************************************************************************
*                                                                      *
*                      N A S C O M     B A S I C                       *
*             Additional commands added to take advantage              *
*             of the features of the LM80C Color Computer              *
*           and changes made to the original Microsoft BASIC           *
*                                                                      *
************************************************************************
*                                                                      *
*                             Version  3.4                             *
*                             (2020/03/29)                             *
*       This release covers the LM80C FIRMWARE R3.4 and above          *
*                                                                      *
************************************************************************
*                                                                      *
*                              N O T I C E                             *
*                                                                      *
*        This could be the last release of the current manual          *   
* in TEXT format. From now on, please download and use the ODT version *
*   instead, that will be updated regolarly and considered the "main"  *
*          and "official" reference manual for LM80C BASIC             *
*                                                                      *
************************************************************************

                        1. SIGNIFICANT CHANGES
                        ----------------------

1.1 Video VS Console
--------------------
The most significant difference between the original Microsoft BASIC
released for NASCOM computers is the usage of the screen instead of the
terminal or console devices. The main output device is the video:
the console output is at the moment left for compatibility reasons.
When writing a program of your own or running one such of those found
anywhere on internet, keep in mind that the LM80C computer will always
and primarily print output on the screen, so please adapt/modify the
source to take care of such behaviour.

1.2 Memory
----------
NASCOM Basic was originally released for machines that had a limited
amount of RAM, i.e. 4/8 KB. Surely, they could be expanded and several
users reached 16/24/32 KB of memory and more but this wasn't the
standard. The LM80C Color Computer actually comes with 32 KB od SRAM so
don't hesitate to use all of this room. Just keep in mind that the
original limit on the lenght of a inputted line is still fixed at 72
chars. But, apart from that, you can enter bigger programs.
------------------------------------------------------------------------

                       2. REMOVED STATEMENTS
                       ---------------------

Some statements have been removed from the interpreter due to the fact
that they laid over the original NASCOM machines. They are:
CLOAD/CSAVE: they loaded/stored data from/to an external mass storage
device
LINES: set the lines to be printed simultaneously
MONITOR: it launched the MONITOR program
NULL: it set the number of null chars to be printed after a carriage
return
PSET: it set a video pixel on
POINT: it returned the state of a video pixel
------------------------------------------------------------------------

                3. STATEMENTS WITH DIFFERENT BEHAVIOUR
                --------------------------------------

Some statements have been changed from their original behaviour. They
are:
SCREEN: changes the video mode
RESET: resets the system
------------------------------------------------------------------------

                        4. NEW STATEMENTS
                        -----------------

There are a lot of new statements, used to take advantage of the
different (and much powerful) hardware of the LM80C.
But, firstly let's start with a big thanks to Grant Searle, from whose
BASIC comes the LM80C version, that added some useful statements (they
are marked with a "*GS*").

4.1 New number representations
------------------------------
The same number can be represented in several different bases. The
usual base is the decimal one, where every single can only be the
usual numerical digits from 0 to 9. LM80C BASIC supports other bases
for numbers:
&Hxxxx: hexadecimal base. *GS*
&Bnnnn: binary base. *GS*

4.2 New functions
-----------------
A function is a statement that gets an input paramether and returns
another data, that depends on the way it processed the input.

BIN$: returns the binary representation of a number. *GS*
HEX$: returns the hexadecimal representation of a number. *GS*
INKEY: returns the ASCII code of the key being pressed
SSTAT: reads the registers of the PSG
TMR: returns the value of the system timer
VPEEK: reads from VRAM
VSTAT: returns the value of status register of the VDP

4.3 New commands
----------------
Commands are statements that tell the system to perfom a specific
operation. Commands can get some paramethers but usually don't return
any value. Here are the new commands:

CIRCLE: draws a circle
COLOR: set the foreground, background, and border colors
CLS: clears the screen
DRAW: draws a line
LOCATE: position the cursor onto the screen
PAUSE: pauses the execution of the code for a certain bit of time
PLOT: draws a pixel point
RESET: resets the system
SCREEN: changes the display mode
SERIAL: open a serial communication line
SOUND: plays a sound tone
SREG: writes into a PSG register
SYS: executes an assembly routine
VOLUME: sets the volume of the PSG audio channels
VPOKE: writes into VRAM
VREG: writes into a VDP register
XOR: make a XOR between operators

------------------------------------------------------------------------

                        5. LANGUAGE REFERENCE
                        ---------------------

[nnnn] statements
-----
Syntax: [nnnn] [list of statements]

A number before a single statement or a list of them introduces a
program line that, when RETURN is pressed, is stored into memory. If the
line doesn't exist, the new line is saved as it, otherwise if the line
is already present it will be replaced byt the current one. Any line
starting with a number is interpreted as a program line: if nothing
follows the number the BASIC interpreter first will look for a stored
line with the same number. If found, it will be deleted from memory.
If no program lines corresponds, an error of "Undefined line number"
will be raised. The maximum allowed value for a line number is 65,529.

Examples:

10 PRINT "HELLO"  -> when RETURN is pressed, the line is stored into
                     memory
10 PRINT "WORLD"  -> when RETURN is pressed, this line will substitute
                     for the current line into memory
10                -> when RETURN is pressed, the line whose number is
                     10 will be deleted from memory
------------------------------------------------------------------------

&B
--
Syntax: &Bnnnn

Binary base. It interprets the "nnnn" value as a binary value (signed
int). "n" can be made only by "0" or "1" numbers.

Example:
?&B1000  => prints value 8
------------------------------------------------------------------------

&H
--
Syntax: &Hxxxx

Hexadecimal base. It interprets the "xxxx" value as an hexadecimal value
(signed int). Each "x" can be any number between 0 and 9 and any char
between A (10) and F (15).

Example:
?&H0F  => prints value 15
-----------------------------------------------------------------------

ABS
------
Syntax: ABS(X)

Returns the absolute value (i.e. with no sign) of the expression "X".

Examples:
ABS(12.4) => 12.4
ABS(-75) => 75
-----------------------------------------------------------------------

AND
---
Syntax: A AND B

Logic operator used in boolean expressions. AND performs a logical
conjuntion. The interpreter supports 4 boolean operators: AND, OR, XOR,
and NOT, each of them work with 16-bit signed integers. They convert
their inputs in 16-bit integers and return a value in such format. This
means that the result is true only if both expressions A and B are true.
The result of an AND operation follows the truth table below (1=T=true,
0=F=false):
0 AND 0 = 0
0 AND 1 = 0
1 AND 0 = 0
1 AND 1 = 1
See also NOT, OR, and XOR.

Examples:
10 AND 1 => 0 (because 10=1010b so 1010 AND 0001 = 0000)
11 AND 1 => 1 (because 11=1011b so 1011 AND 0001 = 0001)
-----------------------------------------------------------------------

ASC
---
Syntax: ASC(X$)

Returns the ASCII code of the first character of the string "X".

Example:
ASC("A") => 65
ASC("AB") => 65
-----------------------------------------------------------------------

ATN
---
Syntax: ATN(X)

Returns the arctangent of "X". The result is in RADIUS in range
-pi/2 to pi/2

Example:
ATN(2) => 1.10715
-----------------------------------------------------------------------

BIN$
----
Syntax: BIN$(X)
Converts an expression into a string containing the binary value.

Example:
BIN$(12) => "1010"
-----------------------------------------------------------------------

CHR$
----
Syntax: CHR$(X)

Returns a string containing the character whose ASCII code is
represented by expression X.

Example:
CHR$(65) => "A"
-----------------------------------------------------------------------

CIRCLE
------
Syntax: CIRCLE x,y,radius[,color]

Draws a circle whose center is at X,Y coordinates. X can range from 0 to
255, Y can range from 0 to 191. "radius" can range from 0 to 255. If
"color" is passed, the circle will be drawn with the specified color,
otherwise the foreground color will be used (see COLOR).
Points of the circumference that come out of the screen won't be paint-
ed.

Example:
CIRCLE128,96,25 => draws a circle centered in the middle of the screen
                   with a diameter of 50 pixels (radius=25)
-----------------------------------------------------------------------

CLEAR
-----
Syntax: CLEAR
        CLEAR X

The call of CLEAR with no paramethers set the contents of all the
numeric variables stored in memory to 0 and of the string variables to
"" (empty string).
If called with a numeric expression, it sets the string space to the
value of expression "X". At startup, the string space is set by default
to 100. See the string chapter for more info.

Examples:
CLEAR => clears every variable
CLEAR 200 => sets the string space to 200 chars
-----------------------------------------------------------------------

CLS
---
Syntax: CLS

Clears the current screen, intializes the pattern cells. The filling
value is graphic mode dependant: in modes 0, 1, & 4 the video buffer is
filled up with ASCII value 32 (the "space" character) while in modes
2 & 3 the command simply resets the pixels of the screen. Finally, in
text modes, it moves the cursor at coordinates 0,0 (the top left
corner). CLS clears the screen by using the background color set with
COLOR statement.
Same behaviour can be obtained in text modes by pressing together the
SHIFT + CLEAR/HOME keys.
-----------------------------------------------------------------------

COLOR
-----
Syntax: COLOR foreground[,background][,border]

Sets the colors of the screen. It can have 1 to 3 arguments, depending
of the current video mode. "Foreground" sets the color of the text or of
the pixels being printed on screen; "background" sets the color of the
background parts, while "border" sets the colors of the borders of the
image (the parts over the top, right, bottom, and left of the display).
Values range from 1 to 15:
1: black                        9:  light red
2: medium green                 10: dark yellow
3: light green                  11: light yellow
4: dark blue                    12: dark green
5: light blue                   13: magenta (purple)
6: dark red                     14: gray
7: cyan (aqua blue)             15: white
8: Medium red

In SCREEN 0 (text mode), only the first 2 params are allowed since the
background and border colors coincide. In SCREEN 3 (multicolor mode)
only the border color is allowed.
When in graphic mode 2, the color of the pixels painted by PLOT, DRAW,
and CIRCLE commands, when not specified, is the foreground color set by
COLOR.

Examples:
COLOR 1,15,5 => in SCREEN 1 it sets the text in black, the background in
                white, and the border in light blue
COLOR 15,5   => in SCREEN 0 it sets the text to white on light blue
                background (this is the default combination)
COLOR 3      => in SCREEN 3 sets the border color to light green
-----------------------------------------------------------------------

CONT
----
Syntax: CONT

Given after an error that halted the execution of a program, forces
the interpreter to continue with the line after the one that raised
the error.
-----------------------------------------------------------------------

COS
---
Syntax: COS(X)

Returns the cosine of "X". The result is in RADIUS in range -pi/2 to
pi/2.

Example:
COS(10) => -0.839072
-----------------------------------------------------------------------

DATA
----
Syntax: DATA <list>

Introduces a list of informations used by the program itself. "list"
can be a list of numerical or strings separated by commas and read with
the READ statement. A string can be inserted without quotation marks
but, if the string must contain any space, their use is needed.
See also RESTORE.

Example:
10 DATA 20,30,40  => numericals
20 DATA " HELLO ",LM80C => Note the usage of quot.marks to include
                           space in the first string
-----------------------------------------------------------------------

DEEK
----
Syntax: DEEK(X)

Reads a word from memory cells given by the expression X and X+1. A word
is a 16-bit value stored in 2 contiguos memory cells: X contains the
low byte while X+1 contains the high byte. 

Example:
A=DEEK(1000) => reads the word at 1000/1000+1 and stores it into A
-----------------------------------------------------------------------

DEF
---
Syntax: DEF FNXXX(Y)=<expression>

Creates an user-defined function that expands the built-in functions of
the interpreter. XXX is the name of the new function and must follow
the FN statement and must be a valid variable name; Y is the paramether
passed, and it must be a valid variable name too; "expression" is the
newly defined function. Limits: everything must reside in 72 chars (the
lenght of a standard line); only one paramether is allowed. To call the
function just use the FNXXX name.

Example:
10 DEF FNRAD(DEG)=3.14159/180*DEG:REM SETS THE FUNCTION
20 PRINT FNRAD(100):REM FUNCTION CALL (PRINTS 1.74532)
-----------------------------------------------------------------------

DIM
---
Syntax DIM <V>(<I>,[J])[,....]

Allocates space for array variables. More than one array can be
dimensioned with one DIM statement. Array can have one ore two
dimensions. If an array is used without being dimensioned, it is
assumed to have a maimum subscript of 10 (i.e., eleven elements from 0
to 10). So, for example A(I,J) is assumed to have 121 elements, unless
otherwise dimensioned.

Examples:
DIM A(10) => monodimensional array, elements numbered from 0 to 10
DIM B(5,5) => bidimensional array, indexes fro 0 to 5 (36 elements).
-----------------------------------------------------------------------

DOKE
----
Syntax: DOKE X,Y

Writes a word value (a 16-bit number) into a couple of contiguos memory
cells. X and Y must be valid numericals, in any supported format. The
low byte of Y will be written into location X while the high byte of Y
will be written into location X+1.

Example:
DOKE &H8100,&HAABB => cell $8100 will contain $BB
                      cell $8101 will contain $AA
-----------------------------------------------------------------------

DRAW
----
Syntax: DRAW X1,Y1,X2,Y2[,color]

Draws a line starting from point with coordinates X1,Y1 to point with
coordinates X2,Y2. If "color" is specified, the line will be drawn with
that color (see "COLOR" for color codes), otherwise the foreground
color will be used. X1 and X2 must be in range 0~255, X1 and Y2 must be
in range 0~191: 0,0 if the top-left corner while 255,191 is the bottom-
right corner. Due to hardware limitations of the VDP "Video Display
Processor", for every single portion of screen of 8x1 pixels there can
only be 1 primary color: if a line of one color intersects a line of
another color, the pixels of the crossing byte will get the last color
used. The direction of drawing is always from X1,Y1 to X2,Y2, regardless
of which location each pair of coordinates has on the screen. 

Example:
DRAW0,0,255,191,7 => draw a diagonal from top left to bottom right in
                     cyan color
-----------------------------------------------------------------------

END
---
Syntax: END

Terminates the execution of a program. Any statements and/or program
lines following the END statement will be ignored and control will
return to the editor. There is another instruction to halt the execution
of the program, STOP: the difference is that the latter interrupts the
code flow with a "BREAK" message (as if the RUN STOP key would have been
pressed) while END behaves has the interpreter would have reached the
last line of the program.

See also: STOP
-----------------------------------------------------------------------

EXP
---
Syntax: EXP(X)

Returns e to the power X. X must be lesser or equal to 87.3365.

Example:
EXP(2) => 7.38905
-----------------------------------------------------------------------

FN
--

See "DEF"
-----------------------------------------------------------------------

FOR
---
Syntax: FOR <var> = <X> TO <Y> [STEP <Z>] /instructions/ NEXT <X>[,...]

The FOR..NEXT statements are used to create loops, i.e. a sequence of
instructions that have to be repeated for a certain number of times.
<var> is a valid name of a variable that will contain the value
incremented during the loop and used for the ending test. X, Y, and Z
are expression. X is the starting value and it is assigned to <var> at
the beginning of the loop. Then, the instructions between FOR and NEXT
statements are executed. When the NEXT is reached, if X is lesser
than Y, the value of Z if present, is added to <var> and tested against
Y: if <var> is greater then Y the loop is terminated and the execution
continues from the first instruction after the NEXT statement; otherwise
the loop is repeated.
If Z is not present, the increment is assumed to be 1. If Z is negative,
the loop decrements the value of <var> from X to Y.
FOR..NEXT loops can be nested: the only limit is the amount of memory.

One or more loop variables can follow the NEXT statement, altough the
first variable must refer to the recent loop, the second of the most
recent one and so on. If no variable is present, the NEXT statement 
refers to the most recent FOR statement.

Examples:
FOR I=1 to 10:PRINT I:NEXT I => repeats the loop 10 times (from 1 to 10)

10 FOR I=1 to 10
20 FOR J=1 TO 20
30 PRINT A(I,J)
40 NEXT J,I => repeat 2 loops, J is the first because is the most recent
-----------------------------------------------------------------------

FRE
---
Syntax: FRE(X)

If X is a numerical expression, FRE returns the memory available for
BASIC environments. If the expression is a string, it returns the
available space in the string space. See CLEAR for more details. 

Examples:
FRE(0) => returns the memory available for BASIC (programs and vars)
FRE("") => returns the free space in the string space
-----------------------------------------------------------------------

GOSUB
-----
Syntax: GOSUB <line>

Jumps at <line> to execute a portion of code. When the interpreter
will encounter the RETURN statement, it will resume the execution at
the instruction following the GOSUB statement.
See also RETURN.

Examples:
10 GOSUB 30 => jumps to 30
20 END => resumes from here
30 PRINT "HELLO" 
40 RETURN => return to caller
-----------------------------------------------------------------------

GOTO
----
Syntax: GOTO <line>

Makes an unconditional jump to another point of the program indicated
by <line>. 

Example:
10 GOTO 100
-----------------------------------------------------------------------

HEX$
----
Syntax: HEX$(X)

Converts the numerical expression X into a string containing the
hexadecimal representation of the value of X. X must be a signed integer
with value in range -32,768/+32,767.

Example:
HEX$(1000) => "3E8"
-----------------------------------------------------------------------

IF
--
Syntax: IF cond THEN [...]
        IF cond GOTO <line>
        IF cond THEN <line>

IF is a conditional branch. It serves to change the order of the
execution of the instructions of a programs instead of the ordinary
sequential flow. "cond" can be any valid arithmetic, relational, or
logical expression: if it is evaulated true (i.e. non-zero), the
statements after IF are executed.

There are several allowed formats of the statement. If the expression is
true, anything that follows THEN will be executed:
10 IF A=1 THEN PRINT "A IS EQUAL TO 1":GOTO 100

If there is only a GOTO instruction after the expressio to be evaluated,
the THEN statement can be omitted:
10 IF A=1 GOTO 100

If there is only a jump instruction (GOTO) after the IF, another form
can be used where GOTO is omitted and THEN is followed by the line
number:
10 IF A=1 THEN 100
-----------------------------------------------------------------------

INKEY
-----
Fomart: INKEY(X)

When used inside a program (usage in indrect mode is now allowed), this
function returns the ASCII code of the code being pressed by the user.
X can vary between 0 and 1,023 and represents the interval the function
has to wait for the user's input before return control to the program.
If X is 0 the function won't wait any time: it will read the input
buffer and return the code being present, otherwise it will wait for
the corresponding number of hundredths of seconds before to return.
The results are 0 for no key being pressed. The last key being pressed
is always inserted into a temp buffer used by INKEY so if the user is
asked to press a key AFTER a certain moment, it is reccomended to
make a null read before the real one. Another good way of working is to
make a little IF..THEN loop and leave it when INKEY returns 0 to be sure
to read only the requested keys. SInce the function read the keys very
fast, it is suggested to introduce a delay of at least 5 to let
the user be able to press a key.

Examples:
10 INKEY(0):REM EMPTIES THE BUFFER
20 A=INKEY(10):IFA=0THEN10:REM REPEAT UNTIL A KEY IS PRESSED
30 PRINT CHR$(A):REM PRINT PRESSED KEY CODE

10 A=INKEY(500):REM WAIT A KEY FOR 5 SECONDS
20 IF A=0 THEN PRINT "NO KEY PRESSED":GOTO 40
30 PRINT "KEY PRESSED: ";CHR$(A)
40 END
-----------------------------------------------------------------------

INP
---
Syntax: INP(X)

Reads a byte (an 8-bit value) from the I/O port specified by the
expression X. X must be in range 0-255.

Example:
A=INP(1) => read a byte from port 1 and assign it to A
-----------------------------------------------------------------------

INPUT
-----
Syntax: INPUT [<prompt text>;]<list of variables>

Reads one or more data from the standard input and assign it to the
same number of variables. The interpreter prompts the user with a 
question mark, then he/she must insert some data and press the ENTER
key. If more than one data is requested, each one must be separated
by a comma, and the user must be enter the exact amount of values with
the correct type, separated by commas. If the data is invalid, i.e. a
string when a number was expected, the interpreter will print a "REDO
FROM START?" error and the user will be asked to re-enter the data; if
more data was requested than entered, a "??" will be printed and the
interpreter will ask for the missing ones; if more data was entered
than requested, an "EXTRA IGNORED" advice will be printed and the
execution will continue discarding the extra values. If a prompt text
is passed, it will be printed on screen before the question mark. The
prompt text must be enclosed in double quotation marks and followed by a
semicolon. 

Examples:
INPUT "WHAT'S YOUR NAME";NAME$ => waits for a string
INPUT "NAME,AGE";NAME$,AGE => waits for 2 data (a string and a number)
INPUT A => wait for a number with just a "?"
-----------------------------------------------------------------------

INT
---
Syntax: INT(X)

Returns the integer part of X. X must be a numerical expression. The
result is obtainded by truncating X to the decimal point. If X is
negative, the round is made to the first integer greater than X.

Examples:
INT(3.14) => 3
INT(-3.14) => -4
-----------------------------------------------------------------------

LEFT$
-----
Syntax: LEFT$(X,I)

Returns a string that contains the I characters to the left of the
string X.
See also RIGHT$ and MID$.

Example:
LEFT$("HELLO",2) => "HE"
-----------------------------------------------------------------------

LEN
---
Syntax: LEN(X)

Returns the lenght of the string X.

Example:
LEN("HELLO") => 5
-----------------------------------------------------------------------

LET
---
Syntax: LET <var>=<val>

Assigns the value <val> to the variable with name <var>. The use of LET
is optional and this statement can be omitted.

Example:
LET A=10   is equal to   A=10
-----------------------------------------------------------------------

LIST
----
Syntax: LIST [start][[-][end]]

Lists a program stored in memory. LIST without arguments will print
the whole program. If <start> is passed, only the specified line will be
printed. <start> followed by "-" will print the line passed as argument
and all the following ones. If <end> is passed precede by "-", only the
lines up to <end> will be printed. If both <start> and <end> are passed,
only the lines included into the two intervals will be printed. If
<start> isn't present in memory, the next line is considered: same for
<end>. During the listing, a press of "SPACE" key will pause the
printing: to resume it, just press the "SPACE" key another time, to halt
it press the "RUN/STOP" key. Same behavior is obtanied by pressing the
latter while listing.

Examples:
LIST  => list the whole program stored into memory
LIST 100  => list line 100
LIST -100 => list lines from beginning to 100
LIST 100- => list lines from 100 to end of program
LIST 50-100 => list lines from 50 to 100
-----------------------------------------------------------------------

LOCATE
------
Syntax: LOCATE X,Y

Places the cursor on the screen at coordinates X,Y. LOCATE works only
in graphic modes 0 & 1. Y is in range 0~23 while X is in range 0~31/39,
depending on which mode is active at the moment: graphic 1 is 32 chars
wide while graphic 1 is 40 chars wide. Coordinates 0,0 point to the top
left corner. The usage of this command makes no sense in screen modes
2 & 3 since they don't have any cursor support.

Examples:
LOCATE 0,0 => place the cursor in the top left corner
LOCATE 0,9 => place the cursor at the first cell of the 10th row
-----------------------------------------------------------------------

LOG
---
Syntax: LOG(X)

Returns the natural logarithm of X. X must be greater than 0.

Example:
LOG(10) => 2.30259
-----------------------------------------------------------------------

MID$
----
Syntax: MIDS$(X,I[,J])

Returns a portion of string X. If J is omitted, it returns the I right-
most characters of X; if J is passed, it returns the chars between the
Ith and the Jth.

Examples:
MID$("HELLO",3) => "LLO"
MID$("HELLO",3,2 = > "LL"
-----------------------------------------------------------------------

NEW
---
Syntax: NEW

Deletes the current program in memory and clears every variable. Used
before to enter a new program without the need to reset the system.

Example:
NEW
-----------------------------------------------------------------------

NEXT
----
Syntax: NEXT <list of variables>

Used in FOR loops. See FOR for details.
-----------------------------------------------------------------------

NOT
---
Syntax: NOT X

Logic operator used in boolean expressions. NOT performs a logical
negation, or bitwise complement, of X. The interpreter supports 4
boolean operators: AND, OR, XOR, and NOT, each of them work with 16-bit
signed integers. They convert their inputs in 16-bit integers and return
a value in such format. NOT returns the complement of value X, meaning
that the result is true when X is false and vice-versa. The truth table
of NOT operator is shown below (1=T=true, 0=F=false):
NOT 1 => 0
NOT 0 => 1
See also AND, OR, and XOR.

Note:
Since the interpreter works with 16-bit signed numbers, one could think
that in some cases it works in a strange manner:
NOT 1 => -2
NOT 0 => -1

Indeed, the results are OK. NOT 0 should return 1 but, since the two's
complement of sixteen zeros is sixteen ones, which is the two's
complement representation of -1. Similarly, NOT 1 should be 0 but since
the 16-bit value of 1 is the binary 0000000000000001, the bit complement
of it is 1111111111111110 that is the two's complement of -2.
Eventually, NOT X is equal to -(X+1).
-----------------------------------------------------------------------

ON
--
Syntax: ON X GOTO <list of lines>
        ON X GOSUB <list of lines>

Used in conjunction with GOTO and GOSUB to introduce a series of
unconditional jumps (GOTO) or calls to subroutines (GOSUB). X must be
a numerical expression: the jump is executed by calling the line whose
position corresponds to the value of X. The lines must be separated by
columns.

Examples:
ON A GOTO 100,200,300
ON B GOSUB 1000,2000,3000
-----------------------------------------------------------------------

OR
--
Syntax: X OR Y

Logic operator used in boolean expressions and bitwise operations. OR
performs a logical disjunction operation. It returns a true value when
one or both the expressions are true. The interpreter supports 4 boolean
operators: AND, OR, XOR, and NOT, each of them work with 16-bit signed
integers. They convert their inputs in 16-bit integers and return a
value in such format. Its truth table is the following (1=T=true,
0=F=false):
0 OR 0 = 0
0 OR 1 = 1
1 OR 0 = 1
1 OR 1 = 1
See also AND, NOT, and XOR.

Example:
4 OR 2 => 6 (4 is 100b, 2 is 10b, so 100b OR 010b = 110b, that is 6 in
            decimal representation)
-----------------------------------------------------------------------

OUT
---
Syntax: OUT X,Y

Sends Y to the peripherical device connected to output port X. X and Y
must be expressions with values in range 0~255.

Example:
OUT 1,100
-----------------------------------------------------------------------

PAUSE
-----
Syntax: PAUSE X

Forces the system to halt and wait for a specific interval of time set
by X. X must be a numerical expression in range 0~65,535 that represents
the number of 100ths of a second to wait.

Examples:
PAUSE 1000 => wait for 10 seconds (1,000 x 0.01s)
PAUSE 0 => no wait. this is similar to the assembly instruction NOP
-----------------------------------------------------------------------

PEEK
----
Syntax: PEEK(X)

Returns the byte stored in RAM at location X. X must be a numerical
expression in range -32,768 to 32,767 (i.e. a 16-bit signed integer).

Example:
PRINT PEEK(8000) => prints the contents of address 8000.
-----------------------------------------------------------------------

PLOT
----
Syntax: PLOT x,y[,color]

Plots a pixel onto the screen. This command only works in SCREEN mode 2.
"x" and "y" are the coordinates where to set the pixel. "color" is
optional: if not passed, the color used is the default one set with the
COLOR command or, in case you are plotting into an 8x1 pixel area that
already has a pixel colored with a color different from the foreground
color set with COLOR, the former will be used.
"x" must be in range 0~255 while "y" in range 0~191. The coordinates 0,0
correspond to the pixel in the top left corner of the screen.

Example:
PLOT 0,255  => plot a pixel into the top right corner of the screen
-----------------------------------------------------------------------

POKE
----
Syntax: POKE X,Y
Writes the byte Y into the location of RAM whose address is X. X must be
a numerical expression in range -32,768 to 32,767 (i.e. a 16-bit signed
integer), Y an expression whose value is in range 0~255.

Example:
POKE -28672,128 => writes 128 into memory cell located at 36,864 (just
remember that numbers are 16-bit signed so everything greater than 
32,767 must be provided in two's complement)
-----------------------------------------------------------------------

POS
---
Syntax: POS(X)

In origin it returned the current position of the terminal's printer
head. Now it returns the horizontal position of the cursor during a
print on video. Note: it doesn't return the X position of the cursor on
the screen, and its behaviour may change in future releases.
-----------------------------------------------------------------------

PRINT
-----
Syntax: PRINT [data|variables|text|operations]

The PRINT statement prints something on screen. It supports different
types of expressions: it can print the contents of variables, text
included between double quotation marks, the results of numerical
expressions, numerical literals. The interpreters considers the printing
line divided in zones of 14 spaces each: if expressions are separated by
commas the interpreter prints each expression at the beginning of such
spaces. If a semicolon is used (;) the expressions are printed one after
another. If neither of them are present, then the interpreter will
go to the next line after the ending of the print statement.

Examples:
PRINT => just go to next line
PRINT "HELLO" => prints HELLO and then a carriage return is inserted
PRINT A => prints the value of variable A
PRINT "LENGHT:";LN;" METERS" => prints LENGHT followed by the contents
                                of LN and then by METERS
PRINT A,B => prints the contents of A and B with tabulation
-----------------------------------------------------------------------

READ
----
Syntax: READ <list of variables>

Reads the informations stored into the program with DATA statement.
<list of variables> is a set of variables names separated by commas. The
The effect of READ statement is to read the value introduced by DATA and
store it into the variables following READ, from left to right. If the
informations to be read are less than the variables names an error will
be raised. If there are more values stored in DATA than are read from
a READ, the next READ will continue to read from the next unread data.
Types of variables and informations must be coherents (i.e. a string
can not be assigned to a numerical variable).
See also RESTORE.

Example:
10 DATA 10,20,"HELLO"
20 READ A,B,C$ => 10 will be written into A, 20 into B, and "HELLO" in C
-----------------------------------------------------------------------

REM
---
Syntax: REM <comment>

Used to enter a comment into the program. Everything that follow the REM
statement will be ignored.

Example:
10 X=10:REM SETS HERE THE STARTING VALUE
-----------------------------------------------------------------------

RESET
-----
Syntax: RESET

Originally used to reset (set to off) a video pixel, now (without any
additional paramether) performs a system reset.
-----------------------------------------------------------------------

RESTORE
-------
Syntax: RESTORE [line_num]

After a RESTORE statement the next information read with a READ state-
ment will be the first value of the first DATA into the program. If
[line_num] is passed, the next information read will be the one stored
at such line number: this permits to read the same informations several
times.
See also DATA and READ.

Example:
10 DATA 10,20,30
20 READ A => A will contain 10
30 RESTORE: READ B => B will also contain 10
-----------------------------------------------------------------------

RETURN
------
Syntax: RETURN

Used to leave a sub-routine called by GOSUB. After the RETURN statement,
the execution of the program will continue with the instruction
following the GOSUB statement.

Example:
10 GOSUB 100
20 PRINT "FINISH":END
100 PRINT "START"
110 RETURN  => the execution will continue from line 20
-----------------------------------------------------------------------

RIGHT$
------
Syntax: RIGHT$(X,I)

Returns a string that contains the I characters to the right of the
string X.
See also LEFT$ and MID$.

Example:
RIGHT$("HELLO",2) => "LO"
-----------------------------------------------------------------------

RND
---
Syntax: RND(I)

Returns a random number between 0 and 1. A negative value of X will
start a new sequence; if X is greater than zero the function will return
the next value in the random sequence; a value of zero will return the
last number returned. The same negative number will generate the same
random sequence.
See also TMR.

Examples:
A=RND(1) => returns a random number
A=INT(RND(1)*6)+1 => rolls a dice: will return a number between 1 and 6.

If you need to create a good random sequence you can use the system
tick timer used to increment the 100ths of second counter:
RND(-ABS(TMR(0)))
-----------------------------------------------------------------------

RUN
---
Syntax: RUN [numline]

Start the execution of the program currently stored in memory. If
[numline] is passed, the execution will start from such line, otherwise
it will start from the first line.

Example:
RUN  => start the execution of the program from the first line
RUN 1000 => start the execution of the program from line 1000
-----------------------------------------------------------------------

SCREEN
------
Syntax: SCREEN mode[,spriteSize][,[spriteMagn]]

Change the screen mode. "mode" is a number between 0 and 4 and sets the
screen as follow:
0: 40x24 chars text mode (no sprites support)
1: 32x24 chars text mode or 256x192 pixels graphic mode (sprites supp.)
2: 256x192 pixels graphic mode (sprites supported, bitmap mode)
3: 64x48 pixels multicolor graphic mode (sprites supported)
4: 256x192 pixels text/graphics mode (limited sprites support)

SCREEN initializes the screen with default settings, meaning that it
sets for each mode specific foreground, background, and border colors:
in modes 0, 1, & 4, the default settings include background and border
colors set to light blue while text set to white; in modes 2 the back-
ground is white, the foreground is black and the border is light blue;
in mode 3 the background is white and the border is light blue, while no
specific foreground is set. In modes 0 & 1 it also loads and configures
a complet charset with 256 chars, since these two are also text modes:
the big difference is that mode 0 is a real text mode, with no support
for sprites and graphics, while mode 1 is a graphics mode where each
char is in reality a tile. In every mode, SCREEN also performs a screen
clear. 

SCREEN 4 is a special, not ufficially supported yet still documented,
mode that is a mix between SCREEN 1 and SCREEN 2. In SCREEN 4 the video
buffer is divided into 768 cells each of those can be assigned to one
8x8 pattern, like in mode 1, but where the colors are managed for single
bytes (8x1 pixels). It lacks in sprite supporting: only 8 sprites can
be used, if you try to some more they will start to duplicate them-
selves.

Examples:
SCREEN 0  => sets the 40x24 chars text mode
SCREEN 2  => sets the bitmap graphic mode

If "spriteSize" and "SpriteMagn" are passed, then SCREEN also sets the
size and magnification attributes for sprites. Arguments can assume
value of 0 or 1:
spriteSize: 0=set sprites to 8x8 pixels
            1=set sprites to 16x16 pixels

spriteMagn: 0=no sprite magnification
            1=set sprite magnification to ON, so that 8x8 sprites
            become 16x16 and 16x16 sprites become 32x32

Note the sprite magnification halves their video resolution so that
when a sprite is magnified each pixel occupies a 2x2 pixels on the video
grid.

You can just pass one argument of the two, in this case it is assumed
that it will be interpreted as the sprite size argument.

Examples:
SCREEN 1,0,0 => this corresponds to SCREEN 1, sprites are set to 8x8
                pixels and sprite magnification is off
SCREEN 1,1,0 => screen mode 1 with sprites size set to 16x16 (the last
                argument can be omitted)
SCREEN 1,1   => same as above
SCREEN 1,0,1 => sprites size set to 8x8, sprite magnification on

Obviously, the sprite size and magnification arguments are revelant only
when used in graphics modes that support the sprite visualization.

Further reading: to better know the video capabilities of the VDP the
reading of its reference guide is reccomended. A copy can be found here:
https://github.com/leomil72/LM80C/tree/master/manuals

See also: CLS and COLOR
-----------------------------------------------------------------------

SERIAL
------
Syntax: SERIAL ch,bps[,data,par,stop]

Opens a serial connection between the computer and an external device.
"ch" can be 1 or 2: 1 corresponds to SIO channel A, while 2 to SIO
channel B. In LM80C computer the channel A is connected to a USB-to-
-serial converter so that serial port 1 works only as a char device,
while channel B (port 2) is configured as a block device. "bps"
indicates the bauds per second, i.e. the speed of the serial line. "bps"
can assume one of the following values:
57600,38400,28800,19200,14400,9600,4800,3600,2400,1200,600,1,0

1 and 0 are special values that will be analized below. If a valid value
for <bps> is entered, the serial line will be set to run at the selected
speed. <data> represents the number of bits that compose the data to be
sent: allowed values are 5/6/7/8. 5 is used to instructs the SIO to work
with a number of 5 bits (or less) per single char. <par> is the parity
bit: it can be 0/1/2. 0 means no parity bit; 1 means an odd parity; 2
means an even parity. <stop> sets the number of bits sent after the data
bits. Its value must be: 0, for no stop bits; 1, for 1 stop bit; 2, for
1.5 stop bits; 3, for 2 stop bits. Opening a serial line leads to the
corresponding status LED to be turned on.

Example:
SERIAL 1,19200,8,0,1  => normal settings to open a serial line with
                         19,200 bps, 8 data bits, no parity bits,1 stop
                         bit

If the user tries to re-open a serial communication on a port already
opened, an error will be raised:

SERIAL 1,19200,8,0,1
Ok
SERIAL 1,38400,8,0,1
Serial Port Already Open Error
Ok

If 0 is entered as <bps>, the other arguments are ignored and the
command closes the connection opened on channel <ch>:

SERIAL 1,0 => closes the serial port 1, resetting the SIO channel A.

The Z80 SIO peripheral chip has an internal buffer that can stores up to
3 chars: if fourth char is received while the CPU hasn’t collected one
of the incoming chars yet, then a buffer overrun occours. The BASIC
interpreter will disable the serial line functionalities (no incoming
chars will be accepted, no outgoing chars will be sent, while the line
will still remain open) and the corresponding status LED will be turned
on. This condition will remain until the user will call the SERIAL
command with the special value of 1 for bps, that re-activates the
normal port operation.

SERIAL 1,1	=> re-activates the RX/TX transmission after a buffer
               overrun condition

Further reading: to better know the serial capabilities of the SIO chip,
the reading of the Z80 peripherals' user manual is reccomended. A copy
can be found here:
https://github.com/leomil72/LM80C/tree/master/manuals
-----------------------------------------------------------------------

SGN
---
Syntax: SGN(X)

Returns the sign of X: it returns -1 if X is negative, 1 if it is 
positive, or 0 if it is zero.

Example:
PRINT SGN(-345) => -1

An interesting usage of SGN is in combination with conditional jumps
where a specific set of istructions can be executed depending of the
sign of a variable being checked:

Example:
10 ON SGN(X)+2 GOSUB 100,200,300

In this example, the program will continue from line 100 if X<0, from
line 200 is X=0, and from line 300 if X>0.
-----------------------------------------------------------------------

SIN
---
Syntax: SIN(X)

Returns the sine of "X". The result is in RADIUS in range -pi/2 to pi/2.

Example:
SIN(5) => -0.958924
-----------------------------------------------------------------------

SOUND
-----
Syntax: SOUND ch,tone,dur

This command instructs the PSG to emit a sound with a particular tone
for a specific duration on the selected channel. "ch" can be 1,2, or 3,
and corresponds to the same analog channel of the PSG."tone" can vary
between 0 and 4,095 and it is inversely related to the real frequency of
the emitted tone. The formula to get the frequency is below:

Freq = 1,843,200 / 16 / (4,096 - tone)
(where 1,843,200 Hz is the clock of the PSG while "16" is a fixed
internal prescaler)

I.e.: if tone is equal to 4,000, the frequency of the sound generated
by the PSG will be 1,200 Hz. In fact, 1,843,200 / 16 / 96 = 1,200.
The lower frequency will be 28 Hz while the higher frequency will be
115,200 Hz (115 KHz). Obviously, anything over 15/20 KHz won’t be
audible. "dur" is the duration in 100ths of a second and its range is
between 0 and 16,383 (0.0~163.8 seconds). By setting a tone of "tone" 0
we force the audio to quit immediately. By setting a tone with duration
equals to 0, the tone will last forever, unless you quit the volume off
or you set another tone on the same channel.

The inverse formula to calculate the value "tone" to pass to SOUND to
generate a tone of frequency "freq" is:
tone = 4,096 - (1,843,299 / 16 / (freq))
I.e.: if a tone with a frequency of 2,000 Hz (2 KHz) is required, "tone"
equals to 
tone = 4,096 - (1,843,200 / 16 / 2,000)) = 4,096 - 57.6 => 4,038(.4)
In fact, if we use the previous formula, we get:
Freq = 1,843,200 / 16 / (4,096 - 4,038) = 115,200 / 58 = 1,986 Hz
(due to integer truncatings, the frequency is a little bit smaller than
needed)

Example:
SOUND 1,3500,100 => plays a tone of freq. 193 Hz for 1 second.

There is a speciale usage of SOUND. If used with just a 0 as paramether,
SOUND will reset the PSG registers and shut down every sound generated
by the audio chip, including the white noise and the envelops activated
with SREG.

Example:
SOUND 0  => shut down every king of sound/tone
-----------------------------------------------------------------------

SPC
---
Syntax: SPC(X)

Prints X empty chars on video. It can only be used in conjunction with a
PRINT statement.
Please keep in mind that TAB and SPC are similar but have different
behaviours since the former moves the cursor without altering the chars
before the position to reach while SPC prints empty chars deleting every
char during the movement.

Example:
PRINT "A";SPC(5);"B"
A     B

See also: TAB
-----------------------------------------------------------------------
 
SQR
---
Syntax: SQR(X)

Returns the square root of X X must be greater than zero.

Example:
SQR(9) => 3
-----------------------------------------------------------------------

SREG
----
Syntax: SREG X,Y

Writes the byte Y into the register X of the PSG. X must be in the range
0-15 while Y in the range 0-255. See SSTA for considerations about the
register numbering. Please remember that registers #14 and #15 are used
to read the keyboard so they shouldn't be used.

Example:
SREG 8,15 => set the volume of analog channel A to 15
-----------------------------------------------------------------------

SSTAT
-----
Syntax: SSTAT(X)

Reads the PSG (Programmable Sound Generator) register set by X and
returns a byte. X must be in the range 0-15. Some words must be spent
about the register numbering. The PSG datasheet reports that registers
are divided into 2 sets of 8 elements each, numbered from 0 to 15, resp.
Please remember that registers #14 and #15 are used to read the keyboard
so they shouldn't be used.

Example:
SSTAT(8) => actually reading the register #8.
-----------------------------------------------------------------------

STEP
----
Syntax: STEP <val>

Used in FOR..NEXT loops to set the increment of the index variable.
See FOR for more details.
-----------------------------------------------------------------------

STOP
----
Syntax: STOP

Halts the execution of a program. See CONT on how to resume running.

See also: END
-----------------------------------------------------------------------

STR$
----
Syntax: STR$(X)

Converts the string representation of expression X.

Example:
STR$(12) => "12"
-----------------------------------------------------------------------

SYS
---
Syntax: SYS address[,value]

Calls a machine language routine starting at "address". "address" must
be a signed integer (i.e. in range -32,768 to +32,767). If "value" is
present, it will be passed to the routine into the Accumulator register.
"value" must be a byte value (0~255). SYS differs from USR in the way
that it's a command so there is no return value to be collected.

See also: USR
-----------------------------------------------------------------------

TAB
---
Syntax: TAB(X)

Moves the cursor to column X on the video. X must be in the range 0~255:
0 means no movements.

Example:
PRINT TAB(5);"*" =>
     *

Please keep in mind that TAB and SPC are similar but have different
behaviours since the former moves the cursor without altering the chars
before the position to reach, while SPC prints empty chars deleting
every char under the cursor during its movement.

See also: SPC
-----------------------------------------------------------------------

TAN
---
Syntax: TAN(X)

Returns the tangent of X. The result is in radians.

Example:
TAN(1) => 1.55741
-----------------------------------------------------------------------

THEN
----
Syntax: THEN

Used with IF statement. See IF for more details.
-----------------------------------------------------------------------

TMR
---
Syntax: TMR(X)

Returns the value of the system tick timer, that is a 32-bit counter
that is incremented every hundredth of a second. Since the BASIC
interpreter that only manage 16-bit values, the system timer can be
read by considering it divided into 2 halves: if X is 0 than the
function will return the first two less significant bytes of the
counter. If X is 1, than the two most significant bytes will be returned
instead. 

Example:
TMR(0) => 3456

Since the BASIC operates with signed integers, values returned by TMR()
go from -32768 to +32767. To get the unsigned counterpart, if the value
returned is negative, you can add it to 65536 to get a value in the
range 0 ~ 65535.

Example:
10 A=TMR(0):IF A<0 THEN A=65536+A

The system counter can be used to measure the passing of time by using
the whole 32-bit value of the system tick timer. Also, if you divide 
this value by 100 you get the numbers of seconds elapsed since the
computer has been powered on.

Examples:
PRINT (TMR(1)*65536+TMR(0)) => 273636  (100dths of seconds)
PRINT INT((TMR(1)*65536+TMR(0))/100) => 2736  (seconds)
-----------------------------------------------------------------------

TO
--
Syntax: TO

Used in FOR..NEXT loops to set the range of the index variable. See FOR
for more informations.
-----------------------------------------------------------------------

USR
---
Syntax: USR(X)

Calls an user-defined machine language subroutine with argument "X".
"X" is mandatory: even if it's not used, it must be passed to USR.
The call of the subroutine is made through an entry point in RAM that
must be initialized with the address of the first cell where the
user code is stored in RAM. The entry point is located at locations 
$8049 and $804A: the address must be set using the little-endian order,
meaning that the less significant byte must be stored into $8049 while
the most significant byte must be stored into $804A. Suppose that
a subroutine has been stored in RAM from address $B0A0. Then the byte
$A0 will be stored at $8049 while byte $B0 will be stored at $804A.
USR is a function, so it must be called in a way that can collect the
possible returned value.

Example:
A=USR(0) => call a subroutine with argument 0 and assign its returned
value to A.

See also: SYS
-----------------------------------------------------------------------

VAL
---
Syntax: VAL(X$)

Returns the numerical value of string X$. If the first character of X$
isn't a +,&, or a digit then the result will be 0.

Examples:
VAL("12") => 12
A$="a":PRINT VAL(A$) => 0, because A$ can not be represented as a number
-----------------------------------------------------------------------

VOLUME
------
Syntax: VOLUME X,Y

Sets the volume of the selected channel X to volue Y. X must be in the
range 0~3: 1,2, and 3 works on the corresponding analog channel,
resepectively. If X is 0, the statement will apply to all the channels.
Y must be a numerical value between 0 (no audio) and 15 (max volume).

Example:
VOLUME 0,0 => quits the volume of all the channels.
-----------------------------------------------------------------------

VPEEK
-----
Syntax: VPEEK(X)

Reads a value from the VRAM (or Video-RAM), the memory that is at
exclusive use of the VDP (Video Dislay Processor). X is a value between
0 ($0000) and 16,383 ($3FFF), since the VRAM is 16 KB wide. It returns
a byte value (0-255).

Example:
A=VPEEK(0)
-----------------------------------------------------------------------

VPOKE
-----
Syntax: VPOKE X,Y

Like its RAM counterpart, VPOKE writes Y into the cell of VRAM whose
address is X. X must be in the range 0~16,383, while Y is a byte value
(0-255).

Example:
VPOKE 1000,100
-----------------------------------------------------------------------

VREG
----
Syntax: VREG reg,value

Writes "value" into the VDP register "reg". "reg" must be a number in
the range 0~7, while "value" is a byte (0~255).

Example:
VREG 7,15 = writes 15 into register #7
-----------------------------------------------------------------------

VSTAT
-----
Syntax: VSTAT(X)

Reads the status register of the VDP. "X" is ignored and it can be any
signed integer (between -32,768 and +32,767). It returns a byte value
(0-255).

Example:
VSTAT(0)
-----------------------------------------------------------------------

WAIT
----
Syntax: WAIT X,Y[,Z]

Reads the I/O port X and performs and OR between the read byte and Y.
If Z is passed, the result of the OR operation is ANDed with Z. The
excution continues with a non-zero result.

Example:
WAIT 0,0,128 => the execution continues only if port 0 returns 128
                because 128 OR 0 = 128 and 128 AND 128 = 128.
-----------------------------------------------------------------------

WIDTH
-----
Syntax: WIDTH X

Sets the lenght of a lines for inputs or outputs. X must be in the range
0~255. Default is 255. 
------------------------------------------------------------------------

XOR
---
Syntax: X XOR Y

Logic operator used in boolean expressions and bitwise operations. It
performs a logical exclusive disjunction between expression X and Y. The
interpreter supports 4 boolean operators: AND, OR, XOR, and NOT, each of
them work with 16-bit signed integers. They convert their inputs in
16-bit integers and return a value in such format. It returns a true
value only when an odd number of inputs are true, meaning that its
results are true only when its operators are one false and one true, and
it returns a false value when its operators have the same value. Its
truth table is the following:
0 XOR 0 = 0
0 XOR 1 = 1
1 XOR 0 = 1
1 XOR 1 = 0
See also: AND, OR, and NOT.

Example:
11 XOR 2 => 9 (11 is 1011b, 2 is 0010b, so 1011b XOR 0010b is equal to
              1001b, that is 9 in decimal representation)

XOR is commonly used in cryptographic algorithms since one of its
features is to revert a XORed bit to its original value when it's XORed
again with the same value: first, we XOR a value with a "key" to get an
encrypted result, then we revert to the original value the encrypted
result by XORing it again with the "key". I.e.: 1 XOR 1 = 0 and 0 XOR 1
= 1. Let say that the "key" is value 167 and let say that we have to
encrypt the text "A". Since the ASCII code of "A" is 65, the operation
is:
65 XOR 167 = 230

Now, to revert to the original text, let's XOR 230 with the same "key":
230 XOR 167 => 65
------------------------------------------------------------------------
