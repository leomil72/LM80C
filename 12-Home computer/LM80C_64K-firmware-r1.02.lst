# file opened: LM80C_64K-firmware-r1.02.asm
   1  0000              ; ------------------------------------------------------------------------------
   2  0000              ; LM80C 64K - FIRMWARE - R1.02
   3  0000              ; ------------------------------------------------------------------------------
   4  0000              ; The following code is intended to be used with LM80C Z80-based computer
   5  0000              ; designed by Leonardo Miliani. More info at
   6  0000              ; www DOT leonardomiliani DOT com
   7  0000              ; ------------------------------------------------------------------------------
   8  0000              ; Coding/Editing/Compiling:
   9  0000              ; Original init code for MC68B05 by Grant Searle
  10  0000              ; Original SIO/CTC/PIO init code by Mario Blunk
  11  0000              ; NASCOM BASIC originally modified by Gran Searle
  12  0000              ; Code modified and adapted for LM80C by Leonardo Miliani
  13  0000              ;
  14  0000              ; Edited with Visual Studio Code
  15  0000              ;
  16  0000              ; Compiled with SjASMPlus assembler 1.18.0
  17  0000              ; https://github.com/z00m128/sjasmplus
  18  0000              ; ------------------------------------------------------------------------------
  19  0000              ; Copyright notes:
  20  0000              ; Parts of the code (c) Grant Searle - free for non commercial use
  21  0000              ; Please include this advice and the note to the attribution of the original
  22  0000              ; version to Grant Searle if you intend to redistribuite it
  23  0000              ; http://searle.hostei.com/grant/index.html
  24  0000              ; eMail: home.micros01@btinternet.com
  25  0000              ;
  26  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  27  0000              ; Parts of the code (c) Mario Blunk
  28  0000              ; http://www.trainÂ­z.de
  29  0000              ;
  30  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  31  0000              ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  32  0000              ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  33  0000              ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  34  0000              ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  35  0000              ; the original ROM code (checksum A934H). PA
  36  0000              ;
  37  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  38  0000              ; The following code is intended to be used with LM80C Z80-based computer
  39  0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
  40  0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
  41  0000              ; kind of warranty: you can use them at your own risk.
  42  0000              ; You are free to use them for any non-commercial use: you are only asked to
  43  0000              ; maintain the copyright notices, include this advice and the note to the
  44  0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  45  0000              ; redistribuite them.
  46  0000              ; https://www.leonardomiliani.com
  47  0000              ;
  48  0000              ; Please support me by visiting the following links:
  49  0000              ; Main project page: https://www.leonardomiliani.com
  50  0000              ; Schematics and code: https://github.com/leomil72/LM80C
  51  0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  52  0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  53  0000              ; ------------------------------------------------------------------------------
  54  0000              ; output binary file
  55  0000                  OUTPUT "LM80C-64K-firmware-r1.02.bin"
  56  0000
  57  0000              ; set computer model
  58  0000                  DEFINE  LM80C64K
  59  0000
  60  0000              ; ------------------------------------------------------------------------------
  61  0000              ; include the latest version of the bootloader: this sets up the address aliases
  62  0000              ; configure the hardware, checks if warm or cold startup and loads the BASIC interpreter
  63  0000                  INCLUDE "../include/bootloader/bootloader64k-r1.02.asm"
# file opened: ../include/bootloader/bootloader64k-r1.02.asm
   1+ 0000              ; ------------------------------------------------------------------------------
   2+ 0000              ; LM80C 64K - BOOTLOADER - R1.02
   3+ 0000              ; ------------------------------------------------------------------------------
   4+ 0000              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0000              ; kind of warranty: you can use them at your own risk.
   8+ 0000              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0000              ; maintain the copyright notices, include this advice and the note to the
  10+ 0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0000              ; redistribuite them.
  12+ 0000              ; https://www.leonardomiliani.com
  13+ 0000              ;
  14+ 0000              ; Please support me by visiting the following links:
  15+ 0000              ; Main project page: https://www.leonardomiliani.com
  16+ 0000              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0000              ; ------------------------------------------------------------------------------
  20+ 0000
  21+ 0000              ; ADDRESS DECODING (bits A6/A5/A4)
  22+ 0000              ; 0000xxxx : PIO
  23+ 0000              ; 0001xxxx : CTC
  24+ 0000              ; 0010xxxx : SIO
  25+ 0000              ; 0011xxxx : VDP
  26+ 0000              ; 0100xxxx : PSG
  27+ 0000              ; 0101xxxx : C.F.
  28+ 0000
  29+ 0000
  30+ 0000              ; ------------------------------------------------------------------------------
  31+ 0000              ;               EQUATES
  32+ 0000              ; ------------------------------------------------------------------------------
  33+ 0000              ; label defining for PIO (Parallel Input/Output)
  34+ 0000              PIO_DA          equ %00000000
  35+ 0000              PIO_DB          equ %00000001
  36+ 0000              PIO_CA          equ %00000010
  37+ 0000              PIO_CB          equ %00000011
  38+ 0000
  39+ 0000              ; label defining for CTC (Counter Timer Circuit)
  40+ 0000              CTC_CH0         equ %00010000
  41+ 0000              CTC_CH1         equ %00010001
  42+ 0000              CTC_CH2         equ %00010010
  43+ 0000              CTC_CH3         equ %00010011
  44+ 0000
  45+ 0000              ;label defining for SIO (Serial Input/Output)
  46+ 0000              SIO_CA          equ %00100010
  47+ 0000              SIO_CB          equ %00100011
  48+ 0000              SIO_DA          equ %00100000
  49+ 0000              SIO_DB          equ %00100001
  50+ 0000
  51+ 0000              ;label defining for VDP (Video Display Processor)
  52+ 0000              VDP_DAT         equ %00110000
  53+ 0000              VDP_SET         equ %00110010
  54+ 0000
  55+ 0000              ; label defining for PSG (Programmable Sound Generator)
  56+ 0000              PSG_REG         equ %01000000
  57+ 0000              PSG_DAT         equ %01000001
  58+ 0000
  59+ 0000              ; Interrupt-driven serial I/O interface lead by the Z80 SIO to run modified
  60+ 0000              ; NASCOM Basic 4.7 - Full input buffering with incoming data hardware handshaking
  61+ 0000              ; Handshake shows full before the buffer is totally filled to allow run-on from the sender
  62+ 0000              SER_BUFSIZE     equ     $58
  63+ 0000              SER_FULLSIZE    equ     $50
  64+ 0000              SER_EMPTYSIZE   equ     $05
  65+ 0000
  66+ 0000
  67+ 0000              ;------------------------------------------------------------------------------
  68+ 0000              ;                                F I R M W A R E
  69+ 0000              ;------------------------------------------------------------------------------
  70+ 0000              ; BASE MEMORY - RESET LOCATION ($0000) -> the CPU jumps to $0000 after a reset
  71+ 0000                              org     $0000
  72+ 0000 F3           RST00:          di                      ; be sure that INTs are disabled
  73+ 0001 C3 CF 50                     jp      ROM2RAM         ; jump to ROM/RAM switcher
  74+ 0004
  75+ 0004              ;------------------------------------------------------------------------------
  76+ 0004              ; interrupt vector when SIO ch.B has a char available in its buffer
  77+ 0004                              ;$0004
  78+ 0004 64 01                        defw    RX_CHB_AVAIL
  79+ 0006
  80+ 0006              ;------------------------------------------------------------------------------
  81+ 0006              ; interrupt vector for SIO ch.B special conditions (i.e. buf overrun)
  82+ 0006                              ;$0006
  83+ 0006 67 01                        defw    SPEC_RXB_CNDT
  84+ 0008
  85+ 0008              ;------------------------------------------------------------------------------
  86+ 0008              ; send a character over serial ch. A
  87+ 0008                              ;$0008
  88+ 0008 C3 4D 02     RST08:          jp      TXA
  89+ 000B FF                           BLOCK   1,$FF   ; filler
  90+ 000C
  91+ 000C              ;------------------------------------------------------------------------------
  92+ 000C              ; interrupt vector when SIO ch.A has a char available in its buffer
  93+ 000C                              ;$000C
  94+ 000C 00 01                        defw    RX_CHA_AVAIL
  95+ 000E
  96+ 000E              ;------------------------------------------------------------------------------
  97+ 000E              ; interrupt vector for SIO ch.A special conditions (i.e. buf overrun)
  98+ 000E                              ;$000E
  99+ 000E 35 01                        defw    SPEC_RXA_CNDT
 100+ 0010
 101+ 0010              ;------------------------------------------------------------------------------
 102+ 0010              ; receive a character over serial ch. A
 103+ 0010                              ;$0010
 104+ 0010 C3 23 02     RST10:          jp      RXA
 105+ 0013 FF FF FF...                  BLOCK   5,$FF   ; filler
 106+ 0018              ;------------------------------------------------------------------------------
 107+ 0018              ; check serial status
 108+ 0018
 109+ 0018                              ;$0018
 110+ 0018 C3 7A 02     RST18:          jp      CKINCHAR
 111+ 001B FF FF FF...                  BLOCK   $25,$FF ; filler
 112+ 0040              ;------------------------------------------------------------------------------
 113+ 0040              ; interrupt vectors for CTC
 114+ 0040                              ;$0040               ; for CH0 Timer - used in BASIC by serial 1 for bps
 115+ 0040 BF 52                        defw    CTC0IV
 116+ 0042                              ;$0042               ; for CH1 Timer - used in BASIC by serial 2 for bps
 117+ 0042 C2 52                        defw    CTC1IV
 118+ 0044                              ;$0044               ; for CH2 timer - unused
 119+ 0044 C5 52                        defw    CTC2IV
 120+ 0046                              ;$0046               ; for CH3 Timer - used by FW for 100ths/s counter
 121+ 0046 C8 52                        defw    CTC3IV
 122+ 0048 FF FF FF...                  BLOCK   $1E,$FF ; filler
 123+ 0066              ;------------------------------------------------------------------------------
 124+ 0066              ; interrupt routine for NMI
 125+ 0066                              ;$0066
 126+ 0066 C3 5F 51                     jp      NMIUSR              ; jump to execute NMI service routine
 127+ 0069 FF FF FF...                  BLOCK   $27,$FF ; filler
 128+ 0090              ;------------------------------------------------------------------------------
 129+ 0090                  LUA
 130+ 0090 ~                    sj.insert_define("TIME", '"' .. os.date("%d-%m-%Y %H:%M:%S") .. '"')
 131+ 0090              	ENDLUA
 132+ 0090                              ;$0090
 133+ 0090 4C 4D 38 30                  defb    $4C,$4D,$38,$30,$43,$20,$36,$34
 133+ 0094 43 20 36 34
 134+ 0098 4B 20 43 4F                  defb    $4B,$20,$43,$4F,$4C,$4F,$52,$00
 134+ 009C 4C 4F 52 00
 135+ 00A0 43 4F 4D 50                  defb    $43,$4F,$4D,$50,$55,$54,$45,$52
 135+ 00A4 55 54 45 52
 136+ 00A8 20 28 32 30                  defb    $20,$28,$32,$30,$32,$30,$29,$00
 136+ 00AC 32 30 29 00
 137+ 00B0 44 65 73 69                  defb    $44,$65,$73,$69,$67,$6E,$65,$64
 137+ 00B4 67 6E 65 64
 138+ 00B8 20 62 79 00                  defb    $20,$62,$79,$00,$00,$00,$00,$00
 138+ 00BC 00 00 00 00
 139+ 00C0 4C 65 6F 6E                  defb    $4C,$65,$6F,$6E,$61,$72,$64,$6F
 139+ 00C4 61 72 64 6F
 140+ 00C8 20 4D 69 6C                  defb    $20,$4D,$69,$6C,$69,$61,$6E,$69
 140+ 00CC 69 61 6E 69
 141+ 00D0 46 57 20 31  FWVER:          defm    "FW 1.02",$20,"03-01-2021 11:04:08",$00
 141+ 00D4 2E 30 32 20
 141+ 00D8 30 33 2D 30
 141+ 00DC 31 2D 32 30
 141+ 00E0 32 31 20 31
 141+ 00E4 31 3A 30 34
 141+ 00E8 3A 30 38 00
bootloader64k-r1.02.asm(142): warning: Label has different value in pass 3: previous value 218 not equal 236
 142+ 00EC              FMVEREND:       equ     $
 143+ 00EC FF FF FF...                  BLOCK   $100-FMVEREND,$FF   ; filler
 144+ 0100              ;------------------------------------------------------------------------------
 145+ 0100
 146+ 0100              ;-------------------------------------------------------------------------------
 147+ 0100              ;               Z80 SIO CH. A MANAGEMENT
 148+ 0100              ;-------------------------------------------------------------------------------
 149+ 0100
 150+ 0100              ;-------------------------------------------------------------------------------
 151+ 0100              ; interrupt driven routine to get chars from Z80 SIO ch.A
 152+ 0100              ; this is the only channel that can print received chars onto the screen
 153+ 0100                              ;$0100
 154+ 0100 F5           RX_CHA_AVAIL:   push    AF              ; store A
 155+ 0101 E5                           push    HL              ; and HL
 156+ 0102 CD 8E 01                     call    A_RTS_OFF       ; disable RTS line
 157+ 0105 DB 20                        in      A,(SIO_DA)      ; read char from RX buffer into A
 158+ 0107 32 18 53                     ld      (TMPKEYBFR),A   ; store it into the temp key buffer
 159+ 010A CD F4 01                     call    CHARINTOBFR     ; sub-routine to put the char into the input buffer
 160+ 010D D2 30 01                     jp      NC,LVRXCHA      ; if buffer is full, then leave without doing anything else
 161+ 0110 3A 18 53                     ld      A,(TMPKEYBFR)   ; retrieve char
 162+ 0113 32 D9 52                     ld      (CHR4VID),A     ; write into buffer for video printing
 163+ 0116 FE 0D                        cp      CR              ; is it RETURN?
 164+ 0118 CA 20 01                     jp      Z,CNTRXCHA      ; yes, continue
 165+ 011B FE 20                        cp      $20             ; is it another control char (code < 32)?
 166+ 011D DA 30 01                     jp      C,LVRXCHA       ; yes, leave w/o printing it on video nor sending back to serial
 167+ 0120 F5           CNTRXCHA:       push    AF              ; store char
 168+ 0121 AF                           xor     A
 169+ 0122 32 16 53                     ld      (KBDNPT),A      ; a char from serial is like a char printed by BASIC
 170+ 0125 3A D6 52                     ld      A,(CRSR_STATE)  ; check cursor state
 171+ 0128 B7                           or      A               ; is it on?
 172+ 0129 C4 56 07                     call    NZ,CHAR2VID     ; yes, print on screen
 173+ 012C F1                           pop     AF              ; retrieve char
 174+ 012D CD 4D 02                     call    TXA             ; send back to serial
 175+ 0130 E1           LVRXCHA:        pop     HL              ; retrieve HL
 176+ 0131 F1                           pop     AF              ; and A
 177+ 0132 FB                           ei                      ; re-enable interrupts
 178+ 0133 ED 4D                        reti                    ; and exit
 179+ 0135
 180+ 0135              ;-------------------------------------------------------------------------------
 181+ 0135              ; special SIO ch.A condition (i.e., buffer overrun)
 182+ 0135              ; if buffer overruns then show an error, empty the RX buffer and send
 183+ 0135              ; a break char
 184+ 0135 F5           SPEC_RXA_CNDT:  push    AF              ; store AF
 185+ 0136 CD 8E 01                     call    A_RTS_OFF       ; disable RTS
 186+ 0139 CD C2 01                     call    SIO_A_DI        ; disable RX on ch. A
 187+ 013C 3A 1E 53                     ld      A,(SERIALS_EN)  ; load serial status
 188+ 013F CB 97                        res     2,A             ; disable RX on port 1
 189+ 0141 32 1E 53                     ld      (SERIALS_EN),A  ; store new serial status
 190+ 0144 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 191+ 0146 CB E7                        set     4,A             ; set 5th pin ON
 192+ 0148 D3 01                        out     (PIO_DB),A      ; send new setting
 193+ 014A 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 194+ 014C D3 22                        out     (SIO_CA),A      ; send command to SIO
 195+ 014E AF           EMPTYCHABFR:    xor     A
 196+ 014F D3 22                        out     (SIO_CA),A      ; write to WR0, select RR0
 197+ 0151 DB 22                        in      A,(SIO_CA)      ; read RR0 register
 198+ 0153 E6 01                        and     $01             ; check if input buffer if empty
 199+ 0155 CA 5C 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then leave
 200+ 0158 DB 20                        in      A,(SIO_DA)      ; read chars
 201+ 015A 18 F2                        jr      EMPTYCHABFR     ; repeat
 202+ 015C F1           CHABFREMPTY:    pop     AF              ; retrieve AF
 203+ 015D 21 DD 3C                     ld      HL,SOERR        ; return point set to Serial Buffer Overrun routine
 204+ 0160 E3                           ex      (SP),HL         ; store onto stack
 205+ 0161 FB                           ei                      ; re-enable interrupts
 206+ 0162 ED 4D                        reti                    ; return from interrupt and execute code at SOERR
 207+ 0164
 208+ 0164              ;-------------------------------------------------------------------------------
 209+ 0164              ;               Z80 SIO CH. A MANAGEMENT
 210+ 0164              ;-------------------------------------------------------------------------------
 211+ 0164
 212+ 0164              ;-------------------------------------------------------------------------------
 213+ 0164              ; interrupt driven routine to get chars from Z80 SIO ch.B
 214+ 0164 FB           RX_CHB_AVAIL:   ei
 215+ 0165 ED 4D                        reti
 216+ 0167
 217+ 0167              ;-------------------------------------------------------------------------------
 218+ 0167              ; special SIO ch.A condition (i.e., buffer overrun)
 219+ 0167              ; if buffer overruns then show an error, empty the RX buffer and send
 220+ 0167              ; a break char
 221+ 0167 F5           SPEC_RXB_CNDT:  push    AF              ; store A
 222+ 0168 CD 96 01                     call    B_RTS_OFF       ; disable RTS
 223+ 016B CD CA 01                     call    SIO_B_DI        ; disable RX on ch.B
 224+ 016E 3A 1E 53                     ld      A,(SERIALS_EN)  ; load serial status
 225+ 0171 CB 9F                        res     3,A             ; disable RX on port 2
 226+ 0173 32 1E 53                     ld      (SERIALS_EN),A  ; store new serial status
 227+ 0176 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 228+ 0178 CB EF                        set     5,A             ; set 5th pin ON
 229+ 017A D3 01                        out     (PIO_DB),A      ; send new setting
 230+ 017C 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 231+ 017E D3 23                        out     (SIO_CB),A      ; send command to SIO
 232+ 0180 AF           EMPTYCHBBFR:    xor     A
 233+ 0181 D3 23                        out     (SIO_CB),A      ; write to WR0, select RR0
 234+ 0183 DB 23                        in      A,(SIO_CB)      ; read RR0 register
 235+ 0185 E6 01                        and     $01             ; check if input buffer if empty
 236+ 0187 CA 5C 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then jump to run "exit" code
 237+ 018A DB 21                        in      A,(SIO_DB)      ; read chars
 238+ 018C 18 F2                        jr      EMPTYCHBBFR     ; repeat
 239+ 018E
 240+ 018E
 241+ 018E              ;-------------------------------------------------------------------------------
 242+ 018E              ;               Z80 SIO MANAGEMENT
 243+ 018E              ;-------------------------------------------------------------------------------
 244+ 018E              ; disable RTS:
 245+ 018E              ; by resetting RTS bit (set to 0), the RTS line is disabled (HIGH)
 246+ 018E C5           A_RTS_OFF:      push    BC              ; store BC
 247+ 018F 0E 22                        ld      C,SIO_CA        ; select channel A
 248+ 0191 3A 1F 53                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 249+ 0194 18 06                        jr      SIO_RTS_OFF
 250+ 0196 C5           B_RTS_OFF:      push    BC              ; store BC
 251+ 0197 0E 23                        ld      C,SIO_CB        ; select channel B
 252+ 0199 3A 20 53                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 253+ 019C 47           SIO_RTS_OFF:    ld      B,A             ; store data bits
 254+ 019D 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 255+ 019F ED 79                        out     (C),A
 256+ 01A1 78                           ld      A,B             ; retrieve data bits
 257+ 01A2 F6 28                        or      %00101000       ; TX enable; RTS disable
 258+ 01A4 ED 79                        out     (C),A           ; send setting
 259+ 01A6 C1                           pop     BC              ; retrieve BC
 260+ 01A7 C9                           ret                     ; exit
 261+ 01A8
 262+ 01A8              ;-------------------------------------------------------------------------------
 263+ 01A8              ; enable RTS
 264+ 01A8              ; by setting RTS bit (set to 1), the RTS line is enabled (LOW)
 265+ 01A8 C5           A_RTS_ON:       push    BC              ; store BC
 266+ 01A9 0E 22                        ld      C,SIO_CA        ; select channel A
 267+ 01AB 3A 1F 53                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 268+ 01AE 18 06                        jr      SIO_RTS_ON
 269+ 01B0 C5           B_RTS_ON:       push    BC              ; store BC
 270+ 01B1 0E 23                        ld      C,SIO_CB        ; select channel B
 271+ 01B3 3A 20 53                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 272+ 01B6 47           SIO_RTS_ON:     ld      B,A             ; store data bits
 273+ 01B7 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 274+ 01B9 ED 79                        out     (C),A
 275+ 01BB 78                           ld      A,B             ; retrieve data bits
 276+ 01BC F6 2A                        or      %00101010       ; TX enable; RTS enable
 277+ 01BE ED 79                        out     (C),A           ; send setting
 278+ 01C0 C1                           pop     BC              ; retrieve BC
 279+ 01C1 C9                           ret                     ; return
 280+ 01C2
 281+ 01C2              ;-------------------------------------------------------------------------------
 282+ 01C2              ; disable SIO RX channel
 283+ 01C2 C5           SIO_A_DI:       push    BC              ; store BC
 284+ 01C3 0E 22                        ld      C,SIO_CA        ; SIO channel A
 285+ 01C5 3A 1F 53                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 286+ 01C8 18 06                        jr      SIO_RXDI        ; jump to disable RX
 287+ 01CA C5           SIO_B_DI:       push    BC              ; store BC
 288+ 01CB 0E 23                        ld      C,SIO_CB        ; SIO channel B
 289+ 01CD 3A 20 53                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 290+ 01D0 47           SIO_RXDI:       ld      B,A             ; store data bits
 291+ 01D1 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 292+ 01D3 ED 79                        out     (C),A
 293+ 01D5 78                           ld      A,B             ; retrieve data bits; RX disabled; auto enable is OFF
 294+ 01D6 ED 79                        out     (C),A
 295+ 01D8 C1                           pop     BC              ; retrieve BC
 296+ 01D9 C9                           ret                     ; return
 297+ 01DA
 298+ 01DA              ;-------------------------------------------------------------------------------
 299+ 01DA              ; enable SIO RX channel
 300+ 01DA C5           SIO_A_EI:       push    BC              ; store BC
 301+ 01DB 0E 22                        ld      C,SIO_CA
 302+ 01DD 3A 1F 53                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 303+ 01E0 18 06                        jr      SIO_RXEN
 304+ 01E2 C5           SIO_B_EI:       push    BC              ; store BC
 305+ 01E3 0E 23                        ld      C,SIO_CB
 306+ 01E5 3A 20 53                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 307+ 01E8 47           SIO_RXEN:       ld      B,A             ; store data bits
 308+ 01E9 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 309+ 01EB ED 79                        out     (C),A           ; select register
 310+ 01ED 78                           ld      A,B             ; retrieve data bits
 311+ 01EE CB C7                        set     0,A             ; set RX enabled; auto enable is OFF
 312+ 01F0 ED 79                        out     (C),A           ; send settings to SIO
 313+ 01F2 C1                           pop     BC              ; retrieve BC
 314+ 01F3 C9                           ret
 315+ 01F4
 316+ 01F4              ;------------------------------------------------------------------------------
 317+ 01F4              ; put a char into the input buffer, char is into A
 318+ 01F4              ; this sub is called both from the ISR "RX_CHA_AVAIL" and when
 319+ 01F4              ; the RETURN key is pressed on the keyboard
 320+ 01F4 F5           CHARINTOBFR:    push    AF              ; store it
 321+ 01F5 3A 5A 51                     ld      A,(serBufUsed)  ; load buffer size
 322+ 01F8 FE 58                        cp      SER_BUFSIZE     ; if buffer is not full
 323+ 01FA DA FF 01                     jp      C,NOTFULL       ; then store the char
 324+ 01FD F1                           pop     AF              ; else drop it
 325+ 01FE C9                           ret                     ; and exit
 326+ 01FF 2A 56 51     NOTFULL:        ld      HL,(serInPtr)   ; buffer is not full, can store the char
 327+ 0202 23                           inc     HL              ; load pointer to find first free cell
 328+ 0203 7D                           ld      A,L             ; only check low byte because buffer<256
 329+ 0204 FE 56                        cp      bufWrap         ; check if the pointer is at the last cell
 330+ 0206 20 03                        jr      NZ,NOTWRAP      ; if not then continue
 331+ 0208 21 FE 50                     ld      HL,SERBUF_START ; else load the address of the first cell
 332+ 020B 22 56 51     NOTWRAP:        ld      (serInPtr),HL   ; store the new pointer
 333+ 020E F1                           pop     AF              ; then recover the char
 334+ 020F 77                           ld      (HL),A          ; and store it in the appropriate cell
 335+ 0210 3A 5A 51                     ld      A,(serBufUsed)  ; load the size of the input buffer
 336+ 0213 3C                           inc     A               ; increment it
 337+ 0214 32 5A 51                     ld      (serBufUsed),A  ; and store the new size
 338+ 0217 FE 50                        cp      SER_FULLSIZE    ; check if input buffer is full
 339+ 0219 D8                           ret     C               ; exit if buffer is not full
 340+ 021A 3A 1E 53                     ld      A,(SERIALS_EN)  ; check if serial 1 is open
 341+ 021D 1F                           rra                     ; bit 0 into Carry: if Carry is 1 then serial 0 is open and...
 342+ 021E DC 8E 01                     call    C,A_RTS_OFF     ; ...stop receiving further chars
 343+ 0221 AF                           xor     A               ; clear Carry to set a buffer full condition
 344+ 0222 C9                           ret
 345+ 0223
 346+ 0223
 347+ 0223              ;-------------------------------------------------------------------------------
 348+ 0223              ; retrieve a char from the input buffer
 349+ 0223 3A 5A 51     RXA:            ld      A,(serBufUsed)  ; load the buffer size
 350+ 0226 A7                           and     A               ; check if it's 0 (empty)
 351+ 0227 CA 23 02                     jp      Z,RXA           ; if it's empty, wait for a char
 352+ 022A F3                           di                      ; disable interrupts
 353+ 022B E5                           push    HL              ; store HL
 354+ 022C 2A 58 51                     ld      HL,(serRdPtr)   ; load pointer to first available char
 355+ 022F 23                           inc     HL              ; increment it (go to the next char)
 356+ 0230 7D                           ld      A,L             ; check if the end of the buffer has been reached
 357+ 0231 FE 56                        cp      bufWrap         ; (only check low byte because buffer<256)
 358+ 0233 20 03                        jr      NZ,NOTRDWRAP    ; if not, jump straight
 359+ 0235 21 FE 50                     ld      HL,SERBUF_START ; else reload the starting address of the buffer
 360+ 0238 22 58 51     NOTRDWRAP:      ld      (serRdPtr),HL   ; store new pointer to the next char to read
 361+ 023B 3A 5A 51                     ld      A,(serBufUsed)  ; load buffer size
 362+ 023E 3D                           dec     A               ; decrement it
 363+ 023F 32 5A 51                     ld      (serBufUsed),A  ; and store the new size
 364+ 0242 FE 05                        cp      SER_EMPTYSIZE   ; check if input buffer can be considered empty
 365+ 0244 30 03                        jr      NC,RXA_EXIT     ; if not empty yet, then exit
 366+ 0246 CD A8 01                     call    A_RTS_ON        ; else re-enable receiving chars
 367+ 0249 7E           RXA_EXIT:       ld      A,(HL)          ; recover the char and return it into A
 368+ 024A E1                           pop     HL              ; retrieve HL
 369+ 024B FB                           ei                      ; re-enable interrupts
 370+ 024C C9                           ret                     ; return
 371+ 024D
 372+ 024D              ;------------------------------------------------------------------------------
 373+ 024D              ; sends a char over the serial (trick for INTs from WikiTI)
 374+ 024D              ; char is into A
 375+ 024D F5           TXA:            push    AF              ; store AF
 376+ 024E C5                           push    BC              ; store BC
 377+ 024F 47                           ld      B,A             ; store char
 378+ 0250 ED 57                        ld      A,I             ; when loading I into A, P/V is set to the value of IFF (P/V is set if INTs enabled)
 379+ 0252 EA 57 02                     jp      PE,CNTTXA       ; if set, jump over
 380+ 0255 ED 57                        ld      A,I             ; if not set, test again to fix "false negative" from interrupt occurring at first test
 381+ 0257 F5           CNTTXA:         push    AF              ; store current P/V flag
 382+ 0258 F3                           di                      ; disable INTs
 383+ 0259 3A 1E 53                     ld      A,(SERIALS_EN)  ; load serial status
 384+ 025C FE 05                        cp      %00000101       ; check if serial 1 is open and RX/TX is enabled
 385+ 025E 20 06                        jr      NZ,TXA_EXIT     ; no, jump over
 386+ 0260 78                           ld      A,B             ; retrieve char
 387+ 0261 D3 20                        out     (SIO_DA),A      ; send char to the SIO
 388+ 0263 CD 6E 02                     call    TX_EMP          ; wait for outgoing char to be sent
 389+ 0266 F1           TXA_EXIT:       pop     AF              ; retrieve P/V flag
 390+ 0267 E2 6B 02                     jp      PO,EXTXA        ; if P is reset, INTs were disabled so we can leave right now
 391+ 026A FB                           ei                      ; INTs were enabled, so re-enable interrupts
 392+ 026B C1           EXTXA:          pop     BC              ; retrieve BC
 393+ 026C F1                           pop     AF              ; retrieve AF
 394+ 026D C9                           ret                     ; return
 395+ 026E
 396+ 026E              ;------------------------------------------------------------------------------
 397+ 026E              ; wait until outgoing serial has been sent
 398+ 026E 97           TX_EMP:         sub     A               ; set A to 0
 399+ 026F 3C                           inc     A               ; set A to 1
 400+ 0270 D3 22                        out     (SIO_CA),A      ; write to WR0, select RR1
 401+ 0272 DB 22                        in      A,(SIO_CA)      ; read RR1 register
 402+ 0274 CB 47                        bit     0,A             ; check if all chars have been sent
 403+ 0276 CA 6E 02                     jp      Z,TX_EMP        ; if not (bit 0 = 0) then retrieve
 404+ 0279 C9                           ret                     ; else exit
 405+ 027A
 406+ 027A
 407+ 027A              ;------------------------------------------------------------------------------
 408+ 027A              ; check if there is some chars into the buffer
 409+ 027A 3A 5A 51     CKINCHAR:       ld      A,(serBufUsed)  ; load char in buffer
 410+ 027D A7                           and     A               ; compare to 0
 411+ 027E C9                           ret                     ; return
 412+ 027F
 413+ 027F              ;------------------------------------------------------------------------------
 414+ 027F              ; print a text from memory, and terminate when $00 is found
 415+ 027F 7E           RAWPRINT:       ld      A,(HL)          ; load character from memory cell pointed by HL
 416+ 0280 B7                           or      A               ; is it $00 (end string)?
 417+ 0281 C8                           ret     Z               ; Yes, then return
 418+ 0282 32 D9 52                     ld      (CHR4VID),A     ; store char
 419+ 0285 F3                           di
 420+ 0286 CD 56 07                     call    CHAR2VID        ; and send it to screen
 421+ 0289 FB                           ei
 422+ 028A 23                           inc     HL              ; and select the next one
 423+ 028B 18 F2                        jr      RAWPRINT        ; repeat
 424+ 028D
 425+ 028D              ;-------------------------------------------------
 426+ 028D              ; Interrupt service routine (ISR) for CH3 timer
 427+ 028D              ; this is used to increment the 100ths of a second counter and for cursor flashing
 428+ 028D F5           CH3_TIMER:      push    AF              ; save regs. A,
 429+ 028E C5                           push    BC              ; BC,
 430+ 028F D5                           push    DE              ; DE,
 431+ 0290 E5                           push    HL              ; HL
 432+ 0291 21 BB 52                     ld      HL,TMRCNT       ; load starting address of the timer
 433+ 0294 06 04                        ld      B,$04           ; 4 bytes to check
 434+ 0296 34           INCTMR3:        inc     (HL)            ; increment timer
 435+ 0297 20 03                        jr      NZ,CHKCRSR      ; if not zero then exit (finished increment)
 436+ 0299 23                           inc     HL              ; if yes, there was an overflow, so increment next byte
 437+ 029A 10 FA                        djnz    INCTMR3         ; repeat for 4 bytes
 438+ 029C CD C0 07     CHKCRSR:        call    FLASHCURSOR     ; call the flashing cursor routine
 439+ 029F CD BC 0C                     call    MNGSNDS         ; call the tone managemenet
 440+ 02A2 3A BB 52                     ld      A,(TMRCNT)      ; check for keyboard management
 441+ 02A5 1F                           rra                     ; bit 0 = 1 ?
 442+ 02A6 D4 21 0D                     call    NC,KEYBOARD     ; no, so read the keyboard inputs
 443+ 02A9 E1                           pop     HL              ; retrieve HL,
 444+ 02AA D1                           pop     DE              ; DE,
 445+ 02AB C1                           pop     BC              ; BC,
 446+ 02AC F1                           pop     AF              ; and A
 447+ 02AD FB                           ei                      ; re-enable interrupts
 448+ 02AE ED 4D                        reti                    ; exit from ISR
 449+ 02B0
 450+ 02B0              ;------------------------------------------------------------------------------
 451+ 02B0              ;               HARDWARE INITIALISATION
 452+ 02B0              ;------------------------------------------------------------------------------
 453+ 02B0              ; first run - setup HW & SW
 454+ 02B0              ; now run from RAM
 455+ 02B0 21 8D 52     INIT_HW:        ld      HL,TEMPSTACK    ; load temp stack pointer
 456+ 02B3 F9           INIT_HW2:       ld      SP,HL           ; set stack to temp stack pointer
 457+ 02B4 21 FE 50                     ld      HL,SERBUF_START ; set beginning of input buffer
 458+ 02B7 22 56 51                     ld      (serInPtr),HL   ; for incoming chars to store into buffer
 459+ 02BA 22 58 51                     ld      (serRdPtr),HL   ; and for chars to be read from buffer
 460+ 02BD AF                           xor     A               ; reset A
 461+ 02BE 32 5A 51                     ld      (serBufUsed),A  ; actual buffer size is 0
 462+ 02C1 32 1E 53                     ld      (SERIALS_EN),A  ; set serial ports status to OFF
 463+ 02C4 CD 42 03                     call    initCTC         ; configure CTC, then...
 464+ 02C7 CD 5A 0C                     call    initPSG         ; ...configure PSG
 465+ 02CA CD F6 04                     call    SHOW_LOGO       ; show computer logo
 466+ 02CD 1E 01                        ld      E,$01           ; E chooses the video mode (graphics 1)
 467+ 02CF CD D3 03                     call    initVDP         ; set video display
 468+ 02D2 AF                           xor     A
 469+ 02D3 ED 47                        ld      I,A             ; set high byte of interrupt vectors to point to page 0
 470+ 02D5 ED 5E                        im      2               ; interrupt mode 2
 471+ 02D7 FB                           ei                      ; enable interrupts
 472+ 02D8                              ; print system messages
 473+ 02D8 AF                           xor     A               ; A=0 so...
 474+ 02D9 32 16 53                     ld      (KBDNPT),A      ; ...inputs don't come from keyboard
 475+ 02DC 3C                           inc     A               ; A=1...
 476+ 02DD 32 D8 52                     ld      (PRNTVIDEO),A   ; ...to activate the print-on-video
 477+ 02E0 21 78 03                     ld      HL,MSGTXT1      ; sign-on message
 478+ 02E3 CD 7F 02                     call    RAWPRINT        ; print message
 479+ 02E6 3A 5B 51                     ld      A,(basicStarted); check if BASIC is already started
 480+ 02E9 FE 59                        cp      'Y'             ; to see if this is a power-up
 481+ 02EB 20 19                        jr      NZ,COLDSTART    ; if not, then do a COLD start
 482+ 02ED 21 B6 03                     ld      HL,MSGTXT2      ; message to choose kind of start
 483+ 02F0 CD 7F 02                     call    RAWPRINT        ; print message
 484+ 02F3 CD F2 08                     call    CURSOR_ON       ; enable cursor
 485+ 02F6 AF                           xor     A
 486+ 02F7 32 D8 52                     ld      (PRNTVIDEO),A   ; disable print-on-video
 487+ 02FA CD 23 02     CORW:           call    RXA             ; look for a pressed key
 488+ 02FD E6 DF                        and     %11011111       ; only UPPERCASE char
 489+ 02FF FE 43                        cp      'C'             ; cold start?
 490+ 0301 20 0E                        jr      NZ,CHECKWARM    ; no, let's check for warm start
 491+ 0303 CD 1E 03                     call    ECHO_CHAR       ; echoes the char
 492+ 0306 3E 59        COLDSTART:      ld      A,'Y'           ; yes, set the "BASIC started" flag
 493+ 0308 32 5B 51                     ld      (basicStarted),A
 494+ 030B CD 07 09                     call    CURSOR_OFF      ; disable cursor
 495+ 030E C3 C0 11                     jp      COLD            ; start BASIC COLD
 496+ 0311 FE 57        CHECKWARM:      cp      'W'
 497+ 0313 20 E5                        jr      NZ,CORW         ; char not recognized, wait again
 498+ 0315 CD 1E 03                     call    ECHO_CHAR       ; echoes the char
 499+ 0318 CD 07 09                     call    CURSOR_OFF      ; disable cursor
 500+ 031B C3 C3 11                     jp      WARM            ; start BASIC WARM
 501+ 031E
 502+ 031E              ;-------------------------------------------------------------------------------
 503+ 031E              ; send back char received through ch. A
 504+ 031E 32 D9 52     ECHO_CHAR:      ld      (CHR4VID),A     ; set char for video printing
 505+ 0321 AF                           xor     A
 506+ 0322 32 16 53                     ld      (KBDNPT),A      ; input is not from keyboard
 507+ 0325 F3                           di                      ; disable INTs
 508+ 0326 CD 56 07                     call    CHAR2VID        ; echoes back the pressed key,
 509+ 0329 3E 0D                        ld      A,CR            ; then set a CR
 510+ 032B 32 D9 52                     ld      (CHR4VID),A     ; set char for video printing
 511+ 032E CD 56 07                     call    CHAR2VID        ; and send it to screen
 512+ 0331 FB                           ei                      ; re-enable INTs
 513+ 0332 3E 01                        ld      A,$01
 514+ 0334 32 D8 52                     ld      (PRNTVIDEO),A   ; re-enable video printing
 515+ 0337 C9                           ret                     ; return to caller
 516+ 0338
 517+ 0338              ;-------------------------------------------------------------------------------
 518+ 0338              ; Z80 SIO default settings for serial channels
 519+ 0338 30           SIO_A_SETS:     defb    %00110000       ; write into WR0: error reset, select WR0
 520+ 0339 18                           defb    %00011000       ; write into WR0: channel reset
 521+ 033A 04                           defb    %00000100       ; write into WR0: select WR4
 522+ 033B 44                           defb    %01000100       ; write into WR4: presc. 16x, 1 stop bit, no parity
 523+ 033C 05                           defb    %00000101       ; write into WR0: select WR5
 524+ 033D E8                           defb    %11101000       ; write into WR5: DTR on, TX 8 bits, BREAK off, TX on, RTS off
 525+ 033E 01           SIO_B_SETS:     defb    %00000001       ; write into WR0: select WR1
 526+ 033F 04                           defb    %00000100       ; write into WR1: status affects interrupt vectors
 527+ 0340 02                           defb    %00000010       ; write into WR0: select WR2
 528+ 0341 00                           defb    %00000000       ; write into WR2: set interrupt vector, but bits D3/D2/D1 of this vector
 529+ 0342                                                      ; will be affected by the channel & condition that raised the interrupt
 530+ 0342                                                      ; (see datasheet): in our example, 0x0C for Ch.A receiving A char, 0x0E
 531+ 0342                                                      ; for special conditions
 532+ 0342              ;------------------------------------------------------------------------------
 533+ 0342              ;               Z80 CTC SETTING UP
 534+ 0342              ;------------------------------------------------------------------------------
 535+ 0342              initCTC:
 536+ 0342 21 6C 03                     ld      HL,CTCCONF      ; CTC configuration
 537+ 0345 11 BF 52                     ld      DE,CTC0IV       ; CTC interrupt vector table
 538+ 0348 01 0C 00                     ld      BC,$000C        ; 12 bytes
 539+ 034B ED B0                        ldir                    ; copy data
 540+ 034D              ;CH0, CH1, & CH2 disabled
 541+ 034D 3E 03                        ld      A,%00000011     ; interrupt off, timer mode, prescaler=16, don't care ext. TRG edge,
 542+ 034F                                                      ; start timer on loading constant, no time constant follows, software reset, command word
 543+ 034F D3 10                        out     (CTC_CH0),A     ; set CH0
 544+ 0351 D3 11                        out     (CTC_CH1),A     ; set CH1
 545+ 0353 D3 12                        out     (CTC_CH2),A     ; set CH2
 546+ 0355              ;init CH3
 547+ 0355              ;CH3 divides CPU CLK by 144*256 providing an interrupt signal at 100 Hz (1/100 sec).
 548+ 0355              ;f = CPU_CLK/(144*256) => 3,686,400 / ( 36,864 ) => 100Hz
 549+ 0355 3E A7                        ld      A,%10100111     ; interrupt on; timer mode; prescaler=256; don't care ext; automatic trigger;
 550+ 0357                                                      ; time constant follows; cont. operation; command word
 551+ 0357 D3 13                        out     (CTC_CH3),A     ; send to CH3
 552+ 0359 3E 90                        ld      A,$90           ; time constant - 90$ (144d)
 553+ 035B D3 13                        out     (CTC_CH3),A     ; send to CH3
 554+ 035D 3E 40                        ld      A,%01000000     ; D7..D3 provide the first part of the int vector (in our case, $0100), followed by
 555+ 035F                                                      ; D2..D1, provided by the CTC (they point to the channel), D0=interrupt word
 556+ 035F                                                      ; so int vector is 01000xx00
 557+ 035F D3 10                        out     (CTC_CH0),A     ; send to CTC
 558+ 0361                              ; reset cells of 100ths of a second counter
 559+ 0361 AF                           xor     A               ; reset A
 560+ 0362 21 BB 52                     ld      HL,TMRCNT       ; load TMR pointer
 561+ 0365 06 04                        ld      B,$04           ; 4 memory cells
 562+ 0367 77           RESTMR:         ld      (HL),A          ; reset n-cell of TMR
 563+ 0368 23                           inc     HL              ; next cell
 564+ 0369 10 FC                        djnz    RESTMR          ; repeat for 4 cells
 565+ 036B C9                           ret
 566+ 036C
 567+ 036C
 568+ 036C              ;------------------------------------------------------------------------------
 569+ 036C              ; jump table for CHx interrupts
 570+ 036C FB ED 4D     CTCCONF:        defb    $FB,$ED,$4D     ; CTC0 interrupt vector (ei; reti)
 571+ 036F FB ED 4D                     defb    $FB,$ED,$4D     ; CTC1 interrupt vector (ei; reti)
 572+ 0372 FB ED 4D                     defb    $FB,$ED,$4D     ; CTC2 interrupt vector (ei; reti)
 573+ 0375 C3 8D 02                     jp      CH3_TIMER       ; CTC3 interrupt vector (jump to execute sys-tick timer)
 574+ 0378
 575+ 0378
 576+ 0378              ;------------------------------------------------------------------------------
 577+ 0378              ; welcome messages
 578+ 0378 20 20 20 20  MSGTXT1:        defm    "    LM80C 64K Color Computer",CR
 578+ 037C 4C 4D 38 30
 578+ 0380 43 20 36 34
 578+ 0384 4B 20 43 6F
 578+ 0388 6C 6F 72 20
 578+ 038C 43 6F 6D 70
 578+ 0390 75 74 65 72
 578+ 0394 0D
 579+ 0395 20 62 79 20                  defm    " by Leonardo Miliani * FW R1.02",CR,0
 579+ 0399 4C 65 6F 6E
 579+ 039D 61 72 64 6F
 579+ 03A1 20 4D 69 6C
 579+ 03A5 69 61 6E 69
 579+ 03A9 20 2A 20 46
 579+ 03AD 57 20 52 31
 579+ 03B1 2E 30 32 0D
 579+ 03B5 00
 580+ 03B6 0D           MSGTXT2:        defb    CR
 581+ 03B7 20 20 20 3C                  defm    "   <C>old or <W>arm start? ",0
 581+ 03BB 43 3E 6F 6C
 581+ 03BF 64 20 6F 72
 581+ 03C3 20 3C 57 3E
 581+ 03C7 61 72 6D 20
 581+ 03CB 73 74 61 72
 581+ 03CF 74 3F 20 00
 582+ 03D3
# file closed: ../include/bootloader/bootloader64k-r1.02.asm
  64  03D3
  65  03D3              ; incude the latest version of the VDP module
  66  03D3                  INCLUDE "../include/vdp/vdp64k-r1.0.asm"
# file opened: ../include/vdp/vdp64k-r1.0.asm
   1+ 03D3              ; ------------------------------------------------------------------------------
   2+ 03D3              ; LM80C 64K - VDP ROUTINES - R1.0
   3+ 03D3              ; ------------------------------------------------------------------------------
   4+ 03D3              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 03D3              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 03D3              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 03D3              ; kind of warranty: you can use them at your own risk.
   8+ 03D3              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 03D3              ; maintain the copyright notices, include this advice and the note to the
  10+ 03D3              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 03D3              ; redistribuite them.
  12+ 03D3              ; https://www.leonardomiliani.com
  13+ 03D3              ;
  14+ 03D3              ; Please support me by visiting the following links:
  15+ 03D3              ; Main project page: https://www.leonardomiliani.com
  16+ 03D3              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 03D3              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 03D3              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 03D3              ; ------------------------------------------------------------------------------
  20+ 03D3              ;
  21+ 03D3              ;------------------------------------------------------------------------------
  22+ 03D3              ; VDP INITIALISATION
  23+ 03D3              ; initialize VDP for a specific graphics mode
  24+ 03D3              ; INPUT: E -> contains the graphics mode:
  25+ 03D3              ; 0=text; 1=graphics 1; 2=graphics 2; 3=multicolor; 4=extended graphics 2
  26+ 03D3 D5           initVDP:        push    DE              ; store E
  27+ 03D4 CD 96 0A                     call    EMPTY_VRAM      ; reset VRAM
  28+ 03D7 CD B5 0A                     call    SET_GFX_MODE    ; load register settings
  29+ 03DA CD AA 0A                     call    CLR_RAM_REG     ; reset RAM registers
  30+ 03DD D1                           pop     DE              ; restore reg. E
  31+ 03DE AF                           xor     A               ; reset A
  32+ 03DF 47                           ld      B,A             ; reset B (will be used later)
  33+ 03E0 7B                           ld      A,E             ; move E into A
  34+ 03E1 32 CD 52                     ld      (SCR_MODE),A    ; store screen mode
  35+ 03E4 FE 01                        cp      $01             ; is it graphics 1 (A=1)?
  36+ 03E6 CA 22 04                     jp      Z,G1MD          ; yes, jump over
  37+ 03E9 FE 02                        cp      $02             ; is it graphics 2 (A=2)?
  38+ 03EB CA 63 04                     jp      Z,G2MD          ; yes, jump over
  39+ 03EE FE 03                        cp      $03             ; is it multicolor (A=3)?
  40+ 03F0 CA 85 04                     jp      Z,MCMD          ; yes, jump over
  41+ 03F3 FE 04                        cp      $04             ; is it extended graphics 2 (A=4)?
  42+ 03F5 CA A8 04                     jp      Z,EXG2MD        ; yes, jump over; otherwise, it must be $00 so we assume that it's text mode
  43+ 03F8
  44+ 03F8                              ; LOAD VDP SETTINGS FOR SELECTED VIDEO MODE:
  45+ 03F8                              ; TEXT MODE (G0)
  46+ 03F8              TXTMD:          ; load charset
  47+ 03F8 60                           ld      H,B
  48+ 03F9 68                           ld      L,B             ; HL=first pattern cell $0000
  49+ 03FA CD D1 0A                     call    LOADCHARSET     ; load patterns into VRAM
  50+ 03FD                              ; set cursor & video overlay
  51+ 03FD AF                           xor     A               ; reset A
  52+ 03FE 32 D1 52                     ld      (SCR_CURS_X),A  ; set cursor position at X=0
  53+ 0401 32 D2 52                     ld      (SCR_CURS_Y),A  ; and Y=0
  54+ 0404 3E 05                        ld      A,$05           ; light blue
  55+ 0406 32 DB 52                     ld      (BKGNDCLR),A    ; set background/border color
  56+ 0409 3E 28                        ld      A,$28
  57+ 040B 32 CB 52                     ld      (SCR_SIZE_W),A  ; screen width = 40 cols
  58+ 040E 3E 18                        ld      A,$18
  59+ 0410 32 CC 52                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  60+ 0413 3E 1E                        ld      A,$1E
  61+ 0415 32 A1 51                     ld      (COMMAN),A      ; width for commas (4 columns)
  62+ 0418 11 00 08                     ld      DE,$0800
  63+ 041B ED 53 CF 52                  ld      (SCR_NAM_TB),DE ; set name table address
  64+ 041F C3 EB 04                     jp      ENDVDPSET       ; execute the rest of the video setting
  65+ 0422
  66+ 0422                              ; GRAPHICS 1 MODE (G1)
  67+ 0422              G1MD:           ; load pattern table
  68+ 0422 68                           ld      L,B
  69+ 0423 60                           ld      H,B             ; HL=first pattern cell $0000
  70+ 0424 CD D1 0A                     call    LOADCHARSET     ; load patterns into VRAM
  71+ 0427                              ; set cursor & video overlay
  72+ 0427 AF                           xor     A               ; position cursor
  73+ 0428 32 D1 52                     ld      (SCR_CURS_X),A  ; at X=0
  74+ 042B 32 D2 52                     ld      (SCR_CURS_Y),A  ; and Y=0
  75+ 042E 3E 20                        ld      A,$20
  76+ 0430 32 CB 52                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
  77+ 0433 3E 18                        ld      A,$18
  78+ 0435 32 CC 52                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  79+ 0438 3E 14                        ld      A,$14
  80+ 043A 32 A1 51                     ld      (COMMAN),A      ; width for commas (3 columns)
  81+ 043D 11 00 18                     ld      DE,$1800
  82+ 0440 ED 53 CF 52                  ld      (SCR_NAM_TB),DE ; set name table address
  83+ 0444                              ; load color table
  84+ 0444 21 00 20                     ld      HL,$2000        ; color table start: $2000
  85+ 0447 CD 65 06                     call    SETVDPADRS
  86+ 044A 3E 01                        ld      A,$01           ; foreground color...
  87+ 044C 32 DA 52                     ld      (FRGNDCLR),A    ; ...set to black
  88+ 044F 3E 0F                        ld      A,$0F           ; background color...
  89+ 0451 32 DB 52                     ld      (BKGNDCLR),A    ; ...set to white
  90+ 0454 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
  91+ 0456 06 20                        ld      B,$20           ; 32 bytes of colors
  92+ 0458 0E 30                        ld      C,VDP_DAT       ; VDP data mode
  93+ 045A ED 79        LDCLRTBMD1:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
  94+ 045C 00                           nop
  95+ 045D 00                           nop
  96+ 045E 10 FA                        djnz    LDCLRTBMD1      ; repeat for 32 bytes
  97+ 0460 C3 EB 04                     jp      ENDVDPSET       ; execute the rest of the video setting
  98+ 0463
  99+ 0463                              ; GRAPHICS 2 MODE (G2)
 100+ 0463 AF           G2MD:           xor     A               ; position cursor
 101+ 0464 32 D1 52                     ld      (SCR_CURS_X),A  ; at X=0
 102+ 0467 32 D2 52                     ld      (SCR_CURS_Y),A  ; and Y=0
 103+ 046A 32 CB 52                     ld      (SCR_SIZE_W),A  ; screen width = 256 pixels (0=256)
 104+ 046D 3C                           inc     A               ; black on...
 105+ 046E 32 DA 52                     ld      (FRGNDCLR),A    ; ...foreground
 106+ 0471 3E 0F                        ld      A,$0F           ; white on...
 107+ 0473 32 DB 52                     ld      (BKGNDCLR),A    ; ...background
 108+ 0476 3E C0                        ld      A,$C0
 109+ 0478 32 CC 52                     ld      (SCR_SIZE_H),A  ; screen height = 192 pixels
 110+ 047B 11 00 18                     ld      DE,$1800
 111+ 047E ED 53 CF 52                  ld      (SCR_NAM_TB),DE ; set name table address
 112+ 0482 C3 EB 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 113+ 0485
 114+ 0485                              ; MULTICOLOR MODE (G3)
 115+ 0485 AF           MCMD:           xor     A               ; position cursor
 116+ 0486 32 D1 52                     ld      (SCR_CURS_X),A  ; at X=0
 117+ 0489 32 D2 52                     ld      (SCR_CURS_Y),A  ; and Y=0
 118+ 048C 3E 0F                        ld      A,$0F           ; white color for...
 119+ 048E 32 DB 52                     ld      (BKGNDCLR),A    ; ...background and...
 120+ 0491 32 DA 52                     ld      (FRGNDCLR),A    ; ...foreground (even this is not used in MC)
 121+ 0494 3E 40                        ld      A,$40
 122+ 0496 32 CB 52                     ld      (SCR_SIZE_W),A  ; screen width = 64 blocks
 123+ 0499 3E 30                        ld      A,$30
 124+ 049B 32 CC 52                     ld      (SCR_SIZE_H),A  ; screen height = 48 blocks
 125+ 049E 11 00 08                     ld      DE,$0800
 126+ 04A1 ED 53 CF 52                  ld      (SCR_NAM_TB),DE ; set name table address
 127+ 04A5 C3 EB 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 128+ 04A8
 129+ 04A8                              ; EXTENDED GRAPHICS 2 (G4)
 130+ 04A8              EXG2MD:         ; load pattern table
 131+ 04A8 60                           ld      H,B
 132+ 04A9 68                           ld      L,B             ; HL=first pattern cell $0000
 133+ 04AA CD D1 0A                     call    LOADCHARSET     ; load patterns into VRAM
 134+ 04AD                              ; set cursor & video overlay
 135+ 04AD AF                           xor     A               ; position cursor
 136+ 04AE 32 D1 52                     ld      (SCR_CURS_X),A  ; at X=0
 137+ 04B1 32 D2 52                     ld      (SCR_CURS_Y),A  ; and Y=0
 138+ 04B4 3E 20                        ld      A,$20
 139+ 04B6 32 CB 52                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
 140+ 04B9 3E 18                        ld      A,$18
 141+ 04BB 32 CC 52                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
 142+ 04BE 3E 14                        ld      A,$14
 143+ 04C0 32 A1 51                     ld      (COMMAN),A      ; width for commas (3 columns)
 144+ 04C3 11 00 38                     ld      DE,$3800
 145+ 04C6 ED 53 CF 52                  ld      (SCR_NAM_TB),DE ; set name table address
 146+ 04CA                               ; load color table
 147+ 04CA 21 00 20                     ld      HL,$2000        ; color table start: $2000
 148+ 04CD CD 65 06                     call    SETVDPADRS
 149+ 04D0 3E 01                        ld      A,$01           ; foreground color is...
 150+ 04D2 32 DA 52                     ld      (FRGNDCLR),A    ; ...set to black
 151+ 04D5 3E 0F                        ld      A,$0F           ; whitefor...
 152+ 04D7 32 DB 52                     ld      (BKGNDCLR),A    ; ...background
 153+ 04DA 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
 154+ 04DC 16 08                        ld      D,$08           ; 8 pages of
 155+ 04DE 06 00                        ld      B,$00           ; 256 bytes of colors (total of 2,048 cells)
 156+ 04E0 0E 30                        ld      C,VDP_DAT       ; VDP data mode
 157+ 04E2 ED 79        LDCLRTBEX2:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
 158+ 04E4 00                           nop
 159+ 04E5 00                           nop
 160+ 04E6 10 FA                        djnz    LDCLRTBEX2      ; repeat for 256 bytes
 161+ 04E8 15                           dec     D               ; did we fill up all the cells?
 162+ 04E9 20 F7                        jr      NZ,LDCLRTBEX2   ; no, repeat
 163+ 04EB                              ; LAST VDP SETTINGS
 164+ 04EB CD 07 09     ENDVDPSET:      call    CURSOR_OFF      ; disable cursor
 165+ 04EE CD D3 05                     call    EMPTYVIDBUF     ; empty video buffer
 166+ 04F1 AF                           xor     A
 167+ 04F2 32 D5 52                     ld      (SCR_ORG_CHR),A ; store byte used tochar used to empty the video buffer
 168+ 04F5 C9                           ret                     ; return to caller
 169+ 04F6
 170+ 04F6
 171+ 04F6              ; show initial logo
 172+ 04F6 CD 96 0A     SHOW_LOGO:      call    EMPTY_VRAM      ; reset VRAM
 173+ 04F9                              ; set VDP for G2 mode
 174+ 04F9 06 07                        ld      B,$07           ; set only the first 7 registers
 175+ 04FB 11 10 00                     ld      DE,$0010        ; load settings for G2 mode
 176+ 04FE CD BD 0A                     call    SET_GFX_MODE2   ; load register settings
 177+ 0501 16 01                        ld      D,$01           ; backdrop color set to black
 178+ 0503 ED 51                        out     (C),D           ; send data to VDP
 179+ 0505 ED 79                        out     (C),A           ; indicate the register to send data to
 180+ 0507                              ; set name table
 181+ 0507 21 00 18                     ld      HL,$1800        ; name table address
 182+ 050A CD 52 06                     call    SETNAMETABLE    ; set name table (load names into table)
 183+ 050D CD 71 05                     call    ERASECLRTBL     ; erase color table (set foreground & background to black)
 184+ 0510                              ; set colors for logo
 185+ 0510 21 00 28                     ld      HL,$2800        ; 2nd page of color table
 186+ 0513 CD 65 06                     call    SETVDPADRS
 187+ 0516 06 05                        ld      B,5             ; 5 bands
 188+ 0518 21 BE 05                     ld      HL,CLRTABLE
 189+ 051B 0E 30                        ld      C,VDP_DAT
 190+ 051D 1E 08                        ld      E,$08           ; 8 pixels each pattern
 191+ 051F 16 40        RPT101:         ld      D,$40           ; 64 chars each band
 192+ 0521 7E                           ld      A,(HL)
 193+ 0522 ED 79        RPT102:         out     (C),A
 194+ 0524 00                           nop
 195+ 0525 1D                           dec     E
 196+ 0526 20 FA                        jr      NZ,RPT102
 197+ 0528 1E 08                        ld      E,$08
 198+ 052A 15                           dec     D
 199+ 052B 20 F5                        jr      NZ,RPT102
 200+ 052D 23                           inc     HL
 201+ 052E 10 EF                        djnz    RPT101
 202+ 0530                              ; set pattern table
 203+ 0530 21 00 08                     ld      HL,$0800        ; address of first cell of 2nd area of pattern table
 204+ 0533 11 1A 0B                     ld      DE,LM80CLOGO    ; pointer to logo pattern
 205+ 0536 06 00                        ld      B,$00           ; 256 bytes, 8 rows
 206+ 0538 CD 9D 05     RPT103:         call    LOADLOGOCHRS
 207+ 053B 13                           inc     DE              ; next logo pattern
 208+ 053C 10 FA                        djnz    RPT103
 209+ 053E 06 20                        ld      B,$20           ; repeat for another 2 rows
 210+ 0540 CD 9D 05     RPT104:         call    LOADLOGOCHRS
 211+ 0543 13                           inc     DE              ; next logo pattern
 212+ 0544 10 FA                        djnz    RPT104
 213+ 0546                              ; show logo/message, play a beep, check for SHIFT pressure (to disable DOS), and wait a while
 214+ 0546 06 02                        ld      B,$02
 215+ 0548 AF                           xor     A
 216+ 0549 57                           ld      D,A             ; 256 times
 217+ 054A 5F                           ld      E,A             ; x 256 times
 218+ 054B 32 DC 52                     ld      (TMPBFR1),A     ; sound flag set to 0
 219+ 054E 3C                           inc     A               ; A=1
 220+ 054F 32 21 53                     ld      (DOS_EN),A      ; DOS enabled
 221+ 0552 00           DEC_D:          nop                     ; does nothing...
 222+ 0553 00                           nop
 223+ 0554 00                           nop
 224+ 0555 00                           nop
 225+ 0556 00                           nop
 226+ 0557 00                           nop
 227+ 0558 1D                           dec     E               ; decrement E
 228+ 0559 20 F7                        jr      NZ,DEC_D        ; repeat until $00
 229+ 055B 7A                           ld      A,D
 230+ 055C FE 40                        cp      $40             ; ...equal to 64
 231+ 055E CC 89 05                     call    Z,SETBEEP       ; if yes, start sound
 232+ 0561 15                           dec     D
 233+ 0562 20 EE                        jr      NZ,DEC_D        ; repeat
 234+ 0564 3A DC 52                     ld      A,(TMPBFR1)
 235+ 0567 FE 02                        cp      $02
 236+ 0569 C4 95 05                     call    NZ,BEEPOFF
 237+ 056C CD C3 05                     call    CHECKSHIFT
 238+ 056F 10 E1                        djnz    DEC_D
 239+ 0571              ERASECLRTBL:    ; erase color table
 240+ 0571 3E 11                        ld      A,$11           ; foreground and background set to black
 241+ 0573 16 0A                        ld      D,$0A           ; 10 pages
 242+ 0575 06 00                        ld      B,$00           ; 256 color cells per page
 243+ 0577 21 00 28                     ld      HL,$2800        ; first cell of 2nd color table
 244+ 057A CD 65 06                     call    SETVDPADRS      ; send address
 245+ 057D 0E 30                        ld      C,VDP_DAT       ; VDP address for passing data
 246+ 057F ED 79        RPT100:         out     (C),A           ; send data
 247+ 0581 00                           nop
 248+ 0582 00                           nop                     ; little delay
 249+ 0583 10 FA                        djnz    RPT100          ; repeat for entire page
 250+ 0585 15                           dec     D
 251+ 0586 20 F7                        jr      NZ,RPT100       ; repeat for all the pages ($0A00 cells)
 252+ 0588 C9                           ret                     ; return to caller
 253+ 0589
 254+ 0589              ; play a beep
 255+ 0589 3A DC 52     SETBEEP:        ld      A,(TMPBFR1)     ; check the already-beeped flag
 256+ 058C B7                           or      A               ; is it 0?
 257+ 058D C0                           ret     NZ              ; no, exit
 258+ 058E 3C                           inc     A               ; flag to 1
 259+ 058F 32 DC 52                     ld      (TMPBFR1),A     ; set sound
 260+ 0592 C3 88 0C                     jp      WLCMBEEP        ; play a beep & return
 261+ 0595
 262+ 0595              ; beep off
 263+ 0595 3E 02        BEEPOFF:        ld      A,$02           ; flag for sound off
 264+ 0597 32 DC 52                     ld      (TMPBFR1),A     ; set flag
 265+ 059A C3 8E 0C                     jp      NOBEEP          ; stop beep and return
 266+ 059D
 267+ 059D
 268+ 059D              ; used to load the chars that will compose the logo of the splash screen
 269+ 059D 1A           LOADLOGOCHRS:   ld      A,(DE)          ; load a pattern char of the logo
 270+ 059E 87                           add     A,A
 271+ 059F 87                           add     A,A
 272+ 05A0 87                           add     A,A             ; multiply times 8 to get the offset
 273+ 05A1 C5                           push    BC
 274+ 05A2 D5                           push    DE              ; store BC and DE
 275+ 05A3 E5                           push    HL              ; store VRAM address to write to
 276+ 05A4 21 FA 4F                     ld      HL,LOGOFONT     ; start of logo font data
 277+ 05A7 5F                           ld      E,A
 278+ 05A8 16 00                        ld      D,$00           ; put offset (A) into DE
 279+ 05AA 19                           add     HL,DE           ; get address of pattern data
 280+ 05AB EB                           ex      DE,HL           ; move address into DE
 281+ 05AC E1                           pop     HL              ; retrieve VRAM address
 282+ 05AD 06 08                        ld      B,$08           ; 8 bytes per pattern
 283+ 05AF CD 65 06                     call    SETVDPADRS      ; set VDP address
 284+ 05B2 0E 30                        ld      C,VDP_DAT
 285+ 05B4 1A           SNDLOGPT:       ld      A,(DE)          ; load data from RAM
 286+ 05B5 ED 79                        out     (C),A           ; and send to VRAM
 287+ 05B7 13                           inc     DE              ; next byte into RAM
 288+ 05B8 23                           inc     HL              ; next byte into VRAM (used in future iterations)
 289+ 05B9 10 F9                        djnz    SNDLOGPT        ; repeat 8 times
 290+ 05BB D1                           pop     DE
 291+ 05BC C1                           pop     BC              ; retrieve BC & DE
 292+ 05BD C9                           ret                     ; return to caller
 293+ 05BE              CLRTABLE:       equ $
 294+ 05BE 18 1B 13 14                  defb    $18,$1B,$13,$14,$1D ; colors of background bands of the logo
 294+ 05C2 1D
 295+ 05C3
 296+ 05C3
 297+ 05C3              ; while showing the logo, check if SPACE bar is being pressed
 298+ 05C3              ; if yes, then disable DOS functions recovering RAM
 299+ 05C3 F5           CHECKSHIFT:     push    AF
 300+ 05C4 3E FD                        ld      A,%11111101     ; select SHIFT row
 301+ 05C6 CD 0C 0D                     call    READKBLN        ; read row
 302+ 05C9 CB 5F                        bit     3,A             ; test if SHIFT key is pressed (4th bit is reset)
 303+ 05CB 20 04                        jr      NZ,LVCKSHF      ; no, leave
 304+ 05CD AF                           xor     A               ; yes, so...
 305+ 05CE 32 21 53                     ld      (DOS_EN),A      ; ...disable DOS
 306+ 05D1 F1           LVCKSHF:        pop     AF
 307+ 05D2 C9                           ret
 308+ 05D3
 309+ 05D3
 310+ 05D3              ; empty video buffer
 311+ 05D3 3A CD 52     EMPTYVIDBUF:    ld      A,(SCR_MODE)    ; check screen mode
 312+ 05D6 FE 02                        cp      $02             ; is it G2 mode?
 313+ 05D8 CA FC 05                     jp      Z,EMPTYG2       ; yes, jump over
 314+ 05DB FE 03                        cp      $03             ; is it MC mode?
 315+ 05DD CA 2D 06                     jp      Z,EMPTYMC       ; yes, jump over
 316+ 05E0 3A CC 52                     ld      A,(SCR_SIZE_H)  ; load height of screen
 317+ 05E3 47                           ld      B,A             ; move rows into B
 318+ 05E4 AF                           xor     A               ; filling char is $00
 319+ 05E5 2A CF 52                     ld      HL,(SCR_NAM_TB) ; load the name table address
 320+ 05E8 CD 65 06                     call    SETVDPADRS      ; send address to VDP
 321+ 05EB 0E 30                        ld      C,VDP_DAT       ; VDP address for passing data
 322+ 05ED 5F           LDCOLSTOEMPTY:  ld      E,A             ; store filling char into E
 323+ 05EE 3A CB 52                     ld      A,(SCR_SIZE_W)  ; load # of cols to empty into A
 324+ 05F1 57                           ld      D,A             ; move A into D
 325+ 05F2 7B                           ld      A,E             ; recover filling char
 326+ 05F3 ED 79        RPTEMPTYBUF:    out     (C),A           ; write empty byte into VRAM
 327+ 05F5 00                           nop
 328+ 05F6 15                           dec     D               ; decr. D
 329+ 05F7 20 FA                        jr      NZ,RPTEMPTYBUF  ; repeat for the # of cols
 330+ 05F9 10 F2                        djnz    LDCOLSTOEMPTY   ; repeat for the # of rows
 331+ 05FB C9                           ret                     ; return to caller
 332+ 05FC 2A CF 52     EMPTYG2:        ld      HL,(SCR_NAM_TB) ; yes, additional setup for G2 - load G2 name table address (usually $1800)
 333+ 05FF CD 52 06                     call    SETNAMETABLE    ; set name table
 334+ 0602 21 00 00                     ld      HL,$0000        ; set pattern table
 335+ 0605 CD 65 06                     call    SETVDPADRS      ; send address to VDP
 336+ 0608 AF                           xor     A               ; empty pattern
 337+ 0609 16 18                        ld      D,$18           ; 6144 ($1800) cell to clean, 24 pages ($18)
 338+ 060B 47                           ld      B,A             ; 256 bytes for page
 339+ 060C 0E 30                        ld      C,VDP_DAT       ; VDP data mode
 340+ 060E ED 79        CLRG2PTNTBL:    out     (C),A           ; clear pattern
 341+ 0610 00                           nop                     ; little delay
 342+ 0611 00                           nop
 343+ 0612 10 FA                        djnz    CLRG2PTNTBL     ; repeat for 1 page
 344+ 0614 15                           dec     D               ; next page
 345+ 0615 20 F7                        jr      NZ,CLRG2PTNTBL  ; repeat
 346+ 0617 21 00 20                     ld      HL,$2000        ; load the color table address
 347+ 061A CD 65 06                     call    SETVDPADRS      ; send address to VDP
 348+ 061D 3A DA 52                     ld      A,(FRGNDCLR)    ; load foreground
 349+ 0620 87                           add     A,A
 350+ 0621 87                           add     A,A
 351+ 0622 87                           add     A,A
 352+ 0623 87                           add     A,A             ; move to high nibble
 353+ 0624 57                           ld      D,A             ; store into D
 354+ 0625 3A DB 52                     ld      A,(BKGNDCLR)    ; load background color
 355+ 0628 B2                           or      D               ; combine with background color
 356+ 0629 16 18                        ld      D,$18           ; 6144 ($1800) cells to fill, so 24 pages ($18)
 357+ 062B 18 17                        jr      STARTEMPTY
 358+ 062D 21 00 08     EMPTYMC:        ld      HL,$0800        ; MC name table
 359+ 0630 CD 52 06                     call    SETNAMETABLE    ; set name table
 360+ 0633 21 00 00                     ld      HL,$0000        ; color table address
 361+ 0636 CD 65 06                     call    SETVDPADRS      ; send address to VDP
 362+ 0639 3A DB 52                     ld      A,(BKGNDCLR)    ; load background
 363+ 063C 57                           ld      D,A             ; store into D
 364+ 063D 87                           add     A,A
 365+ 063E 87                           add     A,A
 366+ 063F 87                           add     A,A
 367+ 0640 87                           add     A,A             ; move to high nibble
 368+ 0641 B2                           or      D               ; set background color for high and low nibble
 369+ 0642 16 08                        ld      D,$08           ; 2048 ($0800) cells to fill, so 8 pages ($08)
 370+ 0644 0E 30        STARTEMPTY:     ld      C,VDP_DAT       ; VDP address for passing data
 371+ 0646 06 00                        ld      B,$00           ; 256 bytes each page ($00=256)
 372+ 0648 ED 79        SNDCLRSET:      out     (C),A           ; send color setting
 373+ 064A 00                           nop                     ; wait a while
 374+ 064B 00                           nop
 375+ 064C 10 FA                        djnz    SNDCLRSET       ; repeat for 1 page
 376+ 064E 15                           dec     D               ; have we filled all the pages?
 377+ 064F 20 F7                        jr      NZ,SNDCLRSET    ; no, repeat
 378+ 0651 C9                           ret                     ; return to caller
 379+ 0652
 380+ 0652              ; set name table for G2 mode (patterns from $00 to $FF for each of the 3 areas of the screen)
 381+ 0652 CD 65 06     SETNAMETABLE:   call    SETVDPADRS      ; send address to VDP
 382+ 0655 0E 30                        ld      C,VDP_DAT       ; VDP address for passing data
 383+ 0657 16 03                        ld      D,$03           ; 3 pages to fill into VRAM (768 cells)
 384+ 0659 AF                           xor     A               ; starting char name #0 (chars go from 0 to 255)
 385+ 065A 47                           ld      B,A             ; reset B
 386+ 065B ED 79        RPTFLL1:        out     (C),A           ; send name to VRAM
 387+ 065D 00                           nop
 388+ 065E 3C                           inc     A               ; increment # of name
 389+ 065F 10 FA                        djnz    RPTFLL1         ; repeat for 256 cells (1 page)
 390+ 0661 15                           dec     D               ; did we fill all the pages?
 391+ 0662 20 F7                        jr      NZ,RPTFLL1      ; no, continue
 392+ 0664 C9                           ret                     ; return to caller
 393+ 0665
 394+ 0665              ; set an address into VRAM: address is in HL
 395+ 0665 0E 32        SETVDPADRS:     ld      C,VDP_SET       ; VDP address mode
 396+ 0667 CB F4                        set     6,H             ; set bit #6 of address, to write to VRAM
 397+ 0669 ED 69                        out     (C),L           ; send low and...
 398+ 066B ED 61                        out     (C),H           ; ...high byte of the first cell
 399+ 066D C9                           ret                     ; return to caller
 400+ 066E
 401+ 066E              ; clear the video buffer and position the cursor at 0,0
 402+ 066E CD D3 05     CLEARVIDBUF:    call    EMPTYVIDBUF     ; clear video buffer
 403+ 0671 AF                           xor     A               ; reset A
 404+ 0672 32 D1 52                     ld      (SCR_CURS_X),A  ; cursor X to 0
 405+ 0675 32 D2 52                     ld      (SCR_CURS_Y),A  ; cursor Y to 0
 406+ 0678 C3 C1 06                     jp      POS_CURSOR      ; position cursor & return to caller
 407+ 067B
 408+ 067B              ; HOME: position the cursor at coords. 0,0
 409+ 067B AF           ATHOME:         xor     A               ; position cursor at 0,0 by storing...
 410+ 067C 32 D4 52                     ld      (SCR_CUR_NY),A  ; ...new Y...
 411+ 067F 32 D3 52                     ld      (SCR_CUR_NX),A  ; ...and new X
 412+ 0682 C3 CB 06                     jp      MOVCRS          ; move cursor to new location & return to caller
 413+ 0685
 414+ 0685              ; load the char or byte at the VRAM position set by HL
 415+ 0685              ; value is returned into A
 416+ 0685 C5           READ_VIDEO_LOC: push    BC              ; store BC
 417+ 0686 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 418+ 0688 44                           ld      B,H
 419+ 0689 CB B8                        res     7,B
 420+ 068B CB B0                        res     6,B
 421+ 068D ED 69                        out     (C),L           ; low byte then...
 422+ 068F ED 41                        out     (C),B           ; high byte
 423+ 0691 0E 30                        ld      C,VDP_DAT       ; VDP data mode
 424+ 0693 00                           nop                     ; wait...
 425+ 0694 00                           nop                     ; ...a while
 426+ 0695 00                           nop
 427+ 0696 ED 78                        in      A,(C)           ; read byte at current VRAM location
 428+ 0698 C1                           pop     BC              ; restore BC
 429+ 0699 C9                           ret                     ; return to caller
 430+ 069A
 431+ 069A              ; write a byte at the VRAM position pointed by HL
 432+ 069A              ; value is in A
 433+ 069A C5           WRITE_VIDEO_LOC:push    BC              ; store BC
 434+ 069B 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 435+ 069D 44                           ld      B,H             ; copy H into B
 436+ 069E CB B8                        res     7,B
 437+ 06A0 CB F0                        set     6,B             ; write to VRAM
 438+ 06A2 ED 69                        out     (C),L           ; low byte then...
 439+ 06A4 ED 41                        out     (C),B           ; high byte of VRAM address
 440+ 06A6 0E 30                        ld      C,VDP_DAT       ; VDP data mode
 441+ 06A8 00                           nop                     ; wait...
 442+ 06A9 00                           nop                     ; ...a while
 443+ 06AA 00                           nop
 444+ 06AB ED 79                        out     (C),A           ; write byte into VRAM
 445+ 06AD C1                           pop     BC              ; restore BC
 446+ 06AE C9                           ret                     ; return to caller
 447+ 06AF
 448+ 06AF              ; write a value into a specific VDP register
 449+ 06AF              ; value is in E, register is in A
 450+ 06AF C5           WRITE_VREG:     push    BC              ; store BC
 451+ 06B0 C6 80                        add     A,$80           ; set VDP to write to registers
 452+ 06B2 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 453+ 06B4 ED 59                        out     (C),E           ; send data to VDP
 454+ 06B6 ED 79                        out     (C),A           ; select the destination register
 455+ 06B8 C1                           pop     BC              ; restore BC
 456+ 06B9 C9                           ret                     ; return to caller
 457+ 06BA
 458+ 06BA              ; read VDP status register and return value into A
 459+ 06BA C5           READ_VSTAT:     push    BC              ; store BC
 460+ 06BB 0E 32                        ld      C,VDP_SET       ; VDP register access
 461+ 06BD ED 78                        in      A,(C)           ; read status register
 462+ 06BF C1                           pop     BC              ; restore BC
 463+ 06C0 C9                           ret                     ; return to caller
 464+ 06C1
 465+ 06C1              ; position the cursor at the current coordinates, preserving underlying char
 466+ 06C1 CD 04 07     POS_CURSOR:     call    LOAD_CRSR_POS   ; load the VRAM address of cursor into HL
 467+ 06C4 CD 85 06                     call    READ_VIDEO_LOC  ; load the current char at the cursor position (return in A)
 468+ 06C7 32 D5 52                     ld      (SCR_ORG_CHR),A ; store the current char
 469+ 06CA C9                           ret
 470+ 06CB
 471+ 06CB              ; move cursor to new X,Y coordinates
 472+ 06CB CD FB 06     MOVCRS:         call    RSTCHRCRS       ; restore the char in the current cursor position
 473+ 06CE CD E6 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 474+ 06D1 CD C1 06     MOVSHOWCRS:     call    POS_CURSOR      ; position cursor into new location
 475+ 06D4 3A D6 52                     ld      A,(CRSR_STATE)  ; load status of cursor
 476+ 06D7 A7                           and     A               ; is cursor off?
 477+ 06D8 C8                           ret     Z               ; yes, return
 478+ 06D9 3A D7 52                     ld      A,(LSTCSRSTA)   ; it's visible, so...
 479+ 06DC F6 20                        or      $20             ; ...set cursor on
 480+ 06DE 32 D7 52                     ld      (LSTCSRSTA),A   ; store the last cursor state
 481+ 06E1 3E FF                        ld      A,$FF           ; set cursor visible after moved it
 482+ 06E3 C3 9A 06                     jp      WRITE_VIDEO_LOC ; write into video cell
 483+ 06E6
 484+ 06E6
 485+ 06E6              ; set new cursor's coordinates:
 486+ 06E6 3A D3 52     NEWCRSRCOORD:   ld      A,(SCR_CUR_NX)  ; load new X
 487+ 06E9 32 D1 52                     ld      (SCR_CURS_X),A  ; write new X
 488+ 06EC 3A D4 52                     ld      A,(SCR_CUR_NY)  ; load new Y
 489+ 06EF 32 D2 52                     ld      (SCR_CURS_Y),A  ; write new Y
 490+ 06F2 3E FF                        ld      A,$FF           ; delete new values
 491+ 06F4 32 D3 52                     ld      (SCR_CUR_NX),A  ; of X
 492+ 06F7 32 D4 52                     ld      (SCR_CUR_NY),A  ; and Y
 493+ 06FA C9                           ret
 494+ 06FB
 495+ 06FB              ; recover char under the cursor and prints it onto the screen
 496+ 06FB CD 04 07     RSTCHRCRS:      call    LOAD_CRSR_POS   ; recover old cursor position
 497+ 06FE 3A D5 52                     ld      A,(SCR_ORG_CHR) ; recover old char
 498+ 0701 C3 9A 06                     jp      WRITE_VIDEO_LOC ; write char into VRAM & return
 499+ 0704
 500+ 0704              ; retrieve cursor position from either current coordinates or next place
 501+ 0704              ; return address position into HL
 502+ 0704 3A D2 52     LOAD_CRSR_POS:  ld      A,(SCR_CURS_Y)  ; load cursor Y
 503+ 0707 6F                           ld      L,A             ; move it into reg.L
 504+ 0708 AF                           xor     A               ; reset A
 505+ 0709 67                           ld      H,A             ; reset H
 506+ 070A 47                           ld      B,A             ; reset B
 507+ 070B 29                           add     HL,HL           ; create offset (each address is 2-bytes long so we need to double HL)
 508+ 070C 11 66 0A                     ld      DE,POS_TB_CRS_40; load position table address of cursor for 40 cols
 509+ 070F 3A CB 52                     ld      A,(SCR_SIZE_W)  ; load screen width
 510+ 0712 FE 28                        cp      $28             ; is it 40 cols?
 511+ 0714 28 03                        jr      Z,CONT_POS_CURS ; yes, jump over
 512+ 0716 11 36 0A                     ld      DE,POS_TB_CRS_32; no, load position table address of cursor for 32 cols
 513+ 0719 19           CONT_POS_CURS:  add     HL,DE           ; the correct starting address of the required row is now into HL
 514+ 071A 5E                           ld      E,(HL)         ; load starting address of the required row into DE
 515+ 071B 23                           inc     HL
 516+ 071C 56                           ld      D,(HL)
 517+ 071D 2A CF 52                     ld      HL,(SCR_NAM_TB) ; load starting address of name table
 518+ 0720 19                           add     HL,DE           ; starting address of the current row into name table
 519+ 0721 3A D1 52                     ld      A,(SCR_CURS_X)  ; load cursor X
 520+ 0724 4F                           ld      C,A             ; transfer A into C
 521+ 0725 09                           add     HL,BC           ; add X offset: now HL contains the address of the current cursor position
 522+ 0726 C9                           ret
 523+ 0727
 524+ 0727              ; find X,Y coordinates of a screen address pointed in VRAM by HL
 525+ 0727              ; return them into L,A for X,Y
 526+ 0727 D5           HL2XY:          push    DE              ; store DE
 527+ 0728 ED 5B CF 52                  ld      DE,(SCR_NAM_TB) ; load starting address of name table into DE
 528+ 072C AF                           xor     A               ; clear Carry
 529+ 072D ED 52                        sbc     HL,DE           ; find position relative to screen (from 0,0)
 530+ 072F D1                           pop     DE
 531+ 0730 3A CB 52                     ld      A,(SCR_SIZE_W)  ; load screen width
 532+ 0733 4F                           ld      C,A             ; move it into C
 533+ 0734 CD D6 3F                     call    DIV_16_8        ; divide position by C: return Y into L and X into A
 534+ 0737 C9                           ret                     ; return to caller
 535+ 0738
 536+ 0738              ;-------------------------------------------------------------------------------
 537+ 0738              ; char table for jumps
 538+ 0738 19           CHRTBL:         defb    HOME
 539+ 0739 7B 06                        defw    ATHOME          ; move the cursor to 0,0
 540+ 073B
 541+ 073B 0C                           defb    CS
 542+ 073C 6E 06                        defw    CLEARVIDBUF     ; clear video buffer and position cursor at 0,0
 543+ 073E
 544+ 073E 0D                           defb    CR
 545+ 073F 89 09                        defw    CRGRETURN       ; go to the beginning of the next line
 546+ 0741
 547+ 0741 08                           defb    BKSP
 548+ 0742 25 08                        defw    BACKSPACE       ; move cursor left 1 position
 549+ 0744
 550+ 0744 1C                           defb    CRSLFT
 551+ 0745 38 08                        defw    CURSORLEFT      ; move cursor left
 552+ 0747
 553+ 0747 1E                           defb    CRSUP
 554+ 0748 84 08                        defw    CURSORUP        ; move cursor up
 555+ 074A
 556+ 074A 1D                           defb    CRSRGT
 557+ 074B 9D 08                        defw    CURSORRIGHT     ; move cursor right
 558+ 074D
 559+ 074D 1F                           defb    CRSDN
 560+ 074E D2 08                        defw    CURSORDOWN      ; move cursor up
 561+ 0750
 562+ 0750 1A                           defb    INSRT
 563+ 0751 E4 07                        defw    INSERTKEY       ; insert a space
 564+ 0753
 565+ 0753 0A                           defb    LF
 566+ 0754 BF 07                        defw    PLACEHOLDER     ; CURRENTLY WE DON'T PRINT LINE FEED
 567+ 0756
 568+ 0756              ; send current char to video buffer
 569+ 0756 F5           CHAR2VID:       push    AF              ; store AF
 570+ 0757 C5                           push    BC              ; store BC
 571+ 0758 D5                           push    DE              ; store DE
 572+ 0759 E5                           push    HL              ; store HL
 573+ 075A 3A D6 52                     ld      A,(CRSR_STATE)  ; store cursor state...
 574+ 075D F5                           push    AF              ; into stack
 575+ 075E CD 07 09                     call    CURSOR_OFF      ; cursor off
 576+ 0761 3A D9 52                     ld      A,(CHR4VID)     ; recover char
 577+ 0764 06 0A                        ld      B,$0A           ; 10 chars to check
 578+ 0766 21 38 07                     ld      HL,CHRTBL       ; address of key table
 579+ 0769 BE           RPTCPCK:        cp      (HL)            ; compare with char
 580+ 076A 23                           inc     HL              ; beginning of sub-routine address
 581+ 076B 20 09                        jr      NZ,NXTCPCK      ; different, go to next char
 582+ 076D 5E                           ld      E,(HL)          ; load addres into DE
 583+ 076E 23                           inc     HL
 584+ 076F 56                           ld      D,(HL)
 585+ 0770 EB                           ex      DE,HL           ; move user routine's address into HL
 586+ 0771 11 B2 07                     ld      DE,EXITCHAR2VID ; set point of return after the user routine
 587+ 0774 D5                           push    DE              ; store into stack
 588+ 0775 E9                           jp      (HL)            ; call user routine - then, the CPU will return (jump) to EXITCHAR2VID
 589+ 0776 23           NXTCPCK:        inc     HL              ; jump over 2 cells...
 590+ 0777 23                           inc     HL              ; ...to the next char code
 591+ 0778 10 EF                        djnz    RPTCPCK         ; repeat
 592+ 077A                              ; it'a not a special char, just print it
 593+ 077A CD 04 07                     call    LOAD_CRSR_POS   ; recover position of cursor
 594+ 077D 3A D9 52                     ld      A,(CHR4VID)     ; recover char to print
 595+ 0780 CD 9A 06                     call    WRITE_VIDEO_LOC ; write A into VRAM at (HL)
 596+ 0783 3A D2 52                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 597+ 0786 5F                           ld      E,A             ; store cursor Y into E
 598+ 0787 3A D1 52                     ld      A,(SCR_CURS_X)  ; load cursor X
 599+ 078A 3C                           inc     A               ; move 1 step to right
 600+ 078B 21 CB 52                     ld      HL,SCR_SIZE_W   ; cell that keeps the width of screen
 601+ 078E BE                           cp      (HL)            ; have we reached the most right position?
 602+ 078F 20 0F                        jr      NZ,SETCSRCOORDS ; no, go over
 603+ 0791 1C                           inc     E               ; yes, increment cursor Y (go to next line)
 604+ 0792 7B                           ld      A,E             ; move cursor Y into A
 605+ 0793 21 CC 52                     ld      HL,SCR_SIZE_H   ; cell that keeps the height of screen
 606+ 0796 BE                           cp      (HL)            ; have we reached the bottom of the screen?
 607+ 0797 20 06                        jr      NZ,SETCRSRY     ; no, jump over
 608+ 0799 D5                           push    DE
 609+ 079A CD 0E 09                     call    SCROLLUP        ; scroll screen up
 610+ 079D D1                           pop     DE
 611+ 079E 1D                           dec     E               ; decrement 1 row, to set cursor Y on the last line
 612+ 079F AF           SETCRSRY:       xor     A               ; then set cursor X to 0 (go to beginning of line)
 613+ 07A0 32 D1 52     SETCSRCOORDS:   ld      (SCR_CURS_X),A  ; store current cursor X
 614+ 07A3 7B                           ld      A,E             ; recover Y
 615+ 07A4 32 D2 52                     ld      (SCR_CURS_Y),A  ; store current cursor Y
 616+ 07A7 CD C1 06                     call    POS_CURSOR      ; position cursor into new location
 617+ 07AA 3A BB 52                     ld      A,(TMRCNT)      ; load status of cursor flashing
 618+ 07AD E6 20                        and     $20             ; check cursor state
 619+ 07AF 32 D7 52                     ld      (LSTCSRSTA),A   ; store the last cursor state
 620+ 07B2 AF           EXITCHAR2VID:   xor     A               ; reset char
 621+ 07B3 32 D9 52                     ld      (CHR4VID),A     ; to be sent to screen
 622+ 07B6 F1                           pop     AF              ; recover cursor state
 623+ 07B7 A7                           and     A               ; was it off (A=0)?
 624+ 07B8 C4 F2 08                     call    NZ,CURSOR_ON    ; no, set cursor on
 625+ 07BB E1                           pop     HL              ; restore HL
 626+ 07BC D1                           pop     DE              ; restore DE
 627+ 07BD C1                           pop     BC              ; restore BC
 628+ 07BE F1                           pop     AF              ; restore AF
 629+ 07BF C9           PLACEHOLDER:    ret                     ; return to caller
 630+ 07C0
 631+ 07C0              ; flash the cursor at the current position
 632+ 07C0              ; (this sub-routine is called by CH3 timer ISR)
 633+ 07C0 3A D6 52     FLASHCURSOR:    ld      A,(CRSR_STATE)  ; now, check the cursor
 634+ 07C3 A7                           and     A               ; cursor off (A=0)?
 635+ 07C4 C8                           ret     Z               ; yes, return
 636+ 07C5 3A BB 52                     ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
 637+ 07C8 E6 20                        and     $20             ; check if it's time to flash the cursor (check bit #6)
 638+ 07CA 21 D7 52                     ld      HL,LSTCSRSTA    ; load address of cell that stores the last cursor state
 639+ 07CD 46                           ld      B,(HL)          ; load last state
 640+ 07CE B8                           cp      B               ; compare current state with last state
 641+ 07CF C8                           ret     Z               ; same state, no change required - exit
 642+ 07D0 77                           ld      (HL),A          ; save new state
 643+ 07D1 F5                           push    AF              ; store A (keep state for later use)
 644+ 07D2 CD 04 07                     call    LOAD_CRSR_POS   ; load current cursor position into HL
 645+ 07D5 F1                           pop     AF              ; recover current state
 646+ 07D6 06 FF                        ld      B,$FF           ; cursor char
 647+ 07D8 FE 20                        cp      $20             ; is the cursor on video (A == $20)?
 648+ 07DA 28 04                        jr      Z,PUTCRSCHR     ; yes, jump over
 649+ 07DC 3A D5 52                     ld      A,(SCR_ORG_CHR) ; no, load the original char
 650+ 07DF 47                           ld      B,A             ; move char into B
 651+ 07E0 78           PUTCRSCHR:      ld      A,B             ; recover char from B
 652+ 07E1 C3 9A 06                     jp      WRITE_VIDEO_LOC ; print cursor/char at the current position & return
 653+ 07E4
 654+ 07E4
 655+ 07E4              ; insert an empty space at the current position of the cursor, moving the following text
 656+ 07E4              ; 1 cell straight
 657+ 07E4 CD FB 06     INSERTKEY:      call    RSTCHRCRS       ; restore char under the cursor
 658+ 07E7 CD 04 07                     call    LOAD_CRSR_POS   ; retrieve address of cursor cell
 659+ 07EA 22 DC 52                     ld      (CUR_POS),HL    ; store it
 660+ 07ED CD 10 0A                     call    ENDOFLN         ; find address of first free cell after the end of the text from the current cursor position - address into HL -
 661+ 07F0                                                      ; DE is the address of the bottom right cell of the screen
 662+ 07F0 22 E0 52                     ld      (ENDTXT),HL     ; store it
 663+ 07F3 ED 4B DC 52                  ld      BC,(CUR_POS)    ; load starting address
 664+ 07F7 AF                           xor     A
 665+ 07F8 ED 42                        sbc     HL,BC           ; how many positions to move?
 666+ 07FA CA D1 06                     jp      Z,MOVSHOWCRS    ; none - leave and re-place cursor
 667+ 07FD 44 4D                        ld      BC,HL           ; number of chars to scroll into BC
 668+ 07FF 2A E0 52                     ld      HL,(ENDTXT)     ; load address of the end of text
 669+ 0802 2B           CHKHL:          dec     HL              ; decrement to find the address of the char to move
 670+ 0803 E5                           push    HL
 671+ 0804 CD 97 3F                     call    CMP16           ; is it the last cell (bottom right) of screen?
 672+ 0807 E1                           pop     HL
 673+ 0808 D2 13 08                     jp      NC,NXTINST      ; yes, so jump over - nothing to do
 674+ 080B CD 85 06                     call    READ_VIDEO_LOC  ; no, so read current char
 675+ 080E 23                           inc     HL              ; next cell
 676+ 080F CD 9A 06                     call    WRITE_VIDEO_LOC ; write into new position
 677+ 0812 2B                           dec     HL              ; decrement to old position
 678+ 0813 0B           NXTINST:        dec     BC              ; decrement number of chars to move
 679+ 0814 79                           ld      A,C
 680+ 0815 B0                           or      B               ; finished?
 681+ 0816 20 EA                        jr      NZ,CHKHL        ; no, repeat
 682+ 0818 AF           ENDINSRT:       xor     A
 683+ 0819 2A DC 52                     ld      HL,(CUR_POS)
 684+ 081C 32 D5 52                     ld      (SCR_ORG_CHR),A ; reset original char under the cursor
 685+ 081F CD 9A 06                     call    WRITE_VIDEO_LOC ; empty current video location
 686+ 0822 C3 D1 06                     jp      MOVSHOWCRS      ; re-place cursor
 687+ 0825
 688+ 0825              ; delete the char at the left of the cursor
 689+ 0825 CD 61 08     BACKSPACE:      call    MVCRS2LFT       ; prepare to move cursor to left
 690+ 0828 CD FB 06                     call    RSTCHRCRS       ; restore char under the cursor
 691+ 082B CD E6 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 692+ 082E CD 04 07                     call    LOAD_CRSR_POS   ; find address of new video cell
 693+ 0831 AF                           xor     A               ; null char
 694+ 0832 CD 9A 06                     call    WRITE_VIDEO_LOC ; write into video cell
 695+ 0835 C3 D1 06                     jp      MOVSHOWCRS      ; move cursor to the new location and set it ON
 696+ 0838
 697+ 0838
 698+ 0838              ; move cursor to left
 699+ 0838 F5           CURSORLEFT:     push    AF              ; store A
 700+ 0839 3A D1 52                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 701+ 083C A7                           and     A               ; is it at the most left of the screen (X=0)?
 702+ 083D 28 0C                        jr      Z,CHCKYPOS      ; yes, check Y position
 703+ 083F 3D                           dec     A               ; no, decrement X
 704+ 0840 32 D3 52                     ld      (SCR_CUR_NX),A  ; store new X
 705+ 0843 3A D2 52                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 706+ 0846 32 D4 52                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 707+ 0849 18 11                        jr      CONTCRSLFT      ; go on moving cursor
 708+ 084B 3A D2 52     CHCKYPOS:       ld      A,(SCR_CURS_Y)  ; load cursor Y
 709+ 084E A7                           and     A               ; is it at the most top of the screen (Y=0)?
 710+ 084F 28 0E                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 711+ 0851 3D                           dec     A               ; no, decrement Y
 712+ 0852 32 D4 52                     ld      (SCR_CUR_NY),A  ; store new Y
 713+ 0855 3A CB 52                     ld      A,(SCR_SIZE_W)  ; load current screen width
 714+ 0858 3D                           dec     A               ; cursor to the most right position (width-0)
 715+ 0859 32 D3 52                     ld      (SCR_CUR_NX),A  ; set new cursor X
 716+ 085C CD CB 06     CONTCRSLFT:     call    MOVCRS          ; move cursor into new position
 717+ 085F F1           EXITCURSORLEFT: pop     AF              ; restore A
 718+ 0860 C9                           ret                     ; return to caller
 719+ 0861
 720+ 0861              ; move cursor 1 position to the left
 721+ 0861 3A D1 52     MVCRS2LFT:      ld      A,(SCR_CURS_X)  ; load cursor X into A
 722+ 0864 A7                           and     A               ; is it at the most left of the screen (X=0)?
 723+ 0865 28 0B                        jr      Z,CHKYPOS       ; yes, check Y position
 724+ 0867 3D                           dec     A               ; no, decrement X
 725+ 0868 32 D3 52                     ld      (SCR_CUR_NX),A  ; store new X
 726+ 086B 3A D2 52                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 727+ 086E 32 D4 52                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 728+ 0871 C9                           ret                     ; go on moving cursor
 729+ 0872 3A D2 52     CHKYPOS:        ld      A,(SCR_CURS_Y)  ; load cursor Y
 730+ 0875 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 731+ 0876 28 E7                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 732+ 0878 3D                           dec     A               ; no, decrement Y
 733+ 0879 32 D4 52                     ld      (SCR_CUR_NY),A  ; store new Y
 734+ 087C 3A CB 52                     ld      A,(SCR_SIZE_W)  ; load current screen width
 735+ 087F 3D                           dec     A               ; cursor to the most right position (width-1)
 736+ 0880 32 D3 52                     ld      (SCR_CUR_NX),A  ; set new cursor X
 737+ 0883 C9                           ret                     ; return to caller
 738+ 0884
 739+ 0884              ; move cursor up
 740+ 0884 F5           CURSORUP:       push    AF              ; store A
 741+ 0885 3A D2 52                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 742+ 0888 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 743+ 0889 28 10                        jr      Z,EXITCURSORUP  ; yes, exit doing nothing
 744+ 088B 3D                           dec     A               ; no, decrement Y
 745+ 088C 32 D4 52                     ld      (SCR_CUR_NY),A  ; store new Y
 746+ 088F 3A D1 52                     ld      A,(SCR_CURS_X)  ; load current cursor X
 747+ 0892 32 D3 52                     ld      (SCR_CUR_NX),A  ; set new cursor X
 748+ 0895 CD FB 06                     call    RSTCHRCRS       ; restore char under the cursor and print it
 749+ 0898 CD CB 06                     call    MOVCRS          ; move cursor into new position
 750+ 089B F1           EXITCURSORUP:   pop     AF              ; restore A
 751+ 089C C9                           ret                     ; return to caller
 752+ 089D
 753+ 089D
 754+ 089D              ; move cursor to right
 755+ 089D F5           CURSORRIGHT:    push    AF              ; store A
 756+ 089E C5                           push    BC              ; store B
 757+ 089F 3A CB 52                     ld      A,(SCR_SIZE_W)  ; load current screen width (in text modes it's 32 or 40)
 758+ 08A2 3D                           dec     A               ; decrement it (most right can only be 31 or 39)
 759+ 08A3 47                           ld      B,A             ; move A into B
 760+ 08A4 3A D1 52                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 761+ 08A7 B8                           cp      B               ; is cursor at the most right position on the screen?
 762+ 08A8 30 0C                        jr      NC,CHCKYPOS2    ; yes, so jump to check Y position
 763+ 08AA 3C                           inc     A               ; no, so increment X
 764+ 08AB 32 D3 52                     ld      (SCR_CUR_NX),A  ; store new X
 765+ 08AE 3A D2 52                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 766+ 08B1 32 D4 52                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 767+ 08B4 18 13                        jr      CONTCRSRGT      ; go on moving cursor
 768+ 08B6 3A CC 52     CHCKYPOS2:      ld      A,(SCR_SIZE_H)  ; load screen height
 769+ 08B9 3D                           dec     A               ; decrement it (last row can only be 23)
 770+ 08BA 47                           ld      B,A             ; move bottom into B
 771+ 08BB 3A D2 52                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 772+ 08BE B8                           cp      B               ; is the cursor at the bottom of the screen?
 773+ 08BF 30 0E                        jr      NC,EXITCURSORRGHT; yes, exit doing nothing
 774+ 08C1 3C                           inc     A               ; no, increment Y
 775+ 08C2 32 D4 52                     ld      (SCR_CUR_NY),A  ; store new Y
 776+ 08C5 AF                           xor     A               ; move cursor to top left
 777+ 08C6 32 D3 52                     ld      (SCR_CUR_NX),A  ; store new X
 778+ 08C9 CD FB 06     CONTCRSRGT:     call    RSTCHRCRS       ; restore char under the cursor and print it
 779+ 08CC CD CB 06                     call    MOVCRS          ; move cursor into new position
 780+ 08CF C1           EXITCURSORRGHT: pop     BC              ; retrieve BC
 781+ 08D0 F1                           pop     AF              ; restore A
 782+ 08D1 C9                           ret                     ; return to caller
 783+ 08D2
 784+ 08D2
 785+ 08D2              ; move cursor down
 786+ 08D2 F5           CURSORDOWN:     push    AF              ; store A
 787+ 08D3 C5                           push    BC              ; store B
 788+ 08D4 3A CC 52                     ld      A,(SCR_SIZE_H)  ; load current screen height (in text modes it's 24)
 789+ 08D7 3D                           dec     A               ; decrement it (positions can only vary between 0 and 23)
 790+ 08D8 47                           ld      B,A             ; move X into B
 791+ 08D9 3A D2 52                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 792+ 08DC B8                           cp      B               ; is current cursor position < 23?
 793+ 08DD 30 10                        jr      NC,EXITCURSORDOWN; no, exit doing nothing
 794+ 08DF 3C                           inc     A               ; yes, increment Y
 795+ 08E0 32 D4 52                     ld      (SCR_CUR_NY),A  ; store new Y
 796+ 08E3 3A D1 52                     ld      A,(SCR_CURS_X)  ; load current cursor X
 797+ 08E6 32 D3 52                     ld      (SCR_CUR_NX),A  ; set new cursor X
 798+ 08E9 CD FB 06                     call    RSTCHRCRS       ; restore char under the cursor and print it
 799+ 08EC CD CB 06                     call    MOVCRS          ; move cursor into new position
 800+ 08EF C1           EXITCURSORDOWN: pop     BC              ; retrieve BC
 801+ 08F0 F1                           pop     AF              ; retrieve A
 802+ 08F1 C9                           ret                     ; return to caller
 803+ 08F2
 804+ 08F2
 805+ 08F2              ; set cursor on (visible on screen)
 806+ 08F2 F5           CURSOR_ON:      push    AF              ; store AF
 807+ 08F3 3A D6 52                     ld      A,(CRSR_STATE)  ; load cursor state
 808+ 08F6 B7                           or      A               ; is it on?
 809+ 08F7 20 0C                        jr      NZ,EXITCURSOR_ON; yes, so nothing to do
 810+ 08F9 3A CC 52                     ld      A,(SCR_SIZE_H)  ; check the video mode
 811+ 08FC FE 30                        cp      $30             ; graphics 2 or 3 (if value>=48)?
 812+ 08FE 30 05                        jr      NC,EXITCURSOR_ON; yes, so exit (no cursor in graphics 2 or 3)
 813+ 0900 3E 01                        ld      A,$01           ; cursor state ON
 814+ 0902 32 D6 52                     ld      (CRSR_STATE),A  ; set state
 815+ 0905 F1           EXITCURSOR_ON:  pop     AF              ; restore AF
 816+ 0906 C9                           ret                     ; return to caller
 817+ 0907
 818+ 0907              ; set cursor off (invisible on screen)
 819+ 0907 F5           CURSOR_OFF:     push    AF              ; store AF
 820+ 0908 AF                           xor     A               ; cursor state OFF
 821+ 0909 32 D6 52                     ld      (CRSR_STATE),A  ; set state
 822+ 090C F1                           pop     AF              ; restore AF
 823+ 090D C9                           ret
 824+ 090E
 825+ 090E              ; scroll the screen 1 row up
 826+ 090E AF           SCROLLUP:       xor     A
 827+ 090F 32 D8 52                     ld      (PRNTVIDEO),A
 828+ 0912 2A CF 52                     ld      HL,(SCR_NAM_TB) ; start address of the name table
 829+ 0915 22 0C 53                     ld      (VIDTMP1),HL    ; store address of the destination row (1st row of the screen)
 830+ 0918 3A CB 52                     ld      A,(SCR_SIZE_W)  ; load the screen width
 831+ 091B 5F                           ld      E,A             ; move width into E
 832+ 091C 16 00                        ld      D,$00           ; reset D
 833+ 091E 19                           add     HL,DE           ; HL now contains the address of the source row (2nd row of the screen)
 834+ 091F 22 0E 53                     ld      (VIDTMP2),HL    ; store address of source row
 835+ 0922 3A CC 52                     ld      A,(SCR_SIZE_H)  ; load the screen height
 836+ 0925 3D                           dec     A               ; decrement the # of rows: now, A contains the # of rows to be moved
 837+ 0926 47                           ld      B,A             ; move # of rows into B
 838+ 0927 3A CB 52     SCROLLNXTRW:    ld      A,(SCR_SIZE_W)  ; (re)load the screen width
 839+ 092A 5F                           ld      E,A             ; move width into E
 840+ 092B 2A 0E 53                     ld      HL,(VIDTMP2)    ; load source address
 841+ 092E 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 842+ 0930 ED 69                        out     (C),L           ; low byte of source
 843+ 0932 ED 61                        out     (C),H           ; high byte of source
 844+ 0934 21 E4 52                     ld      HL,VIDEOBUFF    ; load address of the first cell of the video buffer
 845+ 0937 0E 30                        ld      C,VDP_DAT       ; VDP data mode
 846+ 0939 ED 78        LOADNEXTCOL:    in      A,(C)           ; load char
 847+ 093B 77                           ld      (HL),A          ; store char
 848+ 093C 23                           inc     HL              ; next cell of the buffer
 849+ 093D 1D                           dec     E               ; count the chars to be read
 850+ 093E 20 F9                        jr      NZ,LOADNEXTCOL  ; repeat until we read the entire row
 851+ 0940 3A CB 52                     ld      A,(SCR_SIZE_W)  ; reload the screen width
 852+ 0943 5F                           ld      E,A             ; move # of rows into E
 853+ 0944 16 00                        ld      D,$00           ; reset D
 854+ 0946 2A 0C 53                     ld      HL,(VIDTMP1)    ; load address of destination row
 855+ 0949 E5                           push    HL              ; store HL
 856+ 094A 2A 0E 53                     ld      HL,(VIDTMP2)    ; current source will be..
 857+ 094D 22 0C 53                     ld      (VIDTMP1),HL    ; ..new destination
 858+ 0950 19                           add     HL,DE           ; address of new
 859+ 0951 22 0E 53                     ld      (VIDTMP2),HL    ; source row
 860+ 0954 E1                           pop     HL              ; restore address of current destination row
 861+ 0955 CB F4                        set     6,H             ; writing mode
 862+ 0957 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 863+ 0959 ED 69                        out     (C),L           ; low byte
 864+ 095B ED 61                        out     (C),H           ; high byte of address
 865+ 095D 21 E4 52                     ld      HL,VIDEOBUFF    ; video buffer address
 866+ 0960 0E 30                        ld      C,VDP_DAT       ; VDP data mode
 867+ 0962 7E           WRITEBUF:       ld      A,(HL)          ; load char
 868+ 0963 ED 79                        out     (C),A           ; send char
 869+ 0965 23                           inc     HL              ; increment buffer index
 870+ 0966 1D                           dec     E               ; next row
 871+ 0967 20 F9                        jr      NZ,WRITEBUF     ; repeat until 0
 872+ 0969 10 BC                        djnz    SCROLLNXTRW     ; repeat for the entire screen
 873+ 096B 3A CB 52                     ld      A,(SCR_SIZE_W)  ; reload screen width
 874+ 096E 47                           ld      B,A             ; cells to empty into B
 875+ 096F AF                           xor     A               ; null char
 876+ 0970 0E 32                        ld      C,VDP_SET       ; VDP set mode
 877+ 0972 2A 0C 53                     ld      HL,(VIDTMP1)    ; load address of the last row
 878+ 0975 CB F4                        set     6,H             ; writing mode
 879+ 0977 ED 69                        out     (C),L           ; low byte then..
 880+ 0979 ED 61                        out     (C),H           ; high byte of address
 881+ 097B 0E 30                        ld      C,VDP_DAT       ; VDP data mode
 882+ 097D ED 79        RPTEMPTYROW:    out     (C),A           ; empty cell
 883+ 097F 00                           nop                     ; delay
 884+ 0980 00                           nop
 885+ 0981 10 FA                        djnz    RPTEMPTYROW     ; repeat until the last row has been cleaned
 886+ 0983 3E 01                        ld      A,$01
 887+ 0985 32 D8 52                     ld      (PRNTVIDEO),A   ; set print-on-video on
 888+ 0988 C9                           ret                     ; return to caller
 889+ 0989
 890+ 0989              ; carriage return: first, it looks for char $00 at the beginning of the line (look for the first null char),
 891+ 0989              ; then it starts sendind every char it finds on the screen to the terminal buffer of the BASIC interpreter
 892+ 0989              ; until another null char is found. Finally, move to the next line and position the cursor at the beginning
 893+ 0989              ; of the row (equivalent to CR+LF), then gets back control to the screen editor to let it interpret the line
 894+ 0989              CUR_POS         equ     TMPBFR1         ; cursor position
 895+ 0989              SRTTXT          equ     TMPBFR2         ; start of text line
 896+ 0989              ENDTXT          equ     TMPBFR3         ; end of text line
 897+ 0989              CRGRETURN:      ; preliminary: disable cursor if on, and retrieve char under it
 898+ 0989 3A D6 52                     ld      A,(CRSR_STATE)  ; recover cursor state
 899+ 098C 32 E2 52                     ld      (TMPBFR4),A     ; store status
 900+ 098F A7                           and     A               ; is cursor on?
 901+ 0990 C4 07 09                     call    NZ,CURSOR_OFF   ; yes, so set cursor off
 902+ 0993 CD FB 06                     call    RSTCHRCRS       ; restore char under it
 903+ 0996                              ; first, check if cursor if off, so that we just interpret return as a new line command
 904+ 0996 3A 16 53                     ld      A,(KBDNPT)      ; check if input from keyboad
 905+ 0999 A7                           and     A               ; if 0, input is not from keyboard...
 906+ 099A CA EF 09                     jp      Z,PRNTRETURN    ; ...so just print a carriage return; otherwise, interpret the return
 907+ 099D                              ; first part: look for the beginning of the text line on screen
 908+ 099D CD 04 07                     call    LOAD_CRSR_POS   ; load cursor position into HL
 909+ 09A0 22 DC 52                     ld      (CUR_POS),HL    ; store it
 910+ 09A3 ED 5B CF 52                  ld      DE,(SCR_NAM_TB) ; load VRAM address of top-left cell of screen ("home")
 911+ 09A7 E5           RPTNLLSRC:      push    HL
 912+ 09A8 CD 97 3F                     call    CMP16           ; check if at "home"
 913+ 09AB E1                           pop     HL
 914+ 09AC CA B7 09                     jp      Z,CNTNULL       ; yes, exit because there is nothing before
 915+ 09AF 2B                           dec     HL              ; go 1 step back
 916+ 09B0 CD 85 06                     call    READ_VIDEO_LOC  ; read char of current position
 917+ 09B3 A7                           and     A               ; is it $00 (null char)?
 918+ 09B4 20 F1                        jr      NZ,RPTNLLSRC    ; no, continue searching
 919+ 09B6 23                           inc     HL              ; move 1 step forward to go back to the last cell with something in
 920+ 09B7                              ; second part: look for the ending of the text on screen
 921+ 09B7 22 DE 52     CNTNULL:        ld      (SRTTXT),HL     ; store beginning of text
 922+ 09BA CD 10 0A                     call    ENDOFLN         ; find end of text line looking at the end of chars after the cursor position
 923+ 09BD 22 E0 52                     ld      (ENDTXT),HL     ; store ending of text line
 924+ 09C0 ED 5B DE 52                  ld      DE,(SRTTXT)     ; load beginning of text line
 925+ 09C4 A7                           and     A               ; clear Carry
 926+ 09C5 ED 52                        sbc     HL,DE           ; how many chars?
 927+ 09C7 28 26                        jr      Z,PRNTRETURN    ; no chars found (HL-DE=0), so just print return & leave
 928+ 09C9                              ;---    central part: send the text on the screen to the interpreter
 929+ 09C9 2A DE 52                     ld      HL,(SRTTXT)     ; load beginning of text line
 930+ 09CC ED 5B E0 52                  ld      DE,(ENDTXT)     ; load ending of text line
 931+ 09D0 CD 85 06     SNDCHRTOBFR:    call    READ_VIDEO_LOC  ; read char
 932+ 09D3 E5                           push    HL
 933+ 09D4 CD F4 01                     call    CHARINTOBFR     ; send char to buffer
 934+ 09D7 E1                           pop     HL
 935+ 09D8 23                           inc     HL              ; go to next char
 936+ 09D9 E5                           push    HL              ; store HL
 937+ 09DA CD 97 3F                     call    CMP16           ; check if DE=HL (finish chars)
 938+ 09DD E1                           pop     HL
 939+ 09DE 20 F0                        jr      NZ,SNDCHRTOBFR  ; no, repeat
 940+ 09E0 3E 0D                        ld      A,CR            ; yes, so now send carriage return
 941+ 09E2 CD F4 01                     call    CHARINTOBFR     ; send to buffer
 942+ 09E5 2A E0 52                     ld      HL,(ENDTXT)     ; recover address of last char of input text
 943+ 09E8 CD 27 07                     call    HL2XY           ; retrieve X,Y from address
 944+ 09EB 7D                           ld      A,L             ; move Y into A (we don't need X anymore)
 945+ 09EC 32 D2 52                     ld      (SCR_CURS_Y),A  ; store new Y
 946+ 09EF                              ;---    final part: go at the beginning of a new line on the screen
 947+ 09EF AF           PRNTRETURN:     xor     A               ; move to col 0
 948+ 09F0 32 D1 52                     ld      (SCR_CURS_X),A  ; store new X
 949+ 09F3 3A D2 52                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 950+ 09F6 3C                           inc     A               ; new row
 951+ 09F7 21 CC 52                     ld      HL,SCR_SIZE_H   ; load address of cell that keeps screen height
 952+ 09FA BE                           cp      (HL)            ; is the cursor over the bottom of the screen?
 953+ 09FB 38 06                        jr      C,ADDNEWLINE    ; no, jump over
 954+ 09FD 3D                           dec     A               ; yes, so come back 1 row, then...
 955+ 09FE F5                           push    AF              ; (store A)
 956+ 09FF CD 0E 09                     call    SCROLLUP        ; ...scroll the screen before to...
 957+ 0A02 F1                           pop     AF              ; (retrieve A)
 958+ 0A03 32 D2 52     ADDNEWLINE:     ld      (SCR_CURS_Y),A  ; ...store new Y
 959+ 0A06 3A E2 52                     ld      A,(TMPBFR4)     ; retrieve cursor state
 960+ 0A09 A7                           and     A               ; was it off (A=0)?
 961+ 0A0A C4 F2 08                     call    NZ,CURSOR_ON    ; no, set cursor on
 962+ 0A0D C3 C1 06                     jp      POS_CURSOR      ; position cursor to new location & return to caller
 963+ 0A10
 964+ 0A10              ; find end of text line
 965+ 0A10              ; destroys A, DE, and HL - store address of last char of text line into HL,
 966+ 0A10              ; while DE contains the address of the bottom right cell of the screen
 967+ 0A10 3A CC 52     ENDOFLN:        ld      A,(SCR_SIZE_H)
 968+ 0A13 5F                           ld      E,A             ; load screen height into DE
 969+ 0A14 3A CB 52                     ld      A,(SCR_SIZE_W)
 970+ 0A17 6F                           ld      L,A             ; load screen width into HL
 971+ 0A18 AF                           xor     A
 972+ 0A19 67                           ld      H,A
 973+ 0A1A 57                           ld      D,A
 974+ 0A1B CD A2 3F                     call    MUL16           ; multiply HL times DE to get the screen size
 975+ 0A1E ED 5B CF 52                  ld      DE,(SCR_NAM_TB) ; load screen name table start address into DE
 976+ 0A22 19                           add     HL,DE           ; get the address...
 977+ 0A23 2B                           dec     HL              ; ...of the "last" video cell
 978+ 0A24 EB                           ex      DE,HL           ; store address into DE
 979+ 0A25 2A DC 52                     ld      HL,(CUR_POS)    ; retrieve original cursor position
 980+ 0A28 E5           RPTNLLSRC2:     push    HL
 981+ 0A29 CD 97 3F                     call    CMP16           ; check if at last position on screen (bottom right corner)
 982+ 0A2C E1                           pop     HL
 983+ 0A2D C8                           ret     Z               ; if yes, exit because these is nothing after
 984+ 0A2E 23                           inc     HL              ; 1 more step forward
 985+ 0A2F CD 85 06                     call    READ_VIDEO_LOC  ; read char of current position
 986+ 0A32 A7                           and     A               ; is it $00 (null char)?
 987+ 0A33 20 F3                        jr      NZ,RPTNLLSRC2   ; no, continue searching
 988+ 0A35 C9           CNTNULL2:       ret                     ; yes: found end of text, return to caller
 989+ 0A36
 990+ 0A36
 991+ 0A36              ; ------------------------------------------------------------------------------
 992+ 0A36                              ; this table contains the values of the offsets to be added to
 993+ 0A36                              ; the starting address of the name table to find the correct
 994+ 0A36                              ; value of the first cell of the corresponding row
 995+ 0A36                              ; (by doing so, it's faster than doing a multipication)
 996+ 0A36                              ; table for graphics 1 text mode: 32 cols
 997+ 0A36 00 00 20 00  POS_TB_CRS_32:  defw    $0000,$0020,$0040,$0060,$0080,$00A0,$00C0,$00E0
 997+ 0A3A 40 00 60 00
 997+ 0A3E 80 00 A0 00
 997+ 0A42 C0 00 E0 00
 998+ 0A46 00 01 20 01                  defw    $0100,$0120,$0140,$0160,$0180,$01A0,$01C0,$01E0
 998+ 0A4A 40 01 60 01
 998+ 0A4E 80 01 A0 01
 998+ 0A52 C0 01 E0 01
 999+ 0A56 00 02 20 02                  defw    $0200,$0220,$0240,$0260,$0280,$02A0,$02C0,$02E0
 999+ 0A5A 40 02 60 02
 999+ 0A5E 80 02 A0 02
 999+ 0A62 C0 02 E0 02
1000+ 0A66                              ; table for pure text mode: 40 cols
1001+ 0A66 00 00 28 00  POS_TB_CRS_40:  defw    $0000,$0028,$0050,$0078,$00A0,$00C8,$00F0,$0118
1001+ 0A6A 50 00 78 00
1001+ 0A6E A0 00 C8 00
1001+ 0A72 F0 00 18 01
1002+ 0A76 40 01 68 01                  defw    $0140,$0168,$0190,$01B8,$01E0,$0208,$0230,$0258
1002+ 0A7A 90 01 B8 01
1002+ 0A7E E0 01 08 02
1002+ 0A82 30 02 58 02
1003+ 0A86 80 02 A8 02                  defw    $0280,$02A8,$02D0,$02F8,$0320,$0348,$0370,$0398
1003+ 0A8A D0 02 F8 02
1003+ 0A8E 20 03 48 03
1003+ 0A92 70 03 98 03
1004+ 0A96
1005+ 0A96              ; ------------------------------------------------------------------------------
1006+ 0A96              ; reset VRAM
1007+ 0A96 AF           EMPTY_VRAM:     xor     A               ; reg.A cleared: we fill up VRAM with $00
1008+ 0A97 67                           ld      H,A
1009+ 0A98 6F                           ld      L,A             ; reset HL
1010+ 0A99 CD 65 06                     call    SETVDPADRS      ; set address of first VRAM cell to $0000
1011+ 0A9C 06 40                        ld      B,$40           ; $40 pages of RAM...
1012+ 0A9E 57                           ld      D,A             ; ...each one with $100 cells (tot. $4000 bytes)
1013+ 0A9F 0E 30                        ld      C,VDP_DAT       ; VDP data mode
1014+ 0AA1 ED 79        EMPTVRM:        out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
1015+ 0AA3 14                           inc     D               ; next cell
1016+ 0AA4 00                           nop
1017+ 0AA5 20 FA                        jr      NZ,EMPTVRM      ; repeat until page is fully cleared
1018+ 0AA7 10 F8                        djnz    EMPTVRM         ; repeat for $40 pages
1019+ 0AA9 C9                           ret                     ; return to caller
1020+ 0AAA
1021+ 0AAA              ; clear video registers in SRAM
1022+ 0AAA 21 CB 52     CLR_RAM_REG:    ld      HL,SCR_SIZE_W   ; address of first register
1023+ 0AAD AF                           xor     A               ; $00 to clean the registers
1024+ 0AAE 06 45                        ld      B,CHASNDDTN-SCR_SIZE_W; how many bytes (registers) to clean (dinamically calculated)
1025+ 0AB0 77           RSTVDPRAMREG:   ld      (HL),A          ; reset register
1026+ 0AB1 23                           inc     HL              ; next register
1027+ 0AB2 10 FC                        djnz    RSTVDPRAMREG    ; repeat
1028+ 0AB4 C9                           ret                     ; return to caller
1029+ 0AB5
1030+ 0AB5              ; ------------------------------------------------------------------------------
1031+ 0AB5              ; set a specific graphics mode, passed into reg. E
1032+ 0AB5 06 08        SET_GFX_MODE:   ld      B,$08           ; 8 registers means 8 bytes..
1033+ 0AB7 CB 23                        sla     E               ; multiply E by 8..
1034+ 0AB9 CB 23                        sla     E               ; so that reg. E can point..
1035+ 0ABB CB 23                        sla     E               ; to the correct settings
1036+ 0ABD 16 00        SET_GFX_MODE2:  ld      D,$00           ; reset D
1037+ 0ABF 21 F2 0A                     ld      HL,VDPMODESET   ; pointer to register settings | <= here points the SHOW_LOGO sub-routine
1038+ 0AC2 19                           add     HL,DE           ; add offset to get the correct set of values for the required mode
1039+ 0AC3 3E 80                        ld      A,$80           ; start with REG0 ($80+register number)
1040+ 0AC5 0E 32                        ld      C,VDP_SET       ; VDP set
1041+ 0AC7 56           LDREGVLS:       ld      D,(HL)          ; load register's value
1042+ 0AC8 ED 51                        out     (C),D           ; send data to VDP
1043+ 0ACA ED 79                        out     (C),A           ; indicate the register to send data to
1044+ 0ACC 3C                           inc     A               ; next register
1045+ 0ACD 23                           inc     HL              ; next value
1046+ 0ACE 10 F7                        djnz    LDREGVLS        ; repeat for 8 registers
1047+ 0AD0 C9                           ret
1048+ 0AD1
1049+ 0AD1              ; ------------------------------------------------------------------------------
1050+ 0AD1              LOADCHARSET:    ; reg. A contains the video mode
1051+ 0AD1                              ; reg. HL contains address of pattern table into VRAM
1052+ 0AD1 06 00                        ld      B,$00           ; 0=256 chars to load (complete charset)
1053+ 0AD3 CB F4                        set     $06,H           ; add $4000 to address to indicate that we want to write into VRAM
1054+ 0AD5 0E 32                        ld      C,VDP_SET       ; load VDP address into C
1055+ 0AD7 ED 69                        out     (C),L           ; send low byte of address
1056+ 0AD9 ED 61                        out     (C),H           ; send high byte
1057+ 0ADB 21 FA 3F                     ld      HL,CHRST68      ; starting address of 6x8 charset into ROM
1058+ 0ADE A7                           and     A               ; is it text mode (A=0)?
1059+ 0ADF 28 03                        jr      Z,NXTCHAR       ; yes, so jump to load chars into VRAM
1060+ 0AE1 21 FA 47                     ld      HL,CHRST88      ; no, so we change and load the 8x8 charset
1061+ 0AE4 16 08        NXTCHAR:        ld      D,$08           ; 8 bytes per pattern char
1062+ 0AE6 0E 30                        ld      C,VDP_DAT       ; VDP data mode
1063+ 0AE8 7E           SENDCHRPTRNS:   ld      A,(HL)          ; load byte to send to VDP
1064+ 0AE9 ED 79                        out     (C),A           ; write byte into VRAM
1065+ 0AEB 23                           inc     HL              ; inc byte pointer
1066+ 0AEC 15                           dec     D               ; 8 bytes sents (0 char)?
1067+ 0AED 20 F9                        jr      NZ,SENDCHRPTRNS ; no, continue
1068+ 0AEF 10 F3                        djnz    NXTCHAR         ; yes, decrement chars counter and continue for all the chars
1069+ 0AF1 C9                           ret                     ; return to caller
1070+ 0AF2
1071+ 0AF2              ;------------------------------------------------------------------------------
1072+ 0AF2              ; NAME TABLE:       buffer video - contains the chars to be shown on video
1073+ 0AF2              ; PATTERN TABLE:    charset - contains the chars/tiles to be loaded into the name table
1074+ 0AF2              ; COLOR TABLE:      color settings for chars/tiles
1075+ 0AF2
1076+ 0AF2                              ; VDP register settings for a text display
1077+ 0AF2 00           VDPMODESET:     defb    %00000000       ; reg.0: external video off
1078+ 0AF3 D0                           defb    %11010000       ; reg.1: 16K VRAM, video on, int. off, text mode (40x24)
1079+ 0AF4 02                           defb    $02             ; reg.2: name table set to $0800 ($02x$400)
1080+ 0AF5 00                           defb    $00             ; reg.3: not used in text mode
1081+ 0AF6 00                           defb    $00             ; reg.4: pattern table set to $0000
1082+ 0AF7 00                           defb    $00             ; reg.5: not used in text mode
1083+ 0AF8 00                           defb    $00             ; reg.6: not used in text mode
1084+ 0AF9 F5                           defb    $f5             ; reg.7: white text on light blue background
1085+ 0AFA
1086+ 0AFA              VDPMODESET1:    ; VDP register settings for a graphics 1 mode
1087+ 0AFA 00                           defb    %00000000       ; reg.0: ext. video off
1088+ 0AFB C0                           defb    %11000000       ; reg.1: 16K Vram; video on, int off, graphics mode 1, sprite size 8x8, sprite magn. 0
1089+ 0AFC 06                           defb    $06             ; reg.2: name table address: $1800
1090+ 0AFD 80                           defb    $80             ; reg.3: color table address: $2000
1091+ 0AFE 00                           defb    $00             ; reg.4: pattern table address: $0000
1092+ 0AFF 36                           defb    $36             ; reg.5: sprite attr. table address: $1B00
1093+ 0B00 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1094+ 0B01 05                           defb    $05             ; reg.7: backdrop color (light blue)
1095+ 0B02
1096+ 0B02              VDPMODESET2:    ; VDP register settings for a graphics 2 mode
1097+ 0B02 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1098+ 0B03 C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1099+ 0B04 06                           defb    $06             ; reg.2: name table addr.: $1800
1100+ 0B05 FF                           defb    $FF             ; reg.3: color table addr.: $2000
1101+ 0B06 03                           defb    $03             ; reg.4: pattern table addr.: $0000
1102+ 0B07 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1103+ 0B08 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1104+ 0B09 05                           defb    $05             ; reg.7: backdrop color: light blue
1105+ 0B0A
1106+ 0B0A              VDPMODESETMC:   ; VDP register settings for a multicolor mode
1107+ 0B0A 00                           defb    %00000000       ; reg.0: ext. video dis.
1108+ 0B0B CB                           defb    %11001011       ; reg.1: 16K VRAM, video on, INT off, multicolor mode, sprite size 8x8, sprite magn. 0
1109+ 0B0C 02                           defb    $02             ; reg.2: name table addr.: $0800
1110+ 0B0D 00                           defb    $00             ; reg.3: don't care
1111+ 0B0E 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1112+ 0B0F 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1113+ 0B10 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1114+ 0B11 0F                           defb    $0F             ; reg.7: backdrop color (white)
1115+ 0B12
1116+ 0B12              VDPMODESETEX2:  ; VDP register settings for an extended graphics 2 mode
1117+ 0B12 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1118+ 0B13 C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1119+ 0B14 0E                           defb    $0E             ; reg.2: name table addr.: $3800
1120+ 0B15 9F                           defb    $9F             ; reg.3: color table addr.: $2000
1121+ 0B16 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1122+ 0B17 76                           defb    $76             ; reg.5: sprite attr. table addr.: $3B00
1123+ 0B18 03                           defb    $03             ; reg.6: sprite pattern table addr.: $1800
1124+ 0B19 05                           defb    $05             ; reg.7: backdrop color: light blue
1125+ 0B1A
1126+ 0B1A              LM80CLOGO:      ; patterns to compose the splash screen logo
1127+ 0B1A 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1127+ 0B1E 00 00 00 00
1127+ 0B22 00 00 00 00
1127+ 0B26 00 00 00 00
1127+ 0B2A 00 00 00 00
1127+ 0B2E 00 00 00 00
1127+ 0B32 00 00 00 00
1127+ 0B36 00 00 00 00
1128+ 0B3A 00 00 0F 0A                  defb    0,0,15,10,11,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1128+ 0B3E 0B 10 00 00
1128+ 0B42 00 00 00 00
1128+ 0B46 00 00 00 00
1128+ 0B4A 00 00 00 00
1128+ 0B4E 00 00 00 00
1128+ 0B52 00 00 00 00
1128+ 0B56 00 00 00 00
1129+ 0B5A 00 00 0D 17                  defb    0,0,13,23,0,12,0,0,0,1,0,0,0,20,0,0,6,5,6,21,22,7,6,21,22,7,6,1,1,7,0,0
1129+ 0B5E 00 0C 00 00
1129+ 0B62 00 01 00 00
1129+ 0B66 00 14 00 00
1129+ 0B6A 06 05 06 15
1129+ 0B6E 16 07 06 15
1129+ 0B72 16 07 06 01
1129+ 0B76 01 07 00 00
1130+ 0B7A 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,20,6,1,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1130+ 0B7E 00 0C 00 00
1130+ 0B82 00 01 00 00
1130+ 0B86 00 01 14 06
1130+ 0B8A 01 05 03 05
1130+ 0B8E 03 05 03 05
1130+ 0B92 03 05 03 05
1130+ 0B96 03 05 00 00
1131+ 0B9A 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,1,1,1,5,9,20,19,8,3,5,19,5,3,5,0,0,0,0
1131+ 0B9E 00 0C 00 00
1131+ 0BA2 00 01 00 00
1131+ 0BA6 00 01 01 01
1131+ 0BAA 01 05 09 14
1131+ 0BAE 13 08 03 05
1131+ 0BB2 13 05 03 05
1131+ 0BB6 00 00 00 00
1132+ 0BBA 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,8,3,5,6,21,22,7,3,1,22,5,3,5,0,0,0,0
1132+ 0BBE 00 0C 00 00
1132+ 0BC2 00 01 00 00
1132+ 0BC6 00 01 00 08
1132+ 0BCA 03 05 06 15
1132+ 0BCE 16 07 03 01
1132+ 0BD2 16 05 03 05
1132+ 0BD6 00 00 00 00
1133+ 0BDA 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,0,3,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1133+ 0BDE 00 0C 00 00
1133+ 0BE2 00 01 00 00
1133+ 0BE6 00 01 00 00
1133+ 0BEA 03 05 03 05
1133+ 0BEE 03 05 03 05
1133+ 0BF2 03 05 03 05
1133+ 0BF6 03 05 00 00
1134+ 0BFA 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,4,4,0,1,0,0,3,5,9,20,19,8,9,20,19,8,9,1,1,8,0,0
1134+ 0BFE 00 0C 00 00
1134+ 0C02 00 01 04 04
1134+ 0C06 00 01 00 00
1134+ 0C0A 03 05 09 14
1134+ 0C0E 13 08 09 14
1134+ 0C12 13 08 09 01
1134+ 0C16 01 08 00 00
1135+ 0C1A 00 00 0E 12                  defb    0,0,14,18,18,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1135+ 0C1E 12 11 00 00
1135+ 0C22 00 00 00 00
1135+ 0C26 00 00 00 00
1135+ 0C2A 00 00 00 00
1135+ 0C2E 00 00 00 00
1135+ 0C32 00 00 00 00
1135+ 0C36 00 00 00 00
1136+ 0C3A 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1136+ 0C3E 00 00 00 00
1136+ 0C42 00 00 00 00
1136+ 0C46 00 00 00 00
1136+ 0C4A 00 00 00 00
1136+ 0C4E 00 00 00 00
1136+ 0C52 00 00 00 00
1136+ 0C56 00 00 00 00
# file closed: ../include/vdp/vdp64k-r1.0.asm
  67  0C5A
  68  0C5A              ; incude the latest version of the PSG module
  69  0C5A                  INCLUDE "../include/psg/psg64k-r1.0.asm"
# file opened: ../include/psg/psg64k-r1.0.asm
   1+ 0C5A              ; ------------------------------------------------------------------------------
   2+ 0C5A              ; LM80C 64K - PSG ROUTINES - R1.0
   3+ 0C5A              ; ------------------------------------------------------------------------------
   4+ 0C5A              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0C5A              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0C5A              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0C5A              ; kind of warranty: you can use them at your own risk.
   8+ 0C5A              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0C5A              ; maintain the copyright notices, include this advice and the note to the
  10+ 0C5A              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0C5A              ; redistribuite them.
  12+ 0C5A              ; https://www.leonardomiliani.com
  13+ 0C5A              ;
  14+ 0C5A              ; Please support me by visiting the following links:
  15+ 0C5A              ; Main project page: https://www.leonardomiliani.com
  16+ 0C5A              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0C5A              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0C5A              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0C5A              ; ------------------------------------------------------------------------------
  20+ 0C5A              ;
  21+ 0C5A              ; ------------------------------------------------------------------------------
  22+ 0C5A
  23+ 0C5A              ;------------------------------------------------------------------------------
  24+ 0C5A
  25+ 0C5A              ; configure the PSG
  26+ 0C5A 21 10 53     initPSG:        ld      HL,CHASNDDTN    ; starting address of sound & keyboard RAM registers
  27+ 0C5D 06 0E                        ld      B,SERIALS_EN-CHASNDDTN; # of PSG sound & keyboard registers
  28+ 0C5F AF                           xor     A               ; reset A
  29+ 0C60 77           EMPTSNDBFR:     ld      (HL),A          ; reset RAM register
  30+ 0C61 23                           inc     HL              ; next register
  31+ 0C62 10 FC                        djnz    EMPTSNDBFR      ; repeat
  32+ 0C64 06 10        CLRPSGREGS:     ld      B,$10           ; 16 registers to set
  33+ 0C66 21 78 0C                     ld      HL,SNDREGCFG    ; starting address of register settings
  34+ 0C69 16 00                        ld      D,$00           ; first register
  35+ 0C6B 7A           RSTPSG:         ld      A,D             ; register value
  36+ 0C6C CD B2 0C                     call    SETSNDREG       ; select register
  37+ 0C6F 7E                           ld      A,(HL)          ; load value
  38+ 0C70 CD B7 0C                     call    WRTSNDREG       ; write to register
  39+ 0C73 14                           inc     D               ; next register
  40+ 0C74 23                           inc     HL              ; next value
  41+ 0C75 10 F4                        djnz    RSTPSG          ; repeat for each register
  42+ 0C77 C9                           ret                     ; return to caller
  43+ 0C78
  44+ 0C78 00 00 00 00  SNDREGCFG:      defb $00,$00,$00,$00,$00,$00,$00,%10111111
  44+ 0C7C 00 00 00 BF
  45+ 0C80 00 00 00 00                  defb $00,$00,$00,$00,$00,$00,$ff,$ff
  45+ 0C84 00 00 FF FF
  46+ 0C88                              ; reg. 7: set I/O ch.A to OUTPUT, I/O ch.B to INPUT; set noise to OFF; set audio to OFF
  47+ 0C88
  48+ 0C88
  49+ 0C88              ; routine to play a welcome beep on channel C (tone 4010) and to shut it off
  50+ 0C88 21 A2 0C     WLCMBEEP:       ld      HL,WLCBPDAT     ; data address
  51+ 0C8B C3 91 0C                     jp      SENDSND
  52+ 0C8E 21 AA 0C     NOBEEP:         ld      HL,NOBPDAT      ; data address
  53+ 0C91 C5           SENDSND:        push    BC
  54+ 0C92 06 04                        ld      B,$04           ; 4 pairs
  55+ 0C94 7E           RPTWLCMBP:      ld      A,(HL)          ; read register #
  56+ 0C95 CD B2 0C                     call    SETSNDREG
  57+ 0C98 23                           inc     HL              ; next cell
  58+ 0C99 7E                           ld      A,(HL)          ; read value
  59+ 0C9A CD B7 0C                     call    WRTSNDREG
  60+ 0C9D 23                           inc     HL
  61+ 0C9E 10 F4                        djnz    RPTWLCMBP       ; repeat
  62+ 0CA0 C1                           pop     BC
  63+ 0CA1 C9                           ret                     ; return to caller
  64+ 0CA2
  65+ 0CA2 07 BB 04 56  WLCBPDAT:       defb    $07,%10111011,$04,$56,$05,$00,$0A,$0F
  65+ 0CA6 05 00 0A 0F
  66+ 0CAA 04 00 05 00  NOBPDAT:        defb    $04,$00,$05,$00,$0A,$00,$07,%10111111
  66+ 0CAE 0A 00 07 BF
  67+ 0CB2
  68+ 0CB2
  69+ 0CB2              ; select register on PSG
  70+ 0CB2 0E 40        SETSNDREG:      ld      C,PSG_REG       ; PSG register port
  71+ 0CB4 ED 79                        out     (C),A           ; set register
  72+ 0CB6 C9                           ret                     ; return to caller
  73+ 0CB7
  74+ 0CB7              ; send data to PSG
  75+ 0CB7 0E 41        WRTSNDREG:      ld      C,PSG_DAT       ; PSG data port
  76+ 0CB9 ED 79                        out     (C),A           ; send data
  77+ 0CBB C9                           ret                     ; return to caller
  78+ 0CBC
  79+ 0CBC              ; manage the sounds' duration: each time this subroutine is called, it
  80+ 0CBC              ; decrements the single sound durations (measured in ms) and eventually
  81+ 0CBC              ; shut off the audio channel whose counter has reached 0.
  82+ 0CBC              ; (this sub-routine is called by CH3 timer ISR)
  83+ 0CBC DD E5        MNGSNDS:        push    IX              ; store IX
  84+ 0CBE DD 21 10 53                  ld      IX,CHASNDDTN    ; starting address of tones duration
  85+ 0CC2 06 03                        ld      B,$03           ; 3 channels to check
  86+ 0CC4 26 01                        ld      H,$01           ; mixer channels: A=>bit 1, B=>bit 2, C=>bit 3
  87+ 0CC6 DD 5E 00     CHKSNDCH:       ld      E,(IX+0)        ; load LSB into E
  88+ 0CC9 DD 56 01                     ld      D,(IX+1)        ; load MSB into D
  89+ 0CCC 7B                           ld      A,E             ; load E into A
  90+ 0CCD B2                           or      D               ; check that DE=0
  91+ 0CCE 28 31                        jr      Z,CNTCHKSND     ; yes, jump over
  92+ 0CD0 1B                           dec     DE              ; no, so decrement DE
  93+ 0CD1 7B                           ld      A,E             ; reload E into A...
  94+ 0CD2 DD 73 00                     ld      (IX+0),E        ; store new...
  95+ 0CD5 DD 72 01                     ld      (IX+1),D        ; ...duration and...
  96+ 0CD8 B2                           or      D               ; ...do another check to see if DE=0
  97+ 0CD9 20 26                        jr      NZ,CNTCHKSND    ; no, so jump over
  98+ 0CDB                                                      ; if yes, let's shut down the corresponding channel
  99+ 0CDB                                                      ; to shut down a tone we disable it into the mixer
 100+ 0CDB                                                      ; then set 0 into its tone registers
 101+ 0CDB 16 07                        ld      D,$07           ; mixer register
 102+ 0CDD 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 103+ 0CDF ED 51                        out     (C),D           ; set mixer register
 104+ 0CE1 ED 78                        in      A,(C)           ; load current value
 105+ 0CE3 B4                           or      H               ; set off the channel into the mixer (remember that 1=OFF)
 106+ 0CE4 ED 51                        out     (C),D           ; select mixer register
 107+ 0CE6 0E 41                        ld      C,PSG_DAT       ; PSG data port
 108+ 0CE8 ED 79                        out     (C),A           ; send new value for the mixer
 109+ 0CEA 3E 03                        ld      A,$03           ; three channels
 110+ 0CEC 90                           sub     B               ; find current channel (0->A, 1->B, 2->C)
 111+ 0CED 87                           add     A,A             ; and find first register (A=>0, B=>2, C=>4)
 112+ 0CEE 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 113+ 0CF0 ED 79                        out     (C),A           ; select first tone register of channel
 114+ 0CF2 2E 00                        ld      L,$00           ; value 0 into L
 115+ 0CF4 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 116+ 0CF6 ED 69                        out     (C),L           ; write 0 into register
 117+ 0CF8 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 118+ 0CFA 3C                           inc     A               ; next tone register
 119+ 0CFB ED 79                        out     (C),A           ; select second tone register of channel
 120+ 0CFD 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 121+ 0CFF ED 69                        out     (C),L           ; write 0 into register
 122+ 0D01 DD 23        CNTCHKSND:      inc     IX              ; set for...
 123+ 0D03 DD 23                        inc     IX              ; ...next channel...
 124+ 0D05 CB 24                        sla     H               ; shift left H 1 bit
 125+ 0D07 10 BD                        djnz    CHKSNDCH        ; repeat for 3 channels
 126+ 0D09 DD E1                        pop     IX              ; restore IX
 127+ 0D0B C9                           ret                     ; return to caller
 128+ 0D0C
 129+ 0D0C              ; read a specific row of the keyboard matrix, set by A
 130+ 0D0C              ; return read into A
 131+ 0D0C C5           READKBLN:       push    BC              ; store BC
 132+ 0D0D 06 0F                        ld      B,$0F           ; reg #15
 133+ 0D0F 0E 40                        ld      C,PSG_REG       ; PSG register port
 134+ 0D11 ED 41                        out     (C),B           ; select reg #15
 135+ 0D13 0E 41                        ld      C,PSG_DAT       ; PSG data port
 136+ 0D15 ED 79                        out     (C),A           ; activate the row
 137+ 0D17 06 0E                        ld      B,$0E           ; register #14 (port B)
 138+ 0D19 0E 40                        ld      C,PSG_REG       ; PSG register port
 139+ 0D1B ED 41                        out     (C),B           ; select reg. 14 (port B)
 140+ 0D1D ED 78                        in      A,(C)           ; read register #14
 141+ 0D1F C1                           pop     BC              ; retrieve BC
 142+ 0D20 C9                           ret
 143+ 0D21
 144+ 0D21              ; read the keyboard matrix to look for a key pressure
 145+ 0D21 0E 40        KEYBOARD:       ld      C,PSG_REG       ; PSG register port
 146+ 0D23 06 07                        ld      B,$07           ; set register #7...
 147+ 0D25 ED 41                        out     (C),B           ; ...to work with
 148+ 0D27 ED 78                        in      A,(C)           ; read register #7
 149+ 0D29 CB FF                        set     7,A             ; port A set to output
 150+ 0D2B CB B7                        res     6,A             ; port B set to input
 151+ 0D2D ED 41                        out     (C),B           ; set register #7
 152+ 0D2F 0E 41                        ld      C,PSG_DAT       ; PSG data port
 153+ 0D31 ED 79                        out     (C),A           ; set I/O ports w/o altering the rest of the mixer
 154+ 0D33                              ; check special keys (SHIFT/ALT/CTRL)
 155+ 0D33 3E FD                        ld      A,%11111101     ; select SHIFT row
 156+ 0D35 CD 0C 0D                     call    READKBLN        ; read row
 157+ 0D38 CB 5F                        bit     3,A             ; test if SHIFT key is pressed (4th bit is reset)
 158+ 0D3A 20 05                        jr      NZ,CHECKALT     ; no, so go on
 159+ 0D3C 21 1D 53                     ld      HL,CONTROLKEYS  ; control key flags
 160+ 0D3F 36 01                        ld      (HL),%00000001  ; set SHIFT flag, reset CTRL & ALT flags (currently multiply control keys are NOT supported)
 161+ 0D41 3E FE        CHECKALT:       ld      A,%11111110     ; select ALT row
 162+ 0D43 CD 0C 0D                     call    READKBLN        ; read ALT row
 163+ 0D46 CB 6F                        bit     5,A             ; test if ALT key is pressed (5th bit is reset)
 164+ 0D48 20 05                        jr      NZ,CHECKCTRL    ; no, so go on
 165+ 0D4A 21 1D 53                     ld      HL,CONTROLKEYS  ; control key flags
 166+ 0D4D 36 04                        ld      (HL),%00000100  ; set ALT flag, reset SHIFT & CTRL flag (currently multiply control keys are NOT supported)
 167+ 0D4F 3E FE        CHECKCTRL:      ld      A,%11111110     ; select CTRL row
 168+ 0D51 CD 0C 0D                     call    READKBLN        ; read CTRL row
 169+ 0D54 CB 57                        bit     2,A             ; test if CTRL key is pressed (3rd bit is reset)
 170+ 0D56 20 05                        jr      NZ,CHECKKBD     ; no, so make a normal reading
 171+ 0D58 21 1D 53                     ld      HL,CONTROLKEYS  ; control key flags
 172+ 0D5B 36 02                        ld      (HL),%00000010  ; set CTRL flag, reset SHIFT & ALT flags (currently multiply control keys are NOT supported)
 173+ 0D5D 06 08        CHECKKBD:       ld      B,$08           ; 8 lines
 174+ 0D5F 3E 7F                        ld      A,%01111111     ; start from the last line of the matrix
 175+ 0D61 16 0F        RPTKBDRD:       ld      D,$0F           ; register #15 (port B)
 176+ 0D63 0E 40                        ld      C,PSG_REG       ; PSG register port
 177+ 0D65 ED 51                        out     (C),D           ; select reg. #15
 178+ 0D67 0E 41                        ld      C,PSG_DAT       ; PSG data port
 179+ 0D69 ED 79                        out     (C),A           ; activate 1 line (active line is grounded, i.e. with a LOW signal)
 180+ 0D6B 5F                           ld      E,A             ; save current line into E
 181+ 0D6C 16 0E                        ld      D,$0E           ; register #14 (port A)
 182+ 0D6E 0E 40                        ld      C,PSG_REG       ; PSG register port
 183+ 0D70 ED 51                        out     (C),D           ; select reg. 14 (port A)
 184+ 0D72 00                           nop
 185+ 0D73 ED 78                        in      A,(C)           ; read register #14
 186+ 0D75 FE FF                        cp      $FF             ; is there any line set to 0?
 187+ 0D77 28 2E                        jr      Z,NOKEYPRSD     ; no, go to the next row
 188+ 0D79                              ; check control keys
 189+ 0D79 32 17 53                     ld      (KBTMP),A       ; yes, check if a control key was pressed. First, store current row
 190+ 0D7C 78                           ld      A,B             ; copy current row (B) into A
 191+ 0D7D FE 02                        cp      $02             ; is it the row of the SHIFT?
 192+ 0D7F 20 0F                        jr      NZ,TESTALT      ; no, continue checking the other control keys
 193+ 0D81 3A 17 53                     ld      A,(KBTMP)       ; yes, retrieve current row data
 194+ 0D84 CB 5F                        bit     3,A             ; check SHIFT bit line
 195+ 0D86 20 31                        jr      NZ,FINDKEY      ; no SHIFT, continue checking
 196+ 0D88 CB DF                        set     3,A             ; yes, it's the SHIFT. So remove SHIFT bit
 197+ 0D8A FE FF                        cp      $FF             ; after deleting the SHIFT bit, is there any other bit selected?
 198+ 0D8C 20 2B                        jr      NZ,FINDKEY      ; yes, go to check which one
 199+ 0D8E 18 17                        jr      NOKEYPRSD       ; no, go to next row
 200+ 0D90 FE 01        TESTALT:        cp      $01             ; is it the line of ALT & CTRL?
 201+ 0D92 3A 17 53                     ld      A,(KBTMP)       ; retrieve current row data
 202+ 0D95 20 22                        jr      NZ,FINDKEY      ; no, continue
 203+ 0D97 CB 6F                        bit     5,A             ; yes, check ALT bit line
 204+ 0D99 20 02                        jr      NZ,TESTCTRL     ; no ALT, continue checking
 205+ 0D9B CB EF                        set     5,A             ; yes, it's the ALT. So remove ALT bit
 206+ 0D9D CB 57        TESTCTRL:       bit     2,A             ; check CTRL bit line
 207+ 0D9F 20 02                        jr      NZ,ENDCTRLCK    ; no CTRL, continue checking
 208+ 0DA1 CB D7                        set     2,A             ; delete CTRL bit flag
 209+ 0DA3 FE FF        ENDCTRLCK:      cp      $FF             ; after deleting the ALT & CTRL bits, is there any other bit selected?
 210+ 0DA5 20 12                        jr      NZ,FINDKEY      ; yes, go to check which one
 211+ 0DA7 7B           NOKEYPRSD:      ld      A,E             ; no key pressed, load current output port
 212+ 0DA8 0F                           rrca                    ; rotate right by 1
 213+ 0DA9 10 B6                        djnz    RPTKBDRD        ; repeat for 8 lines
 214+ 0DAB AF                           xor     A               ; if exit from here, no key has been pressed...
 215+ 0DAC 32 19 53                     ld      (LASTKEYPRSD),A ; ...so reset the last key cell...
 216+ 0DAF 32 1D 53                     ld      (CONTROLKEYS),A ; ...reset contro key flags...
 217+ 0DB2 32 16 53                     ld      (KBDNPT),A      ; ...no input from keyboard...
 218+ 0DB5 32 1A 53                     ld      (STATUSKEY),A   ; ...no auto-repeat...
 219+ 0DB8 C9                           ret                     ; ...and leave
 220+ 0DB9 1E FF        FINDKEY:        ld      E,$FF           ; counter
 221+ 0DBB 1C           CHKLN:          inc     E               ; E goes from 0 to 7
 222+ 0DBC CB 3F                        srl     A               ; is the first bit reset? (we're looking for a "0", meaning grounded line)
 223+ 0DBE 38 FB                        jr      C,CHKLN         ; no, check next bit
 224+ 0DC0 3A 1D 53                     ld      A,(CONTROLKEYS) ; load control key flags
 225+ 0DC3 21 DC 0E                     ld      HL,KBMAP        ; normal keymap
 226+ 0DC6 FE 01                        cp      $01             ; SHIFT flag?
 227+ 0DC8 20 05                        jr      NZ,CHKCTRL      ; no, jump over
 228+ 0DCA 21 1C 0F                     ld      HL,KBMAP_SFT    ; SHIFT keymap
 229+ 0DCD 18 10                        jr      LOADMAP         ; and load it
 230+ 0DCF FE 02        CHKCTRL:        cp      $02             ; CTRL flag?
 231+ 0DD1 20 05                        jr      NZ,CHKALT       ; no, jump over
 232+ 0DD3 21 9C 0F                     ld      HL,KBMAP_CTRL   ; CTRL map
 233+ 0DD6 18 07                        jr      LOADMAP         ; and load it
 234+ 0DD8 FE 04        CHKALT:         cp      $04             ; ALT flag?
 235+ 0DDA 20 03                        jr      NZ,LOADMAP      ; no, check over
 236+ 0DDC 21 5C 0F                     ld      HL,KBMAP_ALT    ; ALT map
 237+ 0DDF 05           LOADMAP:        dec     B               ; decrement row # (rows go from 0 to 7)
 238+ 0DE0 48                           ld      C,B             ; move B into C and...
 239+ 0DE1 CB 21                        sla     C               ; ...multiply it...
 240+ 0DE3 CB 21                        sla     C               ; ...by 8 to find...
 241+ 0DE5 CB 21                        sla     C               ; ...the current row into the matrix
 242+ 0DE7 06 00                        ld      B,$00           ; reset B
 243+ 0DE9 09                           add     HL,BC           ; find the address of the current row
 244+ 0DEA 50                           ld      D,B             ; reset D
 245+ 0DEB 19                           add     HL,DE           ; find the current column - now (HL) stores the pressed key
 246+ 0DEC 3A 19 53                     ld      A,(LASTKEYPRSD) ; load the last key pressed
 247+ 0DEF BE                           cp      (HL)            ; is it the same key?
 248+ 0DF0 20 41                        jr      NZ,NEWKEY       ; no, it's a new key
 249+ 0DF2 44 4D                        ld      BC,HL           ; store address of current keycode
 250+ 0DF4 2A BB 52                     ld      HL,(TMRCNT)     ; load current system timer
 251+ 0DF7 ED 5B 1B 53                  ld      DE,(KEYTMR)     ; load auto-repeat timer
 252+ 0DFB 3A 1A 53                     ld      A,(STATUSKEY)   ; yes, load current status of auto-repeat
 253+ 0DFE FE 01                        cp      $01             ; is it initial pressure?
 254+ 0E00 20 1F                        jr      NZ,CHKAUTO      ; no, jump over
 255+ 0E02 AF                           xor     A               ; clear Carry
 256+ 0E03 ED 52                        sbc     HL,DE           ; startint time - actual time
 257+ 0E05 16 00                        ld      D,$00           ; 64 ths/s > 640 ms
 258+ 0E07 3A B1 51                     ld      A,(KEYDEL)
 259+ 0E0A 5F                           ld      E,A
 260+ 0E0B CD 97 3F                     call    CMP16           ; time elapsed is >= $40?
 261+ 0E0E DA 83 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 262+ 0E11 3E 02        SETNEWAUTO:     ld      A,$02           ; yes set status to...
 263+ 0E13 32 1A 53                     ld      (STATUSKEY),A   ; ...auto-repeat
 264+ 0E16 2A BB 52                     ld      HL,(TMRCNT)     ; load system timer
 265+ 0E19 22 1B 53                     ld      (KEYTMR),HL     ; store starting time
 266+ 0E1C 60 69                        ld      HL,BC           ; retrieve address of current keycode
 267+ 0E1E C3 40 0E                     jp      SENDKEY         ; send key
 268+ 0E21 AF           CHKAUTO:        xor     A               ; clear Carry
 269+ 0E22 ED 52                        sbc     HL,DE           ; computer interval between initial pressure of key and current time
 270+ 0E24 16 00                        ld      D,$00
 271+ 0E26 3A B2 51                     ld      A,(AUTOKE)
 272+ 0E29 5F                           ld      E,A             ; auto-repeat delay into DE
 273+ 0E2A CD 97 3F                     call    CMP16           ; check if interval is greater than delay
 274+ 0E2D DA 83 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 275+ 0E30 C3 11 0E                     jp      SETNEWAUTO      ; set new loop and send key
 276+ 0E33 AF           NEWKEY:         xor     A               ; set initial state...
 277+ 0E34 3C                           inc     A               ; ...for auto-repeat...
 278+ 0E35 32 1A 53                     ld      (STATUSKEY),A   ; ...1=pressure init
 279+ 0E38 ED 4B BB 52                  ld      BC,(TMRCNT)     ; load current system timer
 280+ 0E3C ED 43 1B 53                  ld      (KEYTMR),BC     ; set starting time
 281+ 0E40 7E           SENDKEY:        ld      A,(HL)          ; then, load key...
 282+ 0E41 32 19 53                     ld      (LASTKEYPRSD),A ; ...store it...
 283+ 0E44 32 18 53                     ld      (TMPKEYBFR),A   ; ...insert it into the INKEY buffer...
 284+ 0E47 32 D9 52                     ld      (CHR4VID),A     ; ...and store char for video
 285+ 0E4A FE 03                        cp      CTRLC           ; is it RUN/STOP?
 286+ 0E4C 20 05                        jr      NZ,CNTKBCK      ; no, jump over
 287+ 0E4E CD F4 01                     call    CHARINTOBFR     ; yes, send directly to buffer and...
 288+ 0E51 18 30                        jr      LVKBRDCHK2      ; ...leave
 289+ 0E53 01 00 08     CNTKBCK:        ld      BC,$0800        ; 8 FN keys (B), FN key number (C)
 290+ 0E56 21 D4 0E                     ld      HL,FNKEYSORD    ; FN keys codes
 291+ 0E59 BE           CHKFNK:         cp      (HL)            ; is it an FN key?
 292+ 0E5A CA 88 0E                     jp      Z,PRNTFNKEY     ; yes, jump over
 293+ 0E5D 0C                           inc     C               ; next FN key
 294+ 0E5E 23                           inc     HL              ; next FN key code
 295+ 0E5F 10 F8                        djnz    CHKFNK          ; continue for 8 FN keys
 296+ 0E61 3E 01        SNDKEYTOBFR:    ld      A,$01           ; normal key - set input flag
 297+ 0E63 32 16 53                     ld      (KBDNPT),A      ; to keyboard
 298+ 0E66 3A D8 52                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 299+ 0E69 B7                           or      A               ; is the print-on-video disabled?
 300+ 0E6A CA 73 0E                     jp      Z,PUTCHRBUF     ; yes, so send char to input buffer
 301+ 0E6D 3A D6 52                     ld      A,(CRSR_STATE)  ; check cursor state
 302+ 0E70 B7                           or      A               ; is it 0 (cursor OFF)?
 303+ 0E71 20 0D                        jr      NZ,PNT2VD       ; no, print on screen
 304+ 0E73 AF           PUTCHRBUF:      xor     A
 305+ 0E74 32 16 53                     ld      (KBDNPT),A      ; if send to input buffer, set RETURN as from BASIC
 306+ 0E77 3A 18 53                     ld      A,(TMPKEYBFR)   ; retrieve char
 307+ 0E7A CD F4 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 308+ 0E7D C3 83 0E                     jp      LVKBRDCHK2      ; ...and leave
 309+ 0E80 CD 56 07     PNT2VD:         call    CHAR2VID        ; send char to video
 310+ 0E83 AF           LVKBRDCHK2:     xor     A
 311+ 0E84 32 1D 53                     ld      (CONTROLKEYS),A ; reset control key flags
 312+ 0E87 C9           LVKBRDCHK:      ret                     ; return to caller: the current key code is into TMPKEYBFR
 313+ 0E88                              ; manage FN keys
 314+ 0E88 57           PRNTFNKEY:      ld      D,A             ; copy A into D
 315+ 0E89 2A AD 51                     ld      HL,(LINEAT)     ; Get current line number
 316+ 0E8C 23                           inc     HL              ; -1 means direct statement
 317+ 0E8D 7C                           ld      A,H
 318+ 0E8E B5                           or      L
 319+ 0E8F 7A                           ld      A,D             ; retrieve char
 320+ 0E90 20 CF                        jr      NZ,SNDKEYTOBFR  ; indirect mode - just send FN key code to buffer
 321+ 0E92 79                           ld      A,C             ; direct mode, so print text - first, get FN key number
 322+ 0E93 87                           add     A,A
 323+ 0E94 87                           add     A,A
 324+ 0E95 87                           add     A,A
 325+ 0E96 87                           add     A,A             ; FN key number * 16
 326+ 0E97 4F                           ld      C,A             ; move it into C
 327+ 0E98 06 00                        ld      B,$00           ; reset B, to get offset
 328+ 0E9A 21 B3 51                     ld      HL,FNKEYS       ; load address of FN keys texts
 329+ 0E9D 09                           add     HL,BC           ; get correct text address
 330+ 0E9E 06 10                        ld      B,$10           ; 16 chars
 331+ 0EA0 7E           LDFNKEYCHR:     ld      A,(HL)          ; load char
 332+ 0EA1 A7                           and     A               ; null char?
 333+ 0EA2 CA 83 0E                     jp      Z,LVKBRDCHK2    ; yes, so leave
 334+ 0EA5 57                           ld      D,A             ; pass char into D
 335+ 0EA6 3A D8 52                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 336+ 0EA9 B7                           or      A               ; is the print-on-video disabled?
 337+ 0EAA CA BA 0E                     jp      Z,PUTCHRBUF1    ; yes, so send char to input buffer
 338+ 0EAD 3A D6 52                     ld      A,(CRSR_STATE)  ; check cursor state
 339+ 0EB0 B7                           or      A               ; is it 0 (cursor OFF)?
 340+ 0EB1 C4 C7 0E                     call    NZ,PRNTFNK      ; no, print on screen
 341+ 0EB4 23           CNTFNK:         inc     HL              ; next char
 342+ 0EB5 10 E9                        djnz    LDFNKEYCHR      ; repeat for max. 16 chars
 343+ 0EB7 C3 83 0E                     jp      LVKBRDCHK2      ; leave
 344+ 0EBA AF           PUTCHRBUF1:     xor     A               ; if send to input buffer,...
 345+ 0EBB 32 16 53                     ld      (KBDNPT),A      ; ...set input as from BASIC
 346+ 0EBE 7A                           ld      A,D             ; retrieve char
 347+ 0EBF E5                           push    HL              ; store HL
 348+ 0EC0 CD F4 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 349+ 0EC3 E1                           pop     HL              ; retrieve HL
 350+ 0EC4 C3 B4 0E                     jp      CNTFNK          ; repeat
 351+ 0EC7 7A           PRNTFNK:        ld      A,D             ; recover char
 352+ 0EC8 32 D9 52                     ld      (CHR4VID),A     ; store char for printing
 353+ 0ECB 3E 01                        ld      A,$01           ; normal key - set input flag
 354+ 0ECD 32 16 53                     ld      (KBDNPT),A      ; to keyboard
 355+ 0ED0 CD 56 07                     call    CHAR2VID        ; print on screen
 356+ 0ED3 C9                           ret                     ; return to caller
 357+ 0ED4
 358+ 0ED4
 359+ 0ED4              ;-----------------------------------------------------------------------
 360+ 0ED4 01 02 04 05  FNKEYSORD:      defb 1,2,4,5,6,22,23,24                 ; order of FN Keys
 360+ 0ED8 06 16 17 18
 361+ 0EDC              ;-----------------------------------------------------------------------
 362+ 0EDC              ; key codes
 363+ 0EDC 31 19 0E 03  KBMAP:          defb '1',25,14,3,' ',16,'q','2'         ; 25=HOME  14=CTRL  3=RUN/STOP 16=C=
 363+ 0EE0 20 10 71 32
 364+ 0EE4 33 77 61 14                  defb '3','w','a',20,'z','s','e','4'     ; 20=SHIFT
 364+ 0EE8 7A 73 65 34
 365+ 0EEC 35 72 64 78                  defb '5','r','d','x','c','f','t','6'
 365+ 0EF0 63 66 74 36
 366+ 0EF4 37 79 67 76                  defb '7','y','g','v','b','h','u','8'
 366+ 0EF8 62 68 75 38
 367+ 0EFC 39 69 6A 6E                  defb '9','i','j','n','m','k','o','0'
 367+ 0F00 6D 6B 6F 30
 368+ 0F04 1F 70 6C 2C                  defb 31,'p','l',',','.',':','-',30      ; 31=CURSOR DOWN  30=CURSOR UP
 368+ 0F08 2E 3A 2D 1E
 369+ 0F0C 1C 2A 3B 2F                  defb 28,'*',';','/',27,'=','+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 369+ 0F10 1B 3D 2B 1D
 370+ 0F14 08 0D FC 40                  defb 8,13,252,'@',1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 370+ 0F18 01 02 04 18
 371+ 0F1C
 372+ 0F1C              ; shifted codes - not all the keys have the shifted version
 373+ 0F1C 21 0C 0E 03  KBMAP_SFT:      defb '!',12,14,3,' ',16,'Q',34          ; 12=CLEAR  14=CTRL  3=RUN/STOP 16=C=   34="
 373+ 0F20 20 10 51 22
 374+ 0F24 23 57 41 14                  defb '#','W','A',20,'Z','S','E','$'     ; 20=SHIFT
 374+ 0F28 5A 53 45 24
 375+ 0F2C 25 52 44 58                  defb '%','R','D','X','C','F','T','&'
 375+ 0F30 43 46 54 26
 376+ 0F34 27 59 47 56                  defb 39,'Y','G','V','B','H','U','('     ; 39='
 376+ 0F38 42 48 55 28
 377+ 0F3C 29 49 4A 4E                  defb ')','I','J','N','M','K','O',94     ; 94=^
 377+ 0F40 4D 4B 4F 5E
 378+ 0F44 1F 50 4C 3C                  defb 31,'P','L','<','>','[','_',30      ; 31=CURSOR DOWN  30=CURSOR UP
 378+ 0F48 3E 5B 5F 1E
 379+ 0F4C 1C 2A 5D 3F                  defb 28,'*',']','?',27,198,'+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 379+ 0F50 1B C6 2B 1D
 380+ 0F54 1A 0D D3 40                  defb 26,13,211,'@',5,6,22,23            ; 26=INSERT, 211=â¬  5=F4  6=F5  22=F6  23=F7
 380+ 0F58 05 06 16 17
 381+ 0F5C
 382+ 0F5C              ; ALT (C=) codes - not all the keys have the alt-ed version
 383+ 0F5C 31 0C 0E 03  KBMAP_ALT:      defb '1',12,14,3,' ',16,222,196         ; 12=CLEAR  14=CTRL  3=RUN/STOP  16=C=  34="
 383+ 0F60 20 10 DE C4
 384+ 0F64 33 DD 85 14                  defb '3',221,133,20,131,130,165,'4'     ; 20=SHIFT
 384+ 0F68 83 82 A5 34
 385+ 0F6C 35 A2 A6 84                  defb '5',162,166,132,157,163,168,'6'
 385+ 0F70 9D A3 A8 36
 386+ 0F74 37 AB A9 A1                  defb '7',171,169,161,158,172,213,'8'    ;
 386+ 0F78 9E AC D5 38
 387+ 0F7C 39 D6 D8 9F                  defb '9',214,216,159,160,215,135,195    ;
 387+ 0F80 A0 D7 87 C3
 388+ 0F84 1F 88 8A C1                  defb 31,136,138,193,192,123,144,30      ; 31=CURSOR DOWN  123={  30=CURSOR UP
 388+ 0F88 C0 7B 90 1E
 389+ 0F8C 1C 8F 7D FE                  defb 28,143,125,254,27,209,148,29       ; 28=CURSOR LEFT  125=}  27=ESCAPE  29=CURSOR RIGHT
 389+ 0F90 1B D1 94 1D
 390+ 0F94 08 0D E0 89                  defb 8,13,224,137,5,6,22,23             ; 8=DEL(backspace)  13=RETURN  252=Â£  5=F4  6=F5  22=F6  23=F7
 390+ 0F98 05 06 16 17
 391+ 0F9C
 392+ 0F9C              ; CTRL codes - not all the keys have the control-ed version
 393+ 0F9C 31 19 0E 03  KBMAP_CTRL:     defb '1',25,14,3,' ',16,154,'2'         ; 25=HOME  14=CTRL  3=RUN/STOP  16=C=
 393+ 0FA0 20 10 9A 32
 394+ 0FA4 33 9C 95 14                  defb '3',156,149,20,152,150,153,'4'     ; 20=SHIFT
 394+ 0FA8 98 96 99 34
 395+ 0FAC 35 9B B0 97                  defb '5',155,176,151,177,175,165,'6'
 395+ 0FB0 B1 AF A5 36
 396+ 0FB4 37 A6 A8 B2                  defb '7',166,168,178,179,169,167,'8'
 396+ 0FB8 B3 A9 A7 38
 397+ 0FBC 39 B8 AA AC                  defb '9',184,170,172,171,181,164,'0'
 397+ 0FC0 AB B5 A4 30
 398+ 0FC4 1F A3 AD 2C                  defb 31,163,173,',','.',':',186,30      ; 31=CURSOR DOWN  30=CURSOR UP
 398+ 0FC8 2E 3A BA 1E
 399+ 0FCC 1C E1 3B 2F                  defb 28,225,';','/',27,212,185,29       ; 28=CURSOR LEFT  27=ESCAPE  212=Ï  29=CURSOR RIGHT
 399+ 0FD0 1B D4 B9 1D
 400+ 0FD4 08 0D BD A2                  defb 8,13,189,162,1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 400+ 0FD8 01 02 04 18
# file closed: ../include/psg/psg64k-r1.0.asm
  70  0FDC
  71  0FDC              ; include the latest version of the LM80C 64K BASIC interpreter
  72  0FDC                  INCLUDE "../include/basic/basic64k-r1.01.asm"
# file opened: ../include/basic/basic64k-r1.01.asm
   1+ 0FDC              ; ------------------------------------------------------------------------------
   2+ 0FDC              ; LM80C BASIC 64K - R1.01
   3+ 0FDC              ; ------------------------------------------------------------------------------
   4+ 0FDC              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0FDC              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0FDC              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0FDC              ; kind of warranty: you can use them at your own risk.
   8+ 0FDC              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0FDC              ; maintain the copyright notices, include this advice and the note to the
  10+ 0FDC              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0FDC              ; redistribuite them.
  12+ 0FDC              ; https://www.leonardomiliani.com
  13+ 0FDC              ;
  14+ 0FDC              ; Please support me by visiting the following links:
  15+ 0FDC              ; Main project page: https://www.leonardomiliani.com
  16+ 0FDC              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0FDC              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0FDC              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0FDC              ; ------------------------------------------------------------------------------
  20+ 0FDC              ; LM80C BASIC 64K - originally based on the following NASCOM BASIC versions:
  21+ 0FDC              ; 4.7  - original version by NASCOM/MICROSOFT
  22+ 0FDC              ; 4.7b - modified version by Grant Searle (additional commands & functions)
  23+ 0FDC
  24+ 0FDC
  25+ 0FDC              ;------------------------------------------------------------------------------
  26+ 0FDC              ;  L M 8 0 C   6 4 K   B A S I C
  27+ 0FDC              ;------------------------------------------------------------------------------
  28+ 0FDC
  29+ 0FDC              ; GENERAL EQUATES
  30+ 0FDC
  31+ 0FDC              NLLCR           equ     $00             ; null char (used as space/empty char in video prints)
  32+ 0FDC              CTRLC           equ     $03             ; Control "C"
  33+ 0FDC              CTRLG           equ     $07             ; Control "G"
  34+ 0FDC              BKSP            equ     $08             ; Back space
  35+ 0FDC              LF              equ     $0A             ; Line feed
  36+ 0FDC              CS              equ     $0C             ; Clear screen
  37+ 0FDC              CR              equ     $0D             ; Carriage return
  38+ 0FDC              CTRLO           equ     $0F             ; Control "O"
  39+ 0FDC              CTRLQ           equ     $11             ; Control "Q"
  40+ 0FDC              CTRLR           equ     $12             ; Control "R"
  41+ 0FDC              CTRLS           equ     $13             ; Control "S"
  42+ 0FDC              CTRLU           equ     $15             ; Control "U"
  43+ 0FDC              HOME            equ     $19             ; Home (cursor at 0,0)
  44+ 0FDC              ESC             equ     $1B             ; Escape
  45+ 0FDC              SPC             equ     $20             ; Space
  46+ 0FDC              DEL             equ     $7F             ; Delete
  47+ 0FDC              INSRT           equ     $1A             ; Insert Key
  48+ 0FDC              ; cursor ASCII codes
  49+ 0FDC              CRSLFT          equ     $1C             ; cursor left
  50+ 0FDC              CRSRGT          equ     $1D             ; cursor right
  51+ 0FDC              CRSUP           equ     $1E             ; cursor up
  52+ 0FDC              CRSDN           equ     $1F             ; cursor down
  53+ 0FDC
  54+ 0FDC
  55+ 0FDC              ;-------------------------------------------------------------------------
  56+ 0FDC              ; BASIC ERROR MESSAGES
  57+ 0FDC              ; the interpreter looks for a single-byte code in the following list,
  58+ 0FDC              ; then loads the corresponding memory pointer in "ERRTBL" table to
  59+ 0FDC              ; find where to retrieve the message text in "ERRORS"
  60+ 0FDC
  61+ 0FDC              ; BASIC ERROR CODE VALUES
  62+ 0FDC              ; These values act as an offset to point to the error message into the error table
  63+ 0FDC              ; must be incremented by 2 because they point to a word address jump
  64+ 0FDC              NF              equ     $00     ; NEXT without FOR
  65+ 0FDC              SN              equ     $02     ; Syntax error
  66+ 0FDC              RG              equ     $04     ; RETURN without GOSUB
  67+ 0FDC              OD              equ     $06     ; Out of DATA
  68+ 0FDC              FC              equ     $08     ; Function call error
  69+ 0FDC              OV              equ     $0A     ; Overflow
  70+ 0FDC              OM              equ     $0C     ; Out of memory
  71+ 0FDC              UL              equ     $0E     ; Undefined line number
  72+ 0FDC              BS              equ     $10     ; Bad subscript
  73+ 0FDC              DD              equ     $12     ; Re-Dimensioned array
  74+ 0FDC              DZ              equ     $14     ; Division by zero (/0)
  75+ 0FDC              ID              equ     $16     ; Illegal direct
  76+ 0FDC              TM              equ     $18     ; Type mis-match
  77+ 0FDC              OS              equ     $1A     ; Out of string space
  78+ 0FDC              LS              equ     $1C     ; String too long
  79+ 0FDC              ST              equ     $1E     ; String formula too complex
  80+ 0FDC              CN              equ     $20     ; Can't continue
  81+ 0FDC              UF              equ     $22     ; Undefined FN function
  82+ 0FDC              MO              equ     $24     ; Missing operand
  83+ 0FDC              HX              equ     $26     ; HEX error
  84+ 0FDC              BN              equ     $28     ; BIN error
  85+ 0FDC              GM              equ     $2A     ; No Graphics Mode
  86+ 0FDC              SC              equ     $2C     ; Serial configuration
  87+ 0FDC              SA              equ     $2E     ; Serial port already open
  88+ 0FDC              SO              equ     $30     ; Serial buffer overrun
  89+ 0FDC              HP              equ     $32     ; HELP call
  90+ 0FDC
  91+ 0FDC              ; BASIC ERROR POINTER TABLE
  92+ 0FDC              ERRTBL: equ $
  93+ 0FDC 10 10        NFPTR:  defw    NFMSG
  94+ 0FDE 21 10        SNPTR:  defw    SNMSG
  95+ 0FE0 28 10        RGPTR:  defw    RGMSG
  96+ 0FE2 3D 10        ODPTR:  defw    ODMSG
  97+ 0FE4 49 10        FCPTR:  defw    FCMSG
  98+ 0FE6 5F 10        OVPTR:  defw    OVMSG
  99+ 0FE8 68 10        OMPTR:  defw    OMMSG
 100+ 0FEA 76 10        ULPTR:  defw    ULMSG
 101+ 0FEC 85 10        BSPTR:  defw    BSMSG
 102+ 0FEE 93 10        DDPTR:  defw    DDMSG
 103+ 0FF0 A8 10        DZPTR:  defw    DZMSG
 104+ 0FF2 B9 10        IDPTR:  defw    IDMSG
 105+ 0FF4 C8 10        TMPTR:  defw    TMMSG
 106+ 0FF6 D7 10        OSPTR:  defw    OSMSG
 107+ 0FF8 EB 10        LSPTR:  defw    LSMSG
 108+ 0FFA FB 10        STPTR:  defw    STMSG
 109+ 0FFC 16 11        CNPTR:  defw    CNMSG
 110+ 0FFE 25 11        UFPTR:  defw    UFMSG
 111+ 1000 3B 11        MOPTR:  defw    MOMSG
 112+ 1002 4B 11        HXPTR:  defw    HXMSG
 113+ 1004 56 11        BNPTR:  defw    BNMSG
 114+ 1006 61 11        GMPRT:  defw    GMMSG
 115+ 1008 72 11        SCPTR:  defw    SCMSG
 116+ 100A 87 11        SAPTR:  defw    SAMSG
 117+ 100C A0 11        SOPTR:  defw    SOMSG
 118+ 100E B6 11        HPPTR:  defw    HPMSG
 119+ 1010
 120+ 1010              ; BASIC ERROR MESSAGE LIST
 121+ 1010              ERRORS  equ $
 122+ 1010 4E 45 58 54  NFMSG:  defb    "NEXT Without FOR",0
 122+ 1014 20 57 69 74
 122+ 1018 68 6F 75 74
 122+ 101C 20 46 4F 52
 122+ 1020 00
 123+ 1021 53 79 6E 74  SNMSG:  defb    "Syntax",0
 123+ 1025 61 78 00
 124+ 1028 52 45 54 55  RGMSG:  defb    "RETURN without GOSUB",0
 124+ 102C 52 4E 20 77
 124+ 1030 69 74 68 6F
 124+ 1034 75 74 20 47
 124+ 1038 4F 53 55 42
 124+ 103C 00
 125+ 103D 4F 75 74 20  ODMSG:  defb    "Out of DATA",0
 125+ 1041 6F 66 20 44
 125+ 1045 41 54 41 00
 126+ 1049 49 6C 6C 65  FCMSG:  defb    "Illegal Function Call",0
 126+ 104D 67 61 6C 20
 126+ 1051 46 75 6E 63
 126+ 1055 74 69 6F 6E
 126+ 1059 20 43 61 6C
 126+ 105D 6C 00
 127+ 105F 4F 76 65 72  OVMSG:  defb    "Overflow",0
 127+ 1063 66 6C 6F 77
 127+ 1067 00
 128+ 1068 4F 75 74 20  OMMSG:  defb    "Out of Memory",0
 128+ 106C 6F 66 20 4D
 128+ 1070 65 6D 6F 72
 128+ 1074 79 00
 129+ 1076 55 6E 64 65  ULMSG:  defb    "Undefined Line",0
 129+ 107A 66 69 6E 65
 129+ 107E 64 20 4C 69
 129+ 1082 6E 65 00
 130+ 1085 42 61 64 20  BSMSG:  defb    "Bad Subscript",0
 130+ 1089 53 75 62 73
 130+ 108D 63 72 69 70
 130+ 1091 74 00
 131+ 1093 52 65 2D 44  DDMSG:  defb    "Re-Dimensioned Array",0
 131+ 1097 69 6D 65 6E
 131+ 109B 73 69 6F 6E
 131+ 109F 65 64 20 41
 131+ 10A3 72 72 61 79
 131+ 10A7 00
 132+ 10A8 44 69 76 69  DZMSG:  defb    "Division by Zero",0
 132+ 10AC 73 69 6F 6E
 132+ 10B0 20 62 79 20
 132+ 10B4 5A 65 72 6F
 132+ 10B8 00
 133+ 10B9 49 6C 6C 65  IDMSG:  defb    "Illegal Direct",0
 133+ 10BD 67 61 6C 20
 133+ 10C1 44 69 72 65
 133+ 10C5 63 74 00
 134+ 10C8 54 79 70 65  TMMSG:  defb    "Type Mis-match",0
 134+ 10CC 20 4D 69 73
 134+ 10D0 2D 6D 61 74
 134+ 10D4 63 68 00
 135+ 10D7 4F 75 74 20  OSMSG:  defb    "Out of String Space",0
 135+ 10DB 6F 66 20 53
 135+ 10DF 74 72 69 6E
 135+ 10E3 67 20 53 70
 135+ 10E7 61 63 65 00
 136+ 10EB 53 74 72 69  LSMSG:  defb    "String Too Long",0
 136+ 10EF 6E 67 20 54
 136+ 10F3 6F 6F 20 4C
 136+ 10F7 6F 6E 67 00
 137+ 10FB 53 74 72 69  STMSG:  defb    "String Formula Too Complex",0
 137+ 10FF 6E 67 20 46
 137+ 1103 6F 72 6D 75
 137+ 1107 6C 61 20 54
 137+ 110B 6F 6F 20 43
 137+ 110F 6F 6D 70 6C
 137+ 1113 65 78 00
 138+ 1116 43 61 6E 27  CNMSG:  defb    "Can't Continue",0
 138+ 111A 74 20 43 6F
 138+ 111E 6E 74 69 6E
 138+ 1122 75 65 00
 139+ 1125 55 6E 64 65  UFMSG:  defb    "Undefined FN Function",0
 139+ 1129 66 69 6E 65
 139+ 112D 64 20 46 4E
 139+ 1131 20 46 75 6E
 139+ 1135 63 74 69 6F
 139+ 1139 6E 00
 140+ 113B 4D 69 73 73  MOMSG:  defb    "Missing Operand",0
 140+ 113F 69 6E 67 20
 140+ 1143 4F 70 65 72
 140+ 1147 61 6E 64 00
 141+ 114B 48 45 58 20  HXMSG:  defb    "HEX Format",0
 141+ 114F 46 6F 72 6D
 141+ 1153 61 74 00
 142+ 1156 42 49 4E 20  BNMSG:  defb    "BIN Format",0
 142+ 115A 46 6F 72 6D
 142+ 115E 61 74 00
 143+ 1161 4E 6F 20 47  GMMSG:  defb    "No Graphics Mode",0
 143+ 1165 72 61 70 68
 143+ 1169 69 63 73 20
 143+ 116D 4D 6F 64 65
 143+ 1171 00
 144+ 1172 53 65 72 69  SCMSG:  defb    "Serial Configuration",0
 144+ 1176 61 6C 20 43
 144+ 117A 6F 6E 66 69
 144+ 117E 67 75 72 61
 144+ 1182 74 69 6F 6E
 144+ 1186 00
 145+ 1187 53 65 72 69  SAMSG:  defb    "Serial Port Already Open",0
 145+ 118B 61 6C 20 50
 145+ 118F 6F 72 74 20
 145+ 1193 41 6C 72 65
 145+ 1197 61 64 79 20
 145+ 119B 4F 70 65 6E
 145+ 119F 00
 146+ 11A0 53 65 72 69  SOMSG:  defb    "Serial Buffer Overrun",0
 146+ 11A4 61 6C 20 42
 146+ 11A8 75 66 66 65
 146+ 11AC 72 20 4F 76
 146+ 11B0 65 72 72 75
 146+ 11B4 6E 00
 147+ 11B6 48 45 4C 50  HPMSG:  defb    "HELP Call",0
 147+ 11BA 20 43 61 6C
 147+ 11BE 6C 00
 148+ 11C0
 149+ 11C0
 150+ 11C0              ;-----------------------------------------------------------------------------
 151+ 11C0              ; STARTING POINTS FOR BASIC BOOT
 152+ 11C0              ; COLD: reset every memory pointer, acting as a power-up boot
 153+ 11C0              ; WARM: preserve program in memory, keeping every current pointer
 154+ 11C0
 155+ 11C0 C3 C6 11     COLD:   jp      STARTB          ; Jump for cold start
 156+ 11C3 C3 74 12     WARM:   jp      WARMST          ; Jump for warm start
 157+ 11C6
 158+ 11C6 C3 CD 11     STARTB: jp      CSTART          ; Jump to initialise
 159+ 11C9 81 1C                defw    DEINT           ; Get integer -32768 to 32767
 160+ 11CB 3E 24                defw    ABPASS          ; Return integer in AB
 161+ 11CD 21 5C 51     CSTART: ld      HL,WRKSPC       ; Start of workspace RAM
 162+ 11D0 F9                   ld      SP,HL           ; Set up a temporary stack
 163+ 11D1 C3 82 3F             jp      INITST          ; Go to initialise
 164+ 11D4
 165+ 11D4 21 41 15     INIT:   ld      HL,INITAB       ; Initialise workspace
 166+ 11D7 01 DC 00             ld      BC,INITBE-INITAB+3; Bytes to copy
 167+ 11DA 11 5C 51             ld      DE,WRKSPC       ; Into workspace RAM
 168+ 11DD ED B0                ldir                    ; Copy data
 169+ 11DF EB                   ex      DE,HL           ; Copy DE into HL
 170+ 11E0 F9                   ld      SP,HL           ; Temporary stack
 171+ 11E1 CD F4 17             call    CLREG           ; Clear registers and stack
 172+ 11E4 CD 98 1E             call    PRNTCRLF        ; Output CRLF
 173+ 11E7 32 8F 52             ld      (BUFFER+88+1),A ; Mark end of buffer
 174+ 11EA 32 45 53             ld      (PROGST),A      ; Initialise program area
 175+ 11ED 18 13                jr      MNOASK          ; usually, don't ask for memory top (only when there are errors)
 176+ 11EF 21 DB 12     MSIZE:  ld      HL,MEMMSG       ; Point to message
 177+ 11F2 CD 5C 25             call    PRS             ; Output "Memory size"
 178+ 11F5 CD 11 18             call    PROMPT          ; Get input with '?'
 179+ 11F8 CD F2 08             call    CURSOR_ON       ; enable cursor
 180+ 11FB CD CB 1B             call    GETCHR          ; Get next character
 181+ 11FE B7                   or      A               ; Set flags
 182+ 11FF C2 17 12             jp      NZ,TSTMEM       ; If number - Test if RAM there
 183+ 1202 21 A9 53     MNOASK: ld      HL,STLOOK       ; Point to start of RAM
 184+ 1205 23           MLOOP:  inc     HL              ; Next byte
 185+ 1206 7C                   ld      A,H             ; Above address FFFF ?
 186+ 1207 B5                   or      L
 187+ 1208 CA 29 12             jp      Z,SETTOP        ; Yes - 64K RAM
 188+ 120B 7E                   ld      A,(HL)          ; Get contents
 189+ 120C 47                   ld      B,A             ; Save it
 190+ 120D 2F                   cpl                     ; Flip all bits
 191+ 120E 77                   ld      (HL),A          ; Put it back
 192+ 120F BE                   cp      (HL)            ; RAM there if same
 193+ 1210 70                   ld      (HL),B          ; Restore old contents
 194+ 1211 CA 05 12             jp      Z,MLOOP         ; If RAM - test next byte
 195+ 1214 C3 29 12             jp      SETTOP          ; Top of RAM found
 196+ 1217
 197+ 1217 CD 9B 1C     TSTMEM: call    ATOH            ; Get high memory into DE
 198+ 121A B7                   or      A               ; Set flags on last byte
 199+ 121B C2 A8 16             jp      NZ,SNERR        ; ?SN Error if bad character
 200+ 121E EB                   ex      DE,HL           ; Address into HL
 201+ 121F 2B                   dec     HL              ; Back one byte
 202+ 1220 3E D9                ld      A,%11011001     ; Test byte
 203+ 1222 46                   ld      B,(HL)          ; Get old contents
 204+ 1223 77                   ld      (HL),A          ; Load test byte
 205+ 1224 BE                   cp      (HL)            ; RAM there if same
 206+ 1225 70                   ld      (HL),B          ; Restore old contents
 207+ 1226 C2 EF 11             jp      NZ,MSIZE        ; Ask again if no RAM
 208+ 1229
 209+ 1229 CD 07 09     SETTOP: call    CURSOR_OFF      ; disable cursor
 210+ 122C 2B                   dec     HL              ; Back one byte
 211+ 122D 11 A8 53             ld      DE,STLOOK-1     ; See if enough RAM
 212+ 1230 CD 84 19             call    CPDEHL          ; Compare DE with HL
 213+ 1233 DA EF 11             jp      C,MSIZE         ; Ask again if not enough RAM
 214+ 1236 3A 21 53             ld      A,(DOS_EN)      ; read if the user enabled/disabled DOS while booting
 215+ 1239 1F                   rra                     ; is DOS disabled?
 216+ 123A 30 04                jr      NC,NODOS        ; yes, so jump over
 217+ 123C 11 00 FE             ld      DE,0-512        ; no, so reserve 512 bytes on top of RAM...
 218+ 123F 19                   add     HL,DE           ; ...for I/O buffer
 219+ 1240 11 9C FF     NODOS:  ld      DE,0-100        ; 100 Bytes string space
 220+ 1243 22 94 52             ld      (LSTRAM),HL     ; Save last available RAM
 221+ 1246 19                   add     HL,DE           ; Allocate string space
 222+ 1247 22 AB 51             ld      (STRSPC),HL     ; Save string space
 223+ 124A CD CF 17             call    CLRPTR          ; Clear program area
 224+ 124D 2A AB 51             ld      HL,(STRSPC)     ; Get end of memory
 225+ 1250 11 EF FF             ld      DE,0-17         ; Offset for free bytes
 226+ 1253 19                   add     HL,DE           ; Adjust HL
 227+ 1254 11 45 53             ld      DE,PROGST       ; Start of program text
 228+ 1257 7D                   ld      A,L             ; Get LSB
 229+ 1258 93                   sub     E               ; Adjust it
 230+ 1259 6F                   ld      L,A             ; Re-save
 231+ 125A 7C                   ld      A,H             ; Get MSB
 232+ 125B 9A                   sbc     A,D             ; Adjust it
 233+ 125C 67                   ld      H,A             ; Re-save
 234+ 125D E5                   push    HL              ; Save bytes free
 235+ 125E 21 9A 12             ld      HL,SIGNON       ; Sign-on message
 236+ 1261 CD 5C 25             call    PRS             ; Output string
 237+ 1264 21 83 12             ld      HL,BLNSPC       ; Empty space
 238+ 1267 CD 5C 25             call    PRS             ; Output string
 239+ 126A E1                   pop     HL              ; Get bytes free back
 240+ 126B CD FB 2F             call    PRNTHL          ; Output amount of free memory
 241+ 126E 21 8C 12             ld      HL,BFREE        ; " Bytes free" message
 242+ 1271 CD 5C 25             call    PRS             ; Output string
 243+ 1274
 244+ 1274 31 3B 52     WARMST: ld      SP,STACK        ; Temporary stack
 245+ 1277 CD F4 17     BRKRET: call    CLREG           ; Clear registers and stack
 246+ 127A CD 19 3D             call    RESFN           ; reset FN keys and auto-repeat
 247+ 127D CD F2 08             call    CURSOR_ON       ; enable cursor
 248+ 1280 C3 02 17             jp      PRNTOK          ; Go to get command line
 249+ 1283
 250+ 1283 20 20 20 20  BLNSPC: defb    "        ",0    ; 8 empty cells to align the "XXXX Bytes free" message
 250+ 1287 20 20 20 20
 250+ 128B 00
 251+ 128C 20 42 79 74  BFREE:  defb    " Bytes free",CR,CR,0
 251+ 1290 65 73 20 66
 251+ 1294 72 65 65 0D
 251+ 1298 0D 00
 252+ 129A
 253+ 129A 4C 4D 38 30  SIGNON: defb    "LM80C BASIC 64K ",251," 2020 L.Miliani"
 253+ 129E 43 20 42 41
 253+ 12A2 53 49 43 20
 253+ 12A6 36 34 4B 20
 253+ 12AA FB 20 32 30
 253+ 12AE 32 30 20 4C
 253+ 12B2 2E 4D 69 6C
 253+ 12B6 69 61 6E 69
 254+ 12BA 20 5A 38 30          defb    " Z80 BASIC 4.7 ",251," 1978 Microsoft",CR,0
 254+ 12BE 20 42 41 53
 254+ 12C2 49 43 20 34
 254+ 12C6 2E 37 20 FB
 254+ 12CA 20 31 39 37
 254+ 12CE 38 20 4D 69
 254+ 12D2 63 72 6F 73
 254+ 12D6 6F 66 74 0D
 254+ 12DA 00
 255+ 12DB
 256+ 12DB 4D 65 6D 6F  MEMMSG: defb    "Memory top",0
 256+ 12DF 72 79 20 74
 256+ 12E3 6F 70 00
 257+ 12E6
 258+ 12E6              ; The following list reports all the functions supported by the interpreter.
 259+ 12E6              ; To add a custom function, the user must first insert the reserved word here,
 260+ 12E6              ; then into the list of the reserved words below, and finally must increment the
 261+ 12E6              ; ZSGN token value and all the following ones after ZSGN by 1 for every added
 262+ 12E6              ; function.
 263+ 12E6
 264+ 12E6              ; FUNCTION ADDRESS TABLE (this is a sort of offset table)
 265+ 12E6              ; this list must be coherent with the tokens' functions list. This means that every
 266+ 12E6              ; entry here must have the corresponding entry in the tokens list.
 267+ 12E6 70 2E        FNCTAB: defw    SGN
 268+ 12E8 06 24                defw    TMR         ; added by Leonardo Miliani
 269+ 12EA 34 2F                defw    INT
 270+ 12EC 86 2E                defw    ABS_        ; _ necessary for assembler warning
 271+ 12EE 62 51                defw    USR
 272+ 12F0 1C 24                defw    FRE
 273+ 12F2 97 28                defw    INP
 274+ 12F4 4A 24                defw    POS
 275+ 12F6 FA 30                defw    SQR
 276+ 12F8 D9 31                defw    RND
 277+ 12FA C4 2C                defw    LOG
 278+ 12FC 48 31                defw    EXP
 279+ 12FE 4E 32                defw    COS
 280+ 1300 54 32                defw    SIN
 281+ 1302 B5 32                defw    TAN
 282+ 1304 CA 32                defw    ATN
 283+ 1306 73 29                defw    PEEK
 284+ 1308 35 33                defw    DEEK
 285+ 130A 7A 29                defw    VPEEK       ; added by Leonardo Miliani
 286+ 130C 49 2B                defw    VSTAT       ; added by Leonardo Miliani
 287+ 130E 54 2B                defw    SSTAT       ; added by Leonardo Miliani
 288+ 1310 68 2B                defw    INKEY       ; added by Leonardo Miliani
 289+ 1312 8E 36                defw    POINT       ; added by Leonardo Miliani
 290+ 1314 2E 27                defw    INSTR       ; added by Leonardo Miliani
 291+ 1316 CE 26                defw    LEN
 292+ 1318 E6 24                defw    STR
 293+ 131A 5E 28                defw    VAL
 294+ 131C DD 26                defw    ASC
 295+ 131E EE 26                defw    CHR
 296+ 1320 7D 3E                defw    HEX         ; added by Grant Searle
 297+ 1322 0E 3F                defw    BIN         ; added by Grant Searle
 298+ 1324 FE 26                defw    LEFT
 299+ 1326 24 28                defw    RIGHT
 300+ 1328 2E 28                defw    MID
 301+ 132A
 302+ 132A              ; RESERVED WORD LIST
 303+ 132A              ; Here are all the reserved words used by the interpreter
 304+ 132A              ; To add custom functions/commands, the user must insert the keyword
 305+ 132A              ; in this list, following the schematic
 306+ 132A C5 4E 44     WORDS:  defb    'E'+$80,"ND"            ; from here the list contains the COMMANDS
 307+ 132D C6 4F 52             defb    'F'+$80,"OR"
 308+ 1330 CE 45 58 54          defb    'N'+$80,"EXT"
 309+ 1334 C4 41 54 41          defb    'D'+$80,"ATA"
 310+ 1338 C9 4E 50 55          defb    'I'+$80,"NPUT"
 310+ 133C 54
 311+ 133D C4 49 4D             defb    'D'+$80,"IM"
 312+ 1340 D2 45 41 44          defb    'R'+$80,"EAD"
 313+ 1344 CC 45 54             defb    'L'+$80,"ET"
 314+ 1347 C7 4F 54 4F          defb    'G'+$80,"OTO"
 315+ 134B D2 55 4E             defb    'R'+$80,"UN"
 316+ 134E C9 46                defb    'I'+$80,"F"
 317+ 1350 D2 45 53 54          defb    'R'+$80,"ESTORE"
 317+ 1354 4F 52 45
 318+ 1357 C7 4F 53 55          defb    'G'+$80,"OSUB"
 318+ 135B 42
 319+ 135C D2 45 54 55          defb    'R'+$80,"ETURN"
 319+ 1360 52 4E
 320+ 1362 D2 45 4D             defb    'R'+$80,"EM"            ; original REM
 321+ 1365 D3 54 4F 50          defb    'S'+$80,"TOP"
 322+ 1369 CF 55 54             defb    'O'+$80,"UT"
 323+ 136C CF 4E                defb    'O'+$80,"N"
 324+ 136E C6 49 4C 45          defb    'F'+$80,"ILES"
 324+ 1372 53
 325+ 1373 C5 52 41 53          defb    'E'+$80,"RASE"          ; added by Leonardo Miliani
 325+ 1377 45
 326+ 1378 D7 41 49 54          defb    'W'+$80,"AIT"
 327+ 137C C4 45 46             defb    'D'+$80,"EF"
 328+ 137F D0 4F 4B 45          defb    'P'+$80,"OKE"
 329+ 1383 C4 4F 4B 45          defb    'D'+$80,"OKE"
 330+ 1387 D6 50 4F 4B          defb    'V'+$80,"POKE"          ; added by Leonardo Miliani
 330+ 138B 45
 331+ 138C D3 52 45 47          defb    'S'+$80,"REG"           ; added by Leonardo Miliani
 332+ 1390 D6 52 45 47          defb    'V'+$80,"REG"           ; added by Leonardo Miliani
 333+ 1394 D3 43 52 45          defb    'S'+$80,"CREEN"         ; changed by Leonardo Miliani
 333+ 1398 45 4E
 334+ 139A CC 4F 43 41          defb    'L'+$80,"OCATE"         ; added by Leonardo Miliani
 334+ 139E 54 45
 335+ 13A0 D3 4F 55 4E          defb    'S'+$80,"OUND"          ; added by Leonardo Miliani
 335+ 13A4 44
 336+ 13A5 D6 4F 4C 55          defb    'V'+$80,"OLUME"         ; added by Leonardo Miliani
 336+ 13A9 4D 45
 337+ 13AB D0 41 55 53          defb    'P'+$80,"AUSE"          ; added by Leonardo Miliani
 337+ 13AF 45
 338+ 13B0 C3 4F 4C 4F          defb    'C'+$80,"OLOR"          ; added by Leonardo Miliani
 338+ 13B4 52
 339+ 13B5 D0 4C 4F 54          defb    'P'+$80,"LOT"           ; added by Leonardo Miliani
 340+ 13B9 C4 52 41 57          defb    'D'+$80,"RAW"           ; added by Leonardo Miliani
 341+ 13BD C3 49 52 43          defb    'C'+$80,"IRCLE"         ; added by Leonardo Miliani
 341+ 13C1 4C 45
 342+ 13C3 D0 41 49 4E          defb    'P'+$80,"AINT"          ; added by Leonardo Miliani
 342+ 13C7 54
 343+ 13C8 D3 45 52 49          defb    'S'+$80,"ERIAL"         ; added by Leonardo Miliani
 343+ 13CC 41 4C
 344+ 13CE C8 45 4C 50          defb    'H'+$80,"ELP"           ; changed by Leonardo Miliani - was LINES
 345+ 13D2 C3 4C 53             defb    'C'+$80,"LS"            ; restored command
 346+ 13D5 CB 45 59             defb    'K'+$80,"EY"            ; added by Leonardo Miliani
 347+ 13D8 CE 4D 49             defb    'N'+$80,"MI"            ; added by Leonardo Miliani
 348+ 13DB C7 50 52 49          defb    'G'+$80,"PRINT"         ; added by Leonardo Miliani
 348+ 13DF 4E 54
 349+ 13E1 D7 49 44 54          defb    'W'+$80,"IDTH"
 349+ 13E5 48
 350+ 13E6 D3 59 53             defb    'S'+$80,"YS"            ; added by Leonardo Miliani
 351+ 13E9 D2 45 53 45          defb    'R'+$80,"ESET"          ; changed by Leonardo Miliani
 351+ 13ED 54
 352+ 13EE C5 4C 53 45          defb    'E'+$80,"LSE"           ; added by Leonardo Miliani
 353+ 13F2 D0 52 49 4E          defb    'P'+$80,"RINT"
 353+ 13F6 54
 354+ 13F7 C3 4F 4E 54          defb    'C'+$80,"ONT"
 355+ 13FB CC 49 53 54          defb    'L'+$80,"IST"
 356+ 13FF C3 4C 45 41          defb    'C'+$80,"LEAR"
 356+ 1403 52
 357+ 1404 CC 4F 41 44          defb    'L'+$80,"OAD"
 358+ 1408 D3 41 56 45          defb    'S'+$80,"AVE"
 359+ 140C CE 45 57             defb    'N'+$80,"EW"
 360+ 140F D4 41 42 28          defb    'T'+$80,"AB("
 361+ 1413 D4 4F                defb    'T'+$80,"O"
 362+ 1415 C6 4E                defb    'F'+$80,"N"
 363+ 1417 D3 50 43 28          defb    'S'+$80,"PC("
 364+ 141B D4 48 45 4E          defb    'T'+$80,"HEN"
 365+ 141F CE 4F 54             defb    'N'+$80,"OT"
 366+ 1422 D3 54 45 50          defb    'S'+$80,"TEP"
 367+ 1426                      ; from here: operators
 368+ 1426 AB                   defb    '+'+$80
 369+ 1427 AD                   defb    '-'+$80
 370+ 1428 AA                   defb    '*'+$80
 371+ 1429 AF                   defb    '/'+$80
 372+ 142A A5                   defb    '%'+$80
 373+ 142B A3                   defb    '#'+$80
 374+ 142C DE                   defb    '^'+$80
 375+ 142D C1 4E 44             defb    'A'+$80,"ND"
 376+ 1430 D8 4F 52             defb    'X'+$80,"OR"
 377+ 1433 CF 52                defb    'O'+$80,"R"
 378+ 1435 BE                   defb    '>'+$80
 379+ 1436 BD                   defb    '='+$80
 380+ 1437 BC                   defb    '<'+$80
 381+ 1438
 382+ 1438                      ; from here there are the tokens' FUNCTIONS list
 383+ 1438                      ; this list must be coherent with the functions list above
 384+ 1438 D3 47 4E             defb    'S'+$80,"GN"
 385+ 143B D4 4D 52             defb    'T'+$80,"MR"            ; added by Leonardo Miliani
 386+ 143E C9 4E 54             defb    'I'+$80,"NT"
 387+ 1441 C1 42 53             defb    'A'+$80,"BS"
 388+ 1444 D5 53 52             defb    'U'+$80,"SR"
 389+ 1447 C6 52 45             defb    'F'+$80,"RE"
 390+ 144A C9 4E 50             defb    'I'+$80,"NP"
 391+ 144D D0 4F 53             defb    'P'+$80,"OS"
 392+ 1450 D3 51 52             defb    'S'+$80,"QR"
 393+ 1453 D2 4E 44             defb    'R'+$80,"ND"
 394+ 1456 CC 4F 47             defb    'L'+$80,"OG"
 395+ 1459 C5 58 50             defb    'E'+$80,"XP"
 396+ 145C C3 4F 53             defb    'C'+$80,"OS"
 397+ 145F D3 49 4E             defb    'S'+$80,"IN"
 398+ 1462 D4 41 4E             defb    'T'+$80,"AN"
 399+ 1465 C1 54 4E             defb    'A'+$80,"TN"
 400+ 1468 D0 45 45 4B          defb    'P'+$80,"EEK"
 401+ 146C C4 45 45 4B          defb    'D'+$80,"EEK"
 402+ 1470 D6 50 45 45          defb    'V'+$80,"PEEK"          ; added by Leonardo Miliani
 402+ 1474 4B
 403+ 1475 D6 53 54 41          defb    'V'+$80,"STAT"          ; added by Leonardo Miliani
 403+ 1479 54
 404+ 147A D3 53 54 41          defb    'S'+$80,"STAT"          ; added by Leonardo Miliani
 404+ 147E 54
 405+ 147F C9 4E 4B 45          defb    'I'+$80,"NKEY"          ; added by Leonardo Miliani
 405+ 1483 59
 406+ 1484 D0 4F 49 4E          defb    'P'+$80,"OINT"          ; added by Leonardo Miliani
 406+ 1488 54
 407+ 1489 C9 4E 53 54          defb    'I'+$80,"NSTR"          ; added by Leonardo Miliani
 407+ 148D 52
 408+ 148E CC 45 4E             defb    'L'+$80,"EN"
 409+ 1491 D3 54 52 24          defb    'S'+$80,"TR$"
 410+ 1495 D6 41 4C             defb    'V'+$80,"AL"
 411+ 1498 C1 53 43             defb    'A'+$80,"SC"
 412+ 149B C3 48 52 24          defb    'C'+$80,"HR$"
 413+ 149F C8 45 58 24          defb    'H'+$80,"EX$"           ; added by Grant Searle
 414+ 14A3 C2 49 4E 24          defb    'B'+$80,"IN$"           ; added by Grant Searle
 415+ 14A7 CC 45 46 54          defb    'L'+$80,"EFT$"
 415+ 14AB 24
 416+ 14AC D2 49 47 48          defb    'R'+$80,"IGHT$"
 416+ 14B0 54 24
 417+ 14B2 CD 49 44 24          defb    'M'+$80,"ID$"
 418+ 14B6 80                   defb    $80                     ; End-of-list marker
 419+ 14B7
 420+ 14B7              ; KEYWORD ADDRESS TABLE
 421+ 14B7              ; this list must be coherent with the commands'
 422+ 14B7              ; tokens list above
 423+ 14B7 15 1C        WORDTB: defw    PEND
 424+ 14B9 12 1B                defw    FOR
 425+ 14BB 09 20                defw    NEXT
 426+ 14BD 74 1D                defw    DATA
 427+ 14BF 0E 1F                defw    INPUT
 428+ 14C1 5E 22                defw    DIM
 429+ 14C3 40 1F                defw    READ
 430+ 14C5 8B 1D                defw    LET
 431+ 14C7 31 1D                defw    GOTO
 432+ 14C9 0C 1D                defw    RUN
 433+ 14CB 03 1E                defw    IF
 434+ 14CD DB 1B                defw    RESTOR
 435+ 14CF 20 1D                defw    GOSUB
 436+ 14D1 4F 1D                defw    RETURN
 437+ 14D3 76 1D                defw    REM         ; original REM
 438+ 14D5 13 1C                defw    STOP
 439+ 14D7 A3 28                defw    POUT
 440+ 14D9 E5 1D                defw    ON
 441+ 14DB 7B 3E                defw    FILES       ; changed by Leonardo Miliani - was NULL
 442+ 14DD 7C 3E                defw    ERASE       ; added by Leonardo Miliani
 443+ 14DF A9 28                defw    WAIT
 444+ 14E1 52 24                defw    DEF
 445+ 14E3 9D 29                defw    POKE
 446+ 14E5 40 33                defw    DOKE
 447+ 14E7 A2 29                defw    VPOKE       ; added by Leonardo Miliani
 448+ 14E9 DF 29                defw    SREG        ; added by Leonardo Miliani
 449+ 14EB 2D 2B                defw    VREG        ; added by Leonardo Miliani
 450+ 14ED 76 33                defw    SCREEN      ; new behaviour: now it sets up a graphics mode (Leonardo Miliani)
 451+ 14EF AD 29                defw    LOCATE      ; added by Leonardo Miliani
 452+ 14F1 39 2A                defw    SOUND       ; added by Leonardo Miliani
 453+ 14F3 00 2A                defw    VOLUME      ; added by Leonardo Miliani
 454+ 14F5 57 33                defw    PAUSE       ; added by Leonardo Miliani
 455+ 14F7 F1 33                defw    COLOR       ; added by Leonardo Miliani
 456+ 14F9 E1 36                defw    PLOT        ; added by Leonardo Miliani
 457+ 14FB 74 37                defw    DRAW        ; added by Leonardo Miliani
 458+ 14FD AA 38                defw    CIRCLE      ; added by Leonardo Miliani
 459+ 14FF 9E 35                defw    PAINT       ; added by Leonardo Miliani
 460+ 1501 AF 3A                defw    SERIAL      ; added by Leonardo Miliani
 461+ 1503 F1 3C                defw    HELP        ; changed by Leonardo Miliani - was LINES
 462+ 1505 19 33                defw    CLS
 463+ 1507 0C 3D                defw    KEY         ; added by Leonardo Miliani
 464+ 1509 EB 28                defw    NMI         ; added by Leonardo Miliani
 465+ 150B AD 34                defw    GPRINT      ; added by Leonardo Miliani
 466+ 150D 2D 33                defw    WIDTH
 467+ 150F 45 29                defw    SYS         ; added by Leonardo Miliani
 468+ 1511 73 3F                defw    RESET       ; new behaviour: now it resets the system
 469+ 1513 78 1D                defw    REM+2       ; ELSE: added by Leonardo Miliani
 470+ 1515 35 1E                defw    PRINT
 471+ 1517 47 1C                defw    CONT
 472+ 1519 E9 19                defw    LIST
 473+ 151B C0 1C                defw    CLEAR
 474+ 151D 79 3E                defw    LOAD        ; re-implemented by Leonardo Miliani (was CLOAD)
 475+ 151F 7A 3E                defw    SAVE        ; re-implemented by Leonardo Miliani (was CSAVE)
 476+ 1521 CE 17                defw    NEW
 477+ 1523
 478+ 1523              ; RESERVED WORD TOKEN VALUES
 479+ 1523              ; if you add a function or command you must increment by 1
 480+ 1523              ; the values below. Pay attention that you must increment only the
 481+ 1523              ; values AFTER the position where you entered the function/command word
 482+ 1523              ; in the "Reserver word list" above. I.E.: VPOKE has been added between
 483+ 1523              ; DOKE and SCREEN, and since REM is the reserved work listed below
 484+ 1523              ; that is before the point where VPOKE has been entered, every entry
 485+ 1523              ; after REM has been incremented.
 486+ 1523              ; Another example: when TMR has been added, since it's a function, every
 487+ 1523              ; entry after & included ZSGN must be checked (read below)
 488+ 1523
 489+ 1523              ZEND    equ     $80             ; END        <-- from here, there are the commands
 490+ 1523              ZFOR    equ     $81             ; FOR
 491+ 1523              ZDATA   equ     $83             ; DATA
 492+ 1523              ZGOTO   equ     $88             ; GOTO
 493+ 1523              ZGOSUB  equ     $8C             ; GOSUB
 494+ 1523              ZREM    equ     $8E             ; REM
 495+ 1523              ZELSE   equ     $AE             ; ELSE
 496+ 1523              ZPRINT  equ     $AF             ; PRINT
 497+ 1523              ZNEW    equ     $B5             ; NEW
 498+ 1523
 499+ 1523              ZTAB    equ     $B6             ; TAB
 500+ 1523              ZTO     equ     $B7             ; TO
 501+ 1523              ZFN     equ     $B8             ; FN
 502+ 1523              ZSPC    equ     $B9             ; SPC
 503+ 1523              ZTHEN   equ     $BA             ; THEN
 504+ 1523              ZNOT    equ     $BB             ; NOT
 505+ 1523              ZSTEP   equ     $BC             ; STEP
 506+ 1523
 507+ 1523              ZPLUS   equ     $BD             ; +         <-- from here, there are the math operators
 508+ 1523              ZMINUS  equ     $BE             ; -
 509+ 1523              ZTIMES  equ     $BF             ; *
 510+ 1523              ZDIV    equ     $C0             ; /
 511+ 1523              ZMOD    equ     $C1             ; %
 512+ 1523              ZDINT   equ     $C2             ; #
 513+ 1523              ZOR     equ     $C6             ; OR
 514+ 1523              ZGTR    equ     $C7             ; >
 515+ 1523              ZEQUAL  equ     $C8             ; M
 516+ 1523              ZLTH    equ     $C9             ; <
 517+ 1523
 518+ 1523              ZSGN    equ     $CA             ; SGN       <-- from here, there are the functions
 519+ 1523              ZPOINT  equ     $E0             ; ZPOINT    <-- if the user enters a custom function, between
 520+ 1523                                              ;               SGN and POINT, he/she must increment this pointer by 1
 521+ 1523              ZINSTR  equ     $E1             ; ZINSTR    <-- same here
 522+ 1523              ZLEFT   equ     $E9             ; LEFT$     <-- if the user enters a custom function anywhere,
 523+ 1523                                              ;               he/she must increment this pointer by 1
 524+ 1523
 525+ 1523              ; ARITHMETIC PRECEDENCE TABLE
 526+ 1523              ; in the formulas below, <last> is a number stored into the stack that must be retrieved
 527+ 1523              ; with POP BC, POP DE; FPREG is a f.p. number store into the RAM register FPREG
 528+ 1523 79           PRITAB: defb    $79             ; Precedence value
 529+ 1524 E2 2F                defw    PADD            ; FPREG = <last> + FPREG
 530+ 1526
 531+ 1526 79                   defb    $79             ; Precedence value
 532+ 1527 C5 2B                defw    PSUB            ; FPREG = <last> - FPREG
 533+ 1529
 534+ 1529 7C                   defb    $7C             ; Precedence value
 535+ 152A 03 2D                defw    MULT            ; PPREG = <last> * FPREG
 536+ 152C
 537+ 152C 7C                   defb    $7C             ; Precedence value
 538+ 152D B5 2D                defw    DIV             ; FPREG = <last> / FPREG
 539+ 152F
 540+ 152F 7C                   defb    $7C             ; Precedence value
 541+ 1530 60 2D                defw    MOD             ; FPREG = INT(<last>)-(INT(FPREG)*INT(<last>/FPREG))
 542+ 1532
 543+ 1532 7C                   defb    $7C             ; precedence value
 544+ 1533 58 2D                defw    DINT            ; FPREG = INT(<last> / FPREG )
 545+ 1535
 546+ 1535 7F                   defb    $7F             ; Precedence value
 547+ 1536 03 31                defw    POWER           ; FPREG = <last> ^ FPREG
 548+ 1538
 549+ 1538 50                   defb    $50             ; Precedence value
 550+ 1539 A7 21                defw    PAND            ; FPREG = <last> AND FPREG
 551+ 153B
 552+ 153B 4A                   defb    $4A             ; Precedence value
 553+ 153C AF 21                defw    PXOR            ; FPREG = <last> XOR FPREG
 554+ 153E
 555+ 153E 46                   defb    $46             ; Precedence value
 556+ 153F AA 21                defw    POR             ; FPREG = <last> OR FPREG
 557+ 1541
 558+ 1541
 559+ 1541              ; INITIALISATION TABLE -------------------------------------------------------
 560+ 1541              ; these values are copied into RAM at startup
 561+ 1541 C3 74 12     INITAB: jp      WARMST          ; Warm start jump
 562+ 1544 ED 45 00             defb    $ED,$45,$00     ; RETN + NOP for default NMI service routine
 563+ 1547 C3 96 1C             jp      FCERR           ; "USR (X)" jump (Set to Error)
 564+ 154A D3 00                out     (0),A           ; "out p,n" skeleton
 565+ 154C C9                   ret
 566+ 154D D6 00                sub     $00             ; Division support routine
 567+ 154F 6F                   ld      L,A
 568+ 1550 7C                   ld      A,H
 569+ 1551 DE 00                sbc     A,$00
 570+ 1553 67                   ld      H,A
 571+ 1554 78                   ld      A,B
 572+ 1555 DE 00                sbc     A,$00
 573+ 1557 47                   ld      B,A
 574+ 1558 3E 00                ld      A,$00
 575+ 155A C9                   ret
 576+ 155B 00 00 00             defb    $00,$00,$00     ; Random number seed table used by RND
 577+ 155E 35 4A CA 99          defb    $35,$4A,$CA,$99 ;-2.65145E+07
 578+ 1562 39 1C 76 98          defb    $39,$1C,$76,$98 ; 1.61291E+07
 579+ 1566 22 95 B3 98          defb    $22,$95,$B3,$98 ;-1.17691E+07
 580+ 156A 0A DD 47 98          defb    $0A,$DD,$47,$98 ; 1.30983E+07
 581+ 156E 53 D1 99 99          defb    $53,$D1,$99,$99 ;-2-01612E+07
 582+ 1572 0A 1A 9F 98          defb    $0A,$1A,$9F,$98 ;-1.04269E+07
 583+ 1576 65 BC CD 98          defb    $65,$BC,$CD,$98 ;-1.34831E+07
 584+ 157A D6 77 3E 98          defb    $D6,$77,$3E,$98 ; 1.24825E+07
 585+ 157E 52 C7 4F 80          defb    $52,$C7,$4F,$80 ; Last random number
 586+ 1582 DB 00                in      A,($00)         ; INP (x) skeleton
 587+ 1584 C9                   ret
 588+ 1585 FF                   defb    $FF             ; Terminal width (255 = no auto CRLF)
 589+ 1586 14                   defb    $14             ; Width for commas (at reset, 3 columns, for G1 mode)
 590+ 1587 00                   defb    $00             ; No nulls after input bytes
 591+ 1588 00                   defb    $00             ; Output enabled (^O off)
 592+ 1589 00 00                defw    $00             ; Array load/save check sum
 593+ 158B 00                   defb    $00             ; Break not by NMI
 594+ 158C 00                   defb    $00             ; Break flag
 595+ 158D C3 0A 19             jp      TTYLIN          ; Input reflection (set to TTY)
 596+ 1590 A9 53                defw    STLOOK          ; Temp string space
 597+ 1592 FE FF                defw    -2              ; Current line number (cold)
 598+ 1594 FF FF                defw    -1              ; Current line with errors (no errors)
 599+ 1596 40           AUTORP: defb    $40             ; delay for key auto-repeat start
 600+ 1597 08                   defb    $08             ; auto-repeat delay
 601+ 1598 4C 49 53 54  DEFFNKS:defm    "LIST",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 1
 601+ 159C 0D 00 00 00
 601+ 15A0 00 00 00 00
 601+ 15A4 00 00 00 00
 602+ 15A8 52 55 4E 0D          defm    "RUN",13,0,0,0,0,0,0,0,0,0,0,0,0    ; KEY 2
 602+ 15AC 00 00 00 00
 602+ 15B0 00 00 00 00
 602+ 15B4 00 00 00 00
 603+ 15B8 53 43 52 45          defm    "SCREEN1",13,0,0,0,0,0,0,0,0        ; KEY 3
 603+ 15BC 45 4E 31 0D
 603+ 15C0 00 00 00 00
 603+ 15C4 00 00 00 00
 604+ 15C8 43 4F 4C 4F          defm    "COLOR1,15,5",13,0,0,0,0            ; KEY 4
 604+ 15CC 52 31 2C 31
 604+ 15D0 35 2C 35 0D
 604+ 15D4 00 00 00 00
 605+ 15D8 53 45 52 49          defm    "SERIAL1,38400",13,0,0              ; KEY 5
 605+ 15DC 41 4C 31 2C
 605+ 15E0 33 38 34 30
 605+ 15E4 30 0D 00 00
 606+ 15E8 53 43 52 45          defm    "SCREEN2",13,0,0,0,0,0,0,0,0        ; KEY 6
 606+ 15EC 45 4E 32 0D
 606+ 15F0 00 00 00 00
 606+ 15F4 00 00 00 00
 607+ 15F8 43 4F 4E 54          defm    "CONT",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 7
 607+ 15FC 0D 00 00 00
 607+ 1600 00 00 00 00
 607+ 1604 00 00 00 00
 608+ 1608 48 45 4C 50          defm    "HELP",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 8 (HELP KEY)
 608+ 160C 0D 00 00 00
 608+ 1610 00 00 00 00
 608+ 1614 00 00 00 00
 609+ 1618 46 53                defw    PROGST+1        ; Start of program text
 610+ 161A              INITBE:
 611+ 161A
 612+ 161A              ; END OF INITIALISATION TABLE ---------------------------------------------------
 613+ 161A
 614+ 161A 20 45 72 72  ERRMSG: defb    " Error",0
 614+ 161E 6F 72 00
 615+ 1621 20 69 6E 20  INMSG:  defb    " in ",0
 615+ 1625 00
 616+ 1626              ZERBYT  equ     $-1             ; A zero byte
 617+ 1626 4F 6B 0D 00  OKMSG:  defb    "Ok",CR,0,0
 617+ 162A 00
 618+ 162B 42 72 65 61  BRKMSG: defb    "Break",0
 618+ 162F 6B 00
 619+ 1631
 620+ 1631 21 04 00     BAKSTK: ld      HL,$04          ; Look for "FOR" block with
 621+ 1634 39                   add     HL,SP           ; same index as specified
 622+ 1635 7E           LOKFOR: ld      A,(HL)          ; Get block ID
 623+ 1636 23                   inc     HL              ; Point to index address
 624+ 1637 FE 81                cp      ZFOR            ; Is it a "FOR" token
 625+ 1639 C0                   ret     NZ              ; No - exit
 626+ 163A 4E                   ld      C,(HL)          ; BC = Address of "FOR" index
 627+ 163B 23                   inc     HL
 628+ 163C 46                   ld      B,(HL)
 629+ 163D 23                   inc     HL              ; Point to sign of STEP
 630+ 163E E5                   push    HL              ; Save pointer to sign
 631+ 163F 69                   ld      L,C             ; HL = address of "FOR" index
 632+ 1640 60                   ld      H,B
 633+ 1641 7A                   ld      A,D             ; See if an index was specified
 634+ 1642 B3                   or      E               ; DE = 0 if no index specified
 635+ 1643 EB                   ex      DE,HL           ; Specified index into HL
 636+ 1644 CA 4B 16             jp      Z,INDFND        ; Skip if no index given
 637+ 1647 EB                   ex      DE,HL           ; Index back into DE
 638+ 1648 CD 84 19             call    CPDEHL          ; Compare index with one given
 639+ 164B 01 0D 00     INDFND: ld      BC,16-3         ; Offset to next block
 640+ 164E E1                   pop     HL              ; Restore pointer to sign
 641+ 164F C8                   ret     Z               ; Return if block found
 642+ 1650 09                   add     HL,BC           ; Point to next block
 643+ 1651 C3 35 16             jp      LOKFOR          ; Keep on looking
 644+ 1654
 645+ 1654 CD 6E 16     MOVUP:  call    ENFMEM          ; See if enough memory
 646+ 1657 C5           MOVSTR: push    BC              ; Save end of source
 647+ 1658 E3                   ex      (SP),HL         ; Swap source and dest" end
 648+ 1659 C1                   pop     BC              ; Get end of destination
 649+ 165A CD 84 19     MOVLP:  call    CPDEHL          ; See if list moved
 650+ 165D 7E                   ld      A,(HL)          ; Get byte
 651+ 165E 02                   ld      (BC),A          ; Move it
 652+ 165F C8                   ret     Z               ; Exit if all done
 653+ 1660 0B                   dec     BC              ; Next byte to move to
 654+ 1661 2B                   dec     HL              ; Next byte to move
 655+ 1662 C3 5A 16             jp      MOVLP           ; Loop until all bytes moved
 656+ 1665
 657+ 1665 E5           CHKSTK: push    HL              ; Save code string address
 658+ 1666 2A 26 53             ld      HL,(ARREND)     ; Lowest free memory
 659+ 1669 06 00                ld      B,$00           ; BC = Number of levels to test
 660+ 166B 09                   add     HL,BC           ; 2 Bytes for each level
 661+ 166C 09                   add     HL,BC
 662+ 166D 3E                   defb    $3E             ; Skip "push HL"
 663+ 166E E5           ENFMEM: push    HL              ; Save code string address
 664+ 166F 3E D0                ld      A,$D0           ; LOW -48 ; 48 Bytes minimum RAM
 665+ 1671 95                   sub     L
 666+ 1672 6F                   ld      L,A
 667+ 1673 3E FF                ld      A,$FF           ; HIGH (-48) ; 48 Bytes minimum RAM
 668+ 1675 9C                   sbc     A,H
 669+ 1676 DA 7D 16             jp      C,OMERR         ; Not enough - ?OM Error
 670+ 1679 67                   ld      H,A
 671+ 167A 39                   add     HL,SP           ; Test if stack is overflowed
 672+ 167B E1                   pop     HL              ; Restore code string address
 673+ 167C D8                   ret     C               ; Return if enough memory
 674+ 167D 1E 0C        OMERR:  ld      E,OM            ; ?OM Error
 675+ 167F C3 BC 16             jp      ERROR
 676+ 1682
 677+ 1682
 678+ 1682              ; if in graphics mode, return to text (called by "NOLIN" and "ERROR")
 679+ 1682 F5           EXITGM: push    AF              ; store AF
 680+ 1683 3A CD 52             ld      A,(SCR_MODE)    ; check screen mode
 681+ 1686 FE 02                cp      $02             ; G2?
 682+ 1688 CA 8F 16             jp      Z,LDG1          ; yes, back to G1
 683+ 168B FE 03                cp      $03             ; G3?
 684+ 168D 20 11                jr      NZ,LDG1ND       ; no, so return
 685+ 168F E5           LDG1:   push    HL              ; store HL
 686+ 1690 D5                   push    DE              ; store DE
 687+ 1691 11 01 00             ld      DE,$0001        ; sprites set to defaults, G1 mode
 688+ 1694 F3                   di                      ; disable INTs
 689+ 1695 CD D3 03             call    initVDP         ; initialize VDP with mode pointed by E
 690+ 1698 FB                   ei                      ; re-enable INTs
 691+ 1699 3E 01                ld      A,$01           ; activate the...
 692+ 169B 32 D8 52             ld      (PRNTVIDEO),A   ; ...video buffer...
 693+ 169E D1                   pop     DE              ; retrieve DE
 694+ 169F E1                   pop     HL              ; retrieve HL
 695+ 16A0 F1           LDG1ND: pop     AF              ; retrieve AF
 696+ 16A1 C9                   ret                     ; return to caller
 697+ 16A2
 698+ 16A2
 699+ 16A2 2A AE 52     DATSNR: ld      HL,(DATLIN)     ; Get line of current DATA item
 700+ 16A5 22 AD 51             ld      (LINEAT),HL     ; Save as current line
 701+ 16A8 1E 02        SNERR:  ld      E,SN            ; ?SN Error
 702+ 16AA 01                   defb    $01             ; Skip "ld E,DZ"
 703+ 16AB 1E 14        DZERR:  ld      E,DZ            ; ?/0 Error
 704+ 16AD 01                   defb    $01             ; Skip "ld E,NF"
 705+ 16AE 1E 00        NFERR:  ld      E,NF            ; ?NF Error
 706+ 16B0 01                   defb    $01             ; Skip "ld E,DD"
 707+ 16B1 1E 12        DDERR:  ld      E,DD            ; ?DD Error
 708+ 16B3 01                   defb    $01             ; Skip "ld E,UF"
 709+ 16B4 1E 22        UFERR:  ld      E,UF            ; ?UF Error
 710+ 16B6 01                   defb    $01             ; Skip "ld E,OV
 711+ 16B7 1E 0A        OVERR:  ld      E,OV            ; ?OV Error
 712+ 16B9 01                   defb    $01             ; Skip "ld E,TM"
 713+ 16BA 1E 18        TMERR:  ld      E,TM            ; ?TM Error
 714+ 16BC
 715+ 16BC CD F4 17     ERROR:  call    CLREG           ; Clear registers and stack
 716+ 16BF CD 82 16             call    EXITGM          ; exit from graphic modes
 717+ 16C2 32 A3 51             ld      (CTLOFG),A      ; Enable output (A is 0)
 718+ 16C5 CD F2 08             call    CURSOR_ON       ; enable cursor
 719+ 16C8 CD 86 1E             call    STTLIN          ; Start new line
 720+ 16CB 21 DC 0F             ld      HL,ERRTBL       ; Point to error codes
 721+ 16CE 57                   ld      D,A             ; D = 0 (A is 0)
 722+ 16CF 3E 3F                ld      A,'?'
 723+ 16D1 CD 95 19             call    OUTC            ; Output '?'
 724+ 16D4 19                   add     HL,DE           ; Offset to correct error code
 725+ 16D5 5E                   ld      E,(HL)          ; load pointer to error message
 726+ 16D6 23                   inc     HL              ; by loading LSB,
 727+ 16D7 56                   ld      D,(HL)          ; then MSB
 728+ 16D8 62 6B                ld      HL,DE           ; load pointer to HL
 729+ 16DA CD 5C 25             call    PRS             ; Output error message
 730+ 16DD 21 1A 16             ld      HL,ERRMSG       ; "Error" message
 731+ 16E0 CD 5C 25     ERRIN:  call    PRS             ; Output message
 732+ 16E3 2A AD 51             ld      HL,(LINEAT)     ; Get line of error
 733+ 16E6 11 FE FF             ld      DE,-2           ; Cold start error if -2
 734+ 16E9 CD 84 19             call    CPDEHL          ; See if cold start error
 735+ 16EC CA CD 11             jp      Z,CSTART        ; Cold start error - Restart
 736+ 16EF 7C                   ld      A,H             ; Was it a direct error?
 737+ 16F0 A5                   and     L               ; Line = -1 if direct error
 738+ 16F1 3C                   inc     A
 739+ 16F2 CA FD 16             jp      Z,PTLN          ; Yes, jump over
 740+ 16F5 E5                   push    HL              ; indirect mode - store HL
 741+ 16F6 2A AD 51             ld      HL,(LINEAT)     ; copy current line number
 742+ 16F9 22 AF 51             ld      (HLPLN),HL      ; save in HELP line register
 743+ 16FC E1                   pop     HL              ; retrieve HL
 744+ 16FD C4 F3 2F     PTLN:   call    NZ,LINEIN       ; No - output line of error
 745+ 1700
 746+ 1700 3E                   defb    $3E             ; Skip "pop BC"
 747+ 1701 C1           POPNOK: pop     BC              ; Drop address in input buffer
 748+ 1702
 749+ 1702              ; run into direct mode: print OK and get command
 750+ 1702 AF           PRNTOK: xor     A               ; Output "Ok" and get command
 751+ 1703 32 A3 51             ld      (CTLOFG),A      ; Enable output
 752+ 1706 CD 86 1E             call    STTLIN          ; Start new line
 753+ 1709 21 26 16             ld      HL,OKMSG        ; "Ok" message
 754+ 170C CD 5C 25             call    PRS             ; Output "Ok"
 755+ 170F CD F2 08     GETCMD: call    CURSOR_ON       ; enable cursor
 756+ 1712 21 FF FF             ld      HL,-1           ; Flag direct mode
 757+ 1715 22 AD 51             ld      (LINEAT),HL     ; Save as current line
 758+ 1718 CD 0A 19             call    GETLIN          ; Get an input line
 759+ 171B DA 0F 17             jp      C,GETCMD        ; Get line again if break
 760+ 171E CD CB 1B             call    GETCHR          ; Get first character
 761+ 1721 17                   rla                     ; 8th bit is copied into carry and original carry is copied into bit 0)
 762+ 1722 DA A8 16             jp      C,SNERR         ; if char >=128 (8th bit set) then raise an error
 763+ 1725 1F                   rra                     ; recover original char and Carry
 764+ 1726 3C                   inc     A               ; Test if end of line
 765+ 1727 3D                   dec     A               ; Without affecting Carry
 766+ 1728 CA 0F 17             jp      Z,GETCMD        ; Nothing entered - Get another
 767+ 172B F5                   push    AF              ; Save Carry status
 768+ 172C CD 07 09             call    CURSOR_OFF      ; cursor disabled
 769+ 172F CD 9B 1C             call    ATOH            ; Get line number into DE
 770+ 1732 D5                   push    DE              ; Save line number
 771+ 1733 CD 21 18             call    CRUNCH          ; Tokenise rest of line
 772+ 1736 47                   ld      B,A             ; Length of tokenised line
 773+ 1737 D1                   pop     DE              ; Restore line number
 774+ 1738 F1                   pop     AF              ; Restore Carry
 775+ 1739 D2 AB 1B             jp      NC,EXCUTE       ; No line number - Direct mode
 776+ 173C D5                   push    DE              ; Save line number
 777+ 173D C5                   push    BC              ; Save length of tokenised line
 778+ 173E AF                   xor     A
 779+ 173F 32 B1 52             ld      (LSTBIN),A      ; Clear last byte input
 780+ 1742 CD CB 1B             call    GETCHR          ; Get next character
 781+ 1745 B7                   or      A               ; Set flags
 782+ 1746 F5                   push    AF              ; And save them
 783+ 1747 CD AE 17             call    SRCHLN          ; Search for line number in DE
 784+ 174A DA 53 17             jp      C,LINFND        ; Jump if line found
 785+ 174D F1                   pop     AF              ; Get status
 786+ 174E F5                   push    AF              ; And re-save
 787+ 174F CA 4A 1D             jp      Z,ULERR         ; Nothing after number - Error
 788+ 1752 B7                   or      A               ; Clear Carry
 789+ 1753 C5           LINFND: push    BC              ; Save address of line in prog
 790+ 1754 D2 6A 17             jp      NC,INEWLN       ; Line not found - Insert new
 791+ 1757 EB                   ex      DE,HL           ; Next line address in DE
 792+ 1758 2A 22 53             ld      HL,(PROGND)     ; End of program
 793+ 175B 1A           SFTPRG: ld      A,(DE)          ; Shift rest of program down
 794+ 175C 02                   ld      (BC),A
 795+ 175D 03                   inc     BC              ; Next destination
 796+ 175E 13                   inc     DE              ; Next source
 797+ 175F CD 84 19             call    CPDEHL          ; All done?
 798+ 1762 C2 5B 17             jp      NZ,SFTPRG       ; More to do
 799+ 1765 60                   ld      H,B             ; HL - New end of program
 800+ 1766 69                   ld      L,C
 801+ 1767 22 22 53             ld      (PROGND),HL     ; Update end of program
 802+ 176A
 803+ 176A D1           INEWLN: pop     DE              ; Get address of line,
 804+ 176B F1                   pop     AF              ; Get status
 805+ 176C CA 91 17             jp      Z,SETPTR        ; No text - Set up pointers
 806+ 176F 2A 22 53             ld      HL,(PROGND)     ; Get end of program
 807+ 1772 E3                   ex      (SP),HL         ; Get length of input line
 808+ 1773 C1                   pop     BC              ; End of program to BC
 809+ 1774 09                   add     HL,BC           ; Find new end
 810+ 1775 E5                   push    HL              ; Save new end
 811+ 1776 CD 54 16             call    MOVUP           ; Make space for line
 812+ 1779 E1                   pop     HL              ; Restore new end
 813+ 177A 22 22 53             ld      (PROGND),HL     ; Update end of program pointer
 814+ 177D EB                   ex      DE,HL           ; Get line to move up in HL
 815+ 177E 74                   ld      (HL),H          ; Save MSB
 816+ 177F D1                   pop     DE              ; Get new line number
 817+ 1780 23                   inc     HL              ; Skip pointer
 818+ 1781 23                   inc     HL
 819+ 1782 73                   ld      (HL),E          ; Save LSB of line number
 820+ 1783 23                   inc     HL
 821+ 1784 72                   ld      (HL),D          ; Save MSB of line number
 822+ 1785 23                   inc     HL              ; To first byte in line
 823+ 1786 11 36 52             ld      DE,BUFFER       ; Copy buffer to program
 824+ 1789 1A           MOVBUF: ld      A,(DE)          ; Get source
 825+ 178A 77                   ld      (HL),A          ; Save destinations
 826+ 178B 23                   inc     HL              ; Next source
 827+ 178C 13                   inc     DE              ; Next destination
 828+ 178D B7                   or      A               ; Done?
 829+ 178E C2 89 17             jp      NZ,MOVBUF       ; No - Repeat
 830+ 1791 CD DA 17     SETPTR: call    RUNFST          ; Set line pointers
 831+ 1794 23                   inc     HL              ; To LSB of pointer
 832+ 1795 EB                   ex      DE,HL           ; Address to DE
 833+ 1796 62           PTRLP:  ld      H,D             ; Address to HL
 834+ 1797 6B                   ld      L,E
 835+ 1798 7E                   ld      A,(HL)          ; Get LSB of pointer
 836+ 1799 23                   inc     HL              ; To MSB of pointer
 837+ 179A B6                   or      (HL)            ; Compare with MSB pointer
 838+ 179B CA 0F 17             jp      Z,GETCMD        ; Get command line if end
 839+ 179E 23                   inc     HL              ; To LSB of line number
 840+ 179F 23                   inc     HL              ; Skip line number
 841+ 17A0 23                   inc     HL              ; Point to first byte in line
 842+ 17A1 AF                   xor     A               ; Looking for 00 byte
 843+ 17A2 BE           FNDEND: cp      (HL)            ; Found end of line?
 844+ 17A3 23                   inc     HL              ; Move to next byte
 845+ 17A4 C2 A2 17             jp      NZ,FNDEND       ; No - Keep looking
 846+ 17A7 EB                   ex      DE,HL           ; Next line address to HL
 847+ 17A8 73                   ld      (HL),E          ; Save LSB of pointer
 848+ 17A9 23                   inc     HL
 849+ 17AA 72                   ld      (HL),D          ; Save MSB of pointer
 850+ 17AB C3 96 17             jp      PTRLP           ; Do next line
 851+ 17AE
 852+ 17AE 2A 33 52     SRCHLN: ld      HL,(BASTXT)     ; Start of program text
 853+ 17B1 44           SRCHLP: ld      B,H             ; BC = Address to look at
 854+ 17B2 4D                   ld      C,L
 855+ 17B3 7E                   ld      A,(HL)          ; Get address of next line
 856+ 17B4 23                   inc     HL
 857+ 17B5 B6                   or      (HL)            ; End of program found?
 858+ 17B6 2B                   dec     HL
 859+ 17B7 C8                   ret     Z               ; Yes - Line not found
 860+ 17B8 23                   inc     HL
 861+ 17B9 23                   inc     HL
 862+ 17BA 7E                   ld      A,(HL)          ; Get LSB of line number
 863+ 17BB 23                   inc     HL
 864+ 17BC 66                   ld      H,(HL)          ; Get MSB of line number
 865+ 17BD 6F                   ld      L,A
 866+ 17BE CD 84 19             call    CPDEHL          ; Compare with line in DE
 867+ 17C1 60                   ld      H,B             ; HL = Start of this line
 868+ 17C2 69                   ld      L,C
 869+ 17C3 7E                   ld      A,(HL)          ; Get LSB of next line address
 870+ 17C4 23                   inc     HL
 871+ 17C5 66                   ld      H,(HL)          ; Get MSB of next line address
 872+ 17C6 6F                   ld      L,A             ; Next line to HL
 873+ 17C7 3F                   ccf
 874+ 17C8 C8                   ret     Z               ; Lines found - Exit
 875+ 17C9 3F                   ccf
 876+ 17CA D0                   ret     NC              ; Line not found,at line after
 877+ 17CB C3 B1 17             jp      SRCHLP          ; Keep looking
 878+ 17CE
 879+ 17CE C0           NEW:    ret     NZ              ; Return if any more on line
 880+ 17CF 2A 33 52     CLRPTR: ld      HL,(BASTXT)     ; Point to start of program
 881+ 17D2 AF                   xor     A               ; Set program area to empty
 882+ 17D3 77                   ld      (HL),A          ; Save LSB = 00
 883+ 17D4 23                   inc     HL
 884+ 17D5 77                   ld      (HL),A          ; Save MSB = 00
 885+ 17D6 23                   inc     HL
 886+ 17D7 22 22 53             ld      (PROGND),HL     ; Set program end
 887+ 17DA
 888+ 17DA 2A 33 52     RUNFST: ld      HL,(BASTXT)     ; Clear all variables
 889+ 17DD 2B                   dec     HL
 890+ 17DE
 891+ 17DE 22 B3 52     INTVAR: ld      (BRKLIN),HL     ; Initialise RUN variables
 892+ 17E1 2A 94 52             ld      HL,(LSTRAM)     ; Get end of RAM
 893+ 17E4 22 A8 52             ld      (STRBOT),HL     ; Clear string space
 894+ 17E7 AF                   xor     A
 895+ 17E8 CD DB 1B             call    RESTOR          ; Reset DATA pointers
 896+ 17EB 2A 22 53             ld      HL,(PROGND)     ; Get end of program
 897+ 17EE 22 24 53             ld      (VAREND),HL     ; Clear variables
 898+ 17F1 22 26 53             ld      (ARREND),HL     ; Clear arrays
 899+ 17F4
 900+ 17F4 C1           CLREG:  pop     BC              ; Save return address
 901+ 17F5 2A AB 51             ld      HL,(STRSPC)     ; Get end of working RAM
 902+ 17F8 F9                   ld      SP,HL           ; Set stack
 903+ 17F9 21 98 52             ld      HL,TMSTPL       ; Temporary string pool
 904+ 17FC 22 96 52             ld      (TMSTPT),HL     ; Reset temporary string ptr
 905+ 17FF AF                   xor     A               ; A = 00
 906+ 1800 6F                   ld      L,A             ; HL = 0000
 907+ 1801 67                   ld      H,A
 908+ 1802 22 B9 52             ld      (CONTAD),HL     ; No CONTinue
 909+ 1805 32 B0 52             ld      (FORFLG),A      ; Clear FOR flag
 910+ 1808 22 2A 53             ld      (FNRGNM),HL     ; Clear FN argument
 911+ 180B E5                   push    HL              ; HL = 0000
 912+ 180C C5                   push    BC              ; Put back return
 913+ 180D 2A B3 52     DOAGN:  ld      HL,(BRKLIN)     ; Get address of code to RUN
 914+ 1810 C9                   ret                     ; Return to execution driver
 915+ 1811
 916+ 1811 3E 3F        PROMPT: ld      A,'?'           ; '?'
 917+ 1813 CD 95 19             call    OUTC            ; Output character
 918+ 1816 3E 00                ld      A,NLLCR         ; null char
 919+ 1818 CD 95 19             call    OUTC            ; Output character
 920+ 181B CD F2 08             call    CURSOR_ON       ; enable cursor
 921+ 181E C3 A8 51             jp      RINPUT          ; Get input line
 922+ 1821
 923+ 1821 AF           CRUNCH: xor     A               ; Tokenise line @ HL to BUFFER
 924+ 1822 32 93 52             ld      (DATFLG),A      ; Reset literal flag
 925+ 1825 0E 05                ld      C,2+3           ; 2 byte number and 3 nulls
 926+ 1827 11 36 52             ld      DE,BUFFER       ; Start of input buffer
 927+ 182A 7E           CRNCLP: ld      A,(HL)          ; Get byte
 928+ 182B FE 20                cp      SPC             ; Is it a space?
 929+ 182D CA A9 18             jp      Z,MOVDIR        ; Yes - Copy direct
 930+ 1830 47                   ld      B,A             ; Save character
 931+ 1831 FE 22                cp      $22             ; '"'             ; Is it a quote?
 932+ 1833 CA C9 18             jp      Z,CPYLIT        ; Yes - Copy literal string
 933+ 1836 B7                   or      A               ; Is it end of buffer?
 934+ 1837 CA D0 18             jp      Z,ENDBUF        ; Yes - End buffer
 935+ 183A 3A 93 52             ld      A,(DATFLG)      ; Get data type
 936+ 183D B7                   or      A               ; Literal?
 937+ 183E 7E                   ld      A,(HL)          ; Get byte to copy
 938+ 183F C2 A9 18             jp      NZ,MOVDIR       ; Literal - Copy direct
 939+ 1842 FE 3F                cp      '?'             ; Is it '?' short for PRINT
 940+ 1844 3E AF                ld      A,ZPRINT        ; "PRINT" token
 941+ 1846 CA A9 18             jp      Z,MOVDIR        ; Yes - replace it
 942+ 1849 7E                   ld      A,(HL)          ; Get byte again
 943+ 184A FE 30                cp      '0'             ; Is it less than '0'
 944+ 184C DA 54 18             jp      C,FNDWRD        ; Yes - Look for reserved words
 945+ 184F FE 3C                cp      $3C  ;60; ";"+1       ; Is it "0123456789:;" ?
 946+ 1851 DA A9 18             jp      C,MOVDIR        ; Yes - copy it direct
 947+ 1854 D5           FNDWRD: push    DE              ; Look for reserved words
 948+ 1855 11 29 13             ld      DE,WORDS-1      ; Point to table
 949+ 1858 C5                   push    BC              ; Save count
 950+ 1859 01 A5 18             ld      BC,RETNAD       ; Where to return to
 951+ 185C C5                   push    BC              ; Save return address
 952+ 185D 06 7F                ld      B,ZEND-1        ; First token value -1
 953+ 185F 7E                   ld      A,(HL)          ; Get byte
 954+ 1860 FE 61                cp      'a'             ; Less than 'a' ?
 955+ 1862 DA 6D 18             jp      C,SEARCH        ; Yes - search for words
 956+ 1865 FE 7B                cp      'z'+1           ; Greater than 'z' ?
 957+ 1867 D2 6D 18             jp      NC,SEARCH       ; Yes - search for words
 958+ 186A E6 5F                and     %01011111       ; Force upper case
 959+ 186C 77                   ld      (HL),A          ; Replace byte
 960+ 186D 4E           SEARCH: ld      C,(HL)          ; Search for a word
 961+ 186E EB                   ex      DE,HL
 962+ 186F 23           GETNXT: inc     HL              ; Get next reserved word
 963+ 1870 B6                   or      (HL)            ; Start of word?
 964+ 1871 F2 6F 18             jp      P,GETNXT        ; No - move on
 965+ 1874 04                   inc     B               ; Increment token value
 966+ 1875 7E                   ld      A,(HL)          ; Get byte from table
 967+ 1876 E6 7F                and     %01111111       ; Strip bit 7
 968+ 1878 C8                   ret     Z               ; Return if end of list
 969+ 1879 B9                   cp      C               ; Same character as in buffer?
 970+ 187A C2 6F 18             jp      NZ,GETNXT       ; No - get next word
 971+ 187D EB                   ex      DE,HL
 972+ 187E E5                   push    HL              ; Save start of word
 973+ 187F
 974+ 187F 13           NXTBYT: inc     DE              ; Look through rest of word
 975+ 1880 1A                   ld      A,(DE)          ; Get byte from table
 976+ 1881 B7                   or      A               ; End of word ?
 977+ 1882 FA A1 18             jp      M,MATCH         ; Yes - Match found
 978+ 1885 4F                   ld      C,A             ; Save it
 979+ 1886 78                   ld      A,B             ; Get token value
 980+ 1887 FE 88                cp      ZGOTO           ; Is it "GOTO" token ?
 981+ 1889 C2 90 18             jp      NZ,NOSPC        ; No - Don't allow spaces
 982+ 188C CD CB 1B             call    GETCHR          ; Get next character
 983+ 188F 2B                   dec     HL              ; Cancel increment from GETCHR
 984+ 1890 23           NOSPC:  inc     HL              ; Next byte
 985+ 1891 7E                   ld      A,(HL)          ; Get byte
 986+ 1892 FE 61                cp      'a'             ; Less than 'a' ?
 987+ 1894 DA 99 18             jp      C,NOCHNG        ; Yes - don't change
 988+ 1897 E6 5F                and     %01011111       ; Make upper case
 989+ 1899 B9           NOCHNG: cp      C               ; Same as in buffer ?
 990+ 189A CA 7F 18             jp      Z,NXTBYT        ; Yes - keep testing
 991+ 189D E1                   pop     HL              ; Get back start of word
 992+ 189E C3 6D 18             jp      SEARCH          ; Look at next word
 993+ 18A1
 994+ 18A1 48           MATCH:  ld      C,B             ; Word found - Save token value
 995+ 18A2 F1                   pop     AF              ; Throw away return
 996+ 18A3 EB                   ex      DE,HL
 997+ 18A4 C9                   ret                     ; Return to "RETNAD"
 998+ 18A5 EB           RETNAD: ex      DE,HL           ; Get address in string
 999+ 18A6 79                   ld      A,C             ; Get token value
1000+ 18A7 C1                   pop     BC              ; Restore buffer length
1001+ 18A8 D1                   pop     DE              ; Get destination address
1002+ 18A9 23           MOVDIR: inc     HL              ; Next source in buffer
1003+ 18AA 12                   ld      (DE),A          ; Put byte in buffer
1004+ 18AB 13                   inc     DE              ; Move up buffer
1005+ 18AC 0C                   inc     C               ; Increment length of buffer
1006+ 18AD D6 3A                sub     ':'             ; End of statement?
1007+ 18AF CA B7 18             jp      Z,SETLIT        ; Jump if multi-statement line
1008+ 18B2 FE 49                cp      ZDATA-$3A       ; Is it DATA statement ?
1009+ 18B4 C2 BA 18             jp      NZ,TSTREM       ; No - see if REM
1010+ 18B7 32 93 52     SETLIT: ld      (DATFLG),A      ; Set literal flag
1011+ 18BA D6 54        TSTREM: sub     ZREM-$3A        ; Is it REM?
1012+ 18BC C2 2A 18             jp      NZ,CRNCLP       ; No - Leave flag
1013+ 18BF 47                   ld      B,A             ; Copy rest of buffer
1014+ 18C0 7E           NXTCHR: ld      A,(HL)          ; Get byte
1015+ 18C1 B7                   or      A               ; End of line ?
1016+ 18C2 CA D0 18             jp      Z,ENDBUF        ; Yes - Terminate buffer
1017+ 18C5 B8                   cp      B               ; End of statement ?
1018+ 18C6 CA A9 18             jp      Z,MOVDIR        ; Yes - Get next one
1019+ 18C9 23           CPYLIT: inc     HL              ; Move up source string
1020+ 18CA 12                   ld      (DE),A          ; Save in destination
1021+ 18CB 0C                   inc     C               ; Increment length
1022+ 18CC 13                   inc     DE              ; Move up destination
1023+ 18CD C3 C0 18             jp      NXTCHR          ; Repeat
1024+ 18D0
1025+ 18D0 21 35 52     ENDBUF: ld      HL,BUFFER-1     ; Point to start of buffer
1026+ 18D3 12                   ld      (DE),A          ; Mark end of buffer (A = 00)
1027+ 18D4 13                   inc     DE
1028+ 18D5 12                   ld      (DE),A          ; A = 00
1029+ 18D6 13                   inc     DE
1030+ 18D7 12                   ld      (DE),A          ; A = 00
1031+ 18D8 C9                   ret
1032+ 18D9
1033+ 18D9 3A A2 51     DODEL:  ld      A,(NULFLG)      ; Get null flag status
1034+ 18DC B7                   or      A               ; Is it zero?
1035+ 18DD 3E 00                ld      A,$00           ; Zero A - Leave flags
1036+ 18DF 32 A2 51             ld      (NULFLG),A      ; Zero null flag
1037+ 18E2 C2 ED 18             jp      NZ,ECHDEL       ; Set - Echo it
1038+ 18E5 05                   dec     B               ; Decrement length
1039+ 18E6 CA 0A 19             jp      Z,GETLIN        ; Get line again if empty
1040+ 18E9 CD 95 19             call    OUTC            ; Output null character
1041+ 18EC 3E                   defb    $3E             ; Skip "dec B"
1042+ 18ED 05           ECHDEL: dec     B               ; Count bytes in buffer
1043+ 18EE 2B                   dec     HL              ; Back space buffer
1044+ 18EF CA 01 19             jp      Z,OTKLN         ; No buffer - Try again
1045+ 18F2 7E                   ld      A,(HL)          ; Get deleted byte
1046+ 18F3 CD 95 19             call    OUTC            ; Echo it
1047+ 18F6 C3 13 19             jp      MORINP          ; Get more input
1048+ 18F9
1049+ 18F9 05           DELCHR: dec     B               ; Count bytes in buffer
1050+ 18FA 2B                   dec     HL              ; Back space buffer
1051+ 18FB CD 95 19             call    OUTC            ; Output character in A
1052+ 18FE C2 13 19             jp      NZ,MORINP       ; Not end - Get more
1053+ 1901 CD 95 19     OTKLN:  call    OUTC            ; Output character in A
1054+ 1904 CD 98 1E     KILIN:  call    PRNTCRLF        ; Output CRLF
1055+ 1907 C3 0A 19             jp      TTYLIN          ; Get line again
1056+ 190A
1057+ 190A              GETLIN:
1058+ 190A 21 36 52     TTYLIN: ld      HL,BUFFER       ; Get a line by character
1059+ 190D 06 01                ld      B,$01           ; Set buffer as empty
1060+ 190F AF                   xor     A
1061+ 1910 32 A2 51             ld      (NULFLG),A      ; Clear null flag
1062+ 1913 CD D6 19     MORINP: call    CLOTST          ; Get character and test ^O
1063+ 1916 4F                   ld      C,A             ; Save character in C
1064+ 1917 FE 7F                cp      DEL             ; Delete character?
1065+ 1919 CA D9 18             jp      Z,DODEL         ; Yes - Process it
1066+ 191C 3A A2 51             ld      A,(NULFLG)      ; Get null flag
1067+ 191F B7                   or      A               ; Test null flag status
1068+ 1920 CA 2C 19             jp      Z,PROCES        ; Reset - Process character
1069+ 1923 3E 00                ld      A,$00           ; Set a null
1070+ 1925 CD 95 19             call    OUTC            ; Output null
1071+ 1928 AF                   xor     A               ; Clear A
1072+ 1929 32 A2 51             ld      (NULFLG),A      ; Reset null flag
1073+ 192C 79           PROCES: ld      A,C             ; Get character
1074+ 192D FE 07                cp      CTRLG           ; Bell?
1075+ 192F CA 6C 19             jp      Z,PUTCTL        ; Yes - Save it
1076+ 1932 FE 03                cp      CTRLC           ; Is it control "C"?
1077+ 1934 CC 61 19             call    Z,GMNCR         ; Yes - exit from graphic mode & Output CRLF
1078+ 1937 37                   scf                     ; Flag break
1079+ 1938 C8                   ret     Z               ; Return if control "C"
1080+ 1939 FE 0D                cp      CR              ; Is it enter?
1081+ 193B CA 8E 1E             jp      Z,ENDINP        ; Yes - Terminate input
1082+ 193E FE 15                cp      CTRLU           ; Is it control "U"?
1083+ 1940 CA 04 19             jp      Z,KILIN         ; Yes - Get another line
1084+ 1943 FE 08                cp      BKSP            ; Is it backspace?
1085+ 1945 CA F9 18             jp      Z,DELCHR        ; Yes - Delete character
1086+ 1948 FE 12                cp      CTRLR           ; Is it control "R"?
1087+ 194A C2 67 19             jp      NZ,PUTBUF       ; No - Put in buffer
1088+ 194D C5                   push    BC              ; Save buffer length
1089+ 194E D5                   push    DE              ; Save DE
1090+ 194F E5                   push    HL              ; Save buffer address
1091+ 1950 36 00                ld      (HL),$00        ; Mark end of buffer
1092+ 1952 CD 91 3F             call    OUTNCR          ; Output and do CRLF
1093+ 1955 21 36 52             ld      HL,BUFFER       ; Point to buffer start
1094+ 1958 CD 5C 25             call    PRS             ; Output buffer
1095+ 195B E1                   pop     HL              ; Restore buffer address
1096+ 195C D1                   pop     DE              ; Restore DE
1097+ 195D C1                   pop     BC              ; Restore buffer length
1098+ 195E C3 13 19             jp      MORINP          ; Get another character
1099+ 1961 CD 82 16     GMNCR:  call    EXITGM          ; exit from graphic mode
1100+ 1964 C3 98 1E             jp      PRNTCRLF        ; output CRLF
1101+ 1967
1102+ 1967 FE 20        PUTBUF: cp      SPC             ; Is it a control code?
1103+ 1969 DA 13 19             jp      C,MORINP        ; Yes - Ignore
1104+ 196C 78           PUTCTL: ld      A,B             ; Get number of bytes in buffer
1105+ 196D FE 59                cp      $58+$01         ; Test for line overflow
1106+ 196F 3E 08                ld      A,BKSP          ; Set a bell
1107+ 1971 D2 7E 19             jp      NC,OUTNBS       ; Ring bell if buffer full
1108+ 1974 79                   ld      A,C             ; Get character
1109+ 1975 71                   ld      (HL),C          ; Save in buffer
1110+ 1976 32 B1 52             ld      (LSTBIN),A      ; Save last input byte
1111+ 1979 23                   inc     HL              ; Move up buffer
1112+ 197A 04                   inc     B               ; Increment length
1113+ 197B C3 13 19     OUTIT:  jp      MORINP          ; Get another character
1114+ 197E
1115+ 197E CD 95 19     OUTNBS: call    OUTC            ; Output bell and back over it
1116+ 1981 C3 7B 19             jp      OUTIT           ; get more chars
1117+ 1984
1118+ 1984 7C           CPDEHL: ld      A,H             ; Get H
1119+ 1985 92                   sub     D               ; Compare with D
1120+ 1986 C0                   ret     NZ              ; Different - Exit
1121+ 1987 7D                   ld      A,L             ; Get L
1122+ 1988 93                   sub     E               ; Compare with E
1123+ 1989 C9                   ret                     ; Return status
1124+ 198A
1125+ 198A 7E           CHKSYN: ld      A,(HL)          ; Check syntax of character
1126+ 198B E3                   ex      (SP),HL         ; Address of test byte
1127+ 198C BE                   cp      (HL)            ; Same as in code string?
1128+ 198D 23                   inc     HL              ; Return address
1129+ 198E E3                   ex      (SP),HL         ; Put it back
1130+ 198F CA CB 1B             jp      Z,GETCHR        ; Yes - Get next character
1131+ 1992 C3 A8 16             jp      SNERR           ; Different - ?SN Error
1132+ 1995
1133+ 1995 F5           OUTC:   push    AF              ; Save character
1134+ 1996 3A A3 51             ld      A,(CTLOFG)      ; Get control "O" flag
1135+ 1999 B7                   or      A               ; Is it set?
1136+ 199A C2 91 25             jp      NZ,POPAF        ; Yes - don't output
1137+ 199D F1                   pop     AF              ; Restore character
1138+ 199E C5                   push    BC              ; Save buffer length
1139+ 199F F5                   push    AF              ; Save character
1140+ 19A0 FE 20                cp      SPC             ; Is it a control code?
1141+ 19A2 DA B9 19             jp      C,DINPOS        ; Yes - Don't inc POS(X)
1142+ 19A5 3A A0 51             ld      A,(LWIDTH)      ; Get line width
1143+ 19A8 47                   ld      B,A             ; To B
1144+ 19A9 3A 90 52             ld      A,(CURPOS)      ; Get cursor position
1145+ 19AC 04                   inc     B               ; Width 255?
1146+ 19AD CA B5 19             jp      Z,INCLEN        ; Yes - No width limit
1147+ 19B0 05                   dec     B               ; Restore width
1148+ 19B1 B8                   cp      B               ; At end of line?
1149+ 19B2 CC 98 1E             call    Z,PRNTCRLF      ; Yes - output CRLF
1150+ 19B5 3C           INCLEN: inc     A               ; Move on one character
1151+ 19B6 32 90 52             ld      (CURPOS),A      ; Save new position
1152+ 19B9 AF           DINPOS: xor     A
1153+ 19BA 32 16 53             ld      (KBDNPT),A      ; set flag for no char from keyboard
1154+ 19BD F1                   pop     AF              ; Restore character
1155+ 19BE C1                   pop     BC              ; Restore buffer length
1156+ 19BF F5                   push    AF
1157+ 19C0 CD C8 19             call    SND2VID         ; send char to video
1158+ 19C3 F1                   pop     AF
1159+ 19C4 CD 70 3F             call    MONOUT          ; send char to serial if enabled
1160+ 19C7 C9                   ret
1161+ 19C8
1162+ 19C8              ; print char to video if cursor is on
1163+ 19C8 32 D9 52     SND2VID:ld      (CHR4VID),A     ; store A
1164+ 19CB 3A D8 52             ld      A,(PRNTVIDEO)   ; check print-on-video
1165+ 19CE B7                   or      A               ; is it off?
1166+ 19CF C8                   ret     Z               ; yes, so return
1167+ 19D0 F3                   di                      ; disable INTs
1168+ 19D1 CD 56 07             call    CHAR2VID        ; cursor is on, so print char on screen
1169+ 19D4 FB                   ei                      ; re-enable INTs
1170+ 19D5 C9                   ret                     ; return to caller
1171+ 19D6
1172+ 19D6 CD 17 33     CLOTST: call    GETINP          ; Get input character
1173+ 19D9 FE 0F                cp      CTRLO           ; Is it control "O"?
1174+ 19DB C0                   ret     NZ              ; No don't flip flag
1175+ 19DC 3A A3 51             ld      A,(CTLOFG)      ; Get flag
1176+ 19DF 2F                   cpl                     ; Flip it
1177+ 19E0 32 A3 51             ld      (CTLOFG),A      ; Put it back
1178+ 19E3 A7                   and     A               ; is output enabled?
1179+ 19E4 CC F2 08             call    Z,CURSOR_ON     ; yes, so cursor on
1180+ 19E7 AF                   xor     A               ; Null character
1181+ 19E8 C9                   ret
1182+ 19E9
1183+ 19E9              ; LIST: list the program stored into memory
1184+ 19E9 C1           LIST:   pop     BC              ; rubbish - not needed (legacy from original call of LIST)
1185+ 19EA 2B                   dec     HL              ; dec 'cos GETCHR INCs
1186+ 19EB CD CB 1B             call    GETCHR          ; Get next character
1187+ 19EE CA 44 1A             jp      Z,LSTALL        ; list all if nothing follows
1188+ 19F1 FE BE                cp      ZMINUS          ; is it '-'?
1189+ 19F3 20 20                jr      NZ,LST01        ; no, look for a line number
1190+ 19F5 11 00 00             ld      DE,$0000        ; yes, set search from 0
1191+ 19F8 CD E5 1A             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1192+ 19FB ED 43 DC 52          ld      (TMPBFR1),BC    ; store address of starting line
1193+ 19FF CD 8A 19             call    CHKSYN          ; skip '-'
1194+ 1A02 BE                   defb    ZMINUS
1195+ 1A03 CD 9B 1C             call    ATOH            ; now, look for another number (ASCII number to DE)
1196+ 1A06 CD EB 1A             call    SRCLN           ; find a line, getting the previous if it doesn't exist
1197+ 1A09 ED 43 DE 52          ld      (TMPBFR2),BC    ; store address of ending line
1198+ 1A0D ED 4B DC 52          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1199+ 1A11 C5                   push    BC              ; store address of line for later use
1200+ 1A12 C3 7C 1A             jp      LISTLP          ; go listing
1201+ 1A15 CD 9B 1C     LST01:  call    ATOH            ; get a line number (ASCII number to DE)
1202+ 1A18 ED 53 E2 52  LST01H: ld      (TMPBFR4),DE    ; store ending line address for later use - N.B.: this is a hook for HELP command
1203+ 1A1C CD E5 1A             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1204+ 1A1F ED 43 DC 52          ld      (TMPBFR1),BC    ; store address of starting line
1205+ 1A23 ED 43 DE 52          ld      (TMPBFR2),BC    ; same address for ending line (we'll change it later if needed)
1206+ 1A27 2B                   dec     HL              ; dec 'cos GETCHR INCs
1207+ 1A28 CD CB 1B             call    GETCHR          ; Get next character
1208+ 1A2B CA 37 1A             jp      Z,LSTNOT        ; nothing follows, so ending & starting lines are the same
1209+ 1A2E FE BE                cp      ZMINUS          ; is it '-'?
1210+ 1A30 CA 5C 1A             jp      Z,LST03         ; yes, read ending line
1211+ 1A33 C5           LST06:  push    BC              ; store address for later use
1212+ 1A34 C3 7C 1A             jp      LISTLP          ; jump to list
1213+ 1A37 ED 5B E2 52  LSTNOT: ld      DE,(TMPBFR4)
1214+ 1A3B CD E5 1A             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1215+ 1A3E DA 33 1A             jp      C,LST06
1216+ 1A41 C3 02 17             jp      PRNTOK
1217+ 1A44 11 F9 FF     LSTALL: ld      DE,65529        ; set ending line to max. allowed line number
1218+ 1A47 CD E5 1A             call    SRCHLIN         ; get address of last line
1219+ 1A4A ED 43 DE 52          ld      (TMPBFR2),BC    ; store it
1220+ 1A4E 11 00 00             ld      DE,$0000        ; set start to first line in memory
1221+ 1A51 CD E5 1A             call    SRCHLIN         ; get address of first line
1222+ 1A54 ED 43 DC 52          ld      (TMPBFR1),BC    ; store it
1223+ 1A58 C5                   push    BC              ; store address of starting line for later use
1224+ 1A59 C3 7C 1A             jp      LISTLP          ; start printing
1225+ 1A5C CD 8A 19     LST03:  call    CHKSYN          ; skip '-'
1226+ 1A5F BE                   defb    ZMINUS
1227+ 1A60 CD 9B 1C             call    ATOH            ; look for another number (return into DE)
1228+ 1A63 7A                   ld      A,D
1229+ 1A64 B3                   or      E               ; is line=0?
1230+ 1A65 20 09                jr      NZ,LST05        ; no, jump over
1231+ 1A67 11 F9 FF             ld      DE,65529        ; yes set last valid line number
1232+ 1A6A CD E5 1A             call    SRCHLIN         ; get address of last line
1233+ 1A6D C3 73 1A             jp      LST02
1234+ 1A70 CD EB 1A     LST05:  call    SRCLN           ; find a line, getting the previous if it doesn't exist
1235+ 1A73 ED 43 DE 52  LST02:  ld      (TMPBFR2),BC    ; store address of ending line
1236+ 1A77 ED 4B DC 52          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1237+ 1A7B C5                   push    BC              ; store it for later use
1238+ 1A7C E1           LISTLP: pop     HL              ; Restore address of line
1239+ 1A7D 4E                   ld      C,(HL)          ; Get LSB of next line
1240+ 1A7E 23                   inc     HL
1241+ 1A7F 46                   ld      B,(HL)          ; Get MSB of next line
1242+ 1A80 23                   inc     HL
1243+ 1A81 78                   ld      A,B             ; BC = 0 (End of program)?
1244+ 1A82 B1                   or      C
1245+ 1A83 CA 02 17             jp      Z,PRNTOK        ; Yes - Go to command mode
1246+ 1A86 CD F6 1B             call    TSTBRK          ; Test for break key
1247+ 1A89 CD F9 1A             call    TSTSPC          ; test for space
1248+ 1A8C C5                   push    BC              ; Save address of next line
1249+ 1A8D 3A D1 52             ld      A,(SCR_CURS_X)  ; load current X pos of cursor
1250+ 1A90 A7                   and     A               ; is it at the beginning of a new line?
1251+ 1A91 20 0B                jr      NZ,LST08        ; No, jump over
1252+ 1A93 3E 0D                ld      A,CR            ; yes, so just send a CR
1253+ 1A95 CD 70 3F             call    MONOUT          ; to serial if it's open
1254+ 1A98 AF                   xor     A               ; then, set cursor
1255+ 1A99 32 90 52             ld      (CURPOS),A      ; to position 0
1256+ 1A9C 18 03                jr      LST07           ; and continue
1257+ 1A9E CD 98 1E     LST08:  call    PRNTCRLF        ; output CRLF
1258+ 1AA1 5E           LST07:  ld      E,(HL)          ; Get LSB of line number
1259+ 1AA2 23                   inc     HL
1260+ 1AA3 56                   ld      D,(HL)          ; Get MSB of line number
1261+ 1AA4 23                   inc     HL
1262+ 1AA5 E5                   push    HL              ; Save address of line start
1263+ 1AA6 EB                   ex      DE,HL           ; Line number to HL
1264+ 1AA7 CD FB 2F             call    PRNTHL          ; Output line number in decimal
1265+ 1AAA 3E 20                ld      A,SPC           ; Space after line number
1266+ 1AAC E1                   pop     HL              ; Restore start of line address
1267+ 1AAD CD 95 19     LSTLP2: call    OUTC            ; Output character in A
1268+ 1AB0 7E           LSTLP3: ld      A,(HL)          ; Get next byte in line
1269+ 1AB1 B7                   or      A               ; End of line?
1270+ 1AB2 23                   inc     HL              ; To next byte in line
1271+ 1AB3 CA D7 1A             jp      Z,NXTLN         ; Yes - check next line
1272+ 1AB6 F2 AD 1A             jp      P,LSTLP2        ; No token - output it
1273+ 1AB9 D6 7F                sub     ZEND-1          ; Find and output word
1274+ 1ABB 4F                   ld      C,A             ; Token offset+1 to C
1275+ 1ABC 11 2A 13             ld      DE,WORDS        ; Reserved word list
1276+ 1ABF 1A           FNDTOK: ld      A,(DE)          ; Get character in list
1277+ 1AC0 13                   inc     DE              ; Move on to next
1278+ 1AC1 B7                   or      A               ; Is it start of word?
1279+ 1AC2 F2 BF 1A             jp      P,FNDTOK        ; No - Keep looking for word
1280+ 1AC5 0D                   dec     C               ; Count words
1281+ 1AC6 C2 BF 1A             jp      NZ,FNDTOK       ; Not there - keep looking
1282+ 1AC9 E6 7F        OUTWRD: and     %01111111       ; Strip bit 7
1283+ 1ACB CD 95 19             call    OUTC            ; Output character
1284+ 1ACE 1A                   ld      A,(DE)          ; Get next character
1285+ 1ACF 13                   inc     DE              ; Move on to next
1286+ 1AD0 B7                   or      A               ; Is it end of word?
1287+ 1AD1 F2 C9 1A             jp      P,OUTWRD        ; No - output the rest
1288+ 1AD4 C3 B0 1A             jp      LSTLP3          ; Next byte in line
1289+ 1AD7 D1           NXTLN:  pop     DE              ; recover address of current line
1290+ 1AD8 2A DE 52             ld      HL,(TMPBFR2)    ; address of last line to print
1291+ 1ADB CD 97 3F             call    CMP16           ; check if current line is over last printable line
1292+ 1ADE DA 02 17             jp      C,PRNTOK        ; finish - leave & print OK
1293+ 1AE1 D5                   push    DE              ; store address of current line
1294+ 1AE2 C3 7C 1A             jp      LISTLP          ; continue listing
1295+ 1AE5              ; look for the address of a program line
1296+ 1AE5 E5           SRCHLIN:push    HL              ; store HL (this is needed because HL store the pointer to the input buffer)
1297+ 1AE6 CD AE 17             call    SRCHLN          ; search for line number in DE
1298+ 1AE9 E1                   pop     HL              ; retrieve HL
1299+ 1AEA C9                   ret                     ; return to caller
1300+ 1AEB              ; look for the address of a program line - if the line isn't found,
1301+ 1AEB              ; it look backward for the previous line
1302+ 1AEB E5           SRCLN:  push    HL              ; store HL
1303+ 1AEC CD AE 17     SRCLN1: call    SRCHLN          ; search for line in DE
1304+ 1AEF DA F7 1A             jp      C,LVSRLN        ; found it, leave loop
1305+ 1AF2 1B                   dec     DE              ; not found, decrement number to look backward for an existing line
1306+ 1AF3 7B                   ld      A,E
1307+ 1AF4 B2                   or      D               ; is line number zero?
1308+ 1AF5 20 F5                jr      NZ,SRCLN1       ; no, continue
1309+ 1AF7 E1           LVSRLN: pop     HL              ; retrieve HL
1310+ 1AF8 C9                   ret                     ; return to caller
1311+ 1AF9
1312+ 1AF9              ; during LISTing, check if PAUSE is pressed, then pause listing and
1313+ 1AF9              ; wait for another pressing of PAUSE to continue or CTRL-C/BREAK to exit
1314+ 1AF9 3A 18 53     TSTSPC: ld      A,(TMPKEYBFR)   ; Get input character
1315+ 1AFC FE 20                cp      SPC             ; Is it SPACE?
1316+ 1AFE C0                   ret     NZ              ; No, return
1317+ 1AFF CD 17 33     WTSPC:  call    GETINP          ; Yes, stop listing and wait for another space or BREAK
1318+ 1B02 FE 20                cp      SPC             ; is it SPACE?
1319+ 1B04 20 05                jr      NZ,CNTWTSP      ; no, continue
1320+ 1B06 AF                   xor     A
1321+ 1B07 32 18 53             ld      (TMPKEYBFR),A   ; reset key
1322+ 1B0A C9                   ret                     ; return to caller
1323+ 1B0B FE 03        CNTWTSP:cp      CTRLC           ; is it CTRL-C/BREAK?
1324+ 1B0D 20 F0                jr      NZ,WTSPC        ; no, loop
1325+ 1B0F C3 77 12             jp      BRKRET          ; exit and output "Ok"
1326+ 1B12
1327+ 1B12
1328+ 1B12 3E 64        FOR:    ld      A,$64           ; Flag "FOR" assignment
1329+ 1B14 32 B0 52             ld      (FORFLG),A      ; Save "FOR" flag
1330+ 1B17 CD 8B 1D             call    LET             ; Set up initial index
1331+ 1B1A C1                   pop     BC              ; Drop RETurn address
1332+ 1B1B E5                   push    HL              ; Save code string address
1333+ 1B1C CD 74 1D             call    DATA            ; Get next statement address
1334+ 1B1F 22 AC 52             ld      (LOOPST),HL     ; Save it for start of loop
1335+ 1B22 21 02 00             ld      HL,$0002        ; Offset for "FOR" block
1336+ 1B25 39                   add     HL,SP           ; Point to it
1337+ 1B26 CD 35 16     FORSLP: call    LOKFOR          ; Look for existing "FOR" block
1338+ 1B29 D1                   pop     DE              ; Get code string address
1339+ 1B2A C2 42 1B             jp      NZ,FORFND       ; No nesting found
1340+ 1B2D 09                   add     HL,BC           ; Move into "FOR" block
1341+ 1B2E D5                   push    DE              ; Save code string address
1342+ 1B2F 2B                   dec     HL
1343+ 1B30 56                   ld      D,(HL)          ; Get MSB of loop statement
1344+ 1B31 2B                   dec     HL
1345+ 1B32 5E                   ld      E,(HL)          ; Get LSB of loop statement
1346+ 1B33 23                   inc     HL
1347+ 1B34 23                   inc     HL
1348+ 1B35 E5                   push    HL              ; Save block address
1349+ 1B36 2A AC 52             ld      HL,(LOOPST)     ; Get address of loop statement
1350+ 1B39 CD 84 19             call    CPDEHL          ; Compare the FOR loops
1351+ 1B3C E1                   pop     HL              ; Restore block address
1352+ 1B3D C2 26 1B             jp      NZ,FORSLP       ; Different FORs - Find another
1353+ 1B40 D1                   pop     DE              ; Restore code string address
1354+ 1B41 F9                   ld      SP,HL           ; Remove all nested loops
1355+ 1B42
1356+ 1B42 EB           FORFND: ex      DE,HL           ; Code string address to HL
1357+ 1B43 0E 08                ld      C,$08
1358+ 1B45 CD 65 16             call    CHKSTK          ; Check for 8 levels of stack
1359+ 1B48 E5                   push    HL              ; Save code string address
1360+ 1B49 2A AC 52             ld      HL,(LOOPST)     ; Get first statement of loop
1361+ 1B4C E3                   ex      (SP),HL         ; Save and restore code string
1362+ 1B4D E5                   push    HL              ; Re-save code string address
1363+ 1B4E 2A AD 51             ld      HL,(LINEAT)     ; Get current line number
1364+ 1B51 E3                   ex      (SP),HL         ; Save and restore code string
1365+ 1B52 CD 57 20             call    TSTNUM          ; Make sure it's a number
1366+ 1B55 CD 8A 19             call    CHKSYN          ; Make sure "TO" is next
1367+ 1B58 B7                   defb    ZTO             ; "TO" token
1368+ 1B59 CD 54 20             call    GETNUM          ; Get "TO" expression value
1369+ 1B5C E5                   push    HL              ; Save code string address
1370+ 1B5D CD AD 2E             call    BCDEFP          ; Move "TO" value to BCDE
1371+ 1B60 E1                   pop     HL              ; Restore code string address
1372+ 1B61 C5                   push    BC              ; Save "TO" value in block
1373+ 1B62 D5                   push    DE
1374+ 1B63 01 00 81             ld      BC,$8100        ; BCDE - 1 (default STEP)
1375+ 1B66 51                   ld      D,C             ; C=0
1376+ 1B67 5A                   ld      E,D             ; D=0
1377+ 1B68 7E                   ld      A,(HL)          ; Get next byte in code string
1378+ 1B69 FE BC                cp      ZSTEP           ; See if "STEP" is stated
1379+ 1B6B 3E 01                ld      A,$01           ; Sign of step = 1
1380+ 1B6D C2 7E 1B             jp      NZ,SAVSTP       ; No STEP given - Default to 1
1381+ 1B70 CD CB 1B             call    GETCHR          ; Jump over "STEP" token
1382+ 1B73 CD 54 20             call    GETNUM          ; Get step value
1383+ 1B76 E5                   push    HL              ; Save code string address
1384+ 1B77 CD AD 2E             call    BCDEFP          ; Move STEP to BCDE
1385+ 1B7A CD 61 2E             call    TSTSGN          ; Test sign of FPREG
1386+ 1B7D E1                   pop     HL              ; Restore code string address
1387+ 1B7E C5           SAVSTP: push    BC              ; Save the STEP value in block
1388+ 1B7F D5                   push    DE
1389+ 1B80 F5                   push    AF              ; Save sign of STEP
1390+ 1B81 33                   inc     SP              ; Don't save flags
1391+ 1B82 E5                   push    HL              ; Save code string address
1392+ 1B83 2A B3 52             ld      HL,(BRKLIN)     ; Get address of index variable
1393+ 1B86 E3                   ex      (SP),HL         ; Save and restore code string
1394+ 1B87 06 81        PUTFID: ld      B,ZFOR          ; "FOR" block marker
1395+ 1B89 C5                   push    BC              ; Save it
1396+ 1B8A 33                   inc     SP              ; Don't save C
1397+ 1B8B
1398+ 1B8B CD F6 1B     RUNCNT: call    TSTBRK          ; Execution driver - Test break
1399+ 1B8E 22 B3 52             ld      (BRKLIN),HL     ; Save code address for break
1400+ 1B91 7E                   ld      A,(HL)          ; Get next byte in code string
1401+ 1B92 FE 3A                cp      ':'             ; Multi statement line?
1402+ 1B94 CA AB 1B             jp      Z,EXCUTE        ; Yes - Execute it
1403+ 1B97 B7                   or      A               ; End of line?
1404+ 1B98 C2 A8 16             jp      NZ,SNERR        ; No - Syntax error
1405+ 1B9B 23                   inc     HL              ; Point to address of next line
1406+ 1B9C 7E                   ld      A,(HL)          ; Get LSB of line pointer
1407+ 1B9D 23                   inc     HL
1408+ 1B9E B6                   or      (HL)            ; Is it zero (End of prog)?
1409+ 1B9F CA 1D 1C             jp      Z,ENDPRG        ; Yes - Terminate execution
1410+ 1BA2 23                   inc     HL              ; Point to line number
1411+ 1BA3 5E                   ld      E,(HL)          ; Get LSB of line number
1412+ 1BA4 23                   inc     HL
1413+ 1BA5 56                   ld      D,(HL)          ; Get MSB of line number
1414+ 1BA6 EB                   ex      DE,HL           ; Line number to HL
1415+ 1BA7 22 AD 51             ld      (LINEAT),HL     ; Save as current line number
1416+ 1BAA EB                   ex      DE,HL           ; Line number back to DE
1417+ 1BAB CD CB 1B     EXCUTE: call    GETCHR          ; Get key word
1418+ 1BAE 11 8B 1B             ld      DE,RUNCNT       ; Where to RETurn to
1419+ 1BB1 D5                   push    DE              ; Save for RETurn
1420+ 1BB2 C8           IFJMP:  ret     Z               ; Go to RUNCNT if end of STMT
1421+ 1BB3
1422+ 1BB3 D6 80        ONJMP:  sub     ZEND            ; Is it a token?
1423+ 1BB5 DA 8B 1D             jp      C,LET           ; No - try to assign it
1424+ 1BB8 FE 36                cp      ZNEW+1-ZEND     ; END to NEW ?
1425+ 1BBA D2 A8 16             jp      NC,SNERR        ; Not a key word - ?SN Error
1426+ 1BBD 07                   rlca                    ; Double it
1427+ 1BBE 4F                   ld      C,A             ; BC = Offset into table
1428+ 1BBF 06 00                ld      B,0
1429+ 1BC1 EB                   ex      DE,HL           ; Save code string address
1430+ 1BC2 21 B7 14             ld      HL,WORDTB       ; Keyword address table
1431+ 1BC5 09                   add     HL,BC           ; Point to routine address
1432+ 1BC6 4E                   ld      C,(HL)          ; Get LSB of routine address
1433+ 1BC7 23                   inc     HL
1434+ 1BC8 46                   ld      B,(HL)          ; Get MSB of routine address
1435+ 1BC9 C5                   push    BC              ; Save routine address
1436+ 1BCA EB                   ex      DE,HL           ; Restore code string address
1437+ 1BCB
1438+ 1BCB              ; get a char from input buffer: exit with NC if character found is
1439+ 1BCB              ; not a number; exit with Z if nothing found; char is into A
1440+ 1BCB 23           GETCHR: inc     HL              ; Point to next character
1441+ 1BCC 7E                   ld      A,(HL)          ; Get next code string byte
1442+ 1BCD FE 3A                cp      ':'             ; Z if ':'
1443+ 1BCF D0                   ret     NC              ; NC if > "9"
1444+ 1BD0 FE 20                cp      SPC
1445+ 1BD2 CA CB 1B             jp      Z,GETCHR        ; Skip over spaces
1446+ 1BD5 FE 30                cp      '0'
1447+ 1BD7 3F                   ccf                     ; NC if < '0'
1448+ 1BD8 3C                   inc     A               ; Test for zero - Leave carry
1449+ 1BD9 3D                   dec     A               ; Z if Null
1450+ 1BDA C9                   ret
1451+ 1BDB
1452+ 1BDB EB           RESTOR: ex      DE,HL           ; Save code string address
1453+ 1BDC 2A 33 52             ld      HL,(BASTXT)     ; Point to start of program
1454+ 1BDF CA F0 1B             jp      Z,RESTNL        ; Just RESTORE - reset pointer
1455+ 1BE2 EB                   ex      DE,HL           ; Restore code string address
1456+ 1BE3 CD 9B 1C             call    ATOH            ; Get line number to DE
1457+ 1BE6 E5                   push    HL              ; Save code string address
1458+ 1BE7 CD AE 17             call    SRCHLN          ; Search for line number in DE
1459+ 1BEA 60                   ld      H,B             ; HL = Address of line
1460+ 1BEB 69                   ld      L,C
1461+ 1BEC D1                   pop     DE              ; Restore code string address
1462+ 1BED D2 4A 1D             jp      NC,ULERR        ; ?UL Error if not found
1463+ 1BF0 2B           RESTNL: dec     HL              ; Byte before DATA statement
1464+ 1BF1 22 28 53     UPDATA: ld      (NXTDAT),HL     ; Update DATA pointer
1465+ 1BF4 EB                   ex      DE,HL           ; Restore code string address
1466+ 1BF5 C9                   ret
1467+ 1BF6
1468+ 1BF6
1469+ 1BF6 DF           TSTBRK: rst     $18             ; Check input status
1470+ 1BF7 C8                   ret     Z               ; No key, go back
1471+ 1BF8 D7                   rst     $10             ; Get the key into A
1472+ 1BF9 FE 1B                cp      ESC             ; Escape key?
1473+ 1BFB 28 11                jr      Z,BRK           ; Yes, break
1474+ 1BFD FE 03                cp      CTRLC           ; <Ctrl-C>
1475+ 1BFF 28 0D                jr      Z,BRK           ; Yes, break
1476+ 1C01 FE 13                cp      CTRLS           ; Stop scrolling?
1477+ 1C03 C0                   ret     NZ              ; Other key, ignore
1478+ 1C04
1479+ 1C04
1480+ 1C04 D7           STALL:  rst     $10             ; Wait for key
1481+ 1C05 FE 11                cp      CTRLQ           ; Resume scrolling?
1482+ 1C07 C8                   ret     Z               ; Release the chokehold
1483+ 1C08 FE 03                cp      CTRLC           ; Second break?
1484+ 1C0A 28 07                jr      Z,STOP          ; Break during hold exits prog
1485+ 1C0C 18 F6                jr      STALL           ; Loop until <Ctrl-Q> or <brk>
1486+ 1C0E
1487+ 1C0E 3E FF        BRK:    ld      A,$FF           ; Set BRKFLG
1488+ 1C10 32 A7 51             ld      (BRKFLG),A      ; Store it
1489+ 1C13
1490+ 1C13 C0           STOP:   ret     NZ              ; Exit if anything else
1491+ 1C14 F6                   defb    $F6             ; Flag "STOP"
1492+ 1C15 C0           PEND:   ret     NZ              ; Exit if anything else
1493+ 1C16 22 B3 52             ld      (BRKLIN),HL     ; Save point of break
1494+ 1C19 21                   defb    $21             ; Skip "OR 11111111B"
1495+ 1C1A F6 FF        INPBRK: or      %11111111       ; Flag "Break" wanted
1496+ 1C1C C1                   pop     BC              ; Return not needed and more
1497+ 1C1D 2A AD 51     ENDPRG: ld      HL,(LINEAT)     ; Get current line number
1498+ 1C20 F5                   push    AF              ; Save STOP / END status
1499+ 1C21 7D                   ld      A,L             ; Is it direct break?
1500+ 1C22 A4                   and     H
1501+ 1C23 3C                   inc     A               ; Line is -1 if direct break
1502+ 1C24 CA 30 1C             jp      Z,NOLIN         ; Yes - No line number
1503+ 1C27 22 B7 52             ld      (ERRLIN),HL     ; Save line of break
1504+ 1C2A 2A B3 52             ld      HL,(BRKLIN)     ; Get point of break
1505+ 1C2D 22 B9 52             ld      (CONTAD),HL     ; Save point to CONTinue
1506+ 1C30 AF           NOLIN:  xor     A
1507+ 1C31 32 A3 51             ld      (CTLOFG),A      ; Enable output
1508+ 1C34 CD 86 1E             call    STTLIN          ; Start a new line
1509+ 1C37 F1                   pop     AF              ; Restore STOP / END status
1510+ 1C38 21 2B 16             ld      HL,BRKMSG       ; "Break" message
1511+ 1C3B C2 41 1C             jp      NZ,ERRINT       ; "in line" wanted?
1512+ 1C3E C3 02 17             jp      PRNTOK          ; Go to command mode
1513+ 1C41 CD 82 16     ERRINT: call    EXITGM          ; exit from graphics mode
1514+ 1C44 C3 E0 16             jp      ERRIN           ; print message
1515+ 1C47
1516+ 1C47
1517+ 1C47 21 FF FF     CONT:   ld      HL,-1           ; reset...
1518+ 1C4A 22 AF 51             ld      (HLPLN),HL      ; ...HELP line register
1519+ 1C4D 2A B9 52             ld      HL,(CONTAD)     ; Get CONTinue address
1520+ 1C50 7C                   ld      A,H             ; Is it zero?
1521+ 1C51 B5                   or      L
1522+ 1C52 1E 20                ld      E,CN            ; ?CN Error
1523+ 1C54 CA BC 16             jp      Z,ERROR         ; Yes - output "?CN Error"
1524+ 1C57 EB                   ex      DE,HL           ; Save code string address
1525+ 1C58 2A B7 52             ld      HL,(ERRLIN)     ; Get line of last break
1526+ 1C5B 22 AD 51             ld      (LINEAT),HL     ; Set up current line number
1527+ 1C5E EB                   ex      DE,HL           ; Restore code string address
1528+ 1C5F C9                   ret                     ; CONTinue where left off
1529+ 1C60
1530+ 1C60 E5           ACCSUM: push    HL              ; Save address in array
1531+ 1C61 2A A4 51             ld      HL,(CHKSUM)     ; Get check sum
1532+ 1C64 06 00                ld      B,$00           ; BC - Value of byte
1533+ 1C66 4F                   ld      C,A
1534+ 1C67 09                   add     HL,BC           ; Add byte to check sum
1535+ 1C68 22 A4 51             ld      (CHKSUM),HL     ; Re-save check sum
1536+ 1C6B E1                   pop     HL              ; Restore address in array
1537+ 1C6C C9                   ret
1538+ 1C6D
1539+ 1C6D 7E           CHKLTR: ld      A,(HL)          ; Get byte
1540+ 1C6E FE 41                cp      'A'             ; < 'a' ?
1541+ 1C70 D8                   ret     C               ; Carry set if not letter
1542+ 1C71 FE 5B                cp      'Z'+1           ; > 'z' ?
1543+ 1C73 3F                   ccf
1544+ 1C74 C9                   ret                     ; Carry set if not letter
1545+ 1C75
1546+ 1C75 CD CB 1B     FPSINT: call    GETCHR          ; Get next character
1547+ 1C78 CD 54 20     POSINT: call    GETNUM          ; Get integer 0 to 32767
1548+ 1C7B CD 61 2E     DEPINT: call    TSTSGN          ; Test sign of FPREG
1549+ 1C7E FA 96 1C             jp      M,FCERR         ; Negative - ?FC Error
1550+ 1C81 3A 33 53     DEINT:  ld      A,(FPEXP)       ; Get integer value to DE
1551+ 1C84 FE 90                cp      $80+$10         ; Exponent in range (16 bits)?
1552+ 1C86 DA 09 2F             jp      C,FPINT         ; Yes - convert it
1553+ 1C89 01 80 90             ld      BC,$9080        ; BCDE = -32768
1554+ 1C8C 11 00 00             ld      DE,$0000
1555+ 1C8F E5                   push    HL              ; Save code string address
1556+ 1C90 CD DC 2E             call    CMPNUM          ; Compare FPREG with BCDE
1557+ 1C93 E1                   pop     HL              ; Restore code string address
1558+ 1C94 51                   ld      D,C             ; MSB to D
1559+ 1C95 C8                   ret     Z               ; Return if in range
1560+ 1C96 1E 08        FCERR:  ld      E,FC            ; ?FC Error
1561+ 1C98 C3 BC 16             jp      ERROR           ; Output error-
1562+ 1C9B
1563+ 1C9B 2B           ATOH:   dec     HL              ; ASCII number to DE binary
1564+ 1C9C 11 00 00     GETLN:  ld      DE,$0000        ; Get number to DE
1565+ 1C9F CD CB 1B     GTLNLP: call    GETCHR          ; Get next character
1566+ 1CA2 D0                   ret     NC              ; Exit if not a digit
1567+ 1CA3 E5                   push    HL              ; Save code string address
1568+ 1CA4 F5                   push    AF              ; Save digit
1569+ 1CA5 21 98 19             ld      HL,65529/10     ; Largest number 65529
1570+ 1CA8 CD 84 19             call    CPDEHL          ; Number in range?
1571+ 1CAB DA A8 16             jp      C,SNERR         ; No - ?SN Error
1572+ 1CAE 62                   ld      H,D             ; HL = Number
1573+ 1CAF 6B                   ld      L,E
1574+ 1CB0 19                   add     HL,DE           ; Times 2
1575+ 1CB1 29                   add     HL,HL           ; Times 4
1576+ 1CB2 19                   add     HL,DE           ; Times 5
1577+ 1CB3 29                   add     HL,HL           ; Times 10
1578+ 1CB4 F1                   pop     AF              ; Restore digit
1579+ 1CB5 D6 30                sub     '0'             ; Make it 0 to 9
1580+ 1CB7 5F                   ld      E,A             ; DE = Value of digit
1581+ 1CB8 16 00                ld      D,0
1582+ 1CBA 19                   add     HL,DE           ; Add to number
1583+ 1CBB EB                   ex      DE,HL           ; Number to DE
1584+ 1CBC E1                   pop     HL              ; Restore code string address
1585+ 1CBD C3 9F 1C             jp      GTLNLP          ; Go to next character
1586+ 1CC0
1587+ 1CC0 CA DE 17     CLEAR:  jp      Z,INTVAR        ; Just "CLEAR" Keep parameters
1588+ 1CC3 CD 54 20             call    GETNUM          ; Evaluate a number
1589+ 1CC6 CD 81 1C             call    DEINT           ; Get integer -32768 to 32767 into DE
1590+ 1CC9 2B                   dec     HL              ; Cancel increment
1591+ 1CCA CD CB 1B             call    GETCHR          ; Get next character
1592+ 1CCD E5                   push    HL              ; Save code string address
1593+ 1CCE 2A 94 52             ld      HL,(LSTRAM)     ; Get end of RAM
1594+ 1CD1 CA E9 1C             jp      Z,STORED        ; No value given - Use stored
1595+ 1CD4 E1                   pop     HL              ; Restore code string address
1596+ 1CD5 CD 8A 19             call    CHKSYN          ; Check for comma
1597+ 1CD8 2C                   defb    ','
1598+ 1CD9 D5                   push    DE              ; Save number
1599+ 1CDA CD 54 20             call    GETNUM          ; Evaluate a number
1600+ 1CDD CD 81 1C             call    DEINT           ; Get integer -32768 to 32767 into DE
1601+ 1CE0 2B                   dec     HL              ; Cancel increment
1602+ 1CE1 CD CB 1B             call    GETCHR          ; Get next character
1603+ 1CE4 C2 A8 16             jp      NZ,SNERR        ; ?SN Error if more on line
1604+ 1CE7 E3                   ex      (SP),HL         ; Save code string address
1605+ 1CE8 EB                   ex      DE,HL           ; Number to DE
1606+ 1CE9 7D           STORED: ld      A,L             ; Get LSB of new RAM top
1607+ 1CEA 93                   sub     E               ; Subtract LSB of string space
1608+ 1CEB 5F                   ld      E,A             ; Save LSB
1609+ 1CEC 7C                   ld      A,H             ; Get MSB of new RAM top
1610+ 1CED 9A                   sbc     A,D             ; Subtract MSB of string space
1611+ 1CEE 57                   ld      D,A             ; Save MSB
1612+ 1CEF DA 7D 16             jp      C,OMERR         ; ?OM Error if not enough mem
1613+ 1CF2 E5                   push    HL              ; Save RAM top
1614+ 1CF3 2A 22 53             ld      HL,(PROGND)     ; Get program end
1615+ 1CF6 01 28 00             ld      BC,$28          ; 40 Bytes minimum working RAM
1616+ 1CF9 09                   add     HL,BC           ; Get lowest address
1617+ 1CFA CD 84 19             call    CPDEHL          ; Enough memory?
1618+ 1CFD D2 7D 16             jp      NC,OMERR        ; No - ?OM Error
1619+ 1D00 EB                   ex      DE,HL           ; RAM top to HL
1620+ 1D01 22 AB 51             ld      (STRSPC),HL     ; Set new string space
1621+ 1D04 E1                   pop     HL              ; End of memory to use
1622+ 1D05 22 94 52             ld      (LSTRAM),HL     ; Set new top of RAM
1623+ 1D08 E1                   pop     HL              ; Restore code string address
1624+ 1D09 C3 DE 17             jp      INTVAR          ; Initialise variables
1625+ 1D0C
1626+ 1D0C E5           RUN:    push    HL              ; store HL
1627+ 1D0D 21 FF FF             ld      HL,-1           ; reset...
1628+ 1D10 22 AF 51             ld      (HLPLN),HL      ; ...HELP line register
1629+ 1D13 E1                   pop     HL              ; retrieve HL
1630+ 1D14 CA DA 17             jp      Z,RUNFST        ; RUN from start if just RUN
1631+ 1D17 CD DE 17             call    INTVAR          ; Initialise variables
1632+ 1D1A 01 8B 1B             ld      BC,RUNCNT       ; Execution driver loop
1633+ 1D1D C3 30 1D             jp      RUNLIN          ; RUN from line number
1634+ 1D20
1635+ 1D20 0E 03        GOSUB:  ld      C,$03           ; 3 Levels of stack needed
1636+ 1D22 CD 65 16             call    CHKSTK          ; Check for 3 levels of stack
1637+ 1D25 C1                   pop     BC              ; Get return address
1638+ 1D26 E5                   push    HL              ; Save code string for RETURN
1639+ 1D27 E5                   push    HL              ; And for GOSUB routine
1640+ 1D28 2A AD 51             ld      HL,(LINEAT)     ; Get current line
1641+ 1D2B E3                   ex      (SP),HL         ; Into stack - Code string out
1642+ 1D2C 3E 8C                ld      A,ZGOSUB        ; "GOSUB" token
1643+ 1D2E F5                   push    AF              ; Save token
1644+ 1D2F 33                   inc     SP              ; Don't save flags
1645+ 1D30
1646+ 1D30 C5           RUNLIN: push    BC              ; Save return address
1647+ 1D31 CD 9B 1C     GOTO:   call    ATOH            ; ASCII number to DE binary
1648+ 1D34 CD 76 1D             call    REM             ; Get end of line
1649+ 1D37 E5                   push    HL              ; Save end of line
1650+ 1D38 2A AD 51             ld      HL,(LINEAT)     ; Get current line
1651+ 1D3B CD 84 19             call    CPDEHL          ; Line after current?
1652+ 1D3E E1                   pop     HL              ; Restore end of line
1653+ 1D3F 23                   inc     HL              ; Start of next line
1654+ 1D40 DC B1 17             call    C,SRCHLP        ; Line is after current line
1655+ 1D43 D4 AE 17             call    NC,SRCHLN       ; Line is before current line
1656+ 1D46 60                   ld      H,B             ; Set up code string address
1657+ 1D47 69                   ld      L,C
1658+ 1D48 2B                   dec     HL              ; Incremented after
1659+ 1D49 D8                   ret     C               ; Line found
1660+ 1D4A 1E 0E        ULERR:  ld      E,UL            ; ?UL Error
1661+ 1D4C C3 BC 16             jp      ERROR           ; Output error message
1662+ 1D4F
1663+ 1D4F C0           RETURN: ret     NZ              ; Return if not just RETURN
1664+ 1D50 16 FF                ld      D,-1            ; Flag "GOSUB" search
1665+ 1D52 CD 31 16             call    BAKSTK          ; Look "GOSUB" block
1666+ 1D55 F9                   ld      SP,HL           ; Kill all FORs in subroutine
1667+ 1D56 FE 8C                cp      ZGOSUB          ; Test for "GOSUB" token
1668+ 1D58 1E 04                ld      E,RG            ; ?RG Error
1669+ 1D5A C2 BC 16             jp      NZ,ERROR        ; Error if no "GOSUB" found
1670+ 1D5D E1                   pop     HL              ; Get RETURN line number
1671+ 1D5E 22 AD 51             ld      (LINEAT),HL     ; Save as current
1672+ 1D61 23                   inc     HL              ; Was it from direct statement?
1673+ 1D62 7C                   ld      A,H
1674+ 1D63 B5                   or      L               ; Return to line
1675+ 1D64 C2 6E 1D             jp      NZ,RETLIN       ; No - Return to line
1676+ 1D67 3A B1 52             ld      A,(LSTBIN)      ; Any INPUT in subroutine?
1677+ 1D6A B7                   or      A               ; If so buffer is corrupted
1678+ 1D6B C2 01 17             jp      NZ,POPNOK       ; Yes - Go to command mode
1679+ 1D6E 21 8B 1B     RETLIN: ld      HL,RUNCNT       ; Execution driver loop
1680+ 1D71 E3                   ex      (SP),HL         ; Into stack - Code string out
1681+ 1D72 3E                   defb    $3E             ; Skip "pop HL"
1682+ 1D73 E1           NXTDTA: pop     HL              ; Restore code string address
1683+ 1D74
1684+ 1D74 01 3A        DATA:   defb    $01,$3A         ; ':' End of statement (stands for LD BC,$0E3A - NOP)
1685+ 1D76 0E 00        REM:    ld      C,$00           ; 00  End of statement
1686+ 1D78 06 00                ld      B,$00
1687+ 1D7A 79           NXTSTL: ld      A,C             ; Statement and byte
1688+ 1D7B 48                   ld      C,B
1689+ 1D7C 47                   ld      B,A             ; Statement end byte
1690+ 1D7D 7E           NXTSTT: ld      A,(HL)          ; Get byte
1691+ 1D7E B7                   or      A               ; End of line?
1692+ 1D7F C8                   ret     Z               ; Yes - Exit
1693+ 1D80 B8                   cp      B               ; End of statement?
1694+ 1D81 C8                   ret     Z               ; Yes - Exit
1695+ 1D82 23                   inc     HL              ; Next byte
1696+ 1D83 FE 22                cp      $22             ; '"'             ; Literal string?
1697+ 1D85 CA 7A 1D             jp      Z,NXTSTL        ; Yes - Look for another '"'
1698+ 1D88 C3 7D 1D             jp      NXTSTT          ; Keep looking
1699+ 1D8B
1700+ 1D8B CD 63 22     LET:    call    GETVAR          ; Get variable name
1701+ 1D8E CD 8A 19             call    CHKSYN          ; Make sure "=" follows
1702+ 1D91 C8                   defb    ZEQUAL          ; "=" token
1703+ 1D92 D5                   push    DE              ; Save address of variable
1704+ 1D93 3A 92 52             ld      A,(TYPE)        ; Get data type
1705+ 1D96 F5                   push    AF              ; Save type
1706+ 1D97 CD 66 20             call    EVAL            ; Evaluate expression
1707+ 1D9A F1                   pop     AF              ; Restore type
1708+ 1D9B E3                   ex      (SP),HL         ; Save code - Get var addr
1709+ 1D9C 22 B3 52             ld      (BRKLIN),HL     ; Save address of variable
1710+ 1D9F 1F                   rra                     ; Adjust type
1711+ 1DA0 CD 59 20             call    CHKTYP          ; Check types are the same
1712+ 1DA3 CA DE 1D             jp      Z,LETNUM        ; Numeric - Move value
1713+ 1DA6 E5           LETSTR: push    HL              ; Save address of string var
1714+ 1DA7 2A 30 53             ld      HL,(FPREG)      ; Pointer to string entry
1715+ 1DAA E5                   push    HL              ; Save it on stack
1716+ 1DAB 23                   inc     HL              ; Skip over length
1717+ 1DAC 23                   inc     HL
1718+ 1DAD 5E                   ld      E,(HL)          ; LSB of string address
1719+ 1DAE 23                   inc     HL
1720+ 1DAF 56                   ld      D,(HL)          ; MSB of string address
1721+ 1DB0 2A 33 52             ld      HL,(BASTXT)     ; Point to start of program
1722+ 1DB3 CD 84 19             call    CPDEHL          ; Is string before program?
1723+ 1DB6 D2 CD 1D             jp      NC,CRESTR       ; Yes - Create string entry
1724+ 1DB9 2A AB 51             ld      HL,(STRSPC)     ; Point to string space
1725+ 1DBC CD 84 19             call    CPDEHL          ; Is string literal in program?
1726+ 1DBF D1                   pop     DE              ; Restore address of string
1727+ 1DC0 D2 D5 1D             jp      NC,MVSTPT       ; Yes - Set up pointer
1728+ 1DC3 21 A4 52             ld      HL,TMPSTR       ; Temporary string pool
1729+ 1DC6 CD 84 19             call    CPDEHL          ; Is string in temporary pool?
1730+ 1DC9 D2 D5 1D             jp      NC,MVSTPT       ; No - Set up pointer
1731+ 1DCC 3E                   defb    $3E             ; Skip "pop DE"
1732+ 1DCD D1           CRESTR: pop     DE              ; Restore address of string
1733+ 1DCE CD BD 26             call    BAKTMP          ; Back to last tmp-str entry
1734+ 1DD1 EB                   ex      DE,HL           ; Address of string entry
1735+ 1DD2 CD F6 24             call    SAVSTR          ; Save string in string area
1736+ 1DD5 CD BD 26     MVSTPT: call    BAKTMP          ; Back to last tmp-str entry
1737+ 1DD8 E1                   pop     HL              ; Get string pointer
1738+ 1DD9 CD BC 2E             call    DETHL4          ; Move string pointer to var
1739+ 1DDC E1                   pop     HL              ; Restore code string address
1740+ 1DDD C9                   ret
1741+ 1DDE
1742+ 1DDE E5           LETNUM: push    HL              ; Save address of variable
1743+ 1DDF CD B9 2E             call    FPTHL           ; Move value to variable
1744+ 1DE2 D1                   pop     DE              ; Restore address of variable
1745+ 1DE3 E1                   pop     HL              ; Restore code string address
1746+ 1DE4 C9                   ret
1747+ 1DE5
1748+ 1DE5 CD DA 28     ON:     call    GETINT          ; Get integer 0-255
1749+ 1DE8 7E                   ld      A,(HL)          ; Get "GOTO" or "GOSUB" token
1750+ 1DE9 47                   ld      B,A             ; Save in B
1751+ 1DEA FE 8C                cp      ZGOSUB          ; "GOSUB" token?
1752+ 1DEC CA F4 1D             jp      Z,ONGO          ; Yes - Find line number
1753+ 1DEF CD 8A 19             call    CHKSYN          ; Make sure it's "GOTO"
1754+ 1DF2 88                   defb    ZGOTO           ; "GOTO" token
1755+ 1DF3 2B                   dec     HL              ; Cancel increment
1756+ 1DF4 4B           ONGO:   ld      C,E             ; Integer of branch value
1757+ 1DF5 0D           ONGOLP: dec     C               ; Count branches
1758+ 1DF6 78                   ld      A,B             ; Get "GOTO" or "GOSUB" token
1759+ 1DF7 CA B3 1B             jp      Z,ONJMP         ; Go to that line if right one
1760+ 1DFA CD 9C 1C             call    GETLN           ; Get line number to DE
1761+ 1DFD FE 2C                cp      ','             ; Another line number?
1762+ 1DFF C0                   ret     NZ              ; No - Drop through
1763+ 1E00 C3 F5 1D             jp      ONGOLP          ; Yes - loop
1764+ 1E03
1765+ 1E03 CD 66 20     IF:     call    EVAL            ; Evaluate expression
1766+ 1E06 7E                   ld      A,(HL)          ; Get token
1767+ 1E07 FE 88                cp      ZGOTO           ; "GOTO" token?
1768+ 1E09 CA 11 1E             jp      Z,IFGO          ; Yes - Get line
1769+ 1E0C CD 8A 19             call    CHKSYN          ; Make sure it's "THEN"
1770+ 1E0F BA                   defb    ZTHEN           ; "THEN" token
1771+ 1E10 2B                   dec     HL              ; Cancel increment
1772+ 1E11 CD 57 20     IFGO:   call    TSTNUM          ; Make sure it's numeric
1773+ 1E14 CD 61 2E             call    TSTSGN          ; Test state of expression
1774+ 1E17 CA 23 1E             jp      Z,IF1           ; False - Jump over
1775+ 1E1A CD CB 1B     IF0:    call    GETCHR          ; Get next character
1776+ 1E1D DA 31 1D             jp      C,GOTO          ; Number - GOTO that line
1777+ 1E20 C3 B2 1B             jp      IFJMP           ; Otherwise do statement
1778+ 1E23 0E AE        IF1:    ld      C,ZELSE
1779+ 1E25 CD 78 1D             call    REM+2           ; check statement
1780+ 1E28 B7                   or      A               ; end of line?
1781+ 1E29 C8                   ret     Z               ; yes, leave
1782+ 1E2A FE AE                cp      ZELSE
1783+ 1E2C 20 F5                jr      NZ,IF1          ; ELSE not found, continue check
1784+ 1E2E C3 1A 1E             jp      IF0             ; return to IF
1785+ 1E31
1786+ 1E31
1787+ 1E31 2B           MRPRNT: dec     HL              ; dec 'cos GETCHR INCs
1788+ 1E32 CD CB 1B             call    GETCHR          ; Get next character
1789+ 1E35 CA 98 1E     PRINT:  jp      Z,PRNTCRLF      ; CRLF if just PRINT
1790+ 1E38 C8           PRNTLP: ret     Z               ; End of list - Exit
1791+ 1E39 FE B6                cp      ZTAB            ; "TAB(" token?
1792+ 1E3B CA C0 1E             jp      Z,DOTAB         ; Yes - Do TAB routine
1793+ 1E3E FE B9                cp      ZSPC            ; "SPC(" token?
1794+ 1E40 CA C0 1E             jp      Z,DOTAB         ; Yes - Do SPC routine
1795+ 1E43 E5                   push    HL              ; Save code string address
1796+ 1E44 FE 2C                cp      ','             ; Comma?
1797+ 1E46 CA A7 1E             jp      Z,DOCOM         ; Yes - Move to next zone
1798+ 1E49 FE 3B                cp      ';'             ; Semi-colon?
1799+ 1E4B CA E4 1E             jp      Z,NEXITM        ; Do semi-colon routine
1800+ 1E4E C1                   pop     BC              ; Code string address to BC
1801+ 1E4F CD 66 20             call    EVAL            ; Evaluate expression
1802+ 1E52 E5                   push    HL              ; Save code string address
1803+ 1E53 3A 92 52             ld      A,(TYPE)        ; Get variable type
1804+ 1E56 B7                   or      A               ; Is it a string variable?
1805+ 1E57 C2 7F 1E             jp      NZ,PRNTST       ; Yes - Output string contents
1806+ 1E5A CD 06 30             call    NUMASC          ; Convert number to text
1807+ 1E5D CD 1A 25             call    CRTST           ; Create temporary string
1808+ 1E60 36 00                ld      (HL),NLLCR      ; Followed by a NULL char (was SPC, space)
1809+ 1E62 2A 30 53             ld      HL,(FPREG)      ; Get length of output
1810+ 1E65 34                   inc     (HL)            ; Plus 1 for the space
1811+ 1E66 2A 30 53             ld      HL,(FPREG)      ; < Not needed >
1812+ 1E69 3A A0 51             ld      A,(LWIDTH)      ; Get width of line
1813+ 1E6C 47                   ld      B,A             ; To B
1814+ 1E6D 04                   inc     B               ; Width 255 (No limit)?
1815+ 1E6E CA 7B 1E             jp      Z,PRNTNB        ; Yes - Output number string
1816+ 1E71 04                   inc     B               ; Adjust it
1817+ 1E72 3A 90 52             ld      A,(CURPOS)      ; Get cursor position
1818+ 1E75 86                   add     A,(HL)          ; Add length of string
1819+ 1E76 3D                   dec     A               ; Adjust it
1820+ 1E77 B8                   cp      B               ; Will output fit on this line?
1821+ 1E78 D4 98 1E             call    NC,PRNTCRLF     ; No - CRLF first
1822+ 1E7B CD 5F 25     PRNTNB: call    PRS1            ; Output string at (HL)
1823+ 1E7E AF                   xor     A               ; Skip call by setting 'z' flag
1824+ 1E7F C4 5F 25     PRNTST: call    NZ,PRS1         ; Output string at (HL)
1825+ 1E82 E1                   pop     HL              ; Restore code string address
1826+ 1E83 C3 31 1E             jp      MRPRNT          ; See if more to PRINT
1827+ 1E86
1828+ 1E86 3A 90 52     STTLIN: ld      A,(CURPOS)      ; Make sure on new line
1829+ 1E89 B7                   or      A               ; Already at start?
1830+ 1E8A C8                   ret     Z               ; Yes - Do nothing
1831+ 1E8B C3 98 1E             jp      PRNTCRLF        ; Start a new line
1832+ 1E8E
1833+ 1E8E AF           ENDINP: xor     A
1834+ 1E8F 32 16 53             ld      (KBDNPT),A      ; char is not from keyboard
1835+ 1E92 77                   ld      (HL),A          ; Mark end of buffer
1836+ 1E93 21 35 52             ld      HL,BUFFER-1     ; Point to buffer
1837+ 1E96 18 0A                jr      CNTEND
1838+ 1E98 3E 0D        PRNTCRLF:ld     A,CR            ; Load a CR
1839+ 1E9A CD 95 19             call    OUTC            ; Output character
1840+ 1E9D 3E 0A                ld      A,LF            ; Load a LF
1841+ 1E9F CD 95 19             call    OUTC            ; Output character
1842+ 1EA2 AF           CNTEND: xor     A               ; Set to position 0
1843+ 1EA3 32 90 52             ld      (CURPOS),A      ; Store it
1844+ 1EA6 C9                   ret                     ; return to caller
1845+ 1EA7
1846+ 1EA7 3A A1 51     DOCOM:  ld      A,(COMMAN)      ; Get comma width
1847+ 1EAA 47                   ld      B,A             ; Save in B
1848+ 1EAB 3A D1 52             ld      A,(SCR_CURS_X)  ; Get current position
1849+ 1EAE B8                   cp      B               ; Within the limit?
1850+ 1EAF D4 98 1E             call    NC,PRNTCRLF     ; No - output CRLF
1851+ 1EB2 D2 E4 1E             jp      NC,NEXITM       ; Get next item
1852+ 1EB5 D6 0A        ZONELP: sub     $0A             ; Next zone of 10 characters
1853+ 1EB7 D2 B5 1E             jp      NC,ZONELP       ; Repeat if more zones
1854+ 1EBA 2F                   cpl                     ; Number of null chars to output
1855+ 1EBB 0E 00                ld      C,NLLCR         ; null char
1856+ 1EBD C3 DA 1E             jp      ASPCS           ; Output them
1857+ 1EC0
1858+ 1EC0 F5           DOTAB:  push    AF              ; Save token
1859+ 1EC1 CD D7 28             call    FNDNUM          ; Evaluate expression
1860+ 1EC4 CD 8A 19             call    CHKSYN          ; Make sure ")" follows
1861+ 1EC7 29                   defb    ')'
1862+ 1EC8 2B                   dec     HL              ; Back space on to ")"
1863+ 1EC9 F1                   pop     AF              ; Restore token
1864+ 1ECA 0E 00                ld      C,NLLCR         ; for SPC we use NULL char (was SPACE)
1865+ 1ECC D6 B9                sub     ZSPC            ; Was it "SPC(" ?
1866+ 1ECE E5                   push    HL              ; Save code string address
1867+ 1ECF CA D5 1E             jp      Z,DOSPC         ; Yes - Do 'E' spaces
1868+ 1ED2 3A D1 52             ld      A,(SCR_CURS_X)  ; Get current X position
1869+ 1ED5 2F           DOSPC:  cpl                     ; Number of spaces to print to
1870+ 1ED6 83                   add     A,E             ; Total number to print
1871+ 1ED7 D2 E4 1E             jp      NC,NEXITM       ; TAB < Current POS(X)
1872+ 1EDA 3C           ASPCS:  inc     A               ; Output A spaces
1873+ 1EDB 47                   ld      B,A             ; Save number to print
1874+ 1EDC 79           SPCLP:  ld      A,C             ; char to print
1875+ 1EDD CD 95 19             call    OUTC            ; Output character in A
1876+ 1EE0 05                   dec     B               ; Count them
1877+ 1EE1 C2 DC 1E             jp      NZ,SPCLP        ; Repeat if more
1878+ 1EE4 E1           NEXITM: pop     HL              ; Restore code string address
1879+ 1EE5 CD CB 1B             call    GETCHR          ; Get next character
1880+ 1EE8 C3 38 1E             jp      PRNTLP          ; More to print
1881+ 1EEB
1882+ 1EEB 3F 52 65 64  REDO:   defb    "?Redo from start",CR,0
1882+ 1EEF 6F 20 66 72
1882+ 1EF3 6F 6D 20 73
1882+ 1EF7 74 61 72 74
1882+ 1EFB 0D 00
1883+ 1EFD
1884+ 1EFD 3A B2 52     BADINP: ld      A,(READFG)      ; READ or INPUT?
1885+ 1F00 B7                   or      A
1886+ 1F01 C2 A2 16             jp      NZ,DATSNR       ; READ - ?SN Error
1887+ 1F04 C1                   pop     BC              ; Throw away code string addr
1888+ 1F05 21 EB 1E             ld      HL,REDO         ; "Redo from start" message
1889+ 1F08 CD 5C 25             call    PRS             ; Output string
1890+ 1F0B C3 0D 18             jp      DOAGN           ; Do last INPUT again
1891+ 1F0E
1892+ 1F0E CD C7 24     INPUT:  call    IDTEST          ; Test for illegal direct
1893+ 1F11 7E                   ld      A,(HL)          ; Get character after "INPUT"
1894+ 1F12 FE 22                cp      $22             ; '"' ; Is there a prompt string?
1895+ 1F14 3E 00                ld      A,$00           ; Clear A and leave flags
1896+ 1F16 32 A3 51             ld      (CTLOFG),A      ; Enable output
1897+ 1F19 C2 28 1F             jp      NZ,NOPMPT       ; No prompt - get input
1898+ 1F1C CD 1B 25             call    QTSTR           ; Get string terminated by '"'
1899+ 1F1F CD 8A 19             call    CHKSYN          ; Check for ';' after prompt
1900+ 1F22 3B                   defb    ";"
1901+ 1F23 E5                   push    HL              ; Save code string address
1902+ 1F24 CD 5F 25             call    PRS1            ; Output prompt string
1903+ 1F27 3E                   defb    $3E             ; Skip "push HL"
1904+ 1F28 E5           NOPMPT: push    HL              ; Save code string address
1905+ 1F29 CD 11 18             call    PROMPT          ; Get input with "? " prompt
1906+ 1F2C C1                   pop     BC              ; Restore code string address
1907+ 1F2D DA 1A 1C             jp      C,INPBRK        ; Break pressed - Exit
1908+ 1F30 23                   inc     HL              ; Next byte
1909+ 1F31 7E                   ld      A,(HL)          ; Get it
1910+ 1F32 B7                   or      A               ; End of line?
1911+ 1F33 2B                   dec     HL              ; Back again
1912+ 1F34 C5                   push    BC              ; Re-save code string address
1913+ 1F35 CD 07 09             call    CURSOR_OFF      ; disable cursor
1914+ 1F38 CA 73 1D             jp      Z,NXTDTA        ; Yes - Find next DATA stmt
1915+ 1F3B 36 2C                ld      (HL),','        ; Store comma as separator
1916+ 1F3D C3 45 1F             jp      NXTITM          ; Get next item
1917+ 1F40
1918+ 1F40 E5           READ:   push    HL              ; Save code string address
1919+ 1F41 2A 28 53             ld      HL,(NXTDAT)     ; Next DATA statement
1920+ 1F44 F6                   defb    $F6             ; Flag "READ"
1921+ 1F45 AF           NXTITM: xor     A               ; Flag "INPUT"
1922+ 1F46 32 B2 52             ld      (READFG),A      ; Save "READ"/"INPUT" flag
1923+ 1F49 E3                   ex      (SP),HL         ; Get code str' , Save pointer
1924+ 1F4A C3 51 1F             jp      GTVLUS          ; Get values
1925+ 1F4D
1926+ 1F4D CD 8A 19     NEDMOR: call    CHKSYN          ; Check for comma between items
1927+ 1F50 2C                   defb    ','
1928+ 1F51 CD 63 22     GTVLUS: call    GETVAR          ; Get variable name
1929+ 1F54 E3                   ex      (SP),HL         ; Save code str" , Get pointer
1930+ 1F55 D5                   push    DE              ; Save variable address
1931+ 1F56 7E                   ld      A,(HL)          ; Get next "INPUT"/"DATA" byte
1932+ 1F57 FE 2C                cp      ','             ; Comma?
1933+ 1F59 CA 79 1F             jp      Z,ANTVLU        ; Yes - Get another value
1934+ 1F5C 3A B2 52             ld      A,(READFG)      ; Is it READ?
1935+ 1F5F B7                   or      A
1936+ 1F60 C2 E5 1F             jp      NZ,FDTLP        ; Yes - Find next DATA stmt
1937+ 1F63 3E 3F                ld      A,'?'           ; More INPUT needed
1938+ 1F65 CD 95 19             call    OUTC            ; Output character
1939+ 1F68 CD 11 18             call    PROMPT          ; Get INPUT with prompt
1940+ 1F6B D1                   pop     DE              ; Variable address
1941+ 1F6C C1                   pop     BC              ; Code string address
1942+ 1F6D DA 1A 1C             jp      C,INPBRK        ; Break pressed
1943+ 1F70 23                   inc     HL              ; Point to next DATA byte
1944+ 1F71 7E                   ld      A,(HL)          ; Get byte
1945+ 1F72 B7                   or      A               ; Is it zero (No input) ?
1946+ 1F73 2B                   dec     HL              ; Back space INPUT pointer
1947+ 1F74 C5                   push    BC              ; Save code string address
1948+ 1F75 CA 73 1D             jp      Z,NXTDTA        ; Find end of buffer
1949+ 1F78 D5                   push    DE              ; Save variable address
1950+ 1F79 3A 92 52     ANTVLU: ld      A,(TYPE)        ; Check data type
1951+ 1F7C B7                   or      A               ; Is it numeric?
1952+ 1F7D CA A3 1F             jp      Z,INPBIN        ; Yes - Convert to binary
1953+ 1F80 CD CB 1B             call    GETCHR          ; Get next character
1954+ 1F83 57                   ld      D,A             ; Save input character
1955+ 1F84 47                   ld      B,A             ; Again
1956+ 1F85 FE 22                cp      $22             ; '"'     ; Start of literal sting?
1957+ 1F87 CA 97 1F             jp      Z,STRENT        ; Yes - Create string entry
1958+ 1F8A 3A B2 52             ld      A,(READFG)      ; "READ" or "INPUT" ?
1959+ 1F8D B7                   or      A
1960+ 1F8E 57                   ld      D,A             ; Save 00 if "INPUT"
1961+ 1F8F CA 94 1F             jp      Z,ITMSEP        ; "INPUT" - End with 00
1962+ 1F92 16 3A                ld      D,':'           ; "DATA" - End with 00 or ':'
1963+ 1F94 06 2C        ITMSEP: ld      B,','           ; Item separator
1964+ 1F96 2B                   dec     HL              ; Back space for DTSTR
1965+ 1F97 CD 1E 25     STRENT: call    DTSTR           ; Get string terminated by D
1966+ 1F9A EB                   ex      DE,HL           ; String address to DE
1967+ 1F9B 21 AE 1F             ld      HL,LTSTND       ; Where to go after LETSTR
1968+ 1F9E E3                   ex      (SP),HL         ; Save HL , get input pointer
1969+ 1F9F D5                   push    DE              ; Save address of string
1970+ 1FA0 C3 A6 1D             jp      LETSTR          ; Assign string to variable
1971+ 1FA3
1972+ 1FA3 CD CB 1B     INPBIN: call    GETCHR          ; Get next character
1973+ 1FA6 CD 68 2F             call    ASCTFP          ; Convert ASCII to FP number
1974+ 1FA9 E3                   ex      (SP),HL         ; Save input ptr, Get var addr
1975+ 1FAA CD B9 2E             call    FPTHL           ; Move FPREG to variable
1976+ 1FAD E1                   pop     HL              ; Restore input pointer
1977+ 1FAE 2B           LTSTND: dec     HL              ; dec 'cos GETCHR INCs
1978+ 1FAF CD CB 1B             call    GETCHR          ; Get next character
1979+ 1FB2 CA BA 1F             jp      Z,MORDT         ; End of line - More needed?
1980+ 1FB5 FE 2C                cp      ','             ; Another value?
1981+ 1FB7 C2 FD 1E             jp      NZ,BADINP       ; No - Bad input
1982+ 1FBA E3           MORDT:  ex      (SP),HL         ; Get code string address
1983+ 1FBB 2B                   dec     HL              ; dec 'cos GETCHR INCs
1984+ 1FBC CD CB 1B             call    GETCHR          ; Get next character
1985+ 1FBF C2 4D 1F             jp      NZ,NEDMOR       ; More needed - Get it
1986+ 1FC2 D1                   pop     DE              ; Restore DATA pointer
1987+ 1FC3 3A B2 52             ld      A,(READFG)      ; "READ" or "INPUT" ?
1988+ 1FC6 B7                   or      A
1989+ 1FC7 EB                   ex      DE,HL           ; DATA pointer to HL
1990+ 1FC8 C2 F1 1B             jp      NZ,UPDATA       ; Update DATA pointer if "READ"
1991+ 1FCB D5                   push    DE              ; Save code string address
1992+ 1FCC B6                   or      (HL)            ; More input given?
1993+ 1FCD 21 D5 1F             ld      HL,EXTIG        ; "?Extra ignored" message
1994+ 1FD0 C4 5C 25             call    NZ,PRS          ; Output string if extra given
1995+ 1FD3 E1                   pop     HL              ; Restore code string address
1996+ 1FD4 C9                   ret
1997+ 1FD5
1998+ 1FD5 3F 45 78 74  EXTIG:  defb    "?Extra ignored",CR,0
1998+ 1FD9 72 61 20 69
1998+ 1FDD 67 6E 6F 72
1998+ 1FE1 65 64 0D 00
1999+ 1FE5
2000+ 1FE5 CD 74 1D     FDTLP:  call    DATA            ; Get next statement
2001+ 1FE8 B7                   or      A               ; End of line?
2002+ 1FE9 C2 FE 1F             jp      NZ,FANDT        ; No - See if DATA statement
2003+ 1FEC 23                   inc     HL
2004+ 1FED 7E                   ld      A,(HL)          ; End of program?
2005+ 1FEE 23                   inc     HL
2006+ 1FEF B6                   or      (HL)            ; 00 00 Ends program
2007+ 1FF0 1E 06                ld      E,OD            ; ?OD Error
2008+ 1FF2 CA BC 16             jp      Z,ERROR         ; Yes - Out of DATA
2009+ 1FF5 23                   inc     HL
2010+ 1FF6 5E                   ld      E,(HL)          ; LSB of line number
2011+ 1FF7 23                   inc     HL
2012+ 1FF8 56                   ld      D,(HL)          ; MSB of line number
2013+ 1FF9 EB                   ex      DE,HL
2014+ 1FFA 22 AE 52             ld      (DATLIN),HL     ; Set line of current DATA item
2015+ 1FFD EB                   ex      DE,HL
2016+ 1FFE CD CB 1B     FANDT:  call    GETCHR          ; Get next character
2017+ 2001 FE 83                cp      ZDATA           ; "DATA" token
2018+ 2003 C2 E5 1F             jp      NZ,FDTLP        ; No "DATA" - Keep looking
2019+ 2006 C3 79 1F             jp      ANTVLU          ; Found - Convert input
2020+ 2009
2021+ 2009 11 00 00     NEXT:   ld      DE,$0000        ; In case no index given
2022+ 200C C4 63 22     NEXT1:  call    NZ,GETVAR       ; Get index address
2023+ 200F 22 B3 52             ld      (BRKLIN),HL     ; Save code string address
2024+ 2012 CD 31 16             call    BAKSTK          ; Look for "FOR" block
2025+ 2015 C2 AE 16             jp      NZ,NFERR        ; No "FOR" - ?NF Error
2026+ 2018 F9                   ld      SP,HL           ; Clear nested loops
2027+ 2019 D5                   push    DE              ; Save index address
2028+ 201A 7E                   ld      A,(HL)          ; Get sign of STEP
2029+ 201B 23                   inc     HL
2030+ 201C F5                   push    AF              ; Save sign of STEP
2031+ 201D D5                   push    DE              ; Save index address
2032+ 201E CD 9F 2E             call    PHLTFP          ; Move index value to FPREG
2033+ 2021 E3                   ex      (SP),HL         ; Save address of TO value
2034+ 2022 E5                   push    HL              ; Save address of index
2035+ 2023 CD BB 2B             call    ADDPHL          ; Add STEP to index value
2036+ 2026 E1                   pop     HL              ; Restore address of index
2037+ 2027 CD B9 2E             call    FPTHL           ; Move value to index variable
2038+ 202A E1                   pop     HL              ; Restore address of TO value
2039+ 202B CD B0 2E             call    LOADFP          ; Move TO value to BCDE
2040+ 202E E5                   push    HL              ; Save address of line of FOR
2041+ 202F CD DC 2E             call    CMPNUM          ; Compare index with TO value
2042+ 2032 E1                   pop     HL              ; Restore address of line num
2043+ 2033 C1                   pop     BC              ; Address of sign of STEP
2044+ 2034 90                   sub     B               ; Compare with expected sign
2045+ 2035 CD B0 2E             call    LOADFP          ; BC = Loop stmt,DE = Line num
2046+ 2038 CA 44 20             jp      Z,KILFOR        ; Loop finished - Terminate it
2047+ 203B EB                   ex      DE,HL           ; Loop statement line number
2048+ 203C 22 AD 51             ld      (LINEAT),HL     ; Set loop line number
2049+ 203F 69                   ld      L,C             ; Set code string to loop
2050+ 2040 60                   ld      H,B
2051+ 2041 C3 87 1B             jp      PUTFID          ; Put back "FOR" and continue
2052+ 2044
2053+ 2044 F9           KILFOR: ld      SP,HL           ; Remove "FOR" block
2054+ 2045 2A B3 52             ld      HL,(BRKLIN)     ; Code string after "NEXT"
2055+ 2048 7E                   ld      A,(HL)          ; Get next byte in code string
2056+ 2049 FE 2C                cp      ','             ; More NEXTs ?
2057+ 204B C2 8B 1B             jp      NZ,RUNCNT       ; No - Do next statement
2058+ 204E CD CB 1B             call    GETCHR          ; Position to index name
2059+ 2051 CD 0C 20             call    NEXT1           ; Re-enter NEXT routine
2060+ 2054              ; < will not RETurn to here , Exit to RUNCNT or Loop >
2061+ 2054
2062+ 2054 CD 66 20     GETNUM: call    EVAL            ; Get a numeric expression
2063+ 2057 F6           TSTNUM: defb    $F6             ; Clear carry (numeric)
2064+ 2058 37           TSTSTR: scf                     ; Set carry (string)
2065+ 2059 3A 92 52     CHKTYP: ld      A,(TYPE)        ; Check types match
2066+ 205C 8F                   adc     A,A             ; Expected + actual
2067+ 205D B7                   or      A               ; Clear carry , set parity
2068+ 205E E8                   ret     PE              ; Even parity - Types match
2069+ 205F C3 BA 16             jp      TMERR           ; Different types - Error
2070+ 2062
2071+ 2062 CD 8A 19     OPNPAR: call    CHKSYN          ; Make sure "(" follows
2072+ 2065 28                   defb    '('
2073+ 2066 2B           EVAL:   dec     HL              ; Evaluate expression & save
2074+ 2067 16 00                ld      D,$00           ; Precedence value
2075+ 2069 D5           EVAL1:  push    DE              ; Save precedence
2076+ 206A 0E 01                ld      C,$01
2077+ 206C CD 65 16             call    CHKSTK          ; Check for 1 level of stack
2078+ 206F CD DD 20             call    OPRND           ; Get next expression value
2079+ 2072 22 B5 52     EVAL2:  ld      (NXTOPR),HL     ; Save address of next operator
2080+ 2075 2A B5 52     EVAL3:  ld      HL,(NXTOPR)     ; Restore address of next opr
2081+ 2078 C1                   pop     BC              ; Precedence value and operator
2082+ 2079 78                   ld      A,B             ; Get precedence value
2083+ 207A FE 78                cp      $78             ; "AND", "OR", or "XOR" ?
2084+ 207C D4 57 20             call    NC,TSTNUM       ; No - Make sure it's a number
2085+ 207F 7E                   ld      A,(HL)          ; Get next operator / function
2086+ 2080 16 00                ld      D,$00           ; Clear Last relation
2087+ 2082 D6 C7        RLTLP:  sub     ZGTR            ; ">" Token
2088+ 2084 DA 9E 20             jp      C,FOPRND        ; + - * / ^ AND OR XOR - Test it
2089+ 2087 FE 03                cp      ZLTH+1-ZGTR     ; < = >
2090+ 2089 D2 9E 20             jp      NC,FOPRND       ; Function - Call it
2091+ 208C FE 01                cp      ZEQUAL-ZGTR     ; "="
2092+ 208E 17                   rla                     ; <- Test for legal
2093+ 208F AA                   xor     D               ; <- combinations of < = >
2094+ 2090 BA                   cp      D               ; <- by combining last token
2095+ 2091 57                   ld      D,A             ; <- with current one
2096+ 2092 DA A8 16             jp      C,SNERR         ; Error if "<<' '==" or ">>"
2097+ 2095 22 AA 52             ld      (CUROPR),HL     ; Save address of current token
2098+ 2098 CD CB 1B             call    GETCHR          ; Get next character
2099+ 209B C3 82 20             jp      RLTLP           ; Treat the two as one
2100+ 209E
2101+ 209E 7A           FOPRND: ld      A,D             ; < = > found ?
2102+ 209F B7                   or      A
2103+ 20A0 C2 DE 21             jp      NZ,TSTRED       ; Yes - Test for reduction
2104+ 20A3 7E                   ld      A,(HL)          ; Get operator token
2105+ 20A4 22 AA 52             ld      (CUROPR),HL     ; Save operator address
2106+ 20A7 D6 BD                sub     ZPLUS           ; Operator or function?
2107+ 20A9 D8                   ret     C               ; Neither - Exit
2108+ 20AA FE 0A                cp      ZOR+1-ZPLUS     ; Is it + - * / ^ AND XOR OR ?
2109+ 20AC D0                   ret     NC              ; No - Exit
2110+ 20AD 5F                   ld      E,A             ; Coded operator
2111+ 20AE 3A 92 52             ld      A,(TYPE)        ; Get data type
2112+ 20B1 3D                   dec     A               ; FF = numeric , 00 = string
2113+ 20B2 B3                   or      E               ; Combine with coded operator
2114+ 20B3 7B                   ld      A,E             ; Get coded operator
2115+ 20B4 CA 52 26             jp      Z,CONCAT        ; String concatenation
2116+ 20B7 07                   rlca                    ; Times 2
2117+ 20B8 83                   add     A,E             ; Times 3
2118+ 20B9 5F                   ld      E,A             ; To DE (D is 0)
2119+ 20BA 21 23 15             ld      HL,PRITAB       ; Precedence table
2120+ 20BD 19                   add     HL,DE           ; To the operator concerned
2121+ 20BE 78                   ld      A,B             ; Last operator precedence
2122+ 20BF 56                   ld      D,(HL)          ; Get evaluation precedence
2123+ 20C0 BA                   cp      D               ; Compare with eval precedence
2124+ 20C1 D0                   ret     NC              ; Exit if higher precedence
2125+ 20C2 23                   inc     HL              ; Point to routine address
2126+ 20C3 CD 57 20             call    TSTNUM          ; Make sure it's a number
2127+ 20C6
2128+ 20C6 C5           STKTHS: push    BC              ; Save last precedence & token
2129+ 20C7 01 75 20             ld      BC,EVAL3        ; Where to go on prec' break
2130+ 20CA C5                   push    BC              ; Save on stack for return
2131+ 20CB 43                   ld      B,E             ; Save operator
2132+ 20CC 4A                   ld      C,D             ; Save precedence
2133+ 20CD CD 92 2E             call    STAKFP          ; Move value to stack
2134+ 20D0 58                   ld      E,B             ; Restore operator
2135+ 20D1 51                   ld      D,C             ; Restore precedence
2136+ 20D2 4E                   ld      C,(HL)          ; Get LSB of routine address
2137+ 20D3 23                   inc     HL
2138+ 20D4 46                   ld      B,(HL)          ; Get MSB of routine address
2139+ 20D5 23                   inc     HL
2140+ 20D6 C5                   push    BC              ; Save routine address
2141+ 20D7 2A AA 52             ld      HL,(CUROPR)     ; Address of current operator
2142+ 20DA C3 69 20             jp      EVAL1           ; Loop until prec' break
2143+ 20DD
2144+ 20DD AF           OPRND:  xor     A               ; Get operand routine
2145+ 20DE 32 92 52             ld      (TYPE),A        ; Set numeric expected
2146+ 20E1 CD CB 1B             call    GETCHR          ; Get next character
2147+ 20E4 1E 24                ld      E,MO            ; ?MO Error
2148+ 20E6 CA BC 16             jp      Z,ERROR         ; No operand - Error
2149+ 20E9 DA 68 2F             jp      C,ASCTFP        ; Number - Get value
2150+ 20EC CD 6D 1C             call    CHKLTR          ; See if a letter
2151+ 20EF D2 44 21             jp      NC,CONVAR       ; Letter - Find variable
2152+ 20F2 FE 26                cp      '&'             ; &H = HEX, &B = BINARY
2153+ 20F4 20 12                jr      NZ,NOTAMP
2154+ 20F6 CD CB 1B             call    GETCHR          ; Get next character
2155+ 20F9 FE 48                cp      'H'             ; Hex number indicated? [function added]
2156+ 20FB CA D0 3E             jp      Z,HEXTFP        ; Convert Hex to FPREG
2157+ 20FE FE 42                cp      'B'             ; Binary number indicated? [function added]
2158+ 2100 CA 40 3F             jp      Z,BINTFP        ; Convert Bin to FPREG
2159+ 2103 1E 02                ld      E,SN            ; If neither then a ?SN Error
2160+ 2105 CA BC 16             jp      Z,ERROR         ;
2161+ 2108 FE BD        NOTAMP: cp      ZPLUS           ; '+' Token ?
2162+ 210A CA DD 20             jp      Z,OPRND         ; Yes - Look for operand
2163+ 210D FE 2E                cp      '.'             ; '.' ?
2164+ 210F CA 68 2F             jp      Z,ASCTFP        ; Yes - Create FP number
2165+ 2112 FE BE                cp      ZMINUS          ; '-' Token ?
2166+ 2114 CA 33 21             jp      Z,MINUS         ; Yes - Do minus
2167+ 2117 FE 22                cp      $22             ; '"'             ; Literal string ?
2168+ 2119 CA 1B 25             jp      Z,QTSTR         ; Get string terminated by '"'
2169+ 211C FE BB                cp      ZNOT            ; "NOT" Token ?
2170+ 211E CA 3E 22             jp      Z,EVNOT         ; Yes - Eval NOT expression
2171+ 2121 FE B8                cp      ZFN             ; "FN" Token ?
2172+ 2123 CA 7F 24             jp      Z,DOFN          ; Yes - Do FN routine
2173+ 2126 D6 CA                sub     ZSGN            ; Is it a function?
2174+ 2128 D2 55 21             jp      NC,FNOFST       ; Yes - Evaluate function
2175+ 212B CD 62 20     EVLPAR: call    OPNPAR          ; Evaluate expression in "()"
2176+ 212E CD 8A 19             call    CHKSYN          ; Make sure ")" follows
2177+ 2131 29                   defb    ')'
2178+ 2132 C9                   ret
2179+ 2133
2180+ 2133 16 7D        MINUS:  ld      D,$7D           ; '-' precedence
2181+ 2135 CD 69 20             call    EVAL1           ; Evaluate until prec' break
2182+ 2138 2A B5 52             ld      HL,(NXTOPR)     ; Get next operator address
2183+ 213B E5                   push    HL              ; Save next operator address
2184+ 213C CD 8A 2E             call    INVSGN          ; Negate value
2185+ 213F CD 57 20     RETNUM: call    TSTNUM          ; Make sure it's a number
2186+ 2142 E1                   pop     HL              ; Restore next operator address
2187+ 2143 C9                   ret
2188+ 2144
2189+ 2144 CD 63 22     CONVAR: call    GETVAR          ; Get variable address to DE
2190+ 2147 E5           FRMEVL: push    HL              ; Save code string address
2191+ 2148 EB                   ex      DE,HL           ; Variable address to HL
2192+ 2149 22 30 53             ld      (FPREG),HL      ; Save address of variable
2193+ 214C 3A 92 52             ld      A,(TYPE)        ; Get type
2194+ 214F B7                   or      A               ; Numeric?
2195+ 2150 CC 9F 2E             call    Z,PHLTFP        ; Yes - Move contents to FPREG
2196+ 2153 E1                   pop     HL              ; Restore code string address
2197+ 2154 C9                   ret
2198+ 2155
2199+ 2155 06 00        FNOFST: ld      B,$00           ; Get address of function
2200+ 2157 07                   rlca                    ; Double function offset
2201+ 2158 4F                   ld      C,A             ; BC = Offset in function table
2202+ 2159 C5                   push    BC              ; Save adjusted token value
2203+ 215A CD CB 1B             call    GETCHR          ; Get next character
2204+ 215D 79                   ld      A,C             ; Get adjusted token value
2205+ 215E FE 2C                cp      2*(ZPOINT-ZSGN) ; "POINT" token?
2206+ 2160 CA 8E 36             jp      Z,POINT         ; Yes, do "POINT"
2207+ 2163 FE 2E                cp      2*(ZINSTR-ZSGN) ; "INSTR" token?
2208+ 2165 CA 2E 27             jp      Z,INSTR         ; Yes, do "INSTR"
2209+ 2168 FE 3D                cp      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
2210+ 216A DA 86 21             jp      C,FNVAL         ; No - Do function
2211+ 216D CD 62 20             call    OPNPAR          ; Evaluate expression  (X,...
2212+ 2170 CD 8A 19             call    CHKSYN          ; Make sure ',' follows
2213+ 2173 2C                   defb    ','
2214+ 2174 CD 58 20             call    TSTSTR          ; Make sure it's a string
2215+ 2177 EB                   ex      DE,HL           ; Save code string address
2216+ 2178 2A 30 53             ld      HL,(FPREG)      ; Get address of string
2217+ 217B E3                   ex      (SP),HL         ; Save address of string
2218+ 217C E5                   push    HL              ; Save adjusted token value
2219+ 217D EB                   ex      DE,HL           ; Restore code string address
2220+ 217E CD DA 28             call    GETINT          ; Get integer 0-255
2221+ 2181 EB                   ex      DE,HL           ; Save code string address
2222+ 2182 E3                   ex      (SP),HL         ; Save integer,HL = adj' token
2223+ 2183 C3 8E 21             jp      GOFUNC          ; Jump to string function
2224+ 2186
2225+ 2186 CD 2B 21     FNVAL:  call    EVLPAR          ; Evaluate expression
2226+ 2189 E3                   ex      (SP),HL         ; HL = Adjusted token value
2227+ 218A 11 3F 21             ld      DE,RETNUM       ; Return number from function
2228+ 218D D5                   push    DE              ; Save on stack
2229+ 218E 01 E6 12     GOFUNC: ld      BC,FNCTAB       ; Function routine addresses
2230+ 2191 09                   add     HL,BC           ; Point to right address
2231+ 2192 4E                   ld      C,(HL)          ; Get LSB of address
2232+ 2193 23                   inc     HL              ;
2233+ 2194 66                   ld      H,(HL)          ; Get MSB of address
2234+ 2195 69                   ld      L,C             ; Address to HL
2235+ 2196 E9                   jp      (HL)            ; Jump to function
2236+ 2197
2237+ 2197 15           SGNEXP: dec     D               ; Dee to flag negative exponent
2238+ 2198 FE BE                cp      ZMINUS          ; '-' token ?
2239+ 219A C8                   ret     Z               ; Yes - Return
2240+ 219B FE 2D                cp      '-'             ; '-' ASCII ?
2241+ 219D C8                   ret     Z               ; Yes - Return
2242+ 219E 14                   inc     D               ; Inc to flag positive exponent
2243+ 219F FE 2B                cp      '+'             ; '+' ASCII ?
2244+ 21A1 C8                   ret     Z               ; Yes - Return
2245+ 21A2 FE BD                cp      ZPLUS           ; '+' token ?
2246+ 21A4 C8                   ret     Z               ; Yes - Return
2247+ 21A5 2B                   dec     HL              ; dec 'cos GETCHR INCs
2248+ 21A6 C9                   ret                     ; Return "NZ"
2249+ 21A7
2250+ 21A7              ; execute OR, AND, and XOR operations
2251+ 21A7 AF           PAND:   xor     A               ; for AND, Z=1
2252+ 21A8 18 07                jr      CNTLGC
2253+ 21AA AF           POR:    xor     A               ; for OR, Z=0, S=1
2254+ 21AB D6 01                sub     $01
2255+ 21AD 18 02                jr      CNTLGC
2256+ 21AF AF           PXOR:   xor     A               ; for XOR, Z=0, S=0
2257+ 21B0 3C                   inc     A
2258+ 21B1 F5           CNTLGC: push    AF              ; store operand's flags
2259+ 21B2 CD 57 20             call    TSTNUM          ; Make sure it's a number
2260+ 21B5 CD 81 1C             call    DEINT           ; Get integer -32768 to 32767
2261+ 21B8 F1                   pop     AF              ; retrieve operand's flags
2262+ 21B9 EB                   ex      DE,HL           ; <- Get last
2263+ 21BA C1                   pop     BC              ; <-  value
2264+ 21BB E3                   ex      (SP),HL         ; <-  from
2265+ 21BC EB                   ex      DE,HL           ; <-  stack
2266+ 21BD CD A2 2E             call    FPBCDE          ; Move last value to FPREG
2267+ 21C0 F5                   push    AF              ; store operand's flags
2268+ 21C1 CD 81 1C             call    DEINT           ; Get integer -32768 to 32767
2269+ 21C4 F1                   pop     AF              ; retrieve operand's flags
2270+ 21C5 C1                   pop     BC              ; Get value
2271+ 21C6 79                   ld      A,C             ; Get LSB
2272+ 21C7 21 3D 24             ld      HL,ACPASS       ; Address of save AC as current
2273+ 21CA 20 05                jr      NZ,POR1         ; if X/OR, jump over
2274+ 21CC A3           PAND1:  and     E               ; "AND" LSBs
2275+ 21CD 4F                   ld      C,A             ; Save LSB
2276+ 21CE 78                   ld      A,B             ; Get MSB
2277+ 21CF A2                   and     D               ; "AND" MSBs
2278+ 21D0 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2279+ 21D1 F2 D9 21     POR1:   jp      P,PXOR1         ; if S=0, jump to XOR
2280+ 21D4 B3                   or      E               ; "OR" LSBs
2281+ 21D5 4F                   ld      C,A             ; Save LSB
2282+ 21D6 78                   ld      A,B             ; Get MSB
2283+ 21D7 B2                   or      D               ; "OR" MSBs
2284+ 21D8 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2285+ 21D9 AB           PXOR1:  xor     E               ; "XOR" LSBs
2286+ 21DA 4F                   ld      C,A             ; Save LSB
2287+ 21DB 78                   ld      A,B             ; Get MSB
2288+ 21DC AA                   xor     D               ; "XOR" MSBs
2289+ 21DD E9                   jp      (HL)            ; Save AC as current (ACPASS)
2290+ 21DE
2291+ 21DE 21 F0 21     TSTRED: ld      HL,CMPLOG       ; Logical compare routine
2292+ 21E1 3A 92 52             ld      A,(TYPE)        ; Get data type
2293+ 21E4 1F                   rra                     ; Carry set = string
2294+ 21E5 7A                   ld      A,D             ; Get last precedence value
2295+ 21E6 17                   rla                     ; Times 2 plus carry
2296+ 21E7 5F                   ld      E,A             ; To E
2297+ 21E8 16 64                ld      D,$64           ; Relational precedence
2298+ 21EA 78                   ld      A,B             ; Get current precedence
2299+ 21EB BA                   cp      D               ; Compare with last
2300+ 21EC D0                   ret     NC              ; Eval if last was rel' or log'
2301+ 21ED C3 C6 20             jp      STKTHS          ; Stack this one and get next
2302+ 21F0
2303+ 21F0 F2 21        CMPLOG: defw    CMPLG1          ; Compare two values / strings
2304+ 21F2 79           CMPLG1: ld      A,C             ; Get data type
2305+ 21F3 B7                   or      A
2306+ 21F4 1F                   rra
2307+ 21F5 C1                   pop     BC              ; Get last expression to BCDE
2308+ 21F6 D1                   pop     DE
2309+ 21F7 F5                   push    AF              ; Save status
2310+ 21F8 CD 59 20             call    CHKTYP          ; Check that types match
2311+ 21FB 21 34 22             ld      HL,CMPRES       ; Result to comparison
2312+ 21FE E5                   push    HL              ; Save for RETurn
2313+ 21FF CA DC 2E             jp      Z,CMPNUM        ; Compare values if numeric
2314+ 2202 AF                   xor     A               ; Compare two strings
2315+ 2203 32 92 52             ld      (TYPE),A        ; Set type to numeric
2316+ 2206 D5                   push    DE              ; Save string name
2317+ 2207 CD 9F 26             call    GSTRCU          ; Get current string
2318+ 220A 7E                   ld      A,(HL)          ; Get length of string
2319+ 220B 23                   inc     HL
2320+ 220C 23                   inc     HL
2321+ 220D 4E                   ld      C,(HL)          ; Get LSB of address
2322+ 220E 23                   inc     HL
2323+ 220F 46                   ld      B,(HL)          ; Get MSB of address
2324+ 2210 D1                   pop     DE              ; Restore string name
2325+ 2211 C5                   push    BC              ; Save address of string
2326+ 2212 F5                   push    AF              ; Save length of string
2327+ 2213 CD A3 26             call    GSTRDE          ; Get second string
2328+ 2216 CD B0 2E             call    LOADFP          ; Get address of second string
2329+ 2219 F1                   pop     AF              ; Restore length of string 1
2330+ 221A 57                   ld      D,A             ; Length to D
2331+ 221B E1                   pop     HL              ; Restore address of string 1
2332+ 221C 7B           CMPSTR: ld      A,E             ; Bytes of string 2 to do
2333+ 221D B2                   or      D               ; Bytes of string 1 to do
2334+ 221E C8                   ret     Z               ; Exit if all bytes compared
2335+ 221F 7A                   ld      A,D             ; Get bytes of string 1 to do
2336+ 2220 D6 01                sub     $01
2337+ 2222 D8                   ret     C               ; Exit if end of string 1
2338+ 2223 AF                   xor     A
2339+ 2224 BB                   cp      E               ; Bytes of string 2 to do
2340+ 2225 3C                   inc     A
2341+ 2226 D0                   ret     NC              ; Exit if end of string 2
2342+ 2227 15                   dec     D               ; Count bytes in string 1
2343+ 2228 1D                   dec     E               ; Count bytes in string 2
2344+ 2229 0A                   ld      A,(BC)          ; Byte in string 2
2345+ 222A BE                   cp      (HL)            ; Compare to byte in string 1
2346+ 222B 23                   inc     HL              ; Move up string 1
2347+ 222C 03                   inc     BC              ; Move up string 2
2348+ 222D CA 1C 22             jp      Z,CMPSTR        ; Same - Try next bytes
2349+ 2230 3F                   ccf                     ; Flag difference (">" or "<")
2350+ 2231 C3 6C 2E             jp      FLGDIF          ; "<" gives -1 , ">" gives +1
2351+ 2234
2352+ 2234 3C           CMPRES: inc     A               ; Increment current value
2353+ 2235 8F                   adc     A,A             ; Double plus carry
2354+ 2236 C1                   pop     BC              ; Get other value
2355+ 2237 A0                   and     B               ; Combine them
2356+ 2238 C6 FF                add     A,-1            ; Carry set if different
2357+ 223A 9F                   sbc     A,A             ; 00 - Equal , FF - Different
2358+ 223B C3 73 2E             jp      FLGREL          ; Set current value & continue
2359+ 223E
2360+ 223E 16 5A        EVNOT:  ld      D,$5A           ; Precedence value for "NOT"
2361+ 2240 CD 69 20             call    EVAL1           ; Eval until precedence break
2362+ 2243 CD 57 20             call    TSTNUM          ; Make sure it's a number
2363+ 2246 CD 81 1C             call    DEINT           ; Get integer -32768 - 32767
2364+ 2249 7B                   ld      A,E             ; Get LSB
2365+ 224A 2F                   cpl                     ; Invert LSB
2366+ 224B 4F                   ld      C,A             ; Save "NOT" of LSB
2367+ 224C 7A                   ld      A,D             ; Get MSB
2368+ 224D 2F                   cpl                     ; Invert MSB
2369+ 224E CD 3D 24             call    ACPASS          ; Save AC as current
2370+ 2251 C1                   pop     BC              ; Clean up stack
2371+ 2252 C3 75 20             jp      EVAL3           ; Continue evaluation
2372+ 2255
2373+ 2255 2B           DIMRET: dec     HL              ; dec 'cos GETCHR INCs
2374+ 2256 CD CB 1B             call    GETCHR          ; Get next character
2375+ 2259 C8                   ret     Z               ; End of DIM statement
2376+ 225A CD 8A 19             call    CHKSYN          ; Make sure ',' follows
2377+ 225D 2C                   defb    ','
2378+ 225E 01 55 22     DIM:    ld      BC,DIMRET       ; Return to "DIMRET"
2379+ 2261 C5                   push    BC              ; Save on stack
2380+ 2262 F6                   defb    $F6             ; Flag "Create" variable
2381+ 2263 AF           GETVAR: xor     A               ; Find variable address,to DE
2382+ 2264 32 91 52             ld      (LCRFLG),A      ; Set locate / create flag
2383+ 2267 46                   ld      B,(HL)          ; Get First byte of name
2384+ 2268 CD 6D 1C     GTFNAM: call    CHKLTR          ; See if a letter
2385+ 226B DA A8 16             jp      C,SNERR         ; ?SN Error if not a letter
2386+ 226E AF                   xor     A
2387+ 226F 4F                   ld      C,A             ; Clear second byte of name
2388+ 2270 32 92 52             ld      (TYPE),A        ; Set type to numeric
2389+ 2273 CD CB 1B             call    GETCHR          ; Get next character
2390+ 2276 DA 7F 22             jp      C,SVNAM2        ; Numeric - Save in name
2391+ 2279 CD 6D 1C             call    CHKLTR          ; See if a letter
2392+ 227C DA 8C 22             jp      C,CHARTY        ; Not a letter - Check type
2393+ 227F 4F           SVNAM2: ld      C,A             ; Save second byte of name
2394+ 2280 CD CB 1B     ENDNAM: call    GETCHR          ; Get next character
2395+ 2283 DA 80 22             jp      C,ENDNAM        ; Numeric - Get another
2396+ 2286 CD 6D 1C             call    CHKLTR          ; See if a letter
2397+ 2289 D2 80 22             jp      NC,ENDNAM       ; Letter - Get another
2398+ 228C D6 24        CHARTY: sub     '$'             ; String variable?
2399+ 228E C2 9B 22             jp      NZ,NOTSTR       ; No - Numeric variable
2400+ 2291 3C                   inc     A               ; A = 1 (string type)
2401+ 2292 32 92 52             ld      (TYPE),A        ; Set type to string
2402+ 2295 0F                   rrca                    ; A = 80H , Flag for string
2403+ 2296 81                   add     A,C             ; 2nd byte of name has bit 7 on
2404+ 2297 4F                   ld      C,A             ; Resave second byte on name
2405+ 2298 CD CB 1B             call    GETCHR          ; Get next character
2406+ 229B 3A B0 52     NOTSTR: ld      A,(FORFLG)      ; Array name needed ?
2407+ 229E 3D                   dec     A
2408+ 229F CA 48 23             jp      Z,ARLDSV        ; Yes - Get array name
2409+ 22A2 F2 AB 22             jp      P,NSCFOR        ; No array with "FOR" or "FN"
2410+ 22A5 7E                   ld      A,(HL)          ; Get byte again
2411+ 22A6 D6 28                sub     '('             ; Subscripted variable?
2412+ 22A8 CA 20 23             jp      Z,SBSCPT        ; Yes - Sort out subscript
2413+ 22AB
2414+ 22AB AF           NSCFOR: xor     A               ; Simple variable
2415+ 22AC 32 B0 52             ld      (FORFLG),A      ; Clear "FOR" flag
2416+ 22AF E5                   push    HL              ; Save code string address
2417+ 22B0 50                   ld      D,B             ; DE = Variable name to find
2418+ 22B1 59                   ld      E,C
2419+ 22B2 2A 2A 53             ld      HL,(FNRGNM)     ; FN argument name
2420+ 22B5 CD 84 19             call    CPDEHL          ; Is it the FN argument?
2421+ 22B8 11 2C 53             ld      DE,FNARG        ; Point to argument value
2422+ 22BB CA 51 2D             jp      Z,POPHRT        ; Yes - Return FN argument value
2423+ 22BE 2A 24 53             ld      HL,(VAREND)     ; End of variables
2424+ 22C1 EB                   ex      DE,HL           ; Address of end of search
2425+ 22C2 2A 22 53             ld      HL,(PROGND)     ; Start of variables address
2426+ 22C5 CD 84 19     FNDVAR: call    CPDEHL          ; End of variable list table?
2427+ 22C8 CA DE 22             jp      Z,CFEVAL        ; Yes - Called from EVAL?
2428+ 22CB 79                   ld      A,C             ; Get second byte of name
2429+ 22CC 96                   sub     (HL)            ; Compare with name in list
2430+ 22CD 23                   inc     HL              ; Move on to first byte
2431+ 22CE C2 D3 22             jp      NZ,FNTHR        ; Different - Find another
2432+ 22D1 78                   ld      A,B             ; Get first byte of name
2433+ 22D2 96                   sub     (HL)            ; Compare with name in list
2434+ 22D3 23           FNTHR:  inc     HL              ; Move on to LSB of value
2435+ 22D4 CA 12 23             jp      Z,RETADR        ; Found - Return address
2436+ 22D7 23                   inc     HL              ; <- Skip
2437+ 22D8 23                   inc     HL              ; <- over
2438+ 22D9 23                   inc     HL              ; <- F.P.
2439+ 22DA 23                   inc     HL              ; <- value
2440+ 22DB C3 C5 22             jp      FNDVAR          ; Keep looking
2441+ 22DE
2442+ 22DE E1           CFEVAL: pop     HL              ; Restore code string address
2443+ 22DF E3                   ex      (SP),HL         ; Get return address
2444+ 22E0 D5                   push    DE              ; Save address of variable
2445+ 22E1 11 47 21             ld      DE,FRMEVL       ; Return address in EVAL
2446+ 22E4 CD 84 19             call    CPDEHL          ; Called from EVAL ?
2447+ 22E7 D1                   pop     DE              ; Restore address of variable
2448+ 22E8 CA 15 23             jp      Z,RETNUL        ; Yes - Return null variable
2449+ 22EB E3                   ex      (SP),HL         ; Put back return
2450+ 22EC E5                   push    HL              ; Save code string address
2451+ 22ED C5                   push    BC              ; Save variable name
2452+ 22EE 01 06 00             ld      BC,$0006        ; 2 byte name plus 4 byte data
2453+ 22F1 2A 26 53             ld      HL,(ARREND)     ; End of arrays
2454+ 22F4 E5                   push    HL              ; Save end of arrays
2455+ 22F5 09                   add     HL,BC           ; Move up 6 bytes
2456+ 22F6 C1                   pop     BC              ; Source address in BC
2457+ 22F7 E5                   push    HL              ; Save new end address
2458+ 22F8 CD 54 16             call    MOVUP           ; Move arrays up
2459+ 22FB E1                   pop     HL              ; Restore new end address
2460+ 22FC 22 26 53             ld      (ARREND),HL     ; Set new end address
2461+ 22FF 60                   ld      H,B             ; End of variables to HL
2462+ 2300 69                   ld      L,C
2463+ 2301 22 24 53             ld      (VAREND),HL     ; Set new end address
2464+ 2304
2465+ 2304 2B           ZEROLP: dec     HL              ; Back through to zero variable
2466+ 2305 36 00                ld      (HL),$00        ; Zero byte in variable
2467+ 2307 CD 84 19             call    CPDEHL          ; Done them all?
2468+ 230A C2 04 23             jp      NZ,ZEROLP       ; No - Keep on going
2469+ 230D D1                   pop     DE              ; Get variable name
2470+ 230E 73                   ld      (HL),E          ; Store second character
2471+ 230F 23                   inc     HL
2472+ 2310 72                   ld      (HL),D          ; Store first character
2473+ 2311 23                   inc     HL
2474+ 2312 EB           RETADR: ex      DE,HL           ; Address of variable in DE
2475+ 2313 E1                   pop     HL              ; Restore code string address
2476+ 2314 C9                   ret
2477+ 2315
2478+ 2315 32 33 53     RETNUL: ld      (FPEXP),A       ; Set result to zero
2479+ 2318 21 25 16             ld      HL,ZERBYT       ; Also set a null string
2480+ 231B 22 30 53             ld      (FPREG),HL      ; Save for EVAL
2481+ 231E E1                   pop     HL              ; Restore code string address
2482+ 231F C9                   ret
2483+ 2320
2484+ 2320 E5           SBSCPT: push    HL              ; Save code string address
2485+ 2321 2A 91 52             ld      HL,(LCRFLG)     ; Locate/Create and Type
2486+ 2324 E3                   ex      (SP),HL         ; Save and get code string
2487+ 2325 57                   ld      D,A             ; Zero number of dimensions
2488+ 2326 D5           SCPTLP: push    DE              ; Save number of dimensions
2489+ 2327 C5                   push    BC              ; Save array name
2490+ 2328 CD 75 1C             call    FPSINT          ; Get subscript (0-32767)
2491+ 232B C1                   pop     BC              ; Restore array name
2492+ 232C F1                   pop     AF              ; Get number of dimensions
2493+ 232D EB                   ex      DE,HL
2494+ 232E E3                   ex      (SP),HL         ; Save subscript value
2495+ 232F E5                   push    HL              ; Save LCRFLG and TYPE
2496+ 2330 EB                   ex      DE,HL
2497+ 2331 3C                   inc     A               ; Count dimensions
2498+ 2332 57                   ld      D,A             ; Save in D
2499+ 2333 7E                   ld      A,(HL)          ; Get next byte in code string
2500+ 2334 FE 2C                cp      ','             ; Comma (more to come)?
2501+ 2336 CA 26 23             jp      Z,SCPTLP        ; Yes - More subscripts
2502+ 2339 CD 8A 19             call    CHKSYN          ; Make sure ")" follows
2503+ 233C 29                   defb    ')'
2504+ 233D 22 B5 52             ld      (NXTOPR),HL     ; Save code string address
2505+ 2340 E1                   pop     HL              ; Get LCRFLG and TYPE
2506+ 2341 22 91 52             ld      (LCRFLG),HL     ; Restore Locate/create & type
2507+ 2344 1E 00                ld      E,$00           ; Flag not CSAVE* or CLOAD*
2508+ 2346 D5                   push    DE              ; Save number of dimensions (D)
2509+ 2347 11                   defb    $11             ; Skip "push HL" and "push AF'
2510+ 2348
2511+ 2348 E5           ARLDSV: push    HL              ; Save code string address
2512+ 2349 F5                   push    AF              ; A = 00 , Flags set = Z,N
2513+ 234A 2A 24 53             ld      HL,(VAREND)     ; Start of arrays
2514+ 234D 3E                   defb    $3E             ; Skip "add HL,DE"
2515+ 234E 19           FNDARY: add     HL,DE           ; Move to next array start
2516+ 234F EB                   ex      DE,HL
2517+ 2350 2A 26 53             ld      HL,(ARREND)     ; End of arrays
2518+ 2353 EB                   ex      DE,HL           ; Current array pointer
2519+ 2354 CD 84 19             call    CPDEHL          ; End of arrays found?
2520+ 2357 CA 80 23             jp      Z,CREARY        ; Yes - Create array
2521+ 235A 7E                   ld      A,(HL)          ; Get second byte of name
2522+ 235B B9                   cp      C               ; Compare with name given
2523+ 235C 23                   inc     HL              ; Move on
2524+ 235D C2 62 23             jp      NZ,NXTARY       ; Different - Find next array
2525+ 2360 7E                   ld      A,(HL)          ; Get first byte of name
2526+ 2361 B8                   cp      B               ; Compare with name given
2527+ 2362 23           NXTARY: inc     HL              ; Move on
2528+ 2363 5E                   ld      E,(HL)          ; Get LSB of next array address
2529+ 2364 23                   inc     HL
2530+ 2365 56                   ld      D,(HL)          ; Get MSB of next array address
2531+ 2366 23                   inc     HL
2532+ 2367 C2 4E 23             jp      NZ,FNDARY       ; Not found - Keep looking
2533+ 236A 3A 91 52             ld      A,(LCRFLG)      ; Found Locate or Create it?
2534+ 236D B7                   or      A
2535+ 236E C2 B1 16             jp      NZ,DDERR        ; Create - ?DD Error
2536+ 2371 F1                   pop     AF              ; Locate - Get number of dim'ns
2537+ 2372 44                   ld      B,H             ; BC Points to array dim'ns
2538+ 2373 4D                   ld      C,L
2539+ 2374 CA 51 2D             jp      Z,POPHRT        ; Jump if array load/save
2540+ 2377 96                   sub     (HL)            ; Same number of dimensions?
2541+ 2378 CA DE 23             jp      Z,FINDEL        ; Yes - Find element
2542+ 237B 1E 10        BSERR:  ld      E,BS            ; ?BS Error
2543+ 237D C3 BC 16             jp      ERROR           ; Output error
2544+ 2380
2545+ 2380 11 04 00     CREARY: ld      DE,$0004        ; 4 Bytes per entry
2546+ 2383 F1                   pop     AF              ; Array to save or 0 dim'ns?
2547+ 2384 CA 96 1C             jp      Z,FCERR         ; Yes - ?FC Error
2548+ 2387 71                   ld      (HL),C          ; Save second byte of name
2549+ 2388 23                   inc     HL
2550+ 2389 70                   ld      (HL),B          ; Save first byte of name
2551+ 238A 23                   inc     HL
2552+ 238B 4F                   ld      C,A             ; Number of dimensions to C
2553+ 238C CD 65 16             call    CHKSTK          ; Check if enough memory
2554+ 238F 23                   inc     HL              ; Point to number of dimensions
2555+ 2390 23                   inc     HL
2556+ 2391 22 AA 52             ld      (CUROPR),HL     ; Save address of pointer
2557+ 2394 71                   ld      (HL),C          ; Set number of dimensions
2558+ 2395 23                   inc     HL
2559+ 2396 3A 91 52             ld      A,(LCRFLG)      ; Locate of Create?
2560+ 2399 17                   rla                     ; Carry set = Create
2561+ 239A 79                   ld      A,C             ; Get number of dimensions
2562+ 239B 01 0B 00     CRARLP: ld      BC,10+1         ; Default dimension size 10
2563+ 239E D2 A3 23             jp      NC,DEFSIZ       ; Locate - Set default size
2564+ 23A1 C1                   pop     BC              ; Get specified dimension size
2565+ 23A2 03                   inc     BC              ; Include zero element
2566+ 23A3 71           DEFSIZ: ld      (HL),C          ; Save LSB of dimension size
2567+ 23A4 23                   inc     HL
2568+ 23A5 70                   ld      (HL),B          ; Save MSB of dimension size
2569+ 23A6 23                   inc     HL
2570+ 23A7 F5                   push    AF              ; Save num' of dim'ns an status
2571+ 23A8 E5                   push    HL              ; Save address of dim'n size
2572+ 23A9 CD 4D 2F             call    MLDEBC          ; Multiply DE by BC to find
2573+ 23AC EB                   ex      DE,HL           ; amount of mem needed (to DE)
2574+ 23AD E1                   pop     HL              ; Restore address of dimension
2575+ 23AE F1                   pop     AF              ; Restore number of dimensions
2576+ 23AF 3D                   dec     A               ; Count them
2577+ 23B0 C2 9B 23             jp      NZ,CRARLP       ; Do next dimension if more
2578+ 23B3 F5                   push    AF              ; Save locate/create flag
2579+ 23B4 42                   ld      B,D             ; MSB of memory needed
2580+ 23B5 4B                   ld      C,E             ; LSB of memory needed
2581+ 23B6 EB                   ex      DE,HL
2582+ 23B7 19                   add     HL,DE           ; Add bytes to array start
2583+ 23B8 DA 7D 16             jp      C,OMERR         ; Too big - Error
2584+ 23BB CD 6E 16             call    ENFMEM          ; See if enough memory
2585+ 23BE 22 26 53             ld      (ARREND),HL     ; Save new end of array
2586+ 23C1
2587+ 23C1 2B           ZERARY: dec     HL              ; Back through array data
2588+ 23C2 36 00                ld      (HL),$00        ; Set array element to zero
2589+ 23C4 CD 84 19             call    CPDEHL          ; All elements zeroed?
2590+ 23C7 C2 C1 23             jp      NZ,ZERARY       ; No - Keep on going
2591+ 23CA 03                   inc     BC              ; Number of bytes + 1
2592+ 23CB 57                   ld      D,A             ; A=0
2593+ 23CC 2A AA 52             ld      HL,(CUROPR)     ; Get address of array
2594+ 23CF 5E                   ld      E,(HL)          ; Number of dimensions
2595+ 23D0 EB                   ex      DE,HL           ; To HL
2596+ 23D1 29                   add     HL,HL           ; Two bytes per dimension size
2597+ 23D2 09                   add     HL,BC           ; Add number of bytes
2598+ 23D3 EB                   ex      DE,HL           ; Bytes needed to DE
2599+ 23D4 2B                   dec     HL
2600+ 23D5 2B                   dec     HL
2601+ 23D6 73                   ld      (HL),E          ; Save LSB of bytes needed
2602+ 23D7 23                   inc     HL
2603+ 23D8 72                   ld      (HL),D          ; Save MSB of bytes needed
2604+ 23D9 23                   inc     HL
2605+ 23DA F1                   pop     AF              ; Locate / Create?
2606+ 23DB DA 02 24             jp      C,ENDDIM        ; A is 0 , End if create
2607+ 23DE 47           FINDEL: ld      B,A             ; Find array element
2608+ 23DF 4F                   ld      C,A
2609+ 23E0 7E                   ld      A,(HL)          ; Number of dimensions
2610+ 23E1 23                   inc     HL
2611+ 23E2 16                   defb    $16             ; Skip "pop HL"
2612+ 23E3 E1           FNDELP: pop     HL              ; Address of next dim' size
2613+ 23E4 5E                   ld      E,(HL)          ; Get LSB of dim'n size
2614+ 23E5 23                   inc     HL
2615+ 23E6 56                   ld      D,(HL)          ; Get MSB of dim'n size
2616+ 23E7 23                   inc     HL
2617+ 23E8 E3                   ex      (SP),HL         ; Save address - Get index
2618+ 23E9 F5                   push    AF              ; Save number of dim'ns
2619+ 23EA CD 84 19             call    CPDEHL          ; Dimension too large?
2620+ 23ED D2 7B 23             jp      NC,BSERR        ; Yes - ?BS Error
2621+ 23F0 E5                   push    HL              ; Save index
2622+ 23F1 CD 4D 2F             call    MLDEBC          ; Multiply previous by size
2623+ 23F4 D1                   pop     DE              ; Index supplied to DE
2624+ 23F5 19                   add     HL,DE           ; Add index to pointer
2625+ 23F6 F1                   pop     AF              ; Number of dimensions
2626+ 23F7 3D                   dec     A               ; Count them
2627+ 23F8 44                   ld      B,H             ; MSB of pointer
2628+ 23F9 4D                   ld      C,L             ; LSB of pointer
2629+ 23FA C2 E3 23             jp      NZ,FNDELP       ; More - Keep going
2630+ 23FD 29                   add     HL,HL           ; 4 Bytes per element
2631+ 23FE 29                   add     HL,HL
2632+ 23FF C1                   pop     BC              ; Start of array
2633+ 2400 09                   add     HL,BC           ; Point to element
2634+ 2401 EB                   ex      DE,HL           ; Address of element to DE
2635+ 2402 2A B5 52     ENDDIM: ld      HL,(NXTOPR)     ; Got code string address
2636+ 2405 C9                   ret
2637+ 2406
2638+ 2406
2639+ 2406              ; returns the value of the 32-bit system tick counter as
2640+ 2406              ; two 16-bit words
2641+ 2406 CD 57 20     TMR:    call    TSTNUM          ; Make sure it's a number
2642+ 2409 CD 81 1C             call    DEINT           ; Get integer (-32768 to 32767)
2643+ 240C 2A BB 52             ld      HL,(TMRCNT)     ; load the LSBytes of timer
2644+ 240F 7B                   ld      A,E
2645+ 2410 B2                   or      D               ; is it 0?
2646+ 2411 CA 17 24             jp      Z,ENDTMR        ; yes, jump over
2647+ 2414 2A BD 52             ld      HL,(TMRCNT+2)   ; load the MSBytes of timer
2648+ 2417 45           ENDTMR: ld      B,L             ; move bytes...
2649+ 2418 7C                   ld      A,H             ; ...into AB
2650+ 2419 C3 3E 24             jp      ABPASS          ; return word into AB
2651+ 241C
2652+ 241C
2653+ 241C              ; returns the free space for BASIC or into the string pool
2654+ 241C 2A 26 53     FRE:    ld      HL,(ARREND)     ; Start of free memory
2655+ 241F EB                   ex      DE,HL           ; To DE
2656+ 2420 21 00 00             ld      HL,$0000        ; End of free memory
2657+ 2423 39                   add     HL,SP           ; Current stack value
2658+ 2424 3A 92 52             ld      A,(TYPE)        ; Dummy argument type
2659+ 2427 B7                   or      A
2660+ 2428 CA 38 24             jp      Z,FRENUM        ; Numeric - Free variable space
2661+ 242B CD 9F 26             call    GSTRCU          ; Current string to pool
2662+ 242E CD 9F 25             call    GARBGE          ; Garbage collection
2663+ 2431 2A AB 51             ld      HL,(STRSPC)     ; Bottom of string space in use
2664+ 2434 EB                   ex      DE,HL           ; To DE
2665+ 2435 2A A8 52             ld      HL,(STRBOT)     ; Bottom of string space
2666+ 2438 7D           FRENUM: ld      A,L             ; Get LSB of end
2667+ 2439 93                   sub     E               ; Subtract LSB of beginning
2668+ 243A 4F                   ld      C,A             ; Save difference if C
2669+ 243B 7C                   ld      A,H             ; Get MSB of end
2670+ 243C 9A                   sbc     A,D             ; Subtract MSB of beginning
2671+ 243D 41           ACPASS: ld      B,C             ; Return integer AC
2672+ 243E 50           ABPASS: ld      D,B             ; Return integer AB
2673+ 243F 1E 00                ld      E,$00
2674+ 2441 21 92 52             ld      HL,TYPE         ; Point to type
2675+ 2444 73                   ld      (HL),E          ; Set type to numeric
2676+ 2445 06 90                ld      B,$80+$10       ; 16 bit integer
2677+ 2447 C3 78 2E             jp      RETINT          ; Return the integer
2678+ 244A
2679+ 244A              ; returns the X position of the cursor during a print
2680+ 244A 3A 90 52     POS:    ld      A,(CURPOS)      ; Get cursor position
2681+ 244D 47           PASSA:  ld      B,A             ; Put A into AB
2682+ 244E AF                   xor     A               ; Zero A
2683+ 244F C3 3E 24             jp      ABPASS          ; Return integer AB
2684+ 2452
2685+ 2452 CD D5 24     DEF:    call    CHEKFN          ; Get "FN" and name
2686+ 2455 CD C7 24             call    IDTEST          ; Test for illegal direct
2687+ 2458 01 74 1D             ld      BC,DATA         ; To get next statement
2688+ 245B C5                   push    BC              ; Save address for RETurn
2689+ 245C D5                   push    DE              ; Save address of function ptr
2690+ 245D CD 8A 19             call    CHKSYN          ; Make sure "(" follows
2691+ 2460 28                   defb    '('
2692+ 2461 CD 63 22             call    GETVAR          ; Get argument variable name
2693+ 2464 E5                   push    HL              ; Save code string address
2694+ 2465 EB                   ex      DE,HL           ; Argument address to HL
2695+ 2466 2B                   dec     HL
2696+ 2467 56                   ld      D,(HL)          ; Get first byte of arg name
2697+ 2468 2B                   dec     HL
2698+ 2469 5E                   ld      E,(HL)          ; Get second byte of arg name
2699+ 246A E1                   pop     HL              ; Restore code string address
2700+ 246B CD 57 20             call    TSTNUM          ; Make sure numeric argument
2701+ 246E CD 8A 19             call    CHKSYN          ; Make sure ")" follows
2702+ 2471 29                   defb    ')'
2703+ 2472 CD 8A 19             call    CHKSYN          ; Make sure "=" follows
2704+ 2475 C8                   defb    ZEQUAL          ; "=" token
2705+ 2476 44                   ld      B,H             ; Code string address to BC
2706+ 2477 4D                   ld      C,L
2707+ 2478 E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2708+ 2479 71                   ld      (HL),C          ; Save LSB of FN code string
2709+ 247A 23                   inc     HL
2710+ 247B 70                   ld      (HL),B          ; Save MSB of FN code string
2711+ 247C C3 14 25             jp      SVSTAD          ; Save address and do function
2712+ 247F
2713+ 247F CD D5 24     DOFN:   call    CHEKFN          ; Make sure FN follows
2714+ 2482 D5                   push    DE              ; Save function pointer address
2715+ 2483 CD 2B 21             call    EVLPAR          ; Evaluate expression in "()"
2716+ 2486 CD 57 20             call    TSTNUM          ; Make sure numeric result
2717+ 2489 E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2718+ 248A 5E                   ld      E,(HL)          ; Get LSB of FN code string
2719+ 248B 23                   inc     HL
2720+ 248C 56                   ld      D,(HL)          ; Get MSB of FN code string
2721+ 248D 23                   inc     HL
2722+ 248E 7A                   ld      A,D             ; And function DEFined?
2723+ 248F B3                   or      E
2724+ 2490 CA B4 16             jp      Z,UFERR         ; No - ?UF Error
2725+ 2493 7E                   ld      A,(HL)          ; Get LSB of argument address
2726+ 2494 23                   inc     HL
2727+ 2495 66                   ld      H,(HL)          ; Get MSB of argument address
2728+ 2496 6F                   ld      L,A             ; HL = Arg variable address
2729+ 2497 E5                   push    HL              ; Save it
2730+ 2498 2A 2A 53             ld      HL,(FNRGNM)     ; Get old argument name
2731+ 249B E3                   ex      (SP),HL         ; Save old , Get new
2732+ 249C 22 2A 53             ld      (FNRGNM),HL     ; Set new argument name
2733+ 249F 2A 2E 53             ld      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2734+ 24A2 E5                   push    HL              ; Save it
2735+ 24A3 2A 2C 53             ld      HL,(FNARG)      ; Get MSB,EXP of old arg value
2736+ 24A6 E5                   push    HL              ; Save it
2737+ 24A7 21 2C 53             ld      HL,FNARG        ; HL = Value of argument
2738+ 24AA D5                   push    DE              ; Save FN code string address
2739+ 24AB CD B9 2E             call    FPTHL           ; Move FPREG to argument
2740+ 24AE E1                   pop     HL              ; Get FN code string address
2741+ 24AF CD 54 20             call    GETNUM          ; Get value from function
2742+ 24B2 2B                   dec     HL              ; dec 'cos GETCHR INCs
2743+ 24B3 CD CB 1B             call    GETCHR          ; Get next character
2744+ 24B6 C2 A8 16             jp      NZ,SNERR        ; Bad character in FN - Error
2745+ 24B9 E1                   pop     HL              ; Get MSB,EXP of old arg
2746+ 24BA 22 2C 53             ld      (FNARG),HL      ; Restore it
2747+ 24BD E1                   pop     HL              ; Get LSB,NLSB of old arg
2748+ 24BE 22 2E 53             ld      (FNARG+2),HL    ; Restore it
2749+ 24C1 E1                   pop     HL              ; Get name of old arg
2750+ 24C2 22 2A 53             ld      (FNRGNM),HL     ; Restore it
2751+ 24C5 E1                   pop     HL              ; Restore code string address
2752+ 24C6 C9                   ret
2753+ 24C7
2754+ 24C7 E5           IDTEST: push    HL              ; Save code string address
2755+ 24C8 2A AD 51             ld      HL,(LINEAT)     ; Get current line number
2756+ 24CB 23                   inc     HL              ; -1 means direct statement
2757+ 24CC 7C                   ld      A,H
2758+ 24CD B5                   or      L
2759+ 24CE E1                   pop     HL              ; Restore code string address
2760+ 24CF C0                   ret     NZ              ; Return if in program
2761+ 24D0 1E 16                ld      E,ID            ; ?ID Error
2762+ 24D2 C3 BC 16             jp      ERROR
2763+ 24D5
2764+ 24D5 CD 8A 19     CHEKFN: call    CHKSYN          ; Make sure FN follows
2765+ 24D8 B8                   defb    ZFN             ; "FN" token
2766+ 24D9 3E 80                ld      A,$80
2767+ 24DB 32 B0 52             ld      (FORFLG),A      ; Flag FN name to find
2768+ 24DE B6                   or      (HL)            ; FN name has bit 7 set
2769+ 24DF 47                   ld      B,A             ; in first byte of name
2770+ 24E0 CD 68 22             call    GTFNAM          ; Get FN name
2771+ 24E3 C3 57 20             jp      TSTNUM          ; Make sure numeric function
2772+ 24E6
2773+ 24E6 CD 57 20     STR:    call    TSTNUM          ; Make sure it's a number
2774+ 24E9 CD 06 30             call    NUMASC          ; Turn number into text
2775+ 24EC CD 1A 25     STR1:   call    CRTST           ; Create string entry for it
2776+ 24EF CD 9F 26             call    GSTRCU          ; Current string to pool
2777+ 24F2 01 FA 26             ld      BC,TOPOOL       ; Save in string pool
2778+ 24F5 C5                   push    BC              ; Save address on stack
2779+ 24F6
2780+ 24F6 7E           SAVSTR: ld      A,(HL)          ; Get string length
2781+ 24F7 23                   inc     HL
2782+ 24F8 23                   inc     HL
2783+ 24F9 E5                   push    HL              ; Save pointer to string
2784+ 24FA CD 75 25             call    TESTR           ; See if enough string space
2785+ 24FD E1                   pop     HL              ; Restore pointer to string
2786+ 24FE 4E                   ld      C,(HL)          ; Get LSB of address
2787+ 24FF 23                   inc     HL
2788+ 2500 46                   ld      B,(HL)          ; Get MSB of address
2789+ 2501 CD 0E 25             call    CRTMST          ; Create string entry
2790+ 2504 E5                   push    HL              ; Save pointer to MSB of addr
2791+ 2505 6F                   ld      L,A             ; Length of string
2792+ 2506 CD 92 26             call    TOSTRA          ; Move to string area
2793+ 2509 D1                   pop     DE              ; Restore pointer to MSB
2794+ 250A C9                   ret
2795+ 250B
2796+ 250B CD 75 25     MKTMST: call    TESTR           ; See if enough string space
2797+ 250E 21 A4 52     CRTMST: ld      HL,TMPSTR       ; Temporary string
2798+ 2511 E5                   push    HL              ; Save it
2799+ 2512 77                   ld      (HL),A          ; Save length of string
2800+ 2513 23                   inc     HL
2801+ 2514 23           SVSTAD: inc     HL
2802+ 2515 73                   ld      (HL),E          ; Save LSB of address
2803+ 2516 23                   inc     HL
2804+ 2517 72                   ld      (HL),D          ; Save MSB of address
2805+ 2518 E1                   pop     HL              ; Restore pointer
2806+ 2519 C9                   ret
2807+ 251A
2808+ 251A 2B           CRTST:  dec     HL              ; dec - INCed after
2809+ 251B 06 22        QTSTR:  ld      B,$22           ; '"'           ; Terminating quote
2810+ 251D 50                   ld      D,B             ; Quote to D
2811+ 251E E5           DTSTR:  push    HL              ; Save start
2812+ 251F 0E FF                ld      C,-1            ; Set counter to -1
2813+ 2521 23           QTSTLP: inc     HL              ; Move on
2814+ 2522 7E                   ld      A,(HL)          ; Get byte
2815+ 2523 0C                   inc     C               ; Count bytes
2816+ 2524 B7                   or      A               ; End of line?
2817+ 2525 CA 30 25             jp      Z,CRTSTE        ; Yes - Create string entry
2818+ 2528 BA                   cp      D               ; Terminator D found?
2819+ 2529 CA 30 25             jp      Z,CRTSTE        ; Yes - Create string entry
2820+ 252C B8                   cp      B               ; Terminator B found?
2821+ 252D C2 21 25             jp      NZ,QTSTLP       ; No - Keep looking
2822+ 2530 FE 22        CRTSTE: cp      $22             ; '"'             ; End with '"'?
2823+ 2532 CC CB 1B             call    Z,GETCHR        ; Yes - Get next character
2824+ 2535 E3                   ex      (SP),HL         ; Starting quote
2825+ 2536 23                   inc     HL              ; First byte of string
2826+ 2537 EB                   ex      DE,HL           ; To DE
2827+ 2538 79                   ld      A,C             ; Get length
2828+ 2539 CD 0E 25             call    CRTMST          ; Create string entry
2829+ 253C 11 A4 52     TSTOPL: ld      DE,TMPSTR       ; Temporary string
2830+ 253F 2A 96 52             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2831+ 2542 22 30 53             ld      (FPREG),HL      ; Save address of string ptr
2832+ 2545 3E 01                ld      A,$01
2833+ 2547 32 92 52             ld      (TYPE),A        ; Set type to string
2834+ 254A CD BC 2E             call    DETHL4          ; Move string to pool
2835+ 254D CD 84 19             call    CPDEHL          ; Out of string pool?
2836+ 2550 22 96 52             ld      (TMSTPT),HL     ; Save new pointer
2837+ 2553 E1                   pop     HL              ; Restore code string address
2838+ 2554 7E                   ld      A,(HL)          ; Get next code byte
2839+ 2555 C0                   ret     NZ              ; Return if pool OK
2840+ 2556 1E 1E                ld      E,ST            ; ?ST Error
2841+ 2558 C3 BC 16             jp      ERROR           ; String pool overflow
2842+ 255B
2843+ 255B 23           PRNUMS: inc     HL              ; Skip leading space
2844+ 255C CD 1A 25     PRS:    call    CRTST           ; Create string entry for it
2845+ 255F CD 9F 26     PRS1:   call    GSTRCU          ; Current string to pool
2846+ 2562 CD B0 2E             call    LOADFP          ; Move string block to BCDE
2847+ 2565 1C                   inc     E               ; Length + 1
2848+ 2566 1D           PRSLP:  dec     E               ; Count characters
2849+ 2567 C8                   ret     Z               ; End of string
2850+ 2568 0A                   ld      A,(BC)          ; Get byte to output
2851+ 2569 CD 95 19             call    OUTC            ; Output character in A
2852+ 256C FE 0D                cp      CR              ; Return?
2853+ 256E CC A2 1E             call    Z,CNTEND        ; Yes - Position cursor to 0
2854+ 2571 03                   inc     BC              ; Next byte in string
2855+ 2572 C3 66 25             jp      PRSLP           ; More characters to output
2856+ 2575
2857+ 2575 B7           TESTR:  or      A               ; Test if enough room
2858+ 2576 0E                   defb    $0E             ; No garbage collection done
2859+ 2577 F1           GRBDON: pop     AF              ; Garbage collection done
2860+ 2578 F5                   push    AF              ; Save status
2861+ 2579 2A AB 51             ld      HL,(STRSPC)     ; Bottom of string space in use
2862+ 257C EB                   ex      DE,HL           ; To DE
2863+ 257D 2A A8 52             ld      HL,(STRBOT)     ; Bottom of string area
2864+ 2580 2F                   cpl                     ; Negate length (Top down)
2865+ 2581 4F                   ld      C,A             ; -Length to BC
2866+ 2582 06 FF                ld      B,-1            ; BC = -ve length of string
2867+ 2584 09                   add     HL,BC           ; Add to bottom of space in use
2868+ 2585 23                   inc     HL              ; Plus one for 2's complement
2869+ 2586 CD 84 19             call    CPDEHL          ; Below string RAM area?
2870+ 2589 DA 93 25             jp      C,TESTOS        ; Tidy up if not done else err
2871+ 258C 22 A8 52             ld      (STRBOT),HL     ; Save new bottom of area
2872+ 258F 23                   inc     HL              ; Point to first byte of string
2873+ 2590 EB                   ex      DE,HL           ; Address to DE
2874+ 2591 F1           POPAF:  pop     AF              ; Throw away status push
2875+ 2592 C9                   ret
2876+ 2593
2877+ 2593 F1           TESTOS: pop     AF              ; Garbage collect been done?
2878+ 2594 1E 1A                ld      E,OS            ; ?OS Error
2879+ 2596 CA BC 16             jp      Z,ERROR         ; Yes - Not enough string space
2880+ 2599 BF                   cp      A               ; Flag garbage collect done
2881+ 259A F5                   push    AF              ; Save status
2882+ 259B 01 77 25             ld      BC,GRBDON       ; Garbage collection done
2883+ 259E C5                   push    BC              ; Save for RETurn
2884+ 259F 2A 94 52     GARBGE: ld      HL,(LSTRAM)     ; Get end of RAM pointer
2885+ 25A2 22 A8 52     GARBLP: ld      (STRBOT),HL     ; Reset string pointer
2886+ 25A5 21 00 00             ld      HL,$0000
2887+ 25A8 E5                   push    HL              ; Flag no string found
2888+ 25A9 2A AB 51             ld      HL,(STRSPC)     ; Get bottom of string space
2889+ 25AC E5                   push    HL              ; Save bottom of string space
2890+ 25AD 21 98 52             ld      HL,TMSTPL       ; Temporary string pool
2891+ 25B0 EB           GRBLP:  ex      DE,HL
2892+ 25B1 2A 96 52             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2893+ 25B4 EB                   ex      DE,HL
2894+ 25B5 CD 84 19             call    CPDEHL          ; Temporary string pool done?
2895+ 25B8 01 B0 25             ld      BC,GRBLP        ; Loop until string pool done
2896+ 25BB C2 04 26             jp      NZ,STPOOL       ; No - See if in string area
2897+ 25BE 2A 22 53             ld      HL,(PROGND)     ; Start of simple variables
2898+ 25C1 EB           SMPVAR: ex      DE,HL
2899+ 25C2 2A 24 53             ld      HL,(VAREND)     ; End of simple variables
2900+ 25C5 EB                   ex      DE,HL
2901+ 25C6 CD 84 19             call    CPDEHL          ; All simple strings done?
2902+ 25C9 CA D7 25             jp      Z,ARRLP         ; Yes - Do string arrays
2903+ 25CC 7E                   ld      A,(HL)          ; Get type of variable
2904+ 25CD 23                   inc     HL
2905+ 25CE 23                   inc     HL
2906+ 25CF B7                   or      A               ; "S" flag set if string
2907+ 25D0 CD 07 26             call    STRADD          ; See if string in string area
2908+ 25D3 C3 C1 25             jp      SMPVAR          ; Loop until simple ones done
2909+ 25D6
2910+ 25D6 C1           GNXARY: pop     BC              ; Scrap address of this array
2911+ 25D7 EB           ARRLP:  ex      DE,HL
2912+ 25D8 2A 26 53             ld      HL,(ARREND)     ; End of string arrays
2913+ 25DB EB                   ex      DE,HL
2914+ 25DC CD 84 19             call    CPDEHL          ; All string arrays done?
2915+ 25DF CA 2D 26             jp      Z,SCNEND        ; Yes - Move string if found
2916+ 25E2 CD B0 2E             call    LOADFP          ; Get array name to BCDE
2917+ 25E5 7B                   ld      A,E             ; Get type of array
2918+ 25E6 E5                   push    HL              ; Save address of num of dim'ns
2919+ 25E7 09                   add     HL,BC           ; Start of next array
2920+ 25E8 B7                   or      A               ; Test type of array
2921+ 25E9 F2 D6 25             jp      P,GNXARY        ; Numeric array - Ignore it
2922+ 25EC 22 AA 52             ld      (CUROPR),HL     ; Save address of next array
2923+ 25EF E1                   pop     HL              ; Get address of num of dim'ns
2924+ 25F0 4E                   ld      C,(HL)          ; BC = Number of dimensions
2925+ 25F1 06 00                ld      B,$00
2926+ 25F3 09                   add     HL,BC           ; Two bytes per dimension size
2927+ 25F4 09                   add     HL,BC
2928+ 25F5 23                   inc     HL              ; Plus one for number of dim'ns
2929+ 25F6 EB           GRBARY: ex      DE,HL
2930+ 25F7 2A AA 52             ld      HL,(CUROPR)     ; Get address of next array
2931+ 25FA EB                   ex      DE,HL
2932+ 25FB CD 84 19             call    CPDEHL          ; Is this array finished?
2933+ 25FE CA D7 25             jp      Z,ARRLP         ; Yes - Get next one
2934+ 2601 01 F6 25             ld      BC,GRBARY       ; Loop until array all done
2935+ 2604 C5           STPOOL: push    BC              ; Save return address
2936+ 2605 F6 80                or      $80             ; Flag string type
2937+ 2607 7E           STRADD: ld      A,(HL)          ; Get string length
2938+ 2608 23                   inc     HL
2939+ 2609 23                   inc     HL
2940+ 260A 5E                   ld      E,(HL)          ; Get LSB of string address
2941+ 260B 23                   inc     HL
2942+ 260C 56                   ld      D,(HL)          ; Get MSB of string address
2943+ 260D 23                   inc     HL
2944+ 260E F0                   ret     P               ; Not a string - Return
2945+ 260F B7                   or      A               ; Set flags on string length
2946+ 2610 C8                   ret     Z               ; Null string - Return
2947+ 2611 44                   ld      B,H             ; Save variable pointer
2948+ 2612 4D                   ld      C,L
2949+ 2613 2A A8 52             ld      HL,(STRBOT)     ; Bottom of new area
2950+ 2616 CD 84 19             call    CPDEHL          ; String been done?
2951+ 2619 60                   ld      H,B             ; Restore variable pointer
2952+ 261A 69                   ld      L,C
2953+ 261B D8                   ret     C               ; String done - Ignore
2954+ 261C E1                   pop     HL              ; Return address
2955+ 261D E3                   ex      (SP),HL         ; Lowest available string area
2956+ 261E CD 84 19             call    CPDEHL          ; String within string area?
2957+ 2621 E3                   ex      (SP),HL         ; Lowest available string area
2958+ 2622 E5                   push    HL              ; Re-save return address
2959+ 2623 60                   ld      H,B             ; Restore variable pointer
2960+ 2624 69                   ld      L,C
2961+ 2625 D0                   ret     NC              ; Outside string area - Ignore
2962+ 2626 C1                   pop     BC              ; Get return , Throw 2 away
2963+ 2627 F1                   pop     AF              ;
2964+ 2628 F1                   pop     AF              ;
2965+ 2629 E5                   push    HL              ; Save variable pointer
2966+ 262A D5                   push    DE              ; Save address of current
2967+ 262B C5                   push    BC              ; Put back return address
2968+ 262C C9                   ret                     ; Go to it
2969+ 262D
2970+ 262D D1           SCNEND: pop     DE              ; Addresses of strings
2971+ 262E E1                   pop     HL              ;
2972+ 262F 7D                   ld      A,L             ; HL = 0 if no more to do
2973+ 2630 B4                   or      H
2974+ 2631 C8                   ret     Z               ; No more to do - Return
2975+ 2632 2B                   dec     HL
2976+ 2633 46                   ld      B,(HL)          ; MSB of address of string
2977+ 2634 2B                   dec     HL
2978+ 2635 4E                   ld      C,(HL)          ; LSB of address of string
2979+ 2636 E5                   push    HL              ; Save variable address
2980+ 2637 2B                   dec     HL
2981+ 2638 2B                   dec     HL
2982+ 2639 6E                   ld      L,(HL)          ; HL = Length of string
2983+ 263A 26 00                ld      H,$00
2984+ 263C 09                   add     HL,BC           ; Address of end of string+1
2985+ 263D 50                   ld      D,B             ; String address to DE
2986+ 263E 59                   ld      E,C
2987+ 263F 2B                   dec     HL              ; Last byte in string
2988+ 2640 44                   ld      B,H             ; Address to BC
2989+ 2641 4D                   ld      C,L
2990+ 2642 2A A8 52             ld      HL,(STRBOT)     ; Current bottom of string area
2991+ 2645 CD 57 16             call    MOVSTR          ; Move string to new address
2992+ 2648 E1                   pop     HL              ; Restore variable address
2993+ 2649 71                   ld      (HL),C          ; Save new LSB of address
2994+ 264A 23                   inc     HL
2995+ 264B 70                   ld      (HL),B          ; Save new MSB of address
2996+ 264C 69                   ld      L,C             ; Next string area+1 to HL
2997+ 264D 60                   ld      H,B
2998+ 264E 2B                   dec     HL              ; Next string area address
2999+ 264F C3 A2 25             jp      GARBLP          ; Look for more strings
3000+ 2652
3001+ 2652 C5           CONCAT: push    BC              ; Save prec' opr & code string
3002+ 2653 E5                   push    HL              ;
3003+ 2654 2A 30 53             ld      HL,(FPREG)      ; Get first string
3004+ 2657 E3                   ex      (SP),HL         ; Save first string
3005+ 2658 CD DD 20             call    OPRND           ; Get second string
3006+ 265B E3                   ex      (SP),HL         ; Restore first string
3007+ 265C CD 58 20             call    TSTSTR          ; Make sure it's a string
3008+ 265F 7E                   ld      A,(HL)          ; Get length of second string
3009+ 2660 E5                   push    HL              ; Save first string
3010+ 2661 2A 30 53             ld      HL,(FPREG)      ; Get second string
3011+ 2664 E5                   push    HL              ; Save second string
3012+ 2665 86                   add     A,(HL)          ; Add length of second string
3013+ 2666 1E 1C                ld      E,LS            ; ?LS Error
3014+ 2668 DA BC 16             jp      C,ERROR         ; String too long - Error
3015+ 266B CD 0B 25             call    MKTMST          ; Make temporary string
3016+ 266E D1                   pop     DE              ; Get second string to DE
3017+ 266F CD A3 26             call    GSTRDE          ; Move to string pool if needed
3018+ 2672 E3                   ex      (SP),HL         ; Get first string
3019+ 2673 CD A2 26             call    GSTRHL          ; Move to string pool if needed
3020+ 2676 E5                   push    HL              ; Save first string
3021+ 2677 2A A6 52             ld      HL,(TMPSTR+2)   ; Temporary string address
3022+ 267A EB                   ex      DE,HL           ; To DE
3023+ 267B CD 89 26             call    SSTSA           ; First string to string area
3024+ 267E CD 89 26             call    SSTSA           ; Second string to string area
3025+ 2681 21 72 20             ld      HL,EVAL2        ; Return to evaluation loop
3026+ 2684 E3                   ex      (SP),HL         ; Save return,get code string
3027+ 2685 E5                   push    HL              ; Save code string address
3028+ 2686 C3 3C 25             jp      TSTOPL          ; To temporary string to pool
3029+ 2689
3030+ 2689 E1           SSTSA:  pop     HL              ; Return address
3031+ 268A E3                   ex      (SP),HL         ; Get string block,save return
3032+ 268B 7E                   ld      A,(HL)          ; Get length of string
3033+ 268C 23                   inc     HL
3034+ 268D 23                   inc     HL
3035+ 268E 4E                   ld      C,(HL)          ; Get LSB of string address
3036+ 268F 23                   inc     HL
3037+ 2690 46                   ld      B,(HL)          ; Get MSB of string address
3038+ 2691 6F                   ld      L,A             ; Length to L
3039+ 2692 2C           TOSTRA: inc     L               ; inc - DECed after
3040+ 2693 2D           TSALP:  dec     L               ; Count bytes moved
3041+ 2694 C8                   ret     Z               ; End of string - Return
3042+ 2695 0A                   ld      A,(BC)          ; Get source
3043+ 2696 12                   ld      (DE),A          ; Save destination
3044+ 2697 03                   inc     BC              ; Next source
3045+ 2698 13                   inc     DE              ; Next destination
3046+ 2699 C3 93 26             jp      TSALP           ; Loop until string moved
3047+ 269C
3048+ 269C CD 58 20     GETSTR: call    TSTSTR          ; Make sure it's a string
3049+ 269F 2A 30 53     GSTRCU: ld      HL,(FPREG)      ; Get current string
3050+ 26A2 EB           GSTRHL: ex      DE,HL           ; Save DE
3051+ 26A3 CD BD 26     GSTRDE: call    BAKTMP          ; Was it last tmp-str?
3052+ 26A6 EB                   ex      DE,HL           ; Restore DE
3053+ 26A7 C0                   ret     NZ              ; No - Return
3054+ 26A8 D5                   push    DE              ; Save string
3055+ 26A9 50                   ld      D,B             ; String block address to DE
3056+ 26AA 59                   ld      E,C
3057+ 26AB 1B                   dec     DE              ; Point to length
3058+ 26AC 4E                   ld      C,(HL)          ; Get string length
3059+ 26AD 2A A8 52             ld      HL,(STRBOT)     ; Current bottom of string area
3060+ 26B0 CD 84 19             call    CPDEHL          ; Last one in string area?
3061+ 26B3 C2 BB 26             jp      NZ,POPHL        ; No - Return
3062+ 26B6 47                   ld      B,A             ; Clear B (A=0)
3063+ 26B7 09                   add     HL,BC           ; Remove string from str' area
3064+ 26B8 22 A8 52             ld      (STRBOT),HL     ; Save new bottom of str' area
3065+ 26BB E1           POPHL:  pop     HL              ; Restore string
3066+ 26BC C9                   ret
3067+ 26BD
3068+ 26BD 2A 96 52     BAKTMP: ld      HL,(TMSTPT)     ; Get temporary string pool top
3069+ 26C0 2B                   dec     HL              ; Back
3070+ 26C1 46                   ld      B,(HL)          ; Get MSB of address
3071+ 26C2 2B                   dec     HL              ; Back
3072+ 26C3 4E                   ld      C,(HL)          ; Get LSB of address
3073+ 26C4 2B                   dec     HL              ; Back
3074+ 26C5 2B                   dec     HL              ; Back
3075+ 26C6 CD 84 19             call    CPDEHL          ; String last in string pool?
3076+ 26C9 C0                   ret     NZ              ; Yes - Leave it
3077+ 26CA 22 96 52             ld      (TMSTPT),HL     ; Save new string pool top
3078+ 26CD C9                   ret
3079+ 26CE
3080+ 26CE 01 4D 24     LEN:    ld      BC,PASSA        ; To return integer A
3081+ 26D1 C5                   push    BC              ; Save address
3082+ 26D2 CD 9C 26     GETLEN: call    GETSTR          ; Get string and its length
3083+ 26D5 AF                   xor     A
3084+ 26D6 57                   ld      D,A             ; Clear D
3085+ 26D7 32 92 52             ld      (TYPE),A        ; Set type to numeric
3086+ 26DA 7E                   ld      A,(HL)          ; Get length of string
3087+ 26DB B7                   or      A               ; Set status flags
3088+ 26DC C9                   ret
3089+ 26DD
3090+ 26DD 01 4D 24     ASC:    ld      BC,PASSA        ; To return integer A
3091+ 26E0 C5                   push    BC              ; Save address
3092+ 26E1 CD D2 26     GTFLNM: call    GETLEN          ; Get length of string
3093+ 26E4 CA 96 1C             jp      Z,FCERR         ; Null string - Error
3094+ 26E7 23                   inc     HL
3095+ 26E8 23                   inc     HL
3096+ 26E9 5E                   ld      E,(HL)          ; Get LSB of address
3097+ 26EA 23                   inc     HL
3098+ 26EB 56                   ld      D,(HL)          ; Get MSB of address
3099+ 26EC 1A                   ld      A,(DE)          ; Get first byte of string
3100+ 26ED C9                   ret
3101+ 26EE
3102+ 26EE 3E 01        CHR:    ld      A,$01           ; One character string
3103+ 26F0 CD 0B 25             call    MKTMST          ; Make a temporary string
3104+ 26F3 CD DD 28             call    MAKINT          ; Make it integer A
3105+ 26F6 2A A6 52             ld      HL,(TMPSTR+2)   ; Get address of string
3106+ 26F9 73                   ld      (HL),E          ; Save character
3107+ 26FA C1           TOPOOL: pop     BC              ; Clean up stack
3108+ 26FB C3 3C 25             jp      TSTOPL          ; Temporary string to pool
3109+ 26FE
3110+ 26FE CD 8D 28     LEFT:   call    LFRGNM          ; Get number and ending ")"
3111+ 2701 AF                   xor     A               ; Start at first byte in string
3112+ 2702 E3           RIGHT1: ex      (SP),HL         ; Save code string,Get string
3113+ 2703 4F                   ld      C,A             ; Starting position in string
3114+ 2704 E5           MID1:   push    HL              ; Save string block address
3115+ 2705 7E                   ld      A,(HL)          ; Get length of string
3116+ 2706 B8                   cp      B               ; Compare with number given
3117+ 2707 DA 0C 27             jp      C,ALLFOL        ; All following bytes required
3118+ 270A 78                   ld      A,B             ; Get new length
3119+ 270B 11                   defb    $11             ; Skip "ld C,0"
3120+ 270C 0E 00        ALLFOL: ld      C,$00           ; First byte of string
3121+ 270E C5                   push    BC              ; Save position in string
3122+ 270F CD 75 25             call    TESTR           ; See if enough string space
3123+ 2712 C1                   pop     BC              ; Get position in string
3124+ 2713 E1                   pop     HL              ; Restore string block address
3125+ 2714 E5                   push    HL              ; And re-save it
3126+ 2715 23                   inc     HL
3127+ 2716 23                   inc     HL
3128+ 2717 46                   ld      B,(HL)          ; Get LSB of address
3129+ 2718 23                   inc     HL
3130+ 2719 66                   ld      H,(HL)          ; Get MSB of address
3131+ 271A 68                   ld      L,B             ; HL = address of string
3132+ 271B 06 00                ld      B,$00           ; BC = starting address
3133+ 271D 09                   add     HL,BC           ; Point to that byte
3134+ 271E 44                   ld      B,H             ; BC = source string
3135+ 271F 4D                   ld      C,L
3136+ 2720 CD 0E 25             call    CRTMST          ; Create a string entry
3137+ 2723 6F                   ld      L,A             ; Length of new string
3138+ 2724 CD 92 26             call    TOSTRA          ; Move string to string area
3139+ 2727 D1                   pop     DE              ; Clear stack
3140+ 2728 CD A3 26             call    GSTRDE          ; Move to string pool if needed
3141+ 272B C3 3C 25             jp      TSTOPL          ; Temporary string to pool
3142+ 272E
3143+ 272E
3144+ 272E              ; INSTR statement - look for a string inside another string
3145+ 272E              ; usage: INSTR(A$,B$) -> search for B$ into A$
3146+ 272E              ; return 0 if B$ is not contained into A$ or LEN(A$)<LEN(B$)
3147+ 272E              ; return 1~255 to indicate the starting position of B$ into A$
3148+ 272E              ; ex.: INSTR("HELLO","LO") returns 4
3149+ 272E              LNS1    equ     TMPBFR1
3150+ 272E              ADRS1   equ     TMPBFR2
3151+ 272E              LNS2    equ     TMPBFR3
3152+ 272E              ADRS2   equ     TMPBFR4
3153+ 272E              PT      equ     VIDEOBUFF
3154+ 272E              PT1     equ     VIDEOBUFF+2
3155+ 272E              PT2     equ     VIDEOBUFF+4
3156+ 272E              TP      equ     VIDEOBUFF+6
3157+ 272E              TF      equ     VIDEOBUFF+8
3158+ 272E CD 8A 19     INSTR:  call    CHKSYN          ; make sure "(" follows
3159+ 2731 28                   defb    '('
3160+ 2732 2B                   dec     HL              ; dec 'cause GETCHR increments
3161+ 2733 CD CB 1B             call    GETCHR          ; check if something follows
3162+ 2736 CA A8 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
3163+ 2739 CD 66 20             call    EVAL            ; Evaluate expression
3164+ 273C CD 58 20             call    TSTSTR          ; Make sure it's a string
3165+ 273F 22 E4 52             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3166+ 2742 CD 9F 26             call    GSTRCU          ; check that a string follows
3167+ 2745 CD B0 2E             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3168+ 2748 ED 53 DC 52          ld      (LNS1),DE       ; store values into
3169+ 274C ED 43 DE 52          ld      (ADRS1),BC      ; temp buffers
3170+ 2750 2A E4 52             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3171+ 2753 CD 8A 19             call    CHKSYN          ; Make sure ',' follows
3172+ 2756 2C                   defb    ','
3173+ 2757 2B                   dec     HL              ; dec 'cause GETCHR increments
3174+ 2758 CD CB 1B             call    GETCHR          ; check if something follows
3175+ 275B CA A8 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
3176+ 275E CD 66 20             call    EVAL            ; Evaluate expression
3177+ 2761 CD 58 20             call    TSTSTR          ; Make sure it's a string
3178+ 2764 22 E4 52             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3179+ 2767 CD 9F 26             call    GSTRCU          ; check that a string follows
3180+ 276A CD B0 2E             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3181+ 276D ED 53 E0 52          ld      (LNS2),DE       ; store values into
3182+ 2771 ED 43 E2 52          ld      (ADRS2),BC      ; temp buffers
3183+ 2775 2A E4 52             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3184+ 2778 CD 8A 19             call    CHKSYN          ; make sure ")" follows
3185+ 277B 29                   defb    ')'
3186+ 277C E5                   push    HL              ; store current code string pointer (the point after the ")" ) ...
3187+ 277D FD E1                pop     IY              ; ...into IY
3188+ 277F AF                   xor     A               ; reset 10 RAM cells
3189+ 2780 06 0A                ld      B,$0A           ; (INSTR registers)
3190+ 2782 21 E4 52             ld      HL,PT           ; first cell
3191+ 2785 77           EMPTINS:ld      (HL),A          ; reset cell
3192+ 2786 23                   inc     HL              ; next cell
3193+ 2787 10 FC                djnz    EMPTINS         ; repeat
3194+ 2789 ED 5B E0 52          ld      DE,(LNS2)       ; load len(S2) into DE
3195+ 278D 2A DC 52             ld      HL,(LNS1)       ; load len(S1) into HL
3196+ 2790 CD 97 3F             call    CMP16           ; check that len(S1)>=len(S2)
3197+ 2793 DA 08 28             jp      C,RZINSTR       ; if len(S2)>len(S1) then return 0
3198+ 2796 AF           RPTINST:xor     A               ; reset...
3199+ 2797 32 EA 52             ld      (TP),A          ; ...TP...
3200+ 279A 32 EC 52             ld      (TF),A          ; ...and TF
3201+ 279D ED 4B E4 52          ld      BC,(PT)         ; pointer to S1
3202+ 27A1 2A DE 52             ld      HL,(ADRS1)      ; first cell of S1
3203+ 27A4 09                   add     HL,BC           ; get current position into RAM
3204+ 27A5 7E                   ld      A,(HL)          ; load S1(PT)
3205+ 27A6 2A E2 52             ld      HL,(ADRS2)      ; pointer to first char of S2
3206+ 27A9 BE                   cp      (HL)            ; is S1(PT)=S2(0)?
3207+ 27AA 20 3A                jr      NZ,CNT1INS      ; no, continue
3208+ 27AC 3A E4 52             ld      A,(PT)          ; load current PT
3209+ 27AF 32 EA 52             ld      (TP),A          ; TP=PT
3210+ 27B2 32 E6 52             ld      (PT1),A         ; P1=PT
3211+ 27B5 AF                   xor     A               ; set...
3212+ 27B6 32 E8 52             ld      (PT2),A         ; ...PT2=0
3213+ 27B9 3C                   inc     A               ;
3214+ 27BA 32 EC 52             ld      (TF),A          ; set TF=1
3215+ 27BD ED 4B E6 52  RP2INST:ld      BC,(PT1)        ; load pointer PT1
3216+ 27C1 2A DE 52             ld      HL,(ADRS1)      ; load address of S1
3217+ 27C4 09                   add     HL,BC           ; find char of S1 pointed by PT1
3218+ 27C5 7E                   ld      A,(HL)          ; load S1(PT1)
3219+ 27C6 ED 4B E8 52          ld      BC,(PT2)        ; load pointer PT2
3220+ 27CA 2A E2 52             ld      HL,(ADRS2)      ; load char of S2 pointed by PT2
3221+ 27CD 09                   add     HL,BC           ; find S2(PT2)
3222+ 27CE BE                   cp      (HL)            ; is S1(PT1)=S2(PT2)?
3223+ 27CF 20 4C                jr      NZ,CNTZIN       ; no, exit inner loop
3224+ 27D1 21 E6 52             ld      HL,PT1
3225+ 27D4 34                   inc     (HL)            ; increment PT1
3226+ 27D5 3A E8 52             ld      A,(PT2)
3227+ 27D8 3C                   inc     A               ; increment PT2
3228+ 27D9 32 E8 52             ld      (PT2),A
3229+ 27DC CA E6 27             jp      Z,CNT1INS       ; if PT2>255 then exit
3230+ 27DF 21 E0 52             ld      HL,LNS2         ; len(S2)
3231+ 27E2 BE                   cp      (HL)            ; PT2=len(S2)?
3232+ 27E3 DA BD 27             jp      C,RP2INST       ; no (PT2<len(S2) - repeat
3233+ 27E6 3A EC 52     CNT1INS:ld      A,(TF)          ; check TF
3234+ 27E9 A7                   and     A               ; TF=0? (clears also Carry for next SBC)
3235+ 27EA 20 1C                jr      NZ,RZINSTR      ; no, exit
3236+ 27EC 2A DC 52             ld      HL,(LNS1)       ; load len(S1)
3237+ 27EF ED 4B E0 52          ld      BC,(LNS2)       ; load len(S2)
3238+ 27F3 ED 42                sbc     HL,BC           ; HL=len(S1)-len(S2)
3239+ 27F5 ED 5B E4 52          ld      DE,(PT)         ; load pointer
3240+ 27F9 1C                   inc     E               ; PT=PT+1
3241+ 27FA ED 53 E4 52          ld      (PT),DE         ; store new value
3242+ 27FE EB                   ex      DE,HL           ; invert registers
3243+ 27FF CD 97 3F             call    CMP16           ; check if PT>len(S1)-len(S2)
3244+ 2802 DA 96 27             jp      C,RPTINST       ; repeat if <
3245+ 2805 CA 96 27             jp      Z,RPTINST       ; repeat if =
3246+ 2808 3A EC 52     RZINSTR:ld      A,(TF)          ; current value of TF
3247+ 280B A7                   and     A               ; is it 0?
3248+ 280C CA 13 28             jp      Z,LVINSTR       ; yes, return 0
3249+ 280F 3A EA 52             ld      A,(TP)          ; return TP...
3250+ 2812 3C                   inc     A               ; ...incremented by 1
3251+ 2813 E1           LVINSTR:pop     HL              ; drop original return point
3252+ 2814 FD E5                push    IY              ; load current string address from IY into stack
3253+ 2816 11 3F 21             ld      DE,RETNUM       ; Address of Return number from function...
3254+ 2819 D5                   push    DE              ; ...saved on stack
3255+ 281A C3 4D 24             jp      PASSA           ; return TP
3256+ 281D AF           CNTZIN: xor     A               ; set...
3257+ 281E 32 EC 52             ld      (TF),A          ; TF=0
3258+ 2821 C3 E6 27             jp      CNT1INS         ; continue
3259+ 2824
3260+ 2824
3261+ 2824 CD 8D 28     RIGHT:  call    LFRGNM          ; Get number and ending ")"
3262+ 2827 D1                   pop     DE              ; Get string length
3263+ 2828 D5                   push    DE              ; And re-save
3264+ 2829 1A                   ld      A,(DE)          ; Get length
3265+ 282A 90                   sub     B               ; Move back N bytes
3266+ 282B C3 02 27             jp      RIGHT1          ; Go and get sub-string
3267+ 282E
3268+ 282E EB           MID:    ex      DE,HL           ; Get code string address
3269+ 282F 7E                   ld      A,(HL)          ; Get next byte ',' or ")"
3270+ 2830 CD 92 28             call    MIDNUM          ; Get number supplied
3271+ 2833 04                   inc     B               ; Is it character zero?
3272+ 2834 05                   dec     B
3273+ 2835 CA 96 1C             jp      Z,FCERR         ; Yes - Error
3274+ 2838 C5                   push    BC              ; Save starting position
3275+ 2839 1E FF                ld      E,$FF           ; All of string
3276+ 283B FE 29                cp      ')'             ; Any length given?
3277+ 283D CA 47 28             jp      Z,RSTSTR        ; No - Rest of string
3278+ 2840 CD 8A 19             call    CHKSYN          ; Make sure ',' follows
3279+ 2843 2C                   defb    ','
3280+ 2844 CD DA 28             call    GETINT          ; Get integer 0-255
3281+ 2847 CD 8A 19     RSTSTR: call    CHKSYN          ; Make sure ")" follows
3282+ 284A 29                   defb    ')'
3283+ 284B F1                   pop     AF              ; Restore starting position
3284+ 284C E3                   ex      (SP),HL         ; Get string,save code string
3285+ 284D 01 04 27             ld      BC,MID1         ; Continuation of MID$ routine
3286+ 2850 C5                   push    BC              ; Save for return
3287+ 2851 3D                   dec     A               ; Starting position-1
3288+ 2852 BE                   cp      (HL)            ; Compare with length
3289+ 2853 06 00                ld      B,$00           ; Zero bytes length
3290+ 2855 D0                   ret     NC              ; Null string if start past end
3291+ 2856 4F                   ld      C,A             ; Save starting position-1
3292+ 2857 7E                   ld      A,(HL)          ; Get length of string
3293+ 2858 91                   sub     C               ; Subtract start
3294+ 2859 BB                   cp      E               ; Enough string for it?
3295+ 285A 47                   ld      B,A             ; Save maximum length available
3296+ 285B D8                   ret     C               ; Truncate string if needed
3297+ 285C 43                   ld      B,E             ; Set specified length
3298+ 285D C9                   ret                     ; Go and create string
3299+ 285E
3300+ 285E CD D2 26     VAL:    call    GETLEN          ; Get length of string
3301+ 2861 CA 30 2C             jp      Z,RESZER        ; Result zero
3302+ 2864 5F                   ld      E,A             ; Save length
3303+ 2865 23                   inc     HL
3304+ 2866 23                   inc     HL
3305+ 2867 7E                   ld      A,(HL)          ; Get LSB of address
3306+ 2868 23                   inc     HL
3307+ 2869 66                   ld      H,(HL)          ; Get MSB of address
3308+ 286A 6F                   ld      L,A             ; HL = String address
3309+ 286B E5                   push    HL              ; Save string address
3310+ 286C 19                   add     HL,DE
3311+ 286D 46                   ld      B,(HL)          ; Get end of string+1 byte
3312+ 286E 72                   ld      (HL),D          ; Zero it to terminate
3313+ 286F E3                   ex      (SP),HL         ; Save string end,get start
3314+ 2870 C5                   push    BC              ; Save end+1 byte
3315+ 2871 7E                   ld      A,(HL)          ; Get starting byte
3316+ 2872 FE 24                cp      '$'             ; Hex number indicated? [function added]
3317+ 2874 C2 7C 28             jp      NZ,VAL1
3318+ 2877 CD D0 3E             call    HEXTFP          ; Convert Hex to FPREG
3319+ 287A 18 0D                jr      VAL3
3320+ 287C FE 25        VAL1:   cp      '%'             ; Binary number indicated? [function added]
3321+ 287E C2 86 28             jp      NZ,VAL2
3322+ 2881 CD 40 3F             call    BINTFP          ; Convert Bin to FPREG
3323+ 2884 18 03                jr      VAL3
3324+ 2886 CD 68 2F     VAL2:   call    ASCTFP          ; Convert ASCII string to FP
3325+ 2889 C1           VAL3:   pop     BC              ; Restore end+1 byte
3326+ 288A E1                   pop     HL              ; Restore end+1 address
3327+ 288B 70                   ld      (HL),B          ; Put back original byte
3328+ 288C C9                   ret
3329+ 288D
3330+ 288D EB           LFRGNM: ex      DE,HL           ; Code string address to HL
3331+ 288E CD 8A 19             call    CHKSYN          ; Make sure ")" follows
3332+ 2891 29                   defb    ')'
3333+ 2892 C1           MIDNUM: pop     BC              ; Get return address
3334+ 2893 D1                   pop     DE              ; Get number supplied
3335+ 2894 C5                   push    BC              ; Re-save return address
3336+ 2895 43                   ld      B,E             ; Number to B
3337+ 2896 C9                   ret
3338+ 2897
3339+ 2897 CD DD 28     INP:    call    MAKINT          ; Make it integer A
3340+ 289A 32 9E 51             ld      (INPORT),A      ; Set input port
3341+ 289D CD 9D 51             call    INPSUB          ; Get input from port
3342+ 28A0 C3 4D 24             jp      PASSA           ; Return integer A
3343+ 28A3
3344+ 28A3 CD C7 28     POUT:   call    SETIO           ; Set up port number
3345+ 28A6 C3 65 51             jp      OUTSUB          ; Output data and return
3346+ 28A9
3347+ 28A9 CD C7 28     WAIT:   call    SETIO           ; Set up port number
3348+ 28AC F5                   push    AF              ; Save AND mask
3349+ 28AD 1E 00                ld      E,$00           ; Assume zero if none given
3350+ 28AF 2B                   dec     HL              ; dec 'cos GETCHR INCs
3351+ 28B0 CD CB 1B             call    GETCHR          ; Get next character
3352+ 28B3 CA BD 28             jp      Z,NOXOR         ; No XOR byte given
3353+ 28B6 CD 8A 19             call    CHKSYN          ; Make sure ',' follows
3354+ 28B9 2C                   defb    ','
3355+ 28BA CD DA 28             call    GETINT          ; Get integer 0-255 to XOR with
3356+ 28BD C1           NOXOR:  pop     BC              ; Restore AND mask
3357+ 28BE CD 9D 51     WAITLP: call    INPSUB          ; Get input
3358+ 28C1 AB                   xor     E               ; Flip selected bits
3359+ 28C2 A0                   and     B               ; Result non-zero?
3360+ 28C3 CA BE 28             jp      Z,WAITLP        ; No = keep waiting
3361+ 28C6 C9                   ret
3362+ 28C7
3363+ 28C7 CD DA 28     SETIO:  call    GETINT          ; Get integer 0-255
3364+ 28CA 32 9E 51             ld      (INPORT),A      ; Set input port
3365+ 28CD 32 66 51             ld      (OTPORT),A      ; Set output port
3366+ 28D0 CD 8A 19             call    CHKSYN          ; Make sure ',' follows
3367+ 28D3 2C                   defb    ','
3368+ 28D4 C3 DA 28             jp      GETINT          ; Get integer 0-255 and return
3369+ 28D7
3370+ 28D7 CD CB 1B     FNDNUM: call    GETCHR          ; Get next character
3371+ 28DA CD 54 20     GETINT: call    GETNUM          ; Get a number from 0 to 255
3372+ 28DD CD 7B 1C     MAKINT: call    DEPINT          ; Make sure value 0 - 255
3373+ 28E0 7A                   ld      A,D             ; Get MSB of number
3374+ 28E1 B7                   or      A               ; Zero?
3375+ 28E2 C2 96 1C             jp      NZ,FCERR        ; No - Error
3376+ 28E5 2B                   dec     HL              ; dec 'cos GETCHR INCs
3377+ 28E6 CD CB 1B             call    GETCHR          ; Get next character
3378+ 28E9 7B                   ld      A,E             ; Get number to A
3379+ 28EA C9                   ret
3380+ 28EB
3381+ 28EB
3382+ 28EB              ; activate a Non-Maskable Interrupt hooked to VDP interrupt signal
3383+ 28EB CD 54 20     NMI:    call    GETNUM          ; Get memory address
3384+ 28EE CD 81 1C             call    DEINT           ; get integer -32768 to 32767
3385+ 28F1 7B                   ld      A,E             ; check if address is 0
3386+ 28F2 B2                   or      D
3387+ 28F3 20 11                jr      NZ,NM1          ; no, so jump over
3388+ 28F5 F3           DISNMI: di                      ; disable INTs
3389+ 28F6 CD 22 29             call    NMIDINT         ; disable VDP INT
3390+ 28F9 E5                   push    HL              ; store HL
3391+ 28FA 21 ED 45             ld      HL,$45ED        ; these are the op-codes for "RETN"
3392+ 28FD 22 5F 51             ld      (NMIUSR),HL     ; store RETN
3393+ 2900 AF                   xor     A
3394+ 2901 32 61 51             ld      (NMIUSR+2),A    ; "NOP"
3395+ 2904 18 11                jr      NMI2            ; execute the last part of code
3396+ 2906 E5           NM1:    push    HL              ; store current HL
3397+ 2907 EB                   ex      DE,HL           ; move address argument into HL
3398+ 2908 F3                   di                      ; disable INTs
3399+ 2909 CD 22 29             call    NMIDINT         ; disable VDP INT, if enabled
3400+ 290C 3E C3                ld      A,$C3           ; "jp" instruction
3401+ 290E 32 5F 51             ld      (NMIUSR),A      ; store it
3402+ 2911 22 60 51             ld      (NMIUSR+1),HL   ; store address
3403+ 2914 CD 1B 29             call    NMIEINT         ; re-enable VDP INT
3404+ 2917 FB           NMI2:   ei                      ; re-enable INTS
3405+ 2918 00                   nop                     ; wait for INTs
3406+ 2919 E1                   pop    HL               ; retrieve HL
3407+ 291A C9                   ret                     ; return to caller
3408+ 291B              ; enable VDP INT
3409+ 291B CD 31 29     NMIEINT:call    NMIVR1          ; load default VReg #1 setting
3410+ 291E F6 20                or      %00100000       ; enable VDP INT
3411+ 2920 18 03                jr      NMIINT          ; rest of code is shared
3412+ 2922              ; disable VDP INT
3413+ 2922 CD 31 29     NMIDINT:call    NMIVR1          ; load default VReg #1 setting
3414+ 2925 D5           NMIINT: push    DE              ; store DE
3415+ 2926 5F                   ld      E,A             ; move value into E
3416+ 2927 3E 01                ld      A,$01           ; VREG #1
3417+ 2929 F3                   di                      ; disable INTs
3418+ 292A CD AF 06             call    WRITE_VREG      ; disable VDP INT
3419+ 292D FB                   ei                      ; re-enable INTs
3420+ 292E 00                   nop                     ; wait for INTs being enabled
3421+ 292F D1                   pop     DE              ; retrieve DE
3422+ 2930 C9                   ret                     ; return to caller
3423+ 2931
3424+ 2931              ; load VREG #1 setting for current screen mode and return it into A
3425+ 2931 E5           NMIVR1: push    HL              ; store HL
3426+ 2932 D5                   push    DE              ; store DE
3427+ 2933 3A CD 52             ld      A,(SCR_MODE)    ; check screen mode
3428+ 2936 87                   add     A,A             ; multiply A by 8...
3429+ 2937 87                   add     A,A             ; ...so that reg. A can points..
3430+ 2938 87                   add     A,A             ; to the correct settings
3431+ 2939 3C                   inc     A               ; need to change VREG 1
3432+ 293A 5F                   ld      E,A             ; copy A into E
3433+ 293B 16 00                ld      D,$00           ; reset D
3434+ 293D 21 F2 0A             ld      HL,VDPMODESET   ; pointer to register #1 setting...
3435+ 2940 19                   add     HL,DE           ; ...for current screen mode
3436+ 2941 7E                   ld      A,(HL)          ; load current setting
3437+ 2942 D1                   pop     DE              ; retrieve DE
3438+ 2943 E1                   pop     HL              ; retrieve HL
3439+ 2944 C9                   ret                     ; return to caller
3440+ 2945
3441+ 2945              ; execute a machine language routine, eventually passing a param into A
3442+ 2945 CD 54 20     SYS:    call    GETNUM          ; Get memory address
3443+ 2948 CD 81 1C             call    DEINT           ; Get integer -32768 to 32767
3444+ 294B ED 53 DE 52          ld      (TMPBFR2),DE    ; store user routine's address
3445+ 294F AF                   xor     A               ; reset A
3446+ 2950 32 DC 52             ld      (TMPBFR1),A     ; store into temp buffer
3447+ 2953 2B                   dec     HL              ; dec 'cos GETCHR INCs
3448+ 2954 CD CB 1B             call    GETCHR          ; check next character
3449+ 2957 28 0A                jr      Z,NOSYSPR       ; jump if nothing follows
3450+ 2959 CD 8A 19             call    CHKSYN          ; Make sure ',' follows
3451+ 295C 2C                   defb    ','
3452+ 295D CD DA 28             call    GETINT          ; get byte value (0~255) if something follows
3453+ 2960 32 DC 52             ld      (TMPBFR1),A     ; store into temp buffer
3454+ 2963 3A DC 52     NOSYSPR:ld      A,(TMPBFR1)     ; recover A
3455+ 2966 ED 5B DE 52          ld      DE,(TMPBFR2)    ; recover user routine's address
3456+ 296A E5                   push    HL              ; save code string address
3457+ 296B EB                   ex      DE,HL           ; move user routine's address into HL
3458+ 296C 11 71 29             ld      DE,SYSRET       ; set point of return after the user routine
3459+ 296F D5                   push    DE              ; store into stack
3460+ 2970 E9                   jp      (HL)            ; call user routine
3461+ 2971 E1           SYSRET: pop     HL              ; retrieve code string address
3462+ 2972 C9                   ret                     ; return to caller
3463+ 2973
3464+ 2973
3465+ 2973              ; read the contents of a byte from RAM
3466+ 2973 CD 81 1C     PEEK:   call    DEINT           ; Get memory address into DE
3467+ 2976 1A                   ld      A,(DE)          ; Read value of memory cell
3468+ 2977 C3 4D 24             jp      PASSA           ; Return into A
3469+ 297A
3470+ 297A              ; read the contents of a byte from VRAM
3471+ 297A CD 81 1C     VPEEK:  call    DEINT           ; Get VRAM address into DE
3472+ 297D EB                   ex      DE,HL           ; Copy param into HL
3473+ 297E F3                   di                      ; Disable interrupts
3474+ 297F CD 85 06             call    READ_VIDEO_LOC  ; Read data from VRAM at address HL
3475+ 2982 FB                   ei                      ; Re-enable interrupts
3476+ 2983 EB                   ex      DE,HL           ; Restore HL
3477+ 2984 C3 4D 24             jp      PASSA           ; Return value into A
3478+ 2987
3479+ 2987              ; recover params for POKE/VPOKE commands
3480+ 2987              ; returns address into DE and byte to be written into A
3481+ 2987 CD 54 20     PKEPRMS:call    GETNUM          ; Get memory address
3482+ 298A CD 81 1C             call    DEINT           ; Get integer -32768 to 32767
3483+ 298D ED 53 DC 52          ld      (TMPBFR1),DE    ; Store DE into a temp. buffer
3484+ 2991 CD 8A 19             call    CHKSYN          ; Make sure ',' follows
3485+ 2994 2C                   defb    ','
3486+ 2995 CD DA 28             call    GETINT          ; Get integer 0-255
3487+ 2998 ED 5B DC 52          ld      DE,(TMPBFR1)    ; Restore memory address
3488+ 299C C9                   ret                     ; Return to caller
3489+ 299D
3490+ 299D              ; write a byte into SRAM
3491+ 299D CD 87 29     POKE:   call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3492+ 29A0 12                   ld      (DE),A          ; Load it into memory
3493+ 29A1 C9                   ret
3494+ 29A2
3495+ 29A2              ; write a byte into VRAM
3496+ 29A2 CD 87 29     VPOKE:  call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3497+ 29A5 EB                   ex      DE,HL           ; Copy address into HL
3498+ 29A6 F3                   di                      ; Disable interrupts
3499+ 29A7 CD 9A 06             call    WRITE_VIDEO_LOC ; write data into VRAM at address HL
3500+ 29AA FB                   ei                      ; Re-enable interrupts
3501+ 29AB EB                   ex      DE,HL           ; Restore HL
3502+ 29AC C9                   ret                     ; Return to caller
3503+ 29AD
3504+ 29AD              ; position the cursor at a specific X,Y location onto screen
3505+ 29AD CD DA 28     LOCATE: call    GETINT          ; get the first param into A
3506+ 29B0 E5                   push    HL              ; store HL
3507+ 29B1 21 CB 52             ld      HL,SCR_SIZE_W   ; load address of screen width
3508+ 29B4 5E                   ld      E,(HL)          ; load screen width into E
3509+ 29B5 E1                   pop     HL              ; restore HL
3510+ 29B6 BB                   cp      E               ; compare witdh with param
3511+ 29B7 D2 96 1C             jp      NC,FCERR        ; value over the width of the screen, exit with Illegal F.C. error
3512+ 29BA 32 DC 52             ld      (TMPBFR1),A     ; Store X into a temp. buffer
3513+ 29BD CD 8A 19             call    CHKSYN          ; Make sure ',' follows
3514+ 29C0 2C                   defb    ','
3515+ 29C1 CD DA 28             call    GETINT          ; Get the second param into A
3516+ 29C4 E5                   push    HL              ; store HL
3517+ 29C5 21 CC 52             ld      HL,SCR_SIZE_H   ; load address of screen width
3518+ 29C8 5E                   ld      E,(HL)          ; load screen width into A
3519+ 29C9 E1                   pop     HL              ; restore HL
3520+ 29CA BB                   cp      E               ; compare witdh with param
3521+ 29CB D2 96 1C             jp      NC,FCERR        ; value over the height of the screen, exit with Illegal F.C. error
3522+ 29CE 32 D4 52             ld      (SCR_CUR_NY),A  ; store new Y
3523+ 29D1 3A DC 52             ld      A,(TMPBFR1)     ; recover the new X
3524+ 29D4 32 D3 52             ld      (SCR_CUR_NX),A  ; store new X
3525+ 29D7 E5                   push    HL              ; store HL
3526+ 29D8 F3                   di                      ; disable INTs
3527+ 29D9 CD CB 06             call    MOVCRS          ; move cursor to new location
3528+ 29DC FB                   ei                      ; re-enable INTs
3529+ 29DD E1                   pop     HL              ; restore HL
3530+ 29DE C9                   ret                     ; return to caller
3531+ 29DF
3532+ 29DF              ; write a byte into one of the PSG registers
3533+ 29DF CD DA 28     SREG:   call    GETINT          ; Get register number back into A
3534+ 29E2 FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3535+ 29E4 D2 96 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3536+ 29E7 32 DC 52             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3537+ 29EA CD 8A 19             call    CHKSYN          ; Make sure ',' follows
3538+ 29ED 2C                   defb    ','
3539+ 29EE CD DA 28             call    GETINT          ; get second value (0-255), returned into A
3540+ 29F1 5F                   ld      E,A             ; store value into E
3541+ 29F2 3A DC 52             ld      A,(TMPBFR1)     ; recover VDP register and store into D
3542+ 29F5 F3                   di                      ; disable INTs
3543+ 29F6 0E 40                ld      C,PSG_REG       ; output port to access PSG registers
3544+ 29F8 ED 79                out     (C),A           ; send register # to PSG
3545+ 29FA 0E 41                ld      C,PSG_DAT       ; output port to send data to PSG
3546+ 29FC ED 59                out     (C),E           ; send byte to write into selected register
3547+ 29FE FB                   ei                      ; re-enable INTs
3548+ 29FF C9                   ret                     ; return to caller
3549+ 2A00
3550+ 2A00              ; VOLUME ch,vol
3551+ 2A00              ; set the volume for the audio channels
3552+ 2A00              ; "ch" is 1~3 for corresponding channel, or 0 for all; "vol" is 0~15 (0=OFF, 15=MAX)
3553+ 2A00 CD DA 28     VOLUME: call    GETINT          ; get integer 0-255 (recover channel)
3554+ 2A03 FE 04                cp      $04             ; check if it's in the range 0~3
3555+ 2A05 D2 96 1C             jp      NC,FCERR        ; if not, exit with Illegal function call error
3556+ 2A08 32 DC 52             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3557+ 2A0B CD 8A 19             call    CHKSYN          ; Make sure ',' follows
3558+ 2A0E 2C                   defb    ','
3559+ 2A0F CD DA 28             call    GETINT          ; get integer 0-255 (recover channel)
3560+ 2A12 FE 10                cp      $10             ; check if it's in the range 0~15
3561+ 2A14 D2 96 1C             jp      NC,FCERR        ; if not, exit with Illegal funcion call
3562+ 2A17 57                   ld      D,A             ; store volume into D
3563+ 2A18 3A DC 52             ld      A,(TMPBFR1)     ; retrieve channel
3564+ 2A1B A7                   and     A               ; is it 0? (0=every channel)
3565+ 2A1C 20 10                jr      NZ,VOLCH        ; no, jump over
3566+ 2A1E 06 03                ld      B,$03           ; yes, set every channel
3567+ 2A20 1E 08                ld      E,$08           ; register volume of first channel
3568+ 2A22 0E 40        RPVOLCG:ld      C,PSG_REG       ; PSG register port
3569+ 2A24 ED 59                out     (C),E           ; set register #
3570+ 2A26 0E 41                ld      C,PSG_DAT       ; PSG data port
3571+ 2A28 ED 51                out     (C),D           ; send volume
3572+ 2A2A 1C                   inc     E               ; next register
3573+ 2A2B 10 F5                djnz    RPVOLCG         ; repeat for each channel
3574+ 2A2D C9                   ret                     ; return to caller
3575+ 2A2E 0E 40        VOLCH:  ld      C,PSG_REG       ; PSG register port
3576+ 2A30 C6 07                add     $07             ; add 7 to A so that we have the correct register (1->8, 2->9, 3->10)
3577+ 2A32 ED 79                out     (C),A           ; set register
3578+ 2A34 0E 41                ld      C,PSG_DAT       ; PSG data port
3579+ 2A36 ED 51                out     (C),D           ; send volume level
3580+ 2A38 C9                   ret                     ; return to caller
3581+ 2A39
3582+ 2A39              ; SOUND ch,tone,dur
3583+ 2A39              ; play a tone or noise of "tone" frequency from selected channel "ch" for duration "dur"
3584+ 2A39              ; "ch" is 1~6 (0=means sound OFF,1~3 for tone, 4~6 for noise) / "tone" is 1~4,095 (0=means no tone) /
3585+ 2A39              ; "dur" is 1~16383 h.o.s.,0.001~163s (0=means non-stop tone)
3586+ 2A39 CD DA 28     SOUND:  call    GETINT          ; get integer 0-255 (recover channel)
3587+ 2A3C A7                   and     A               ; is it zero?
3588+ 2A3D 20 08                jr      NZ,CTSNDC       ; no, continue with checking of params
3589+ 2A3F E5                   push    HL              ; store HL
3590+ 2A40 F3                   di                      ; disable INTs
3591+ 2A41 CD 64 0C             call    CLRPSGREGS      ; yes, it's zero, so reset PSG registers to shut down every sound
3592+ 2A44 FB                   ei                      ; re-enable INTs
3593+ 2A45 E1                   pop     HL              ; retrieve HL
3594+ 2A46 C9                   ret                     ; return to caller
3595+ 2A47 32 DC 52     CTSNDC: ld      (TMPBFR1),A     ; no, continue by storing A into a temp. buffer
3596+ 2A4A FE 04                cp      $04             ; is channel >3?
3597+ 2A4C D2 CB 2A             jp      NC,NOISUP       ; Yes - check to see if it's a noise channel
3598+ 2A4F CD 8A 19             call    CHKSYN          ; No, continue checking by making sure ',' follows
3599+ 2A52 2C                   defb    ','
3600+ 2A53 CD 54 20             call    GETNUM          ; Get tone frequency
3601+ 2A56 CD 81 1C             call    DEINT           ; Get integer -32768 to 32767
3602+ 2A59 ED 53 DE 52          ld      (TMPBFR2),DE    ; Store frequency
3603+ 2A5D CD 8A 19             call    CHKSYN          ; Make sure ',' follows
3604+ 2A60 2C                   defb    ','
3605+ 2A61 CD 54 20             call    GETNUM          ; Get duration
3606+ 2A64 CD 81 1C             call    DEINT           ; Get integer -32768 to 32767
3607+ 2A67 ED 53 E0 52          ld      (TMPBFR3),DE    ; Store duration
3608+ 2A6B                                              ; CHECK CHANNEL
3609+ 2A6B 3A DC 52             ld      A,(TMPBFR1)     ; recover channel
3610+ 2A6E FE 01                cp      $01             ; is channel <1?
3611+ 2A70 DA 96 1C             jp      C,FCERR         ; Yes - Illegal function call error
3612+ 2A73                                              ; CHECK FREQUENCY
3613+ 2A73 ED 5B DE 52          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3614+ 2A77 7A                   ld      A,D             ; move D into A and check if it is in the range 0~4095...
3615+ 2A78 FE 10                cp      $10             ; ...so D must not be greater than $0F (15)
3616+ 2A7A D2 96 1C             jp      NC,FCERR        ; if not in the range, exit with an Illegal function call error
3617+ 2A7D                                              ; CHECK DURATION
3618+ 2A7D ED 5B E0 52          ld      DE,(TMPBFR3)    ; restore duration from temp buffer
3619+ 2A81 7A                   ld      A,D             ; check if it is in the range 0~16383...
3620+ 2A82 E6 C0                and     $C0             ; ...(15th & 14th bits must not be set)
3621+ 2A84 C2 96 1C             jp      NZ,FCERR        ; if not in the range, exit with an Illegal function call error
3622+ 2A87                                              ;
3623+ 2A87                                              ; SET TONE:
3624+ 2A87                                              ; let's start by setting up the channel
3625+ 2A87 3A DC 52             ld      A,(TMPBFR1)     ; restore channel value
3626+ 2A8A FE 03                cp      $03             ; is it 3?
3627+ 2A8C 20 02                jr      NZ,SND1         ; no, jump over
3628+ 2A8E 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3629+ 2A90 2F           SND1:   cpl                     ; complement of A - this is used later to set on the channel into the mixer
3630+ 2A91 CD 18 2B             call    WRTSND          ; enable line into mixer of channel stored in A
3631+ 2A94                                              ; SET FREQUENCY
3632+ 2A94                                              ; we simply get frequency and subtract from 4096. The result
3633+ 2A94                                              ; is put into register pair of the corresponding freq tone channel
3634+ 2A94 ED 5B DE 52          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3635+ 2A98 E5                   push    HL              ; store HL (it will be used by the subroutine)
3636+ 2A99 21 00 10             ld      HL,$1000        ; load 4096 into HL
3637+ 2A9C A7                   and     A               ; reset C flag
3638+ 2A9D ED 52                sbc     HL,DE           ; subtract freq from HL - now the frequency is inverted, so we will send the low as high and vice-versa
3639+ 2A9F 3A DC 52             ld      A,(TMPBFR1)     ; restore channel value
3640+ 2AA2 3D                   dec     A               ; set A into the range 0~2
3641+ 2AA3 87                   add     A,A             ; double A to find the register pair that correspond to the channel (A->0,1 / B->2,3, C->4,5)
3642+ 2AA4 0E 40                ld      C,PSG_REG       ; PSG register port
3643+ 2AA6 ED 79                out     (C),A           ; select first register of the pair
3644+ 2AA8 0E 41                ld      C,PSG_DAT       ; PSG data port
3645+ 2AAA ED 69                out     (C),L           ; send high byte
3646+ 2AAC 0E 40                ld      C,PSG_REG       ; PSG register support
3647+ 2AAE 3C                   inc     A               ; second register of the pair
3648+ 2AAF ED 79                out     (C),A           ; select register
3649+ 2AB1 0E 41                ld      C,PSG_DAT       ; PSG data port
3650+ 2AB3 ED 61                out     (C),H           ; send low byte
3651+ 2AB5 ED 5B E0 52          ld      DE,(TMPBFR3)    ; recover duration
3652+ 2AB9 3A DC 52             ld      A,(TMPBFR1)     ; recover channel value
3653+ 2ABC 3D                   dec     A               ; set channel into the range 0~2
3654+ 2ABD 87                   add     A,A             ; double A to find the correct offset
3655+ 2ABE 21 10 53             ld      HL,CHASNDDTN    ; set duration into...
3656+ 2AC1 85                   add     A,L             ; ...the proper...
3657+ 2AC2 30 01                jr      NC,SNDOVR       ; (is there a rest? no, jump over
3658+ 2AC4 24                   inc     H               ; yes, increment H)
3659+ 2AC5 6F           SNDOVR: ld      L,A             ; ...register pair...
3660+ 2AC6 73                   ld      (HL),E          ; ...and store the value
3661+ 2AC7 23                   inc     HL
3662+ 2AC8 72                   ld      (HL),D
3663+ 2AC9 E1                   pop     HL              ; retrieve HL
3664+ 2ACA C9                   ret                     ; Return to caller
3665+ 2ACB FE 07        NOISUP: cp      $07             ; is channel in range 4 to 6 (for a noise)?
3666+ 2ACD D2 96 1C             jp      NC,FCERR        ; no, so ILLEGAL FUNCTION CALL
3667+ 2AD0 CD 8A 19             call    CHKSYN          ; yes, continue checking by making sure ',' follows
3668+ 2AD3 2C                   defb    ','
3669+ 2AD4 CD DA 28             call    GETINT          ; get integer 0-255 (frequency)
3670+ 2AD7 FE 20                cp      $20             ; make sure it's in range 0~31
3671+ 2AD9 D2 96 1C             jp      NC,FCERR        ; no, so Illegal function call
3672+ 2ADC 32 DE 52             ld      (TMPBFR2),A     ; store freq.
3673+ 2ADF 2B                   dec     HL              ; dec 'cos GETCHR INCs
3674+ 2AE0 CD CB 1B             call    GETCHR          ; check that nothing follows
3675+ 2AE3 C2 A8 16             jp      NZ,SNERR        ; error if no empty line
3676+ 2AE6 3A DE 52             ld      A,(TMPBFR2)     ; retrieve freq.
3677+ 2AE9 5F                   ld      E,A             ; store freq into E
3678+ 2AEA 3A DC 52             ld      A,(TMPBFR1)     ; retrieve channel
3679+ 2AED D6 03                sub     $03             ; subtract 3 to get channel in range 1~3
3680+ 2AEF FE 03                cp      $03             ; is it 3?
3681+ 2AF1 20 02                jr      NZ,NOS1         ; no, jump over
3682+ 2AF3 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3683+ 2AF5 87           NOS1:   add     A,A
3684+ 2AF6 87                   add     A,A
3685+ 2AF7 87                   add     A,A             ; let's move A 3 bits to left
3686+ 2AF8 47                   ld      B,A             ; store channel into B
3687+ 2AF9 7B                   ld      A,E             ; check if
3688+ 2AFA A7                   and     A               ; freq is 0 (means that noise reproduction must be halted)
3689+ 2AFB F3                   di                      ; disable INts
3690+ 2AFC 20 0A                jr      NZ,NOS2         ; no, so jump over
3691+ 2AFE 3E 07                ld      A,$07           ; mixer register
3692+ 2B00 CD B2 0C             call    SETSNDREG       ; set mixer register
3693+ 2B03 ED 78                in      A,(C)           ; load current mixer value
3694+ 2B05 B0                   or      B               ; disable noise
3695+ 2B06 18 19                jr      NOS3            ; continue over
3696+ 2B08 78           NOS2:   ld      A,B             ; recover channel
3697+ 2B09 2F                   cpl                     ; complement of A - this is used to set on the channel into the mixer
3698+ 2B0A CD 18 2B             call    WRTSND          ; enable line into mixer of channel stored in A
3699+ 2B0D 3E 06                ld      A,$06           ; write into noise register
3700+ 2B0F CD B2 0C             call    SETSNDREG       ; set register into PSG
3701+ 2B12 7B                   ld      A,E             ; load value for noise frequency
3702+ 2B13 CD B7 0C             call    WRTSNDREG       ; write data into register $06
3703+ 2B16 FB                   ei                      ; re-enable INTs
3704+ 2B17 C9                   ret
3705+ 2B18                      ; enable line into mixer of channel stored in A
3706+ 2B18 47           WRTSND: ld      B,A             ; move channel into B
3707+ 2B19 3E 07                ld      A,$07           ; mixer register
3708+ 2B1B CD B2 0C             call    SETSNDREG       ; set mixer register
3709+ 2B1E ED 78                in      A,(C)           ; load current value
3710+ 2B20 A0                   and     B               ; set on the channel into the mixer (remember that 0=ON)
3711+ 2B21                                              ; example: if channel is A (1), complement of 1 is 254 (11111110). So, 255 (in case
3712+ 2B21                                              ; the register is still unchanged after reset) is 11111111 and
3713+ 2B21                                              ; 11111111 AND 11111110 is equal to 11111110
3714+ 2B21                                              ; 11111001 AND 11111110 is equal to 11111000 (in case channels B & C are ON)
3715+ 2B21 47           NOS3:   ld      B,A             ; store new mixer value into B
3716+ 2B22 3E 07                ld      A,$07           ; mixer address
3717+ 2B24 CD B2 0C             call    SETSNDREG       ; set register
3718+ 2B27 78                   ld      A,B             ; retrieve new mixer value from B
3719+ 2B28 CD B7 0C             call    WRTSNDREG       ; send new value for the mixer
3720+ 2B2B FB                   ei                      ; re-enable INTs
3721+ 2B2C C9                   ret                     ; return to caller
3722+ 2B2D
3723+ 2B2D              ; write a byte into one of the VDP registers
3724+ 2B2D CD DA 28     VREG:   call    GETINT          ; Get register number back into A
3725+ 2B30 FE 08                cp      $08             ; check if value is equal or greater than 8 (VDP registers are only 8, from 0 to 7)
3726+ 2B32 D2 96 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3727+ 2B35 32 DC 52             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3728+ 2B38 CD 8A 19             call    CHKSYN          ; Make sure ',' follows
3729+ 2B3B 2C                   defb    ','
3730+ 2B3C CD DA 28             call    GETINT          ; get value (0-255)
3731+ 2B3F 5F                   ld      E,A             ; store value into E
3732+ 2B40 3A DC 52             ld      A,(TMPBFR1)     ; recover VDP register and store into A
3733+ 2B43 F3                   di                      ; disable INTs
3734+ 2B44 CD AF 06             call    WRITE_VREG      ; write value into VDP register
3735+ 2B47 FB                   ei                      ; re-enable INTs
3736+ 2B48 C9                   ret                     ; return to caller
3737+ 2B49
3738+ 2B49              ; read the VDP status register and return it into A
3739+ 2B49 CD 81 1C     VSTAT:  call    DEINT           ; Get integer -32768 to 32767 (Note: we do NOT use it)
3740+ 2B4C F3                   di                      ; disable INTs
3741+ 2B4D CD BA 06             call    READ_VSTAT      ; read VDP register status
3742+ 2B50 FB                   ei                      ; re-enable INTs
3743+ 2B51 C3 4D 24             jp      PASSA           ; Return integer A
3744+ 2B54
3745+ 2B54              ; read from PSG register and return it into A
3746+ 2B54 CD 81 1C     SSTAT:  call    DEINT           ; get integer -32768 to 32767
3747+ 2B57 7B                   ld      A,E             ; consider LSB
3748+ 2B58 FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3749+ 2B5A D2 96 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3750+ 2B5D F3                   di                      ; disable INts
3751+ 2B5E 0E 40                ld      C,PSG_REG       ; output port to set PSG register
3752+ 2B60 ED 79                out     (C),A           ; send register to read from
3753+ 2B62 ED 78                in      A,(C)           ; read register's contents and store into A
3754+ 2B64 FB                   ei                      ; re-enable INTs
3755+ 2B65 C3 4D 24             jp      PASSA           ; return A
3756+ 2B68
3757+ 2B68              ; read the temp key buffer and return the value of the current key being pressed
3758+ 2B68              ; can wait for the number of 100thds of second before to return
3759+ 2B68 CD C7 24     INKEY:  call    IDTEST          ; Test for illegal direct
3760+ 2B6B CD 81 1C             call    DEINT           ; get number param (100thds of second to wait) into DE
3761+ 2B6E C5                   push    BC              ; store BC
3762+ 2B6F 3A BB 52             ld      A,(TMRCNT)      ; Load current value of system timer
3763+ 2B72 47                   ld      B,A             ; move it into B
3764+ 2B73 3A BB 52     CMP_A:  ld      A,(TMRCNT)      ; make a little delay of 1/100 sec...
3765+ 2B76 B8                   cp      B               ; ...to let the sniffer collect...
3766+ 2B77 20 FA                jr      NZ,CMP_A        ; ...at least 1 char before to continue
3767+ 2B79 7A                   ld      A,D             ; check the param
3768+ 2B7A B3                   or      E               ; if DE<>0 then...
3769+ 2B7B 20 05                jr      NZ,INKEY2       ; ...jump over...
3770+ 2B7D 3A 18 53             ld      A,(TMPKEYBFR)   ; ...else read the buffer and...
3771+ 2B80 18 2A                jr      ENDINK          ; ...return it
3772+ 2B82 7A           INKEY2: ld      A,D             ; check if param>1023
3773+ 2B83 FE 04                cp      $04             ; to do this we check if MSB>3
3774+ 2B85 D2 96 1C             jp      NC,FCERR        ; if MSB >=4 then error
3775+ 2B88 E5                   push    HL              ; store HL
3776+ 2B89 21 09 00             ld      HL,$0009        ; check if value
3777+ 2B8C CD 97 3F             call    CMP16           ; is < 10
3778+ 2B8F E1                   pop     HL              ; retrieve HL
3779+ 2B90 DA 96 2B             jp      C,SRTINK        ; if value >= 10 then jump over
3780+ 2B93 11 0A 00             ld      DE,$000A        ; else, use 10 (no intervals shorter than 10/100s)
3781+ 2B96 3A BB 52     SRTINK: ld      A,(TMRCNT)      ; Load the first byte of the system timer
3782+ 2B99 47                   ld      B,A             ; move it into B
3783+ 2B9A 3A 18 53     CHKINK: ld      A,(TMPKEYBFR)   ; load char code from buffer
3784+ 2B9D A7                   and     A               ; is it 0?
3785+ 2B9E 20 0C                jr      NZ,ENDINK       ; no, so we can return it
3786+ 2BA0 3A BB 52             ld      A,(TMRCNT)      ; load the first byte of the system timer
3787+ 2BA3 B8                   cp      B               ; is it the same value?
3788+ 2BA4 28 F4                jr      Z,CHKINK        ; yes, so read again
3789+ 2BA6 47                   ld      B,A             ; store new value
3790+ 2BA7 1B                   dec     DE              ; no, decrement timer
3791+ 2BA8 7A                   ld      A,D             ; check if zero reached
3792+ 2BA9 B3                   or      E               ; by ORing D and E
3793+ 2BAA 20 EE                jr      NZ,CHKINK       ; if not 0, repeat
3794+ 2BAC C1           ENDINK: pop     BC              ; restore BC
3795+ 2BAD F5                   push    AF              ; store A
3796+ 2BAE F3                   di                      ; disable INTs
3797+ 2BAF AF                   xor     A               ; clear the...
3798+ 2BB0 32 18 53             ld      (TMPKEYBFR),A   ; ...TMP KEY buffer for the next read
3799+ 2BB3 FB                   ei                      ; re-enable INTs
3800+ 2BB4 F1                   pop     AF              ; retrieve A
3801+ 2BB5 C3 4D 24     ENDINK2:jp      PASSA           ; return A as ASCII value
3802+ 2BB8
3803+ 2BB8 21 DF 30     ROUND:  ld      HL,HALF         ; Add 0.5 to FPREG
3804+ 2BBB CD B0 2E     ADDPHL: call    LOADFP          ; Load FP at (HL) to BCDE
3805+ 2BBE C3 CA 2B             jp      FPADD           ; Add BCDE to FPREG
3806+ 2BC1
3807+ 2BC1 CD B0 2E     SUBPHL: call    LOADFP          ; FPREG = -FPREG + number at HL
3808+ 2BC4 21                   defb    $21             ; Skip "pop BC" and "pop DE"
3809+ 2BC5 C1           PSUB:   pop     BC              ; Get FP number from stack
3810+ 2BC6 D1                   pop     DE
3811+ 2BC7 CD 8A 2E     SUBCDE: call    INVSGN          ; Negate FPREG
3812+ 2BCA 78           FPADD:  ld      A,B             ; Get FP exponent
3813+ 2BCB B7                   or      A               ; Is number zero?
3814+ 2BCC C8                   ret     Z               ; Yes - Nothing to add
3815+ 2BCD 3A 33 53             ld      A,(FPEXP)       ; Get FPREG exponent
3816+ 2BD0 B7                   or      A               ; Is this number zero?
3817+ 2BD1 CA A2 2E             jp      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3818+ 2BD4 90                   sub     B               ; BCDE number larger?
3819+ 2BD5 D2 E4 2B             jp      NC,NOSWAP       ; No - Don't swap them
3820+ 2BD8 2F                   cpl                     ; Two's complement
3821+ 2BD9 3C                   inc     A               ;  FP exponent
3822+ 2BDA EB                   ex      DE,HL
3823+ 2BDB CD 92 2E             call    STAKFP          ; Put FPREG on stack
3824+ 2BDE EB                   ex      DE,HL
3825+ 2BDF CD A2 2E             call    FPBCDE          ; Move BCDE to FPREG
3826+ 2BE2 C1                   pop     BC              ; Restore number from stack
3827+ 2BE3 D1                   pop     DE
3828+ 2BE4 FE 19        NOSWAP: cp      24+1            ; Second number insignificant?
3829+ 2BE6 D0                   ret     NC              ; Yes - First number is result
3830+ 2BE7 F5                   push    AF              ; Save number of bits to scale
3831+ 2BE8 CD C7 2E             call    SIGNS           ; Set MSBs & sign of result
3832+ 2BEB 67                   ld      H,A             ; Save sign of result
3833+ 2BEC F1                   pop     AF              ; Restore scaling factor
3834+ 2BED CD 8F 2C             call    SCALE           ; Scale BCDE to same exponent
3835+ 2BF0 B4                   or      H               ; Result to be positive?
3836+ 2BF1 21 30 53             ld      HL,FPREG        ; Point to FPREG
3837+ 2BF4 F2 0A 2C             jp      P,MINCDE        ; No - Subtract FPREG from CDE
3838+ 2BF7 CD 6F 2C             call    PLUCDE          ; Add FPREG to CDE
3839+ 2BFA D2 50 2C             jp      NC,RONDUP       ; No overflow - Round it up
3840+ 2BFD 23                   inc     HL              ; Point to exponent
3841+ 2BFE 34                   inc     (HL)            ; Increment it
3842+ 2BFF CA B7 16             jp      Z,OVERR         ; Number overflowed - Error
3843+ 2C02 2E 01                ld      L,$01           ; 1 bit to shift right
3844+ 2C04 CD A5 2C             call    SHRT1           ; Shift result right
3845+ 2C07 C3 50 2C             jp      RONDUP          ; Round it up
3846+ 2C0A
3847+ 2C0A AF           MINCDE: xor     A               ; Clear A and carry
3848+ 2C0B 90                   sub     B               ; Negate exponent
3849+ 2C0C 47                   ld      B,A             ; Re-save exponent
3850+ 2C0D 7E                   ld      A,(HL)          ; Get LSB of FPREG
3851+ 2C0E 9B                   sbc     A, E            ; Subtract LSB of BCDE
3852+ 2C0F 5F                   ld      E,A             ; Save LSB of BCDE
3853+ 2C10 23                   inc     HL
3854+ 2C11 7E                   ld      A,(HL)          ; Get NMSB of FPREG
3855+ 2C12 9A                   sbc     A,D             ; Subtract NMSB of BCDE
3856+ 2C13 57                   ld      D,A             ; Save NMSB of BCDE
3857+ 2C14 23                   inc     HL
3858+ 2C15 7E                   ld      A,(HL)          ; Get MSB of FPREG
3859+ 2C16 99                   sbc     A,C             ; Subtract MSB of BCDE
3860+ 2C17 4F                   ld      C,A             ; Save MSB of BCDE
3861+ 2C18 DC 7B 2C     CONPOS: call    C,COMPL         ; Overflow - Make it positive
3862+ 2C1B
3863+ 2C1B 68           BNORM:  ld      L,B             ; L = Exponent
3864+ 2C1C 63                   ld      H,E             ; H = LSB
3865+ 2C1D AF                   xor     A
3866+ 2C1E 47           BNRMLP: ld      B,A             ; Save bit count
3867+ 2C1F 79                   ld      A,C             ; Get MSB
3868+ 2C20 B7                   or      A               ; Is it zero?
3869+ 2C21 C2 3D 2C             jp      NZ,PNORM        ; No - Do it bit at a time
3870+ 2C24 4A                   ld      C,D             ; MSB = NMSB
3871+ 2C25 54                   ld      D,H             ; NMSB= LSB
3872+ 2C26 65                   ld      H,L             ; LSB = VLSB
3873+ 2C27 6F                   ld      L,A             ; VLSB= 0
3874+ 2C28 78                   ld      A,B             ; Get exponent
3875+ 2C29 D6 08                sub     $08             ; Count 8 bits
3876+ 2C2B FE E0                cp      -24-8           ; Was number zero?
3877+ 2C2D C2 1E 2C             jp      NZ,BNRMLP       ; No - Keep normalising
3878+ 2C30 AF           RESZER: xor     A               ; Result is zero
3879+ 2C31 32 33 53     SAVEXP: ld      (FPEXP),A       ; Save result as zero
3880+ 2C34 C9                   ret
3881+ 2C35
3882+ 2C35 05           NORMAL: dec     B               ; Count bits
3883+ 2C36 29                   add     HL,HL           ; Shift HL left
3884+ 2C37 7A                   ld      A,D             ; Get NMSB
3885+ 2C38 17                   rla                     ; Shift left with last bit
3886+ 2C39 57                   ld      D,A             ; Save NMSB
3887+ 2C3A 79                   ld      A,C             ; Get MSB
3888+ 2C3B 8F                   adc     A,A             ; Shift left with last bit
3889+ 2C3C 4F                   ld      C,A             ; Save MSB
3890+ 2C3D F2 35 2C     PNORM:  jp      P,NORMAL        ; Not done - Keep going
3891+ 2C40 78                   ld      A,B             ; Number of bits shifted
3892+ 2C41 5C                   ld      E,H             ; Save HL in EB
3893+ 2C42 45                   ld      B,L
3894+ 2C43 B7                   or      A               ; Any shifting done?
3895+ 2C44 CA 50 2C             jp      Z,RONDUP        ; No - Round it up
3896+ 2C47 21 33 53             ld      HL,FPEXP        ; Point to exponent
3897+ 2C4A 86                   add     A,(HL)          ; Add shifted bits
3898+ 2C4B 77                   ld      (HL),A          ; Re-save exponent
3899+ 2C4C D2 30 2C             jp      NC,RESZER       ; Underflow - Result is zero
3900+ 2C4F C8                   ret     Z               ; Result is zero
3901+ 2C50 78           RONDUP: ld      A,B             ; Get VLSB of number
3902+ 2C51 21 33 53     RONDB:  ld      HL,FPEXP        ; Point to exponent
3903+ 2C54 B7                   or      A               ; Any rounding?
3904+ 2C55 FC 62 2C             call    M,FPROND        ; Yes - Round number up
3905+ 2C58 46                   ld      B,(HL)          ; B = Exponent
3906+ 2C59 23                   inc     HL
3907+ 2C5A 7E                   ld      A,(HL)          ; Get sign of result
3908+ 2C5B E6 80                and     %10000000       ; Only bit 7 needed
3909+ 2C5D A9                   xor     C               ; Set correct sign
3910+ 2C5E 4F                   ld      C,A             ; Save correct sign in number
3911+ 2C5F C3 A2 2E             jp      FPBCDE          ; Move BCDE to FPREG
3912+ 2C62
3913+ 2C62 1C           FPROND: inc     E               ; Round LSB
3914+ 2C63 C0                   ret     NZ              ; Return if ok
3915+ 2C64 14                   inc     D               ; Round NMSB
3916+ 2C65 C0                   ret     NZ              ; Return if ok
3917+ 2C66 0C                   inc     C               ; Round MSB
3918+ 2C67 C0                   ret     NZ              ; Return if ok
3919+ 2C68 0E 80                ld      C,$80           ; Set normal value
3920+ 2C6A 34                   inc     (HL)            ; Increment exponent
3921+ 2C6B C0                   ret     NZ              ; Return if ok
3922+ 2C6C C3 B7 16             jp      OVERR           ; Overflow error
3923+ 2C6F
3924+ 2C6F 7E           PLUCDE: ld      A,(HL)          ; Get LSB of FPREG
3925+ 2C70 83                   add     A,E             ; Add LSB of BCDE
3926+ 2C71 5F                   ld      E,A             ; Save LSB of BCDE
3927+ 2C72 23                   inc     HL
3928+ 2C73 7E                   ld      A,(HL)          ; Get NMSB of FPREG
3929+ 2C74 8A                   adc     A,D             ; Add NMSB of BCDE
3930+ 2C75 57                   ld      D,A             ; Save NMSB of BCDE
3931+ 2C76 23                   inc     HL
3932+ 2C77 7E                   ld      A,(HL)          ; Get MSB of FPREG
3933+ 2C78 89                   adc     A,C             ; Add MSB of BCDE
3934+ 2C79 4F                   ld      C,A             ; Save MSB of BCDE
3935+ 2C7A C9                   ret
3936+ 2C7B
3937+ 2C7B 21 34 53     COMPL:  ld      HL,SGNRES       ; Sign of result
3938+ 2C7E 7E                   ld      A,(HL)          ; Get sign of result
3939+ 2C7F 2F                   cpl                     ; Negate it
3940+ 2C80 77                   ld      (HL),A          ; Put it back
3941+ 2C81 AF                   xor     A
3942+ 2C82 6F                   ld      L,A             ; Set L to zero
3943+ 2C83 90                   sub     B               ; Negate exponent,set carry
3944+ 2C84 47                   ld      B,A             ; Re-save exponent
3945+ 2C85 7D                   ld      A,L             ; Load zero
3946+ 2C86 9B                   sbc     A,E             ; Negate LSB
3947+ 2C87 5F                   ld      E,A             ; Re-save LSB
3948+ 2C88 7D                   ld      A,L             ; Load zero
3949+ 2C89 9A                   sbc     A,D             ; Negate NMSB
3950+ 2C8A 57                   ld      D,A             ; Re-save NMSB
3951+ 2C8B 7D                   ld      A,L             ; Load zero
3952+ 2C8C 99                   sbc     A,C             ; Negate MSB
3953+ 2C8D 4F                   ld      C,A             ; Re-save MSB
3954+ 2C8E C9                   ret
3955+ 2C8F
3956+ 2C8F 06 00        SCALE:  ld      B,$00           ; Clear underflow
3957+ 2C91 D6 08        SCALLP: sub     $08             ; 8 bits (a whole byte)?
3958+ 2C93 DA 9E 2C             jp      C,SHRITE        ; No - Shift right A bits
3959+ 2C96 43                   ld      B,E             ; <- Shift
3960+ 2C97 5A                   ld      E,D             ; <- right
3961+ 2C98 51                   ld      D,C             ; <- eight
3962+ 2C99 0E 00                ld      C,$00           ; <- bits
3963+ 2C9B C3 91 2C             jp      SCALLP          ; More bits to shift
3964+ 2C9E
3965+ 2C9E C6 09        SHRITE: add     A,8+1           ; Adjust count
3966+ 2CA0 6F                   ld      L,A             ; Save bits to shift
3967+ 2CA1 AF           SHRLP:  xor     A               ; Flag for all done
3968+ 2CA2 2D                   dec     L               ; All shifting done?
3969+ 2CA3 C8                   ret     Z               ; Yes - Return
3970+ 2CA4 79                   ld      A,C             ; Get MSB
3971+ 2CA5 1F           SHRT1:  rra                     ; Shift it right
3972+ 2CA6 4F                   ld      C,A             ; Re-save
3973+ 2CA7 7A                   ld      A,D             ; Get NMSB
3974+ 2CA8 1F                   rra                     ; Shift right with last bit
3975+ 2CA9 57                   ld      D,A             ; Re-save it
3976+ 2CAA 7B                   ld      A,E             ; Get LSB
3977+ 2CAB 1F                   rra                     ; Shift right with last bit
3978+ 2CAC 5F                   ld      E,A             ; Re-save it
3979+ 2CAD 78                   ld      A,B             ; Get underflow
3980+ 2CAE 1F                   rra                     ; Shift right with last bit
3981+ 2CAF 47                   ld      B,A             ; Re-save underflow
3982+ 2CB0 C3 A1 2C             jp      SHRLP           ; More bits to do
3983+ 2CB3
3984+ 2CB3 00 00 00 81  UNITY:  defb    $00,$00,$00,$81 ; 1.00000
3985+ 2CB7
3986+ 2CB7 03           LOGTAB: defb    $03             ; Table used by LOG
3987+ 2CB8 AA 56 19 80          defb    $AA,$56,$19,$80 ; 0.59898
3988+ 2CBC F1 22 76 80          defb    $F1,$22,$76,$80 ; 0.96147
3989+ 2CC0 45 AA 38 82          defb    $45,$AA,$38,$82 ; 2.88539
3990+ 2CC4
3991+ 2CC4 CD 61 2E     LOG:    call    TSTSGN          ; Test sign of value
3992+ 2CC7 B7                   or      A
3993+ 2CC8 EA 96 1C             jp      PE,FCERR        ; ?FC Error if <= zero
3994+ 2CCB 21 33 53             ld      HL,FPEXP        ; Point to exponent
3995+ 2CCE 7E                   ld      A,(HL)          ; Get exponent
3996+ 2CCF 01 35 80             ld      BC,$8035        ; BCDE = SQR(1/2)
3997+ 2CD2 11 F3 04             ld      DE,$04F3
3998+ 2CD5 90                   sub     B               ; Scale value to be < 1
3999+ 2CD6 F5                   push    AF              ; Save scale factor
4000+ 2CD7 70                   ld      (HL),B          ; Save new exponent
4001+ 2CD8 D5                   push    DE              ; Save SQR(1/2)
4002+ 2CD9 C5                   push    BC
4003+ 2CDA CD CA 2B             call    FPADD           ; Add SQR(1/2) to value
4004+ 2CDD C1                   pop     BC              ; Restore SQR(1/2)
4005+ 2CDE D1                   pop     DE
4006+ 2CDF 04                   inc     B               ; Make it SQR(2)
4007+ 2CE0 CD B7 2D             call    DVBCDE          ; Divide by SQR(2)
4008+ 2CE3 21 B3 2C             ld      HL,UNITY        ; Point to 1.
4009+ 2CE6 CD C1 2B             call    SUBPHL          ; Subtract FPREG from 1
4010+ 2CE9 21 B7 2C             ld      HL,LOGTAB       ; Coefficient table
4011+ 2CEC CD A9 31             call    SUMSER          ; Evaluate sum of series
4012+ 2CEF 01 80 80             ld      BC,$8080        ; BCDE = -0.5
4013+ 2CF2 11 00 00             ld      DE,$0000
4014+ 2CF5 CD CA 2B             call    FPADD           ; Subtract 0.5 from FPREG
4015+ 2CF8 F1                   pop     AF              ; Restore scale factor
4016+ 2CF9 CD DC 2F             call    RSCALE          ; Re-scale number
4017+ 2CFC 01 31 80     MULLN2: ld      BC,$8031        ; BCDE = Ln(2)
4018+ 2CFF 11 18 72             ld      DE,$7218
4019+ 2D02 21                   defb    $21             ; Skip "pop BC" and "pop DE"
4020+ 2D03
4021+ 2D03 C1           MULT:   pop     BC              ; Get number from stack
4022+ 2D04 D1                   pop     DE
4023+ 2D05 CD 61 2E     FPMULT: call    TSTSGN          ; Test sign of FPREG
4024+ 2D08 C8                   ret     Z               ; Return zero if zero
4025+ 2D09 2E 00                ld      L,$00           ; Flag add exponents
4026+ 2D0B CD 1F 2E             call    ADDEXP          ; Add exponents
4027+ 2D0E 79                   ld      A,C             ; Get MSB of multiplier
4028+ 2D0F 32 42 53             ld      (MULVAL),A      ; Save MSB of multiplier
4029+ 2D12 EB                   ex      DE,HL
4030+ 2D13 22 43 53             ld      (MULVAL+1),HL   ; Save rest of multiplier
4031+ 2D16 01 00 00             ld      BC,$0000        ; Partial product (BCDE) = zero
4032+ 2D19 50                   ld      D,B
4033+ 2D1A 58                   ld      E,B
4034+ 2D1B 21 1B 2C             ld      HL,BNORM        ; Address of normalise
4035+ 2D1E E5                   push    HL              ; Save for return
4036+ 2D1F 21 27 2D             ld      HL,MULT8        ; Address of 8 bit multiply
4037+ 2D22 E5                   push    HL              ; Save for NMSB,MSB
4038+ 2D23 E5                   push    HL              ;
4039+ 2D24 21 30 53             ld      HL,FPREG        ; Point to number
4040+ 2D27 7E           MULT8:  ld      A,(HL)          ; Get LSB of number
4041+ 2D28 23                   inc     HL              ; Point to NMSB
4042+ 2D29 B7                   or      A               ; Test LSB
4043+ 2D2A CA 53 2D             jp      Z,BYTSFT        ; Zero - shift to next byte
4044+ 2D2D E5                   push    HL              ; Save address of number
4045+ 2D2E 2E 08                ld      L,$08           ; 8 bits to multiply by
4046+ 2D30 1F           MUL8LP: rra                     ; Shift LSB right
4047+ 2D31 67                   ld      H,A             ; Save LSB
4048+ 2D32 79                   ld      A,C             ; Get MSB
4049+ 2D33 D2 41 2D             jp      NC,NOMADD       ; Bit was zero - Don't add
4050+ 2D36 E5                   push    HL              ; Save LSB and count
4051+ 2D37 2A 43 53             ld      HL,(MULVAL+1)   ; Get LSB and NMSB
4052+ 2D3A 19                   add     HL,DE           ; Add NMSB and LSB
4053+ 2D3B EB                   ex      DE,HL           ; Leave sum in DE
4054+ 2D3C E1                   pop     HL              ; Restore MSB and count
4055+ 2D3D 3A 42 53             ld      A,(MULVAL)      ; Get MSB of multiplier
4056+ 2D40 89                   adc     A,C             ; Add MSB
4057+ 2D41 1F           NOMADD: rra                     ; Shift MSB right
4058+ 2D42 4F                   ld      C,A             ; Re-save MSB
4059+ 2D43 7A                   ld      A,D             ; Get NMSB
4060+ 2D44 1F                   rra                     ; Shift NMSB right
4061+ 2D45 57                   ld      D,A             ; Re-save NMSB
4062+ 2D46 7B                   ld      A,E             ; Get LSB
4063+ 2D47 1F                   rra                     ; Shift LSB right
4064+ 2D48 5F                   ld      E,A             ; Re-save LSB
4065+ 2D49 78                   ld      A,B             ; Get VLSB
4066+ 2D4A 1F                   rra                     ; Shift VLSB right
4067+ 2D4B 47                   ld      B,A             ; Re-save VLSB
4068+ 2D4C 2D                   dec     L               ; Count bits multiplied
4069+ 2D4D 7C                   ld      A,H             ; Get LSB of multiplier
4070+ 2D4E C2 30 2D             jp      NZ,MUL8LP       ; More - Do it
4071+ 2D51 E1           POPHRT: pop     HL              ; Restore address of number
4072+ 2D52 C9                   ret
4073+ 2D53
4074+ 2D53 43           BYTSFT: ld      B,E             ; Shift partial product left
4075+ 2D54 5A                   ld      E,D
4076+ 2D55 51                   ld      D,C
4077+ 2D56 4F                   ld      C,A
4078+ 2D57 C9                   ret
4079+ 2D58
4080+ 2D58
4081+ 2D58              ; WORKING ââ
4082+ 2D58 C1           DINT:   pop     BC              ; Get number from stack
4083+ 2D59 D1                   pop     DE
4084+ 2D5A CD B7 2D             call    DVBCDE          ; get BCDE/FPREG and store result into FPREG
4085+ 2D5D C3 34 2F             jp      INT             ; return INT(FPREG)
4086+ 2D60
4087+ 2D60
4088+ 2D60              ; A MODULO B - return remainder of the integer division A/B where:
4089+ 2D60              ; A is in stack; B is in FPREG
4090+ 2D60              ; math is:
4091+ 2D60              ; A=INT(A); B=INT(B); R=A-(B*INT(A/B))
4092+ 2D60 CD 34 2F     MOD:    call    INT             ; B=INT(B)
4093+ 2D63 CD AD 2E             call    BCDEFP          ; copy B (from FPREG) into BCDE
4094+ 2D66 ED 53 E0 52          ld      (TMPBFR3),DE    ; store B into...
4095+ 2D6A ED 43 E2 52          ld      (TMPBFR4),BC    ; ...a temp buffer
4096+ 2D6E C1                   pop     BC              ; recover A...
4097+ 2D6F D1                   pop     DE              ; ...from stack
4098+ 2D70 CD A2 2E             call    FPBCDE          ; store A into FPREG
4099+ 2D73 CD 34 2F             call    INT             ; get integer part: A=INT(A)
4100+ 2D76 CD AD 2E             call    BCDEFP          ; copy A (from FPREG) into BCDE
4101+ 2D79 ED 53 DC 52          ld      (TMPBFR1),DE    ; store A into...
4102+ 2D7D ED 43 DE 52          ld      (TMPBFR2),BC    ; ...a temp buffer
4103+ 2D81                                              ; begin calculation
4104+ 2D81 2A E0 52             ld      HL,(TMPBFR3)    ; move B...
4105+ 2D84 22 30 53             ld      (FPREG),HL      ; ...from...
4106+ 2D87 2A E2 52             ld      HL,(TMPBFR4)    ; ...temp buffer...
4107+ 2D8A 22 32 53             ld      (FPREG+2),HL    ; ...into FPREG
4108+ 2D8D CD B7 2D             call    DVBCDE          ; compute A/B and store into FPREG
4109+ 2D90 CD 34 2F             call    INT             ; get integer part of result: now FPREG = INT(A/B)
4110+ 2D93 ED 5B E0 52          ld      DE,(TMPBFR3)    ; load B...
4111+ 2D97 ED 4B E2 52          ld      BC,(TMPBFR4)    ; ...into BCDE
4112+ 2D9B CD 05 2D             call    FPMULT          ; get B*INT(A/B) and store into FPREG
4113+ 2D9E ED 5B DC 52          ld      DE,(TMPBFR1)    ; retrieve A from...
4114+ 2DA2 ED 4B DE 52          ld      BC,(TMPBFR2)    ; ...temp buffer
4115+ 2DA6 C3 C7 2B             jp      SUBCDE          ; return result of A-(B*INT(A/B))
4116+ 2DA9
4117+ 2DA9
4118+ 2DA9 CD 92 2E     DIV10:  call    STAKFP          ; Save FPREG on stack
4119+ 2DAC 01 20 84             ld      BC,$8420        ; BCDE = 10.
4120+ 2DAF 11 00 00             ld      DE,$0000
4121+ 2DB2 CD A2 2E             call    FPBCDE          ; Move 10 to FPREG
4122+ 2DB5
4123+ 2DB5 C1           DIV:    pop     BC              ; Get number from stack
4124+ 2DB6 D1                   pop     DE
4125+ 2DB7 CD 61 2E     DVBCDE: call    TSTSGN          ; Test sign of FPREG
4126+ 2DBA CA AB 16             jp      Z,DZERR         ; Error if division by zero
4127+ 2DBD 2E FF                ld      L,-1            ; Flag subtract exponents
4128+ 2DBF CD 1F 2E             call    ADDEXP          ; Subtract exponents
4129+ 2DC2 34                   inc     (HL)            ; Add 2 to exponent to adjust
4130+ 2DC3 34                   inc     (HL)
4131+ 2DC4 2B                   dec     HL              ; Point to MSB
4132+ 2DC5 7E                   ld      A,(HL)          ; Get MSB of dividend
4133+ 2DC6 32 71 51             ld      (DIV3),A        ; Save for subtraction
4134+ 2DC9 2B                   dec     HL
4135+ 2DCA 7E                   ld      A,(HL)          ; Get NMSB of dividend
4136+ 2DCB 32 6D 51             ld      (DIV2),A        ; Save for subtraction
4137+ 2DCE 2B                   dec     HL
4138+ 2DCF 7E                   ld      A,(HL)          ; Get MSB of dividend
4139+ 2DD0 32 69 51             ld      (DIV1),A        ; Save for subtraction
4140+ 2DD3 41                   ld      B,C             ; Get MSB
4141+ 2DD4 EB                   ex      DE,HL           ; NMSB,LSB to HL
4142+ 2DD5 AF                   xor     A
4143+ 2DD6 4F                   ld      C,A             ; Clear MSB of quotient
4144+ 2DD7 57                   ld      D,A             ; Clear NMSB of quotient
4145+ 2DD8 5F                   ld      E,A             ; Clear LSB of quotient
4146+ 2DD9 32 74 51             ld      (DIV4),A        ; Clear overflow count
4147+ 2DDC E5           DIVLP:  push    HL              ; Save divisor
4148+ 2DDD C5                   push    BC
4149+ 2DDE 7D                   ld      A,L             ; Get LSB of number
4150+ 2DDF CD 68 51             call    DIVSUP          ; Subt' divisor from dividend
4151+ 2DE2 DE 00                sbc     A,$00           ; Count for overflows
4152+ 2DE4 3F                   ccf
4153+ 2DE5 D2 EF 2D             jp      NC,RESDIV       ; Restore divisor if borrow
4154+ 2DE8 32 74 51             ld      (DIV4),A        ; Re-save overflow count
4155+ 2DEB F1                   pop     AF              ; Scrap divisor
4156+ 2DEC F1                   pop     AF
4157+ 2DED 37                   scf                     ; Set carry to
4158+ 2DEE D2                   defb    $D2             ; Skip "pop BC" and "pop HL"
4159+ 2DEF
4160+ 2DEF C1           RESDIV: pop     BC              ; Restore divisor
4161+ 2DF0 E1                   pop     HL
4162+ 2DF1 79                   ld      A,C             ; Get MSB of quotient
4163+ 2DF2 3C                   inc     A
4164+ 2DF3 3D                   dec     A
4165+ 2DF4 1F                   rra                     ; Bit 0 to bit 7
4166+ 2DF5 FA 51 2C             jp      M,RONDB         ; Done - Normalise result
4167+ 2DF8 17                   rla                     ; Restore carry
4168+ 2DF9 7B                   ld      A,E             ; Get LSB of quotient
4169+ 2DFA 17                   rla                     ; Double it
4170+ 2DFB 5F                   ld      E,A             ; Put it back
4171+ 2DFC 7A                   ld      A,D             ; Get NMSB of quotient
4172+ 2DFD 17                   rla                     ; Double it
4173+ 2DFE 57                   ld      D,A             ; Put it back
4174+ 2DFF 79                   ld      A,C             ; Get MSB of quotient
4175+ 2E00 17                   rla                     ; Double it
4176+ 2E01 4F                   ld      C,A             ; Put it back
4177+ 2E02 29                   add     HL,HL           ; Double NMSB,LSB of divisor
4178+ 2E03 78                   ld      A,B             ; Get MSB of divisor
4179+ 2E04 17                   rla                     ; Double it
4180+ 2E05 47                   ld      B,A             ; Put it back
4181+ 2E06 3A 74 51             ld      A,(DIV4)        ; Get VLSB of quotient
4182+ 2E09 17                   rla                     ; Double it
4183+ 2E0A 32 74 51             ld      (DIV4),A        ; Put it back
4184+ 2E0D 79                   ld      A,C             ; Get MSB of quotient
4185+ 2E0E B2                   or      D               ; Merge NMSB
4186+ 2E0F B3                   or      E               ; Merge LSB
4187+ 2E10 C2 DC 2D             jp      NZ,DIVLP        ; Not done - Keep dividing
4188+ 2E13 E5                   push    HL              ; Save divisor
4189+ 2E14 21 33 53             ld      HL,FPEXP        ; Point to exponent
4190+ 2E17 35                   dec     (HL)            ; Divide by 2
4191+ 2E18 E1                   pop     HL              ; Restore divisor
4192+ 2E19 C2 DC 2D             jp      NZ,DIVLP        ; Ok - Keep going
4193+ 2E1C C3 B7 16             jp      OVERR           ; Overflow error
4194+ 2E1F
4195+ 2E1F
4196+ 2E1F 78           ADDEXP: ld      A,B             ; Get exponent of dividend
4197+ 2E20 B7                   or      A               ; Test it
4198+ 2E21 CA 43 2E             jp      Z,OVTST3        ; Zero - Result zero
4199+ 2E24 7D                   ld      A,L             ; Get add/subtract flag
4200+ 2E25 21 33 53             ld      HL,FPEXP        ; Point to exponent
4201+ 2E28 AE                   xor     (HL)            ; Add or subtract it
4202+ 2E29 80                   add     A,B             ; Add the other exponent
4203+ 2E2A 47                   ld      B,A             ; Save new exponent
4204+ 2E2B 1F                   rra                     ; Test exponent for overflow
4205+ 2E2C A8                   xor     B
4206+ 2E2D 78                   ld      A,B             ; Get exponent
4207+ 2E2E F2 42 2E             jp      P,OVTST2        ; Positive - Test for overflow
4208+ 2E31 C6 80                add     A,$80           ; Add excess 128
4209+ 2E33 77                   ld      (HL),A          ; Save new exponent
4210+ 2E34 CA 51 2D             jp      Z,POPHRT        ; Zero - Result zero
4211+ 2E37 CD C7 2E             call    SIGNS           ; Set MSBs and sign of result
4212+ 2E3A 77                   ld      (HL),A          ; Save new exponent
4213+ 2E3B 2B                   dec     HL              ; Point to MSB
4214+ 2E3C C9                   ret
4215+ 2E3D
4216+ 2E3D CD 61 2E     OVTST1: call    TSTSGN          ; Test sign of FPREG
4217+ 2E40 2F                   cpl                     ; Invert sign
4218+ 2E41 E1                   pop     HL              ; Clean up stack
4219+ 2E42 B7           OVTST2: or      A               ; Test if new exponent zero
4220+ 2E43 E1           OVTST3: pop     HL              ; Clear off return address
4221+ 2E44 F2 30 2C             jp      P,RESZER        ; Result zero
4222+ 2E47 C3 B7 16             jp      OVERR           ; Overflow error
4223+ 2E4A
4224+ 2E4A CD AD 2E     MLSP10: call    BCDEFP          ; Move FPREG to BCDE
4225+ 2E4D 78                   ld      A,B             ; Get exponent
4226+ 2E4E B7                   or      A               ; Is it zero?
4227+ 2E4F C8                   ret     Z               ; Yes - Result is zero
4228+ 2E50 C6 02                add     A,$02           ; Multiply by 4
4229+ 2E52 DA B7 16             jp      C,OVERR         ; Overflow - ?OV Error
4230+ 2E55 47                   ld      B,A             ; Re-save exponent
4231+ 2E56 CD CA 2B             call    FPADD           ; Add BCDE to FPREG (Times 5)
4232+ 2E59 21 33 53             ld      HL,FPEXP        ; Point to exponent
4233+ 2E5C 34                   inc     (HL)            ; Double number (Times 10)
4234+ 2E5D C0                   ret     NZ              ; Ok - Return
4235+ 2E5E C3 B7 16             jp      OVERR           ; Overflow error
4236+ 2E61
4237+ 2E61 3A 33 53     TSTSGN: ld      A,(FPEXP)       ; Get sign of FPREG
4238+ 2E64 B7                   or      A
4239+ 2E65 C8                   ret     Z               ; RETurn if number is zero
4240+ 2E66 3A 32 53             ld      A,(FPREG+2)     ; Get MSB of FPREG
4241+ 2E69 FE                   defb    0FEH            ; Test sign
4242+ 2E6A 2F           RETREL: cpl                     ; Invert sign
4243+ 2E6B 17                   rla                     ; Sign bit to carry
4244+ 2E6C 9F           FLGDIF: sbc     A,A             ; Carry to all bits of A
4245+ 2E6D C0                   ret     NZ              ; Return -1 if negative
4246+ 2E6E 3C                   inc     A               ; Bump to +1
4247+ 2E6F C9                   ret                     ; Positive - Return +1
4248+ 2E70
4249+ 2E70 CD 61 2E     SGN:    call    TSTSGN          ; Test sign of FPREG
4250+ 2E73 06 88        FLGREL: ld      B,$80+8         ; 8 bit integer in exponent
4251+ 2E75 11 00 00             ld      DE,0            ; Zero NMSB and LSB
4252+ 2E78 21 33 53     RETINT: ld      HL,FPEXP        ; Point to exponent
4253+ 2E7B 4F                   ld      C,A             ; CDE = MSB,NMSB and LSB
4254+ 2E7C 70                   ld      (HL),B          ; Save exponent
4255+ 2E7D 06 00                ld      B,0             ; CDE = integer to normalise
4256+ 2E7F 23                   inc     HL              ; Point to sign of result
4257+ 2E80 36 80                ld      (HL),$80        ; Set sign of result
4258+ 2E82 17                   rla                     ; Carry = sign of integer
4259+ 2E83 C3 18 2C             jp      CONPOS          ; Set sign of result
4260+ 2E86
4261+ 2E86 CD 61 2E     ABS_:   call    TSTSGN          ; Test sign of FPREG
4262+ 2E89 F0                   ret     P               ; Return if positive
4263+ 2E8A 21 32 53     INVSGN: ld      HL,FPREG+2      ; Point to MSB
4264+ 2E8D 7E                   ld      A,(HL)          ; Get sign of mantissa
4265+ 2E8E EE 80                xor     $80             ; Invert sign of mantissa
4266+ 2E90 77                   ld      (HL),A          ; Re-save sign of mantissa
4267+ 2E91 C9                   ret
4268+ 2E92
4269+ 2E92 EB           STAKFP: ex      DE,HL           ; Save code string address
4270+ 2E93 2A 30 53             ld      HL,(FPREG)      ; LSB,NLSB of FPREG
4271+ 2E96 E3                   ex      (SP),HL         ; Stack them,get return
4272+ 2E97 E5                   push    HL              ; Re-save return
4273+ 2E98 2A 32 53             ld      HL,(FPREG+2)    ; MSB and exponent of FPREG
4274+ 2E9B E3                   ex      (SP),HL         ; Stack them,get return
4275+ 2E9C E5                   push    HL              ; Re-save return
4276+ 2E9D EB                   ex      DE,HL           ; Restore code string address
4277+ 2E9E C9                   ret
4278+ 2E9F
4279+ 2E9F              ; store F.P. number from BCDE into FPREG
4280+ 2E9F CD B0 2E     PHLTFP: call    LOADFP          ; Number at HL to BCDE
4281+ 2EA2 EB           FPBCDE: ex      DE,HL           ; Save code string address
4282+ 2EA3 22 30 53             ld      (FPREG),HL      ; Save LSB,NLSB of number
4283+ 2EA6 60                   ld      H,B             ; Exponent of number
4284+ 2EA7 69                   ld      L,C             ; MSB of number
4285+ 2EA8 22 32 53             ld      (FPREG+2),HL    ; Save MSB and exponent
4286+ 2EAB EB                   ex      DE,HL           ; Restore code string address
4287+ 2EAC C9                   ret
4288+ 2EAD
4289+ 2EAD              ; load F.P. number from FPREG into BCDE
4290+ 2EAD 21 30 53     BCDEFP: ld      HL,FPREG        ; Point to FPREG
4291+ 2EB0 5E           LOADFP: ld      E,(HL)          ; Get LSB of number
4292+ 2EB1 23                   inc     HL
4293+ 2EB2 56                   ld      D,(HL)          ; Get NMSB of number
4294+ 2EB3 23                   inc     HL
4295+ 2EB4 4E                   ld      C,(HL)          ; Get MSB of number
4296+ 2EB5 23                   inc     HL
4297+ 2EB6 46                   ld      B,(HL)          ; Get exponent of number
4298+ 2EB7 23           INCHL:  inc     HL              ; Used for conditional "inc HL"
4299+ 2EB8 C9                   ret
4300+ 2EB9
4301+ 2EB9 11 30 53     FPTHL:  ld      DE,FPREG        ; Point to FPREG
4302+ 2EBC 06 04        DETHL4: ld      B,$04           ; 4 bytes to move
4303+ 2EBE 1A           DETHLB: ld      A,(DE)          ; Get source
4304+ 2EBF 77                   ld      (HL),A          ; Save destination
4305+ 2EC0 13                   inc     DE              ; Next source
4306+ 2EC1 23                   inc     HL              ; Next destination
4307+ 2EC2 05                   dec     B               ; Count bytes
4308+ 2EC3 C2 BE 2E             jp      NZ,DETHLB       ; Loop if more
4309+ 2EC6 C9                   ret
4310+ 2EC7
4311+ 2EC7 21 32 53     SIGNS:  ld      HL,FPREG+2      ; Point to MSB of FPREG
4312+ 2ECA 7E                   ld      A,(HL)          ; Get MSB
4313+ 2ECB 07                   rlca                    ; Old sign to carry
4314+ 2ECC 37                   scf                     ; Set MSBit
4315+ 2ECD 1F                   rra                     ; Set MSBit of MSB
4316+ 2ECE 77                   ld      (HL),A          ; Save new MSB
4317+ 2ECF 3F                   ccf                     ; Complement sign
4318+ 2ED0 1F                   rra                     ; Old sign to carry
4319+ 2ED1 23                   inc     HL
4320+ 2ED2 23                   inc     HL
4321+ 2ED3 77                   ld      (HL),A          ; Set sign of result
4322+ 2ED4 79                   ld      A,C             ; Get MSB
4323+ 2ED5 07                   rlca                    ; Old sign to carry
4324+ 2ED6 37                   scf                     ; Set MSBit
4325+ 2ED7 1F                   rra                     ; Set MSBit of MSB
4326+ 2ED8 4F                   ld      C,A             ; Save MSB
4327+ 2ED9 1F                   rra
4328+ 2EDA AE                   xor     (HL)            ; New sign of result
4329+ 2EDB C9                   ret
4330+ 2EDC
4331+ 2EDC 78           CMPNUM: ld      A,B             ; Get exponent of number
4332+ 2EDD B7                   or      A
4333+ 2EDE CA 61 2E             jp      Z,TSTSGN        ; Zero - Test sign of FPREG
4334+ 2EE1 21 6A 2E             ld      HL,RETREL       ; Return relation routine
4335+ 2EE4 E5                   push    HL              ; Save for return
4336+ 2EE5 CD 61 2E             call    TSTSGN          ; Test sign of FPREG
4337+ 2EE8 79                   ld      A,C             ; Get MSB of number
4338+ 2EE9 C8                   ret     Z               ; FPREG zero - Number's MSB
4339+ 2EEA 21 32 53             ld      HL,FPREG+2      ; MSB of FPREG
4340+ 2EED AE                   xor     (HL)            ; Combine signs
4341+ 2EEE 79                   ld      A,C             ; Get MSB of number
4342+ 2EEF F8                   ret     M               ; Exit if signs different
4343+ 2EF0 CD F6 2E             call    CMPFP           ; Compare FP numbers
4344+ 2EF3 1F                   rra                     ; Get carry to sign
4345+ 2EF4 A9                   xor     C               ; Combine with MSB of number
4346+ 2EF5 C9                   ret
4347+ 2EF6
4348+ 2EF6 23           CMPFP:  inc     HL              ; Point to exponent
4349+ 2EF7 78                   ld      A,B             ; Get exponent
4350+ 2EF8 BE                   cp      (HL)            ; Compare exponents
4351+ 2EF9 C0                   ret     NZ              ; Different
4352+ 2EFA 2B                   dec     HL              ; Point to MBS
4353+ 2EFB 79                   ld      A,C             ; Get MSB
4354+ 2EFC BE                   cp      (HL)            ; Compare MSBs
4355+ 2EFD C0                   ret     NZ              ; Different
4356+ 2EFE 2B                   dec     HL              ; Point to NMSB
4357+ 2EFF 7A                   ld      A,D             ; Get NMSB
4358+ 2F00 BE                   cp      (HL)            ; Compare NMSBs
4359+ 2F01 C0                   ret     NZ              ; Different
4360+ 2F02 2B                   dec     HL              ; Point to LSB
4361+ 2F03 7B                   ld      A,E             ; Get LSB
4362+ 2F04 96                   sub     (HL)            ; Compare LSBs
4363+ 2F05 C0                   ret     NZ              ; Different
4364+ 2F06 E1                   pop     HL              ; Drop RETurn
4365+ 2F07 E1                   pop     HL              ; Drop another RETurn
4366+ 2F08 C9                   ret
4367+ 2F09
4368+ 2F09 47           FPINT:  ld      B,A             ; <- Move
4369+ 2F0A 4F                   ld      C,A             ; <- exponent
4370+ 2F0B 57                   ld      D,A             ; <- to all
4371+ 2F0C 5F                   ld      E,A             ; <- bits
4372+ 2F0D B7                   or      A               ; Test exponent
4373+ 2F0E C8                   ret     Z               ; Zero - Return zero
4374+ 2F0F E5                   push    HL              ; Save pointer to number
4375+ 2F10 CD AD 2E             call    BCDEFP          ; Move FPREG to BCDE
4376+ 2F13 CD C7 2E             call    SIGNS           ; Set MSBs & sign of result
4377+ 2F16 AE                   xor     (HL)            ; Combine with sign of FPREG
4378+ 2F17 67                   ld      H,A             ; Save combined signs
4379+ 2F18 FC 2D 2F             call    M,DCBCDE        ; Negative - Decrement BCDE
4380+ 2F1B 3E 98                ld      A,$80+24        ; 24 bits
4381+ 2F1D 90                   sub     B               ; Bits to shift
4382+ 2F1E CD 8F 2C             call    SCALE           ; Shift BCDE
4383+ 2F21 7C                   ld      A,H             ; Get combined sign
4384+ 2F22 17                   rla                     ; Sign to carry
4385+ 2F23 DC 62 2C             call    C,FPROND        ; Negative - Round number up
4386+ 2F26 06 00                ld      B,$00           ; Zero exponent
4387+ 2F28 DC 7B 2C             call    C,COMPL         ; If negative make positive
4388+ 2F2B E1                   pop     HL              ; Restore pointer to number
4389+ 2F2C C9                   ret
4390+ 2F2D
4391+ 2F2D 1B           DCBCDE: dec     DE              ; Decrement BCDE
4392+ 2F2E 7A                   ld      A,D             ; Test LSBs
4393+ 2F2F A3                   and     E
4394+ 2F30 3C                   inc     A
4395+ 2F31 C0                   ret     NZ              ; Exit if LSBs not FFFF
4396+ 2F32 0B                   dec     BC              ; Decrement MSBs
4397+ 2F33 C9                   ret
4398+ 2F34
4399+ 2F34 21 33 53     INT:    ld      HL,FPEXP        ; Point to exponent
4400+ 2F37 7E                   ld      A,(HL)          ; Get exponent
4401+ 2F38 FE 98                cp      $80+24          ; Integer accuracy only?
4402+ 2F3A 3A 30 53             ld      A,(FPREG)       ; Get LSB
4403+ 2F3D D0                   ret     NC              ; Yes - Already integer
4404+ 2F3E 7E                   ld      A,(HL)          ; Get exponent
4405+ 2F3F CD 09 2F             call    FPINT           ; F.P to integer
4406+ 2F42 36 98                ld      (HL),$80+24     ; Save 24 bit integer
4407+ 2F44 7B                   ld      A,E             ; Get LSB of number
4408+ 2F45 F5                   push    AF              ; Save LSB
4409+ 2F46 79                   ld      A,C             ; Get MSB of number
4410+ 2F47 17                   rla                     ; Sign to carry
4411+ 2F48 CD 18 2C             call    CONPOS          ; Set sign of result
4412+ 2F4B F1                   pop     AF              ; Restore LSB of number
4413+ 2F4C C9                   ret
4414+ 2F4D
4415+ 2F4D 21 00 00     MLDEBC: ld      HL,$0000        ; Clear partial product
4416+ 2F50 78                   ld      A,B             ; Test multiplier
4417+ 2F51 B1                   or      C
4418+ 2F52 C8                   ret     Z               ; Return zero if zero
4419+ 2F53 3E 10                ld      A,$10           ; 16 bits
4420+ 2F55 29           MLDBLP: add     HL,HL           ; Shift P.P left
4421+ 2F56 DA 7B 23             jp      C,BSERR         ; ?BS Error if overflow
4422+ 2F59 EB                   ex      DE,HL
4423+ 2F5A 29                   add     HL,HL           ; Shift multiplier left
4424+ 2F5B EB                   ex      DE,HL
4425+ 2F5C D2 63 2F             jp      NC,NOMLAD       ; Bit was zero - No add
4426+ 2F5F 09                   add     HL,BC           ; Add multiplicand
4427+ 2F60 DA 7B 23             jp      C,BSERR         ; ?BS Error if overflow
4428+ 2F63 3D           NOMLAD: dec     A               ; Count bits
4429+ 2F64 C2 55 2F             jp      NZ,MLDBLP       ; More
4430+ 2F67 C9                   ret
4431+ 2F68
4432+ 2F68 FE 2D        ASCTFP: cp      '-'             ; Negative?
4433+ 2F6A F5                   push    AF              ; Save it and flags
4434+ 2F6B CA 74 2F             jp      Z,CNVNUM        ; Yes - Convert number
4435+ 2F6E FE 2B                cp      '+'             ; Positive?
4436+ 2F70 CA 74 2F             jp      Z,CNVNUM        ; Yes - Convert number
4437+ 2F73 2B                   dec     HL              ; dec 'cos GETCHR INCs
4438+ 2F74 CD 30 2C     CNVNUM: call    RESZER          ; Set result to zero
4439+ 2F77 47                   ld      B,A             ; Digits after point counter
4440+ 2F78 57                   ld      D,A             ; Sign of exponent
4441+ 2F79 5F                   ld      E,A             ; Exponent of ten
4442+ 2F7A 2F                   cpl
4443+ 2F7B 4F                   ld      C,A             ; Before or after point flag
4444+ 2F7C CD CB 1B     MANLP:  call    GETCHR          ; Get next character
4445+ 2F7F DA C5 2F             jp      C,ADDIG         ; Digit - Add to number
4446+ 2F82 FE 2E                cp      '.'
4447+ 2F84 CA A0 2F             jp      Z,DPOINT        ; '.' - Flag point
4448+ 2F87 FE 45                cp      'E'
4449+ 2F89 C2 A4 2F             jp      NZ,CONEXP       ; Not 'E' - Scale number
4450+ 2F8C CD CB 1B             call    GETCHR          ; Get next character
4451+ 2F8F CD 97 21             call    SGNEXP          ; Get sign of exponent
4452+ 2F92 CD CB 1B     EXPLP:  call    GETCHR          ; Get next character
4453+ 2F95 DA E7 2F             jp      C,EDIGIT        ; Digit - Add to exponent
4454+ 2F98 14                   inc     D               ; Is sign negative?
4455+ 2F99 C2 A4 2F             jp      NZ,CONEXP       ; No - Scale number
4456+ 2F9C AF                   xor     A
4457+ 2F9D 93                   sub     E               ; Negate exponent
4458+ 2F9E 5F                   ld      E,A             ; And re-save it
4459+ 2F9F 0C                   inc     C               ; Flag end of number
4460+ 2FA0 0C           DPOINT: inc     C               ; Flag point passed
4461+ 2FA1 CA 7C 2F             jp      Z,MANLP         ; Zero - Get another digit
4462+ 2FA4 E5           CONEXP: push    HL              ; Save code string address
4463+ 2FA5 7B                   ld      A,E             ; Get exponent
4464+ 2FA6 90                   sub     B               ; Subtract digits after point
4465+ 2FA7 F4 BD 2F     SCALMI: call    P,SCALPL        ; Positive - Multiply number
4466+ 2FAA F2 B3 2F             jp      P,ENDCON        ; Positive - All done
4467+ 2FAD F5                   push    AF              ; Save number of times to /10
4468+ 2FAE CD A9 2D             call    DIV10           ; Divide by 10
4469+ 2FB1 F1                   pop     AF              ; Restore count
4470+ 2FB2 3C                   inc     A               ; Count divides
4471+ 2FB3
4472+ 2FB3 C2 A7 2F     ENDCON: jp      NZ,SCALMI       ; More to do
4473+ 2FB6 D1                   pop     DE              ; Restore code string address
4474+ 2FB7 F1                   pop     AF              ; Restore sign of number
4475+ 2FB8 CC 8A 2E             call    Z,INVSGN        ; Negative - Negate number
4476+ 2FBB EB                   ex      DE,HL           ; Code string address to HL
4477+ 2FBC C9                   ret
4478+ 2FBD
4479+ 2FBD C8           SCALPL: ret     Z               ; Exit if no scaling needed
4480+ 2FBE F5           MULTEN: push    AF              ; Save count
4481+ 2FBF CD 4A 2E             call    MLSP10          ; Multiply number by 10
4482+ 2FC2 F1                   pop     AF              ; Restore count
4483+ 2FC3 3D                   dec     A               ; Count multiplies
4484+ 2FC4 C9                   ret
4485+ 2FC5
4486+ 2FC5 D5           ADDIG:  push    DE              ; Save sign of exponent
4487+ 2FC6 57                   ld      D,A             ; Save digit
4488+ 2FC7 78                   ld      A,B             ; Get digits after point
4489+ 2FC8 89                   adc     A,C             ; Add one if after point
4490+ 2FC9 47                   ld      B,A             ; Re-save counter
4491+ 2FCA C5                   push    BC              ; Save point flags
4492+ 2FCB E5                   push    HL              ; Save code string address
4493+ 2FCC D5                   push    DE              ; Save digit
4494+ 2FCD CD 4A 2E             call    MLSP10          ; Multiply number by 10
4495+ 2FD0 F1                   pop     AF              ; Restore digit
4496+ 2FD1 D6 30                sub     '0'             ; Make it absolute
4497+ 2FD3 CD DC 2F             call    RSCALE          ; Re-scale number
4498+ 2FD6 E1                   pop     HL              ; Restore code string address
4499+ 2FD7 C1                   pop     BC              ; Restore point flags
4500+ 2FD8 D1                   pop     DE              ; Restore sign of exponent
4501+ 2FD9 C3 7C 2F             jp      MANLP           ; Get another digit
4502+ 2FDC
4503+ 2FDC CD 92 2E     RSCALE: call    STAKFP          ; Put number on stack
4504+ 2FDF CD 73 2E             call    FLGREL          ; Digit to add to FPREG
4505+ 2FE2 C1           PADD:   pop     BC              ; Restore number
4506+ 2FE3 D1                   pop     DE
4507+ 2FE4 C3 CA 2B             jp      FPADD           ; Add BCDE to FPREG and return
4508+ 2FE7
4509+ 2FE7 7B           EDIGIT: ld      A,E             ; Get digit
4510+ 2FE8 07                   rlca                    ; Times 2
4511+ 2FE9 07                   rlca                    ; Times 4
4512+ 2FEA 83                   add     A,E             ; Times 5
4513+ 2FEB 07                   rlca                    ; Times 10
4514+ 2FEC 86                   add     A,(HL)          ; Add next digit
4515+ 2FED D6 30                sub     '0'             ; Make it absolute
4516+ 2FEF 5F                   ld      E,A             ; Save new digit
4517+ 2FF0 C3 92 2F             jp      EXPLP           ; Look for another digit
4518+ 2FF3
4519+ 2FF3 E5           LINEIN: push    HL              ; Save code string address
4520+ 2FF4 21 21 16             ld      HL,INMSG        ; Output " in "
4521+ 2FF7 CD 5C 25             call    PRS             ; Output string at HL
4522+ 2FFA E1                   pop     HL              ; Restore code string address
4523+ 2FFB EB           PRNTHL: ex      DE,HL           ; Code string address to DE
4524+ 2FFC AF                   xor     A
4525+ 2FFD 06 98                ld      B,$80+24        ; 24 bits
4526+ 2FFF CD 78 2E             call    RETINT          ; Return the integer
4527+ 3002 21 5B 25             ld      HL,PRNUMS       ; Print number string
4528+ 3005 E5                   push    HL              ; Save for return
4529+ 3006 21 35 53     NUMASC: ld      HL,PBUFF        ; Convert number to ASCII
4530+ 3009 E5                   push    HL              ; Save for return
4531+ 300A CD 61 2E             call    TSTSGN          ; Test sign of FPREG
4532+ 300D 36 20                ld      (HL),SPC        ; Space at start
4533+ 300F F2 14 30             jp      P,SPCFST        ; Positive - Space to start
4534+ 3012 36 2D                ld      (HL),'-'        ; '-' sign at start
4535+ 3014 23           SPCFST: inc     HL              ; First byte of number
4536+ 3015 36 30                ld      (HL),'0'        ; '0' if zero
4537+ 3017 CA CA 30             jp      Z,JSTZER        ; Return '0' if zero
4538+ 301A E5                   push    HL              ; Save buffer address
4539+ 301B FC 8A 2E             call    M,INVSGN        ; Negate FPREG if negative
4540+ 301E AF                   xor     A               ; Zero A
4541+ 301F F5                   push    AF              ; Save it
4542+ 3020 CD D0 30             call    RNGTST          ; Test number is in range
4543+ 3023 01 43 91     SIXDIG: ld      BC,$9143        ; BCDE - 99999.9
4544+ 3026 11 F8 4F             ld      DE,$4FF8
4545+ 3029 CD DC 2E             call    CMPNUM          ; Compare numbers
4546+ 302C B7                   or      A
4547+ 302D E2 41 30             jp      PO,INRNG        ; > 99999.9 - Sort it out
4548+ 3030 F1                   pop     AF              ; Restore count
4549+ 3031 CD BE 2F             call    MULTEN          ; Multiply by ten
4550+ 3034 F5                   push    AF              ; Re-save count
4551+ 3035 C3 23 30             jp      SIXDIG          ; Test it again
4552+ 3038
4553+ 3038 CD A9 2D     GTSIXD: call    DIV10           ; Divide by 10
4554+ 303B F1                   pop     AF              ; Get count
4555+ 303C 3C                   inc     A               ; Count divides
4556+ 303D F5                   push    AF              ; Re-save count
4557+ 303E CD D0 30             call    RNGTST          ; Test number is in range
4558+ 3041 CD B8 2B     INRNG:  call    ROUND           ; Add 0.5 to FPREG
4559+ 3044 3C                   inc     A
4560+ 3045 CD 09 2F             call    FPINT           ; F.P to integer
4561+ 3048 CD A2 2E             call    FPBCDE          ; Move BCDE to FPREG
4562+ 304B 01 06 03             ld      BC,$0306        ; 1E+06 to 1E-03 range
4563+ 304E F1                   pop     AF              ; Restore count
4564+ 304F 81                   add     A,C             ; 6 digits before point
4565+ 3050 3C                   inc     A               ; Add one
4566+ 3051 FA 5D 30             jp      M,MAKNUM        ; Do it in 'E' form if < 1E-02
4567+ 3054 FE 08                cp      6+1+1           ; More than 999999 ?
4568+ 3056 D2 5D 30             jp      NC,MAKNUM       ; Yes - Do it in 'E' form
4569+ 3059 3C                   inc     A               ; Adjust for exponent
4570+ 305A 47                   ld      B,A             ; Exponent of number
4571+ 305B 3E 02                ld      A,2             ; Make it zero after
4572+ 305D
4573+ 305D 3D           MAKNUM: dec     A               ; Adjust for digits to do
4574+ 305E 3D                   dec     A
4575+ 305F E1                   pop     HL              ; Restore buffer address
4576+ 3060 F5                   push    AF              ; Save count
4577+ 3061 11 E3 30             ld      DE,POWERS       ; Powers of ten
4578+ 3064 05                   dec     B               ; Count digits before point
4579+ 3065 C2 6E 30             jp      NZ,DIGTXT       ; Not zero - Do number
4580+ 3068 36 2E                ld      (HL),'.'        ; Save point
4581+ 306A 23                   inc     HL              ; Move on
4582+ 306B 36 30                ld      (HL),'0'        ; Save zero
4583+ 306D 23                   inc     HL              ; Move on
4584+ 306E 05           DIGTXT: dec     B               ; Count digits before point
4585+ 306F 36 2E                ld      (HL),'.'        ; Save point in case
4586+ 3071 CC B7 2E             call    Z,INCHL         ; Last digit - move on
4587+ 3074 C5                   push    BC              ; Save digits before point
4588+ 3075 E5                   push    HL              ; Save buffer address
4589+ 3076 D5                   push    DE              ; Save powers of ten
4590+ 3077 CD AD 2E             call    BCDEFP          ; Move FPREG to BCDE
4591+ 307A E1                   pop     HL              ; Powers of ten table
4592+ 307B 06 2F                ld      B,'0'-1         ; ASCII '0' - 1
4593+ 307D 04           TRYAGN: inc     B               ; Count subtractions
4594+ 307E 7B                   ld      A,E             ; Get LSB
4595+ 307F 96                   sub     (HL)            ; Subtract LSB
4596+ 3080 5F                   ld      E,A             ; Save LSB
4597+ 3081 23                   inc     HL
4598+ 3082 7A                   ld      A,D             ; Get NMSB
4599+ 3083 9E                   sbc     A,(HL)          ; Subtract NMSB
4600+ 3084 57                   ld      D,A             ; Save NMSB
4601+ 3085 23                   inc     HL
4602+ 3086 79                   ld      A,C             ; Get MSB
4603+ 3087 9E                   sbc     A,(HL)          ; Subtract MSB
4604+ 3088 4F                   ld      C,A             ; Save MSB
4605+ 3089 2B                   dec     HL              ; Point back to start
4606+ 308A 2B                   dec     HL
4607+ 308B D2 7D 30             jp      NC,TRYAGN       ; No overflow - Try again
4608+ 308E CD 6F 2C             call    PLUCDE          ; Restore number
4609+ 3091 23                   inc     HL              ; Start of next number
4610+ 3092 CD A2 2E             call    FPBCDE          ; Move BCDE to FPREG
4611+ 3095 EB                   ex      DE,HL           ; Save point in table
4612+ 3096 E1                   pop     HL              ; Restore buffer address
4613+ 3097 70                   ld      (HL),B          ; Save digit in buffer
4614+ 3098 23                   inc     HL              ; And move on
4615+ 3099 C1                   pop     BC              ; Restore digit count
4616+ 309A 0D                   dec     C               ; Count digits
4617+ 309B C2 6E 30             jp      NZ,DIGTXT       ; More - Do them
4618+ 309E 05                   dec     B               ; Any decimal part?
4619+ 309F CA AE 30             jp      Z,DOEBIT        ; No - Do 'E' bit
4620+ 30A2 2B           SUPTLZ: dec     HL              ; Move back through buffer
4621+ 30A3 7E                   ld      A,(HL)          ; Get character
4622+ 30A4 FE 30                cp      '0'             ; '0' character?
4623+ 30A6 CA A2 30             jp      Z,SUPTLZ        ; Yes - Look back for more
4624+ 30A9 FE 2E                cp      '.'             ; A decimal point?
4625+ 30AB C4 B7 2E             call    NZ,INCHL        ; Move back over digit
4626+ 30AE
4627+ 30AE F1           DOEBIT: pop     AF              ; Get 'E' flag
4628+ 30AF CA CD 30             jp      Z,NOENED        ; No 'E' needed - End buffer
4629+ 30B2 36 45                ld      (HL),'E'        ; Put 'E' in buffer
4630+ 30B4 23                   inc     HL              ; And move on
4631+ 30B5 36 2B                ld      (HL),'+'        ; Put '+' in buffer
4632+ 30B7 F2 BE 30             jp      P,OUTEXP        ; Positive - Output exponent
4633+ 30BA 36 2D                ld      (HL),'-'        ; Put '-' in buffer
4634+ 30BC 2F                   cpl                     ; Negate exponent
4635+ 30BD 3C                   inc     A
4636+ 30BE 06 2F        OUTEXP: ld      B,'0'-1         ; ASCII '0' - 1
4637+ 30C0 04           EXPTEN: inc     B               ; Count subtractions
4638+ 30C1 D6 0A                sub     $0A             ; Tens digit
4639+ 30C3 D2 C0 30             jp      NC,EXPTEN       ; More to do
4640+ 30C6 C6 3A                add     A,'0'+10        ; Restore and make ASCII
4641+ 30C8 23                   inc     HL              ; Move on
4642+ 30C9 70                   ld      (HL),B          ; Save MSB of exponent
4643+ 30CA 23           JSTZER: inc     HL              ;
4644+ 30CB 77                   ld      (HL),A          ; Save LSB of exponent
4645+ 30CC 23                   inc     HL
4646+ 30CD 71           NOENED: ld      (HL),C          ; Mark end of buffer
4647+ 30CE E1                   pop     HL              ; Restore code string address
4648+ 30CF C9                   ret
4649+ 30D0
4650+ 30D0 01 74 94     RNGTST: ld      BC,$9474        ; BCDE = 999999.
4651+ 30D3 11 F7 23             ld      DE,$23F7
4652+ 30D6 CD DC 2E             call    CMPNUM          ; Compare numbers
4653+ 30D9 B7                   or      A
4654+ 30DA E1                   pop     HL              ; Return address to HL
4655+ 30DB E2 38 30             jp      PO,GTSIXD       ; Too big - Divide by ten
4656+ 30DE E9                   jp      (HL)            ; Otherwise return to caller
4657+ 30DF
4658+ 30DF 00 00 00 80  HALF:   defb    $00,$00,$00,$80 ; 0.5
4659+ 30E3
4660+ 30E3 A0 86 01     POWERS: defb    $A0,$86,$01  ; 100000
4661+ 30E6 10 27 00             defb    $10,$27,$00  ;  10000
4662+ 30E9 E8 03 00             defb    $E8,$03,$00  ;   1000
4663+ 30EC 64 00 00             defb    $64,$00,$00  ;    100
4664+ 30EF 0A 00 00             defb    $0A,$00,$00  ;     10
4665+ 30F2 01 00 00             defb    $01,$00,$00  ;      1
4666+ 30F5
4667+ 30F5 21 8A 2E     NEGAFT: ld      HL,INVSGN       ; Negate result
4668+ 30F8 E3                   ex      (SP),HL         ; To be done after caller
4669+ 30F9 E9                   jp      (HL)            ; Return to caller
4670+ 30FA
4671+ 30FA CD 92 2E     SQR:    call    STAKFP          ; Put value on stack
4672+ 30FD 21 DF 30             ld      HL,HALF         ; Set power to 1/2
4673+ 3100 CD 9F 2E             call    PHLTFP          ; Move 1/2 to FPREG
4674+ 3103
4675+ 3103 C1           POWER:  pop     BC              ; Get base
4676+ 3104 D1                   pop     DE
4677+ 3105 CD 61 2E             call    TSTSGN          ; Test sign of power
4678+ 3108 78                   ld      A,B             ; Get exponent of base
4679+ 3109 CA 48 31             jp      Z,EXP           ; Make result 1 if zero
4680+ 310C F2 13 31             jp      P,POWER1        ; Positive base - Ok
4681+ 310F B7                   or      A               ; Zero to negative power?
4682+ 3110 CA AB 16             jp      Z,DZERR         ; Yes - ?/0 Error
4683+ 3113 B7           POWER1: or      A               ; Base zero?
4684+ 3114 CA 31 2C             jp      Z,SAVEXP        ; Yes - Return zero
4685+ 3117 D5                   push    DE              ; Save base
4686+ 3118 C5                   push    BC
4687+ 3119 79                   ld      A,C             ; Get MSB of base
4688+ 311A F6 7F                or      %01111111       ; Get sign status
4689+ 311C CD AD 2E             call    BCDEFP          ; Move power to BCDE
4690+ 311F F2 30 31             jp      P,POWER2        ; Positive base - Ok
4691+ 3122 D5                   push    DE              ; Save power
4692+ 3123 C5                   push    BC
4693+ 3124 CD 34 2F             call    INT             ; Get integer of power
4694+ 3127 C1                   pop     BC              ; Restore power
4695+ 3128 D1                   pop     DE
4696+ 3129 F5                   push    AF              ; MSB of base
4697+ 312A CD DC 2E             call    CMPNUM          ; Power an integer?
4698+ 312D E1                   pop     HL              ; Restore MSB of base
4699+ 312E 7C                   ld      A,H             ; but don't affect flags
4700+ 312F 1F                   rra                     ; Exponent odd or even?
4701+ 3130 E1           POWER2: pop     HL              ; Restore MSB and exponent
4702+ 3131 22 32 53             ld      (FPREG+2),HL    ; Save base in FPREG
4703+ 3134 E1                   pop     HL              ; LSBs of base
4704+ 3135 22 30 53             ld      (FPREG),HL      ; Save in FPREG
4705+ 3138 DC F5 30             call    C,NEGAFT        ; Odd power - Negate result
4706+ 313B CC 8A 2E             call    Z,INVSGN        ; Negative base - Negate it
4707+ 313E D5                   push    DE              ; Save power
4708+ 313F C5                   push    BC
4709+ 3140 CD C4 2C             call    LOG             ; Get LOG of base
4710+ 3143 C1                   pop     BC              ; Restore power
4711+ 3144 D1                   pop     DE
4712+ 3145 CD 05 2D             call    FPMULT          ; Multiply LOG by power
4713+ 3148
4714+ 3148 CD 92 2E     EXP:    call    STAKFP          ; Put value on stack
4715+ 314B 01 38 81             ld      BC,$8138        ; BCDE = 1/Ln(2)
4716+ 314E 11 3B AA             ld      DE,$AA3B
4717+ 3151 CD 05 2D             call    FPMULT          ; Multiply value by 1/LN(2)
4718+ 3154 3A 33 53             ld      A,(FPEXP)       ; Get exponent
4719+ 3157 FE 88                cp      $80+8           ; Is it in range?
4720+ 3159 D2 3D 2E             jp      NC,OVTST1       ; No - Test for overflow
4721+ 315C CD 34 2F             call    INT             ; Get INT of FPREG
4722+ 315F C6 80                add     A,$80           ; For excess 128
4723+ 3161 C6 02                add     A,$02           ; Exponent > 126?
4724+ 3163 DA 3D 2E             jp      C,OVTST1        ; Yes - Test for overflow
4725+ 3166 F5                   push    AF              ; Save scaling factor
4726+ 3167 21 B3 2C             ld      HL,UNITY        ; Point to 1.
4727+ 316A CD BB 2B             call    ADDPHL          ; Add 1 to FPREG
4728+ 316D CD FC 2C             call    MULLN2          ; Multiply by LN(2)
4729+ 3170 F1                   pop     AF              ; Restore scaling factor
4730+ 3171 C1                   pop     BC              ; Restore exponent
4731+ 3172 D1                   pop     DE
4732+ 3173 F5                   push    AF              ; Save scaling factor
4733+ 3174 CD C7 2B             call    SUBCDE          ; Subtract exponent from FPREG
4734+ 3177 CD 8A 2E             call    INVSGN          ; Negate result
4735+ 317A 21 88 31             ld      HL,EXPTAB       ; Coefficient table
4736+ 317D CD B8 31             call    SMSER1          ; Sum the series
4737+ 3180 11 00 00             ld      DE,$0000        ; Zero LSBs
4738+ 3183 C1                   pop     BC              ; Scaling factor
4739+ 3184 4A                   ld      C,D             ; Zero MSB
4740+ 3185 C3 05 2D             jp      FPMULT          ; Scale result to correct value
4741+ 3188
4742+ 3188 08           EXPTAB: defb    $08             ; Table used by EXP
4743+ 3189 40 2E 94 74          defb    $40,$2E,$94,$74 ; -1/7! (-1/5040)
4744+ 318D 70 4F 2E 77          defb    $70,$4F,$2E,$77 ;  1/6! ( 1/720)
4745+ 3191 6E 02 88 7A          defb    $6E,$02,$88,$7A ; -1/5! (-1/120)
4746+ 3195 E6 A0 2A 7C          defb    $E6,$A0,$2A,$7C ;  1/4! ( 1/24)
4747+ 3199 50 AA AA 7E          defb    $50,$AA,$AA,$7E ; -1/3! (-1/6)
4748+ 319D FF FF 7F 7F          defb    $FF,$FF,$7F,$7F ;  1/2! ( 1/2)
4749+ 31A1 00 00 80 81          defb    $00,$00,$80,$81 ; -1/1! (-1/1)
4750+ 31A5 00 00 00 81          defb    $00,$00,$00,$81 ;  1/0! ( 1/1)
4751+ 31A9
4752+ 31A9 CD 92 2E     SUMSER: call    STAKFP          ; Put FPREG on stack
4753+ 31AC 11 03 2D             ld      DE,MULT         ; Multiply by "X"
4754+ 31AF D5                   push    DE              ; To be done after
4755+ 31B0 E5                   push    HL              ; Save address of table
4756+ 31B1 CD AD 2E             call    BCDEFP          ; Move FPREG to BCDE
4757+ 31B4 CD 05 2D             call    FPMULT          ; Square the value
4758+ 31B7 E1                   pop     HL              ; Restore address of table
4759+ 31B8 CD 92 2E     SMSER1: call    STAKFP          ; Put value on stack
4760+ 31BB 7E                   ld      A,(HL)          ; Get number of coefficients
4761+ 31BC 23                   inc     HL              ; Point to start of table
4762+ 31BD CD 9F 2E             call    PHLTFP          ; Move coefficient to FPREG
4763+ 31C0 06                   defb    06H             ; Skip "pop AF"
4764+ 31C1 F1           SUMLP:  pop     AF              ; Restore count
4765+ 31C2 C1                   pop     BC              ; Restore number
4766+ 31C3 D1                   pop     DE
4767+ 31C4 3D                   dec     A               ; Cont coefficients
4768+ 31C5 C8                   ret     Z               ; All done
4769+ 31C6 D5                   push    DE              ; Save number
4770+ 31C7 C5                   push    BC
4771+ 31C8 F5                   push    AF              ; Save count
4772+ 31C9 E5                   push    HL              ; Save address in table
4773+ 31CA CD 05 2D             call    FPMULT          ; Multiply FPREG by BCDE
4774+ 31CD E1                   pop     HL              ; Restore address in table
4775+ 31CE CD B0 2E             call    LOADFP          ; Number at HL to BCDE
4776+ 31D1 E5                   push    HL              ; Save address in table
4777+ 31D2 CD CA 2B             call    FPADD           ; Add coefficient to FPREG
4778+ 31D5 E1                   pop     HL              ; Restore address in table
4779+ 31D6 C3 C1 31             jp      SUMLP           ; More coefficients
4780+ 31D9
4781+ 31D9 CD 61 2E     RND:    call    TSTSGN          ; Test sign of FPREG
4782+ 31DC 21 78 51             ld      HL,SEED+2       ; Random number seed
4783+ 31DF FA 3A 32             jp      M,RESEED        ; Negative - Re-seed
4784+ 31E2 21 99 51             ld      HL,LSTRND       ; Last random number
4785+ 31E5 CD 9F 2E             call    PHLTFP          ; Move last RND to FPREG
4786+ 31E8 21 78 51             ld      HL,SEED+2       ; Random number seed
4787+ 31EB C8                   ret     Z               ; Return if RND(0)
4788+ 31EC 86                   add     A,(HL)          ; Add (SEED)+2)
4789+ 31ED E6 07                and     %00000111       ; 0 to 7
4790+ 31EF 06 00                ld      B,$00
4791+ 31F1 77                   ld      (HL),A          ; Re-save seed
4792+ 31F2 23                   inc     HL              ; Move to coefficient table
4793+ 31F3 87                   add     A,A             ; 4 bytes
4794+ 31F4 87                   add     A,A             ; per entry
4795+ 31F5 4F                   ld      C,A             ; BC = Offset into table
4796+ 31F6 09                   add     HL,BC           ; Point to coefficient
4797+ 31F7 CD B0 2E             call    LOADFP          ; Coefficient to BCDE
4798+ 31FA CD 05 2D             call    FPMULT  ;       ; Multiply FPREG by coefficient
4799+ 31FD 3A 77 51             ld      A,(SEED+1)      ; Get (SEED+1)
4800+ 3200 3C                   inc     A               ; Add 1
4801+ 3201 E6 03                and     %00000011       ; 0 to 3
4802+ 3203 06 00                ld      B,$00
4803+ 3205 FE 01                cp      $01             ; Is it zero?
4804+ 3207 88                   adc     A,B             ; Yes - Make it 1
4805+ 3208 32 77 51             ld      (SEED+1),A      ; Re-save seed
4806+ 320B 21 3E 32             ld      HL,RNDTAB-4     ; Addition table
4807+ 320E 87                   add     A,A             ; 4 bytes
4808+ 320F 87                   add     A,A             ; per entry
4809+ 3210 4F                   ld      C,A             ; BC = Offset into table
4810+ 3211 09                   add     HL,BC           ; Point to value
4811+ 3212 CD BB 2B             call    ADDPHL          ; Add value to FPREG
4812+ 3215 CD AD 2E     RND1:   call    BCDEFP          ; Move FPREG to BCDE
4813+ 3218 7B                   ld      A,E             ; Get LSB
4814+ 3219 59                   ld      E,C             ; LSB = MSB
4815+ 321A EE 4F                xor     %01001111       ; Fiddle around
4816+ 321C 4F                   ld      C,A             ; New MSB
4817+ 321D 36 80                ld      (HL),$80        ; Set exponent
4818+ 321F 2B                   dec     HL              ; Point to MSB
4819+ 3220 46                   ld      B,(HL)          ; Get MSB
4820+ 3221 36 80                ld      (HL),$80        ; Make value -0.5
4821+ 3223 21 76 51             ld      HL,SEED         ; Random number seed
4822+ 3226 34                   inc     (HL)            ; Count seed
4823+ 3227 7E                   ld      A,(HL)          ; Get seed
4824+ 3228 D6 AB                sub     $AB             ; Do it modulo 171
4825+ 322A C2 31 32             jp      NZ,RND2         ; Non-zero - Ok
4826+ 322D 77                   ld      (HL),A          ; Zero seed
4827+ 322E 0C                   inc     C               ; Fillde about
4828+ 322F 15                   dec     D               ; with the
4829+ 3230 1C                   inc     E               ; number
4830+ 3231 CD 1B 2C     RND2:   call    BNORM           ; Normalise number
4831+ 3234 21 99 51             ld      HL,LSTRND       ; Save random number
4832+ 3237 C3 B9 2E             jp      FPTHL           ; Move FPREG to last and return
4833+ 323A
4834+ 323A 77           RESEED: ld      (HL),A          ; Re-seed random numbers
4835+ 323B 2B                   dec     HL
4836+ 323C 77                   ld      (HL),A
4837+ 323D 2B                   dec     HL
4838+ 323E 77                   ld      (HL),A
4839+ 323F C3 15 32             jp      RND1            ; Return RND seed
4840+ 3242
4841+ 3242 68 B1 46 68  RNDTAB: defb    $68,$B1,$46,$68 ; Table used by RND
4842+ 3246 99 E9 92 69          defb    $99,$E9,$92,$69
4843+ 324A 10 D1 75 68          defb    $10,$D1,$75,$68
4844+ 324E
4845+ 324E 21 98 32     COS:    ld      HL,HALFPI       ; Point to PI/2
4846+ 3251 CD BB 2B             call    ADDPHL          ; Add it to PPREG
4847+ 3254 CD 92 2E     SIN:    call    STAKFP          ; Put angle on stack
4848+ 3257 01 49 83             ld      BC,$8349        ; BCDE = 2 PI
4849+ 325A 11 DB 0F             ld      DE,$0FDB
4850+ 325D CD A2 2E             call    FPBCDE          ; Move 2 PI to FPREG
4851+ 3260 C1                   pop     BC              ; Restore angle
4852+ 3261 D1                   pop     DE
4853+ 3262 CD B7 2D             call    DVBCDE          ; Divide angle by 2 PI
4854+ 3265 CD 92 2E             call    STAKFP          ; Put it on stack
4855+ 3268 CD 34 2F             call    INT             ; Get INT of result
4856+ 326B C1                   pop     BC              ; Restore number
4857+ 326C D1                   pop     DE
4858+ 326D CD C7 2B             call    SUBCDE          ; Make it 0 <= value < 1
4859+ 3270 21 9C 32             ld      HL,QUARTR       ; Point to 0.25
4860+ 3273 CD C1 2B             call    SUBPHL          ; Subtract value from 0.25
4861+ 3276 CD 61 2E             call    TSTSGN          ; Test sign of value
4862+ 3279 37                   scf                     ; Flag positive
4863+ 327A F2 84 32             jp      P,SIN1          ; Positive - Ok
4864+ 327D CD B8 2B             call    ROUND           ; Add 0.5 to value
4865+ 3280 CD 61 2E             call    TSTSGN          ; Test sign of value
4866+ 3283 B7                   or      A               ; Flag negative
4867+ 3284 F5           SIN1:   push    AF              ; Save sign
4868+ 3285 F4 8A 2E             call    P,INVSGN        ; Negate value if positive
4869+ 3288 21 9C 32             ld      HL,QUARTR       ; Point to 0.25
4870+ 328B CD BB 2B             call    ADDPHL          ; Add 0.25 to value
4871+ 328E F1                   pop     AF              ; Restore sign
4872+ 328F D4 8A 2E             call    NC,INVSGN       ; Negative - Make positive
4873+ 3292 21 A0 32             ld      HL,SINTAB       ; Coefficient table
4874+ 3295 C3 A9 31             jp      SUMSER          ; Evaluate sum of series
4875+ 3298
4876+ 3298 DB 0F 49 81  HALFPI: defb    $DB,$0F,$49,$81 ; 1.5708 (PI/2)
4877+ 329C
4878+ 329C 00 00 00 7F  QUARTR: defb    $00,$00,$00,$7F ; 0.25
4879+ 32A0
4880+ 32A0 05           SINTAB: defb    $05             ; Table used by SIN
4881+ 32A1 BA D7 1E 86          defb    $BA,$D7,$1E,$86 ; 39.711
4882+ 32A5 64 26 99 87          defb    $64,$26,$99,$87 ;-76.575
4883+ 32A9 58 34 23 87          defb    $58,$34,$23,$87 ; 81.602
4884+ 32AD E0 5D A5 86          defb    $E0,$5D,$A5,$86 ;-41.342
4885+ 32B1 DA 0F 49 83          defb    $DA,$0F,$49,$83 ;  6.2832
4886+ 32B5
4887+ 32B5 CD 92 2E     TAN:    call    STAKFP          ; Put angle on stack
4888+ 32B8 CD 54 32             call    SIN             ; Get SIN of angle
4889+ 32BB C1                   pop     BC              ; Restore angle
4890+ 32BC E1                   pop     HL
4891+ 32BD CD 92 2E             call    STAKFP          ; Save SIN of angle
4892+ 32C0 EB                   ex      DE,HL           ; BCDE = Angle
4893+ 32C1 CD A2 2E             call    FPBCDE          ; Angle to FPREG
4894+ 32C4 CD 4E 32             call    COS             ; Get COS of angle
4895+ 32C7 C3 B5 2D             jp      DIV             ; TAN = SIN / COS
4896+ 32CA
4897+ 32CA CD 61 2E     ATN:    call    TSTSGN          ; Test sign of value
4898+ 32CD FC F5 30             call    M,NEGAFT        ; Negate result after if -ve
4899+ 32D0 FC 8A 2E             call    M,INVSGN        ; Negate value if -ve
4900+ 32D3 3A 33 53             ld      A,(FPEXP)       ; Get exponent
4901+ 32D6 FE 81                cp      81H             ; Number less than 1?
4902+ 32D8 DA E7 32             jp      C,ATN1          ; Yes - Get arc tangnt
4903+ 32DB 01 00 81             ld      BC,$8100        ; BCDE = 1
4904+ 32DE 51                   ld      D,C
4905+ 32DF 59                   ld      E,C
4906+ 32E0 CD B7 2D             call    DVBCDE          ; Get reciprocal of number
4907+ 32E3 21 C1 2B             ld      HL,SUBPHL       ; Sub angle from PI/2
4908+ 32E6 E5                   push    HL              ; Save for angle > 1
4909+ 32E7 21 F1 32     ATN1:   ld      HL,ATNTAB       ; Coefficient table
4910+ 32EA CD A9 31             call    SUMSER          ; Evaluate sum of series
4911+ 32ED 21 98 32             ld      HL,HALFPI       ; PI/2 - angle in case > 1
4912+ 32F0 C9                   ret                     ; Number > 1 - Sub from PI/2
4913+ 32F1
4914+ 32F1 09           ATNTAB: defb    $09             ; Table used by ATN
4915+ 32F2 4A D7 3B 78          defb    $4A,$D7,$3B,$78 ; 1/17
4916+ 32F6 02 6E 84 7B          defb    $02,$6E,$84,$7B ;-1/15
4917+ 32FA FE C1 2F 7C          defb    $FE,$C1,$2F,$7C ; 1/13
4918+ 32FE 74 31 9A 7D          defb    $74,$31,$9A,$7D ;-1/11
4919+ 3302 84 3D 5A 7D          defb    $84,$3D,$5A,$7D ; 1/9
4920+ 3306 C8 7F 91 7E          defb    $C8,$7F,$91,$7E ;-1/7
4921+ 330A E4 BB 4C 7E          defb    $E4,$BB,$4C,$7E ; 1/5
4922+ 330E 6C AA AA 7F          defb    $6C,$AA,$AA,$7F ;-1/3
4923+ 3312 00 00 00 81          defb    $00,$00,$00,$81 ; 1/1
4924+ 3316
4925+ 3316
4926+ 3316 C9           ARET:   ret                     ; A RETurn instruction
4927+ 3317
4928+ 3317 D7           GETINP: rst     $10             ; input a character
4929+ 3318 C9                   ret
4930+ 3319
4931+ 3319 E5           CLS:    push    HL
4932+ 331A D5                   push    DE
4933+ 331B 3A CD 52             ld      A,(SCR_MODE)    ; check screen mode
4934+ 331E FE 02                cp      $02             ; G2 mode?
4935+ 3320 CC D3 05             call    Z,EMPTYVIDBUF   ; yes, reset video buffer
4936+ 3323 D1                   pop     DE
4937+ 3324 E1                   pop     HL
4938+ 3325 3E 0C                ld      A,CS            ; ASCII Clear screen
4939+ 3327 CD C8 19             call    SND2VID         ; send to screen
4940+ 332A C3 70 3F             jp      MONOUT          ; Output character
4941+ 332D
4942+ 332D CD DA 28     WIDTH:  call    GETINT          ; Get integer 0-255
4943+ 3330 7B                   ld      A,E             ; Width to A
4944+ 3331 32 A0 51             ld      (LWIDTH),A      ; Set width
4945+ 3334 C9                   ret
4946+ 3335
4947+ 3335
4948+ 3335 CD 81 1C     DEEK:   call    DEINT           ; Get integer -32768 to 32767
4949+ 3338 D5                   push    DE              ; Save number
4950+ 3339 E1                   pop     HL              ; Number to HL
4951+ 333A 46           RECWRD: ld      B,(HL)          ; Get LSB of contents
4952+ 333B 23                   inc     HL
4953+ 333C 7E                   ld      A,(HL)          ; Get MSB of contents
4954+ 333D C3 3E 24             jp      ABPASS          ; Return integer AB
4955+ 3340
4956+ 3340 CD 54 20     DOKE:   call    GETNUM          ; Get a number
4957+ 3343 CD 81 1C             call    DEINT           ; Get integer -32768 to 32767
4958+ 3346 D5                   push    DE              ; Save address
4959+ 3347 CD 8A 19             call    CHKSYN          ; Make sure ',' follows
4960+ 334A 2C                   defb    ','
4961+ 334B CD 54 20             call    GETNUM          ; Get a number
4962+ 334E CD 81 1C             call    DEINT           ; Get integer -32768 to 32767
4963+ 3351 E3                   ex      (SP),HL         ; Save value,get address
4964+ 3352 73                   ld      (HL),E          ; Save LSB of value
4965+ 3353 23                   inc     HL
4966+ 3354 72                   ld      (HL),D          ; Save MSB of value
4967+ 3355 E1                   pop     HL              ; Restore code string address
4968+ 3356 C9                   ret
4969+ 3357
4970+ 3357              ; stop the execution of code for a certain bit of time. The pause
4971+ 3357              ; is between $0000 and $FFFF 100ths of second (0~655.5 secs)
4972+ 3357 CD 54 20     PAUSE:  call    GETNUM          ; Get a number
4973+ 335A CD 81 1C             call    DEINT           ; Get integer -32768 to 32767
4974+ 335D 7A                   ld      A,D             ; load D into A
4975+ 335E B3                   or      E               ; are D & E equal to $00?
4976+ 335F C8                   ret     Z               ; if yes, then return
4977+ 3360 C5           DIR_PAU:push    BC              ; store BC
4978+ 3361 3A BB 52             ld      A,(TMRCNT)      ; Load current value of system timer
4979+ 3364 47                   ld      B,A             ; move it into B
4980+ 3365 CD F6 1B     RPTPS:  call    TSTBRK          ; Test for break key
4981+ 3368 3A BB 52             ld      A,(TMRCNT)      ; Load current value of system timer
4982+ 336B B8                   cp      B               ; is it the same value?
4983+ 336C 28 F7                jr      Z,RPTPS         ; yes, so read again
4984+ 336E 47                   ld      B,A             ; no, so store the new value
4985+ 336F 1B                   dec     DE              ; decrement interval
4986+ 3370 7A                   ld      A,D             ; load D into A
4987+ 3371 B3                   or      E               ; check if DE is equal to 0 (if D & e are $00 then result is 0)
4988+ 3372 20 F1                jr      NZ,RPTPS        ; no, repeat
4989+ 3374 C1                   pop     BC              ; yes, recover BC and continue
4990+ 3375 C9                   ret
4991+ 3376
4992+ 3376              ; change the screen mode. Usage: SCREEN X[,Y][,Z]
4993+ 3376              ; where X is: 0=text mode (40x24),
4994+ 3376              ; 1=graphic mode 1 (32x24 chars); 2=graphic mode 2 (256x192 pixels);
4995+ 3376              ; 3=multicolor mode (64x48 pixels); 4=extended graphic mode 2 (32x24 chars mixed between G1 and G2)
4996+ 3376              ; Y is: 0=8x8 sprites, 1=16x16 sprites
4997+ 3376              ; Z is: 0=no sprite magnification; 1=sprite magnification x2 (8x8=>16x16, and 16x16=32x32)
4998+ 3376              ; (the latters are accepted only in graphic modes G1, G2, G3, and G4)
4999+ 3376 AF           SCREEN: xor     A
5000+ 3377 32 DE 52             ld      (TMPBFR2),A     ; sprite size & magnif. byte set to 0
5001+ 337A CD DA 28             call    GETINT          ; Get integer 0-255
5002+ 337D FE 05                cp      $05             ; is it a valid mode (0~4)?
5003+ 337F D2 96 1C             jp      NC,FCERR        ; No - Illegal function call Error
5004+ 3382 32 DC 52             ld      (TMPBFR1),A     ; store graphic mode
5005+ 3385 A7                   and     A               ; is it 0 (text mode)?
5006+ 3386 CA A2 33             jp      Z,SCVDP         ; yes, ignore other arguments and set mode immediately
5007+ 3389 CD E1 33     SETVDP: call    CHKSCAR         ; no, check if sprite size follows
5008+ 338C DA 94 33             jp      C,CKMAGN        ; no (set to 0 or missing), so jump over
5009+ 338F 3E 02                ld      A,$02           ; no, so set sprite size
5010+ 3391 32 DE 52             ld      (TMPBFR2),A     ; ...to 16x16
5011+ 3394 CD E1 33     CKMAGN: call    CHKSCAR         ; check if sprite magnification follows
5012+ 3397 DA A2 33             jp      C,SCVDP         ; no (set to 0 or missing), so jump over
5013+ 339A 3A DE 52             ld      A,(TMPBFR2)     ; yes, so retrieve sprite attributes...
5014+ 339D F6 01                or      $01             ; ...set sprite magnification to 2x...
5015+ 339F 32 DE 52             ld      (TMPBFR2),A     ; ...and save flags again
5016+ 33A2 F3           SCVDP:  di                      ; disable INTs
5017+ 33A3 D5                   push    DE              ; store DE
5018+ 33A4 E5                   push    HL              ; store HL
5019+ 33A5 3A DC 52             ld      A,(TMPBFR1)     ; recover graphic mode
5020+ 33A8 5F                   ld      E,A             ; and store it into E
5021+ 33A9 3A DE 52             ld      A,(TMPBFR2)     ; recover sprite flags
5022+ 33AC 57                   ld      D,A             ; and store them into D
5023+ 33AD D5                   push    DE              ; store D & E
5024+ 33AE CD D3 03             call    initVDP         ; initialize VDP with mode pointed by E
5025+ 33B1 D1                   pop     DE              ; retrieve D & E
5026+ 33B2 7B                   ld      A,E             ; move graphic mode into A
5027+ 33B3 87                   add     A,A
5028+ 33B4 87                   add     A,A
5029+ 33B5 87                   add     A,A             ; multiply A times 8 to get offset of graphic mode
5030+ 33B6 5F                   ld      E,A             ; and pass it into E
5031+ 33B7 D5                   push    DE              ; store sprite flags in E
5032+ 33B8 16 00                ld      D,$00           ; reset D
5033+ 33BA 21 F3 0A             ld      HL,VDPMODESET+1 ; load address of VDP settings for reg#1
5034+ 33BD 19                   add     HL,DE           ; load correct reg#1 setting
5035+ 33BE D1                   pop     DE              ; retrieve sprite flags from E
5036+ 33BF 7E                   ld      A,(HL)          ; load reg#1 setting
5037+ 33C0 E6 FC                and     %11111100       ; reset size & magn. bits
5038+ 33C2 B2                   or      D               ; set size & magn. bits
5039+ 33C3 5F                   ld      E,A             ; value into E
5040+ 33C4 3E 01                ld      A,$01           ; reg #1
5041+ 33C6 CD AF 06             call    WRITE_VREG      ; send setting to reg #1
5042+ 33C9 2A AD 51             ld      HL,(LINEAT)     ; Get current line number
5043+ 33CC 23                   inc     HL              ; -1 means direct statement
5044+ 33CD 7C                   ld      A,H
5045+ 33CE B5                   or      L
5046+ 33CF CC F2 08             call    Z,CURSOR_ON     ; enable cursor if not in program mode
5047+ 33D2 FB                   ei                      ; re-enable interrupts
5048+ 33D3 E1                   pop     HL              ; restore HL
5049+ 33D4 D1                   pop     DE              ; restore DE
5050+ 33D5 3A CC 52             ld      A,(SCR_SIZE_H)  ; check the screen mode by looking at the screen height
5051+ 33D8 FE 30                cp      $30             ; is it 48 chars or 192 pixels (MC and G2 modes)?
5052+ 33DA D0                   ret     NC              ; yes, so exit (in graphics 2 and multicolor no print-on-video)
5053+ 33DB 3E 01                ld      A,$01           ; no (we are in Text, G1 or ExG2), so activate the...
5054+ 33DD 32 D8 52             ld      (PRNTVIDEO),A   ; ...video buffer...
5055+ 33E0 C9                   ret                     ; ...and return to caller
5056+ 33E1
5057+ 33E1              ; check an additional argument for SCREEN
5058+ 33E1 2B           CHKSCAR:dec     HL              ; dec 'cos GETCHR INCs
5059+ 33E2 CD CB 1B             call    GETCHR          ; Get next character
5060+ 33E5 37                   scf                     ; set carry flag
5061+ 33E6 C8                   ret     Z               ; return if nothing follows with Carry=1
5062+ 33E7 CD 8A 19             call    CHKSYN          ; Make sure ',' follows
5063+ 33EA 2C                   defb    ','
5064+ 33EB CD DA 28             call    GETINT          ; get value
5065+ 33EE 1F                   rra                     ; Carry=bit #0
5066+ 33EF 3F                   ccf                     ; invert Carry, so Carry=0 if arg. is 1, and Carry=1 otherwise (arg<>1)
5067+ 33F0 C9                   ret                     ; return
5068+ 33F1
5069+ 33F1
5070+ 33F1              ; change the colors of the screen - Syntax is COLOR a,b,c where:
5071+ 33F1              ; a=foreground color / b=background color / c=border color
5072+ 33F1              ; a,b,c must be in a range between 1 and 15 (0 is transparent and it's not supported)
5073+ 33F1 CD DA 28     COLOR:  call    GETINT          ; get first value
5074+ 33F4 CD 9A 34             call    CHKCLR1         ; check if it's in range 1~15
5075+ 33F7 32 DC 52             ld      (TMPBFR1),A     ; store it
5076+ 33FA 3A CD 52             ld      A,(SCR_MODE)    ; check screen mode
5077+ 33FD FE 03                cp      $03             ; is it multicolor mode?
5078+ 33FF 20 0D                jr      NZ,CNTCKCL      ; no, continue
5079+ 3401 3E 0F                ld      A,$0F           ; white for...
5080+ 3403 32 DA 52             ld      (FRGNDCLR),A    ; ...foreground (even it's not used in MC)
5081+ 3406 3A DC 52             ld      A,(TMPBFR1)     ; yes, so we stop here because in MC mode we just support border color
5082+ 3409 32 E0 52             ld      (TMPBFR3),A     ; move color into temp buffer 3
5083+ 340C 18 31                jr      CLRMC           ; jump to set color
5084+ 340E CD 8A 19     CNTCKCL:call    CHKSYN          ; Make sure ',' follows
5085+ 3411 2C                   defb    ','
5086+ 3412 CD DA 28             call    GETINT          ; get second value
5087+ 3415 CD 9A 34             call    CHKCLR1         ; check if it's in range 1~15
5088+ 3418 32 DE 52             ld      (TMPBFR2),A     ; store it
5089+ 341B 3A CD 52             ld      A,(SCR_MODE)    ; check screen mode
5090+ 341E A7                   and     A               ; is it text mode?
5091+ 341F 28 1B                jr      Z,CLRTXT        ; yes, stop here because in text mode, background and border colors coincide
5092+ 3421 CD 8A 19             call    CHKSYN          ; Make sure ',' follows
5093+ 3424 2C                   defb    ','
5094+ 3425 CD DA 28             call    GETINT          ; get third value
5095+ 3428 CD 9A 34             call    CHKCLR1         ; check if it's in range 1~15
5096+ 342B 32 E0 52             ld      (TMPBFR3),A     ; store it
5097+ 342E D5                   push    DE              ; store DE
5098+ 342F 3A CD 52             ld      A,(SCR_MODE)    ; check screen mode
5099+ 3432 FE 01                cp      $01             ; is it G1 mode?
5100+ 3434 28 10                jr      Z,CLRG1         ; yes, jump over
5101+ 3436 FE 02                cp      $02             ; is it G2 mode?
5102+ 3438 28 15                jr      Z,CLRG2         ; yes, jump over
5103+ 343A 18 1C                jr      CLREX2          ; last case can only be ExG2
5104+ 343C CD 8D 34     CLRTXT: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5105+ 343F 32 E0 52     CLRMC:  ld      (TMPBFR3),A     ; store color settings (for MC mode, we only set border color)
5106+ 3442 D5                   push    DE              ; store DE
5107+ 3443 F3                   di                      ; disable INTs
5108+ 3444 18 2E                jr      SETBRCL         ; set colors and exit
5109+ 3446 CD 8D 34     CLRG1:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5110+ 3449 16 01                ld      D,$01           ; repeat 1 time
5111+ 344B 06 20                ld      B,$20           ; 32 bytes of colors
5112+ 344D 18 10                jr      LOADCLR         ; load colors
5113+ 344F CD 8D 34     CLRG2:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5114+ 3452 16 18                ld      D,$18           ; 18 pages of...
5115+ 3454 06 00                ld      B,$00           ; ...256 bytes each
5116+ 3456 18 07                jr      LOADCLR         ; load colors
5117+ 3458 CD 8D 34     CLREX2: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5118+ 345B 16 08                ld      D,$08           ; 8 pages of...
5119+ 345D 06 00                ld      B,$00           ; ...256 bytes each
5120+ 345F E5           LOADCLR:push    HL              ; store HL
5121+ 3460 21 00 20             ld      HL,$2000        ; color table start: $2000
5122+ 3463 F3                   di                      ; disable INTs
5123+ 3464 CD 65 06             call    SETVDPADRS
5124+ 3467 0E 30                ld      C,VDP_DAT       ; VDP data mode
5125+ 3469 ED 79        RPTLDCL:out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
5126+ 346B 00                   nop
5127+ 346C 00                   nop
5128+ 346D 10 FA                djnz    RPTLDCL         ; repeat for 256 bytes (1 page)
5129+ 346F 15                   dec     D               ; did we fill up all the pages?
5130+ 3470 20 F7                jr      NZ,RPTLDCL      ; no, repeat
5131+ 3472 FB                   ei
5132+ 3473 E1                   pop     HL              ; retrieve HL
5133+ 3474 3A DC 52     SETBRCL:ld      A,(TMPBFR1)     ; retrieve foreground color
5134+ 3477 32 DA 52             ld      (FRGNDCLR),A    ; store it
5135+ 347A 3A DE 52             ld      A,(TMPBFR2)     ; retrieve background color
5136+ 347D 32 DB 52             ld      (BKGNDCLR),A    ; store it
5137+ 3480 3A E0 52             ld      A,(TMPBFR3)     ; recover border color
5138+ 3483 5F                   ld      E,A             ; move it into E
5139+ 3484 3E 07                ld      A,$07           ; set VDP register 7
5140+ 3486 F3                   di
5141+ 3487 CD AF 06             call    WRITE_VREG      ; send value to VDP: set border color
5142+ 348A FB                   ei                      ; re-enable INTs
5143+ 348B D1                   pop     DE              ; retrieve DE
5144+ 348C C9                   ret                     ; return to caller
5145+ 348D
5146+ 348D
5147+ 348D              ; mix 2 color nibbles in 1 byte
5148+ 348D 3A DE 52     MIXCLRS:ld      A,(TMPBFR2)     ; retrieve background color
5149+ 3490 47                   ld      B,A             ; move it into B
5150+ 3491 3A DC 52             ld      A,(TMPBFR1)     ; retrieve foreground color
5151+ 3494 87                   add     A,A             ; move foreground color into the high nibble of A
5152+ 3495 87                   add     A,A
5153+ 3496 87                   add     A,A
5154+ 3497 87                   add     A,A
5155+ 3498 B0                   or      B               ; put background color into the low nibble of A
5156+ 3499 C9                   ret                     ; return to caller
5157+ 349A
5158+ 349A
5159+ 349A              ; check if the color is not 0 and into the range 1~15
5160+ 349A A7           CHKCLR1:and     A               ; is it 0?
5161+ 349B CA A8 16             jp      Z,SNERR         ; yes, raise a SN error
5162+ 349E FE 10        CHKCLR0:cp      $10             ; is it in range 0~15?
5163+ 34A0 D2 A8 16             jp      NC,SNERR        ; no, raise a SN error
5164+ 34A3 C9                   ret                     ; param is OK, can return
5165+ 34A4
5166+ 34A4
5167+ 34A4              ; check if in graphics 2 mode
5168+ 34A4 3A CD 52     CHKG2M: ld      A,(SCR_MODE)    ; check screen mode
5169+ 34A7 FE 02                cp      $02             ; actually, we can paint only in G2
5170+ 34A9 C2 AA 3A             jp      NZ,GMERR        ; no G2, print a No Graphics Mode Error
5171+ 34AC C9                   ret                     ; return to caller
5172+ 34AD
5173+ 34AD
5174+ 34AD              ; print a text in screen 2
5175+ 34AD              ; GPRINT text,x,y[,fc[,bc]]
5176+ 34AD              ; where "text" is an expression that can be converted into a sequence of ASCII chars,
5177+ 34AD              ; x & y are the coordinates (0<=x<=31, 0<=y<=23), fc & bc are foreground and background
5178+ 34AD              ; colors (1~15), resp.
5179+ 34AD              ; (portions of code are from nippur72)
5180+ 34AD              GX      equ     TMPBFR3
5181+ 34AD              GY      equ     TMPBFR4
5182+ 34AD              TMPCLR  equ     TMPBFR2
5183+ 34AD              MIXCOL  equ     TMPBFR1
5184+ 34AD              TMPADR  equ     VIDEOBUFF
5185+ 34AD              CHRPNT  equ     VIDEOBUFF+$02
5186+ 34AD              NUMCHR  equ     VIDEOBUFF+$04
5187+ 34AD              TMPHL   equ     VIDEOBUFF+$06
5188+ 34AD CD A4 34     GPRINT: call    CHKG2M          ; check if in graphic mode 2
5189+ 34B0 2B                   dec     HL              ; dec 'cos GETCHR INCs
5190+ 34B1 CD CB 1B             call    GETCHR          ; check if something follows
5191+ 34B4 CA A8 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
5192+ 34B7 22 E4 52             ld      (VIDEOBUFF),HL  ; save current code string pointer
5193+ 34BA CD 66 20             call    EVAL            ; Evaluate expression
5194+ 34BD CD 58 20             call    TSTSTR          ; Make sure it's a string
5195+ 34C0 22 EA 52             ld      (TMPHL),HL      ; store code string pointer
5196+ 34C3 CD 9F 26             call    GSTRCU          ; Current string to pool
5197+ 34C6 CD B0 2E             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
5198+ 34C9 ED 43 E6 52          ld      (CHRPNT),BC     ; store string pointer
5199+ 34CD ED 53 E8 52          ld      (NUMCHR),DE     ; store string lenght
5200+ 34D1 2A EA 52             ld      HL,(TMPHL)      ; store code string pointer
5201+ 34D4 CD 8A 19             call    CHKSYN          ; Make sure ',' follows
5202+ 34D7 2C                   defb    ','
5203+ 34D8 CD DA 28             call    GETINT          ; get X coord.
5204+ 34DB FE 20                cp      $20             ; is it in rage 0~31?
5205+ 34DD D2 96 1C             jp      NC,FCERR        ; Illegal function call error
5206+ 34E0 32 E0 52             ld      (GX),A          ; store into temp. buffer
5207+ 34E3 CD 8A 19             call    CHKSYN          ; Make sure ',' follows
5208+ 34E6 2C                   defb    ','
5209+ 34E7 CD DA 28             call    GETINT          ; get Y coord.
5210+ 34EA FE 18                cp      $18             ; is it in range 0~23?
5211+ 34EC D2 96 1C             jp      NC,FCERR        ; Illegal function call error
5212+ 34EF 32 E2 52             ld      (GY),A          ; store into temp. buffer
5213+ 34F2 11 DE 52             ld      DE,TMPCLR
5214+ 34F5 3A DB 52             ld      A,(BKGNDCLR)    ; load background color
5215+ 34F8 12                   ld      (DE),A          ; store into temp buff
5216+ 34F9 3A DA 52             ld      A,(FRGNDCLR)    ; load foreground color
5217+ 34FC 1B                   dec     DE
5218+ 34FD 1B                   dec     DE
5219+ 34FE 12                   ld      (DE),A          ; store into temp buff
5220+ 34FF CD 8B 35             call    CKCOL           ; check color
5221+ 3502 CA 0A 35             jp      Z,CNTGPT2       ; if anything follows, jump over
5222+ 3505 13                   inc     DE
5223+ 3506 13                   inc     DE
5224+ 3507 CD 8B 35             call    CKCOL           ; check background color
5225+ 350A CD 8D 34     CNTGPT2:call    MIXCLRS         ; mix foreground & background colors
5226+ 350D 32 DC 52             ld      (MIXCOL),A      ; store mixed colors
5227+ 3510 E5                   push    HL              ; store code string address
5228+ 3511 ED 4B E6 52          ld      BC,(CHRPNT)     ; retrieve string pointer
5229+ 3515 ED 5B E8 52          ld      DE,(NUMCHR)     ; retrieve string lenght
5230+ 3519 1C                   inc     E               ; Length + 1
5231+ 351A CD 1F 35             call    GPNT            ; print on G2
5232+ 351D E1                   pop     HL              ; recover HL
5233+ 351E C9                   ret                     ; return to caller
5234+ 351F D5           GPNT:   push    DE              ; store string lenght (E)
5235+ 3520                      ; calculate VRAM address of first char
5236+ 3520 3A E0 52             LD      A,(GX)          ; load X
5237+ 3523 6F                   ld      L,A             ;
5238+ 3524 26 00                ld      H,0             ; HL = X
5239+ 3526 29                   add     HL,HL           ;
5240+ 3527 29                   add     HL,HL           ;
5241+ 3528 29                   add     HL,HL           ; X=X*8
5242+ 3529 3A E2 52             ld      A,(GY)          ; load Y
5243+ 352C 57                   ld      D,A             ; move it into D
5244+ 352D 1E 00                ld      E,0             ; DE =Y*256
5245+ 352F 19                   add     HL,DE           ; address = X*8 + Y*256
5246+ 3530 22 E4 52             ld      (TMPADR),HL     ; store VRAM address of first VRAM cell
5247+ 3533 D1                   pop     DE              ; retrieve # of chars to be printed yet (E)
5248+ 3534 1D           RPGPNT: dec     E               ; Count characters
5249+ 3535 C8                   ret     Z               ; End of string - return
5250+ 3536 D5                   push    DE              ; store chars counter
5251+ 3537                      ; calculate dest address in color vram
5252+ 3537 2A E4 52             ld      HL,(TMPADR)     ; recover VRAM address
5253+ 353A 11 00 20             ld      DE,$2000        ; color map address
5254+ 353D 19                   add     HL,DE           ; HL = $2000 + XY address
5255+ 353E F3                   di                      ; disable INTs
5256+ 353F                      ; send color settings
5257+ 353F CD 65 06     GPNTCOL:call    SETVDPADRS      ; set VRAM address for color cell
5258+ 3542 3A DC 52             ld      A,(MIXCOL)      ; load color settings
5259+ 3545 06 08                ld      B,$08           ; repeat for 8 rows
5260+ 3547 0E 30                ld      C,VDP_DAT       ; VDP data mode
5261+ 3549 ED 79        GPNTCO1:out     (C),A           ; send data (VRAM pointer auto-increments)
5262+ 354B 00                   nop                     ; wait...
5263+ 354C 00                   nop                     ; ...a...
5264+ 354D 00                   nop                     ; ...while
5265+ 354E 10 F9                djnz    GPNTCO1         ; repeat for 8 cells
5266+ 3550                      ; calculate source address
5267+ 3550 2A E6 52             ld      HL,(CHRPNT)     ; load char pointer
5268+ 3553 7E                   ld      A,(HL)          ; get char
5269+ 3554 23                   inc     HL              ; increment char pointer
5270+ 3555 22 E6 52             ld      (CHRPNT),HL     ; store char pointer
5271+ 3558 6F                   ld      L,A             ;
5272+ 3559 26 00                ld      H,0             ; char into HL
5273+ 355B 29                   add     HL,HL           ;
5274+ 355C 29                   add     HL,HL           ;
5275+ 355D 29                   add     HL,HL           ; get offset of char into ROM (charcode * 8)
5276+ 355E 11 FA 47             ld      DE,CHRST88      ; DE = start of 8x8 fonts in ROM
5277+ 3561 19                   add     HL,DE           ; HL = start of characters in ROM
5278+ 3562 EB                   ex      DE,HL           ; store address into DE
5279+ 3563 2A E4 52     GPCPCHR:ld      HL,(TMPADR)     ; load VRAM address
5280+ 3566 CD 65 06             call    SETVDPADRS      ; send it to VDP
5281+ 3569 EB                   ex      DE,HL           ; restore address into HL
5282+ 356A 06 08                ld      B,$08           ; repeat for 8 rows
5283+ 356C 0E 30                ld      C,VDP_DAT       ; VDP data mode
5284+ 356E ED A3        GPCPCH1:outi                    ; load a byte from ROM and send to VRAM
5285+ 3570 00                   nop                     ; wait...
5286+ 3571 00                   nop                     ; ...a...
5287+ 3572 00                   nop                     ; ...while
5288+ 3573 20 F9                jr      NZ,GPCPCH1      ; repeat for 8 chars
5289+ 3575 FB                   ei                      ; re-enable INTs
5290+ 3576 11 08 00             ld      DE,$0008        ; 8 bytes to go to the next video ell
5291+ 3579 2A E4 52             ld      HL,(TMPADR)     ; load VRAM address
5292+ 357C 19                   add     HL,DE           ; get address of next VRAM cell
5293+ 357D 22 E4 52             ld      (TMPADR),HL     ; store new VRAM address
5294+ 3580 11 00 18             ld      DE,$1800        ; forbidden address
5295+ 3583 CD 97 3F             call    CMP16           ; check if the printing has gone out of the screen
5296+ 3586 D1                   pop     DE              ; retrieve number of chars to be printed
5297+ 3587 D0                   ret     NC              ; if HL>=$1800 then leave
5298+ 3588 C3 34 35             jp      RPGPNT          ; otherwise, check if more chars to output
5299+ 358B
5300+ 358B 2B           CKCOL:  dec     HL              ; dec 'cos GETCHR INCs
5301+ 358C CD CB 1B             call    GETCHR          ; Get next character
5302+ 358F C8                   ret     Z               ; return if nothing follows
5303+ 3590 CD 8A 19             call    CHKSYN          ; Make sure ',' follows
5304+ 3593 2C                   defb    ','
5305+ 3594 D5                   push    DE              ; store DE
5306+ 3595 CD DA 28             call    GETINT          ; get value
5307+ 3598 CD 9A 34             call    CHKCLR1         ; check if color is in range 1~15
5308+ 359B D1                   pop     DE              ; retrieve DE
5309+ 359C 12                   ld      (DE),A          ; store color into temp buffer
5310+ 359D C9                   ret                     ; return to caller
5311+ 359E
5312+ 359E
5313+ 359E              ; paint X,Y[,C]: in graphics mode, fills an area starting
5314+ 359E              ; at point X,Y, using default color or, if used, with
5315+ 359E              ; color set by C
5316+ 359E              ; TMPBFR1       X
5317+ 359E              ; TMPBFR2       Y
5318+ 359E              ; TMPBFR3       COLOR
5319+ 359E              PNT     equ     VIDEOBUFF
5320+ 359E              SPA     equ     VIDEOBUFF+$02
5321+ 359E              SPB     equ     VIDEOBUFF+$03
5322+ 359E              ORGSP   equ     VIDEOBUFF+$04
5323+ 359E CD A4 34     PAINT:  call    CHKG2M          ; check if in graphic mode 2
5324+ 35A1 CD DA 28             call    GETINT          ; get X
5325+ 35A4 32 DC 52             ld      (TMPBFR1),A     ; store X
5326+ 35A7 CD 8A 19             call    CHKSYN          ; Make sure ',' follows
5327+ 35AA 2C                   defb    ','
5328+ 35AB CD DA 28             call    GETINT          ; get Y coords,
5329+ 35AE FE C0                cp      $C0             ; check if Y is in range 0~191
5330+ 35B0 D2 96 1C             jp      NC,FCERR        ; no, raise an FC error
5331+ 35B3 32 DE 52             ld      (TMPBFR2),A     ; store Y
5332+ 35B6 CD 91 3A             call    CLRPRM          ; check if color has been passed
5333+ 35B9 3A E0 52             ld      A,(TMPBFR3)     ; load color
5334+ 35BC A7                   and     A               ; check if 0
5335+ 35BD CA 96 1C             jp      Z,FCERR         ; yes, raise an error
5336+ 35C0 E5                   push    HL              ; store HL
5337+ 35C1 C5                   push    BC              ; store BC
5338+ 35C2 D5                   push    DE              ; store DE
5339+ 35C3                      ; start algorithm
5340+ 35C3 CD D6 36             call    PNTRTN          ; check if pixel is already set
5341+ 35C6 C2 7A 36             jp      NZ,EXITPA2      ; if yes, then leave PAINT
5342+ 35C9 ED 73 E8 52          ld      (ORGSP),SP      ; no, store current Stack Pointer
5343+ 35CD 21 01 00             ld      HL,$0001        ; HL=1
5344+ 35D0 22 E4 52             ld      (PNT),HL        ; set PNT
5345+ 35D3 3A DC 52             ld      A,(TMPBFR1)     ; load starting X...
5346+ 35D6 47                   ld      B,A             ; ...into B
5347+ 35D7 3A DE 52             ld      A,(TMPBFR2)     ; load starting Y...
5348+ 35DA 4F                   ld      C,A             ; ...into C
5349+ 35DB C5                   push    BC              ; store starting X,Y into stack
5350+ 35DC                      ; main loop
5351+ 35DC 2A E4 52     NXTLOOP:ld      HL,(PNT)        ; retrieve PNT
5352+ 35DF 7C                   ld      A,H             ; check if PNT=0
5353+ 35E0 B5                   or      L
5354+ 35E1 CA 76 36             jp      Z,EXITPAI       ; yes, no more points to process - exit
5355+ 35E4 2B                   dec     HL              ; no, so decrement PNT...
5356+ 35E5 22 E4 52             ld      (PNT),HL        ; ...and store it
5357+ 35E8 C1                   pop     BC              ; retrieve pixel coordinates X,Y into BC
5358+ 35E9 CD 7E 36     PAINT0: call    CHECKPA         ; check if pixel is set/reset
5359+ 35EC 20 09                jr      NZ,PAINT11      ; pixel is set, so jump over
5360+ 35EE 78                   ld      A,B             ; pixel is reset, check if X1=0
5361+ 35EF A7                   and     A               ; (reached the limit of the screen)
5362+ 35F0 CA F8 35             jp      Z,PAINT1        ; yes, jump over
5363+ 35F3 05                   dec     B               ; no, decrement X1...
5364+ 35F4 C3 E9 35             jp      PAINT0          ; ...and repeat
5365+ 35F7 04           PAINT11:inc     B               ; if found a pixel on, the re-increment X1
5366+ 35F8 AF           PAINT1: xor     A               ; reset A
5367+ 35F9 57                   ld      D,A             ; set SA=0
5368+ 35FA 5F                   ld      E,A             ; set SB=0
5369+ 35FB CD 7E 36     MNPAINT:call    CHECKPA         ; check if pixel is set/reset
5370+ 35FE 20 DC                jr      NZ,NXTLOOP      ; it's set, so goto next loop
5371+ 3600 78                   ld      A,B             ; copy X1
5372+ 3601 32 DC 52             ld      (TMPBFR1),A     ; into buffer
5373+ 3604 79                   ld      A,C             ; copy Y
5374+ 3605 32 DE 52             ld      (TMPBFR2),A     ; into buffer
5375+ 3608 CD FC 36             call    CNTPLOT         ; plot pixel X1,Y
5376+ 360B 7A                   ld      A,D             ; load SA into A
5377+ 360C A7                   and     A               ; SA=0?
5378+ 360D 20 1C                jr      NZ,PAINT2       ; no, jump over
5379+ 360F 79                   ld      A,C             ; load Y
5380+ 3610 FE 01                cp      $01             ; Y>0?
5381+ 3612 DA 2B 36             jp      C,PAINT2        ; no, jump over
5382+ 3615 3D                   dec     A               ; yes, Y=Y-1
5383+ 3616 CD 7F 36             call    CHECKPY         ; check pixel X1,Y-1
5384+ 3619 20 10                jr      NZ,PAINT2       ; it's set, so jump over
5385+ 361B 0D                   dec     C               ; Y=Y-1
5386+ 361C C5                   push    BC              ; insert pixel(X1,Y-1) into stack
5387+ 361D 0C                   inc     C               ; retrieve original Y
5388+ 361E 2A E4 52             ld      HL,(PNT)        ; load PNT
5389+ 3621 23                   inc     HL              ; increment PNT
5390+ 3622 22 E4 52             ld      (PNT),HL        ; store new PNT
5391+ 3625 3E 01                ld      A,$01           ; set SA=1 and...
5392+ 3627 57                   ld      D,A             ; ...store SA into memory
5393+ 3628 C3 3E 36             jp      PAINT3          ; jump over
5394+ 362B 7A           PAINT2: ld      A,D             ; load SA into A
5395+ 362C 1F                   rra                     ; check if SA=1
5396+ 362D 30 0F                jr      NC,PAINT3       ; no, jump over
5397+ 362F 79                   ld      A,C             ; load Y
5398+ 3630 FE 01                cp      $01             ; Y>0?
5399+ 3632 DA 3E 36             jp      C,PAINT3        ; no, jump over
5400+ 3635 3D                   dec     A               ; Y=Y-1
5401+ 3636 CD 7F 36             call    CHECKPY         ; check pixel X1,Y-1
5402+ 3639 CA 3E 36             jp      Z,PAINT3        ; if pixel is off, jump over
5403+ 363C AF                   xor     A               ; pixel is on, so...
5404+ 363D 57                   ld      D,A             ; ...set SA=0
5405+ 363E 7B           PAINT3: ld      A,E             ; check if...
5406+ 363F A7                   and     A               ; SB=0
5407+ 3640 20 1B                jr      NZ,PAINT4       ; no, jump over
5408+ 3642 79                   ld      A,C             ; load Y
5409+ 3643 FE BF                cp      $BF             ; Y<191?
5410+ 3645 30 16                jr      NC,PAINT4       ; no, jump over
5411+ 3647 3C                   inc     A               ; Y=Y+1
5412+ 3648 CD 7F 36             call    CHECKPY         ; check pixel X1,Y+1
5413+ 364B 20 10                jr      NZ,PAINT4       ; pixel is on, so jump over
5414+ 364D 0C                   inc     C               ; Y=Y+1
5415+ 364E C5                   push    BC              ; insert pixel(X1,Y+1) into stack
5416+ 364F 0D                   dec     C               ; retrieve original Y
5417+ 3650 2A E4 52             ld      HL,(PNT)        ; PNT
5418+ 3653 23                   inc     HL              ; PNT=PNT+1
5419+ 3654 22 E4 52             ld      (PNT),HL        ; store PNT
5420+ 3657 3E 01                ld      A,$01           ; SB=1
5421+ 3659 5F                   ld      E,A             ; set SB
5422+ 365A C3 6F 36             jp      PAINT5          ; jump over
5423+ 365D 7B           PAINT4: ld      A,E             ; load SB
5424+ 365E 1F                   rra                     ; check if SB=1
5425+ 365F 30 0E                jr      NC,PAINT5       ; no, jump over
5426+ 3661 79                   ld      A,C             ; load Y
5427+ 3662 FE BF                cp      $BF             ; Y<191?
5428+ 3664 30 09                jr      NC,PAINT5       ; no, jump over
5429+ 3666 3C                   inc     A               ; Y=Y+1
5430+ 3667 CD 7F 36             call    CHECKPY         ; check pixel X1,Y+1
5431+ 366A CA 6F 36             jp      Z,PAINT5        ; if pixel is off, jump over
5432+ 366D AF                   xor     A               ; pixel is on, so...
5433+ 366E 5F                   ld      E,A             ; ...set SB=0
5434+ 366F 04           PAINT5: inc     B               ; X1=X1+1
5435+ 3670 CA DC 35             jp      Z,NXTLOOP       ; if X1>255 (X1=0) then goto next loop
5436+ 3673 C3 FB 35             jp      MNPAINT         ; otherwise, repeat for next X
5437+ 3676 ED 7B E8 52  EXITPAI:ld      SP,(ORGSP)      ; retrieve original SP pointer
5438+ 367A D1           EXITPA2:pop     DE              ; retrieve DE
5439+ 367B C1                   pop     BC              ; retrieve BC
5440+ 367C E1                   pop     HL              ; retrieve HL
5441+ 367D C9                   ret                     ; return to caller
5442+ 367E 79           CHECKPA:ld      A,C             ; copy Y into A
5443+ 367F 32 DE 52     CHECKPY:ld      (TMPBFR2),A     ; store Y
5444+ 3682 78                   ld      A,B             ; copy X1 into A
5445+ 3683 32 DC 52             ld      (TMPBFR1),A     ; store X1
5446+ 3686 C5                   push    BC              ; save X1,Y
5447+ 3687 D5                   push    DE
5448+ 3688 CD D6 36             call    PNTRTN          ; check if pixel is set/reset
5449+ 368B D1                   pop     DE
5450+ 368C C1                   pop     BC              ; retrieve X1,Y
5451+ 368D C9                   ret                     ; return to caller
5452+ 368E
5453+ 368E
5454+ 368E              ; POINT(x,y): return if a pixel is set (returns color) or if it's reset (0)
5455+ 368E CD A4 34     POINT:  call    CHKG2M          ; check if in graphic mode 2
5456+ 3691 CD 8A 19             call    CHKSYN          ; make sure "(" follows
5457+ 3694 28                   defb    '('
5458+ 3695 CD DA 28             call    GETINT          ; get X coords.
5459+ 3698 32 DC 52             ld      (TMPBFR1),A     ; store it into a temp buffer
5460+ 369B CD 8A 19             call    CHKSYN          ; Make sure ',' follows
5461+ 369E 2C                   defb    ','
5462+ 369F CD DA 28             call    GETINT          ; get Y coords,
5463+ 36A2 FE C0                cp      $C0             ; check if Y is in range 0~191
5464+ 36A4 D2 96 1C             jp      NC,FCERR        ; no, raise an FC error
5465+ 36A7 32 DE 52             ld      (TMPBFR2),A     ; store into a temp buffer
5466+ 36AA CD 8A 19             call    CHKSYN          ; make sure ")" follows
5467+ 36AD 29                   defb    ')'
5468+ 36AE E5                   push    HL              ; store current string address - the point after the ")" - ...
5469+ 36AF FD E1                pop     IY              ; ...into IY
5470+ 36B1 CD D6 36             call    PNTRTN          ; check if pixel is set or reset
5471+ 36B4 20 0C                jr      NZ,CTPOINT      ; it's ON, jump over
5472+ 36B6 AF                   xor     A               ; no, it's OFF. make sure to reset A...
5473+ 36B7 47                   ld      B,A             ; ...and B
5474+ 36B8 E1           PNTEND: pop     HL              ; drop original return point
5475+ 36B9 FD E5                push    IY              ; load current string address from IY into stack
5476+ 36BB 11 3F 21             ld      DE,RETNUM       ; Address of Return number from function...
5477+ 36BE D5                   push    DE              ; ...saved on stack
5478+ 36BF C3 3E 24             jp      ABPASS          ; return AB
5479+ 36C2 CB EC        CTPOINT:set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5480+ 36C4 F3                   di
5481+ 36C5 CD 85 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5482+ 36C8 FB                   ei
5483+ 36C9 CB 3F                srl     A               ; shift A...
5484+ 36CB CB 3F                srl     A               ; ...4 times...
5485+ 36CD CB 3F                srl     A               ; ...to move foreground color...
5486+ 36CF CB 3F                srl     A               ; ...into lowest nibble
5487+ 36D1 47                   ld      B,A             ; color into B
5488+ 36D2 AF                   xor     A               ; reset MSB
5489+ 36D3 C3 B8 36             jp      PNTEND          ; return AB
5490+ 36D6 CD 49 37     PNTRTN: call    XY2HL           ; find HL address of pixel at X,Y
5491+ 36D9 57                   ld      D,A             ; store pixel index
5492+ 36DA F3                   di                      ; disable INTs
5493+ 36DB CD 85 06             call    READ_VIDEO_LOC  ; read contents of VRAM cell addressed by HL
5494+ 36DE FB                   ei                      ; re-enable INTs
5495+ 36DF A2                   and     D               ; is the pixel ON or OFF? (will be checked later)
5496+ 36E0 C9                   ret                     ; return to caller
5497+ 36E1
5498+ 36E1
5499+ 36E1              ; PLOT X,Y[,color]
5500+ 36E1              ; plot a pixel in graphic mode 2
5501+ 36E1 CD A4 34     PLOT:   call    CHKG2M          ; check if in G2 mode
5502+ 36E4 CD DA 28             call    GETINT          ; get X coords.
5503+ 36E7 32 DC 52             ld      (TMPBFR1),A     ; store it into a temp buffer
5504+ 36EA CD 8A 19             call    CHKSYN          ; Make sure ',' follows
5505+ 36ED 2C                   defb    ','
5506+ 36EE CD DA 28             call    GETINT          ; get Y coords,
5507+ 36F1 FE C0                cp      $C0             ; check if Y is in range 0~191
5508+ 36F3 D2 96 1C             jp      NC,FCERR        ; no, raise an FC error
5509+ 36F6 32 DE 52             ld      (TMPBFR2),A     ; store into a temp buffer
5510+ 36F9 CD 91 3A             call    CLRPRM          ; check if param "color" has been passed
5511+ 36FC E5           CNTPLOT:push    HL              ; store HL
5512+ 36FD C5                   push    BC              ; store BC
5513+ 36FE D5                   push    DE              ; store DE
5514+ 36FF CD 49 37             call    XY2HL           ; find VRAM address of byte containing pixel at X,Y & return into HL
5515+ 3702 D2 3D 37             jp      NC,NOGD         ; if carry is reset, there was an error -> so leave
5516+ 3705 57                   ld      D,A             ; move pixel value into D
5517+ 3706 3A E0 52             ld      A,(TMPBFR3)     ; retrieve color
5518+ 3709 A7                   and     A               ; is it 0? (background, or reset pixel)
5519+ 370A 20 11                jr      NZ,CNTPLT1      ; no, continue
5520+ 370C F3                   di                      ; yes - so, disable INTs
5521+ 370D CD 85 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5522+ 3710 FB                   ei                      ; re-enable INTs
5523+ 3711 5F                   ld      E,A             ; store value of cell
5524+ 3712 7A                   ld      A,D             ; retrieve pixel
5525+ 3713 2F                   cpl                     ; revert bits
5526+ 3714 A3                   and     E               ; set video pixel to off
5527+ 3715 F3                   di                      ; disable INTs
5528+ 3716 CD 9A 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5529+ 3719 FB                   ei                      ; re-enable INTs
5530+ 371A C3 3D 37             jp      NOGD            ; leave
5531+ 371D 87           CNTPLT1:add     A,A             ; now we move low nibble
5532+ 371E 87                   add     A,A             ; in the high nibble
5533+ 371F 87                   add     A,A             ; by adding A to itself
5534+ 3720 87                   add     A,A             ; 4 times (this is a shift left 4)
5535+ 3721 5F                   ld      E,A             ; move it into E
5536+ 3722 F3                   di                      ; disable INTs
5537+ 3723 CD 85 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5538+ 3726 FB                   ei
5539+ 3727 B2                   or      D               ; plot new pixel preserving original pattern
5540+ 3728 F3                   di
5541+ 3729 CD 9A 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5542+ 372C FB                   ei
5543+ 372D CB EC                set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5544+ 372F F3                   di
5545+ 3730 CD 85 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5546+ 3733 FB                   ei
5547+ 3734 E6 0F                and     %00001111       ; reset high nibble (the foreground color)
5548+ 3736 B3                   or      E               ; set new foreground color
5549+ 3737 F3                   di
5550+ 3738 CD 9A 06             call    WRITE_VIDEO_LOC ; write new color settings
5551+ 373B FB                   ei                      ; re-enable INTs
5552+ 373C 00                   nop                     ; wait for INTs to be enabled again
5553+ 373D D1           NOGD:   pop     DE              ; retrieve DE
5554+ 373E C1                   pop     BC              ; retrieve BC
5555+ 373F E1                   pop     HL              ; retrieve HL
5556+ 3740 C9                   ret                     ; return to caller
5557+ 3741 80 40 20 10  PXLSET: defb    $80,$40,$20,$10,$08,$04,$02,$01 ; pixel to be set ON
5557+ 3745 08 04 02 01
5558+ 3749                      ; where R(X/8)=> 0=80h, 1=40h, 2=20h, 3=10h, 4=08h, 5=04h, 6=02h, 7=$01
5559+ 3749
5560+ 3749
5561+ 3749              ; compute the VRAM address of the byte containing the pixel
5562+ 3749              ; being pointed by X,Y (TMPBFR1,TMPBFR1)
5563+ 3749              ; byte address is returned into HL
5564+ 3749              ; pixel is returned into A
5565+ 3749              XY2HL:  ; formula is: ADDRESS=(INT(X/8))*8 + (INT(Y/8))*256 + R(Y/8)
5566+ 3749                      ; where R(Y/8) is the remainder of (Y/8)
5567+ 3749                      ; the pixel to be set is given by R(X/8), and data is taken from the array
5568+ 3749 3A DE 52             ld      A,(TMPBFR2)     ; retrieve Y
5569+ 374C FE C0                cp      $C0             ; Y>=192?
5570+ 374E D0                   ret     NC              ; yes, so leave
5571+ 374F 1E 08                ld      E,$08           ; load E with divisor
5572+ 3751 57                   ld      D,A             ; and store into D (dividend)
5573+ 3752 CD C6 3F             call    DIV_8_8         ; get Y/8, D is quotient=INT(Y/8), and A is remainder
5574+ 3755 4F                   ld      C,A             ; store remainder into C
5575+ 3756 42                   ld      B,D             ; B=(INT(Y/8))*256 (we simply copy quotient into B)
5576+ 3757 60 69                ld      HL,BC           ; copy BC into HL: now HL has the VRAM address of the byte being set
5577+ 3759 3A DC 52             ld      A,(TMPBFR1)     ; retrieve X
5578+ 375C 57                   ld      D,A             ; and move it into D (dividend)
5579+ 375D CD C6 3F             call    DIV_8_8         ; get X/8, D is quotient=INT(X/8), and A is remainder
5580+ 3760 4F                   ld      C,A             ; store remainder into C
5581+ 3761 7A                   ld      A,D             ; move quotient into A
5582+ 3762 87                   add     A,A
5583+ 3763 87                   add     A,A
5584+ 3764 87                   add     A,A             ; multiply quotient by 8
5585+ 3765 5F                   ld      E,A             ; store result into E
5586+ 3766 16 00                ld      D,$00           ; reset D
5587+ 3768 19                   add     HL,DE           ; add DE to HL, getting the final VRAM address
5588+ 3769 EB                   ex      DE,HL           ; move VRAM address into DE
5589+ 376A 21 41 37             ld      HL,PXLSET       ; starting address of table for pixel to draw
5590+ 376D 06 00                ld      B,$00           ; reset B
5591+ 376F 09                   add     HL,BC           ; add C (remainder of X/8) to get address of pixel to turn on
5592+ 3770 7E                   ld      A,(HL)          ; load pixel data
5593+ 3771 EB                   ex      DE,HL           ; retrieve VRAM pattern address into HL
5594+ 3772 37                   scf                     ; set Carry for normal exit
5595+ 3773 C9                   ret                     ; return to caller
5596+ 3774
5597+ 3774
5598+ 3774              ; DRAW X1,Y1,X2,Y2[,color]
5599+ 3774              ; Draw a line using Bresenham's line algorithm from X1,Y1 to X2,Y2
5600+ 3774              ; X1,Y1 can be either less than or greater than X2,Y2 (meaning that)
5601+ 3774              ; the drawing will be ever done from X1,Y2 to X2,Y2, regardless of
5602+ 3774              ; the values. If color is not specified, the foreground color set
5603+ 3774              ; with COLOR will be used
5604+ 3774              X1      equ     TMPBFR1
5605+ 3774              Y1      equ     TMPBFR2
5606+ 3774              X2      equ     VIDEOBUFF
5607+ 3774              Y2      equ     VIDEOBUFF+$02
5608+ 3774              ER      equ     VIDEOBUFF+$04
5609+ 3774              E2      equ     VIDEOBUFF+$06
5610+ 3774              SX      equ     VIDEOBUFF+$08
5611+ 3774              SY      equ     VIDEOBUFF+$0A
5612+ 3774              DX      equ     VIDEOBUFF+$0C
5613+ 3774              DY      equ     VIDEOBUFF+$0E
5614+ 3774 CD A4 34     DRAW:   call    CHKG2M          ; check if in G2 mode
5615+ 3777 CD 79 3A             call    CLRVDBF         ; clear VIDEOBUFF
5616+ 377A CD DA 28             call    GETINT          ; get X1 coords.
5617+ 377D 32 DC 52             ld      (X1),A          ; store it into a temp buffer
5618+ 3780 CD 8A 19             call    CHKSYN          ; Make sure ',' follows
5619+ 3783 2C                   defb    ','
5620+ 3784 CD DA 28             call    GETINT          ; get Y1 coords.
5621+ 3787 FE C0                cp      $C0             ; check if Y1 is in range 0~191
5622+ 3789 D2 96 1C             jp      NC,FCERR        ; no, raise an FC error
5623+ 378C 32 DE 52             ld      (Y1),A          ; store into a temp buffer
5624+ 378F CD 8A 19             call    CHKSYN          ; Make sure ',' follows
5625+ 3792 2C                   defb    ','
5626+ 3793 CD DA 28             call    GETINT          ; get X2 coords.
5627+ 3796 32 E4 52             ld      (X2),A          ; store it into a temp buffer
5628+ 3799 CD 8A 19             call    CHKSYN          ; Make sure ',' follows
5629+ 379C 2C                   defb    ','
5630+ 379D CD DA 28             call    GETINT          ; get Y2 coords
5631+ 37A0 FE C0                cp      $C0             ; check if Y2 is in range 0~191
5632+ 37A2 D2 96 1C             jp      NC,FCERR        ; no, raise an FC error
5633+ 37A5 32 E6 52             ld      (Y2),A          ; store it into a temp buffer
5634+ 37A8 CD 91 3A             call    CLRPRM          ; check for arg. "color" and store it into TMPBFR3
5635+ 37AB E5                   push    HL              ; store register we'll use
5636+ 37AC D5                   push    DE
5637+ 37AD C5                   push    BC
5638+ 37AE ED 5B DC 52          ld      DE,(X1)         ; load X1 and
5639+ 37B2 2A E4 52             ld      HL,(X2)         ; X2
5640+ 37B5 B7                   or      A               ; clear CARRY
5641+ 37B6 ED 52                sbc     HL,DE           ; DX=X2-X1
5642+ 37B8 CD BC 3F             call    absHL           ; DX=ABS(DX)
5643+ 37BB 22 F0 52             ld      (DX),HL         ; store DX
5644+ 37BE 01 FF FF             ld      BC,$FFFF        ; SX=-1
5645+ 37C1 2A DC 52             ld      HL,(X1)
5646+ 37C4 ED 5B E4 52          ld      DE,(X2)
5647+ 37C8 CD 97 3F             call    CMP16           ; X1<X2?
5648+ 37CB CA D4 37             jp      Z,X1GR          ; no, X1=X2
5649+ 37CE F2 D4 37             jp      P,X1GR          ; no, X1>X2
5650+ 37D1 01 01 00             ld      BC,$0001        ; yes, so set SX=1
5651+ 37D4 ED 43 EC 52  X1GR:   ld      (SX),BC         ; store SX
5652+ 37D8 ED 5B DE 52          ld      DE,(Y1)
5653+ 37DC 2A E6 52             ld      HL,(Y2)
5654+ 37DF B7                   or      A               ; clear Carry
5655+ 37E0 ED 52                sbc     HL,DE           ; DY=Y2-Y1
5656+ 37E2 CD BC 3F             call    absHL           ; DY=ABS(DY)
5657+ 37E5 22 F2 52             ld      (DY),HL         ; store DY
5658+ 37E8 01 FF FF             ld      BC,$FFFF        ; SY=-1
5659+ 37EB 2A DE 52             ld      HL,(Y1)
5660+ 37EE ED 5B E6 52          ld      DE,(Y2)
5661+ 37F2 CD 97 3F             call    CMP16           ; is Y1<Y2?
5662+ 37F5 CA FE 37             jp      Z,Y1GR          ; no, Y1=Y2
5663+ 37F8 F2 FE 37             jp      P,Y1GR          ; no, Y1>Y2 - jump over
5664+ 37FB 01 01 00             ld      BC,$0001        ; yes, so set SY=1
5665+ 37FE ED 43 EE 52  Y1GR:   ld      (SY),BC         ; store SY
5666+ 3802 2A F2 52             ld      HL,(DY)         ; ER=DY
5667+ 3805 CD BF 3F             call    negHL           ; ER=-DY
5668+ 3808 22 E8 52             ld      (ER),HL         ; store ER
5669+ 380B 2A F0 52             ld      HL,(DX)
5670+ 380E ED 5B F2 52          ld      DE,(DY)
5671+ 3812 CD 97 3F             call    CMP16           ; DX>DY?
5672+ 3815 CA 21 38             jp      Z,ER2           ; no, DX=DY
5673+ 3818 FA 21 38             jp      M,ER2           ; no, DX<DY
5674+ 381B 2A F0 52             ld      HL,(DX)         ; reload DX
5675+ 381E 22 E8 52             ld      (ER),HL         ; yes: DX>DY, so ER=DX
5676+ 3821 2A E8 52     ER2:    ld      HL,(ER)         ; load ER
5677+ 3824 CB 2C                sra     H               ; right shift (and preserve sign)...
5678+ 3826 CB 1D                rr      L               ; ...of HL, so ER=INT(ER/2)
5679+ 3828 CB 7C                bit     7,H             ; is the number negative?
5680+ 382A CA 2E 38             jp      Z,STRE2         ; no, jump over
5681+ 382D 23                   inc     HL              ; yes, add 1 'cos INT of a negative number needs to be incremented
5682+ 382E 22 E8 52     STRE2:  ld      (ER),HL         ; store ER
5683+ 3831 CD FC 36     RPTDRW: call    CNTPLOT         ; plot first pixel
5684+ 3834 2A DC 52             ld      HL,(X1)
5685+ 3837 ED 5B E4 52          ld      DE,(X2)
5686+ 383B CD 97 3F             call    CMP16           ; X1=X2?
5687+ 383E 20 0D                jr      NZ,CNTDRW       ; no, continue drawing
5688+ 3840 2A DE 52             ld      HL,(Y1)         ; yes, so check
5689+ 3843 ED 5B E6 52          ld      DE,(Y2)         ; also Y
5690+ 3847 CD 97 3F             call    CMP16           ; Y1=Y2?
5691+ 384A CA A6 38             jp      Z,ENDDRAW       ; yes, finished drawing: exit
5692+ 384D ED 5B E8 52  CNTDRW: ld      DE,(ER)
5693+ 3851 ED 53 EA 52          ld      (E2),DE         ; E2=ER
5694+ 3855 2A F0 52             ld      HL,(DX)
5695+ 3858 CD BF 3F             call    negHL           ; DX=-DX
5696+ 385B EB                   ex      DE,HL           ; invert DE and HL => HL=E2, DE=-DX
5697+ 385C CD 97 3F             call    CMP16           ; E2>-DX?
5698+ 385F CA 7D 38             jp      Z,DXGR          ; no, E2=-DX: jump
5699+ 3862 FA 7D 38             jp      M,DXGR          ; no, E2<-DX: jump
5700+ 3865 2A E8 52             ld      HL,(ER)         ; yes
5701+ 3868 ED 5B F2 52          ld      DE,(DY)
5702+ 386C B7                   or      A               ; clear CARRY
5703+ 386D ED 52                sbc     HL,DE           ; ER=ER-DY
5704+ 386F 22 E8 52             ld      (ER),HL
5705+ 3872 2A DC 52             ld      HL,(X1)
5706+ 3875 ED 5B EC 52          ld      DE,(SX)
5707+ 3879 19                   add     HL,DE           ; X1=X1+SX (increment X1)
5708+ 387A 22 DC 52             ld      (X1),HL
5709+ 387D 2A EA 52     DXGR:   ld      HL,(E2)
5710+ 3880 ED 5B F2 52          ld      DE,(DY)
5711+ 3884 CD 97 3F             call    CMP16           ; E2<DY?
5712+ 3887 CA 31 38             jp      Z,RPTDRW        ; no, E2=DY: jump
5713+ 388A F2 31 38             jp      P,RPTDRW        ; no, E2>DY: jump
5714+ 388D 2A E8 52             ld      HL,(ER)         ; yes
5715+ 3890 ED 5B F0 52          ld      DE,(DX)
5716+ 3894 19                   add     HL,DE           ; ER=ER+DX
5717+ 3895 22 E8 52             ld      (ER),HL
5718+ 3898 2A DE 52             ld      HL,(Y1)
5719+ 389B ED 5B EE 52          ld      DE,(SY)
5720+ 389F 19                   add     HL,DE           ; Y1=Y1+SY (increment Y1)
5721+ 38A0 22 DE 52             ld      (Y1),HL
5722+ 38A3 C3 31 38             jp      RPTDRW          ; repeat
5723+ 38A6 C1           ENDDRAW:pop     BC              ; retrieve BC
5724+ 38A7 D1                   pop     DE              ; retrieve DE
5725+ 38A8 E1                   pop     HL              ; retrieve HL
5726+ 38A9 C9                   ret                     ; return to caller
5727+ 38AA
5728+ 38AA
5729+ 38AA              ; CIRCLE X,Y,R[,C]
5730+ 38AA              ; Draw a circle using Bresenham's circle algorithm with center in X,Y
5731+ 38AA              ; and radius R, with optional color C. If color is not specified, the
5732+ 38AA              ; foreground color set with COLOR will be used
5733+ 38AA              XC      equ     VIDEOBUFF
5734+ 38AA              YC      equ     VIDEOBUFF+$02
5735+ 38AA              RADIUS  equ     VIDEOBUFF+$04
5736+ 38AA              XI      equ     VIDEOBUFF+$06
5737+ 38AA              YI      equ     VIDEOBUFF+$08
5738+ 38AA              DC      equ     VIDEOBUFF+$0A
5739+ 38AA CD A4 34     CIRCLE: call    CHKG2M          ; check if in G2 mode
5740+ 38AD CD 79 3A             call    CLRVDBF         ; clear VIDEOBUFF
5741+ 38B0 CD DA 28             call    GETINT          ; get X coords.
5742+ 38B3 32 E4 52             ld      (XC),A          ; store it into a temp buffer
5743+ 38B6 CD 8A 19             call    CHKSYN          ; Make sure ',' follows
5744+ 38B9 2C                   defb    ','
5745+ 38BA CD DA 28             call    GETINT          ; get Y coords,
5746+ 38BD 32 E6 52             ld      (YC),A          ; store it into a temp buffer
5747+ 38C0 CD 8A 19             call    CHKSYN          ; Make sure ',' follows
5748+ 38C3 2C                   defb    ','
5749+ 38C4 CD DA 28             call    GETINT          ; get radius
5750+ 38C7 32 E8 52             ld      (RADIUS),A      ; store it into a temp buffer
5751+ 38CA CD 91 3A             call    CLRPRM          ; check if param "color" has been passed
5752+ 38CD C5                   push    BC              ; store BC
5753+ 38CE D5                   push    DE              ; store DE
5754+ 38CF E5                   push    HL              ; store HL
5755+ 38D0 AF                   xor     A               ; clear A,
5756+ 38D1 47                   ld      B,A             ; B,
5757+ 38D2 4F                   ld      C,A             ; C,
5758+ 38D3 57                   ld      D,A             ; D,
5759+ 38D4 67                   ld      H,A             ; and H
5760+ 38D5 ED 43 EA 52          ld      (XI),BC         ; clear XI
5761+ 38D9 3A E8 52             ld      A,(RADIUS)      ; load RADIUS into A
5762+ 38DC 6F                   ld      L,A             ; HL now contains R
5763+ 38DD 22 EC 52             ld      (YI),HL         ; YI=RADIUS
5764+ 38E0 29                   add     HL,HL           ; R*2
5765+ 38E1 EB                   ex      DE,HL           ; put HL into DE
5766+ 38E2 21 03 00             ld      HL,$0003        ; now HL is 3
5767+ 38E5 AF                   xor     A               ; clear Carry
5768+ 38E6 ED 52                sbc     HL,DE           ; HL=>D=3-(2*R)
5769+ 38E8 22 EE 52             ld      (DC),HL         ; store D
5770+ 38EB CD 4A 39             call    DRWCRL          ; draw initial point
5771+ 38EE ED 5B EA 52  RPTCRL: ld      DE,(XI)         ; load XI
5772+ 38F2 2A EC 52             ld      HL,(YI)         ; load YI
5773+ 38F5 CD 97 3F             call    CMP16           ; is YI<DI?
5774+ 38F8 CA 01 39             jp      Z,RPTCL1        ; no, YI=XI
5775+ 38FB F2 01 39             jp      P,RPTCL1        ; no, YI>XI
5776+ 38FE C3 46 39             jp      ENDCRL          ; yes, so we've finished
5777+ 3901 21 EA 52     RPTCL1: ld      HL,XI
5778+ 3904 34                   inc     (HL)            ; XI=XI+1
5779+ 3905 2A EE 52             ld      HL,(DC)         ; load D
5780+ 3908 7C                   ld      A,H
5781+ 3909 B5                   or      L               ; is D=0? Yes, jump over
5782+ 390A CA 2E 39             jp      Z,DLSZ
5783+ 390D CB 7C                bit     7,H             ; is D<0?
5784+ 390F 20 1D                jr      NZ,DLSZ         ; yes, jump over
5785+ 3911 ED 5B EC 52          ld      DE,(YI)         ; D>0
5786+ 3915 1B                   dec     DE              ; so, YI=YI-1
5787+ 3916 ED 53 EC 52          ld      (YI),DE         ; store YI
5788+ 391A AF                   xor     A               ; clear Carry
5789+ 391B 2A EA 52             ld      HL,(XI)
5790+ 391E ED 52                sbc     HL,DE           ; HL=XI-YI
5791+ 3920 29                   add     HL,HL
5792+ 3921 29                   add     HL,HL           ; HL=HL*4
5793+ 3922 11 0A 00             ld      DE,10
5794+ 3925 19                   add     HL,DE           ; HL=HL+10
5795+ 3926 ED 5B EE 52          ld      DE,(DC)         ; load D
5796+ 392A EB                   ex      DE,HL           ; invert DE and HL, so that HL=4*(XI-YI)+10 and DE=D
5797+ 392B 19                   add     HL,DE           ; D=D+4*(XI-YI)+10
5798+ 392C 18 0F                jr      PLTCRL          ; plot next pixel
5799+ 392E 2A EA 52     DLSZ:   ld      HL,(XI)         ; load XI
5800+ 3931 29                   add     HL,HL
5801+ 3932 29                   add     HL,HL           ; XI=XI*4
5802+ 3933 11 06 00             ld      DE,$0006
5803+ 3936 19                   add     HL,DE
5804+ 3937 ED 5B EE 52          ld      DE,(DC)
5805+ 393B EB                   ex      DE,HL           ; HL=D and DE=4*XI+6
5806+ 393C 19                   add     HL,DE           ; D=D+4*XI+6
5807+ 393D 22 EE 52     PLTCRL: ld      (DC),HL         ; store new D
5808+ 3940 CD 4A 39             call    DRWCRL          ; plot pixel
5809+ 3943 C3 EE 38             jp      RPTCRL          ; repeat
5810+ 3946 E1           ENDCRL: pop     HL
5811+ 3947 D1                   pop     DE
5812+ 3948 C1                   pop     BC
5813+ 3949 C9                   ret                     ; return to caller
5814+ 394A 2A E4 52     DRWCRL: ld      HL,(XC)
5815+ 394D ED 5B EA 52          ld      DE,(XI)
5816+ 3951 19                   add     HL,DE           ; X=XC+XI
5817+ 3952 22 DC 52             ld      (X1),HL         ; store X
5818+ 3955 CD 69 3A             call    VALIDX          ; check if X is valid (0~255)
5819+ 3958 DA 6C 39             jp      C,CNTCL1        ; if Carry is set, X is not valid
5820+ 395B 2A E6 52             ld      HL,(YC)
5821+ 395E ED 5B EC 52          ld      DE,(YI)
5822+ 3962 19                   add     HL,DE           ; Y=YC+YI
5823+ 3963 22 DE 52             ld      (Y1),HL         ; store Y
5824+ 3966 CD 6E 3A             call    VALIDY          ; check if Y is valid (0~191)
5825+ 3969 D4 FC 36             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5826+ 396C AF           CNTCL1: xor     A               ; clear Carry
5827+ 396D 2A E4 52             ld      HL,(XC)
5828+ 3970 ED 5B EA 52          ld      DE,(XI)
5829+ 3974 ED 52                sbc     HL,DE           ; X=XC-XI
5830+ 3976 22 DC 52             ld      (X1),HL         ; store X
5831+ 3979 CD 69 3A             call    VALIDX          ; check if X is valid (0~255)
5832+ 397C DA 90 39             jp      C,CNTCL2        ; if Carry is set, X is not valid
5833+ 397F 2A E6 52             ld      HL,(YC)
5834+ 3982 ED 5B EC 52          ld      DE,(YI)
5835+ 3986 19                   add     HL,DE           ; Y=YC+YI
5836+ 3987 22 DE 52             ld      (Y1),HL         ; store Y
5837+ 398A CD 6E 3A             call    VALIDY          ; check if Y is valid (0~191)
5838+ 398D D4 FC 36             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5839+ 3990 2A E4 52     CNTCL2: ld      HL,(XC)
5840+ 3993 ED 5B EA 52          ld      DE,(XI)
5841+ 3997 19                   add     HL,DE           ; X=XC+XI
5842+ 3998 22 DC 52             ld      (X1),HL         ; store X
5843+ 399B CD 69 3A             call    VALIDX          ; check if X is valid (0~255)
5844+ 399E DA B4 39             jp      C,CNTCL3        ; if Carry is set, X is not valid
5845+ 39A1 AF                   xor     A               ; clear Carry
5846+ 39A2 2A E6 52             ld      HL,(YC)
5847+ 39A5 ED 5B EC 52          ld      DE,(YI)
5848+ 39A9 ED 52                sbc     HL,DE           ; Y=YC-YI
5849+ 39AB 22 DE 52             ld      (Y1),HL         ; store Y
5850+ 39AE CD 6E 3A             call    VALIDY          ; check if Y is valid (0~191)
5851+ 39B1 D4 FC 36             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5852+ 39B4 AF           CNTCL3: xor     A               ; clear Carry
5853+ 39B5 2A E4 52             ld      HL,(XC)
5854+ 39B8 ED 5B EA 52          ld      DE,(XI)
5855+ 39BC ED 52                sbc     HL,DE           ; X=XC-XI
5856+ 39BE 22 DC 52             ld      (X1),HL         ; store X
5857+ 39C1 CD 69 3A             call    VALIDX          ; check if X is valid (0~255)
5858+ 39C4 DA DA 39             jp      C,CNTCL4        ; if Carry is set, X is not valid
5859+ 39C7 AF                   xor     A               ; clear Carry
5860+ 39C8 2A E6 52             ld      HL,(YC)
5861+ 39CB ED 5B EC 52          ld      DE,(YI)
5862+ 39CF ED 52                sbc     HL,DE           ; Y=YC-YI
5863+ 39D1 22 DE 52             ld      (Y1),HL         ; store Y
5864+ 39D4 CD 6E 3A             call    VALIDY          ; check if Y is valid (0~191)
5865+ 39D7 D4 FC 36             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5866+ 39DA 2A E4 52     CNTCL4: ld      HL,(XC)
5867+ 39DD ED 5B EC 52          ld      DE,(YI)
5868+ 39E1 19                   add     HL,DE           ; X=XC+YI
5869+ 39E2 22 DC 52             ld      (X1),HL         ; store X
5870+ 39E5 CD 69 3A             call    VALIDX          ; check if X is valid (0~255)
5871+ 39E8 DA FC 39             jp      C,CNTCL5        ; if Carry is set, X is not valid
5872+ 39EB 2A E6 52             ld      HL,(YC)
5873+ 39EE ED 5B EA 52          ld      DE,(XI)
5874+ 39F2 19                   add     HL,DE           ; Y=YC+XI
5875+ 39F3 22 DE 52             ld      (Y1),HL         ; store Y
5876+ 39F6 CD 6E 3A             call    VALIDY          ; check if Y is valid (0~191)
5877+ 39F9 D4 FC 36             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5878+ 39FC AF           CNTCL5: xor     A               ; clear Carry
5879+ 39FD 2A E4 52             ld      HL,(XC)
5880+ 3A00 ED 5B EC 52          ld      DE,(YI)
5881+ 3A04 ED 52                sbc     HL,DE           ; X=XC-YI
5882+ 3A06 22 DC 52             ld      (X1),HL         ; store X
5883+ 3A09 CD 69 3A             call    VALIDX          ; check if X is valid (0~255)
5884+ 3A0C DA 20 3A             jp      C,CNTCL6        ; if Carry is set, X is not valid
5885+ 3A0F 2A E6 52             ld      HL,(YC)
5886+ 3A12 ED 5B EA 52          ld      DE,(XI)
5887+ 3A16 19                   add     HL,DE           ; Y=YC+XI
5888+ 3A17 22 DE 52             ld      (Y1),HL         ; store Y
5889+ 3A1A CD 6E 3A             call    VALIDY          ; check if Y is valid (0~191)
5890+ 3A1D D4 FC 36             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5891+ 3A20 2A E4 52     CNTCL6: ld      HL,(XC)
5892+ 3A23 ED 5B EC 52          ld      DE,(YI)
5893+ 3A27 19                   add     HL,DE           ; X=XC+YI
5894+ 3A28 22 DC 52             ld      (X1),HL         ; store X
5895+ 3A2B CD 69 3A             call    VALIDX          ; check if X is valid (0~255)
5896+ 3A2E DA 44 3A             jp      C,CNTCL7        ; if Carry is set, X is not valid
5897+ 3A31 AF                   xor     A               ; clear Carry
5898+ 3A32 2A E6 52             ld      HL,(YC)
5899+ 3A35 ED 5B EA 52          ld      DE,(XI)
5900+ 3A39 ED 52                sbc     HL,DE           ; Y=YC-XI
5901+ 3A3B 22 DE 52             ld      (Y1),HL         ; store Y
5902+ 3A3E CD 6E 3A             call    VALIDY          ; check if Y is valid (0~191)
5903+ 3A41 D4 FC 36             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5904+ 3A44 AF           CNTCL7: xor     A               ; clear Carry
5905+ 3A45 2A E4 52             ld      HL,(XC)
5906+ 3A48 ED 5B EC 52          ld      DE,(YI)
5907+ 3A4C ED 52                sbc     HL,DE           ; X=XC-YI
5908+ 3A4E 22 DC 52             ld      (X1),HL         ; store X
5909+ 3A51 CD 69 3A             call    VALIDX          ; check if X is valid (0~255)
5910+ 3A54 D8                   ret     C               ; if Carry is set, X is not valid
5911+ 3A55 AF                   xor     A               ; clear Carry
5912+ 3A56 2A E6 52             ld      HL,(YC)
5913+ 3A59 ED 5B EA 52          ld      DE,(XI)
5914+ 3A5D ED 52                sbc     HL,DE           ; Y=YC-XI
5915+ 3A5F 22 DE 52             ld      (Y1),HL         ; store Y
5916+ 3A62 CD 6E 3A             call    VALIDY          ; check if Y is valid (0~191)
5917+ 3A65 D4 FC 36             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5918+ 3A68 C9                   ret                     ; return to caller
5919+ 3A69
5920+ 3A69              ; check if X,Y coordinates are valid: 0<=X<=255 and 0<=Y<=191
5921+ 3A69              ; input: HL (value to check), can be negative
5922+ 3A69              ; output: CARRY flag: reset => VALID  //  set => NOT VALID
5923+ 3A69              ; destroys: A
5924+ 3A69 AF           VALIDX: xor     A               ; reset A
5925+ 3A6A B4                   or      H               ; check if H is 0 (this means that X is in range 0~255 and not negative)
5926+ 3A6B C8                   ret     Z               ; yes, we can return (C is clear)
5927+ 3A6C 37                   scf                     ; set Carry flag to raise error
5928+ 3A6D C9                   ret                     ; return to caller
5929+ 3A6E
5930+ 3A6E AF           VALIDY: xor     A               ; reset A
5931+ 3A6F B4                   or      H               ; check if H is 0 (this means that Y is in range 0~255 and not negative)
5932+ 3A70 28 02                jr      Z,CNTVALY       ; yes, continue checking
5933+ 3A72 37                   scf                     ; no, raise error by setting Carry flag
5934+ 3A73 C9                   ret                     ; return to caller
5935+ 3A74 7D           CNTVALY:ld      A,L
5936+ 3A75 FE C0                cp      $C0             ; is Y<192? Carry is set if Y<192
5937+ 3A77 3F                   ccf                     ; invert Carry, so Carry=0 means OK, Carry=1 means ERROR
5938+ 3A78 C9                   ret                     ; return to caller
5939+ 3A79
5940+ 3A79
5941+ 3A79              ; clear VIDEOBUFF before using it as temp buffer
5942+ 3A79 AF           CLRVDBF:xor     A               ; clear A
5943+ 3A7A C5                   push    BC              ; store BC
5944+ 3A7B E5                   push    HL              ; store HL
5945+ 3A7C 21 DC 52             ld      HL,TMPBFR1      ; address of 1st cell
5946+ 3A7F 06 06                ld      B,$06           ; 6 cells
5947+ 3A81 77           RPTCVB1:ld      (HL),A          ; clear cell
5948+ 3A82 23                   inc     HL              ; next cell
5949+ 3A83 10 FC                djnz    RPTCVB1         ; repeat
5950+ 3A85 06 28                ld      B,$28           ; 40 cells
5951+ 3A87 21 E4 52             ld      HL,VIDEOBUFF    ; address of 1st cell
5952+ 3A8A 77           RPTCVB2:ld      (HL),A          ; clear cell
5953+ 3A8B 23                   inc     HL              ; next cell
5954+ 3A8C 10 FC                djnz    RPTCVB2         ; repeat
5955+ 3A8E E1                   pop     HL              ; retrieve HL
5956+ 3A8F C1                   pop     BC              ; retrieve BC
5957+ 3A90 C9                   ret                     ; return to caller
5958+ 3A91
5959+ 3A91
5960+ 3A91              ; check if a color is passed as argument with PLOT, DRAW, and CIRCLE
5961+ 3A91              ; commands. If not present, the default foreground color will be used
5962+ 3A91 3A DA 52     CLRPRM: ld      A,(FRGNDCLR)    ; load foreground color
5963+ 3A94 32 E0 52             ld      (TMPBFR3),A     ; store into temp buffer
5964+ 3A97 2B                   dec     HL              ; dec 'cos GETCHR INCs
5965+ 3A98 CD CB 1B             call    GETCHR          ; Get next character
5966+ 3A9B C8                   ret     Z               ; return foreground color if nothing follows
5967+ 3A9C CD 8A 19             call    CHKSYN          ; Make sure ',' follows
5968+ 3A9F 2C                   defb    ','
5969+ 3AA0 CD DA 28             call    GETINT          ; get value
5970+ 3AA3 CD 9E 34             call    CHKCLR0         ; check if color is in range 0~15
5971+ 3AA6 32 E0 52             ld      (TMPBFR3),A     ; store color into temp buffer
5972+ 3AA9 C9                   ret                     ; return to caller
5973+ 3AAA
5974+ 3AAA
5975+ 3AAA              ; no graphics mode error: raised when a graphics command is invoked
5976+ 3AAA              ; out of graphic 2 mode.
5977+ 3AAA 1E 2A        GMERR:  ld      E,GM            ; load Graphics Mode Error flag
5978+ 3AAC C3 BC 16             jp      ERROR           ; print error
5979+ 3AAF
5980+ 3AAF
5981+ 3AAF              ; set a serial port: params are PORT,BPS,DATA,PARITY,STOP
5982+ 3AAF              ; PORT=1/2; BPS=1,200~57,600 (see below), DATA=5/6/7/8
5983+ 3AAF              ; PARITY: 0=no parity; 1=ODD parity; 2=EVEN parity;
5984+ 3AAF              ; STOP=0/1/2/3: 0=0 bit; 1=1 bit; 2=1.5 bits; 3=2 bits
5985+ 3AAF              ; PORT 1 acts as a char device; PORT 2 acts as a block device
5986+ 3AAF              ; DATA,PARITY, and STOP are optional: if nothing follows BPS,
5987+ 3AAF              ; they are assumed to be 8,0,1 resp.
5988+ 3AAF              PRTNUM  equ     VIDEOBUFF
5989+ 3AAF              BPS     equ     VIDEOBUFF+$01
5990+ 3AAF              DATABT  equ     BPS+$02
5991+ 3AAF              PARBT   equ     DATABT+$01
5992+ 3AAF              STPBT   equ     PARBT+$01
5993+ 3AAF              SIOBFR  equ     STPBT+$01
5994+ 3AAF CD DA 28     SERIAL: call    GETINT          ; get port #
5995+ 3AB2 A7                   and     A               ; is it zero?
5996+ 3AB3 CA 96 1C             jp      Z,FCERR         ; yes, error
5997+ 3AB6 FE 03                cp      $03             ; is it 1 or 2?
5998+ 3AB8 D2 D8 3C             jp      NC,SCERR        ; no, error
5999+ 3ABB 32 E4 52             ld      (PRTNUM),A      ; store port number into a temp buffer
6000+ 3ABE CD 8A 19             call    CHKSYN          ; Make sure ',' follows
6001+ 3AC1 2C                   defb    ','
6002+ 3AC2 2B                   dec     HL
6003+ 3AC3 CD CB 1B             call    GETCHR          ; check what's following
6004+ 3AC6 CA A8 16             jp      Z,SNERR         ; error if nothing follows
6005+ 3AC9 30 05                jr      NC,SERVAR       ; it's not a number, try a variable
6006+ 3ACB CD 9B 1C             call    ATOH            ; get bps (returned into DE)
6007+ 3ACE 18 0F                jr      CHKZSER         ; jump over
6008+ 3AD0 CD 54 20     SERVAR: call    GETNUM          ; get number
6009+ 3AD3 CD 61 2E             call    TSTSGN          ; check value
6010+ 3AD6 FA 96 1C             jp      M,FCERR         ; negative - illegal function call
6011+ 3AD9 3A 33 53             ld      A,(FPEXP)       ; Get integer value to DE
6012+ 3ADC CD 09 2F             call    FPINT           ; get integer number into BCDE - drop BC 'cause isn't necessary
6013+ 3ADF 7A           CHKZSER:ld      A,D             ; bps is into DE - move MSB into A
6014+ 3AE0 B3                   or      E               ; check if bps=0
6015+ 3AE1 20 3A                jr      NZ,CNTSER       ; no, continue checking
6016+ 3AE3                      ; if baud rate is 0, then close the serial comm.
6017+ 3AE3 3A E4 52     RSTSERS:ld      A,(PRTNUM)      ; yes, so reset the channel. First, load port number
6018+ 3AE6 3D                   dec     A               ; subtract 1, so that serial channel is 0=>A and 1=>B
6019+ 3AE7 C6 22                add     SIO_CA          ; find correct channel
6020+ 3AE9 4F                   ld      C,A             ; store serial channel
6021+ 3AEA F3                   di                      ; disable INTs
6022+ 3AEB AF                   xor     A               ; reset A
6023+ 3AEC 16 01                ld      D,$01           ; start from WR1
6024+ 3AEE 06 05                ld      B,$05           ; 5 registers
6025+ 3AF0 ED 51        RPTRSSR:out     (C),D           ; select register
6026+ 3AF2 ED 79                out     (C),A           ; reset register
6027+ 3AF4 14                   inc     D               ; next register
6028+ 3AF5 10 F9                djnz    RPTRSSR         ; repeat
6029+ 3AF7 3E 30                ld      A,%00110000     ; write into WR0: error reset, select WR0
6030+ 3AF9 ED 79                out     (C),A           ; send command to serial channel
6031+ 3AFB 3E 18                ld      A,%00011000     ; write into WR0: channel reset
6032+ 3AFD ED 79                out     (C),A           ; send command to serial channel
6033+ 3AFF FB                   ei                      ; re-enable INTs
6034+ 3B00 E5                   push    HL              ; store HL
6035+ 3B01 21 1E 53             ld      HL,SERIALS_EN   ; serials enabled status byte
6036+ 3B04 DB 01                in      A,(PIO_DB)      ; read status LEDs
6037+ 3B06 CB 41                bit     0,C             ; check serial port
6038+ 3B08 20 09                jr      NZ,SRPT2        ; if bit is set, jump to port 2
6039+ 3B0A CB B7                res     6,A             ; it's port 1
6040+ 3B0C CB A7                res     4,A             ; remove possible error LED
6041+ 3B0E CB 86                res     0,(HL)          ; disable port 1
6042+ 3B10 C3 19 3B             jp      SERLED          ; jump over
6043+ 3B13 CB BF        SRPT2:  res     7,A             ; it's port 2
6044+ 3B15 CB AF                res     5,A             ; remove possible error LED
6045+ 3B17 CB 8E                res     1,(HL)          ; disable port 2
6046+ 3B19 D3 01        SERLED: out     (PIO_DB),A      ; send new configuration
6047+ 3B1B E1                   pop     HL              ; retrieve HL
6048+ 3B1C C9                   ret                     ; return to caller
6049+ 3B1D                      ; check if bps=1, meaning reactivate RX on serial
6050+ 3B1D 7A           CNTSER: ld      A,D
6051+ 3B1E B2                   or      D               ; check if bps<>1 by first checking D=0
6052+ 3B1F 20 36                jr      NZ,CNTSER2      ; if not, jump over
6053+ 3B21 7B                   ld      A,E             ; then by checking that
6054+ 3B22 FE 01                cp      $01             ; E=1
6055+ 3B24 20 31                jr      NZ,CNTSER2      ; if not, jump over
6056+ 3B26 3A E4 52             ld      A,(PRTNUM)      ; load port number
6057+ 3B29 57                   ld      D,A             ; store port on D
6058+ 3B2A 3A 1E 53             ld      A,(SERIALS_EN)  ; load address of serial status cell
6059+ 3B2D A2                   and     D               ; check status
6060+ 3B2E CA D8 3C             jp      Z,SCERR         ; port not open, raise error
6061+ 3B31 F3                   di                      ; disable INTs
6062+ 3B32 7A                   ld      A,D             ; move port # into A
6063+ 3B33 5F                   ld      E,A             ; and also into E
6064+ 3B34 87                   add     A
6065+ 3B35 87                   add     A               ; move A to left times 2
6066+ 3B36 57                   ld      D,A             ; move value into D
6067+ 3B37 3A 1E 53             ld      A,(SERIALS_EN)  ; load serial status byte
6068+ 3B3A B2                   or      D               ; re-enable RX
6069+ 3B3B 32 1E 53             ld      (SERIALS_EN),A  ; store new serial status
6070+ 3B3E 7B                   ld      A,E             ; recover port #
6071+ 3B3F 3D                   dec     A               ; check port
6072+ 3B40 20 0A                jr      NZ,CNTRX2       ; port is #2
6073+ 3B42 CD DA 01             call    SIO_A_EI        ; re-enable RX on port 1
6074+ 3B45 DB 01                in      A,(PIO_DB)      ; load status LEDs
6075+ 3B47 CB A7                res     4,A             ; remove error LED
6076+ 3B49 C3 53 3B             jp      RXEND           ; terminate setting
6077+ 3B4C CD E2 01     CNTRX2: call    SIO_B_EI        ; re-enable RX on port 2
6078+ 3B4F DB 01                in      A,(PIO_DB)      ; load status LEDs
6079+ 3B51 CB AF                res     5,A             ; remove error LED
6080+ 3B53 D3 01        RXEND:  out     (PIO_DB),A      ; set new status for LEDs
6081+ 3B55 FB                   ei                      ; re-enable INTs
6082+ 3B56 C9                   ret                     ; return to caller
6083+ 3B57                      ; set serial port comm.
6084+ 3B57 D5           CNTSER2:push    DE              ; store BPS
6085+ 3B58 3A E4 52             ld      A,(PRTNUM)      ; load port number
6086+ 3B5B 57                   ld      D,A             ; move port # into D
6087+ 3B5C 3A 1E 53             ld      A,(SERIALS_EN)  ; check if serial port is already open
6088+ 3B5F A2                   and     D               ; by ANDing A with D
6089+ 3B60 D1                   pop     DE              ; retrieve BPS
6090+ 3B61 CA 69 3B             jp      Z,CNTSER3       ; not open, continue
6091+ 3B64 1E 2E                ld      E,SA            ; already open, so raise a "Serial Port Already Error"
6092+ 3B66 C3 BC 16             jp      ERROR           ; and leave
6093+ 3B69 E5           CNTSER3:push    HL              ; store HL
6094+ 3B6A 21 00 E1             ld      HL,$E100        ; check bps. start with HL=57,600
6095+ 3B6D CD 97 3F             call    CMP16           ; is bps<=57,600?
6096+ 3B70 E1                   pop     HL              ; but first, recover HL
6097+ 3B71 DA D8 3C             jp      C,SCERR         ; no (bps>57,600) then error
6098+ 3B74 ED 53 E5 52          ld      (BPS),DE        ; store bps
6099+ 3B78 2B                   dec     HL              ; dec 'cos GETCHR INCs
6100+ 3B79 CD CB 1B             call    GETCHR          ; Get next character
6101+ 3B7C CA B4 3B             jp      Z,DEFSER        ; defaults if nothing follows
6102+ 3B7F CD 8A 19             call    CHKSYN          ; Make sure ',' follows
6103+ 3B82 2C                   defb    ','
6104+ 3B83 CD DA 28             call    GETINT          ; get data bits
6105+ 3B86 FE 05                cp      $05             ; is it <5?
6106+ 3B88 DA D8 3C             jp      C,SCERR         ; yes, error
6107+ 3B8B FE 09                cp      $09             ; is it >=9?
6108+ 3B8D D2 96 1C             jp      NC,FCERR        ; yes, error
6109+ 3B90 32 E7 52             ld      (DATABT),A      ; store data bits
6110+ 3B93 CD 8A 19             call    CHKSYN          ; Make sure ',' follows
6111+ 3B96 2C                   defb    ','
6112+ 3B97 CD DA 28             call    GETINT          ; get parity bits
6113+ 3B9A BF FE 03             cp      A,$03           ; check if parity is in range 0~2
6114+ 3B9D D2 D8 3C             jp      NC,SCERR        ; no, error
6115+ 3BA0 32 E8 52             ld      (PARBT),A       ; store parity
6116+ 3BA3 CD 8A 19             call    CHKSYN          ; Make sure ',' follows
6117+ 3BA6 2C                   defb    ','
6118+ 3BA7 CD DA 28             call    GETINT          ; get stop bits
6119+ 3BAA FE 03                cp      $03             ; is it >=3?
6120+ 3BAC D2 D8 3C             jp      NC,SCERR        ; yes, error
6121+ 3BAF 32 E9 52             ld      (STPBT),A       ; store stop bits
6122+ 3BB2 18 0D                jr      SETSER          ; jump to set serial
6123+ 3BB4 3E 08        DEFSER: ld      A,$08           ; 8 bits for data
6124+ 3BB6 32 E7 52             ld      (DATABT),A
6125+ 3BB9 AF                   xor     A               ; no parity bit
6126+ 3BBA 32 E8 52             ld      (PARBT),A
6127+ 3BBD 3C                   inc     A               ; 1 bit for stop
6128+ 3BBE 32 E9 52             ld      (STPBT),A
6129+ 3BC1                      ; check if bps are legal
6130+ 3BC1 E5           SETSER: push    HL              ; store HL
6131+ 3BC2 D5                   push    DE              ; store DE
6132+ 3BC3 DD E5                push    IX              ; store IX
6133+ 3BC5 DD 21 B3 3C          ld      IX,SUP_BPS      ; allowed BPSs
6134+ 3BC9 06 0B                ld      B,$0B           ; 11 items
6135+ 3BCB 0E 00                ld      C,$00           ; reset pointer
6136+ 3BCD 2A E5 52     CKBPS:  ld      HL,(BPS)        ; load BPS
6137+ 3BD0 DD 5E 00             ld      E,(IX+0)        ; load LSB of item
6138+ 3BD3 DD 56 01             ld      D,(IX+1)        ; load MSB of item
6139+ 3BD6 CD 97 3F             call    CMP16           ; is it equal?
6140+ 3BD9 CA E6 3B             jp      Z,SET_PT        ; yes, found a correspondance
6141+ 3BDC DD 23                inc     IX
6142+ 3BDE DD 23                inc     IX              ; no, go to next entry
6143+ 3BE0 0C                   inc     C               ; increment pointer
6144+ 3BE1 10 EA                djnz    CKBPS           ; repeat for 10 entries
6145+ 3BE3 C3 D4 3C             jp      SCERR1          ; if nothing found, raise an error
6146+ 3BE6              SET_PT: ;init CTC CH0: CH0 provides RX/TX clock to SIO port A
6147+ 3BE6                      ; TO0 output frequency=INPUT CLK/time constant. Time constant is set to get 16 times
6148+ 3BE6                      ; the requested baud rate. I.e., if bps is 19,200 then time constast is set to 6 because
6149+ 3BE6                      ; 1,843,200/6 = 307,200 Hz (that is 19,200 x 16)
6150+ 3BE6 F3                   di                      ; disable INTs
6151+ 3BE7 06 00                ld      B,$00           ; reset B
6152+ 3BE9 21 C9 3C             ld      HL,CTC_CFG      ; address of first CTC divider
6153+ 3BEC 09                   add     HL,BC           ; adjust for correct CTC divider
6154+ 3BED 0E 10                ld      C,CTC_CH0       ; CTC channel 0
6155+ 3BEF 3A E4 52             ld      A,(PRTNUM)      ; load port number
6156+ 3BF2 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6157+ 3BF3 DA F7 3B             jp      C,SET_CTC       ; port 1 => ch. 0, so continue
6158+ 3BF6 0C                   inc     C               ; port 2 => ch. 1, increment address port into C
6159+ 3BF7 3E 47        SET_CTC:ld      A,%01000111     ; interrupt off, counter mode, prsc=16 (doesn't matter), ext. start,
6160+ 3BF9                                              ; start upon loading time constant, time constant follows, sw reset, command word
6161+ 3BF9 ED 79                out     (C),A           ; configure CTC channel
6162+ 3BFB 7E                   ld      A,(HL)          ; load CTC divider
6163+ 3BFC ED 79                out     (C),A           ; send divider
6164+ 3BFE                      ; configure SIO
6165+ 3BFE 21 38 03             ld      HL,SIO_A_SETS   ; load default settings for SIO
6166+ 3C01 11 EA 52             ld      DE,SIOBFR       ; into a temp buffer
6167+ 3C04 01 0A 00             ld      BC,$000A        ; 10 items to copy
6168+ 3C07 ED B0                ldir                    ; copy SIO settings into TEMP buffer
6169+ 3C09 3A EF 52             ld      A,(SIOBFR+5)    ; load WR5 setting
6170+ 3C0C 47                   ld      B,A             ; move it into B
6171+ 3C0D 3A E7 52             ld      A,(DATABT)      ; load DATA bits
6172+ 3C10 FE 05                cp      $05             ; is it 5 bits?
6173+ 3C12 20 06                jr      NZ,BITS6        ; no, jump over
6174+ 3C14 CB B0                res     6,B
6175+ 3C16 CB A8                res     5,B             ; set D6 & D5 to 0
6176+ 3C18 18 19                jr      SETPAR          ; jump to set parity
6177+ 3C1A FE 06        BITS6:  cp      $06             ; is it 6 bits?
6178+ 3C1C 20 06                jr      NZ,BITS7        ; no, jump over
6179+ 3C1E CB F0                set     6,B
6180+ 3C20 CB A8                res     5,B             ; set D6 & D5 to 1,0
6181+ 3C22 18 0F                jr      SETPAR          ; jump to set parity
6182+ 3C24 FE 07        BITS7:  cp      $07             ; is it 7 bits?
6183+ 3C26 20 07                jr      NZ,BITS8        ; no, jump over
6184+ 3C28 CB B0                res     6,B
6185+ 3C2A CB E8                set     5,B             ; set D6 & D5 to 0,1
6186+ 3C2C C3 33 3C             jp      SETPAR          ; jump to set parity
6187+ 3C2F CB F0        BITS8:  set     6,B
6188+ 3C31 CB E8                set     5,B             ; set D6 & D5 to 1,1
6189+ 3C33 21 1F 53     SETPAR: ld      HL,SERABITS     ; load address for storing data bits
6190+ 3C36 3A E4 52             ld      A,(PRTNUM)      ; check serial port number
6191+ 3C39 3D                   dec     A               ; is it port #1?
6192+ 3C3A CA 3E 3C             jp      Z,SETPAR2       ; yes, jump over
6193+ 3C3D 23                   inc     HL              ; port #2, use SERBBITS instead
6194+ 3C3E 78           SETPAR2:ld      A,B             ; retrieve DATA bits
6195+ 3C3F 32 EF 52             ld      (SIOBFR+5),A    ; save DATA bits
6196+ 3C42 E6 60                and     %01100000       ; filter only D5&D6 bits
6197+ 3C44 87                   add     A,A             ; shift left times 1
6198+ 3C45 77                   ld      (HL),A          ; store for SIO_EI & SIO_DI functions
6199+ 3C46 3A E9 52             ld      A,(STPBT)       ; load STOP bits
6200+ 3C49 87                   add     A,A
6201+ 3C4A 87                   add     A,A             ; 2 left shifts
6202+ 3C4B 47                   ld      B,A             ; move forming byte into B
6203+ 3C4C 3A E8 52             ld      A,(PARBT)       ; load PARITY setting
6204+ 3C4F A7                   and     A               ; is it 0?
6205+ 3C50 CA 5B 3C             jp      Z,STRPAR        ; yes, jump over
6206+ 3C53 CB C0                set     0,B             ; set PARITY on
6207+ 3C55 3D                   dec     A               ; is parity ODD?
6208+ 3C56 CA 5B 3C             jp      Z,STRPAR        ; yes, so jump over
6209+ 3C59 CB C8                set     1,B             ; no, it's EVEN so set the corresponding bit
6210+ 3C5B 3A ED 52     STRPAR: ld      A,(SIOBFR+3)    ; load WR4 setting
6211+ 3C5E E6 F0                and     %11110000       ; reset STOP & PARITY bits
6212+ 3C60 B0                   or      B               ; set new STOP & PARITY bits
6213+ 3C61 32 ED 52             ld      (SIOBFR+3),A    ; store new value
6214+ 3C64                      ;set up TX and RX:
6215+ 3C64                      ; the followings are settings for channel A
6216+ 3C64 21 EA 52             ld      HL,SIOBFR       ; settings for SIO ch. A
6217+ 3C67 06 06                ld      B,$06           ; 6 bytes to send
6218+ 3C69 0E 22                ld      C,SIO_CA        ; I/O address of SIO ch.A
6219+ 3C6B 3A E4 52             ld      A,(PRTNUM)      ; load port number
6220+ 3C6E 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6221+ 3C6F DA 73 3C             jp      C,SRLCNT        ; port 1, continue
6222+ 3C72 0C                   inc     C               ; port 2, increment address port into C
6223+ 3C73 ED B3        SRLCNT: otir                    ; send bytes to SIO
6224+ 3C75                      ; the following are settings for channel B (don't need to load HL since settings are contigous)
6225+ 3C75 06 04                ld      B,$04           ; other 4 bytes to send
6226+ 3C77 51                   ld      D,C             ; store port address into D
6227+ 3C78 0E 23                ld      C,SIO_CB        ; I/O address of SIO ch.B
6228+ 3C7A ED B3                otir                    ; send bytes to SIO
6229+ 3C7C                      ; the following are settings for selected channel
6230+ 3C7C 3E 01                ld      A,$01           ; write into WR0: select WR1
6231+ 3C7E 4A                   ld      C,D             ; retrieve port address
6232+ 3C7F ED 79                out     (C),A
6233+ 3C81 3E 18                ld      A,%00011000     ; interrupts on every RX char; parity is no special condition;
6234+ 3C83                                              ; buffer overrun is special condition
6235+ 3C83 ED 79                out     (C),A
6236+ 3C85 21 1E 53             ld      HL,SERIALS_EN
6237+ 3C88 3A E4 52             ld      A,(PRTNUM)      ; retrieve serial channel
6238+ 3C8B 3D                   dec     A               ; channel A?
6239+ 3C8C 20 10                jr      NZ,ENCHB        ; no, jump over
6240+ 3C8E CD DA 01             call    SIO_A_EI        ; enable RX on SIO channel A
6241+ 3C91 CB C6                set     0,(HL)          ; set serial port 1 status ON
6242+ 3C93 CB D6                set     2,(HL)          ; set serial port 1 RX ON
6243+ 3C95                      ; back to normal running
6244+ 3C95 FB                   ei                      ; re-enable INTs
6245+ 3C96 DB 01                in      A,(PIO_DB)      ; load status LEDs
6246+ 3C98 CB F7                set     6,A             ; set status LED on
6247+ 3C9A CB A7                res     4,A             ; set error LED off
6248+ 3C9C 18 0E                jr      EXNRM           ; leave
6249+ 3C9E CD E2 01     ENCHB:  call    SIO_B_EI        ; enable RX on SIO channel B
6250+ 3CA1 CB CE                set     1,(HL)          ; set serial port 2 status ON
6251+ 3CA3 CB DE                set     3,(HL)          ; set serial port 2 RX ON
6252+ 3CA5                      ; back to normal running
6253+ 3CA5 FB                   ei                      ; re-enable INTs
6254+ 3CA6 DB 01                in      A,(PIO_DB)      ; load status LEDs
6255+ 3CA8 CB FF                set     7,A             ; set status LED on
6256+ 3CAA CB AF                res     5,A             ; set error LED off
6257+ 3CAC D3 01        EXNRM:  out     (PIO_DB),A      ; send new configuration
6258+ 3CAE DD E1                pop     IX              ; retrieve IX
6259+ 3CB0 D1                   pop     DE              ; retrieve DE
6260+ 3CB1 E1                   pop     HL              ; retrieve HL
6261+ 3CB2 C9                   ret                     ; return to caller
6262+ 3CB3
6263+ 3CB3              ; allowed bps (Bauds per second)
6264+ 3CB3 00 E1 00 96  SUP_BPS:defw    57600,38400,28800,19200,14400,9600,4800,3600,2400,1200,600
6264+ 3CB7 80 70 00 4B
6264+ 3CBB 40 38 80 25
6264+ 3CBF C0 12 10 0E
6264+ 3CC3 60 09 B0 04
6264+ 3CC7 58 02
6265+ 3CC9              ; corresponding CTC divider
6266+ 3CC9 02 03 04 06  CTC_CFG:defb    2,3,4,6,8,12,24,32,48,96,192
6266+ 3CCD 08 0C 18 20
6266+ 3CD1 30 60 C0
6267+ 3CD4
6268+ 3CD4
6269+ 3CD4              ; serial configuration error
6270+ 3CD4 DD E1        SCERR1: pop     IX              ; retrieve IX
6271+ 3CD6 D1                   pop     DE              ; retrieve DE
6272+ 3CD7 E1                   pop     HL              ; retrieve HL
6273+ 3CD8 1E 2C        SCERR:  ld      E,SC            ; Serial Configuration Error
6274+ 3CDA C3 BC 16             jp      ERROR           ; print error
6275+ 3CDD
6276+ 3CDD
6277+ 3CDD              ; serial buffer overrun
6278+ 3CDD CD 98 1E     SOERR:  call    PRNTCRLF
6279+ 3CE0 1E 30                ld      E,SO            ; Serial Buffer Overrun
6280+ 3CE2 C3 BC 16             jp      ERROR
6281+ 3CE5
6282+ 3CE5
6283+ 3CE5              ; check for direct mode
6284+ 3CE5 E5           DIRMOD: push    HL              ; Save code string address
6285+ 3CE6 2A AD 51             ld      HL,(LINEAT)     ; Get current line number
6286+ 3CE9 23                   inc     HL              ; -1 means direct statement
6287+ 3CEA 7C                   ld      A,H
6288+ 3CEB B5                   or      L
6289+ 3CEC E1                   pop     HL              ; Restore code string address
6290+ 3CED C2 07 3D             jp      NZ,HLPERR       ; raise error if in indirect mode
6291+ 3CF0 C9                   ret
6292+ 3CF1
6293+ 3CF1
6294+ 3CF1              ; HELP lists the line program where an error occured
6295+ 3CF1 CD E5 3C     HELP:   call    DIRMOD          ; check if in direct mode
6296+ 3CF4 E5                   push    HL              ; store HL
6297+ 3CF5 2A AF 51             ld      HL,(HLPLN)      ; load HELP line
6298+ 3CF8 23                   inc     HL              ; increment HL
6299+ 3CF9 7C                   ld      A,H
6300+ 3CFA B5                   or      L               ; check if there is a line into the HELP reg.
6301+ 3CFB E1                   pop     HL
6302+ 3CFC CA 07 3D             jp      Z,HLPERR        ; no line found, raise error
6303+ 3CFF ED 5B AF 51          ld      DE,(HLPLN)      ; recover line
6304+ 3D03 C1                   pop     BC              ; remove BC from stack since it's not needed anymore for LIST
6305+ 3D04 C3 18 1A             jp      LST01H          ; jump to list line
6306+ 3D07 1E 32        HLPERR: ld      E,HP            ; HELP call error
6307+ 3D09 C3 BC 16             jp      ERROR           ; raise error
6308+ 3D0C
6309+ 3D0C
6310+ 3D0C              ; KEY command to list/modify function keys and auto-repeat
6311+ 3D0C 2B           KEY:    dec     HL              ; dec 'cos GETCHR INCs
6312+ 3D0D CD CB 1B             call    GETCHR          ; Get next character
6313+ 3D10 CA 90 3D             jp      Z,LSTKEYS       ; jump if nothing follows
6314+ 3D13                      ; change FN keys
6315+ 3D13 CD DA 28             call    GETINT          ; get a number
6316+ 3D16 A7                   and     A               ; is it 0?
6317+ 3D17 20 10                jr      NZ,KEYCH        ; no, jump over
6318+ 3D19 E5           RESFN:  push    HL              ; yes - reset FN keys to defaults
6319+ 3D1A D5                   push    DE              ; store HL & DE
6320+ 3D1B 21 96 15             ld      HL,AUTORP       ; pointer to default auto-repeat delays and FN keys texts
6321+ 3D1E 11 B1 51             ld      DE,KEYDEL       ; pointer to destination
6322+ 3D21 01 82 00             ld      BC,$0082        ; 130 chars to be copied (2xauto-delay, 128xFN keys)
6323+ 3D24 ED B0                ldir                    ; restore default texts
6324+ 3D26 D1                   pop     DE              ; retrieve DE
6325+ 3D27 E1                   pop     HL              ; retrieve HL
6326+ 3D28 C9                   ret                     ; return to caller
6327+ 3D29 FE 09        KEYCH:  cp      $09             ; is it >= 9?
6328+ 3D2B D2 43 3E             jp      NC,SETREP       ; yes - jump over
6329+ 3D2E 3D                   dec     A               ; FN key in range 0~7
6330+ 3D2F 87                   add     A,A             ; multiply A...
6331+ 3D30 87                   add     A,A             ; ... times 4...
6332+ 3D31 87                   add     A,A             ; ... to get the correct...
6333+ 3D32 87                   add     A,A             ; ... offset fo FN key text
6334+ 3D33 32 DC 52             ld      (TMPBFR1),A     ; store FN key offset...
6335+ 3D36 AF                   xor     A               ; ...in a...
6336+ 3D37 32 DD 52             ld      (TMPBFR1+1),A   ; ...16-bit register
6337+ 3D3A CD 8A 19             call    CHKSYN          ; Make sure ',' follows
6338+ 3D3D 2C                   defb    ','
6339+ 3D3E 44 4D                ld      BC,HL           ; copy address into BC
6340+ 3D40 CD 66 20             call    EVAL            ; Evaluate expression (in E there is the length)
6341+ 3D43 E5                   push    HL              ; store string pointer
6342+ 3D44 3A 92 52             ld      A,(TYPE)        ; Get variable type
6343+ 3D47 B7                   or      A               ; Is it a string variable?
6344+ 3D48 CA A8 16             jp      Z,SNERR         ; no - syntax error
6345+ 3D4B CD 9F 26             call    GSTRCU          ; Current string to pool
6346+ 3D4E CD B0 2E             call    LOADFP          ; Move string block data to (BC=pointer, DE=length)
6347+ 3D51 7B                   ld      A,E             ; copy length into A
6348+ 3D52 FE 11                cp      $11             ; is length > 16?
6349+ 3D54 DA 59 3D             jp      C,DECLN1        ; no, jump over
6350+ 3D57 1E 10                ld      E,$10           ; yes, so set length to 16
6351+ 3D59 3E 10        DECLN1: ld      A,$10           ; calculate how many...
6352+ 3D5B 93                   sub     E               ; ...null chars needed to fill up...
6353+ 3D5C 57                   ld      D,A             ; ...the FN key text
6354+ 3D5D C5                   push    BC              ; store address of string
6355+ 3D5E ED 4B DC 52          ld      BC,(TMPBFR1)    ; load FN key offset
6356+ 3D62 21 B3 51             ld      HL,FNKEYS       ; load address of FN keys texts
6357+ 3D65 09                   add     HL,BC           ; get corrected address
6358+ 3D66 C1                   pop     BC              ; retrieve address of string chars
6359+ 3D67 0A           CPKEY:  ld      A,(BC)          ; load char from string
6360+ 3D68 FE 0D                cp      CR              ; return?
6361+ 3D6A CA 77 3D             jp      Z,CPKEY2        ; yes, store char
6362+ 3D6D FE 7B                cp      $7B             ; if char > "z" ?
6363+ 3D6F D2 A8 16             jp      NC,SNERR        ; yes - syntax error
6364+ 3D72 FE 20                cp      $20             ; is char < space?
6365+ 3D74 DA A8 16             jp      C,SNERR         ; yes - syntax error
6366+ 3D77 FE 61        CPKEY2: cp      $61             ; is it >= 'a'?
6367+ 3D79 DA 7E 3D             jp      C,CPKEY3        ; no, continue
6368+ 3D7C E6 5F                and     %01011111       ; set letters to uppercase
6369+ 3D7E 77           CPKEY3: ld      (HL),A          ; store char
6370+ 3D7F 23                   inc     HL              ; next string char
6371+ 3D80 03                   inc     BC              ; next free cell
6372+ 3D81 1D                   dec     E               ; decrement E
6373+ 3D82 20 E3                jr      NZ,CPKEY        ; repeat until 0
6374+ 3D84 AF                   xor     A               ; null char
6375+ 3D85 14                   inc     D               ; +1 to decrement below
6376+ 3D86 15           CPKEY1: dec     D               ; how many null chars to insert?
6377+ 3D87 CA 8E 3D             jp      Z,CPKYEND       ; no more nulls, so exit
6378+ 3D8A 77                   ld      (HL),A          ; store it
6379+ 3D8B 23                   inc     HL              ; next cell
6380+ 3D8C 18 F8                jr      CPKEY1          ; repeat
6381+ 3D8E E1           CPKYEND:pop     HL              ; retrieve pointer to string
6382+ 3D8F C9                   ret                     ; return to caller
6383+ 3D90                                              ; list FN keys
6384+ 3D90 E5           LSTKEYS:push    HL              ; Save code string address
6385+ 3D91 2A AD 51             ld      HL,(LINEAT)     ; Get current line number
6386+ 3D94 23                   inc     HL              ; -1 means direct statement
6387+ 3D95 7C                   ld      A,H
6388+ 3D96 B5                   or      L
6389+ 3D97 E1                   pop     HL              ; Restore code string address
6390+ 3D98 C2 A8 16             jp      NZ,SNERR        ; raise error if in indirect mode
6391+ 3D9B E5                   push    HL              ; store HL
6392+ 3D9C D5                   push    DE              ; store DE
6393+ 3D9D 21 B3 51             ld      HL,FNKEYS       ; load starting address of FN keys text
6394+ 3DA0 0E 01                ld      C,$01           ; 8 function keys
6395+ 3DA2 06 10        PRTK4:  ld      B,$10           ; 16 chars each
6396+ 3DA4 11 65 3E     PRTK2:  ld      DE,CHKEY1       ; message "KEY "
6397+ 3DA7 CD 34 3E             call    PRTCKEY         ; print it
6398+ 3DAA 79                   ld      A,C             ; load FN key
6399+ 3DAB C6 30                add     $30             ; get number in ASCI code
6400+ 3DAD CD 95 19             call    OUTC            ; print it
6401+ 3DB0 11 6A 3E             ld      DE,CHKEY2       ; message ": ""
6402+ 3DB3 CD 34 3E             call    PRTCKEY         ; print it
6403+ 3DB6 3E 01                ld      A,$01           ; " opened
6404+ 3DB8 32 DC 52             ld      (TMPBFR1),A
6405+ 3DBB 7E           LDKEY:  ld      A,(HL)          ; retrieve char
6406+ 3DBC A7                   and     A               ; is it zero?
6407+ 3DBD CA D0 3D             jp      Z,CNTLTK        ; yes, go next char
6408+ 3DC0 CD 1C 3E             call    OPNQT           ; check if quotes are opened
6409+ 3DC3 FE 22                cp      $22             ; check if char is "?
6410+ 3DC5 CA E5 3D             jp      Z,PRTCHR        ; yes, print "chr$("
6411+ 3DC8 FE 0D                cp      CR              ; is it a CR?
6412+ 3DCA CA E5 3D             jp      Z,PRTCHR        ; yes, print "chr$("
6413+ 3DCD CD 95 19     PRTK3:  call    OUTC            ; no, just print it
6414+ 3DD0 23           CNTLTK: inc     HL              ; next char
6415+ 3DD1 10 E8                djnz    LDKEY           ; continue until finished
6416+ 3DD3 CD 0A 3E             call    CLSQT           ; check if quotes are still open
6417+ 3DD6 3E 0D                ld      A,CR            ; go next line
6418+ 3DD8 CD 95 19             call    OUTC            ; print it
6419+ 3DDB 0C                   inc     C               ; next FN key
6420+ 3DDC 79                   ld      A,C             ; check if...
6421+ 3DDD FE 09                cp      $09             ; finished keys?
6422+ 3DDF DA A2 3D             jp      C,PRTK4         ; no, repeat 1 more time
6423+ 3DE2 D1                   pop     DE              ; retrieve DE
6424+ 3DE3 E1                   pop     HL              ; retrieve HL
6425+ 3DE4 C9                   ret                     ; return to caller
6426+ 3DE5 E5           PRTCHR: push    HL              ; store HL
6427+ 3DE6 CD 0A 3E             call    CLSQT           ; check if quotes are closed
6428+ 3DE9 3E 2B                ld      A,'+'           ; '+' char
6429+ 3DEB CD 95 19             call    OUTC            ; print it
6430+ 3DEE 11 6D 3E             ld      DE,CHKEY3       ; address of "CHR$("
6431+ 3DF1 CD 34 3E             call    PRTCKEY         ; print it
6432+ 3DF4 E1                   pop     HL              ; recover HL
6433+ 3DF5 23                   inc     HL              ; next char
6434+ 3DF6 05                   dec     B               ; increment char counter
6435+ 3DF7 11 73 3E             ld      DE,CHKEY4       ; load address of RETURN
6436+ 3DFA 7E                   ld      A,(HL)          ; load char
6437+ 3DFB FE 0D                cp      CR              ; is it a RETURN?
6438+ 3DFD 20 03                jr      NZ,PTCHR1       ; no, jump over
6439+ 3DFF 11 76 3E             ld      DE,CHKEY5       ; yes, load address of "
6440+ 3E02 CD 34 3E     PTCHR1: call    PRTCKEY         ; print it
6441+ 3E05 3E 29                ld      A,')'           ; char )
6442+ 3E07 C3 CD 3D             jp      PRTK3           ; continue
6443+ 3E0A F5           CLSQT:  push    AF              ; store A
6444+ 3E0B 3A DC 52             ld      A,(TMPBFR1)     ; quote status
6445+ 3E0E A7                   and     A               ; are they closed?
6446+ 3E0F 28 09                jr      Z,CLSQT1        ; if yes, return
6447+ 3E11 3E 22                ld      A,$22           ; no, so close them
6448+ 3E13 CD 95 19             call    OUTC            ; print "
6449+ 3E16 AF                   xor     A               ; set quotes
6450+ 3E17 32 DC 52             ld      (TMPBFR1),A     ; as closed
6451+ 3E1A F1           CLSQT1: pop     AF              ; retrieve A
6452+ 3E1B C9                   ret                     ; return to caller
6453+ 3E1C F5           OPNQT:  push    AF              ; store A
6454+ 3E1D 3A DC 52             ld      A,(TMPBFR1)     ; quote status
6455+ 3E20 A7                   and     A               ; are they open?
6456+ 3E21 20 0F                jr      NZ,OPNQT1       ; if yes, return
6457+ 3E23 3E 2B                ld      A,'+'           ; no, so add '+
6458+ 3E25 CD 95 19             call    OUTC            ; print it
6459+ 3E28 3E 22                ld      A,$22           ; and then open quotes
6460+ 3E2A CD 95 19             call    OUTC            ; print them
6461+ 3E2D 3E 01                ld      A,$01           ; set quotes
6462+ 3E2F 32 DC 52             ld      (TMPBFR1),A     ; as opened
6463+ 3E32 F1           OPNQT1: pop     AF              ; retrieve A
6464+ 3E33 C9                   ret                     ; return to caller
6465+ 3E34 F5           PRTCKEY:push    AF              ; store original char
6466+ 3E35 1A           PRTK1:  ld      A,(DE)          ; load char
6467+ 3E36 A7                   and     A               ; is it 0?
6468+ 3E37 CA 41 3E             jp      Z,PRTEND        ; yes, finished printing
6469+ 3E3A CD 95 19             call    OUTC            ; no, print char
6470+ 3E3D 13                   inc     DE              ; next char
6471+ 3E3E C3 35 3E             jp      PRTK1           ; repeat
6472+ 3E41 F1           PRTEND: pop     AF              ; retrieve AF
6473+ 3E42 C9                   ret                     ; return to caller
6474+ 3E43 FE 09        SETREP: cp      $09             ; is it special key 9? (stands for auto-repeat)
6475+ 3E45 C2 A8 16             jp      NZ,SNERR        ; no, raise an error
6476+ 3E48 CD 8A 19             call    CHKSYN          ; Check for comma
6477+ 3E4B 2C                   defb    ','
6478+ 3E4C CD DA 28             call    GETINT          ; get a number
6479+ 3E4F 32 DC 52             ld      (TMPBFR1),A     ; store it
6480+ 3E52 CD 8A 19             call    CHKSYN          ; Check for comma
6481+ 3E55 2C                   defb    ','
6482+ 3E56 CD DA 28             call    GETINT          ; get another number
6483+ 3E59 E5                   push    HL              ; store HL
6484+ 3E5A 21 B2 51             ld      HL,AUTOKE       ; address of second cell for key auto-repeat
6485+ 3E5D 77                   ld      (HL),A          ; store auto-repeat delay
6486+ 3E5E 2B                   dec     HL              ; previous cell
6487+ 3E5F 3A DC 52             ld      A,(TMPBFR1)     ; retrieve value
6488+ 3E62 77                   ld      (HL),A          ; store delay for auto-repeat
6489+ 3E63 E1                   pop     HL              ; retrieve HL
6490+ 3E64 C9                   ret
6491+ 3E65 4B 45 59 20  CHKEY1: defb    "KEY ",0
6491+ 3E69 00
6492+ 3E6A 3A 22 00     CHKEY2: defb    ":",34,0
6493+ 3E6D 63 68 72 24  CHKEY3: defb    "chr$(",0
6493+ 3E71 28 00
6494+ 3E73 31 33 00     CHKEY4: defb    "13",0
6495+ 3E76 33 34 00     CHKEY5: defb    "34",0
6496+ 3E79
6497+ 3E79
6498+ 3E79              ; LOAD "filename"
6499+ 3E79              ; load a BASIC program from disk
6500+ 3E79 C9           LOAD:   ret                     ; currently a stub for LOAD
6501+ 3E7A
6502+ 3E7A
6503+ 3E7A              ; SAVE "filename"
6504+ 3E7A              ; save a BASIC program on disk
6505+ 3E7A C9           SAVE:   ret                     ; currently a stub for SAVE
6506+ 3E7B
6507+ 3E7B
6508+ 3E7B              ; FILES
6509+ 3E7B              ; list files on disk
6510+ 3E7B C9           FILES:  ret                     ; currently a stub for FILES
6511+ 3E7C
6512+ 3E7C
6513+ 3E7C              ; ERASE "filename"
6514+ 3E7C              ; erase a file from disk
6515+ 3E7C C9           ERASE:  ret                     ; currently a stub for ERASE
6516+ 3E7D
6517+ 3E7D
6518+ 3E7D              ; HEX$(nn) Convert 16 bit number to Hexadecimal string
6519+ 3E7D CD 57 20     HEX: 	call	TSTNUM          ; Verify it's a number
6520+ 3E80 CD 81 1C             call	DEINT           ; Get integer -32768 to 32767
6521+ 3E83 C5                   push	BC              ; Save contents of BC
6522+ 3E84 21 35 53             ld      HL,PBUFF        ; load address of PBUFF into HL
6523+ 3E87 7A                   ld      A,D             ; Get MSB into A
6524+ 3E88 B7                   or      A               ; OR with LSB to see if param=0
6525+ 3E89 28 0C                jr      Z,HEX2          ; Skip output if both high digits are zero
6526+ 3E8B CD B3 3E             call    BYT2ASC         ; Convert D to ASCII
6527+ 3E8E 78                   ld      A,B             ; cechk if B
6528+ 3E8F FE 30                cp      '0'             ; is 0
6529+ 3E91 28 02                jr      Z,HEX1          ; Don't store high digit if zero
6530+ 3E93 70                   ld      (HL),B          ; Store it to PBUFF
6531+ 3E94 23                   inc     HL              ; Next location
6532+ 3E95 71           HEX1:   ld      (HL),C          ; Store C to PBUFF+1
6533+ 3E96 23                   inc     HL              ; Next location
6534+ 3E97 7B           HEX2:   ld      A,E             ; Get lower byte
6535+ 3E98 CD B3 3E             call    BYT2ASC         ; Convert E to ASCII
6536+ 3E9B 7A                   ld      A,D
6537+ 3E9C B7                   or      A
6538+ 3E9D 20 05                jr      NZ,HEX3         ; If upper byte was not zero then always print lower byte
6539+ 3E9F 78                   ld      A,B
6540+ 3EA0 FE 30                cp      '0'             ; If high digit of lower byte is zero then don't print
6541+ 3EA2 28 02                jr      Z,HEX4
6542+ 3EA4 70           HEX3:   ld      (HL),B          ; to PBUFF+2
6543+ 3EA5 23                   inc     HL              ; Next location
6544+ 3EA6 71           HEX4:   ld      (HL),C          ; to PBUFF+3
6545+ 3EA7 23                   inc     HL              ; PBUFF+4 to zero
6546+ 3EA8 AF                   xor     A               ; Terminating character
6547+ 3EA9 77                   ld      (HL),A          ; Store zero to terminate
6548+ 3EAA 23                   inc     HL              ; Make sure PBUFF is terminated
6549+ 3EAB 77                   ld      (HL),A          ; Store the double zero there
6550+ 3EAC C1                   pop     BC              ; Get BC back
6551+ 3EAD 21 35 53             ld      HL,PBUFF        ; Reset to start of PBUFF
6552+ 3EB0 C3 EC 24             jp      STR1            ; Convert the PBUFF to a string and return it
6553+ 3EB3 47           BYT2ASC:ld      B,A             ; Save original value
6554+ 3EB4 E6 0F                and     $0F             ; Strip off upper nybble
6555+ 3EB6 FE 0A                cp      $0A             ; 0-9?
6556+ 3EB8 38 02                jr      C,ADD30         ; If A-F, add 7 more
6557+ 3EBA C6 07                add     A,$07           ; Bring value up to ASCII A-F
6558+ 3EBC C6 30        ADD30:  add     A,$30           ; And make ASCII
6559+ 3EBE 4F                   ld      C,A             ; Save converted char to C
6560+ 3EBF 78                   ld      A,B             ; Retrieve original value
6561+ 3EC0 0F                   rrca                    ; and Rotate it right
6562+ 3EC1 0F                   rrca
6563+ 3EC2 0F                   rrca
6564+ 3EC3 0F                   rrca
6565+ 3EC4 E6 0F                and     $0F             ; Mask off upper nybble
6566+ 3EC6 FE 0A                cp      $0A             ; 0-9? < A hex?
6567+ 3EC8 38 02                jr      C,ADD301        ; Skip Add 7
6568+ 3ECA C6 07                add     A,$07           ; Bring it up to ASCII A-F
6569+ 3ECC C6 30        ADD301: add     A,$30           ; And make it full ASCII
6570+ 3ECE 47                   ld      B,A             ; Store high order byte
6571+ 3ECF C9                   ret
6572+ 3ED0
6573+ 3ED0              ; Convert "&Hnnnn" to FPREG
6574+ 3ED0              ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
6575+ 3ED0              ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
6576+ 3ED0 EB           HEXTFP: ex      DE,HL           ; Move code string pointer to DE
6577+ 3ED1 21 00 00             ld      HL,$0000        ; Zero out the value
6578+ 3ED4 CD E9 3E             call    GETHEX          ; Check the number for valid hex
6579+ 3ED7 DA 09 3F             jp      C,HXERR         ; First value wasn't hex, HX error
6580+ 3EDA 18 05                jr      HEXLP1          ; Convert first character
6581+ 3EDC CD E9 3E     HEXLP:  call    GETHEX          ; Get second and addtional characters
6582+ 3EDF 38 1F                jr      C,HEXIT         ; Exit if not a hex character
6583+ 3EE1 29           HEXLP1: add     HL,HL           ; Rotate 4 bits to the left
6584+ 3EE2 29                   add     HL,HL
6585+ 3EE3 29                   add     HL,HL
6586+ 3EE4 29                   add     HL,HL
6587+ 3EE5 B5                   or      L               ; Add in D0-D3 into L
6588+ 3EE6 6F                   ld      L,A             ; Save new value
6589+ 3EE7 18 F3                jr      HEXLP           ; And continue until all hex characters are in
6590+ 3EE9
6591+ 3EE9 13           GETHEX: inc     DE              ; Next location
6592+ 3EEA 1A                   ld      A,(DE)          ; Load character at pointer
6593+ 3EEB FE 20                cp      SPC
6594+ 3EED CA E9 3E             jp      Z,GETHEX        ; Skip spaces
6595+ 3EF0 D6 30                sub     $30             ; Get absolute value
6596+ 3EF2 D8                   ret     C               ; < "0", error
6597+ 3EF3 FE 0A                cp      $0A
6598+ 3EF5 38 05                jr      C,NOSUB7        ; Is already in the range 0-9
6599+ 3EF7 D6 07                sub     $07             ; Reduce to A-F
6600+ 3EF9 FE 0A                cp      $0A             ; Value should be $0A-$0F at this point
6601+ 3EFB D8                   ret     C               ; CY set if was :            ; < = > ? @
6602+ 3EFC FE 10        NOSUB7: cp      $10             ; > Greater than "F"?
6603+ 3EFE 3F                   ccf
6604+ 3EFF C9                   ret                     ; CY set if it wasn't valid hex
6605+ 3F00
6606+ 3F00 EB           HEXIT:  ex      DE,HL           ; Value into DE, Code string into HL
6607+ 3F01 7A                   ld      A,D             ; Load DE into AC
6608+ 3F02 4B                   ld      C,E             ; For prep to
6609+ 3F03 E5                   push    HL
6610+ 3F04 CD 3D 24             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6611+ 3F07 E1                   pop     HL
6612+ 3F08 C9                   ret
6613+ 3F09
6614+ 3F09 DD 5C        HXERR:  ld      E,HX            ; ?HEX Error
6615+ 3F0B C3 BC 16             jp      ERROR
6616+ 3F0E
6617+ 3F0E              ; BIN$(NN) Convert integer to a 1-16 char binary string
6618+ 3F0E CD 57 20     BIN:    call    TSTNUM          ; Verify it's a number
6619+ 3F11 CD 81 1C             call    DEINT           ; Get integer -32768 to 32767
6620+ 3F14 C5           BIN2:   push    BC              ; Save contents of BC
6621+ 3F15 21 35 53             ld      HL,PBUFF
6622+ 3F18 06 11                ld      B,$11           ; One higher than max char count (16+1)
6623+ 3F1A              ZEROSUP:                        ; Suppress leading zeros
6624+ 3F1A 05                   dec     B               ; Max 16 chars
6625+ 3F1B 78                   ld      A,B
6626+ 3F1C FE 01                cp      $01
6627+ 3F1E 28 08                jr      Z,BITOUT        ; Always output at least one character
6628+ 3F20 CB 13                rl      E
6629+ 3F22 CB 12                rl      D
6630+ 3F24 30 F4                jr      NC,ZEROSUP
6631+ 3F26 18 04                jr      BITOUT2
6632+ 3F28 CB 13        BITOUT: rl      E
6633+ 3F2A CB 12                rl      D               ; Top bit now in carry
6634+ 3F2C 3E 30        BITOUT2:ld      A,'0'           ; Char for '0'
6635+ 3F2E CE 00                adc     A,$00           ; If carry set then '0' --> '1'
6636+ 3F30 77                   ld      (HL),A
6637+ 3F31 23                   inc     HL
6638+ 3F32 05                   dec     B
6639+ 3F33 20 F3                jr      NZ,BITOUT
6640+ 3F35 AF                   xor     A               ; Terminating character
6641+ 3F36 77                   ld      (HL),A          ; Store zero to terminate
6642+ 3F37 23                   inc     HL              ; Make sure PBUFF is terminated
6643+ 3F38 77                   ld      (HL),A          ; Store the double zero there
6644+ 3F39 C1                   pop     BC
6645+ 3F3A 21 35 53             ld      HL,PBUFF
6646+ 3F3D C3 EC 24             jp      STR1
6647+ 3F40
6648+ 3F40              ; Convert "&Bnnnn" to FPREG
6649+ 3F40              ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
6650+ 3F40 EB           BINTFP: ex      DE,HL           ; Move code string pointer to DE
6651+ 3F41 21 00 00             ld      HL,$0000        ; Zero out the value
6652+ 3F44 CD 5D 3F             call    CHKBIN          ; Check the number for valid bin
6653+ 3F47 DA 6B 3F             jp      C,BINERR        ; First value wasn't bin, HX error
6654+ 3F4A D6 30        BINIT:  sub     '0'
6655+ 3F4C 29                   add     HL,HL           ; Rotate HL left
6656+ 3F4D B5                   or      L
6657+ 3F4E 6F                   ld      L,A
6658+ 3F4F CD 5D 3F             call    CHKBIN          ; Get second and addtional characters
6659+ 3F52 30 F6                jr      NC,BINIT        ; Process if a bin character
6660+ 3F54 EB                   ex      DE,HL           ; Value into DE, Code string into HL
6661+ 3F55 7A                   ld      A,D             ; Load DE into AC
6662+ 3F56 4B                   ld      C,E             ; For prep to
6663+ 3F57 E5                   push    HL
6664+ 3F58 CD 3D 24             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6665+ 3F5B E1                   pop     HL
6666+ 3F5C C9                   ret
6667+ 3F5D
6668+ 3F5D              ; Char is in A, NC if char is 0 or 1
6669+ 3F5D 13           CHKBIN: inc     DE
6670+ 3F5E 1A                   ld      A,(DE)
6671+ 3F5F FE 20                cp      SPC
6672+ 3F61 CA 5D 3F             jp      Z,CHKBIN        ; Skip spaces
6673+ 3F64 FE 30                cp      '0'             ; Set C if < '0'
6674+ 3F66 D8                   ret     C
6675+ 3F67 FE 32                cp      '2'
6676+ 3F69 3F                   ccf                     ; Set C if > '1'
6677+ 3F6A C9                   ret
6678+ 3F6B
6679+ 3F6B 1E 28        BINERR: ld      E,BN            ; ?BIN Error
6680+ 3F6D C3 BC 16             jp      ERROR
6681+ 3F70
6682+ 3F70
6683+ 3F70 C3 08 00     MONOUT: jp      $0008           ; output a char
6684+ 3F73
6685+ 3F73
6686+ 3F73 3A 1E 53     RESET:  ld      A,(SERIALS_EN)
6687+ 3F76 E6 11                and     $11             ; are serial ports open?
6688+ 3F78 C4 E3 3A             call    NZ,RSTSERS      ; yes, reset serials
6689+ 3F7B CD F5 28             call    DISNMI          ; disable NMI vector
6690+ 3F7E F3                   di                      ; disable INTs
6691+ 3F7F C3 CF 50             jp      ROM2RAM         ; Restart
6692+ 3F82
6693+ 3F82
6694+ 3F82 3E 00        INITST: ld      A,$00           ; Clear break flag
6695+ 3F84 32 A7 51             ld      (BRKFLG),A
6696+ 3F87 C3 D4 11             jp      INIT
6697+ 3F8A
6698+ 3F8A
6699+ 3F8A F5           TSTBIT: push    AF              ; Save bit mask
6700+ 3F8B A0                   and     B               ; Get common bits
6701+ 3F8C C1                   pop     BC              ; Restore bit mask
6702+ 3F8D B8                   cp      B               ; Same bit set?
6703+ 3F8E 3E 00                ld      A,$00           ; Return 0 in A
6704+ 3F90 C9                   ret
6705+ 3F91
6706+ 3F91 CD 95 19     OUTNCR: call    OUTC            ; Output character in A
6707+ 3F94 C3 98 1E             jp      PRNTCRLF        ; Output CRLF
6708+ 3F97
# file closed: ../include/basic/basic64k-r1.01.asm
  73  3F97
  74  3F97              ; include utils
  75  3F97                  INCLUDE "../include/utils/utils-r11.asm"
# file opened: ../include/utils/utils-r11.asm
   1+ 3F97              ; ------------------------------------------------------------------------------
   2+ 3F97              ; LM80C - UTILITY ROUTINES - R1.1
   3+ 3F97              ; ------------------------------------------------------------------------------
   4+ 3F97              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 3F97              ; designed by Leonardo Miliani. More info at
   6+ 3F97              ; www DOT leonardomiliani DOT com
   7+ 3F97              ;
   8+ 3F97              ; *ALS are routines from "Z80 Assembly Language Subroutines" by Lance
   9+ 3F97              ; A. Leventhal and Winthrop Saville - Ed. Osborne/McGraw-Hill (1983)
  10+ 3F97              ;
  11+ 3F97              ; * WKT are routines from WikiTI:
  12+ 3F97              ; http://wikiti.brandonw.net/index.php?title=WikiTI_Home
  13+ 3F97              ;
  14+ 3F97              ; * LAC are routines from Learn@Cemetch
  15+ 3F97              ; https://learn.cemetech.net/index.php/Main_Page
  16+ 3F97              ;
  17+ 3F97              ; ------------------------------------------------------------------------------
  18+ 3F97              ; Code Revision:
  19+ 3F97              ; R1.0 - 20200110 - First release: 16-bit comparision/multiplication/negation
  20+ 3F97              ; R1.1 - 20200413 - Second release: added ABS(HL)
  21+ 3F97              ;
  22+ 3F97              ; ------------------------------------------------------------------------------
  23+ 3F97
  24+ 3F97              ; compare two 16-bit registers, HL (minuend) and DE (subtrahend)
  25+ 3F97              ; values can be both signed or unsigned words
  26+ 3F97              ; inputs: HL, DE
  27+ 3F97              ; destroys: A,F,HL
  28+ 3F97              ;
  29+ 3F97              ; returns: Z=1 if HL = DE
  30+ 3F97              ; for UNSIGNED: C=1 if HL<DE  //  C=0 if HL>DE
  31+ 3F97              ; for SIGNED:   S=1 (M) if HL<DE  //  S=0 (P) if HL>DE
  32+ 3F97              ; if HL=DE: Z,P,NC  - Z=1, S=0; C=0
  33+ 3F97              ; if HL>DE: NZ,P,NC - Z=0, S=0; C=0
  34+ 3F97              ; if HL<DE: NZ,M,C  - Z=0, S=1; C=1
  35+ 3F97              ; Source: ALS
  36+ 3F97
  37+ 3F97 B7           CMP16:  or      A           ; clear CARRY
  38+ 3F98 ED 52                sbc     HL,DE       ; subtract DE from HL
  39+ 3F9A E0                   ret     PO          ; return if no overflow
  40+ 3F9B 7C                   ld      A,H         ; overflow - invert SIGN flag
  41+ 3F9C 1F                   rra                 ; save CARRY flag in bit 7
  42+ 3F9D EE 40                xor     %01000000   ; complement bit 6 (SIGN bit)
  43+ 3F9F 37                   scf                 ; ensure a Non-Zero result
  44+ 3FA0 8F                   adc     A,A         ; restore CARRY, complemented SIGN
  45+ 3FA1                                          ; ZERO flag = 0 for sure
  46+ 3FA1 C9                   ret                 ; return
  47+ 3FA2
  48+ 3FA2              ; ----------------------------------------------------------------------
  49+ 3FA2
  50+ 3FA2              ; multiply 2 signed/unsigned 16-bit words and return a 16-bit
  51+ 3FA2              ; signed/unsigned product
  52+ 3FA2              ; inputs: HL (multiplicand); DE (multiplier)
  53+ 3FA2              ; destroys: A,F
  54+ 3FA2              ; returns: HL (product)
  55+ 3FA2              ; Source: ALS
  56+ 3FA2
  57+ 3FA2              ; initialize partial product, bit count
  58+ 3FA2 C5           MUL16:  push    BC
  59+ 3FA3 4D                   ld      C,L         ; BC = multiplier
  60+ 3FA4 44                   ld      B,H
  61+ 3FA5 21 00 00             ld      HL,0        ; product = 0
  62+ 3FA8 3E 0F                ld      A,$0F       ; count = bit lenght - 1 (16-1)
  63+ 3FAA                      ; shift-and-add algorithm
  64+ 3FAA                      ; if MSB of multiplier is 1, add multiplicand to partial product
  65+ 3FAA                      ; shift partial product, multiplier left 1 bit
  66+ 3FAA CB 23        MLP:    sla     E           ; shift multiplier left 1 bit
  67+ 3FAC CB 12                rl      D
  68+ 3FAE 30 01                jr      NC,MLP1     ; jump if MSB of multiplier = 0
  69+ 3FB0 09                   add     HL,BC       ; add multiplicand to partial product
  70+ 3FB1 29           MLP1:   add     HL,HL       ; shift partial product left
  71+ 3FB2 3D                   dec     A
  72+ 3FB3 20 F5                jr      NZ,MLP      ; continue until count = 0
  73+ 3FB5                      ; add multiplicand one last time if MSB of multiplier is 1
  74+ 3FB5 B2                   or      D           ; sign flag = MSB of multiplier
  75+ 3FB6 F2 BA 3F             jp      P,EXMUL16   ; exit if MSB of multiplier is 0
  76+ 3FB9 09                   add     HL,BC       ; add multiplicand to product
  77+ 3FBA C1           EXMUL16:pop     BC
  78+ 3FBB C9                   ret
  79+ 3FBC
  80+ 3FBC              ; ----------------------------------------------------------------------
  81+ 3FBC              ; absolute value of HL (same applies to other 16-bit register pairs)
  82+ 3FBC              ; also, invert value of HL (or any other 16-bit register, just adjust the code)
  83+ 3FBC              ;
  84+ 3FBC              ; inputs: HL
  85+ 3FBC              ; destroys: A
  86+ 3FBC              ; operation: ABS(HL)
  87+ 3FBC              ; returns: HL with no sign or negated
  88+ 3FBC              ; Source: WKT
  89+ 3FBC
  90+ 3FBC CB 7C        absHL:  bit     7,H
  91+ 3FBE C8                   ret     Z
  92+ 3FBF AF           negHL:  xor     A
  93+ 3FC0 95                   sub     L
  94+ 3FC1 6F                   ld      L,A
  95+ 3FC2 9F                   sbc     A,A
  96+ 3FC3 94                   sub     H
  97+ 3FC4 67                   ld      H,A
  98+ 3FC5 C9                   ret
  99+ 3FC6
 100+ 3FC6              ; ------------------------------------------------------------------------------
 101+ 3FC6
 102+ 3FC6              ; 8/8 division
 103+ 3FC6              ; INPUT: D (dividend), E (divisor)
 104+ 3FC6              ; OPERATION: D/E
 105+ 3FC6              ; OUTPUT: D (quotient), A (remainder)
 106+ 3FC6 AF           DIV_8_8:    xor     A
 107+ 3FC7 C5                       push    BC
 108+ 3FC8 06 08                    ld      B,08h
 109+ 3FCA CB 22        DIV_8_8LOOP:sla     D
 110+ 3FCC 17                       rla
 111+ 3FCD BB                       cp      E
 112+ 3FCE 38 02                    jr      C,$+4
 113+ 3FD0 93                       sub     E
 114+ 3FD1 14                       inc     D
 115+ 3FD2 10 F6                    djnz    DIV_8_8LOOP
 116+ 3FD4 C1                       pop     BC
 117+ 3FD5 C9                       ret
 118+ 3FD6
 119+ 3FD6              ; ----------------------------------------------------------------------
 120+ 3FD6              ; divide a 16-bit number by an 8-bit number
 121+ 3FD6              ; (16/8 division)
 122+ 3FD6              ;
 123+ 3FD6              ; inputs: HL (Dividend), C (divisor)
 124+ 3FD6              ; destroys: A
 125+ 3FD6              ; OPERATION: HL/C
 126+ 3FD6              ; returns: HL (quotient), A (remainder)
 127+ 3FD6              ; source: WKT
 128+ 3FD6
 129+ 3FD6 AF           DIV_16_8:   xor     A
 130+ 3FD7 06 10                    ld      B,16
 131+ 3FD9 29           DIV_16_8LP: add     HL,HL
 132+ 3FDA 17                       rla
 133+ 3FDB 38 03                    jr      C,$+5
 134+ 3FDD B9                       cp      C
 135+ 3FDE 38 02                    jr      C,$+4
 136+ 3FE0 91                       sub     C
 137+ 3FE1 2C                       inc     L
 138+ 3FE2 10 F5                    djnz    DIV_16_8LP
 139+ 3FE4 C9                       ret
 140+ 3FE5
 141+ 3FE5              ; ----------------------------------------------------------------------
 142+ 3FE5              ; divide a 16-bit number by a 16-bit number
 143+ 3FE5              ; (16/16 division)
 144+ 3FE5              ;
 145+ 3FE5              ; inputs: AC (Dividend), DE (divisor)
 146+ 3FE5              ; destroys: HL,A,C
 147+ 3FE5              ; OPERATION: AC/DE
 148+ 3FE5              ; returns: AC (quotient), HL (remainder)
 149+ 3FE5              ; source: WKT
 150+ 3FE5 21 00 00     DIV_16_16:  ld      HL, 0
 151+ 3FE8 06 10                    ld      B, 16
 152+ 3FEA CB 21        DV16_16_LP: sla     C
 153+ 3FEC CB C1                    set     0,C         ; this simulates the SLL undocumented instruction
 154+ 3FEE 17                       rla
 155+ 3FEF ED 6A                    adc     HL,HL
 156+ 3FF1 ED 52                    sbc     HL,DE
 157+ 3FF3 30 02                    jr      NC, $+4
 158+ 3FF5 19                       add     HL,DE
 159+ 3FF6 0D                       dec     C
 160+ 3FF7 10 F1                    djnz    DV16_16_LP
 161+ 3FF9 C9                       ret
# file closed: ../include/utils/utils-r11.asm
  76  3FFA
  77  3FFA              ; include the latest version of the font sets
  78  3FFA                  INCLUDE "../include/vdp/6x8fonts-r16.asm"
# file opened: ../include/vdp/6x8fonts-r16.asm
   1+ 3FFA              ; ------------------------------------------------------------------------------
   2+ 3FFA              ; LM80C - 6x8 CHARSET - R1.6
   3+ 3FFA              ; ------------------------------------------------------------------------------
   4+ 3FFA              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 3FFA              ; designed by Leonardo Miliani. More info at
   6+ 3FFA              ; www DOT leonardomiliani DOT com
   7+ 3FFA              ; ------------------------------------------------------------------------------
   8+ 3FFA              ; Code Revision:
   9+ 3FFA              ; R1.0 - 20190511 - First revision: ASCII chars (from 0 to 127)
  10+ 3FFA              ; R1.1 - 20190521 - Expanded to 255 chars
  11+ 3FFA              ; R1.2 - 20191209 - Start adding graphic chars to be coherent with 8x8 fonts
  12+ 3FFA              ; R1.3 - 20191226 - Added extended char codes (128-255)
  13+ 3FFA              ; R1.4 - 20200228 - adopted more usual hexadecimal & binary prefixes
  14+ 3FFA              ; R1.5 - 20200524 - New style for char #252
  15+ 3FFA              ; R1.6 - 20200704 - Redefined chars 105, 106, and 252
  16+ 3FFA              ; ------------------------------------------------------------------------------
  17+ 3FFA              ;
  18+ 3FFA              ;-------------------------------------------------------------------------------
  19+ 3FFA              ;
  20+ 3FFA              ;               6 x 8    C  H  A  R  S  E  T
  21+ 3FFA              ;
  22+ 3FFA              ;-------------------------------------------------------------------------------
  23+ 3FFA              ;
  24+ 3FFA              ;       6X8 CHARS, DESIGNED FOR TEXT BUT USABLE IN GRAPHICS 1 MODE TOO
  25+ 3FFA              ;       UPDATE: NOW GRAPHICS 1 MODE HAS ITS OWN CHAR SET
  26+ 3FFA
  27+ 3FFA              CHRST68 equ $
  28+ 3FFA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  28+ 3FFE 00 00 00 00
  29+ 4002 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  29+ 4006 00 00 00 00
  30+ 400A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  30+ 400E 00 00 00 00
  31+ 4012 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  31+ 4016 00 00 00 00
  32+ 401A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  32+ 401E 00 00 00 00
  33+ 4022 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  33+ 4026 00 00 00 00
  34+ 402A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  34+ 402E 00 00 00 00
  35+ 4032 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  35+ 4036 00 00 00 00
  36+ 403A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
  36+ 403E 00 00 00 00
  37+ 4042 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  37+ 4046 00 00 00 00
  38+ 404A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  38+ 404E 00 00 00 00
  39+ 4052 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11
  39+ 4056 00 00 00 00
  40+ 405A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  40+ 405E 00 00 00 00
  41+ 4062 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
  41+ 4066 00 00 00 00
  42+ 406A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
  42+ 406E 00 00 00 00
  43+ 4072 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  43+ 4076 00 00 00 00
  44+ 407A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  44+ 407E 00 00 00 00
  45+ 4082 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  45+ 4086 00 00 00 00
  46+ 408A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  46+ 408E 00 00 00 00
  47+ 4092 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  47+ 4096 00 00 00 00
  48+ 409A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
  48+ 409E 00 00 00 00
  49+ 40A2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  49+ 40A6 00 00 00 00
  50+ 40AA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
  50+ 40AE 00 00 00 00
  51+ 40B2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
  51+ 40B6 00 00 00 00
  52+ 40BA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
  52+ 40BE 00 00 00 00
  53+ 40C2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
  53+ 40C6 00 00 00 00
  54+ 40CA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
  54+ 40CE 00 00 00 00
  55+ 40D2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
  55+ 40D6 00 00 00 00
  56+ 40DA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
  56+ 40DE 00 00 00 00
  57+ 40E2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
  57+ 40E6 00 00 00 00
  58+ 40EA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
  58+ 40EE 00 00 00 00
  59+ 40F2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
  59+ 40F6 00 00 00 00
  60+ 40FA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32: space
  60+ 40FE 00 00 00 00
  61+ 4102 20 20 20 20          defb $20,$20,$20,$20,$20,$00,$20,$00 ; char 33: !
  61+ 4106 20 00 20 00
  62+ 410A 50 50 00 00          defb $50,$50,$00,$00,$00,$00,$00,$00 ; char 34: "
  62+ 410E 00 00 00 00
  63+ 4112 50 50 F8 50          defb $50,$50,$f8,$50,$f8,$50,$50,$00 ; char 35: #
  63+ 4116 F8 50 50 00
  64+ 411A 20 78 A0 70          defb $20,$78,$a0,$70,$28,$f0,$20,$00 ; char 36: $
  64+ 411E 28 F0 20 00
  65+ 4122 C0 C8 10 20          defb $c0,$c8,$10,$20,$40,$98,$18,$00 ; char 37: %
  65+ 4126 40 98 18 00
  66+ 412A 60 90 A0 40          defb $60,$90,$a0,$40,$a8,$90,$68,$00 ; char 38: &
  66+ 412E A8 90 68 00
  67+ 4132 60 20 40 00          defb $60,$20,$40,$00,$00,$00,$00,$00 ; char 39: '
  67+ 4136 00 00 00 00
  68+ 413A 10 20 40 40          defb $10,$20,$40,$40,$40,$20,$10,$00 ; char 40: (
  68+ 413E 40 20 10 00
  69+ 4142 40 20 10 10          defb $40,$20,$10,$10,$10,$20,$40,$00 ; char 41: )
  69+ 4146 10 20 40 00
  70+ 414A 00 20 A8 70          defb $00,$20,$a8,$70,$a8,$20,$00,$00 ; char 42: *
  70+ 414E A8 20 00 00
  71+ 4152 00 20 20 F8          defb $00,$20,$20,$f8,$20,$20,$00,$00 ; char 43: +
  71+ 4156 20 20 00 00
  72+ 415A 00 00 00 00          defb $00,$00,$00,$00,$60,$20,$40,$00 ; char 44: ,
  72+ 415E 60 20 40 00
  73+ 4162 00 00 00 F8          defb $00,$00,$00,$f8,$00,$00,$00,$00 ; char 45: -
  73+ 4166 00 00 00 00
  74+ 416A 00 00 00 00          defb $00,$00,$00,$00,$00,$60,$60,$00 ; char 46: .
  74+ 416E 00 60 60 00
  75+ 4172 00 08 10 20          defb $00,$08,$10,$20,$40,$80,$00,$00 ; char 47: /
  75+ 4176 40 80 00 00
  76+ 417A 70 88 98 A8          defb $70,$88,$98,$a8,$c8,$88,$70,$00 ; char 48: 0
  76+ 417E C8 88 70 00
  77+ 4182 20 60 20 20          defb $20,$60,$20,$20,$20,$20,$70,$00 ; char 49: 1
  77+ 4186 20 20 70 00
  78+ 418A 70 88 08 10          defb $70,$88,$08,$10,$20,$40,$f8,$00 ; char 50: 2
  78+ 418E 20 40 F8 00
  79+ 4192 F8 10 20 10          defb $f8,$10,$20,$10,$08,$88,$70,$00 ; char 51: 3
  79+ 4196 08 88 70 00
  80+ 419A 10 30 50 90          defb $10,$30,$50,$90,$f8,$10,$10,$00 ; char 52: 4
  80+ 419E F8 10 10 00
  81+ 41A2 F8 80 F0 08          defb $f8,$80,$f0,$08,$08,$88,$70,$00 ; char 53: 5
  81+ 41A6 08 88 70 00
  82+ 41AA 30 40 80 F0          defb $30,$40,$80,$f0,$88,$88,$70,$00 ; char 54: 6
  82+ 41AE 88 88 70 00
  83+ 41B2 F8 08 10 20          defb $f8,$08,$10,$20,$40,$40,$40,$00 ; char 55: 7
  83+ 41B6 40 40 40 00
  84+ 41BA 70 88 88 70          defb $70,$88,$88,$70,$88,$88,$70,$00 ; char 56: 8
  84+ 41BE 88 88 70 00
  85+ 41C2 70 88 88 78          defb $70,$88,$88,$78,$08,$10,$60,$00 ; char 57: 9
  85+ 41C6 08 10 60 00
  86+ 41CA 00 30 30 00          defb $00,$30,$30,$00,$30,$30,$00,$00 ; char 58: :
  86+ 41CE 30 30 00 00
  87+ 41D2 00 30 30 00          defb $00,$30,$30,$00,$30,$10,$20,$00 ; char 59: ;
  87+ 41D6 30 10 20 00
  88+ 41DA 10 20 40 80          defb $10,$20,$40,$80,$40,$20,$10,$00 ; char 60: <
  88+ 41DE 40 20 10 00
  89+ 41E2 00 00 F8 00          defb $00,$00,$f8,$00,$f8,$00,$00,$00 ; char 61: =
  89+ 41E6 F8 00 00 00
  90+ 41EA 40 20 10 08          defb $40,$20,$10,$08,$10,$20,$40,$00 ; char 62: >
  90+ 41EE 10 20 40 00
  91+ 41F2 70 88 08 10          defb $70,$88,$08,$10,$20,$00,$20,$00 ; char 63: ?
  91+ 41F6 20 00 20 00
  92+ 41FA 70 88 08 68          defb $70,$88,$08,$68,$a8,$a8,$70,$00 ; char 64: @
  92+ 41FE A8 A8 70 00
  93+ 4202 70 88 88 88          defb $70,$88,$88,$88,$f8,$88,$88,$00 ; char 65: A
  93+ 4206 F8 88 88 00
  94+ 420A F0 88 88 F0          defb $f0,$88,$88,$f0,$88,$88,$f0,$00 ; char 66: B
  94+ 420E 88 88 F0 00
  95+ 4212 70 88 80 80          defb $70,$88,$80,$80,$80,$88,$70,$00 ; char 67: C
  95+ 4216 80 88 70 00
  96+ 421A E0 90 88 88          defb $e0,$90,$88,$88,$88,$90,$e0,$00 ; char 68: D
  96+ 421E 88 90 E0 00
  97+ 4222 F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$f8,$00 ; char 69: E
  97+ 4226 80 80 F8 00
  98+ 422A F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$80,$00 ; char 70: F
  98+ 422E 80 80 80 00
  99+ 4232 70 88 80 B8          defb $70,$88,$80,$b8,$88,$88,$78,$00 ; char 71: G
  99+ 4236 88 88 78 00
 100+ 423A 88 88 88 F8          defb $88,$88,$88,$f8,$88,$88,$88,$00 ; char 72: H
 100+ 423E 88 88 88 00
 101+ 4242 70 20 20 20          defb $70,$20,$20,$20,$20,$20,$70,$00 ; char 73: I
 101+ 4246 20 20 70 00
 102+ 424A 38 10 10 10          defb $38,$10,$10,$10,$10,$90,$60,$00 ; char 74: J
 102+ 424E 10 90 60 00
 103+ 4252 88 90 A0 C0          defb $88,$90,$a0,$c0,$a0,$90,$88,$00 ; char 75: K
 103+ 4256 A0 90 88 00
 104+ 425A 80 80 80 80          defb $80,$80,$80,$80,$80,$80,$f8,$00 ; char 76: L
 104+ 425E 80 80 F8 00
 105+ 4262 88 D8 A8 A8          defb $88,$d8,$a8,$a8,$88,$88,$88,$00 ; char 77: M
 105+ 4266 88 88 88 00
 106+ 426A 88 C8 A8 98          defb $88,$c8,$a8,$98,$88,$88,$88,$00 ; char 78: N
 106+ 426E 88 88 88 00
 107+ 4272 70 88 88 88          defb $70,$88,$88,$88,$88,$88,$70,$00 ; char 79: O
 107+ 4276 88 88 70 00
 108+ 427A F0 88 88 F0          defb $f0,$88,$88,$f0,$80,$80,$80,$00 ; char 80: P
 108+ 427E 80 80 80 00
 109+ 4282 70 88 88 88          defb $70,$88,$88,$88,$a8,$90,$68,$00 ; char 81: Q
 109+ 4286 A8 90 68 00
 110+ 428A F0 88 88 F0          defb $f0,$88,$88,$f0,$a0,$90,$88,$00 ; char 82: R
 110+ 428E A0 90 88 00
 111+ 4292 78 80 80 70          defb $78,$80,$80,$70,$08,$08,$f0,$00 ; char 83: S
 111+ 4296 08 08 F0 00
 112+ 429A F8 20 20 20          defb $f8,$20,$20,$20,$20,$20,$20,$00 ; char 84: T
 112+ 429E 20 20 20 00
 113+ 42A2 88 88 88 88          defb $88,$88,$88,$88,$88,$88,$70,$00 ; char 85: U
 113+ 42A6 88 88 70 00
 114+ 42AA 88 88 88 88          defb $88,$88,$88,$88,$88,$50,$20,$00 ; char 86: V
 114+ 42AE 88 50 20 00
 115+ 42B2 88 88 88 88          defb $88,$88,$88,$88,$a8,$a8,$50,$00 ; char 87: W
 115+ 42B6 A8 A8 50 00
 116+ 42BA 88 88 50 20          defb $88,$88,$50,$20,$50,$88,$88,$00 ; char 88: X
 116+ 42BE 50 88 88 00
 117+ 42C2 88 88 88 50          defb $88,$88,$88,$50,$20,$20,$20,$00 ; char 89: Y
 117+ 42C6 20 20 20 00
 118+ 42CA F8 08 10 20          defb $f8,$08,$10,$20,$40,$80,$f8,$00 ; char 90: Z
 118+ 42CE 40 80 F8 00
 119+ 42D2 70 40 40 40          defb $70,$40,$40,$40,$40,$40,$70,$00 ; char 91: [
 119+ 42D6 40 40 70 00
 120+ 42DA 00 80 40 20          defb $00,$80,$40,$20,$10,$08,$00,$00 ; char 92: \
 120+ 42DE 10 08 00 00
 121+ 42E2 70 10 10 10          defb $70,$10,$10,$10,$10,$10,$70,$00 ; char 93: ]
 121+ 42E6 10 10 70 00
 122+ 42EA 20 50 88 00          defb $20,$50,$88,$00,$00,$00,$00,$00 ; char 94: ^
 122+ 42EE 00 00 00 00
 123+ 42F2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$FC ; char 95: _ (underscore)
 123+ 42F6 00 00 00 FC
 124+ 42FA 40 20 10 00          defb $40,$20,$10,$00,$00,$00,$00,$00 ; char 96: `
 124+ 42FE 00 00 00 00
 125+ 4302 00 00 70 08          defb $00,$00,$70,$08,$78,$88,$78,$00 ; char 97: a
 125+ 4306 78 88 78 00
 126+ 430A 80 80 80 B0          defb $80,$80,$80,$b0,$c8,$88,$f0,$00 ; char 98: b
 126+ 430E C8 88 F0 00
 127+ 4312 00 00 70 80          defb $00,$00,$70,$80,$80,$88,$70,$00 ; char 99: c
 127+ 4316 80 88 70 00
 128+ 431A 08 08 08 68          defb $08,$08,$08,$68,$98,$88,$78,$00 ; char 100: d
 128+ 431E 98 88 78 00
 129+ 4322 00 00 70 88          defb $00,$00,$70,$88,$f8,$80,$70,$00 ; char 101: e
 129+ 4326 F8 80 70 00
 130+ 432A 30 48 40 E0          defb $30,$48,$40,$e0,$40,$40,$40,$00 ; char 102: f
 130+ 432E 40 40 40 00
 131+ 4332 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$70,$00 ; char 103: g
 131+ 4336 78 08 70 00
 132+ 433A 80 80 B0 C8          defb $80,$80,$b0,$c8,$88,$88,$88,$00 ; char 104: h
 132+ 433E 88 88 88 00
 133+ 4342 20 00 20 20          defb $20,$00,$20,$20,$20,$20,$20,$00 ; char 105: i
 133+ 4346 20 20 20 00
 134+ 434A 08 00 18 08          defb $08,$00,$18,$08,$08,$88,$70,$00 ; char 106: j
 134+ 434E 08 88 70 00
 135+ 4352 80 80 90 A0          defb $80,$80,$90,$a0,$c0,$a0,$90,$00 ; char 107: k
 135+ 4356 C0 A0 90 00
 136+ 435A 60 20 20 20          defb $60,$20,$20,$20,$20,$20,$70,$00 ; char 108: l
 136+ 435E 20 20 70 00
 137+ 4362 00 00 D0 A8          defb $00,$00,$d0,$a8,$a8,$88,$88,$00 ; char 109: m
 137+ 4366 A8 88 88 00
 138+ 436A 00 00 B0 C8          defb $00,$00,$b0,$c8,$88,$88,$88,$00 ; char 110: n
 138+ 436E 88 88 88 00
 139+ 4372 00 00 70 88          defb $00,$00,$70,$88,$88,$88,$70,$00 ; char 111: o
 139+ 4376 88 88 70 00
 140+ 437A 00 00 F0 88          defb $00,$00,$f0,$88,$f0,$80,$80,$00 ; char 112: p
 140+ 437E F0 80 80 00
 141+ 4382 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$08,$00 ; char 113: q
 141+ 4386 78 08 08 00
 142+ 438A 00 00 B0 C8          defb $00,$00,$b0,$c8,$80,$80,$80,$00 ; char 114: r
 142+ 438E 80 80 80 00
 143+ 4392 00 00 70 80          defb $00,$00,$70,$80,$70,$08,$f0,$00 ; char 115: s
 143+ 4396 70 08 F0 00
 144+ 439A 40 40 E0 40          defb $40,$40,$e0,$40,$40,$48,$30,$00 ; char 116: t
 144+ 439E 40 48 30 00
 145+ 43A2 00 00 88 88          defb $00,$00,$88,$88,$88,$98,$68,$00 ; char 117: u
 145+ 43A6 88 98 68 00
 146+ 43AA 00 00 88 88          defb $00,$00,$88,$88,$88,$50,$20,$00 ; char 118: v
 146+ 43AE 88 50 20 00
 147+ 43B2 00 00 88 88          defb $00,$00,$88,$88,$a8,$a8,$50,$00 ; char 119: w
 147+ 43B6 A8 A8 50 00
 148+ 43BA 00 00 88 50          defb $00,$00,$88,$50,$20,$50,$88,$00 ; char 120: x
 148+ 43BE 20 50 88 00
 149+ 43C2 00 00 88 98          defb $00,$00,$88,$98,$68,$08,$70,$00 ; char 121: y
 149+ 43C6 68 08 70 00
 150+ 43CA 00 00 F8 10          defb $00,$00,$f8,$10,$20,$40,$f8,$00 ; char 122: z
 150+ 43CE 20 40 F8 00
 151+ 43D2 10 20 20 40          defb $10,$20,$20,$40,$20,$20,$10,$00 ; char 123: {
 151+ 43D6 20 20 10 00
 152+ 43DA 20 20 20 20          defb $20,$20,$20,$20,$20,$20,$20,$00 ; char 124: |
 152+ 43DE 20 20 20 00
 153+ 43E2 20 10 10 08          defb $20,$10,$10,$08,$10,$10,$20,$00 ; char 125: }
 153+ 43E6 10 10 20 00
 154+ 43EA 00 28 50 00          defb $00,$28,$50,$00,$00,$00,$00,$00 ; char 126: ~
 154+ 43EE 00 00 00 00
 155+ 43F2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 127: (delete) - here end the standard ASCII (0-127)
 155+ 43F6 00 00 00 00
 156+ 43FA 78 84 CC 84          defb %01111000,%10000100,%11001100,%10000100,%10110100,%10000100,%01111000,%00000000 ; char 128 (open face)
 156+ 43FE B4 84 78 00
 157+ 4402 78 FC B4 FC          defb %01111000,%11111100,%10110100,%11111100,%10110100,%11001100,%01111000,%00000000 ; char 129 (full face)
 157+ 4406 B4 CC 78 00
 158+ 440A 48 FC FC FC          defb %01001000,%11111100,%11111100,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 130 (hearts)
 158+ 440E FC 78 30 00
 159+ 4412 00 20 70 F8          defb %00000000,%00100000,%01110000,%11111000,%11111000,%01110000,%00100000,%00000000 ; char 131 (diamonds)
 159+ 4416 F8 70 20 00
 160+ 441A 70 20 A8 F8          defb %01110000,%00100000,%10101000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 132 (clubs)
 160+ 441E A8 20 70 00
 161+ 4422 20 70 F8 F8          defb %00100000,%01110000,%11111000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 133 (spades)
 161+ 4426 A8 20 70 00
 162+ 442A 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 134
 162+ 442E FC 30 30 30
 163+ 4432 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 135
 163+ 4436 3C 30 30 30
 164+ 443A 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 136
 164+ 443E F0 30 30 30
 165+ 4442 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00000000,%00000000,%00000000 ; char 137
 165+ 4446 F0 00 00 00
 166+ 444A 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00000000,%00000000,%00000000 ; char 138
 166+ 444E 3C 00 00 00
 167+ 4452 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 139
 167+ 4456 FC 00 00 00
 168+ 445A 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 140
 168+ 445E 3C 30 30 30
 169+ 4462 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 141
 169+ 4466 FC 30 30 30
 170+ 446A 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 142
 170+ 446E F0 30 30 30
 171+ 4472 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 143
 171+ 4476 FC 00 00 00
 172+ 447A 30 30 30 30          defb %00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000 ; char 144
 172+ 447E 30 30 30 30
 173+ 4482 0C 1C 18 38          defb %00001100,%00011100,%00011000,%00111000,%01110000,%01100000,%11100000,%11000000 ; char 145
 173+ 4486 70 60 E0 C0
 174+ 448A C0 E0 60 70          defb %11000000,%11100000,%01100000,%01110000,%00111000,%00011000,%00011100,%00001100 ; char 146
 174+ 448E 38 18 1C 0C
 175+ 4492 CC CC 78 30          defb %11001100,%11001100,%01111000,%00110000,%00110000,%01111000,%11001100,%11001100 ; char 147
 175+ 4496 30 78 CC CC
 176+ 449A 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 148
 176+ 449E 20 20 20 20
 177+ 44A2 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 149
 177+ 44A6 20 20 20 20
 178+ 44AA 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 150
 178+ 44AE 20 20 20 20
 179+ 44B2 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 151
 179+ 44B6 00 00 00 00
 180+ 44BA 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00000000,%00000000,%00000000,%00000000 ; char 152
 180+ 44BE 00 00 00 00
 181+ 44C2 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 153
 181+ 44C6 00 00 00 00
 182+ 44CA 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 154
 182+ 44CE 20 20 20 20
 183+ 44D2 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 155
 183+ 44D6 20 20 20 20
 184+ 44DA 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 156
 184+ 44DE 20 20 20 20
 185+ 44E2 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 157
 185+ 44E6 00 00 00 00
 186+ 44EA 20 20 20 20          defb %00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000 ; char 158
 186+ 44EE 20 20 20 20
 187+ 44F2 04 08 08 10          defb %00000100,%00001000,%00001000,%00010000,%00100000,%01000000,%01000000,%10000000 ; char 159
 187+ 44F6 20 40 40 80
 188+ 44FA 80 40 40 20          defb %10000000,%01000000,%01000000,%00100000,%00010000,%00001000,%00001000,%00000100 ; char 160
 188+ 44FE 10 08 08 04
 189+ 4502 84 48 48 30          defb %10000100,%01001000,%01001000,%00110000,%00110000,%01001000,%01001000,%10000100 ; char 161
 189+ 4506 30 48 48 84
 190+ 450A 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 162
 190+ 450E 00 00 FC FC
 191+ 4512 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111100,%11111100,%11111100,%11111100 ; char 163
 191+ 4516 FC FC FC FC
 192+ 451A 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 164
 192+ 451E FC FC FC FC
 193+ 4522 FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 193+ 4526 00 00 00 00
 194+ 452A FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 166
 194+ 452E 00 00 00 00
 195+ 4532 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 167
 195+ 4536 FC FC 00 00
 196+ 453A 80 80 80 80          defb %10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000 ; char 168
 196+ 453E 80 80 80 80
 197+ 4542 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000 ; char 169
 197+ 4546 E0 E0 E0 E0
 198+ 454A F8 F8 F8 F8          defb %11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000 ; char 170
 198+ 454E F8 F8 F8 F8
 199+ 4552 04 04 04 04          defb %00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100 ; char 171
 199+ 4556 04 04 04 04
 200+ 455A 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100 ; char 172
 200+ 455E 1C 1C 1C 1C
 201+ 4562 7C 7C 7C 7C          defb %01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100 ; char 173
 201+ 4566 7C 7C 7C 7C
 202+ 456A FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 174
 202+ 456E 84 84 84 FC
 203+ 4572 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%11100000,%11100000,%11100000 ; char 175
 203+ 4576 E0 E0 E0 E0
 204+ 457A 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00011100,%00011100,%00011100 ; char 176
 204+ 457E 1C 1C 1C 1C
 205+ 4582 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 177
 205+ 4586 00 00 00 00
 206+ 458A E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 178
 206+ 458E 00 00 00 00
 207+ 4592 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00011100,%00011100,%00011100,%00011100 ; char 179
 207+ 4596 1C 1C 1C 1C
 208+ 459A 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%11100000,%11100000,%11100000,%11100000 ; char 180
 208+ 459E E0 E0 E0 E0
 209+ 45A2 78 78 78 78          defb %01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000 ; char 181
 209+ 45A6 78 78 78 78
 210+ 45AA CC CC CC CC          defb %11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100 ; char 182
 210+ 45AE CC CC CC CC
 211+ 45B2 FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 183
 211+ 45B6 00 00 FC FC
 212+ 45BA 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 184
 212+ 45BE FC FC 00 00
 213+ 45C2 30 30 CC CC          defb %00110000,%00110000,%11001100,%11001100,%00110000,%00110000,%11001100,%11001100 ; char 185
 213+ 45C6 30 30 CC CC
 214+ 45CA 54 A8 54 A8          defb %01010100,%10101000,%01010100,%10101000,%01010100,%10101000,%01010100,%10101000 ; char 186
 214+ 45CE 54 A8 54 A8
 215+ 45D2 64 30 98 CC          defb %01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100 ; char 187
 215+ 45D6 64 30 98 CC
 216+ 45DA CC 64 30 98          defb %11001100,%01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000 ; char 188
 216+ 45DE CC 64 30 98
 217+ 45E2 30 98 CC 64          defb %00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100,%01100100 ; char 189
 217+ 45E6 30 98 CC 64
 218+ 45EA 64 CC 98 30          defb %01100100,%11001100,%10011000,%00110000,%01100100,%11001100,%10011000,%00110000 ; char 190
 218+ 45EE 64 CC 98 30
 219+ 45F2 20 20 F8 20          defb %00100000,%00100000,%11111000,%00100000,%00100000,%00000000,%11111000,%00000000 ; char 191 (Â±)
 219+ 45F6 20 00 F8 00
 220+ 45FA C0 30 08 30          defb %11000000,%00110000,%00001000,%00110000,%11000000,%00000000,%11111000,%00000000 ; char 192 (â¥)
 220+ 45FE C0 00 F8 00
 221+ 4602 18 60 80 60          defb %00011000,%01100000,%10000000,%01100000,%00011000,%00000000,%11111000,%00000000 ; char 193 (â¤)
 221+ 4606 18 00 F8 00
 222+ 460A 3C 20 20 20          defb %00111100,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 222+ 460E A0 60 20 00
 223+ 4612 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 223+ 4616 00 00 00 00
 224+ 461A 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 224+ 461E 70 00 00 00
 225+ 4622 00 00 54 A8          defb %00000000,%00000000,%01010100,%10101000,%00000000,%11111100,%00000000,%00000000 ; char 197
 225+ 4626 00 FC 00 00
 226+ 462A 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 226+ 462E 54 A8 00 00
 227+ 4632 00 80 C0 E0          defb %00000000,%10000000,%11000000,%11100000,%11100000,%11000000,%10000000,%00000000 ; char 199
 227+ 4636 E0 C0 80 00
 228+ 463A FC 78 30 00          defb %11111100,%01111000,%00110000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 200
 228+ 463E 00 00 00 00
 229+ 4642 00 04 0C 1C          defb %00000000,%00000100,%00001100,%00011100,%00011100,%00001100,%00000100,%00000000 ; char 201
 229+ 4646 1C 0C 04 00
 230+ 464A 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00110000,%01111000,%11111100 ; char 202
 230+ 464E 00 30 78 FC
 231+ 4652 20 70 F8 20          defb %00100000,%01110000,%11111000,%00100000,%00100000,%00100000,%00100000,%00000000 ; char 203 (up arrow)
 231+ 4656 20 20 20 00
 232+ 465A 3C 1C 1C 24          defb %00111100,%00011100,%00011100,%00100100,%01000000,%10000000,%00000000,%00000000 ; char 204 (up right arrow)
 232+ 465E 40 80 00 00
 233+ 4662 00 10 18 FC          defb %00000000,%00010000,%00011000,%11111100,%00011000,%00010000,%00000000,%00000000 ; char 205 (right arrow)
 233+ 4666 18 10 00 00
 234+ 466A 00 00 80 40          defb %00000000,%00000000,%10000000,%01000000,%00100100,%00011100,%00011100,%00111100 ; char 206 (down right arrow)
 234+ 466E 24 1C 1C 3C
 235+ 4672 00 20 20 20          defb %00000000,%00100000,%00100000,%00100000,%00100000,%11111000,%01110000,%00100000 ; char 207 (down arrow)
 235+ 4676 20 F8 70 20
 236+ 467A 00 00 04 08          defb %00000000,%00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000 ; char 208 (down left arrow)
 236+ 467E 90 E0 E0 F0
 237+ 4682 00 20 60 FC          defb %00000000,%00100000,%01100000,%11111100,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 237+ 4686 60 20 00 00
 238+ 468A F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 238+ 468E 08 04 00 00
 239+ 4692 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 239+ 4696 F0 44 38 00
 240+ 469A 00 04 78 A8          defb %00000000,%00000100,%01111000,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 240+ 469E 28 28 28 00
 241+ 46A2 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00100000,%00100000,%00100000 ; char 213
 241+ 46A6 1C 20 20 20
 242+ 46AA 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%00010000,%00010000,%00010000 ; char 214
 242+ 46AE E0 10 10 10
 243+ 46B2 10 10 10 E0          defb %00010000,%00010000,%00010000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 215
 243+ 46B6 00 00 00 00
 244+ 46BA 20 20 20 1C          defb %00100000,%00100000,%00100000,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 216
 244+ 46BE 00 00 00 00
 245+ 46C2 00 00 00 1C          defb %00000000,%00000000,%00000000,%00011100,%00111100,%00110000,%00110000,%00110000 ; char 217
 245+ 46C6 3C 30 30 30
 246+ 46CA 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00110000,%00110000,%00110000 ; char 218
 246+ 46CE F0 30 30 30
 247+ 46D2 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 247+ 46D6 E0 00 00 00
 248+ 46DA 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00011100,%00000000,%00000000,%00000000 ; char 220
 248+ 46DE 1C 00 00 00
 249+ 46E2 00 30 48 48          defb %00000000,%00110000,%01001000,%01001000,%01001000,%00110000,%00000000,%00000000 ; char 221
 249+ 46E6 48 30 00 00
 250+ 46EA 00 30 78 78          defb %00000000,%00110000,%01111000,%01111000,%01111000,%00110000,%00000000,%00000000 ; char 222
 250+ 46EE 78 30 00 00
 251+ 46F2 00 30 78 FC          defb %00000000,%00110000,%01111000,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 223
 251+ 46F6 FC 78 30 00
 252+ 46FA FC F8 F0 E0          defb %11111100,%11111000,%11110000,%11100000,%11100000,%11000000,%10000000,%10000000 ; char 224
 252+ 46FE E0 C0 80 80
 253+ 4702 FC 7C 3C 1C          defb %11111100,%01111100,%00111100,%00011100,%00011100,%00001100,%00000100,%00000100 ; char 225
 253+ 4706 1C 0C 04 04
 254+ 470A 04 04 0C 1C          defb %00000100,%00000100,%00001100,%00011100,%00011100,%00111100,%01111100,%11111100 ; char 226
 254+ 470E 1C 3C 7C FC
 255+ 4712 80 80 C0 E0          defb %10000000,%10000000,%11000000,%11100000,%11100000,%11110000,%11111000,%11111100 ; char 227
 255+ 4716 E0 F0 F8 FC
 256+ 471A 00 04 0C D8          defb %00000000,%00000100,%00001100,%11011000,%11110000,%11100000,%11000000,%00000000 ; char 228 (checkmark)
 256+ 471E F0 E0 C0 00
 257+ 4722 00 CC 78 30          defb %00000000,%11001100,%01111000,%00110000,%01111000,%11001100,%00000000,%00000000 ; char 229 (x)
 257+ 4726 78 CC 00 00
 258+ 472A 70 88 88 88          defb %01110000,%10001000,%10001000,%10001000,%01110000,%00100000,%01110000,%00100000 ; char 230 (female)
 258+ 472E 70 20 70 20
 259+ 4732 00 1C 0C 74          defb %00000000,%00011100,%00001100,%01110100,%10010000,%10010000,%01100000,%00000000 ; char 231 (male)
 259+ 4736 90 90 60 00
 260+ 473A F8 84 84 84          defb %11111000,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 232 (new doc)
 260+ 473E 84 84 84 FC
 261+ 4742 00 F0 FC 84          defb %00000000,%11110000,%11111100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 233 (folder)
 261+ 4746 84 84 84 FC
 262+ 474A 30 78 FC 48          defb %00110000,%01111000,%11111100,%01001000,%01001000,%01001000,%01001000,%01111000 ; char 234 (trash bin)
 262+ 474E 48 48 48 78
 263+ 4752 FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%11111100,%10110100,%10110100,%11111100 ; char 235 (floppy disk)
 263+ 4756 FC B4 B4 FC
 264+ 475A 00 00 D4 D8          defb %00000000,%00000000,%11010100,%11011000,%11010100,%11010100,%00000000,%00000000 ; char 236 (OK)
 264+ 475E D4 D4 00 00
 265+ 4762 30 78 FC 78          defb %00110000,%01111000,%11111100,%01111000,%01111000,%01001000,%01001000,%01001000 ; char 237 (home)
 265+ 4766 78 48 48 48
 266+ 476A 78 84 A4 A4          defb %01111000,%10000100,%10100100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 238 (clock)
 266+ 476E B4 84 78 00
 267+ 4772 00 00 08 F4          defb %00000000,%00000000,%00001000,%11110100,%10101000,%10000000,%00000000,%00000000 ; char 239 (key)
 267+ 4776 A8 80 00 00
 268+ 477A 20 30 78 B0          defb %00100000,%00110000,%01111000,%10110000,%10100000,%10001000,%01110000,%00000000 ; char 240 (undo)
 268+ 477E A0 88 70 00
 269+ 4782 00 FC CC B4          defb %00000000,%11111100,%11001100,%10110100,%10000100,%10000100,%11111100,%00000000 ; char 241 (letter)
 269+ 4786 84 84 FC 00
 270+ 478A 60 90 90 F0          defb %01100000,%10010000,%10010000,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 242 (lock)
 270+ 478E F0 F0 F0 00
 271+ 4792 08 14 14 F0          defb %00001000,%00010100,%00010100,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 243 (unlock)
 271+ 4796 F0 F0 F0 00
 272+ 479A FC FC 84 B4          defb %11111100,%11111100,%10000100,%10110100,%10010100,%10010100,%10000100,%11111100 ; char 244 (calendar)
 272+ 479E 94 94 84 FC
 273+ 47A2 00 04 38 58          defb %00000000,%00000100,%00111000,%01011000,%01101000,%01110000,%10000000,%00000000 ; char 245 (diameter)
 273+ 47A6 68 70 80 00
 274+ 47AA 78 84 84 84          defb %01111000,%10000100,%10000100,%10000100,%01101100,%00011000,%00001000,%00000000 ; char 246 (baloon)
 274+ 47AE 6C 18 08 00
 275+ 47B2 30 28 28 28          defb %00110000,%00101000,%00101000,%00101000,%00100000,%01100000,%11100000,%01000000 ; char 247 (note)
 275+ 47B6 20 60 E0 40
 276+ 47BA 20 68 E4 E4          defb %00100000,%01101000,%11100100,%11100100,%11100100,%01101000,%00100000,%00000000 ; char 248 (audio on)
 276+ 47BE E4 68 20 00
 277+ 47C2 20 60 E0 E0          defb %00100000,%01100000,%11100000,%11100000,%11100000,%01100000,%00100000,%00000000 ; char 249 (audio off)
 277+ 47C6 E0 60 20 00
 278+ 47CA 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11110000,%10010000 ; char 250 (pointer)
 278+ 47CE F8 FC F0 90
 279+ 47D2 78 84 B4 A4          defb %01111000,%10000100,%10110100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 251 (Â©)
 279+ 47D6 B4 84 78 00
 280+ 47DA 30 48 40 E0          defb %00110000,%01001000,%01000000,%11100000,%01000000,%01001000,%10110000,%00000000 ; char 252 (Â£)
 280+ 47DE 40 48 B0 00
 281+ 47E2 78 84 F0 48          defb %01111000,%10000100,%11110000,%01001000,%01001000,%00111100,%10000100,%01111000 ; char 253 (Â§)
 281+ 47E6 48 3C 84 78
 282+ 47EA 00 00 20 00          defb %00000000,%00000000,%00100000,%00000000,%11111000,%00000000,%00100000,%00000000 ; char 254 (Ã·)
 282+ 47EE F8 00 20 00
 283+ 47F2 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 255 (cursor)
 283+ 47F6 FC FC FC FC
 284+ 47FA                      ; here ends the ASCII table
 285+ 47FA
# file closed: ../include/vdp/6x8fonts-r16.asm
  79  47FA                  INCLUDE "../include/vdp/8x8fonts-r18.asm"
# file opened: ../include/vdp/8x8fonts-r18.asm
   1+ 47FA              ; ------------------------------------------------------------------------------
   2+ 47FA              ; LM80C - 8x8 CHARSET - R1.8
   3+ 47FA              ; ------------------------------------------------------------------------------
   4+ 47FA              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 47FA              ; designed by Leonardo Miliani. More info at
   6+ 47FA              ; www DOT leonardomiliani DOT com
   7+ 47FA              ; ------------------------------------------------------------------------------
   8+ 47FA              ; Code Revision:
   9+ 47FA              ; R1.0 - 20190615 - First revision: ASCII chars (from 0 to 255) - actually, they are 6x8 pixels
  10+ 47FA              ; R1.1 - 20190616 - Converted to 8x8 pixels
  11+ 47FA              ; R1.2 - 20191013 - Added new graphic chars and reorganized previous ones
  12+ 47FA              ; R1.3 - 20191015 - More graphic chars
  13+ 47FA              ; R1.4 - 20191202 - Fixed char 11/12, added new special chars
  14+ 47FA              ; R1.5 - 20191210 - Changed several graphic chars
  15+ 47FA              ; R1.6 - 20200125 - Removed double chars, changed with new ones
  16+ 47FA              ; R1.7 - 20200228 - adopted more usual hexadecimal & binary prefixes
  17+ 47FA              ; R1.8 - 20200524 - New style for char #252
  18+ 47FA              ; ------------------------------------------------------------------------------
  19+ 47FA              ;
  20+ 47FA              ;-------------------------------------------------------------------------------
  21+ 47FA              ;
  22+ 47FA              ;               8 x 8    C  H  A  R  S  E  T
  23+ 47FA              ;
  24+ 47FA              ;-------------------------------------------------------------------------------
  25+ 47FA              ;
  26+ 47FA              ;       8X8 CHARS, DESIGNED FOR GRAPHICS 1 MODE
  27+ 47FA
  28+ 47FA              CHRST88 equ $
  29+ 47FA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  29+ 47FE 00 00 00 00
  30+ 4802 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  30+ 4806 00 00 00 00
  31+ 480A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  31+ 480E 00 00 00 00
  32+ 4812 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  32+ 4816 00 00 00 00
  33+ 481A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  33+ 481E 00 00 00 00
  34+ 4822 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  34+ 4826 00 00 00 00
  35+ 482A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  35+ 482E 00 00 00 00
  36+ 4832 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  36+ 4836 00 00 00 00
  37+ 483A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 DEL key (backspace)
  37+ 483E 00 00 00 00
  38+ 4842 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  38+ 4846 00 00 00 00
  39+ 484A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  39+ 484E 00 00 00 00
  40+ 4852 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 (unused)
  40+ 4856 00 00 00 00
  41+ 485A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  41+ 485E 00 00 00 00
  42+ 4862 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 RETURN key (carriage return)
  42+ 4866 00 00 00 00
  43+ 486A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL key
  43+ 486E 00 00 00 00
  44+ 4872 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  44+ 4876 00 00 00 00
  45+ 487A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  45+ 487E 00 00 00 00
  46+ 4882 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  46+ 4886 00 00 00 00
  47+ 488A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  47+ 488E 00 00 00 00
  48+ 4892 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  48+ 4896 00 00 00 00
  49+ 489A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT key
  49+ 489E 00 00 00 00
  50+ 48A2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  50+ 48A6 00 00 00 00
  51+ 48AA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6 key
  51+ 48AE 00 00 00 00
  52+ 48B2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7 key
  52+ 48B6 00 00 00 00
  53+ 48BA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP key
  53+ 48BE 00 00 00 00
  54+ 48C2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 HOME key
  54+ 48C6 00 00 00 00
  55+ 48CA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26 INSERT key
  55+ 48CE 00 00 00 00
  56+ 48D2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 ESCAPE key
  56+ 48D6 00 00 00 00
  57+ 48DA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 CRSR LEFT key (cursor left)
  57+ 48DE 00 00 00 00
  58+ 48E2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 CRSR RIGHT key (cursor right)
  58+ 48E6 00 00 00 00
  59+ 48EA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 CRSR UP key (cursor up)
  59+ 48EE 00 00 00 00
  60+ 48F2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 CRSR DOWN key (cursor down)
  60+ 48F6 00 00 00 00
  61+ 48FA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32 SPACE key
  61+ 48FE 00 00 00 00
  62+ 4902 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00000000,%00010000,%00000000 ; char 33 - !
  62+ 4906 10 00 10 00
  63+ 490A 28 28 28 00          defb %00101000,%00101000,%00101000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 34 - "
  63+ 490E 00 00 00 00
  64+ 4912 28 28 FE 28          defb %00101000,%00101000,%11111110,%00101000,%11111110,%00101000,%00101000,%00000000 ; char 35 - #
  64+ 4916 FE 28 28 00
  65+ 491A 10 3C 50 38          defb %00010000,%00111100,%01010000,%00111000,%00010100,%01111000,%00010000,%00000000 ; char 36 - $
  65+ 491E 14 78 10 00
  66+ 4922 00 62 64 08          defb %00000000,%01100010,%01100100,%00001000,%00010000,%00100110,%01000110,%00000000 ; char 37 - %
  66+ 4926 10 26 46 00
  67+ 492A 00 30 48 30          defb %00000000,%00110000,%01001000,%00110000,%01001010,%01000100,%00111010,%00000000 ; char 38 - &
  67+ 492E 4A 44 3A 00
  68+ 4932 08 10 20 00          defb %00001000,%00010000,%00100000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 39 - '
  68+ 4936 00 00 00 00
  69+ 493A 08 10 20 20          defb %00001000,%00010000,%00100000,%00100000,%00100000,%00010000,%00001000,%00000000 ; char 40 - (
  69+ 493E 20 10 08 00
  70+ 4942 20 10 08 08          defb %00100000,%00010000,%00001000,%00001000,%00001000,%00010000,%00100000,%00000000 ; char 41 - )
  70+ 4946 08 10 20 00
  71+ 494A 00 10 54 38          defb %00000000,%00010000,%01010100,%00111000,%00111000,%01010100,%00010000,%00000000 ; char 42 - *
  71+ 494E 38 54 10 00
  72+ 4952 00 10 10 7C          defb %00000000,%00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%00000000 ; char 43 - +
  72+ 4956 10 10 00 00
  73+ 495A 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00001000,%00010000 ; char 44 - ,
  73+ 495E 00 18 08 10
  74+ 4962 00 00 00 7C          defb %00000000,%00000000,%00000000,%01111100,%00000000,%00000000,%00000000,%00000000 ; char 45 - -
  74+ 4966 00 00 00 00
  75+ 496A 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00011000,%00000000 ; char 46 - .
  75+ 496E 00 18 18 00
  76+ 4972 00 02 04 08          defb %00000000,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%00000000 ; char 47 - /
  76+ 4976 10 20 40 00
  77+ 497A 38 44 4C 54          defb %00111000,%01000100,%01001100,%01010100,%01100100,%01000100,%00111000,%00000000 ; char 48 - 0
  77+ 497E 64 44 38 00
  78+ 4982 10 30 50 10          defb %00010000,%00110000,%01010000,%00010000,%00010000,%00010000,%01111100,%00000000 ; char 49 - 1
  78+ 4986 10 10 7C 00
  79+ 498A 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 50 - 2
  79+ 498E 10 20 7C 00
  80+ 4992 7C 08 10 08          defb %01111100,%00001000,%00010000,%00001000,%00000100,%01000100,%00111000,%00000000 ; char 51 - 3
  80+ 4996 04 44 38 00
  81+ 499A 08 18 28 48          defb %00001000,%00011000,%00101000,%01001000,%01111100,%00001000,%00001000,%00000000 ; char 52 - 4
  81+ 499E 7C 08 08 00
  82+ 49A2 7C 40 78 04          defb %01111100,%01000000,%01111000,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 53 - 5
  82+ 49A6 04 44 38 00
  83+ 49AA 38 44 40 78          defb %00111000,%01000100,%01000000,%01111000,%01000100,%01000100,%00111000,%00000000 ; char 54 - 6
  83+ 49AE 44 44 38 00
  84+ 49B2 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%00100000,%00100000,%00000000 ; char 55 - 7
  84+ 49B6 20 20 20 00
  85+ 49BA 38 44 44 38          defb %00111000,%01000100,%01000100,%00111000,%01000100,%01000100,%00111000,%00000000 ; char 56 - 8
  85+ 49BE 44 44 38 00
  86+ 49C2 38 44 44 3C          defb %00111000,%01000100,%01000100,%00111100,%00000100,%01000100,%00111000,%00000000 ; char 57 - 9
  86+ 49C6 04 44 38 00
  87+ 49CA 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00011000,%00000000,%00000000 ; char 58 - :
  87+ 49CE 18 18 00 00
  88+ 49D2 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00001000,%00010000,%00000000 ; char 59 - ;
  88+ 49D6 18 08 10 00
  89+ 49DA 04 08 10 20          defb %00000100,%00001000,%00010000,%00100000,%00010000,%00001000,%00000100,%00000000 ; char 60 - <
  89+ 49DE 10 08 04 00
  90+ 49E2 00 00 7E 00          defb %00000000,%00000000,%01111110,%00000000,%01111110,%00000000,%00000000,%00000000 ; char 61 - =
  90+ 49E6 7E 00 00 00
  91+ 49EA 20 10 08 04          defb %00100000,%00010000,%00001000,%00000100,%00001000,%00010000,%00100000,%00000000 ; char 62 - >
  91+ 49EE 08 10 20 00
  92+ 49F2 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00000000,%00010000,%00000000 ; char 63 - ?
  92+ 49F6 10 00 10 00
  93+ 49FA 78 84 BC AC          defb %01111000,%10000100,%10111100,%10101100,%10111000,%10000000,%10000100,%01111000 ; char 64 - @
  93+ 49FE B8 80 84 78
  94+ 4A02 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%00000000 ; char 65 - A
  94+ 4A06 7C 44 44 00
  95+ 4A0A 78 44 44 78          defb %01111000,%01000100,%01000100,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 66 - B
  95+ 4A0E 44 44 78 00
  96+ 4A12 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 67 - C
  96+ 4A16 40 44 38 00
  97+ 4A1A 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01000100,%01000100,%01111000,%00000000 ; char 68 - D
  97+ 4A1E 44 44 78 00
  98+ 4A22 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01111100,%00000000 ; char 69 - E
  98+ 4A26 40 40 7C 00
  99+ 4A2A 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01000000,%00000000 ; char 70 - F
  99+ 4A2E 40 40 40 00
 100+ 4A32 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01011100,%01000100,%00111000,%00000000 ; char 71 - G
 100+ 4A36 5C 44 38 00
 101+ 4A3A 44 44 44 7C          defb %01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%01000100,%00000000 ; char 72 - H
 101+ 4A3E 44 44 44 00
 102+ 4A42 38 10 10 10          defb %00111000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 73 - I
 102+ 4A46 10 10 38 00
 103+ 4A4A 3C 04 04 04          defb %00111100,%00000100,%00000100,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 74 - J
 103+ 4A4E 04 44 38 00
 104+ 4A52 44 44 48 70          defb %01000100,%01000100,%01001000,%01110000,%01001000,%01000100,%01000100,%00000000 ; char 75 - K
 104+ 4A56 48 44 44 00
 105+ 4A5A 40 40 40 40          defb %01000000,%01000000,%01000000,%01000000,%01000000,%01000000,%01111100,%00000000 ; char 76 - L
 105+ 4A5E 40 40 7C 00
 106+ 4A62 42 66 5A 42          defb %01000010,%01100110,%01011010,%01000010,%01000010,%01000010,%01000010,%00000000 ; char 77 - M
 106+ 4A66 42 42 42 00
 107+ 4A6A 44 64 54 4C          defb %01000100,%01100100,%01010100,%01001100,%01000100,%01000100,%01000100,%00000000 ; char 78 - N
 107+ 4A6E 44 44 44 00
 108+ 4A72 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 79 - O
 108+ 4A76 44 44 38 00
 109+ 4A7A 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01000000,%01000000,%00000000 ; char 80 - P
 109+ 4A7E 78 40 40 00
 110+ 4A82 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01010100,%01001000,%00110100,%00000000 ; char 81 - Q
 110+ 4A86 54 48 34 00
 111+ 4A8A 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01001000,%01000100,%00000000 ; char 82 - R
 111+ 4A8E 78 48 44 00
 112+ 4A92 3C 40 40 38          defb %00111100,%01000000,%01000000,%00111000,%00000100,%00000100,%01111000,%00000000 ; char 83 - S
 112+ 4A96 04 04 78 00
 113+ 4A9A 7C 10 10 10          defb %01111100,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 84 - T
 113+ 4A9E 10 10 10 00
 114+ 4AA2 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 85 - U
 114+ 4AA6 44 44 38 00
 115+ 4AAA 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 86 - V
 115+ 4AAE 44 28 10 00
 116+ 4AB2 42 42 42 42          defb %01000010,%01000010,%01000010,%01000010,%01011010,%01011010,%00100100,%00000000 ; char 87 - W
 116+ 4AB6 5A 5A 24 00
 117+ 4ABA 44 44 28 10          defb %01000100,%01000100,%00101000,%00010000,%00101000,%01000100,%01000100,%00000000 ; char 88 - X
 117+ 4ABE 28 44 44 00
 118+ 4AC2 44 44 44 28          defb %01000100,%01000100,%01000100,%00101000,%00010000,%00010000,%00010000,%00000000 ; char 89 - Y
 118+ 4AC6 10 10 10 00
 119+ 4ACA 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%01000000,%01111100,%00000000 ; char 90 - Z
 119+ 4ACE 20 40 7C 00
 120+ 4AD2 38 20 20 20          defb %00111000,%00100000,%00100000,%00100000,%00100000,%00100000,%00111000,%00000000 ; char 91 - [
 120+ 4AD6 20 20 38 00
 121+ 4ADA 00 40 20 10          defb %00000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000000 ; char 92 - \
 121+ 4ADE 08 04 02 00
 122+ 4AE2 38 08 08 08          defb %00111000,%00001000,%00001000,%00001000,%00001000,%00001000,%00111000,%00000000 ; char 93 - ]
 122+ 4AE6 08 08 38 00
 123+ 4AEA 10 28 44 00          defb %00010000,%00101000,%01000100,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 94 - ^
 123+ 4AEE 00 00 00 00
 124+ 4AF2 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%01111110,%00000000 ; char 95 _ (underscore)
 124+ 4AF6 00 00 7E 00
 125+ 4AFA 20 10 08 00          defb %00100000,%00010000,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 96 - `
 125+ 4AFE 00 00 00 00
 126+ 4B02 00 00 38 04          defb %00000000,%00000000,%00111000,%00000100,%00111100,%01000100,%00111100,%00000000 ; char 97 - a
 126+ 4B06 3C 44 3C 00
 127+ 4B0A 40 40 40 78          defb %01000000,%01000000,%01000000,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 98 - b
 127+ 4B0E 44 44 78 00
 128+ 4B12 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 99 - c
 128+ 4B16 40 44 38 00
 129+ 4B1A 04 04 04 3C          defb %00000100,%00000100,%00000100,%00111100,%01000100,%01000100,%00111100,%00000000 ; char 100 - d
 129+ 4B1E 44 44 3C 00
 130+ 4B22 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01111100,%01000000,%00111000,%00000000 ; char 101 - e
 130+ 4B26 7C 40 38 00
 131+ 4B2A 18 24 20 70          defb %00011000,%00100100,%00100000,%01110000,%00100000,%00100000,%00100000,%00000000 ; char 102 - f
 131+ 4B2E 20 20 20 00
 132+ 4B32 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00111000 ; char 103 - g
 132+ 4B36 44 3C 04 38
 133+ 4B3A 40 40 58 64          defb %01000000,%01000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 104 - h
 133+ 4B3E 44 44 44 00
 134+ 4B42 00 10 00 10          defb %00000000,%00010000,%00000000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 105 - i
 134+ 4B46 10 10 10 00
 135+ 4B4A 08 00 18 08          defb %00001000,%00000000,%00011000,%00001000,%00001000,%00001000,%01001000,%00110000 ; char 106 - j
 135+ 4B4E 08 08 48 30
 136+ 4B52 40 40 48 50          defb %01000000,%01000000,%01001000,%01010000,%01100000,%01010000,%01001000,%00000000 ; char 107 - k
 136+ 4B56 60 50 48 00
 137+ 4B5A 30 10 10 10          defb %00110000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 108 - l
 137+ 4B5E 10 10 38 00
 138+ 4B62 00 00 54 6A          defb %00000000,%00000000,%01010100,%01101010,%01001010,%01000010,%01000010,%00000000 ; char 109 - m
 138+ 4B66 4A 42 42 00
 139+ 4B6A 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 110 - n
 139+ 4B6E 44 44 44 00
 140+ 4B72 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 111: o
 140+ 4B76 44 44 38 00
 141+ 4B7A 00 00 78 44          defb %00000000,%00000000,%01111000,%01000100,%01000100,%01111000,%01000000,%01000000 ; char 112: p
 141+ 4B7E 44 78 40 40
 142+ 4B82 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00000100 ; char 113: q
 142+ 4B86 44 3C 04 04
 143+ 4B8A 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000000,%01000000,%01000000,%00000000 ; char 114: r
 143+ 4B8E 40 40 40 00
 144+ 4B92 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%00111000,%00000100,%01111000,%00000000 ; char 115: s
 144+ 4B96 38 04 78 00
 145+ 4B9A 20 20 70 20          defb %00100000,%00100000,%01110000,%00100000,%00100000,%00100100,%00011000,%00000000 ; char 116: t
 145+ 4B9E 20 24 18 00
 146+ 4BA2 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%01001100,%00110100,%00000000 ; char 117: u
 146+ 4BA6 44 4C 34 00
 147+ 4BAA 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 118: v
 147+ 4BAE 44 28 10 00
 148+ 4BB2 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01010100,%01010100,%00101000,%00000000 ; char 119: w
 148+ 4BB6 54 54 28 00
 149+ 4BBA 00 00 44 28          defb %00000000,%00000000,%01000100,%00101000,%00010000,%00101000,%01000100,%00000000 ; char 120: x
 149+ 4BBE 10 28 44 00
 150+ 4BC2 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01001100,%00110100,%00000100,%00111000 ; char 121: y
 150+ 4BC6 4C 34 04 38
 151+ 4BCA 00 00 7C 08          defb %00000000,%00000000,%01111100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 122: z
 151+ 4BCE 10 20 7C 00
 152+ 4BD2 18 20 20 40          defb %00011000,%00100000,%00100000,%01000000,%00100000,%00100000,%00011000,%00000000 ; char 123: {
 152+ 4BD6 20 20 18 00
 153+ 4BDA 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 124: |
 153+ 4BDE 10 10 10 00
 154+ 4BE2 30 08 08 04          defb %00110000,%00001000,%00001000,%00000100,%00001000,%00001000,%00110000,%00000000 ; char 125: }
 154+ 4BE6 08 08 30 00
 155+ 4BEA 20 54 08 00          defb %00100000,%01010100,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 126: ~
 155+ 4BEE 00 00 00 00
 156+ 4BF2 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 127 (delete) - end the standard ASCII (0-127)
 156+ 4BF6 00 00 00 00
 157+ 4BFA 3C 42 A5 81          defb %00111100,%01000010,%10100101,%10000001,%10100101,%10011001,%01000010,%00111100 ; char 128 (open face)
 157+ 4BFE A5 99 42 3C
 158+ 4C02 3C 7E DB FF          defb %00111100,%01111110,%11011011,%11111111,%11011011,%11100111,%01111110,%00111100 ; char 129 (full face)
 158+ 4C06 DB E7 7E 3C
 159+ 4C0A 6C FE FE FE          defb %01101100,%11111110,%11111110,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 130 (hearts)
 159+ 4C0E 7C 38 10 00
 160+ 4C12 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 131 (diamonds)
 160+ 4C16 7C 38 10 00
 161+ 4C1A 10 38 54 FE          defb %00010000,%00111000,%01010100,%11111110,%01010100,%00010000,%01111100,%00000000 ; char 132 (clus)
 161+ 4C1E 54 10 7C 00
 162+ 4C22 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%11010110,%00010000,%01111100,%00000000 ; char 133 (spades)
 162+ 4C26 D6 10 7C 00
 163+ 4C2A 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 134
 163+ 4C2E FF 18 18 18
 164+ 4C32 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 135
 164+ 4C36 1F 18 18 18
 165+ 4C3A 00 00 00 F8          defb %00000000,%00000000,%00000000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 136
 165+ 4C3E F8 18 18 18
 166+ 4C42 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00000000,%00000000,%00000000 ; char 137
 166+ 4C46 F8 00 00 00
 167+ 4C4A 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00000000,%00000000,%00000000 ; char 138
 167+ 4C4E 1F 00 00 00
 168+ 4C52 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 139
 168+ 4C56 FF 00 00 00
 169+ 4C5A 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 140
 169+ 4C5E 1F 18 18 18
 170+ 4C62 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 141
 170+ 4C66 FF 18 18 18
 171+ 4C6A 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 142
 171+ 4C6E F8 18 18 18
 172+ 4C72 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 143
 172+ 4C76 FF 00 00 00
 173+ 4C7A 18 18 18 18          defb %00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000 ; char 144
 173+ 4C7E 18 18 18 18
 174+ 4C82 03 07 0E 1C          defb %00000011,%00000111,%00001110,%00011100,%00111000,%01110000,%11100000,%11000000 ; char 145
 174+ 4C86 38 70 E0 C0
 175+ 4C8A C0 E0 70 38          defb %11000000,%11100000,%01110000,%00111000,%00011100,%00001110,%00000111,%00000011 ; char 146
 175+ 4C8E 1C 0E 07 03
 176+ 4C92 C3 E7 7E 3C          defb %11000011,%11100111,%01111110,%00111100,%00111100,%01111110,%11100111,%11000011 ; char 147
 176+ 4C96 3C 7E E7 C3
 177+ 4C9A 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 148
 177+ 4C9E 10 10 10 10
 178+ 4CA2 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 149
 178+ 4CA6 10 10 10 10
 179+ 4CAA 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 150
 179+ 4CAE 10 10 10 10
 180+ 4CB2 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 151
 180+ 4CB6 00 00 00 00
 181+ 4CBA 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00000000,%00000000,%00000000,%00000000 ; char 152
 181+ 4CBE 00 00 00 00
 182+ 4CC2 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 153
 182+ 4CC6 00 00 00 00
 183+ 4CCA 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 154
 183+ 4CCE 10 10 10 10
 184+ 4CD2 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 155
 184+ 4CD6 10 10 10 10
 185+ 4CDA 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 156
 185+ 4CDE 10 10 10 10
 186+ 4CE2 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 157
 186+ 4CE6 00 00 00 00
 187+ 4CEA 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000 ; char 158
 187+ 4CEE 10 10 10 10
 188+ 4CF2 01 02 04 08          defb %00000001,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%10000000 ; char 159
 188+ 4CF6 10 20 40 80
 189+ 4CFA 80 40 20 10          defb %10000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000001 ; char 160
 189+ 4CFE 08 04 02 01
 190+ 4D02 81 42 24 18          defb %10000001,%01000010,%00100100,%00011000,%00011000,%00100100,%01000010,%10000001 ; char 161
 190+ 4D06 18 24 42 81
 191+ 4D0A 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 162
 191+ 4D0E 00 00 FF FF
 192+ 4D12 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; char 163
 192+ 4D16 FF FF FF FF
 193+ 4D1A 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 164
 193+ 4D1E FF FF FF FF
 194+ 4D22 FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 194+ 4D26 00 00 00 00
 195+ 4D2A FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 166
 195+ 4D2E 00 00 00 00
 196+ 4D32 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 167
 196+ 4D36 FF FF 00 00
 197+ 4D3A C0 C0 C0 C0          defb %11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000 ; char 168
 197+ 4D3E C0 C0 C0 C0
 198+ 4D42 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; char 169
 198+ 4D46 F0 F0 F0 F0
 199+ 4D4A FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 170
 199+ 4D4E FC FC FC FC
 200+ 4D52 03 03 03 03          defb %00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011 ; char 171
 200+ 4D56 03 03 03 03
 201+ 4D5A 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; char 172
 201+ 4D5E 0F 0F 0F 0F
 202+ 4D62 3F 3F 3F 3F          defb %00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111 ; char 173
 202+ 4D66 3F 3F 3F 3F
 203+ 4D6A FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 174
 203+ 4D6E 81 81 81 FF
 204+ 4D72 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; char 175
 204+ 4D76 F0 F0 F0 F0
 205+ 4D7A 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; char 176
 205+ 4D7E 0F 0F 0F 0F
 206+ 4D82 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; char 177
 206+ 4D86 00 00 00 00
 207+ 4D8A F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 178
 207+ 4D8E 00 00 00 00
 208+ 4D92 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00001111,%00001111,%00001111,%00001111 ; char 179
 208+ 4D96 0F 0F 0F 0F
 209+ 4D9A 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%11110000,%11110000,%11110000,%11110000 ; char 180
 209+ 4D9E F0 F0 F0 F0
 210+ 4DA2 3C 3C 3C 3C          defb %00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100 ; char 181
 210+ 4DA6 3C 3C 3C 3C
 211+ 4DAA C3 C3 C3 C3          defb %11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011 ; char 182
 211+ 4DAE C3 C3 C3 C3
 212+ 4DB2 FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 183
 212+ 4DB6 00 00 FF FF
 213+ 4DBA 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 184
 213+ 4DBE FF FF 00 00
 214+ 4DC2 33 33 CC CC          defb %00110011,%00110011,%11001100,%11001100,%00110011,%00110011,%11001100,%11001100 ; char 185
 214+ 4DC6 33 33 CC CC
 215+ 4DCA 55 AA 55 AA          defb %01010101,%10101010,%01010101,%10101010,%01010101,%10101010,%01010101,%10101010 ; char 186
 215+ 4DCE 55 AA 55 AA
 216+ 4DD2 66 33 99 CC          defb %01100110,%00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100 ; char 187
 216+ 4DD6 66 33 99 CC
 217+ 4DDA CC 99 33 66          defb %11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011,%01100110 ; char 188
 217+ 4DDE CC 99 33 66
 218+ 4DE2 33 99 CC 66          defb %00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100,%01100110 ; char 189
 218+ 4DE6 33 99 CC 66
 219+ 4DEA 66 CC 99 33          defb %01100110,%11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011 ; char 190
 219+ 4DEE 66 CC 99 33
 220+ 4DF2 10 10 7C 10          defb %00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%01111100,%00000000 ; char 191 (Â±)
 220+ 4DF6 10 00 7C 00
 221+ 4DFA 60 18 06 18          defb %01100000,%00011000,%00000110,%00011000,%01100000,%00000000,%01111110,%00000000 ; char 192 (â¥)
 221+ 4DFE 60 00 7E 00
 222+ 4E02 06 18 60 18          defb %00000110,%00011000,%01100000,%00011000,%00000110,%00000000,%01111110,%00000000 ; char 193 (â¤)
 222+ 4E06 06 00 7E 00
 223+ 4E0A 3E 20 20 20          defb %00111110,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 223+ 4E0E A0 60 20 00
 224+ 4E12 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 224+ 4E16 00 00 00 00
 225+ 4E1A 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 225+ 4E1E 70 00 00 00
 226+ 4E22 00 00 2A 54          defb %00000000,%00000000,%00101010,%01010100,%00000000,%01111110,%00000000,%00000000 ; char 197
 226+ 4E26 00 7E 00 00
 227+ 4E2A 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 227+ 4E2E 54 A8 00 00
 228+ 4E32 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11100000,%11000000,%10000000,%00000000 ; char 199
 228+ 4E36 E0 C0 80 00
 229+ 4E3A FE 7C 38 10          defb %11111110,%01111100,%00111000,%00010000,%00000000,%00000000,%00000000,%00000000 ; char 200
 229+ 4E3E 00 00 00 00
 230+ 4E42 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00000111,%00000011,%00000001,%00000000 ; char 201
 230+ 4E46 07 03 01 00
 231+ 4E4A 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00010000,%00111000,%01111100,%11111110 ; char 202
 231+ 4E4E 10 38 7C FE
 232+ 4E52 10 38 7C 10          defb %00010000,%00111000,%01111100,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 203 (up arrow)
 232+ 4E56 10 10 10 00
 233+ 4E5A 1E 0E 0E 12          defb %00011110,%00001110,%00001110,%00010010,%00100000,%01000000,%00000000,%00000000 ; char 204 (up right arrow)
 233+ 4E5E 20 40 00 00
 234+ 4E62 00 08 0C FE          defb %00000000,%00001000,%00001100,%11111110,%00001100,%00001000,%00000000,%00000000 ; char 205 (right arrow)
 234+ 4E66 0C 08 00 00
 235+ 4E6A 00 40 20 12          defb %00000000,%01000000,%00100000,%00010010,%00001110,%00001110,%00011110,%00000000 ; char 206 (down right arrow)
 235+ 4E6E 0E 0E 1E 00
 236+ 4E72 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%01111100,%00111000,%00010000,%00000000 ; char 207 (down arrow)
 236+ 4E76 7C 38 10 00
 237+ 4E7A 00 04 08 90          defb %00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000,%00000000 ; char 208 (down left arrow)
 237+ 4E7E E0 E0 F0 00
 238+ 4E82 00 20 60 FE          defb %00000000,%00100000,%01100000,%11111110,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 238+ 4E86 60 20 00 00
 239+ 4E8A F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 239+ 4E8E 08 04 00 00
 240+ 4E92 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 240+ 4E96 F0 44 38 00
 241+ 4E9A 00 02 7C A8          defb %00000000,%00000010,%01111100,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 241+ 4E9E 28 28 28 00
 242+ 4EA2 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001000,%00010000,%00010000,%00010000 ; char 213
 242+ 4EA6 08 10 10 10
 243+ 4EAA 00 00 00 C0          defb %00000000,%00000000,%00000000,%11000000,%00100000,%00010000,%00010000,%00010000 ; char 214
 243+ 4EAE 20 10 10 10
 244+ 4EB2 10 10 20 C0          defb %00010000,%00010000,%00100000,%11000000,%00000000,%00000000,%00000000,%00000000 ; char 215
 244+ 4EB6 00 00 00 00
 245+ 4EBA 10 10 08 07          defb %00010000,%00010000,%00001000,%00000111,%00000000,%00000000,%00000000,%00000000 ; char 216
 245+ 4EBE 00 00 00 00
 246+ 4EC2 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001111,%00011100,%00011000,%00011000 ; char 217
 246+ 4EC6 0F 1C 18 18
 247+ 4ECA 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00111000,%00011000,%00011000 ; char 218
 247+ 4ECE F0 38 18 18
 248+ 4ED2 18 18 38 F0          defb %00011000,%00011000,%00111000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 248+ 4ED6 E0 00 00 00
 249+ 4EDA 18 18 1C 0F          defb %00011000,%00011000,%00011100,%00001111,%00000111,%00000000,%00000000,%00000000 ; char 220
 249+ 4EDE 07 00 00 00
 250+ 4EE2 00 3C 42 42          defb %00000000,%00111100,%01000010,%01000010,%01000010,%01000010,%00111100,%00000000 ; char 221
 250+ 4EE6 42 42 3C 00
 251+ 4EEA 00 3C 7E 7E          defb %00000000,%00111100,%01111110,%01111110,%01111110,%01111110,%00111100,%00000000 ; char 222
 251+ 4EEE 7E 7E 3C 00
 252+ 4EF2 00 18 3C 7E          defb %00000000,%00011000,%00111100,%01111110,%01111110,%00111100,%00011000,%00000000 ; char 223
 252+ 4EF6 7E 3C 18 00
 253+ 4EFA FF FE FC F8          defb %11111111,%11111110,%11111100,%11111000,%11110000,%11100000,%11000000,%10000000 ; char 224
 253+ 4EFE F0 E0 C0 80
 254+ 4F02 FF 7F 3F 1F          defb %11111111,%01111111,%00111111,%00011111,%00001111,%00000111,%00000011,%00000001 ; char 225
 254+ 4F06 0F 07 03 01
 255+ 4F0A 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00011111,%00111111,%01111111,%11111111 ; char 226
 255+ 4F0E 1F 3F 7F FF
 256+ 4F12 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11111110,%11111111 ; char 227
 256+ 4F16 F8 FC FE FF
 257+ 4F1A 00 02 06 6C          defb %00000000,%00000010,%00000110,%01101100,%01111000,%01110000,%01100000,%00000000 ; char 228 (checkmark)
 257+ 4F1E 78 70 60 00
 258+ 4F22 00 66 3C 18          defb %00000000,%01100110,%00111100,%00011000,%00111100,%01100110,%00000000,%00000000 ; char 229 (x)
 258+ 4F26 3C 66 00 00
 259+ 4F2A 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%00111000,%00010000,%00111000,%00010000 ; char 230 (female)
 259+ 4F2E 38 10 38 10
 260+ 4F32 07 03 3D 44          defb %00000111,%00000011,%00111101,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 231 (male)
 260+ 4F36 44 44 38 00
 261+ 4F3A 78 44 42 42          defb %01111000,%01000100,%01000010,%01000010,%01000010,%01000010,%01000010,%01111110 ; char 232 (new doc)
 261+ 4F3E 42 42 42 7E
 262+ 4F42 00 F8 FF 81          defb %00000000,%11111000,%11111111,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 233 (folder)
 262+ 4F46 81 81 81 FF
 263+ 4F4A 10 7C FE 54          defb %00010000,%01111100,%11111110,%01010100,%01010100,%01010100,%01010100,%01111100 ; char 234 (trash bin)
 263+ 4F4E 54 54 54 7C
 264+ 4F52 FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10111101,%10101101,%10101101,%11111111 ; char 235 (floppy disk)
 264+ 4F56 BD AD AD FF
 265+ 4F5A 00 EA AA AC          defb %00000000,%11101010,%10101010,%10101100,%10101100,%10101010,%11101010,%00000000 ; char 236 (OK)
 265+ 4F5E AC AA EA 00
 266+ 4F62 18 7E FF 7E          defb %00011000,%01111110,%11111111,%01111110,%01111110,%01100110,%01100110,%01100110 ; char 237 (home)
 266+ 4F66 7E 66 66 66
 267+ 4F6A 3C 42 91 91          defb %00111100,%01000010,%10010001,%10010001,%10011101,%10000001,%01000010,%00111100 ; char 238 (clock)
 267+ 4F6E 9D 81 42 3C
 268+ 4F72 00 02 05 FD          defb %00000000,%00000010,%00000101,%11111101,%10100101,%10100010,%00000000,%00000000 ; char 239 (key)
 268+ 4F76 A5 A2 00 00
 269+ 4F7A 08 0C 3E 4C          defb %00001000,%00001100,%00111110,%01001100,%01001000,%01000010,%01000010,%00111100 ; char 240 (undo)
 269+ 4F7E 48 42 42 3C
 270+ 4F82 00 FF C3 A5          defb %00000000,%11111111,%11000011,%10100101,%10011001,%10000001,%11111111,%00000000 ; char 241 (letter)
 270+ 4F86 99 81 FF 00
 271+ 4F8A 38 44 44 7C          defb %00111000,%01000100,%01000100,%01111100,%01111100,%01111100,%01111100,%00000000 ; char 242 (lock)
 271+ 4F8E 7C 7C 7C 00
 272+ 4F92 06 09 09 F8          defb %00000110,%00001001,%00001001,%11111000,%11111000,%11111000,%11111000,%00000000 ; char 243 (unlock)
 272+ 4F96 F8 F8 F8 00
 273+ 4F9A FF FF 81 AD          defb %11111111,%11111111,%10000001,%10101101,%10100101,%10100101,%10000001,%11111111 ; char 244 (calendar)
 273+ 4F9E A5 A5 81 FF
 274+ 4FA2 01 1A 24 4A          defb %00000001,%00011010,%00100100,%01001010,%01010010,%00100100,%01011000,%10000000 ; char 245 (diameter)
 274+ 4FA6 52 24 58 80
 275+ 4FAA 7E 81 81 81          defb %01111110,%10000001,%10000001,%10000001,%10000001,%01110110,%00001100,%00000100 ; char 246 (baloon)
 275+ 4FAE 81 76 0C 04
 276+ 4FB2 0C 0A 0A 0A          defb %00001100,%00001010,%00001010,%00001010,%00001000,%00011000,%00111000,%00010000 ; char 247 (note)
 276+ 4FB6 08 18 38 10
 277+ 4FBA 12 31 F5 F5          defb %00010010,%00110001,%11110101,%11110101,%11110101,%11110101,%00110001,%00010010 ; char 248 (audio on)
 277+ 4FBE F5 F5 31 12
 278+ 4FC2 10 30 F0 F0          defb %00010000,%00110000,%11110000,%11110000,%11110000,%11110000,%00110000,%00010000 ; char 249 (audio off)
 278+ 4FC6 F0 F0 30 10
 279+ 4FCA 40 60 70 78          defb %01000000,%01100000,%01110000,%01111000,%01111100,%01111110,%01111000,%01001000 ; char 250 (pointer)
 279+ 4FCE 7C 7E 78 48
 280+ 4FD2 3C 42 99 A1          defb %00111100,%01000010,%10011001,%10100001,%10100001,%10011001,%01000010,%00111100 ; char 251 (Â©)
 280+ 4FD6 A1 99 42 3C
 281+ 4FDA 18 24 20 78          defb %00011000,%00100100,%00100000,%01111000,%00100000,%00100010,%01011100,%00000000 ; char 252 (Â£)
 281+ 4FDE 20 22 5C 00
 282+ 4FE2 3C 42 78 24          defb %00111100,%01000010,%01111000,%00100100,%00100100,%00011110,%01000010,%00111100 ; char 253 (Â§)
 282+ 4FE6 24 1E 42 3C
 283+ 4FEA 00 00 10 00          defb %00000000,%00000000,%00010000,%00000000,%01111100,%00000000,%00010000,%00000000 ; char 254 (Ã·)
 283+ 4FEE 7C 00 10 00
 284+ 4FF2 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 255 (cursor)
 284+ 4FF6 FF FF FF FF
 285+ 4FFA
# file closed: ../include/vdp/8x8fonts-r18.asm
  80  4FFA                  INCLUDE "../include/vdp/logo-fonts.asm"
# file opened: ../include/vdp/logo-fonts.asm
   1+ 4FFA              ; ------------------------------------------------------------------------------
   2+ 4FFA              ; LM80C - LOGO CHARSET - R1.1
   3+ 4FFA              ; ------------------------------------------------------------------------------
   4+ 4FFA              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4FFA              ; designed by Leonardo Miliani. More info at
   6+ 4FFA              ; www DOT leonardomiliani DOT com
   7+ 4FFA              ; ------------------------------------------------------------------------------
   8+ 4FFA              ; Code Revision:
   9+ 4FFA              ; R1.0 - 20200124 - First revision: logo chars
  10+ 4FFA              ; R1.1 - 20200229 - Adopted usual hexadecimal & binary prefixes
  11+ 4FFA              ; ------------------------------------------------------------------------------
  12+ 4FFA
  13+ 4FFA              LOGOFONT:   equ $
  14+ 4FFA 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; 0
  14+ 4FFE 00 00 00 00
  15+ 5002 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; 1
  15+ 5006 FF FF FF FF
  16+ 500A FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; 2
  16+ 500E 00 00 00 00
  17+ 5012 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; 3
  17+ 5016 0F 0F 0F 0F
  18+ 501A 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; 4
  18+ 501E FF FF FF FF
  19+ 5022 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; 5
  19+ 5026 F0 F0 F0 F0
  20+ 502A 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; 6
  20+ 502E 0F 0F 0F 0F
  21+ 5032 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; 7
  21+ 5036 F0 F0 F0 F0
  22+ 503A F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; 8
  22+ 503E 00 00 00 00
  23+ 5042 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; 9
  23+ 5046 00 00 00 00
  24+ 504A 00 00 00 FC              defb %00000000,%00000000,%00000000,%11111100,%11111111,%00000111,%00000011,%00000000 ; 10
  24+ 504E FF 07 03 00
  25+ 5052 00 00 00 3F              defb %00000000,%00000000,%00000000,%00111111,%11111111,%11100000,%11000000,%00000000 ; 11
  25+ 5056 FF E0 C0 00
  26+ 505A 18 18 1F 19              defb %00011000,%00011000,%00011111,%00011001,%00011001,%00011111,%00011000,%00011000 ; 12
  26+ 505E 19 1F 18 18
  27+ 5062 18 18 F8 98              defb %00011000,%00011000,%11111000,%10011000,%10011000,%11111000,%00011000,%00011000 ; 13
  27+ 5066 98 F8 18 18
  28+ 506A 18 18 1C 1F              defb %00011000,%00011000,%00011100,%00011111,%00001111,%00000000,%00000000,%00000000 ; 14
  28+ 506E 0F 00 00 00
  29+ 5072 00 00 00 0F              defb %00000000,%00000000,%00000000,%00001111,%00011111,%00011100,%00011000,%00011000 ; 15
  29+ 5076 1F 1C 18 18
  30+ 507A 00 00 00 F0              defb %00000000,%00000000,%00000000,%11110000,%11111000,%00111000,%00011000,%00011000 ; 16
  30+ 507E F8 38 18 18
  31+ 5082 18 18 38 F8              defb %00011000,%00011000,%00111000,%11111000,%11110000,%00000000,%00000000,%00000000 ; 17
  31+ 5086 F0 00 00 00
  32+ 508A 00 00 00 FF              defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; 18
  32+ 508E FF 00 00 00
  33+ 5092 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%11111111,%11111111,%11111111,%11111111 ; 19
  33+ 5096 FF FF FF FF
  34+ 509A F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11111111,%11111111,%11111111,%11111111 ; 20
  34+ 509E FF FF FF FF
  35+ 50A2 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11110000,%11110000,%11110000,%11110000 ; 21
  35+ 50A6 F0 F0 F0 F0
  36+ 50AA FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00001111,%00001111,%00001111,%00001111 ; 22
  36+ 50AE 0F 0F 0F 0F
  37+ 50B2 00 30 78 78              defb %00000000,%00110000,%01111000,%01111000,%00110000,%00000000,%00000000,%00000000 ; 23
  37+ 50B6 30 00 00 00
  38+ 50BA
# file closed: ../include/vdp/logo-fonts.asm
  81  50BA
  82  50BA              ; include ROM/RAM switcher
  83  50BA                  INCLUDE "../include/switcher/switcher-r11.asm"
# file opened: ../include/switcher/switcher-r11.asm
   1+ 50BA              ; ------------------------------------------------------------------------------
   2+ 50BA              ; LM80C - ROM/RAM SWITCHER - R1.1
   3+ 50BA              ; ------------------------------------------------------------------------------
   4+ 50BA              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 50BA              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 50BA              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 50BA              ; kind of warranty: you can use them at your own risk.
   8+ 50BA              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 50BA              ; maintain the copyright notices, include this advice and the note to the
  10+ 50BA              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 50BA              ; redistribuite them.
  12+ 50BA              ; https://www.leonardomiliani.com
  13+ 50BA              ;
  14+ 50BA              ; Please support me by visiting the following links:
  15+ 50BA              ; Main project page: https://www.leonardomiliani.com
  16+ 50BA              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 50BA              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 50BA              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 50BA              ; ------------------------------------------------------------------------------
  20+ 50BA              ; Code Revision:
  21+ 50BA              ; R1.0   - 20200718 - First version
  22+ 50BA              ; R1.1   - 20200827 - PIO settings now are part of the file
  23+ 50BA              ;-------------------------------------------------------------------------------
  24+ 50BA
  25+ 50BA              TMP_FW_LOC:     equ     $8000           ; address from where to make a temporary copy of the FW
  26+ 50BA              ;-------------------------------------------------------------------------------
  27+ 50BA              ; THIS CODE WILL BE EXECUTED FROM RAM
  28+ 50BA 3E FC        RAMRUN:         ld      A,%11111100     ; set ROM off and RAM on..
  29+ 50BC D3 01                        out     (PIO_DB),A      ; ...by setting bit #0 to 0 (and leave VRAM bank #0)
  30+ 50BE 01 FE 50                     ld      BC,END_OF_FW    ; let's copy back FW into low RAM - bytes to copy
  31+ 50C1 21 00 80                     ld      HL,TMP_FW_LOC   ; source address
  32+ 50C4 11 00 00                     ld      DE,$0000        ; dest. address
  33+ 50C7 ED B0                        ldir                    ; copy!
  34+ 50C9 AF                           xor     A
  35+ 50CA D3 01                        out     (PIO_DB),A      ; all LEDs off - finished copying
  36+ 50CC C3 B0 02                     jp      INIT_HW         ; return control to old init (now into RAM)
  37+ 50CF
  38+ 50CF              ;-------------------------------------------------------------------------------
  39+ 50CF              ; copy the whole contents of ROM into RAM then disable the first memory
  40+ 50CF 3A 5B 51     ROM2RAM:        ld      A,(basicStarted); check if BASIC is already started
  41+ 50D2 FE 59                        cp      'Y'             ; to see if this is a power-up
  42+ 50D4 20 0F                        jr      NZ,CNTCP2RAM    ; no, continue copy to RAM
  43+ 50D6                              ; WARNING: Do **NOT** change the following "out()" sequence, ABSOLUTELY!
  44+ 50D6 3E CF                        ld      A,%11001111     ; set mode 3 ("control mode")
  45+ 50D8 D3 03                        out     (PIO_CB),A      ; for PIO port B
  46+ 50DA AF                           xor     A               ; set LEDs off, RAM on, VRAM on bank #0
  47+ 50DB D3 01                        out     (PIO_DB),A      ; send settings to PIO register
  48+ 50DD D3 03                        out     (PIO_CB),A      ; set pins following register's status
  49+ 50DF 21 8D 52                     ld      HL,TEMPSTACK    ; temporary stack
  50+ 50E2 C3 B3 02                     jp      INIT_HW2        ; jump to re-init HW
  51+ 50E5
  52+ 50E5                              ; WARNING: Do **NOT** change the following "out()" sequence, ABSOLUTELY!
  53+ 50E5 3E CF        CNTCP2RAM:      ld      A,%11001111     ; set mode 3 (mode control)
  54+ 50E7 D3 03                        out     (PIO_CB),A      ; for PIO port B
  55+ 50E9 3E FD                        ld      A,%11111101     ; set pin #0 as HIGH to enable ROM
  56+ 50EB D3 01                        out     (PIO_DB),A      ; store the value into the internal register
  57+ 50ED AF                           xor     A               ; set pins to OUTPUT
  58+ 50EE D3 03                        out     (PIO_CB),A      ; for port B, activating the RAM
  59+ 50F0 01 FE 50                     ld      BC,END_OF_FW    ; copy FW from ROM to high RAM
  60+ 50F3 21 00 00                     ld      HL,$0000        ; source address
  61+ 50F6 11 00 80                     ld      DE,TMP_FW_LOC   ; dest. address
  62+ 50F9 ED B0                        ldir                    ; copy!
  63+ 50FB C3 BA D0                     jp      RAMRUN+TMP_FW_LOC; jump to execute code into RAM
  64+ 50FE
  65+ 50FE              ;-------------------------------------------------------------------------------
  66+ 50FE              END_OF_FW:      equ     $   ; this is the last cell of the firmware
# file closed: ../include/switcher/switcher-r11.asm
  84  50FE
  85  50FE              ; include workspace equates
  86  50FE                  INCLUDE "../include/workspace/workspace-r1.0.asm"
# file opened: ../include/workspace/workspace-r1.0.asm
   1+ 50FE              ; ------------------------------------------------------------------------------
   2+ 50FE              ; LM80C 64K - WORKSPACE EQUATES - R1.0
   3+ 50FE              ; ------------------------------------------------------------------------------
   4+ 50FE              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 50FE              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 50FE              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 50FE              ; kind of warranty: you can use them at your own risk.
   8+ 50FE              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 50FE              ; maintain the copyright notices, include this advice and the note to the
  10+ 50FE              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 50FE              ; redistribuite them.
  12+ 50FE              ; https://www.leonardomiliani.com
  13+ 50FE              ;
  14+ 50FE              ; Please support me by visiting the following links:
  15+ 50FE              ; Main project page: https://www.leonardomiliani.com
  16+ 50FE              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 50FE              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 50FE              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 50FE              ; ------------------------------------------------------------------------------
  20+ 50FE
  21+ 50FE              ; set starting of RAM based on computer model
  22+ 50FE                  IFDEF LM80C64K
  23+ 50FE              SERBUF_START    equ     END_OF_FW       ; RAM starts here
  24+ 50FE                  ELSE
  25+ 50FE ~            SERBUF_START    equ     $8000           ; RAM starts here
  26+ 50FE                  ENDIF
  27+ 50FE
  28+ 50FE              ;-------------------------------------------------------------------------------
  29+ 50FE              serInPtr        equ     SERBUF_START + SER_BUFSIZE
  30+ 50FE              serRdPtr        equ     serInPtr+2
  31+ 50FE              serBufUsed      equ     serRdPtr+2
  32+ 50FE              basicStarted    equ     serBufUsed+1
  33+ 50FE              bufWrap         equ     (SERBUF_START + SER_BUFSIZE) & $FF
  34+ 50FE              TEMPSTACK       equ     CURPOS - 3      ; top of BASIC line input buffer so is "free ram" when BASIC resets
  35+ 50FE
  36+ 50FE              ; BASIC WORK SPACE LOCATIONS
  37+ 50FE              ; THE INTERPRETER ALLOCATES THE FOLLOWING RAM CELLS
  38+ 50FE              ; TO STORE IMPORTANT VALUES USED FOR SOME SPECIFIC FUNCTIONS:
  39+ 50FE              ; THEY CAN BE VECTOR (ADDRESSES) FUNCTIONS, SYSTEM DATAS (I.E. VARIABLES)
  40+ 50FE              ; AND SO ON. THE FIRST CELLS ARE FILLED WITH VALUES STORED INTO ROM AT $(INITAB) ADDRESS
  41+ 50FE              WRKSPC          equ     basicStarted+$01; (3) BASIC Work space
  42+ 50FE              NMIUSR          equ     WRKSPC+$03      ; (3) NMI exit point routine
  43+ 50FE              USR             equ     NMIUSR+$03      ; (3) "USR (x)" jump  <-- in (USR+$01)/(USR+$02) the user can store the address of a specific machine language routine
  44+ 50FE              OUTSUB          equ     USR+$03         ; (1) "out p,n"
  45+ 50FE              OTPORT          equ     OUTSUB+$01      ; (2) Port (p)
  46+ 50FE              DIVSUP          equ     OTPORT+$02      ; (1) Division support routine
  47+ 50FE              DIV1            equ     DIVSUP+$01      ; (4) <- Values
  48+ 50FE              DIV2            equ     DIV1+$04        ; (4) <-   to
  49+ 50FE              DIV3            equ     DIV2+$04        ; (3) <-   be
  50+ 50FE              DIV4            equ     DIV3+$03        ; (2) <-inserted
  51+ 50FE              SEED            equ     DIV4+$02        ; (35) Random number seed  <-- starting address of a seed table
  52+ 50FE              LSTRND          equ     SEED+$23        ; (4) Last random number
  53+ 50FE              INPSUB          equ     LSTRND+$04      ; (1) INP A,(x) Routine
  54+ 50FE              INPORT          equ     INPSUB+$01      ; (2) PORT (x)
  55+ 50FE              LWIDTH          equ     INPORT+$02      ; (1) Terminal width
  56+ 50FE              COMMAN          equ     LWIDTH+$01      ; (1) Width for commas
  57+ 50FE              NULFLG          equ     COMMAN+$01      ; (1) Null after input byte flag
  58+ 50FE              CTLOFG          equ     NULFLG+$01      ; (1) Control "O" flag
  59+ 50FE              CHKSUM          equ     CTLOFG+$01      ; (2) Array load/save check sum
  60+ 50FE              NMIFLG          equ     CHKSUM+$02      ; (1) Flag for NMI break routine
  61+ 50FE              BRKFLG          equ     NMIFLG+$01      ; (1) Break flag
  62+ 50FE              RINPUT          equ     BRKFLG+$01      ; (3) Input reflection
  63+ 50FE              STRSPC          equ     RINPUT+$03      ; (2) Pointer to bottom (start) of string space - default is 100 bytes below the top of memory
  64+ 50FE              LINEAT          equ     STRSPC+$02      ; (2) Current line number. -1 means "direct mode", while -2 means cold start.
  65+ 50FE              HLPLN           equ     LINEAT+$02      ; (2) Current line with errors
  66+ 50FE              KEYDEL          equ     HLPLN+$02       ; (1) delay before key auto-repeat starts
  67+ 50FE              AUTOKE          equ     KEYDEL+$01      ; (1) delay for key auto-repeat
  68+ 50FE              FNKEYS          equ     AUTOKE+$01      ; (128) default text of FN keys
  69+ 50FE              BASTXT          equ     FNKEYS+$80      ; (3) Pointer to start of BASIC program in memory
  70+ 50FE              ; - - - - - - - - - - - - - - - - - - -   the above are locations pre-filled by the firmware at startup
  71+ 50FE              BUFFER          equ     BASTXT+$03      ; (5) Input buffer
  72+ 50FE              STACK           equ     BUFFER+$05      ; (85) Initial stack
  73+ 50FE              CURPOS          equ     STACK+$55       ; (1) Character position on line
  74+ 50FE              LCRFLG          equ     CURPOS+$01      ; (1) Locate/Create flag for DIM statement
  75+ 50FE              TYPE            equ     LCRFLG+$01      ; (1) Data type flag: 0=numeric, non-zero=string
  76+ 50FE              DATFLG          equ     TYPE+$01        ; (1) Literal statement flag
  77+ 50FE              LSTRAM          equ     DATFLG+$01      ; (2) Last available RAM location usable by BASIC
  78+ 50FE              TMSTPT          equ     LSTRAM+$02      ; (2) Temporary string pointer
  79+ 50FE              TMSTPL          equ     TMSTPT+$02      ; (12) Temporary string pool
  80+ 50FE              TMPSTR          equ     TMSTPL+$0C      ; (4) Temporary string
  81+ 50FE              STRBOT          equ     TMPSTR+$04      ; (2) Bottom of string space
  82+ 50FE              CUROPR          equ     STRBOT+$02      ; (2) Current operator in EVAL
  83+ 50FE              LOOPST          equ     CUROPR+$02      ; (2) First statement of loop
  84+ 50FE              DATLIN          equ     LOOPST+$02      ; (2) Line of current DATA item
  85+ 50FE              FORFLG          equ     DATLIN+$02      ; (1) "FOR" loop flag
  86+ 50FE              LSTBIN          equ     FORFLG+$01      ; (1) Last byte entered
  87+ 50FE              READFG          equ     LSTBIN+$01      ; (1) Read/Input flag
  88+ 50FE              BRKLIN          equ     READFG+$01      ; (2) Line of break
  89+ 50FE              NXTOPR          equ     BRKLIN+$02      ; (2) Next operator in EVAL
  90+ 50FE              ERRLIN          equ     NXTOPR+$02      ; (2) Line of error
  91+ 50FE              CONTAD          equ     ERRLIN+$02      ; (2) Where to CONTinue
  92+ 50FE              TMRCNT          equ     CONTAD+$02      ; (4) TMR counter for 1/100 seconds
  93+ 50FE              CTC0IV          equ     TMRCNT+$04      ; (3) CTC0 interrupt vector
  94+ 50FE              CTC1IV          equ     CTC0IV+$03      ; (3) CTC1 interrupt vector
  95+ 50FE              CTC2IV          equ     CTC1IV+$03      ; (3) CTC2 interrupt vector
  96+ 50FE              CTC3IV          equ     CTC2IV+$03      ; (3) CTC3 interrupt vector
  97+ 50FE              ; - - - - - - - - - - - - - - - - - - -   VIDEO REGISTERS - FROM HERE...
  98+ 50FE              SCR_SIZE_W      equ     CTC3IV+$03      ; (1) screen width (it can be either 40 chars or 32 chars/bytes)
  99+ 50FE              SCR_SIZE_H      equ     SCR_SIZE_W+$01  ; (1) screen height (it can be 24/48/192: 24 for text, 48 for MC, 192 for graphics)
 100+ 50FE              SCR_MODE        equ     SCR_SIZE_H+$01  ; (1) screen mode (0=text, 1=G1, 2=G2, 3=MC, 4=ExG2)
 101+ 50FE              SCR_NAM_TB      equ     SCR_MODE+$02    ; (2) video name table address
 102+ 50FE              SCR_CURS_X      equ     SCR_NAM_TB+$02  ; (1) cursor X
 103+ 50FE              SCR_CURS_Y      equ     SCR_CURS_X+$01  ; (1) cursor Y
 104+ 50FE              SCR_CUR_NX      equ     SCR_CURS_Y+$01  ; (1) new cursor X position
 105+ 50FE              SCR_CUR_NY      equ     SCR_CUR_NX+$01  ; (1) new cursor Y position
 106+ 50FE              SCR_ORG_CHR     equ     SCR_CUR_NY+$01  ; (1) original char positioned under the cursor
 107+ 50FE              CRSR_STATE      equ     SCR_ORG_CHR+$01 ; (1) state of cursor (1=on, 0=off)
 108+ 50FE              LSTCSRSTA       equ     CRSR_STATE+$01  ; (1) last cursor state
 109+ 50FE              PRNTVIDEO       equ     LSTCSRSTA+$01   ; (1) print on video buffer (1=on / 0=off) set to off on graphic only modes
 110+ 50FE              CHR4VID         equ     PRNTVIDEO+$01   ; (1) char for video buffer
 111+ 50FE              FRGNDCLR        equ     CHR4VID+$01     ; (1) foreground color as set by SCREEN or COLOR commands
 112+ 50FE              BKGNDCLR        equ     FRGNDCLR+$01    ; (1) background color as set by SCREEN or COLOR commands
 113+ 50FE              TMPBFR1         equ     BKGNDCLR+$01    ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 114+ 50FE              TMPBFR2         equ     TMPBFR1+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 115+ 50FE              TMPBFR3         equ     TMPBFR2+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 116+ 50FE              TMPBFR4         equ     TMPBFR3+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 117+ 50FE              VIDEOBUFF       equ     TMPBFR4+$02     ; (40) buffer used for video scrolling and other purposes
 118+ 50FE              VIDTMP1         equ     VIDEOBUFF+$28   ; (2) temporary video word
 119+ 50FE              VIDTMP2         equ     VIDTMP1+$02     ; (2) temporary video word
 120+ 50FE              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO VPD OUT OF THIS RANGE,
 121+ 50FE                                                      ; OTHERWISE YOU WILL HAVE TO CHECK THE POINTER IN "CLR_RAM_REG" FUNCTION
 122+ 50FE              ; - - - - - - - - - - - - - - - - - - -   SOUND & KEYBOARD REGISTERS - FROM HERE...
 123+ 50FE              CHASNDDTN       equ     VIDTMP2+$02     ; (2) sound Ch.A duration (in 1/100s)
 124+ 50FE              CHBSNDDTN       equ     CHASNDDTN+$02   ; (2) sound Ch.B duration (in 1/100s)
 125+ 50FE              CHCSNDDTN       equ     CHBSNDDTN+$02   ; (2) sound Ch.C duration (in 1/100s)
 126+ 50FE              KBDNPT          equ     CHCSNDDTN+$02   ; (1) temp cell used to flag if input comes from keyboard
 127+ 50FE              KBTMP           equ     KBDNPT+$01      ; (1) temp cell used by keyboard scanner
 128+ 50FE              TMPKEYBFR       equ     KBTMP+$01       ; (1) temp buffer for last key pressed
 129+ 50FE              LASTKEYPRSD     equ     TMPKEYBFR+$01   ; (1) last key code pressed
 130+ 50FE              STATUSKEY       equ     LASTKEYPRSD+$01 ; (1) status key, used for auto-repeat
 131+ 50FE              KEYTMR          equ     STATUSKEY+$01   ; (2) timer used for auto-repeat key
 132+ 50FE              CONTROLKEYS     equ     KEYTMR+$02      ; (1) flags for control keys (bit#0=SHIFT; bit#1=CTRL; bit#2=C=)
 133+ 50FE              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO PSG OUT OF THIS RANGE,
 134+ 50FE                                                      ; OTHERWISE YOU WILL HAVE TO CHANGE THE POINTER IN "initPSG" FUNCTION
 135+ 50FE              SERIALS_EN      equ     CONTROLKEYS+$01 ; (1) serial ports status: bit 0 for Port1 (A), bit 1 for Port2 (B): 0=OFF, 1=ON
 136+ 50FE              SERABITS        equ     SERIALS_EN+$01  ; (1) serial port A data bits
 137+ 50FE              SERBBITS        equ     SERABITS+$01    ; (1) serial port B data bits
 138+ 50FE              DOS_EN          equ     SERBBITS+$01    ; (1) DOS enable/disable (1/0)
 139+ 50FE              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 140+ 50FE                                                      ; from here there are the RAM locations that
 141+ 50FE                                                      ; are saved during SAVE
 142+ 50FE              PROGND          equ     DOS_EN+$01      ; (2) End of program
 143+ 50FE              VAREND          equ     PROGND+$02      ; (2) End of variables
 144+ 50FE              ARREND          equ     VAREND+$02      ; (2) End of arrays
 145+ 50FE              NXTDAT          equ     ARREND+$02      ; (2) Next data item
 146+ 50FE              FNRGNM          equ     NXTDAT+$02      ; (2) Name of FN argument
 147+ 50FE              FNARG           equ     FNRGNM+$02      ; (4) FN argument value
 148+ 50FE              FPREG           equ     FNARG+$04       ; (3) Floating point register
 149+ 50FE              FPEXP           equ     FPREG+$03       ; (1) Floating point exponent
 150+ 50FE              SGNRES          equ     FPEXP+$01       ; (1) Sign of result
 151+ 50FE              PBUFF           equ     SGNRES+$01      ; (13) Number print buffer
 152+ 50FE              MULVAL          equ     PBUFF+$0D       ; (3) Multiplier
 153+ 50FE              PROGST          equ     MULVAL+$03      ; (100) Start of program text area
 154+ 50FE              STLOOK          equ     PROGST+$64      ; Start of memory test
 155+ 50FE
# file closed: ../include/workspace/workspace-r1.0.asm
  87  50FE
  88  50FE              ; END OF ASSEMBLY SOURCE
  89  50FE              ;-------------------------------------------------------------------------------
  90  50FE
# file closed: LM80C_64K-firmware-r1.02.asm

Value    Label
------ - -----------------------------------------------------------
0x5314   CHCSNDDTN
0x5312   CHBSNDDTN
0x51A6   NMIFLG
0x50E5   CNTCP2RAM
0x50FE   END_OF_FW
0x50BA   RAMRUN
0x8000   TMP_FW_LOC
0x3FEA   DV16_16_LP
0x3FE5 X DIV_16_16
0x3FD9   DIV_16_8LP
0x3FCA   DIV_8_8LOOP
0x3FBA   EXMUL16
0x3FB1   MLP1
0x3FAA   MLP
0x3F8A X TSTBIT
0x3F4A   BINIT
0x3F5D   CHKBIN
0x3F2C   BITOUT2
0x3F28   BITOUT
0x3F1A   ZEROSUP
0x3F14 X BIN2
0x3EFC   NOSUB7
0x3F00   HEXIT
0x3EDC   HEXLP
0x3EE1   HEXLP1
0x3F09   HXERR
0x3EE9   GETHEX
0x3ECC   ADD301
0x3EBC   ADD30
0x3EA6   HEX4
0x3EA4   HEX3
0x3E95   HEX1
0x3E97   HEX2
0x3E41   PRTEND
0x3E35   PRTK1
0x3E32   OPNQT1
0x3E1A   CLSQT1
0x3E76   CHKEY5
0x3E02   PTCHR1
0x3E73   CHKEY4
0x3E0A   CLSQT
0x3DCD   PRTK3
0x3DE5   PRTCHR
0x3E1C   OPNQT
0x3DD0   CNTLTK
0x3DBB   LDKEY
0x3E6A   CHKEY2
0x3E34   PRTCKEY
0x3E65   CHKEY1
0x3DA4 X PRTK2
0x3DA2   PRTK4
0x3D8E   CPKYEND
0x3D86   CPKEY1
0x3D7E   CPKEY3
0x3D77   CPKEY2
0x3D67   CPKEY
0x3D59   DECLN1
0x3E43   SETREP
0x3D29   KEYCH
0x3D90   LSTKEYS
0x3D07   HLPERR
0x3CE5   DIRMOD
0x3CAC   EXNRM
0x3C9E   ENCHB
0x3C73   SRLCNT
0x3C5B   STRPAR
0x3C3E   SETPAR2
0x3C2F   BITS8
0x3C24   BITS7
0x3C33   SETPAR
0x3C1A   BITS6
0x3BF7   SET_CTC
0x3CC9   CTC_CFG
0x3CD4   SCERR1
0x3BE6   SET_PT
0x3BCD   CKBPS
0x3CB3   SUP_BPS
0x3BC1   SETSER
0x3BB4   DEFSER
0x3B69   CNTSER3
0x3B4C   CNTRX2
0x3B57   CNTSER2
0x3B19   SERLED
0x3B13   SRPT2
0x3AF0   RPTRSSR
0x3AE3   RSTSERS
0x3B1D   CNTSER
0x3ADF   CHKZSER
0x3AD0   SERVAR
0x3CD8   SCERR
0x52EA   SIOBFR
0x52E9   STPBT
0x52E8   PARBT
0x52E7   DATABT
0x52E5   BPS
0x52E4   PRTNUM
0x3A8A   RPTCVB2
0x3A81   RPTCVB1
0x3A74   CNTVALY
0x3A44   CNTCL7
0x3A20   CNTCL6
0x39FC   CNTCL5
0x39DA   CNTCL4
0x39B4   CNTCL3
0x3990   CNTCL2
0x3A6E   VALIDY
0x396C   CNTCL1
0x3A69   VALIDX
0x393D   PLTCRL
0x392E   DLSZ
0x3946   ENDCRL
0x3901   RPTCL1
0x38EE   RPTCRL
0x394A   DRWCRL
0x52EE   DC
0x52EC   YI
0x52EA   XI
0x52E8   RADIUS
0x52E6   YC
0x52E4   XC
0x387D   DXGR
0x38A6   ENDDRAW
0x384D   CNTDRW
0x3831   RPTDRW
0x382E   STRE2
0x3821   ER2
0x3FBF   negHL
0x37FE   Y1GR
0x37D4   X1GR
0x3FBC   absHL
0x3A79   CLRVDBF
0x52F0   DX
0x52EE   SY
0x52EC   SX
0x52EA   E2
0x52E8   ER
0x52E6   Y2
0x52E4   X2
0x52DE   Y1
0x52DC   X1
0x3FC6   DIV_8_8
0x3741   PXLSET
0x371D   CNTPLT1
0x373D   NOGD
0x3749   XY2HL
0x36B8   PNTEND
0x36C2   CTPOINT
0x366F   PAINT5
0x363E   PAINT3
0x367F   CHECKPY
0x362B   PAINT2
0x36FC   CNTPLOT
0x35FB   MNPAINT
0x35F8   PAINT1
0x35F7   PAINT11
0x367E   CHECKPA
0x35E9   PAINT0
0x3676   EXITPAI
0x35DC   NXTLOOP
0x367A   EXITPA2
0x36D6   PNTRTN
0x3A91   CLRPRM
0x52E8   ORGSP
0x52E7 X SPB
0x52E6 X SPA
0x52E4   PNT
0x356E   GPCPCH1
0x3563 X GPCPCHR
0x3549   GPNTCO1
0x353F X GPNTCOL
0x3534   RPGPNT
0x351F   GPNT
0x350A   CNTGPT2
0x358B   CKCOL
0x52EA   TMPHL
0x52E8   NUMCHR
0x52E6   CHRPNT
0x52E4   TMPADR
0x52DC   MIXCOL
0x52DE   TMPCLR
0x52E2   GY
0x52E0   GX
0x3AAA   GMERR
0x34A4   CHKG2M
0x349E   CHKCLR0
0x3469   RPTLDCL
0x345F   LOADCLR
0x3474   SETBRCL
0x348D   MIXCLRS
0x3458   CLREX2
0x344F   CLRG2
0x3446   CLRG1
0x343C   CLRTXT
0x343F   CLRMC
0x349A   CHKCLR1
0x3394   CKMAGN
0x33E1   CHKSCAR
0x3389 X SETVDP
0x33A2   SCVDP
0x3365   RPTPS
0x3360 X DIR_PAU
0x333A X RECWRD
0x3316 X ARET
0x32F1   ATNTAB
0x32E7   ATN1
0x32A0   SINTAB
0x3284   SIN1
0x329C   QUARTR
0x3298   HALFPI
0x3231   RND2
0x3215   RND1
0x3242   RNDTAB
0x5199   LSTRND
0x323A   RESEED
0x5176   SEED
0x31C1   SUMLP
0x31B8   SMSER1
0x3188   EXPTAB
0x3130   POWER2
0x3113   POWER1
0x30F5   NEGAFT
0x30C0   EXPTEN
0x30BE   OUTEXP
0x30CD   NOENED
0x30A2   SUPTLZ
0x30AE   DOEBIT
0x307D   TRYAGN
0x306E   DIGTXT
0x30E3   POWERS
0x305D   MAKNUM
0x3038   GTSIXD
0x3041   INRNG
0x3023   SIXDIG
0x30D0   RNGTST
0x30CA   JSTZER
0x3014   SPCFST
0x5335   PBUFF
0x2FBE   MULTEN
0x2FB3   ENDCON
0x2FBD   SCALPL
0x2FA7   SCALMI
0x2FE7   EDIGIT
0x2F92   EXPLP
0x2FA4   CONEXP
0x2FA0   DPOINT
0x2FC5   ADDIG
0x2F7C   MANLP
0x2F74   CNVNUM
0x2F63   NOMLAD
0x2F55   MLDBLP
0x2F2D   DCBCDE
0x2EF6   CMPFP
0x2EBE   DETHLB
0x2EB7   INCHL
0x2E6A   RETREL
0x2E4A   MLSP10
0x2E3D   OVTST1
0x2E42   OVTST2
0x2E43   OVTST3
0x2DEF   RESDIV
0x5168   DIVSUP
0x2DDC   DIVLP
0x5174   DIV4
0x5169   DIV1
0x516D   DIV2
0x5171   DIV3
0x2DA9   DIV10
0x2D41   NOMADD
0x2D30   MUL8LP
0x2D53   BYTSFT
0x2D27   MULT8
0x5342   MULVAL
0x2E1F   ADDEXP
0x2D05   FPMULT
0x2CFC   MULLN2
0x2FDC   RSCALE
0x31A9   SUMSER
0x2DB7   DVBCDE
0x2CB7   LOGTAB
0x2CB3   UNITY
0x2CA1   SHRLP
0x2C9E   SHRITE
0x2C91   SCALLP
0x5334   SGNRES
0x2C62   FPROND
0x2C51   RONDB
0x2C35   NORMAL
0x2C31   SAVEXP
0x2C3D   PNORM
0x2C18   CONPOS
0x2CA5   SHRT1
0x2C50   RONDUP
0x2C6F   PLUCDE
0x2C0A   MINCDE
0x2C8F   SCALE
0x2EC7   SIGNS
0x2BE4   NOSWAP
0x2BC7   SUBCDE
0x2BC1   SUBPHL
0x2BCA   FPADD
0x30DF   HALF
0x2BB8   ROUND
0x2BB5 X ENDINK2
0x2B9A   CHKINK
0x2B96   SRTINK
0x2BAC   ENDINK
0x2B82   INKEY2
0x2B73   CMP_A
0x2B21   NOS3
0x2B08   NOS2
0x2AF5   NOS1
0x2AC5   SNDOVR
0x2B18   WRTSND
0x2A90   SND1
0x2A22   RPVOLCG
0x2A2E   VOLCH
0x2987   PKEPRMS
0x2971   SYSRET
0x2963   NOSYSPR
0x2925   NMIINT
0x2931   NMIVR1
0x291B   NMIEINT
0x2917   NMI2
0x2922   NMIDINT
0x28F5   DISNMI
0x2906   NM1
0x5166   OTPORT
0x28BE   WAITLP
0x28BD   NOXOR
0x5165   OUTSUB
0x28C7   SETIO
0x519D   INPSUB
0x519E   INPORT
0x2886   VAL2
0x2889   VAL3
0x287C   VAL1
0x2C30   RESZER
0x2847   RSTSTR
0x2892   MIDNUM
0x2813   LVINSTR
0x281D   CNTZIN
0x27BD   RP2INST
0x27E6   CNT1INS
0x2796   RPTINST
0x2808   RZINSTR
0x52F2   DY
0x2785   EMPTINS
0x52EC   TF
0x52EA   TP
0x52E8   PT2
0x52E4   PT
0x52E2   ADRS2
0x52E0   LNS2
0x52DE   ADRS1
0x52DC   LNS1
0x270C   ALLFOL
0x2704   MID1
0x3F6B   BINERR
0x2702   RIGHT1
0x288D   LFRGNM
0x28DD   MAKINT
0x26E1 X GTFLNM
0x26D2   GETLEN
0x26BB   POPHL
0x269C   GETSTR
0x2693   TSALP
0x2689   SSTSA
0x26A2   GSTRHL
0x25F6   GRBARY
0x262D   SCNEND
0x25D6   GNXARY
0x2607   STRADD
0x25D7   ARRLP
0x25C1   SMPVAR
0x2604   STPOOL
0x25B0   GRBLP
0x25A2   GARBLP
0x2593   TESTOS
0x2577   GRBDON
0x2566   PRSLP
0x255B   PRNUMS
0x253C   TSTOPL
0x2530   CRTSTE
0x2521   QTSTLP
0x250B   MKTMST
0x2692   TOSTRA
0x250E   CRTMST
0x2575   TESTR
0x26FA   TOPOOL
0x24EC   STR1
0x2514   SVSTAD
0x24D5   CHEKFN
0x244D   PASSA
0x2E78   RETINT
0x259F   GARBGE
0x2438   FRENUM
0x2417   ENDTMR
0x23E3   FNDELP
0x2402   ENDDIM
0x23C1   ZERARY
0x2F4D   MLDEBC
0x23A3   DEFSIZ
0x239B   CRARLP
0x237B   BSERR
0x23DE   FINDEL
0x2362   NXTARY
0x2380   CREARY
0x234E   FNDARY
0x2326   SCPTLP
0x2304   ZEROLP
0x2315   RETNUL
0x2312   RETADR
0x22D3   FNTHR
0x22DE   CFEVAL
0x22C5   FNDVAR
0x2D51   POPHRT
0x532C   FNARG
0x2320   SBSCPT
0x22AB   NSCFOR
0x2348   ARLDSV
0x229B   NOTSTR
0x2280   ENDNAM
0x228C   CHARTY
0x227F   SVNAM2
0x2268   GTFNAM
0x5291   LCRFLG
0x2255   DIMRET
0x2E73   FLGREL
0x2E6C   FLGDIF
0x221C   CMPSTR
0x26A3   GSTRDE
0x269F   GSTRCU
0x2234   CMPRES
0x21F2   CMPLG1
0x21F0   CMPLOG
0x21D9   PXOR1
0x21CC X PAND1
0x21D1   POR1
0x243D   ACPASS
0x2EA2   FPBCDE
0x21B1   CNTLGC
0x2197   SGNEXP
0x218E   GOFUNC
0x2186   FNVAL
0x2147   FRMEVL
0x213F   RETNUM
0x2E8A   INVSGN
0x212B   EVLPAR
0x2155   FNOFST
0x247F   DOFN
0x223E   EVNOT
0x2133   MINUS
0x3F40   BINTFP
0x3ED0   HEXTFP
0x2108   NOTAMP
0x2144   CONVAR
0x2E92   STAKFP
0x20C6   STKTHS
0x2652   CONCAT
0x21DE   TSTRED
0x52AA   CUROPR
0x209E   FOPRND
0x2082   RLTLP
0x2075   EVAL3
0x52B5   NXTOPR
0x2072   EVAL2
0x20DD   OPRND
0x2069   EVAL1
0x2062   OPNPAR
0x2058   TSTSTR
0x2044   KILFOR
0x2EB0   LOADFP
0x2BBB   ADDPHL
0x2E9F   PHLTFP
0x200C   NEXT1
0x1FFE   FANDT
0x1FD5   EXTIG
0x1FBA   MORDT
0x2F68   ASCTFP
0x1FAE   LTSTND
0x251E   DTSTR
0x1F94   ITMSEP
0x1F97   STRENT
0x1FA3   INPBIN
0x1FE5   FDTLP
0x1F79   ANTVLU
0x1F4D   NEDMOR
0x1F51   GTVLUS
0x1F45   NXTITM
0x1F28   NOPMPT
0x24C7   IDTEST
0x52B2   READFG
0x1EFD   BADINP
0x1EEB   REDO
0x1EDC   SPCLP
0x1ED5   DOSPC
0x28D7   FNDNUM
0x1EB5   ZONELP
0x1EA2   CNTEND
0x255F   PRS1
0x251A   CRTST
0x3006   NUMASC
0x1E7F   PRNTST
0x1EE4   NEXITM
0x1EA7   DOCOM
0x1EC0   DOTAB
0x1E38   PRNTLP
0x1E31   MRPRNT
0x1E1A   IF0
0x1E23   IF1
0x1E11   IFGO
0x1DF5   ONGOLP
0x1DF4   ONGO
0x28DA   GETINT
0x2EB9   FPTHL
0x2EBC   DETHL4
0x24F6   SAVSTR
0x26BD   BAKTMP
0x52A4   TMPSTR
0x1DD5   MVSTPT
0x1DCD   CRESTR
0x5330   FPREG
0x1DA6   LETSTR
0x1DDE   LETNUM
0x2059   CHKTYP
0x2066   EVAL
0x5292   TYPE
0x2263   GETVAR
0x1D7D   NXTSTT
0x1D7A   NXTSTL
0x1D73   NXTDTA
0x1D6E   RETLIN
0x1D30   RUNLIN
0x1CE9   STORED
0x1C9F   GTLNLP
0x1C9C   GETLN
0x2EDC   CMPNUM
0x2F09   FPINT
0x5333   FPEXP
0x1C7B   DEPINT
0x1C78 X POSINT
0x2ACB   NOISUP
0x1C75   FPSINT
0x1C6D   CHKLTR
0x51A4   CHKSUM
0x1C60 X ACCSUM
0x1C41   ERRINT
0x52B7   ERRLIN
0x1C30   NOLIN
0x1C1A   INPBRK
0x51A7   BRKFLG
0x1C04   STALL
0x1C0E   BRK
0x5328   NXTDAT
0x1BF1   UPDATA
0x1BF0   RESTNL
0x1BB3   ONJMP
0x1BB2   IFJMP
0x1C1D   ENDPRG
0x1B8B   RUNCNT
0x1B87   PUTFID
0x2E61   TSTSGN
0x1B7E   SAVSTP
0x2EAD   BCDEFP
0x2054   GETNUM
0x2057   TSTNUM
0x1B42   FORFND
0x1B26   FORSLP
0x52AC   LOOPST
0x1B0B   CNTWTSP
0x1AFF   WTSPC
0x1AF7   LVSRLN
0x1AEC   SRCLN1
0x1AC9   OUTWRD
0x1AD7   NXTLN
0x1AB0   LSTLP3
0x1AAD   LSTLP2
0x1AA1   LST07
0x1A9E   LST08
0x1AF9   TSTSPC
0x1BF6   TSTBRK
0x365D   PAINT4
0x1A73   LST02
0x1A70   LST05
0x1A33   LST06
0x1A5C   LST03
0x1A37   LSTNOT
0x1A18   LST01H
0x1A7C   LISTLP
0x1AEB   SRCLN
0x1AE5   SRCHLIN
0x1A15   LST01
0x1A44   LSTALL
0x3317   GETINP
0x3F70   MONOUT
0x19C8   SND2VID
0x19B5   INCLEN
0x5290   CURPOS
0x51A0   LWIDTH
0x19B9   DINPOS
0x2591   POPAF
0x198A   CHKSYN
0x197B   OUTIT
0x197E   OUTNBS
0x3F91   OUTNCR
0x1967   PUTBUF
0x1E8E   ENDINP
0x1961   GMNCR
0x196C   PUTCTL
0x192C   PROCES
0x19D6   CLOTST
0x1904   KILIN
0x18F9   DELCHR
0x1913   MORINP
0x1901   OTKLN
0x18ED   ECHDEL
0x51A2   NULFLG
0x18D9   DODEL
0x18C0   NXTCHR
0x18BA   TSTREM
0x18B7   SETLIT
0x1899   NOCHNG
0x1890   NOSPC
0x18A1   MATCH
0x187F   NXTBYT
0x186F   GETNXT
0x186D   SEARCH
0x18A5   RETNAD
0x1854   FNDWRD
0x18D0   ENDBUF
0x18C9   CPYLIT
0x18A9   MOVDIR
0x182A   CRNCLP
0x5293   DATFLG
0x51A8   RINPUT
0x180D   DOAGN
0x532A   FNRGNM
0x52B0   FORFLG
0x52B9   CONTAD
0x5296   TMSTPT
0x5298   TMSTPL
0x5324   VAREND
0x52A8   STRBOT
0x52B3   BRKLIN
0x17DE   INTVAR
0x17B1   SRCHLP
0x5233   BASTXT
0x17A2   FNDEND
0x1796   PTRLP
0x17DA   RUNFST
0x1789   MOVBUF
0x1791   SETPTR
0x175B   SFTPRG
0x5322   PROGND
0x176A   INEWLN
0x1D4A   ULERR
0x1753   LINFND
0x17AE   SRCHLN
0x52B1   LSTBIN
0x1BAB   EXCUTE
0x1821   CRUNCH
0x190A   GETLIN
0x170F   GETCMD
0x1701   POPNOK
0x2FF3   LINEIN
0x51AF   HLPLN
0x16FD   PTLN
0x16E0   ERRIN
0x1995   OUTC
0x1E86   STTLIN
0x51A3   CTLOFG
0x16BA   TMERR
0x16B7   OVERR
0x16B4   UFERR
0x16B1   DDERR
0x16AE   NFERR
0x16AB   DZERR
0x52AE   DATLIN
0x16A2   DATSNR
0x16A0   LDG1ND
0x168F   LDG1
0x1682   EXITGM
0x16BC   ERROR
0x167D   OMERR
0x5326   ARREND
0x1665   CHKSTK
0x165A   MOVLP
0x1657   MOVSTR
0x166E   ENFMEM
0x1654   MOVUP
0x164B   INDFND
0x1635   LOKFOR
0x1631   BAKSTK
0x162B   BRKMSG
0x1626   OKMSG
0x1625   ZERBYT
0x1621   INMSG
0x161A   ERRMSG
0x1598 X DEFFNKS
0x1596   AUTORP
0x190A   TTYLIN
0x1C96   FCERR
0x21AA   POR
0x21AF   PXOR
0x21A7   PAND
0x2C1B   BNORM
0x3103   POWER
0x2D58   DINT
0x2D60   MOD
0x2DB5   DIV
0x2D03   MULT
0x2BC5   PSUB
0x2FE2   PADD
0x1523   PRITAB
0x00E9   ZLEFT
0x00E1   ZINSTR
0x00E0   ZPOINT
0x00CA   ZSGN
0x00C9   ZLTH
0x00C8   ZEQUAL
0x00C7   ZGTR
0x00C6   ZOR
0x00C2 X ZDINT
0x00C1 X ZMOD
0x00C0 X ZDIV
0x00BF X ZTIMES
0x00BE   ZMINUS
0x00BD   ZPLUS
0x00BC   ZSTEP
0x00BB   ZNOT
0x00BA   ZTHEN
0x00B9   ZSPC
0x00B8   ZFN
0x00B7   ZTO
0x00B6   ZTAB
0x00B5   ZNEW
0x00AF   ZPRINT
0x00AE   ZELSE
0x008E   ZREM
0x008C   ZGOSUB
0x0088   ZGOTO
0x0083   ZDATA
0x0081   ZFOR
0x0080   ZEND
0x17CE   NEW
0x3E7A   SAVE
0x3E79   LOAD
0x1CC0   CLEAR
0x19E9   LIST
0x1C47   CONT
0x1E35   PRINT
0x3F73   RESET
0x2945   SYS
0x332D   WIDTH
0x34AD   GPRINT
0x28EB   NMI
0x3D0C   KEY
0x3319   CLS
0x3CF1   HELP
0x3AAF   SERIAL
0x359E   PAINT
0x38AA   CIRCLE
0x3774   DRAW
0x36E1   PLOT
0x33F1   COLOR
0x3357   PAUSE
0x2A00   VOLUME
0x2A39   SOUND
0x29AD   LOCATE
0x2B2D   VREG
0x29DF   SREG
0x29A2   VPOKE
0x3340   DOKE
0x299D   POKE
0x2452   DEF
0x28A9   WAIT
0x3E7C   ERASE
0x3E7B   FILES
0x1DE5   ON
0x28A3   POUT
0x1C13   STOP
0x1D76   REM
0x1D4F   RETURN
0x1D20   GOSUB
0x1BDB   RESTOR
0x1E03   IF
0x1D0C   RUN
0x1D31   GOTO
0x1D8B   LET
0x1F40   READ
0x225E   DIM
0x1F0E   INPUT
0x1D74   DATA
0x2009   NEXT
0x1B12   FOR
0x1C15   PEND
0x14B7   WORDTB
0x132A   WORDS
0x282E   MID
0x2824   RIGHT
0x26FE   LEFT
0x3F0E   BIN
0x3E7D   HEX
0x26EE   CHR
0x26DD   ASC
0x285E   VAL
0x24E6   STR
0x3B53   RXEND
0x26CE   LEN
0x272E   INSTR
0x368E   POINT
0x2B68   INKEY
0x2B54   SSTAT
0x2B49   VSTAT
0x297A   VPEEK
0x3335   DEEK
0x2973   PEEK
0x32CA   ATN
0x32B5   TAN
0x3376   SCREEN
0x3254   SIN
0x324E   COS
0x3148   EXP
0x2CC4   LOG
0x31D9   RND
0x30FA   SQR
0x244A   POS
0x2897   INP
0x241C   FRE
0x52E6   PT1
0x5162   USR
0x2E86   ABS_
0x2F34   INT
0x2406   TMR
0x2E70   SGN
0x12E6   FNCTAB
0x1702   PRNTOK
0x3D19   RESFN
0x1277   BRKRET
0x523B   STACK
0x128C   BFREE
0x2FFB   PRNTHL
0x1283   BLNSPC
0x17CF   CLRPTR
0x51AB   STRSPC
0x5294   LSTRAM
0x1240   NODOS
0x1984   CPDEHL
0x16A8   SNERR
0x1C9B   ATOH
0x1229   SETTOP
0x1205   MLOOP
0x53A9   STLOOK
0x1217   TSTMEM
0x1BCB   GETCHR
0x1811   PROMPT
0x255C   PRS
0x12DB   MEMMSG
0x11EF   MSIZE
0x1202   MNOASK
0x2A47   CTSNDC
0x5345   PROGST
0x5236   BUFFER
0x1E98   PRNTCRLF
0x17F4   CLREG
0x1ABF   FNDTOK
0x161A   INITBE
0x1541   INITAB
0x11D4   INIT
0x515C   WRKSPC
0x243E   ABPASS
0x1E7B   PRNTNB
0x1C81   DEINT
0x11CD   CSTART
0x1274   WARMST
0x11C6   STARTB
0x1010 X ERRORS
0x11B6   HPMSG
0x100E X HPPTR
0x11A0   SOMSG
0x1187   SAMSG
0x100A X SAPTR
0x1172   SCMSG
0x1008 X SCPTR
0x1006 X GMPRT
0x1156   BNMSG
0x1004 X BNPTR
0x114B   HXMSG
0x1002 X HXPTR
0x113B   MOMSG
0x1000 X MOPTR
0x3EB3   BYT2ASC
0x1125   UFMSG
0x0FFE X UFPTR
0x1116   CNMSG
0x0FFC X CNPTR
0x10FB   STMSG
0x0FFA X STPTR
0x100C X SOPTR
0x10EB   LSMSG
0x0FF8 X LSPTR
0x10D7   OSMSG
0x0FF6 X OSPTR
0x10C8   TMMSG
0x0FF4 X TMPTR
0x10B9   IDMSG
0x0FF2 X IDPTR
0x10A8   DZMSG
0x0FF0 X DZPTR
0x1093   DDMSG
0x0FEE X DDPTR
0x1085   BSMSG
0x0FEC X BSPTR
0x1076   ULMSG
0x3E6D   CHKEY3
0x0FEA X ULPTR
0x1068   OMMSG
0x0FE8 X OMPTR
0x105F   OVMSG
0x0FE6 X OVPTR
0x1049   FCMSG
0x0FE4 X FCPTR
0x103D   ODMSG
0x0FE2 X ODPTR
0x1028   RGMSG
0x0FE0 X RGPTR
0x1021   SNMSG
0x0FDE X SNPTR
0x1010   NFMSG
0x0FDC X NFPTR
0x0FDC   ERRTBL
0x0032   HP
0x0030   SO
0x002E   SA
0x002C   SC
0x002A   GM
0x0028   BN
0x0026 X HX
0x0024   MO
0x0022   UF
0x0020   CN
0x001E   ST
0x1EDA   ASPCS
0x001C   LS
0x001A   OS
0x0018   TM
0x0016   ID
0x0014   DZ
0x0012   DD
0x0010   BS
0x000E   UL
0x000C   OM
0x000A   OV
0x0008   FC
0x0006   OD
0x0004   RG
0x0002   SN
0x0000   NF
0x007F   DEL
0x0020   SPC
0x001B   ESC
0x0015   CTRLU
0x0013   CTRLS
0x0012   CTRLR
0x0011   CTRLQ
0x000F   CTRLO
0x0007   CTRLG
0x0EB4   CNTFNK
0x0EC7   PRNTFNK
0x0EBA   PUTCHRBUF1
0x0EA0   LDFNKEYCHR
0x51B3   FNKEYS
0x51AD   LINEAT
0x129A   SIGNON
0x0E87 X LVKBRDCHK
0x0E80   PNT2VD
0x0E73   PUTCHRBUF
0x0E61   SNDKEYTOBFR
0x0E88   PRNTFNKEY
0x0E59   CHKFNK
0x0ED4   FNKEYSORD
0x0E53   CNTKBCK
0x0003   CTRLC
0x51B2   AUTOKE
0x2C1E   BNRMLP
0x0E40   SENDKEY
0x0E11   SETNEWAUTO
0x0E83   LVKBRDCHK2
0x51B1   KEYDEL
0x0E21   CHKAUTO
0x531B   KEYTMR
0x0E33   NEWKEY
0x0F5C   KBMAP_ALT
0x0F9C   KBMAP_CTRL
0x0DD8   CHKALT
0x0DDF   LOADMAP
0x0F1C   KBMAP_SFT
0x0DCF   CHKCTRL
0x0EDC   KBMAP
0x0DBB   CHKLN
0x531A   STATUSKEY
0x5319   LASTKEYPRSD
0x0DA3   ENDCTRLCK
0x0D9D   TESTCTRL
0x0DB9   FINDKEY
0x0D90   TESTALT
0x5317   KBTMP
0x0DA7   NOKEYPRSD
0x0D61   RPTKBDRD
0x0D5D   CHECKKBD
0x0D4F   CHECKCTRL
0x531D   CONTROLKEYS
0x0D41   CHECKALT
0x0D01   CNTCHKSND
0x0CC6   CHKSNDCH
0x0C94   RPTWLCMBP
0x0CAA   NOBPDAT
0x0C91   SENDSND
0x0CA2   WLCBPDAT
0x0CB7   WRTSNDREG
0x0CB2   SETSNDREG
0x0C78   SNDREGCFG
0x0C64   CLRPSGREGS
0x0C60   EMPTSNDBFR
0x0B12 X VDPMODESETEX2
0x0B0A X VDPMODESETMC
0x0B02 X VDPMODESET2
0x251B   QTSTR
0x0AFA X VDPMODESET1
0x0AE8   SENDCHRPTRNS
0x47FA   CHRST88
0x0AE4   NXTCHAR
0x3FFA   CHRST68
0x0AC7   LDREGVLS
0x0AF2   VDPMODESET
0x0AB0   RSTVDPRAMREG
0x5310   CHASNDDTN
0x0AA1   EMPTVRM
0x0A35 X CNTNULL2
0x0A28   RPTNLLSRC2
0x3FA2   MUL16
0x0A03   ADDNEWLINE
0x09D0   SNDCHRTOBFR
0x09B7   CNTNULL
0x09A7   RPTNLLSRC
0x09EF   PRNTRETURN
0x52E2   TMPBFR4
0x52E0   TMPBFR3
0x52DE   SRTTXT
0x52DE   TMPBFR2
0x097D   RPTEMPTYROW
0x0962   WRITEBUF
0x0939   LOADNEXTCOL
0x52E4   VIDEOBUFF
0x0927   SCROLLNXTRW
0x530E   VIDTMP2
0x530C   VIDTMP1
0x0905   EXITCURSOR_ON
0x08EF   EXITCURSORDOWN
0x08CF   EXITCURSORRGHT
0x08C9   CONTCRSRGT
0x08B6   CHCKYPOS2
0x089B   EXITCURSORUP
0x0872   CHKYPOS
0x085F   EXITCURSORLEFT
0x085C   CONTCRSLFT
0x084B   CHCKYPOS
0x0861   MVCRS2LFT
0x0818 X ENDINSRT
0x0813   NXTINST
0x3F97   CMP16
0x0802   CHKHL
0x52E0   ENDTXT
0x0A10   ENDOFLN
0x52DC   CUR_POS
0x07E0   PUTCRSCHR
0x090E   SCROLLUP
0x079F   SETCRSRY
0x07A0   SETCSRCOORDS
0x07B2   EXITCHAR2VID
0x0776   NXTCPCK
0x0769   RPTCPCK
0x07BF   PLACEHOLDER
0x000A   LF
0x07E4   INSERTKEY
0x001A   INSRT
0x08D2   CURSORDOWN
0x001F   CRSDN
0x089D   CURSORRIGHT
0x001D   CRSRGT
0x0884   CURSORUP
0x001E   CRSUP
0x0838   CURSORLEFT
0x001C   CRSLFT
0x0825   BACKSPACE
0x340E   CNTCKCL
0x0008   BKSP
0x0989   CRGRETURN
0x000C   CS
0x0019   HOME
0x0738   CHRTBL
0x3FD6   DIV_16_8
0x0727   HL2XY
0x0A36   POS_TB_CRS_32
0x0719   CONT_POS_CURS
0x0A66   POS_TB_CRS_40
0x52D7   LSTCSRSTA
0x06D1   MOVSHOWCRS
0x06E6   NEWCRSRCOORD
0x06FB   RSTCHRCRS
0x0704   LOAD_CRSR_POS
0x06BA   READ_VSTAT
0x06AF   WRITE_VREG
0x069A   WRITE_VIDEO_LOC
0x0685   READ_VIDEO_LOC
0x06CB   MOVCRS
0x52D3   SCR_CUR_NX
0x0000   NLLCR
0x52D4   SCR_CUR_NY
0x067B   ATHOME
0x06C1   POS_CURSOR
0x066E   CLEARVIDBUF
0x065B   RPTFLL1
0x0648   SNDCLRSET
0x0644   STARTEMPTY
0x060E   CLRG2PTNTBL
0x05F3   RPTEMPTYBUF
0x05ED   LDCOLSTOEMPTY
0x062D   EMPTYMC
0x05FC   EMPTYG2
0x05D1   LVCKSHF
0x0D0C   READKBLN
0x05B4   SNDLOGPT
0x2C7B   COMPL
0x4FFA   LOGOFONT
0x0C8E   NOBEEP
0x0C88   WLCMBEEP
0x057F   RPT100
0x05C3   CHECKSHIFT
0x0595   BEEPOFF
0x0589   SETBEEP
0x0552   DEC_D
0x5321   DOS_EN
0x52DC   TMPBFR1
0x0540   RPT104
0x059D   LOADLOGOCHRS
0x0538   RPT103
0x0B1A   LM80CLOGO
0x0522   RPT102
0x0C6B   RSTPSG
0x051F   RPT101
0x05BE   CLRTABLE
0x0571   ERASECLRTBL
0x0652   SETNAMETABLE
0x0ABD   SET_GFX_MODE2
0x52D5   SCR_ORG_CHR
0x05D3   EMPTYVIDBUF
0x045A   LDCLRTBMD1
0x52DA   FRGNDCLR
0x0665   SETVDPADRS
0x04EB   ENDVDPSET
0x52CF   SCR_NAM_TB
0x51A1   COMMAN
0x52CC   SCR_SIZE_H
0x52CB   SCR_SIZE_W
0x52DB   BKGNDCLR
0x52D2   SCR_CURS_Y
0x04E2   LDCLRTBEX2
0x52D1   SCR_CURS_X
0x0AD1   LOADCHARSET
0x03F8 X TXTMD
0x04A8   EXG2MD
0x0485   MCMD
0x0463   G2MD
0x0422   G1MD
0x52CD   SCR_MODE
0x0AAA   CLR_RAM_REG
0x0AB5   SET_GFX_MODE
0x0A96   EMPTY_VRAM
0x0367   RESTMR
0x036C   CTCCONF
0x033E X SIO_B_SETS
0x0338   SIO_A_SETS
0x11C3   WARM
0x11C0   COLD
0x0907   CURSOR_OFF
0x031E   ECHO_CHAR
0x0311   CHECKWARM
0x02FA   CORW
0x08F2   CURSOR_ON
0x03B6   MSGTXT2
0x0306   COLDSTART
0x515B   basicStarted
0x0378   MSGTXT1
0x52D8   PRNTVIDEO
0x3F82   INITST
0x03D3   initVDP
0x04F6   SHOW_LOGO
0x0C5A   initPSG
0x0342   initCTC
0x02B3   INIT_HW2
0x528D   TEMPSTACK
0x02B0   INIT_HW
0x0D21   KEYBOARD
0x0CBC   MNGSNDS
0x07C0   FLASHCURSOR
0x029C   CHKCRSR
0x0296   INCTMR3
0x52BB   TMRCNT
0x028D   CH3_TIMER
0x027F   RAWPRINT
0x026B   EXTXA
0x026E   TX_EMP
0x0266   TXA_EXIT
0x0257   CNTTXA
0x0249   RXA_EXIT
0x0238   NOTRDWRAP
0x5158   serRdPtr
0x50FE   SERBUF_START
0x020B   NOTWRAP
0x0056   bufWrap
0x5156   serInPtr
0x01FF   NOTFULL
0x515A   serBufUsed
0x01E2   SIO_B_EI
0x01E8   SIO_RXEN
0x01DA   SIO_A_EI
0x01D0   SIO_RXDI
0x01B0 X B_RTS_ON
0x01B6   SIO_RTS_ON
0x01A8   A_RTS_ON
0x5320   SERBBITS
0x019C   SIO_RTS_OFF
0x531F   SERABITS
0x0180   EMPTYCHBBFR
0x01CA   SIO_B_DI
0x0196   B_RTS_OFF
0x3CDD   SOERR
0x015C   CHABFREMPTY
0x014E   EMPTYCHABFR
0x531E   SERIALS_EN
0x01C2   SIO_A_DI
0x1161   GMMSG
0x0756   CHAR2VID
0x52D6   CRSR_STATE
0x5316   KBDNPT
0x0120   CNTRXCHA
0x000D   CR
0x52D9   CHR4VID
0x0130   LVRXCHA
0x01F4   CHARINTOBFR
0x5318   TMPKEYBFR
0x018E   A_RTS_OFF
0x00EC   FMVEREND
0x00D0 X FWVER
0x515F   NMIUSR
0x52C8   CTC3IV
0x52C5   CTC2IV
0x52C2   CTC1IV
0x52BF   CTC0IV
0x027A   CKINCHAR
0x0018 X RST18
0x0223   RXA
0x0010 X RST10
0x0135   SPEC_RXA_CNDT
0x0100   RX_CHA_AVAIL
0x024D   TXA
0x0008 X RST08
0x0167   SPEC_RXB_CNDT
0x0164   RX_CHB_AVAIL
0x50CF   ROM2RAM
0x0000 X RST00
0x0005   SER_EMPTYSIZE
0x0050   SER_FULLSIZE
0x0058   SER_BUFSIZE
0x0041   PSG_DAT
0x0040   PSG_REG
0x0032   VDP_SET
0x0030   VDP_DAT
0x0021   SIO_DB
0x0020   SIO_DA
0x0023   SIO_CB
0x0022   SIO_CA
0x0013   CTC_CH3
0x0012   CTC_CH2
0x0011   CTC_CH1
0x0010   CTC_CH0
0x0003   PIO_CB
0x0002 X PIO_CA
0x0001   PIO_DB
0x0000 X PIO_DA
