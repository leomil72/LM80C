# file opened: LM80C_64K-firmware-r1.19.asm
   1  0000              ; ------------------------------------------------------------------------------
   2  0000              ; LM80C 64K - FIRMWARE - R1.19
   3  0000              ; ------------------------------------------------------------------------------
   4  0000              ; The following code is intended to be used with LM80C Z80-based computer
   5  0000              ; designed by Leonardo Miliani. More info at
   6  0000              ; www DOT leonardomiliani DOT com
   7  0000              ; ------------------------------------------------------------------------------
   8  0000              ; Coding/Editing/Compiling:
   9  0000              ; Original init code for MC68B05 by Grant Searle
  10  0000              ; Original SIO/CTC/PIO init code by Mario Blunk
  11  0000              ; NASCOM BASIC originally modified by Gran Searle
  12  0000              ; Code modified and adapted for LM80C by Leonardo Miliani
  13  0000              ;
  14  0000              ; Edited with Visual Studio Code
  15  0000              ;
  16  0000              ; Compiled with SjASMPlus assembler 1.18.2
  17  0000              ; https://github.com/z00m128/sjasmplus
  18  0000              ; ------------------------------------------------------------------------------
  19  0000              ; Copyright notes:
  20  0000              ; Parts of the code (c) Grant Searle - free for non commercial use
  21  0000              ; Please include this advice and the note to the attribution of the original
  22  0000              ; version to Grant Searle if you intend to redistribuite it
  23  0000              ; http://searle.hostei.com/grant/index.html
  24  0000              ; eMail: home.micros01@btinternet.com
  25  0000              ;
  26  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  27  0000              ; Parts of the code (c) Mario Blunk
  28  0000              ; http://www.trainÂ­z.de
  29  0000              ;
  30  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  31  0000              ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  32  0000              ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  33  0000              ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  34  0000              ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  35  0000              ; the original ROM code (checksum A934H). PA
  36  0000              ;
  37  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  38  0000              ; The following code is intended to be used with LM80C Z80-based computer
  39  0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
  40  0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
  41  0000              ; kind of warranty: you can use them at your own risk.
  42  0000              ; You are free to use them for any non-commercial use: you are only asked to
  43  0000              ; maintain the copyright notices, include this advice and the note to the
  44  0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  45  0000              ; redistribuite them.
  46  0000              ; https://www.leonardomiliani.com
  47  0000              ;
  48  0000              ; Please support me by visiting the following links:
  49  0000              ; Main project page: https://www.leonardomiliani.com
  50  0000              ; Schematics and code: https://github.com/leomil72/LM80C
  51  0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  52  0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  53  0000              ; ------------------------------------------------------------------------------
  54  0000              ; set name for binary output file
  55  0000                  OUTPUT "LM80C-64K-firmware-r1.19.bin"
  56  0000
  57  0000              ; set firmware version
  58  0000                  DEFINE VERSION "1.19"
  59  0000
  60  0000              ; set DOS version
  61  0000                  DEFINE  DOS_VER "1.06"
  62  0000
  63  0000              ; ------------------------------------------------------------------------------
  64  0000              ; include the latest version of the bootloader: this sets up the address aliases,
  65  0000              ; configure the hardware, checks if warm or cold startup and loads the BASIC interpreter
  66  0000                  INCLUDE "../include/bootloader/bootloader-1.07.asm"
# file opened: ../include/bootloader/bootloader-1.07.asm
   1+ 0000              ; ------------------------------------------------------------------------------
   2+ 0000              ; LM80C - BOOTLOADER - 1.07
   3+ 0000              ; ------------------------------------------------------------------------------
   4+ 0000              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0000              ; kind of warranty: you can use them at your own risk.
   8+ 0000              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0000              ; maintain the copyright notices, include this advice and the note to the
  10+ 0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0000              ; redistribuite them.
  12+ 0000              ; https://www.leonardomiliani.com
  13+ 0000              ;
  14+ 0000              ; Please support me by visiting the following links:
  15+ 0000              ; Main project page: https://www.leonardomiliani.com
  16+ 0000              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0000              ; ------------------------------------------------------------------------------
  20+ 0000
  21+ 0000              ; ADDRESS DECODING (bits A6/A5/A4)
  22+ 0000              ; 0000xxxx : PIO
  23+ 0000              ; 0001xxxx : CTC
  24+ 0000              ; 0010xxxx : SIO
  25+ 0000              ; 0011xxxx : VDP
  26+ 0000              ; 0100xxxx : PSG
  27+ 0000              ; 0101xxxx : C.F.
  28+ 0000
  29+ 0000
  30+ 0000              ; ------------------------------------------------------------------------------
  31+ 0000              ;               EQUATES
  32+ 0000              ; ------------------------------------------------------------------------------
  33+ 0000              ; label defining for PIO (Parallel Input/Output)
  34+ 0000              PIO_DA          equ %00000000
  35+ 0000              PIO_DB          equ %00000001
  36+ 0000              PIO_CA          equ %00000010
  37+ 0000              PIO_CB          equ %00000011
  38+ 0000
  39+ 0000              ; label defining for CTC (Counter Timer Circuit)
  40+ 0000              CTC_CH0         equ %00010000
  41+ 0000              CTC_CH1         equ %00010001
  42+ 0000              CTC_CH2         equ %00010010
  43+ 0000              CTC_CH3         equ %00010011
  44+ 0000
  45+ 0000              ;label defining for SIO (Serial Input/Output)
  46+ 0000              SIO_CA          equ %00100010
  47+ 0000              SIO_CB          equ %00100011
  48+ 0000              SIO_DA          equ %00100000
  49+ 0000              SIO_DB          equ %00100001
  50+ 0000
  51+ 0000              ;label defining for VDP (Video Display Processor)
  52+ 0000              VDP_DAT         equ %00110000
  53+ 0000              VDP_SET         equ %00110001
  54+ 0000
  55+ 0000              ; label defining for PSG (Programmable Sound Generator)
  56+ 0000              PSG_REG         equ %01000000
  57+ 0000              PSG_DAT         equ %01000001
  58+ 0000
  59+ 0000              ; Interrupt-driven serial I/O interface lead by the Z80 SIO to run modified
  60+ 0000              ; NASCOM Basic 4.7 - Full input buffering with incoming data hardware handshaking
  61+ 0000              ; Handshake shows full before the buffer is totally filled to allow run-on from the sender
  62+ 0000              SER_BUFSIZE     equ     $58
  63+ 0000              SER_FULLSIZE    equ     $50
  64+ 0000              SER_EMPTYSIZE   equ     $05
  65+ 0000
  66+ 0000
  67+ 0000              ;------------------------------------------------------------------------------
  68+ 0000              ;                                F I R M W A R E
  69+ 0000              ;------------------------------------------------------------------------------
  70+ 0000              ; BASE MEMORY - RESET LOCATION ($0000) -> the CPU jumps to $0000 after a reset
  71+ 0000                              org     $0000
  72+ 0000 F3           RST00:          di                      ; be sure that INTs are disabled
  73+ 0001 C3 6C 53                     jp      ROM2RAM         ; jump to ROM/RAM switcher
  74+ 0004
  75+ 0004              ;------------------------------------------------------------------------------
  76+ 0004              ; interrupt vector when SIO ch.B has a char available in its buffer
  77+ 0004                              ;$0004
  78+ 0004 65 01                        defw    RX_CHB_AVAIL
  79+ 0006
  80+ 0006              ;------------------------------------------------------------------------------
  81+ 0006              ; interrupt vector for SIO ch.B special conditions (i.e. buf overrun)
  82+ 0006                              ;$0006
  83+ 0006 68 01                        defw    SPEC_RXB_CNDT
  84+ 0008
  85+ 0008              ;------------------------------------------------------------------------------
  86+ 0008              ; send a character over serial ch. A
  87+ 0008                              ;$0008
  88+ 0008 C3 59 02     RST08:          jp      TXA
  89+ 000B FF                           BLOCK   1,$FF   ; filler
  90+ 000C
  91+ 000C              ;------------------------------------------------------------------------------
  92+ 000C              ; interrupt vector when SIO ch.A has a char available in its buffer
  93+ 000C                              ;$000C
  94+ 000C 00 01                        defw    RX_CHA_AVAIL
  95+ 000E
  96+ 000E              ;------------------------------------------------------------------------------
  97+ 000E              ; interrupt vector for SIO ch.A special conditions (i.e. buf overrun)
  98+ 000E                              ;$000E
  99+ 000E 36 01                        defw    SPEC_RXA_CNDT
 100+ 0010
 101+ 0010              ;------------------------------------------------------------------------------
 102+ 0010              ; receive a character over serial ch. A
 103+ 0010                              ;$0010
 104+ 0010 C3 2A 02     RST10:          jp      RXA
 105+ 0013 FF FF FF...                  BLOCK   5,$FF   ; filler
 106+ 0018              ;------------------------------------------------------------------------------
 107+ 0018              ; check buffer state
 108+ 0018
 109+ 0018                              ;$0018
 110+ 0018 C3 78 02     RST18:          jp      CKINCHAR
 111+ 001B FF FF FF...                  BLOCK   $25,$FF ; filler
 112+ 0040              ;------------------------------------------------------------------------------
 113+ 0040              ; interrupt vectors for CTC
 114+ 0040                              ;$0040               ; for CH0 Timer - used in BASIC by serial 1 for bps
 115+ 0040 89 55                        defw    CTC0IV
 116+ 0042                              ;$0042               ; for CH1 Timer - used in BASIC by serial 2 for bps
 117+ 0042 8C 55                        defw    CTC1IV
 118+ 0044                              ;$0044               ; for CH2 timer - unused
 119+ 0044 8F 55                        defw    CTC2IV
 120+ 0046                              ;$0046               ; for CH3 Timer - used by FW for 100ths/s counter
 121+ 0046 92 55                        defw    CTC3IV
 122+ 0048 FF FF FF...                  BLOCK   $1E,$FF ; filler
 123+ 0066              ;------------------------------------------------------------------------------
 124+ 0066              ; interrupt routine for NMI
 125+ 0066                              ;$0066
 126+ 0066 C3 04 54                     jp      NMIUSR              ; jump to execute NMI service routine
 127+ 0069 FF FF FF...                  BLOCK   $27,$FF ; filler
 128+ 0090              ;------------------------------------------------------------------------------
 129+ 0090
 130+ 0090                              ;$0090
 131+ 0090 4C 4D 38 30                  defb    $4C,$4D,$38,$30,$43,$20,$36,$34
 131+ 0094 43 20 36 34
 132+ 0098 4B 20 43 4F                  defb    $4B,$20,$43,$4F,$4C,$4F,$52,$00
 132+ 009C 4C 4F 52 00
 133+ 00A0 43 4F 4D 50                  defb    $43,$4F,$4D,$50,$55,$54,$45,$52
 133+ 00A4 55 54 45 52
 134+ 00A8 20 28 32 30                  defb    $20,$28,$32,$30,$32,$31,$29,$00
 134+ 00AC 32 31 29 00
 135+ 00B0 44 65 73 69                  defb    $44,$65,$73,$69,$67,$6E,$65,$64
 135+ 00B4 67 6E 65 64
 136+ 00B8 20 62 79 00                  defb    $20,$62,$79,$00,$00,$00,$00,$00
 136+ 00BC 00 00 00 00
 137+ 00C0 4C 65 6F 6E                  defb    $4C,$65,$6F,$6E,$61,$72,$64,$6F
 137+ 00C4 61 72 64 6F
 138+ 00C8 20 4D 69 6C                  defb    $20,$4D,$69,$6C,$69,$61,$6E,$69
 138+ 00CC 69 61 6E 69
 139+ 00D0 46 57 20 31  FWVER:          defm    "FW ","1.19",$20,"2021-04-18",$20,"22:51:01",$00
 139+ 00D4 2E 31 39 20
 139+ 00D8 32 30 32 31
 139+ 00DC 2D 30 34 2D
 139+ 00E0 31 38 20 32
 139+ 00E4 32 3A 35 31
 139+ 00E8 3A 30 31 00
 140+ 00EC              FMVEREND:       equ     $
 141+ 00EC FF FF FF...                  BLOCK   $100-FMVEREND,$FF   ; filler
 142+ 0100              ;------------------------------------------------------------------------------
 143+ 0100
 144+ 0100              ;-------------------------------------------------------------------------------
 145+ 0100              ;               Z80 SIO CH. A MANAGEMENT
 146+ 0100              ;-------------------------------------------------------------------------------
 147+ 0100
 148+ 0100              ;-------------------------------------------------------------------------------
 149+ 0100              ; interrupt driven routine to get chars from Z80 SIO ch.A
 150+ 0100              ; this is the only serial channel that can print received chars onto the screen
 151+ 0100                              ;$0100
 152+ 0100 F5           RX_CHA_AVAIL:   push    AF              ; store A
 153+ 0101 E5                           push    HL              ; and HL
 154+ 0102 CD 8F 01                     call    A_RTS_OFF       ; disable RTS line
 155+ 0105 DB 20                        in      A,(SIO_DA)      ; read char from RX buffer into A
 156+ 0107 32 E1 55                     ld      (TMPKEYBFR),A   ; store it into the temp key buffer
 157+ 010A CD FD 01                     call    CHARINTOBFR     ; sub-routine to put the char into the input buffer
 158+ 010D D2 31 01                     jp      NC,LVRXCHA      ; if buffer is full, then leave without doing anything else
 159+ 0110 3A E1 55                     ld      A,(TMPKEYBFR)   ; retrieve char
 160+ 0113 32 A2 55                     ld      (CHR4VID),A     ; write into buffer for video printing
 161+ 0116 FE 0D                        cp      CR              ; is it RETURN?
 162+ 0118 CA 20 01                     jp      Z,CNTRXCHA      ; yes, continue
 163+ 011B FE 20                        cp      $20             ; is it another control char (code < 32)?
 164+ 011D DA 31 01                     jp      C,LVRXCHA       ; yes, leave w/o printing it on video nor sending back to serial
 165+ 0120 F5           CNTRXCHA:       push    AF              ; store char
 166+ 0121 AF                           xor     A
 167+ 0122 32 DF 55                     ld      (KBDNPT),A      ; a char from serial is like a char printed by BASIC
 168+ 0125 3A A1 55                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 169+ 0128 FE 01                        cp      $01             ; is the print on video on?
 170+ 012A CC 61 07                     call    Z,CHAR2VID      ; yes, print on screen
 171+ 012D F1                           pop     AF              ; retrieve char
 172+ 012E CD 59 02                     call    TXA             ; send back to serial
 173+ 0131 E1           LVRXCHA:        pop     HL              ; retrieve HL
 174+ 0132 F1                           pop     AF              ; and A
 175+ 0133 FB                           ei                      ; re-enable interrupts
 176+ 0134 ED 4D                        reti                    ; and exit
 177+ 0136
 178+ 0136              ;-------------------------------------------------------------------------------
 179+ 0136              ; special SIO ch.A condition (i.e., buffer overrun)
 180+ 0136              ; if buffer overruns then show an error, empty the RX buffer and send
 181+ 0136              ; a break char
 182+ 0136 F5           SPEC_RXA_CNDT:  push    AF              ; store AF
 183+ 0137 CD 8F 01                     call    A_RTS_OFF       ; disable RTS
 184+ 013A CD CB 01                     call    SIO_A_DI        ; disable RX on ch. A
 185+ 013D 3A E7 55                     ld      A,(SERIALS_EN)  ; load serial status
 186+ 0140 CB 97                        res     2,A             ; disable RX on port 1
 187+ 0142 32 E7 55                     ld      (SERIALS_EN),A  ; store new serial status
 188+ 0145 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 189+ 0147 CB E7                        set     4,A             ; set 5th pin ON
 190+ 0149 D3 01                        out     (PIO_DB),A      ; send new setting
 191+ 014B 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 192+ 014D D3 22                        out     (SIO_CA),A      ; send command to SIO
 193+ 014F AF           EMPTYCHABFR:    xor     A
 194+ 0150 D3 22                        out     (SIO_CA),A      ; write to WR0, select RR0
 195+ 0152 DB 22                        in      A,(SIO_CA)      ; read RR0 register
 196+ 0154 E6 01                        and     $01             ; check if input buffer if empty
 197+ 0156 CA 5D 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then leave
 198+ 0159 DB 20                        in      A,(SIO_DA)      ; read chars
 199+ 015B 18 F2                        jr      EMPTYCHABFR     ; repeat
 200+ 015D F1           CHABFREMPTY:    pop     AF              ; retrieve AF
 201+ 015E 21 A3 3E                     ld      HL,SOERR        ; return point set to Serial Buffer Overrun routine
 202+ 0161 E3                           ex      (SP),HL         ; store onto stack
 203+ 0162 FB                           ei                      ; re-enable interrupts
 204+ 0163 ED 4D                        reti                    ; return from interrupt and execute code at SOERR
 205+ 0165
 206+ 0165              ;-------------------------------------------------------------------------------
 207+ 0165              ;               Z80 SIO CH. A MANAGEMENT
 208+ 0165              ;-------------------------------------------------------------------------------
 209+ 0165
 210+ 0165              ;-------------------------------------------------------------------------------
 211+ 0165              ; interrupt driven routine to get chars from Z80 SIO ch.B
 212+ 0165 FB           RX_CHB_AVAIL:   ei
 213+ 0166 ED 4D                        reti
 214+ 0168
 215+ 0168              ;-------------------------------------------------------------------------------
 216+ 0168              ; special SIO ch.A condition (i.e., buffer overrun)
 217+ 0168              ; if buffer overruns then show an error, empty the RX buffer and send
 218+ 0168              ; a break char
 219+ 0168 F5           SPEC_RXB_CNDT:  push    AF              ; store A
 220+ 0169 CD 97 01                     call    B_RTS_OFF       ; disable RTS
 221+ 016C CD D3 01                     call    SIO_B_DI        ; disable RX on ch.B
 222+ 016F 3A E7 55                     ld      A,(SERIALS_EN)  ; load serial status
 223+ 0172 CB 9F                        res     3,A             ; disable RX on port 2
 224+ 0174 32 E7 55                     ld      (SERIALS_EN),A  ; store new serial status
 225+ 0177 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 226+ 0179 CB EF                        set     5,A             ; set 5th pin ON
 227+ 017B D3 01                        out     (PIO_DB),A      ; send new setting
 228+ 017D 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 229+ 017F D3 23                        out     (SIO_CB),A      ; send command to SIO
 230+ 0181 AF           EMPTYCHBBFR:    xor     A
 231+ 0182 D3 23                        out     (SIO_CB),A      ; write to WR0, select RR0
 232+ 0184 DB 23                        in      A,(SIO_CB)      ; read RR0 register
 233+ 0186 E6 01                        and     $01             ; check if input buffer if empty
 234+ 0188 CA 5D 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then jump to run "exit" code
 235+ 018B DB 21                        in      A,(SIO_DB)      ; read chars
 236+ 018D 18 F2                        jr      EMPTYCHBBFR     ; repeat
 237+ 018F
 238+ 018F
 239+ 018F              ;-------------------------------------------------------------------------------
 240+ 018F              ;               Z80 SIO MANAGEMENT
 241+ 018F              ;-------------------------------------------------------------------------------
 242+ 018F              ; disable RTS:
 243+ 018F              ; by resetting RTS bit (set to 0), the RTS line is disabled (HIGH)
 244+ 018F C5           A_RTS_OFF:      push    BC              ; store BC
 245+ 0190 0E 22                        ld      C,SIO_CA        ; select channel A
 246+ 0192 3A E8 55                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 247+ 0195 18 06                        jr      SIO_RTS_OFF
 248+ 0197 C5           B_RTS_OFF:      push    BC              ; store BC
 249+ 0198 0E 23                        ld      C,SIO_CB        ; select channel B
 250+ 019A 3A E9 55                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 251+ 019D CB 3F        SIO_RTS_OFF:    srl     A               ; position data bits in bits #5&6
 252+ 019F E6 60                        and     %01100000       ; get only bits #5&6
 253+ 01A1 47                           ld      B,A             ; store data bits
 254+ 01A2 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 255+ 01A4 ED 79                        out     (C),A
 256+ 01A6 3E 88                        ld      A,%10001000     ; enable DTR (b7) and TX (b4), disable RTS (b1)
 257+ 01A8 B0                           or      B               ; set data bits
 258+ 01A9 ED 79                        out     (C),A           ; send setting
 259+ 01AB C1                           pop     BC              ; retrieve BC
 260+ 01AC C9                           ret                     ; exit
 261+ 01AD
 262+ 01AD              ;-------------------------------------------------------------------------------
 263+ 01AD              ; enable RTS
 264+ 01AD              ; by setting RTS bit (set to 1), the RTS line is enabled (LOW)
 265+ 01AD C5           A_RTS_ON:       push    BC              ; store BC
 266+ 01AE 0E 22                        ld      C,SIO_CA        ; select channel A
 267+ 01B0 3A E8 55                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 268+ 01B3 18 06                        jr      SIO_RTS_ON
 269+ 01B5 C5           B_RTS_ON:       push    BC              ; store BC
 270+ 01B6 0E 23                        ld      C,SIO_CB        ; select channel B
 271+ 01B8 3A E9 55                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 272+ 01BB CB 3F        SIO_RTS_ON:     srl     A               ; position data bits in bits #5&6
 273+ 01BD E6 60                        and     %01100000       ; get only bits #5&6
 274+ 01BF 47                           ld      B,A             ; store data bits
 275+ 01C0 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 276+ 01C2 ED 79                        out     (C),A
 277+ 01C4 3E 8A                        ld      A,%10001010     ; enable DTR (b7), TX (b4), and RTS (b1)
 278+ 01C6 B0                           or      B               ; set data bits
 279+ 01C7 ED 79                        out     (C),A           ; send setting
 280+ 01C9 C1                           pop     BC              ; retrieve BC
 281+ 01CA C9                           ret                     ; return
 282+ 01CB
 283+ 01CB              ;-------------------------------------------------------------------------------
 284+ 01CB              ; disable SIO RX channel
 285+ 01CB C5           SIO_A_DI:       push    BC              ; store BC
 286+ 01CC 0E 22                        ld      C,SIO_CA        ; SIO channel A
 287+ 01CE 3A E8 55                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 288+ 01D1 18 06                        jr      SIO_RXDI        ; jump to disable RX
 289+ 01D3 C5           SIO_B_DI:       push    BC              ; store BC
 290+ 01D4 0E 23                        ld      C,SIO_CB        ; SIO channel B
 291+ 01D6 3A E9 55                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 292+ 01D9 47           SIO_RXDI:       ld      B,A             ; store data bits
 293+ 01DA 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 294+ 01DC ED 79                        out     (C),A
 295+ 01DE 78                           ld      A,B             ; retrieve data bits; RX disabled; auto enable is OFF
 296+ 01DF ED 79                        out     (C),A
 297+ 01E1 C1                           pop     BC              ; retrieve BC
 298+ 01E2 C9                           ret                     ; return
 299+ 01E3
 300+ 01E3              ;-------------------------------------------------------------------------------
 301+ 01E3              ; enable SIO RX channel
 302+ 01E3 C5           SIO_A_EI:       push    BC              ; store BC
 303+ 01E4 0E 22                        ld      C,SIO_CA
 304+ 01E6 3A E8 55                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 305+ 01E9 18 06                        jr      SIO_RXEN
 306+ 01EB C5           SIO_B_EI:       push    BC              ; store BC
 307+ 01EC 0E 23                        ld      C,SIO_CB
 308+ 01EE 3A E9 55                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 309+ 01F1 47           SIO_RXEN:       ld      B,A             ; store data bits
 310+ 01F2 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 311+ 01F4 ED 79                        out     (C),A           ; select register
 312+ 01F6 78                           ld      A,B             ; retrieve data bits
 313+ 01F7 CB C7                        set     0,A             ; set RX enabled; auto enable is OFF
 314+ 01F9 ED 79                        out     (C),A           ; send settings to SIO
 315+ 01FB C1                           pop     BC              ; retrieve BC
 316+ 01FC C9                           ret
 317+ 01FD
 318+ 01FD              ;------------------------------------------------------------------------------
 319+ 01FD              ; put a char into the input buffer, char is into A
 320+ 01FD              ; this sub is called both from the ISR "RX_CHA_AVAIL" and when
 321+ 01FD              ; the RETURN key is pressed on the keyboard
 322+ 01FD F5           CHARINTOBFR:    push    AF              ; store it
 323+ 01FE 3A FF 53                     ld      A,(serBufUsed)  ; load buffer size
 324+ 0201 FE 58                        cp      SER_BUFSIZE     ; if buffer is not full
 325+ 0203 DA 08 02                     jp      C,NOTFULL       ; then store the char
 326+ 0206 F1                           pop     AF              ; else drop it
 327+ 0207 C9                           ret                     ; and exit
 328+ 0208 2A FB 53     NOTFULL:        ld      HL,(serInPtr)   ; buffer is not full, can store the char
 329+ 020B 23                           inc     HL              ; load pointer to find first free cell
 330+ 020C 7D                           ld      A,L             ; only check low byte because buffer<256
 331+ 020D FE FB                        cp      bufWrap         ; check if the pointer is at the last cell
 332+ 020F 20 03                        jr      NZ,NOTWRAP      ; if not then continue
 333+ 0211 21 A3 53                     ld      HL,SERBUF_START ; else load the address of the first cell
 334+ 0214 22 FB 53     NOTWRAP:        ld      (serInPtr),HL   ; store the new pointer
 335+ 0217 F1                           pop     AF              ; then retrieve the char...
 336+ 0218 77                           ld      (HL),A          ; ...and store it in the appropriate cell
 337+ 0219 21 FF 53                     ld      HL,serBufUsed   ; size of the input buffer
 338+ 021C 34                           inc     (HL)            ; increment it
 339+ 021D 3E 50                        ld      A,SER_FULLSIZE  ; input buffer capacity
 340+ 021F BE                           cp      (HL)            ; check if input buffer is full
 341+ 0220 D8                           ret     C               ; exit if buffer is not full
 342+ 0221 3A E7 55                     ld      A,(SERIALS_EN)  ; check if serial 1 is open
 343+ 0224 1F                           rra                     ; bit 0 into Carry: if Carry is 1 then serial 0 is open and...
 344+ 0225 DC 8F 01                     call    C,A_RTS_OFF     ; ...receiving further chars must be stopped
 345+ 0228 37                           scf                     ; set Carry flag, because  we must inform that the char has been added before to disable RTS
 346+ 0229 C9                           ret
 347+ 022A
 348+ 022A
 349+ 022A              ;-------------------------------------------------------------------------------
 350+ 022A              ; retrieve a char from the input buffer
 351+ 022A 3A FF 53     RXA:            ld      A,(serBufUsed)  ; load the buffer size
 352+ 022D A7                           and     A               ; check if it's 0 (empty)
 353+ 022E CA 2A 02                     jp      Z,RXA           ; if it's empty, wait for a char
 354+ 0231 F3                           di                      ; disable interrupts
 355+ 0232 E5                           push    HL              ; store HL
 356+ 0233 2A FD 53                     ld      HL,(serRdPtr)   ; load pointer to first available char
 357+ 0236 23                           inc     HL              ; increment it (go to the next char)
 358+ 0237 7D                           ld      A,L             ; check if the end of the buffer has been reached
 359+ 0238 FE FB                        cp      bufWrap         ; (only check low byte because buffer<256)
 360+ 023A 20 03                        jr      NZ,NOTRDWRAP    ; if not, jump straight
 361+ 023C 21 A3 53                     ld      HL,SERBUF_START ; else reload the starting address of the buffer
 362+ 023F 22 FD 53     NOTRDWRAP:      ld      (serRdPtr),HL   ; store new pointer to the next char to read
 363+ 0242 3A FF 53                     ld      A,(serBufUsed)  ; load buffer size
 364+ 0245 3D                           dec     A               ; decrement it
 365+ 0246 32 FF 53                     ld      (serBufUsed),A  ; and store the new size
 366+ 0249 FE 05                        cp      SER_EMPTYSIZE   ; check if input buffer can be considered empty
 367+ 024B 30 08                        jr      NC,RXA_EXIT     ; if not empty yet, then exit
 368+ 024D 3A E7 55                     ld      A,(SERIALS_EN)  ; load serial state
 369+ 0250 EE 05                        xor     %00000101       ; check if serial 1 is open and RX enabled
 370+ 0252 CC AD 01                     call    Z,A_RTS_ON      ; yes, set RTS on
 371+ 0255 7E           RXA_EXIT:       ld      A,(HL)          ; recover the char and return it into A
 372+ 0256 E1                           pop     HL              ; retrieve HL
 373+ 0257 FB                           ei                      ; re-enable interrupts
 374+ 0258 C9                           ret                     ; return
 375+ 0259
 376+ 0259              ;------------------------------------------------------------------------------
 377+ 0259              ; sends a char over the serial - char is into A
 378+ 0259 F5           TXA:            push    AF              ; store AF
 379+ 025A C5                           push    BC              ; store BC
 380+ 025B 47                           ld      B,A             ; store char
 381+ 025C 3A E7 55                     ld      A,(SERIALS_EN)  ; load serial status
 382+ 025F EE 05                        xor     %00000101       ; check if serial 1 is open and RX is enabled
 383+ 0261 20 06                        jr      NZ,TXA_EXIT     ; no, jump over
 384+ 0263 78                           ld      A,B             ; retrieve char
 385+ 0264 D3 20                        out     (SIO_DA),A      ; send char to the SIO
 386+ 0266 CD 6C 02                     call    TX_EMP          ; wait for outgoing char to be sent
 387+ 0269 C1           TXA_EXIT:       pop     BC              ; retrieve BC
 388+ 026A F1                           pop     AF              ; retrieve AF
 389+ 026B C9                           ret                     ; return
 390+ 026C
 391+ 026C              ;------------------------------------------------------------------------------
 392+ 026C              ; wait until outgoing serial has been sent
 393+ 026C 97           TX_EMP:         sub     A               ; set A to 0
 394+ 026D 3C                           inc     A               ; set A to 1
 395+ 026E D3 22                        out     (SIO_CA),A      ; write to WR0, select RR1
 396+ 0270 DB 22                        in      A,(SIO_CA)      ; read RR1 register
 397+ 0272 CB 47                        bit     0,A             ; check if all chars have been sent
 398+ 0274 CA 6C 02                     jp      Z,TX_EMP        ; if not (bit 0 = 0) then retrieve
 399+ 0277 C9                           ret                     ; else exit
 400+ 0278
 401+ 0278
 402+ 0278              ;------------------------------------------------------------------------------
 403+ 0278              ; check if there is some chars into the buffer
 404+ 0278 3A FF 53     CKINCHAR:       ld      A,(serBufUsed)  ; load buffer size
 405+ 027B A7                           and     A               ; compare to 0
 406+ 027C C9                           ret                     ; return
 407+ 027D
 408+ 027D              ;------------------------------------------------------------------------------
 409+ 027D              ; print a text from memory, and terminate when $00 is found
 410+ 027D 7E           RAWPRINT:       ld      A,(HL)          ; load character from memory cell pointed by HL
 411+ 027E B7                           or      A               ; is it $00 (end string)?
 412+ 027F C8                           ret     Z               ; Yes, then return
 413+ 0280 32 A2 55                     ld      (CHR4VID),A     ; store char
 414+ 0283 F3                           di
 415+ 0284 CD 61 07                     call    CHAR2VID        ; and send it to screen
 416+ 0287 FB                           ei
 417+ 0288 23                           inc     HL              ; and select the next one
 418+ 0289 18 F2                        jr      RAWPRINT        ; repeat
 419+ 028B
 420+ 028B              ;-------------------------------------------------
 421+ 028B              ; Interrupt service routine (ISR) for CH3 timer
 422+ 028B              ; this is used to increment the 100ths of a second counter and for cursor flashing
 423+ 028B F5           CH3_TIMER:      push    AF              ; save regs. A,
 424+ 028C C5                           push    BC              ; BC,
 425+ 028D D5                           push    DE              ; DE,
 426+ 028E E5                           push    HL              ; HL
 427+ 028F 21 85 55                     ld      HL,TMRCNT       ; load starting address of the timer
 428+ 0292 06 04                        ld      B,$04           ; 4 bytes to check
 429+ 0294 34           INCTMR3:        inc     (HL)            ; increment timer
 430+ 0295 20 03                        jr      NZ,CHKCRSR      ; if not zero then exit (finished increment)
 431+ 0297 23                           inc     HL              ; if yes, there was an overflow, so increment next byte
 432+ 0298 10 FA                        djnz    INCTMR3         ; repeat for 4 bytes
 433+ 029A CD CB 07     CHKCRSR:        call    FLASHCURSOR     ; call the flashing cursor routine
 434+ 029D CD F3 0C                     call    MNGSNDS         ; call the tone managemenet
 435+ 02A0 3A 85 55                     ld      A,(TMRCNT)      ; check for keyboard management
 436+ 02A3 1F                           rra                     ; bit 0 = 1 ?
 437+ 02A4 D4 58 0D                     call    NC,KEYBOARD     ; no, so read the keyboard inputs
 438+ 02A7 E1                           pop     HL              ; retrieve HL,
 439+ 02A8 D1                           pop     DE              ; DE,
 440+ 02A9 C1                           pop     BC              ; BC,
 441+ 02AA F1                           pop     AF              ; and A
 442+ 02AB FB                           ei                      ; re-enable interrupts
 443+ 02AC ED 4D                        reti                    ; exit from ISR
 444+ 02AE
 445+ 02AE              ;------------------------------------------------------------------------------
 446+ 02AE              ;               HARDWARE INITIALISATION
 447+ 02AE              ;------------------------------------------------------------------------------
 448+ 02AE              ; first run - setup HW & SW
 449+ 02AE              ; (on LN80C 64K runs from RAM)
 450+ 02AE 21 32 55     INIT_HW:        ld      HL,TEMPSTACK    ; load temp stack pointer
 451+ 02B1 F9           INIT_HW2:       ld      SP,HL           ; set stack to temp stack pointer
 452+ 02B2 21 A3 53                     ld      HL,SERBUF_START ; set beginning of input buffer
 453+ 02B5 22 FB 53                     ld      (serInPtr),HL   ; for incoming chars to store into buffer
 454+ 02B8 22 FD 53                     ld      (serRdPtr),HL   ; and for chars to be read from buffer
 455+ 02BB AF                           xor     A               ; reset A
 456+ 02BC 32 FF 53                     ld      (serBufUsed),A  ; actual buffer size is 0
 457+ 02BF 32 E7 55                     ld      (SERIALS_EN),A  ; set serial ports status to OFF
 458+ 02C2 CD 40 03                     call    initCTC         ; configure CTC, then...
 459+ 02C5 CD 91 0C                     call    initPSG         ; ...configure PSG
 460+ 02C8 CD F2 04                     call    SHOW_LOGO       ; show computer logo
 461+ 02CB 1E 01                        ld      E,$01           ; E chooses the video mode (graphics 1)
 462+ 02CD CD D1 03                     call    initVDP         ; set video display
 463+ 02D0 AF                           xor     A
 464+ 02D1 ED 47                        ld      I,A             ; set high byte of interrupt vectors to point to page 0
 465+ 02D3 ED 5E                        im      2               ; interrupt mode 2
 466+ 02D5 FB                           ei                      ; enable interrupts
 467+ 02D6                              ; print system messages
 468+ 02D6 AF                           xor     A               ; A=0 so...
 469+ 02D7 32 DF 55                     ld      (KBDNPT),A      ; ...inputs don't come from keyboard
 470+ 02DA 3C                           inc     A               ; A=1...
 471+ 02DB 32 A1 55                     ld      (PRNTVIDEO),A   ; ...to activate the print-on-video
 472+ 02DE 21 76 03                     ld      HL,MSGTXT1      ; sign-on message
 473+ 02E1 CD 7D 02                     call    RAWPRINT        ; print message
 474+ 02E4 3A 00 54                     ld      A,(basicStarted); check if BASIC is already started
 475+ 02E7 FE 59                        cp      'Y'             ; to see if this is a power-up
 476+ 02E9 20 19                        jr      NZ,COLDSTART    ; if not, then do a COLD start
 477+ 02EB 21 B4 03                     ld      HL,MSGTXT2      ; message to choose kind of start
 478+ 02EE CD 7D 02                     call    RAWPRINT        ; print message
 479+ 02F1 CD 2D 09                     call    CURSOR_ON       ; enable cursor
 480+ 02F4 AF                           xor     A
 481+ 02F5 32 A1 55                     ld      (PRNTVIDEO),A   ; disable print-on-video
 482+ 02F8 CD 2A 02     CORW:           call    RXA             ; look for a pressed key
 483+ 02FB E6 DF                        and     %11011111       ; only UPPERCASE char
 484+ 02FD FE 43                        cp      'C'             ; cold start?
 485+ 02FF 20 0E                        jr      NZ,CHECKWARM    ; no, let's check for warm start
 486+ 0301 CD 1C 03                     call    ECHO_CHAR       ; echoes the char
 487+ 0304 3E 59        COLDSTART:      ld      A,'Y'           ; yes, set the "BASIC started" flag
 488+ 0306 32 00 54                     ld      (basicStarted),A
 489+ 0309 CD 42 09                     call    CURSOR_OFF      ; disable cursor
 490+ 030C C3 FA 12                     jp      COLD            ; start BASIC COLD
 491+ 030F FE 57        CHECKWARM:      cp      'W'
 492+ 0311 20 E5                        jr      NZ,CORW         ; char not recognized, wait again
 493+ 0313 CD 1C 03                     call    ECHO_CHAR       ; echoes the char
 494+ 0316 CD 42 09                     call    CURSOR_OFF      ; disable cursor
 495+ 0319 C3 FD 12                     jp      WARM            ; start BASIC WARM
 496+ 031C
 497+ 031C              ;-------------------------------------------------------------------------------
 498+ 031C              ; send back char received through ch. A
 499+ 031C 32 A2 55     ECHO_CHAR:      ld      (CHR4VID),A     ; set char for video printing
 500+ 031F AF                           xor     A
 501+ 0320 32 DF 55                     ld      (KBDNPT),A      ; input is not from keyboard
 502+ 0323 F3                           di                      ; disable INTs
 503+ 0324 CD 61 07                     call    CHAR2VID        ; echoes back the pressed key,
 504+ 0327 3E 0D                        ld      A,CR            ; then set a CR
 505+ 0329 32 A2 55                     ld      (CHR4VID),A     ; set char for video printing
 506+ 032C CD 61 07                     call    CHAR2VID        ; and send it to screen
 507+ 032F FB                           ei                      ; re-enable INTs
 508+ 0330 3E 01                        ld      A,$01
 509+ 0332 32 A1 55                     ld      (PRNTVIDEO),A   ; re-enable video printing
 510+ 0335 C9                           ret                     ; return to caller
 511+ 0336
 512+ 0336
 513+ 0336              ;-------------------------------------------------------------------------------
 514+ 0336              ; Z80 SIO default settings for serial channels
 515+ 0336 30           SIO_A_SETS:     defb    %00110000       ; write into WR0: error reset, select WR0
 516+ 0337 18                           defb    %00011000       ; write into WR0: channel reset
 517+ 0338 04                           defb    %00000100       ; write into WR0: select WR4
 518+ 0339 44                           defb    %01000100       ; write into WR4: presc. 16x, 1 stop bit, no parity
 519+ 033A 05                           defb    %00000101       ; write into WR0: select WR5
 520+ 033B E8                           defb    %11101000       ; write into WR5: DTR on, TX 8 bits, BREAK off, TX on, RTS off
 521+ 033C 01           SIO_B_SETS:     defb    %00000001       ; write into WR0: select WR1
 522+ 033D 04                           defb    %00000100       ; write into WR1: status affects interrupt vectors
 523+ 033E 02                           defb    %00000010       ; write into WR0: select WR2
 524+ 033F 00                           defb    %00000000       ; write into WR2: set interrupt vector, but bits D3/D2/D1 of this vector
 525+ 0340                                                      ; will be affected by the channel & condition that raised the interrupt
 526+ 0340                                                      ; (see datasheet): in our example, 0x0C for Ch.A receiving A char, 0x0E
 527+ 0340                                                      ; for special conditions
 528+ 0340              ;------------------------------------------------------------------------------
 529+ 0340              ;               Z80 CTC SETTING UP
 530+ 0340              ;------------------------------------------------------------------------------
 531+ 0340              initCTC:
 532+ 0340 21 6A 03                     ld      HL,CTCCONF      ; CTC configuration
 533+ 0343 11 89 55                     ld      DE,CTC0IV       ; CTC interrupt vector table
 534+ 0346 01 0C 00                     ld      BC,$000C        ; 12 bytes
 535+ 0349 ED B0                        ldir                    ; copy data
 536+ 034B              ;CH0, CH1, & CH2 disabled
 537+ 034B 3E 03                        ld      A,%00000011     ; interrupt off, timer mode, prescaler=16, don't care ext. TRG edge,
 538+ 034D                                                      ; start timer on loading constant, no time constant follows, software reset, command word
 539+ 034D D3 10                        out     (CTC_CH0),A     ; set CH0
 540+ 034F D3 11                        out     (CTC_CH1),A     ; set CH1
 541+ 0351 D3 12                        out     (CTC_CH2),A     ; set CH2
 542+ 0353              ;init CH3
 543+ 0353              ;CH3 divides CPU CLK by 144*256 providing an interrupt signal at 100 Hz (1/100 sec).
 544+ 0353              ;f = CPU_CLK/(144*256) => 3,686,400 / ( 36,864 ) => 100Hz
 545+ 0353 3E A7                        ld      A,%10100111     ; interrupt on; timer mode; prescaler=256; don't care ext; automatic trigger;
 546+ 0355                                                      ; time constant follows; cont. operation; command word
 547+ 0355 D3 13                        out     (CTC_CH3),A     ; send to CH3
 548+ 0357 3E 90                        ld      A,$90           ; time constant - 90$ (144d)
 549+ 0359 D3 13                        out     (CTC_CH3),A     ; send to CH3
 550+ 035B 3E 40                        ld      A,%01000000     ; D7..D3 provide the first part of the int vector (in our case, $0100), followed by
 551+ 035D                                                      ; D2..D1, provided by the CTC (they point to the channel), D0=interrupt word
 552+ 035D                                                      ; so int vector is 01000xx00
 553+ 035D D3 10                        out     (CTC_CH0),A     ; send to CTC
 554+ 035F                              ; reset cells of 100ths of a second counter
 555+ 035F AF                           xor     A               ; reset A
 556+ 0360 21 85 55                     ld      HL,TMRCNT       ; load TMR pointer
 557+ 0363 06 04                        ld      B,$04           ; 4 memory cells
 558+ 0365 77           RESTMR:         ld      (HL),A          ; reset n-cell of TMR
 559+ 0366 23                           inc     HL              ; next cell
 560+ 0367 10 FC                        djnz    RESTMR          ; repeat for 4 cells
 561+ 0369 C9                           ret
 562+ 036A
 563+ 036A
 564+ 036A              ;------------------------------------------------------------------------------
 565+ 036A              ; jump table for CHx interrupts
 566+ 036A FB ED 4D     CTCCONF:        defb    $FB,$ED,$4D     ; CTC0 interrupt vector (ei; reti)
 567+ 036D FB ED 4D                     defb    $FB,$ED,$4D     ; CTC1 interrupt vector (ei; reti)
 568+ 0370 FB ED 4D                     defb    $FB,$ED,$4D     ; CTC2 interrupt vector (ei; reti)
 569+ 0373 C3 8B 02                     jp      CH3_TIMER       ; CTC3 interrupt vector (jump to execute sys-tick timer)
 570+ 0376
 571+ 0376
 572+ 0376              ;------------------------------------------------------------------------------
 573+ 0376              ; welcome messages
 574+ 0376              MSGTXT1:
 575+ 0376 20 20 20 20                  defm    "    LM80C 64K Color Computer",CR
 575+ 037A 4C 4D 38 30
 575+ 037E 43 20 36 34
 575+ 0382 4B 20 43 6F
 575+ 0386 6C 6F 72 20
 575+ 038A 43 6F 6D 70
 575+ 038E 75 74 65 72
 575+ 0392 0D
 576+ 0393 20 62 79 20                  defm    " by Leonardo Miliani * FW R","1.19",CR,0
 576+ 0397 4C 65 6F 6E
 576+ 039B 61 72 64 6F
 576+ 039F 20 4D 69 6C
 576+ 03A3 69 61 6E 69
 576+ 03A7 20 2A 20 46
 576+ 03AB 57 20 52 31
 576+ 03AF 2E 31 39 0D
 576+ 03B3 00
 577+ 03B4 0D           MSGTXT2:        defb    CR
 578+ 03B5 20 20 20 3C                  defm    "   <C>old or <W>arm start? ",0
 578+ 03B9 43 3E 6F 6C
 578+ 03BD 64 20 6F 72
 578+ 03C1 20 3C 57 3E
 578+ 03C5 61 72 6D 20
 578+ 03C9 73 74 61 72
 578+ 03CD 74 3F 20 00
 579+ 03D1
# file closed: ../include/bootloader/bootloader-1.07.asm
  67  03D1
  68  03D1              ; incude the latest version of the VDP module
  69  03D1                  INCLUDE "../include/vdp/vdp-1.08.asm"
# file opened: ../include/vdp/vdp-1.08.asm
   1+ 03D1              ; ------------------------------------------------------------------------------
   2+ 03D1              ; LM80C - VDP ROUTINES - 1.08
   3+ 03D1              ; ------------------------------------------------------------------------------
   4+ 03D1              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 03D1              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 03D1              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 03D1              ; kind of warranty: you can use them at your own risk.
   8+ 03D1              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 03D1              ; maintain the copyright notices, include this advice and the note to the
  10+ 03D1              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 03D1              ; redistribuite them.
  12+ 03D1              ; https://www.leonardomiliani.com
  13+ 03D1              ;
  14+ 03D1              ; Please support me by visiting the following links:
  15+ 03D1              ; Main project page: https://www.leonardomiliani.com
  16+ 03D1              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 03D1              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 03D1              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 03D1              ; ------------------------------------------------------------------------------
  20+ 03D1              ;
  21+ 03D1              ;------------------------------------------------------------------------------
  22+ 03D1              ; VDP INITIALISATION
  23+ 03D1              ; initialize VDP for a specific graphics mode
  24+ 03D1              ; INPUT: E -> contains the graphics mode:
  25+ 03D1              ; 0=text; 1=graphics 1; 2=graphics 2; 3=multicolor; 4=extended graphics 2
  26+ 03D1 D5           initVDP:        push    DE              ; store E
  27+ 03D2 CD CF 0A                     call    EMPTY_VRAM      ; reset VRAM
  28+ 03D5 CD ED 0A                     call    SET_GFX_MODE    ; load register settings
  29+ 03D8 CD E2 0A                     call    CLR_RAM_REG     ; reset RAM registers
  30+ 03DB D1                           pop     DE              ; restore reg. E
  31+ 03DC AF                           xor     A               ; reset A
  32+ 03DD 47                           ld      B,A             ; reset B (will be used later)
  33+ 03DE 7B                           ld      A,E             ; move E into A
  34+ 03DF 32 97 55                     ld      (SCR_MODE),A    ; store screen mode
  35+ 03E2 FE 01                        cp      $01             ; is it graphics 1 (A=1)?
  36+ 03E4 CA 20 04                     jp      Z,G1MD          ; yes, jump over
  37+ 03E7 FE 02                        cp      $02             ; is it graphics 2 (A=2)?
  38+ 03E9 CA 60 04                     jp      Z,G2MD          ; yes, jump over
  39+ 03EC FE 03                        cp      $03             ; is it multicolor (A=3)?
  40+ 03EE CA 82 04                     jp      Z,MCMD          ; yes, jump over
  41+ 03F1 FE 04                        cp      $04             ; is it extended graphics 2 (A=4)?
  42+ 03F3 CA A5 04                     jp      Z,EXG2MD        ; yes, jump over
  43+ 03F6                              ; otherwise, it must be $00 so we assume that it's text mode
  44+ 03F6
  45+ 03F6              ; LOAD VDP SETTINGS FOR SELECTED VIDEO MODE:
  46+ 03F6
  47+ 03F6                              ; TEXT MODE (G0)
  48+ 03F6                              ; load charset
  49+ 03F6 60           TXTMD:          ld      H,B
  50+ 03F7 68                           ld      L,B             ; HL=first pattern cell $0000
  51+ 03F8 CD 09 0B                     call    LOADCHARSET     ; load patterns into VRAM
  52+ 03FB                              ; set cursor & video overlay
  53+ 03FB AF                           xor     A               ; reset A
  54+ 03FC 32 9A 55                     ld      (SCR_CURS_X),A  ; set cursor position at X=0
  55+ 03FF 32 9B 55                     ld      (SCR_CURS_Y),A  ; and Y=0
  56+ 0402 3E 05                        ld      A,$05           ; light blue
  57+ 0404 32 A4 55                     ld      (BKGNDCLR),A    ; set background/border color
  58+ 0407 3E 28                        ld      A,$28
  59+ 0409 32 95 55                     ld      (SCR_SIZE_W),A  ; screen width = 40 cols
  60+ 040C 3E 18                        ld      A,$18
  61+ 040E 32 96 55                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  62+ 0411 3E 1E                        ld      A,$1E
  63+ 0413 32 46 54                     ld      (COMMAN),A      ; width for commas (4 columns)
  64+ 0416 11 00 08                     ld      DE,$0800
  65+ 0419 ED 53 98 55                  ld      (SCR_NAM_TB),DE ; set name table address
  66+ 041D C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
  67+ 0420
  68+ 0420                              ; GRAPHICS 1 MODE (G1)
  69+ 0420                              ; load pattern table
  70+ 0420 68           G1MD:           ld      L,B
  71+ 0421 60                           ld      H,B             ; HL=first pattern cell $0000
  72+ 0422 CD 09 0B                     call    LOADCHARSET     ; load patterns into VRAM
  73+ 0425                              ; set cursor & video overlay
  74+ 0425 AF                           xor     A               ; position cursor
  75+ 0426 32 9A 55                     ld      (SCR_CURS_X),A  ; at X=0
  76+ 0429 32 9B 55                     ld      (SCR_CURS_Y),A  ; and Y=0
  77+ 042C 3E 20                        ld      A,$20
  78+ 042E 32 95 55                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
  79+ 0431 3E 18                        ld      A,$18
  80+ 0433 32 96 55                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  81+ 0436 3E 14                        ld      A,$14
  82+ 0438 32 46 54                     ld      (COMMAN),A      ; width for commas (3 columns)
  83+ 043B 11 00 18                     ld      DE,$1800
  84+ 043E ED 53 98 55                  ld      (SCR_NAM_TB),DE ; set name table address
  85+ 0442                              ; load color table
  86+ 0442 21 00 20                     ld      HL,$2000        ; color table start: $2000
  87+ 0445 CD 70 06                     call    SETVDPADRS
  88+ 0448 3E 01                        ld      A,$01           ; foreground color...
  89+ 044A 32 A3 55                     ld      (FRGNDCLR),A    ; ...set to black
  90+ 044D 3E 0F                        ld      A,$0F           ; background color...
  91+ 044F 32 A4 55                     ld      (BKGNDCLR),A    ; ...set to white
  92+ 0452 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
  93+ 0454 06 20                        ld      B,$20           ; 32 bytes of colors
  94+ 0456 0D                           dec     C               ; VDP data mode
  95+ 0457 ED 79        LDCLRTBMD1:     out     (C),A           ; after the first byte, the VDP autoincrements VRAM pointer
  96+ 0459 00                           nop
  97+ 045A 00                           nop
  98+ 045B 10 FA                        djnz    LDCLRTBMD1      ; repeat for 32 bytes
  99+ 045D C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 100+ 0460
 101+ 0460                              ; GRAPHICS 2 MODE (G2)
 102+ 0460 AF           G2MD:           xor     A               ; position cursor
 103+ 0461 32 9A 55                     ld      (SCR_CURS_X),A  ; at X=0
 104+ 0464 32 9B 55                     ld      (SCR_CURS_Y),A  ; and Y=0
 105+ 0467 32 95 55                     ld      (SCR_SIZE_W),A  ; screen width = 256 pixels (0=256)
 106+ 046A 3C                           inc     A               ; black on...
 107+ 046B 32 A3 55                     ld      (FRGNDCLR),A    ; ...foreground
 108+ 046E 3E 0F                        ld      A,$0F           ; white on...
 109+ 0470 32 A4 55                     ld      (BKGNDCLR),A    ; ...background
 110+ 0473 3E C0                        ld      A,$C0
 111+ 0475 32 96 55                     ld      (SCR_SIZE_H),A  ; screen height = 192 pixels
 112+ 0478 11 00 18                     ld      DE,$1800
 113+ 047B ED 53 98 55                  ld      (SCR_NAM_TB),DE ; set name table address
 114+ 047F C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 115+ 0482
 116+ 0482                              ; MULTICOLOR MODE (G3)
 117+ 0482 AF           MCMD:           xor     A               ; position cursor
 118+ 0483 32 9A 55                     ld      (SCR_CURS_X),A  ; at X=0
 119+ 0486 32 9B 55                     ld      (SCR_CURS_Y),A  ; and Y=0
 120+ 0489 3E 0F                        ld      A,$0F           ; white color for...
 121+ 048B 32 A4 55                     ld      (BKGNDCLR),A    ; ...background and...
 122+ 048E 32 A3 55                     ld      (FRGNDCLR),A    ; ...foreground (even this is not used in MC)
 123+ 0491 3E 40                        ld      A,$40
 124+ 0493 32 95 55                     ld      (SCR_SIZE_W),A  ; screen width = 64 blocks
 125+ 0496 3E 30                        ld      A,$30
 126+ 0498 32 96 55                     ld      (SCR_SIZE_H),A  ; screen height = 48 blocks
 127+ 049B 11 00 08                     ld      DE,$0800
 128+ 049E ED 53 98 55                  ld      (SCR_NAM_TB),DE ; set name table address
 129+ 04A2 C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 130+ 04A5
 131+ 04A5                              ; EXTENDED GRAPHICS 2 (G4)
 132+ 04A5              EXG2MD:         ; load pattern table
 133+ 04A5 60                           ld      H,B
 134+ 04A6 68                           ld      L,B             ; HL=first pattern cell $0000
 135+ 04A7 CD 09 0B                     call    LOADCHARSET     ; load patterns into VRAM
 136+ 04AA                              ; set cursor & video overlay
 137+ 04AA AF                           xor     A               ; position cursor
 138+ 04AB 32 9A 55                     ld      (SCR_CURS_X),A  ; at X=0
 139+ 04AE 32 9B 55                     ld      (SCR_CURS_Y),A  ; and Y=0
 140+ 04B1 3E 20                        ld      A,$20
 141+ 04B3 32 95 55                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
 142+ 04B6 3E 18                        ld      A,$18
 143+ 04B8 32 96 55                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
 144+ 04BB 3E 14                        ld      A,$14
 145+ 04BD 32 46 54                     ld      (COMMAN),A      ; width for commas (3 columns)
 146+ 04C0 11 00 38                     ld      DE,$3800
 147+ 04C3 ED 53 98 55                  ld      (SCR_NAM_TB),DE ; set name table address
 148+ 04C7                               ; load color table
 149+ 04C7 21 00 20                     ld      HL,$2000        ; color table start: $2000
 150+ 04CA CD 70 06                     call    SETVDPADRS
 151+ 04CD 3E 01                        ld      A,$01           ; foreground color is...
 152+ 04CF 32 A3 55                     ld      (FRGNDCLR),A    ; ...set to black
 153+ 04D2 3E 0F                        ld      A,$0F           ; whitefor...
 154+ 04D4 32 A4 55                     ld      (BKGNDCLR),A    ; ...background
 155+ 04D7 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
 156+ 04D9 16 08                        ld      D,$08           ; 8 pages of
 157+ 04DB 06 00                        ld      B,$00           ; 256 bytes of colors (total of 2,048 cells)
 158+ 04DD 0D                           dec     C               ; VDP data mode
 159+ 04DE ED 79        LDCLRTBEX2:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
 160+ 04E0 00                           nop
 161+ 04E1 00                           nop
 162+ 04E2 10 FA                        djnz    LDCLRTBEX2      ; repeat for 256 bytes
 163+ 04E4 15                           dec     D               ; did we fill up all the cells?
 164+ 04E5 20 F7                        jr      NZ,LDCLRTBEX2   ; no, repeat
 165+ 04E7                              ; LAST VDP SETTINGS
 166+ 04E7 CD 42 09     ENDVDPSET:      call    CURSOR_OFF      ; disable cursor
 167+ 04EA CD E2 05                     call    EMPTYVIDBUF     ; empty video buffer
 168+ 04ED AF                           xor     A
 169+ 04EE 32 9E 55                     ld      (SCR_ORG_CHR),A ; store byte used tochar used to empty the video buffer
 170+ 04F1 C9                           ret                     ; return to caller
 171+ 04F2
 172+ 04F2
 173+ 04F2              ; show initial logo
 174+ 04F2 CD CF 0A     SHOW_LOGO:      call    EMPTY_VRAM      ; reset VRAM
 175+ 04F5                              ; set VDP for G2 mode
 176+ 04F5 06 07                        ld      B,$07           ; set only the first 7 registers
 177+ 04F7 11 10 00                     ld      DE,$0010        ; load settings for G2 mode
 178+ 04FA CD F5 0A                     call    SET_GFX_MODE2   ; load register settings
 179+ 04FD 16 01                        ld      D,$01           ; backdrop color set to black
 180+ 04FF ED 51                        out     (C),D           ; send data to VDP
 181+ 0501 ED 79                        out     (C),A           ; indicate the register to send data to
 182+ 0503                              ; set name table
 183+ 0503 21 00 18                     ld      HL,$1800        ; name table address
 184+ 0506 CD 5E 06                     call    SETNAMETABLE    ; set name table (load names into table)
 185+ 0509 CD 73 05                     call    ERASECLRTBL     ; erase color table (set foreground & background to black)
 186+ 050C                              ; set colors for logo
 187+ 050C 21 00 28                     ld      HL,$2800        ; 2nd page of color table
 188+ 050F CD 70 06                     call    SETVDPADRS
 189+ 0512 06 05                        ld      B,$05           ; 5 bands
 190+ 0514 21 BE 05                     ld      HL,CLRTABLE
 191+ 0517 0D                           dec     C               ; set VDP_DAT
 192+ 0518 1E 08                        ld      E,$08           ; 8 pixels each pattern
 193+ 051A 16 40        RPT101:         ld      D,$40           ; 64 chars each band
 194+ 051C 7E                           ld      A,(HL)          ; load data
 195+ 051D ED 79        RPT102:         out     (C),A           ; send it to VRAM
 196+ 051F 00                           nop                     ; little delay
 197+ 0520 1D                           dec     E               ; decrement counter
 198+ 0521 20 FA                        jr      NZ,RPT102       ; repeat until zero
 199+ 0523 1E 08                        ld      E,$08           ; 8 pixels each pattern
 200+ 0525 15                           dec     D               ; decrement char band counter
 201+ 0526 20 F5                        jr      NZ,RPT102       ; repeat until zero
 202+ 0528 23                           inc     HL              ; next pattern
 203+ 0529 10 EF                        djnz    RPT101          ; repeat until covered every band
 204+ 052B                              ; set pattern table
 205+ 052B 21 00 08                     ld      HL,$0800        ; address of first cell of 2nd area of pattern table
 206+ 052E 11 51 0B                     ld      DE,LM80CLOGO    ; pointer to logo pattern
 207+ 0531 45                           ld      B,L             ; 256 bytes, 8 rows
 208+ 0532 CD 9E 05     RPT103:         call    LOADLOGOCHRS
 209+ 0535 13                           inc     DE              ; next logo pattern
 210+ 0536 10 FA                        djnz    RPT103
 211+ 0538 06 20                        ld      B,$20           ; repeat for another 2 rows
 212+ 053A CD 9E 05     RPT104:         call    LOADLOGOCHRS
 213+ 053D 13                           inc     DE              ; next logo pattern
 214+ 053E 10 FA                        djnz    RPT104
 215+ 0540                              ; show logo/message, play a beep, check for CTRL pressing (to disable DOS), and wait a while
 216+ 0540 06 02                        ld      B,$02           ; two times
 217+ 0542 AF                           xor     A               ; reset A
 218+ 0543 57                           ld      D,A             ; 256 times
 219+ 0544 5F                           ld      E,A             ; x 256 times
 220+ 0545 32 A5 55                     ld      (TMPBFR1),A     ; sound flag set to 0
 221+ 0548 3A 00 54                     ld      A,(basicStarted)
 222+ 054B FE 59                        cp      'Y'
 223+ 054D 28 05                        jr      Z,DEC_D
 224+ 054F 3E 01                        ld      A,$01           ; by default, I/O DOS buffer is enabled
 225+ 0551 32 EA 55                     ld      (DOS_EN),A      ; DOS enabled
 226+ 0554 00           DEC_D:          nop                     ; does nothing...
 227+ 0555 00                           nop
 228+ 0556 00                           nop
 229+ 0557 00                           nop
 230+ 0558 00                           nop
 231+ 0559 00                           nop                     ; ...until here
 232+ 055A 1D                           dec     E               ; decrement E
 233+ 055B 20 F7                        jr      NZ,DEC_D        ; repeat until $00
 234+ 055D 7A                           ld      A,D
 235+ 055E FE 40                        cp      $40             ; ...equal to 64
 236+ 0560 CC 8A 05                     call    Z,SETBEEP       ; if yes, start sound
 237+ 0563 15                           dec     D
 238+ 0564 20 EE                        jr      NZ,DEC_D        ; repeat
 239+ 0566 3A A5 55                     ld      A,(TMPBFR1)     ; sound state
 240+ 0569 FE 02                        cp      $02             ; check if sound is to be set off
 241+ 056B C4 96 05                     call    NZ,BEEPOFF      ; yes
 242+ 056E CD C3 05                     call    CHKSPCK         ; check if special key (CTRL) has been pressed on keyboard
 243+ 0571                                                      ; on LM80C 64K, you can disabled the I/O DOS buffer
 244+ 0571 10 E1                        djnz    DEC_D           ; repeat
 245+ 0573              ERASECLRTBL:    ; erase color table
 246+ 0573 3E 11                        ld      A,$11           ; foreground and background set to black
 247+ 0575 16 0A                        ld      D,$0A           ; 10 pages
 248+ 0577 06 00                        ld      B,$00           ; 256 color cells per page
 249+ 0579 21 00 28                     ld      HL,$2800        ; first cell of 2nd color table
 250+ 057C CD 70 06                     call    SETVDPADRS      ; send address
 251+ 057F 0D                           dec     C               ; VDP address for passing data
 252+ 0580 ED 79        RPT100:         out     (C),A           ; send data
 253+ 0582 00                           nop
 254+ 0583 00                           nop                     ; little delay
 255+ 0584 10 FA                        djnz    RPT100          ; repeat for entire page
 256+ 0586 15                           dec     D
 257+ 0587 20 F7                        jr      NZ,RPT100       ; repeat for all the pages ($0A00 cells)
 258+ 0589 C9                           ret                     ; return to caller
 259+ 058A
 260+ 058A              ; play a beep
 261+ 058A 3A A5 55     SETBEEP:        ld      A,(TMPBFR1)     ; check the already-beeped flag
 262+ 058D B7                           or      A               ; is it 0?
 263+ 058E C0                           ret     NZ              ; no, exit
 264+ 058F 3C                           inc     A               ; flag to 1
 265+ 0590 32 A5 55                     ld      (TMPBFR1),A     ; set sound
 266+ 0593 C3 BF 0C                     jp      WLCMBEEP        ; play a beep & return
 267+ 0596
 268+ 0596              ; beep off
 269+ 0596 3E 02        BEEPOFF:        ld      A,$02           ; flag for sound off
 270+ 0598 32 A5 55                     ld      (TMPBFR1),A     ; set flag
 271+ 059B C3 C5 0C                     jp      NOBEEP          ; stop beep and return
 272+ 059E
 273+ 059E
 274+ 059E              ; used to load the chars that will compose the logo of the splash screen
 275+ 059E 1A           LOADLOGOCHRS:   ld      A,(DE)          ; load a pattern char of the logo
 276+ 059F 87                           add     A,A
 277+ 05A0 87                           add     A,A
 278+ 05A1 87                           add     A,A             ; multiply times 8 to get the offset
 279+ 05A2 C5                           push    BC
 280+ 05A3 D5                           push    DE              ; store BC and DE
 281+ 05A4 E5                           push    HL              ; store VRAM address to write to
 282+ 05A5 21 97 52                     ld      HL,LOGOFONT     ; start of logo font data
 283+ 05A8 5F                           ld      E,A
 284+ 05A9 16 00                        ld      D,$00           ; put offset (A) into DE
 285+ 05AB 19                           add     HL,DE           ; get address of pattern data
 286+ 05AC EB                           ex      DE,HL           ; move address into DE
 287+ 05AD E1                           pop     HL              ; retrieve VRAM address
 288+ 05AE 06 08                        ld      B,$08           ; 8 bytes per pattern
 289+ 05B0 CD 70 06                     call    SETVDPADRS      ; set VDP address
 290+ 05B3 0D                           dec     C               ; VDP_DAT
 291+ 05B4 1A           SNDLOGPT:       ld      A,(DE)          ; load data from RAM
 292+ 05B5 ED 79                        out     (C),A           ; and send to VRAM
 293+ 05B7 13                           inc     DE              ; next byte into RAM
 294+ 05B8 23                           inc     HL              ; next byte into VRAM (used in future iterations)
 295+ 05B9 10 F9                        djnz    SNDLOGPT        ; repeat 8 times
 296+ 05BB D1                           pop     DE
 297+ 05BC C1                           pop     BC              ; retrieve BC & DE
 298+ 05BD C9                           ret                     ; return to caller
 299+ 05BE              CLRTABLE:       equ $
 300+ 05BE 18 1B 13 14                  defb    $18,$1B,$13,$14,$1D ; colors of background bands of the logo
 300+ 05C2 1D
 301+ 05C3
 302+ 05C3
 303+ 05C3              ; while showing the logo, check if special key (CTRL) is being pressed
 304+ 05C3              ; if yes, then disable DOS functions recovering RAM
 305+ 05C3 F5           CHKSPCK:        push    AF
 306+ 05C4 3E FE                        ld      A,%11111110     ; select CTRL row
 307+ 05C6 CD 43 0D                     call    READKBLN        ; read row
 308+ 05C9 CB 5F                        bit     3,A             ; test for RUN/STOP
 309+ 05CB CA DB 05                     jp      Z,DOCOLDRESET   ; yes, do a cold reset
 310+ 05CE CB 57                        bit     2,A             ; test if CTRL key is pressed
 311+ 05D0 20 07                        jr      NZ,LVCKSPLK     ; no, leave
 312+ 05D2 AF                           xor     A               ; yes, so...
 313+ 05D3 32 EA 55                     ld      (DOS_EN),A      ; ...disable DOS
 314+ 05D6 32 00 54                     ld      (basicStarted),A; reset BASIC warm start
 315+ 05D9 F1           LVCKSPLK:       pop     AF
 316+ 05DA C9                           ret
 317+ 05DB AF           DOCOLDRESET:    xor     A               ; reset A
 318+ 05DC 32 00 54                     ld      (basicStarted),A; reset BASIC warm start
 319+ 05DF C3 00 00                     jp      $0000           ; restart
 320+ 05E2
 321+ 05E2
 322+ 05E2              ; empty video buffer
 323+ 05E2 3A 97 55     EMPTYVIDBUF:    ld      A,(SCR_MODE)    ; check screen mode
 324+ 05E5 FE 02                        cp      $02             ; is it G2 mode?
 325+ 05E7 CA 0A 06                     jp      Z,EMPTYG2       ; yes, jump over
 326+ 05EA FE 03                        cp      $03             ; is it MC mode?
 327+ 05EC CA 3A 06                     jp      Z,EMPTYMC       ; yes, jump over
 328+ 05EF 3A 96 55                     ld      A,(SCR_SIZE_H)  ; load height of screen
 329+ 05F2 47                           ld      B,A             ; move rows into B
 330+ 05F3 AF                           xor     A               ; filling char is $00
 331+ 05F4 2A 98 55                     ld      HL,(SCR_NAM_TB) ; load the name table address
 332+ 05F7 CD 70 06                     call    SETVDPADRS      ; send address to VDP
 333+ 05FA 0D                           dec     C               ; VDP address for passing data
 334+ 05FB 5F           LDCOLSTOEMPTY:  ld      E,A             ; store filling char into E
 335+ 05FC 3A 95 55                     ld      A,(SCR_SIZE_W)  ; load # of cols to empty into A
 336+ 05FF 57                           ld      D,A             ; move A into D
 337+ 0600 7B                           ld      A,E             ; recover filling char
 338+ 0601 ED 79        RPTEMPTYBUF:    out     (C),A           ; write empty byte into VRAM
 339+ 0603 00                           nop
 340+ 0604 15                           dec     D               ; decr. D
 341+ 0605 20 FA                        jr      NZ,RPTEMPTYBUF  ; repeat for the # of cols
 342+ 0607 10 F2                        djnz    LDCOLSTOEMPTY   ; repeat for the # of rows
 343+ 0609 C9                           ret                     ; return to caller
 344+ 060A 2A 98 55     EMPTYG2:        ld      HL,(SCR_NAM_TB) ; yes, additional setup for G2 - load G2 name table address (usually $1800)
 345+ 060D CD 5E 06                     call    SETNAMETABLE    ; set name table
 346+ 0610 21 00 00                     ld      HL,$0000        ; set pattern table
 347+ 0613 CD 70 06                     call    SETVDPADRS      ; send address to VDP
 348+ 0616 AF                           xor     A               ; empty pattern
 349+ 0617 16 18                        ld      D,$18           ; 6144 ($1800) cell to clean, 24 pages ($18)
 350+ 0619 47                           ld      B,A             ; 256 bytes for page
 351+ 061A 0D                           dec     C               ; VDP data mode
 352+ 061B ED 79        CLRG2PTNTBL:    out     (C),A           ; clear pattern
 353+ 061D 00                           nop                     ; little delay
 354+ 061E 00                           nop
 355+ 061F 10 FA                        djnz    CLRG2PTNTBL     ; repeat for 1 page
 356+ 0621 15                           dec     D               ; next page
 357+ 0622 20 F7                        jr      NZ,CLRG2PTNTBL  ; repeat
 358+ 0624 21 00 20                     ld      HL,$2000        ; load the color table address
 359+ 0627 CD 70 06                     call    SETVDPADRS      ; send address to VDP
 360+ 062A 3A A3 55                     ld      A,(FRGNDCLR)    ; load foreground
 361+ 062D 87                           add     A,A
 362+ 062E 87                           add     A,A
 363+ 062F 87                           add     A,A
 364+ 0630 87                           add     A,A             ; move to high nibble
 365+ 0631 57                           ld      D,A             ; store into D
 366+ 0632 3A A4 55                     ld      A,(BKGNDCLR)    ; load background color
 367+ 0635 B2                           or      D               ; combine with background color
 368+ 0636 16 18                        ld      D,$18           ; 6144 ($1800) cells to fill, so 24 pages ($18)
 369+ 0638 18 17                        jr      STARTEMPTY
 370+ 063A 21 00 08     EMPTYMC:        ld      HL,$0800        ; MC name table
 371+ 063D CD 5E 06                     call    SETNAMETABLE    ; set name table
 372+ 0640 21 00 00                     ld      HL,$0000        ; color table address
 373+ 0643 CD 70 06                     call    SETVDPADRS      ; send address to VDP
 374+ 0646 3A A4 55                     ld      A,(BKGNDCLR)    ; load background
 375+ 0649 57                           ld      D,A             ; store into D
 376+ 064A 87                           add     A,A
 377+ 064B 87                           add     A,A
 378+ 064C 87                           add     A,A
 379+ 064D 87                           add     A,A             ; move to high nibble
 380+ 064E B2                           or      D               ; set background color for high and low nibble
 381+ 064F 16 08                        ld      D,$08           ; 2048 ($0800) cells to fill, so 8 pages ($08)
 382+ 0651 0D           STARTEMPTY:     dec     C               ; VDP address for passing data
 383+ 0652 06 00                        ld      B,$00           ; 256 bytes each page ($00=256)
 384+ 0654 ED 79        SNDCLRSET:      out     (C),A           ; send color setting
 385+ 0656 00                           nop                     ; wait a while
 386+ 0657 00                           nop
 387+ 0658 10 FA                        djnz    SNDCLRSET       ; repeat for 1 page
 388+ 065A 15                           dec     D               ; have we filled all the pages?
 389+ 065B 20 F7                        jr      NZ,SNDCLRSET    ; no, repeat
 390+ 065D C9                           ret                     ; return to caller
 391+ 065E
 392+ 065E              ; set name table for G2 mode (patterns from $00 to $FF for each of the 3 areas of the screen)
 393+ 065E CD 70 06     SETNAMETABLE:   call    SETVDPADRS      ; send address to VDP
 394+ 0661 0D                           dec     C               ; VDP address for passing data
 395+ 0662 16 03                        ld      D,$03           ; 3 pages to fill into VRAM (768 cells)
 396+ 0664 AF                           xor     A               ; starting char name #0 (chars go from 0 to 255)
 397+ 0665 47                           ld      B,A             ; reset B
 398+ 0666 ED 79        RPTFLL1:        out     (C),A           ; send name to VRAM
 399+ 0668 00                           nop
 400+ 0669 3C                           inc     A               ; increment # of name
 401+ 066A 10 FA                        djnz    RPTFLL1         ; repeat for 256 cells (1 page)
 402+ 066C 15                           dec     D               ; did we fill all the pages?
 403+ 066D 20 F7                        jr      NZ,RPTFLL1      ; no, continue
 404+ 066F C9                           ret                     ; return to caller
 405+ 0670
 406+ 0670              ; set an address into VRAM: address is in HL - HL is changed after it
 407+ 0670 0E 31        SETVDPADRS:     ld      C,VDP_SET       ; VDP address mode
 408+ 0672 CB F4                        set     6,H             ; set bit #6 of address, to write to VRAM
 409+ 0674 ED 69                        out     (C),L           ; send low and...
 410+ 0676 ED 61                        out     (C),H           ; ...high byte of the first cell
 411+ 0678 C9                           ret                     ; return to caller
 412+ 0679
 413+ 0679              ; clear the video buffer and position the cursor at 0,0
 414+ 0679 CD E2 05     CLEARVIDBUF:    call    EMPTYVIDBUF     ; clear video buffer
 415+ 067C AF                           xor     A               ; reset A
 416+ 067D 32 9A 55                     ld      (SCR_CURS_X),A  ; cursor X to 0
 417+ 0680 32 9B 55                     ld      (SCR_CURS_Y),A  ; cursor Y to 0
 418+ 0683 C3 CC 06                     jp      POS_CURSOR      ; position cursor & return to caller
 419+ 0686
 420+ 0686              ; HOME: position the cursor at coords. 0,0
 421+ 0686 AF           ATHOME:         xor     A               ; position cursor at 0,0 by storing...
 422+ 0687 32 9D 55                     ld      (SCR_CUR_NY),A  ; ...new Y...
 423+ 068A 32 9C 55                     ld      (SCR_CUR_NX),A  ; ...and new X
 424+ 068D C3 D6 06                     jp      MOVCRS          ; move cursor to new location & return to caller
 425+ 0690
 426+ 0690              ; load the char or byte at the VRAM position set by HL
 427+ 0690              ; value is returned into A
 428+ 0690 C5           READ_VIDEO_LOC: push    BC              ; store BC
 429+ 0691 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 430+ 0693 44                           ld      B,H
 431+ 0694 CB B8                        res     7,B
 432+ 0696 CB B0                        res     6,B
 433+ 0698 ED 69                        out     (C),L           ; low byte then...
 434+ 069A ED 41                        out     (C),B           ; high byte
 435+ 069C 0D                           dec     C               ; VDP data mode
 436+ 069D 00                           nop                     ; added to compensate shorter instruction
 437+ 069E 00                           nop                     ; wait...
 438+ 069F 00                           nop                     ; ...a while
 439+ 06A0 00                           nop
 440+ 06A1 ED 78                        in      A,(C)           ; read byte at current VRAM location
 441+ 06A3 C1                           pop     BC              ; restore BC
 442+ 06A4 C9                           ret                     ; return to caller
 443+ 06A5
 444+ 06A5              ; write a byte at the VRAM position pointed by HL
 445+ 06A5              ; value is in A
 446+ 06A5 C5           WRITE_VIDEO_LOC:push    BC              ; store BC
 447+ 06A6 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 448+ 06A8 44                           ld      B,H             ; copy H into B
 449+ 06A9 CB B8                        res     7,B
 450+ 06AB CB F0                        set     6,B             ; write to VRAM
 451+ 06AD ED 69                        out     (C),L           ; low byte then...
 452+ 06AF ED 41                        out     (C),B           ; high byte of VRAM address
 453+ 06B1 0D                           dec     C               ; VDP data mode
 454+ 06B2 00                           nop                     ; added to compensate shorter instruction
 455+ 06B3 00                           nop                     ; wait...
 456+ 06B4 00                           nop                     ; ...a while
 457+ 06B5 00                           nop
 458+ 06B6 ED 79                        out     (C),A           ; write byte into VRAM
 459+ 06B8 C1                           pop     BC              ; restore BC
 460+ 06B9 C9                           ret                     ; return to caller
 461+ 06BA
 462+ 06BA              ; write a value into a specific VDP register
 463+ 06BA              ; value is in E, register is in A
 464+ 06BA C5           WRITE_VREG:     push    BC              ; store BC
 465+ 06BB C6 80                        add     A,$80           ; set VDP to write to registers
 466+ 06BD 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 467+ 06BF ED 59                        out     (C),E           ; send data to VDP
 468+ 06C1 ED 79                        out     (C),A           ; select the destination register
 469+ 06C3 C1                           pop     BC              ; restore BC
 470+ 06C4 C9                           ret                     ; return to caller
 471+ 06C5
 472+ 06C5              ; read VDP status register and return value into A
 473+ 06C5 C5           READ_VSTAT:     push    BC              ; store BC
 474+ 06C6 0E 31                        ld      C,VDP_SET       ; VDP register access
 475+ 06C8 ED 78                        in      A,(C)           ; read status register
 476+ 06CA C1                           pop     BC              ; restore BC
 477+ 06CB C9                           ret                     ; return to caller
 478+ 06CC
 479+ 06CC              ; position the cursor at the current coordinates, preserving underlying char
 480+ 06CC CD 0F 07     POS_CURSOR:     call    LOAD_CRSR_POS   ; load the VRAM address of cursor into HL
 481+ 06CF CD 90 06                     call    READ_VIDEO_LOC  ; load the current char at the cursor position (return in A)
 482+ 06D2 32 9E 55                     ld      (SCR_ORG_CHR),A ; store the current char
 483+ 06D5 C9                           ret
 484+ 06D6
 485+ 06D6              ; move cursor to new X,Y coordinates
 486+ 06D6 CD 06 07     MOVCRS:         call    RSTCHRCRS       ; restore the char in the current cursor position
 487+ 06D9 CD F1 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 488+ 06DC CD CC 06     MOVSHOWCRS:     call    POS_CURSOR      ; position cursor into new location
 489+ 06DF 3A 9F 55                     ld      A,(CRSR_STATE)  ; load status of cursor
 490+ 06E2 A7                           and     A               ; is cursor off?
 491+ 06E3 C8                           ret     Z               ; yes, return
 492+ 06E4 3A 85 55                     ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
 493+ 06E7 F6 20                        or      $20             ; ...set cursor on
 494+ 06E9 32 A0 55                     ld      (LSTCSRSTA),A   ; store the last cursor state
 495+ 06EC 3E FF                        ld      A,$FF           ; BTW, set cursor visible after moved it
 496+ 06EE C3 A5 06                     jp      WRITE_VIDEO_LOC ; write into video cell
 497+ 06F1
 498+ 06F1
 499+ 06F1              ; set new cursor's coordinates
 500+ 06F1 3A 9C 55     NEWCRSRCOORD:   ld      A,(SCR_CUR_NX)  ; load new X
 501+ 06F4 32 9A 55                     ld      (SCR_CURS_X),A  ; write new X
 502+ 06F7 3A 9D 55                     ld      A,(SCR_CUR_NY)  ; load new Y
 503+ 06FA 32 9B 55                     ld      (SCR_CURS_Y),A  ; write new Y
 504+ 06FD 3E FF                        ld      A,$FF           ; delete new values
 505+ 06FF 32 9C 55                     ld      (SCR_CUR_NX),A  ; of X
 506+ 0702 32 9D 55                     ld      (SCR_CUR_NY),A  ; and Y
 507+ 0705 C9                           ret
 508+ 0706
 509+ 0706              ; recover char under the cursor and prints it onto the screen
 510+ 0706 CD 0F 07     RSTCHRCRS:      call    LOAD_CRSR_POS   ; recover old cursor position
 511+ 0709 3A 9E 55                     ld      A,(SCR_ORG_CHR) ; recover old char
 512+ 070C C3 A5 06                     jp      WRITE_VIDEO_LOC ; write char into VRAM & return
 513+ 070F
 514+ 070F              ; retrieve cursor position from either current coordinates or next place
 515+ 070F              ; return address position into HL
 516+ 070F 3A 9B 55     LOAD_CRSR_POS:  ld      A,(SCR_CURS_Y)  ; load cursor Y
 517+ 0712 6F                           ld      L,A             ; move it into reg.L
 518+ 0713 AF                           xor     A               ; reset A
 519+ 0714 67                           ld      H,A             ; reset H
 520+ 0715 47                           ld      B,A             ; reset B
 521+ 0716 29                           add     HL,HL           ; create offset (each address is 2-bytes long so we need to double HL)
 522+ 0717 11 9F 0A                     ld      DE,POS_TB_CRS_40; load position table address of cursor for 40 cols
 523+ 071A 3A 95 55                     ld      A,(SCR_SIZE_W)  ; load screen width
 524+ 071D FE 28                        cp      $28             ; is it 40 cols?
 525+ 071F 28 03                        jr      Z,CONT_POS_CURS ; yes, jump over
 526+ 0721 11 6F 0A                     ld      DE,POS_TB_CRS_32; no, load position table address of cursor for 32 cols
 527+ 0724 19           CONT_POS_CURS:  add     HL,DE           ; the correct starting address of the required row is now into HL
 528+ 0725 5E                           ld      E,(HL)          ; load starting address of the required row into DE
 529+ 0726 23                           inc     HL
 530+ 0727 56                           ld      D,(HL)
 531+ 0728 2A 98 55                     ld      HL,(SCR_NAM_TB) ; load starting address of name table
 532+ 072B 19                           add     HL,DE           ; starting address of the current row into name table
 533+ 072C 3A 9A 55                     ld      A,(SCR_CURS_X)  ; load cursor X
 534+ 072F 4F                           ld      C,A             ; transfer A into C
 535+ 0730 09                           add     HL,BC           ; add X offset: now HL contains the address of the current cursor position
 536+ 0731 C9                           ret
 537+ 0732
 538+ 0732              ; find X,Y coordinates of a screen address pointed in VRAM by HL
 539+ 0732              ; return them into L,A for X,Y
 540+ 0732 D5           HL2XY:          push    DE              ; store DE
 541+ 0733 ED 5B 98 55                  ld      DE,(SCR_NAM_TB) ; load starting address of name table into DE
 542+ 0737 AF                           xor     A               ; clear Carry
 543+ 0738 ED 52                        sbc     HL,DE           ; find position relative to screen (from 0,0)
 544+ 073A D1                           pop     DE
 545+ 073B 3A 95 55                     ld      A,(SCR_SIZE_W)  ; load screen width
 546+ 073E 4F                           ld      C,A             ; move it into C
 547+ 073F CD BC 41                     call    DIV_16_8        ; divide position by C: return Y into L and X into A
 548+ 0742 C9                           ret                     ; return to caller
 549+ 0743
 550+ 0743              ;-------------------------------------------------------------------------------
 551+ 0743              ; char table for jumps
 552+ 0743 19           CHRTBL:         defb    HOME
 553+ 0744 86 06                        defw    ATHOME          ; move the cursor to 0,0
 554+ 0746
 555+ 0746 0C                           defb    CS
 556+ 0747 79 06                        defw    CLEARVIDBUF     ; clear video buffer and position cursor at 0,0
 557+ 0749
 558+ 0749 0D                           defb    CR
 559+ 074A C2 09                        defw    CRGRETURN       ; go to the beginning of the next line
 560+ 074C
 561+ 074C 08                           defb    BKSP
 562+ 074D 30 08                        defw    BACKSPACE       ; move cursor left 1 position
 563+ 074F
 564+ 074F 1C                           defb    CRSLFT
 565+ 0750 73 08                        defw    CURSORLEFT      ; move cursor left
 566+ 0752
 567+ 0752 1E                           defb    CRSUP
 568+ 0753 BF 08                        defw    CURSORUP        ; move cursor up
 569+ 0755
 570+ 0755 1D                           defb    CRSRGT
 571+ 0756 D8 08                        defw    CURSORRIGHT     ; move cursor right
 572+ 0758
 573+ 0758 1F                           defb    CRSDN
 574+ 0759 0D 09                        defw    CURSORDOWN      ; move cursor up
 575+ 075B
 576+ 075B 1A                           defb    INSRT
 577+ 075C EE 07                        defw    INSERTKEY       ; insert a space
 578+ 075E
 579+ 075E 0A                           defb    LF
 580+ 075F CA 07                        defw    PLACEHOLDER     ; CURRENTLY WE DON'T PRINT LINE FEED
 581+ 0761
 582+ 0761              ; send current char to video buffer
 583+ 0761 F5           CHAR2VID:       push    AF              ; store AF
 584+ 0762 C5                           push    BC              ; store BC
 585+ 0763 D5                           push    DE              ; store DE
 586+ 0764 E5                           push    HL              ; store HL
 587+ 0765 3A 9F 55                     ld      A,(CRSR_STATE)  ; store cursor state...
 588+ 0768 F5                           push    AF              ; into stack
 589+ 0769 CD 42 09                     call    CURSOR_OFF      ; cursor off
 590+ 076C 3A A2 55                     ld      A,(CHR4VID)     ; recover char
 591+ 076F 06 0A                        ld      B,$0A           ; 10 chars to check
 592+ 0771 21 43 07                     ld      HL,CHRTBL       ; address of key table
 593+ 0774 BE           RPTCPCK:        cp      (HL)            ; compare with char
 594+ 0775 23                           inc     HL              ; beginning of sub-routine address
 595+ 0776 20 09                        jr      NZ,NXTCPCK      ; different, go to next char
 596+ 0778 5E                           ld      E,(HL)          ; load addres into DE
 597+ 0779 23                           inc     HL
 598+ 077A 56                           ld      D,(HL)
 599+ 077B EB                           ex      DE,HL           ; move user routine's address into HL
 600+ 077C 11 BD 07                     ld      DE,EXITCHAR2VID ; set point of return after the user routine
 601+ 077F D5                           push    DE              ; store into stack
 602+ 0780 E9                           jp      (HL)            ; call user routine - then, the CPU will return (jump) to EXITCHAR2VID
 603+ 0781 23           NXTCPCK:        inc     HL              ; jump over 2 cells...
 604+ 0782 23                           inc     HL              ; ...to the next char code
 605+ 0783 10 EF                        djnz    RPTCPCK         ; repeat
 606+ 0785                              ; it'a not a special char, just print it
 607+ 0785 CD 0F 07                     call    LOAD_CRSR_POS   ; recover position of cursor
 608+ 0788 3A A2 55                     ld      A,(CHR4VID)     ; recover char to print
 609+ 078B CD A5 06                     call    WRITE_VIDEO_LOC ; write A into VRAM at (HL)
 610+ 078E 3A 9B 55                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 611+ 0791 5F                           ld      E,A             ; store cursor Y into E
 612+ 0792 3A 9A 55                     ld      A,(SCR_CURS_X)  ; load cursor X
 613+ 0795 3C                           inc     A               ; move 1 step to right
 614+ 0796 21 95 55                     ld      HL,SCR_SIZE_W   ; cell that keeps the width of screen
 615+ 0799 BE                           cp      (HL)            ; have we reached the most right position?
 616+ 079A 20 0F                        jr      NZ,SETCSRCOORDS ; no, go over
 617+ 079C 1C                           inc     E               ; yes, increment cursor Y (go to next line)
 618+ 079D 7B                           ld      A,E             ; move cursor Y into A
 619+ 079E 21 96 55                     ld      HL,SCR_SIZE_H   ; cell that keeps the height of screen
 620+ 07A1 BE                           cp      (HL)            ; have we reached the bottom of the screen?
 621+ 07A2 20 06                        jr      NZ,SETCRSRY     ; no, jump over
 622+ 07A4 D5                           push    DE
 623+ 07A5 CD 49 09                     call    SCROLLUP        ; scroll screen up
 624+ 07A8 D1                           pop     DE
 625+ 07A9 1D                           dec     E               ; decrement 1 row, to set cursor Y on the last line
 626+ 07AA AF           SETCRSRY:       xor     A               ; then set cursor X to 0 (go to beginning of line)
 627+ 07AB 32 9A 55     SETCSRCOORDS:   ld      (SCR_CURS_X),A  ; store current cursor X
 628+ 07AE 7B                           ld      A,E             ; recover Y
 629+ 07AF 32 9B 55                     ld      (SCR_CURS_Y),A  ; store current cursor Y
 630+ 07B2 CD CC 06                     call    POS_CURSOR      ; position cursor into new location
 631+ 07B5 3A 85 55                     ld      A,(TMRCNT)      ; load status of cursor flashing
 632+ 07B8 E6 20                        and     $20             ; check cursor state
 633+ 07BA 32 A0 55                     ld      (LSTCSRSTA),A   ; store the last cursor state
 634+ 07BD AF           EXITCHAR2VID:   xor     A               ; reset char
 635+ 07BE 32 A2 55                     ld      (CHR4VID),A     ; to be sent to screen
 636+ 07C1 F1                           pop     AF              ; recover cursor state
 637+ 07C2 A7                           and     A               ; was it off (A=0)?
 638+ 07C3 C4 2D 09                     call    NZ,CURSOR_ON    ; no, set cursor on
 639+ 07C6 E1                           pop     HL              ; restore HL
 640+ 07C7 D1                           pop     DE              ; restore DE
 641+ 07C8 C1                           pop     BC              ; restore BC
 642+ 07C9 F1                           pop     AF              ; restore AF
 643+ 07CA C9           PLACEHOLDER:    ret                     ; return to caller
 644+ 07CB
 645+ 07CB              ; flash the cursor at the current position
 646+ 07CB              ; (this sub-routine is called by CH3 timer ISR)
 647+ 07CB 3A 9F 55     FLASHCURSOR:    ld      A,(CRSR_STATE)  ; now, check the cursor
 648+ 07CE A7                           and     A               ; cursor off (A=0)?
 649+ 07CF C8                           ret     Z               ; yes, return
 650+ 07D0 3A 85 55                     ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
 651+ 07D3 E6 20                        and     $20             ; check if it's time to flash the cursor (check bit #6)
 652+ 07D5 21 A0 55                     ld      HL,LSTCSRSTA    ; load address of cell that stores the last cursor state
 653+ 07D8 BE                           cp      (HL)            ; compare current state with last state
 654+ 07D9 C8                           ret     Z               ; same state, no change required - exit
 655+ 07DA 77                           ld      (HL),A          ; save new state
 656+ 07DB F5                           push    AF              ; store A (keep state for later use)
 657+ 07DC CD 0F 07                     call    LOAD_CRSR_POS   ; load current cursor position into HL
 658+ 07DF F1                           pop     AF              ; recover current state
 659+ 07E0 06 FF                        ld      B,$FF           ; cursor char
 660+ 07E2 FE 20                        cp      $20             ; is the cursor on video (A == $20)?
 661+ 07E4 28 04                        jr      Z,PUTCRSCHR     ; yes, jump over
 662+ 07E6 3A 9E 55                     ld      A,(SCR_ORG_CHR) ; no, load the original char
 663+ 07E9 47                           ld      B,A             ; move char into B
 664+ 07EA 78           PUTCRSCHR:      ld      A,B             ; recover char from B
 665+ 07EB C3 A5 06                     jp      WRITE_VIDEO_LOC ; print cursor/char at the current position & return
 666+ 07EE
 667+ 07EE
 668+ 07EE              ; insert an empty space at the current position of the cursor, moving the following text
 669+ 07EE              ; 1 cell straight
 670+ 07EE CD 06 07     INSERTKEY:      call    RSTCHRCRS       ; restore char under the cursor
 671+ 07F1 CD 0F 07                     call    LOAD_CRSR_POS   ; retrieve address of cursor cell
 672+ 07F4 22 A5 55                     ld      (CUR_POS),HL    ; store it
 673+ 07F7 CD 49 0A                     call    ENDOFLN         ; find address of first free cell after the end of the text from the current cursor position - address into HL -
 674+ 07FA                                                      ; DE is the address of the bottom right cell of the screen
 675+ 07FA 22 A9 55                     ld      (ENDTXT),HL     ; store it
 676+ 07FD ED 4B A5 55                  ld      BC,(CUR_POS)    ; load starting address
 677+ 0801 AF                           xor     A
 678+ 0802 ED 42                        sbc     HL,BC           ; how many positions to move?
 679+ 0804 CA DC 06                     jp      Z,MOVSHOWCRS    ; none - leave and re-place cursor
 680+ 0807 44 4D                        ld      BC,HL           ; number of chars to scroll into BC
 681+ 0809 2A A9 55                     ld      HL,(ENDTXT)     ; load address of the end of text
 682+ 080C 2B           CHKHL:          dec     HL              ; decrement to find the address of the char to move
 683+ 080D E5                           push    HL
 684+ 080E CD 61 41                     call    CMP16           ; is it the last cell (bottom right) of screen?
 685+ 0811 E1                           pop     HL
 686+ 0812 D2 1D 08                     jp      NC,NXTINST      ; yes, so jump over - nothing to do
 687+ 0815 CD 90 06                     call    READ_VIDEO_LOC  ; no, so read current char
 688+ 0818 23                           inc     HL              ; next cell
 689+ 0819 CD A5 06                     call    WRITE_VIDEO_LOC ; write into new position
 690+ 081C 2B                           dec     HL              ; decrement to old position
 691+ 081D 0B           NXTINST:        dec     BC              ; decrement number of chars to move
 692+ 081E 79                           ld      A,C
 693+ 081F B0                           or      B               ; finished?
 694+ 0820 20 EA                        jr      NZ,CHKHL        ; no, repeat
 695+ 0822 3E 20                        ld      A,SPC           ; load SPACE character
 696+ 0824 2A A5 55                     ld      HL,(CUR_POS)    ; get cursor position
 697+ 0827 32 9E 55                     ld      (SCR_ORG_CHR),A ; reset original char under the cursor
 698+ 082A CD A5 06                     call    WRITE_VIDEO_LOC ; empty current video location
 699+ 082D C3 DC 06                     jp      MOVSHOWCRS      ; re-place cursor
 700+ 0830
 701+ 0830              ; delete the char at the left of the cursor
 702+ 0830 CD 06 07     BACKSPACE:      call    RSTCHRCRS       ; restore char
 703+ 0833 2A 98 55                     ld      HL,(SCR_NAM_TB) ; address of origin of screen (location 0,0)
 704+ 0836 44 4D                        ld      BC,HL           ; store into BC
 705+ 0838 CD 0F 07                     call    LOAD_CRSR_POS   ; load address of current cursor pos.
 706+ 083B 54 5D                        ld      DE,HL           ; copy into DE
 707+ 083D AF                           xor     A               ; reset Carry
 708+ 083E ED 42                        sbc     HL,BC           ; check how many chars between
 709+ 0840 CA 6A 08                     jp      Z,LVBKSP        ; none, so we are at the top left corner
 710+ 0843 ED 53 A5 55                  ld      (CUR_POS),DE    ; store current cursor position
 711+ 0847 CD 49 0A                     call    ENDOFLN         ; check end of text
 712+ 084A ED 5B A5 55                  ld      DE,(CUR_POS)    ; retrieve cursor position
 713+ 084E AF                           xor     A               ; reset Carry
 714+ 084F ED 52                        sbc     HL,DE           ; check if none follows
 715+ 0851 CA 6A 08                     jp      Z,LVBKSP        ; no chars follow, so simply move the cursor
 716+ 0854 44 4D                        ld      BC,HL           ; save numbers of chars to move
 717+ 0856 EB                           ex      DE,HL           ; copy starting position into HL
 718+ 0857 CD 90 06     MVBKSP:         call    READ_VIDEO_LOC  ; read char
 719+ 085A 2B                           dec     HL              ; 1 position to left
 720+ 085B CD A5 06                     call    WRITE_VIDEO_LOC ; write char
 721+ 085E 23                           inc     HL              ; goto next char to copy (2 steps to right)
 722+ 085F 23                           inc     HL
 723+ 0860 0B                           dec     BC              ; decrement # of chars
 724+ 0861 79                           ld      A,C
 725+ 0862 B0                           or      B               ; 0 chars?
 726+ 0863 20 F2                        jr      NZ,MVBKSP       ; not finished, continue
 727+ 0865 2B                           dec     HL
 728+ 0866 AF                           xor     A
 729+ 0867 CD A5 06                     call    WRITE_VIDEO_LOC ; reset last char
 730+ 086A CD 9C 08     LVBKSP:         call    MVCRS2LFT       ; move cursor to new position
 731+ 086D CD F1 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 732+ 0870 C3 DC 06                     jp      MOVSHOWCRS      ; move cursor to the new location and set it ON
 733+ 0873
 734+ 0873
 735+ 0873              ; move cursor to left
 736+ 0873 F5           CURSORLEFT:     push    AF              ; store A
 737+ 0874 3A 9A 55                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 738+ 0877 A7                           and     A               ; is it at the most left of the screen (X=0)?
 739+ 0878 28 0C                        jr      Z,CHCKYPOS      ; yes, check Y position
 740+ 087A 3D                           dec     A               ; no, decrement X
 741+ 087B 32 9C 55                     ld      (SCR_CUR_NX),A  ; store new X
 742+ 087E 3A 9B 55                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 743+ 0881 32 9D 55                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 744+ 0884 18 11                        jr      CONTCRSLFT      ; go on moving cursor
 745+ 0886 3A 9B 55     CHCKYPOS:       ld      A,(SCR_CURS_Y)  ; load cursor Y
 746+ 0889 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 747+ 088A 28 0E                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 748+ 088C 3D                           dec     A               ; no, decrement Y
 749+ 088D 32 9D 55                     ld      (SCR_CUR_NY),A  ; store new Y
 750+ 0890 3A 95 55                     ld      A,(SCR_SIZE_W)  ; load current screen width
 751+ 0893 3D                           dec     A               ; cursor to the most right position (width-0)
 752+ 0894 32 9C 55                     ld      (SCR_CUR_NX),A  ; set new cursor X
 753+ 0897 CD D6 06     CONTCRSLFT:     call    MOVCRS          ; move cursor into new position
 754+ 089A F1           EXITCURSORLEFT: pop     AF              ; restore A
 755+ 089B C9                           ret                     ; return to caller
 756+ 089C
 757+ 089C              ; move cursor 1 position to the left
 758+ 089C 3A 9A 55     MVCRS2LFT:      ld      A,(SCR_CURS_X)  ; load cursor X into A
 759+ 089F A7                           and     A               ; is it at the most left of the screen (X=0)?
 760+ 08A0 28 0B                        jr      Z,CHKYPOS       ; yes, check Y position
 761+ 08A2 3D                           dec     A               ; no, decrement X
 762+ 08A3 32 9C 55                     ld      (SCR_CUR_NX),A  ; store new X
 763+ 08A6 3A 9B 55                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 764+ 08A9 32 9D 55                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 765+ 08AC C9                           ret                     ; go on moving cursor
 766+ 08AD 3A 9B 55     CHKYPOS:        ld      A,(SCR_CURS_Y)  ; load cursor Y
 767+ 08B0 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 768+ 08B1 28 E7                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 769+ 08B3 3D                           dec     A               ; no, decrement Y
 770+ 08B4 32 9D 55                     ld      (SCR_CUR_NY),A  ; store new Y
 771+ 08B7 3A 95 55                     ld      A,(SCR_SIZE_W)  ; load current screen width
 772+ 08BA 3D                           dec     A               ; cursor to the most right position (width-1)
 773+ 08BB 32 9C 55                     ld      (SCR_CUR_NX),A  ; set new cursor X
 774+ 08BE C9                           ret                     ; return to caller
 775+ 08BF
 776+ 08BF              ; move cursor up
 777+ 08BF F5           CURSORUP:       push    AF              ; store A
 778+ 08C0 3A 9B 55                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 779+ 08C3 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 780+ 08C4 28 10                        jr      Z,EXITCURSORUP  ; yes, exit doing nothing
 781+ 08C6 3D                           dec     A               ; no, decrement Y
 782+ 08C7 32 9D 55                     ld      (SCR_CUR_NY),A  ; store new Y
 783+ 08CA 3A 9A 55                     ld      A,(SCR_CURS_X)  ; load current cursor X
 784+ 08CD 32 9C 55                     ld      (SCR_CUR_NX),A  ; set new cursor X
 785+ 08D0 CD 06 07                     call    RSTCHRCRS       ; restore char under the cursor and print it
 786+ 08D3 CD D6 06                     call    MOVCRS          ; move cursor into new position
 787+ 08D6 F1           EXITCURSORUP:   pop     AF              ; restore A
 788+ 08D7 C9                           ret                     ; return to caller
 789+ 08D8
 790+ 08D8
 791+ 08D8              ; move cursor to right
 792+ 08D8 F5           CURSORRIGHT:    push    AF              ; store A
 793+ 08D9 C5                           push    BC              ; store B
 794+ 08DA 3A 95 55                     ld      A,(SCR_SIZE_W)  ; load current screen width (in text modes it's 32 or 40)
 795+ 08DD 3D                           dec     A               ; decrement it (most right can only be 31 or 39)
 796+ 08DE 47                           ld      B,A             ; move A into B
 797+ 08DF 3A 9A 55                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 798+ 08E2 B8                           cp      B               ; is cursor at the most right position on the screen?
 799+ 08E3 30 0C                        jr      NC,CHCKYPOS2    ; yes, so jump to check Y position
 800+ 08E5 3C                           inc     A               ; no, so increment X
 801+ 08E6 32 9C 55                     ld      (SCR_CUR_NX),A  ; store new X
 802+ 08E9 3A 9B 55                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 803+ 08EC 32 9D 55                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 804+ 08EF 18 13                        jr      CONTCRSRGT      ; go on moving cursor
 805+ 08F1 3A 96 55     CHCKYPOS2:      ld      A,(SCR_SIZE_H)  ; load screen height
 806+ 08F4 3D                           dec     A               ; decrement it (last row can only be 23)
 807+ 08F5 47                           ld      B,A             ; move bottom into B
 808+ 08F6 3A 9B 55                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 809+ 08F9 B8                           cp      B               ; is the cursor at the bottom of the screen?
 810+ 08FA 30 0E                        jr      NC,EXITCURSORRGHT; yes, exit doing nothing
 811+ 08FC 3C                           inc     A               ; no, increment Y
 812+ 08FD 32 9D 55                     ld      (SCR_CUR_NY),A  ; store new Y
 813+ 0900 AF                           xor     A               ; move cursor to top left
 814+ 0901 32 9C 55                     ld      (SCR_CUR_NX),A  ; store new X
 815+ 0904 CD 06 07     CONTCRSRGT:     call    RSTCHRCRS       ; restore char under the cursor and print it
 816+ 0907 CD D6 06                     call    MOVCRS          ; move cursor into new position
 817+ 090A C1           EXITCURSORRGHT: pop     BC              ; retrieve BC
 818+ 090B F1                           pop     AF              ; restore A
 819+ 090C C9                           ret                     ; return to caller
 820+ 090D
 821+ 090D
 822+ 090D              ; move cursor down
 823+ 090D F5           CURSORDOWN:     push    AF              ; store A
 824+ 090E C5                           push    BC              ; store B
 825+ 090F 3A 96 55                     ld      A,(SCR_SIZE_H)  ; load current screen height (in text modes it's 24)
 826+ 0912 3D                           dec     A               ; decrement it (positions can only vary between 0 and 23)
 827+ 0913 47                           ld      B,A             ; move X into B
 828+ 0914 3A 9B 55                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 829+ 0917 B8                           cp      B               ; is current cursor position < 23?
 830+ 0918 30 10                        jr      NC,EXITCURSORDOWN; no, exit doing nothing
 831+ 091A 3C                           inc     A               ; yes, increment Y
 832+ 091B 32 9D 55                     ld      (SCR_CUR_NY),A  ; store new Y
 833+ 091E 3A 9A 55                     ld      A,(SCR_CURS_X)  ; load current cursor X
 834+ 0921 32 9C 55                     ld      (SCR_CUR_NX),A  ; set new cursor X
 835+ 0924 CD 06 07                     call    RSTCHRCRS       ; restore char under the cursor and print it
 836+ 0927 CD D6 06                     call    MOVCRS          ; move cursor into new position
 837+ 092A C1           EXITCURSORDOWN: pop     BC              ; retrieve BC
 838+ 092B F1                           pop     AF              ; retrieve A
 839+ 092C C9                           ret                     ; return to caller
 840+ 092D
 841+ 092D
 842+ 092D              ; set cursor on (visible on screen)
 843+ 092D F5           CURSOR_ON:      push    AF              ; store AF
 844+ 092E 3A 9F 55                     ld      A,(CRSR_STATE)  ; load cursor state
 845+ 0931 B7                           or      A               ; is it on?
 846+ 0932 20 0C                        jr      NZ,EXITCURSOR_ON; yes, so nothing to do
 847+ 0934 3A 96 55                     ld      A,(SCR_SIZE_H)  ; check the video mode
 848+ 0937 FE 30                        cp      $30             ; graphics 2 or 3 (if value>=48)?
 849+ 0939 30 05                        jr      NC,EXITCURSOR_ON; yes, so exit (no cursor in graphics 2 or 3)
 850+ 093B 3E 01                        ld      A,$01           ; cursor state ON
 851+ 093D 32 9F 55                     ld      (CRSR_STATE),A  ; set state
 852+ 0940 F1           EXITCURSOR_ON:  pop     AF              ; restore AF
 853+ 0941 C9                           ret                     ; return to caller
 854+ 0942
 855+ 0942              ; set cursor off (invisible on screen)
 856+ 0942 F5           CURSOR_OFF:     push    AF              ; store AF
 857+ 0943 AF                           xor     A               ; cursor state OFF
 858+ 0944 32 9F 55                     ld      (CRSR_STATE),A  ; set state
 859+ 0947 F1                           pop     AF              ; restore AF
 860+ 0948 C9                           ret
 861+ 0949
 862+ 0949              ; scroll the screen 1 row up
 863+ 0949 AF           SCROLLUP:       xor     A               ; reset A
 864+ 094A 57                           ld      D,A             ; reset D
 865+ 094B 32 A1 55                     ld      (PRNTVIDEO),A   ; no print on screen while scrolling
 866+ 094E 2A 98 55                     ld      HL,(SCR_NAM_TB) ; start address of the name table
 867+ 0951 22 D5 55                     ld      (VIDTMP1),HL    ; store address of the destination row (1st row of the screen)
 868+ 0954 3A 95 55                     ld      A,(SCR_SIZE_W)  ; load the screen width
 869+ 0957 5F                           ld      E,A             ; move width into E
 870+ 0958 19                           add     HL,DE           ; HL now contains the address of the source row (2nd row of the screen)
 871+ 0959 22 D7 55                     ld      (VIDTMP2),HL    ; store address of source row
 872+ 095C 3A 96 55                     ld      A,(SCR_SIZE_H)  ; load the screen height
 873+ 095F 3D                           dec     A               ; decrement the # of rows: now, A contains the # of rows to be moved
 874+ 0960 47                           ld      B,A             ; move # of rows into B
 875+ 0961 3A 95 55     SCROLLNXTRW:    ld      A,(SCR_SIZE_W)  ; (re)load the screen width
 876+ 0964 5F                           ld      E,A             ; move width into E
 877+ 0965 2A D7 55                     ld      HL,(VIDTMP2)    ; load source address
 878+ 0968 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 879+ 096A ED 69                        out     (C),L           ; low byte of source
 880+ 096C ED 61                        out     (C),H           ; high byte of source
 881+ 096E 21 AD 55                     ld      HL,VIDEOBUFF    ; load address of the first cell of the video buffer
 882+ 0971 0D                           dec     C               ; VDP data mode
 883+ 0972 00                           nop                     ; added to compensate shorter instruction
 884+ 0973 ED 78        LOADNEXTCOL:    in      A,(C)           ; load char
 885+ 0975 77                           ld      (HL),A          ; store char
 886+ 0976 23                           inc     HL              ; next cell of the buffer
 887+ 0977 1D                           dec     E               ; count the chars to be read
 888+ 0978 20 F9                        jr      NZ,LOADNEXTCOL  ; repeat until we read the entire row
 889+ 097A 3A 95 55                     ld      A,(SCR_SIZE_W)  ; reload the screen width
 890+ 097D 5F                           ld      E,A             ; move # of rows into E
 891+ 097E 16 00                        ld      D,$00           ; reset D
 892+ 0980 2A D5 55                     ld      HL,(VIDTMP1)    ; load address of destination row
 893+ 0983 E5                           push    HL              ; store HL
 894+ 0984 2A D7 55                     ld      HL,(VIDTMP2)    ; current source will be..
 895+ 0987 22 D5 55                     ld      (VIDTMP1),HL    ; ..new destination
 896+ 098A 19                           add     HL,DE           ; address of new
 897+ 098B 22 D7 55                     ld      (VIDTMP2),HL    ; source row
 898+ 098E E1                           pop     HL              ; restore address of current destination row
 899+ 098F CB F4                        set     6,H             ; writing mode
 900+ 0991 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 901+ 0993 ED 69                        out     (C),L           ; low byte
 902+ 0995 ED 61                        out     (C),H           ; high byte of address
 903+ 0997 21 AD 55                     ld      HL,VIDEOBUFF    ; video buffer address
 904+ 099A 0D                           dec     C               ; VDP data mode
 905+ 099B 7E           WRITEBUF:       ld      A,(HL)          ; load char
 906+ 099C ED 79                        out     (C),A           ; send char
 907+ 099E 23                           inc     HL              ; increment buffer index
 908+ 099F 1D                           dec     E               ; next row
 909+ 09A0 20 F9                        jr      NZ,WRITEBUF     ; repeat until 0
 910+ 09A2 10 BD                        djnz    SCROLLNXTRW     ; repeat for the entire screen
 911+ 09A4 3A 95 55                     ld      A,(SCR_SIZE_W)  ; reload screen width
 912+ 09A7 47                           ld      B,A             ; cells to empty into B
 913+ 09A8 AF                           xor     A               ; null char
 914+ 09A9 0E 31                        ld      C,VDP_SET       ; VDP set mode
 915+ 09AB 2A D5 55                     ld      HL,(VIDTMP1)    ; load address of the last row
 916+ 09AE CB F4                        set     6,H             ; writing mode
 917+ 09B0 ED 69                        out     (C),L           ; low byte then..
 918+ 09B2 ED 61                        out     (C),H           ; high byte of address
 919+ 09B4 0D                           dec     C               ; VDP data mode
 920+ 09B5 00                           nop                     ; delay
 921+ 09B6 ED 79        RPTEMPTYROW:    out     (C),A           ; empty cell
 922+ 09B8 00                           nop                     ; delay
 923+ 09B9 00                           nop
 924+ 09BA 10 FA                        djnz    RPTEMPTYROW     ; repeat until the last row has been cleaned
 925+ 09BC 3E 01                        ld      A,$01
 926+ 09BE 32 A1 55                     ld      (PRNTVIDEO),A   ; set print-on-video on
 927+ 09C1 C9                           ret                     ; return to caller
 928+ 09C2
 929+ 09C2              ; carriage return: first, it looks for char $00 at the beginning of the line (look for the first null char),
 930+ 09C2              ; then it starts sendind every char it finds on the screen to the terminal buffer of the BASIC interpreter
 931+ 09C2              ; until another null char is found. Finally, move to the next line and position the cursor at the beginning
 932+ 09C2              ; of the row (equivalent to CR+LF), then gets back control to the screen editor to let it interpret the line
 933+ 09C2              CUR_POS         equ     TMPBFR1         ; cursor position
 934+ 09C2              SRTTXT          equ     TMPBFR2         ; start of text line
 935+ 09C2              ENDTXT          equ     TMPBFR3         ; end of text line
 936+ 09C2              CRGRETURN:      ; preliminary: disable cursor if on, and retrieve char under it
 937+ 09C2 3A 9F 55                     ld      A,(CRSR_STATE)  ; recover cursor state
 938+ 09C5 32 AB 55                     ld      (TMPBFR4),A     ; store status
 939+ 09C8 A7                           and     A               ; is cursor on?
 940+ 09C9 C4 42 09                     call    NZ,CURSOR_OFF   ; yes, so set cursor off
 941+ 09CC CD 06 07                     call    RSTCHRCRS       ; restore char under it
 942+ 09CF                              ; first, check if cursor if off, so that we just interpret return as a new line command
 943+ 09CF 3A DF 55                     ld      A,(KBDNPT)      ; check if input from keyboad
 944+ 09D2 A7                           and     A               ; if 0, input is not from keyboard...
 945+ 09D3 CA 28 0A                     jp      Z,PRNTRETURN    ; ...so just print a carriage return; otherwise, interpret the return
 946+ 09D6                              ; first part: look for the beginning of the text line on screen
 947+ 09D6 CD 0F 07                     call    LOAD_CRSR_POS   ; load cursor position into HL
 948+ 09D9 22 A5 55                     ld      (CUR_POS),HL    ; store it
 949+ 09DC ED 5B 98 55                  ld      DE,(SCR_NAM_TB) ; load VRAM address of top-left cell of screen ("home")
 950+ 09E0 E5           RPTNLLSRC:      push    HL
 951+ 09E1 CD 61 41                     call    CMP16           ; check if at "home"
 952+ 09E4 E1                           pop     HL
 953+ 09E5 CA F0 09                     jp      Z,CNTNULL       ; yes, exit because there is nothing before
 954+ 09E8 2B                           dec     HL              ; go 1 step back
 955+ 09E9 CD 90 06                     call    READ_VIDEO_LOC  ; read char of current position
 956+ 09EC A7                           and     A               ; is it $00 (null char)?
 957+ 09ED 20 F1                        jr      NZ,RPTNLLSRC    ; no, continue searching
 958+ 09EF 23                           inc     HL              ; move 1 step forward to go back to the last cell with something in
 959+ 09F0                              ; second part: look for the ending of the text on screen
 960+ 09F0 22 A7 55     CNTNULL:        ld      (SRTTXT),HL     ; store beginning of text
 961+ 09F3 CD 49 0A                     call    ENDOFLN         ; find end of text line looking at the end of chars after the cursor position
 962+ 09F6 22 A9 55                     ld      (ENDTXT),HL     ; store ending of text line
 963+ 09F9 ED 5B A7 55                  ld      DE,(SRTTXT)     ; load beginning of text line
 964+ 09FD A7                           and     A               ; clear Carry
 965+ 09FE ED 52                        sbc     HL,DE           ; how many chars?
 966+ 0A00 28 26                        jr      Z,PRNTRETURN    ; no chars found (HL-DE=0), so just print return & leave
 967+ 0A02                              ;---    central part: send the text on the screen to the interpreter
 968+ 0A02 2A A7 55                     ld      HL,(SRTTXT)     ; load beginning of text line
 969+ 0A05 ED 5B A9 55                  ld      DE,(ENDTXT)     ; load ending of text line
 970+ 0A09 CD 90 06     SNDCHRTOBFR:    call    READ_VIDEO_LOC  ; read char
 971+ 0A0C E5                           push    HL
 972+ 0A0D CD FD 01                     call    CHARINTOBFR     ; send char to buffer
 973+ 0A10 E1                           pop     HL
 974+ 0A11 23                           inc     HL              ; go to next char
 975+ 0A12 E5                           push    HL              ; store HL
 976+ 0A13 CD 61 41                     call    CMP16           ; check if DE=HL (finish chars)
 977+ 0A16 E1                           pop     HL
 978+ 0A17 20 F0                        jr      NZ,SNDCHRTOBFR  ; no, repeat
 979+ 0A19 3E 0D                        ld      A,CR            ; yes, so now send carriage return
 980+ 0A1B CD FD 01                     call    CHARINTOBFR     ; send to buffer
 981+ 0A1E 2A A9 55                     ld      HL,(ENDTXT)     ; recover address of last char of input text
 982+ 0A21 CD 32 07                     call    HL2XY           ; retrieve X,Y from address
 983+ 0A24 7D                           ld      A,L             ; move Y into A (we don't need X anymore)
 984+ 0A25 32 9B 55                     ld      (SCR_CURS_Y),A  ; store new Y
 985+ 0A28                              ;---    final part: go at the beginning of a new line on the screen
 986+ 0A28 AF           PRNTRETURN:     xor     A               ; move to col 0
 987+ 0A29 32 9A 55                     ld      (SCR_CURS_X),A  ; store new X
 988+ 0A2C 3A 9B 55                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 989+ 0A2F 3C                           inc     A               ; new row
 990+ 0A30 21 96 55                     ld      HL,SCR_SIZE_H   ; load address of cell that keeps screen height
 991+ 0A33 BE                           cp      (HL)            ; is the cursor over the bottom of the screen?
 992+ 0A34 38 06                        jr      C,ADDNEWLINE    ; no, jump over
 993+ 0A36 3D                           dec     A               ; yes, so come back 1 row, then...
 994+ 0A37 F5                           push    AF              ; (store A)
 995+ 0A38 CD 49 09                     call    SCROLLUP        ; ...scroll the screen before to...
 996+ 0A3B F1                           pop     AF              ; (retrieve A)
 997+ 0A3C 32 9B 55     ADDNEWLINE:     ld      (SCR_CURS_Y),A  ; ...store new Y
 998+ 0A3F 3A AB 55                     ld      A,(TMPBFR4)     ; retrieve cursor state
 999+ 0A42 A7                           and     A               ; was it off (A=0)?
1000+ 0A43 C4 2D 09                     call    NZ,CURSOR_ON    ; no, set cursor on
1001+ 0A46 C3 CC 06                     jp      POS_CURSOR      ; position cursor to new location & return to caller
1002+ 0A49
1003+ 0A49              ; find end of text line
1004+ 0A49              ; destroys A, DE, and HL - store address of last char of text line into HL,
1005+ 0A49              ; while DE contains the address of the bottom right cell of the screen
1006+ 0A49 3A 96 55     ENDOFLN:        ld      A,(SCR_SIZE_H)
1007+ 0A4C 5F                           ld      E,A             ; load screen height into DE
1008+ 0A4D 3A 95 55                     ld      A,(SCR_SIZE_W)
1009+ 0A50 6F                           ld      L,A             ; load screen width into HL
1010+ 0A51 AF                           xor     A
1011+ 0A52 67                           ld      H,A
1012+ 0A53 57                           ld      D,A
1013+ 0A54 CD 6C 41                     call    MUL16           ; multiply HL times DE to get the screen size
1014+ 0A57 ED 5B 98 55                  ld      DE,(SCR_NAM_TB) ; load screen name table start address into DE
1015+ 0A5B 19                           add     HL,DE           ; get the address...
1016+ 0A5C 2B                           dec     HL              ; ...of the "last" video cell
1017+ 0A5D EB                           ex      DE,HL           ; store address into DE
1018+ 0A5E 2A A5 55                     ld      HL,(CUR_POS)    ; retrieve original cursor position
1019+ 0A61 E5           RPTNLLSRC2:     push    HL
1020+ 0A62 CD 61 41                     call    CMP16           ; check if at last position on screen (bottom right corner)
1021+ 0A65 E1                           pop     HL
1022+ 0A66 C8                           ret     Z               ; if yes, exit because these is nothing after
1023+ 0A67 23                           inc     HL              ; 1 more step forward
1024+ 0A68 CD 90 06                     call    READ_VIDEO_LOC  ; read char of current position
1025+ 0A6B A7                           and     A               ; is it $00 (null char)?
1026+ 0A6C 20 F3                        jr      NZ,RPTNLLSRC2   ; no, continue searching
1027+ 0A6E C9                           ret                     ; yes: found end of text, return to caller
1028+ 0A6F
1029+ 0A6F
1030+ 0A6F              ; ------------------------------------------------------------------------------
1031+ 0A6F                              ; this table contains the values of the offsets to be added to
1032+ 0A6F                              ; the starting address of the name table to find the correct
1033+ 0A6F                              ; value of the first cell of the corresponding row
1034+ 0A6F                              ; (by doing so, it's faster than doing a multipication)
1035+ 0A6F                              ; table for graphics 1 text mode: 32 cols
1036+ 0A6F 00 00 20 00  POS_TB_CRS_32:  defw    $0000,$0020,$0040,$0060,$0080,$00A0,$00C0,$00E0
1036+ 0A73 40 00 60 00
1036+ 0A77 80 00 A0 00
1036+ 0A7B C0 00 E0 00
1037+ 0A7F 00 01 20 01                  defw    $0100,$0120,$0140,$0160,$0180,$01A0,$01C0,$01E0
1037+ 0A83 40 01 60 01
1037+ 0A87 80 01 A0 01
1037+ 0A8B C0 01 E0 01
1038+ 0A8F 00 02 20 02                  defw    $0200,$0220,$0240,$0260,$0280,$02A0,$02C0,$02E0
1038+ 0A93 40 02 60 02
1038+ 0A97 80 02 A0 02
1038+ 0A9B C0 02 E0 02
1039+ 0A9F                              ; table for pure text mode: 40 cols
1040+ 0A9F 00 00 28 00  POS_TB_CRS_40:  defw    $0000,$0028,$0050,$0078,$00A0,$00C8,$00F0,$0118
1040+ 0AA3 50 00 78 00
1040+ 0AA7 A0 00 C8 00
1040+ 0AAB F0 00 18 01
1041+ 0AAF 40 01 68 01                  defw    $0140,$0168,$0190,$01B8,$01E0,$0208,$0230,$0258
1041+ 0AB3 90 01 B8 01
1041+ 0AB7 E0 01 08 02
1041+ 0ABB 30 02 58 02
1042+ 0ABF 80 02 A8 02                  defw    $0280,$02A8,$02D0,$02F8,$0320,$0348,$0370,$0398
1042+ 0AC3 D0 02 F8 02
1042+ 0AC7 20 03 48 03
1042+ 0ACB 70 03 98 03
1043+ 0ACF
1044+ 0ACF              ; ------------------------------------------------------------------------------
1045+ 0ACF              ; reset VRAM
1046+ 0ACF AF           EMPTY_VRAM:     xor     A               ; reg.A cleared: we fill up VRAM with $00
1047+ 0AD0 67                           ld      H,A
1048+ 0AD1 6F                           ld      L,A             ; reset HL
1049+ 0AD2 CD 70 06                     call    SETVDPADRS      ; set address of first VRAM cell to $0000
1050+ 0AD5 06 40                        ld      B,$40           ; $40 pages of RAM...
1051+ 0AD7 57                           ld      D,A             ; ...each one with $100 cells (tot. $4000 bytes)
1052+ 0AD8 0D                           dec     C               ; VDP data mode
1053+ 0AD9 ED 79        EMPTVRM:        out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
1054+ 0ADB 14                           inc     D               ; next cell
1055+ 0ADC 00                           nop
1056+ 0ADD 20 FA                        jr      NZ,EMPTVRM      ; repeat until page is fully cleared
1057+ 0ADF 10 F8                        djnz    EMPTVRM         ; repeat for $40 pages
1058+ 0AE1 C9                           ret                     ; return to caller
1059+ 0AE2
1060+ 0AE2              ; clear video registers in SRAM
1061+ 0AE2 21 95 55     CLR_RAM_REG:    ld      HL,SCR_SIZE_W   ; address of first register
1062+ 0AE5 AF                           xor     A               ; $00 to clean the registers
1063+ 0AE6 06 44                        ld      B,CHASNDDTN-SCR_SIZE_W; how many bytes (registers) to clean (dinamically calculated)
1064+ 0AE8 77           RSTVDPRAMREG:   ld      (HL),A          ; reset register
1065+ 0AE9 23                           inc     HL              ; next register
1066+ 0AEA 10 FC                        djnz    RSTVDPRAMREG    ; repeat
1067+ 0AEC C9                           ret                     ; return to caller
1068+ 0AED
1069+ 0AED              ; ------------------------------------------------------------------------------
1070+ 0AED              ; set a specific graphics mode, passed into reg. E
1071+ 0AED 06 08        SET_GFX_MODE:   ld      B,$08           ; 8 registers means 8 bytes..
1072+ 0AEF CB 23                        sla     E               ; multiply E by 8..
1073+ 0AF1 CB 23                        sla     E               ; so that reg. E can point..
1074+ 0AF3 CB 23                        sla     E               ; to the correct settings
1075+ 0AF5 16 00        SET_GFX_MODE2:  ld      D,$00           ; reset D
1076+ 0AF7 21 29 0B                     ld      HL,VDPMODESET   ; pointer to register settings | <= here points the SHOW_LOGO sub-routine
1077+ 0AFA 19                           add     HL,DE           ; add offset to get the correct set of values for the required mode
1078+ 0AFB 3E 80                        ld      A,$80           ; start with REG0 ($80+register number)
1079+ 0AFD 0E 31                        ld      C,VDP_SET       ; VDP set
1080+ 0AFF 56           LDREGVLS:       ld      D,(HL)          ; load register's value
1081+ 0B00 ED 51                        out     (C),D           ; send data to VDP
1082+ 0B02 ED 79                        out     (C),A           ; indicate the register to send data to
1083+ 0B04 3C                           inc     A               ; next register
1084+ 0B05 23                           inc     HL              ; next value
1085+ 0B06 10 F7                        djnz    LDREGVLS        ; repeat for 8 registers
1086+ 0B08 C9                           ret
1087+ 0B09
1088+ 0B09              ; ------------------------------------------------------------------------------
1089+ 0B09              LOADCHARSET:    ; reg. A contains the video mode
1090+ 0B09                              ; reg. HL contains address of pattern table into VRAM
1091+ 0B09 06 00                        ld      B,$00           ; 0=256 chars to load (complete charset)
1092+ 0B0B CB F4                        set     $06,H           ; add $4000 to address to indicate that we want to write into VRAM
1093+ 0B0D 0E 31                        ld      C,VDP_SET       ; load VDP address into C
1094+ 0B0F ED 69                        out     (C),L           ; send low byte of address
1095+ 0B11 ED 61                        out     (C),H           ; send high byte
1096+ 0B13 0D                           dec     C               ; VDP data mode
1097+ 0B14 21 97 42                     ld      HL,CHRST68      ; starting address of 6x8 charset into ROM
1098+ 0B17 A7                           and     A               ; is it text mode (A=0)?
1099+ 0B18 28 03                        jr      Z,NXTCHAR       ; yes, so jump to load chars into VRAM
1100+ 0B1A 21 97 4A                     ld      HL,CHRST88      ; no, so we change and load the 8x8 charset
1101+ 0B1D 16 08        NXTCHAR:        ld      D,$08           ; 8 bytes per pattern char
1102+ 0B1F 7E           SENDCHRPTRNS:   ld      A,(HL)          ; load byte to send to VDP
1103+ 0B20 ED 79                        out     (C),A           ; write byte into VRAM
1104+ 0B22 23                           inc     HL              ; inc byte pointer
1105+ 0B23 15                           dec     D               ; 8 bytes sents (0 char)?
1106+ 0B24 20 F9                        jr      NZ,SENDCHRPTRNS ; no, continue
1107+ 0B26 10 F5                        djnz    NXTCHAR         ; yes, decrement chars counter and continue for all the chars
1108+ 0B28 C9                           ret                     ; return to caller
1109+ 0B29
1110+ 0B29              ;------------------------------------------------------------------------------
1111+ 0B29              ; NAME TABLE:       buffer video - contains the chars to be shown on video
1112+ 0B29              ; PATTERN TABLE:    charset - contains the chars/tiles to be loaded into the name table
1113+ 0B29              ; COLOR TABLE:      color settings for chars/tiles
1114+ 0B29
1115+ 0B29                              ; VDP register settings for a text display
1116+ 0B29 00           VDPMODESET:     defb    %00000000       ; reg.0: external video off
1117+ 0B2A D0                           defb    %11010000       ; reg.1: 16K VRAM, video on, int. off, text mode (40x24)
1118+ 0B2B 02                           defb    $02             ; reg.2: name table set to $0800 ($02x$400)
1119+ 0B2C 00                           defb    $00             ; reg.3: not used in text mode
1120+ 0B2D 00                           defb    $00             ; reg.4: pattern table set to $0000
1121+ 0B2E 00                           defb    $00             ; reg.5: not used in text mode
1122+ 0B2F 00                           defb    $00             ; reg.6: not used in text mode
1123+ 0B30 F5                           defb    $f5             ; reg.7: white text on light blue background
1124+ 0B31
1125+ 0B31              VDPMODESET1:    ; VDP register settings for a graphics 1 mode
1126+ 0B31 00                           defb    %00000000       ; reg.0: ext. video off
1127+ 0B32 C0                           defb    %11000000       ; reg.1: 16K Vram; video on, int off, graphics mode 1, sprite size 8x8, sprite magn. 0
1128+ 0B33 06                           defb    $06             ; reg.2: name table address: $1800
1129+ 0B34 80                           defb    $80             ; reg.3: color table address: $2000
1130+ 0B35 00                           defb    $00             ; reg.4: pattern table address: $0000
1131+ 0B36 36                           defb    $36             ; reg.5: sprite attr. table address: $1B00
1132+ 0B37 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1133+ 0B38 05                           defb    $05             ; reg.7: backdrop color (light blue)
1134+ 0B39
1135+ 0B39              VDPMODESET2:    ; VDP register settings for a graphics 2 mode
1136+ 0B39 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1137+ 0B3A C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1138+ 0B3B 06                           defb    $06             ; reg.2: name table addr.: $1800
1139+ 0B3C FF                           defb    $FF             ; reg.3: color table addr.: $2000
1140+ 0B3D 03                           defb    $03             ; reg.4: pattern table addr.: $0000
1141+ 0B3E 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1142+ 0B3F 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1143+ 0B40 05                           defb    $05             ; reg.7: backdrop color: light blue
1144+ 0B41
1145+ 0B41              VDPMODESETMC:   ; VDP register settings for a multicolor mode
1146+ 0B41 00                           defb    %00000000       ; reg.0: ext. video dis.
1147+ 0B42 CB                           defb    %11001011       ; reg.1: 16K VRAM, video on, INT off, multicolor mode, sprite size 8x8, sprite magn. 0
1148+ 0B43 02                           defb    $02             ; reg.2: name table addr.: $0800
1149+ 0B44 00                           defb    $00             ; reg.3: don't care
1150+ 0B45 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1151+ 0B46 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1152+ 0B47 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1153+ 0B48 0F                           defb    $0F             ; reg.7: backdrop color (white)
1154+ 0B49
1155+ 0B49              VDPMODESETEX2:  ; VDP register settings for an extended graphics 2 mode
1156+ 0B49 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1157+ 0B4A C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1158+ 0B4B 0E                           defb    $0E             ; reg.2: name table addr.: $3800
1159+ 0B4C 9F                           defb    $9F             ; reg.3: color table addr.: $2000
1160+ 0B4D 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1161+ 0B4E 76                           defb    $76             ; reg.5: sprite attr. table addr.: $3B00
1162+ 0B4F 03                           defb    $03             ; reg.6: sprite pattern table addr.: $1800
1163+ 0B50 05                           defb    $05             ; reg.7: backdrop color: light blue
1164+ 0B51
1165+ 0B51              LM80CLOGO:      ; patterns to compose the splash screen logo
1166+ 0B51                              ; 1st band
1167+ 0B51 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1167+ 0B55 00 00 00 00
1167+ 0B59 00 00 00 00
1167+ 0B5D 00 00 00 00
1167+ 0B61 00 00 00 00
1167+ 0B65 00 00 00 00
1167+ 0B69 00 00 00 00
1167+ 0B6D 00 00 00 00
1168+ 0B71 00 00 0F 0A                  defb    0,0,15,10,11,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1168+ 0B75 0B 10 00 00
1168+ 0B79 00 00 00 00
1168+ 0B7D 00 00 00 00
1168+ 0B81 00 00 00 00
1168+ 0B85 00 00 00 00
1168+ 0B89 00 00 00 00
1168+ 0B8D 00 00 00 00
1169+ 0B91                              ; 2nd band
1170+ 0B91 00 00 0D 17                  defb    0,0,13,23,0,12,0,0,0,1,0,0,0,20,0,0,6,5,6,21,22,7,6,21,22,7,6,1,1,7,0,0
1170+ 0B95 00 0C 00 00
1170+ 0B99 00 01 00 00
1170+ 0B9D 00 14 00 00
1170+ 0BA1 06 05 06 15
1170+ 0BA5 16 07 06 15
1170+ 0BA9 16 07 06 01
1170+ 0BAD 01 07 00 00
1171+ 0BB1 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,20,6,1,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1171+ 0BB5 00 0C 00 00
1171+ 0BB9 00 01 00 00
1171+ 0BBD 00 01 14 06
1171+ 0BC1 01 05 03 05
1171+ 0BC5 03 05 03 05
1171+ 0BC9 03 05 03 05
1171+ 0BCD 03 05 00 00
1172+ 0BD1                              ; 3rd band
1173+ 0BD1 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,1,1,1,5,9,20,19,8,3,5,19,5,3,5,0,0,0,0
1173+ 0BD5 00 0C 00 00
1173+ 0BD9 00 01 00 00
1173+ 0BDD 00 01 01 01
1173+ 0BE1 01 05 09 14
1173+ 0BE5 13 08 03 05
1173+ 0BE9 13 05 03 05
1173+ 0BED 00 00 00 00
1174+ 0BF1 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,8,3,5,6,21,22,7,3,1,22,5,3,5,0,0,0,0
1174+ 0BF5 00 0C 00 00
1174+ 0BF9 00 01 00 00
1174+ 0BFD 00 01 00 08
1174+ 0C01 03 05 06 15
1174+ 0C05 16 07 03 01
1174+ 0C09 16 05 03 05
1174+ 0C0D 00 00 00 00
1175+ 0C11                              ; 4th band
1176+ 0C11 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,0,3,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1176+ 0C15 00 0C 00 00
1176+ 0C19 00 01 00 00
1176+ 0C1D 00 01 00 00
1176+ 0C21 03 05 03 05
1176+ 0C25 03 05 03 05
1176+ 0C29 03 05 03 05
1176+ 0C2D 03 05 00 00
1177+ 0C31 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,4,4,0,1,0,0,3,5,9,20,19,8,9,20,19,8,9,1,1,8,0,0
1177+ 0C35 00 0C 00 00
1177+ 0C39 00 01 04 04
1177+ 0C3D 00 01 00 00
1177+ 0C41 03 05 09 14
1177+ 0C45 13 08 09 14
1177+ 0C49 13 08 09 01
1177+ 0C4D 01 08 00 00
1178+ 0C51                              ; 5th band
1179+ 0C51 00 00 0E 12                  defb    0,0,14,18,18,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1179+ 0C55 12 11 00 00
1179+ 0C59 00 00 00 00
1179+ 0C5D 00 00 00 00
1179+ 0C61 00 00 00 00
1179+ 0C65 00 00 00 00
1179+ 0C69 00 00 00 00
1179+ 0C6D 00 00 00 00
1180+ 0C71 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1180+ 0C75 00 00 00 00
1180+ 0C79 00 00 00 00
1180+ 0C7D 00 00 00 00
1180+ 0C81 00 00 00 00
1180+ 0C85 00 00 00 00
1180+ 0C89 00 00 00 00
1180+ 0C8D 00 00 00 00
# file closed: ../include/vdp/vdp-1.08.asm
  70  0C91
  71  0C91              ; incude the latest version of the PSG module
  72  0C91                  INCLUDE "../include/psg/psg-1.02.asm"
# file opened: ../include/psg/psg-1.02.asm
   1+ 0C91              ; ------------------------------------------------------------------------------
   2+ 0C91              ; LM80C - PSG ROUTINES - 1.02
   3+ 0C91              ; ------------------------------------------------------------------------------
   4+ 0C91              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0C91              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0C91              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0C91              ; kind of warranty: you can use them at your own risk.
   8+ 0C91              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0C91              ; maintain the copyright notices, include this advice and the note to the
  10+ 0C91              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0C91              ; redistribuite them.
  12+ 0C91              ; https://www.leonardomiliani.com
  13+ 0C91              ;
  14+ 0C91              ; Please support me by visiting the following links:
  15+ 0C91              ; Main project page: https://www.leonardomiliani.com
  16+ 0C91              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0C91              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0C91              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0C91              ; ------------------------------------------------------------------------------
  20+ 0C91              ;
  21+ 0C91              ; ------------------------------------------------------------------------------
  22+ 0C91
  23+ 0C91              ;------------------------------------------------------------------------------
  24+ 0C91
  25+ 0C91              ; configure the PSG
  26+ 0C91 21 D9 55     initPSG:        ld      HL,CHASNDDTN    ; starting address of sound & keyboard RAM registers
  27+ 0C94 06 0E                        ld      B,SERIALS_EN-CHASNDDTN; # of PSG sound & keyboard registers
  28+ 0C96 AF                           xor     A               ; reset A
  29+ 0C97 77           EMPTSNDBFR:     ld      (HL),A          ; reset RAM register
  30+ 0C98 23                           inc     HL              ; next register
  31+ 0C99 10 FC                        djnz    EMPTSNDBFR      ; repeat
  32+ 0C9B 06 10        CLRPSGREGS:     ld      B,$10           ; 16 registers to set
  33+ 0C9D 21 AF 0C                     ld      HL,SNDREGCFG    ; starting address of register settings
  34+ 0CA0 16 00                        ld      D,$00           ; first register
  35+ 0CA2 7A           RSTPSG:         ld      A,D             ; register value
  36+ 0CA3 CD E9 0C                     call    SETSNDREG       ; select register
  37+ 0CA6 7E                           ld      A,(HL)          ; load value
  38+ 0CA7 CD EE 0C                     call    WRTSNDREG       ; write to register
  39+ 0CAA 14                           inc     D               ; next register
  40+ 0CAB 23                           inc     HL              ; next value
  41+ 0CAC 10 F4                        djnz    RSTPSG          ; repeat for each register
  42+ 0CAE C9                           ret                     ; return to caller
  43+ 0CAF
  44+ 0CAF 00 00 00 00  SNDREGCFG:      defb $00,$00,$00,$00,$00,$00,$00,%10111111
  44+ 0CB3 00 00 00 BF
  45+ 0CB7 00 00 00 00                  defb $00,$00,$00,$00,$00,$00,$ff,$ff
  45+ 0CBB 00 00 FF FF
  46+ 0CBF                              ; reg. 7: set I/O ch.A to OUTPUT, I/O ch.B to INPUT; set noise to OFF; set audio to OFF
  47+ 0CBF
  48+ 0CBF
  49+ 0CBF              ; routine to play a welcome beep on channel C (tone 4010) and to shut it off
  50+ 0CBF 21 D9 0C     WLCMBEEP:       ld      HL,WLCBPDAT     ; data address
  51+ 0CC2 C3 C8 0C                     jp      SENDSND
  52+ 0CC5 21 E1 0C     NOBEEP:         ld      HL,NOBPDAT      ; data address
  53+ 0CC8 C5           SENDSND:        push    BC
  54+ 0CC9 06 04                        ld      B,$04           ; 4 pairs
  55+ 0CCB 7E           RPTWLCMBP:      ld      A,(HL)          ; read register #
  56+ 0CCC CD E9 0C                     call    SETSNDREG
  57+ 0CCF 23                           inc     HL              ; next cell
  58+ 0CD0 7E                           ld      A,(HL)          ; read value
  59+ 0CD1 CD EE 0C                     call    WRTSNDREG
  60+ 0CD4 23                           inc     HL
  61+ 0CD5 10 F4                        djnz    RPTWLCMBP       ; repeat
  62+ 0CD7 C1                           pop     BC
  63+ 0CD8 C9                           ret                     ; return to caller
  64+ 0CD9
  65+ 0CD9 07 BB 04 56  WLCBPDAT:       defb    $07,%10111011,$04,$56,$05,$00,$0A,$0F
  65+ 0CDD 05 00 0A 0F
  66+ 0CE1 04 00 05 00  NOBPDAT:        defb    $04,$00,$05,$00,$0A,$00,$07,%10111111
  66+ 0CE5 0A 00 07 BF
  67+ 0CE9
  68+ 0CE9
  69+ 0CE9              ; select register on PSG
  70+ 0CE9 0E 40        SETSNDREG:      ld      C,PSG_REG       ; PSG register port
  71+ 0CEB ED 79                        out     (C),A           ; set register
  72+ 0CED C9                           ret                     ; return to caller
  73+ 0CEE
  74+ 0CEE              ; send data to PSG
  75+ 0CEE 0E 41        WRTSNDREG:      ld      C,PSG_DAT       ; PSG data port
  76+ 0CF0 ED 79                        out     (C),A           ; send data
  77+ 0CF2 C9                           ret                     ; return to caller
  78+ 0CF3
  79+ 0CF3              ; manage the sounds' duration: each time this subroutine is called, it
  80+ 0CF3              ; decrements the single sound durations (measured in ms) and eventually
  81+ 0CF3              ; shut off the audio channel whose counter has reached 0.
  82+ 0CF3              ; (this sub-routine is called by CH3 timer ISR)
  83+ 0CF3 DD E5        MNGSNDS:        push    IX              ; store IX
  84+ 0CF5 DD 21 D9 55                  ld      IX,CHASNDDTN    ; starting address of tones duration
  85+ 0CF9 06 03                        ld      B,$03           ; 3 channels to check
  86+ 0CFB 26 01                        ld      H,$01           ; mixer channels: A=>bit 1, B=>bit 2, C=>bit 3
  87+ 0CFD DD 5E 00     CHKSNDCH:       ld      E,(IX+0)        ; load LSB into E
  88+ 0D00 DD 56 01                     ld      D,(IX+1)        ; load MSB into D
  89+ 0D03 7B                           ld      A,E             ; load E into A
  90+ 0D04 B2                           or      D               ; check that DE=0
  91+ 0D05 28 31                        jr      Z,CNTCHKSND     ; yes, jump over
  92+ 0D07 1B                           dec     DE              ; no, so decrement DE
  93+ 0D08 7B                           ld      A,E             ; reload E into A...
  94+ 0D09 DD 73 00                     ld      (IX+0),E        ; store new...
  95+ 0D0C DD 72 01                     ld      (IX+1),D        ; ...duration and...
  96+ 0D0F B2                           or      D               ; ...do another check to see if DE=0
  97+ 0D10 20 26                        jr      NZ,CNTCHKSND    ; no, so jump over
  98+ 0D12                                                      ; if yes, let's shut down the corresponding channel
  99+ 0D12                                                      ; to shut down a tone we disable it into the mixer
 100+ 0D12                                                      ; then set 0 into its tone registers
 101+ 0D12 16 07                        ld      D,$07           ; mixer register
 102+ 0D14 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 103+ 0D16 ED 51                        out     (C),D           ; set mixer register
 104+ 0D18 ED 78                        in      A,(C)           ; load current value
 105+ 0D1A B4                           or      H               ; set off the channel into the mixer (remember that 1=OFF)
 106+ 0D1B ED 51                        out     (C),D           ; select mixer register
 107+ 0D1D 0E 41                        ld      C,PSG_DAT       ; PSG data port
 108+ 0D1F ED 79                        out     (C),A           ; send new value for the mixer
 109+ 0D21 3E 03                        ld      A,$03           ; three channels
 110+ 0D23 90                           sub     B               ; find current channel (0->A, 1->B, 2->C)
 111+ 0D24 87                           add     A,A             ; and find first register (A=>0, B=>2, C=>4)
 112+ 0D25 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 113+ 0D27 ED 79                        out     (C),A           ; select first tone register of channel
 114+ 0D29 2E 00                        ld      L,$00           ; value 0 into L
 115+ 0D2B 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 116+ 0D2D ED 69                        out     (C),L           ; write 0 into register
 117+ 0D2F 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 118+ 0D31 3C                           inc     A               ; next tone register
 119+ 0D32 ED 79                        out     (C),A           ; select second tone register of channel
 120+ 0D34 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 121+ 0D36 ED 69                        out     (C),L           ; write 0 into register
 122+ 0D38 DD 23        CNTCHKSND:      inc     IX              ; set for...
 123+ 0D3A DD 23                        inc     IX              ; ...next channel...
 124+ 0D3C CB 24                        sla     H               ; shift left H 1 bit
 125+ 0D3E 10 BD                        djnz    CHKSNDCH        ; repeat for 3 channels
 126+ 0D40 DD E1                        pop     IX              ; restore IX
 127+ 0D42 C9                           ret                     ; return to caller
 128+ 0D43
 129+ 0D43              ; read a specific row of the keyboard matrix, set by A
 130+ 0D43              ; return read into A
 131+ 0D43 C5           READKBLN:       push    BC              ; store BC
 132+ 0D44 06 0F                        ld      B,$0F           ; reg #15
 133+ 0D46 0E 40                        ld      C,PSG_REG       ; PSG register port
 134+ 0D48 ED 41                        out     (C),B           ; select reg #15
 135+ 0D4A 0E 41                        ld      C,PSG_DAT       ; PSG data port
 136+ 0D4C ED 79                        out     (C),A           ; activate the row
 137+ 0D4E 06 0E                        ld      B,$0E           ; register #14 (port B)
 138+ 0D50 0E 40                        ld      C,PSG_REG       ; PSG register port
 139+ 0D52 ED 41                        out     (C),B           ; select reg. 14 (port B)
 140+ 0D54 ED 78                        in      A,(C)           ; read register #14
 141+ 0D56 C1                           pop     BC              ; retrieve BC
 142+ 0D57 C9                           ret
 143+ 0D58
 144+ 0D58              ; read the keyboard matrix to look for a key pressure
 145+ 0D58 0E 40        KEYBOARD:       ld      C,PSG_REG       ; PSG register port
 146+ 0D5A 06 07                        ld      B,$07           ; set register #7...
 147+ 0D5C ED 41                        out     (C),B           ; ...to work with
 148+ 0D5E ED 78                        in      A,(C)           ; read register #7
 149+ 0D60 CB FF                        set     7,A             ; port A set to output
 150+ 0D62 CB B7                        res     6,A             ; port B set to input
 151+ 0D64 ED 41                        out     (C),B           ; set register #7
 152+ 0D66 0E 41                        ld      C,PSG_DAT       ; PSG data port
 153+ 0D68 ED 79                        out     (C),A           ; set I/O ports w/o altering the rest of the mixer
 154+ 0D6A                              ; check for reset combination
 155+ 0D6A 3E FE                        ld      A,%11111110     ; first line of keyboard matrix
 156+ 0D6C CD 43 0D                     call    READKBLN
 157+ 0D6F FE DB                        cp      %11011011       ; are C= and CTRL pressed?
 158+ 0D71 20 29                        jr      NZ,CHKSPCKS     ; no, jump over
 159+ 0D73 3E FE        NOMRPRSS:       ld      A,%11111110     ; wait until the user...
 160+ 0D75 CD 43 0D                     call    READKBLN        ; ...releases the key combination...
 161+ 0D78 FE DB                        cp      %11011011       ; ...to avoid multiple...
 162+ 0D7A 28 F7                        jr      Z,NOMRPRSS      ; ...calls of this code
 163+ 0D7C CD 91 0C                     call    initPSG         ; reset sounds
 164+ 0D7F 1E 01                        ld      E,$01           ; flag for soft reset and graphic mode 1
 165+ 0D81 CD 35 41                     call    RESET2          ; reset serials, close seq. files and put disk into standby
 166+ 0D84 CD D1 03                     call    initVDP         ; set video mode
 167+ 0D87 CD 98 19                     call    RUNFST          ; clear BASIC pointers
 168+ 0D8A E1                           pop     HL              ; remove HL from stack (put by RUNFST routine)
 169+ 0D8B CC 2D 09                     call    Z,CURSOR_ON     ; enable cursor
 170+ 0D8E 3E 01                        ld      A,$01           ; activate the...
 171+ 0D90 32 A1 55                     ld      (PRNTVIDEO),A   ; ...video buffer...
 172+ 0D93 DD 21 B0 18                  ld      IX,PRNTOK       ; set return address
 173+ 0D97 DD E5                        push    IX              ; store into stack
 174+ 0D99 FB                           ei                      ; re-enable INTs
 175+ 0D9A ED 4D                        reti                    ; return from ISR and go to BASIC prompt
 176+ 0D9C                              ; check special keys (SHIFT/ALT/CTRL)
 177+ 0D9C 3E FD        CHKSPCKS:       ld      A,%11111101     ; select SHIFT row
 178+ 0D9E CD 43 0D                     call    READKBLN        ; read row
 179+ 0DA1 CB 5F                        bit     3,A             ; test if SHIFT key is pressed (4th bit is reset)
 180+ 0DA3 20 05                        jr      NZ,CHECKALT     ; no, so go on
 181+ 0DA5 21 E6 55                     ld      HL,CONTROLKEYS  ; control key flags
 182+ 0DA8 36 01                        ld      (HL),%00000001  ; set SHIFT flag, reset CTRL & ALT flags (currently multiply control keys are NOT supported)
 183+ 0DAA 3E FE        CHECKALT:       ld      A,%11111110     ; select ALT row
 184+ 0DAC CD 43 0D                     call    READKBLN        ; read ALT row
 185+ 0DAF CB 6F                        bit     5,A             ; test if ALT key is pressed (5th bit is reset)
 186+ 0DB1 20 05                        jr      NZ,CHECKCTRL    ; no, so go on
 187+ 0DB3 21 E6 55                     ld      HL,CONTROLKEYS  ; control key flags
 188+ 0DB6 36 04                        ld      (HL),%00000100  ; set ALT flag, reset SHIFT & CTRL flag (currently multiply control keys are NOT supported)
 189+ 0DB8 3E FE        CHECKCTRL:      ld      A,%11111110     ; select CTRL row
 190+ 0DBA CD 43 0D                     call    READKBLN        ; read CTRL row
 191+ 0DBD CB 57                        bit     2,A             ; test if CTRL key is pressed (3rd bit is reset)
 192+ 0DBF 20 05                        jr      NZ,CHECKKBD     ; no, so make a normal reading
 193+ 0DC1 21 E6 55                     ld      HL,CONTROLKEYS  ; control key flags
 194+ 0DC4 36 02                        ld      (HL),%00000010  ; set CTRL flag, reset SHIFT & ALT flags (currently multiply control keys are NOT supported)
 195+ 0DC6 06 08        CHECKKBD:       ld      B,$08           ; 8 lines
 196+ 0DC8 3E 7F                        ld      A,%01111111     ; start from the last line of the matrix
 197+ 0DCA 16 0F        RPTKBDRD:       ld      D,$0F           ; register #15 (port B)
 198+ 0DCC 0E 40                        ld      C,PSG_REG       ; PSG register port
 199+ 0DCE ED 51                        out     (C),D           ; select reg. #15
 200+ 0DD0 0E 41                        ld      C,PSG_DAT       ; PSG data port
 201+ 0DD2 ED 79                        out     (C),A           ; activate 1 line (active line is grounded, i.e. with a LOW signal)
 202+ 0DD4 5F                           ld      E,A             ; save current line into E
 203+ 0DD5 16 0E                        ld      D,$0E           ; register #14 (port A)
 204+ 0DD7 0E 40                        ld      C,PSG_REG       ; PSG register port
 205+ 0DD9 ED 51                        out     (C),D           ; select reg. 14 (port A)
 206+ 0DDB 00                           nop
 207+ 0DDC ED 78                        in      A,(C)           ; read register #14
 208+ 0DDE FE FF                        cp      $FF             ; is there any line set to 0?
 209+ 0DE0 28 2E                        jr      Z,NOKEYPRSD     ; no, go to the next row
 210+ 0DE2                              ; check control keys
 211+ 0DE2 32 E0 55                     ld      (KBTMP),A       ; yes, check if a control key was pressed. First, store current row
 212+ 0DE5 78                           ld      A,B             ; copy current row (B) into A
 213+ 0DE6 FE 02                        cp      $02             ; is it the row of the SHIFT?
 214+ 0DE8 20 0F                        jr      NZ,TESTALT      ; no, continue checking the other control keys
 215+ 0DEA 3A E0 55                     ld      A,(KBTMP)       ; yes, retrieve current row data
 216+ 0DED CB 5F                        bit     3,A             ; check SHIFT bit line
 217+ 0DEF 20 31                        jr      NZ,FINDKEY      ; no SHIFT, continue checking
 218+ 0DF1 CB DF                        set     3,A             ; yes, it's the SHIFT. So remove SHIFT bit
 219+ 0DF3 FE FF                        cp      $FF             ; after deleting the SHIFT bit, is there any other bit selected?
 220+ 0DF5 20 2B                        jr      NZ,FINDKEY      ; yes, go to check which one
 221+ 0DF7 18 17                        jr      NOKEYPRSD       ; no, go to next row
 222+ 0DF9 FE 01        TESTALT:        cp      $01             ; is it the line of ALT & CTRL?
 223+ 0DFB 3A E0 55                     ld      A,(KBTMP)       ; retrieve current row data
 224+ 0DFE 20 22                        jr      NZ,FINDKEY      ; no, continue
 225+ 0E00 CB 6F                        bit     5,A             ; yes, check ALT bit line
 226+ 0E02 20 02                        jr      NZ,TESTCTRL     ; no ALT, continue checking
 227+ 0E04 CB EF                        set     5,A             ; yes, it's the ALT. So remove ALT bit
 228+ 0E06 CB 57        TESTCTRL:       bit     2,A             ; check CTRL bit line
 229+ 0E08 20 02                        jr      NZ,ENDCTRLCK    ; no CTRL, continue checking
 230+ 0E0A CB D7                        set     2,A             ; delete CTRL bit flag
 231+ 0E0C FE FF        ENDCTRLCK:      cp      $FF             ; after deleting the ALT & CTRL bits, is there any other bit selected?
 232+ 0E0E 20 12                        jr      NZ,FINDKEY      ; yes, go to check which one
 233+ 0E10 7B           NOKEYPRSD:      ld      A,E             ; no key pressed, load current output port
 234+ 0E11 0F                           rrca                    ; rotate right by 1
 235+ 0E12 10 B6                        djnz    RPTKBDRD        ; repeat for 8 lines
 236+ 0E14 AF                           xor     A               ; if exit from here, no key has been pressed...
 237+ 0E15 32 E2 55                     ld      (LASTKEYPRSD),A ; ...so reset the last key cell...
 238+ 0E18 32 E6 55                     ld      (CONTROLKEYS),A ; ...reset contro key flags...
 239+ 0E1B 32 DF 55                     ld      (KBDNPT),A      ; ...no input from keyboard...
 240+ 0E1E 32 E3 55                     ld      (STATUSKEY),A   ; ...no auto-repeat...
 241+ 0E21 C9                           ret                     ; ...and leave
 242+ 0E22 1E FF        FINDKEY:        ld      E,$FF           ; counter
 243+ 0E24 1C           CHKLN:          inc     E               ; E goes from 0 to 7
 244+ 0E25 CB 3F                        srl     A               ; is the first bit reset? (we're looking for a "0", meaning grounded line)
 245+ 0E27 38 FB                        jr      C,CHKLN         ; no, check next bit
 246+ 0E29 3A E6 55                     ld      A,(CONTROLKEYS) ; load control key flags
 247+ 0E2C 21 45 0F                     ld      HL,KBMAP        ; normal keymap
 248+ 0E2F FE 01                        cp      $01             ; SHIFT flag?
 249+ 0E31 20 05                        jr      NZ,CHKCTRL      ; no, jump over
 250+ 0E33 21 85 0F                     ld      HL,KBMAP_SFT    ; SHIFT keymap
 251+ 0E36 18 10                        jr      LOADMAP         ; and load it
 252+ 0E38 FE 02        CHKCTRL:        cp      $02             ; CTRL flag?
 253+ 0E3A 20 05                        jr      NZ,CHKALT       ; no, jump over
 254+ 0E3C 21 05 10                     ld      HL,KBMAP_CTRL   ; CTRL map
 255+ 0E3F 18 07                        jr      LOADMAP         ; and load it
 256+ 0E41 FE 04        CHKALT:         cp      $04             ; ALT flag?
 257+ 0E43 20 03                        jr      NZ,LOADMAP      ; no, check over
 258+ 0E45 21 C5 0F                     ld      HL,KBMAP_ALT    ; ALT map
 259+ 0E48 05           LOADMAP:        dec     B               ; decrement row # (rows go from 0 to 7)
 260+ 0E49 48                           ld      C,B             ; move B into C and...
 261+ 0E4A CB 21                        sla     C               ; ...multiply it...
 262+ 0E4C CB 21                        sla     C               ; ...by 8 to find...
 263+ 0E4E CB 21                        sla     C               ; ...the current row into the matrix
 264+ 0E50 06 00                        ld      B,$00           ; reset B
 265+ 0E52 09                           add     HL,BC           ; find the address of the current row
 266+ 0E53 50                           ld      D,B             ; reset D
 267+ 0E54 19                           add     HL,DE           ; find the current column - now (HL) stores the pressed key
 268+ 0E55 3A E2 55                     ld      A,(LASTKEYPRSD) ; load the last key pressed
 269+ 0E58 BE                           cp      (HL)            ; is it the same key?
 270+ 0E59 20 41                        jr      NZ,NEWKEY       ; no, it's a new key
 271+ 0E5B 44 4D                        ld      BC,HL           ; store address of current keycode
 272+ 0E5D 2A 85 55                     ld      HL,(TMRCNT)     ; load current system timer
 273+ 0E60 ED 5B E4 55                  ld      DE,(KEYTMR)     ; load auto-repeat timer
 274+ 0E64 3A E3 55                     ld      A,(STATUSKEY)   ; yes, load current status of auto-repeat
 275+ 0E67 FE 01                        cp      $01             ; is it initial pressure?
 276+ 0E69 20 1F                        jr      NZ,CHKAUTO      ; no, jump over
 277+ 0E6B AF                           xor     A               ; clear Carry
 278+ 0E6C ED 52                        sbc     HL,DE           ; startint time - actual time
 279+ 0E6E 16 00                        ld      D,$00           ; 64 ths/s > 640 ms
 280+ 0E70 3A 56 54                     ld      A,(KEYDEL)
 281+ 0E73 5F                           ld      E,A
 282+ 0E74 CD 61 41                     call    CMP16           ; time elapsed is >= $40?
 283+ 0E77 DA EC 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 284+ 0E7A 3E 02        SETNEWAUTO:     ld      A,$02           ; yes set status to...
 285+ 0E7C 32 E3 55                     ld      (STATUSKEY),A   ; ...auto-repeat
 286+ 0E7F 2A 85 55                     ld      HL,(TMRCNT)     ; load system timer
 287+ 0E82 22 E4 55                     ld      (KEYTMR),HL     ; store starting time
 288+ 0E85 60 69                        ld      HL,BC           ; retrieve address of current keycode
 289+ 0E87 C3 A9 0E                     jp      SENDKEY         ; send key
 290+ 0E8A AF           CHKAUTO:        xor     A               ; clear Carry
 291+ 0E8B ED 52                        sbc     HL,DE           ; computer interval between initial pressure of key and current time
 292+ 0E8D 16 00                        ld      D,$00
 293+ 0E8F 3A 57 54                     ld      A,(AUTOKE)
 294+ 0E92 5F                           ld      E,A             ; auto-repeat delay into DE
 295+ 0E93 CD 61 41                     call    CMP16           ; check if interval is greater than delay
 296+ 0E96 DA EC 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 297+ 0E99 C3 7A 0E                     jp      SETNEWAUTO      ; set new loop and send key
 298+ 0E9C AF           NEWKEY:         xor     A               ; set initial state...
 299+ 0E9D 3C                           inc     A               ; ...for auto-repeat...
 300+ 0E9E 32 E3 55                     ld      (STATUSKEY),A   ; ...1=pressure init
 301+ 0EA1 ED 4B 85 55                  ld      BC,(TMRCNT)     ; load current system timer
 302+ 0EA5 ED 43 E4 55                  ld      (KEYTMR),BC     ; set starting time
 303+ 0EA9 7E           SENDKEY:        ld      A,(HL)          ; then, load key...
 304+ 0EAA 32 E2 55                     ld      (LASTKEYPRSD),A ; ...store it...
 305+ 0EAD 32 E1 55                     ld      (TMPKEYBFR),A   ; ...insert it into the INKEY buffer...
 306+ 0EB0 32 A2 55                     ld      (CHR4VID),A     ; ...and store char for video
 307+ 0EB3 FE 03                        cp      CTRLC           ; is it RUN/STOP?
 308+ 0EB5 20 05                        jr      NZ,CNTKBCK      ; no, jump over
 309+ 0EB7 CD FD 01                     call    CHARINTOBFR     ; yes, send directly to buffer and...
 310+ 0EBA 18 30                        jr      LVKBRDCHK2      ; ...leave
 311+ 0EBC 01 00 08     CNTKBCK:        ld      BC,$0800        ; 8 FN keys (B), FN key number (C)
 312+ 0EBF 21 3D 0F                     ld      HL,FNKEYSORD    ; FN keys codes
 313+ 0EC2 BE           CHKFNK:         cp      (HL)            ; is it an FN key?
 314+ 0EC3 CA F1 0E                     jp      Z,PRNTFNKEY     ; yes, jump over
 315+ 0EC6 0C                           inc     C               ; next FN key
 316+ 0EC7 23                           inc     HL              ; next FN key code
 317+ 0EC8 10 F8                        djnz    CHKFNK          ; continue for 8 FN keys
 318+ 0ECA 3E 01        SNDKEYTOBFR:    ld      A,$01           ; normal key - set input flag
 319+ 0ECC 32 DF 55                     ld      (KBDNPT),A      ; to keyboard
 320+ 0ECF 3A A1 55                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 321+ 0ED2 B7                           or      A               ; is the print-on-video disabled?
 322+ 0ED3 CA DC 0E                     jp      Z,PUTCHRBUF     ; yes, so send char to input buffer
 323+ 0ED6 3A 9F 55                     ld      A,(CRSR_STATE)  ; check cursor state
 324+ 0ED9 B7                           or      A               ; is it 0 (cursor OFF)?
 325+ 0EDA 20 0D                        jr      NZ,PNT2VD       ; no, print on screen
 326+ 0EDC AF           PUTCHRBUF:      xor     A
 327+ 0EDD 32 DF 55                     ld      (KBDNPT),A      ; if send to input buffer, set RETURN as from BASIC
 328+ 0EE0 3A E1 55                     ld      A,(TMPKEYBFR)   ; retrieve char
 329+ 0EE3 CD FD 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 330+ 0EE6 C3 EC 0E                     jp      LVKBRDCHK2      ; ...and leave
 331+ 0EE9 CD 61 07     PNT2VD:         call    CHAR2VID        ; send char to video
 332+ 0EEC AF           LVKBRDCHK2:     xor     A
 333+ 0EED 32 E6 55                     ld      (CONTROLKEYS),A ; reset control key flags
 334+ 0EF0 C9                           ret                     ; return to caller: the current key code is into TMPKEYBFR
 335+ 0EF1                              ; manage FN keys
 336+ 0EF1 57           PRNTFNKEY:      ld      D,A             ; copy A into D
 337+ 0EF2 2A 52 54                     ld      HL,(LINEAT)     ; Get current line number
 338+ 0EF5 23                           inc     HL              ; -1 means direct statement
 339+ 0EF6 7C                           ld      A,H
 340+ 0EF7 B5                           or      L
 341+ 0EF8 7A                           ld      A,D             ; retrieve char
 342+ 0EF9 20 CF                        jr      NZ,SNDKEYTOBFR  ; indirect mode - just send FN key code to buffer
 343+ 0EFB 79                           ld      A,C             ; direct mode, so print text - first, get FN key number
 344+ 0EFC 87                           add     A,A
 345+ 0EFD 87                           add     A,A
 346+ 0EFE 87                           add     A,A
 347+ 0EFF 87                           add     A,A             ; FN key number * 16
 348+ 0F00 4F                           ld      C,A             ; move it into C
 349+ 0F01 06 00                        ld      B,$00           ; reset B, to get offset
 350+ 0F03 21 58 54                     ld      HL,FNKEYS       ; load address of FN keys texts
 351+ 0F06 09                           add     HL,BC           ; get correct text address
 352+ 0F07 06 10                        ld      B,$10           ; 16 chars
 353+ 0F09 7E           LDFNKEYCHR:     ld      A,(HL)          ; load char
 354+ 0F0A A7                           and     A               ; null char?
 355+ 0F0B CA EC 0E                     jp      Z,LVKBRDCHK2    ; yes, so leave
 356+ 0F0E 57                           ld      D,A             ; pass char into D
 357+ 0F0F 3A A1 55                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 358+ 0F12 B7                           or      A               ; is the print-on-video disabled?
 359+ 0F13 CA 23 0F                     jp      Z,PUTCHRBUF1    ; yes, so send char to input buffer
 360+ 0F16 3A 9F 55                     ld      A,(CRSR_STATE)  ; check cursor state
 361+ 0F19 B7                           or      A               ; is it 0 (cursor OFF)?
 362+ 0F1A C4 30 0F                     call    NZ,PRNTFNK      ; no, print on screen
 363+ 0F1D 23           CNTFNK:         inc     HL              ; next char
 364+ 0F1E 10 E9                        djnz    LDFNKEYCHR      ; repeat for max. 16 chars
 365+ 0F20 C3 EC 0E                     jp      LVKBRDCHK2      ; leave
 366+ 0F23 AF           PUTCHRBUF1:     xor     A               ; if send to input buffer,...
 367+ 0F24 32 DF 55                     ld      (KBDNPT),A      ; ...set input as from BASIC
 368+ 0F27 7A                           ld      A,D             ; retrieve char
 369+ 0F28 E5                           push    HL              ; store HL
 370+ 0F29 CD FD 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 371+ 0F2C E1                           pop     HL              ; retrieve HL
 372+ 0F2D C3 1D 0F                     jp      CNTFNK          ; repeat
 373+ 0F30 7A           PRNTFNK:        ld      A,D             ; recover char
 374+ 0F31 32 A2 55                     ld      (CHR4VID),A     ; store char for printing
 375+ 0F34 3E 01                        ld      A,$01           ; normal key - set input flag
 376+ 0F36 32 DF 55                     ld      (KBDNPT),A      ; to keyboard
 377+ 0F39 CD 61 07                     call    CHAR2VID        ; print on screen
 378+ 0F3C C9                           ret                     ; return to caller
 379+ 0F3D
 380+ 0F3D
 381+ 0F3D              ;-----------------------------------------------------------------------
 382+ 0F3D 01 02 04 05  FNKEYSORD:      defb 1,2,4,5,6,22,23,24                 ; order of FN Keys
 382+ 0F41 06 16 17 18
 383+ 0F45              ;-----------------------------------------------------------------------
 384+ 0F45              ; key codes
 385+ 0F45 31 19 0E 03  KBMAP:          defb '1',25,14,3,' ',16,'q','2'         ; 25=HOME  14=CTRL  3=RUN/STOP 16=C=
 385+ 0F49 20 10 71 32
 386+ 0F4D 33 77 61 14                  defb '3','w','a',20,'z','s','e','4'     ; 20=SHIFT
 386+ 0F51 7A 73 65 34
 387+ 0F55 35 72 64 78                  defb '5','r','d','x','c','f','t','6'
 387+ 0F59 63 66 74 36
 388+ 0F5D 37 79 67 76                  defb '7','y','g','v','b','h','u','8'
 388+ 0F61 62 68 75 38
 389+ 0F65 39 69 6A 6E                  defb '9','i','j','n','m','k','o','0'
 389+ 0F69 6D 6B 6F 30
 390+ 0F6D 1F 70 6C 2C                  defb 31,'p','l',',','.',':','-',30      ; 31=CURSOR DOWN  30=CURSOR UP
 390+ 0F71 2E 3A 2D 1E
 391+ 0F75 1C 2A 3B 2F                  defb 28,'*',';','/',27,'=','+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 391+ 0F79 1B 3D 2B 1D
 392+ 0F7D 08 0D FC 40                  defb 8,13,252,'@',1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 392+ 0F81 01 02 04 18
 393+ 0F85
 394+ 0F85              ; shifted codes - not all the keys have the shifted version
 395+ 0F85 21 0C 0E 03  KBMAP_SFT:      defb '!',12,14,3,' ',16,'Q',34          ; 12=CLEAR  14=CTRL  3=RUN/STOP 16=C=   34="
 395+ 0F89 20 10 51 22
 396+ 0F8D 23 57 41 14                  defb '#','W','A',20,'Z','S','E','$'     ; 20=SHIFT
 396+ 0F91 5A 53 45 24
 397+ 0F95 25 52 44 58                  defb '%','R','D','X','C','F','T','&'
 397+ 0F99 43 46 54 26
 398+ 0F9D 27 59 47 56                  defb 39,'Y','G','V','B','H','U','('     ; 39='
 398+ 0FA1 42 48 55 28
 399+ 0FA5 29 49 4A 4E                  defb ')','I','J','N','M','K','O',94     ; 94=^
 399+ 0FA9 4D 4B 4F 5E
 400+ 0FAD 1F 50 4C 3C                  defb 31,'P','L','<','>','[','_',30      ; 31=CURSOR DOWN  30=CURSOR UP
 400+ 0FB1 3E 5B 5F 1E
 401+ 0FB5 1C 2A 5D 3F                  defb 28,'*',']','?',27,198,'+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 401+ 0FB9 1B C6 2B 1D
 402+ 0FBD 1A 0D D3 40                  defb 26,13,211,'@',5,6,22,23            ; 26=INSERT, 211=â¬  5=F4  6=F5  22=F6  23=F7
 402+ 0FC1 05 06 16 17
 403+ 0FC5
 404+ 0FC5              ; ALT (C=) codes - not all the keys have the alt-ed version
 405+ 0FC5 31 0C 0E 03  KBMAP_ALT:      defb '1',12,14,3,' ',16,222,196         ; 12=CLEAR  14=CTRL  3=RUN/STOP  16=C=  34="
 405+ 0FC9 20 10 DE C4
 406+ 0FCD 33 DD 85 14                  defb '3',221,133,20,131,130,165,'4'     ; 20=SHIFT
 406+ 0FD1 83 82 A5 34
 407+ 0FD5 35 A2 A6 84                  defb '5',162,166,132,157,163,168,'6'
 407+ 0FD9 9D A3 A8 36
 408+ 0FDD 37 AB A9 A1                  defb '7',171,169,161,158,172,213,'8'    ;
 408+ 0FE1 9E AC D5 38
 409+ 0FE5 39 D6 D8 9F                  defb '9',214,216,159,160,215,135,195    ;
 409+ 0FE9 A0 D7 87 C3
 410+ 0FED 1F 88 8A C1                  defb 31,136,138,193,192,123,144,30      ; 31=CURSOR DOWN  123={  30=CURSOR UP
 410+ 0FF1 C0 7B 90 1E
 411+ 0FF5 1C 8F 7D FE                  defb 28,143,125,254,27,209,148,29       ; 28=CURSOR LEFT  125=}  27=ESCAPE  29=CURSOR RIGHT
 411+ 0FF9 1B D1 94 1D
 412+ 0FFD 08 0D E0 89                  defb 8,13,224,137,5,6,22,23             ; 8=DEL(backspace)  13=RETURN  252=Â£  5=F4  6=F5  22=F6  23=F7
 412+ 1001 05 06 16 17
 413+ 1005
 414+ 1005              ; CTRL codes - not all the keys have the control-ed version
 415+ 1005 31 19 0E 03  KBMAP_CTRL:     defb '1',25,14,3,' ',16,154,'2'         ; 25=HOME  14=CTRL  3=RUN/STOP  16=C=
 415+ 1009 20 10 9A 32
 416+ 100D 33 9C 95 14                  defb '3',156,149,20,152,150,153,'4'     ; 20=SHIFT
 416+ 1011 98 96 99 34
 417+ 1015 35 9B B0 97                  defb '5',155,176,151,177,175,165,'6'
 417+ 1019 B1 AF A5 36
 418+ 101D 37 A6 A8 B2                  defb '7',166,168,178,179,169,167,'8'
 418+ 1021 B3 A9 A7 38
 419+ 1025 39 B8 AA AC                  defb '9',184,170,172,171,181,164,'0'
 419+ 1029 AB B5 A4 30
 420+ 102D 1F A3 AD 2C                  defb 31,163,173,',','.',':',186,30      ; 31=CURSOR DOWN  30=CURSOR UP
 420+ 1031 2E 3A BA 1E
 421+ 1035 1C E1 3B 2F                  defb 28,225,';','/',27,212,185,29       ; 28=CURSOR LEFT  27=ESCAPE  212=Ï  29=CURSOR RIGHT
 421+ 1039 1B D4 B9 1D
 422+ 103D 08 0D BD A2                  defb 8,13,189,162,1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 422+ 1041 01 02 04 18
# file closed: ../include/psg/psg-1.02.asm
  73  1045
  74  1045              ; include the latest version of the LM80C 64K BASIC interpreter
  75  1045                  INCLUDE "../include/basic/basic-1.14.asm"
# file opened: ../include/basic/basic-1.14.asm
   1+ 1045              ; ------------------------------------------------------------------------------
   2+ 1045              ; LM80C BASIC - R3.26
   3+ 1045              ; ------------------------------------------------------------------------------
   4+ 1045              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 1045              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 1045              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 1045              ; kind of warranty: you can use them at your own risk.
   8+ 1045              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 1045              ; maintain the copyright notices, include this advice and the note to the
  10+ 1045              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 1045              ; redistribuite them.
  12+ 1045              ; https://www.leonardomiliani.com
  13+ 1045              ;
  14+ 1045              ; Please support me by visiting the following links:
  15+ 1045              ; Main project page: https://www.leonardomiliani.com
  16+ 1045              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 1045              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 1045              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 1045              ; ------------------------------------------------------------------------------
  20+ 1045              ; LM80C BASIC 64K - originally based on the following NASCOM BASIC versions:
  21+ 1045              ; 4.7  - original version by NASCOM/MICROSOFT
  22+ 1045              ; 4.7b - modified version by Grant Searle (additional commands & functions)
  23+ 1045
  24+ 1045
  25+ 1045              ;------------------------------------------------------------------------------
  26+ 1045              ;  L M 8 0 C   B A S I C
  27+ 1045              ;------------------------------------------------------------------------------
  28+ 1045
  29+ 1045              ; GENERAL EQUATES
  30+ 1045
  31+ 1045              NLLCR           equ     $00             ; null char (used as space/empty char in video prints)
  32+ 1045              CTRLC           equ     $03             ; Control "C"
  33+ 1045              CTRLG           equ     $07             ; Control "G"
  34+ 1045              BKSP            equ     $08             ; Back space
  35+ 1045              LF              equ     $0A             ; Line feed
  36+ 1045              CS              equ     $0C             ; Clear screen
  37+ 1045              CR              equ     $0D             ; Carriage return
  38+ 1045              CTRLO           equ     $0F             ; Control "O"
  39+ 1045              CTRLQ           equ     $11             ; Control "Q"
  40+ 1045              CTRLR           equ     $12             ; Control "R"
  41+ 1045              CTRLS           equ     $13             ; Control "S"
  42+ 1045              CTRLU           equ     $15             ; Control "U"
  43+ 1045              HOME            equ     $19             ; Home (cursor at 0,0)
  44+ 1045              ESC             equ     $1B             ; Escape
  45+ 1045              SPC             equ     $20             ; Space
  46+ 1045              DEL             equ     $7F             ; Delete
  47+ 1045              INSRT           equ     $1A             ; Insert Key
  48+ 1045              ; cursor ASCII codes
  49+ 1045              CRSLFT          equ     $1C             ; cursor left
  50+ 1045              CRSRGT          equ     $1D             ; cursor right
  51+ 1045              CRSUP           equ     $1E             ; cursor up
  52+ 1045              CRSDN           equ     $1F             ; cursor down
  53+ 1045
  54+ 1045
  55+ 1045              ;-------------------------------------------------------------------------
  56+ 1045              ; BASIC ERROR MESSAGES
  57+ 1045              ; the interpreter looks for a single-byte code in the following list,
  58+ 1045              ; then loads the corresponding memory pointer in "ERRTBL" table to
  59+ 1045              ; find where to retrieve the message text in "ERRORS"
  60+ 1045
  61+ 1045              ; BASIC ERROR CODE VALUES
  62+ 1045              ; These values act as an offset to point to the error message into the error table
  63+ 1045              ; must be incremented by 2 because they point to a word address jump
  64+ 1045              NF      equ     $00     ; NEXT without FOR
  65+ 1045              SN      equ     $02     ; Syntax error
  66+ 1045              RG      equ     $04     ; RETURN without GOSUB
  67+ 1045              OD      equ     $06     ; Out of DATA
  68+ 1045              FC      equ     $08     ; Function call error
  69+ 1045              OV      equ     $0A     ; Overflow
  70+ 1045              OM      equ     $0C     ; Out of memory
  71+ 1045              UL      equ     $0E     ; Undefined line number
  72+ 1045              BS      equ     $10     ; Bad subscript
  73+ 1045              DD      equ     $12     ; Re-Dimensioned array
  74+ 1045              DZ      equ     $14     ; Division by zero (/0)
  75+ 1045              ID      equ     $16     ; Illegal direct
  76+ 1045              TM      equ     $18     ; Type mis-match
  77+ 1045              OS      equ     $1A     ; Out of string space
  78+ 1045              LS      equ     $1C     ; String too long
  79+ 1045              ST      equ     $1E     ; String formula too complex
  80+ 1045              CN      equ     $20     ; Can't continue
  81+ 1045              UF      equ     $22     ; Undefined FN function
  82+ 1045              MO      equ     $24     ; Missing operand
  83+ 1045              HE      equ     $26     ; HEX error
  84+ 1045              BN      equ     $28     ; BIN error
  85+ 1045              GM      equ     $2A     ; No Graphics Mode
  86+ 1045              SC      equ     $2C     ; Serial configuration
  87+ 1045              SA      equ     $2E     ; Serial port already open
  88+ 1045              SO      equ     $30     ; Serial buffer overrun
  89+ 1045              HP      equ     $32     ; HELP call
  90+ 1045              IM      equ     $34     ; Illegal indirect
  91+ 1045              NR      equ     $36     ; Device not ready
  92+ 1045              D0      equ     $38     ; File open/close error
  93+ 1045              D1      equ     $3A     ; Disk/File name error
  94+ 1045              D2      equ     $3C     ; Disk geometry error
  95+ 1045              D3      equ     $3E     ; Save error
  96+ 1045              D4      equ     $40     ; Load error
  97+ 1045              D5      equ     $42     ; Disk full error
  98+ 1045              D6      equ     $44     ; Duplicate file name error
  99+ 1045              D7      equ     $46     ; DOS version error
 100+ 1045              D8      equ     $48     ; File not found error
 101+ 1045              D9      equ     $4A     ; File already open
 102+ 1045              DA      equ     $4C     ; End of file
 103+ 1045
 104+ 1045
 105+ 1045              ; BASIC ERROR POINTER TABLE
 106+ 1045              ERRTBL: equ $
 107+ 1045 93 10        NFPTR:  defw    NFMSG
 108+ 1047 A4 10        SNPTR:  defw    SNMSG
 109+ 1049 AB 10        RGPTR:  defw    RGMSG
 110+ 104B C0 10        ODPTR:  defw    ODMSG
 111+ 104D CC 10        FCPTR:  defw    FCMSG
 112+ 104F E2 10        OVPTR:  defw    OVMSG
 113+ 1051 EB 10        OMPTR:  defw    OMMSG
 114+ 1053 F9 10        ULPTR:  defw    ULMSG
 115+ 1055 08 11        BSPTR:  defw    BSMSG
 116+ 1057 16 11        DDPTR:  defw    DDMSG
 117+ 1059 2B 11        DZPTR:  defw    DZMSG
 118+ 105B 3C 11        IDPTR:  defw    IDMSG
 119+ 105D 50 11        TMPTR:  defw    TMMSG
 120+ 105F 5F 11        OSPTR:  defw    OSMSG
 121+ 1061 73 11        LSPTR:  defw    LSMSG
 122+ 1063 83 11        STPTR:  defw    STMSG
 123+ 1065 9E 11        CNPTR:  defw    CNMSG
 124+ 1067 AD 11        UFPTR:  defw    UFMSG
 125+ 1069 C3 11        MOPTR:  defw    MOMSG
 126+ 106B D3 11        HEPTR:  defw    HEMSG
 127+ 106D DE 11        BNPTR:  defw    BNMSG
 128+ 106F E9 11        GMPRT:  defw    GMMSG
 129+ 1071 FA 11        SCPTR:  defw    SCMSG
 130+ 1073 0F 12        SAPTR:  defw    SAMSG
 131+ 1075 28 12        SOPTR:  defw    SOMSG
 132+ 1077 3E 12        HPPTR:  defw    HPMSG
 133+ 1079 48 12        IMPRT:  defw    IMMSG
 134+ 107B 5E 12        NRPRT:  defw    NRMSG
 135+ 107D 6F 12        D0PTR:  defw    D0MSG
 136+ 107F 7F 12        D1PRT:  defw    D1MSG
 137+ 1081 8B 12        D2PRT:  defw    D2MSG
 138+ 1083 99 12        D3PRT:  defw    D3MSG
 139+ 1085 9E 12        D4PTR:  defw    D4MSG
 140+ 1087 A3 12        D5PTR:  defw    D5MSG
 141+ 1089 AD 12        D6PTR:  defw    D6MSG
 142+ 108B C1 12        D7PRT:  defw    D7MSG
 143+ 108D CD 12        D8PTR:  defw    D8MSG
 144+ 108F DC 12        D9PTR:  defw    D9MSG
 145+ 1091 EE 12        DAPTR:  defw    DAMSG
 146+ 1093
 147+ 1093
 148+ 1093              ; BASIC ERROR MESSAGE LIST
 149+ 1093              ERRORS  equ $
 150+ 1093 4E 45 58 54  NFMSG:  defb    "NEXT Without FOR",0
 150+ 1097 20 57 69 74
 150+ 109B 68 6F 75 74
 150+ 109F 20 46 4F 52
 150+ 10A3 00
 151+ 10A4 53 79 6E 74  SNMSG:  defb    "Syntax",0
 151+ 10A8 61 78 00
 152+ 10AB 52 45 54 55  RGMSG:  defb    "RETURN without GOSUB",0
 152+ 10AF 52 4E 20 77
 152+ 10B3 69 74 68 6F
 152+ 10B7 75 74 20 47
 152+ 10BB 4F 53 55 42
 152+ 10BF 00
 153+ 10C0 4F 75 74 20  ODMSG:  defb    "Out of DATA",0
 153+ 10C4 6F 66 20 44
 153+ 10C8 41 54 41 00
 154+ 10CC 49 6C 6C 65  FCMSG:  defb    "Illegal Function Call",0
 154+ 10D0 67 61 6C 20
 154+ 10D4 46 75 6E 63
 154+ 10D8 74 69 6F 6E
 154+ 10DC 20 43 61 6C
 154+ 10E0 6C 00
 155+ 10E2 4F 76 65 72  OVMSG:  defb    "Overflow",0
 155+ 10E6 66 6C 6F 77
 155+ 10EA 00
 156+ 10EB 4F 75 74 20  OMMSG:  defb    "Out of Memory",0
 156+ 10EF 6F 66 20 4D
 156+ 10F3 65 6D 6F 72
 156+ 10F7 79 00
 157+ 10F9 55 6E 64 65  ULMSG:  defb    "Undefined Line",0
 157+ 10FD 66 69 6E 65
 157+ 1101 64 20 4C 69
 157+ 1105 6E 65 00
 158+ 1108 42 61 64 20  BSMSG:  defb    "Bad Subscript",0
 158+ 110C 53 75 62 73
 158+ 1110 63 72 69 70
 158+ 1114 74 00
 159+ 1116 52 65 2D 44  DDMSG:  defb    "Re-Dimensioned Array",0
 159+ 111A 69 6D 65 6E
 159+ 111E 73 69 6F 6E
 159+ 1122 65 64 20 41
 159+ 1126 72 72 61 79
 159+ 112A 00
 160+ 112B 44 69 76 69  DZMSG:  defb    "Division by Zero",0
 160+ 112F 73 69 6F 6E
 160+ 1133 20 62 79 20
 160+ 1137 5A 65 72 6F
 160+ 113B 00
 161+ 113C 49 6C 6C 65  IDMSG:  defb    "Illegal Direct Mode",0
 161+ 1140 67 61 6C 20
 161+ 1144 44 69 72 65
 161+ 1148 63 74 20 4D
 161+ 114C 6F 64 65 00
 162+ 1150 54 79 70 65  TMMSG:  defb    "Type Mis-match",0
 162+ 1154 20 4D 69 73
 162+ 1158 2D 6D 61 74
 162+ 115C 63 68 00
 163+ 115F 4F 75 74 20  OSMSG:  defb    "Out of String Space",0
 163+ 1163 6F 66 20 53
 163+ 1167 74 72 69 6E
 163+ 116B 67 20 53 70
 163+ 116F 61 63 65 00
 164+ 1173 53 74 72 69  LSMSG:  defb    "String Too Long",0
 164+ 1177 6E 67 20 54
 164+ 117B 6F 6F 20 4C
 164+ 117F 6F 6E 67 00
 165+ 1183 53 74 72 69  STMSG:  defb    "String Formula Too Complex",0
 165+ 1187 6E 67 20 46
 165+ 118B 6F 72 6D 75
 165+ 118F 6C 61 20 54
 165+ 1193 6F 6F 20 43
 165+ 1197 6F 6D 70 6C
 165+ 119B 65 78 00
 166+ 119E 43 61 6E 27  CNMSG:  defb    "Can't Continue",0
 166+ 11A2 74 20 43 6F
 166+ 11A6 6E 74 69 6E
 166+ 11AA 75 65 00
 167+ 11AD 55 6E 64 65  UFMSG:  defb    "Undefined FN Function",0
 167+ 11B1 66 69 6E 65
 167+ 11B5 64 20 46 4E
 167+ 11B9 20 46 75 6E
 167+ 11BD 63 74 69 6F
 167+ 11C1 6E 00
 168+ 11C3 4D 69 73 73  MOMSG:  defb    "Missing Operand",0
 168+ 11C7 69 6E 67 20
 168+ 11CB 4F 70 65 72
 168+ 11CF 61 6E 64 00
 169+ 11D3 48 45 58 20  HEMSG:  defb    "HEX Format",0
 169+ 11D7 46 6F 72 6D
 169+ 11DB 61 74 00
 170+ 11DE 42 49 4E 20  BNMSG:  defb    "BIN Format",0
 170+ 11E2 46 6F 72 6D
 170+ 11E6 61 74 00
 171+ 11E9 4E 6F 20 47  GMMSG:  defb    "No Graphics Mode",0
 171+ 11ED 72 61 70 68
 171+ 11F1 69 63 73 20
 171+ 11F5 4D 6F 64 65
 171+ 11F9 00
 172+ 11FA 53 65 72 69  SCMSG:  defb    "Serial Configuration",0
 172+ 11FE 61 6C 20 43
 172+ 1202 6F 6E 66 69
 172+ 1206 67 75 72 61
 172+ 120A 74 69 6F 6E
 172+ 120E 00
 173+ 120F 53 65 72 69  SAMSG:  defb    "Serial Port Already Open",0
 173+ 1213 61 6C 20 50
 173+ 1217 6F 72 74 20
 173+ 121B 41 6C 72 65
 173+ 121F 61 64 79 20
 173+ 1223 4F 70 65 6E
 173+ 1227 00
 174+ 1228 53 65 72 69  SOMSG:  defb    "Serial Buffer Overrun",0
 174+ 122C 61 6C 20 42
 174+ 1230 75 66 66 65
 174+ 1234 72 20 4F 76
 174+ 1238 65 72 72 75
 174+ 123C 6E 00
 175+ 123E 48 45 4C 50  HPMSG:  defb    "HELP Call",0
 175+ 1242 20 43 61 6C
 175+ 1246 6C 00
 176+ 1248 49 6C 6C 65  IMMSG:  defb    "Illegal Indirect Mode",0
 176+ 124C 67 61 6C 20
 176+ 1250 49 6E 64 69
 176+ 1254 72 65 63 74
 176+ 1258 20 4D 6F 64
 176+ 125C 65 00
 177+ 125E 44 65 76 69  NRMSG:  defb    "Device Not Ready",0
 177+ 1262 63 65 20 4E
 177+ 1266 6F 74 20 52
 177+ 126A 65 61 64 79
 177+ 126E 00
 178+ 126F 46 69 6C 65  D0MSG:  defb    "File Open/Close",0
 178+ 1273 20 4F 70 65
 178+ 1277 6E 2F 43 6C
 178+ 127B 6F 73 65 00
 179+ 127F 4E 61 6D 65  D1MSG:  defb    "Name String",0
 179+ 1283 20 53 74 72
 179+ 1287 69 6E 67 00
 180+ 128B 44 69 73 6B  D2MSG:  defb    "Disk Geometry",0
 180+ 128F 20 47 65 6F
 180+ 1293 6D 65 74 72
 180+ 1297 79 00
 181+ 1299 53 61 76 65  D3MSG:  defb    "Save",0
 181+ 129D 00
 182+ 129E 4C 6F 61 64  D4MSG:  defb    "Load",0
 182+ 12A2 00
 183+ 12A3 44 69 73 6B  D5MSG:  defb    "Disk Full",0
 183+ 12A7 20 46 75 6C
 183+ 12AB 6C 00
 184+ 12AD 44 75 70 6C  D6MSG:  defb    "Duplicate File Name",0
 184+ 12B1 69 63 61 74
 184+ 12B5 65 20 46 69
 184+ 12B9 6C 65 20 4E
 184+ 12BD 61 6D 65 00
 185+ 12C1 44 4F 53 20  D7MSG:  defb    "DOS Version",0
 185+ 12C5 56 65 72 73
 185+ 12C9 69 6F 6E 00
 186+ 12CD 46 69 6C 65  D8MSG:  defb    "File Not Found",0
 186+ 12D1 20 4E 6F 74
 186+ 12D5 20 46 6F 75
 186+ 12D9 6E 64 00
 187+ 12DC 46 69 6C 65  D9MSG:  defb    "File Already Open",0
 187+ 12E0 20 41 6C 72
 187+ 12E4 65 61 64 79
 187+ 12E8 20 4F 70 65
 187+ 12EC 6E 00
 188+ 12EE 45 6E 64 20  DAMSG:  defb    "End Of File",0
 188+ 12F2 4F 66 20 46
 188+ 12F6 69 6C 65 00
 189+ 12FA
 190+ 12FA
 191+ 12FA              ;-----------------------------------------------------------------------------
 192+ 12FA              ; STARTING POINTS FOR BASIC BOOT
 193+ 12FA              ; COLD: reset every memory pointer, acting as a power-up boot
 194+ 12FA              ; WARM: preserve program in memory, keeping every current pointer
 195+ 12FA
 196+ 12FA C3 00 13     COLD:   jp      STARTB          ; Jump for cold start
 197+ 12FD C3 D6 13     WARM:   jp      WARMST          ; Jump for warm start
 198+ 1300
 199+ 1300 C3 07 13     STARTB: jp      CSTART          ; Jump to initialise
 200+ 1303 4D 1E                defw    DEINT           ; Get integer -32768 to 32767
 201+ 1305 12 26                defw    ABPASS          ; Return integer in AB
 202+ 1307 21 01 54     CSTART: ld      HL,WRKSPC       ; Start of workspace RAM
 203+ 130A F9                   ld      SP,HL           ; Set up a temporary stack
 204+ 130B C3 54 41             jp      INITST          ; Go to initialise
 205+ 130E
 206+ 130E 21 E9 16     SYSINIT:ld      HL,INITAB       ; Initialise workspace
 207+ 1311 01 DC 00             ld      BC,INITBE-INITAB+3; Bytes to copy
 208+ 1314 11 01 54             ld      DE,WRKSPC       ; Into workspace RAM
 209+ 1317 ED B0                ldir                    ; Copy data
 210+ 1319 EB                   ex      DE,HL           ; Copy DE into HL
 211+ 131A F9                   ld      SP,HL           ; Temporary stack
 212+ 131B CD B2 19             call    CLREG           ; Clear registers and stack
 213+ 131E CD 64 20             call    PRNTCRLF        ; Output CRLF
 214+ 1321 32 34 55             ld      (BUFFER+88+1),A ; Mark end of buffer
 215+ 1324 32 0E 56             ld      (PROGST),A      ; Initialise program area
 216+ 1327 18 13                jr      MNOASK          ; usually, don't ask for memory top (only when there are errors)
 217+ 1329 21 5A 14     MSIZE:  ld      HL,MEMMSG       ; Point to message
 218+ 132C CD 30 27             call    PRS             ; Output "Memory size"
 219+ 132F CD CF 19             call    PROMPT          ; Get input with '?'
 220+ 1332 CD 2D 09             call    CURSOR_ON       ; enable cursor
 221+ 1335 CD 97 1D             call    GETCHR          ; Get next character
 222+ 1338 B7                   or      A               ; Set flags
 223+ 1339 C2 51 13             jp      NZ,TSTMEM       ; If number - Test if RAM there
 224+ 133C 21 72 56     MNOASK: ld      HL,STLOOK       ; Point to start of RAM
 225+ 133F 23           MLOOP:  inc     HL              ; Next byte
 226+ 1340 7C                   ld      A,H             ; Above address FFFF ?
 227+ 1341 B5                   or      L
 228+ 1342 CA 63 13             jp      Z,SETTOP        ; Yes - 64K RAM
 229+ 1345 7E                   ld      A,(HL)          ; Get contents
 230+ 1346 47                   ld      B,A             ; Save it
 231+ 1347 2F                   cpl                     ; Flip all bits
 232+ 1348 77                   ld      (HL),A          ; Put it back
 233+ 1349 BE                   cp      (HL)            ; RAM there if same
 234+ 134A 70                   ld      (HL),B          ; Restore old contents
 235+ 134B CA 3F 13             jp      Z,MLOOP         ; If RAM - test next byte
 236+ 134E C3 63 13             jp      SETTOP          ; Top of RAM found
 237+ 1351
 238+ 1351 CD 67 1E     TSTMEM: call    ATOH            ; Get high memory into DE
 239+ 1354 B7                   or      A               ; Set flags on last byte
 240+ 1355 C2 50 18             jp      NZ,SNERR        ; ?SN Error if bad character
 241+ 1358 EB                   ex      DE,HL           ; Address into HL
 242+ 1359 2B                   dec     HL              ; Back one byte
 243+ 135A 3E D9                ld      A,%11011001     ; Test byte
 244+ 135C 46                   ld      B,(HL)          ; Get old contents
 245+ 135D 77                   ld      (HL),A          ; Load test byte
 246+ 135E BE                   cp      (HL)            ; RAM there if same
 247+ 135F 70                   ld      (HL),B          ; Restore old contents
 248+ 1360 C2 29 13             jp      NZ,MSIZE        ; Ask again if no RAM
 249+ 1363
 250+ 1363 CD 42 09     SETTOP: call    CURSOR_OFF      ; disable cursor
 251+ 1366 2B                   dec     HL              ; Back one byte
 252+ 1367 11 71 56             ld      DE,STLOOK-1     ; See if enough RAM
 253+ 136A CD 48 1B             call    CPDEHL          ; Compare DE with HL
 254+ 136D DA 29 13             jp      C,MSIZE         ; Ask again if not enough RAM
 255+ 1370 3A EA 55             ld      A,(DOS_EN)      ; read if the user enabled/disabled DOS while booting
 256+ 1373 1F                   rra                     ; is DOS enabled?
 257+ 1374 38 1C                jr      C,SETDSR        ; yes, so jump over
 258+ 1376 DD 21 E0 FF          ld      IX,DOSJPTB+1    ; point to 1st address of DOS jump table
 259+ 137A
 260+ 137A                      DEFINE  DOSNTRS 11      ; DOS entries <-- CHANGE THIS VALUE TO ALIGN IT WITH THE NUMBER OF ENTRIES
 261+ 137A
 262+ 137A 06 0B                ld      B,11       ; number of entries
 263+ 137C 11 50 18             ld      DE,SNERR        ; address of REM routine
 264+ 137F DD 73 00     CPDSTB: ld      (IX),E          ; copy REM address...
 265+ 1382 DD 23                inc     IX              ; ...into the...
 266+ 1384 DD 72 00             ld      (IX),D          ; ...jump entry
 267+ 1387 DD 23                inc     IX              ; next jump address
 268+ 1389 DD 23                inc     IX
 269+ 138B 10 F2                djnz    CPDSTB          ; repeat
 270+ 138D 11 DF FF             ld      DE,0-(11*3); protect jump table (3 byte for each entry)
 271+ 1390 18 03                jr      SETNOD
 272+ 1392 11 25 EE     SETDSR: ld      DE,0-($FFFF-DOSSTART+1) ; no, so reserve RAM occupied by DOS & I/O buffers
 273+ 1395 19           SETNOD: add     HL,DE
 274+ 1396 22 39 55     SETTRAM:ld      (LSTRAM),HL     ; Save last available RAM
 275+ 1399 11 9C FF             ld      DE,0-100        ; now, reserve 100 bytes for string space
 276+ 139C 19                   add     HL,DE           ; Allocate string space
 277+ 139D 22 50 54             ld      (STRSPC),HL     ; Save string space
 278+ 13A0 CD 8D 19             call    CLRPTR          ; Clear program area
 279+ 13A3 2A 50 54             ld      HL,(STRSPC)     ; Get end of memory
 280+ 13A6 11 EF FF             ld      DE,0-17         ; Offset for free bytes
 281+ 13A9 19                   add     HL,DE           ; Adjust HL
 282+ 13AA 11 0E 56             ld      DE,PROGST       ; Start of program text
 283+ 13AD 7D                   ld      A,L             ; Get LSB
 284+ 13AE 93                   sub     E               ; Adjust it
 285+ 13AF 6F                   ld      L,A             ; Re-save
 286+ 13B0 7C                   ld      A,H             ; Get MSB
 287+ 13B1 9A                   sbc     A,D             ; Adjust it
 288+ 13B2 67                   ld      H,A             ; Re-save
 289+ 13B3 E5                   push    HL              ; Save bytes free
 290+ 13B4 21 FC 13             ld      HL,SIGNON       ; Sign-on message
 291+ 13B7 CD 30 27             call    PRS             ; Output string
 292+ 13BA 3A EA 55             ld      A,(DOS_EN)      ; check if DOS is enabled
 293+ 13BD B7                   or      A
 294+ 13BE 28 06                jr      Z,SETTP1        ; no DOS, jump over
 295+ 13C0 21 3D 14             ld      HL,DOSMSG       ; DOS message
 296+ 13C3 CD 30 27             call    PRS
 297+ 13C6 21 E5 13     SETTP1: ld      HL,BLNSPC       ; Empty space
 298+ 13C9 CD 30 27             call    PRS             ; Output string
 299+ 13CC E1                   pop     HL              ; Get bytes free back
 300+ 13CD CD CF 31             call    PRNTHL          ; Output amount of free memory
 301+ 13D0 21 EE 13             ld      HL,BFREE        ; " Bytes free" message
 302+ 13D3 CD 30 27             call    PRS             ; Output string
 303+ 13D6
 304+ 13D6 31 E0 54     WARMST: ld      SP,STACK        ; Temporary stack
 305+ 13D9 CD B2 19     BRKRET: call    CLREG           ; Clear registers and stack
 306+ 13DC CD DF 3E             call    RESFN           ; reset FN keys and auto-repeat
 307+ 13DF CD 2D 09             call    CURSOR_ON       ; enable cursor
 308+ 13E2 C3 B0 18             jp      PRNTOK          ; Go to get command line
 309+ 13E5
 310+ 13E5 20 20 20 20  BLNSPC: defb    "        ",0    ; 8 empty cells to align the "XXXX Bytes free" message
 310+ 13E9 20 20 20 20
 310+ 13ED 00
 311+ 13EE 20 42 79 74  BFREE:  defb    " Bytes free",CR,CR,0
 311+ 13F2 65 73 20 66
 311+ 13F6 72 65 65 0D
 311+ 13FA 0D 00
 312+ 13FC
 313+ 13FC 4C 4D 38 30  SIGNON: defb    "LM80C BASIC 3.26 ",251,"2021 L.Miliani"
 313+ 1400 43 20 42 41
 313+ 1404 53 49 43 20
 313+ 1408 33 2E 32 36
 313+ 140C 20 FB 32 30
 313+ 1410 32 31 20 4C
 313+ 1414 2E 4D 69 6C
 313+ 1418 69 61 6E 69
 314+ 141C 20 5A 38 30          defb    " Z80 BASIC 4.7  ",251,"1978 Microsoft",CR,0
 314+ 1420 20 42 41 53
 314+ 1424 49 43 20 34
 314+ 1428 2E 37 20 20
 314+ 142C FB 31 39 37
 314+ 1430 38 20 4D 69
 314+ 1434 63 72 6F 73
 314+ 1438 6F 66 74 0D
 314+ 143C 00
 315+ 143D 20 20 20 20  DOSMSG: defb    "     LM80C DOS ","1.06","  Loaded",CR,0
 315+ 1441 20 4C 4D 38
 315+ 1445 30 43 20 44
 315+ 1449 4F 53 20 31
 315+ 144D 2E 30 36 20
 315+ 1451 20 4C 6F 61
 315+ 1455 64 65 64 0D
 315+ 1459 00
 316+ 145A
 317+ 145A 4D 65 6D 6F  MEMMSG: defb    "Memory top",0
 317+ 145E 72 79 20 74
 317+ 1462 6F 70 00
 318+ 1465
 319+ 1465              ; The following list reports all the functions supported by the interpreter.
 320+ 1465              ; To add a custom function, the user must first insert the reserved word here,
 321+ 1465              ; then into the list of the reserved words below, and finally must increment the
 322+ 1465              ; ZSGN token value and all the following ones after ZSGN by 1 for every added
 323+ 1465              ; function.
 324+ 1465
 325+ 1465              ; FUNCTION ADDRESS TABLE (this is a sort of offset table)
 326+ 1465              ; this list must be coherent with the tokens' functions list. This means that every
 327+ 1465              ; entry here must have the corresponding entry in the tokens list.
 328+ 1465 44 30        FNCTAB: defw    SGN
 329+ 1467 DA 25                defw    TMR         ; added by Leonardo Miliani
 330+ 1469 08 31                defw    INT
 331+ 146B 5A 30                defw    ABS_        ; '_' necessary to avoid assembler warnings
 332+ 146D 07 54                defw    USR
 333+ 146F F0 25                defw    FRE
 334+ 1471 6B 2A                defw    INP
 335+ 1473 1E 26                defw    POS
 336+ 1475 CE 32                defw    SQR
 337+ 1477 AD 33                defw    RND
 338+ 1479 98 2E                defw    LOG
 339+ 147B 1C 33                defw    EXP
 340+ 147D 22 34                defw    COS
 341+ 147F 28 34                defw    SIN
 342+ 1481 89 34                defw    TAN
 343+ 1483 9E 34                defw    ATN
 344+ 1485 47 2B                defw    PEEK
 345+ 1487 08 35                defw    DEEK
 346+ 1489 4E 2B                defw    VPEEK       ; added by Leonardo Miliani
 347+ 148B 1D 2D                defw    VSTAT       ; added by Leonardo Miliani
 348+ 148D 28 2D                defw    SSTAT       ; added by Leonardo Miliani
 349+ 148F 3C 2D                defw    INKEY       ; added by Leonardo Miliani
 350+ 1491 54 38                defw    POINT       ; added by Leonardo Miliani
 351+ 1493 02 29                defw    INSTR       ; added by Leonardo Miliani
 352+ 1495 E8 FF                defw    JPGET       ; added by Leonardo Miliani
 353+ 1497 E2 FF                defw    JPEOF       ; added by Leonardo Miliani
 354+ 1499 DF FF                defw    JPEXI       ; added by Leonardo Miliani
 355+ 149B A2 28                defw    LEN
 356+ 149D BA 26                defw    STR
 357+ 149F 32 2A                defw    VAL
 358+ 14A1 B1 28                defw    ASC
 359+ 14A3 C2 28                defw    CHR
 360+ 14A5 3D 40                defw    HEX         ; added by Grant Searle
 361+ 14A7 CE 40                defw    BIN         ; added by Grant Searle
 362+ 14A9 D2 28                defw    LEFT
 363+ 14AB F8 29                defw    RIGHT
 364+ 14AD 02 2A                defw    MID
 365+ 14AF
 366+ 14AF              ; RESERVED WORD LIST
 367+ 14AF              ; Here are all the reserved words used by the interpreter
 368+ 14AF              ; To add custom functions/commands, the user must insert the keyword
 369+ 14AF              ; in this list, following the schematic
 370+ 14AF C5 4E 44     WORDS:  defb    'E'+$80,"ND"            ; from here the list contains the COMMANDS
 371+ 14B2 C6 4F 52             defb    'F'+$80,"OR"
 372+ 14B5 CE 45 58 54          defb    'N'+$80,"EXT"
 373+ 14B9 C4 41 54 41          defb    'D'+$80,"ATA"
 374+ 14BD C9 4E 50 55          defb    'I'+$80,"NPUT"
 374+ 14C1 54
 375+ 14C2 C4 49 4D             defb    'D'+$80,"IM"
 376+ 14C5 D2 45 41 44          defb    'R'+$80,"EAD"
 377+ 14C9 CC 45 54             defb    'L'+$80,"ET"
 378+ 14CC C7 4F 54 4F          defb    'G'+$80,"OTO"
 379+ 14D0 D2 55 4E             defb    'R'+$80,"UN"
 380+ 14D3 C9 46                defb    'I'+$80,"F"
 381+ 14D5 D2 45 53 54          defb    'R'+$80,"ESTORE"
 381+ 14D9 4F 52 45
 382+ 14DC C7 4F 53 55          defb    'G'+$80,"OSUB"
 382+ 14E0 42
 383+ 14E1 D2 45 54 55          defb    'R'+$80,"ETURN"
 383+ 14E5 52 4E
 384+ 14E7 D2 45 4D             defb    'R'+$80,"EM"            ; original REM
 385+ 14EA D3 54 4F 50          defb    'S'+$80,"TOP"
 386+ 14EE CF 55 54             defb    'O'+$80,"UT"
 387+ 14F1 CF 4E                defb    'O'+$80,"N"
 388+ 14F3 C6 49 4C 45          defb    'F'+$80,"ILES"          ; added by Leonardo Miliani
 388+ 14F7 53
 389+ 14F8 C5 52 41 53          defb    'E'+$80,"RASE"          ; added by Leonardo Miliani
 389+ 14FC 45
 390+ 14FD C4 49 53 4B          defb    'D'+$80,"ISK"           ; added by Leonardo Miliani
 391+ 1501 CF 50 45 4E          defb    'O'+$80,"PEN"           ; added by Leonardo Miliani
 392+ 1505 C3 4C 4F 53          defb    'C'+$80,"LOSE"          ; added by Leonardo Miliani
 392+ 1509 45
 393+ 150A D0 55 54             defb    'P'+$80,"UT"            ; added by Leonardo Miliani
 394+ 150D D7 41 49 54          defb    'W'+$80,"AIT"
 395+ 1511 C4 45 46             defb    'D'+$80,"EF"
 396+ 1514 D0 4F 4B 45          defb    'P'+$80,"OKE"
 397+ 1518 C4 4F 4B 45          defb    'D'+$80,"OKE"
 398+ 151C D6 50 4F 4B          defb    'V'+$80,"POKE"          ; added by Leonardo Miliani
 398+ 1520 45
 399+ 1521 D3 52 45 47          defb    'S'+$80,"REG"           ; added by Leonardo Miliani
 400+ 1525 D6 52 45 47          defb    'V'+$80,"REG"           ; added by Leonardo Miliani
 401+ 1529 D3 43 52 45          defb    'S'+$80,"CREEN"         ; changed by Leonardo Miliani
 401+ 152D 45 4E
 402+ 152F CC 4F 43 41          defb    'L'+$80,"OCATE"         ; added by Leonardo Miliani
 402+ 1533 54 45
 403+ 1535 D3 4F 55 4E          defb    'S'+$80,"OUND"          ; added by Leonardo Miliani
 403+ 1539 44
 404+ 153A D6 4F 4C 55          defb    'V'+$80,"OLUME"         ; added by Leonardo Miliani
 404+ 153E 4D 45
 405+ 1540 D0 41 55 53          defb    'P'+$80,"AUSE"          ; added by Leonardo Miliani
 405+ 1544 45
 406+ 1545 C3 4F 4C 4F          defb    'C'+$80,"OLOR"          ; added by Leonardo Miliani
 406+ 1549 52
 407+ 154A D0 4C 4F 54          defb    'P'+$80,"LOT"           ; added by Leonardo Miliani
 408+ 154E C4 52 41 57          defb    'D'+$80,"RAW"           ; added by Leonardo Miliani
 409+ 1552 C3 49 52 43          defb    'C'+$80,"IRCLE"         ; added by Leonardo Miliani
 409+ 1556 4C 45
 410+ 1558 D0 41 49 4E          defb    'P'+$80,"AINT"          ; added by Leonardo Miliani
 410+ 155C 54
 411+ 155D D3 45 52 49          defb    'S'+$80,"ERIAL"         ; added by Leonardo Miliani
 411+ 1561 41 4C
 412+ 1563 C8 45 4C 50          defb    'H'+$80,"ELP"           ; changed by Leonardo Miliani - was LINES
 413+ 1567 C3 4C 53             defb    'C'+$80,"LS"            ; restored command
 414+ 156A CB 45 59             defb    'K'+$80,"EY"            ; added by Leonardo Miliani
 415+ 156D CE 4D 49             defb    'N'+$80,"MI"            ; added by Leonardo Miliani
 416+ 1570 C7 50 52 49          defb    'G'+$80,"PRINT"         ; added by Leonardo Miliani
 416+ 1574 4E 54
 417+ 1576 D7 49 44 54          defb    'W'+$80,"IDTH"
 417+ 157A 48
 418+ 157B D3 59 53             defb    'S'+$80,"YS"            ; added by Leonardo Miliani
 419+ 157E D2 45 53 45          defb    'R'+$80,"ESET"          ; changed by Leonardo Miliani
 419+ 1582 54
 420+ 1583 C5 4C 53 45          defb    'E'+$80,"LSE"           ; added by Leonardo Miliani
 421+ 1587 D0 52 49 4E          defb    'P'+$80,"RINT"
 421+ 158B 54
 422+ 158C C3 4F 4E 54          defb    'C'+$80,"ONT"
 423+ 1590 CC 49 53 54          defb    'L'+$80,"IST"
 424+ 1594 C3 4C 45 41          defb    'C'+$80,"LEAR"
 424+ 1598 52
 425+ 1599 CC 4F 41 44          defb    'L'+$80,"OAD"
 426+ 159D D3 41 56 45          defb    'S'+$80,"AVE"
 427+ 15A1 CE 45 57             defb    'N'+$80,"EW"
 428+ 15A4 D4 41 42 28          defb    'T'+$80,"AB("
 429+ 15A8 D4 4F                defb    'T'+$80,"O"
 430+ 15AA C6 4E                defb    'F'+$80,"N"
 431+ 15AC D3 50 43 28          defb    'S'+$80,"PC("
 432+ 15B0 D4 48 45 4E          defb    'T'+$80,"HEN"
 433+ 15B4 CE 4F 54             defb    'N'+$80,"OT"
 434+ 15B7 D3 54 45 50          defb    'S'+$80,"TEP"
 435+ 15BB                      ; from here: operators
 436+ 15BB AB                   defb    '+'+$80
 437+ 15BC AD                   defb    '-'+$80
 438+ 15BD AA                   defb    '*'+$80
 439+ 15BE AF                   defb    '/'+$80
 440+ 15BF A5                   defb    '%'+$80
 441+ 15C0 A3                   defb    '#'+$80
 442+ 15C1 DE                   defb    '^'+$80
 443+ 15C2 C1 4E 44             defb    'A'+$80,"ND"
 444+ 15C5 D8 4F 52             defb    'X'+$80,"OR"
 445+ 15C8 CF 52                defb    'O'+$80,"R"
 446+ 15CA BE                   defb    '>'+$80
 447+ 15CB BD                   defb    '='+$80
 448+ 15CC BC                   defb    '<'+$80
 449+ 15CD
 450+ 15CD                      ; from here there are the tokens' FUNCTIONS list
 451+ 15CD                      ; this list must be coherent with the functions list above
 452+ 15CD D3 47 4E             defb    'S'+$80,"GN"
 453+ 15D0 D4 4D 52             defb    'T'+$80,"MR"            ; added by Leonardo Miliani
 454+ 15D3 C9 4E 54             defb    'I'+$80,"NT"
 455+ 15D6 C1 42 53             defb    'A'+$80,"BS"
 456+ 15D9 D5 53 52             defb    'U'+$80,"SR"
 457+ 15DC C6 52 45             defb    'F'+$80,"RE"
 458+ 15DF C9 4E 50             defb    'I'+$80,"NP"
 459+ 15E2 D0 4F 53             defb    'P'+$80,"OS"
 460+ 15E5 D3 51 52             defb    'S'+$80,"QR"
 461+ 15E8 D2 4E 44             defb    'R'+$80,"ND"
 462+ 15EB CC 4F 47             defb    'L'+$80,"OG"
 463+ 15EE C5 58 50             defb    'E'+$80,"XP"
 464+ 15F1 C3 4F 53             defb    'C'+$80,"OS"
 465+ 15F4 D3 49 4E             defb    'S'+$80,"IN"
 466+ 15F7 D4 41 4E             defb    'T'+$80,"AN"
 467+ 15FA C1 54 4E             defb    'A'+$80,"TN"
 468+ 15FD D0 45 45 4B          defb    'P'+$80,"EEK"
 469+ 1601 C4 45 45 4B          defb    'D'+$80,"EEK"
 470+ 1605 D6 50 45 45          defb    'V'+$80,"PEEK"          ; added by Leonardo Miliani
 470+ 1609 4B
 471+ 160A D6 53 54 41          defb    'V'+$80,"STAT"          ; added by Leonardo Miliani
 471+ 160E 54
 472+ 160F D3 53 54 41          defb    'S'+$80,"STAT"          ; added by Leonardo Miliani
 472+ 1613 54
 473+ 1614 C9 4E 4B 45          defb    'I'+$80,"NKEY"          ; added by Leonardo Miliani
 473+ 1618 59
 474+ 1619 D0 4F 49 4E          defb    'P'+$80,"OINT"          ; added by Leonardo Miliani
 474+ 161D 54
 475+ 161E C9 4E 53 54          defb    'I'+$80,"NSTR"          ; added by Leonardo Miliani
 475+ 1622 52
 476+ 1623 C7 45 54             defb    'G'+$80,"ET"            ; added by Leonardo Miliani
 477+ 1626 C5 4F 46             defb    'E'+$80,"OF"            ; added by Leonardo Miliani
 478+ 1629 C5 58 49 53          defb    'E'+$80,"XIST"          ; added by Leonardo Miliani
 478+ 162D 54
 479+ 162E CC 45 4E             defb    'L'+$80,"EN"
 480+ 1631 D3 54 52 24          defb    'S'+$80,"TR$"
 481+ 1635 D6 41 4C             defb    'V'+$80,"AL"
 482+ 1638 C1 53 43             defb    'A'+$80,"SC"
 483+ 163B C3 48 52 24          defb    'C'+$80,"HR$"
 484+ 163F C8 45 58 24          defb    'H'+$80,"EX$"           ; added by Grant Searle
 485+ 1643 C2 49 4E 24          defb    'B'+$80,"IN$"           ; added by Grant Searle
 486+ 1647 CC 45 46 54          defb    'L'+$80,"EFT$"
 486+ 164B 24
 487+ 164C D2 49 47 48          defb    'R'+$80,"IGHT$"
 487+ 1650 54 24
 488+ 1652 CD 49 44 24          defb    'M'+$80,"ID$"
 489+ 1656 80                   defb    $80                     ; End-of-list marker
 490+ 1657
 491+ 1657              ; COMMAND KEYWORD ADDRESS TABLE
 492+ 1657              ; this list must be coherent with the commands' tokens list above
 493+ 1657 E1 1D        WORDTB: defw    PEND
 494+ 1659 DE 1C                defw    FOR
 495+ 165B DD 21                defw    NEXT
 496+ 165D 40 1F                defw    DATA
 497+ 165F DA 20                defw    INPUT
 498+ 1661 32 24                defw    DIM
 499+ 1663 14 21                defw    READ
 500+ 1665 57 1F                defw    LET
 501+ 1667 FD 1E                defw    GOTO
 502+ 1669 D8 1E                defw    RUN
 503+ 166B CF 1F                defw    IF
 504+ 166D A7 1D                defw    RESTOR
 505+ 166F EC 1E                defw    GOSUB
 506+ 1671 1B 1F                defw    RETURN
 507+ 1673 42 1F                defw    REM         ; original REM
 508+ 1675 DF 1D                defw    STOP
 509+ 1677 77 2A                defw    POUT
 510+ 1679 B1 1F                defw    ON
 511+ 167B FD FF                defw    JPFILS      ; changed by Leonardo Miliani - was NULL
 512+ 167D F4 FF                defw    JPERAS      ; added by Leonardo Miliani
 513+ 167F F1 FF                defw    JPDISK      ; added by Leonardo Miliani
 514+ 1681 EE FF                defw    JPOPEN      ; added by Leonardo Miliani
 515+ 1683 EB FF                defw    JPCLOSE     ; added by Leonardo Miliani
 516+ 1685 E5 FF                defw    JPPUT       ; added by Leonardo Miliani
 517+ 1687 7D 2A                defw    WAIT
 518+ 1689 26 26                defw    DEF
 519+ 168B 71 2B                defw    POKE
 520+ 168D 13 35                defw    DOKE
 521+ 168F 76 2B                defw    VPOKE       ; added by Leonardo Miliani
 522+ 1691 B3 2B                defw    SREG        ; added by Leonardo Miliani
 523+ 1693 01 2D                defw    VREG        ; added by Leonardo Miliani
 524+ 1695 47 35                defw    SCREEN      ; new behaviour: now it sets up a graphics mode (Leonardo Miliani)
 525+ 1697 81 2B                defw    LOCATE      ; added by Leonardo Miliani
 526+ 1699 0D 2C                defw    SOUND       ; added by Leonardo Miliani
 527+ 169B D4 2B                defw    VOLUME      ; added by Leonardo Miliani
 528+ 169D 2A 35                defw    PAUSE       ; added by Leonardo Miliani
 529+ 169F C0 35                defw    COLOR       ; added by Leonardo Miliani
 530+ 16A1 A7 38                defw    PLOT        ; added by Leonardo Miliani
 531+ 16A3 39 39                defw    DRAW        ; added by Leonardo Miliani
 532+ 16A5 6E 3A                defw    CIRCLE      ; added by Leonardo Miliani
 533+ 16A7 68 37                defw    PAINT       ; added by Leonardo Miliani
 534+ 16A9 75 3C                defw    SERIAL      ; added by Leonardo Miliani
 535+ 16AB B4 3E                defw    HELP        ; changed by Leonardo Miliani - was LINES
 536+ 16AD EC 34                defw    CLS
 537+ 16AF D2 3E                defw    KEY         ; added by Leonardo Miliani
 538+ 16B1 BF 2A                defw    NMI         ; added by Leonardo Miliani
 539+ 16B3 78 36                defw    GPRINT      ; added by Leonardo Miliani
 540+ 16B5 00 35                defw    WIDTH
 541+ 16B7 19 2B                defw    SYS         ; added by Leonardo Miliani
 542+ 16B9 33 41                defw    RESET       ; new behaviour: now it resets the system
 543+ 16BB 44 1F                defw    REM+2       ; ELSE: added by Leonardo Miliani
 544+ 16BD 01 20                defw    PRINT
 545+ 16BF 13 1E                defw    CONT
 546+ 16C1 B5 1B                defw    LIST
 547+ 16C3 8C 1E                defw    CLEAR
 548+ 16C5 F7 FF                defw    JPLOAD      ; re-implemented by Leonardo Miliani (was CLOAD)
 549+ 16C7 FA FF                defw    JPSAVE      ; re-implemented by Leonardo Miliani (was CSAVE)
 550+ 16C9 8C 19                defw    NEW
 551+ 16CB
 552+ 16CB              ; RESERVED WORD TOKEN VALUES
 553+ 16CB              ; if you add a function or command you must increment by 1
 554+ 16CB              ; the values below. Pay attention that you must increment only the
 555+ 16CB              ; values AFTER the position where you entered the function/command word
 556+ 16CB              ; in the "Reserver word list" above. I.E.: VPOKE has been added between
 557+ 16CB              ; DOKE and SCREEN, and since REM is the reserved work listed below
 558+ 16CB              ; that is before the point where VPOKE has been entered, every entry
 559+ 16CB              ; after REM has been incremented.
 560+ 16CB              ; Another example: when TMR has been added, since it's a function, every
 561+ 16CB              ; entry after & included ZSGN must be checked (read below)
 562+ 16CB
 563+ 16CB              ZEND    equ     $80             ; END        <-- from here, there are the commands
 564+ 16CB              ZFOR    equ     $81             ; FOR
 565+ 16CB              ZDATA   equ     $83             ; DATA
 566+ 16CB              ZGOTO   equ     $88             ; GOTO
 567+ 16CB              ZGOSUB  equ     $8C             ; GOSUB
 568+ 16CB              ZREM    equ     $8E             ; REM
 569+ 16CB              ZELSE   equ     $B2             ; ELSE
 570+ 16CB              ZPRINT  equ     $B3             ; PRINT
 571+ 16CB              ZNEW    equ     $B9             ; NEW
 572+ 16CB
 573+ 16CB              ZTAB    equ     $BA             ; TAB
 574+ 16CB              ZTO     equ     $BB             ; TO
 575+ 16CB              ZFN     equ     $BC             ; FN
 576+ 16CB              ZSPC    equ     $BD             ; SPC
 577+ 16CB              ZTHEN   equ     $BE             ; THEN
 578+ 16CB              ZNOT    equ     $BF             ; NOT
 579+ 16CB              ZSTEP   equ     $C0             ; STEP
 580+ 16CB
 581+ 16CB              ZPLUS   equ     $C1             ; +         <-- from here, there are the math operators
 582+ 16CB              ZMINUS  equ     $C2             ; -
 583+ 16CB              ZTIMES  equ     $C3             ; *
 584+ 16CB              ZDIV    equ     $C4             ; /
 585+ 16CB              ZMOD    equ     $C5             ; %
 586+ 16CB              ZDINT   equ     $C6             ; #
 587+ 16CB              ZOR     equ     $CA             ; OR
 588+ 16CB              ZGTR    equ     $CB             ; >
 589+ 16CB              ZEQUAL  equ     $CC             ; M
 590+ 16CB              ZLTH    equ     $CD             ; <
 591+ 16CB
 592+ 16CB              ZSGN    equ     $CE             ; SGN       <-- from here, there are the functions
 593+ 16CB              ZPOINT  equ     $E4             ; ZPOINT    <-- if the user enters a custom function, between
 594+ 16CB                                              ;               SGN and POINT, he/she must increment this pointer by 1
 595+ 16CB              ZINSTR  equ     $E5             ; ZINSTR    <-- same here
 596+ 16CB              ZLEFT   equ     $F0             ; LEFT$     <-- if the user enters a custom function anywhere,
 597+ 16CB                                              ;               he/she must increment this pointer by 1
 598+ 16CB
 599+ 16CB              ; ARITHMETIC PRECEDENCE TABLE
 600+ 16CB              ; in the formulas below, <last> is a number stored into the stack that must be retrieved
 601+ 16CB              ; with POP BC, POP DE; FPREG is a f.p. number store into the RAM register FPREG
 602+ 16CB 79           PRITAB: defb    $79             ; Precedence value
 603+ 16CC B6 31                defw    PADD            ; FPREG = <last> + FPREG
 604+ 16CE
 605+ 16CE 79                   defb    $79             ; Precedence value
 606+ 16CF 99 2D                defw    PSUB            ; FPREG = <last> - FPREG
 607+ 16D1
 608+ 16D1 7C                   defb    $7C             ; Precedence value
 609+ 16D2 D7 2E                defw    MULT            ; PPREG = <last> * FPREG
 610+ 16D4
 611+ 16D4 7C                   defb    $7C             ; Precedence value
 612+ 16D5 89 2F                defw    DIV             ; FPREG = <last> / FPREG
 613+ 16D7
 614+ 16D7 7C                   defb    $7C             ; Precedence value
 615+ 16D8 34 2F                defw    MOD             ; FPREG = INT(<last>)-(INT(FPREG)*INT(<last>/FPREG))
 616+ 16DA
 617+ 16DA 7C                   defb    $7C             ; precedence value
 618+ 16DB 2C 2F                defw    DINT            ; FPREG = INT(<last> / FPREG )
 619+ 16DD
 620+ 16DD 7F                   defb    $7F             ; Precedence value
 621+ 16DE D7 32                defw    POWER           ; FPREG = <last> ^ FPREG
 622+ 16E0
 623+ 16E0 50                   defb    $50             ; Precedence value
 624+ 16E1 7B 23                defw    PAND            ; FPREG = <last> AND FPREG
 625+ 16E3
 626+ 16E3 4A                   defb    $4A             ; Precedence value
 627+ 16E4 83 23                defw    PXOR            ; FPREG = <last> XOR FPREG
 628+ 16E6
 629+ 16E6 46                   defb    $46             ; Precedence value
 630+ 16E7 7E 23                defw    POR             ; FPREG = <last> OR FPREG
 631+ 16E9
 632+ 16E9
 633+ 16E9              ; INITIALISATION TABLE -------------------------------------------------------
 634+ 16E9              ; these values are copied into RAM at startup
 635+ 16E9 C3 D6 13     INITAB: jp      WARMST          ; Warm start jump
 636+ 16EC ED 45 00             defb    $ED,$45,$00     ; RETN + NOP for default NMI service routine
 637+ 16EF C3 62 1E             jp      FCERR           ; "USR (X)" jump (Set to Error)
 638+ 16F2 D3 00                out     (0),A           ; "out p,n" skeleton
 639+ 16F4 C9                   ret
 640+ 16F5 D6 00                sub     $00             ; Division support routine
 641+ 16F7 6F                   ld      L,A
 642+ 16F8 7C                   ld      A,H
 643+ 16F9 DE 00                sbc     A,$00
 644+ 16FB 67                   ld      H,A
 645+ 16FC 78                   ld      A,B
 646+ 16FD DE 00                sbc     A,$00
 647+ 16FF 47                   ld      B,A
 648+ 1700 3E 00                ld      A,$00
 649+ 1702 C9                   ret
 650+ 1703 00 00 00             defb    $00,$00,$00     ; Random number seed table used by RND
 651+ 1706 35 4A CA 99          defb    $35,$4A,$CA,$99 ;-2.65145E+07
 652+ 170A 39 1C 76 98          defb    $39,$1C,$76,$98 ; 1.61291E+07
 653+ 170E 22 95 B3 98          defb    $22,$95,$B3,$98 ;-1.17691E+07
 654+ 1712 0A DD 47 98          defb    $0A,$DD,$47,$98 ; 1.30983E+07
 655+ 1716 53 D1 99 99          defb    $53,$D1,$99,$99 ;-2-01612E+07
 656+ 171A 0A 1A 9F 98          defb    $0A,$1A,$9F,$98 ;-1.04269E+07
 657+ 171E 65 BC CD 98          defb    $65,$BC,$CD,$98 ;-1.34831E+07
 658+ 1722 D6 77 3E 98          defb    $D6,$77,$3E,$98 ; 1.24825E+07
 659+ 1726 52 C7 4F 80          defb    $52,$C7,$4F,$80 ; Last random number
 660+ 172A DB 00                in      A,($00)         ; INP (x) skeleton
 661+ 172C C9                   ret
 662+ 172D FF                   defb    $FF             ; Terminal width (255 = no auto CRLF)
 663+ 172E 14                   defb    $14             ; Width for commas (at reset, 3 columns, for G1 mode)
 664+ 172F 00                   defb    $00             ; No nulls after input bytes
 665+ 1730 00                   defb    $00             ; Output enabled (^O off)
 666+ 1731 00 00                defw    $00             ; Array load/save check sum
 667+ 1733 00                   defb    $00             ; Break not by NMI
 668+ 1734 00                   defb    $00             ; Break flag
 669+ 1735 C3 D0 1A             jp      TTYLIN          ; Input reflection (set to TTY)
 670+ 1738 72 56                defw    STLOOK          ; Temp string space
 671+ 173A FE FF                defw    -2              ; Current line number (cold)
 672+ 173C FF FF                defw    -1              ; Current line with errors (no errors)
 673+ 173E 40           AUTORP: defb    $40             ; delay for key auto-repeat start
 674+ 173F 08                   defb    $08             ; auto-repeat delay
 675+ 1740 4C 49 53 54  DEFFNKS:defm    "LIST",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 1
 675+ 1744 0D 00 00 00
 675+ 1748 00 00 00 00
 675+ 174C 00 00 00 00
 676+ 1750 52 55 4E 0D          defm    "RUN",13,0,0,0,0,0,0,0,0,0,0,0,0    ; KEY 2
 676+ 1754 00 00 00 00
 676+ 1758 00 00 00 00
 676+ 175C 00 00 00 00
 677+ 1760 53 43 52 45          defm    "SCREEN1",13,0,0,0,0,0,0,0,0        ; KEY 3
 677+ 1764 45 4E 31 0D
 677+ 1768 00 00 00 00
 677+ 176C 00 00 00 00
 678+ 1770 43 4F 4C 4F          defm    "COLOR1,15,5",13,0,0,0,0            ; KEY 4
 678+ 1774 52 31 2C 31
 678+ 1778 35 2C 35 0D
 678+ 177C 00 00 00 00
 679+ 1780 53 45 52 49          defm    "SERIAL1,38400",13,0,0              ; KEY 5
 679+ 1784 41 4C 31 2C
 679+ 1788 33 38 34 30
 679+ 178C 30 0D 00 00
 680+ 1790 53 43 52 45          defm    "SCREEN2",13,0,0,0,0,0,0,0,0        ; KEY 6
 680+ 1794 45 4E 32 0D
 680+ 1798 00 00 00 00
 680+ 179C 00 00 00 00
 681+ 17A0 43 4F 4E 54          defm    "CONT",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 7
 681+ 17A4 0D 00 00 00
 681+ 17A8 00 00 00 00
 681+ 17AC 00 00 00 00
 682+ 17B0 48 45 4C 50          defm    "HELP",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 8 (HELP KEY)
 682+ 17B4 0D 00 00 00
 682+ 17B8 00 00 00 00
 682+ 17BC 00 00 00 00
 683+ 17C0 0F 56                defw    PROGST+1        ; Start of program text
 684+ 17C2              INITBE:
 685+ 17C2
 686+ 17C2              ; END OF INITIALISATION TABLE ---------------------------------------------------
 687+ 17C2
 688+ 17C2 20 45 72 72  ERRMSG: defb    " Error",0
 688+ 17C6 6F 72 00
 689+ 17C9 20 69 6E 20  INMSG:  defb    " in ",0
 689+ 17CD 00
 690+ 17CE              ZERBYT  equ     $-1             ; A zero byte
 691+ 17CE 4F 6B 0D 00  OKMSG:  defb    "Ok",CR,0,0
 691+ 17D2 00
 692+ 17D3 42 72 65 61  BRKMSG: defb    "Break",0
 692+ 17D7 6B 00
 693+ 17D9
 694+ 17D9 21 04 00     BAKSTK: ld      HL,$04          ; Look for "FOR" block with
 695+ 17DC 39                   add     HL,SP           ; same index as specified
 696+ 17DD 7E           LOKFOR: ld      A,(HL)          ; Get block ID
 697+ 17DE 23                   inc     HL              ; Point to index address
 698+ 17DF FE 81                cp      ZFOR            ; Is it a "FOR" token
 699+ 17E1 C0                   ret     NZ              ; No - exit
 700+ 17E2 4E                   ld      C,(HL)          ; BC = Address of "FOR" index
 701+ 17E3 23                   inc     HL
 702+ 17E4 46                   ld      B,(HL)
 703+ 17E5 23                   inc     HL              ; Point to sign of STEP
 704+ 17E6 E5                   push    HL              ; Save pointer to sign
 705+ 17E7 69                   ld      L,C             ; HL = address of "FOR" index
 706+ 17E8 60                   ld      H,B
 707+ 17E9 7A                   ld      A,D             ; See if an index was specified
 708+ 17EA B3                   or      E               ; DE = 0 if no index specified
 709+ 17EB EB                   ex      DE,HL           ; Specified index into HL
 710+ 17EC CA F3 17             jp      Z,INDFND        ; Skip if no index given
 711+ 17EF EB                   ex      DE,HL           ; Index back into DE
 712+ 17F0 CD 48 1B             call    CPDEHL          ; Compare index with one given
 713+ 17F3 01 0D 00     INDFND: ld      BC,16-3         ; Offset to next block
 714+ 17F6 E1                   pop     HL              ; Restore pointer to sign
 715+ 17F7 C8                   ret     Z               ; Return if block found
 716+ 17F8 09                   add     HL,BC           ; Point to next block
 717+ 17F9 C3 DD 17             jp      LOKFOR          ; Keep on looking
 718+ 17FC
 719+ 17FC CD 16 18     MOVUP:  call    ENFMEM          ; See if enough memory
 720+ 17FF C5           MOVSTR: push    BC              ; Save end of source
 721+ 1800 E3                   ex      (SP),HL         ; Swap source and dest" end
 722+ 1801 C1                   pop     BC              ; Get end of destination
 723+ 1802 CD 48 1B     MOVLP:  call    CPDEHL          ; See if list moved
 724+ 1805 7E                   ld      A,(HL)          ; Get byte
 725+ 1806 02                   ld      (BC),A          ; Move it
 726+ 1807 C8                   ret     Z               ; Exit if all done
 727+ 1808 0B                   dec     BC              ; Next byte to move to
 728+ 1809 2B                   dec     HL              ; Next byte to move
 729+ 180A C3 02 18             jp      MOVLP           ; Loop until all bytes moved
 730+ 180D
 731+ 180D E5           CHKSTK: push    HL              ; Save code string address
 732+ 180E 2A EF 55             ld      HL,(ARREND)     ; Lowest free memory
 733+ 1811 06 00                ld      B,$00           ; BC = Number of levels to test
 734+ 1813 09                   add     HL,BC           ; 2 Bytes for each level
 735+ 1814 09                   add     HL,BC
 736+ 1815 3E                   defb    $3E             ; Skip "push HL"
 737+ 1816 E5           ENFMEM: push    HL              ; Save code string address
 738+ 1817 3E D0                ld      A,$D0           ; LOW -48 ; 48 Bytes minimum RAM
 739+ 1819 95                   sub     L
 740+ 181A 6F                   ld      L,A
 741+ 181B 3E FF                ld      A,$FF           ; HIGH (-48) ; 48 Bytes minimum RAM
 742+ 181D 9C                   sbc     A,H
 743+ 181E DA 25 18             jp      C,OMERR         ; Not enough - ?OM Error
 744+ 1821 67                   ld      H,A
 745+ 1822 39                   add     HL,SP           ; Test if stack is overflowed
 746+ 1823 E1                   pop     HL              ; Restore code string address
 747+ 1824 D8                   ret     C               ; Return if enough memory
 748+ 1825 1E 0C        OMERR:  ld      E,OM            ; ?OM Error
 749+ 1827 C3 6A 18             jp      ERROR
 750+ 182A
 751+ 182A
 752+ 182A              ; if in graphics mode, return to text (called by "NOLIN" and "ERROR")
 753+ 182A F5           EXITGM: push    AF              ; store AF
 754+ 182B 3A 97 55             ld      A,(SCR_MODE)    ; check screen mode
 755+ 182E FE 02                cp      $02             ; G2?
 756+ 1830 CA 37 18             jp      Z,LDG1          ; yes, back to G1
 757+ 1833 FE 03                cp      $03             ; G3?
 758+ 1835 20 11                jr      NZ,LDG1ND       ; no, so return
 759+ 1837 E5           LDG1:   push    HL              ; store HL
 760+ 1838 D5                   push    DE              ; store DE
 761+ 1839 11 01 00             ld      DE,$0001        ; sprites set to defaults, G1 mode
 762+ 183C F3                   di                      ; disable INTs
 763+ 183D CD D1 03             call    initVDP         ; initialize VDP with mode pointed by E
 764+ 1840 FB                   ei                      ; re-enable INTs
 765+ 1841 3E 01                ld      A,$01           ; activate the...
 766+ 1843 32 A1 55             ld      (PRNTVIDEO),A   ; ...video buffer...
 767+ 1846 D1                   pop     DE              ; retrieve DE
 768+ 1847 E1                   pop     HL              ; retrieve HL
 769+ 1848 F1           LDG1ND: pop     AF              ; retrieve AF
 770+ 1849 C9                   ret                     ; return to caller
 771+ 184A
 772+ 184A
 773+ 184A 2A 78 55     DATSNR: ld      HL,(DATLIN)     ; Get line of current DATA item
 774+ 184D 22 52 54             ld      (LINEAT),HL     ; Save as current line
 775+ 1850 1E 02        SNERR:  ld      E,SN            ; ?SN Error
 776+ 1852 01                   defb    $01             ; Skip "ld E,DZ"
 777+ 1853 1E 14        DZERR:  ld      E,DZ            ; ?/0 Error
 778+ 1855 01                   defb    $01             ; Skip "ld E,NF"
 779+ 1856 1E 00        NFERR:  ld      E,NF            ; ?NF Error
 780+ 1858 01                   defb    $01             ; Skip "ld E,DD"
 781+ 1859 1E 12        DDERR:  ld      E,DD            ; ?DD Error
 782+ 185B 01                   defb    $01             ; Skip "ld E,UF"
 783+ 185C 1E 22        UFERR:  ld      E,UF            ; ?UF Error
 784+ 185E 01                   defb    $01             ; Skip "ld E,OV
 785+ 185F 1E 0A        OVERR:  ld      E,OV            ; ?OV Error
 786+ 1861 01                   defb    $01             ; Skip "ld E,TM"
 787+ 1862 1E 18        TMERR:  ld      E,TM            ; ?TM Error
 788+ 1864 01                   defb    $01             ; Skip next statement
 789+ 1865 1E 34        IMERR:  ld      E,IM            ; ?Illegal indirect mode error
 790+ 1867 01                   defb    $01             ; Skip next statement
 791+ 1868 1E 36        NRERR:  ld      E,NR            ; ?Device not ready error
 792+ 186A
 793+ 186A CD B2 19     ERROR:  call    CLREG           ; Clear registers and stack
 794+ 186D CD 2A 18             call    EXITGM          ; exit from graphic modes
 795+ 1870 32 48 54             ld      (CTLOFG),A      ; Enable output (A is 0)
 796+ 1873 CD 2D 09             call    CURSOR_ON       ; enable cursor
 797+ 1876 CD 52 20             call    STTLIN          ; Start new line
 798+ 1879 21 45 10             ld      HL,ERRTBL       ; Point to error codes
 799+ 187C 57                   ld      D,A             ; D = 0 (A is 0)
 800+ 187D 3E 3F                ld      A,'?'
 801+ 187F CD 59 1B             call    OUTC            ; Output '?'
 802+ 1882 19                   add     HL,DE           ; Offset to correct error code
 803+ 1883 5E                   ld      E,(HL)          ; load pointer to error message
 804+ 1884 23                   inc     HL              ; by loading LSB,
 805+ 1885 56                   ld      D,(HL)          ; then MSB
 806+ 1886 62 6B                ld      HL,DE           ; load pointer to HL
 807+ 1888 CD 30 27             call    PRS             ; Output error message
 808+ 188B 21 C2 17             ld      HL,ERRMSG       ; "Error" message
 809+ 188E CD 30 27     ERRIN:  call    PRS             ; Output message
 810+ 1891 2A 52 54             ld      HL,(LINEAT)     ; Get line of error
 811+ 1894 11 FE FF             ld      DE,-2           ; Cold start error if -2
 812+ 1897 CD 48 1B             call    CPDEHL          ; See if cold start error
 813+ 189A CA 07 13             jp      Z,CSTART        ; Cold start error - Restart
 814+ 189D 7C                   ld      A,H             ; Was it a direct error?
 815+ 189E A5                   and     L               ; Line = -1 if direct error
 816+ 189F 3C                   inc     A
 817+ 18A0 CA AB 18             jp      Z,PTLN          ; Yes, jump over
 818+ 18A3 E5                   push    HL              ; indirect mode - store HL
 819+ 18A4 2A 52 54             ld      HL,(LINEAT)     ; copy current line number
 820+ 18A7 22 54 54             ld      (HLPLN),HL      ; save in HELP line register
 821+ 18AA E1                   pop     HL              ; retrieve HL
 822+ 18AB C4 C7 31     PTLN:   call    NZ,LINEIN       ; No - output line of error
 823+ 18AE
 824+ 18AE 3E                   defb    $3E             ; Skip "pop BC"
 825+ 18AF C1           POPNOK: pop     BC              ; Drop address in input buffer
 826+ 18B0
 827+ 18B0              ; run into direct mode: print OK and get command
 828+ 18B0 AF           PRNTOK: xor     A               ; Output "Ok" and get command
 829+ 18B1 32 48 54             ld      (CTLOFG),A      ; Enable output
 830+ 18B4 CD 52 20             call    STTLIN          ; Start new line
 831+ 18B7 21 CE 17             ld      HL,OKMSG        ; "Ok" message
 832+ 18BA CD 30 27             call    PRS             ; Output "Ok"
 833+ 18BD CD 2D 09     GETCMD: call    CURSOR_ON       ; enable cursor
 834+ 18C0 3A E7 55             ld      A,(SERIALS_EN)  ; load serial state
 835+ 18C3 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
 836+ 18C5 CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
 837+ 18C8 21 FF FF             ld      HL,-1           ; Flag direct mode
 838+ 18CB 22 52 54             ld      (LINEAT),HL     ; Save as current line
 839+ 18CE CD D0 1A             call    GETLIN          ; Get an input line
 840+ 18D1 DA BD 18             jp      C,GETCMD        ; Get line again if break
 841+ 18D4 CD 97 1D             call    GETCHR          ; Get first character
 842+ 18D7 17                   rla                     ; 8th bit is copied into carry and original carry is copied into bit 0)
 843+ 18D8 DA 50 18             jp      C,SNERR         ; if char >=128 (8th bit set) then raise an error
 844+ 18DB 1F                   rra                     ; recover original char and Carry
 845+ 18DC 3C                   inc     A               ; Test if end of line
 846+ 18DD 3D                   dec     A               ; Without affecting Carry
 847+ 18DE CA BD 18             jp      Z,GETCMD        ; Nothing entered - Get another
 848+ 18E1 F5                   push    AF              ; Save Carry status
 849+ 18E2 3A E7 55             ld      A,(SERIALS_EN)  ; load serial state
 850+ 18E5 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
 851+ 18E7 CC 8F 01             call    Z,A_RTS_OFF      ; yes, set RTS on
 852+ 18EA CD 42 09             call    CURSOR_OFF      ; cursor disabled
 853+ 18ED CD 67 1E             call    ATOH            ; Get line number into DE
 854+ 18F0 D5                   push    DE              ; Save line number
 855+ 18F1 CD E7 19             call    CRUNCH          ; Tokenise rest of line
 856+ 18F4 47                   ld      B,A             ; Length of tokenised line
 857+ 18F5 D1                   pop     DE              ; Restore line number
 858+ 18F6 F1                   pop     AF              ; Restore Carry
 859+ 18F7 D2 77 1D             jp      NC,EXCUTE       ; No line number - Direct mode
 860+ 18FA D5                   push    DE              ; Save line number
 861+ 18FB C5                   push    BC              ; Save length of tokenised line
 862+ 18FC AF                   xor     A
 863+ 18FD 32 7B 55             ld      (LSTBIN),A      ; Clear last byte input
 864+ 1900 CD 97 1D             call    GETCHR          ; Get next character
 865+ 1903 B7                   or      A               ; Set flags
 866+ 1904 F5                   push    AF              ; And save them
 867+ 1905 CD 6C 19             call    SRCHLN          ; Search for line number in DE
 868+ 1908 DA 11 19             jp      C,LINFND        ; Jump if line found
 869+ 190B F1                   pop     AF              ; Get status
 870+ 190C F5                   push    AF              ; And re-save
 871+ 190D CA 16 1F             jp      Z,ULERR         ; Nothing after number - Error
 872+ 1910 B7                   or      A               ; Clear Carry
 873+ 1911 C5           LINFND: push    BC              ; Save address of line in prog
 874+ 1912 D2 28 19             jp      NC,INEWLN       ; Line not found - Insert new
 875+ 1915 EB                   ex      DE,HL           ; Next line address in DE
 876+ 1916 2A EB 55             ld      HL,(PROGND)     ; End of program
 877+ 1919 1A           SFTPRG: ld      A,(DE)          ; Shift rest of program down
 878+ 191A 02                   ld      (BC),A
 879+ 191B 03                   inc     BC              ; Next destination
 880+ 191C 13                   inc     DE              ; Next source
 881+ 191D CD 48 1B             call    CPDEHL          ; All done?
 882+ 1920 C2 19 19             jp      NZ,SFTPRG       ; More to do
 883+ 1923 60                   ld      H,B             ; HL - New end of program
 884+ 1924 69                   ld      L,C
 885+ 1925 22 EB 55             ld      (PROGND),HL     ; Update end of program
 886+ 1928
 887+ 1928 D1           INEWLN: pop     DE              ; Get address of line,
 888+ 1929 F1                   pop     AF              ; Get status
 889+ 192A CA 4F 19             jp      Z,SETPTR        ; No text - Set up pointers
 890+ 192D 2A EB 55             ld      HL,(PROGND)     ; Get end of program
 891+ 1930 E3                   ex      (SP),HL         ; Get length of input line
 892+ 1931 C1                   pop     BC              ; End of program to BC
 893+ 1932 09                   add     HL,BC           ; Find new end
 894+ 1933 E5                   push    HL              ; Save new end
 895+ 1934 CD FC 17             call    MOVUP           ; Make space for line
 896+ 1937 E1                   pop     HL              ; Restore new end
 897+ 1938 22 EB 55             ld      (PROGND),HL     ; Update end of program pointer
 898+ 193B EB                   ex      DE,HL           ; Get line to move up in HL
 899+ 193C 74                   ld      (HL),H          ; Save MSB
 900+ 193D D1                   pop     DE              ; Get new line number
 901+ 193E 23                   inc     HL              ; Skip pointer
 902+ 193F 23                   inc     HL
 903+ 1940 73                   ld      (HL),E          ; Save LSB of line number
 904+ 1941 23                   inc     HL
 905+ 1942 72                   ld      (HL),D          ; Save MSB of line number
 906+ 1943 23                   inc     HL              ; To first byte in line
 907+ 1944 11 DB 54             ld      DE,BUFFER       ; Copy buffer to program
 908+ 1947 1A           MOVBUF: ld      A,(DE)          ; Get source
 909+ 1948 77                   ld      (HL),A          ; Save destinations
 910+ 1949 23                   inc     HL              ; Next source
 911+ 194A 13                   inc     DE              ; Next destination
 912+ 194B B7                   or      A               ; Done?
 913+ 194C C2 47 19             jp      NZ,MOVBUF       ; No - Repeat
 914+ 194F CD 98 19     SETPTR: call    RUNFST          ; Set line pointers
 915+ 1952 23                   inc     HL              ; To LSB of pointer
 916+ 1953 EB                   ex      DE,HL           ; Address to DE
 917+ 1954 62           PTRLP:  ld      H,D             ; Address to HL
 918+ 1955 6B                   ld      L,E
 919+ 1956 7E                   ld      A,(HL)          ; Get LSB of pointer
 920+ 1957 23                   inc     HL              ; To MSB of pointer
 921+ 1958 B6                   or      (HL)            ; Compare with MSB pointer
 922+ 1959 CA BD 18             jp      Z,GETCMD        ; Get command line if end
 923+ 195C 23                   inc     HL              ; To LSB of line number
 924+ 195D 23                   inc     HL              ; Skip line number
 925+ 195E 23                   inc     HL              ; Point to first byte in line
 926+ 195F AF                   xor     A               ; Looking for 00 byte
 927+ 1960 BE           FNDEND: cp      (HL)            ; Found end of line?
 928+ 1961 23                   inc     HL              ; Move to next byte
 929+ 1962 C2 60 19             jp      NZ,FNDEND       ; No - Keep looking
 930+ 1965 EB                   ex      DE,HL           ; Next line address to HL
 931+ 1966 73                   ld      (HL),E          ; Save LSB of pointer
 932+ 1967 23                   inc     HL
 933+ 1968 72                   ld      (HL),D          ; Save MSB of pointer
 934+ 1969 C3 54 19             jp      PTRLP           ; Do next line
 935+ 196C
 936+ 196C 2A D8 54     SRCHLN: ld      HL,(BASTXT)     ; Start of program text
 937+ 196F 44           SRCHLP: ld      B,H             ; BC = Address to look at
 938+ 1970 4D                   ld      C,L
 939+ 1971 7E                   ld      A,(HL)          ; Get address of next line
 940+ 1972 23                   inc     HL
 941+ 1973 B6                   or      (HL)            ; End of program found?
 942+ 1974 2B                   dec     HL
 943+ 1975 C8                   ret     Z               ; Yes - Line not found
 944+ 1976 23                   inc     HL
 945+ 1977 23                   inc     HL
 946+ 1978 7E                   ld      A,(HL)          ; Get LSB of line number
 947+ 1979 23                   inc     HL
 948+ 197A 66                   ld      H,(HL)          ; Get MSB of line number
 949+ 197B 6F                   ld      L,A
 950+ 197C CD 48 1B             call    CPDEHL          ; Compare with line in DE
 951+ 197F 60                   ld      H,B             ; HL = Start of this line
 952+ 1980 69                   ld      L,C
 953+ 1981 7E                   ld      A,(HL)          ; Get LSB of next line address
 954+ 1982 23                   inc     HL
 955+ 1983 66                   ld      H,(HL)          ; Get MSB of next line address
 956+ 1984 6F                   ld      L,A             ; Next line to HL
 957+ 1985 3F                   ccf
 958+ 1986 C8                   ret     Z               ; Lines found - Exit
 959+ 1987 3F                   ccf
 960+ 1988 D0                   ret     NC              ; Line not found,at line after
 961+ 1989 C3 6F 19             jp      SRCHLP          ; Keep looking
 962+ 198C
 963+ 198C C0           NEW:    ret     NZ              ; Return if any more on line
 964+ 198D 2A D8 54     CLRPTR: ld      HL,(BASTXT)     ; Point to start of program
 965+ 1990 AF                   xor     A               ; Set program area to empty
 966+ 1991 77                   ld      (HL),A          ; Save LSB = 00
 967+ 1992 23                   inc     HL
 968+ 1993 77                   ld      (HL),A          ; Save MSB = 00
 969+ 1994 23                   inc     HL
 970+ 1995 22 EB 55             ld      (PROGND),HL     ; Set program end
 971+ 1998
 972+ 1998 2A D8 54     RUNFST: ld      HL,(BASTXT)     ; Clear all variables
 973+ 199B 2B                   dec     HL
 974+ 199C
 975+ 199C 22 7D 55     INTVAR: ld      (BRKLIN),HL     ; Initialise RUN variables
 976+ 199F 2A 39 55             ld      HL,(LSTRAM)     ; Get end of RAM
 977+ 19A2 22 72 55             ld      (STRBOT),HL     ; Clear string space
 978+ 19A5 AF                   xor     A
 979+ 19A6 CD A7 1D             call    RESTOR          ; Reset DATA pointers
 980+ 19A9 2A EB 55             ld      HL,(PROGND)     ; Get end of program
 981+ 19AC 22 ED 55             ld      (VAREND),HL     ; Clear variables
 982+ 19AF 22 EF 55             ld      (ARREND),HL     ; Clear arrays
 983+ 19B2
 984+ 19B2 C1           CLREG:  pop     BC              ; Save return address
 985+ 19B3 2A 50 54             ld      HL,(STRSPC)     ; Get end of working RAM
 986+ 19B6 F9                   ld      SP,HL           ; Set stack
 987+ 19B7 21 62 55             ld      HL,TMSTPL       ; Temporary string pool
 988+ 19BA 22 60 55             ld      (TMSTPT),HL     ; Reset temporary string ptr
 989+ 19BD AF                   xor     A               ; A = 00
 990+ 19BE 6F                   ld      L,A             ; HL = 0000
 991+ 19BF 67                   ld      H,A
 992+ 19C0 22 83 55             ld      (CONTAD),HL     ; No CONTinue
 993+ 19C3 32 7A 55             ld      (FORFLG),A      ; Clear FOR flag
 994+ 19C6 22 F3 55             ld      (FNRGNM),HL     ; Clear FN argument
 995+ 19C9 E5                   push    HL              ; HL = 0000
 996+ 19CA C5                   push    BC              ; Put back return
 997+ 19CB 2A 7D 55     DOAGN:  ld      HL,(BRKLIN)     ; Get address of code to RUN
 998+ 19CE C9                   ret                     ; Return to execution driver
 999+ 19CF
1000+ 19CF 3E 3F        PROMPT: ld      A,'?'           ; '?'
1001+ 19D1 CD 59 1B             call    OUTC            ; Output character
1002+ 19D4 3E 00                ld      A,NLLCR         ; null char
1003+ 19D6 CD 59 1B             call    OUTC            ; Output character
1004+ 19D9 CD 2D 09             call    CURSOR_ON       ; enable cursor
1005+ 19DC 3A E7 55             ld      A,(SERIALS_EN)  ; load serial state
1006+ 19DF EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
1007+ 19E1 CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
1008+ 19E4 C3 4D 54             jp      RINPUT          ; Get input line
1009+ 19E7
1010+ 19E7 AF           CRUNCH: xor     A               ; Tokenise line @ HL to BUFFER
1011+ 19E8 32 38 55             ld      (DATFLG),A      ; Reset literal flag
1012+ 19EB 0E 05                ld      C,2+3           ; 2 byte number and 3 nulls
1013+ 19ED 11 DB 54             ld      DE,BUFFER       ; Start of input buffer
1014+ 19F0 7E           CRNCLP: ld      A,(HL)          ; Get byte
1015+ 19F1 FE 20                cp      SPC             ; Is it a space?
1016+ 19F3 CA 6F 1A             jp      Z,MOVDIR        ; Yes - Copy direct
1017+ 19F6 47                   ld      B,A             ; Save character
1018+ 19F7 FE 22                cp      $22             ; '"'             ; Is it a quote?
1019+ 19F9 CA 8F 1A             jp      Z,CPYLIT        ; Yes - Copy literal string
1020+ 19FC B7                   or      A               ; Is it end of buffer?
1021+ 19FD CA 96 1A             jp      Z,ENDBUF        ; Yes - End buffer
1022+ 1A00 3A 38 55             ld      A,(DATFLG)      ; Get data type
1023+ 1A03 B7                   or      A               ; Literal?
1024+ 1A04 7E                   ld      A,(HL)          ; Get byte to copy
1025+ 1A05 C2 6F 1A             jp      NZ,MOVDIR       ; Literal - Copy direct
1026+ 1A08 FE 3F                cp      '?'             ; Is it '?' short for PRINT
1027+ 1A0A 3E B3                ld      A,ZPRINT        ; "PRINT" token
1028+ 1A0C CA 6F 1A             jp      Z,MOVDIR        ; Yes - replace it
1029+ 1A0F 7E                   ld      A,(HL)          ; Get byte again
1030+ 1A10 FE 30                cp      '0'             ; Is it less than '0'
1031+ 1A12 DA 1A 1A             jp      C,FNDWRD        ; Yes - Look for reserved words
1032+ 1A15 FE 3C                cp      $3C  ;60; ";"+1       ; Is it "0123456789:;" ?
1033+ 1A17 DA 6F 1A             jp      C,MOVDIR        ; Yes - copy it direct
1034+ 1A1A D5           FNDWRD: push    DE              ; Look for reserved words
1035+ 1A1B 11 AE 14             ld      DE,WORDS-1      ; Point to table
1036+ 1A1E C5                   push    BC              ; Save count
1037+ 1A1F 01 6B 1A             ld      BC,RETNAD       ; Where to return to
1038+ 1A22 C5                   push    BC              ; Save return address
1039+ 1A23 06 7F                ld      B,ZEND-1        ; First token value -1
1040+ 1A25 7E                   ld      A,(HL)          ; Get byte
1041+ 1A26 FE 61                cp      'a'             ; Less than 'a' ?
1042+ 1A28 DA 33 1A             jp      C,SEARCH        ; Yes - search for words
1043+ 1A2B FE 7B                cp      'z'+1           ; Greater than 'z' ?
1044+ 1A2D D2 33 1A             jp      NC,SEARCH       ; Yes - search for words
1045+ 1A30 E6 5F                and     %01011111       ; Force upper case
1046+ 1A32 77                   ld      (HL),A          ; Replace byte
1047+ 1A33 4E           SEARCH: ld      C,(HL)          ; Search for a word
1048+ 1A34 EB                   ex      DE,HL
1049+ 1A35 23           GETNXT: inc     HL              ; Get next reserved word
1050+ 1A36 B6                   or      (HL)            ; Start of word?
1051+ 1A37 F2 35 1A             jp      P,GETNXT        ; No - move on
1052+ 1A3A 04                   inc     B               ; Increment token value
1053+ 1A3B 7E                   ld      A,(HL)          ; Get byte from table
1054+ 1A3C E6 7F                and     %01111111       ; Strip bit 7
1055+ 1A3E C8                   ret     Z               ; Return if end of list
1056+ 1A3F B9                   cp      C               ; Same character as in buffer?
1057+ 1A40 C2 35 1A             jp      NZ,GETNXT       ; No - get next word
1058+ 1A43 EB                   ex      DE,HL
1059+ 1A44 E5                   push    HL              ; Save start of word
1060+ 1A45
1061+ 1A45 13           NXTBYT: inc     DE              ; Look through rest of word
1062+ 1A46 1A                   ld      A,(DE)          ; Get byte from table
1063+ 1A47 B7                   or      A               ; End of word ?
1064+ 1A48 FA 67 1A             jp      M,MATCH         ; Yes - Match found
1065+ 1A4B 4F                   ld      C,A             ; Save it
1066+ 1A4C 78                   ld      A,B             ; Get token value
1067+ 1A4D FE 88                cp      ZGOTO           ; Is it "GOTO" token ?
1068+ 1A4F C2 56 1A             jp      NZ,NOSPC        ; No - Don't allow spaces
1069+ 1A52 CD 97 1D             call    GETCHR          ; Get next character
1070+ 1A55 2B                   dec     HL              ; Cancel increment from GETCHR
1071+ 1A56 23           NOSPC:  inc     HL              ; Next byte
1072+ 1A57 7E                   ld      A,(HL)          ; Get byte
1073+ 1A58 FE 61                cp      'a'             ; Less than 'a' ?
1074+ 1A5A DA 5F 1A             jp      C,NOCHNG        ; Yes - don't change
1075+ 1A5D E6 5F                and     %01011111       ; Make upper case
1076+ 1A5F B9           NOCHNG: cp      C               ; Same as in buffer ?
1077+ 1A60 CA 45 1A             jp      Z,NXTBYT        ; Yes - keep testing
1078+ 1A63 E1                   pop     HL              ; Get back start of word
1079+ 1A64 C3 33 1A             jp      SEARCH          ; Look at next word
1080+ 1A67
1081+ 1A67 48           MATCH:  ld      C,B             ; Word found - Save token value
1082+ 1A68 F1                   pop     AF              ; Throw away return
1083+ 1A69 EB                   ex      DE,HL
1084+ 1A6A C9                   ret                     ; Return to "RETNAD"
1085+ 1A6B EB           RETNAD: ex      DE,HL           ; Get address in string
1086+ 1A6C 79                   ld      A,C             ; Get token value
1087+ 1A6D C1                   pop     BC              ; Restore buffer length
1088+ 1A6E D1                   pop     DE              ; Get destination address
1089+ 1A6F 23           MOVDIR: inc     HL              ; Next source in buffer
1090+ 1A70 12                   ld      (DE),A          ; Put byte in buffer
1091+ 1A71 13                   inc     DE              ; Move up buffer
1092+ 1A72 0C                   inc     C               ; Increment length of buffer
1093+ 1A73 D6 3A                sub     ':'             ; End of statement?
1094+ 1A75 CA 7D 1A             jp      Z,SETLIT        ; Jump if multi-statement line
1095+ 1A78 FE 49                cp      ZDATA-$3A       ; Is it DATA statement ?
1096+ 1A7A C2 80 1A             jp      NZ,TSTREM       ; No - see if REM
1097+ 1A7D 32 38 55     SETLIT: ld      (DATFLG),A      ; Set literal flag
1098+ 1A80 D6 54        TSTREM: sub     ZREM-$3A        ; Is it REM?
1099+ 1A82 C2 F0 19             jp      NZ,CRNCLP       ; No - Leave flag
1100+ 1A85 47                   ld      B,A             ; Copy rest of buffer
1101+ 1A86 7E           NXTCHR: ld      A,(HL)          ; Get byte
1102+ 1A87 B7                   or      A               ; End of line ?
1103+ 1A88 CA 96 1A             jp      Z,ENDBUF        ; Yes - Terminate buffer
1104+ 1A8B B8                   cp      B               ; End of statement ?
1105+ 1A8C CA 6F 1A             jp      Z,MOVDIR        ; Yes - Get next one
1106+ 1A8F 23           CPYLIT: inc     HL              ; Move up source string
1107+ 1A90 12                   ld      (DE),A          ; Save in destination
1108+ 1A91 0C                   inc     C               ; Increment length
1109+ 1A92 13                   inc     DE              ; Move up destination
1110+ 1A93 C3 86 1A             jp      NXTCHR          ; Repeat
1111+ 1A96
1112+ 1A96 21 DA 54     ENDBUF: ld      HL,BUFFER-1     ; Point to start of buffer
1113+ 1A99 12                   ld      (DE),A          ; Mark end of buffer (A = 00)
1114+ 1A9A 13                   inc     DE
1115+ 1A9B 12                   ld      (DE),A          ; A = 00
1116+ 1A9C 13                   inc     DE
1117+ 1A9D 12                   ld      (DE),A          ; A = 00
1118+ 1A9E C9                   ret
1119+ 1A9F
1120+ 1A9F 3A 47 54     DODEL:  ld      A,(NULFLG)      ; Get null flag status
1121+ 1AA2 B7                   or      A               ; Is it zero?
1122+ 1AA3 3E 00                ld      A,$00           ; Zero A - Leave flags
1123+ 1AA5 32 47 54             ld      (NULFLG),A      ; Zero null flag
1124+ 1AA8 C2 B3 1A             jp      NZ,ECHDEL       ; Set - Echo it
1125+ 1AAB 05                   dec     B               ; Decrement length
1126+ 1AAC CA D0 1A             jp      Z,GETLIN        ; Get line again if empty
1127+ 1AAF CD 59 1B             call    OUTC            ; Output null character
1128+ 1AB2 3E                   defb    $3E             ; Skip "dec B"
1129+ 1AB3 05           ECHDEL: dec     B               ; Count bytes in buffer
1130+ 1AB4 2B                   dec     HL              ; Back space buffer
1131+ 1AB5 CA C7 1A             jp      Z,OTKLN         ; No buffer - Try again
1132+ 1AB8 7E                   ld      A,(HL)          ; Get deleted byte
1133+ 1AB9 CD 59 1B             call    OUTC            ; Echo it
1134+ 1ABC C3 D9 1A             jp      MORINP          ; Get more input
1135+ 1ABF
1136+ 1ABF 05           DELCHR: dec     B               ; Count bytes in buffer
1137+ 1AC0 2B                   dec     HL              ; Back space buffer
1138+ 1AC1 CD 59 1B             call    OUTC            ; Output character in A
1139+ 1AC4 C2 D9 1A             jp      NZ,MORINP       ; Not end - Get more
1140+ 1AC7 CD 59 1B     OTKLN:  call    OUTC            ; Output character in A
1141+ 1ACA CD 64 20     KILIN:  call    PRNTCRLF        ; Output CRLF
1142+ 1ACD C3 D0 1A             jp      TTYLIN          ; Get line again
1143+ 1AD0
1144+ 1AD0              GETLIN:
1145+ 1AD0 21 DB 54     TTYLIN: ld      HL,BUFFER       ; Get a line by character
1146+ 1AD3 06 01                ld      B,$01           ; Set buffer as empty
1147+ 1AD5 AF                   xor     A
1148+ 1AD6 32 47 54             ld      (NULFLG),A      ; Clear null flag
1149+ 1AD9 CD 9A 1B     MORINP: call    CLOTST          ; Get character and test ^O
1150+ 1ADC 4F                   ld      C,A             ; Save character in C
1151+ 1ADD FE 7F                cp      DEL             ; Delete character?
1152+ 1ADF CA 9F 1A             jp      Z,DODEL         ; Yes - Process it
1153+ 1AE2 3A 47 54             ld      A,(NULFLG)      ; Get null flag
1154+ 1AE5 B7                   or      A               ; Test null flag status
1155+ 1AE6 CA F0 1A             jp      Z,PROCES        ; Reset - Process character
1156+ 1AE9 AF                   xor     A               ; Clear A
1157+ 1AEA 32 47 54             ld      (NULFLG),A      ; Reset null flag
1158+ 1AED CD 59 1B             call    OUTC            ; Output null
1159+ 1AF0 79           PROCES: ld      A,C             ; Get character
1160+ 1AF1 FE 07                cp      CTRLG           ; Bell?
1161+ 1AF3 CA 30 1B             jp      Z,PUTCTL        ; Yes - Save it
1162+ 1AF6 FE 03                cp      CTRLC           ; Is it control "C"?
1163+ 1AF8 CC 25 1B             call    Z,GMNCR         ; Yes - exit from graphic mode & Output CRLF
1164+ 1AFB 37                   scf                     ; Flag break
1165+ 1AFC C8                   ret     Z               ; Return if control "C"
1166+ 1AFD FE 0D                cp      CR              ; Is it enter?
1167+ 1AFF CA 5A 20             jp      Z,ENDINP        ; Yes - Terminate input
1168+ 1B02 FE 15                cp      CTRLU           ; Is it control "U"?
1169+ 1B04 CA CA 1A             jp      Z,KILIN         ; Yes - Get another line
1170+ 1B07 FE 08                cp      BKSP            ; Is it backspace?
1171+ 1B09 CA BF 1A             jp      Z,DELCHR        ; Yes - Delete character
1172+ 1B0C FE 12                cp      CTRLR           ; Is it control "R"?
1173+ 1B0E C2 2B 1B             jp      NZ,PUTBUF       ; No - Put in buffer
1174+ 1B11 C5                   push    BC              ; Save buffer length
1175+ 1B12 D5                   push    DE              ; Save DE
1176+ 1B13 E5                   push    HL              ; Save buffer address
1177+ 1B14 36 00                ld      (HL),$00        ; Mark end of buffer
1178+ 1B16 CD 5B 41             call    OUTNCR          ; Output and do CRLF
1179+ 1B19 21 DB 54             ld      HL,BUFFER       ; Point to buffer start
1180+ 1B1C CD 30 27             call    PRS             ; Output buffer
1181+ 1B1F E1                   pop     HL              ; Restore buffer address
1182+ 1B20 D1                   pop     DE              ; Restore DE
1183+ 1B21 C1                   pop     BC              ; Restore buffer length
1184+ 1B22 C3 D9 1A             jp      MORINP          ; Get another character
1185+ 1B25 CD 2A 18     GMNCR:  call    EXITGM          ; exit from graphic mode
1186+ 1B28 C3 64 20             jp      PRNTCRLF        ; output CRLF
1187+ 1B2B
1188+ 1B2B FE 20        PUTBUF: cp      SPC             ; Is it a control code?
1189+ 1B2D DA D9 1A             jp      C,MORINP        ; Yes - Ignore
1190+ 1B30 78           PUTCTL: ld      A,B             ; Get number of bytes in buffer
1191+ 1B31 FE 59                cp      $58+$01         ; Test for line overflow
1192+ 1B33 3E 08                ld      A,BKSP          ; Set a bell
1193+ 1B35 D2 42 1B             jp      NC,OUTNBS       ; Ring bell if buffer full
1194+ 1B38 79                   ld      A,C             ; Get character
1195+ 1B39 71                   ld      (HL),C          ; Save in buffer
1196+ 1B3A 32 7B 55             ld      (LSTBIN),A      ; Save last input byte
1197+ 1B3D 23                   inc     HL              ; Move up buffer
1198+ 1B3E 04                   inc     B               ; Increment length
1199+ 1B3F C3 D9 1A     OUTIT:  jp      MORINP          ; Get another character
1200+ 1B42
1201+ 1B42 CD 59 1B     OUTNBS: call    OUTC            ; Output bell and back over it
1202+ 1B45 C3 3F 1B             jp      OUTIT           ; get more chars
1203+ 1B48
1204+ 1B48 7C           CPDEHL: ld      A,H             ; Get H
1205+ 1B49 92                   sub     D               ; Compare with D
1206+ 1B4A C0                   ret     NZ              ; Different - Exit
1207+ 1B4B 7D                   ld      A,L             ; Get L
1208+ 1B4C 93                   sub     E               ; Compare with E
1209+ 1B4D C9                   ret                     ; Return status
1210+ 1B4E
1211+ 1B4E 7E           CHKSYN: ld      A,(HL)          ; Check syntax of character
1212+ 1B4F E3                   ex      (SP),HL         ; Address of test byte
1213+ 1B50 BE                   cp      (HL)            ; Same as in code string?
1214+ 1B51 23                   inc     HL              ; Return address
1215+ 1B52 E3                   ex      (SP),HL         ; Put it back
1216+ 1B53 CA 97 1D             jp      Z,GETCHR        ; Yes - Get next character
1217+ 1B56 C3 50 18             jp      SNERR           ; Different - ?SN Error
1218+ 1B59
1219+ 1B59 F5           OUTC:   push    AF              ; Save character
1220+ 1B5A 3A 48 54             ld      A,(CTLOFG)      ; Get control "O" flag
1221+ 1B5D B7                   or      A               ; Is it set?
1222+ 1B5E C2 65 27             jp      NZ,POPAF        ; Yes - don't output
1223+ 1B61 F1                   pop     AF              ; Restore character
1224+ 1B62 C5                   push    BC              ; Save buffer length
1225+ 1B63 F5                   push    AF              ; Save character
1226+ 1B64 FE 20                cp      SPC             ; Is it a control code?
1227+ 1B66 DA 7D 1B             jp      C,DINPOS        ; Yes - Don't inc POS(X)
1228+ 1B69 3A 45 54             ld      A,(LWIDTH)      ; Get line width
1229+ 1B6C 47                   ld      B,A             ; To B
1230+ 1B6D 3A 35 55             ld      A,(CURPOS)      ; Get cursor position
1231+ 1B70 04                   inc     B               ; Width 255?
1232+ 1B71 CA 79 1B             jp      Z,INCLEN        ; Yes - No width limit
1233+ 1B74 05                   dec     B               ; Restore width
1234+ 1B75 B8                   cp      B               ; At end of line?
1235+ 1B76 CC 64 20             call    Z,PRNTCRLF      ; Yes - output CRLF
1236+ 1B79 3C           INCLEN: inc     A               ; Move on one character
1237+ 1B7A 32 35 55             ld      (CURPOS),A      ; Save new position
1238+ 1B7D AF           DINPOS: xor     A
1239+ 1B7E 32 DF 55             ld      (KBDNPT),A      ; set flag for no char from keyboard
1240+ 1B81 F1                   pop     AF              ; Restore character
1241+ 1B82 C1                   pop     BC              ; Restore buffer length
1242+ 1B83 F5                   push    AF
1243+ 1B84 CD 8C 1B             call    SND2VID         ; send char to video
1244+ 1B87 F1                   pop     AF
1245+ 1B88 CD 30 41             call    MONOUT          ; send char to serial if enabled
1246+ 1B8B C9                   ret
1247+ 1B8C
1248+ 1B8C              ; print char to video if cursor is on
1249+ 1B8C 32 A2 55     SND2VID:ld      (CHR4VID),A     ; store A
1250+ 1B8F 3A A1 55             ld      A,(PRNTVIDEO)   ; check print-on-video
1251+ 1B92 B7                   or      A               ; is it off?
1252+ 1B93 C8                   ret     Z               ; yes, so return
1253+ 1B94 F3                   di                      ; disable INTs
1254+ 1B95 CD 61 07             call    CHAR2VID        ; cursor is on, so print char on screen
1255+ 1B98 FB                   ei                      ; re-enable INTs
1256+ 1B99 C9                   ret                     ; return to caller
1257+ 1B9A
1258+ 1B9A CD EA 34     CLOTST: call    GETINP          ; Get input character
1259+ 1B9D FE 0F                cp      CTRLO           ; Is it control "O"?
1260+ 1B9F C0                   ret     NZ              ; No don't flip flag
1261+ 1BA0 3A 48 54             ld      A,(CTLOFG)      ; Get flag
1262+ 1BA3 2F                   cpl                     ; Flip it
1263+ 1BA4 32 48 54             ld      (CTLOFG),A      ; Put it back
1264+ 1BA7 A7                   and     A               ; is output enabled?
1265+ 1BA8 CC 2D 09             call    Z,CURSOR_ON     ; yes, so cursor on
1266+ 1BAB 3A E7 55             ld      A,(SERIALS_EN)  ; load serial state
1267+ 1BAE EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
1268+ 1BB0 CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
1269+ 1BB3 AF                   xor     A               ; Null character
1270+ 1BB4 C9                   ret
1271+ 1BB5
1272+ 1BB5              ; LIST: list the program stored into memory
1273+ 1BB5 C1           LIST:   pop     BC              ; rubbish - not needed (legacy from original call of LIST)
1274+ 1BB6 2B                   dec     HL              ; dec 'cos GETCHR INCs
1275+ 1BB7 CD 97 1D             call    GETCHR          ; Get next character
1276+ 1BBA CA 10 1C             jp      Z,LSTALL        ; list all if nothing follows
1277+ 1BBD FE C2                cp      ZMINUS          ; is it '-'?
1278+ 1BBF 20 20                jr      NZ,LST01        ; no, look for a line number
1279+ 1BC1 11 00 00             ld      DE,$0000        ; yes, set search from 0
1280+ 1BC4 CD B1 1C             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1281+ 1BC7 ED 43 A5 55          ld      (TMPBFR1),BC    ; store address of starting line
1282+ 1BCB CD 4E 1B             call    CHKSYN          ; skip '-'
1283+ 1BCE C2                   defb    ZMINUS
1284+ 1BCF CD 67 1E             call    ATOH            ; now, look for another number (ASCII number to DE)
1285+ 1BD2 CD B7 1C             call    SRCLN           ; find a line, getting the previous if it doesn't exist
1286+ 1BD5 ED 43 A7 55          ld      (TMPBFR2),BC    ; store address of ending line
1287+ 1BD9 ED 4B A5 55          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1288+ 1BDD C5                   push    BC              ; store address of line for later use
1289+ 1BDE C3 48 1C             jp      LISTLP          ; go listing
1290+ 1BE1 CD 67 1E     LST01:  call    ATOH            ; get a line number (ASCII number to DE)
1291+ 1BE4 ED 53 AB 55  LST01H: ld      (TMPBFR4),DE    ; store ending line address for later use - N.B.: this is a hook for HELP command
1292+ 1BE8 CD B1 1C             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1293+ 1BEB ED 43 A5 55          ld      (TMPBFR1),BC    ; store address of starting line
1294+ 1BEF ED 43 A7 55          ld      (TMPBFR2),BC    ; same address for ending line (we'll change it later if needed)
1295+ 1BF3 2B                   dec     HL              ; dec 'cos GETCHR INCs
1296+ 1BF4 CD 97 1D             call    GETCHR          ; Get next character
1297+ 1BF7 CA 03 1C             jp      Z,LSTNOT        ; nothing follows, so ending & starting lines are the same
1298+ 1BFA FE C2                cp      ZMINUS          ; is it '-'?
1299+ 1BFC CA 28 1C             jp      Z,LST03         ; yes, read ending line
1300+ 1BFF C5           LST06:  push    BC              ; store address for later use
1301+ 1C00 C3 48 1C             jp      LISTLP          ; jump to list
1302+ 1C03 ED 5B AB 55  LSTNOT: ld      DE,(TMPBFR4)
1303+ 1C07 CD B1 1C             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1304+ 1C0A DA FF 1B             jp      C,LST06
1305+ 1C0D C3 B0 18             jp      PRNTOK
1306+ 1C10 11 F9 FF     LSTALL: ld      DE,65529        ; set ending line to max. allowed line number
1307+ 1C13 CD B1 1C             call    SRCHLIN         ; get address of last line
1308+ 1C16 ED 43 A7 55          ld      (TMPBFR2),BC    ; store it
1309+ 1C1A 11 00 00             ld      DE,$0000        ; set start to first line in memory
1310+ 1C1D CD B1 1C             call    SRCHLIN         ; get address of first line
1311+ 1C20 ED 43 A5 55          ld      (TMPBFR1),BC    ; store it
1312+ 1C24 C5                   push    BC              ; store address of starting line for later use
1313+ 1C25 C3 48 1C             jp      LISTLP          ; start printing
1314+ 1C28 CD 4E 1B     LST03:  call    CHKSYN          ; skip '-'
1315+ 1C2B C2                   defb    ZMINUS
1316+ 1C2C CD 67 1E             call    ATOH            ; look for another number (return into DE)
1317+ 1C2F 7A                   ld      A,D
1318+ 1C30 B3                   or      E               ; is line=0?
1319+ 1C31 20 09                jr      NZ,LST05        ; no, jump over
1320+ 1C33 11 F9 FF             ld      DE,65529        ; yes set last valid line number
1321+ 1C36 CD B1 1C             call    SRCHLIN         ; get address of last line
1322+ 1C39 C3 3F 1C             jp      LST02
1323+ 1C3C CD B7 1C     LST05:  call    SRCLN           ; find a line, getting the previous if it doesn't exist
1324+ 1C3F ED 43 A7 55  LST02:  ld      (TMPBFR2),BC    ; store address of ending line
1325+ 1C43 ED 4B A5 55          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1326+ 1C47 C5                   push    BC              ; store it for later use
1327+ 1C48 E1           LISTLP: pop     HL              ; Restore address of line
1328+ 1C49 4E                   ld      C,(HL)          ; Get LSB of next line
1329+ 1C4A 23                   inc     HL
1330+ 1C4B 46                   ld      B,(HL)          ; Get MSB of next line
1331+ 1C4C 23                   inc     HL
1332+ 1C4D 78                   ld      A,B             ; BC = 0 (End of program)?
1333+ 1C4E B1                   or      C
1334+ 1C4F CA B0 18             jp      Z,PRNTOK        ; Yes - Go to command mode
1335+ 1C52 CD C2 1D             call    TSTBRK          ; Test for break key
1336+ 1C55 CD C5 1C             call    TSTSPC          ; test for space
1337+ 1C58 C5                   push    BC              ; Save address of next line
1338+ 1C59 3A 9A 55             ld      A,(SCR_CURS_X)  ; load current X pos of cursor
1339+ 1C5C A7                   and     A               ; is it at the beginning of a new line?
1340+ 1C5D 20 0B                jr      NZ,LST08        ; No, jump over
1341+ 1C5F 3E 0D                ld      A,CR            ; yes, so just send a CR
1342+ 1C61 CD 30 41             call    MONOUT          ; to serial if it's open
1343+ 1C64 AF                   xor     A               ; then, set cursor
1344+ 1C65 32 35 55             ld      (CURPOS),A      ; to position 0
1345+ 1C68 18 03                jr      LST07           ; and continue
1346+ 1C6A CD 64 20     LST08:  call    PRNTCRLF        ; output CRLF
1347+ 1C6D 5E           LST07:  ld      E,(HL)          ; Get LSB of line number
1348+ 1C6E 23                   inc     HL
1349+ 1C6F 56                   ld      D,(HL)          ; Get MSB of line number
1350+ 1C70 23                   inc     HL
1351+ 1C71 E5                   push    HL              ; Save address of line start
1352+ 1C72 EB                   ex      DE,HL           ; Line number to HL
1353+ 1C73 CD CF 31             call    PRNTHL          ; Output line number in decimal
1354+ 1C76 3E 20                ld      A,SPC           ; Space after line number
1355+ 1C78 E1                   pop     HL              ; Restore start of line address
1356+ 1C79 CD 59 1B     LSTLP2: call    OUTC            ; Output character in A
1357+ 1C7C 7E           LSTLP3: ld      A,(HL)          ; Get next byte in line
1358+ 1C7D B7                   or      A               ; End of line?
1359+ 1C7E 23                   inc     HL              ; To next byte in line
1360+ 1C7F CA A3 1C             jp      Z,NXTLN         ; Yes - check next line
1361+ 1C82 F2 79 1C             jp      P,LSTLP2        ; No token - output it
1362+ 1C85 D6 7F                sub     ZEND-1          ; Find and output word
1363+ 1C87 4F                   ld      C,A             ; Token offset+1 to C
1364+ 1C88 11 AF 14             ld      DE,WORDS        ; Reserved word list
1365+ 1C8B 1A           FNDTOK: ld      A,(DE)          ; Get character in list
1366+ 1C8C 13                   inc     DE              ; Move on to next
1367+ 1C8D B7                   or      A               ; Is it start of word?
1368+ 1C8E F2 8B 1C             jp      P,FNDTOK        ; No - Keep looking for word
1369+ 1C91 0D                   dec     C               ; Count words
1370+ 1C92 C2 8B 1C             jp      NZ,FNDTOK       ; Not there - keep looking
1371+ 1C95 E6 7F        OUTWRD: and     %01111111       ; Strip bit 7
1372+ 1C97 CD 59 1B             call    OUTC            ; Output character
1373+ 1C9A 1A                   ld      A,(DE)          ; Get next character
1374+ 1C9B 13                   inc     DE              ; Move on to next
1375+ 1C9C B7                   or      A               ; Is it end of word?
1376+ 1C9D F2 95 1C             jp      P,OUTWRD        ; No - output the rest
1377+ 1CA0 C3 7C 1C             jp      LSTLP3          ; Next byte in line
1378+ 1CA3 D1           NXTLN:  pop     DE              ; recover address of current line
1379+ 1CA4 2A A7 55             ld      HL,(TMPBFR2)    ; address of last line to print
1380+ 1CA7 CD 61 41             call    CMP16           ; check if current line is over last printable line
1381+ 1CAA DA B0 18             jp      C,PRNTOK        ; finish - leave & print OK
1382+ 1CAD D5                   push    DE              ; store address of current line
1383+ 1CAE C3 48 1C             jp      LISTLP          ; continue listing
1384+ 1CB1              ; look for the address of a program line
1385+ 1CB1 E5           SRCHLIN:push    HL              ; store HL (this is needed because HL store the pointer to the input buffer)
1386+ 1CB2 CD 6C 19             call    SRCHLN          ; search for line number in DE
1387+ 1CB5 E1                   pop     HL              ; retrieve HL
1388+ 1CB6 C9                   ret                     ; return to caller
1389+ 1CB7              ; look for the address of a program line - if the line isn't found,
1390+ 1CB7              ; it look backward for the previous line
1391+ 1CB7 E5           SRCLN:  push    HL              ; store HL
1392+ 1CB8 CD 6C 19     SRCLN1: call    SRCHLN          ; search for line in DE
1393+ 1CBB DA C3 1C             jp      C,LVSRLN        ; found it, leave loop
1394+ 1CBE 1B                   dec     DE              ; not found, decrement number to look backward for an existing line
1395+ 1CBF 7B                   ld      A,E
1396+ 1CC0 B2                   or      D               ; is line number zero?
1397+ 1CC1 20 F5                jr      NZ,SRCLN1       ; no, continue
1398+ 1CC3 E1           LVSRLN: pop     HL              ; retrieve HL
1399+ 1CC4 C9                   ret                     ; return to caller
1400+ 1CC5
1401+ 1CC5              ; during LISTing, check if PAUSE is pressed, then pause listing and
1402+ 1CC5              ; wait for another pressing of PAUSE to continue or CTRL-C/BREAK to exit
1403+ 1CC5 3A E1 55     TSTSPC: ld      A,(TMPKEYBFR)   ; Get input character
1404+ 1CC8 FE 20                cp      SPC             ; Is it SPACE?
1405+ 1CCA C0                   ret     NZ              ; No, return
1406+ 1CCB CD EA 34     WTSPC:  call    GETINP          ; Yes, stop listing and wait for another space or BREAK
1407+ 1CCE FE 20                cp      SPC             ; is it SPACE?
1408+ 1CD0 20 05                jr      NZ,CNTWTSP      ; no, continue
1409+ 1CD2 AF                   xor     A
1410+ 1CD3 32 E1 55             ld      (TMPKEYBFR),A   ; reset key
1411+ 1CD6 C9                   ret                     ; return to caller
1412+ 1CD7 FE 03        CNTWTSP:cp      CTRLC           ; is it CTRL-C/BREAK?
1413+ 1CD9 20 F0                jr      NZ,WTSPC        ; no, loop
1414+ 1CDB C3 D9 13             jp      BRKRET          ; exit and output "Ok"
1415+ 1CDE
1416+ 1CDE
1417+ 1CDE 3E 64        FOR:    ld      A,$64           ; Flag "FOR" assignment
1418+ 1CE0 32 7A 55             ld      (FORFLG),A      ; Save "FOR" flag
1419+ 1CE3 CD 57 1F             call    LET             ; Set up initial index
1420+ 1CE6 C1                   pop     BC              ; Drop RETurn address
1421+ 1CE7 E5                   push    HL              ; Save code string address
1422+ 1CE8 CD 40 1F             call    DATA            ; Get next statement address
1423+ 1CEB 22 76 55             ld      (LOOPST),HL     ; Save it for start of loop
1424+ 1CEE 21 02 00             ld      HL,$0002        ; Offset for "FOR" block
1425+ 1CF1 39                   add     HL,SP           ; Point to it
1426+ 1CF2 CD DD 17     FORSLP: call    LOKFOR          ; Look for existing "FOR" block
1427+ 1CF5 D1                   pop     DE              ; Get code string address
1428+ 1CF6 C2 0E 1D             jp      NZ,FORFND       ; No nesting found
1429+ 1CF9 09                   add     HL,BC           ; Move into "FOR" block
1430+ 1CFA D5                   push    DE              ; Save code string address
1431+ 1CFB 2B                   dec     HL
1432+ 1CFC 56                   ld      D,(HL)          ; Get MSB of loop statement
1433+ 1CFD 2B                   dec     HL
1434+ 1CFE 5E                   ld      E,(HL)          ; Get LSB of loop statement
1435+ 1CFF 23                   inc     HL
1436+ 1D00 23                   inc     HL
1437+ 1D01 E5                   push    HL              ; Save block address
1438+ 1D02 2A 76 55             ld      HL,(LOOPST)     ; Get address of loop statement
1439+ 1D05 CD 48 1B             call    CPDEHL          ; Compare the FOR loops
1440+ 1D08 E1                   pop     HL              ; Restore block address
1441+ 1D09 C2 F2 1C             jp      NZ,FORSLP       ; Different FORs - Find another
1442+ 1D0C D1                   pop     DE              ; Restore code string address
1443+ 1D0D F9                   ld      SP,HL           ; Remove all nested loops
1444+ 1D0E
1445+ 1D0E EB           FORFND: ex      DE,HL           ; Code string address to HL
1446+ 1D0F 0E 08                ld      C,$08
1447+ 1D11 CD 0D 18             call    CHKSTK          ; Check for 8 levels of stack
1448+ 1D14 E5                   push    HL              ; Save code string address
1449+ 1D15 2A 76 55             ld      HL,(LOOPST)     ; Get first statement of loop
1450+ 1D18 E3                   ex      (SP),HL         ; Save and restore code string
1451+ 1D19 E5                   push    HL              ; Re-save code string address
1452+ 1D1A 2A 52 54             ld      HL,(LINEAT)     ; Get current line number
1453+ 1D1D E3                   ex      (SP),HL         ; Save and restore code string
1454+ 1D1E CD 2B 22             call    TSTNUM          ; Make sure it's a number
1455+ 1D21 CD 4E 1B             call    CHKSYN          ; Make sure "TO" is next
1456+ 1D24 BB                   defb    ZTO             ; "TO" token
1457+ 1D25 CD 28 22             call    GETNUM          ; Get "TO" expression value
1458+ 1D28 E5                   push    HL              ; Save code string address
1459+ 1D29 CD 81 30             call    BCDEFP          ; Move "TO" value to BCDE
1460+ 1D2C E1                   pop     HL              ; Restore code string address
1461+ 1D2D C5                   push    BC              ; Save "TO" value in block
1462+ 1D2E D5                   push    DE
1463+ 1D2F 01 00 81             ld      BC,$8100        ; BCDE - 1 (default STEP)
1464+ 1D32 51                   ld      D,C             ; C=0
1465+ 1D33 5A                   ld      E,D             ; D=0
1466+ 1D34 7E                   ld      A,(HL)          ; Get next byte in code string
1467+ 1D35 FE C0                cp      ZSTEP           ; See if "STEP" is stated
1468+ 1D37 3E 01                ld      A,$01           ; Sign of step = 1
1469+ 1D39 C2 4A 1D             jp      NZ,SAVSTP       ; No STEP given - Default to 1
1470+ 1D3C CD 97 1D             call    GETCHR          ; Jump over "STEP" token
1471+ 1D3F CD 28 22             call    GETNUM          ; Get step value
1472+ 1D42 E5                   push    HL              ; Save code string address
1473+ 1D43 CD 81 30             call    BCDEFP          ; Move STEP to BCDE
1474+ 1D46 CD 35 30             call    TSTSGN          ; Test sign of FPREG
1475+ 1D49 E1                   pop     HL              ; Restore code string address
1476+ 1D4A C5           SAVSTP: push    BC              ; Save the STEP value in block
1477+ 1D4B D5                   push    DE
1478+ 1D4C F5                   push    AF              ; Save sign of STEP
1479+ 1D4D 33                   inc     SP              ; Don't save flags
1480+ 1D4E E5                   push    HL              ; Save code string address
1481+ 1D4F 2A 7D 55             ld      HL,(BRKLIN)     ; Get address of index variable
1482+ 1D52 E3                   ex      (SP),HL         ; Save and restore code string
1483+ 1D53 06 81        PUTFID: ld      B,ZFOR          ; "FOR" block marker
1484+ 1D55 C5                   push    BC              ; Save it
1485+ 1D56 33                   inc     SP              ; Don't save C
1486+ 1D57
1487+ 1D57 CD C2 1D     RUNCNT: call    TSTBRK          ; Execution driver - Test break
1488+ 1D5A 22 7D 55             ld      (BRKLIN),HL     ; Save code address for break
1489+ 1D5D 7E                   ld      A,(HL)          ; Get next byte in code string
1490+ 1D5E FE 3A                cp      ':'             ; Multi statement line?
1491+ 1D60 CA 77 1D             jp      Z,EXCUTE        ; Yes - Execute it
1492+ 1D63 B7                   or      A               ; End of line?
1493+ 1D64 C2 50 18             jp      NZ,SNERR        ; No - Syntax error
1494+ 1D67 23                   inc     HL              ; Point to address of next line
1495+ 1D68 7E                   ld      A,(HL)          ; Get LSB of line pointer
1496+ 1D69 23                   inc     HL
1497+ 1D6A B6                   or      (HL)            ; Is it zero (End of prog)?
1498+ 1D6B CA E9 1D             jp      Z,ENDPRG        ; Yes - Terminate execution
1499+ 1D6E 23                   inc     HL              ; Point to line number
1500+ 1D6F 5E                   ld      E,(HL)          ; Get LSB of line number
1501+ 1D70 23                   inc     HL
1502+ 1D71 56                   ld      D,(HL)          ; Get MSB of line number
1503+ 1D72 EB                   ex      DE,HL           ; Line number to HL
1504+ 1D73 22 52 54             ld      (LINEAT),HL     ; Save as current line number
1505+ 1D76 EB                   ex      DE,HL           ; Line number back to DE
1506+ 1D77 CD 97 1D     EXCUTE: call    GETCHR          ; Get key word
1507+ 1D7A 11 57 1D             ld      DE,RUNCNT       ; Where to RETurn to
1508+ 1D7D D5                   push    DE              ; Save for RETurn
1509+ 1D7E C8           IFJMP:  ret     Z               ; Go to RUNCNT if end of STMT
1510+ 1D7F
1511+ 1D7F D6 80        ONJMP:  sub     ZEND            ; Is it a token?
1512+ 1D81 DA 57 1F             jp      C,LET           ; No - try to assign it
1513+ 1D84 FE 3A                cp      ZNEW+1-ZEND     ; END to NEW ?
1514+ 1D86 D2 50 18             jp      NC,SNERR        ; Not a key word - ?SN Error
1515+ 1D89 07                   rlca                    ; Double it
1516+ 1D8A 4F                   ld      C,A             ; BC = Offset into table
1517+ 1D8B 06 00                ld      B,0
1518+ 1D8D EB                   ex      DE,HL           ; Save code string address
1519+ 1D8E 21 57 16             ld      HL,WORDTB       ; Keyword address table
1520+ 1D91 09                   add     HL,BC           ; Point to routine address
1521+ 1D92 4E                   ld      C,(HL)          ; Get LSB of routine address
1522+ 1D93 23                   inc     HL
1523+ 1D94 46                   ld      B,(HL)          ; Get MSB of routine address
1524+ 1D95 C5                   push    BC              ; Save routine address
1525+ 1D96 EB                   ex      DE,HL           ; Restore code string address
1526+ 1D97
1527+ 1D97              ; get a char from input buffer: exit with NC if character found is
1528+ 1D97              ; not a number; exit with Z if nothing found; char is into A
1529+ 1D97 23           GETCHR: inc     HL              ; Point to next character
1530+ 1D98 7E                   ld      A,(HL)          ; Get next code string byte
1531+ 1D99 FE 3A                cp      ':'             ; Z if ':'
1532+ 1D9B D0                   ret     NC              ; NC if > "9"
1533+ 1D9C FE 20                cp      SPC
1534+ 1D9E CA 97 1D             jp      Z,GETCHR        ; Skip over spaces
1535+ 1DA1 FE 30                cp      '0'
1536+ 1DA3 3F                   ccf                     ; NC if < '0'
1537+ 1DA4 3C                   inc     A               ; Test for zero - Leave carry
1538+ 1DA5 3D                   dec     A               ; Z if Null
1539+ 1DA6 C9                   ret
1540+ 1DA7
1541+ 1DA7 EB           RESTOR: ex      DE,HL           ; Save code string address
1542+ 1DA8 2A D8 54             ld      HL,(BASTXT)     ; Point to start of program
1543+ 1DAB CA BC 1D             jp      Z,RESTNL        ; Just RESTORE - reset pointer
1544+ 1DAE EB                   ex      DE,HL           ; Restore code string address
1545+ 1DAF CD 67 1E             call    ATOH            ; Get line number to DE
1546+ 1DB2 E5                   push    HL              ; Save code string address
1547+ 1DB3 CD 6C 19             call    SRCHLN          ; Search for line number in DE
1548+ 1DB6 60                   ld      H,B             ; HL = Address of line
1549+ 1DB7 69                   ld      L,C
1550+ 1DB8 D1                   pop     DE              ; Restore code string address
1551+ 1DB9 D2 16 1F             jp      NC,ULERR        ; ?UL Error if not found
1552+ 1DBC 2B           RESTNL: dec     HL              ; Byte before DATA statement
1553+ 1DBD 22 F1 55     UPDATA: ld      (NXTDAT),HL     ; Update DATA pointer
1554+ 1DC0 EB                   ex      DE,HL           ; Restore code string address
1555+ 1DC1 C9                   ret
1556+ 1DC2
1557+ 1DC2
1558+ 1DC2              ; check if CTRL-C is into input buffer
1559+ 1DC2 DF           TSTBRK: rst     $18             ; Check input status
1560+ 1DC3 C8                   ret     Z               ; No key, go back
1561+ 1DC4 D7                   rst     $10             ; Get the key into A
1562+ 1DC5 FE 1B                cp      ESC             ; Escape key?
1563+ 1DC7 28 11                jr      Z,BRK           ; Yes, break
1564+ 1DC9 FE 03                cp      CTRLC           ; <Ctrl-C>
1565+ 1DCB 28 0D                jr      Z,BRK           ; Yes, break
1566+ 1DCD FE 13                cp      CTRLS           ; Stop scrolling?
1567+ 1DCF C0                   ret     NZ              ; Other key, ignore
1568+ 1DD0
1569+ 1DD0
1570+ 1DD0              ; wait for a key while listing
1571+ 1DD0 D7           STALL:  rst     $10             ; Wait for key
1572+ 1DD1 FE 11                cp      CTRLQ           ; Resume scrolling?
1573+ 1DD3 C8                   ret     Z               ; Release the chokehold
1574+ 1DD4 FE 03                cp      CTRLC           ; Second break?
1575+ 1DD6 28 07                jr      Z,STOP          ; Break during hold exits prog
1576+ 1DD8 18 F6                jr      STALL           ; Loop until <Ctrl-Q> or <brk>
1577+ 1DDA
1578+ 1DDA 3E FF        BRK:    ld      A,$FF           ; Set BRKFLG
1579+ 1DDC 32 4C 54             ld      (BRKFLG),A      ; Store it
1580+ 1DDF
1581+ 1DDF C0           STOP:   ret     NZ              ; Exit if anything else
1582+ 1DE0 F6                   defb    $F6             ; Flag "STOP"
1583+ 1DE1 C0           PEND:   ret     NZ              ; Exit if anything else
1584+ 1DE2 22 7D 55             ld      (BRKLIN),HL     ; Save point of break
1585+ 1DE5 21                   defb    $21             ; Skip "OR 11111111B"
1586+ 1DE6 F6 FF        INPBRK: or      %11111111       ; Flag "Break" wanted
1587+ 1DE8 C1                   pop     BC              ; Return not needed and more
1588+ 1DE9 2A 52 54     ENDPRG: ld      HL,(LINEAT)     ; Get current line number
1589+ 1DEC F5                   push    AF              ; Save STOP / END status
1590+ 1DED 7D                   ld      A,L             ; Is it direct break?
1591+ 1DEE A4                   and     H
1592+ 1DEF 3C                   inc     A               ; Line is -1 if direct break
1593+ 1DF0 CA FC 1D             jp      Z,NOLIN         ; Yes - No line number
1594+ 1DF3 22 81 55             ld      (ERRLIN),HL     ; Save line of break
1595+ 1DF6 2A 7D 55             ld      HL,(BRKLIN)     ; Get point of break
1596+ 1DF9 22 83 55             ld      (CONTAD),HL     ; Save point to CONTinue
1597+ 1DFC AF           NOLIN:  xor     A
1598+ 1DFD 32 48 54             ld      (CTLOFG),A      ; Enable output
1599+ 1E00 CD 52 20             call    STTLIN          ; Start a new line
1600+ 1E03 F1                   pop     AF              ; Restore STOP / END status
1601+ 1E04 21 D3 17             ld      HL,BRKMSG       ; "Break" message
1602+ 1E07 C2 0D 1E             jp      NZ,ERRINT       ; "in line" wanted?
1603+ 1E0A C3 B0 18             jp      PRNTOK          ; Go to command mode
1604+ 1E0D CD 2A 18     ERRINT: call    EXITGM          ; exit from graphics mode
1605+ 1E10 C3 8E 18             jp      ERRIN           ; print message
1606+ 1E13
1607+ 1E13
1608+ 1E13              ; CONTinue after a break/error
1609+ 1E13 21 FF FF     CONT:   ld      HL,-1           ; reset...
1610+ 1E16 22 54 54             ld      (HLPLN),HL      ; ...HELP line register
1611+ 1E19 2A 83 55             ld      HL,(CONTAD)     ; Get CONTinue address
1612+ 1E1C 7C                   ld      A,H             ; Is it zero?
1613+ 1E1D B5                   or      L
1614+ 1E1E 1E 20                ld      E,CN            ; ?CN Error
1615+ 1E20 CA 6A 18             jp      Z,ERROR         ; Yes - output "?CN Error"
1616+ 1E23 EB                   ex      DE,HL           ; Save code string address
1617+ 1E24 2A 81 55             ld      HL,(ERRLIN)     ; Get line of last break
1618+ 1E27 22 52 54             ld      (LINEAT),HL     ; Set up current line number
1619+ 1E2A EB                   ex      DE,HL           ; Restore code string address
1620+ 1E2B C9                   ret                     ; CONTinue where left off
1621+ 1E2C
1622+ 1E2C E5           ACCSUM: push    HL              ; Save address in array
1623+ 1E2D 2A 49 54             ld      HL,(CHKSUM)     ; Get check sum
1624+ 1E30 06 00                ld      B,$00           ; BC - Value of byte
1625+ 1E32 4F                   ld      C,A
1626+ 1E33 09                   add     HL,BC           ; Add byte to check sum
1627+ 1E34 22 49 54             ld      (CHKSUM),HL     ; Re-save check sum
1628+ 1E37 E1                   pop     HL              ; Restore address in array
1629+ 1E38 C9                   ret
1630+ 1E39
1631+ 1E39 7E           CHKLTR: ld      A,(HL)          ; Get byte
1632+ 1E3A FE 41                cp      'A'             ; < 'a' ?
1633+ 1E3C D8                   ret     C               ; Carry set if not letter
1634+ 1E3D FE 5B                cp      'Z'+1           ; > 'z' ?
1635+ 1E3F 3F                   ccf
1636+ 1E40 C9                   ret                     ; Carry set if not letter
1637+ 1E41
1638+ 1E41 CD 97 1D     FPSINT: call    GETCHR          ; Get next character
1639+ 1E44 CD 28 22     POSINT: call    GETNUM          ; Get integer 0 to 32767
1640+ 1E47 CD 35 30     DEPINT: call    TSTSGN          ; Test sign of FPREG
1641+ 1E4A FA 62 1E             jp      M,FCERR         ; Negative - ?FC Error
1642+ 1E4D 3A FC 55     DEINT:  ld      A,(FPEXP)       ; Get integer value to DE
1643+ 1E50 FE 90                cp      $80+$10         ; Exponent in range (16 bits)?
1644+ 1E52 DA DD 30             jp      C,FPINT         ; Yes - convert it
1645+ 1E55 01 80 90             ld      BC,$9080        ; BCDE = -32768
1646+ 1E58 11 00 00             ld      DE,$0000
1647+ 1E5B E5                   push    HL              ; Save code string address
1648+ 1E5C CD B0 30             call    CMPNUM          ; Compare FPREG with BCDE
1649+ 1E5F E1                   pop     HL              ; Restore code string address
1650+ 1E60 51                   ld      D,C             ; MSB to D
1651+ 1E61 C8                   ret     Z               ; Return if in range
1652+ 1E62 1E 08        FCERR:  ld      E,FC            ; ?FC Error
1653+ 1E64 C3 6A 18             jp      ERROR           ; Output error-
1654+ 1E67
1655+ 1E67
1656+ 1E67              ; convert a number in ASCII chars into an integer and store it into DE
1657+ 1E67 2B           ATOH:   dec     HL              ; ASCII number to DE binary
1658+ 1E68 11 00 00     GETLN:  ld      DE,$0000        ; Get number to DE
1659+ 1E6B CD 97 1D     GTLNLP: call    GETCHR          ; Get next character
1660+ 1E6E D0                   ret     NC              ; Exit if not a digit
1661+ 1E6F E5                   push    HL              ; Save code string address
1662+ 1E70 F5                   push    AF              ; Save digit
1663+ 1E71 21 98 19             ld      HL,65529/10     ; Largest number 65529
1664+ 1E74 CD 48 1B             call    CPDEHL          ; Number in range?
1665+ 1E77 DA 50 18             jp      C,SNERR         ; No - ?SN Error
1666+ 1E7A 62                   ld      H,D             ; HL = Number
1667+ 1E7B 6B                   ld      L,E
1668+ 1E7C 19                   add     HL,DE           ; Times 2
1669+ 1E7D 29                   add     HL,HL           ; Times 4
1670+ 1E7E 19                   add     HL,DE           ; Times 5
1671+ 1E7F 29                   add     HL,HL           ; Times 10
1672+ 1E80 F1                   pop     AF              ; Restore digit
1673+ 1E81 D6 30                sub     '0'             ; Make it 0 to 9
1674+ 1E83 5F                   ld      E,A             ; DE = Value of digit
1675+ 1E84 16 00                ld      D,0
1676+ 1E86 19                   add     HL,DE           ; Add to number
1677+ 1E87 EB                   ex      DE,HL           ; Number to DE
1678+ 1E88 E1                   pop     HL              ; Restore code string address
1679+ 1E89 C3 6B 1E             jp      GTLNLP          ; Go to next character
1680+ 1E8C
1681+ 1E8C CA 9C 19     CLEAR:  jp      Z,INTVAR        ; Just "CLEAR" Keep parameters
1682+ 1E8F CD 28 22             call    GETNUM          ; Evaluate a number
1683+ 1E92 CD 4D 1E             call    DEINT           ; Get integer -32768 to 32767 into DE
1684+ 1E95 2B                   dec     HL              ; Cancel increment
1685+ 1E96 CD 97 1D             call    GETCHR          ; Get next character
1686+ 1E99 E5                   push    HL              ; Save code string address
1687+ 1E9A 2A 39 55             ld      HL,(LSTRAM)     ; Get end of RAM
1688+ 1E9D CA B5 1E             jp      Z,STORED        ; No value given - Use stored
1689+ 1EA0 E1                   pop     HL              ; Restore code string address
1690+ 1EA1 CD 4E 1B             call    CHKSYN          ; Check for comma
1691+ 1EA4 2C                   defb    ','
1692+ 1EA5 D5                   push    DE              ; Save number
1693+ 1EA6 CD 28 22             call    GETNUM          ; Evaluate a number
1694+ 1EA9 CD 4D 1E             call    DEINT           ; Get integer -32768 to 32767 into DE
1695+ 1EAC 2B                   dec     HL              ; Cancel increment
1696+ 1EAD CD 97 1D             call    GETCHR          ; Get next character
1697+ 1EB0 C2 50 18             jp      NZ,SNERR        ; ?SN Error if more on line
1698+ 1EB3 E3                   ex      (SP),HL         ; Save code string address
1699+ 1EB4 EB                   ex      DE,HL           ; Number to DE
1700+ 1EB5 7D           STORED: ld      A,L             ; Get LSB of new RAM top
1701+ 1EB6 93                   sub     E               ; Subtract LSB of string space
1702+ 1EB7 5F                   ld      E,A             ; Save LSB
1703+ 1EB8 7C                   ld      A,H             ; Get MSB of new RAM top
1704+ 1EB9 9A                   sbc     A,D             ; Subtract MSB of string space
1705+ 1EBA 57                   ld      D,A             ; Save MSB
1706+ 1EBB DA 25 18             jp      C,OMERR         ; ?OM Error if not enough mem
1707+ 1EBE E5                   push    HL              ; Save RAM top
1708+ 1EBF 2A EB 55             ld      HL,(PROGND)     ; Get program end
1709+ 1EC2 01 28 00             ld      BC,$28          ; 40 Bytes minimum working RAM
1710+ 1EC5 09                   add     HL,BC           ; Get lowest address
1711+ 1EC6 CD 48 1B             call    CPDEHL          ; Enough memory?
1712+ 1EC9 D2 25 18             jp      NC,OMERR        ; No - ?OM Error
1713+ 1ECC EB                   ex      DE,HL           ; RAM top to HL
1714+ 1ECD 22 50 54             ld      (STRSPC),HL     ; Set new string space
1715+ 1ED0 E1                   pop     HL              ; End of memory to use
1716+ 1ED1 22 39 55             ld      (LSTRAM),HL     ; Set new top of RAM
1717+ 1ED4 E1                   pop     HL              ; Restore code string address
1718+ 1ED5 C3 9C 19             jp      INTVAR          ; Initialise variables
1719+ 1ED8
1720+ 1ED8 E5           RUN:    push    HL              ; store HL
1721+ 1ED9 21 FF FF             ld      HL,-1           ; reset...
1722+ 1EDC 22 54 54             ld      (HLPLN),HL      ; ...HELP line register
1723+ 1EDF E1                   pop     HL              ; retrieve HL
1724+ 1EE0 CA 98 19             jp      Z,RUNFST        ; RUN from start if just RUN
1725+ 1EE3 CD 9C 19             call    INTVAR          ; Initialise variables
1726+ 1EE6 01 57 1D             ld      BC,RUNCNT       ; Execution driver loop
1727+ 1EE9 C3 FC 1E             jp      RUNLIN          ; RUN from line number
1728+ 1EEC
1729+ 1EEC 0E 03        GOSUB:  ld      C,$03           ; 3 Levels of stack needed
1730+ 1EEE CD 0D 18             call    CHKSTK          ; Check for 3 levels of stack
1731+ 1EF1 C1                   pop     BC              ; Get return address
1732+ 1EF2 E5                   push    HL              ; Save code string for RETURN
1733+ 1EF3 E5                   push    HL              ; And for GOSUB routine
1734+ 1EF4 2A 52 54             ld      HL,(LINEAT)     ; Get current line
1735+ 1EF7 E3                   ex      (SP),HL         ; Into stack - Code string out
1736+ 1EF8 3E 8C                ld      A,ZGOSUB        ; "GOSUB" token
1737+ 1EFA F5                   push    AF              ; Save token
1738+ 1EFB 33                   inc     SP              ; Don't save flags
1739+ 1EFC
1740+ 1EFC C5           RUNLIN: push    BC              ; Save return address
1741+ 1EFD CD 67 1E     GOTO:   call    ATOH            ; ASCII number to DE binary
1742+ 1F00 CD 42 1F             call    REM             ; Get end of line
1743+ 1F03 E5                   push    HL              ; Save end of line
1744+ 1F04 2A 52 54             ld      HL,(LINEAT)     ; Get current line
1745+ 1F07 CD 48 1B             call    CPDEHL          ; Line after current?
1746+ 1F0A E1                   pop     HL              ; Restore end of line
1747+ 1F0B 23                   inc     HL              ; Start of next line
1748+ 1F0C DC 6F 19             call    C,SRCHLP        ; Line is after current line
1749+ 1F0F D4 6C 19             call    NC,SRCHLN       ; Line is before current line
1750+ 1F12 60                   ld      H,B             ; Set up code string address
1751+ 1F13 69                   ld      L,C
1752+ 1F14 2B                   dec     HL              ; Incremented after
1753+ 1F15 D8                   ret     C               ; Line found
1754+ 1F16 1E 0E        ULERR:  ld      E,UL            ; ?UL Error
1755+ 1F18 C3 6A 18             jp      ERROR           ; Output error message
1756+ 1F1B
1757+ 1F1B C0           RETURN: ret     NZ              ; Return if not just RETURN
1758+ 1F1C 16 FF                ld      D,-1            ; Flag "GOSUB" search
1759+ 1F1E CD D9 17             call    BAKSTK          ; Look "GOSUB" block
1760+ 1F21 F9                   ld      SP,HL           ; Kill all FORs in subroutine
1761+ 1F22 FE 8C                cp      ZGOSUB          ; Test for "GOSUB" token
1762+ 1F24 1E 04                ld      E,RG            ; ?RG Error
1763+ 1F26 C2 6A 18             jp      NZ,ERROR        ; Error if no "GOSUB" found
1764+ 1F29 E1                   pop     HL              ; Get RETURN line number
1765+ 1F2A 22 52 54             ld      (LINEAT),HL     ; Save as current
1766+ 1F2D 23                   inc     HL              ; Was it from direct statement?
1767+ 1F2E 7C                   ld      A,H
1768+ 1F2F B5                   or      L               ; Return to line
1769+ 1F30 C2 3A 1F             jp      NZ,RETLIN       ; No - Return to line
1770+ 1F33 3A 7B 55             ld      A,(LSTBIN)      ; Any INPUT in subroutine?
1771+ 1F36 B7                   or      A               ; If so buffer is corrupted
1772+ 1F37 C2 AF 18             jp      NZ,POPNOK       ; Yes - Go to command mode
1773+ 1F3A 21 57 1D     RETLIN: ld      HL,RUNCNT       ; Execution driver loop
1774+ 1F3D E3                   ex      (SP),HL         ; Into stack - Code string out
1775+ 1F3E 3E                   defb    $3E             ; Skip "pop HL"
1776+ 1F3F E1           NXTDTA: pop     HL              ; Restore code string address
1777+ 1F40
1778+ 1F40 01 3A        DATA:   defb    $01,$3A         ; ':' End of statement (stands for LD BC,$0E3A - NOP)
1779+ 1F42 0E 00        REM:    ld      C,$00           ; 00  End of statement
1780+ 1F44 06 00                ld      B,$00
1781+ 1F46 79           NXTSTL: ld      A,C             ; Statement and byte
1782+ 1F47 48                   ld      C,B
1783+ 1F48 47                   ld      B,A             ; Statement end byte
1784+ 1F49 7E           NXTSTT: ld      A,(HL)          ; Get byte
1785+ 1F4A B7                   or      A               ; End of line?
1786+ 1F4B C8                   ret     Z               ; Yes - Exit
1787+ 1F4C B8                   cp      B               ; End of statement?
1788+ 1F4D C8                   ret     Z               ; Yes - Exit
1789+ 1F4E 23                   inc     HL              ; Next byte
1790+ 1F4F FE 22                cp      $22             ; '"'             ; Literal string?
1791+ 1F51 CA 46 1F             jp      Z,NXTSTL        ; Yes - Look for another '"'
1792+ 1F54 C3 49 1F             jp      NXTSTT          ; Keep looking
1793+ 1F57
1794+ 1F57 CD 37 24     LET:    call    GETVAR          ; Get variable name
1795+ 1F5A CD 4E 1B             call    CHKSYN          ; Make sure "=" follows
1796+ 1F5D CC                   defb    ZEQUAL          ; "=" token
1797+ 1F5E D5                   push    DE              ; Save address of variable
1798+ 1F5F 3A 37 55             ld      A,(TYPE)        ; Get data type
1799+ 1F62 F5                   push    AF              ; Save type
1800+ 1F63 CD 3A 22             call    EVAL            ; Evaluate expression
1801+ 1F66 F1                   pop     AF              ; Restore type
1802+ 1F67 E3                   ex      (SP),HL         ; Save code - Get var addr
1803+ 1F68 22 7D 55             ld      (BRKLIN),HL     ; Save address of variable
1804+ 1F6B 1F                   rra                     ; Adjust type
1805+ 1F6C CD 2D 22             call    CHKTYP          ; Check types are the same
1806+ 1F6F CA AA 1F             jp      Z,LETNUM        ; Numeric - Move value
1807+ 1F72 E5           LETSTR: push    HL              ; Save address of string var
1808+ 1F73 2A F9 55             ld      HL,(FPREG)      ; Pointer to string entry
1809+ 1F76 E5                   push    HL              ; Save it on stack
1810+ 1F77 23                   inc     HL              ; Skip over length
1811+ 1F78 23                   inc     HL
1812+ 1F79 5E                   ld      E,(HL)          ; LSB of string address
1813+ 1F7A 23                   inc     HL
1814+ 1F7B 56                   ld      D,(HL)          ; MSB of string address
1815+ 1F7C 2A D8 54             ld      HL,(BASTXT)     ; Point to start of program
1816+ 1F7F CD 48 1B             call    CPDEHL          ; Is string before program?
1817+ 1F82 D2 99 1F             jp      NC,CRESTR       ; Yes - Create string entry
1818+ 1F85 2A 50 54             ld      HL,(STRSPC)     ; Point to string space
1819+ 1F88 CD 48 1B             call    CPDEHL          ; Is string literal in program?
1820+ 1F8B D1                   pop     DE              ; Restore address of string
1821+ 1F8C D2 A1 1F             jp      NC,MVSTPT       ; Yes - Set up pointer
1822+ 1F8F 21 6E 55             ld      HL,TMPSTR       ; Temporary string pool
1823+ 1F92 CD 48 1B             call    CPDEHL          ; Is string in temporary pool?
1824+ 1F95 D2 A1 1F             jp      NC,MVSTPT       ; No - Set up pointer
1825+ 1F98 3E                   defb    $3E             ; Skip "pop DE"
1826+ 1F99 D1           CRESTR: pop     DE              ; Restore address of string
1827+ 1F9A CD 91 28             call    BAKTMP          ; Back to last tmp-str entry
1828+ 1F9D EB                   ex      DE,HL           ; Address of string entry
1829+ 1F9E CD CA 26             call    SAVSTR          ; Save string in string area
1830+ 1FA1 CD 91 28     MVSTPT: call    BAKTMP          ; Back to last tmp-str entry
1831+ 1FA4 E1                   pop     HL              ; Get string pointer
1832+ 1FA5 CD 90 30             call    DETHL4          ; Move string pointer to var
1833+ 1FA8 E1                   pop     HL              ; Restore code string address
1834+ 1FA9 C9                   ret
1835+ 1FAA
1836+ 1FAA E5           LETNUM: push    HL              ; Save address of variable
1837+ 1FAB CD 8D 30             call    FPTHL           ; Move value to variable
1838+ 1FAE D1                   pop     DE              ; Restore address of variable
1839+ 1FAF E1                   pop     HL              ; Restore code string address
1840+ 1FB0 C9                   ret
1841+ 1FB1
1842+ 1FB1 CD AE 2A     ON:     call    GETINT          ; Get integer 0-255
1843+ 1FB4 7E                   ld      A,(HL)          ; Get "GOTO" or "GOSUB" token
1844+ 1FB5 47                   ld      B,A             ; Save in B
1845+ 1FB6 FE 8C                cp      ZGOSUB          ; "GOSUB" token?
1846+ 1FB8 CA C0 1F             jp      Z,ONGO          ; Yes - Find line number
1847+ 1FBB CD 4E 1B             call    CHKSYN          ; Make sure it's "GOTO"
1848+ 1FBE 88                   defb    ZGOTO           ; "GOTO" token
1849+ 1FBF 2B                   dec     HL              ; Cancel increment
1850+ 1FC0 4B           ONGO:   ld      C,E             ; Integer of branch value
1851+ 1FC1 0D           ONGOLP: dec     C               ; Count branches
1852+ 1FC2 78                   ld      A,B             ; Get "GOTO" or "GOSUB" token
1853+ 1FC3 CA 7F 1D             jp      Z,ONJMP         ; Go to that line if right one
1854+ 1FC6 CD 68 1E             call    GETLN           ; Get line number to DE
1855+ 1FC9 FE 2C                cp      ','             ; Another line number?
1856+ 1FCB C0                   ret     NZ              ; No - Drop through
1857+ 1FCC C3 C1 1F             jp      ONGOLP          ; Yes - loop
1858+ 1FCF
1859+ 1FCF CD 3A 22     IF:     call    EVAL            ; Evaluate expression
1860+ 1FD2 7E                   ld      A,(HL)          ; Get token
1861+ 1FD3 FE 88                cp      ZGOTO           ; "GOTO" token?
1862+ 1FD5 CA DD 1F             jp      Z,IFGO          ; Yes - Get line
1863+ 1FD8 CD 4E 1B             call    CHKSYN          ; Make sure it's "THEN"
1864+ 1FDB BE                   defb    ZTHEN           ; "THEN" token
1865+ 1FDC 2B                   dec     HL              ; Cancel increment
1866+ 1FDD CD 2B 22     IFGO:   call    TSTNUM          ; Make sure it's numeric
1867+ 1FE0 CD 35 30             call    TSTSGN          ; Test state of expression
1868+ 1FE3 CA EF 1F             jp      Z,IF1           ; False - Jump over
1869+ 1FE6 CD 97 1D     IF0:    call    GETCHR          ; Get next character
1870+ 1FE9 DA FD 1E             jp      C,GOTO          ; Number - GOTO that line
1871+ 1FEC C3 7E 1D             jp      IFJMP           ; Otherwise do statement
1872+ 1FEF 0E B2        IF1:    ld      C,ZELSE
1873+ 1FF1 CD 44 1F             call    REM+2           ; check statement
1874+ 1FF4 B7                   or      A               ; end of line?
1875+ 1FF5 C8                   ret     Z               ; yes, leave
1876+ 1FF6 FE B2                cp      ZELSE
1877+ 1FF8 20 F5                jr      NZ,IF1          ; ELSE not found, continue check
1878+ 1FFA C3 E6 1F             jp      IF0             ; return to IF
1879+ 1FFD
1880+ 1FFD
1881+ 1FFD 2B           MRPRNT: dec     HL              ; dec 'cos GETCHR INCs
1882+ 1FFE CD 97 1D             call    GETCHR          ; Get next character
1883+ 2001 CA 64 20     PRINT:  jp      Z,PRNTCRLF      ; CRLF if just PRINT
1884+ 2004 C8           PRNTLP: ret     Z               ; End of list - Exit
1885+ 2005 FE BA                cp      ZTAB            ; "TAB(" token?
1886+ 2007 CA 8C 20             jp      Z,DOTAB         ; Yes - Do TAB routine
1887+ 200A FE BD                cp      ZSPC            ; "SPC(" token?
1888+ 200C CA 8C 20             jp      Z,DOTAB         ; Yes - Do SPC routine
1889+ 200F E5                   push    HL              ; Save code string address
1890+ 2010 FE 2C                cp      ','             ; Comma?
1891+ 2012 CA 73 20             jp      Z,DOCOM         ; Yes - Move to next zone
1892+ 2015 FE 3B                cp      ';'             ; Semi-colon?
1893+ 2017 CA B0 20             jp      Z,NEXITM        ; Do semi-colon routine
1894+ 201A C1                   pop     BC              ; Code string address to BC
1895+ 201B CD 3A 22             call    EVAL            ; Evaluate expression
1896+ 201E E5                   push    HL              ; Save code string address
1897+ 201F 3A 37 55             ld      A,(TYPE)        ; Get variable type
1898+ 2022 B7                   or      A               ; Is it a string variable?
1899+ 2023 C2 4B 20             jp      NZ,PRNTST       ; Yes - Output string contents
1900+ 2026 CD DA 31             call    NUMASC          ; Convert number to text
1901+ 2029 CD EE 26             call    CRTST           ; Create temporary string
1902+ 202C 36 00                ld      (HL),NLLCR      ; Followed by a NULL char (was SPC, space)
1903+ 202E 2A F9 55             ld      HL,(FPREG)      ; Get length of output
1904+ 2031 34                   inc     (HL)            ; Plus 1 for the space
1905+ 2032 2A F9 55             ld      HL,(FPREG)      ; < Not needed >
1906+ 2035 3A 45 54             ld      A,(LWIDTH)      ; Get width of line
1907+ 2038 47                   ld      B,A             ; To B
1908+ 2039 04                   inc     B               ; Width 255 (No limit)?
1909+ 203A CA 47 20             jp      Z,PRNTNB        ; Yes - Output number string
1910+ 203D 04                   inc     B               ; Adjust it
1911+ 203E 3A 35 55             ld      A,(CURPOS)      ; Get cursor position
1912+ 2041 86                   add     A,(HL)          ; Add length of string
1913+ 2042 3D                   dec     A               ; Adjust it
1914+ 2043 B8                   cp      B               ; Will output fit on this line?
1915+ 2044 D4 64 20             call    NC,PRNTCRLF     ; No - CRLF first
1916+ 2047 CD 33 27     PRNTNB: call    PRS1            ; Output string at (HL)
1917+ 204A AF                   xor     A               ; Skip call by setting 'z' flag
1918+ 204B C4 33 27     PRNTST: call    NZ,PRS1         ; Output string at (HL)
1919+ 204E E1                   pop     HL              ; Restore code string address
1920+ 204F C3 FD 1F             jp      MRPRNT          ; See if more to PRINT
1921+ 2052
1922+ 2052 3A 35 55     STTLIN: ld      A,(CURPOS)      ; Make sure on new line
1923+ 2055 B7                   or      A               ; Already at start?
1924+ 2056 C8                   ret     Z               ; Yes - Do nothing
1925+ 2057 C3 64 20             jp      PRNTCRLF        ; Start a new line
1926+ 205A
1927+ 205A AF           ENDINP: xor     A
1928+ 205B 32 DF 55             ld      (KBDNPT),A      ; char is not from keyboard
1929+ 205E 77                   ld      (HL),A          ; Mark end of buffer
1930+ 205F 21 DA 54             ld      HL,BUFFER-1     ; Point to buffer
1931+ 2062 18 0A                jr      CNTEND
1932+ 2064 3E 0D        PRNTCRLF:ld     A,CR            ; Load a CR
1933+ 2066 CD 59 1B             call    OUTC            ; Output character
1934+ 2069 3E 0A                ld      A,LF            ; Load a LF
1935+ 206B CD 59 1B             call    OUTC            ; Output character
1936+ 206E AF           CNTEND: xor     A               ; Set to position 0
1937+ 206F 32 35 55             ld      (CURPOS),A      ; Store it
1938+ 2072 C9                   ret                     ; return to caller
1939+ 2073
1940+ 2073 3A 46 54     DOCOM:  ld      A,(COMMAN)      ; Get comma width
1941+ 2076 47                   ld      B,A             ; Save in B
1942+ 2077 3A 9A 55             ld      A,(SCR_CURS_X)  ; Get current position
1943+ 207A B8                   cp      B               ; Within the limit?
1944+ 207B D4 64 20             call    NC,PRNTCRLF     ; No - output CRLF
1945+ 207E D2 B0 20             jp      NC,NEXITM       ; Get next item
1946+ 2081 D6 0A        ZONELP: sub     $0A             ; Next zone of 10 characters
1947+ 2083 D2 81 20             jp      NC,ZONELP       ; Repeat if more zones
1948+ 2086 2F                   cpl                     ; Number of null chars to output
1949+ 2087 0E 00                ld      C,NLLCR         ; null char
1950+ 2089 C3 A6 20             jp      ASPCS           ; Output them
1951+ 208C
1952+ 208C F5           DOTAB:  push    AF              ; Save token
1953+ 208D CD AB 2A             call    FNDNUM          ; Evaluate expression
1954+ 2090 CD 4E 1B             call    CHKSYN          ; Make sure ")" follows
1955+ 2093 29                   defb    ')'
1956+ 2094 2B                   dec     HL              ; Back space on to ")"
1957+ 2095 F1                   pop     AF              ; Restore token
1958+ 2096 0E 00                ld      C,NLLCR         ; for SPC we use NULL char (was SPACE)
1959+ 2098 D6 BD                sub     ZSPC            ; Was it "SPC(" ?
1960+ 209A E5                   push    HL              ; Save code string address
1961+ 209B CA A1 20             jp      Z,DOSPC         ; Yes - Do 'E' spaces
1962+ 209E 3A 9A 55             ld      A,(SCR_CURS_X)  ; Get current X position
1963+ 20A1 2F           DOSPC:  cpl                     ; Number of spaces to print to
1964+ 20A2 83                   add     A,E             ; Total number to print
1965+ 20A3 D2 B0 20             jp      NC,NEXITM       ; TAB < Current POS(X)
1966+ 20A6 3C           ASPCS:  inc     A               ; Output A spaces
1967+ 20A7 47                   ld      B,A             ; Save number to print
1968+ 20A8 79           SPCLP:  ld      A,C             ; char to print
1969+ 20A9 CD 59 1B             call    OUTC            ; Output character in A
1970+ 20AC 05                   dec     B               ; Count them
1971+ 20AD C2 A8 20             jp      NZ,SPCLP        ; Repeat if more
1972+ 20B0 E1           NEXITM: pop     HL              ; Restore code string address
1973+ 20B1 CD 97 1D             call    GETCHR          ; Get next character
1974+ 20B4 C3 04 20             jp      PRNTLP          ; More to print
1975+ 20B7
1976+ 20B7 3F 52 65 64  REDO:   defb    "?Redo from start",CR,0
1976+ 20BB 6F 20 66 72
1976+ 20BF 6F 6D 20 73
1976+ 20C3 74 61 72 74
1976+ 20C7 0D 00
1977+ 20C9
1978+ 20C9 3A 7C 55     BADINP: ld      A,(READFG)      ; READ or INPUT?
1979+ 20CC B7                   or      A
1980+ 20CD C2 4A 18             jp      NZ,DATSNR       ; READ - ?SN Error
1981+ 20D0 C1                   pop     BC              ; Throw away code string addr
1982+ 20D1 21 B7 20             ld      HL,REDO         ; "Redo from start" message
1983+ 20D4 CD 30 27             call    PRS             ; Output string
1984+ 20D7 C3 CB 19             jp      DOAGN           ; Do last INPUT again
1985+ 20DA
1986+ 20DA CD 9B 26     INPUT:  call    IDTEST          ; Test for illegal direct
1987+ 20DD 7E                   ld      A,(HL)          ; Get character after "INPUT"
1988+ 20DE FE 22                cp      $22             ; '"' ; Is there a prompt string?
1989+ 20E0 3E 00                ld      A,$00           ; Clear A and leave flags
1990+ 20E2 32 48 54             ld      (CTLOFG),A      ; Enable output
1991+ 20E5 C2 F4 20             jp      NZ,NOPMPT       ; No prompt - get input
1992+ 20E8 CD EF 26             call    QTSTR           ; Get string terminated by '"'
1993+ 20EB CD 4E 1B             call    CHKSYN          ; Check for ';' after prompt
1994+ 20EE 3B                   defb    ";"
1995+ 20EF E5                   push    HL              ; Save code string address
1996+ 20F0 CD 33 27             call    PRS1            ; Output prompt string
1997+ 20F3 3E                   defb    $3E             ; Skip "push HL"
1998+ 20F4 E5           NOPMPT: push    HL              ; Save code string address
1999+ 20F5 CD CF 19             call    PROMPT          ; Get input with "? " prompt
2000+ 20F8 C1                   pop     BC              ; Restore code string address
2001+ 20F9 DA E6 1D             jp      C,INPBRK        ; Break pressed - Exit
2002+ 20FC 23                   inc     HL              ; Next byte
2003+ 20FD 7E                   ld      A,(HL)          ; Get it
2004+ 20FE B7                   or      A               ; End of line?
2005+ 20FF 2B                   dec     HL              ; Back again
2006+ 2100 C5                   push    BC              ; Re-save code string address
2007+ 2101 3A E7 55             ld      A,(SERIALS_EN)  ; load serial state
2008+ 2104 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
2009+ 2106 CC 8F 01             call    Z,A_RTS_OFF      ; yes, set RTS on
2010+ 2109 CD 42 09             call    CURSOR_OFF      ; disable cursor
2011+ 210C CA 3F 1F             jp      Z,NXTDTA        ; Yes - Find next DATA stmt
2012+ 210F 36 2C                ld      (HL),','        ; Store comma as separator
2013+ 2111 C3 19 21             jp      NXTITM          ; Get next item
2014+ 2114
2015+ 2114 E5           READ:   push    HL              ; Save code string address
2016+ 2115 2A F1 55             ld      HL,(NXTDAT)     ; Next DATA statement
2017+ 2118 F6                   defb    $F6             ; Flag "READ"
2018+ 2119 AF           NXTITM: xor     A               ; Flag "INPUT"
2019+ 211A 32 7C 55             ld      (READFG),A      ; Save "READ"/"INPUT" flag
2020+ 211D E3                   ex      (SP),HL         ; Get code str' , Save pointer
2021+ 211E C3 25 21             jp      GTVLUS          ; Get values
2022+ 2121
2023+ 2121 CD 4E 1B     NEDMOR: call    CHKSYN          ; Check for comma between items
2024+ 2124 2C                   defb    ','
2025+ 2125 CD 37 24     GTVLUS: call    GETVAR          ; Get variable name
2026+ 2128 E3                   ex      (SP),HL         ; Save code str" , Get pointer
2027+ 2129 D5                   push    DE              ; Save variable address
2028+ 212A 7E                   ld      A,(HL)          ; Get next "INPUT"/"DATA" byte
2029+ 212B FE 2C                cp      ','             ; Comma?
2030+ 212D CA 4D 21             jp      Z,ANTVLU        ; Yes - Get another value
2031+ 2130 3A 7C 55             ld      A,(READFG)      ; Is it READ?
2032+ 2133 B7                   or      A
2033+ 2134 C2 B9 21             jp      NZ,FDTLP        ; Yes - Find next DATA stmt
2034+ 2137 3E 3F                ld      A,'?'           ; More INPUT needed
2035+ 2139 CD 59 1B             call    OUTC            ; Output character
2036+ 213C CD CF 19             call    PROMPT          ; Get INPUT with prompt
2037+ 213F D1                   pop     DE              ; Variable address
2038+ 2140 C1                   pop     BC              ; Code string address
2039+ 2141 DA E6 1D             jp      C,INPBRK        ; Break pressed
2040+ 2144 23                   inc     HL              ; Point to next DATA byte
2041+ 2145 7E                   ld      A,(HL)          ; Get byte
2042+ 2146 B7                   or      A               ; Is it zero (No input) ?
2043+ 2147 2B                   dec     HL              ; Back space INPUT pointer
2044+ 2148 C5                   push    BC              ; Save code string address
2045+ 2149 CA 3F 1F             jp      Z,NXTDTA        ; Find end of buffer
2046+ 214C D5                   push    DE              ; Save variable address
2047+ 214D 3A 37 55     ANTVLU: ld      A,(TYPE)        ; Check data type
2048+ 2150 B7                   or      A               ; Is it numeric?
2049+ 2151 CA 77 21             jp      Z,INPBIN        ; Yes - Convert to binary
2050+ 2154 CD 97 1D             call    GETCHR          ; Get next character
2051+ 2157 57                   ld      D,A             ; Save input character
2052+ 2158 47                   ld      B,A             ; Again
2053+ 2159 FE 22                cp      $22             ; '"'     ; Start of literal sting?
2054+ 215B CA 6B 21             jp      Z,STRENT        ; Yes - Create string entry
2055+ 215E 3A 7C 55             ld      A,(READFG)      ; "READ" or "INPUT" ?
2056+ 2161 B7                   or      A
2057+ 2162 57                   ld      D,A             ; Save 00 if "INPUT"
2058+ 2163 CA 68 21             jp      Z,ITMSEP        ; "INPUT" - End with 00
2059+ 2166 16 3A                ld      D,':'           ; "DATA" - End with 00 or ':'
2060+ 2168 06 2C        ITMSEP: ld      B,','           ; Item separator
2061+ 216A 2B                   dec     HL              ; Back space for DTSTR
2062+ 216B CD F2 26     STRENT: call    DTSTR           ; Get string terminated by D
2063+ 216E EB                   ex      DE,HL           ; String address to DE
2064+ 216F 21 82 21             ld      HL,LTSTND       ; Where to go after LETSTR
2065+ 2172 E3                   ex      (SP),HL         ; Save HL , get input pointer
2066+ 2173 D5                   push    DE              ; Save address of string
2067+ 2174 C3 72 1F             jp      LETSTR          ; Assign string to variable
2068+ 2177
2069+ 2177 CD 97 1D     INPBIN: call    GETCHR          ; Get next character
2070+ 217A CD 3C 31             call    ASCTFP          ; Convert ASCII to FP number
2071+ 217D E3                   ex      (SP),HL         ; Save input ptr, Get var addr
2072+ 217E CD 8D 30             call    FPTHL           ; Move FPREG to variable
2073+ 2181 E1                   pop     HL              ; Restore input pointer
2074+ 2182 2B           LTSTND: dec     HL              ; dec 'cos GETCHR INCs
2075+ 2183 CD 97 1D             call    GETCHR          ; Get next character
2076+ 2186 CA 8E 21             jp      Z,MORDT         ; End of line - More needed?
2077+ 2189 FE 2C                cp      ','             ; Another value?
2078+ 218B C2 C9 20             jp      NZ,BADINP       ; No - Bad input
2079+ 218E E3           MORDT:  ex      (SP),HL         ; Get code string address
2080+ 218F 2B                   dec     HL              ; dec 'cos GETCHR INCs
2081+ 2190 CD 97 1D             call    GETCHR          ; Get next character
2082+ 2193 C2 21 21             jp      NZ,NEDMOR       ; More needed - Get it
2083+ 2196 D1                   pop     DE              ; Restore DATA pointer
2084+ 2197 3A 7C 55             ld      A,(READFG)      ; "READ" or "INPUT" ?
2085+ 219A B7                   or      A
2086+ 219B EB                   ex      DE,HL           ; DATA pointer to HL
2087+ 219C C2 BD 1D             jp      NZ,UPDATA       ; Update DATA pointer if "READ"
2088+ 219F D5                   push    DE              ; Save code string address
2089+ 21A0 B6                   or      (HL)            ; More input given?
2090+ 21A1 21 A9 21             ld      HL,EXTIG        ; "?Extra ignored" message
2091+ 21A4 C4 30 27             call    NZ,PRS          ; Output string if extra given
2092+ 21A7 E1                   pop     HL              ; Restore code string address
2093+ 21A8 C9                   ret
2094+ 21A9
2095+ 21A9 3F 45 78 74  EXTIG:  defb    "?Extra ignored",CR,0
2095+ 21AD 72 61 20 69
2095+ 21B1 67 6E 6F 72
2095+ 21B5 65 64 0D 00
2096+ 21B9
2097+ 21B9 CD 40 1F     FDTLP:  call    DATA            ; Get next statement
2098+ 21BC B7                   or      A               ; End of line?
2099+ 21BD C2 D2 21             jp      NZ,FANDT        ; No - See if DATA statement
2100+ 21C0 23                   inc     HL
2101+ 21C1 7E                   ld      A,(HL)          ; End of program?
2102+ 21C2 23                   inc     HL
2103+ 21C3 B6                   or      (HL)            ; 00 00 Ends program
2104+ 21C4 1E 06                ld      E,OD            ; ?OD Error
2105+ 21C6 CA 6A 18             jp      Z,ERROR         ; Yes - Out of DATA
2106+ 21C9 23                   inc     HL
2107+ 21CA 5E                   ld      E,(HL)          ; LSB of line number
2108+ 21CB 23                   inc     HL
2109+ 21CC 56                   ld      D,(HL)          ; MSB of line number
2110+ 21CD EB                   ex      DE,HL
2111+ 21CE 22 78 55             ld      (DATLIN),HL     ; Set line of current DATA item
2112+ 21D1 EB                   ex      DE,HL
2113+ 21D2 CD 97 1D     FANDT:  call    GETCHR          ; Get next character
2114+ 21D5 FE 83                cp      ZDATA           ; "DATA" token
2115+ 21D7 C2 B9 21             jp      NZ,FDTLP        ; No "DATA" - Keep looking
2116+ 21DA C3 4D 21             jp      ANTVLU          ; Found - Convert input
2117+ 21DD
2118+ 21DD 11 00 00     NEXT:   ld      DE,$0000        ; In case no index given
2119+ 21E0 C4 37 24     NEXT1:  call    NZ,GETVAR       ; Get index address
2120+ 21E3 22 7D 55             ld      (BRKLIN),HL     ; Save code string address
2121+ 21E6 CD D9 17             call    BAKSTK          ; Look for "FOR" block
2122+ 21E9 C2 56 18             jp      NZ,NFERR        ; No "FOR" - ?NF Error
2123+ 21EC F9                   ld      SP,HL           ; Clear nested loops
2124+ 21ED D5                   push    DE              ; Save index address
2125+ 21EE 7E                   ld      A,(HL)          ; Get sign of STEP
2126+ 21EF 23                   inc     HL
2127+ 21F0 F5                   push    AF              ; Save sign of STEP
2128+ 21F1 D5                   push    DE              ; Save index address
2129+ 21F2 CD 73 30             call    PHLTFP          ; Move index value to FPREG
2130+ 21F5 E3                   ex      (SP),HL         ; Save address of TO value
2131+ 21F6 E5                   push    HL              ; Save address of index
2132+ 21F7 CD 8F 2D             call    ADDPHL          ; Add STEP to index value
2133+ 21FA E1                   pop     HL              ; Restore address of index
2134+ 21FB CD 8D 30             call    FPTHL           ; Move value to index variable
2135+ 21FE E1                   pop     HL              ; Restore address of TO value
2136+ 21FF CD 84 30             call    LOADFP          ; Move TO value to BCDE
2137+ 2202 E5                   push    HL              ; Save address of line of FOR
2138+ 2203 CD B0 30             call    CMPNUM          ; Compare index with TO value
2139+ 2206 E1                   pop     HL              ; Restore address of line num
2140+ 2207 C1                   pop     BC              ; Address of sign of STEP
2141+ 2208 90                   sub     B               ; Compare with expected sign
2142+ 2209 CD 84 30             call    LOADFP          ; BC = Loop stmt,DE = Line num
2143+ 220C CA 18 22             jp      Z,KILFOR        ; Loop finished - Terminate it
2144+ 220F EB                   ex      DE,HL           ; Loop statement line number
2145+ 2210 22 52 54             ld      (LINEAT),HL     ; Set loop line number
2146+ 2213 69                   ld      L,C             ; Set code string to loop
2147+ 2214 60                   ld      H,B
2148+ 2215 C3 53 1D             jp      PUTFID          ; Put back "FOR" and continue
2149+ 2218
2150+ 2218 F9           KILFOR: ld      SP,HL           ; Remove "FOR" block
2151+ 2219 2A 7D 55             ld      HL,(BRKLIN)     ; Code string after "NEXT"
2152+ 221C 7E                   ld      A,(HL)          ; Get next byte in code string
2153+ 221D FE 2C                cp      ','             ; More NEXTs ?
2154+ 221F C2 57 1D             jp      NZ,RUNCNT       ; No - Do next statement
2155+ 2222 CD 97 1D             call    GETCHR          ; Position to index name
2156+ 2225 CD E0 21             call    NEXT1           ; Re-enter NEXT routine
2157+ 2228              ; < will not RETurn to here , Exit to RUNCNT or Loop >
2158+ 2228
2159+ 2228 CD 3A 22     GETNUM: call    EVAL            ; Get a numeric expression
2160+ 222B F6           TSTNUM: defb    $F6             ; Clear carry (numeric)
2161+ 222C 37           TSTSTR: scf                     ; Set carry (string)
2162+ 222D 3A 37 55     CHKTYP: ld      A,(TYPE)        ; Check types match
2163+ 2230 8F                   adc     A,A             ; Expected + actual
2164+ 2231 B7                   or      A               ; Clear carry , set parity
2165+ 2232 E8                   ret     PE              ; Even parity - Types match
2166+ 2233 C3 62 18             jp      TMERR           ; Different types - Error
2167+ 2236
2168+ 2236 CD 4E 1B     OPNPAR: call    CHKSYN          ; Make sure "(" follows
2169+ 2239 28                   defb    '('
2170+ 223A 2B           EVAL:   dec     HL              ; Evaluate expression & save
2171+ 223B 16 00                ld      D,$00           ; Precedence value
2172+ 223D D5           EVAL1:  push    DE              ; Save precedence
2173+ 223E 0E 01                ld      C,$01
2174+ 2240 CD 0D 18             call    CHKSTK          ; Check for 1 level of stack
2175+ 2243 CD B1 22             call    OPRND           ; Get next expression value
2176+ 2246 22 7F 55     EVAL2:  ld      (NXTOPR),HL     ; Save address of next operator
2177+ 2249 2A 7F 55     EVAL3:  ld      HL,(NXTOPR)     ; Restore address of next opr
2178+ 224C C1                   pop     BC              ; Precedence value and operator
2179+ 224D 78                   ld      A,B             ; Get precedence value
2180+ 224E FE 78                cp      $78             ; "AND", "OR", or "XOR" ?
2181+ 2250 D4 2B 22             call    NC,TSTNUM       ; No - Make sure it's a number
2182+ 2253 7E                   ld      A,(HL)          ; Get next operator / function
2183+ 2254 16 00                ld      D,$00           ; Clear Last relation
2184+ 2256 D6 CB        RLTLP:  sub     ZGTR            ; ">" Token
2185+ 2258 DA 72 22             jp      C,FOPRND        ; + - * / ^ AND OR XOR - Test it
2186+ 225B FE 03                cp      ZLTH+1-ZGTR     ; < = >
2187+ 225D D2 72 22             jp      NC,FOPRND       ; Function - Call it
2188+ 2260 FE 01                cp      ZEQUAL-ZGTR     ; "="
2189+ 2262 17                   rla                     ; <- Test for legal
2190+ 2263 AA                   xor     D               ; <- combinations of < = >
2191+ 2264 BA                   cp      D               ; <- by combining last token
2192+ 2265 57                   ld      D,A             ; <- with current one
2193+ 2266 DA 50 18             jp      C,SNERR         ; Error if "<<' '==" or ">>"
2194+ 2269 22 74 55             ld      (CUROPR),HL     ; Save address of current token
2195+ 226C CD 97 1D             call    GETCHR          ; Get next character
2196+ 226F C3 56 22             jp      RLTLP           ; Treat the two as one
2197+ 2272
2198+ 2272 7A           FOPRND: ld      A,D             ; < = > found ?
2199+ 2273 B7                   or      A
2200+ 2274 C2 B2 23             jp      NZ,TSTRED       ; Yes - Test for reduction
2201+ 2277 7E                   ld      A,(HL)          ; Get operator token
2202+ 2278 22 74 55             ld      (CUROPR),HL     ; Save operator address
2203+ 227B D6 C1                sub     ZPLUS           ; Operator or function?
2204+ 227D D8                   ret     C               ; Neither - Exit
2205+ 227E FE 0A                cp      ZOR+1-ZPLUS     ; Is it + - * / ^ AND XOR OR ?
2206+ 2280 D0                   ret     NC              ; No - Exit
2207+ 2281 5F                   ld      E,A             ; Coded operator
2208+ 2282 3A 37 55             ld      A,(TYPE)        ; Get data type
2209+ 2285 3D                   dec     A               ; FF = numeric , 00 = string
2210+ 2286 B3                   or      E               ; Combine with coded operator
2211+ 2287 7B                   ld      A,E             ; Get coded operator
2212+ 2288 CA 26 28             jp      Z,CONCAT        ; String concatenation
2213+ 228B 07                   rlca                    ; Times 2
2214+ 228C 83                   add     A,E             ; Times 3
2215+ 228D 5F                   ld      E,A             ; To DE (D is 0)
2216+ 228E 21 CB 16             ld      HL,PRITAB       ; Precedence table
2217+ 2291 19                   add     HL,DE           ; To the operator concerned
2218+ 2292 78                   ld      A,B             ; Last operator precedence
2219+ 2293 56                   ld      D,(HL)          ; Get evaluation precedence
2220+ 2294 BA                   cp      D               ; Compare with eval precedence
2221+ 2295 D0                   ret     NC              ; Exit if higher precedence
2222+ 2296 23                   inc     HL              ; Point to routine address
2223+ 2297 CD 2B 22             call    TSTNUM          ; Make sure it's a number
2224+ 229A
2225+ 229A C5           STKTHS: push    BC              ; Save last precedence & token
2226+ 229B 01 49 22             ld      BC,EVAL3        ; Where to go on prec' break
2227+ 229E C5                   push    BC              ; Save on stack for return
2228+ 229F 43                   ld      B,E             ; Save operator
2229+ 22A0 4A                   ld      C,D             ; Save precedence
2230+ 22A1 CD 66 30             call    STAKFP          ; Move value to stack
2231+ 22A4 58                   ld      E,B             ; Restore operator
2232+ 22A5 51                   ld      D,C             ; Restore precedence
2233+ 22A6 4E                   ld      C,(HL)          ; Get LSB of routine address
2234+ 22A7 23                   inc     HL
2235+ 22A8 46                   ld      B,(HL)          ; Get MSB of routine address
2236+ 22A9 23                   inc     HL
2237+ 22AA C5                   push    BC              ; Save routine address
2238+ 22AB 2A 74 55             ld      HL,(CUROPR)     ; Address of current operator
2239+ 22AE C3 3D 22             jp      EVAL1           ; Loop until prec' break
2240+ 22B1
2241+ 22B1 AF           OPRND:  xor     A               ; Get operand routine
2242+ 22B2 32 37 55             ld      (TYPE),A        ; Set numeric expected
2243+ 22B5 CD 97 1D             call    GETCHR          ; Get next character
2244+ 22B8 1E 24                ld      E,MO            ; ?MO Error
2245+ 22BA CA 6A 18             jp      Z,ERROR         ; No operand - Error
2246+ 22BD DA 3C 31             jp      C,ASCTFP        ; Number - Get value
2247+ 22C0 CD 39 1E             call    CHKLTR          ; See if a letter
2248+ 22C3 D2 18 23             jp      NC,CONVAR       ; Letter - Find variable
2249+ 22C6 FE 26                cp      '&'             ; &H = HEX, &B = BINARY
2250+ 22C8 20 12                jr      NZ,NOTAMP
2251+ 22CA CD 97 1D             call    GETCHR          ; Get next character
2252+ 22CD FE 48                cp      'H'             ; Hex number indicated? [function added]
2253+ 22CF CA 90 40             jp      Z,HEXTFP        ; Convert Hex to FPREG
2254+ 22D2 FE 42                cp      'B'             ; Binary number indicated? [function added]
2255+ 22D4 CA 00 41             jp      Z,BINTFP        ; Convert Bin to FPREG
2256+ 22D7 1E 02                ld      E,SN            ; If neither then a ?SN Error
2257+ 22D9 CA 6A 18             jp      Z,ERROR         ;
2258+ 22DC FE C1        NOTAMP: cp      ZPLUS           ; '+' Token ?
2259+ 22DE CA B1 22             jp      Z,OPRND         ; Yes - Look for operand
2260+ 22E1 FE 2E                cp      '.'             ; '.' ?
2261+ 22E3 CA 3C 31             jp      Z,ASCTFP        ; Yes - Create FP number
2262+ 22E6 FE C2                cp      ZMINUS          ; '-' Token ?
2263+ 22E8 CA 07 23             jp      Z,MINUS         ; Yes - Do minus
2264+ 22EB FE 22                cp      $22             ; '"'             ; Literal string ?
2265+ 22ED CA EF 26             jp      Z,QTSTR         ; Get string terminated by '"'
2266+ 22F0 FE BF                cp      ZNOT            ; "NOT" Token ?
2267+ 22F2 CA 12 24             jp      Z,EVNOT         ; Yes - Eval NOT expression
2268+ 22F5 FE BC                cp      ZFN             ; "FN" Token ?
2269+ 22F7 CA 53 26             jp      Z,DOFN          ; Yes - Do FN routine
2270+ 22FA D6 CE                sub     ZSGN            ; Is it a function?
2271+ 22FC D2 29 23             jp      NC,FNOFST       ; Yes - Evaluate function
2272+ 22FF CD 36 22     EVLPAR: call    OPNPAR          ; Evaluate expression in "()"
2273+ 2302 CD 4E 1B             call    CHKSYN          ; Make sure ")" follows
2274+ 2305 29                   defb    ')'
2275+ 2306 C9                   ret
2276+ 2307
2277+ 2307 16 7D        MINUS:  ld      D,$7D           ; '-' precedence
2278+ 2309 CD 3D 22             call    EVAL1           ; Evaluate until prec' break
2279+ 230C 2A 7F 55             ld      HL,(NXTOPR)     ; Get next operator address
2280+ 230F E5                   push    HL              ; Save next operator address
2281+ 2310 CD 5E 30             call    INVSGN          ; Negate value
2282+ 2313 CD 2B 22     RETNUM: call    TSTNUM          ; Make sure it's a number
2283+ 2316 E1                   pop     HL              ; Restore next operator address
2284+ 2317 C9                   ret
2285+ 2318
2286+ 2318 CD 37 24     CONVAR: call    GETVAR          ; Get variable address to DE
2287+ 231B E5           FRMEVL: push    HL              ; Save code string address
2288+ 231C EB                   ex      DE,HL           ; Variable address to HL
2289+ 231D 22 F9 55             ld      (FPREG),HL      ; Save address of variable
2290+ 2320 3A 37 55             ld      A,(TYPE)        ; Get type
2291+ 2323 B7                   or      A               ; Numeric?
2292+ 2324 CC 73 30             call    Z,PHLTFP        ; Yes - Move contents to FPREG
2293+ 2327 E1                   pop     HL              ; Restore code string address
2294+ 2328 C9                   ret
2295+ 2329
2296+ 2329 06 00        FNOFST: ld      B,$00           ; Get address of function
2297+ 232B 07                   rlca                    ; Double function offset
2298+ 232C 4F                   ld      C,A             ; BC = Offset in function table
2299+ 232D C5                   push    BC              ; Save adjusted token value
2300+ 232E CD 97 1D             call    GETCHR          ; Get next character
2301+ 2331 79                   ld      A,C             ; Get adjusted token value
2302+ 2332 FE 2C                cp      2*(ZPOINT-ZSGN) ; "POINT" token?
2303+ 2334 CA 54 38             jp      Z,POINT         ; Yes, do "POINT"
2304+ 2337 FE 2E                cp      2*(ZINSTR-ZSGN) ; "INSTR" token?
2305+ 2339 CA 02 29             jp      Z,INSTR         ; Yes, do "INSTR"
2306+ 233C FE 43                cp      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
2307+ 233E DA 5A 23             jp      C,FNVAL         ; No - Do function
2308+ 2341 CD 36 22             call    OPNPAR          ; Evaluate expression  (X,...
2309+ 2344 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
2310+ 2347 2C                   defb    ','
2311+ 2348 CD 2C 22             call    TSTSTR          ; Make sure it's a string
2312+ 234B EB                   ex      DE,HL           ; Save code string address
2313+ 234C 2A F9 55             ld      HL,(FPREG)      ; Get address of string
2314+ 234F E3                   ex      (SP),HL         ; Save address of string
2315+ 2350 E5                   push    HL              ; Save adjusted token value
2316+ 2351 EB                   ex      DE,HL           ; Restore code string address
2317+ 2352 CD AE 2A             call    GETINT          ; Get integer 0-255
2318+ 2355 EB                   ex      DE,HL           ; Save code string address
2319+ 2356 E3                   ex      (SP),HL         ; Save integer,HL = adj' token
2320+ 2357 C3 62 23             jp      GOFUNC          ; Jump to string function
2321+ 235A
2322+ 235A CD FF 22     FNVAL:  call    EVLPAR          ; Evaluate expression
2323+ 235D E3                   ex      (SP),HL         ; HL = Adjusted token value
2324+ 235E 11 13 23             ld      DE,RETNUM       ; Return number from function
2325+ 2361 D5                   push    DE              ; Save on stack
2326+ 2362 01 65 14     GOFUNC: ld      BC,FNCTAB       ; Function routine addresses
2327+ 2365 09                   add     HL,BC           ; Point to right address
2328+ 2366 4E                   ld      C,(HL)          ; Get LSB of address
2329+ 2367 23                   inc     HL              ;
2330+ 2368 66                   ld      H,(HL)          ; Get MSB of address
2331+ 2369 69                   ld      L,C             ; Address to HL
2332+ 236A E9                   jp      (HL)            ; Jump to function
2333+ 236B
2334+ 236B 15           SGNEXP: dec     D               ; Dee to flag negative exponent
2335+ 236C FE C2                cp      ZMINUS          ; '-' token ?
2336+ 236E C8                   ret     Z               ; Yes - Return
2337+ 236F FE 2D                cp      '-'             ; '-' ASCII ?
2338+ 2371 C8                   ret     Z               ; Yes - Return
2339+ 2372 14                   inc     D               ; Inc to flag positive exponent
2340+ 2373 FE 2B                cp      '+'             ; '+' ASCII ?
2341+ 2375 C8                   ret     Z               ; Yes - Return
2342+ 2376 FE C1                cp      ZPLUS           ; '+' token ?
2343+ 2378 C8                   ret     Z               ; Yes - Return
2344+ 2379 2B                   dec     HL              ; dec 'cos GETCHR INCs
2345+ 237A C9                   ret                     ; Return "NZ"
2346+ 237B
2347+ 237B              ; execute OR, AND, and XOR operations
2348+ 237B AF           PAND:   xor     A               ; for AND, Z=1
2349+ 237C 18 07                jr      CNTLGC
2350+ 237E AF           POR:    xor     A               ; for OR, Z=0, S=1
2351+ 237F D6 01                sub     $01
2352+ 2381 18 02                jr      CNTLGC
2353+ 2383 AF           PXOR:   xor     A               ; for XOR, Z=0, S=0
2354+ 2384 3C                   inc     A
2355+ 2385 F5           CNTLGC: push    AF              ; store operand's flags
2356+ 2386 CD 2B 22             call    TSTNUM          ; Make sure it's a number
2357+ 2389 CD 4D 1E             call    DEINT           ; Get integer -32768 to 32767
2358+ 238C F1                   pop     AF              ; retrieve operand's flags
2359+ 238D EB                   ex      DE,HL           ; <- Get last
2360+ 238E C1                   pop     BC              ; <-  value
2361+ 238F E3                   ex      (SP),HL         ; <-  from
2362+ 2390 EB                   ex      DE,HL           ; <-  stack
2363+ 2391 CD 76 30             call    FPBCDE          ; Move last value to FPREG
2364+ 2394 F5                   push    AF              ; store operand's flags
2365+ 2395 CD 4D 1E             call    DEINT           ; Get integer -32768 to 32767
2366+ 2398 F1                   pop     AF              ; retrieve operand's flags
2367+ 2399 C1                   pop     BC              ; Get value
2368+ 239A 79                   ld      A,C             ; Get LSB
2369+ 239B 21 11 26             ld      HL,ACPASS       ; Address of save AC as current
2370+ 239E 20 05                jr      NZ,POR1         ; if X/OR, jump over
2371+ 23A0 A3           PAND1:  and     E               ; "AND" LSBs
2372+ 23A1 4F                   ld      C,A             ; Save LSB
2373+ 23A2 78                   ld      A,B             ; Get MSB
2374+ 23A3 A2                   and     D               ; "AND" MSBs
2375+ 23A4 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2376+ 23A5 F2 AD 23     POR1:   jp      P,PXOR1         ; if S=0, jump to XOR
2377+ 23A8 B3                   or      E               ; "OR" LSBs
2378+ 23A9 4F                   ld      C,A             ; Save LSB
2379+ 23AA 78                   ld      A,B             ; Get MSB
2380+ 23AB B2                   or      D               ; "OR" MSBs
2381+ 23AC E9                   jp      (HL)            ; Save AC as current (ACPASS)
2382+ 23AD AB           PXOR1:  xor     E               ; "XOR" LSBs
2383+ 23AE 4F                   ld      C,A             ; Save LSB
2384+ 23AF 78                   ld      A,B             ; Get MSB
2385+ 23B0 AA                   xor     D               ; "XOR" MSBs
2386+ 23B1 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2387+ 23B2
2388+ 23B2 21 C4 23     TSTRED: ld      HL,CMPLOG       ; Logical compare routine
2389+ 23B5 3A 37 55             ld      A,(TYPE)        ; Get data type
2390+ 23B8 1F                   rra                     ; Carry set = string
2391+ 23B9 7A                   ld      A,D             ; Get last precedence value
2392+ 23BA 17                   rla                     ; Times 2 plus carry
2393+ 23BB 5F                   ld      E,A             ; To E
2394+ 23BC 16 64                ld      D,$64           ; Relational precedence
2395+ 23BE 78                   ld      A,B             ; Get current precedence
2396+ 23BF BA                   cp      D               ; Compare with last
2397+ 23C0 D0                   ret     NC              ; Eval if last was rel' or log'
2398+ 23C1 C3 9A 22             jp      STKTHS          ; Stack this one and get next
2399+ 23C4
2400+ 23C4 C6 23        CMPLOG: defw    CMPLG1          ; Compare two values / strings
2401+ 23C6 79           CMPLG1: ld      A,C             ; Get data type
2402+ 23C7 B7                   or      A
2403+ 23C8 1F                   rra
2404+ 23C9 C1                   pop     BC              ; Get last expression to BCDE
2405+ 23CA D1                   pop     DE
2406+ 23CB F5                   push    AF              ; Save status
2407+ 23CC CD 2D 22             call    CHKTYP          ; Check that types match
2408+ 23CF 21 08 24             ld      HL,CMPRES       ; Result to comparison
2409+ 23D2 E5                   push    HL              ; Save for RETurn
2410+ 23D3 CA B0 30             jp      Z,CMPNUM        ; Compare values if numeric
2411+ 23D6 AF                   xor     A               ; Compare two strings
2412+ 23D7 32 37 55             ld      (TYPE),A        ; Set type to numeric
2413+ 23DA D5                   push    DE              ; Save string name
2414+ 23DB CD 73 28             call    GSTRCU          ; Get current string
2415+ 23DE 7E                   ld      A,(HL)          ; Get length of string
2416+ 23DF 23                   inc     HL
2417+ 23E0 23                   inc     HL
2418+ 23E1 4E                   ld      C,(HL)          ; Get LSB of address
2419+ 23E2 23                   inc     HL
2420+ 23E3 46                   ld      B,(HL)          ; Get MSB of address
2421+ 23E4 D1                   pop     DE              ; Restore string name
2422+ 23E5 C5                   push    BC              ; Save address of string
2423+ 23E6 F5                   push    AF              ; Save length of string
2424+ 23E7 CD 77 28             call    GSTRDE          ; Get second string
2425+ 23EA CD 84 30             call    LOADFP          ; Get address of second string
2426+ 23ED F1                   pop     AF              ; Restore length of string 1
2427+ 23EE 57                   ld      D,A             ; Length to D
2428+ 23EF E1                   pop     HL              ; Restore address of string 1
2429+ 23F0 7B           CMPSTR: ld      A,E             ; Bytes of string 2 to do
2430+ 23F1 B2                   or      D               ; Bytes of string 1 to do
2431+ 23F2 C8                   ret     Z               ; Exit if all bytes compared
2432+ 23F3 7A                   ld      A,D             ; Get bytes of string 1 to do
2433+ 23F4 D6 01                sub     $01
2434+ 23F6 D8                   ret     C               ; Exit if end of string 1
2435+ 23F7 AF                   xor     A
2436+ 23F8 BB                   cp      E               ; Bytes of string 2 to do
2437+ 23F9 3C                   inc     A
2438+ 23FA D0                   ret     NC              ; Exit if end of string 2
2439+ 23FB 15                   dec     D               ; Count bytes in string 1
2440+ 23FC 1D                   dec     E               ; Count bytes in string 2
2441+ 23FD 0A                   ld      A,(BC)          ; Byte in string 2
2442+ 23FE BE                   cp      (HL)            ; Compare to byte in string 1
2443+ 23FF 23                   inc     HL              ; Move up string 1
2444+ 2400 03                   inc     BC              ; Move up string 2
2445+ 2401 CA F0 23             jp      Z,CMPSTR        ; Same - Try next bytes
2446+ 2404 3F                   ccf                     ; Flag difference (">" or "<")
2447+ 2405 C3 40 30             jp      FLGDIF          ; "<" gives -1 , ">" gives +1
2448+ 2408
2449+ 2408 3C           CMPRES: inc     A               ; Increment current value
2450+ 2409 8F                   adc     A,A             ; Double plus carry
2451+ 240A C1                   pop     BC              ; Get other value
2452+ 240B A0                   and     B               ; Combine them
2453+ 240C C6 FF                add     A,-1            ; Carry set if different
2454+ 240E 9F                   sbc     A,A             ; 00 - Equal , FF - Different
2455+ 240F C3 47 30             jp      FLGREL          ; Set current value & continue
2456+ 2412
2457+ 2412 16 5A        EVNOT:  ld      D,$5A           ; Precedence value for "NOT"
2458+ 2414 CD 3D 22             call    EVAL1           ; Eval until precedence break
2459+ 2417 CD 2B 22             call    TSTNUM          ; Make sure it's a number
2460+ 241A CD 4D 1E             call    DEINT           ; Get integer -32768 - 32767
2461+ 241D 7B                   ld      A,E             ; Get LSB
2462+ 241E 2F                   cpl                     ; Invert LSB
2463+ 241F 4F                   ld      C,A             ; Save "NOT" of LSB
2464+ 2420 7A                   ld      A,D             ; Get MSB
2465+ 2421 2F                   cpl                     ; Invert MSB
2466+ 2422 CD 11 26             call    ACPASS          ; Save AC as current
2467+ 2425 C1                   pop     BC              ; Clean up stack
2468+ 2426 C3 49 22             jp      EVAL3           ; Continue evaluation
2469+ 2429
2470+ 2429 2B           DIMRET: dec     HL              ; dec 'cos GETCHR INCs
2471+ 242A CD 97 1D             call    GETCHR          ; Get next character
2472+ 242D C8                   ret     Z               ; End of DIM statement
2473+ 242E CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
2474+ 2431 2C                   defb    ','
2475+ 2432 01 29 24     DIM:    ld      BC,DIMRET       ; Return to "DIMRET"
2476+ 2435 C5                   push    BC              ; Save on stack
2477+ 2436 F6                   defb    $F6             ; Flag "Create" variable
2478+ 2437 AF           GETVAR: xor     A               ; Find variable address,to DE
2479+ 2438 32 36 55             ld      (LCRFLG),A      ; Set locate / create flag
2480+ 243B 46                   ld      B,(HL)          ; Get First byte of name
2481+ 243C CD 39 1E     GTFNAM: call    CHKLTR          ; See if a letter
2482+ 243F DA 50 18             jp      C,SNERR         ; ?SN Error if not a letter
2483+ 2442 AF                   xor     A
2484+ 2443 4F                   ld      C,A             ; Clear second byte of name
2485+ 2444 32 37 55             ld      (TYPE),A        ; Set type to numeric
2486+ 2447 CD 97 1D             call    GETCHR          ; Get next character
2487+ 244A DA 53 24             jp      C,SVNAM2        ; Numeric - Save in name
2488+ 244D CD 39 1E             call    CHKLTR          ; See if a letter
2489+ 2450 DA 60 24             jp      C,CHARTY        ; Not a letter - Check type
2490+ 2453 4F           SVNAM2: ld      C,A             ; Save second byte of name
2491+ 2454 CD 97 1D     ENDNAM: call    GETCHR          ; Get next character
2492+ 2457 DA 54 24             jp      C,ENDNAM        ; Numeric - Get another
2493+ 245A CD 39 1E             call    CHKLTR          ; See if a letter
2494+ 245D D2 54 24             jp      NC,ENDNAM       ; Letter - Get another
2495+ 2460 D6 24        CHARTY: sub     '$'             ; String variable?
2496+ 2462 C2 6F 24             jp      NZ,NOTSTR       ; No - Numeric variable
2497+ 2465 3C                   inc     A               ; A = 1 (string type)
2498+ 2466 32 37 55             ld      (TYPE),A        ; Set type to string
2499+ 2469 0F                   rrca                    ; A = 80H , Flag for string
2500+ 246A 81                   add     A,C             ; 2nd byte of name has bit 7 on
2501+ 246B 4F                   ld      C,A             ; Resave second byte on name
2502+ 246C CD 97 1D             call    GETCHR          ; Get next character
2503+ 246F 3A 7A 55     NOTSTR: ld      A,(FORFLG)      ; Array name needed ?
2504+ 2472 3D                   dec     A
2505+ 2473 CA 1C 25             jp      Z,ARLDSV        ; Yes - Get array name
2506+ 2476 F2 7F 24             jp      P,NSCFOR        ; No array with "FOR" or "FN"
2507+ 2479 7E                   ld      A,(HL)          ; Get byte again
2508+ 247A D6 28                sub     '('             ; Subscripted variable?
2509+ 247C CA F4 24             jp      Z,SBSCPT        ; Yes - Sort out subscript
2510+ 247F
2511+ 247F AF           NSCFOR: xor     A               ; Simple variable
2512+ 2480 32 7A 55             ld      (FORFLG),A      ; Clear "FOR" flag
2513+ 2483 E5                   push    HL              ; Save code string address
2514+ 2484 50                   ld      D,B             ; DE = Variable name to find
2515+ 2485 59                   ld      E,C
2516+ 2486 2A F3 55             ld      HL,(FNRGNM)     ; FN argument name
2517+ 2489 CD 48 1B             call    CPDEHL          ; Is it the FN argument?
2518+ 248C 11 F5 55             ld      DE,FNARG        ; Point to argument value
2519+ 248F CA 25 2F             jp      Z,POPHRT        ; Yes - Return FN argument value
2520+ 2492 2A ED 55             ld      HL,(VAREND)     ; End of variables
2521+ 2495 EB                   ex      DE,HL           ; Address of end of search
2522+ 2496 2A EB 55             ld      HL,(PROGND)     ; Start of variables address
2523+ 2499 CD 48 1B     FNDVAR: call    CPDEHL          ; End of variable list table?
2524+ 249C CA B2 24             jp      Z,CFEVAL        ; Yes - Called from EVAL?
2525+ 249F 79                   ld      A,C             ; Get second byte of name
2526+ 24A0 96                   sub     (HL)            ; Compare with name in list
2527+ 24A1 23                   inc     HL              ; Move on to first byte
2528+ 24A2 C2 A7 24             jp      NZ,FNTHR        ; Different - Find another
2529+ 24A5 78                   ld      A,B             ; Get first byte of name
2530+ 24A6 96                   sub     (HL)            ; Compare with name in list
2531+ 24A7 23           FNTHR:  inc     HL              ; Move on to LSB of value
2532+ 24A8 CA E6 24             jp      Z,RETADR        ; Found - Return address
2533+ 24AB 23                   inc     HL              ; <- Skip
2534+ 24AC 23                   inc     HL              ; <- over
2535+ 24AD 23                   inc     HL              ; <- F.P.
2536+ 24AE 23                   inc     HL              ; <- value
2537+ 24AF C3 99 24             jp      FNDVAR          ; Keep looking
2538+ 24B2
2539+ 24B2 E1           CFEVAL: pop     HL              ; Restore code string address
2540+ 24B3 E3                   ex      (SP),HL         ; Get return address
2541+ 24B4 D5                   push    DE              ; Save address of variable
2542+ 24B5 11 1B 23             ld      DE,FRMEVL       ; Return address in EVAL
2543+ 24B8 CD 48 1B             call    CPDEHL          ; Called from EVAL ?
2544+ 24BB D1                   pop     DE              ; Restore address of variable
2545+ 24BC CA E9 24             jp      Z,RETNUL        ; Yes - Return null variable
2546+ 24BF E3                   ex      (SP),HL         ; Put back return
2547+ 24C0 E5                   push    HL              ; Save code string address
2548+ 24C1 C5                   push    BC              ; Save variable name
2549+ 24C2 01 06 00             ld      BC,$0006        ; 2 byte name plus 4 byte data
2550+ 24C5 2A EF 55             ld      HL,(ARREND)     ; End of arrays
2551+ 24C8 E5                   push    HL              ; Save end of arrays
2552+ 24C9 09                   add     HL,BC           ; Move up 6 bytes
2553+ 24CA C1                   pop     BC              ; Source address in BC
2554+ 24CB E5                   push    HL              ; Save new end address
2555+ 24CC CD FC 17             call    MOVUP           ; Move arrays up
2556+ 24CF E1                   pop     HL              ; Restore new end address
2557+ 24D0 22 EF 55             ld      (ARREND),HL     ; Set new end address
2558+ 24D3 60                   ld      H,B             ; End of variables to HL
2559+ 24D4 69                   ld      L,C
2560+ 24D5 22 ED 55             ld      (VAREND),HL     ; Set new end address
2561+ 24D8
2562+ 24D8 2B           ZEROLP: dec     HL              ; Back through to zero variable
2563+ 24D9 36 00                ld      (HL),$00        ; Zero byte in variable
2564+ 24DB CD 48 1B             call    CPDEHL          ; Done them all?
2565+ 24DE C2 D8 24             jp      NZ,ZEROLP       ; No - Keep on going
2566+ 24E1 D1                   pop     DE              ; Get variable name
2567+ 24E2 73                   ld      (HL),E          ; Store second character
2568+ 24E3 23                   inc     HL
2569+ 24E4 72                   ld      (HL),D          ; Store first character
2570+ 24E5 23                   inc     HL
2571+ 24E6 EB           RETADR: ex      DE,HL           ; Address of variable in DE
2572+ 24E7 E1                   pop     HL              ; Restore code string address
2573+ 24E8 C9                   ret
2574+ 24E9
2575+ 24E9 32 FC 55     RETNUL: ld      (FPEXP),A       ; Set result to zero
2576+ 24EC 21 CD 17             ld      HL,ZERBYT       ; Also set a null string
2577+ 24EF 22 F9 55             ld      (FPREG),HL      ; Save for EVAL
2578+ 24F2 E1                   pop     HL              ; Restore code string address
2579+ 24F3 C9                   ret
2580+ 24F4
2581+ 24F4 E5           SBSCPT: push    HL              ; Save code string address
2582+ 24F5 2A 36 55             ld      HL,(LCRFLG)     ; Locate/Create and Type
2583+ 24F8 E3                   ex      (SP),HL         ; Save and get code string
2584+ 24F9 57                   ld      D,A             ; Zero number of dimensions
2585+ 24FA D5           SCPTLP: push    DE              ; Save number of dimensions
2586+ 24FB C5                   push    BC              ; Save array name
2587+ 24FC CD 41 1E             call    FPSINT          ; Get subscript (0-32767)
2588+ 24FF C1                   pop     BC              ; Restore array name
2589+ 2500 F1                   pop     AF              ; Get number of dimensions
2590+ 2501 EB                   ex      DE,HL
2591+ 2502 E3                   ex      (SP),HL         ; Save subscript value
2592+ 2503 E5                   push    HL              ; Save LCRFLG and TYPE
2593+ 2504 EB                   ex      DE,HL
2594+ 2505 3C                   inc     A               ; Count dimensions
2595+ 2506 57                   ld      D,A             ; Save in D
2596+ 2507 7E                   ld      A,(HL)          ; Get next byte in code string
2597+ 2508 FE 2C                cp      ','             ; Comma (more to come)?
2598+ 250A CA FA 24             jp      Z,SCPTLP        ; Yes - More subscripts
2599+ 250D CD 4E 1B             call    CHKSYN          ; Make sure ")" follows
2600+ 2510 29                   defb    ')'
2601+ 2511 22 7F 55             ld      (NXTOPR),HL     ; Save code string address
2602+ 2514 E1                   pop     HL              ; Get LCRFLG and TYPE
2603+ 2515 22 36 55             ld      (LCRFLG),HL     ; Restore Locate/create & type
2604+ 2518 1E 00                ld      E,$00           ; Flag not CSAVE* or CLOAD*
2605+ 251A D5                   push    DE              ; Save number of dimensions (D)
2606+ 251B 11                   defb    $11             ; Skip "push HL" and "push AF'
2607+ 251C
2608+ 251C E5           ARLDSV: push    HL              ; Save code string address
2609+ 251D F5                   push    AF              ; A = 00 , Flags set = Z,N
2610+ 251E 2A ED 55             ld      HL,(VAREND)     ; Start of arrays
2611+ 2521 3E                   defb    $3E             ; Skip "add HL,DE"
2612+ 2522 19           FNDARY: add     HL,DE           ; Move to next array start
2613+ 2523 EB                   ex      DE,HL
2614+ 2524 2A EF 55             ld      HL,(ARREND)     ; End of arrays
2615+ 2527 EB                   ex      DE,HL           ; Current array pointer
2616+ 2528 CD 48 1B             call    CPDEHL          ; End of arrays found?
2617+ 252B CA 54 25             jp      Z,CREARY        ; Yes - Create array
2618+ 252E 7E                   ld      A,(HL)          ; Get second byte of name
2619+ 252F B9                   cp      C               ; Compare with name given
2620+ 2530 23                   inc     HL              ; Move on
2621+ 2531 C2 36 25             jp      NZ,NXTARY       ; Different - Find next array
2622+ 2534 7E                   ld      A,(HL)          ; Get first byte of name
2623+ 2535 B8                   cp      B               ; Compare with name given
2624+ 2536 23           NXTARY: inc     HL              ; Move on
2625+ 2537 5E                   ld      E,(HL)          ; Get LSB of next array address
2626+ 2538 23                   inc     HL
2627+ 2539 56                   ld      D,(HL)          ; Get MSB of next array address
2628+ 253A 23                   inc     HL
2629+ 253B C2 22 25             jp      NZ,FNDARY       ; Not found - Keep looking
2630+ 253E 3A 36 55             ld      A,(LCRFLG)      ; Found Locate or Create it?
2631+ 2541 B7                   or      A
2632+ 2542 C2 59 18             jp      NZ,DDERR        ; Create - ?DD Error
2633+ 2545 F1                   pop     AF              ; Locate - Get number of dim'ns
2634+ 2546 44                   ld      B,H             ; BC Points to array dim'ns
2635+ 2547 4D                   ld      C,L
2636+ 2548 CA 25 2F             jp      Z,POPHRT        ; Jump if array load/save
2637+ 254B 96                   sub     (HL)            ; Same number of dimensions?
2638+ 254C CA B2 25             jp      Z,FINDEL        ; Yes - Find element
2639+ 254F 1E 10        BSERR:  ld      E,BS            ; ?BS Error
2640+ 2551 C3 6A 18             jp      ERROR           ; Output error
2641+ 2554
2642+ 2554 11 04 00     CREARY: ld      DE,$0004        ; 4 Bytes per entry
2643+ 2557 F1                   pop     AF              ; Array to save or 0 dim'ns?
2644+ 2558 CA 62 1E             jp      Z,FCERR         ; Yes - ?FC Error
2645+ 255B 71                   ld      (HL),C          ; Save second byte of name
2646+ 255C 23                   inc     HL
2647+ 255D 70                   ld      (HL),B          ; Save first byte of name
2648+ 255E 23                   inc     HL
2649+ 255F 4F                   ld      C,A             ; Number of dimensions to C
2650+ 2560 CD 0D 18             call    CHKSTK          ; Check if enough memory
2651+ 2563 23                   inc     HL              ; Point to number of dimensions
2652+ 2564 23                   inc     HL
2653+ 2565 22 74 55             ld      (CUROPR),HL     ; Save address of pointer
2654+ 2568 71                   ld      (HL),C          ; Set number of dimensions
2655+ 2569 23                   inc     HL
2656+ 256A 3A 36 55             ld      A,(LCRFLG)      ; Locate of Create?
2657+ 256D 17                   rla                     ; Carry set = Create
2658+ 256E 79                   ld      A,C             ; Get number of dimensions
2659+ 256F 01 0B 00     CRARLP: ld      BC,10+1         ; Default dimension size 10
2660+ 2572 D2 77 25             jp      NC,DEFSIZ       ; Locate - Set default size
2661+ 2575 C1                   pop     BC              ; Get specified dimension size
2662+ 2576 03                   inc     BC              ; Include zero element
2663+ 2577 71           DEFSIZ: ld      (HL),C          ; Save LSB of dimension size
2664+ 2578 23                   inc     HL
2665+ 2579 70                   ld      (HL),B          ; Save MSB of dimension size
2666+ 257A 23                   inc     HL
2667+ 257B F5                   push    AF              ; Save num' of dim'ns an status
2668+ 257C E5                   push    HL              ; Save address of dim'n size
2669+ 257D CD 21 31             call    MLDEBC          ; Multiply DE by BC to find
2670+ 2580 EB                   ex      DE,HL           ; amount of mem needed (to DE)
2671+ 2581 E1                   pop     HL              ; Restore address of dimension
2672+ 2582 F1                   pop     AF              ; Restore number of dimensions
2673+ 2583 3D                   dec     A               ; Count them
2674+ 2584 C2 6F 25             jp      NZ,CRARLP       ; Do next dimension if more
2675+ 2587 F5                   push    AF              ; Save locate/create flag
2676+ 2588 42                   ld      B,D             ; MSB of memory needed
2677+ 2589 4B                   ld      C,E             ; LSB of memory needed
2678+ 258A EB                   ex      DE,HL
2679+ 258B 19                   add     HL,DE           ; Add bytes to array start
2680+ 258C DA 25 18             jp      C,OMERR         ; Too big - Error
2681+ 258F CD 16 18             call    ENFMEM          ; See if enough memory
2682+ 2592 22 EF 55             ld      (ARREND),HL     ; Save new end of array
2683+ 2595
2684+ 2595 2B           ZERARY: dec     HL              ; Back through array data
2685+ 2596 36 00                ld      (HL),$00        ; Set array element to zero
2686+ 2598 CD 48 1B             call    CPDEHL          ; All elements zeroed?
2687+ 259B C2 95 25             jp      NZ,ZERARY       ; No - Keep on going
2688+ 259E 03                   inc     BC              ; Number of bytes + 1
2689+ 259F 57                   ld      D,A             ; A=0
2690+ 25A0 2A 74 55             ld      HL,(CUROPR)     ; Get address of array
2691+ 25A3 5E                   ld      E,(HL)          ; Number of dimensions
2692+ 25A4 EB                   ex      DE,HL           ; To HL
2693+ 25A5 29                   add     HL,HL           ; Two bytes per dimension size
2694+ 25A6 09                   add     HL,BC           ; Add number of bytes
2695+ 25A7 EB                   ex      DE,HL           ; Bytes needed to DE
2696+ 25A8 2B                   dec     HL
2697+ 25A9 2B                   dec     HL
2698+ 25AA 73                   ld      (HL),E          ; Save LSB of bytes needed
2699+ 25AB 23                   inc     HL
2700+ 25AC 72                   ld      (HL),D          ; Save MSB of bytes needed
2701+ 25AD 23                   inc     HL
2702+ 25AE F1                   pop     AF              ; Locate / Create?
2703+ 25AF DA D6 25             jp      C,ENDDIM        ; A is 0 , End if create
2704+ 25B2 47           FINDEL: ld      B,A             ; Find array element
2705+ 25B3 4F                   ld      C,A
2706+ 25B4 7E                   ld      A,(HL)          ; Number of dimensions
2707+ 25B5 23                   inc     HL
2708+ 25B6 16                   defb    $16             ; Skip "pop HL"
2709+ 25B7 E1           FNDELP: pop     HL              ; Address of next dim' size
2710+ 25B8 5E                   ld      E,(HL)          ; Get LSB of dim'n size
2711+ 25B9 23                   inc     HL
2712+ 25BA 56                   ld      D,(HL)          ; Get MSB of dim'n size
2713+ 25BB 23                   inc     HL
2714+ 25BC E3                   ex      (SP),HL         ; Save address - Get index
2715+ 25BD F5                   push    AF              ; Save number of dim'ns
2716+ 25BE CD 48 1B             call    CPDEHL          ; Dimension too large?
2717+ 25C1 D2 4F 25             jp      NC,BSERR        ; Yes - ?BS Error
2718+ 25C4 E5                   push    HL              ; Save index
2719+ 25C5 CD 21 31             call    MLDEBC          ; Multiply previous by size
2720+ 25C8 D1                   pop     DE              ; Index supplied to DE
2721+ 25C9 19                   add     HL,DE           ; Add index to pointer
2722+ 25CA F1                   pop     AF              ; Number of dimensions
2723+ 25CB 3D                   dec     A               ; Count them
2724+ 25CC 44                   ld      B,H             ; MSB of pointer
2725+ 25CD 4D                   ld      C,L             ; LSB of pointer
2726+ 25CE C2 B7 25             jp      NZ,FNDELP       ; More - Keep going
2727+ 25D1 29                   add     HL,HL           ; 4 Bytes per element
2728+ 25D2 29                   add     HL,HL
2729+ 25D3 C1                   pop     BC              ; Start of array
2730+ 25D4 09                   add     HL,BC           ; Point to element
2731+ 25D5 EB                   ex      DE,HL           ; Address of element to DE
2732+ 25D6 2A 7F 55     ENDDIM: ld      HL,(NXTOPR)     ; Got code string address
2733+ 25D9 C9                   ret
2734+ 25DA
2735+ 25DA
2736+ 25DA              ; returns the value of the 32-bit system tick counter as
2737+ 25DA              ; two 16-bit words
2738+ 25DA CD 2B 22     TMR:    call    TSTNUM          ; Make sure it's a number
2739+ 25DD CD 4D 1E             call    DEINT           ; Get integer (-32768 to 32767)
2740+ 25E0 2A 85 55             ld      HL,(TMRCNT)     ; load the LSBytes of timer
2741+ 25E3 7B                   ld      A,E
2742+ 25E4 B2                   or      D               ; is it 0?
2743+ 25E5 CA EB 25             jp      Z,ENDTMR        ; yes, jump over
2744+ 25E8 2A 87 55             ld      HL,(TMRCNT+2)   ; load the MSBytes of timer
2745+ 25EB 45           ENDTMR: ld      B,L             ; move bytes...
2746+ 25EC 7C                   ld      A,H             ; ...into AB
2747+ 25ED C3 12 26             jp      ABPASS          ; return word into AB
2748+ 25F0
2749+ 25F0
2750+ 25F0              ; returns the free space for BASIC or into the string pool
2751+ 25F0 2A EF 55     FRE:    ld      HL,(ARREND)     ; Start of free memory
2752+ 25F3 EB                   ex      DE,HL           ; To DE
2753+ 25F4 21 00 00             ld      HL,$0000        ; End of free memory
2754+ 25F7 39                   add     HL,SP           ; Current stack value
2755+ 25F8 3A 37 55             ld      A,(TYPE)        ; Dummy argument type
2756+ 25FB B7                   or      A
2757+ 25FC CA 0C 26             jp      Z,FRENUM        ; Numeric - Free variable space
2758+ 25FF CD 73 28             call    GSTRCU          ; Current string to pool
2759+ 2602 CD 73 27             call    GARBGE          ; Garbage collection
2760+ 2605 2A 50 54             ld      HL,(STRSPC)     ; Bottom of string space in use
2761+ 2608 EB                   ex      DE,HL           ; To DE
2762+ 2609 2A 72 55             ld      HL,(STRBOT)     ; Bottom of string space
2763+ 260C 7D           FRENUM: ld      A,L             ; Get LSB of end
2764+ 260D 93                   sub     E               ; Subtract LSB of beginning
2765+ 260E 4F                   ld      C,A             ; Save difference if C
2766+ 260F 7C                   ld      A,H             ; Get MSB of end
2767+ 2610 9A                   sbc     A,D             ; Subtract MSB of beginning
2768+ 2611 41           ACPASS: ld      B,C             ; Return integer AC
2769+ 2612 50           ABPASS: ld      D,B             ; Return integer AB
2770+ 2613 1E 00                ld      E,$00
2771+ 2615 21 37 55             ld      HL,TYPE         ; Point to type
2772+ 2618 73                   ld      (HL),E          ; Set type to numeric
2773+ 2619 06 90                ld      B,$80+$10       ; 16 bit integer
2774+ 261B C3 4C 30             jp      RETINT          ; Return the integer
2775+ 261E
2776+ 261E              ; returns the X position of the cursor during a print
2777+ 261E 3A 35 55     POS:    ld      A,(CURPOS)      ; Get cursor position
2778+ 2621              ; return the value in A as a number
2779+ 2621 47           PASSA:  ld      B,A             ; Put A into AB
2780+ 2622 AF                   xor     A               ; Zero A
2781+ 2623 C3 12 26             jp      ABPASS          ; Return integer AB
2782+ 2626
2783+ 2626 CD A9 26     DEF:    call    CHEKFN          ; Get "FN" and name
2784+ 2629 CD 9B 26             call    IDTEST          ; Test for illegal direct
2785+ 262C 01 40 1F             ld      BC,DATA         ; To get next statement
2786+ 262F C5                   push    BC              ; Save address for RETurn
2787+ 2630 D5                   push    DE              ; Save address of function ptr
2788+ 2631 CD 4E 1B             call    CHKSYN          ; Make sure "(" follows
2789+ 2634 28                   defb    '('
2790+ 2635 CD 37 24             call    GETVAR          ; Get argument variable name
2791+ 2638 E5                   push    HL              ; Save code string address
2792+ 2639 EB                   ex      DE,HL           ; Argument address to HL
2793+ 263A 2B                   dec     HL
2794+ 263B 56                   ld      D,(HL)          ; Get first byte of arg name
2795+ 263C 2B                   dec     HL
2796+ 263D 5E                   ld      E,(HL)          ; Get second byte of arg name
2797+ 263E E1                   pop     HL              ; Restore code string address
2798+ 263F CD 2B 22             call    TSTNUM          ; Make sure numeric argument
2799+ 2642 CD 4E 1B             call    CHKSYN          ; Make sure ")" follows
2800+ 2645 29                   defb    ')'
2801+ 2646 CD 4E 1B             call    CHKSYN          ; Make sure "=" follows
2802+ 2649 CC                   defb    ZEQUAL          ; "=" token
2803+ 264A 44                   ld      B,H             ; Code string address to BC
2804+ 264B 4D                   ld      C,L
2805+ 264C E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2806+ 264D 71                   ld      (HL),C          ; Save LSB of FN code string
2807+ 264E 23                   inc     HL
2808+ 264F 70                   ld      (HL),B          ; Save MSB of FN code string
2809+ 2650 C3 E8 26             jp      SVSTAD          ; Save address and do function
2810+ 2653
2811+ 2653 CD A9 26     DOFN:   call    CHEKFN          ; Make sure FN follows
2812+ 2656 D5                   push    DE              ; Save function pointer address
2813+ 2657 CD FF 22             call    EVLPAR          ; Evaluate expression in "()"
2814+ 265A CD 2B 22             call    TSTNUM          ; Make sure numeric result
2815+ 265D E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2816+ 265E 5E                   ld      E,(HL)          ; Get LSB of FN code string
2817+ 265F 23                   inc     HL
2818+ 2660 56                   ld      D,(HL)          ; Get MSB of FN code string
2819+ 2661 23                   inc     HL
2820+ 2662 7A                   ld      A,D             ; And function DEFined?
2821+ 2663 B3                   or      E
2822+ 2664 CA 5C 18             jp      Z,UFERR         ; No - ?UF Error
2823+ 2667 7E                   ld      A,(HL)          ; Get LSB of argument address
2824+ 2668 23                   inc     HL
2825+ 2669 66                   ld      H,(HL)          ; Get MSB of argument address
2826+ 266A 6F                   ld      L,A             ; HL = Arg variable address
2827+ 266B E5                   push    HL              ; Save it
2828+ 266C 2A F3 55             ld      HL,(FNRGNM)     ; Get old argument name
2829+ 266F E3                   ex      (SP),HL         ; Save old , Get new
2830+ 2670 22 F3 55             ld      (FNRGNM),HL     ; Set new argument name
2831+ 2673 2A F7 55             ld      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2832+ 2676 E5                   push    HL              ; Save it
2833+ 2677 2A F5 55             ld      HL,(FNARG)      ; Get MSB,EXP of old arg value
2834+ 267A E5                   push    HL              ; Save it
2835+ 267B 21 F5 55             ld      HL,FNARG        ; HL = Value of argument
2836+ 267E D5                   push    DE              ; Save FN code string address
2837+ 267F CD 8D 30             call    FPTHL           ; Move FPREG to argument
2838+ 2682 E1                   pop     HL              ; Get FN code string address
2839+ 2683 CD 28 22             call    GETNUM          ; Get value from function
2840+ 2686 2B                   dec     HL              ; dec 'cos GETCHR INCs
2841+ 2687 CD 97 1D             call    GETCHR          ; Get next character
2842+ 268A C2 50 18             jp      NZ,SNERR        ; Bad character in FN - Error
2843+ 268D E1                   pop     HL              ; Get MSB,EXP of old arg
2844+ 268E 22 F5 55             ld      (FNARG),HL      ; Restore it
2845+ 2691 E1                   pop     HL              ; Get LSB,NLSB of old arg
2846+ 2692 22 F7 55             ld      (FNARG+2),HL    ; Restore it
2847+ 2695 E1                   pop     HL              ; Get name of old arg
2848+ 2696 22 F3 55             ld      (FNRGNM),HL     ; Restore it
2849+ 2699 E1                   pop     HL              ; Restore code string address
2850+ 269A C9                   ret
2851+ 269B
2852+ 269B E5           IDTEST: push    HL              ; Save code string address
2853+ 269C 2A 52 54             ld      HL,(LINEAT)     ; Get current line number
2854+ 269F 23                   inc     HL              ; -1 means direct statement
2855+ 26A0 7C                   ld      A,H
2856+ 26A1 B5                   or      L
2857+ 26A2 E1                   pop     HL              ; Restore code string address
2858+ 26A3 C0                   ret     NZ              ; Return if in program
2859+ 26A4 1E 16                ld      E,ID            ; ?ID Error
2860+ 26A6 C3 6A 18             jp      ERROR
2861+ 26A9
2862+ 26A9 CD 4E 1B     CHEKFN: call    CHKSYN          ; Make sure FN follows
2863+ 26AC BC                   defb    ZFN             ; "FN" token
2864+ 26AD 3E 80                ld      A,$80
2865+ 26AF 32 7A 55             ld      (FORFLG),A      ; Flag FN name to find
2866+ 26B2 B6                   or      (HL)            ; FN name has bit 7 set
2867+ 26B3 47                   ld      B,A             ; in first byte of name
2868+ 26B4 CD 3C 24             call    GTFNAM          ; Get FN name
2869+ 26B7 C3 2B 22             jp      TSTNUM          ; Make sure numeric function
2870+ 26BA
2871+ 26BA CD 2B 22     STR:    call    TSTNUM          ; Make sure it's a number
2872+ 26BD CD DA 31             call    NUMASC          ; Turn number into text
2873+ 26C0 CD EE 26     STR1:   call    CRTST           ; Create string entry for it
2874+ 26C3 CD 73 28             call    GSTRCU          ; Current string to pool
2875+ 26C6 01 CE 28             ld      BC,TOPOOL       ; Save in string pool
2876+ 26C9 C5                   push    BC              ; Save address on stack
2877+ 26CA
2878+ 26CA 7E           SAVSTR: ld      A,(HL)          ; Get string length
2879+ 26CB 23                   inc     HL
2880+ 26CC 23                   inc     HL
2881+ 26CD E5                   push    HL              ; Save pointer to string
2882+ 26CE CD 49 27             call    TESTR           ; See if enough string space
2883+ 26D1 E1                   pop     HL              ; Restore pointer to string
2884+ 26D2 4E                   ld      C,(HL)          ; Get LSB of address
2885+ 26D3 23                   inc     HL
2886+ 26D4 46                   ld      B,(HL)          ; Get MSB of address
2887+ 26D5 CD E2 26             call    CRTMST          ; Create string entry
2888+ 26D8 E5                   push    HL              ; Save pointer to MSB of addr
2889+ 26D9 6F                   ld      L,A             ; Length of string
2890+ 26DA CD 66 28             call    TOSTRA          ; Move to string area
2891+ 26DD D1                   pop     DE              ; Restore pointer to MSB
2892+ 26DE C9                   ret
2893+ 26DF
2894+ 26DF CD 49 27     MKTMST: call    TESTR           ; See if enough string space
2895+ 26E2 21 6E 55     CRTMST: ld      HL,TMPSTR       ; Temporary string
2896+ 26E5 E5                   push    HL              ; Save it
2897+ 26E6 77                   ld      (HL),A          ; Save length of string
2898+ 26E7 23                   inc     HL
2899+ 26E8 23           SVSTAD: inc     HL
2900+ 26E9 73                   ld      (HL),E          ; Save LSB of address
2901+ 26EA 23                   inc     HL
2902+ 26EB 72                   ld      (HL),D          ; Save MSB of address
2903+ 26EC E1                   pop     HL              ; Restore pointer
2904+ 26ED C9                   ret
2905+ 26EE
2906+ 26EE 2B           CRTST:  dec     HL              ; dec - INCed after
2907+ 26EF 06 22        QTSTR:  ld      B,$22           ; '"'           ; Terminating quote
2908+ 26F1 50                   ld      D,B             ; Quote to D
2909+ 26F2 E5           DTSTR:  push    HL              ; Save start
2910+ 26F3 0E FF                ld      C,-1            ; Set counter to -1
2911+ 26F5 23           QTSTLP: inc     HL              ; Move on
2912+ 26F6 7E                   ld      A,(HL)          ; Get byte
2913+ 26F7 0C                   inc     C               ; Count bytes
2914+ 26F8 B7                   or      A               ; End of line?
2915+ 26F9 CA 04 27             jp      Z,CRTSTE        ; Yes - Create string entry
2916+ 26FC BA                   cp      D               ; Terminator D found?
2917+ 26FD CA 04 27             jp      Z,CRTSTE        ; Yes - Create string entry
2918+ 2700 B8                   cp      B               ; Terminator B found?
2919+ 2701 C2 F5 26             jp      NZ,QTSTLP       ; No - Keep looking
2920+ 2704 FE 22        CRTSTE: cp      $22             ; '"'             ; End with '"'?
2921+ 2706 CC 97 1D             call    Z,GETCHR        ; Yes - Get next character
2922+ 2709 E3                   ex      (SP),HL         ; Starting quote
2923+ 270A 23                   inc     HL              ; First byte of string
2924+ 270B EB                   ex      DE,HL           ; To DE
2925+ 270C 79                   ld      A,C             ; Get length
2926+ 270D CD E2 26             call    CRTMST          ; Create string entry
2927+ 2710 11 6E 55     TSTOPL: ld      DE,TMPSTR       ; Temporary string
2928+ 2713 2A 60 55             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2929+ 2716 22 F9 55             ld      (FPREG),HL      ; Save address of string ptr
2930+ 2719 3E 01                ld      A,$01
2931+ 271B 32 37 55             ld      (TYPE),A        ; Set type to string
2932+ 271E CD 90 30             call    DETHL4          ; Move string to pool
2933+ 2721 CD 48 1B             call    CPDEHL          ; Out of string pool?
2934+ 2724 22 60 55             ld      (TMSTPT),HL     ; Save new pointer
2935+ 2727 E1                   pop     HL              ; Restore code string address
2936+ 2728 7E                   ld      A,(HL)          ; Get next code byte
2937+ 2729 C0                   ret     NZ              ; Return if pool OK
2938+ 272A 1E 1E                ld      E,ST            ; ?ST Error
2939+ 272C C3 6A 18             jp      ERROR           ; String pool overflow
2940+ 272F
2941+ 272F 23           PRNUMS: inc     HL              ; Skip leading space
2942+ 2730 CD EE 26     PRS:    call    CRTST           ; Create string entry for it
2943+ 2733 CD 73 28     PRS1:   call    GSTRCU          ; Current string to pool
2944+ 2736 CD 84 30             call    LOADFP          ; Move string block to BCDE
2945+ 2739 1C                   inc     E               ; Length + 1
2946+ 273A 1D           PRSLP:  dec     E               ; Count characters
2947+ 273B C8                   ret     Z               ; End of string
2948+ 273C 0A                   ld      A,(BC)          ; Get byte to output
2949+ 273D CD 59 1B             call    OUTC            ; Output character in A
2950+ 2740 FE 0D                cp      CR              ; Return?
2951+ 2742 CC 6E 20             call    Z,CNTEND        ; Yes - Position cursor to 0
2952+ 2745 03                   inc     BC              ; Next byte in string
2953+ 2746 C3 3A 27             jp      PRSLP           ; More characters to output
2954+ 2749
2955+ 2749 B7           TESTR:  or      A               ; Test if enough room
2956+ 274A 0E                   defb    $0E             ; No garbage collection done
2957+ 274B F1           GRBDON: pop     AF              ; Garbage collection done
2958+ 274C F5                   push    AF              ; Save status
2959+ 274D 2A 50 54             ld      HL,(STRSPC)     ; Bottom of string space in use
2960+ 2750 EB                   ex      DE,HL           ; To DE
2961+ 2751 2A 72 55             ld      HL,(STRBOT)     ; Bottom of string area
2962+ 2754 2F                   cpl                     ; Negate length (Top down)
2963+ 2755 4F                   ld      C,A             ; -Length to BC
2964+ 2756 06 FF                ld      B,-1            ; BC = -ve length of string
2965+ 2758 09                   add     HL,BC           ; Add to bottom of space in use
2966+ 2759 23                   inc     HL              ; Plus one for 2's complement
2967+ 275A CD 48 1B             call    CPDEHL          ; Below string RAM area?
2968+ 275D DA 67 27             jp      C,TESTOS        ; Tidy up if not done else err
2969+ 2760 22 72 55             ld      (STRBOT),HL     ; Save new bottom of area
2970+ 2763 23                   inc     HL              ; Point to first byte of string
2971+ 2764 EB                   ex      DE,HL           ; Address to DE
2972+ 2765 F1           POPAF:  pop     AF              ; Throw away status push
2973+ 2766 C9                   ret
2974+ 2767
2975+ 2767 F1           TESTOS: pop     AF              ; Garbage collect been done?
2976+ 2768 1E 1A                ld      E,OS            ; ?OS Error
2977+ 276A CA 6A 18             jp      Z,ERROR         ; Yes - Not enough string space
2978+ 276D BF                   cp      A               ; Flag garbage collect done
2979+ 276E F5                   push    AF              ; Save status
2980+ 276F 01 4B 27             ld      BC,GRBDON       ; Garbage collection done
2981+ 2772 C5                   push    BC              ; Save for RETurn
2982+ 2773 2A 39 55     GARBGE: ld      HL,(LSTRAM)     ; Get end of RAM pointer
2983+ 2776 22 72 55     GARBLP: ld      (STRBOT),HL     ; Reset string pointer
2984+ 2779 21 00 00             ld      HL,$0000
2985+ 277C E5                   push    HL              ; Flag no string found
2986+ 277D 2A 50 54             ld      HL,(STRSPC)     ; Get bottom of string space
2987+ 2780 E5                   push    HL              ; Save bottom of string space
2988+ 2781 21 62 55             ld      HL,TMSTPL       ; Temporary string pool
2989+ 2784 EB           GRBLP:  ex      DE,HL
2990+ 2785 2A 60 55             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2991+ 2788 EB                   ex      DE,HL
2992+ 2789 CD 48 1B             call    CPDEHL          ; Temporary string pool done?
2993+ 278C 01 84 27             ld      BC,GRBLP        ; Loop until string pool done
2994+ 278F C2 D8 27             jp      NZ,STPOOL       ; No - See if in string area
2995+ 2792 2A EB 55             ld      HL,(PROGND)     ; Start of simple variables
2996+ 2795 EB           SMPVAR: ex      DE,HL
2997+ 2796 2A ED 55             ld      HL,(VAREND)     ; End of simple variables
2998+ 2799 EB                   ex      DE,HL
2999+ 279A CD 48 1B             call    CPDEHL          ; All simple strings done?
3000+ 279D CA AB 27             jp      Z,ARRLP         ; Yes - Do string arrays
3001+ 27A0 7E                   ld      A,(HL)          ; Get type of variable
3002+ 27A1 23                   inc     HL
3003+ 27A2 23                   inc     HL
3004+ 27A3 B7                   or      A               ; "S" flag set if string
3005+ 27A4 CD DB 27             call    STRADD          ; See if string in string area
3006+ 27A7 C3 95 27             jp      SMPVAR          ; Loop until simple ones done
3007+ 27AA
3008+ 27AA C1           GNXARY: pop     BC              ; Scrap address of this array
3009+ 27AB EB           ARRLP:  ex      DE,HL
3010+ 27AC 2A EF 55             ld      HL,(ARREND)     ; End of string arrays
3011+ 27AF EB                   ex      DE,HL
3012+ 27B0 CD 48 1B             call    CPDEHL          ; All string arrays done?
3013+ 27B3 CA 01 28             jp      Z,SCNEND        ; Yes - Move string if found
3014+ 27B6 CD 84 30             call    LOADFP          ; Get array name to BCDE
3015+ 27B9 7B                   ld      A,E             ; Get type of array
3016+ 27BA E5                   push    HL              ; Save address of num of dim'ns
3017+ 27BB 09                   add     HL,BC           ; Start of next array
3018+ 27BC B7                   or      A               ; Test type of array
3019+ 27BD F2 AA 27             jp      P,GNXARY        ; Numeric array - Ignore it
3020+ 27C0 22 74 55             ld      (CUROPR),HL     ; Save address of next array
3021+ 27C3 E1                   pop     HL              ; Get address of num of dim'ns
3022+ 27C4 4E                   ld      C,(HL)          ; BC = Number of dimensions
3023+ 27C5 06 00                ld      B,$00
3024+ 27C7 09                   add     HL,BC           ; Two bytes per dimension size
3025+ 27C8 09                   add     HL,BC
3026+ 27C9 23                   inc     HL              ; Plus one for number of dim'ns
3027+ 27CA EB           GRBARY: ex      DE,HL
3028+ 27CB 2A 74 55             ld      HL,(CUROPR)     ; Get address of next array
3029+ 27CE EB                   ex      DE,HL
3030+ 27CF CD 48 1B             call    CPDEHL          ; Is this array finished?
3031+ 27D2 CA AB 27             jp      Z,ARRLP         ; Yes - Get next one
3032+ 27D5 01 CA 27             ld      BC,GRBARY       ; Loop until array all done
3033+ 27D8 C5           STPOOL: push    BC              ; Save return address
3034+ 27D9 F6 80                or      $80             ; Flag string type
3035+ 27DB 7E           STRADD: ld      A,(HL)          ; Get string length
3036+ 27DC 23                   inc     HL
3037+ 27DD 23                   inc     HL
3038+ 27DE 5E                   ld      E,(HL)          ; Get LSB of string address
3039+ 27DF 23                   inc     HL
3040+ 27E0 56                   ld      D,(HL)          ; Get MSB of string address
3041+ 27E1 23                   inc     HL
3042+ 27E2 F0                   ret     P               ; Not a string - Return
3043+ 27E3 B7                   or      A               ; Set flags on string length
3044+ 27E4 C8                   ret     Z               ; Null string - Return
3045+ 27E5 44                   ld      B,H             ; Save variable pointer
3046+ 27E6 4D                   ld      C,L
3047+ 27E7 2A 72 55             ld      HL,(STRBOT)     ; Bottom of new area
3048+ 27EA CD 48 1B             call    CPDEHL          ; String been done?
3049+ 27ED 60                   ld      H,B             ; Restore variable pointer
3050+ 27EE 69                   ld      L,C
3051+ 27EF D8                   ret     C               ; String done - Ignore
3052+ 27F0 E1                   pop     HL              ; Return address
3053+ 27F1 E3                   ex      (SP),HL         ; Lowest available string area
3054+ 27F2 CD 48 1B             call    CPDEHL          ; String within string area?
3055+ 27F5 E3                   ex      (SP),HL         ; Lowest available string area
3056+ 27F6 E5                   push    HL              ; Re-save return address
3057+ 27F7 60                   ld      H,B             ; Restore variable pointer
3058+ 27F8 69                   ld      L,C
3059+ 27F9 D0                   ret     NC              ; Outside string area - Ignore
3060+ 27FA C1                   pop     BC              ; Get return , Throw 2 away
3061+ 27FB F1                   pop     AF              ;
3062+ 27FC F1                   pop     AF              ;
3063+ 27FD E5                   push    HL              ; Save variable pointer
3064+ 27FE D5                   push    DE              ; Save address of current
3065+ 27FF C5                   push    BC              ; Put back return address
3066+ 2800 C9                   ret                     ; Go to it
3067+ 2801
3068+ 2801 D1           SCNEND: pop     DE              ; Addresses of strings
3069+ 2802 E1                   pop     HL              ;
3070+ 2803 7D                   ld      A,L             ; HL = 0 if no more to do
3071+ 2804 B4                   or      H
3072+ 2805 C8                   ret     Z               ; No more to do - Return
3073+ 2806 2B                   dec     HL
3074+ 2807 46                   ld      B,(HL)          ; MSB of address of string
3075+ 2808 2B                   dec     HL
3076+ 2809 4E                   ld      C,(HL)          ; LSB of address of string
3077+ 280A E5                   push    HL              ; Save variable address
3078+ 280B 2B                   dec     HL
3079+ 280C 2B                   dec     HL
3080+ 280D 6E                   ld      L,(HL)          ; HL = Length of string
3081+ 280E 26 00                ld      H,$00
3082+ 2810 09                   add     HL,BC           ; Address of end of string+1
3083+ 2811 50                   ld      D,B             ; String address to DE
3084+ 2812 59                   ld      E,C
3085+ 2813 2B                   dec     HL              ; Last byte in string
3086+ 2814 44                   ld      B,H             ; Address to BC
3087+ 2815 4D                   ld      C,L
3088+ 2816 2A 72 55             ld      HL,(STRBOT)     ; Current bottom of string area
3089+ 2819 CD FF 17             call    MOVSTR          ; Move string to new address
3090+ 281C E1                   pop     HL              ; Restore variable address
3091+ 281D 71                   ld      (HL),C          ; Save new LSB of address
3092+ 281E 23                   inc     HL
3093+ 281F 70                   ld      (HL),B          ; Save new MSB of address
3094+ 2820 69                   ld      L,C             ; Next string area+1 to HL
3095+ 2821 60                   ld      H,B
3096+ 2822 2B                   dec     HL              ; Next string area address
3097+ 2823 C3 76 27             jp      GARBLP          ; Look for more strings
3098+ 2826
3099+ 2826 C5           CONCAT: push    BC              ; Save prec' opr & code string
3100+ 2827 E5                   push    HL              ;
3101+ 2828 2A F9 55             ld      HL,(FPREG)      ; Get first string
3102+ 282B E3                   ex      (SP),HL         ; Save first string
3103+ 282C CD B1 22             call    OPRND           ; Get second string
3104+ 282F E3                   ex      (SP),HL         ; Restore first string
3105+ 2830 CD 2C 22             call    TSTSTR          ; Make sure it's a string
3106+ 2833 7E                   ld      A,(HL)          ; Get length of second string
3107+ 2834 E5                   push    HL              ; Save first string
3108+ 2835 2A F9 55             ld      HL,(FPREG)      ; Get second string
3109+ 2838 E5                   push    HL              ; Save second string
3110+ 2839 86                   add     A,(HL)          ; Add length of second string
3111+ 283A 1E 1C                ld      E,LS            ; ?LS Error
3112+ 283C DA 6A 18             jp      C,ERROR         ; String too long - Error
3113+ 283F CD DF 26             call    MKTMST          ; Make temporary string
3114+ 2842 D1                   pop     DE              ; Get second string to DE
3115+ 2843 CD 77 28             call    GSTRDE          ; Move to string pool if needed
3116+ 2846 E3                   ex      (SP),HL         ; Get first string
3117+ 2847 CD 76 28             call    GSTRHL          ; Move to string pool if needed
3118+ 284A E5                   push    HL              ; Save first string
3119+ 284B 2A 70 55             ld      HL,(TMPSTR+2)   ; Temporary string address
3120+ 284E EB                   ex      DE,HL           ; To DE
3121+ 284F CD 5D 28             call    SSTSA           ; First string to string area
3122+ 2852 CD 5D 28             call    SSTSA           ; Second string to string area
3123+ 2855 21 46 22             ld      HL,EVAL2        ; Return to evaluation loop
3124+ 2858 E3                   ex      (SP),HL         ; Save return,get code string
3125+ 2859 E5                   push    HL              ; Save code string address
3126+ 285A C3 10 27             jp      TSTOPL          ; To temporary string to pool
3127+ 285D
3128+ 285D E1           SSTSA:  pop     HL              ; Return address
3129+ 285E E3                   ex      (SP),HL         ; Get string block,save return
3130+ 285F 7E                   ld      A,(HL)          ; Get length of string
3131+ 2860 23                   inc     HL
3132+ 2861 23                   inc     HL
3133+ 2862 4E                   ld      C,(HL)          ; Get LSB of string address
3134+ 2863 23                   inc     HL
3135+ 2864 46                   ld      B,(HL)          ; Get MSB of string address
3136+ 2865 6F                   ld      L,A             ; Length to L
3137+ 2866 2C           TOSTRA: inc     L               ; inc - DECed after
3138+ 2867 2D           TSALP:  dec     L               ; Count bytes moved
3139+ 2868 C8                   ret     Z               ; End of string - Return
3140+ 2869 0A                   ld      A,(BC)          ; Get source
3141+ 286A 12                   ld      (DE),A          ; Save destination
3142+ 286B 03                   inc     BC              ; Next source
3143+ 286C 13                   inc     DE              ; Next destination
3144+ 286D C3 67 28             jp      TSALP           ; Loop until string moved
3145+ 2870
3146+ 2870 CD 2C 22     GETSTR: call    TSTSTR          ; Make sure it's a string
3147+ 2873 2A F9 55     GSTRCU: ld      HL,(FPREG)      ; Get current string
3148+ 2876 EB           GSTRHL: ex      DE,HL           ; Save DE
3149+ 2877 CD 91 28     GSTRDE: call    BAKTMP          ; Was it last tmp-str?
3150+ 287A EB                   ex      DE,HL           ; Restore DE
3151+ 287B C0                   ret     NZ              ; No - Return
3152+ 287C D5                   push    DE              ; Save string
3153+ 287D 50                   ld      D,B             ; String block address to DE
3154+ 287E 59                   ld      E,C
3155+ 287F 1B                   dec     DE              ; Point to length
3156+ 2880 4E                   ld      C,(HL)          ; Get string length
3157+ 2881 2A 72 55             ld      HL,(STRBOT)     ; Current bottom of string area
3158+ 2884 CD 48 1B             call    CPDEHL          ; Last one in string area?
3159+ 2887 C2 8F 28             jp      NZ,POPHL        ; No - Return
3160+ 288A 47                   ld      B,A             ; Clear B (A=0)
3161+ 288B 09                   add     HL,BC           ; Remove string from str' area
3162+ 288C 22 72 55             ld      (STRBOT),HL     ; Save new bottom of str' area
3163+ 288F E1           POPHL:  pop     HL              ; Restore string
3164+ 2890 C9                   ret
3165+ 2891
3166+ 2891 2A 60 55     BAKTMP: ld      HL,(TMSTPT)     ; Get temporary string pool top
3167+ 2894 2B                   dec     HL              ; Back
3168+ 2895 46                   ld      B,(HL)          ; Get MSB of address
3169+ 2896 2B                   dec     HL              ; Back
3170+ 2897 4E                   ld      C,(HL)          ; Get LSB of address
3171+ 2898 2B                   dec     HL              ; Back
3172+ 2899 2B                   dec     HL              ; Back
3173+ 289A CD 48 1B             call    CPDEHL          ; String last in string pool?
3174+ 289D C0                   ret     NZ              ; Yes - Leave it
3175+ 289E 22 60 55             ld      (TMSTPT),HL     ; Save new string pool top
3176+ 28A1 C9                   ret
3177+ 28A2
3178+ 28A2 01 21 26     LEN:    ld      BC,PASSA        ; To return integer A
3179+ 28A5 C5                   push    BC              ; Save address
3180+ 28A6 CD 70 28     GETLEN: call    GETSTR          ; Get string and its length
3181+ 28A9 AF                   xor     A
3182+ 28AA 57                   ld      D,A             ; Clear D
3183+ 28AB 32 37 55             ld      (TYPE),A        ; Set type to numeric
3184+ 28AE 7E                   ld      A,(HL)          ; Get length of string
3185+ 28AF B7                   or      A               ; Set status flags
3186+ 28B0 C9                   ret
3187+ 28B1
3188+ 28B1 01 21 26     ASC:    ld      BC,PASSA        ; To return integer A
3189+ 28B4 C5                   push    BC              ; Save address
3190+ 28B5 CD A6 28     GTFLNM: call    GETLEN          ; Get length of string
3191+ 28B8 CA 62 1E             jp      Z,FCERR         ; Null string - Error
3192+ 28BB 23                   inc     HL
3193+ 28BC 23                   inc     HL
3194+ 28BD 5E                   ld      E,(HL)          ; Get LSB of address
3195+ 28BE 23                   inc     HL
3196+ 28BF 56                   ld      D,(HL)          ; Get MSB of address
3197+ 28C0 1A                   ld      A,(DE)          ; Get first byte of string
3198+ 28C1 C9                   ret
3199+ 28C2
3200+ 28C2 3E 01        CHR:    ld      A,$01           ; One character string
3201+ 28C4 CD DF 26             call    MKTMST          ; Make a temporary string
3202+ 28C7 CD B1 2A             call    MAKINT          ; Make it integer A
3203+ 28CA 2A 70 55             ld      HL,(TMPSTR+2)   ; Get address of string
3204+ 28CD 73                   ld      (HL),E          ; Save character
3205+ 28CE C1           TOPOOL: pop     BC              ; Clean up stack
3206+ 28CF C3 10 27             jp      TSTOPL          ; Temporary string to pool
3207+ 28D2
3208+ 28D2 CD 61 2A     LEFT:   call    LFRGNM          ; Get number and ending ")"
3209+ 28D5 AF                   xor     A               ; Start at first byte in string
3210+ 28D6 E3           RIGHT1: ex      (SP),HL         ; Save code string,Get string
3211+ 28D7 4F                   ld      C,A             ; Starting position in string
3212+ 28D8 E5           MID1:   push    HL              ; Save string block address
3213+ 28D9 7E                   ld      A,(HL)          ; Get length of string
3214+ 28DA B8                   cp      B               ; Compare with number given
3215+ 28DB DA E0 28             jp      C,ALLFOL        ; All following bytes required
3216+ 28DE 78                   ld      A,B             ; Get new length
3217+ 28DF 11                   defb    $11             ; Skip "ld C,0"
3218+ 28E0 0E 00        ALLFOL: ld      C,$00           ; First byte of string
3219+ 28E2 C5                   push    BC              ; Save position in string
3220+ 28E3 CD 49 27             call    TESTR           ; See if enough string space
3221+ 28E6 C1                   pop     BC              ; Get position in string
3222+ 28E7 E1                   pop     HL              ; Restore string block address
3223+ 28E8 E5                   push    HL              ; And re-save it
3224+ 28E9 23                   inc     HL
3225+ 28EA 23                   inc     HL
3226+ 28EB 46                   ld      B,(HL)          ; Get LSB of address
3227+ 28EC 23                   inc     HL
3228+ 28ED 66                   ld      H,(HL)          ; Get MSB of address
3229+ 28EE 68                   ld      L,B             ; HL = address of string
3230+ 28EF 06 00                ld      B,$00           ; BC = starting address
3231+ 28F1 09                   add     HL,BC           ; Point to that byte
3232+ 28F2 44                   ld      B,H             ; BC = source string
3233+ 28F3 4D                   ld      C,L
3234+ 28F4 CD E2 26             call    CRTMST          ; Create a string entry
3235+ 28F7 6F                   ld      L,A             ; Length of new string
3236+ 28F8 CD 66 28             call    TOSTRA          ; Move string to string area
3237+ 28FB D1                   pop     DE              ; Clear stack
3238+ 28FC CD 77 28             call    GSTRDE          ; Move to string pool if needed
3239+ 28FF C3 10 27             jp      TSTOPL          ; Temporary string to pool
3240+ 2902
3241+ 2902
3242+ 2902              ; INSTR statement - look for a string inside another string
3243+ 2902              ; usage: INSTR(A$,B$) -> search for B$ into A$
3244+ 2902              ; return 0 if B$ is not found into A$, or LEN(A$)<LEN(B$)
3245+ 2902              ; return 1~255 to indicate the starting position of B$ into A$
3246+ 2902              ; ex.: INSTR("HELLO","LO") returns 4 - INSTR("HOME","PC") returns 0
3247+ 2902              LNS1    equ     TMPBFR1
3248+ 2902              ADRS1   equ     TMPBFR2
3249+ 2902              LNS2    equ     TMPBFR3
3250+ 2902              ADRS2   equ     TMPBFR4
3251+ 2902              PT      equ     VIDEOBUFF
3252+ 2902              PT1     equ     VIDEOBUFF+2
3253+ 2902              PT2     equ     VIDEOBUFF+4
3254+ 2902              TP      equ     VIDEOBUFF+6
3255+ 2902              TF      equ     VIDEOBUFF+8
3256+ 2902 CD 4E 1B     INSTR:  call    CHKSYN          ; make sure "(" follows
3257+ 2905 28                   defb    '('
3258+ 2906 2B                   dec     HL              ; dec 'cause GETCHR increments
3259+ 2907 CD 97 1D             call    GETCHR          ; check if something follows
3260+ 290A CA 50 18             jp      Z,SNERR         ; if nothing else, raise a syntax error
3261+ 290D CD 3A 22             call    EVAL            ; Evaluate expression
3262+ 2910 CD 2C 22             call    TSTSTR          ; Make sure it's a string
3263+ 2913 22 AD 55             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3264+ 2916 CD 73 28             call    GSTRCU          ; check that a string follows
3265+ 2919 CD 84 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3266+ 291C ED 53 A5 55          ld      (LNS1),DE       ; store values into
3267+ 2920 ED 43 A7 55          ld      (ADRS1),BC      ; temp buffers
3268+ 2924 2A AD 55             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3269+ 2927 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
3270+ 292A 2C                   defb    ','
3271+ 292B 2B                   dec     HL              ; dec 'cause GETCHR increments
3272+ 292C CD 97 1D             call    GETCHR          ; check if something follows
3273+ 292F CA 50 18             jp      Z,SNERR         ; if nothing else, raise a syntax error
3274+ 2932 CD 3A 22             call    EVAL            ; Evaluate expression
3275+ 2935 CD 2C 22             call    TSTSTR          ; Make sure it's a string
3276+ 2938 22 AD 55             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3277+ 293B CD 73 28             call    GSTRCU          ; check that a string follows
3278+ 293E CD 84 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3279+ 2941 ED 53 A9 55          ld      (LNS2),DE       ; store values into
3280+ 2945 ED 43 AB 55          ld      (ADRS2),BC      ; temp buffers
3281+ 2949 2A AD 55             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3282+ 294C CD 4E 1B             call    CHKSYN          ; make sure ")" follows
3283+ 294F 29                   defb    ')'
3284+ 2950 E5                   push    HL              ; store current code string pointer (the point after the ")" ) ...
3285+ 2951 FD E1                pop     IY              ; ...into IY
3286+ 2953 AF                   xor     A               ; reset 10 RAM cells
3287+ 2954 06 0A                ld      B,$0A           ; (INSTR registers)
3288+ 2956 21 AD 55             ld      HL,PT           ; first cell
3289+ 2959 77           EMPTINS:ld      (HL),A          ; reset cell
3290+ 295A 23                   inc     HL              ; next cell
3291+ 295B 10 FC                djnz    EMPTINS         ; repeat
3292+ 295D ED 5B A9 55          ld      DE,(LNS2)       ; load len(S2) into DE
3293+ 2961 2A A5 55             ld      HL,(LNS1)       ; load len(S1) into HL
3294+ 2964 CD 61 41             call    CMP16           ; check that len(S1)>=len(S2)
3295+ 2967 DA DC 29             jp      C,RZINSTR       ; if len(S2)>len(S1) then return 0
3296+ 296A AF           RPTINST:xor     A               ; reset...
3297+ 296B 32 B3 55             ld      (TP),A          ; ...TP...
3298+ 296E 32 B5 55             ld      (TF),A          ; ...and TF
3299+ 2971 ED 4B AD 55          ld      BC,(PT)         ; pointer to S1
3300+ 2975 2A A7 55             ld      HL,(ADRS1)      ; first cell of S1
3301+ 2978 09                   add     HL,BC           ; get current position into RAM
3302+ 2979 7E                   ld      A,(HL)          ; load S1(PT)
3303+ 297A 2A AB 55             ld      HL,(ADRS2)      ; pointer to first char of S2
3304+ 297D BE                   cp      (HL)            ; is S1(PT)=S2(0)?
3305+ 297E 20 3A                jr      NZ,CNT1INS      ; no, continue
3306+ 2980 3A AD 55             ld      A,(PT)          ; load current PT
3307+ 2983 32 B3 55             ld      (TP),A          ; TP=PT
3308+ 2986 32 AF 55             ld      (PT1),A         ; P1=PT
3309+ 2989 AF                   xor     A               ; set...
3310+ 298A 32 B1 55             ld      (PT2),A         ; ...PT2=0
3311+ 298D 3C                   inc     A               ;
3312+ 298E 32 B5 55             ld      (TF),A          ; set TF=1
3313+ 2991 ED 4B AF 55  RP2INST:ld      BC,(PT1)        ; load pointer PT1
3314+ 2995 2A A7 55             ld      HL,(ADRS1)      ; load address of S1
3315+ 2998 09                   add     HL,BC           ; find char of S1 pointed by PT1
3316+ 2999 7E                   ld      A,(HL)          ; load S1(PT1)
3317+ 299A ED 4B B1 55          ld      BC,(PT2)        ; load pointer PT2
3318+ 299E 2A AB 55             ld      HL,(ADRS2)      ; load char of S2 pointed by PT2
3319+ 29A1 09                   add     HL,BC           ; find S2(PT2)
3320+ 29A2 BE                   cp      (HL)            ; is S1(PT1)=S2(PT2)?
3321+ 29A3 20 4C                jr      NZ,CNTZIN       ; no, exit inner loop
3322+ 29A5 21 AF 55             ld      HL,PT1
3323+ 29A8 34                   inc     (HL)            ; increment PT1
3324+ 29A9 3A B1 55             ld      A,(PT2)
3325+ 29AC 3C                   inc     A               ; increment PT2
3326+ 29AD 32 B1 55             ld      (PT2),A
3327+ 29B0 CA BA 29             jp      Z,CNT1INS       ; if PT2>255 then exit
3328+ 29B3 21 A9 55             ld      HL,LNS2         ; len(S2)
3329+ 29B6 BE                   cp      (HL)            ; PT2=len(S2)?
3330+ 29B7 DA 91 29             jp      C,RP2INST       ; no (PT2<len(S2) - repeat
3331+ 29BA 3A B5 55     CNT1INS:ld      A,(TF)          ; check TF
3332+ 29BD A7                   and     A               ; TF=0? (clears also Carry for next SBC)
3333+ 29BE 20 1C                jr      NZ,RZINSTR      ; no, exit
3334+ 29C0 2A A5 55             ld      HL,(LNS1)       ; load len(S1)
3335+ 29C3 ED 4B A9 55          ld      BC,(LNS2)       ; load len(S2)
3336+ 29C7 ED 42                sbc     HL,BC           ; HL=len(S1)-len(S2)
3337+ 29C9 ED 5B AD 55          ld      DE,(PT)         ; load pointer
3338+ 29CD 1C                   inc     E               ; PT=PT+1
3339+ 29CE ED 53 AD 55          ld      (PT),DE         ; store new value
3340+ 29D2 EB                   ex      DE,HL           ; invert registers
3341+ 29D3 CD 61 41             call    CMP16           ; check if PT>len(S1)-len(S2)
3342+ 29D6 DA 6A 29             jp      C,RPTINST       ; repeat if <
3343+ 29D9 CA 6A 29             jp      Z,RPTINST       ; repeat if =
3344+ 29DC 3A B5 55     RZINSTR:ld      A,(TF)          ; current value of TF
3345+ 29DF A7                   and     A               ; is it 0?
3346+ 29E0 CA E7 29             jp      Z,LVINSTR       ; yes, return 0
3347+ 29E3 3A B3 55             ld      A,(TP)          ; return TP...
3348+ 29E6 3C                   inc     A               ; ...incremented by 1
3349+ 29E7 E1           LVINSTR:pop     HL              ; drop original return point
3350+ 29E8 FD E5                push    IY              ; load current string address from IY into stack
3351+ 29EA 11 13 23             ld      DE,RETNUM       ; Address of Return number from function...
3352+ 29ED D5                   push    DE              ; ...saved on stack
3353+ 29EE C3 21 26             jp      PASSA           ; return TP
3354+ 29F1 AF           CNTZIN: xor     A               ; set...
3355+ 29F2 32 B5 55             ld      (TF),A          ; TF=0
3356+ 29F5 C3 BA 29             jp      CNT1INS         ; continue
3357+ 29F8
3358+ 29F8
3359+ 29F8              ; returns the right portion of a string
3360+ 29F8 CD 61 2A     RIGHT:  call    LFRGNM          ; Get number and ending ")"
3361+ 29FB D1                   pop     DE              ; Get string length
3362+ 29FC D5                   push    DE              ; And re-save
3363+ 29FD 1A                   ld      A,(DE)          ; Get length
3364+ 29FE 90                   sub     B               ; Move back N bytes
3365+ 29FF C3 D6 28             jp      RIGHT1          ; Go and get sub-string
3366+ 2A02
3367+ 2A02              ; returns a piece of a string
3368+ 2A02 EB           MID:    ex      DE,HL           ; Get code string address
3369+ 2A03 7E                   ld      A,(HL)          ; Get next byte ',' or ")"
3370+ 2A04 CD 66 2A             call    MIDNUM          ; Get number supplied
3371+ 2A07 04                   inc     B               ; Is it character zero?
3372+ 2A08 05                   dec     B
3373+ 2A09 CA 62 1E             jp      Z,FCERR         ; Yes - Error
3374+ 2A0C C5                   push    BC              ; Save starting position
3375+ 2A0D 1E FF                ld      E,$FF           ; All of string
3376+ 2A0F FE 29                cp      ')'             ; Any length given?
3377+ 2A11 CA 1B 2A             jp      Z,RSTSTR        ; No - Rest of string
3378+ 2A14 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
3379+ 2A17 2C                   defb    ','
3380+ 2A18 CD AE 2A             call    GETINT          ; Get integer 0-255
3381+ 2A1B CD 4E 1B     RSTSTR: call    CHKSYN          ; Make sure ")" follows
3382+ 2A1E 29                   defb    ')'
3383+ 2A1F F1                   pop     AF              ; Restore starting position
3384+ 2A20 E3                   ex      (SP),HL         ; Get string,save code string
3385+ 2A21 01 D8 28             ld      BC,MID1         ; Continuation of MID$ routine
3386+ 2A24 C5                   push    BC              ; Save for return
3387+ 2A25 3D                   dec     A               ; Starting position-1
3388+ 2A26 BE                   cp      (HL)            ; Compare with length
3389+ 2A27 06 00                ld      B,$00           ; Zero bytes length
3390+ 2A29 D0                   ret     NC              ; Null string if start past end
3391+ 2A2A 4F                   ld      C,A             ; Save starting position-1
3392+ 2A2B 7E                   ld      A,(HL)          ; Get length of string
3393+ 2A2C 91                   sub     C               ; Subtract start
3394+ 2A2D BB                   cp      E               ; Enough string for it?
3395+ 2A2E 47                   ld      B,A             ; Save maximum length available
3396+ 2A2F D8                   ret     C               ; Truncate string if needed
3397+ 2A30 43                   ld      B,E             ; Set specified length
3398+ 2A31 C9                   ret                     ; Go and create string
3399+ 2A32
3400+ 2A32
3401+ 2A32              ; return the value of a numeric string
3402+ 2A32 CD A6 28     VAL:    call    GETLEN          ; Get length of string
3403+ 2A35 CA 04 2E             jp      Z,RESZER        ; Result zero
3404+ 2A38 5F                   ld      E,A             ; Save length
3405+ 2A39 23                   inc     HL
3406+ 2A3A 23                   inc     HL
3407+ 2A3B 7E                   ld      A,(HL)          ; Get LSB of address
3408+ 2A3C 23                   inc     HL
3409+ 2A3D 66                   ld      H,(HL)          ; Get MSB of address
3410+ 2A3E 6F                   ld      L,A             ; HL = String address
3411+ 2A3F E5                   push    HL              ; Save string address
3412+ 2A40 19                   add     HL,DE
3413+ 2A41 46                   ld      B,(HL)          ; Get end of string+1 byte
3414+ 2A42 72                   ld      (HL),D          ; Zero it to terminate
3415+ 2A43 E3                   ex      (SP),HL         ; Save string end,get start
3416+ 2A44 C5                   push    BC              ; Save end+1 byte
3417+ 2A45 7E                   ld      A,(HL)          ; Get starting byte
3418+ 2A46 FE 24                cp      '$'             ; Hex number indicated? [function added]
3419+ 2A48 C2 50 2A             jp      NZ,VAL1
3420+ 2A4B CD 90 40             call    HEXTFP          ; Convert Hex to FPREG
3421+ 2A4E 18 0D                jr      VAL3
3422+ 2A50 FE 25        VAL1:   cp      '%'             ; Binary number indicated? [function added]
3423+ 2A52 C2 5A 2A             jp      NZ,VAL2
3424+ 2A55 CD 00 41             call    BINTFP          ; Convert Bin to FPREG
3425+ 2A58 18 03                jr      VAL3
3426+ 2A5A CD 3C 31     VAL2:   call    ASCTFP          ; Convert ASCII string to FP
3427+ 2A5D C1           VAL3:   pop     BC              ; Restore end+1 byte
3428+ 2A5E E1                   pop     HL              ; Restore end+1 address
3429+ 2A5F 70                   ld      (HL),B          ; Put back original byte
3430+ 2A60 C9                   ret
3431+ 2A61
3432+ 2A61 EB           LFRGNM: ex      DE,HL           ; Code string address to HL
3433+ 2A62 CD 4E 1B             call    CHKSYN          ; Make sure ")" follows
3434+ 2A65 29                   defb    ')'
3435+ 2A66 C1           MIDNUM: pop     BC              ; Get return address
3436+ 2A67 D1                   pop     DE              ; Get number supplied
3437+ 2A68 C5                   push    BC              ; Re-save return address
3438+ 2A69 43                   ld      B,E             ; Number to B
3439+ 2A6A C9                   ret
3440+ 2A6B
3441+ 2A6B CD B1 2A     INP:    call    MAKINT          ; Make it integer A
3442+ 2A6E 32 43 54             ld      (INPORT),A      ; Set input port
3443+ 2A71 CD 42 54             call    INPSUB          ; Get input from port
3444+ 2A74 C3 21 26             jp      PASSA           ; Return integer A
3445+ 2A77
3446+ 2A77 CD 9B 2A     POUT:   call    SETIO           ; Set up port number
3447+ 2A7A C3 0A 54             jp      OUTSUB          ; Output data and return
3448+ 2A7D
3449+ 2A7D CD 9B 2A     WAIT:   call    SETIO           ; Set up port number
3450+ 2A80 F5                   push    AF              ; Save AND mask
3451+ 2A81 1E 00                ld      E,$00           ; Assume zero if none given
3452+ 2A83 2B                   dec     HL              ; dec 'cos GETCHR INCs
3453+ 2A84 CD 97 1D             call    GETCHR          ; Get next character
3454+ 2A87 CA 91 2A             jp      Z,NOXOR         ; No XOR byte given
3455+ 2A8A CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
3456+ 2A8D 2C                   defb    ','
3457+ 2A8E CD AE 2A             call    GETINT          ; Get integer 0-255 to XOR with
3458+ 2A91 C1           NOXOR:  pop     BC              ; Restore AND mask
3459+ 2A92 CD 42 54     WAITLP: call    INPSUB          ; Get input
3460+ 2A95 AB                   xor     E               ; Flip selected bits
3461+ 2A96 A0                   and     B               ; Result non-zero?
3462+ 2A97 CA 92 2A             jp      Z,WAITLP        ; No = keep waiting
3463+ 2A9A C9                   ret
3464+ 2A9B
3465+ 2A9B CD AE 2A     SETIO:  call    GETINT          ; Get integer 0-255
3466+ 2A9E 32 43 54             ld      (INPORT),A      ; Set input port
3467+ 2AA1 32 0B 54             ld      (OTPORT),A      ; Set output port
3468+ 2AA4 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
3469+ 2AA7 2C                   defb    ','
3470+ 2AA8 C3 AE 2A             jp      GETINT          ; Get integer 0-255 and return
3471+ 2AAB
3472+ 2AAB CD 97 1D     FNDNUM: call    GETCHR          ; Get next character
3473+ 2AAE CD 28 22     GETINT: call    GETNUM          ; Get a number from 0 to 255
3474+ 2AB1 CD 47 1E     MAKINT: call    DEPINT          ; Make sure value 0 - 255
3475+ 2AB4 7A                   ld      A,D             ; Get MSB of number
3476+ 2AB5 B7                   or      A               ; Zero?
3477+ 2AB6 C2 62 1E             jp      NZ,FCERR        ; No - Error
3478+ 2AB9 2B                   dec     HL              ; dec 'cos GETCHR INCs
3479+ 2ABA CD 97 1D             call    GETCHR          ; Get next character
3480+ 2ABD 7B                   ld      A,E             ; Get number to A
3481+ 2ABE C9                   ret
3482+ 2ABF
3483+ 2ABF
3484+ 2ABF              ; activate a Non-Maskable Interrupt hooked to VDP interrupt signal
3485+ 2ABF              ; address must point to an ISR routine that terminates with EI/RETN instructions
3486+ 2ABF CD 28 22     NMI:    call    GETNUM          ; Get memory address
3487+ 2AC2 CD 4D 1E             call    DEINT           ; get integer -32768 to 32767
3488+ 2AC5 7B                   ld      A,E             ; check if address is 0
3489+ 2AC6 B2                   or      D
3490+ 2AC7 20 11                jr      NZ,NM1          ; no, so jump over
3491+ 2AC9 F3           DISNMI: di                      ; disable INTs
3492+ 2ACA CD F6 2A             call    NMIDINT         ; disable VDP INT
3493+ 2ACD E5                   push    HL              ; store HL
3494+ 2ACE 21 ED 45             ld      HL,$45ED        ; these are the op-codes for "RETN"
3495+ 2AD1 22 04 54             ld      (NMIUSR),HL     ; store RETN
3496+ 2AD4 AF                   xor     A
3497+ 2AD5 32 06 54             ld      (NMIUSR+2),A    ; "NOP"
3498+ 2AD8 18 11                jr      NMI2            ; execute the last part of code
3499+ 2ADA E5           NM1:    push    HL              ; store current HL
3500+ 2ADB EB                   ex      DE,HL           ; move address argument into HL
3501+ 2ADC F3                   di                      ; disable INTs
3502+ 2ADD CD F6 2A             call    NMIDINT         ; disable VDP INT, if enabled
3503+ 2AE0 3E C3                ld      A,$C3           ; "jp" instruction
3504+ 2AE2 32 04 54             ld      (NMIUSR),A      ; store it
3505+ 2AE5 22 05 54             ld      (NMIUSR+1),HL   ; store address
3506+ 2AE8 CD EF 2A             call    NMIEINT         ; re-enable VDP INT
3507+ 2AEB FB           NMI2:   ei                      ; re-enable INTS
3508+ 2AEC 00                   nop                     ; wait for INTs
3509+ 2AED E1                   pop    HL               ; retrieve HL
3510+ 2AEE C9                   ret                     ; return to caller
3511+ 2AEF              ; enable VDP INT
3512+ 2AEF CD 05 2B     NMIEINT:call    NMIVR1          ; load default VReg #1 setting
3513+ 2AF2 F6 20                or      %00100000       ; enable VDP INT
3514+ 2AF4 18 03                jr      NMIINT          ; rest of code is shared
3515+ 2AF6              ; disable VDP INT
3516+ 2AF6 CD 05 2B     NMIDINT:call    NMIVR1          ; load default VReg #1 setting
3517+ 2AF9 D5           NMIINT: push    DE              ; store DE
3518+ 2AFA 5F                   ld      E,A             ; move value into E
3519+ 2AFB 3E 01                ld      A,$01           ; VREG #1
3520+ 2AFD F3                   di                      ; disable INTs
3521+ 2AFE CD BA 06             call    WRITE_VREG      ; disable VDP INT
3522+ 2B01 FB                   ei                      ; re-enable INTs
3523+ 2B02 00                   nop                     ; wait for INTs being enabled
3524+ 2B03 D1                   pop     DE              ; retrieve DE
3525+ 2B04 C9                   ret                     ; return to caller
3526+ 2B05
3527+ 2B05              ; load VREG #1 setting for current screen mode and return it into A
3528+ 2B05 E5           NMIVR1: push    HL              ; store HL
3529+ 2B06 D5                   push    DE              ; store DE
3530+ 2B07 3A 97 55             ld      A,(SCR_MODE)    ; check screen mode
3531+ 2B0A 87                   add     A,A             ; multiply A by 8...
3532+ 2B0B 87                   add     A,A             ; ...so that reg. A can points..
3533+ 2B0C 87                   add     A,A             ; to the correct settings
3534+ 2B0D 3C                   inc     A               ; need to change VREG 1
3535+ 2B0E 5F                   ld      E,A             ; copy A into E
3536+ 2B0F 16 00                ld      D,$00           ; reset D
3537+ 2B11 21 29 0B             ld      HL,VDPMODESET   ; pointer to register #1 setting...
3538+ 2B14 19                   add     HL,DE           ; ...for current screen mode
3539+ 2B15 7E                   ld      A,(HL)          ; load current setting
3540+ 2B16 D1                   pop     DE              ; retrieve DE
3541+ 2B17 E1                   pop     HL              ; retrieve HL
3542+ 2B18 C9                   ret                     ; return to caller
3543+ 2B19
3544+ 2B19              ; execute a machine language routine, eventually passing a param into A
3545+ 2B19 CD 28 22     SYS:    call    GETNUM          ; Get memory address
3546+ 2B1C CD 4D 1E             call    DEINT           ; Get integer -32768 to 32767
3547+ 2B1F ED 53 A7 55          ld      (TMPBFR2),DE    ; store user routine's address
3548+ 2B23 AF                   xor     A               ; reset A
3549+ 2B24 32 A5 55             ld      (TMPBFR1),A     ; store into temp buffer
3550+ 2B27 2B                   dec     HL              ; dec 'cos GETCHR INCs
3551+ 2B28 CD 97 1D             call    GETCHR          ; check next character
3552+ 2B2B 28 0A                jr      Z,NOSYSPR       ; jump if nothing follows
3553+ 2B2D CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
3554+ 2B30 2C                   defb    ','
3555+ 2B31 CD AE 2A             call    GETINT          ; get byte value (0~255) if something follows
3556+ 2B34 32 A5 55             ld      (TMPBFR1),A     ; store into temp buffer
3557+ 2B37 3A A5 55     NOSYSPR:ld      A,(TMPBFR1)     ; recover A
3558+ 2B3A ED 5B A7 55          ld      DE,(TMPBFR2)    ; recover user routine's address
3559+ 2B3E E5                   push    HL              ; save code string address
3560+ 2B3F EB                   ex      DE,HL           ; move user routine's address into HL
3561+ 2B40 11 45 2B             ld      DE,SYSRET       ; set point of return after the user routine
3562+ 2B43 D5                   push    DE              ; store into stack
3563+ 2B44 E9                   jp      (HL)            ; call user routine
3564+ 2B45 E1           SYSRET: pop     HL              ; retrieve code string address
3565+ 2B46 C9                   ret                     ; return to caller
3566+ 2B47
3567+ 2B47
3568+ 2B47              ; read the contents of a RAM location
3569+ 2B47 CD 4D 1E     PEEK:   call    DEINT           ; Get memory address into DE
3570+ 2B4A 1A                   ld      A,(DE)          ; Read value of memory cell
3571+ 2B4B C3 21 26             jp      PASSA           ; Return into A
3572+ 2B4E
3573+ 2B4E              ; read the contents of a VRAM location
3574+ 2B4E CD 4D 1E     VPEEK:  call    DEINT           ; Get VRAM address into DE
3575+ 2B51 EB                   ex      DE,HL           ; Copy param into HL
3576+ 2B52 F3                   di                      ; Disable interrupts
3577+ 2B53 CD 90 06             call    READ_VIDEO_LOC  ; Read data from VRAM at address HL
3578+ 2B56 FB                   ei                      ; Re-enable interrupts
3579+ 2B57 EB                   ex      DE,HL           ; Restore HL
3580+ 2B58 C3 21 26             jp      PASSA           ; Return value into A
3581+ 2B5B
3582+ 2B5B              ; recover params for POKE/VPOKE commands
3583+ 2B5B              ; returns address into DE and byte to be written into A
3584+ 2B5B CD 28 22     PKEPRMS:call    GETNUM          ; Get memory address
3585+ 2B5E CD 4D 1E             call    DEINT           ; Get integer -32768 to 32767
3586+ 2B61 ED 53 A5 55          ld      (TMPBFR1),DE    ; Store DE into a temp. buffer
3587+ 2B65 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
3588+ 2B68 2C                   defb    ','
3589+ 2B69 CD AE 2A             call    GETINT          ; Get integer 0-255
3590+ 2B6C ED 5B A5 55          ld      DE,(TMPBFR1)    ; Restore memory address
3591+ 2B70 C9                   ret                     ; Return to caller
3592+ 2B71
3593+ 2B71              ; write a byte into a RAM location
3594+ 2B71 CD 5B 2B     POKE:   call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3595+ 2B74 12                   ld      (DE),A          ; Load it into memory
3596+ 2B75 C9                   ret
3597+ 2B76
3598+ 2B76              ; write a byte into a VRAM location
3599+ 2B76 CD 5B 2B     VPOKE:  call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3600+ 2B79 EB                   ex      DE,HL           ; Copy address into HL
3601+ 2B7A F3                   di                      ; Disable interrupts
3602+ 2B7B CD A5 06             call    WRITE_VIDEO_LOC ; write data into VRAM at address HL
3603+ 2B7E FB                   ei                      ; Re-enable interrupts
3604+ 2B7F EB                   ex      DE,HL           ; Restore HL
3605+ 2B80 C9                   ret                     ; Return to caller
3606+ 2B81
3607+ 2B81              ; position the cursor at a specific X,Y location onto screen
3608+ 2B81 CD AE 2A     LOCATE: call    GETINT          ; get the first param into A
3609+ 2B84 E5                   push    HL              ; store HL
3610+ 2B85 21 95 55             ld      HL,SCR_SIZE_W   ; load address of screen width
3611+ 2B88 5E                   ld      E,(HL)          ; load screen width into E
3612+ 2B89 E1                   pop     HL              ; restore HL
3613+ 2B8A BB                   cp      E               ; compare witdh with param
3614+ 2B8B D2 62 1E             jp      NC,FCERR        ; value over the width of the screen, exit with Illegal F.C. error
3615+ 2B8E 32 A5 55             ld      (TMPBFR1),A     ; Store X into a temp. buffer
3616+ 2B91 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
3617+ 2B94 2C                   defb    ','
3618+ 2B95 CD AE 2A             call    GETINT          ; Get the second param into A
3619+ 2B98 E5                   push    HL              ; store HL
3620+ 2B99 21 96 55             ld      HL,SCR_SIZE_H   ; load address of screen width
3621+ 2B9C 5E                   ld      E,(HL)          ; load screen width into A
3622+ 2B9D E1                   pop     HL              ; restore HL
3623+ 2B9E BB                   cp      E               ; compare witdh with param
3624+ 2B9F D2 62 1E             jp      NC,FCERR        ; value over the height of the screen, exit with Illegal F.C. error
3625+ 2BA2 32 9D 55             ld      (SCR_CUR_NY),A  ; store new Y
3626+ 2BA5 3A A5 55             ld      A,(TMPBFR1)     ; recover the new X
3627+ 2BA8 32 9C 55             ld      (SCR_CUR_NX),A  ; store new X
3628+ 2BAB E5                   push    HL              ; store HL
3629+ 2BAC F3                   di                      ; disable INTs
3630+ 2BAD CD D6 06             call    MOVCRS          ; move cursor to new location
3631+ 2BB0 FB                   ei                      ; re-enable INTs
3632+ 2BB1 E1                   pop     HL              ; restore HL
3633+ 2BB2 C9                   ret                     ; return to caller
3634+ 2BB3
3635+ 2BB3              ; write a byte into one of the PSG registers
3636+ 2BB3 CD AE 2A     SREG:   call    GETINT          ; Get register number back into A
3637+ 2BB6 FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3638+ 2BB8 D2 62 1E             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3639+ 2BBB 32 A5 55             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3640+ 2BBE CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
3641+ 2BC1 2C                   defb    ','
3642+ 2BC2 CD AE 2A             call    GETINT          ; get second value (0-255), returned into A
3643+ 2BC5 5F                   ld      E,A             ; store value into E
3644+ 2BC6 3A A5 55             ld      A,(TMPBFR1)     ; recover VDP register and store into D
3645+ 2BC9 F3                   di                      ; disable INTs
3646+ 2BCA 0E 40                ld      C,PSG_REG       ; output port to access PSG registers
3647+ 2BCC ED 79                out     (C),A           ; send register # to PSG
3648+ 2BCE 0E 41                ld      C,PSG_DAT       ; output port to send data to PSG
3649+ 2BD0 ED 59                out     (C),E           ; send byte to write into selected register
3650+ 2BD2 FB                   ei                      ; re-enable INTs
3651+ 2BD3 C9                   ret                     ; return to caller
3652+ 2BD4
3653+ 2BD4              ; VOLUME ch,vol
3654+ 2BD4              ; set the volume for the audio channels
3655+ 2BD4              ; "ch" is 1~3 for corresponding channel, or 0 for all; "vol" is 0~15 (0=OFF, 15=MAX)
3656+ 2BD4 CD AE 2A     VOLUME: call    GETINT          ; get integer 0-255 (recover channel)
3657+ 2BD7 FE 04                cp      $04             ; check if it's in the range 0~3
3658+ 2BD9 D2 62 1E             jp      NC,FCERR        ; if not, exit with Illegal function call error
3659+ 2BDC 32 A5 55             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3660+ 2BDF CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
3661+ 2BE2 2C                   defb    ','
3662+ 2BE3 CD AE 2A             call    GETINT          ; get integer 0-255 (recover channel)
3663+ 2BE6 FE 10                cp      $10             ; check if it's in the range 0~15
3664+ 2BE8 D2 62 1E             jp      NC,FCERR        ; if not, exit with Illegal funcion call
3665+ 2BEB 57                   ld      D,A             ; store volume into D
3666+ 2BEC 3A A5 55             ld      A,(TMPBFR1)     ; retrieve channel
3667+ 2BEF A7                   and     A               ; is it 0? (0=every channel)
3668+ 2BF0 20 10                jr      NZ,VOLCH        ; no, jump over
3669+ 2BF2 06 03                ld      B,$03           ; yes, set every channel
3670+ 2BF4 1E 08                ld      E,$08           ; register volume of first channel
3671+ 2BF6 0E 40        RPVOLCG:ld      C,PSG_REG       ; PSG register port
3672+ 2BF8 ED 59                out     (C),E           ; set register #
3673+ 2BFA 0E 41                ld      C,PSG_DAT       ; PSG data port
3674+ 2BFC ED 51                out     (C),D           ; send volume
3675+ 2BFE 1C                   inc     E               ; next register
3676+ 2BFF 10 F5                djnz    RPVOLCG         ; repeat for each channel
3677+ 2C01 C9                   ret                     ; return to caller
3678+ 2C02 0E 40        VOLCH:  ld      C,PSG_REG       ; PSG register port
3679+ 2C04 C6 07                add     $07             ; add 7 to A so that we have the correct register (1->8, 2->9, 3->10)
3680+ 2C06 ED 79                out     (C),A           ; set register
3681+ 2C08 0E 41                ld      C,PSG_DAT       ; PSG data port
3682+ 2C0A ED 51                out     (C),D           ; send volume level
3683+ 2C0C C9                   ret                     ; return to caller
3684+ 2C0D
3685+ 2C0D              ; SOUND ch,tone,dur
3686+ 2C0D              ; play a tone or noise of "tone" frequency from selected channel "ch" for duration "dur"
3687+ 2C0D              ; "ch" is 1~6 (0=means sound OFF,1~3 for tone, 4~6 for noise) / "tone" is 1~4,095 (0=means no tone) /
3688+ 2C0D              ; "dur" is 1~16383 h.o.s.,0.001~163s (0=means non-stop tone)
3689+ 2C0D CD AE 2A     SOUND:  call    GETINT          ; get integer 0-255 (recover channel)
3690+ 2C10 A7                   and     A               ; is it zero?
3691+ 2C11 20 08                jr      NZ,CTSNDC       ; no, continue with checking of params
3692+ 2C13 E5                   push    HL              ; store HL
3693+ 2C14 F3                   di                      ; disable INTs
3694+ 2C15 CD 9B 0C             call    CLRPSGREGS      ; yes, it's zero, so reset PSG registers to shut down every sound
3695+ 2C18 FB                   ei                      ; re-enable INTs
3696+ 2C19 E1                   pop     HL              ; retrieve HL
3697+ 2C1A C9                   ret                     ; return to caller
3698+ 2C1B 32 A5 55     CTSNDC: ld      (TMPBFR1),A     ; no, continue by storing A into a temp. buffer
3699+ 2C1E FE 04                cp      $04             ; is channel >3?
3700+ 2C20 D2 9F 2C             jp      NC,NOISUP       ; Yes - check to see if it's a noise channel
3701+ 2C23 CD 4E 1B             call    CHKSYN          ; No, continue checking by making sure ',' follows
3702+ 2C26 2C                   defb    ','
3703+ 2C27 CD 28 22             call    GETNUM          ; Get tone frequency
3704+ 2C2A CD 4D 1E             call    DEINT           ; Get integer -32768 to 32767
3705+ 2C2D ED 53 A7 55          ld      (TMPBFR2),DE    ; Store frequency
3706+ 2C31 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
3707+ 2C34 2C                   defb    ','
3708+ 2C35 CD 28 22             call    GETNUM          ; Get duration
3709+ 2C38 CD 4D 1E             call    DEINT           ; Get integer -32768 to 32767
3710+ 2C3B ED 53 A9 55          ld      (TMPBFR3),DE    ; Store duration
3711+ 2C3F                                              ; CHECK CHANNEL
3712+ 2C3F 3A A5 55             ld      A,(TMPBFR1)     ; recover channel
3713+ 2C42 FE 01                cp      $01             ; is channel <1?
3714+ 2C44 DA 62 1E             jp      C,FCERR         ; Yes - Illegal function call error
3715+ 2C47                                              ; CHECK FREQUENCY
3716+ 2C47 ED 5B A7 55          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3717+ 2C4B 7A                   ld      A,D             ; move D into A and check if it is in the range 0~4095...
3718+ 2C4C FE 10                cp      $10             ; ...so D must not be greater than $0F (15)
3719+ 2C4E D2 62 1E             jp      NC,FCERR        ; if not in the range, exit with an Illegal function call error
3720+ 2C51                                              ; CHECK DURATION
3721+ 2C51 ED 5B A9 55          ld      DE,(TMPBFR3)    ; restore duration from temp buffer
3722+ 2C55 7A                   ld      A,D             ; check if it is in the range 0~16383...
3723+ 2C56 E6 C0                and     $C0             ; ...(15th & 14th bits must not be set)
3724+ 2C58 C2 62 1E             jp      NZ,FCERR        ; if not in the range, exit with an Illegal function call error
3725+ 2C5B                                              ;
3726+ 2C5B                                              ; SET TONE:
3727+ 2C5B                                              ; let's start by setting up the channel
3728+ 2C5B 3A A5 55             ld      A,(TMPBFR1)     ; restore channel value
3729+ 2C5E FE 03                cp      $03             ; is it 3?
3730+ 2C60 20 02                jr      NZ,SND1         ; no, jump over
3731+ 2C62 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3732+ 2C64 2F           SND1:   cpl                     ; complement of A - this is used later to set on the channel into the mixer
3733+ 2C65 CD EC 2C             call    WRTSND          ; enable line into mixer of channel stored in A
3734+ 2C68                                              ; SET FREQUENCY
3735+ 2C68                                              ; we simply get frequency and subtract from 4096. The result
3736+ 2C68                                              ; is put into register pair of the corresponding freq tone channel
3737+ 2C68 ED 5B A7 55          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3738+ 2C6C E5                   push    HL              ; store HL (it will be used by the subroutine)
3739+ 2C6D 21 00 10             ld      HL,$1000        ; load 4096 into HL
3740+ 2C70 A7                   and     A               ; reset C flag
3741+ 2C71 ED 52                sbc     HL,DE           ; subtract freq from HL - now the frequency is inverted, so we will send the low as high and vice-versa
3742+ 2C73 3A A5 55             ld      A,(TMPBFR1)     ; restore channel value
3743+ 2C76 3D                   dec     A               ; set A into the range 0~2
3744+ 2C77 87                   add     A,A             ; double A to find the register pair that correspond to the channel (A->0,1 / B->2,3, C->4,5)
3745+ 2C78 0E 40                ld      C,PSG_REG       ; PSG register port
3746+ 2C7A ED 79                out     (C),A           ; select first register of the pair
3747+ 2C7C 0E 41                ld      C,PSG_DAT       ; PSG data port
3748+ 2C7E ED 69                out     (C),L           ; send high byte
3749+ 2C80 0E 40                ld      C,PSG_REG       ; PSG register support
3750+ 2C82 3C                   inc     A               ; second register of the pair
3751+ 2C83 ED 79                out     (C),A           ; select register
3752+ 2C85 0E 41                ld      C,PSG_DAT       ; PSG data port
3753+ 2C87 ED 61                out     (C),H           ; send low byte
3754+ 2C89 ED 5B A9 55          ld      DE,(TMPBFR3)    ; recover duration
3755+ 2C8D 3A A5 55             ld      A,(TMPBFR1)     ; recover channel value
3756+ 2C90 3D                   dec     A               ; set channel into the range 0~2
3757+ 2C91 87                   add     A,A             ; double A to find the correct offset
3758+ 2C92 21 D9 55             ld      HL,CHASNDDTN    ; set duration into...
3759+ 2C95 85                   add     A,L             ; ...the proper...
3760+ 2C96 30 01                jr      NC,SNDOVR       ; (is there a rest? no, jump over
3761+ 2C98 24                   inc     H               ; yes, increment H)
3762+ 2C99 6F           SNDOVR: ld      L,A             ; ...register pair...
3763+ 2C9A 73                   ld      (HL),E          ; ...and store the value
3764+ 2C9B 23                   inc     HL
3765+ 2C9C 72                   ld      (HL),D
3766+ 2C9D E1                   pop     HL              ; retrieve HL
3767+ 2C9E C9                   ret                     ; Return to caller
3768+ 2C9F FE 07        NOISUP: cp      $07             ; is channel in range 4 to 6 (for a noise)?
3769+ 2CA1 D2 62 1E             jp      NC,FCERR        ; no, so ILLEGAL FUNCTION CALL
3770+ 2CA4 CD 4E 1B             call    CHKSYN          ; yes, continue checking by making sure ',' follows
3771+ 2CA7 2C                   defb    ','
3772+ 2CA8 CD AE 2A             call    GETINT          ; get integer 0-255 (frequency)
3773+ 2CAB FE 20                cp      $20             ; make sure it's in range 0~31
3774+ 2CAD D2 62 1E             jp      NC,FCERR        ; no, so Illegal function call
3775+ 2CB0 32 A7 55             ld      (TMPBFR2),A     ; store freq.
3776+ 2CB3 2B                   dec     HL              ; dec 'cos GETCHR INCs
3777+ 2CB4 CD 97 1D             call    GETCHR          ; check that nothing follows
3778+ 2CB7 C2 50 18             jp      NZ,SNERR        ; error if no empty line
3779+ 2CBA 3A A7 55             ld      A,(TMPBFR2)     ; retrieve freq.
3780+ 2CBD 5F                   ld      E,A             ; store freq into E
3781+ 2CBE 3A A5 55             ld      A,(TMPBFR1)     ; retrieve channel
3782+ 2CC1 D6 03                sub     $03             ; subtract 3 to get channel in range 1~3
3783+ 2CC3 FE 03                cp      $03             ; is it 3?
3784+ 2CC5 20 02                jr      NZ,NOS1         ; no, jump over
3785+ 2CC7 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3786+ 2CC9 87           NOS1:   add     A,A
3787+ 2CCA 87                   add     A,A
3788+ 2CCB 87                   add     A,A             ; let's move A 3 bits to left
3789+ 2CCC 47                   ld      B,A             ; store channel into B
3790+ 2CCD 7B                   ld      A,E             ; check if
3791+ 2CCE A7                   and     A               ; freq is 0 (means that noise reproduction must be halted)
3792+ 2CCF F3                   di                      ; disable INts
3793+ 2CD0 20 0A                jr      NZ,NOS2         ; no, so jump over
3794+ 2CD2 3E 07                ld      A,$07           ; mixer register
3795+ 2CD4 CD E9 0C             call    SETSNDREG       ; set mixer register
3796+ 2CD7 ED 78                in      A,(C)           ; load current mixer value
3797+ 2CD9 B0                   or      B               ; disable noise
3798+ 2CDA 18 19                jr      NOS3            ; continue over
3799+ 2CDC 78           NOS2:   ld      A,B             ; recover channel
3800+ 2CDD 2F                   cpl                     ; complement of A - this is used to set on the channel into the mixer
3801+ 2CDE CD EC 2C             call    WRTSND          ; enable line into mixer of channel stored in A
3802+ 2CE1 3E 06                ld      A,$06           ; write into noise register
3803+ 2CE3 CD E9 0C             call    SETSNDREG       ; set register into PSG
3804+ 2CE6 7B                   ld      A,E             ; load value for noise frequency
3805+ 2CE7 CD EE 0C             call    WRTSNDREG       ; write data into register $06
3806+ 2CEA FB                   ei                      ; re-enable INTs
3807+ 2CEB C9                   ret
3808+ 2CEC                      ; enable line into mixer of channel stored in A
3809+ 2CEC 47           WRTSND: ld      B,A             ; move channel into B
3810+ 2CED 3E 07                ld      A,$07           ; mixer register
3811+ 2CEF CD E9 0C             call    SETSNDREG       ; set mixer register
3812+ 2CF2 ED 78                in      A,(C)           ; load current value
3813+ 2CF4 A0                   and     B               ; set on the channel into the mixer (remember that 0=ON)
3814+ 2CF5                                              ; example: if channel is A (1), complement of 1 is 254 (11111110). So, 255 (in case
3815+ 2CF5                                              ; the register is still unchanged after reset) is 11111111 and
3816+ 2CF5                                              ; 11111111 AND 11111110 is equal to 11111110
3817+ 2CF5                                              ; 11111001 AND 11111110 is equal to 11111000 (in case channels B & C are ON)
3818+ 2CF5 47           NOS3:   ld      B,A             ; store new mixer value into B
3819+ 2CF6 3E 07                ld      A,$07           ; mixer address
3820+ 2CF8 CD E9 0C             call    SETSNDREG       ; set register
3821+ 2CFB 78                   ld      A,B             ; retrieve new mixer value from B
3822+ 2CFC CD EE 0C             call    WRTSNDREG       ; send new value for the mixer
3823+ 2CFF FB                   ei                      ; re-enable INTs
3824+ 2D00 C9                   ret                     ; return to caller
3825+ 2D01
3826+ 2D01              ; write a byte into one of the VDP registers
3827+ 2D01 CD AE 2A     VREG:   call    GETINT          ; Get register number back into A
3828+ 2D04 FE 08                cp      $08             ; check if value is equal or greater than 8 (VDP registers are only 8, from 0 to 7)
3829+ 2D06 D2 62 1E             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3830+ 2D09 32 A5 55             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3831+ 2D0C CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
3832+ 2D0F 2C                   defb    ','
3833+ 2D10 CD AE 2A             call    GETINT          ; get value (0-255)
3834+ 2D13 5F                   ld      E,A             ; store value into E
3835+ 2D14 3A A5 55             ld      A,(TMPBFR1)     ; recover VDP register and store into A
3836+ 2D17 F3                   di                      ; disable INTs
3837+ 2D18 CD BA 06             call    WRITE_VREG      ; write value into VDP register
3838+ 2D1B FB                   ei                      ; re-enable INTs
3839+ 2D1C C9                   ret                     ; return to caller
3840+ 2D1D
3841+ 2D1D              ; read the VDP status register and return it into A
3842+ 2D1D CD 4D 1E     VSTAT:  call    DEINT           ; Get integer -32768 to 32767 (Note: we do NOT use it)
3843+ 2D20 F3                   di                      ; disable INTs
3844+ 2D21 CD C5 06             call    READ_VSTAT      ; read VDP register status
3845+ 2D24 FB                   ei                      ; re-enable INTs
3846+ 2D25 C3 21 26             jp      PASSA           ; Return integer A
3847+ 2D28
3848+ 2D28              ; read from PSG register and return it into A
3849+ 2D28 CD 4D 1E     SSTAT:  call    DEINT           ; get integer -32768 to 32767
3850+ 2D2B 7B                   ld      A,E             ; consider LSB
3851+ 2D2C FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3852+ 2D2E D2 62 1E             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3853+ 2D31 F3                   di                      ; disable INts
3854+ 2D32 0E 40                ld      C,PSG_REG       ; output port to set PSG register
3855+ 2D34 ED 79                out     (C),A           ; send register to read from
3856+ 2D36 ED 78                in      A,(C)           ; read register's contents and store into A
3857+ 2D38 FB                   ei                      ; re-enable INTs
3858+ 2D39 C3 21 26             jp      PASSA           ; return A
3859+ 2D3C
3860+ 2D3C              ; read the temp key buffer and return the value of the current key being pressed
3861+ 2D3C              ; can wait for the number of 100thds of second before to return
3862+ 2D3C CD 9B 26     INKEY:  call    IDTEST          ; Test for illegal direct
3863+ 2D3F CD 4D 1E             call    DEINT           ; get number param (100thds of second to wait) into DE
3864+ 2D42 C5                   push    BC              ; store BC
3865+ 2D43 3A 85 55             ld      A,(TMRCNT)      ; Load current value of system timer
3866+ 2D46 47                   ld      B,A             ; move it into B
3867+ 2D47 3A 85 55     CMP_A:  ld      A,(TMRCNT)      ; make a little delay of 1/100 sec...
3868+ 2D4A B8                   cp      B               ; ...to let the sniffer collect...
3869+ 2D4B 20 FA                jr      NZ,CMP_A        ; ...at least 1 char before to continue
3870+ 2D4D 7A                   ld      A,D             ; check the param
3871+ 2D4E B3                   or      E               ; if DE<>0 then...
3872+ 2D4F 20 05                jr      NZ,INKEY2       ; ...jump over...
3873+ 2D51 3A E1 55             ld      A,(TMPKEYBFR)   ; ...else read the buffer and...
3874+ 2D54 18 2A                jr      ENDINK          ; ...return it
3875+ 2D56 7A           INKEY2: ld      A,D             ; check if param>1023
3876+ 2D57 FE 04                cp      $04             ; to do this we check if MSB>3
3877+ 2D59 D2 62 1E             jp      NC,FCERR        ; if MSB >=4 then error
3878+ 2D5C E5                   push    HL              ; store HL
3879+ 2D5D 21 09 00             ld      HL,$0009        ; check if value
3880+ 2D60 CD 61 41             call    CMP16           ; is < 10
3881+ 2D63 E1                   pop     HL              ; retrieve HL
3882+ 2D64 DA 6A 2D             jp      C,SRTINK        ; if value >= 10 then jump over
3883+ 2D67 11 0A 00             ld      DE,$000A        ; else, use 10 (no intervals shorter than 10/100s)
3884+ 2D6A 3A 85 55     SRTINK: ld      A,(TMRCNT)      ; Load the first byte of the system timer
3885+ 2D6D 47                   ld      B,A             ; move it into B
3886+ 2D6E 3A E1 55     CHKINK: ld      A,(TMPKEYBFR)   ; load char code from buffer
3887+ 2D71 A7                   and     A               ; is it 0?
3888+ 2D72 20 0C                jr      NZ,ENDINK       ; no, so we can return it
3889+ 2D74 3A 85 55             ld      A,(TMRCNT)      ; load the first byte of the system timer
3890+ 2D77 B8                   cp      B               ; is it the same value?
3891+ 2D78 28 F4                jr      Z,CHKINK        ; yes, so read again
3892+ 2D7A 47                   ld      B,A             ; store new value
3893+ 2D7B 1B                   dec     DE              ; no, decrement timer
3894+ 2D7C 7A                   ld      A,D             ; check if zero reached
3895+ 2D7D B3                   or      E               ; by ORing D and E
3896+ 2D7E 20 EE                jr      NZ,CHKINK       ; if not 0, repeat
3897+ 2D80 C1           ENDINK: pop     BC              ; restore BC
3898+ 2D81 F5                   push    AF              ; store A
3899+ 2D82 F3                   di                      ; disable INTs
3900+ 2D83 AF                   xor     A               ; clear the...
3901+ 2D84 32 E1 55             ld      (TMPKEYBFR),A   ; ...TMP KEY buffer for the next read
3902+ 2D87 FB                   ei                      ; re-enable INTs
3903+ 2D88 F1                   pop     AF              ; retrieve A
3904+ 2D89 C3 21 26             jp      PASSA           ; return A as ASCII value
3905+ 2D8C
3906+ 2D8C
3907+ 2D8C 21 B3 32     ROUND:  ld      HL,HALF         ; Add 0.5 to FPREG
3908+ 2D8F CD 84 30     ADDPHL: call    LOADFP          ; Load FP at (HL) to BCDE
3909+ 2D92 C3 9E 2D             jp      FPADD           ; Add BCDE to FPREG
3910+ 2D95
3911+ 2D95
3912+ 2D95 CD 84 30     SUBPHL: call    LOADFP          ; FPREG = -FPREG + number at HL
3913+ 2D98 21                   defb    $21             ; Skip "pop BC" and "pop DE"
3914+ 2D99 C1           PSUB:   pop     BC              ; Get FP number from stack
3915+ 2D9A D1                   pop     DE
3916+ 2D9B CD 5E 30     SUBCDE: call    INVSGN          ; Negate FPREG
3917+ 2D9E 78           FPADD:  ld      A,B             ; Get FP exponent
3918+ 2D9F B7                   or      A               ; Is number zero?
3919+ 2DA0 C8                   ret     Z               ; Yes - Nothing to add
3920+ 2DA1 3A FC 55             ld      A,(FPEXP)       ; Get FPREG exponent
3921+ 2DA4 B7                   or      A               ; Is this number zero?
3922+ 2DA5 CA 76 30             jp      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3923+ 2DA8 90                   sub     B               ; BCDE number larger?
3924+ 2DA9 D2 B8 2D             jp      NC,NOSWAP       ; No - Don't swap them
3925+ 2DAC 2F                   cpl                     ; Two's complement
3926+ 2DAD 3C                   inc     A               ;  FP exponent
3927+ 2DAE EB                   ex      DE,HL
3928+ 2DAF CD 66 30             call    STAKFP          ; Put FPREG on stack
3929+ 2DB2 EB                   ex      DE,HL
3930+ 2DB3 CD 76 30             call    FPBCDE          ; Move BCDE to FPREG
3931+ 2DB6 C1                   pop     BC              ; Restore number from stack
3932+ 2DB7 D1                   pop     DE
3933+ 2DB8 FE 19        NOSWAP: cp      24+1            ; Second number insignificant?
3934+ 2DBA D0                   ret     NC              ; Yes - First number is result
3935+ 2DBB F5                   push    AF              ; Save number of bits to scale
3936+ 2DBC CD 9B 30             call    SIGNS           ; Set MSBs & sign of result
3937+ 2DBF 67                   ld      H,A             ; Save sign of result
3938+ 2DC0 F1                   pop     AF              ; Restore scaling factor
3939+ 2DC1 CD 63 2E             call    SCALE           ; Scale BCDE to same exponent
3940+ 2DC4 B4                   or      H               ; Result to be positive?
3941+ 2DC5 21 F9 55             ld      HL,FPREG        ; Point to FPREG
3942+ 2DC8 F2 DE 2D             jp      P,MINCDE        ; No - Subtract FPREG from CDE
3943+ 2DCB CD 43 2E             call    PLUCDE          ; Add FPREG to CDE
3944+ 2DCE D2 24 2E             jp      NC,RONDUP       ; No overflow - Round it up
3945+ 2DD1 23                   inc     HL              ; Point to exponent
3946+ 2DD2 34                   inc     (HL)            ; Increment it
3947+ 2DD3 CA 5F 18             jp      Z,OVERR         ; Number overflowed - Error
3948+ 2DD6 2E 01                ld      L,$01           ; 1 bit to shift right
3949+ 2DD8 CD 79 2E             call    SHRT1           ; Shift result right
3950+ 2DDB C3 24 2E             jp      RONDUP          ; Round it up
3951+ 2DDE
3952+ 2DDE AF           MINCDE: xor     A               ; Clear A and carry
3953+ 2DDF 90                   sub     B               ; Negate exponent
3954+ 2DE0 47                   ld      B,A             ; Re-save exponent
3955+ 2DE1 7E                   ld      A,(HL)          ; Get LSB of FPREG
3956+ 2DE2 9B                   sbc     A, E            ; Subtract LSB of BCDE
3957+ 2DE3 5F                   ld      E,A             ; Save LSB of BCDE
3958+ 2DE4 23                   inc     HL
3959+ 2DE5 7E                   ld      A,(HL)          ; Get NMSB of FPREG
3960+ 2DE6 9A                   sbc     A,D             ; Subtract NMSB of BCDE
3961+ 2DE7 57                   ld      D,A             ; Save NMSB of BCDE
3962+ 2DE8 23                   inc     HL
3963+ 2DE9 7E                   ld      A,(HL)          ; Get MSB of FPREG
3964+ 2DEA 99                   sbc     A,C             ; Subtract MSB of BCDE
3965+ 2DEB 4F                   ld      C,A             ; Save MSB of BCDE
3966+ 2DEC DC 4F 2E     CONPOS: call    C,COMPL         ; Overflow - Make it positive
3967+ 2DEF
3968+ 2DEF 68           BNORM:  ld      L,B             ; L = Exponent
3969+ 2DF0 63                   ld      H,E             ; H = LSB
3970+ 2DF1 AF                   xor     A
3971+ 2DF2 47           BNRMLP: ld      B,A             ; Save bit count
3972+ 2DF3 79                   ld      A,C             ; Get MSB
3973+ 2DF4 B7                   or      A               ; Is it zero?
3974+ 2DF5 C2 11 2E             jp      NZ,PNORM        ; No - Do it bit at a time
3975+ 2DF8 4A                   ld      C,D             ; MSB = NMSB
3976+ 2DF9 54                   ld      D,H             ; NMSB= LSB
3977+ 2DFA 65                   ld      H,L             ; LSB = VLSB
3978+ 2DFB 6F                   ld      L,A             ; VLSB= 0
3979+ 2DFC 78                   ld      A,B             ; Get exponent
3980+ 2DFD D6 08                sub     $08             ; Count 8 bits
3981+ 2DFF FE E0                cp      -24-8           ; Was number zero?
3982+ 2E01 C2 F2 2D             jp      NZ,BNRMLP       ; No - Keep normalising
3983+ 2E04 AF           RESZER: xor     A               ; Result is zero
3984+ 2E05 32 FC 55     SAVEXP: ld      (FPEXP),A       ; Save result as zero
3985+ 2E08 C9                   ret
3986+ 2E09
3987+ 2E09 05           NORMAL: dec     B               ; Count bits
3988+ 2E0A 29                   add     HL,HL           ; Shift HL left
3989+ 2E0B 7A                   ld      A,D             ; Get NMSB
3990+ 2E0C 17                   rla                     ; Shift left with last bit
3991+ 2E0D 57                   ld      D,A             ; Save NMSB
3992+ 2E0E 79                   ld      A,C             ; Get MSB
3993+ 2E0F 8F                   adc     A,A             ; Shift left with last bit
3994+ 2E10 4F                   ld      C,A             ; Save MSB
3995+ 2E11 F2 09 2E     PNORM:  jp      P,NORMAL        ; Not done - Keep going
3996+ 2E14 78                   ld      A,B             ; Number of bits shifted
3997+ 2E15 5C                   ld      E,H             ; Save HL in EB
3998+ 2E16 45                   ld      B,L
3999+ 2E17 B7                   or      A               ; Any shifting done?
4000+ 2E18 CA 24 2E             jp      Z,RONDUP        ; No - Round it up
4001+ 2E1B 21 FC 55             ld      HL,FPEXP        ; Point to exponent
4002+ 2E1E 86                   add     A,(HL)          ; Add shifted bits
4003+ 2E1F 77                   ld      (HL),A          ; Re-save exponent
4004+ 2E20 D2 04 2E             jp      NC,RESZER       ; Underflow - Result is zero
4005+ 2E23 C8                   ret     Z               ; Result is zero
4006+ 2E24 78           RONDUP: ld      A,B             ; Get VLSB of number
4007+ 2E25 21 FC 55     RONDB:  ld      HL,FPEXP        ; Point to exponent
4008+ 2E28 B7                   or      A               ; Any rounding?
4009+ 2E29 FC 36 2E             call    M,FPROND        ; Yes - Round number up
4010+ 2E2C 46                   ld      B,(HL)          ; B = Exponent
4011+ 2E2D 23                   inc     HL
4012+ 2E2E 7E                   ld      A,(HL)          ; Get sign of result
4013+ 2E2F E6 80                and     %10000000       ; Only bit 7 needed
4014+ 2E31 A9                   xor     C               ; Set correct sign
4015+ 2E32 4F                   ld      C,A             ; Save correct sign in number
4016+ 2E33 C3 76 30             jp      FPBCDE          ; Move BCDE to FPREG
4017+ 2E36
4018+ 2E36 1C           FPROND: inc     E               ; Round LSB
4019+ 2E37 C0                   ret     NZ              ; Return if ok
4020+ 2E38 14                   inc     D               ; Round NMSB
4021+ 2E39 C0                   ret     NZ              ; Return if ok
4022+ 2E3A 0C                   inc     C               ; Round MSB
4023+ 2E3B C0                   ret     NZ              ; Return if ok
4024+ 2E3C 0E 80                ld      C,$80           ; Set normal value
4025+ 2E3E 34                   inc     (HL)            ; Increment exponent
4026+ 2E3F C0                   ret     NZ              ; Return if ok
4027+ 2E40 C3 5F 18             jp      OVERR           ; Overflow error
4028+ 2E43
4029+ 2E43 7E           PLUCDE: ld      A,(HL)          ; Get LSB of FPREG
4030+ 2E44 83                   add     A,E             ; Add LSB of BCDE
4031+ 2E45 5F                   ld      E,A             ; Save LSB of BCDE
4032+ 2E46 23                   inc     HL
4033+ 2E47 7E                   ld      A,(HL)          ; Get NMSB of FPREG
4034+ 2E48 8A                   adc     A,D             ; Add NMSB of BCDE
4035+ 2E49 57                   ld      D,A             ; Save NMSB of BCDE
4036+ 2E4A 23                   inc     HL
4037+ 2E4B 7E                   ld      A,(HL)          ; Get MSB of FPREG
4038+ 2E4C 89                   adc     A,C             ; Add MSB of BCDE
4039+ 2E4D 4F                   ld      C,A             ; Save MSB of BCDE
4040+ 2E4E C9                   ret
4041+ 2E4F
4042+ 2E4F 21 FD 55     COMPL:  ld      HL,SGNRES       ; Sign of result
4043+ 2E52 7E                   ld      A,(HL)          ; Get sign of result
4044+ 2E53 2F                   cpl                     ; Negate it
4045+ 2E54 77                   ld      (HL),A          ; Put it back
4046+ 2E55 AF                   xor     A
4047+ 2E56 6F                   ld      L,A             ; Set L to zero
4048+ 2E57 90                   sub     B               ; Negate exponent,set carry
4049+ 2E58 47                   ld      B,A             ; Re-save exponent
4050+ 2E59 7D                   ld      A,L             ; Load zero
4051+ 2E5A 9B                   sbc     A,E             ; Negate LSB
4052+ 2E5B 5F                   ld      E,A             ; Re-save LSB
4053+ 2E5C 7D                   ld      A,L             ; Load zero
4054+ 2E5D 9A                   sbc     A,D             ; Negate NMSB
4055+ 2E5E 57                   ld      D,A             ; Re-save NMSB
4056+ 2E5F 7D                   ld      A,L             ; Load zero
4057+ 2E60 99                   sbc     A,C             ; Negate MSB
4058+ 2E61 4F                   ld      C,A             ; Re-save MSB
4059+ 2E62 C9                   ret
4060+ 2E63
4061+ 2E63 06 00        SCALE:  ld      B,$00           ; Clear underflow
4062+ 2E65 D6 08        SCALLP: sub     $08             ; 8 bits (a whole byte)?
4063+ 2E67 DA 72 2E             jp      C,SHRITE        ; No - Shift right A bits
4064+ 2E6A 43                   ld      B,E             ; <- Shift
4065+ 2E6B 5A                   ld      E,D             ; <- right
4066+ 2E6C 51                   ld      D,C             ; <- eight
4067+ 2E6D 0E 00                ld      C,$00           ; <- bits
4068+ 2E6F C3 65 2E             jp      SCALLP          ; More bits to shift
4069+ 2E72
4070+ 2E72 C6 09        SHRITE: add     A,8+1           ; Adjust count
4071+ 2E74 6F                   ld      L,A             ; Save bits to shift
4072+ 2E75 AF           SHRLP:  xor     A               ; Flag for all done
4073+ 2E76 2D                   dec     L               ; All shifting done?
4074+ 2E77 C8                   ret     Z               ; Yes - Return
4075+ 2E78 79                   ld      A,C             ; Get MSB
4076+ 2E79 1F           SHRT1:  rra                     ; Shift it right
4077+ 2E7A 4F                   ld      C,A             ; Re-save
4078+ 2E7B 7A                   ld      A,D             ; Get NMSB
4079+ 2E7C 1F                   rra                     ; Shift right with last bit
4080+ 2E7D 57                   ld      D,A             ; Re-save it
4081+ 2E7E 7B                   ld      A,E             ; Get LSB
4082+ 2E7F 1F                   rra                     ; Shift right with last bit
4083+ 2E80 5F                   ld      E,A             ; Re-save it
4084+ 2E81 78                   ld      A,B             ; Get underflow
4085+ 2E82 1F                   rra                     ; Shift right with last bit
4086+ 2E83 47                   ld      B,A             ; Re-save underflow
4087+ 2E84 C3 75 2E             jp      SHRLP           ; More bits to do
4088+ 2E87
4089+ 2E87 00 00 00 81  UNITY:  defb    $00,$00,$00,$81 ; 1.00000
4090+ 2E8B
4091+ 2E8B 03           LOGTAB: defb    $03             ; Table used by LOG
4092+ 2E8C AA 56 19 80          defb    $AA,$56,$19,$80 ; 0.59898
4093+ 2E90 F1 22 76 80          defb    $F1,$22,$76,$80 ; 0.96147
4094+ 2E94 45 AA 38 82          defb    $45,$AA,$38,$82 ; 2.88539
4095+ 2E98
4096+ 2E98 CD 35 30     LOG:    call    TSTSGN          ; Test sign of value
4097+ 2E9B B7                   or      A
4098+ 2E9C EA 62 1E             jp      PE,FCERR        ; ?FC Error if <= zero
4099+ 2E9F 21 FC 55             ld      HL,FPEXP        ; Point to exponent
4100+ 2EA2 7E                   ld      A,(HL)          ; Get exponent
4101+ 2EA3 01 35 80             ld      BC,$8035        ; BCDE = SQR(1/2)
4102+ 2EA6 11 F3 04             ld      DE,$04F3
4103+ 2EA9 90                   sub     B               ; Scale value to be < 1
4104+ 2EAA F5                   push    AF              ; Save scale factor
4105+ 2EAB 70                   ld      (HL),B          ; Save new exponent
4106+ 2EAC D5                   push    DE              ; Save SQR(1/2)
4107+ 2EAD C5                   push    BC
4108+ 2EAE CD 9E 2D             call    FPADD           ; Add SQR(1/2) to value
4109+ 2EB1 C1                   pop     BC              ; Restore SQR(1/2)
4110+ 2EB2 D1                   pop     DE
4111+ 2EB3 04                   inc     B               ; Make it SQR(2)
4112+ 2EB4 CD 8B 2F             call    DVBCDE          ; Divide by SQR(2)
4113+ 2EB7 21 87 2E             ld      HL,UNITY        ; Point to 1.
4114+ 2EBA CD 95 2D             call    SUBPHL          ; Subtract FPREG from 1
4115+ 2EBD 21 8B 2E             ld      HL,LOGTAB       ; Coefficient table
4116+ 2EC0 CD 7D 33             call    SUMSER          ; Evaluate sum of series
4117+ 2EC3 01 80 80             ld      BC,$8080        ; BCDE = -0.5
4118+ 2EC6 11 00 00             ld      DE,$0000
4119+ 2EC9 CD 9E 2D             call    FPADD           ; Subtract 0.5 from FPREG
4120+ 2ECC F1                   pop     AF              ; Restore scale factor
4121+ 2ECD CD B0 31             call    RSCALE          ; Re-scale number
4122+ 2ED0 01 31 80     MULLN2: ld      BC,$8031        ; BCDE = Ln(2)
4123+ 2ED3 11 18 72             ld      DE,$7218
4124+ 2ED6 21                   defb    $21             ; Skip "pop BC" and "pop DE"
4125+ 2ED7
4126+ 2ED7 C1           MULT:   pop     BC              ; Get number from stack
4127+ 2ED8 D1                   pop     DE
4128+ 2ED9 CD 35 30     FPMULT: call    TSTSGN          ; Test sign of FPREG
4129+ 2EDC C8                   ret     Z               ; Return zero if zero
4130+ 2EDD 2E 00                ld      L,$00           ; Flag add exponents
4131+ 2EDF CD F3 2F             call    ADDEXP          ; Add exponents
4132+ 2EE2 79                   ld      A,C             ; Get MSB of multiplier
4133+ 2EE3 32 0B 56             ld      (MULVAL),A      ; Save MSB of multiplier
4134+ 2EE6 EB                   ex      DE,HL
4135+ 2EE7 22 0C 56             ld      (MULVAL+1),HL   ; Save rest of multiplier
4136+ 2EEA 01 00 00             ld      BC,$0000        ; Partial product (BCDE) = zero
4137+ 2EED 50                   ld      D,B
4138+ 2EEE 58                   ld      E,B
4139+ 2EEF 21 EF 2D             ld      HL,BNORM        ; Address of normalise
4140+ 2EF2 E5                   push    HL              ; Save for return
4141+ 2EF3 21 FB 2E             ld      HL,MULT8        ; Address of 8 bit multiply
4142+ 2EF6 E5                   push    HL              ; Save for NMSB,MSB
4143+ 2EF7 E5                   push    HL              ;
4144+ 2EF8 21 F9 55             ld      HL,FPREG        ; Point to number
4145+ 2EFB 7E           MULT8:  ld      A,(HL)          ; Get LSB of number
4146+ 2EFC 23                   inc     HL              ; Point to NMSB
4147+ 2EFD B7                   or      A               ; Test LSB
4148+ 2EFE CA 27 2F             jp      Z,BYTSFT        ; Zero - shift to next byte
4149+ 2F01 E5                   push    HL              ; Save address of number
4150+ 2F02 2E 08                ld      L,$08           ; 8 bits to multiply by
4151+ 2F04 1F           MUL8LP: rra                     ; Shift LSB right
4152+ 2F05 67                   ld      H,A             ; Save LSB
4153+ 2F06 79                   ld      A,C             ; Get MSB
4154+ 2F07 D2 15 2F             jp      NC,NOMADD       ; Bit was zero - Don't add
4155+ 2F0A E5                   push    HL              ; Save LSB and count
4156+ 2F0B 2A 0C 56             ld      HL,(MULVAL+1)   ; Get LSB and NMSB
4157+ 2F0E 19                   add     HL,DE           ; Add NMSB and LSB
4158+ 2F0F EB                   ex      DE,HL           ; Leave sum in DE
4159+ 2F10 E1                   pop     HL              ; Restore MSB and count
4160+ 2F11 3A 0B 56             ld      A,(MULVAL)      ; Get MSB of multiplier
4161+ 2F14 89                   adc     A,C             ; Add MSB
4162+ 2F15 1F           NOMADD: rra                     ; Shift MSB right
4163+ 2F16 4F                   ld      C,A             ; Re-save MSB
4164+ 2F17 7A                   ld      A,D             ; Get NMSB
4165+ 2F18 1F                   rra                     ; Shift NMSB right
4166+ 2F19 57                   ld      D,A             ; Re-save NMSB
4167+ 2F1A 7B                   ld      A,E             ; Get LSB
4168+ 2F1B 1F                   rra                     ; Shift LSB right
4169+ 2F1C 5F                   ld      E,A             ; Re-save LSB
4170+ 2F1D 78                   ld      A,B             ; Get VLSB
4171+ 2F1E 1F                   rra                     ; Shift VLSB right
4172+ 2F1F 47                   ld      B,A             ; Re-save VLSB
4173+ 2F20 2D                   dec     L               ; Count bits multiplied
4174+ 2F21 7C                   ld      A,H             ; Get LSB of multiplier
4175+ 2F22 C2 04 2F             jp      NZ,MUL8LP       ; More - Do it
4176+ 2F25 E1           POPHRT: pop     HL              ; Restore address of number
4177+ 2F26 C9                   ret
4178+ 2F27
4179+ 2F27 43           BYTSFT: ld      B,E             ; Shift partial product left
4180+ 2F28 5A                   ld      E,D
4181+ 2F29 51                   ld      D,C
4182+ 2F2A 4F                   ld      C,A
4183+ 2F2B C9                   ret
4184+ 2F2C
4185+ 2F2C
4186+ 2F2C              ; WORKING ââ
4187+ 2F2C C1           DINT:   pop     BC              ; Get number from stack
4188+ 2F2D D1                   pop     DE
4189+ 2F2E CD 8B 2F             call    DVBCDE          ; get BCDE/FPREG and store result into FPREG
4190+ 2F31 C3 08 31             jp      INT             ; return INT(FPREG)
4191+ 2F34
4192+ 2F34
4193+ 2F34              ; A MODULO B - return remainder of the integer division A/B where:
4194+ 2F34              ; A is in stack; B is in FPREG
4195+ 2F34              ; math is:
4196+ 2F34              ; A=INT(A); B=INT(B); R=A-(B*INT(A/B))
4197+ 2F34 CD 08 31     MOD:    call    INT             ; B=INT(B)
4198+ 2F37 CD 81 30             call    BCDEFP          ; copy B (from FPREG) into BCDE
4199+ 2F3A ED 53 A9 55          ld      (TMPBFR3),DE    ; store B into...
4200+ 2F3E ED 43 AB 55          ld      (TMPBFR4),BC    ; ...a temp buffer
4201+ 2F42 C1                   pop     BC              ; recover A...
4202+ 2F43 D1                   pop     DE              ; ...from stack
4203+ 2F44 CD 76 30             call    FPBCDE          ; store A into FPREG
4204+ 2F47 CD 08 31             call    INT             ; get integer part: A=INT(A)
4205+ 2F4A CD 81 30             call    BCDEFP          ; copy A (from FPREG) into BCDE
4206+ 2F4D ED 53 A5 55          ld      (TMPBFR1),DE    ; store A into...
4207+ 2F51 ED 43 A7 55          ld      (TMPBFR2),BC    ; ...a temp buffer
4208+ 2F55                                              ; begin calculation
4209+ 2F55 2A A9 55             ld      HL,(TMPBFR3)    ; move B...
4210+ 2F58 22 F9 55             ld      (FPREG),HL      ; ...from...
4211+ 2F5B 2A AB 55             ld      HL,(TMPBFR4)    ; ...temp buffer...
4212+ 2F5E 22 FB 55             ld      (FPREG+2),HL    ; ...into FPREG
4213+ 2F61 CD 8B 2F             call    DVBCDE          ; compute A/B and store into FPREG
4214+ 2F64 CD 08 31             call    INT             ; get integer part of result: now FPREG = INT(A/B)
4215+ 2F67 ED 5B A9 55          ld      DE,(TMPBFR3)    ; load B...
4216+ 2F6B ED 4B AB 55          ld      BC,(TMPBFR4)    ; ...into BCDE
4217+ 2F6F CD D9 2E             call    FPMULT          ; get B*INT(A/B) and store into FPREG
4218+ 2F72 ED 5B A5 55          ld      DE,(TMPBFR1)    ; retrieve A from...
4219+ 2F76 ED 4B A7 55          ld      BC,(TMPBFR2)    ; ...temp buffer
4220+ 2F7A C3 9B 2D             jp      SUBCDE          ; return result of A-(B*INT(A/B))
4221+ 2F7D
4222+ 2F7D
4223+ 2F7D CD 66 30     DIV10:  call    STAKFP          ; Save FPREG on stack
4224+ 2F80 01 20 84             ld      BC,$8420        ; BCDE = 10.
4225+ 2F83 11 00 00             ld      DE,$0000
4226+ 2F86 CD 76 30             call    FPBCDE          ; Move 10 to FPREG
4227+ 2F89
4228+ 2F89 C1           DIV:    pop     BC              ; Get number from stack
4229+ 2F8A D1                   pop     DE
4230+ 2F8B CD 35 30     DVBCDE: call    TSTSGN          ; Test sign of FPREG
4231+ 2F8E CA 53 18             jp      Z,DZERR         ; Error if division by zero
4232+ 2F91 2E FF                ld      L,-1            ; Flag subtract exponents
4233+ 2F93 CD F3 2F             call    ADDEXP          ; Subtract exponents
4234+ 2F96 34                   inc     (HL)            ; Add 2 to exponent to adjust
4235+ 2F97 34                   inc     (HL)
4236+ 2F98 2B                   dec     HL              ; Point to MSB
4237+ 2F99 7E                   ld      A,(HL)          ; Get MSB of dividend
4238+ 2F9A 32 16 54             ld      (DIV3),A        ; Save for subtraction
4239+ 2F9D 2B                   dec     HL
4240+ 2F9E 7E                   ld      A,(HL)          ; Get NMSB of dividend
4241+ 2F9F 32 12 54             ld      (DIV2),A        ; Save for subtraction
4242+ 2FA2 2B                   dec     HL
4243+ 2FA3 7E                   ld      A,(HL)          ; Get MSB of dividend
4244+ 2FA4 32 0E 54             ld      (DIV1),A        ; Save for subtraction
4245+ 2FA7 41                   ld      B,C             ; Get MSB
4246+ 2FA8 EB                   ex      DE,HL           ; NMSB,LSB to HL
4247+ 2FA9 AF                   xor     A
4248+ 2FAA 4F                   ld      C,A             ; Clear MSB of quotient
4249+ 2FAB 57                   ld      D,A             ; Clear NMSB of quotient
4250+ 2FAC 5F                   ld      E,A             ; Clear LSB of quotient
4251+ 2FAD 32 19 54             ld      (DIV4),A        ; Clear overflow count
4252+ 2FB0 E5           DIVLP:  push    HL              ; Save divisor
4253+ 2FB1 C5                   push    BC
4254+ 2FB2 7D                   ld      A,L             ; Get LSB of number
4255+ 2FB3 CD 0D 54             call    DIVSUP          ; Subt' divisor from dividend
4256+ 2FB6 DE 00                sbc     A,$00           ; Count for overflows
4257+ 2FB8 3F                   ccf
4258+ 2FB9 D2 C3 2F             jp      NC,RESDIV       ; Restore divisor if borrow
4259+ 2FBC 32 19 54             ld      (DIV4),A        ; Re-save overflow count
4260+ 2FBF F1                   pop     AF              ; Scrap divisor
4261+ 2FC0 F1                   pop     AF
4262+ 2FC1 37                   scf                     ; Set carry to
4263+ 2FC2 D2                   defb    $D2             ; Skip "pop BC" and "pop HL"
4264+ 2FC3
4265+ 2FC3 C1           RESDIV: pop     BC              ; Restore divisor
4266+ 2FC4 E1                   pop     HL
4267+ 2FC5 79                   ld      A,C             ; Get MSB of quotient
4268+ 2FC6 3C                   inc     A
4269+ 2FC7 3D                   dec     A
4270+ 2FC8 1F                   rra                     ; Bit 0 to bit 7
4271+ 2FC9 FA 25 2E             jp      M,RONDB         ; Done - Normalise result
4272+ 2FCC 17                   rla                     ; Restore carry
4273+ 2FCD 7B                   ld      A,E             ; Get LSB of quotient
4274+ 2FCE 17                   rla                     ; Double it
4275+ 2FCF 5F                   ld      E,A             ; Put it back
4276+ 2FD0 7A                   ld      A,D             ; Get NMSB of quotient
4277+ 2FD1 17                   rla                     ; Double it
4278+ 2FD2 57                   ld      D,A             ; Put it back
4279+ 2FD3 79                   ld      A,C             ; Get MSB of quotient
4280+ 2FD4 17                   rla                     ; Double it
4281+ 2FD5 4F                   ld      C,A             ; Put it back
4282+ 2FD6 29                   add     HL,HL           ; Double NMSB,LSB of divisor
4283+ 2FD7 78                   ld      A,B             ; Get MSB of divisor
4284+ 2FD8 17                   rla                     ; Double it
4285+ 2FD9 47                   ld      B,A             ; Put it back
4286+ 2FDA 3A 19 54             ld      A,(DIV4)        ; Get VLSB of quotient
4287+ 2FDD 17                   rla                     ; Double it
4288+ 2FDE 32 19 54             ld      (DIV4),A        ; Put it back
4289+ 2FE1 79                   ld      A,C             ; Get MSB of quotient
4290+ 2FE2 B2                   or      D               ; Merge NMSB
4291+ 2FE3 B3                   or      E               ; Merge LSB
4292+ 2FE4 C2 B0 2F             jp      NZ,DIVLP        ; Not done - Keep dividing
4293+ 2FE7 E5                   push    HL              ; Save divisor
4294+ 2FE8 21 FC 55             ld      HL,FPEXP        ; Point to exponent
4295+ 2FEB 35                   dec     (HL)            ; Divide by 2
4296+ 2FEC E1                   pop     HL              ; Restore divisor
4297+ 2FED C2 B0 2F             jp      NZ,DIVLP        ; Ok - Keep going
4298+ 2FF0 C3 5F 18             jp      OVERR           ; Overflow error
4299+ 2FF3
4300+ 2FF3
4301+ 2FF3 78           ADDEXP: ld      A,B             ; Get exponent of dividend
4302+ 2FF4 B7                   or      A               ; Test it
4303+ 2FF5 CA 17 30             jp      Z,OVTST3        ; Zero - Result zero
4304+ 2FF8 7D                   ld      A,L             ; Get add/subtract flag
4305+ 2FF9 21 FC 55             ld      HL,FPEXP        ; Point to exponent
4306+ 2FFC AE                   xor     (HL)            ; Add or subtract it
4307+ 2FFD 80                   add     A,B             ; Add the other exponent
4308+ 2FFE 47                   ld      B,A             ; Save new exponent
4309+ 2FFF 1F                   rra                     ; Test exponent for overflow
4310+ 3000 A8                   xor     B
4311+ 3001 78                   ld      A,B             ; Get exponent
4312+ 3002 F2 16 30             jp      P,OVTST2        ; Positive - Test for overflow
4313+ 3005 C6 80                add     A,$80           ; Add excess 128
4314+ 3007 77                   ld      (HL),A          ; Save new exponent
4315+ 3008 CA 25 2F             jp      Z,POPHRT        ; Zero - Result zero
4316+ 300B CD 9B 30             call    SIGNS           ; Set MSBs and sign of result
4317+ 300E 77                   ld      (HL),A          ; Save new exponent
4318+ 300F 2B                   dec     HL              ; Point to MSB
4319+ 3010 C9                   ret
4320+ 3011
4321+ 3011 CD 35 30     OVTST1: call    TSTSGN          ; Test sign of FPREG
4322+ 3014 2F                   cpl                     ; Invert sign
4323+ 3015 E1                   pop     HL              ; Clean up stack
4324+ 3016 B7           OVTST2: or      A               ; Test if new exponent zero
4325+ 3017 E1           OVTST3: pop     HL              ; Clear off return address
4326+ 3018 F2 04 2E             jp      P,RESZER        ; Result zero
4327+ 301B C3 5F 18             jp      OVERR           ; Overflow error
4328+ 301E
4329+ 301E CD 81 30     MLSP10: call    BCDEFP          ; Move FPREG to BCDE
4330+ 3021 78                   ld      A,B             ; Get exponent
4331+ 3022 B7                   or      A               ; Is it zero?
4332+ 3023 C8                   ret     Z               ; Yes - Result is zero
4333+ 3024 C6 02                add     A,$02           ; Multiply by 4
4334+ 3026 DA 5F 18             jp      C,OVERR         ; Overflow - ?OV Error
4335+ 3029 47                   ld      B,A             ; Re-save exponent
4336+ 302A CD 9E 2D             call    FPADD           ; Add BCDE to FPREG (Times 5)
4337+ 302D 21 FC 55             ld      HL,FPEXP        ; Point to exponent
4338+ 3030 34                   inc     (HL)            ; Double number (Times 10)
4339+ 3031 C0                   ret     NZ              ; Ok - Return
4340+ 3032 C3 5F 18             jp      OVERR           ; Overflow error
4341+ 3035
4342+ 3035 3A FC 55     TSTSGN: ld      A,(FPEXP)       ; Get sign of FPREG
4343+ 3038 B7                   or      A
4344+ 3039 C8                   ret     Z               ; RETurn if number is zero
4345+ 303A 3A FB 55             ld      A,(FPREG+2)     ; Get MSB of FPREG
4346+ 303D FE                   defb    0FEH            ; Test sign
4347+ 303E 2F           RETREL: cpl                     ; Invert sign
4348+ 303F 17                   rla                     ; Sign bit to carry
4349+ 3040 9F           FLGDIF: sbc     A,A             ; Carry to all bits of A
4350+ 3041 C0                   ret     NZ              ; Return -1 if negative
4351+ 3042 3C                   inc     A               ; Bump to +1
4352+ 3043 C9                   ret                     ; Positive - Return +1
4353+ 3044
4354+ 3044 CD 35 30     SGN:    call    TSTSGN          ; Test sign of FPREG
4355+ 3047 06 88        FLGREL: ld      B,$80+8         ; 8 bit integer in exponent
4356+ 3049 11 00 00             ld      DE,0            ; Zero NMSB and LSB
4357+ 304C 21 FC 55     RETINT: ld      HL,FPEXP        ; Point to exponent
4358+ 304F 4F                   ld      C,A             ; CDE = MSB,NMSB and LSB
4359+ 3050 70                   ld      (HL),B          ; Save exponent
4360+ 3051 06 00                ld      B,0             ; CDE = integer to normalise
4361+ 3053 23                   inc     HL              ; Point to sign of result
4362+ 3054 36 80                ld      (HL),$80        ; Set sign of result
4363+ 3056 17                   rla                     ; Carry = sign of integer
4364+ 3057 C3 EC 2D             jp      CONPOS          ; Set sign of result
4365+ 305A
4366+ 305A CD 35 30     ABS_:   call    TSTSGN          ; Test sign of FPREG
4367+ 305D F0                   ret     P               ; Return if positive
4368+ 305E 21 FB 55     INVSGN: ld      HL,FPREG+2      ; Point to MSB
4369+ 3061 7E                   ld      A,(HL)          ; Get sign of mantissa
4370+ 3062 EE 80                xor     $80             ; Invert sign of mantissa
4371+ 3064 77                   ld      (HL),A          ; Re-save sign of mantissa
4372+ 3065 C9                   ret
4373+ 3066
4374+ 3066 EB           STAKFP: ex      DE,HL           ; Save code string address
4375+ 3067 2A F9 55             ld      HL,(FPREG)      ; LSB,NLSB of FPREG
4376+ 306A E3                   ex      (SP),HL         ; Stack them,get return
4377+ 306B E5                   push    HL              ; Re-save return
4378+ 306C 2A FB 55             ld      HL,(FPREG+2)    ; MSB and exponent of FPREG
4379+ 306F E3                   ex      (SP),HL         ; Stack them,get return
4380+ 3070 E5                   push    HL              ; Re-save return
4381+ 3071 EB                   ex      DE,HL           ; Restore code string address
4382+ 3072 C9                   ret
4383+ 3073
4384+ 3073              ; store F.P. number from BCDE into (FPREG)
4385+ 3073 CD 84 30     PHLTFP: call    LOADFP          ; Number at HL to BCDE
4386+ 3076 EB           FPBCDE: ex      DE,HL           ; Save code string address
4387+ 3077 22 F9 55             ld      (FPREG),HL      ; Save LSB,NLSB of number
4388+ 307A 60                   ld      H,B             ; Exponent of number
4389+ 307B 69                   ld      L,C             ; MSB of number
4390+ 307C 22 FB 55             ld      (FPREG+2),HL    ; Save MSB and exponent
4391+ 307F EB                   ex      DE,HL           ; Restore code string address
4392+ 3080 C9                   ret
4393+ 3081
4394+ 3081              ; load F.P. number from (FPREG) into BCDE
4395+ 3081 21 F9 55     BCDEFP: ld      HL,FPREG        ; Point to FPREG
4396+ 3084 5E           LOADFP: ld      E,(HL)          ; Get LSB of number
4397+ 3085 23                   inc     HL
4398+ 3086 56                   ld      D,(HL)          ; Get NMSB of number
4399+ 3087 23                   inc     HL
4400+ 3088 4E                   ld      C,(HL)          ; Get MSB of number
4401+ 3089 23                   inc     HL
4402+ 308A 46                   ld      B,(HL)          ; Get exponent of number
4403+ 308B 23           INCHL:  inc     HL              ; Used for conditional "inc HL"
4404+ 308C C9                   ret
4405+ 308D
4406+ 308D              ; move floating point from (FPREG) into (HL)
4407+ 308D 11 F9 55     FPTHL:  ld      DE,FPREG        ; Point to FPREG
4408+ 3090 06 04        DETHL4: ld      B,$04           ; 4 bytes to move
4409+ 3092 1A           DETHLB: ld      A,(DE)          ; Get source
4410+ 3093 77                   ld      (HL),A          ; Save destination
4411+ 3094 13                   inc     DE              ; Next source
4412+ 3095 23                   inc     HL              ; Next destination
4413+ 3096 05                   dec     B               ; Count bytes
4414+ 3097 C2 92 30             jp      NZ,DETHLB       ; Loop if more
4415+ 309A C9                   ret
4416+ 309B
4417+ 309B 21 FB 55     SIGNS:  ld      HL,FPREG+2      ; Point to MSB of FPREG
4418+ 309E 7E                   ld      A,(HL)          ; Get MSB
4419+ 309F 07                   rlca                    ; Old sign to carry
4420+ 30A0 37                   scf                     ; Set MSBit
4421+ 30A1 1F                   rra                     ; Set MSBit of MSB
4422+ 30A2 77                   ld      (HL),A          ; Save new MSB
4423+ 30A3 3F                   ccf                     ; Complement sign
4424+ 30A4 1F                   rra                     ; Old sign to carry
4425+ 30A5 23                   inc     HL
4426+ 30A6 23                   inc     HL
4427+ 30A7 77                   ld      (HL),A          ; Set sign of result
4428+ 30A8 79                   ld      A,C             ; Get MSB
4429+ 30A9 07                   rlca                    ; Old sign to carry
4430+ 30AA 37                   scf                     ; Set MSBit
4431+ 30AB 1F                   rra                     ; Set MSBit of MSB
4432+ 30AC 4F                   ld      C,A             ; Save MSB
4433+ 30AD 1F                   rra
4434+ 30AE AE                   xor     (HL)            ; New sign of result
4435+ 30AF C9                   ret
4436+ 30B0
4437+ 30B0 78           CMPNUM: ld      A,B             ; Get exponent of number
4438+ 30B1 B7                   or      A
4439+ 30B2 CA 35 30             jp      Z,TSTSGN        ; Zero - Test sign of FPREG
4440+ 30B5 21 3E 30             ld      HL,RETREL       ; Return relation routine
4441+ 30B8 E5                   push    HL              ; Save for return
4442+ 30B9 CD 35 30             call    TSTSGN          ; Test sign of FPREG
4443+ 30BC 79                   ld      A,C             ; Get MSB of number
4444+ 30BD C8                   ret     Z               ; FPREG zero - Number's MSB
4445+ 30BE 21 FB 55             ld      HL,FPREG+2      ; MSB of FPREG
4446+ 30C1 AE                   xor     (HL)            ; Combine signs
4447+ 30C2 79                   ld      A,C             ; Get MSB of number
4448+ 30C3 F8                   ret     M               ; Exit if signs different
4449+ 30C4 CD CA 30             call    CMPFP           ; Compare FP numbers
4450+ 30C7 1F                   rra                     ; Get carry to sign
4451+ 30C8 A9                   xor     C               ; Combine with MSB of number
4452+ 30C9 C9                   ret
4453+ 30CA
4454+ 30CA 23           CMPFP:  inc     HL              ; Point to exponent
4455+ 30CB 78                   ld      A,B             ; Get exponent
4456+ 30CC BE                   cp      (HL)            ; Compare exponents
4457+ 30CD C0                   ret     NZ              ; Different
4458+ 30CE 2B                   dec     HL              ; Point to MBS
4459+ 30CF 79                   ld      A,C             ; Get MSB
4460+ 30D0 BE                   cp      (HL)            ; Compare MSBs
4461+ 30D1 C0                   ret     NZ              ; Different
4462+ 30D2 2B                   dec     HL              ; Point to NMSB
4463+ 30D3 7A                   ld      A,D             ; Get NMSB
4464+ 30D4 BE                   cp      (HL)            ; Compare NMSBs
4465+ 30D5 C0                   ret     NZ              ; Different
4466+ 30D6 2B                   dec     HL              ; Point to LSB
4467+ 30D7 7B                   ld      A,E             ; Get LSB
4468+ 30D8 96                   sub     (HL)            ; Compare LSBs
4469+ 30D9 C0                   ret     NZ              ; Different
4470+ 30DA E1                   pop     HL              ; Drop RETurn
4471+ 30DB E1                   pop     HL              ; Drop another RETurn
4472+ 30DC C9                   ret
4473+ 30DD
4474+ 30DD 47           FPINT:  ld      B,A             ; <- Move
4475+ 30DE 4F                   ld      C,A             ; <- exponent
4476+ 30DF 57                   ld      D,A             ; <- to all
4477+ 30E0 5F                   ld      E,A             ; <- bits
4478+ 30E1 B7                   or      A               ; Test exponent
4479+ 30E2 C8                   ret     Z               ; Zero - Return zero
4480+ 30E3 E5                   push    HL              ; Save pointer to number
4481+ 30E4 CD 81 30             call    BCDEFP          ; Move FPREG to BCDE
4482+ 30E7 CD 9B 30             call    SIGNS           ; Set MSBs & sign of result
4483+ 30EA AE                   xor     (HL)            ; Combine with sign of FPREG
4484+ 30EB 67                   ld      H,A             ; Save combined signs
4485+ 30EC FC 01 31             call    M,DCBCDE        ; Negative - Decrement BCDE
4486+ 30EF 3E 98                ld      A,$80+24        ; 24 bits
4487+ 30F1 90                   sub     B               ; Bits to shift
4488+ 30F2 CD 63 2E             call    SCALE           ; Shift BCDE
4489+ 30F5 7C                   ld      A,H             ; Get combined sign
4490+ 30F6 17                   rla                     ; Sign to carry
4491+ 30F7 DC 36 2E             call    C,FPROND        ; Negative - Round number up
4492+ 30FA 06 00                ld      B,$00           ; Zero exponent
4493+ 30FC DC 4F 2E             call    C,COMPL         ; If negative make positive
4494+ 30FF E1                   pop     HL              ; Restore pointer to number
4495+ 3100 C9                   ret
4496+ 3101
4497+ 3101 1B           DCBCDE: dec     DE              ; Decrement BCDE
4498+ 3102 7A                   ld      A,D             ; Test LSBs
4499+ 3103 A3                   and     E
4500+ 3104 3C                   inc     A
4501+ 3105 C0                   ret     NZ              ; Exit if LSBs not FFFF
4502+ 3106 0B                   dec     BC              ; Decrement MSBs
4503+ 3107 C9                   ret
4504+ 3108
4505+ 3108 21 FC 55     INT:    ld      HL,FPEXP        ; Point to exponent
4506+ 310B 7E                   ld      A,(HL)          ; Get exponent
4507+ 310C FE 98                cp      $80+24          ; Integer accuracy only?
4508+ 310E 3A F9 55             ld      A,(FPREG)       ; Get LSB
4509+ 3111 D0                   ret     NC              ; Yes - Already integer
4510+ 3112 7E                   ld      A,(HL)          ; Get exponent
4511+ 3113 CD DD 30             call    FPINT           ; F.P to integer
4512+ 3116 36 98                ld      (HL),$80+24     ; Save 24 bit integer
4513+ 3118 7B                   ld      A,E             ; Get LSB of number
4514+ 3119 F5                   push    AF              ; Save LSB
4515+ 311A 79                   ld      A,C             ; Get MSB of number
4516+ 311B 17                   rla                     ; Sign to carry
4517+ 311C CD EC 2D             call    CONPOS          ; Set sign of result
4518+ 311F F1                   pop     AF              ; Restore LSB of number
4519+ 3120 C9                   ret
4520+ 3121
4521+ 3121 21 00 00     MLDEBC: ld      HL,$0000        ; Clear partial product
4522+ 3124 78                   ld      A,B             ; Test multiplier
4523+ 3125 B1                   or      C
4524+ 3126 C8                   ret     Z               ; Return zero if zero
4525+ 3127 3E 10                ld      A,$10           ; 16 bits
4526+ 3129 29           MLDBLP: add     HL,HL           ; Shift P.P left
4527+ 312A DA 4F 25             jp      C,BSERR         ; ?BS Error if overflow
4528+ 312D EB                   ex      DE,HL
4529+ 312E 29                   add     HL,HL           ; Shift multiplier left
4530+ 312F EB                   ex      DE,HL
4531+ 3130 D2 37 31             jp      NC,NOMLAD       ; Bit was zero - No add
4532+ 3133 09                   add     HL,BC           ; Add multiplicand
4533+ 3134 DA 4F 25             jp      C,BSERR         ; ?BS Error if overflow
4534+ 3137 3D           NOMLAD: dec     A               ; Count bits
4535+ 3138 C2 29 31             jp      NZ,MLDBLP       ; More
4536+ 313B C9                   ret
4537+ 313C
4538+ 313C FE 2D        ASCTFP: cp      '-'             ; Negative?
4539+ 313E F5                   push    AF              ; Save it and flags
4540+ 313F CA 48 31             jp      Z,CNVNUM        ; Yes - Convert number
4541+ 3142 FE 2B                cp      '+'             ; Positive?
4542+ 3144 CA 48 31             jp      Z,CNVNUM        ; Yes - Convert number
4543+ 3147 2B                   dec     HL              ; dec 'cos GETCHR INCs
4544+ 3148 CD 04 2E     CNVNUM: call    RESZER          ; Set result to zero
4545+ 314B 47                   ld      B,A             ; Digits after point counter
4546+ 314C 57                   ld      D,A             ; Sign of exponent
4547+ 314D 5F                   ld      E,A             ; Exponent of ten
4548+ 314E 2F                   cpl
4549+ 314F 4F                   ld      C,A             ; Before or after point flag
4550+ 3150 CD 97 1D     MANLP:  call    GETCHR          ; Get next character
4551+ 3153 DA 99 31             jp      C,ADDIG         ; Digit - Add to number
4552+ 3156 FE 2E                cp      '.'
4553+ 3158 CA 74 31             jp      Z,DPOINT        ; '.' - Flag point
4554+ 315B FE 45                cp      'E'
4555+ 315D C2 78 31             jp      NZ,CONEXP       ; Not 'E' - Scale number
4556+ 3160 CD 97 1D             call    GETCHR          ; Get next character
4557+ 3163 CD 6B 23             call    SGNEXP          ; Get sign of exponent
4558+ 3166 CD 97 1D     EXPLP:  call    GETCHR          ; Get next character
4559+ 3169 DA BB 31             jp      C,EDIGIT        ; Digit - Add to exponent
4560+ 316C 14                   inc     D               ; Is sign negative?
4561+ 316D C2 78 31             jp      NZ,CONEXP       ; No - Scale number
4562+ 3170 AF                   xor     A
4563+ 3171 93                   sub     E               ; Negate exponent
4564+ 3172 5F                   ld      E,A             ; And re-save it
4565+ 3173 0C                   inc     C               ; Flag end of number
4566+ 3174 0C           DPOINT: inc     C               ; Flag point passed
4567+ 3175 CA 50 31             jp      Z,MANLP         ; Zero - Get another digit
4568+ 3178 E5           CONEXP: push    HL              ; Save code string address
4569+ 3179 7B                   ld      A,E             ; Get exponent
4570+ 317A 90                   sub     B               ; Subtract digits after point
4571+ 317B F4 91 31     SCALMI: call    P,SCALPL        ; Positive - Multiply number
4572+ 317E F2 87 31             jp      P,ENDCON        ; Positive - All done
4573+ 3181 F5                   push    AF              ; Save number of times to /10
4574+ 3182 CD 7D 2F             call    DIV10           ; Divide by 10
4575+ 3185 F1                   pop     AF              ; Restore count
4576+ 3186 3C                   inc     A               ; Count divides
4577+ 3187
4578+ 3187 C2 7B 31     ENDCON: jp      NZ,SCALMI       ; More to do
4579+ 318A D1                   pop     DE              ; Restore code string address
4580+ 318B F1                   pop     AF              ; Restore sign of number
4581+ 318C CC 5E 30             call    Z,INVSGN        ; Negative - Negate number
4582+ 318F EB                   ex      DE,HL           ; Code string address to HL
4583+ 3190 C9                   ret
4584+ 3191
4585+ 3191 C8           SCALPL: ret     Z               ; Exit if no scaling needed
4586+ 3192 F5           MULTEN: push    AF              ; Save count
4587+ 3193 CD 1E 30             call    MLSP10          ; Multiply number by 10
4588+ 3196 F1                   pop     AF              ; Restore count
4589+ 3197 3D                   dec     A               ; Count multiplies
4590+ 3198 C9                   ret
4591+ 3199
4592+ 3199 D5           ADDIG:  push    DE              ; Save sign of exponent
4593+ 319A 57                   ld      D,A             ; Save digit
4594+ 319B 78                   ld      A,B             ; Get digits after point
4595+ 319C 89                   adc     A,C             ; Add one if after point
4596+ 319D 47                   ld      B,A             ; Re-save counter
4597+ 319E C5                   push    BC              ; Save point flags
4598+ 319F E5                   push    HL              ; Save code string address
4599+ 31A0 D5                   push    DE              ; Save digit
4600+ 31A1 CD 1E 30             call    MLSP10          ; Multiply number by 10
4601+ 31A4 F1                   pop     AF              ; Restore digit
4602+ 31A5 D6 30                sub     '0'             ; Make it absolute
4603+ 31A7 CD B0 31             call    RSCALE          ; Re-scale number
4604+ 31AA E1                   pop     HL              ; Restore code string address
4605+ 31AB C1                   pop     BC              ; Restore point flags
4606+ 31AC D1                   pop     DE              ; Restore sign of exponent
4607+ 31AD C3 50 31             jp      MANLP           ; Get another digit
4608+ 31B0
4609+ 31B0 CD 66 30     RSCALE: call    STAKFP          ; Put number on stack
4610+ 31B3 CD 47 30             call    FLGREL          ; Digit to add to FPREG
4611+ 31B6 C1           PADD:   pop     BC              ; Restore number
4612+ 31B7 D1                   pop     DE
4613+ 31B8 C3 9E 2D             jp      FPADD           ; Add BCDE to FPREG and return
4614+ 31BB
4615+ 31BB 7B           EDIGIT: ld      A,E             ; Get digit
4616+ 31BC 07                   rlca                    ; Times 2
4617+ 31BD 07                   rlca                    ; Times 4
4618+ 31BE 83                   add     A,E             ; Times 5
4619+ 31BF 07                   rlca                    ; Times 10
4620+ 31C0 86                   add     A,(HL)          ; Add next digit
4621+ 31C1 D6 30                sub     '0'             ; Make it absolute
4622+ 31C3 5F                   ld      E,A             ; Save new digit
4623+ 31C4 C3 66 31             jp      EXPLP           ; Look for another digit
4624+ 31C7
4625+ 31C7 E5           LINEIN: push    HL              ; Save code string address
4626+ 31C8 21 C9 17             ld      HL,INMSG        ; Output " in "
4627+ 31CB CD 30 27             call    PRS             ; Output string at HL
4628+ 31CE E1                   pop     HL              ; Restore code string address
4629+ 31CF EB           PRNTHL: ex      DE,HL           ; Code string address to DE
4630+ 31D0 AF                   xor     A
4631+ 31D1 06 98                ld      B,$80+24        ; 24 bits
4632+ 31D3 CD 4C 30             call    RETINT          ; Return the integer
4633+ 31D6 21 2F 27             ld      HL,PRNUMS       ; Print number string
4634+ 31D9 E5                   push    HL              ; Save for return
4635+ 31DA              ; conmvert FP number into ASCII chars
4636+ 31DA 21 FE 55     NUMASC: ld      HL,PBUFF        ; Convert number to ASCII
4637+ 31DD E5                   push    HL              ; Save for return
4638+ 31DE CD 35 30             call    TSTSGN          ; Test sign of FPREG
4639+ 31E1 36 20                ld      (HL),SPC        ; Space at start
4640+ 31E3 F2 E8 31             jp      P,SPCFST        ; Positive - Space to start
4641+ 31E6 36 2D                ld      (HL),'-'        ; '-' sign at start
4642+ 31E8 23           SPCFST: inc     HL              ; First byte of number
4643+ 31E9 36 30                ld      (HL),'0'        ; '0' if zero
4644+ 31EB CA 9E 32             jp      Z,JSTZER        ; Return '0' if zero
4645+ 31EE E5                   push    HL              ; Save buffer address
4646+ 31EF FC 5E 30             call    M,INVSGN        ; Negate FPREG if negative
4647+ 31F2 AF                   xor     A               ; Zero A
4648+ 31F3 F5                   push    AF              ; Save it
4649+ 31F4 CD A4 32             call    RNGTST          ; Test number is in range
4650+ 31F7 01 43 91     SIXDIG: ld      BC,$9143        ; BCDE - 99999.9
4651+ 31FA 11 F8 4F             ld      DE,$4FF8
4652+ 31FD CD B0 30             call    CMPNUM          ; Compare numbers
4653+ 3200 B7                   or      A
4654+ 3201 E2 15 32             jp      PO,INRNG        ; > 99999.9 - Sort it out
4655+ 3204 F1                   pop     AF              ; Restore count
4656+ 3205 CD 92 31             call    MULTEN          ; Multiply by ten
4657+ 3208 F5                   push    AF              ; Re-save count
4658+ 3209 C3 F7 31             jp      SIXDIG          ; Test it again
4659+ 320C
4660+ 320C CD 7D 2F     GTSIXD: call    DIV10           ; Divide by 10
4661+ 320F F1                   pop     AF              ; Get count
4662+ 3210 3C                   inc     A               ; Count divides
4663+ 3211 F5                   push    AF              ; Re-save count
4664+ 3212 CD A4 32             call    RNGTST          ; Test number is in range
4665+ 3215 CD 8C 2D     INRNG:  call    ROUND           ; Add 0.5 to FPREG
4666+ 3218 3C                   inc     A
4667+ 3219 CD DD 30             call    FPINT           ; F.P to integer
4668+ 321C CD 76 30             call    FPBCDE          ; Move BCDE to FPREG
4669+ 321F 01 06 03             ld      BC,$0306        ; 1E+06 to 1E-03 range
4670+ 3222 F1                   pop     AF              ; Restore count
4671+ 3223 81                   add     A,C             ; 6 digits before point
4672+ 3224 3C                   inc     A               ; Add one
4673+ 3225 FA 31 32             jp      M,MAKNUM        ; Do it in 'E' form if < 1E-02
4674+ 3228 FE 08                cp      6+1+1           ; More than 999999 ?
4675+ 322A D2 31 32             jp      NC,MAKNUM       ; Yes - Do it in 'E' form
4676+ 322D 3C                   inc     A               ; Adjust for exponent
4677+ 322E 47                   ld      B,A             ; Exponent of number
4678+ 322F 3E 02                ld      A,2             ; Make it zero after
4679+ 3231
4680+ 3231 3D           MAKNUM: dec     A               ; Adjust for digits to do
4681+ 3232 3D                   dec     A
4682+ 3233 E1                   pop     HL              ; Restore buffer address
4683+ 3234 F5                   push    AF              ; Save count
4684+ 3235 11 B7 32             ld      DE,POWERS       ; Powers of ten
4685+ 3238 05                   dec     B               ; Count digits before point
4686+ 3239 C2 42 32             jp      NZ,DIGTXT       ; Not zero - Do number
4687+ 323C 36 2E                ld      (HL),'.'        ; Save point
4688+ 323E 23                   inc     HL              ; Move on
4689+ 323F 36 30                ld      (HL),'0'        ; Save zero
4690+ 3241 23                   inc     HL              ; Move on
4691+ 3242 05           DIGTXT: dec     B               ; Count digits before point
4692+ 3243 36 2E                ld      (HL),'.'        ; Save point in case
4693+ 3245 CC 8B 30             call    Z,INCHL         ; Last digit - move on
4694+ 3248 C5                   push    BC              ; Save digits before point
4695+ 3249 E5                   push    HL              ; Save buffer address
4696+ 324A D5                   push    DE              ; Save powers of ten
4697+ 324B CD 81 30             call    BCDEFP          ; Move FPREG to BCDE
4698+ 324E E1                   pop     HL              ; Powers of ten table
4699+ 324F 06 2F                ld      B,'0'-1         ; ASCII '0' - 1
4700+ 3251 04           TRYAGN: inc     B               ; Count subtractions
4701+ 3252 7B                   ld      A,E             ; Get LSB
4702+ 3253 96                   sub     (HL)            ; Subtract LSB
4703+ 3254 5F                   ld      E,A             ; Save LSB
4704+ 3255 23                   inc     HL
4705+ 3256 7A                   ld      A,D             ; Get NMSB
4706+ 3257 9E                   sbc     A,(HL)          ; Subtract NMSB
4707+ 3258 57                   ld      D,A             ; Save NMSB
4708+ 3259 23                   inc     HL
4709+ 325A 79                   ld      A,C             ; Get MSB
4710+ 325B 9E                   sbc     A,(HL)          ; Subtract MSB
4711+ 325C 4F                   ld      C,A             ; Save MSB
4712+ 325D 2B                   dec     HL              ; Point back to start
4713+ 325E 2B                   dec     HL
4714+ 325F D2 51 32             jp      NC,TRYAGN       ; No overflow - Try again
4715+ 3262 CD 43 2E             call    PLUCDE          ; Restore number
4716+ 3265 23                   inc     HL              ; Start of next number
4717+ 3266 CD 76 30             call    FPBCDE          ; Move BCDE to FPREG
4718+ 3269 EB                   ex      DE,HL           ; Save point in table
4719+ 326A E1                   pop     HL              ; Restore buffer address
4720+ 326B 70                   ld      (HL),B          ; Save digit in buffer
4721+ 326C 23                   inc     HL              ; And move on
4722+ 326D C1                   pop     BC              ; Restore digit count
4723+ 326E 0D                   dec     C               ; Count digits
4724+ 326F C2 42 32             jp      NZ,DIGTXT       ; More - Do them
4725+ 3272 05                   dec     B               ; Any decimal part?
4726+ 3273 CA 82 32             jp      Z,DOEBIT        ; No - Do 'E' bit
4727+ 3276 2B           SUPTLZ: dec     HL              ; Move back through buffer
4728+ 3277 7E                   ld      A,(HL)          ; Get character
4729+ 3278 FE 30                cp      '0'             ; '0' character?
4730+ 327A CA 76 32             jp      Z,SUPTLZ        ; Yes - Look back for more
4731+ 327D FE 2E                cp      '.'             ; A decimal point?
4732+ 327F C4 8B 30             call    NZ,INCHL        ; Move back over digit
4733+ 3282
4734+ 3282 F1           DOEBIT: pop     AF              ; Get 'E' flag
4735+ 3283 CA A1 32             jp      Z,NOENED        ; No 'E' needed - End buffer
4736+ 3286 36 45                ld      (HL),'E'        ; Put 'E' in buffer
4737+ 3288 23                   inc     HL              ; And move on
4738+ 3289 36 2B                ld      (HL),'+'        ; Put '+' in buffer
4739+ 328B F2 92 32             jp      P,OUTEXP        ; Positive - Output exponent
4740+ 328E 36 2D                ld      (HL),'-'        ; Put '-' in buffer
4741+ 3290 2F                   cpl                     ; Negate exponent
4742+ 3291 3C                   inc     A
4743+ 3292 06 2F        OUTEXP: ld      B,'0'-1         ; ASCII '0' - 1
4744+ 3294 04           EXPTEN: inc     B               ; Count subtractions
4745+ 3295 D6 0A                sub     $0A             ; Tens digit
4746+ 3297 D2 94 32             jp      NC,EXPTEN       ; More to do
4747+ 329A C6 3A                add     A,'0'+10        ; Restore and make ASCII
4748+ 329C 23                   inc     HL              ; Move on
4749+ 329D 70                   ld      (HL),B          ; Save MSB of exponent
4750+ 329E 23           JSTZER: inc     HL              ;
4751+ 329F 77                   ld      (HL),A          ; Save LSB of exponent
4752+ 32A0 23                   inc     HL
4753+ 32A1 71           NOENED: ld      (HL),C          ; Mark end of buffer
4754+ 32A2 E1                   pop     HL              ; Restore code string address
4755+ 32A3 C9                   ret
4756+ 32A4
4757+ 32A4 01 74 94     RNGTST: ld      BC,$9474        ; BCDE = 999999.
4758+ 32A7 11 F7 23             ld      DE,$23F7
4759+ 32AA CD B0 30             call    CMPNUM          ; Compare numbers
4760+ 32AD B7                   or      A
4761+ 32AE E1                   pop     HL              ; Return address to HL
4762+ 32AF E2 0C 32             jp      PO,GTSIXD       ; Too big - Divide by ten
4763+ 32B2 E9                   jp      (HL)            ; Otherwise return to caller
4764+ 32B3
4765+ 32B3 00 00 00 80  HALF:   defb    $00,$00,$00,$80 ; 0.5
4766+ 32B7
4767+ 32B7 A0 86 01     POWERS: defb    $A0,$86,$01  ; 100000
4768+ 32BA 10 27 00             defb    $10,$27,$00  ;  10000
4769+ 32BD E8 03 00             defb    $E8,$03,$00  ;   1000
4770+ 32C0 64 00 00             defb    $64,$00,$00  ;    100
4771+ 32C3 0A 00 00             defb    $0A,$00,$00  ;     10
4772+ 32C6 01 00 00             defb    $01,$00,$00  ;      1
4773+ 32C9
4774+ 32C9 21 5E 30     NEGAFT: ld      HL,INVSGN       ; Negate result
4775+ 32CC E3                   ex      (SP),HL         ; To be done after caller
4776+ 32CD E9                   jp      (HL)            ; Return to caller
4777+ 32CE
4778+ 32CE CD 66 30     SQR:    call    STAKFP          ; Put value on stack
4779+ 32D1 21 B3 32             ld      HL,HALF         ; Set power to 1/2
4780+ 32D4 CD 73 30             call    PHLTFP          ; Move 1/2 to FPREG
4781+ 32D7
4782+ 32D7 C1           POWER:  pop     BC              ; Get base
4783+ 32D8 D1                   pop     DE
4784+ 32D9 CD 35 30             call    TSTSGN          ; Test sign of power
4785+ 32DC 78                   ld      A,B             ; Get exponent of base
4786+ 32DD CA 1C 33             jp      Z,EXP           ; Make result 1 if zero
4787+ 32E0 F2 E7 32             jp      P,POWER1        ; Positive base - Ok
4788+ 32E3 B7                   or      A               ; Zero to negative power?
4789+ 32E4 CA 53 18             jp      Z,DZERR         ; Yes - ?/0 Error
4790+ 32E7 B7           POWER1: or      A               ; Base zero?
4791+ 32E8 CA 05 2E             jp      Z,SAVEXP        ; Yes - Return zero
4792+ 32EB D5                   push    DE              ; Save base
4793+ 32EC C5                   push    BC
4794+ 32ED 79                   ld      A,C             ; Get MSB of base
4795+ 32EE F6 7F                or      %01111111       ; Get sign status
4796+ 32F0 CD 81 30             call    BCDEFP          ; Move power to BCDE
4797+ 32F3 F2 04 33             jp      P,POWER2        ; Positive base - Ok
4798+ 32F6 D5                   push    DE              ; Save power
4799+ 32F7 C5                   push    BC
4800+ 32F8 CD 08 31             call    INT             ; Get integer of power
4801+ 32FB C1                   pop     BC              ; Restore power
4802+ 32FC D1                   pop     DE
4803+ 32FD F5                   push    AF              ; MSB of base
4804+ 32FE CD B0 30             call    CMPNUM          ; Power an integer?
4805+ 3301 E1                   pop     HL              ; Restore MSB of base
4806+ 3302 7C                   ld      A,H             ; but don't affect flags
4807+ 3303 1F                   rra                     ; Exponent odd or even?
4808+ 3304 E1           POWER2: pop     HL              ; Restore MSB and exponent
4809+ 3305 22 FB 55             ld      (FPREG+2),HL    ; Save base in FPREG
4810+ 3308 E1                   pop     HL              ; LSBs of base
4811+ 3309 22 F9 55             ld      (FPREG),HL      ; Save in FPREG
4812+ 330C DC C9 32             call    C,NEGAFT        ; Odd power - Negate result
4813+ 330F CC 5E 30             call    Z,INVSGN        ; Negative base - Negate it
4814+ 3312 D5                   push    DE              ; Save power
4815+ 3313 C5                   push    BC
4816+ 3314 CD 98 2E             call    LOG             ; Get LOG of base
4817+ 3317 C1                   pop     BC              ; Restore power
4818+ 3318 D1                   pop     DE
4819+ 3319 CD D9 2E             call    FPMULT          ; Multiply LOG by power
4820+ 331C
4821+ 331C CD 66 30     EXP:    call    STAKFP          ; Put value on stack
4822+ 331F 01 38 81             ld      BC,$8138        ; BCDE = 1/Ln(2)
4823+ 3322 11 3B AA             ld      DE,$AA3B
4824+ 3325 CD D9 2E             call    FPMULT          ; Multiply value by 1/LN(2)
4825+ 3328 3A FC 55             ld      A,(FPEXP)       ; Get exponent
4826+ 332B FE 88                cp      $80+8           ; Is it in range?
4827+ 332D D2 11 30             jp      NC,OVTST1       ; No - Test for overflow
4828+ 3330 CD 08 31             call    INT             ; Get INT of FPREG
4829+ 3333 C6 80                add     A,$80           ; For excess 128
4830+ 3335 C6 02                add     A,$02           ; Exponent > 126?
4831+ 3337 DA 11 30             jp      C,OVTST1        ; Yes - Test for overflow
4832+ 333A F5                   push    AF              ; Save scaling factor
4833+ 333B 21 87 2E             ld      HL,UNITY        ; Point to 1.
4834+ 333E CD 8F 2D             call    ADDPHL          ; Add 1 to FPREG
4835+ 3341 CD D0 2E             call    MULLN2          ; Multiply by LN(2)
4836+ 3344 F1                   pop     AF              ; Restore scaling factor
4837+ 3345 C1                   pop     BC              ; Restore exponent
4838+ 3346 D1                   pop     DE
4839+ 3347 F5                   push    AF              ; Save scaling factor
4840+ 3348 CD 9B 2D             call    SUBCDE          ; Subtract exponent from FPREG
4841+ 334B CD 5E 30             call    INVSGN          ; Negate result
4842+ 334E 21 5C 33             ld      HL,EXPTAB       ; Coefficient table
4843+ 3351 CD 8C 33             call    SMSER1          ; Sum the series
4844+ 3354 11 00 00             ld      DE,$0000        ; Zero LSBs
4845+ 3357 C1                   pop     BC              ; Scaling factor
4846+ 3358 4A                   ld      C,D             ; Zero MSB
4847+ 3359 C3 D9 2E             jp      FPMULT          ; Scale result to correct value
4848+ 335C
4849+ 335C 08           EXPTAB: defb    $08             ; Table used by EXP
4850+ 335D 40 2E 94 74          defb    $40,$2E,$94,$74 ; -1/7! (-1/5040)
4851+ 3361 70 4F 2E 77          defb    $70,$4F,$2E,$77 ;  1/6! ( 1/720)
4852+ 3365 6E 02 88 7A          defb    $6E,$02,$88,$7A ; -1/5! (-1/120)
4853+ 3369 E6 A0 2A 7C          defb    $E6,$A0,$2A,$7C ;  1/4! ( 1/24)
4854+ 336D 50 AA AA 7E          defb    $50,$AA,$AA,$7E ; -1/3! (-1/6)
4855+ 3371 FF FF 7F 7F          defb    $FF,$FF,$7F,$7F ;  1/2! ( 1/2)
4856+ 3375 00 00 80 81          defb    $00,$00,$80,$81 ; -1/1! (-1/1)
4857+ 3379 00 00 00 81          defb    $00,$00,$00,$81 ;  1/0! ( 1/1)
4858+ 337D
4859+ 337D CD 66 30     SUMSER: call    STAKFP          ; Put FPREG on stack
4860+ 3380 11 D7 2E             ld      DE,MULT         ; Multiply by "X"
4861+ 3383 D5                   push    DE              ; To be done after
4862+ 3384 E5                   push    HL              ; Save address of table
4863+ 3385 CD 81 30             call    BCDEFP          ; Move FPREG to BCDE
4864+ 3388 CD D9 2E             call    FPMULT          ; Square the value
4865+ 338B E1                   pop     HL              ; Restore address of table
4866+ 338C CD 66 30     SMSER1: call    STAKFP          ; Put value on stack
4867+ 338F 7E                   ld      A,(HL)          ; Get number of coefficients
4868+ 3390 23                   inc     HL              ; Point to start of table
4869+ 3391 CD 73 30             call    PHLTFP          ; Move coefficient to FPREG
4870+ 3394 06                   defb    06H             ; Skip "pop AF"
4871+ 3395 F1           SUMLP:  pop     AF              ; Restore count
4872+ 3396 C1                   pop     BC              ; Restore number
4873+ 3397 D1                   pop     DE
4874+ 3398 3D                   dec     A               ; Cont coefficients
4875+ 3399 C8                   ret     Z               ; All done
4876+ 339A D5                   push    DE              ; Save number
4877+ 339B C5                   push    BC
4878+ 339C F5                   push    AF              ; Save count
4879+ 339D E5                   push    HL              ; Save address in table
4880+ 339E CD D9 2E             call    FPMULT          ; Multiply FPREG by BCDE
4881+ 33A1 E1                   pop     HL              ; Restore address in table
4882+ 33A2 CD 84 30             call    LOADFP          ; Number at HL to BCDE
4883+ 33A5 E5                   push    HL              ; Save address in table
4884+ 33A6 CD 9E 2D             call    FPADD           ; Add coefficient to FPREG
4885+ 33A9 E1                   pop     HL              ; Restore address in table
4886+ 33AA C3 95 33             jp      SUMLP           ; More coefficients
4887+ 33AD
4888+ 33AD
4889+ 33AD              ; random number generator
4890+ 33AD              ; a negative argument is used as a seed for the RNG
4891+ 33AD              ; 0 is used to repeat the last random number
4892+ 33AD              ; a positive argument generates a new random number
4893+ 33AD CD 35 30     RND:    call    TSTSGN          ; Test sign of FPREG
4894+ 33B0 21 1D 54             ld      HL,SEED+2       ; Random number seed
4895+ 33B3 FA 0E 34             jp      M,RESEED        ; Negative - Re-seed
4896+ 33B6 21 3E 54             ld      HL,LSTRND       ; Last random number
4897+ 33B9 CD 73 30             call    PHLTFP          ; Move last RND to FPREG
4898+ 33BC 21 1D 54             ld      HL,SEED+2       ; Random number seed
4899+ 33BF C8                   ret     Z               ; Return if RND(0)
4900+ 33C0 86                   add     A,(HL)          ; Add (SEED+2)
4901+ 33C1 E6 07                and     %00000111       ; 0 to 7
4902+ 33C3 06 00                ld      B,$00
4903+ 33C5 77                   ld      (HL),A          ; Re-save seed
4904+ 33C6 23                   inc     HL              ; Move to coefficient table
4905+ 33C7 87                   add     A,A             ; 4 bytes
4906+ 33C8 87                   add     A,A             ; per entry
4907+ 33C9 4F                   ld      C,A             ; BC = Offset into table
4908+ 33CA 09                   add     HL,BC           ; Point to coefficient
4909+ 33CB CD 84 30             call    LOADFP          ; Coefficient to BCDE
4910+ 33CE CD D9 2E             call    FPMULT          ; Multiply FPREG by coefficient
4911+ 33D1 3A 1C 54             ld      A,(SEED+1)      ; Get (SEED+1)
4912+ 33D4 3C                   inc     A               ; Add 1
4913+ 33D5 E6 03                and     %00000011       ; 0 to 3
4914+ 33D7 06 00                ld      B,$00
4915+ 33D9 FE 01                cp      $01             ; Is it zero?
4916+ 33DB 88                   adc     A,B             ; Yes - Make it 1
4917+ 33DC 32 1C 54             ld      (SEED+1),A      ; Re-save seed
4918+ 33DF 21 12 34             ld      HL,RNDTAB-4     ; Addition table
4919+ 33E2 87                   add     A,A             ; 4 bytes
4920+ 33E3 87                   add     A,A             ; per entry
4921+ 33E4 4F                   ld      C,A             ; BC = Offset into table
4922+ 33E5 09                   add     HL,BC           ; Point to value
4923+ 33E6 CD 8F 2D             call    ADDPHL          ; Add value to FPREG
4924+ 33E9 CD 81 30     RND1:   call    BCDEFP          ; Move FPREG to BCDE
4925+ 33EC 7B                   ld      A,E             ; Get LSB
4926+ 33ED 59                   ld      E,C             ; LSB = MSB
4927+ 33EE EE 4F                xor     %01001111       ; Fiddle around
4928+ 33F0 4F                   ld      C,A             ; New MSB
4929+ 33F1 36 80                ld      (HL),$80        ; Set exponent
4930+ 33F3 2B                   dec     HL              ; Point to MSB
4931+ 33F4 46                   ld      B,(HL)          ; Get MSB
4932+ 33F5 36 80                ld      (HL),$80        ; Make value -0.5
4933+ 33F7 21 1B 54             ld      HL,SEED         ; Random number seed
4934+ 33FA 34                   inc     (HL)            ; Count seed
4935+ 33FB 7E                   ld      A,(HL)          ; Get seed
4936+ 33FC D6 AB                sub     $AB             ; Do it modulo 171
4937+ 33FE C2 05 34             jp      NZ,RND2         ; Non-zero - Ok
4938+ 3401 77                   ld      (HL),A          ; Zero seed
4939+ 3402 0C                   inc     C               ; Fillde about
4940+ 3403 15                   dec     D               ; with the
4941+ 3404 1C                   inc     E               ; number
4942+ 3405 CD EF 2D     RND2:   call    BNORM           ; Normalise number
4943+ 3408 21 3E 54             ld      HL,LSTRND       ; Save random number
4944+ 340B C3 8D 30             jp      FPTHL           ; Move FPREG to last and return
4945+ 340E
4946+ 340E 77           RESEED: ld      (HL),A          ; Re-seed random numbers
4947+ 340F 2B                   dec     HL
4948+ 3410 77                   ld      (HL),A
4949+ 3411 2B                   dec     HL
4950+ 3412 77                   ld      (HL),A
4951+ 3413 C3 E9 33             jp      RND1            ; Return RND seed
4952+ 3416
4953+ 3416 68 B1 46 68  RNDTAB: defb    $68,$B1,$46,$68 ; Table used by RND
4954+ 341A 99 E9 92 69          defb    $99,$E9,$92,$69
4955+ 341E 10 D1 75 68          defb    $10,$D1,$75,$68
4956+ 3422
4957+ 3422              ; COS and SIN functions
4958+ 3422 21 6C 34     COS:    ld      HL,HALFPI       ; Point to PI/2
4959+ 3425 CD 8F 2D             call    ADDPHL          ; Add it to PPREG
4960+ 3428 CD 66 30     SIN:    call    STAKFP          ; Put angle on stack
4961+ 342B 01 49 83             ld      BC,$8349        ; BCDE = 2 PI
4962+ 342E 11 DB 0F             ld      DE,$0FDB
4963+ 3431 CD 76 30             call    FPBCDE          ; Move 2 PI to FPREG
4964+ 3434 C1                   pop     BC              ; Restore angle
4965+ 3435 D1                   pop     DE
4966+ 3436 CD 8B 2F             call    DVBCDE          ; Divide angle by 2 PI
4967+ 3439 CD 66 30             call    STAKFP          ; Put it on stack
4968+ 343C CD 08 31             call    INT             ; Get INT of result
4969+ 343F C1                   pop     BC              ; Restore number
4970+ 3440 D1                   pop     DE
4971+ 3441 CD 9B 2D             call    SUBCDE          ; Make it 0 <= value < 1
4972+ 3444 21 70 34             ld      HL,QUARTR       ; Point to 0.25
4973+ 3447 CD 95 2D             call    SUBPHL          ; Subtract value from 0.25
4974+ 344A CD 35 30             call    TSTSGN          ; Test sign of value
4975+ 344D 37                   scf                     ; Flag positive
4976+ 344E F2 58 34             jp      P,SIN1          ; Positive - Ok
4977+ 3451 CD 8C 2D             call    ROUND           ; Add 0.5 to value
4978+ 3454 CD 35 30             call    TSTSGN          ; Test sign of value
4979+ 3457 B7                   or      A               ; Flag negative
4980+ 3458 F5           SIN1:   push    AF              ; Save sign
4981+ 3459 F4 5E 30             call    P,INVSGN        ; Negate value if positive
4982+ 345C 21 70 34             ld      HL,QUARTR       ; Point to 0.25
4983+ 345F CD 8F 2D             call    ADDPHL          ; Add 0.25 to value
4984+ 3462 F1                   pop     AF              ; Restore sign
4985+ 3463 D4 5E 30             call    NC,INVSGN       ; Negative - Make positive
4986+ 3466 21 74 34             ld      HL,SINTAB       ; Coefficient table
4987+ 3469 C3 7D 33             jp      SUMSER          ; Evaluate sum of series
4988+ 346C
4989+ 346C DB 0F 49 81  HALFPI: defb    $DB,$0F,$49,$81 ; 1.5708 (PI/2)
4990+ 3470
4991+ 3470 00 00 00 7F  QUARTR: defb    $00,$00,$00,$7F ; 0.25
4992+ 3474
4993+ 3474 05           SINTAB: defb    $05             ; Table used by SIN
4994+ 3475 BA D7 1E 86          defb    $BA,$D7,$1E,$86 ; 39.711
4995+ 3479 64 26 99 87          defb    $64,$26,$99,$87 ;-76.575
4996+ 347D 58 34 23 87          defb    $58,$34,$23,$87 ; 81.602
4997+ 3481 E0 5D A5 86          defb    $E0,$5D,$A5,$86 ;-41.342
4998+ 3485 DA 0F 49 83          defb    $DA,$0F,$49,$83 ;  6.2832
4999+ 3489
5000+ 3489 CD 66 30     TAN:    call    STAKFP          ; Put angle on stack
5001+ 348C CD 28 34             call    SIN             ; Get SIN of angle
5002+ 348F C1                   pop     BC              ; Restore angle
5003+ 3490 E1                   pop     HL
5004+ 3491 CD 66 30             call    STAKFP          ; Save SIN of angle
5005+ 3494 EB                   ex      DE,HL           ; BCDE = Angle
5006+ 3495 CD 76 30             call    FPBCDE          ; Angle to FPREG
5007+ 3498 CD 22 34             call    COS             ; Get COS of angle
5008+ 349B C3 89 2F             jp      DIV             ; TAN = SIN / COS
5009+ 349E
5010+ 349E CD 35 30     ATN:    call    TSTSGN          ; Test sign of value
5011+ 34A1 FC C9 32             call    M,NEGAFT        ; Negate result after if -ve
5012+ 34A4 FC 5E 30             call    M,INVSGN        ; Negate value if -ve
5013+ 34A7 3A FC 55             ld      A,(FPEXP)       ; Get exponent
5014+ 34AA FE 81                cp      81H             ; Number less than 1?
5015+ 34AC DA BB 34             jp      C,ATN1          ; Yes - Get arc tangnt
5016+ 34AF 01 00 81             ld      BC,$8100        ; BCDE = 1
5017+ 34B2 51                   ld      D,C
5018+ 34B3 59                   ld      E,C
5019+ 34B4 CD 8B 2F             call    DVBCDE          ; Get reciprocal of number
5020+ 34B7 21 95 2D             ld      HL,SUBPHL       ; Sub angle from PI/2
5021+ 34BA E5                   push    HL              ; Save for angle > 1
5022+ 34BB 21 C5 34     ATN1:   ld      HL,ATNTAB       ; Coefficient table
5023+ 34BE CD 7D 33             call    SUMSER          ; Evaluate sum of series
5024+ 34C1 21 6C 34             ld      HL,HALFPI       ; PI/2 - angle in case > 1
5025+ 34C4 C9                   ret                     ; Number > 1 - Sub from PI/2
5026+ 34C5
5027+ 34C5 09           ATNTAB: defb    $09             ; Table used by ATN
5028+ 34C6 4A D7 3B 78          defb    $4A,$D7,$3B,$78 ; 1/17
5029+ 34CA 02 6E 84 7B          defb    $02,$6E,$84,$7B ;-1/15
5030+ 34CE FE C1 2F 7C          defb    $FE,$C1,$2F,$7C ; 1/13
5031+ 34D2 74 31 9A 7D          defb    $74,$31,$9A,$7D ;-1/11
5032+ 34D6 84 3D 5A 7D          defb    $84,$3D,$5A,$7D ; 1/9
5033+ 34DA C8 7F 91 7E          defb    $C8,$7F,$91,$7E ;-1/7
5034+ 34DE E4 BB 4C 7E          defb    $E4,$BB,$4C,$7E ; 1/5
5035+ 34E2 6C AA AA 7F          defb    $6C,$AA,$AA,$7F ;-1/3
5036+ 34E6 00 00 00 81          defb    $00,$00,$00,$81 ; 1/1
5037+ 34EA
5038+ 34EA
5039+ 34EA D7           GETINP: rst     $10             ; input a character
5040+ 34EB C9                   ret
5041+ 34EC
5042+ 34EC E5           CLS:    push    HL
5043+ 34ED D5                   push    DE
5044+ 34EE 3A 97 55             ld      A,(SCR_MODE)    ; check screen mode
5045+ 34F1 FE 02                cp      $02             ; G2 mode?
5046+ 34F3 CC E2 05             call    Z,EMPTYVIDBUF   ; yes, reset video buffer
5047+ 34F6 D1                   pop     DE
5048+ 34F7 E1                   pop     HL
5049+ 34F8 3E 0C                ld      A,CS            ; ASCII Clear screen
5050+ 34FA CD 8C 1B             call    SND2VID         ; send to screen
5051+ 34FD C3 30 41             jp      MONOUT          ; Output character
5052+ 3500
5053+ 3500 CD AE 2A     WIDTH:  call    GETINT          ; Get integer 0-255
5054+ 3503 7B                   ld      A,E             ; Width to A
5055+ 3504 32 45 54             ld      (LWIDTH),A      ; Set width
5056+ 3507 C9                   ret
5057+ 3508
5058+ 3508
5059+ 3508              ; read a word (2 bytes) from a couple of RAM locations, in little-endian format
5060+ 3508              ; i.e., the first location is the LSB, while the second one is the MSB
5061+ 3508 CD 4D 1E     DEEK:   call    DEINT           ; Get integer -32768 to 32767
5062+ 350B D5                   push    DE              ; Save number
5063+ 350C E1                   pop     HL              ; Number to HL
5064+ 350D 46                   ld      B,(HL)          ; Get LSB of contents
5065+ 350E 23                   inc     HL
5066+ 350F 7E                   ld      A,(HL)          ; Get MSB of contents
5067+ 3510 C3 12 26             jp      ABPASS          ; Return integer AB
5068+ 3513
5069+ 3513              ; write a word (2 bytes) into a couple of RAM locations, in little-endian format
5070+ 3513              ; i.e., the LSB will go into the first location, while the MSB into the second one
5071+ 3513 CD 28 22     DOKE:   call    GETNUM          ; Get a number
5072+ 3516 CD 4D 1E             call    DEINT           ; Get integer -32768 to 32767
5073+ 3519 D5                   push    DE              ; Save address
5074+ 351A CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
5075+ 351D 2C                   defb    ','
5076+ 351E CD 28 22             call    GETNUM          ; Get a number
5077+ 3521 CD 4D 1E             call    DEINT           ; Get integer -32768 to 32767
5078+ 3524 E3                   ex      (SP),HL         ; Save value,get address
5079+ 3525 73                   ld      (HL),E          ; Save LSB of value
5080+ 3526 23                   inc     HL
5081+ 3527 72                   ld      (HL),D          ; Save MSB of value
5082+ 3528 E1                   pop     HL              ; Restore code string address
5083+ 3529 C9                   ret
5084+ 352A
5085+ 352A              ; stop the execution of code for a certain bit of time. The pause
5086+ 352A              ; is between $0000 and $FFFF 100ths of a second (0~655.5 secs)
5087+ 352A CD 28 22     PAUSE:  call    GETNUM          ; Get a number
5088+ 352D CD 4D 1E             call    DEINT           ; Get integer -32768 to 32767
5089+ 3530 7A                   ld      A,D             ; load D into A
5090+ 3531 B3                   or      E               ; are D & E equal to $00?
5091+ 3532 C8                   ret     Z               ; if yes, then return
5092+ 3533 3A 85 55             ld      A,(TMRCNT)      ; Load current value of system timer
5093+ 3536 47                   ld      B,A             ; move it into B
5094+ 3537 CD C2 1D     RPTPS:  call    TSTBRK          ; Test for break key
5095+ 353A 3A 85 55             ld      A,(TMRCNT)      ; Load current value of system timer
5096+ 353D B8                   cp      B               ; is it the same value?
5097+ 353E 28 F7                jr      Z,RPTPS         ; yes, so read again
5098+ 3540 47                   ld      B,A             ; no, so store the new value
5099+ 3541 1B                   dec     DE              ; decrement interval
5100+ 3542 7A                   ld      A,D             ; load D into A
5101+ 3543 B3                   or      E               ; check if DE is equal to 0 (if D & e are $00 then result is 0)
5102+ 3544 20 F1                jr      NZ,RPTPS        ; no, repeat
5103+ 3546 C9                   ret
5104+ 3547
5105+ 3547              ; change the screen mode and set some graphic features. Usage: SCREEN X[,Y][,Z]
5106+ 3547              ; where X is graphic mode:
5107+ 3547              ; 0=text mode (40x24), 1=graphic mode 1 (32x24 chars); 2=graphic mode 2 (256x192 pixels);
5108+ 3547              ; 3=multicolor mode (64x48 pixels); 4=extended graphic mode 2 (32x24 chars mixed between G1 and G2)
5109+ 3547              ; Y is: 0=8x8 sprites, 1=16x16 sprites
5110+ 3547              ; Z is: 0=no sprite magnification; 1=sprite magnification x2 (8x8=>16x16, and 16x16=32x32)
5111+ 3547              ; (the latters are accepted only in graphic modes G1, G2, G3, and G4)
5112+ 3547 AF           SCREEN: xor     A
5113+ 3548 32 A7 55             ld      (TMPBFR2),A     ; sprite size & magnif. byte set to 0
5114+ 354B CD AE 2A             call    GETINT          ; Get integer 0-255
5115+ 354E FE 05                cp      $05             ; is it a valid mode (0~4)?
5116+ 3550 D2 62 1E             jp      NC,FCERR        ; No - Illegal function call Error
5117+ 3553 32 A5 55             ld      (TMPBFR1),A     ; store graphic mode
5118+ 3556 A7                   and     A               ; is it 0 (text mode)?
5119+ 3557 CA 73 35             jp      Z,SCVDP         ; yes, ignore other arguments and set mode immediately
5120+ 355A CD B0 35             call    CHKSCAR         ; no, check if sprite size follows
5121+ 355D DA 65 35             jp      C,CKMAGN        ; no (set to 0 or missing), so jump over
5122+ 3560 3E 02                ld      A,$02           ; no, so set sprite size
5123+ 3562 32 A7 55             ld      (TMPBFR2),A     ; ...to 16x16
5124+ 3565 CD B0 35     CKMAGN: call    CHKSCAR         ; check if sprite magnification follows
5125+ 3568 DA 73 35             jp      C,SCVDP         ; no (set to 0 or missing), so jump over
5126+ 356B 3A A7 55             ld      A,(TMPBFR2)     ; yes, so retrieve sprite attributes...
5127+ 356E F6 01                or      $01             ; ...set sprite magnification to 2x...
5128+ 3570 32 A7 55             ld      (TMPBFR2),A     ; ...and save flags again
5129+ 3573 F3           SCVDP:  di                      ; disable INTs
5130+ 3574 E5                   push    HL              ; store HL
5131+ 3575 3A A5 55             ld      A,(TMPBFR1)     ; recover graphic mode
5132+ 3578 5F                   ld      E,A             ; and store it into E
5133+ 3579 3A A7 55             ld      A,(TMPBFR2)     ; recover sprite flags
5134+ 357C 57                   ld      D,A             ; and store them into D
5135+ 357D D5                   push    DE              ; store D & E
5136+ 357E CD D1 03             call    initVDP         ; initialize VDP with mode pointed by E
5137+ 3581 D1                   pop     DE              ; retrieve D & E
5138+ 3582 7B                   ld      A,E             ; move graphic mode into A
5139+ 3583 87                   add     A,A
5140+ 3584 87                   add     A,A
5141+ 3585 87                   add     A,A             ; multiply A times 8 to get offset of graphic mode
5142+ 3586 5F                   ld      E,A             ; and pass it into E
5143+ 3587 D5                   push    DE              ; store sprite flags in E
5144+ 3588 16 00                ld      D,$00           ; reset D
5145+ 358A 21 2A 0B             ld      HL,VDPMODESET+1 ; load address of VDP settings for reg#1
5146+ 358D 19                   add     HL,DE           ; load correct reg#1 setting
5147+ 358E D1                   pop     DE              ; retrieve sprite flags from E
5148+ 358F 7E                   ld      A,(HL)          ; load reg#1 setting
5149+ 3590 E6 FC                and     %11111100       ; reset size & magn. bits
5150+ 3592 B2                   or      D               ; set size & magn. bits
5151+ 3593 5F                   ld      E,A             ; value into E
5152+ 3594 3E 01                ld      A,$01           ; reg #1
5153+ 3596 CD BA 06             call    WRITE_VREG      ; send setting to reg #1
5154+ 3599 2A 52 54             ld      HL,(LINEAT)     ; Get current line number
5155+ 359C 23                   inc     HL              ; -1 means direct statement
5156+ 359D 7C                   ld      A,H
5157+ 359E B5                   or      L
5158+ 359F CC 2D 09             call    Z,CURSOR_ON     ; enable cursor if not in program mode
5159+ 35A2 FB                   ei                      ; re-enable interrupts
5160+ 35A3 E1                   pop     HL              ; restore HL
5161+ 35A4 3A 96 55             ld      A,(SCR_SIZE_H)  ; check the screen mode by looking at the screen height
5162+ 35A7 FE 30                cp      $30             ; is it 48 chars or 192 pixels (MC and G2 modes)?
5163+ 35A9 D0                   ret     NC              ; yes, so exit (in graphics 2 and multicolor no print-on-video)
5164+ 35AA 3E 01                ld      A,$01           ; no (we are in Text, G1 or ExG2), so activate the...
5165+ 35AC 32 A1 55             ld      (PRNTVIDEO),A   ; ...video buffer...
5166+ 35AF C9                   ret                     ; ...and return to caller
5167+ 35B0
5168+ 35B0              ; check an additional argument for SCREEN - There are 2 ways of working:
5169+ 35B0              ; to check if something follows: Carry is 1 is no argument follows, 0 otherwise
5170+ 35B0              ; to check the value of the following argument: 0 is argument is 1, 1 is argument is <> 1
5171+ 35B0 2B           CHKSCAR:dec     HL              ; dec 'cos GETCHR INCs
5172+ 35B1 CD 97 1D             call    GETCHR          ; Get next character
5173+ 35B4 37                   scf                     ; set carry flag
5174+ 35B5 C8                   ret     Z               ; return if nothing follows with Carry=1
5175+ 35B6 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
5176+ 35B9 2C                   defb    ','
5177+ 35BA CD AE 2A             call    GETINT          ; get value
5178+ 35BD 1F                   rra                     ; Carry=bit #0
5179+ 35BE 3F                   ccf                     ; invert Carry, so Carry=0 if arg. is 1, and Carry=1 otherwise (arg<>1)
5180+ 35BF C9                   ret                     ; return
5181+ 35C0
5182+ 35C0
5183+ 35C0              ; change the colors of the screen - Syntax is COLOR a,b,c where:
5184+ 35C0              ; a=foreground color / b=background color / c=border color
5185+ 35C0              ; a,b,c must be in a range between 1 and 15 (0 is transparent and it's not supported)
5186+ 35C0              ; the number of arguments is based on the current screen mode
5187+ 35C0 CD AE 2A     COLOR:  call    GETINT          ; get first value
5188+ 35C3 CD 65 36             call    CHKCLR1         ; check if it's in range 1~15
5189+ 35C6 32 A5 55             ld      (TMPBFR1),A     ; store it
5190+ 35C9 3A 97 55             ld      A,(SCR_MODE)    ; check screen mode
5191+ 35CC FE 03                cp      $03             ; is it multicolor mode?
5192+ 35CE 20 0D                jr      NZ,CNTCKCL      ; no, continue
5193+ 35D0 3E 0F                ld      A,$0F           ; white for...
5194+ 35D2 32 A3 55             ld      (FRGNDCLR),A    ; ...foreground (even it's not used in MC)
5195+ 35D5 3A A5 55             ld      A,(TMPBFR1)     ; yes, so we stop here because in MC mode we just support border color
5196+ 35D8 32 A9 55             ld      (TMPBFR3),A     ; move color into temp buffer 3
5197+ 35DB 18 30                jr      CLRMC           ; jump to set color
5198+ 35DD CD 4E 1B     CNTCKCL:call    CHKSYN          ; Make sure ',' follows
5199+ 35E0 2C                   defb    ','
5200+ 35E1 CD AE 2A             call    GETINT          ; get second value
5201+ 35E4 CD 65 36             call    CHKCLR1         ; check if it's in range 1~15
5202+ 35E7 32 A7 55             ld      (TMPBFR2),A     ; store it
5203+ 35EA 3A 97 55             ld      A,(SCR_MODE)    ; check screen mode
5204+ 35ED A7                   and     A               ; is it text mode?
5205+ 35EE 28 1A                jr      Z,CLRTXT        ; yes, stop here because in text mode, background and border colors coincide
5206+ 35F0 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
5207+ 35F3 2C                   defb    ','
5208+ 35F4 CD AE 2A             call    GETINT          ; get third value
5209+ 35F7 CD 65 36             call    CHKCLR1         ; check if it's in range 1~15
5210+ 35FA 32 A9 55             ld      (TMPBFR3),A     ; store it
5211+ 35FD 3A 97 55             ld      A,(SCR_MODE)    ; check screen mode
5212+ 3600 FE 01                cp      $01             ; is it G1 mode?
5213+ 3602 28 0F                jr      Z,CLRG1         ; yes, jump over
5214+ 3604 FE 02                cp      $02             ; is it G2 mode?
5215+ 3606 28 14                jr      Z,CLRG2         ; yes, jump over
5216+ 3608 18 1B                jr      CLREX2          ; last case can only be ExG2
5217+ 360A CD 58 36     CLRTXT: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5218+ 360D 32 A9 55     CLRMC:  ld      (TMPBFR3),A     ; store color settings (for MC mode, we only set border color)
5219+ 3610 F3                   di                      ; disable INTs
5220+ 3611 18 2D                jr      SETBRCL         ; set colors and exit
5221+ 3613 CD 58 36     CLRG1:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5222+ 3616 16 01                ld      D,$01           ; repeat 1 time
5223+ 3618 06 20                ld      B,$20           ; 32 bytes of colors
5224+ 361A 18 10                jr      LOADCLR         ; load colors
5225+ 361C CD 58 36     CLRG2:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5226+ 361F 16 18                ld      D,$18           ; 18 pages of...
5227+ 3621 06 00                ld      B,$00           ; ...256 bytes each
5228+ 3623 18 07                jr      LOADCLR         ; load colors
5229+ 3625 CD 58 36     CLREX2: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5230+ 3628 16 08                ld      D,$08           ; 8 pages of...
5231+ 362A 06 00                ld      B,$00           ; ...256 bytes each
5232+ 362C E5           LOADCLR:push    HL              ; store HL
5233+ 362D 21 00 20             ld      HL,$2000        ; color table start: $2000
5234+ 3630 F3                   di                      ; disable INTs
5235+ 3631 CD 70 06             call    SETVDPADRS
5236+ 3634 0D                   dec     C               ; VDP data mode
5237+ 3635 ED 79        RPTLDCL:out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
5238+ 3637 00                   nop
5239+ 3638 00                   nop
5240+ 3639 10 FA                djnz    RPTLDCL         ; repeat for 256 bytes (1 page)
5241+ 363B 15                   dec     D               ; did we fill up all the pages?
5242+ 363C 20 F7                jr      NZ,RPTLDCL      ; no, repeat
5243+ 363E FB                   ei
5244+ 363F E1                   pop     HL              ; retrieve HL
5245+ 3640 3A A5 55     SETBRCL:ld      A,(TMPBFR1)     ; retrieve foreground color
5246+ 3643 32 A3 55             ld      (FRGNDCLR),A    ; store it
5247+ 3646 3A A7 55             ld      A,(TMPBFR2)     ; retrieve background color
5248+ 3649 32 A4 55             ld      (BKGNDCLR),A    ; store it
5249+ 364C 3A A9 55             ld      A,(TMPBFR3)     ; recover border color
5250+ 364F 5F                   ld      E,A             ; move it into E
5251+ 3650 3E 07                ld      A,$07           ; set VDP register 7
5252+ 3652 F3                   di
5253+ 3653 CD BA 06             call    WRITE_VREG      ; send value to VDP: set border color
5254+ 3656 FB                   ei                      ; re-enable INTs
5255+ 3657 C9                   ret                     ; return to caller
5256+ 3658
5257+ 3658
5258+ 3658              ; mix 2 color nibbles in 1 byte
5259+ 3658 3A A7 55     MIXCLRS:ld      A,(TMPBFR2)     ; retrieve background color
5260+ 365B 47                   ld      B,A             ; move it into B
5261+ 365C 3A A5 55             ld      A,(TMPBFR1)     ; retrieve foreground color
5262+ 365F 87                   add     A,A             ; move foreground color into the high nibble of A
5263+ 3660 87                   add     A,A
5264+ 3661 87                   add     A,A
5265+ 3662 87                   add     A,A
5266+ 3663 B0                   or      B               ; put background color into the low nibble of A
5267+ 3664 C9                   ret                     ; return to caller
5268+ 3665
5269+ 3665
5270+ 3665              ; check if the color is not 0 and into the range 1~15
5271+ 3665 A7           CHKCLR1:and     A               ; is it 0?
5272+ 3666 CA 50 18             jp      Z,SNERR         ; yes, raise a SN error
5273+ 3669 FE 10        CHKCLR0:cp      $10             ; is it in range 0~15?
5274+ 366B D2 50 18             jp      NC,SNERR        ; no, raise a SN error
5275+ 366E C9                   ret                     ; param is OK, can return
5276+ 366F
5277+ 366F
5278+ 366F              ; check if in graphics 2 mode
5279+ 366F 3A 97 55     CHKG2M: ld      A,(SCR_MODE)    ; check screen mode
5280+ 3672 FE 02                cp      $02             ; actually, we can paint only in G2
5281+ 3674 C2 70 3C             jp      NZ,GMERR        ; no G2, print a No Graphics Mode Error
5282+ 3677 C9                   ret                     ; return to caller
5283+ 3678
5284+ 3678
5285+ 3678              ; print a text in screen 2
5286+ 3678              ; GPRINT text,x,y[,fc[,bc]]
5287+ 3678              ; where "text" is an expression that can be converted into a sequence of ASCII chars,
5288+ 3678              ; x & y are the coordinates (0<=x<=31, 0<=y<=23), fc & bc are foreground and background
5289+ 3678              ; colors (1~15), resp.
5290+ 3678              ; (portions of code are from nippur72)
5291+ 3678              GX      equ     TMPBFR3
5292+ 3678              GY      equ     TMPBFR4
5293+ 3678              TMPCLR  equ     TMPBFR2
5294+ 3678              MIXCOL  equ     TMPBFR1
5295+ 3678              TMPADR  equ     VIDEOBUFF
5296+ 3678              CHRPNT  equ     VIDEOBUFF+$02
5297+ 3678              NUMCHR  equ     VIDEOBUFF+$04
5298+ 3678              TMPHL   equ     VIDEOBUFF+$06
5299+ 3678 CD 6F 36     GPRINT: call    CHKG2M          ; check if in graphic mode 2
5300+ 367B 2B                   dec     HL              ; dec 'cos GETCHR INCs
5301+ 367C CD 97 1D             call    GETCHR          ; check if something follows
5302+ 367F CA 50 18             jp      Z,SNERR         ; if nothing else, raise a syntax error
5303+ 3682 22 AD 55             ld      (TMPADR),HL     ; save current code string pointer
5304+ 3685 CD 3A 22             call    EVAL            ; Evaluate expression
5305+ 3688 CD 2C 22             call    TSTSTR          ; Make sure it's a string
5306+ 368B 22 B3 55             ld      (TMPHL),HL      ; store code string pointer
5307+ 368E CD 73 28             call    GSTRCU          ; Current string to pool
5308+ 3691 CD 84 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
5309+ 3694 ED 43 AF 55          ld      (CHRPNT),BC     ; store string pointer
5310+ 3698 ED 53 B1 55          ld      (NUMCHR),DE     ; store string lenght
5311+ 369C 2A B3 55             ld      HL,(TMPHL)      ; restore code string pointer
5312+ 369F CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
5313+ 36A2 2C                   defb    ','
5314+ 36A3 CD AE 2A             call    GETINT          ; get X coord.
5315+ 36A6 FE 20                cp      $20             ; is it in rage 0~31?
5316+ 36A8 D2 62 1E             jp      NC,FCERR        ; Illegal function call error
5317+ 36AB 32 A9 55             ld      (GX),A          ; store into temp. buffer
5318+ 36AE CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
5319+ 36B1 2C                   defb    ','
5320+ 36B2 CD AE 2A             call    GETINT          ; get Y coord.
5321+ 36B5 FE 18                cp      $18             ; is it in range 0~23?
5322+ 36B7 D2 62 1E             jp      NC,FCERR        ; Illegal function call error
5323+ 36BA 32 AB 55             ld      (GY),A          ; store into temp. buffer
5324+ 36BD 11 A7 55             ld      DE,TMPCLR
5325+ 36C0 3A A4 55             ld      A,(BKGNDCLR)    ; load background color
5326+ 36C3 12                   ld      (DE),A          ; store into temp buff
5327+ 36C4 3A A3 55             ld      A,(FRGNDCLR)    ; load foreground color
5328+ 36C7 1B                   dec     DE
5329+ 36C8 1B                   dec     DE
5330+ 36C9 12                   ld      (DE),A          ; store into temp buff
5331+ 36CA CD 55 37             call    CKCOL           ; check color
5332+ 36CD CA D5 36             jp      Z,CNTGPT2       ; if anything follows, jump over
5333+ 36D0 13                   inc     DE
5334+ 36D1 13                   inc     DE
5335+ 36D2 CD 55 37             call    CKCOL           ; check background color
5336+ 36D5 CD 58 36     CNTGPT2:call    MIXCLRS         ; mix foreground & background colors
5337+ 36D8 32 A5 55             ld      (MIXCOL),A      ; store mixed colors
5338+ 36DB E5                   push    HL              ; store code string address
5339+ 36DC ED 4B AF 55          ld      BC,(CHRPNT)     ; retrieve string pointer
5340+ 36E0 ED 5B B1 55          ld      DE,(NUMCHR)     ; retrieve string lenght
5341+ 36E4 1C                   inc     E               ; Length + 1
5342+ 36E5 CD EA 36             call    GPNT            ; print on G2
5343+ 36E8 E1                   pop     HL              ; recover HL
5344+ 36E9 C9                   ret                     ; return to caller
5345+ 36EA D5           GPNT:   push    DE              ; store string lenght (E)
5346+ 36EB                      ; calculate VRAM address of first char
5347+ 36EB 3A A9 55             LD      A,(GX)          ; load X
5348+ 36EE 6F                   ld      L,A             ;
5349+ 36EF 26 00                ld      H,0             ; HL = X
5350+ 36F1 29                   add     HL,HL           ;
5351+ 36F2 29                   add     HL,HL           ;
5352+ 36F3 29                   add     HL,HL           ; X=X*8
5353+ 36F4 3A AB 55             ld      A,(GY)          ; load Y
5354+ 36F7 57                   ld      D,A             ; move it into D
5355+ 36F8 1E 00                ld      E,0             ; DE =Y*256
5356+ 36FA 19                   add     HL,DE           ; address = X*8 + Y*256
5357+ 36FB 22 AD 55             ld      (TMPADR),HL     ; store VRAM address of first VRAM cell
5358+ 36FE D1                   pop     DE              ; retrieve # of chars to be printed yet (E)
5359+ 36FF 1D           RPGPNT: dec     E               ; Count characters
5360+ 3700 C8                   ret     Z               ; End of string - return
5361+ 3701 D5                   push    DE              ; store chars counter
5362+ 3702                      ; calculate dest address in color vram
5363+ 3702 2A AD 55             ld      HL,(TMPADR)     ; recover VRAM address
5364+ 3705 11 00 20             ld      DE,$2000        ; color map address
5365+ 3708 19                   add     HL,DE           ; HL = $2000 + XY address
5366+ 3709 F3                   di                      ; disable INTs
5367+ 370A                      ; send color settings
5368+ 370A CD 70 06             call    SETVDPADRS      ; set VRAM address for color cell
5369+ 370D 3A A5 55             ld      A,(MIXCOL)      ; load color settings
5370+ 3710 06 08                ld      B,$08           ; repeat for 8 rows
5371+ 3712 0E 30                ld      C,VDP_DAT       ; VDP data mode
5372+ 3714 ED 79        GPNTCO1:out     (C),A           ; send data (VRAM pointer auto-increments)
5373+ 3716 00                   nop                     ; wait...
5374+ 3717 00                   nop                     ; ...a...
5375+ 3718 00                   nop                     ; ...while
5376+ 3719 10 F9                djnz    GPNTCO1         ; repeat for 8 cells
5377+ 371B                      ; calculate source address
5378+ 371B 2A AF 55             ld      HL,(CHRPNT)     ; load char pointer
5379+ 371E 7E                   ld      A,(HL)          ; get char
5380+ 371F 23                   inc     HL              ; increment char pointer
5381+ 3720 22 AF 55             ld      (CHRPNT),HL     ; store char pointer
5382+ 3723 6F                   ld      L,A             ;
5383+ 3724 26 00                ld      H,$00           ; char into HL
5384+ 3726 29                   add     HL,HL           ;
5385+ 3727 29                   add     HL,HL           ;
5386+ 3728 29                   add     HL,HL           ; get offset of char into ROM (charcode * 8)
5387+ 3729 11 97 4A             ld      DE,CHRST88      ; DE = start of 8x8 fonts in ROM
5388+ 372C 19                   add     HL,DE           ; HL = start of characters in ROM
5389+ 372D EB                   ex      DE,HL           ; store address into DE
5390+ 372E 2A AD 55             ld      HL,(TMPADR)     ; load VRAM address
5391+ 3731 CD 70 06             call    SETVDPADRS      ; send it to VDP
5392+ 3734 EB                   ex      DE,HL           ; restore address into HL
5393+ 3735 06 08                ld      B,$08           ; repeat for 8 rows
5394+ 3737 0D                   dec     C               ; VDP data mode
5395+ 3738 ED A3        GPCPCH1:outi                    ; load a byte from ROM and send to VRAM
5396+ 373A 00                   nop                     ; wait...
5397+ 373B 00                   nop                     ; ...a...
5398+ 373C 00                   nop                     ; ...while
5399+ 373D 20 F9                jr      NZ,GPCPCH1      ; repeat for 8 chars
5400+ 373F FB                   ei                      ; re-enable INTs
5401+ 3740 11 08 00             ld      DE,$0008        ; 8 bytes to go to the next video cell
5402+ 3743 2A AD 55             ld      HL,(TMPADR)     ; load VRAM address
5403+ 3746 19                   add     HL,DE           ; get address of next VRAM cell
5404+ 3747 22 AD 55             ld      (TMPADR),HL     ; store new VRAM address
5405+ 374A 11 00 18             ld      DE,$1800        ; forbidden address
5406+ 374D CD 61 41             call    CMP16           ; check if the printing has gone out of the screen
5407+ 3750 D1                   pop     DE              ; retrieve number of chars to be printed
5408+ 3751 D0                   ret     NC              ; if HL>=$1800 then leave
5409+ 3752 C3 FF 36             jp      RPGPNT          ; otherwise, check if more chars to output
5410+ 3755
5411+ 3755              ; used by GPRINT to get a color argument (if present)
5412+ 3755 2B           CKCOL:  dec     HL              ; dec 'cos GETCHR INCs
5413+ 3756 CD 97 1D             call    GETCHR          ; Get next character
5414+ 3759 C8                   ret     Z               ; return if nothing follows
5415+ 375A CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
5416+ 375D 2C                   defb    ','
5417+ 375E D5                   push    DE              ; store DE
5418+ 375F CD AE 2A             call    GETINT          ; get value
5419+ 3762 CD 65 36             call    CHKCLR1         ; check if color is in range 1~15
5420+ 3765 D1                   pop     DE              ; retrieve DE
5421+ 3766 12                   ld      (DE),A          ; store color into temp buffer
5422+ 3767 C9                   ret                     ; return to caller
5423+ 3768
5424+ 3768
5425+ 3768              ; paint X,Y[,C]: in graphics mode, fills an area starting
5426+ 3768              ; at point X,Y, using default color or, if used, with
5427+ 3768              ; color set by C
5428+ 3768              ; TMPBFR1       X
5429+ 3768              ; TMPBFR2       Y
5430+ 3768              ; TMPBFR3       COLOR
5431+ 3768              PNT     equ     VIDEOBUFF
5432+ 3768              ORGSP   equ     VIDEOBUFF+$02
5433+ 3768 CD 6F 36     PAINT:  call    CHKG2M          ; check if in graphic mode 2
5434+ 376B CD AE 2A             call    GETINT          ; get X
5435+ 376E 32 A5 55             ld      (TMPBFR1),A     ; store X
5436+ 3771 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
5437+ 3774 2C                   defb    ','
5438+ 3775 CD AE 2A             call    GETINT          ; get Y coords,
5439+ 3778 FE C0                cp      $C0             ; check if Y is in range 0~191
5440+ 377A D2 62 1E             jp      NC,FCERR        ; no, raise an FC error
5441+ 377D 32 A7 55             ld      (TMPBFR2),A     ; store Y
5442+ 3780 CD 57 3C             call    CLRPRM          ; check if color has been passed
5443+ 3783 3A A9 55             ld      A,(TMPBFR3)     ; load color
5444+ 3786 A7                   and     A               ; check if 0
5445+ 3787 CA 62 1E             jp      Z,FCERR         ; yes, raise an error
5446+ 378A E5                   push    HL              ; store HL
5447+ 378B                      ; start algorithm
5448+ 378B CD 9C 38             call    PNTRTN          ; check if pixel is already set
5449+ 378E C2 42 38             jp      NZ,EXITPA2      ; if yes, then leave PAINT
5450+ 3791 ED 73 AF 55          ld      (ORGSP),SP      ; no, store current Stack Pointer
5451+ 3795 21 01 00             ld      HL,$0001        ; HL=1
5452+ 3798 22 AD 55             ld      (PNT),HL        ; set PNT
5453+ 379B 3A A5 55             ld      A,(TMPBFR1)     ; load starting X...
5454+ 379E 47                   ld      B,A             ; ...into B
5455+ 379F 3A A7 55             ld      A,(TMPBFR2)     ; load starting Y...
5456+ 37A2 4F                   ld      C,A             ; ...into C
5457+ 37A3 C5                   push    BC              ; store starting X,Y into stack
5458+ 37A4                      ; main loop
5459+ 37A4 2A AD 55     NXTLOOP:ld      HL,(PNT)        ; retrieve PNT
5460+ 37A7 7C                   ld      A,H             ; check if PNT=0
5461+ 37A8 B5                   or      L
5462+ 37A9 CA 3E 38             jp      Z,EXITPAI       ; yes, no more points to process - exit
5463+ 37AC 2B                   dec     HL              ; no, so decrement PNT...
5464+ 37AD 22 AD 55             ld      (PNT),HL        ; ...and store it
5465+ 37B0 C1                   pop     BC              ; retrieve pixel coordinates X,Y into BC
5466+ 37B1 CD 44 38     PAINT0: call    CHECKPA         ; check if pixel is set/reset
5467+ 37B4 20 09                jr      NZ,PAINT11      ; pixel is set, so jump over
5468+ 37B6 78                   ld      A,B             ; pixel is reset, check if X1=0
5469+ 37B7 A7                   and     A               ; (reached the limit of the screen)
5470+ 37B8 CA C0 37             jp      Z,PAINT1        ; yes, jump over
5471+ 37BB 05                   dec     B               ; no, decrement X1...
5472+ 37BC C3 B1 37             jp      PAINT0          ; ...and repeat
5473+ 37BF 04           PAINT11:inc     B               ; if found a pixel on, the re-increment X1
5474+ 37C0 AF           PAINT1: xor     A               ; reset A
5475+ 37C1 57                   ld      D,A             ; set SA=0
5476+ 37C2 5F                   ld      E,A             ; set SB=0
5477+ 37C3 CD 44 38     MNPAINT:call    CHECKPA         ; check if pixel is set/reset
5478+ 37C6 20 DC                jr      NZ,NXTLOOP      ; it's set, so goto next loop
5479+ 37C8 78                   ld      A,B             ; copy X1
5480+ 37C9 32 A5 55             ld      (TMPBFR1),A     ; into buffer
5481+ 37CC 79                   ld      A,C             ; copy Y
5482+ 37CD 32 A7 55             ld      (TMPBFR2),A     ; into buffer
5483+ 37D0 CD C2 38             call    CNTPLOT         ; plot pixel X1,Y
5484+ 37D3 7A                   ld      A,D             ; load SA into A
5485+ 37D4 A7                   and     A               ; SA=0?
5486+ 37D5 20 1C                jr      NZ,PAINT2       ; no, jump over
5487+ 37D7 79                   ld      A,C             ; load Y
5488+ 37D8 FE 01                cp      $01             ; Y>0?
5489+ 37DA DA F3 37             jp      C,PAINT2        ; no, jump over
5490+ 37DD 3D                   dec     A               ; yes, Y=Y-1
5491+ 37DE CD 45 38             call    CHECKPY         ; check pixel X1,Y-1
5492+ 37E1 20 10                jr      NZ,PAINT2       ; it's set, so jump over
5493+ 37E3 0D                   dec     C               ; Y=Y-1
5494+ 37E4 C5                   push    BC              ; insert pixel(X1,Y-1) into stack
5495+ 37E5 0C                   inc     C               ; retrieve original Y
5496+ 37E6 2A AD 55             ld      HL,(PNT)        ; load PNT
5497+ 37E9 23                   inc     HL              ; increment PNT
5498+ 37EA 22 AD 55             ld      (PNT),HL        ; store new PNT
5499+ 37ED 3E 01                ld      A,$01           ; set SA=1 and...
5500+ 37EF 57                   ld      D,A             ; ...store SA into memory
5501+ 37F0 C3 06 38             jp      PAINT3          ; jump over
5502+ 37F3 7A           PAINT2: ld      A,D             ; load SA into A
5503+ 37F4 1F                   rra                     ; check if SA=1
5504+ 37F5 30 0F                jr      NC,PAINT3       ; no, jump over
5505+ 37F7 79                   ld      A,C             ; load Y
5506+ 37F8 FE 01                cp      $01             ; Y>0?
5507+ 37FA DA 06 38             jp      C,PAINT3        ; no, jump over
5508+ 37FD 3D                   dec     A               ; Y=Y-1
5509+ 37FE CD 45 38             call    CHECKPY         ; check pixel X1,Y-1
5510+ 3801 CA 06 38             jp      Z,PAINT3        ; if pixel is off, jump over
5511+ 3804 AF                   xor     A               ; pixel is on, so...
5512+ 3805 57                   ld      D,A             ; ...set SA=0
5513+ 3806 7B           PAINT3: ld      A,E             ; check if...
5514+ 3807 A7                   and     A               ; SB=0
5515+ 3808 20 1B                jr      NZ,PAINT4       ; no, jump over
5516+ 380A 79                   ld      A,C             ; load Y
5517+ 380B FE BF                cp      $BF             ; Y<191?
5518+ 380D 30 16                jr      NC,PAINT4       ; no, jump over
5519+ 380F 3C                   inc     A               ; Y=Y+1
5520+ 3810 CD 45 38             call    CHECKPY         ; check pixel X1,Y+1
5521+ 3813 20 10                jr      NZ,PAINT4       ; pixel is on, so jump over
5522+ 3815 0C                   inc     C               ; Y=Y+1
5523+ 3816 C5                   push    BC              ; insert pixel(X1,Y+1) into stack
5524+ 3817 0D                   dec     C               ; retrieve original Y
5525+ 3818 2A AD 55             ld      HL,(PNT)        ; PNT
5526+ 381B 23                   inc     HL              ; PNT=PNT+1
5527+ 381C 22 AD 55             ld      (PNT),HL        ; store PNT
5528+ 381F 3E 01                ld      A,$01           ; SB=1
5529+ 3821 5F                   ld      E,A             ; set SB
5530+ 3822 C3 37 38             jp      PAINT5          ; jump over
5531+ 3825 7B           PAINT4: ld      A,E             ; load SB
5532+ 3826 1F                   rra                     ; check if SB=1
5533+ 3827 30 0E                jr      NC,PAINT5       ; no, jump over
5534+ 3829 79                   ld      A,C             ; load Y
5535+ 382A FE BF                cp      $BF             ; Y<191?
5536+ 382C 30 09                jr      NC,PAINT5       ; no, jump over
5537+ 382E 3C                   inc     A               ; Y=Y+1
5538+ 382F CD 45 38             call    CHECKPY         ; check pixel X1,Y+1
5539+ 3832 CA 37 38             jp      Z,PAINT5        ; if pixel is off, jump over
5540+ 3835 AF                   xor     A               ; pixel is on, so...
5541+ 3836 5F                   ld      E,A             ; ...set SB=0
5542+ 3837 04           PAINT5: inc     B               ; X1=X1+1
5543+ 3838 CA A4 37             jp      Z,NXTLOOP       ; if X1>255 (X1=0) then goto next loop
5544+ 383B C3 C3 37             jp      MNPAINT         ; otherwise, repeat for next X
5545+ 383E ED 7B AF 55  EXITPAI:ld      SP,(ORGSP)      ; retrieve original SP pointer
5546+ 3842 E1           EXITPA2:pop     HL              ; retrieve HL
5547+ 3843 C9                   ret                     ; return to caller
5548+ 3844 79           CHECKPA:ld      A,C             ; copy Y into A
5549+ 3845 32 A7 55     CHECKPY:ld      (TMPBFR2),A     ; store Y
5550+ 3848 78                   ld      A,B             ; copy X1 into A
5551+ 3849 32 A5 55             ld      (TMPBFR1),A     ; store X1
5552+ 384C C5                   push    BC              ; save X1,Y
5553+ 384D D5                   push    DE
5554+ 384E CD 9C 38             call    PNTRTN          ; check if pixel is set/reset
5555+ 3851 D1                   pop     DE
5556+ 3852 C1                   pop     BC              ; retrieve X1,Y
5557+ 3853 C9                   ret                     ; return to caller
5558+ 3854
5559+ 3854
5560+ 3854              ; POINT(x,y): return if a pixel is set (returns color) or if it's reset (0)
5561+ 3854 CD 6F 36     POINT:  call    CHKG2M          ; check if in graphic mode 2
5562+ 3857 CD 4E 1B             call    CHKSYN          ; make sure "(" follows
5563+ 385A 28                   defb    '('
5564+ 385B CD AE 2A             call    GETINT          ; get X coords.
5565+ 385E 32 A5 55             ld      (TMPBFR1),A     ; store it into a temp buffer
5566+ 3861 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
5567+ 3864 2C                   defb    ','
5568+ 3865 CD AE 2A             call    GETINT          ; get Y coords,
5569+ 3868 FE C0                cp      $C0             ; check if Y is in range 0~191
5570+ 386A D2 62 1E             jp      NC,FCERR        ; no, raise an FC error
5571+ 386D 32 A7 55             ld      (TMPBFR2),A     ; store into a temp buffer
5572+ 3870 CD 4E 1B             call    CHKSYN          ; make sure ")" follows
5573+ 3873 29                   defb    ')'
5574+ 3874 E5                   push    HL              ; store current string address - the point after the ")" - ...
5575+ 3875 FD E1                pop     IY              ; ...into IY
5576+ 3877 CD 9C 38             call    PNTRTN          ; check if pixel is set or reset
5577+ 387A 20 0C                jr      NZ,CTPOINT      ; it's ON, jump over
5578+ 387C AF                   xor     A               ; no, it's OFF. make sure to reset A...
5579+ 387D 47                   ld      B,A             ; ...and B
5580+ 387E E1           PNTEND: pop     HL              ; drop original return point
5581+ 387F FD E5                push    IY              ; load current string address from IY into stack
5582+ 3881 11 13 23             ld      DE,RETNUM       ; Address of Return number from function...
5583+ 3884 D5                   push    DE              ; ...saved on stack
5584+ 3885 C3 12 26             jp      ABPASS          ; return AB
5585+ 3888 CB EC        CTPOINT:set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5586+ 388A F3                   di
5587+ 388B CD 90 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5588+ 388E FB                   ei
5589+ 388F CB 3F                srl     A               ; shift A...
5590+ 3891 CB 3F                srl     A               ; ...4 times...
5591+ 3893 CB 3F                srl     A               ; ...to move foreground color...
5592+ 3895 CB 3F                srl     A               ; ...into lowest nibble
5593+ 3897 47                   ld      B,A             ; color into B
5594+ 3898 AF                   xor     A               ; reset MSB
5595+ 3899 C3 7E 38             jp      PNTEND          ; return AB
5596+ 389C CD 0F 39     PNTRTN: call    XY2HL           ; find HL address of pixel at X,Y
5597+ 389F 57                   ld      D,A             ; store pixel index
5598+ 38A0 F3                   di                      ; disable INTs
5599+ 38A1 CD 90 06             call    READ_VIDEO_LOC  ; read contents of VRAM cell addressed by HL
5600+ 38A4 FB                   ei                      ; re-enable INTs
5601+ 38A5 A2                   and     D               ; is the pixel ON or OFF? (will be checked later)
5602+ 38A6 C9                   ret                     ; return to caller
5603+ 38A7
5604+ 38A7
5605+ 38A7              ; PLOT X,Y[,color]
5606+ 38A7              ; plot a pixel in graphic mode 2
5607+ 38A7 CD 6F 36     PLOT:   call    CHKG2M          ; check if in G2 mode
5608+ 38AA CD AE 2A             call    GETINT          ; get X coords.
5609+ 38AD 32 A5 55             ld      (TMPBFR1),A     ; store it into a temp buffer
5610+ 38B0 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
5611+ 38B3 2C                   defb    ','
5612+ 38B4 CD AE 2A             call    GETINT          ; get Y coords,
5613+ 38B7 FE C0                cp      $C0             ; check if Y is in range 0~191
5614+ 38B9 D2 62 1E             jp      NC,FCERR        ; no, raise an FC error
5615+ 38BC 32 A7 55             ld      (TMPBFR2),A     ; store into a temp buffer
5616+ 38BF CD 57 3C             call    CLRPRM          ; check if param "color" has been passed
5617+ 38C2 E5           CNTPLOT:push    HL              ; store HL ** do NOT remove these PUSHs since this
5618+ 38C3 C5                   push    BC              ; store BC ** function is called from other routines
5619+ 38C4 D5                   push    DE              ; store DE ***
5620+ 38C5 CD 0F 39             call    XY2HL           ; find VRAM address of byte containing pixel at X,Y & return into HL
5621+ 38C8 D2 03 39             jp      NC,NOGD         ; if carry is reset, there was an error -> so leave
5622+ 38CB 57                   ld      D,A             ; move pixel value into D
5623+ 38CC 3A A9 55             ld      A,(TMPBFR3)     ; retrieve color
5624+ 38CF A7                   and     A               ; is it 0? (background, or reset pixel)
5625+ 38D0 20 11                jr      NZ,CNTPLT1      ; no, continue
5626+ 38D2 F3                   di                      ; yes - so, disable INTs
5627+ 38D3 CD 90 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5628+ 38D6 FB                   ei                      ; re-enable INTs
5629+ 38D7 5F                   ld      E,A             ; store value of cell
5630+ 38D8 7A                   ld      A,D             ; retrieve pixel
5631+ 38D9 2F                   cpl                     ; revert bits
5632+ 38DA A3                   and     E               ; set video pixel to off
5633+ 38DB F3                   di                      ; disable INTs
5634+ 38DC CD A5 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5635+ 38DF FB                   ei                      ; re-enable INTs
5636+ 38E0 C3 03 39             jp      NOGD            ; leave
5637+ 38E3 87           CNTPLT1:add     A,A             ; now we move low nibble
5638+ 38E4 87                   add     A,A             ; in the high nibble
5639+ 38E5 87                   add     A,A             ; by adding A to itself
5640+ 38E6 87                   add     A,A             ; 4 times (this is a shift left 4)
5641+ 38E7 5F                   ld      E,A             ; move it into E
5642+ 38E8 F3                   di                      ; disable INTs
5643+ 38E9 CD 90 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5644+ 38EC FB                   ei
5645+ 38ED B2                   or      D               ; merge new pixel preserving original pattern
5646+ 38EE F3                   di
5647+ 38EF CD A5 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5648+ 38F2 FB                   ei
5649+ 38F3 CB EC                set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5650+ 38F5 F3                   di
5651+ 38F6 CD 90 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5652+ 38F9 FB                   ei
5653+ 38FA E6 0F                and     %00001111       ; reset high nibble (the foreground color)
5654+ 38FC B3                   or      E               ; set new foreground color
5655+ 38FD F3                   di
5656+ 38FE CD A5 06             call    WRITE_VIDEO_LOC ; write new color settings
5657+ 3901 FB                   ei                      ; re-enable INTs
5658+ 3902 00                   nop                     ; wait for INTs to be enabled again
5659+ 3903 D1           NOGD:   pop     DE              ; retrieve DE
5660+ 3904 C1                   pop     BC              ; retrieve BC
5661+ 3905 E1                   pop     HL              ; retrieve HL
5662+ 3906 C9                   ret                     ; return to caller
5663+ 3907 80 40 20 10  PXLSET: defb    $80,$40,$20,$10,$08,$04,$02,$01 ; pixel to be set ON
5663+ 390B 08 04 02 01
5664+ 390F                      ; where R(X/8)=> 0=80h, 1=40h, 2=20h, 3=10h, 4=08h, 5=04h, 6=02h, 7=$01
5665+ 390F
5666+ 390F
5667+ 390F              ; compute the VRAM address of the byte containing the pixel
5668+ 390F              ; being pointed by X,Y (TMPBFR1,TMPBFR2)
5669+ 390F              ; byte address is returned into HL
5670+ 390F              ; pixel is returned into A
5671+ 390F              XY2HL:  ; formula is: ADDRESS=(INT(X/8))*8 + (INT(Y/8))*256 + R(Y/8)
5672+ 390F                      ; where R(Y/8) is the remainder of (Y/8)
5673+ 390F                      ; the pixel to be set is given by R(X/8), and data is taken from the array
5674+ 390F 3A A7 55             ld      A,(TMPBFR2)     ; retrieve Y
5675+ 3912 FE C0                cp      $C0             ; Y>=192?
5676+ 3914 D0                   ret     NC              ; yes, so leave
5677+ 3915 1E 08                ld      E,$08           ; load E with divisor
5678+ 3917 57                   ld      D,A             ; and store into D (dividend)
5679+ 3918 CD AC 41             call    DIV_8_8         ; get Y/8, D is quotient=INT(Y/8), and A is remainder
5680+ 391B 4F                   ld      C,A             ; store remainder into C
5681+ 391C 42                   ld      B,D             ; B=(INT(Y/8))*256 (we simply copy quotient into B)
5682+ 391D 60 69                ld      HL,BC           ; copy BC into HL: now HL has the VRAM address of the byte being set
5683+ 391F 3A A5 55             ld      A,(TMPBFR1)     ; retrieve X
5684+ 3922 57                   ld      D,A             ; and move it into D (dividend)
5685+ 3923 CD AC 41             call    DIV_8_8         ; get X/8, D is quotient=INT(X/8), and A is remainder
5686+ 3926 4F                   ld      C,A             ; store remainder into C
5687+ 3927 7A                   ld      A,D             ; move quotient into A
5688+ 3928 87                   add     A,A             ; multiply quotient by 8
5689+ 3929 87                   add     A,A
5690+ 392A 87                   add     A,A
5691+ 392B 5F                   ld      E,A             ; store result into E
5692+ 392C 16 00                ld      D,$00           ; reset D
5693+ 392E 42                   ld      B,D             ; reset B
5694+ 392F 19                   add     HL,DE           ; add DE to HL, getting the final VRAM address
5695+ 3930 EB                   ex      DE,HL           ; move VRAM address into DE
5696+ 3931 21 07 39             ld      HL,PXLSET       ; starting address of table for pixel to draw
5697+ 3934 09                   add     HL,BC           ; add C (remainder of X/8) to get address of pixel to turn on
5698+ 3935 7E                   ld      A,(HL)          ; load pixel data
5699+ 3936 EB                   ex      DE,HL           ; retrieve VRAM pattern address into HL
5700+ 3937 37                   scf                     ; set Carry for normal exit
5701+ 3938 C9                   ret                     ; return to caller
5702+ 3939
5703+ 3939
5704+ 3939              ; DRAW X1,Y1,X2,Y2[,color]
5705+ 3939              ; Draw a line using Bresenham's line algorithm from X1,Y1 to X2,Y2
5706+ 3939              ; X1,Y1 can be either less than or greater than X2,Y2 (meaning that)
5707+ 3939              ; the drawing will be ever done from X1,Y2 to X2,Y2, regardless of
5708+ 3939              ; the values. If color is not specified, the foreground color set
5709+ 3939              ; with COLOR will be used
5710+ 3939              X1      equ     TMPBFR1
5711+ 3939              Y1      equ     TMPBFR2
5712+ 3939              X2      equ     VIDEOBUFF
5713+ 3939              Y2      equ     VIDEOBUFF+$02
5714+ 3939              ER      equ     VIDEOBUFF+$04
5715+ 3939              E2      equ     VIDEOBUFF+$06
5716+ 3939              SX      equ     VIDEOBUFF+$08
5717+ 3939              SY      equ     VIDEOBUFF+$0A
5718+ 3939              DX      equ     VIDEOBUFF+$0C
5719+ 3939              DY      equ     VIDEOBUFF+$0E
5720+ 3939 CD 6F 36     DRAW:   call    CHKG2M          ; check if in G2 mode
5721+ 393C CD 39 3C             call    CLRTMBF         ; clear TMPBFRx
5722+ 393F CD 48 3C             call    CLRVDBF         ; clear VIDEOBUFF
5723+ 3942 CD AE 2A             call    GETINT          ; get X1 coords.
5724+ 3945 32 A5 55             ld      (X1),A          ; store it into a temp buffer
5725+ 3948 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
5726+ 394B 2C                   defb    ','
5727+ 394C CD AE 2A             call    GETINT          ; get Y1 coords.
5728+ 394F FE C0                cp      $C0             ; check if Y1 is in range 0~191
5729+ 3951 D2 62 1E             jp      NC,FCERR        ; no, raise an FC error
5730+ 3954 32 A7 55             ld      (Y1),A          ; store into a temp buffer
5731+ 3957 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
5732+ 395A 2C                   defb    ','
5733+ 395B CD AE 2A             call    GETINT          ; get X2 coords.
5734+ 395E 32 AD 55             ld      (X2),A          ; store it into a temp buffer
5735+ 3961 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
5736+ 3964 2C                   defb    ','
5737+ 3965 CD AE 2A             call    GETINT          ; get Y2 coords
5738+ 3968 FE C0                cp      $C0             ; check if Y2 is in range 0~191
5739+ 396A D2 62 1E             jp      NC,FCERR        ; no, raise an FC error
5740+ 396D 32 AF 55             ld      (Y2),A          ; store it into a temp buffer
5741+ 3970 CD 57 3C             call    CLRPRM          ; check for arg. "color" and store it into TMPBFR3
5742+ 3973 E5                   push    HL              ; store register we'll use
5743+ 3974 ED 5B A5 55          ld      DE,(X1)         ; load X1 and
5744+ 3978 2A AD 55             ld      HL,(X2)         ; X2
5745+ 397B B7                   or      A               ; clear CARRY
5746+ 397C ED 52                sbc     HL,DE           ; DX=X2-X1
5747+ 397E CD A2 41             call    absHL           ; DX=ABS(DX)
5748+ 3981 22 B9 55             ld      (DX),HL         ; store DX
5749+ 3984 01 FF FF             ld      BC,$FFFF        ; SX=-1
5750+ 3987 2A A5 55             ld      HL,(X1)
5751+ 398A ED 5B AD 55          ld      DE,(X2)
5752+ 398E CD 61 41             call    CMP16           ; X1<X2?
5753+ 3991 CA 9A 39             jp      Z,X1GR          ; no, X1=X2
5754+ 3994 F2 9A 39             jp      P,X1GR          ; no, X1>X2
5755+ 3997 01 01 00             ld      BC,$0001        ; yes, so set SX=1
5756+ 399A ED 43 B5 55  X1GR:   ld      (SX),BC         ; store SX
5757+ 399E ED 5B A7 55          ld      DE,(Y1)
5758+ 39A2 2A AF 55             ld      HL,(Y2)
5759+ 39A5 B7                   or      A               ; clear Carry
5760+ 39A6 ED 52                sbc     HL,DE           ; DY=Y2-Y1
5761+ 39A8 CD A2 41             call    absHL           ; DY=ABS(DY)
5762+ 39AB 22 BB 55             ld      (DY),HL         ; store DY
5763+ 39AE 01 FF FF             ld      BC,$FFFF        ; SY=-1
5764+ 39B1 2A A7 55             ld      HL,(Y1)
5765+ 39B4 ED 5B AF 55          ld      DE,(Y2)
5766+ 39B8 CD 61 41             call    CMP16           ; is Y1<Y2?
5767+ 39BB CA C4 39             jp      Z,Y1GR          ; no, Y1=Y2
5768+ 39BE F2 C4 39             jp      P,Y1GR          ; no, Y1>Y2 - jump over
5769+ 39C1 01 01 00             ld      BC,$0001        ; yes, so set SY=1
5770+ 39C4 ED 43 B7 55  Y1GR:   ld      (SY),BC         ; store SY
5771+ 39C8 2A BB 55             ld      HL,(DY)         ; ER=DY
5772+ 39CB CD A5 41             call    negHL           ; ER=-DY
5773+ 39CE 22 B1 55             ld      (ER),HL         ; store ER
5774+ 39D1 2A B9 55             ld      HL,(DX)
5775+ 39D4 ED 5B BB 55          ld      DE,(DY)
5776+ 39D8 CD 61 41             call    CMP16           ; DX>DY?
5777+ 39DB CA E7 39             jp      Z,ER2           ; no, DX=DY
5778+ 39DE FA E7 39             jp      M,ER2           ; no, DX<DY
5779+ 39E1 2A B9 55             ld      HL,(DX)         ; reload DX
5780+ 39E4 22 B1 55             ld      (ER),HL         ; yes: DX>DY, so ER=DX
5781+ 39E7 2A B1 55     ER2:    ld      HL,(ER)         ; load ER
5782+ 39EA CB 2C                sra     H               ; right shift (and preserve sign)...
5783+ 39EC CB 1D                rr      L               ; ...of HL, so ER=INT(ER/2)
5784+ 39EE CB 7C                bit     7,H             ; is the number negative?
5785+ 39F0 CA F4 39             jp      Z,STRE2         ; no, jump over
5786+ 39F3 23                   inc     HL              ; yes, add 1 'cos INT of a negative number needs to be incremented
5787+ 39F4 22 B1 55     STRE2:  ld      (ER),HL         ; store ER
5788+ 39F7 CD C2 38     RPTDRW: call    CNTPLOT         ; plot first pixel
5789+ 39FA 2A A5 55             ld      HL,(X1)
5790+ 39FD ED 5B AD 55          ld      DE,(X2)
5791+ 3A01 CD 61 41             call    CMP16           ; X1=X2?
5792+ 3A04 20 0D                jr      NZ,CNTDRW       ; no, continue drawing
5793+ 3A06 2A A7 55             ld      HL,(Y1)         ; yes, so check
5794+ 3A09 ED 5B AF 55          ld      DE,(Y2)         ; also Y
5795+ 3A0D CD 61 41             call    CMP16           ; Y1=Y2?
5796+ 3A10 CA 6C 3A             jp      Z,ENDDRAW       ; yes, finished drawing: exit
5797+ 3A13 ED 5B B1 55  CNTDRW: ld      DE,(ER)
5798+ 3A17 ED 53 B3 55          ld      (E2),DE         ; E2=ER
5799+ 3A1B 2A B9 55             ld      HL,(DX)
5800+ 3A1E CD A5 41             call    negHL           ; DX=-DX
5801+ 3A21 EB                   ex      DE,HL           ; invert DE and HL => HL=E2, DE=-DX
5802+ 3A22 CD 61 41             call    CMP16           ; E2>-DX?
5803+ 3A25 CA 43 3A             jp      Z,DXGR          ; no, E2=-DX: jump
5804+ 3A28 FA 43 3A             jp      M,DXGR          ; no, E2<-DX: jump
5805+ 3A2B 2A B1 55             ld      HL,(ER)         ; yes
5806+ 3A2E ED 5B BB 55          ld      DE,(DY)
5807+ 3A32 B7                   or      A               ; clear CARRY
5808+ 3A33 ED 52                sbc     HL,DE           ; ER=ER-DY
5809+ 3A35 22 B1 55             ld      (ER),HL
5810+ 3A38 2A A5 55             ld      HL,(X1)
5811+ 3A3B ED 5B B5 55          ld      DE,(SX)
5812+ 3A3F 19                   add     HL,DE           ; X1=X1+SX (increment X1)
5813+ 3A40 22 A5 55             ld      (X1),HL
5814+ 3A43 2A B3 55     DXGR:   ld      HL,(E2)
5815+ 3A46 ED 5B BB 55          ld      DE,(DY)
5816+ 3A4A CD 61 41             call    CMP16           ; E2<DY?
5817+ 3A4D CA F7 39             jp      Z,RPTDRW        ; no, E2=DY: jump
5818+ 3A50 F2 F7 39             jp      P,RPTDRW        ; no, E2>DY: jump
5819+ 3A53 2A B1 55             ld      HL,(ER)         ; yes
5820+ 3A56 ED 5B B9 55          ld      DE,(DX)
5821+ 3A5A 19                   add     HL,DE           ; ER=ER+DX
5822+ 3A5B 22 B1 55             ld      (ER),HL
5823+ 3A5E 2A A7 55             ld      HL,(Y1)
5824+ 3A61 ED 5B B7 55          ld      DE,(SY)
5825+ 3A65 19                   add     HL,DE           ; Y1=Y1+SY (increment Y1)
5826+ 3A66 22 A7 55             ld      (Y1),HL
5827+ 3A69 C3 F7 39             jp      RPTDRW          ; repeat
5828+ 3A6C E1           ENDDRAW:pop     HL              ; retrieve HL
5829+ 3A6D C9                   ret                     ; return to caller
5830+ 3A6E
5831+ 3A6E
5832+ 3A6E              ; CIRCLE X,Y,R[,C]
5833+ 3A6E              ; Draw a circle using Bresenham's circle algorithm with center in X,Y
5834+ 3A6E              ; and radius R, with optional color C. If color is not specified, the
5835+ 3A6E              ; foreground color set with COLOR will be used
5836+ 3A6E              XC      equ     VIDEOBUFF
5837+ 3A6E              YC      equ     VIDEOBUFF+$02
5838+ 3A6E              RADIUS  equ     VIDEOBUFF+$04
5839+ 3A6E              XI      equ     VIDEOBUFF+$06
5840+ 3A6E              YI      equ     VIDEOBUFF+$08
5841+ 3A6E              DC      equ     VIDEOBUFF+$0A
5842+ 3A6E CD 6F 36     CIRCLE: call    CHKG2M          ; check if in G2 mode
5843+ 3A71 CD 48 3C             call    CLRVDBF         ; clear VIDEOBUFF
5844+ 3A74 CD AE 2A             call    GETINT          ; get X coords.
5845+ 3A77 32 AD 55             ld      (XC),A          ; store it into a temp buffer
5846+ 3A7A CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
5847+ 3A7D 2C                   defb    ','
5848+ 3A7E CD AE 2A             call    GETINT          ; get Y coords,
5849+ 3A81 32 AF 55             ld      (YC),A          ; store it into a temp buffer
5850+ 3A84 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
5851+ 3A87 2C                   defb    ','
5852+ 3A88 CD AE 2A             call    GETINT          ; get radius
5853+ 3A8B 32 B1 55             ld      (RADIUS),A      ; store it into a temp buffer
5854+ 3A8E CD 57 3C             call    CLRPRM          ; check if param "color" has been passed
5855+ 3A91 E5                   push    HL              ; store HL
5856+ 3A92 AF                   xor     A               ; clear A,
5857+ 3A93 47                   ld      B,A             ; B,
5858+ 3A94 4F                   ld      C,A             ; C,
5859+ 3A95 57                   ld      D,A             ; D,
5860+ 3A96 67                   ld      H,A             ; and H
5861+ 3A97 ED 43 B3 55          ld      (XI),BC         ; clear XI
5862+ 3A9B 3A B1 55             ld      A,(RADIUS)      ; load RADIUS into A
5863+ 3A9E 6F                   ld      L,A             ; HL now contains R
5864+ 3A9F 22 B5 55             ld      (YI),HL         ; YI=RADIUS
5865+ 3AA2 29                   add     HL,HL           ; R*2
5866+ 3AA3 EB                   ex      DE,HL           ; put HL into DE
5867+ 3AA4 21 03 00             ld      HL,$0003        ; HL = 3
5868+ 3AA7 AF                   xor     A               ; clear Carry
5869+ 3AA8 ED 52                sbc     HL,DE           ; D=3-(2*R) => HL
5870+ 3AAA 22 B7 55             ld      (DC),HL         ; store D
5871+ 3AAD CD 0A 3B             call    DRWCRL          ; draw initial point
5872+ 3AB0 ED 5B B3 55  RPTCRL: ld      DE,(XI)         ; load XI
5873+ 3AB4 2A B5 55             ld      HL,(YI)         ; load YI
5874+ 3AB7 CD 61 41             call    CMP16           ; is YI<DI?
5875+ 3ABA CA C3 3A             jp      Z,RPTCL1        ; no, YI=XI
5876+ 3ABD F2 C3 3A             jp      P,RPTCL1        ; no, YI>XI
5877+ 3AC0 C3 08 3B             jp      ENDCRL          ; yes, so we've finished
5878+ 3AC3 21 B3 55     RPTCL1: ld      HL,XI
5879+ 3AC6 34                   inc     (HL)            ; XI=XI+1
5880+ 3AC7 2A B7 55             ld      HL,(DC)         ; load D
5881+ 3ACA 7C                   ld      A,H
5882+ 3ACB B5                   or      L               ; is D=0? Yes, jump over
5883+ 3ACC CA F0 3A             jp      Z,DLSZ
5884+ 3ACF CB 7C                bit     7,H             ; is D<0?
5885+ 3AD1 20 1D                jr      NZ,DLSZ         ; yes, jump over
5886+ 3AD3 ED 5B B5 55          ld      DE,(YI)         ; D>0
5887+ 3AD7 1B                   dec     DE              ; so, YI=YI-1
5888+ 3AD8 ED 53 B5 55          ld      (YI),DE         ; store YI
5889+ 3ADC AF                   xor     A               ; clear Carry
5890+ 3ADD 2A B3 55             ld      HL,(XI)
5891+ 3AE0 ED 52                sbc     HL,DE           ; HL=XI-YI
5892+ 3AE2 29                   add     HL,HL
5893+ 3AE3 29                   add     HL,HL           ; HL=HL*4
5894+ 3AE4 11 0A 00             ld      DE,10
5895+ 3AE7 19                   add     HL,DE           ; HL=HL+10
5896+ 3AE8 ED 5B B7 55          ld      DE,(DC)         ; load D
5897+ 3AEC EB                   ex      DE,HL           ; invert DE and HL, so that HL=4*(XI-YI)+10 and DE=D
5898+ 3AED 19                   add     HL,DE           ; D=D+4*(XI-YI)+10
5899+ 3AEE 18 0F                jr      PLTCRL          ; plot next pixel
5900+ 3AF0 2A B3 55     DLSZ:   ld      HL,(XI)         ; load XI
5901+ 3AF3 29                   add     HL,HL
5902+ 3AF4 29                   add     HL,HL           ; XI=XI*4
5903+ 3AF5 11 06 00             ld      DE,$0006
5904+ 3AF8 19                   add     HL,DE
5905+ 3AF9 ED 5B B7 55          ld      DE,(DC)
5906+ 3AFD EB                   ex      DE,HL           ; HL=D and DE=4*XI+6
5907+ 3AFE 19                   add     HL,DE           ; D=D+4*XI+6
5908+ 3AFF 22 B7 55     PLTCRL: ld      (DC),HL         ; store new D
5909+ 3B02 CD 0A 3B             call    DRWCRL          ; plot pixel
5910+ 3B05 C3 B0 3A             jp      RPTCRL          ; repeat
5911+ 3B08 E1           ENDCRL: pop     HL
5912+ 3B09 C9                   ret                     ; return to caller
5913+ 3B0A 2A AD 55     DRWCRL: ld      HL,(XC)
5914+ 3B0D ED 5B B3 55          ld      DE,(XI)
5915+ 3B11 19                   add     HL,DE           ; X=XC+XI
5916+ 3B12 22 A5 55             ld      (X1),HL         ; store X
5917+ 3B15 CD 29 3C             call    VALIDX          ; check if X is valid (0~255)
5918+ 3B18 DA 2C 3B             jp      C,CNTCL1        ; if Carry is set, X is not valid
5919+ 3B1B 2A AF 55             ld      HL,(YC)
5920+ 3B1E ED 5B B5 55          ld      DE,(YI)
5921+ 3B22 19                   add     HL,DE           ; Y=YC+YI
5922+ 3B23 22 A7 55             ld      (Y1),HL         ; store Y
5923+ 3B26 CD 2E 3C             call    VALIDY          ; check if Y is valid (0~191)
5924+ 3B29 D4 C2 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5925+ 3B2C AF           CNTCL1: xor     A               ; clear Carry
5926+ 3B2D 2A AD 55             ld      HL,(XC)
5927+ 3B30 ED 5B B3 55          ld      DE,(XI)
5928+ 3B34 ED 52                sbc     HL,DE           ; X=XC-XI
5929+ 3B36 22 A5 55             ld      (X1),HL         ; store X
5930+ 3B39 CD 29 3C             call    VALIDX          ; check if X is valid (0~255)
5931+ 3B3C DA 50 3B             jp      C,CNTCL2        ; if Carry is set, X is not valid
5932+ 3B3F 2A AF 55             ld      HL,(YC)
5933+ 3B42 ED 5B B5 55          ld      DE,(YI)
5934+ 3B46 19                   add     HL,DE           ; Y=YC+YI
5935+ 3B47 22 A7 55             ld      (Y1),HL         ; store Y
5936+ 3B4A CD 2E 3C             call    VALIDY          ; check if Y is valid (0~191)
5937+ 3B4D D4 C2 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5938+ 3B50 2A AD 55     CNTCL2: ld      HL,(XC)
5939+ 3B53 ED 5B B3 55          ld      DE,(XI)
5940+ 3B57 19                   add     HL,DE           ; X=XC+XI
5941+ 3B58 22 A5 55             ld      (X1),HL         ; store X
5942+ 3B5B CD 29 3C             call    VALIDX          ; check if X is valid (0~255)
5943+ 3B5E DA 74 3B             jp      C,CNTCL3        ; if Carry is set, X is not valid
5944+ 3B61 AF                   xor     A               ; clear Carry
5945+ 3B62 2A AF 55             ld      HL,(YC)
5946+ 3B65 ED 5B B5 55          ld      DE,(YI)
5947+ 3B69 ED 52                sbc     HL,DE           ; Y=YC-YI
5948+ 3B6B 22 A7 55             ld      (Y1),HL         ; store Y
5949+ 3B6E CD 2E 3C             call    VALIDY          ; check if Y is valid (0~191)
5950+ 3B71 D4 C2 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5951+ 3B74 AF           CNTCL3: xor     A               ; clear Carry
5952+ 3B75 2A AD 55             ld      HL,(XC)
5953+ 3B78 ED 5B B3 55          ld      DE,(XI)
5954+ 3B7C ED 52                sbc     HL,DE           ; X=XC-XI
5955+ 3B7E 22 A5 55             ld      (X1),HL         ; store X
5956+ 3B81 CD 29 3C             call    VALIDX          ; check if X is valid (0~255)
5957+ 3B84 DA 9A 3B             jp      C,CNTCL4        ; if Carry is set, X is not valid
5958+ 3B87 AF                   xor     A               ; clear Carry
5959+ 3B88 2A AF 55             ld      HL,(YC)
5960+ 3B8B ED 5B B5 55          ld      DE,(YI)
5961+ 3B8F ED 52                sbc     HL,DE           ; Y=YC-YI
5962+ 3B91 22 A7 55             ld      (Y1),HL         ; store Y
5963+ 3B94 CD 2E 3C             call    VALIDY          ; check if Y is valid (0~191)
5964+ 3B97 D4 C2 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5965+ 3B9A 2A AD 55     CNTCL4: ld      HL,(XC)
5966+ 3B9D ED 5B B5 55          ld      DE,(YI)
5967+ 3BA1 19                   add     HL,DE           ; X=XC+YI
5968+ 3BA2 22 A5 55             ld      (X1),HL         ; store X
5969+ 3BA5 CD 29 3C             call    VALIDX          ; check if X is valid (0~255)
5970+ 3BA8 DA BC 3B             jp      C,CNTCL5        ; if Carry is set, X is not valid
5971+ 3BAB 2A AF 55             ld      HL,(YC)
5972+ 3BAE ED 5B B3 55          ld      DE,(XI)
5973+ 3BB2 19                   add     HL,DE           ; Y=YC+XI
5974+ 3BB3 22 A7 55             ld      (Y1),HL         ; store Y
5975+ 3BB6 CD 2E 3C             call    VALIDY          ; check if Y is valid (0~191)
5976+ 3BB9 D4 C2 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5977+ 3BBC AF           CNTCL5: xor     A               ; clear Carry
5978+ 3BBD 2A AD 55             ld      HL,(XC)
5979+ 3BC0 ED 5B B5 55          ld      DE,(YI)
5980+ 3BC4 ED 52                sbc     HL,DE           ; X=XC-YI
5981+ 3BC6 22 A5 55             ld      (X1),HL         ; store X
5982+ 3BC9 CD 29 3C             call    VALIDX          ; check if X is valid (0~255)
5983+ 3BCC DA E0 3B             jp      C,CNTCL6        ; if Carry is set, X is not valid
5984+ 3BCF 2A AF 55             ld      HL,(YC)
5985+ 3BD2 ED 5B B3 55          ld      DE,(XI)
5986+ 3BD6 19                   add     HL,DE           ; Y=YC+XI
5987+ 3BD7 22 A7 55             ld      (Y1),HL         ; store Y
5988+ 3BDA CD 2E 3C             call    VALIDY          ; check if Y is valid (0~191)
5989+ 3BDD D4 C2 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5990+ 3BE0 2A AD 55     CNTCL6: ld      HL,(XC)
5991+ 3BE3 ED 5B B5 55          ld      DE,(YI)
5992+ 3BE7 19                   add     HL,DE           ; X=XC+YI
5993+ 3BE8 22 A5 55             ld      (X1),HL         ; store X
5994+ 3BEB CD 29 3C             call    VALIDX          ; check if X is valid (0~255)
5995+ 3BEE DA 04 3C             jp      C,CNTCL7        ; if Carry is set, X is not valid
5996+ 3BF1 AF                   xor     A               ; clear Carry
5997+ 3BF2 2A AF 55             ld      HL,(YC)
5998+ 3BF5 ED 5B B3 55          ld      DE,(XI)
5999+ 3BF9 ED 52                sbc     HL,DE           ; Y=YC-XI
6000+ 3BFB 22 A7 55             ld      (Y1),HL         ; store Y
6001+ 3BFE CD 2E 3C             call    VALIDY          ; check if Y is valid (0~191)
6002+ 3C01 D4 C2 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
6003+ 3C04 AF           CNTCL7: xor     A               ; clear Carry
6004+ 3C05 2A AD 55             ld      HL,(XC)
6005+ 3C08 ED 5B B5 55          ld      DE,(YI)
6006+ 3C0C ED 52                sbc     HL,DE           ; X=XC-YI
6007+ 3C0E 22 A5 55             ld      (X1),HL         ; store X
6008+ 3C11 CD 29 3C             call    VALIDX          ; check if X is valid (0~255)
6009+ 3C14 D8                   ret     C               ; if Carry is set, X is not valid
6010+ 3C15 AF                   xor     A               ; clear Carry
6011+ 3C16 2A AF 55             ld      HL,(YC)
6012+ 3C19 ED 5B B3 55          ld      DE,(XI)
6013+ 3C1D ED 52                sbc     HL,DE           ; Y=YC-XI
6014+ 3C1F 22 A7 55             ld      (Y1),HL         ; store Y
6015+ 3C22 CD 2E 3C             call    VALIDY          ; check if Y is valid (0~191)
6016+ 3C25 D4 C2 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
6017+ 3C28 C9                   ret                     ; return to caller
6018+ 3C29
6019+ 3C29              ; check if X,Y coordinates are valid: 0<=X<=255 and 0<=Y<=191
6020+ 3C29              ; input: HL (value to check), can be negative
6021+ 3C29              ; output: CARRY flag: reset => VALID  //  set => NOT VALID
6022+ 3C29              ; destroys: A
6023+ 3C29 AF           VALIDX: xor     A               ; reset A
6024+ 3C2A B4                   or      H               ; check if H is 0 (this means that X is in range 0~255 and not negative)
6025+ 3C2B C8                   ret     Z               ; yes, we can return (C is clear)
6026+ 3C2C 37                   scf                     ; set Carry flag to raise error
6027+ 3C2D C9                   ret                     ; return to caller
6028+ 3C2E
6029+ 3C2E AF           VALIDY: xor     A               ; reset A
6030+ 3C2F B4                   or      H               ; check if H is 0 (this means that Y is in range 0~255 and not negative)
6031+ 3C30 28 02                jr      Z,CNTVALY       ; yes, continue checking
6032+ 3C32 37                   scf                     ; no, raise error by setting Carry flag
6033+ 3C33 C9                   ret                     ; return to caller
6034+ 3C34 7D           CNTVALY:ld      A,L
6035+ 3C35 FE C0                cp      $C0             ; is Y<192? Carry is set if Y<192
6036+ 3C37 3F                   ccf                     ; invert Carry, so Carry=0 means OK, Carry=1 means ERROR
6037+ 3C38 C9                   ret                     ; return to caller
6038+ 3C39
6039+ 3C39
6040+ 3C39
6041+ 3C39              ; cleat TMPBFR1-4 buffers before using them
6042+ 3C39 AF           CLRTMBF:xor     A               ; reset A
6043+ 3C3A E5                   push    HL              ; store HL
6044+ 3C3B C5                   push    BC              ; store BC
6045+ 3C3C 21 A5 55             ld      HL,TMPBFR1      ; address of 1st location
6046+ 3C3F 06 08                ld      B,$08           ; 8 locations
6047+ 3C41 77           RPCLTMB:ld      (HL),A          ; clear byte
6048+ 3C42 23                   inc     HL              ; next location
6049+ 3C43 10 FC                djnz    RPCLTMB         ; repeat
6050+ 3C45 C1                   pop     BC              ; retrieve BC
6051+ 3C46 E1                   pop     HL              ; retrieve HL
6052+ 3C47 C9                   ret                     ; return to caller
6053+ 3C48
6054+ 3C48
6055+ 3C48              ; clear VIDEOBUFF before using it as temp buffer
6056+ 3C48 AF           CLRVDBF:xor     A               ; clear A
6057+ 3C49 C5                   push    BC              ; store BC
6058+ 3C4A E5                   push    HL              ; store HL
6059+ 3C4B 06 28                ld      B,$28           ; 40 cells
6060+ 3C4D 21 AD 55             ld      HL,VIDEOBUFF    ; address of 1st cell
6061+ 3C50 77           RPTCVBF:ld      (HL),A          ; clear cell
6062+ 3C51 23                   inc     HL              ; next cell
6063+ 3C52 10 FC                djnz    RPTCVBF         ; repeat
6064+ 3C54 E1                   pop     HL              ; retrieve HL
6065+ 3C55 C1                   pop     BC              ; retrieve BC
6066+ 3C56 C9                   ret                     ; return to caller
6067+ 3C57
6068+ 3C57
6069+ 3C57              ; check if a color is passed as argument with PLOT, DRAW, and CIRCLE
6070+ 3C57              ; commands. If not present, the default foreground color will be used
6071+ 3C57 3A A3 55     CLRPRM: ld      A,(FRGNDCLR)    ; load foreground color
6072+ 3C5A 32 A9 55             ld      (TMPBFR3),A     ; store into temp buffer
6073+ 3C5D 2B                   dec     HL              ; dec 'cos GETCHR INCs
6074+ 3C5E CD 97 1D             call    GETCHR          ; Get next character
6075+ 3C61 C8                   ret     Z               ; return foreground color if nothing follows
6076+ 3C62 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
6077+ 3C65 2C                   defb    ','
6078+ 3C66 CD AE 2A             call    GETINT          ; get value
6079+ 3C69 CD 69 36             call    CHKCLR0         ; check if color is in range 0~15
6080+ 3C6C 32 A9 55             ld      (TMPBFR3),A     ; store color into temp buffer
6081+ 3C6F C9                   ret                     ; return to caller
6082+ 3C70
6083+ 3C70
6084+ 3C70              ; no graphics mode error: raised when a graphics command is invoked
6085+ 3C70              ; out of graphic 2 mode.
6086+ 3C70 1E 2A        GMERR:  ld      E,GM            ; load Graphics Mode Error flag
6087+ 3C72 C3 6A 18             jp      ERROR           ; print error
6088+ 3C75
6089+ 3C75
6090+ 3C75              ; set a serial port: params are PORT,BPS,DATA,PARITY,STOP
6091+ 3C75              ; PORT=1/2; BPS=1,200~57,600 (see below), DATA=5/6/7/8
6092+ 3C75              ; PARITY: 0=no parity; 1=ODD parity; 2=EVEN parity;
6093+ 3C75              ; STOP=0/1/2/3: 0=0 bit; 1=1 bit; 2=1.5 bits; 3=2 bits
6094+ 3C75              ; PORT 1 acts as a char device; PORT 2 acts as a block device
6095+ 3C75              ; DATA,PARITY, and STOP are optional: if nothing follows BPS,
6096+ 3C75              ; they are assumed to be 8,0,1 resp.
6097+ 3C75              PRTNUM  equ     VIDEOBUFF
6098+ 3C75              BPS     equ     PRTNUM+$01
6099+ 3C75              DATABT  equ     BPS+$02
6100+ 3C75              PARBT   equ     DATABT+$01
6101+ 3C75              STPBT   equ     PARBT+$01
6102+ 3C75              SIOBFR  equ     STPBT+$01
6103+ 3C75 CD AE 2A     SERIAL: call    GETINT          ; get port #
6104+ 3C78 A7                   and     A               ; is it zero?
6105+ 3C79 CA 62 1E             jp      Z,FCERR         ; yes, error
6106+ 3C7C FE 03                cp      $03             ; is it 1 or 2?
6107+ 3C7E D2 9E 3E             jp      NC,SCERR        ; no, error
6108+ 3C81 32 AD 55             ld      (PRTNUM),A      ; store port number into a temp buffer
6109+ 3C84 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
6110+ 3C87 2C                   defb    ','
6111+ 3C88 2B                   dec     HL
6112+ 3C89 CD 97 1D             call    GETCHR          ; check what's following
6113+ 3C8C CA 50 18             jp      Z,SNERR         ; error if nothing follows
6114+ 3C8F 30 05                jr      NC,SERVAR       ; it's not a number, try a variable
6115+ 3C91 CD 67 1E             call    ATOH            ; get bps (returned into DE)
6116+ 3C94 18 0F                jr      CHKZSER         ; jump over
6117+ 3C96 CD 28 22     SERVAR: call    GETNUM          ; get number
6118+ 3C99 CD 35 30             call    TSTSGN          ; check value
6119+ 3C9C FA 62 1E             jp      M,FCERR         ; negative - illegal function call
6120+ 3C9F 3A FC 55             ld      A,(FPEXP)       ; Get integer value to DE
6121+ 3CA2 CD DD 30             call    FPINT           ; get integer number into BCDE - drop BC 'cause isn't necessary
6122+ 3CA5 7A           CHKZSER:ld      A,D             ; bps is into DE - move MSB into A
6123+ 3CA6 B3                   or      E               ; check if bps=0
6124+ 3CA7 20 3A                jr      NZ,CNTSER       ; no, continue checking
6125+ 3CA9                      ; if baud rate is 0, then close the serial comm.
6126+ 3CA9 3A AD 55     RSTSERS:ld      A,(PRTNUM)      ; yes, so reset the channel. First, load port number
6127+ 3CAC 3D                   dec     A               ; subtract 1, so that serial channel is 0=>A and 1=>B
6128+ 3CAD C6 22                add     SIO_CA          ; find correct channel
6129+ 3CAF 4F                   ld      C,A             ; store serial channel
6130+ 3CB0 F3                   di                      ; disable INTs
6131+ 3CB1 AF                   xor     A               ; reset A
6132+ 3CB2 16 01                ld      D,$01           ; start from WR1
6133+ 3CB4 06 05                ld      B,$05           ; 5 registers
6134+ 3CB6 ED 51        RPTRSSR:out     (C),D           ; select register
6135+ 3CB8 ED 79                out     (C),A           ; reset register
6136+ 3CBA 14                   inc     D               ; next register
6137+ 3CBB 10 F9                djnz    RPTRSSR         ; repeat
6138+ 3CBD 3E 30                ld      A,%00110000     ; write into WR0: error reset, select WR0
6139+ 3CBF ED 79                out     (C),A           ; send command to serial channel
6140+ 3CC1 3E 18                ld      A,%00011000     ; write into WR0: channel reset
6141+ 3CC3 ED 79                out     (C),A           ; send command to serial channel
6142+ 3CC5 FB                   ei                      ; re-enable INTs
6143+ 3CC6 E5                   push    HL              ; store HL
6144+ 3CC7 21 E7 55             ld      HL,SERIALS_EN   ; serials enabled status byte
6145+ 3CCA DB 01                in      A,(PIO_DB)      ; read status LEDs
6146+ 3CCC CB 41                bit     0,C             ; check serial port
6147+ 3CCE 20 09                jr      NZ,SRPT2        ; if bit is set, jump to port 2
6148+ 3CD0 CB B7                res     6,A             ; it's port 1
6149+ 3CD2 CB A7                res     4,A             ; remove possible error LED
6150+ 3CD4 CB 86                res     0,(HL)          ; disable port 1
6151+ 3CD6 C3 DF 3C             jp      SERLED          ; jump over
6152+ 3CD9 CB BF        SRPT2:  res     7,A             ; it's port 2
6153+ 3CDB CB AF                res     5,A             ; remove possible error LED
6154+ 3CDD CB 8E                res     1,(HL)          ; disable port 2
6155+ 3CDF D3 01        SERLED: out     (PIO_DB),A      ; send new configuration
6156+ 3CE1 E1                   pop     HL              ; retrieve HL
6157+ 3CE2 C9                   ret                     ; return to caller
6158+ 3CE3                      ; check if bps=1, meaning reactivate RX on serial
6159+ 3CE3 7A           CNTSER: ld      A,D
6160+ 3CE4 B2                   or      D               ; check if bps<>1 by first checking D=0
6161+ 3CE5 20 36                jr      NZ,CNTSER2      ; if not, jump over
6162+ 3CE7 7B                   ld      A,E             ; then by checking that
6163+ 3CE8 FE 01                cp      $01             ; E=1
6164+ 3CEA 20 31                jr      NZ,CNTSER2      ; if not, jump over
6165+ 3CEC 3A AD 55             ld      A,(PRTNUM)      ; load port number
6166+ 3CEF 57                   ld      D,A             ; store port on D
6167+ 3CF0 3A E7 55             ld      A,(SERIALS_EN)  ; load address of serial status cell
6168+ 3CF3 A2                   and     D               ; check status
6169+ 3CF4 CA 9E 3E             jp      Z,SCERR         ; port not open, raise error
6170+ 3CF7 F3                   di                      ; disable INTs
6171+ 3CF8 7A                   ld      A,D             ; move port # into A
6172+ 3CF9 5F                   ld      E,A             ; and also into E
6173+ 3CFA 87                   add     A
6174+ 3CFB 87                   add     A               ; move A to left times 2
6175+ 3CFC 57                   ld      D,A             ; move value into D
6176+ 3CFD 3A E7 55             ld      A,(SERIALS_EN)  ; load serial status byte
6177+ 3D00 B2                   or      D               ; re-enable RX
6178+ 3D01 32 E7 55             ld      (SERIALS_EN),A  ; store new serial status
6179+ 3D04 7B                   ld      A,E             ; recover port #
6180+ 3D05 3D                   dec     A               ; check port
6181+ 3D06 20 0A                jr      NZ,CNTRX2       ; port is #2
6182+ 3D08 CD E3 01             call    SIO_A_EI        ; re-enable RX on port 1
6183+ 3D0B DB 01                in      A,(PIO_DB)      ; load status LEDs
6184+ 3D0D CB A7                res     4,A             ; remove error LED
6185+ 3D0F C3 19 3D             jp      RXEND           ; terminate setting
6186+ 3D12 CD EB 01     CNTRX2: call    SIO_B_EI        ; re-enable RX on port 2
6187+ 3D15 DB 01                in      A,(PIO_DB)      ; load status LEDs
6188+ 3D17 CB AF                res     5,A             ; remove error LED
6189+ 3D19 D3 01        RXEND:  out     (PIO_DB),A      ; set new status for LEDs
6190+ 3D1B FB                   ei                      ; re-enable INTs
6191+ 3D1C C9                   ret                     ; return to caller
6192+ 3D1D                      ; set serial port comm.
6193+ 3D1D D5           CNTSER2:push    DE              ; store BPS
6194+ 3D1E 3A AD 55             ld      A,(PRTNUM)      ; load port number
6195+ 3D21 57                   ld      D,A             ; move port # into D
6196+ 3D22 3A E7 55             ld      A,(SERIALS_EN)  ; check if serial port is already open
6197+ 3D25 A2                   and     D               ; by ANDing A with D
6198+ 3D26 D1                   pop     DE              ; retrieve BPS
6199+ 3D27 CA 2F 3D             jp      Z,CNTSER3       ; not open, continue
6200+ 3D2A 1E 2E                ld      E,SA            ; already open, so raise a "Serial Port Already Error"
6201+ 3D2C C3 6A 18             jp      ERROR           ; and leave
6202+ 3D2F E5           CNTSER3:push    HL              ; store HL
6203+ 3D30 21 00 E1             ld      HL,$E100        ; check bps. start with HL=57,600
6204+ 3D33 CD 61 41             call    CMP16           ; is bps<=57,600?
6205+ 3D36 E1                   pop     HL              ; but first, recover HL
6206+ 3D37 DA 9E 3E             jp      C,SCERR         ; no (bps>57,600) then error
6207+ 3D3A ED 53 AE 55          ld      (BPS),DE        ; store bps
6208+ 3D3E 2B                   dec     HL              ; dec 'cos GETCHR INCs
6209+ 3D3F CD 97 1D             call    GETCHR          ; Get next character
6210+ 3D42 CA 7A 3D             jp      Z,DEFSER        ; defaults if nothing follows
6211+ 3D45 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
6212+ 3D48 2C                   defb    ','
6213+ 3D49 CD AE 2A             call    GETINT          ; get data bits
6214+ 3D4C FE 05                cp      $05             ; is it <5?
6215+ 3D4E DA 9E 3E             jp      C,SCERR         ; yes, error
6216+ 3D51 FE 09                cp      $09             ; is it >=9?
6217+ 3D53 D2 62 1E             jp      NC,FCERR        ; yes, error
6218+ 3D56 32 B0 55             ld      (DATABT),A      ; store data bits
6219+ 3D59 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
6220+ 3D5C 2C                   defb    ','
6221+ 3D5D CD AE 2A             call    GETINT          ; get parity bits
6222+ 3D60 BF FE 03             cp      A,$03           ; check if parity is in range 0~2
6223+ 3D63 D2 9E 3E             jp      NC,SCERR        ; no, error
6224+ 3D66 32 B1 55             ld      (PARBT),A       ; store parity
6225+ 3D69 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
6226+ 3D6C 2C                   defb    ','
6227+ 3D6D CD AE 2A             call    GETINT          ; get stop bits
6228+ 3D70 FE 03                cp      $03             ; is it >=3?
6229+ 3D72 D2 9E 3E             jp      NC,SCERR        ; yes, error
6230+ 3D75 32 B2 55             ld      (STPBT),A       ; store stop bits
6231+ 3D78 18 0D                jr      SETSER          ; jump to set serial
6232+ 3D7A 3E 08        DEFSER: ld      A,$08           ; 8 bits for data
6233+ 3D7C 32 B0 55             ld      (DATABT),A
6234+ 3D7F AF                   xor     A               ; no parity bit
6235+ 3D80 32 B1 55             ld      (PARBT),A
6236+ 3D83 3C                   inc     A               ; 1 bit for stop
6237+ 3D84 32 B2 55             ld      (STPBT),A
6238+ 3D87                      ; check if bps are legal
6239+ 3D87 E5           SETSER: push    HL              ; store HL
6240+ 3D88 D5                   push    DE              ; store DE
6241+ 3D89 DD E5                push    IX              ; store IX
6242+ 3D8B DD 21 79 3E          ld      IX,SUP_BPS      ; allowed BPSs
6243+ 3D8F 06 0B                ld      B,$0B           ; 11 items
6244+ 3D91 0E 00                ld      C,$00           ; reset pointer
6245+ 3D93 2A AE 55     CKBPS:  ld      HL,(BPS)        ; load BPS
6246+ 3D96 DD 5E 00             ld      E,(IX+0)        ; load LSB of item
6247+ 3D99 DD 56 01             ld      D,(IX+1)        ; load MSB of item
6248+ 3D9C CD 61 41             call    CMP16           ; is it equal?
6249+ 3D9F CA AC 3D             jp      Z,SET_PT        ; yes, found a correspondance
6250+ 3DA2 DD 23                inc     IX
6251+ 3DA4 DD 23                inc     IX              ; no, go to next entry
6252+ 3DA6 0C                   inc     C               ; increment pointer
6253+ 3DA7 10 EA                djnz    CKBPS           ; repeat for 10 entries
6254+ 3DA9 C3 9A 3E             jp      SCERR1          ; if nothing found, raise an error
6255+ 3DAC              SET_PT: ;init CTC CH0: CH0 provides RX/TX clock to SIO port A
6256+ 3DAC                      ; TO0 output frequency=INPUT CLK/time constant. Time constant is set to get 16 times
6257+ 3DAC                      ; the requested baud rate. I.e., if bps is 19,200 then time constast is set to 6 because
6258+ 3DAC                      ; 1,843,200/6 = 307,200 Hz (that is 19,200 x 16)
6259+ 3DAC F3                   di                      ; disable INTs
6260+ 3DAD 06 00                ld      B,$00           ; reset B
6261+ 3DAF 21 8F 3E             ld      HL,CTC_CFG      ; address of first CTC divider
6262+ 3DB2 09                   add     HL,BC           ; adjust for correct CTC divider
6263+ 3DB3 0E 10                ld      C,CTC_CH0       ; CTC channel 0
6264+ 3DB5 3A AD 55             ld      A,(PRTNUM)      ; load port number
6265+ 3DB8 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6266+ 3DB9 DA BD 3D             jp      C,SET_CTC       ; port 1 => ch. 0, so continue
6267+ 3DBC 0C                   inc     C               ; port 2 => ch. 1, increment address port into C
6268+ 3DBD 3E 47        SET_CTC:ld      A,%01000111     ; interrupt off, counter mode, prsc=16 (doesn't matter), ext. start,
6269+ 3DBF                                              ; start upon loading time constant, time constant follows, sw reset, command word
6270+ 3DBF ED 79                out     (C),A           ; configure CTC channel
6271+ 3DC1 7E                   ld      A,(HL)          ; load CTC divider
6272+ 3DC2 ED 79                out     (C),A           ; send divider
6273+ 3DC4                      ; configure SIO
6274+ 3DC4 21 36 03             ld      HL,SIO_A_SETS   ; load default settings for SIO
6275+ 3DC7 11 B3 55             ld      DE,SIOBFR       ; into a temp buffer
6276+ 3DCA 01 0A 00             ld      BC,$000A        ; 10 items to copy
6277+ 3DCD ED B0                ldir                    ; copy SIO settings into TEMP buffer
6278+ 3DCF 3A B8 55             ld      A,(SIOBFR+5)    ; load WR5 setting
6279+ 3DD2 47                   ld      B,A             ; move it into B
6280+ 3DD3 3A B0 55             ld      A,(DATABT)      ; load DATA bits
6281+ 3DD6 FE 05                cp      $05             ; is it 5 bits?
6282+ 3DD8 20 06                jr      NZ,BITS6        ; no, jump over
6283+ 3DDA CB B0                res     6,B
6284+ 3DDC CB A8                res     5,B             ; set D6 & D5 to 0
6285+ 3DDE 18 19                jr      SETPAR          ; jump to set parity
6286+ 3DE0 FE 06        BITS6:  cp      $06             ; is it 6 bits?
6287+ 3DE2 20 06                jr      NZ,BITS7        ; no, jump over
6288+ 3DE4 CB F0                set     6,B
6289+ 3DE6 CB A8                res     5,B             ; set D6 & D5 to 1,0
6290+ 3DE8 18 0F                jr      SETPAR          ; jump to set parity
6291+ 3DEA FE 07        BITS7:  cp      $07             ; is it 7 bits?
6292+ 3DEC 20 07                jr      NZ,BITS8        ; no, jump over
6293+ 3DEE CB B0                res     6,B
6294+ 3DF0 CB E8                set     5,B             ; set D6 & D5 to 0,1
6295+ 3DF2 C3 F9 3D             jp      SETPAR          ; jump to set parity
6296+ 3DF5 CB F0        BITS8:  set     6,B
6297+ 3DF7 CB E8                set     5,B             ; set D6 & D5 to 1,1
6298+ 3DF9 21 E8 55     SETPAR: ld      HL,SERABITS     ; load address for storing data bits
6299+ 3DFC 3A AD 55             ld      A,(PRTNUM)      ; check serial port number
6300+ 3DFF 3D                   dec     A               ; is it port #1?
6301+ 3E00 CA 04 3E             jp      Z,SETPAR2       ; yes, jump over
6302+ 3E03 23                   inc     HL              ; port #2, use SERBBITS instead
6303+ 3E04 78           SETPAR2:ld      A,B             ; retrieve DATA bits
6304+ 3E05 32 B8 55             ld      (SIOBFR+5),A    ; save DATA bits
6305+ 3E08 E6 60                and     %01100000       ; filter only D5&D6 bits
6306+ 3E0A 87                   add     A,A             ; shift left times 1
6307+ 3E0B 77                   ld      (HL),A          ; store for SIO_EI & SIO_DI functions
6308+ 3E0C 3A B2 55             ld      A,(STPBT)       ; load STOP bits
6309+ 3E0F 87                   add     A,A
6310+ 3E10 87                   add     A,A             ; 2 left shifts
6311+ 3E11 47                   ld      B,A             ; move forming byte into B
6312+ 3E12 3A B1 55             ld      A,(PARBT)       ; load PARITY setting
6313+ 3E15 A7                   and     A               ; is it 0?
6314+ 3E16 CA 21 3E             jp      Z,STRPAR        ; yes, jump over
6315+ 3E19 CB C0                set     0,B             ; set PARITY on
6316+ 3E1B 3D                   dec     A               ; is parity ODD?
6317+ 3E1C CA 21 3E             jp      Z,STRPAR        ; yes, so jump over
6318+ 3E1F CB C8                set     1,B             ; no, it's EVEN so set the corresponding bit
6319+ 3E21 3A B6 55     STRPAR: ld      A,(SIOBFR+3)    ; load WR4 setting
6320+ 3E24 E6 F0                and     %11110000       ; reset STOP & PARITY bits
6321+ 3E26 B0                   or      B               ; set new STOP & PARITY bits
6322+ 3E27 32 B6 55             ld      (SIOBFR+3),A    ; store new value
6323+ 3E2A                      ;set up TX and RX:
6324+ 3E2A                      ; the followings are settings for channel A
6325+ 3E2A 21 B3 55             ld      HL,SIOBFR       ; settings for SIO ch. A
6326+ 3E2D 06 06                ld      B,$06           ; 6 bytes to send
6327+ 3E2F 0E 22                ld      C,SIO_CA        ; I/O address of SIO ch.A
6328+ 3E31 3A AD 55             ld      A,(PRTNUM)      ; load port number
6329+ 3E34 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6330+ 3E35 DA 39 3E             jp      C,SRLCNT        ; port 1, continue
6331+ 3E38 0C                   inc     C               ; port 2, increment address port into C
6332+ 3E39 ED B3        SRLCNT: otir                    ; send bytes to SIO
6333+ 3E3B                      ; the following are settings for channel B (don't need to load HL since settings are contigous)
6334+ 3E3B 06 04                ld      B,$04           ; other 4 bytes to send
6335+ 3E3D 51                   ld      D,C             ; store port address into D
6336+ 3E3E 0E 23                ld      C,SIO_CB        ; I/O address of SIO ch.B
6337+ 3E40 ED B3                otir                    ; send bytes to SIO
6338+ 3E42                      ; the following are settings for selected channel
6339+ 3E42 3E 01                ld      A,$01           ; write into WR0: select WR1
6340+ 3E44 4A                   ld      C,D             ; retrieve port address
6341+ 3E45 ED 79                out     (C),A
6342+ 3E47 3E 18                ld      A,%00011000     ; interrupts on every RX char; parity is no special condition;
6343+ 3E49                                              ; buffer overrun is special condition
6344+ 3E49 ED 79                out     (C),A
6345+ 3E4B 21 E7 55             ld      HL,SERIALS_EN
6346+ 3E4E 3A AD 55             ld      A,(PRTNUM)      ; retrieve serial channel
6347+ 3E51 3D                   dec     A               ; channel A?
6348+ 3E52 20 10                jr      NZ,ENCHB        ; no, jump over
6349+ 3E54 CD E3 01             call    SIO_A_EI        ; enable RX on SIO channel A
6350+ 3E57 CB C6                set     0,(HL)          ; set serial port 1 status ON
6351+ 3E59 CB D6                set     2,(HL)          ; set serial port 1 RX ON
6352+ 3E5B                      ; back to normal running
6353+ 3E5B FB                   ei                      ; re-enable INTs
6354+ 3E5C DB 01                in      A,(PIO_DB)      ; load status LEDs
6355+ 3E5E CB F7                set     6,A             ; set status LED on
6356+ 3E60 CB A7                res     4,A             ; set error LED off
6357+ 3E62 18 0E                jr      EXNRM           ; leave
6358+ 3E64 CD EB 01     ENCHB:  call    SIO_B_EI        ; enable RX on SIO channel B
6359+ 3E67 CB CE                set     1,(HL)          ; set serial port 2 status ON
6360+ 3E69 CB DE                set     3,(HL)          ; set serial port 2 RX ON
6361+ 3E6B                      ; back to normal running
6362+ 3E6B FB                   ei                      ; re-enable INTs
6363+ 3E6C DB 01                in      A,(PIO_DB)      ; load status LEDs
6364+ 3E6E CB FF                set     7,A             ; set status LED on
6365+ 3E70 CB AF                res     5,A             ; set error LED off
6366+ 3E72 D3 01        EXNRM:  out     (PIO_DB),A      ; send new configuration
6367+ 3E74 DD E1                pop     IX              ; retrieve IX
6368+ 3E76 D1                   pop     DE              ; retrieve DE
6369+ 3E77 E1                   pop     HL              ; retrieve HL
6370+ 3E78 C9                   ret                     ; return to caller
6371+ 3E79
6372+ 3E79              ; allowed bps (Bauds per second)
6373+ 3E79 00 E1 00 96  SUP_BPS:defw    57600,38400,28800,19200,14400,9600,4800,3600,2400,1200,600
6373+ 3E7D 80 70 00 4B
6373+ 3E81 40 38 80 25
6373+ 3E85 C0 12 10 0E
6373+ 3E89 60 09 B0 04
6373+ 3E8D 58 02
6374+ 3E8F              ; corresponding CTC divider
6375+ 3E8F 02 03 04 06  CTC_CFG:defb    2,3,4,6,8,12,24,32,48,96,192
6375+ 3E93 08 0C 18 20
6375+ 3E97 30 60 C0
6376+ 3E9A
6377+ 3E9A
6378+ 3E9A              ; serial configuration error
6379+ 3E9A DD E1        SCERR1: pop     IX              ; retrieve IX
6380+ 3E9C D1                   pop     DE              ; retrieve DE
6381+ 3E9D E1                   pop     HL              ; retrieve HL
6382+ 3E9E 1E 2C        SCERR:  ld      E,SC            ; Serial Configuration Error
6383+ 3EA0 C3 6A 18             jp      ERROR           ; print error
6384+ 3EA3
6385+ 3EA3
6386+ 3EA3              ; serial buffer overrun
6387+ 3EA3 CD 64 20     SOERR:  call    PRNTCRLF
6388+ 3EA6 1E 30                ld      E,SO            ; Serial Buffer Overrun
6389+ 3EA8 C3 6A 18             jp      ERROR
6390+ 3EAB
6391+ 3EAB
6392+ 3EAB              ; check for direct mode:
6393+ 3EAB              ; Z is set if in direct mode, reset otherwise
6394+ 3EAB E5           DIRMOD: push    HL              ; Save code string address
6395+ 3EAC 2A 52 54             ld      HL,(LINEAT)     ; Get current line number
6396+ 3EAF 23                   inc     HL              ; -1 means direct statement
6397+ 3EB0 7C                   ld      A,H
6398+ 3EB1 B5                   or      L
6399+ 3EB2 E1                   pop     HL              ; Restore code string address
6400+ 3EB3 C9                   ret
6401+ 3EB4
6402+ 3EB4
6403+ 3EB4              ; HELP lists the line program where an error occured
6404+ 3EB4 CD AB 3E     HELP:   call    DIRMOD          ; check if in direct mode
6405+ 3EB7 C2 CD 3E             jp      NZ,HLPERR       ; raise error if in indirect mode
6406+ 3EBA E5                   push    HL              ; store HL
6407+ 3EBB 2A 54 54             ld      HL,(HLPLN)      ; load HELP line
6408+ 3EBE 23                   inc     HL              ; increment HL
6409+ 3EBF 7C                   ld      A,H
6410+ 3EC0 B5                   or      L               ; check if there is a line into the HELP reg.
6411+ 3EC1 E1                   pop     HL
6412+ 3EC2 CA CD 3E             jp      Z,HLPERR        ; no line found, raise error
6413+ 3EC5 ED 5B 54 54          ld      DE,(HLPLN)      ; recover line
6414+ 3EC9 C1                   pop     BC              ; remove BC from stack since it's not needed anymore for LIST
6415+ 3ECA C3 E4 1B             jp      LST01H          ; jump to list line
6416+ 3ECD 1E 32        HLPERR: ld      E,HP            ; HELP call error
6417+ 3ECF C3 6A 18             jp      ERROR           ; raise error
6418+ 3ED2
6419+ 3ED2
6420+ 3ED2              ; KEY command to list/modify function keys and auto-repeat
6421+ 3ED2 2B           KEY:    dec     HL              ; dec 'cos GETCHR INCs
6422+ 3ED3 CD 97 1D             call    GETCHR          ; Get next character
6423+ 3ED6 CA 54 3F             jp      Z,LSTKEYS       ; jump if nothing follows
6424+ 3ED9                      ; change FN keys
6425+ 3ED9 CD AE 2A             call    GETINT          ; get a number
6426+ 3EDC A7                   and     A               ; is it 0?
6427+ 3EDD 20 0E                jr      NZ,KEYCH        ; no, jump over
6428+ 3EDF E5           RESFN:  push    HL              ; yes - reset FN keys to defaults
6429+ 3EE0 21 3E 17             ld      HL,AUTORP       ; pointer to default auto-repeat delays and FN keys texts
6430+ 3EE3 11 56 54             ld      DE,KEYDEL       ; pointer to destination
6431+ 3EE6 01 82 00             ld      BC,$0082        ; 130 chars to be copied (2xauto-delay, 128xFN keys)
6432+ 3EE9 ED B0                ldir                    ; restore default texts
6433+ 3EEB E1                   pop     HL              ; retrieve HL
6434+ 3EEC C9                   ret                     ; return to caller
6435+ 3EED FE 09        KEYCH:  cp      $09             ; is it >= 9?
6436+ 3EEF D2 07 40             jp      NC,SETREP       ; yes - jump over
6437+ 3EF2 3D                   dec     A               ; FN key in range 0~7
6438+ 3EF3 87                   add     A,A             ; multiply A...
6439+ 3EF4 87                   add     A,A             ; ... times 4...
6440+ 3EF5 87                   add     A,A             ; ... to get the correct...
6441+ 3EF6 87                   add     A,A             ; ... offset fo FN key text
6442+ 3EF7 32 A5 55             ld      (TMPBFR1),A     ; store FN key offset...
6443+ 3EFA AF                   xor     A               ; ...in a...
6444+ 3EFB 32 A6 55             ld      (TMPBFR1+1),A   ; ...16-bit register
6445+ 3EFE CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
6446+ 3F01 2C                   defb    ','
6447+ 3F02 44 4D                ld      BC,HL           ; copy address into BC
6448+ 3F04 CD 3A 22             call    EVAL            ; Evaluate expression (in E there is the length)
6449+ 3F07 E5                   push    HL              ; store string pointer
6450+ 3F08 3A 37 55             ld      A,(TYPE)        ; Get variable type
6451+ 3F0B B7                   or      A               ; Is it a string variable?
6452+ 3F0C CA 50 18             jp      Z,SNERR         ; no - syntax error
6453+ 3F0F CD 73 28             call    GSTRCU          ; Current string to pool
6454+ 3F12 CD 84 30             call    LOADFP          ; Move string block data to (BC=pointer, DE=length)
6455+ 3F15 7B                   ld      A,E             ; copy length into A
6456+ 3F16 FE 11                cp      $11             ; is length > 16?
6457+ 3F18 DA 1D 3F             jp      C,DECLN1        ; no, jump over
6458+ 3F1B 1E 10                ld      E,$10           ; yes, so set length to 16
6459+ 3F1D 3E 10        DECLN1: ld      A,$10           ; calculate how many...
6460+ 3F1F 93                   sub     E               ; ...null chars needed to fill up...
6461+ 3F20 57                   ld      D,A             ; ...the FN key text
6462+ 3F21 C5                   push    BC              ; store address of string
6463+ 3F22 ED 4B A5 55          ld      BC,(TMPBFR1)    ; load FN key offset
6464+ 3F26 21 58 54             ld      HL,FNKEYS       ; load address of FN keys texts
6465+ 3F29 09                   add     HL,BC           ; get corrected address
6466+ 3F2A C1                   pop     BC              ; retrieve address of string chars
6467+ 3F2B 0A           CPKEY:  ld      A,(BC)          ; load char from string
6468+ 3F2C FE 0D                cp      CR              ; return?
6469+ 3F2E CA 3B 3F             jp      Z,CPKEY2        ; yes, store char
6470+ 3F31 FE 7B                cp      $7B             ; if char > "z" ?
6471+ 3F33 D2 50 18             jp      NC,SNERR        ; yes - syntax error
6472+ 3F36 FE 20                cp      $20             ; is char < space?
6473+ 3F38 DA 50 18             jp      C,SNERR         ; yes - syntax error
6474+ 3F3B FE 61        CPKEY2: cp      $61             ; is it >= 'a'?
6475+ 3F3D DA 42 3F             jp      C,CPKEY3        ; no, continue
6476+ 3F40 E6 5F                and     %01011111       ; set letters to uppercase
6477+ 3F42 77           CPKEY3: ld      (HL),A          ; store char
6478+ 3F43 23                   inc     HL              ; next string char
6479+ 3F44 03                   inc     BC              ; next free cell
6480+ 3F45 1D                   dec     E               ; decrement E
6481+ 3F46 20 E3                jr      NZ,CPKEY        ; repeat until 0
6482+ 3F48 AF                   xor     A               ; null char
6483+ 3F49 14                   inc     D               ; +1 to decrement below
6484+ 3F4A 15           CPKEY1: dec     D               ; how many null chars to insert?
6485+ 3F4B CA 52 3F             jp      Z,CPKYEND       ; no more nulls, so exit
6486+ 3F4E 77                   ld      (HL),A          ; store it
6487+ 3F4F 23                   inc     HL              ; next cell
6488+ 3F50 18 F8                jr      CPKEY1          ; repeat
6489+ 3F52 E1           CPKYEND:pop     HL              ; retrieve pointer to string
6490+ 3F53 C9                   ret                     ; return to caller
6491+ 3F54                                              ; list FN keys
6492+ 3F54 E5           LSTKEYS:push    HL              ; Save code string address
6493+ 3F55 2A 52 54             ld      HL,(LINEAT)     ; Get current line number
6494+ 3F58 23                   inc     HL              ; -1 means direct statement
6495+ 3F59 7C                   ld      A,H
6496+ 3F5A B5                   or      L
6497+ 3F5B E1                   pop     HL              ; Restore code string address
6498+ 3F5C C2 50 18             jp      NZ,SNERR        ; raise error if in indirect mode
6499+ 3F5F E5                   push    HL              ; store HL
6500+ 3F60 D5                   push    DE              ; store DE
6501+ 3F61 21 58 54             ld      HL,FNKEYS       ; load starting address of FN keys text
6502+ 3F64 0E 01                ld      C,$01           ; 8 function keys
6503+ 3F66 06 10        PRTK4:  ld      B,$10           ; 16 chars each
6504+ 3F68 11 29 40             ld      DE,CHKEY1       ; message "KEY "
6505+ 3F6B CD F8 3F             call    PRTCKEY         ; print it
6506+ 3F6E 79                   ld      A,C             ; load FN key
6507+ 3F6F C6 30                add     $30             ; get number in ASCI code
6508+ 3F71 CD 59 1B             call    OUTC            ; print it
6509+ 3F74 11 2E 40             ld      DE,CHKEY2       ; message ": ""
6510+ 3F77 CD F8 3F             call    PRTCKEY         ; print it
6511+ 3F7A 3E 01                ld      A,$01           ; " opened
6512+ 3F7C 32 A5 55             ld      (TMPBFR1),A
6513+ 3F7F 7E           LDKEY:  ld      A,(HL)          ; retrieve char
6514+ 3F80 A7                   and     A               ; is it zero?
6515+ 3F81 CA 94 3F             jp      Z,CNTLTK        ; yes, go next char
6516+ 3F84 CD E0 3F             call    OPNQT           ; check if quotes are opened
6517+ 3F87 FE 22                cp      $22             ; check if char is "?
6518+ 3F89 CA A9 3F             jp      Z,PRTCHR        ; yes, print "chr$("
6519+ 3F8C FE 0D                cp      CR              ; is it a CR?
6520+ 3F8E CA A9 3F             jp      Z,PRTCHR        ; yes, print "chr$("
6521+ 3F91 CD 59 1B     PRTK3:  call    OUTC            ; no, just print it
6522+ 3F94 23           CNTLTK: inc     HL              ; next char
6523+ 3F95 10 E8                djnz    LDKEY           ; continue until finished
6524+ 3F97 CD CE 3F             call    CLSQT           ; check if quotes are still open
6525+ 3F9A 3E 0D                ld      A,CR            ; go next line
6526+ 3F9C CD 59 1B             call    OUTC            ; print it
6527+ 3F9F 0C                   inc     C               ; next FN key
6528+ 3FA0 79                   ld      A,C             ; check if...
6529+ 3FA1 FE 09                cp      $09             ; finished keys?
6530+ 3FA3 DA 66 3F             jp      C,PRTK4         ; no, repeat 1 more time
6531+ 3FA6 D1                   pop     DE              ; retrieve DE
6532+ 3FA7 E1                   pop     HL              ; retrieve HL
6533+ 3FA8 C9                   ret                     ; return to caller
6534+ 3FA9 E5           PRTCHR: push    HL              ; store HL
6535+ 3FAA CD CE 3F             call    CLSQT           ; check if quotes are closed
6536+ 3FAD 3E 2B                ld      A,'+'           ; '+' char
6537+ 3FAF CD 59 1B             call    OUTC            ; print it
6538+ 3FB2 11 31 40             ld      DE,CHKEY3       ; address of "CHR$("
6539+ 3FB5 CD F8 3F             call    PRTCKEY         ; print it
6540+ 3FB8 E1                   pop     HL              ; recover HL
6541+ 3FB9 23                   inc     HL              ; next char
6542+ 3FBA 05                   dec     B               ; increment char counter
6543+ 3FBB 11 37 40             ld      DE,CHKEY4       ; load address of RETURN
6544+ 3FBE 7E                   ld      A,(HL)          ; load char
6545+ 3FBF FE 0D                cp      CR              ; is it a RETURN?
6546+ 3FC1 20 03                jr      NZ,PTCHR1       ; no, jump over
6547+ 3FC3 11 3A 40             ld      DE,CHKEY5       ; yes, load address of "
6548+ 3FC6 CD F8 3F     PTCHR1: call    PRTCKEY         ; print it
6549+ 3FC9 3E 29                ld      A,')'           ; char )
6550+ 3FCB C3 91 3F             jp      PRTK3           ; continue
6551+ 3FCE F5           CLSQT:  push    AF              ; store A
6552+ 3FCF 3A A5 55             ld      A,(TMPBFR1)     ; quote status
6553+ 3FD2 A7                   and     A               ; are they closed?
6554+ 3FD3 28 09                jr      Z,CLSQT1        ; if yes, return
6555+ 3FD5 3E 22                ld      A,$22           ; no, so close them
6556+ 3FD7 CD 59 1B             call    OUTC            ; print "
6557+ 3FDA AF                   xor     A               ; set quotes
6558+ 3FDB 32 A5 55             ld      (TMPBFR1),A     ; as closed
6559+ 3FDE F1           CLSQT1: pop     AF              ; retrieve A
6560+ 3FDF C9                   ret                     ; return to caller
6561+ 3FE0 F5           OPNQT:  push    AF              ; store A
6562+ 3FE1 3A A5 55             ld      A,(TMPBFR1)     ; quote status
6563+ 3FE4 A7                   and     A               ; are they open?
6564+ 3FE5 20 0F                jr      NZ,OPNQT1       ; if yes, return
6565+ 3FE7 3E 2B                ld      A,'+'           ; no, so add '+
6566+ 3FE9 CD 59 1B             call    OUTC            ; print it
6567+ 3FEC 3E 22                ld      A,$22           ; and then open quotes
6568+ 3FEE CD 59 1B             call    OUTC            ; print them
6569+ 3FF1 3E 01                ld      A,$01           ; set quotes
6570+ 3FF3 32 A5 55             ld      (TMPBFR1),A     ; as opened
6571+ 3FF6 F1           OPNQT1: pop     AF              ; retrieve A
6572+ 3FF7 C9                   ret                     ; return to caller
6573+ 3FF8 F5           PRTCKEY:push    AF              ; store original char
6574+ 3FF9 1A           PRTK1:  ld      A,(DE)          ; load char
6575+ 3FFA A7                   and     A               ; is it 0?
6576+ 3FFB CA 05 40             jp      Z,PRTEND        ; yes, finished printing
6577+ 3FFE CD 59 1B             call    OUTC            ; no, print char
6578+ 4001 13                   inc     DE              ; next char
6579+ 4002 C3 F9 3F             jp      PRTK1           ; repeat
6580+ 4005 F1           PRTEND: pop     AF              ; retrieve AF
6581+ 4006 C9                   ret                     ; return to caller
6582+ 4007 FE 09        SETREP: cp      $09             ; is it special key 9? (stands for auto-repeat)
6583+ 4009 C2 50 18             jp      NZ,SNERR        ; no, raise an error
6584+ 400C CD 4E 1B             call    CHKSYN          ; Check for comma
6585+ 400F 2C                   defb    ','
6586+ 4010 CD AE 2A             call    GETINT          ; get a number
6587+ 4013 32 A5 55             ld      (TMPBFR1),A     ; store it
6588+ 4016 CD 4E 1B             call    CHKSYN          ; Check for comma
6589+ 4019 2C                   defb    ','
6590+ 401A CD AE 2A             call    GETINT          ; get another number
6591+ 401D E5                   push    HL              ; store HL
6592+ 401E 21 57 54             ld      HL,AUTOKE       ; address of second cell for key auto-repeat
6593+ 4021 77                   ld      (HL),A          ; store auto-repeat delay
6594+ 4022 2B                   dec     HL              ; previous cell
6595+ 4023 3A A5 55             ld      A,(TMPBFR1)     ; retrieve value
6596+ 4026 77                   ld      (HL),A          ; store delay for auto-repeat
6597+ 4027 E1                   pop     HL              ; retrieve HL
6598+ 4028 C9                   ret
6599+ 4029 4B 45 59 20  CHKEY1: defb    "KEY ",0
6599+ 402D 00
6600+ 402E 3A 22 00     CHKEY2: defb    ":",34,0
6601+ 4031 63 68 72 24  CHKEY3: defb    "chr$(",0
6601+ 4035 28 00
6602+ 4037 31 33 00     CHKEY4: defb    "13",0
6603+ 403A 33 34 00     CHKEY5: defb    "34",0
6604+ 403D
6605+ 403D
6606+ 403D              ; HEX$(nn) Convert 16 bit number to Hexadecimal string
6607+ 403D CD 2B 22     HEX: 	call	TSTNUM          ; Verify it's a number
6608+ 4040 CD 4D 1E             call	DEINT           ; Get integer -32768 to 32767
6609+ 4043 C5                   push	BC              ; Save contents of BC
6610+ 4044 21 FE 55             ld      HL,PBUFF        ; load address of PBUFF into HL
6611+ 4047 7A                   ld      A,D             ; Get MSB into A
6612+ 4048 B7                   or      A               ; OR with LSB to see if param=0
6613+ 4049 28 0C                jr      Z,HEX2          ; Skip output if both high digits are zero
6614+ 404B CD 73 40             call    BYT2ASC         ; Convert D to ASCII
6615+ 404E 78                   ld      A,B             ; cechk if B
6616+ 404F FE 30                cp      '0'             ; is 0
6617+ 4051 28 02                jr      Z,HEX1          ; Don't store high digit if zero
6618+ 4053 70                   ld      (HL),B          ; Store it to PBUFF
6619+ 4054 23                   inc     HL              ; Next location
6620+ 4055 71           HEX1:   ld      (HL),C          ; Store C to PBUFF+1
6621+ 4056 23                   inc     HL              ; Next location
6622+ 4057 7B           HEX2:   ld      A,E             ; Get lower byte
6623+ 4058 CD 73 40             call    BYT2ASC         ; Convert E to ASCII
6624+ 405B 7A                   ld      A,D
6625+ 405C B7                   or      A
6626+ 405D 20 05                jr      NZ,HEX3         ; If upper byte was not zero then always print lower byte
6627+ 405F 78                   ld      A,B
6628+ 4060 FE 30                cp      '0'             ; If high digit of lower byte is zero then don't print
6629+ 4062 28 02                jr      Z,HEX4
6630+ 4064 70           HEX3:   ld      (HL),B          ; to PBUFF+2
6631+ 4065 23                   inc     HL              ; Next location
6632+ 4066 71           HEX4:   ld      (HL),C          ; to PBUFF+3
6633+ 4067 23                   inc     HL              ; PBUFF+4 to zero
6634+ 4068 AF                   xor     A               ; Terminating character
6635+ 4069 77                   ld      (HL),A          ; Store zero to terminate
6636+ 406A 23                   inc     HL              ; Make sure PBUFF is terminated
6637+ 406B 77                   ld      (HL),A          ; Store the double zero there
6638+ 406C C1                   pop     BC              ; Get BC back
6639+ 406D 21 FE 55             ld      HL,PBUFF        ; Reset to start of PBUFF
6640+ 4070 C3 C0 26             jp      STR1            ; Convert the PBUFF to a string and return it
6641+ 4073 47           BYT2ASC:ld      B,A             ; Save original value
6642+ 4074 E6 0F                and     $0F             ; Strip off upper nybble
6643+ 4076 FE 0A                cp      $0A             ; 0-9?
6644+ 4078 38 02                jr      C,ADD30         ; If A-F, add 7 more
6645+ 407A C6 07                add     A,$07           ; Bring value up to ASCII A-F
6646+ 407C C6 30        ADD30:  add     A,$30           ; And make ASCII
6647+ 407E 4F                   ld      C,A             ; Save converted char to C
6648+ 407F 78                   ld      A,B             ; Retrieve original value
6649+ 4080 0F                   rrca                    ; and Rotate it right
6650+ 4081 0F                   rrca
6651+ 4082 0F                   rrca
6652+ 4083 0F                   rrca
6653+ 4084 E6 0F                and     $0F             ; Mask off upper nybble
6654+ 4086 FE 0A                cp      $0A             ; 0-9? < A hex?
6655+ 4088 38 02                jr      C,ADD301        ; Skip Add 7
6656+ 408A C6 07                add     A,$07           ; Bring it up to ASCII A-F
6657+ 408C C6 30        ADD301: add     A,$30           ; And make it full ASCII
6658+ 408E 47                   ld      B,A             ; Store high order byte
6659+ 408F C9                   ret
6660+ 4090
6661+ 4090              ; Convert "&Hnnnn" to FPREG
6662+ 4090              ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
6663+ 4090              ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
6664+ 4090 EB           HEXTFP: ex      DE,HL           ; Move code string pointer to DE
6665+ 4091 21 00 00             ld      HL,$0000        ; Zero out the value
6666+ 4094 CD A9 40             call    GETHEX          ; Check the number for valid hex
6667+ 4097 DA C9 40             jp      C,HXERR         ; First value wasn't hex, HEX error
6668+ 409A 18 05                jr      HEXLP1          ; Convert first character
6669+ 409C CD A9 40     HEXLP:  call    GETHEX          ; Get second and addtional characters
6670+ 409F 38 1F                jr      C,HEXIT         ; Exit if not a hex character
6671+ 40A1 29           HEXLP1: add     HL,HL           ; Rotate 4 bits to the left
6672+ 40A2 29                   add     HL,HL
6673+ 40A3 29                   add     HL,HL
6674+ 40A4 29                   add     HL,HL
6675+ 40A5 B5                   or      L               ; Add in D0-D3 into L
6676+ 40A6 6F                   ld      L,A             ; Save new value
6677+ 40A7 18 F3                jr      HEXLP           ; And continue until all hex characters are in
6678+ 40A9
6679+ 40A9 13           GETHEX: inc     DE              ; Next location
6680+ 40AA 1A                   ld      A,(DE)          ; Load character at pointer
6681+ 40AB FE 20                cp      SPC
6682+ 40AD CA A9 40             jp      Z,GETHEX        ; Skip spaces
6683+ 40B0 D6 30                sub     $30             ; Get absolute value
6684+ 40B2 D8                   ret     C               ; < "0", error
6685+ 40B3 FE 0A                cp      $0A
6686+ 40B5 38 05                jr      C,NOSUB7        ; Is already in the range 0-9
6687+ 40B7 D6 07                sub     $07             ; Reduce to A-F
6688+ 40B9 FE 0A                cp      $0A             ; Value should be $0A-$0F at this point
6689+ 40BB D8                   ret     C               ; CY set if was :            ; < = > ? @
6690+ 40BC FE 10        NOSUB7: cp      $10             ; > Greater than "F"?
6691+ 40BE 3F                   ccf
6692+ 40BF C9                   ret                     ; CY set if it wasn't valid hex
6693+ 40C0
6694+ 40C0 EB           HEXIT:  ex      DE,HL           ; Value into DE, Code string into HL
6695+ 40C1 7A                   ld      A,D             ; Load DE into AC
6696+ 40C2 4B                   ld      C,E             ; For prep to
6697+ 40C3 E5                   push    HL
6698+ 40C4 CD 11 26             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6699+ 40C7 E1                   pop     HL
6700+ 40C8 C9                   ret
6701+ 40C9
6702+ 40C9 1E 26        HXERR:  ld      E,HE            ; ?HEX Error
6703+ 40CB C3 6A 18             jp      ERROR
6704+ 40CE
6705+ 40CE              ; BIN$(NN) Convert integer to a 1-16 char binary string
6706+ 40CE CD 2B 22     BIN:    call    TSTNUM          ; Verify it's a number
6707+ 40D1 CD 4D 1E             call    DEINT           ; Get integer -32768 to 32767
6708+ 40D4 C5                   push    BC              ; Save contents of BC
6709+ 40D5 21 FE 55             ld      HL,PBUFF
6710+ 40D8 06 11                ld      B,$11           ; One higher than max char count (16+1)
6711+ 40DA                      ; Suppress leading zeros
6712+ 40DA 05           ZEROSUP:dec     B               ; Max 16 chars
6713+ 40DB 78                   ld      A,B
6714+ 40DC FE 01                cp      $01
6715+ 40DE 28 08                jr      Z,BITOUT        ; Always output at least one character
6716+ 40E0 CB 13                rl      E
6717+ 40E2 CB 12                rl      D
6718+ 40E4 30 F4                jr      NC,ZEROSUP
6719+ 40E6 18 04                jr      BITOUT2
6720+ 40E8 CB 13        BITOUT: rl      E
6721+ 40EA CB 12                rl      D               ; Top bit now in carry
6722+ 40EC 3E 30        BITOUT2:ld      A,'0'           ; Char for '0'
6723+ 40EE CE 00                adc     A,$00           ; If carry set then '0' --> '1'
6724+ 40F0 77                   ld      (HL),A
6725+ 40F1 23                   inc     HL
6726+ 40F2 05                   dec     B
6727+ 40F3 20 F3                jr      NZ,BITOUT
6728+ 40F5 AF                   xor     A               ; Terminating character
6729+ 40F6 77                   ld      (HL),A          ; Store zero to terminate
6730+ 40F7 23                   inc     HL              ; Make sure PBUFF is terminated
6731+ 40F8 77                   ld      (HL),A          ; Store the double zero there
6732+ 40F9 C1                   pop     BC
6733+ 40FA 21 FE 55             ld      HL,PBUFF
6734+ 40FD C3 C0 26             jp      STR1
6735+ 4100
6736+ 4100              ; Convert "&Bnnnn" to FPREG
6737+ 4100              ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
6738+ 4100 EB           BINTFP: ex      DE,HL           ; Move code string pointer to DE
6739+ 4101 21 00 00             ld      HL,$0000        ; Zero out the value
6740+ 4104 CD 1D 41             call    CHKBIN          ; Check the number for valid bin
6741+ 4107 DA 2B 41             jp      C,BINERR        ; First value wasn't bin, BIN error
6742+ 410A D6 30        BINIT:  sub     '0'
6743+ 410C 29                   add     HL,HL           ; Rotate HL left
6744+ 410D B5                   or      L
6745+ 410E 6F                   ld      L,A
6746+ 410F CD 1D 41             call    CHKBIN          ; Get second and addtional characters
6747+ 4112 30 F6                jr      NC,BINIT        ; Process if a bin character
6748+ 4114 EB                   ex      DE,HL           ; Value into DE, Code string into HL
6749+ 4115 7A                   ld      A,D             ; Load DE into AC
6750+ 4116 4B                   ld      C,E             ; For prep to
6751+ 4117 E5                   push    HL
6752+ 4118 CD 11 26             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6753+ 411B E1                   pop     HL
6754+ 411C C9                   ret
6755+ 411D
6756+ 411D              ; Char is in A, NC if char is 0 or 1
6757+ 411D 13           CHKBIN: inc     DE
6758+ 411E 1A                   ld      A,(DE)
6759+ 411F FE 20                cp      SPC
6760+ 4121 CA 1D 41             jp      Z,CHKBIN        ; Skip spaces
6761+ 4124 FE 30                cp      '0'             ; Set C if < '0'
6762+ 4126 D8                   ret     C
6763+ 4127 FE 32                cp      '2'
6764+ 4129 3F                   ccf                     ; Set C if > '1'
6765+ 412A C9                   ret
6766+ 412B
6767+ 412B 1E 28        BINERR: ld      E,BN            ; ?BIN Error
6768+ 412D C3 6A 18             jp      ERROR
6769+ 4130
6770+ 4130
6771+ 4130 C3 08 00     MONOUT: jp      $0008           ; output a char
6772+ 4133
6773+ 4133
6774+ 4133 1E 00        RESET:  ld      E,$00           ; full RESET
6775+ 4135 CD C9 2A     RESET2: call    DISNMI          ; disable NMI vector
6776+ 4138 3A E7 55             ld      A,(SERIALS_EN)  ; load status of serial lines
6777+ 413B E6 11                and     $11             ; are serial ports open?
6778+ 413D C4 A9 3C             call    NZ,RSTSERS      ; yes, reset serials
6779+ 4140 3A EA 55             ld      A,(DOS_EN)      ; check DOS status
6780+ 4143 A7                   and     A               ; DOS enabled?
6781+ 4144 28 0A                jr      Z,RESETE        ; no, jump over
6782+ 4146 CD 49 FD             call    CF_STANDBY      ; yes, put CF into standby mode
6783+ 4149 AF                   xor     A
6784+ 414A 32 D4 FF             ld      (SEQFL),A       ; close any seq. file opened
6785+ 414D 7B                   ld      A,E
6786+ 414E B7                   or      A
6787+ 414F C0                   ret     NZ              ; return if called from soft reset (C= + CTRL)
6788+ 4150 F3           RESETE: di                      ; disable INTs
6789+ 4151 C3 6C 53             jp      ROM2RAM         ; Restart
6790+ 4154
6791+ 4154
6792+ 4154 AF           INITST: xor     A              ; Clear break flag
6793+ 4155 32 4C 54             ld      (BRKFLG),A
6794+ 4158 C3 0E 13             jp      SYSINIT
6795+ 415B
6796+ 415B
6797+ 415B CD 59 1B     OUTNCR: call    OUTC            ; Output character in A
6798+ 415E C3 64 20             jp      PRNTCRLF        ; Output CRLF
6799+ 4161
# file closed: ../include/basic/basic-1.14.asm
  76  4161
  77  4161              ; include utils
  78  4161                  INCLUDE "../include/utils/utils-r1.2.asm"
# file opened: ../include/utils/utils-r1.2.asm
   1+ 4161              ; ------------------------------------------------------------------------------
   2+ 4161              ; LM80C - UTILITY ROUTINES - R1.2
   3+ 4161              ; ------------------------------------------------------------------------------
   4+ 4161              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4161              ; designed by Leonardo Miliani. More info at
   6+ 4161              ; www DOT leonardomiliani DOT com
   7+ 4161              ;
   8+ 4161              ; *ALS are routines from "Z80 Assembly Language Subroutines" by Lance
   9+ 4161              ; A. Leventhal and Winthrop Saville - Ed. Osborne/McGraw-Hill (1983)
  10+ 4161              ;
  11+ 4161              ; * WKT are routines from WikiTI:
  12+ 4161              ; http://wikiti.brandonw.net/index.php?title=WikiTI_Home
  13+ 4161              ;
  14+ 4161              ; * LAC are routines from Learn@Cemetch
  15+ 4161              ; https://learn.cemetech.net/index.php/Main_Page
  16+ 4161              ;
  17+ 4161              ; ------------------------------------------------------------------------------
  18+ 4161              ; Code Revision:
  19+ 4161              ; R1.0 - 20200110 - First release: 16-bit comparision/multiplication/negation
  20+ 4161              ; R1.1 - 20200413 - Second release: added ABS(HL)
  21+ 4161              ; R1.2 - 20200131 - Added 32/16 bit multiplication/division and converter to
  22+ 4161              ;                   transform a 32-bit value into ASCII representation
  23+ 4161              ;
  24+ 4161              ; ------------------------------------------------------------------------------
  25+ 4161
  26+ 4161              ; compare two 16-bit registers, HL (minuend) and DE (subtrahend)
  27+ 4161              ; values can be both signed or unsigned words
  28+ 4161              ; inputs: HL, DE
  29+ 4161              ; destroys: A,F,HL
  30+ 4161              ;
  31+ 4161              ; returns: Z=1 if HL = DE
  32+ 4161              ; for UNSIGNED: C=1 if HL<DE  //  C=0 if HL>DE
  33+ 4161              ; for SIGNED:   S=1 (M) if HL<DE  //  S=0 (P) if HL>DE
  34+ 4161              ; if HL=DE: Z,P,NC  - Z=1, S=0; C=0
  35+ 4161              ; if HL>DE: NZ,P,NC - Z=0, S=0; C=0
  36+ 4161              ; if HL<DE: NZ,M,C  - Z=0, S=1; C=1
  37+ 4161              ; Source: ALS
  38+ 4161
  39+ 4161 B7           CMP16:  or      A           ; clear CARRY
  40+ 4162 ED 52                sbc     HL,DE       ; subtract DE from HL
  41+ 4164 E0                   ret     PO          ; return if no overflow
  42+ 4165 7C                   ld      A,H         ; overflow - invert SIGN flag
  43+ 4166 1F                   rra                 ; save CARRY flag in bit 7
  44+ 4167 EE 40                xor     %01000000   ; complement bit 6 (SIGN bit)
  45+ 4169 37                   scf                 ; ensure a Non-Zero result
  46+ 416A 8F                   adc     A,A         ; restore CARRY, complemented SIGN
  47+ 416B                                          ; ZERO flag = 0 for sure
  48+ 416B C9                   ret                 ; return
  49+ 416C
  50+ 416C              ; ----------------------------------------------------------------------
  51+ 416C
  52+ 416C              ; multiply 2 signed/unsigned 16-bit words and return a 16-bit
  53+ 416C              ; signed/unsigned product
  54+ 416C              ; inputs: HL (multiplicand); DE (multiplier)
  55+ 416C              ; destroys: A,F
  56+ 416C              ; returns: HL (product)
  57+ 416C              ; Source: ALS
  58+ 416C
  59+ 416C              ; initialize partial product, bit count
  60+ 416C C5           MUL16:  push    BC
  61+ 416D 4D                   ld      C,L         ; BC = multiplier
  62+ 416E 44                   ld      B,H
  63+ 416F 21 00 00             ld      HL,0        ; product = 0
  64+ 4172 3E 0F                ld      A,$0F       ; count = bit lenght - 1 (16-1)
  65+ 4174                      ; shift-and-add algorithm
  66+ 4174                      ; if MSB of multiplier is 1, add multiplicand to partial product
  67+ 4174                      ; shift partial product, multiplier left 1 bit
  68+ 4174 CB 23        MLP:    sla     E           ; shift multiplier left 1 bit
  69+ 4176 CB 12                rl      D
  70+ 4178 30 01                jr      NC,MLP1     ; jump if MSB of multiplier = 0
  71+ 417A 09                   add     HL,BC       ; add multiplicand to partial product
  72+ 417B 29           MLP1:   add     HL,HL       ; shift partial product left
  73+ 417C 3D                   dec     A
  74+ 417D 20 F5                jr      NZ,MLP      ; continue until count = 0
  75+ 417F                      ; add multiplicand one last time if MSB of multiplier is 1
  76+ 417F B2                   or      D           ; sign flag = MSB of multiplier
  77+ 4180 F2 84 41             jp      P,EXMUL16   ; exit if MSB of multiplier is 0
  78+ 4183 09                   add     HL,BC       ; add multiplicand to product
  79+ 4184 C1           EXMUL16:pop     BC
  80+ 4185 C9                   ret
  81+ 4186
  82+ 4186
  83+ 4186              ; ----------------------------------------------------------------------
  84+ 4186
  85+ 4186              ; multiply 2 unsigned 16-bit words and return a 32-bit unsigned product
  86+ 4186              ; inputs: BC (multiplicand); DE (multiplier)
  87+ 4186              ; destroys: A,F
  88+ 4186              ; operation: BC * DE
  89+ 4186              ; returns: DEHL (product)
  90+ 4186              ; Source: WKT
  91+ 4186
  92+ 4186 21 00 00     MUL_U32:ld      HL,$0000        ; reset HL
  93+ 4189 CB 23                sla     E		; optimised 1st iteration
  94+ 418B CB 12                rl      D
  95+ 418D 30 02                jr      NC,MU32_1       ; if no Carry then jump over
  96+ 418F 60                   ld      H,B
  97+ 4190 69                   ld      L,C
  98+ 4191 3E 0F        MU32_1: ld      A,$0F
  99+ 4193 29           MUL_32L:add     HL,HL           ; main loop
 100+ 4194 CB 13                rl      E
 101+ 4196 CB 12                rl      D
 102+ 4198 30 04                jr      NC,MU32_2
 103+ 419A 09                   add     HL,BC
 104+ 419B 30 01                jr      NC,MU32_2
 105+ 419D 13                   inc     DE
 106+ 419E 3D           MU32_2: dec     A
 107+ 419F 20 F2                jr      NZ,MUL_32L
 108+ 41A1 C9                   ret
 109+ 41A2
 110+ 41A2              ; ----------------------------------------------------------------------
 111+ 41A2              ; absolute value of HL (same applies to other 16-bit register pairs)
 112+ 41A2              ; also, invert value of HL (or any other 16-bit register, just adjust the code)
 113+ 41A2              ;
 114+ 41A2              ; inputs: HL
 115+ 41A2              ; destroys: A
 116+ 41A2              ; operation: ABS(HL)
 117+ 41A2              ; returns: HL with no sign or negated
 118+ 41A2              ; Source: WKT
 119+ 41A2
 120+ 41A2 CB 7C        absHL:  bit     7,H
 121+ 41A4 C8                   ret     Z
 122+ 41A5 AF           negHL:  xor     A
 123+ 41A6 95                   sub     L
 124+ 41A7 6F                   ld      L,A
 125+ 41A8 9F                   sbc     A,A
 126+ 41A9 94                   sub     H
 127+ 41AA 67                   ld      H,A
 128+ 41AB C9                   ret
 129+ 41AC
 130+ 41AC              ; ------------------------------------------------------------------------------
 131+ 41AC
 132+ 41AC              ; 8/8 division
 133+ 41AC              ; INPUT: D (dividend), E (divisor)
 134+ 41AC              ; OPERATION: D/E
 135+ 41AC              ; OUTPUT: D (quotient), A (remainder)
 136+ 41AC AF           DIV_8_8:    xor     A
 137+ 41AD C5                       push    BC
 138+ 41AE 06 08                    ld      B,08h
 139+ 41B0 CB 22        DIV_8_8LOOP:sla     D
 140+ 41B2 17                       rla
 141+ 41B3 BB                       cp      E
 142+ 41B4 38 02                    jr      C,$+4
 143+ 41B6 93                       sub     E
 144+ 41B7 14                       inc     D
 145+ 41B8 10 F6                    djnz    DIV_8_8LOOP
 146+ 41BA C1                       pop     BC
 147+ 41BB C9                       ret
 148+ 41BC
 149+ 41BC              ; ----------------------------------------------------------------------
 150+ 41BC              ; divide a 16-bit number by an 8-bit number
 151+ 41BC              ; (16/8 division)
 152+ 41BC              ;
 153+ 41BC              ; inputs: HL (Dividend), C (divisor)
 154+ 41BC              ; destroys: A, B
 155+ 41BC              ; OPERATION: HL/C
 156+ 41BC              ; returns: HL (quotient), A (remainder)
 157+ 41BC              ; source: WKT
 158+ 41BC
 159+ 41BC AF           DIV_16_8:   xor     A
 160+ 41BD 06 10                    ld      B,16
 161+ 41BF 29           DIV_16_8LP: add     HL,HL
 162+ 41C0 17                       rla
 163+ 41C1 38 03                    jr      C,$+5
 164+ 41C3 B9                       cp      C
 165+ 41C4 38 02                    jr      C,$+4
 166+ 41C6 91                       sub     C
 167+ 41C7 2C                       inc     L
 168+ 41C8 10 F5                    djnz    DIV_16_8LP
 169+ 41CA C9                       ret
 170+ 41CB
 171+ 41CB              ; ----------------------------------------------------------------------
 172+ 41CB              ; divide a 16-bit number by a 16-bit number
 173+ 41CB              ; (16/16 division)
 174+ 41CB              ;
 175+ 41CB              ; inputs: AC (Dividend), DE (divisor)
 176+ 41CB              ; destroys: HL,A,C
 177+ 41CB              ; OPERATION: AC/DE
 178+ 41CB              ; returns: AC (quotient), HL (remainder)
 179+ 41CB              ; source: WKT
 180+ 41CB 21 00 00     DIV_16_16:  ld      HL, 0
 181+ 41CE 06 10                    ld      B, 16
 182+ 41D0 CB 21        DV16_16_LP: sla     C
 183+ 41D2 CB C1                    set     0,C         ; this simulates the SLL undocumented instruction
 184+ 41D4 17                       rla
 185+ 41D5 ED 6A                    adc     HL,HL
 186+ 41D7 ED 52                    sbc     HL,DE
 187+ 41D9 30 02                    jr      NC, $+4
 188+ 41DB 19                       add     HL,DE
 189+ 41DC 0D                       dec     C
 190+ 41DD 10 F1                    djnz    DV16_16_LP
 191+ 41DF C9                       ret
 192+ 41E0
 193+ 41E0
 194+ 41E0              ; ----------------------------------------------------------------------
 195+ 41E0              ; divide a 32-bit number by a 16 bit-number
 196+ 41E0              ; (32/16 division)
 197+ 41E0              ;
 198+ 41E0              ; inputs: ACIX (Dividend), DE (divisor)
 199+ 41E0              ; destroys: HL,IX,BC
 200+ 41E0              ; OPERATION: ACIX/DE
 201+ 41E0              ; returns: ACIX (quotient), HL (remainder)
 202+ 41E0              ; source: WKT
 203+ 41E0
 204+ 41E0 21 00 00     DIV_32_16:  ld      HL,0
 205+ 41E3 06 20                    ld      B,32
 206+ 41E5 DD 29        DIV_32_16LP:add     IX,IX
 207+ 41E7 CB 11                    rl      C
 208+ 41E9 17                       rla
 209+ 41EA ED 6A                    adc     HL,HL
 210+ 41EC 38 08                    jr      C,DIV_32_16OF
 211+ 41EE ED 52                    sbc     HL,DE
 212+ 41F0 30 07                    jr      NC,DIV_32_16SB
 213+ 41F2 19                       add     HL,DE
 214+ 41F3 10 F0                    djnz    DIV_32_16LP
 215+ 41F5 C9                       ret
 216+ 41F6 B7           DIV_32_16OF:or      A                   ; overflow
 217+ 41F7 ED 52                    sbc     HL,DE
 218+ 41F9 DD 23        DIV_32_16SB:inc     IX                  ; set bit
 219+ 41FB 10 E8                    djnz    DIV_32_16LP
 220+ 41FD C9                       ret
 221+ 41FE
 222+ 41FE
 223+ 41FE              ; ----------------------------------------------------------------------
 224+ 41FE              ; convert a 32-bit number in ASCII string (terminated by '0')
 225+ 41FE              ;
 226+ 41FE              ; inputs: DEIX (Value), IY (dest. address in memory)
 227+ 41FE              ; destroys: AF, BC, DE, HL, IX
 228+ 41FE              ; outputs: IY (last char in dest. string)
 229+ 41FE              ; source: MSX Forum
 230+ 41FE
 231+ 41FE 01 00 00 00  CLCN32T:    defw    1,0,10,0,100,0,1000,0,10000,0
 231+ 4202 0A 00 00 00
 231+ 4206 64 00 00 00
 231+ 420A E8 03 00 00
 231+ 420E 10 27 00 00
 232+ 4212 A0 86 01 00              defw    $86A0,$1,$4240,$F,$9680,$98,$E100,$5F5,$CA00,$3B9A
 232+ 4216 40 42 0F 00
 232+ 421A 80 96 98 00
 232+ 421E 00 E1 F5 05
 232+ 4222 00 CA 9A 3B
 233+ 4226 00 00 00 00  CLCN32Z:    defs    4
 234+ 422A
 235+ 422A DD 22 26 42  CLCN32:     ld      (CLCN32Z),IX
 236+ 422E ED 53 28 42              ld      (CLCN32Z+$02),DE
 237+ 4232 DD 21 22 42              ld      IX,CLCN32T+$24
 238+ 4236 06 09                    ld      B,$09
 239+ 4238 0E 00                    ld      C,$00
 240+ 423A 3E 30        CLCN321:    ld      A,"0"
 241+ 423C B7                       or      A
 242+ 423D DD 5E 00     CLCN322:    ld      E,(IX+$00)
 243+ 4240 DD 56 01                 ld      D,(IX+$01)
 244+ 4243 2A 26 42                 ld      HL,(CLCN32Z)
 245+ 4246 ED 52                    sbc     HL,DE
 246+ 4248 22 26 42                 ld      (CLCN32Z),HL
 247+ 424B DD 5E 02                 ld      E,(IX+$02)
 248+ 424E DD 56 03                 ld      D,(IX+$03)
 249+ 4251 2A 28 42                 ld      HL,(CLCN32Z+$02)
 250+ 4254 ED 52                    sbc     HL,DE
 251+ 4256 22 28 42                 ld      (CLCN32Z+$02),HL
 252+ 4259 38 04                    jr      C,CLCN325
 253+ 425B 0C                       inc     C
 254+ 425C 3C                       inc     A
 255+ 425D 18 DE                    jr      CLCN322
 256+ 425F DD 5E 00     CLCN325:    ld      E,(IX+$00)
 257+ 4262 DD 56 01                 ld      D,(IX+$01)
 258+ 4265 2A 26 42                 ld      HL,(CLCN32Z)
 259+ 4268 19                       add     HL,DE
 260+ 4269 22 26 42                 ld      (CLCN32Z),HL
 261+ 426C DD 5E 02                 ld      E,(IX+$02)
 262+ 426F DD 56 03                 ld      D,(IX+$03)
 263+ 4272 2A 28 42                 ld      HL,(CLCN32Z+$02)
 264+ 4275 ED 5A                    adc     HL,DE
 265+ 4277 22 28 42                 ld      (CLCN32Z+$02),HL
 266+ 427A 11 FC FF                 ld      DE,-4
 267+ 427D DD 19                    add     IX,DE
 268+ 427F 0C                       inc     C
 269+ 4280 0D                       dec     C
 270+ 4281 28 05                    jr      Z,CLCN323
 271+ 4283 FD 77 00                 ld      (IY+$00),A
 272+ 4286 FD 23                    inc     IY
 273+ 4288 10 B0        CLCN323:    djnz    CLCN321
 274+ 428A 3A 26 42                 ld      A,(CLCN32Z)
 275+ 428D C6 30                    add     "0"
 276+ 428F FD 77 00                 ld      (IY+$00),A
 277+ 4292 FD 36 01 00              ld      (IY+$01),0
 278+ 4296 C9                       ret
# file closed: ../include/utils/utils-r1.2.asm
  79  4297
  80  4297              ; include the latest version of the font sets
  81  4297                  INCLUDE "../include/vdp/6x8fonts-r16.asm"
# file opened: ../include/vdp/6x8fonts-r16.asm
   1+ 4297              ; ------------------------------------------------------------------------------
   2+ 4297              ; LM80C - 6x8 CHARSET - R1.6
   3+ 4297              ; ------------------------------------------------------------------------------
   4+ 4297              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4297              ; designed by Leonardo Miliani. More info at
   6+ 4297              ; www DOT leonardomiliani DOT com
   7+ 4297              ; ------------------------------------------------------------------------------
   8+ 4297              ; Code Revision:
   9+ 4297              ; R1.0 - 20190511 - First revision: ASCII chars (from 0 to 127)
  10+ 4297              ; R1.1 - 20190521 - Expanded to 255 chars
  11+ 4297              ; R1.2 - 20191209 - Start adding graphic chars to be coherent with 8x8 fonts
  12+ 4297              ; R1.3 - 20191226 - Added extended char codes (128-255)
  13+ 4297              ; R1.4 - 20200228 - adopted more usual hexadecimal & binary prefixes
  14+ 4297              ; R1.5 - 20200524 - New style for char #252
  15+ 4297              ; R1.6 - 20200704 - Redefined chars 105, 106, and 252
  16+ 4297              ; ------------------------------------------------------------------------------
  17+ 4297              ;
  18+ 4297              ;-------------------------------------------------------------------------------
  19+ 4297              ;
  20+ 4297              ;               6 x 8    C  H  A  R  S  E  T
  21+ 4297              ;
  22+ 4297              ;-------------------------------------------------------------------------------
  23+ 4297              ;
  24+ 4297              ;       6X8 CHARS, DESIGNED FOR TEXT BUT USABLE IN GRAPHICS 1 MODE TOO
  25+ 4297              ;       UPDATE: NOW GRAPHICS 1 MODE HAS ITS OWN CHAR SET
  26+ 4297
  27+ 4297              CHRST68 equ $
  28+ 4297 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  28+ 429B 00 00 00 00
  29+ 429F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  29+ 42A3 00 00 00 00
  30+ 42A7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  30+ 42AB 00 00 00 00
  31+ 42AF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  31+ 42B3 00 00 00 00
  32+ 42B7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  32+ 42BB 00 00 00 00
  33+ 42BF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  33+ 42C3 00 00 00 00
  34+ 42C7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  34+ 42CB 00 00 00 00
  35+ 42CF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  35+ 42D3 00 00 00 00
  36+ 42D7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
  36+ 42DB 00 00 00 00
  37+ 42DF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  37+ 42E3 00 00 00 00
  38+ 42E7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  38+ 42EB 00 00 00 00
  39+ 42EF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11
  39+ 42F3 00 00 00 00
  40+ 42F7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  40+ 42FB 00 00 00 00
  41+ 42FF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
  41+ 4303 00 00 00 00
  42+ 4307 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
  42+ 430B 00 00 00 00
  43+ 430F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  43+ 4313 00 00 00 00
  44+ 4317 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  44+ 431B 00 00 00 00
  45+ 431F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  45+ 4323 00 00 00 00
  46+ 4327 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  46+ 432B 00 00 00 00
  47+ 432F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  47+ 4333 00 00 00 00
  48+ 4337 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
  48+ 433B 00 00 00 00
  49+ 433F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  49+ 4343 00 00 00 00
  50+ 4347 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
  50+ 434B 00 00 00 00
  51+ 434F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
  51+ 4353 00 00 00 00
  52+ 4357 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
  52+ 435B 00 00 00 00
  53+ 435F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
  53+ 4363 00 00 00 00
  54+ 4367 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
  54+ 436B 00 00 00 00
  55+ 436F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
  55+ 4373 00 00 00 00
  56+ 4377 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
  56+ 437B 00 00 00 00
  57+ 437F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
  57+ 4383 00 00 00 00
  58+ 4387 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
  58+ 438B 00 00 00 00
  59+ 438F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
  59+ 4393 00 00 00 00
  60+ 4397 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32: space
  60+ 439B 00 00 00 00
  61+ 439F 20 20 20 20          defb $20,$20,$20,$20,$20,$00,$20,$00 ; char 33: !
  61+ 43A3 20 00 20 00
  62+ 43A7 50 50 00 00          defb $50,$50,$00,$00,$00,$00,$00,$00 ; char 34: "
  62+ 43AB 00 00 00 00
  63+ 43AF 50 50 F8 50          defb $50,$50,$f8,$50,$f8,$50,$50,$00 ; char 35: #
  63+ 43B3 F8 50 50 00
  64+ 43B7 20 78 A0 70          defb $20,$78,$a0,$70,$28,$f0,$20,$00 ; char 36: $
  64+ 43BB 28 F0 20 00
  65+ 43BF C0 C8 10 20          defb $c0,$c8,$10,$20,$40,$98,$18,$00 ; char 37: %
  65+ 43C3 40 98 18 00
  66+ 43C7 60 90 A0 40          defb $60,$90,$a0,$40,$a8,$90,$68,$00 ; char 38: &
  66+ 43CB A8 90 68 00
  67+ 43CF 60 20 40 00          defb $60,$20,$40,$00,$00,$00,$00,$00 ; char 39: '
  67+ 43D3 00 00 00 00
  68+ 43D7 10 20 40 40          defb $10,$20,$40,$40,$40,$20,$10,$00 ; char 40: (
  68+ 43DB 40 20 10 00
  69+ 43DF 40 20 10 10          defb $40,$20,$10,$10,$10,$20,$40,$00 ; char 41: )
  69+ 43E3 10 20 40 00
  70+ 43E7 00 20 A8 70          defb $00,$20,$a8,$70,$a8,$20,$00,$00 ; char 42: *
  70+ 43EB A8 20 00 00
  71+ 43EF 00 20 20 F8          defb $00,$20,$20,$f8,$20,$20,$00,$00 ; char 43: +
  71+ 43F3 20 20 00 00
  72+ 43F7 00 00 00 00          defb $00,$00,$00,$00,$60,$20,$40,$00 ; char 44: ,
  72+ 43FB 60 20 40 00
  73+ 43FF 00 00 00 F8          defb $00,$00,$00,$f8,$00,$00,$00,$00 ; char 45: -
  73+ 4403 00 00 00 00
  74+ 4407 00 00 00 00          defb $00,$00,$00,$00,$00,$60,$60,$00 ; char 46: .
  74+ 440B 00 60 60 00
  75+ 440F 00 08 10 20          defb $00,$08,$10,$20,$40,$80,$00,$00 ; char 47: /
  75+ 4413 40 80 00 00
  76+ 4417 70 88 98 A8          defb $70,$88,$98,$a8,$c8,$88,$70,$00 ; char 48: 0
  76+ 441B C8 88 70 00
  77+ 441F 20 60 20 20          defb $20,$60,$20,$20,$20,$20,$70,$00 ; char 49: 1
  77+ 4423 20 20 70 00
  78+ 4427 70 88 08 10          defb $70,$88,$08,$10,$20,$40,$f8,$00 ; char 50: 2
  78+ 442B 20 40 F8 00
  79+ 442F F8 10 20 10          defb $f8,$10,$20,$10,$08,$88,$70,$00 ; char 51: 3
  79+ 4433 08 88 70 00
  80+ 4437 10 30 50 90          defb $10,$30,$50,$90,$f8,$10,$10,$00 ; char 52: 4
  80+ 443B F8 10 10 00
  81+ 443F F8 80 F0 08          defb $f8,$80,$f0,$08,$08,$88,$70,$00 ; char 53: 5
  81+ 4443 08 88 70 00
  82+ 4447 30 40 80 F0          defb $30,$40,$80,$f0,$88,$88,$70,$00 ; char 54: 6
  82+ 444B 88 88 70 00
  83+ 444F F8 08 10 20          defb $f8,$08,$10,$20,$40,$40,$40,$00 ; char 55: 7
  83+ 4453 40 40 40 00
  84+ 4457 70 88 88 70          defb $70,$88,$88,$70,$88,$88,$70,$00 ; char 56: 8
  84+ 445B 88 88 70 00
  85+ 445F 70 88 88 78          defb $70,$88,$88,$78,$08,$10,$60,$00 ; char 57: 9
  85+ 4463 08 10 60 00
  86+ 4467 00 30 30 00          defb $00,$30,$30,$00,$30,$30,$00,$00 ; char 58: :
  86+ 446B 30 30 00 00
  87+ 446F 00 30 30 00          defb $00,$30,$30,$00,$30,$10,$20,$00 ; char 59: ;
  87+ 4473 30 10 20 00
  88+ 4477 10 20 40 80          defb $10,$20,$40,$80,$40,$20,$10,$00 ; char 60: <
  88+ 447B 40 20 10 00
  89+ 447F 00 00 F8 00          defb $00,$00,$f8,$00,$f8,$00,$00,$00 ; char 61: =
  89+ 4483 F8 00 00 00
  90+ 4487 40 20 10 08          defb $40,$20,$10,$08,$10,$20,$40,$00 ; char 62: >
  90+ 448B 10 20 40 00
  91+ 448F 70 88 08 10          defb $70,$88,$08,$10,$20,$00,$20,$00 ; char 63: ?
  91+ 4493 20 00 20 00
  92+ 4497 70 88 08 68          defb $70,$88,$08,$68,$a8,$a8,$70,$00 ; char 64: @
  92+ 449B A8 A8 70 00
  93+ 449F 70 88 88 88          defb $70,$88,$88,$88,$f8,$88,$88,$00 ; char 65: A
  93+ 44A3 F8 88 88 00
  94+ 44A7 F0 88 88 F0          defb $f0,$88,$88,$f0,$88,$88,$f0,$00 ; char 66: B
  94+ 44AB 88 88 F0 00
  95+ 44AF 70 88 80 80          defb $70,$88,$80,$80,$80,$88,$70,$00 ; char 67: C
  95+ 44B3 80 88 70 00
  96+ 44B7 E0 90 88 88          defb $e0,$90,$88,$88,$88,$90,$e0,$00 ; char 68: D
  96+ 44BB 88 90 E0 00
  97+ 44BF F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$f8,$00 ; char 69: E
  97+ 44C3 80 80 F8 00
  98+ 44C7 F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$80,$00 ; char 70: F
  98+ 44CB 80 80 80 00
  99+ 44CF 70 88 80 B8          defb $70,$88,$80,$b8,$88,$88,$78,$00 ; char 71: G
  99+ 44D3 88 88 78 00
 100+ 44D7 88 88 88 F8          defb $88,$88,$88,$f8,$88,$88,$88,$00 ; char 72: H
 100+ 44DB 88 88 88 00
 101+ 44DF 70 20 20 20          defb $70,$20,$20,$20,$20,$20,$70,$00 ; char 73: I
 101+ 44E3 20 20 70 00
 102+ 44E7 38 10 10 10          defb $38,$10,$10,$10,$10,$90,$60,$00 ; char 74: J
 102+ 44EB 10 90 60 00
 103+ 44EF 88 90 A0 C0          defb $88,$90,$a0,$c0,$a0,$90,$88,$00 ; char 75: K
 103+ 44F3 A0 90 88 00
 104+ 44F7 80 80 80 80          defb $80,$80,$80,$80,$80,$80,$f8,$00 ; char 76: L
 104+ 44FB 80 80 F8 00
 105+ 44FF 88 D8 A8 A8          defb $88,$d8,$a8,$a8,$88,$88,$88,$00 ; char 77: M
 105+ 4503 88 88 88 00
 106+ 4507 88 C8 A8 98          defb $88,$c8,$a8,$98,$88,$88,$88,$00 ; char 78: N
 106+ 450B 88 88 88 00
 107+ 450F 70 88 88 88          defb $70,$88,$88,$88,$88,$88,$70,$00 ; char 79: O
 107+ 4513 88 88 70 00
 108+ 4517 F0 88 88 F0          defb $f0,$88,$88,$f0,$80,$80,$80,$00 ; char 80: P
 108+ 451B 80 80 80 00
 109+ 451F 70 88 88 88          defb $70,$88,$88,$88,$a8,$90,$68,$00 ; char 81: Q
 109+ 4523 A8 90 68 00
 110+ 4527 F0 88 88 F0          defb $f0,$88,$88,$f0,$a0,$90,$88,$00 ; char 82: R
 110+ 452B A0 90 88 00
 111+ 452F 78 80 80 70          defb $78,$80,$80,$70,$08,$08,$f0,$00 ; char 83: S
 111+ 4533 08 08 F0 00
 112+ 4537 F8 20 20 20          defb $f8,$20,$20,$20,$20,$20,$20,$00 ; char 84: T
 112+ 453B 20 20 20 00
 113+ 453F 88 88 88 88          defb $88,$88,$88,$88,$88,$88,$70,$00 ; char 85: U
 113+ 4543 88 88 70 00
 114+ 4547 88 88 88 88          defb $88,$88,$88,$88,$88,$50,$20,$00 ; char 86: V
 114+ 454B 88 50 20 00
 115+ 454F 88 88 88 88          defb $88,$88,$88,$88,$a8,$a8,$50,$00 ; char 87: W
 115+ 4553 A8 A8 50 00
 116+ 4557 88 88 50 20          defb $88,$88,$50,$20,$50,$88,$88,$00 ; char 88: X
 116+ 455B 50 88 88 00
 117+ 455F 88 88 88 50          defb $88,$88,$88,$50,$20,$20,$20,$00 ; char 89: Y
 117+ 4563 20 20 20 00
 118+ 4567 F8 08 10 20          defb $f8,$08,$10,$20,$40,$80,$f8,$00 ; char 90: Z
 118+ 456B 40 80 F8 00
 119+ 456F 70 40 40 40          defb $70,$40,$40,$40,$40,$40,$70,$00 ; char 91: [
 119+ 4573 40 40 70 00
 120+ 4577 00 80 40 20          defb $00,$80,$40,$20,$10,$08,$00,$00 ; char 92: \
 120+ 457B 10 08 00 00
 121+ 457F 70 10 10 10          defb $70,$10,$10,$10,$10,$10,$70,$00 ; char 93: ]
 121+ 4583 10 10 70 00
 122+ 4587 20 50 88 00          defb $20,$50,$88,$00,$00,$00,$00,$00 ; char 94: ^
 122+ 458B 00 00 00 00
 123+ 458F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$FC ; char 95: _ (underscore)
 123+ 4593 00 00 00 FC
 124+ 4597 40 20 10 00          defb $40,$20,$10,$00,$00,$00,$00,$00 ; char 96: `
 124+ 459B 00 00 00 00
 125+ 459F 00 00 70 08          defb $00,$00,$70,$08,$78,$88,$78,$00 ; char 97: a
 125+ 45A3 78 88 78 00
 126+ 45A7 80 80 80 B0          defb $80,$80,$80,$b0,$c8,$88,$f0,$00 ; char 98: b
 126+ 45AB C8 88 F0 00
 127+ 45AF 00 00 70 80          defb $00,$00,$70,$80,$80,$88,$70,$00 ; char 99: c
 127+ 45B3 80 88 70 00
 128+ 45B7 08 08 08 68          defb $08,$08,$08,$68,$98,$88,$78,$00 ; char 100: d
 128+ 45BB 98 88 78 00
 129+ 45BF 00 00 70 88          defb $00,$00,$70,$88,$f8,$80,$70,$00 ; char 101: e
 129+ 45C3 F8 80 70 00
 130+ 45C7 30 48 40 E0          defb $30,$48,$40,$e0,$40,$40,$40,$00 ; char 102: f
 130+ 45CB 40 40 40 00
 131+ 45CF 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$70,$00 ; char 103: g
 131+ 45D3 78 08 70 00
 132+ 45D7 80 80 B0 C8          defb $80,$80,$b0,$c8,$88,$88,$88,$00 ; char 104: h
 132+ 45DB 88 88 88 00
 133+ 45DF 20 00 20 20          defb $20,$00,$20,$20,$20,$20,$20,$00 ; char 105: i
 133+ 45E3 20 20 20 00
 134+ 45E7 08 00 18 08          defb $08,$00,$18,$08,$08,$88,$70,$00 ; char 106: j
 134+ 45EB 08 88 70 00
 135+ 45EF 80 80 90 A0          defb $80,$80,$90,$a0,$c0,$a0,$90,$00 ; char 107: k
 135+ 45F3 C0 A0 90 00
 136+ 45F7 60 20 20 20          defb $60,$20,$20,$20,$20,$20,$70,$00 ; char 108: l
 136+ 45FB 20 20 70 00
 137+ 45FF 00 00 D0 A8          defb $00,$00,$d0,$a8,$a8,$88,$88,$00 ; char 109: m
 137+ 4603 A8 88 88 00
 138+ 4607 00 00 B0 C8          defb $00,$00,$b0,$c8,$88,$88,$88,$00 ; char 110: n
 138+ 460B 88 88 88 00
 139+ 460F 00 00 70 88          defb $00,$00,$70,$88,$88,$88,$70,$00 ; char 111: o
 139+ 4613 88 88 70 00
 140+ 4617 00 00 F0 88          defb $00,$00,$f0,$88,$f0,$80,$80,$00 ; char 112: p
 140+ 461B F0 80 80 00
 141+ 461F 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$08,$00 ; char 113: q
 141+ 4623 78 08 08 00
 142+ 4627 00 00 B0 C8          defb $00,$00,$b0,$c8,$80,$80,$80,$00 ; char 114: r
 142+ 462B 80 80 80 00
 143+ 462F 00 00 70 80          defb $00,$00,$70,$80,$70,$08,$f0,$00 ; char 115: s
 143+ 4633 70 08 F0 00
 144+ 4637 40 40 E0 40          defb $40,$40,$e0,$40,$40,$48,$30,$00 ; char 116: t
 144+ 463B 40 48 30 00
 145+ 463F 00 00 88 88          defb $00,$00,$88,$88,$88,$98,$68,$00 ; char 117: u
 145+ 4643 88 98 68 00
 146+ 4647 00 00 88 88          defb $00,$00,$88,$88,$88,$50,$20,$00 ; char 118: v
 146+ 464B 88 50 20 00
 147+ 464F 00 00 88 88          defb $00,$00,$88,$88,$a8,$a8,$50,$00 ; char 119: w
 147+ 4653 A8 A8 50 00
 148+ 4657 00 00 88 50          defb $00,$00,$88,$50,$20,$50,$88,$00 ; char 120: x
 148+ 465B 20 50 88 00
 149+ 465F 00 00 88 98          defb $00,$00,$88,$98,$68,$08,$70,$00 ; char 121: y
 149+ 4663 68 08 70 00
 150+ 4667 00 00 F8 10          defb $00,$00,$f8,$10,$20,$40,$f8,$00 ; char 122: z
 150+ 466B 20 40 F8 00
 151+ 466F 10 20 20 40          defb $10,$20,$20,$40,$20,$20,$10,$00 ; char 123: {
 151+ 4673 20 20 10 00
 152+ 4677 20 20 20 20          defb $20,$20,$20,$20,$20,$20,$20,$00 ; char 124: |
 152+ 467B 20 20 20 00
 153+ 467F 20 10 10 08          defb $20,$10,$10,$08,$10,$10,$20,$00 ; char 125: }
 153+ 4683 10 10 20 00
 154+ 4687 00 28 50 00          defb $00,$28,$50,$00,$00,$00,$00,$00 ; char 126: ~
 154+ 468B 00 00 00 00
 155+ 468F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 127: (delete) - here end the standard ASCII (0-127)
 155+ 4693 00 00 00 00
 156+ 4697 78 84 CC 84          defb %01111000,%10000100,%11001100,%10000100,%10110100,%10000100,%01111000,%00000000 ; char 128 (open face)
 156+ 469B B4 84 78 00
 157+ 469F 78 FC B4 FC          defb %01111000,%11111100,%10110100,%11111100,%10110100,%11001100,%01111000,%00000000 ; char 129 (full face)
 157+ 46A3 B4 CC 78 00
 158+ 46A7 48 FC FC FC          defb %01001000,%11111100,%11111100,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 130 (hearts)
 158+ 46AB FC 78 30 00
 159+ 46AF 00 20 70 F8          defb %00000000,%00100000,%01110000,%11111000,%11111000,%01110000,%00100000,%00000000 ; char 131 (diamonds)
 159+ 46B3 F8 70 20 00
 160+ 46B7 70 20 A8 F8          defb %01110000,%00100000,%10101000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 132 (clubs)
 160+ 46BB A8 20 70 00
 161+ 46BF 20 70 F8 F8          defb %00100000,%01110000,%11111000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 133 (spades)
 161+ 46C3 A8 20 70 00
 162+ 46C7 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 134
 162+ 46CB FC 30 30 30
 163+ 46CF 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 135
 163+ 46D3 3C 30 30 30
 164+ 46D7 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 136
 164+ 46DB F0 30 30 30
 165+ 46DF 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00000000,%00000000,%00000000 ; char 137
 165+ 46E3 F0 00 00 00
 166+ 46E7 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00000000,%00000000,%00000000 ; char 138
 166+ 46EB 3C 00 00 00
 167+ 46EF 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 139
 167+ 46F3 FC 00 00 00
 168+ 46F7 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 140
 168+ 46FB 3C 30 30 30
 169+ 46FF 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 141
 169+ 4703 FC 30 30 30
 170+ 4707 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 142
 170+ 470B F0 30 30 30
 171+ 470F 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 143
 171+ 4713 FC 00 00 00
 172+ 4717 30 30 30 30          defb %00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000 ; char 144
 172+ 471B 30 30 30 30
 173+ 471F 0C 1C 18 38          defb %00001100,%00011100,%00011000,%00111000,%01110000,%01100000,%11100000,%11000000 ; char 145
 173+ 4723 70 60 E0 C0
 174+ 4727 C0 E0 60 70          defb %11000000,%11100000,%01100000,%01110000,%00111000,%00011000,%00011100,%00001100 ; char 146
 174+ 472B 38 18 1C 0C
 175+ 472F CC CC 78 30          defb %11001100,%11001100,%01111000,%00110000,%00110000,%01111000,%11001100,%11001100 ; char 147
 175+ 4733 30 78 CC CC
 176+ 4737 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 148
 176+ 473B 20 20 20 20
 177+ 473F 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 149
 177+ 4743 20 20 20 20
 178+ 4747 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 150
 178+ 474B 20 20 20 20
 179+ 474F 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 151
 179+ 4753 00 00 00 00
 180+ 4757 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00000000,%00000000,%00000000,%00000000 ; char 152
 180+ 475B 00 00 00 00
 181+ 475F 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 153
 181+ 4763 00 00 00 00
 182+ 4767 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 154
 182+ 476B 20 20 20 20
 183+ 476F 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 155
 183+ 4773 20 20 20 20
 184+ 4777 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 156
 184+ 477B 20 20 20 20
 185+ 477F 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 157
 185+ 4783 00 00 00 00
 186+ 4787 20 20 20 20          defb %00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000 ; char 158
 186+ 478B 20 20 20 20
 187+ 478F 04 08 08 10          defb %00000100,%00001000,%00001000,%00010000,%00100000,%01000000,%01000000,%10000000 ; char 159
 187+ 4793 20 40 40 80
 188+ 4797 80 40 40 20          defb %10000000,%01000000,%01000000,%00100000,%00010000,%00001000,%00001000,%00000100 ; char 160
 188+ 479B 10 08 08 04
 189+ 479F 84 48 48 30          defb %10000100,%01001000,%01001000,%00110000,%00110000,%01001000,%01001000,%10000100 ; char 161
 189+ 47A3 30 48 48 84
 190+ 47A7 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 162
 190+ 47AB 00 00 FC FC
 191+ 47AF 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111100,%11111100,%11111100,%11111100 ; char 163
 191+ 47B3 FC FC FC FC
 192+ 47B7 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 164
 192+ 47BB FC FC FC FC
 193+ 47BF FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 193+ 47C3 00 00 00 00
 194+ 47C7 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 166
 194+ 47CB 00 00 00 00
 195+ 47CF FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 167
 195+ 47D3 FC FC 00 00
 196+ 47D7 80 80 80 80          defb %10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000 ; char 168
 196+ 47DB 80 80 80 80
 197+ 47DF E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000 ; char 169
 197+ 47E3 E0 E0 E0 E0
 198+ 47E7 F8 F8 F8 F8          defb %11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000 ; char 170
 198+ 47EB F8 F8 F8 F8
 199+ 47EF 04 04 04 04          defb %00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100 ; char 171
 199+ 47F3 04 04 04 04
 200+ 47F7 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100 ; char 172
 200+ 47FB 1C 1C 1C 1C
 201+ 47FF 7C 7C 7C 7C          defb %01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100 ; char 173
 201+ 4803 7C 7C 7C 7C
 202+ 4807 FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 174
 202+ 480B 84 84 84 FC
 203+ 480F 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%11100000,%11100000,%11100000 ; char 175
 203+ 4813 E0 E0 E0 E0
 204+ 4817 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00011100,%00011100,%00011100 ; char 176
 204+ 481B 1C 1C 1C 1C
 205+ 481F 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 177
 205+ 4823 00 00 00 00
 206+ 4827 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 178
 206+ 482B 00 00 00 00
 207+ 482F E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00011100,%00011100,%00011100,%00011100 ; char 179
 207+ 4833 1C 1C 1C 1C
 208+ 4837 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%11100000,%11100000,%11100000,%11100000 ; char 180
 208+ 483B E0 E0 E0 E0
 209+ 483F 78 78 78 78          defb %01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000 ; char 181
 209+ 4843 78 78 78 78
 210+ 4847 CC CC CC CC          defb %11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100 ; char 182
 210+ 484B CC CC CC CC
 211+ 484F FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 183
 211+ 4853 00 00 FC FC
 212+ 4857 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 184
 212+ 485B FC FC 00 00
 213+ 485F 30 30 CC CC          defb %00110000,%00110000,%11001100,%11001100,%00110000,%00110000,%11001100,%11001100 ; char 185
 213+ 4863 30 30 CC CC
 214+ 4867 54 A8 54 A8          defb %01010100,%10101000,%01010100,%10101000,%01010100,%10101000,%01010100,%10101000 ; char 186
 214+ 486B 54 A8 54 A8
 215+ 486F 64 30 98 CC          defb %01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100 ; char 187
 215+ 4873 64 30 98 CC
 216+ 4877 CC 64 30 98          defb %11001100,%01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000 ; char 188
 216+ 487B CC 64 30 98
 217+ 487F 30 98 CC 64          defb %00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100,%01100100 ; char 189
 217+ 4883 30 98 CC 64
 218+ 4887 64 CC 98 30          defb %01100100,%11001100,%10011000,%00110000,%01100100,%11001100,%10011000,%00110000 ; char 190
 218+ 488B 64 CC 98 30
 219+ 488F 20 20 F8 20          defb %00100000,%00100000,%11111000,%00100000,%00100000,%00000000,%11111000,%00000000 ; char 191 (Â±)
 219+ 4893 20 00 F8 00
 220+ 4897 C0 30 08 30          defb %11000000,%00110000,%00001000,%00110000,%11000000,%00000000,%11111000,%00000000 ; char 192 (â¥)
 220+ 489B C0 00 F8 00
 221+ 489F 18 60 80 60          defb %00011000,%01100000,%10000000,%01100000,%00011000,%00000000,%11111000,%00000000 ; char 193 (â¤)
 221+ 48A3 18 00 F8 00
 222+ 48A7 3C 20 20 20          defb %00111100,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 222+ 48AB A0 60 20 00
 223+ 48AF 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 223+ 48B3 00 00 00 00
 224+ 48B7 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 224+ 48BB 70 00 00 00
 225+ 48BF 00 00 54 A8          defb %00000000,%00000000,%01010100,%10101000,%00000000,%11111100,%00000000,%00000000 ; char 197
 225+ 48C3 00 FC 00 00
 226+ 48C7 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 226+ 48CB 54 A8 00 00
 227+ 48CF 00 80 C0 E0          defb %00000000,%10000000,%11000000,%11100000,%11100000,%11000000,%10000000,%00000000 ; char 199
 227+ 48D3 E0 C0 80 00
 228+ 48D7 FC 78 30 00          defb %11111100,%01111000,%00110000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 200
 228+ 48DB 00 00 00 00
 229+ 48DF 00 04 0C 1C          defb %00000000,%00000100,%00001100,%00011100,%00011100,%00001100,%00000100,%00000000 ; char 201
 229+ 48E3 1C 0C 04 00
 230+ 48E7 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00110000,%01111000,%11111100 ; char 202
 230+ 48EB 00 30 78 FC
 231+ 48EF 20 70 F8 20          defb %00100000,%01110000,%11111000,%00100000,%00100000,%00100000,%00100000,%00000000 ; char 203 (up arrow)
 231+ 48F3 20 20 20 00
 232+ 48F7 3C 1C 1C 24          defb %00111100,%00011100,%00011100,%00100100,%01000000,%10000000,%00000000,%00000000 ; char 204 (up right arrow)
 232+ 48FB 40 80 00 00
 233+ 48FF 00 10 18 FC          defb %00000000,%00010000,%00011000,%11111100,%00011000,%00010000,%00000000,%00000000 ; char 205 (right arrow)
 233+ 4903 18 10 00 00
 234+ 4907 00 00 80 40          defb %00000000,%00000000,%10000000,%01000000,%00100100,%00011100,%00011100,%00111100 ; char 206 (down right arrow)
 234+ 490B 24 1C 1C 3C
 235+ 490F 00 20 20 20          defb %00000000,%00100000,%00100000,%00100000,%00100000,%11111000,%01110000,%00100000 ; char 207 (down arrow)
 235+ 4913 20 F8 70 20
 236+ 4917 00 00 04 08          defb %00000000,%00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000 ; char 208 (down left arrow)
 236+ 491B 90 E0 E0 F0
 237+ 491F 00 20 60 FC          defb %00000000,%00100000,%01100000,%11111100,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 237+ 4923 60 20 00 00
 238+ 4927 F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 238+ 492B 08 04 00 00
 239+ 492F 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 239+ 4933 F0 44 38 00
 240+ 4937 00 04 78 A8          defb %00000000,%00000100,%01111000,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 240+ 493B 28 28 28 00
 241+ 493F 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00100000,%00100000,%00100000 ; char 213
 241+ 4943 1C 20 20 20
 242+ 4947 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%00010000,%00010000,%00010000 ; char 214
 242+ 494B E0 10 10 10
 243+ 494F 10 10 10 E0          defb %00010000,%00010000,%00010000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 215
 243+ 4953 00 00 00 00
 244+ 4957 20 20 20 1C          defb %00100000,%00100000,%00100000,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 216
 244+ 495B 00 00 00 00
 245+ 495F 00 00 00 1C          defb %00000000,%00000000,%00000000,%00011100,%00111100,%00110000,%00110000,%00110000 ; char 217
 245+ 4963 3C 30 30 30
 246+ 4967 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00110000,%00110000,%00110000 ; char 218
 246+ 496B F0 30 30 30
 247+ 496F 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 247+ 4973 E0 00 00 00
 248+ 4977 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00011100,%00000000,%00000000,%00000000 ; char 220
 248+ 497B 1C 00 00 00
 249+ 497F 00 30 48 48          defb %00000000,%00110000,%01001000,%01001000,%01001000,%00110000,%00000000,%00000000 ; char 221
 249+ 4983 48 30 00 00
 250+ 4987 00 30 78 78          defb %00000000,%00110000,%01111000,%01111000,%01111000,%00110000,%00000000,%00000000 ; char 222
 250+ 498B 78 30 00 00
 251+ 498F 00 30 78 FC          defb %00000000,%00110000,%01111000,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 223
 251+ 4993 FC 78 30 00
 252+ 4997 FC F8 F0 E0          defb %11111100,%11111000,%11110000,%11100000,%11100000,%11000000,%10000000,%10000000 ; char 224
 252+ 499B E0 C0 80 80
 253+ 499F FC 7C 3C 1C          defb %11111100,%01111100,%00111100,%00011100,%00011100,%00001100,%00000100,%00000100 ; char 225
 253+ 49A3 1C 0C 04 04
 254+ 49A7 04 04 0C 1C          defb %00000100,%00000100,%00001100,%00011100,%00011100,%00111100,%01111100,%11111100 ; char 226
 254+ 49AB 1C 3C 7C FC
 255+ 49AF 80 80 C0 E0          defb %10000000,%10000000,%11000000,%11100000,%11100000,%11110000,%11111000,%11111100 ; char 227
 255+ 49B3 E0 F0 F8 FC
 256+ 49B7 00 04 0C D8          defb %00000000,%00000100,%00001100,%11011000,%11110000,%11100000,%11000000,%00000000 ; char 228 (checkmark)
 256+ 49BB F0 E0 C0 00
 257+ 49BF 00 CC 78 30          defb %00000000,%11001100,%01111000,%00110000,%01111000,%11001100,%00000000,%00000000 ; char 229 (x)
 257+ 49C3 78 CC 00 00
 258+ 49C7 70 88 88 88          defb %01110000,%10001000,%10001000,%10001000,%01110000,%00100000,%01110000,%00100000 ; char 230 (female)
 258+ 49CB 70 20 70 20
 259+ 49CF 00 1C 0C 74          defb %00000000,%00011100,%00001100,%01110100,%10010000,%10010000,%01100000,%00000000 ; char 231 (male)
 259+ 49D3 90 90 60 00
 260+ 49D7 F8 84 84 84          defb %11111000,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 232 (new doc)
 260+ 49DB 84 84 84 FC
 261+ 49DF 00 F0 FC 84          defb %00000000,%11110000,%11111100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 233 (folder)
 261+ 49E3 84 84 84 FC
 262+ 49E7 30 78 FC 48          defb %00110000,%01111000,%11111100,%01001000,%01001000,%01001000,%01001000,%01111000 ; char 234 (trash bin)
 262+ 49EB 48 48 48 78
 263+ 49EF FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%11111100,%10110100,%10110100,%11111100 ; char 235 (floppy disk)
 263+ 49F3 FC B4 B4 FC
 264+ 49F7 00 00 D4 D8          defb %00000000,%00000000,%11010100,%11011000,%11010100,%11010100,%00000000,%00000000 ; char 236 (OK)
 264+ 49FB D4 D4 00 00
 265+ 49FF 30 78 FC 78          defb %00110000,%01111000,%11111100,%01111000,%01111000,%01001000,%01001000,%01001000 ; char 237 (home)
 265+ 4A03 78 48 48 48
 266+ 4A07 78 84 A4 A4          defb %01111000,%10000100,%10100100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 238 (clock)
 266+ 4A0B B4 84 78 00
 267+ 4A0F 00 00 08 F4          defb %00000000,%00000000,%00001000,%11110100,%10101000,%10000000,%00000000,%00000000 ; char 239 (key)
 267+ 4A13 A8 80 00 00
 268+ 4A17 20 30 78 B0          defb %00100000,%00110000,%01111000,%10110000,%10100000,%10001000,%01110000,%00000000 ; char 240 (undo)
 268+ 4A1B A0 88 70 00
 269+ 4A1F 00 FC CC B4          defb %00000000,%11111100,%11001100,%10110100,%10000100,%10000100,%11111100,%00000000 ; char 241 (letter)
 269+ 4A23 84 84 FC 00
 270+ 4A27 60 90 90 F0          defb %01100000,%10010000,%10010000,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 242 (lock)
 270+ 4A2B F0 F0 F0 00
 271+ 4A2F 08 14 14 F0          defb %00001000,%00010100,%00010100,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 243 (unlock)
 271+ 4A33 F0 F0 F0 00
 272+ 4A37 FC FC 84 B4          defb %11111100,%11111100,%10000100,%10110100,%10010100,%10010100,%10000100,%11111100 ; char 244 (calendar)
 272+ 4A3B 94 94 84 FC
 273+ 4A3F 00 04 38 58          defb %00000000,%00000100,%00111000,%01011000,%01101000,%01110000,%10000000,%00000000 ; char 245 (diameter)
 273+ 4A43 68 70 80 00
 274+ 4A47 78 84 84 84          defb %01111000,%10000100,%10000100,%10000100,%01101100,%00011000,%00001000,%00000000 ; char 246 (baloon)
 274+ 4A4B 6C 18 08 00
 275+ 4A4F 30 28 28 28          defb %00110000,%00101000,%00101000,%00101000,%00100000,%01100000,%11100000,%01000000 ; char 247 (note)
 275+ 4A53 20 60 E0 40
 276+ 4A57 20 68 E4 E4          defb %00100000,%01101000,%11100100,%11100100,%11100100,%01101000,%00100000,%00000000 ; char 248 (audio on)
 276+ 4A5B E4 68 20 00
 277+ 4A5F 20 60 E0 E0          defb %00100000,%01100000,%11100000,%11100000,%11100000,%01100000,%00100000,%00000000 ; char 249 (audio off)
 277+ 4A63 E0 60 20 00
 278+ 4A67 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11110000,%10010000 ; char 250 (pointer)
 278+ 4A6B F8 FC F0 90
 279+ 4A6F 78 84 B4 A4          defb %01111000,%10000100,%10110100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 251 (Â©)
 279+ 4A73 B4 84 78 00
 280+ 4A77 30 48 40 E0          defb %00110000,%01001000,%01000000,%11100000,%01000000,%01001000,%10110000,%00000000 ; char 252 (Â£)
 280+ 4A7B 40 48 B0 00
 281+ 4A7F 78 84 F0 48          defb %01111000,%10000100,%11110000,%01001000,%01001000,%00111100,%10000100,%01111000 ; char 253 (Â§)
 281+ 4A83 48 3C 84 78
 282+ 4A87 00 00 20 00          defb %00000000,%00000000,%00100000,%00000000,%11111000,%00000000,%00100000,%00000000 ; char 254 (Ã·)
 282+ 4A8B F8 00 20 00
 283+ 4A8F FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 255 (cursor)
 283+ 4A93 FC FC FC FC
 284+ 4A97                      ; here ends the ASCII table
 285+ 4A97
# file closed: ../include/vdp/6x8fonts-r16.asm
  82  4A97                  INCLUDE "../include/vdp/8x8fonts-r18.asm"
# file opened: ../include/vdp/8x8fonts-r18.asm
   1+ 4A97              ; ------------------------------------------------------------------------------
   2+ 4A97              ; LM80C - 8x8 CHARSET - R1.8
   3+ 4A97              ; ------------------------------------------------------------------------------
   4+ 4A97              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4A97              ; designed by Leonardo Miliani. More info at
   6+ 4A97              ; www DOT leonardomiliani DOT com
   7+ 4A97              ; ------------------------------------------------------------------------------
   8+ 4A97              ; Code Revision:
   9+ 4A97              ; R1.0 - 20190615 - First revision: ASCII chars (from 0 to 255) - actually, they are 6x8 pixels
  10+ 4A97              ; R1.1 - 20190616 - Converted to 8x8 pixels
  11+ 4A97              ; R1.2 - 20191013 - Added new graphic chars and reorganized previous ones
  12+ 4A97              ; R1.3 - 20191015 - More graphic chars
  13+ 4A97              ; R1.4 - 20191202 - Fixed char 11/12, added new special chars
  14+ 4A97              ; R1.5 - 20191210 - Changed several graphic chars
  15+ 4A97              ; R1.6 - 20200125 - Removed double chars, changed with new ones
  16+ 4A97              ; R1.7 - 20200228 - adopted more usual hexadecimal & binary prefixes
  17+ 4A97              ; R1.8 - 20200524 - New style for char #252
  18+ 4A97              ; ------------------------------------------------------------------------------
  19+ 4A97              ;
  20+ 4A97              ;-------------------------------------------------------------------------------
  21+ 4A97              ;
  22+ 4A97              ;               8 x 8    C  H  A  R  S  E  T
  23+ 4A97              ;
  24+ 4A97              ;-------------------------------------------------------------------------------
  25+ 4A97              ;
  26+ 4A97              ;       8X8 CHARS, DESIGNED FOR GRAPHICS 1 MODE
  27+ 4A97
  28+ 4A97              CHRST88 equ $
  29+ 4A97 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  29+ 4A9B 00 00 00 00
  30+ 4A9F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  30+ 4AA3 00 00 00 00
  31+ 4AA7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  31+ 4AAB 00 00 00 00
  32+ 4AAF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  32+ 4AB3 00 00 00 00
  33+ 4AB7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  33+ 4ABB 00 00 00 00
  34+ 4ABF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  34+ 4AC3 00 00 00 00
  35+ 4AC7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  35+ 4ACB 00 00 00 00
  36+ 4ACF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  36+ 4AD3 00 00 00 00
  37+ 4AD7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 DEL key (backspace)
  37+ 4ADB 00 00 00 00
  38+ 4ADF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  38+ 4AE3 00 00 00 00
  39+ 4AE7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  39+ 4AEB 00 00 00 00
  40+ 4AEF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 (unused)
  40+ 4AF3 00 00 00 00
  41+ 4AF7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  41+ 4AFB 00 00 00 00
  42+ 4AFF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 RETURN key (carriage return)
  42+ 4B03 00 00 00 00
  43+ 4B07 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL key
  43+ 4B0B 00 00 00 00
  44+ 4B0F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  44+ 4B13 00 00 00 00
  45+ 4B17 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  45+ 4B1B 00 00 00 00
  46+ 4B1F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  46+ 4B23 00 00 00 00
  47+ 4B27 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  47+ 4B2B 00 00 00 00
  48+ 4B2F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  48+ 4B33 00 00 00 00
  49+ 4B37 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT key
  49+ 4B3B 00 00 00 00
  50+ 4B3F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  50+ 4B43 00 00 00 00
  51+ 4B47 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6 key
  51+ 4B4B 00 00 00 00
  52+ 4B4F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7 key
  52+ 4B53 00 00 00 00
  53+ 4B57 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP key
  53+ 4B5B 00 00 00 00
  54+ 4B5F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 HOME key
  54+ 4B63 00 00 00 00
  55+ 4B67 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26 INSERT key
  55+ 4B6B 00 00 00 00
  56+ 4B6F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 ESCAPE key
  56+ 4B73 00 00 00 00
  57+ 4B77 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 CRSR LEFT key (cursor left)
  57+ 4B7B 00 00 00 00
  58+ 4B7F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 CRSR RIGHT key (cursor right)
  58+ 4B83 00 00 00 00
  59+ 4B87 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 CRSR UP key (cursor up)
  59+ 4B8B 00 00 00 00
  60+ 4B8F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 CRSR DOWN key (cursor down)
  60+ 4B93 00 00 00 00
  61+ 4B97 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32 SPACE key
  61+ 4B9B 00 00 00 00
  62+ 4B9F 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00000000,%00010000,%00000000 ; char 33 - !
  62+ 4BA3 10 00 10 00
  63+ 4BA7 28 28 28 00          defb %00101000,%00101000,%00101000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 34 - "
  63+ 4BAB 00 00 00 00
  64+ 4BAF 28 28 FE 28          defb %00101000,%00101000,%11111110,%00101000,%11111110,%00101000,%00101000,%00000000 ; char 35 - #
  64+ 4BB3 FE 28 28 00
  65+ 4BB7 10 3C 50 38          defb %00010000,%00111100,%01010000,%00111000,%00010100,%01111000,%00010000,%00000000 ; char 36 - $
  65+ 4BBB 14 78 10 00
  66+ 4BBF 00 62 64 08          defb %00000000,%01100010,%01100100,%00001000,%00010000,%00100110,%01000110,%00000000 ; char 37 - %
  66+ 4BC3 10 26 46 00
  67+ 4BC7 00 30 48 30          defb %00000000,%00110000,%01001000,%00110000,%01001010,%01000100,%00111010,%00000000 ; char 38 - &
  67+ 4BCB 4A 44 3A 00
  68+ 4BCF 08 10 20 00          defb %00001000,%00010000,%00100000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 39 - '
  68+ 4BD3 00 00 00 00
  69+ 4BD7 08 10 20 20          defb %00001000,%00010000,%00100000,%00100000,%00100000,%00010000,%00001000,%00000000 ; char 40 - (
  69+ 4BDB 20 10 08 00
  70+ 4BDF 20 10 08 08          defb %00100000,%00010000,%00001000,%00001000,%00001000,%00010000,%00100000,%00000000 ; char 41 - )
  70+ 4BE3 08 10 20 00
  71+ 4BE7 00 10 54 38          defb %00000000,%00010000,%01010100,%00111000,%00111000,%01010100,%00010000,%00000000 ; char 42 - *
  71+ 4BEB 38 54 10 00
  72+ 4BEF 00 10 10 7C          defb %00000000,%00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%00000000 ; char 43 - +
  72+ 4BF3 10 10 00 00
  73+ 4BF7 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00001000,%00010000 ; char 44 - ,
  73+ 4BFB 00 18 08 10
  74+ 4BFF 00 00 00 7C          defb %00000000,%00000000,%00000000,%01111100,%00000000,%00000000,%00000000,%00000000 ; char 45 - -
  74+ 4C03 00 00 00 00
  75+ 4C07 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00011000,%00000000 ; char 46 - .
  75+ 4C0B 00 18 18 00
  76+ 4C0F 00 02 04 08          defb %00000000,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%00000000 ; char 47 - /
  76+ 4C13 10 20 40 00
  77+ 4C17 38 44 4C 54          defb %00111000,%01000100,%01001100,%01010100,%01100100,%01000100,%00111000,%00000000 ; char 48 - 0
  77+ 4C1B 64 44 38 00
  78+ 4C1F 10 30 50 10          defb %00010000,%00110000,%01010000,%00010000,%00010000,%00010000,%01111100,%00000000 ; char 49 - 1
  78+ 4C23 10 10 7C 00
  79+ 4C27 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 50 - 2
  79+ 4C2B 10 20 7C 00
  80+ 4C2F 7C 08 10 08          defb %01111100,%00001000,%00010000,%00001000,%00000100,%01000100,%00111000,%00000000 ; char 51 - 3
  80+ 4C33 04 44 38 00
  81+ 4C37 08 18 28 48          defb %00001000,%00011000,%00101000,%01001000,%01111100,%00001000,%00001000,%00000000 ; char 52 - 4
  81+ 4C3B 7C 08 08 00
  82+ 4C3F 7C 40 78 04          defb %01111100,%01000000,%01111000,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 53 - 5
  82+ 4C43 04 44 38 00
  83+ 4C47 38 44 40 78          defb %00111000,%01000100,%01000000,%01111000,%01000100,%01000100,%00111000,%00000000 ; char 54 - 6
  83+ 4C4B 44 44 38 00
  84+ 4C4F 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%00100000,%00100000,%00000000 ; char 55 - 7
  84+ 4C53 20 20 20 00
  85+ 4C57 38 44 44 38          defb %00111000,%01000100,%01000100,%00111000,%01000100,%01000100,%00111000,%00000000 ; char 56 - 8
  85+ 4C5B 44 44 38 00
  86+ 4C5F 38 44 44 3C          defb %00111000,%01000100,%01000100,%00111100,%00000100,%01000100,%00111000,%00000000 ; char 57 - 9
  86+ 4C63 04 44 38 00
  87+ 4C67 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00011000,%00000000,%00000000 ; char 58 - :
  87+ 4C6B 18 18 00 00
  88+ 4C6F 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00001000,%00010000,%00000000 ; char 59 - ;
  88+ 4C73 18 08 10 00
  89+ 4C77 04 08 10 20          defb %00000100,%00001000,%00010000,%00100000,%00010000,%00001000,%00000100,%00000000 ; char 60 - <
  89+ 4C7B 10 08 04 00
  90+ 4C7F 00 00 7E 00          defb %00000000,%00000000,%01111110,%00000000,%01111110,%00000000,%00000000,%00000000 ; char 61 - =
  90+ 4C83 7E 00 00 00
  91+ 4C87 20 10 08 04          defb %00100000,%00010000,%00001000,%00000100,%00001000,%00010000,%00100000,%00000000 ; char 62 - >
  91+ 4C8B 08 10 20 00
  92+ 4C8F 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00000000,%00010000,%00000000 ; char 63 - ?
  92+ 4C93 10 00 10 00
  93+ 4C97 78 84 BC AC          defb %01111000,%10000100,%10111100,%10101100,%10111000,%10000000,%10000100,%01111000 ; char 64 - @
  93+ 4C9B B8 80 84 78
  94+ 4C9F 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%00000000 ; char 65 - A
  94+ 4CA3 7C 44 44 00
  95+ 4CA7 78 44 44 78          defb %01111000,%01000100,%01000100,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 66 - B
  95+ 4CAB 44 44 78 00
  96+ 4CAF 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 67 - C
  96+ 4CB3 40 44 38 00
  97+ 4CB7 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01000100,%01000100,%01111000,%00000000 ; char 68 - D
  97+ 4CBB 44 44 78 00
  98+ 4CBF 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01111100,%00000000 ; char 69 - E
  98+ 4CC3 40 40 7C 00
  99+ 4CC7 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01000000,%00000000 ; char 70 - F
  99+ 4CCB 40 40 40 00
 100+ 4CCF 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01011100,%01000100,%00111000,%00000000 ; char 71 - G
 100+ 4CD3 5C 44 38 00
 101+ 4CD7 44 44 44 7C          defb %01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%01000100,%00000000 ; char 72 - H
 101+ 4CDB 44 44 44 00
 102+ 4CDF 38 10 10 10          defb %00111000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 73 - I
 102+ 4CE3 10 10 38 00
 103+ 4CE7 3C 04 04 04          defb %00111100,%00000100,%00000100,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 74 - J
 103+ 4CEB 04 44 38 00
 104+ 4CEF 44 44 48 70          defb %01000100,%01000100,%01001000,%01110000,%01001000,%01000100,%01000100,%00000000 ; char 75 - K
 104+ 4CF3 48 44 44 00
 105+ 4CF7 40 40 40 40          defb %01000000,%01000000,%01000000,%01000000,%01000000,%01000000,%01111100,%00000000 ; char 76 - L
 105+ 4CFB 40 40 7C 00
 106+ 4CFF 42 66 5A 42          defb %01000010,%01100110,%01011010,%01000010,%01000010,%01000010,%01000010,%00000000 ; char 77 - M
 106+ 4D03 42 42 42 00
 107+ 4D07 44 64 54 4C          defb %01000100,%01100100,%01010100,%01001100,%01000100,%01000100,%01000100,%00000000 ; char 78 - N
 107+ 4D0B 44 44 44 00
 108+ 4D0F 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 79 - O
 108+ 4D13 44 44 38 00
 109+ 4D17 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01000000,%01000000,%00000000 ; char 80 - P
 109+ 4D1B 78 40 40 00
 110+ 4D1F 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01010100,%01001000,%00110100,%00000000 ; char 81 - Q
 110+ 4D23 54 48 34 00
 111+ 4D27 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01001000,%01000100,%00000000 ; char 82 - R
 111+ 4D2B 78 48 44 00
 112+ 4D2F 3C 40 40 38          defb %00111100,%01000000,%01000000,%00111000,%00000100,%00000100,%01111000,%00000000 ; char 83 - S
 112+ 4D33 04 04 78 00
 113+ 4D37 7C 10 10 10          defb %01111100,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 84 - T
 113+ 4D3B 10 10 10 00
 114+ 4D3F 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 85 - U
 114+ 4D43 44 44 38 00
 115+ 4D47 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 86 - V
 115+ 4D4B 44 28 10 00
 116+ 4D4F 42 42 42 42          defb %01000010,%01000010,%01000010,%01000010,%01011010,%01011010,%00100100,%00000000 ; char 87 - W
 116+ 4D53 5A 5A 24 00
 117+ 4D57 44 44 28 10          defb %01000100,%01000100,%00101000,%00010000,%00101000,%01000100,%01000100,%00000000 ; char 88 - X
 117+ 4D5B 28 44 44 00
 118+ 4D5F 44 44 44 28          defb %01000100,%01000100,%01000100,%00101000,%00010000,%00010000,%00010000,%00000000 ; char 89 - Y
 118+ 4D63 10 10 10 00
 119+ 4D67 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%01000000,%01111100,%00000000 ; char 90 - Z
 119+ 4D6B 20 40 7C 00
 120+ 4D6F 38 20 20 20          defb %00111000,%00100000,%00100000,%00100000,%00100000,%00100000,%00111000,%00000000 ; char 91 - [
 120+ 4D73 20 20 38 00
 121+ 4D77 00 40 20 10          defb %00000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000000 ; char 92 - \
 121+ 4D7B 08 04 02 00
 122+ 4D7F 38 08 08 08          defb %00111000,%00001000,%00001000,%00001000,%00001000,%00001000,%00111000,%00000000 ; char 93 - ]
 122+ 4D83 08 08 38 00
 123+ 4D87 10 28 44 00          defb %00010000,%00101000,%01000100,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 94 - ^
 123+ 4D8B 00 00 00 00
 124+ 4D8F 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%01111110,%00000000 ; char 95 _ (underscore)
 124+ 4D93 00 00 7E 00
 125+ 4D97 20 10 08 00          defb %00100000,%00010000,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 96 - `
 125+ 4D9B 00 00 00 00
 126+ 4D9F 00 00 38 04          defb %00000000,%00000000,%00111000,%00000100,%00111100,%01000100,%00111100,%00000000 ; char 97 - a
 126+ 4DA3 3C 44 3C 00
 127+ 4DA7 40 40 40 78          defb %01000000,%01000000,%01000000,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 98 - b
 127+ 4DAB 44 44 78 00
 128+ 4DAF 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 99 - c
 128+ 4DB3 40 44 38 00
 129+ 4DB7 04 04 04 3C          defb %00000100,%00000100,%00000100,%00111100,%01000100,%01000100,%00111100,%00000000 ; char 100 - d
 129+ 4DBB 44 44 3C 00
 130+ 4DBF 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01111100,%01000000,%00111000,%00000000 ; char 101 - e
 130+ 4DC3 7C 40 38 00
 131+ 4DC7 18 24 20 70          defb %00011000,%00100100,%00100000,%01110000,%00100000,%00100000,%00100000,%00000000 ; char 102 - f
 131+ 4DCB 20 20 20 00
 132+ 4DCF 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00111000 ; char 103 - g
 132+ 4DD3 44 3C 04 38
 133+ 4DD7 40 40 58 64          defb %01000000,%01000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 104 - h
 133+ 4DDB 44 44 44 00
 134+ 4DDF 00 10 00 10          defb %00000000,%00010000,%00000000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 105 - i
 134+ 4DE3 10 10 10 00
 135+ 4DE7 08 00 18 08          defb %00001000,%00000000,%00011000,%00001000,%00001000,%00001000,%01001000,%00110000 ; char 106 - j
 135+ 4DEB 08 08 48 30
 136+ 4DEF 40 40 48 50          defb %01000000,%01000000,%01001000,%01010000,%01100000,%01010000,%01001000,%00000000 ; char 107 - k
 136+ 4DF3 60 50 48 00
 137+ 4DF7 30 10 10 10          defb %00110000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 108 - l
 137+ 4DFB 10 10 38 00
 138+ 4DFF 00 00 54 6A          defb %00000000,%00000000,%01010100,%01101010,%01001010,%01000010,%01000010,%00000000 ; char 109 - m
 138+ 4E03 4A 42 42 00
 139+ 4E07 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 110 - n
 139+ 4E0B 44 44 44 00
 140+ 4E0F 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 111: o
 140+ 4E13 44 44 38 00
 141+ 4E17 00 00 78 44          defb %00000000,%00000000,%01111000,%01000100,%01000100,%01111000,%01000000,%01000000 ; char 112: p
 141+ 4E1B 44 78 40 40
 142+ 4E1F 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00000100 ; char 113: q
 142+ 4E23 44 3C 04 04
 143+ 4E27 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000000,%01000000,%01000000,%00000000 ; char 114: r
 143+ 4E2B 40 40 40 00
 144+ 4E2F 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%00111000,%00000100,%01111000,%00000000 ; char 115: s
 144+ 4E33 38 04 78 00
 145+ 4E37 20 20 70 20          defb %00100000,%00100000,%01110000,%00100000,%00100000,%00100100,%00011000,%00000000 ; char 116: t
 145+ 4E3B 20 24 18 00
 146+ 4E3F 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%01001100,%00110100,%00000000 ; char 117: u
 146+ 4E43 44 4C 34 00
 147+ 4E47 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 118: v
 147+ 4E4B 44 28 10 00
 148+ 4E4F 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01010100,%01010100,%00101000,%00000000 ; char 119: w
 148+ 4E53 54 54 28 00
 149+ 4E57 00 00 44 28          defb %00000000,%00000000,%01000100,%00101000,%00010000,%00101000,%01000100,%00000000 ; char 120: x
 149+ 4E5B 10 28 44 00
 150+ 4E5F 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01001100,%00110100,%00000100,%00111000 ; char 121: y
 150+ 4E63 4C 34 04 38
 151+ 4E67 00 00 7C 08          defb %00000000,%00000000,%01111100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 122: z
 151+ 4E6B 10 20 7C 00
 152+ 4E6F 18 20 20 40          defb %00011000,%00100000,%00100000,%01000000,%00100000,%00100000,%00011000,%00000000 ; char 123: {
 152+ 4E73 20 20 18 00
 153+ 4E77 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 124: |
 153+ 4E7B 10 10 10 00
 154+ 4E7F 30 08 08 04          defb %00110000,%00001000,%00001000,%00000100,%00001000,%00001000,%00110000,%00000000 ; char 125: }
 154+ 4E83 08 08 30 00
 155+ 4E87 20 54 08 00          defb %00100000,%01010100,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 126: ~
 155+ 4E8B 00 00 00 00
 156+ 4E8F 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 127 (delete) - end the standard ASCII (0-127)
 156+ 4E93 00 00 00 00
 157+ 4E97 3C 42 A5 81          defb %00111100,%01000010,%10100101,%10000001,%10100101,%10011001,%01000010,%00111100 ; char 128 (open face)
 157+ 4E9B A5 99 42 3C
 158+ 4E9F 3C 7E DB FF          defb %00111100,%01111110,%11011011,%11111111,%11011011,%11100111,%01111110,%00111100 ; char 129 (full face)
 158+ 4EA3 DB E7 7E 3C
 159+ 4EA7 6C FE FE FE          defb %01101100,%11111110,%11111110,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 130 (hearts)
 159+ 4EAB 7C 38 10 00
 160+ 4EAF 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 131 (diamonds)
 160+ 4EB3 7C 38 10 00
 161+ 4EB7 10 38 54 FE          defb %00010000,%00111000,%01010100,%11111110,%01010100,%00010000,%01111100,%00000000 ; char 132 (clus)
 161+ 4EBB 54 10 7C 00
 162+ 4EBF 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%11010110,%00010000,%01111100,%00000000 ; char 133 (spades)
 162+ 4EC3 D6 10 7C 00
 163+ 4EC7 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 134
 163+ 4ECB FF 18 18 18
 164+ 4ECF 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 135
 164+ 4ED3 1F 18 18 18
 165+ 4ED7 00 00 00 F8          defb %00000000,%00000000,%00000000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 136
 165+ 4EDB F8 18 18 18
 166+ 4EDF 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00000000,%00000000,%00000000 ; char 137
 166+ 4EE3 F8 00 00 00
 167+ 4EE7 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00000000,%00000000,%00000000 ; char 138
 167+ 4EEB 1F 00 00 00
 168+ 4EEF 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 139
 168+ 4EF3 FF 00 00 00
 169+ 4EF7 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 140
 169+ 4EFB 1F 18 18 18
 170+ 4EFF 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 141
 170+ 4F03 FF 18 18 18
 171+ 4F07 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 142
 171+ 4F0B F8 18 18 18
 172+ 4F0F 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 143
 172+ 4F13 FF 00 00 00
 173+ 4F17 18 18 18 18          defb %00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000 ; char 144
 173+ 4F1B 18 18 18 18
 174+ 4F1F 03 07 0E 1C          defb %00000011,%00000111,%00001110,%00011100,%00111000,%01110000,%11100000,%11000000 ; char 145
 174+ 4F23 38 70 E0 C0
 175+ 4F27 C0 E0 70 38          defb %11000000,%11100000,%01110000,%00111000,%00011100,%00001110,%00000111,%00000011 ; char 146
 175+ 4F2B 1C 0E 07 03
 176+ 4F2F C3 E7 7E 3C          defb %11000011,%11100111,%01111110,%00111100,%00111100,%01111110,%11100111,%11000011 ; char 147
 176+ 4F33 3C 7E E7 C3
 177+ 4F37 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 148
 177+ 4F3B 10 10 10 10
 178+ 4F3F 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 149
 178+ 4F43 10 10 10 10
 179+ 4F47 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 150
 179+ 4F4B 10 10 10 10
 180+ 4F4F 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 151
 180+ 4F53 00 00 00 00
 181+ 4F57 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00000000,%00000000,%00000000,%00000000 ; char 152
 181+ 4F5B 00 00 00 00
 182+ 4F5F 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 153
 182+ 4F63 00 00 00 00
 183+ 4F67 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 154
 183+ 4F6B 10 10 10 10
 184+ 4F6F 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 155
 184+ 4F73 10 10 10 10
 185+ 4F77 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 156
 185+ 4F7B 10 10 10 10
 186+ 4F7F 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 157
 186+ 4F83 00 00 00 00
 187+ 4F87 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000 ; char 158
 187+ 4F8B 10 10 10 10
 188+ 4F8F 01 02 04 08          defb %00000001,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%10000000 ; char 159
 188+ 4F93 10 20 40 80
 189+ 4F97 80 40 20 10          defb %10000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000001 ; char 160
 189+ 4F9B 08 04 02 01
 190+ 4F9F 81 42 24 18          defb %10000001,%01000010,%00100100,%00011000,%00011000,%00100100,%01000010,%10000001 ; char 161
 190+ 4FA3 18 24 42 81
 191+ 4FA7 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 162
 191+ 4FAB 00 00 FF FF
 192+ 4FAF 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; char 163
 192+ 4FB3 FF FF FF FF
 193+ 4FB7 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 164
 193+ 4FBB FF FF FF FF
 194+ 4FBF FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 194+ 4FC3 00 00 00 00
 195+ 4FC7 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 166
 195+ 4FCB 00 00 00 00
 196+ 4FCF FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 167
 196+ 4FD3 FF FF 00 00
 197+ 4FD7 C0 C0 C0 C0          defb %11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000 ; char 168
 197+ 4FDB C0 C0 C0 C0
 198+ 4FDF F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; char 169
 198+ 4FE3 F0 F0 F0 F0
 199+ 4FE7 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 170
 199+ 4FEB FC FC FC FC
 200+ 4FEF 03 03 03 03          defb %00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011 ; char 171
 200+ 4FF3 03 03 03 03
 201+ 4FF7 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; char 172
 201+ 4FFB 0F 0F 0F 0F
 202+ 4FFF 3F 3F 3F 3F          defb %00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111 ; char 173
 202+ 5003 3F 3F 3F 3F
 203+ 5007 FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 174
 203+ 500B 81 81 81 FF
 204+ 500F 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; char 175
 204+ 5013 F0 F0 F0 F0
 205+ 5017 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; char 176
 205+ 501B 0F 0F 0F 0F
 206+ 501F 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; char 177
 206+ 5023 00 00 00 00
 207+ 5027 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 178
 207+ 502B 00 00 00 00
 208+ 502F F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00001111,%00001111,%00001111,%00001111 ; char 179
 208+ 5033 0F 0F 0F 0F
 209+ 5037 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%11110000,%11110000,%11110000,%11110000 ; char 180
 209+ 503B F0 F0 F0 F0
 210+ 503F 3C 3C 3C 3C          defb %00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100 ; char 181
 210+ 5043 3C 3C 3C 3C
 211+ 5047 C3 C3 C3 C3          defb %11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011 ; char 182
 211+ 504B C3 C3 C3 C3
 212+ 504F FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 183
 212+ 5053 00 00 FF FF
 213+ 5057 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 184
 213+ 505B FF FF 00 00
 214+ 505F 33 33 CC CC          defb %00110011,%00110011,%11001100,%11001100,%00110011,%00110011,%11001100,%11001100 ; char 185
 214+ 5063 33 33 CC CC
 215+ 5067 55 AA 55 AA          defb %01010101,%10101010,%01010101,%10101010,%01010101,%10101010,%01010101,%10101010 ; char 186
 215+ 506B 55 AA 55 AA
 216+ 506F 66 33 99 CC          defb %01100110,%00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100 ; char 187
 216+ 5073 66 33 99 CC
 217+ 5077 CC 99 33 66          defb %11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011,%01100110 ; char 188
 217+ 507B CC 99 33 66
 218+ 507F 33 99 CC 66          defb %00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100,%01100110 ; char 189
 218+ 5083 33 99 CC 66
 219+ 5087 66 CC 99 33          defb %01100110,%11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011 ; char 190
 219+ 508B 66 CC 99 33
 220+ 508F 10 10 7C 10          defb %00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%01111100,%00000000 ; char 191 (Â±)
 220+ 5093 10 00 7C 00
 221+ 5097 60 18 06 18          defb %01100000,%00011000,%00000110,%00011000,%01100000,%00000000,%01111110,%00000000 ; char 192 (â¥)
 221+ 509B 60 00 7E 00
 222+ 509F 06 18 60 18          defb %00000110,%00011000,%01100000,%00011000,%00000110,%00000000,%01111110,%00000000 ; char 193 (â¤)
 222+ 50A3 06 00 7E 00
 223+ 50A7 3E 20 20 20          defb %00111110,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 223+ 50AB A0 60 20 00
 224+ 50AF 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 224+ 50B3 00 00 00 00
 225+ 50B7 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 225+ 50BB 70 00 00 00
 226+ 50BF 00 00 2A 54          defb %00000000,%00000000,%00101010,%01010100,%00000000,%01111110,%00000000,%00000000 ; char 197
 226+ 50C3 00 7E 00 00
 227+ 50C7 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 227+ 50CB 54 A8 00 00
 228+ 50CF 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11100000,%11000000,%10000000,%00000000 ; char 199
 228+ 50D3 E0 C0 80 00
 229+ 50D7 FE 7C 38 10          defb %11111110,%01111100,%00111000,%00010000,%00000000,%00000000,%00000000,%00000000 ; char 200
 229+ 50DB 00 00 00 00
 230+ 50DF 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00000111,%00000011,%00000001,%00000000 ; char 201
 230+ 50E3 07 03 01 00
 231+ 50E7 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00010000,%00111000,%01111100,%11111110 ; char 202
 231+ 50EB 10 38 7C FE
 232+ 50EF 10 38 7C 10          defb %00010000,%00111000,%01111100,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 203 (up arrow)
 232+ 50F3 10 10 10 00
 233+ 50F7 1E 0E 0E 12          defb %00011110,%00001110,%00001110,%00010010,%00100000,%01000000,%00000000,%00000000 ; char 204 (up right arrow)
 233+ 50FB 20 40 00 00
 234+ 50FF 00 08 0C FE          defb %00000000,%00001000,%00001100,%11111110,%00001100,%00001000,%00000000,%00000000 ; char 205 (right arrow)
 234+ 5103 0C 08 00 00
 235+ 5107 00 40 20 12          defb %00000000,%01000000,%00100000,%00010010,%00001110,%00001110,%00011110,%00000000 ; char 206 (down right arrow)
 235+ 510B 0E 0E 1E 00
 236+ 510F 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%01111100,%00111000,%00010000,%00000000 ; char 207 (down arrow)
 236+ 5113 7C 38 10 00
 237+ 5117 00 04 08 90          defb %00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000,%00000000 ; char 208 (down left arrow)
 237+ 511B E0 E0 F0 00
 238+ 511F 00 20 60 FE          defb %00000000,%00100000,%01100000,%11111110,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 238+ 5123 60 20 00 00
 239+ 5127 F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 239+ 512B 08 04 00 00
 240+ 512F 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 240+ 5133 F0 44 38 00
 241+ 5137 00 02 7C A8          defb %00000000,%00000010,%01111100,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 241+ 513B 28 28 28 00
 242+ 513F 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001000,%00010000,%00010000,%00010000 ; char 213
 242+ 5143 08 10 10 10
 243+ 5147 00 00 00 C0          defb %00000000,%00000000,%00000000,%11000000,%00100000,%00010000,%00010000,%00010000 ; char 214
 243+ 514B 20 10 10 10
 244+ 514F 10 10 20 C0          defb %00010000,%00010000,%00100000,%11000000,%00000000,%00000000,%00000000,%00000000 ; char 215
 244+ 5153 00 00 00 00
 245+ 5157 10 10 08 07          defb %00010000,%00010000,%00001000,%00000111,%00000000,%00000000,%00000000,%00000000 ; char 216
 245+ 515B 00 00 00 00
 246+ 515F 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001111,%00011100,%00011000,%00011000 ; char 217
 246+ 5163 0F 1C 18 18
 247+ 5167 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00111000,%00011000,%00011000 ; char 218
 247+ 516B F0 38 18 18
 248+ 516F 18 18 38 F0          defb %00011000,%00011000,%00111000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 248+ 5173 E0 00 00 00
 249+ 5177 18 18 1C 0F          defb %00011000,%00011000,%00011100,%00001111,%00000111,%00000000,%00000000,%00000000 ; char 220
 249+ 517B 07 00 00 00
 250+ 517F 00 3C 42 42          defb %00000000,%00111100,%01000010,%01000010,%01000010,%01000010,%00111100,%00000000 ; char 221
 250+ 5183 42 42 3C 00
 251+ 5187 00 3C 7E 7E          defb %00000000,%00111100,%01111110,%01111110,%01111110,%01111110,%00111100,%00000000 ; char 222
 251+ 518B 7E 7E 3C 00
 252+ 518F 00 18 3C 7E          defb %00000000,%00011000,%00111100,%01111110,%01111110,%00111100,%00011000,%00000000 ; char 223
 252+ 5193 7E 3C 18 00
 253+ 5197 FF FE FC F8          defb %11111111,%11111110,%11111100,%11111000,%11110000,%11100000,%11000000,%10000000 ; char 224
 253+ 519B F0 E0 C0 80
 254+ 519F FF 7F 3F 1F          defb %11111111,%01111111,%00111111,%00011111,%00001111,%00000111,%00000011,%00000001 ; char 225
 254+ 51A3 0F 07 03 01
 255+ 51A7 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00011111,%00111111,%01111111,%11111111 ; char 226
 255+ 51AB 1F 3F 7F FF
 256+ 51AF 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11111110,%11111111 ; char 227
 256+ 51B3 F8 FC FE FF
 257+ 51B7 00 02 06 6C          defb %00000000,%00000010,%00000110,%01101100,%01111000,%01110000,%01100000,%00000000 ; char 228 (checkmark)
 257+ 51BB 78 70 60 00
 258+ 51BF 00 66 3C 18          defb %00000000,%01100110,%00111100,%00011000,%00111100,%01100110,%00000000,%00000000 ; char 229 (x)
 258+ 51C3 3C 66 00 00
 259+ 51C7 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%00111000,%00010000,%00111000,%00010000 ; char 230 (female)
 259+ 51CB 38 10 38 10
 260+ 51CF 07 03 3D 44          defb %00000111,%00000011,%00111101,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 231 (male)
 260+ 51D3 44 44 38 00
 261+ 51D7 78 44 42 42          defb %01111000,%01000100,%01000010,%01000010,%01000010,%01000010,%01000010,%01111110 ; char 232 (new doc)
 261+ 51DB 42 42 42 7E
 262+ 51DF 00 F8 FF 81          defb %00000000,%11111000,%11111111,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 233 (folder)
 262+ 51E3 81 81 81 FF
 263+ 51E7 10 7C FE 54          defb %00010000,%01111100,%11111110,%01010100,%01010100,%01010100,%01010100,%01111100 ; char 234 (trash bin)
 263+ 51EB 54 54 54 7C
 264+ 51EF FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10111101,%10101101,%10101101,%11111111 ; char 235 (floppy disk)
 264+ 51F3 BD AD AD FF
 265+ 51F7 00 EA AA AC          defb %00000000,%11101010,%10101010,%10101100,%10101100,%10101010,%11101010,%00000000 ; char 236 (OK)
 265+ 51FB AC AA EA 00
 266+ 51FF 18 7E FF 7E          defb %00011000,%01111110,%11111111,%01111110,%01111110,%01100110,%01100110,%01100110 ; char 237 (home)
 266+ 5203 7E 66 66 66
 267+ 5207 3C 42 91 91          defb %00111100,%01000010,%10010001,%10010001,%10011101,%10000001,%01000010,%00111100 ; char 238 (clock)
 267+ 520B 9D 81 42 3C
 268+ 520F 00 02 05 FD          defb %00000000,%00000010,%00000101,%11111101,%10100101,%10100010,%00000000,%00000000 ; char 239 (key)
 268+ 5213 A5 A2 00 00
 269+ 5217 08 0C 3E 4C          defb %00001000,%00001100,%00111110,%01001100,%01001000,%01000010,%01000010,%00111100 ; char 240 (undo)
 269+ 521B 48 42 42 3C
 270+ 521F 00 FF C3 A5          defb %00000000,%11111111,%11000011,%10100101,%10011001,%10000001,%11111111,%00000000 ; char 241 (letter)
 270+ 5223 99 81 FF 00
 271+ 5227 38 44 44 7C          defb %00111000,%01000100,%01000100,%01111100,%01111100,%01111100,%01111100,%00000000 ; char 242 (lock)
 271+ 522B 7C 7C 7C 00
 272+ 522F 06 09 09 F8          defb %00000110,%00001001,%00001001,%11111000,%11111000,%11111000,%11111000,%00000000 ; char 243 (unlock)
 272+ 5233 F8 F8 F8 00
 273+ 5237 FF FF 81 AD          defb %11111111,%11111111,%10000001,%10101101,%10100101,%10100101,%10000001,%11111111 ; char 244 (calendar)
 273+ 523B A5 A5 81 FF
 274+ 523F 01 1A 24 4A          defb %00000001,%00011010,%00100100,%01001010,%01010010,%00100100,%01011000,%10000000 ; char 245 (diameter)
 274+ 5243 52 24 58 80
 275+ 5247 7E 81 81 81          defb %01111110,%10000001,%10000001,%10000001,%10000001,%01110110,%00001100,%00000100 ; char 246 (baloon)
 275+ 524B 81 76 0C 04
 276+ 524F 0C 0A 0A 0A          defb %00001100,%00001010,%00001010,%00001010,%00001000,%00011000,%00111000,%00010000 ; char 247 (note)
 276+ 5253 08 18 38 10
 277+ 5257 12 31 F5 F5          defb %00010010,%00110001,%11110101,%11110101,%11110101,%11110101,%00110001,%00010010 ; char 248 (audio on)
 277+ 525B F5 F5 31 12
 278+ 525F 10 30 F0 F0          defb %00010000,%00110000,%11110000,%11110000,%11110000,%11110000,%00110000,%00010000 ; char 249 (audio off)
 278+ 5263 F0 F0 30 10
 279+ 5267 40 60 70 78          defb %01000000,%01100000,%01110000,%01111000,%01111100,%01111110,%01111000,%01001000 ; char 250 (pointer)
 279+ 526B 7C 7E 78 48
 280+ 526F 3C 42 99 A1          defb %00111100,%01000010,%10011001,%10100001,%10100001,%10011001,%01000010,%00111100 ; char 251 (Â©)
 280+ 5273 A1 99 42 3C
 281+ 5277 18 24 20 78          defb %00011000,%00100100,%00100000,%01111000,%00100000,%00100010,%01011100,%00000000 ; char 252 (Â£)
 281+ 527B 20 22 5C 00
 282+ 527F 3C 42 78 24          defb %00111100,%01000010,%01111000,%00100100,%00100100,%00011110,%01000010,%00111100 ; char 253 (Â§)
 282+ 5283 24 1E 42 3C
 283+ 5287 00 00 10 00          defb %00000000,%00000000,%00010000,%00000000,%01111100,%00000000,%00010000,%00000000 ; char 254 (Ã·)
 283+ 528B 7C 00 10 00
 284+ 528F FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 255 (cursor)
 284+ 5293 FF FF FF FF
 285+ 5297
# file closed: ../include/vdp/8x8fonts-r18.asm
  83  5297                  INCLUDE "../include/vdp/logo-fonts.asm"
# file opened: ../include/vdp/logo-fonts.asm
   1+ 5297              ; ------------------------------------------------------------------------------
   2+ 5297              ; LM80C - LOGO CHARSET - R1.1
   3+ 5297              ; ------------------------------------------------------------------------------
   4+ 5297              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 5297              ; designed by Leonardo Miliani. More info at
   6+ 5297              ; www DOT leonardomiliani DOT com
   7+ 5297              ; ------------------------------------------------------------------------------
   8+ 5297              ; Code Revision:
   9+ 5297              ; R1.0 - 20200124 - First revision: logo chars
  10+ 5297              ; R1.1 - 20200229 - Adopted usual hexadecimal & binary prefixes
  11+ 5297              ; ------------------------------------------------------------------------------
  12+ 5297
  13+ 5297              LOGOFONT:   equ $
  14+ 5297 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; 0
  14+ 529B 00 00 00 00
  15+ 529F FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; 1
  15+ 52A3 FF FF FF FF
  16+ 52A7 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; 2
  16+ 52AB 00 00 00 00
  17+ 52AF 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; 3
  17+ 52B3 0F 0F 0F 0F
  18+ 52B7 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; 4
  18+ 52BB FF FF FF FF
  19+ 52BF F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; 5
  19+ 52C3 F0 F0 F0 F0
  20+ 52C7 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; 6
  20+ 52CB 0F 0F 0F 0F
  21+ 52CF 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; 7
  21+ 52D3 F0 F0 F0 F0
  22+ 52D7 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; 8
  22+ 52DB 00 00 00 00
  23+ 52DF 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; 9
  23+ 52E3 00 00 00 00
  24+ 52E7 00 00 00 FC              defb %00000000,%00000000,%00000000,%11111100,%11111111,%00000111,%00000011,%00000000 ; 10
  24+ 52EB FF 07 03 00
  25+ 52EF 00 00 00 3F              defb %00000000,%00000000,%00000000,%00111111,%11111111,%11100000,%11000000,%00000000 ; 11
  25+ 52F3 FF E0 C0 00
  26+ 52F7 18 18 1F 19              defb %00011000,%00011000,%00011111,%00011001,%00011001,%00011111,%00011000,%00011000 ; 12
  26+ 52FB 19 1F 18 18
  27+ 52FF 18 18 F8 98              defb %00011000,%00011000,%11111000,%10011000,%10011000,%11111000,%00011000,%00011000 ; 13
  27+ 5303 98 F8 18 18
  28+ 5307 18 18 1C 1F              defb %00011000,%00011000,%00011100,%00011111,%00001111,%00000000,%00000000,%00000000 ; 14
  28+ 530B 0F 00 00 00
  29+ 530F 00 00 00 0F              defb %00000000,%00000000,%00000000,%00001111,%00011111,%00011100,%00011000,%00011000 ; 15
  29+ 5313 1F 1C 18 18
  30+ 5317 00 00 00 F0              defb %00000000,%00000000,%00000000,%11110000,%11111000,%00111000,%00011000,%00011000 ; 16
  30+ 531B F8 38 18 18
  31+ 531F 18 18 38 F8              defb %00011000,%00011000,%00111000,%11111000,%11110000,%00000000,%00000000,%00000000 ; 17
  31+ 5323 F0 00 00 00
  32+ 5327 00 00 00 FF              defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; 18
  32+ 532B FF 00 00 00
  33+ 532F 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%11111111,%11111111,%11111111,%11111111 ; 19
  33+ 5333 FF FF FF FF
  34+ 5337 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11111111,%11111111,%11111111,%11111111 ; 20
  34+ 533B FF FF FF FF
  35+ 533F FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11110000,%11110000,%11110000,%11110000 ; 21
  35+ 5343 F0 F0 F0 F0
  36+ 5347 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00001111,%00001111,%00001111,%00001111 ; 22
  36+ 534B 0F 0F 0F 0F
  37+ 534F 00 30 78 78              defb %00000000,%00110000,%01111000,%01111000,%00110000,%00000000,%00000000,%00000000 ; 23
  37+ 5353 30 00 00 00
  38+ 5357
# file closed: ../include/vdp/logo-fonts.asm
  84  5357
  85  5357              ; include ROM/RAM switcher
  86  5357                  INCLUDE "../include/switcher/switcher-r1.03.asm"
# file opened: ../include/switcher/switcher-r1.03.asm
   1+ 5357              ; ------------------------------------------------------------------------------
   2+ 5357              ; LM80C - ROM/RAM SWITCHER - R1.03
   3+ 5357              ; ------------------------------------------------------------------------------
   4+ 5357              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 5357              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 5357              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 5357              ; kind of warranty: you can use them at your own risk.
   8+ 5357              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 5357              ; maintain the copyright notices, include this advice and the note to the
  10+ 5357              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 5357              ; redistribuite them.
  12+ 5357              ; https://www.leonardomiliani.com
  13+ 5357              ;
  14+ 5357              ; Please support me by visiting the following links:
  15+ 5357              ; Main project page: https://www.leonardomiliani.com
  16+ 5357              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 5357              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 5357              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 5357              ; ------------------------------------------------------------------------------
  20+ 5357              ; Code Revision:
  21+ 5357              ; R1.0   - 20200718 - First version
  22+ 5357              ; R1.1   - 20200827 - PIO settings now are part of the file
  23+ 5357              ; R1.02  - 20210319 - support for LM80C DOS and its repositioning into high-RAM
  24+ 5357              ; R1.03  - 20210408 - code revision
  25+ 5357              ;-------------------------------------------------------------------------------
  26+ 5357
  27+ 5357              TMP_FW_LOC:     equ     $8000           ; address from where to make a temporary copy of the FW
  28+ 5357              ;-------------------------------------------------------------------------------
  29+ 5357              ; THIS CODE WILL BE EXECUTED FROM RAM
  30+ 5357 3E FC        RAMRUN:         ld      A,%11111100     ; set ROM off and RAM on..
  31+ 5359 D3 01                        out     (PIO_DB),A      ; ...by setting bit #0 to 0 (and leave VRAM bank #0)
  32+ 535B 01 A3 53                     ld      BC,END_OF_FW    ; let's copy back FW into low RAM - bytes to copy
  33+ 535E 21 00 80                     ld      HL,TMP_FW_LOC   ; source address
  34+ 5361 11 00 00                     ld      DE,$0000        ; dest. address
  35+ 5364 ED B0                        ldir                    ; copy!
  36+ 5366 AF                           xor     A
  37+ 5367 D3 01                        out     (PIO_DB),A      ; all LEDs off - finished copying
  38+ 5369 C3 AE 02                     jp      INIT_HW         ; return control to old init (now into RAM)
  39+ 536C
  40+ 536C              ;-------------------------------------------------------------------------------
  41+ 536C              ; copy the whole contents of ROM into RAM then disable the first memory
  42+ 536C 3A 00 54     ROM2RAM:        ld      A,(basicStarted); check if BASIC is already started
  43+ 536F FE 59                        cp      'Y'             ; to see if this is a power-up
  44+ 5371 20 0C                        jr      NZ,CNTCP2RAM    ; no, continue copy to RAM
  45+ 5373                              ; WARNING: Do **NOT** change the following "out()" sequence, ABSOLUTELY!
  46+ 5373 3E CF                        ld      A,%11001111     ; set mode 3 ("control mode")
  47+ 5375 D3 03                        out     (PIO_CB),A      ; for PIO port B
  48+ 5377 AF                           xor     A               ; set LEDs off, RAM on, VRAM on bank #0
  49+ 5378 D3 01                        out     (PIO_DB),A      ; send settings to PIO register
  50+ 537A D3 03                        out     (PIO_CB),A      ; set pins following register's status
  51+ 537C C3 AE 02                     jp      INIT_HW         ; jump to re-init HW
  52+ 537F
  53+ 537F                              ; WARNING: Do **NOT** change the following "out()" sequence, ABSOLUTELY!
  54+ 537F 3E CF        CNTCP2RAM:      ld      A,%11001111     ; set mode 3 (mode control)
  55+ 5381 D3 03                        out     (PIO_CB),A      ; for PIO port B
  56+ 5383 3E FD                        ld      A,%11111101     ; set pin #0 as HIGH to enable ROM
  57+ 5385 D3 01                        out     (PIO_DB),A      ; store the value into the internal register
  58+ 5387 AF                           xor     A               ; set pins to OUTPUT
  59+ 5388 D3 03                        out     (PIO_CB),A      ; for port B, activating the RAM
  60+ 538A                              ; copy DOS
  61+ 538A 01 DB 11                     ld      BC,$FFFF-DOSSTART+1 ; bytes to copy
  62+ 538D 21 A3 53                     ld      HL,END_OF_FW    ; load DOS from its original location and...
  63+ 5390 11 25 EE                     ld      DE,DOSSTART     ; ...store it into its portion of memory
  64+ 5393 ED B0                        ldir                    ; copy!
  65+ 5395                              ; copy BASIC
  66+ 5395 01 A3 53                     ld      BC,END_OF_FW    ; copy FW from ROM to high RAM
  67+ 5398 21 00 00                     ld      HL,$0000        ; source address
  68+ 539B 11 00 80                     ld      DE,TMP_FW_LOC   ; dest. address
  69+ 539E ED B0                        ldir                    ; copy!
  70+ 53A0 C3 57 D3                     jp      RAMRUN+TMP_FW_LOC; jump to execute code into RAM
  71+ 53A3
  72+ 53A3              ;-------------------------------------------------------------------------------
  73+ 53A3              END_OF_FW:      equ     $   ; this is the last cell of the firmware
# file closed: ../include/switcher/switcher-r1.03.asm
  87  53A3
  88  53A3              ; include workspace equates
  89  53A3                  INCLUDE "../include/workspace/workspace-r1.02.asm"
# file opened: ../include/workspace/workspace-r1.02.asm
   1+ 53A3              ; ------------------------------------------------------------------------------
   2+ 53A3              ; LM80C 64K - WORKSPACE EQUATES - R1.02
   3+ 53A3              ; ------------------------------------------------------------------------------
   4+ 53A3              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 53A3              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 53A3              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 53A3              ; kind of warranty: you can use them at your own risk.
   8+ 53A3              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 53A3              ; maintain the copyright notices, include this advice and the note to the
  10+ 53A3              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 53A3              ; redistribuite them.
  12+ 53A3              ; https://www.leonardomiliani.com
  13+ 53A3              ;
  14+ 53A3              ; Please support me by visiting the following links:
  15+ 53A3              ; Main project page: https://www.leonardomiliani.com
  16+ 53A3              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 53A3              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 53A3              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 53A3              ; ------------------------------------------------------------------------------
  20+ 53A3
  21+ 53A3              ; set starting of RAM based on computer model
  22+ 53A3              SERBUF_START    equ     END_OF_FW       ; RAM starts here
  23+ 53A3
  24+ 53A3              ;-------------------------------------------------------------------------------
  25+ 53A3              serInPtr        equ     SERBUF_START + SER_BUFSIZE
  26+ 53A3              serRdPtr        equ     serInPtr+2
  27+ 53A3              serBufUsed      equ     serRdPtr+2
  28+ 53A3              basicStarted    equ     serBufUsed+1
  29+ 53A3              bufWrap         equ     (SERBUF_START + SER_BUFSIZE) & $FF
  30+ 53A3              TEMPSTACK       equ     CURPOS - 3      ; top of BASIC line input buffer so is "free ram" when BASIC resets
  31+ 53A3
  32+ 53A3              ; BASIC WORK SPACE LOCATIONS
  33+ 53A3              ; THE INTERPRETER ALLOCATES THE FOLLOWING RAM CELLS
  34+ 53A3              ; TO STORE IMPORTANT VALUES USED FOR SOME SPECIFIC FUNCTIONS:
  35+ 53A3              ; THEY CAN BE VECTOR (ADDRESSES) FUNCTIONS, SYSTEM DATAS (I.E. VARIABLES)
  36+ 53A3              ; AND SO ON. THE FIRST CELLS ARE FILLED WITH VALUES STORED INTO ROM AT $(INITAB) ADDRESS
  37+ 53A3              WRKSPC          equ     basicStarted+$01; (3) BASIC Work space
  38+ 53A3              NMIUSR          equ     WRKSPC+$03      ; (3) NMI exit point routine
  39+ 53A3              USR             equ     NMIUSR+$03      ; (3) "USR (x)" jump  <-- in (USR+$01)/(USR+$02) the user can store the address of a specific machine language routine
  40+ 53A3              OUTSUB          equ     USR+$03         ; (1) "out p,n"
  41+ 53A3              OTPORT          equ     OUTSUB+$01      ; (2) Port (p)
  42+ 53A3              DIVSUP          equ     OTPORT+$02      ; (1) Division support routine
  43+ 53A3              DIV1            equ     DIVSUP+$01      ; (4) <- Values
  44+ 53A3              DIV2            equ     DIV1+$04        ; (4) <-   to
  45+ 53A3              DIV3            equ     DIV2+$04        ; (3) <-   be
  46+ 53A3              DIV4            equ     DIV3+$03        ; (2) <-inserted
  47+ 53A3              SEED            equ     DIV4+$02        ; (35) Random number seed  <-- starting address of a seed table
  48+ 53A3              LSTRND          equ     SEED+$23        ; (4) Last random number
  49+ 53A3              INPSUB          equ     LSTRND+$04      ; (1) INP A,(x) Routine
  50+ 53A3              INPORT          equ     INPSUB+$01      ; (2) PORT (x)
  51+ 53A3              LWIDTH          equ     INPORT+$02      ; (1) Terminal width
  52+ 53A3              COMMAN          equ     LWIDTH+$01      ; (1) Width for commas
  53+ 53A3              NULFLG          equ     COMMAN+$01      ; (1) Null after input byte flag
  54+ 53A3              CTLOFG          equ     NULFLG+$01      ; (1) Control "O" flag
  55+ 53A3              CHKSUM          equ     CTLOFG+$01      ; (2) Array load/save check sum
  56+ 53A3              NMIFLG          equ     CHKSUM+$02      ; (1) Flag for NMI break routine
  57+ 53A3              BRKFLG          equ     NMIFLG+$01      ; (1) Break flag
  58+ 53A3              RINPUT          equ     BRKFLG+$01      ; (3) Input reflection
  59+ 53A3              STRSPC          equ     RINPUT+$03      ; (2) Pointer to bottom (start) of string space - default is 100 bytes below the top of memory
  60+ 53A3              LINEAT          equ     STRSPC+$02      ; (2) Current line number. -1 means "direct mode", while -2 means cold start.
  61+ 53A3              HLPLN           equ     LINEAT+$02      ; (2) Current line with errors
  62+ 53A3              KEYDEL          equ     HLPLN+$02       ; (1) delay before key auto-repeat starts
  63+ 53A3              AUTOKE          equ     KEYDEL+$01      ; (1) delay for key auto-repeat
  64+ 53A3              FNKEYS          equ     AUTOKE+$01      ; (128) default text of FN keys
  65+ 53A3              BASTXT          equ     FNKEYS+$80      ; (3) Pointer to start of BASIC program in memory
  66+ 53A3              ; - - - - - - - - - - - - - - - - - - -   the above are locations pre-filled by the firmware at startup
  67+ 53A3              BUFFER          equ     BASTXT+$03      ; (5) Input buffer
  68+ 53A3              STACK           equ     BUFFER+$05      ; (85) Initial stack
  69+ 53A3              CURPOS          equ     STACK+$55       ; (1) Character position on line
  70+ 53A3              LCRFLG          equ     CURPOS+$01      ; (1) Locate/Create flag for DIM statement
  71+ 53A3              TYPE            equ     LCRFLG+$01      ; (1) Data type flag: 0=numeric, non-zero=string
  72+ 53A3              DATFLG          equ     TYPE+$01        ; (1) Literal statement flag
  73+ 53A3              LSTRAM          equ     DATFLG+$01      ; (2) Last available RAM location for BASIC
  74+ 53A3              DOSER           equ     LSTRAM+$02      ; (1) Error from DOS
  75+ 53A3              TMPDBF          equ     DOSER+$01       ; (36) Secondary buffer for DOS
  76+ 53A3              TMSTPT          equ     TMPDBF+$24      ; (2) Temporary string pointer
  77+ 53A3              TMSTPL          equ     TMSTPT+$02      ; (12) Temporary string pool
  78+ 53A3              TMPSTR          equ     TMSTPL+$0C      ; (4) Temporary string
  79+ 53A3              STRBOT          equ     TMPSTR+$04      ; (2) Bottom of string space
  80+ 53A3              CUROPR          equ     STRBOT+$02      ; (2) Current operator in EVAL
  81+ 53A3              LOOPST          equ     CUROPR+$02      ; (2) First statement of loop
  82+ 53A3              DATLIN          equ     LOOPST+$02      ; (2) Line of current DATA item
  83+ 53A3              FORFLG          equ     DATLIN+$02      ; (1) "FOR" loop flag
  84+ 53A3              LSTBIN          equ     FORFLG+$01      ; (1) Last byte entered
  85+ 53A3              READFG          equ     LSTBIN+$01      ; (1) Read/Input flag
  86+ 53A3              BRKLIN          equ     READFG+$01      ; (2) Line of break
  87+ 53A3              NXTOPR          equ     BRKLIN+$02      ; (2) Next operator in EVAL
  88+ 53A3              ERRLIN          equ     NXTOPR+$02      ; (2) Line of error
  89+ 53A3              CONTAD          equ     ERRLIN+$02      ; (2) Where to CONTinue
  90+ 53A3              TMRCNT          equ     CONTAD+$02      ; (4) TMR counter for 1/100 seconds
  91+ 53A3              CTC0IV          equ     TMRCNT+$04      ; (3) CTC0 interrupt vector
  92+ 53A3              CTC1IV          equ     CTC0IV+$03      ; (3) CTC1 interrupt vector
  93+ 53A3              CTC2IV          equ     CTC1IV+$03      ; (3) CTC2 interrupt vector
  94+ 53A3              CTC3IV          equ     CTC2IV+$03      ; (3) CTC3 interrupt vector
  95+ 53A3              ; - - - - - - - - - - - - - - - - - - -   VIDEO REGISTERS - FROM HERE...
  96+ 53A3              SCR_SIZE_W      equ     CTC3IV+$03      ; (1) screen width (it can be either 40 chars or 32 chars/bytes)
  97+ 53A3              SCR_SIZE_H      equ     SCR_SIZE_W+$01  ; (1) screen height (it can be 24/48/192: 24 for text, 48 for MC, 192 for graphics)
  98+ 53A3              SCR_MODE        equ     SCR_SIZE_H+$01  ; (1) screen mode (0=text, 1=G1, 2=G2, 3=MC, 4=ExG2)
  99+ 53A3              SCR_NAM_TB      equ     SCR_MODE+$01    ; (2) video name table address
 100+ 53A3              SCR_CURS_X      equ     SCR_NAM_TB+$02  ; (1) cursor X
 101+ 53A3              SCR_CURS_Y      equ     SCR_CURS_X+$01  ; (1) cursor Y
 102+ 53A3              SCR_CUR_NX      equ     SCR_CURS_Y+$01  ; (1) new cursor X position
 103+ 53A3              SCR_CUR_NY      equ     SCR_CUR_NX+$01  ; (1) new cursor Y position
 104+ 53A3              SCR_ORG_CHR     equ     SCR_CUR_NY+$01  ; (1) original char positioned under the cursor
 105+ 53A3              CRSR_STATE      equ     SCR_ORG_CHR+$01 ; (1) state of cursor (1=on, 0=off)
 106+ 53A3              LSTCSRSTA       equ     CRSR_STATE+$01  ; (1) last cursor state
 107+ 53A3              PRNTVIDEO       equ     LSTCSRSTA+$01   ; (1) print on video buffer (1=on / 0=off) set to off on graphic only modes
 108+ 53A3              CHR4VID         equ     PRNTVIDEO+$01   ; (1) char for video buffer
 109+ 53A3              FRGNDCLR        equ     CHR4VID+$01     ; (1) foreground color as set by SCREEN or COLOR commands
 110+ 53A3              BKGNDCLR        equ     FRGNDCLR+$01    ; (1) background color as set by SCREEN or COLOR commands
 111+ 53A3              TMPBFR1         equ     BKGNDCLR+$01    ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 112+ 53A3              TMPBFR2         equ     TMPBFR1+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 113+ 53A3              TMPBFR3         equ     TMPBFR2+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 114+ 53A3              TMPBFR4         equ     TMPBFR3+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 115+ 53A3              VIDEOBUFF       equ     TMPBFR4+$02     ; (40) buffer used for video scrolling and other purposes
 116+ 53A3              VIDTMP1         equ     VIDEOBUFF+$28   ; (2) temporary video word
 117+ 53A3              VIDTMP2         equ     VIDTMP1+$02     ; (2) temporary video word
 118+ 53A3              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO VPD OUT OF THIS RANGE,
 119+ 53A3                                                      ; OTHERWISE YOU WILL HAVE TO CHECK THE POINTER IN "CLR_RAM_REG" FUNCTION
 120+ 53A3              ; - - - - - - - - - - - - - - - - - - -   SOUND & KEYBOARD REGISTERS - FROM HERE...
 121+ 53A3              CHASNDDTN       equ     VIDTMP2+$02     ; (2) sound Ch.A duration (in 1/100s)
 122+ 53A3              CHBSNDDTN       equ     CHASNDDTN+$02   ; (2) sound Ch.B duration (in 1/100s)
 123+ 53A3              CHCSNDDTN       equ     CHBSNDDTN+$02   ; (2) sound Ch.C duration (in 1/100s)
 124+ 53A3              KBDNPT          equ     CHCSNDDTN+$02   ; (1) temp cell used to flag if input comes from keyboard
 125+ 53A3              KBTMP           equ     KBDNPT+$01      ; (1) temp cell used by keyboard scanner
 126+ 53A3              TMPKEYBFR       equ     KBTMP+$01       ; (1) temp buffer for last key pressed
 127+ 53A3              LASTKEYPRSD     equ     TMPKEYBFR+$01   ; (1) last key code pressed
 128+ 53A3              STATUSKEY       equ     LASTKEYPRSD+$01 ; (1) status key, used for auto-repeat
 129+ 53A3              KEYTMR          equ     STATUSKEY+$01   ; (2) timer used for auto-repeat key
 130+ 53A3              CONTROLKEYS     equ     KEYTMR+$02      ; (1) flags for control keys (bit#0=SHIFT; bit#1=CTRL; bit#2=C=)
 131+ 53A3              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO PSG OUT OF THIS RANGE,
 132+ 53A3                                                      ; OTHERWISE YOU WILL HAVE TO CHANGE THE POINTER IN "initPSG" FUNCTION
 133+ 53A3              SERIALS_EN      equ     CONTROLKEYS+$01 ; (1) serial ports status: bit 0 for Port1 (A), bit 1 for Port2 (B): 0=OFF, 1=ON
 134+ 53A3              SERABITS        equ     SERIALS_EN+$01  ; (1) serial port A data bits
 135+ 53A3              SERBBITS        equ     SERABITS+$01    ; (1) serial port B data bits
 136+ 53A3              DOS_EN          equ     SERBBITS+$01    ; (1) DOS enable/disable (1/0)
 137+ 53A3              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 138+ 53A3                                                      ; from here there are the RAM locations that
 139+ 53A3                                                      ; are saved during SAVE
 140+ 53A3              PROGND          equ     DOS_EN+$01      ; (2) End of program
 141+ 53A3              VAREND          equ     PROGND+$02      ; (2) End of variables
 142+ 53A3              ARREND          equ     VAREND+$02      ; (2) End of arrays
 143+ 53A3              NXTDAT          equ     ARREND+$02      ; (2) Next data item
 144+ 53A3              FNRGNM          equ     NXTDAT+$02      ; (2) Name of FN argument
 145+ 53A3              FNARG           equ     FNRGNM+$02      ; (4) FN argument value
 146+ 53A3              FPREG           equ     FNARG+$04       ; (3) Floating point register
 147+ 53A3              FPEXP           equ     FPREG+$03       ; (1) Floating point exponent
 148+ 53A3              SGNRES          equ     FPEXP+$01       ; (1) Sign of result
 149+ 53A3              PBUFF           equ     SGNRES+$01      ; (13) Number print buffer
 150+ 53A3              MULVAL          equ     PBUFF+$0D       ; (3) Multiplier
 151+ 53A3              PROGST          equ     MULVAL+$03      ; (100) Start of program text area
 152+ 53A3              STLOOK          equ     PROGST+$64      ; Start of memory test
 153+ 53A3
# file closed: ../include/workspace/workspace-r1.02.asm
  90  53A3
  91  53A3              ; include the latest versions of the CF & DOS modules
  92  53A3              ; do NOT move these files from this position and
  93  53A3              ; do NOT alter their order!
  94  53A3                  INCLUDE "../include/dos/dos-1.06.asm"
# file opened: ../include/dos/dos-1.06.asm
   1+ 53A3              ; ------------------------------------------------------------------------------
   2+ 53A3              ; LM80C 64K - DOS ROUTINES - R1.05
   3+ 53A3              ; ------------------------------------------------------------------------------
   4+ 53A3              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 53A3              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 53A3              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 53A3              ; kind of warranty: you can use them at your own risk.
   8+ 53A3              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 53A3              ; maintain the copyright notices, include this advice and the note to the
  10+ 53A3              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 53A3              ; redistribuite them.
  12+ 53A3              ; https://www.leonardomiliani.com
  13+ 53A3              ;
  14+ 53A3              ; Please support me by visiting the following links:
  15+ 53A3              ; Main project page: https://www.leonardomiliani.com
  16+ 53A3              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 53A3              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 53A3              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 53A3              ; ------------------------------------------------------------------------------
  20+ 53A3              ;
  21+ 53A3              ; ------------------------------------------------------------------------------
  22+ 53A3              ; Code Revision:
  23+ 53A3              ; R1.0  - 20210306 - first release
  24+ 53A3              ; R1.01 - 20210309 - code cleaning & optimization - new behaviour for ERASE (full erase everything)
  25+ 53A3              ; R1.02 - 20210310 - code optimization - new UNDELETE feature for DISK statement
  26+ 53A3              ; R1.03 - 20210316 - code size enhancements
  27+ 53A3              ; R1.04 - 20210319 - code re-organization and new positioning into RAM
  28+ 53A3              ; R1.05 - 20210327 - added support for sequential files
  29+ 53A3              ;
  30+ 53A3              ;------------------------------------------------------------------------------
  31+ 53A3
  32+ 53A3
  33+ 53A3                          org     $EE25
  34+ EE25
  35+ EE25              DOSSTART:   equ     $
  36+ EE25 4C 4D 38 30  DSKHDR      defb    "LM80C DOS",$00,"1.06",$00     ; disk header
  36+ EE29 43 20 44 4F
  36+ EE2D 53 00 31 2E
  36+ EE31 30 36 00
  37+ EE34 00 01        DSKDIRADR:  defb    $00,$01                         ; 1st sector of directory ($0001)
  38+ EE36
  39+ EE36              DIR_STRT:   equ     TMPDBF          ; (2) start of directory
  40+ EE36              DAT_STRT:   equ     DIR_STRT+$02    ; (2) start of DATA area
  41+ EE36              DIR_SCT:    equ     DAT_STRT+$02    ; (2) sector of first free entry in the directory
  42+ EE36              NTR_NBR:    equ     DIR_SCT+$02     ; (2) number of free entry
  43+ EE36              BYT_SIZ:    equ     NTR_NBR+$02     ; (2) file size in bytes
  44+ EE36              SCT_SIZ:    equ     BYT_SIZ+$02     ; (1) file size in sectors
  45+ EE36              MSW_SCT:    equ     SCT_SIZ+$01     ; (2) MSW sector of file
  46+ EE36              LSW_SCT:    equ     MSW_SCT+$02     ; (2) LSW sector of file
  47+ EE36              RAM_PTR:    equ     LSW_SCT+$02     ; (2) pointer to RAM
  48+ EE36              TPBF1:      equ     RAM_PTR+$02     ; (2) temp. word
  49+ EE36              TPBF2:      equ     TPBF1+$02       ; (2) temp. word
  50+ EE36              TPBF3:      equ     TPBF2+$02       ; (2) temp. word
  51+ EE36              TPBF4:      equ     TPBF3+$02       ; (2) temp. word
  52+ EE36              SRTMEM:     equ     TPBF4+$02       ; (2) temp. word
  53+ EE36              ENDMEM:     equ     SRTMEM+$02      ; (2) temp. word
  54+ EE36
  55+ EE36
  56+ EE36              ; **************************************************************************************
  57+ EE36              ;                            B A S I C    I N T E R F A C E
  58+ EE36              ;***************************************************************************************
  59+ EE36
  60+ EE36              ; OPEN a sequential file
  61+ EE36              ; OPEN "filename",flnm,mod = open file "filename" with #flnm for READ (mod=0) or WRITE (mod=1)
  62+ EE36 CD A7 F1     OPEN:   call    CHKFLNM         ; check if a string follows
  63+ EE39 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
  64+ EE3C 2C                   defb    ','
  65+ EE3D CD AE 2A             call    GETINT          ; get file number
  66+ EE40 32 3C 55             ld      (TMPDBF),A      ; store it into a temp buffer
  67+ EE43 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
  68+ EE46 2C                   defb    ','
  69+ EE47 CD AE 2A             call    GETINT          ; get mode
  70+ EE4A FE 02                cp      $02             ; 0 or 1?
  71+ EE4C D2 62 1E             jp      NC,FCERR        ; no, illegal function call
  72+ EE4F 32 3D 55             ld      (TMPDBF+1),A    ; store it into a temp buffer
  73+ EE52 2B                   dec     HL              ; dec 'cos GETCHR INCs
  74+ EE53 CD 97 1D             call    GETCHR          ; check if something follows
  75+ EE56 C2 50 18             jp      NZ,SNERR        ; if something more, raise a syntax error
  76+ EE59 E5                   push    HL              ; store code string pointer
  77+ EE5A CD A7 F3             call    OPNFIL          ; call open file
  78+ EE5D E1                   pop     HL              ; retrieve code string pointer
  79+ EE5E DA ED EF             jp      C,DOS_ERR       ; any error?
  80+ EE61 C9                   ret                     ; return to caller
  81+ EE62
  82+ EE62
  83+ EE62              ; CLOSE a file
  84+ EE62 CD AE 2A     CLOSE:  call    GETINT          ; look for a number
  85+ EE65 32 3C 55             ld      (TMPDBF),A      ; store file number
  86+ EE68 E5                   push    HL              ; store code string pointer
  87+ EE69 CD B1 F4             call    CLOSFIL         ; close an open file
  88+ EE6C E1                   pop     HL              ; retrieve code string pointer
  89+ EE6D DA ED EF             jp      C,DOS_ERR
  90+ EE70 C9                   ret                     ; return to caller
  91+ EE71
  92+ EE71
  93+ EE71              ; LOAD "filename"[,1]  <- load a BASIC program from disk
  94+ EE71              ; LOAD x,y,w,z         <- load a sector from disc, LBA address equals to ((((z*256)+w)*256)+y)*256)+x
  95+ EE71 CD C4 EE     LOAD:   call    LDSVPT          ; check what's following
  96+ EE74 CA 92 EE             jp      Z,LOADST        ; number - load a single sector
  97+ EE77 CD AB 3E             call    DIRMOD          ; a file can be loaded ONLY in direct mode
  98+ EE7A C2 65 18             jp      NZ,IMERR        ; raise error if in indirect mode
  99+ EE7D CD B1 F1             call    CHKFN1          ; string - evaluate file name
 100+ EE80 CD F4 EF             call    CHK1AR          ; check for ",1" argument
 101+ EE83 22 A5 55             ld      (TMPBFR1),HL    ; store HL
 102+ EE86 21 B3 EE             ld      HL,TXTLDG       ; loading message
 103+ EE89 CD 30 27             call    PRS             ; print
 104+ EE8C CD 78 F9             call    LODFILE         ; load file into memory
 105+ EE8F C3 A7 EE             jp      LDEND           ; retrieve registers and leave
 106+ EE92 2A A5 55     LOADST: ld      HL,(TMPBFR1)    ; retrieve HL
 107+ EE95 CD D6 EE             call    GET4AR          ; get 4 arguments
 108+ EE98 22 A5 55             ld      (TMPBFR1),HL    ; store HL
 109+ EE9B CD 13 FD             call    CF_SETSTR       ; set sector
 110+ EE9E CD 55 FD             call    CF_RD_SEC       ; read sector
 111+ EEA1 38 0B                jr      C,LDERR         ; load error?
 112+ EEA3 CD 49 FD             call    CF_STANDBY      ; put CF in standby mode
 113+ EEA6 AF                   xor     A               ; clear Carry
 114+ EEA7 2A A5 55     LDEND:  ld      HL,(TMPBFR1)    ; retrieve HL
 115+ EEAA DA ED EF             jp      C,DOS_ERR       ; jump if DOS error
 116+ EEAD C9                   ret                     ; return to caller
 117+ EEAE 1E 40        LDERR:  ld      E,D4            ; load error
 118+ EEB0 C3 6A 18             jp      ERROR
 119+ EEB3 4C 6F 61 64  TXTLDG: defb    "Loading file... ",0
 119+ EEB7 69 6E 67 20
 119+ EEBB 66 69 6C 65
 119+ EEBF 2E 2E 2E 20
 119+ EEC3 00
 120+ EEC4
 121+ EEC4
 122+ EEC4              ; common code for LOAD/SAVE to check the type of operation required
 123+ EEC4              ; (load/save a file or a single sector)
 124+ EEC4              ; returns Z if argument is a number, NZ if it's a string
 125+ EEC4 2B           LDSVPT: dec     HL              ; dec 'cos GETCHR INCs
 126+ EEC5 CD 97 1D             call    GETCHR          ; check if something follows
 127+ EEC8 CA 50 18             jp      Z,SNERR         ; if anything else, raise a syntax error
 128+ EECB 22 A5 55             ld      (TMPBFR1),HL    ; save current code string pointer
 129+ EECE CD 3A 22             call    EVAL            ; Evaluate expression
 130+ EED1 3A 37 55             ld      A,(TYPE)        ; Get variable type
 131+ EED4 B7                   or      A               ; Is it a string variable?
 132+ EED5 C9                   ret                     ; return to caller
 133+ EED6
 134+ EED6
 135+ EED6              ; shared code between LOAD and SAVE
 136+ EED6              ; get 4 arguments after the command LOAD or SAVE
 137+ EED6              ; and load them into appropriate registers
 138+ EED6 2A A5 55     GET4AR: ld      HL,(TMPBFR1)    ; retrieve string code pointer
 139+ EED9 CD AE 2A             call    GETINT          ; get 1st pointer
 140+ EEDC 32 3C 55             ld      (TMPDBF),A      ; store it into a temp buffer
 141+ EEDF CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
 142+ EEE2 2C                   defb    ','
 143+ EEE3 CD AE 2A             call    GETINT          ; get 2nd pointer
 144+ EEE6 32 3D 55             ld      (TMPDBF+1),A    ; store it into a temp buffer
 145+ EEE9 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
 146+ EEEC 2C                   defb    ','
 147+ EEED CD AE 2A             call    GETINT          ; get 3rd pointer
 148+ EEF0 32 3E 55             ld      (TMPDBF+2),A    ; store it into a temp buffer
 149+ EEF3 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
 150+ EEF6 2C                   defb    ','
 151+ EEF7 CD AE 2A             call    GETINT          ; get 4th pointer
 152+ EEFA 57                   ld      D,A             ; store it
 153+ EEFB 3A 3C 55             ld      A,(TMPDBF)      ; retrieve 1st pointer
 154+ EEFE 4F                   ld      C,A
 155+ EEFF 3A 3D 55             ld      A,(TMPDBF+1)    ; retrieve 2nd pointer
 156+ EF02 47                   ld      B,A
 157+ EF03 3A 3E 55             ld      A,(TMPDBF+2)    ; retrieve 3rd pointer
 158+ EF06 5F                   ld      E,A
 159+ EF07 CD D1 FC             call    CF_INIT         ; init CF card
 160+ EF0A DA 68 18             jp      C,NRERR         ; error if device not available/ready
 161+ EF0D C9                   ret                     ; return to caller
 162+ EF0E
 163+ EF0E
 164+ EF0E              ; save a file onto the disk
 165+ EF0E              ; syntax: save "filename" to save a BASIC program
 166+ EF0E              ; save x,y,z to save IO buffer into x-y-z sector
 167+ EF0E              ; save "filename",start,end to save a portion of memory
 168+ EF0E 2B           SAVE:   dec     HL              ; dec 'cos GETCHR INCs
 169+ EF0F CD 97 1D             call    GETCHR          ; check if something follows
 170+ EF12 CA 50 18             jp      Z,SNERR         ; if nothing else, raise a syntax error
 171+ EF15 22 A5 55             ld      (TMPBFR1),HL    ; save current code string pointer
 172+ EF18 CD 3A 22             call    EVAL            ; Evaluate expression
 173+ EF1B 3A 37 55             ld      A,(TYPE)        ; Get variable type
 174+ EF1E B7                   or      A               ; Is it a string variable?
 175+ EF1F CA 7D EF             jp      Z,SAVESCT       ; no - save a single sector
 176+ EF22 CD B1 F1             call    CHKFN1          ; yes, load string name
 177+ EF25 ED 53 AB 55          ld      (TMPBFR4),DE    ; store lenght into another buffer
 178+ EF29 ED 43 55 55          ld      (TPBF4+2),BC    ; store address into another buffer
 179+ EF2D 3E 80                ld      A,$80           ; set BAS as file type
 180+ EF2F 32 53 55             ld      (TPBF4),A
 181+ EF32 2B                   dec     HL              ; dec 'cos GETCHR INCs
 182+ EF33 CD 97 1D             call    GETCHR          ; check if something follows
 183+ EF36 28 30                jr      Z,SAVE1         ; no, jump over
 184+ EF38 CD 4E 1B             call    CHKSYN          ; yes - Make sure ',' follows
 185+ EF3B 2C                   defb    ','
 186+ EF3C 22 3C 55             ld      (TMPDBF),HL     ; store code string pointer
 187+ EF3F CD 3A 22             call    EVAL            ; check expression
 188+ EF42 2A 3C 55             ld      HL,(TMPDBF)     ; point back to the beginning of epression
 189+ EF45 3A 37 55             ld      A,(TYPE)        ; check result type
 190+ EF48 B7                   or      A               ; is it another string?
 191+ EF49 20 4B                jr      NZ,RENFIL       ; yes, jump to rename file
 192+ EF4B CD 28 22             call    GETNUM          ; no, this is the memory address for a BIN file
 193+ EF4E CD 4D 1E             call    DEINT           ; Get integer -32768 to 32767
 194+ EF51 ED 53 55 55          ld      (SRTMEM),DE     ; Store DE into a temp. buffer
 195+ EF55 CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
 196+ EF58 2C                   defb    ','
 197+ EF59 CD 28 22             call    GETNUM          ; Get memory address
 198+ EF5C CD 4D 1E             call    DEINT           ; Get integer -32768 to 32767
 199+ EF5F ED 53 57 55          ld      (ENDMEM),DE     ; Store DE into a temp. buffer
 200+ EF63 3E 81                ld      A,$81           ; set BIN for file type
 201+ EF65 32 53 55             ld      (TPBF4),A
 202+ EF68 CD AB 3E     SAVE1:  call    DIRMOD          ; can be executed ONLY in direct mode
 203+ EF6B C2 65 18             jp      NZ,IMERR        ; raise error if in indirect mode
 204+ EF6E 22 A5 55             ld      (TMPBFR1),HL    ; store code string pointer
 205+ EF71 21 C9 EF             ld      HL,TXTSVG       ; loading message
 206+ EF74 CD 30 27             call    PRS             ; print
 207+ EF77 CD AE F7             call    SAVFILE         ; load file into memory
 208+ EF7A C3 8F EF             jp      SVEND           ; retrieve registers and leave
 209+ EF7D                      ;save a single sector
 210+ EF7D 2A 3C 55     SAVESCT:ld      HL,(TMPDBF)     ; retrieve string code pointer
 211+ EF80 CD D6 EE             call    GET4AR          ; get 4 arguments
 212+ EF83 22 A5 55             ld      (TMPBFR1),HL    ; store code string pointer
 213+ EF86 CD 7C FD             call    CF_WR_SEC       ; read sector
 214+ EF89 38 39                jr      C,SVERR
 215+ EF8B CD 49 FD             call    CF_STANDBY      ; put CF in standby mode
 216+ EF8E AF                   xor     A               ; clear Carry
 217+ EF8F 2A A5 55     SVEND:  ld      HL,(TMPBFR1)    ; retrieve code string pointer
 218+ EF92 DA ED EF             jp      C,DOS_ERR       ; jump if DOS error
 219+ EF95 C9                   ret                     ; return to caller
 220+ EF96 CD 73 28     RENFIL: call    GSTRCU          ; check that a string follows
 221+ EF99 CD 84 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
 222+ EF9C ED 53 44 55          ld      (BYT_SIZ),DE    ; store values into
 223+ EFA0 ED 43 4B 55          ld      (RAM_PTR),BC    ; temp buffers
 224+ EFA4 E5                   push    HL              ; store code string pointer
 225+ EFA5 21 B3 EF             ld      HL,TXTRNM       ; point to "renaming file"
 226+ EFA8 CD 30 27             call    PRS             ; print string
 227+ EFAB CD E4 F8             call    CHNGNAM         ; rename file
 228+ EFAE E1                   pop     HL              ; retrieve code string pointer
 229+ EFAF DA ED EF             jp      C,DOS_ERR       ; any error?
 230+ EFB2 C9                   ret                     ; return to caller
 231+ EFB3 52 65 6E 61  TXTRNM: defb    "Renaming file...",0
 231+ EFB7 6D 69 6E 67
 231+ EFBB 20 66 69 6C
 231+ EFBF 65 2E 2E 2E
 231+ EFC3 00
 232+ EFC4 1E 3E        SVERR:  ld      E,D3            ; save error
 233+ EFC6 C3 6A 18             jp      ERROR
 234+ EFC9 53 61 76 69  TXTSVG: defb    "Saving file... ",0
 234+ EFCD 6E 67 20 66
 234+ EFD1 69 6C 65 2E
 234+ EFD5 2E 2E 20 00
 235+ EFD9
 236+ EFD9
 237+ EFD9              ; FILES
 238+ EFD9              ; list files on disk
 239+ EFD9 CD A4 FC     FILES:  call    CLRIOBF         ; clear I/O buffer
 240+ EFDC CD D1 FC             call    CF_INIT         ; init CF card
 241+ EFDF DA ED EF             jp      C,DOS_ERR       ; error if device not available/ready
 242+ EFE2 E5                   push    HL              ; store code string pointer
 243+ EFE3 16 01                ld      D,$01           ; print disk details and file list
 244+ EFE5 CD 71 F6             call    LST_FILES       ; list files
 245+ EFE8 E1                   pop     HL              ; retrieve code string pointer
 246+ EFE9 DA ED EF             jp      C,DOS_ERR       ; any error?
 247+ EFEC C9                   ret                     ; return to caller
 248+ EFED
 249+ EFED
 250+ EFED              ; raise a DOS error
 251+ EFED 3A 3B 55     DOS_ERR:ld      A,(DOSER)       ; load error code
 252+ EFF0 5F                   ld      E,A             ; copy into E
 253+ EFF1 C3 6A 18             jp      ERROR           ; goto error routine
 254+ EFF4
 255+ EFF4
 256+ EFF4              ; check for ",1" argument
 257+ EFF4              ; check if 1 is passed as argument after LOAD and ERASE
 258+ EFF4 AF           CHK1AR: xor     A               ; reset A
 259+ EFF5 32 53 55             ld      (TPBF4),A       ; default setting
 260+ EFF8                                              ; (load=store file in RAM using current BASIC pointers
 261+ EFF8                                              ; (erase=quick delete)
 262+ EFF8 2B                   dec     HL              ; dec 'cause GETCHR increments
 263+ EFF9 CD 97 1D             call    GETCHR          ; check if something follows
 264+ EFFC C8                   ret     Z               ; if nothing follows, return
 265+ EFFD CD 4E 1B             call    CHKSYN          ; Make sure ',' follows
 266+ F000 2C                   defb    ','
 267+ F001 CD AE 2A             call    GETINT          ; get a value
 268+ F004 3D                   dec     A               ; decrement it
 269+ F005 C2 50 18             jp      NZ,SNERR        ; not '1' - raise an error
 270+ F008 3C                   inc     A               ; A=1
 271+ F009 32 53 55             ld      (TPBF4),A       ; load=store file in RAM using address in file
 272+ F00C                                              ; erase=full delete
 273+ F00C C9                   ret                     ; return to caller
 274+ F00D
 275+ F00D
 276+ F00D              ; ERASE "filename"
 277+ F00D              ; erase a file from disk
 278+ F00D CD A7 F1     ERASE:  call    CHKFLNM         ; check for a disk name
 279+ F010 CD F4 EF             call    CHK1AR          ; check for ",1" argument
 280+ F013 E5                   push    HL              ; store code string pointer
 281+ F014 21 37 F0             ld      HL,ERSTX        ; Point to message
 282+ F017 CD 30 27             call    PRS             ; print message for init confirmation
 283+ F01A E1                   pop     HL              ; retrieve HL
 284+ F01B CD 82 F1             call    CNFREQ          ; ask for confirmation
 285+ F01E 38 33                jr      C,ABRTDS        ; if Carry set then abort
 286+ F020 CD D1 FC             call    CF_INIT         ; init CF card
 287+ F023 DA ED EF             jp      C,DOS_ERR       ; error if device not available/ready
 288+ F026 E5                   push    HL              ; store code string pointer
 289+ F027 CD 28 FA             call    FIL_ERASE       ; deleted file
 290+ F02A E1                   pop     HL              ; retrieve code string pointer
 291+ F02B DA ED EF             jp      C,DOS_ERR       ; leave if error
 292+ F02E E5                   push    HL              ; store HL
 293+ F02F 21 45 F0             ld      HL,ERASED       ; point to message of file deleted
 294+ F032 CD 30 27             call    PRS             ; print it
 295+ F035 E1                   pop     HL              ; retrieve HL
 296+ F036 C9                   ret                     ; return to caller
 297+ F037 44 65 6C 65  ERSTX:  defb    "Delete file? ",0
 297+ F03B 74 65 20 66
 297+ F03F 69 6C 65 3F
 297+ F043 20 00
 298+ F045 46 69 6C 65  ERASED: defb    "File deleted",CR,0
 298+ F049 20 64 65 6C
 298+ F04D 65 74 65 64
 298+ F051 0D 00
 299+ F053
 300+ F053
 301+ F053              ; disk operation aborted
 302+ F053 3E 01        ABRTDS: ld      A,$01           ; re-enable...
 303+ F055 32 A1 55             ld      (PRNTVIDEO),A   ; ...print-on-video
 304+ F058 E5                   push    HL              ; store code string pointer
 305+ F059 21 61 F0             ld      HL,ABRTXT       ; Point to message
 306+ F05C CD 30 27             call    PRS             ; print message for leaving init procedure
 307+ F05F E1                   pop     HL              ; retrieve code string pointer
 308+ F060 C9                   ret                     ; return to caller
 309+ F061 0D 41 62 6F  ABRTXT: defb    CR,"Aborted",0
 309+ F065 72 74 65 64
 309+ F069 00
 310+ F06A
 311+ F06A
 312+ F06A              ; **************************************************************************************
 313+ F06A              ;                               D O S    R O U T I N E S
 314+ F06A              ;***************************************************************************************
 315+ F06A
 316+ F06A              ; DISK command -------
 317+ F06A              ; execute several operations on a disk:
 318+ F06A              ; "F": format/rewrite Master Sector
 319+ F06A              ; "R": rename disk
 320+ F06A              ; "W": rewrite Master Sector
 321+ F06A              ; "U": undelete deleted files
 322+ F06A              ; syntax: DISK "arg1"[,"arg2"]
 323+ F06A              TPHL:   equ     TMPDBF          ; temp. buffer for code string pointer
 324+ F06A CD AB 3E     DISK:   call    DIRMOD          ; can be executed ONLY in direct mode
 325+ F06D C2 65 18             jp      NZ,IMERR        ; raise error if in indirect mode
 326+ F070                      ; check first argument
 327+ F070 2B                   dec     HL              ; dec 'cause GETCHR increments
 328+ F071 CD 97 1D             call    GETCHR          ; check if something follows
 329+ F074 CA 50 18             jp      Z,SNERR         ; if nothing else, raise a syntax error
 330+ F077 CD 3A 22             call    EVAL            ; Evaluate expression
 331+ F07A CD 2C 22             call    TSTSTR          ; Make sure it's a string
 332+ F07D 22 3C 55             ld      (TPHL),HL       ; store code string pointer into a temp buffer
 333+ F080 CD 73 28             call    GSTRCU          ; check that a string follows
 334+ F083 CD 84 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
 335+ F086 7B                   ld      A,E
 336+ F087 3D                   dec     A               ; lenght must be = 1
 337+ F088 2A 3C 55             ld      HL,(TPHL)       ; retrieve code string pointer
 338+ F08B C2 50 18             jp      NZ,SNERR
 339+ F08E AF                   xor     A
 340+ F08F 32 53 55             ld      (TPBF4),A       ; set default to full format
 341+ F092 0A                   ld      A,(BC)          ; load command
 342+ F093 E6 5F                and     %01011111       ; Force upper case
 343+ F095 FE 46                cp      'F'             ; format command?
 344+ F097 CA B1 F0             jp      Z,DSKFRM        ; yes
 345+ F09A FE 57                cp      'W'             ; rewrite master sector?
 346+ F09C CA AC F0             jp      Z,RWMSSC        ; yes
 347+ F09F FE 52                cp      'R'             ; rename command?
 348+ F0A1 CA 50 F1             jp      Z,DSKRNM        ; yes
 349+ F0A4 FE 55                cp      'U'             ; undelete command?
 350+ F0A6 CA 40 F1             jp      Z,DSKUND        ; yes
 351+ F0A9 C3 50 18             jp      SNERR           ; nothing more - raise a syntax error
 352+ F0AC
 353+ F0AC
 354+ F0AC              ; Format disk or rewrite Master sector
 355+ F0AC              ; syntax: DISK "F/W","disk name"
 356+ F0AC              ; "F" -> format disk, "W" -> rewrite master sector
 357+ F0AC              ; "disk name" is the name -> max 16 chars, allowed chars: "A" to "Z", "0" to "9","-", SPACE
 358+ F0AC              ; Format: set up a fresh new file system, creating the Master Sector and
 359+ F0AC              ; initializing the directory
 360+ F0AC              ; Master Sector rewriting: re-initialize the Master Sector, writing a new disk name and
 361+ F0AC              ; re-calculating disk geometry
 362+ F0AC              DKNMPT: equ     TMPBFR2         ; store the pointer to the disk name string
 363+ F0AC              DKLNPT: equ     TMPBFR3         ; store the pointer to the lenght of disk name string
 364+ F0AC 3E 01        RWMSSC  ld      A,$01           ; set rewriting of master sector
 365+ F0AE 32 53 55             ld      (TPBF4),A
 366+ F0B1 CD 4E 1B     DSKFRM: call    CHKSYN          ; Make sure ',' follows
 367+ F0B4 2C                   defb    ','
 368+ F0B5 CD A7 F1             call    CHKFLNM         ; check for file name
 369+ F0B8 11 FB F0             ld      DE,MSTTXT       ; format message
 370+ F0BB 3A 53 55             ld      A,(TPBF4)       ; check for type of operation
 371+ F0BE B7                   or      A               ; A=0 (full format)?
 372+ F0BF 20 03                jr      NZ,CFINIT       ; no, jump over
 373+ F0C1 11 13 F1             ld      DE,FRMTXT       ; rewrite Master Sector
 374+ F0C4 E5           CFINIT: push    HL              ; store code string pointer
 375+ F0C5 62                   ld      H,D             ; Point to message
 376+ F0C6 6B                   ld      L,E
 377+ F0C7 CD 30 27             call    PRS             ; print message for confirmation
 378+ F0CA E1                   pop     HL              ; retrieve HL
 379+ F0CB CD 82 F1             call    CNFREQ          ; ask for confirmation
 380+ F0CE DA 53 F0             jp      C,ABRTDS        ; if Carry set then abort
 381+ F0D1 CD D1 FC             call    CF_INIT         ; init CF card
 382+ F0D4 DA ED EF             jp      C,DOS_ERR       ; error if device not available/ready
 383+ F0D7 E5                   push    HL              ; store code string pointer
 384+ F0D8 CD CE F1             call    DSK_INIT        ; init disk
 385+ F0DB E1                   pop     HL              ; retrieve code string pointer
 386+ F0DC DA ED EF             jp      C,DOS_ERR       ; if Carry set, raise error
 387+ F0DF E5                   push    HL              ; store code string pointer
 388+ F0E0 3A A5 55             ld      A,(TMPBFR1)
 389+ F0E3 B7                   or      A               ; full formatting?
 390+ F0E4 20 0D                jr      NZ,MSPTOK       ; no
 391+ F0E6 21 2B F1             ld      HL,OPRCMP       ; yes, Point to message
 392+ F0E9 CD 30 27             call    PRS             ; print message for init confirmation
 393+ F0EC 16 00                ld      D,$00           ; print only disk details, no file list
 394+ F0EE CD 71 F6             call    LST_FILES       ; print details of disk and list files
 395+ F0F1 E1                   pop     HL              ; retrieve code string pointer
 396+ F0F2 C9                   ret                     ; return to caller
 397+ F0F3 21 2B F1     MSPTOK: ld      HL,OPRCMP       ; format OK message
 398+ F0F6 CD 30 27             call    PRS             ; print message for init confirmation
 399+ F0F9 E1                   pop     HL              ; retrieve code string pointer
 400+ F0FA C9                   ret                     ; return to caller
 401+ F0FB 52 65 77 72  MSTTXT: defb    "Rewrite Master Sector? ",0
 401+ F0FF 69 74 65 20
 401+ F103 4D 61 73 74
 401+ F107 65 72 20 53
 401+ F10B 65 63 74 6F
 401+ F10F 72 3F 20 00
 402+ F113 57 41 52 4E  FRMTXT: defb    "WARNING!! Format disk? ",0
 402+ F117 49 4E 47 21
 402+ F11B 21 20 46 6F
 402+ F11F 72 6D 61 74
 402+ F123 20 64 69 73
 402+ F127 6B 3F 20 00
 403+ F12B 4F 70 65 72  OPRCMP: defb    "Operation completed",CR,0
 403+ F12F 61 74 69 6F
 403+ F133 6E 20 63 6F
 403+ F137 6D 70 6C 65
 403+ F13B 74 65 64 0D
 403+ F13F 00
 404+ F140
 405+ F140
 406+ F140              ; undelete files
 407+ F140              ; look for files marked as "deleted" and undelete them
 408+ F140 2B           DSKUND: dec     HL              ; dec 'cause GETCHR increments
 409+ F141 CD 97 1D             call    GETCHR          ; check if something follows
 410+ F144 C2 50 18             jp      NZ,SNERR        ; if something else, raise a syntax error
 411+ F147 E5                   push    HL              ; store code string pointer
 412+ F148 CD EA FA             call    DSKUNDFL        ; undelete files
 413+ F14B E1                   pop     HL              ; retrieve code string pointer
 414+ F14C DA ED EF             jp      C,DOS_ERR       ; DOS error
 415+ F14F C9                   ret                     ; return to caller
 416+ F150
 417+ F150
 418+ F150              ; disk rename
 419+ F150              ; change the name of the disk w/o altering anything else
 420+ F150 CD 4E 1B     DSKRNM: call    CHKSYN          ; Make sure ',' follows
 421+ F153 2C                   defb    ','
 422+ F154 CD A7 F1             call    CHKFLNM         ; check for file name
 423+ F157 E5                   push    HL              ; store code string pointer
 424+ F158 21 74 F1             ld      HL,RNDKTX       ; Point to message
 425+ F15B CD 30 27             call    PRS             ; print message for confirmation
 426+ F15E E1                   pop     HL              ; retrieve HL
 427+ F15F CD 82 F1             call    CNFREQ          ; ask for confirmation
 428+ F162 DA 53 F0             jp      C,ABRTDS        ; if Carry set then abort
 429+ F165 CD D1 FC             call    CF_INIT         ; init CF card
 430+ F168 DA ED EF             jp      C,DOS_ERR       ; error if device not available/ready
 431+ F16B E5                   push    HL              ; store code string pointer
 432+ F16C CD 06 F3             call    DSK_RNM         ; init disk
 433+ F16F E1                   pop     HL              ; retrieve code string pointer
 434+ F170 DA ED EF             jp      C,DOS_ERR       ; DOS error
 435+ F173 C9                   ret
 436+ F174 52 65 6E 61  RNDKTX: defb    "Rename disk? ",0
 436+ F178 6D 65 20 64
 436+ F17C 69 73 6B 3F
 436+ F180 20 00
 437+ F182
 438+ F182
 439+ F182              ; confirmation required by the user ('y' or 'Y' DO confirm, otherwise DON'T)
 440+ F182 CD 2D 09     CNFREQ: call    CURSOR_ON       ; enable cursor
 441+ F185 AF                   xor     A
 442+ F186 32 A1 55             ld      (PRNTVIDEO),A   ; disable print-on-video
 443+ F189 CD 2A 02             call    RXA             ; look for a pressed key
 444+ F18C FE 03                cp      CTRLC           ; is it RUN STOP?
 445+ F18E 28 15                jr      Z,CNFRQN        ; yes, abort operation
 446+ F190 E6 DF                and     %11011111       ; only UPPERCASE char
 447+ F192 FE 59                cp      'Y'             ; 'Y'?
 448+ F194 20 0F                jr      NZ,CNFRQN       ; no, abort operation
 449+ F196 08                   ex      AF,AF'          ; store char into A'
 450+ F197 3E 01                ld      A,$01           ; re-enable...
 451+ F199 32 A1 55             ld      (PRNTVIDEO),A   ; ...print-on-video
 452+ F19C 08                   ex      AF,AF'          ; retrieve char from A'
 453+ F19D CD 1C 03             call    ECHO_CHAR       ; yes, echoes the char
 454+ F1A0 CD 42 09             call    CURSOR_OFF      ; disable cursor
 455+ F1A3 AF                   xor     A               ; reset Carry flag
 456+ F1A4 C9                   ret                     ; return to caller
 457+ F1A5 37           CNFRQN: scf                     ; set Carry flag
 458+ F1A6 C9                   ret                     ; return to caller
 459+ F1A7
 460+ F1A7
 461+ F1A7              ; check that a disk/file name follows
 462+ F1A7 2B           CHKFLNM:dec     HL              ; dec 'cause GETCHR increments
 463+ F1A8 CD 97 1D             call    GETCHR          ; check if something follows
 464+ F1AB CA 50 18             jp      Z,SNERR         ; if nothing else, raise a syntax error
 465+ F1AE CD 3A 22             call    EVAL            ; Evaluate expression
 466+ F1B1 CD 2C 22     CHKFN1: call    TSTSTR          ; Make sure it's a string
 467+ F1B4 22 3E 55     CHKFN2: ld      (TMPDBF+2),HL   ; store code string pointer into a temp buffer
 468+ F1B7 CD 73 28             call    GSTRCU          ; get current string into pool
 469+ F1BA CD 84 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
 470+ F1BD 7B                   ld      A,E             ; check if lenght = 0
 471+ F1BE A7                   and     A               ; null string?
 472+ F1BF CA 50 18             jp      Z,SNERR         ; yes, syntax error
 473+ F1C2 ED 53 A9 55          ld      (DKLNPT),DE     ; no, store lenght
 474+ F1C6 ED 43 A7 55          ld      (DKNMPT),BC     ; store address of temp string
 475+ F1CA 2A 3E 55             ld      HL,(TMPDBF+2)   ; retrieve code string pointer
 476+ F1CD C9                   ret                     ; return to caller
 477+ F1CE
 478+ F1CE
 479+ F1CE              ; *****************************************************************************
 480+ F1CE              ; D I S K    I N I T
 481+ F1CE              ; Functions: format a disk creating a fresh new file system on disk or
 482+ F1CE              ;            rewrite only the Master Sector
 483+ F1CE              ; *****************************************************************************
 484+ F1CE CD 6F FB     DSK_INIT:   call    CHKSQFL         ; check if a seq. file is open
 485+ F1D1 C2 1D F6                 jp      NZ,FILOPCLER    ; jump if open
 486+ F1D4 3A 53 55                 ld      A,(TPBF4)       ; load type of formatting
 487+ F1D7 32 A5 55                 ld      (TMPBFR1),A     ; save onto another location for later use
 488+ F1DA CD A4 FC                 call    CLRIOBF         ; clear I/O buffer
 489+ F1DD CD B9 FC                 call    CLRDOSBF        ; clear DOS buffer
 490+ F1E0 3E E0                    ld 	    A,$E0           ; select CF as master, driver 0, LBA mode (bits #5-7=111)
 491+ F1E2 D3 56                    out     (CF_LBA3),A     ; send configuration
 492+ F1E4 3E EC                    ld      A,$EC           ; select "drive ID" command
 493+ F1E6 D3 57                    out     (CF_CMD),A      ; send command
 494+ F1E8 CD 06 FD                 call    CF_DAT_RDY      ; wait until data is ready to be read
 495+ F1EB CD 68 FD                 call    CF_RD_CMD       ; read data and store into I/O buffer
 496+ F1EE 11 A0 FD                 ld      DE,DOSBFR       ; address of default conf. buffer
 497+ F1F1 21 C0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
 498+ F1F4 01 0E 00                 ld      BC,$000E        ; position of current disk size in sectors
 499+ F1F7 09                       add     HL,BC           ; set into HL
 500+ F1F8 0E 04                    ld      C,$04           ; 4 bytes to copy
 501+ F1FA ED B0                    ldir                    ; copy (DE is auto-incremented)
 502+ F1FC 21 C0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
 503+ F1FF 01 02 00                 ld      BC,$0002        ; 2 bytes to copy and also address of number of cylinders
 504+ F202 09                       add     HL,BC           ; get position of data
 505+ F203 ED B0                    ldir                    ; copy (DE is auto-incremented)
 506+ F205 21 C0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
 507+ F208 01 0C 00                 ld      BC,$000C        ; address of number of sectors per cylinder
 508+ F20B 09                       add     HL,BC           ; get position of data
 509+ F20C 0E 02                    ld      C,$02           ; 2 bytes to copy
 510+ F20E ED B0                    ldir                    ; copy (DE is auto-incremented)
 511+ F210 21 C0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
 512+ F213 01 06 00                 ld      BC,$0006        ; address of number of heads
 513+ F216 09                       add     HL,BC           ; get position of data
 514+ F217 0E 02                    ld      C,$02           ; 2 bytes to copy
 515+ F219 ED B0                    ldir                    ; copy (DE is auto-incremented)
 516+ F21B                          ; now we calculate the # of files allowed (1 file = 1 block = 64K)
 517+ F21B ED 53 53 55              ld      (TPBF4),DE      ; store current pointer to temp. default conf. buffer
 518+ F21F 21 A0 FD                 ld      HL,DOSBFR       ; load number of sectors
 519+ F222 4E                       ld      C,(HL)          ; MSW into AC
 520+ F223 23                       inc     HL
 521+ F224 7E                       ld      A,(HL)
 522+ F225 23                       inc     HL
 523+ F226 5E                       ld      E,(HL)          ; LSW into DE
 524+ F227 23                       inc     HL
 525+ F228 56                       ld      D,(HL)
 526+ F229 D5                       push    DE              ; move DE into IX
 527+ F22A DD E1                    pop     IX
 528+ F22C 11 80 00                 ld      DE,$0080        ; 128 sectors per block
 529+ F22F CD E0 41                 call    DIV_32_16       ; execute ACIX/DE; result is into ACIX, remainder into HL
 530+ F232 47                       ld      B,A             ; now result is into BCIX
 531+ F233 B1                       or      C               ; BC=$0000?
 532+ F234 28 05                    jr      Z,DOS_FTC       ; yes, but.....
 533+ F236 11 FF FF                 ld      DE,$FFFF        ; ... no more than $FFFF files, so set limit
 534+ F239 18 0E                    jr      DOS_FT1         ; jump over
 535+ F23B DD E5        DOS_FTC:    push    IX              ; move IX into DE
 536+ F23D D1                       pop     DE              ; now result is into BCDE
 537+ F23E 7C                       ld      A,H             ; remainder = zero?
 538+ F23F B5                       or      L
 539+ F240 CA 49 F2                 jp      Z,DOS_FT1       ; yes, jump over
 540+ F243 13                       inc     DE              ; no, increment DE
 541+ F244 7A                       ld      A,D             ; check if DE is zero
 542+ F245 B3                       or      E
 543+ F246 20 01                    jr      NZ,DOS_FT1      ; no, jump over
 544+ F248 1B                       dec     DE              ; yes, so set files to limit of $FFFF
 545+ F249 2A 53 55     DOS_FT1:    ld      HL,(TPBF4)      ; retrieve current pointer to temp. def. conf. buffer
 546+ F24C CD 68 FC                 call    DE2HL           ; store # of entries
 547+ F24F D5                       push    DE              ; store entries
 548+ F250 EB                       ex      DE,HL           ; copy current pointer into DE
 549+ F251 21 34 EE                 ld      HL,DSKDIRADR    ; address of directory start
 550+ F254 01 02 00                 ld      BC,$0002        ; 2 bytes to copy
 551+ F257 ED B0                    ldir                    ; copy into buffer
 552+ F259                          ; now we calculate the starting sector of data area
 553+ F259 E1                       pop     HL              ; entries into HL
 554+ F25A 0E 10                    ld      C,$10           ; 16 entries per sector
 555+ F25C CD BC 41                 call    DIV_16_8        ; calculare how many sectors for dir (HL/C)
 556+ F25F B7                       or      A               ; remainder = 0?
 557+ F260 28 01                    jr      Z,DOS_FT2       ; yes, jump over
 558+ F262 23                       inc     HL              ; increment sectors
 559+ F263 E5           DOS_FT2:    push    HL              ; store size of directory
 560+ F264 FD E1                    pop     IY              ; into IY
 561+ F266 23                       inc     HL              ; data area is 1 sector bigger than directory's size
 562+ F267 EB                       ex      DE,HL           ; restore pointer into HL, and move sectors into DE
 563+ F268 73                       ld      (HL),E          ; store starting of
 564+ F269 23                       inc     HL              ; data area
 565+ F26A 72                       ld      (HL),D          ; into buffer
 566+ F26B                          ; now clean again the I/O buffer and copy the configuration into I/O buffer
 567+ F26B CD A4 FC                 call    CLRIOBF         ; clear I/O buffer
 568+ F26E 21 25 EE                 ld      HL,DSKHDR       ; address of disk header string
 569+ F271 11 C0 FD                 ld      DE,IOBUFF       ; address of I/O buffer
 570+ F274 01 0F 00                 ld      BC,$000F        ; 15 chars
 571+ F277 ED B0                    ldir                    ; copy header into buffer
 572+ F279 21 A0 FD                 ld      HL,DOSBFR       ; first part of configuration
 573+ F27C 01 10 00                 ld      BC,$0010        ; composed by 16 chars
 574+ F27F ED B0                    ldir                    ; copy (DE is auto-incremented)
 575+ F281 AF                       xor     A               ; A=$0
 576+ F282 12                       ld      (DE),A          ; marker at $1F
 577+ F283 13                       inc     DE
 578+ F284 CD 40 FC                 call    CHKNMVAL        ; copy disk name into buffer
 579+ F287 DA 2C F6                 jp      C,NAMERR        ; disk name error
 580+ F28A CD C8 FB                 call    RND_ID          ; generate a semi-random disk ID
 581+ F28D 21 C0 FD                 ld      HL,IOBUFF       ; get starting address of I/O buffer
 582+ F290 54                       ld      D,H             ; copy into DE...
 583+ F291 5D                       ld      E,L             ; ...for later use
 584+ F292 01 FE 01                 ld      BC,$01FE        ; get address of last 2 bytes...
 585+ F295 09                       add     HL,BC           ; ...of the I/O buffer
 586+ F296 3E 38                    ld      A,'8'           ; write marker "80"
 587+ F298 77                       ld      (HL),A          ; ...
 588+ F299 23                       inc     HL              ; ...
 589+ F29A 3E 30                    ld      A,'0'           ; ...
 590+ F29C 77                       ld      (HL),A          ; ...into last 2 locations
 591+ F29D EB                       ex      DE,HL           ; copy beginning of I/O buffer from DE into HL
 592+ F29E AF                       xor     A               ; reset A - set sector # to $00000000
 593+ F29F 47                       ld      B,A             ; LBA0=0
 594+ F2A0 4F                       ld      C,A             ; LBA1=0
 595+ F2A1 57                       ld      D,A             ; LBA2=0
 596+ F2A2 5F                       ld      E,A             ; LBA3=0
 597+ F2A3 CD 7C FD                 call    CF_WR_SEC       ; write sector to CF
 598+ F2A6 DA 23 F6                 jp      C,D2ERR
 599+ F2A9                          ; check if only re-writing of Master Sector was need
 600+ F2A9 3A A5 55                 ld      A,(TMPBFR1)     ; retrieve type of formatting
 601+ F2AC 3D                       dec     A               ; A=1?
 602+ F2AD C8                       ret     Z               ; yes, finished job
 603+ F2AE                          ; erase directory -----------------------------
 604+ F2AE                          ; create a progress bar
 605+ F2AE 3E 0D                    ld      A,CR            ; no, full format - go to new line
 606+ F2B0 CD 59 1B                 call    OUTC
 607+ F2B3 FD E5                    push    IY              ; copy directory's size...
 608+ F2B5 E1                       pop     HL              ; ...into HL
 609+ F2B6 01 18 00                 ld      BC,$0018        ; 24 steps
 610+ F2B9 CD BC 41                 call    DIV_16_8        ; calculate HL/24 (remainder is ignored, here)
 611+ F2BC E5                       push    HL              ; store result...
 612+ F2BD DD E1                    pop     IX              ; ...into IX...
 613+ F2BF EB                       ex      DE,HL           ; ...and into DE
 614+ F2C0 3E 2D                    ld      A,'-'           ; print a progress bar
 615+ F2C2 CD FE F2                 call    DOS_FT7         ; print it
 616+ F2C5 3E 1C                    ld      A,CRSLFT        ; CURSOR left
 617+ F2C7 CD FE F2                 call    DOS_FT7         ; come back to beginning of line
 618+ F2CA FD E5                    push    IY              ; copy directory's size
 619+ F2CC E1                       pop     HL              ; into HL
 620+ F2CD 01 01 00                 ld      BC,$0001        ; first sector of directory
 621+ F2D0 CD A4 FC                 call    CLRIOBF         ; clear I/O buffer
 622+ F2D3 D5           DOS_FTA:    push    DE              ; store counter
 623+ F2D4 11 00 00                 ld      DE,$0000        ; reset MSW of sector pointer
 624+ F2D7 CD 7C FD                 call    CF_WR_SEC       ; write sector to CF
 625+ F2DA DA FA F2                 jp      C,DOS_FT10      ; error occured
 626+ F2DD 03                       inc     BC              ; next sector
 627+ F2DE 2B                       dec     HL              ; decrement HL
 628+ F2DF D1                       pop     DE              ; retrieve counter
 629+ F2E0 1B                       dec     DE              ; decrement counter
 630+ F2E1 7B                       ld      A,E
 631+ F2E2 B2                       or      D               ; check if counter is zero
 632+ F2E3 20 08                    jr      NZ,DOS_FT9      ; no, jump over
 633+ F2E5 3E 2A                    ld      A,'*'           ; yes, print char
 634+ F2E7 CD 59 1B                 call    OUTC
 635+ F2EA DD E5                    push    IX              ; re-set counter
 636+ F2EC D1                       pop     DE
 637+ F2ED 7C           DOS_FT9:    ld      A,H             ; check if...
 638+ F2EE B5                       or      L               ; ...HL = 0
 639+ F2EF 20 E2                    jr      NZ,DOS_FTA      ; if not, repeat
 640+ F2F1 3E 0D                    ld      A,CR            ; return
 641+ F2F3 CD 59 1B                 call    OUTC            ; next line
 642+ F2F6 CD 49 FD                 call    CF_STANDBY      ; set CF into stand-by mode
 643+ F2F9 C9                       ret
 644+ F2FA D1           DOS_FT10:   pop     DE
 645+ F2FB C3 23 F6                 jp      D2ERR           ; disk geometry error
 646+ F2FE
 647+ F2FE              ; print a char 24 times
 648+ F2FE 06 18        DOS_FT7:    ld      B,$18           ; 24 times
 649+ F300 CD 59 1B     DOS_FT8:    call    OUTC            ; print char
 650+ F303 10 FB                    djnz    DOS_FT8         ; repeat
 651+ F305 C9                       ret                     ; return to caller
 652+ F306
 653+ F306
 654+ F306              ; *****************************************************************************
 655+ F306              ; D I S K    R E N A M E
 656+ F306              ;******************************************************************************
 657+ F306 CD 08 FC     DSK_RNM:    call    CHKDSKVAL       ; check DOS version & load disk details
 658+ F309 DA 35 F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
 659+ F30C CD A4 FC                 call    CLRIOBF         ; clear I/O buffer
 660+ F30F CD B9 FC                 call    CLRDOSBF        ; clear DOS buff.
 661+ F312 CD BC FB                 call    LDMSCT          ; load Master Sector
 662+ F315 21 C0 FD                 ld      HL,IOBUFF       ; point to start of I/O buffer
 663+ F318 01 20 00                 ld      BC,$0020        ; offset for disk name
 664+ F31B 09                       add     HL,BC           ; get pointer
 665+ F31C EB                       ex      DE,HL           ; copy pointer into DE
 666+ F31D CD 40 FC                 call    CHKNMVAL        ; copy disk name into buffer
 667+ F320 DA 2C F6                 jp      C,NAMERR        ; disk name error
 668+ F323 11 00 00                 ld      DE,$0000        ; reset MSW sector
 669+ F326 42                       ld      B,D             ; reset LSW sector
 670+ F327 4A                       ld      C,D
 671+ F328 CD 7C FD                 call    CF_WR_SEC       ; write sector
 672+ F32B DA A0 FA                 jp      C,WRT_ERR       ; error?
 673+ F32E C9                       ret                     ; no, return to caller
 674+ F32F
 675+ F32F
 676+ F32F              ; *****************************************************************************
 677+ F32F              ; PUT A CHAR INTO A SEQUENTIAL FILE
 678+ F32F              ; when the buffer is full, it writes it on the disk,
 679+ F32F              ; then move to another sector
 680+ F32F              ; *****************************************************************************
 681+ F32F CD 6F FB     PUTFIL:     call    CHKSQFL         ; is there a seq. file open?
 682+ F332 CA 1D F6                 jp      Z,FILOPCLER     ; no, raise an error
 683+ F335 47                       ld      B,A             ; copy file number into B
 684+ F336 3A 3C 55                 ld      A,(TMPDBF)      ; load argument
 685+ F339 B8                       cp      B               ; are they equal?
 686+ F33A C2 2F F6                 jp      NZ,FLNTFND      ; file not found
 687+ F33D 3A D5 FF                 ld      A,(SEQFLS)      ; check access mode
 688+ F340 B7                       or      A               ; only reading?
 689+ F341 3E 3E                    ld      A,D3            ; prepare a save error
 690+ F343 CA 37 F6                 jp      Z,RET_ERR       ; yes, error
 691+ F346                          ; store byte
 692+ F346 ED 5B DB FF              ld      DE,(SEQBYSZ)    ; load size in bytes
 693+ F34A 13                       inc     DE              ; increment file size
 694+ F34B 7B                       ld      A,E             ; check if...
 695+ F34C B2                       or      D               ; ...rolled back to $0000
 696+ F34D CA 26 F6                 jp      Z,DSKFULL       ; yes, block is full
 697+ F350 ED 53 DB FF              ld      (SEQBYSZ),DE    ; no, store new size
 698+ F354 2A DD FF                 ld      HL,(SEQPNT)     ; pointer to byte
 699+ F357 11 C0 FD                 ld      DE,IOBUFF       ; load starting address of I/O buffer
 700+ F35A 44                       ld      B,H             ; copy byte pointer...
 701+ F35B 4D                       ld      C,L             ; ...to BC
 702+ F35C 19                       add     HL,DE           ; point to new location
 703+ F35D 3A 3D 55                 ld      A,(TMPDBF+1)    ; retrieve byte
 704+ F360 77                       ld      (HL),A          ; store it
 705+ F361 03                       inc     BC              ; increment byte pointer
 706+ F362 ED 43 DD FF              ld      (SEQPNT),BC     ; store it
 707+ F366 CD 6B F3                 call    PUTNXSC         ; check if I/O buffer is full
 708+ F369 AF                       xor     A               ; clear Carry
 709+ F36A C9                       ret                     ; return to caller
 710+ F36B                          ; check if I/O buffer is full
 711+ F36B                          ; if yes, store buffer and goto a new sector
 712+ F36B 11 00 02     PUTNXSC:    ld      DE,$0200        ; max buffer size
 713+ F36E 2A DD FF                 ld      HL,(SEQPNT)     ; pointer to byte
 714+ F371 CD 61 41                 call    CMP16           ; check if pointer < $200
 715+ F374 D8                       ret     C               ; yes, return
 716+ F375 ED 4B D8 FF              ld      BC,(SEQSCTL)    ; load LSW of sector address
 717+ F379 ED 5B D6 FF              ld      DE,(SEQSCTM)    ; load MSW of sector address
 718+ F37D CD 7C FD                 call    CF_WR_SEC       ; write buffer into sector
 719+ F380 3A DA FF                 ld      A,(SEQSCSZ)     ; load size in sectors
 720+ F383 3C                       inc     A               ; we need another sector
 721+ F384 67                       ld      H,A             ; store A into H
 722+ F385 FE 81                    cp      $81             ; A>128?
 723+ F387 3E 42                    ld      A,D5            ; prepare a disk full error
 724+ F389 D2 FC F5                 jp      NC,GETER        ; yes, raise an error
 725+ F38C 7C                       ld      A,H             ; no, retrieve sector counter
 726+ F38D 32 DA FF                 ld      (SEQSCSZ),A     ; store new size in sectors
 727+ F390 21 00 00                 ld      HL,$0000        ; reset pointer
 728+ F393 22 DD FF                 ld      (SEQPNT),HL
 729+ F396 03                       inc     BC              ; next sector
 730+ F397 79                       ld      A,C             ; check if BC is rolled back to zero (overflow)
 731+ F398 B0                       or      B
 732+ F399 20 05                    jr      NZ,PUTFIL2      ; no, jump over
 733+ F39B 13                       inc     DE              ; yes, increment MSW of sector address
 734+ F39C ED 53 D6 FF              ld      (SEQSCTM),DE    ; save new MSW of sector address
 735+ F3A0 ED 43 D8 FF  PUTFIL2:    ld      (SEQSCTL),BC    ; save new LSW of sector address
 736+ F3A4 C3 4D F4                 jp      OPNFRD1         ; load sector and return
 737+ F3A7
 738+ F3A7
 739+ F3A7              ; *****************************************************************************
 740+ F3A7              ; OPEN A SEQUENTIAL FILE
 741+ F3A7              ; open a sequential file for read/write operations
 742+ F3A7              ; if file already exists, it appends new data at the end of the file
 743+ F3A7              ;******************************************************************************
 744+ F3A7 CD 08 FC     OPNFIL:     call    CHKDSKVAL       ; check DOS version & load disk details
 745+ F3AA DA 35 F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
 746+ F3AD CD 6F FB                 call    CHKSQFL         ; check if there is a file already opened
 747+ F3B0 C2 20 F6                 jp      NZ,FILALROP     ; yes, jump over
 748+ F3B3 CD C5 FC                 call    CLRSEQBF        ; clear seq. file buffer
 749+ F3B6 3A 3C 55                 ld      A,(TMPDBF)      ; recover file number and...
 750+ F3B9 32 D4 FF                 ld      (SEQFL),A       ; ...store it
 751+ F3BC 3A 3D 55                 ld      A,(TMPDBF+1)    ; load access mode
 752+ F3BF 32 D5 FF                 ld      (SEQFLS),A      ; store access mode
 753+ F3C2                          ; open file
 754+ F3C2 CD A4 FC                 call    CLRIOBF         ; clear I/O
 755+ F3C5 CD 46 F9                 call    CHKFLEXT        ; check if file already exists
 756+ F3C8 1E 00                    ld      E,$00           ; reset E
 757+ F3CA CB 13                    rl      E               ; store Carry into E (0=file not exists, 1=file exists)
 758+ F3CC 3A D5 FF                 ld      A,(SEQFLS)      ; load access mode (0=read, 1=create/append)
 759+ F3CF B3                       or      E               ; if read mode and file not exist...
 760+ F3D0 CA 2F F6                 jp      Z,FLNTFND       ; ...raise a file not found error
 761+ F3D3 3A D5 FF                 ld      A,(SEQFLS)      ; reload access mode (0=read, 1=create/append)
 762+ F3D6 B7                       or      A               ; read mode?
 763+ F3D7 28 7F                    jr      Z,OPFLRS        ; yes, open file for read
 764+ F3D9                          ; open file for writing
 765+ F3D9 7B                       ld      A,E             ; no, open file for save
 766+ F3DA B7                       or      A               ; check if file exists
 767+ F3DB 20 46                    jr      NZ,OPNFRD       ; file exists, open for append
 768+ F3DD                          ; open file for creating (new file)
 769+ F3DD CD A4 FC                 call    CLRIOBF         ; clear I/O buffer
 770+ F3E0 CD 37 FB                 call    FNDFRENTR       ; file doesn't exist, find a free entry in the directory
 771+ F3E3 DA 26 F6                 jp      C,DSKFULL       ; no entry, disk full error
 772+ F3E6 3E 82                    ld      A,$82           ; set seq. file type
 773+ F3E8 32 53 55                 ld      (TPBF4),A
 774+ F3EB 3E 01                    ld      A,$01           ; set initial size to 1 sector
 775+ F3ED 32 DA FF                 ld      (SEQSCSZ),A     ; store it for seq. file manager
 776+ F3F0 32 46 55                 ld      (SCT_SIZ),A     ; store it for DOS, too
 777+ F3F3 21 00 00                 ld      HL,$0000        ; set initial file size to 0 bytes
 778+ F3F6 22 44 55                 ld      (BYT_SIZ),HL    ; store it for DOS
 779+ F3F9 22 55 55                 ld      (SRTMEM),HL     ; RAM starting address set to 0 (seq. file is not saved/loaded from/into RAM)
 780+ F3FC CD 63 F8                 call    SVENTRY         ; save entry into directory
 781+ F3FF ED 5B 47 55              ld      DE,(MSW_SCT)    ; store MSW of sector address for DOS
 782+ F403 ED 53 D6 FF              ld      (SEQSCTM),DE    ; also for seq. file manager
 783+ F407 ED 4B 49 55              ld      BC,(LSW_SCT)    ; store LSW of sector address for DOS
 784+ F40B ED 43 D8 FF              ld      (SEQSCTL),BC    ; also for seq. file manager
 785+ F40F CD A5 F4                 call    SVSQFLNM        ; store name
 786+ F412 CD A4 FC                 call    CLRIOBF         ; clear I/O buffer
 787+ F415 ED 5B 47 55              ld      DE,(MSW_SCT)    ; load MSW of sector
 788+ F419 ED 4B 49 55              ld      BC,(LSW_SCT)    ; load LSW of sector
 789+ F41D CD 7C FD                 call    CF_WR_SEC       ; write sector
 790+ F420 C3 69 F4                 jp      OPNFILPT        ; go setting pointer
 791+ F423                          ; open file for append (add data after the end)
 792+ F423 CD 71 F4     OPNFRD:     call    OPNRDDET        ; load file details - size in bytes in DE - size in sectors in A
 793+ F426 21 00 02                 ld      HL,$0200        ; sector wide
 794+ F429 EB                       ex      DE,HL           ; move file size into HL and sector size into DE
 795+ F42A 3D           OPNFRD3:    dec     A               ; decrement sector counter
 796+ F42B 28 05                    jr      Z,OPNFRD2       ; reached 0? jump over
 797+ F42D B7                       or      A               ; reset Carry
 798+ F42E ED 52                    sbc     HL,DE           ; decrement sector size
 799+ F430 18 F8                    jr      OPNFRD3         ; repeat
 800+ F432 22 DD FF     OPNFRD2:    ld      (SEQPNT),HL     ; save pointer
 801+ F435 3A DA FF                 ld      A,(SEQSCSZ)     ; load size in sectors
 802+ F438 3D                       dec     A               ; decrement by 1
 803+ F439 4F                       ld      C,A             ; store into...
 804+ F43A 06 00                    ld      B,$00           ; ...BC
 805+ F43C 2A D8 FF                 ld      HL,(SEQSCTL)    ; load LSW of sector address
 806+ F43F ED 5B D6 FF              ld      DE,(SEQSCTM)    ; load MSW of sector address
 807+ F443 09                       add     HL,BC           ; point to latest sector
 808+ F444 4D                       ld      C,L             ; copy HL into BC
 809+ F445 44                       ld      B,H
 810+ F446 30 05                    jr      NC,OPNFRD1      ; if LSW didn't overflow, jump over
 811+ F448 13                       inc     DE              ; overflow, so increment MSW
 812+ F449 ED 53 D6 FF              ld      (SEQSCTM),DE    ; store new MSW of sector address
 813+ F44D ED 43 D8 FF  OPNFRD1:    ld      (SEQSCTL),BC    ; store new LSW of sector address
 814+ F451 CD 13 FD                 call    CF_SETSTR       ; set sector to load
 815+ F454 CD 55 FD                 call    CF_RD_SEC       ; read sector
 816+ F457 C9                       ret                     ; return to caller
 817+ F458                          ; open file for read & point to beginning of it
 818+ F458 CD 71 F4     OPFLRS:     call    OPNRDDET        ; load file details
 819+ F45B ED 5B D6 FF              ld      DE,(SEQSCTM)    ; load MSW of sector address
 820+ F45F ED 4B D8 FF              ld      BC,(SEQSCTL)    ; load LSW of sector addres
 821+ F463 CD 13 FD     OPFLRS1:    call    CF_SETSTR       ; point to 1st sector
 822+ F466 CD 55 FD                 call    CF_RD_SEC       ; load sector
 823+ F469 AF           OPNFILPT:   xor     A               ; A=0
 824+ F46A 32 DD FF                 ld      (SEQPNT),A      ; file pointer...
 825+ F46D 32 DE FF                 ld      (SEQPNT+1),A    ; ...set to 0
 826+ F470 C9                       ret                     ; return to caller
 827+ F471
 828+ F471
 829+ F471              ; open an existing file and load details
 830+ F471 DD 5E 14     OPNRDDET:   ld      E,(IX+$14)      ; load MSW into DE
 831+ F474 DD 56 15                 ld      D,(IX+$15)
 832+ F477 DD 4E 16                 ld      C,(IX+$16)      ; load LSW into BC
 833+ F47A DD 46 17                 ld      B,(IX+$17)
 834+ F47D ED 53 47 55              ld      (MSW_SCT),DE    ; store DE for DOS
 835+ F481 ED 53 D6 FF              ld      (SEQSCTM),DE    ; also for seq. file manager
 836+ F485 ED 43 49 55              ld      (LSW_SCT),BC    ; store BC dor DOS
 837+ F489 ED 43 D8 FF              ld      (SEQSCTL),BC    ; also for seq. file manager
 838+ F48D DD 5E 18                 ld      E,(IX+$18)      ; load size in bytes
 839+ F490 DD 56 19                 ld      D,(IX+$19)
 840+ F493 ED 53 44 55              ld      (BYT_SIZ),DE    ; store it for DOS
 841+ F497 ED 53 DB FF              ld      (SEQBYSZ),DE    ; store it for seq. file manager
 842+ F49B DD 7E 1A                 ld      A,(IX+$1A)      ; load size in sectors
 843+ F49E 32 46 55                 ld      (SCT_SIZ),A     ; store it for DOS
 844+ F4A1 32 DA FF                 ld      (SEQSCSZ),A     ; and also for seq. file manager
 845+ F4A4 C9                       ret                     ; return to caller
 846+ F4A5
 847+ F4A5
 848+ F4A5              ; save file name into seq. buffer
 849+ F4A5 11 C4 FF     SVSQFLNM:   ld      DE,TMPNAM       ; temp. buff.
 850+ F4A8 01 10 00                 ld      BC,$0010        ; 10 chars
 851+ F4AB 21 A0 FD                 ld      HL,DOSBFR       ; pointer to file name
 852+ F4AE ED B0                    ldir                    ; store filename
 853+ F4B0 C9                       ret                     ; return to caller
 854+ F4B1
 855+ F4B1              ; *****************************************************************************
 856+ F4B1              ; CLOSE A SEQUENTIAL FILE
 857+ F4B1              ; *****************************************************************************
 858+ F4B1 CD 6F FB     CLOSFIL:    call    CHKSQFL         ; is there a seq. file open?
 859+ F4B4 CA 1D F6                 jp      Z,FILOPCLER     ; no, raise an error
 860+ F4B7 47                       ld      B,A             ; copy file number into B
 861+ F4B8 3A 3C 55                 ld      A,(TMPDBF)      ; load argument
 862+ F4BB B8                       cp      B               ; are they equal?
 863+ F4BC C2 2F F6                 jp      NZ,FLNTFND      ; file not found
 864+ F4BF 3A D5 FF                 ld      A,(SEQFLS)      ; check access mode
 865+ F4C2 B7                       or      A               ; only reading?
 866+ F4C3 28 09                    jr      Z,CLOSFIL1      ; yes, just mark file closed
 867+ F4C5 CD D6 F4                 call    SVCRNTSE        ; save current buffer
 868+ F4C8 CD E2 F4                 call    UPCRNENT        ; update entry into dir
 869+ F4CB DA 2F F6                 jp      C,FLNTFND       ; file not found?
 870+ F4CE CD 49 FD     CLOSFIL1:   call    CF_STANDBY      ; put disk into standby
 871+ F4D1 AF                       xor     A               ; mark file as closed
 872+ F4D2 32 D4 FF                 ld      (SEQFL),A
 873+ F4D5 C9                       ret                     ; return to caller
 874+ F4D6
 875+ F4D6
 876+ F4D6              ; save current buffer into a sequential file
 877+ F4D6 ED 5B D6 FF  SVCRNTSE:   ld      DE,(SEQSCTM)    ; MSW of sector address
 878+ F4DA ED 4B D8 FF              ld      BC,(SEQSCTL)    ; LSW of sector address
 879+ F4DE CD 7C FD                 call    CF_WR_SEC       ; save current open sector
 880+ F4E1 C9                       ret
 881+ F4E2
 882+ F4E2
 883+ F4E2              ; update current entry (for a seq. file)
 884+ F4E2 11 10 00     UPCRNENT:   ld      DE,$0010
 885+ F4E5 ED 53 A9 55              ld      (DKLNPT),DE     ; lenght of name
 886+ F4E9 11 C4 FF                 ld      DE,TMPNAM
 887+ F4EC ED 53 A7 55              ld      (DKNMPT),DE     ; pointer to name
 888+ F4F0 CD 46 F9                 call    CHKFLEXT        ; check file existance
 889+ F4F3 D2 11 F5                 jp      NC,UPCRNENT1    ; file not found
 890+ F4F6 2A DB FF                 ld      HL,(SEQBYSZ)
 891+ F4F9 DD 75 18                 ld      (IX+$18),L      ; point to file size
 892+ F4FC DD 74 19                 ld      (IX+$19),H
 893+ F4FF 3A DA FF                 ld      A,(SEQSCSZ)     ; load size in sectors
 894+ F502 DD 77 1A                 ld      (IX+$1A),A
 895+ F505 ED 5B 4F 55              ld      DE,(TPBF2)      ; retrieve MSW of current directory sector
 896+ F509 ED 4B 51 55              ld      BC,(TPBF3)      ; retrieve LSW of current directory secto
 897+ F50D CD 7C FD                 call    CF_WR_SEC       ; store entry
 898+ F510 37                       scf                     ; set Carry
 899+ F511 3F           UPCRNENT1:  ccf                     ; invert Carry
 900+ F512 C9                       ret
 901+ F513
 902+ F513
 903+ F513              ; *****************************************************************************
 904+ F513              ; E X I S T
 905+ F513              ; check if a file already exists
 906+ F513              ; input: file name
 907+ F513              ; return: 1 if file exist, 0 otherwise
 908+ F513              ; *****************************************************************************
 909+ F513 CD 6F FB     EXIST:      call    CHKSQFL         ; is there a seq. file opened?
 910+ F516 1E 38                    ld      E,D0            ; prepare a file open error
 911+ F518 C2 6A 18                 jp      NZ,ERROR        ; yes, exit with error
 912+ F51B CD 08 FC                 call    CHKDSKVAL       ; check DOS version & load disk details
 913+ F51E 1E 46                    ld      E,D7            ; prepare a DOS version error
 914+ F520 DA 6A 18                 jp      C,ERROR         ; if Carry is set, raise DOS version error
 915+ F523 E5                       push    HL              ; store code string pointer
 916+ F524 CD 70 28                 call    GETSTR          ; get string (error if it isn't)
 917+ F527 CD B4 F1                 call    CHKFN2          ; store string and get pointers
 918+ F52A CD A4 FC                 call    CLRIOBF         ; clear I/O
 919+ F52D CD 46 F9                 call    CHKFLEXT        ; check if file already exists
 920+ F530 E1                       pop     HL              ; retrieve code string pointer
 921+ F531 3E 00                    ld      A,$00           ; reset A
 922+ F533 CB 17                    rl      A               ; store Carry into A: 0=file not exist, 1=file exist
 923+ F535 5F                       ld      E,A
 924+ F536 CD 49 FD                 call    CF_STANDBY
 925+ F539 7B                       ld      A,E
 926+ F53A C3 21 26                 jp      PASSA           ; return A
 927+ F53D
 928+ F53D
 929+ F53D              ; *****************************************************************************
 930+ F53D              ; E O F
 931+ F53D              ; check EOF/size
 932+ F53D              ; input: 0 => return size of current file
 933+ F53D              ; input: file number => 1 if EOF, 0 otherwise
 934+ F53D              ; *****************************************************************************
 935+ F53D CD 6F FB     EOF:        call    CHKSQFL         ; is there a seq. file open?
 936+ F540 1E 38                    ld      E,D0            ; prepare a file open error
 937+ F542 CA 6A 18                 jp      Z,ERROR         ; no, raise an error
 938+ F545 CD 4D 1E                 call    DEINT           ; get any number
 939+ F548 7B                       ld      A,E             ; is it 0?
 940+ F549 B7                       or      A
 941+ F54A 28 07                    jr      Z,EOF1          ; ok, jump over
 942+ F54C 3A D4 FF                 ld      A,(SEQFL)       ; get current file number
 943+ F54F BB                       cp      E               ; same?
 944+ F550 C2 62 1E                 jp      NZ,FCERR        ; no, error
 945+ F553 D5           EOF1:       push    DE              ; store value
 946+ F554 E5                       push    HL              ; store code string pointer
 947+ F555 CD 5F FB                 call    CHKEOF          ; check EOF/size
 948+ F558 E1                       pop     HL              ; retrieve code string pointer
 949+ F559 C1                       pop     BC              ; retrieve argument
 950+ F55A 3E 00                    ld      A,$00           ; reset A (w/o altering Carry)
 951+ F55C 17                       rla                     ; copy Carry into bit #0
 952+ F55D 47                       ld      B,A             ; copy A into B
 953+ F55E 79                       ld      A,C             ; retrieve argument
 954+ F55F B7                       or      A               ; is it zero?
 955+ F560 20 05                    jr      NZ,RETEOF       ; return EOF
 956+ F562 7A                       ld      A,D             ; copy size into AB
 957+ F563 43                       ld      B,E
 958+ F564 C3 12 26                 jp      ABPASS          ; return size into AB
 959+ F567 78           RETEOF:     ld      A,B             ; retrieve EOF
 960+ F568 C3 21 26                 jp      PASSA           ; return value
 961+ F56B
 962+ F56B
 963+ F56B              ; *****************************************************************************
 964+ F56B              ; P U T
 965+ F56B              ; *****************************************************************************
 966+ F56B CD AE 2A     PUT:        call    GETINT          ; get file number
 967+ F56E 32 3C 55                 ld      (TMPDBF),A      ; store it
 968+ F571 CD 4E 1B                 call    CHKSYN          ; Make sure ',' follows
 969+ F574 2C                       defb    ','
 970+ F575 CD AE 2A                 call    GETINT          ; get mode
 971+ F578 32 3D 55                 ld      (TMPDBF+1),A    ; store it
 972+ F57B E5                       push    HL              ; store code string pointer
 973+ F57C CD 2F F3                 call    PUTFIL          ; insert data into file
 974+ F57F DA ED EF                 jp      C,DOS_ERR       ; any error?
 975+ F582 E1                       pop     HL              ; retrieve code string pointer
 976+ F583 C9                       ret                     ; return to caller
 977+ F584
 978+ F584
 979+ F584              ; *****************************************************************************
 980+ F584              ; G E T
 981+ F584              ; return a byte read from a sequential file
 982+ F584              ; *****************************************************************************
 983+ F584 CD 6F FB     GET:        call    CHKSQFL         ; is there a seq. file opened?
 984+ F587 3E 38                    ld      A,D0            ; prepare a file open error
 985+ F589 28 71                    jr      Z,GETER         ; no, exit with error
 986+ F58B 3A D5 FF                 ld      A,(SEQFLS)      ; yes, check mode
 987+ F58E B7                       or      A               ; is it write?
 988+ F58F C2 62 1E                 jp      NZ,FCERR        ; yes, raise error
 989+ F592 CD 4D 1E                 call    DEINT           ; no, get file number
 990+ F595 7B                       ld      A,E             ; check if...
 991+ F596 B7                       or      A               ; ...it's zero
 992+ F597 CA 04 F6                 jp      Z,GETZER        ; yes, reset file pointer
 993+ F59A 3A D4 FF                 ld      A,(SEQFL)       ; no, compare file opened
 994+ F59D BB                       cp      E               ; with file passed
 995+ F59E C2 62 1E                 jp      NZ,FCERR        ; error if different
 996+ F5A1                          ; load byte pointed by seq. file pointer
 997+ F5A1 E5                       push    HL              ; store code string pointer
 998+ F5A2 CD 5F FB                 call    CHKEOF          ; check if EOF
 999+ F5A5 3E 4C                    ld      A,DA
1000+ F5A7 DA FC F5                 jp      C,GETER         ; return EOF error
1001+ F5AA 2A DD FF                 ld      HL,(SEQPNT)     ; reload pointer in bytes
1002+ F5AD 7C                       ld      A,H             ; copy into AC
1003+ F5AE 4D                       ld      C,L
1004+ F5AF 11 00 02                 ld      DE,$0200        ; size of buffer
1005+ F5B2 CD CB 41                 call    DIV_16_16       ; calculate (pointer MOD $200) => HL=current pointer into buffer
1006+ F5B5 11 C0 FD                 ld      DE,IOBUFF       ; address of I/O buffer
1007+ F5B8 19                       add     HL,DE           ; find position of byte to load
1008+ F5B9 7E                       ld      A,(HL)          ; load byte
1009+ F5BA 32 A5 55                 ld      (TMPBFR1),A     ; store
1010+ F5BD 2A DD FF                 ld      HL,(SEQPNT)     ; load pointer
1011+ F5C0 23                       inc     HL              ; increment pointer
1012+ F5C1 22 DD FF                 ld      (SEQPNT),HL
1013+ F5C4 11 00 02                 ld      DE,$0200        ; sector size
1014+ F5C7 CD 61 41                 call    CMP16           ; check if pointer >= $200
1015+ F5CA 38 29                    jr      C,GET1          ; no, jump over
1016+ F5CC 21 00 00                 ld      HL,$0000        ; yes, reset pointer
1017+ F5CF 22 DD FF                 ld      (SEQPNT),HL
1018+ F5D2 ED 4B D8 FF              ld      BC,(SEQSCTL)    ; load LSW of sector address
1019+ F5D6 03                       inc     BC              ; next sector
1020+ F5D7 79                       ld      A,C             ; check if BC is rolled back to zero (overflow)
1021+ F5D8 B0                       or      B
1022+ F5D9 20 09                    jr      NZ,GET2         ; no, jump over
1023+ F5DB ED 5B D6 FF              ld      DE,(SEQSCTM)    ; yes, load MSW of sector address
1024+ F5DF 13                       inc     DE              ; increment MSW of sector address
1025+ F5E0 ED 53 D6 FF              ld      (SEQSCTM),DE    ; save MSW of sector address
1026+ F5E4 ED 43 D8 FF  GET2:       ld      (SEQSCTL),BC    ; save LSW of sector address
1027+ F5E8 ED 5B D6 FF              ld      DE,(SEQSCTM)    ; (re)load MSW of sector address
1028+ F5EC CD 13 FD                 call    CF_SETSTR       ; set sector to read
1029+ F5EF CD 55 FD                 call    CF_RD_SEC       ; read next sector
1030+ F5F2 CD 49 FD                 call    CF_STANDBY      ; set CF to standby
1031+ F5F5 E1           GET1:       pop     HL              ; retrieve code string pointer
1032+ F5F6 3A A5 55                 ld      A,(TMPBFR1)
1033+ F5F9 C3 21 26                 jp      PASSA           ; return A and then return to caller
1034+ F5FC E1           GETER:      pop     HL              ; retrieve code string pointer
1035+ F5FD 5F                       ld      E,A             ; load error code
1036+ F5FE CD 49 FD                 call    CF_STANDBY      ; set CF into stand-by
1037+ F601 C3 6A 18                 jp      ERROR           ; raise error
1038+ F604 E5           GETZER:     push    HL
1039+ F605 ED 5B 47 55              ld      DE,(MSW_SCT)    ; reload MSW of file
1040+ F609 ED 53 D6 FF              ld      (SEQSCTM),DE    ; restore
1041+ F60D ED 4B 49 55              ld      BC,(LSW_SCT)    ; reload LSW of file
1042+ F611 ED 43 D8 FF              ld      (SEQSCTL),BC    ; restore
1043+ F615 CD 63 F4                 call    OPFLRS1         ; reload 1st sector and reset pointer
1044+ F618 E1                       pop     HL              ; retrieve code string pointer
1045+ F619 AF                       xor     A               ; set A to 0 for "no errors"
1046+ F61A C3 21 26                 jp      PASSA           ; return A
1047+ F61D
1048+ F61D
1049+ F61D              ; *****************************************************************************
1050+ F61D              ; DOS ERRORS
1051+ F61D              ; *****************************************************************************
1052+ F61D 3E 38        FILOPCLER:  ld      A,D0            ; file open/close error
1053+ F61F 01                       defb    $01             ; Skip next statement
1054+ F620 3E 4A        FILALROP:   ld      A,D9            ; file already open
1055+ F622 01                       defb    $01             ; Skip next statement
1056+ F623 3E 3C        D2ERR:      ld      A,D2            ; disk geometry error
1057+ F625 01                       defb    $01             ; Skip next statement
1058+ F626 3E 42        DSKFULL:    ld      A,D5            ; disk full error
1059+ F628 01                       defb    $01             ; Skip next statement
1060+ F629 3E 44        DUPLERR:    ld      A,D6            ; duplicate file name
1061+ F62B 01                       defb    $01             ; Skip next statement
1062+ F62C 3E 3A        NAMERR:     ld      A,D1            ; file name error
1063+ F62E 01                       defb    $01             ; Skip next statement
1064+ F62F 3E 48        FLNTFND:    ld      A,D8            ; file not found
1065+ F631 01                       defb    $01             ; Skip next statement
1066+ F632 3E 40        LODERR:     ld      A,D4            ; generic load error
1067+ F634 01                       defb    $01             ; Skip next statement
1068+ F635 3E 46        DOSVERSERR: ld      A,D7            ; DOS version error
1069+ F637 32 3B 55     RET_ERR:    ld      (DOSER),A       ; store DOS error
1070+ F63A CD 49 FD                 call    CF_STANDBY      ; set CF into stand-by
1071+ F63D 37                       scf                     ; set Carry for error
1072+ F63E C9                       ret                     ; return to caller
1073+ F63F
1074+ F63F
1075+ F63F              ; *****************************************************************************
1076+ F63F              ; L I S T    F I L E S
1077+ F63F              ; Function: print details of disk and list files
1078+ F63F              ; Input: D: $00=only disk details; $01=file list, too
1079+ F63F              ; *****************************************************************************
1080+ F63F 44 69 73 6B  DSKNMTX:    defb    "Disk name: ",0
1080+ F643 20 6E 61 6D
1080+ F647 65 3A 20 00
1081+ F64B 0D 53 65 63  TLSCTTX:    defb    CR,"Sectors: ",0
1081+ F64F 74 6F 72 73
1081+ F653 3A 20 00
1082+ F656 0D 41 6C 6C  ALFLSTXT:   defb    CR,"Allowed files: ",0
1082+ F65A 6F 77 65 64
1082+ F65E 20 66 69 6C
1082+ F662 65 73 3A 20
1082+ F666 00
1083+ F667 20 66 69 6C  TLFLSTX:    defb    " file(s)",CR,0
1083+ F66B 65 28 73 29
1083+ F66F 0D 00
1084+ F671 CD 6F FB     LST_FILES:  call    CHKSQFL         ; check if a seq. file is open
1085+ F674 C2 1D F6                 jp      NZ,FILOPCLER    ; jump if open
1086+ F677 CD 08 FC                 call    CHKDSKVAL       ; check DOS version & load disk details
1087+ F67A DA 35 F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
1088+ F67D D5                       push    DE              ; store D
1089+ F67E CD BC FB                 call    LDMSCT          ; load Master Sector
1090+ F681 21 3F F6                 ld      HL,DSKNMTX      ; pointer to "Disk name" message
1091+ F684 CD 30 27                 call    PRS             ; print it
1092+ F687 21 C0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
1093+ F68A 11 20 00                 ld      DE,$0020        ; position of disk name
1094+ F68D 19                       add     HL,DE           ; get address
1095+ F68E 06 10                    ld      B,$10           ; 16 chars
1096+ F690 7E           INPR1:      ld      A,(HL)          ; load char
1097+ F691 CD 59 1B                 call    OUTC            ; print it
1098+ F694 23                       inc     HL
1099+ F695 10 F9                    djnz    INPR1           ; repeat
1100+ F697 3E 0D                    ld      A,CR
1101+ F699 CD 59 1B                 call    OUTC            ; carriage return
1102+ F69C DD 21 00 00              ld      IX,$0000        ; reset file counter (for use in formatting)
1103+ F6A0 D1                       pop     DE              ; retrieve D
1104+ F6A1 7A                       ld      A,D
1105+ F6A2 B7                       or      A               ; is D=0?
1106+ F6A3 CA 56 F7                 jp      Z,PNTSTATS      ; yes, jump over
1107+ F6A6                          ; print list of files
1108+ F6A6 21 C0 FD                 ld      HL,IOBUFF       ; start of I/O buffer
1109+ F6A9 11 0F 00                 ld      DE,$000F        ; point to details of disk
1110+ F6AC 19                       add     HL,DE           ; find address
1111+ F6AD 11 A0 FD                 ld      DE,DOSBFR       ; store into DOS buffer
1112+ F6B0 01 20 00                 ld      BC,$0020        ; 32 bytes
1113+ F6B3 ED B0                    ldir                    ; copy
1114+ F6B5 CD AD FB                 call    LDENTRIES       ; load entries
1115+ F6B8 FD 2A 42 55              ld      IY,(NTR_NBR)    ; load max entries
1116+ F6BC D9                       exx
1117+ F6BD 01 00 00                 ld      BC,$0000        ; reset file counter
1118+ F6C0 D9                       exx
1119+ F6C1 CD 74 FB                 call    SETPTEN         ; point to 1st sector of dir
1120+ F6C4 CD 7C FB     LSTFILES1:  call    PT2FSEN         ; point to 1st entry of a dir's sect
1121+ F6C7 CD 87 FB     LSTFILES2:  call    CKCREN          ; check current entry
1122+ F6CA 28 64                    jr      Z,LSTFILES6     ; if empty or deleted, ignore it
1123+ F6CC C5                       push    BC              ; this is a valid entry - so, store BC (LSW of sect)
1124+ F6CD FD E5                    push    IY              ; store IY (entries counter)
1125+ F6CF E5                       push    HL              ; store HL (sect entry counter)
1126+ F6D0 D5                       push    DE              ; store DE (MSW of sector)
1127+ F6D1 DD E5                    push    IX              ; store IX (pointer to first byte of entry)
1128+ F6D3 06 10                    ld      B,$10           ; 16 chars to read and print
1129+ F6D5 DD 7E 00     LSTFILES3:  ld      A,(IX)          ; load char from name
1130+ F6D8 CD 59 1B                 call    OUTC            ; print char
1131+ F6DB DD 23                    inc     IX              ; next char
1132+ F6DD 10 F6                    djnz    LSTFILES3       ; repeat
1133+ F6DF 3E 20                    ld      A,SPC
1134+ F6E1 CD 59 1B                 call    OUTC            ; print space
1135+ F6E4 DD 7E 00                 ld      A,(IX)          ; file type
1136+ F6E7 D6 80                    sub     $80             ; types start from $80
1137+ F6E9 B7                       or      A               ; BAS type ($00)?
1138+ F6EA 20 05                    jr      NZ,LSTFILES20   ; no, jump over
1139+ F6EC 21 9A F7                 ld      HL,FILETP       ; print "BAS"
1140+ F6EF 18 13                    jr      LSTFILESPR
1141+ F6F1 3D           LSTFILES20: dec     A               ; BIN type ($01)?
1142+ F6F2 20 05                    jr      NZ,LSTFILES21   ; no, jump over
1143+ F6F4 21 9F F7                 ld      HL,FILETP+5     ; print "BIN"
1144+ F6F7 18 0B                    jr      LSTFILESPR
1145+ F6F9 3D           LSTFILES21: dec     A
1146+ F6FA 20 05                    jr      NZ,LSTFILES22
1147+ F6FC 21 A4 F7                 ld      HL,FILETP+10    ; print "SEQ"
1148+ F6FF 18 03                    jr      LSTFILESPR
1149+ F701 21 A4 F7     LSTFILES22: ld      HL,FILETP+10    ; print "???"
1150+ F704 CD 30 27     LSTFILESPR: call    PRS
1151+ F707 01 08 00                 ld      BC,$0008
1152+ F70A DD 09                    add     IX,BC           ; point to file size in bytes
1153+ F70C DD 4E 00                 ld      C,(IX)          ; load size in BC, first LSW
1154+ F70F DD 23                    inc     IX
1155+ F711 DD 46 00                 ld      B,(IX)          ; then MSW
1156+ F714 C5                       push    BC              ; copy...
1157+ F715 DD E1                    pop     IX              ; ...into IX
1158+ F717 11 00 00                 ld      DE,$0000        ; reset DE
1159+ F71A FD E5                    push    IY
1160+ F71C CD 7B FC                 call    PRN16ASCIX      ; print size in bytes (DEIX)
1161+ F71F FD E1                    pop     IY
1162+ F721 3E 0D                    ld      A,CR
1163+ F723 CD 59 1B                 call    OUTC            ; print carriage return
1164+ F726 D9                       exx                     ; set shadow registers
1165+ F727 03                       inc     BC              ; increment file counter
1166+ F728 D9                       exx                     ; restore main registers
1167+ F729 DD E1                    pop     IX              ; retrieve IX
1168+ F72B D1                       pop     DE              ; retrieve DE
1169+ F72C E1                       pop     HL              ; retrieve HL
1170+ F72D FD E1                    pop     IY              ; retrieve IY
1171+ F72F C1                       pop     BC              ; retrieve BC
1172+ F730 CD C2 1D     LSTFILES6:  call    TSTBRK          ; Test for break key
1173+ F733 CD C5 1C                 call    TSTSPC          ; test for space
1174+ F736 CD 8F FB                 call    GTNXTEN         ; other entries in this sector?
1175+ F739 20 8C                    jr      NZ,LSTFILES2    ; yes, continue check
1176+ F73B CD 9B FB                 call    CKLSTEN         ; go to next sector
1177+ F73E D2 C4 F6                 jp      NC,LSTFILES1    ; more entries? repeat
1178+ F741 D9                       exx                     ; set shadow registers
1179+ F742 C5                       push    BC              ; store file counter
1180+ F743 D9                       exx                     ; restore main registers
1181+ F744 DD E1                    pop     IX              ; retrieve file counter
1182+ F746 DD E5                    push    IX              ; store it again
1183+ F748 11 00 00                 ld      DE,$0000        ; reset DE
1184+ F74B CD 7B FC                 call    PRN16ASCIX      ; print number of files from DEIX
1185+ F74E 21 67 F6                 ld      HL,TLFLSTX
1186+ F751 CD 30 27                 call    PRS             ; print "file(s)"
1187+ F754 DD E1                    pop     IX
1188+ F756 21 4B F6     PNTSTATS:   ld      HL,TLSCTTX      ; Point to message "Tot. sectors"
1189+ F759 CD 30 27                 call    PRS             ; print message
1190+ F75C 21 A0 FD                 ld      HL,DOSBFR       ; reload address of I/O buffer and point to disk size
1191+ F75F DD E5                    push    IX
1192+ F761 CD 72 FC                 call    PRN32ASCII      ; print size
1193+ F764 3E 2F                    ld      A,'/'
1194+ F766 CD 59 1B                 call    OUTC            ; print a "/""
1195+ F769 D1                       pop     DE              ; copy number of entries into DE
1196+ F76A 01 80 00                 ld      BC,$0080        ; 128 sectors per entry block
1197+ F76D CD 86 41                 call    MUL_U32         ; multiply BC times DE: returns DEHL
1198+ F770 ED 53 4D 55              ld      (TPBF1),DE      ; store results
1199+ F774 22 4F 55                 ld      (TPBF2),HL
1200+ F777 21 4D 55                 ld      HL,TPBF1        ; print results
1201+ F77A CD 72 FC                 call    PRN32ASCII
1202+ F77D 21 56 F6                 ld      HL,ALFLSTXT     ; Point to message "Allowed files"
1203+ F780 CD 30 27                 call    PRS             ; print message
1204+ F783 21 A0 FD                 ld      HL,DOSBFR       ; reload address of I/O buffer
1205+ F786 01 0A 00                 ld      BC,$000A        ; address of allowed files
1206+ F789 09                       add     HL,BC           ; find pointer
1207+ F78A 11 00 00                 ld      DE,$0000        ; MSW set to $0000
1208+ F78D CD 75 FC                 call    PRN16ASCII      ; print max files
1209+ F790 3E 0D                    ld      A,CR
1210+ F792 CD 59 1B                 call    OUTC            ; print a carriage return
1211+ F795 CD 49 FD                 call    CF_STANDBY      ; put CF into standby
1212+ F798 AF                       xor     A               ; clear Carry flag
1213+ F799 C9                       ret                     ; return to caller
1214+ F79A 42 41 53 20  FILETP:     defb    "BAS ",0        ; BASIC type
1214+ F79E 00
1215+ F79F 42 49 4E 20              defb    "BIN ",0        ; BINARY type
1215+ F7A3 00
1216+ F7A4 53 45 51 20              defb    "SEQ ",0        ; SEQUENTIAL type
1216+ F7A8 00
1217+ F7A9 3F 3F 3F 20              defb    "??? ",0        ; unkown
1217+ F7AD 00
1218+ F7AE
1219+ F7AE
1220+ F7AE              ; *****************************************************************************
1221+ F7AE              ; S A V E    F I L E
1222+ F7AE              ; save current BASIC program onto a file
1223+ F7AE              ; *****************************************************************************
1224+ F7AE CD 6F FB     SAVFILE:    call    CHKSQFL         ; check if a seq. file is open
1225+ F7B1 C2 1D F6                 jp      NZ,FILOPCLER    ; jump if open
1226+ F7B4 CD 46 F9                 call    CHKFLEXT        ; file already exists?
1227+ F7B7 DA 29 F6                 jp      C,DUPLERR       ; name is present - error
1228+ F7BA CD 37 FB                 call    FNDFRENTR       ; find a free entry in the directory
1229+ F7BD DA 26 F6                 jp      C,DSKFULL       ; no entry, disk full error
1230+ F7C0 3A 53 55                 ld      A,(TPBF4)       ; check what to save
1231+ F7C3 FE 80                    cp      $80             ; BASIC program?
1232+ F7C5 C2 D4 F7                 jp      NZ,SAVFL3       ; no, jump over
1233+ F7C8                          ; BASIC area to save starts at PROGND and ends at (PROGND)
1234+ F7C8 2A EB 55                 ld      HL,(PROGND)     ; load end of BASIC program <- WARNING: pay attention to (PROGND) and PROGND
1235+ F7CB 11 EB 55                 ld      DE,PROGND       ; start of RAM to be saved  <- WARNING: pay attention to (PROGND) and PROGND
1236+ F7CE ED 53 55 55              ld      (SRTMEM),DE     ; copy DE
1237+ F7D2 18 08                    jr      SAVFL1
1238+ F7D4 2A 57 55     SAVFL3:     ld      HL,(ENDMEM)     ; save a portion of memory: HL <= end of portion
1239+ F7D7 23                       inc     HL              ; we always need 1 more byte to store the portion of memory
1240+ F7D8 ED 5B 55 55              ld      DE,(SRTMEM)     ; DE <= start of portion
1241+ F7DC                          ; compute how many sectors/blocks are needed to save file
1242+ F7DC AF           SAVFL1:     xor     A               ; reset Carry
1243+ F7DD ED 52                    sbc     HL,DE           ; get how many bytes to save
1244+ F7DF 22 44 55                 ld      (BYT_SIZ),HL    ; store into memory
1245+ F7E2 11 00 02                 ld      DE,$0200        ; 512 bytes per sector
1246+ F7E5 7C                       ld      A,H             ; move lenght...
1247+ F7E6 4D                       ld      C,L             ; ...into AC
1248+ F7E7 CD CB 41                 call    DIV_16_16       ; lenght/512 = nbr. of sectors: quotient in AC but A will be discarded
1249+ F7EA 7C                       ld      A,H             ; check if...
1250+ F7EB B5                       or      L               ; ...remainder (HL) is 0
1251+ F7EC 28 01                    jr      Z,SAVFL6        ; yes, jump over
1252+ F7EE 03                       inc     BC              ; no, so we need another sector
1253+ F7EF 79           SAVFL6:     ld      A,C
1254+ F7F0 32 46 55                 ld      (SCT_SIZ),A     ; store into memory
1255+ F7F3 CD 63 F8                 call    SVENTRY         ; save new entry into dir
1256+ F7F6 CD A4 FC                 call    CLRIOBF         ; clear I/O buffer
1257+ F7F9                          ; start saving RAM
1258+ F7F9 ED 5B 55 55              ld      DE,(SRTMEM)     ; load start of RAM
1259+ F7FD ED 53 4B 55              ld      (RAM_PTR),DE    ; store
1260+ F801 CD A4 FC     SAVFL10:    call    CLRIOBF         ; clear I/O buffer
1261+ F804 2A 44 55                 ld      HL,(BYT_SIZ)    ; load bytes left to be copied
1262+ F807 11 00 02                 ld      DE,$0200        ; are they < 512?
1263+ F80A CD 61 41                 call    CMP16
1264+ F80D 30 04                    jr      NC,SAVFL4       ; no, jump over
1265+ F80F ED 5B 44 55              ld      DE,(BYT_SIZ)    ; yes, so load remaining bytes
1266+ F813 4B           SAVFL4:     ld      C,E             ; bytes to copy
1267+ F814 42                       ld      B,D             ; into BC
1268+ F815 2A 4B 55                 ld      HL,(RAM_PTR)    ; load pointer to RAM to be saved
1269+ F818 11 C0 FD                 ld      DE,IOBUFF       ; load start of I/O buffer
1270+ F81B ED B0                    ldir                    ; copy data
1271+ F81D ED 5B 47 55              ld      DE,(MSW_SCT)    ; load MSW of sector
1272+ F821 ED 4B 49 55              ld      BC,(LSW_SCT)    ; load LSW of sector
1273+ F825 CD 7C FD                 call    CF_WR_SEC       ; write sector
1274+ F828 DA A0 FA                 jp      C,WRT_ERR       ; error?
1275+ F82B 21 46 55                 ld      HL,SCT_SIZ      ; sector counter
1276+ F82E 35                       dec     (HL)            ; copied all the sectors?
1277+ F82F CA 5E F8                 jp      Z,SAVFLEXT      ; yes, exit
1278+ F832 2A 4B 55                 ld      HL,(RAM_PTR)    ; pointer to RAM
1279+ F835 11 00 02                 ld      DE,$0200        ; block of 512 bytes copied
1280+ F838 19                       add     HL,DE           ; calculate next starting address
1281+ F839 22 4B 55                 ld      (RAM_PTR),HL    ; store next block
1282+ F83C AF                       xor     A               ; reset Carry
1283+ F83D 2A 44 55                 ld      HL,(BYT_SIZ)    ; load left bytes
1284+ F840 ED 52                    sbc     HL,DE           ; subtract copied bytes
1285+ F842 22 44 55                 ld      (BYT_SIZ),HL    ; store left bytes
1286+ F845 ED 4B 49 55              ld      BC,(LSW_SCT)    ; load LSW of sector
1287+ F849 03                       inc     BC              ; next sector
1288+ F84A 78                       ld      A,B             ; BC=$0000?
1289+ F84B B1                       or      C
1290+ F84C 20 09                    jr      NZ,SAVFL12      ; no, jump over
1291+ F84E ED 5B 47 55              ld      DE,(MSW_SCT)    ; load MSW of sector
1292+ F852 13                       inc     DE              ; increment DE
1293+ F853 ED 53 47 55              ld      (MSW_SCT),DE    ; store new MSW of sector
1294+ F857 ED 43 49 55  SAVFL12:    ld      (LSW_SCT),BC    ; store new LSW of sector
1295+ F85B C3 01 F8                 jp      SAVFL10         ; repeat
1296+ F85E CD 49 FD     SAVFLEXT:   call    CF_STANDBY      ; set CF into stand-by mode
1297+ F861 AF                       xor     A               ; clear Carry flag
1298+ F862 C9                       ret                     ; return to caller
1299+ F863
1300+ F863
1301+ F863              ; save entry on disk
1302+ F863 11 00 00     SVENTRY:    ld      DE,$0000        ; directory is always from sector 0000-0001
1303+ F866 ED 4B 40 55              ld      BC,(DIR_SCT)    ; load sector of dir where to save file entry
1304+ F86A CD 13 FD                 call    CF_SETSTR       ; set sector to read
1305+ F86D CD 55 FD                 call    CF_RD_SEC       ; read sector
1306+ F870 3A 42 55                 ld      A,(NTR_NBR)     ; load entry number (ignoring MSB)
1307+ F873 E6 0F                    and     %00001111       ; be sure to get only low nibble
1308+ F875 87                       add     A,A             ; multiply...
1309+ F876 87                       add     A,A             ; ...times 16 by...
1310+ F877 87                       add     A,A             ; ...adding...
1311+ F878 87                       add     A,A             ; ...4 times
1312+ F879 CB 27                    sla     A               ; left shift to multiply times 32 - Carry is set if results is > 255
1313+ F87B 5F                       ld      E,A             ; copy into C
1314+ F87C CB 12                    rl      D               ; if Carry, then increment D (D was 0, see above)
1315+ F87E                          ; set name
1316+ F87E 21 C0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
1317+ F881 19                       add     HL,DE           ; add offset to get address of entry
1318+ F882 11 A0 FD                 ld      DE,DOSBFR       ; pointer to file name
1319+ F885 01 10 00                 ld      BC,$0010        ; 16 chars
1320+ F888 EB                       ex      DE,HL           ; move source into HL and destination into DE
1321+ F889 ED B0                    ldir                    ; copy file name
1322+ F88B EB                       ex      DE,HL           ; move current buffer pointer into HL
1323+ F88C 3A 53 55                 ld      A,(TPBF4)       ; load the type of file
1324+ F88F 77                       ld      (HL),A          ; store it
1325+ F890 23                       inc     HL
1326+ F891 AF                       xor     A               ; file attributes - AT THE MOMENT, NO ATTRIBUTES
1327+ F892 77                       ld      (HL),A
1328+ F893 23                       inc     HL
1329+ F894 ED 5B 42 55              ld      DE,(NTR_NBR)    ; reload entry number
1330+ F898 CD 68 FC                 call    DE2HL           ; store entry into buffer
1331+ F89B E5                       push    HL              ; store pointer
1332+ F89C 01 80 00                 ld      BC,$0080        ; 128 sectors per entry block
1333+ F89F CD 86 41                 call    MUL_U32         ; multiply BC times DE: returns DEHL
1334+ F8A2 ED 4B 3E 55              ld      BC,(DAT_STRT)   ; load start of data
1335+ F8A6 09                       add     HL,BC           ; add sector of data area
1336+ F8A7 30 01                    jr      NC,SAVFL9       ; overflow?
1337+ F8A9 13                       inc     DE              ; yes, increment DE
1338+ F8AA ED 53 47 55  SAVFL9:     ld      (MSW_SCT),DE    ; store MSW of sector
1339+ F8AE 22 49 55                 ld      (LSW_SCT),HL    ; store LSW of sector
1340+ F8B1 E1                       pop     HL              ; retrieve pointer
1341+ F8B2 CD 68 FC                 call    DE2HL           ; also copy MSW of sector into entry
1342+ F8B5 ED 5B 49 55              ld      DE,(LSW_SCT)    ; retrieve LSW
1343+ F8B9 CD 68 FC                 call    DE2HL           ; also copy LSW of sector into entry
1344+ F8BC ED 5B 44 55              ld      DE,(BYT_SIZ)    ; retrieve file size in bytes
1345+ F8C0 CD 68 FC                 call    DE2HL           ; copy file size into buffer
1346+ F8C3 3A 46 55                 ld      A,(SCT_SIZ)     ; retrieve file size in sectors
1347+ F8C6 77                       ld      (HL),A          ; copy into buffer
1348+ F8C7 23                       inc     HL              ; next location
1349+ F8C8 ED 5B 55 55              ld      DE,(SRTMEM)     ; start of address of file in RAM
1350+ F8CC CD 68 FC                 call    DE2HL           ; copy into buffer
1351+ F8CF 06 03                    ld      B,$03           ; remaining chars...
1352+ F8D1 AF                       xor     A               ; ...set to $00
1353+ F8D2 77           SAVFL2:     ld      (HL),A          ; reset byte
1354+ F8D3 23                       inc     HL              ; next cell
1355+ F8D4 10 FC                    djnz    SAVFL2          ; repeat
1356+ F8D6                          ; save entry into directory
1357+ F8D6 11 00 00                 ld      DE,$0000        ; block 0
1358+ F8D9 ED 4B 40 55              ld      BC,(DIR_SCT)    ; load sector of dir where to save file entry
1359+ F8DD CD 7C FD                 call    CF_WR_SEC       ; write new entry into directory
1360+ F8E0 DA 23 F6                 jp      C,D2ERR         ; error occured
1361+ F8E3 C9                       ret
1362+ F8E4
1363+ F8E4
1364+ F8E4              ; *****************************************************************************
1365+ F8E4              ; C H A N G E    F I L E N A M E
1366+ F8E4              ; change name to a file
1367+ F8E4              ; *****************************************************************************
1368+ F8E4 ED 5B 44 55  CHNGNAM:    ld      DE,(BYT_SIZ)    ; load lenght
1369+ F8E8 ED 53 A9 55              ld      (DKLNPT),DE     ; store it
1370+ F8EC ED 5B 4B 55              ld      DE,(RAM_PTR)    ; load address
1371+ F8F0 ED 53 A7 55              ld      (DKNMPT),DE     ; store it
1372+ F8F4 CD 46 F9                 call    CHKFLEXT        ; destination file already exists?
1373+ F8F7 DA 29 F6                 jp      C,DUPLERR       ; file name already exists
1374+ F8FA CD A4 FC                 call    CLRIOBF         ; clear I/O buffer
1375+ F8FD ED 5B AB 55              ld      DE,(TMPBFR4)    ; load lenght
1376+ F901 ED 53 A9 55              ld      (DKLNPT),DE     ; store it
1377+ F905 ED 5B 55 55              ld      DE,(TPBF4+2)    ; load address
1378+ F909 ED 53 A7 55              ld      (DKNMPT),DE     ; store it
1379+ F90D CD 63 F9                 call    LK4FILE         ; look for file
1380+ F910 D2 2F F6                 jp      NC,FLNTFND      ; file not found error
1381+ F913 ED 5B 44 55              ld      DE,(BYT_SIZ)    ; load lenght
1382+ F917 ED 53 A9 55              ld      (DKLNPT),DE     ; store it
1383+ F91B ED 5B 4B 55              ld      DE,(RAM_PTR)    ; load address
1384+ F91F ED 53 A7 55              ld      (DKNMPT),DE     ; store it
1385+ F923 CD B9 FC                 call    CLRDOSBF        ; clear DOS buffer
1386+ F926 11 A0 FD                 ld      DE,DOSBFR       ; DE set to beginning of DOS buffer
1387+ F929 CD 40 FC                 call    CHKNMVAL        ; check and copy file name
1388+ F92C 21 A0 FD                 ld      HL,DOSBFR       ; retrieve new name pointer
1389+ F92F DD E5                    push    IX              ; copy dest. address...
1390+ F931 D1                       pop     DE              ; ...into DE
1391+ F932 01 10 00                 ld      BC,$0010        ; 16 chars to copy
1392+ F935 ED B0                    ldir                    ; copy
1393+ F937 ED 5B 4F 55              ld      DE,(TPBF2)      ; retrieve MSW of dir. sector
1394+ F93B ED 4B 51 55              ld      BC,(TPBF3)      ; retrieve LSW of dir. sector
1395+ F93F CD 7C FD                 call    CF_WR_SEC       ; write sector
1396+ F942 CD 49 FD                 call    CF_STANDBY      ; put CF in standby
1397+ F945 C9                       ret                     ; return to caller
1398+ F946
1399+ F946
1400+ F946              ; *****************************************************************************
1401+ F946              ; C H E C K    F I L E    E X I S T A N C E
1402+ F946              ; check if a file with the given name exists into dir
1403+ F946              ; Carry set if exist
1404+ F946              ; *****************************************************************************
1405+ F946 CD A4 FC     CHKFLEXT:   call    CLRIOBF         ; clear I/O
1406+ F949 CD 08 FC                 call    CHKDSKVAL       ; check DOS version & load disk details
1407+ F94C DA 35 F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
1408+ F94F CD AD FB                 call    LDENTRIES       ; load entries into RAM register NTR_NBR
1409+ F952 CD 6D FC                 call    HL2DE           ; get start of directory into DE
1410+ F955 ED 53 3C 55              ld      (DIR_STRT),DE   ; store
1411+ F959 CD 6D FC                 call    HL2DE           ; get start of data area into DE
1412+ F95C ED 53 3E 55              ld      (DAT_STRT),DE   ; store
1413+ F960 C3 66 F9                 jp      LK4FILE1        ; check for name already present in dir and return to caller
1414+ F963
1415+ F963
1416+ F963              ; *****************************************************************************
1417+ F963              ; L O O K    F O R    A    F I L E
1418+ F963              ; look for the given file into the dir
1419+ F963              ; Carry is reset if not found, set otherwise
1420+ F963              ; *****************************************************************************
1421+ F963 CD AD FB     LK4FILE:    call    LDENTRIES       ; load entries into RAM register NTR_NBR
1422+ F966 CD A4 FC     LK4FILE1:   call    CLRIOBF         ; clear IO buffer
1423+ F969 CD B9 FC                 call    CLRDOSBF        ; clear DOS buffer
1424+ F96C 11 A0 FD                 ld      DE,DOSBFR       ; DE set to beginning of DOS buffer
1425+ F96F CD 40 FC                 call    CHKNMVAL        ; check and copy file name
1426+ F972 DA 2C F6                 jp      C,NAMERR        ; if Carry, file name error
1427+ F975 C3 A5 FA                 jp      FILE_EXIST      ; check if file exists and return to caller
1428+ F978
1429+ F978
1430+ F978              ; *****************************************************************************
1431+ F978              ; F I L E    L O A D
1432+ F978              ; load a file from the disk into the memory
1433+ F978              ; *****************************************************************************
1434+ F978 CD 6F FB     LODFILE:    call    CHKSQFL         ; check if a seq. file is open
1435+ F97B C2 1D F6                 jp      NZ,FILOPCLER    ; jump if open
1436+ F97E CD A4 FC                 call    CLRIOBF         ; clear I/O
1437+ F981 CD 08 FC                 call    CHKDSKVAL       ; check DOS version & load disk details
1438+ F984 DA 35 F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
1439+ F987 CD 63 F9                 call    LK4FILE         ; look for given file
1440+ F98A D2 2F F6                 jp      NC,FLNTFND      ; file not found - error
1441+ F98D DD E5                    push    IX              ; copy pointer to file...
1442+ F98F E1                       pop     HL              ; ...into HL
1443+ F990 01 10 00                 ld      BC,$0010        ; skip file name (16 chars)...
1444+ F993 09                       add     HL,BC           ; ...by getting pointer to file details
1445+ F994 7E                       ld      A,(HL)          ; load file type
1446+ F995 FE 80                    cp      $80             ; 'BAS' type?
1447+ F997 28 0C                    jr      Z,LDFL4         ; yes, jump over
1448+ F999 FE 81                    cp      $81             ; 'BIN' type?
1449+ F99B C2 32 F6                 jp      NZ,LODERR       ; no, raise error
1450+ F99E 3A 53 55                 ld      A,(TPBF4)       ; if BIN file, file must be loaded into its original position
1451+ F9A1 B7                       or      A               ; did the user set this?
1452+ F9A2 CA 32 F6                 jp      Z,LODERR        ; no, raise an error
1453+ F9A5 0E 04        LDFL4:      ld      C,$04           ; 4 steps forward and also 4 bytes to copy
1454+ F9A7 09                       add     HL,BC           ; point to starting sector
1455+ F9A8 11 47 55                 ld      DE,MSW_SCT      ; point to store sector address of file
1456+ F9AB ED B0                    ldir                    ; copy MSW/LSW from entry into buffer
1457+ F9AD 11 44 55                 ld      DE,BYT_SIZ      ; point to store size of file
1458+ F9B0 01 03 00                 ld      BC,$0003        ; 3 bytes to copy
1459+ F9B3 ED B0                    ldir                    ; copy size in bytes and sectors from entry into buffer
1460+ F9B5 11 EB 55                 ld      DE,PROGND       ; load start of BASIC RAM
1461+ F9B8 3A 53 55                 ld      A,(TPBF4)       ; check where to save the data from
1462+ F9BB B7                       or      A               ; is it 0? (meaning from the current BASIC pointers)
1463+ F9BC 28 03                    jr      Z,LDFL1         ; yes, don't re-load the file from the address stored into the file
1464+ F9BE CD 6D FC                 call    HL2DE           ; no, load RAM address from disk
1465+ F9C1 ED 53 4B 55  LDFL1:      ld      (RAM_PTR),DE    ; store starting pointer
1466+ F9C5                          ; start loading from disk
1467+ F9C5 CD A4 FC     LDFL2:      call    CLRIOBF         ; clear I/O buffer
1468+ F9C8 ED 5B 47 55              ld      DE,(MSW_SCT)    ; load MSW of sector
1469+ F9CC ED 4B 49 55              ld      BC,(LSW_SCT)    ; load LSW of sector
1470+ F9D0 CD 13 FD                 call    CF_SETSTR       ; set sector
1471+ F9D3 CD 55 FD                 call    CF_RD_SEC       ; read sector
1472+ F9D6 2A 44 55                 ld      HL,(BYT_SIZ)    ; load bytes left to be copied
1473+ F9D9 11 00 02                 ld      DE,$0200        ; are they < 512?
1474+ F9DC CD 61 41                 call    CMP16
1475+ F9DF 30 04                    jr      NC,LDFL3        ; no, jump over
1476+ F9E1 ED 5B 44 55              ld      DE,(BYT_SIZ)    ; yes, so load only remaining bytes
1477+ F9E5 4B           LDFL3:      ld      C,E             ; move bytes to copy...
1478+ F9E6 42                       ld      B,D             ; ...into BC
1479+ F9E7 21 C0 FD                 ld      HL,IOBUFF       ; point to I/O buffer
1480+ F9EA ED 5B 4B 55              ld      DE,(RAM_PTR)    ; point to RAM where to save
1481+ F9EE ED B0                    ldir                    ; copy data
1482+ F9F0 21 46 55                 ld      HL,SCT_SIZ      ; sector counter
1483+ F9F3 35                       dec     (HL)            ; copied all the sectors?
1484+ F9F4 CA 23 FA                 jp      Z,LDFLEX        ; yes, exit
1485+ F9F7 2A 4B 55                 ld      HL,(RAM_PTR)    ; pointer to RAM
1486+ F9FA 11 00 02                 ld      DE,$0200        ; block of 512 bytes copied
1487+ F9FD 19                       add     HL,DE           ; calculate next starting address
1488+ F9FE 22 4B 55                 ld      (RAM_PTR),HL    ; store next block
1489+ FA01 AF                       xor     A               ; reset Carry
1490+ FA02 2A 44 55                 ld      HL,(BYT_SIZ)    ; load left bytes
1491+ FA05 ED 52                    sbc     HL,DE           ; subtract copied bytes
1492+ FA07 22 44 55                 ld      (BYT_SIZ),HL    ; store left bytes
1493+ FA0A ED 4B 49 55              ld      BC,(LSW_SCT)    ; load LSW of sector
1494+ FA0E 03                       inc     BC              ; next sector
1495+ FA0F 78                       ld      A,B             ; BC=$0000?
1496+ FA10 B1                       or      C
1497+ FA11 20 09                    jr      NZ,LDFL5        ; no, jump over
1498+ FA13 ED 5B 47 55              ld      DE,(MSW_SCT)    ; load MSW of sector
1499+ FA17 13                       inc     DE              ; increment DE
1500+ FA18 ED 53 47 55              ld      (MSW_SCT),DE    ; store new MSW of sector
1501+ FA1C ED 43 49 55  LDFL5:      ld      (LSW_SCT),BC    ; store new LSW of sector
1502+ FA20 C3 C5 F9                 jp      LDFL2           ; repeat
1503+ FA23 CD 49 FD     LDFLEX:     call    CF_STANDBY      ; set CF into stand-by mode
1504+ FA26 AF                       xor     A               ; clear Carry flag
1505+ FA27 C9                       ret                     ; return to caller
1506+ FA28
1507+ FA28
1508+ FA28              ; *****************************************************************************
1509+ FA28              ; F I L E    E R A S E
1510+ FA28              ; erase a file from disk, freeing its block
1511+ FA28              ; *****************************************************************************
1512+ FA28 CD 6F FB     FIL_ERASE:  call    CHKSQFL         ; check if a seq. file is open
1513+ FA2B C2 1D F6                 jp      NZ,FILOPCLER    ; jump if open
1514+ FA2E CD A4 FC                 call    CLRIOBF         ; clear I/O
1515+ FA31 CD 08 FC                 call    CHKDSKVAL       ; check DOS version & load disk details
1516+ FA34 DA 35 F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
1517+ FA37 CD 63 F9                 call    LK4FILE         ; look for given file
1518+ FA3A D2 2F F6                 jp      NC,FLNTFND      ; file not found - error
1519+ FA3D DD 5E 14                 ld      E,(IX+$14)      ; load MSW into DE
1520+ FA40 DD 56 15                 ld      D,(IX+$15)
1521+ FA43 DD 4E 16                 ld      C,(IX+$16)      ; load LSW into BC
1522+ FA46 DD 46 17                 ld      B,(IX+$17)
1523+ FA49 ED 53 47 55              ld      (MSW_SCT),DE    ; store DE
1524+ FA4D ED 43 49 55              ld      (LSW_SCT),BC    ; store BC
1525+ FA51 DD 7E 1A                 ld      A,(IX+$1A)      ; load size in sectors
1526+ FA54 32 46 55                 ld      (SCT_SIZ),A     ; store it
1527+ FA57 3E 7F                    ld      A,$7F           ; marker for file deleted
1528+ FA59 DD 77 00                 ld      (IX),A          ; set file as deleted (quick erase)
1529+ FA5C 3A 53 55                 ld      A,(TPBF4)       ; check for quick or full delete
1530+ FA5F B7                       or      A               ; A=0 quick erase
1531+ FA60 28 0A                    jr      Z,FIL_ERA5      ; jump if quick erase
1532+ FA62 AF                       xor     A               ; clear A
1533+ FA63 06 20                    ld      B,$20           ; full erase - clean entry (32 cells)
1534+ FA65 DD 77 00     FIL_ERA6:   ld      (IX),A          ; reset cell
1535+ FA68 DD 23                    inc     IX              ; next cell
1536+ FA6A 10 F9                    djnz    FIL_ERA6        ; repeat
1537+ FA6C ED 5B 4F 55  FIL_ERA5:   ld      DE,(TPBF2)      ; retrieve MSW of current directory sector
1538+ FA70 ED 4B 51 55              ld      BC,(TPBF3)      ; retrieve LSW of current directory sector
1539+ FA74 CD 7C FD                 call    CF_WR_SEC       ; write sector
1540+ FA77 38 27                    jr      C,WRT_ERR       ; error?
1541+ FA79 3A 53 55                 ld      A,(TPBF4)       ; check for quick or full delete
1542+ FA7C B7                       or      A               ; if A=0 then quick erase
1543+ FA7D 28 1C                    jr      Z,FIL_ERA3      ; yes, leave
1544+ FA7F CD A4 FC                 call    CLRIOBF         ; no, full delete - clear I/O buffer
1545+ FA82 ED 5B 47 55              ld      DE,(MSW_SCT)    ; load MSW of 1st sector of file block
1546+ FA86 ED 4B 49 55              ld      BC,(LSW_SCT)    ; load LSW of 1st sector of file block
1547+ FA8A 21 46 55                 ld      HL,SCT_SIZ      ; pointer to size in sectors
1548+ FA8D CD 7C FD     FIL_ERA1:   call    CF_WR_SEC       ; erase sector
1549+ FA90 38 0E                    jr      C,WRT_ERR       ; error?
1550+ FA92 03                       inc     BC              ; next sector
1551+ FA93 78                       ld      A,B             ; is LSW rolled back to 0?
1552+ FA94 B1                       or      C
1553+ FA95 20 01                    jr      NZ,FIL_ERA2     ; no, jump over
1554+ FA97 13                       inc     DE              ; yes, increment MSW
1555+ FA98 35           FIL_ERA2:   dec     (HL)            ; decrement sector counter
1556+ FA99 20 F2                    jr      NZ,FIL_ERA1     ; repeat if other sectors
1557+ FA9B CD 49 FD     FIL_ERA3:   call    CF_STANDBY      ; set CF into stand-by mode
1558+ FA9E AF                       xor     A               ; clear Carry
1559+ FA9F C9                       ret
1560+ FAA0 CD 49 FD     WRT_ERR:    call    CF_STANDBY      ; put CF into stand-by
1561+ FAA3 37                       scf                     ; set error
1562+ FAA4 C9                       ret                     ; return to caller
1563+ FAA5
1564+ FAA5
1565+ FAA5              ; *****************************************************************************
1566+ FAA5              ; F I L E    C H E C K
1567+ FAA5              ; check if file name already exists in directory
1568+ FAA5              ; file name must be stored from DOSBFR   for 16 chars
1569+ FAA5              ; *****************************************************************************
1570+ FAA5 FD 2A 42 55  FILE_EXIST: ld      IY,(NTR_NBR)    ; load max entries
1571+ FAA9 CD 74 FB                 call    SETPTEN         ; point to 1st sector of dir
1572+ FAAC CD 7C FB     CHKSTNM1:   call    PT2FSEN         ; point to 1st entry of a dir's sect
1573+ FAAF CD 87 FB     CHKSTNM2:   call    CKCREN          ; check current entry
1574+ FAB2 28 28                    jr      Z,CHKSTNM10     ; if empty or deleted, jump over
1575+ FAB4 22 4D 55                 ld      (TPBF1),HL      ; store HL
1576+ FAB7 ED 53 4F 55              ld      (TPBF2),DE      ; store DE
1577+ FABB ED 43 51 55              ld      (TPBF3),BC      ; store BC
1578+ FABF DD E5                    push    IX              ; copy IX...
1579+ FAC1 E1                       pop     HL              ; ...into HL
1580+ FAC2 11 A0 FD                 ld      DE,DOSBFR       ; beginning of name file
1581+ FAC5 06 10                    ld      B,$10           ; 16 chars to check
1582+ FAC7 1A           CHKSTNM3:   ld      A,(DE)          ; load a char from name on disk
1583+ FAC8 ED A1                    cpi                     ; compare with name from user
1584+ FACA 20 05                    jr      NZ,CHKSTNM6     ; chars are different, leave
1585+ FACC 13                       inc     DE              ; inc DE (HL is incremented by "cpi")
1586+ FACD 10 F8                    djnz    CHKSTNM3        ; repeat for 16 chars
1587+ FACF 18 17                    jr      FLEXST          ; file exists in dir
1588+ FAD1 2A 4D 55     CHKSTNM6:   ld      HL,(TPBF1)      ; retrieve HL
1589+ FAD4 ED 5B 4F 55              ld      DE,(TPBF2)      ; retrieve DE
1590+ FAD8 ED 4B 51 55              ld      BC,(TPBF3)      ; retrieve sector counter
1591+ FADC CD 8F FB     CHKSTNM10:  call    GTNXTEN         ; other entries in this sector?
1592+ FADF 20 CE                    jr      NZ,CHKSTNM2     ; yes, continue check
1593+ FAE1 CD 9B FB                 call    CKLSTEN         ; go to next sector
1594+ FAE4 30 C6                    jr      NC,CHKSTNM1     ; more entries? repeat
1595+ FAE6 AF                       xor     A               ; file not found, reset Carry
1596+ FAE7 C9                       ret                     ; return
1597+ FAE8 37           FLEXST:     scf                     ; file is present - set Carry flag for error
1598+ FAE9 C9                       ret
1599+ FAEA
1600+ FAEA
1601+ FAEA              ; *****************************************************************************
1602+ FAEA              ; UNDELETE DELETED FILES
1603+ FAEA              ; look for deleted files and undelete them
1604+ FAEA              ; *****************************************************************************
1605+ FAEA CD A4 FC     DSKUNDFL:   call    CLRIOBF         ; clear I/O
1606+ FAED CD 08 FC                 call    CHKDSKVAL       ; check DOS version & load disk details
1607+ FAF0 DA 35 F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
1608+ FAF3 CD 37 FB                 call    FNDFRENTR       ; find a free entry
1609+ FAF6 D8           DSKUNDFL1:  ret     C               ; return if entries are finished
1610+ FAF7 DD 7E 00                 ld      A,(IX)          ; reload first char of entry
1611+ FAFA FE 7F                    cp      $7F             ; is it a deleted entry?
1612+ FAFC 20 29                    jr      NZ,DSKUNDFL2    ; no, jump over
1613+ FAFE CD DF FB                 call    RND8            ; get a random char
1614+ FB01 CD FD FB                 call    CHATOZ          ; transform it into a letter
1615+ FB04 DD 77 00                 ld      (IX),A          ; store it as the first letter of filename
1616+ FB07 CD 7C FD                 call    CF_WR_SEC       ; write sector (address is into DEBC)
1617+ FB0A E5                       push    HL              ; store HL
1618+ FB0B C5                       push    BC              ; store BC
1619+ FB0C D5                       push    DE              ; store DE
1620+ FB0D DD E5                    push    IX              ; copy IX...
1621+ FB0F E1                       pop     HL              ; ...into HL
1622+ FB10 06 10                    ld      B,$10           ; 16 chars
1623+ FB12 7E           DSKUNDPR:   ld      A,(HL)          ; retrieve char from filename
1624+ FB13 CD 59 1B                 call    OUTC            ; print char
1625+ FB16 23                       inc     HL              ; next char
1626+ FB17 10 F9                    djnz    DSKUNDPR        ; repeat
1627+ FB19 3E 20                    ld      A,SPC           ; print a space
1628+ FB1B CD 59 1B                 call    OUTC
1629+ FB1E 21 2C FB                 ld      HL,DSKUNDTXT    ; print undeleted message
1630+ FB21 CD 30 27                 call    PRS
1631+ FB24 D1                       pop     DE              ; retrieve DE
1632+ FB25 C1                       pop     BC              ; retrieve BC
1633+ FB26 E1                       pop     HL              ; retrieve HL
1634+ FB27 CD 4B FB     DSKUNDFL2:  call    FNDFRENTR4      ; goto next entry
1635+ FB2A 18 CA                    jr      DSKUNDFL1       ; repeat
1636+ FB2C 75 6E 64 65  DSKUNDTXT:  defb    "undeleted",CR,0
1636+ FB30 6C 65 74 65
1636+ FB34 64 0D 00
1637+ FB37
1638+ FB37
1639+ FB37              ; *****************************************************************************
1640+ FB37              ; FIND A FREE ENTRY
1641+ FB37              ; find a free entry in the directory to store a new file
1642+ FB37              ; *****************************************************************************
1643+ FB37 CD BC FB     FNDFRENTR:  call    LDMSCT          ; read Master Sector
1644+ FB3A CD AD FB                 call    LDENTRIES       ; load entries into RAM register NTR_NBR and DE
1645+ FB3D D5                       push    DE              ; copy number of entries...
1646+ FB3E FD E1                    pop     IY              ; ...into IY
1647+ FB40 CD 74 FB                 call    SETPTEN         ; point to first entry
1648+ FB43 CD 7C FB     FNDFRENTR1: call    PT2FSEN         ; point to 1st entry of sector
1649+ FB46 CD 87 FB     FNDFRENTR2: call    CKCREN          ; check current entry
1650+ FB49 28 0B                    jr      Z,FNDFRENTR3    ; found a free entry
1651+ FB4B CD 8F FB     FNDFRENTR4: call    GTNXTEN         ; other entries in this sector?
1652+ FB4E 20 F6                    jr      NZ,FNDFRENTR2   ; yes, continue check
1653+ FB50 CD 9B FB                 call    CKLSTEN         ; go to next sector
1654+ FB53 30 EE                    jr      NC,FNDFRENTR1   ; more entries? repeat
1655+ FB55 C9                       ret                     ; entries finished - leave
1656+ FB56 ED 43 40 55  FNDFRENTR3: ld      (DIR_SCT),BC    ; store sector of dir
1657+ FB5A 22 42 55                 ld      (NTR_NBR),HL    ; store entry number
1658+ FB5D AF                       xor     A               ; reset Carry
1659+ FB5E C9                       ret
1660+ FB5F
1661+ FB5F
1662+ FB5F              ; *****************************************************************************
1663+ FB5F              ;   U T I L I T I E S
1664+ FB5F              ; *****************************************************************************
1665+ FB5F
1666+ FB5F
1667+ FB5F              ; check if EOF for seq. file
1668+ FB5F              ; C is set if EOF, NC otherwise
1669+ FB5F              ; destroys DE & HL
1670+ FB5F              ; return: DE=size of seq. file; C=1 if EOF, C=0 otherwise
1671+ FB5F ED 5B DB FF  CHKEOF:     ld      DE,(SEQBYSZ)    ; size of seq. file
1672+ FB63 7B                       ld      A,E             ; check if file size...
1673+ FB64 B2                       or      D               ; ...is 0
1674+ FB65 28 06                    jr      Z,CHKEOFC       ; yes, EOF
1675+ FB67 2A DD FF                 ld      HL,(SEQPNT)     ; pointer to last byte of seq. file
1676+ FB6A CD 61 41                 call    CMP16           ; over the EOF?
1677+ FB6D 3F           CHKEOFC:    ccf                     ; invert Carry
1678+ FB6E C9                       ret
1679+ FB6F
1680+ FB6F
1681+ FB6F              ; check if a sequential file is open
1682+ FB6F 3A D4 FF     CHKSQFL:    ld      A,(SEQFL)       ; seq. file status
1683+ FB72 B7                       or      A               ; if A<>0 then a file is open
1684+ FB73 C9                       ret                     ; return to caller
1685+ FB74
1686+ FB74
1687+ FB74              ; set up registers to point to first sector of directory
1688+ FB74 01 01 00     SETPTEN:    ld      BC,$0001        ; BC=$0001 (starting sector of dir) (LSW)
1689+ FB77 50                       ld      D,B             ; DE=$0000 (starting sector of dir) (MSW)
1690+ FB78 58                       ld      E,B
1691+ FB79 60                       ld      H,B             ; HL=$0000 (entry counter)
1692+ FB7A 68                       ld      L,B
1693+ FB7B C9                       ret                     ; return to caller
1694+ FB7C
1695+ FB7C
1696+ FB7C              ; load a sector and point to first entry
1697+ FB7C CD 13 FD     PT2FSEN:    call    CF_SETSTR       ; set sector to read (BC-DE)
1698+ FB7F CD 55 FD                 call    CF_RD_SEC       ; read sector
1699+ FB82 DD 21 C0 FD              ld      IX,IOBUFF       ; beginning of I/O buffer
1700+ FB86 C9                       ret
1701+ FB87
1702+ FB87
1703+ FB87              ; check current entry
1704+ FB87 DD 7E 00     CKCREN:     ld      A,(IX)          ; load 1st char of entry name
1705+ FB8A                          ;dec     IY              ; decrement number of entries
1706+ FB8A B7                       or      A               ; is it $00 (empty entry)?
1707+ FB8B C8                       ret     Z               ; yes, found an entry
1708+ FB8C FE 7F                    cp      $7F             ; is it $7F (deleted entry)?
1709+ FB8E C9                       ret
1710+ FB8F
1711+ FB8F
1712+ FB8F              ; goto next entry
1713+ FB8F C5           GTNXTEN:    push    BC              ; store BC
1714+ FB90 01 20 00                 ld      BC,$0020        ; load BC with directory entry size (32 bytes)
1715+ FB93 DD 09                    add     IX,BC           ; next entry in current sector
1716+ FB95 C1                       pop     BC              ; retrieve sector pointer
1717+ FB96 23                       inc     HL              ; increment entry counter
1718+ FB97 7D                       ld      A,L
1719+ FB98 E6 0F                    and     %00001111       ; just done 16 entries?
1720+ FB9A C9                       ret
1721+ FB9B
1722+ FB9B
1723+ FB9B              ; check if reached last entry
1724+ FB9B              ; Carry is set if entries finished
1725+ FB9B 03           CKLSTEN:    inc     BC              ; entries in this sector finished .. goto next sector
1726+ FB9C 78                       ld      A,B             ; check if...
1727+ FB9D B1                       or      C               ; ...BC=$000
1728+ FB9E 20 01                    jr      NZ,CKLSTEN1     ; no, jump over
1729+ FBA0 13                       inc     DE              ; yes, increment DE (MSW)
1730+ FBA1 E5           CKLSTEN1:   push    HL              ; preserve current entry
1731+ FBA2 D5                       push    DE
1732+ FBA3 FD E5                    push    IY              ; copy max allowed files...
1733+ FBA5 D1                       pop     DE              ; ...into HL
1734+ FBA6 CD 61 41                 call    CMP16           ; check if reached max allowed entries
1735+ FBA9 D1                       pop     DE
1736+ FBAA E1                       pop     HL              ; (retrieve current entry)
1737+ FBAB 3F                       ccf
1738+ FBAC C9                       ret                     ; return
1739+ FBAD
1740+ FBAD
1741+ FBAD              ; load entries intro RAM register
1742+ FBAD 21 C0 FD     LDENTRIES:  ld      HL,IOBUFF       ; start of I/O buffer
1743+ FBB0 01 19 00                 ld      BC,$0019        ; point to max. allowed entries
1744+ FBB3 09                       add     HL,BC           ; get address
1745+ FBB4 CD 6D FC                 call    HL2DE           ; get entries into DE
1746+ FBB7 ED 53 42 55              ld      (NTR_NBR),DE    ; store
1747+ FBBB C9                       ret                     ; return to caller
1748+ FBBC
1749+ FBBC
1750+ FBBC              ; load Master Sector (sector #0)
1751+ FBBC 01 00 00     LDMSCT:     ld      BC,$0000        ; LSW of sector
1752+ FBBF 50                       ld      D,B             ; MSW of sector
1753+ FBC0 58                       ld      E,B
1754+ FBC1 CD 13 FD                 call    CF_SETSTR       ; set sector
1755+ FBC4 CD 55 FD                 call    CF_RD_SEC       ; read sector
1756+ FBC7 C9                       ret
1757+ FBC8
1758+ FBC8
1759+ FBC8              ; generate random disk ID
1760+ FBC8 C5           RND_ID:     push    BC
1761+ FBC9 06 02                    ld      B,$02           ; repeat 2 times
1762+ FBCB CD DF FB     RND_ID1:    call    RND8            ; get a random value
1763+ FBCE CD FD FB                 call    CHATOZ          ; transform it into a letter
1764+ FBD1 12                       ld      (DE),A          ; store it
1765+ FBD2 13                       inc     DE              ; inc pointer
1766+ FBD3 CD DF FB                 call    RND8            ; get a random value
1767+ FBD6 CD F2 FB                 call    CH0TO9          ; transform it into a number from 0 to 9
1768+ FBD9 12                       ld      (DE),A          ; store it
1769+ FBDA 13                       inc     DE              ; inc pointer
1770+ FBDB 10 EE                    djnz    RND_ID1         ; repeat
1771+ FBDD C1                       pop     BC
1772+ FBDE C9                       ret                     ; return to caller
1773+ FBDF
1774+ FBDF
1775+ FBDF              ; generate a pseudo-random number using TMR and R registers
1776+ FBDF C5           RND8:       push    BC              ; store B
1777+ FBE0 3A 85 55                 ld      A,(TMRCNT)      ; load LSW of sys-timer
1778+ FBE3 47                       ld      B,A             ; copy into B
1779+ FBE4 ED 5F                    ld      A,R             ; load refresh register
1780+ FBE6 A8                       xor     B               ; A xor B
1781+ FBE7 47                       ld      B,A             ; copy into B
1782+ FBE8 0F                       rrca                    ; multiply by 32
1783+ FBE9 0F                       rrca
1784+ FBEA 0F                       rrca
1785+ FBEB EE 1F                    xor     $1F             ; a XOR to mix bits
1786+ FBED 80                       add     A,B             ; add B
1787+ FBEE DE FF                    sbc     A,255           ; carry
1788+ FBF0 C1                       pop     BC              ; retrieve B
1789+ FBF1 C9                       ret                     ; return to caller
1790+ FBF2
1791+ FBF2
1792+ FBF2              ; char ported into 0-9 interval
1793+ FBF2 E6 0F        CH0TO9:     and     %00001111       ; get only low nibble
1794+ FBF4 FE 0A                    cp      $0A             ; is it < 10?
1795+ FBF6 38 02                    jr      C,CH0TO9E       ; yes, jump over
1796+ FBF8 D6 0A                    sub     $0A             ; subract 10
1797+ FBFA C6 30        CH0TO9E:    add     $30             ; get a number from 0 to 9
1798+ FBFC C9                       ret
1799+ FBFD
1800+ FBFD
1801+ FBFD              ; char ported into A-Z interval
1802+ FBFD E6 1F        CHATOZ:     and     %00011111       ; get only first 5 bits
1803+ FBFF FE 1A                    cp      $1A             ; is it < 26?
1804+ FC01 38 02                    jr      C,CHATOZE       ; yes, jump over
1805+ FC03 D6 1A                    sub     $1A             ; no, subtract 26
1806+ FC05 C6 41        CHATOZE:    add     $41             ; get a letter from 'A' to 'Z'
1807+ FC07 C9                       ret                     ; return to caller
1808+ FC08
1809+ FC08
1810+ FC08              ; first check DOS validity then load disk details
1811+ FC08 CD D1 FC     CHKDSKVAL:  call    CF_INIT         ; open CF card comm.
1812+ FC0B D8                       ret     C               ; if errors, leave
1813+ FC0C C5                       push    BC              ; store BC
1814+ FC0D D5                       push    DE              ; store DE
1815+ FC0E E5                       push    HL              ; store HL
1816+ FC0F 01 00 00                 ld      BC,$0000        ; reset LSW of sector
1817+ FC12 50                       ld      D,B             ; reset MSW of sector
1818+ FC13 58                       ld      E,B
1819+ FC14 CD 13 FD                 call    CF_SETSTR       ; set sector #0
1820+ FC17 CD 55 FD                 call    CF_RD_SEC       ; read sector
1821+ FC1A 21 C0 FD                 ld      HL,IOBUFF       ; address of default conf. buffer
1822+ FC1D 11 0A 00                 ld      DE,$000A        ; point to disk DOS version
1823+ FC20 19                       add     HL,DE
1824+ FC21 11 2F EE                 ld      DE,DSKHDR+10    ; get starting address of I/O buffer
1825+ FC24 06 04                    ld      B,$04           ; 4 chars
1826+ FC26 1A           CHKDSKVAL1: ld      A,(DE)          ; load char from DOS version into memory
1827+ FC27 BE                       cp      (HL)            ; compare with disk DOS version
1828+ FC28 20 11                    jr      NZ,CHKDSKVALE   ; no match - so error
1829+ FC2A 13                       inc     DE              ; next source
1830+ FC2B 23                       inc     HL              ; next comparison
1831+ FC2C 10 F8                    djnz    CHKDSKVAL1      ; repeat
1832+ FC2E 21 A0 FD                 ld      HL,DOSBFR       ; address of default conf. buffer
1833+ FC31 11 1D 00                 ld      DE,$001D        ; point to address of data area
1834+ FC34 19                       add     HL,DE           ; set pointer to beginning of identifies
1835+ FC35 CD 6D FC                 call    HL2DE           ; first sector of data area into DE
1836+ FC38 AF                       xor     A               ; no error - clear Carry flag
1837+ FC39 18 01                    jr      CHKDSKVAL2      ; jump over
1838+ FC3B 37           CHKDSKVALE: scf                     ; error - set carry flag
1839+ FC3C E1           CHKDSKVAL2: pop     HL
1840+ FC3D D1                       pop     DE
1841+ FC3E C1                       pop     BC
1842+ FC3F C9                       ret                     ; return to caller
1843+ FC40
1844+ FC40
1845+ FC40              ; check name validity (only allowed chars) and copy it from string pool into a temp buff
1846+ FC40              ; Inputs: DE: pointer to dest. buffer
1847+ FC40              ; operation: copy (HL)->(DE) and pads to get a 16-chars name
1848+ FC40              ; destroys: A, BC, DE, HL
1849+ FC40 ED 4B A9 55  CHKNMVAL:   ld      BC,(DKLNPT)     ; load lenght of name
1850+ FC44 79                       ld      A,C             ; lenght is max. 16 char, so we only check C
1851+ FC45 FE 11                    cp      $11             ; is it <=16?
1852+ FC47 38 02                    jr      C,CHKNMVAL1     ; yes, so jump over
1853+ FC49 0E 10                    ld      C,$10           ; no, get only 16 chars
1854+ FC4B 41           CHKNMVAL1:  ld      B,C             ; copy lenght into B
1855+ FC4C 0E 10                    ld      C,$10           ; char counter
1856+ FC4E 2A A7 55                 ld      HL,(DKNMPT)     ; pointer to name
1857+ FC51 7E           CHKNMVAL2:  ld      A,(HL)          ; get a char from string name
1858+ FC52 CD 8E FC                 call    CHK_NAM         ; check if valid
1859+ FC55 D8                       ret     C               ; no, name error
1860+ FC56 12                       ld      (DE),A          ; yes, store char
1861+ FC57 13                       inc     DE              ; next I/O location
1862+ FC58 23                       inc     HL              ; next name char
1863+ FC59 0D                       dec     C               ; decrement number of chars copied
1864+ FC5A 10 F5                    djnz    CHKNMVAL2       ; repeat until name ends
1865+ FC5C 79                       ld      A,C             ; check if there are no empty chars in file
1866+ FC5D B7                       or      A
1867+ FC5E C8                       ret     Z               ; yes, job finished - return
1868+ FC5F 3E 20                    ld      A,SPC           ; no, padding required
1869+ FC61 12           CHKNMVAL3:  ld      (DE),A          ; store char
1870+ FC62 13                       inc     DE              ; next location
1871+ FC63 0D                       dec     C               ; check if padding is over
1872+ FC64 20 FB                    jr      NZ,CHKNMVAL3    ; no, continue
1873+ FC66 AF                       xor     A               ; clear Carry flag
1874+ FC67 C9                       ret                     ; return to caller
1875+ FC68
1876+ FC68
1877+ FC68              ; store DE into (HL) and (HL+1)
1878+ FC68 73           DE2HL:      ld      (HL),E          ; LSW of size
1879+ FC69 23                       inc     HL
1880+ FC6A 72                       ld      (HL),D          ; MSW of size
1881+ FC6B 23                       inc     HL
1882+ FC6C C9                       ret                     ; return to caller
1883+ FC6D
1884+ FC6D
1885+ FC6D              ; get DE from (HL) and (HL+1)
1886+ FC6D 5E           HL2DE:      ld      E,(HL)          ; get LSW into E
1887+ FC6E 23                       inc     HL              ; next location
1888+ FC6F 56                       ld      D,(HL)          ; get MSW into D
1889+ FC70 23                       inc     HL              ; next location
1890+ FC71 C9                       ret                     ; return to caller
1891+ FC72
1892+ FC72
1893+ FC72              ; convert a 16/32-bit number into an ASCII string and print it
1894+ FC72              ; inputs: HL pointer to 32-bit number
1895+ FC72 CD 6D FC     PRN32ASCII: call    HL2DE           ; load MSW into DE  <-- entry for 32-bit
1896+ FC75 4E           PRN16ASCII: ld      C,(HL)          ; load LSW into BC   <-- entry for 16-bit (set DE to $0000 before to call)
1897+ FC76 23                       inc     HL
1898+ FC77 46                       ld      B,(HL)
1899+ FC78 C5                       push    BC              ; copy BC...
1900+ FC79 DD E1                    pop     IX              ; ...into IX
1901+ FC7B FD 21 4D 55  PRN16ASCIX: ld      IY,TPBF1        ; number is into DEIX - now, load pointer to destination buffer
1902+ FC7F CD 2A 42                 call    CLCN32          ; convert number in DEIX into ASCII number
1903+ FC82 21 4D 55                 ld      HL,TPBF1        ; address of ASCII number
1904+ FC85 7E           PRNTSIZ:    ld      A,(HL)          ; get a char
1905+ FC86 B7                       or      A               ; is it $00 (end of string)?
1906+ FC87 C8                       ret     Z               ; yes, leave
1907+ FC88 CD 59 1B                 call    OUTC            ; no, print char
1908+ FC8B 23                       inc     HL              ; next char
1909+ FC8C 18 F7                    jr      PRNTSIZ         ; repeat
1910+ FC8E
1911+ FC8E
1912+ FC8E              ; check for non-allowed chars in disk/file names - allowed chars: '0'-'9', 'A'-'Z', '-', SPACE
1913+ FC8E              ; input: A -> char to check
1914+ FC8E              ; return: C is set if ERROR, reset otherwise
1915+ FC8E FE 20        CHK_NAM:    cp      SPC             ; is it a space?
1916+ FC90 C8                       ret     Z               ; return if equal (C is reset)
1917+ FC91 FE 2D                    cp      '-'             ; is it a minus?
1918+ FC93 C8                       ret     Z               ; return if equal
1919+ FC94 FE 30                    cp      '0'             ; char < '0' ?
1920+ FC96 D8                       ret     C               ; yes, disk name error
1921+ FC97 FE 3A                    cp      ':'             ; is char <= '9' ?
1922+ FC99 38 07                    jr      C,CHK_C_CF      ; yes, leave
1923+ FC9B E6 5F                    and     %01011111       ; for letters, only UPPER CASE
1924+ FC9D FE 41                    cp      'A'             ; is char >= 'A' ?
1925+ FC9F D8                       ret     C               ; no, error
1926+ FCA0 FE 5B                    cp      '['             ; is char <= 'Z' ? (if yes, C=1, then C=0; otherwise, C=0 then C=1)
1927+ FCA2 3F           CHK_C_CF:   ccf                     ; Carry complement (invert Carry)
1928+ FCA3 C9                       ret                     ; return to caller
1929+ FCA4
1930+ FCA4
1931+ FCA4              ; clear I/O buffer
1932+ FCA4 F5           CLRIOBF:    push    AF              ; store AF
1933+ FCA5 C5                       push    BC              ; store BC
1934+ FCA6 E5                       push    HL              ; store HL
1935+ FCA7 21 C0 FD                 ld 	    HL,IOBUFF       ; load address of I/O buffer
1936+ FCAA 01 02 00                 ld      BC,$0002        ; B=256 iterations ($00); C=repeat 2 times
1937+ FCAD AF           CLRBUFF:    xor     A               ; reset A   ----- common part -----
1938+ FCAE 77           RSTIOBF:    ld      (HL),A          ; reset cell
1939+ FCAF 23                       inc     HL              ; next cell
1940+ FCB0 10 FC                    djnz    RSTIOBF         ; repeat for 256 times
1941+ FCB2 0D                       dec     C               ; decrement C
1942+ FCB3 20 F9                    jr      NZ,RSTIOBF      ; repeat if not zero
1943+ FCB5 E1                       pop     HL              ; retrieve HL
1944+ FCB6 C1                       pop     BC              ; retrieve BC
1945+ FCB7 F1                       pop     AF              ; retrieve AF
1946+ FCB8 C9                       ret                     ; return to caller
1947+ FCB9
1948+ FCB9
1949+ FCB9              ; clear DOS buffer
1950+ FCB9 F5           CLRDOSBF:   push    AF              ; store AF
1951+ FCBA C5                       push    BC              ; store BC
1952+ FCBB E5                       push    HL              ; store HL
1953+ FCBC 21 A0 FD                 ld 	    HL,DOSBFR       ; load address of DOS buffer
1954+ FCBF 01 01 20                 ld      BC,$2001        ; B=32 iterations; C=repeat 1 time
1955+ FCC2 C3 AD FC                 jp      CLRBUFF         ; continue to common part
1956+ FCC5
1957+ FCC5
1958+ FCC5              ; clear seq. file buffer
1959+ FCC5 F5           CLRSEQBF:   push    AF              ; store AF
1960+ FCC6 C5                       push    BC              ; store BC
1961+ FCC7 E5                       push    HL              ; store HL
1962+ FCC8 21 D4 FF                 ld 	    HL,SEQFL        ; load address of DOS buffer
1963+ FCCB 01 01 0B                 ld      BC,$0B01        ; B=11 iterations; C=repeat 1 time
1964+ FCCE C3 AD FC                 jp      CLRBUFF         ; continue to common part
1965+ FCD1
# file closed: ../include/dos/dos-1.06.asm
  95  FCD1                  INCLUDE "../include/dos/bios-1.03.asm"
# file opened: ../include/dos/bios-1.03.asm
   1+ FCD1              ; ------------------------------------------------------------------------------
   2+ FCD1              ; LM80C 64K - BIOS ROUTINES - R1.03
   3+ FCD1              ; ------------------------------------------------------------------------------
   4+ FCD1              ; The following code is intended to be used with LM80C Z80-based computer
   5+ FCD1              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ FCD1              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ FCD1              ; kind of warranty: you can use them at your own risk.
   8+ FCD1              ; You are free to use them for any non-commercial use: you are only asked to
   9+ FCD1              ; maintain the copyright notices, include this advice and the note to the
  10+ FCD1              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ FCD1              ; redistribuite them.
  12+ FCD1              ; https://www.leonardomiliani.com
  13+ FCD1              ;
  14+ FCD1              ; Please support me by visiting the following links:
  15+ FCD1              ; Main project page: https://www.leonardomiliani.com
  16+ FCD1              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ FCD1              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ FCD1              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ FCD1              ; ------------------------------------------------------------------------------
  20+ FCD1              ;
  21+ FCD1              ; ------------------------------------------------------------------------------
  22+ FCD1              ; Code Revision:
  23+ FCD1              ; R1.0  - 20210307 - first release
  24+ FCD1              ; R1.01 - 20210310 - Code optimizing & better error handling
  25+ FCD1              ; R1.02 - 20210316 - disk speed improvements with INIR and OTIR
  26+ FCD1              ; R1.03 - 20210319 - code re-organization and new positioning into RAM
  27+ FCD1              ;
  28+ FCD1              ;------------------------------------------------------------------------------
  29+ FCD1
  30+ FCD1              ; equates for CF at port $50
  31+ FCD1              CF_DATA:        equ %01010000   ; ($50) Data register (R/W)
  32+ FCD1              CF_ERR:         equ %01010001   ; ($51) Error (R)
  33+ FCD1              CF_FTR:         equ %01010001   ; ($51) Features (W)
  34+ FCD1              CF_SECCNT:      equ %01010010   ; ($52) Sector count register (R/W)
  35+ FCD1              CF_LBA0:        equ %01010011   ; ($53) LBA register 0 (bits 0-7) (R/W)
  36+ FCD1              CF_LBA1:        equ %01010100   ; ($54) LBA register 1 (bits 8-15) (R/W)
  37+ FCD1              CF_LBA2:        equ %01010101   ; ($55) LBA register 2 (bits 16-23) (R/W)
  38+ FCD1              CF_LBA3:        equ %01010110   ; ($56) LBA register 3 (bits 24-27) (R/W) - bits 28-31 must be set to 111 in LBA mode
  39+ FCD1              CF_STAT:        equ %01010111   ; ($57) Status (R)
  40+ FCD1              CF_CMD:         equ %01010111   ; ($57) Command register (W)
  41+ FCD1
  42+ FCD1
  43+ FCD1              ;------------------------------------------------------------------------------
  44+ FCD1              ; R O U T I N E S
  45+ FCD1              ;------------------------------------------------------------------------------
  46+ FCD1
  47+ FCD1              BIOSSTART:  equ     $
  48+ FCD1              ; initilialize CF to work with, wakeing it up from standby and setting it to work in 8-bit mode
  49+ FCD1 CD E7 FC     CF_INIT:    call    CF_NOP          ; execute a NOP to wake up the CF
  50+ FCD4 CD 35 FD                 call    CR_DEV_RDY      ; wait for CF available and ready
  51+ FCD7 D8                       ret     C               ; no card or I/O error, leave
  52+ FCD8 3E 01                    ld      A,$01           ; 8-bit mode
  53+ FCDA D3 51                    out     (CF_FTR),A      ; set mode
  54+ FCDC CD F0 FC                 call    CF_BUSY         ; wait for CF being ready
  55+ FCDF 3E EF                    ld      A,$EF           ; command to set mode
  56+ FCE1 D3 57                    out     (CF_CMD),A      ; execute command
  57+ FCE3 CD F0 FC                 call    CF_BUSY         ; wait for CF being ready
  58+ FCE6 C9                       ret                     ; return to caller
  59+ FCE7
  60+ FCE7
  61+ FCE7              ; a NOP command, just used to wake up the CF card
  62+ FCE7 3E 69        CF_NOP:     ld      A,$69           ; NOP command
  63+ FCE9 D3 51                    out     (CF_FTR),A      ; send it
  64+ FCEB 3E EF                    ld      A,$EF           ; set mode command
  65+ FCED D3 57                    out     (CF_CMD),A      ; execute NOP
  66+ FCEF C9                       ret                     ; return to caller
  67+ FCF0
  68+ FCF0
  69+ FCF0              ; wait until BUSY bit is 0 (means CF has executed the requested job)
  70+ FCF0 DB 57        CF_BUSY:    in      A,(CF_STAT)     ; read status register
  71+ FCF2 07                       rlca                    ; copy bit #7 into the Carry
  72+ FCF3 DA F0 FC                 jp      C,CF_BUSY       ; loop while bit #7 is 1
  73+ FCF6 C9                       ret                     ; bit #7 cleared - return to caller
  74+ FCF7
  75+ FCF7
  76+ FCF7              ; check that CF is ready to get commands
  77+ FCF7 DB 57        CF_CMDRDY:  in      A,(CF_STAT)     ; read status register
  78+ FCF9 CB 47                    bit     0,A             ; any error?
  79+ FCFB 20 07                    jr      NZ,RETERR       ; yes, return error
  80+ FCFD E6 C0                    and     %11000000       ; check only bits #6 & #7
  81+ FCFF EE 40                    xor     %01000000       ; bit #7 (BUSY) must be 0 and bit #6 (DRVRDY) must be 1
  82+ FD01 20 F4                    jr      NZ,CF_CMDRDY    ; wait
  83+ FD03 C9                       ret                     ; return to caller
  84+ FD04 37           RETERR:     scf                     ; set carry flag
  85+ FD05 C9                       ret                     ; return
  86+ FD06
  87+ FD06
  88+ FD06              ; wait until data is ready to be read
  89+ FD06 DB 57        CF_DAT_RDY: in      A,(CF_STAT)     ; read status register
  90+ FD08 CB 47                    bit     0,A             ; any error?
  91+ FD0A 20 F8                    jr      NZ,RETERR       ; yes, return error
  92+ FD0C E6 88                    and     %10001000       ; check only bits #7 & #3
  93+ FD0E EE 08                    xor     %00001000       ; bit #7 (BUSY) must be 0 and bit #3 (DRQ) must be 1
  94+ FD10 20 F4                    jr      NZ,CF_DAT_RDY   ; wait until data is ready
  95+ FD12 C9                       ret                     ; return to caller
  96+ FD13
  97+ FD13
  98+ FD13              ; set sector to read from/write to - sector number is into DEBC (C=LSB, D=MSB)
  99+ FD13 CD F7 FC     CF_SETSTR:  call    CF_CMDRDY       ; Make sure drive is ready for command
 100+ FD16 3E 01                    ld      A,$01           ; 1 sector at a time
 101+ FD18 D3 52                    out     (CF_SECCNT),A   ; set number of sectors
 102+ FD1A CD F7 FC                 call    CF_CMDRDY       ; Make sure drive is ready for command
 103+ FD1D 79                       ld      A,C             ; load LBA0 byte
 104+ FD1E D3 53                    out     (CF_LBA0),A     ; send it
 105+ FD20 CD F7 FC                 call    CF_CMDRDY       ; Make sure drive is ready for command
 106+ FD23 78                       ld      A,B             ; load LBA1 byte
 107+ FD24 D3 54                    out     (CF_LBA1),A     ; send it
 108+ FD26 CD F7 FC                 call    CF_CMDRDY       ; Make sure drive is ready for command
 109+ FD29 7B                       ld      A,E             ; load LBA2 byte
 110+ FD2A D3 55                    out     (CF_LBA2),A     ; send it
 111+ FD2C CD F7 FC                 call    CF_CMDRDY       ; Make sure drive is ready for command
 112+ FD2F 3E E0                    ld      A,$E0           ; load LBA3 byte+master+LBA addressing
 113+ FD31 B2                       or      D               ; add LBA sector
 114+ FD32 D3 56                    out     (CF_LBA3),A     ; send it
 115+ FD34 C9                       ret                     ; return to caller
 116+ FD35
 117+ FD35
 118+ FD35              ; check if device is available & ready - try a bit of times, then exit with
 119+ FD35              ; error if no response, otherwise wait until device is ready
 120+ FD35              ; return Carry = 0 if device is available and ready, Carry = 1 if errors
 121+ FD35 C5           CR_DEV_RDY: push    BC              ; store HL
 122+ FD36 06 00                    ld      B,$00           ; 256 tries
 123+ FD38 0E 57                    ld      C,CF_STAT       ; address of status register
 124+ FD3A ED 78        CR_DV_RD_1: in      A,(C)           ; load status register (curiously, with no CF attached, in(CF_STAT) returns %01111000)
 125+ FD3C FE 40                    cp      %01000000       ; busy=0, rdy=1
 126+ FD3E 28 07                    jr      Z,CR_DV_RD_E    ; got a response, so leave
 127+ FD40 FE 50                    cp      %01010000       ; busy=0, rdy=1, dsc=1
 128+ FD42 28 03                    jr      Z,CR_DV_RD_E    ; got a response, so leave
 129+ FD44 10 F4                    djnz    CR_DV_RD_1      ; repeat until timeout (Carry=1 while HL<DE)
 130+ FD46 37                       scf                     ; exit with Carry = 1 (device NOT ready)
 131+ FD47 C1           CR_DV_RD_E: pop     BC              ; retrieve HL
 132+ FD48 C9                       ret                     ; return to caller
 133+ FD49
 134+ FD49
 135+ FD49              ; put the CF into stand-by mode
 136+ FD49 3E E0        CF_STANDBY: ld 	    A,$E0   		; select CF as master, driver 0, LBA mode (bits #5-7=111)
 137+ FD4B D3 56                    out 	(CF_LBA3),A     ; send configuration
 138+ FD4D 3E 92                    ld      A,$92           ; standby mode
 139+ FD4F D3 57                    out     (CF_CMD),A      ; send command
 140+ FD51 CD F0 FC                 call    CF_BUSY         ; wait for CF being ready
 141+ FD54 C9                       ret                     ; return to caller
 142+ FD55
 143+ FD55
 144+ FD55              ;***************************************************************************
 145+ FD55              ; CF_RD_SEC
 146+ FD55              ; Function: load a sector (512 bytes) into RAM buffer.
 147+ FD55              ;***************************************************************************
 148+ FD55 CD F7 FC     CF_RD_SEC:  call    CF_CMDRDY       ; Make sure drive is ready for command
 149+ FD58 D8                       ret     C               ; return if error
 150+ FD59 3E 20                    ld      A,$20           ; Prepare read command
 151+ FD5B D3 57                    out     (CF_CMD),A      ; Send read command
 152+ FD5D CD 06 FD                 call    CF_DAT_RDY      ; Wait until data is ready to be read
 153+ FD60 D8                       ret     C               ; return if error
 154+ FD61 DB 57                    in      A,(CF_STAT)     ; Read status
 155+ FD63 E6 01                    and     %00000001       ; mask off error bit
 156+ FD65 C2 55 FD                 jp      NZ,CF_RD_SEC    ; Try again if error
 157+ FD68              ; read CF buffer after it's been filled up by a previous command
 158+ FD68              ; and store data into the I/O buffer
 159+ FD68 C5           CF_RD_CMD:  push    BC              ; store BC
 160+ FD69 E5                       push    HL              ; store HL
 161+ FD6A CD 06 FD                 call    CF_DAT_RDY	    ; wait for data from CF to be ready
 162+ FD6D 38 0A                    jr      C,CF_RD_EXIT    ; if error, leave
 163+ FD6F 01 50 00                 ld      BC,CF_DATA      ; set 256 bytes per loop (B=$00) and CF port (C=CF_DATA)
 164+ FD72 21 C0 FD                 ld      HL,IOBUFF       ; get starting address of I/O buffer
 165+ FD75 ED B2                    inir                    ; get 256 bytes
 166+ FD77 ED B2                    inir                    ; get 256 bytes
 167+ FD79 E1           CF_RD_EXIT: pop     HL              ; retrieve HL
 168+ FD7A C1                       pop     BC              ; retrieve BC
 169+ FD7B C9                       ret                     ; return to caller
 170+ FD7C
 171+ FD7C
 172+ FD7C              ;***************************************************************************
 173+ FD7C              ; CF_WR_SEC
 174+ FD7C              ; Function: write a sector to Compact Flash - sector address is into BCDE - source address is into HL
 175+ FD7C              ;***************************************************************************
 176+ FD7C C5           CF_WR_SEC:  push    BC              ; store BC
 177+ FD7D E5                       push    HL              ; store HL
 178+ FD7E CD 13 FD                 call    CF_SETSTR       ; set sector
 179+ FD81 CD F7 FC                 call    CF_CMDRDY       ; Make sure drive is ready for command
 180+ FD84 38 17                    jr      C,CF_WR_EXIT    ; return if error
 181+ FD86 3E 30                    ld      A,$30           ; set write command
 182+ FD88 D3 57                    out     (CF_CMD),A      ; send command
 183+ FD8A CD 06 FD                 call    CF_DAT_RDY      ; Make sure drive is ready to get data
 184+ FD8D 38 0E                    jr      C,CF_WR_EXIT    ; return if error
 185+ FD8F 21 C0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
 186+ FD92 01 50 00                 ld      BC,CF_DATA      ; set 256 bytes per loop (B=$00) and CF port (C=CF_DATA)
 187+ FD95 ED B3                    otir                    ; output 256 bytes
 188+ FD97 ED B3                    otir                    ; output 256 bytes
 189+ FD99 CD F0 FC                 call    CF_BUSY         ; wait for CF to complete the writing
 190+ FD9C AF                       xor     A               ; clear Carry
 191+ FD9D E1           CF_WR_EXIT: pop     HL              ; retrieve HL
 192+ FD9E C1                       pop     BC              ; retrieve BC
 193+ FD9F C9                       ret                     ; return to caller
 194+ FDA0
 195+ FDA0              BIOSEND:    equ     $               ; end of BIOS
# file closed: ../include/dos/bios-1.03.asm
  96  FDA0                  INCLUDE "../include/dos/buffers-1.02.asm"
# file opened: ../include/dos/buffers-1.02.asm
   1+ FDA0              ; ------------------------------------------------------------------------------
   2+ FDA0              ; LM80C 64K - BUFFERS - R1.02
   3+ FDA0              ; ------------------------------------------------------------------------------
   4+ FDA0              ; The following code is intended to be used with LM80C Z80-based computer
   5+ FDA0              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ FDA0              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ FDA0              ; kind of warranty: you can use them at your own risk.
   8+ FDA0              ; You are free to use them for any non-commercial use: you are only asked to
   9+ FDA0              ; maintain the copyright notices, include this advice and the note to the
  10+ FDA0              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ FDA0              ; redistribuite them.
  12+ FDA0              ; https://www.leonardomiliani.com
  13+ FDA0              ;
  14+ FDA0              ; Please support me by visiting the following links:
  15+ FDA0              ; Main project page: https://www.leonardomiliani.com
  16+ FDA0              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ FDA0              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ FDA0              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ FDA0              ; ------------------------------------------------------------------------------
  20+ FDA0              ;
  21+ FDA0              ; ------------------------------------------------------------------------------
  22+ FDA0              ; Code Revision:
  23+ FDA0              ; R1.00 - 20210319 - first release
  24+ FDA0              ; R1.01 - 20210327 - added support for sequential files
  25+ FDA0              ; R1.02 - 20210418 - added new statement EXIST
  26+ FDA0              ;
  27+ FDA0              ;------------------------------------------------------------------------------
  28+ FDA0
  29+ FDA0
  30+ FDA0                          DEFINE  DOSJPTBLS   $FDA0       ; beginning of DOS jump table & buffers
  31+ FDA0                          BLOCK     $FDA0-BIOSEND,$FF   ; filler
  32+ FDA0
  33+ FDA0              ;DOS jump table & buffers
  34+ FDA0                          org       $FDA0
  35+ FDA0              SRTBFS:     equ     $
  36+ FDA0
  37+ FDA0                          ; buffers
  38+ FDA0 FF FF FF...  DOSBFR:     BLOCK   $20,$FF         ; 32 bytes buffer
  39+ FDC0 FF FF FF...  IOBUFF:     BLOCK   $200,$FF        ; 512 bytes buffer
  40+ FFC0
  41+ FFC0 FF FF FF FF              BLOCK   $04,$FF
  42+ FFC4                          ; pointers for sequential file
  43+ FFC4              TMPNAM:     equ     $
  44+ FFC4 00 00 00...              BLOCK   $10,$00         ; 16 butes wide
  45+ FFD4 00           SEQFL:      defb    $00             ; (1) 0=no seq. file open / >1=seq. file number
  46+ FFD5 00           SEQFLS:     defb    $00             ; (1) seq. file mode: 0 read / 1 write
  47+ FFD6 00 00        SEQSCTM:    defb    $00,$00         ; (2) MSW of sector address
  48+ FFD8 00 00        SEQSCTL:    defb    $00,$00         ; (2) LSW of sector address
  49+ FFDA 00           SEQSCSZ:    defb    $00             ; (1) size in sectors
  50+ FFDB 00 00        SEQBYSZ:    defb    $00,$00         ; (2) size in bytes
  51+ FFDD 00 00        SEQPNT:     defb    $00,$00         ; (2) pointer to byte
  52+ FFDF
  53+ FFDF                          ; DOS jump table
  54+ FFDF              DOSJPTB     equ     $               ; address of 1st entry
  55+ FFDF C3 13 F5     JPEXI:      jp      EXIST           ; jump to EXIST statement
  56+ FFE2 C3 3D F5     JPEOF:      jp      EOF             ; jump to EOF statement
  57+ FFE5 C3 6B F5     JPPUT:      jp      PUT             ; jump to PUT statement
  58+ FFE8 C3 84 F5     JPGET:      jp      GET             ; jump to GET statement
  59+ FFEB C3 62 EE     JPCLOSE:    jp      CLOSE           ; jump to CLOSE statement
  60+ FFEE C3 36 EE     JPOPEN:     jp      OPEN            ; jump to OPEN statement
  61+ FFF1 C3 6A F0     JPDISK:     jp      DISK            ; jump to DISK statement
  62+ FFF4 C3 0D F0     JPERAS:     jp      ERASE           ; jump to ERASE statement
  63+ FFF7 C3 71 EE     JPLOAD:     jp      LOAD            ; jump to LOAD statement
  64+ FFFA C3 0E EF     JPSAVE:     jp      SAVE            ; jump to SAVE statement
  65+ FFFD C3 D9 EF     JPFILS:     jp      FILES           ; jump to FILES statement
  66+ 0000
# file closed: ../include/dos/buffers-1.02.asm
  97  0000
  98  0000              ; END OF ASSEMBLY SOURCE
  99  0000              ;-------------------------------------------------------------------------------
 100  0000
# file closed: LM80C_64K-firmware-r1.19.asm

Value    Label
------ - -----------------------------------------------------------
0x018F   A_RTS_OFF
0x01AD   A_RTS_ON
0x2612   ABPASS
0xF053   ABRTDS
0xF061   ABRTXT
0x305A   ABS_
0x41A2   absHL
0x1E2C X ACCSUM
0x2611   ACPASS
0x407C   ADD30
0x408C   ADD301
0x2FF3   ADDEXP
0x3199   ADDIG
0x0A3C   ADDNEWLINE
0x2D8F   ADDPHL
0x55A7   ADRS1
0x55AB   ADRS2
0xF656   ALFLSTXT
0x28E0   ALLFOL
0x214D   ANTVLU
0x251C   ARLDSV
0x55EF   ARREND
0x27AB   ARRLP
0x28B1   ASC
0x313C   ASCTFP
0x20A6   ASPCS
0x0686   ATHOME
0x349E   ATN
0x34BB   ATN1
0x34C5   ATNTAB
0x1E67   ATOH
0x5457   AUTOKE
0x173E   AUTORP
0x0197   B_RTS_OFF
0x01B5 X B_RTS_ON
0x0830   BACKSPACE
0x20C9   BADINP
0x17D9   BAKSTK
0x2891   BAKTMP
0x5400   basicStarted
0x54D8   BASTXT
0x3081   BCDEFP
0x0596   BEEPOFF
0x13EE   BFREE
0x40CE   BIN
0x412B   BINERR
0x410A   BINIT
0x4100   BINTFP
0xFDA0   BIOSEND
0xFCD1 X BIOSSTART
0x40E8   BITOUT
0x40EC   BITOUT2
0x3DE0   BITS6
0x3DEA   BITS7
0x3DF5   BITS8
0x55A4   BKGNDCLR
0x0008   BKSP
0x13E5   BLNSPC
0x0028   BN
0x11DE   BNMSG
0x2DEF   BNORM
0x106D X BNPTR
0x2DF2   BNRMLP
0x55AE   BPS
0x1DDA   BRK
0x544C   BRKFLG
0x557D   BRKLIN
0x17D3   BRKMSG
0x13D9   BRKRET
0x0010   BS
0x254F   BSERR
0x1108   BSMSG
0x1055 X BSPTR
0x54DB   BUFFER
0x00FB   bufWrap
0x4073   BYT2ASC
0x5544   BYT_SIZ
0x2F27   BYTSFT
0xFCF0   CF_BUSY
0x0057   CF_CMD
0xFCF7   CF_CMDRDY
0xFD06   CF_DAT_RDY
0x0050   CF_DATA
0x0051 X CF_ERR
0x0051   CF_FTR
0xFCD1   CF_INIT
0x0053   CF_LBA0
0x0054   CF_LBA1
0x0055   CF_LBA2
0x0056   CF_LBA3
0xFCE7   CF_NOP
0xFD68   CF_RD_CMD
0xFD79   CF_RD_EXIT
0xFD55   CF_RD_SEC
0x0052   CF_SECCNT
0xFD13   CF_SETSTR
0xFD49   CF_STANDBY
0x0057   CF_STAT
0xFD9D   CF_WR_EXIT
0xFD7C   CF_WR_SEC
0x24B2   CFEVAL
0xF0C4   CFINIT
0xFBF2   CH0TO9
0xFBFA   CH0TO9E
0x028B   CH3_TIMER
0x015D   CHABFREMPTY
0x0761   CHAR2VID
0x01FD   CHARINTOBFR
0x2460   CHARTY
0x55D9   CHASNDDTN
0xFBFD   CHATOZ
0xFC05   CHATOZE
0x55DB   CHBSNDDTN
0x0886   CHCKYPOS
0x08F1   CHCKYPOS2
0x55DD   CHCSNDDTN
0x0DAA   CHECKALT
0x0DB8   CHECKCTRL
0x0DC6   CHECKKBD
0x3844   CHECKPA
0x3845   CHECKPY
0x030F   CHECKWARM
0x26A9   CHEKFN
0xEFF4   CHK1AR
0xFCA2   CHK_C_CF
0xFC8E   CHK_NAM
0x0E41   CHKALT
0x0E8A   CHKAUTO
0x411D   CHKBIN
0x3669   CHKCLR0
0x3665   CHKCLR1
0x029A   CHKCRSR
0x0E38   CHKCTRL
0xFC08   CHKDSKVAL
0xFC26   CHKDSKVAL1
0xFC3C   CHKDSKVAL2
0xFC3B   CHKDSKVALE
0xFB5F   CHKEOF
0xFB6D   CHKEOFC
0x4029   CHKEY1
0x402E   CHKEY2
0x4031   CHKEY3
0x4037   CHKEY4
0x403A   CHKEY5
0xF946   CHKFLEXT
0xF1A7   CHKFLNM
0xF1B1   CHKFN1
0xF1B4   CHKFN2
0x0EC2   CHKFNK
0x366F   CHKG2M
0x080C   CHKHL
0x2D6E   CHKINK
0x0E24   CHKLN
0x1E39   CHKLTR
0xFC40   CHKNMVAL
0xFC4B   CHKNMVAL1
0xFC51   CHKNMVAL2
0xFC61   CHKNMVAL3
0x35B0   CHKSCAR
0x0CFD   CHKSNDCH
0x05C3   CHKSPCK
0x0D9C   CHKSPCKS
0xFB6F   CHKSQFL
0x180D   CHKSTK
0xFAAC   CHKSTNM1
0xFADC   CHKSTNM10
0xFAAF   CHKSTNM2
0xFAC7   CHKSTNM3
0xFAD1   CHKSTNM6
0x5449   CHKSUM
0x1B4E   CHKSYN
0x222D   CHKTYP
0x08AD   CHKYPOS
0x3CA5   CHKZSER
0xF8E4   CHNGNAM
0x28C2   CHR
0x55A2   CHR4VID
0x55AF   CHRPNT
0x4297   CHRST68
0x4A97   CHRST88
0x0743   CHRTBL
0x3A6E   CIRCLE
0x3D93   CKBPS
0x3755   CKCOL
0xFB87   CKCREN
0x0278   CKINCHAR
0xFB9B   CKLSTEN
0xFBA1   CKLSTEN1
0x3565   CKMAGN
0x422A   CLCN32
0x423A   CLCN321
0x423D   CLCN322
0x4288   CLCN323
0x425F   CLCN325
0x41FE   CLCN32T
0x4226   CLCN32Z
0x1E8C   CLEAR
0x0679   CLEARVIDBUF
0xEE62   CLOSE
0xF4B1   CLOSFIL
0xF4CE   CLOSFIL1
0x1B9A   CLOTST
0x0AE2   CLR_RAM_REG
0xFCAD   CLRBUFF
0xFCB9   CLRDOSBF
0x19B2   CLREG
0x3625   CLREX2
0x3613   CLRG1
0x361C   CLRG2
0x061B   CLRG2PTNTBL
0xFCA4   CLRIOBF
0x360D   CLRMC
0x3C57   CLRPRM
0x0C9B   CLRPSGREGS
0x198D   CLRPTR
0xFCC5   CLRSEQBF
0x05BE   CLRTABLE
0x3C39   CLRTMBF
0x360A   CLRTXT
0x3C48   CLRVDBF
0x34EC   CLS
0x3FCE   CLSQT
0x3FDE   CLSQT1
0x4161   CMP16
0x2D47   CMP_A
0x30CA   CMPFP
0x23C6   CMPLG1
0x23C4   CMPLOG
0x30B0   CMPNUM
0x2408   CMPRES
0x23F0   CMPSTR
0x0020   CN
0xF182   CNFREQ
0xF1A5   CNFRQN
0x119E   CNMSG
0x1065 X CNPTR
0x29BA   CNT1INS
0x0D38   CNTCHKSND
0x35DD   CNTCKCL
0x3B2C   CNTCL1
0x3B50   CNTCL2
0x3B74   CNTCL3
0x3B9A   CNTCL4
0x3BBC   CNTCL5
0x3BE0   CNTCL6
0x3C04   CNTCL7
0x537F   CNTCP2RAM
0x3A13   CNTDRW
0x206E   CNTEND
0x0F1D   CNTFNK
0x36D5   CNTGPT2
0x0EBC   CNTKBCK
0x2385   CNTLGC
0x3F94   CNTLTK
0x09F0   CNTNULL
0x38C2   CNTPLOT
0x38E3   CNTPLT1
0x3D12   CNTRX2
0x0120   CNTRXCHA
0x3CE3   CNTSER
0x3D1D   CNTSER2
0x3D2F   CNTSER3
0x3C34   CNTVALY
0x1CD7   CNTWTSP
0x29F1   CNTZIN
0x3148   CNVNUM
0x12FA   COLD
0x0304   COLDSTART
0x35C0   COLOR
0x5446   COMMAN
0x2E4F   COMPL
0x2826   CONCAT
0x3178   CONEXP
0x2DEC   CONPOS
0x1E13   CONT
0x0724   CONT_POS_CURS
0x5583   CONTAD
0x0897   CONTCRSLFT
0x0904   CONTCRSRGT
0x55E6   CONTROLKEYS
0x2318   CONVAR
0x02F8   CORW
0x3422   COS
0x1B48   CPDEHL
0x137F   CPDSTB
0x3F2B   CPKEY
0x3F4A   CPKEY1
0x3F3B   CPKEY2
0x3F42   CPKEY3
0x3F52   CPKYEND
0x1A8F   CPYLIT
0x000D   CR
0xFD35   CR_DEV_RDY
0xFD3A   CR_DV_RD_1
0xFD47   CR_DV_RD_E
0x256F   CRARLP
0x2554   CREARY
0x1F99   CRESTR
0x09C2   CRGRETURN
0x19F0   CRNCLP
0x001F   CRSDN
0x001C   CRSLFT
0x559F   CRSR_STATE
0x001D   CRSRGT
0x001E   CRSUP
0x26E2   CRTMST
0x26EE   CRTST
0x2704   CRTSTE
0x19E7   CRUNCH
0x000C   CS
0x1307   CSTART
0x5589   CTC0IV
0x558C   CTC1IV
0x558F   CTC2IV
0x5592   CTC3IV
0x3E8F   CTC_CFG
0x0010   CTC_CH0
0x0011   CTC_CH1
0x0012   CTC_CH2
0x0013   CTC_CH3
0x036A   CTCCONF
0x5448   CTLOFG
0x3888   CTPOINT
0x0003   CTRLC
0x0007   CTRLG
0x000F   CTRLO
0x0011   CTRLQ
0x0012   CTRLR
0x0013   CTRLS
0x0015   CTRLU
0x2C1B   CTSNDC
0x55A5   CUR_POS
0x5574   CUROPR
0x5535   CURPOS
0x0942   CURSOR_OFF
0x092D   CURSOR_ON
0x090D   CURSORDOWN
0x0873   CURSORLEFT
0x08D8   CURSORRIGHT
0x08BF   CURSORUP
0x0038   D0
0x126F   D0MSG
0x107D X D0PTR
0x003A   D1
0x127F   D1MSG
0x107F X D1PRT
0x003C   D2
0xF623   D2ERR
0x128B   D2MSG
0x1081 X D2PRT
0x003E   D3
0x1299   D3MSG
0x1083 X D3PRT
0x0040   D4
0x129E   D4MSG
0x1085 X D4PTR
0x0042   D5
0x12A3   D5MSG
0x1087 X D5PTR
0x0044   D6
0x12AD   D6MSG
0x1089 X D6PTR
0x0046   D7
0x12C1   D7MSG
0x108B X D7PRT
0x0048   D8
0x12CD   D8MSG
0x108D X D8PTR
0x004A   D9
0x12DC   D9MSG
0x108F X D9PTR
0x004C   DA
0x12EE   DAMSG
0x1091 X DAPTR
0x553E   DAT_STRT
0x1F40   DATA
0x55B0   DATABT
0x5538   DATFLG
0x5578   DATLIN
0x184A   DATSNR
0x55B7   DC
0x3101   DCBCDE
0x0012   DD
0x1859   DDERR
0x1116   DDMSG
0x1057 X DDPTR
0xFC68   DE2HL
0x0554   DEC_D
0x3F1D   DECLN1
0x3508   DEEK
0x2626   DEF
0x1740 X DEFFNKS
0x3D7A   DEFSER
0x2577   DEFSIZ
0x1E4D   DEINT
0x007F   DEL
0x1ABF   DELCHR
0x1E47   DEPINT
0x3090   DETHL4
0x3092   DETHLB
0x3242   DIGTXT
0x2432   DIM
0x2429   DIMRET
0x1B7D   DINPOS
0x2F2C   DINT
0x5540   DIR_SCT
0x553C   DIR_STRT
0x3EAB   DIRMOD
0xF06A   DISK
0x2AC9   DISNMI
0x2F89   DIV
0x540E   DIV1
0x2F7D   DIV10
0x5412   DIV2
0x5416   DIV3
0x5419   DIV4
0x41CB   DIV_16_16
0x41BC   DIV_16_8
0x41BF   DIV_16_8LP
0x41E0   DIV_32_16
0x41E5   DIV_32_16LP
0x41F6   DIV_32_16OF
0x41F9   DIV_32_16SB
0x41AC   DIV_8_8
0x41B0   DIV_8_8LOOP
0x2FB0   DIVLP
0x540D   DIVSUP
0x55A9   DKLNPT
0x55A7   DKNMPT
0x3AF0   DLSZ
0x19CB   DOAGN
0x05DB   DOCOLDRESET
0x2073   DOCOM
0x1A9F   DODEL
0x3282   DOEBIT
0x2653   DOFN
0x3513   DOKE
0x55EA   DOS_EN
0xEFED   DOS_ERR
0xF249   DOS_FT1
0xF2FA   DOS_FT10
0xF263   DOS_FT2
0xF2FE   DOS_FT7
0xF300   DOS_FT8
0xF2ED   DOS_FT9
0xF2D3   DOS_FTA
0xF23B   DOS_FTC
0xFDA0   DOSBFR
0x553B   DOSER
0xFFDF   DOSJPTB
0x143D   DOSMSG
0x20A1   DOSPC
0xEE25   DOSSTART
0xF635   DOSVERSERR
0x208C   DOTAB
0x3174   DPOINT
0x3939   DRAW
0x3B0A   DRWCRL
0xF1CE   DSK_INIT
0xF306   DSK_RNM
0xEE34   DSKDIRADR
0xF0B1   DSKFRM
0xF626   DSKFULL
0xEE25   DSKHDR
0xF63F   DSKNMTX
0xF150   DSKRNM
0xF140   DSKUND
0xFAEA   DSKUNDFL
0xFAF6   DSKUNDFL1
0xFB27   DSKUNDFL2
0xFB12   DSKUNDPR
0xFB2C   DSKUNDTXT
0x26F2   DTSTR
0xF629   DUPLERR
0x41D0   DV16_16_LP
0x2F8B   DVBCDE
0x55B9   DX
0x3A43   DXGR
0x55BB   DY
0x0014   DZ
0x1853   DZERR
0x112B   DZMSG
0x1059 X DZPTR
0x55B3   E2
0x1AB3   ECHDEL
0x031C   ECHO_CHAR
0x31BB   EDIGIT
0x2959   EMPTINS
0x0C97   EMPTSNDBFR
0x0AD9   EMPTVRM
0x0ACF   EMPTY_VRAM
0x014F   EMPTYCHABFR
0x0181   EMPTYCHBBFR
0x060A   EMPTYG2
0x063A   EMPTYMC
0x05E2   EMPTYVIDBUF
0x3E64   ENCHB
0x53A3   END_OF_FW
0x1A96   ENDBUF
0x3187   ENDCON
0x3B08   ENDCRL
0x0E0C   ENDCTRLCK
0x25D6   ENDDIM
0x3A6C   ENDDRAW
0x2D80   ENDINK
0x205A   ENDINP
0x5557   ENDMEM
0x2454   ENDNAM
0x0A49   ENDOFLN
0x1DE9   ENDPRG
0x25EB   ENDTMR
0x55A9   ENDTXT
0x04E7   ENDVDPSET
0x1816   ENFMEM
0xF53D   EOF
0xF553   EOF1
0x55B1   ER
0x39E7   ER2
0xF00D   ERASE
0x0573   ERASECLRTBL
0xF045   ERASED
0x188E   ERRIN
0x1E0D   ERRINT
0x5581   ERRLIN
0x17C2   ERRMSG
0x186A   ERROR
0x1093 X ERRORS
0x1045   ERRTBL
0xF037   ERSTX
0x001B   ESC
0x223A   EVAL
0x223D   EVAL1
0x2246   EVAL2
0x2249   EVAL3
0x22FF   EVLPAR
0x2412   EVNOT
0x1D77   EXCUTE
0x04A5   EXG2MD
0xF513   EXIST
0x07BD   EXITCHAR2VID
0x0940   EXITCURSOR_ON
0x092A   EXITCURSORDOWN
0x089A   EXITCURSORLEFT
0x090A   EXITCURSORRGHT
0x08D6   EXITCURSORUP
0x182A   EXITGM
0x3842   EXITPA2
0x383E   EXITPAI
0x4184   EXMUL16
0x3E72   EXNRM
0x331C   EXP
0x3166   EXPLP
0x335C   EXPTAB
0x3294   EXPTEN
0x21A9   EXTIG
0x21D2   FANDT
0x0008   FC
0x1E62   FCERR
0x10CC   FCMSG
0x104D X FCPTR
0x21B9   FDTLP
0xFA8D   FIL_ERA1
0xFA98   FIL_ERA2
0xFA9B   FIL_ERA3
0xFA6C   FIL_ERA5
0xFA65   FIL_ERA6
0xFA28   FIL_ERASE
0xF620   FILALROP
0xFAA5   FILE_EXIST
0xEFD9   FILES
0xF79A   FILETP
0xF61D   FILOPCLER
0x25B2   FINDEL
0x0E22   FINDKEY
0x07CB   FLASHCURSOR
0xFAE8   FLEXST
0x3040   FLGDIF
0x3047   FLGREL
0xF62F   FLNTFND
0x00EC   FMVEREND
0x55F5   FNARG
0x1465   FNCTAB
0x2522   FNDARY
0x25B7   FNDELP
0x1960   FNDEND
0xFB37   FNDFRENTR
0xFB43   FNDFRENTR1
0xFB46   FNDFRENTR2
0xFB56   FNDFRENTR3
0xFB4B   FNDFRENTR4
0x2AAB   FNDNUM
0x1C8B   FNDTOK
0x2499   FNDVAR
0x1A1A   FNDWRD
0x5458   FNKEYS
0x0F3D   FNKEYSORD
0x2329   FNOFST
0x55F3   FNRGNM
0x24A7   FNTHR
0x235A   FNVAL
0x2272   FOPRND
0x1CDE   FOR
0x557A   FORFLG
0x1D0E   FORFND
0x1CF2   FORSLP
0x2D9E   FPADD
0x3076   FPBCDE
0x55FC   FPEXP
0x30DD   FPINT
0x2ED9   FPMULT
0x55F9   FPREG
0x2E36   FPROND
0x1E41   FPSINT
0x308D   FPTHL
0x25F0   FRE
0x260C   FRENUM
0x55A3   FRGNDCLR
0x231B   FRMEVL
0xF113   FRMTXT
0x00D0 X FWVER
0x0420   G1MD
0x0460   G2MD
0x2773   GARBGE
0x2776   GARBLP
0xF584   GET
0xF5F5   GET1
0xF5E4   GET2
0xEED6   GET4AR
0x1D97   GETCHR
0x18BD   GETCMD
0xF5FC   GETER
0x40A9   GETHEX
0x34EA   GETINP
0x2AAE   GETINT
0x28A6   GETLEN
0x1AD0   GETLIN
0x1E68   GETLN
0x2228   GETNUM
0x1A35   GETNXT
0x2870   GETSTR
0x2437   GETVAR
0xF604   GETZER
0x002A   GM
0x3C70   GMERR
0x11E9   GMMSG
0x1B25   GMNCR
0x106F X GMPRT
0x27AA   GNXARY
0x2362   GOFUNC
0x1EEC   GOSUB
0x1EFD   GOTO
0x3738   GPCPCH1
0x36EA   GPNT
0x3714   GPNTCO1
0x3678   GPRINT
0x27CA   GRBARY
0x274B   GRBDON
0x2784   GRBLP
0x2873   GSTRCU
0x2877   GSTRDE
0x2876   GSTRHL
0x28B5 X GTFLNM
0x243C   GTFNAM
0x1E6B   GTLNLP
0xFB8F   GTNXTEN
0x320C   GTSIXD
0x2125   GTVLUS
0x55A9   GX
0x55AB   GY
0x32B3   HALF
0x346C   HALFPI
0x0026   HE
0x3EB4   HELP
0x11D3   HEMSG
0x106B X HEPTR
0x403D   HEX
0x4055   HEX1
0x4057   HEX2
0x4064   HEX3
0x4066   HEX4
0x40C0   HEXIT
0x409C   HEXLP
0x40A1   HEXLP1
0x4090   HEXTFP
0xFC6D   HL2DE
0x0732   HL2XY
0x3ECD   HLPERR
0x5454   HLPLN
0x0019   HOME
0x0032   HP
0x123E   HPMSG
0x1077 X HPPTR
0x40C9   HXERR
0x0016   ID
0x113C   IDMSG
0x105B X IDPTR
0x269B   IDTEST
0x1FCF   IF
0x1FE6   IF0
0x1FEF   IF1
0x1FDD   IFGO
0x1D7E   IFJMP
0x0034   IM
0x1865   IMERR
0x1248   IMMSG
0x1079 X IMPRT
0x308B   INCHL
0x1B79   INCLEN
0x0294   INCTMR3
0x17F3   INDFND
0x1928   INEWLN
0x02AE   INIT_HW
0x02B1 X INIT_HW2
0x16E9   INITAB
0x17C2   INITBE
0x0340   initCTC
0x0C91   initPSG
0x4154   INITST
0x03D1   initVDP
0x2D3C   INKEY
0x2D56   INKEY2
0x17C9   INMSG
0x2A6B   INP
0x2177   INPBIN
0x1DE6   INPBRK
0x5443   INPORT
0xF690   INPR1
0x5442   INPSUB
0x20DA   INPUT
0x3215   INRNG
0x07EE   INSERTKEY
0x001A   INSRT
0x2902   INSTR
0x3108   INT
0x199C   INTVAR
0x305E   INVSGN
0xFDC0   IOBUFF
0x2168   ITMSEP
0xFFEB   JPCLOSE
0xFFF1   JPDISK
0xFFE2   JPEOF
0xFFF4   JPERAS
0xFFDF   JPEXI
0xFFFD   JPFILS
0xFFE8   JPGET
0xFFF7   JPLOAD
0xFFEE   JPOPEN
0xFFE5   JPPUT
0xFFFA   JPSAVE
0x329E   JSTZER
0x55DF   KBDNPT
0x0F45   KBMAP
0x0FC5   KBMAP_ALT
0x1005   KBMAP_CTRL
0x0F85   KBMAP_SFT
0x55E0   KBTMP
0x3ED2   KEY
0x0D58   KEYBOARD
0x3EED   KEYCH
0x5456   KEYDEL
0x55E4   KEYTMR
0x2218   KILFOR
0x1ACA   KILIN
0x55E2   LASTKEYPRSD
0x5536   LCRFLG
0x04DE   LDCLRTBEX2
0x0457   LDCLRTBMD1
0x05FB   LDCOLSTOEMPTY
0xEEA7   LDEND
0xFBAD   LDENTRIES
0xEEAE   LDERR
0xF9C1   LDFL1
0xF9C5   LDFL2
0xF9E5   LDFL3
0xF9A5   LDFL4
0xFA1C   LDFL5
0xFA23   LDFLEX
0x0F09   LDFNKEYCHR
0x1837   LDG1
0x1848   LDG1ND
0x3F7F   LDKEY
0xFBBC   LDMSCT
0x0AFF   LDREGVLS
0xEEC4   LDSVPT
0x28D2   LEFT
0x28A2   LEN
0x1F57   LET
0x1FAA   LETNUM
0x1F72   LETSTR
0x000A   LF
0x2A61   LFRGNM
0x5452   LINEAT
0x31C7   LINEIN
0x1911   LINFND
0x1BB5   LIST
0x1C48   LISTLP
0xF963   LK4FILE
0xF966   LK4FILE1
0x0B51   LM80CLOGO
0x55A5   LNS1
0x55A9   LNS2
0xEE71   LOAD
0x070F   LOAD_CRSR_POS
0x0B09   LOADCHARSET
0x362C   LOADCLR
0x3084   LOADFP
0x059E   LOADLOGOCHRS
0x0E48   LOADMAP
0x0973   LOADNEXTCOL
0xEE92   LOADST
0x2B81   LOCATE
0xF632   LODERR
0xF978   LODFILE
0x2E98   LOG
0x5297   LOGOFONT
0x2E8B   LOGTAB
0x17DD   LOKFOR
0x5576   LOOPST
0x001C   LS
0x1173   LSMSG
0x1061 X LSPTR
0x1BE1   LST01
0x1BE4   LST01H
0x1C3F   LST02
0x1C28   LST03
0x1C3C   LST05
0x1BFF   LST06
0x1C6D   LST07
0x1C6A   LST08
0xF671   LST_FILES
0x1C10   LSTALL
0x557B   LSTBIN
0x55A0   LSTCSRSTA
0xF6C4   LSTFILES1
0xF6C7   LSTFILES2
0xF6F1   LSTFILES20
0xF6F9   LSTFILES21
0xF701   LSTFILES22
0xF6D5   LSTFILES3
0xF730   LSTFILES6
0xF704   LSTFILESPR
0x3F54   LSTKEYS
0x1C79   LSTLP2
0x1C7C   LSTLP3
0x1C03   LSTNOT
0x5539   LSTRAM
0x543E   LSTRND
0x5549   LSW_SCT
0x2182   LTSTND
0x086A   LVBKSP
0x05D9   LVCKSPLK
0x29E7   LVINSTR
0x0EEC   LVKBRDCHK2
0x0131   LVRXCHA
0x1CC3   LVSRLN
0x5445   LWIDTH
0x2AB1   MAKINT
0x3231   MAKNUM
0x3150   MANLP
0x1A67   MATCH
0x0482   MCMD
0x145A   MEMMSG
0x2A02   MID
0x28D8   MID1
0x2A66   MIDNUM
0x2DDE   MINCDE
0x2307   MINUS
0x3658   MIXCLRS
0x55A5   MIXCOL
0x26DF   MKTMST
0x3129   MLDBLP
0x3121   MLDEBC
0x133F   MLOOP
0x4174   MLP
0x417B   MLP1
0x301E   MLSP10
0x0CF3   MNGSNDS
0x133C   MNOASK
0x37C3   MNPAINT
0x0024   MO
0x2F34   MOD
0x11C3   MOMSG
0x4130   MONOUT
0x1069 X MOPTR
0x218E   MORDT
0x1AD9   MORINP
0x1947   MOVBUF
0x06D6   MOVCRS
0x1A6F   MOVDIR
0x1802   MOVLP
0x06DC   MOVSHOWCRS
0x17FF   MOVSTR
0x17FC   MOVUP
0x1FFD   MRPRNT
0x0376   MSGTXT1
0x03B4   MSGTXT2
0x1329   MSIZE
0xF0F3   MSPTOK
0xF0FB   MSTTXT
0x5547   MSW_SCT
0x4191   MU32_1
0x419E   MU32_2
0x416C   MUL16
0x2F04   MUL8LP
0x4193   MUL_32L
0x4186   MUL_U32
0x2ED0   MULLN2
0x2ED7   MULT
0x2EFB   MULT8
0x3192   MULTEN
0x560B   MULVAL
0x0857   MVBKSP
0x089C   MVCRS2LFT
0x1FA1   MVSTPT
0xF62C   NAMERR
0x2121   NEDMOR
0x32C9   NEGAFT
0x41A5   negHL
0x198C   NEW
0x06F1   NEWCRSRCOORD
0x0E9C   NEWKEY
0x20B0   NEXITM
0x21DD   NEXT
0x21E0   NEXT1
0x0000   NF
0x1856   NFERR
0x1093   NFMSG
0x1045 X NFPTR
0x0000   NLLCR
0x2ADA   NM1
0x2ABF   NMI
0x2AEB   NMI2
0x2AF6   NMIDINT
0x2AEF   NMIEINT
0x544B   NMIFLG
0x2AF9   NMIINT
0x5404   NMIUSR
0x2B05   NMIVR1
0x0CC5   NOBEEP
0x0CE1   NOBPDAT
0x1A5F   NOCHNG
0x32A1   NOENED
0x3903   NOGD
0x2C9F   NOISUP
0x0E10   NOKEYPRSD
0x1DFC   NOLIN
0x2F15   NOMADD
0x3137   NOMLAD
0x0D73   NOMRPRSS
0x20F4   NOPMPT
0x2E09   NORMAL
0x2CC9   NOS1
0x2CDC   NOS2
0x2CF5   NOS3
0x1A56   NOSPC
0x40BC   NOSUB7
0x2DB8   NOSWAP
0x2B37   NOSYSPR
0x22DC   NOTAMP
0x0208   NOTFULL
0x023F   NOTRDWRAP
0x246F   NOTSTR
0x0214   NOTWRAP
0x2A91   NOXOR
0x0036   NR
0x1868   NRERR
0x125E   NRMSG
0x107B X NRPRT
0x247F   NSCFOR
0x5542   NTR_NBR
0x5447   NULFLG
0x31DA   NUMASC
0x55B1   NUMCHR
0x2536   NXTARY
0x1A45   NXTBYT
0x0B1D   NXTCHAR
0x1A86   NXTCHR
0x0781   NXTCPCK
0x55F1   NXTDAT
0x1F3F   NXTDTA
0x081D   NXTINST
0x2119   NXTITM
0x1CA3   NXTLN
0x37A4   NXTLOOP
0x557F   NXTOPR
0x1F46   NXTSTL
0x1F49   NXTSTT
0x0006   OD
0x10C0   ODMSG
0x104B X ODPTR
0x17CE   OKMSG
0x000C   OM
0x1825   OMERR
0x10EB   OMMSG
0x1051 X OMPTR
0x1FB1   ON
0x1FC0   ONGO
0x1FC1   ONGOLP
0x1D7F   ONJMP
0xEE36   OPEN
0xF458   OPFLRS
0xF463   OPFLRS1
0xF3A7   OPNFIL
0xF469   OPNFILPT
0xF423   OPNFRD
0xF44D   OPNFRD1
0xF432   OPNFRD2
0xF42A   OPNFRD3
0x2236   OPNPAR
0x3FE0   OPNQT
0x3FF6   OPNQT1
0xF471   OPNRDDET
0xF12B   OPRCMP
0x22B1   OPRND
0x55AF   ORGSP
0x001A   OS
0x115F   OSMSG
0x105F X OSPTR
0x1AC7   OTKLN
0x540B   OTPORT
0x1B59   OUTC
0x3292   OUTEXP
0x1B3F   OUTIT
0x1B42   OUTNBS
0x415B   OUTNCR
0x540A   OUTSUB
0x1C95   OUTWRD
0x000A   OV
0x185F   OVERR
0x10E2   OVMSG
0x104F X OVPTR
0x3011   OVTST1
0x3016   OVTST2
0x3017   OVTST3
0x31B6   PADD
0x3768   PAINT
0x37B1   PAINT0
0x37C0   PAINT1
0x37BF   PAINT11
0x37F3   PAINT2
0x3806   PAINT3
0x3825   PAINT4
0x3837   PAINT5
0x237B   PAND
0x23A0 X PAND1
0x55B1   PARBT
0x2621   PASSA
0x352A   PAUSE
0x55FE   PBUFF
0x2B47   PEEK
0x1DE1   PEND
0x3073   PHLTFP
0x0002 X PIO_CA
0x0003   PIO_CB
0x0000 X PIO_DA
0x0001   PIO_DB
0x2B5B   PKEPRMS
0x07CA   PLACEHOLDER
0x38A7   PLOT
0x3AFF   PLTCRL
0x2E43   PLUCDE
0x2E11   PNORM
0x55AD   PNT
0x0EE9   PNT2VD
0x387E   PNTEND
0x389C   PNTRTN
0xF756   PNTSTATS
0x3854   POINT
0x2B71   POKE
0x2765   POPAF
0x288F   POPHL
0x2F25   POPHRT
0x18AF   POPNOK
0x237E   POR
0x23A5   POR1
0x261E   POS
0x06CC   POS_CURSOR
0x0A6F   POS_TB_CRS_32
0x0A9F   POS_TB_CRS_40
0x1E44 X POSINT
0x2A77   POUT
0x32D7   POWER
0x32E7   POWER1
0x3304   POWER2
0x32B7   POWERS
0x2001   PRINT
0x16CB   PRITAB
0xFC75   PRN16ASCII
0xFC7B   PRN16ASCIX
0xFC72   PRN32ASCII
0x2064   PRNTCRLF
0x0F30   PRNTFNK
0x0EF1   PRNTFNKEY
0x31CF   PRNTHL
0x2004   PRNTLP
0x2047   PRNTNB
0x18B0   PRNTOK
0x0A28   PRNTRETURN
0xFC85   PRNTSIZ
0x204B   PRNTST
0x55A1   PRNTVIDEO
0x272F   PRNUMS
0x1AF0   PROCES
0x55EB   PROGND
0x560E   PROGST
0x19CF   PROMPT
0x2730   PRS
0x2733   PRS1
0x273A   PRSLP
0x3FA9   PRTCHR
0x3FF8   PRTCKEY
0x4005   PRTEND
0x3FF9   PRTK1
0x3F91   PRTK3
0x3F66   PRTK4
0x55AD   PRTNUM
0x0041   PSG_DAT
0x0040   PSG_REG
0x2D99   PSUB
0x55AD   PT
0x55AF   PT1
0x55B1   PT2
0xFB7C   PT2FSEN
0x3FC6   PTCHR1
0x18AB   PTLN
0x1954   PTRLP
0xF56B   PUT
0x1B2B   PUTBUF
0x0EDC   PUTCHRBUF
0x0F23   PUTCHRBUF1
0x07EA   PUTCRSCHR
0x1B30   PUTCTL
0x1D53   PUTFID
0xF32F   PUTFIL
0xF3A0   PUTFIL2
0xF36B   PUTNXSC
0x3907   PXLSET
0x2383   PXOR
0x23AD   PXOR1
0x26F5   QTSTLP
0x26EF   QTSTR
0x3470   QUARTR
0x55B1   RADIUS
0x554B   RAM_PTR
0x5357   RAMRUN
0x027D   RAWPRINT
0x2114   READ
0x0690   READ_VIDEO_LOC
0x06C5   READ_VSTAT
0x557C   READFG
0x0D43   READKBLN
0x20B7   REDO
0x1F42   REM
0xEF96   RENFIL
0x2FC3   RESDIV
0x340E   RESEED
0x4133   RESET
0x4135   RESET2
0x4150   RESETE
0x3EDF   RESFN
0x0365   RESTMR
0x1DBC   RESTNL
0x1DA7   RESTOR
0x2E04   RESZER
0xF637   RET_ERR
0x24E6   RETADR
0xF567   RETEOF
0xFD04   RETERR
0x304C   RETINT
0x1F3A   RETLIN
0x1A6B   RETNAD
0x24E9   RETNUL
0x2313   RETNUM
0x303E   RETREL
0x1F1B   RETURN
0x0004   RG
0x10AB   RGMSG
0x1049 X RGPTR
0x29F8   RIGHT
0x28D6   RIGHT1
0x544D   RINPUT
0x2256   RLTLP
0x33AD   RND
0x33E9   RND1
0x3405   RND2
0xFBDF   RND8
0xFBC8   RND_ID
0xFBCB   RND_ID1
0xF174   RNDKTX
0x3416   RNDTAB
0x32A4   RNGTST
0x536C   ROM2RAM
0x2E25   RONDB
0x2E24   RONDUP
0x2D8C   ROUND
0x2991   RP2INST
0x3C41   RPCLTMB
0x36FF   RPGPNT
0x0580   RPT100
0x051A   RPT101
0x051D   RPT102
0x0532   RPT103
0x053A   RPT104
0x3AC3   RPTCL1
0x0774   RPTCPCK
0x3AB0   RPTCRL
0x3C50   RPTCVBF
0x39F7   RPTDRW
0x0601   RPTEMPTYBUF
0x09B6   RPTEMPTYROW
0x0666   RPTFLL1
0x296A   RPTINST
0x0DCA   RPTKBDRD
0x3635   RPTLDCL
0x09E0   RPTNLLSRC
0x0A61   RPTNLLSRC2
0x3537   RPTPS
0x3CB6   RPTRSSR
0x0CCB   RPTWLCMBP
0x2BF6   RPVOLCG
0x31B0   RSCALE
0x0000 X RST00
0x0008 X RST08
0x0010 X RST10
0x0018 X RST18
0x0706   RSTCHRCRS
0xFCAE   RSTIOBF
0x0CA2   RSTPSG
0x3CA9   RSTSERS
0x2A1B   RSTSTR
0x0AE8   RSTVDPRAMREG
0x1ED8   RUN
0x1D57   RUNCNT
0x1998   RUNFST
0x1EFC   RUNLIN
0xF0AC   RWMSSC
0x0100   RX_CHA_AVAIL
0x0165   RX_CHB_AVAIL
0x022A   RXA
0x0255   RXA_EXIT
0x3D19   RXEND
0x29DC   RZINSTR
0x002E   SA
0x120F   SAMSG
0x1073 X SAPTR
0xEF0E   SAVE
0xEF68   SAVE1
0xEF7D   SAVESCT
0x2E05   SAVEXP
0xF7AE   SAVFILE
0xF7DC   SAVFL1
0xF801   SAVFL10
0xF857   SAVFL12
0xF8D2   SAVFL2
0xF7D4   SAVFL3
0xF813   SAVFL4
0xF7EF   SAVFL6
0xF8AA   SAVFL9
0xF85E   SAVFLEXT
0x1D4A   SAVSTP
0x26CA   SAVSTR
0x24F4   SBSCPT
0x002C   SC
0x2E63   SCALE
0x2E65   SCALLP
0x317B   SCALMI
0x3191   SCALPL
0x3E9E   SCERR
0x3E9A   SCERR1
0x11FA   SCMSG
0x2801   SCNEND
0x24FA   SCPTLP
0x1071 X SCPTR
0x559C   SCR_CUR_NX
0x559D   SCR_CUR_NY
0x559A   SCR_CURS_X
0x559B   SCR_CURS_Y
0x5597   SCR_MODE
0x5598   SCR_NAM_TB
0x559E   SCR_ORG_CHR
0x5596   SCR_SIZE_H
0x5595   SCR_SIZE_W
0x3547   SCREEN
0x0961   SCROLLNXTRW
0x0949   SCROLLUP
0x5546   SCT_SIZ
0x3573   SCVDP
0x1A33   SEARCH
0x541B   SEED
0x0B1F   SENDCHRPTRNS
0x0EA9   SENDKEY
0x0CC8   SENDSND
0xFFDB   SEQBYSZ
0xFFD4   SEQFL
0xFFD5   SEQFLS
0xFFDD   SEQPNT
0xFFDA   SEQSCSZ
0xFFD8   SEQSCTL
0xFFD6   SEQSCTM
0x0058   SER_BUFSIZE
0x0005   SER_EMPTYSIZE
0x0050   SER_FULLSIZE
0x55E8   SERABITS
0x55E9   SERBBITS
0x53A3   SERBUF_START
0x53FF   serBufUsed
0x3C75   SERIAL
0x55E7   SERIALS_EN
0x53FB   serInPtr
0x3CDF   SERLED
0x53FD   serRdPtr
0x3C96   SERVAR
0x3DBD   SET_CTC
0x0AED   SET_GFX_MODE
0x0AF5   SET_GFX_MODE2
0x3DAC   SET_PT
0x058A   SETBEEP
0x3640   SETBRCL
0x07AA   SETCRSRY
0x07AB   SETCSRCOORDS
0x1392   SETDSR
0x2A9B   SETIO
0x1A7D   SETLIT
0x065E   SETNAMETABLE
0x0E7A   SETNEWAUTO
0x1395   SETNOD
0x3DF9   SETPAR
0x3E04   SETPAR2
0xFB74   SETPTEN
0x194F   SETPTR
0x4007   SETREP
0x3D87   SETSER
0x0CE9   SETSNDREG
0x1363   SETTOP
0x13C6   SETTP1
0x1396 X SETTRAM
0x0670   SETVDPADRS
0x1919   SFTPRG
0x3044   SGN
0x236B   SGNEXP
0x55FD   SGNRES
0x04F2   SHOW_LOGO
0x2E72   SHRITE
0x2E75   SHRLP
0x2E79   SHRT1
0x13FC   SIGNON
0x309B   SIGNS
0x3428   SIN
0x3458   SIN1
0x3474   SINTAB
0x01CB   SIO_A_DI
0x01E3   SIO_A_EI
0x0336   SIO_A_SETS
0x01D3   SIO_B_DI
0x01EB   SIO_B_EI
0x033C X SIO_B_SETS
0x0022   SIO_CA
0x0023   SIO_CB
0x0020   SIO_DA
0x0021   SIO_DB
0x019D   SIO_RTS_OFF
0x01BB   SIO_RTS_ON
0x01D9   SIO_RXDI
0x01F1   SIO_RXEN
0x55B3   SIOBFR
0x31F7   SIXDIG
0x2795   SMPVAR
0x338C   SMSER1
0x0002   SN
0x2C64   SND1
0x1B8C   SND2VID
0x0A09   SNDCHRTOBFR
0x0654   SNDCLRSET
0x0ECA   SNDKEYTOBFR
0x05B4   SNDLOGPT
0x2C99   SNDOVR
0x0CAF   SNDREGCFG
0x1850   SNERR
0x10A4   SNMSG
0x1047 X SNPTR
0x0030   SO
0x3EA3   SOERR
0x1228   SOMSG
0x1075 X SOPTR
0x2C0D   SOUND
0x0020   SPC
0x31E8   SPCFST
0x20A8   SPCLP
0x0136   SPEC_RXA_CNDT
0x0168   SPEC_RXB_CNDT
0x32CE   SQR
0x1CB1   SRCHLIN
0x196C   SRCHLN
0x196F   SRCHLP
0x1CB7   SRCLN
0x1CB8   SRCLN1
0x2BB3   SREG
0x3E39   SRLCNT
0x3CD9   SRPT2
0xFDA0 X SRTBFS
0x2D6A   SRTINK
0x5555   SRTMEM
0x55A7   SRTTXT
0x2D28   SSTAT
0x285D   SSTSA
0x001E   ST
0x54E0   STACK
0x3066   STAKFP
0x1DD0   STALL
0x1300   STARTB
0x0651   STARTEMPTY
0x55E3   STATUSKEY
0x229A   STKTHS
0x5672   STLOOK
0x1183   STMSG
0x1DDF   STOP
0x1EB5   STORED
0x55B2   STPBT
0x27D8   STPOOL
0x1063 X STPTR
0x26BA   STR
0x26C0   STR1
0x27DB   STRADD
0x5572   STRBOT
0x39F4   STRE2
0x216B   STRENT
0x3E21   STRPAR
0x5450   STRSPC
0x2052   STTLIN
0x2D9B   SUBCDE
0x2D95   SUBPHL
0x3395   SUMLP
0x337D   SUMSER
0x3E79   SUP_BPS
0x3276   SUPTLZ
0xF4D6   SVCRNTSE
0xEF8F   SVEND
0xF863   SVENTRY
0xEFC4   SVERR
0x2453   SVNAM2
0xF4A5   SVSQFLNM
0x26E8   SVSTAD
0x55B5   SX
0x55B7   SY
0x2B19   SYS
0x130E   SYSINIT
0x2B45   SYSRET
0x3489   TAN
0x5532   TEMPSTACK
0x0DF9   TESTALT
0x0E06   TESTCTRL
0x2767   TESTOS
0x2749   TESTR
0x55B5   TF
0xF667   TLFLSTX
0xF64B   TLSCTTX
0x0018   TM
0x1862   TMERR
0x1150   TMMSG
0x8000   TMP_FW_LOC
0x55AD   TMPADR
0x55A5   TMPBFR1
0x55A7   TMPBFR2
0x55A9   TMPBFR3
0x55AB   TMPBFR4
0x55A7   TMPCLR
0x553C   TMPDBF
0x55B3   TMPHL
0x55E1   TMPKEYBFR
0xFFC4   TMPNAM
0x556E   TMPSTR
0x105D X TMPTR
0x25DA   TMR
0x5585   TMRCNT
0x5562   TMSTPL
0x5560   TMSTPT
0x28CE   TOPOOL
0x2866   TOSTRA
0x55B3   TP
0x554D   TPBF1
0x554F   TPBF2
0x5551   TPBF3
0x5553   TPBF4
0x553C   TPHL
0x3251   TRYAGN
0x2867   TSALP
0x1DC2   TSTBRK
0x1351   TSTMEM
0x222B   TSTNUM
0x2710   TSTOPL
0x23B2   TSTRED
0x1A80   TSTREM
0x3035   TSTSGN
0x1CC5   TSTSPC
0x222C   TSTSTR
0x1AD0   TTYLIN
0x026C   TX_EMP
0x0259   TXA
0x0269   TXA_EXIT
0xEEB3   TXTLDG
0x03F6 X TXTMD
0xEFB3   TXTRNM
0xEFC9   TXTSVG
0x5537   TYPE
0x0022   UF
0x185C   UFERR
0x11AD   UFMSG
0x1067 X UFPTR
0x000E   UL
0x1F16   ULERR
0x10F9   ULMSG
0x1053 X ULPTR
0x2E87   UNITY
0xF4E2   UPCRNENT
0xF511   UPCRNENT1
0x1DBD   UPDATA
0x5407   USR
0x2A32   VAL
0x2A50   VAL1
0x2A5A   VAL2
0x2A5D   VAL3
0x3C29   VALIDX
0x3C2E   VALIDY
0x55ED   VAREND
0x0030   VDP_DAT
0x0031   VDP_SET
0x0B29   VDPMODESET
0x0B31 X VDPMODESET1
0x0B39 X VDPMODESET2
0x0B49 X VDPMODESETEX2
0x0B41 X VDPMODESETMC
0x55AD   VIDEOBUFF
0x55D5   VIDTMP1
0x55D7   VIDTMP2
0x2C02   VOLCH
0x2BD4   VOLUME
0x2B4E   VPEEK
0x2B76   VPOKE
0x2D01   VREG
0x2D1D   VSTAT
0x2A7D   WAIT
0x2A92   WAITLP
0x12FD   WARM
0x13D6   WARMST
0x3500   WIDTH
0x0CD9   WLCBPDAT
0x0CBF   WLCMBEEP
0x14AF   WORDS
0x1657   WORDTB
0x06A5   WRITE_VIDEO_LOC
0x06BA   WRITE_VREG
0x099B   WRITEBUF
0x5401   WRKSPC
0xFAA0   WRT_ERR
0x2CEC   WRTSND
0x0CEE   WRTSNDREG
0x1CCB   WTSPC
0x55A5   X1
0x399A   X1GR
0x55AD   X2
0x55AD   XC
0x55B3   XI
0x390F   XY2HL
0x55A7   Y1
0x39C4   Y1GR
0x55AF   Y2
0x55AF   YC
0x55B5   YI
0x0083   ZDATA
0x00C6 X ZDINT
0x00C4 X ZDIV
0x00B2   ZELSE
0x0080   ZEND
0x00CC   ZEQUAL
0x2595   ZERARY
0x17CD   ZERBYT
0x24D8   ZEROLP
0x40DA   ZEROSUP
0x00BC   ZFN
0x0081   ZFOR
0x008C   ZGOSUB
0x0088   ZGOTO
0x00CB   ZGTR
0x00E5   ZINSTR
0x00F0   ZLEFT
0x00CD   ZLTH
0x00C2   ZMINUS
0x00C5 X ZMOD
0x00B9   ZNEW
0x00BF   ZNOT
0x2081   ZONELP
0x00CA   ZOR
0x00C1   ZPLUS
0x00E4   ZPOINT
0x00B3   ZPRINT
0x008E   ZREM
0x00CE   ZSGN
0x00BD   ZSPC
0x00C0   ZSTEP
0x00BA   ZTAB
0x00BE   ZTHEN
0x00C3 X ZTIMES
0x00BB   ZTO
