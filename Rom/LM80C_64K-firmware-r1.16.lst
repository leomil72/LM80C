# file opened: LM80C_64K-firmware-r1.16.asm
   1  0000              ; ------------------------------------------------------------------------------
   2  0000              ; LM80C 64K - FIRMWARE - R1.16
   3  0000              ; ------------------------------------------------------------------------------
   4  0000              ; The following code is intended to be used with LM80C Z80-based computer
   5  0000              ; designed by Leonardo Miliani. More info at
   6  0000              ; www DOT leonardomiliani DOT com
   7  0000              ; ------------------------------------------------------------------------------
   8  0000              ; Coding/Editing/Compiling:
   9  0000              ; Original init code for MC68B05 by Grant Searle
  10  0000              ; Original SIO/CTC/PIO init code by Mario Blunk
  11  0000              ; NASCOM BASIC originally modified by Gran Searle
  12  0000              ; Code modified and adapted for LM80C by Leonardo Miliani
  13  0000              ;
  14  0000              ; Edited with Visual Studio Code
  15  0000              ;
  16  0000              ; Compiled with SjASMPlus assembler 1.18.2
  17  0000              ; https://github.com/z00m128/sjasmplus
  18  0000              ; ------------------------------------------------------------------------------
  19  0000              ; Copyright notes:
  20  0000              ; Parts of the code (c) Grant Searle - free for non commercial use
  21  0000              ; Please include this advice and the note to the attribution of the original
  22  0000              ; version to Grant Searle if you intend to redistribuite it
  23  0000              ; http://searle.hostei.com/grant/index.html
  24  0000              ; eMail: home.micros01@btinternet.com
  25  0000              ;
  26  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  27  0000              ; Parts of the code (c) Mario Blunk
  28  0000              ; http://www.trainÂ­z.de
  29  0000              ;
  30  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  31  0000              ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  32  0000              ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  33  0000              ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  34  0000              ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  35  0000              ; the original ROM code (checksum A934H). PA
  36  0000              ;
  37  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  38  0000              ; The following code is intended to be used with LM80C Z80-based computer
  39  0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
  40  0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
  41  0000              ; kind of warranty: you can use them at your own risk.
  42  0000              ; You are free to use them for any non-commercial use: you are only asked to
  43  0000              ; maintain the copyright notices, include this advice and the note to the
  44  0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  45  0000              ; redistribuite them.
  46  0000              ; https://www.leonardomiliani.com
  47  0000              ;
  48  0000              ; Please support me by visiting the following links:
  49  0000              ; Main project page: https://www.leonardomiliani.com
  50  0000              ; Schematics and code: https://github.com/leomil72/LM80C
  51  0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  52  0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  53  0000              ; ------------------------------------------------------------------------------
  54  0000              ; set name for binary output file
  55  0000                  OUTPUT "LM80C-64K-firmware-r1.16.bin"
  56  0000
  57  0000              ; set firmware version
  58  0000                  DEFINE VERSION "1.16"
  59  0000
  60  0000              ; set DOS version
  61  0000                  DEFINE  DOS_VER "1.05"
  62  0000
  63  0000              ; ------------------------------------------------------------------------------
  64  0000              ; include the latest version of the bootloader: this sets up the address aliases,
  65  0000              ; configure the hardware, checks if warm or cold startup and loads the BASIC interpreter
  66  0000                  INCLUDE "../include/bootloader/bootloader-1.07.asm"
# file opened: ../include/bootloader/bootloader-1.07.asm
   1+ 0000              ; ------------------------------------------------------------------------------
   2+ 0000              ; LM80C - BOOTLOADER - 1.07
   3+ 0000              ; ------------------------------------------------------------------------------
   4+ 0000              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0000              ; kind of warranty: you can use them at your own risk.
   8+ 0000              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0000              ; maintain the copyright notices, include this advice and the note to the
  10+ 0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0000              ; redistribuite them.
  12+ 0000              ; https://www.leonardomiliani.com
  13+ 0000              ;
  14+ 0000              ; Please support me by visiting the following links:
  15+ 0000              ; Main project page: https://www.leonardomiliani.com
  16+ 0000              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0000              ; ------------------------------------------------------------------------------
  20+ 0000
  21+ 0000              ; ADDRESS DECODING (bits A6/A5/A4)
  22+ 0000              ; 0000xxxx : PIO
  23+ 0000              ; 0001xxxx : CTC
  24+ 0000              ; 0010xxxx : SIO
  25+ 0000              ; 0011xxxx : VDP
  26+ 0000              ; 0100xxxx : PSG
  27+ 0000              ; 0101xxxx : C.F.
  28+ 0000
  29+ 0000
  30+ 0000              ; ------------------------------------------------------------------------------
  31+ 0000              ;               EQUATES
  32+ 0000              ; ------------------------------------------------------------------------------
  33+ 0000              ; label defining for PIO (Parallel Input/Output)
  34+ 0000              PIO_DA          equ %00000000
  35+ 0000              PIO_DB          equ %00000001
  36+ 0000              PIO_CA          equ %00000010
  37+ 0000              PIO_CB          equ %00000011
  38+ 0000
  39+ 0000              ; label defining for CTC (Counter Timer Circuit)
  40+ 0000              CTC_CH0         equ %00010000
  41+ 0000              CTC_CH1         equ %00010001
  42+ 0000              CTC_CH2         equ %00010010
  43+ 0000              CTC_CH3         equ %00010011
  44+ 0000
  45+ 0000              ;label defining for SIO (Serial Input/Output)
  46+ 0000              SIO_CA          equ %00100010
  47+ 0000              SIO_CB          equ %00100011
  48+ 0000              SIO_DA          equ %00100000
  49+ 0000              SIO_DB          equ %00100001
  50+ 0000
  51+ 0000              ;label defining for VDP (Video Display Processor)
  52+ 0000              VDP_DAT         equ %00110000
  53+ 0000              VDP_SET         equ %00110001
  54+ 0000
  55+ 0000              ; label defining for PSG (Programmable Sound Generator)
  56+ 0000              PSG_REG         equ %01000000
  57+ 0000              PSG_DAT         equ %01000001
  58+ 0000
  59+ 0000              ; Interrupt-driven serial I/O interface lead by the Z80 SIO to run modified
  60+ 0000              ; NASCOM Basic 4.7 - Full input buffering with incoming data hardware handshaking
  61+ 0000              ; Handshake shows full before the buffer is totally filled to allow run-on from the sender
  62+ 0000              SER_BUFSIZE     equ     $58
  63+ 0000              SER_FULLSIZE    equ     $50
  64+ 0000              SER_EMPTYSIZE   equ     $05
  65+ 0000
  66+ 0000
  67+ 0000              ;------------------------------------------------------------------------------
  68+ 0000              ;                                F I R M W A R E
  69+ 0000              ;------------------------------------------------------------------------------
  70+ 0000              ; BASE MEMORY - RESET LOCATION ($0000) -> the CPU jumps to $0000 after a reset
  71+ 0000                              org     $0000
  72+ 0000 F3           RST00:          di                      ; be sure that INTs are disabled
  73+ 0001 C3 40 53                     jp      ROM2RAM         ; jump to ROM/RAM switcher
  74+ 0004
  75+ 0004              ;------------------------------------------------------------------------------
  76+ 0004              ; interrupt vector when SIO ch.B has a char available in its buffer
  77+ 0004                              ;$0004
  78+ 0004 65 01                        defw    RX_CHB_AVAIL
  79+ 0006
  80+ 0006              ;------------------------------------------------------------------------------
  81+ 0006              ; interrupt vector for SIO ch.B special conditions (i.e. buf overrun)
  82+ 0006                              ;$0006
  83+ 0006 68 01                        defw    SPEC_RXB_CNDT
  84+ 0008
  85+ 0008              ;------------------------------------------------------------------------------
  86+ 0008              ; send a character over serial ch. A
  87+ 0008                              ;$0008
  88+ 0008 C3 59 02     RST08:          jp      TXA
  89+ 000B FF                           BLOCK   1,$FF   ; filler
  90+ 000C
  91+ 000C              ;------------------------------------------------------------------------------
  92+ 000C              ; interrupt vector when SIO ch.A has a char available in its buffer
  93+ 000C                              ;$000C
  94+ 000C 00 01                        defw    RX_CHA_AVAIL
  95+ 000E
  96+ 000E              ;------------------------------------------------------------------------------
  97+ 000E              ; interrupt vector for SIO ch.A special conditions (i.e. buf overrun)
  98+ 000E                              ;$000E
  99+ 000E 36 01                        defw    SPEC_RXA_CNDT
 100+ 0010
 101+ 0010              ;------------------------------------------------------------------------------
 102+ 0010              ; receive a character over serial ch. A
 103+ 0010                              ;$0010
 104+ 0010 C3 2A 02     RST10:          jp      RXA
 105+ 0013 FF FF FF...                  BLOCK   5,$FF   ; filler
 106+ 0018              ;------------------------------------------------------------------------------
 107+ 0018              ; check buffer state
 108+ 0018
 109+ 0018                              ;$0018
 110+ 0018 C3 78 02     RST18:          jp      CKINCHAR
 111+ 001B FF FF FF...                  BLOCK   $25,$FF ; filler
 112+ 0040              ;------------------------------------------------------------------------------
 113+ 0040              ; interrupt vectors for CTC
 114+ 0040                              ;$0040               ; for CH0 Timer - used in BASIC by serial 1 for bps
 115+ 0040 60 55                        defw    CTC0IV
 116+ 0042                              ;$0042               ; for CH1 Timer - used in BASIC by serial 2 for bps
 117+ 0042 63 55                        defw    CTC1IV
 118+ 0044                              ;$0044               ; for CH2 timer - unused
 119+ 0044 66 55                        defw    CTC2IV
 120+ 0046                              ;$0046               ; for CH3 Timer - used by FW for 100ths/s counter
 121+ 0046 69 55                        defw    CTC3IV
 122+ 0048 FF FF FF...                  BLOCK   $1E,$FF ; filler
 123+ 0066              ;------------------------------------------------------------------------------
 124+ 0066              ; interrupt routine for NMI
 125+ 0066                              ;$0066
 126+ 0066 C3 DB 53                     jp      NMIUSR              ; jump to execute NMI service routine
 127+ 0069 FF FF FF...                  BLOCK   $27,$FF ; filler
 128+ 0090              ;------------------------------------------------------------------------------
 129+ 0090
 130+ 0090                              ;$0090
 131+ 0090 4C 4D 38 30                  defb    $4C,$4D,$38,$30,$43,$20,$36,$34
 131+ 0094 43 20 36 34
 132+ 0098 4B 20 43 4F                  defb    $4B,$20,$43,$4F,$4C,$4F,$52,$00
 132+ 009C 4C 4F 52 00
 133+ 00A0 43 4F 4D 50                  defb    $43,$4F,$4D,$50,$55,$54,$45,$52
 133+ 00A4 55 54 45 52
 134+ 00A8 20 28 32 30                  defb    $20,$28,$32,$30,$32,$31,$29,$00
 134+ 00AC 32 31 29 00
 135+ 00B0 44 65 73 69                  defb    $44,$65,$73,$69,$67,$6E,$65,$64
 135+ 00B4 67 6E 65 64
 136+ 00B8 20 62 79 00                  defb    $20,$62,$79,$00,$00,$00,$00,$00
 136+ 00BC 00 00 00 00
 137+ 00C0 4C 65 6F 6E                  defb    $4C,$65,$6F,$6E,$61,$72,$64,$6F
 137+ 00C4 61 72 64 6F
 138+ 00C8 20 4D 69 6C                  defb    $20,$4D,$69,$6C,$69,$61,$6E,$69
 138+ 00CC 69 61 6E 69
 139+ 00D0 46 57 20 31  FWVER:          defm    "FW ","1.16",$20,"2021-03-28",$20,"23:23:10",$00
 139+ 00D4 2E 31 36 20
 139+ 00D8 32 30 32 31
 139+ 00DC 2D 30 33 2D
 139+ 00E0 32 38 20 32
 139+ 00E4 33 3A 32 33
 139+ 00E8 3A 31 30 00
 140+ 00EC              FMVEREND:       equ     $
 141+ 00EC FF FF FF...                  BLOCK   $100-FMVEREND,$FF   ; filler
 142+ 0100              ;------------------------------------------------------------------------------
 143+ 0100
 144+ 0100              ;-------------------------------------------------------------------------------
 145+ 0100              ;               Z80 SIO CH. A MANAGEMENT
 146+ 0100              ;-------------------------------------------------------------------------------
 147+ 0100
 148+ 0100              ;-------------------------------------------------------------------------------
 149+ 0100              ; interrupt driven routine to get chars from Z80 SIO ch.A
 150+ 0100              ; this is the only serial channel that can print received chars onto the screen
 151+ 0100                              ;$0100
 152+ 0100 F5           RX_CHA_AVAIL:   push    AF              ; store A
 153+ 0101 E5                           push    HL              ; and HL
 154+ 0102 CD 8F 01                     call    A_RTS_OFF       ; disable RTS line
 155+ 0105 DB 20                        in      A,(SIO_DA)      ; read char from RX buffer into A
 156+ 0107 32 B8 55                     ld      (TMPKEYBFR),A   ; store it into the temp key buffer
 157+ 010A CD FD 01                     call    CHARINTOBFR     ; sub-routine to put the char into the input buffer
 158+ 010D D2 31 01                     jp      NC,LVRXCHA      ; if buffer is full, then leave without doing anything else
 159+ 0110 3A B8 55                     ld      A,(TMPKEYBFR)   ; retrieve char
 160+ 0113 32 79 55                     ld      (CHR4VID),A     ; write into buffer for video printing
 161+ 0116 FE 0D                        cp      CR              ; is it RETURN?
 162+ 0118 CA 20 01                     jp      Z,CNTRXCHA      ; yes, continue
 163+ 011B FE 20                        cp      $20             ; is it another control char (code < 32)?
 164+ 011D DA 31 01                     jp      C,LVRXCHA       ; yes, leave w/o printing it on video nor sending back to serial
 165+ 0120 F5           CNTRXCHA:       push    AF              ; store char
 166+ 0121 AF                           xor     A
 167+ 0122 32 B6 55                     ld      (KBDNPT),A      ; a char from serial is like a char printed by BASIC
 168+ 0125 3A 78 55                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 169+ 0128 FE 01                        cp      $01             ; is the print on video on?
 170+ 012A CC 5A 07                     call    Z,CHAR2VID      ; yes, print on screen
 171+ 012D F1                           pop     AF              ; retrieve char
 172+ 012E CD 59 02                     call    TXA             ; send back to serial
 173+ 0131 E1           LVRXCHA:        pop     HL              ; retrieve HL
 174+ 0132 F1                           pop     AF              ; and A
 175+ 0133 FB                           ei                      ; re-enable interrupts
 176+ 0134 ED 4D                        reti                    ; and exit
 177+ 0136
 178+ 0136              ;-------------------------------------------------------------------------------
 179+ 0136              ; special SIO ch.A condition (i.e., buffer overrun)
 180+ 0136              ; if buffer overruns then show an error, empty the RX buffer and send
 181+ 0136              ; a break char
 182+ 0136 F5           SPEC_RXA_CNDT:  push    AF              ; store AF
 183+ 0137 CD 8F 01                     call    A_RTS_OFF       ; disable RTS
 184+ 013A CD CB 01                     call    SIO_A_DI        ; disable RX on ch. A
 185+ 013D 3A BE 55                     ld      A,(SERIALS_EN)  ; load serial status
 186+ 0140 CB 97                        res     2,A             ; disable RX on port 1
 187+ 0142 32 BE 55                     ld      (SERIALS_EN),A  ; store new serial status
 188+ 0145 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 189+ 0147 CB E7                        set     4,A             ; set 5th pin ON
 190+ 0149 D3 01                        out     (PIO_DB),A      ; send new setting
 191+ 014B 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 192+ 014D D3 22                        out     (SIO_CA),A      ; send command to SIO
 193+ 014F AF           EMPTYCHABFR:    xor     A
 194+ 0150 D3 22                        out     (SIO_CA),A      ; write to WR0, select RR0
 195+ 0152 DB 22                        in      A,(SIO_CA)      ; read RR0 register
 196+ 0154 E6 01                        and     $01             ; check if input buffer if empty
 197+ 0156 CA 5D 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then leave
 198+ 0159 DB 20                        in      A,(SIO_DA)      ; read chars
 199+ 015B 18 F2                        jr      EMPTYCHABFR     ; repeat
 200+ 015D F1           CHABFREMPTY:    pop     AF              ; retrieve AF
 201+ 015E 21 79 3E                     ld      HL,SOERR        ; return point set to Serial Buffer Overrun routine
 202+ 0161 E3                           ex      (SP),HL         ; store onto stack
 203+ 0162 FB                           ei                      ; re-enable interrupts
 204+ 0163 ED 4D                        reti                    ; return from interrupt and execute code at SOERR
 205+ 0165
 206+ 0165              ;-------------------------------------------------------------------------------
 207+ 0165              ;               Z80 SIO CH. A MANAGEMENT
 208+ 0165              ;-------------------------------------------------------------------------------
 209+ 0165
 210+ 0165              ;-------------------------------------------------------------------------------
 211+ 0165              ; interrupt driven routine to get chars from Z80 SIO ch.B
 212+ 0165 FB           RX_CHB_AVAIL:   ei
 213+ 0166 ED 4D                        reti
 214+ 0168
 215+ 0168              ;-------------------------------------------------------------------------------
 216+ 0168              ; special SIO ch.A condition (i.e., buffer overrun)
 217+ 0168              ; if buffer overruns then show an error, empty the RX buffer and send
 218+ 0168              ; a break char
 219+ 0168 F5           SPEC_RXB_CNDT:  push    AF              ; store A
 220+ 0169 CD 97 01                     call    B_RTS_OFF       ; disable RTS
 221+ 016C CD D3 01                     call    SIO_B_DI        ; disable RX on ch.B
 222+ 016F 3A BE 55                     ld      A,(SERIALS_EN)  ; load serial status
 223+ 0172 CB 9F                        res     3,A             ; disable RX on port 2
 224+ 0174 32 BE 55                     ld      (SERIALS_EN),A  ; store new serial status
 225+ 0177 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 226+ 0179 CB EF                        set     5,A             ; set 5th pin ON
 227+ 017B D3 01                        out     (PIO_DB),A      ; send new setting
 228+ 017D 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 229+ 017F D3 23                        out     (SIO_CB),A      ; send command to SIO
 230+ 0181 AF           EMPTYCHBBFR:    xor     A
 231+ 0182 D3 23                        out     (SIO_CB),A      ; write to WR0, select RR0
 232+ 0184 DB 23                        in      A,(SIO_CB)      ; read RR0 register
 233+ 0186 E6 01                        and     $01             ; check if input buffer if empty
 234+ 0188 CA 5D 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then jump to run "exit" code
 235+ 018B DB 21                        in      A,(SIO_DB)      ; read chars
 236+ 018D 18 F2                        jr      EMPTYCHBBFR     ; repeat
 237+ 018F
 238+ 018F
 239+ 018F              ;-------------------------------------------------------------------------------
 240+ 018F              ;               Z80 SIO MANAGEMENT
 241+ 018F              ;-------------------------------------------------------------------------------
 242+ 018F              ; disable RTS:
 243+ 018F              ; by resetting RTS bit (set to 0), the RTS line is disabled (HIGH)
 244+ 018F C5           A_RTS_OFF:      push    BC              ; store BC
 245+ 0190 0E 22                        ld      C,SIO_CA        ; select channel A
 246+ 0192 3A BF 55                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 247+ 0195 18 06                        jr      SIO_RTS_OFF
 248+ 0197 C5           B_RTS_OFF:      push    BC              ; store BC
 249+ 0198 0E 23                        ld      C,SIO_CB        ; select channel B
 250+ 019A 3A C0 55                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 251+ 019D CB 3F        SIO_RTS_OFF:    srl     A               ; position data bits in bits #5&6
 252+ 019F E6 60                        and     %01100000       ; get only bits #5&6
 253+ 01A1 47                           ld      B,A             ; store data bits
 254+ 01A2 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 255+ 01A4 ED 79                        out     (C),A
 256+ 01A6 3E 88                        ld      A,%10001000     ; enable DTR (b7) and TX (b4), disable RTS (b1)
 257+ 01A8 B0                           or      B               ; set data bits
 258+ 01A9 ED 79                        out     (C),A           ; send setting
 259+ 01AB C1                           pop     BC              ; retrieve BC
 260+ 01AC C9                           ret                     ; exit
 261+ 01AD
 262+ 01AD              ;-------------------------------------------------------------------------------
 263+ 01AD              ; enable RTS
 264+ 01AD              ; by setting RTS bit (set to 1), the RTS line is enabled (LOW)
 265+ 01AD C5           A_RTS_ON:       push    BC              ; store BC
 266+ 01AE 0E 22                        ld      C,SIO_CA        ; select channel A
 267+ 01B0 3A BF 55                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 268+ 01B3 18 06                        jr      SIO_RTS_ON
 269+ 01B5 C5           B_RTS_ON:       push    BC              ; store BC
 270+ 01B6 0E 23                        ld      C,SIO_CB        ; select channel B
 271+ 01B8 3A C0 55                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 272+ 01BB CB 3F        SIO_RTS_ON:     srl     A               ; position data bits in bits #5&6
 273+ 01BD E6 60                        and     %01100000       ; get only bits #5&6
 274+ 01BF 47                           ld      B,A             ; store data bits
 275+ 01C0 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 276+ 01C2 ED 79                        out     (C),A
 277+ 01C4 3E 8A                        ld      A,%10001010     ; enable DTR (b7), TX (b4), and RTS (b1)
 278+ 01C6 B0                           or      B               ; set data bits
 279+ 01C7 ED 79                        out     (C),A           ; send setting
 280+ 01C9 C1                           pop     BC              ; retrieve BC
 281+ 01CA C9                           ret                     ; return
 282+ 01CB
 283+ 01CB              ;-------------------------------------------------------------------------------
 284+ 01CB              ; disable SIO RX channel
 285+ 01CB C5           SIO_A_DI:       push    BC              ; store BC
 286+ 01CC 0E 22                        ld      C,SIO_CA        ; SIO channel A
 287+ 01CE 3A BF 55                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 288+ 01D1 18 06                        jr      SIO_RXDI        ; jump to disable RX
 289+ 01D3 C5           SIO_B_DI:       push    BC              ; store BC
 290+ 01D4 0E 23                        ld      C,SIO_CB        ; SIO channel B
 291+ 01D6 3A C0 55                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 292+ 01D9 47           SIO_RXDI:       ld      B,A             ; store data bits
 293+ 01DA 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 294+ 01DC ED 79                        out     (C),A
 295+ 01DE 78                           ld      A,B             ; retrieve data bits; RX disabled; auto enable is OFF
 296+ 01DF ED 79                        out     (C),A
 297+ 01E1 C1                           pop     BC              ; retrieve BC
 298+ 01E2 C9                           ret                     ; return
 299+ 01E3
 300+ 01E3              ;-------------------------------------------------------------------------------
 301+ 01E3              ; enable SIO RX channel
 302+ 01E3 C5           SIO_A_EI:       push    BC              ; store BC
 303+ 01E4 0E 22                        ld      C,SIO_CA
 304+ 01E6 3A BF 55                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 305+ 01E9 18 06                        jr      SIO_RXEN
 306+ 01EB C5           SIO_B_EI:       push    BC              ; store BC
 307+ 01EC 0E 23                        ld      C,SIO_CB
 308+ 01EE 3A C0 55                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 309+ 01F1 47           SIO_RXEN:       ld      B,A             ; store data bits
 310+ 01F2 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 311+ 01F4 ED 79                        out     (C),A           ; select register
 312+ 01F6 78                           ld      A,B             ; retrieve data bits
 313+ 01F7 CB C7                        set     0,A             ; set RX enabled; auto enable is OFF
 314+ 01F9 ED 79                        out     (C),A           ; send settings to SIO
 315+ 01FB C1                           pop     BC              ; retrieve BC
 316+ 01FC C9                           ret
 317+ 01FD
 318+ 01FD              ;------------------------------------------------------------------------------
 319+ 01FD              ; put a char into the input buffer, char is into A
 320+ 01FD              ; this sub is called both from the ISR "RX_CHA_AVAIL" and when
 321+ 01FD              ; the RETURN key is pressed on the keyboard
 322+ 01FD F5           CHARINTOBFR:    push    AF              ; store it
 323+ 01FE 3A D6 53                     ld      A,(serBufUsed)  ; load buffer size
 324+ 0201 FE 58                        cp      SER_BUFSIZE     ; if buffer is not full
 325+ 0203 DA 08 02                     jp      C,NOTFULL       ; then store the char
 326+ 0206 F1                           pop     AF              ; else drop it
 327+ 0207 C9                           ret                     ; and exit
 328+ 0208 2A D2 53     NOTFULL:        ld      HL,(serInPtr)   ; buffer is not full, can store the char
 329+ 020B 23                           inc     HL              ; load pointer to find first free cell
 330+ 020C 7D                           ld      A,L             ; only check low byte because buffer<256
 331+ 020D FE D2                        cp      bufWrap         ; check if the pointer is at the last cell
 332+ 020F 20 03                        jr      NZ,NOTWRAP      ; if not then continue
 333+ 0211 21 7A 53                     ld      HL,SERBUF_START ; else load the address of the first cell
 334+ 0214 22 D2 53     NOTWRAP:        ld      (serInPtr),HL   ; store the new pointer
 335+ 0217 F1                           pop     AF              ; then retrieve the char...
 336+ 0218 77                           ld      (HL),A          ; ...and store it in the appropriate cell
 337+ 0219 21 D6 53                     ld      HL,serBufUsed   ; size of the input buffer
 338+ 021C 34                           inc     (HL)            ; increment it
 339+ 021D 3E 50                        ld      A,SER_FULLSIZE  ; input buffer capacity
 340+ 021F BE                           cp      (HL)            ; check if input buffer is full
 341+ 0220 D8                           ret     C               ; exit if buffer is not full
 342+ 0221 3A BE 55                     ld      A,(SERIALS_EN)  ; check if serial 1 is open
 343+ 0224 1F                           rra                     ; bit 0 into Carry: if Carry is 1 then serial 0 is open and...
 344+ 0225 DC 8F 01                     call    C,A_RTS_OFF     ; ...receiving further chars must be stopped
 345+ 0228 37                           scf                     ; set Carry flag, because  we must inform that the char has been added before to disable RTS
 346+ 0229 C9                           ret
 347+ 022A
 348+ 022A
 349+ 022A              ;-------------------------------------------------------------------------------
 350+ 022A              ; retrieve a char from the input buffer
 351+ 022A 3A D6 53     RXA:            ld      A,(serBufUsed)  ; load the buffer size
 352+ 022D A7                           and     A               ; check if it's 0 (empty)
 353+ 022E CA 2A 02                     jp      Z,RXA           ; if it's empty, wait for a char
 354+ 0231 F3                           di                      ; disable interrupts
 355+ 0232 E5                           push    HL              ; store HL
 356+ 0233 2A D4 53                     ld      HL,(serRdPtr)   ; load pointer to first available char
 357+ 0236 23                           inc     HL              ; increment it (go to the next char)
 358+ 0237 7D                           ld      A,L             ; check if the end of the buffer has been reached
 359+ 0238 FE D2                        cp      bufWrap         ; (only check low byte because buffer<256)
 360+ 023A 20 03                        jr      NZ,NOTRDWRAP    ; if not, jump straight
 361+ 023C 21 7A 53                     ld      HL,SERBUF_START ; else reload the starting address of the buffer
 362+ 023F 22 D4 53     NOTRDWRAP:      ld      (serRdPtr),HL   ; store new pointer to the next char to read
 363+ 0242 3A D6 53                     ld      A,(serBufUsed)  ; load buffer size
 364+ 0245 3D                           dec     A               ; decrement it
 365+ 0246 32 D6 53                     ld      (serBufUsed),A  ; and store the new size
 366+ 0249 FE 05                        cp      SER_EMPTYSIZE   ; check if input buffer can be considered empty
 367+ 024B 30 08                        jr      NC,RXA_EXIT     ; if not empty yet, then exit
 368+ 024D 3A BE 55                     ld      A,(SERIALS_EN)  ; load serial state
 369+ 0250 EE 05                        xor     %00000101       ; check if serial 1 is open and RX enabled
 370+ 0252 CC AD 01                     call    Z,A_RTS_ON      ; yes, set RTS on
 371+ 0255 7E           RXA_EXIT:       ld      A,(HL)          ; recover the char and return it into A
 372+ 0256 E1                           pop     HL              ; retrieve HL
 373+ 0257 FB                           ei                      ; re-enable interrupts
 374+ 0258 C9                           ret                     ; return
 375+ 0259
 376+ 0259              ;------------------------------------------------------------------------------
 377+ 0259              ; sends a char over the serial - char is into A
 378+ 0259 F5           TXA:            push    AF              ; store AF
 379+ 025A C5                           push    BC              ; store BC
 380+ 025B 47                           ld      B,A             ; store char
 381+ 025C 3A BE 55                     ld      A,(SERIALS_EN)  ; load serial status
 382+ 025F EE 05                        xor     %00000101       ; check if serial 1 is open and RX is enabled
 383+ 0261 20 06                        jr      NZ,TXA_EXIT     ; no, jump over
 384+ 0263 78                           ld      A,B             ; retrieve char
 385+ 0264 D3 20                        out     (SIO_DA),A      ; send char to the SIO
 386+ 0266 CD 6C 02                     call    TX_EMP          ; wait for outgoing char to be sent
 387+ 0269 C1           TXA_EXIT:       pop     BC              ; retrieve BC
 388+ 026A F1                           pop     AF              ; retrieve AF
 389+ 026B C9                           ret                     ; return
 390+ 026C
 391+ 026C              ;------------------------------------------------------------------------------
 392+ 026C              ; wait until outgoing serial has been sent
 393+ 026C 97           TX_EMP:         sub     A               ; set A to 0
 394+ 026D 3C                           inc     A               ; set A to 1
 395+ 026E D3 22                        out     (SIO_CA),A      ; write to WR0, select RR1
 396+ 0270 DB 22                        in      A,(SIO_CA)      ; read RR1 register
 397+ 0272 CB 47                        bit     0,A             ; check if all chars have been sent
 398+ 0274 CA 6C 02                     jp      Z,TX_EMP        ; if not (bit 0 = 0) then retrieve
 399+ 0277 C9                           ret                     ; else exit
 400+ 0278
 401+ 0278
 402+ 0278              ;------------------------------------------------------------------------------
 403+ 0278              ; check if there is some chars into the buffer
 404+ 0278 3A D6 53     CKINCHAR:       ld      A,(serBufUsed)  ; load buffer size
 405+ 027B A7                           and     A               ; compare to 0
 406+ 027C C9                           ret                     ; return
 407+ 027D
 408+ 027D              ;------------------------------------------------------------------------------
 409+ 027D              ; print a text from memory, and terminate when $00 is found
 410+ 027D 7E           RAWPRINT:       ld      A,(HL)          ; load character from memory cell pointed by HL
 411+ 027E B7                           or      A               ; is it $00 (end string)?
 412+ 027F C8                           ret     Z               ; Yes, then return
 413+ 0280 32 79 55                     ld      (CHR4VID),A     ; store char
 414+ 0283 F3                           di
 415+ 0284 CD 5A 07                     call    CHAR2VID        ; and send it to screen
 416+ 0287 FB                           ei
 417+ 0288 23                           inc     HL              ; and select the next one
 418+ 0289 18 F2                        jr      RAWPRINT        ; repeat
 419+ 028B
 420+ 028B              ;-------------------------------------------------
 421+ 028B              ; Interrupt service routine (ISR) for CH3 timer
 422+ 028B              ; this is used to increment the 100ths of a second counter and for cursor flashing
 423+ 028B F5           CH3_TIMER:      push    AF              ; save regs. A,
 424+ 028C C5                           push    BC              ; BC,
 425+ 028D D5                           push    DE              ; DE,
 426+ 028E E5                           push    HL              ; HL
 427+ 028F 21 5C 55                     ld      HL,TMRCNT       ; load starting address of the timer
 428+ 0292 06 04                        ld      B,$04           ; 4 bytes to check
 429+ 0294 34           INCTMR3:        inc     (HL)            ; increment timer
 430+ 0295 20 03                        jr      NZ,CHKCRSR      ; if not zero then exit (finished increment)
 431+ 0297 23                           inc     HL              ; if yes, there was an overflow, so increment next byte
 432+ 0298 10 FA                        djnz    INCTMR3         ; repeat for 4 bytes
 433+ 029A CD C4 07     CHKCRSR:        call    FLASHCURSOR     ; call the flashing cursor routine
 434+ 029D CD EC 0C                     call    MNGSNDS         ; call the tone managemenet
 435+ 02A0 3A 5C 55                     ld      A,(TMRCNT)      ; check for keyboard management
 436+ 02A3 1F                           rra                     ; bit 0 = 1 ?
 437+ 02A4 D4 51 0D                     call    NC,KEYBOARD     ; no, so read the keyboard inputs
 438+ 02A7 E1                           pop     HL              ; retrieve HL,
 439+ 02A8 D1                           pop     DE              ; DE,
 440+ 02A9 C1                           pop     BC              ; BC,
 441+ 02AA F1                           pop     AF              ; and A
 442+ 02AB FB                           ei                      ; re-enable interrupts
 443+ 02AC ED 4D                        reti                    ; exit from ISR
 444+ 02AE
 445+ 02AE              ;------------------------------------------------------------------------------
 446+ 02AE              ;               HARDWARE INITIALISATION
 447+ 02AE              ;------------------------------------------------------------------------------
 448+ 02AE              ; first run - setup HW & SW
 449+ 02AE              ; (on LN80C 64K runs from RAM)
 450+ 02AE 21 09 55     INIT_HW:        ld      HL,TEMPSTACK    ; load temp stack pointer
 451+ 02B1 F9           INIT_HW2:       ld      SP,HL           ; set stack to temp stack pointer
 452+ 02B2 21 7A 53                     ld      HL,SERBUF_START ; set beginning of input buffer
 453+ 02B5 22 D2 53                     ld      (serInPtr),HL   ; for incoming chars to store into buffer
 454+ 02B8 22 D4 53                     ld      (serRdPtr),HL   ; and for chars to be read from buffer
 455+ 02BB AF                           xor     A               ; reset A
 456+ 02BC 32 D6 53                     ld      (serBufUsed),A  ; actual buffer size is 0
 457+ 02BF 32 BE 55                     ld      (SERIALS_EN),A  ; set serial ports status to OFF
 458+ 02C2 CD 40 03                     call    initCTC         ; configure CTC, then...
 459+ 02C5 CD 8A 0C                     call    initPSG         ; ...configure PSG
 460+ 02C8 CD F2 04                     call    SHOW_LOGO       ; show computer logo
 461+ 02CB 1E 01                        ld      E,$01           ; E chooses the video mode (graphics 1)
 462+ 02CD CD D1 03                     call    initVDP         ; set video display
 463+ 02D0 AF                           xor     A
 464+ 02D1 ED 47                        ld      I,A             ; set high byte of interrupt vectors to point to page 0
 465+ 02D3 ED 5E                        im      2               ; interrupt mode 2
 466+ 02D5 FB                           ei                      ; enable interrupts
 467+ 02D6                              ; print system messages
 468+ 02D6 AF                           xor     A               ; A=0 so...
 469+ 02D7 32 B6 55                     ld      (KBDNPT),A      ; ...inputs don't come from keyboard
 470+ 02DA 3C                           inc     A               ; A=1...
 471+ 02DB 32 78 55                     ld      (PRNTVIDEO),A   ; ...to activate the print-on-video
 472+ 02DE 21 76 03                     ld      HL,MSGTXT1      ; sign-on message
 473+ 02E1 CD 7D 02                     call    RAWPRINT        ; print message
 474+ 02E4 3A D7 53                     ld      A,(basicStarted); check if BASIC is already started
 475+ 02E7 FE 59                        cp      'Y'             ; to see if this is a power-up
 476+ 02E9 20 19                        jr      NZ,COLDSTART    ; if not, then do a COLD start
 477+ 02EB 21 B4 03                     ld      HL,MSGTXT2      ; message to choose kind of start
 478+ 02EE CD 7D 02                     call    RAWPRINT        ; print message
 479+ 02F1 CD 26 09                     call    CURSOR_ON       ; enable cursor
 480+ 02F4 AF                           xor     A
 481+ 02F5 32 78 55                     ld      (PRNTVIDEO),A   ; disable print-on-video
 482+ 02F8 CD 2A 02     CORW:           call    RXA             ; look for a pressed key
 483+ 02FB E6 DF                        and     %11011111       ; only UPPERCASE char
 484+ 02FD FE 43                        cp      'C'             ; cold start?
 485+ 02FF 20 0E                        jr      NZ,CHECKWARM    ; no, let's check for warm start
 486+ 0301 CD 1C 03                     call    ECHO_CHAR       ; echoes the char
 487+ 0304 3E 59        COLDSTART:      ld      A,'Y'           ; yes, set the "BASIC started" flag
 488+ 0306 32 D7 53                     ld      (basicStarted),A
 489+ 0309 CD 3B 09                     call    CURSOR_OFF      ; disable cursor
 490+ 030C C3 C1 12                     jp      COLD            ; start BASIC COLD
 491+ 030F FE 57        CHECKWARM:      cp      'W'
 492+ 0311 20 E5                        jr      NZ,CORW         ; char not recognized, wait again
 493+ 0313 CD 1C 03                     call    ECHO_CHAR       ; echoes the char
 494+ 0316 CD 3B 09                     call    CURSOR_OFF      ; disable cursor
 495+ 0319 C3 C4 12                     jp      WARM            ; start BASIC WARM
 496+ 031C
 497+ 031C              ;-------------------------------------------------------------------------------
 498+ 031C              ; send back char received through ch. A
 499+ 031C 32 79 55     ECHO_CHAR:      ld      (CHR4VID),A     ; set char for video printing
 500+ 031F AF                           xor     A
 501+ 0320 32 B6 55                     ld      (KBDNPT),A      ; input is not from keyboard
 502+ 0323 F3                           di                      ; disable INTs
 503+ 0324 CD 5A 07                     call    CHAR2VID        ; echoes back the pressed key,
 504+ 0327 3E 0D                        ld      A,CR            ; then set a CR
 505+ 0329 32 79 55                     ld      (CHR4VID),A     ; set char for video printing
 506+ 032C CD 5A 07                     call    CHAR2VID        ; and send it to screen
 507+ 032F FB                           ei                      ; re-enable INTs
 508+ 0330 3E 01                        ld      A,$01
 509+ 0332 32 78 55                     ld      (PRNTVIDEO),A   ; re-enable video printing
 510+ 0335 C9                           ret                     ; return to caller
 511+ 0336
 512+ 0336
 513+ 0336              ;-------------------------------------------------------------------------------
 514+ 0336              ; Z80 SIO default settings for serial channels
 515+ 0336 30           SIO_A_SETS:     defb    %00110000       ; write into WR0: error reset, select WR0
 516+ 0337 18                           defb    %00011000       ; write into WR0: channel reset
 517+ 0338 04                           defb    %00000100       ; write into WR0: select WR4
 518+ 0339 44                           defb    %01000100       ; write into WR4: presc. 16x, 1 stop bit, no parity
 519+ 033A 05                           defb    %00000101       ; write into WR0: select WR5
 520+ 033B E8                           defb    %11101000       ; write into WR5: DTR on, TX 8 bits, BREAK off, TX on, RTS off
 521+ 033C 01           SIO_B_SETS:     defb    %00000001       ; write into WR0: select WR1
 522+ 033D 04                           defb    %00000100       ; write into WR1: status affects interrupt vectors
 523+ 033E 02                           defb    %00000010       ; write into WR0: select WR2
 524+ 033F 00                           defb    %00000000       ; write into WR2: set interrupt vector, but bits D3/D2/D1 of this vector
 525+ 0340                                                      ; will be affected by the channel & condition that raised the interrupt
 526+ 0340                                                      ; (see datasheet): in our example, 0x0C for Ch.A receiving A char, 0x0E
 527+ 0340                                                      ; for special conditions
 528+ 0340              ;------------------------------------------------------------------------------
 529+ 0340              ;               Z80 CTC SETTING UP
 530+ 0340              ;------------------------------------------------------------------------------
 531+ 0340              initCTC:
 532+ 0340 21 6A 03                     ld      HL,CTCCONF      ; CTC configuration
 533+ 0343 11 60 55                     ld      DE,CTC0IV       ; CTC interrupt vector table
 534+ 0346 01 0C 00                     ld      BC,$000C        ; 12 bytes
 535+ 0349 ED B0                        ldir                    ; copy data
 536+ 034B              ;CH0, CH1, & CH2 disabled
 537+ 034B 3E 03                        ld      A,%00000011     ; interrupt off, timer mode, prescaler=16, don't care ext. TRG edge,
 538+ 034D                                                      ; start timer on loading constant, no time constant follows, software reset, command word
 539+ 034D D3 10                        out     (CTC_CH0),A     ; set CH0
 540+ 034F D3 11                        out     (CTC_CH1),A     ; set CH1
 541+ 0351 D3 12                        out     (CTC_CH2),A     ; set CH2
 542+ 0353              ;init CH3
 543+ 0353              ;CH3 divides CPU CLK by 144*256 providing an interrupt signal at 100 Hz (1/100 sec).
 544+ 0353              ;f = CPU_CLK/(144*256) => 3,686,400 / ( 36,864 ) => 100Hz
 545+ 0353 3E A7                        ld      A,%10100111     ; interrupt on; timer mode; prescaler=256; don't care ext; automatic trigger;
 546+ 0355                                                      ; time constant follows; cont. operation; command word
 547+ 0355 D3 13                        out     (CTC_CH3),A     ; send to CH3
 548+ 0357 3E 90                        ld      A,$90           ; time constant - 90$ (144d)
 549+ 0359 D3 13                        out     (CTC_CH3),A     ; send to CH3
 550+ 035B 3E 40                        ld      A,%01000000     ; D7..D3 provide the first part of the int vector (in our case, $0100), followed by
 551+ 035D                                                      ; D2..D1, provided by the CTC (they point to the channel), D0=interrupt word
 552+ 035D                                                      ; so int vector is 01000xx00
 553+ 035D D3 10                        out     (CTC_CH0),A     ; send to CTC
 554+ 035F                              ; reset cells of 100ths of a second counter
 555+ 035F AF                           xor     A               ; reset A
 556+ 0360 21 5C 55                     ld      HL,TMRCNT       ; load TMR pointer
 557+ 0363 06 04                        ld      B,$04           ; 4 memory cells
 558+ 0365 77           RESTMR:         ld      (HL),A          ; reset n-cell of TMR
 559+ 0366 23                           inc     HL              ; next cell
 560+ 0367 10 FC                        djnz    RESTMR          ; repeat for 4 cells
 561+ 0369 C9                           ret
 562+ 036A
 563+ 036A
 564+ 036A              ;------------------------------------------------------------------------------
 565+ 036A              ; jump table for CHx interrupts
 566+ 036A FB ED 4D     CTCCONF:        defb    $FB,$ED,$4D     ; CTC0 interrupt vector (ei; reti)
 567+ 036D FB ED 4D                     defb    $FB,$ED,$4D     ; CTC1 interrupt vector (ei; reti)
 568+ 0370 FB ED 4D                     defb    $FB,$ED,$4D     ; CTC2 interrupt vector (ei; reti)
 569+ 0373 C3 8B 02                     jp      CH3_TIMER       ; CTC3 interrupt vector (jump to execute sys-tick timer)
 570+ 0376
 571+ 0376
 572+ 0376              ;------------------------------------------------------------------------------
 573+ 0376              ; welcome messages
 574+ 0376              MSGTXT1:
 575+ 0376 20 20 20 20                  defm    "    LM80C 64K Color Computer",CR
 575+ 037A 4C 4D 38 30
 575+ 037E 43 20 36 34
 575+ 0382 4B 20 43 6F
 575+ 0386 6C 6F 72 20
 575+ 038A 43 6F 6D 70
 575+ 038E 75 74 65 72
 575+ 0392 0D
 576+ 0393 20 62 79 20                  defm    " by Leonardo Miliani * FW R","1.16",CR,0
 576+ 0397 4C 65 6F 6E
 576+ 039B 61 72 64 6F
 576+ 039F 20 4D 69 6C
 576+ 03A3 69 61 6E 69
 576+ 03A7 20 2A 20 46
 576+ 03AB 57 20 52 31
 576+ 03AF 2E 31 36 0D
 576+ 03B3 00
 577+ 03B4 0D           MSGTXT2:        defb    CR
 578+ 03B5 20 20 20 3C                  defm    "   <C>old or <W>arm start? ",0
 578+ 03B9 43 3E 6F 6C
 578+ 03BD 64 20 6F 72
 578+ 03C1 20 3C 57 3E
 578+ 03C5 61 72 6D 20
 578+ 03C9 73 74 61 72
 578+ 03CD 74 3F 20 00
 579+ 03D1
# file closed: ../include/bootloader/bootloader-1.07.asm
  67  03D1
  68  03D1              ; incude the latest version of the VDP module
  69  03D1                  INCLUDE "../include/vdp/vdp-1.07.asm"
# file opened: ../include/vdp/vdp-1.07.asm
   1+ 03D1              ; ------------------------------------------------------------------------------
   2+ 03D1              ; LM80C - VDP ROUTINES - 1.07
   3+ 03D1              ; ------------------------------------------------------------------------------
   4+ 03D1              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 03D1              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 03D1              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 03D1              ; kind of warranty: you can use them at your own risk.
   8+ 03D1              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 03D1              ; maintain the copyright notices, include this advice and the note to the
  10+ 03D1              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 03D1              ; redistribuite them.
  12+ 03D1              ; https://www.leonardomiliani.com
  13+ 03D1              ;
  14+ 03D1              ; Please support me by visiting the following links:
  15+ 03D1              ; Main project page: https://www.leonardomiliani.com
  16+ 03D1              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 03D1              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 03D1              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 03D1              ; ------------------------------------------------------------------------------
  20+ 03D1              ;
  21+ 03D1              ;------------------------------------------------------------------------------
  22+ 03D1              ; VDP INITIALISATION
  23+ 03D1              ; initialize VDP for a specific graphics mode
  24+ 03D1              ; INPUT: E -> contains the graphics mode:
  25+ 03D1              ; 0=text; 1=graphics 1; 2=graphics 2; 3=multicolor; 4=extended graphics 2
  26+ 03D1 D5           initVDP:        push    DE              ; store E
  27+ 03D2 CD C8 0A                     call    EMPTY_VRAM      ; reset VRAM
  28+ 03D5 CD E6 0A                     call    SET_GFX_MODE    ; load register settings
  29+ 03D8 CD DB 0A                     call    CLR_RAM_REG     ; reset RAM registers
  30+ 03DB D1                           pop     DE              ; restore reg. E
  31+ 03DC AF                           xor     A               ; reset A
  32+ 03DD 47                           ld      B,A             ; reset B (will be used later)
  33+ 03DE 7B                           ld      A,E             ; move E into A
  34+ 03DF 32 6E 55                     ld      (SCR_MODE),A    ; store screen mode
  35+ 03E2 FE 01                        cp      $01             ; is it graphics 1 (A=1)?
  36+ 03E4 CA 20 04                     jp      Z,G1MD          ; yes, jump over
  37+ 03E7 FE 02                        cp      $02             ; is it graphics 2 (A=2)?
  38+ 03E9 CA 60 04                     jp      Z,G2MD          ; yes, jump over
  39+ 03EC FE 03                        cp      $03             ; is it multicolor (A=3)?
  40+ 03EE CA 82 04                     jp      Z,MCMD          ; yes, jump over
  41+ 03F1 FE 04                        cp      $04             ; is it extended graphics 2 (A=4)?
  42+ 03F3 CA A5 04                     jp      Z,EXG2MD        ; yes, jump over
  43+ 03F6                              ; otherwise, it must be $00 so we assume that it's text mode
  44+ 03F6
  45+ 03F6              ; LOAD VDP SETTINGS FOR SELECTED VIDEO MODE:
  46+ 03F6
  47+ 03F6                              ; TEXT MODE (G0)
  48+ 03F6                              ; load charset
  49+ 03F6 60           TXTMD:          ld      H,B
  50+ 03F7 68                           ld      L,B             ; HL=first pattern cell $0000
  51+ 03F8 CD 02 0B                     call    LOADCHARSET     ; load patterns into VRAM
  52+ 03FB                              ; set cursor & video overlay
  53+ 03FB AF                           xor     A               ; reset A
  54+ 03FC 32 71 55                     ld      (SCR_CURS_X),A  ; set cursor position at X=0
  55+ 03FF 32 72 55                     ld      (SCR_CURS_Y),A  ; and Y=0
  56+ 0402 3E 05                        ld      A,$05           ; light blue
  57+ 0404 32 7B 55                     ld      (BKGNDCLR),A    ; set background/border color
  58+ 0407 3E 28                        ld      A,$28
  59+ 0409 32 6C 55                     ld      (SCR_SIZE_W),A  ; screen width = 40 cols
  60+ 040C 3E 18                        ld      A,$18
  61+ 040E 32 6D 55                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  62+ 0411 3E 1E                        ld      A,$1E
  63+ 0413 32 1D 54                     ld      (COMMAN),A      ; width for commas (4 columns)
  64+ 0416 11 00 08                     ld      DE,$0800
  65+ 0419 ED 53 6F 55                  ld      (SCR_NAM_TB),DE ; set name table address
  66+ 041D C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
  67+ 0420
  68+ 0420                              ; GRAPHICS 1 MODE (G1)
  69+ 0420                              ; load pattern table
  70+ 0420 68           G1MD:           ld      L,B
  71+ 0421 60                           ld      H,B             ; HL=first pattern cell $0000
  72+ 0422 CD 02 0B                     call    LOADCHARSET     ; load patterns into VRAM
  73+ 0425                              ; set cursor & video overlay
  74+ 0425 AF                           xor     A               ; position cursor
  75+ 0426 32 71 55                     ld      (SCR_CURS_X),A  ; at X=0
  76+ 0429 32 72 55                     ld      (SCR_CURS_Y),A  ; and Y=0
  77+ 042C 3E 20                        ld      A,$20
  78+ 042E 32 6C 55                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
  79+ 0431 3E 18                        ld      A,$18
  80+ 0433 32 6D 55                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  81+ 0436 3E 14                        ld      A,$14
  82+ 0438 32 1D 54                     ld      (COMMAN),A      ; width for commas (3 columns)
  83+ 043B 11 00 18                     ld      DE,$1800
  84+ 043E ED 53 6F 55                  ld      (SCR_NAM_TB),DE ; set name table address
  85+ 0442                              ; load color table
  86+ 0442 21 00 20                     ld      HL,$2000        ; color table start: $2000
  87+ 0445 CD 69 06                     call    SETVDPADRS
  88+ 0448 3E 01                        ld      A,$01           ; foreground color...
  89+ 044A 32 7A 55                     ld      (FRGNDCLR),A    ; ...set to black
  90+ 044D 3E 0F                        ld      A,$0F           ; background color...
  91+ 044F 32 7B 55                     ld      (BKGNDCLR),A    ; ...set to white
  92+ 0452 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
  93+ 0454 06 20                        ld      B,$20           ; 32 bytes of colors
  94+ 0456 0D                           dec     C               ; VDP data mode
  95+ 0457 ED 79        LDCLRTBMD1:     out     (C),A           ; after the first byte, the VDP autoincrements VRAM pointer
  96+ 0459 00                           nop
  97+ 045A 00                           nop
  98+ 045B 10 FA                        djnz    LDCLRTBMD1      ; repeat for 32 bytes
  99+ 045D C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 100+ 0460
 101+ 0460                              ; GRAPHICS 2 MODE (G2)
 102+ 0460 AF           G2MD:           xor     A               ; position cursor
 103+ 0461 32 71 55                     ld      (SCR_CURS_X),A  ; at X=0
 104+ 0464 32 72 55                     ld      (SCR_CURS_Y),A  ; and Y=0
 105+ 0467 32 6C 55                     ld      (SCR_SIZE_W),A  ; screen width = 256 pixels (0=256)
 106+ 046A 3C                           inc     A               ; black on...
 107+ 046B 32 7A 55                     ld      (FRGNDCLR),A    ; ...foreground
 108+ 046E 3E 0F                        ld      A,$0F           ; white on...
 109+ 0470 32 7B 55                     ld      (BKGNDCLR),A    ; ...background
 110+ 0473 3E C0                        ld      A,$C0
 111+ 0475 32 6D 55                     ld      (SCR_SIZE_H),A  ; screen height = 192 pixels
 112+ 0478 11 00 18                     ld      DE,$1800
 113+ 047B ED 53 6F 55                  ld      (SCR_NAM_TB),DE ; set name table address
 114+ 047F C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 115+ 0482
 116+ 0482                              ; MULTICOLOR MODE (G3)
 117+ 0482 AF           MCMD:           xor     A               ; position cursor
 118+ 0483 32 71 55                     ld      (SCR_CURS_X),A  ; at X=0
 119+ 0486 32 72 55                     ld      (SCR_CURS_Y),A  ; and Y=0
 120+ 0489 3E 0F                        ld      A,$0F           ; white color for...
 121+ 048B 32 7B 55                     ld      (BKGNDCLR),A    ; ...background and...
 122+ 048E 32 7A 55                     ld      (FRGNDCLR),A    ; ...foreground (even this is not used in MC)
 123+ 0491 3E 40                        ld      A,$40
 124+ 0493 32 6C 55                     ld      (SCR_SIZE_W),A  ; screen width = 64 blocks
 125+ 0496 3E 30                        ld      A,$30
 126+ 0498 32 6D 55                     ld      (SCR_SIZE_H),A  ; screen height = 48 blocks
 127+ 049B 11 00 08                     ld      DE,$0800
 128+ 049E ED 53 6F 55                  ld      (SCR_NAM_TB),DE ; set name table address
 129+ 04A2 C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 130+ 04A5
 131+ 04A5                              ; EXTENDED GRAPHICS 2 (G4)
 132+ 04A5              EXG2MD:         ; load pattern table
 133+ 04A5 60                           ld      H,B
 134+ 04A6 68                           ld      L,B             ; HL=first pattern cell $0000
 135+ 04A7 CD 02 0B                     call    LOADCHARSET     ; load patterns into VRAM
 136+ 04AA                              ; set cursor & video overlay
 137+ 04AA AF                           xor     A               ; position cursor
 138+ 04AB 32 71 55                     ld      (SCR_CURS_X),A  ; at X=0
 139+ 04AE 32 72 55                     ld      (SCR_CURS_Y),A  ; and Y=0
 140+ 04B1 3E 20                        ld      A,$20
 141+ 04B3 32 6C 55                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
 142+ 04B6 3E 18                        ld      A,$18
 143+ 04B8 32 6D 55                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
 144+ 04BB 3E 14                        ld      A,$14
 145+ 04BD 32 1D 54                     ld      (COMMAN),A      ; width for commas (3 columns)
 146+ 04C0 11 00 38                     ld      DE,$3800
 147+ 04C3 ED 53 6F 55                  ld      (SCR_NAM_TB),DE ; set name table address
 148+ 04C7                               ; load color table
 149+ 04C7 21 00 20                     ld      HL,$2000        ; color table start: $2000
 150+ 04CA CD 69 06                     call    SETVDPADRS
 151+ 04CD 3E 01                        ld      A,$01           ; foreground color is...
 152+ 04CF 32 7A 55                     ld      (FRGNDCLR),A    ; ...set to black
 153+ 04D2 3E 0F                        ld      A,$0F           ; whitefor...
 154+ 04D4 32 7B 55                     ld      (BKGNDCLR),A    ; ...background
 155+ 04D7 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
 156+ 04D9 16 08                        ld      D,$08           ; 8 pages of
 157+ 04DB 06 00                        ld      B,$00           ; 256 bytes of colors (total of 2,048 cells)
 158+ 04DD 0D                           dec     C               ; VDP data mode
 159+ 04DE ED 79        LDCLRTBEX2:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
 160+ 04E0 00                           nop
 161+ 04E1 00                           nop
 162+ 04E2 10 FA                        djnz    LDCLRTBEX2      ; repeat for 256 bytes
 163+ 04E4 15                           dec     D               ; did we fill up all the cells?
 164+ 04E5 20 F7                        jr      NZ,LDCLRTBEX2   ; no, repeat
 165+ 04E7                              ; LAST VDP SETTINGS
 166+ 04E7 CD 3B 09     ENDVDPSET:      call    CURSOR_OFF      ; disable cursor
 167+ 04EA CD DB 05                     call    EMPTYVIDBUF     ; empty video buffer
 168+ 04ED AF                           xor     A
 169+ 04EE 32 75 55                     ld      (SCR_ORG_CHR),A ; store byte used tochar used to empty the video buffer
 170+ 04F1 C9                           ret                     ; return to caller
 171+ 04F2
 172+ 04F2
 173+ 04F2              ; show initial logo
 174+ 04F2 CD C8 0A     SHOW_LOGO:      call    EMPTY_VRAM      ; reset VRAM
 175+ 04F5                              ; set VDP for G2 mode
 176+ 04F5 06 07                        ld      B,$07           ; set only the first 7 registers
 177+ 04F7 11 10 00                     ld      DE,$0010        ; load settings for G2 mode
 178+ 04FA CD EE 0A                     call    SET_GFX_MODE2   ; load register settings
 179+ 04FD 16 01                        ld      D,$01           ; backdrop color set to black
 180+ 04FF ED 51                        out     (C),D           ; send data to VDP
 181+ 0501 ED 79                        out     (C),A           ; indicate the register to send data to
 182+ 0503                              ; set name table
 183+ 0503 21 00 18                     ld      HL,$1800        ; name table address
 184+ 0506 CD 57 06                     call    SETNAMETABLE    ; set name table (load names into table)
 185+ 0509 CD 6C 05                     call    ERASECLRTBL     ; erase color table (set foreground & background to black)
 186+ 050C                              ; set colors for logo
 187+ 050C 21 00 28                     ld      HL,$2800        ; 2nd page of color table
 188+ 050F CD 69 06                     call    SETVDPADRS
 189+ 0512 06 05                        ld      B,$05           ; 5 bands
 190+ 0514 21 B7 05                     ld      HL,CLRTABLE
 191+ 0517 0D                           dec     C               ; set VDP_DAT
 192+ 0518 1E 08                        ld      E,$08           ; 8 pixels each pattern
 193+ 051A 16 40        RPT101:         ld      D,$40           ; 64 chars each band
 194+ 051C 7E                           ld      A,(HL)          ; load data
 195+ 051D ED 79        RPT102:         out     (C),A           ; send it to VRAM
 196+ 051F 00                           nop                     ; little delay
 197+ 0520 1D                           dec     E               ; decrement counter
 198+ 0521 20 FA                        jr      NZ,RPT102       ; repeat until zero
 199+ 0523 1E 08                        ld      E,$08           ; 8 pixels each pattern
 200+ 0525 15                           dec     D               ; decrement char band counter
 201+ 0526 20 F5                        jr      NZ,RPT102       ; repeat until zero
 202+ 0528 23                           inc     HL              ; next pattern
 203+ 0529 10 EF                        djnz    RPT101          ; repeat until covered every band
 204+ 052B                              ; set pattern table
 205+ 052B 21 00 08                     ld      HL,$0800        ; address of first cell of 2nd area of pattern table
 206+ 052E 11 4A 0B                     ld      DE,LM80CLOGO    ; pointer to logo pattern
 207+ 0531 06 00                        ld      B,$00           ; 256 bytes, 8 rows
 208+ 0533 CD 97 05     RPT103:         call    LOADLOGOCHRS
 209+ 0536 13                           inc     DE              ; next logo pattern
 210+ 0537 10 FA                        djnz    RPT103
 211+ 0539 06 20                        ld      B,$20           ; repeat for another 2 rows
 212+ 053B CD 97 05     RPT104:         call    LOADLOGOCHRS
 213+ 053E 13                           inc     DE              ; next logo pattern
 214+ 053F 10 FA                        djnz    RPT104
 215+ 0541                              ; show logo/message, play a beep, check for CTRL pressing (to disable DOS), and wait a while
 216+ 0541 06 02                        ld      B,$02           ; two times
 217+ 0543 AF                           xor     A               ; reset A
 218+ 0544 57                           ld      D,A             ; 256 times
 219+ 0545 5F                           ld      E,A             ; x 256 times
 220+ 0546 32 7C 55                     ld      (TMPBFR1),A     ; sound flag set to 0
 221+ 0549 3C                           inc     A               ; by default, I/O DOS buffer is enabled
 222+ 054A 32 C1 55                     ld      (DOS_EN),A      ; DOS enabled
 223+ 054D 00           DEC_D:          nop                     ; does nothing...
 224+ 054E 00                           nop
 225+ 054F 00                           nop
 226+ 0550 00                           nop
 227+ 0551 00                           nop
 228+ 0552 00                           nop                     ; ...until here
 229+ 0553 1D                           dec     E               ; decrement E
 230+ 0554 20 F7                        jr      NZ,DEC_D        ; repeat until $00
 231+ 0556 7A                           ld      A,D
 232+ 0557 FE 40                        cp      $40             ; ...equal to 64
 233+ 0559 CC 83 05                     call    Z,SETBEEP       ; if yes, start sound
 234+ 055C 15                           dec     D
 235+ 055D 20 EE                        jr      NZ,DEC_D        ; repeat
 236+ 055F 3A 7C 55                     ld      A,(TMPBFR1)     ; sound state
 237+ 0562 FE 02                        cp      $02             ; check if sound is to be set off
 238+ 0564 C4 8F 05                     call    NZ,BEEPOFF      ; yes
 239+ 0567 CD BC 05                     call    CHKSPCK         ; check if special key (CTRL) has been pressed on keyboard
 240+ 056A                                                      ; on LM80C 64K, you can disabled the I/O DOS buffer
 241+ 056A 10 E1                        djnz    DEC_D           ; repeat
 242+ 056C              ERASECLRTBL:    ; erase color table
 243+ 056C 3E 11                        ld      A,$11           ; foreground and background set to black
 244+ 056E 16 0A                        ld      D,$0A           ; 10 pages
 245+ 0570 06 00                        ld      B,$00           ; 256 color cells per page
 246+ 0572 21 00 28                     ld      HL,$2800        ; first cell of 2nd color table
 247+ 0575 CD 69 06                     call    SETVDPADRS      ; send address
 248+ 0578 0D                           dec     C               ; VDP address for passing data
 249+ 0579 ED 79        RPT100:         out     (C),A           ; send data
 250+ 057B 00                           nop
 251+ 057C 00                           nop                     ; little delay
 252+ 057D 10 FA                        djnz    RPT100          ; repeat for entire page
 253+ 057F 15                           dec     D
 254+ 0580 20 F7                        jr      NZ,RPT100       ; repeat for all the pages ($0A00 cells)
 255+ 0582 C9                           ret                     ; return to caller
 256+ 0583
 257+ 0583              ; play a beep
 258+ 0583 3A 7C 55     SETBEEP:        ld      A,(TMPBFR1)     ; check the already-beeped flag
 259+ 0586 B7                           or      A               ; is it 0?
 260+ 0587 C0                           ret     NZ              ; no, exit
 261+ 0588 3C                           inc     A               ; flag to 1
 262+ 0589 32 7C 55                     ld      (TMPBFR1),A     ; set sound
 263+ 058C C3 B8 0C                     jp      WLCMBEEP        ; play a beep & return
 264+ 058F
 265+ 058F              ; beep off
 266+ 058F 3E 02        BEEPOFF:        ld      A,$02           ; flag for sound off
 267+ 0591 32 7C 55                     ld      (TMPBFR1),A     ; set flag
 268+ 0594 C3 BE 0C                     jp      NOBEEP          ; stop beep and return
 269+ 0597
 270+ 0597
 271+ 0597              ; used to load the chars that will compose the logo of the splash screen
 272+ 0597 1A           LOADLOGOCHRS:   ld      A,(DE)          ; load a pattern char of the logo
 273+ 0598 87                           add     A,A
 274+ 0599 87                           add     A,A
 275+ 059A 87                           add     A,A             ; multiply times 8 to get the offset
 276+ 059B C5                           push    BC
 277+ 059C D5                           push    DE              ; store BC and DE
 278+ 059D E5                           push    HL              ; store VRAM address to write to
 279+ 059E 21 6B 52                     ld      HL,LOGOFONT     ; start of logo font data
 280+ 05A1 5F                           ld      E,A
 281+ 05A2 16 00                        ld      D,$00           ; put offset (A) into DE
 282+ 05A4 19                           add     HL,DE           ; get address of pattern data
 283+ 05A5 EB                           ex      DE,HL           ; move address into DE
 284+ 05A6 E1                           pop     HL              ; retrieve VRAM address
 285+ 05A7 06 08                        ld      B,$08           ; 8 bytes per pattern
 286+ 05A9 CD 69 06                     call    SETVDPADRS      ; set VDP address
 287+ 05AC 0D                           dec     C               ; VDP_DAT
 288+ 05AD 1A           SNDLOGPT:       ld      A,(DE)          ; load data from RAM
 289+ 05AE ED 79                        out     (C),A           ; and send to VRAM
 290+ 05B0 13                           inc     DE              ; next byte into RAM
 291+ 05B1 23                           inc     HL              ; next byte into VRAM (used in future iterations)
 292+ 05B2 10 F9                        djnz    SNDLOGPT        ; repeat 8 times
 293+ 05B4 D1                           pop     DE
 294+ 05B5 C1                           pop     BC              ; retrieve BC & DE
 295+ 05B6 C9                           ret                     ; return to caller
 296+ 05B7              CLRTABLE:       equ $
 297+ 05B7 18 1B 13 14                  defb    $18,$1B,$13,$14,$1D ; colors of background bands of the logo
 297+ 05BB 1D
 298+ 05BC
 299+ 05BC
 300+ 05BC              ; while showing the logo, check if special key (CTRL) is being pressed
 301+ 05BC              ; if yes, then disable DOS functions recovering RAM
 302+ 05BC F5           CHKSPCK:        push    AF
 303+ 05BD 3E FE                        ld      A,%11111110     ; select CTRL row
 304+ 05BF CD 3C 0D                     call    READKBLN        ; read row
 305+ 05C2 CB 5F                        bit     3,A             ; test for RUN/STOP
 306+ 05C4 CA D4 05                     jp      Z,DOCOLDRESET   ; yes, do a cold reset
 307+ 05C7 CB 57                        bit     2,A             ; test if CTRL key is pressed
 308+ 05C9 20 07                        jr      NZ,LVCKSPLK     ; no, leave
 309+ 05CB AF                           xor     A               ; yes, so...
 310+ 05CC 32 C1 55                     ld      (DOS_EN),A      ; ...disable DOS
 311+ 05CF 32 D7 53                     ld      (basicStarted),A; reset BASIC warm start
 312+ 05D2 F1           LVCKSPLK:       pop     AF
 313+ 05D3 C9                           ret
 314+ 05D4 AF           DOCOLDRESET:    xor     A               ; reset A
 315+ 05D5 32 D7 53                     ld      (basicStarted),A; reset BASIC warm start
 316+ 05D8 C3 00 00                     jp      $0000           ; restart
 317+ 05DB
 318+ 05DB
 319+ 05DB              ; empty video buffer
 320+ 05DB 3A 6E 55     EMPTYVIDBUF:    ld      A,(SCR_MODE)    ; check screen mode
 321+ 05DE FE 02                        cp      $02             ; is it G2 mode?
 322+ 05E0 CA 03 06                     jp      Z,EMPTYG2       ; yes, jump over
 323+ 05E3 FE 03                        cp      $03             ; is it MC mode?
 324+ 05E5 CA 33 06                     jp      Z,EMPTYMC       ; yes, jump over
 325+ 05E8 3A 6D 55                     ld      A,(SCR_SIZE_H)  ; load height of screen
 326+ 05EB 47                           ld      B,A             ; move rows into B
 327+ 05EC AF                           xor     A               ; filling char is $00
 328+ 05ED 2A 6F 55                     ld      HL,(SCR_NAM_TB) ; load the name table address
 329+ 05F0 CD 69 06                     call    SETVDPADRS      ; send address to VDP
 330+ 05F3 0D                           dec     C               ; VDP address for passing data
 331+ 05F4 5F           LDCOLSTOEMPTY:  ld      E,A             ; store filling char into E
 332+ 05F5 3A 6C 55                     ld      A,(SCR_SIZE_W)  ; load # of cols to empty into A
 333+ 05F8 57                           ld      D,A             ; move A into D
 334+ 05F9 7B                           ld      A,E             ; recover filling char
 335+ 05FA ED 79        RPTEMPTYBUF:    out     (C),A           ; write empty byte into VRAM
 336+ 05FC 00                           nop
 337+ 05FD 15                           dec     D               ; decr. D
 338+ 05FE 20 FA                        jr      NZ,RPTEMPTYBUF  ; repeat for the # of cols
 339+ 0600 10 F2                        djnz    LDCOLSTOEMPTY   ; repeat for the # of rows
 340+ 0602 C9                           ret                     ; return to caller
 341+ 0603 2A 6F 55     EMPTYG2:        ld      HL,(SCR_NAM_TB) ; yes, additional setup for G2 - load G2 name table address (usually $1800)
 342+ 0606 CD 57 06                     call    SETNAMETABLE    ; set name table
 343+ 0609 21 00 00                     ld      HL,$0000        ; set pattern table
 344+ 060C CD 69 06                     call    SETVDPADRS      ; send address to VDP
 345+ 060F AF                           xor     A               ; empty pattern
 346+ 0610 16 18                        ld      D,$18           ; 6144 ($1800) cell to clean, 24 pages ($18)
 347+ 0612 47                           ld      B,A             ; 256 bytes for page
 348+ 0613 0D                           dec     C               ; VDP data mode
 349+ 0614 ED 79        CLRG2PTNTBL:    out     (C),A           ; clear pattern
 350+ 0616 00                           nop                     ; little delay
 351+ 0617 00                           nop
 352+ 0618 10 FA                        djnz    CLRG2PTNTBL     ; repeat for 1 page
 353+ 061A 15                           dec     D               ; next page
 354+ 061B 20 F7                        jr      NZ,CLRG2PTNTBL  ; repeat
 355+ 061D 21 00 20                     ld      HL,$2000        ; load the color table address
 356+ 0620 CD 69 06                     call    SETVDPADRS      ; send address to VDP
 357+ 0623 3A 7A 55                     ld      A,(FRGNDCLR)    ; load foreground
 358+ 0626 87                           add     A,A
 359+ 0627 87                           add     A,A
 360+ 0628 87                           add     A,A
 361+ 0629 87                           add     A,A             ; move to high nibble
 362+ 062A 57                           ld      D,A             ; store into D
 363+ 062B 3A 7B 55                     ld      A,(BKGNDCLR)    ; load background color
 364+ 062E B2                           or      D               ; combine with background color
 365+ 062F 16 18                        ld      D,$18           ; 6144 ($1800) cells to fill, so 24 pages ($18)
 366+ 0631 18 17                        jr      STARTEMPTY
 367+ 0633 21 00 08     EMPTYMC:        ld      HL,$0800        ; MC name table
 368+ 0636 CD 57 06                     call    SETNAMETABLE    ; set name table
 369+ 0639 21 00 00                     ld      HL,$0000        ; color table address
 370+ 063C CD 69 06                     call    SETVDPADRS      ; send address to VDP
 371+ 063F 3A 7B 55                     ld      A,(BKGNDCLR)    ; load background
 372+ 0642 57                           ld      D,A             ; store into D
 373+ 0643 87                           add     A,A
 374+ 0644 87                           add     A,A
 375+ 0645 87                           add     A,A
 376+ 0646 87                           add     A,A             ; move to high nibble
 377+ 0647 B2                           or      D               ; set background color for high and low nibble
 378+ 0648 16 08                        ld      D,$08           ; 2048 ($0800) cells to fill, so 8 pages ($08)
 379+ 064A 0D           STARTEMPTY:     dec     C               ; VDP address for passing data
 380+ 064B 06 00                        ld      B,$00           ; 256 bytes each page ($00=256)
 381+ 064D ED 79        SNDCLRSET:      out     (C),A           ; send color setting
 382+ 064F 00                           nop                     ; wait a while
 383+ 0650 00                           nop
 384+ 0651 10 FA                        djnz    SNDCLRSET       ; repeat for 1 page
 385+ 0653 15                           dec     D               ; have we filled all the pages?
 386+ 0654 20 F7                        jr      NZ,SNDCLRSET    ; no, repeat
 387+ 0656 C9                           ret                     ; return to caller
 388+ 0657
 389+ 0657              ; set name table for G2 mode (patterns from $00 to $FF for each of the 3 areas of the screen)
 390+ 0657 CD 69 06     SETNAMETABLE:   call    SETVDPADRS      ; send address to VDP
 391+ 065A 0D                           dec     C               ; VDP address for passing data
 392+ 065B 16 03                        ld      D,$03           ; 3 pages to fill into VRAM (768 cells)
 393+ 065D AF                           xor     A               ; starting char name #0 (chars go from 0 to 255)
 394+ 065E 47                           ld      B,A             ; reset B
 395+ 065F ED 79        RPTFLL1:        out     (C),A           ; send name to VRAM
 396+ 0661 00                           nop
 397+ 0662 3C                           inc     A               ; increment # of name
 398+ 0663 10 FA                        djnz    RPTFLL1         ; repeat for 256 cells (1 page)
 399+ 0665 15                           dec     D               ; did we fill all the pages?
 400+ 0666 20 F7                        jr      NZ,RPTFLL1      ; no, continue
 401+ 0668 C9                           ret                     ; return to caller
 402+ 0669
 403+ 0669              ; set an address into VRAM: address is in HL - HL is changed after it
 404+ 0669 0E 31        SETVDPADRS:     ld      C,VDP_SET       ; VDP address mode
 405+ 066B CB F4                        set     6,H             ; set bit #6 of address, to write to VRAM
 406+ 066D ED 69                        out     (C),L           ; send low and...
 407+ 066F ED 61                        out     (C),H           ; ...high byte of the first cell
 408+ 0671 C9                           ret                     ; return to caller
 409+ 0672
 410+ 0672              ; clear the video buffer and position the cursor at 0,0
 411+ 0672 CD DB 05     CLEARVIDBUF:    call    EMPTYVIDBUF     ; clear video buffer
 412+ 0675 AF                           xor     A               ; reset A
 413+ 0676 32 71 55                     ld      (SCR_CURS_X),A  ; cursor X to 0
 414+ 0679 32 72 55                     ld      (SCR_CURS_Y),A  ; cursor Y to 0
 415+ 067C C3 C5 06                     jp      POS_CURSOR      ; position cursor & return to caller
 416+ 067F
 417+ 067F              ; HOME: position the cursor at coords. 0,0
 418+ 067F AF           ATHOME:         xor     A               ; position cursor at 0,0 by storing...
 419+ 0680 32 74 55                     ld      (SCR_CUR_NY),A  ; ...new Y...
 420+ 0683 32 73 55                     ld      (SCR_CUR_NX),A  ; ...and new X
 421+ 0686 C3 CF 06                     jp      MOVCRS          ; move cursor to new location & return to caller
 422+ 0689
 423+ 0689              ; load the char or byte at the VRAM position set by HL
 424+ 0689              ; value is returned into A
 425+ 0689 C5           READ_VIDEO_LOC: push    BC              ; store BC
 426+ 068A 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 427+ 068C 44                           ld      B,H
 428+ 068D CB B8                        res     7,B
 429+ 068F CB B0                        res     6,B
 430+ 0691 ED 69                        out     (C),L           ; low byte then...
 431+ 0693 ED 41                        out     (C),B           ; high byte
 432+ 0695 0D                           dec     C               ; VDP data mode
 433+ 0696 00                           nop                     ; added to compensate shorter instruction
 434+ 0697 00                           nop                     ; wait...
 435+ 0698 00                           nop                     ; ...a while
 436+ 0699 00                           nop
 437+ 069A ED 78                        in      A,(C)           ; read byte at current VRAM location
 438+ 069C C1                           pop     BC              ; restore BC
 439+ 069D C9                           ret                     ; return to caller
 440+ 069E
 441+ 069E              ; write a byte at the VRAM position pointed by HL
 442+ 069E              ; value is in A
 443+ 069E C5           WRITE_VIDEO_LOC:push    BC              ; store BC
 444+ 069F 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 445+ 06A1 44                           ld      B,H             ; copy H into B
 446+ 06A2 CB B8                        res     7,B
 447+ 06A4 CB F0                        set     6,B             ; write to VRAM
 448+ 06A6 ED 69                        out     (C),L           ; low byte then...
 449+ 06A8 ED 41                        out     (C),B           ; high byte of VRAM address
 450+ 06AA 0D                           dec     C               ; VDP data mode
 451+ 06AB 00                           nop                     ; added to compensate shorter instruction
 452+ 06AC 00                           nop                     ; wait...
 453+ 06AD 00                           nop                     ; ...a while
 454+ 06AE 00                           nop
 455+ 06AF ED 79                        out     (C),A           ; write byte into VRAM
 456+ 06B1 C1                           pop     BC              ; restore BC
 457+ 06B2 C9                           ret                     ; return to caller
 458+ 06B3
 459+ 06B3              ; write a value into a specific VDP register
 460+ 06B3              ; value is in E, register is in A
 461+ 06B3 C5           WRITE_VREG:     push    BC              ; store BC
 462+ 06B4 C6 80                        add     A,$80           ; set VDP to write to registers
 463+ 06B6 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 464+ 06B8 ED 59                        out     (C),E           ; send data to VDP
 465+ 06BA ED 79                        out     (C),A           ; select the destination register
 466+ 06BC C1                           pop     BC              ; restore BC
 467+ 06BD C9                           ret                     ; return to caller
 468+ 06BE
 469+ 06BE              ; read VDP status register and return value into A
 470+ 06BE C5           READ_VSTAT:     push    BC              ; store BC
 471+ 06BF 0E 31                        ld      C,VDP_SET       ; VDP register access
 472+ 06C1 ED 78                        in      A,(C)           ; read status register
 473+ 06C3 C1                           pop     BC              ; restore BC
 474+ 06C4 C9                           ret                     ; return to caller
 475+ 06C5
 476+ 06C5              ; position the cursor at the current coordinates, preserving underlying char
 477+ 06C5 CD 08 07     POS_CURSOR:     call    LOAD_CRSR_POS   ; load the VRAM address of cursor into HL
 478+ 06C8 CD 89 06                     call    READ_VIDEO_LOC  ; load the current char at the cursor position (return in A)
 479+ 06CB 32 75 55                     ld      (SCR_ORG_CHR),A ; store the current char
 480+ 06CE C9                           ret
 481+ 06CF
 482+ 06CF              ; move cursor to new X,Y coordinates
 483+ 06CF CD FF 06     MOVCRS:         call    RSTCHRCRS       ; restore the char in the current cursor position
 484+ 06D2 CD EA 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 485+ 06D5 CD C5 06     MOVSHOWCRS:     call    POS_CURSOR      ; position cursor into new location
 486+ 06D8 3A 76 55                     ld      A,(CRSR_STATE)  ; load status of cursor
 487+ 06DB A7                           and     A               ; is cursor off?
 488+ 06DC C8                           ret     Z               ; yes, return
 489+ 06DD 3A 5C 55                     ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
 490+ 06E0 F6 20                        or      $20             ; ...set cursor on
 491+ 06E2 32 77 55                     ld      (LSTCSRSTA),A   ; store the last cursor state
 492+ 06E5 3E FF                        ld      A,$FF           ; BTW, set cursor visible after moved it
 493+ 06E7 C3 9E 06                     jp      WRITE_VIDEO_LOC ; write into video cell
 494+ 06EA
 495+ 06EA
 496+ 06EA              ; set new cursor's coordinates
 497+ 06EA 3A 73 55     NEWCRSRCOORD:   ld      A,(SCR_CUR_NX)  ; load new X
 498+ 06ED 32 71 55                     ld      (SCR_CURS_X),A  ; write new X
 499+ 06F0 3A 74 55                     ld      A,(SCR_CUR_NY)  ; load new Y
 500+ 06F3 32 72 55                     ld      (SCR_CURS_Y),A  ; write new Y
 501+ 06F6 3E FF                        ld      A,$FF           ; delete new values
 502+ 06F8 32 73 55                     ld      (SCR_CUR_NX),A  ; of X
 503+ 06FB 32 74 55                     ld      (SCR_CUR_NY),A  ; and Y
 504+ 06FE C9                           ret
 505+ 06FF
 506+ 06FF              ; recover char under the cursor and prints it onto the screen
 507+ 06FF CD 08 07     RSTCHRCRS:      call    LOAD_CRSR_POS   ; recover old cursor position
 508+ 0702 3A 75 55                     ld      A,(SCR_ORG_CHR) ; recover old char
 509+ 0705 C3 9E 06                     jp      WRITE_VIDEO_LOC ; write char into VRAM & return
 510+ 0708
 511+ 0708              ; retrieve cursor position from either current coordinates or next place
 512+ 0708              ; return address position into HL
 513+ 0708 3A 72 55     LOAD_CRSR_POS:  ld      A,(SCR_CURS_Y)  ; load cursor Y
 514+ 070B 6F                           ld      L,A             ; move it into reg.L
 515+ 070C AF                           xor     A               ; reset A
 516+ 070D 67                           ld      H,A             ; reset H
 517+ 070E 47                           ld      B,A             ; reset B
 518+ 070F 29                           add     HL,HL           ; create offset (each address is 2-bytes long so we need to double HL)
 519+ 0710 11 98 0A                     ld      DE,POS_TB_CRS_40; load position table address of cursor for 40 cols
 520+ 0713 3A 6C 55                     ld      A,(SCR_SIZE_W)  ; load screen width
 521+ 0716 FE 28                        cp      $28             ; is it 40 cols?
 522+ 0718 28 03                        jr      Z,CONT_POS_CURS ; yes, jump over
 523+ 071A 11 68 0A                     ld      DE,POS_TB_CRS_32; no, load position table address of cursor for 32 cols
 524+ 071D 19           CONT_POS_CURS:  add     HL,DE           ; the correct starting address of the required row is now into HL
 525+ 071E 5E                           ld      E,(HL)          ; load starting address of the required row into DE
 526+ 071F 23                           inc     HL
 527+ 0720 56                           ld      D,(HL)
 528+ 0721 2A 6F 55                     ld      HL,(SCR_NAM_TB) ; load starting address of name table
 529+ 0724 19                           add     HL,DE           ; starting address of the current row into name table
 530+ 0725 3A 71 55                     ld      A,(SCR_CURS_X)  ; load cursor X
 531+ 0728 4F                           ld      C,A             ; transfer A into C
 532+ 0729 09                           add     HL,BC           ; add X offset: now HL contains the address of the current cursor position
 533+ 072A C9                           ret
 534+ 072B
 535+ 072B              ; find X,Y coordinates of a screen address pointed in VRAM by HL
 536+ 072B              ; return them into L,A for X,Y
 537+ 072B D5           HL2XY:          push    DE              ; store DE
 538+ 072C ED 5B 6F 55                  ld      DE,(SCR_NAM_TB) ; load starting address of name table into DE
 539+ 0730 AF                           xor     A               ; clear Carry
 540+ 0731 ED 52                        sbc     HL,DE           ; find position relative to screen (from 0,0)
 541+ 0733 D1                           pop     DE
 542+ 0734 3A 6C 55                     ld      A,(SCR_SIZE_W)  ; load screen width
 543+ 0737 4F                           ld      C,A             ; move it into C
 544+ 0738 CD 90 41                     call    DIV_16_8        ; divide position by C: return Y into L and X into A
 545+ 073B C9                           ret                     ; return to caller
 546+ 073C
 547+ 073C              ;-------------------------------------------------------------------------------
 548+ 073C              ; char table for jumps
 549+ 073C 19           CHRTBL:         defb    HOME
 550+ 073D 7F 06                        defw    ATHOME          ; move the cursor to 0,0
 551+ 073F
 552+ 073F 0C                           defb    CS
 553+ 0740 72 06                        defw    CLEARVIDBUF     ; clear video buffer and position cursor at 0,0
 554+ 0742
 555+ 0742 0D                           defb    CR
 556+ 0743 BB 09                        defw    CRGRETURN       ; go to the beginning of the next line
 557+ 0745
 558+ 0745 08                           defb    BKSP
 559+ 0746 29 08                        defw    BACKSPACE       ; move cursor left 1 position
 560+ 0748
 561+ 0748 1C                           defb    CRSLFT
 562+ 0749 6C 08                        defw    CURSORLEFT      ; move cursor left
 563+ 074B
 564+ 074B 1E                           defb    CRSUP
 565+ 074C B8 08                        defw    CURSORUP        ; move cursor up
 566+ 074E
 567+ 074E 1D                           defb    CRSRGT
 568+ 074F D1 08                        defw    CURSORRIGHT     ; move cursor right
 569+ 0751
 570+ 0751 1F                           defb    CRSDN
 571+ 0752 06 09                        defw    CURSORDOWN      ; move cursor up
 572+ 0754
 573+ 0754 1A                           defb    INSRT
 574+ 0755 E7 07                        defw    INSERTKEY       ; insert a space
 575+ 0757
 576+ 0757 0A                           defb    LF
 577+ 0758 C3 07                        defw    PLACEHOLDER     ; CURRENTLY WE DON'T PRINT LINE FEED
 578+ 075A
 579+ 075A              ; send current char to video buffer
 580+ 075A F5           CHAR2VID:       push    AF              ; store AF
 581+ 075B C5                           push    BC              ; store BC
 582+ 075C D5                           push    DE              ; store DE
 583+ 075D E5                           push    HL              ; store HL
 584+ 075E 3A 76 55                     ld      A,(CRSR_STATE)  ; store cursor state...
 585+ 0761 F5                           push    AF              ; into stack
 586+ 0762 CD 3B 09                     call    CURSOR_OFF      ; cursor off
 587+ 0765 3A 79 55                     ld      A,(CHR4VID)     ; recover char
 588+ 0768 06 0A                        ld      B,$0A           ; 10 chars to check
 589+ 076A 21 3C 07                     ld      HL,CHRTBL       ; address of key table
 590+ 076D BE           RPTCPCK:        cp      (HL)            ; compare with char
 591+ 076E 23                           inc     HL              ; beginning of sub-routine address
 592+ 076F 20 09                        jr      NZ,NXTCPCK      ; different, go to next char
 593+ 0771 5E                           ld      E,(HL)          ; load addres into DE
 594+ 0772 23                           inc     HL
 595+ 0773 56                           ld      D,(HL)
 596+ 0774 EB                           ex      DE,HL           ; move user routine's address into HL
 597+ 0775 11 B6 07                     ld      DE,EXITCHAR2VID ; set point of return after the user routine
 598+ 0778 D5                           push    DE              ; store into stack
 599+ 0779 E9                           jp      (HL)            ; call user routine - then, the CPU will return (jump) to EXITCHAR2VID
 600+ 077A 23           NXTCPCK:        inc     HL              ; jump over 2 cells...
 601+ 077B 23                           inc     HL              ; ...to the next char code
 602+ 077C 10 EF                        djnz    RPTCPCK         ; repeat
 603+ 077E                              ; it'a not a special char, just print it
 604+ 077E CD 08 07                     call    LOAD_CRSR_POS   ; recover position of cursor
 605+ 0781 3A 79 55                     ld      A,(CHR4VID)     ; recover char to print
 606+ 0784 CD 9E 06                     call    WRITE_VIDEO_LOC ; write A into VRAM at (HL)
 607+ 0787 3A 72 55                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 608+ 078A 5F                           ld      E,A             ; store cursor Y into E
 609+ 078B 3A 71 55                     ld      A,(SCR_CURS_X)  ; load cursor X
 610+ 078E 3C                           inc     A               ; move 1 step to right
 611+ 078F 21 6C 55                     ld      HL,SCR_SIZE_W   ; cell that keeps the width of screen
 612+ 0792 BE                           cp      (HL)            ; have we reached the most right position?
 613+ 0793 20 0F                        jr      NZ,SETCSRCOORDS ; no, go over
 614+ 0795 1C                           inc     E               ; yes, increment cursor Y (go to next line)
 615+ 0796 7B                           ld      A,E             ; move cursor Y into A
 616+ 0797 21 6D 55                     ld      HL,SCR_SIZE_H   ; cell that keeps the height of screen
 617+ 079A BE                           cp      (HL)            ; have we reached the bottom of the screen?
 618+ 079B 20 06                        jr      NZ,SETCRSRY     ; no, jump over
 619+ 079D D5                           push    DE
 620+ 079E CD 42 09                     call    SCROLLUP        ; scroll screen up
 621+ 07A1 D1                           pop     DE
 622+ 07A2 1D                           dec     E               ; decrement 1 row, to set cursor Y on the last line
 623+ 07A3 AF           SETCRSRY:       xor     A               ; then set cursor X to 0 (go to beginning of line)
 624+ 07A4 32 71 55     SETCSRCOORDS:   ld      (SCR_CURS_X),A  ; store current cursor X
 625+ 07A7 7B                           ld      A,E             ; recover Y
 626+ 07A8 32 72 55                     ld      (SCR_CURS_Y),A  ; store current cursor Y
 627+ 07AB CD C5 06                     call    POS_CURSOR      ; position cursor into new location
 628+ 07AE 3A 5C 55                     ld      A,(TMRCNT)      ; load status of cursor flashing
 629+ 07B1 E6 20                        and     $20             ; check cursor state
 630+ 07B3 32 77 55                     ld      (LSTCSRSTA),A   ; store the last cursor state
 631+ 07B6 AF           EXITCHAR2VID:   xor     A               ; reset char
 632+ 07B7 32 79 55                     ld      (CHR4VID),A     ; to be sent to screen
 633+ 07BA F1                           pop     AF              ; recover cursor state
 634+ 07BB A7                           and     A               ; was it off (A=0)?
 635+ 07BC C4 26 09                     call    NZ,CURSOR_ON    ; no, set cursor on
 636+ 07BF E1                           pop     HL              ; restore HL
 637+ 07C0 D1                           pop     DE              ; restore DE
 638+ 07C1 C1                           pop     BC              ; restore BC
 639+ 07C2 F1                           pop     AF              ; restore AF
 640+ 07C3 C9           PLACEHOLDER:    ret                     ; return to caller
 641+ 07C4
 642+ 07C4              ; flash the cursor at the current position
 643+ 07C4              ; (this sub-routine is called by CH3 timer ISR)
 644+ 07C4 3A 76 55     FLASHCURSOR:    ld      A,(CRSR_STATE)  ; now, check the cursor
 645+ 07C7 A7                           and     A               ; cursor off (A=0)?
 646+ 07C8 C8                           ret     Z               ; yes, return
 647+ 07C9 3A 5C 55                     ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
 648+ 07CC E6 20                        and     $20             ; check if it's time to flash the cursor (check bit #6)
 649+ 07CE 21 77 55                     ld      HL,LSTCSRSTA    ; load address of cell that stores the last cursor state
 650+ 07D1 BE                           cp      (HL)            ; compare current state with last state
 651+ 07D2 C8                           ret     Z               ; same state, no change required - exit
 652+ 07D3 77                           ld      (HL),A          ; save new state
 653+ 07D4 F5                           push    AF              ; store A (keep state for later use)
 654+ 07D5 CD 08 07                     call    LOAD_CRSR_POS   ; load current cursor position into HL
 655+ 07D8 F1                           pop     AF              ; recover current state
 656+ 07D9 06 FF                        ld      B,$FF           ; cursor char
 657+ 07DB FE 20                        cp      $20             ; is the cursor on video (A == $20)?
 658+ 07DD 28 04                        jr      Z,PUTCRSCHR     ; yes, jump over
 659+ 07DF 3A 75 55                     ld      A,(SCR_ORG_CHR) ; no, load the original char
 660+ 07E2 47                           ld      B,A             ; move char into B
 661+ 07E3 78           PUTCRSCHR:      ld      A,B             ; recover char from B
 662+ 07E4 C3 9E 06                     jp      WRITE_VIDEO_LOC ; print cursor/char at the current position & return
 663+ 07E7
 664+ 07E7
 665+ 07E7              ; insert an empty space at the current position of the cursor, moving the following text
 666+ 07E7              ; 1 cell straight
 667+ 07E7 CD FF 06     INSERTKEY:      call    RSTCHRCRS       ; restore char under the cursor
 668+ 07EA CD 08 07                     call    LOAD_CRSR_POS   ; retrieve address of cursor cell
 669+ 07ED 22 7C 55                     ld      (CUR_POS),HL    ; store it
 670+ 07F0 CD 42 0A                     call    ENDOFLN         ; find address of first free cell after the end of the text from the current cursor position - address into HL -
 671+ 07F3                                                      ; DE is the address of the bottom right cell of the screen
 672+ 07F3 22 80 55                     ld      (ENDTXT),HL     ; store it
 673+ 07F6 ED 4B 7C 55                  ld      BC,(CUR_POS)    ; load starting address
 674+ 07FA AF                           xor     A
 675+ 07FB ED 42                        sbc     HL,BC           ; how many positions to move?
 676+ 07FD CA D5 06                     jp      Z,MOVSHOWCRS    ; none - leave and re-place cursor
 677+ 0800 44 4D                        ld      BC,HL           ; number of chars to scroll into BC
 678+ 0802 2A 80 55                     ld      HL,(ENDTXT)     ; load address of the end of text
 679+ 0805 2B           CHKHL:          dec     HL              ; decrement to find the address of the char to move
 680+ 0806 E5                           push    HL
 681+ 0807 CD 35 41                     call    CMP16           ; is it the last cell (bottom right) of screen?
 682+ 080A E1                           pop     HL
 683+ 080B D2 16 08                     jp      NC,NXTINST      ; yes, so jump over - nothing to do
 684+ 080E CD 89 06                     call    READ_VIDEO_LOC  ; no, so read current char
 685+ 0811 23                           inc     HL              ; next cell
 686+ 0812 CD 9E 06                     call    WRITE_VIDEO_LOC ; write into new position
 687+ 0815 2B                           dec     HL              ; decrement to old position
 688+ 0816 0B           NXTINST:        dec     BC              ; decrement number of chars to move
 689+ 0817 79                           ld      A,C
 690+ 0818 B0                           or      B               ; finished?
 691+ 0819 20 EA                        jr      NZ,CHKHL        ; no, repeat
 692+ 081B 3E 20                        ld      A,SPC           ; load SPACE character
 693+ 081D 2A 7C 55                     ld      HL,(CUR_POS)    ; get cursor position
 694+ 0820 32 75 55                     ld      (SCR_ORG_CHR),A ; reset original char under the cursor
 695+ 0823 CD 9E 06                     call    WRITE_VIDEO_LOC ; empty current video location
 696+ 0826 C3 D5 06                     jp      MOVSHOWCRS      ; re-place cursor
 697+ 0829
 698+ 0829              ; delete the char at the left of the cursor
 699+ 0829 CD FF 06     BACKSPACE:      call    RSTCHRCRS       ; restore char
 700+ 082C 2A 6F 55                     ld      HL,(SCR_NAM_TB) ; address of origin of screen (location 0,0)
 701+ 082F 44 4D                        ld      BC,HL           ; store into BC
 702+ 0831 CD 08 07                     call    LOAD_CRSR_POS   ; load address of current cursor pos.
 703+ 0834 54 5D                        ld      DE,HL           ; copy into DE
 704+ 0836 AF                           xor     A               ; reset Carry
 705+ 0837 ED 42                        sbc     HL,BC           ; check how many chars between
 706+ 0839 CA 63 08                     jp      Z,LVBKSP        ; none, so we are at the top left corner
 707+ 083C ED 53 7C 55                  ld      (CUR_POS),DE    ; store current cursor position
 708+ 0840 CD 42 0A                     call    ENDOFLN         ; check end of text
 709+ 0843 ED 5B 7C 55                  ld      DE,(CUR_POS)    ; retrieve cursor position
 710+ 0847 AF                           xor     A               ; reset Carry
 711+ 0848 ED 52                        sbc     HL,DE           ; check if none follows
 712+ 084A CA 63 08                     jp      Z,LVBKSP        ; no chars follow, so simply move the cursor
 713+ 084D 44 4D                        ld      BC,HL           ; save numbers of chars to move
 714+ 084F EB                           ex      DE,HL           ; copy starting position into HL
 715+ 0850 CD 89 06     MVBKSP:         call    READ_VIDEO_LOC  ; read char
 716+ 0853 2B                           dec     HL              ; 1 position to left
 717+ 0854 CD 9E 06                     call    WRITE_VIDEO_LOC ; write char
 718+ 0857 23                           inc     HL              ; goto next char to copy (2 steps to right)
 719+ 0858 23                           inc     HL
 720+ 0859 0B                           dec     BC              ; decrement # of chars
 721+ 085A 79                           ld      A,C
 722+ 085B B0                           or      B               ; 0 chars?
 723+ 085C 20 F2                        jr      NZ,MVBKSP       ; not finished, continue
 724+ 085E 2B                           dec     HL
 725+ 085F AF                           xor     A
 726+ 0860 CD 9E 06                     call    WRITE_VIDEO_LOC ; reset last char
 727+ 0863 CD 95 08     LVBKSP:         call    MVCRS2LFT       ; move cursor to new position
 728+ 0866 CD EA 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 729+ 0869 C3 D5 06                     jp      MOVSHOWCRS      ; move cursor to the new location and set it ON
 730+ 086C
 731+ 086C
 732+ 086C              ; move cursor to left
 733+ 086C F5           CURSORLEFT:     push    AF              ; store A
 734+ 086D 3A 71 55                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 735+ 0870 A7                           and     A               ; is it at the most left of the screen (X=0)?
 736+ 0871 28 0C                        jr      Z,CHCKYPOS      ; yes, check Y position
 737+ 0873 3D                           dec     A               ; no, decrement X
 738+ 0874 32 73 55                     ld      (SCR_CUR_NX),A  ; store new X
 739+ 0877 3A 72 55                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 740+ 087A 32 74 55                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 741+ 087D 18 11                        jr      CONTCRSLFT      ; go on moving cursor
 742+ 087F 3A 72 55     CHCKYPOS:       ld      A,(SCR_CURS_Y)  ; load cursor Y
 743+ 0882 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 744+ 0883 28 0E                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 745+ 0885 3D                           dec     A               ; no, decrement Y
 746+ 0886 32 74 55                     ld      (SCR_CUR_NY),A  ; store new Y
 747+ 0889 3A 6C 55                     ld      A,(SCR_SIZE_W)  ; load current screen width
 748+ 088C 3D                           dec     A               ; cursor to the most right position (width-0)
 749+ 088D 32 73 55                     ld      (SCR_CUR_NX),A  ; set new cursor X
 750+ 0890 CD CF 06     CONTCRSLFT:     call    MOVCRS          ; move cursor into new position
 751+ 0893 F1           EXITCURSORLEFT: pop     AF              ; restore A
 752+ 0894 C9                           ret                     ; return to caller
 753+ 0895
 754+ 0895              ; move cursor 1 position to the left
 755+ 0895 3A 71 55     MVCRS2LFT:      ld      A,(SCR_CURS_X)  ; load cursor X into A
 756+ 0898 A7                           and     A               ; is it at the most left of the screen (X=0)?
 757+ 0899 28 0B                        jr      Z,CHKYPOS       ; yes, check Y position
 758+ 089B 3D                           dec     A               ; no, decrement X
 759+ 089C 32 73 55                     ld      (SCR_CUR_NX),A  ; store new X
 760+ 089F 3A 72 55                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 761+ 08A2 32 74 55                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 762+ 08A5 C9                           ret                     ; go on moving cursor
 763+ 08A6 3A 72 55     CHKYPOS:        ld      A,(SCR_CURS_Y)  ; load cursor Y
 764+ 08A9 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 765+ 08AA 28 E7                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 766+ 08AC 3D                           dec     A               ; no, decrement Y
 767+ 08AD 32 74 55                     ld      (SCR_CUR_NY),A  ; store new Y
 768+ 08B0 3A 6C 55                     ld      A,(SCR_SIZE_W)  ; load current screen width
 769+ 08B3 3D                           dec     A               ; cursor to the most right position (width-1)
 770+ 08B4 32 73 55                     ld      (SCR_CUR_NX),A  ; set new cursor X
 771+ 08B7 C9                           ret                     ; return to caller
 772+ 08B8
 773+ 08B8              ; move cursor up
 774+ 08B8 F5           CURSORUP:       push    AF              ; store A
 775+ 08B9 3A 72 55                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 776+ 08BC A7                           and     A               ; is it at the most top of the screen (Y=0)?
 777+ 08BD 28 10                        jr      Z,EXITCURSORUP  ; yes, exit doing nothing
 778+ 08BF 3D                           dec     A               ; no, decrement Y
 779+ 08C0 32 74 55                     ld      (SCR_CUR_NY),A  ; store new Y
 780+ 08C3 3A 71 55                     ld      A,(SCR_CURS_X)  ; load current cursor X
 781+ 08C6 32 73 55                     ld      (SCR_CUR_NX),A  ; set new cursor X
 782+ 08C9 CD FF 06                     call    RSTCHRCRS       ; restore char under the cursor and print it
 783+ 08CC CD CF 06                     call    MOVCRS          ; move cursor into new position
 784+ 08CF F1           EXITCURSORUP:   pop     AF              ; restore A
 785+ 08D0 C9                           ret                     ; return to caller
 786+ 08D1
 787+ 08D1
 788+ 08D1              ; move cursor to right
 789+ 08D1 F5           CURSORRIGHT:    push    AF              ; store A
 790+ 08D2 C5                           push    BC              ; store B
 791+ 08D3 3A 6C 55                     ld      A,(SCR_SIZE_W)  ; load current screen width (in text modes it's 32 or 40)
 792+ 08D6 3D                           dec     A               ; decrement it (most right can only be 31 or 39)
 793+ 08D7 47                           ld      B,A             ; move A into B
 794+ 08D8 3A 71 55                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 795+ 08DB B8                           cp      B               ; is cursor at the most right position on the screen?
 796+ 08DC 30 0C                        jr      NC,CHCKYPOS2    ; yes, so jump to check Y position
 797+ 08DE 3C                           inc     A               ; no, so increment X
 798+ 08DF 32 73 55                     ld      (SCR_CUR_NX),A  ; store new X
 799+ 08E2 3A 72 55                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 800+ 08E5 32 74 55                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 801+ 08E8 18 13                        jr      CONTCRSRGT      ; go on moving cursor
 802+ 08EA 3A 6D 55     CHCKYPOS2:      ld      A,(SCR_SIZE_H)  ; load screen height
 803+ 08ED 3D                           dec     A               ; decrement it (last row can only be 23)
 804+ 08EE 47                           ld      B,A             ; move bottom into B
 805+ 08EF 3A 72 55                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 806+ 08F2 B8                           cp      B               ; is the cursor at the bottom of the screen?
 807+ 08F3 30 0E                        jr      NC,EXITCURSORRGHT; yes, exit doing nothing
 808+ 08F5 3C                           inc     A               ; no, increment Y
 809+ 08F6 32 74 55                     ld      (SCR_CUR_NY),A  ; store new Y
 810+ 08F9 AF                           xor     A               ; move cursor to top left
 811+ 08FA 32 73 55                     ld      (SCR_CUR_NX),A  ; store new X
 812+ 08FD CD FF 06     CONTCRSRGT:     call    RSTCHRCRS       ; restore char under the cursor and print it
 813+ 0900 CD CF 06                     call    MOVCRS          ; move cursor into new position
 814+ 0903 C1           EXITCURSORRGHT: pop     BC              ; retrieve BC
 815+ 0904 F1                           pop     AF              ; restore A
 816+ 0905 C9                           ret                     ; return to caller
 817+ 0906
 818+ 0906
 819+ 0906              ; move cursor down
 820+ 0906 F5           CURSORDOWN:     push    AF              ; store A
 821+ 0907 C5                           push    BC              ; store B
 822+ 0908 3A 6D 55                     ld      A,(SCR_SIZE_H)  ; load current screen height (in text modes it's 24)
 823+ 090B 3D                           dec     A               ; decrement it (positions can only vary between 0 and 23)
 824+ 090C 47                           ld      B,A             ; move X into B
 825+ 090D 3A 72 55                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 826+ 0910 B8                           cp      B               ; is current cursor position < 23?
 827+ 0911 30 10                        jr      NC,EXITCURSORDOWN; no, exit doing nothing
 828+ 0913 3C                           inc     A               ; yes, increment Y
 829+ 0914 32 74 55                     ld      (SCR_CUR_NY),A  ; store new Y
 830+ 0917 3A 71 55                     ld      A,(SCR_CURS_X)  ; load current cursor X
 831+ 091A 32 73 55                     ld      (SCR_CUR_NX),A  ; set new cursor X
 832+ 091D CD FF 06                     call    RSTCHRCRS       ; restore char under the cursor and print it
 833+ 0920 CD CF 06                     call    MOVCRS          ; move cursor into new position
 834+ 0923 C1           EXITCURSORDOWN: pop     BC              ; retrieve BC
 835+ 0924 F1                           pop     AF              ; retrieve A
 836+ 0925 C9                           ret                     ; return to caller
 837+ 0926
 838+ 0926
 839+ 0926              ; set cursor on (visible on screen)
 840+ 0926 F5           CURSOR_ON:      push    AF              ; store AF
 841+ 0927 3A 76 55                     ld      A,(CRSR_STATE)  ; load cursor state
 842+ 092A B7                           or      A               ; is it on?
 843+ 092B 20 0C                        jr      NZ,EXITCURSOR_ON; yes, so nothing to do
 844+ 092D 3A 6D 55                     ld      A,(SCR_SIZE_H)  ; check the video mode
 845+ 0930 FE 30                        cp      $30             ; graphics 2 or 3 (if value>=48)?
 846+ 0932 30 05                        jr      NC,EXITCURSOR_ON; yes, so exit (no cursor in graphics 2 or 3)
 847+ 0934 3E 01                        ld      A,$01           ; cursor state ON
 848+ 0936 32 76 55                     ld      (CRSR_STATE),A  ; set state
 849+ 0939 F1           EXITCURSOR_ON:  pop     AF              ; restore AF
 850+ 093A C9                           ret                     ; return to caller
 851+ 093B
 852+ 093B              ; set cursor off (invisible on screen)
 853+ 093B F5           CURSOR_OFF:     push    AF              ; store AF
 854+ 093C AF                           xor     A               ; cursor state OFF
 855+ 093D 32 76 55                     ld      (CRSR_STATE),A  ; set state
 856+ 0940 F1                           pop     AF              ; restore AF
 857+ 0941 C9                           ret
 858+ 0942
 859+ 0942              ; scroll the screen 1 row up
 860+ 0942 AF           SCROLLUP:       xor     A               ; reset A
 861+ 0943 57                           ld      D,A             ; reset D
 862+ 0944 32 78 55                     ld      (PRNTVIDEO),A   ; no print on screen while scrolling
 863+ 0947 2A 6F 55                     ld      HL,(SCR_NAM_TB) ; start address of the name table
 864+ 094A 22 AC 55                     ld      (VIDTMP1),HL    ; store address of the destination row (1st row of the screen)
 865+ 094D 3A 6C 55                     ld      A,(SCR_SIZE_W)  ; load the screen width
 866+ 0950 5F                           ld      E,A             ; move width into E
 867+ 0951 19                           add     HL,DE           ; HL now contains the address of the source row (2nd row of the screen)
 868+ 0952 22 AE 55                     ld      (VIDTMP2),HL    ; store address of source row
 869+ 0955 3A 6D 55                     ld      A,(SCR_SIZE_H)  ; load the screen height
 870+ 0958 3D                           dec     A               ; decrement the # of rows: now, A contains the # of rows to be moved
 871+ 0959 47                           ld      B,A             ; move # of rows into B
 872+ 095A 3A 6C 55     SCROLLNXTRW:    ld      A,(SCR_SIZE_W)  ; (re)load the screen width
 873+ 095D 5F                           ld      E,A             ; move width into E
 874+ 095E 2A AE 55                     ld      HL,(VIDTMP2)    ; load source address
 875+ 0961 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 876+ 0963 ED 69                        out     (C),L           ; low byte of source
 877+ 0965 ED 61                        out     (C),H           ; high byte of source
 878+ 0967 21 84 55                     ld      HL,VIDEOBUFF    ; load address of the first cell of the video buffer
 879+ 096A 0D                           dec     C               ; VDP data mode
 880+ 096B 00                           nop                     ; added to compensate shorter instruction
 881+ 096C ED 78        LOADNEXTCOL:    in      A,(C)           ; load char
 882+ 096E 77                           ld      (HL),A          ; store char
 883+ 096F 23                           inc     HL              ; next cell of the buffer
 884+ 0970 1D                           dec     E               ; count the chars to be read
 885+ 0971 20 F9                        jr      NZ,LOADNEXTCOL  ; repeat until we read the entire row
 886+ 0973 3A 6C 55                     ld      A,(SCR_SIZE_W)  ; reload the screen width
 887+ 0976 5F                           ld      E,A             ; move # of rows into E
 888+ 0977 16 00                        ld      D,$00           ; reset D
 889+ 0979 2A AC 55                     ld      HL,(VIDTMP1)    ; load address of destination row
 890+ 097C E5                           push    HL              ; store HL
 891+ 097D 2A AE 55                     ld      HL,(VIDTMP2)    ; current source will be..
 892+ 0980 22 AC 55                     ld      (VIDTMP1),HL    ; ..new destination
 893+ 0983 19                           add     HL,DE           ; address of new
 894+ 0984 22 AE 55                     ld      (VIDTMP2),HL    ; source row
 895+ 0987 E1                           pop     HL              ; restore address of current destination row
 896+ 0988 CB F4                        set     6,H             ; writing mode
 897+ 098A 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 898+ 098C ED 69                        out     (C),L           ; low byte
 899+ 098E ED 61                        out     (C),H           ; high byte of address
 900+ 0990 21 84 55                     ld      HL,VIDEOBUFF    ; video buffer address
 901+ 0993 0D                           dec     C               ; VDP data mode
 902+ 0994 7E           WRITEBUF:       ld      A,(HL)          ; load char
 903+ 0995 ED 79                        out     (C),A           ; send char
 904+ 0997 23                           inc     HL              ; increment buffer index
 905+ 0998 1D                           dec     E               ; next row
 906+ 0999 20 F9                        jr      NZ,WRITEBUF     ; repeat until 0
 907+ 099B 10 BD                        djnz    SCROLLNXTRW     ; repeat for the entire screen
 908+ 099D 3A 6C 55                     ld      A,(SCR_SIZE_W)  ; reload screen width
 909+ 09A0 47                           ld      B,A             ; cells to empty into B
 910+ 09A1 AF                           xor     A               ; null char
 911+ 09A2 0E 31                        ld      C,VDP_SET       ; VDP set mode
 912+ 09A4 2A AC 55                     ld      HL,(VIDTMP1)    ; load address of the last row
 913+ 09A7 CB F4                        set     6,H             ; writing mode
 914+ 09A9 ED 69                        out     (C),L           ; low byte then..
 915+ 09AB ED 61                        out     (C),H           ; high byte of address
 916+ 09AD 0D                           dec     C               ; VDP data mode
 917+ 09AE 00                           nop                     ; delay
 918+ 09AF ED 79        RPTEMPTYROW:    out     (C),A           ; empty cell
 919+ 09B1 00                           nop                     ; delay
 920+ 09B2 00                           nop
 921+ 09B3 10 FA                        djnz    RPTEMPTYROW     ; repeat until the last row has been cleaned
 922+ 09B5 3E 01                        ld      A,$01
 923+ 09B7 32 78 55                     ld      (PRNTVIDEO),A   ; set print-on-video on
 924+ 09BA C9                           ret                     ; return to caller
 925+ 09BB
 926+ 09BB              ; carriage return: first, it looks for char $00 at the beginning of the line (look for the first null char),
 927+ 09BB              ; then it starts sendind every char it finds on the screen to the terminal buffer of the BASIC interpreter
 928+ 09BB              ; until another null char is found. Finally, move to the next line and position the cursor at the beginning
 929+ 09BB              ; of the row (equivalent to CR+LF), then gets back control to the screen editor to let it interpret the line
 930+ 09BB              CUR_POS         equ     TMPBFR1         ; cursor position
 931+ 09BB              SRTTXT          equ     TMPBFR2         ; start of text line
 932+ 09BB              ENDTXT          equ     TMPBFR3         ; end of text line
 933+ 09BB              CRGRETURN:      ; preliminary: disable cursor if on, and retrieve char under it
 934+ 09BB 3A 76 55                     ld      A,(CRSR_STATE)  ; recover cursor state
 935+ 09BE 32 82 55                     ld      (TMPBFR4),A     ; store status
 936+ 09C1 A7                           and     A               ; is cursor on?
 937+ 09C2 C4 3B 09                     call    NZ,CURSOR_OFF   ; yes, so set cursor off
 938+ 09C5 CD FF 06                     call    RSTCHRCRS       ; restore char under it
 939+ 09C8                              ; first, check if cursor if off, so that we just interpret return as a new line command
 940+ 09C8 3A B6 55                     ld      A,(KBDNPT)      ; check if input from keyboad
 941+ 09CB A7                           and     A               ; if 0, input is not from keyboard...
 942+ 09CC CA 21 0A                     jp      Z,PRNTRETURN    ; ...so just print a carriage return; otherwise, interpret the return
 943+ 09CF                              ; first part: look for the beginning of the text line on screen
 944+ 09CF CD 08 07                     call    LOAD_CRSR_POS   ; load cursor position into HL
 945+ 09D2 22 7C 55                     ld      (CUR_POS),HL    ; store it
 946+ 09D5 ED 5B 6F 55                  ld      DE,(SCR_NAM_TB) ; load VRAM address of top-left cell of screen ("home")
 947+ 09D9 E5           RPTNLLSRC:      push    HL
 948+ 09DA CD 35 41                     call    CMP16           ; check if at "home"
 949+ 09DD E1                           pop     HL
 950+ 09DE CA E9 09                     jp      Z,CNTNULL       ; yes, exit because there is nothing before
 951+ 09E1 2B                           dec     HL              ; go 1 step back
 952+ 09E2 CD 89 06                     call    READ_VIDEO_LOC  ; read char of current position
 953+ 09E5 A7                           and     A               ; is it $00 (null char)?
 954+ 09E6 20 F1                        jr      NZ,RPTNLLSRC    ; no, continue searching
 955+ 09E8 23                           inc     HL              ; move 1 step forward to go back to the last cell with something in
 956+ 09E9                              ; second part: look for the ending of the text on screen
 957+ 09E9 22 7E 55     CNTNULL:        ld      (SRTTXT),HL     ; store beginning of text
 958+ 09EC CD 42 0A                     call    ENDOFLN         ; find end of text line looking at the end of chars after the cursor position
 959+ 09EF 22 80 55                     ld      (ENDTXT),HL     ; store ending of text line
 960+ 09F2 ED 5B 7E 55                  ld      DE,(SRTTXT)     ; load beginning of text line
 961+ 09F6 A7                           and     A               ; clear Carry
 962+ 09F7 ED 52                        sbc     HL,DE           ; how many chars?
 963+ 09F9 28 26                        jr      Z,PRNTRETURN    ; no chars found (HL-DE=0), so just print return & leave
 964+ 09FB                              ;---    central part: send the text on the screen to the interpreter
 965+ 09FB 2A 7E 55                     ld      HL,(SRTTXT)     ; load beginning of text line
 966+ 09FE ED 5B 80 55                  ld      DE,(ENDTXT)     ; load ending of text line
 967+ 0A02 CD 89 06     SNDCHRTOBFR:    call    READ_VIDEO_LOC  ; read char
 968+ 0A05 E5                           push    HL
 969+ 0A06 CD FD 01                     call    CHARINTOBFR     ; send char to buffer
 970+ 0A09 E1                           pop     HL
 971+ 0A0A 23                           inc     HL              ; go to next char
 972+ 0A0B E5                           push    HL              ; store HL
 973+ 0A0C CD 35 41                     call    CMP16           ; check if DE=HL (finish chars)
 974+ 0A0F E1                           pop     HL
 975+ 0A10 20 F0                        jr      NZ,SNDCHRTOBFR  ; no, repeat
 976+ 0A12 3E 0D                        ld      A,CR            ; yes, so now send carriage return
 977+ 0A14 CD FD 01                     call    CHARINTOBFR     ; send to buffer
 978+ 0A17 2A 80 55                     ld      HL,(ENDTXT)     ; recover address of last char of input text
 979+ 0A1A CD 2B 07                     call    HL2XY           ; retrieve X,Y from address
 980+ 0A1D 7D                           ld      A,L             ; move Y into A (we don't need X anymore)
 981+ 0A1E 32 72 55                     ld      (SCR_CURS_Y),A  ; store new Y
 982+ 0A21                              ;---    final part: go at the beginning of a new line on the screen
 983+ 0A21 AF           PRNTRETURN:     xor     A               ; move to col 0
 984+ 0A22 32 71 55                     ld      (SCR_CURS_X),A  ; store new X
 985+ 0A25 3A 72 55                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 986+ 0A28 3C                           inc     A               ; new row
 987+ 0A29 21 6D 55                     ld      HL,SCR_SIZE_H   ; load address of cell that keeps screen height
 988+ 0A2C BE                           cp      (HL)            ; is the cursor over the bottom of the screen?
 989+ 0A2D 38 06                        jr      C,ADDNEWLINE    ; no, jump over
 990+ 0A2F 3D                           dec     A               ; yes, so come back 1 row, then...
 991+ 0A30 F5                           push    AF              ; (store A)
 992+ 0A31 CD 42 09                     call    SCROLLUP        ; ...scroll the screen before to...
 993+ 0A34 F1                           pop     AF              ; (retrieve A)
 994+ 0A35 32 72 55     ADDNEWLINE:     ld      (SCR_CURS_Y),A  ; ...store new Y
 995+ 0A38 3A 82 55                     ld      A,(TMPBFR4)     ; retrieve cursor state
 996+ 0A3B A7                           and     A               ; was it off (A=0)?
 997+ 0A3C C4 26 09                     call    NZ,CURSOR_ON    ; no, set cursor on
 998+ 0A3F C3 C5 06                     jp      POS_CURSOR      ; position cursor to new location & return to caller
 999+ 0A42
1000+ 0A42              ; find end of text line
1001+ 0A42              ; destroys A, DE, and HL - store address of last char of text line into HL,
1002+ 0A42              ; while DE contains the address of the bottom right cell of the screen
1003+ 0A42 3A 6D 55     ENDOFLN:        ld      A,(SCR_SIZE_H)
1004+ 0A45 5F                           ld      E,A             ; load screen height into DE
1005+ 0A46 3A 6C 55                     ld      A,(SCR_SIZE_W)
1006+ 0A49 6F                           ld      L,A             ; load screen width into HL
1007+ 0A4A AF                           xor     A
1008+ 0A4B 67                           ld      H,A
1009+ 0A4C 57                           ld      D,A
1010+ 0A4D CD 40 41                     call    MUL16           ; multiply HL times DE to get the screen size
1011+ 0A50 ED 5B 6F 55                  ld      DE,(SCR_NAM_TB) ; load screen name table start address into DE
1012+ 0A54 19                           add     HL,DE           ; get the address...
1013+ 0A55 2B                           dec     HL              ; ...of the "last" video cell
1014+ 0A56 EB                           ex      DE,HL           ; store address into DE
1015+ 0A57 2A 7C 55                     ld      HL,(CUR_POS)    ; retrieve original cursor position
1016+ 0A5A E5           RPTNLLSRC2:     push    HL
1017+ 0A5B CD 35 41                     call    CMP16           ; check if at last position on screen (bottom right corner)
1018+ 0A5E E1                           pop     HL
1019+ 0A5F C8                           ret     Z               ; if yes, exit because these is nothing after
1020+ 0A60 23                           inc     HL              ; 1 more step forward
1021+ 0A61 CD 89 06                     call    READ_VIDEO_LOC  ; read char of current position
1022+ 0A64 A7                           and     A               ; is it $00 (null char)?
1023+ 0A65 20 F3                        jr      NZ,RPTNLLSRC2   ; no, continue searching
1024+ 0A67 C9                           ret                     ; yes: found end of text, return to caller
1025+ 0A68
1026+ 0A68
1027+ 0A68              ; ------------------------------------------------------------------------------
1028+ 0A68                              ; this table contains the values of the offsets to be added to
1029+ 0A68                              ; the starting address of the name table to find the correct
1030+ 0A68                              ; value of the first cell of the corresponding row
1031+ 0A68                              ; (by doing so, it's faster than doing a multipication)
1032+ 0A68                              ; table for graphics 1 text mode: 32 cols
1033+ 0A68 00 00 20 00  POS_TB_CRS_32:  defw    $0000,$0020,$0040,$0060,$0080,$00A0,$00C0,$00E0
1033+ 0A6C 40 00 60 00
1033+ 0A70 80 00 A0 00
1033+ 0A74 C0 00 E0 00
1034+ 0A78 00 01 20 01                  defw    $0100,$0120,$0140,$0160,$0180,$01A0,$01C0,$01E0
1034+ 0A7C 40 01 60 01
1034+ 0A80 80 01 A0 01
1034+ 0A84 C0 01 E0 01
1035+ 0A88 00 02 20 02                  defw    $0200,$0220,$0240,$0260,$0280,$02A0,$02C0,$02E0
1035+ 0A8C 40 02 60 02
1035+ 0A90 80 02 A0 02
1035+ 0A94 C0 02 E0 02
1036+ 0A98                              ; table for pure text mode: 40 cols
1037+ 0A98 00 00 28 00  POS_TB_CRS_40:  defw    $0000,$0028,$0050,$0078,$00A0,$00C8,$00F0,$0118
1037+ 0A9C 50 00 78 00
1037+ 0AA0 A0 00 C8 00
1037+ 0AA4 F0 00 18 01
1038+ 0AA8 40 01 68 01                  defw    $0140,$0168,$0190,$01B8,$01E0,$0208,$0230,$0258
1038+ 0AAC 90 01 B8 01
1038+ 0AB0 E0 01 08 02
1038+ 0AB4 30 02 58 02
1039+ 0AB8 80 02 A8 02                  defw    $0280,$02A8,$02D0,$02F8,$0320,$0348,$0370,$0398
1039+ 0ABC D0 02 F8 02
1039+ 0AC0 20 03 48 03
1039+ 0AC4 70 03 98 03
1040+ 0AC8
1041+ 0AC8              ; ------------------------------------------------------------------------------
1042+ 0AC8              ; reset VRAM
1043+ 0AC8 AF           EMPTY_VRAM:     xor     A               ; reg.A cleared: we fill up VRAM with $00
1044+ 0AC9 67                           ld      H,A
1045+ 0ACA 6F                           ld      L,A             ; reset HL
1046+ 0ACB CD 69 06                     call    SETVDPADRS      ; set address of first VRAM cell to $0000
1047+ 0ACE 06 40                        ld      B,$40           ; $40 pages of RAM...
1048+ 0AD0 57                           ld      D,A             ; ...each one with $100 cells (tot. $4000 bytes)
1049+ 0AD1 0D                           dec     C               ; VDP data mode
1050+ 0AD2 ED 79        EMPTVRM:        out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
1051+ 0AD4 14                           inc     D               ; next cell
1052+ 0AD5 00                           nop
1053+ 0AD6 20 FA                        jr      NZ,EMPTVRM      ; repeat until page is fully cleared
1054+ 0AD8 10 F8                        djnz    EMPTVRM         ; repeat for $40 pages
1055+ 0ADA C9                           ret                     ; return to caller
1056+ 0ADB
1057+ 0ADB              ; clear video registers in SRAM
1058+ 0ADB 21 6C 55     CLR_RAM_REG:    ld      HL,SCR_SIZE_W   ; address of first register
1059+ 0ADE AF                           xor     A               ; $00 to clean the registers
1060+ 0ADF 06 44                        ld      B,CHASNDDTN-SCR_SIZE_W; how many bytes (registers) to clean (dinamically calculated)
1061+ 0AE1 77           RSTVDPRAMREG:   ld      (HL),A          ; reset register
1062+ 0AE2 23                           inc     HL              ; next register
1063+ 0AE3 10 FC                        djnz    RSTVDPRAMREG    ; repeat
1064+ 0AE5 C9                           ret                     ; return to caller
1065+ 0AE6
1066+ 0AE6              ; ------------------------------------------------------------------------------
1067+ 0AE6              ; set a specific graphics mode, passed into reg. E
1068+ 0AE6 06 08        SET_GFX_MODE:   ld      B,$08           ; 8 registers means 8 bytes..
1069+ 0AE8 CB 23                        sla     E               ; multiply E by 8..
1070+ 0AEA CB 23                        sla     E               ; so that reg. E can point..
1071+ 0AEC CB 23                        sla     E               ; to the correct settings
1072+ 0AEE 16 00        SET_GFX_MODE2:  ld      D,$00           ; reset D
1073+ 0AF0 21 22 0B                     ld      HL,VDPMODESET   ; pointer to register settings | <= here points the SHOW_LOGO sub-routine
1074+ 0AF3 19                           add     HL,DE           ; add offset to get the correct set of values for the required mode
1075+ 0AF4 3E 80                        ld      A,$80           ; start with REG0 ($80+register number)
1076+ 0AF6 0E 31                        ld      C,VDP_SET       ; VDP set
1077+ 0AF8 56           LDREGVLS:       ld      D,(HL)          ; load register's value
1078+ 0AF9 ED 51                        out     (C),D           ; send data to VDP
1079+ 0AFB ED 79                        out     (C),A           ; indicate the register to send data to
1080+ 0AFD 3C                           inc     A               ; next register
1081+ 0AFE 23                           inc     HL              ; next value
1082+ 0AFF 10 F7                        djnz    LDREGVLS        ; repeat for 8 registers
1083+ 0B01 C9                           ret
1084+ 0B02
1085+ 0B02              ; ------------------------------------------------------------------------------
1086+ 0B02              LOADCHARSET:    ; reg. A contains the video mode
1087+ 0B02                              ; reg. HL contains address of pattern table into VRAM
1088+ 0B02 06 00                        ld      B,$00           ; 0=256 chars to load (complete charset)
1089+ 0B04 CB F4                        set     $06,H           ; add $4000 to address to indicate that we want to write into VRAM
1090+ 0B06 0E 31                        ld      C,VDP_SET       ; load VDP address into C
1091+ 0B08 ED 69                        out     (C),L           ; send low byte of address
1092+ 0B0A ED 61                        out     (C),H           ; send high byte
1093+ 0B0C 0D                           dec     C               ; VDP data mode
1094+ 0B0D 21 6B 42                     ld      HL,CHRST68      ; starting address of 6x8 charset into ROM
1095+ 0B10 A7                           and     A               ; is it text mode (A=0)?
1096+ 0B11 28 03                        jr      Z,NXTCHAR       ; yes, so jump to load chars into VRAM
1097+ 0B13 21 6B 4A                     ld      HL,CHRST88      ; no, so we change and load the 8x8 charset
1098+ 0B16 16 08        NXTCHAR:        ld      D,$08           ; 8 bytes per pattern char
1099+ 0B18 7E           SENDCHRPTRNS:   ld      A,(HL)          ; load byte to send to VDP
1100+ 0B19 ED 79                        out     (C),A           ; write byte into VRAM
1101+ 0B1B 23                           inc     HL              ; inc byte pointer
1102+ 0B1C 15                           dec     D               ; 8 bytes sents (0 char)?
1103+ 0B1D 20 F9                        jr      NZ,SENDCHRPTRNS ; no, continue
1104+ 0B1F 10 F5                        djnz    NXTCHAR         ; yes, decrement chars counter and continue for all the chars
1105+ 0B21 C9                           ret                     ; return to caller
1106+ 0B22
1107+ 0B22              ;------------------------------------------------------------------------------
1108+ 0B22              ; NAME TABLE:       buffer video - contains the chars to be shown on video
1109+ 0B22              ; PATTERN TABLE:    charset - contains the chars/tiles to be loaded into the name table
1110+ 0B22              ; COLOR TABLE:      color settings for chars/tiles
1111+ 0B22
1112+ 0B22                              ; VDP register settings for a text display
1113+ 0B22 00           VDPMODESET:     defb    %00000000       ; reg.0: external video off
1114+ 0B23 D0                           defb    %11010000       ; reg.1: 16K VRAM, video on, int. off, text mode (40x24)
1115+ 0B24 02                           defb    $02             ; reg.2: name table set to $0800 ($02x$400)
1116+ 0B25 00                           defb    $00             ; reg.3: not used in text mode
1117+ 0B26 00                           defb    $00             ; reg.4: pattern table set to $0000
1118+ 0B27 00                           defb    $00             ; reg.5: not used in text mode
1119+ 0B28 00                           defb    $00             ; reg.6: not used in text mode
1120+ 0B29 F5                           defb    $f5             ; reg.7: white text on light blue background
1121+ 0B2A
1122+ 0B2A              VDPMODESET1:    ; VDP register settings for a graphics 1 mode
1123+ 0B2A 00                           defb    %00000000       ; reg.0: ext. video off
1124+ 0B2B C0                           defb    %11000000       ; reg.1: 16K Vram; video on, int off, graphics mode 1, sprite size 8x8, sprite magn. 0
1125+ 0B2C 06                           defb    $06             ; reg.2: name table address: $1800
1126+ 0B2D 80                           defb    $80             ; reg.3: color table address: $2000
1127+ 0B2E 00                           defb    $00             ; reg.4: pattern table address: $0000
1128+ 0B2F 36                           defb    $36             ; reg.5: sprite attr. table address: $1B00
1129+ 0B30 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1130+ 0B31 05                           defb    $05             ; reg.7: backdrop color (light blue)
1131+ 0B32
1132+ 0B32              VDPMODESET2:    ; VDP register settings for a graphics 2 mode
1133+ 0B32 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1134+ 0B33 C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1135+ 0B34 06                           defb    $06             ; reg.2: name table addr.: $1800
1136+ 0B35 FF                           defb    $FF             ; reg.3: color table addr.: $2000
1137+ 0B36 03                           defb    $03             ; reg.4: pattern table addr.: $0000
1138+ 0B37 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1139+ 0B38 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1140+ 0B39 05                           defb    $05             ; reg.7: backdrop color: light blue
1141+ 0B3A
1142+ 0B3A              VDPMODESETMC:   ; VDP register settings for a multicolor mode
1143+ 0B3A 00                           defb    %00000000       ; reg.0: ext. video dis.
1144+ 0B3B CB                           defb    %11001011       ; reg.1: 16K VRAM, video on, INT off, multicolor mode, sprite size 8x8, sprite magn. 0
1145+ 0B3C 02                           defb    $02             ; reg.2: name table addr.: $0800
1146+ 0B3D 00                           defb    $00             ; reg.3: don't care
1147+ 0B3E 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1148+ 0B3F 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1149+ 0B40 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1150+ 0B41 0F                           defb    $0F             ; reg.7: backdrop color (white)
1151+ 0B42
1152+ 0B42              VDPMODESETEX2:  ; VDP register settings for an extended graphics 2 mode
1153+ 0B42 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1154+ 0B43 C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1155+ 0B44 0E                           defb    $0E             ; reg.2: name table addr.: $3800
1156+ 0B45 9F                           defb    $9F             ; reg.3: color table addr.: $2000
1157+ 0B46 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1158+ 0B47 76                           defb    $76             ; reg.5: sprite attr. table addr.: $3B00
1159+ 0B48 03                           defb    $03             ; reg.6: sprite pattern table addr.: $1800
1160+ 0B49 05                           defb    $05             ; reg.7: backdrop color: light blue
1161+ 0B4A
1162+ 0B4A              LM80CLOGO:      ; patterns to compose the splash screen logo
1163+ 0B4A                              ; 1st band
1164+ 0B4A 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1164+ 0B4E 00 00 00 00
1164+ 0B52 00 00 00 00
1164+ 0B56 00 00 00 00
1164+ 0B5A 00 00 00 00
1164+ 0B5E 00 00 00 00
1164+ 0B62 00 00 00 00
1164+ 0B66 00 00 00 00
1165+ 0B6A 00 00 0F 0A                  defb    0,0,15,10,11,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1165+ 0B6E 0B 10 00 00
1165+ 0B72 00 00 00 00
1165+ 0B76 00 00 00 00
1165+ 0B7A 00 00 00 00
1165+ 0B7E 00 00 00 00
1165+ 0B82 00 00 00 00
1165+ 0B86 00 00 00 00
1166+ 0B8A                              ; 2nd band
1167+ 0B8A 00 00 0D 17                  defb    0,0,13,23,0,12,0,0,0,1,0,0,0,20,0,0,6,5,6,21,22,7,6,21,22,7,6,1,1,7,0,0
1167+ 0B8E 00 0C 00 00
1167+ 0B92 00 01 00 00
1167+ 0B96 00 14 00 00
1167+ 0B9A 06 05 06 15
1167+ 0B9E 16 07 06 15
1167+ 0BA2 16 07 06 01
1167+ 0BA6 01 07 00 00
1168+ 0BAA 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,20,6,1,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1168+ 0BAE 00 0C 00 00
1168+ 0BB2 00 01 00 00
1168+ 0BB6 00 01 14 06
1168+ 0BBA 01 05 03 05
1168+ 0BBE 03 05 03 05
1168+ 0BC2 03 05 03 05
1168+ 0BC6 03 05 00 00
1169+ 0BCA                              ; 3rd band
1170+ 0BCA 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,1,1,1,5,9,20,19,8,3,5,19,5,3,5,0,0,0,0
1170+ 0BCE 00 0C 00 00
1170+ 0BD2 00 01 00 00
1170+ 0BD6 00 01 01 01
1170+ 0BDA 01 05 09 14
1170+ 0BDE 13 08 03 05
1170+ 0BE2 13 05 03 05
1170+ 0BE6 00 00 00 00
1171+ 0BEA 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,8,3,5,6,21,22,7,3,1,22,5,3,5,0,0,0,0
1171+ 0BEE 00 0C 00 00
1171+ 0BF2 00 01 00 00
1171+ 0BF6 00 01 00 08
1171+ 0BFA 03 05 06 15
1171+ 0BFE 16 07 03 01
1171+ 0C02 16 05 03 05
1171+ 0C06 00 00 00 00
1172+ 0C0A                              ; 4th band
1173+ 0C0A 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,0,3,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1173+ 0C0E 00 0C 00 00
1173+ 0C12 00 01 00 00
1173+ 0C16 00 01 00 00
1173+ 0C1A 03 05 03 05
1173+ 0C1E 03 05 03 05
1173+ 0C22 03 05 03 05
1173+ 0C26 03 05 00 00
1174+ 0C2A 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,4,4,0,1,0,0,3,5,9,20,19,8,9,20,19,8,9,1,1,8,0,0
1174+ 0C2E 00 0C 00 00
1174+ 0C32 00 01 04 04
1174+ 0C36 00 01 00 00
1174+ 0C3A 03 05 09 14
1174+ 0C3E 13 08 09 14
1174+ 0C42 13 08 09 01
1174+ 0C46 01 08 00 00
1175+ 0C4A                              ; 5th band
1176+ 0C4A 00 00 0E 12                  defb    0,0,14,18,18,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1176+ 0C4E 12 11 00 00
1176+ 0C52 00 00 00 00
1176+ 0C56 00 00 00 00
1176+ 0C5A 00 00 00 00
1176+ 0C5E 00 00 00 00
1176+ 0C62 00 00 00 00
1176+ 0C66 00 00 00 00
1177+ 0C6A 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1177+ 0C6E 00 00 00 00
1177+ 0C72 00 00 00 00
1177+ 0C76 00 00 00 00
1177+ 0C7A 00 00 00 00
1177+ 0C7E 00 00 00 00
1177+ 0C82 00 00 00 00
1177+ 0C86 00 00 00 00
# file closed: ../include/vdp/vdp-1.07.asm
  70  0C8A
  71  0C8A              ; incude the latest version of the PSG module
  72  0C8A                  INCLUDE "../include/psg/psg-1.1.asm"
# file opened: ../include/psg/psg-1.1.asm
   1+ 0C8A              ; ------------------------------------------------------------------------------
   2+ 0C8A              ; LM80C - PSG ROUTINES - 1.1
   3+ 0C8A              ; ------------------------------------------------------------------------------
   4+ 0C8A              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0C8A              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0C8A              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0C8A              ; kind of warranty: you can use them at your own risk.
   8+ 0C8A              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0C8A              ; maintain the copyright notices, include this advice and the note to the
  10+ 0C8A              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0C8A              ; redistribuite them.
  12+ 0C8A              ; https://www.leonardomiliani.com
  13+ 0C8A              ;
  14+ 0C8A              ; Please support me by visiting the following links:
  15+ 0C8A              ; Main project page: https://www.leonardomiliani.com
  16+ 0C8A              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0C8A              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0C8A              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0C8A              ; ------------------------------------------------------------------------------
  20+ 0C8A              ;
  21+ 0C8A              ; ------------------------------------------------------------------------------
  22+ 0C8A
  23+ 0C8A              ;------------------------------------------------------------------------------
  24+ 0C8A
  25+ 0C8A              ; configure the PSG
  26+ 0C8A 21 B0 55     initPSG:        ld      HL,CHASNDDTN    ; starting address of sound & keyboard RAM registers
  27+ 0C8D 06 0E                        ld      B,SERIALS_EN-CHASNDDTN; # of PSG sound & keyboard registers
  28+ 0C8F AF                           xor     A               ; reset A
  29+ 0C90 77           EMPTSNDBFR:     ld      (HL),A          ; reset RAM register
  30+ 0C91 23                           inc     HL              ; next register
  31+ 0C92 10 FC                        djnz    EMPTSNDBFR      ; repeat
  32+ 0C94 06 10        CLRPSGREGS:     ld      B,$10           ; 16 registers to set
  33+ 0C96 21 A8 0C                     ld      HL,SNDREGCFG    ; starting address of register settings
  34+ 0C99 16 00                        ld      D,$00           ; first register
  35+ 0C9B 7A           RSTPSG:         ld      A,D             ; register value
  36+ 0C9C CD E2 0C                     call    SETSNDREG       ; select register
  37+ 0C9F 7E                           ld      A,(HL)          ; load value
  38+ 0CA0 CD E7 0C                     call    WRTSNDREG       ; write to register
  39+ 0CA3 14                           inc     D               ; next register
  40+ 0CA4 23                           inc     HL              ; next value
  41+ 0CA5 10 F4                        djnz    RSTPSG          ; repeat for each register
  42+ 0CA7 C9                           ret                     ; return to caller
  43+ 0CA8
  44+ 0CA8 00 00 00 00  SNDREGCFG:      defb $00,$00,$00,$00,$00,$00,$00,%10111111
  44+ 0CAC 00 00 00 BF
  45+ 0CB0 00 00 00 00                  defb $00,$00,$00,$00,$00,$00,$ff,$ff
  45+ 0CB4 00 00 FF FF
  46+ 0CB8                              ; reg. 7: set I/O ch.A to OUTPUT, I/O ch.B to INPUT; set noise to OFF; set audio to OFF
  47+ 0CB8
  48+ 0CB8
  49+ 0CB8              ; routine to play a welcome beep on channel C (tone 4010) and to shut it off
  50+ 0CB8 21 D2 0C     WLCMBEEP:       ld      HL,WLCBPDAT     ; data address
  51+ 0CBB C3 C1 0C                     jp      SENDSND
  52+ 0CBE 21 DA 0C     NOBEEP:         ld      HL,NOBPDAT      ; data address
  53+ 0CC1 C5           SENDSND:        push    BC
  54+ 0CC2 06 04                        ld      B,$04           ; 4 pairs
  55+ 0CC4 7E           RPTWLCMBP:      ld      A,(HL)          ; read register #
  56+ 0CC5 CD E2 0C                     call    SETSNDREG
  57+ 0CC8 23                           inc     HL              ; next cell
  58+ 0CC9 7E                           ld      A,(HL)          ; read value
  59+ 0CCA CD E7 0C                     call    WRTSNDREG
  60+ 0CCD 23                           inc     HL
  61+ 0CCE 10 F4                        djnz    RPTWLCMBP       ; repeat
  62+ 0CD0 C1                           pop     BC
  63+ 0CD1 C9                           ret                     ; return to caller
  64+ 0CD2
  65+ 0CD2 07 BB 04 56  WLCBPDAT:       defb    $07,%10111011,$04,$56,$05,$00,$0A,$0F
  65+ 0CD6 05 00 0A 0F
  66+ 0CDA 04 00 05 00  NOBPDAT:        defb    $04,$00,$05,$00,$0A,$00,$07,%10111111
  66+ 0CDE 0A 00 07 BF
  67+ 0CE2
  68+ 0CE2
  69+ 0CE2              ; select register on PSG
  70+ 0CE2 0E 40        SETSNDREG:      ld      C,PSG_REG       ; PSG register port
  71+ 0CE4 ED 79                        out     (C),A           ; set register
  72+ 0CE6 C9                           ret                     ; return to caller
  73+ 0CE7
  74+ 0CE7              ; send data to PSG
  75+ 0CE7 0E 41        WRTSNDREG:      ld      C,PSG_DAT       ; PSG data port
  76+ 0CE9 ED 79                        out     (C),A           ; send data
  77+ 0CEB C9                           ret                     ; return to caller
  78+ 0CEC
  79+ 0CEC              ; manage the sounds' duration: each time this subroutine is called, it
  80+ 0CEC              ; decrements the single sound durations (measured in ms) and eventually
  81+ 0CEC              ; shut off the audio channel whose counter has reached 0.
  82+ 0CEC              ; (this sub-routine is called by CH3 timer ISR)
  83+ 0CEC DD E5        MNGSNDS:        push    IX              ; store IX
  84+ 0CEE DD 21 B0 55                  ld      IX,CHASNDDTN    ; starting address of tones duration
  85+ 0CF2 06 03                        ld      B,$03           ; 3 channels to check
  86+ 0CF4 26 01                        ld      H,$01           ; mixer channels: A=>bit 1, B=>bit 2, C=>bit 3
  87+ 0CF6 DD 5E 00     CHKSNDCH:       ld      E,(IX+0)        ; load LSB into E
  88+ 0CF9 DD 56 01                     ld      D,(IX+1)        ; load MSB into D
  89+ 0CFC 7B                           ld      A,E             ; load E into A
  90+ 0CFD B2                           or      D               ; check that DE=0
  91+ 0CFE 28 31                        jr      Z,CNTCHKSND     ; yes, jump over
  92+ 0D00 1B                           dec     DE              ; no, so decrement DE
  93+ 0D01 7B                           ld      A,E             ; reload E into A...
  94+ 0D02 DD 73 00                     ld      (IX+0),E        ; store new...
  95+ 0D05 DD 72 01                     ld      (IX+1),D        ; ...duration and...
  96+ 0D08 B2                           or      D               ; ...do another check to see if DE=0
  97+ 0D09 20 26                        jr      NZ,CNTCHKSND    ; no, so jump over
  98+ 0D0B                                                      ; if yes, let's shut down the corresponding channel
  99+ 0D0B                                                      ; to shut down a tone we disable it into the mixer
 100+ 0D0B                                                      ; then set 0 into its tone registers
 101+ 0D0B 16 07                        ld      D,$07           ; mixer register
 102+ 0D0D 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 103+ 0D0F ED 51                        out     (C),D           ; set mixer register
 104+ 0D11 ED 78                        in      A,(C)           ; load current value
 105+ 0D13 B4                           or      H               ; set off the channel into the mixer (remember that 1=OFF)
 106+ 0D14 ED 51                        out     (C),D           ; select mixer register
 107+ 0D16 0E 41                        ld      C,PSG_DAT       ; PSG data port
 108+ 0D18 ED 79                        out     (C),A           ; send new value for the mixer
 109+ 0D1A 3E 03                        ld      A,$03           ; three channels
 110+ 0D1C 90                           sub     B               ; find current channel (0->A, 1->B, 2->C)
 111+ 0D1D 87                           add     A,A             ; and find first register (A=>0, B=>2, C=>4)
 112+ 0D1E 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 113+ 0D20 ED 79                        out     (C),A           ; select first tone register of channel
 114+ 0D22 2E 00                        ld      L,$00           ; value 0 into L
 115+ 0D24 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 116+ 0D26 ED 69                        out     (C),L           ; write 0 into register
 117+ 0D28 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 118+ 0D2A 3C                           inc     A               ; next tone register
 119+ 0D2B ED 79                        out     (C),A           ; select second tone register of channel
 120+ 0D2D 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 121+ 0D2F ED 69                        out     (C),L           ; write 0 into register
 122+ 0D31 DD 23        CNTCHKSND:      inc     IX              ; set for...
 123+ 0D33 DD 23                        inc     IX              ; ...next channel...
 124+ 0D35 CB 24                        sla     H               ; shift left H 1 bit
 125+ 0D37 10 BD                        djnz    CHKSNDCH        ; repeat for 3 channels
 126+ 0D39 DD E1                        pop     IX              ; restore IX
 127+ 0D3B C9                           ret                     ; return to caller
 128+ 0D3C
 129+ 0D3C              ; read a specific row of the keyboard matrix, set by A
 130+ 0D3C              ; return read into A
 131+ 0D3C C5           READKBLN:       push    BC              ; store BC
 132+ 0D3D 06 0F                        ld      B,$0F           ; reg #15
 133+ 0D3F 0E 40                        ld      C,PSG_REG       ; PSG register port
 134+ 0D41 ED 41                        out     (C),B           ; select reg #15
 135+ 0D43 0E 41                        ld      C,PSG_DAT       ; PSG data port
 136+ 0D45 ED 79                        out     (C),A           ; activate the row
 137+ 0D47 06 0E                        ld      B,$0E           ; register #14 (port B)
 138+ 0D49 0E 40                        ld      C,PSG_REG       ; PSG register port
 139+ 0D4B ED 41                        out     (C),B           ; select reg. 14 (port B)
 140+ 0D4D ED 78                        in      A,(C)           ; read register #14
 141+ 0D4F C1                           pop     BC              ; retrieve BC
 142+ 0D50 C9                           ret
 143+ 0D51
 144+ 0D51              ; read the keyboard matrix to look for a key pressure
 145+ 0D51 0E 40        KEYBOARD:       ld      C,PSG_REG       ; PSG register port
 146+ 0D53 06 07                        ld      B,$07           ; set register #7...
 147+ 0D55 ED 41                        out     (C),B           ; ...to work with
 148+ 0D57 ED 78                        in      A,(C)           ; read register #7
 149+ 0D59 CB FF                        set     7,A             ; port A set to output
 150+ 0D5B CB B7                        res     6,A             ; port B set to input
 151+ 0D5D ED 41                        out     (C),B           ; set register #7
 152+ 0D5F 0E 41                        ld      C,PSG_DAT       ; PSG data port
 153+ 0D61 ED 79                        out     (C),A           ; set I/O ports w/o altering the rest of the mixer
 154+ 0D63                              ; check special keys (SHIFT/ALT/CTRL)
 155+ 0D63 3E FD                        ld      A,%11111101     ; select SHIFT row
 156+ 0D65 CD 3C 0D                     call    READKBLN        ; read row
 157+ 0D68 CB 5F                        bit     3,A             ; test if SHIFT key is pressed (4th bit is reset)
 158+ 0D6A 20 05                        jr      NZ,CHECKALT     ; no, so go on
 159+ 0D6C 21 BD 55                     ld      HL,CONTROLKEYS  ; control key flags
 160+ 0D6F 36 01                        ld      (HL),%00000001  ; set SHIFT flag, reset CTRL & ALT flags (currently multiply control keys are NOT supported)
 161+ 0D71 3E FE        CHECKALT:       ld      A,%11111110     ; select ALT row
 162+ 0D73 CD 3C 0D                     call    READKBLN        ; read ALT row
 163+ 0D76 CB 6F                        bit     5,A             ; test if ALT key is pressed (5th bit is reset)
 164+ 0D78 20 05                        jr      NZ,CHECKCTRL    ; no, so go on
 165+ 0D7A 21 BD 55                     ld      HL,CONTROLKEYS  ; control key flags
 166+ 0D7D 36 04                        ld      (HL),%00000100  ; set ALT flag, reset SHIFT & CTRL flag (currently multiply control keys are NOT supported)
 167+ 0D7F 3E FE        CHECKCTRL:      ld      A,%11111110     ; select CTRL row
 168+ 0D81 CD 3C 0D                     call    READKBLN        ; read CTRL row
 169+ 0D84 CB 57                        bit     2,A             ; test if CTRL key is pressed (3rd bit is reset)
 170+ 0D86 20 05                        jr      NZ,CHECKKBD     ; no, so make a normal reading
 171+ 0D88 21 BD 55                     ld      HL,CONTROLKEYS  ; control key flags
 172+ 0D8B 36 02                        ld      (HL),%00000010  ; set CTRL flag, reset SHIFT & ALT flags (currently multiply control keys are NOT supported)
 173+ 0D8D 06 08        CHECKKBD:       ld      B,$08           ; 8 lines
 174+ 0D8F 3E 7F                        ld      A,%01111111     ; start from the last line of the matrix
 175+ 0D91 16 0F        RPTKBDRD:       ld      D,$0F           ; register #15 (port B)
 176+ 0D93 0E 40                        ld      C,PSG_REG       ; PSG register port
 177+ 0D95 ED 51                        out     (C),D           ; select reg. #15
 178+ 0D97 0E 41                        ld      C,PSG_DAT       ; PSG data port
 179+ 0D99 ED 79                        out     (C),A           ; activate 1 line (active line is grounded, i.e. with a LOW signal)
 180+ 0D9B 5F                           ld      E,A             ; save current line into E
 181+ 0D9C 16 0E                        ld      D,$0E           ; register #14 (port A)
 182+ 0D9E 0E 40                        ld      C,PSG_REG       ; PSG register port
 183+ 0DA0 ED 51                        out     (C),D           ; select reg. 14 (port A)
 184+ 0DA2 00                           nop
 185+ 0DA3 ED 78                        in      A,(C)           ; read register #14
 186+ 0DA5 FE FF                        cp      $FF             ; is there any line set to 0?
 187+ 0DA7 28 2E                        jr      Z,NOKEYPRSD     ; no, go to the next row
 188+ 0DA9                              ; check control keys
 189+ 0DA9 32 B7 55                     ld      (KBTMP),A       ; yes, check if a control key was pressed. First, store current row
 190+ 0DAC 78                           ld      A,B             ; copy current row (B) into A
 191+ 0DAD FE 02                        cp      $02             ; is it the row of the SHIFT?
 192+ 0DAF 20 0F                        jr      NZ,TESTALT      ; no, continue checking the other control keys
 193+ 0DB1 3A B7 55                     ld      A,(KBTMP)       ; yes, retrieve current row data
 194+ 0DB4 CB 5F                        bit     3,A             ; check SHIFT bit line
 195+ 0DB6 20 31                        jr      NZ,FINDKEY      ; no SHIFT, continue checking
 196+ 0DB8 CB DF                        set     3,A             ; yes, it's the SHIFT. So remove SHIFT bit
 197+ 0DBA FE FF                        cp      $FF             ; after deleting the SHIFT bit, is there any other bit selected?
 198+ 0DBC 20 2B                        jr      NZ,FINDKEY      ; yes, go to check which one
 199+ 0DBE 18 17                        jr      NOKEYPRSD       ; no, go to next row
 200+ 0DC0 FE 01        TESTALT:        cp      $01             ; is it the line of ALT & CTRL?
 201+ 0DC2 3A B7 55                     ld      A,(KBTMP)       ; retrieve current row data
 202+ 0DC5 20 22                        jr      NZ,FINDKEY      ; no, continue
 203+ 0DC7 CB 6F                        bit     5,A             ; yes, check ALT bit line
 204+ 0DC9 20 02                        jr      NZ,TESTCTRL     ; no ALT, continue checking
 205+ 0DCB CB EF                        set     5,A             ; yes, it's the ALT. So remove ALT bit
 206+ 0DCD CB 57        TESTCTRL:       bit     2,A             ; check CTRL bit line
 207+ 0DCF 20 02                        jr      NZ,ENDCTRLCK    ; no CTRL, continue checking
 208+ 0DD1 CB D7                        set     2,A             ; delete CTRL bit flag
 209+ 0DD3 FE FF        ENDCTRLCK:      cp      $FF             ; after deleting the ALT & CTRL bits, is there any other bit selected?
 210+ 0DD5 20 12                        jr      NZ,FINDKEY      ; yes, go to check which one
 211+ 0DD7 7B           NOKEYPRSD:      ld      A,E             ; no key pressed, load current output port
 212+ 0DD8 0F                           rrca                    ; rotate right by 1
 213+ 0DD9 10 B6                        djnz    RPTKBDRD        ; repeat for 8 lines
 214+ 0DDB AF                           xor     A               ; if exit from here, no key has been pressed...
 215+ 0DDC 32 B9 55                     ld      (LASTKEYPRSD),A ; ...so reset the last key cell...
 216+ 0DDF 32 BD 55                     ld      (CONTROLKEYS),A ; ...reset contro key flags...
 217+ 0DE2 32 B6 55                     ld      (KBDNPT),A      ; ...no input from keyboard...
 218+ 0DE5 32 BA 55                     ld      (STATUSKEY),A   ; ...no auto-repeat...
 219+ 0DE8 C9                           ret                     ; ...and leave
 220+ 0DE9 1E FF        FINDKEY:        ld      E,$FF           ; counter
 221+ 0DEB 1C           CHKLN:          inc     E               ; E goes from 0 to 7
 222+ 0DEC CB 3F                        srl     A               ; is the first bit reset? (we're looking for a "0", meaning grounded line)
 223+ 0DEE 38 FB                        jr      C,CHKLN         ; no, check next bit
 224+ 0DF0 3A BD 55                     ld      A,(CONTROLKEYS) ; load control key flags
 225+ 0DF3 21 0C 0F                     ld      HL,KBMAP        ; normal keymap
 226+ 0DF6 FE 01                        cp      $01             ; SHIFT flag?
 227+ 0DF8 20 05                        jr      NZ,CHKCTRL      ; no, jump over
 228+ 0DFA 21 4C 0F                     ld      HL,KBMAP_SFT    ; SHIFT keymap
 229+ 0DFD 18 10                        jr      LOADMAP         ; and load it
 230+ 0DFF FE 02        CHKCTRL:        cp      $02             ; CTRL flag?
 231+ 0E01 20 05                        jr      NZ,CHKALT       ; no, jump over
 232+ 0E03 21 CC 0F                     ld      HL,KBMAP_CTRL   ; CTRL map
 233+ 0E06 18 07                        jr      LOADMAP         ; and load it
 234+ 0E08 FE 04        CHKALT:         cp      $04             ; ALT flag?
 235+ 0E0A 20 03                        jr      NZ,LOADMAP      ; no, check over
 236+ 0E0C 21 8C 0F                     ld      HL,KBMAP_ALT    ; ALT map
 237+ 0E0F 05           LOADMAP:        dec     B               ; decrement row # (rows go from 0 to 7)
 238+ 0E10 48                           ld      C,B             ; move B into C and...
 239+ 0E11 CB 21                        sla     C               ; ...multiply it...
 240+ 0E13 CB 21                        sla     C               ; ...by 8 to find...
 241+ 0E15 CB 21                        sla     C               ; ...the current row into the matrix
 242+ 0E17 06 00                        ld      B,$00           ; reset B
 243+ 0E19 09                           add     HL,BC           ; find the address of the current row
 244+ 0E1A 50                           ld      D,B             ; reset D
 245+ 0E1B 19                           add     HL,DE           ; find the current column - now (HL) stores the pressed key
 246+ 0E1C 3A B9 55                     ld      A,(LASTKEYPRSD) ; load the last key pressed
 247+ 0E1F BE                           cp      (HL)            ; is it the same key?
 248+ 0E20 20 41                        jr      NZ,NEWKEY       ; no, it's a new key
 249+ 0E22 44 4D                        ld      BC,HL           ; store address of current keycode
 250+ 0E24 2A 5C 55                     ld      HL,(TMRCNT)     ; load current system timer
 251+ 0E27 ED 5B BB 55                  ld      DE,(KEYTMR)     ; load auto-repeat timer
 252+ 0E2B 3A BA 55                     ld      A,(STATUSKEY)   ; yes, load current status of auto-repeat
 253+ 0E2E FE 01                        cp      $01             ; is it initial pressure?
 254+ 0E30 20 1F                        jr      NZ,CHKAUTO      ; no, jump over
 255+ 0E32 AF                           xor     A               ; clear Carry
 256+ 0E33 ED 52                        sbc     HL,DE           ; startint time - actual time
 257+ 0E35 16 00                        ld      D,$00           ; 64 ths/s > 640 ms
 258+ 0E37 3A 2D 54                     ld      A,(KEYDEL)
 259+ 0E3A 5F                           ld      E,A
 260+ 0E3B CD 35 41                     call    CMP16           ; time elapsed is >= $40?
 261+ 0E3E DA B3 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 262+ 0E41 3E 02        SETNEWAUTO:     ld      A,$02           ; yes set status to...
 263+ 0E43 32 BA 55                     ld      (STATUSKEY),A   ; ...auto-repeat
 264+ 0E46 2A 5C 55                     ld      HL,(TMRCNT)     ; load system timer
 265+ 0E49 22 BB 55                     ld      (KEYTMR),HL     ; store starting time
 266+ 0E4C 60 69                        ld      HL,BC           ; retrieve address of current keycode
 267+ 0E4E C3 70 0E                     jp      SENDKEY         ; send key
 268+ 0E51 AF           CHKAUTO:        xor     A               ; clear Carry
 269+ 0E52 ED 52                        sbc     HL,DE           ; computer interval between initial pressure of key and current time
 270+ 0E54 16 00                        ld      D,$00
 271+ 0E56 3A 2E 54                     ld      A,(AUTOKE)
 272+ 0E59 5F                           ld      E,A             ; auto-repeat delay into DE
 273+ 0E5A CD 35 41                     call    CMP16           ; check if interval is greater than delay
 274+ 0E5D DA B3 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 275+ 0E60 C3 41 0E                     jp      SETNEWAUTO      ; set new loop and send key
 276+ 0E63 AF           NEWKEY:         xor     A               ; set initial state...
 277+ 0E64 3C                           inc     A               ; ...for auto-repeat...
 278+ 0E65 32 BA 55                     ld      (STATUSKEY),A   ; ...1=pressure init
 279+ 0E68 ED 4B 5C 55                  ld      BC,(TMRCNT)     ; load current system timer
 280+ 0E6C ED 43 BB 55                  ld      (KEYTMR),BC     ; set starting time
 281+ 0E70 7E           SENDKEY:        ld      A,(HL)          ; then, load key...
 282+ 0E71 32 B9 55                     ld      (LASTKEYPRSD),A ; ...store it...
 283+ 0E74 32 B8 55                     ld      (TMPKEYBFR),A   ; ...insert it into the INKEY buffer...
 284+ 0E77 32 79 55                     ld      (CHR4VID),A     ; ...and store char for video
 285+ 0E7A FE 03                        cp      CTRLC           ; is it RUN/STOP?
 286+ 0E7C 20 05                        jr      NZ,CNTKBCK      ; no, jump over
 287+ 0E7E CD FD 01                     call    CHARINTOBFR     ; yes, send directly to buffer and...
 288+ 0E81 18 30                        jr      LVKBRDCHK2      ; ...leave
 289+ 0E83 01 00 08     CNTKBCK:        ld      BC,$0800        ; 8 FN keys (B), FN key number (C)
 290+ 0E86 21 04 0F                     ld      HL,FNKEYSORD    ; FN keys codes
 291+ 0E89 BE           CHKFNK:         cp      (HL)            ; is it an FN key?
 292+ 0E8A CA B8 0E                     jp      Z,PRNTFNKEY     ; yes, jump over
 293+ 0E8D 0C                           inc     C               ; next FN key
 294+ 0E8E 23                           inc     HL              ; next FN key code
 295+ 0E8F 10 F8                        djnz    CHKFNK          ; continue for 8 FN keys
 296+ 0E91 3E 01        SNDKEYTOBFR:    ld      A,$01           ; normal key - set input flag
 297+ 0E93 32 B6 55                     ld      (KBDNPT),A      ; to keyboard
 298+ 0E96 3A 78 55                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 299+ 0E99 B7                           or      A               ; is the print-on-video disabled?
 300+ 0E9A CA A3 0E                     jp      Z,PUTCHRBUF     ; yes, so send char to input buffer
 301+ 0E9D 3A 76 55                     ld      A,(CRSR_STATE)  ; check cursor state
 302+ 0EA0 B7                           or      A               ; is it 0 (cursor OFF)?
 303+ 0EA1 20 0D                        jr      NZ,PNT2VD       ; no, print on screen
 304+ 0EA3 AF           PUTCHRBUF:      xor     A
 305+ 0EA4 32 B6 55                     ld      (KBDNPT),A      ; if send to input buffer, set RETURN as from BASIC
 306+ 0EA7 3A B8 55                     ld      A,(TMPKEYBFR)   ; retrieve char
 307+ 0EAA CD FD 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 308+ 0EAD C3 B3 0E                     jp      LVKBRDCHK2      ; ...and leave
 309+ 0EB0 CD 5A 07     PNT2VD:         call    CHAR2VID        ; send char to video
 310+ 0EB3 AF           LVKBRDCHK2:     xor     A
 311+ 0EB4 32 BD 55                     ld      (CONTROLKEYS),A ; reset control key flags
 312+ 0EB7 C9                           ret                     ; return to caller: the current key code is into TMPKEYBFR
 313+ 0EB8                              ; manage FN keys
 314+ 0EB8 57           PRNTFNKEY:      ld      D,A             ; copy A into D
 315+ 0EB9 2A 29 54                     ld      HL,(LINEAT)     ; Get current line number
 316+ 0EBC 23                           inc     HL              ; -1 means direct statement
 317+ 0EBD 7C                           ld      A,H
 318+ 0EBE B5                           or      L
 319+ 0EBF 7A                           ld      A,D             ; retrieve char
 320+ 0EC0 20 CF                        jr      NZ,SNDKEYTOBFR  ; indirect mode - just send FN key code to buffer
 321+ 0EC2 79                           ld      A,C             ; direct mode, so print text - first, get FN key number
 322+ 0EC3 87                           add     A,A
 323+ 0EC4 87                           add     A,A
 324+ 0EC5 87                           add     A,A
 325+ 0EC6 87                           add     A,A             ; FN key number * 16
 326+ 0EC7 4F                           ld      C,A             ; move it into C
 327+ 0EC8 06 00                        ld      B,$00           ; reset B, to get offset
 328+ 0ECA 21 2F 54                     ld      HL,FNKEYS       ; load address of FN keys texts
 329+ 0ECD 09                           add     HL,BC           ; get correct text address
 330+ 0ECE 06 10                        ld      B,$10           ; 16 chars
 331+ 0ED0 7E           LDFNKEYCHR:     ld      A,(HL)          ; load char
 332+ 0ED1 A7                           and     A               ; null char?
 333+ 0ED2 CA B3 0E                     jp      Z,LVKBRDCHK2    ; yes, so leave
 334+ 0ED5 57                           ld      D,A             ; pass char into D
 335+ 0ED6 3A 78 55                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 336+ 0ED9 B7                           or      A               ; is the print-on-video disabled?
 337+ 0EDA CA EA 0E                     jp      Z,PUTCHRBUF1    ; yes, so send char to input buffer
 338+ 0EDD 3A 76 55                     ld      A,(CRSR_STATE)  ; check cursor state
 339+ 0EE0 B7                           or      A               ; is it 0 (cursor OFF)?
 340+ 0EE1 C4 F7 0E                     call    NZ,PRNTFNK      ; no, print on screen
 341+ 0EE4 23           CNTFNK:         inc     HL              ; next char
 342+ 0EE5 10 E9                        djnz    LDFNKEYCHR      ; repeat for max. 16 chars
 343+ 0EE7 C3 B3 0E                     jp      LVKBRDCHK2      ; leave
 344+ 0EEA AF           PUTCHRBUF1:     xor     A               ; if send to input buffer,...
 345+ 0EEB 32 B6 55                     ld      (KBDNPT),A      ; ...set input as from BASIC
 346+ 0EEE 7A                           ld      A,D             ; retrieve char
 347+ 0EEF E5                           push    HL              ; store HL
 348+ 0EF0 CD FD 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 349+ 0EF3 E1                           pop     HL              ; retrieve HL
 350+ 0EF4 C3 E4 0E                     jp      CNTFNK          ; repeat
 351+ 0EF7 7A           PRNTFNK:        ld      A,D             ; recover char
 352+ 0EF8 32 79 55                     ld      (CHR4VID),A     ; store char for printing
 353+ 0EFB 3E 01                        ld      A,$01           ; normal key - set input flag
 354+ 0EFD 32 B6 55                     ld      (KBDNPT),A      ; to keyboard
 355+ 0F00 CD 5A 07                     call    CHAR2VID        ; print on screen
 356+ 0F03 C9                           ret                     ; return to caller
 357+ 0F04
 358+ 0F04
 359+ 0F04              ;-----------------------------------------------------------------------
 360+ 0F04 01 02 04 05  FNKEYSORD:      defb 1,2,4,5,6,22,23,24                 ; order of FN Keys
 360+ 0F08 06 16 17 18
 361+ 0F0C              ;-----------------------------------------------------------------------
 362+ 0F0C              ; key codes
 363+ 0F0C 31 19 0E 03  KBMAP:          defb '1',25,14,3,' ',16,'q','2'         ; 25=HOME  14=CTRL  3=RUN/STOP 16=C=
 363+ 0F10 20 10 71 32
 364+ 0F14 33 77 61 14                  defb '3','w','a',20,'z','s','e','4'     ; 20=SHIFT
 364+ 0F18 7A 73 65 34
 365+ 0F1C 35 72 64 78                  defb '5','r','d','x','c','f','t','6'
 365+ 0F20 63 66 74 36
 366+ 0F24 37 79 67 76                  defb '7','y','g','v','b','h','u','8'
 366+ 0F28 62 68 75 38
 367+ 0F2C 39 69 6A 6E                  defb '9','i','j','n','m','k','o','0'
 367+ 0F30 6D 6B 6F 30
 368+ 0F34 1F 70 6C 2C                  defb 31,'p','l',',','.',':','-',30      ; 31=CURSOR DOWN  30=CURSOR UP
 368+ 0F38 2E 3A 2D 1E
 369+ 0F3C 1C 2A 3B 2F                  defb 28,'*',';','/',27,'=','+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 369+ 0F40 1B 3D 2B 1D
 370+ 0F44 08 0D FC 40                  defb 8,13,252,'@',1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 370+ 0F48 01 02 04 18
 371+ 0F4C
 372+ 0F4C              ; shifted codes - not all the keys have the shifted version
 373+ 0F4C 21 0C 0E 03  KBMAP_SFT:      defb '!',12,14,3,' ',16,'Q',34          ; 12=CLEAR  14=CTRL  3=RUN/STOP 16=C=   34="
 373+ 0F50 20 10 51 22
 374+ 0F54 23 57 41 14                  defb '#','W','A',20,'Z','S','E','$'     ; 20=SHIFT
 374+ 0F58 5A 53 45 24
 375+ 0F5C 25 52 44 58                  defb '%','R','D','X','C','F','T','&'
 375+ 0F60 43 46 54 26
 376+ 0F64 27 59 47 56                  defb 39,'Y','G','V','B','H','U','('     ; 39='
 376+ 0F68 42 48 55 28
 377+ 0F6C 29 49 4A 4E                  defb ')','I','J','N','M','K','O',94     ; 94=^
 377+ 0F70 4D 4B 4F 5E
 378+ 0F74 1F 50 4C 3C                  defb 31,'P','L','<','>','[','_',30      ; 31=CURSOR DOWN  30=CURSOR UP
 378+ 0F78 3E 5B 5F 1E
 379+ 0F7C 1C 2A 5D 3F                  defb 28,'*',']','?',27,198,'+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 379+ 0F80 1B C6 2B 1D
 380+ 0F84 1A 0D D3 40                  defb 26,13,211,'@',5,6,22,23            ; 26=INSERT, 211=â¬  5=F4  6=F5  22=F6  23=F7
 380+ 0F88 05 06 16 17
 381+ 0F8C
 382+ 0F8C              ; ALT (C=) codes - not all the keys have the alt-ed version
 383+ 0F8C 31 0C 0E 03  KBMAP_ALT:      defb '1',12,14,3,' ',16,222,196         ; 12=CLEAR  14=CTRL  3=RUN/STOP  16=C=  34="
 383+ 0F90 20 10 DE C4
 384+ 0F94 33 DD 85 14                  defb '3',221,133,20,131,130,165,'4'     ; 20=SHIFT
 384+ 0F98 83 82 A5 34
 385+ 0F9C 35 A2 A6 84                  defb '5',162,166,132,157,163,168,'6'
 385+ 0FA0 9D A3 A8 36
 386+ 0FA4 37 AB A9 A1                  defb '7',171,169,161,158,172,213,'8'    ;
 386+ 0FA8 9E AC D5 38
 387+ 0FAC 39 D6 D8 9F                  defb '9',214,216,159,160,215,135,195    ;
 387+ 0FB0 A0 D7 87 C3
 388+ 0FB4 1F 88 8A C1                  defb 31,136,138,193,192,123,144,30      ; 31=CURSOR DOWN  123={  30=CURSOR UP
 388+ 0FB8 C0 7B 90 1E
 389+ 0FBC 1C 8F 7D FE                  defb 28,143,125,254,27,209,148,29       ; 28=CURSOR LEFT  125=}  27=ESCAPE  29=CURSOR RIGHT
 389+ 0FC0 1B D1 94 1D
 390+ 0FC4 08 0D E0 89                  defb 8,13,224,137,5,6,22,23             ; 8=DEL(backspace)  13=RETURN  252=Â£  5=F4  6=F5  22=F6  23=F7
 390+ 0FC8 05 06 16 17
 391+ 0FCC
 392+ 0FCC              ; CTRL codes - not all the keys have the control-ed version
 393+ 0FCC 31 19 0E 03  KBMAP_CTRL:     defb '1',25,14,3,' ',16,154,'2'         ; 25=HOME  14=CTRL  3=RUN/STOP  16=C=
 393+ 0FD0 20 10 9A 32
 394+ 0FD4 33 9C 95 14                  defb '3',156,149,20,152,150,153,'4'     ; 20=SHIFT
 394+ 0FD8 98 96 99 34
 395+ 0FDC 35 9B B0 97                  defb '5',155,176,151,177,175,165,'6'
 395+ 0FE0 B1 AF A5 36
 396+ 0FE4 37 A6 A8 B2                  defb '7',166,168,178,179,169,167,'8'
 396+ 0FE8 B3 A9 A7 38
 397+ 0FEC 39 B8 AA AC                  defb '9',184,170,172,171,181,164,'0'
 397+ 0FF0 AB B5 A4 30
 398+ 0FF4 1F A3 AD 2C                  defb 31,163,173,',','.',':',186,30      ; 31=CURSOR DOWN  30=CURSOR UP
 398+ 0FF8 2E 3A BA 1E
 399+ 0FFC 1C E1 3B 2F                  defb 28,225,';','/',27,212,185,29       ; 28=CURSOR LEFT  27=ESCAPE  212=Ï  29=CURSOR RIGHT
 399+ 1000 1B D4 B9 1D
 400+ 1004 08 0D BD A2                  defb 8,13,189,162,1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 400+ 1008 01 02 04 18
# file closed: ../include/psg/psg-1.1.asm
  73  100C
  74  100C              ; include the latest version of the LM80C 64K BASIC interpreter
  75  100C                  INCLUDE "../include/basic/basic-1.11.asm"
# file opened: ../include/basic/basic-1.11.asm
   1+ 100C              ; ------------------------------------------------------------------------------
   2+ 100C              ; LM80C BASIC (32K/64K) - R3.25
   3+ 100C              ; ------------------------------------------------------------------------------
   4+ 100C              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 100C              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 100C              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 100C              ; kind of warranty: you can use them at your own risk.
   8+ 100C              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 100C              ; maintain the copyright notices, include this advice and the note to the
  10+ 100C              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 100C              ; redistribuite them.
  12+ 100C              ; https://www.leonardomiliani.com
  13+ 100C              ;
  14+ 100C              ; Please support me by visiting the following links:
  15+ 100C              ; Main project page: https://www.leonardomiliani.com
  16+ 100C              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 100C              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 100C              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 100C              ; ------------------------------------------------------------------------------
  20+ 100C              ; LM80C BASIC 64K - originally based on the following NASCOM BASIC versions:
  21+ 100C              ; 4.7  - original version by NASCOM/MICROSOFT
  22+ 100C              ; 4.7b - modified version by Grant Searle (additional commands & functions)
  23+ 100C
  24+ 100C
  25+ 100C              ;------------------------------------------------------------------------------
  26+ 100C              ;  L M 8 0 C   B A S I C
  27+ 100C              ;------------------------------------------------------------------------------
  28+ 100C
  29+ 100C              ; GENERAL EQUATES
  30+ 100C
  31+ 100C              NLLCR           equ     $00             ; null char (used as space/empty char in video prints)
  32+ 100C              CTRLC           equ     $03             ; Control "C"
  33+ 100C              CTRLG           equ     $07             ; Control "G"
  34+ 100C              BKSP            equ     $08             ; Back space
  35+ 100C              LF              equ     $0A             ; Line feed
  36+ 100C              CS              equ     $0C             ; Clear screen
  37+ 100C              CR              equ     $0D             ; Carriage return
  38+ 100C              CTRLO           equ     $0F             ; Control "O"
  39+ 100C              CTRLQ           equ     $11             ; Control "Q"
  40+ 100C              CTRLR           equ     $12             ; Control "R"
  41+ 100C              CTRLS           equ     $13             ; Control "S"
  42+ 100C              CTRLU           equ     $15             ; Control "U"
  43+ 100C              HOME            equ     $19             ; Home (cursor at 0,0)
  44+ 100C              ESC             equ     $1B             ; Escape
  45+ 100C              SPC             equ     $20             ; Space
  46+ 100C              DEL             equ     $7F             ; Delete
  47+ 100C              INSRT           equ     $1A             ; Insert Key
  48+ 100C              ; cursor ASCII codes
  49+ 100C              CRSLFT          equ     $1C             ; cursor left
  50+ 100C              CRSRGT          equ     $1D             ; cursor right
  51+ 100C              CRSUP           equ     $1E             ; cursor up
  52+ 100C              CRSDN           equ     $1F             ; cursor down
  53+ 100C
  54+ 100C
  55+ 100C              ;-------------------------------------------------------------------------
  56+ 100C              ; BASIC ERROR MESSAGES
  57+ 100C              ; the interpreter looks for a single-byte code in the following list,
  58+ 100C              ; then loads the corresponding memory pointer in "ERRTBL" table to
  59+ 100C              ; find where to retrieve the message text in "ERRORS"
  60+ 100C
  61+ 100C              ; BASIC ERROR CODE VALUES
  62+ 100C              ; These values act as an offset to point to the error message into the error table
  63+ 100C              ; must be incremented by 2 because they point to a word address jump
  64+ 100C              NF      equ     $00     ; NEXT without FOR
  65+ 100C              SN      equ     $02     ; Syntax error
  66+ 100C              RG      equ     $04     ; RETURN without GOSUB
  67+ 100C              OD      equ     $06     ; Out of DATA
  68+ 100C              FC      equ     $08     ; Function call error
  69+ 100C              OV      equ     $0A     ; Overflow
  70+ 100C              OM      equ     $0C     ; Out of memory
  71+ 100C              UL      equ     $0E     ; Undefined line number
  72+ 100C              BS      equ     $10     ; Bad subscript
  73+ 100C              DD      equ     $12     ; Re-Dimensioned array
  74+ 100C              DZ      equ     $14     ; Division by zero (/0)
  75+ 100C              ID      equ     $16     ; Illegal direct
  76+ 100C              TM      equ     $18     ; Type mis-match
  77+ 100C              OS      equ     $1A     ; Out of string space
  78+ 100C              LS      equ     $1C     ; String too long
  79+ 100C              ST      equ     $1E     ; String formula too complex
  80+ 100C              CN      equ     $20     ; Can't continue
  81+ 100C              UF      equ     $22     ; Undefined FN function
  82+ 100C              MO      equ     $24     ; Missing operand
  83+ 100C              HE      equ     $26     ; HEX error
  84+ 100C              BN      equ     $28     ; BIN error
  85+ 100C              GM      equ     $2A     ; No Graphics Mode
  86+ 100C              SC      equ     $2C     ; Serial configuration
  87+ 100C              SA      equ     $2E     ; Serial port already open
  88+ 100C              SO      equ     $30     ; Serial buffer overrun
  89+ 100C              HP      equ     $32     ; HELP call
  90+ 100C              IM      equ     $34     ; Illegal indirect
  91+ 100C              NR      equ     $36     ; Device not ready
  92+ 100C              D0      equ     $38     ; File open/close error
  93+ 100C              D1      equ     $3A     ; Disk/File name error
  94+ 100C              D2      equ     $3C     ; Disk geometry error
  95+ 100C              D3      equ     $3E     ; Save error
  96+ 100C              D4      equ     $40     ; Load error
  97+ 100C              D5      equ     $42     ; Disk full error
  98+ 100C              D6      equ     $44     ; Duplicate file name error
  99+ 100C              D7      equ     $46     ; DOS version error
 100+ 100C              D8      equ     $48     ; File not found error
 101+ 100C              D9      equ     $4A     ; File already open
 102+ 100C              DA      equ     $4C     ; End of file
 103+ 100C
 104+ 100C
 105+ 100C              ; BASIC ERROR POINTER TABLE
 106+ 100C              ERRTBL: equ $
 107+ 100C 5A 10        NFPTR:  defw    NFMSG
 108+ 100E 6B 10        SNPTR:  defw    SNMSG
 109+ 1010 72 10        RGPTR:  defw    RGMSG
 110+ 1012 87 10        ODPTR:  defw    ODMSG
 111+ 1014 93 10        FCPTR:  defw    FCMSG
 112+ 1016 A9 10        OVPTR:  defw    OVMSG
 113+ 1018 B2 10        OMPTR:  defw    OMMSG
 114+ 101A C0 10        ULPTR:  defw    ULMSG
 115+ 101C CF 10        BSPTR:  defw    BSMSG
 116+ 101E DD 10        DDPTR:  defw    DDMSG
 117+ 1020 F2 10        DZPTR:  defw    DZMSG
 118+ 1022 03 11        IDPTR:  defw    IDMSG
 119+ 1024 17 11        TMPTR:  defw    TMMSG
 120+ 1026 26 11        OSPTR:  defw    OSMSG
 121+ 1028 3A 11        LSPTR:  defw    LSMSG
 122+ 102A 4A 11        STPTR:  defw    STMSG
 123+ 102C 65 11        CNPTR:  defw    CNMSG
 124+ 102E 74 11        UFPTR:  defw    UFMSG
 125+ 1030 8A 11        MOPTR:  defw    MOMSG
 126+ 1032 9A 11        HEPTR:  defw    HEMSG
 127+ 1034 A5 11        BNPTR:  defw    BNMSG
 128+ 1036 B0 11        GMPRT:  defw    GMMSG
 129+ 1038 C1 11        SCPTR:  defw    SCMSG
 130+ 103A D6 11        SAPTR:  defw    SAMSG
 131+ 103C EF 11        SOPTR:  defw    SOMSG
 132+ 103E 05 12        HPPTR:  defw    HPMSG
 133+ 1040 0F 12        IMPRT:  defw    IMMSG
 134+ 1042 25 12        NRPRT:  defw    NRMSG
 135+ 1044 36 12        D0PTR:  defw    D0MSG
 136+ 1046 46 12        D1PRT:  defw    D1MSG
 137+ 1048 52 12        D2PRT:  defw    D2MSG
 138+ 104A 60 12        D3PRT:  defw    D3MSG
 139+ 104C 65 12        D4PTR:  defw    D4MSG
 140+ 104E 6A 12        D5PTR:  defw    D5MSG
 141+ 1050 74 12        D6PTR:  defw    D6MSG
 142+ 1052 88 12        D7PRT:  defw    D7MSG
 143+ 1054 94 12        D8PTR:  defw    D8MSG
 144+ 1056 A3 12        D9PTR:  defw    D9MSG
 145+ 1058 B5 12        DAPTR:  defw    DAMSG
 146+ 105A
 147+ 105A
 148+ 105A              ; BASIC ERROR MESSAGE LIST
 149+ 105A              ERRORS  equ $
 150+ 105A 4E 45 58 54  NFMSG:  defb    "NEXT Without FOR",0
 150+ 105E 20 57 69 74
 150+ 1062 68 6F 75 74
 150+ 1066 20 46 4F 52
 150+ 106A 00
 151+ 106B 53 79 6E 74  SNMSG:  defb    "Syntax",0
 151+ 106F 61 78 00
 152+ 1072 52 45 54 55  RGMSG:  defb    "RETURN without GOSUB",0
 152+ 1076 52 4E 20 77
 152+ 107A 69 74 68 6F
 152+ 107E 75 74 20 47
 152+ 1082 4F 53 55 42
 152+ 1086 00
 153+ 1087 4F 75 74 20  ODMSG:  defb    "Out of DATA",0
 153+ 108B 6F 66 20 44
 153+ 108F 41 54 41 00
 154+ 1093 49 6C 6C 65  FCMSG:  defb    "Illegal Function Call",0
 154+ 1097 67 61 6C 20
 154+ 109B 46 75 6E 63
 154+ 109F 74 69 6F 6E
 154+ 10A3 20 43 61 6C
 154+ 10A7 6C 00
 155+ 10A9 4F 76 65 72  OVMSG:  defb    "Overflow",0
 155+ 10AD 66 6C 6F 77
 155+ 10B1 00
 156+ 10B2 4F 75 74 20  OMMSG:  defb    "Out of Memory",0
 156+ 10B6 6F 66 20 4D
 156+ 10BA 65 6D 6F 72
 156+ 10BE 79 00
 157+ 10C0 55 6E 64 65  ULMSG:  defb    "Undefined Line",0
 157+ 10C4 66 69 6E 65
 157+ 10C8 64 20 4C 69
 157+ 10CC 6E 65 00
 158+ 10CF 42 61 64 20  BSMSG:  defb    "Bad Subscript",0
 158+ 10D3 53 75 62 73
 158+ 10D7 63 72 69 70
 158+ 10DB 74 00
 159+ 10DD 52 65 2D 44  DDMSG:  defb    "Re-Dimensioned Array",0
 159+ 10E1 69 6D 65 6E
 159+ 10E5 73 69 6F 6E
 159+ 10E9 65 64 20 41
 159+ 10ED 72 72 61 79
 159+ 10F1 00
 160+ 10F2 44 69 76 69  DZMSG:  defb    "Division by Zero",0
 160+ 10F6 73 69 6F 6E
 160+ 10FA 20 62 79 20
 160+ 10FE 5A 65 72 6F
 160+ 1102 00
 161+ 1103 49 6C 6C 65  IDMSG:  defb    "Illegal Direct Mode",0
 161+ 1107 67 61 6C 20
 161+ 110B 44 69 72 65
 161+ 110F 63 74 20 4D
 161+ 1113 6F 64 65 00
 162+ 1117 54 79 70 65  TMMSG:  defb    "Type Mis-match",0
 162+ 111B 20 4D 69 73
 162+ 111F 2D 6D 61 74
 162+ 1123 63 68 00
 163+ 1126 4F 75 74 20  OSMSG:  defb    "Out of String Space",0
 163+ 112A 6F 66 20 53
 163+ 112E 74 72 69 6E
 163+ 1132 67 20 53 70
 163+ 1136 61 63 65 00
 164+ 113A 53 74 72 69  LSMSG:  defb    "String Too Long",0
 164+ 113E 6E 67 20 54
 164+ 1142 6F 6F 20 4C
 164+ 1146 6F 6E 67 00
 165+ 114A 53 74 72 69  STMSG:  defb    "String Formula Too Complex",0
 165+ 114E 6E 67 20 46
 165+ 1152 6F 72 6D 75
 165+ 1156 6C 61 20 54
 165+ 115A 6F 6F 20 43
 165+ 115E 6F 6D 70 6C
 165+ 1162 65 78 00
 166+ 1165 43 61 6E 27  CNMSG:  defb    "Can't Continue",0
 166+ 1169 74 20 43 6F
 166+ 116D 6E 74 69 6E
 166+ 1171 75 65 00
 167+ 1174 55 6E 64 65  UFMSG:  defb    "Undefined FN Function",0
 167+ 1178 66 69 6E 65
 167+ 117C 64 20 46 4E
 167+ 1180 20 46 75 6E
 167+ 1184 63 74 69 6F
 167+ 1188 6E 00
 168+ 118A 4D 69 73 73  MOMSG:  defb    "Missing Operand",0
 168+ 118E 69 6E 67 20
 168+ 1192 4F 70 65 72
 168+ 1196 61 6E 64 00
 169+ 119A 48 45 58 20  HEMSG:  defb    "HEX Format",0
 169+ 119E 46 6F 72 6D
 169+ 11A2 61 74 00
 170+ 11A5 42 49 4E 20  BNMSG:  defb    "BIN Format",0
 170+ 11A9 46 6F 72 6D
 170+ 11AD 61 74 00
 171+ 11B0 4E 6F 20 47  GMMSG:  defb    "No Graphics Mode",0
 171+ 11B4 72 61 70 68
 171+ 11B8 69 63 73 20
 171+ 11BC 4D 6F 64 65
 171+ 11C0 00
 172+ 11C1 53 65 72 69  SCMSG:  defb    "Serial Configuration",0
 172+ 11C5 61 6C 20 43
 172+ 11C9 6F 6E 66 69
 172+ 11CD 67 75 72 61
 172+ 11D1 74 69 6F 6E
 172+ 11D5 00
 173+ 11D6 53 65 72 69  SAMSG:  defb    "Serial Port Already Open",0
 173+ 11DA 61 6C 20 50
 173+ 11DE 6F 72 74 20
 173+ 11E2 41 6C 72 65
 173+ 11E6 61 64 79 20
 173+ 11EA 4F 70 65 6E
 173+ 11EE 00
 174+ 11EF 53 65 72 69  SOMSG:  defb    "Serial Buffer Overrun",0
 174+ 11F3 61 6C 20 42
 174+ 11F7 75 66 66 65
 174+ 11FB 72 20 4F 76
 174+ 11FF 65 72 72 75
 174+ 1203 6E 00
 175+ 1205 48 45 4C 50  HPMSG:  defb    "HELP Call",0
 175+ 1209 20 43 61 6C
 175+ 120D 6C 00
 176+ 120F 49 6C 6C 65  IMMSG:  defb    "Illegal Indirect Mode",0
 176+ 1213 67 61 6C 20
 176+ 1217 49 6E 64 69
 176+ 121B 72 65 63 74
 176+ 121F 20 4D 6F 64
 176+ 1223 65 00
 177+ 1225 44 65 76 69  NRMSG:  defb    "Device Not Ready",0
 177+ 1229 63 65 20 4E
 177+ 122D 6F 74 20 52
 177+ 1231 65 61 64 79
 177+ 1235 00
 178+ 1236 46 69 6C 65  D0MSG:  defb    "File Open/Close",0
 178+ 123A 20 4F 70 65
 178+ 123E 6E 2F 43 6C
 178+ 1242 6F 73 65 00
 179+ 1246 4E 61 6D 65  D1MSG:  defb    "Name String",0
 179+ 124A 20 53 74 72
 179+ 124E 69 6E 67 00
 180+ 1252 44 69 73 6B  D2MSG:  defb    "Disk Geometry",0
 180+ 1256 20 47 65 6F
 180+ 125A 6D 65 74 72
 180+ 125E 79 00
 181+ 1260 53 61 76 65  D3MSG:  defb    "Save",0
 181+ 1264 00
 182+ 1265 4C 6F 61 64  D4MSG:  defb    "Load",0
 182+ 1269 00
 183+ 126A 44 69 73 6B  D5MSG:  defb    "Disk Full",0
 183+ 126E 20 46 75 6C
 183+ 1272 6C 00
 184+ 1274 44 75 70 6C  D6MSG:  defb    "Duplicate File Name",0
 184+ 1278 69 63 61 74
 184+ 127C 65 20 46 69
 184+ 1280 6C 65 20 4E
 184+ 1284 61 6D 65 00
 185+ 1288 44 4F 53 20  D7MSG:  defb    "DOS Version",0
 185+ 128C 56 65 72 73
 185+ 1290 69 6F 6E 00
 186+ 1294 46 69 6C 65  D8MSG:  defb    "File Not Found",0
 186+ 1298 20 4E 6F 74
 186+ 129C 20 46 6F 75
 186+ 12A0 6E 64 00
 187+ 12A3 46 69 6C 65  D9MSG:  defb    "File Already Open",0
 187+ 12A7 20 41 6C 72
 187+ 12AB 65 61 64 79
 187+ 12AF 20 4F 70 65
 187+ 12B3 6E 00
 188+ 12B5 45 6E 64 20  DAMSG:  defb    "End Of File",0
 188+ 12B9 4F 66 20 46
 188+ 12BD 69 6C 65 00
 189+ 12C1
 190+ 12C1
 191+ 12C1              ;-----------------------------------------------------------------------------
 192+ 12C1              ; STARTING POINTS FOR BASIC BOOT
 193+ 12C1              ; COLD: reset every memory pointer, acting as a power-up boot
 194+ 12C1              ; WARM: preserve program in memory, keeping every current pointer
 195+ 12C1
 196+ 12C1 C3 C7 12     COLD:   jp      STARTB          ; Jump for cold start
 197+ 12C4 C3 9D 13     WARM:   jp      WARMST          ; Jump for warm start
 198+ 12C7
 199+ 12C7 C3 CE 12     STARTB: jp      CSTART          ; Jump to initialise
 200+ 12CA 0F 1E                defw    DEINT           ; Get integer -32768 to 32767
 201+ 12CC D4 25                defw    ABPASS          ; Return integer in AB
 202+ 12CE 21 D8 53     CSTART: ld      HL,WRKSPC       ; Start of workspace RAM
 203+ 12D1 F9                   ld      SP,HL           ; Set up a temporary stack
 204+ 12D2 C3 27 41             jp      INITST          ; Go to initialise
 205+ 12D5
 206+ 12D5 21 A9 16     SYSINIT:ld      HL,INITAB       ; Initialise workspace
 207+ 12D8 01 DC 00             ld      BC,INITBE-INITAB+3; Bytes to copy
 208+ 12DB 11 D8 53             ld      DE,WRKSPC       ; Into workspace RAM
 209+ 12DE ED B0                ldir                    ; Copy data
 210+ 12E0 EB                   ex      DE,HL           ; Copy DE into HL
 211+ 12E1 F9                   ld      SP,HL           ; Temporary stack
 212+ 12E2 CD 72 19             call    CLREG           ; Clear registers and stack
 213+ 12E5 CD 26 20             call    PRNTCRLF        ; Output CRLF
 214+ 12E8 32 0B 55             ld      (BUFFER+88+1),A ; Mark end of buffer
 215+ 12EB 32 E5 55             ld      (PROGST),A      ; Initialise program area
 216+ 12EE 18 13                jr      MNOASK          ; usually, don't ask for memory top (only when there are errors)
 217+ 12F0 21 21 14     MSIZE:  ld      HL,MEMMSG       ; Point to message
 218+ 12F3 CD F2 26             call    PRS             ; Output "Memory size"
 219+ 12F6 CD 8F 19             call    PROMPT          ; Get input with '?'
 220+ 12F9 CD 26 09             call    CURSOR_ON       ; enable cursor
 221+ 12FC CD 59 1D             call    GETCHR          ; Get next character
 222+ 12FF B7                   or      A               ; Set flags
 223+ 1300 C2 18 13             jp      NZ,TSTMEM       ; If number - Test if RAM there
 224+ 1303 21 49 56     MNOASK: ld      HL,STLOOK       ; Point to start of RAM
 225+ 1306 23           MLOOP:  inc     HL              ; Next byte
 226+ 1307 7C                   ld      A,H             ; Above address FFFF ?
 227+ 1308 B5                   or      L
 228+ 1309 CA 2A 13             jp      Z,SETTOP        ; Yes - 64K RAM
 229+ 130C 7E                   ld      A,(HL)          ; Get contents
 230+ 130D 47                   ld      B,A             ; Save it
 231+ 130E 2F                   cpl                     ; Flip all bits
 232+ 130F 77                   ld      (HL),A          ; Put it back
 233+ 1310 BE                   cp      (HL)            ; RAM there if same
 234+ 1311 70                   ld      (HL),B          ; Restore old contents
 235+ 1312 CA 06 13             jp      Z,MLOOP         ; If RAM - test next byte
 236+ 1315 C3 2A 13             jp      SETTOP          ; Top of RAM found
 237+ 1318
 238+ 1318 CD 29 1E     TSTMEM: call    ATOH            ; Get high memory into DE
 239+ 131B B7                   or      A               ; Set flags on last byte
 240+ 131C C2 10 18             jp      NZ,SNERR        ; ?SN Error if bad character
 241+ 131F EB                   ex      DE,HL           ; Address into HL
 242+ 1320 2B                   dec     HL              ; Back one byte
 243+ 1321 3E D9                ld      A,%11011001     ; Test byte
 244+ 1323 46                   ld      B,(HL)          ; Get old contents
 245+ 1324 77                   ld      (HL),A          ; Load test byte
 246+ 1325 BE                   cp      (HL)            ; RAM there if same
 247+ 1326 70                   ld      (HL),B          ; Restore old contents
 248+ 1327 C2 F0 12             jp      NZ,MSIZE        ; Ask again if no RAM
 249+ 132A
 250+ 132A CD 3B 09     SETTOP: call    CURSOR_OFF      ; disable cursor
 251+ 132D 2B                   dec     HL              ; Back one byte
 252+ 132E 11 48 56             ld      DE,STLOOK-1     ; See if enough RAM
 253+ 1331 CD 0A 1B             call    CPDEHL          ; Compare DE with HL
 254+ 1334 DA F0 12             jp      C,MSIZE         ; Ask again if not enough RAM
 255+ 1337 3A C1 55             ld      A,(DOS_EN)      ; read if the user enabled/disabled DOS while booting
 256+ 133A 1F                   rra                     ; is DOS enabled?
 257+ 133B 38 1C                jr      C,SETDSR        ; yes, so jump over
 258+ 133D DD 21 E3 FF          ld      IX,DOSJPTB+1    ; point to 1st address of DOS jump table
 259+ 1341
 260+ 1341                      DEFINE  DOSNTRS 10      ; DOS entries <-- CHANGE THIS VALUE TO ALIGN IT WITH THE NUMBER OF ENTRIES
 261+ 1341
 262+ 1341 06 0A                ld      B,10       ; number of entries
 263+ 1343 11 10 18             ld      DE,SNERR        ; address of REM routine
 264+ 1346 DD 73 00     CPDSTB: ld      (IX),E          ; copy REM address...
 265+ 1349 DD 23                inc     IX              ; ...into the...
 266+ 134B DD 72 00             ld      (IX),D          ; ...jump entry
 267+ 134E DD 23                inc     IX              ; next jump address
 268+ 1350 DD 23                inc     IX
 269+ 1352 10 F2                djnz    CPDSTB          ; repeat
 270+ 1354 11 E2 FF             ld      DE,0-(10*3); protect jump table (3 byte for each entry)
 271+ 1357 18 03                jr      SETNOD
 272+ 1359 11 70 EE     SETDSR: ld      DE,0-($FFFF-DOSSTART+1) ; no, so reserve RAM occupied by DOS & I/O buffers
 273+ 135C 19           SETNOD: add     HL,DE
 274+ 135D 22 10 55     SETTRAM:ld      (LSTRAM),HL     ; Save last available RAM
 275+ 1360 11 9C FF             ld      DE,0-100        ; now, reserve 100 bytes for string space
 276+ 1363 19                   add     HL,DE           ; Allocate string space
 277+ 1364 22 27 54             ld      (STRSPC),HL     ; Save string space
 278+ 1367 CD 4D 19             call    CLRPTR          ; Clear program area
 279+ 136A 2A 27 54             ld      HL,(STRSPC)     ; Get end of memory
 280+ 136D 11 EF FF             ld      DE,0-17         ; Offset for free bytes
 281+ 1370 19                   add     HL,DE           ; Adjust HL
 282+ 1371 11 E5 55             ld      DE,PROGST       ; Start of program text
 283+ 1374 7D                   ld      A,L             ; Get LSB
 284+ 1375 93                   sub     E               ; Adjust it
 285+ 1376 6F                   ld      L,A             ; Re-save
 286+ 1377 7C                   ld      A,H             ; Get MSB
 287+ 1378 9A                   sbc     A,D             ; Adjust it
 288+ 1379 67                   ld      H,A             ; Re-save
 289+ 137A E5                   push    HL              ; Save bytes free
 290+ 137B 21 C3 13             ld      HL,SIGNON       ; Sign-on message
 291+ 137E CD F2 26             call    PRS             ; Output string
 292+ 1381 3A C1 55             ld      A,(DOS_EN)      ; check if DOS is enabled
 293+ 1384 B7                   or      A
 294+ 1385 28 06                jr      Z,SETTP1        ; no DOS, jump over
 295+ 1387 21 04 14             ld      HL,DOSMSG       ; DOS message
 296+ 138A CD F2 26             call    PRS
 297+ 138D 21 AC 13     SETTP1: ld      HL,BLNSPC       ; Empty space
 298+ 1390 CD F2 26             call    PRS             ; Output string
 299+ 1393 E1                   pop     HL              ; Get bytes free back
 300+ 1394 CD 91 31             call    PRNTHL          ; Output amount of free memory
 301+ 1397 21 B5 13             ld      HL,BFREE        ; " Bytes free" message
 302+ 139A CD F2 26             call    PRS             ; Output string
 303+ 139D
 304+ 139D 31 B7 54     WARMST: ld      SP,STACK        ; Temporary stack
 305+ 13A0 CD 72 19     BRKRET: call    CLREG           ; Clear registers and stack
 306+ 13A3 CD B5 3E             call    RESFN           ; reset FN keys and auto-repeat
 307+ 13A6 CD 26 09             call    CURSOR_ON       ; enable cursor
 308+ 13A9 C3 70 18             jp      PRNTOK          ; Go to get command line
 309+ 13AC
 310+ 13AC 20 20 20 20  BLNSPC: defb    "        ",0    ; 8 empty cells to align the "XXXX Bytes free" message
 310+ 13B0 20 20 20 20
 310+ 13B4 00
 311+ 13B5 20 42 79 74  BFREE:  defb    " Bytes free",CR,CR,0
 311+ 13B9 65 73 20 66
 311+ 13BD 72 65 65 0D
 311+ 13C1 0D 00
 312+ 13C3
 313+ 13C3 4C 4D 38 30  SIGNON: defb    "LM80C BASIC 3.25 ",251,"2021 L.Miliani"
 313+ 13C7 43 20 42 41
 313+ 13CB 53 49 43 20
 313+ 13CF 33 2E 32 35
 313+ 13D3 20 FB 32 30
 313+ 13D7 32 31 20 4C
 313+ 13DB 2E 4D 69 6C
 313+ 13DF 69 61 6E 69
 314+ 13E3 20 5A 38 30          defb    " Z80 BASIC 4.7  ",251,"1978 Microsoft",CR,0
 314+ 13E7 20 42 41 53
 314+ 13EB 49 43 20 34
 314+ 13EF 2E 37 20 20
 314+ 13F3 FB 31 39 37
 314+ 13F7 38 20 4D 69
 314+ 13FB 63 72 6F 73
 314+ 13FF 6F 66 74 0D
 314+ 1403 00
 315+ 1404 20 20 20 20  DOSMSG: defb    "     LM80C DOS ","1.05","  Loaded",CR,0
 315+ 1408 20 4C 4D 38
 315+ 140C 30 43 20 44
 315+ 1410 4F 53 20 31
 315+ 1414 2E 30 35 20
 315+ 1418 20 4C 6F 61
 315+ 141C 64 65 64 0D
 315+ 1420 00
 316+ 1421
 317+ 1421 4D 65 6D 6F  MEMMSG: defb    "Memory top",0
 317+ 1425 72 79 20 74
 317+ 1429 6F 70 00
 318+ 142C
 319+ 142C              ; The following list reports all the functions supported by the interpreter.
 320+ 142C              ; To add a custom function, the user must first insert the reserved word here,
 321+ 142C              ; then into the list of the reserved words below, and finally must increment the
 322+ 142C              ; ZSGN token value and all the following ones after ZSGN by 1 for every added
 323+ 142C              ; function.
 324+ 142C
 325+ 142C              ; FUNCTION ADDRESS TABLE (this is a sort of offset table)
 326+ 142C              ; this list must be coherent with the tokens' functions list. This means that every
 327+ 142C              ; entry here must have the corresponding entry in the tokens list.
 328+ 142C 06 30        FNCTAB: defw    SGN
 329+ 142E 9C 25                defw    TMR         ; added by Leonardo Miliani
 330+ 1430 CA 30                defw    INT
 331+ 1432 1C 30                defw    ABS_        ; '_' necessary to avoid assembler warnings
 332+ 1434 DE 53                defw    USR
 333+ 1436 B2 25                defw    FRE
 334+ 1438 2D 2A                defw    INP
 335+ 143A E0 25                defw    POS
 336+ 143C 90 32                defw    SQR
 337+ 143E 6F 33                defw    RND
 338+ 1440 5A 2E                defw    LOG
 339+ 1442 DE 32                defw    EXP
 340+ 1444 E4 33                defw    COS
 341+ 1446 EA 33                defw    SIN
 342+ 1448 4B 34                defw    TAN
 343+ 144A 60 34                defw    ATN
 344+ 144C 09 2B                defw    PEEK
 345+ 144E CA 34                defw    DEEK
 346+ 1450 10 2B                defw    VPEEK       ; added by Leonardo Miliani
 347+ 1452 DF 2C                defw    VSTAT       ; added by Leonardo Miliani
 348+ 1454 EA 2C                defw    SSTAT       ; added by Leonardo Miliani
 349+ 1456 FE 2C                defw    INKEY       ; added by Leonardo Miliani
 350+ 1458 21 38                defw    POINT       ; added by Leonardo Miliani
 351+ 145A C4 28                defw    INSTR       ; added by Leonardo Miliani
 352+ 145C E8 FF                defw    JPGET       ; added by Leonardo Miliani
 353+ 145E E2 FF                defw    JPEOF       ; added by Leonardo Miliani
 354+ 1460 64 28                defw    LEN
 355+ 1462 7C 26                defw    STR
 356+ 1464 F4 29                defw    VAL
 357+ 1466 73 28                defw    ASC
 358+ 1468 84 28                defw    CHR
 359+ 146A 15 40                defw    HEX         ; added by Grant Searle
 360+ 146C A6 40                defw    BIN         ; added by Grant Searle
 361+ 146E 94 28                defw    LEFT
 362+ 1470 BA 29                defw    RIGHT
 363+ 1472 C4 29                defw    MID
 364+ 1474
 365+ 1474              ; RESERVED WORD LIST
 366+ 1474              ; Here are all the reserved words used by the interpreter
 367+ 1474              ; To add custom functions/commands, the user must insert the keyword
 368+ 1474              ; in this list, following the schematic
 369+ 1474 C5 4E 44     WORDS:  defb    'E'+$80,"ND"            ; from here the list contains the COMMANDS
 370+ 1477 C6 4F 52             defb    'F'+$80,"OR"
 371+ 147A CE 45 58 54          defb    'N'+$80,"EXT"
 372+ 147E C4 41 54 41          defb    'D'+$80,"ATA"
 373+ 1482 C9 4E 50 55          defb    'I'+$80,"NPUT"
 373+ 1486 54
 374+ 1487 C4 49 4D             defb    'D'+$80,"IM"
 375+ 148A D2 45 41 44          defb    'R'+$80,"EAD"
 376+ 148E CC 45 54             defb    'L'+$80,"ET"
 377+ 1491 C7 4F 54 4F          defb    'G'+$80,"OTO"
 378+ 1495 D2 55 4E             defb    'R'+$80,"UN"
 379+ 1498 C9 46                defb    'I'+$80,"F"
 380+ 149A D2 45 53 54          defb    'R'+$80,"ESTORE"
 380+ 149E 4F 52 45
 381+ 14A1 C7 4F 53 55          defb    'G'+$80,"OSUB"
 381+ 14A5 42
 382+ 14A6 D2 45 54 55          defb    'R'+$80,"ETURN"
 382+ 14AA 52 4E
 383+ 14AC D2 45 4D             defb    'R'+$80,"EM"            ; original REM
 384+ 14AF D3 54 4F 50          defb    'S'+$80,"TOP"
 385+ 14B3 CF 55 54             defb    'O'+$80,"UT"
 386+ 14B6 CF 4E                defb    'O'+$80,"N"
 387+ 14B8 C6 49 4C 45          defb    'F'+$80,"ILES"          ; added by Leonardo Miliani
 387+ 14BC 53
 388+ 14BD C5 52 41 53          defb    'E'+$80,"RASE"          ; added by Leonardo Miliani
 388+ 14C1 45
 389+ 14C2 C4 49 53 4B          defb    'D'+$80,"ISK"           ; added by Leonardo Miliani
 390+ 14C6 CF 50 45 4E          defb    'O'+$80,"PEN"           ; added by Leonardo Miliani
 391+ 14CA C3 4C 4F 53          defb    'C'+$80,"LOSE"          ; added by Leonardo Miliani
 391+ 14CE 45
 392+ 14CF D0 55 54             defb    'P'+$80,"UT"            ; added by Leonardo Miliani
 393+ 14D2 D7 41 49 54          defb    'W'+$80,"AIT"
 394+ 14D6 C4 45 46             defb    'D'+$80,"EF"
 395+ 14D9 D0 4F 4B 45          defb    'P'+$80,"OKE"
 396+ 14DD C4 4F 4B 45          defb    'D'+$80,"OKE"
 397+ 14E1 D6 50 4F 4B          defb    'V'+$80,"POKE"          ; added by Leonardo Miliani
 397+ 14E5 45
 398+ 14E6 D3 52 45 47          defb    'S'+$80,"REG"           ; added by Leonardo Miliani
 399+ 14EA D6 52 45 47          defb    'V'+$80,"REG"           ; added by Leonardo Miliani
 400+ 14EE D3 43 52 45          defb    'S'+$80,"CREEN"         ; changed by Leonardo Miliani
 400+ 14F2 45 4E
 401+ 14F4 CC 4F 43 41          defb    'L'+$80,"OCATE"         ; added by Leonardo Miliani
 401+ 14F8 54 45
 402+ 14FA D3 4F 55 4E          defb    'S'+$80,"OUND"          ; added by Leonardo Miliani
 402+ 14FE 44
 403+ 14FF D6 4F 4C 55          defb    'V'+$80,"OLUME"         ; added by Leonardo Miliani
 403+ 1503 4D 45
 404+ 1505 D0 41 55 53          defb    'P'+$80,"AUSE"          ; added by Leonardo Miliani
 404+ 1509 45
 405+ 150A C3 4F 4C 4F          defb    'C'+$80,"OLOR"          ; added by Leonardo Miliani
 405+ 150E 52
 406+ 150F D0 4C 4F 54          defb    'P'+$80,"LOT"           ; added by Leonardo Miliani
 407+ 1513 C4 52 41 57          defb    'D'+$80,"RAW"           ; added by Leonardo Miliani
 408+ 1517 C3 49 52 43          defb    'C'+$80,"IRCLE"         ; added by Leonardo Miliani
 408+ 151B 4C 45
 409+ 151D D0 41 49 4E          defb    'P'+$80,"AINT"          ; added by Leonardo Miliani
 409+ 1521 54
 410+ 1522 D3 45 52 49          defb    'S'+$80,"ERIAL"         ; added by Leonardo Miliani
 410+ 1526 41 4C
 411+ 1528 C8 45 4C 50          defb    'H'+$80,"ELP"           ; changed by Leonardo Miliani - was LINES
 412+ 152C C3 4C 53             defb    'C'+$80,"LS"            ; restored command
 413+ 152F CB 45 59             defb    'K'+$80,"EY"            ; added by Leonardo Miliani
 414+ 1532 CE 4D 49             defb    'N'+$80,"MI"            ; added by Leonardo Miliani
 415+ 1535 C7 50 52 49          defb    'G'+$80,"PRINT"         ; added by Leonardo Miliani
 415+ 1539 4E 54
 416+ 153B D7 49 44 54          defb    'W'+$80,"IDTH"
 416+ 153F 48
 417+ 1540 D3 59 53             defb    'S'+$80,"YS"            ; added by Leonardo Miliani
 418+ 1543 D2 45 53 45          defb    'R'+$80,"ESET"          ; changed by Leonardo Miliani
 418+ 1547 54
 419+ 1548 C5 4C 53 45          defb    'E'+$80,"LSE"           ; added by Leonardo Miliani
 420+ 154C D0 52 49 4E          defb    'P'+$80,"RINT"
 420+ 1550 54
 421+ 1551 C3 4F 4E 54          defb    'C'+$80,"ONT"
 422+ 1555 CC 49 53 54          defb    'L'+$80,"IST"
 423+ 1559 C3 4C 45 41          defb    'C'+$80,"LEAR"
 423+ 155D 52
 424+ 155E CC 4F 41 44          defb    'L'+$80,"OAD"
 425+ 1562 D3 41 56 45          defb    'S'+$80,"AVE"
 426+ 1566 CE 45 57             defb    'N'+$80,"EW"
 427+ 1569 D4 41 42 28          defb    'T'+$80,"AB("
 428+ 156D D4 4F                defb    'T'+$80,"O"
 429+ 156F C6 4E                defb    'F'+$80,"N"
 430+ 1571 D3 50 43 28          defb    'S'+$80,"PC("
 431+ 1575 D4 48 45 4E          defb    'T'+$80,"HEN"
 432+ 1579 CE 4F 54             defb    'N'+$80,"OT"
 433+ 157C D3 54 45 50          defb    'S'+$80,"TEP"
 434+ 1580                      ; from here: operators
 435+ 1580 AB                   defb    '+'+$80
 436+ 1581 AD                   defb    '-'+$80
 437+ 1582 AA                   defb    '*'+$80
 438+ 1583 AF                   defb    '/'+$80
 439+ 1584 A5                   defb    '%'+$80
 440+ 1585 A3                   defb    '#'+$80
 441+ 1586 DE                   defb    '^'+$80
 442+ 1587 C1 4E 44             defb    'A'+$80,"ND"
 443+ 158A D8 4F 52             defb    'X'+$80,"OR"
 444+ 158D CF 52                defb    'O'+$80,"R"
 445+ 158F BE                   defb    '>'+$80
 446+ 1590 BD                   defb    '='+$80
 447+ 1591 BC                   defb    '<'+$80
 448+ 1592
 449+ 1592                      ; from here there are the tokens' FUNCTIONS list
 450+ 1592                      ; this list must be coherent with the functions list above
 451+ 1592 D3 47 4E             defb    'S'+$80,"GN"
 452+ 1595 D4 4D 52             defb    'T'+$80,"MR"            ; added by Leonardo Miliani
 453+ 1598 C9 4E 54             defb    'I'+$80,"NT"
 454+ 159B C1 42 53             defb    'A'+$80,"BS"
 455+ 159E D5 53 52             defb    'U'+$80,"SR"
 456+ 15A1 C6 52 45             defb    'F'+$80,"RE"
 457+ 15A4 C9 4E 50             defb    'I'+$80,"NP"
 458+ 15A7 D0 4F 53             defb    'P'+$80,"OS"
 459+ 15AA D3 51 52             defb    'S'+$80,"QR"
 460+ 15AD D2 4E 44             defb    'R'+$80,"ND"
 461+ 15B0 CC 4F 47             defb    'L'+$80,"OG"
 462+ 15B3 C5 58 50             defb    'E'+$80,"XP"
 463+ 15B6 C3 4F 53             defb    'C'+$80,"OS"
 464+ 15B9 D3 49 4E             defb    'S'+$80,"IN"
 465+ 15BC D4 41 4E             defb    'T'+$80,"AN"
 466+ 15BF C1 54 4E             defb    'A'+$80,"TN"
 467+ 15C2 D0 45 45 4B          defb    'P'+$80,"EEK"
 468+ 15C6 C4 45 45 4B          defb    'D'+$80,"EEK"
 469+ 15CA D6 50 45 45          defb    'V'+$80,"PEEK"          ; added by Leonardo Miliani
 469+ 15CE 4B
 470+ 15CF D6 53 54 41          defb    'V'+$80,"STAT"          ; added by Leonardo Miliani
 470+ 15D3 54
 471+ 15D4 D3 53 54 41          defb    'S'+$80,"STAT"          ; added by Leonardo Miliani
 471+ 15D8 54
 472+ 15D9 C9 4E 4B 45          defb    'I'+$80,"NKEY"          ; added by Leonardo Miliani
 472+ 15DD 59
 473+ 15DE D0 4F 49 4E          defb    'P'+$80,"OINT"          ; added by Leonardo Miliani
 473+ 15E2 54
 474+ 15E3 C9 4E 53 54          defb    'I'+$80,"NSTR"          ; added by Leonardo Miliani
 474+ 15E7 52
 475+ 15E8 C7 45 54             defb    'G'+$80,"ET"            ; added by Leonardo Miliani
 476+ 15EB C5 4F 46             defb    'E'+$80,"OF"            ; added by Leonardo Miliani
 477+ 15EE CC 45 4E             defb    'L'+$80,"EN"
 478+ 15F1 D3 54 52 24          defb    'S'+$80,"TR$"
 479+ 15F5 D6 41 4C             defb    'V'+$80,"AL"
 480+ 15F8 C1 53 43             defb    'A'+$80,"SC"
 481+ 15FB C3 48 52 24          defb    'C'+$80,"HR$"
 482+ 15FF C8 45 58 24          defb    'H'+$80,"EX$"           ; added by Grant Searle
 483+ 1603 C2 49 4E 24          defb    'B'+$80,"IN$"           ; added by Grant Searle
 484+ 1607 CC 45 46 54          defb    'L'+$80,"EFT$"
 484+ 160B 24
 485+ 160C D2 49 47 48          defb    'R'+$80,"IGHT$"
 485+ 1610 54 24
 486+ 1612 CD 49 44 24          defb    'M'+$80,"ID$"
 487+ 1616 80                   defb    $80                     ; End-of-list marker
 488+ 1617
 489+ 1617              ; COMMAND KEYWORD ADDRESS TABLE
 490+ 1617              ; this list must be coherent with the commands' tokens list above
 491+ 1617 A3 1D        WORDTB: defw    PEND
 492+ 1619 A0 1C                defw    FOR
 493+ 161B 9F 21                defw    NEXT
 494+ 161D 02 1F                defw    DATA
 495+ 161F 9C 20                defw    INPUT
 496+ 1621 F4 23                defw    DIM
 497+ 1623 D6 20                defw    READ
 498+ 1625 19 1F                defw    LET
 499+ 1627 BF 1E                defw    GOTO
 500+ 1629 9A 1E                defw    RUN
 501+ 162B 91 1F                defw    IF
 502+ 162D 69 1D                defw    RESTOR
 503+ 162F AE 1E                defw    GOSUB
 504+ 1631 DD 1E                defw    RETURN
 505+ 1633 04 1F                defw    REM         ; original REM
 506+ 1635 A1 1D                defw    STOP
 507+ 1637 39 2A                defw    POUT
 508+ 1639 73 1F                defw    ON
 509+ 163B FD FF                defw    JPFILS      ; changed by Leonardo Miliani - was NULL
 510+ 163D F4 FF                defw    JPERAS      ; added by Leonardo Miliani
 511+ 163F F1 FF                defw    JPDISK      ; added by Leonardo Miliani
 512+ 1641 EE FF                defw    JPOPEN      ; added by Leonardo Miliani
 513+ 1643 EB FF                defw    JPCLOSE     ; added by Leonardo Miliani
 514+ 1645 E5 FF                defw    JPPUT       ; added by Leonardo Miliani
 515+ 1647 3F 2A                defw    WAIT
 516+ 1649 E8 25                defw    DEF
 517+ 164B 33 2B                defw    POKE
 518+ 164D D5 34                defw    DOKE
 519+ 164F 38 2B                defw    VPOKE       ; added by Leonardo Miliani
 520+ 1651 75 2B                defw    SREG        ; added by Leonardo Miliani
 521+ 1653 C3 2C                defw    VREG        ; added by Leonardo Miliani
 522+ 1655 0B 35                defw    SCREEN      ; new behaviour: now it sets up a graphics mode (Leonardo Miliani)
 523+ 1657 43 2B                defw    LOCATE      ; added by Leonardo Miliani
 524+ 1659 CF 2B                defw    SOUND       ; added by Leonardo Miliani
 525+ 165B 96 2B                defw    VOLUME      ; added by Leonardo Miliani
 526+ 165D EC 34                defw    PAUSE       ; added by Leonardo Miliani
 527+ 165F 86 35                defw    COLOR       ; added by Leonardo Miliani
 528+ 1661 74 38                defw    PLOT        ; added by Leonardo Miliani
 529+ 1663 07 39                defw    DRAW        ; added by Leonardo Miliani
 530+ 1665 40 3A                defw    CIRCLE      ; added by Leonardo Miliani
 531+ 1667 31 37                defw    PAINT       ; added by Leonardo Miliani
 532+ 1669 4B 3C                defw    SERIAL      ; added by Leonardo Miliani
 533+ 166B 8A 3E                defw    HELP        ; changed by Leonardo Miliani - was LINES
 534+ 166D AE 34                defw    CLS
 535+ 166F A8 3E                defw    KEY         ; added by Leonardo Miliani
 536+ 1671 81 2A                defw    NMI         ; added by Leonardo Miliani
 537+ 1673 41 36                defw    GPRINT      ; added by Leonardo Miliani
 538+ 1675 C2 34                defw    WIDTH
 539+ 1677 DB 2A                defw    SYS         ; added by Leonardo Miliani
 540+ 1679 0B 41                defw    RESET       ; new behaviour: now it resets the system
 541+ 167B 06 1F                defw    REM+2       ; ELSE: added by Leonardo Miliani
 542+ 167D C3 1F                defw    PRINT
 543+ 167F D5 1D                defw    CONT
 544+ 1681 77 1B                defw    LIST
 545+ 1683 4E 1E                defw    CLEAR
 546+ 1685 F7 FF                defw    JPLOAD      ; re-implemented by Leonardo Miliani (was CLOAD)
 547+ 1687 FA FF                defw    JPSAVE      ; re-implemented by Leonardo Miliani (was CSAVE)
 548+ 1689 4C 19                defw    NEW
 549+ 168B
 550+ 168B              ; RESERVED WORD TOKEN VALUES
 551+ 168B              ; if you add a function or command you must increment by 1
 552+ 168B              ; the values below. Pay attention that you must increment only the
 553+ 168B              ; values AFTER the position where you entered the function/command word
 554+ 168B              ; in the "Reserver word list" above. I.E.: VPOKE has been added between
 555+ 168B              ; DOKE and SCREEN, and since REM is the reserved work listed below
 556+ 168B              ; that is before the point where VPOKE has been entered, every entry
 557+ 168B              ; after REM has been incremented.
 558+ 168B              ; Another example: when TMR has been added, since it's a function, every
 559+ 168B              ; entry after & included ZSGN must be checked (read below)
 560+ 168B
 561+ 168B              ZEND    equ     $80             ; END        <-- from here, there are the commands
 562+ 168B              ZFOR    equ     $81             ; FOR
 563+ 168B              ZDATA   equ     $83             ; DATA
 564+ 168B              ZGOTO   equ     $88             ; GOTO
 565+ 168B              ZGOSUB  equ     $8C             ; GOSUB
 566+ 168B              ZREM    equ     $8E             ; REM
 567+ 168B              ZELSE   equ     $B2             ; ELSE
 568+ 168B              ZPRINT  equ     $B3             ; PRINT
 569+ 168B              ZNEW    equ     $B9             ; NEW
 570+ 168B
 571+ 168B              ZTAB    equ     $BA             ; TAB
 572+ 168B              ZTO     equ     $BB             ; TO
 573+ 168B              ZFN     equ     $BC             ; FN
 574+ 168B              ZSPC    equ     $BD             ; SPC
 575+ 168B              ZTHEN   equ     $BE             ; THEN
 576+ 168B              ZNOT    equ     $BF             ; NOT
 577+ 168B              ZSTEP   equ     $C0             ; STEP
 578+ 168B
 579+ 168B              ZPLUS   equ     $C1             ; +         <-- from here, there are the math operators
 580+ 168B              ZMINUS  equ     $C2             ; -
 581+ 168B              ZTIMES  equ     $C3             ; *
 582+ 168B              ZDIV    equ     $C4             ; /
 583+ 168B              ZMOD    equ     $C5             ; %
 584+ 168B              ZDINT   equ     $C6             ; #
 585+ 168B              ZOR     equ     $CA             ; OR
 586+ 168B              ZGTR    equ     $CB             ; >
 587+ 168B              ZEQUAL  equ     $CC             ; M
 588+ 168B              ZLTH    equ     $CD             ; <
 589+ 168B
 590+ 168B              ZSGN    equ     $CE             ; SGN       <-- from here, there are the functions
 591+ 168B              ZPOINT  equ     $E4             ; ZPOINT    <-- if the user enters a custom function, between
 592+ 168B                                              ;               SGN and POINT, he/she must increment this pointer by 1
 593+ 168B              ZINSTR  equ     $E5             ; ZINSTR    <-- same here
 594+ 168B              ZLEFT   equ     $EF             ; LEFT$     <-- if the user enters a custom function anywhere,
 595+ 168B                                              ;               he/she must increment this pointer by 1
 596+ 168B
 597+ 168B              ; ARITHMETIC PRECEDENCE TABLE
 598+ 168B              ; in the formulas below, <last> is a number stored into the stack that must be retrieved
 599+ 168B              ; with POP BC, POP DE; FPREG is a f.p. number store into the RAM register FPREG
 600+ 168B 79           PRITAB: defb    $79             ; Precedence value
 601+ 168C 78 31                defw    PADD            ; FPREG = <last> + FPREG
 602+ 168E
 603+ 168E 79                   defb    $79             ; Precedence value
 604+ 168F 5B 2D                defw    PSUB            ; FPREG = <last> - FPREG
 605+ 1691
 606+ 1691 7C                   defb    $7C             ; Precedence value
 607+ 1692 99 2E                defw    MULT            ; PPREG = <last> * FPREG
 608+ 1694
 609+ 1694 7C                   defb    $7C             ; Precedence value
 610+ 1695 4B 2F                defw    DIV             ; FPREG = <last> / FPREG
 611+ 1697
 612+ 1697 7C                   defb    $7C             ; Precedence value
 613+ 1698 F6 2E                defw    MOD             ; FPREG = INT(<last>)-(INT(FPREG)*INT(<last>/FPREG))
 614+ 169A
 615+ 169A 7C                   defb    $7C             ; precedence value
 616+ 169B EE 2E                defw    DINT            ; FPREG = INT(<last> / FPREG )
 617+ 169D
 618+ 169D 7F                   defb    $7F             ; Precedence value
 619+ 169E 99 32                defw    POWER           ; FPREG = <last> ^ FPREG
 620+ 16A0
 621+ 16A0 50                   defb    $50             ; Precedence value
 622+ 16A1 3D 23                defw    PAND            ; FPREG = <last> AND FPREG
 623+ 16A3
 624+ 16A3 4A                   defb    $4A             ; Precedence value
 625+ 16A4 45 23                defw    PXOR            ; FPREG = <last> XOR FPREG
 626+ 16A6
 627+ 16A6 46                   defb    $46             ; Precedence value
 628+ 16A7 40 23                defw    POR             ; FPREG = <last> OR FPREG
 629+ 16A9
 630+ 16A9
 631+ 16A9              ; INITIALISATION TABLE -------------------------------------------------------
 632+ 16A9              ; these values are copied into RAM at startup
 633+ 16A9 C3 9D 13     INITAB: jp      WARMST          ; Warm start jump
 634+ 16AC ED 45 00             defb    $ED,$45,$00     ; RETN + NOP for default NMI service routine
 635+ 16AF C3 24 1E             jp      FCERR           ; "USR (X)" jump (Set to Error)
 636+ 16B2 D3 00                out     (0),A           ; "out p,n" skeleton
 637+ 16B4 C9                   ret
 638+ 16B5 D6 00                sub     $00             ; Division support routine
 639+ 16B7 6F                   ld      L,A
 640+ 16B8 7C                   ld      A,H
 641+ 16B9 DE 00                sbc     A,$00
 642+ 16BB 67                   ld      H,A
 643+ 16BC 78                   ld      A,B
 644+ 16BD DE 00                sbc     A,$00
 645+ 16BF 47                   ld      B,A
 646+ 16C0 3E 00                ld      A,$00
 647+ 16C2 C9                   ret
 648+ 16C3 00 00 00             defb    $00,$00,$00     ; Random number seed table used by RND
 649+ 16C6 35 4A CA 99          defb    $35,$4A,$CA,$99 ;-2.65145E+07
 650+ 16CA 39 1C 76 98          defb    $39,$1C,$76,$98 ; 1.61291E+07
 651+ 16CE 22 95 B3 98          defb    $22,$95,$B3,$98 ;-1.17691E+07
 652+ 16D2 0A DD 47 98          defb    $0A,$DD,$47,$98 ; 1.30983E+07
 653+ 16D6 53 D1 99 99          defb    $53,$D1,$99,$99 ;-2-01612E+07
 654+ 16DA 0A 1A 9F 98          defb    $0A,$1A,$9F,$98 ;-1.04269E+07
 655+ 16DE 65 BC CD 98          defb    $65,$BC,$CD,$98 ;-1.34831E+07
 656+ 16E2 D6 77 3E 98          defb    $D6,$77,$3E,$98 ; 1.24825E+07
 657+ 16E6 52 C7 4F 80          defb    $52,$C7,$4F,$80 ; Last random number
 658+ 16EA DB 00                in      A,($00)         ; INP (x) skeleton
 659+ 16EC C9                   ret
 660+ 16ED FF                   defb    $FF             ; Terminal width (255 = no auto CRLF)
 661+ 16EE 14                   defb    $14             ; Width for commas (at reset, 3 columns, for G1 mode)
 662+ 16EF 00                   defb    $00             ; No nulls after input bytes
 663+ 16F0 00                   defb    $00             ; Output enabled (^O off)
 664+ 16F1 00 00                defw    $00             ; Array load/save check sum
 665+ 16F3 00                   defb    $00             ; Break not by NMI
 666+ 16F4 00                   defb    $00             ; Break flag
 667+ 16F5 C3 90 1A             jp      TTYLIN          ; Input reflection (set to TTY)
 668+ 16F8 49 56                defw    STLOOK          ; Temp string space
 669+ 16FA FE FF                defw    -2              ; Current line number (cold)
 670+ 16FC FF FF                defw    -1              ; Current line with errors (no errors)
 671+ 16FE 40           AUTORP: defb    $40             ; delay for key auto-repeat start
 672+ 16FF 08                   defb    $08             ; auto-repeat delay
 673+ 1700 4C 49 53 54  DEFFNKS:defm    "LIST",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 1
 673+ 1704 0D 00 00 00
 673+ 1708 00 00 00 00
 673+ 170C 00 00 00 00
 674+ 1710 52 55 4E 0D          defm    "RUN",13,0,0,0,0,0,0,0,0,0,0,0,0    ; KEY 2
 674+ 1714 00 00 00 00
 674+ 1718 00 00 00 00
 674+ 171C 00 00 00 00
 675+ 1720 53 43 52 45          defm    "SCREEN1",13,0,0,0,0,0,0,0,0        ; KEY 3
 675+ 1724 45 4E 31 0D
 675+ 1728 00 00 00 00
 675+ 172C 00 00 00 00
 676+ 1730 43 4F 4C 4F          defm    "COLOR1,15,5",13,0,0,0,0            ; KEY 4
 676+ 1734 52 31 2C 31
 676+ 1738 35 2C 35 0D
 676+ 173C 00 00 00 00
 677+ 1740 53 45 52 49          defm    "SERIAL1,38400",13,0,0              ; KEY 5
 677+ 1744 41 4C 31 2C
 677+ 1748 33 38 34 30
 677+ 174C 30 0D 00 00
 678+ 1750 53 43 52 45          defm    "SCREEN2",13,0,0,0,0,0,0,0,0        ; KEY 6
 678+ 1754 45 4E 32 0D
 678+ 1758 00 00 00 00
 678+ 175C 00 00 00 00
 679+ 1760 43 4F 4E 54          defm    "CONT",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 7
 679+ 1764 0D 00 00 00
 679+ 1768 00 00 00 00
 679+ 176C 00 00 00 00
 680+ 1770 48 45 4C 50          defm    "HELP",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 8 (HELP KEY)
 680+ 1774 0D 00 00 00
 680+ 1778 00 00 00 00
 680+ 177C 00 00 00 00
 681+ 1780 E6 55                defw    PROGST+1        ; Start of program text
 682+ 1782              INITBE:
 683+ 1782
 684+ 1782              ; END OF INITIALISATION TABLE ---------------------------------------------------
 685+ 1782
 686+ 1782 20 45 72 72  ERRMSG: defb    " Error",0
 686+ 1786 6F 72 00
 687+ 1789 20 69 6E 20  INMSG:  defb    " in ",0
 687+ 178D 00
 688+ 178E              ZERBYT  equ     $-1             ; A zero byte
 689+ 178E 4F 6B 0D 00  OKMSG:  defb    "Ok",CR,0,0
 689+ 1792 00
 690+ 1793 42 72 65 61  BRKMSG: defb    "Break",0
 690+ 1797 6B 00
 691+ 1799
 692+ 1799 21 04 00     BAKSTK: ld      HL,$04          ; Look for "FOR" block with
 693+ 179C 39                   add     HL,SP           ; same index as specified
 694+ 179D 7E           LOKFOR: ld      A,(HL)          ; Get block ID
 695+ 179E 23                   inc     HL              ; Point to index address
 696+ 179F FE 81                cp      ZFOR            ; Is it a "FOR" token
 697+ 17A1 C0                   ret     NZ              ; No - exit
 698+ 17A2 4E                   ld      C,(HL)          ; BC = Address of "FOR" index
 699+ 17A3 23                   inc     HL
 700+ 17A4 46                   ld      B,(HL)
 701+ 17A5 23                   inc     HL              ; Point to sign of STEP
 702+ 17A6 E5                   push    HL              ; Save pointer to sign
 703+ 17A7 69                   ld      L,C             ; HL = address of "FOR" index
 704+ 17A8 60                   ld      H,B
 705+ 17A9 7A                   ld      A,D             ; See if an index was specified
 706+ 17AA B3                   or      E               ; DE = 0 if no index specified
 707+ 17AB EB                   ex      DE,HL           ; Specified index into HL
 708+ 17AC CA B3 17             jp      Z,INDFND        ; Skip if no index given
 709+ 17AF EB                   ex      DE,HL           ; Index back into DE
 710+ 17B0 CD 0A 1B             call    CPDEHL          ; Compare index with one given
 711+ 17B3 01 0D 00     INDFND: ld      BC,16-3         ; Offset to next block
 712+ 17B6 E1                   pop     HL              ; Restore pointer to sign
 713+ 17B7 C8                   ret     Z               ; Return if block found
 714+ 17B8 09                   add     HL,BC           ; Point to next block
 715+ 17B9 C3 9D 17             jp      LOKFOR          ; Keep on looking
 716+ 17BC
 717+ 17BC CD D6 17     MOVUP:  call    ENFMEM          ; See if enough memory
 718+ 17BF C5           MOVSTR: push    BC              ; Save end of source
 719+ 17C0 E3                   ex      (SP),HL         ; Swap source and dest" end
 720+ 17C1 C1                   pop     BC              ; Get end of destination
 721+ 17C2 CD 0A 1B     MOVLP:  call    CPDEHL          ; See if list moved
 722+ 17C5 7E                   ld      A,(HL)          ; Get byte
 723+ 17C6 02                   ld      (BC),A          ; Move it
 724+ 17C7 C8                   ret     Z               ; Exit if all done
 725+ 17C8 0B                   dec     BC              ; Next byte to move to
 726+ 17C9 2B                   dec     HL              ; Next byte to move
 727+ 17CA C3 C2 17             jp      MOVLP           ; Loop until all bytes moved
 728+ 17CD
 729+ 17CD E5           CHKSTK: push    HL              ; Save code string address
 730+ 17CE 2A C6 55             ld      HL,(ARREND)     ; Lowest free memory
 731+ 17D1 06 00                ld      B,$00           ; BC = Number of levels to test
 732+ 17D3 09                   add     HL,BC           ; 2 Bytes for each level
 733+ 17D4 09                   add     HL,BC
 734+ 17D5 3E                   defb    $3E             ; Skip "push HL"
 735+ 17D6 E5           ENFMEM: push    HL              ; Save code string address
 736+ 17D7 3E D0                ld      A,$D0           ; LOW -48 ; 48 Bytes minimum RAM
 737+ 17D9 95                   sub     L
 738+ 17DA 6F                   ld      L,A
 739+ 17DB 3E FF                ld      A,$FF           ; HIGH (-48) ; 48 Bytes minimum RAM
 740+ 17DD 9C                   sbc     A,H
 741+ 17DE DA E5 17             jp      C,OMERR         ; Not enough - ?OM Error
 742+ 17E1 67                   ld      H,A
 743+ 17E2 39                   add     HL,SP           ; Test if stack is overflowed
 744+ 17E3 E1                   pop     HL              ; Restore code string address
 745+ 17E4 D8                   ret     C               ; Return if enough memory
 746+ 17E5 1E 0C        OMERR:  ld      E,OM            ; ?OM Error
 747+ 17E7 C3 2A 18             jp      ERROR
 748+ 17EA
 749+ 17EA
 750+ 17EA              ; if in graphics mode, return to text (called by "NOLIN" and "ERROR")
 751+ 17EA F5           EXITGM: push    AF              ; store AF
 752+ 17EB 3A 6E 55             ld      A,(SCR_MODE)    ; check screen mode
 753+ 17EE FE 02                cp      $02             ; G2?
 754+ 17F0 CA F7 17             jp      Z,LDG1          ; yes, back to G1
 755+ 17F3 FE 03                cp      $03             ; G3?
 756+ 17F5 20 11                jr      NZ,LDG1ND       ; no, so return
 757+ 17F7 E5           LDG1:   push    HL              ; store HL
 758+ 17F8 D5                   push    DE              ; store DE
 759+ 17F9 11 01 00             ld      DE,$0001        ; sprites set to defaults, G1 mode
 760+ 17FC F3                   di                      ; disable INTs
 761+ 17FD CD D1 03             call    initVDP         ; initialize VDP with mode pointed by E
 762+ 1800 FB                   ei                      ; re-enable INTs
 763+ 1801 3E 01                ld      A,$01           ; activate the...
 764+ 1803 32 78 55             ld      (PRNTVIDEO),A   ; ...video buffer...
 765+ 1806 D1                   pop     DE              ; retrieve DE
 766+ 1807 E1                   pop     HL              ; retrieve HL
 767+ 1808 F1           LDG1ND: pop     AF              ; retrieve AF
 768+ 1809 C9                   ret                     ; return to caller
 769+ 180A
 770+ 180A
 771+ 180A 2A 4F 55     DATSNR: ld      HL,(DATLIN)     ; Get line of current DATA item
 772+ 180D 22 29 54             ld      (LINEAT),HL     ; Save as current line
 773+ 1810 1E 02        SNERR:  ld      E,SN            ; ?SN Error
 774+ 1812 01                   defb    $01             ; Skip "ld E,DZ"
 775+ 1813 1E 14        DZERR:  ld      E,DZ            ; ?/0 Error
 776+ 1815 01                   defb    $01             ; Skip "ld E,NF"
 777+ 1816 1E 00        NFERR:  ld      E,NF            ; ?NF Error
 778+ 1818 01                   defb    $01             ; Skip "ld E,DD"
 779+ 1819 1E 12        DDERR:  ld      E,DD            ; ?DD Error
 780+ 181B 01                   defb    $01             ; Skip "ld E,UF"
 781+ 181C 1E 22        UFERR:  ld      E,UF            ; ?UF Error
 782+ 181E 01                   defb    $01             ; Skip "ld E,OV
 783+ 181F 1E 0A        OVERR:  ld      E,OV            ; ?OV Error
 784+ 1821 01                   defb    $01             ; Skip "ld E,TM"
 785+ 1822 1E 18        TMERR:  ld      E,TM            ; ?TM Error
 786+ 1824 01                   defb    $01             ; Skip next statement
 787+ 1825 1E 34        IMERR:  ld      E,IM            ; ?Illegal indirect mode error
 788+ 1827 01                   defb    $01             ; Skip next statement
 789+ 1828 1E 36        NRERR:  ld      E,NR            ; ?Device not ready error
 790+ 182A
 791+ 182A CD 72 19     ERROR:  call    CLREG           ; Clear registers and stack
 792+ 182D CD EA 17             call    EXITGM          ; exit from graphic modes
 793+ 1830 32 1F 54             ld      (CTLOFG),A      ; Enable output (A is 0)
 794+ 1833 CD 26 09             call    CURSOR_ON       ; enable cursor
 795+ 1836 CD 14 20             call    STTLIN          ; Start new line
 796+ 1839 21 0C 10             ld      HL,ERRTBL       ; Point to error codes
 797+ 183C 57                   ld      D,A             ; D = 0 (A is 0)
 798+ 183D 3E 3F                ld      A,'?'
 799+ 183F CD 1B 1B             call    OUTC            ; Output '?'
 800+ 1842 19                   add     HL,DE           ; Offset to correct error code
 801+ 1843 5E                   ld      E,(HL)          ; load pointer to error message
 802+ 1844 23                   inc     HL              ; by loading LSB,
 803+ 1845 56                   ld      D,(HL)          ; then MSB
 804+ 1846 62 6B                ld      HL,DE           ; load pointer to HL
 805+ 1848 CD F2 26             call    PRS             ; Output error message
 806+ 184B 21 82 17             ld      HL,ERRMSG       ; "Error" message
 807+ 184E CD F2 26     ERRIN:  call    PRS             ; Output message
 808+ 1851 2A 29 54             ld      HL,(LINEAT)     ; Get line of error
 809+ 1854 11 FE FF             ld      DE,-2           ; Cold start error if -2
 810+ 1857 CD 0A 1B             call    CPDEHL          ; See if cold start error
 811+ 185A CA CE 12             jp      Z,CSTART        ; Cold start error - Restart
 812+ 185D 7C                   ld      A,H             ; Was it a direct error?
 813+ 185E A5                   and     L               ; Line = -1 if direct error
 814+ 185F 3C                   inc     A
 815+ 1860 CA 6B 18             jp      Z,PTLN          ; Yes, jump over
 816+ 1863 E5                   push    HL              ; indirect mode - store HL
 817+ 1864 2A 29 54             ld      HL,(LINEAT)     ; copy current line number
 818+ 1867 22 2B 54             ld      (HLPLN),HL      ; save in HELP line register
 819+ 186A E1                   pop     HL              ; retrieve HL
 820+ 186B C4 89 31     PTLN:   call    NZ,LINEIN       ; No - output line of error
 821+ 186E
 822+ 186E 3E                   defb    $3E             ; Skip "pop BC"
 823+ 186F C1           POPNOK: pop     BC              ; Drop address in input buffer
 824+ 1870
 825+ 1870              ; run into direct mode: print OK and get command
 826+ 1870 AF           PRNTOK: xor     A               ; Output "Ok" and get command
 827+ 1871 32 1F 54             ld      (CTLOFG),A      ; Enable output
 828+ 1874 CD 14 20             call    STTLIN          ; Start new line
 829+ 1877 21 8E 17             ld      HL,OKMSG        ; "Ok" message
 830+ 187A CD F2 26             call    PRS             ; Output "Ok"
 831+ 187D CD 26 09     GETCMD: call    CURSOR_ON       ; enable cursor
 832+ 1880 3A BE 55             ld      A,(SERIALS_EN)  ; load serial state
 833+ 1883 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
 834+ 1885 CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
 835+ 1888 21 FF FF             ld      HL,-1           ; Flag direct mode
 836+ 188B 22 29 54             ld      (LINEAT),HL     ; Save as current line
 837+ 188E CD 90 1A             call    GETLIN          ; Get an input line
 838+ 1891 DA 7D 18             jp      C,GETCMD        ; Get line again if break
 839+ 1894 CD 59 1D             call    GETCHR          ; Get first character
 840+ 1897 17                   rla                     ; 8th bit is copied into carry and original carry is copied into bit 0)
 841+ 1898 DA 10 18             jp      C,SNERR         ; if char >=128 (8th bit set) then raise an error
 842+ 189B 1F                   rra                     ; recover original char and Carry
 843+ 189C 3C                   inc     A               ; Test if end of line
 844+ 189D 3D                   dec     A               ; Without affecting Carry
 845+ 189E CA 7D 18             jp      Z,GETCMD        ; Nothing entered - Get another
 846+ 18A1 F5                   push    AF              ; Save Carry status
 847+ 18A2 3A BE 55             ld      A,(SERIALS_EN)  ; load serial state
 848+ 18A5 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
 849+ 18A7 CC 8F 01             call    Z,A_RTS_OFF      ; yes, set RTS on
 850+ 18AA CD 3B 09             call    CURSOR_OFF      ; cursor disabled
 851+ 18AD CD 29 1E             call    ATOH            ; Get line number into DE
 852+ 18B0 D5                   push    DE              ; Save line number
 853+ 18B1 CD A7 19             call    CRUNCH          ; Tokenise rest of line
 854+ 18B4 47                   ld      B,A             ; Length of tokenised line
 855+ 18B5 D1                   pop     DE              ; Restore line number
 856+ 18B6 F1                   pop     AF              ; Restore Carry
 857+ 18B7 D2 39 1D             jp      NC,EXCUTE       ; No line number - Direct mode
 858+ 18BA D5                   push    DE              ; Save line number
 859+ 18BB C5                   push    BC              ; Save length of tokenised line
 860+ 18BC AF                   xor     A
 861+ 18BD 32 52 55             ld      (LSTBIN),A      ; Clear last byte input
 862+ 18C0 CD 59 1D             call    GETCHR          ; Get next character
 863+ 18C3 B7                   or      A               ; Set flags
 864+ 18C4 F5                   push    AF              ; And save them
 865+ 18C5 CD 2C 19             call    SRCHLN          ; Search for line number in DE
 866+ 18C8 DA D1 18             jp      C,LINFND        ; Jump if line found
 867+ 18CB F1                   pop     AF              ; Get status
 868+ 18CC F5                   push    AF              ; And re-save
 869+ 18CD CA D8 1E             jp      Z,ULERR         ; Nothing after number - Error
 870+ 18D0 B7                   or      A               ; Clear Carry
 871+ 18D1 C5           LINFND: push    BC              ; Save address of line in prog
 872+ 18D2 D2 E8 18             jp      NC,INEWLN       ; Line not found - Insert new
 873+ 18D5 EB                   ex      DE,HL           ; Next line address in DE
 874+ 18D6 2A C2 55             ld      HL,(PROGND)     ; End of program
 875+ 18D9 1A           SFTPRG: ld      A,(DE)          ; Shift rest of program down
 876+ 18DA 02                   ld      (BC),A
 877+ 18DB 03                   inc     BC              ; Next destination
 878+ 18DC 13                   inc     DE              ; Next source
 879+ 18DD CD 0A 1B             call    CPDEHL          ; All done?
 880+ 18E0 C2 D9 18             jp      NZ,SFTPRG       ; More to do
 881+ 18E3 60                   ld      H,B             ; HL - New end of program
 882+ 18E4 69                   ld      L,C
 883+ 18E5 22 C2 55             ld      (PROGND),HL     ; Update end of program
 884+ 18E8
 885+ 18E8 D1           INEWLN: pop     DE              ; Get address of line,
 886+ 18E9 F1                   pop     AF              ; Get status
 887+ 18EA CA 0F 19             jp      Z,SETPTR        ; No text - Set up pointers
 888+ 18ED 2A C2 55             ld      HL,(PROGND)     ; Get end of program
 889+ 18F0 E3                   ex      (SP),HL         ; Get length of input line
 890+ 18F1 C1                   pop     BC              ; End of program to BC
 891+ 18F2 09                   add     HL,BC           ; Find new end
 892+ 18F3 E5                   push    HL              ; Save new end
 893+ 18F4 CD BC 17             call    MOVUP           ; Make space for line
 894+ 18F7 E1                   pop     HL              ; Restore new end
 895+ 18F8 22 C2 55             ld      (PROGND),HL     ; Update end of program pointer
 896+ 18FB EB                   ex      DE,HL           ; Get line to move up in HL
 897+ 18FC 74                   ld      (HL),H          ; Save MSB
 898+ 18FD D1                   pop     DE              ; Get new line number
 899+ 18FE 23                   inc     HL              ; Skip pointer
 900+ 18FF 23                   inc     HL
 901+ 1900 73                   ld      (HL),E          ; Save LSB of line number
 902+ 1901 23                   inc     HL
 903+ 1902 72                   ld      (HL),D          ; Save MSB of line number
 904+ 1903 23                   inc     HL              ; To first byte in line
 905+ 1904 11 B2 54             ld      DE,BUFFER       ; Copy buffer to program
 906+ 1907 1A           MOVBUF: ld      A,(DE)          ; Get source
 907+ 1908 77                   ld      (HL),A          ; Save destinations
 908+ 1909 23                   inc     HL              ; Next source
 909+ 190A 13                   inc     DE              ; Next destination
 910+ 190B B7                   or      A               ; Done?
 911+ 190C C2 07 19             jp      NZ,MOVBUF       ; No - Repeat
 912+ 190F CD 58 19     SETPTR: call    RUNFST          ; Set line pointers
 913+ 1912 23                   inc     HL              ; To LSB of pointer
 914+ 1913 EB                   ex      DE,HL           ; Address to DE
 915+ 1914 62           PTRLP:  ld      H,D             ; Address to HL
 916+ 1915 6B                   ld      L,E
 917+ 1916 7E                   ld      A,(HL)          ; Get LSB of pointer
 918+ 1917 23                   inc     HL              ; To MSB of pointer
 919+ 1918 B6                   or      (HL)            ; Compare with MSB pointer
 920+ 1919 CA 7D 18             jp      Z,GETCMD        ; Get command line if end
 921+ 191C 23                   inc     HL              ; To LSB of line number
 922+ 191D 23                   inc     HL              ; Skip line number
 923+ 191E 23                   inc     HL              ; Point to first byte in line
 924+ 191F AF                   xor     A               ; Looking for 00 byte
 925+ 1920 BE           FNDEND: cp      (HL)            ; Found end of line?
 926+ 1921 23                   inc     HL              ; Move to next byte
 927+ 1922 C2 20 19             jp      NZ,FNDEND       ; No - Keep looking
 928+ 1925 EB                   ex      DE,HL           ; Next line address to HL
 929+ 1926 73                   ld      (HL),E          ; Save LSB of pointer
 930+ 1927 23                   inc     HL
 931+ 1928 72                   ld      (HL),D          ; Save MSB of pointer
 932+ 1929 C3 14 19             jp      PTRLP           ; Do next line
 933+ 192C
 934+ 192C 2A AF 54     SRCHLN: ld      HL,(BASTXT)     ; Start of program text
 935+ 192F 44           SRCHLP: ld      B,H             ; BC = Address to look at
 936+ 1930 4D                   ld      C,L
 937+ 1931 7E                   ld      A,(HL)          ; Get address of next line
 938+ 1932 23                   inc     HL
 939+ 1933 B6                   or      (HL)            ; End of program found?
 940+ 1934 2B                   dec     HL
 941+ 1935 C8                   ret     Z               ; Yes - Line not found
 942+ 1936 23                   inc     HL
 943+ 1937 23                   inc     HL
 944+ 1938 7E                   ld      A,(HL)          ; Get LSB of line number
 945+ 1939 23                   inc     HL
 946+ 193A 66                   ld      H,(HL)          ; Get MSB of line number
 947+ 193B 6F                   ld      L,A
 948+ 193C CD 0A 1B             call    CPDEHL          ; Compare with line in DE
 949+ 193F 60                   ld      H,B             ; HL = Start of this line
 950+ 1940 69                   ld      L,C
 951+ 1941 7E                   ld      A,(HL)          ; Get LSB of next line address
 952+ 1942 23                   inc     HL
 953+ 1943 66                   ld      H,(HL)          ; Get MSB of next line address
 954+ 1944 6F                   ld      L,A             ; Next line to HL
 955+ 1945 3F                   ccf
 956+ 1946 C8                   ret     Z               ; Lines found - Exit
 957+ 1947 3F                   ccf
 958+ 1948 D0                   ret     NC              ; Line not found,at line after
 959+ 1949 C3 2F 19             jp      SRCHLP          ; Keep looking
 960+ 194C
 961+ 194C C0           NEW:    ret     NZ              ; Return if any more on line
 962+ 194D 2A AF 54     CLRPTR: ld      HL,(BASTXT)     ; Point to start of program
 963+ 1950 AF                   xor     A               ; Set program area to empty
 964+ 1951 77                   ld      (HL),A          ; Save LSB = 00
 965+ 1952 23                   inc     HL
 966+ 1953 77                   ld      (HL),A          ; Save MSB = 00
 967+ 1954 23                   inc     HL
 968+ 1955 22 C2 55             ld      (PROGND),HL     ; Set program end
 969+ 1958
 970+ 1958 2A AF 54     RUNFST: ld      HL,(BASTXT)     ; Clear all variables
 971+ 195B 2B                   dec     HL
 972+ 195C
 973+ 195C 22 54 55     INTVAR: ld      (BRKLIN),HL     ; Initialise RUN variables
 974+ 195F 2A 10 55             ld      HL,(LSTRAM)     ; Get end of RAM
 975+ 1962 22 49 55             ld      (STRBOT),HL     ; Clear string space
 976+ 1965 AF                   xor     A
 977+ 1966 CD 69 1D             call    RESTOR          ; Reset DATA pointers
 978+ 1969 2A C2 55             ld      HL,(PROGND)     ; Get end of program
 979+ 196C 22 C4 55             ld      (VAREND),HL     ; Clear variables
 980+ 196F 22 C6 55             ld      (ARREND),HL     ; Clear arrays
 981+ 1972
 982+ 1972 C1           CLREG:  pop     BC              ; Save return address
 983+ 1973 2A 27 54             ld      HL,(STRSPC)     ; Get end of working RAM
 984+ 1976 F9                   ld      SP,HL           ; Set stack
 985+ 1977 21 39 55             ld      HL,TMSTPL       ; Temporary string pool
 986+ 197A 22 37 55             ld      (TMSTPT),HL     ; Reset temporary string ptr
 987+ 197D AF                   xor     A               ; A = 00
 988+ 197E 6F                   ld      L,A             ; HL = 0000
 989+ 197F 67                   ld      H,A
 990+ 1980 22 5A 55             ld      (CONTAD),HL     ; No CONTinue
 991+ 1983 32 51 55             ld      (FORFLG),A      ; Clear FOR flag
 992+ 1986 22 CA 55             ld      (FNRGNM),HL     ; Clear FN argument
 993+ 1989 E5                   push    HL              ; HL = 0000
 994+ 198A C5                   push    BC              ; Put back return
 995+ 198B 2A 54 55     DOAGN:  ld      HL,(BRKLIN)     ; Get address of code to RUN
 996+ 198E C9                   ret                     ; Return to execution driver
 997+ 198F
 998+ 198F 3E 3F        PROMPT: ld      A,'?'           ; '?'
 999+ 1991 CD 1B 1B             call    OUTC            ; Output character
1000+ 1994 3E 00                ld      A,NLLCR         ; null char
1001+ 1996 CD 1B 1B             call    OUTC            ; Output character
1002+ 1999 CD 26 09             call    CURSOR_ON       ; enable cursor
1003+ 199C 3A BE 55             ld      A,(SERIALS_EN)  ; load serial state
1004+ 199F EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
1005+ 19A1 CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
1006+ 19A4 C3 24 54             jp      RINPUT          ; Get input line
1007+ 19A7
1008+ 19A7 AF           CRUNCH: xor     A               ; Tokenise line @ HL to BUFFER
1009+ 19A8 32 0F 55             ld      (DATFLG),A      ; Reset literal flag
1010+ 19AB 0E 05                ld      C,2+3           ; 2 byte number and 3 nulls
1011+ 19AD 11 B2 54             ld      DE,BUFFER       ; Start of input buffer
1012+ 19B0 7E           CRNCLP: ld      A,(HL)          ; Get byte
1013+ 19B1 FE 20                cp      SPC             ; Is it a space?
1014+ 19B3 CA 2F 1A             jp      Z,MOVDIR        ; Yes - Copy direct
1015+ 19B6 47                   ld      B,A             ; Save character
1016+ 19B7 FE 22                cp      $22             ; '"'             ; Is it a quote?
1017+ 19B9 CA 4F 1A             jp      Z,CPYLIT        ; Yes - Copy literal string
1018+ 19BC B7                   or      A               ; Is it end of buffer?
1019+ 19BD CA 56 1A             jp      Z,ENDBUF        ; Yes - End buffer
1020+ 19C0 3A 0F 55             ld      A,(DATFLG)      ; Get data type
1021+ 19C3 B7                   or      A               ; Literal?
1022+ 19C4 7E                   ld      A,(HL)          ; Get byte to copy
1023+ 19C5 C2 2F 1A             jp      NZ,MOVDIR       ; Literal - Copy direct
1024+ 19C8 FE 3F                cp      '?'             ; Is it '?' short for PRINT
1025+ 19CA 3E B3                ld      A,ZPRINT        ; "PRINT" token
1026+ 19CC CA 2F 1A             jp      Z,MOVDIR        ; Yes - replace it
1027+ 19CF 7E                   ld      A,(HL)          ; Get byte again
1028+ 19D0 FE 30                cp      '0'             ; Is it less than '0'
1029+ 19D2 DA DA 19             jp      C,FNDWRD        ; Yes - Look for reserved words
1030+ 19D5 FE 3C                cp      $3C  ;60; ";"+1       ; Is it "0123456789:;" ?
1031+ 19D7 DA 2F 1A             jp      C,MOVDIR        ; Yes - copy it direct
1032+ 19DA D5           FNDWRD: push    DE              ; Look for reserved words
1033+ 19DB 11 73 14             ld      DE,WORDS-1      ; Point to table
1034+ 19DE C5                   push    BC              ; Save count
1035+ 19DF 01 2B 1A             ld      BC,RETNAD       ; Where to return to
1036+ 19E2 C5                   push    BC              ; Save return address
1037+ 19E3 06 7F                ld      B,ZEND-1        ; First token value -1
1038+ 19E5 7E                   ld      A,(HL)          ; Get byte
1039+ 19E6 FE 61                cp      'a'             ; Less than 'a' ?
1040+ 19E8 DA F3 19             jp      C,SEARCH        ; Yes - search for words
1041+ 19EB FE 7B                cp      'z'+1           ; Greater than 'z' ?
1042+ 19ED D2 F3 19             jp      NC,SEARCH       ; Yes - search for words
1043+ 19F0 E6 5F                and     %01011111       ; Force upper case
1044+ 19F2 77                   ld      (HL),A          ; Replace byte
1045+ 19F3 4E           SEARCH: ld      C,(HL)          ; Search for a word
1046+ 19F4 EB                   ex      DE,HL
1047+ 19F5 23           GETNXT: inc     HL              ; Get next reserved word
1048+ 19F6 B6                   or      (HL)            ; Start of word?
1049+ 19F7 F2 F5 19             jp      P,GETNXT        ; No - move on
1050+ 19FA 04                   inc     B               ; Increment token value
1051+ 19FB 7E                   ld      A,(HL)          ; Get byte from table
1052+ 19FC E6 7F                and     %01111111       ; Strip bit 7
1053+ 19FE C8                   ret     Z               ; Return if end of list
1054+ 19FF B9                   cp      C               ; Same character as in buffer?
1055+ 1A00 C2 F5 19             jp      NZ,GETNXT       ; No - get next word
1056+ 1A03 EB                   ex      DE,HL
1057+ 1A04 E5                   push    HL              ; Save start of word
1058+ 1A05
1059+ 1A05 13           NXTBYT: inc     DE              ; Look through rest of word
1060+ 1A06 1A                   ld      A,(DE)          ; Get byte from table
1061+ 1A07 B7                   or      A               ; End of word ?
1062+ 1A08 FA 27 1A             jp      M,MATCH         ; Yes - Match found
1063+ 1A0B 4F                   ld      C,A             ; Save it
1064+ 1A0C 78                   ld      A,B             ; Get token value
1065+ 1A0D FE 88                cp      ZGOTO           ; Is it "GOTO" token ?
1066+ 1A0F C2 16 1A             jp      NZ,NOSPC        ; No - Don't allow spaces
1067+ 1A12 CD 59 1D             call    GETCHR          ; Get next character
1068+ 1A15 2B                   dec     HL              ; Cancel increment from GETCHR
1069+ 1A16 23           NOSPC:  inc     HL              ; Next byte
1070+ 1A17 7E                   ld      A,(HL)          ; Get byte
1071+ 1A18 FE 61                cp      'a'             ; Less than 'a' ?
1072+ 1A1A DA 1F 1A             jp      C,NOCHNG        ; Yes - don't change
1073+ 1A1D E6 5F                and     %01011111       ; Make upper case
1074+ 1A1F B9           NOCHNG: cp      C               ; Same as in buffer ?
1075+ 1A20 CA 05 1A             jp      Z,NXTBYT        ; Yes - keep testing
1076+ 1A23 E1                   pop     HL              ; Get back start of word
1077+ 1A24 C3 F3 19             jp      SEARCH          ; Look at next word
1078+ 1A27
1079+ 1A27 48           MATCH:  ld      C,B             ; Word found - Save token value
1080+ 1A28 F1                   pop     AF              ; Throw away return
1081+ 1A29 EB                   ex      DE,HL
1082+ 1A2A C9                   ret                     ; Return to "RETNAD"
1083+ 1A2B EB           RETNAD: ex      DE,HL           ; Get address in string
1084+ 1A2C 79                   ld      A,C             ; Get token value
1085+ 1A2D C1                   pop     BC              ; Restore buffer length
1086+ 1A2E D1                   pop     DE              ; Get destination address
1087+ 1A2F 23           MOVDIR: inc     HL              ; Next source in buffer
1088+ 1A30 12                   ld      (DE),A          ; Put byte in buffer
1089+ 1A31 13                   inc     DE              ; Move up buffer
1090+ 1A32 0C                   inc     C               ; Increment length of buffer
1091+ 1A33 D6 3A                sub     ':'             ; End of statement?
1092+ 1A35 CA 3D 1A             jp      Z,SETLIT        ; Jump if multi-statement line
1093+ 1A38 FE 49                cp      ZDATA-$3A       ; Is it DATA statement ?
1094+ 1A3A C2 40 1A             jp      NZ,TSTREM       ; No - see if REM
1095+ 1A3D 32 0F 55     SETLIT: ld      (DATFLG),A      ; Set literal flag
1096+ 1A40 D6 54        TSTREM: sub     ZREM-$3A        ; Is it REM?
1097+ 1A42 C2 B0 19             jp      NZ,CRNCLP       ; No - Leave flag
1098+ 1A45 47                   ld      B,A             ; Copy rest of buffer
1099+ 1A46 7E           NXTCHR: ld      A,(HL)          ; Get byte
1100+ 1A47 B7                   or      A               ; End of line ?
1101+ 1A48 CA 56 1A             jp      Z,ENDBUF        ; Yes - Terminate buffer
1102+ 1A4B B8                   cp      B               ; End of statement ?
1103+ 1A4C CA 2F 1A             jp      Z,MOVDIR        ; Yes - Get next one
1104+ 1A4F 23           CPYLIT: inc     HL              ; Move up source string
1105+ 1A50 12                   ld      (DE),A          ; Save in destination
1106+ 1A51 0C                   inc     C               ; Increment length
1107+ 1A52 13                   inc     DE              ; Move up destination
1108+ 1A53 C3 46 1A             jp      NXTCHR          ; Repeat
1109+ 1A56
1110+ 1A56 21 B1 54     ENDBUF: ld      HL,BUFFER-1     ; Point to start of buffer
1111+ 1A59 12                   ld      (DE),A          ; Mark end of buffer (A = 00)
1112+ 1A5A 13                   inc     DE
1113+ 1A5B 12                   ld      (DE),A          ; A = 00
1114+ 1A5C 13                   inc     DE
1115+ 1A5D 12                   ld      (DE),A          ; A = 00
1116+ 1A5E C9                   ret
1117+ 1A5F
1118+ 1A5F 3A 1E 54     DODEL:  ld      A,(NULFLG)      ; Get null flag status
1119+ 1A62 B7                   or      A               ; Is it zero?
1120+ 1A63 3E 00                ld      A,$00           ; Zero A - Leave flags
1121+ 1A65 32 1E 54             ld      (NULFLG),A      ; Zero null flag
1122+ 1A68 C2 73 1A             jp      NZ,ECHDEL       ; Set - Echo it
1123+ 1A6B 05                   dec     B               ; Decrement length
1124+ 1A6C CA 90 1A             jp      Z,GETLIN        ; Get line again if empty
1125+ 1A6F CD 1B 1B             call    OUTC            ; Output null character
1126+ 1A72 3E                   defb    $3E             ; Skip "dec B"
1127+ 1A73 05           ECHDEL: dec     B               ; Count bytes in buffer
1128+ 1A74 2B                   dec     HL              ; Back space buffer
1129+ 1A75 CA 87 1A             jp      Z,OTKLN         ; No buffer - Try again
1130+ 1A78 7E                   ld      A,(HL)          ; Get deleted byte
1131+ 1A79 CD 1B 1B             call    OUTC            ; Echo it
1132+ 1A7C C3 99 1A             jp      MORINP          ; Get more input
1133+ 1A7F
1134+ 1A7F 05           DELCHR: dec     B               ; Count bytes in buffer
1135+ 1A80 2B                   dec     HL              ; Back space buffer
1136+ 1A81 CD 1B 1B             call    OUTC            ; Output character in A
1137+ 1A84 C2 99 1A             jp      NZ,MORINP       ; Not end - Get more
1138+ 1A87 CD 1B 1B     OTKLN:  call    OUTC            ; Output character in A
1139+ 1A8A CD 26 20     KILIN:  call    PRNTCRLF        ; Output CRLF
1140+ 1A8D C3 90 1A             jp      TTYLIN          ; Get line again
1141+ 1A90
1142+ 1A90              GETLIN:
1143+ 1A90 21 B2 54     TTYLIN: ld      HL,BUFFER       ; Get a line by character
1144+ 1A93 06 01                ld      B,$01           ; Set buffer as empty
1145+ 1A95 AF                   xor     A
1146+ 1A96 32 1E 54             ld      (NULFLG),A      ; Clear null flag
1147+ 1A99 CD 5C 1B     MORINP: call    CLOTST          ; Get character and test ^O
1148+ 1A9C 4F                   ld      C,A             ; Save character in C
1149+ 1A9D FE 7F                cp      DEL             ; Delete character?
1150+ 1A9F CA 5F 1A             jp      Z,DODEL         ; Yes - Process it
1151+ 1AA2 3A 1E 54             ld      A,(NULFLG)      ; Get null flag
1152+ 1AA5 B7                   or      A               ; Test null flag status
1153+ 1AA6 CA B2 1A             jp      Z,PROCES        ; Reset - Process character
1154+ 1AA9 3E 00                ld      A,$00           ; Set a null
1155+ 1AAB CD 1B 1B             call    OUTC            ; Output null
1156+ 1AAE AF                   xor     A               ; Clear A
1157+ 1AAF 32 1E 54             ld      (NULFLG),A      ; Reset null flag
1158+ 1AB2 79           PROCES: ld      A,C             ; Get character
1159+ 1AB3 FE 07                cp      CTRLG           ; Bell?
1160+ 1AB5 CA F2 1A             jp      Z,PUTCTL        ; Yes - Save it
1161+ 1AB8 FE 03                cp      CTRLC           ; Is it control "C"?
1162+ 1ABA CC E7 1A             call    Z,GMNCR         ; Yes - exit from graphic mode & Output CRLF
1163+ 1ABD 37                   scf                     ; Flag break
1164+ 1ABE C8                   ret     Z               ; Return if control "C"
1165+ 1ABF FE 0D                cp      CR              ; Is it enter?
1166+ 1AC1 CA 1C 20             jp      Z,ENDINP        ; Yes - Terminate input
1167+ 1AC4 FE 15                cp      CTRLU           ; Is it control "U"?
1168+ 1AC6 CA 8A 1A             jp      Z,KILIN         ; Yes - Get another line
1169+ 1AC9 FE 08                cp      BKSP            ; Is it backspace?
1170+ 1ACB CA 7F 1A             jp      Z,DELCHR        ; Yes - Delete character
1171+ 1ACE FE 12                cp      CTRLR           ; Is it control "R"?
1172+ 1AD0 C2 ED 1A             jp      NZ,PUTBUF       ; No - Put in buffer
1173+ 1AD3 C5                   push    BC              ; Save buffer length
1174+ 1AD4 D5                   push    DE              ; Save DE
1175+ 1AD5 E5                   push    HL              ; Save buffer address
1176+ 1AD6 36 00                ld      (HL),$00        ; Mark end of buffer
1177+ 1AD8 CD 2F 41             call    OUTNCR          ; Output and do CRLF
1178+ 1ADB 21 B2 54             ld      HL,BUFFER       ; Point to buffer start
1179+ 1ADE CD F2 26             call    PRS             ; Output buffer
1180+ 1AE1 E1                   pop     HL              ; Restore buffer address
1181+ 1AE2 D1                   pop     DE              ; Restore DE
1182+ 1AE3 C1                   pop     BC              ; Restore buffer length
1183+ 1AE4 C3 99 1A             jp      MORINP          ; Get another character
1184+ 1AE7 CD EA 17     GMNCR:  call    EXITGM          ; exit from graphic mode
1185+ 1AEA C3 26 20             jp      PRNTCRLF        ; output CRLF
1186+ 1AED
1187+ 1AED FE 20        PUTBUF: cp      SPC             ; Is it a control code?
1188+ 1AEF DA 99 1A             jp      C,MORINP        ; Yes - Ignore
1189+ 1AF2 78           PUTCTL: ld      A,B             ; Get number of bytes in buffer
1190+ 1AF3 FE 59                cp      $58+$01         ; Test for line overflow
1191+ 1AF5 3E 08                ld      A,BKSP          ; Set a bell
1192+ 1AF7 D2 04 1B             jp      NC,OUTNBS       ; Ring bell if buffer full
1193+ 1AFA 79                   ld      A,C             ; Get character
1194+ 1AFB 71                   ld      (HL),C          ; Save in buffer
1195+ 1AFC 32 52 55             ld      (LSTBIN),A      ; Save last input byte
1196+ 1AFF 23                   inc     HL              ; Move up buffer
1197+ 1B00 04                   inc     B               ; Increment length
1198+ 1B01 C3 99 1A     OUTIT:  jp      MORINP          ; Get another character
1199+ 1B04
1200+ 1B04 CD 1B 1B     OUTNBS: call    OUTC            ; Output bell and back over it
1201+ 1B07 C3 01 1B             jp      OUTIT           ; get more chars
1202+ 1B0A
1203+ 1B0A 7C           CPDEHL: ld      A,H             ; Get H
1204+ 1B0B 92                   sub     D               ; Compare with D
1205+ 1B0C C0                   ret     NZ              ; Different - Exit
1206+ 1B0D 7D                   ld      A,L             ; Get L
1207+ 1B0E 93                   sub     E               ; Compare with E
1208+ 1B0F C9                   ret                     ; Return status
1209+ 1B10
1210+ 1B10 7E           CHKSYN: ld      A,(HL)          ; Check syntax of character
1211+ 1B11 E3                   ex      (SP),HL         ; Address of test byte
1212+ 1B12 BE                   cp      (HL)            ; Same as in code string?
1213+ 1B13 23                   inc     HL              ; Return address
1214+ 1B14 E3                   ex      (SP),HL         ; Put it back
1215+ 1B15 CA 59 1D             jp      Z,GETCHR        ; Yes - Get next character
1216+ 1B18 C3 10 18             jp      SNERR           ; Different - ?SN Error
1217+ 1B1B
1218+ 1B1B F5           OUTC:   push    AF              ; Save character
1219+ 1B1C 3A 1F 54             ld      A,(CTLOFG)      ; Get control "O" flag
1220+ 1B1F B7                   or      A               ; Is it set?
1221+ 1B20 C2 27 27             jp      NZ,POPAF        ; Yes - don't output
1222+ 1B23 F1                   pop     AF              ; Restore character
1223+ 1B24 C5                   push    BC              ; Save buffer length
1224+ 1B25 F5                   push    AF              ; Save character
1225+ 1B26 FE 20                cp      SPC             ; Is it a control code?
1226+ 1B28 DA 3F 1B             jp      C,DINPOS        ; Yes - Don't inc POS(X)
1227+ 1B2B 3A 1C 54             ld      A,(LWIDTH)      ; Get line width
1228+ 1B2E 47                   ld      B,A             ; To B
1229+ 1B2F 3A 0C 55             ld      A,(CURPOS)      ; Get cursor position
1230+ 1B32 04                   inc     B               ; Width 255?
1231+ 1B33 CA 3B 1B             jp      Z,INCLEN        ; Yes - No width limit
1232+ 1B36 05                   dec     B               ; Restore width
1233+ 1B37 B8                   cp      B               ; At end of line?
1234+ 1B38 CC 26 20             call    Z,PRNTCRLF      ; Yes - output CRLF
1235+ 1B3B 3C           INCLEN: inc     A               ; Move on one character
1236+ 1B3C 32 0C 55             ld      (CURPOS),A      ; Save new position
1237+ 1B3F AF           DINPOS: xor     A
1238+ 1B40 32 B6 55             ld      (KBDNPT),A      ; set flag for no char from keyboard
1239+ 1B43 F1                   pop     AF              ; Restore character
1240+ 1B44 C1                   pop     BC              ; Restore buffer length
1241+ 1B45 F5                   push    AF
1242+ 1B46 CD 4E 1B             call    SND2VID         ; send char to video
1243+ 1B49 F1                   pop     AF
1244+ 1B4A CD 08 41             call    MONOUT          ; send char to serial if enabled
1245+ 1B4D C9                   ret
1246+ 1B4E
1247+ 1B4E              ; print char to video if cursor is on
1248+ 1B4E 32 79 55     SND2VID:ld      (CHR4VID),A     ; store A
1249+ 1B51 3A 78 55             ld      A,(PRNTVIDEO)   ; check print-on-video
1250+ 1B54 B7                   or      A               ; is it off?
1251+ 1B55 C8                   ret     Z               ; yes, so return
1252+ 1B56 F3                   di                      ; disable INTs
1253+ 1B57 CD 5A 07             call    CHAR2VID        ; cursor is on, so print char on screen
1254+ 1B5A FB                   ei                      ; re-enable INTs
1255+ 1B5B C9                   ret                     ; return to caller
1256+ 1B5C
1257+ 1B5C CD AC 34     CLOTST: call    GETINP          ; Get input character
1258+ 1B5F FE 0F                cp      CTRLO           ; Is it control "O"?
1259+ 1B61 C0                   ret     NZ              ; No don't flip flag
1260+ 1B62 3A 1F 54             ld      A,(CTLOFG)      ; Get flag
1261+ 1B65 2F                   cpl                     ; Flip it
1262+ 1B66 32 1F 54             ld      (CTLOFG),A      ; Put it back
1263+ 1B69 A7                   and     A               ; is output enabled?
1264+ 1B6A CC 26 09             call    Z,CURSOR_ON     ; yes, so cursor on
1265+ 1B6D 3A BE 55             ld      A,(SERIALS_EN)  ; load serial state
1266+ 1B70 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
1267+ 1B72 CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
1268+ 1B75 AF                   xor     A               ; Null character
1269+ 1B76 C9                   ret
1270+ 1B77
1271+ 1B77              ; LIST: list the program stored into memory
1272+ 1B77 C1           LIST:   pop     BC              ; rubbish - not needed (legacy from original call of LIST)
1273+ 1B78 2B                   dec     HL              ; dec 'cos GETCHR INCs
1274+ 1B79 CD 59 1D             call    GETCHR          ; Get next character
1275+ 1B7C CA D2 1B             jp      Z,LSTALL        ; list all if nothing follows
1276+ 1B7F FE C2                cp      ZMINUS          ; is it '-'?
1277+ 1B81 20 20                jr      NZ,LST01        ; no, look for a line number
1278+ 1B83 11 00 00             ld      DE,$0000        ; yes, set search from 0
1279+ 1B86 CD 73 1C             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1280+ 1B89 ED 43 7C 55          ld      (TMPBFR1),BC    ; store address of starting line
1281+ 1B8D CD 10 1B             call    CHKSYN          ; skip '-'
1282+ 1B90 C2                   defb    ZMINUS
1283+ 1B91 CD 29 1E             call    ATOH            ; now, look for another number (ASCII number to DE)
1284+ 1B94 CD 79 1C             call    SRCLN           ; find a line, getting the previous if it doesn't exist
1285+ 1B97 ED 43 7E 55          ld      (TMPBFR2),BC    ; store address of ending line
1286+ 1B9B ED 4B 7C 55          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1287+ 1B9F C5                   push    BC              ; store address of line for later use
1288+ 1BA0 C3 0A 1C             jp      LISTLP          ; go listing
1289+ 1BA3 CD 29 1E     LST01:  call    ATOH            ; get a line number (ASCII number to DE)
1290+ 1BA6 ED 53 82 55  LST01H: ld      (TMPBFR4),DE    ; store ending line address for later use - N.B.: this is a hook for HELP command
1291+ 1BAA CD 73 1C             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1292+ 1BAD ED 43 7C 55          ld      (TMPBFR1),BC    ; store address of starting line
1293+ 1BB1 ED 43 7E 55          ld      (TMPBFR2),BC    ; same address for ending line (we'll change it later if needed)
1294+ 1BB5 2B                   dec     HL              ; dec 'cos GETCHR INCs
1295+ 1BB6 CD 59 1D             call    GETCHR          ; Get next character
1296+ 1BB9 CA C5 1B             jp      Z,LSTNOT        ; nothing follows, so ending & starting lines are the same
1297+ 1BBC FE C2                cp      ZMINUS          ; is it '-'?
1298+ 1BBE CA EA 1B             jp      Z,LST03         ; yes, read ending line
1299+ 1BC1 C5           LST06:  push    BC              ; store address for later use
1300+ 1BC2 C3 0A 1C             jp      LISTLP          ; jump to list
1301+ 1BC5 ED 5B 82 55  LSTNOT: ld      DE,(TMPBFR4)
1302+ 1BC9 CD 73 1C             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1303+ 1BCC DA C1 1B             jp      C,LST06
1304+ 1BCF C3 70 18             jp      PRNTOK
1305+ 1BD2 11 F9 FF     LSTALL: ld      DE,65529        ; set ending line to max. allowed line number
1306+ 1BD5 CD 73 1C             call    SRCHLIN         ; get address of last line
1307+ 1BD8 ED 43 7E 55          ld      (TMPBFR2),BC    ; store it
1308+ 1BDC 11 00 00             ld      DE,$0000        ; set start to first line in memory
1309+ 1BDF CD 73 1C             call    SRCHLIN         ; get address of first line
1310+ 1BE2 ED 43 7C 55          ld      (TMPBFR1),BC    ; store it
1311+ 1BE6 C5                   push    BC              ; store address of starting line for later use
1312+ 1BE7 C3 0A 1C             jp      LISTLP          ; start printing
1313+ 1BEA CD 10 1B     LST03:  call    CHKSYN          ; skip '-'
1314+ 1BED C2                   defb    ZMINUS
1315+ 1BEE CD 29 1E             call    ATOH            ; look for another number (return into DE)
1316+ 1BF1 7A                   ld      A,D
1317+ 1BF2 B3                   or      E               ; is line=0?
1318+ 1BF3 20 09                jr      NZ,LST05        ; no, jump over
1319+ 1BF5 11 F9 FF             ld      DE,65529        ; yes set last valid line number
1320+ 1BF8 CD 73 1C             call    SRCHLIN         ; get address of last line
1321+ 1BFB C3 01 1C             jp      LST02
1322+ 1BFE CD 79 1C     LST05:  call    SRCLN           ; find a line, getting the previous if it doesn't exist
1323+ 1C01 ED 43 7E 55  LST02:  ld      (TMPBFR2),BC    ; store address of ending line
1324+ 1C05 ED 4B 7C 55          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1325+ 1C09 C5                   push    BC              ; store it for later use
1326+ 1C0A E1           LISTLP: pop     HL              ; Restore address of line
1327+ 1C0B 4E                   ld      C,(HL)          ; Get LSB of next line
1328+ 1C0C 23                   inc     HL
1329+ 1C0D 46                   ld      B,(HL)          ; Get MSB of next line
1330+ 1C0E 23                   inc     HL
1331+ 1C0F 78                   ld      A,B             ; BC = 0 (End of program)?
1332+ 1C10 B1                   or      C
1333+ 1C11 CA 70 18             jp      Z,PRNTOK        ; Yes - Go to command mode
1334+ 1C14 CD 84 1D             call    TSTBRK          ; Test for break key
1335+ 1C17 CD 87 1C             call    TSTSPC          ; test for space
1336+ 1C1A C5                   push    BC              ; Save address of next line
1337+ 1C1B 3A 71 55             ld      A,(SCR_CURS_X)  ; load current X pos of cursor
1338+ 1C1E A7                   and     A               ; is it at the beginning of a new line?
1339+ 1C1F 20 0B                jr      NZ,LST08        ; No, jump over
1340+ 1C21 3E 0D                ld      A,CR            ; yes, so just send a CR
1341+ 1C23 CD 08 41             call    MONOUT          ; to serial if it's open
1342+ 1C26 AF                   xor     A               ; then, set cursor
1343+ 1C27 32 0C 55             ld      (CURPOS),A      ; to position 0
1344+ 1C2A 18 03                jr      LST07           ; and continue
1345+ 1C2C CD 26 20     LST08:  call    PRNTCRLF        ; output CRLF
1346+ 1C2F 5E           LST07:  ld      E,(HL)          ; Get LSB of line number
1347+ 1C30 23                   inc     HL
1348+ 1C31 56                   ld      D,(HL)          ; Get MSB of line number
1349+ 1C32 23                   inc     HL
1350+ 1C33 E5                   push    HL              ; Save address of line start
1351+ 1C34 EB                   ex      DE,HL           ; Line number to HL
1352+ 1C35 CD 91 31             call    PRNTHL          ; Output line number in decimal
1353+ 1C38 3E 20                ld      A,SPC           ; Space after line number
1354+ 1C3A E1                   pop     HL              ; Restore start of line address
1355+ 1C3B CD 1B 1B     LSTLP2: call    OUTC            ; Output character in A
1356+ 1C3E 7E           LSTLP3: ld      A,(HL)          ; Get next byte in line
1357+ 1C3F B7                   or      A               ; End of line?
1358+ 1C40 23                   inc     HL              ; To next byte in line
1359+ 1C41 CA 65 1C             jp      Z,NXTLN         ; Yes - check next line
1360+ 1C44 F2 3B 1C             jp      P,LSTLP2        ; No token - output it
1361+ 1C47 D6 7F                sub     ZEND-1          ; Find and output word
1362+ 1C49 4F                   ld      C,A             ; Token offset+1 to C
1363+ 1C4A 11 74 14             ld      DE,WORDS        ; Reserved word list
1364+ 1C4D 1A           FNDTOK: ld      A,(DE)          ; Get character in list
1365+ 1C4E 13                   inc     DE              ; Move on to next
1366+ 1C4F B7                   or      A               ; Is it start of word?
1367+ 1C50 F2 4D 1C             jp      P,FNDTOK        ; No - Keep looking for word
1368+ 1C53 0D                   dec     C               ; Count words
1369+ 1C54 C2 4D 1C             jp      NZ,FNDTOK       ; Not there - keep looking
1370+ 1C57 E6 7F        OUTWRD: and     %01111111       ; Strip bit 7
1371+ 1C59 CD 1B 1B             call    OUTC            ; Output character
1372+ 1C5C 1A                   ld      A,(DE)          ; Get next character
1373+ 1C5D 13                   inc     DE              ; Move on to next
1374+ 1C5E B7                   or      A               ; Is it end of word?
1375+ 1C5F F2 57 1C             jp      P,OUTWRD        ; No - output the rest
1376+ 1C62 C3 3E 1C             jp      LSTLP3          ; Next byte in line
1377+ 1C65 D1           NXTLN:  pop     DE              ; recover address of current line
1378+ 1C66 2A 7E 55             ld      HL,(TMPBFR2)    ; address of last line to print
1379+ 1C69 CD 35 41             call    CMP16           ; check if current line is over last printable line
1380+ 1C6C DA 70 18             jp      C,PRNTOK        ; finish - leave & print OK
1381+ 1C6F D5                   push    DE              ; store address of current line
1382+ 1C70 C3 0A 1C             jp      LISTLP          ; continue listing
1383+ 1C73              ; look for the address of a program line
1384+ 1C73 E5           SRCHLIN:push    HL              ; store HL (this is needed because HL store the pointer to the input buffer)
1385+ 1C74 CD 2C 19             call    SRCHLN          ; search for line number in DE
1386+ 1C77 E1                   pop     HL              ; retrieve HL
1387+ 1C78 C9                   ret                     ; return to caller
1388+ 1C79              ; look for the address of a program line - if the line isn't found,
1389+ 1C79              ; it look backward for the previous line
1390+ 1C79 E5           SRCLN:  push    HL              ; store HL
1391+ 1C7A CD 2C 19     SRCLN1: call    SRCHLN          ; search for line in DE
1392+ 1C7D DA 85 1C             jp      C,LVSRLN        ; found it, leave loop
1393+ 1C80 1B                   dec     DE              ; not found, decrement number to look backward for an existing line
1394+ 1C81 7B                   ld      A,E
1395+ 1C82 B2                   or      D               ; is line number zero?
1396+ 1C83 20 F5                jr      NZ,SRCLN1       ; no, continue
1397+ 1C85 E1           LVSRLN: pop     HL              ; retrieve HL
1398+ 1C86 C9                   ret                     ; return to caller
1399+ 1C87
1400+ 1C87              ; during LISTing, check if PAUSE is pressed, then pause listing and
1401+ 1C87              ; wait for another pressing of PAUSE to continue or CTRL-C/BREAK to exit
1402+ 1C87 3A B8 55     TSTSPC: ld      A,(TMPKEYBFR)   ; Get input character
1403+ 1C8A FE 20                cp      SPC             ; Is it SPACE?
1404+ 1C8C C0                   ret     NZ              ; No, return
1405+ 1C8D CD AC 34     WTSPC:  call    GETINP          ; Yes, stop listing and wait for another space or BREAK
1406+ 1C90 FE 20                cp      SPC             ; is it SPACE?
1407+ 1C92 20 05                jr      NZ,CNTWTSP      ; no, continue
1408+ 1C94 AF                   xor     A
1409+ 1C95 32 B8 55             ld      (TMPKEYBFR),A   ; reset key
1410+ 1C98 C9                   ret                     ; return to caller
1411+ 1C99 FE 03        CNTWTSP:cp      CTRLC           ; is it CTRL-C/BREAK?
1412+ 1C9B 20 F0                jr      NZ,WTSPC        ; no, loop
1413+ 1C9D C3 A0 13             jp      BRKRET          ; exit and output "Ok"
1414+ 1CA0
1415+ 1CA0
1416+ 1CA0 3E 64        FOR:    ld      A,$64           ; Flag "FOR" assignment
1417+ 1CA2 32 51 55             ld      (FORFLG),A      ; Save "FOR" flag
1418+ 1CA5 CD 19 1F             call    LET             ; Set up initial index
1419+ 1CA8 C1                   pop     BC              ; Drop RETurn address
1420+ 1CA9 E5                   push    HL              ; Save code string address
1421+ 1CAA CD 02 1F             call    DATA            ; Get next statement address
1422+ 1CAD 22 4D 55             ld      (LOOPST),HL     ; Save it for start of loop
1423+ 1CB0 21 02 00             ld      HL,$0002        ; Offset for "FOR" block
1424+ 1CB3 39                   add     HL,SP           ; Point to it
1425+ 1CB4 CD 9D 17     FORSLP: call    LOKFOR          ; Look for existing "FOR" block
1426+ 1CB7 D1                   pop     DE              ; Get code string address
1427+ 1CB8 C2 D0 1C             jp      NZ,FORFND       ; No nesting found
1428+ 1CBB 09                   add     HL,BC           ; Move into "FOR" block
1429+ 1CBC D5                   push    DE              ; Save code string address
1430+ 1CBD 2B                   dec     HL
1431+ 1CBE 56                   ld      D,(HL)          ; Get MSB of loop statement
1432+ 1CBF 2B                   dec     HL
1433+ 1CC0 5E                   ld      E,(HL)          ; Get LSB of loop statement
1434+ 1CC1 23                   inc     HL
1435+ 1CC2 23                   inc     HL
1436+ 1CC3 E5                   push    HL              ; Save block address
1437+ 1CC4 2A 4D 55             ld      HL,(LOOPST)     ; Get address of loop statement
1438+ 1CC7 CD 0A 1B             call    CPDEHL          ; Compare the FOR loops
1439+ 1CCA E1                   pop     HL              ; Restore block address
1440+ 1CCB C2 B4 1C             jp      NZ,FORSLP       ; Different FORs - Find another
1441+ 1CCE D1                   pop     DE              ; Restore code string address
1442+ 1CCF F9                   ld      SP,HL           ; Remove all nested loops
1443+ 1CD0
1444+ 1CD0 EB           FORFND: ex      DE,HL           ; Code string address to HL
1445+ 1CD1 0E 08                ld      C,$08
1446+ 1CD3 CD CD 17             call    CHKSTK          ; Check for 8 levels of stack
1447+ 1CD6 E5                   push    HL              ; Save code string address
1448+ 1CD7 2A 4D 55             ld      HL,(LOOPST)     ; Get first statement of loop
1449+ 1CDA E3                   ex      (SP),HL         ; Save and restore code string
1450+ 1CDB E5                   push    HL              ; Re-save code string address
1451+ 1CDC 2A 29 54             ld      HL,(LINEAT)     ; Get current line number
1452+ 1CDF E3                   ex      (SP),HL         ; Save and restore code string
1453+ 1CE0 CD ED 21             call    TSTNUM          ; Make sure it's a number
1454+ 1CE3 CD 10 1B             call    CHKSYN          ; Make sure "TO" is next
1455+ 1CE6 BB                   defb    ZTO             ; "TO" token
1456+ 1CE7 CD EA 21             call    GETNUM          ; Get "TO" expression value
1457+ 1CEA E5                   push    HL              ; Save code string address
1458+ 1CEB CD 43 30             call    BCDEFP          ; Move "TO" value to BCDE
1459+ 1CEE E1                   pop     HL              ; Restore code string address
1460+ 1CEF C5                   push    BC              ; Save "TO" value in block
1461+ 1CF0 D5                   push    DE
1462+ 1CF1 01 00 81             ld      BC,$8100        ; BCDE - 1 (default STEP)
1463+ 1CF4 51                   ld      D,C             ; C=0
1464+ 1CF5 5A                   ld      E,D             ; D=0
1465+ 1CF6 7E                   ld      A,(HL)          ; Get next byte in code string
1466+ 1CF7 FE C0                cp      ZSTEP           ; See if "STEP" is stated
1467+ 1CF9 3E 01                ld      A,$01           ; Sign of step = 1
1468+ 1CFB C2 0C 1D             jp      NZ,SAVSTP       ; No STEP given - Default to 1
1469+ 1CFE CD 59 1D             call    GETCHR          ; Jump over "STEP" token
1470+ 1D01 CD EA 21             call    GETNUM          ; Get step value
1471+ 1D04 E5                   push    HL              ; Save code string address
1472+ 1D05 CD 43 30             call    BCDEFP          ; Move STEP to BCDE
1473+ 1D08 CD F7 2F             call    TSTSGN          ; Test sign of FPREG
1474+ 1D0B E1                   pop     HL              ; Restore code string address
1475+ 1D0C C5           SAVSTP: push    BC              ; Save the STEP value in block
1476+ 1D0D D5                   push    DE
1477+ 1D0E F5                   push    AF              ; Save sign of STEP
1478+ 1D0F 33                   inc     SP              ; Don't save flags
1479+ 1D10 E5                   push    HL              ; Save code string address
1480+ 1D11 2A 54 55             ld      HL,(BRKLIN)     ; Get address of index variable
1481+ 1D14 E3                   ex      (SP),HL         ; Save and restore code string
1482+ 1D15 06 81        PUTFID: ld      B,ZFOR          ; "FOR" block marker
1483+ 1D17 C5                   push    BC              ; Save it
1484+ 1D18 33                   inc     SP              ; Don't save C
1485+ 1D19
1486+ 1D19 CD 84 1D     RUNCNT: call    TSTBRK          ; Execution driver - Test break
1487+ 1D1C 22 54 55             ld      (BRKLIN),HL     ; Save code address for break
1488+ 1D1F 7E                   ld      A,(HL)          ; Get next byte in code string
1489+ 1D20 FE 3A                cp      ':'             ; Multi statement line?
1490+ 1D22 CA 39 1D             jp      Z,EXCUTE        ; Yes - Execute it
1491+ 1D25 B7                   or      A               ; End of line?
1492+ 1D26 C2 10 18             jp      NZ,SNERR        ; No - Syntax error
1493+ 1D29 23                   inc     HL              ; Point to address of next line
1494+ 1D2A 7E                   ld      A,(HL)          ; Get LSB of line pointer
1495+ 1D2B 23                   inc     HL
1496+ 1D2C B6                   or      (HL)            ; Is it zero (End of prog)?
1497+ 1D2D CA AB 1D             jp      Z,ENDPRG        ; Yes - Terminate execution
1498+ 1D30 23                   inc     HL              ; Point to line number
1499+ 1D31 5E                   ld      E,(HL)          ; Get LSB of line number
1500+ 1D32 23                   inc     HL
1501+ 1D33 56                   ld      D,(HL)          ; Get MSB of line number
1502+ 1D34 EB                   ex      DE,HL           ; Line number to HL
1503+ 1D35 22 29 54             ld      (LINEAT),HL     ; Save as current line number
1504+ 1D38 EB                   ex      DE,HL           ; Line number back to DE
1505+ 1D39 CD 59 1D     EXCUTE: call    GETCHR          ; Get key word
1506+ 1D3C 11 19 1D             ld      DE,RUNCNT       ; Where to RETurn to
1507+ 1D3F D5                   push    DE              ; Save for RETurn
1508+ 1D40 C8           IFJMP:  ret     Z               ; Go to RUNCNT if end of STMT
1509+ 1D41
1510+ 1D41 D6 80        ONJMP:  sub     ZEND            ; Is it a token?
1511+ 1D43 DA 19 1F             jp      C,LET           ; No - try to assign it
1512+ 1D46 FE 3A                cp      ZNEW+1-ZEND     ; END to NEW ?
1513+ 1D48 D2 10 18             jp      NC,SNERR        ; Not a key word - ?SN Error
1514+ 1D4B 07                   rlca                    ; Double it
1515+ 1D4C 4F                   ld      C,A             ; BC = Offset into table
1516+ 1D4D 06 00                ld      B,0
1517+ 1D4F EB                   ex      DE,HL           ; Save code string address
1518+ 1D50 21 17 16             ld      HL,WORDTB       ; Keyword address table
1519+ 1D53 09                   add     HL,BC           ; Point to routine address
1520+ 1D54 4E                   ld      C,(HL)          ; Get LSB of routine address
1521+ 1D55 23                   inc     HL
1522+ 1D56 46                   ld      B,(HL)          ; Get MSB of routine address
1523+ 1D57 C5                   push    BC              ; Save routine address
1524+ 1D58 EB                   ex      DE,HL           ; Restore code string address
1525+ 1D59
1526+ 1D59              ; get a char from input buffer: exit with NC if character found is
1527+ 1D59              ; not a number; exit with Z if nothing found; char is into A
1528+ 1D59 23           GETCHR: inc     HL              ; Point to next character
1529+ 1D5A 7E                   ld      A,(HL)          ; Get next code string byte
1530+ 1D5B FE 3A                cp      ':'             ; Z if ':'
1531+ 1D5D D0                   ret     NC              ; NC if > "9"
1532+ 1D5E FE 20                cp      SPC
1533+ 1D60 CA 59 1D             jp      Z,GETCHR        ; Skip over spaces
1534+ 1D63 FE 30                cp      '0'
1535+ 1D65 3F                   ccf                     ; NC if < '0'
1536+ 1D66 3C                   inc     A               ; Test for zero - Leave carry
1537+ 1D67 3D                   dec     A               ; Z if Null
1538+ 1D68 C9                   ret
1539+ 1D69
1540+ 1D69 EB           RESTOR: ex      DE,HL           ; Save code string address
1541+ 1D6A 2A AF 54             ld      HL,(BASTXT)     ; Point to start of program
1542+ 1D6D CA 7E 1D             jp      Z,RESTNL        ; Just RESTORE - reset pointer
1543+ 1D70 EB                   ex      DE,HL           ; Restore code string address
1544+ 1D71 CD 29 1E             call    ATOH            ; Get line number to DE
1545+ 1D74 E5                   push    HL              ; Save code string address
1546+ 1D75 CD 2C 19             call    SRCHLN          ; Search for line number in DE
1547+ 1D78 60                   ld      H,B             ; HL = Address of line
1548+ 1D79 69                   ld      L,C
1549+ 1D7A D1                   pop     DE              ; Restore code string address
1550+ 1D7B D2 D8 1E             jp      NC,ULERR        ; ?UL Error if not found
1551+ 1D7E 2B           RESTNL: dec     HL              ; Byte before DATA statement
1552+ 1D7F 22 C8 55     UPDATA: ld      (NXTDAT),HL     ; Update DATA pointer
1553+ 1D82 EB                   ex      DE,HL           ; Restore code string address
1554+ 1D83 C9                   ret
1555+ 1D84
1556+ 1D84
1557+ 1D84              ; check if CTRL-C is into input buffer
1558+ 1D84 DF           TSTBRK: rst     $18             ; Check input status
1559+ 1D85 C8                   ret     Z               ; No key, go back
1560+ 1D86 D7                   rst     $10             ; Get the key into A
1561+ 1D87 FE 1B                cp      ESC             ; Escape key?
1562+ 1D89 28 11                jr      Z,BRK           ; Yes, break
1563+ 1D8B FE 03                cp      CTRLC           ; <Ctrl-C>
1564+ 1D8D 28 0D                jr      Z,BRK           ; Yes, break
1565+ 1D8F FE 13                cp      CTRLS           ; Stop scrolling?
1566+ 1D91 C0                   ret     NZ              ; Other key, ignore
1567+ 1D92
1568+ 1D92
1569+ 1D92              ; wait for a key while listing
1570+ 1D92 D7           STALL:  rst     $10             ; Wait for key
1571+ 1D93 FE 11                cp      CTRLQ           ; Resume scrolling?
1572+ 1D95 C8                   ret     Z               ; Release the chokehold
1573+ 1D96 FE 03                cp      CTRLC           ; Second break?
1574+ 1D98 28 07                jr      Z,STOP          ; Break during hold exits prog
1575+ 1D9A 18 F6                jr      STALL           ; Loop until <Ctrl-Q> or <brk>
1576+ 1D9C
1577+ 1D9C 3E FF        BRK:    ld      A,$FF           ; Set BRKFLG
1578+ 1D9E 32 23 54             ld      (BRKFLG),A      ; Store it
1579+ 1DA1
1580+ 1DA1 C0           STOP:   ret     NZ              ; Exit if anything else
1581+ 1DA2 F6                   defb    $F6             ; Flag "STOP"
1582+ 1DA3 C0           PEND:   ret     NZ              ; Exit if anything else
1583+ 1DA4 22 54 55             ld      (BRKLIN),HL     ; Save point of break
1584+ 1DA7 21                   defb    $21             ; Skip "OR 11111111B"
1585+ 1DA8 F6 FF        INPBRK: or      %11111111       ; Flag "Break" wanted
1586+ 1DAA C1                   pop     BC              ; Return not needed and more
1587+ 1DAB 2A 29 54     ENDPRG: ld      HL,(LINEAT)     ; Get current line number
1588+ 1DAE F5                   push    AF              ; Save STOP / END status
1589+ 1DAF 7D                   ld      A,L             ; Is it direct break?
1590+ 1DB0 A4                   and     H
1591+ 1DB1 3C                   inc     A               ; Line is -1 if direct break
1592+ 1DB2 CA BE 1D             jp      Z,NOLIN         ; Yes - No line number
1593+ 1DB5 22 58 55             ld      (ERRLIN),HL     ; Save line of break
1594+ 1DB8 2A 54 55             ld      HL,(BRKLIN)     ; Get point of break
1595+ 1DBB 22 5A 55             ld      (CONTAD),HL     ; Save point to CONTinue
1596+ 1DBE AF           NOLIN:  xor     A
1597+ 1DBF 32 1F 54             ld      (CTLOFG),A      ; Enable output
1598+ 1DC2 CD 14 20             call    STTLIN          ; Start a new line
1599+ 1DC5 F1                   pop     AF              ; Restore STOP / END status
1600+ 1DC6 21 93 17             ld      HL,BRKMSG       ; "Break" message
1601+ 1DC9 C2 CF 1D             jp      NZ,ERRINT       ; "in line" wanted?
1602+ 1DCC C3 70 18             jp      PRNTOK          ; Go to command mode
1603+ 1DCF CD EA 17     ERRINT: call    EXITGM          ; exit from graphics mode
1604+ 1DD2 C3 4E 18             jp      ERRIN           ; print message
1605+ 1DD5
1606+ 1DD5
1607+ 1DD5              ; CONTinue after a break/error
1608+ 1DD5 21 FF FF     CONT:   ld      HL,-1           ; reset...
1609+ 1DD8 22 2B 54             ld      (HLPLN),HL      ; ...HELP line register
1610+ 1DDB 2A 5A 55             ld      HL,(CONTAD)     ; Get CONTinue address
1611+ 1DDE 7C                   ld      A,H             ; Is it zero?
1612+ 1DDF B5                   or      L
1613+ 1DE0 1E 20                ld      E,CN            ; ?CN Error
1614+ 1DE2 CA 2A 18             jp      Z,ERROR         ; Yes - output "?CN Error"
1615+ 1DE5 EB                   ex      DE,HL           ; Save code string address
1616+ 1DE6 2A 58 55             ld      HL,(ERRLIN)     ; Get line of last break
1617+ 1DE9 22 29 54             ld      (LINEAT),HL     ; Set up current line number
1618+ 1DEC EB                   ex      DE,HL           ; Restore code string address
1619+ 1DED C9                   ret                     ; CONTinue where left off
1620+ 1DEE
1621+ 1DEE E5           ACCSUM: push    HL              ; Save address in array
1622+ 1DEF 2A 20 54             ld      HL,(CHKSUM)     ; Get check sum
1623+ 1DF2 06 00                ld      B,$00           ; BC - Value of byte
1624+ 1DF4 4F                   ld      C,A
1625+ 1DF5 09                   add     HL,BC           ; Add byte to check sum
1626+ 1DF6 22 20 54             ld      (CHKSUM),HL     ; Re-save check sum
1627+ 1DF9 E1                   pop     HL              ; Restore address in array
1628+ 1DFA C9                   ret
1629+ 1DFB
1630+ 1DFB 7E           CHKLTR: ld      A,(HL)          ; Get byte
1631+ 1DFC FE 41                cp      'A'             ; < 'a' ?
1632+ 1DFE D8                   ret     C               ; Carry set if not letter
1633+ 1DFF FE 5B                cp      'Z'+1           ; > 'z' ?
1634+ 1E01 3F                   ccf
1635+ 1E02 C9                   ret                     ; Carry set if not letter
1636+ 1E03
1637+ 1E03 CD 59 1D     FPSINT: call    GETCHR          ; Get next character
1638+ 1E06 CD EA 21     POSINT: call    GETNUM          ; Get integer 0 to 32767
1639+ 1E09 CD F7 2F     DEPINT: call    TSTSGN          ; Test sign of FPREG
1640+ 1E0C FA 24 1E             jp      M,FCERR         ; Negative - ?FC Error
1641+ 1E0F 3A D3 55     DEINT:  ld      A,(FPEXP)       ; Get integer value to DE
1642+ 1E12 FE 90                cp      $80+$10         ; Exponent in range (16 bits)?
1643+ 1E14 DA 9F 30             jp      C,FPINT         ; Yes - convert it
1644+ 1E17 01 80 90             ld      BC,$9080        ; BCDE = -32768
1645+ 1E1A 11 00 00             ld      DE,$0000
1646+ 1E1D E5                   push    HL              ; Save code string address
1647+ 1E1E CD 72 30             call    CMPNUM          ; Compare FPREG with BCDE
1648+ 1E21 E1                   pop     HL              ; Restore code string address
1649+ 1E22 51                   ld      D,C             ; MSB to D
1650+ 1E23 C8                   ret     Z               ; Return if in range
1651+ 1E24 1E 08        FCERR:  ld      E,FC            ; ?FC Error
1652+ 1E26 C3 2A 18             jp      ERROR           ; Output error-
1653+ 1E29
1654+ 1E29
1655+ 1E29              ; convert a number in ASCII chars into an integer and store it into DE
1656+ 1E29 2B           ATOH:   dec     HL              ; ASCII number to DE binary
1657+ 1E2A 11 00 00     GETLN:  ld      DE,$0000        ; Get number to DE
1658+ 1E2D CD 59 1D     GTLNLP: call    GETCHR          ; Get next character
1659+ 1E30 D0                   ret     NC              ; Exit if not a digit
1660+ 1E31 E5                   push    HL              ; Save code string address
1661+ 1E32 F5                   push    AF              ; Save digit
1662+ 1E33 21 98 19             ld      HL,65529/10     ; Largest number 65529
1663+ 1E36 CD 0A 1B             call    CPDEHL          ; Number in range?
1664+ 1E39 DA 10 18             jp      C,SNERR         ; No - ?SN Error
1665+ 1E3C 62                   ld      H,D             ; HL = Number
1666+ 1E3D 6B                   ld      L,E
1667+ 1E3E 19                   add     HL,DE           ; Times 2
1668+ 1E3F 29                   add     HL,HL           ; Times 4
1669+ 1E40 19                   add     HL,DE           ; Times 5
1670+ 1E41 29                   add     HL,HL           ; Times 10
1671+ 1E42 F1                   pop     AF              ; Restore digit
1672+ 1E43 D6 30                sub     '0'             ; Make it 0 to 9
1673+ 1E45 5F                   ld      E,A             ; DE = Value of digit
1674+ 1E46 16 00                ld      D,0
1675+ 1E48 19                   add     HL,DE           ; Add to number
1676+ 1E49 EB                   ex      DE,HL           ; Number to DE
1677+ 1E4A E1                   pop     HL              ; Restore code string address
1678+ 1E4B C3 2D 1E             jp      GTLNLP          ; Go to next character
1679+ 1E4E
1680+ 1E4E CA 5C 19     CLEAR:  jp      Z,INTVAR        ; Just "CLEAR" Keep parameters
1681+ 1E51 CD EA 21             call    GETNUM          ; Evaluate a number
1682+ 1E54 CD 0F 1E             call    DEINT           ; Get integer -32768 to 32767 into DE
1683+ 1E57 2B                   dec     HL              ; Cancel increment
1684+ 1E58 CD 59 1D             call    GETCHR          ; Get next character
1685+ 1E5B E5                   push    HL              ; Save code string address
1686+ 1E5C 2A 10 55             ld      HL,(LSTRAM)     ; Get end of RAM
1687+ 1E5F CA 77 1E             jp      Z,STORED        ; No value given - Use stored
1688+ 1E62 E1                   pop     HL              ; Restore code string address
1689+ 1E63 CD 10 1B             call    CHKSYN          ; Check for comma
1690+ 1E66 2C                   defb    ','
1691+ 1E67 D5                   push    DE              ; Save number
1692+ 1E68 CD EA 21             call    GETNUM          ; Evaluate a number
1693+ 1E6B CD 0F 1E             call    DEINT           ; Get integer -32768 to 32767 into DE
1694+ 1E6E 2B                   dec     HL              ; Cancel increment
1695+ 1E6F CD 59 1D             call    GETCHR          ; Get next character
1696+ 1E72 C2 10 18             jp      NZ,SNERR        ; ?SN Error if more on line
1697+ 1E75 E3                   ex      (SP),HL         ; Save code string address
1698+ 1E76 EB                   ex      DE,HL           ; Number to DE
1699+ 1E77 7D           STORED: ld      A,L             ; Get LSB of new RAM top
1700+ 1E78 93                   sub     E               ; Subtract LSB of string space
1701+ 1E79 5F                   ld      E,A             ; Save LSB
1702+ 1E7A 7C                   ld      A,H             ; Get MSB of new RAM top
1703+ 1E7B 9A                   sbc     A,D             ; Subtract MSB of string space
1704+ 1E7C 57                   ld      D,A             ; Save MSB
1705+ 1E7D DA E5 17             jp      C,OMERR         ; ?OM Error if not enough mem
1706+ 1E80 E5                   push    HL              ; Save RAM top
1707+ 1E81 2A C2 55             ld      HL,(PROGND)     ; Get program end
1708+ 1E84 01 28 00             ld      BC,$28          ; 40 Bytes minimum working RAM
1709+ 1E87 09                   add     HL,BC           ; Get lowest address
1710+ 1E88 CD 0A 1B             call    CPDEHL          ; Enough memory?
1711+ 1E8B D2 E5 17             jp      NC,OMERR        ; No - ?OM Error
1712+ 1E8E EB                   ex      DE,HL           ; RAM top to HL
1713+ 1E8F 22 27 54             ld      (STRSPC),HL     ; Set new string space
1714+ 1E92 E1                   pop     HL              ; End of memory to use
1715+ 1E93 22 10 55             ld      (LSTRAM),HL     ; Set new top of RAM
1716+ 1E96 E1                   pop     HL              ; Restore code string address
1717+ 1E97 C3 5C 19             jp      INTVAR          ; Initialise variables
1718+ 1E9A
1719+ 1E9A E5           RUN:    push    HL              ; store HL
1720+ 1E9B 21 FF FF             ld      HL,-1           ; reset...
1721+ 1E9E 22 2B 54             ld      (HLPLN),HL      ; ...HELP line register
1722+ 1EA1 E1                   pop     HL              ; retrieve HL
1723+ 1EA2 CA 58 19             jp      Z,RUNFST        ; RUN from start if just RUN
1724+ 1EA5 CD 5C 19             call    INTVAR          ; Initialise variables
1725+ 1EA8 01 19 1D             ld      BC,RUNCNT       ; Execution driver loop
1726+ 1EAB C3 BE 1E             jp      RUNLIN          ; RUN from line number
1727+ 1EAE
1728+ 1EAE 0E 03        GOSUB:  ld      C,$03           ; 3 Levels of stack needed
1729+ 1EB0 CD CD 17             call    CHKSTK          ; Check for 3 levels of stack
1730+ 1EB3 C1                   pop     BC              ; Get return address
1731+ 1EB4 E5                   push    HL              ; Save code string for RETURN
1732+ 1EB5 E5                   push    HL              ; And for GOSUB routine
1733+ 1EB6 2A 29 54             ld      HL,(LINEAT)     ; Get current line
1734+ 1EB9 E3                   ex      (SP),HL         ; Into stack - Code string out
1735+ 1EBA 3E 8C                ld      A,ZGOSUB        ; "GOSUB" token
1736+ 1EBC F5                   push    AF              ; Save token
1737+ 1EBD 33                   inc     SP              ; Don't save flags
1738+ 1EBE
1739+ 1EBE C5           RUNLIN: push    BC              ; Save return address
1740+ 1EBF CD 29 1E     GOTO:   call    ATOH            ; ASCII number to DE binary
1741+ 1EC2 CD 04 1F             call    REM             ; Get end of line
1742+ 1EC5 E5                   push    HL              ; Save end of line
1743+ 1EC6 2A 29 54             ld      HL,(LINEAT)     ; Get current line
1744+ 1EC9 CD 0A 1B             call    CPDEHL          ; Line after current?
1745+ 1ECC E1                   pop     HL              ; Restore end of line
1746+ 1ECD 23                   inc     HL              ; Start of next line
1747+ 1ECE DC 2F 19             call    C,SRCHLP        ; Line is after current line
1748+ 1ED1 D4 2C 19             call    NC,SRCHLN       ; Line is before current line
1749+ 1ED4 60                   ld      H,B             ; Set up code string address
1750+ 1ED5 69                   ld      L,C
1751+ 1ED6 2B                   dec     HL              ; Incremented after
1752+ 1ED7 D8                   ret     C               ; Line found
1753+ 1ED8 1E 0E        ULERR:  ld      E,UL            ; ?UL Error
1754+ 1EDA C3 2A 18             jp      ERROR           ; Output error message
1755+ 1EDD
1756+ 1EDD C0           RETURN: ret     NZ              ; Return if not just RETURN
1757+ 1EDE 16 FF                ld      D,-1            ; Flag "GOSUB" search
1758+ 1EE0 CD 99 17             call    BAKSTK          ; Look "GOSUB" block
1759+ 1EE3 F9                   ld      SP,HL           ; Kill all FORs in subroutine
1760+ 1EE4 FE 8C                cp      ZGOSUB          ; Test for "GOSUB" token
1761+ 1EE6 1E 04                ld      E,RG            ; ?RG Error
1762+ 1EE8 C2 2A 18             jp      NZ,ERROR        ; Error if no "GOSUB" found
1763+ 1EEB E1                   pop     HL              ; Get RETURN line number
1764+ 1EEC 22 29 54             ld      (LINEAT),HL     ; Save as current
1765+ 1EEF 23                   inc     HL              ; Was it from direct statement?
1766+ 1EF0 7C                   ld      A,H
1767+ 1EF1 B5                   or      L               ; Return to line
1768+ 1EF2 C2 FC 1E             jp      NZ,RETLIN       ; No - Return to line
1769+ 1EF5 3A 52 55             ld      A,(LSTBIN)      ; Any INPUT in subroutine?
1770+ 1EF8 B7                   or      A               ; If so buffer is corrupted
1771+ 1EF9 C2 6F 18             jp      NZ,POPNOK       ; Yes - Go to command mode
1772+ 1EFC 21 19 1D     RETLIN: ld      HL,RUNCNT       ; Execution driver loop
1773+ 1EFF E3                   ex      (SP),HL         ; Into stack - Code string out
1774+ 1F00 3E                   defb    $3E             ; Skip "pop HL"
1775+ 1F01 E1           NXTDTA: pop     HL              ; Restore code string address
1776+ 1F02
1777+ 1F02 01 3A        DATA:   defb    $01,$3A         ; ':' End of statement (stands for LD BC,$0E3A - NOP)
1778+ 1F04 0E 00        REM:    ld      C,$00           ; 00  End of statement
1779+ 1F06 06 00                ld      B,$00
1780+ 1F08 79           NXTSTL: ld      A,C             ; Statement and byte
1781+ 1F09 48                   ld      C,B
1782+ 1F0A 47                   ld      B,A             ; Statement end byte
1783+ 1F0B 7E           NXTSTT: ld      A,(HL)          ; Get byte
1784+ 1F0C B7                   or      A               ; End of line?
1785+ 1F0D C8                   ret     Z               ; Yes - Exit
1786+ 1F0E B8                   cp      B               ; End of statement?
1787+ 1F0F C8                   ret     Z               ; Yes - Exit
1788+ 1F10 23                   inc     HL              ; Next byte
1789+ 1F11 FE 22                cp      $22             ; '"'             ; Literal string?
1790+ 1F13 CA 08 1F             jp      Z,NXTSTL        ; Yes - Look for another '"'
1791+ 1F16 C3 0B 1F             jp      NXTSTT          ; Keep looking
1792+ 1F19
1793+ 1F19 CD F9 23     LET:    call    GETVAR          ; Get variable name
1794+ 1F1C CD 10 1B             call    CHKSYN          ; Make sure "=" follows
1795+ 1F1F CC                   defb    ZEQUAL          ; "=" token
1796+ 1F20 D5                   push    DE              ; Save address of variable
1797+ 1F21 3A 0E 55             ld      A,(TYPE)        ; Get data type
1798+ 1F24 F5                   push    AF              ; Save type
1799+ 1F25 CD FC 21             call    EVAL            ; Evaluate expression
1800+ 1F28 F1                   pop     AF              ; Restore type
1801+ 1F29 E3                   ex      (SP),HL         ; Save code - Get var addr
1802+ 1F2A 22 54 55             ld      (BRKLIN),HL     ; Save address of variable
1803+ 1F2D 1F                   rra                     ; Adjust type
1804+ 1F2E CD EF 21             call    CHKTYP          ; Check types are the same
1805+ 1F31 CA 6C 1F             jp      Z,LETNUM        ; Numeric - Move value
1806+ 1F34 E5           LETSTR: push    HL              ; Save address of string var
1807+ 1F35 2A D0 55             ld      HL,(FPREG)      ; Pointer to string entry
1808+ 1F38 E5                   push    HL              ; Save it on stack
1809+ 1F39 23                   inc     HL              ; Skip over length
1810+ 1F3A 23                   inc     HL
1811+ 1F3B 5E                   ld      E,(HL)          ; LSB of string address
1812+ 1F3C 23                   inc     HL
1813+ 1F3D 56                   ld      D,(HL)          ; MSB of string address
1814+ 1F3E 2A AF 54             ld      HL,(BASTXT)     ; Point to start of program
1815+ 1F41 CD 0A 1B             call    CPDEHL          ; Is string before program?
1816+ 1F44 D2 5B 1F             jp      NC,CRESTR       ; Yes - Create string entry
1817+ 1F47 2A 27 54             ld      HL,(STRSPC)     ; Point to string space
1818+ 1F4A CD 0A 1B             call    CPDEHL          ; Is string literal in program?
1819+ 1F4D D1                   pop     DE              ; Restore address of string
1820+ 1F4E D2 63 1F             jp      NC,MVSTPT       ; Yes - Set up pointer
1821+ 1F51 21 45 55             ld      HL,TMPSTR       ; Temporary string pool
1822+ 1F54 CD 0A 1B             call    CPDEHL          ; Is string in temporary pool?
1823+ 1F57 D2 63 1F             jp      NC,MVSTPT       ; No - Set up pointer
1824+ 1F5A 3E                   defb    $3E             ; Skip "pop DE"
1825+ 1F5B D1           CRESTR: pop     DE              ; Restore address of string
1826+ 1F5C CD 53 28             call    BAKTMP          ; Back to last tmp-str entry
1827+ 1F5F EB                   ex      DE,HL           ; Address of string entry
1828+ 1F60 CD 8C 26             call    SAVSTR          ; Save string in string area
1829+ 1F63 CD 53 28     MVSTPT: call    BAKTMP          ; Back to last tmp-str entry
1830+ 1F66 E1                   pop     HL              ; Get string pointer
1831+ 1F67 CD 52 30             call    DETHL4          ; Move string pointer to var
1832+ 1F6A E1                   pop     HL              ; Restore code string address
1833+ 1F6B C9                   ret
1834+ 1F6C
1835+ 1F6C E5           LETNUM: push    HL              ; Save address of variable
1836+ 1F6D CD 4F 30             call    FPTHL           ; Move value to variable
1837+ 1F70 D1                   pop     DE              ; Restore address of variable
1838+ 1F71 E1                   pop     HL              ; Restore code string address
1839+ 1F72 C9                   ret
1840+ 1F73
1841+ 1F73 CD 70 2A     ON:     call    GETINT          ; Get integer 0-255
1842+ 1F76 7E                   ld      A,(HL)          ; Get "GOTO" or "GOSUB" token
1843+ 1F77 47                   ld      B,A             ; Save in B
1844+ 1F78 FE 8C                cp      ZGOSUB          ; "GOSUB" token?
1845+ 1F7A CA 82 1F             jp      Z,ONGO          ; Yes - Find line number
1846+ 1F7D CD 10 1B             call    CHKSYN          ; Make sure it's "GOTO"
1847+ 1F80 88                   defb    ZGOTO           ; "GOTO" token
1848+ 1F81 2B                   dec     HL              ; Cancel increment
1849+ 1F82 4B           ONGO:   ld      C,E             ; Integer of branch value
1850+ 1F83 0D           ONGOLP: dec     C               ; Count branches
1851+ 1F84 78                   ld      A,B             ; Get "GOTO" or "GOSUB" token
1852+ 1F85 CA 41 1D             jp      Z,ONJMP         ; Go to that line if right one
1853+ 1F88 CD 2A 1E             call    GETLN           ; Get line number to DE
1854+ 1F8B FE 2C                cp      ','             ; Another line number?
1855+ 1F8D C0                   ret     NZ              ; No - Drop through
1856+ 1F8E C3 83 1F             jp      ONGOLP          ; Yes - loop
1857+ 1F91
1858+ 1F91 CD FC 21     IF:     call    EVAL            ; Evaluate expression
1859+ 1F94 7E                   ld      A,(HL)          ; Get token
1860+ 1F95 FE 88                cp      ZGOTO           ; "GOTO" token?
1861+ 1F97 CA 9F 1F             jp      Z,IFGO          ; Yes - Get line
1862+ 1F9A CD 10 1B             call    CHKSYN          ; Make sure it's "THEN"
1863+ 1F9D BE                   defb    ZTHEN           ; "THEN" token
1864+ 1F9E 2B                   dec     HL              ; Cancel increment
1865+ 1F9F CD ED 21     IFGO:   call    TSTNUM          ; Make sure it's numeric
1866+ 1FA2 CD F7 2F             call    TSTSGN          ; Test state of expression
1867+ 1FA5 CA B1 1F             jp      Z,IF1           ; False - Jump over
1868+ 1FA8 CD 59 1D     IF0:    call    GETCHR          ; Get next character
1869+ 1FAB DA BF 1E             jp      C,GOTO          ; Number - GOTO that line
1870+ 1FAE C3 40 1D             jp      IFJMP           ; Otherwise do statement
1871+ 1FB1 0E B2        IF1:    ld      C,ZELSE
1872+ 1FB3 CD 06 1F             call    REM+2           ; check statement
1873+ 1FB6 B7                   or      A               ; end of line?
1874+ 1FB7 C8                   ret     Z               ; yes, leave
1875+ 1FB8 FE B2                cp      ZELSE
1876+ 1FBA 20 F5                jr      NZ,IF1          ; ELSE not found, continue check
1877+ 1FBC C3 A8 1F             jp      IF0             ; return to IF
1878+ 1FBF
1879+ 1FBF
1880+ 1FBF 2B           MRPRNT: dec     HL              ; dec 'cos GETCHR INCs
1881+ 1FC0 CD 59 1D             call    GETCHR          ; Get next character
1882+ 1FC3 CA 26 20     PRINT:  jp      Z,PRNTCRLF      ; CRLF if just PRINT
1883+ 1FC6 C8           PRNTLP: ret     Z               ; End of list - Exit
1884+ 1FC7 FE BA                cp      ZTAB            ; "TAB(" token?
1885+ 1FC9 CA 4E 20             jp      Z,DOTAB         ; Yes - Do TAB routine
1886+ 1FCC FE BD                cp      ZSPC            ; "SPC(" token?
1887+ 1FCE CA 4E 20             jp      Z,DOTAB         ; Yes - Do SPC routine
1888+ 1FD1 E5                   push    HL              ; Save code string address
1889+ 1FD2 FE 2C                cp      ','             ; Comma?
1890+ 1FD4 CA 35 20             jp      Z,DOCOM         ; Yes - Move to next zone
1891+ 1FD7 FE 3B                cp      ';'             ; Semi-colon?
1892+ 1FD9 CA 72 20             jp      Z,NEXITM        ; Do semi-colon routine
1893+ 1FDC C1                   pop     BC              ; Code string address to BC
1894+ 1FDD CD FC 21             call    EVAL            ; Evaluate expression
1895+ 1FE0 E5                   push    HL              ; Save code string address
1896+ 1FE1 3A 0E 55             ld      A,(TYPE)        ; Get variable type
1897+ 1FE4 B7                   or      A               ; Is it a string variable?
1898+ 1FE5 C2 0D 20             jp      NZ,PRNTST       ; Yes - Output string contents
1899+ 1FE8 CD 9C 31             call    NUMASC          ; Convert number to text
1900+ 1FEB CD B0 26             call    CRTST           ; Create temporary string
1901+ 1FEE 36 00                ld      (HL),NLLCR      ; Followed by a NULL char (was SPC, space)
1902+ 1FF0 2A D0 55             ld      HL,(FPREG)      ; Get length of output
1903+ 1FF3 34                   inc     (HL)            ; Plus 1 for the space
1904+ 1FF4 2A D0 55             ld      HL,(FPREG)      ; < Not needed >
1905+ 1FF7 3A 1C 54             ld      A,(LWIDTH)      ; Get width of line
1906+ 1FFA 47                   ld      B,A             ; To B
1907+ 1FFB 04                   inc     B               ; Width 255 (No limit)?
1908+ 1FFC CA 09 20             jp      Z,PRNTNB        ; Yes - Output number string
1909+ 1FFF 04                   inc     B               ; Adjust it
1910+ 2000 3A 0C 55             ld      A,(CURPOS)      ; Get cursor position
1911+ 2003 86                   add     A,(HL)          ; Add length of string
1912+ 2004 3D                   dec     A               ; Adjust it
1913+ 2005 B8                   cp      B               ; Will output fit on this line?
1914+ 2006 D4 26 20             call    NC,PRNTCRLF     ; No - CRLF first
1915+ 2009 CD F5 26     PRNTNB: call    PRS1            ; Output string at (HL)
1916+ 200C AF                   xor     A               ; Skip call by setting 'z' flag
1917+ 200D C4 F5 26     PRNTST: call    NZ,PRS1         ; Output string at (HL)
1918+ 2010 E1                   pop     HL              ; Restore code string address
1919+ 2011 C3 BF 1F             jp      MRPRNT          ; See if more to PRINT
1920+ 2014
1921+ 2014 3A 0C 55     STTLIN: ld      A,(CURPOS)      ; Make sure on new line
1922+ 2017 B7                   or      A               ; Already at start?
1923+ 2018 C8                   ret     Z               ; Yes - Do nothing
1924+ 2019 C3 26 20             jp      PRNTCRLF        ; Start a new line
1925+ 201C
1926+ 201C AF           ENDINP: xor     A
1927+ 201D 32 B6 55             ld      (KBDNPT),A      ; char is not from keyboard
1928+ 2020 77                   ld      (HL),A          ; Mark end of buffer
1929+ 2021 21 B1 54             ld      HL,BUFFER-1     ; Point to buffer
1930+ 2024 18 0A                jr      CNTEND
1931+ 2026 3E 0D        PRNTCRLF:ld     A,CR            ; Load a CR
1932+ 2028 CD 1B 1B             call    OUTC            ; Output character
1933+ 202B 3E 0A                ld      A,LF            ; Load a LF
1934+ 202D CD 1B 1B             call    OUTC            ; Output character
1935+ 2030 AF           CNTEND: xor     A               ; Set to position 0
1936+ 2031 32 0C 55             ld      (CURPOS),A      ; Store it
1937+ 2034 C9                   ret                     ; return to caller
1938+ 2035
1939+ 2035 3A 1D 54     DOCOM:  ld      A,(COMMAN)      ; Get comma width
1940+ 2038 47                   ld      B,A             ; Save in B
1941+ 2039 3A 71 55             ld      A,(SCR_CURS_X)  ; Get current position
1942+ 203C B8                   cp      B               ; Within the limit?
1943+ 203D D4 26 20             call    NC,PRNTCRLF     ; No - output CRLF
1944+ 2040 D2 72 20             jp      NC,NEXITM       ; Get next item
1945+ 2043 D6 0A        ZONELP: sub     $0A             ; Next zone of 10 characters
1946+ 2045 D2 43 20             jp      NC,ZONELP       ; Repeat if more zones
1947+ 2048 2F                   cpl                     ; Number of null chars to output
1948+ 2049 0E 00                ld      C,NLLCR         ; null char
1949+ 204B C3 68 20             jp      ASPCS           ; Output them
1950+ 204E
1951+ 204E F5           DOTAB:  push    AF              ; Save token
1952+ 204F CD 6D 2A             call    FNDNUM          ; Evaluate expression
1953+ 2052 CD 10 1B             call    CHKSYN          ; Make sure ")" follows
1954+ 2055 29                   defb    ')'
1955+ 2056 2B                   dec     HL              ; Back space on to ")"
1956+ 2057 F1                   pop     AF              ; Restore token
1957+ 2058 0E 00                ld      C,NLLCR         ; for SPC we use NULL char (was SPACE)
1958+ 205A D6 BD                sub     ZSPC            ; Was it "SPC(" ?
1959+ 205C E5                   push    HL              ; Save code string address
1960+ 205D CA 63 20             jp      Z,DOSPC         ; Yes - Do 'E' spaces
1961+ 2060 3A 71 55             ld      A,(SCR_CURS_X)  ; Get current X position
1962+ 2063 2F           DOSPC:  cpl                     ; Number of spaces to print to
1963+ 2064 83                   add     A,E             ; Total number to print
1964+ 2065 D2 72 20             jp      NC,NEXITM       ; TAB < Current POS(X)
1965+ 2068 3C           ASPCS:  inc     A               ; Output A spaces
1966+ 2069 47                   ld      B,A             ; Save number to print
1967+ 206A 79           SPCLP:  ld      A,C             ; char to print
1968+ 206B CD 1B 1B             call    OUTC            ; Output character in A
1969+ 206E 05                   dec     B               ; Count them
1970+ 206F C2 6A 20             jp      NZ,SPCLP        ; Repeat if more
1971+ 2072 E1           NEXITM: pop     HL              ; Restore code string address
1972+ 2073 CD 59 1D             call    GETCHR          ; Get next character
1973+ 2076 C3 C6 1F             jp      PRNTLP          ; More to print
1974+ 2079
1975+ 2079 3F 52 65 64  REDO:   defb    "?Redo from start",CR,0
1975+ 207D 6F 20 66 72
1975+ 2081 6F 6D 20 73
1975+ 2085 74 61 72 74
1975+ 2089 0D 00
1976+ 208B
1977+ 208B 3A 53 55     BADINP: ld      A,(READFG)      ; READ or INPUT?
1978+ 208E B7                   or      A
1979+ 208F C2 0A 18             jp      NZ,DATSNR       ; READ - ?SN Error
1980+ 2092 C1                   pop     BC              ; Throw away code string addr
1981+ 2093 21 79 20             ld      HL,REDO         ; "Redo from start" message
1982+ 2096 CD F2 26             call    PRS             ; Output string
1983+ 2099 C3 8B 19             jp      DOAGN           ; Do last INPUT again
1984+ 209C
1985+ 209C CD 5D 26     INPUT:  call    IDTEST          ; Test for illegal direct
1986+ 209F 7E                   ld      A,(HL)          ; Get character after "INPUT"
1987+ 20A0 FE 22                cp      $22             ; '"' ; Is there a prompt string?
1988+ 20A2 3E 00                ld      A,$00           ; Clear A and leave flags
1989+ 20A4 32 1F 54             ld      (CTLOFG),A      ; Enable output
1990+ 20A7 C2 B6 20             jp      NZ,NOPMPT       ; No prompt - get input
1991+ 20AA CD B1 26             call    QTSTR           ; Get string terminated by '"'
1992+ 20AD CD 10 1B             call    CHKSYN          ; Check for ';' after prompt
1993+ 20B0 3B                   defb    ";"
1994+ 20B1 E5                   push    HL              ; Save code string address
1995+ 20B2 CD F5 26             call    PRS1            ; Output prompt string
1996+ 20B5 3E                   defb    $3E             ; Skip "push HL"
1997+ 20B6 E5           NOPMPT: push    HL              ; Save code string address
1998+ 20B7 CD 8F 19             call    PROMPT          ; Get input with "? " prompt
1999+ 20BA C1                   pop     BC              ; Restore code string address
2000+ 20BB DA A8 1D             jp      C,INPBRK        ; Break pressed - Exit
2001+ 20BE 23                   inc     HL              ; Next byte
2002+ 20BF 7E                   ld      A,(HL)          ; Get it
2003+ 20C0 B7                   or      A               ; End of line?
2004+ 20C1 2B                   dec     HL              ; Back again
2005+ 20C2 C5                   push    BC              ; Re-save code string address
2006+ 20C3 3A BE 55             ld      A,(SERIALS_EN)  ; load serial state
2007+ 20C6 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
2008+ 20C8 CC 8F 01             call    Z,A_RTS_OFF      ; yes, set RTS on
2009+ 20CB CD 3B 09             call    CURSOR_OFF      ; disable cursor
2010+ 20CE CA 01 1F             jp      Z,NXTDTA        ; Yes - Find next DATA stmt
2011+ 20D1 36 2C                ld      (HL),','        ; Store comma as separator
2012+ 20D3 C3 DB 20             jp      NXTITM          ; Get next item
2013+ 20D6
2014+ 20D6 E5           READ:   push    HL              ; Save code string address
2015+ 20D7 2A C8 55             ld      HL,(NXTDAT)     ; Next DATA statement
2016+ 20DA F6                   defb    $F6             ; Flag "READ"
2017+ 20DB AF           NXTITM: xor     A               ; Flag "INPUT"
2018+ 20DC 32 53 55             ld      (READFG),A      ; Save "READ"/"INPUT" flag
2019+ 20DF E3                   ex      (SP),HL         ; Get code str' , Save pointer
2020+ 20E0 C3 E7 20             jp      GTVLUS          ; Get values
2021+ 20E3
2022+ 20E3 CD 10 1B     NEDMOR: call    CHKSYN          ; Check for comma between items
2023+ 20E6 2C                   defb    ','
2024+ 20E7 CD F9 23     GTVLUS: call    GETVAR          ; Get variable name
2025+ 20EA E3                   ex      (SP),HL         ; Save code str" , Get pointer
2026+ 20EB D5                   push    DE              ; Save variable address
2027+ 20EC 7E                   ld      A,(HL)          ; Get next "INPUT"/"DATA" byte
2028+ 20ED FE 2C                cp      ','             ; Comma?
2029+ 20EF CA 0F 21             jp      Z,ANTVLU        ; Yes - Get another value
2030+ 20F2 3A 53 55             ld      A,(READFG)      ; Is it READ?
2031+ 20F5 B7                   or      A
2032+ 20F6 C2 7B 21             jp      NZ,FDTLP        ; Yes - Find next DATA stmt
2033+ 20F9 3E 3F                ld      A,'?'           ; More INPUT needed
2034+ 20FB CD 1B 1B             call    OUTC            ; Output character
2035+ 20FE CD 8F 19             call    PROMPT          ; Get INPUT with prompt
2036+ 2101 D1                   pop     DE              ; Variable address
2037+ 2102 C1                   pop     BC              ; Code string address
2038+ 2103 DA A8 1D             jp      C,INPBRK        ; Break pressed
2039+ 2106 23                   inc     HL              ; Point to next DATA byte
2040+ 2107 7E                   ld      A,(HL)          ; Get byte
2041+ 2108 B7                   or      A               ; Is it zero (No input) ?
2042+ 2109 2B                   dec     HL              ; Back space INPUT pointer
2043+ 210A C5                   push    BC              ; Save code string address
2044+ 210B CA 01 1F             jp      Z,NXTDTA        ; Find end of buffer
2045+ 210E D5                   push    DE              ; Save variable address
2046+ 210F 3A 0E 55     ANTVLU: ld      A,(TYPE)        ; Check data type
2047+ 2112 B7                   or      A               ; Is it numeric?
2048+ 2113 CA 39 21             jp      Z,INPBIN        ; Yes - Convert to binary
2049+ 2116 CD 59 1D             call    GETCHR          ; Get next character
2050+ 2119 57                   ld      D,A             ; Save input character
2051+ 211A 47                   ld      B,A             ; Again
2052+ 211B FE 22                cp      $22             ; '"'     ; Start of literal sting?
2053+ 211D CA 2D 21             jp      Z,STRENT        ; Yes - Create string entry
2054+ 2120 3A 53 55             ld      A,(READFG)      ; "READ" or "INPUT" ?
2055+ 2123 B7                   or      A
2056+ 2124 57                   ld      D,A             ; Save 00 if "INPUT"
2057+ 2125 CA 2A 21             jp      Z,ITMSEP        ; "INPUT" - End with 00
2058+ 2128 16 3A                ld      D,':'           ; "DATA" - End with 00 or ':'
2059+ 212A 06 2C        ITMSEP: ld      B,','           ; Item separator
2060+ 212C 2B                   dec     HL              ; Back space for DTSTR
2061+ 212D CD B4 26     STRENT: call    DTSTR           ; Get string terminated by D
2062+ 2130 EB                   ex      DE,HL           ; String address to DE
2063+ 2131 21 44 21             ld      HL,LTSTND       ; Where to go after LETSTR
2064+ 2134 E3                   ex      (SP),HL         ; Save HL , get input pointer
2065+ 2135 D5                   push    DE              ; Save address of string
2066+ 2136 C3 34 1F             jp      LETSTR          ; Assign string to variable
2067+ 2139
2068+ 2139 CD 59 1D     INPBIN: call    GETCHR          ; Get next character
2069+ 213C CD FE 30             call    ASCTFP          ; Convert ASCII to FP number
2070+ 213F E3                   ex      (SP),HL         ; Save input ptr, Get var addr
2071+ 2140 CD 4F 30             call    FPTHL           ; Move FPREG to variable
2072+ 2143 E1                   pop     HL              ; Restore input pointer
2073+ 2144 2B           LTSTND: dec     HL              ; dec 'cos GETCHR INCs
2074+ 2145 CD 59 1D             call    GETCHR          ; Get next character
2075+ 2148 CA 50 21             jp      Z,MORDT         ; End of line - More needed?
2076+ 214B FE 2C                cp      ','             ; Another value?
2077+ 214D C2 8B 20             jp      NZ,BADINP       ; No - Bad input
2078+ 2150 E3           MORDT:  ex      (SP),HL         ; Get code string address
2079+ 2151 2B                   dec     HL              ; dec 'cos GETCHR INCs
2080+ 2152 CD 59 1D             call    GETCHR          ; Get next character
2081+ 2155 C2 E3 20             jp      NZ,NEDMOR       ; More needed - Get it
2082+ 2158 D1                   pop     DE              ; Restore DATA pointer
2083+ 2159 3A 53 55             ld      A,(READFG)      ; "READ" or "INPUT" ?
2084+ 215C B7                   or      A
2085+ 215D EB                   ex      DE,HL           ; DATA pointer to HL
2086+ 215E C2 7F 1D             jp      NZ,UPDATA       ; Update DATA pointer if "READ"
2087+ 2161 D5                   push    DE              ; Save code string address
2088+ 2162 B6                   or      (HL)            ; More input given?
2089+ 2163 21 6B 21             ld      HL,EXTIG        ; "?Extra ignored" message
2090+ 2166 C4 F2 26             call    NZ,PRS          ; Output string if extra given
2091+ 2169 E1                   pop     HL              ; Restore code string address
2092+ 216A C9                   ret
2093+ 216B
2094+ 216B 3F 45 78 74  EXTIG:  defb    "?Extra ignored",CR,0
2094+ 216F 72 61 20 69
2094+ 2173 67 6E 6F 72
2094+ 2177 65 64 0D 00
2095+ 217B
2096+ 217B CD 02 1F     FDTLP:  call    DATA            ; Get next statement
2097+ 217E B7                   or      A               ; End of line?
2098+ 217F C2 94 21             jp      NZ,FANDT        ; No - See if DATA statement
2099+ 2182 23                   inc     HL
2100+ 2183 7E                   ld      A,(HL)          ; End of program?
2101+ 2184 23                   inc     HL
2102+ 2185 B6                   or      (HL)            ; 00 00 Ends program
2103+ 2186 1E 06                ld      E,OD            ; ?OD Error
2104+ 2188 CA 2A 18             jp      Z,ERROR         ; Yes - Out of DATA
2105+ 218B 23                   inc     HL
2106+ 218C 5E                   ld      E,(HL)          ; LSB of line number
2107+ 218D 23                   inc     HL
2108+ 218E 56                   ld      D,(HL)          ; MSB of line number
2109+ 218F EB                   ex      DE,HL
2110+ 2190 22 4F 55             ld      (DATLIN),HL     ; Set line of current DATA item
2111+ 2193 EB                   ex      DE,HL
2112+ 2194 CD 59 1D     FANDT:  call    GETCHR          ; Get next character
2113+ 2197 FE 83                cp      ZDATA           ; "DATA" token
2114+ 2199 C2 7B 21             jp      NZ,FDTLP        ; No "DATA" - Keep looking
2115+ 219C C3 0F 21             jp      ANTVLU          ; Found - Convert input
2116+ 219F
2117+ 219F 11 00 00     NEXT:   ld      DE,$0000        ; In case no index given
2118+ 21A2 C4 F9 23     NEXT1:  call    NZ,GETVAR       ; Get index address
2119+ 21A5 22 54 55             ld      (BRKLIN),HL     ; Save code string address
2120+ 21A8 CD 99 17             call    BAKSTK          ; Look for "FOR" block
2121+ 21AB C2 16 18             jp      NZ,NFERR        ; No "FOR" - ?NF Error
2122+ 21AE F9                   ld      SP,HL           ; Clear nested loops
2123+ 21AF D5                   push    DE              ; Save index address
2124+ 21B0 7E                   ld      A,(HL)          ; Get sign of STEP
2125+ 21B1 23                   inc     HL
2126+ 21B2 F5                   push    AF              ; Save sign of STEP
2127+ 21B3 D5                   push    DE              ; Save index address
2128+ 21B4 CD 35 30             call    PHLTFP          ; Move index value to FPREG
2129+ 21B7 E3                   ex      (SP),HL         ; Save address of TO value
2130+ 21B8 E5                   push    HL              ; Save address of index
2131+ 21B9 CD 51 2D             call    ADDPHL          ; Add STEP to index value
2132+ 21BC E1                   pop     HL              ; Restore address of index
2133+ 21BD CD 4F 30             call    FPTHL           ; Move value to index variable
2134+ 21C0 E1                   pop     HL              ; Restore address of TO value
2135+ 21C1 CD 46 30             call    LOADFP          ; Move TO value to BCDE
2136+ 21C4 E5                   push    HL              ; Save address of line of FOR
2137+ 21C5 CD 72 30             call    CMPNUM          ; Compare index with TO value
2138+ 21C8 E1                   pop     HL              ; Restore address of line num
2139+ 21C9 C1                   pop     BC              ; Address of sign of STEP
2140+ 21CA 90                   sub     B               ; Compare with expected sign
2141+ 21CB CD 46 30             call    LOADFP          ; BC = Loop stmt,DE = Line num
2142+ 21CE CA DA 21             jp      Z,KILFOR        ; Loop finished - Terminate it
2143+ 21D1 EB                   ex      DE,HL           ; Loop statement line number
2144+ 21D2 22 29 54             ld      (LINEAT),HL     ; Set loop line number
2145+ 21D5 69                   ld      L,C             ; Set code string to loop
2146+ 21D6 60                   ld      H,B
2147+ 21D7 C3 15 1D             jp      PUTFID          ; Put back "FOR" and continue
2148+ 21DA
2149+ 21DA F9           KILFOR: ld      SP,HL           ; Remove "FOR" block
2150+ 21DB 2A 54 55             ld      HL,(BRKLIN)     ; Code string after "NEXT"
2151+ 21DE 7E                   ld      A,(HL)          ; Get next byte in code string
2152+ 21DF FE 2C                cp      ','             ; More NEXTs ?
2153+ 21E1 C2 19 1D             jp      NZ,RUNCNT       ; No - Do next statement
2154+ 21E4 CD 59 1D             call    GETCHR          ; Position to index name
2155+ 21E7 CD A2 21             call    NEXT1           ; Re-enter NEXT routine
2156+ 21EA              ; < will not RETurn to here , Exit to RUNCNT or Loop >
2157+ 21EA
2158+ 21EA CD FC 21     GETNUM: call    EVAL            ; Get a numeric expression
2159+ 21ED F6           TSTNUM: defb    $F6             ; Clear carry (numeric)
2160+ 21EE 37           TSTSTR: scf                     ; Set carry (string)
2161+ 21EF 3A 0E 55     CHKTYP: ld      A,(TYPE)        ; Check types match
2162+ 21F2 8F                   adc     A,A             ; Expected + actual
2163+ 21F3 B7                   or      A               ; Clear carry , set parity
2164+ 21F4 E8                   ret     PE              ; Even parity - Types match
2165+ 21F5 C3 22 18             jp      TMERR           ; Different types - Error
2166+ 21F8
2167+ 21F8 CD 10 1B     OPNPAR: call    CHKSYN          ; Make sure "(" follows
2168+ 21FB 28                   defb    '('
2169+ 21FC 2B           EVAL:   dec     HL              ; Evaluate expression & save
2170+ 21FD 16 00                ld      D,$00           ; Precedence value
2171+ 21FF D5           EVAL1:  push    DE              ; Save precedence
2172+ 2200 0E 01                ld      C,$01
2173+ 2202 CD CD 17             call    CHKSTK          ; Check for 1 level of stack
2174+ 2205 CD 73 22             call    OPRND           ; Get next expression value
2175+ 2208 22 56 55     EVAL2:  ld      (NXTOPR),HL     ; Save address of next operator
2176+ 220B 2A 56 55     EVAL3:  ld      HL,(NXTOPR)     ; Restore address of next opr
2177+ 220E C1                   pop     BC              ; Precedence value and operator
2178+ 220F 78                   ld      A,B             ; Get precedence value
2179+ 2210 FE 78                cp      $78             ; "AND", "OR", or "XOR" ?
2180+ 2212 D4 ED 21             call    NC,TSTNUM       ; No - Make sure it's a number
2181+ 2215 7E                   ld      A,(HL)          ; Get next operator / function
2182+ 2216 16 00                ld      D,$00           ; Clear Last relation
2183+ 2218 D6 CB        RLTLP:  sub     ZGTR            ; ">" Token
2184+ 221A DA 34 22             jp      C,FOPRND        ; + - * / ^ AND OR XOR - Test it
2185+ 221D FE 03                cp      ZLTH+1-ZGTR     ; < = >
2186+ 221F D2 34 22             jp      NC,FOPRND       ; Function - Call it
2187+ 2222 FE 01                cp      ZEQUAL-ZGTR     ; "="
2188+ 2224 17                   rla                     ; <- Test for legal
2189+ 2225 AA                   xor     D               ; <- combinations of < = >
2190+ 2226 BA                   cp      D               ; <- by combining last token
2191+ 2227 57                   ld      D,A             ; <- with current one
2192+ 2228 DA 10 18             jp      C,SNERR         ; Error if "<<' '==" or ">>"
2193+ 222B 22 4B 55             ld      (CUROPR),HL     ; Save address of current token
2194+ 222E CD 59 1D             call    GETCHR          ; Get next character
2195+ 2231 C3 18 22             jp      RLTLP           ; Treat the two as one
2196+ 2234
2197+ 2234 7A           FOPRND: ld      A,D             ; < = > found ?
2198+ 2235 B7                   or      A
2199+ 2236 C2 74 23             jp      NZ,TSTRED       ; Yes - Test for reduction
2200+ 2239 7E                   ld      A,(HL)          ; Get operator token
2201+ 223A 22 4B 55             ld      (CUROPR),HL     ; Save operator address
2202+ 223D D6 C1                sub     ZPLUS           ; Operator or function?
2203+ 223F D8                   ret     C               ; Neither - Exit
2204+ 2240 FE 0A                cp      ZOR+1-ZPLUS     ; Is it + - * / ^ AND XOR OR ?
2205+ 2242 D0                   ret     NC              ; No - Exit
2206+ 2243 5F                   ld      E,A             ; Coded operator
2207+ 2244 3A 0E 55             ld      A,(TYPE)        ; Get data type
2208+ 2247 3D                   dec     A               ; FF = numeric , 00 = string
2209+ 2248 B3                   or      E               ; Combine with coded operator
2210+ 2249 7B                   ld      A,E             ; Get coded operator
2211+ 224A CA E8 27             jp      Z,CONCAT        ; String concatenation
2212+ 224D 07                   rlca                    ; Times 2
2213+ 224E 83                   add     A,E             ; Times 3
2214+ 224F 5F                   ld      E,A             ; To DE (D is 0)
2215+ 2250 21 8B 16             ld      HL,PRITAB       ; Precedence table
2216+ 2253 19                   add     HL,DE           ; To the operator concerned
2217+ 2254 78                   ld      A,B             ; Last operator precedence
2218+ 2255 56                   ld      D,(HL)          ; Get evaluation precedence
2219+ 2256 BA                   cp      D               ; Compare with eval precedence
2220+ 2257 D0                   ret     NC              ; Exit if higher precedence
2221+ 2258 23                   inc     HL              ; Point to routine address
2222+ 2259 CD ED 21             call    TSTNUM          ; Make sure it's a number
2223+ 225C
2224+ 225C C5           STKTHS: push    BC              ; Save last precedence & token
2225+ 225D 01 0B 22             ld      BC,EVAL3        ; Where to go on prec' break
2226+ 2260 C5                   push    BC              ; Save on stack for return
2227+ 2261 43                   ld      B,E             ; Save operator
2228+ 2262 4A                   ld      C,D             ; Save precedence
2229+ 2263 CD 28 30             call    STAKFP          ; Move value to stack
2230+ 2266 58                   ld      E,B             ; Restore operator
2231+ 2267 51                   ld      D,C             ; Restore precedence
2232+ 2268 4E                   ld      C,(HL)          ; Get LSB of routine address
2233+ 2269 23                   inc     HL
2234+ 226A 46                   ld      B,(HL)          ; Get MSB of routine address
2235+ 226B 23                   inc     HL
2236+ 226C C5                   push    BC              ; Save routine address
2237+ 226D 2A 4B 55             ld      HL,(CUROPR)     ; Address of current operator
2238+ 2270 C3 FF 21             jp      EVAL1           ; Loop until prec' break
2239+ 2273
2240+ 2273 AF           OPRND:  xor     A               ; Get operand routine
2241+ 2274 32 0E 55             ld      (TYPE),A        ; Set numeric expected
2242+ 2277 CD 59 1D             call    GETCHR          ; Get next character
2243+ 227A 1E 24                ld      E,MO            ; ?MO Error
2244+ 227C CA 2A 18             jp      Z,ERROR         ; No operand - Error
2245+ 227F DA FE 30             jp      C,ASCTFP        ; Number - Get value
2246+ 2282 CD FB 1D             call    CHKLTR          ; See if a letter
2247+ 2285 D2 DA 22             jp      NC,CONVAR       ; Letter - Find variable
2248+ 2288 FE 26                cp      '&'             ; &H = HEX, &B = BINARY
2249+ 228A 20 12                jr      NZ,NOTAMP
2250+ 228C CD 59 1D             call    GETCHR          ; Get next character
2251+ 228F FE 48                cp      'H'             ; Hex number indicated? [function added]
2252+ 2291 CA 68 40             jp      Z,HEXTFP        ; Convert Hex to FPREG
2253+ 2294 FE 42                cp      'B'             ; Binary number indicated? [function added]
2254+ 2296 CA D8 40             jp      Z,BINTFP        ; Convert Bin to FPREG
2255+ 2299 1E 02                ld      E,SN            ; If neither then a ?SN Error
2256+ 229B CA 2A 18             jp      Z,ERROR         ;
2257+ 229E FE C1        NOTAMP: cp      ZPLUS           ; '+' Token ?
2258+ 22A0 CA 73 22             jp      Z,OPRND         ; Yes - Look for operand
2259+ 22A3 FE 2E                cp      '.'             ; '.' ?
2260+ 22A5 CA FE 30             jp      Z,ASCTFP        ; Yes - Create FP number
2261+ 22A8 FE C2                cp      ZMINUS          ; '-' Token ?
2262+ 22AA CA C9 22             jp      Z,MINUS         ; Yes - Do minus
2263+ 22AD FE 22                cp      $22             ; '"'             ; Literal string ?
2264+ 22AF CA B1 26             jp      Z,QTSTR         ; Get string terminated by '"'
2265+ 22B2 FE BF                cp      ZNOT            ; "NOT" Token ?
2266+ 22B4 CA D4 23             jp      Z,EVNOT         ; Yes - Eval NOT expression
2267+ 22B7 FE BC                cp      ZFN             ; "FN" Token ?
2268+ 22B9 CA 15 26             jp      Z,DOFN          ; Yes - Do FN routine
2269+ 22BC D6 CE                sub     ZSGN            ; Is it a function?
2270+ 22BE D2 EB 22             jp      NC,FNOFST       ; Yes - Evaluate function
2271+ 22C1 CD F8 21     EVLPAR: call    OPNPAR          ; Evaluate expression in "()"
2272+ 22C4 CD 10 1B             call    CHKSYN          ; Make sure ")" follows
2273+ 22C7 29                   defb    ')'
2274+ 22C8 C9                   ret
2275+ 22C9
2276+ 22C9 16 7D        MINUS:  ld      D,$7D           ; '-' precedence
2277+ 22CB CD FF 21             call    EVAL1           ; Evaluate until prec' break
2278+ 22CE 2A 56 55             ld      HL,(NXTOPR)     ; Get next operator address
2279+ 22D1 E5                   push    HL              ; Save next operator address
2280+ 22D2 CD 20 30             call    INVSGN          ; Negate value
2281+ 22D5 CD ED 21     RETNUM: call    TSTNUM          ; Make sure it's a number
2282+ 22D8 E1                   pop     HL              ; Restore next operator address
2283+ 22D9 C9                   ret
2284+ 22DA
2285+ 22DA CD F9 23     CONVAR: call    GETVAR          ; Get variable address to DE
2286+ 22DD E5           FRMEVL: push    HL              ; Save code string address
2287+ 22DE EB                   ex      DE,HL           ; Variable address to HL
2288+ 22DF 22 D0 55             ld      (FPREG),HL      ; Save address of variable
2289+ 22E2 3A 0E 55             ld      A,(TYPE)        ; Get type
2290+ 22E5 B7                   or      A               ; Numeric?
2291+ 22E6 CC 35 30             call    Z,PHLTFP        ; Yes - Move contents to FPREG
2292+ 22E9 E1                   pop     HL              ; Restore code string address
2293+ 22EA C9                   ret
2294+ 22EB
2295+ 22EB 06 00        FNOFST: ld      B,$00           ; Get address of function
2296+ 22ED 07                   rlca                    ; Double function offset
2297+ 22EE 4F                   ld      C,A             ; BC = Offset in function table
2298+ 22EF C5                   push    BC              ; Save adjusted token value
2299+ 22F0 CD 59 1D             call    GETCHR          ; Get next character
2300+ 22F3 79                   ld      A,C             ; Get adjusted token value
2301+ 22F4 FE 2C                cp      2*(ZPOINT-ZSGN) ; "POINT" token?
2302+ 22F6 CA 21 38             jp      Z,POINT         ; Yes, do "POINT"
2303+ 22F9 FE 2E                cp      2*(ZINSTR-ZSGN) ; "INSTR" token?
2304+ 22FB CA C4 28             jp      Z,INSTR         ; Yes, do "INSTR"
2305+ 22FE FE 41                cp      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
2306+ 2300 DA 1C 23             jp      C,FNVAL         ; No - Do function
2307+ 2303 CD F8 21             call    OPNPAR          ; Evaluate expression  (X,...
2308+ 2306 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
2309+ 2309 2C                   defb    ','
2310+ 230A CD EE 21             call    TSTSTR          ; Make sure it's a string
2311+ 230D EB                   ex      DE,HL           ; Save code string address
2312+ 230E 2A D0 55             ld      HL,(FPREG)      ; Get address of string
2313+ 2311 E3                   ex      (SP),HL         ; Save address of string
2314+ 2312 E5                   push    HL              ; Save adjusted token value
2315+ 2313 EB                   ex      DE,HL           ; Restore code string address
2316+ 2314 CD 70 2A             call    GETINT          ; Get integer 0-255
2317+ 2317 EB                   ex      DE,HL           ; Save code string address
2318+ 2318 E3                   ex      (SP),HL         ; Save integer,HL = adj' token
2319+ 2319 C3 24 23             jp      GOFUNC          ; Jump to string function
2320+ 231C
2321+ 231C CD C1 22     FNVAL:  call    EVLPAR          ; Evaluate expression
2322+ 231F E3                   ex      (SP),HL         ; HL = Adjusted token value
2323+ 2320 11 D5 22             ld      DE,RETNUM       ; Return number from function
2324+ 2323 D5                   push    DE              ; Save on stack
2325+ 2324 01 2C 14     GOFUNC: ld      BC,FNCTAB       ; Function routine addresses
2326+ 2327 09                   add     HL,BC           ; Point to right address
2327+ 2328 4E                   ld      C,(HL)          ; Get LSB of address
2328+ 2329 23                   inc     HL              ;
2329+ 232A 66                   ld      H,(HL)          ; Get MSB of address
2330+ 232B 69                   ld      L,C             ; Address to HL
2331+ 232C E9                   jp      (HL)            ; Jump to function
2332+ 232D
2333+ 232D 15           SGNEXP: dec     D               ; Dee to flag negative exponent
2334+ 232E FE C2                cp      ZMINUS          ; '-' token ?
2335+ 2330 C8                   ret     Z               ; Yes - Return
2336+ 2331 FE 2D                cp      '-'             ; '-' ASCII ?
2337+ 2333 C8                   ret     Z               ; Yes - Return
2338+ 2334 14                   inc     D               ; Inc to flag positive exponent
2339+ 2335 FE 2B                cp      '+'             ; '+' ASCII ?
2340+ 2337 C8                   ret     Z               ; Yes - Return
2341+ 2338 FE C1                cp      ZPLUS           ; '+' token ?
2342+ 233A C8                   ret     Z               ; Yes - Return
2343+ 233B 2B                   dec     HL              ; dec 'cos GETCHR INCs
2344+ 233C C9                   ret                     ; Return "NZ"
2345+ 233D
2346+ 233D              ; execute OR, AND, and XOR operations
2347+ 233D AF           PAND:   xor     A               ; for AND, Z=1
2348+ 233E 18 07                jr      CNTLGC
2349+ 2340 AF           POR:    xor     A               ; for OR, Z=0, S=1
2350+ 2341 D6 01                sub     $01
2351+ 2343 18 02                jr      CNTLGC
2352+ 2345 AF           PXOR:   xor     A               ; for XOR, Z=0, S=0
2353+ 2346 3C                   inc     A
2354+ 2347 F5           CNTLGC: push    AF              ; store operand's flags
2355+ 2348 CD ED 21             call    TSTNUM          ; Make sure it's a number
2356+ 234B CD 0F 1E             call    DEINT           ; Get integer -32768 to 32767
2357+ 234E F1                   pop     AF              ; retrieve operand's flags
2358+ 234F EB                   ex      DE,HL           ; <- Get last
2359+ 2350 C1                   pop     BC              ; <-  value
2360+ 2351 E3                   ex      (SP),HL         ; <-  from
2361+ 2352 EB                   ex      DE,HL           ; <-  stack
2362+ 2353 CD 38 30             call    FPBCDE          ; Move last value to FPREG
2363+ 2356 F5                   push    AF              ; store operand's flags
2364+ 2357 CD 0F 1E             call    DEINT           ; Get integer -32768 to 32767
2365+ 235A F1                   pop     AF              ; retrieve operand's flags
2366+ 235B C1                   pop     BC              ; Get value
2367+ 235C 79                   ld      A,C             ; Get LSB
2368+ 235D 21 D3 25             ld      HL,ACPASS       ; Address of save AC as current
2369+ 2360 20 05                jr      NZ,POR1         ; if X/OR, jump over
2370+ 2362 A3           PAND1:  and     E               ; "AND" LSBs
2371+ 2363 4F                   ld      C,A             ; Save LSB
2372+ 2364 78                   ld      A,B             ; Get MSB
2373+ 2365 A2                   and     D               ; "AND" MSBs
2374+ 2366 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2375+ 2367 F2 6F 23     POR1:   jp      P,PXOR1         ; if S=0, jump to XOR
2376+ 236A B3                   or      E               ; "OR" LSBs
2377+ 236B 4F                   ld      C,A             ; Save LSB
2378+ 236C 78                   ld      A,B             ; Get MSB
2379+ 236D B2                   or      D               ; "OR" MSBs
2380+ 236E E9                   jp      (HL)            ; Save AC as current (ACPASS)
2381+ 236F AB           PXOR1:  xor     E               ; "XOR" LSBs
2382+ 2370 4F                   ld      C,A             ; Save LSB
2383+ 2371 78                   ld      A,B             ; Get MSB
2384+ 2372 AA                   xor     D               ; "XOR" MSBs
2385+ 2373 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2386+ 2374
2387+ 2374 21 86 23     TSTRED: ld      HL,CMPLOG       ; Logical compare routine
2388+ 2377 3A 0E 55             ld      A,(TYPE)        ; Get data type
2389+ 237A 1F                   rra                     ; Carry set = string
2390+ 237B 7A                   ld      A,D             ; Get last precedence value
2391+ 237C 17                   rla                     ; Times 2 plus carry
2392+ 237D 5F                   ld      E,A             ; To E
2393+ 237E 16 64                ld      D,$64           ; Relational precedence
2394+ 2380 78                   ld      A,B             ; Get current precedence
2395+ 2381 BA                   cp      D               ; Compare with last
2396+ 2382 D0                   ret     NC              ; Eval if last was rel' or log'
2397+ 2383 C3 5C 22             jp      STKTHS          ; Stack this one and get next
2398+ 2386
2399+ 2386 88 23        CMPLOG: defw    CMPLG1          ; Compare two values / strings
2400+ 2388 79           CMPLG1: ld      A,C             ; Get data type
2401+ 2389 B7                   or      A
2402+ 238A 1F                   rra
2403+ 238B C1                   pop     BC              ; Get last expression to BCDE
2404+ 238C D1                   pop     DE
2405+ 238D F5                   push    AF              ; Save status
2406+ 238E CD EF 21             call    CHKTYP          ; Check that types match
2407+ 2391 21 CA 23             ld      HL,CMPRES       ; Result to comparison
2408+ 2394 E5                   push    HL              ; Save for RETurn
2409+ 2395 CA 72 30             jp      Z,CMPNUM        ; Compare values if numeric
2410+ 2398 AF                   xor     A               ; Compare two strings
2411+ 2399 32 0E 55             ld      (TYPE),A        ; Set type to numeric
2412+ 239C D5                   push    DE              ; Save string name
2413+ 239D CD 35 28             call    GSTRCU          ; Get current string
2414+ 23A0 7E                   ld      A,(HL)          ; Get length of string
2415+ 23A1 23                   inc     HL
2416+ 23A2 23                   inc     HL
2417+ 23A3 4E                   ld      C,(HL)          ; Get LSB of address
2418+ 23A4 23                   inc     HL
2419+ 23A5 46                   ld      B,(HL)          ; Get MSB of address
2420+ 23A6 D1                   pop     DE              ; Restore string name
2421+ 23A7 C5                   push    BC              ; Save address of string
2422+ 23A8 F5                   push    AF              ; Save length of string
2423+ 23A9 CD 39 28             call    GSTRDE          ; Get second string
2424+ 23AC CD 46 30             call    LOADFP          ; Get address of second string
2425+ 23AF F1                   pop     AF              ; Restore length of string 1
2426+ 23B0 57                   ld      D,A             ; Length to D
2427+ 23B1 E1                   pop     HL              ; Restore address of string 1
2428+ 23B2 7B           CMPSTR: ld      A,E             ; Bytes of string 2 to do
2429+ 23B3 B2                   or      D               ; Bytes of string 1 to do
2430+ 23B4 C8                   ret     Z               ; Exit if all bytes compared
2431+ 23B5 7A                   ld      A,D             ; Get bytes of string 1 to do
2432+ 23B6 D6 01                sub     $01
2433+ 23B8 D8                   ret     C               ; Exit if end of string 1
2434+ 23B9 AF                   xor     A
2435+ 23BA BB                   cp      E               ; Bytes of string 2 to do
2436+ 23BB 3C                   inc     A
2437+ 23BC D0                   ret     NC              ; Exit if end of string 2
2438+ 23BD 15                   dec     D               ; Count bytes in string 1
2439+ 23BE 1D                   dec     E               ; Count bytes in string 2
2440+ 23BF 0A                   ld      A,(BC)          ; Byte in string 2
2441+ 23C0 BE                   cp      (HL)            ; Compare to byte in string 1
2442+ 23C1 23                   inc     HL              ; Move up string 1
2443+ 23C2 03                   inc     BC              ; Move up string 2
2444+ 23C3 CA B2 23             jp      Z,CMPSTR        ; Same - Try next bytes
2445+ 23C6 3F                   ccf                     ; Flag difference (">" or "<")
2446+ 23C7 C3 02 30             jp      FLGDIF          ; "<" gives -1 , ">" gives +1
2447+ 23CA
2448+ 23CA 3C           CMPRES: inc     A               ; Increment current value
2449+ 23CB 8F                   adc     A,A             ; Double plus carry
2450+ 23CC C1                   pop     BC              ; Get other value
2451+ 23CD A0                   and     B               ; Combine them
2452+ 23CE C6 FF                add     A,-1            ; Carry set if different
2453+ 23D0 9F                   sbc     A,A             ; 00 - Equal , FF - Different
2454+ 23D1 C3 09 30             jp      FLGREL          ; Set current value & continue
2455+ 23D4
2456+ 23D4 16 5A        EVNOT:  ld      D,$5A           ; Precedence value for "NOT"
2457+ 23D6 CD FF 21             call    EVAL1           ; Eval until precedence break
2458+ 23D9 CD ED 21             call    TSTNUM          ; Make sure it's a number
2459+ 23DC CD 0F 1E             call    DEINT           ; Get integer -32768 - 32767
2460+ 23DF 7B                   ld      A,E             ; Get LSB
2461+ 23E0 2F                   cpl                     ; Invert LSB
2462+ 23E1 4F                   ld      C,A             ; Save "NOT" of LSB
2463+ 23E2 7A                   ld      A,D             ; Get MSB
2464+ 23E3 2F                   cpl                     ; Invert MSB
2465+ 23E4 CD D3 25             call    ACPASS          ; Save AC as current
2466+ 23E7 C1                   pop     BC              ; Clean up stack
2467+ 23E8 C3 0B 22             jp      EVAL3           ; Continue evaluation
2468+ 23EB
2469+ 23EB 2B           DIMRET: dec     HL              ; dec 'cos GETCHR INCs
2470+ 23EC CD 59 1D             call    GETCHR          ; Get next character
2471+ 23EF C8                   ret     Z               ; End of DIM statement
2472+ 23F0 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
2473+ 23F3 2C                   defb    ','
2474+ 23F4 01 EB 23     DIM:    ld      BC,DIMRET       ; Return to "DIMRET"
2475+ 23F7 C5                   push    BC              ; Save on stack
2476+ 23F8 F6                   defb    $F6             ; Flag "Create" variable
2477+ 23F9 AF           GETVAR: xor     A               ; Find variable address,to DE
2478+ 23FA 32 0D 55             ld      (LCRFLG),A      ; Set locate / create flag
2479+ 23FD 46                   ld      B,(HL)          ; Get First byte of name
2480+ 23FE CD FB 1D     GTFNAM: call    CHKLTR          ; See if a letter
2481+ 2401 DA 10 18             jp      C,SNERR         ; ?SN Error if not a letter
2482+ 2404 AF                   xor     A
2483+ 2405 4F                   ld      C,A             ; Clear second byte of name
2484+ 2406 32 0E 55             ld      (TYPE),A        ; Set type to numeric
2485+ 2409 CD 59 1D             call    GETCHR          ; Get next character
2486+ 240C DA 15 24             jp      C,SVNAM2        ; Numeric - Save in name
2487+ 240F CD FB 1D             call    CHKLTR          ; See if a letter
2488+ 2412 DA 22 24             jp      C,CHARTY        ; Not a letter - Check type
2489+ 2415 4F           SVNAM2: ld      C,A             ; Save second byte of name
2490+ 2416 CD 59 1D     ENDNAM: call    GETCHR          ; Get next character
2491+ 2419 DA 16 24             jp      C,ENDNAM        ; Numeric - Get another
2492+ 241C CD FB 1D             call    CHKLTR          ; See if a letter
2493+ 241F D2 16 24             jp      NC,ENDNAM       ; Letter - Get another
2494+ 2422 D6 24        CHARTY: sub     '$'             ; String variable?
2495+ 2424 C2 31 24             jp      NZ,NOTSTR       ; No - Numeric variable
2496+ 2427 3C                   inc     A               ; A = 1 (string type)
2497+ 2428 32 0E 55             ld      (TYPE),A        ; Set type to string
2498+ 242B 0F                   rrca                    ; A = 80H , Flag for string
2499+ 242C 81                   add     A,C             ; 2nd byte of name has bit 7 on
2500+ 242D 4F                   ld      C,A             ; Resave second byte on name
2501+ 242E CD 59 1D             call    GETCHR          ; Get next character
2502+ 2431 3A 51 55     NOTSTR: ld      A,(FORFLG)      ; Array name needed ?
2503+ 2434 3D                   dec     A
2504+ 2435 CA DE 24             jp      Z,ARLDSV        ; Yes - Get array name
2505+ 2438 F2 41 24             jp      P,NSCFOR        ; No array with "FOR" or "FN"
2506+ 243B 7E                   ld      A,(HL)          ; Get byte again
2507+ 243C D6 28                sub     '('             ; Subscripted variable?
2508+ 243E CA B6 24             jp      Z,SBSCPT        ; Yes - Sort out subscript
2509+ 2441
2510+ 2441 AF           NSCFOR: xor     A               ; Simple variable
2511+ 2442 32 51 55             ld      (FORFLG),A      ; Clear "FOR" flag
2512+ 2445 E5                   push    HL              ; Save code string address
2513+ 2446 50                   ld      D,B             ; DE = Variable name to find
2514+ 2447 59                   ld      E,C
2515+ 2448 2A CA 55             ld      HL,(FNRGNM)     ; FN argument name
2516+ 244B CD 0A 1B             call    CPDEHL          ; Is it the FN argument?
2517+ 244E 11 CC 55             ld      DE,FNARG        ; Point to argument value
2518+ 2451 CA E7 2E             jp      Z,POPHRT        ; Yes - Return FN argument value
2519+ 2454 2A C4 55             ld      HL,(VAREND)     ; End of variables
2520+ 2457 EB                   ex      DE,HL           ; Address of end of search
2521+ 2458 2A C2 55             ld      HL,(PROGND)     ; Start of variables address
2522+ 245B CD 0A 1B     FNDVAR: call    CPDEHL          ; End of variable list table?
2523+ 245E CA 74 24             jp      Z,CFEVAL        ; Yes - Called from EVAL?
2524+ 2461 79                   ld      A,C             ; Get second byte of name
2525+ 2462 96                   sub     (HL)            ; Compare with name in list
2526+ 2463 23                   inc     HL              ; Move on to first byte
2527+ 2464 C2 69 24             jp      NZ,FNTHR        ; Different - Find another
2528+ 2467 78                   ld      A,B             ; Get first byte of name
2529+ 2468 96                   sub     (HL)            ; Compare with name in list
2530+ 2469 23           FNTHR:  inc     HL              ; Move on to LSB of value
2531+ 246A CA A8 24             jp      Z,RETADR        ; Found - Return address
2532+ 246D 23                   inc     HL              ; <- Skip
2533+ 246E 23                   inc     HL              ; <- over
2534+ 246F 23                   inc     HL              ; <- F.P.
2535+ 2470 23                   inc     HL              ; <- value
2536+ 2471 C3 5B 24             jp      FNDVAR          ; Keep looking
2537+ 2474
2538+ 2474 E1           CFEVAL: pop     HL              ; Restore code string address
2539+ 2475 E3                   ex      (SP),HL         ; Get return address
2540+ 2476 D5                   push    DE              ; Save address of variable
2541+ 2477 11 DD 22             ld      DE,FRMEVL       ; Return address in EVAL
2542+ 247A CD 0A 1B             call    CPDEHL          ; Called from EVAL ?
2543+ 247D D1                   pop     DE              ; Restore address of variable
2544+ 247E CA AB 24             jp      Z,RETNUL        ; Yes - Return null variable
2545+ 2481 E3                   ex      (SP),HL         ; Put back return
2546+ 2482 E5                   push    HL              ; Save code string address
2547+ 2483 C5                   push    BC              ; Save variable name
2548+ 2484 01 06 00             ld      BC,$0006        ; 2 byte name plus 4 byte data
2549+ 2487 2A C6 55             ld      HL,(ARREND)     ; End of arrays
2550+ 248A E5                   push    HL              ; Save end of arrays
2551+ 248B 09                   add     HL,BC           ; Move up 6 bytes
2552+ 248C C1                   pop     BC              ; Source address in BC
2553+ 248D E5                   push    HL              ; Save new end address
2554+ 248E CD BC 17             call    MOVUP           ; Move arrays up
2555+ 2491 E1                   pop     HL              ; Restore new end address
2556+ 2492 22 C6 55             ld      (ARREND),HL     ; Set new end address
2557+ 2495 60                   ld      H,B             ; End of variables to HL
2558+ 2496 69                   ld      L,C
2559+ 2497 22 C4 55             ld      (VAREND),HL     ; Set new end address
2560+ 249A
2561+ 249A 2B           ZEROLP: dec     HL              ; Back through to zero variable
2562+ 249B 36 00                ld      (HL),$00        ; Zero byte in variable
2563+ 249D CD 0A 1B             call    CPDEHL          ; Done them all?
2564+ 24A0 C2 9A 24             jp      NZ,ZEROLP       ; No - Keep on going
2565+ 24A3 D1                   pop     DE              ; Get variable name
2566+ 24A4 73                   ld      (HL),E          ; Store second character
2567+ 24A5 23                   inc     HL
2568+ 24A6 72                   ld      (HL),D          ; Store first character
2569+ 24A7 23                   inc     HL
2570+ 24A8 EB           RETADR: ex      DE,HL           ; Address of variable in DE
2571+ 24A9 E1                   pop     HL              ; Restore code string address
2572+ 24AA C9                   ret
2573+ 24AB
2574+ 24AB 32 D3 55     RETNUL: ld      (FPEXP),A       ; Set result to zero
2575+ 24AE 21 8D 17             ld      HL,ZERBYT       ; Also set a null string
2576+ 24B1 22 D0 55             ld      (FPREG),HL      ; Save for EVAL
2577+ 24B4 E1                   pop     HL              ; Restore code string address
2578+ 24B5 C9                   ret
2579+ 24B6
2580+ 24B6 E5           SBSCPT: push    HL              ; Save code string address
2581+ 24B7 2A 0D 55             ld      HL,(LCRFLG)     ; Locate/Create and Type
2582+ 24BA E3                   ex      (SP),HL         ; Save and get code string
2583+ 24BB 57                   ld      D,A             ; Zero number of dimensions
2584+ 24BC D5           SCPTLP: push    DE              ; Save number of dimensions
2585+ 24BD C5                   push    BC              ; Save array name
2586+ 24BE CD 03 1E             call    FPSINT          ; Get subscript (0-32767)
2587+ 24C1 C1                   pop     BC              ; Restore array name
2588+ 24C2 F1                   pop     AF              ; Get number of dimensions
2589+ 24C3 EB                   ex      DE,HL
2590+ 24C4 E3                   ex      (SP),HL         ; Save subscript value
2591+ 24C5 E5                   push    HL              ; Save LCRFLG and TYPE
2592+ 24C6 EB                   ex      DE,HL
2593+ 24C7 3C                   inc     A               ; Count dimensions
2594+ 24C8 57                   ld      D,A             ; Save in D
2595+ 24C9 7E                   ld      A,(HL)          ; Get next byte in code string
2596+ 24CA FE 2C                cp      ','             ; Comma (more to come)?
2597+ 24CC CA BC 24             jp      Z,SCPTLP        ; Yes - More subscripts
2598+ 24CF CD 10 1B             call    CHKSYN          ; Make sure ")" follows
2599+ 24D2 29                   defb    ')'
2600+ 24D3 22 56 55             ld      (NXTOPR),HL     ; Save code string address
2601+ 24D6 E1                   pop     HL              ; Get LCRFLG and TYPE
2602+ 24D7 22 0D 55             ld      (LCRFLG),HL     ; Restore Locate/create & type
2603+ 24DA 1E 00                ld      E,$00           ; Flag not CSAVE* or CLOAD*
2604+ 24DC D5                   push    DE              ; Save number of dimensions (D)
2605+ 24DD 11                   defb    $11             ; Skip "push HL" and "push AF'
2606+ 24DE
2607+ 24DE E5           ARLDSV: push    HL              ; Save code string address
2608+ 24DF F5                   push    AF              ; A = 00 , Flags set = Z,N
2609+ 24E0 2A C4 55             ld      HL,(VAREND)     ; Start of arrays
2610+ 24E3 3E                   defb    $3E             ; Skip "add HL,DE"
2611+ 24E4 19           FNDARY: add     HL,DE           ; Move to next array start
2612+ 24E5 EB                   ex      DE,HL
2613+ 24E6 2A C6 55             ld      HL,(ARREND)     ; End of arrays
2614+ 24E9 EB                   ex      DE,HL           ; Current array pointer
2615+ 24EA CD 0A 1B             call    CPDEHL          ; End of arrays found?
2616+ 24ED CA 16 25             jp      Z,CREARY        ; Yes - Create array
2617+ 24F0 7E                   ld      A,(HL)          ; Get second byte of name
2618+ 24F1 B9                   cp      C               ; Compare with name given
2619+ 24F2 23                   inc     HL              ; Move on
2620+ 24F3 C2 F8 24             jp      NZ,NXTARY       ; Different - Find next array
2621+ 24F6 7E                   ld      A,(HL)          ; Get first byte of name
2622+ 24F7 B8                   cp      B               ; Compare with name given
2623+ 24F8 23           NXTARY: inc     HL              ; Move on
2624+ 24F9 5E                   ld      E,(HL)          ; Get LSB of next array address
2625+ 24FA 23                   inc     HL
2626+ 24FB 56                   ld      D,(HL)          ; Get MSB of next array address
2627+ 24FC 23                   inc     HL
2628+ 24FD C2 E4 24             jp      NZ,FNDARY       ; Not found - Keep looking
2629+ 2500 3A 0D 55             ld      A,(LCRFLG)      ; Found Locate or Create it?
2630+ 2503 B7                   or      A
2631+ 2504 C2 19 18             jp      NZ,DDERR        ; Create - ?DD Error
2632+ 2507 F1                   pop     AF              ; Locate - Get number of dim'ns
2633+ 2508 44                   ld      B,H             ; BC Points to array dim'ns
2634+ 2509 4D                   ld      C,L
2635+ 250A CA E7 2E             jp      Z,POPHRT        ; Jump if array load/save
2636+ 250D 96                   sub     (HL)            ; Same number of dimensions?
2637+ 250E CA 74 25             jp      Z,FINDEL        ; Yes - Find element
2638+ 2511 1E 10        BSERR:  ld      E,BS            ; ?BS Error
2639+ 2513 C3 2A 18             jp      ERROR           ; Output error
2640+ 2516
2641+ 2516 11 04 00     CREARY: ld      DE,$0004        ; 4 Bytes per entry
2642+ 2519 F1                   pop     AF              ; Array to save or 0 dim'ns?
2643+ 251A CA 24 1E             jp      Z,FCERR         ; Yes - ?FC Error
2644+ 251D 71                   ld      (HL),C          ; Save second byte of name
2645+ 251E 23                   inc     HL
2646+ 251F 70                   ld      (HL),B          ; Save first byte of name
2647+ 2520 23                   inc     HL
2648+ 2521 4F                   ld      C,A             ; Number of dimensions to C
2649+ 2522 CD CD 17             call    CHKSTK          ; Check if enough memory
2650+ 2525 23                   inc     HL              ; Point to number of dimensions
2651+ 2526 23                   inc     HL
2652+ 2527 22 4B 55             ld      (CUROPR),HL     ; Save address of pointer
2653+ 252A 71                   ld      (HL),C          ; Set number of dimensions
2654+ 252B 23                   inc     HL
2655+ 252C 3A 0D 55             ld      A,(LCRFLG)      ; Locate of Create?
2656+ 252F 17                   rla                     ; Carry set = Create
2657+ 2530 79                   ld      A,C             ; Get number of dimensions
2658+ 2531 01 0B 00     CRARLP: ld      BC,10+1         ; Default dimension size 10
2659+ 2534 D2 39 25             jp      NC,DEFSIZ       ; Locate - Set default size
2660+ 2537 C1                   pop     BC              ; Get specified dimension size
2661+ 2538 03                   inc     BC              ; Include zero element
2662+ 2539 71           DEFSIZ: ld      (HL),C          ; Save LSB of dimension size
2663+ 253A 23                   inc     HL
2664+ 253B 70                   ld      (HL),B          ; Save MSB of dimension size
2665+ 253C 23                   inc     HL
2666+ 253D F5                   push    AF              ; Save num' of dim'ns an status
2667+ 253E E5                   push    HL              ; Save address of dim'n size
2668+ 253F CD E3 30             call    MLDEBC          ; Multiply DE by BC to find
2669+ 2542 EB                   ex      DE,HL           ; amount of mem needed (to DE)
2670+ 2543 E1                   pop     HL              ; Restore address of dimension
2671+ 2544 F1                   pop     AF              ; Restore number of dimensions
2672+ 2545 3D                   dec     A               ; Count them
2673+ 2546 C2 31 25             jp      NZ,CRARLP       ; Do next dimension if more
2674+ 2549 F5                   push    AF              ; Save locate/create flag
2675+ 254A 42                   ld      B,D             ; MSB of memory needed
2676+ 254B 4B                   ld      C,E             ; LSB of memory needed
2677+ 254C EB                   ex      DE,HL
2678+ 254D 19                   add     HL,DE           ; Add bytes to array start
2679+ 254E DA E5 17             jp      C,OMERR         ; Too big - Error
2680+ 2551 CD D6 17             call    ENFMEM          ; See if enough memory
2681+ 2554 22 C6 55             ld      (ARREND),HL     ; Save new end of array
2682+ 2557
2683+ 2557 2B           ZERARY: dec     HL              ; Back through array data
2684+ 2558 36 00                ld      (HL),$00        ; Set array element to zero
2685+ 255A CD 0A 1B             call    CPDEHL          ; All elements zeroed?
2686+ 255D C2 57 25             jp      NZ,ZERARY       ; No - Keep on going
2687+ 2560 03                   inc     BC              ; Number of bytes + 1
2688+ 2561 57                   ld      D,A             ; A=0
2689+ 2562 2A 4B 55             ld      HL,(CUROPR)     ; Get address of array
2690+ 2565 5E                   ld      E,(HL)          ; Number of dimensions
2691+ 2566 EB                   ex      DE,HL           ; To HL
2692+ 2567 29                   add     HL,HL           ; Two bytes per dimension size
2693+ 2568 09                   add     HL,BC           ; Add number of bytes
2694+ 2569 EB                   ex      DE,HL           ; Bytes needed to DE
2695+ 256A 2B                   dec     HL
2696+ 256B 2B                   dec     HL
2697+ 256C 73                   ld      (HL),E          ; Save LSB of bytes needed
2698+ 256D 23                   inc     HL
2699+ 256E 72                   ld      (HL),D          ; Save MSB of bytes needed
2700+ 256F 23                   inc     HL
2701+ 2570 F1                   pop     AF              ; Locate / Create?
2702+ 2571 DA 98 25             jp      C,ENDDIM        ; A is 0 , End if create
2703+ 2574 47           FINDEL: ld      B,A             ; Find array element
2704+ 2575 4F                   ld      C,A
2705+ 2576 7E                   ld      A,(HL)          ; Number of dimensions
2706+ 2577 23                   inc     HL
2707+ 2578 16                   defb    $16             ; Skip "pop HL"
2708+ 2579 E1           FNDELP: pop     HL              ; Address of next dim' size
2709+ 257A 5E                   ld      E,(HL)          ; Get LSB of dim'n size
2710+ 257B 23                   inc     HL
2711+ 257C 56                   ld      D,(HL)          ; Get MSB of dim'n size
2712+ 257D 23                   inc     HL
2713+ 257E E3                   ex      (SP),HL         ; Save address - Get index
2714+ 257F F5                   push    AF              ; Save number of dim'ns
2715+ 2580 CD 0A 1B             call    CPDEHL          ; Dimension too large?
2716+ 2583 D2 11 25             jp      NC,BSERR        ; Yes - ?BS Error
2717+ 2586 E5                   push    HL              ; Save index
2718+ 2587 CD E3 30             call    MLDEBC          ; Multiply previous by size
2719+ 258A D1                   pop     DE              ; Index supplied to DE
2720+ 258B 19                   add     HL,DE           ; Add index to pointer
2721+ 258C F1                   pop     AF              ; Number of dimensions
2722+ 258D 3D                   dec     A               ; Count them
2723+ 258E 44                   ld      B,H             ; MSB of pointer
2724+ 258F 4D                   ld      C,L             ; LSB of pointer
2725+ 2590 C2 79 25             jp      NZ,FNDELP       ; More - Keep going
2726+ 2593 29                   add     HL,HL           ; 4 Bytes per element
2727+ 2594 29                   add     HL,HL
2728+ 2595 C1                   pop     BC              ; Start of array
2729+ 2596 09                   add     HL,BC           ; Point to element
2730+ 2597 EB                   ex      DE,HL           ; Address of element to DE
2731+ 2598 2A 56 55     ENDDIM: ld      HL,(NXTOPR)     ; Got code string address
2732+ 259B C9                   ret
2733+ 259C
2734+ 259C
2735+ 259C              ; returns the value of the 32-bit system tick counter as
2736+ 259C              ; two 16-bit words
2737+ 259C CD ED 21     TMR:    call    TSTNUM          ; Make sure it's a number
2738+ 259F CD 0F 1E             call    DEINT           ; Get integer (-32768 to 32767)
2739+ 25A2 2A 5C 55             ld      HL,(TMRCNT)     ; load the LSBytes of timer
2740+ 25A5 7B                   ld      A,E
2741+ 25A6 B2                   or      D               ; is it 0?
2742+ 25A7 CA AD 25             jp      Z,ENDTMR        ; yes, jump over
2743+ 25AA 2A 5E 55             ld      HL,(TMRCNT+2)   ; load the MSBytes of timer
2744+ 25AD 45           ENDTMR: ld      B,L             ; move bytes...
2745+ 25AE 7C                   ld      A,H             ; ...into AB
2746+ 25AF C3 D4 25             jp      ABPASS          ; return word into AB
2747+ 25B2
2748+ 25B2
2749+ 25B2              ; returns the free space for BASIC or into the string pool
2750+ 25B2 2A C6 55     FRE:    ld      HL,(ARREND)     ; Start of free memory
2751+ 25B5 EB                   ex      DE,HL           ; To DE
2752+ 25B6 21 00 00             ld      HL,$0000        ; End of free memory
2753+ 25B9 39                   add     HL,SP           ; Current stack value
2754+ 25BA 3A 0E 55             ld      A,(TYPE)        ; Dummy argument type
2755+ 25BD B7                   or      A
2756+ 25BE CA CE 25             jp      Z,FRENUM        ; Numeric - Free variable space
2757+ 25C1 CD 35 28             call    GSTRCU          ; Current string to pool
2758+ 25C4 CD 35 27             call    GARBGE          ; Garbage collection
2759+ 25C7 2A 27 54             ld      HL,(STRSPC)     ; Bottom of string space in use
2760+ 25CA EB                   ex      DE,HL           ; To DE
2761+ 25CB 2A 49 55             ld      HL,(STRBOT)     ; Bottom of string space
2762+ 25CE 7D           FRENUM: ld      A,L             ; Get LSB of end
2763+ 25CF 93                   sub     E               ; Subtract LSB of beginning
2764+ 25D0 4F                   ld      C,A             ; Save difference if C
2765+ 25D1 7C                   ld      A,H             ; Get MSB of end
2766+ 25D2 9A                   sbc     A,D             ; Subtract MSB of beginning
2767+ 25D3 41           ACPASS: ld      B,C             ; Return integer AC
2768+ 25D4 50           ABPASS: ld      D,B             ; Return integer AB
2769+ 25D5 1E 00                ld      E,$00
2770+ 25D7 21 0E 55             ld      HL,TYPE         ; Point to type
2771+ 25DA 73                   ld      (HL),E          ; Set type to numeric
2772+ 25DB 06 90                ld      B,$80+$10       ; 16 bit integer
2773+ 25DD C3 0E 30             jp      RETINT          ; Return the integer
2774+ 25E0
2775+ 25E0              ; returns the X position of the cursor during a print
2776+ 25E0 3A 0C 55     POS:    ld      A,(CURPOS)      ; Get cursor position
2777+ 25E3              ; return the value in A as a number
2778+ 25E3 47           PASSA:  ld      B,A             ; Put A into AB
2779+ 25E4 AF                   xor     A               ; Zero A
2780+ 25E5 C3 D4 25             jp      ABPASS          ; Return integer AB
2781+ 25E8
2782+ 25E8 CD 6B 26     DEF:    call    CHEKFN          ; Get "FN" and name
2783+ 25EB CD 5D 26             call    IDTEST          ; Test for illegal direct
2784+ 25EE 01 02 1F             ld      BC,DATA         ; To get next statement
2785+ 25F1 C5                   push    BC              ; Save address for RETurn
2786+ 25F2 D5                   push    DE              ; Save address of function ptr
2787+ 25F3 CD 10 1B             call    CHKSYN          ; Make sure "(" follows
2788+ 25F6 28                   defb    '('
2789+ 25F7 CD F9 23             call    GETVAR          ; Get argument variable name
2790+ 25FA E5                   push    HL              ; Save code string address
2791+ 25FB EB                   ex      DE,HL           ; Argument address to HL
2792+ 25FC 2B                   dec     HL
2793+ 25FD 56                   ld      D,(HL)          ; Get first byte of arg name
2794+ 25FE 2B                   dec     HL
2795+ 25FF 5E                   ld      E,(HL)          ; Get second byte of arg name
2796+ 2600 E1                   pop     HL              ; Restore code string address
2797+ 2601 CD ED 21             call    TSTNUM          ; Make sure numeric argument
2798+ 2604 CD 10 1B             call    CHKSYN          ; Make sure ")" follows
2799+ 2607 29                   defb    ')'
2800+ 2608 CD 10 1B             call    CHKSYN          ; Make sure "=" follows
2801+ 260B CC                   defb    ZEQUAL          ; "=" token
2802+ 260C 44                   ld      B,H             ; Code string address to BC
2803+ 260D 4D                   ld      C,L
2804+ 260E E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2805+ 260F 71                   ld      (HL),C          ; Save LSB of FN code string
2806+ 2610 23                   inc     HL
2807+ 2611 70                   ld      (HL),B          ; Save MSB of FN code string
2808+ 2612 C3 AA 26             jp      SVSTAD          ; Save address and do function
2809+ 2615
2810+ 2615 CD 6B 26     DOFN:   call    CHEKFN          ; Make sure FN follows
2811+ 2618 D5                   push    DE              ; Save function pointer address
2812+ 2619 CD C1 22             call    EVLPAR          ; Evaluate expression in "()"
2813+ 261C CD ED 21             call    TSTNUM          ; Make sure numeric result
2814+ 261F E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2815+ 2620 5E                   ld      E,(HL)          ; Get LSB of FN code string
2816+ 2621 23                   inc     HL
2817+ 2622 56                   ld      D,(HL)          ; Get MSB of FN code string
2818+ 2623 23                   inc     HL
2819+ 2624 7A                   ld      A,D             ; And function DEFined?
2820+ 2625 B3                   or      E
2821+ 2626 CA 1C 18             jp      Z,UFERR         ; No - ?UF Error
2822+ 2629 7E                   ld      A,(HL)          ; Get LSB of argument address
2823+ 262A 23                   inc     HL
2824+ 262B 66                   ld      H,(HL)          ; Get MSB of argument address
2825+ 262C 6F                   ld      L,A             ; HL = Arg variable address
2826+ 262D E5                   push    HL              ; Save it
2827+ 262E 2A CA 55             ld      HL,(FNRGNM)     ; Get old argument name
2828+ 2631 E3                   ex      (SP),HL         ; Save old , Get new
2829+ 2632 22 CA 55             ld      (FNRGNM),HL     ; Set new argument name
2830+ 2635 2A CE 55             ld      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2831+ 2638 E5                   push    HL              ; Save it
2832+ 2639 2A CC 55             ld      HL,(FNARG)      ; Get MSB,EXP of old arg value
2833+ 263C E5                   push    HL              ; Save it
2834+ 263D 21 CC 55             ld      HL,FNARG        ; HL = Value of argument
2835+ 2640 D5                   push    DE              ; Save FN code string address
2836+ 2641 CD 4F 30             call    FPTHL           ; Move FPREG to argument
2837+ 2644 E1                   pop     HL              ; Get FN code string address
2838+ 2645 CD EA 21             call    GETNUM          ; Get value from function
2839+ 2648 2B                   dec     HL              ; dec 'cos GETCHR INCs
2840+ 2649 CD 59 1D             call    GETCHR          ; Get next character
2841+ 264C C2 10 18             jp      NZ,SNERR        ; Bad character in FN - Error
2842+ 264F E1                   pop     HL              ; Get MSB,EXP of old arg
2843+ 2650 22 CC 55             ld      (FNARG),HL      ; Restore it
2844+ 2653 E1                   pop     HL              ; Get LSB,NLSB of old arg
2845+ 2654 22 CE 55             ld      (FNARG+2),HL    ; Restore it
2846+ 2657 E1                   pop     HL              ; Get name of old arg
2847+ 2658 22 CA 55             ld      (FNRGNM),HL     ; Restore it
2848+ 265B E1                   pop     HL              ; Restore code string address
2849+ 265C C9                   ret
2850+ 265D
2851+ 265D E5           IDTEST: push    HL              ; Save code string address
2852+ 265E 2A 29 54             ld      HL,(LINEAT)     ; Get current line number
2853+ 2661 23                   inc     HL              ; -1 means direct statement
2854+ 2662 7C                   ld      A,H
2855+ 2663 B5                   or      L
2856+ 2664 E1                   pop     HL              ; Restore code string address
2857+ 2665 C0                   ret     NZ              ; Return if in program
2858+ 2666 1E 16                ld      E,ID            ; ?ID Error
2859+ 2668 C3 2A 18             jp      ERROR
2860+ 266B
2861+ 266B CD 10 1B     CHEKFN: call    CHKSYN          ; Make sure FN follows
2862+ 266E BC                   defb    ZFN             ; "FN" token
2863+ 266F 3E 80                ld      A,$80
2864+ 2671 32 51 55             ld      (FORFLG),A      ; Flag FN name to find
2865+ 2674 B6                   or      (HL)            ; FN name has bit 7 set
2866+ 2675 47                   ld      B,A             ; in first byte of name
2867+ 2676 CD FE 23             call    GTFNAM          ; Get FN name
2868+ 2679 C3 ED 21             jp      TSTNUM          ; Make sure numeric function
2869+ 267C
2870+ 267C CD ED 21     STR:    call    TSTNUM          ; Make sure it's a number
2871+ 267F CD 9C 31             call    NUMASC          ; Turn number into text
2872+ 2682 CD B0 26     STR1:   call    CRTST           ; Create string entry for it
2873+ 2685 CD 35 28             call    GSTRCU          ; Current string to pool
2874+ 2688 01 90 28             ld      BC,TOPOOL       ; Save in string pool
2875+ 268B C5                   push    BC              ; Save address on stack
2876+ 268C
2877+ 268C 7E           SAVSTR: ld      A,(HL)          ; Get string length
2878+ 268D 23                   inc     HL
2879+ 268E 23                   inc     HL
2880+ 268F E5                   push    HL              ; Save pointer to string
2881+ 2690 CD 0B 27             call    TESTR           ; See if enough string space
2882+ 2693 E1                   pop     HL              ; Restore pointer to string
2883+ 2694 4E                   ld      C,(HL)          ; Get LSB of address
2884+ 2695 23                   inc     HL
2885+ 2696 46                   ld      B,(HL)          ; Get MSB of address
2886+ 2697 CD A4 26             call    CRTMST          ; Create string entry
2887+ 269A E5                   push    HL              ; Save pointer to MSB of addr
2888+ 269B 6F                   ld      L,A             ; Length of string
2889+ 269C CD 28 28             call    TOSTRA          ; Move to string area
2890+ 269F D1                   pop     DE              ; Restore pointer to MSB
2891+ 26A0 C9                   ret
2892+ 26A1
2893+ 26A1 CD 0B 27     MKTMST: call    TESTR           ; See if enough string space
2894+ 26A4 21 45 55     CRTMST: ld      HL,TMPSTR       ; Temporary string
2895+ 26A7 E5                   push    HL              ; Save it
2896+ 26A8 77                   ld      (HL),A          ; Save length of string
2897+ 26A9 23                   inc     HL
2898+ 26AA 23           SVSTAD: inc     HL
2899+ 26AB 73                   ld      (HL),E          ; Save LSB of address
2900+ 26AC 23                   inc     HL
2901+ 26AD 72                   ld      (HL),D          ; Save MSB of address
2902+ 26AE E1                   pop     HL              ; Restore pointer
2903+ 26AF C9                   ret
2904+ 26B0
2905+ 26B0 2B           CRTST:  dec     HL              ; dec - INCed after
2906+ 26B1 06 22        QTSTR:  ld      B,$22           ; '"'           ; Terminating quote
2907+ 26B3 50                   ld      D,B             ; Quote to D
2908+ 26B4 E5           DTSTR:  push    HL              ; Save start
2909+ 26B5 0E FF                ld      C,-1            ; Set counter to -1
2910+ 26B7 23           QTSTLP: inc     HL              ; Move on
2911+ 26B8 7E                   ld      A,(HL)          ; Get byte
2912+ 26B9 0C                   inc     C               ; Count bytes
2913+ 26BA B7                   or      A               ; End of line?
2914+ 26BB CA C6 26             jp      Z,CRTSTE        ; Yes - Create string entry
2915+ 26BE BA                   cp      D               ; Terminator D found?
2916+ 26BF CA C6 26             jp      Z,CRTSTE        ; Yes - Create string entry
2917+ 26C2 B8                   cp      B               ; Terminator B found?
2918+ 26C3 C2 B7 26             jp      NZ,QTSTLP       ; No - Keep looking
2919+ 26C6 FE 22        CRTSTE: cp      $22             ; '"'             ; End with '"'?
2920+ 26C8 CC 59 1D             call    Z,GETCHR        ; Yes - Get next character
2921+ 26CB E3                   ex      (SP),HL         ; Starting quote
2922+ 26CC 23                   inc     HL              ; First byte of string
2923+ 26CD EB                   ex      DE,HL           ; To DE
2924+ 26CE 79                   ld      A,C             ; Get length
2925+ 26CF CD A4 26             call    CRTMST          ; Create string entry
2926+ 26D2 11 45 55     TSTOPL: ld      DE,TMPSTR       ; Temporary string
2927+ 26D5 2A 37 55             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2928+ 26D8 22 D0 55             ld      (FPREG),HL      ; Save address of string ptr
2929+ 26DB 3E 01                ld      A,$01
2930+ 26DD 32 0E 55             ld      (TYPE),A        ; Set type to string
2931+ 26E0 CD 52 30             call    DETHL4          ; Move string to pool
2932+ 26E3 CD 0A 1B             call    CPDEHL          ; Out of string pool?
2933+ 26E6 22 37 55             ld      (TMSTPT),HL     ; Save new pointer
2934+ 26E9 E1                   pop     HL              ; Restore code string address
2935+ 26EA 7E                   ld      A,(HL)          ; Get next code byte
2936+ 26EB C0                   ret     NZ              ; Return if pool OK
2937+ 26EC 1E 1E                ld      E,ST            ; ?ST Error
2938+ 26EE C3 2A 18             jp      ERROR           ; String pool overflow
2939+ 26F1
2940+ 26F1 23           PRNUMS: inc     HL              ; Skip leading space
2941+ 26F2 CD B0 26     PRS:    call    CRTST           ; Create string entry for it
2942+ 26F5 CD 35 28     PRS1:   call    GSTRCU          ; Current string to pool
2943+ 26F8 CD 46 30             call    LOADFP          ; Move string block to BCDE
2944+ 26FB 1C                   inc     E               ; Length + 1
2945+ 26FC 1D           PRSLP:  dec     E               ; Count characters
2946+ 26FD C8                   ret     Z               ; End of string
2947+ 26FE 0A                   ld      A,(BC)          ; Get byte to output
2948+ 26FF CD 1B 1B             call    OUTC            ; Output character in A
2949+ 2702 FE 0D                cp      CR              ; Return?
2950+ 2704 CC 30 20             call    Z,CNTEND        ; Yes - Position cursor to 0
2951+ 2707 03                   inc     BC              ; Next byte in string
2952+ 2708 C3 FC 26             jp      PRSLP           ; More characters to output
2953+ 270B
2954+ 270B B7           TESTR:  or      A               ; Test if enough room
2955+ 270C 0E                   defb    $0E             ; No garbage collection done
2956+ 270D F1           GRBDON: pop     AF              ; Garbage collection done
2957+ 270E F5                   push    AF              ; Save status
2958+ 270F 2A 27 54             ld      HL,(STRSPC)     ; Bottom of string space in use
2959+ 2712 EB                   ex      DE,HL           ; To DE
2960+ 2713 2A 49 55             ld      HL,(STRBOT)     ; Bottom of string area
2961+ 2716 2F                   cpl                     ; Negate length (Top down)
2962+ 2717 4F                   ld      C,A             ; -Length to BC
2963+ 2718 06 FF                ld      B,-1            ; BC = -ve length of string
2964+ 271A 09                   add     HL,BC           ; Add to bottom of space in use
2965+ 271B 23                   inc     HL              ; Plus one for 2's complement
2966+ 271C CD 0A 1B             call    CPDEHL          ; Below string RAM area?
2967+ 271F DA 29 27             jp      C,TESTOS        ; Tidy up if not done else err
2968+ 2722 22 49 55             ld      (STRBOT),HL     ; Save new bottom of area
2969+ 2725 23                   inc     HL              ; Point to first byte of string
2970+ 2726 EB                   ex      DE,HL           ; Address to DE
2971+ 2727 F1           POPAF:  pop     AF              ; Throw away status push
2972+ 2728 C9                   ret
2973+ 2729
2974+ 2729 F1           TESTOS: pop     AF              ; Garbage collect been done?
2975+ 272A 1E 1A                ld      E,OS            ; ?OS Error
2976+ 272C CA 2A 18             jp      Z,ERROR         ; Yes - Not enough string space
2977+ 272F BF                   cp      A               ; Flag garbage collect done
2978+ 2730 F5                   push    AF              ; Save status
2979+ 2731 01 0D 27             ld      BC,GRBDON       ; Garbage collection done
2980+ 2734 C5                   push    BC              ; Save for RETurn
2981+ 2735 2A 10 55     GARBGE: ld      HL,(LSTRAM)     ; Get end of RAM pointer
2982+ 2738 22 49 55     GARBLP: ld      (STRBOT),HL     ; Reset string pointer
2983+ 273B 21 00 00             ld      HL,$0000
2984+ 273E E5                   push    HL              ; Flag no string found
2985+ 273F 2A 27 54             ld      HL,(STRSPC)     ; Get bottom of string space
2986+ 2742 E5                   push    HL              ; Save bottom of string space
2987+ 2743 21 39 55             ld      HL,TMSTPL       ; Temporary string pool
2988+ 2746 EB           GRBLP:  ex      DE,HL
2989+ 2747 2A 37 55             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2990+ 274A EB                   ex      DE,HL
2991+ 274B CD 0A 1B             call    CPDEHL          ; Temporary string pool done?
2992+ 274E 01 46 27             ld      BC,GRBLP        ; Loop until string pool done
2993+ 2751 C2 9A 27             jp      NZ,STPOOL       ; No - See if in string area
2994+ 2754 2A C2 55             ld      HL,(PROGND)     ; Start of simple variables
2995+ 2757 EB           SMPVAR: ex      DE,HL
2996+ 2758 2A C4 55             ld      HL,(VAREND)     ; End of simple variables
2997+ 275B EB                   ex      DE,HL
2998+ 275C CD 0A 1B             call    CPDEHL          ; All simple strings done?
2999+ 275F CA 6D 27             jp      Z,ARRLP         ; Yes - Do string arrays
3000+ 2762 7E                   ld      A,(HL)          ; Get type of variable
3001+ 2763 23                   inc     HL
3002+ 2764 23                   inc     HL
3003+ 2765 B7                   or      A               ; "S" flag set if string
3004+ 2766 CD 9D 27             call    STRADD          ; See if string in string area
3005+ 2769 C3 57 27             jp      SMPVAR          ; Loop until simple ones done
3006+ 276C
3007+ 276C C1           GNXARY: pop     BC              ; Scrap address of this array
3008+ 276D EB           ARRLP:  ex      DE,HL
3009+ 276E 2A C6 55             ld      HL,(ARREND)     ; End of string arrays
3010+ 2771 EB                   ex      DE,HL
3011+ 2772 CD 0A 1B             call    CPDEHL          ; All string arrays done?
3012+ 2775 CA C3 27             jp      Z,SCNEND        ; Yes - Move string if found
3013+ 2778 CD 46 30             call    LOADFP          ; Get array name to BCDE
3014+ 277B 7B                   ld      A,E             ; Get type of array
3015+ 277C E5                   push    HL              ; Save address of num of dim'ns
3016+ 277D 09                   add     HL,BC           ; Start of next array
3017+ 277E B7                   or      A               ; Test type of array
3018+ 277F F2 6C 27             jp      P,GNXARY        ; Numeric array - Ignore it
3019+ 2782 22 4B 55             ld      (CUROPR),HL     ; Save address of next array
3020+ 2785 E1                   pop     HL              ; Get address of num of dim'ns
3021+ 2786 4E                   ld      C,(HL)          ; BC = Number of dimensions
3022+ 2787 06 00                ld      B,$00
3023+ 2789 09                   add     HL,BC           ; Two bytes per dimension size
3024+ 278A 09                   add     HL,BC
3025+ 278B 23                   inc     HL              ; Plus one for number of dim'ns
3026+ 278C EB           GRBARY: ex      DE,HL
3027+ 278D 2A 4B 55             ld      HL,(CUROPR)     ; Get address of next array
3028+ 2790 EB                   ex      DE,HL
3029+ 2791 CD 0A 1B             call    CPDEHL          ; Is this array finished?
3030+ 2794 CA 6D 27             jp      Z,ARRLP         ; Yes - Get next one
3031+ 2797 01 8C 27             ld      BC,GRBARY       ; Loop until array all done
3032+ 279A C5           STPOOL: push    BC              ; Save return address
3033+ 279B F6 80                or      $80             ; Flag string type
3034+ 279D 7E           STRADD: ld      A,(HL)          ; Get string length
3035+ 279E 23                   inc     HL
3036+ 279F 23                   inc     HL
3037+ 27A0 5E                   ld      E,(HL)          ; Get LSB of string address
3038+ 27A1 23                   inc     HL
3039+ 27A2 56                   ld      D,(HL)          ; Get MSB of string address
3040+ 27A3 23                   inc     HL
3041+ 27A4 F0                   ret     P               ; Not a string - Return
3042+ 27A5 B7                   or      A               ; Set flags on string length
3043+ 27A6 C8                   ret     Z               ; Null string - Return
3044+ 27A7 44                   ld      B,H             ; Save variable pointer
3045+ 27A8 4D                   ld      C,L
3046+ 27A9 2A 49 55             ld      HL,(STRBOT)     ; Bottom of new area
3047+ 27AC CD 0A 1B             call    CPDEHL          ; String been done?
3048+ 27AF 60                   ld      H,B             ; Restore variable pointer
3049+ 27B0 69                   ld      L,C
3050+ 27B1 D8                   ret     C               ; String done - Ignore
3051+ 27B2 E1                   pop     HL              ; Return address
3052+ 27B3 E3                   ex      (SP),HL         ; Lowest available string area
3053+ 27B4 CD 0A 1B             call    CPDEHL          ; String within string area?
3054+ 27B7 E3                   ex      (SP),HL         ; Lowest available string area
3055+ 27B8 E5                   push    HL              ; Re-save return address
3056+ 27B9 60                   ld      H,B             ; Restore variable pointer
3057+ 27BA 69                   ld      L,C
3058+ 27BB D0                   ret     NC              ; Outside string area - Ignore
3059+ 27BC C1                   pop     BC              ; Get return , Throw 2 away
3060+ 27BD F1                   pop     AF              ;
3061+ 27BE F1                   pop     AF              ;
3062+ 27BF E5                   push    HL              ; Save variable pointer
3063+ 27C0 D5                   push    DE              ; Save address of current
3064+ 27C1 C5                   push    BC              ; Put back return address
3065+ 27C2 C9                   ret                     ; Go to it
3066+ 27C3
3067+ 27C3 D1           SCNEND: pop     DE              ; Addresses of strings
3068+ 27C4 E1                   pop     HL              ;
3069+ 27C5 7D                   ld      A,L             ; HL = 0 if no more to do
3070+ 27C6 B4                   or      H
3071+ 27C7 C8                   ret     Z               ; No more to do - Return
3072+ 27C8 2B                   dec     HL
3073+ 27C9 46                   ld      B,(HL)          ; MSB of address of string
3074+ 27CA 2B                   dec     HL
3075+ 27CB 4E                   ld      C,(HL)          ; LSB of address of string
3076+ 27CC E5                   push    HL              ; Save variable address
3077+ 27CD 2B                   dec     HL
3078+ 27CE 2B                   dec     HL
3079+ 27CF 6E                   ld      L,(HL)          ; HL = Length of string
3080+ 27D0 26 00                ld      H,$00
3081+ 27D2 09                   add     HL,BC           ; Address of end of string+1
3082+ 27D3 50                   ld      D,B             ; String address to DE
3083+ 27D4 59                   ld      E,C
3084+ 27D5 2B                   dec     HL              ; Last byte in string
3085+ 27D6 44                   ld      B,H             ; Address to BC
3086+ 27D7 4D                   ld      C,L
3087+ 27D8 2A 49 55             ld      HL,(STRBOT)     ; Current bottom of string area
3088+ 27DB CD BF 17             call    MOVSTR          ; Move string to new address
3089+ 27DE E1                   pop     HL              ; Restore variable address
3090+ 27DF 71                   ld      (HL),C          ; Save new LSB of address
3091+ 27E0 23                   inc     HL
3092+ 27E1 70                   ld      (HL),B          ; Save new MSB of address
3093+ 27E2 69                   ld      L,C             ; Next string area+1 to HL
3094+ 27E3 60                   ld      H,B
3095+ 27E4 2B                   dec     HL              ; Next string area address
3096+ 27E5 C3 38 27             jp      GARBLP          ; Look for more strings
3097+ 27E8
3098+ 27E8 C5           CONCAT: push    BC              ; Save prec' opr & code string
3099+ 27E9 E5                   push    HL              ;
3100+ 27EA 2A D0 55             ld      HL,(FPREG)      ; Get first string
3101+ 27ED E3                   ex      (SP),HL         ; Save first string
3102+ 27EE CD 73 22             call    OPRND           ; Get second string
3103+ 27F1 E3                   ex      (SP),HL         ; Restore first string
3104+ 27F2 CD EE 21             call    TSTSTR          ; Make sure it's a string
3105+ 27F5 7E                   ld      A,(HL)          ; Get length of second string
3106+ 27F6 E5                   push    HL              ; Save first string
3107+ 27F7 2A D0 55             ld      HL,(FPREG)      ; Get second string
3108+ 27FA E5                   push    HL              ; Save second string
3109+ 27FB 86                   add     A,(HL)          ; Add length of second string
3110+ 27FC 1E 1C                ld      E,LS            ; ?LS Error
3111+ 27FE DA 2A 18             jp      C,ERROR         ; String too long - Error
3112+ 2801 CD A1 26             call    MKTMST          ; Make temporary string
3113+ 2804 D1                   pop     DE              ; Get second string to DE
3114+ 2805 CD 39 28             call    GSTRDE          ; Move to string pool if needed
3115+ 2808 E3                   ex      (SP),HL         ; Get first string
3116+ 2809 CD 38 28             call    GSTRHL          ; Move to string pool if needed
3117+ 280C E5                   push    HL              ; Save first string
3118+ 280D 2A 47 55             ld      HL,(TMPSTR+2)   ; Temporary string address
3119+ 2810 EB                   ex      DE,HL           ; To DE
3120+ 2811 CD 1F 28             call    SSTSA           ; First string to string area
3121+ 2814 CD 1F 28             call    SSTSA           ; Second string to string area
3122+ 2817 21 08 22             ld      HL,EVAL2        ; Return to evaluation loop
3123+ 281A E3                   ex      (SP),HL         ; Save return,get code string
3124+ 281B E5                   push    HL              ; Save code string address
3125+ 281C C3 D2 26             jp      TSTOPL          ; To temporary string to pool
3126+ 281F
3127+ 281F E1           SSTSA:  pop     HL              ; Return address
3128+ 2820 E3                   ex      (SP),HL         ; Get string block,save return
3129+ 2821 7E                   ld      A,(HL)          ; Get length of string
3130+ 2822 23                   inc     HL
3131+ 2823 23                   inc     HL
3132+ 2824 4E                   ld      C,(HL)          ; Get LSB of string address
3133+ 2825 23                   inc     HL
3134+ 2826 46                   ld      B,(HL)          ; Get MSB of string address
3135+ 2827 6F                   ld      L,A             ; Length to L
3136+ 2828 2C           TOSTRA: inc     L               ; inc - DECed after
3137+ 2829 2D           TSALP:  dec     L               ; Count bytes moved
3138+ 282A C8                   ret     Z               ; End of string - Return
3139+ 282B 0A                   ld      A,(BC)          ; Get source
3140+ 282C 12                   ld      (DE),A          ; Save destination
3141+ 282D 03                   inc     BC              ; Next source
3142+ 282E 13                   inc     DE              ; Next destination
3143+ 282F C3 29 28             jp      TSALP           ; Loop until string moved
3144+ 2832
3145+ 2832 CD EE 21     GETSTR: call    TSTSTR          ; Make sure it's a string
3146+ 2835 2A D0 55     GSTRCU: ld      HL,(FPREG)      ; Get current string
3147+ 2838 EB           GSTRHL: ex      DE,HL           ; Save DE
3148+ 2839 CD 53 28     GSTRDE: call    BAKTMP          ; Was it last tmp-str?
3149+ 283C EB                   ex      DE,HL           ; Restore DE
3150+ 283D C0                   ret     NZ              ; No - Return
3151+ 283E D5                   push    DE              ; Save string
3152+ 283F 50                   ld      D,B             ; String block address to DE
3153+ 2840 59                   ld      E,C
3154+ 2841 1B                   dec     DE              ; Point to length
3155+ 2842 4E                   ld      C,(HL)          ; Get string length
3156+ 2843 2A 49 55             ld      HL,(STRBOT)     ; Current bottom of string area
3157+ 2846 CD 0A 1B             call    CPDEHL          ; Last one in string area?
3158+ 2849 C2 51 28             jp      NZ,POPHL        ; No - Return
3159+ 284C 47                   ld      B,A             ; Clear B (A=0)
3160+ 284D 09                   add     HL,BC           ; Remove string from str' area
3161+ 284E 22 49 55             ld      (STRBOT),HL     ; Save new bottom of str' area
3162+ 2851 E1           POPHL:  pop     HL              ; Restore string
3163+ 2852 C9                   ret
3164+ 2853
3165+ 2853 2A 37 55     BAKTMP: ld      HL,(TMSTPT)     ; Get temporary string pool top
3166+ 2856 2B                   dec     HL              ; Back
3167+ 2857 46                   ld      B,(HL)          ; Get MSB of address
3168+ 2858 2B                   dec     HL              ; Back
3169+ 2859 4E                   ld      C,(HL)          ; Get LSB of address
3170+ 285A 2B                   dec     HL              ; Back
3171+ 285B 2B                   dec     HL              ; Back
3172+ 285C CD 0A 1B             call    CPDEHL          ; String last in string pool?
3173+ 285F C0                   ret     NZ              ; Yes - Leave it
3174+ 2860 22 37 55             ld      (TMSTPT),HL     ; Save new string pool top
3175+ 2863 C9                   ret
3176+ 2864
3177+ 2864 01 E3 25     LEN:    ld      BC,PASSA        ; To return integer A
3178+ 2867 C5                   push    BC              ; Save address
3179+ 2868 CD 32 28     GETLEN: call    GETSTR          ; Get string and its length
3180+ 286B AF                   xor     A
3181+ 286C 57                   ld      D,A             ; Clear D
3182+ 286D 32 0E 55             ld      (TYPE),A        ; Set type to numeric
3183+ 2870 7E                   ld      A,(HL)          ; Get length of string
3184+ 2871 B7                   or      A               ; Set status flags
3185+ 2872 C9                   ret
3186+ 2873
3187+ 2873 01 E3 25     ASC:    ld      BC,PASSA        ; To return integer A
3188+ 2876 C5                   push    BC              ; Save address
3189+ 2877 CD 68 28     GTFLNM: call    GETLEN          ; Get length of string
3190+ 287A CA 24 1E             jp      Z,FCERR         ; Null string - Error
3191+ 287D 23                   inc     HL
3192+ 287E 23                   inc     HL
3193+ 287F 5E                   ld      E,(HL)          ; Get LSB of address
3194+ 2880 23                   inc     HL
3195+ 2881 56                   ld      D,(HL)          ; Get MSB of address
3196+ 2882 1A                   ld      A,(DE)          ; Get first byte of string
3197+ 2883 C9                   ret
3198+ 2884
3199+ 2884 3E 01        CHR:    ld      A,$01           ; One character string
3200+ 2886 CD A1 26             call    MKTMST          ; Make a temporary string
3201+ 2889 CD 73 2A             call    MAKINT          ; Make it integer A
3202+ 288C 2A 47 55             ld      HL,(TMPSTR+2)   ; Get address of string
3203+ 288F 73                   ld      (HL),E          ; Save character
3204+ 2890 C1           TOPOOL: pop     BC              ; Clean up stack
3205+ 2891 C3 D2 26             jp      TSTOPL          ; Temporary string to pool
3206+ 2894
3207+ 2894 CD 23 2A     LEFT:   call    LFRGNM          ; Get number and ending ")"
3208+ 2897 AF                   xor     A               ; Start at first byte in string
3209+ 2898 E3           RIGHT1: ex      (SP),HL         ; Save code string,Get string
3210+ 2899 4F                   ld      C,A             ; Starting position in string
3211+ 289A E5           MID1:   push    HL              ; Save string block address
3212+ 289B 7E                   ld      A,(HL)          ; Get length of string
3213+ 289C B8                   cp      B               ; Compare with number given
3214+ 289D DA A2 28             jp      C,ALLFOL        ; All following bytes required
3215+ 28A0 78                   ld      A,B             ; Get new length
3216+ 28A1 11                   defb    $11             ; Skip "ld C,0"
3217+ 28A2 0E 00        ALLFOL: ld      C,$00           ; First byte of string
3218+ 28A4 C5                   push    BC              ; Save position in string
3219+ 28A5 CD 0B 27             call    TESTR           ; See if enough string space
3220+ 28A8 C1                   pop     BC              ; Get position in string
3221+ 28A9 E1                   pop     HL              ; Restore string block address
3222+ 28AA E5                   push    HL              ; And re-save it
3223+ 28AB 23                   inc     HL
3224+ 28AC 23                   inc     HL
3225+ 28AD 46                   ld      B,(HL)          ; Get LSB of address
3226+ 28AE 23                   inc     HL
3227+ 28AF 66                   ld      H,(HL)          ; Get MSB of address
3228+ 28B0 68                   ld      L,B             ; HL = address of string
3229+ 28B1 06 00                ld      B,$00           ; BC = starting address
3230+ 28B3 09                   add     HL,BC           ; Point to that byte
3231+ 28B4 44                   ld      B,H             ; BC = source string
3232+ 28B5 4D                   ld      C,L
3233+ 28B6 CD A4 26             call    CRTMST          ; Create a string entry
3234+ 28B9 6F                   ld      L,A             ; Length of new string
3235+ 28BA CD 28 28             call    TOSTRA          ; Move string to string area
3236+ 28BD D1                   pop     DE              ; Clear stack
3237+ 28BE CD 39 28             call    GSTRDE          ; Move to string pool if needed
3238+ 28C1 C3 D2 26             jp      TSTOPL          ; Temporary string to pool
3239+ 28C4
3240+ 28C4
3241+ 28C4              ; INSTR statement - look for a string inside another string
3242+ 28C4              ; usage: INSTR(A$,B$) -> search for B$ into A$
3243+ 28C4              ; return 0 if B$ is not found into A$, or LEN(A$)<LEN(B$)
3244+ 28C4              ; return 1~255 to indicate the starting position of B$ into A$
3245+ 28C4              ; ex.: INSTR("HELLO","LO") returns 4 - INSTR("HOME","PC") returns 0
3246+ 28C4              LNS1    equ     TMPBFR1
3247+ 28C4              ADRS1   equ     TMPBFR2
3248+ 28C4              LNS2    equ     TMPBFR3
3249+ 28C4              ADRS2   equ     TMPBFR4
3250+ 28C4              PT      equ     VIDEOBUFF
3251+ 28C4              PT1     equ     VIDEOBUFF+2
3252+ 28C4              PT2     equ     VIDEOBUFF+4
3253+ 28C4              TP      equ     VIDEOBUFF+6
3254+ 28C4              TF      equ     VIDEOBUFF+8
3255+ 28C4 CD 10 1B     INSTR:  call    CHKSYN          ; make sure "(" follows
3256+ 28C7 28                   defb    '('
3257+ 28C8 2B                   dec     HL              ; dec 'cause GETCHR increments
3258+ 28C9 CD 59 1D             call    GETCHR          ; check if something follows
3259+ 28CC CA 10 18             jp      Z,SNERR         ; if nothing else, raise a syntax error
3260+ 28CF CD FC 21             call    EVAL            ; Evaluate expression
3261+ 28D2 CD EE 21             call    TSTSTR          ; Make sure it's a string
3262+ 28D5 22 84 55             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3263+ 28D8 CD 35 28             call    GSTRCU          ; check that a string follows
3264+ 28DB CD 46 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3265+ 28DE ED 53 7C 55          ld      (LNS1),DE       ; store values into
3266+ 28E2 ED 43 7E 55          ld      (ADRS1),BC      ; temp buffers
3267+ 28E6 2A 84 55             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3268+ 28E9 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
3269+ 28EC 2C                   defb    ','
3270+ 28ED 2B                   dec     HL              ; dec 'cause GETCHR increments
3271+ 28EE CD 59 1D             call    GETCHR          ; check if something follows
3272+ 28F1 CA 10 18             jp      Z,SNERR         ; if nothing else, raise a syntax error
3273+ 28F4 CD FC 21             call    EVAL            ; Evaluate expression
3274+ 28F7 CD EE 21             call    TSTSTR          ; Make sure it's a string
3275+ 28FA 22 84 55             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3276+ 28FD CD 35 28             call    GSTRCU          ; check that a string follows
3277+ 2900 CD 46 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3278+ 2903 ED 53 80 55          ld      (LNS2),DE       ; store values into
3279+ 2907 ED 43 82 55          ld      (ADRS2),BC      ; temp buffers
3280+ 290B 2A 84 55             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3281+ 290E CD 10 1B             call    CHKSYN          ; make sure ")" follows
3282+ 2911 29                   defb    ')'
3283+ 2912 E5                   push    HL              ; store current code string pointer (the point after the ")" ) ...
3284+ 2913 FD E1                pop     IY              ; ...into IY
3285+ 2915 AF                   xor     A               ; reset 10 RAM cells
3286+ 2916 06 0A                ld      B,$0A           ; (INSTR registers)
3287+ 2918 21 84 55             ld      HL,PT           ; first cell
3288+ 291B 77           EMPTINS:ld      (HL),A          ; reset cell
3289+ 291C 23                   inc     HL              ; next cell
3290+ 291D 10 FC                djnz    EMPTINS         ; repeat
3291+ 291F ED 5B 80 55          ld      DE,(LNS2)       ; load len(S2) into DE
3292+ 2923 2A 7C 55             ld      HL,(LNS1)       ; load len(S1) into HL
3293+ 2926 CD 35 41             call    CMP16           ; check that len(S1)>=len(S2)
3294+ 2929 DA 9E 29             jp      C,RZINSTR       ; if len(S2)>len(S1) then return 0
3295+ 292C AF           RPTINST:xor     A               ; reset...
3296+ 292D 32 8A 55             ld      (TP),A          ; ...TP...
3297+ 2930 32 8C 55             ld      (TF),A          ; ...and TF
3298+ 2933 ED 4B 84 55          ld      BC,(PT)         ; pointer to S1
3299+ 2937 2A 7E 55             ld      HL,(ADRS1)      ; first cell of S1
3300+ 293A 09                   add     HL,BC           ; get current position into RAM
3301+ 293B 7E                   ld      A,(HL)          ; load S1(PT)
3302+ 293C 2A 82 55             ld      HL,(ADRS2)      ; pointer to first char of S2
3303+ 293F BE                   cp      (HL)            ; is S1(PT)=S2(0)?
3304+ 2940 20 3A                jr      NZ,CNT1INS      ; no, continue
3305+ 2942 3A 84 55             ld      A,(PT)          ; load current PT
3306+ 2945 32 8A 55             ld      (TP),A          ; TP=PT
3307+ 2948 32 86 55             ld      (PT1),A         ; P1=PT
3308+ 294B AF                   xor     A               ; set...
3309+ 294C 32 88 55             ld      (PT2),A         ; ...PT2=0
3310+ 294F 3C                   inc     A               ;
3311+ 2950 32 8C 55             ld      (TF),A          ; set TF=1
3312+ 2953 ED 4B 86 55  RP2INST:ld      BC,(PT1)        ; load pointer PT1
3313+ 2957 2A 7E 55             ld      HL,(ADRS1)      ; load address of S1
3314+ 295A 09                   add     HL,BC           ; find char of S1 pointed by PT1
3315+ 295B 7E                   ld      A,(HL)          ; load S1(PT1)
3316+ 295C ED 4B 88 55          ld      BC,(PT2)        ; load pointer PT2
3317+ 2960 2A 82 55             ld      HL,(ADRS2)      ; load char of S2 pointed by PT2
3318+ 2963 09                   add     HL,BC           ; find S2(PT2)
3319+ 2964 BE                   cp      (HL)            ; is S1(PT1)=S2(PT2)?
3320+ 2965 20 4C                jr      NZ,CNTZIN       ; no, exit inner loop
3321+ 2967 21 86 55             ld      HL,PT1
3322+ 296A 34                   inc     (HL)            ; increment PT1
3323+ 296B 3A 88 55             ld      A,(PT2)
3324+ 296E 3C                   inc     A               ; increment PT2
3325+ 296F 32 88 55             ld      (PT2),A
3326+ 2972 CA 7C 29             jp      Z,CNT1INS       ; if PT2>255 then exit
3327+ 2975 21 80 55             ld      HL,LNS2         ; len(S2)
3328+ 2978 BE                   cp      (HL)            ; PT2=len(S2)?
3329+ 2979 DA 53 29             jp      C,RP2INST       ; no (PT2<len(S2) - repeat
3330+ 297C 3A 8C 55     CNT1INS:ld      A,(TF)          ; check TF
3331+ 297F A7                   and     A               ; TF=0? (clears also Carry for next SBC)
3332+ 2980 20 1C                jr      NZ,RZINSTR      ; no, exit
3333+ 2982 2A 7C 55             ld      HL,(LNS1)       ; load len(S1)
3334+ 2985 ED 4B 80 55          ld      BC,(LNS2)       ; load len(S2)
3335+ 2989 ED 42                sbc     HL,BC           ; HL=len(S1)-len(S2)
3336+ 298B ED 5B 84 55          ld      DE,(PT)         ; load pointer
3337+ 298F 1C                   inc     E               ; PT=PT+1
3338+ 2990 ED 53 84 55          ld      (PT),DE         ; store new value
3339+ 2994 EB                   ex      DE,HL           ; invert registers
3340+ 2995 CD 35 41             call    CMP16           ; check if PT>len(S1)-len(S2)
3341+ 2998 DA 2C 29             jp      C,RPTINST       ; repeat if <
3342+ 299B CA 2C 29             jp      Z,RPTINST       ; repeat if =
3343+ 299E 3A 8C 55     RZINSTR:ld      A,(TF)          ; current value of TF
3344+ 29A1 A7                   and     A               ; is it 0?
3345+ 29A2 CA A9 29             jp      Z,LVINSTR       ; yes, return 0
3346+ 29A5 3A 8A 55             ld      A,(TP)          ; return TP...
3347+ 29A8 3C                   inc     A               ; ...incremented by 1
3348+ 29A9 E1           LVINSTR:pop     HL              ; drop original return point
3349+ 29AA FD E5                push    IY              ; load current string address from IY into stack
3350+ 29AC 11 D5 22             ld      DE,RETNUM       ; Address of Return number from function...
3351+ 29AF D5                   push    DE              ; ...saved on stack
3352+ 29B0 C3 E3 25             jp      PASSA           ; return TP
3353+ 29B3 AF           CNTZIN: xor     A               ; set...
3354+ 29B4 32 8C 55             ld      (TF),A          ; TF=0
3355+ 29B7 C3 7C 29             jp      CNT1INS         ; continue
3356+ 29BA
3357+ 29BA
3358+ 29BA              ; returns the right portion of a string
3359+ 29BA CD 23 2A     RIGHT:  call    LFRGNM          ; Get number and ending ")"
3360+ 29BD D1                   pop     DE              ; Get string length
3361+ 29BE D5                   push    DE              ; And re-save
3362+ 29BF 1A                   ld      A,(DE)          ; Get length
3363+ 29C0 90                   sub     B               ; Move back N bytes
3364+ 29C1 C3 98 28             jp      RIGHT1          ; Go and get sub-string
3365+ 29C4
3366+ 29C4              ; returns a piece of a string
3367+ 29C4 EB           MID:    ex      DE,HL           ; Get code string address
3368+ 29C5 7E                   ld      A,(HL)          ; Get next byte ',' or ")"
3369+ 29C6 CD 28 2A             call    MIDNUM          ; Get number supplied
3370+ 29C9 04                   inc     B               ; Is it character zero?
3371+ 29CA 05                   dec     B
3372+ 29CB CA 24 1E             jp      Z,FCERR         ; Yes - Error
3373+ 29CE C5                   push    BC              ; Save starting position
3374+ 29CF 1E FF                ld      E,$FF           ; All of string
3375+ 29D1 FE 29                cp      ')'             ; Any length given?
3376+ 29D3 CA DD 29             jp      Z,RSTSTR        ; No - Rest of string
3377+ 29D6 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
3378+ 29D9 2C                   defb    ','
3379+ 29DA CD 70 2A             call    GETINT          ; Get integer 0-255
3380+ 29DD CD 10 1B     RSTSTR: call    CHKSYN          ; Make sure ")" follows
3381+ 29E0 29                   defb    ')'
3382+ 29E1 F1                   pop     AF              ; Restore starting position
3383+ 29E2 E3                   ex      (SP),HL         ; Get string,save code string
3384+ 29E3 01 9A 28             ld      BC,MID1         ; Continuation of MID$ routine
3385+ 29E6 C5                   push    BC              ; Save for return
3386+ 29E7 3D                   dec     A               ; Starting position-1
3387+ 29E8 BE                   cp      (HL)            ; Compare with length
3388+ 29E9 06 00                ld      B,$00           ; Zero bytes length
3389+ 29EB D0                   ret     NC              ; Null string if start past end
3390+ 29EC 4F                   ld      C,A             ; Save starting position-1
3391+ 29ED 7E                   ld      A,(HL)          ; Get length of string
3392+ 29EE 91                   sub     C               ; Subtract start
3393+ 29EF BB                   cp      E               ; Enough string for it?
3394+ 29F0 47                   ld      B,A             ; Save maximum length available
3395+ 29F1 D8                   ret     C               ; Truncate string if needed
3396+ 29F2 43                   ld      B,E             ; Set specified length
3397+ 29F3 C9                   ret                     ; Go and create string
3398+ 29F4
3399+ 29F4
3400+ 29F4              ; return the value of a numeric string
3401+ 29F4 CD 68 28     VAL:    call    GETLEN          ; Get length of string
3402+ 29F7 CA C6 2D             jp      Z,RESZER        ; Result zero
3403+ 29FA 5F                   ld      E,A             ; Save length
3404+ 29FB 23                   inc     HL
3405+ 29FC 23                   inc     HL
3406+ 29FD 7E                   ld      A,(HL)          ; Get LSB of address
3407+ 29FE 23                   inc     HL
3408+ 29FF 66                   ld      H,(HL)          ; Get MSB of address
3409+ 2A00 6F                   ld      L,A             ; HL = String address
3410+ 2A01 E5                   push    HL              ; Save string address
3411+ 2A02 19                   add     HL,DE
3412+ 2A03 46                   ld      B,(HL)          ; Get end of string+1 byte
3413+ 2A04 72                   ld      (HL),D          ; Zero it to terminate
3414+ 2A05 E3                   ex      (SP),HL         ; Save string end,get start
3415+ 2A06 C5                   push    BC              ; Save end+1 byte
3416+ 2A07 7E                   ld      A,(HL)          ; Get starting byte
3417+ 2A08 FE 24                cp      '$'             ; Hex number indicated? [function added]
3418+ 2A0A C2 12 2A             jp      NZ,VAL1
3419+ 2A0D CD 68 40             call    HEXTFP          ; Convert Hex to FPREG
3420+ 2A10 18 0D                jr      VAL3
3421+ 2A12 FE 25        VAL1:   cp      '%'             ; Binary number indicated? [function added]
3422+ 2A14 C2 1C 2A             jp      NZ,VAL2
3423+ 2A17 CD D8 40             call    BINTFP          ; Convert Bin to FPREG
3424+ 2A1A 18 03                jr      VAL3
3425+ 2A1C CD FE 30     VAL2:   call    ASCTFP          ; Convert ASCII string to FP
3426+ 2A1F C1           VAL3:   pop     BC              ; Restore end+1 byte
3427+ 2A20 E1                   pop     HL              ; Restore end+1 address
3428+ 2A21 70                   ld      (HL),B          ; Put back original byte
3429+ 2A22 C9                   ret
3430+ 2A23
3431+ 2A23 EB           LFRGNM: ex      DE,HL           ; Code string address to HL
3432+ 2A24 CD 10 1B             call    CHKSYN          ; Make sure ")" follows
3433+ 2A27 29                   defb    ')'
3434+ 2A28 C1           MIDNUM: pop     BC              ; Get return address
3435+ 2A29 D1                   pop     DE              ; Get number supplied
3436+ 2A2A C5                   push    BC              ; Re-save return address
3437+ 2A2B 43                   ld      B,E             ; Number to B
3438+ 2A2C C9                   ret
3439+ 2A2D
3440+ 2A2D CD 73 2A     INP:    call    MAKINT          ; Make it integer A
3441+ 2A30 32 1A 54             ld      (INPORT),A      ; Set input port
3442+ 2A33 CD 19 54             call    INPSUB          ; Get input from port
3443+ 2A36 C3 E3 25             jp      PASSA           ; Return integer A
3444+ 2A39
3445+ 2A39 CD 5D 2A     POUT:   call    SETIO           ; Set up port number
3446+ 2A3C C3 E1 53             jp      OUTSUB          ; Output data and return
3447+ 2A3F
3448+ 2A3F CD 5D 2A     WAIT:   call    SETIO           ; Set up port number
3449+ 2A42 F5                   push    AF              ; Save AND mask
3450+ 2A43 1E 00                ld      E,$00           ; Assume zero if none given
3451+ 2A45 2B                   dec     HL              ; dec 'cos GETCHR INCs
3452+ 2A46 CD 59 1D             call    GETCHR          ; Get next character
3453+ 2A49 CA 53 2A             jp      Z,NOXOR         ; No XOR byte given
3454+ 2A4C CD 10 1B             call    CHKSYN          ; Make sure ',' follows
3455+ 2A4F 2C                   defb    ','
3456+ 2A50 CD 70 2A             call    GETINT          ; Get integer 0-255 to XOR with
3457+ 2A53 C1           NOXOR:  pop     BC              ; Restore AND mask
3458+ 2A54 CD 19 54     WAITLP: call    INPSUB          ; Get input
3459+ 2A57 AB                   xor     E               ; Flip selected bits
3460+ 2A58 A0                   and     B               ; Result non-zero?
3461+ 2A59 CA 54 2A             jp      Z,WAITLP        ; No = keep waiting
3462+ 2A5C C9                   ret
3463+ 2A5D
3464+ 2A5D CD 70 2A     SETIO:  call    GETINT          ; Get integer 0-255
3465+ 2A60 32 1A 54             ld      (INPORT),A      ; Set input port
3466+ 2A63 32 E2 53             ld      (OTPORT),A      ; Set output port
3467+ 2A66 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
3468+ 2A69 2C                   defb    ','
3469+ 2A6A C3 70 2A             jp      GETINT          ; Get integer 0-255 and return
3470+ 2A6D
3471+ 2A6D CD 59 1D     FNDNUM: call    GETCHR          ; Get next character
3472+ 2A70 CD EA 21     GETINT: call    GETNUM          ; Get a number from 0 to 255
3473+ 2A73 CD 09 1E     MAKINT: call    DEPINT          ; Make sure value 0 - 255
3474+ 2A76 7A                   ld      A,D             ; Get MSB of number
3475+ 2A77 B7                   or      A               ; Zero?
3476+ 2A78 C2 24 1E             jp      NZ,FCERR        ; No - Error
3477+ 2A7B 2B                   dec     HL              ; dec 'cos GETCHR INCs
3478+ 2A7C CD 59 1D             call    GETCHR          ; Get next character
3479+ 2A7F 7B                   ld      A,E             ; Get number to A
3480+ 2A80 C9                   ret
3481+ 2A81
3482+ 2A81
3483+ 2A81              ; activate a Non-Maskable Interrupt hooked to VDP interrupt signal
3484+ 2A81              ; address must point to an ISR routine that terminates with EI/RETN instructions
3485+ 2A81 CD EA 21     NMI:    call    GETNUM          ; Get memory address
3486+ 2A84 CD 0F 1E             call    DEINT           ; get integer -32768 to 32767
3487+ 2A87 7B                   ld      A,E             ; check if address is 0
3488+ 2A88 B2                   or      D
3489+ 2A89 20 11                jr      NZ,NM1          ; no, so jump over
3490+ 2A8B F3           DISNMI: di                      ; disable INTs
3491+ 2A8C CD B8 2A             call    NMIDINT         ; disable VDP INT
3492+ 2A8F E5                   push    HL              ; store HL
3493+ 2A90 21 ED 45             ld      HL,$45ED        ; these are the op-codes for "RETN"
3494+ 2A93 22 DB 53             ld      (NMIUSR),HL     ; store RETN
3495+ 2A96 AF                   xor     A
3496+ 2A97 32 DD 53             ld      (NMIUSR+2),A    ; "NOP"
3497+ 2A9A 18 11                jr      NMI2            ; execute the last part of code
3498+ 2A9C E5           NM1:    push    HL              ; store current HL
3499+ 2A9D EB                   ex      DE,HL           ; move address argument into HL
3500+ 2A9E F3                   di                      ; disable INTs
3501+ 2A9F CD B8 2A             call    NMIDINT         ; disable VDP INT, if enabled
3502+ 2AA2 3E C3                ld      A,$C3           ; "jp" instruction
3503+ 2AA4 32 DB 53             ld      (NMIUSR),A      ; store it
3504+ 2AA7 22 DC 53             ld      (NMIUSR+1),HL   ; store address
3505+ 2AAA CD B1 2A             call    NMIEINT         ; re-enable VDP INT
3506+ 2AAD FB           NMI2:   ei                      ; re-enable INTS
3507+ 2AAE 00                   nop                     ; wait for INTs
3508+ 2AAF E1                   pop    HL               ; retrieve HL
3509+ 2AB0 C9                   ret                     ; return to caller
3510+ 2AB1              ; enable VDP INT
3511+ 2AB1 CD C7 2A     NMIEINT:call    NMIVR1          ; load default VReg #1 setting
3512+ 2AB4 F6 20                or      %00100000       ; enable VDP INT
3513+ 2AB6 18 03                jr      NMIINT          ; rest of code is shared
3514+ 2AB8              ; disable VDP INT
3515+ 2AB8 CD C7 2A     NMIDINT:call    NMIVR1          ; load default VReg #1 setting
3516+ 2ABB D5           NMIINT: push    DE              ; store DE
3517+ 2ABC 5F                   ld      E,A             ; move value into E
3518+ 2ABD 3E 01                ld      A,$01           ; VREG #1
3519+ 2ABF F3                   di                      ; disable INTs
3520+ 2AC0 CD B3 06             call    WRITE_VREG      ; disable VDP INT
3521+ 2AC3 FB                   ei                      ; re-enable INTs
3522+ 2AC4 00                   nop                     ; wait for INTs being enabled
3523+ 2AC5 D1                   pop     DE              ; retrieve DE
3524+ 2AC6 C9                   ret                     ; return to caller
3525+ 2AC7
3526+ 2AC7              ; load VREG #1 setting for current screen mode and return it into A
3527+ 2AC7 E5           NMIVR1: push    HL              ; store HL
3528+ 2AC8 D5                   push    DE              ; store DE
3529+ 2AC9 3A 6E 55             ld      A,(SCR_MODE)    ; check screen mode
3530+ 2ACC 87                   add     A,A             ; multiply A by 8...
3531+ 2ACD 87                   add     A,A             ; ...so that reg. A can points..
3532+ 2ACE 87                   add     A,A             ; to the correct settings
3533+ 2ACF 3C                   inc     A               ; need to change VREG 1
3534+ 2AD0 5F                   ld      E,A             ; copy A into E
3535+ 2AD1 16 00                ld      D,$00           ; reset D
3536+ 2AD3 21 22 0B             ld      HL,VDPMODESET   ; pointer to register #1 setting...
3537+ 2AD6 19                   add     HL,DE           ; ...for current screen mode
3538+ 2AD7 7E                   ld      A,(HL)          ; load current setting
3539+ 2AD8 D1                   pop     DE              ; retrieve DE
3540+ 2AD9 E1                   pop     HL              ; retrieve HL
3541+ 2ADA C9                   ret                     ; return to caller
3542+ 2ADB
3543+ 2ADB              ; execute a machine language routine, eventually passing a param into A
3544+ 2ADB CD EA 21     SYS:    call    GETNUM          ; Get memory address
3545+ 2ADE CD 0F 1E             call    DEINT           ; Get integer -32768 to 32767
3546+ 2AE1 ED 53 7E 55          ld      (TMPBFR2),DE    ; store user routine's address
3547+ 2AE5 AF                   xor     A               ; reset A
3548+ 2AE6 32 7C 55             ld      (TMPBFR1),A     ; store into temp buffer
3549+ 2AE9 2B                   dec     HL              ; dec 'cos GETCHR INCs
3550+ 2AEA CD 59 1D             call    GETCHR          ; check next character
3551+ 2AED 28 0A                jr      Z,NOSYSPR       ; jump if nothing follows
3552+ 2AEF CD 10 1B             call    CHKSYN          ; Make sure ',' follows
3553+ 2AF2 2C                   defb    ','
3554+ 2AF3 CD 70 2A             call    GETINT          ; get byte value (0~255) if something follows
3555+ 2AF6 32 7C 55             ld      (TMPBFR1),A     ; store into temp buffer
3556+ 2AF9 3A 7C 55     NOSYSPR:ld      A,(TMPBFR1)     ; recover A
3557+ 2AFC ED 5B 7E 55          ld      DE,(TMPBFR2)    ; recover user routine's address
3558+ 2B00 E5                   push    HL              ; save code string address
3559+ 2B01 EB                   ex      DE,HL           ; move user routine's address into HL
3560+ 2B02 11 07 2B             ld      DE,SYSRET       ; set point of return after the user routine
3561+ 2B05 D5                   push    DE              ; store into stack
3562+ 2B06 E9                   jp      (HL)            ; call user routine
3563+ 2B07 E1           SYSRET: pop     HL              ; retrieve code string address
3564+ 2B08 C9                   ret                     ; return to caller
3565+ 2B09
3566+ 2B09
3567+ 2B09              ; read the contents of a RAM location
3568+ 2B09 CD 0F 1E     PEEK:   call    DEINT           ; Get memory address into DE
3569+ 2B0C 1A                   ld      A,(DE)          ; Read value of memory cell
3570+ 2B0D C3 E3 25             jp      PASSA           ; Return into A
3571+ 2B10
3572+ 2B10              ; read the contents of a VRAM location
3573+ 2B10 CD 0F 1E     VPEEK:  call    DEINT           ; Get VRAM address into DE
3574+ 2B13 EB                   ex      DE,HL           ; Copy param into HL
3575+ 2B14 F3                   di                      ; Disable interrupts
3576+ 2B15 CD 89 06             call    READ_VIDEO_LOC  ; Read data from VRAM at address HL
3577+ 2B18 FB                   ei                      ; Re-enable interrupts
3578+ 2B19 EB                   ex      DE,HL           ; Restore HL
3579+ 2B1A C3 E3 25             jp      PASSA           ; Return value into A
3580+ 2B1D
3581+ 2B1D              ; recover params for POKE/VPOKE commands
3582+ 2B1D              ; returns address into DE and byte to be written into A
3583+ 2B1D CD EA 21     PKEPRMS:call    GETNUM          ; Get memory address
3584+ 2B20 CD 0F 1E             call    DEINT           ; Get integer -32768 to 32767
3585+ 2B23 ED 53 7C 55          ld      (TMPBFR1),DE    ; Store DE into a temp. buffer
3586+ 2B27 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
3587+ 2B2A 2C                   defb    ','
3588+ 2B2B CD 70 2A             call    GETINT          ; Get integer 0-255
3589+ 2B2E ED 5B 7C 55          ld      DE,(TMPBFR1)    ; Restore memory address
3590+ 2B32 C9                   ret                     ; Return to caller
3591+ 2B33
3592+ 2B33              ; write a byte into a RAM location
3593+ 2B33 CD 1D 2B     POKE:   call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3594+ 2B36 12                   ld      (DE),A          ; Load it into memory
3595+ 2B37 C9                   ret
3596+ 2B38
3597+ 2B38              ; write a byte into a VRAM location
3598+ 2B38 CD 1D 2B     VPOKE:  call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3599+ 2B3B EB                   ex      DE,HL           ; Copy address into HL
3600+ 2B3C F3                   di                      ; Disable interrupts
3601+ 2B3D CD 9E 06             call    WRITE_VIDEO_LOC ; write data into VRAM at address HL
3602+ 2B40 FB                   ei                      ; Re-enable interrupts
3603+ 2B41 EB                   ex      DE,HL           ; Restore HL
3604+ 2B42 C9                   ret                     ; Return to caller
3605+ 2B43
3606+ 2B43              ; position the cursor at a specific X,Y location onto screen
3607+ 2B43 CD 70 2A     LOCATE: call    GETINT          ; get the first param into A
3608+ 2B46 E5                   push    HL              ; store HL
3609+ 2B47 21 6C 55             ld      HL,SCR_SIZE_W   ; load address of screen width
3610+ 2B4A 5E                   ld      E,(HL)          ; load screen width into E
3611+ 2B4B E1                   pop     HL              ; restore HL
3612+ 2B4C BB                   cp      E               ; compare witdh with param
3613+ 2B4D D2 24 1E             jp      NC,FCERR        ; value over the width of the screen, exit with Illegal F.C. error
3614+ 2B50 32 7C 55             ld      (TMPBFR1),A     ; Store X into a temp. buffer
3615+ 2B53 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
3616+ 2B56 2C                   defb    ','
3617+ 2B57 CD 70 2A             call    GETINT          ; Get the second param into A
3618+ 2B5A E5                   push    HL              ; store HL
3619+ 2B5B 21 6D 55             ld      HL,SCR_SIZE_H   ; load address of screen width
3620+ 2B5E 5E                   ld      E,(HL)          ; load screen width into A
3621+ 2B5F E1                   pop     HL              ; restore HL
3622+ 2B60 BB                   cp      E               ; compare witdh with param
3623+ 2B61 D2 24 1E             jp      NC,FCERR        ; value over the height of the screen, exit with Illegal F.C. error
3624+ 2B64 32 74 55             ld      (SCR_CUR_NY),A  ; store new Y
3625+ 2B67 3A 7C 55             ld      A,(TMPBFR1)     ; recover the new X
3626+ 2B6A 32 73 55             ld      (SCR_CUR_NX),A  ; store new X
3627+ 2B6D E5                   push    HL              ; store HL
3628+ 2B6E F3                   di                      ; disable INTs
3629+ 2B6F CD CF 06             call    MOVCRS          ; move cursor to new location
3630+ 2B72 FB                   ei                      ; re-enable INTs
3631+ 2B73 E1                   pop     HL              ; restore HL
3632+ 2B74 C9                   ret                     ; return to caller
3633+ 2B75
3634+ 2B75              ; write a byte into one of the PSG registers
3635+ 2B75 CD 70 2A     SREG:   call    GETINT          ; Get register number back into A
3636+ 2B78 FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3637+ 2B7A D2 24 1E             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3638+ 2B7D 32 7C 55             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3639+ 2B80 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
3640+ 2B83 2C                   defb    ','
3641+ 2B84 CD 70 2A             call    GETINT          ; get second value (0-255), returned into A
3642+ 2B87 5F                   ld      E,A             ; store value into E
3643+ 2B88 3A 7C 55             ld      A,(TMPBFR1)     ; recover VDP register and store into D
3644+ 2B8B F3                   di                      ; disable INTs
3645+ 2B8C 0E 40                ld      C,PSG_REG       ; output port to access PSG registers
3646+ 2B8E ED 79                out     (C),A           ; send register # to PSG
3647+ 2B90 0E 41                ld      C,PSG_DAT       ; output port to send data to PSG
3648+ 2B92 ED 59                out     (C),E           ; send byte to write into selected register
3649+ 2B94 FB                   ei                      ; re-enable INTs
3650+ 2B95 C9                   ret                     ; return to caller
3651+ 2B96
3652+ 2B96              ; VOLUME ch,vol
3653+ 2B96              ; set the volume for the audio channels
3654+ 2B96              ; "ch" is 1~3 for corresponding channel, or 0 for all; "vol" is 0~15 (0=OFF, 15=MAX)
3655+ 2B96 CD 70 2A     VOLUME: call    GETINT          ; get integer 0-255 (recover channel)
3656+ 2B99 FE 04                cp      $04             ; check if it's in the range 0~3
3657+ 2B9B D2 24 1E             jp      NC,FCERR        ; if not, exit with Illegal function call error
3658+ 2B9E 32 7C 55             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3659+ 2BA1 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
3660+ 2BA4 2C                   defb    ','
3661+ 2BA5 CD 70 2A             call    GETINT          ; get integer 0-255 (recover channel)
3662+ 2BA8 FE 10                cp      $10             ; check if it's in the range 0~15
3663+ 2BAA D2 24 1E             jp      NC,FCERR        ; if not, exit with Illegal funcion call
3664+ 2BAD 57                   ld      D,A             ; store volume into D
3665+ 2BAE 3A 7C 55             ld      A,(TMPBFR1)     ; retrieve channel
3666+ 2BB1 A7                   and     A               ; is it 0? (0=every channel)
3667+ 2BB2 20 10                jr      NZ,VOLCH        ; no, jump over
3668+ 2BB4 06 03                ld      B,$03           ; yes, set every channel
3669+ 2BB6 1E 08                ld      E,$08           ; register volume of first channel
3670+ 2BB8 0E 40        RPVOLCG:ld      C,PSG_REG       ; PSG register port
3671+ 2BBA ED 59                out     (C),E           ; set register #
3672+ 2BBC 0E 41                ld      C,PSG_DAT       ; PSG data port
3673+ 2BBE ED 51                out     (C),D           ; send volume
3674+ 2BC0 1C                   inc     E               ; next register
3675+ 2BC1 10 F5                djnz    RPVOLCG         ; repeat for each channel
3676+ 2BC3 C9                   ret                     ; return to caller
3677+ 2BC4 0E 40        VOLCH:  ld      C,PSG_REG       ; PSG register port
3678+ 2BC6 C6 07                add     $07             ; add 7 to A so that we have the correct register (1->8, 2->9, 3->10)
3679+ 2BC8 ED 79                out     (C),A           ; set register
3680+ 2BCA 0E 41                ld      C,PSG_DAT       ; PSG data port
3681+ 2BCC ED 51                out     (C),D           ; send volume level
3682+ 2BCE C9                   ret                     ; return to caller
3683+ 2BCF
3684+ 2BCF              ; SOUND ch,tone,dur
3685+ 2BCF              ; play a tone or noise of "tone" frequency from selected channel "ch" for duration "dur"
3686+ 2BCF              ; "ch" is 1~6 (0=means sound OFF,1~3 for tone, 4~6 for noise) / "tone" is 1~4,095 (0=means no tone) /
3687+ 2BCF              ; "dur" is 1~16383 h.o.s.,0.001~163s (0=means non-stop tone)
3688+ 2BCF CD 70 2A     SOUND:  call    GETINT          ; get integer 0-255 (recover channel)
3689+ 2BD2 A7                   and     A               ; is it zero?
3690+ 2BD3 20 08                jr      NZ,CTSNDC       ; no, continue with checking of params
3691+ 2BD5 E5                   push    HL              ; store HL
3692+ 2BD6 F3                   di                      ; disable INTs
3693+ 2BD7 CD 94 0C             call    CLRPSGREGS      ; yes, it's zero, so reset PSG registers to shut down every sound
3694+ 2BDA FB                   ei                      ; re-enable INTs
3695+ 2BDB E1                   pop     HL              ; retrieve HL
3696+ 2BDC C9                   ret                     ; return to caller
3697+ 2BDD 32 7C 55     CTSNDC: ld      (TMPBFR1),A     ; no, continue by storing A into a temp. buffer
3698+ 2BE0 FE 04                cp      $04             ; is channel >3?
3699+ 2BE2 D2 61 2C             jp      NC,NOISUP       ; Yes - check to see if it's a noise channel
3700+ 2BE5 CD 10 1B             call    CHKSYN          ; No, continue checking by making sure ',' follows
3701+ 2BE8 2C                   defb    ','
3702+ 2BE9 CD EA 21             call    GETNUM          ; Get tone frequency
3703+ 2BEC CD 0F 1E             call    DEINT           ; Get integer -32768 to 32767
3704+ 2BEF ED 53 7E 55          ld      (TMPBFR2),DE    ; Store frequency
3705+ 2BF3 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
3706+ 2BF6 2C                   defb    ','
3707+ 2BF7 CD EA 21             call    GETNUM          ; Get duration
3708+ 2BFA CD 0F 1E             call    DEINT           ; Get integer -32768 to 32767
3709+ 2BFD ED 53 80 55          ld      (TMPBFR3),DE    ; Store duration
3710+ 2C01                                              ; CHECK CHANNEL
3711+ 2C01 3A 7C 55             ld      A,(TMPBFR1)     ; recover channel
3712+ 2C04 FE 01                cp      $01             ; is channel <1?
3713+ 2C06 DA 24 1E             jp      C,FCERR         ; Yes - Illegal function call error
3714+ 2C09                                              ; CHECK FREQUENCY
3715+ 2C09 ED 5B 7E 55          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3716+ 2C0D 7A                   ld      A,D             ; move D into A and check if it is in the range 0~4095...
3717+ 2C0E FE 10                cp      $10             ; ...so D must not be greater than $0F (15)
3718+ 2C10 D2 24 1E             jp      NC,FCERR        ; if not in the range, exit with an Illegal function call error
3719+ 2C13                                              ; CHECK DURATION
3720+ 2C13 ED 5B 80 55          ld      DE,(TMPBFR3)    ; restore duration from temp buffer
3721+ 2C17 7A                   ld      A,D             ; check if it is in the range 0~16383...
3722+ 2C18 E6 C0                and     $C0             ; ...(15th & 14th bits must not be set)
3723+ 2C1A C2 24 1E             jp      NZ,FCERR        ; if not in the range, exit with an Illegal function call error
3724+ 2C1D                                              ;
3725+ 2C1D                                              ; SET TONE:
3726+ 2C1D                                              ; let's start by setting up the channel
3727+ 2C1D 3A 7C 55             ld      A,(TMPBFR1)     ; restore channel value
3728+ 2C20 FE 03                cp      $03             ; is it 3?
3729+ 2C22 20 02                jr      NZ,SND1         ; no, jump over
3730+ 2C24 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3731+ 2C26 2F           SND1:   cpl                     ; complement of A - this is used later to set on the channel into the mixer
3732+ 2C27 CD AE 2C             call    WRTSND          ; enable line into mixer of channel stored in A
3733+ 2C2A                                              ; SET FREQUENCY
3734+ 2C2A                                              ; we simply get frequency and subtract from 4096. The result
3735+ 2C2A                                              ; is put into register pair of the corresponding freq tone channel
3736+ 2C2A ED 5B 7E 55          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3737+ 2C2E E5                   push    HL              ; store HL (it will be used by the subroutine)
3738+ 2C2F 21 00 10             ld      HL,$1000        ; load 4096 into HL
3739+ 2C32 A7                   and     A               ; reset C flag
3740+ 2C33 ED 52                sbc     HL,DE           ; subtract freq from HL - now the frequency is inverted, so we will send the low as high and vice-versa
3741+ 2C35 3A 7C 55             ld      A,(TMPBFR1)     ; restore channel value
3742+ 2C38 3D                   dec     A               ; set A into the range 0~2
3743+ 2C39 87                   add     A,A             ; double A to find the register pair that correspond to the channel (A->0,1 / B->2,3, C->4,5)
3744+ 2C3A 0E 40                ld      C,PSG_REG       ; PSG register port
3745+ 2C3C ED 79                out     (C),A           ; select first register of the pair
3746+ 2C3E 0E 41                ld      C,PSG_DAT       ; PSG data port
3747+ 2C40 ED 69                out     (C),L           ; send high byte
3748+ 2C42 0E 40                ld      C,PSG_REG       ; PSG register support
3749+ 2C44 3C                   inc     A               ; second register of the pair
3750+ 2C45 ED 79                out     (C),A           ; select register
3751+ 2C47 0E 41                ld      C,PSG_DAT       ; PSG data port
3752+ 2C49 ED 61                out     (C),H           ; send low byte
3753+ 2C4B ED 5B 80 55          ld      DE,(TMPBFR3)    ; recover duration
3754+ 2C4F 3A 7C 55             ld      A,(TMPBFR1)     ; recover channel value
3755+ 2C52 3D                   dec     A               ; set channel into the range 0~2
3756+ 2C53 87                   add     A,A             ; double A to find the correct offset
3757+ 2C54 21 B0 55             ld      HL,CHASNDDTN    ; set duration into...
3758+ 2C57 85                   add     A,L             ; ...the proper...
3759+ 2C58 30 01                jr      NC,SNDOVR       ; (is there a rest? no, jump over
3760+ 2C5A 24                   inc     H               ; yes, increment H)
3761+ 2C5B 6F           SNDOVR: ld      L,A             ; ...register pair...
3762+ 2C5C 73                   ld      (HL),E          ; ...and store the value
3763+ 2C5D 23                   inc     HL
3764+ 2C5E 72                   ld      (HL),D
3765+ 2C5F E1                   pop     HL              ; retrieve HL
3766+ 2C60 C9                   ret                     ; Return to caller
3767+ 2C61 FE 07        NOISUP: cp      $07             ; is channel in range 4 to 6 (for a noise)?
3768+ 2C63 D2 24 1E             jp      NC,FCERR        ; no, so ILLEGAL FUNCTION CALL
3769+ 2C66 CD 10 1B             call    CHKSYN          ; yes, continue checking by making sure ',' follows
3770+ 2C69 2C                   defb    ','
3771+ 2C6A CD 70 2A             call    GETINT          ; get integer 0-255 (frequency)
3772+ 2C6D FE 20                cp      $20             ; make sure it's in range 0~31
3773+ 2C6F D2 24 1E             jp      NC,FCERR        ; no, so Illegal function call
3774+ 2C72 32 7E 55             ld      (TMPBFR2),A     ; store freq.
3775+ 2C75 2B                   dec     HL              ; dec 'cos GETCHR INCs
3776+ 2C76 CD 59 1D             call    GETCHR          ; check that nothing follows
3777+ 2C79 C2 10 18             jp      NZ,SNERR        ; error if no empty line
3778+ 2C7C 3A 7E 55             ld      A,(TMPBFR2)     ; retrieve freq.
3779+ 2C7F 5F                   ld      E,A             ; store freq into E
3780+ 2C80 3A 7C 55             ld      A,(TMPBFR1)     ; retrieve channel
3781+ 2C83 D6 03                sub     $03             ; subtract 3 to get channel in range 1~3
3782+ 2C85 FE 03                cp      $03             ; is it 3?
3783+ 2C87 20 02                jr      NZ,NOS1         ; no, jump over
3784+ 2C89 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3785+ 2C8B 87           NOS1:   add     A,A
3786+ 2C8C 87                   add     A,A
3787+ 2C8D 87                   add     A,A             ; let's move A 3 bits to left
3788+ 2C8E 47                   ld      B,A             ; store channel into B
3789+ 2C8F 7B                   ld      A,E             ; check if
3790+ 2C90 A7                   and     A               ; freq is 0 (means that noise reproduction must be halted)
3791+ 2C91 F3                   di                      ; disable INts
3792+ 2C92 20 0A                jr      NZ,NOS2         ; no, so jump over
3793+ 2C94 3E 07                ld      A,$07           ; mixer register
3794+ 2C96 CD E2 0C             call    SETSNDREG       ; set mixer register
3795+ 2C99 ED 78                in      A,(C)           ; load current mixer value
3796+ 2C9B B0                   or      B               ; disable noise
3797+ 2C9C 18 19                jr      NOS3            ; continue over
3798+ 2C9E 78           NOS2:   ld      A,B             ; recover channel
3799+ 2C9F 2F                   cpl                     ; complement of A - this is used to set on the channel into the mixer
3800+ 2CA0 CD AE 2C             call    WRTSND          ; enable line into mixer of channel stored in A
3801+ 2CA3 3E 06                ld      A,$06           ; write into noise register
3802+ 2CA5 CD E2 0C             call    SETSNDREG       ; set register into PSG
3803+ 2CA8 7B                   ld      A,E             ; load value for noise frequency
3804+ 2CA9 CD E7 0C             call    WRTSNDREG       ; write data into register $06
3805+ 2CAC FB                   ei                      ; re-enable INTs
3806+ 2CAD C9                   ret
3807+ 2CAE                      ; enable line into mixer of channel stored in A
3808+ 2CAE 47           WRTSND: ld      B,A             ; move channel into B
3809+ 2CAF 3E 07                ld      A,$07           ; mixer register
3810+ 2CB1 CD E2 0C             call    SETSNDREG       ; set mixer register
3811+ 2CB4 ED 78                in      A,(C)           ; load current value
3812+ 2CB6 A0                   and     B               ; set on the channel into the mixer (remember that 0=ON)
3813+ 2CB7                                              ; example: if channel is A (1), complement of 1 is 254 (11111110). So, 255 (in case
3814+ 2CB7                                              ; the register is still unchanged after reset) is 11111111 and
3815+ 2CB7                                              ; 11111111 AND 11111110 is equal to 11111110
3816+ 2CB7                                              ; 11111001 AND 11111110 is equal to 11111000 (in case channels B & C are ON)
3817+ 2CB7 47           NOS3:   ld      B,A             ; store new mixer value into B
3818+ 2CB8 3E 07                ld      A,$07           ; mixer address
3819+ 2CBA CD E2 0C             call    SETSNDREG       ; set register
3820+ 2CBD 78                   ld      A,B             ; retrieve new mixer value from B
3821+ 2CBE CD E7 0C             call    WRTSNDREG       ; send new value for the mixer
3822+ 2CC1 FB                   ei                      ; re-enable INTs
3823+ 2CC2 C9                   ret                     ; return to caller
3824+ 2CC3
3825+ 2CC3              ; write a byte into one of the VDP registers
3826+ 2CC3 CD 70 2A     VREG:   call    GETINT          ; Get register number back into A
3827+ 2CC6 FE 08                cp      $08             ; check if value is equal or greater than 8 (VDP registers are only 8, from 0 to 7)
3828+ 2CC8 D2 24 1E             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3829+ 2CCB 32 7C 55             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3830+ 2CCE CD 10 1B             call    CHKSYN          ; Make sure ',' follows
3831+ 2CD1 2C                   defb    ','
3832+ 2CD2 CD 70 2A             call    GETINT          ; get value (0-255)
3833+ 2CD5 5F                   ld      E,A             ; store value into E
3834+ 2CD6 3A 7C 55             ld      A,(TMPBFR1)     ; recover VDP register and store into A
3835+ 2CD9 F3                   di                      ; disable INTs
3836+ 2CDA CD B3 06             call    WRITE_VREG      ; write value into VDP register
3837+ 2CDD FB                   ei                      ; re-enable INTs
3838+ 2CDE C9                   ret                     ; return to caller
3839+ 2CDF
3840+ 2CDF              ; read the VDP status register and return it into A
3841+ 2CDF CD 0F 1E     VSTAT:  call    DEINT           ; Get integer -32768 to 32767 (Note: we do NOT use it)
3842+ 2CE2 F3                   di                      ; disable INTs
3843+ 2CE3 CD BE 06             call    READ_VSTAT      ; read VDP register status
3844+ 2CE6 FB                   ei                      ; re-enable INTs
3845+ 2CE7 C3 E3 25             jp      PASSA           ; Return integer A
3846+ 2CEA
3847+ 2CEA              ; read from PSG register and return it into A
3848+ 2CEA CD 0F 1E     SSTAT:  call    DEINT           ; get integer -32768 to 32767
3849+ 2CED 7B                   ld      A,E             ; consider LSB
3850+ 2CEE FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3851+ 2CF0 D2 24 1E             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3852+ 2CF3 F3                   di                      ; disable INts
3853+ 2CF4 0E 40                ld      C,PSG_REG       ; output port to set PSG register
3854+ 2CF6 ED 79                out     (C),A           ; send register to read from
3855+ 2CF8 ED 78                in      A,(C)           ; read register's contents and store into A
3856+ 2CFA FB                   ei                      ; re-enable INTs
3857+ 2CFB C3 E3 25             jp      PASSA           ; return A
3858+ 2CFE
3859+ 2CFE              ; read the temp key buffer and return the value of the current key being pressed
3860+ 2CFE              ; can wait for the number of 100thds of second before to return
3861+ 2CFE CD 5D 26     INKEY:  call    IDTEST          ; Test for illegal direct
3862+ 2D01 CD 0F 1E             call    DEINT           ; get number param (100thds of second to wait) into DE
3863+ 2D04 C5                   push    BC              ; store BC
3864+ 2D05 3A 5C 55             ld      A,(TMRCNT)      ; Load current value of system timer
3865+ 2D08 47                   ld      B,A             ; move it into B
3866+ 2D09 3A 5C 55     CMP_A:  ld      A,(TMRCNT)      ; make a little delay of 1/100 sec...
3867+ 2D0C B8                   cp      B               ; ...to let the sniffer collect...
3868+ 2D0D 20 FA                jr      NZ,CMP_A        ; ...at least 1 char before to continue
3869+ 2D0F 7A                   ld      A,D             ; check the param
3870+ 2D10 B3                   or      E               ; if DE<>0 then...
3871+ 2D11 20 05                jr      NZ,INKEY2       ; ...jump over...
3872+ 2D13 3A B8 55             ld      A,(TMPKEYBFR)   ; ...else read the buffer and...
3873+ 2D16 18 2A                jr      ENDINK          ; ...return it
3874+ 2D18 7A           INKEY2: ld      A,D             ; check if param>1023
3875+ 2D19 FE 04                cp      $04             ; to do this we check if MSB>3
3876+ 2D1B D2 24 1E             jp      NC,FCERR        ; if MSB >=4 then error
3877+ 2D1E E5                   push    HL              ; store HL
3878+ 2D1F 21 09 00             ld      HL,$0009        ; check if value
3879+ 2D22 CD 35 41             call    CMP16           ; is < 10
3880+ 2D25 E1                   pop     HL              ; retrieve HL
3881+ 2D26 DA 2C 2D             jp      C,SRTINK        ; if value >= 10 then jump over
3882+ 2D29 11 0A 00             ld      DE,$000A        ; else, use 10 (no intervals shorter than 10/100s)
3883+ 2D2C 3A 5C 55     SRTINK: ld      A,(TMRCNT)      ; Load the first byte of the system timer
3884+ 2D2F 47                   ld      B,A             ; move it into B
3885+ 2D30 3A B8 55     CHKINK: ld      A,(TMPKEYBFR)   ; load char code from buffer
3886+ 2D33 A7                   and     A               ; is it 0?
3887+ 2D34 20 0C                jr      NZ,ENDINK       ; no, so we can return it
3888+ 2D36 3A 5C 55             ld      A,(TMRCNT)      ; load the first byte of the system timer
3889+ 2D39 B8                   cp      B               ; is it the same value?
3890+ 2D3A 28 F4                jr      Z,CHKINK        ; yes, so read again
3891+ 2D3C 47                   ld      B,A             ; store new value
3892+ 2D3D 1B                   dec     DE              ; no, decrement timer
3893+ 2D3E 7A                   ld      A,D             ; check if zero reached
3894+ 2D3F B3                   or      E               ; by ORing D and E
3895+ 2D40 20 EE                jr      NZ,CHKINK       ; if not 0, repeat
3896+ 2D42 C1           ENDINK: pop     BC              ; restore BC
3897+ 2D43 F5                   push    AF              ; store A
3898+ 2D44 F3                   di                      ; disable INTs
3899+ 2D45 AF                   xor     A               ; clear the...
3900+ 2D46 32 B8 55             ld      (TMPKEYBFR),A   ; ...TMP KEY buffer for the next read
3901+ 2D49 FB                   ei                      ; re-enable INTs
3902+ 2D4A F1                   pop     AF              ; retrieve A
3903+ 2D4B C3 E3 25             jp      PASSA           ; return A as ASCII value
3904+ 2D4E
3905+ 2D4E
3906+ 2D4E 21 75 32     ROUND:  ld      HL,HALF         ; Add 0.5 to FPREG
3907+ 2D51 CD 46 30     ADDPHL: call    LOADFP          ; Load FP at (HL) to BCDE
3908+ 2D54 C3 60 2D             jp      FPADD           ; Add BCDE to FPREG
3909+ 2D57
3910+ 2D57
3911+ 2D57 CD 46 30     SUBPHL: call    LOADFP          ; FPREG = -FPREG + number at HL
3912+ 2D5A 21                   defb    $21             ; Skip "pop BC" and "pop DE"
3913+ 2D5B C1           PSUB:   pop     BC              ; Get FP number from stack
3914+ 2D5C D1                   pop     DE
3915+ 2D5D CD 20 30     SUBCDE: call    INVSGN          ; Negate FPREG
3916+ 2D60 78           FPADD:  ld      A,B             ; Get FP exponent
3917+ 2D61 B7                   or      A               ; Is number zero?
3918+ 2D62 C8                   ret     Z               ; Yes - Nothing to add
3919+ 2D63 3A D3 55             ld      A,(FPEXP)       ; Get FPREG exponent
3920+ 2D66 B7                   or      A               ; Is this number zero?
3921+ 2D67 CA 38 30             jp      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3922+ 2D6A 90                   sub     B               ; BCDE number larger?
3923+ 2D6B D2 7A 2D             jp      NC,NOSWAP       ; No - Don't swap them
3924+ 2D6E 2F                   cpl                     ; Two's complement
3925+ 2D6F 3C                   inc     A               ;  FP exponent
3926+ 2D70 EB                   ex      DE,HL
3927+ 2D71 CD 28 30             call    STAKFP          ; Put FPREG on stack
3928+ 2D74 EB                   ex      DE,HL
3929+ 2D75 CD 38 30             call    FPBCDE          ; Move BCDE to FPREG
3930+ 2D78 C1                   pop     BC              ; Restore number from stack
3931+ 2D79 D1                   pop     DE
3932+ 2D7A FE 19        NOSWAP: cp      24+1            ; Second number insignificant?
3933+ 2D7C D0                   ret     NC              ; Yes - First number is result
3934+ 2D7D F5                   push    AF              ; Save number of bits to scale
3935+ 2D7E CD 5D 30             call    SIGNS           ; Set MSBs & sign of result
3936+ 2D81 67                   ld      H,A             ; Save sign of result
3937+ 2D82 F1                   pop     AF              ; Restore scaling factor
3938+ 2D83 CD 25 2E             call    SCALE           ; Scale BCDE to same exponent
3939+ 2D86 B4                   or      H               ; Result to be positive?
3940+ 2D87 21 D0 55             ld      HL,FPREG        ; Point to FPREG
3941+ 2D8A F2 A0 2D             jp      P,MINCDE        ; No - Subtract FPREG from CDE
3942+ 2D8D CD 05 2E             call    PLUCDE          ; Add FPREG to CDE
3943+ 2D90 D2 E6 2D             jp      NC,RONDUP       ; No overflow - Round it up
3944+ 2D93 23                   inc     HL              ; Point to exponent
3945+ 2D94 34                   inc     (HL)            ; Increment it
3946+ 2D95 CA 1F 18             jp      Z,OVERR         ; Number overflowed - Error
3947+ 2D98 2E 01                ld      L,$01           ; 1 bit to shift right
3948+ 2D9A CD 3B 2E             call    SHRT1           ; Shift result right
3949+ 2D9D C3 E6 2D             jp      RONDUP          ; Round it up
3950+ 2DA0
3951+ 2DA0 AF           MINCDE: xor     A               ; Clear A and carry
3952+ 2DA1 90                   sub     B               ; Negate exponent
3953+ 2DA2 47                   ld      B,A             ; Re-save exponent
3954+ 2DA3 7E                   ld      A,(HL)          ; Get LSB of FPREG
3955+ 2DA4 9B                   sbc     A, E            ; Subtract LSB of BCDE
3956+ 2DA5 5F                   ld      E,A             ; Save LSB of BCDE
3957+ 2DA6 23                   inc     HL
3958+ 2DA7 7E                   ld      A,(HL)          ; Get NMSB of FPREG
3959+ 2DA8 9A                   sbc     A,D             ; Subtract NMSB of BCDE
3960+ 2DA9 57                   ld      D,A             ; Save NMSB of BCDE
3961+ 2DAA 23                   inc     HL
3962+ 2DAB 7E                   ld      A,(HL)          ; Get MSB of FPREG
3963+ 2DAC 99                   sbc     A,C             ; Subtract MSB of BCDE
3964+ 2DAD 4F                   ld      C,A             ; Save MSB of BCDE
3965+ 2DAE DC 11 2E     CONPOS: call    C,COMPL         ; Overflow - Make it positive
3966+ 2DB1
3967+ 2DB1 68           BNORM:  ld      L,B             ; L = Exponent
3968+ 2DB2 63                   ld      H,E             ; H = LSB
3969+ 2DB3 AF                   xor     A
3970+ 2DB4 47           BNRMLP: ld      B,A             ; Save bit count
3971+ 2DB5 79                   ld      A,C             ; Get MSB
3972+ 2DB6 B7                   or      A               ; Is it zero?
3973+ 2DB7 C2 D3 2D             jp      NZ,PNORM        ; No - Do it bit at a time
3974+ 2DBA 4A                   ld      C,D             ; MSB = NMSB
3975+ 2DBB 54                   ld      D,H             ; NMSB= LSB
3976+ 2DBC 65                   ld      H,L             ; LSB = VLSB
3977+ 2DBD 6F                   ld      L,A             ; VLSB= 0
3978+ 2DBE 78                   ld      A,B             ; Get exponent
3979+ 2DBF D6 08                sub     $08             ; Count 8 bits
3980+ 2DC1 FE E0                cp      -24-8           ; Was number zero?
3981+ 2DC3 C2 B4 2D             jp      NZ,BNRMLP       ; No - Keep normalising
3982+ 2DC6 AF           RESZER: xor     A               ; Result is zero
3983+ 2DC7 32 D3 55     SAVEXP: ld      (FPEXP),A       ; Save result as zero
3984+ 2DCA C9                   ret
3985+ 2DCB
3986+ 2DCB 05           NORMAL: dec     B               ; Count bits
3987+ 2DCC 29                   add     HL,HL           ; Shift HL left
3988+ 2DCD 7A                   ld      A,D             ; Get NMSB
3989+ 2DCE 17                   rla                     ; Shift left with last bit
3990+ 2DCF 57                   ld      D,A             ; Save NMSB
3991+ 2DD0 79                   ld      A,C             ; Get MSB
3992+ 2DD1 8F                   adc     A,A             ; Shift left with last bit
3993+ 2DD2 4F                   ld      C,A             ; Save MSB
3994+ 2DD3 F2 CB 2D     PNORM:  jp      P,NORMAL        ; Not done - Keep going
3995+ 2DD6 78                   ld      A,B             ; Number of bits shifted
3996+ 2DD7 5C                   ld      E,H             ; Save HL in EB
3997+ 2DD8 45                   ld      B,L
3998+ 2DD9 B7                   or      A               ; Any shifting done?
3999+ 2DDA CA E6 2D             jp      Z,RONDUP        ; No - Round it up
4000+ 2DDD 21 D3 55             ld      HL,FPEXP        ; Point to exponent
4001+ 2DE0 86                   add     A,(HL)          ; Add shifted bits
4002+ 2DE1 77                   ld      (HL),A          ; Re-save exponent
4003+ 2DE2 D2 C6 2D             jp      NC,RESZER       ; Underflow - Result is zero
4004+ 2DE5 C8                   ret     Z               ; Result is zero
4005+ 2DE6 78           RONDUP: ld      A,B             ; Get VLSB of number
4006+ 2DE7 21 D3 55     RONDB:  ld      HL,FPEXP        ; Point to exponent
4007+ 2DEA B7                   or      A               ; Any rounding?
4008+ 2DEB FC F8 2D             call    M,FPROND        ; Yes - Round number up
4009+ 2DEE 46                   ld      B,(HL)          ; B = Exponent
4010+ 2DEF 23                   inc     HL
4011+ 2DF0 7E                   ld      A,(HL)          ; Get sign of result
4012+ 2DF1 E6 80                and     %10000000       ; Only bit 7 needed
4013+ 2DF3 A9                   xor     C               ; Set correct sign
4014+ 2DF4 4F                   ld      C,A             ; Save correct sign in number
4015+ 2DF5 C3 38 30             jp      FPBCDE          ; Move BCDE to FPREG
4016+ 2DF8
4017+ 2DF8 1C           FPROND: inc     E               ; Round LSB
4018+ 2DF9 C0                   ret     NZ              ; Return if ok
4019+ 2DFA 14                   inc     D               ; Round NMSB
4020+ 2DFB C0                   ret     NZ              ; Return if ok
4021+ 2DFC 0C                   inc     C               ; Round MSB
4022+ 2DFD C0                   ret     NZ              ; Return if ok
4023+ 2DFE 0E 80                ld      C,$80           ; Set normal value
4024+ 2E00 34                   inc     (HL)            ; Increment exponent
4025+ 2E01 C0                   ret     NZ              ; Return if ok
4026+ 2E02 C3 1F 18             jp      OVERR           ; Overflow error
4027+ 2E05
4028+ 2E05 7E           PLUCDE: ld      A,(HL)          ; Get LSB of FPREG
4029+ 2E06 83                   add     A,E             ; Add LSB of BCDE
4030+ 2E07 5F                   ld      E,A             ; Save LSB of BCDE
4031+ 2E08 23                   inc     HL
4032+ 2E09 7E                   ld      A,(HL)          ; Get NMSB of FPREG
4033+ 2E0A 8A                   adc     A,D             ; Add NMSB of BCDE
4034+ 2E0B 57                   ld      D,A             ; Save NMSB of BCDE
4035+ 2E0C 23                   inc     HL
4036+ 2E0D 7E                   ld      A,(HL)          ; Get MSB of FPREG
4037+ 2E0E 89                   adc     A,C             ; Add MSB of BCDE
4038+ 2E0F 4F                   ld      C,A             ; Save MSB of BCDE
4039+ 2E10 C9                   ret
4040+ 2E11
4041+ 2E11 21 D4 55     COMPL:  ld      HL,SGNRES       ; Sign of result
4042+ 2E14 7E                   ld      A,(HL)          ; Get sign of result
4043+ 2E15 2F                   cpl                     ; Negate it
4044+ 2E16 77                   ld      (HL),A          ; Put it back
4045+ 2E17 AF                   xor     A
4046+ 2E18 6F                   ld      L,A             ; Set L to zero
4047+ 2E19 90                   sub     B               ; Negate exponent,set carry
4048+ 2E1A 47                   ld      B,A             ; Re-save exponent
4049+ 2E1B 7D                   ld      A,L             ; Load zero
4050+ 2E1C 9B                   sbc     A,E             ; Negate LSB
4051+ 2E1D 5F                   ld      E,A             ; Re-save LSB
4052+ 2E1E 7D                   ld      A,L             ; Load zero
4053+ 2E1F 9A                   sbc     A,D             ; Negate NMSB
4054+ 2E20 57                   ld      D,A             ; Re-save NMSB
4055+ 2E21 7D                   ld      A,L             ; Load zero
4056+ 2E22 99                   sbc     A,C             ; Negate MSB
4057+ 2E23 4F                   ld      C,A             ; Re-save MSB
4058+ 2E24 C9                   ret
4059+ 2E25
4060+ 2E25 06 00        SCALE:  ld      B,$00           ; Clear underflow
4061+ 2E27 D6 08        SCALLP: sub     $08             ; 8 bits (a whole byte)?
4062+ 2E29 DA 34 2E             jp      C,SHRITE        ; No - Shift right A bits
4063+ 2E2C 43                   ld      B,E             ; <- Shift
4064+ 2E2D 5A                   ld      E,D             ; <- right
4065+ 2E2E 51                   ld      D,C             ; <- eight
4066+ 2E2F 0E 00                ld      C,$00           ; <- bits
4067+ 2E31 C3 27 2E             jp      SCALLP          ; More bits to shift
4068+ 2E34
4069+ 2E34 C6 09        SHRITE: add     A,8+1           ; Adjust count
4070+ 2E36 6F                   ld      L,A             ; Save bits to shift
4071+ 2E37 AF           SHRLP:  xor     A               ; Flag for all done
4072+ 2E38 2D                   dec     L               ; All shifting done?
4073+ 2E39 C8                   ret     Z               ; Yes - Return
4074+ 2E3A 79                   ld      A,C             ; Get MSB
4075+ 2E3B 1F           SHRT1:  rra                     ; Shift it right
4076+ 2E3C 4F                   ld      C,A             ; Re-save
4077+ 2E3D 7A                   ld      A,D             ; Get NMSB
4078+ 2E3E 1F                   rra                     ; Shift right with last bit
4079+ 2E3F 57                   ld      D,A             ; Re-save it
4080+ 2E40 7B                   ld      A,E             ; Get LSB
4081+ 2E41 1F                   rra                     ; Shift right with last bit
4082+ 2E42 5F                   ld      E,A             ; Re-save it
4083+ 2E43 78                   ld      A,B             ; Get underflow
4084+ 2E44 1F                   rra                     ; Shift right with last bit
4085+ 2E45 47                   ld      B,A             ; Re-save underflow
4086+ 2E46 C3 37 2E             jp      SHRLP           ; More bits to do
4087+ 2E49
4088+ 2E49 00 00 00 81  UNITY:  defb    $00,$00,$00,$81 ; 1.00000
4089+ 2E4D
4090+ 2E4D 03           LOGTAB: defb    $03             ; Table used by LOG
4091+ 2E4E AA 56 19 80          defb    $AA,$56,$19,$80 ; 0.59898
4092+ 2E52 F1 22 76 80          defb    $F1,$22,$76,$80 ; 0.96147
4093+ 2E56 45 AA 38 82          defb    $45,$AA,$38,$82 ; 2.88539
4094+ 2E5A
4095+ 2E5A CD F7 2F     LOG:    call    TSTSGN          ; Test sign of value
4096+ 2E5D B7                   or      A
4097+ 2E5E EA 24 1E             jp      PE,FCERR        ; ?FC Error if <= zero
4098+ 2E61 21 D3 55             ld      HL,FPEXP        ; Point to exponent
4099+ 2E64 7E                   ld      A,(HL)          ; Get exponent
4100+ 2E65 01 35 80             ld      BC,$8035        ; BCDE = SQR(1/2)
4101+ 2E68 11 F3 04             ld      DE,$04F3
4102+ 2E6B 90                   sub     B               ; Scale value to be < 1
4103+ 2E6C F5                   push    AF              ; Save scale factor
4104+ 2E6D 70                   ld      (HL),B          ; Save new exponent
4105+ 2E6E D5                   push    DE              ; Save SQR(1/2)
4106+ 2E6F C5                   push    BC
4107+ 2E70 CD 60 2D             call    FPADD           ; Add SQR(1/2) to value
4108+ 2E73 C1                   pop     BC              ; Restore SQR(1/2)
4109+ 2E74 D1                   pop     DE
4110+ 2E75 04                   inc     B               ; Make it SQR(2)
4111+ 2E76 CD 4D 2F             call    DVBCDE          ; Divide by SQR(2)
4112+ 2E79 21 49 2E             ld      HL,UNITY        ; Point to 1.
4113+ 2E7C CD 57 2D             call    SUBPHL          ; Subtract FPREG from 1
4114+ 2E7F 21 4D 2E             ld      HL,LOGTAB       ; Coefficient table
4115+ 2E82 CD 3F 33             call    SUMSER          ; Evaluate sum of series
4116+ 2E85 01 80 80             ld      BC,$8080        ; BCDE = -0.5
4117+ 2E88 11 00 00             ld      DE,$0000
4118+ 2E8B CD 60 2D             call    FPADD           ; Subtract 0.5 from FPREG
4119+ 2E8E F1                   pop     AF              ; Restore scale factor
4120+ 2E8F CD 72 31             call    RSCALE          ; Re-scale number
4121+ 2E92 01 31 80     MULLN2: ld      BC,$8031        ; BCDE = Ln(2)
4122+ 2E95 11 18 72             ld      DE,$7218
4123+ 2E98 21                   defb    $21             ; Skip "pop BC" and "pop DE"
4124+ 2E99
4125+ 2E99 C1           MULT:   pop     BC              ; Get number from stack
4126+ 2E9A D1                   pop     DE
4127+ 2E9B CD F7 2F     FPMULT: call    TSTSGN          ; Test sign of FPREG
4128+ 2E9E C8                   ret     Z               ; Return zero if zero
4129+ 2E9F 2E 00                ld      L,$00           ; Flag add exponents
4130+ 2EA1 CD B5 2F             call    ADDEXP          ; Add exponents
4131+ 2EA4 79                   ld      A,C             ; Get MSB of multiplier
4132+ 2EA5 32 E2 55             ld      (MULVAL),A      ; Save MSB of multiplier
4133+ 2EA8 EB                   ex      DE,HL
4134+ 2EA9 22 E3 55             ld      (MULVAL+1),HL   ; Save rest of multiplier
4135+ 2EAC 01 00 00             ld      BC,$0000        ; Partial product (BCDE) = zero
4136+ 2EAF 50                   ld      D,B
4137+ 2EB0 58                   ld      E,B
4138+ 2EB1 21 B1 2D             ld      HL,BNORM        ; Address of normalise
4139+ 2EB4 E5                   push    HL              ; Save for return
4140+ 2EB5 21 BD 2E             ld      HL,MULT8        ; Address of 8 bit multiply
4141+ 2EB8 E5                   push    HL              ; Save for NMSB,MSB
4142+ 2EB9 E5                   push    HL              ;
4143+ 2EBA 21 D0 55             ld      HL,FPREG        ; Point to number
4144+ 2EBD 7E           MULT8:  ld      A,(HL)          ; Get LSB of number
4145+ 2EBE 23                   inc     HL              ; Point to NMSB
4146+ 2EBF B7                   or      A               ; Test LSB
4147+ 2EC0 CA E9 2E             jp      Z,BYTSFT        ; Zero - shift to next byte
4148+ 2EC3 E5                   push    HL              ; Save address of number
4149+ 2EC4 2E 08                ld      L,$08           ; 8 bits to multiply by
4150+ 2EC6 1F           MUL8LP: rra                     ; Shift LSB right
4151+ 2EC7 67                   ld      H,A             ; Save LSB
4152+ 2EC8 79                   ld      A,C             ; Get MSB
4153+ 2EC9 D2 D7 2E             jp      NC,NOMADD       ; Bit was zero - Don't add
4154+ 2ECC E5                   push    HL              ; Save LSB and count
4155+ 2ECD 2A E3 55             ld      HL,(MULVAL+1)   ; Get LSB and NMSB
4156+ 2ED0 19                   add     HL,DE           ; Add NMSB and LSB
4157+ 2ED1 EB                   ex      DE,HL           ; Leave sum in DE
4158+ 2ED2 E1                   pop     HL              ; Restore MSB and count
4159+ 2ED3 3A E2 55             ld      A,(MULVAL)      ; Get MSB of multiplier
4160+ 2ED6 89                   adc     A,C             ; Add MSB
4161+ 2ED7 1F           NOMADD: rra                     ; Shift MSB right
4162+ 2ED8 4F                   ld      C,A             ; Re-save MSB
4163+ 2ED9 7A                   ld      A,D             ; Get NMSB
4164+ 2EDA 1F                   rra                     ; Shift NMSB right
4165+ 2EDB 57                   ld      D,A             ; Re-save NMSB
4166+ 2EDC 7B                   ld      A,E             ; Get LSB
4167+ 2EDD 1F                   rra                     ; Shift LSB right
4168+ 2EDE 5F                   ld      E,A             ; Re-save LSB
4169+ 2EDF 78                   ld      A,B             ; Get VLSB
4170+ 2EE0 1F                   rra                     ; Shift VLSB right
4171+ 2EE1 47                   ld      B,A             ; Re-save VLSB
4172+ 2EE2 2D                   dec     L               ; Count bits multiplied
4173+ 2EE3 7C                   ld      A,H             ; Get LSB of multiplier
4174+ 2EE4 C2 C6 2E             jp      NZ,MUL8LP       ; More - Do it
4175+ 2EE7 E1           POPHRT: pop     HL              ; Restore address of number
4176+ 2EE8 C9                   ret
4177+ 2EE9
4178+ 2EE9 43           BYTSFT: ld      B,E             ; Shift partial product left
4179+ 2EEA 5A                   ld      E,D
4180+ 2EEB 51                   ld      D,C
4181+ 2EEC 4F                   ld      C,A
4182+ 2EED C9                   ret
4183+ 2EEE
4184+ 2EEE
4185+ 2EEE              ; WORKING ââ
4186+ 2EEE C1           DINT:   pop     BC              ; Get number from stack
4187+ 2EEF D1                   pop     DE
4188+ 2EF0 CD 4D 2F             call    DVBCDE          ; get BCDE/FPREG and store result into FPREG
4189+ 2EF3 C3 CA 30             jp      INT             ; return INT(FPREG)
4190+ 2EF6
4191+ 2EF6
4192+ 2EF6              ; A MODULO B - return remainder of the integer division A/B where:
4193+ 2EF6              ; A is in stack; B is in FPREG
4194+ 2EF6              ; math is:
4195+ 2EF6              ; A=INT(A); B=INT(B); R=A-(B*INT(A/B))
4196+ 2EF6 CD CA 30     MOD:    call    INT             ; B=INT(B)
4197+ 2EF9 CD 43 30             call    BCDEFP          ; copy B (from FPREG) into BCDE
4198+ 2EFC ED 53 80 55          ld      (TMPBFR3),DE    ; store B into...
4199+ 2F00 ED 43 82 55          ld      (TMPBFR4),BC    ; ...a temp buffer
4200+ 2F04 C1                   pop     BC              ; recover A...
4201+ 2F05 D1                   pop     DE              ; ...from stack
4202+ 2F06 CD 38 30             call    FPBCDE          ; store A into FPREG
4203+ 2F09 CD CA 30             call    INT             ; get integer part: A=INT(A)
4204+ 2F0C CD 43 30             call    BCDEFP          ; copy A (from FPREG) into BCDE
4205+ 2F0F ED 53 7C 55          ld      (TMPBFR1),DE    ; store A into...
4206+ 2F13 ED 43 7E 55          ld      (TMPBFR2),BC    ; ...a temp buffer
4207+ 2F17                                              ; begin calculation
4208+ 2F17 2A 80 55             ld      HL,(TMPBFR3)    ; move B...
4209+ 2F1A 22 D0 55             ld      (FPREG),HL      ; ...from...
4210+ 2F1D 2A 82 55             ld      HL,(TMPBFR4)    ; ...temp buffer...
4211+ 2F20 22 D2 55             ld      (FPREG+2),HL    ; ...into FPREG
4212+ 2F23 CD 4D 2F             call    DVBCDE          ; compute A/B and store into FPREG
4213+ 2F26 CD CA 30             call    INT             ; get integer part of result: now FPREG = INT(A/B)
4214+ 2F29 ED 5B 80 55          ld      DE,(TMPBFR3)    ; load B...
4215+ 2F2D ED 4B 82 55          ld      BC,(TMPBFR4)    ; ...into BCDE
4216+ 2F31 CD 9B 2E             call    FPMULT          ; get B*INT(A/B) and store into FPREG
4217+ 2F34 ED 5B 7C 55          ld      DE,(TMPBFR1)    ; retrieve A from...
4218+ 2F38 ED 4B 7E 55          ld      BC,(TMPBFR2)    ; ...temp buffer
4219+ 2F3C C3 5D 2D             jp      SUBCDE          ; return result of A-(B*INT(A/B))
4220+ 2F3F
4221+ 2F3F
4222+ 2F3F CD 28 30     DIV10:  call    STAKFP          ; Save FPREG on stack
4223+ 2F42 01 20 84             ld      BC,$8420        ; BCDE = 10.
4224+ 2F45 11 00 00             ld      DE,$0000
4225+ 2F48 CD 38 30             call    FPBCDE          ; Move 10 to FPREG
4226+ 2F4B
4227+ 2F4B C1           DIV:    pop     BC              ; Get number from stack
4228+ 2F4C D1                   pop     DE
4229+ 2F4D CD F7 2F     DVBCDE: call    TSTSGN          ; Test sign of FPREG
4230+ 2F50 CA 13 18             jp      Z,DZERR         ; Error if division by zero
4231+ 2F53 2E FF                ld      L,-1            ; Flag subtract exponents
4232+ 2F55 CD B5 2F             call    ADDEXP          ; Subtract exponents
4233+ 2F58 34                   inc     (HL)            ; Add 2 to exponent to adjust
4234+ 2F59 34                   inc     (HL)
4235+ 2F5A 2B                   dec     HL              ; Point to MSB
4236+ 2F5B 7E                   ld      A,(HL)          ; Get MSB of dividend
4237+ 2F5C 32 ED 53             ld      (DIV3),A        ; Save for subtraction
4238+ 2F5F 2B                   dec     HL
4239+ 2F60 7E                   ld      A,(HL)          ; Get NMSB of dividend
4240+ 2F61 32 E9 53             ld      (DIV2),A        ; Save for subtraction
4241+ 2F64 2B                   dec     HL
4242+ 2F65 7E                   ld      A,(HL)          ; Get MSB of dividend
4243+ 2F66 32 E5 53             ld      (DIV1),A        ; Save for subtraction
4244+ 2F69 41                   ld      B,C             ; Get MSB
4245+ 2F6A EB                   ex      DE,HL           ; NMSB,LSB to HL
4246+ 2F6B AF                   xor     A
4247+ 2F6C 4F                   ld      C,A             ; Clear MSB of quotient
4248+ 2F6D 57                   ld      D,A             ; Clear NMSB of quotient
4249+ 2F6E 5F                   ld      E,A             ; Clear LSB of quotient
4250+ 2F6F 32 F0 53             ld      (DIV4),A        ; Clear overflow count
4251+ 2F72 E5           DIVLP:  push    HL              ; Save divisor
4252+ 2F73 C5                   push    BC
4253+ 2F74 7D                   ld      A,L             ; Get LSB of number
4254+ 2F75 CD E4 53             call    DIVSUP          ; Subt' divisor from dividend
4255+ 2F78 DE 00                sbc     A,$00           ; Count for overflows
4256+ 2F7A 3F                   ccf
4257+ 2F7B D2 85 2F             jp      NC,RESDIV       ; Restore divisor if borrow
4258+ 2F7E 32 F0 53             ld      (DIV4),A        ; Re-save overflow count
4259+ 2F81 F1                   pop     AF              ; Scrap divisor
4260+ 2F82 F1                   pop     AF
4261+ 2F83 37                   scf                     ; Set carry to
4262+ 2F84 D2                   defb    $D2             ; Skip "pop BC" and "pop HL"
4263+ 2F85
4264+ 2F85 C1           RESDIV: pop     BC              ; Restore divisor
4265+ 2F86 E1                   pop     HL
4266+ 2F87 79                   ld      A,C             ; Get MSB of quotient
4267+ 2F88 3C                   inc     A
4268+ 2F89 3D                   dec     A
4269+ 2F8A 1F                   rra                     ; Bit 0 to bit 7
4270+ 2F8B FA E7 2D             jp      M,RONDB         ; Done - Normalise result
4271+ 2F8E 17                   rla                     ; Restore carry
4272+ 2F8F 7B                   ld      A,E             ; Get LSB of quotient
4273+ 2F90 17                   rla                     ; Double it
4274+ 2F91 5F                   ld      E,A             ; Put it back
4275+ 2F92 7A                   ld      A,D             ; Get NMSB of quotient
4276+ 2F93 17                   rla                     ; Double it
4277+ 2F94 57                   ld      D,A             ; Put it back
4278+ 2F95 79                   ld      A,C             ; Get MSB of quotient
4279+ 2F96 17                   rla                     ; Double it
4280+ 2F97 4F                   ld      C,A             ; Put it back
4281+ 2F98 29                   add     HL,HL           ; Double NMSB,LSB of divisor
4282+ 2F99 78                   ld      A,B             ; Get MSB of divisor
4283+ 2F9A 17                   rla                     ; Double it
4284+ 2F9B 47                   ld      B,A             ; Put it back
4285+ 2F9C 3A F0 53             ld      A,(DIV4)        ; Get VLSB of quotient
4286+ 2F9F 17                   rla                     ; Double it
4287+ 2FA0 32 F0 53             ld      (DIV4),A        ; Put it back
4288+ 2FA3 79                   ld      A,C             ; Get MSB of quotient
4289+ 2FA4 B2                   or      D               ; Merge NMSB
4290+ 2FA5 B3                   or      E               ; Merge LSB
4291+ 2FA6 C2 72 2F             jp      NZ,DIVLP        ; Not done - Keep dividing
4292+ 2FA9 E5                   push    HL              ; Save divisor
4293+ 2FAA 21 D3 55             ld      HL,FPEXP        ; Point to exponent
4294+ 2FAD 35                   dec     (HL)            ; Divide by 2
4295+ 2FAE E1                   pop     HL              ; Restore divisor
4296+ 2FAF C2 72 2F             jp      NZ,DIVLP        ; Ok - Keep going
4297+ 2FB2 C3 1F 18             jp      OVERR           ; Overflow error
4298+ 2FB5
4299+ 2FB5
4300+ 2FB5 78           ADDEXP: ld      A,B             ; Get exponent of dividend
4301+ 2FB6 B7                   or      A               ; Test it
4302+ 2FB7 CA D9 2F             jp      Z,OVTST3        ; Zero - Result zero
4303+ 2FBA 7D                   ld      A,L             ; Get add/subtract flag
4304+ 2FBB 21 D3 55             ld      HL,FPEXP        ; Point to exponent
4305+ 2FBE AE                   xor     (HL)            ; Add or subtract it
4306+ 2FBF 80                   add     A,B             ; Add the other exponent
4307+ 2FC0 47                   ld      B,A             ; Save new exponent
4308+ 2FC1 1F                   rra                     ; Test exponent for overflow
4309+ 2FC2 A8                   xor     B
4310+ 2FC3 78                   ld      A,B             ; Get exponent
4311+ 2FC4 F2 D8 2F             jp      P,OVTST2        ; Positive - Test for overflow
4312+ 2FC7 C6 80                add     A,$80           ; Add excess 128
4313+ 2FC9 77                   ld      (HL),A          ; Save new exponent
4314+ 2FCA CA E7 2E             jp      Z,POPHRT        ; Zero - Result zero
4315+ 2FCD CD 5D 30             call    SIGNS           ; Set MSBs and sign of result
4316+ 2FD0 77                   ld      (HL),A          ; Save new exponent
4317+ 2FD1 2B                   dec     HL              ; Point to MSB
4318+ 2FD2 C9                   ret
4319+ 2FD3
4320+ 2FD3 CD F7 2F     OVTST1: call    TSTSGN          ; Test sign of FPREG
4321+ 2FD6 2F                   cpl                     ; Invert sign
4322+ 2FD7 E1                   pop     HL              ; Clean up stack
4323+ 2FD8 B7           OVTST2: or      A               ; Test if new exponent zero
4324+ 2FD9 E1           OVTST3: pop     HL              ; Clear off return address
4325+ 2FDA F2 C6 2D             jp      P,RESZER        ; Result zero
4326+ 2FDD C3 1F 18             jp      OVERR           ; Overflow error
4327+ 2FE0
4328+ 2FE0 CD 43 30     MLSP10: call    BCDEFP          ; Move FPREG to BCDE
4329+ 2FE3 78                   ld      A,B             ; Get exponent
4330+ 2FE4 B7                   or      A               ; Is it zero?
4331+ 2FE5 C8                   ret     Z               ; Yes - Result is zero
4332+ 2FE6 C6 02                add     A,$02           ; Multiply by 4
4333+ 2FE8 DA 1F 18             jp      C,OVERR         ; Overflow - ?OV Error
4334+ 2FEB 47                   ld      B,A             ; Re-save exponent
4335+ 2FEC CD 60 2D             call    FPADD           ; Add BCDE to FPREG (Times 5)
4336+ 2FEF 21 D3 55             ld      HL,FPEXP        ; Point to exponent
4337+ 2FF2 34                   inc     (HL)            ; Double number (Times 10)
4338+ 2FF3 C0                   ret     NZ              ; Ok - Return
4339+ 2FF4 C3 1F 18             jp      OVERR           ; Overflow error
4340+ 2FF7
4341+ 2FF7 3A D3 55     TSTSGN: ld      A,(FPEXP)       ; Get sign of FPREG
4342+ 2FFA B7                   or      A
4343+ 2FFB C8                   ret     Z               ; RETurn if number is zero
4344+ 2FFC 3A D2 55             ld      A,(FPREG+2)     ; Get MSB of FPREG
4345+ 2FFF FE                   defb    0FEH            ; Test sign
4346+ 3000 2F           RETREL: cpl                     ; Invert sign
4347+ 3001 17                   rla                     ; Sign bit to carry
4348+ 3002 9F           FLGDIF: sbc     A,A             ; Carry to all bits of A
4349+ 3003 C0                   ret     NZ              ; Return -1 if negative
4350+ 3004 3C                   inc     A               ; Bump to +1
4351+ 3005 C9                   ret                     ; Positive - Return +1
4352+ 3006
4353+ 3006 CD F7 2F     SGN:    call    TSTSGN          ; Test sign of FPREG
4354+ 3009 06 88        FLGREL: ld      B,$80+8         ; 8 bit integer in exponent
4355+ 300B 11 00 00             ld      DE,0            ; Zero NMSB and LSB
4356+ 300E 21 D3 55     RETINT: ld      HL,FPEXP        ; Point to exponent
4357+ 3011 4F                   ld      C,A             ; CDE = MSB,NMSB and LSB
4358+ 3012 70                   ld      (HL),B          ; Save exponent
4359+ 3013 06 00                ld      B,0             ; CDE = integer to normalise
4360+ 3015 23                   inc     HL              ; Point to sign of result
4361+ 3016 36 80                ld      (HL),$80        ; Set sign of result
4362+ 3018 17                   rla                     ; Carry = sign of integer
4363+ 3019 C3 AE 2D             jp      CONPOS          ; Set sign of result
4364+ 301C
4365+ 301C CD F7 2F     ABS_:   call    TSTSGN          ; Test sign of FPREG
4366+ 301F F0                   ret     P               ; Return if positive
4367+ 3020 21 D2 55     INVSGN: ld      HL,FPREG+2      ; Point to MSB
4368+ 3023 7E                   ld      A,(HL)          ; Get sign of mantissa
4369+ 3024 EE 80                xor     $80             ; Invert sign of mantissa
4370+ 3026 77                   ld      (HL),A          ; Re-save sign of mantissa
4371+ 3027 C9                   ret
4372+ 3028
4373+ 3028 EB           STAKFP: ex      DE,HL           ; Save code string address
4374+ 3029 2A D0 55             ld      HL,(FPREG)      ; LSB,NLSB of FPREG
4375+ 302C E3                   ex      (SP),HL         ; Stack them,get return
4376+ 302D E5                   push    HL              ; Re-save return
4377+ 302E 2A D2 55             ld      HL,(FPREG+2)    ; MSB and exponent of FPREG
4378+ 3031 E3                   ex      (SP),HL         ; Stack them,get return
4379+ 3032 E5                   push    HL              ; Re-save return
4380+ 3033 EB                   ex      DE,HL           ; Restore code string address
4381+ 3034 C9                   ret
4382+ 3035
4383+ 3035              ; store F.P. number from BCDE into (FPREG)
4384+ 3035 CD 46 30     PHLTFP: call    LOADFP          ; Number at HL to BCDE
4385+ 3038 EB           FPBCDE: ex      DE,HL           ; Save code string address
4386+ 3039 22 D0 55             ld      (FPREG),HL      ; Save LSB,NLSB of number
4387+ 303C 60                   ld      H,B             ; Exponent of number
4388+ 303D 69                   ld      L,C             ; MSB of number
4389+ 303E 22 D2 55             ld      (FPREG+2),HL    ; Save MSB and exponent
4390+ 3041 EB                   ex      DE,HL           ; Restore code string address
4391+ 3042 C9                   ret
4392+ 3043
4393+ 3043              ; load F.P. number from (FPREG) into BCDE
4394+ 3043 21 D0 55     BCDEFP: ld      HL,FPREG        ; Point to FPREG
4395+ 3046 5E           LOADFP: ld      E,(HL)          ; Get LSB of number
4396+ 3047 23                   inc     HL
4397+ 3048 56                   ld      D,(HL)          ; Get NMSB of number
4398+ 3049 23                   inc     HL
4399+ 304A 4E                   ld      C,(HL)          ; Get MSB of number
4400+ 304B 23                   inc     HL
4401+ 304C 46                   ld      B,(HL)          ; Get exponent of number
4402+ 304D 23           INCHL:  inc     HL              ; Used for conditional "inc HL"
4403+ 304E C9                   ret
4404+ 304F
4405+ 304F              ; move floating point from (FPREG) into (HL)
4406+ 304F 11 D0 55     FPTHL:  ld      DE,FPREG        ; Point to FPREG
4407+ 3052 06 04        DETHL4: ld      B,$04           ; 4 bytes to move
4408+ 3054 1A           DETHLB: ld      A,(DE)          ; Get source
4409+ 3055 77                   ld      (HL),A          ; Save destination
4410+ 3056 13                   inc     DE              ; Next source
4411+ 3057 23                   inc     HL              ; Next destination
4412+ 3058 05                   dec     B               ; Count bytes
4413+ 3059 C2 54 30             jp      NZ,DETHLB       ; Loop if more
4414+ 305C C9                   ret
4415+ 305D
4416+ 305D 21 D2 55     SIGNS:  ld      HL,FPREG+2      ; Point to MSB of FPREG
4417+ 3060 7E                   ld      A,(HL)          ; Get MSB
4418+ 3061 07                   rlca                    ; Old sign to carry
4419+ 3062 37                   scf                     ; Set MSBit
4420+ 3063 1F                   rra                     ; Set MSBit of MSB
4421+ 3064 77                   ld      (HL),A          ; Save new MSB
4422+ 3065 3F                   ccf                     ; Complement sign
4423+ 3066 1F                   rra                     ; Old sign to carry
4424+ 3067 23                   inc     HL
4425+ 3068 23                   inc     HL
4426+ 3069 77                   ld      (HL),A          ; Set sign of result
4427+ 306A 79                   ld      A,C             ; Get MSB
4428+ 306B 07                   rlca                    ; Old sign to carry
4429+ 306C 37                   scf                     ; Set MSBit
4430+ 306D 1F                   rra                     ; Set MSBit of MSB
4431+ 306E 4F                   ld      C,A             ; Save MSB
4432+ 306F 1F                   rra
4433+ 3070 AE                   xor     (HL)            ; New sign of result
4434+ 3071 C9                   ret
4435+ 3072
4436+ 3072 78           CMPNUM: ld      A,B             ; Get exponent of number
4437+ 3073 B7                   or      A
4438+ 3074 CA F7 2F             jp      Z,TSTSGN        ; Zero - Test sign of FPREG
4439+ 3077 21 00 30             ld      HL,RETREL       ; Return relation routine
4440+ 307A E5                   push    HL              ; Save for return
4441+ 307B CD F7 2F             call    TSTSGN          ; Test sign of FPREG
4442+ 307E 79                   ld      A,C             ; Get MSB of number
4443+ 307F C8                   ret     Z               ; FPREG zero - Number's MSB
4444+ 3080 21 D2 55             ld      HL,FPREG+2      ; MSB of FPREG
4445+ 3083 AE                   xor     (HL)            ; Combine signs
4446+ 3084 79                   ld      A,C             ; Get MSB of number
4447+ 3085 F8                   ret     M               ; Exit if signs different
4448+ 3086 CD 8C 30             call    CMPFP           ; Compare FP numbers
4449+ 3089 1F                   rra                     ; Get carry to sign
4450+ 308A A9                   xor     C               ; Combine with MSB of number
4451+ 308B C9                   ret
4452+ 308C
4453+ 308C 23           CMPFP:  inc     HL              ; Point to exponent
4454+ 308D 78                   ld      A,B             ; Get exponent
4455+ 308E BE                   cp      (HL)            ; Compare exponents
4456+ 308F C0                   ret     NZ              ; Different
4457+ 3090 2B                   dec     HL              ; Point to MBS
4458+ 3091 79                   ld      A,C             ; Get MSB
4459+ 3092 BE                   cp      (HL)            ; Compare MSBs
4460+ 3093 C0                   ret     NZ              ; Different
4461+ 3094 2B                   dec     HL              ; Point to NMSB
4462+ 3095 7A                   ld      A,D             ; Get NMSB
4463+ 3096 BE                   cp      (HL)            ; Compare NMSBs
4464+ 3097 C0                   ret     NZ              ; Different
4465+ 3098 2B                   dec     HL              ; Point to LSB
4466+ 3099 7B                   ld      A,E             ; Get LSB
4467+ 309A 96                   sub     (HL)            ; Compare LSBs
4468+ 309B C0                   ret     NZ              ; Different
4469+ 309C E1                   pop     HL              ; Drop RETurn
4470+ 309D E1                   pop     HL              ; Drop another RETurn
4471+ 309E C9                   ret
4472+ 309F
4473+ 309F 47           FPINT:  ld      B,A             ; <- Move
4474+ 30A0 4F                   ld      C,A             ; <- exponent
4475+ 30A1 57                   ld      D,A             ; <- to all
4476+ 30A2 5F                   ld      E,A             ; <- bits
4477+ 30A3 B7                   or      A               ; Test exponent
4478+ 30A4 C8                   ret     Z               ; Zero - Return zero
4479+ 30A5 E5                   push    HL              ; Save pointer to number
4480+ 30A6 CD 43 30             call    BCDEFP          ; Move FPREG to BCDE
4481+ 30A9 CD 5D 30             call    SIGNS           ; Set MSBs & sign of result
4482+ 30AC AE                   xor     (HL)            ; Combine with sign of FPREG
4483+ 30AD 67                   ld      H,A             ; Save combined signs
4484+ 30AE FC C3 30             call    M,DCBCDE        ; Negative - Decrement BCDE
4485+ 30B1 3E 98                ld      A,$80+24        ; 24 bits
4486+ 30B3 90                   sub     B               ; Bits to shift
4487+ 30B4 CD 25 2E             call    SCALE           ; Shift BCDE
4488+ 30B7 7C                   ld      A,H             ; Get combined sign
4489+ 30B8 17                   rla                     ; Sign to carry
4490+ 30B9 DC F8 2D             call    C,FPROND        ; Negative - Round number up
4491+ 30BC 06 00                ld      B,$00           ; Zero exponent
4492+ 30BE DC 11 2E             call    C,COMPL         ; If negative make positive
4493+ 30C1 E1                   pop     HL              ; Restore pointer to number
4494+ 30C2 C9                   ret
4495+ 30C3
4496+ 30C3 1B           DCBCDE: dec     DE              ; Decrement BCDE
4497+ 30C4 7A                   ld      A,D             ; Test LSBs
4498+ 30C5 A3                   and     E
4499+ 30C6 3C                   inc     A
4500+ 30C7 C0                   ret     NZ              ; Exit if LSBs not FFFF
4501+ 30C8 0B                   dec     BC              ; Decrement MSBs
4502+ 30C9 C9                   ret
4503+ 30CA
4504+ 30CA 21 D3 55     INT:    ld      HL,FPEXP        ; Point to exponent
4505+ 30CD 7E                   ld      A,(HL)          ; Get exponent
4506+ 30CE FE 98                cp      $80+24          ; Integer accuracy only?
4507+ 30D0 3A D0 55             ld      A,(FPREG)       ; Get LSB
4508+ 30D3 D0                   ret     NC              ; Yes - Already integer
4509+ 30D4 7E                   ld      A,(HL)          ; Get exponent
4510+ 30D5 CD 9F 30             call    FPINT           ; F.P to integer
4511+ 30D8 36 98                ld      (HL),$80+24     ; Save 24 bit integer
4512+ 30DA 7B                   ld      A,E             ; Get LSB of number
4513+ 30DB F5                   push    AF              ; Save LSB
4514+ 30DC 79                   ld      A,C             ; Get MSB of number
4515+ 30DD 17                   rla                     ; Sign to carry
4516+ 30DE CD AE 2D             call    CONPOS          ; Set sign of result
4517+ 30E1 F1                   pop     AF              ; Restore LSB of number
4518+ 30E2 C9                   ret
4519+ 30E3
4520+ 30E3 21 00 00     MLDEBC: ld      HL,$0000        ; Clear partial product
4521+ 30E6 78                   ld      A,B             ; Test multiplier
4522+ 30E7 B1                   or      C
4523+ 30E8 C8                   ret     Z               ; Return zero if zero
4524+ 30E9 3E 10                ld      A,$10           ; 16 bits
4525+ 30EB 29           MLDBLP: add     HL,HL           ; Shift P.P left
4526+ 30EC DA 11 25             jp      C,BSERR         ; ?BS Error if overflow
4527+ 30EF EB                   ex      DE,HL
4528+ 30F0 29                   add     HL,HL           ; Shift multiplier left
4529+ 30F1 EB                   ex      DE,HL
4530+ 30F2 D2 F9 30             jp      NC,NOMLAD       ; Bit was zero - No add
4531+ 30F5 09                   add     HL,BC           ; Add multiplicand
4532+ 30F6 DA 11 25             jp      C,BSERR         ; ?BS Error if overflow
4533+ 30F9 3D           NOMLAD: dec     A               ; Count bits
4534+ 30FA C2 EB 30             jp      NZ,MLDBLP       ; More
4535+ 30FD C9                   ret
4536+ 30FE
4537+ 30FE FE 2D        ASCTFP: cp      '-'             ; Negative?
4538+ 3100 F5                   push    AF              ; Save it and flags
4539+ 3101 CA 0A 31             jp      Z,CNVNUM        ; Yes - Convert number
4540+ 3104 FE 2B                cp      '+'             ; Positive?
4541+ 3106 CA 0A 31             jp      Z,CNVNUM        ; Yes - Convert number
4542+ 3109 2B                   dec     HL              ; dec 'cos GETCHR INCs
4543+ 310A CD C6 2D     CNVNUM: call    RESZER          ; Set result to zero
4544+ 310D 47                   ld      B,A             ; Digits after point counter
4545+ 310E 57                   ld      D,A             ; Sign of exponent
4546+ 310F 5F                   ld      E,A             ; Exponent of ten
4547+ 3110 2F                   cpl
4548+ 3111 4F                   ld      C,A             ; Before or after point flag
4549+ 3112 CD 59 1D     MANLP:  call    GETCHR          ; Get next character
4550+ 3115 DA 5B 31             jp      C,ADDIG         ; Digit - Add to number
4551+ 3118 FE 2E                cp      '.'
4552+ 311A CA 36 31             jp      Z,DPOINT        ; '.' - Flag point
4553+ 311D FE 45                cp      'E'
4554+ 311F C2 3A 31             jp      NZ,CONEXP       ; Not 'E' - Scale number
4555+ 3122 CD 59 1D             call    GETCHR          ; Get next character
4556+ 3125 CD 2D 23             call    SGNEXP          ; Get sign of exponent
4557+ 3128 CD 59 1D     EXPLP:  call    GETCHR          ; Get next character
4558+ 312B DA 7D 31             jp      C,EDIGIT        ; Digit - Add to exponent
4559+ 312E 14                   inc     D               ; Is sign negative?
4560+ 312F C2 3A 31             jp      NZ,CONEXP       ; No - Scale number
4561+ 3132 AF                   xor     A
4562+ 3133 93                   sub     E               ; Negate exponent
4563+ 3134 5F                   ld      E,A             ; And re-save it
4564+ 3135 0C                   inc     C               ; Flag end of number
4565+ 3136 0C           DPOINT: inc     C               ; Flag point passed
4566+ 3137 CA 12 31             jp      Z,MANLP         ; Zero - Get another digit
4567+ 313A E5           CONEXP: push    HL              ; Save code string address
4568+ 313B 7B                   ld      A,E             ; Get exponent
4569+ 313C 90                   sub     B               ; Subtract digits after point
4570+ 313D F4 53 31     SCALMI: call    P,SCALPL        ; Positive - Multiply number
4571+ 3140 F2 49 31             jp      P,ENDCON        ; Positive - All done
4572+ 3143 F5                   push    AF              ; Save number of times to /10
4573+ 3144 CD 3F 2F             call    DIV10           ; Divide by 10
4574+ 3147 F1                   pop     AF              ; Restore count
4575+ 3148 3C                   inc     A               ; Count divides
4576+ 3149
4577+ 3149 C2 3D 31     ENDCON: jp      NZ,SCALMI       ; More to do
4578+ 314C D1                   pop     DE              ; Restore code string address
4579+ 314D F1                   pop     AF              ; Restore sign of number
4580+ 314E CC 20 30             call    Z,INVSGN        ; Negative - Negate number
4581+ 3151 EB                   ex      DE,HL           ; Code string address to HL
4582+ 3152 C9                   ret
4583+ 3153
4584+ 3153 C8           SCALPL: ret     Z               ; Exit if no scaling needed
4585+ 3154 F5           MULTEN: push    AF              ; Save count
4586+ 3155 CD E0 2F             call    MLSP10          ; Multiply number by 10
4587+ 3158 F1                   pop     AF              ; Restore count
4588+ 3159 3D                   dec     A               ; Count multiplies
4589+ 315A C9                   ret
4590+ 315B
4591+ 315B D5           ADDIG:  push    DE              ; Save sign of exponent
4592+ 315C 57                   ld      D,A             ; Save digit
4593+ 315D 78                   ld      A,B             ; Get digits after point
4594+ 315E 89                   adc     A,C             ; Add one if after point
4595+ 315F 47                   ld      B,A             ; Re-save counter
4596+ 3160 C5                   push    BC              ; Save point flags
4597+ 3161 E5                   push    HL              ; Save code string address
4598+ 3162 D5                   push    DE              ; Save digit
4599+ 3163 CD E0 2F             call    MLSP10          ; Multiply number by 10
4600+ 3166 F1                   pop     AF              ; Restore digit
4601+ 3167 D6 30                sub     '0'             ; Make it absolute
4602+ 3169 CD 72 31             call    RSCALE          ; Re-scale number
4603+ 316C E1                   pop     HL              ; Restore code string address
4604+ 316D C1                   pop     BC              ; Restore point flags
4605+ 316E D1                   pop     DE              ; Restore sign of exponent
4606+ 316F C3 12 31             jp      MANLP           ; Get another digit
4607+ 3172
4608+ 3172 CD 28 30     RSCALE: call    STAKFP          ; Put number on stack
4609+ 3175 CD 09 30             call    FLGREL          ; Digit to add to FPREG
4610+ 3178 C1           PADD:   pop     BC              ; Restore number
4611+ 3179 D1                   pop     DE
4612+ 317A C3 60 2D             jp      FPADD           ; Add BCDE to FPREG and return
4613+ 317D
4614+ 317D 7B           EDIGIT: ld      A,E             ; Get digit
4615+ 317E 07                   rlca                    ; Times 2
4616+ 317F 07                   rlca                    ; Times 4
4617+ 3180 83                   add     A,E             ; Times 5
4618+ 3181 07                   rlca                    ; Times 10
4619+ 3182 86                   add     A,(HL)          ; Add next digit
4620+ 3183 D6 30                sub     '0'             ; Make it absolute
4621+ 3185 5F                   ld      E,A             ; Save new digit
4622+ 3186 C3 28 31             jp      EXPLP           ; Look for another digit
4623+ 3189
4624+ 3189 E5           LINEIN: push    HL              ; Save code string address
4625+ 318A 21 89 17             ld      HL,INMSG        ; Output " in "
4626+ 318D CD F2 26             call    PRS             ; Output string at HL
4627+ 3190 E1                   pop     HL              ; Restore code string address
4628+ 3191 EB           PRNTHL: ex      DE,HL           ; Code string address to DE
4629+ 3192 AF                   xor     A
4630+ 3193 06 98                ld      B,$80+24        ; 24 bits
4631+ 3195 CD 0E 30             call    RETINT          ; Return the integer
4632+ 3198 21 F1 26             ld      HL,PRNUMS       ; Print number string
4633+ 319B E5                   push    HL              ; Save for return
4634+ 319C              ; conmvert FP number into ASCII chars
4635+ 319C 21 D5 55     NUMASC: ld      HL,PBUFF        ; Convert number to ASCII
4636+ 319F E5                   push    HL              ; Save for return
4637+ 31A0 CD F7 2F             call    TSTSGN          ; Test sign of FPREG
4638+ 31A3 36 20                ld      (HL),SPC        ; Space at start
4639+ 31A5 F2 AA 31             jp      P,SPCFST        ; Positive - Space to start
4640+ 31A8 36 2D                ld      (HL),'-'        ; '-' sign at start
4641+ 31AA 23           SPCFST: inc     HL              ; First byte of number
4642+ 31AB 36 30                ld      (HL),'0'        ; '0' if zero
4643+ 31AD CA 60 32             jp      Z,JSTZER        ; Return '0' if zero
4644+ 31B0 E5                   push    HL              ; Save buffer address
4645+ 31B1 FC 20 30             call    M,INVSGN        ; Negate FPREG if negative
4646+ 31B4 AF                   xor     A               ; Zero A
4647+ 31B5 F5                   push    AF              ; Save it
4648+ 31B6 CD 66 32             call    RNGTST          ; Test number is in range
4649+ 31B9 01 43 91     SIXDIG: ld      BC,$9143        ; BCDE - 99999.9
4650+ 31BC 11 F8 4F             ld      DE,$4FF8
4651+ 31BF CD 72 30             call    CMPNUM          ; Compare numbers
4652+ 31C2 B7                   or      A
4653+ 31C3 E2 D7 31             jp      PO,INRNG        ; > 99999.9 - Sort it out
4654+ 31C6 F1                   pop     AF              ; Restore count
4655+ 31C7 CD 54 31             call    MULTEN          ; Multiply by ten
4656+ 31CA F5                   push    AF              ; Re-save count
4657+ 31CB C3 B9 31             jp      SIXDIG          ; Test it again
4658+ 31CE
4659+ 31CE CD 3F 2F     GTSIXD: call    DIV10           ; Divide by 10
4660+ 31D1 F1                   pop     AF              ; Get count
4661+ 31D2 3C                   inc     A               ; Count divides
4662+ 31D3 F5                   push    AF              ; Re-save count
4663+ 31D4 CD 66 32             call    RNGTST          ; Test number is in range
4664+ 31D7 CD 4E 2D     INRNG:  call    ROUND           ; Add 0.5 to FPREG
4665+ 31DA 3C                   inc     A
4666+ 31DB CD 9F 30             call    FPINT           ; F.P to integer
4667+ 31DE CD 38 30             call    FPBCDE          ; Move BCDE to FPREG
4668+ 31E1 01 06 03             ld      BC,$0306        ; 1E+06 to 1E-03 range
4669+ 31E4 F1                   pop     AF              ; Restore count
4670+ 31E5 81                   add     A,C             ; 6 digits before point
4671+ 31E6 3C                   inc     A               ; Add one
4672+ 31E7 FA F3 31             jp      M,MAKNUM        ; Do it in 'E' form if < 1E-02
4673+ 31EA FE 08                cp      6+1+1           ; More than 999999 ?
4674+ 31EC D2 F3 31             jp      NC,MAKNUM       ; Yes - Do it in 'E' form
4675+ 31EF 3C                   inc     A               ; Adjust for exponent
4676+ 31F0 47                   ld      B,A             ; Exponent of number
4677+ 31F1 3E 02                ld      A,2             ; Make it zero after
4678+ 31F3
4679+ 31F3 3D           MAKNUM: dec     A               ; Adjust for digits to do
4680+ 31F4 3D                   dec     A
4681+ 31F5 E1                   pop     HL              ; Restore buffer address
4682+ 31F6 F5                   push    AF              ; Save count
4683+ 31F7 11 79 32             ld      DE,POWERS       ; Powers of ten
4684+ 31FA 05                   dec     B               ; Count digits before point
4685+ 31FB C2 04 32             jp      NZ,DIGTXT       ; Not zero - Do number
4686+ 31FE 36 2E                ld      (HL),'.'        ; Save point
4687+ 3200 23                   inc     HL              ; Move on
4688+ 3201 36 30                ld      (HL),'0'        ; Save zero
4689+ 3203 23                   inc     HL              ; Move on
4690+ 3204 05           DIGTXT: dec     B               ; Count digits before point
4691+ 3205 36 2E                ld      (HL),'.'        ; Save point in case
4692+ 3207 CC 4D 30             call    Z,INCHL         ; Last digit - move on
4693+ 320A C5                   push    BC              ; Save digits before point
4694+ 320B E5                   push    HL              ; Save buffer address
4695+ 320C D5                   push    DE              ; Save powers of ten
4696+ 320D CD 43 30             call    BCDEFP          ; Move FPREG to BCDE
4697+ 3210 E1                   pop     HL              ; Powers of ten table
4698+ 3211 06 2F                ld      B,'0'-1         ; ASCII '0' - 1
4699+ 3213 04           TRYAGN: inc     B               ; Count subtractions
4700+ 3214 7B                   ld      A,E             ; Get LSB
4701+ 3215 96                   sub     (HL)            ; Subtract LSB
4702+ 3216 5F                   ld      E,A             ; Save LSB
4703+ 3217 23                   inc     HL
4704+ 3218 7A                   ld      A,D             ; Get NMSB
4705+ 3219 9E                   sbc     A,(HL)          ; Subtract NMSB
4706+ 321A 57                   ld      D,A             ; Save NMSB
4707+ 321B 23                   inc     HL
4708+ 321C 79                   ld      A,C             ; Get MSB
4709+ 321D 9E                   sbc     A,(HL)          ; Subtract MSB
4710+ 321E 4F                   ld      C,A             ; Save MSB
4711+ 321F 2B                   dec     HL              ; Point back to start
4712+ 3220 2B                   dec     HL
4713+ 3221 D2 13 32             jp      NC,TRYAGN       ; No overflow - Try again
4714+ 3224 CD 05 2E             call    PLUCDE          ; Restore number
4715+ 3227 23                   inc     HL              ; Start of next number
4716+ 3228 CD 38 30             call    FPBCDE          ; Move BCDE to FPREG
4717+ 322B EB                   ex      DE,HL           ; Save point in table
4718+ 322C E1                   pop     HL              ; Restore buffer address
4719+ 322D 70                   ld      (HL),B          ; Save digit in buffer
4720+ 322E 23                   inc     HL              ; And move on
4721+ 322F C1                   pop     BC              ; Restore digit count
4722+ 3230 0D                   dec     C               ; Count digits
4723+ 3231 C2 04 32             jp      NZ,DIGTXT       ; More - Do them
4724+ 3234 05                   dec     B               ; Any decimal part?
4725+ 3235 CA 44 32             jp      Z,DOEBIT        ; No - Do 'E' bit
4726+ 3238 2B           SUPTLZ: dec     HL              ; Move back through buffer
4727+ 3239 7E                   ld      A,(HL)          ; Get character
4728+ 323A FE 30                cp      '0'             ; '0' character?
4729+ 323C CA 38 32             jp      Z,SUPTLZ        ; Yes - Look back for more
4730+ 323F FE 2E                cp      '.'             ; A decimal point?
4731+ 3241 C4 4D 30             call    NZ,INCHL        ; Move back over digit
4732+ 3244
4733+ 3244 F1           DOEBIT: pop     AF              ; Get 'E' flag
4734+ 3245 CA 63 32             jp      Z,NOENED        ; No 'E' needed - End buffer
4735+ 3248 36 45                ld      (HL),'E'        ; Put 'E' in buffer
4736+ 324A 23                   inc     HL              ; And move on
4737+ 324B 36 2B                ld      (HL),'+'        ; Put '+' in buffer
4738+ 324D F2 54 32             jp      P,OUTEXP        ; Positive - Output exponent
4739+ 3250 36 2D                ld      (HL),'-'        ; Put '-' in buffer
4740+ 3252 2F                   cpl                     ; Negate exponent
4741+ 3253 3C                   inc     A
4742+ 3254 06 2F        OUTEXP: ld      B,'0'-1         ; ASCII '0' - 1
4743+ 3256 04           EXPTEN: inc     B               ; Count subtractions
4744+ 3257 D6 0A                sub     $0A             ; Tens digit
4745+ 3259 D2 56 32             jp      NC,EXPTEN       ; More to do
4746+ 325C C6 3A                add     A,'0'+10        ; Restore and make ASCII
4747+ 325E 23                   inc     HL              ; Move on
4748+ 325F 70                   ld      (HL),B          ; Save MSB of exponent
4749+ 3260 23           JSTZER: inc     HL              ;
4750+ 3261 77                   ld      (HL),A          ; Save LSB of exponent
4751+ 3262 23                   inc     HL
4752+ 3263 71           NOENED: ld      (HL),C          ; Mark end of buffer
4753+ 3264 E1                   pop     HL              ; Restore code string address
4754+ 3265 C9                   ret
4755+ 3266
4756+ 3266 01 74 94     RNGTST: ld      BC,$9474        ; BCDE = 999999.
4757+ 3269 11 F7 23             ld      DE,$23F7
4758+ 326C CD 72 30             call    CMPNUM          ; Compare numbers
4759+ 326F B7                   or      A
4760+ 3270 E1                   pop     HL              ; Return address to HL
4761+ 3271 E2 CE 31             jp      PO,GTSIXD       ; Too big - Divide by ten
4762+ 3274 E9                   jp      (HL)            ; Otherwise return to caller
4763+ 3275
4764+ 3275 00 00 00 80  HALF:   defb    $00,$00,$00,$80 ; 0.5
4765+ 3279
4766+ 3279 A0 86 01     POWERS: defb    $A0,$86,$01  ; 100000
4767+ 327C 10 27 00             defb    $10,$27,$00  ;  10000
4768+ 327F E8 03 00             defb    $E8,$03,$00  ;   1000
4769+ 3282 64 00 00             defb    $64,$00,$00  ;    100
4770+ 3285 0A 00 00             defb    $0A,$00,$00  ;     10
4771+ 3288 01 00 00             defb    $01,$00,$00  ;      1
4772+ 328B
4773+ 328B 21 20 30     NEGAFT: ld      HL,INVSGN       ; Negate result
4774+ 328E E3                   ex      (SP),HL         ; To be done after caller
4775+ 328F E9                   jp      (HL)            ; Return to caller
4776+ 3290
4777+ 3290 CD 28 30     SQR:    call    STAKFP          ; Put value on stack
4778+ 3293 21 75 32             ld      HL,HALF         ; Set power to 1/2
4779+ 3296 CD 35 30             call    PHLTFP          ; Move 1/2 to FPREG
4780+ 3299
4781+ 3299 C1           POWER:  pop     BC              ; Get base
4782+ 329A D1                   pop     DE
4783+ 329B CD F7 2F             call    TSTSGN          ; Test sign of power
4784+ 329E 78                   ld      A,B             ; Get exponent of base
4785+ 329F CA DE 32             jp      Z,EXP           ; Make result 1 if zero
4786+ 32A2 F2 A9 32             jp      P,POWER1        ; Positive base - Ok
4787+ 32A5 B7                   or      A               ; Zero to negative power?
4788+ 32A6 CA 13 18             jp      Z,DZERR         ; Yes - ?/0 Error
4789+ 32A9 B7           POWER1: or      A               ; Base zero?
4790+ 32AA CA C7 2D             jp      Z,SAVEXP        ; Yes - Return zero
4791+ 32AD D5                   push    DE              ; Save base
4792+ 32AE C5                   push    BC
4793+ 32AF 79                   ld      A,C             ; Get MSB of base
4794+ 32B0 F6 7F                or      %01111111       ; Get sign status
4795+ 32B2 CD 43 30             call    BCDEFP          ; Move power to BCDE
4796+ 32B5 F2 C6 32             jp      P,POWER2        ; Positive base - Ok
4797+ 32B8 D5                   push    DE              ; Save power
4798+ 32B9 C5                   push    BC
4799+ 32BA CD CA 30             call    INT             ; Get integer of power
4800+ 32BD C1                   pop     BC              ; Restore power
4801+ 32BE D1                   pop     DE
4802+ 32BF F5                   push    AF              ; MSB of base
4803+ 32C0 CD 72 30             call    CMPNUM          ; Power an integer?
4804+ 32C3 E1                   pop     HL              ; Restore MSB of base
4805+ 32C4 7C                   ld      A,H             ; but don't affect flags
4806+ 32C5 1F                   rra                     ; Exponent odd or even?
4807+ 32C6 E1           POWER2: pop     HL              ; Restore MSB and exponent
4808+ 32C7 22 D2 55             ld      (FPREG+2),HL    ; Save base in FPREG
4809+ 32CA E1                   pop     HL              ; LSBs of base
4810+ 32CB 22 D0 55             ld      (FPREG),HL      ; Save in FPREG
4811+ 32CE DC 8B 32             call    C,NEGAFT        ; Odd power - Negate result
4812+ 32D1 CC 20 30             call    Z,INVSGN        ; Negative base - Negate it
4813+ 32D4 D5                   push    DE              ; Save power
4814+ 32D5 C5                   push    BC
4815+ 32D6 CD 5A 2E             call    LOG             ; Get LOG of base
4816+ 32D9 C1                   pop     BC              ; Restore power
4817+ 32DA D1                   pop     DE
4818+ 32DB CD 9B 2E             call    FPMULT          ; Multiply LOG by power
4819+ 32DE
4820+ 32DE CD 28 30     EXP:    call    STAKFP          ; Put value on stack
4821+ 32E1 01 38 81             ld      BC,$8138        ; BCDE = 1/Ln(2)
4822+ 32E4 11 3B AA             ld      DE,$AA3B
4823+ 32E7 CD 9B 2E             call    FPMULT          ; Multiply value by 1/LN(2)
4824+ 32EA 3A D3 55             ld      A,(FPEXP)       ; Get exponent
4825+ 32ED FE 88                cp      $80+8           ; Is it in range?
4826+ 32EF D2 D3 2F             jp      NC,OVTST1       ; No - Test for overflow
4827+ 32F2 CD CA 30             call    INT             ; Get INT of FPREG
4828+ 32F5 C6 80                add     A,$80           ; For excess 128
4829+ 32F7 C6 02                add     A,$02           ; Exponent > 126?
4830+ 32F9 DA D3 2F             jp      C,OVTST1        ; Yes - Test for overflow
4831+ 32FC F5                   push    AF              ; Save scaling factor
4832+ 32FD 21 49 2E             ld      HL,UNITY        ; Point to 1.
4833+ 3300 CD 51 2D             call    ADDPHL          ; Add 1 to FPREG
4834+ 3303 CD 92 2E             call    MULLN2          ; Multiply by LN(2)
4835+ 3306 F1                   pop     AF              ; Restore scaling factor
4836+ 3307 C1                   pop     BC              ; Restore exponent
4837+ 3308 D1                   pop     DE
4838+ 3309 F5                   push    AF              ; Save scaling factor
4839+ 330A CD 5D 2D             call    SUBCDE          ; Subtract exponent from FPREG
4840+ 330D CD 20 30             call    INVSGN          ; Negate result
4841+ 3310 21 1E 33             ld      HL,EXPTAB       ; Coefficient table
4842+ 3313 CD 4E 33             call    SMSER1          ; Sum the series
4843+ 3316 11 00 00             ld      DE,$0000        ; Zero LSBs
4844+ 3319 C1                   pop     BC              ; Scaling factor
4845+ 331A 4A                   ld      C,D             ; Zero MSB
4846+ 331B C3 9B 2E             jp      FPMULT          ; Scale result to correct value
4847+ 331E
4848+ 331E 08           EXPTAB: defb    $08             ; Table used by EXP
4849+ 331F 40 2E 94 74          defb    $40,$2E,$94,$74 ; -1/7! (-1/5040)
4850+ 3323 70 4F 2E 77          defb    $70,$4F,$2E,$77 ;  1/6! ( 1/720)
4851+ 3327 6E 02 88 7A          defb    $6E,$02,$88,$7A ; -1/5! (-1/120)
4852+ 332B E6 A0 2A 7C          defb    $E6,$A0,$2A,$7C ;  1/4! ( 1/24)
4853+ 332F 50 AA AA 7E          defb    $50,$AA,$AA,$7E ; -1/3! (-1/6)
4854+ 3333 FF FF 7F 7F          defb    $FF,$FF,$7F,$7F ;  1/2! ( 1/2)
4855+ 3337 00 00 80 81          defb    $00,$00,$80,$81 ; -1/1! (-1/1)
4856+ 333B 00 00 00 81          defb    $00,$00,$00,$81 ;  1/0! ( 1/1)
4857+ 333F
4858+ 333F CD 28 30     SUMSER: call    STAKFP          ; Put FPREG on stack
4859+ 3342 11 99 2E             ld      DE,MULT         ; Multiply by "X"
4860+ 3345 D5                   push    DE              ; To be done after
4861+ 3346 E5                   push    HL              ; Save address of table
4862+ 3347 CD 43 30             call    BCDEFP          ; Move FPREG to BCDE
4863+ 334A CD 9B 2E             call    FPMULT          ; Square the value
4864+ 334D E1                   pop     HL              ; Restore address of table
4865+ 334E CD 28 30     SMSER1: call    STAKFP          ; Put value on stack
4866+ 3351 7E                   ld      A,(HL)          ; Get number of coefficients
4867+ 3352 23                   inc     HL              ; Point to start of table
4868+ 3353 CD 35 30             call    PHLTFP          ; Move coefficient to FPREG
4869+ 3356 06                   defb    06H             ; Skip "pop AF"
4870+ 3357 F1           SUMLP:  pop     AF              ; Restore count
4871+ 3358 C1                   pop     BC              ; Restore number
4872+ 3359 D1                   pop     DE
4873+ 335A 3D                   dec     A               ; Cont coefficients
4874+ 335B C8                   ret     Z               ; All done
4875+ 335C D5                   push    DE              ; Save number
4876+ 335D C5                   push    BC
4877+ 335E F5                   push    AF              ; Save count
4878+ 335F E5                   push    HL              ; Save address in table
4879+ 3360 CD 9B 2E             call    FPMULT          ; Multiply FPREG by BCDE
4880+ 3363 E1                   pop     HL              ; Restore address in table
4881+ 3364 CD 46 30             call    LOADFP          ; Number at HL to BCDE
4882+ 3367 E5                   push    HL              ; Save address in table
4883+ 3368 CD 60 2D             call    FPADD           ; Add coefficient to FPREG
4884+ 336B E1                   pop     HL              ; Restore address in table
4885+ 336C C3 57 33             jp      SUMLP           ; More coefficients
4886+ 336F
4887+ 336F
4888+ 336F              ; random number generator
4889+ 336F              ; a negative argument is used as a seed for the RNG
4890+ 336F              ; 0 is used to repeat the last random number
4891+ 336F              ; a positive argument generates a new random number
4892+ 336F CD F7 2F     RND:    call    TSTSGN          ; Test sign of FPREG
4893+ 3372 21 F4 53             ld      HL,SEED+2       ; Random number seed
4894+ 3375 FA D0 33             jp      M,RESEED        ; Negative - Re-seed
4895+ 3378 21 15 54             ld      HL,LSTRND       ; Last random number
4896+ 337B CD 35 30             call    PHLTFP          ; Move last RND to FPREG
4897+ 337E 21 F4 53             ld      HL,SEED+2       ; Random number seed
4898+ 3381 C8                   ret     Z               ; Return if RND(0)
4899+ 3382 86                   add     A,(HL)          ; Add (SEED+2)
4900+ 3383 E6 07                and     %00000111       ; 0 to 7
4901+ 3385 06 00                ld      B,$00
4902+ 3387 77                   ld      (HL),A          ; Re-save seed
4903+ 3388 23                   inc     HL              ; Move to coefficient table
4904+ 3389 87                   add     A,A             ; 4 bytes
4905+ 338A 87                   add     A,A             ; per entry
4906+ 338B 4F                   ld      C,A             ; BC = Offset into table
4907+ 338C 09                   add     HL,BC           ; Point to coefficient
4908+ 338D CD 46 30             call    LOADFP          ; Coefficient to BCDE
4909+ 3390 CD 9B 2E             call    FPMULT          ; Multiply FPREG by coefficient
4910+ 3393 3A F3 53             ld      A,(SEED+1)      ; Get (SEED+1)
4911+ 3396 3C                   inc     A               ; Add 1
4912+ 3397 E6 03                and     %00000011       ; 0 to 3
4913+ 3399 06 00                ld      B,$00
4914+ 339B FE 01                cp      $01             ; Is it zero?
4915+ 339D 88                   adc     A,B             ; Yes - Make it 1
4916+ 339E 32 F3 53             ld      (SEED+1),A      ; Re-save seed
4917+ 33A1 21 D4 33             ld      HL,RNDTAB-4     ; Addition table
4918+ 33A4 87                   add     A,A             ; 4 bytes
4919+ 33A5 87                   add     A,A             ; per entry
4920+ 33A6 4F                   ld      C,A             ; BC = Offset into table
4921+ 33A7 09                   add     HL,BC           ; Point to value
4922+ 33A8 CD 51 2D             call    ADDPHL          ; Add value to FPREG
4923+ 33AB CD 43 30     RND1:   call    BCDEFP          ; Move FPREG to BCDE
4924+ 33AE 7B                   ld      A,E             ; Get LSB
4925+ 33AF 59                   ld      E,C             ; LSB = MSB
4926+ 33B0 EE 4F                xor     %01001111       ; Fiddle around
4927+ 33B2 4F                   ld      C,A             ; New MSB
4928+ 33B3 36 80                ld      (HL),$80        ; Set exponent
4929+ 33B5 2B                   dec     HL              ; Point to MSB
4930+ 33B6 46                   ld      B,(HL)          ; Get MSB
4931+ 33B7 36 80                ld      (HL),$80        ; Make value -0.5
4932+ 33B9 21 F2 53             ld      HL,SEED         ; Random number seed
4933+ 33BC 34                   inc     (HL)            ; Count seed
4934+ 33BD 7E                   ld      A,(HL)          ; Get seed
4935+ 33BE D6 AB                sub     $AB             ; Do it modulo 171
4936+ 33C0 C2 C7 33             jp      NZ,RND2         ; Non-zero - Ok
4937+ 33C3 77                   ld      (HL),A          ; Zero seed
4938+ 33C4 0C                   inc     C               ; Fillde about
4939+ 33C5 15                   dec     D               ; with the
4940+ 33C6 1C                   inc     E               ; number
4941+ 33C7 CD B1 2D     RND2:   call    BNORM           ; Normalise number
4942+ 33CA 21 15 54             ld      HL,LSTRND       ; Save random number
4943+ 33CD C3 4F 30             jp      FPTHL           ; Move FPREG to last and return
4944+ 33D0
4945+ 33D0 77           RESEED: ld      (HL),A          ; Re-seed random numbers
4946+ 33D1 2B                   dec     HL
4947+ 33D2 77                   ld      (HL),A
4948+ 33D3 2B                   dec     HL
4949+ 33D4 77                   ld      (HL),A
4950+ 33D5 C3 AB 33             jp      RND1            ; Return RND seed
4951+ 33D8
4952+ 33D8 68 B1 46 68  RNDTAB: defb    $68,$B1,$46,$68 ; Table used by RND
4953+ 33DC 99 E9 92 69          defb    $99,$E9,$92,$69
4954+ 33E0 10 D1 75 68          defb    $10,$D1,$75,$68
4955+ 33E4
4956+ 33E4              ; COS and SIN functions
4957+ 33E4 21 2E 34     COS:    ld      HL,HALFPI       ; Point to PI/2
4958+ 33E7 CD 51 2D             call    ADDPHL          ; Add it to PPREG
4959+ 33EA CD 28 30     SIN:    call    STAKFP          ; Put angle on stack
4960+ 33ED 01 49 83             ld      BC,$8349        ; BCDE = 2 PI
4961+ 33F0 11 DB 0F             ld      DE,$0FDB
4962+ 33F3 CD 38 30             call    FPBCDE          ; Move 2 PI to FPREG
4963+ 33F6 C1                   pop     BC              ; Restore angle
4964+ 33F7 D1                   pop     DE
4965+ 33F8 CD 4D 2F             call    DVBCDE          ; Divide angle by 2 PI
4966+ 33FB CD 28 30             call    STAKFP          ; Put it on stack
4967+ 33FE CD CA 30             call    INT             ; Get INT of result
4968+ 3401 C1                   pop     BC              ; Restore number
4969+ 3402 D1                   pop     DE
4970+ 3403 CD 5D 2D             call    SUBCDE          ; Make it 0 <= value < 1
4971+ 3406 21 32 34             ld      HL,QUARTR       ; Point to 0.25
4972+ 3409 CD 57 2D             call    SUBPHL          ; Subtract value from 0.25
4973+ 340C CD F7 2F             call    TSTSGN          ; Test sign of value
4974+ 340F 37                   scf                     ; Flag positive
4975+ 3410 F2 1A 34             jp      P,SIN1          ; Positive - Ok
4976+ 3413 CD 4E 2D             call    ROUND           ; Add 0.5 to value
4977+ 3416 CD F7 2F             call    TSTSGN          ; Test sign of value
4978+ 3419 B7                   or      A               ; Flag negative
4979+ 341A F5           SIN1:   push    AF              ; Save sign
4980+ 341B F4 20 30             call    P,INVSGN        ; Negate value if positive
4981+ 341E 21 32 34             ld      HL,QUARTR       ; Point to 0.25
4982+ 3421 CD 51 2D             call    ADDPHL          ; Add 0.25 to value
4983+ 3424 F1                   pop     AF              ; Restore sign
4984+ 3425 D4 20 30             call    NC,INVSGN       ; Negative - Make positive
4985+ 3428 21 36 34             ld      HL,SINTAB       ; Coefficient table
4986+ 342B C3 3F 33             jp      SUMSER          ; Evaluate sum of series
4987+ 342E
4988+ 342E DB 0F 49 81  HALFPI: defb    $DB,$0F,$49,$81 ; 1.5708 (PI/2)
4989+ 3432
4990+ 3432 00 00 00 7F  QUARTR: defb    $00,$00,$00,$7F ; 0.25
4991+ 3436
4992+ 3436 05           SINTAB: defb    $05             ; Table used by SIN
4993+ 3437 BA D7 1E 86          defb    $BA,$D7,$1E,$86 ; 39.711
4994+ 343B 64 26 99 87          defb    $64,$26,$99,$87 ;-76.575
4995+ 343F 58 34 23 87          defb    $58,$34,$23,$87 ; 81.602
4996+ 3443 E0 5D A5 86          defb    $E0,$5D,$A5,$86 ;-41.342
4997+ 3447 DA 0F 49 83          defb    $DA,$0F,$49,$83 ;  6.2832
4998+ 344B
4999+ 344B CD 28 30     TAN:    call    STAKFP          ; Put angle on stack
5000+ 344E CD EA 33             call    SIN             ; Get SIN of angle
5001+ 3451 C1                   pop     BC              ; Restore angle
5002+ 3452 E1                   pop     HL
5003+ 3453 CD 28 30             call    STAKFP          ; Save SIN of angle
5004+ 3456 EB                   ex      DE,HL           ; BCDE = Angle
5005+ 3457 CD 38 30             call    FPBCDE          ; Angle to FPREG
5006+ 345A CD E4 33             call    COS             ; Get COS of angle
5007+ 345D C3 4B 2F             jp      DIV             ; TAN = SIN / COS
5008+ 3460
5009+ 3460 CD F7 2F     ATN:    call    TSTSGN          ; Test sign of value
5010+ 3463 FC 8B 32             call    M,NEGAFT        ; Negate result after if -ve
5011+ 3466 FC 20 30             call    M,INVSGN        ; Negate value if -ve
5012+ 3469 3A D3 55             ld      A,(FPEXP)       ; Get exponent
5013+ 346C FE 81                cp      81H             ; Number less than 1?
5014+ 346E DA 7D 34             jp      C,ATN1          ; Yes - Get arc tangnt
5015+ 3471 01 00 81             ld      BC,$8100        ; BCDE = 1
5016+ 3474 51                   ld      D,C
5017+ 3475 59                   ld      E,C
5018+ 3476 CD 4D 2F             call    DVBCDE          ; Get reciprocal of number
5019+ 3479 21 57 2D             ld      HL,SUBPHL       ; Sub angle from PI/2
5020+ 347C E5                   push    HL              ; Save for angle > 1
5021+ 347D 21 87 34     ATN1:   ld      HL,ATNTAB       ; Coefficient table
5022+ 3480 CD 3F 33             call    SUMSER          ; Evaluate sum of series
5023+ 3483 21 2E 34             ld      HL,HALFPI       ; PI/2 - angle in case > 1
5024+ 3486 C9                   ret                     ; Number > 1 - Sub from PI/2
5025+ 3487
5026+ 3487 09           ATNTAB: defb    $09             ; Table used by ATN
5027+ 3488 4A D7 3B 78          defb    $4A,$D7,$3B,$78 ; 1/17
5028+ 348C 02 6E 84 7B          defb    $02,$6E,$84,$7B ;-1/15
5029+ 3490 FE C1 2F 7C          defb    $FE,$C1,$2F,$7C ; 1/13
5030+ 3494 74 31 9A 7D          defb    $74,$31,$9A,$7D ;-1/11
5031+ 3498 84 3D 5A 7D          defb    $84,$3D,$5A,$7D ; 1/9
5032+ 349C C8 7F 91 7E          defb    $C8,$7F,$91,$7E ;-1/7
5033+ 34A0 E4 BB 4C 7E          defb    $E4,$BB,$4C,$7E ; 1/5
5034+ 34A4 6C AA AA 7F          defb    $6C,$AA,$AA,$7F ;-1/3
5035+ 34A8 00 00 00 81          defb    $00,$00,$00,$81 ; 1/1
5036+ 34AC
5037+ 34AC
5038+ 34AC D7           GETINP: rst     $10             ; input a character
5039+ 34AD C9                   ret
5040+ 34AE
5041+ 34AE E5           CLS:    push    HL
5042+ 34AF D5                   push    DE
5043+ 34B0 3A 6E 55             ld      A,(SCR_MODE)    ; check screen mode
5044+ 34B3 FE 02                cp      $02             ; G2 mode?
5045+ 34B5 CC DB 05             call    Z,EMPTYVIDBUF   ; yes, reset video buffer
5046+ 34B8 D1                   pop     DE
5047+ 34B9 E1                   pop     HL
5048+ 34BA 3E 0C                ld      A,CS            ; ASCII Clear screen
5049+ 34BC CD 4E 1B             call    SND2VID         ; send to screen
5050+ 34BF C3 08 41             jp      MONOUT          ; Output character
5051+ 34C2
5052+ 34C2 CD 70 2A     WIDTH:  call    GETINT          ; Get integer 0-255
5053+ 34C5 7B                   ld      A,E             ; Width to A
5054+ 34C6 32 1C 54             ld      (LWIDTH),A      ; Set width
5055+ 34C9 C9                   ret
5056+ 34CA
5057+ 34CA
5058+ 34CA              ; read a word (2 bytes) from a couple of RAM locations, in little-endian format
5059+ 34CA              ; i.e., the first location is the LSB, while the second one is the MSB
5060+ 34CA CD 0F 1E     DEEK:   call    DEINT           ; Get integer -32768 to 32767
5061+ 34CD D5                   push    DE              ; Save number
5062+ 34CE E1                   pop     HL              ; Number to HL
5063+ 34CF 46                   ld      B,(HL)          ; Get LSB of contents
5064+ 34D0 23                   inc     HL
5065+ 34D1 7E                   ld      A,(HL)          ; Get MSB of contents
5066+ 34D2 C3 D4 25             jp      ABPASS          ; Return integer AB
5067+ 34D5
5068+ 34D5              ; write a word (2 bytes) into a couple of RAM locations, in little-endian format
5069+ 34D5              ; i.e., the LSB will go into the first location, while the MSB into the second one
5070+ 34D5 CD EA 21     DOKE:   call    GETNUM          ; Get a number
5071+ 34D8 CD 0F 1E             call    DEINT           ; Get integer -32768 to 32767
5072+ 34DB D5                   push    DE              ; Save address
5073+ 34DC CD 10 1B             call    CHKSYN          ; Make sure ',' follows
5074+ 34DF 2C                   defb    ','
5075+ 34E0 CD EA 21             call    GETNUM          ; Get a number
5076+ 34E3 CD 0F 1E             call    DEINT           ; Get integer -32768 to 32767
5077+ 34E6 E3                   ex      (SP),HL         ; Save value,get address
5078+ 34E7 73                   ld      (HL),E          ; Save LSB of value
5079+ 34E8 23                   inc     HL
5080+ 34E9 72                   ld      (HL),D          ; Save MSB of value
5081+ 34EA E1                   pop     HL              ; Restore code string address
5082+ 34EB C9                   ret
5083+ 34EC
5084+ 34EC              ; stop the execution of code for a certain bit of time. The pause
5085+ 34EC              ; is between $0000 and $FFFF 100ths of a second (0~655.5 secs)
5086+ 34EC CD EA 21     PAUSE:  call    GETNUM          ; Get a number
5087+ 34EF CD 0F 1E             call    DEINT           ; Get integer -32768 to 32767
5088+ 34F2 7A                   ld      A,D             ; load D into A
5089+ 34F3 B3                   or      E               ; are D & E equal to $00?
5090+ 34F4 C8                   ret     Z               ; if yes, then return
5091+ 34F5 C5                   push    BC              ; store BC
5092+ 34F6 3A 5C 55             ld      A,(TMRCNT)      ; Load current value of system timer
5093+ 34F9 47                   ld      B,A             ; move it into B
5094+ 34FA CD 84 1D     RPTPS:  call    TSTBRK          ; Test for break key
5095+ 34FD 3A 5C 55             ld      A,(TMRCNT)      ; Load current value of system timer
5096+ 3500 B8                   cp      B               ; is it the same value?
5097+ 3501 28 F7                jr      Z,RPTPS         ; yes, so read again
5098+ 3503 47                   ld      B,A             ; no, so store the new value
5099+ 3504 1B                   dec     DE              ; decrement interval
5100+ 3505 7A                   ld      A,D             ; load D into A
5101+ 3506 B3                   or      E               ; check if DE is equal to 0 (if D & e are $00 then result is 0)
5102+ 3507 20 F1                jr      NZ,RPTPS        ; no, repeat
5103+ 3509 C1                   pop     BC              ; yes, recover BC and continue
5104+ 350A C9                   ret
5105+ 350B
5106+ 350B              ; change the screen mode and set some graphic features. Usage: SCREEN X[,Y][,Z]
5107+ 350B              ; where X is graphic mode:
5108+ 350B              ; 0=text mode (40x24), 1=graphic mode 1 (32x24 chars); 2=graphic mode 2 (256x192 pixels);
5109+ 350B              ; 3=multicolor mode (64x48 pixels); 4=extended graphic mode 2 (32x24 chars mixed between G1 and G2)
5110+ 350B              ; Y is: 0=8x8 sprites, 1=16x16 sprites
5111+ 350B              ; Z is: 0=no sprite magnification; 1=sprite magnification x2 (8x8=>16x16, and 16x16=32x32)
5112+ 350B              ; (the latters are accepted only in graphic modes G1, G2, G3, and G4)
5113+ 350B AF           SCREEN: xor     A
5114+ 350C 32 7E 55             ld      (TMPBFR2),A     ; sprite size & magnif. byte set to 0
5115+ 350F CD 70 2A             call    GETINT          ; Get integer 0-255
5116+ 3512 FE 05                cp      $05             ; is it a valid mode (0~4)?
5117+ 3514 D2 24 1E             jp      NC,FCERR        ; No - Illegal function call Error
5118+ 3517 32 7C 55             ld      (TMPBFR1),A     ; store graphic mode
5119+ 351A A7                   and     A               ; is it 0 (text mode)?
5120+ 351B CA 37 35             jp      Z,SCVDP         ; yes, ignore other arguments and set mode immediately
5121+ 351E CD 76 35             call    CHKSCAR         ; no, check if sprite size follows
5122+ 3521 DA 29 35             jp      C,CKMAGN        ; no (set to 0 or missing), so jump over
5123+ 3524 3E 02                ld      A,$02           ; no, so set sprite size
5124+ 3526 32 7E 55             ld      (TMPBFR2),A     ; ...to 16x16
5125+ 3529 CD 76 35     CKMAGN: call    CHKSCAR         ; check if sprite magnification follows
5126+ 352C DA 37 35             jp      C,SCVDP         ; no (set to 0 or missing), so jump over
5127+ 352F 3A 7E 55             ld      A,(TMPBFR2)     ; yes, so retrieve sprite attributes...
5128+ 3532 F6 01                or      $01             ; ...set sprite magnification to 2x...
5129+ 3534 32 7E 55             ld      (TMPBFR2),A     ; ...and save flags again
5130+ 3537 F3           SCVDP:  di                      ; disable INTs
5131+ 3538 D5                   push    DE              ; store DE
5132+ 3539 E5                   push    HL              ; store HL
5133+ 353A 3A 7C 55             ld      A,(TMPBFR1)     ; recover graphic mode
5134+ 353D 5F                   ld      E,A             ; and store it into E
5135+ 353E 3A 7E 55             ld      A,(TMPBFR2)     ; recover sprite flags
5136+ 3541 57                   ld      D,A             ; and store them into D
5137+ 3542 D5                   push    DE              ; store D & E
5138+ 3543 CD D1 03             call    initVDP         ; initialize VDP with mode pointed by E
5139+ 3546 D1                   pop     DE              ; retrieve D & E
5140+ 3547 7B                   ld      A,E             ; move graphic mode into A
5141+ 3548 87                   add     A,A
5142+ 3549 87                   add     A,A
5143+ 354A 87                   add     A,A             ; multiply A times 8 to get offset of graphic mode
5144+ 354B 5F                   ld      E,A             ; and pass it into E
5145+ 354C D5                   push    DE              ; store sprite flags in E
5146+ 354D 16 00                ld      D,$00           ; reset D
5147+ 354F 21 23 0B             ld      HL,VDPMODESET+1 ; load address of VDP settings for reg#1
5148+ 3552 19                   add     HL,DE           ; load correct reg#1 setting
5149+ 3553 D1                   pop     DE              ; retrieve sprite flags from E
5150+ 3554 7E                   ld      A,(HL)          ; load reg#1 setting
5151+ 3555 E6 FC                and     %11111100       ; reset size & magn. bits
5152+ 3557 B2                   or      D               ; set size & magn. bits
5153+ 3558 5F                   ld      E,A             ; value into E
5154+ 3559 3E 01                ld      A,$01           ; reg #1
5155+ 355B CD B3 06             call    WRITE_VREG      ; send setting to reg #1
5156+ 355E 2A 29 54             ld      HL,(LINEAT)     ; Get current line number
5157+ 3561 23                   inc     HL              ; -1 means direct statement
5158+ 3562 7C                   ld      A,H
5159+ 3563 B5                   or      L
5160+ 3564 CC 26 09             call    Z,CURSOR_ON     ; enable cursor if not in program mode
5161+ 3567 FB                   ei                      ; re-enable interrupts
5162+ 3568 E1                   pop     HL              ; restore HL
5163+ 3569 D1                   pop     DE              ; restore DE
5164+ 356A 3A 6D 55             ld      A,(SCR_SIZE_H)  ; check the screen mode by looking at the screen height
5165+ 356D FE 30                cp      $30             ; is it 48 chars or 192 pixels (MC and G2 modes)?
5166+ 356F D0                   ret     NC              ; yes, so exit (in graphics 2 and multicolor no print-on-video)
5167+ 3570 3E 01                ld      A,$01           ; no (we are in Text, G1 or ExG2), so activate the...
5168+ 3572 32 78 55             ld      (PRNTVIDEO),A   ; ...video buffer...
5169+ 3575 C9                   ret                     ; ...and return to caller
5170+ 3576
5171+ 3576              ; check an additional argument for SCREEN - There are 2 ways of working:
5172+ 3576              ; to check if something follows: Carry is 1 is no argument follows, 0 otherwise
5173+ 3576              ; to check the value of the following argument: 0 is argument is 1, 1 is argument is <> 1
5174+ 3576 2B           CHKSCAR:dec     HL              ; dec 'cos GETCHR INCs
5175+ 3577 CD 59 1D             call    GETCHR          ; Get next character
5176+ 357A 37                   scf                     ; set carry flag
5177+ 357B C8                   ret     Z               ; return if nothing follows with Carry=1
5178+ 357C CD 10 1B             call    CHKSYN          ; Make sure ',' follows
5179+ 357F 2C                   defb    ','
5180+ 3580 CD 70 2A             call    GETINT          ; get value
5181+ 3583 1F                   rra                     ; Carry=bit #0
5182+ 3584 3F                   ccf                     ; invert Carry, so Carry=0 if arg. is 1, and Carry=1 otherwise (arg<>1)
5183+ 3585 C9                   ret                     ; return
5184+ 3586
5185+ 3586
5186+ 3586              ; change the colors of the screen - Syntax is COLOR a,b,c where:
5187+ 3586              ; a=foreground color / b=background color / c=border color
5188+ 3586              ; a,b,c must be in a range between 1 and 15 (0 is transparent and it's not supported)
5189+ 3586              ; the number of arguments is based on the current screen mode
5190+ 3586 CD 70 2A     COLOR:  call    GETINT          ; get first value
5191+ 3589 CD 2E 36             call    CHKCLR1         ; check if it's in range 1~15
5192+ 358C 32 7C 55             ld      (TMPBFR1),A     ; store it
5193+ 358F 3A 6E 55             ld      A,(SCR_MODE)    ; check screen mode
5194+ 3592 FE 03                cp      $03             ; is it multicolor mode?
5195+ 3594 20 0D                jr      NZ,CNTCKCL      ; no, continue
5196+ 3596 3E 0F                ld      A,$0F           ; white for...
5197+ 3598 32 7A 55             ld      (FRGNDCLR),A    ; ...foreground (even it's not used in MC)
5198+ 359B 3A 7C 55             ld      A,(TMPBFR1)     ; yes, so we stop here because in MC mode we just support border color
5199+ 359E 32 80 55             ld      (TMPBFR3),A     ; move color into temp buffer 3
5200+ 35A1 18 31                jr      CLRMC           ; jump to set color
5201+ 35A3 CD 10 1B     CNTCKCL:call    CHKSYN          ; Make sure ',' follows
5202+ 35A6 2C                   defb    ','
5203+ 35A7 CD 70 2A             call    GETINT          ; get second value
5204+ 35AA CD 2E 36             call    CHKCLR1         ; check if it's in range 1~15
5205+ 35AD 32 7E 55             ld      (TMPBFR2),A     ; store it
5206+ 35B0 3A 6E 55             ld      A,(SCR_MODE)    ; check screen mode
5207+ 35B3 A7                   and     A               ; is it text mode?
5208+ 35B4 28 1B                jr      Z,CLRTXT        ; yes, stop here because in text mode, background and border colors coincide
5209+ 35B6 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
5210+ 35B9 2C                   defb    ','
5211+ 35BA CD 70 2A             call    GETINT          ; get third value
5212+ 35BD CD 2E 36             call    CHKCLR1         ; check if it's in range 1~15
5213+ 35C0 32 80 55             ld      (TMPBFR3),A     ; store it
5214+ 35C3 D5                   push    DE              ; store DE
5215+ 35C4 3A 6E 55             ld      A,(SCR_MODE)    ; check screen mode
5216+ 35C7 FE 01                cp      $01             ; is it G1 mode?
5217+ 35C9 28 10                jr      Z,CLRG1         ; yes, jump over
5218+ 35CB FE 02                cp      $02             ; is it G2 mode?
5219+ 35CD 28 15                jr      Z,CLRG2         ; yes, jump over
5220+ 35CF 18 1C                jr      CLREX2          ; last case can only be ExG2
5221+ 35D1 CD 21 36     CLRTXT: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5222+ 35D4 32 80 55     CLRMC:  ld      (TMPBFR3),A     ; store color settings (for MC mode, we only set border color)
5223+ 35D7 D5                   push    DE              ; store DE
5224+ 35D8 F3                   di                      ; disable INTs
5225+ 35D9 18 2D                jr      SETBRCL         ; set colors and exit
5226+ 35DB CD 21 36     CLRG1:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5227+ 35DE 16 01                ld      D,$01           ; repeat 1 time
5228+ 35E0 06 20                ld      B,$20           ; 32 bytes of colors
5229+ 35E2 18 10                jr      LOADCLR         ; load colors
5230+ 35E4 CD 21 36     CLRG2:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5231+ 35E7 16 18                ld      D,$18           ; 18 pages of...
5232+ 35E9 06 00                ld      B,$00           ; ...256 bytes each
5233+ 35EB 18 07                jr      LOADCLR         ; load colors
5234+ 35ED CD 21 36     CLREX2: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5235+ 35F0 16 08                ld      D,$08           ; 8 pages of...
5236+ 35F2 06 00                ld      B,$00           ; ...256 bytes each
5237+ 35F4 E5           LOADCLR:push    HL              ; store HL
5238+ 35F5 21 00 20             ld      HL,$2000        ; color table start: $2000
5239+ 35F8 F3                   di                      ; disable INTs
5240+ 35F9 CD 69 06             call    SETVDPADRS
5241+ 35FC 0D                   dec     C               ; VDP data mode
5242+ 35FD ED 79        RPTLDCL:out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
5243+ 35FF 00                   nop
5244+ 3600 00                   nop
5245+ 3601 10 FA                djnz    RPTLDCL         ; repeat for 256 bytes (1 page)
5246+ 3603 15                   dec     D               ; did we fill up all the pages?
5247+ 3604 20 F7                jr      NZ,RPTLDCL      ; no, repeat
5248+ 3606 FB                   ei
5249+ 3607 E1                   pop     HL              ; retrieve HL
5250+ 3608 3A 7C 55     SETBRCL:ld      A,(TMPBFR1)     ; retrieve foreground color
5251+ 360B 32 7A 55             ld      (FRGNDCLR),A    ; store it
5252+ 360E 3A 7E 55             ld      A,(TMPBFR2)     ; retrieve background color
5253+ 3611 32 7B 55             ld      (BKGNDCLR),A    ; store it
5254+ 3614 3A 80 55             ld      A,(TMPBFR3)     ; recover border color
5255+ 3617 5F                   ld      E,A             ; move it into E
5256+ 3618 3E 07                ld      A,$07           ; set VDP register 7
5257+ 361A F3                   di
5258+ 361B CD B3 06             call    WRITE_VREG      ; send value to VDP: set border color
5259+ 361E FB                   ei                      ; re-enable INTs
5260+ 361F D1                   pop     DE              ; retrieve DE
5261+ 3620 C9                   ret                     ; return to caller
5262+ 3621
5263+ 3621
5264+ 3621              ; mix 2 color nibbles in 1 byte
5265+ 3621 3A 7E 55     MIXCLRS:ld      A,(TMPBFR2)     ; retrieve background color
5266+ 3624 47                   ld      B,A             ; move it into B
5267+ 3625 3A 7C 55             ld      A,(TMPBFR1)     ; retrieve foreground color
5268+ 3628 87                   add     A,A             ; move foreground color into the high nibble of A
5269+ 3629 87                   add     A,A
5270+ 362A 87                   add     A,A
5271+ 362B 87                   add     A,A
5272+ 362C B0                   or      B               ; put background color into the low nibble of A
5273+ 362D C9                   ret                     ; return to caller
5274+ 362E
5275+ 362E
5276+ 362E              ; check if the color is not 0 and into the range 1~15
5277+ 362E A7           CHKCLR1:and     A               ; is it 0?
5278+ 362F CA 10 18             jp      Z,SNERR         ; yes, raise a SN error
5279+ 3632 FE 10        CHKCLR0:cp      $10             ; is it in range 0~15?
5280+ 3634 D2 10 18             jp      NC,SNERR        ; no, raise a SN error
5281+ 3637 C9                   ret                     ; param is OK, can return
5282+ 3638
5283+ 3638
5284+ 3638              ; check if in graphics 2 mode
5285+ 3638 3A 6E 55     CHKG2M: ld      A,(SCR_MODE)    ; check screen mode
5286+ 363B FE 02                cp      $02             ; actually, we can paint only in G2
5287+ 363D C2 46 3C             jp      NZ,GMERR        ; no G2, print a No Graphics Mode Error
5288+ 3640 C9                   ret                     ; return to caller
5289+ 3641
5290+ 3641
5291+ 3641              ; print a text in screen 2
5292+ 3641              ; GPRINT text,x,y[,fc[,bc]]
5293+ 3641              ; where "text" is an expression that can be converted into a sequence of ASCII chars,
5294+ 3641              ; x & y are the coordinates (0<=x<=31, 0<=y<=23), fc & bc are foreground and background
5295+ 3641              ; colors (1~15), resp.
5296+ 3641              ; (portions of code are from nippur72)
5297+ 3641              GX      equ     TMPBFR3
5298+ 3641              GY      equ     TMPBFR4
5299+ 3641              TMPCLR  equ     TMPBFR2
5300+ 3641              MIXCOL  equ     TMPBFR1
5301+ 3641              TMPADR  equ     VIDEOBUFF
5302+ 3641              CHRPNT  equ     VIDEOBUFF+$02
5303+ 3641              NUMCHR  equ     VIDEOBUFF+$04
5304+ 3641              TMPHL   equ     VIDEOBUFF+$06
5305+ 3641 CD 38 36     GPRINT: call    CHKG2M          ; check if in graphic mode 2
5306+ 3644 2B                   dec     HL              ; dec 'cos GETCHR INCs
5307+ 3645 CD 59 1D             call    GETCHR          ; check if something follows
5308+ 3648 CA 10 18             jp      Z,SNERR         ; if nothing else, raise a syntax error
5309+ 364B 22 84 55             ld      (TMPADR),HL     ; save current code string pointer
5310+ 364E CD FC 21             call    EVAL            ; Evaluate expression
5311+ 3651 CD EE 21             call    TSTSTR          ; Make sure it's a string
5312+ 3654 22 8A 55             ld      (TMPHL),HL      ; store code string pointer
5313+ 3657 CD 35 28             call    GSTRCU          ; Current string to pool
5314+ 365A CD 46 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
5315+ 365D ED 43 86 55          ld      (CHRPNT),BC     ; store string pointer
5316+ 3661 ED 53 88 55          ld      (NUMCHR),DE     ; store string lenght
5317+ 3665 2A 8A 55             ld      HL,(TMPHL)      ; restore code string pointer
5318+ 3668 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
5319+ 366B 2C                   defb    ','
5320+ 366C CD 70 2A             call    GETINT          ; get X coord.
5321+ 366F FE 20                cp      $20             ; is it in rage 0~31?
5322+ 3671 D2 24 1E             jp      NC,FCERR        ; Illegal function call error
5323+ 3674 32 80 55             ld      (GX),A          ; store into temp. buffer
5324+ 3677 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
5325+ 367A 2C                   defb    ','
5326+ 367B CD 70 2A             call    GETINT          ; get Y coord.
5327+ 367E FE 18                cp      $18             ; is it in range 0~23?
5328+ 3680 D2 24 1E             jp      NC,FCERR        ; Illegal function call error
5329+ 3683 32 82 55             ld      (GY),A          ; store into temp. buffer
5330+ 3686 11 7E 55             ld      DE,TMPCLR
5331+ 3689 3A 7B 55             ld      A,(BKGNDCLR)    ; load background color
5332+ 368C 12                   ld      (DE),A          ; store into temp buff
5333+ 368D 3A 7A 55             ld      A,(FRGNDCLR)    ; load foreground color
5334+ 3690 1B                   dec     DE
5335+ 3691 1B                   dec     DE
5336+ 3692 12                   ld      (DE),A          ; store into temp buff
5337+ 3693 CD 1E 37             call    CKCOL           ; check color
5338+ 3696 CA 9E 36             jp      Z,CNTGPT2       ; if anything follows, jump over
5339+ 3699 13                   inc     DE
5340+ 369A 13                   inc     DE
5341+ 369B CD 1E 37             call    CKCOL           ; check background color
5342+ 369E CD 21 36     CNTGPT2:call    MIXCLRS         ; mix foreground & background colors
5343+ 36A1 32 7C 55             ld      (MIXCOL),A      ; store mixed colors
5344+ 36A4 E5                   push    HL              ; store code string address
5345+ 36A5 ED 4B 86 55          ld      BC,(CHRPNT)     ; retrieve string pointer
5346+ 36A9 ED 5B 88 55          ld      DE,(NUMCHR)     ; retrieve string lenght
5347+ 36AD 1C                   inc     E               ; Length + 1
5348+ 36AE CD B3 36             call    GPNT            ; print on G2
5349+ 36B1 E1                   pop     HL              ; recover HL
5350+ 36B2 C9                   ret                     ; return to caller
5351+ 36B3 D5           GPNT:   push    DE              ; store string lenght (E)
5352+ 36B4                      ; calculate VRAM address of first char
5353+ 36B4 3A 80 55             LD      A,(GX)          ; load X
5354+ 36B7 6F                   ld      L,A             ;
5355+ 36B8 26 00                ld      H,0             ; HL = X
5356+ 36BA 29                   add     HL,HL           ;
5357+ 36BB 29                   add     HL,HL           ;
5358+ 36BC 29                   add     HL,HL           ; X=X*8
5359+ 36BD 3A 82 55             ld      A,(GY)          ; load Y
5360+ 36C0 57                   ld      D,A             ; move it into D
5361+ 36C1 1E 00                ld      E,0             ; DE =Y*256
5362+ 36C3 19                   add     HL,DE           ; address = X*8 + Y*256
5363+ 36C4 22 84 55             ld      (TMPADR),HL     ; store VRAM address of first VRAM cell
5364+ 36C7 D1                   pop     DE              ; retrieve # of chars to be printed yet (E)
5365+ 36C8 1D           RPGPNT: dec     E               ; Count characters
5366+ 36C9 C8                   ret     Z               ; End of string - return
5367+ 36CA D5                   push    DE              ; store chars counter
5368+ 36CB                      ; calculate dest address in color vram
5369+ 36CB 2A 84 55             ld      HL,(TMPADR)     ; recover VRAM address
5370+ 36CE 11 00 20             ld      DE,$2000        ; color map address
5371+ 36D1 19                   add     HL,DE           ; HL = $2000 + XY address
5372+ 36D2 F3                   di                      ; disable INTs
5373+ 36D3                      ; send color settings
5374+ 36D3 CD 69 06             call    SETVDPADRS      ; set VRAM address for color cell
5375+ 36D6 3A 7C 55             ld      A,(MIXCOL)      ; load color settings
5376+ 36D9 06 08                ld      B,$08           ; repeat for 8 rows
5377+ 36DB 0E 30                ld      C,VDP_DAT       ; VDP data mode
5378+ 36DD ED 79        GPNTCO1:out     (C),A           ; send data (VRAM pointer auto-increments)
5379+ 36DF 00                   nop                     ; wait...
5380+ 36E0 00                   nop                     ; ...a...
5381+ 36E1 00                   nop                     ; ...while
5382+ 36E2 10 F9                djnz    GPNTCO1         ; repeat for 8 cells
5383+ 36E4                      ; calculate source address
5384+ 36E4 2A 86 55             ld      HL,(CHRPNT)     ; load char pointer
5385+ 36E7 7E                   ld      A,(HL)          ; get char
5386+ 36E8 23                   inc     HL              ; increment char pointer
5387+ 36E9 22 86 55             ld      (CHRPNT),HL     ; store char pointer
5388+ 36EC 6F                   ld      L,A             ;
5389+ 36ED 26 00                ld      H,$00           ; char into HL
5390+ 36EF 29                   add     HL,HL           ;
5391+ 36F0 29                   add     HL,HL           ;
5392+ 36F1 29                   add     HL,HL           ; get offset of char into ROM (charcode * 8)
5393+ 36F2 11 6B 4A             ld      DE,CHRST88      ; DE = start of 8x8 fonts in ROM
5394+ 36F5 19                   add     HL,DE           ; HL = start of characters in ROM
5395+ 36F6 EB                   ex      DE,HL           ; store address into DE
5396+ 36F7 2A 84 55             ld      HL,(TMPADR)     ; load VRAM address
5397+ 36FA CD 69 06             call    SETVDPADRS      ; send it to VDP
5398+ 36FD EB                   ex      DE,HL           ; restore address into HL
5399+ 36FE 06 08                ld      B,$08           ; repeat for 8 rows
5400+ 3700 0D                   dec     C               ; VDP data mode
5401+ 3701 ED A3        GPCPCH1:outi                    ; load a byte from ROM and send to VRAM
5402+ 3703 00                   nop                     ; wait...
5403+ 3704 00                   nop                     ; ...a...
5404+ 3705 00                   nop                     ; ...while
5405+ 3706 20 F9                jr      NZ,GPCPCH1      ; repeat for 8 chars
5406+ 3708 FB                   ei                      ; re-enable INTs
5407+ 3709 11 08 00             ld      DE,$0008        ; 8 bytes to go to the next video cell
5408+ 370C 2A 84 55             ld      HL,(TMPADR)     ; load VRAM address
5409+ 370F 19                   add     HL,DE           ; get address of next VRAM cell
5410+ 3710 22 84 55             ld      (TMPADR),HL     ; store new VRAM address
5411+ 3713 11 00 18             ld      DE,$1800        ; forbidden address
5412+ 3716 CD 35 41             call    CMP16           ; check if the printing has gone out of the screen
5413+ 3719 D1                   pop     DE              ; retrieve number of chars to be printed
5414+ 371A D0                   ret     NC              ; if HL>=$1800 then leave
5415+ 371B C3 C8 36             jp      RPGPNT          ; otherwise, check if more chars to output
5416+ 371E
5417+ 371E              ; used by GPRINT to get a color argument (if present)
5418+ 371E 2B           CKCOL:  dec     HL              ; dec 'cos GETCHR INCs
5419+ 371F CD 59 1D             call    GETCHR          ; Get next character
5420+ 3722 C8                   ret     Z               ; return if nothing follows
5421+ 3723 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
5422+ 3726 2C                   defb    ','
5423+ 3727 D5                   push    DE              ; store DE
5424+ 3728 CD 70 2A             call    GETINT          ; get value
5425+ 372B CD 2E 36             call    CHKCLR1         ; check if color is in range 1~15
5426+ 372E D1                   pop     DE              ; retrieve DE
5427+ 372F 12                   ld      (DE),A          ; store color into temp buffer
5428+ 3730 C9                   ret                     ; return to caller
5429+ 3731
5430+ 3731
5431+ 3731              ; paint X,Y[,C]: in graphics mode, fills an area starting
5432+ 3731              ; at point X,Y, using default color or, if used, with
5433+ 3731              ; color set by C
5434+ 3731              ; TMPBFR1       X
5435+ 3731              ; TMPBFR2       Y
5436+ 3731              ; TMPBFR3       COLOR
5437+ 3731              PNT     equ     VIDEOBUFF
5438+ 3731              ORGSP   equ     VIDEOBUFF+$02
5439+ 3731 CD 38 36     PAINT:  call    CHKG2M          ; check if in graphic mode 2
5440+ 3734 CD 70 2A             call    GETINT          ; get X
5441+ 3737 32 7C 55             ld      (TMPBFR1),A     ; store X
5442+ 373A CD 10 1B             call    CHKSYN          ; Make sure ',' follows
5443+ 373D 2C                   defb    ','
5444+ 373E CD 70 2A             call    GETINT          ; get Y coords,
5445+ 3741 FE C0                cp      $C0             ; check if Y is in range 0~191
5446+ 3743 D2 24 1E             jp      NC,FCERR        ; no, raise an FC error
5447+ 3746 32 7E 55             ld      (TMPBFR2),A     ; store Y
5448+ 3749 CD 2D 3C             call    CLRPRM          ; check if color has been passed
5449+ 374C 3A 80 55             ld      A,(TMPBFR3)     ; load color
5450+ 374F A7                   and     A               ; check if 0
5451+ 3750 CA 24 1E             jp      Z,FCERR         ; yes, raise an error
5452+ 3753 E5                   push    HL              ; store HL
5453+ 3754 C5                   push    BC              ; store BC
5454+ 3755 D5                   push    DE              ; store DE
5455+ 3756                      ; start algorithm
5456+ 3756 CD 69 38             call    PNTRTN          ; check if pixel is already set
5457+ 3759 C2 0D 38             jp      NZ,EXITPA2      ; if yes, then leave PAINT
5458+ 375C ED 73 86 55          ld      (ORGSP),SP      ; no, store current Stack Pointer
5459+ 3760 21 01 00             ld      HL,$0001        ; HL=1
5460+ 3763 22 84 55             ld      (PNT),HL        ; set PNT
5461+ 3766 3A 7C 55             ld      A,(TMPBFR1)     ; load starting X...
5462+ 3769 47                   ld      B,A             ; ...into B
5463+ 376A 3A 7E 55             ld      A,(TMPBFR2)     ; load starting Y...
5464+ 376D 4F                   ld      C,A             ; ...into C
5465+ 376E C5                   push    BC              ; store starting X,Y into stack
5466+ 376F                      ; main loop
5467+ 376F 2A 84 55     NXTLOOP:ld      HL,(PNT)        ; retrieve PNT
5468+ 3772 7C                   ld      A,H             ; check if PNT=0
5469+ 3773 B5                   or      L
5470+ 3774 CA 09 38             jp      Z,EXITPAI       ; yes, no more points to process - exit
5471+ 3777 2B                   dec     HL              ; no, so decrement PNT...
5472+ 3778 22 84 55             ld      (PNT),HL        ; ...and store it
5473+ 377B C1                   pop     BC              ; retrieve pixel coordinates X,Y into BC
5474+ 377C CD 11 38     PAINT0: call    CHECKPA         ; check if pixel is set/reset
5475+ 377F 20 09                jr      NZ,PAINT11      ; pixel is set, so jump over
5476+ 3781 78                   ld      A,B             ; pixel is reset, check if X1=0
5477+ 3782 A7                   and     A               ; (reached the limit of the screen)
5478+ 3783 CA 8B 37             jp      Z,PAINT1        ; yes, jump over
5479+ 3786 05                   dec     B               ; no, decrement X1...
5480+ 3787 C3 7C 37             jp      PAINT0          ; ...and repeat
5481+ 378A 04           PAINT11:inc     B               ; if found a pixel on, the re-increment X1
5482+ 378B AF           PAINT1: xor     A               ; reset A
5483+ 378C 57                   ld      D,A             ; set SA=0
5484+ 378D 5F                   ld      E,A             ; set SB=0
5485+ 378E CD 11 38     MNPAINT:call    CHECKPA         ; check if pixel is set/reset
5486+ 3791 20 DC                jr      NZ,NXTLOOP      ; it's set, so goto next loop
5487+ 3793 78                   ld      A,B             ; copy X1
5488+ 3794 32 7C 55             ld      (TMPBFR1),A     ; into buffer
5489+ 3797 79                   ld      A,C             ; copy Y
5490+ 3798 32 7E 55             ld      (TMPBFR2),A     ; into buffer
5491+ 379B CD 8F 38             call    CNTPLOT         ; plot pixel X1,Y
5492+ 379E 7A                   ld      A,D             ; load SA into A
5493+ 379F A7                   and     A               ; SA=0?
5494+ 37A0 20 1C                jr      NZ,PAINT2       ; no, jump over
5495+ 37A2 79                   ld      A,C             ; load Y
5496+ 37A3 FE 01                cp      $01             ; Y>0?
5497+ 37A5 DA BE 37             jp      C,PAINT2        ; no, jump over
5498+ 37A8 3D                   dec     A               ; yes, Y=Y-1
5499+ 37A9 CD 12 38             call    CHECKPY         ; check pixel X1,Y-1
5500+ 37AC 20 10                jr      NZ,PAINT2       ; it's set, so jump over
5501+ 37AE 0D                   dec     C               ; Y=Y-1
5502+ 37AF C5                   push    BC              ; insert pixel(X1,Y-1) into stack
5503+ 37B0 0C                   inc     C               ; retrieve original Y
5504+ 37B1 2A 84 55             ld      HL,(PNT)        ; load PNT
5505+ 37B4 23                   inc     HL              ; increment PNT
5506+ 37B5 22 84 55             ld      (PNT),HL        ; store new PNT
5507+ 37B8 3E 01                ld      A,$01           ; set SA=1 and...
5508+ 37BA 57                   ld      D,A             ; ...store SA into memory
5509+ 37BB C3 D1 37             jp      PAINT3          ; jump over
5510+ 37BE 7A           PAINT2: ld      A,D             ; load SA into A
5511+ 37BF 1F                   rra                     ; check if SA=1
5512+ 37C0 30 0F                jr      NC,PAINT3       ; no, jump over
5513+ 37C2 79                   ld      A,C             ; load Y
5514+ 37C3 FE 01                cp      $01             ; Y>0?
5515+ 37C5 DA D1 37             jp      C,PAINT3        ; no, jump over
5516+ 37C8 3D                   dec     A               ; Y=Y-1
5517+ 37C9 CD 12 38             call    CHECKPY         ; check pixel X1,Y-1
5518+ 37CC CA D1 37             jp      Z,PAINT3        ; if pixel is off, jump over
5519+ 37CF AF                   xor     A               ; pixel is on, so...
5520+ 37D0 57                   ld      D,A             ; ...set SA=0
5521+ 37D1 7B           PAINT3: ld      A,E             ; check if...
5522+ 37D2 A7                   and     A               ; SB=0
5523+ 37D3 20 1B                jr      NZ,PAINT4       ; no, jump over
5524+ 37D5 79                   ld      A,C             ; load Y
5525+ 37D6 FE BF                cp      $BF             ; Y<191?
5526+ 37D8 30 16                jr      NC,PAINT4       ; no, jump over
5527+ 37DA 3C                   inc     A               ; Y=Y+1
5528+ 37DB CD 12 38             call    CHECKPY         ; check pixel X1,Y+1
5529+ 37DE 20 10                jr      NZ,PAINT4       ; pixel is on, so jump over
5530+ 37E0 0C                   inc     C               ; Y=Y+1
5531+ 37E1 C5                   push    BC              ; insert pixel(X1,Y+1) into stack
5532+ 37E2 0D                   dec     C               ; retrieve original Y
5533+ 37E3 2A 84 55             ld      HL,(PNT)        ; PNT
5534+ 37E6 23                   inc     HL              ; PNT=PNT+1
5535+ 37E7 22 84 55             ld      (PNT),HL        ; store PNT
5536+ 37EA 3E 01                ld      A,$01           ; SB=1
5537+ 37EC 5F                   ld      E,A             ; set SB
5538+ 37ED C3 02 38             jp      PAINT5          ; jump over
5539+ 37F0 7B           PAINT4: ld      A,E             ; load SB
5540+ 37F1 1F                   rra                     ; check if SB=1
5541+ 37F2 30 0E                jr      NC,PAINT5       ; no, jump over
5542+ 37F4 79                   ld      A,C             ; load Y
5543+ 37F5 FE BF                cp      $BF             ; Y<191?
5544+ 37F7 30 09                jr      NC,PAINT5       ; no, jump over
5545+ 37F9 3C                   inc     A               ; Y=Y+1
5546+ 37FA CD 12 38             call    CHECKPY         ; check pixel X1,Y+1
5547+ 37FD CA 02 38             jp      Z,PAINT5        ; if pixel is off, jump over
5548+ 3800 AF                   xor     A               ; pixel is on, so...
5549+ 3801 5F                   ld      E,A             ; ...set SB=0
5550+ 3802 04           PAINT5: inc     B               ; X1=X1+1
5551+ 3803 CA 6F 37             jp      Z,NXTLOOP       ; if X1>255 (X1=0) then goto next loop
5552+ 3806 C3 8E 37             jp      MNPAINT         ; otherwise, repeat for next X
5553+ 3809 ED 7B 86 55  EXITPAI:ld      SP,(ORGSP)      ; retrieve original SP pointer
5554+ 380D D1           EXITPA2:pop     DE              ; retrieve DE
5555+ 380E C1                   pop     BC              ; retrieve BC
5556+ 380F E1                   pop     HL              ; retrieve HL
5557+ 3810 C9                   ret                     ; return to caller
5558+ 3811 79           CHECKPA:ld      A,C             ; copy Y into A
5559+ 3812 32 7E 55     CHECKPY:ld      (TMPBFR2),A     ; store Y
5560+ 3815 78                   ld      A,B             ; copy X1 into A
5561+ 3816 32 7C 55             ld      (TMPBFR1),A     ; store X1
5562+ 3819 C5                   push    BC              ; save X1,Y
5563+ 381A D5                   push    DE
5564+ 381B CD 69 38             call    PNTRTN          ; check if pixel is set/reset
5565+ 381E D1                   pop     DE
5566+ 381F C1                   pop     BC              ; retrieve X1,Y
5567+ 3820 C9                   ret                     ; return to caller
5568+ 3821
5569+ 3821
5570+ 3821              ; POINT(x,y): return if a pixel is set (returns color) or if it's reset (0)
5571+ 3821 CD 38 36     POINT:  call    CHKG2M          ; check if in graphic mode 2
5572+ 3824 CD 10 1B             call    CHKSYN          ; make sure "(" follows
5573+ 3827 28                   defb    '('
5574+ 3828 CD 70 2A             call    GETINT          ; get X coords.
5575+ 382B 32 7C 55             ld      (TMPBFR1),A     ; store it into a temp buffer
5576+ 382E CD 10 1B             call    CHKSYN          ; Make sure ',' follows
5577+ 3831 2C                   defb    ','
5578+ 3832 CD 70 2A             call    GETINT          ; get Y coords,
5579+ 3835 FE C0                cp      $C0             ; check if Y is in range 0~191
5580+ 3837 D2 24 1E             jp      NC,FCERR        ; no, raise an FC error
5581+ 383A 32 7E 55             ld      (TMPBFR2),A     ; store into a temp buffer
5582+ 383D CD 10 1B             call    CHKSYN          ; make sure ")" follows
5583+ 3840 29                   defb    ')'
5584+ 3841 E5                   push    HL              ; store current string address - the point after the ")" - ...
5585+ 3842 FD E1                pop     IY              ; ...into IY
5586+ 3844 CD 69 38             call    PNTRTN          ; check if pixel is set or reset
5587+ 3847 20 0C                jr      NZ,CTPOINT      ; it's ON, jump over
5588+ 3849 AF                   xor     A               ; no, it's OFF. make sure to reset A...
5589+ 384A 47                   ld      B,A             ; ...and B
5590+ 384B E1           PNTEND: pop     HL              ; drop original return point
5591+ 384C FD E5                push    IY              ; load current string address from IY into stack
5592+ 384E 11 D5 22             ld      DE,RETNUM       ; Address of Return number from function...
5593+ 3851 D5                   push    DE              ; ...saved on stack
5594+ 3852 C3 D4 25             jp      ABPASS          ; return AB
5595+ 3855 CB EC        CTPOINT:set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5596+ 3857 F3                   di
5597+ 3858 CD 89 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5598+ 385B FB                   ei
5599+ 385C CB 3F                srl     A               ; shift A...
5600+ 385E CB 3F                srl     A               ; ...4 times...
5601+ 3860 CB 3F                srl     A               ; ...to move foreground color...
5602+ 3862 CB 3F                srl     A               ; ...into lowest nibble
5603+ 3864 47                   ld      B,A             ; color into B
5604+ 3865 AF                   xor     A               ; reset MSB
5605+ 3866 C3 4B 38             jp      PNTEND          ; return AB
5606+ 3869 CD DC 38     PNTRTN: call    XY2HL           ; find HL address of pixel at X,Y
5607+ 386C 57                   ld      D,A             ; store pixel index
5608+ 386D F3                   di                      ; disable INTs
5609+ 386E CD 89 06             call    READ_VIDEO_LOC  ; read contents of VRAM cell addressed by HL
5610+ 3871 FB                   ei                      ; re-enable INTs
5611+ 3872 A2                   and     D               ; is the pixel ON or OFF? (will be checked later)
5612+ 3873 C9                   ret                     ; return to caller
5613+ 3874
5614+ 3874
5615+ 3874              ; PLOT X,Y[,color]
5616+ 3874              ; plot a pixel in graphic mode 2
5617+ 3874 CD 38 36     PLOT:   call    CHKG2M          ; check if in G2 mode
5618+ 3877 CD 70 2A             call    GETINT          ; get X coords.
5619+ 387A 32 7C 55             ld      (TMPBFR1),A     ; store it into a temp buffer
5620+ 387D CD 10 1B             call    CHKSYN          ; Make sure ',' follows
5621+ 3880 2C                   defb    ','
5622+ 3881 CD 70 2A             call    GETINT          ; get Y coords,
5623+ 3884 FE C0                cp      $C0             ; check if Y is in range 0~191
5624+ 3886 D2 24 1E             jp      NC,FCERR        ; no, raise an FC error
5625+ 3889 32 7E 55             ld      (TMPBFR2),A     ; store into a temp buffer
5626+ 388C CD 2D 3C             call    CLRPRM          ; check if param "color" has been passed
5627+ 388F E5           CNTPLOT:push    HL              ; store HL
5628+ 3890 C5                   push    BC              ; store BC
5629+ 3891 D5                   push    DE              ; store DE
5630+ 3892 CD DC 38             call    XY2HL           ; find VRAM address of byte containing pixel at X,Y & return into HL
5631+ 3895 D2 D0 38             jp      NC,NOGD         ; if carry is reset, there was an error -> so leave
5632+ 3898 57                   ld      D,A             ; move pixel value into D
5633+ 3899 3A 80 55             ld      A,(TMPBFR3)     ; retrieve color
5634+ 389C A7                   and     A               ; is it 0? (background, or reset pixel)
5635+ 389D 20 11                jr      NZ,CNTPLT1      ; no, continue
5636+ 389F F3                   di                      ; yes - so, disable INTs
5637+ 38A0 CD 89 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5638+ 38A3 FB                   ei                      ; re-enable INTs
5639+ 38A4 5F                   ld      E,A             ; store value of cell
5640+ 38A5 7A                   ld      A,D             ; retrieve pixel
5641+ 38A6 2F                   cpl                     ; revert bits
5642+ 38A7 A3                   and     E               ; set video pixel to off
5643+ 38A8 F3                   di                      ; disable INTs
5644+ 38A9 CD 9E 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5645+ 38AC FB                   ei                      ; re-enable INTs
5646+ 38AD C3 D0 38             jp      NOGD            ; leave
5647+ 38B0 87           CNTPLT1:add     A,A             ; now we move low nibble
5648+ 38B1 87                   add     A,A             ; in the high nibble
5649+ 38B2 87                   add     A,A             ; by adding A to itself
5650+ 38B3 87                   add     A,A             ; 4 times (this is a shift left 4)
5651+ 38B4 5F                   ld      E,A             ; move it into E
5652+ 38B5 F3                   di                      ; disable INTs
5653+ 38B6 CD 89 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5654+ 38B9 FB                   ei
5655+ 38BA B2                   or      D               ; merge new pixel preserving original pattern
5656+ 38BB F3                   di
5657+ 38BC CD 9E 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5658+ 38BF FB                   ei
5659+ 38C0 CB EC                set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5660+ 38C2 F3                   di
5661+ 38C3 CD 89 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5662+ 38C6 FB                   ei
5663+ 38C7 E6 0F                and     %00001111       ; reset high nibble (the foreground color)
5664+ 38C9 B3                   or      E               ; set new foreground color
5665+ 38CA F3                   di
5666+ 38CB CD 9E 06             call    WRITE_VIDEO_LOC ; write new color settings
5667+ 38CE FB                   ei                      ; re-enable INTs
5668+ 38CF 00                   nop                     ; wait for INTs to be enabled again
5669+ 38D0 D1           NOGD:   pop     DE              ; retrieve DE
5670+ 38D1 C1                   pop     BC              ; retrieve BC
5671+ 38D2 E1                   pop     HL              ; retrieve HL
5672+ 38D3 C9                   ret                     ; return to caller
5673+ 38D4 80 40 20 10  PXLSET: defb    $80,$40,$20,$10,$08,$04,$02,$01 ; pixel to be set ON
5673+ 38D8 08 04 02 01
5674+ 38DC                      ; where R(X/8)=> 0=80h, 1=40h, 2=20h, 3=10h, 4=08h, 5=04h, 6=02h, 7=$01
5675+ 38DC
5676+ 38DC
5677+ 38DC              ; compute the VRAM address of the byte containing the pixel
5678+ 38DC              ; being pointed by X,Y (TMPBFR1,TMPBFR2)
5679+ 38DC              ; byte address is returned into HL
5680+ 38DC              ; pixel is returned into A
5681+ 38DC              XY2HL:  ; formula is: ADDRESS=(INT(X/8))*8 + (INT(Y/8))*256 + R(Y/8)
5682+ 38DC                      ; where R(Y/8) is the remainder of (Y/8)
5683+ 38DC                      ; the pixel to be set is given by R(X/8), and data is taken from the array
5684+ 38DC 3A 7E 55             ld      A,(TMPBFR2)     ; retrieve Y
5685+ 38DF FE C0                cp      $C0             ; Y>=192?
5686+ 38E1 D0                   ret     NC              ; yes, so leave
5687+ 38E2 1E 08                ld      E,$08           ; load E with divisor
5688+ 38E4 57                   ld      D,A             ; and store into D (dividend)
5689+ 38E5 CD 80 41             call    DIV_8_8         ; get Y/8, D is quotient=INT(Y/8), and A is remainder
5690+ 38E8 4F                   ld      C,A             ; store remainder into C
5691+ 38E9 42                   ld      B,D             ; B=(INT(Y/8))*256 (we simply copy quotient into B)
5692+ 38EA 60 69                ld      HL,BC           ; copy BC into HL: now HL has the VRAM address of the byte being set
5693+ 38EC 3A 7C 55             ld      A,(TMPBFR1)     ; retrieve X
5694+ 38EF 57                   ld      D,A             ; and move it into D (dividend)
5695+ 38F0 CD 80 41             call    DIV_8_8         ; get X/8, D is quotient=INT(X/8), and A is remainder
5696+ 38F3 4F                   ld      C,A             ; store remainder into C
5697+ 38F4 7A                   ld      A,D             ; move quotient into A
5698+ 38F5 87                   add     A,A             ; multiply quotient by 8
5699+ 38F6 87                   add     A,A
5700+ 38F7 87                   add     A,A
5701+ 38F8 5F                   ld      E,A             ; store result into E
5702+ 38F9 16 00                ld      D,$00           ; reset D
5703+ 38FB 19                   add     HL,DE           ; add DE to HL, getting the final VRAM address
5704+ 38FC EB                   ex      DE,HL           ; move VRAM address into DE
5705+ 38FD 21 D4 38             ld      HL,PXLSET       ; starting address of table for pixel to draw
5706+ 3900 06 00                ld      B,$00           ; reset B
5707+ 3902 09                   add     HL,BC           ; add C (remainder of X/8) to get address of pixel to turn on
5708+ 3903 7E                   ld      A,(HL)          ; load pixel data
5709+ 3904 EB                   ex      DE,HL           ; retrieve VRAM pattern address into HL
5710+ 3905 37                   scf                     ; set Carry for normal exit
5711+ 3906 C9                   ret                     ; return to caller
5712+ 3907
5713+ 3907
5714+ 3907              ; DRAW X1,Y1,X2,Y2[,color]
5715+ 3907              ; Draw a line using Bresenham's line algorithm from X1,Y1 to X2,Y2
5716+ 3907              ; X1,Y1 can be either less than or greater than X2,Y2 (meaning that)
5717+ 3907              ; the drawing will be ever done from X1,Y2 to X2,Y2, regardless of
5718+ 3907              ; the values. If color is not specified, the foreground color set
5719+ 3907              ; with COLOR will be used
5720+ 3907              X1      equ     TMPBFR1
5721+ 3907              Y1      equ     TMPBFR2
5722+ 3907              X2      equ     VIDEOBUFF
5723+ 3907              Y2      equ     VIDEOBUFF+$02
5724+ 3907              ER      equ     VIDEOBUFF+$04
5725+ 3907              E2      equ     VIDEOBUFF+$06
5726+ 3907              SX      equ     VIDEOBUFF+$08
5727+ 3907              SY      equ     VIDEOBUFF+$0A
5728+ 3907              DX      equ     VIDEOBUFF+$0C
5729+ 3907              DY      equ     VIDEOBUFF+$0E
5730+ 3907 CD 38 36     DRAW:   call    CHKG2M          ; check if in G2 mode
5731+ 390A CD 0F 3C             call    CLRTMBF         ; clear TMPBFRx
5732+ 390D CD 1E 3C             call    CLRVDBF         ; clear VIDEOBUFF
5733+ 3910 CD 70 2A             call    GETINT          ; get X1 coords.
5734+ 3913 32 7C 55             ld      (X1),A          ; store it into a temp buffer
5735+ 3916 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
5736+ 3919 2C                   defb    ','
5737+ 391A CD 70 2A             call    GETINT          ; get Y1 coords.
5738+ 391D FE C0                cp      $C0             ; check if Y1 is in range 0~191
5739+ 391F D2 24 1E             jp      NC,FCERR        ; no, raise an FC error
5740+ 3922 32 7E 55             ld      (Y1),A          ; store into a temp buffer
5741+ 3925 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
5742+ 3928 2C                   defb    ','
5743+ 3929 CD 70 2A             call    GETINT          ; get X2 coords.
5744+ 392C 32 84 55             ld      (X2),A          ; store it into a temp buffer
5745+ 392F CD 10 1B             call    CHKSYN          ; Make sure ',' follows
5746+ 3932 2C                   defb    ','
5747+ 3933 CD 70 2A             call    GETINT          ; get Y2 coords
5748+ 3936 FE C0                cp      $C0             ; check if Y2 is in range 0~191
5749+ 3938 D2 24 1E             jp      NC,FCERR        ; no, raise an FC error
5750+ 393B 32 86 55             ld      (Y2),A          ; store it into a temp buffer
5751+ 393E CD 2D 3C             call    CLRPRM          ; check for arg. "color" and store it into TMPBFR3
5752+ 3941 E5                   push    HL              ; store register we'll use
5753+ 3942 D5                   push    DE
5754+ 3943 C5                   push    BC
5755+ 3944 ED 5B 7C 55          ld      DE,(X1)         ; load X1 and
5756+ 3948 2A 84 55             ld      HL,(X2)         ; X2
5757+ 394B B7                   or      A               ; clear CARRY
5758+ 394C ED 52                sbc     HL,DE           ; DX=X2-X1
5759+ 394E CD 76 41             call    absHL           ; DX=ABS(DX)
5760+ 3951 22 90 55             ld      (DX),HL         ; store DX
5761+ 3954 01 FF FF             ld      BC,$FFFF        ; SX=-1
5762+ 3957 2A 7C 55             ld      HL,(X1)
5763+ 395A ED 5B 84 55          ld      DE,(X2)
5764+ 395E CD 35 41             call    CMP16           ; X1<X2?
5765+ 3961 CA 6A 39             jp      Z,X1GR          ; no, X1=X2
5766+ 3964 F2 6A 39             jp      P,X1GR          ; no, X1>X2
5767+ 3967 01 01 00             ld      BC,$0001        ; yes, so set SX=1
5768+ 396A ED 43 8C 55  X1GR:   ld      (SX),BC         ; store SX
5769+ 396E ED 5B 7E 55          ld      DE,(Y1)
5770+ 3972 2A 86 55             ld      HL,(Y2)
5771+ 3975 B7                   or      A               ; clear Carry
5772+ 3976 ED 52                sbc     HL,DE           ; DY=Y2-Y1
5773+ 3978 CD 76 41             call    absHL           ; DY=ABS(DY)
5774+ 397B 22 92 55             ld      (DY),HL         ; store DY
5775+ 397E 01 FF FF             ld      BC,$FFFF        ; SY=-1
5776+ 3981 2A 7E 55             ld      HL,(Y1)
5777+ 3984 ED 5B 86 55          ld      DE,(Y2)
5778+ 3988 CD 35 41             call    CMP16           ; is Y1<Y2?
5779+ 398B CA 94 39             jp      Z,Y1GR          ; no, Y1=Y2
5780+ 398E F2 94 39             jp      P,Y1GR          ; no, Y1>Y2 - jump over
5781+ 3991 01 01 00             ld      BC,$0001        ; yes, so set SY=1
5782+ 3994 ED 43 8E 55  Y1GR:   ld      (SY),BC         ; store SY
5783+ 3998 2A 92 55             ld      HL,(DY)         ; ER=DY
5784+ 399B CD 79 41             call    negHL           ; ER=-DY
5785+ 399E 22 88 55             ld      (ER),HL         ; store ER
5786+ 39A1 2A 90 55             ld      HL,(DX)
5787+ 39A4 ED 5B 92 55          ld      DE,(DY)
5788+ 39A8 CD 35 41             call    CMP16           ; DX>DY?
5789+ 39AB CA B7 39             jp      Z,ER2           ; no, DX=DY
5790+ 39AE FA B7 39             jp      M,ER2           ; no, DX<DY
5791+ 39B1 2A 90 55             ld      HL,(DX)         ; reload DX
5792+ 39B4 22 88 55             ld      (ER),HL         ; yes: DX>DY, so ER=DX
5793+ 39B7 2A 88 55     ER2:    ld      HL,(ER)         ; load ER
5794+ 39BA CB 2C                sra     H               ; right shift (and preserve sign)...
5795+ 39BC CB 1D                rr      L               ; ...of HL, so ER=INT(ER/2)
5796+ 39BE CB 7C                bit     7,H             ; is the number negative?
5797+ 39C0 CA C4 39             jp      Z,STRE2         ; no, jump over
5798+ 39C3 23                   inc     HL              ; yes, add 1 'cos INT of a negative number needs to be incremented
5799+ 39C4 22 88 55     STRE2:  ld      (ER),HL         ; store ER
5800+ 39C7 CD 8F 38     RPTDRW: call    CNTPLOT         ; plot first pixel
5801+ 39CA 2A 7C 55             ld      HL,(X1)
5802+ 39CD ED 5B 84 55          ld      DE,(X2)
5803+ 39D1 CD 35 41             call    CMP16           ; X1=X2?
5804+ 39D4 20 0D                jr      NZ,CNTDRW       ; no, continue drawing
5805+ 39D6 2A 7E 55             ld      HL,(Y1)         ; yes, so check
5806+ 39D9 ED 5B 86 55          ld      DE,(Y2)         ; also Y
5807+ 39DD CD 35 41             call    CMP16           ; Y1=Y2?
5808+ 39E0 CA 3C 3A             jp      Z,ENDDRAW       ; yes, finished drawing: exit
5809+ 39E3 ED 5B 88 55  CNTDRW: ld      DE,(ER)
5810+ 39E7 ED 53 8A 55          ld      (E2),DE         ; E2=ER
5811+ 39EB 2A 90 55             ld      HL,(DX)
5812+ 39EE CD 79 41             call    negHL           ; DX=-DX
5813+ 39F1 EB                   ex      DE,HL           ; invert DE and HL => HL=E2, DE=-DX
5814+ 39F2 CD 35 41             call    CMP16           ; E2>-DX?
5815+ 39F5 CA 13 3A             jp      Z,DXGR          ; no, E2=-DX: jump
5816+ 39F8 FA 13 3A             jp      M,DXGR          ; no, E2<-DX: jump
5817+ 39FB 2A 88 55             ld      HL,(ER)         ; yes
5818+ 39FE ED 5B 92 55          ld      DE,(DY)
5819+ 3A02 B7                   or      A               ; clear CARRY
5820+ 3A03 ED 52                sbc     HL,DE           ; ER=ER-DY
5821+ 3A05 22 88 55             ld      (ER),HL
5822+ 3A08 2A 7C 55             ld      HL,(X1)
5823+ 3A0B ED 5B 8C 55          ld      DE,(SX)
5824+ 3A0F 19                   add     HL,DE           ; X1=X1+SX (increment X1)
5825+ 3A10 22 7C 55             ld      (X1),HL
5826+ 3A13 2A 8A 55     DXGR:   ld      HL,(E2)
5827+ 3A16 ED 5B 92 55          ld      DE,(DY)
5828+ 3A1A CD 35 41             call    CMP16           ; E2<DY?
5829+ 3A1D CA C7 39             jp      Z,RPTDRW        ; no, E2=DY: jump
5830+ 3A20 F2 C7 39             jp      P,RPTDRW        ; no, E2>DY: jump
5831+ 3A23 2A 88 55             ld      HL,(ER)         ; yes
5832+ 3A26 ED 5B 90 55          ld      DE,(DX)
5833+ 3A2A 19                   add     HL,DE           ; ER=ER+DX
5834+ 3A2B 22 88 55             ld      (ER),HL
5835+ 3A2E 2A 7E 55             ld      HL,(Y1)
5836+ 3A31 ED 5B 8E 55          ld      DE,(SY)
5837+ 3A35 19                   add     HL,DE           ; Y1=Y1+SY (increment Y1)
5838+ 3A36 22 7E 55             ld      (Y1),HL
5839+ 3A39 C3 C7 39             jp      RPTDRW          ; repeat
5840+ 3A3C C1           ENDDRAW:pop     BC              ; retrieve BC
5841+ 3A3D D1                   pop     DE              ; retrieve DE
5842+ 3A3E E1                   pop     HL              ; retrieve HL
5843+ 3A3F C9                   ret                     ; return to caller
5844+ 3A40
5845+ 3A40
5846+ 3A40              ; CIRCLE X,Y,R[,C]
5847+ 3A40              ; Draw a circle using Bresenham's circle algorithm with center in X,Y
5848+ 3A40              ; and radius R, with optional color C. If color is not specified, the
5849+ 3A40              ; foreground color set with COLOR will be used
5850+ 3A40              XC      equ     VIDEOBUFF
5851+ 3A40              YC      equ     VIDEOBUFF+$02
5852+ 3A40              RADIUS  equ     VIDEOBUFF+$04
5853+ 3A40              XI      equ     VIDEOBUFF+$06
5854+ 3A40              YI      equ     VIDEOBUFF+$08
5855+ 3A40              DC      equ     VIDEOBUFF+$0A
5856+ 3A40 CD 38 36     CIRCLE: call    CHKG2M          ; check if in G2 mode
5857+ 3A43 CD 1E 3C             call    CLRVDBF         ; clear VIDEOBUFF
5858+ 3A46 CD 70 2A             call    GETINT          ; get X coords.
5859+ 3A49 32 84 55             ld      (XC),A          ; store it into a temp buffer
5860+ 3A4C CD 10 1B             call    CHKSYN          ; Make sure ',' follows
5861+ 3A4F 2C                   defb    ','
5862+ 3A50 CD 70 2A             call    GETINT          ; get Y coords,
5863+ 3A53 32 86 55             ld      (YC),A          ; store it into a temp buffer
5864+ 3A56 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
5865+ 3A59 2C                   defb    ','
5866+ 3A5A CD 70 2A             call    GETINT          ; get radius
5867+ 3A5D 32 88 55             ld      (RADIUS),A      ; store it into a temp buffer
5868+ 3A60 CD 2D 3C             call    CLRPRM          ; check if param "color" has been passed
5869+ 3A63 C5                   push    BC              ; store BC
5870+ 3A64 D5                   push    DE              ; store DE
5871+ 3A65 E5                   push    HL              ; store HL
5872+ 3A66 AF                   xor     A               ; clear A,
5873+ 3A67 47                   ld      B,A             ; B,
5874+ 3A68 4F                   ld      C,A             ; C,
5875+ 3A69 57                   ld      D,A             ; D,
5876+ 3A6A 67                   ld      H,A             ; and H
5877+ 3A6B ED 43 8A 55          ld      (XI),BC         ; clear XI
5878+ 3A6F 3A 88 55             ld      A,(RADIUS)      ; load RADIUS into A
5879+ 3A72 6F                   ld      L,A             ; HL now contains R
5880+ 3A73 22 8C 55             ld      (YI),HL         ; YI=RADIUS
5881+ 3A76 29                   add     HL,HL           ; R*2
5882+ 3A77 EB                   ex      DE,HL           ; put HL into DE
5883+ 3A78 21 03 00             ld      HL,$0003        ; HL = 3
5884+ 3A7B AF                   xor     A               ; clear Carry
5885+ 3A7C ED 52                sbc     HL,DE           ; D=3-(2*R) => HL
5886+ 3A7E 22 8E 55             ld      (DC),HL         ; store D
5887+ 3A81 CD E0 3A             call    DRWCRL          ; draw initial point
5888+ 3A84 ED 5B 8A 55  RPTCRL: ld      DE,(XI)         ; load XI
5889+ 3A88 2A 8C 55             ld      HL,(YI)         ; load YI
5890+ 3A8B CD 35 41             call    CMP16           ; is YI<DI?
5891+ 3A8E CA 97 3A             jp      Z,RPTCL1        ; no, YI=XI
5892+ 3A91 F2 97 3A             jp      P,RPTCL1        ; no, YI>XI
5893+ 3A94 C3 DC 3A             jp      ENDCRL          ; yes, so we've finished
5894+ 3A97 21 8A 55     RPTCL1: ld      HL,XI
5895+ 3A9A 34                   inc     (HL)            ; XI=XI+1
5896+ 3A9B 2A 8E 55             ld      HL,(DC)         ; load D
5897+ 3A9E 7C                   ld      A,H
5898+ 3A9F B5                   or      L               ; is D=0? Yes, jump over
5899+ 3AA0 CA C4 3A             jp      Z,DLSZ
5900+ 3AA3 CB 7C                bit     7,H             ; is D<0?
5901+ 3AA5 20 1D                jr      NZ,DLSZ         ; yes, jump over
5902+ 3AA7 ED 5B 8C 55          ld      DE,(YI)         ; D>0
5903+ 3AAB 1B                   dec     DE              ; so, YI=YI-1
5904+ 3AAC ED 53 8C 55          ld      (YI),DE         ; store YI
5905+ 3AB0 AF                   xor     A               ; clear Carry
5906+ 3AB1 2A 8A 55             ld      HL,(XI)
5907+ 3AB4 ED 52                sbc     HL,DE           ; HL=XI-YI
5908+ 3AB6 29                   add     HL,HL
5909+ 3AB7 29                   add     HL,HL           ; HL=HL*4
5910+ 3AB8 11 0A 00             ld      DE,10
5911+ 3ABB 19                   add     HL,DE           ; HL=HL+10
5912+ 3ABC ED 5B 8E 55          ld      DE,(DC)         ; load D
5913+ 3AC0 EB                   ex      DE,HL           ; invert DE and HL, so that HL=4*(XI-YI)+10 and DE=D
5914+ 3AC1 19                   add     HL,DE           ; D=D+4*(XI-YI)+10
5915+ 3AC2 18 0F                jr      PLTCRL          ; plot next pixel
5916+ 3AC4 2A 8A 55     DLSZ:   ld      HL,(XI)         ; load XI
5917+ 3AC7 29                   add     HL,HL
5918+ 3AC8 29                   add     HL,HL           ; XI=XI*4
5919+ 3AC9 11 06 00             ld      DE,$0006
5920+ 3ACC 19                   add     HL,DE
5921+ 3ACD ED 5B 8E 55          ld      DE,(DC)
5922+ 3AD1 EB                   ex      DE,HL           ; HL=D and DE=4*XI+6
5923+ 3AD2 19                   add     HL,DE           ; D=D+4*XI+6
5924+ 3AD3 22 8E 55     PLTCRL: ld      (DC),HL         ; store new D
5925+ 3AD6 CD E0 3A             call    DRWCRL          ; plot pixel
5926+ 3AD9 C3 84 3A             jp      RPTCRL          ; repeat
5927+ 3ADC E1           ENDCRL: pop     HL
5928+ 3ADD D1                   pop     DE
5929+ 3ADE C1                   pop     BC
5930+ 3ADF C9                   ret                     ; return to caller
5931+ 3AE0 2A 84 55     DRWCRL: ld      HL,(XC)
5932+ 3AE3 ED 5B 8A 55          ld      DE,(XI)
5933+ 3AE7 19                   add     HL,DE           ; X=XC+XI
5934+ 3AE8 22 7C 55             ld      (X1),HL         ; store X
5935+ 3AEB CD FF 3B             call    VALIDX          ; check if X is valid (0~255)
5936+ 3AEE DA 02 3B             jp      C,CNTCL1        ; if Carry is set, X is not valid
5937+ 3AF1 2A 86 55             ld      HL,(YC)
5938+ 3AF4 ED 5B 8C 55          ld      DE,(YI)
5939+ 3AF8 19                   add     HL,DE           ; Y=YC+YI
5940+ 3AF9 22 7E 55             ld      (Y1),HL         ; store Y
5941+ 3AFC CD 04 3C             call    VALIDY          ; check if Y is valid (0~191)
5942+ 3AFF D4 8F 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5943+ 3B02 AF           CNTCL1: xor     A               ; clear Carry
5944+ 3B03 2A 84 55             ld      HL,(XC)
5945+ 3B06 ED 5B 8A 55          ld      DE,(XI)
5946+ 3B0A ED 52                sbc     HL,DE           ; X=XC-XI
5947+ 3B0C 22 7C 55             ld      (X1),HL         ; store X
5948+ 3B0F CD FF 3B             call    VALIDX          ; check if X is valid (0~255)
5949+ 3B12 DA 26 3B             jp      C,CNTCL2        ; if Carry is set, X is not valid
5950+ 3B15 2A 86 55             ld      HL,(YC)
5951+ 3B18 ED 5B 8C 55          ld      DE,(YI)
5952+ 3B1C 19                   add     HL,DE           ; Y=YC+YI
5953+ 3B1D 22 7E 55             ld      (Y1),HL         ; store Y
5954+ 3B20 CD 04 3C             call    VALIDY          ; check if Y is valid (0~191)
5955+ 3B23 D4 8F 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5956+ 3B26 2A 84 55     CNTCL2: ld      HL,(XC)
5957+ 3B29 ED 5B 8A 55          ld      DE,(XI)
5958+ 3B2D 19                   add     HL,DE           ; X=XC+XI
5959+ 3B2E 22 7C 55             ld      (X1),HL         ; store X
5960+ 3B31 CD FF 3B             call    VALIDX          ; check if X is valid (0~255)
5961+ 3B34 DA 4A 3B             jp      C,CNTCL3        ; if Carry is set, X is not valid
5962+ 3B37 AF                   xor     A               ; clear Carry
5963+ 3B38 2A 86 55             ld      HL,(YC)
5964+ 3B3B ED 5B 8C 55          ld      DE,(YI)
5965+ 3B3F ED 52                sbc     HL,DE           ; Y=YC-YI
5966+ 3B41 22 7E 55             ld      (Y1),HL         ; store Y
5967+ 3B44 CD 04 3C             call    VALIDY          ; check if Y is valid (0~191)
5968+ 3B47 D4 8F 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5969+ 3B4A AF           CNTCL3: xor     A               ; clear Carry
5970+ 3B4B 2A 84 55             ld      HL,(XC)
5971+ 3B4E ED 5B 8A 55          ld      DE,(XI)
5972+ 3B52 ED 52                sbc     HL,DE           ; X=XC-XI
5973+ 3B54 22 7C 55             ld      (X1),HL         ; store X
5974+ 3B57 CD FF 3B             call    VALIDX          ; check if X is valid (0~255)
5975+ 3B5A DA 70 3B             jp      C,CNTCL4        ; if Carry is set, X is not valid
5976+ 3B5D AF                   xor     A               ; clear Carry
5977+ 3B5E 2A 86 55             ld      HL,(YC)
5978+ 3B61 ED 5B 8C 55          ld      DE,(YI)
5979+ 3B65 ED 52                sbc     HL,DE           ; Y=YC-YI
5980+ 3B67 22 7E 55             ld      (Y1),HL         ; store Y
5981+ 3B6A CD 04 3C             call    VALIDY          ; check if Y is valid (0~191)
5982+ 3B6D D4 8F 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5983+ 3B70 2A 84 55     CNTCL4: ld      HL,(XC)
5984+ 3B73 ED 5B 8C 55          ld      DE,(YI)
5985+ 3B77 19                   add     HL,DE           ; X=XC+YI
5986+ 3B78 22 7C 55             ld      (X1),HL         ; store X
5987+ 3B7B CD FF 3B             call    VALIDX          ; check if X is valid (0~255)
5988+ 3B7E DA 92 3B             jp      C,CNTCL5        ; if Carry is set, X is not valid
5989+ 3B81 2A 86 55             ld      HL,(YC)
5990+ 3B84 ED 5B 8A 55          ld      DE,(XI)
5991+ 3B88 19                   add     HL,DE           ; Y=YC+XI
5992+ 3B89 22 7E 55             ld      (Y1),HL         ; store Y
5993+ 3B8C CD 04 3C             call    VALIDY          ; check if Y is valid (0~191)
5994+ 3B8F D4 8F 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5995+ 3B92 AF           CNTCL5: xor     A               ; clear Carry
5996+ 3B93 2A 84 55             ld      HL,(XC)
5997+ 3B96 ED 5B 8C 55          ld      DE,(YI)
5998+ 3B9A ED 52                sbc     HL,DE           ; X=XC-YI
5999+ 3B9C 22 7C 55             ld      (X1),HL         ; store X
6000+ 3B9F CD FF 3B             call    VALIDX          ; check if X is valid (0~255)
6001+ 3BA2 DA B6 3B             jp      C,CNTCL6        ; if Carry is set, X is not valid
6002+ 3BA5 2A 86 55             ld      HL,(YC)
6003+ 3BA8 ED 5B 8A 55          ld      DE,(XI)
6004+ 3BAC 19                   add     HL,DE           ; Y=YC+XI
6005+ 3BAD 22 7E 55             ld      (Y1),HL         ; store Y
6006+ 3BB0 CD 04 3C             call    VALIDY          ; check if Y is valid (0~191)
6007+ 3BB3 D4 8F 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
6008+ 3BB6 2A 84 55     CNTCL6: ld      HL,(XC)
6009+ 3BB9 ED 5B 8C 55          ld      DE,(YI)
6010+ 3BBD 19                   add     HL,DE           ; X=XC+YI
6011+ 3BBE 22 7C 55             ld      (X1),HL         ; store X
6012+ 3BC1 CD FF 3B             call    VALIDX          ; check if X is valid (0~255)
6013+ 3BC4 DA DA 3B             jp      C,CNTCL7        ; if Carry is set, X is not valid
6014+ 3BC7 AF                   xor     A               ; clear Carry
6015+ 3BC8 2A 86 55             ld      HL,(YC)
6016+ 3BCB ED 5B 8A 55          ld      DE,(XI)
6017+ 3BCF ED 52                sbc     HL,DE           ; Y=YC-XI
6018+ 3BD1 22 7E 55             ld      (Y1),HL         ; store Y
6019+ 3BD4 CD 04 3C             call    VALIDY          ; check if Y is valid (0~191)
6020+ 3BD7 D4 8F 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
6021+ 3BDA AF           CNTCL7: xor     A               ; clear Carry
6022+ 3BDB 2A 84 55             ld      HL,(XC)
6023+ 3BDE ED 5B 8C 55          ld      DE,(YI)
6024+ 3BE2 ED 52                sbc     HL,DE           ; X=XC-YI
6025+ 3BE4 22 7C 55             ld      (X1),HL         ; store X
6026+ 3BE7 CD FF 3B             call    VALIDX          ; check if X is valid (0~255)
6027+ 3BEA D8                   ret     C               ; if Carry is set, X is not valid
6028+ 3BEB AF                   xor     A               ; clear Carry
6029+ 3BEC 2A 86 55             ld      HL,(YC)
6030+ 3BEF ED 5B 8A 55          ld      DE,(XI)
6031+ 3BF3 ED 52                sbc     HL,DE           ; Y=YC-XI
6032+ 3BF5 22 7E 55             ld      (Y1),HL         ; store Y
6033+ 3BF8 CD 04 3C             call    VALIDY          ; check if Y is valid (0~191)
6034+ 3BFB D4 8F 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
6035+ 3BFE C9                   ret                     ; return to caller
6036+ 3BFF
6037+ 3BFF              ; check if X,Y coordinates are valid: 0<=X<=255 and 0<=Y<=191
6038+ 3BFF              ; input: HL (value to check), can be negative
6039+ 3BFF              ; output: CARRY flag: reset => VALID  //  set => NOT VALID
6040+ 3BFF              ; destroys: A
6041+ 3BFF AF           VALIDX: xor     A               ; reset A
6042+ 3C00 B4                   or      H               ; check if H is 0 (this means that X is in range 0~255 and not negative)
6043+ 3C01 C8                   ret     Z               ; yes, we can return (C is clear)
6044+ 3C02 37                   scf                     ; set Carry flag to raise error
6045+ 3C03 C9                   ret                     ; return to caller
6046+ 3C04
6047+ 3C04 AF           VALIDY: xor     A               ; reset A
6048+ 3C05 B4                   or      H               ; check if H is 0 (this means that Y is in range 0~255 and not negative)
6049+ 3C06 28 02                jr      Z,CNTVALY       ; yes, continue checking
6050+ 3C08 37                   scf                     ; no, raise error by setting Carry flag
6051+ 3C09 C9                   ret                     ; return to caller
6052+ 3C0A 7D           CNTVALY:ld      A,L
6053+ 3C0B FE C0                cp      $C0             ; is Y<192? Carry is set if Y<192
6054+ 3C0D 3F                   ccf                     ; invert Carry, so Carry=0 means OK, Carry=1 means ERROR
6055+ 3C0E C9                   ret                     ; return to caller
6056+ 3C0F
6057+ 3C0F
6058+ 3C0F
6059+ 3C0F              ; cleat TMPBFR1-4 buffers before using them
6060+ 3C0F AF           CLRTMBF:xor     A               ; reset A
6061+ 3C10 E5                   push    HL              ; store HL
6062+ 3C11 C5                   push    BC              ; store BC
6063+ 3C12 21 7C 55             ld      HL,TMPBFR1      ; address of 1st location
6064+ 3C15 06 08                ld      B,$08           ; 8 locations
6065+ 3C17 77           RPCLTMB:ld      (HL),A          ; clear byte
6066+ 3C18 23                   inc     HL              ; next location
6067+ 3C19 10 FC                djnz    RPCLTMB         ; repeat
6068+ 3C1B C1                   pop     BC              ; retrieve BC
6069+ 3C1C E1                   pop     HL              ; retrieve HL
6070+ 3C1D C9                   ret                     ; return to caller
6071+ 3C1E
6072+ 3C1E
6073+ 3C1E              ; clear VIDEOBUFF before using it as temp buffer
6074+ 3C1E AF           CLRVDBF:xor     A               ; clear A
6075+ 3C1F C5                   push    BC              ; store BC
6076+ 3C20 E5                   push    HL              ; store HL
6077+ 3C21 06 28                ld      B,$28           ; 40 cells
6078+ 3C23 21 84 55             ld      HL,VIDEOBUFF    ; address of 1st cell
6079+ 3C26 77           RPTCVBF:ld      (HL),A          ; clear cell
6080+ 3C27 23                   inc     HL              ; next cell
6081+ 3C28 10 FC                djnz    RPTCVBF         ; repeat
6082+ 3C2A E1                   pop     HL              ; retrieve HL
6083+ 3C2B C1                   pop     BC              ; retrieve BC
6084+ 3C2C C9                   ret                     ; return to caller
6085+ 3C2D
6086+ 3C2D
6087+ 3C2D              ; check if a color is passed as argument with PLOT, DRAW, and CIRCLE
6088+ 3C2D              ; commands. If not present, the default foreground color will be used
6089+ 3C2D 3A 7A 55     CLRPRM: ld      A,(FRGNDCLR)    ; load foreground color
6090+ 3C30 32 80 55             ld      (TMPBFR3),A     ; store into temp buffer
6091+ 3C33 2B                   dec     HL              ; dec 'cos GETCHR INCs
6092+ 3C34 CD 59 1D             call    GETCHR          ; Get next character
6093+ 3C37 C8                   ret     Z               ; return foreground color if nothing follows
6094+ 3C38 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
6095+ 3C3B 2C                   defb    ','
6096+ 3C3C CD 70 2A             call    GETINT          ; get value
6097+ 3C3F CD 32 36             call    CHKCLR0         ; check if color is in range 0~15
6098+ 3C42 32 80 55             ld      (TMPBFR3),A     ; store color into temp buffer
6099+ 3C45 C9                   ret                     ; return to caller
6100+ 3C46
6101+ 3C46
6102+ 3C46              ; no graphics mode error: raised when a graphics command is invoked
6103+ 3C46              ; out of graphic 2 mode.
6104+ 3C46 1E 2A        GMERR:  ld      E,GM            ; load Graphics Mode Error flag
6105+ 3C48 C3 2A 18             jp      ERROR           ; print error
6106+ 3C4B
6107+ 3C4B
6108+ 3C4B              ; set a serial port: params are PORT,BPS,DATA,PARITY,STOP
6109+ 3C4B              ; PORT=1/2; BPS=1,200~57,600 (see below), DATA=5/6/7/8
6110+ 3C4B              ; PARITY: 0=no parity; 1=ODD parity; 2=EVEN parity;
6111+ 3C4B              ; STOP=0/1/2/3: 0=0 bit; 1=1 bit; 2=1.5 bits; 3=2 bits
6112+ 3C4B              ; PORT 1 acts as a char device; PORT 2 acts as a block device
6113+ 3C4B              ; DATA,PARITY, and STOP are optional: if nothing follows BPS,
6114+ 3C4B              ; they are assumed to be 8,0,1 resp.
6115+ 3C4B              PRTNUM  equ     VIDEOBUFF
6116+ 3C4B              BPS     equ     PRTNUM+$01
6117+ 3C4B              DATABT  equ     BPS+$02
6118+ 3C4B              PARBT   equ     DATABT+$01
6119+ 3C4B              STPBT   equ     PARBT+$01
6120+ 3C4B              SIOBFR  equ     STPBT+$01
6121+ 3C4B CD 70 2A     SERIAL: call    GETINT          ; get port #
6122+ 3C4E A7                   and     A               ; is it zero?
6123+ 3C4F CA 24 1E             jp      Z,FCERR         ; yes, error
6124+ 3C52 FE 03                cp      $03             ; is it 1 or 2?
6125+ 3C54 D2 74 3E             jp      NC,SCERR        ; no, error
6126+ 3C57 32 84 55             ld      (PRTNUM),A      ; store port number into a temp buffer
6127+ 3C5A CD 10 1B             call    CHKSYN          ; Make sure ',' follows
6128+ 3C5D 2C                   defb    ','
6129+ 3C5E 2B                   dec     HL
6130+ 3C5F CD 59 1D             call    GETCHR          ; check what's following
6131+ 3C62 CA 10 18             jp      Z,SNERR         ; error if nothing follows
6132+ 3C65 30 05                jr      NC,SERVAR       ; it's not a number, try a variable
6133+ 3C67 CD 29 1E             call    ATOH            ; get bps (returned into DE)
6134+ 3C6A 18 0F                jr      CHKZSER         ; jump over
6135+ 3C6C CD EA 21     SERVAR: call    GETNUM          ; get number
6136+ 3C6F CD F7 2F             call    TSTSGN          ; check value
6137+ 3C72 FA 24 1E             jp      M,FCERR         ; negative - illegal function call
6138+ 3C75 3A D3 55             ld      A,(FPEXP)       ; Get integer value to DE
6139+ 3C78 CD 9F 30             call    FPINT           ; get integer number into BCDE - drop BC 'cause isn't necessary
6140+ 3C7B 7A           CHKZSER:ld      A,D             ; bps is into DE - move MSB into A
6141+ 3C7C B3                   or      E               ; check if bps=0
6142+ 3C7D 20 3A                jr      NZ,CNTSER       ; no, continue checking
6143+ 3C7F                      ; if baud rate is 0, then close the serial comm.
6144+ 3C7F 3A 84 55     RSTSERS:ld      A,(PRTNUM)      ; yes, so reset the channel. First, load port number
6145+ 3C82 3D                   dec     A               ; subtract 1, so that serial channel is 0=>A and 1=>B
6146+ 3C83 C6 22                add     SIO_CA          ; find correct channel
6147+ 3C85 4F                   ld      C,A             ; store serial channel
6148+ 3C86 F3                   di                      ; disable INTs
6149+ 3C87 AF                   xor     A               ; reset A
6150+ 3C88 16 01                ld      D,$01           ; start from WR1
6151+ 3C8A 06 05                ld      B,$05           ; 5 registers
6152+ 3C8C ED 51        RPTRSSR:out     (C),D           ; select register
6153+ 3C8E ED 79                out     (C),A           ; reset register
6154+ 3C90 14                   inc     D               ; next register
6155+ 3C91 10 F9                djnz    RPTRSSR         ; repeat
6156+ 3C93 3E 30                ld      A,%00110000     ; write into WR0: error reset, select WR0
6157+ 3C95 ED 79                out     (C),A           ; send command to serial channel
6158+ 3C97 3E 18                ld      A,%00011000     ; write into WR0: channel reset
6159+ 3C99 ED 79                out     (C),A           ; send command to serial channel
6160+ 3C9B FB                   ei                      ; re-enable INTs
6161+ 3C9C E5                   push    HL              ; store HL
6162+ 3C9D 21 BE 55             ld      HL,SERIALS_EN   ; serials enabled status byte
6163+ 3CA0 DB 01                in      A,(PIO_DB)      ; read status LEDs
6164+ 3CA2 CB 41                bit     0,C             ; check serial port
6165+ 3CA4 20 09                jr      NZ,SRPT2        ; if bit is set, jump to port 2
6166+ 3CA6 CB B7                res     6,A             ; it's port 1
6167+ 3CA8 CB A7                res     4,A             ; remove possible error LED
6168+ 3CAA CB 86                res     0,(HL)          ; disable port 1
6169+ 3CAC C3 B5 3C             jp      SERLED          ; jump over
6170+ 3CAF CB BF        SRPT2:  res     7,A             ; it's port 2
6171+ 3CB1 CB AF                res     5,A             ; remove possible error LED
6172+ 3CB3 CB 8E                res     1,(HL)          ; disable port 2
6173+ 3CB5 D3 01        SERLED: out     (PIO_DB),A      ; send new configuration
6174+ 3CB7 E1                   pop     HL              ; retrieve HL
6175+ 3CB8 C9                   ret                     ; return to caller
6176+ 3CB9                      ; check if bps=1, meaning reactivate RX on serial
6177+ 3CB9 7A           CNTSER: ld      A,D
6178+ 3CBA B2                   or      D               ; check if bps<>1 by first checking D=0
6179+ 3CBB 20 36                jr      NZ,CNTSER2      ; if not, jump over
6180+ 3CBD 7B                   ld      A,E             ; then by checking that
6181+ 3CBE FE 01                cp      $01             ; E=1
6182+ 3CC0 20 31                jr      NZ,CNTSER2      ; if not, jump over
6183+ 3CC2 3A 84 55             ld      A,(PRTNUM)      ; load port number
6184+ 3CC5 57                   ld      D,A             ; store port on D
6185+ 3CC6 3A BE 55             ld      A,(SERIALS_EN)  ; load address of serial status cell
6186+ 3CC9 A2                   and     D               ; check status
6187+ 3CCA CA 74 3E             jp      Z,SCERR         ; port not open, raise error
6188+ 3CCD F3                   di                      ; disable INTs
6189+ 3CCE 7A                   ld      A,D             ; move port # into A
6190+ 3CCF 5F                   ld      E,A             ; and also into E
6191+ 3CD0 87                   add     A
6192+ 3CD1 87                   add     A               ; move A to left times 2
6193+ 3CD2 57                   ld      D,A             ; move value into D
6194+ 3CD3 3A BE 55             ld      A,(SERIALS_EN)  ; load serial status byte
6195+ 3CD6 B2                   or      D               ; re-enable RX
6196+ 3CD7 32 BE 55             ld      (SERIALS_EN),A  ; store new serial status
6197+ 3CDA 7B                   ld      A,E             ; recover port #
6198+ 3CDB 3D                   dec     A               ; check port
6199+ 3CDC 20 0A                jr      NZ,CNTRX2       ; port is #2
6200+ 3CDE CD E3 01             call    SIO_A_EI        ; re-enable RX on port 1
6201+ 3CE1 DB 01                in      A,(PIO_DB)      ; load status LEDs
6202+ 3CE3 CB A7                res     4,A             ; remove error LED
6203+ 3CE5 C3 EF 3C             jp      RXEND           ; terminate setting
6204+ 3CE8 CD EB 01     CNTRX2: call    SIO_B_EI        ; re-enable RX on port 2
6205+ 3CEB DB 01                in      A,(PIO_DB)      ; load status LEDs
6206+ 3CED CB AF                res     5,A             ; remove error LED
6207+ 3CEF D3 01        RXEND:  out     (PIO_DB),A      ; set new status for LEDs
6208+ 3CF1 FB                   ei                      ; re-enable INTs
6209+ 3CF2 C9                   ret                     ; return to caller
6210+ 3CF3                      ; set serial port comm.
6211+ 3CF3 D5           CNTSER2:push    DE              ; store BPS
6212+ 3CF4 3A 84 55             ld      A,(PRTNUM)      ; load port number
6213+ 3CF7 57                   ld      D,A             ; move port # into D
6214+ 3CF8 3A BE 55             ld      A,(SERIALS_EN)  ; check if serial port is already open
6215+ 3CFB A2                   and     D               ; by ANDing A with D
6216+ 3CFC D1                   pop     DE              ; retrieve BPS
6217+ 3CFD CA 05 3D             jp      Z,CNTSER3       ; not open, continue
6218+ 3D00 1E 2E                ld      E,SA            ; already open, so raise a "Serial Port Already Error"
6219+ 3D02 C3 2A 18             jp      ERROR           ; and leave
6220+ 3D05 E5           CNTSER3:push    HL              ; store HL
6221+ 3D06 21 00 E1             ld      HL,$E100        ; check bps. start with HL=57,600
6222+ 3D09 CD 35 41             call    CMP16           ; is bps<=57,600?
6223+ 3D0C E1                   pop     HL              ; but first, recover HL
6224+ 3D0D DA 74 3E             jp      C,SCERR         ; no (bps>57,600) then error
6225+ 3D10 ED 53 85 55          ld      (BPS),DE        ; store bps
6226+ 3D14 2B                   dec     HL              ; dec 'cos GETCHR INCs
6227+ 3D15 CD 59 1D             call    GETCHR          ; Get next character
6228+ 3D18 CA 50 3D             jp      Z,DEFSER        ; defaults if nothing follows
6229+ 3D1B CD 10 1B             call    CHKSYN          ; Make sure ',' follows
6230+ 3D1E 2C                   defb    ','
6231+ 3D1F CD 70 2A             call    GETINT          ; get data bits
6232+ 3D22 FE 05                cp      $05             ; is it <5?
6233+ 3D24 DA 74 3E             jp      C,SCERR         ; yes, error
6234+ 3D27 FE 09                cp      $09             ; is it >=9?
6235+ 3D29 D2 24 1E             jp      NC,FCERR        ; yes, error
6236+ 3D2C 32 87 55             ld      (DATABT),A      ; store data bits
6237+ 3D2F CD 10 1B             call    CHKSYN          ; Make sure ',' follows
6238+ 3D32 2C                   defb    ','
6239+ 3D33 CD 70 2A             call    GETINT          ; get parity bits
6240+ 3D36 BF FE 03             cp      A,$03           ; check if parity is in range 0~2
6241+ 3D39 D2 74 3E             jp      NC,SCERR        ; no, error
6242+ 3D3C 32 88 55             ld      (PARBT),A       ; store parity
6243+ 3D3F CD 10 1B             call    CHKSYN          ; Make sure ',' follows
6244+ 3D42 2C                   defb    ','
6245+ 3D43 CD 70 2A             call    GETINT          ; get stop bits
6246+ 3D46 FE 03                cp      $03             ; is it >=3?
6247+ 3D48 D2 74 3E             jp      NC,SCERR        ; yes, error
6248+ 3D4B 32 89 55             ld      (STPBT),A       ; store stop bits
6249+ 3D4E 18 0D                jr      SETSER          ; jump to set serial
6250+ 3D50 3E 08        DEFSER: ld      A,$08           ; 8 bits for data
6251+ 3D52 32 87 55             ld      (DATABT),A
6252+ 3D55 AF                   xor     A               ; no parity bit
6253+ 3D56 32 88 55             ld      (PARBT),A
6254+ 3D59 3C                   inc     A               ; 1 bit for stop
6255+ 3D5A 32 89 55             ld      (STPBT),A
6256+ 3D5D                      ; check if bps are legal
6257+ 3D5D E5           SETSER: push    HL              ; store HL
6258+ 3D5E D5                   push    DE              ; store DE
6259+ 3D5F DD E5                push    IX              ; store IX
6260+ 3D61 DD 21 4F 3E          ld      IX,SUP_BPS      ; allowed BPSs
6261+ 3D65 06 0B                ld      B,$0B           ; 11 items
6262+ 3D67 0E 00                ld      C,$00           ; reset pointer
6263+ 3D69 2A 85 55     CKBPS:  ld      HL,(BPS)        ; load BPS
6264+ 3D6C DD 5E 00             ld      E,(IX+0)        ; load LSB of item
6265+ 3D6F DD 56 01             ld      D,(IX+1)        ; load MSB of item
6266+ 3D72 CD 35 41             call    CMP16           ; is it equal?
6267+ 3D75 CA 82 3D             jp      Z,SET_PT        ; yes, found a correspondance
6268+ 3D78 DD 23                inc     IX
6269+ 3D7A DD 23                inc     IX              ; no, go to next entry
6270+ 3D7C 0C                   inc     C               ; increment pointer
6271+ 3D7D 10 EA                djnz    CKBPS           ; repeat for 10 entries
6272+ 3D7F C3 70 3E             jp      SCERR1          ; if nothing found, raise an error
6273+ 3D82              SET_PT: ;init CTC CH0: CH0 provides RX/TX clock to SIO port A
6274+ 3D82                      ; TO0 output frequency=INPUT CLK/time constant. Time constant is set to get 16 times
6275+ 3D82                      ; the requested baud rate. I.e., if bps is 19,200 then time constast is set to 6 because
6276+ 3D82                      ; 1,843,200/6 = 307,200 Hz (that is 19,200 x 16)
6277+ 3D82 F3                   di                      ; disable INTs
6278+ 3D83 06 00                ld      B,$00           ; reset B
6279+ 3D85 21 65 3E             ld      HL,CTC_CFG      ; address of first CTC divider
6280+ 3D88 09                   add     HL,BC           ; adjust for correct CTC divider
6281+ 3D89 0E 10                ld      C,CTC_CH0       ; CTC channel 0
6282+ 3D8B 3A 84 55             ld      A,(PRTNUM)      ; load port number
6283+ 3D8E 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6284+ 3D8F DA 93 3D             jp      C,SET_CTC       ; port 1 => ch. 0, so continue
6285+ 3D92 0C                   inc     C               ; port 2 => ch. 1, increment address port into C
6286+ 3D93 3E 47        SET_CTC:ld      A,%01000111     ; interrupt off, counter mode, prsc=16 (doesn't matter), ext. start,
6287+ 3D95                                              ; start upon loading time constant, time constant follows, sw reset, command word
6288+ 3D95 ED 79                out     (C),A           ; configure CTC channel
6289+ 3D97 7E                   ld      A,(HL)          ; load CTC divider
6290+ 3D98 ED 79                out     (C),A           ; send divider
6291+ 3D9A                      ; configure SIO
6292+ 3D9A 21 36 03             ld      HL,SIO_A_SETS   ; load default settings for SIO
6293+ 3D9D 11 8A 55             ld      DE,SIOBFR       ; into a temp buffer
6294+ 3DA0 01 0A 00             ld      BC,$000A        ; 10 items to copy
6295+ 3DA3 ED B0                ldir                    ; copy SIO settings into TEMP buffer
6296+ 3DA5 3A 8F 55             ld      A,(SIOBFR+5)    ; load WR5 setting
6297+ 3DA8 47                   ld      B,A             ; move it into B
6298+ 3DA9 3A 87 55             ld      A,(DATABT)      ; load DATA bits
6299+ 3DAC FE 05                cp      $05             ; is it 5 bits?
6300+ 3DAE 20 06                jr      NZ,BITS6        ; no, jump over
6301+ 3DB0 CB B0                res     6,B
6302+ 3DB2 CB A8                res     5,B             ; set D6 & D5 to 0
6303+ 3DB4 18 19                jr      SETPAR          ; jump to set parity
6304+ 3DB6 FE 06        BITS6:  cp      $06             ; is it 6 bits?
6305+ 3DB8 20 06                jr      NZ,BITS7        ; no, jump over
6306+ 3DBA CB F0                set     6,B
6307+ 3DBC CB A8                res     5,B             ; set D6 & D5 to 1,0
6308+ 3DBE 18 0F                jr      SETPAR          ; jump to set parity
6309+ 3DC0 FE 07        BITS7:  cp      $07             ; is it 7 bits?
6310+ 3DC2 20 07                jr      NZ,BITS8        ; no, jump over
6311+ 3DC4 CB B0                res     6,B
6312+ 3DC6 CB E8                set     5,B             ; set D6 & D5 to 0,1
6313+ 3DC8 C3 CF 3D             jp      SETPAR          ; jump to set parity
6314+ 3DCB CB F0        BITS8:  set     6,B
6315+ 3DCD CB E8                set     5,B             ; set D6 & D5 to 1,1
6316+ 3DCF 21 BF 55     SETPAR: ld      HL,SERABITS     ; load address for storing data bits
6317+ 3DD2 3A 84 55             ld      A,(PRTNUM)      ; check serial port number
6318+ 3DD5 3D                   dec     A               ; is it port #1?
6319+ 3DD6 CA DA 3D             jp      Z,SETPAR2       ; yes, jump over
6320+ 3DD9 23                   inc     HL              ; port #2, use SERBBITS instead
6321+ 3DDA 78           SETPAR2:ld      A,B             ; retrieve DATA bits
6322+ 3DDB 32 8F 55             ld      (SIOBFR+5),A    ; save DATA bits
6323+ 3DDE E6 60                and     %01100000       ; filter only D5&D6 bits
6324+ 3DE0 87                   add     A,A             ; shift left times 1
6325+ 3DE1 77                   ld      (HL),A          ; store for SIO_EI & SIO_DI functions
6326+ 3DE2 3A 89 55             ld      A,(STPBT)       ; load STOP bits
6327+ 3DE5 87                   add     A,A
6328+ 3DE6 87                   add     A,A             ; 2 left shifts
6329+ 3DE7 47                   ld      B,A             ; move forming byte into B
6330+ 3DE8 3A 88 55             ld      A,(PARBT)       ; load PARITY setting
6331+ 3DEB A7                   and     A               ; is it 0?
6332+ 3DEC CA F7 3D             jp      Z,STRPAR        ; yes, jump over
6333+ 3DEF CB C0                set     0,B             ; set PARITY on
6334+ 3DF1 3D                   dec     A               ; is parity ODD?
6335+ 3DF2 CA F7 3D             jp      Z,STRPAR        ; yes, so jump over
6336+ 3DF5 CB C8                set     1,B             ; no, it's EVEN so set the corresponding bit
6337+ 3DF7 3A 8D 55     STRPAR: ld      A,(SIOBFR+3)    ; load WR4 setting
6338+ 3DFA E6 F0                and     %11110000       ; reset STOP & PARITY bits
6339+ 3DFC B0                   or      B               ; set new STOP & PARITY bits
6340+ 3DFD 32 8D 55             ld      (SIOBFR+3),A    ; store new value
6341+ 3E00                      ;set up TX and RX:
6342+ 3E00                      ; the followings are settings for channel A
6343+ 3E00 21 8A 55             ld      HL,SIOBFR       ; settings for SIO ch. A
6344+ 3E03 06 06                ld      B,$06           ; 6 bytes to send
6345+ 3E05 0E 22                ld      C,SIO_CA        ; I/O address of SIO ch.A
6346+ 3E07 3A 84 55             ld      A,(PRTNUM)      ; load port number
6347+ 3E0A 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6348+ 3E0B DA 0F 3E             jp      C,SRLCNT        ; port 1, continue
6349+ 3E0E 0C                   inc     C               ; port 2, increment address port into C
6350+ 3E0F ED B3        SRLCNT: otir                    ; send bytes to SIO
6351+ 3E11                      ; the following are settings for channel B (don't need to load HL since settings are contigous)
6352+ 3E11 06 04                ld      B,$04           ; other 4 bytes to send
6353+ 3E13 51                   ld      D,C             ; store port address into D
6354+ 3E14 0E 23                ld      C,SIO_CB        ; I/O address of SIO ch.B
6355+ 3E16 ED B3                otir                    ; send bytes to SIO
6356+ 3E18                      ; the following are settings for selected channel
6357+ 3E18 3E 01                ld      A,$01           ; write into WR0: select WR1
6358+ 3E1A 4A                   ld      C,D             ; retrieve port address
6359+ 3E1B ED 79                out     (C),A
6360+ 3E1D 3E 18                ld      A,%00011000     ; interrupts on every RX char; parity is no special condition;
6361+ 3E1F                                              ; buffer overrun is special condition
6362+ 3E1F ED 79                out     (C),A
6363+ 3E21 21 BE 55             ld      HL,SERIALS_EN
6364+ 3E24 3A 84 55             ld      A,(PRTNUM)      ; retrieve serial channel
6365+ 3E27 3D                   dec     A               ; channel A?
6366+ 3E28 20 10                jr      NZ,ENCHB        ; no, jump over
6367+ 3E2A CD E3 01             call    SIO_A_EI        ; enable RX on SIO channel A
6368+ 3E2D CB C6                set     0,(HL)          ; set serial port 1 status ON
6369+ 3E2F CB D6                set     2,(HL)          ; set serial port 1 RX ON
6370+ 3E31                      ; back to normal running
6371+ 3E31 FB                   ei                      ; re-enable INTs
6372+ 3E32 DB 01                in      A,(PIO_DB)      ; load status LEDs
6373+ 3E34 CB F7                set     6,A             ; set status LED on
6374+ 3E36 CB A7                res     4,A             ; set error LED off
6375+ 3E38 18 0E                jr      EXNRM           ; leave
6376+ 3E3A CD EB 01     ENCHB:  call    SIO_B_EI        ; enable RX on SIO channel B
6377+ 3E3D CB CE                set     1,(HL)          ; set serial port 2 status ON
6378+ 3E3F CB DE                set     3,(HL)          ; set serial port 2 RX ON
6379+ 3E41                      ; back to normal running
6380+ 3E41 FB                   ei                      ; re-enable INTs
6381+ 3E42 DB 01                in      A,(PIO_DB)      ; load status LEDs
6382+ 3E44 CB FF                set     7,A             ; set status LED on
6383+ 3E46 CB AF                res     5,A             ; set error LED off
6384+ 3E48 D3 01        EXNRM:  out     (PIO_DB),A      ; send new configuration
6385+ 3E4A DD E1                pop     IX              ; retrieve IX
6386+ 3E4C D1                   pop     DE              ; retrieve DE
6387+ 3E4D E1                   pop     HL              ; retrieve HL
6388+ 3E4E C9                   ret                     ; return to caller
6389+ 3E4F
6390+ 3E4F              ; allowed bps (Bauds per second)
6391+ 3E4F 00 E1 00 96  SUP_BPS:defw    57600,38400,28800,19200,14400,9600,4800,3600,2400,1200,600
6391+ 3E53 80 70 00 4B
6391+ 3E57 40 38 80 25
6391+ 3E5B C0 12 10 0E
6391+ 3E5F 60 09 B0 04
6391+ 3E63 58 02
6392+ 3E65              ; corresponding CTC divider
6393+ 3E65 02 03 04 06  CTC_CFG:defb    2,3,4,6,8,12,24,32,48,96,192
6393+ 3E69 08 0C 18 20
6393+ 3E6D 30 60 C0
6394+ 3E70
6395+ 3E70
6396+ 3E70              ; serial configuration error
6397+ 3E70 DD E1        SCERR1: pop     IX              ; retrieve IX
6398+ 3E72 D1                   pop     DE              ; retrieve DE
6399+ 3E73 E1                   pop     HL              ; retrieve HL
6400+ 3E74 1E 2C        SCERR:  ld      E,SC            ; Serial Configuration Error
6401+ 3E76 C3 2A 18             jp      ERROR           ; print error
6402+ 3E79
6403+ 3E79
6404+ 3E79              ; serial buffer overrun
6405+ 3E79 CD 26 20     SOERR:  call    PRNTCRLF
6406+ 3E7C 1E 30                ld      E,SO            ; Serial Buffer Overrun
6407+ 3E7E C3 2A 18             jp      ERROR
6408+ 3E81
6409+ 3E81
6410+ 3E81              ; check for direct mode:
6411+ 3E81              ; Z is set if in direct mode, reset otherwise
6412+ 3E81 E5           DIRMOD: push    HL              ; Save code string address
6413+ 3E82 2A 29 54             ld      HL,(LINEAT)     ; Get current line number
6414+ 3E85 23                   inc     HL              ; -1 means direct statement
6415+ 3E86 7C                   ld      A,H
6416+ 3E87 B5                   or      L
6417+ 3E88 E1                   pop     HL              ; Restore code string address
6418+ 3E89 C9                   ret
6419+ 3E8A
6420+ 3E8A
6421+ 3E8A              ; HELP lists the line program where an error occured
6422+ 3E8A CD 81 3E     HELP:   call    DIRMOD          ; check if in direct mode
6423+ 3E8D C2 A3 3E             jp      NZ,HLPERR       ; raise error if in indirect mode
6424+ 3E90 E5                   push    HL              ; store HL
6425+ 3E91 2A 2B 54             ld      HL,(HLPLN)      ; load HELP line
6426+ 3E94 23                   inc     HL              ; increment HL
6427+ 3E95 7C                   ld      A,H
6428+ 3E96 B5                   or      L               ; check if there is a line into the HELP reg.
6429+ 3E97 E1                   pop     HL
6430+ 3E98 CA A3 3E             jp      Z,HLPERR        ; no line found, raise error
6431+ 3E9B ED 5B 2B 54          ld      DE,(HLPLN)      ; recover line
6432+ 3E9F C1                   pop     BC              ; remove BC from stack since it's not needed anymore for LIST
6433+ 3EA0 C3 A6 1B             jp      LST01H          ; jump to list line
6434+ 3EA3 1E 32        HLPERR: ld      E,HP            ; HELP call error
6435+ 3EA5 C3 2A 18             jp      ERROR           ; raise error
6436+ 3EA8
6437+ 3EA8
6438+ 3EA8              ; KEY command to list/modify function keys and auto-repeat
6439+ 3EA8 2B           KEY:    dec     HL              ; dec 'cos GETCHR INCs
6440+ 3EA9 CD 59 1D             call    GETCHR          ; Get next character
6441+ 3EAC CA 2C 3F             jp      Z,LSTKEYS       ; jump if nothing follows
6442+ 3EAF                      ; change FN keys
6443+ 3EAF CD 70 2A             call    GETINT          ; get a number
6444+ 3EB2 A7                   and     A               ; is it 0?
6445+ 3EB3 20 10                jr      NZ,KEYCH        ; no, jump over
6446+ 3EB5 E5           RESFN:  push    HL              ; yes - reset FN keys to defaults
6447+ 3EB6 D5                   push    DE              ; store HL & DE
6448+ 3EB7 21 FE 16             ld      HL,AUTORP       ; pointer to default auto-repeat delays and FN keys texts
6449+ 3EBA 11 2D 54             ld      DE,KEYDEL       ; pointer to destination
6450+ 3EBD 01 82 00             ld      BC,$0082        ; 130 chars to be copied (2xauto-delay, 128xFN keys)
6451+ 3EC0 ED B0                ldir                    ; restore default texts
6452+ 3EC2 D1                   pop     DE              ; retrieve DE
6453+ 3EC3 E1                   pop     HL              ; retrieve HL
6454+ 3EC4 C9                   ret                     ; return to caller
6455+ 3EC5 FE 09        KEYCH:  cp      $09             ; is it >= 9?
6456+ 3EC7 D2 DF 3F             jp      NC,SETREP       ; yes - jump over
6457+ 3ECA 3D                   dec     A               ; FN key in range 0~7
6458+ 3ECB 87                   add     A,A             ; multiply A...
6459+ 3ECC 87                   add     A,A             ; ... times 4...
6460+ 3ECD 87                   add     A,A             ; ... to get the correct...
6461+ 3ECE 87                   add     A,A             ; ... offset fo FN key text
6462+ 3ECF 32 7C 55             ld      (TMPBFR1),A     ; store FN key offset...
6463+ 3ED2 AF                   xor     A               ; ...in a...
6464+ 3ED3 32 7D 55             ld      (TMPBFR1+1),A   ; ...16-bit register
6465+ 3ED6 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
6466+ 3ED9 2C                   defb    ','
6467+ 3EDA 44 4D                ld      BC,HL           ; copy address into BC
6468+ 3EDC CD FC 21             call    EVAL            ; Evaluate expression (in E there is the length)
6469+ 3EDF E5                   push    HL              ; store string pointer
6470+ 3EE0 3A 0E 55             ld      A,(TYPE)        ; Get variable type
6471+ 3EE3 B7                   or      A               ; Is it a string variable?
6472+ 3EE4 CA 10 18             jp      Z,SNERR         ; no - syntax error
6473+ 3EE7 CD 35 28             call    GSTRCU          ; Current string to pool
6474+ 3EEA CD 46 30             call    LOADFP          ; Move string block data to (BC=pointer, DE=length)
6475+ 3EED 7B                   ld      A,E             ; copy length into A
6476+ 3EEE FE 11                cp      $11             ; is length > 16?
6477+ 3EF0 DA F5 3E             jp      C,DECLN1        ; no, jump over
6478+ 3EF3 1E 10                ld      E,$10           ; yes, so set length to 16
6479+ 3EF5 3E 10        DECLN1: ld      A,$10           ; calculate how many...
6480+ 3EF7 93                   sub     E               ; ...null chars needed to fill up...
6481+ 3EF8 57                   ld      D,A             ; ...the FN key text
6482+ 3EF9 C5                   push    BC              ; store address of string
6483+ 3EFA ED 4B 7C 55          ld      BC,(TMPBFR1)    ; load FN key offset
6484+ 3EFE 21 2F 54             ld      HL,FNKEYS       ; load address of FN keys texts
6485+ 3F01 09                   add     HL,BC           ; get corrected address
6486+ 3F02 C1                   pop     BC              ; retrieve address of string chars
6487+ 3F03 0A           CPKEY:  ld      A,(BC)          ; load char from string
6488+ 3F04 FE 0D                cp      CR              ; return?
6489+ 3F06 CA 13 3F             jp      Z,CPKEY2        ; yes, store char
6490+ 3F09 FE 7B                cp      $7B             ; if char > "z" ?
6491+ 3F0B D2 10 18             jp      NC,SNERR        ; yes - syntax error
6492+ 3F0E FE 20                cp      $20             ; is char < space?
6493+ 3F10 DA 10 18             jp      C,SNERR         ; yes - syntax error
6494+ 3F13 FE 61        CPKEY2: cp      $61             ; is it >= 'a'?
6495+ 3F15 DA 1A 3F             jp      C,CPKEY3        ; no, continue
6496+ 3F18 E6 5F                and     %01011111       ; set letters to uppercase
6497+ 3F1A 77           CPKEY3: ld      (HL),A          ; store char
6498+ 3F1B 23                   inc     HL              ; next string char
6499+ 3F1C 03                   inc     BC              ; next free cell
6500+ 3F1D 1D                   dec     E               ; decrement E
6501+ 3F1E 20 E3                jr      NZ,CPKEY        ; repeat until 0
6502+ 3F20 AF                   xor     A               ; null char
6503+ 3F21 14                   inc     D               ; +1 to decrement below
6504+ 3F22 15           CPKEY1: dec     D               ; how many null chars to insert?
6505+ 3F23 CA 2A 3F             jp      Z,CPKYEND       ; no more nulls, so exit
6506+ 3F26 77                   ld      (HL),A          ; store it
6507+ 3F27 23                   inc     HL              ; next cell
6508+ 3F28 18 F8                jr      CPKEY1          ; repeat
6509+ 3F2A E1           CPKYEND:pop     HL              ; retrieve pointer to string
6510+ 3F2B C9                   ret                     ; return to caller
6511+ 3F2C                                              ; list FN keys
6512+ 3F2C E5           LSTKEYS:push    HL              ; Save code string address
6513+ 3F2D 2A 29 54             ld      HL,(LINEAT)     ; Get current line number
6514+ 3F30 23                   inc     HL              ; -1 means direct statement
6515+ 3F31 7C                   ld      A,H
6516+ 3F32 B5                   or      L
6517+ 3F33 E1                   pop     HL              ; Restore code string address
6518+ 3F34 C2 10 18             jp      NZ,SNERR        ; raise error if in indirect mode
6519+ 3F37 E5                   push    HL              ; store HL
6520+ 3F38 D5                   push    DE              ; store DE
6521+ 3F39 21 2F 54             ld      HL,FNKEYS       ; load starting address of FN keys text
6522+ 3F3C 0E 01                ld      C,$01           ; 8 function keys
6523+ 3F3E 06 10        PRTK4:  ld      B,$10           ; 16 chars each
6524+ 3F40 11 01 40             ld      DE,CHKEY1       ; message "KEY "
6525+ 3F43 CD D0 3F             call    PRTCKEY         ; print it
6526+ 3F46 79                   ld      A,C             ; load FN key
6527+ 3F47 C6 30                add     $30             ; get number in ASCI code
6528+ 3F49 CD 1B 1B             call    OUTC            ; print it
6529+ 3F4C 11 06 40             ld      DE,CHKEY2       ; message ": ""
6530+ 3F4F CD D0 3F             call    PRTCKEY         ; print it
6531+ 3F52 3E 01                ld      A,$01           ; " opened
6532+ 3F54 32 7C 55             ld      (TMPBFR1),A
6533+ 3F57 7E           LDKEY:  ld      A,(HL)          ; retrieve char
6534+ 3F58 A7                   and     A               ; is it zero?
6535+ 3F59 CA 6C 3F             jp      Z,CNTLTK        ; yes, go next char
6536+ 3F5C CD B8 3F             call    OPNQT           ; check if quotes are opened
6537+ 3F5F FE 22                cp      $22             ; check if char is "?
6538+ 3F61 CA 81 3F             jp      Z,PRTCHR        ; yes, print "chr$("
6539+ 3F64 FE 0D                cp      CR              ; is it a CR?
6540+ 3F66 CA 81 3F             jp      Z,PRTCHR        ; yes, print "chr$("
6541+ 3F69 CD 1B 1B     PRTK3:  call    OUTC            ; no, just print it
6542+ 3F6C 23           CNTLTK: inc     HL              ; next char
6543+ 3F6D 10 E8                djnz    LDKEY           ; continue until finished
6544+ 3F6F CD A6 3F             call    CLSQT           ; check if quotes are still open
6545+ 3F72 3E 0D                ld      A,CR            ; go next line
6546+ 3F74 CD 1B 1B             call    OUTC            ; print it
6547+ 3F77 0C                   inc     C               ; next FN key
6548+ 3F78 79                   ld      A,C             ; check if...
6549+ 3F79 FE 09                cp      $09             ; finished keys?
6550+ 3F7B DA 3E 3F             jp      C,PRTK4         ; no, repeat 1 more time
6551+ 3F7E D1                   pop     DE              ; retrieve DE
6552+ 3F7F E1                   pop     HL              ; retrieve HL
6553+ 3F80 C9                   ret                     ; return to caller
6554+ 3F81 E5           PRTCHR: push    HL              ; store HL
6555+ 3F82 CD A6 3F             call    CLSQT           ; check if quotes are closed
6556+ 3F85 3E 2B                ld      A,'+'           ; '+' char
6557+ 3F87 CD 1B 1B             call    OUTC            ; print it
6558+ 3F8A 11 09 40             ld      DE,CHKEY3       ; address of "CHR$("
6559+ 3F8D CD D0 3F             call    PRTCKEY         ; print it
6560+ 3F90 E1                   pop     HL              ; recover HL
6561+ 3F91 23                   inc     HL              ; next char
6562+ 3F92 05                   dec     B               ; increment char counter
6563+ 3F93 11 0F 40             ld      DE,CHKEY4       ; load address of RETURN
6564+ 3F96 7E                   ld      A,(HL)          ; load char
6565+ 3F97 FE 0D                cp      CR              ; is it a RETURN?
6566+ 3F99 20 03                jr      NZ,PTCHR1       ; no, jump over
6567+ 3F9B 11 12 40             ld      DE,CHKEY5       ; yes, load address of "
6568+ 3F9E CD D0 3F     PTCHR1: call    PRTCKEY         ; print it
6569+ 3FA1 3E 29                ld      A,')'           ; char )
6570+ 3FA3 C3 69 3F             jp      PRTK3           ; continue
6571+ 3FA6 F5           CLSQT:  push    AF              ; store A
6572+ 3FA7 3A 7C 55             ld      A,(TMPBFR1)     ; quote status
6573+ 3FAA A7                   and     A               ; are they closed?
6574+ 3FAB 28 09                jr      Z,CLSQT1        ; if yes, return
6575+ 3FAD 3E 22                ld      A,$22           ; no, so close them
6576+ 3FAF CD 1B 1B             call    OUTC            ; print "
6577+ 3FB2 AF                   xor     A               ; set quotes
6578+ 3FB3 32 7C 55             ld      (TMPBFR1),A     ; as closed
6579+ 3FB6 F1           CLSQT1: pop     AF              ; retrieve A
6580+ 3FB7 C9                   ret                     ; return to caller
6581+ 3FB8 F5           OPNQT:  push    AF              ; store A
6582+ 3FB9 3A 7C 55             ld      A,(TMPBFR1)     ; quote status
6583+ 3FBC A7                   and     A               ; are they open?
6584+ 3FBD 20 0F                jr      NZ,OPNQT1       ; if yes, return
6585+ 3FBF 3E 2B                ld      A,'+'           ; no, so add '+
6586+ 3FC1 CD 1B 1B             call    OUTC            ; print it
6587+ 3FC4 3E 22                ld      A,$22           ; and then open quotes
6588+ 3FC6 CD 1B 1B             call    OUTC            ; print them
6589+ 3FC9 3E 01                ld      A,$01           ; set quotes
6590+ 3FCB 32 7C 55             ld      (TMPBFR1),A     ; as opened
6591+ 3FCE F1           OPNQT1: pop     AF              ; retrieve A
6592+ 3FCF C9                   ret                     ; return to caller
6593+ 3FD0 F5           PRTCKEY:push    AF              ; store original char
6594+ 3FD1 1A           PRTK1:  ld      A,(DE)          ; load char
6595+ 3FD2 A7                   and     A               ; is it 0?
6596+ 3FD3 CA DD 3F             jp      Z,PRTEND        ; yes, finished printing
6597+ 3FD6 CD 1B 1B             call    OUTC            ; no, print char
6598+ 3FD9 13                   inc     DE              ; next char
6599+ 3FDA C3 D1 3F             jp      PRTK1           ; repeat
6600+ 3FDD F1           PRTEND: pop     AF              ; retrieve AF
6601+ 3FDE C9                   ret                     ; return to caller
6602+ 3FDF FE 09        SETREP: cp      $09             ; is it special key 9? (stands for auto-repeat)
6603+ 3FE1 C2 10 18             jp      NZ,SNERR        ; no, raise an error
6604+ 3FE4 CD 10 1B             call    CHKSYN          ; Check for comma
6605+ 3FE7 2C                   defb    ','
6606+ 3FE8 CD 70 2A             call    GETINT          ; get a number
6607+ 3FEB 32 7C 55             ld      (TMPBFR1),A     ; store it
6608+ 3FEE CD 10 1B             call    CHKSYN          ; Check for comma
6609+ 3FF1 2C                   defb    ','
6610+ 3FF2 CD 70 2A             call    GETINT          ; get another number
6611+ 3FF5 E5                   push    HL              ; store HL
6612+ 3FF6 21 2E 54             ld      HL,AUTOKE       ; address of second cell for key auto-repeat
6613+ 3FF9 77                   ld      (HL),A          ; store auto-repeat delay
6614+ 3FFA 2B                   dec     HL              ; previous cell
6615+ 3FFB 3A 7C 55             ld      A,(TMPBFR1)     ; retrieve value
6616+ 3FFE 77                   ld      (HL),A          ; store delay for auto-repeat
6617+ 3FFF E1                   pop     HL              ; retrieve HL
6618+ 4000 C9                   ret
6619+ 4001 4B 45 59 20  CHKEY1: defb    "KEY ",0
6619+ 4005 00
6620+ 4006 3A 22 00     CHKEY2: defb    ":",34,0
6621+ 4009 63 68 72 24  CHKEY3: defb    "chr$(",0
6621+ 400D 28 00
6622+ 400F 31 33 00     CHKEY4: defb    "13",0
6623+ 4012 33 34 00     CHKEY5: defb    "34",0
6624+ 4015
6625+ 4015
6626+ 4015              ; HEX$(nn) Convert 16 bit number to Hexadecimal string
6627+ 4015 CD ED 21     HEX: 	call	TSTNUM          ; Verify it's a number
6628+ 4018 CD 0F 1E             call	DEINT           ; Get integer -32768 to 32767
6629+ 401B C5                   push	BC              ; Save contents of BC
6630+ 401C 21 D5 55             ld      HL,PBUFF        ; load address of PBUFF into HL
6631+ 401F 7A                   ld      A,D             ; Get MSB into A
6632+ 4020 B7                   or      A               ; OR with LSB to see if param=0
6633+ 4021 28 0C                jr      Z,HEX2          ; Skip output if both high digits are zero
6634+ 4023 CD 4B 40             call    BYT2ASC         ; Convert D to ASCII
6635+ 4026 78                   ld      A,B             ; cechk if B
6636+ 4027 FE 30                cp      '0'             ; is 0
6637+ 4029 28 02                jr      Z,HEX1          ; Don't store high digit if zero
6638+ 402B 70                   ld      (HL),B          ; Store it to PBUFF
6639+ 402C 23                   inc     HL              ; Next location
6640+ 402D 71           HEX1:   ld      (HL),C          ; Store C to PBUFF+1
6641+ 402E 23                   inc     HL              ; Next location
6642+ 402F 7B           HEX2:   ld      A,E             ; Get lower byte
6643+ 4030 CD 4B 40             call    BYT2ASC         ; Convert E to ASCII
6644+ 4033 7A                   ld      A,D
6645+ 4034 B7                   or      A
6646+ 4035 20 05                jr      NZ,HEX3         ; If upper byte was not zero then always print lower byte
6647+ 4037 78                   ld      A,B
6648+ 4038 FE 30                cp      '0'             ; If high digit of lower byte is zero then don't print
6649+ 403A 28 02                jr      Z,HEX4
6650+ 403C 70           HEX3:   ld      (HL),B          ; to PBUFF+2
6651+ 403D 23                   inc     HL              ; Next location
6652+ 403E 71           HEX4:   ld      (HL),C          ; to PBUFF+3
6653+ 403F 23                   inc     HL              ; PBUFF+4 to zero
6654+ 4040 AF                   xor     A               ; Terminating character
6655+ 4041 77                   ld      (HL),A          ; Store zero to terminate
6656+ 4042 23                   inc     HL              ; Make sure PBUFF is terminated
6657+ 4043 77                   ld      (HL),A          ; Store the double zero there
6658+ 4044 C1                   pop     BC              ; Get BC back
6659+ 4045 21 D5 55             ld      HL,PBUFF        ; Reset to start of PBUFF
6660+ 4048 C3 82 26             jp      STR1            ; Convert the PBUFF to a string and return it
6661+ 404B 47           BYT2ASC:ld      B,A             ; Save original value
6662+ 404C E6 0F                and     $0F             ; Strip off upper nybble
6663+ 404E FE 0A                cp      $0A             ; 0-9?
6664+ 4050 38 02                jr      C,ADD30         ; If A-F, add 7 more
6665+ 4052 C6 07                add     A,$07           ; Bring value up to ASCII A-F
6666+ 4054 C6 30        ADD30:  add     A,$30           ; And make ASCII
6667+ 4056 4F                   ld      C,A             ; Save converted char to C
6668+ 4057 78                   ld      A,B             ; Retrieve original value
6669+ 4058 0F                   rrca                    ; and Rotate it right
6670+ 4059 0F                   rrca
6671+ 405A 0F                   rrca
6672+ 405B 0F                   rrca
6673+ 405C E6 0F                and     $0F             ; Mask off upper nybble
6674+ 405E FE 0A                cp      $0A             ; 0-9? < A hex?
6675+ 4060 38 02                jr      C,ADD301        ; Skip Add 7
6676+ 4062 C6 07                add     A,$07           ; Bring it up to ASCII A-F
6677+ 4064 C6 30        ADD301: add     A,$30           ; And make it full ASCII
6678+ 4066 47                   ld      B,A             ; Store high order byte
6679+ 4067 C9                   ret
6680+ 4068
6681+ 4068              ; Convert "&Hnnnn" to FPREG
6682+ 4068              ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
6683+ 4068              ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
6684+ 4068 EB           HEXTFP: ex      DE,HL           ; Move code string pointer to DE
6685+ 4069 21 00 00             ld      HL,$0000        ; Zero out the value
6686+ 406C CD 81 40             call    GETHEX          ; Check the number for valid hex
6687+ 406F DA A1 40             jp      C,HXERR         ; First value wasn't hex, HEX error
6688+ 4072 18 05                jr      HEXLP1          ; Convert first character
6689+ 4074 CD 81 40     HEXLP:  call    GETHEX          ; Get second and addtional characters
6690+ 4077 38 1F                jr      C,HEXIT         ; Exit if not a hex character
6691+ 4079 29           HEXLP1: add     HL,HL           ; Rotate 4 bits to the left
6692+ 407A 29                   add     HL,HL
6693+ 407B 29                   add     HL,HL
6694+ 407C 29                   add     HL,HL
6695+ 407D B5                   or      L               ; Add in D0-D3 into L
6696+ 407E 6F                   ld      L,A             ; Save new value
6697+ 407F 18 F3                jr      HEXLP           ; And continue until all hex characters are in
6698+ 4081
6699+ 4081 13           GETHEX: inc     DE              ; Next location
6700+ 4082 1A                   ld      A,(DE)          ; Load character at pointer
6701+ 4083 FE 20                cp      SPC
6702+ 4085 CA 81 40             jp      Z,GETHEX        ; Skip spaces
6703+ 4088 D6 30                sub     $30             ; Get absolute value
6704+ 408A D8                   ret     C               ; < "0", error
6705+ 408B FE 0A                cp      $0A
6706+ 408D 38 05                jr      C,NOSUB7        ; Is already in the range 0-9
6707+ 408F D6 07                sub     $07             ; Reduce to A-F
6708+ 4091 FE 0A                cp      $0A             ; Value should be $0A-$0F at this point
6709+ 4093 D8                   ret     C               ; CY set if was :            ; < = > ? @
6710+ 4094 FE 10        NOSUB7: cp      $10             ; > Greater than "F"?
6711+ 4096 3F                   ccf
6712+ 4097 C9                   ret                     ; CY set if it wasn't valid hex
6713+ 4098
6714+ 4098 EB           HEXIT:  ex      DE,HL           ; Value into DE, Code string into HL
6715+ 4099 7A                   ld      A,D             ; Load DE into AC
6716+ 409A 4B                   ld      C,E             ; For prep to
6717+ 409B E5                   push    HL
6718+ 409C CD D3 25             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6719+ 409F E1                   pop     HL
6720+ 40A0 C9                   ret
6721+ 40A1
6722+ 40A1 1E 26        HXERR:  ld      E,HE            ; ?HEX Error
6723+ 40A3 C3 2A 18             jp      ERROR
6724+ 40A6
6725+ 40A6              ; BIN$(NN) Convert integer to a 1-16 char binary string
6726+ 40A6 CD ED 21     BIN:    call    TSTNUM          ; Verify it's a number
6727+ 40A9 CD 0F 1E             call    DEINT           ; Get integer -32768 to 32767
6728+ 40AC C5                   push    BC              ; Save contents of BC
6729+ 40AD 21 D5 55             ld      HL,PBUFF
6730+ 40B0 06 11                ld      B,$11           ; One higher than max char count (16+1)
6731+ 40B2                      ; Suppress leading zeros
6732+ 40B2 05           ZEROSUP:dec     B               ; Max 16 chars
6733+ 40B3 78                   ld      A,B
6734+ 40B4 FE 01                cp      $01
6735+ 40B6 28 08                jr      Z,BITOUT        ; Always output at least one character
6736+ 40B8 CB 13                rl      E
6737+ 40BA CB 12                rl      D
6738+ 40BC 30 F4                jr      NC,ZEROSUP
6739+ 40BE 18 04                jr      BITOUT2
6740+ 40C0 CB 13        BITOUT: rl      E
6741+ 40C2 CB 12                rl      D               ; Top bit now in carry
6742+ 40C4 3E 30        BITOUT2:ld      A,'0'           ; Char for '0'
6743+ 40C6 CE 00                adc     A,$00           ; If carry set then '0' --> '1'
6744+ 40C8 77                   ld      (HL),A
6745+ 40C9 23                   inc     HL
6746+ 40CA 05                   dec     B
6747+ 40CB 20 F3                jr      NZ,BITOUT
6748+ 40CD AF                   xor     A               ; Terminating character
6749+ 40CE 77                   ld      (HL),A          ; Store zero to terminate
6750+ 40CF 23                   inc     HL              ; Make sure PBUFF is terminated
6751+ 40D0 77                   ld      (HL),A          ; Store the double zero there
6752+ 40D1 C1                   pop     BC
6753+ 40D2 21 D5 55             ld      HL,PBUFF
6754+ 40D5 C3 82 26             jp      STR1
6755+ 40D8
6756+ 40D8              ; Convert "&Bnnnn" to FPREG
6757+ 40D8              ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
6758+ 40D8 EB           BINTFP: ex      DE,HL           ; Move code string pointer to DE
6759+ 40D9 21 00 00             ld      HL,$0000        ; Zero out the value
6760+ 40DC CD F5 40             call    CHKBIN          ; Check the number for valid bin
6761+ 40DF DA 03 41             jp      C,BINERR        ; First value wasn't bin, BIN error
6762+ 40E2 D6 30        BINIT:  sub     '0'
6763+ 40E4 29                   add     HL,HL           ; Rotate HL left
6764+ 40E5 B5                   or      L
6765+ 40E6 6F                   ld      L,A
6766+ 40E7 CD F5 40             call    CHKBIN          ; Get second and addtional characters
6767+ 40EA 30 F6                jr      NC,BINIT        ; Process if a bin character
6768+ 40EC EB                   ex      DE,HL           ; Value into DE, Code string into HL
6769+ 40ED 7A                   ld      A,D             ; Load DE into AC
6770+ 40EE 4B                   ld      C,E             ; For prep to
6771+ 40EF E5                   push    HL
6772+ 40F0 CD D3 25             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6773+ 40F3 E1                   pop     HL
6774+ 40F4 C9                   ret
6775+ 40F5
6776+ 40F5              ; Char is in A, NC if char is 0 or 1
6777+ 40F5 13           CHKBIN: inc     DE
6778+ 40F6 1A                   ld      A,(DE)
6779+ 40F7 FE 20                cp      SPC
6780+ 40F9 CA F5 40             jp      Z,CHKBIN        ; Skip spaces
6781+ 40FC FE 30                cp      '0'             ; Set C if < '0'
6782+ 40FE D8                   ret     C
6783+ 40FF FE 32                cp      '2'
6784+ 4101 3F                   ccf                     ; Set C if > '1'
6785+ 4102 C9                   ret
6786+ 4103
6787+ 4103 1E 28        BINERR: ld      E,BN            ; ?BIN Error
6788+ 4105 C3 2A 18             jp      ERROR
6789+ 4108
6790+ 4108
6791+ 4108 C3 08 00     MONOUT: jp      $0008           ; output a char
6792+ 410B
6793+ 410B
6794+ 410B CD 8B 2A     RESET:  call    DISNMI          ; disable NMI vector
6795+ 410E 3A BE 55             ld      A,(SERIALS_EN)  ; load status of serial lines
6796+ 4111 E6 11                and     $11             ; are serial ports open?
6797+ 4113 C4 7F 3C             call    NZ,RSTSERS      ; yes, reset serials
6798+ 4116 3A C1 55             ld      A,(DOS_EN)      ; check DOS status
6799+ 4119 A7                   and     A               ; DOS enabled?
6800+ 411A 28 07                jr      Z,RESETE        ; no, jump over
6801+ 411C CD 43 FD             call    CF_STANDBY      ; yes, put CF into standby mode
6802+ 411F AF                   xor     A
6803+ 4120 32 D6 FF             ld      (SEQFL),A       ; close any seq. file opened
6804+ 4123 F3           RESETE: di                      ; disable INTs
6805+ 4124 C3 40 53             jp      ROM2RAM         ; Restart
6806+ 4127
6807+ 4127
6808+ 4127 3E 00        INITST: ld      A,$00           ; Clear break flag
6809+ 4129 32 23 54             ld      (BRKFLG),A
6810+ 412C C3 D5 12             jp      SYSINIT
6811+ 412F
6812+ 412F
6813+ 412F CD 1B 1B     OUTNCR: call    OUTC            ; Output character in A
6814+ 4132 C3 26 20             jp      PRNTCRLF        ; Output CRLF
6815+ 4135
# file closed: ../include/basic/basic-1.11.asm
  76  4135
  77  4135              ; include utils
  78  4135                  INCLUDE "../include/utils/utils-r1.2.asm"
# file opened: ../include/utils/utils-r1.2.asm
   1+ 4135              ; ------------------------------------------------------------------------------
   2+ 4135              ; LM80C - UTILITY ROUTINES - R1.2
   3+ 4135              ; ------------------------------------------------------------------------------
   4+ 4135              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4135              ; designed by Leonardo Miliani. More info at
   6+ 4135              ; www DOT leonardomiliani DOT com
   7+ 4135              ;
   8+ 4135              ; *ALS are routines from "Z80 Assembly Language Subroutines" by Lance
   9+ 4135              ; A. Leventhal and Winthrop Saville - Ed. Osborne/McGraw-Hill (1983)
  10+ 4135              ;
  11+ 4135              ; * WKT are routines from WikiTI:
  12+ 4135              ; http://wikiti.brandonw.net/index.php?title=WikiTI_Home
  13+ 4135              ;
  14+ 4135              ; * LAC are routines from Learn@Cemetch
  15+ 4135              ; https://learn.cemetech.net/index.php/Main_Page
  16+ 4135              ;
  17+ 4135              ; ------------------------------------------------------------------------------
  18+ 4135              ; Code Revision:
  19+ 4135              ; R1.0 - 20200110 - First release: 16-bit comparision/multiplication/negation
  20+ 4135              ; R1.1 - 20200413 - Second release: added ABS(HL)
  21+ 4135              ; R1.2 - 20200131 - Added 32/16 bit multiplication/division and converter to
  22+ 4135              ;                   transform a 32-bit value into ASCII representation
  23+ 4135              ;
  24+ 4135              ; ------------------------------------------------------------------------------
  25+ 4135
  26+ 4135              ; compare two 16-bit registers, HL (minuend) and DE (subtrahend)
  27+ 4135              ; values can be both signed or unsigned words
  28+ 4135              ; inputs: HL, DE
  29+ 4135              ; destroys: A,F,HL
  30+ 4135              ;
  31+ 4135              ; returns: Z=1 if HL = DE
  32+ 4135              ; for UNSIGNED: C=1 if HL<DE  //  C=0 if HL>DE
  33+ 4135              ; for SIGNED:   S=1 (M) if HL<DE  //  S=0 (P) if HL>DE
  34+ 4135              ; if HL=DE: Z,P,NC  - Z=1, S=0; C=0
  35+ 4135              ; if HL>DE: NZ,P,NC - Z=0, S=0; C=0
  36+ 4135              ; if HL<DE: NZ,M,C  - Z=0, S=1; C=1
  37+ 4135              ; Source: ALS
  38+ 4135
  39+ 4135 B7           CMP16:  or      A           ; clear CARRY
  40+ 4136 ED 52                sbc     HL,DE       ; subtract DE from HL
  41+ 4138 E0                   ret     PO          ; return if no overflow
  42+ 4139 7C                   ld      A,H         ; overflow - invert SIGN flag
  43+ 413A 1F                   rra                 ; save CARRY flag in bit 7
  44+ 413B EE 40                xor     %01000000   ; complement bit 6 (SIGN bit)
  45+ 413D 37                   scf                 ; ensure a Non-Zero result
  46+ 413E 8F                   adc     A,A         ; restore CARRY, complemented SIGN
  47+ 413F                                          ; ZERO flag = 0 for sure
  48+ 413F C9                   ret                 ; return
  49+ 4140
  50+ 4140              ; ----------------------------------------------------------------------
  51+ 4140
  52+ 4140              ; multiply 2 signed/unsigned 16-bit words and return a 16-bit
  53+ 4140              ; signed/unsigned product
  54+ 4140              ; inputs: HL (multiplicand); DE (multiplier)
  55+ 4140              ; destroys: A,F
  56+ 4140              ; returns: HL (product)
  57+ 4140              ; Source: ALS
  58+ 4140
  59+ 4140              ; initialize partial product, bit count
  60+ 4140 C5           MUL16:  push    BC
  61+ 4141 4D                   ld      C,L         ; BC = multiplier
  62+ 4142 44                   ld      B,H
  63+ 4143 21 00 00             ld      HL,0        ; product = 0
  64+ 4146 3E 0F                ld      A,$0F       ; count = bit lenght - 1 (16-1)
  65+ 4148                      ; shift-and-add algorithm
  66+ 4148                      ; if MSB of multiplier is 1, add multiplicand to partial product
  67+ 4148                      ; shift partial product, multiplier left 1 bit
  68+ 4148 CB 23        MLP:    sla     E           ; shift multiplier left 1 bit
  69+ 414A CB 12                rl      D
  70+ 414C 30 01                jr      NC,MLP1     ; jump if MSB of multiplier = 0
  71+ 414E 09                   add     HL,BC       ; add multiplicand to partial product
  72+ 414F 29           MLP1:   add     HL,HL       ; shift partial product left
  73+ 4150 3D                   dec     A
  74+ 4151 20 F5                jr      NZ,MLP      ; continue until count = 0
  75+ 4153                      ; add multiplicand one last time if MSB of multiplier is 1
  76+ 4153 B2                   or      D           ; sign flag = MSB of multiplier
  77+ 4154 F2 58 41             jp      P,EXMUL16   ; exit if MSB of multiplier is 0
  78+ 4157 09                   add     HL,BC       ; add multiplicand to product
  79+ 4158 C1           EXMUL16:pop     BC
  80+ 4159 C9                   ret
  81+ 415A
  82+ 415A
  83+ 415A              ; ----------------------------------------------------------------------
  84+ 415A
  85+ 415A              ; multiply 2 unsigned 16-bit words and return a 32-bit unsigned product
  86+ 415A              ; inputs: BC (multiplicand); DE (multiplier)
  87+ 415A              ; destroys: A,F
  88+ 415A              ; operation: BC * DE
  89+ 415A              ; returns: DEHL (product)
  90+ 415A              ; Source: WKT
  91+ 415A
  92+ 415A 21 00 00     MUL_U32:ld      HL,$0000        ; reset HL
  93+ 415D CB 23                sla     E		; optimised 1st iteration
  94+ 415F CB 12                rl      D
  95+ 4161 30 02                jr      NC,MU32_1       ; if no Carry then jump over
  96+ 4163 60                   ld      H,B
  97+ 4164 69                   ld      L,C
  98+ 4165 3E 0F        MU32_1: ld      A,$0F
  99+ 4167 29           MUL_32L:add     HL,HL           ; main loop
 100+ 4168 CB 13                rl      E
 101+ 416A CB 12                rl      D
 102+ 416C 30 04                jr      NC,MU32_2
 103+ 416E 09                   add     HL,BC
 104+ 416F 30 01                jr      NC,MU32_2
 105+ 4171 13                   inc     DE
 106+ 4172 3D           MU32_2: dec     A
 107+ 4173 20 F2                jr      NZ,MUL_32L
 108+ 4175 C9                   ret
 109+ 4176
 110+ 4176              ; ----------------------------------------------------------------------
 111+ 4176              ; absolute value of HL (same applies to other 16-bit register pairs)
 112+ 4176              ; also, invert value of HL (or any other 16-bit register, just adjust the code)
 113+ 4176              ;
 114+ 4176              ; inputs: HL
 115+ 4176              ; destroys: A
 116+ 4176              ; operation: ABS(HL)
 117+ 4176              ; returns: HL with no sign or negated
 118+ 4176              ; Source: WKT
 119+ 4176
 120+ 4176 CB 7C        absHL:  bit     7,H
 121+ 4178 C8                   ret     Z
 122+ 4179 AF           negHL:  xor     A
 123+ 417A 95                   sub     L
 124+ 417B 6F                   ld      L,A
 125+ 417C 9F                   sbc     A,A
 126+ 417D 94                   sub     H
 127+ 417E 67                   ld      H,A
 128+ 417F C9                   ret
 129+ 4180
 130+ 4180              ; ------------------------------------------------------------------------------
 131+ 4180
 132+ 4180              ; 8/8 division
 133+ 4180              ; INPUT: D (dividend), E (divisor)
 134+ 4180              ; OPERATION: D/E
 135+ 4180              ; OUTPUT: D (quotient), A (remainder)
 136+ 4180 AF           DIV_8_8:    xor     A
 137+ 4181 C5                       push    BC
 138+ 4182 06 08                    ld      B,08h
 139+ 4184 CB 22        DIV_8_8LOOP:sla     D
 140+ 4186 17                       rla
 141+ 4187 BB                       cp      E
 142+ 4188 38 02                    jr      C,$+4
 143+ 418A 93                       sub     E
 144+ 418B 14                       inc     D
 145+ 418C 10 F6                    djnz    DIV_8_8LOOP
 146+ 418E C1                       pop     BC
 147+ 418F C9                       ret
 148+ 4190
 149+ 4190              ; ----------------------------------------------------------------------
 150+ 4190              ; divide a 16-bit number by an 8-bit number
 151+ 4190              ; (16/8 division)
 152+ 4190              ;
 153+ 4190              ; inputs: HL (Dividend), C (divisor)
 154+ 4190              ; destroys: A, B
 155+ 4190              ; OPERATION: HL/C
 156+ 4190              ; returns: HL (quotient), A (remainder)
 157+ 4190              ; source: WKT
 158+ 4190
 159+ 4190 AF           DIV_16_8:   xor     A
 160+ 4191 06 10                    ld      B,16
 161+ 4193 29           DIV_16_8LP: add     HL,HL
 162+ 4194 17                       rla
 163+ 4195 38 03                    jr      C,$+5
 164+ 4197 B9                       cp      C
 165+ 4198 38 02                    jr      C,$+4
 166+ 419A 91                       sub     C
 167+ 419B 2C                       inc     L
 168+ 419C 10 F5                    djnz    DIV_16_8LP
 169+ 419E C9                       ret
 170+ 419F
 171+ 419F              ; ----------------------------------------------------------------------
 172+ 419F              ; divide a 16-bit number by a 16-bit number
 173+ 419F              ; (16/16 division)
 174+ 419F              ;
 175+ 419F              ; inputs: AC (Dividend), DE (divisor)
 176+ 419F              ; destroys: HL,A,C
 177+ 419F              ; OPERATION: AC/DE
 178+ 419F              ; returns: AC (quotient), HL (remainder)
 179+ 419F              ; source: WKT
 180+ 419F 21 00 00     DIV_16_16:  ld      HL, 0
 181+ 41A2 06 10                    ld      B, 16
 182+ 41A4 CB 21        DV16_16_LP: sla     C
 183+ 41A6 CB C1                    set     0,C         ; this simulates the SLL undocumented instruction
 184+ 41A8 17                       rla
 185+ 41A9 ED 6A                    adc     HL,HL
 186+ 41AB ED 52                    sbc     HL,DE
 187+ 41AD 30 02                    jr      NC, $+4
 188+ 41AF 19                       add     HL,DE
 189+ 41B0 0D                       dec     C
 190+ 41B1 10 F1                    djnz    DV16_16_LP
 191+ 41B3 C9                       ret
 192+ 41B4
 193+ 41B4
 194+ 41B4              ; ----------------------------------------------------------------------
 195+ 41B4              ; divide a 32-bit number by a 16 bit-number
 196+ 41B4              ; (32/16 division)
 197+ 41B4              ;
 198+ 41B4              ; inputs: ACIX (Dividend), DE (divisor)
 199+ 41B4              ; destroys: HL,IX,BC
 200+ 41B4              ; OPERATION: ACIX/DE
 201+ 41B4              ; returns: ACIX (quotient), HL (remainder)
 202+ 41B4              ; source: WKT
 203+ 41B4
 204+ 41B4 21 00 00     DIV_32_16:  ld      HL,0
 205+ 41B7 06 20                    ld      B,32
 206+ 41B9 DD 29        DIV_32_16LP:add     IX,IX
 207+ 41BB CB 11                    rl      C
 208+ 41BD 17                       rla
 209+ 41BE ED 6A                    adc     HL,HL
 210+ 41C0 38 08                    jr      C,DIV_32_16OF
 211+ 41C2 ED 52                    sbc     HL,DE
 212+ 41C4 30 07                    jr      NC,DIV_32_16SB
 213+ 41C6 19                       add     HL,DE
 214+ 41C7 10 F0                    djnz    DIV_32_16LP
 215+ 41C9 C9                       ret
 216+ 41CA B7           DIV_32_16OF:or      A                   ; overflow
 217+ 41CB ED 52                    sbc     HL,DE
 218+ 41CD DD 23        DIV_32_16SB:inc     IX                  ; set bit
 219+ 41CF 10 E8                    djnz    DIV_32_16LP
 220+ 41D1 C9                       ret
 221+ 41D2
 222+ 41D2
 223+ 41D2              ; ----------------------------------------------------------------------
 224+ 41D2              ; convert a 32-bit number in ASCII string (terminated by '0')
 225+ 41D2              ;
 226+ 41D2              ; inputs: DEIX (Value), IY (dest. address in memory)
 227+ 41D2              ; destroys: AF, BC, DE, HL, IX
 228+ 41D2              ; outputs: IY (last char in dest. string)
 229+ 41D2              ; source: MSX Forum
 230+ 41D2
 231+ 41D2 01 00 00 00  CLCN32T:    defw    1,0,10,0,100,0,1000,0,10000,0
 231+ 41D6 0A 00 00 00
 231+ 41DA 64 00 00 00
 231+ 41DE E8 03 00 00
 231+ 41E2 10 27 00 00
 232+ 41E6 A0 86 01 00              defw    $86A0,$1,$4240,$F,$9680,$98,$E100,$5F5,$CA00,$3B9A
 232+ 41EA 40 42 0F 00
 232+ 41EE 80 96 98 00
 232+ 41F2 00 E1 F5 05
 232+ 41F6 00 CA 9A 3B
 233+ 41FA 00 00 00 00  CLCN32Z:    defs    4
 234+ 41FE
 235+ 41FE DD 22 FA 41  CLCN32:     ld      (CLCN32Z),IX
 236+ 4202 ED 53 FC 41              ld      (CLCN32Z+$02),DE
 237+ 4206 DD 21 F6 41              ld      IX,CLCN32T+$24
 238+ 420A 06 09                    ld      B,$09
 239+ 420C 0E 00                    ld      C,$00
 240+ 420E 3E 30        CLCN321:    ld      A,"0"
 241+ 4210 B7                       or      A
 242+ 4211 DD 5E 00     CLCN322:    ld      E,(IX+$00)
 243+ 4214 DD 56 01                 ld      D,(IX+$01)
 244+ 4217 2A FA 41                 ld      HL,(CLCN32Z)
 245+ 421A ED 52                    sbc     HL,DE
 246+ 421C 22 FA 41                 ld      (CLCN32Z),HL
 247+ 421F DD 5E 02                 ld      E,(IX+$02)
 248+ 4222 DD 56 03                 ld      D,(IX+$03)
 249+ 4225 2A FC 41                 ld      HL,(CLCN32Z+$02)
 250+ 4228 ED 52                    sbc     HL,DE
 251+ 422A 22 FC 41                 ld      (CLCN32Z+$02),HL
 252+ 422D 38 04                    jr      C,CLCN325
 253+ 422F 0C                       inc     C
 254+ 4230 3C                       inc     A
 255+ 4231 18 DE                    jr      CLCN322
 256+ 4233 DD 5E 00     CLCN325:    ld      E,(IX+$00)
 257+ 4236 DD 56 01                 ld      D,(IX+$01)
 258+ 4239 2A FA 41                 ld      HL,(CLCN32Z)
 259+ 423C 19                       add     HL,DE
 260+ 423D 22 FA 41                 ld      (CLCN32Z),HL
 261+ 4240 DD 5E 02                 ld      E,(IX+$02)
 262+ 4243 DD 56 03                 ld      D,(IX+$03)
 263+ 4246 2A FC 41                 ld      HL,(CLCN32Z+$02)
 264+ 4249 ED 5A                    adc     HL,DE
 265+ 424B 22 FC 41                 ld      (CLCN32Z+$02),HL
 266+ 424E 11 FC FF                 ld      DE,-4
 267+ 4251 DD 19                    add     IX,DE
 268+ 4253 0C                       inc     C
 269+ 4254 0D                       dec     C
 270+ 4255 28 05                    jr      Z,CLCN323
 271+ 4257 FD 77 00                 ld      (IY+$00),A
 272+ 425A FD 23                    inc     IY
 273+ 425C 10 B0        CLCN323:    djnz    CLCN321
 274+ 425E 3A FA 41                 ld      A,(CLCN32Z)
 275+ 4261 C6 30                    add     "0"
 276+ 4263 FD 77 00                 ld      (IY+$00),A
 277+ 4266 FD 36 01 00              ld      (IY+$01),0
 278+ 426A C9                       ret
# file closed: ../include/utils/utils-r1.2.asm
  79  426B
  80  426B              ; include the latest version of the font sets
  81  426B                  INCLUDE "../include/vdp/6x8fonts-r16.asm"
# file opened: ../include/vdp/6x8fonts-r16.asm
   1+ 426B              ; ------------------------------------------------------------------------------
   2+ 426B              ; LM80C - 6x8 CHARSET - R1.6
   3+ 426B              ; ------------------------------------------------------------------------------
   4+ 426B              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 426B              ; designed by Leonardo Miliani. More info at
   6+ 426B              ; www DOT leonardomiliani DOT com
   7+ 426B              ; ------------------------------------------------------------------------------
   8+ 426B              ; Code Revision:
   9+ 426B              ; R1.0 - 20190511 - First revision: ASCII chars (from 0 to 127)
  10+ 426B              ; R1.1 - 20190521 - Expanded to 255 chars
  11+ 426B              ; R1.2 - 20191209 - Start adding graphic chars to be coherent with 8x8 fonts
  12+ 426B              ; R1.3 - 20191226 - Added extended char codes (128-255)
  13+ 426B              ; R1.4 - 20200228 - adopted more usual hexadecimal & binary prefixes
  14+ 426B              ; R1.5 - 20200524 - New style for char #252
  15+ 426B              ; R1.6 - 20200704 - Redefined chars 105, 106, and 252
  16+ 426B              ; ------------------------------------------------------------------------------
  17+ 426B              ;
  18+ 426B              ;-------------------------------------------------------------------------------
  19+ 426B              ;
  20+ 426B              ;               6 x 8    C  H  A  R  S  E  T
  21+ 426B              ;
  22+ 426B              ;-------------------------------------------------------------------------------
  23+ 426B              ;
  24+ 426B              ;       6X8 CHARS, DESIGNED FOR TEXT BUT USABLE IN GRAPHICS 1 MODE TOO
  25+ 426B              ;       UPDATE: NOW GRAPHICS 1 MODE HAS ITS OWN CHAR SET
  26+ 426B
  27+ 426B              CHRST68 equ $
  28+ 426B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  28+ 426F 00 00 00 00
  29+ 4273 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  29+ 4277 00 00 00 00
  30+ 427B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  30+ 427F 00 00 00 00
  31+ 4283 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  31+ 4287 00 00 00 00
  32+ 428B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  32+ 428F 00 00 00 00
  33+ 4293 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  33+ 4297 00 00 00 00
  34+ 429B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  34+ 429F 00 00 00 00
  35+ 42A3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  35+ 42A7 00 00 00 00
  36+ 42AB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
  36+ 42AF 00 00 00 00
  37+ 42B3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  37+ 42B7 00 00 00 00
  38+ 42BB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  38+ 42BF 00 00 00 00
  39+ 42C3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11
  39+ 42C7 00 00 00 00
  40+ 42CB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  40+ 42CF 00 00 00 00
  41+ 42D3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
  41+ 42D7 00 00 00 00
  42+ 42DB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
  42+ 42DF 00 00 00 00
  43+ 42E3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  43+ 42E7 00 00 00 00
  44+ 42EB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  44+ 42EF 00 00 00 00
  45+ 42F3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  45+ 42F7 00 00 00 00
  46+ 42FB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  46+ 42FF 00 00 00 00
  47+ 4303 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  47+ 4307 00 00 00 00
  48+ 430B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
  48+ 430F 00 00 00 00
  49+ 4313 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  49+ 4317 00 00 00 00
  50+ 431B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
  50+ 431F 00 00 00 00
  51+ 4323 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
  51+ 4327 00 00 00 00
  52+ 432B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
  52+ 432F 00 00 00 00
  53+ 4333 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
  53+ 4337 00 00 00 00
  54+ 433B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
  54+ 433F 00 00 00 00
  55+ 4343 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
  55+ 4347 00 00 00 00
  56+ 434B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
  56+ 434F 00 00 00 00
  57+ 4353 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
  57+ 4357 00 00 00 00
  58+ 435B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
  58+ 435F 00 00 00 00
  59+ 4363 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
  59+ 4367 00 00 00 00
  60+ 436B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32: space
  60+ 436F 00 00 00 00
  61+ 4373 20 20 20 20          defb $20,$20,$20,$20,$20,$00,$20,$00 ; char 33: !
  61+ 4377 20 00 20 00
  62+ 437B 50 50 00 00          defb $50,$50,$00,$00,$00,$00,$00,$00 ; char 34: "
  62+ 437F 00 00 00 00
  63+ 4383 50 50 F8 50          defb $50,$50,$f8,$50,$f8,$50,$50,$00 ; char 35: #
  63+ 4387 F8 50 50 00
  64+ 438B 20 78 A0 70          defb $20,$78,$a0,$70,$28,$f0,$20,$00 ; char 36: $
  64+ 438F 28 F0 20 00
  65+ 4393 C0 C8 10 20          defb $c0,$c8,$10,$20,$40,$98,$18,$00 ; char 37: %
  65+ 4397 40 98 18 00
  66+ 439B 60 90 A0 40          defb $60,$90,$a0,$40,$a8,$90,$68,$00 ; char 38: &
  66+ 439F A8 90 68 00
  67+ 43A3 60 20 40 00          defb $60,$20,$40,$00,$00,$00,$00,$00 ; char 39: '
  67+ 43A7 00 00 00 00
  68+ 43AB 10 20 40 40          defb $10,$20,$40,$40,$40,$20,$10,$00 ; char 40: (
  68+ 43AF 40 20 10 00
  69+ 43B3 40 20 10 10          defb $40,$20,$10,$10,$10,$20,$40,$00 ; char 41: )
  69+ 43B7 10 20 40 00
  70+ 43BB 00 20 A8 70          defb $00,$20,$a8,$70,$a8,$20,$00,$00 ; char 42: *
  70+ 43BF A8 20 00 00
  71+ 43C3 00 20 20 F8          defb $00,$20,$20,$f8,$20,$20,$00,$00 ; char 43: +
  71+ 43C7 20 20 00 00
  72+ 43CB 00 00 00 00          defb $00,$00,$00,$00,$60,$20,$40,$00 ; char 44: ,
  72+ 43CF 60 20 40 00
  73+ 43D3 00 00 00 F8          defb $00,$00,$00,$f8,$00,$00,$00,$00 ; char 45: -
  73+ 43D7 00 00 00 00
  74+ 43DB 00 00 00 00          defb $00,$00,$00,$00,$00,$60,$60,$00 ; char 46: .
  74+ 43DF 00 60 60 00
  75+ 43E3 00 08 10 20          defb $00,$08,$10,$20,$40,$80,$00,$00 ; char 47: /
  75+ 43E7 40 80 00 00
  76+ 43EB 70 88 98 A8          defb $70,$88,$98,$a8,$c8,$88,$70,$00 ; char 48: 0
  76+ 43EF C8 88 70 00
  77+ 43F3 20 60 20 20          defb $20,$60,$20,$20,$20,$20,$70,$00 ; char 49: 1
  77+ 43F7 20 20 70 00
  78+ 43FB 70 88 08 10          defb $70,$88,$08,$10,$20,$40,$f8,$00 ; char 50: 2
  78+ 43FF 20 40 F8 00
  79+ 4403 F8 10 20 10          defb $f8,$10,$20,$10,$08,$88,$70,$00 ; char 51: 3
  79+ 4407 08 88 70 00
  80+ 440B 10 30 50 90          defb $10,$30,$50,$90,$f8,$10,$10,$00 ; char 52: 4
  80+ 440F F8 10 10 00
  81+ 4413 F8 80 F0 08          defb $f8,$80,$f0,$08,$08,$88,$70,$00 ; char 53: 5
  81+ 4417 08 88 70 00
  82+ 441B 30 40 80 F0          defb $30,$40,$80,$f0,$88,$88,$70,$00 ; char 54: 6
  82+ 441F 88 88 70 00
  83+ 4423 F8 08 10 20          defb $f8,$08,$10,$20,$40,$40,$40,$00 ; char 55: 7
  83+ 4427 40 40 40 00
  84+ 442B 70 88 88 70          defb $70,$88,$88,$70,$88,$88,$70,$00 ; char 56: 8
  84+ 442F 88 88 70 00
  85+ 4433 70 88 88 78          defb $70,$88,$88,$78,$08,$10,$60,$00 ; char 57: 9
  85+ 4437 08 10 60 00
  86+ 443B 00 30 30 00          defb $00,$30,$30,$00,$30,$30,$00,$00 ; char 58: :
  86+ 443F 30 30 00 00
  87+ 4443 00 30 30 00          defb $00,$30,$30,$00,$30,$10,$20,$00 ; char 59: ;
  87+ 4447 30 10 20 00
  88+ 444B 10 20 40 80          defb $10,$20,$40,$80,$40,$20,$10,$00 ; char 60: <
  88+ 444F 40 20 10 00
  89+ 4453 00 00 F8 00          defb $00,$00,$f8,$00,$f8,$00,$00,$00 ; char 61: =
  89+ 4457 F8 00 00 00
  90+ 445B 40 20 10 08          defb $40,$20,$10,$08,$10,$20,$40,$00 ; char 62: >
  90+ 445F 10 20 40 00
  91+ 4463 70 88 08 10          defb $70,$88,$08,$10,$20,$00,$20,$00 ; char 63: ?
  91+ 4467 20 00 20 00
  92+ 446B 70 88 08 68          defb $70,$88,$08,$68,$a8,$a8,$70,$00 ; char 64: @
  92+ 446F A8 A8 70 00
  93+ 4473 70 88 88 88          defb $70,$88,$88,$88,$f8,$88,$88,$00 ; char 65: A
  93+ 4477 F8 88 88 00
  94+ 447B F0 88 88 F0          defb $f0,$88,$88,$f0,$88,$88,$f0,$00 ; char 66: B
  94+ 447F 88 88 F0 00
  95+ 4483 70 88 80 80          defb $70,$88,$80,$80,$80,$88,$70,$00 ; char 67: C
  95+ 4487 80 88 70 00
  96+ 448B E0 90 88 88          defb $e0,$90,$88,$88,$88,$90,$e0,$00 ; char 68: D
  96+ 448F 88 90 E0 00
  97+ 4493 F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$f8,$00 ; char 69: E
  97+ 4497 80 80 F8 00
  98+ 449B F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$80,$00 ; char 70: F
  98+ 449F 80 80 80 00
  99+ 44A3 70 88 80 B8          defb $70,$88,$80,$b8,$88,$88,$78,$00 ; char 71: G
  99+ 44A7 88 88 78 00
 100+ 44AB 88 88 88 F8          defb $88,$88,$88,$f8,$88,$88,$88,$00 ; char 72: H
 100+ 44AF 88 88 88 00
 101+ 44B3 70 20 20 20          defb $70,$20,$20,$20,$20,$20,$70,$00 ; char 73: I
 101+ 44B7 20 20 70 00
 102+ 44BB 38 10 10 10          defb $38,$10,$10,$10,$10,$90,$60,$00 ; char 74: J
 102+ 44BF 10 90 60 00
 103+ 44C3 88 90 A0 C0          defb $88,$90,$a0,$c0,$a0,$90,$88,$00 ; char 75: K
 103+ 44C7 A0 90 88 00
 104+ 44CB 80 80 80 80          defb $80,$80,$80,$80,$80,$80,$f8,$00 ; char 76: L
 104+ 44CF 80 80 F8 00
 105+ 44D3 88 D8 A8 A8          defb $88,$d8,$a8,$a8,$88,$88,$88,$00 ; char 77: M
 105+ 44D7 88 88 88 00
 106+ 44DB 88 C8 A8 98          defb $88,$c8,$a8,$98,$88,$88,$88,$00 ; char 78: N
 106+ 44DF 88 88 88 00
 107+ 44E3 70 88 88 88          defb $70,$88,$88,$88,$88,$88,$70,$00 ; char 79: O
 107+ 44E7 88 88 70 00
 108+ 44EB F0 88 88 F0          defb $f0,$88,$88,$f0,$80,$80,$80,$00 ; char 80: P
 108+ 44EF 80 80 80 00
 109+ 44F3 70 88 88 88          defb $70,$88,$88,$88,$a8,$90,$68,$00 ; char 81: Q
 109+ 44F7 A8 90 68 00
 110+ 44FB F0 88 88 F0          defb $f0,$88,$88,$f0,$a0,$90,$88,$00 ; char 82: R
 110+ 44FF A0 90 88 00
 111+ 4503 78 80 80 70          defb $78,$80,$80,$70,$08,$08,$f0,$00 ; char 83: S
 111+ 4507 08 08 F0 00
 112+ 450B F8 20 20 20          defb $f8,$20,$20,$20,$20,$20,$20,$00 ; char 84: T
 112+ 450F 20 20 20 00
 113+ 4513 88 88 88 88          defb $88,$88,$88,$88,$88,$88,$70,$00 ; char 85: U
 113+ 4517 88 88 70 00
 114+ 451B 88 88 88 88          defb $88,$88,$88,$88,$88,$50,$20,$00 ; char 86: V
 114+ 451F 88 50 20 00
 115+ 4523 88 88 88 88          defb $88,$88,$88,$88,$a8,$a8,$50,$00 ; char 87: W
 115+ 4527 A8 A8 50 00
 116+ 452B 88 88 50 20          defb $88,$88,$50,$20,$50,$88,$88,$00 ; char 88: X
 116+ 452F 50 88 88 00
 117+ 4533 88 88 88 50          defb $88,$88,$88,$50,$20,$20,$20,$00 ; char 89: Y
 117+ 4537 20 20 20 00
 118+ 453B F8 08 10 20          defb $f8,$08,$10,$20,$40,$80,$f8,$00 ; char 90: Z
 118+ 453F 40 80 F8 00
 119+ 4543 70 40 40 40          defb $70,$40,$40,$40,$40,$40,$70,$00 ; char 91: [
 119+ 4547 40 40 70 00
 120+ 454B 00 80 40 20          defb $00,$80,$40,$20,$10,$08,$00,$00 ; char 92: \
 120+ 454F 10 08 00 00
 121+ 4553 70 10 10 10          defb $70,$10,$10,$10,$10,$10,$70,$00 ; char 93: ]
 121+ 4557 10 10 70 00
 122+ 455B 20 50 88 00          defb $20,$50,$88,$00,$00,$00,$00,$00 ; char 94: ^
 122+ 455F 00 00 00 00
 123+ 4563 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$FC ; char 95: _ (underscore)
 123+ 4567 00 00 00 FC
 124+ 456B 40 20 10 00          defb $40,$20,$10,$00,$00,$00,$00,$00 ; char 96: `
 124+ 456F 00 00 00 00
 125+ 4573 00 00 70 08          defb $00,$00,$70,$08,$78,$88,$78,$00 ; char 97: a
 125+ 4577 78 88 78 00
 126+ 457B 80 80 80 B0          defb $80,$80,$80,$b0,$c8,$88,$f0,$00 ; char 98: b
 126+ 457F C8 88 F0 00
 127+ 4583 00 00 70 80          defb $00,$00,$70,$80,$80,$88,$70,$00 ; char 99: c
 127+ 4587 80 88 70 00
 128+ 458B 08 08 08 68          defb $08,$08,$08,$68,$98,$88,$78,$00 ; char 100: d
 128+ 458F 98 88 78 00
 129+ 4593 00 00 70 88          defb $00,$00,$70,$88,$f8,$80,$70,$00 ; char 101: e
 129+ 4597 F8 80 70 00
 130+ 459B 30 48 40 E0          defb $30,$48,$40,$e0,$40,$40,$40,$00 ; char 102: f
 130+ 459F 40 40 40 00
 131+ 45A3 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$70,$00 ; char 103: g
 131+ 45A7 78 08 70 00
 132+ 45AB 80 80 B0 C8          defb $80,$80,$b0,$c8,$88,$88,$88,$00 ; char 104: h
 132+ 45AF 88 88 88 00
 133+ 45B3 20 00 20 20          defb $20,$00,$20,$20,$20,$20,$20,$00 ; char 105: i
 133+ 45B7 20 20 20 00
 134+ 45BB 08 00 18 08          defb $08,$00,$18,$08,$08,$88,$70,$00 ; char 106: j
 134+ 45BF 08 88 70 00
 135+ 45C3 80 80 90 A0          defb $80,$80,$90,$a0,$c0,$a0,$90,$00 ; char 107: k
 135+ 45C7 C0 A0 90 00
 136+ 45CB 60 20 20 20          defb $60,$20,$20,$20,$20,$20,$70,$00 ; char 108: l
 136+ 45CF 20 20 70 00
 137+ 45D3 00 00 D0 A8          defb $00,$00,$d0,$a8,$a8,$88,$88,$00 ; char 109: m
 137+ 45D7 A8 88 88 00
 138+ 45DB 00 00 B0 C8          defb $00,$00,$b0,$c8,$88,$88,$88,$00 ; char 110: n
 138+ 45DF 88 88 88 00
 139+ 45E3 00 00 70 88          defb $00,$00,$70,$88,$88,$88,$70,$00 ; char 111: o
 139+ 45E7 88 88 70 00
 140+ 45EB 00 00 F0 88          defb $00,$00,$f0,$88,$f0,$80,$80,$00 ; char 112: p
 140+ 45EF F0 80 80 00
 141+ 45F3 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$08,$00 ; char 113: q
 141+ 45F7 78 08 08 00
 142+ 45FB 00 00 B0 C8          defb $00,$00,$b0,$c8,$80,$80,$80,$00 ; char 114: r
 142+ 45FF 80 80 80 00
 143+ 4603 00 00 70 80          defb $00,$00,$70,$80,$70,$08,$f0,$00 ; char 115: s
 143+ 4607 70 08 F0 00
 144+ 460B 40 40 E0 40          defb $40,$40,$e0,$40,$40,$48,$30,$00 ; char 116: t
 144+ 460F 40 48 30 00
 145+ 4613 00 00 88 88          defb $00,$00,$88,$88,$88,$98,$68,$00 ; char 117: u
 145+ 4617 88 98 68 00
 146+ 461B 00 00 88 88          defb $00,$00,$88,$88,$88,$50,$20,$00 ; char 118: v
 146+ 461F 88 50 20 00
 147+ 4623 00 00 88 88          defb $00,$00,$88,$88,$a8,$a8,$50,$00 ; char 119: w
 147+ 4627 A8 A8 50 00
 148+ 462B 00 00 88 50          defb $00,$00,$88,$50,$20,$50,$88,$00 ; char 120: x
 148+ 462F 20 50 88 00
 149+ 4633 00 00 88 98          defb $00,$00,$88,$98,$68,$08,$70,$00 ; char 121: y
 149+ 4637 68 08 70 00
 150+ 463B 00 00 F8 10          defb $00,$00,$f8,$10,$20,$40,$f8,$00 ; char 122: z
 150+ 463F 20 40 F8 00
 151+ 4643 10 20 20 40          defb $10,$20,$20,$40,$20,$20,$10,$00 ; char 123: {
 151+ 4647 20 20 10 00
 152+ 464B 20 20 20 20          defb $20,$20,$20,$20,$20,$20,$20,$00 ; char 124: |
 152+ 464F 20 20 20 00
 153+ 4653 20 10 10 08          defb $20,$10,$10,$08,$10,$10,$20,$00 ; char 125: }
 153+ 4657 10 10 20 00
 154+ 465B 00 28 50 00          defb $00,$28,$50,$00,$00,$00,$00,$00 ; char 126: ~
 154+ 465F 00 00 00 00
 155+ 4663 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 127: (delete) - here end the standard ASCII (0-127)
 155+ 4667 00 00 00 00
 156+ 466B 78 84 CC 84          defb %01111000,%10000100,%11001100,%10000100,%10110100,%10000100,%01111000,%00000000 ; char 128 (open face)
 156+ 466F B4 84 78 00
 157+ 4673 78 FC B4 FC          defb %01111000,%11111100,%10110100,%11111100,%10110100,%11001100,%01111000,%00000000 ; char 129 (full face)
 157+ 4677 B4 CC 78 00
 158+ 467B 48 FC FC FC          defb %01001000,%11111100,%11111100,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 130 (hearts)
 158+ 467F FC 78 30 00
 159+ 4683 00 20 70 F8          defb %00000000,%00100000,%01110000,%11111000,%11111000,%01110000,%00100000,%00000000 ; char 131 (diamonds)
 159+ 4687 F8 70 20 00
 160+ 468B 70 20 A8 F8          defb %01110000,%00100000,%10101000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 132 (clubs)
 160+ 468F A8 20 70 00
 161+ 4693 20 70 F8 F8          defb %00100000,%01110000,%11111000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 133 (spades)
 161+ 4697 A8 20 70 00
 162+ 469B 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 134
 162+ 469F FC 30 30 30
 163+ 46A3 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 135
 163+ 46A7 3C 30 30 30
 164+ 46AB 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 136
 164+ 46AF F0 30 30 30
 165+ 46B3 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00000000,%00000000,%00000000 ; char 137
 165+ 46B7 F0 00 00 00
 166+ 46BB 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00000000,%00000000,%00000000 ; char 138
 166+ 46BF 3C 00 00 00
 167+ 46C3 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 139
 167+ 46C7 FC 00 00 00
 168+ 46CB 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 140
 168+ 46CF 3C 30 30 30
 169+ 46D3 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 141
 169+ 46D7 FC 30 30 30
 170+ 46DB 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 142
 170+ 46DF F0 30 30 30
 171+ 46E3 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 143
 171+ 46E7 FC 00 00 00
 172+ 46EB 30 30 30 30          defb %00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000 ; char 144
 172+ 46EF 30 30 30 30
 173+ 46F3 0C 1C 18 38          defb %00001100,%00011100,%00011000,%00111000,%01110000,%01100000,%11100000,%11000000 ; char 145
 173+ 46F7 70 60 E0 C0
 174+ 46FB C0 E0 60 70          defb %11000000,%11100000,%01100000,%01110000,%00111000,%00011000,%00011100,%00001100 ; char 146
 174+ 46FF 38 18 1C 0C
 175+ 4703 CC CC 78 30          defb %11001100,%11001100,%01111000,%00110000,%00110000,%01111000,%11001100,%11001100 ; char 147
 175+ 4707 30 78 CC CC
 176+ 470B 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 148
 176+ 470F 20 20 20 20
 177+ 4713 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 149
 177+ 4717 20 20 20 20
 178+ 471B 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 150
 178+ 471F 20 20 20 20
 179+ 4723 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 151
 179+ 4727 00 00 00 00
 180+ 472B 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00000000,%00000000,%00000000,%00000000 ; char 152
 180+ 472F 00 00 00 00
 181+ 4733 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 153
 181+ 4737 00 00 00 00
 182+ 473B 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 154
 182+ 473F 20 20 20 20
 183+ 4743 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 155
 183+ 4747 20 20 20 20
 184+ 474B 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 156
 184+ 474F 20 20 20 20
 185+ 4753 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 157
 185+ 4757 00 00 00 00
 186+ 475B 20 20 20 20          defb %00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000 ; char 158
 186+ 475F 20 20 20 20
 187+ 4763 04 08 08 10          defb %00000100,%00001000,%00001000,%00010000,%00100000,%01000000,%01000000,%10000000 ; char 159
 187+ 4767 20 40 40 80
 188+ 476B 80 40 40 20          defb %10000000,%01000000,%01000000,%00100000,%00010000,%00001000,%00001000,%00000100 ; char 160
 188+ 476F 10 08 08 04
 189+ 4773 84 48 48 30          defb %10000100,%01001000,%01001000,%00110000,%00110000,%01001000,%01001000,%10000100 ; char 161
 189+ 4777 30 48 48 84
 190+ 477B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 162
 190+ 477F 00 00 FC FC
 191+ 4783 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111100,%11111100,%11111100,%11111100 ; char 163
 191+ 4787 FC FC FC FC
 192+ 478B 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 164
 192+ 478F FC FC FC FC
 193+ 4793 FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 193+ 4797 00 00 00 00
 194+ 479B FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 166
 194+ 479F 00 00 00 00
 195+ 47A3 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 167
 195+ 47A7 FC FC 00 00
 196+ 47AB 80 80 80 80          defb %10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000 ; char 168
 196+ 47AF 80 80 80 80
 197+ 47B3 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000 ; char 169
 197+ 47B7 E0 E0 E0 E0
 198+ 47BB F8 F8 F8 F8          defb %11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000 ; char 170
 198+ 47BF F8 F8 F8 F8
 199+ 47C3 04 04 04 04          defb %00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100 ; char 171
 199+ 47C7 04 04 04 04
 200+ 47CB 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100 ; char 172
 200+ 47CF 1C 1C 1C 1C
 201+ 47D3 7C 7C 7C 7C          defb %01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100 ; char 173
 201+ 47D7 7C 7C 7C 7C
 202+ 47DB FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 174
 202+ 47DF 84 84 84 FC
 203+ 47E3 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%11100000,%11100000,%11100000 ; char 175
 203+ 47E7 E0 E0 E0 E0
 204+ 47EB 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00011100,%00011100,%00011100 ; char 176
 204+ 47EF 1C 1C 1C 1C
 205+ 47F3 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 177
 205+ 47F7 00 00 00 00
 206+ 47FB E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 178
 206+ 47FF 00 00 00 00
 207+ 4803 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00011100,%00011100,%00011100,%00011100 ; char 179
 207+ 4807 1C 1C 1C 1C
 208+ 480B 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%11100000,%11100000,%11100000,%11100000 ; char 180
 208+ 480F E0 E0 E0 E0
 209+ 4813 78 78 78 78          defb %01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000 ; char 181
 209+ 4817 78 78 78 78
 210+ 481B CC CC CC CC          defb %11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100 ; char 182
 210+ 481F CC CC CC CC
 211+ 4823 FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 183
 211+ 4827 00 00 FC FC
 212+ 482B 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 184
 212+ 482F FC FC 00 00
 213+ 4833 30 30 CC CC          defb %00110000,%00110000,%11001100,%11001100,%00110000,%00110000,%11001100,%11001100 ; char 185
 213+ 4837 30 30 CC CC
 214+ 483B 54 A8 54 A8          defb %01010100,%10101000,%01010100,%10101000,%01010100,%10101000,%01010100,%10101000 ; char 186
 214+ 483F 54 A8 54 A8
 215+ 4843 64 30 98 CC          defb %01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100 ; char 187
 215+ 4847 64 30 98 CC
 216+ 484B CC 64 30 98          defb %11001100,%01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000 ; char 188
 216+ 484F CC 64 30 98
 217+ 4853 30 98 CC 64          defb %00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100,%01100100 ; char 189
 217+ 4857 30 98 CC 64
 218+ 485B 64 CC 98 30          defb %01100100,%11001100,%10011000,%00110000,%01100100,%11001100,%10011000,%00110000 ; char 190
 218+ 485F 64 CC 98 30
 219+ 4863 20 20 F8 20          defb %00100000,%00100000,%11111000,%00100000,%00100000,%00000000,%11111000,%00000000 ; char 191 (Â±)
 219+ 4867 20 00 F8 00
 220+ 486B C0 30 08 30          defb %11000000,%00110000,%00001000,%00110000,%11000000,%00000000,%11111000,%00000000 ; char 192 (â¥)
 220+ 486F C0 00 F8 00
 221+ 4873 18 60 80 60          defb %00011000,%01100000,%10000000,%01100000,%00011000,%00000000,%11111000,%00000000 ; char 193 (â¤)
 221+ 4877 18 00 F8 00
 222+ 487B 3C 20 20 20          defb %00111100,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 222+ 487F A0 60 20 00
 223+ 4883 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 223+ 4887 00 00 00 00
 224+ 488B 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 224+ 488F 70 00 00 00
 225+ 4893 00 00 54 A8          defb %00000000,%00000000,%01010100,%10101000,%00000000,%11111100,%00000000,%00000000 ; char 197
 225+ 4897 00 FC 00 00
 226+ 489B 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 226+ 489F 54 A8 00 00
 227+ 48A3 00 80 C0 E0          defb %00000000,%10000000,%11000000,%11100000,%11100000,%11000000,%10000000,%00000000 ; char 199
 227+ 48A7 E0 C0 80 00
 228+ 48AB FC 78 30 00          defb %11111100,%01111000,%00110000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 200
 228+ 48AF 00 00 00 00
 229+ 48B3 00 04 0C 1C          defb %00000000,%00000100,%00001100,%00011100,%00011100,%00001100,%00000100,%00000000 ; char 201
 229+ 48B7 1C 0C 04 00
 230+ 48BB 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00110000,%01111000,%11111100 ; char 202
 230+ 48BF 00 30 78 FC
 231+ 48C3 20 70 F8 20          defb %00100000,%01110000,%11111000,%00100000,%00100000,%00100000,%00100000,%00000000 ; char 203 (up arrow)
 231+ 48C7 20 20 20 00
 232+ 48CB 3C 1C 1C 24          defb %00111100,%00011100,%00011100,%00100100,%01000000,%10000000,%00000000,%00000000 ; char 204 (up right arrow)
 232+ 48CF 40 80 00 00
 233+ 48D3 00 10 18 FC          defb %00000000,%00010000,%00011000,%11111100,%00011000,%00010000,%00000000,%00000000 ; char 205 (right arrow)
 233+ 48D7 18 10 00 00
 234+ 48DB 00 00 80 40          defb %00000000,%00000000,%10000000,%01000000,%00100100,%00011100,%00011100,%00111100 ; char 206 (down right arrow)
 234+ 48DF 24 1C 1C 3C
 235+ 48E3 00 20 20 20          defb %00000000,%00100000,%00100000,%00100000,%00100000,%11111000,%01110000,%00100000 ; char 207 (down arrow)
 235+ 48E7 20 F8 70 20
 236+ 48EB 00 00 04 08          defb %00000000,%00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000 ; char 208 (down left arrow)
 236+ 48EF 90 E0 E0 F0
 237+ 48F3 00 20 60 FC          defb %00000000,%00100000,%01100000,%11111100,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 237+ 48F7 60 20 00 00
 238+ 48FB F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 238+ 48FF 08 04 00 00
 239+ 4903 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 239+ 4907 F0 44 38 00
 240+ 490B 00 04 78 A8          defb %00000000,%00000100,%01111000,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 240+ 490F 28 28 28 00
 241+ 4913 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00100000,%00100000,%00100000 ; char 213
 241+ 4917 1C 20 20 20
 242+ 491B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%00010000,%00010000,%00010000 ; char 214
 242+ 491F E0 10 10 10
 243+ 4923 10 10 10 E0          defb %00010000,%00010000,%00010000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 215
 243+ 4927 00 00 00 00
 244+ 492B 20 20 20 1C          defb %00100000,%00100000,%00100000,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 216
 244+ 492F 00 00 00 00
 245+ 4933 00 00 00 1C          defb %00000000,%00000000,%00000000,%00011100,%00111100,%00110000,%00110000,%00110000 ; char 217
 245+ 4937 3C 30 30 30
 246+ 493B 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00110000,%00110000,%00110000 ; char 218
 246+ 493F F0 30 30 30
 247+ 4943 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 247+ 4947 E0 00 00 00
 248+ 494B 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00011100,%00000000,%00000000,%00000000 ; char 220
 248+ 494F 1C 00 00 00
 249+ 4953 00 30 48 48          defb %00000000,%00110000,%01001000,%01001000,%01001000,%00110000,%00000000,%00000000 ; char 221
 249+ 4957 48 30 00 00
 250+ 495B 00 30 78 78          defb %00000000,%00110000,%01111000,%01111000,%01111000,%00110000,%00000000,%00000000 ; char 222
 250+ 495F 78 30 00 00
 251+ 4963 00 30 78 FC          defb %00000000,%00110000,%01111000,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 223
 251+ 4967 FC 78 30 00
 252+ 496B FC F8 F0 E0          defb %11111100,%11111000,%11110000,%11100000,%11100000,%11000000,%10000000,%10000000 ; char 224
 252+ 496F E0 C0 80 80
 253+ 4973 FC 7C 3C 1C          defb %11111100,%01111100,%00111100,%00011100,%00011100,%00001100,%00000100,%00000100 ; char 225
 253+ 4977 1C 0C 04 04
 254+ 497B 04 04 0C 1C          defb %00000100,%00000100,%00001100,%00011100,%00011100,%00111100,%01111100,%11111100 ; char 226
 254+ 497F 1C 3C 7C FC
 255+ 4983 80 80 C0 E0          defb %10000000,%10000000,%11000000,%11100000,%11100000,%11110000,%11111000,%11111100 ; char 227
 255+ 4987 E0 F0 F8 FC
 256+ 498B 00 04 0C D8          defb %00000000,%00000100,%00001100,%11011000,%11110000,%11100000,%11000000,%00000000 ; char 228 (checkmark)
 256+ 498F F0 E0 C0 00
 257+ 4993 00 CC 78 30          defb %00000000,%11001100,%01111000,%00110000,%01111000,%11001100,%00000000,%00000000 ; char 229 (x)
 257+ 4997 78 CC 00 00
 258+ 499B 70 88 88 88          defb %01110000,%10001000,%10001000,%10001000,%01110000,%00100000,%01110000,%00100000 ; char 230 (female)
 258+ 499F 70 20 70 20
 259+ 49A3 00 1C 0C 74          defb %00000000,%00011100,%00001100,%01110100,%10010000,%10010000,%01100000,%00000000 ; char 231 (male)
 259+ 49A7 90 90 60 00
 260+ 49AB F8 84 84 84          defb %11111000,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 232 (new doc)
 260+ 49AF 84 84 84 FC
 261+ 49B3 00 F0 FC 84          defb %00000000,%11110000,%11111100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 233 (folder)
 261+ 49B7 84 84 84 FC
 262+ 49BB 30 78 FC 48          defb %00110000,%01111000,%11111100,%01001000,%01001000,%01001000,%01001000,%01111000 ; char 234 (trash bin)
 262+ 49BF 48 48 48 78
 263+ 49C3 FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%11111100,%10110100,%10110100,%11111100 ; char 235 (floppy disk)
 263+ 49C7 FC B4 B4 FC
 264+ 49CB 00 00 D4 D8          defb %00000000,%00000000,%11010100,%11011000,%11010100,%11010100,%00000000,%00000000 ; char 236 (OK)
 264+ 49CF D4 D4 00 00
 265+ 49D3 30 78 FC 78          defb %00110000,%01111000,%11111100,%01111000,%01111000,%01001000,%01001000,%01001000 ; char 237 (home)
 265+ 49D7 78 48 48 48
 266+ 49DB 78 84 A4 A4          defb %01111000,%10000100,%10100100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 238 (clock)
 266+ 49DF B4 84 78 00
 267+ 49E3 00 00 08 F4          defb %00000000,%00000000,%00001000,%11110100,%10101000,%10000000,%00000000,%00000000 ; char 239 (key)
 267+ 49E7 A8 80 00 00
 268+ 49EB 20 30 78 B0          defb %00100000,%00110000,%01111000,%10110000,%10100000,%10001000,%01110000,%00000000 ; char 240 (undo)
 268+ 49EF A0 88 70 00
 269+ 49F3 00 FC CC B4          defb %00000000,%11111100,%11001100,%10110100,%10000100,%10000100,%11111100,%00000000 ; char 241 (letter)
 269+ 49F7 84 84 FC 00
 270+ 49FB 60 90 90 F0          defb %01100000,%10010000,%10010000,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 242 (lock)
 270+ 49FF F0 F0 F0 00
 271+ 4A03 08 14 14 F0          defb %00001000,%00010100,%00010100,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 243 (unlock)
 271+ 4A07 F0 F0 F0 00
 272+ 4A0B FC FC 84 B4          defb %11111100,%11111100,%10000100,%10110100,%10010100,%10010100,%10000100,%11111100 ; char 244 (calendar)
 272+ 4A0F 94 94 84 FC
 273+ 4A13 00 04 38 58          defb %00000000,%00000100,%00111000,%01011000,%01101000,%01110000,%10000000,%00000000 ; char 245 (diameter)
 273+ 4A17 68 70 80 00
 274+ 4A1B 78 84 84 84          defb %01111000,%10000100,%10000100,%10000100,%01101100,%00011000,%00001000,%00000000 ; char 246 (baloon)
 274+ 4A1F 6C 18 08 00
 275+ 4A23 30 28 28 28          defb %00110000,%00101000,%00101000,%00101000,%00100000,%01100000,%11100000,%01000000 ; char 247 (note)
 275+ 4A27 20 60 E0 40
 276+ 4A2B 20 68 E4 E4          defb %00100000,%01101000,%11100100,%11100100,%11100100,%01101000,%00100000,%00000000 ; char 248 (audio on)
 276+ 4A2F E4 68 20 00
 277+ 4A33 20 60 E0 E0          defb %00100000,%01100000,%11100000,%11100000,%11100000,%01100000,%00100000,%00000000 ; char 249 (audio off)
 277+ 4A37 E0 60 20 00
 278+ 4A3B 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11110000,%10010000 ; char 250 (pointer)
 278+ 4A3F F8 FC F0 90
 279+ 4A43 78 84 B4 A4          defb %01111000,%10000100,%10110100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 251 (Â©)
 279+ 4A47 B4 84 78 00
 280+ 4A4B 30 48 40 E0          defb %00110000,%01001000,%01000000,%11100000,%01000000,%01001000,%10110000,%00000000 ; char 252 (Â£)
 280+ 4A4F 40 48 B0 00
 281+ 4A53 78 84 F0 48          defb %01111000,%10000100,%11110000,%01001000,%01001000,%00111100,%10000100,%01111000 ; char 253 (Â§)
 281+ 4A57 48 3C 84 78
 282+ 4A5B 00 00 20 00          defb %00000000,%00000000,%00100000,%00000000,%11111000,%00000000,%00100000,%00000000 ; char 254 (Ã·)
 282+ 4A5F F8 00 20 00
 283+ 4A63 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 255 (cursor)
 283+ 4A67 FC FC FC FC
 284+ 4A6B                      ; here ends the ASCII table
 285+ 4A6B
# file closed: ../include/vdp/6x8fonts-r16.asm
  82  4A6B                  INCLUDE "../include/vdp/8x8fonts-r18.asm"
# file opened: ../include/vdp/8x8fonts-r18.asm
   1+ 4A6B              ; ------------------------------------------------------------------------------
   2+ 4A6B              ; LM80C - 8x8 CHARSET - R1.8
   3+ 4A6B              ; ------------------------------------------------------------------------------
   4+ 4A6B              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4A6B              ; designed by Leonardo Miliani. More info at
   6+ 4A6B              ; www DOT leonardomiliani DOT com
   7+ 4A6B              ; ------------------------------------------------------------------------------
   8+ 4A6B              ; Code Revision:
   9+ 4A6B              ; R1.0 - 20190615 - First revision: ASCII chars (from 0 to 255) - actually, they are 6x8 pixels
  10+ 4A6B              ; R1.1 - 20190616 - Converted to 8x8 pixels
  11+ 4A6B              ; R1.2 - 20191013 - Added new graphic chars and reorganized previous ones
  12+ 4A6B              ; R1.3 - 20191015 - More graphic chars
  13+ 4A6B              ; R1.4 - 20191202 - Fixed char 11/12, added new special chars
  14+ 4A6B              ; R1.5 - 20191210 - Changed several graphic chars
  15+ 4A6B              ; R1.6 - 20200125 - Removed double chars, changed with new ones
  16+ 4A6B              ; R1.7 - 20200228 - adopted more usual hexadecimal & binary prefixes
  17+ 4A6B              ; R1.8 - 20200524 - New style for char #252
  18+ 4A6B              ; ------------------------------------------------------------------------------
  19+ 4A6B              ;
  20+ 4A6B              ;-------------------------------------------------------------------------------
  21+ 4A6B              ;
  22+ 4A6B              ;               8 x 8    C  H  A  R  S  E  T
  23+ 4A6B              ;
  24+ 4A6B              ;-------------------------------------------------------------------------------
  25+ 4A6B              ;
  26+ 4A6B              ;       8X8 CHARS, DESIGNED FOR GRAPHICS 1 MODE
  27+ 4A6B
  28+ 4A6B              CHRST88 equ $
  29+ 4A6B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  29+ 4A6F 00 00 00 00
  30+ 4A73 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  30+ 4A77 00 00 00 00
  31+ 4A7B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  31+ 4A7F 00 00 00 00
  32+ 4A83 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  32+ 4A87 00 00 00 00
  33+ 4A8B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  33+ 4A8F 00 00 00 00
  34+ 4A93 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  34+ 4A97 00 00 00 00
  35+ 4A9B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  35+ 4A9F 00 00 00 00
  36+ 4AA3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  36+ 4AA7 00 00 00 00
  37+ 4AAB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 DEL key (backspace)
  37+ 4AAF 00 00 00 00
  38+ 4AB3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  38+ 4AB7 00 00 00 00
  39+ 4ABB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  39+ 4ABF 00 00 00 00
  40+ 4AC3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 (unused)
  40+ 4AC7 00 00 00 00
  41+ 4ACB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  41+ 4ACF 00 00 00 00
  42+ 4AD3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 RETURN key (carriage return)
  42+ 4AD7 00 00 00 00
  43+ 4ADB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL key
  43+ 4ADF 00 00 00 00
  44+ 4AE3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  44+ 4AE7 00 00 00 00
  45+ 4AEB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  45+ 4AEF 00 00 00 00
  46+ 4AF3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  46+ 4AF7 00 00 00 00
  47+ 4AFB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  47+ 4AFF 00 00 00 00
  48+ 4B03 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  48+ 4B07 00 00 00 00
  49+ 4B0B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT key
  49+ 4B0F 00 00 00 00
  50+ 4B13 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  50+ 4B17 00 00 00 00
  51+ 4B1B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6 key
  51+ 4B1F 00 00 00 00
  52+ 4B23 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7 key
  52+ 4B27 00 00 00 00
  53+ 4B2B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP key
  53+ 4B2F 00 00 00 00
  54+ 4B33 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 HOME key
  54+ 4B37 00 00 00 00
  55+ 4B3B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26 INSERT key
  55+ 4B3F 00 00 00 00
  56+ 4B43 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 ESCAPE key
  56+ 4B47 00 00 00 00
  57+ 4B4B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 CRSR LEFT key (cursor left)
  57+ 4B4F 00 00 00 00
  58+ 4B53 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 CRSR RIGHT key (cursor right)
  58+ 4B57 00 00 00 00
  59+ 4B5B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 CRSR UP key (cursor up)
  59+ 4B5F 00 00 00 00
  60+ 4B63 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 CRSR DOWN key (cursor down)
  60+ 4B67 00 00 00 00
  61+ 4B6B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32 SPACE key
  61+ 4B6F 00 00 00 00
  62+ 4B73 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00000000,%00010000,%00000000 ; char 33 - !
  62+ 4B77 10 00 10 00
  63+ 4B7B 28 28 28 00          defb %00101000,%00101000,%00101000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 34 - "
  63+ 4B7F 00 00 00 00
  64+ 4B83 28 28 FE 28          defb %00101000,%00101000,%11111110,%00101000,%11111110,%00101000,%00101000,%00000000 ; char 35 - #
  64+ 4B87 FE 28 28 00
  65+ 4B8B 10 3C 50 38          defb %00010000,%00111100,%01010000,%00111000,%00010100,%01111000,%00010000,%00000000 ; char 36 - $
  65+ 4B8F 14 78 10 00
  66+ 4B93 00 62 64 08          defb %00000000,%01100010,%01100100,%00001000,%00010000,%00100110,%01000110,%00000000 ; char 37 - %
  66+ 4B97 10 26 46 00
  67+ 4B9B 00 30 48 30          defb %00000000,%00110000,%01001000,%00110000,%01001010,%01000100,%00111010,%00000000 ; char 38 - &
  67+ 4B9F 4A 44 3A 00
  68+ 4BA3 08 10 20 00          defb %00001000,%00010000,%00100000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 39 - '
  68+ 4BA7 00 00 00 00
  69+ 4BAB 08 10 20 20          defb %00001000,%00010000,%00100000,%00100000,%00100000,%00010000,%00001000,%00000000 ; char 40 - (
  69+ 4BAF 20 10 08 00
  70+ 4BB3 20 10 08 08          defb %00100000,%00010000,%00001000,%00001000,%00001000,%00010000,%00100000,%00000000 ; char 41 - )
  70+ 4BB7 08 10 20 00
  71+ 4BBB 00 10 54 38          defb %00000000,%00010000,%01010100,%00111000,%00111000,%01010100,%00010000,%00000000 ; char 42 - *
  71+ 4BBF 38 54 10 00
  72+ 4BC3 00 10 10 7C          defb %00000000,%00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%00000000 ; char 43 - +
  72+ 4BC7 10 10 00 00
  73+ 4BCB 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00001000,%00010000 ; char 44 - ,
  73+ 4BCF 00 18 08 10
  74+ 4BD3 00 00 00 7C          defb %00000000,%00000000,%00000000,%01111100,%00000000,%00000000,%00000000,%00000000 ; char 45 - -
  74+ 4BD7 00 00 00 00
  75+ 4BDB 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00011000,%00000000 ; char 46 - .
  75+ 4BDF 00 18 18 00
  76+ 4BE3 00 02 04 08          defb %00000000,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%00000000 ; char 47 - /
  76+ 4BE7 10 20 40 00
  77+ 4BEB 38 44 4C 54          defb %00111000,%01000100,%01001100,%01010100,%01100100,%01000100,%00111000,%00000000 ; char 48 - 0
  77+ 4BEF 64 44 38 00
  78+ 4BF3 10 30 50 10          defb %00010000,%00110000,%01010000,%00010000,%00010000,%00010000,%01111100,%00000000 ; char 49 - 1
  78+ 4BF7 10 10 7C 00
  79+ 4BFB 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 50 - 2
  79+ 4BFF 10 20 7C 00
  80+ 4C03 7C 08 10 08          defb %01111100,%00001000,%00010000,%00001000,%00000100,%01000100,%00111000,%00000000 ; char 51 - 3
  80+ 4C07 04 44 38 00
  81+ 4C0B 08 18 28 48          defb %00001000,%00011000,%00101000,%01001000,%01111100,%00001000,%00001000,%00000000 ; char 52 - 4
  81+ 4C0F 7C 08 08 00
  82+ 4C13 7C 40 78 04          defb %01111100,%01000000,%01111000,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 53 - 5
  82+ 4C17 04 44 38 00
  83+ 4C1B 38 44 40 78          defb %00111000,%01000100,%01000000,%01111000,%01000100,%01000100,%00111000,%00000000 ; char 54 - 6
  83+ 4C1F 44 44 38 00
  84+ 4C23 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%00100000,%00100000,%00000000 ; char 55 - 7
  84+ 4C27 20 20 20 00
  85+ 4C2B 38 44 44 38          defb %00111000,%01000100,%01000100,%00111000,%01000100,%01000100,%00111000,%00000000 ; char 56 - 8
  85+ 4C2F 44 44 38 00
  86+ 4C33 38 44 44 3C          defb %00111000,%01000100,%01000100,%00111100,%00000100,%01000100,%00111000,%00000000 ; char 57 - 9
  86+ 4C37 04 44 38 00
  87+ 4C3B 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00011000,%00000000,%00000000 ; char 58 - :
  87+ 4C3F 18 18 00 00
  88+ 4C43 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00001000,%00010000,%00000000 ; char 59 - ;
  88+ 4C47 18 08 10 00
  89+ 4C4B 04 08 10 20          defb %00000100,%00001000,%00010000,%00100000,%00010000,%00001000,%00000100,%00000000 ; char 60 - <
  89+ 4C4F 10 08 04 00
  90+ 4C53 00 00 7E 00          defb %00000000,%00000000,%01111110,%00000000,%01111110,%00000000,%00000000,%00000000 ; char 61 - =
  90+ 4C57 7E 00 00 00
  91+ 4C5B 20 10 08 04          defb %00100000,%00010000,%00001000,%00000100,%00001000,%00010000,%00100000,%00000000 ; char 62 - >
  91+ 4C5F 08 10 20 00
  92+ 4C63 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00000000,%00010000,%00000000 ; char 63 - ?
  92+ 4C67 10 00 10 00
  93+ 4C6B 78 84 BC AC          defb %01111000,%10000100,%10111100,%10101100,%10111000,%10000000,%10000100,%01111000 ; char 64 - @
  93+ 4C6F B8 80 84 78
  94+ 4C73 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%00000000 ; char 65 - A
  94+ 4C77 7C 44 44 00
  95+ 4C7B 78 44 44 78          defb %01111000,%01000100,%01000100,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 66 - B
  95+ 4C7F 44 44 78 00
  96+ 4C83 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 67 - C
  96+ 4C87 40 44 38 00
  97+ 4C8B 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01000100,%01000100,%01111000,%00000000 ; char 68 - D
  97+ 4C8F 44 44 78 00
  98+ 4C93 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01111100,%00000000 ; char 69 - E
  98+ 4C97 40 40 7C 00
  99+ 4C9B 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01000000,%00000000 ; char 70 - F
  99+ 4C9F 40 40 40 00
 100+ 4CA3 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01011100,%01000100,%00111000,%00000000 ; char 71 - G
 100+ 4CA7 5C 44 38 00
 101+ 4CAB 44 44 44 7C          defb %01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%01000100,%00000000 ; char 72 - H
 101+ 4CAF 44 44 44 00
 102+ 4CB3 38 10 10 10          defb %00111000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 73 - I
 102+ 4CB7 10 10 38 00
 103+ 4CBB 3C 04 04 04          defb %00111100,%00000100,%00000100,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 74 - J
 103+ 4CBF 04 44 38 00
 104+ 4CC3 44 44 48 70          defb %01000100,%01000100,%01001000,%01110000,%01001000,%01000100,%01000100,%00000000 ; char 75 - K
 104+ 4CC7 48 44 44 00
 105+ 4CCB 40 40 40 40          defb %01000000,%01000000,%01000000,%01000000,%01000000,%01000000,%01111100,%00000000 ; char 76 - L
 105+ 4CCF 40 40 7C 00
 106+ 4CD3 42 66 5A 42          defb %01000010,%01100110,%01011010,%01000010,%01000010,%01000010,%01000010,%00000000 ; char 77 - M
 106+ 4CD7 42 42 42 00
 107+ 4CDB 44 64 54 4C          defb %01000100,%01100100,%01010100,%01001100,%01000100,%01000100,%01000100,%00000000 ; char 78 - N
 107+ 4CDF 44 44 44 00
 108+ 4CE3 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 79 - O
 108+ 4CE7 44 44 38 00
 109+ 4CEB 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01000000,%01000000,%00000000 ; char 80 - P
 109+ 4CEF 78 40 40 00
 110+ 4CF3 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01010100,%01001000,%00110100,%00000000 ; char 81 - Q
 110+ 4CF7 54 48 34 00
 111+ 4CFB 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01001000,%01000100,%00000000 ; char 82 - R
 111+ 4CFF 78 48 44 00
 112+ 4D03 3C 40 40 38          defb %00111100,%01000000,%01000000,%00111000,%00000100,%00000100,%01111000,%00000000 ; char 83 - S
 112+ 4D07 04 04 78 00
 113+ 4D0B 7C 10 10 10          defb %01111100,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 84 - T
 113+ 4D0F 10 10 10 00
 114+ 4D13 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 85 - U
 114+ 4D17 44 44 38 00
 115+ 4D1B 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 86 - V
 115+ 4D1F 44 28 10 00
 116+ 4D23 42 42 42 42          defb %01000010,%01000010,%01000010,%01000010,%01011010,%01011010,%00100100,%00000000 ; char 87 - W
 116+ 4D27 5A 5A 24 00
 117+ 4D2B 44 44 28 10          defb %01000100,%01000100,%00101000,%00010000,%00101000,%01000100,%01000100,%00000000 ; char 88 - X
 117+ 4D2F 28 44 44 00
 118+ 4D33 44 44 44 28          defb %01000100,%01000100,%01000100,%00101000,%00010000,%00010000,%00010000,%00000000 ; char 89 - Y
 118+ 4D37 10 10 10 00
 119+ 4D3B 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%01000000,%01111100,%00000000 ; char 90 - Z
 119+ 4D3F 20 40 7C 00
 120+ 4D43 38 20 20 20          defb %00111000,%00100000,%00100000,%00100000,%00100000,%00100000,%00111000,%00000000 ; char 91 - [
 120+ 4D47 20 20 38 00
 121+ 4D4B 00 40 20 10          defb %00000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000000 ; char 92 - \
 121+ 4D4F 08 04 02 00
 122+ 4D53 38 08 08 08          defb %00111000,%00001000,%00001000,%00001000,%00001000,%00001000,%00111000,%00000000 ; char 93 - ]
 122+ 4D57 08 08 38 00
 123+ 4D5B 10 28 44 00          defb %00010000,%00101000,%01000100,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 94 - ^
 123+ 4D5F 00 00 00 00
 124+ 4D63 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%01111110,%00000000 ; char 95 _ (underscore)
 124+ 4D67 00 00 7E 00
 125+ 4D6B 20 10 08 00          defb %00100000,%00010000,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 96 - `
 125+ 4D6F 00 00 00 00
 126+ 4D73 00 00 38 04          defb %00000000,%00000000,%00111000,%00000100,%00111100,%01000100,%00111100,%00000000 ; char 97 - a
 126+ 4D77 3C 44 3C 00
 127+ 4D7B 40 40 40 78          defb %01000000,%01000000,%01000000,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 98 - b
 127+ 4D7F 44 44 78 00
 128+ 4D83 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 99 - c
 128+ 4D87 40 44 38 00
 129+ 4D8B 04 04 04 3C          defb %00000100,%00000100,%00000100,%00111100,%01000100,%01000100,%00111100,%00000000 ; char 100 - d
 129+ 4D8F 44 44 3C 00
 130+ 4D93 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01111100,%01000000,%00111000,%00000000 ; char 101 - e
 130+ 4D97 7C 40 38 00
 131+ 4D9B 18 24 20 70          defb %00011000,%00100100,%00100000,%01110000,%00100000,%00100000,%00100000,%00000000 ; char 102 - f
 131+ 4D9F 20 20 20 00
 132+ 4DA3 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00111000 ; char 103 - g
 132+ 4DA7 44 3C 04 38
 133+ 4DAB 40 40 58 64          defb %01000000,%01000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 104 - h
 133+ 4DAF 44 44 44 00
 134+ 4DB3 00 10 00 10          defb %00000000,%00010000,%00000000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 105 - i
 134+ 4DB7 10 10 10 00
 135+ 4DBB 08 00 18 08          defb %00001000,%00000000,%00011000,%00001000,%00001000,%00001000,%01001000,%00110000 ; char 106 - j
 135+ 4DBF 08 08 48 30
 136+ 4DC3 40 40 48 50          defb %01000000,%01000000,%01001000,%01010000,%01100000,%01010000,%01001000,%00000000 ; char 107 - k
 136+ 4DC7 60 50 48 00
 137+ 4DCB 30 10 10 10          defb %00110000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 108 - l
 137+ 4DCF 10 10 38 00
 138+ 4DD3 00 00 54 6A          defb %00000000,%00000000,%01010100,%01101010,%01001010,%01000010,%01000010,%00000000 ; char 109 - m
 138+ 4DD7 4A 42 42 00
 139+ 4DDB 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 110 - n
 139+ 4DDF 44 44 44 00
 140+ 4DE3 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 111: o
 140+ 4DE7 44 44 38 00
 141+ 4DEB 00 00 78 44          defb %00000000,%00000000,%01111000,%01000100,%01000100,%01111000,%01000000,%01000000 ; char 112: p
 141+ 4DEF 44 78 40 40
 142+ 4DF3 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00000100 ; char 113: q
 142+ 4DF7 44 3C 04 04
 143+ 4DFB 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000000,%01000000,%01000000,%00000000 ; char 114: r
 143+ 4DFF 40 40 40 00
 144+ 4E03 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%00111000,%00000100,%01111000,%00000000 ; char 115: s
 144+ 4E07 38 04 78 00
 145+ 4E0B 20 20 70 20          defb %00100000,%00100000,%01110000,%00100000,%00100000,%00100100,%00011000,%00000000 ; char 116: t
 145+ 4E0F 20 24 18 00
 146+ 4E13 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%01001100,%00110100,%00000000 ; char 117: u
 146+ 4E17 44 4C 34 00
 147+ 4E1B 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 118: v
 147+ 4E1F 44 28 10 00
 148+ 4E23 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01010100,%01010100,%00101000,%00000000 ; char 119: w
 148+ 4E27 54 54 28 00
 149+ 4E2B 00 00 44 28          defb %00000000,%00000000,%01000100,%00101000,%00010000,%00101000,%01000100,%00000000 ; char 120: x
 149+ 4E2F 10 28 44 00
 150+ 4E33 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01001100,%00110100,%00000100,%00111000 ; char 121: y
 150+ 4E37 4C 34 04 38
 151+ 4E3B 00 00 7C 08          defb %00000000,%00000000,%01111100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 122: z
 151+ 4E3F 10 20 7C 00
 152+ 4E43 18 20 20 40          defb %00011000,%00100000,%00100000,%01000000,%00100000,%00100000,%00011000,%00000000 ; char 123: {
 152+ 4E47 20 20 18 00
 153+ 4E4B 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 124: |
 153+ 4E4F 10 10 10 00
 154+ 4E53 30 08 08 04          defb %00110000,%00001000,%00001000,%00000100,%00001000,%00001000,%00110000,%00000000 ; char 125: }
 154+ 4E57 08 08 30 00
 155+ 4E5B 20 54 08 00          defb %00100000,%01010100,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 126: ~
 155+ 4E5F 00 00 00 00
 156+ 4E63 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 127 (delete) - end the standard ASCII (0-127)
 156+ 4E67 00 00 00 00
 157+ 4E6B 3C 42 A5 81          defb %00111100,%01000010,%10100101,%10000001,%10100101,%10011001,%01000010,%00111100 ; char 128 (open face)
 157+ 4E6F A5 99 42 3C
 158+ 4E73 3C 7E DB FF          defb %00111100,%01111110,%11011011,%11111111,%11011011,%11100111,%01111110,%00111100 ; char 129 (full face)
 158+ 4E77 DB E7 7E 3C
 159+ 4E7B 6C FE FE FE          defb %01101100,%11111110,%11111110,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 130 (hearts)
 159+ 4E7F 7C 38 10 00
 160+ 4E83 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 131 (diamonds)
 160+ 4E87 7C 38 10 00
 161+ 4E8B 10 38 54 FE          defb %00010000,%00111000,%01010100,%11111110,%01010100,%00010000,%01111100,%00000000 ; char 132 (clus)
 161+ 4E8F 54 10 7C 00
 162+ 4E93 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%11010110,%00010000,%01111100,%00000000 ; char 133 (spades)
 162+ 4E97 D6 10 7C 00
 163+ 4E9B 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 134
 163+ 4E9F FF 18 18 18
 164+ 4EA3 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 135
 164+ 4EA7 1F 18 18 18
 165+ 4EAB 00 00 00 F8          defb %00000000,%00000000,%00000000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 136
 165+ 4EAF F8 18 18 18
 166+ 4EB3 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00000000,%00000000,%00000000 ; char 137
 166+ 4EB7 F8 00 00 00
 167+ 4EBB 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00000000,%00000000,%00000000 ; char 138
 167+ 4EBF 1F 00 00 00
 168+ 4EC3 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 139
 168+ 4EC7 FF 00 00 00
 169+ 4ECB 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 140
 169+ 4ECF 1F 18 18 18
 170+ 4ED3 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 141
 170+ 4ED7 FF 18 18 18
 171+ 4EDB 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 142
 171+ 4EDF F8 18 18 18
 172+ 4EE3 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 143
 172+ 4EE7 FF 00 00 00
 173+ 4EEB 18 18 18 18          defb %00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000 ; char 144
 173+ 4EEF 18 18 18 18
 174+ 4EF3 03 07 0E 1C          defb %00000011,%00000111,%00001110,%00011100,%00111000,%01110000,%11100000,%11000000 ; char 145
 174+ 4EF7 38 70 E0 C0
 175+ 4EFB C0 E0 70 38          defb %11000000,%11100000,%01110000,%00111000,%00011100,%00001110,%00000111,%00000011 ; char 146
 175+ 4EFF 1C 0E 07 03
 176+ 4F03 C3 E7 7E 3C          defb %11000011,%11100111,%01111110,%00111100,%00111100,%01111110,%11100111,%11000011 ; char 147
 176+ 4F07 3C 7E E7 C3
 177+ 4F0B 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 148
 177+ 4F0F 10 10 10 10
 178+ 4F13 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 149
 178+ 4F17 10 10 10 10
 179+ 4F1B 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 150
 179+ 4F1F 10 10 10 10
 180+ 4F23 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 151
 180+ 4F27 00 00 00 00
 181+ 4F2B 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00000000,%00000000,%00000000,%00000000 ; char 152
 181+ 4F2F 00 00 00 00
 182+ 4F33 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 153
 182+ 4F37 00 00 00 00
 183+ 4F3B 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 154
 183+ 4F3F 10 10 10 10
 184+ 4F43 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 155
 184+ 4F47 10 10 10 10
 185+ 4F4B 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 156
 185+ 4F4F 10 10 10 10
 186+ 4F53 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 157
 186+ 4F57 00 00 00 00
 187+ 4F5B 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000 ; char 158
 187+ 4F5F 10 10 10 10
 188+ 4F63 01 02 04 08          defb %00000001,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%10000000 ; char 159
 188+ 4F67 10 20 40 80
 189+ 4F6B 80 40 20 10          defb %10000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000001 ; char 160
 189+ 4F6F 08 04 02 01
 190+ 4F73 81 42 24 18          defb %10000001,%01000010,%00100100,%00011000,%00011000,%00100100,%01000010,%10000001 ; char 161
 190+ 4F77 18 24 42 81
 191+ 4F7B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 162
 191+ 4F7F 00 00 FF FF
 192+ 4F83 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; char 163
 192+ 4F87 FF FF FF FF
 193+ 4F8B 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 164
 193+ 4F8F FF FF FF FF
 194+ 4F93 FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 194+ 4F97 00 00 00 00
 195+ 4F9B FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 166
 195+ 4F9F 00 00 00 00
 196+ 4FA3 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 167
 196+ 4FA7 FF FF 00 00
 197+ 4FAB C0 C0 C0 C0          defb %11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000 ; char 168
 197+ 4FAF C0 C0 C0 C0
 198+ 4FB3 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; char 169
 198+ 4FB7 F0 F0 F0 F0
 199+ 4FBB FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 170
 199+ 4FBF FC FC FC FC
 200+ 4FC3 03 03 03 03          defb %00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011 ; char 171
 200+ 4FC7 03 03 03 03
 201+ 4FCB 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; char 172
 201+ 4FCF 0F 0F 0F 0F
 202+ 4FD3 3F 3F 3F 3F          defb %00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111 ; char 173
 202+ 4FD7 3F 3F 3F 3F
 203+ 4FDB FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 174
 203+ 4FDF 81 81 81 FF
 204+ 4FE3 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; char 175
 204+ 4FE7 F0 F0 F0 F0
 205+ 4FEB 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; char 176
 205+ 4FEF 0F 0F 0F 0F
 206+ 4FF3 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; char 177
 206+ 4FF7 00 00 00 00
 207+ 4FFB F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 178
 207+ 4FFF 00 00 00 00
 208+ 5003 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00001111,%00001111,%00001111,%00001111 ; char 179
 208+ 5007 0F 0F 0F 0F
 209+ 500B 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%11110000,%11110000,%11110000,%11110000 ; char 180
 209+ 500F F0 F0 F0 F0
 210+ 5013 3C 3C 3C 3C          defb %00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100 ; char 181
 210+ 5017 3C 3C 3C 3C
 211+ 501B C3 C3 C3 C3          defb %11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011 ; char 182
 211+ 501F C3 C3 C3 C3
 212+ 5023 FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 183
 212+ 5027 00 00 FF FF
 213+ 502B 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 184
 213+ 502F FF FF 00 00
 214+ 5033 33 33 CC CC          defb %00110011,%00110011,%11001100,%11001100,%00110011,%00110011,%11001100,%11001100 ; char 185
 214+ 5037 33 33 CC CC
 215+ 503B 55 AA 55 AA          defb %01010101,%10101010,%01010101,%10101010,%01010101,%10101010,%01010101,%10101010 ; char 186
 215+ 503F 55 AA 55 AA
 216+ 5043 66 33 99 CC          defb %01100110,%00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100 ; char 187
 216+ 5047 66 33 99 CC
 217+ 504B CC 99 33 66          defb %11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011,%01100110 ; char 188
 217+ 504F CC 99 33 66
 218+ 5053 33 99 CC 66          defb %00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100,%01100110 ; char 189
 218+ 5057 33 99 CC 66
 219+ 505B 66 CC 99 33          defb %01100110,%11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011 ; char 190
 219+ 505F 66 CC 99 33
 220+ 5063 10 10 7C 10          defb %00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%01111100,%00000000 ; char 191 (Â±)
 220+ 5067 10 00 7C 00
 221+ 506B 60 18 06 18          defb %01100000,%00011000,%00000110,%00011000,%01100000,%00000000,%01111110,%00000000 ; char 192 (â¥)
 221+ 506F 60 00 7E 00
 222+ 5073 06 18 60 18          defb %00000110,%00011000,%01100000,%00011000,%00000110,%00000000,%01111110,%00000000 ; char 193 (â¤)
 222+ 5077 06 00 7E 00
 223+ 507B 3E 20 20 20          defb %00111110,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 223+ 507F A0 60 20 00
 224+ 5083 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 224+ 5087 00 00 00 00
 225+ 508B 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 225+ 508F 70 00 00 00
 226+ 5093 00 00 2A 54          defb %00000000,%00000000,%00101010,%01010100,%00000000,%01111110,%00000000,%00000000 ; char 197
 226+ 5097 00 7E 00 00
 227+ 509B 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 227+ 509F 54 A8 00 00
 228+ 50A3 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11100000,%11000000,%10000000,%00000000 ; char 199
 228+ 50A7 E0 C0 80 00
 229+ 50AB FE 7C 38 10          defb %11111110,%01111100,%00111000,%00010000,%00000000,%00000000,%00000000,%00000000 ; char 200
 229+ 50AF 00 00 00 00
 230+ 50B3 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00000111,%00000011,%00000001,%00000000 ; char 201
 230+ 50B7 07 03 01 00
 231+ 50BB 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00010000,%00111000,%01111100,%11111110 ; char 202
 231+ 50BF 10 38 7C FE
 232+ 50C3 10 38 7C 10          defb %00010000,%00111000,%01111100,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 203 (up arrow)
 232+ 50C7 10 10 10 00
 233+ 50CB 1E 0E 0E 12          defb %00011110,%00001110,%00001110,%00010010,%00100000,%01000000,%00000000,%00000000 ; char 204 (up right arrow)
 233+ 50CF 20 40 00 00
 234+ 50D3 00 08 0C FE          defb %00000000,%00001000,%00001100,%11111110,%00001100,%00001000,%00000000,%00000000 ; char 205 (right arrow)
 234+ 50D7 0C 08 00 00
 235+ 50DB 00 40 20 12          defb %00000000,%01000000,%00100000,%00010010,%00001110,%00001110,%00011110,%00000000 ; char 206 (down right arrow)
 235+ 50DF 0E 0E 1E 00
 236+ 50E3 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%01111100,%00111000,%00010000,%00000000 ; char 207 (down arrow)
 236+ 50E7 7C 38 10 00
 237+ 50EB 00 04 08 90          defb %00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000,%00000000 ; char 208 (down left arrow)
 237+ 50EF E0 E0 F0 00
 238+ 50F3 00 20 60 FE          defb %00000000,%00100000,%01100000,%11111110,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 238+ 50F7 60 20 00 00
 239+ 50FB F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 239+ 50FF 08 04 00 00
 240+ 5103 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 240+ 5107 F0 44 38 00
 241+ 510B 00 02 7C A8          defb %00000000,%00000010,%01111100,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 241+ 510F 28 28 28 00
 242+ 5113 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001000,%00010000,%00010000,%00010000 ; char 213
 242+ 5117 08 10 10 10
 243+ 511B 00 00 00 C0          defb %00000000,%00000000,%00000000,%11000000,%00100000,%00010000,%00010000,%00010000 ; char 214
 243+ 511F 20 10 10 10
 244+ 5123 10 10 20 C0          defb %00010000,%00010000,%00100000,%11000000,%00000000,%00000000,%00000000,%00000000 ; char 215
 244+ 5127 00 00 00 00
 245+ 512B 10 10 08 07          defb %00010000,%00010000,%00001000,%00000111,%00000000,%00000000,%00000000,%00000000 ; char 216
 245+ 512F 00 00 00 00
 246+ 5133 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001111,%00011100,%00011000,%00011000 ; char 217
 246+ 5137 0F 1C 18 18
 247+ 513B 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00111000,%00011000,%00011000 ; char 218
 247+ 513F F0 38 18 18
 248+ 5143 18 18 38 F0          defb %00011000,%00011000,%00111000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 248+ 5147 E0 00 00 00
 249+ 514B 18 18 1C 0F          defb %00011000,%00011000,%00011100,%00001111,%00000111,%00000000,%00000000,%00000000 ; char 220
 249+ 514F 07 00 00 00
 250+ 5153 00 3C 42 42          defb %00000000,%00111100,%01000010,%01000010,%01000010,%01000010,%00111100,%00000000 ; char 221
 250+ 5157 42 42 3C 00
 251+ 515B 00 3C 7E 7E          defb %00000000,%00111100,%01111110,%01111110,%01111110,%01111110,%00111100,%00000000 ; char 222
 251+ 515F 7E 7E 3C 00
 252+ 5163 00 18 3C 7E          defb %00000000,%00011000,%00111100,%01111110,%01111110,%00111100,%00011000,%00000000 ; char 223
 252+ 5167 7E 3C 18 00
 253+ 516B FF FE FC F8          defb %11111111,%11111110,%11111100,%11111000,%11110000,%11100000,%11000000,%10000000 ; char 224
 253+ 516F F0 E0 C0 80
 254+ 5173 FF 7F 3F 1F          defb %11111111,%01111111,%00111111,%00011111,%00001111,%00000111,%00000011,%00000001 ; char 225
 254+ 5177 0F 07 03 01
 255+ 517B 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00011111,%00111111,%01111111,%11111111 ; char 226
 255+ 517F 1F 3F 7F FF
 256+ 5183 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11111110,%11111111 ; char 227
 256+ 5187 F8 FC FE FF
 257+ 518B 00 02 06 6C          defb %00000000,%00000010,%00000110,%01101100,%01111000,%01110000,%01100000,%00000000 ; char 228 (checkmark)
 257+ 518F 78 70 60 00
 258+ 5193 00 66 3C 18          defb %00000000,%01100110,%00111100,%00011000,%00111100,%01100110,%00000000,%00000000 ; char 229 (x)
 258+ 5197 3C 66 00 00
 259+ 519B 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%00111000,%00010000,%00111000,%00010000 ; char 230 (female)
 259+ 519F 38 10 38 10
 260+ 51A3 07 03 3D 44          defb %00000111,%00000011,%00111101,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 231 (male)
 260+ 51A7 44 44 38 00
 261+ 51AB 78 44 42 42          defb %01111000,%01000100,%01000010,%01000010,%01000010,%01000010,%01000010,%01111110 ; char 232 (new doc)
 261+ 51AF 42 42 42 7E
 262+ 51B3 00 F8 FF 81          defb %00000000,%11111000,%11111111,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 233 (folder)
 262+ 51B7 81 81 81 FF
 263+ 51BB 10 7C FE 54          defb %00010000,%01111100,%11111110,%01010100,%01010100,%01010100,%01010100,%01111100 ; char 234 (trash bin)
 263+ 51BF 54 54 54 7C
 264+ 51C3 FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10111101,%10101101,%10101101,%11111111 ; char 235 (floppy disk)
 264+ 51C7 BD AD AD FF
 265+ 51CB 00 EA AA AC          defb %00000000,%11101010,%10101010,%10101100,%10101100,%10101010,%11101010,%00000000 ; char 236 (OK)
 265+ 51CF AC AA EA 00
 266+ 51D3 18 7E FF 7E          defb %00011000,%01111110,%11111111,%01111110,%01111110,%01100110,%01100110,%01100110 ; char 237 (home)
 266+ 51D7 7E 66 66 66
 267+ 51DB 3C 42 91 91          defb %00111100,%01000010,%10010001,%10010001,%10011101,%10000001,%01000010,%00111100 ; char 238 (clock)
 267+ 51DF 9D 81 42 3C
 268+ 51E3 00 02 05 FD          defb %00000000,%00000010,%00000101,%11111101,%10100101,%10100010,%00000000,%00000000 ; char 239 (key)
 268+ 51E7 A5 A2 00 00
 269+ 51EB 08 0C 3E 4C          defb %00001000,%00001100,%00111110,%01001100,%01001000,%01000010,%01000010,%00111100 ; char 240 (undo)
 269+ 51EF 48 42 42 3C
 270+ 51F3 00 FF C3 A5          defb %00000000,%11111111,%11000011,%10100101,%10011001,%10000001,%11111111,%00000000 ; char 241 (letter)
 270+ 51F7 99 81 FF 00
 271+ 51FB 38 44 44 7C          defb %00111000,%01000100,%01000100,%01111100,%01111100,%01111100,%01111100,%00000000 ; char 242 (lock)
 271+ 51FF 7C 7C 7C 00
 272+ 5203 06 09 09 F8          defb %00000110,%00001001,%00001001,%11111000,%11111000,%11111000,%11111000,%00000000 ; char 243 (unlock)
 272+ 5207 F8 F8 F8 00
 273+ 520B FF FF 81 AD          defb %11111111,%11111111,%10000001,%10101101,%10100101,%10100101,%10000001,%11111111 ; char 244 (calendar)
 273+ 520F A5 A5 81 FF
 274+ 5213 01 1A 24 4A          defb %00000001,%00011010,%00100100,%01001010,%01010010,%00100100,%01011000,%10000000 ; char 245 (diameter)
 274+ 5217 52 24 58 80
 275+ 521B 7E 81 81 81          defb %01111110,%10000001,%10000001,%10000001,%10000001,%01110110,%00001100,%00000100 ; char 246 (baloon)
 275+ 521F 81 76 0C 04
 276+ 5223 0C 0A 0A 0A          defb %00001100,%00001010,%00001010,%00001010,%00001000,%00011000,%00111000,%00010000 ; char 247 (note)
 276+ 5227 08 18 38 10
 277+ 522B 12 31 F5 F5          defb %00010010,%00110001,%11110101,%11110101,%11110101,%11110101,%00110001,%00010010 ; char 248 (audio on)
 277+ 522F F5 F5 31 12
 278+ 5233 10 30 F0 F0          defb %00010000,%00110000,%11110000,%11110000,%11110000,%11110000,%00110000,%00010000 ; char 249 (audio off)
 278+ 5237 F0 F0 30 10
 279+ 523B 40 60 70 78          defb %01000000,%01100000,%01110000,%01111000,%01111100,%01111110,%01111000,%01001000 ; char 250 (pointer)
 279+ 523F 7C 7E 78 48
 280+ 5243 3C 42 99 A1          defb %00111100,%01000010,%10011001,%10100001,%10100001,%10011001,%01000010,%00111100 ; char 251 (Â©)
 280+ 5247 A1 99 42 3C
 281+ 524B 18 24 20 78          defb %00011000,%00100100,%00100000,%01111000,%00100000,%00100010,%01011100,%00000000 ; char 252 (Â£)
 281+ 524F 20 22 5C 00
 282+ 5253 3C 42 78 24          defb %00111100,%01000010,%01111000,%00100100,%00100100,%00011110,%01000010,%00111100 ; char 253 (Â§)
 282+ 5257 24 1E 42 3C
 283+ 525B 00 00 10 00          defb %00000000,%00000000,%00010000,%00000000,%01111100,%00000000,%00010000,%00000000 ; char 254 (Ã·)
 283+ 525F 7C 00 10 00
 284+ 5263 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 255 (cursor)
 284+ 5267 FF FF FF FF
 285+ 526B
# file closed: ../include/vdp/8x8fonts-r18.asm
  83  526B                  INCLUDE "../include/vdp/logo-fonts.asm"
# file opened: ../include/vdp/logo-fonts.asm
   1+ 526B              ; ------------------------------------------------------------------------------
   2+ 526B              ; LM80C - LOGO CHARSET - R1.1
   3+ 526B              ; ------------------------------------------------------------------------------
   4+ 526B              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 526B              ; designed by Leonardo Miliani. More info at
   6+ 526B              ; www DOT leonardomiliani DOT com
   7+ 526B              ; ------------------------------------------------------------------------------
   8+ 526B              ; Code Revision:
   9+ 526B              ; R1.0 - 20200124 - First revision: logo chars
  10+ 526B              ; R1.1 - 20200229 - Adopted usual hexadecimal & binary prefixes
  11+ 526B              ; ------------------------------------------------------------------------------
  12+ 526B
  13+ 526B              LOGOFONT:   equ $
  14+ 526B 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; 0
  14+ 526F 00 00 00 00
  15+ 5273 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; 1
  15+ 5277 FF FF FF FF
  16+ 527B FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; 2
  16+ 527F 00 00 00 00
  17+ 5283 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; 3
  17+ 5287 0F 0F 0F 0F
  18+ 528B 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; 4
  18+ 528F FF FF FF FF
  19+ 5293 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; 5
  19+ 5297 F0 F0 F0 F0
  20+ 529B 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; 6
  20+ 529F 0F 0F 0F 0F
  21+ 52A3 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; 7
  21+ 52A7 F0 F0 F0 F0
  22+ 52AB F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; 8
  22+ 52AF 00 00 00 00
  23+ 52B3 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; 9
  23+ 52B7 00 00 00 00
  24+ 52BB 00 00 00 FC              defb %00000000,%00000000,%00000000,%11111100,%11111111,%00000111,%00000011,%00000000 ; 10
  24+ 52BF FF 07 03 00
  25+ 52C3 00 00 00 3F              defb %00000000,%00000000,%00000000,%00111111,%11111111,%11100000,%11000000,%00000000 ; 11
  25+ 52C7 FF E0 C0 00
  26+ 52CB 18 18 1F 19              defb %00011000,%00011000,%00011111,%00011001,%00011001,%00011111,%00011000,%00011000 ; 12
  26+ 52CF 19 1F 18 18
  27+ 52D3 18 18 F8 98              defb %00011000,%00011000,%11111000,%10011000,%10011000,%11111000,%00011000,%00011000 ; 13
  27+ 52D7 98 F8 18 18
  28+ 52DB 18 18 1C 1F              defb %00011000,%00011000,%00011100,%00011111,%00001111,%00000000,%00000000,%00000000 ; 14
  28+ 52DF 0F 00 00 00
  29+ 52E3 00 00 00 0F              defb %00000000,%00000000,%00000000,%00001111,%00011111,%00011100,%00011000,%00011000 ; 15
  29+ 52E7 1F 1C 18 18
  30+ 52EB 00 00 00 F0              defb %00000000,%00000000,%00000000,%11110000,%11111000,%00111000,%00011000,%00011000 ; 16
  30+ 52EF F8 38 18 18
  31+ 52F3 18 18 38 F8              defb %00011000,%00011000,%00111000,%11111000,%11110000,%00000000,%00000000,%00000000 ; 17
  31+ 52F7 F0 00 00 00
  32+ 52FB 00 00 00 FF              defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; 18
  32+ 52FF FF 00 00 00
  33+ 5303 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%11111111,%11111111,%11111111,%11111111 ; 19
  33+ 5307 FF FF FF FF
  34+ 530B F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11111111,%11111111,%11111111,%11111111 ; 20
  34+ 530F FF FF FF FF
  35+ 5313 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11110000,%11110000,%11110000,%11110000 ; 21
  35+ 5317 F0 F0 F0 F0
  36+ 531B FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00001111,%00001111,%00001111,%00001111 ; 22
  36+ 531F 0F 0F 0F 0F
  37+ 5323 00 30 78 78              defb %00000000,%00110000,%01111000,%01111000,%00110000,%00000000,%00000000,%00000000 ; 23
  37+ 5327 30 00 00 00
  38+ 532B
# file closed: ../include/vdp/logo-fonts.asm
  84  532B
  85  532B              ; include ROM/RAM switcher
  86  532B                  INCLUDE "../include/switcher/switcher-r1.02.asm"
# file opened: ../include/switcher/switcher-r1.02.asm
   1+ 532B              ; ------------------------------------------------------------------------------
   2+ 532B              ; LM80C - ROM/RAM SWITCHER - R1.02
   3+ 532B              ; ------------------------------------------------------------------------------
   4+ 532B              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 532B              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 532B              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 532B              ; kind of warranty: you can use them at your own risk.
   8+ 532B              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 532B              ; maintain the copyright notices, include this advice and the note to the
  10+ 532B              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 532B              ; redistribuite them.
  12+ 532B              ; https://www.leonardomiliani.com
  13+ 532B              ;
  14+ 532B              ; Please support me by visiting the following links:
  15+ 532B              ; Main project page: https://www.leonardomiliani.com
  16+ 532B              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 532B              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 532B              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 532B              ; ------------------------------------------------------------------------------
  20+ 532B              ; Code Revision:
  21+ 532B              ; R1.0   - 20200718 - First version
  22+ 532B              ; R1.1   - 20200827 - PIO settings now are part of the file
  23+ 532B              ; R1.02  - 20210319 - support for LM80C DOS and its repositioning into high-RAM
  24+ 532B              ;-------------------------------------------------------------------------------
  25+ 532B
  26+ 532B              TMP_FW_LOC:     equ     $8000           ; address from where to make a temporary copy of the FW
  27+ 532B              ;-------------------------------------------------------------------------------
  28+ 532B              ; THIS CODE WILL BE EXECUTED FROM RAM
  29+ 532B 3E FC        RAMRUN:         ld      A,%11111100     ; set ROM off and RAM on..
  30+ 532D D3 01                        out     (PIO_DB),A      ; ...by setting bit #0 to 0 (and leave VRAM bank #0)
  31+ 532F 01 7A 53                     ld      BC,END_OF_FW    ; let's copy back FW into low RAM - bytes to copy
  32+ 5332 21 00 80                     ld      HL,TMP_FW_LOC   ; source address
  33+ 5335 11 00 00                     ld      DE,$0000        ; dest. address
  34+ 5338 ED B0                        ldir                    ; copy!
  35+ 533A AF                           xor     A
  36+ 533B D3 01                        out     (PIO_DB),A      ; all LEDs off - finished copying
  37+ 533D C3 AE 02                     jp      INIT_HW         ; return control to old init (now into RAM)
  38+ 5340
  39+ 5340              ;-------------------------------------------------------------------------------
  40+ 5340              ; copy the whole contents of ROM into RAM then disable the first memory
  41+ 5340 3A D7 53     ROM2RAM:        ld      A,(basicStarted); check if BASIC is already started
  42+ 5343 FE 59                        cp      'Y'             ; to see if this is a power-up
  43+ 5345 20 0F                        jr      NZ,CNTCP2RAM    ; no, continue copy to RAM
  44+ 5347                              ; WARNING: Do **NOT** change the following "out()" sequence, ABSOLUTELY!
  45+ 5347 3E CF                        ld      A,%11001111     ; set mode 3 ("control mode")
  46+ 5349 D3 03                        out     (PIO_CB),A      ; for PIO port B
  47+ 534B AF                           xor     A               ; set LEDs off, RAM on, VRAM on bank #0
  48+ 534C D3 01                        out     (PIO_DB),A      ; send settings to PIO register
  49+ 534E D3 03                        out     (PIO_CB),A      ; set pins following register's status
  50+ 5350 21 09 55                     ld      HL,TEMPSTACK    ; temporary stack
  51+ 5353 C3 B1 02                     jp      INIT_HW2        ; jump to re-init HW
  52+ 5356
  53+ 5356                              ; WARNING: Do **NOT** change the following "out()" sequence, ABSOLUTELY!
  54+ 5356 3E CF        CNTCP2RAM:      ld      A,%11001111     ; set mode 3 (mode control)
  55+ 5358 D3 03                        out     (PIO_CB),A      ; for PIO port B
  56+ 535A 3E FD                        ld      A,%11111101     ; set pin #0 as HIGH to enable ROM
  57+ 535C D3 01                        out     (PIO_DB),A      ; store the value into the internal register
  58+ 535E AF                           xor     A               ; set pins to OUTPUT
  59+ 535F D3 03                        out     (PIO_CB),A      ; for port B, activating the RAM
  60+ 5361                              ; copy DOS
  61+ 5361 01 90 11                     ld      BC,$FFFF-DOSSTART+1 ; bytes to copy
  62+ 5364 21 7A 53                     ld      HL,END_OF_FW    ; load DOS from its original location and...
  63+ 5367 11 70 EE                     ld      DE,DOSSTART     ; ...store it into its portion of memory
  64+ 536A ED B0                        ldir                    ; copy!
  65+ 536C                              ; copy BASIC
  66+ 536C 01 7A 53                     ld      BC,END_OF_FW    ; copy FW from ROM to high RAM
  67+ 536F 21 00 00                     ld      HL,$0000        ; source address
  68+ 5372 11 00 80                     ld      DE,TMP_FW_LOC   ; dest. address
  69+ 5375 ED B0                        ldir                    ; copy!
  70+ 5377 C3 2B D3                     jp      RAMRUN+TMP_FW_LOC; jump to execute code into RAM
  71+ 537A
  72+ 537A              ;-------------------------------------------------------------------------------
  73+ 537A              END_OF_FW:      equ     $   ; this is the last cell of the firmware
# file closed: ../include/switcher/switcher-r1.02.asm
  87  537A
  88  537A              ; include workspace equates
  89  537A                  INCLUDE "../include/workspace/workspace-r1.02.asm"
# file opened: ../include/workspace/workspace-r1.02.asm
   1+ 537A              ; ------------------------------------------------------------------------------
   2+ 537A              ; LM80C 64K - WORKSPACE EQUATES - R1.02
   3+ 537A              ; ------------------------------------------------------------------------------
   4+ 537A              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 537A              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 537A              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 537A              ; kind of warranty: you can use them at your own risk.
   8+ 537A              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 537A              ; maintain the copyright notices, include this advice and the note to the
  10+ 537A              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 537A              ; redistribuite them.
  12+ 537A              ; https://www.leonardomiliani.com
  13+ 537A              ;
  14+ 537A              ; Please support me by visiting the following links:
  15+ 537A              ; Main project page: https://www.leonardomiliani.com
  16+ 537A              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 537A              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 537A              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 537A              ; ------------------------------------------------------------------------------
  20+ 537A
  21+ 537A              ; set starting of RAM based on computer model
  22+ 537A              SERBUF_START    equ     END_OF_FW       ; RAM starts here
  23+ 537A
  24+ 537A              ;-------------------------------------------------------------------------------
  25+ 537A              serInPtr        equ     SERBUF_START + SER_BUFSIZE
  26+ 537A              serRdPtr        equ     serInPtr+2
  27+ 537A              serBufUsed      equ     serRdPtr+2
  28+ 537A              basicStarted    equ     serBufUsed+1
  29+ 537A              bufWrap         equ     (SERBUF_START + SER_BUFSIZE) & $FF
  30+ 537A              TEMPSTACK       equ     CURPOS - 3      ; top of BASIC line input buffer so is "free ram" when BASIC resets
  31+ 537A
  32+ 537A              ; BASIC WORK SPACE LOCATIONS
  33+ 537A              ; THE INTERPRETER ALLOCATES THE FOLLOWING RAM CELLS
  34+ 537A              ; TO STORE IMPORTANT VALUES USED FOR SOME SPECIFIC FUNCTIONS:
  35+ 537A              ; THEY CAN BE VECTOR (ADDRESSES) FUNCTIONS, SYSTEM DATAS (I.E. VARIABLES)
  36+ 537A              ; AND SO ON. THE FIRST CELLS ARE FILLED WITH VALUES STORED INTO ROM AT $(INITAB) ADDRESS
  37+ 537A              WRKSPC          equ     basicStarted+$01; (3) BASIC Work space
  38+ 537A              NMIUSR          equ     WRKSPC+$03      ; (3) NMI exit point routine
  39+ 537A              USR             equ     NMIUSR+$03      ; (3) "USR (x)" jump  <-- in (USR+$01)/(USR+$02) the user can store the address of a specific machine language routine
  40+ 537A              OUTSUB          equ     USR+$03         ; (1) "out p,n"
  41+ 537A              OTPORT          equ     OUTSUB+$01      ; (2) Port (p)
  42+ 537A              DIVSUP          equ     OTPORT+$02      ; (1) Division support routine
  43+ 537A              DIV1            equ     DIVSUP+$01      ; (4) <- Values
  44+ 537A              DIV2            equ     DIV1+$04        ; (4) <-   to
  45+ 537A              DIV3            equ     DIV2+$04        ; (3) <-   be
  46+ 537A              DIV4            equ     DIV3+$03        ; (2) <-inserted
  47+ 537A              SEED            equ     DIV4+$02        ; (35) Random number seed  <-- starting address of a seed table
  48+ 537A              LSTRND          equ     SEED+$23        ; (4) Last random number
  49+ 537A              INPSUB          equ     LSTRND+$04      ; (1) INP A,(x) Routine
  50+ 537A              INPORT          equ     INPSUB+$01      ; (2) PORT (x)
  51+ 537A              LWIDTH          equ     INPORT+$02      ; (1) Terminal width
  52+ 537A              COMMAN          equ     LWIDTH+$01      ; (1) Width for commas
  53+ 537A              NULFLG          equ     COMMAN+$01      ; (1) Null after input byte flag
  54+ 537A              CTLOFG          equ     NULFLG+$01      ; (1) Control "O" flag
  55+ 537A              CHKSUM          equ     CTLOFG+$01      ; (2) Array load/save check sum
  56+ 537A              NMIFLG          equ     CHKSUM+$02      ; (1) Flag for NMI break routine
  57+ 537A              BRKFLG          equ     NMIFLG+$01      ; (1) Break flag
  58+ 537A              RINPUT          equ     BRKFLG+$01      ; (3) Input reflection
  59+ 537A              STRSPC          equ     RINPUT+$03      ; (2) Pointer to bottom (start) of string space - default is 100 bytes below the top of memory
  60+ 537A              LINEAT          equ     STRSPC+$02      ; (2) Current line number. -1 means "direct mode", while -2 means cold start.
  61+ 537A              HLPLN           equ     LINEAT+$02      ; (2) Current line with errors
  62+ 537A              KEYDEL          equ     HLPLN+$02       ; (1) delay before key auto-repeat starts
  63+ 537A              AUTOKE          equ     KEYDEL+$01      ; (1) delay for key auto-repeat
  64+ 537A              FNKEYS          equ     AUTOKE+$01      ; (128) default text of FN keys
  65+ 537A              BASTXT          equ     FNKEYS+$80      ; (3) Pointer to start of BASIC program in memory
  66+ 537A              ; - - - - - - - - - - - - - - - - - - -   the above are locations pre-filled by the firmware at startup
  67+ 537A              BUFFER          equ     BASTXT+$03      ; (5) Input buffer
  68+ 537A              STACK           equ     BUFFER+$05      ; (85) Initial stack
  69+ 537A              CURPOS          equ     STACK+$55       ; (1) Character position on line
  70+ 537A              LCRFLG          equ     CURPOS+$01      ; (1) Locate/Create flag for DIM statement
  71+ 537A              TYPE            equ     LCRFLG+$01      ; (1) Data type flag: 0=numeric, non-zero=string
  72+ 537A              DATFLG          equ     TYPE+$01        ; (1) Literal statement flag
  73+ 537A              LSTRAM          equ     DATFLG+$01      ; (2) Last available RAM location for BASIC
  74+ 537A              DOSER           equ     LSTRAM+$02      ; (1) Error from DOS
  75+ 537A              TMPDBF          equ     DOSER+$01       ; (36) Secondary buffer for DOS
  76+ 537A              TMSTPT          equ     TMPDBF+$24      ; (2) Temporary string pointer
  77+ 537A              TMSTPL          equ     TMSTPT+$02      ; (12) Temporary string pool
  78+ 537A              TMPSTR          equ     TMSTPL+$0C      ; (4) Temporary string
  79+ 537A              STRBOT          equ     TMPSTR+$04      ; (2) Bottom of string space
  80+ 537A              CUROPR          equ     STRBOT+$02      ; (2) Current operator in EVAL
  81+ 537A              LOOPST          equ     CUROPR+$02      ; (2) First statement of loop
  82+ 537A              DATLIN          equ     LOOPST+$02      ; (2) Line of current DATA item
  83+ 537A              FORFLG          equ     DATLIN+$02      ; (1) "FOR" loop flag
  84+ 537A              LSTBIN          equ     FORFLG+$01      ; (1) Last byte entered
  85+ 537A              READFG          equ     LSTBIN+$01      ; (1) Read/Input flag
  86+ 537A              BRKLIN          equ     READFG+$01      ; (2) Line of break
  87+ 537A              NXTOPR          equ     BRKLIN+$02      ; (2) Next operator in EVAL
  88+ 537A              ERRLIN          equ     NXTOPR+$02      ; (2) Line of error
  89+ 537A              CONTAD          equ     ERRLIN+$02      ; (2) Where to CONTinue
  90+ 537A              TMRCNT          equ     CONTAD+$02      ; (4) TMR counter for 1/100 seconds
  91+ 537A              CTC0IV          equ     TMRCNT+$04      ; (3) CTC0 interrupt vector
  92+ 537A              CTC1IV          equ     CTC0IV+$03      ; (3) CTC1 interrupt vector
  93+ 537A              CTC2IV          equ     CTC1IV+$03      ; (3) CTC2 interrupt vector
  94+ 537A              CTC3IV          equ     CTC2IV+$03      ; (3) CTC3 interrupt vector
  95+ 537A              ; - - - - - - - - - - - - - - - - - - -   VIDEO REGISTERS - FROM HERE...
  96+ 537A              SCR_SIZE_W      equ     CTC3IV+$03      ; (1) screen width (it can be either 40 chars or 32 chars/bytes)
  97+ 537A              SCR_SIZE_H      equ     SCR_SIZE_W+$01  ; (1) screen height (it can be 24/48/192: 24 for text, 48 for MC, 192 for graphics)
  98+ 537A              SCR_MODE        equ     SCR_SIZE_H+$01  ; (1) screen mode (0=text, 1=G1, 2=G2, 3=MC, 4=ExG2)
  99+ 537A              SCR_NAM_TB      equ     SCR_MODE+$01    ; (2) video name table address
 100+ 537A              SCR_CURS_X      equ     SCR_NAM_TB+$02  ; (1) cursor X
 101+ 537A              SCR_CURS_Y      equ     SCR_CURS_X+$01  ; (1) cursor Y
 102+ 537A              SCR_CUR_NX      equ     SCR_CURS_Y+$01  ; (1) new cursor X position
 103+ 537A              SCR_CUR_NY      equ     SCR_CUR_NX+$01  ; (1) new cursor Y position
 104+ 537A              SCR_ORG_CHR     equ     SCR_CUR_NY+$01  ; (1) original char positioned under the cursor
 105+ 537A              CRSR_STATE      equ     SCR_ORG_CHR+$01 ; (1) state of cursor (1=on, 0=off)
 106+ 537A              LSTCSRSTA       equ     CRSR_STATE+$01  ; (1) last cursor state
 107+ 537A              PRNTVIDEO       equ     LSTCSRSTA+$01   ; (1) print on video buffer (1=on / 0=off) set to off on graphic only modes
 108+ 537A              CHR4VID         equ     PRNTVIDEO+$01   ; (1) char for video buffer
 109+ 537A              FRGNDCLR        equ     CHR4VID+$01     ; (1) foreground color as set by SCREEN or COLOR commands
 110+ 537A              BKGNDCLR        equ     FRGNDCLR+$01    ; (1) background color as set by SCREEN or COLOR commands
 111+ 537A              TMPBFR1         equ     BKGNDCLR+$01    ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 112+ 537A              TMPBFR2         equ     TMPBFR1+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 113+ 537A              TMPBFR3         equ     TMPBFR2+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 114+ 537A              TMPBFR4         equ     TMPBFR3+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 115+ 537A              VIDEOBUFF       equ     TMPBFR4+$02     ; (40) buffer used for video scrolling and other purposes
 116+ 537A              VIDTMP1         equ     VIDEOBUFF+$28   ; (2) temporary video word
 117+ 537A              VIDTMP2         equ     VIDTMP1+$02     ; (2) temporary video word
 118+ 537A              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO VPD OUT OF THIS RANGE,
 119+ 537A                                                      ; OTHERWISE YOU WILL HAVE TO CHECK THE POINTER IN "CLR_RAM_REG" FUNCTION
 120+ 537A              ; - - - - - - - - - - - - - - - - - - -   SOUND & KEYBOARD REGISTERS - FROM HERE...
 121+ 537A              CHASNDDTN       equ     VIDTMP2+$02     ; (2) sound Ch.A duration (in 1/100s)
 122+ 537A              CHBSNDDTN       equ     CHASNDDTN+$02   ; (2) sound Ch.B duration (in 1/100s)
 123+ 537A              CHCSNDDTN       equ     CHBSNDDTN+$02   ; (2) sound Ch.C duration (in 1/100s)
 124+ 537A              KBDNPT          equ     CHCSNDDTN+$02   ; (1) temp cell used to flag if input comes from keyboard
 125+ 537A              KBTMP           equ     KBDNPT+$01      ; (1) temp cell used by keyboard scanner
 126+ 537A              TMPKEYBFR       equ     KBTMP+$01       ; (1) temp buffer for last key pressed
 127+ 537A              LASTKEYPRSD     equ     TMPKEYBFR+$01   ; (1) last key code pressed
 128+ 537A              STATUSKEY       equ     LASTKEYPRSD+$01 ; (1) status key, used for auto-repeat
 129+ 537A              KEYTMR          equ     STATUSKEY+$01   ; (2) timer used for auto-repeat key
 130+ 537A              CONTROLKEYS     equ     KEYTMR+$02      ; (1) flags for control keys (bit#0=SHIFT; bit#1=CTRL; bit#2=C=)
 131+ 537A              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO PSG OUT OF THIS RANGE,
 132+ 537A                                                      ; OTHERWISE YOU WILL HAVE TO CHANGE THE POINTER IN "initPSG" FUNCTION
 133+ 537A              SERIALS_EN      equ     CONTROLKEYS+$01 ; (1) serial ports status: bit 0 for Port1 (A), bit 1 for Port2 (B): 0=OFF, 1=ON
 134+ 537A              SERABITS        equ     SERIALS_EN+$01  ; (1) serial port A data bits
 135+ 537A              SERBBITS        equ     SERABITS+$01    ; (1) serial port B data bits
 136+ 537A              DOS_EN          equ     SERBBITS+$01    ; (1) DOS enable/disable (1/0)
 137+ 537A              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 138+ 537A                                                      ; from here there are the RAM locations that
 139+ 537A                                                      ; are saved during SAVE
 140+ 537A              PROGND          equ     DOS_EN+$01      ; (2) End of program
 141+ 537A              VAREND          equ     PROGND+$02      ; (2) End of variables
 142+ 537A              ARREND          equ     VAREND+$02      ; (2) End of arrays
 143+ 537A              NXTDAT          equ     ARREND+$02      ; (2) Next data item
 144+ 537A              FNRGNM          equ     NXTDAT+$02      ; (2) Name of FN argument
 145+ 537A              FNARG           equ     FNRGNM+$02      ; (4) FN argument value
 146+ 537A              FPREG           equ     FNARG+$04       ; (3) Floating point register
 147+ 537A              FPEXP           equ     FPREG+$03       ; (1) Floating point exponent
 148+ 537A              SGNRES          equ     FPEXP+$01       ; (1) Sign of result
 149+ 537A              PBUFF           equ     SGNRES+$01      ; (13) Number print buffer
 150+ 537A              MULVAL          equ     PBUFF+$0D       ; (3) Multiplier
 151+ 537A              PROGST          equ     MULVAL+$03      ; (100) Start of program text area
 152+ 537A              STLOOK          equ     PROGST+$64      ; Start of memory test
 153+ 537A
# file closed: ../include/workspace/workspace-r1.02.asm
  90  537A
  91  537A              ; include the latest versions of the CF & DOS modules
  92  537A              ; do NOT move these files from this position and
  93  537A              ; do NOT alter their order!
  94  537A                  INCLUDE "../include/dos/dos-1.05.asm"
# file opened: ../include/dos/dos-1.05.asm
   1+ 537A              ; ------------------------------------------------------------------------------
   2+ 537A              ; LM80C 64K - DOS ROUTINES - R1.05
   3+ 537A              ; ------------------------------------------------------------------------------
   4+ 537A              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 537A              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 537A              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 537A              ; kind of warranty: you can use them at your own risk.
   8+ 537A              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 537A              ; maintain the copyright notices, include this advice and the note to the
  10+ 537A              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 537A              ; redistribuite them.
  12+ 537A              ; https://www.leonardomiliani.com
  13+ 537A              ;
  14+ 537A              ; Please support me by visiting the following links:
  15+ 537A              ; Main project page: https://www.leonardomiliani.com
  16+ 537A              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 537A              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 537A              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 537A              ; ------------------------------------------------------------------------------
  20+ 537A              ;
  21+ 537A              ; ------------------------------------------------------------------------------
  22+ 537A              ; Code Revision:
  23+ 537A              ; R1.0  - 20210306 - first release
  24+ 537A              ; R1.01 - 20210309 - code cleaning & optimization - new behaviour for ERASE (full erase everything)
  25+ 537A              ; R1.02 - 20210310 - code optimization - new UNDELETE feature for DISK statement
  26+ 537A              ; R1.03 - 2021xxxx - code size enhancements
  27+ 537A              ; R1.04 - 20210319 - code re-organization and new positioning into RAM
  28+ 537A              ; R1.05 - 20210327 - added support for sequential files
  29+ 537A              ;
  30+ 537A              ;------------------------------------------------------------------------------
  31+ 537A
  32+ 537A
  33+ 537A                          org     $EE70
  34+ EE70
  35+ EE70              DOSSTART:   equ     $
  36+ EE70 4C 4D 38 30  DSKHDR      defb    "LM80C DOS",$00,"1.05",$00     ; disk header
  36+ EE74 43 20 44 4F
  36+ EE78 53 00 31 2E
  36+ EE7C 30 35 00
  37+ EE7F 00 01        DSKDIRADR:  defb    $00,$01                         ; 1st sector of directory ($0001)
  38+ EE81
  39+ EE81              DIR_STRT:   equ     TMPDBF          ; (2) start of directory
  40+ EE81              DAT_STRT:   equ     DIR_STRT+$02    ; (2) start of DATA area
  41+ EE81              DIR_SCT:    equ     DAT_STRT+$02    ; (2) sector of first free entry in the directory
  42+ EE81              NTR_NBR:    equ     DIR_SCT+$02     ; (2) number of free entry
  43+ EE81              BYT_SIZ:    equ     NTR_NBR+$02     ; (2) file size in bytes
  44+ EE81              SCT_SIZ:    equ     BYT_SIZ+$02     ; (1) file size in sectors
  45+ EE81              MSW_SCT:    equ     SCT_SIZ+$01     ; (2) MSW sector of file
  46+ EE81              LSW_SCT:    equ     MSW_SCT+$02     ; (2) LSW sector of file
  47+ EE81              RAM_PTR:    equ     LSW_SCT+$02     ; (2) pointer to RAM
  48+ EE81              TPBF1:      equ     RAM_PTR+$02     ; (2) temp. word
  49+ EE81              TPBF2:      equ     TPBF1+$02       ; (2) temp. word
  50+ EE81              TPBF3:      equ     TPBF2+$02       ; (2) temp. word
  51+ EE81              TPBF4:      equ     TPBF3+$02       ; (2) temp. word
  52+ EE81              SRTMEM:     equ     TPBF4+$02       ; (2) temp. word
  53+ EE81              ENDMEM:     equ     SRTMEM+$02      ; (2) temp. word
  54+ EE81
  55+ EE81
  56+ EE81              ; **************************************************************************************
  57+ EE81              ;                            B A S I C    I N T E R F A C E
  58+ EE81              ;***************************************************************************************
  59+ EE81
  60+ EE81              ; OPEN a sequential file
  61+ EE81              ; OPEN "filename",flnm,mod = open file "filename" with #flnm for READ (mod=0) or WRITE (mod=1)
  62+ EE81 CD EF F1     OPEN:   call    CHKFLNM         ; check if a string follows
  63+ EE84 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
  64+ EE87 2C                   defb    ','
  65+ EE88 CD 70 2A             call    GETINT          ; get file number
  66+ EE8B 32 13 55             ld      (TMPDBF),A      ; store it into a temp buffer
  67+ EE8E CD 10 1B             call    CHKSYN          ; Make sure ',' follows
  68+ EE91 2C                   defb    ','
  69+ EE92 CD 70 2A             call    GETINT          ; get mode
  70+ EE95 FE 02                cp      $02             ; 0 or 1?
  71+ EE97 D2 24 1E             jp      NC,FCERR        ; no, illegal function call
  72+ EE9A 32 14 55             ld      (TMPDBF+1),A    ; store it into a temp buffer
  73+ EE9D 2B                   dec     HL              ; dec 'cos GETCHR INCs
  74+ EE9E CD 59 1D             call    GETCHR          ; check if something follows
  75+ EEA1 C2 10 18             jp      NZ,SNERR        ; if something more, raise a syntax error
  76+ EEA4 E5                   push    HL              ; store code string pointer
  77+ EEA5 CD E9 F3             call    OPNFIL          ; call open file
  78+ EEA8 E1                   pop     HL              ; retrieve code string pointer
  79+ EEA9 DA 38 F0             jp      C,DOS_ERR       ; any error?
  80+ EEAC C9                   ret                     ; return to caller
  81+ EEAD
  82+ EEAD
  83+ EEAD              ; CLOSE a file
  84+ EEAD CD 70 2A     CLOSE:  call    GETINT          ; look for a number
  85+ EEB0 32 13 55             ld      (TMPDBF),A      ; store file number
  86+ EEB3 E5                   push    HL              ; store code string pointer
  87+ EEB4 CD F3 F4             call    CLOSFIL         ; close an open file
  88+ EEB7 E1                   pop     HL              ; retrieve code string pointer
  89+ EEB8 DA 38 F0             jp      C,DOS_ERR
  90+ EEBB C9                   ret                     ; return to caller
  91+ EEBC
  92+ EEBC
  93+ EEBC              ; LOAD "filename"[,1]  <- load a BASIC program from disk
  94+ EEBC              ; LOAD x,y,w,z         <- load a sector from disc, LBA address equals to ((((z*256)+w)*256)+y)*256)+x
  95+ EEBC CD 0F EF     LOAD:   call    LDSVPT          ; check what's following
  96+ EEBF CA DD EE             jp      Z,LOADST        ; number - load a single sector
  97+ EEC2 CD 81 3E             call    DIRMOD          ; a file can be loaded ONLY in direct mode
  98+ EEC5 C2 25 18             jp      NZ,IMERR        ; raise error if in indirect mode
  99+ EEC8 CD F9 F1             call    CHKFN1          ; string - evaluate file name
 100+ EECB CD 3F F0             call    CHK1AR          ; check for ",1" argument
 101+ EECE 22 7C 55             ld      (TMPBFR1),HL    ; store HL
 102+ EED1 21 FE EE             ld      HL,TXTLDG       ; loading message
 103+ EED4 CD F2 26             call    PRS             ; print
 104+ EED7 CD 72 F9             call    LODFILE         ; load file into memory
 105+ EEDA C3 F2 EE             jp      LDEND           ; retrieve registers and leave
 106+ EEDD 2A 7C 55     LOADST: ld      HL,(TMPBFR1)    ; retrieve HL
 107+ EEE0 CD 21 EF             call    GET4AR          ; get 4 arguments
 108+ EEE3 22 7C 55             ld      (TMPBFR1),HL    ; store HL
 109+ EEE6 CD 0D FD             call    CF_SETSTR       ; set sector
 110+ EEE9 CD 4F FD             call    CF_RD_SEC       ; read sector
 111+ EEEC 38 0B                jr      C,LDERR         ; load error?
 112+ EEEE CD 43 FD             call    CF_STANDBY      ; put CF in standby mode
 113+ EEF1 AF                   xor     A               ; clear Carry
 114+ EEF2 2A 7C 55     LDEND:  ld      HL,(TMPBFR1)    ; retrieve HL
 115+ EEF5 DA 38 F0             jp      C,DOS_ERR       ; jump if DOS error
 116+ EEF8 C9                   ret                     ; return to caller
 117+ EEF9 1E 40        LDERR:  ld      E,D4            ; load error
 118+ EEFB C3 2A 18             jp      ERROR
 119+ EEFE 4C 6F 61 64  TXTLDG: defb    "Loading file... ",0
 119+ EF02 69 6E 67 20
 119+ EF06 66 69 6C 65
 119+ EF0A 2E 2E 2E 20
 119+ EF0E 00
 120+ EF0F
 121+ EF0F
 122+ EF0F              ; common code for LOAD/SAVE to check the type of operation required
 123+ EF0F              ; (load/save a file or a single sector)
 124+ EF0F              ; returns Z if argument is a number, NZ if it's a string
 125+ EF0F 2B           LDSVPT: dec     HL              ; dec 'cos GETCHR INCs
 126+ EF10 CD 59 1D             call    GETCHR          ; check if something follows
 127+ EF13 CA 10 18             jp      Z,SNERR         ; if anything else, raise a syntax error
 128+ EF16 22 7C 55             ld      (TMPBFR1),HL    ; save current code string pointer
 129+ EF19 CD FC 21             call    EVAL            ; Evaluate expression
 130+ EF1C 3A 0E 55             ld      A,(TYPE)        ; Get variable type
 131+ EF1F B7                   or      A               ; Is it a string variable?
 132+ EF20 C9                   ret                     ; return to caller
 133+ EF21
 134+ EF21
 135+ EF21              ; shared code between LOAD and SAVE
 136+ EF21              ; get 4 arguments after the command LOAD or SAVE
 137+ EF21              ; and load them into appropriate registers
 138+ EF21 2A 7C 55     GET4AR: ld      HL,(TMPBFR1)    ; retrieve string code pointer
 139+ EF24 CD 70 2A             call    GETINT          ; get 1st pointer
 140+ EF27 32 13 55             ld      (TMPDBF),A      ; store it into a temp buffer
 141+ EF2A CD 10 1B             call    CHKSYN          ; Make sure ',' follows
 142+ EF2D 2C                   defb    ','
 143+ EF2E CD 70 2A             call    GETINT          ; get 2nd pointer
 144+ EF31 32 14 55             ld      (TMPDBF+1),A    ; store it into a temp buffer
 145+ EF34 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
 146+ EF37 2C                   defb    ','
 147+ EF38 CD 70 2A             call    GETINT          ; get 3rd pointer
 148+ EF3B 32 15 55             ld      (TMPDBF+2),A    ; store it into a temp buffer
 149+ EF3E CD 10 1B             call    CHKSYN          ; Make sure ',' follows
 150+ EF41 2C                   defb    ','
 151+ EF42 CD 70 2A             call    GETINT          ; get 4th pointer
 152+ EF45 57                   ld      D,A             ; store it
 153+ EF46 3A 13 55             ld      A,(TMPDBF)      ; retrieve 1st pointer
 154+ EF49 4F                   ld      C,A
 155+ EF4A 3A 14 55             ld      A,(TMPDBF+1)    ; retrieve 2nd pointer
 156+ EF4D 47                   ld      B,A
 157+ EF4E 3A 15 55             ld      A,(TMPDBF+2)    ; retrieve 3rd pointer
 158+ EF51 5F                   ld      E,A
 159+ EF52 CD CB FC             call    CF_INIT         ; init CF card
 160+ EF55 DA 28 18             jp      C,NRERR         ; error if device not available/ready
 161+ EF58 C9                   ret                     ; return to caller
 162+ EF59
 163+ EF59
 164+ EF59              ; save a file onto the disk
 165+ EF59              ; syntax: save "filename" to save a BASIC program
 166+ EF59              ; save x,y,z to save IO buffer into x-y-z sector
 167+ EF59              ; save "filename",start,end to save a portion of memory
 168+ EF59 2B           SAVE:   dec     HL              ; dec 'cos GETCHR INCs
 169+ EF5A CD 59 1D             call    GETCHR          ; check if something follows
 170+ EF5D CA 10 18             jp      Z,SNERR         ; if nothing else, raise a syntax error
 171+ EF60 22 7C 55             ld      (TMPBFR1),HL    ; save current code string pointer
 172+ EF63 CD FC 21             call    EVAL            ; Evaluate expression
 173+ EF66 3A 0E 55             ld      A,(TYPE)        ; Get variable type
 174+ EF69 B7                   or      A               ; Is it a string variable?
 175+ EF6A CA C8 EF             jp      Z,SAVESCT       ; no - save a single sector
 176+ EF6D CD F9 F1             call    CHKFN1          ; yes, load string name
 177+ EF70 ED 53 82 55          ld      (TMPBFR4),DE    ; store lenght into another buffer
 178+ EF74 ED 43 2C 55          ld      (TPBF4+2),BC    ; store address into another buffer
 179+ EF78 3E 80                ld      A,$80           ; set BAS as file type
 180+ EF7A 32 2A 55             ld      (TPBF4),A
 181+ EF7D 2B                   dec     HL              ; dec 'cos GETCHR INCs
 182+ EF7E CD 59 1D             call    GETCHR          ; check if something follows
 183+ EF81 28 30                jr      Z,SAVE1         ; no, jump over
 184+ EF83 CD 10 1B             call    CHKSYN          ; yes - Make sure ',' follows
 185+ EF86 2C                   defb    ','
 186+ EF87 22 13 55             ld      (TMPDBF),HL     ; store code string pointer
 187+ EF8A CD FC 21             call    EVAL            ; check expression
 188+ EF8D 2A 13 55             ld      HL,(TMPDBF)     ; point back to the beginning of epression
 189+ EF90 3A 0E 55             ld      A,(TYPE)        ; check result type
 190+ EF93 B7                   or      A               ; is it another string?
 191+ EF94 20 4B                jr      NZ,RENFIL       ; yes, jump to rename file
 192+ EF96 CD EA 21             call    GETNUM          ; no, this is the memory address for a BIN file
 193+ EF99 CD 0F 1E             call    DEINT           ; Get integer -32768 to 32767
 194+ EF9C ED 53 2C 55          ld      (SRTMEM),DE     ; Store DE into a temp. buffer
 195+ EFA0 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
 196+ EFA3 2C                   defb    ','
 197+ EFA4 CD EA 21             call    GETNUM          ; Get memory address
 198+ EFA7 CD 0F 1E             call    DEINT           ; Get integer -32768 to 32767
 199+ EFAA ED 53 2E 55          ld      (ENDMEM),DE     ; Store DE into a temp. buffer
 200+ EFAE 3E 81                ld      A,$81           ; set BIN for file type
 201+ EFB0 32 2A 55             ld      (TPBF4),A
 202+ EFB3 CD 81 3E     SAVE1:  call    DIRMOD          ; can be executed ONLY in direct mode
 203+ EFB6 C2 25 18             jp      NZ,IMERR        ; raise error if in indirect mode
 204+ EFB9 22 7C 55             ld      (TMPBFR1),HL    ; store code string pointer
 205+ EFBC 21 14 F0             ld      HL,TXTSVG       ; loading message
 206+ EFBF CD F2 26             call    PRS             ; print
 207+ EFC2 CD A8 F7             call    SAVFILE         ; load file into memory
 208+ EFC5 C3 DA EF             jp      SVEND           ; retrieve registers and leave
 209+ EFC8                      ;save a single sector
 210+ EFC8 2A 13 55     SAVESCT:ld      HL,(TMPDBF)     ; retrieve string code pointer
 211+ EFCB CD 21 EF             call    GET4AR          ; get 4 arguments
 212+ EFCE 22 7C 55             ld      (TMPBFR1),HL    ; store code string pointer
 213+ EFD1 CD 76 FD             call    CF_WR_SEC       ; read sector
 214+ EFD4 38 39                jr      C,SVERR
 215+ EFD6 CD 43 FD             call    CF_STANDBY      ; put CF in standby mode
 216+ EFD9 AF                   xor     A               ; clear Carry
 217+ EFDA 2A 7C 55     SVEND:  ld      HL,(TMPBFR1)    ; retrieve code string pointer
 218+ EFDD DA 38 F0             jp      C,DOS_ERR       ; jump if DOS error
 219+ EFE0 C9                   ret                     ; return to caller
 220+ EFE1 CD 35 28     RENFIL: call    GSTRCU          ; check that a string follows
 221+ EFE4 CD 46 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
 222+ EFE7 ED 53 1B 55          ld      (BYT_SIZ),DE    ; store values into
 223+ EFEB ED 43 22 55          ld      (RAM_PTR),BC    ; temp buffers
 224+ EFEF E5                   push    HL              ; store code string pointer
 225+ EFF0 21 FE EF             ld      HL,TXTRNM       ; point to "renaming file"
 226+ EFF3 CD F2 26             call    PRS             ; print string
 227+ EFF6 CD DE F8             call    CHNGNAM         ; rename file
 228+ EFF9 E1                   pop     HL              ; retrieve code string pointer
 229+ EFFA DA 38 F0             jp      C,DOS_ERR       ; any error?
 230+ EFFD C9                   ret                     ; return to caller
 231+ EFFE 52 65 6E 61  TXTRNM: defb    "Renaming file...",0
 231+ F002 6D 69 6E 67
 231+ F006 20 66 69 6C
 231+ F00A 65 2E 2E 2E
 231+ F00E 00
 232+ F00F 1E 3E        SVERR:  ld      E,D3            ; save error
 233+ F011 C3 2A 18             jp      ERROR
 234+ F014 53 61 76 69  TXTSVG: defb    "Saving file... ",0
 234+ F018 6E 67 20 66
 234+ F01C 69 6C 65 2E
 234+ F020 2E 2E 20 00
 235+ F024
 236+ F024
 237+ F024              ; FILES
 238+ F024              ; list files on disk
 239+ F024 CD 9E FC     FILES:  call    CLRIOBF         ; clear I/O buffer
 240+ F027 CD CB FC             call    CF_INIT         ; init CF card
 241+ F02A DA 38 F0             jp      C,DOS_ERR       ; error if device not available/ready
 242+ F02D E5                   push    HL              ; store code string pointer
 243+ F02E 16 01                ld      D,$01           ; print disk details and file list
 244+ F030 CD 6B F6             call    LST_FILES       ; list files
 245+ F033 E1                   pop     HL              ; retrieve code string pointer
 246+ F034 DA 38 F0             jp      C,DOS_ERR       ; any error?
 247+ F037 C9                   ret                     ; return to caller
 248+ F038
 249+ F038
 250+ F038              ; raise a DOS error
 251+ F038 3A 12 55     DOS_ERR:ld      A,(DOSER)       ; load error code
 252+ F03B 5F                   ld      E,A             ; copy into E
 253+ F03C C3 2A 18             jp      ERROR           ; goto error routine
 254+ F03F
 255+ F03F
 256+ F03F              ; check for ",1" argument
 257+ F03F              ; check if 1 is passed as argument after LOAD and ERASE
 258+ F03F AF           CHK1AR: xor     A               ; reset A
 259+ F040 32 2A 55             ld      (TPBF4),A       ; default setting
 260+ F043                                              ; (load=store file in RAM using current BASIC pointers
 261+ F043                                              ; (erase=quick delete)
 262+ F043 2B                   dec     HL              ; dec 'cause GETCHR increments
 263+ F044 CD 59 1D             call    GETCHR          ; check if something follows
 264+ F047 C8                   ret     Z               ; if nothing follows, return
 265+ F048 CD 10 1B             call    CHKSYN          ; Make sure ',' follows
 266+ F04B 2C                   defb    ','
 267+ F04C CD 70 2A             call    GETINT          ; get a value
 268+ F04F 3D                   dec     A               ; decrement it
 269+ F050 C2 10 18             jp      NZ,SNERR        ; not '1' - raise an error
 270+ F053 3C                   inc     A               ; A=1
 271+ F054 32 2A 55             ld      (TPBF4),A       ; load=store file in RAM using address in file
 272+ F057                                              ; erase=full delete
 273+ F057 C9                   ret                     ; return to caller
 274+ F058
 275+ F058
 276+ F058              ; ERASE "filename"
 277+ F058              ; erase a file from disk
 278+ F058 CD EF F1     ERASE:  call    CHKFLNM         ; check for a disk name
 279+ F05B CD 3F F0             call    CHK1AR          ; check for ",1" argument
 280+ F05E E5                   push    HL              ; store code string pointer
 281+ F05F 21 82 F0             ld      HL,ERSTX        ; Point to message
 282+ F062 CD F2 26             call    PRS             ; print message for init confirmation
 283+ F065 E1                   pop     HL              ; retrieve HL
 284+ F066 CD CA F1             call    CNFREQ          ; ask for confirmation
 285+ F069 38 33                jr      C,ABRTDS        ; if Carry set then abort
 286+ F06B CD CB FC             call    CF_INIT         ; init CF card
 287+ F06E DA 38 F0             jp      C,DOS_ERR       ; error if device not available/ready
 288+ F071 E5                   push    HL              ; store code string pointer
 289+ F072 CD 22 FA             call    FIL_ERASE       ; deleted file
 290+ F075 E1                   pop     HL              ; retrieve code string pointer
 291+ F076 DA 38 F0             jp      C,DOS_ERR       ; leave if error
 292+ F079 E5                   push    HL              ; store HL
 293+ F07A 21 90 F0             ld      HL,ERASED       ; point to message of file deleted
 294+ F07D CD F2 26             call    PRS             ; print it
 295+ F080 E1                   pop     HL              ; retrieve HL
 296+ F081 C9                   ret                     ; return to caller
 297+ F082 44 65 6C 65  ERSTX:  defb    "Delete file? ",0
 297+ F086 74 65 20 66
 297+ F08A 69 6C 65 3F
 297+ F08E 20 00
 298+ F090 46 69 6C 65  ERASED: defb    "File deleted",CR,0
 298+ F094 20 64 65 6C
 298+ F098 65 74 65 64
 298+ F09C 0D 00
 299+ F09E
 300+ F09E
 301+ F09E              ; disk operation aborted
 302+ F09E 3E 01        ABRTDS: ld      A,$01           ; re-enable...
 303+ F0A0 32 78 55             ld      (PRNTVIDEO),A   ; ...print-on-video
 304+ F0A3 E5                   push    HL              ; store code string pointer
 305+ F0A4 21 AC F0             ld      HL,ABRTXT       ; Point to message
 306+ F0A7 CD F2 26             call    PRS             ; print message for leaving init procedure
 307+ F0AA E1                   pop     HL              ; retrieve code string pointer
 308+ F0AB C9                   ret                     ; return to caller
 309+ F0AC 0D 41 62 6F  ABRTXT: defb    CR,"Aborted",0
 309+ F0B0 72 74 65 64
 309+ F0B4 00
 310+ F0B5
 311+ F0B5
 312+ F0B5              ; **************************************************************************************
 313+ F0B5              ;                               D O S    R O U T I N E S
 314+ F0B5              ;***************************************************************************************
 315+ F0B5
 316+ F0B5               ; DISK command -------
 317+ F0B5              ; execute several operations on a disk:
 318+ F0B5              ; "F": format/rewrite Master Sector
 319+ F0B5              ; "R": rename disk
 320+ F0B5              ; syntax: DISK "arg1"[,arg2][,1]
 321+ F0B5              TPHL:   equ     TMPDBF          ; temp. buffer for code string pointer
 322+ F0B5 CD 81 3E     DISK:   call    DIRMOD          ; can be executed ONLY in direct mode
 323+ F0B8 C2 25 18             jp      NZ,IMERR        ; raise error if in indirect mode
 324+ F0BB                      ; check first argument
 325+ F0BB 2B                   dec     HL              ; dec 'cause GETCHR increments
 326+ F0BC CD 59 1D             call    GETCHR          ; check if something follows
 327+ F0BF CA 10 18             jp      Z,SNERR         ; if nothing else, raise a syntax error
 328+ F0C2 CD FC 21             call    EVAL            ; Evaluate expression
 329+ F0C5 CD EE 21             call    TSTSTR          ; Make sure it's a string
 330+ F0C8 22 13 55             ld      (TPHL),HL       ; store code string pointer into a temp buffer
 331+ F0CB CD 35 28             call    GSTRCU          ; check that a string follows
 332+ F0CE CD 46 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
 333+ F0D1 7B                   ld      A,E
 334+ F0D2 3D                   dec     A               ; lenght must be = 1
 335+ F0D3 2A 13 55             ld      HL,(TPHL)       ; retrieve code string pointer
 336+ F0D6 C2 10 18             jp      NZ,SNERR
 337+ F0D9 AF                   xor     A
 338+ F0DA 32 2A 55             ld      (TPBF4),A       ; set default to full format
 339+ F0DD 0A                   ld      A,(BC)          ; load command
 340+ F0DE E6 5F                and     %01011111       ; Force upper case
 341+ F0E0 FE 46                cp      'F'             ; format command?
 342+ F0E2 CA FC F0             jp      Z,DSKFRM        ; yes
 343+ F0E5 FE 57                cp      'W'             ; rewrite master sector?
 344+ F0E7 CA F7 F0             jp      Z,RWMSSC        ; yes
 345+ F0EA FE 52                cp      'R'             ; rename command?
 346+ F0EC CA 98 F1             jp      Z,DSKRNM        ; yes
 347+ F0EF FE 55                cp      'U'             ; undelete command?
 348+ F0F1 CA 8B F1             jp      Z,DSKUND        ; yes
 349+ F0F4 C3 10 18             jp      SNERR           ; nothing more - raise a syntax error
 350+ F0F7
 351+ F0F7
 352+ F0F7              ; Format disk or rewrite Master sector
 353+ F0F7              ; syntax: DISK "F/W","disk name"
 354+ F0F7              ; "F" -> format disk, "W" -> rewrite master sector
 355+ F0F7              ; "disk name" is the name -> max 16 chars, allowed chars: "A" to "Z", "0" to "9","-", SPACE
 356+ F0F7              ; Format: set up a fresh new file system, re-writing the Master sector and
 357+ F0F7              ; initializing the directory
 358+ F0F7              ; Master Sector rewriting: re-initialize the Master Sector, writing a new disk name and
 359+ F0F7              ; re-calculating disk geometry
 360+ F0F7              DKNMPT: equ     TMPBFR2         ; store the pointer to the disk name string
 361+ F0F7              DKLNPT: equ     TMPBFR3         ; store the pointer to the lenght of disk name string
 362+ F0F7 3E 01        RWMSSC  ld      A,$01           ; set rewriting of master sector
 363+ F0F9 32 2A 55             ld      (TPBF4),A
 364+ F0FC CD 10 1B     DSKFRM: call    CHKSYN          ; Make sure ',' follows
 365+ F0FF 2C                   defb    ','
 366+ F100 CD EF F1             call    CHKFLNM         ; check for file name
 367+ F103 11 46 F1             ld      DE,MSTTXT       ; format message
 368+ F106 3A 2A 55             ld      A,(TPBF4)       ; check for type of operation
 369+ F109 B7                   or      A               ; A=0 (full format)?
 370+ F10A 20 03                jr      NZ,CFINIT       ; no, jump over
 371+ F10C 11 5E F1             ld      DE,FRMTXT       ; rewrite Master Sector
 372+ F10F E5           CFINIT: push    HL              ; store code string pointer
 373+ F110 62                   ld      H,D             ; Point to message
 374+ F111 6B                   ld      L,E
 375+ F112 CD F2 26             call    PRS             ; print message for confirmation
 376+ F115 E1                   pop     HL              ; retrieve HL
 377+ F116 CD CA F1             call    CNFREQ          ; ask for confirmation
 378+ F119 DA 9E F0             jp      C,ABRTDS        ; if Carry set then abort
 379+ F11C CD CB FC             call    CF_INIT         ; init CF card
 380+ F11F DA 38 F0             jp      C,DOS_ERR       ; error if device not available/ready
 381+ F122 E5                   push    HL              ; store code string pointer
 382+ F123 CD 16 F2             call    DSK_INIT        ; init disk
 383+ F126 E1                   pop     HL              ; retrieve code string pointer
 384+ F127 DA 38 F0             jp      C,DOS_ERR       ; if Carry set, raise error
 385+ F12A E5                   push    HL              ; store code string pointer
 386+ F12B 3A 7C 55             ld      A,(TMPBFR1)
 387+ F12E B7                   or      A               ; full formatting?
 388+ F12F 20 0D                jr      NZ,MSPTOK       ; no
 389+ F131 21 76 F1             ld      HL,OPRCMP       ; yes, Point to message
 390+ F134 CD F2 26             call    PRS             ; print message for init confirmation
 391+ F137 16 00                ld      D,$00           ; print only disk details, no file list
 392+ F139 CD 6B F6             call    LST_FILES       ; print details of disk and list files
 393+ F13C E1                   pop     HL              ; retrieve code string pointer
 394+ F13D C9                   ret                     ; return to caller
 395+ F13E 21 76 F1     MSPTOK: ld      HL,OPRCMP       ; format OK message
 396+ F141 CD F2 26             call    PRS             ; print message for init confirmation
 397+ F144 E1                   pop     HL              ; retrieve code string pointer
 398+ F145 C9                   ret                     ; return to caller
 399+ F146 52 65 77 72  MSTTXT: defb    "Rewrite Master Sector? ",0
 399+ F14A 69 74 65 20
 399+ F14E 4D 61 73 74
 399+ F152 65 72 20 53
 399+ F156 65 63 74 6F
 399+ F15A 72 3F 20 00
 400+ F15E 57 41 52 4E  FRMTXT: defb    "WARNING!! Format disk? ",0
 400+ F162 49 4E 47 21
 400+ F166 21 20 46 6F
 400+ F16A 72 6D 61 74
 400+ F16E 20 64 69 73
 400+ F172 6B 3F 20 00
 401+ F176 4F 70 65 72  OPRCMP: defb    "Operation completed",CR,0
 401+ F17A 61 74 69 6F
 401+ F17E 6E 20 63 6F
 401+ F182 6D 70 6C 65
 401+ F186 74 65 64 0D
 401+ F18A 00
 402+ F18B
 403+ F18B
 404+ F18B              ; undelete files
 405+ F18B              ; look for files marked as "deleted" and undelete them
 406+ F18B 2B           DSKUND: dec     HL              ; dec 'cause GETCHR increments
 407+ F18C CD 59 1D             call    GETCHR          ; check if something follows
 408+ F18F C2 10 18             jp      NZ,SNERR        ; if something else, raise a syntax error
 409+ F192 E5                   push    HL              ; store code string pointer
 410+ F193 CD E4 FA             call    DSKUNDFL        ; undelete files
 411+ F196 E1                   pop     HL              ; retrieve code string pointer
 412+ F197 C9                   ret                     ; return to caller
 413+ F198
 414+ F198
 415+ F198              ; disk rename
 416+ F198              ; change the name of the disk w/o altering anything else
 417+ F198 CD 10 1B     DSKRNM: call    CHKSYN          ; Make sure ',' follows
 418+ F19B 2C                   defb    ','
 419+ F19C CD EF F1             call    CHKFLNM         ; check for file name
 420+ F19F E5                   push    HL              ; store code string pointer
 421+ F1A0 21 BC F1             ld      HL,RNDKTX       ; Point to message
 422+ F1A3 CD F2 26             call    PRS             ; print message for confirmation
 423+ F1A6 E1                   pop     HL              ; retrieve HL
 424+ F1A7 CD CA F1             call    CNFREQ          ; ask for confirmation
 425+ F1AA DA 9E F0             jp      C,ABRTDS        ; if Carry set then abort
 426+ F1AD CD CB FC             call    CF_INIT         ; init CF card
 427+ F1B0 DA 38 F0             jp      C,DOS_ERR       ; error if device not available/ready
 428+ F1B3 E5                   push    HL              ; store code string pointer
 429+ F1B4 CD 4E F3             call    DSK_RNM         ; init disk
 430+ F1B7 E1                   pop     HL              ; retrieve code string pointer
 431+ F1B8 DA 38 F0             jp      C,DOS_ERR       ; DOS error
 432+ F1BB C9                   ret
 433+ F1BC 52 65 6E 61  RNDKTX: defb    "Rename disk? ",0
 433+ F1C0 6D 65 20 64
 433+ F1C4 69 73 6B 3F
 433+ F1C8 20 00
 434+ F1CA
 435+ F1CA
 436+ F1CA              ; confirmation required by the user ('y' or 'Y' DO confirm, otherwise DON'T)
 437+ F1CA CD 26 09     CNFREQ: call    CURSOR_ON       ; enable cursor
 438+ F1CD AF                   xor     A
 439+ F1CE 32 78 55             ld      (PRNTVIDEO),A   ; disable print-on-video
 440+ F1D1 CD 2A 02             call    RXA             ; look for a pressed key
 441+ F1D4 FE 03                cp      CTRLC           ; is it RUN STOP?
 442+ F1D6 28 15                jr      Z,CNFRQN        ; yes, abort operation
 443+ F1D8 E6 DF                and     %11011111       ; only UPPERCASE char
 444+ F1DA FE 59                cp      'Y'             ; 'Y'?
 445+ F1DC 20 0F                jr      NZ,CNFRQN       ; no, abort operation
 446+ F1DE 08                   ex      AF,AF'
 447+ F1DF 3E 01                ld      A,$01           ; re-enable...
 448+ F1E1 32 78 55             ld      (PRNTVIDEO),A   ; ...print-on-video
 449+ F1E4 08                   ex      AF,AF'
 450+ F1E5 CD 1C 03             call    ECHO_CHAR       ; yes, echoes the char
 451+ F1E8 CD 3B 09             call    CURSOR_OFF      ; disable cursor
 452+ F1EB AF                   xor     A               ; reset Carry flag
 453+ F1EC C9                   ret                     ; return to caller
 454+ F1ED 37           CNFRQN: scf                     ; set Carry flag
 455+ F1EE C9                   ret                     ; return to caller
 456+ F1EF
 457+ F1EF
 458+ F1EF              ; check that a disk/file name follows
 459+ F1EF 2B           CHKFLNM:dec     HL              ; dec 'cause GETCHR increments
 460+ F1F0 CD 59 1D             call    GETCHR          ; check if something follows
 461+ F1F3 CA 10 18             jp      Z,SNERR         ; if nothing else, raise a syntax error
 462+ F1F6 CD FC 21             call    EVAL            ; Evaluate expression
 463+ F1F9 CD EE 21     CHKFN1: call    TSTSTR          ; Make sure it's a string
 464+ F1FC 22 15 55             ld      (TMPDBF+2),HL   ; store code string pointer into a temp buffer
 465+ F1FF CD 35 28             call    GSTRCU          ; get current string into pool
 466+ F202 CD 46 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
 467+ F205 7B                   ld      A,E             ; check if lenght = 0
 468+ F206 A7                   and     A               ; null string?
 469+ F207 CA 10 18             jp      Z,SNERR         ; yes, syntax error
 470+ F20A ED 53 80 55          ld      (DKLNPT),DE     ; no, store lenght
 471+ F20E ED 43 7E 55          ld      (DKNMPT),BC     ; store address of temp string
 472+ F212 2A 15 55             ld      HL,(TMPDBF+2)   ; retrieve code string pointer
 473+ F215 C9                   ret                     ; return to caller
 474+ F216
 475+ F216
 476+ F216              ; *****************************************************************************
 477+ F216              ; D I S K    I N I T
 478+ F216              ; Functions: format a disk creating a fresh new file system on disk or
 479+ F216              ;            rewrite only the Master Sector
 480+ F216              ; *****************************************************************************
 481+ F216 CD 69 FB     DSK_INIT:   call    CHKSQFL         ; check if a seq. file is open
 482+ F219 C2 17 F6                 jp      NZ,FILOPCLER    ; jump if open
 483+ F21C 3A 2A 55                 ld      A,(TPBF4)       ; load type of formatting
 484+ F21F 32 7C 55                 ld      (TMPBFR1),A     ; save onto another location for later use
 485+ F222 CD 9E FC                 call    CLRIOBF         ; clear I/O buffer
 486+ F225 CD B3 FC                 call    CLRDOSBF        ; clear DOS buffer
 487+ F228 3E E0                    ld 	    A,$E0           ; select CF as master, driver 0, LBA mode (bits #5-7=111)
 488+ F22A D3 56                    out     (CF_LBA3),A     ; send configuration
 489+ F22C 3E EC                    ld      A,$EC           ; select "drive ID" command
 490+ F22E D3 57                    out     (CF_CMD),A      ; send command
 491+ F230 CD 00 FD                 call	CF_DAT_RDY      ; wait until data is ready to be read
 492+ F233 CD 62 FD                 call	CF_RD_CMD       ; read data and store into I/O buffer
 493+ F236 11 A0 FD                 ld      DE,DOSBFR       ; address of default conf. buffer
 494+ F239 21 C0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
 495+ F23C 01 0E 00                 ld      BC,$000E        ; position of current disk size in sectors
 496+ F23F 09                       add     HL,BC           ; set into HL
 497+ F240 0E 04                    ld      C,$04           ; 4 bytes to copy
 498+ F242 ED B0                    ldir                    ; copy (DE is auto-incremented)
 499+ F244 21 C0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
 500+ F247 01 02 00                 ld      BC,$0002        ; 2 bytes to copy and also address of number of cylinders
 501+ F24A 09                       add     HL,BC           ; get position of data
 502+ F24B ED B0                    ldir                    ; copy (DE is auto-incremented)
 503+ F24D 21 C0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
 504+ F250 01 0C 00                 ld      BC,$000C        ; address of number of sectors per cylinder
 505+ F253 09                       add     HL,BC           ; get position of data
 506+ F254 0E 02                    ld      C,$02           ; 2 bytes to copy
 507+ F256 ED B0                    ldir                    ; copy (DE is auto-incremented)
 508+ F258 21 C0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
 509+ F25B 01 06 00                 ld      BC,$0006        ; address of number of heads
 510+ F25E 09                       add     HL,BC           ; get position of data
 511+ F25F 0E 02                    ld      C,$02           ; 2 bytes to copy
 512+ F261 ED B0                    ldir                    ; copy (DE is auto-incremented)
 513+ F263                          ; now we calculate the # of files allowed (1 file = 1 block = 64K)
 514+ F263 ED 53 2A 55              ld      (TPBF4),DE      ; store current pointer to temp. default conf. buffer
 515+ F267 21 A0 FD                 ld      HL,DOSBFR       ; load number of sectors
 516+ F26A 4E                       ld      C,(HL)          ; MSW into AC
 517+ F26B 23                       inc     HL
 518+ F26C 7E                       ld      A,(HL)
 519+ F26D 23                       inc     HL
 520+ F26E 5E                       ld      E,(HL)          ; LSW into DE
 521+ F26F 23                       inc     HL
 522+ F270 56                       ld      D,(HL)
 523+ F271 D5                       push    DE              ; move DE into IX
 524+ F272 DD E1                    pop     IX
 525+ F274 11 80 00                 ld      DE,$0080        ; 128 sectors per block
 526+ F277 CD B4 41                 call    DIV_32_16       ; execute ACIX/DE; result is into ACIX, remainder into HL
 527+ F27A 47                       ld      B,A             ; now result is into BCIX
 528+ F27B B1                       or      C               ; BC=$0000?
 529+ F27C 28 05                    jr      Z,DOS_FTC       ; yes, but.....
 530+ F27E 11 FF FF                 ld      DE,$FFFF        ; ... no more than $FFFF files, so set limit
 531+ F281 18 0E                    jr      DOS_FT1         ; jump over
 532+ F283 DD E5        DOS_FTC:    push    IX              ; move IX into DE
 533+ F285 D1                       pop     DE              ; now result is into BCDE
 534+ F286 7C                       ld      A,H             ; remainder = zero?
 535+ F287 B5                       or      L
 536+ F288 CA 91 F2                 jp      Z,DOS_FT1       ; yes, jump over
 537+ F28B 13                       inc     DE              ; no, increment DE
 538+ F28C 7A                       ld      A,D             ; check if DE is zero
 539+ F28D B3                       or      E
 540+ F28E 20 01                    jr      NZ,DOS_FT1      ; no, jump over
 541+ F290 1B                       dec     DE              ; yes, so set files to limit of $FFFF
 542+ F291 2A 2A 55     DOS_FT1:    ld      HL,(TPBF4)      ; retrieve current pointer to temp. def. conf. buffer
 543+ F294 CD 62 FC                 call    DE2HL           ; store # of entries
 544+ F297 D5                       push    DE              ; store entries
 545+ F298 EB                       ex      DE,HL           ; copy current pointer into DE
 546+ F299 21 7F EE                 ld      HL,DSKDIRADR    ; address of directory start
 547+ F29C 01 02 00                 ld      BC,$0002        ; 2 bytes to copy
 548+ F29F ED B0                    ldir                    ; copy into buffer
 549+ F2A1                          ; now we calculate the starting sector of data area
 550+ F2A1 E1                       pop     HL              ; entries into HL
 551+ F2A2 0E 10                    ld      C,$10           ; 16 entries per sector
 552+ F2A4 CD 90 41                 call    DIV_16_8        ; calculare how many sectors for dir (HL/C)
 553+ F2A7 B7                       or      A               ; remainder = 0?
 554+ F2A8 28 01                    jr      Z,DOS_FT2       ; yes, jump over
 555+ F2AA 23                       inc     HL              ; increment sectors
 556+ F2AB E5           DOS_FT2:    push    HL              ; store size of directory
 557+ F2AC FD E1                    pop     IY              ; into IY
 558+ F2AE 23                       inc     HL              ; data area is 1 sector bigger than directory's size
 559+ F2AF EB                       ex      DE,HL           ; restore pointer into HL, and move sectors into DE
 560+ F2B0 73                       ld      (HL),E          ; store starting of
 561+ F2B1 23                       inc     HL              ; data area
 562+ F2B2 72                       ld      (HL),D          ; into buffer
 563+ F2B3                          ; now clean again the I/O buffer and copy the configuration into I/O buffer
 564+ F2B3 CD 9E FC                 call    CLRIOBF         ; clear I/O buffer
 565+ F2B6 21 70 EE                 ld      HL,DSKHDR       ; address of disk header string
 566+ F2B9 11 C0 FD                 ld      DE,IOBUFF       ; address of I/O buffer
 567+ F2BC 01 0F 00                 ld      BC,$000F        ; 15 chars
 568+ F2BF ED B0                    ldir                    ; copy header into buffer
 569+ F2C1 21 A0 FD                 ld      HL,DOSBFR       ; first part of configuration
 570+ F2C4 01 10 00                 ld      BC,$0010        ; composed by 16 chars
 571+ F2C7 ED B0                    ldir                    ; copy (DE is auto-incremented)
 572+ F2C9 AF                       xor     A               ; A=$0
 573+ F2CA 12                       ld      (DE),A          ; marker at $1F
 574+ F2CB 13                       inc     DE
 575+ F2CC CD 3A FC                 call    CHKNMVAL        ; copy disk name into buffer
 576+ F2CF DA 26 F6                 jp      C,NAMERR        ; disk name error
 577+ F2D2 CD C2 FB                 call    RND_ID          ; generate a semi-random disk ID
 578+ F2D5 21 C0 FD                 ld      HL,IOBUFF       ; get starting address of I/O buffer
 579+ F2D8 54                       ld      D,H             ; copy into DE...
 580+ F2D9 5D                       ld      E,L             ; ...for later use
 581+ F2DA 01 FE 01                 ld      BC,$01FE        ; get address of last 2 bytes...
 582+ F2DD 09                       add     HL,BC           ; ...of the I/O buffer
 583+ F2DE 3E 38                    ld      A,'8'           ; write marker "80"
 584+ F2E0 77                       ld      (HL),A          ; ...
 585+ F2E1 23                       inc     HL              ; ...
 586+ F2E2 3E 30                    ld      A,'0'           ; ...
 587+ F2E4 77                       ld      (HL),A          ; ...into last 2 locations
 588+ F2E5 EB                       ex      DE,HL           ; copy beginning of I/O buffer from DE into HL
 589+ F2E6 AF                       xor     A               ; reset A - set sector # to $00000000
 590+ F2E7 47                       ld      B,A             ; LBA0=0
 591+ F2E8 4F                       ld      C,A             ; LBA1=0
 592+ F2E9 57                       ld      D,A             ; LBA2=0
 593+ F2EA 5F                       ld      E,A             ; LBA3=0
 594+ F2EB CD 76 FD                 call    CF_WR_SEC       ; write sector to CF
 595+ F2EE DA 1D F6                 jp      C,D2ERR
 596+ F2F1                          ; check if only re-writing of Master Sector was need
 597+ F2F1 3A 7C 55                 ld      A,(TMPBFR1)     ; retrieve type of formatting
 598+ F2F4 3D                       dec     A               ; A=1?
 599+ F2F5 C8                       ret     Z               ; yes, finished job
 600+ F2F6                          ; erase directory -----------------------------
 601+ F2F6                          ; create a progress bar
 602+ F2F6 3E 0D                    ld      A,CR            ; no, full format - go to new line
 603+ F2F8 CD 1B 1B                 call    OUTC
 604+ F2FB FD E5                    push    IY              ; copy directory's size...
 605+ F2FD E1                       pop     HL              ; ...into HL
 606+ F2FE 01 18 00                 ld      BC,$0018        ; 24 steps
 607+ F301 CD 90 41                 call    DIV_16_8        ; calculate HL/24 (remainder is ignored, here)
 608+ F304 E5                       push    HL              ; store result...
 609+ F305 DD E1                    pop     IX              ; ...into IX...
 610+ F307 EB                       ex      DE,HL           ; ...and into DE
 611+ F308 3E 2D                    ld      A,'-'           ; print a progress bar
 612+ F30A CD 46 F3                 call    DOS_FT7         ; print it
 613+ F30D 3E 1C                    ld      A,CRSLFT        ; CURSOR left
 614+ F30F CD 46 F3                 call    DOS_FT7         ; come back to beginning of line
 615+ F312 FD E5                    push    IY              ; copy directory's size
 616+ F314 E1                       pop     HL              ; into HL
 617+ F315 01 01 00                 ld      BC,$0001        ; first sector of directory
 618+ F318 CD 9E FC                 call    CLRIOBF         ; clear I/O buffer
 619+ F31B D5           DOS_FTA:    push    DE              ; store counter
 620+ F31C 11 00 00                 ld      DE,$0000        ; reset MSW of sector pointer
 621+ F31F CD 76 FD                 call    CF_WR_SEC       ; write sector to CF
 622+ F322 DA 42 F3                 jp      C,DOS_FT10      ; error occured
 623+ F325 03                       inc     BC              ; next sector
 624+ F326 2B                       dec     HL              ; decrement HL
 625+ F327 D1                       pop     DE              ; retrieve counter
 626+ F328 1B                       dec     DE              ; decrement counter
 627+ F329 7B                       ld      A,E
 628+ F32A B2                       or      D               ; check if counter is zero
 629+ F32B 20 08                    jr      NZ,DOS_FT9      ; no, jump over
 630+ F32D 3E 2A                    ld      A,'*'           ; yes, print char
 631+ F32F CD 1B 1B                 call    OUTC
 632+ F332 DD E5                    push    IX              ; re-set counter
 633+ F334 D1                       pop     DE
 634+ F335 7C           DOS_FT9:    ld      A,H             ; check if...
 635+ F336 B5                       or      L               ; ...HL = 0
 636+ F337 20 E2                    jr      NZ,DOS_FTA      ; if not, repeat
 637+ F339 3E 0D                    ld      A,CR            ; return
 638+ F33B CD 1B 1B                 call    OUTC            ; next line
 639+ F33E CD 43 FD                 call    CF_STANDBY      ; set CF into stand-by mode
 640+ F341 C9                       ret
 641+ F342 D1           DOS_FT10:   pop     DE
 642+ F343 C3 1D F6                 jp      D2ERR           ; disk geometry error
 643+ F346
 644+ F346              ; print a char 24 times
 645+ F346 06 18        DOS_FT7:    ld      B,$18           ; 24 times
 646+ F348 CD 1B 1B     DOS_FT8:    call    OUTC            ; print char
 647+ F34B 10 FB                    djnz    DOS_FT8         ; repeat
 648+ F34D C9                       ret                     ; return to caller
 649+ F34E
 650+ F34E
 651+ F34E              ; *****************************************************************************
 652+ F34E              ; D I S K    R E N A M E
 653+ F34E              ;******************************************************************************
 654+ F34E CD 9E FC     DSK_RNM:    call    CLRIOBF         ; clear I/O buffer
 655+ F351 CD B3 FC                 call    CLRDOSBF        ; clear DOS buff.
 656+ F354 CD B6 FB                 call    LDMSCT          ; load Master Sector
 657+ F357 21 C0 FD                 ld      HL,IOBUFF       ; point to start of I/O buffer
 658+ F35A 01 20 00                 ld      BC,$0020        ; offset for disk name
 659+ F35D 09                       add     HL,BC           ; get pointer
 660+ F35E EB                       ex      DE,HL           ; copy pointer into DE
 661+ F35F CD 3A FC                 call    CHKNMVAL        ; copy disk name into buffer
 662+ F362 DA 26 F6                 jp      C,NAMERR        ; disk name error
 663+ F365 11 00 00                 ld      DE,$0000        ; reset MSW sector
 664+ F368 42                       ld      B,D             ; reset LSW sector
 665+ F369 4A                       ld      C,D
 666+ F36A CD 76 FD                 call    CF_WR_SEC       ; write sector
 667+ F36D DA 9A FA                 jp      C,WRT_ERR       ; error?
 668+ F370 C9                       ret                     ; no, return to caller
 669+ F371
 670+ F371
 671+ F371
 672+ F371              ; *****************************************************************************
 673+ F371              ; PUT A CHAR INTO A SEQUENTIAL FILE
 674+ F371              ; when the buffer is full, it writes it on the disk,
 675+ F371              ; then move to another sector
 676+ F371              ; *****************************************************************************
 677+ F371 CD 69 FB     PUTFIL:     call    CHKSQFL         ; is there a seq. file open?
 678+ F374 CA 17 F6                 jp      Z,FILOPCLER     ; no, raise an error
 679+ F377 47                       ld      B,A             ; copy file number into B
 680+ F378 3A 13 55                 ld      A,(TMPDBF)      ; load argument
 681+ F37B B8                       cp      B               ; are they equal?
 682+ F37C C2 29 F6                 jp      NZ,FLNTFND      ; file not found
 683+ F37F 3A D7 FF                 ld      A,(SEQFLS)      ; check access mode
 684+ F382 B7                       or      A               ; only reading?
 685+ F383 3E 3E                    ld      A,D3            ; prepare a save error
 686+ F385 CA 31 F6                 jp      Z,RET_ERR       ; yes, error
 687+ F388                          ; store byte
 688+ F388 ED 5B DD FF              ld      DE,(SEQBYSZ)    ; load size in bytes
 689+ F38C 13                       inc     DE              ; increment file size
 690+ F38D 7B                       ld      A,E             ; check if...
 691+ F38E B2                       or      D               ; ...rolled back to $0000
 692+ F38F CA 20 F6                 jp      Z,DSKFULL       ; yes, block is full
 693+ F392 ED 53 DD FF              ld      (SEQBYSZ),DE    ; no, store new size
 694+ F396 2A DF FF                 ld      HL,(SEQPNT)     ; pointer to byte
 695+ F399 11 C0 FD                 ld      DE,IOBUFF       ; load starting address of I/O buffer
 696+ F39C 44                       ld      B,H             ; copy byte pointer...
 697+ F39D 4D                       ld      C,L             ; ...to BC
 698+ F39E 19                       add     HL,DE           ; point to new location
 699+ F39F 3A 14 55                 ld      A,(TMPDBF+1)    ; retrieve byte
 700+ F3A2 77                       ld      (HL),A          ; store it
 701+ F3A3 03                       inc     BC              ; increment byte pointer
 702+ F3A4 ED 43 DF FF              ld      (SEQPNT),BC     ; store it
 703+ F3A8 CD AD F3                 call    PUTNXSC         ; check if I/O buffer is full
 704+ F3AB AF                       xor     A               ; clear Carry
 705+ F3AC C9                       ret                     ; return to caller
 706+ F3AD                          ; check if I/O buffer is full
 707+ F3AD                          ; if yes, store buffer and goto a new sector
 708+ F3AD 11 00 02     PUTNXSC:    ld      DE,$0200        ; max buffer size
 709+ F3B0 2A DF FF                 ld      HL,(SEQPNT)     ; pointer to byte
 710+ F3B3 CD 35 41                 call    CMP16           ; check if pointer < $200
 711+ F3B6 D8                       ret     C               ; yes, return
 712+ F3B7 ED 4B DA FF              ld      BC,(SEQSCTL)    ; load LSW of sector address
 713+ F3BB ED 5B D8 FF              ld      DE,(SEQSCTM)    ; load MSW of sector address
 714+ F3BF CD 76 FD                 call    CF_WR_SEC       ; write buffer into sector
 715+ F3C2 3A DC FF                 ld      A,(SEQSCSZ)     ; load size in sectors
 716+ F3C5 3C                       inc     A               ; we need another sector
 717+ F3C6 67                       ld      H,A             ; store A into H
 718+ F3C7 FE 81                    cp      $81             ; A>128?
 719+ F3C9 3E 42                    ld      A,D5            ; prepare a disk full error
 720+ F3CB D2 0F F6                 jp      NC,GETER        ; yes, raise an error
 721+ F3CE 7C                       ld      A,H             ; no, retrieve sector counter
 722+ F3CF 32 DC FF                 ld      (SEQSCSZ),A     ; store new size in sectors
 723+ F3D2 21 00 00                 ld      HL,$0000        ; reset pointer
 724+ F3D5 22 DF FF                 ld      (SEQPNT),HL
 725+ F3D8 03                       inc     BC              ; next sector
 726+ F3D9 79                       ld      A,C             ; check if BC is rolled back to zero (overflow)
 727+ F3DA B0                       or      B
 728+ F3DB 20 05                    jr      NZ,PUTFIL2      ; no, jump over
 729+ F3DD 13                       inc     DE              ; yes, increment MSW of sector address
 730+ F3DE ED 53 D8 FF              ld      (SEQSCTM),DE    ; save new MSW of sector address
 731+ F3E2 ED 43 DA FF  PUTFIL2:    ld      (SEQSCTL),BC    ; save new LSW of sector address
 732+ F3E6 C3 8F F4                 jp      OPNFRD1         ; load sector and return
 733+ F3E9
 734+ F3E9              ; *****************************************************************************
 735+ F3E9              ; OPEN A SEQUENTIAL FILE
 736+ F3E9              ; open a sequential file for read/write operations
 737+ F3E9              ; if file already exists, it appends new data at the end of the file
 738+ F3E9              ;******************************************************************************
 739+ F3E9 CD 02 FC     OPNFIL:     call    CHKDSKVAL       ; check DOS version & load disk details
 740+ F3EC DA 2F F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
 741+ F3EF CD 69 FB                 call    CHKSQFL         ; check if there is a file already opened
 742+ F3F2 C2 1A F6                 jp      NZ,FILALROP     ; yes, jump over
 743+ F3F5 CD BF FC                 call    CLRSEQBF        ; clear seq. file buffer
 744+ F3F8 3A 13 55                 ld      A,(TMPDBF)      ; recover file number and...
 745+ F3FB 32 D6 FF                 ld      (SEQFL),A       ; ...store it
 746+ F3FE 3A 14 55                 ld      A,(TMPDBF+1)    ; load access mode
 747+ F401 32 D7 FF                 ld      (SEQFLS),A      ; store access mode
 748+ F404                          ; open file
 749+ F404 CD 9E FC                 call    CLRIOBF         ; clear I/O
 750+ F407 CD 40 F9                 call    CHKFLEXT        ; check if file already exists
 751+ F40A 1E 00                    ld      E,$00           ; reset E
 752+ F40C CB 13                    rl      E               ; store Carry into E (0=file not exists, 1=file exists)
 753+ F40E 3A D7 FF                 ld      A,(SEQFLS)      ; load access mode (0=read, 1=create/append)
 754+ F411 B3                       or      E               ; if read mode and file not exist...
 755+ F412 CA 29 F6                 jp      Z,FLNTFND       ; ...raise a file not found error
 756+ F415 3A D7 FF                 ld      A,(SEQFLS)      ; reload access mode (0=read, 1=create/append)
 757+ F418 B7                       or      A               ; read mode?
 758+ F419 28 7F                    jr      Z,OPFLRS        ; yes, open file for read
 759+ F41B                          ; open file for writing
 760+ F41B 7B                       ld      A,E             ; no, open file for save
 761+ F41C B7                       or      A               ; check if file exists
 762+ F41D 20 46                    jr      NZ,OPNFRD       ; file exists, open for append
 763+ F41F                          ; open file for creating (new file)
 764+ F41F CD 9E FC                 call    CLRIOBF         ; clear I/O buffer
 765+ F422 CD 31 FB                 call    FNDFRENTR       ; file doesn't exist, find a free entry in the directory
 766+ F425 DA 20 F6                 jp      C,DSKFULL       ; no entry, disk full error
 767+ F428 3E 82                    ld      A,$82           ; set seq. file type
 768+ F42A 32 2A 55                 ld      (TPBF4),A
 769+ F42D 3E 01                    ld      A,$01           ; set initial size to 1 sector
 770+ F42F 32 DC FF                 ld      (SEQSCSZ),A     ; store it for seq. file manager
 771+ F432 32 1D 55                 ld      (SCT_SIZ),A     ; store it for DOS, too
 772+ F435 21 00 00                 ld      HL,$0000        ; set initial file size to 0 bytes
 773+ F438 22 1B 55                 ld      (BYT_SIZ),HL    ; store it for DOS
 774+ F43B 22 2C 55                 ld      (SRTMEM),HL     ; RAM starting address set to 0 (seq. file is not saved/loaded from/into RAM)
 775+ F43E CD 5D F8                 call    SVENTRY         ; save entry into directory
 776+ F441 ED 5B 1E 55              ld      DE,(MSW_SCT)    ; store MSW of sector address for DOS
 777+ F445 ED 53 D8 FF              ld      (SEQSCTM),DE    ; also for seq. file manager
 778+ F449 ED 4B 20 55              ld      BC,(LSW_SCT)    ; store LSW of sector address for DOS
 779+ F44D ED 43 DA FF              ld      (SEQSCTL),BC    ; also for seq. file manager
 780+ F451 CD E7 F4                 call    SVSQFLNM        ; store name
 781+ F454 CD 9E FC                 call    CLRIOBF         ; clear I/O buffer
 782+ F457 ED 5B 1E 55              ld      DE,(MSW_SCT)    ; load MSW of sector
 783+ F45B ED 4B 20 55              ld      BC,(LSW_SCT)    ; load LSW of sector
 784+ F45F CD 76 FD                 call    CF_WR_SEC       ; write sector
 785+ F462 C3 AB F4                 jp      OPNFILPT        ; go setting pointer
 786+ F465                          ; open file for append (add data after the end)
 787+ F465 CD B3 F4     OPNFRD:     call    OPNRDDET        ; load file details - size in bytes in DE - size in sectors in A
 788+ F468 21 00 02                 ld      HL,$0200        ; sector wide
 789+ F46B EB                       ex      DE,HL           ; move file size into HL and sector size into DE
 790+ F46C 3D           OPNFRD3:    dec     A               ; decrement sector counter
 791+ F46D 28 05                    jr      Z,OPNFRD2       ; reached 0? jump over
 792+ F46F B7                       or      A               ; reset Carry
 793+ F470 ED 52                    sbc     HL,DE           ; decrement sector size
 794+ F472 18 F8                    jr      OPNFRD3         ; repeat
 795+ F474 22 DF FF     OPNFRD2:    ld      (SEQPNT),HL     ; save pointer
 796+ F477 3A DC FF                 ld      A,(SEQSCSZ)     ; load size in sectors
 797+ F47A 3D                       dec     A               ; decrement by 1
 798+ F47B 4F                       ld      C,A             ; store into...
 799+ F47C 06 00                    ld      B,$00           ; ...HL
 800+ F47E 2A DA FF                 ld      HL,(SEQSCTL)    ; load LSW of sector address
 801+ F481 ED 5B D8 FF              ld      DE,(SEQSCTM)    ; load MSW of sector address
 802+ F485 09                       add     HL,BC           ; point to latest sector
 803+ F486 4D                       ld      C,L
 804+ F487 44                       ld      B,H
 805+ F488 30 05                    jr      NC,OPNFRD1      ; if LSW didn't overflow, jump over
 806+ F48A 13                       inc     DE              ; overflow, so increment MSW
 807+ F48B ED 53 D8 FF              ld      (SEQSCTM),DE    ; store new MSW of sector address
 808+ F48F ED 43 DA FF  OPNFRD1:    ld      (SEQSCTL),BC    ; store new LSW of sector address
 809+ F493 CD 0D FD                 call    CF_SETSTR       ; set sector to load
 810+ F496 CD 4F FD                 call    CF_RD_SEC       ; read sector
 811+ F499 C9                       ret                     ; return to caller
 812+ F49A                          ; open file for read & point to beginning of it
 813+ F49A CD B3 F4     OPFLRS:     call    OPNRDDET        ; load file details
 814+ F49D ED 5B D8 FF              ld      DE,(SEQSCTM)    ; load MSW of sector address
 815+ F4A1 ED 4B DA FF              ld      BC,(SEQSCTL)    ; load LSW of sector addres
 816+ F4A5 CD 0D FD                 call    CF_SETSTR       ; point to 1st sector
 817+ F4A8 CD 4F FD                 call    CF_RD_SEC       ; load sector
 818+ F4AB AF           OPNFILPT:   xor     A               ; A=0
 819+ F4AC 32 DF FF                 ld      (SEQPNT),A      ; file pointer...
 820+ F4AF 32 E0 FF                 ld      (SEQPNT+1),A    ; ...set to 0
 821+ F4B2 C9                       ret                     ; return to caller
 822+ F4B3
 823+ F4B3
 824+ F4B3              ; open an existing file and load details
 825+ F4B3 DD 5E 14     OPNRDDET:   ld      E,(IX+$14)      ; load MSW into DE
 826+ F4B6 DD 56 15                 ld      D,(IX+$15)
 827+ F4B9 DD 4E 16                 ld      C,(IX+$16)      ; load LSW into BC
 828+ F4BC DD 46 17                 ld      B,(IX+$17)
 829+ F4BF ED 53 1E 55              ld      (MSW_SCT),DE    ; store DE for DOS
 830+ F4C3 ED 53 D8 FF              ld      (SEQSCTM),DE    ; also for seq. file manager
 831+ F4C7 ED 43 20 55              ld      (LSW_SCT),BC    ; store BC dor DOS
 832+ F4CB ED 43 DA FF              ld      (SEQSCTL),BC    ; also for seq. file manager
 833+ F4CF DD 5E 18                 ld      E,(IX+$18)      ; load size in bytes
 834+ F4D2 DD 56 19                 ld      D,(IX+$19)
 835+ F4D5 ED 53 1B 55              ld      (BYT_SIZ),DE    ; store it for DOS
 836+ F4D9 ED 53 DD FF              ld      (SEQBYSZ),DE    ; store it for seq. file manager
 837+ F4DD DD 7E 1A                 ld      A,(IX+$1A)      ; load size in sectors
 838+ F4E0 32 1D 55                 ld      (SCT_SIZ),A     ; store it for DOS
 839+ F4E3 32 DC FF                 ld      (SEQSCSZ),A     ; and also for seq. file manager
 840+ F4E6 C9                       ret                     ; return to caller
 841+ F4E7
 842+ F4E7
 843+ F4E7              ; save file name into seq. buffer
 844+ F4E7 11 C6 FF     SVSQFLNM:   ld      DE,TMPNAM       ; temp. buff.
 845+ F4EA 01 10 00                 ld      BC,$0010        ; 10 chars
 846+ F4ED 21 A0 FD                 ld      HL,DOSBFR       ; pointer to file name
 847+ F4F0 ED B0                    ldir                    ; store filename
 848+ F4F2 C9                       ret                     ; return to caller
 849+ F4F3
 850+ F4F3              ; *****************************************************************************
 851+ F4F3              ; CLOSE A SEQUENTIAL FILE
 852+ F4F3              ; *****************************************************************************
 853+ F4F3 CD 69 FB     CLOSFIL:    call    CHKSQFL         ; is there a seq. file open?
 854+ F4F6 CA 17 F6                 jp      Z,FILOPCLER     ; no, raise an error
 855+ F4F9 47                       ld      B,A             ; copy file number into B
 856+ F4FA 3A 13 55                 ld      A,(TMPDBF)      ; load argument
 857+ F4FD B8                       cp      B               ; are they equal?
 858+ F4FE C2 29 F6                 jp      NZ,FLNTFND      ; file not found
 859+ F501 3A D7 FF                 ld      A,(SEQFLS)      ; check access mode
 860+ F504 B7                       or      A               ; only reading?
 861+ F505 28 09                    jr      Z,CLOSFIL1      ; yes, just mark file closed
 862+ F507 CD 15 F5                 call    SVCRNTSE        ; save current buffer
 863+ F50A CD 21 F5                 call    UPCRNENT        ; update entry into dir
 864+ F50D DA 29 F6                 jp      C,FLNTFND       ; file not found?
 865+ F510              CLOSFIL1:   ;call    CLRSEQBF        ; clear seq. buffer
 866+ F510 AF                       xor     A               ; mark file as closed
 867+ F511 32 D6 FF                 ld      (SEQFL),A
 868+ F514 C9                       ret                     ; return to caller
 869+ F515
 870+ F515
 871+ F515              ; save current buffer into a sequential file
 872+ F515 ED 5B D8 FF  SVCRNTSE:   ld      DE,(SEQSCTM)    ; MSW of sector address
 873+ F519 ED 4B DA FF              ld      BC,(SEQSCTL)    ; LSW of sector address
 874+ F51D CD 76 FD                 call    CF_WR_SEC       ; save current open sector
 875+ F520 C9                       ret
 876+ F521
 877+ F521
 878+ F521              ; update current entry (for a seq. file)
 879+ F521 11 10 00     UPCRNENT:   ld      DE,$0010
 880+ F524 ED 53 80 55              ld      (DKLNPT),DE     ; lenght of name
 881+ F528 11 C6 FF                 ld      DE,TMPNAM
 882+ F52B ED 53 7E 55              ld      (DKNMPT),DE     ; pointer to name
 883+ F52F CD 40 F9                 call    CHKFLEXT        ; check file existance
 884+ F532 D2 50 F5                 jp      NC,UPCRNENT1    ; file not found
 885+ F535 2A DD FF                 ld      HL,(SEQBYSZ)
 886+ F538 DD 75 18                 ld      (IX+$18),L      ; point to file size
 887+ F53B DD 74 19                 ld      (IX+$19),H
 888+ F53E 3A DC FF                 ld      A,(SEQSCSZ)     ; load size in sectors
 889+ F541 DD 77 1A                 ld      (IX+$1A),A
 890+ F544 ED 5B 26 55              ld      DE,(TPBF2)      ; retrieve MSW of current directory sector
 891+ F548 ED 4B 28 55              ld      BC,(TPBF3)      ; retrieve LSW of current directory secto
 892+ F54C CD 76 FD                 call    CF_WR_SEC       ; store entry
 893+ F54F 37                       scf                     ; set Carry
 894+ F550 3F           UPCRNENT1:  ccf                     ; invert Carry
 895+ F551 C9                       ret
 896+ F552
 897+ F552
 898+ F552              ; *****************************************************************************
 899+ F552              ; E O F
 900+ F552              ; check EOF/size
 901+ F552              ; input: 0 => return size of current file
 902+ F552              ; input: file number => 1 if EOF, 0 otherwise
 903+ F552              ; *****************************************************************************
 904+ F552 CD 69 FB     EOF:        call    CHKSQFL         ; is there a seq. file open?
 905+ F555 1E 38                    ld      E,D0            ; prepare a file open error
 906+ F557 CA 2A 18                 jp      Z,ERROR         ; no, raise an error
 907+ F55A CD 0F 1E                 call    DEINT           ; get any number
 908+ F55D 7B                       ld      A,E             ; is it 0?
 909+ F55E B7                       or      A
 910+ F55F 28 07                    jr      Z,EOF1          ; ok, jump over
 911+ F561 3A D6 FF                 ld      A,(SEQFL)       ; get current file number
 912+ F564 BB                       cp      E               ; same?
 913+ F565 C2 24 1E                 jp      NZ,FCERR        ; no, error
 914+ F568 D5           EOF1:       push    DE              ; store value
 915+ F569 E5                       push    HL              ; store code string pointer
 916+ F56A CD 59 FB                 call    CHKEOF          ; check EOF/size
 917+ F56D E1                       pop     HL              ; retrieve code string pointer
 918+ F56E C1                       pop     BC              ; retrieve argument
 919+ F56F 3E 00                    ld      A,$00           ; reset A (w/o altering Carry)
 920+ F571 17                       rla                     ; copy Carry into bit #0
 921+ F572 47                       ld      B,A             ; copy A into B
 922+ F573 79                       ld      A,C             ; retrieve argument
 923+ F574 B7                       or      A               ; is it zero?
 924+ F575 20 05                    jr      NZ,RETEOF       ; return EOF
 925+ F577 7A                       ld      A,D             ; copy size into AB
 926+ F578 43                       ld      B,E
 927+ F579 C3 D4 25                 jp      ABPASS          ; return size into AB
 928+ F57C 78           RETEOF:     ld      A,B             ; retrieve EOF
 929+ F57D C3 E3 25                 jp      PASSA           ; return value
 930+ F580
 931+ F580              ; *****************************************************************************
 932+ F580              ; P U T
 933+ F580              ; *****************************************************************************
 934+ F580 CD 70 2A     PUT:        call    GETINT          ; get file number
 935+ F583 32 13 55                 ld      (TMPDBF),A      ; store it
 936+ F586 CD 10 1B                 call    CHKSYN          ; Make sure ',' follows
 937+ F589 2C                       defb    ','
 938+ F58A CD 70 2A                 call    GETINT          ; get mode
 939+ F58D 32 14 55                 ld      (TMPDBF+1),A    ; store it
 940+ F590 E5                       push    HL              ; store code string pointer
 941+ F591 CD 71 F3                 call    PUTFIL          ; insert data into file
 942+ F594 DA 38 F0                 jp      C,DOS_ERR       ; any error?
 943+ F597 E1                       pop     HL              ; retrieve code string pointer
 944+ F598 C9                       ret                     ; return to caller
 945+ F599
 946+ F599
 947+ F599              ; *****************************************************************************
 948+ F599              ; G E T
 949+ F599              ; return a byte read from a sequential file
 950+ F599              ; *****************************************************************************
 951+ F599 CD 0F 1E     GET:        call    DEINT           ; get file number
 952+ F59C 7B                       ld      A,E             ; check if...
 953+ F59D B7                       or      A               ; ...it's zero
 954+ F59E CA 24 1E                 jp      Z,FCERR         ; yes, illegal function call
 955+ F5A1 CD 69 FB                 call    CHKSQFL         ; is there a seq. file opened?
 956+ F5A4 3E 38                    ld      A,D0            ; prepare a file open error
 957+ F5A6 28 67                    jr      Z,GETER         ; no, exit with error
 958+ F5A8 3A D7 FF                 ld      A,(SEQFLS)      ; check mode
 959+ F5AB B7                       or      A               ; is it write?
 960+ F5AC C2 24 1E                 jp      NZ,FCERR        ; yes, raise error
 961+ F5AF 3A D6 FF                 ld      A,(SEQFL)       ; file number
 962+ F5B2 BB                       cp      E               ; same?
 963+ F5B3 C2 24 1E                 jp      NZ,FCERR        ; no, error
 964+ F5B6                          ; load byte pointed by seq. file pointer
 965+ F5B6 E5                       push    HL              ; store code string pointer
 966+ F5B7 CD 59 FB                 call    CHKEOF          ; check if EOF
 967+ F5BA 1E 4C                    ld      E,DA
 968+ F5BC DA 2A 18                 jp      C,ERROR         ; return EOF error
 969+ F5BF 2A DF FF                 ld      HL,(SEQPNT)     ; reload pointer in bytes
 970+ F5C2 7C                       ld      A,H             ; copy into AC
 971+ F5C3 4D                       ld      C,L
 972+ F5C4 11 00 02                 ld      DE,$0200        ; size of buffer
 973+ F5C7 CD 9F 41                 call    DIV_16_16       ; calculate (pointer MOD $200) => HL=current pointer into buffer
 974+ F5CA 11 C0 FD                 ld      DE,IOBUFF       ; address of I/O buffer
 975+ F5CD 19                       add     HL,DE           ; find position of byte to load
 976+ F5CE 7E                       ld      A,(HL)          ; load byte
 977+ F5CF 32 7C 55                 ld      (TMPBFR1),A     ; store
 978+ F5D2 2A DF FF                 ld      HL,(SEQPNT)     ; load pointer
 979+ F5D5 23                       inc     HL              ; increment pointer
 980+ F5D6 22 DF FF                 ld      (SEQPNT),HL
 981+ F5D9 11 00 02                 ld      DE,$0200        ; sector size
 982+ F5DC 7C                       ld      A,H             ; copy HL into AC
 983+ F5DD 4D                       ld      C,L
 984+ F5DE CD 9F 41                 call    DIV_16_16       ; calculate <pointer/$200>
 985+ F5E1 7D                       ld      A,L
 986+ F5E2 BC                       cp      H               ; check if remainder is 0 meaning that we read all the buffer ($200 chars)
 987+ F5E3 20 23                    jr      NZ,GET1         ; no, jump over
 988+ F5E5 ED 4B DA FF              ld      BC,(SEQSCTL)    ; load LSW of sector address
 989+ F5E9 03                       inc     BC              ; next sector
 990+ F5EA 79                       ld      A,C             ; check if BC is rolled back to zero (overflow)
 991+ F5EB B0                       or      B
 992+ F5EC 20 09                    jr      NZ,GET2         ; no, jump over
 993+ F5EE ED 5B D8 FF              ld      DE,(SEQSCTM)    ; load MSW of sector address
 994+ F5F2 13                       inc     DE              ; yes, increment MSW of sector address
 995+ F5F3 ED 53 D8 FF              ld      (SEQSCTM),DE    ; save MSW of sector address
 996+ F5F7 ED 43 DA FF  GET2:       ld      (SEQSCTL),BC    ; save LSW of sector address
 997+ F5FB ED 5B D8 FF              ld      DE,(SEQSCTM)    ; load MSW of sector address
 998+ F5FF CD 0D FD                 call    CF_SETSTR       ; set sector to read
 999+ F602 CD 4F FD                 call    CF_RD_SEC       ; read next sector
1000+ F605 CD 43 FD                 call    CF_STANDBY
1001+ F608 E1           GET1:       pop     HL
1002+ F609 3A 7C 55                 ld      A,(TMPBFR1)
1003+ F60C C3 E3 25                 jp      PASSA           ; return A and then return to caller
1004+ F60F E1           GETER:      pop     HL
1005+ F610 5F                       ld      E,A
1006+ F611 CD 43 FD                 call    CF_STANDBY      ; set CF into stand-by
1007+ F614 C3 2A 18                 jp      ERROR
1008+ F617
1009+ F617
1010+ F617              ; *****************************************************************************
1011+ F617              ; DOS ERRORS
1012+ F617              ; *****************************************************************************
1013+ F617 3E 38        FILOPCLER:  ld      A,D0            ; file open/close error
1014+ F619 01                       defb    $01             ; Skip next statement
1015+ F61A 3E 4A        FILALROP:   ld      A,D9            ; file already open
1016+ F61C 01                       defb    $01             ; Skip next statement
1017+ F61D 3E 3C        D2ERR:      ld      A,D2            ; disk geometry error
1018+ F61F 01                       defb    $01             ; Skip next statement
1019+ F620 3E 42        DSKFULL:    ld      A,D5            ; disk full error
1020+ F622 01                       defb    $01             ; Skip next statement
1021+ F623 3E 44        DUPLERR:    ld      A,D6            ; duplicate file name
1022+ F625 01                       defb    $01             ; Skip next statement
1023+ F626 3E 3A        NAMERR:     ld      A,D1            ; file name error
1024+ F628 01                       defb    $01             ; Skip next statement
1025+ F629 3E 48        FLNTFND:    ld      A,D8            ; file not found
1026+ F62B 01                       defb    $01             ; Skip next statement
1027+ F62C 3E 40        LODERR:     ld      A,D4            ; generic load error
1028+ F62E 01                       defb    $01             ; Skip next statement
1029+ F62F 3E 46        DOSVERSERR: ld      A,D7            ; DOS version error
1030+ F631 32 12 55     RET_ERR:    ld      (DOSER),A       ; store DOS error
1031+ F634 CD 43 FD                 call    CF_STANDBY      ; set CF into stand-by
1032+ F637 37                       scf                     ; set Carry for error
1033+ F638 C9                       ret                     ; return to caller
1034+ F639
1035+ F639              ; *****************************************************************************
1036+ F639              ; L I S T    F I L E S
1037+ F639              ; Function: print details of disk and list files
1038+ F639              ; Input: D: $00=only disk details; $01=file list, too
1039+ F639              ; *****************************************************************************
1040+ F639 44 69 73 6B  DSKNMTX:    defb    "Disk name: ",0
1040+ F63D 20 6E 61 6D
1040+ F641 65 3A 20 00
1041+ F645 0D 53 65 63  TLSCTTX:    defb    CR,"Sectors: ",0
1041+ F649 74 6F 72 73
1041+ F64D 3A 20 00
1042+ F650 0D 41 6C 6C  ALFLSTXT:   defb    CR,"Allowed files: ",0
1042+ F654 6F 77 65 64
1042+ F658 20 66 69 6C
1042+ F65C 65 73 3A 20
1042+ F660 00
1043+ F661 20 66 69 6C  TLFLSTX:    defb    " file(s)",CR,0
1043+ F665 65 28 73 29
1043+ F669 0D 00
1044+ F66B CD 69 FB     LST_FILES:  call    CHKSQFL         ; check if a seq. file is open
1045+ F66E C2 17 F6                 jp      NZ,FILOPCLER    ; jump if open
1046+ F671 CD 02 FC                 call    CHKDSKVAL       ; check DOS version & load disk details
1047+ F674 DA 2F F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
1048+ F677 D5                       push    DE              ; store D
1049+ F678 CD B6 FB                 call    LDMSCT          ; load Master Sector
1050+ F67B 21 39 F6                 ld      HL,DSKNMTX      ; pointer to "Disk name" message
1051+ F67E CD F2 26                 call    PRS             ; print it
1052+ F681 21 C0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
1053+ F684 11 20 00                 ld      DE,$0020        ; position of disk name
1054+ F687 19                       add     HL,DE           ; get address
1055+ F688 06 10                    ld      B,$10           ; 16 chars
1056+ F68A 7E           INPR1:      ld      A,(HL)          ; load char
1057+ F68B CD 1B 1B                 call    OUTC            ; print it
1058+ F68E 23                       inc     HL
1059+ F68F 10 F9                    djnz    INPR1           ; repeat
1060+ F691 3E 0D                    ld      A,CR
1061+ F693 CD 1B 1B                 call    OUTC            ; carriage return
1062+ F696 DD 21 00 00              ld      IX,$0000        ; reset file counter (for use in formatting)
1063+ F69A D1                       pop     DE              ; retrieve D
1064+ F69B 7A                       ld      A,D
1065+ F69C B7                       or      A               ; is D=0?
1066+ F69D CA 50 F7                 jp      Z,PNTSTATS      ; yes, jump over
1067+ F6A0                          ; print list of files
1068+ F6A0 21 C0 FD                 ld      HL,IOBUFF       ; start of I/O buffer
1069+ F6A3 11 0F 00                 ld      DE,$000F        ; point to details of disk
1070+ F6A6 19                       add     HL,DE           ; find address
1071+ F6A7 11 A0 FD                 ld      DE,DOSBFR       ; store into DOS buffer
1072+ F6AA 01 20 00                 ld      BC,$0020        ; 32 bytes
1073+ F6AD ED B0                    ldir                    ; copy
1074+ F6AF CD A7 FB                 call    LDENTRIES       ; load entries
1075+ F6B2 FD 2A 19 55              ld      IY,(NTR_NBR)    ; load max entries
1076+ F6B6 D9                       exx
1077+ F6B7 01 00 00                 ld      BC,$0000        ; reset file counter
1078+ F6BA D9                       exx
1079+ F6BB CD 6E FB                 call    SETPTEN         ; point to 1st sector of dir
1080+ F6BE CD 76 FB     LSTFILES1:  call    PT2FSEN         ; point to 1st entry of a dir's sect
1081+ F6C1 CD 81 FB     LSTFILES2:  call    CKCREN          ; check current entry
1082+ F6C4 28 64                    jr      Z,LSTFILES6     ; if empty or deleted, ignore it
1083+ F6C6 C5                       push    BC              ; this is a valid entry - so, store BC (LSW of sect)
1084+ F6C7 FD E5                    push    IY              ; store IY (entries counter)
1085+ F6C9 E5                       push    HL              ; store HL (sect entry counter)
1086+ F6CA D5                       push    DE              ; store DE (MSW of sector)
1087+ F6CB DD E5                    push    IX              ; store IX (pointer to first byte of entry)
1088+ F6CD 06 10                    ld      B,$10           ; 16 chars to read and print
1089+ F6CF DD 7E 00     LSTFILES3:  ld      A,(IX)          ; load char from name
1090+ F6D2 CD 1B 1B                 call    OUTC            ; print char
1091+ F6D5 DD 23                    inc     IX              ; next char
1092+ F6D7 10 F6                    djnz    LSTFILES3       ; repeat
1093+ F6D9 3E 20                    ld      A,SPC
1094+ F6DB CD 1B 1B                 call    OUTC            ; print space
1095+ F6DE DD 7E 00                 ld      A,(IX)          ; file type
1096+ F6E1 D6 80                    sub     $80             ; types start from $80
1097+ F6E3 B7                       or      A               ; BAS type ($00)?
1098+ F6E4 20 05                    jr      NZ,LSTFILES20   ; no, jump over
1099+ F6E6 21 94 F7                 ld      HL,FILETP       ; print "BAS"
1100+ F6E9 18 13                    jr      LSTFILESPR
1101+ F6EB 3D           LSTFILES20: dec     A               ; BIN type ($01)?
1102+ F6EC 20 05                    jr      NZ,LSTFILES21   ; no, jump over
1103+ F6EE 21 99 F7                 ld      HL,FILETP+5     ; print "BIN"
1104+ F6F1 18 0B                    jr      LSTFILESPR
1105+ F6F3 3D           LSTFILES21: dec     A
1106+ F6F4 20 05                    jr      NZ,LSTFILES22
1107+ F6F6 21 9E F7                 ld      HL,FILETP+10    ; print "SEQ"
1108+ F6F9 18 03                    jr      LSTFILESPR
1109+ F6FB 21 9E F7     LSTFILES22: ld      HL,FILETP+10    ; print "???"
1110+ F6FE CD F2 26     LSTFILESPR: call    PRS
1111+ F701 01 08 00                 ld      BC,$0008
1112+ F704 DD 09                    add     IX,BC           ; point to file size in bytes
1113+ F706 DD 4E 00                 ld      C,(IX)          ; load size in BC, first LSW
1114+ F709 DD 23                    inc     IX
1115+ F70B DD 46 00                 ld      B,(IX)          ; then MSW
1116+ F70E C5                       push    BC              ; copy...
1117+ F70F DD E1                    pop     IX              ; ...into IX
1118+ F711 11 00 00                 ld      DE,$0000        ; reset DE
1119+ F714 FD E5                    push    IY
1120+ F716 CD 75 FC                 call    PRN16ASCIX      ; print size in bytes (DEIX)
1121+ F719 FD E1                    pop     IY
1122+ F71B 3E 0D                    ld      A,CR
1123+ F71D CD 1B 1B                 call    OUTC            ; print carriage return
1124+ F720 D9                       exx                     ; set shadow registers
1125+ F721 03                       inc     BC              ; increment file counter
1126+ F722 D9                       exx                     ; restore main registers
1127+ F723 DD E1                    pop     IX              ; retrieve IX
1128+ F725 D1                       pop     DE              ; retrieve DE
1129+ F726 E1                       pop     HL              ; retrieve HL
1130+ F727 FD E1                    pop     IY              ; retrieve IY
1131+ F729 C1                       pop     BC              ; retrieve BC
1132+ F72A CD 84 1D     LSTFILES6:  call    TSTBRK          ; Test for break key
1133+ F72D CD 87 1C                 call    TSTSPC          ; test for space
1134+ F730 CD 89 FB                 call    GTNXTEN         ; other entries in this sector?
1135+ F733 20 8C                    jr      NZ,LSTFILES2    ; yes, continue check
1136+ F735 CD 95 FB                 call    CKLSTEN         ; go to next sector
1137+ F738 D2 BE F6                 jp      NC,LSTFILES1    ; more entries? repeat
1138+ F73B D9                       exx                     ; set shadow registers
1139+ F73C C5                       push    BC              ; store file counter
1140+ F73D D9                       exx                     ; restore main registers
1141+ F73E DD E1                    pop     IX              ; retrieve file counter
1142+ F740 DD E5                    push    IX              ; store it again
1143+ F742 11 00 00                 ld      DE,$0000        ; reset DE
1144+ F745 CD 75 FC                 call    PRN16ASCIX      ; print number of files from DEIX
1145+ F748 21 61 F6                 ld      HL,TLFLSTX
1146+ F74B CD F2 26                 call    PRS             ; print "file(s)"
1147+ F74E DD E1                    pop     IX
1148+ F750 21 45 F6     PNTSTATS:   ld      HL,TLSCTTX      ; Point to message "Tot. sectors"
1149+ F753 CD F2 26                 call    PRS             ; print message
1150+ F756 21 A0 FD                 ld      HL,DOSBFR       ; reload address of I/O buffer and point to disk size
1151+ F759 DD E5                    push    IX
1152+ F75B CD 6C FC                 call    PRN32ASCII      ; print size
1153+ F75E 3E 2F                    ld      A,'/'
1154+ F760 CD 1B 1B                 call    OUTC            ; print a "/""
1155+ F763 D1                       pop     DE              ; copy number of entries into DE
1156+ F764 01 80 00                 ld      BC,$0080        ; 128 sectors per entry block
1157+ F767 CD 5A 41                 call    MUL_U32         ; multiply BC times DE: returns DEHL
1158+ F76A ED 53 24 55              ld      (TPBF1),DE      ; store results
1159+ F76E 22 26 55                 ld      (TPBF2),HL
1160+ F771 21 24 55                 ld      HL,TPBF1        ; print results
1161+ F774 CD 6C FC                 call    PRN32ASCII
1162+ F777 21 50 F6                 ld      HL,ALFLSTXT     ; Point to message "Allowed files"
1163+ F77A CD F2 26                 call    PRS             ; print message
1164+ F77D 21 A0 FD                 ld      HL,DOSBFR       ; reload address of I/O buffer
1165+ F780 01 0A 00                 ld      BC,$000A        ; address of allowed files
1166+ F783 09                       add     HL,BC           ; find pointer
1167+ F784 11 00 00                 ld      DE,$0000        ; MSW set to $0000
1168+ F787 CD 6F FC                 call    PRN16ASCII      ; print max files
1169+ F78A 3E 0D                    ld      A,CR
1170+ F78C CD 1B 1B                 call    OUTC            ; print a carriage return
1171+ F78F CD 43 FD                 call    CF_STANDBY      ; put CF into standby
1172+ F792 AF                       xor     A               ; clear Carry flag
1173+ F793 C9                       ret                     ; return to caller
1174+ F794 42 41 53 20  FILETP:     defb    "BAS ",0        ; BASIC type
1174+ F798 00
1175+ F799 42 49 4E 20              defb    "BIN ",0        ; BINARY type
1175+ F79D 00
1176+ F79E 53 45 51 20              defb    "SEQ ",0
1176+ F7A2 00
1177+ F7A3 3F 3F 3F 20              defb    "??? ",0        ; unkown
1177+ F7A7 00
1178+ F7A8
1179+ F7A8
1180+ F7A8              ; *****************************************************************************
1181+ F7A8              ; S A V E    F I L E
1182+ F7A8              ; save current BASIC program onto a file
1183+ F7A8              ; *****************************************************************************
1184+ F7A8 CD 69 FB     SAVFILE:    call    CHKSQFL         ; check if a seq. file is open
1185+ F7AB C2 17 F6                 jp      NZ,FILOPCLER    ; jump if open
1186+ F7AE CD 40 F9                 call    CHKFLEXT        ; file already exists?
1187+ F7B1 DA 23 F6                 jp      C,DUPLERR       ; name is present - error
1188+ F7B4 CD 31 FB                 call    FNDFRENTR       ; find a free entry in the directory
1189+ F7B7 DA 20 F6                 jp      C,DSKFULL       ; no entry, disk full error
1190+ F7BA 3A 2A 55                 ld      A,(TPBF4)       ; check what to save
1191+ F7BD FE 80                    cp      $80             ; BASIC program?
1192+ F7BF C2 CE F7                 jp      NZ,SAVFL3       ; no, jump over
1193+ F7C2                          ; BASIC area to save starts at PROGND and ends at (PROGND)
1194+ F7C2 2A C2 55                 ld      HL,(PROGND)     ; load end of BASIC program <- WARNING: pay attention to (PROGND) and PROGND
1195+ F7C5 11 C2 55                 ld      DE,PROGND       ; start of RAM to be saved  <- WARNING: pay attention to (PROGND) and PROGND
1196+ F7C8 ED 53 2C 55              ld      (SRTMEM),DE     ; copy DE
1197+ F7CC 18 08                    jr      SAVFL1
1198+ F7CE 2A 2E 55     SAVFL3:     ld      HL,(ENDMEM)     ; save a portion of memory: HL <= end of portion
1199+ F7D1 23                       inc     HL              ; we always need 1 more byte to store the portion of memory
1200+ F7D2 ED 5B 2C 55              ld      DE,(SRTMEM)     ; DE <= start of portion
1201+ F7D6                          ; compute how many sectors/blocks are needed to save file
1202+ F7D6 AF           SAVFL1:     xor     A               ; reset Carry
1203+ F7D7 ED 52                    sbc     HL,DE           ; get how many bytes to save
1204+ F7D9 22 1B 55                 ld      (BYT_SIZ),HL    ; store into memory
1205+ F7DC 11 00 02                 ld      DE,$0200        ; 512 bytes per sector
1206+ F7DF 7C                       ld      A,H             ; move lenght...
1207+ F7E0 4D                       ld      C,L             ; ...into AC
1208+ F7E1 CD 9F 41                 call    DIV_16_16       ; lenght/512 = nbr. of sectors: quotient in AC but A will be discarded
1209+ F7E4 7C                       ld      A,H             ; check if...
1210+ F7E5 B5                       or      L               ; ...remainder (HL) is 0
1211+ F7E6 28 01                    jr      Z,SAVFL6        ; yes, jump over
1212+ F7E8 03                       inc     BC              ; no, so we need another sector
1213+ F7E9 79           SAVFL6:     ld      A,C
1214+ F7EA 32 1D 55                 ld      (SCT_SIZ),A     ; store into memory
1215+ F7ED CD 5D F8                 call    SVENTRY         ; save new entry into dir
1216+ F7F0 CD 9E FC                 call    CLRIOBF         ; clear I/O buffer
1217+ F7F3                          ; start saving RAM
1218+ F7F3 ED 5B 2C 55              ld      DE,(SRTMEM)     ; load start of RAM
1219+ F7F7 ED 53 22 55              ld      (RAM_PTR),DE    ; store
1220+ F7FB CD 9E FC     SAVFL10:    call    CLRIOBF         ; clear I/O buffer
1221+ F7FE 2A 1B 55                 ld      HL,(BYT_SIZ)    ; load bytes left to be copied
1222+ F801 11 00 02                 ld      DE,$0200        ; are they < 512?
1223+ F804 CD 35 41                 call    CMP16
1224+ F807 30 04                    jr      NC,SAVFL4       ; no, jump over
1225+ F809 ED 5B 1B 55              ld      DE,(BYT_SIZ)    ; yes, so load remaining bytes
1226+ F80D 4B           SAVFL4:     ld      C,E             ; bytes to copy
1227+ F80E 42                       ld      B,D             ; into BC
1228+ F80F 2A 22 55                 ld      HL,(RAM_PTR)    ; load pointer to RAM to be saved
1229+ F812 11 C0 FD                 ld      DE,IOBUFF       ; load start of I/O buffer
1230+ F815 ED B0                    ldir                    ; copy data
1231+ F817 ED 5B 1E 55              ld      DE,(MSW_SCT)    ; load MSW of sector
1232+ F81B ED 4B 20 55              ld      BC,(LSW_SCT)    ; load LSW of sector
1233+ F81F CD 76 FD                 call    CF_WR_SEC       ; write sector
1234+ F822 DA 9A FA                 jp      C,WRT_ERR       ; error?
1235+ F825 21 1D 55                 ld      HL,SCT_SIZ      ; sector counter
1236+ F828 35                       dec     (HL)            ; copied all the sectors?
1237+ F829 CA 58 F8                 jp      Z,SAVFLEXT      ; yes, exit
1238+ F82C 2A 22 55                 ld      HL,(RAM_PTR)    ; pointer to RAM
1239+ F82F 11 00 02                 ld      DE,$0200        ; block of 512 bytes copied
1240+ F832 19                       add     HL,DE           ; calculate next starting address
1241+ F833 22 22 55                 ld      (RAM_PTR),HL    ; store next block
1242+ F836 AF                       xor     A               ; reset Carry
1243+ F837 2A 1B 55                 ld      HL,(BYT_SIZ)    ; load left bytes
1244+ F83A ED 52                    sbc     HL,DE           ; subtract copied bytes
1245+ F83C 22 1B 55                 ld      (BYT_SIZ),HL    ; store left bytes
1246+ F83F ED 4B 20 55              ld      BC,(LSW_SCT)    ; load LSW of sector
1247+ F843 03                       inc     BC              ; next sector
1248+ F844 78                       ld      A,B             ; BC=$0000?
1249+ F845 B1                       or      C
1250+ F846 20 09                    jr      NZ,SAVFL12      ; no, jump over
1251+ F848 ED 5B 1E 55              ld      DE,(MSW_SCT)    ; load MSW of sector
1252+ F84C 13                       inc     DE              ; increment DE
1253+ F84D ED 53 1E 55              ld      (MSW_SCT),DE    ; store new MSW of sector
1254+ F851 ED 43 20 55  SAVFL12:    ld      (LSW_SCT),BC    ; store new LSW of sector
1255+ F855 C3 FB F7                 jp      SAVFL10         ; repeat
1256+ F858 CD 43 FD     SAVFLEXT:   call    CF_STANDBY      ; set CF into stand-by mode
1257+ F85B AF                       xor     A               ; clear Carry flag
1258+ F85C C9                       ret                     ; return to caller
1259+ F85D
1260+ F85D              ; save entry on disk
1261+ F85D 11 00 00     SVENTRY:    ld      DE,$0000        ; directory is always from sector 0000-0001
1262+ F860 ED 4B 17 55              ld      BC,(DIR_SCT)    ; load sector of dir where to save file entry
1263+ F864 CD 0D FD                 call    CF_SETSTR       ; set sector to read
1264+ F867 CD 4F FD                 call    CF_RD_SEC       ; read sector
1265+ F86A 3A 19 55                 ld      A,(NTR_NBR)     ; load entry number (ignoring MSB)
1266+ F86D E6 0F                    and     %00001111       ; be sure to get only low nibble
1267+ F86F 87                       add     A,A             ; multiply...
1268+ F870 87                       add     A,A             ; ...times 16 by...
1269+ F871 87                       add     A,A             ; ...adding...
1270+ F872 87                       add     A,A             ; ...4 times
1271+ F873 CB 27                    sla     A               ; left shift to multiply times 32 - Carry is set if results is > 255
1272+ F875 5F                       ld      E,A             ; copy into C
1273+ F876 CB 12                    rl      D               ; if Carry, then increment D (D was 0, see above)
1274+ F878                          ; set name
1275+ F878 21 C0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
1276+ F87B 19                       add     HL,DE           ; add offset to get address of entry
1277+ F87C 11 A0 FD                 ld      DE,DOSBFR       ; pointer to file name
1278+ F87F 01 10 00                 ld      BC,$0010        ; 16 chars
1279+ F882 EB                       ex      DE,HL           ; move source into HL and destination into DE
1280+ F883 ED B0                    ldir                    ; copy file name
1281+ F885 EB                       ex      DE,HL           ; move current buffer pointer into HL
1282+ F886 3A 2A 55                 ld      A,(TPBF4)       ; load the type of file
1283+ F889 77                       ld      (HL),A          ; store it
1284+ F88A 23                       inc     HL
1285+ F88B AF                       xor     A               ; file attributes - AT THE MOMENT, NO ATTRIBUTES
1286+ F88C 77                       ld      (HL),A
1287+ F88D 23                       inc     HL
1288+ F88E ED 5B 19 55              ld      DE,(NTR_NBR)    ; reload entry number
1289+ F892 CD 62 FC                 call    DE2HL           ; store entry into buffer
1290+ F895 E5                       push    HL              ; store pointer
1291+ F896 01 80 00                 ld      BC,$0080        ; 128 sectors per entry block
1292+ F899 CD 5A 41                 call    MUL_U32         ; multiply BC times DE: returns DEHL
1293+ F89C ED 4B 15 55              ld      BC,(DAT_STRT)   ; load start of data
1294+ F8A0 09                       add     HL,BC           ; add sector of data area
1295+ F8A1 30 01                    jr      NC,SAVFL9       ; overflow?
1296+ F8A3 13                       inc     DE              ; yes, increment DE
1297+ F8A4 ED 53 1E 55  SAVFL9:     ld      (MSW_SCT),DE    ; store MSW of sector
1298+ F8A8 22 20 55                 ld      (LSW_SCT),HL    ; store LSW of sector
1299+ F8AB E1                       pop     HL              ; retrieve pointer
1300+ F8AC CD 62 FC                 call    DE2HL           ; also copy MSW of sector into entry
1301+ F8AF ED 5B 20 55              ld      DE,(LSW_SCT)    ; retrieve LSW
1302+ F8B3 CD 62 FC                 call    DE2HL           ; also copy LSW of sector into entry
1303+ F8B6 ED 5B 1B 55              ld      DE,(BYT_SIZ)    ; retrieve file size in bytes
1304+ F8BA CD 62 FC                 call    DE2HL           ; copy file size into buffer
1305+ F8BD 3A 1D 55                 ld      A,(SCT_SIZ)     ; retrieve file size in sectors
1306+ F8C0 77                       ld      (HL),A          ; copy into buffer
1307+ F8C1 23                       inc     HL              ; next location
1308+ F8C2 ED 5B 2C 55              ld      DE,(SRTMEM)     ; start of address of file in RAM
1309+ F8C6 CD 62 FC                 call    DE2HL           ; copy into buffer
1310+ F8C9 06 03                    ld      B,$03           ; remaining chars...
1311+ F8CB AF                       xor     A               ; ...set to $00
1312+ F8CC 77           SAVFL2:     ld      (HL),A          ; reset byte
1313+ F8CD 23                       inc     HL              ; next cell
1314+ F8CE 10 FC                    djnz    SAVFL2          ; repeat
1315+ F8D0                          ; save entry into directory
1316+ F8D0 11 00 00                 ld      DE,$0000        ; block 0
1317+ F8D3 ED 4B 17 55              ld      BC,(DIR_SCT)    ; load sector of dir where to save file entry
1318+ F8D7 CD 76 FD                 call    CF_WR_SEC       ; write new entry into directory
1319+ F8DA DA 1D F6                 jp      C,D2ERR         ; error occured
1320+ F8DD C9                       ret
1321+ F8DE
1322+ F8DE
1323+ F8DE              ; *****************************************************************************
1324+ F8DE              ; C H A N G E    F I L E N A M E
1325+ F8DE              ; change name to a file
1326+ F8DE              ; *****************************************************************************
1327+ F8DE ED 5B 1B 55  CHNGNAM:    ld      DE,(BYT_SIZ)    ; load lenght
1328+ F8E2 ED 53 80 55              ld      (DKLNPT),DE     ; store it
1329+ F8E6 ED 5B 22 55              ld      DE,(RAM_PTR)    ; load address
1330+ F8EA ED 53 7E 55              ld      (DKNMPT),DE     ; store it
1331+ F8EE CD 40 F9                 call    CHKFLEXT        ; destination file already exists?
1332+ F8F1 DA 23 F6                 jp      C,DUPLERR       ; file name already exists
1333+ F8F4 CD 9E FC                 call    CLRIOBF         ; clear I/O buffer
1334+ F8F7 ED 5B 82 55              ld      DE,(TMPBFR4)    ; load lenght
1335+ F8FB ED 53 80 55              ld      (DKLNPT),DE     ; store it
1336+ F8FF ED 5B 2C 55              ld      DE,(TPBF4+2)    ; load address
1337+ F903 ED 53 7E 55              ld      (DKNMPT),DE     ; store it
1338+ F907 CD 5D F9                 call    LK4FILE         ; look for file
1339+ F90A D2 29 F6                 jp      NC,FLNTFND      ; file not found error
1340+ F90D ED 5B 1B 55              ld      DE,(BYT_SIZ)    ; load lenght
1341+ F911 ED 53 80 55              ld      (DKLNPT),DE     ; store it
1342+ F915 ED 5B 22 55              ld      DE,(RAM_PTR)    ; load address
1343+ F919 ED 53 7E 55              ld      (DKNMPT),DE     ; store it
1344+ F91D CD B3 FC                 call    CLRDOSBF        ; clear DOS buffer
1345+ F920 11 A0 FD                 ld      DE,DOSBFR       ; DE set to beginning of DOS buffer
1346+ F923 CD 3A FC                 call    CHKNMVAL        ; check and copy file name
1347+ F926 21 A0 FD                 ld      HL,DOSBFR       ; retrieve new name pointer
1348+ F929 DD E5                    push    IX              ; copy dest. address...
1349+ F92B D1                       pop     DE              ; ...into DE
1350+ F92C 01 10 00                 ld      BC,$0010        ; 16 chars to copy
1351+ F92F ED B0                    ldir                    ; copy
1352+ F931 ED 5B 26 55              ld      DE,(TPBF2)      ; retrieve MSW of dir. sector
1353+ F935 ED 4B 28 55              ld      BC,(TPBF3)      ; retrieve LSW of dir. sector
1354+ F939 CD 76 FD                 call    CF_WR_SEC       ; write sector
1355+ F93C CD 43 FD                 call    CF_STANDBY      ; put CF in standby
1356+ F93F C9                       ret                     ; return to caller
1357+ F940
1358+ F940
1359+ F940              ; *****************************************************************************
1360+ F940              ; C H E C K    F I L E    E X I S T A N C E
1361+ F940              ; check if a file with the given name exists into dir
1362+ F940              ; Carry set if exist
1363+ F940              ; *****************************************************************************
1364+ F940 CD 9E FC     CHKFLEXT:   call    CLRIOBF         ; clear I/O
1365+ F943 CD 02 FC                 call    CHKDSKVAL       ; check DOS version & load disk details
1366+ F946 DA 2F F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
1367+ F949 CD A7 FB                 call    LDENTRIES       ; load entries into RAM register NTR_NBR
1368+ F94C CD 67 FC                 call    HL2DE           ; get start of directory into DE
1369+ F94F ED 53 13 55              ld      (DIR_STRT),DE   ; store
1370+ F953 CD 67 FC                 call    HL2DE           ; get start of data area into DE
1371+ F956 ED 53 15 55              ld      (DAT_STRT),DE   ; store
1372+ F95A C3 60 F9                 jp      LK4FILE1        ; check for name already present in dir and return to caller
1373+ F95D
1374+ F95D
1375+ F95D              ; *****************************************************************************
1376+ F95D              ; L O O K    F O R    A    F I L E
1377+ F95D              ; look for the given file into the dir
1378+ F95D              ; Carry is reset if not found, set otherwise
1379+ F95D              ; *****************************************************************************
1380+ F95D CD A7 FB     LK4FILE:    call    LDENTRIES       ; load entries into RAM register NTR_NBR
1381+ F960 CD 9E FC     LK4FILE1:   call    CLRIOBF         ; clear IO buffer
1382+ F963 CD B3 FC                 call    CLRDOSBF        ; clear DOS buffer
1383+ F966 11 A0 FD                 ld      DE,DOSBFR       ; DE set to beginning of DOS buffer
1384+ F969 CD 3A FC                 call    CHKNMVAL        ; check and copy file name
1385+ F96C DA 26 F6                 jp      C,NAMERR        ; if Carry, file name error
1386+ F96F C3 9F FA                 jp      FILE_EXIST      ; check if file exists and return to caller
1387+ F972
1388+ F972
1389+ F972              ; *****************************************************************************
1390+ F972              ; F I L E    L O A D
1391+ F972              ; load a file from the disk into the memory
1392+ F972              ; *****************************************************************************
1393+ F972 CD 69 FB     LODFILE:    call    CHKSQFL         ; check if a seq. file is open
1394+ F975 C2 17 F6                 jp      NZ,FILOPCLER    ; jump if open
1395+ F978 CD 9E FC                 call    CLRIOBF         ; clear I/O
1396+ F97B CD 02 FC                 call    CHKDSKVAL       ; check DOS version & load disk details
1397+ F97E DA 2F F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
1398+ F981 CD 5D F9                 call    LK4FILE         ; look for given file
1399+ F984 D2 29 F6                 jp      NC,FLNTFND      ; file not found - error
1400+ F987 DD E5                    push    IX              ; copy pointer to file...
1401+ F989 E1                       pop     HL              ; ...into HL
1402+ F98A 01 10 00                 ld      BC,$0010        ; skip file name (16 chars)...
1403+ F98D 09                       add     HL,BC           ; ...by getting pointer to file details
1404+ F98E 7E                       ld      A,(HL)          ; load file type
1405+ F98F FE 80                    cp      $80             ; 'BAS' type?
1406+ F991 28 0C                    jr      Z,LDFL4         ; yes, jump over
1407+ F993 FE 81                    cp      $81             ; 'BIN' type?
1408+ F995 C2 2C F6                 jp      NZ,LODERR       ; no, raise error
1409+ F998 3A 2A 55                 ld      A,(TPBF4)       ; if BIN file, file must be loaded into its original position
1410+ F99B B7                       or      A               ; did the user set this?
1411+ F99C CA 2C F6                 jp      Z,LODERR        ; no, raise an error
1412+ F99F 0E 04        LDFL4:      ld      C,$04           ; 4 steps forward and also 4 bytes to copy
1413+ F9A1 09                       add     HL,BC           ; point to starting sector
1414+ F9A2 11 1E 55                 ld      DE,MSW_SCT      ; point to store sector address of file
1415+ F9A5 ED B0                    ldir                    ; copy MSW/LSW from entry into buffer
1416+ F9A7 11 1B 55                 ld      DE,BYT_SIZ      ; point to store size of file
1417+ F9AA 01 03 00                 ld      BC,$0003        ; 3 bytes to copy
1418+ F9AD ED B0                    ldir                    ; copy size in bytes and sectors from entry into buffer
1419+ F9AF 11 C2 55                 ld      DE,PROGND       ; load start of BASIC RAM
1420+ F9B2 3A 2A 55                 ld      A,(TPBF4)       ; check where to save the data from
1421+ F9B5 B7                       or      A               ; is it 0? (meaning from the current BASIC pointers)
1422+ F9B6 28 03                    jr      Z,LDFL1         ; yes, don't re-load the file from the address stored into the file
1423+ F9B8 CD 67 FC                 call    HL2DE           ; no, load RAM address from disk
1424+ F9BB ED 53 22 55  LDFL1:      ld      (RAM_PTR),DE    ; store starting pointer
1425+ F9BF                          ; start loading from disk
1426+ F9BF CD 9E FC     LDFL2:      call    CLRIOBF         ; clear I/O buffer
1427+ F9C2 ED 5B 1E 55              ld      DE,(MSW_SCT)    ; load MSW of sector
1428+ F9C6 ED 4B 20 55              ld      BC,(LSW_SCT)    ; load LSW of sector
1429+ F9CA CD 0D FD                 call    CF_SETSTR       ; set sector
1430+ F9CD CD 4F FD                 call    CF_RD_SEC       ; read sector
1431+ F9D0 2A 1B 55                 ld      HL,(BYT_SIZ)    ; load bytes left to be copied
1432+ F9D3 11 00 02                 ld      DE,$0200        ; are they < 512?
1433+ F9D6 CD 35 41                 call    CMP16
1434+ F9D9 30 04                    jr      NC,LDFL3        ; no, jump over
1435+ F9DB ED 5B 1B 55              ld      DE,(BYT_SIZ)    ; yes, so load only remaining bytes
1436+ F9DF 4B           LDFL3:      ld      C,E             ; move bytes to copy...
1437+ F9E0 42                       ld      B,D             ; ...into BC
1438+ F9E1 21 C0 FD                 ld      HL,IOBUFF       ; point to I/O buffer
1439+ F9E4 ED 5B 22 55              ld      DE,(RAM_PTR)    ; point to RAM where to save
1440+ F9E8 ED B0                    ldir                    ; copy data
1441+ F9EA 21 1D 55                 ld      HL,SCT_SIZ      ; sector counter
1442+ F9ED 35                       dec     (HL)            ; copied all the sectors?
1443+ F9EE CA 1D FA                 jp      Z,LDFLEX        ; yes, exit
1444+ F9F1 2A 22 55                 ld      HL,(RAM_PTR)    ; pointer to RAM
1445+ F9F4 11 00 02                 ld      DE,$0200        ; block of 512 bytes copied
1446+ F9F7 19                       add     HL,DE           ; calculate next starting address
1447+ F9F8 22 22 55                 ld      (RAM_PTR),HL    ; store next block
1448+ F9FB AF                       xor     A               ; reset Carry
1449+ F9FC 2A 1B 55                 ld      HL,(BYT_SIZ)    ; load left bytes
1450+ F9FF ED 52                    sbc     HL,DE           ; subtract copied bytes
1451+ FA01 22 1B 55                 ld      (BYT_SIZ),HL    ; store left bytes
1452+ FA04 ED 4B 20 55              ld      BC,(LSW_SCT)    ; load LSW of sector
1453+ FA08 03                       inc     BC              ; next sector
1454+ FA09 78                       ld      A,B             ; BC=$0000?
1455+ FA0A B1                       or      C
1456+ FA0B 20 09                    jr      NZ,LDFL5        ; no, jump over
1457+ FA0D ED 5B 1E 55              ld      DE,(MSW_SCT)    ; load MSW of sector
1458+ FA11 13                       inc     DE              ; increment DE
1459+ FA12 ED 53 1E 55              ld      (MSW_SCT),DE    ; store new MSW of sector
1460+ FA16 ED 43 20 55  LDFL5:      ld      (LSW_SCT),BC    ; store new LSW of sector
1461+ FA1A C3 BF F9                 jp      LDFL2           ; repeat
1462+ FA1D CD 43 FD     LDFLEX:     call    CF_STANDBY      ; set CF into stand-by mode
1463+ FA20 AF                       xor     A               ; clear Carry flag
1464+ FA21 C9                       ret                     ; return to caller
1465+ FA22
1466+ FA22
1467+ FA22              ; *****************************************************************************
1468+ FA22              ; F I L E    E R A S E
1469+ FA22              ; erase a file from disk, freeing its block
1470+ FA22              ; *****************************************************************************
1471+ FA22 CD 69 FB     FIL_ERASE:  call    CHKSQFL         ; check if a seq. file is open
1472+ FA25 C2 17 F6                 jp      NZ,FILOPCLER    ; jump if open
1473+ FA28 CD 9E FC                 call    CLRIOBF         ; clear I/O
1474+ FA2B CD 02 FC                 call    CHKDSKVAL       ; check DOS version & load disk details
1475+ FA2E DA 2F F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
1476+ FA31 CD 5D F9                 call    LK4FILE         ; look for given file
1477+ FA34 D2 29 F6                 jp      NC,FLNTFND      ; file not found - error
1478+ FA37 DD 5E 14                 ld      E,(IX+$14)      ; load MSW into DE
1479+ FA3A DD 56 15                 ld      D,(IX+$15)
1480+ FA3D DD 4E 16                 ld      C,(IX+$16)      ; load LSW into BC
1481+ FA40 DD 46 17                 ld      B,(IX+$17)
1482+ FA43 ED 53 1E 55              ld      (MSW_SCT),DE    ; store DE
1483+ FA47 ED 43 20 55              ld      (LSW_SCT),BC    ; store BC
1484+ FA4B DD 7E 1A                 ld      A,(IX+$1A)      ; load size in sectors
1485+ FA4E 32 1D 55                 ld      (SCT_SIZ),A     ; store it
1486+ FA51 3E 7F                    ld      A,$7F           ; marker for file deleted
1487+ FA53 DD 77 00                 ld      (IX),A          ; set file as deleted (quick erase)
1488+ FA56 3A 2A 55                 ld      A,(TPBF4)       ; check for quick or full delete
1489+ FA59 B7                       or      A               ; A=0 quick erase
1490+ FA5A 28 0A                    jr      Z,FIL_ERA5      ; jump if quick erase
1491+ FA5C AF                       xor     A               ; clear A
1492+ FA5D 06 20                    ld      B,$20           ; full erase - clean entry (32 cells)
1493+ FA5F DD 77 00     FIL_ERA6:   ld      (IX),A          ; reset cell
1494+ FA62 DD 23                    inc     IX              ; next cell
1495+ FA64 10 F9                    djnz    FIL_ERA6        ; repeat
1496+ FA66 ED 5B 26 55  FIL_ERA5:   ld      DE,(TPBF2)      ; retrieve MSW of current directory sector
1497+ FA6A ED 4B 28 55              ld      BC,(TPBF3)      ; retrieve LSW of current directory sector
1498+ FA6E CD 76 FD                 call    CF_WR_SEC       ; write sector
1499+ FA71 38 27                    jr      C,WRT_ERR       ; error?
1500+ FA73 3A 2A 55                 ld      A,(TPBF4)       ; check for quick or full delete
1501+ FA76 B7                       or      A               ; if A=0 then quick erase
1502+ FA77 28 1C                    jr      Z,FIL_ERA3      ; yes, leave
1503+ FA79 CD 9E FC                 call    CLRIOBF         ; no, full delete - clear I/O buffer
1504+ FA7C ED 5B 1E 55              ld      DE,(MSW_SCT)    ; load MSW of 1st sector of file block
1505+ FA80 ED 4B 20 55              ld      BC,(LSW_SCT)    ; load LSW of 1st sector of file block
1506+ FA84 21 1D 55                 ld      HL,SCT_SIZ      ; pointer to size in sectors
1507+ FA87 CD 76 FD     FIL_ERA1:   call    CF_WR_SEC       ; erase sector
1508+ FA8A 38 0E                    jr      C,WRT_ERR       ; error?
1509+ FA8C 03                       inc     BC              ; next sector
1510+ FA8D 78                       ld      A,B             ; is LSW rolled back to 0?
1511+ FA8E B1                       or      C
1512+ FA8F 20 01                    jr      NZ,FIL_ERA2     ; no, jump over
1513+ FA91 13                       inc     DE              ; yes, increment MSW
1514+ FA92 35           FIL_ERA2:   dec     (HL)            ; decrement sector counter
1515+ FA93 20 F2                    jr      NZ,FIL_ERA1     ; repeat if other sectors
1516+ FA95 CD 43 FD     FIL_ERA3:   call    CF_STANDBY      ; set CF into stand-by mode
1517+ FA98 AF                       xor     A               ; clear Carry
1518+ FA99 C9                       ret
1519+ FA9A CD 43 FD     WRT_ERR:    call    CF_STANDBY      ; put CF into stand-by
1520+ FA9D 37                       scf                     ; set error
1521+ FA9E C9                       ret                     ; return to caller
1522+ FA9F
1523+ FA9F
1524+ FA9F              ; *****************************************************************************
1525+ FA9F              ; F I L E    C H E C K
1526+ FA9F              ; check if file name already exists in directory
1527+ FA9F              ; file name must be stored from DOSBFR   for 16 chars
1528+ FA9F              ; *****************************************************************************
1529+ FA9F FD 2A 19 55  FILE_EXIST: ld      IY,(NTR_NBR)    ; load max entries
1530+ FAA3 CD 6E FB                 call    SETPTEN         ; point to 1st sector of dir
1531+ FAA6 CD 76 FB     CHKSTNM1:   call    PT2FSEN         ; point to 1st entry of a dir's sect
1532+ FAA9 CD 81 FB     CHKSTNM2:   call    CKCREN          ; check current entry
1533+ FAAC 28 28                    jr      Z,CHKSTNM10     ; if empty or deleted, jump over
1534+ FAAE 22 24 55                 ld      (TPBF1),HL      ; store HL
1535+ FAB1 ED 53 26 55              ld      (TPBF2),DE      ; store DE
1536+ FAB5 ED 43 28 55              ld      (TPBF3),BC      ; store BC
1537+ FAB9 DD E5                    push    IX              ; copy IX...
1538+ FABB E1                       pop     HL              ; ...into HL
1539+ FABC 11 A0 FD                 ld      DE,DOSBFR       ; beginning of name file
1540+ FABF 06 10                    ld      B,$10           ; 16 chars to check
1541+ FAC1 1A           CHKSTNM3:   ld      A,(DE)          ; load a char from name on disk
1542+ FAC2 ED A1                    cpi                     ; compare with name from user
1543+ FAC4 20 05                    jr      NZ,CHKSTNM6     ; chars are different, leave
1544+ FAC6 13                       inc     DE              ; inc DE (HL is incremented by "cpi")
1545+ FAC7 10 F8                    djnz    CHKSTNM3        ; repeat for 16 chars
1546+ FAC9 18 17                    jr      FLEXST          ; file exists in dir
1547+ FACB 2A 24 55     CHKSTNM6:   ld      HL,(TPBF1)      ; retrieve HL
1548+ FACE ED 5B 26 55              ld      DE,(TPBF2)      ; retrieve DE
1549+ FAD2 ED 4B 28 55              ld      BC,(TPBF3)      ; retrieve sector counter
1550+ FAD6 CD 89 FB     CHKSTNM10:  call    GTNXTEN         ; other entries in this sector?
1551+ FAD9 20 CE                    jr      NZ,CHKSTNM2     ; yes, continue check
1552+ FADB CD 95 FB                 call    CKLSTEN         ; go to next sector
1553+ FADE 30 C6                    jr      NC,CHKSTNM1     ; more entries? repeat
1554+ FAE0 AF                       xor     A               ; file not found, reset Carry
1555+ FAE1 C9                       ret                     ; return
1556+ FAE2 37           FLEXST:     scf                     ; file is present - set Carry flag for error
1557+ FAE3 C9                       ret
1558+ FAE4
1559+ FAE4
1560+ FAE4              ; *****************************************************************************
1561+ FAE4              ; UNDELETE DELETED FILES
1562+ FAE4              ; look for deleted files and undelete them
1563+ FAE4              ; *****************************************************************************
1564+ FAE4 CD 9E FC     DSKUNDFL:   call    CLRIOBF         ; clear I/O
1565+ FAE7 CD 02 FC                 call    CHKDSKVAL       ; check DOS version & load disk details
1566+ FAEA DA 2F F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
1567+ FAED CD 31 FB                 call    FNDFRENTR       ; find a free entry
1568+ FAF0 D8           DSKUNDFL1:  ret     C               ; return if entries are finished
1569+ FAF1 DD 7E 00                 ld      A,(IX)          ; reload first char of entry
1570+ FAF4 FE 7F                    cp      $7F             ; is it a deleted entry?
1571+ FAF6 20 29                    jr      NZ,DSKUNDFL2    ; no, jump over
1572+ FAF8 CD D9 FB                 call    RND8            ; get a random char
1573+ FAFB CD F7 FB                 call    CHATOZ          ; transform it into a letter
1574+ FAFE DD 77 00                 ld      (IX),A          ; store it as the first letter of filename
1575+ FB01 CD 76 FD                 call    CF_WR_SEC       ; write sector (address is into DEBC)
1576+ FB04 E5                       push    HL              ; store HL
1577+ FB05 C5                       push    BC              ; store BC
1578+ FB06 D5                       push    DE              ; store DE
1579+ FB07 DD E5                    push    IX              ; copy IX...
1580+ FB09 E1                       pop     HL              ; ...into HL
1581+ FB0A 06 10                    ld      B,$10           ; 16 chars
1582+ FB0C 7E           DSKUNDPR:   ld      A,(HL)          ; retrieve char from filename
1583+ FB0D CD 1B 1B                 call    OUTC            ; print char
1584+ FB10 23                       inc     HL              ; next char
1585+ FB11 10 F9                    djnz    DSKUNDPR        ; repeat
1586+ FB13 3E 20                    ld      A,SPC           ; print a space
1587+ FB15 CD 1B 1B                 call    OUTC
1588+ FB18 21 26 FB                 ld      HL,DSKUNDTXT    ; print undeleted message
1589+ FB1B CD F2 26                 call    PRS
1590+ FB1E D1                       pop     DE              ; retrieve DE
1591+ FB1F C1                       pop     BC              ; retrieve BC
1592+ FB20 E1                       pop     HL              ; retrieve HL
1593+ FB21 CD 45 FB     DSKUNDFL2:  call    FNDFRENTR4      ; goto next entry
1594+ FB24 18 CA                    jr      DSKUNDFL1       ; repeat
1595+ FB26 75 6E 64 65  DSKUNDTXT:  defb    "undeleted",CR,0
1595+ FB2A 6C 65 74 65
1595+ FB2E 64 0D 00
1596+ FB31
1597+ FB31
1598+ FB31              ; *****************************************************************************
1599+ FB31              ; FIND A FREE ENTRY
1600+ FB31              ; find a free entry in the directory to store a new file
1601+ FB31              ; *****************************************************************************
1602+ FB31 CD B6 FB     FNDFRENTR:  call    LDMSCT          ; read Master Sector
1603+ FB34 CD A7 FB                 call    LDENTRIES       ; load entries into RAM register NTR_NBR and DE
1604+ FB37 D5                       push    DE              ; copy number of entries...
1605+ FB38 FD E1                    pop     IY              ; ...into IY
1606+ FB3A CD 6E FB                 call    SETPTEN         ; point to first entry
1607+ FB3D CD 76 FB     FNDFRENTR1: call    PT2FSEN         ; point to 1st entry of sector
1608+ FB40 CD 81 FB     FNDFRENTR2: call    CKCREN          ; check current entry
1609+ FB43 28 0B                    jr      Z,FNDFRENTR3    ; found a free entry
1610+ FB45 CD 89 FB     FNDFRENTR4: call    GTNXTEN         ; other entries in this sector?
1611+ FB48 20 F6                    jr      NZ,FNDFRENTR2   ; yes, continue check
1612+ FB4A CD 95 FB                 call    CKLSTEN         ; go to next sector
1613+ FB4D 30 EE                    jr      NC,FNDFRENTR1   ; more entries? repeat
1614+ FB4F C9                       ret                     ; entries finished - leave
1615+ FB50 ED 43 17 55  FNDFRENTR3: ld      (DIR_SCT),BC    ; store sector of dir
1616+ FB54 22 19 55                 ld      (NTR_NBR),HL    ; store entry number
1617+ FB57 AF                       xor     A               ; reset Carry
1618+ FB58 C9                       ret
1619+ FB59
1620+ FB59
1621+ FB59              ; *****************************************************************************
1622+ FB59              ;   U T I L I T I E S
1623+ FB59              ; *****************************************************************************
1624+ FB59
1625+ FB59
1626+ FB59              ; check if EOF for seq. file
1627+ FB59              ; C is set if EOF, NC otherwise
1628+ FB59              ; destroys DE & HL
1629+ FB59              ; return: DE=size of seq. file; C=1 if EOF, C=0 otherwise
1630+ FB59 ED 5B DD FF  CHKEOF:     ld      DE,(SEQBYSZ)    ; size of seq. file
1631+ FB5D 7B                       ld      A,E             ; check if file size...
1632+ FB5E B2                       or      D               ; ...is 0
1633+ FB5F 28 06                    jr      Z,CHKEOFC       ; yes, EOF
1634+ FB61 2A DF FF                 ld      HL,(SEQPNT)     ; pointer to last byte of seq. file
1635+ FB64 CD 35 41                 call    CMP16           ; over the EOF?
1636+ FB67 3F           CHKEOFC:    ccf                     ; invert Carry
1637+ FB68 C9                       ret
1638+ FB69
1639+ FB69
1640+ FB69              ; check if a sequential file is open
1641+ FB69 3A D6 FF     CHKSQFL:    ld      A,(SEQFL)       ; seq. file status
1642+ FB6C B7                       or      A               ; if A<>0 then a file is open
1643+ FB6D C9                       ret                     ; return to caller
1644+ FB6E
1645+ FB6E
1646+ FB6E              ; set up registers to point to first sector of directory
1647+ FB6E 01 01 00     SETPTEN:    ld      BC,$0001        ; BC=$0001 (starting sector of dir) (LSW)
1648+ FB71 50                       ld      D,B             ; DE=$0000 (starting sector of dir) (MSW)
1649+ FB72 58                       ld      E,B
1650+ FB73 60                       ld      H,B             ; HL=$0000 (entry counter)
1651+ FB74 68                       ld      L,B
1652+ FB75 C9                       ret                     ; return to caller
1653+ FB76
1654+ FB76
1655+ FB76              ; load a sector and point to first entry
1656+ FB76 CD 0D FD     PT2FSEN:    call    CF_SETSTR       ; set sector to read (BC-DE)
1657+ FB79 CD 4F FD                 call    CF_RD_SEC       ; read sector
1658+ FB7C DD 21 C0 FD              ld      IX,IOBUFF       ; beginning of I/O buffer
1659+ FB80 C9                       ret
1660+ FB81
1661+ FB81
1662+ FB81              ; check current entry
1663+ FB81 DD 7E 00     CKCREN:     ld      A,(IX)          ; load 1st char of entry name
1664+ FB84                          ;dec     IY              ; decrement number of entries
1665+ FB84 B7                       or      A               ; is it $00 (empty entry)?
1666+ FB85 C8                       ret     Z               ; yes, found an entry
1667+ FB86 FE 7F                    cp      $7F             ; is it $7F (deleted entry)?
1668+ FB88 C9                       ret
1669+ FB89
1670+ FB89              ; goto next entry
1671+ FB89 C5           GTNXTEN:    push    BC              ; store BC
1672+ FB8A 01 20 00                 ld      BC,$0020        ; load BC with directory entry size (32 bytes)
1673+ FB8D DD 09                    add     IX,BC           ; next entry in current sector
1674+ FB8F C1                       pop     BC              ; retrieve sector pointer
1675+ FB90 23                       inc     HL              ; increment entry counter
1676+ FB91 7D                       ld      A,L
1677+ FB92 E6 0F                    and     %00001111       ; just done 16 entries?
1678+ FB94 C9                       ret
1679+ FB95
1680+ FB95
1681+ FB95              ; check if reached last entry
1682+ FB95              ; Carry is set if entries finished
1683+ FB95 03           CKLSTEN:    inc     BC              ; entries in this sector finished .. goto next sector
1684+ FB96 78                       ld      A,B             ; check if...
1685+ FB97 B1                       or      C               ; ...BC=$000
1686+ FB98 20 01                    jr      NZ,CKLSTEN1     ; no, jump over
1687+ FB9A 13                       inc     DE              ; yes, increment DE (MSW)
1688+ FB9B E5           CKLSTEN1:   push    HL              ; preserve current entry
1689+ FB9C D5                       push    DE
1690+ FB9D FD E5                    push    IY              ; copy max allowed files...
1691+ FB9F D1                       pop     DE              ; ...into HL
1692+ FBA0 CD 35 41                 call    CMP16           ; check if reached max allowed entries
1693+ FBA3 D1                       pop     DE
1694+ FBA4 E1                       pop     HL              ; (retrieve current entry)
1695+ FBA5 3F                       ccf
1696+ FBA6 C9                       ret                     ; return
1697+ FBA7
1698+ FBA7
1699+ FBA7              ; load entries intro RAM register
1700+ FBA7 21 C0 FD     LDENTRIES:  ld      HL,IOBUFF       ; start of I/O buffer
1701+ FBAA 01 19 00                 ld      BC,$0019        ; point to max. allowed entries
1702+ FBAD 09                       add     HL,BC           ; get address
1703+ FBAE CD 67 FC                 call    HL2DE           ; get entries into DE
1704+ FBB1 ED 53 19 55              ld      (NTR_NBR),DE    ; store
1705+ FBB5 C9                       ret                     ; return to caller
1706+ FBB6
1707+ FBB6
1708+ FBB6              ; load Master Sector (sector #0)
1709+ FBB6 01 00 00     LDMSCT:     ld      BC,$0000        ; LSW of sector
1710+ FBB9 50                       ld      D,B             ; MSW of sector
1711+ FBBA 58                       ld      E,B
1712+ FBBB CD 0D FD                 call    CF_SETSTR       ; set sector
1713+ FBBE CD 4F FD                 call    CF_RD_SEC       ; read sector
1714+ FBC1 C9                       ret
1715+ FBC2
1716+ FBC2
1717+ FBC2              ; generate random disk ID
1718+ FBC2 C5           RND_ID:     push    BC
1719+ FBC3 06 02                    ld      B,$02           ; repeat 2 times
1720+ FBC5 CD D9 FB     RND_ID1:    call    RND8            ; get a random value
1721+ FBC8 CD F7 FB                 call    CHATOZ          ; transform it into a letter
1722+ FBCB 12                       ld      (DE),A          ; store it
1723+ FBCC 13                       inc     DE              ; inc pointer
1724+ FBCD CD D9 FB                 call    RND8            ; get a random value
1725+ FBD0 CD EC FB                 call    CH0TO9          ; transform it into a number from 0 to 9
1726+ FBD3 12                       ld      (DE),A          ; store it
1727+ FBD4 13                       inc     DE              ; inc pointer
1728+ FBD5 10 EE                    djnz    RND_ID1         ; repeat
1729+ FBD7 C1                       pop     BC
1730+ FBD8 C9                       ret                     ; return to caller
1731+ FBD9
1732+ FBD9
1733+ FBD9              ; generate a pseudo-random number using TMR and R registers
1734+ FBD9 C5           RND8:       push    BC              ; store B
1735+ FBDA 3A 5C 55                 ld      A,(TMRCNT)      ; load LSW of sys-timer
1736+ FBDD 47                       ld      B,A             ; copy into B
1737+ FBDE ED 5F                    ld      A,R             ; load refresh register
1738+ FBE0 A8                       xor     B               ; A xor B
1739+ FBE1 47                       ld      B,A             ; copy into B
1740+ FBE2 0F                       rrca                    ; multiply by 32
1741+ FBE3 0F                       rrca
1742+ FBE4 0F                       rrca
1743+ FBE5 EE 1F                    xor     $1F             ; a XOR to mix bits
1744+ FBE7 80                       add     A,B             ; add B
1745+ FBE8 DE FF                    sbc     A,255           ; carry
1746+ FBEA C1                       pop     BC              ; retrieve B
1747+ FBEB C9                       ret                     ; return to caller
1748+ FBEC
1749+ FBEC
1750+ FBEC              ; char ported into 0-9 interval
1751+ FBEC E6 0F        CH0TO9:     and     %00001111       ; get only low nibble
1752+ FBEE FE 0A                    cp      $0A             ; is it < 10?
1753+ FBF0 38 02                    jr      C,CH0TO9E       ; yes, jump over
1754+ FBF2 D6 0A                    sub     $0A             ; subract 10
1755+ FBF4 C6 30        CH0TO9E:    add     $30             ; get a number from 0 to 9
1756+ FBF6 C9                       ret
1757+ FBF7
1758+ FBF7
1759+ FBF7              ; char ported into A-Z interval
1760+ FBF7 E6 1F        CHATOZ:     and     %00011111       ; get only first 5 bits
1761+ FBF9 FE 1A                    cp      $1A             ; is it < 26?
1762+ FBFB 38 02                    jr      C,CHATOZE       ; yes, jump over
1763+ FBFD D6 1A                    sub     $1A             ; no, subtract 26
1764+ FBFF C6 41        CHATOZE:    add     $41             ; get a letter from 'A' to 'Z'
1765+ FC01 C9                       ret                     ; return to caller
1766+ FC02
1767+ FC02
1768+ FC02              ; first check DOS validity then load disk details
1769+ FC02 CD CB FC     CHKDSKVAL:  call    CF_INIT         ; open CF card comm.
1770+ FC05 D8                       ret     C               ; if errors, leave
1771+ FC06 C5                       push    BC              ; store BC
1772+ FC07 D5                       push    DE              ; store DE
1773+ FC08 E5                       push    HL              ; store HL
1774+ FC09 01 00 00                 ld      BC,$0000        ; reset LSW of sector
1775+ FC0C 50                       ld      D,B             ; reset MSW of sector
1776+ FC0D 58                       ld      E,B
1777+ FC0E CD 0D FD                 call    CF_SETSTR       ; set sector #0
1778+ FC11 CD 4F FD                 call    CF_RD_SEC       ; read sector
1779+ FC14 21 C0 FD                 ld      HL,IOBUFF       ; address of default conf. buffer
1780+ FC17 11 0A 00                 ld      DE,$000A        ; point to disk DOS version
1781+ FC1A 19                       add     HL,DE
1782+ FC1B 11 7A EE                 ld      DE,DSKHDR+10    ; get starting address of I/O buffer
1783+ FC1E 06 04                    ld      B,$04           ; 4 chars
1784+ FC20 1A           CHKDSKVAL1: ld      A,(DE)          ; load char from DOS version into memory
1785+ FC21 BE                       cp      (HL)            ; compare with disk DOS version
1786+ FC22 20 11                    jr      NZ,CHKDSKVALE   ; no match - so error
1787+ FC24 13                       inc     DE              ; next source
1788+ FC25 23                       inc     HL              ; next comparison
1789+ FC26 10 F8                    djnz    CHKDSKVAL1      ; repeat
1790+ FC28 21 A0 FD                 ld      HL,DOSBFR       ; address of default conf. buffer
1791+ FC2B 11 1D 00                 ld      DE,$001D        ; point to address of data area
1792+ FC2E 19                       add     HL,DE           ; set pointer to beginning of identifies
1793+ FC2F CD 67 FC                 call    HL2DE           ; first sector of data area into DE
1794+ FC32 AF                       xor     A               ; no error - clear Carry flag
1795+ FC33 18 01                    jr      CHKDSKVAL2      ; jump over
1796+ FC35 37           CHKDSKVALE: scf                     ; error - set carry flag
1797+ FC36 E1           CHKDSKVAL2: pop     HL
1798+ FC37 D1                       pop     DE
1799+ FC38 C1                       pop     BC
1800+ FC39 C9                       ret                     ; return to caller
1801+ FC3A
1802+ FC3A
1803+ FC3A              ; check name validity (only allowed chars) and copy it from string pool into a temp buff
1804+ FC3A              ; Inputs: DE: pointer to dest. buffer
1805+ FC3A              ; operation: copy (HL)->(DE) and pads to get a 16-chars name
1806+ FC3A              ; destroys: A, BC, DE, HL
1807+ FC3A ED 4B 80 55  CHKNMVAL:   ld      BC,(DKLNPT)     ; load lenght of name
1808+ FC3E 79                       ld      A,C             ; lenght is max. 16 char, so we only check C
1809+ FC3F FE 11                    cp      $11             ; is it <=16?
1810+ FC41 38 02                    jr      C,CHKNMVAL1     ; yes, so jump over
1811+ FC43 0E 10                    ld      C,$10           ; no, get only 16 chars
1812+ FC45 41           CHKNMVAL1:  ld      B,C             ; copy lenght into B
1813+ FC46 0E 10                    ld      C,$10           ; char counter
1814+ FC48 2A 7E 55                 ld      HL,(DKNMPT)     ; pointer to name
1815+ FC4B 7E           CHKNMVAL2:  ld      A,(HL)          ; get a char from string name
1816+ FC4C CD 88 FC                 call    CHK_NAM         ; check if valid
1817+ FC4F D8                       ret     C               ; no, name error
1818+ FC50 12                       ld      (DE),A          ; yes, store char
1819+ FC51 13                       inc     DE              ; next I/O location
1820+ FC52 23                       inc     HL              ; next name char
1821+ FC53 0D                       dec     C               ; decrement number of chars copied
1822+ FC54 10 F5                    djnz    CHKNMVAL2       ; repeat until name ends
1823+ FC56 79                       ld      A,C             ; check if there are no empty chars in file
1824+ FC57 B7                       or      A
1825+ FC58 C8                       ret     Z               ; yes, job finished - return
1826+ FC59 3E 20                    ld      A,SPC           ; no, padding required
1827+ FC5B 12           CHKNMVAL3:  ld      (DE),A          ; store char
1828+ FC5C 13                       inc     DE              ; next location
1829+ FC5D 0D                       dec     C               ; check if padding is over
1830+ FC5E 20 FB                    jr      NZ,CHKNMVAL3    ; no, continue
1831+ FC60 AF                       xor     A               ; clear Carry flag
1832+ FC61 C9                       ret                     ; return to caller
1833+ FC62
1834+ FC62
1835+ FC62              ; store DE into (HL) and (HL+1)
1836+ FC62 73           DE2HL:      ld      (HL),E          ; LSW of size
1837+ FC63 23                       inc     HL
1838+ FC64 72                       ld      (HL),D          ; MSW of size
1839+ FC65 23                       inc     HL
1840+ FC66 C9                       ret                     ; return to caller
1841+ FC67
1842+ FC67
1843+ FC67              ; get DE from (HL) and (HL+1)
1844+ FC67 5E           HL2DE:      ld      E,(HL)          ; get LSW into E
1845+ FC68 23                       inc     HL              ; next location
1846+ FC69 56                       ld      D,(HL)          ; get MSW into D
1847+ FC6A 23                       inc     HL              ; next location
1848+ FC6B C9                       ret                     ; return to caller
1849+ FC6C
1850+ FC6C
1851+ FC6C              ; convert a 16/32-bit number into an ASCII string and print it
1852+ FC6C              ; inputs: HL pointer to 32-bit number
1853+ FC6C CD 67 FC     PRN32ASCII: call    HL2DE           ; load MSW into DE  <-- entry for 32-bit
1854+ FC6F 4E           PRN16ASCII: ld      C,(HL)          ; load LSW into BC   <-- entry for 16-bit (set DE to $0000 before to call)
1855+ FC70 23                       inc     HL
1856+ FC71 46                       ld      B,(HL)
1857+ FC72 C5                       push    BC              ; copy BC...
1858+ FC73 DD E1                    pop     IX              ; ...into IX
1859+ FC75 FD 21 24 55  PRN16ASCIX: ld      IY,TPBF1        ; number is into DEIX - now, load pointer to destination buffer
1860+ FC79 CD FE 41                 call    CLCN32          ; convert number in DEIX into ASCII number
1861+ FC7C 21 24 55                 ld      HL,TPBF1        ; address of ASCII number
1862+ FC7F 7E           PRNTSIZ:    ld      A,(HL)          ; get a char
1863+ FC80 B7                       or      A               ; is it $00 (end of string)?
1864+ FC81 C8                       ret     Z               ; yes, leave
1865+ FC82 CD 1B 1B                 call    OUTC            ; no, print char
1866+ FC85 23                       inc     HL              ; next char
1867+ FC86 18 F7                    jr      PRNTSIZ         ; repeat
1868+ FC88
1869+ FC88
1870+ FC88              ; check for non-allowed chars in disk/file names - allowed chars: '0'-'9', 'A'-'Z', '-', SPACE
1871+ FC88              ; input: A -> char to check
1872+ FC88              ; return: C is set if ERROR, reset otherwise
1873+ FC88 FE 20        CHK_NAM:    cp      SPC             ; is it a space?
1874+ FC8A C8                       ret     Z               ; return if equal (C is reset)
1875+ FC8B FE 2D                    cp      '-'             ; is it a minus?
1876+ FC8D C8                       ret     Z               ; return if equal
1877+ FC8E FE 30                    cp      '0'             ; char < '0' ?
1878+ FC90 D8                       ret     C               ; yes, disk name error
1879+ FC91 FE 3A                    cp      ':'             ; is char <= '9' ?
1880+ FC93 38 07                    jr      C,CHK_C_CF      ; yes, leave
1881+ FC95 E6 5F                    and     %01011111       ; for letters, only UPPER CASE
1882+ FC97 FE 41                    cp      'A'             ; is char >= 'A' ?
1883+ FC99 D8                       ret     C               ; no, error
1884+ FC9A FE 5B                    cp      '['             ; is char <= 'Z' ? (if yes, C=1, then C=0; otherwise, C=0 then C=1)
1885+ FC9C 3F           CHK_C_CF:   ccf                     ; Carry complement (invert Carry)
1886+ FC9D C9                       ret                     ; return to caller
1887+ FC9E
1888+ FC9E
1889+ FC9E              ; clear I/O buffer
1890+ FC9E F5           CLRIOBF:    push    AF              ; store AF
1891+ FC9F C5                       push    BC              ; store BC
1892+ FCA0 E5                       push    HL              ; store HL
1893+ FCA1 21 C0 FD                 ld 	    HL,IOBUFF       ; load address of I/O buffer
1894+ FCA4 01 02 00                 ld      BC,$0002        ; B=256 iterations ($00); C=repeat 2 times
1895+ FCA7 AF           CLRBUFF:    xor     A               ; reset A   ----- common part -----
1896+ FCA8 77           RSTIOBF:    ld      (HL),A          ; reset cell
1897+ FCA9 23                       inc     HL              ; next cell
1898+ FCAA 10 FC                    djnz    RSTIOBF         ; repeat for 256 times
1899+ FCAC 0D                       dec     C               ; decrement C
1900+ FCAD 20 F9                    jr      NZ,RSTIOBF      ; repeat if not zero
1901+ FCAF E1                       pop     HL              ; retrieve HL
1902+ FCB0 C1                       pop     BC              ; retrieve BC
1903+ FCB1 F1                       pop     AF              ; retrieve AF
1904+ FCB2 C9                       ret                     ; return to caller
1905+ FCB3
1906+ FCB3
1907+ FCB3              ; clear DOS buffer
1908+ FCB3 F5           CLRDOSBF:   push    AF              ; store AF
1909+ FCB4 C5                       push    BC              ; store BC
1910+ FCB5 E5                       push    HL              ; store HL
1911+ FCB6 21 A0 FD                 ld 	    HL,DOSBFR       ; load address of DOS buffer
1912+ FCB9 01 01 20                 ld      BC,$2001        ; B=32 iterations; C=repeat 1 time
1913+ FCBC C3 A7 FC                 jp      CLRBUFF         ; continue to common part
1914+ FCBF
1915+ FCBF
1916+ FCBF              ; clear seq. file buffer
1917+ FCBF F5           CLRSEQBF:   push    AF              ; store AF
1918+ FCC0 C5                       push    BC              ; store BC
1919+ FCC1 E5                       push    HL              ; store HL
1920+ FCC2 21 D6 FF                 ld 	    HL,SEQFL        ; load address of DOS buffer
1921+ FCC5 01 01 0B                 ld      BC,$0B01
1922+ FCC8 C3 A7 FC                 jp      CLRBUFF         ; continue to common part
1923+ FCCB
# file closed: ../include/dos/dos-1.05.asm
  95  FCCB                  INCLUDE "../include/dos/bios-1.03.asm"
# file opened: ../include/dos/bios-1.03.asm
   1+ FCCB              ; ------------------------------------------------------------------------------
   2+ FCCB              ; LM80C 64K - BIOS ROUTINES - R1.03
   3+ FCCB              ; ------------------------------------------------------------------------------
   4+ FCCB              ; The following code is intended to be used with LM80C Z80-based computer
   5+ FCCB              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ FCCB              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ FCCB              ; kind of warranty: you can use them at your own risk.
   8+ FCCB              ; You are free to use them for any non-commercial use: you are only asked to
   9+ FCCB              ; maintain the copyright notices, include this advice and the note to the
  10+ FCCB              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ FCCB              ; redistribuite them.
  12+ FCCB              ; https://www.leonardomiliani.com
  13+ FCCB              ;
  14+ FCCB              ; Please support me by visiting the following links:
  15+ FCCB              ; Main project page: https://www.leonardomiliani.com
  16+ FCCB              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ FCCB              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ FCCB              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ FCCB              ; ------------------------------------------------------------------------------
  20+ FCCB              ;
  21+ FCCB              ; ------------------------------------------------------------------------------
  22+ FCCB              ; Code Revision:
  23+ FCCB              ; R1.0  - 20210307 - first release
  24+ FCCB              ; R1.01 - 20210310 - Code optimizing & better error handling
  25+ FCCB              ; R1.02 - 20210316 - disk speed improvements with INIR and OTIR
  26+ FCCB              ; R1.03 - 20210319 - code re-organization and new positioning into RAM
  27+ FCCB              ;
  28+ FCCB              ;------------------------------------------------------------------------------
  29+ FCCB
  30+ FCCB              ; equates for CF at port $50
  31+ FCCB              CF_DATA:        equ %01010000   ; ($50) Data register (R/W)
  32+ FCCB              CF_ERR:         equ %01010001   ; ($51) Error (R)
  33+ FCCB              CF_FTR:         equ %01010001   ; ($51) Features (W)
  34+ FCCB              CF_SECCNT:      equ %01010010   ; ($52) Sector count register (R/W)
  35+ FCCB              CF_LBA0:        equ %01010011   ; ($53) LBA register 0 (bits 0-7) (R/W)
  36+ FCCB              CF_LBA1:        equ %01010100   ; ($54) LBA register 1 (bits 8-15) (R/W)
  37+ FCCB              CF_LBA2:        equ %01010101   ; ($55) LBA register 2 (bits 16-23) (R/W)
  38+ FCCB              CF_LBA3:        equ %01010110   ; ($56) LBA register 3 (bits 24-27) (R/W) - bits 28-31 must be set to 111 in LBA mode
  39+ FCCB              CF_STAT:        equ %01010111   ; ($57) Status (R)
  40+ FCCB              CF_CMD:         equ %01010111   ; ($57) Command register (W)
  41+ FCCB
  42+ FCCB
  43+ FCCB              ;------------------------------------------------------------------------------
  44+ FCCB              ; R O U T I N E S
  45+ FCCB              ;------------------------------------------------------------------------------
  46+ FCCB
  47+ FCCB              BIOSSTART:  equ     $
  48+ FCCB              ; initilialize CF to work with, wakeing it up from standby and setting it to work in 8-bit mode
  49+ FCCB CD E1 FC     CF_INIT:    call    CF_NOP          ; execute a NOP to wake up the CF
  50+ FCCE CD 2F FD                 call    CR_DEV_RDY      ; wait for CF available and ready
  51+ FCD1 D8                       ret     C               ; no card or I/O error, leave
  52+ FCD2 3E 01                    ld      A,$01           ; 8-bit mode
  53+ FCD4 D3 51                    out     (CF_FTR),A      ; set mode
  54+ FCD6 CD EA FC                 call    CF_BUSY         ; wait for CF being ready
  55+ FCD9 3E EF                    ld      A,$EF           ; command to set mode
  56+ FCDB D3 57                    out     (CF_CMD),A      ; execute command
  57+ FCDD CD EA FC                 call    CF_BUSY         ; wait for CF being ready
  58+ FCE0 C9                       ret                     ; return to caller
  59+ FCE1
  60+ FCE1
  61+ FCE1              ; a NOP command, just used to wake up the CF card
  62+ FCE1 3E 69        CF_NOP:     ld      A,$69           ; NOP command
  63+ FCE3 D3 51                    out     (CF_FTR),A      ; send it
  64+ FCE5 3E EF                    ld      A,$EF           ; set mode command
  65+ FCE7 D3 57                    out     (CF_CMD),A      ; execute NOP
  66+ FCE9 C9                       ret                     ; return to caller
  67+ FCEA
  68+ FCEA
  69+ FCEA              ; wait until BUSY bit is 0 (means CF has executed the requested job)
  70+ FCEA DB 57        CF_BUSY:    in      A,(CF_STAT)     ; read status register
  71+ FCEC 07                       rlca                    ; copy bit #7 into the Carry
  72+ FCED DA EA FC                 jp      C,CF_BUSY       ; loop while bit #7 is 1
  73+ FCF0 C9                       ret                     ; bit #7 cleared - return to caller
  74+ FCF1
  75+ FCF1
  76+ FCF1              ; check that CF is ready to get commands
  77+ FCF1 DB 57        CF_CMDRDY:  in      A,(CF_STAT)     ; read status register
  78+ FCF3 CB 47                    bit     0,A             ; any error?
  79+ FCF5 20 07                    jr      NZ,RETERR       ; yes, return error
  80+ FCF7 E6 C0                    and     %11000000       ; check only bits #6 & #7
  81+ FCF9 EE 40                    xor     %01000000       ; bit #7 (BUSY) must be 0 and bit #6 (DRVRDY) must be 1
  82+ FCFB 20 F4                    jr      NZ,CF_CMDRDY    ; wait
  83+ FCFD C9                       ret                     ; return to caller
  84+ FCFE 37           RETERR:     scf                     ; set carry flag
  85+ FCFF C9                       ret                     ; return
  86+ FD00
  87+ FD00
  88+ FD00              ; wait until data is ready to be read
  89+ FD00 DB 57        CF_DAT_RDY: in      A,(CF_STAT)     ; read status register
  90+ FD02 CB 47                    bit     0,A             ; any error?
  91+ FD04 20 F8                    jr      NZ,RETERR       ; yes, return error
  92+ FD06 E6 88                    and     %10001000       ; check only bits #7 & #3
  93+ FD08 EE 08                    xor     %00001000       ; bit #7 (BUSY) must be 0 and bit #3 (DRQ) must be 1
  94+ FD0A 20 F4                    jr      NZ,CF_DAT_RDY   ; wait until data is ready
  95+ FD0C C9                       ret                     ; return to caller
  96+ FD0D
  97+ FD0D
  98+ FD0D              ; set sector to read from/write to - sector number is into DEBC (C=LSB, D=MSB)
  99+ FD0D CD F1 FC     CF_SETSTR:  call    CF_CMDRDY       ; Make sure drive is ready for command
 100+ FD10 3E 01                    ld      A,$01           ; 1 sector at a time
 101+ FD12 D3 52                    out     (CF_SECCNT),A   ; set number of sectors
 102+ FD14 CD F1 FC                 call    CF_CMDRDY       ; Make sure drive is ready for command
 103+ FD17 79                       ld      A,C             ; load LBA0 byte
 104+ FD18 D3 53                    out     (CF_LBA0),A     ; send it
 105+ FD1A CD F1 FC                 call    CF_CMDRDY       ; Make sure drive is ready for command
 106+ FD1D 78                       ld      A,B             ; load LBA1 byte
 107+ FD1E D3 54                    out     (CF_LBA1),A     ; send it
 108+ FD20 CD F1 FC                 call    CF_CMDRDY       ; Make sure drive is ready for command
 109+ FD23 7B                       ld      A,E             ; load LBA2 byte
 110+ FD24 D3 55                    out     (CF_LBA2),A     ; send it
 111+ FD26 CD F1 FC                 call    CF_CMDRDY       ; Make sure drive is ready for command
 112+ FD29 3E E0                    ld      A,$E0           ; load LBA3 byte+master+LBA addressing
 113+ FD2B B2                       or      D               ; add LBA sector
 114+ FD2C D3 56                    out     (CF_LBA3),A     ; send it
 115+ FD2E C9                       ret                     ; return to caller
 116+ FD2F
 117+ FD2F
 118+ FD2F              ; check if device is available & ready - try a bit of times, then exit with
 119+ FD2F              ; error if no response, otherwise wait until device is ready
 120+ FD2F              ; return Carry = 0 if device is available and ready, Carry = 1 if errors
 121+ FD2F C5           CR_DEV_RDY: push    BC              ; store HL
 122+ FD30 06 00                    ld      B,$00           ; 256 tries
 123+ FD32 0E 57                    ld      C,CF_STAT       ; address of status register
 124+ FD34 ED 78        CR_DV_RD_1: in      A,(C)           ; load status register (curiously, with no CF attached, in(CF_STAT) returns %01111000)
 125+ FD36 FE 40                    cp      %01000000       ; busy=0, rdy=1
 126+ FD38 28 07                    jr      Z,CR_DV_RD_E    ; got a response, so leave
 127+ FD3A FE 50                    cp      %01010000       ; busy=0, rdy=1, dsc=1
 128+ FD3C 28 03                    jr      Z,CR_DV_RD_E    ; got a response, so leave
 129+ FD3E 10 F4                    djnz    CR_DV_RD_1      ; repeat until timeout (Carry=1 while HL<DE)
 130+ FD40 37                       scf                     ; exit with Carry = 1 (device NOT ready)
 131+ FD41 C1           CR_DV_RD_E: pop     BC              ; retrieve HL
 132+ FD42 C9                       ret                     ; return to caller
 133+ FD43
 134+ FD43
 135+ FD43              ; put the CF into stand-by mode
 136+ FD43 3E E0        CF_STANDBY: ld 	    A,$E0   		; select CF as master, driver 0, LBA mode (bits #5-7=111)
 137+ FD45 D3 56                    out 	(CF_LBA3),A     ; send configuration
 138+ FD47 3E 92                    ld      A,$92           ; standby mode
 139+ FD49 D3 57                    out     (CF_CMD),A      ; send command
 140+ FD4B CD EA FC                 call    CF_BUSY         ; wait for CF being ready
 141+ FD4E C9                       ret                     ; return to caller
 142+ FD4F
 143+ FD4F
 144+ FD4F              ;***************************************************************************
 145+ FD4F              ; CF_RD_SEC
 146+ FD4F              ; Function: load a sector (512 bytes) into RAM buffer.
 147+ FD4F              ;***************************************************************************
 148+ FD4F CD F1 FC     CF_RD_SEC:  call    CF_CMDRDY       ; Make sure drive is ready for command
 149+ FD52 D8                       ret     C               ; return if error
 150+ FD53 3E 20                    ld      A,$20           ; Prepare read command
 151+ FD55 D3 57                    out     (CF_CMD),A      ; Send read command
 152+ FD57 CD 00 FD                 call    CF_DAT_RDY      ; Wait until data is ready to be read
 153+ FD5A D8                       ret     C               ; return if error
 154+ FD5B DB 57                    in      A,(CF_STAT)     ; Read status
 155+ FD5D E6 01                    and     %00000001       ; mask off error bit
 156+ FD5F C2 4F FD                 jp      NZ,CF_RD_SEC    ; Try again if error
 157+ FD62              ; read CF buffer after it's been filled up by a previous command
 158+ FD62              ; and store data into the I/O buffer
 159+ FD62 C5           CF_RD_CMD:  push    BC              ; store BC
 160+ FD63 E5                       push    HL              ; store HL
 161+ FD64 CD 00 FD                 call    CF_DAT_RDY	    ; wait for data from CF to be ready
 162+ FD67 38 0A                    jr      C,CF_RD_EXIT    ; if error, leave
 163+ FD69 01 50 00                 ld      BC,CF_DATA      ; set 256 bytes per loop (B=$00) and CF port (C=CF_DATA)
 164+ FD6C 21 C0 FD                 ld      HL,IOBUFF       ; get starting address of I/O buffer
 165+ FD6F ED B2                    inir                    ; get 256 bytes
 166+ FD71 ED B2                    inir                    ; get 256 bytes
 167+ FD73 E1           CF_RD_EXIT: pop     HL              ; retrieve HL
 168+ FD74 C1                       pop     BC              ; retrieve BC
 169+ FD75 C9                       ret                     ; return to caller
 170+ FD76
 171+ FD76
 172+ FD76              ;***************************************************************************
 173+ FD76              ; CF_WR_SEC
 174+ FD76              ; Function: write a sector to Compact Flash - sector address is into BCDE - source address is into HL
 175+ FD76              ;***************************************************************************
 176+ FD76 C5           CF_WR_SEC:  push    BC              ; store BC
 177+ FD77 E5                       push    HL              ; store HL
 178+ FD78 CD 0D FD                 call    CF_SETSTR       ; set sector
 179+ FD7B CD F1 FC                 call    CF_CMDRDY       ; Make sure drive is ready for command
 180+ FD7E 38 17                    jr      C,CF_WR_EXIT    ; return if error
 181+ FD80 3E 30                    ld      A,$30           ; set write command
 182+ FD82 D3 57                    out     (CF_CMD),A      ; send command
 183+ FD84 CD 00 FD                 call    CF_DAT_RDY      ; Make sure drive is ready to get data
 184+ FD87 38 0E                    jr      C,CF_WR_EXIT    ; return if error
 185+ FD89 21 C0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
 186+ FD8C 01 50 00                 ld      BC,CF_DATA      ; set 256 bytes per loop (B=$00) and CF port (C=CF_DATA)
 187+ FD8F ED B3                    otir                    ; output 256 bytes
 188+ FD91 ED B3                    otir                    ; output 256 bytes
 189+ FD93 CD EA FC                 call    CF_BUSY         ; wait for CF to complete the writing
 190+ FD96 AF                       xor     A               ; clear Carry
 191+ FD97 E1           CF_WR_EXIT: pop     HL              ; retrieve HL
 192+ FD98 C1                       pop     BC              ; retrieve BC
 193+ FD99 C9                       ret                     ; return to caller
 194+ FD9A
 195+ FD9A              BIOSEND:    equ     $               ; end of BIOS
# file closed: ../include/dos/bios-1.03.asm
  96  FD9A                  INCLUDE "../include/dos/buffers-1.01.asm"
# file opened: ../include/dos/buffers-1.01.asm
   1+ FD9A              ; ------------------------------------------------------------------------------
   2+ FD9A              ; LM80C 64K - BUFFERS - R1.00
   3+ FD9A              ; ------------------------------------------------------------------------------
   4+ FD9A              ; The following code is intended to be used with LM80C Z80-based computer
   5+ FD9A              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ FD9A              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ FD9A              ; kind of warranty: you can use them at your own risk.
   8+ FD9A              ; You are free to use them for any non-commercial use: you are only asked to
   9+ FD9A              ; maintain the copyright notices, include this advice and the note to the
  10+ FD9A              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ FD9A              ; redistribuite them.
  12+ FD9A              ; https://www.leonardomiliani.com
  13+ FD9A              ;
  14+ FD9A              ; Please support me by visiting the following links:
  15+ FD9A              ; Main project page: https://www.leonardomiliani.com
  16+ FD9A              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ FD9A              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ FD9A              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ FD9A              ; ------------------------------------------------------------------------------
  20+ FD9A              ;
  21+ FD9A              ; ------------------------------------------------------------------------------
  22+ FD9A              ; Code Revision:
  23+ FD9A              ; R1.00 - 20210319 - first release
  24+ FD9A              ; R1.01 - 20210327 - added support for sequential files
  25+ FD9A              ;
  26+ FD9A              ;------------------------------------------------------------------------------
  27+ FD9A
  28+ FD9A
  29+ FD9A                          DEFINE  DOSJPTBLS   $FDA0       ; beginning of DOS jump table & buffers
  30+ FD9A FF FF FF...              BLOCK     $FDA0-BIOSEND,$FF   ; filler
  31+ FDA0
  32+ FDA0              ;DOS jump table & buffers
  33+ FDA0                          org       $FDA0
  34+ FDA0              SRTBFS:     equ     $
  35+ FDA0
  36+ FDA0                          ; buffers
  37+ FDA0 FF FF FF...  DOSBFR:     BLOCK   $20,$FF         ; 32 bytes buffer
  38+ FDC0 FF FF FF...  IOBUFF:     BLOCK   $200,$FF        ; 512 bytes buffer
  39+ FFC0
  40+ FFC0 FF FF FF...              BLOCK   $06,$FF
  41+ FFC6                          ; pointers for sequential file
  42+ FFC6              TMPNAM:     equ     $
  43+ FFC6 00 00 00...              BLOCK   $10,$00         ; 16 butes wide
  44+ FFD6 00           SEQFL:      defb    $00             ; (1) 0=no seq. file open / >1=seq. file number
  45+ FFD7 00           SEQFLS:     defb    $00             ; (1) seq. file mode: 0 read / 1 write
  46+ FFD8 00 00        SEQSCTM:    defb    $00,$00         ; (2) MSW of sector address
  47+ FFDA 00 00        SEQSCTL:    defb    $00,$00         ; (2) LSW of sector address
  48+ FFDC 00           SEQSCSZ:    defb    $00             ; (1) size in sectors
  49+ FFDD 00 00        SEQBYSZ:    defb    $00,$00         ; (2) size in bytes
  50+ FFDF 00 00        SEQPNT:     defb    $00,$00         ; (2) pointer to byte
  51+ FFE1
  52+ FFE1 FF                       defb    $FF
  53+ FFE2                          ; DOS jump table
  54+ FFE2              DOSJPTB     equ     $               ; address of 1st entry
  55+ FFE2 C3 52 F5     JPEOF:      jp      EOF             ; jump to EOF statement
  56+ FFE5 C3 80 F5     JPPUT:      jp      PUT             ; jump to PUT statement
  57+ FFE8 C3 99 F5     JPGET:      jp      GET             ; jump to GET statement
  58+ FFEB C3 AD EE     JPCLOSE:    jp      CLOSE           ; jump to CLOSE statement
  59+ FFEE C3 81 EE     JPOPEN:     jp      OPEN            ; jump to OPEN statement
  60+ FFF1 C3 B5 F0     JPDISK:     jp      DISK            ; jump to DISK statement
  61+ FFF4 C3 58 F0     JPERAS:     jp      ERASE           ; jump to ERASE statement
  62+ FFF7 C3 BC EE     JPLOAD:     jp      LOAD            ; jump to LOAD statement
  63+ FFFA C3 59 EF     JPSAVE:     jp      SAVE            ; jump to SAVE statement
  64+ FFFD C3 24 F0     JPFILS:     jp      FILES           ; jump to FILES statement
  65+ 0000
# file closed: ../include/dos/buffers-1.01.asm
  97  0000
  98  0000              ; END OF ASSEMBLY SOURCE
  99  0000              ;-------------------------------------------------------------------------------
 100  0000
# file closed: LM80C_64K-firmware-r1.16.asm

Value    Label
------ - -----------------------------------------------------------
0x018F   A_RTS_OFF
0x01AD   A_RTS_ON
0x25D4   ABPASS
0xF09E   ABRTDS
0xF0AC   ABRTXT
0x301C   ABS_
0x4176   absHL
0x1DEE X ACCSUM
0x25D3   ACPASS
0x4054   ADD30
0x4064   ADD301
0x2FB5   ADDEXP
0x315B   ADDIG
0x0A35   ADDNEWLINE
0x2D51   ADDPHL
0x557E   ADRS1
0x5582   ADRS2
0xF650   ALFLSTXT
0x28A2   ALLFOL
0x210F   ANTVLU
0x24DE   ARLDSV
0x55C6   ARREND
0x276D   ARRLP
0x2873   ASC
0x30FE   ASCTFP
0x2068   ASPCS
0x067F   ATHOME
0x3460   ATN
0x347D   ATN1
0x3487   ATNTAB
0x1E29   ATOH
0x542E   AUTOKE
0x16FE   AUTORP
0x0197   B_RTS_OFF
0x01B5 X B_RTS_ON
0x0829   BACKSPACE
0x208B   BADINP
0x1799   BAKSTK
0x2853   BAKTMP
0x53D7   basicStarted
0x54AF   BASTXT
0x3043   BCDEFP
0x058F   BEEPOFF
0x13B5   BFREE
0x40A6   BIN
0x4103   BINERR
0x40E2   BINIT
0x40D8   BINTFP
0xFD9A   BIOSEND
0xFCCB X BIOSSTART
0x40C0   BITOUT
0x40C4   BITOUT2
0x3DB6   BITS6
0x3DC0   BITS7
0x3DCB   BITS8
0x557B   BKGNDCLR
0x0008   BKSP
0x13AC   BLNSPC
0x0028   BN
0x11A5   BNMSG
0x2DB1   BNORM
0x1034 X BNPTR
0x2DB4   BNRMLP
0x5585   BPS
0x1D9C   BRK
0x5423   BRKFLG
0x5554   BRKLIN
0x1793   BRKMSG
0x13A0   BRKRET
0x0010   BS
0x2511   BSERR
0x10CF   BSMSG
0x101C X BSPTR
0x54B2   BUFFER
0x00D2   bufWrap
0x404B   BYT2ASC
0x551B   BYT_SIZ
0x2EE9   BYTSFT
0xFCEA   CF_BUSY
0x0057   CF_CMD
0xFCF1   CF_CMDRDY
0xFD00   CF_DAT_RDY
0x0050   CF_DATA
0x0051 X CF_ERR
0x0051   CF_FTR
0xFCCB   CF_INIT
0x0053   CF_LBA0
0x0054   CF_LBA1
0x0055   CF_LBA2
0x0056   CF_LBA3
0xFCE1   CF_NOP
0xFD62   CF_RD_CMD
0xFD73   CF_RD_EXIT
0xFD4F   CF_RD_SEC
0x0052   CF_SECCNT
0xFD0D   CF_SETSTR
0xFD43   CF_STANDBY
0x0057   CF_STAT
0xFD97   CF_WR_EXIT
0xFD76   CF_WR_SEC
0x2474   CFEVAL
0xF10F   CFINIT
0xFBEC   CH0TO9
0xFBF4   CH0TO9E
0x028B   CH3_TIMER
0x015D   CHABFREMPTY
0x075A   CHAR2VID
0x01FD   CHARINTOBFR
0x2422   CHARTY
0x55B0   CHASNDDTN
0xFBF7   CHATOZ
0xFBFF   CHATOZE
0x55B2   CHBSNDDTN
0x087F   CHCKYPOS
0x08EA   CHCKYPOS2
0x55B4   CHCSNDDTN
0x0D71   CHECKALT
0x0D7F   CHECKCTRL
0x0D8D   CHECKKBD
0x3811   CHECKPA
0x3812   CHECKPY
0x030F   CHECKWARM
0x266B   CHEKFN
0xF03F   CHK1AR
0xFC9C   CHK_C_CF
0xFC88   CHK_NAM
0x0E08   CHKALT
0x0E51   CHKAUTO
0x40F5   CHKBIN
0x3632   CHKCLR0
0x362E   CHKCLR1
0x029A   CHKCRSR
0x0DFF   CHKCTRL
0xFC02   CHKDSKVAL
0xFC20   CHKDSKVAL1
0xFC36   CHKDSKVAL2
0xFC35   CHKDSKVALE
0xFB59   CHKEOF
0xFB67   CHKEOFC
0x4001   CHKEY1
0x4006   CHKEY2
0x4009   CHKEY3
0x400F   CHKEY4
0x4012   CHKEY5
0xF940   CHKFLEXT
0xF1EF   CHKFLNM
0xF1F9   CHKFN1
0x0E89   CHKFNK
0x3638   CHKG2M
0x0805   CHKHL
0x2D30   CHKINK
0x0DEB   CHKLN
0x1DFB   CHKLTR
0xFC3A   CHKNMVAL
0xFC45   CHKNMVAL1
0xFC4B   CHKNMVAL2
0xFC5B   CHKNMVAL3
0x3576   CHKSCAR
0x0CF6   CHKSNDCH
0x05BC   CHKSPCK
0xFB69   CHKSQFL
0x17CD   CHKSTK
0xFAA6   CHKSTNM1
0xFAD6   CHKSTNM10
0xFAA9   CHKSTNM2
0xFAC1   CHKSTNM3
0xFACB   CHKSTNM6
0x5420   CHKSUM
0x1B10   CHKSYN
0x21EF   CHKTYP
0x08A6   CHKYPOS
0x3C7B   CHKZSER
0xF8DE   CHNGNAM
0x2884   CHR
0x5579   CHR4VID
0x5586   CHRPNT
0x426B   CHRST68
0x4A6B   CHRST88
0x073C   CHRTBL
0x3A40   CIRCLE
0x3D69   CKBPS
0x371E   CKCOL
0xFB81   CKCREN
0x0278   CKINCHAR
0xFB95   CKLSTEN
0xFB9B   CKLSTEN1
0x3529   CKMAGN
0x41FE   CLCN32
0x420E   CLCN321
0x4211   CLCN322
0x425C   CLCN323
0x4233   CLCN325
0x41D2   CLCN32T
0x41FA   CLCN32Z
0x1E4E   CLEAR
0x0672   CLEARVIDBUF
0xEEAD   CLOSE
0xF4F3   CLOSFIL
0xF510   CLOSFIL1
0x1B5C   CLOTST
0x0ADB   CLR_RAM_REG
0xFCA7   CLRBUFF
0xFCB3   CLRDOSBF
0x1972   CLREG
0x35ED   CLREX2
0x35DB   CLRG1
0x35E4   CLRG2
0x0614   CLRG2PTNTBL
0xFC9E   CLRIOBF
0x35D4   CLRMC
0x3C2D   CLRPRM
0x0C94   CLRPSGREGS
0x194D   CLRPTR
0xFCBF   CLRSEQBF
0x05B7   CLRTABLE
0x3C0F   CLRTMBF
0x35D1   CLRTXT
0x3C1E   CLRVDBF
0x34AE   CLS
0x3FA6   CLSQT
0x3FB6   CLSQT1
0x4135   CMP16
0x2D09   CMP_A
0x308C   CMPFP
0x2388   CMPLG1
0x2386   CMPLOG
0x3072   CMPNUM
0x23CA   CMPRES
0x23B2   CMPSTR
0x0020   CN
0xF1CA   CNFREQ
0xF1ED   CNFRQN
0x1165   CNMSG
0x102C X CNPTR
0x297C   CNT1INS
0x0D31   CNTCHKSND
0x35A3   CNTCKCL
0x3B02   CNTCL1
0x3B26   CNTCL2
0x3B4A   CNTCL3
0x3B70   CNTCL4
0x3B92   CNTCL5
0x3BB6   CNTCL6
0x3BDA   CNTCL7
0x5356   CNTCP2RAM
0x39E3   CNTDRW
0x2030   CNTEND
0x0EE4   CNTFNK
0x369E   CNTGPT2
0x0E83   CNTKBCK
0x2347   CNTLGC
0x3F6C   CNTLTK
0x09E9   CNTNULL
0x388F   CNTPLOT
0x38B0   CNTPLT1
0x3CE8   CNTRX2
0x0120   CNTRXCHA
0x3CB9   CNTSER
0x3CF3   CNTSER2
0x3D05   CNTSER3
0x3C0A   CNTVALY
0x1C99   CNTWTSP
0x29B3   CNTZIN
0x310A   CNVNUM
0x12C1   COLD
0x0304   COLDSTART
0x3586   COLOR
0x541D   COMMAN
0x2E11   COMPL
0x27E8   CONCAT
0x313A   CONEXP
0x2DAE   CONPOS
0x1DD5   CONT
0x071D   CONT_POS_CURS
0x555A   CONTAD
0x0890   CONTCRSLFT
0x08FD   CONTCRSRGT
0x55BD   CONTROLKEYS
0x22DA   CONVAR
0x02F8   CORW
0x33E4   COS
0x1B0A   CPDEHL
0x1346   CPDSTB
0x3F03   CPKEY
0x3F22   CPKEY1
0x3F13   CPKEY2
0x3F1A   CPKEY3
0x3F2A   CPKYEND
0x1A4F   CPYLIT
0x000D   CR
0xFD2F   CR_DEV_RDY
0xFD34   CR_DV_RD_1
0xFD41   CR_DV_RD_E
0x2531   CRARLP
0x2516   CREARY
0x1F5B   CRESTR
0x09BB   CRGRETURN
0x19B0   CRNCLP
0x001F   CRSDN
0x001C   CRSLFT
0x5576   CRSR_STATE
0x001D   CRSRGT
0x001E   CRSUP
0x26A4   CRTMST
0x26B0   CRTST
0x26C6   CRTSTE
0x19A7   CRUNCH
0x000C   CS
0x12CE   CSTART
0x5560   CTC0IV
0x5563   CTC1IV
0x5566   CTC2IV
0x5569   CTC3IV
0x3E65   CTC_CFG
0x0010   CTC_CH0
0x0011   CTC_CH1
0x0012   CTC_CH2
0x0013   CTC_CH3
0x036A   CTCCONF
0x541F   CTLOFG
0x3855   CTPOINT
0x0003   CTRLC
0x0007   CTRLG
0x000F   CTRLO
0x0011   CTRLQ
0x0012   CTRLR
0x0013   CTRLS
0x0015   CTRLU
0x2BDD   CTSNDC
0x557C   CUR_POS
0x554B   CUROPR
0x550C   CURPOS
0x093B   CURSOR_OFF
0x0926   CURSOR_ON
0x0906   CURSORDOWN
0x086C   CURSORLEFT
0x08D1   CURSORRIGHT
0x08B8   CURSORUP
0x0038   D0
0x1236   D0MSG
0x1044 X D0PTR
0x003A   D1
0x1246   D1MSG
0x1046 X D1PRT
0x003C   D2
0xF61D   D2ERR
0x1252   D2MSG
0x1048 X D2PRT
0x003E   D3
0x1260   D3MSG
0x104A X D3PRT
0x0040   D4
0x1265   D4MSG
0x104C X D4PTR
0x0042   D5
0x126A   D5MSG
0x104E X D5PTR
0x0044   D6
0x1274   D6MSG
0x1050 X D6PTR
0x0046   D7
0x1288   D7MSG
0x1052 X D7PRT
0x0048   D8
0x1294   D8MSG
0x1054 X D8PTR
0x004A   D9
0x12A3   D9MSG
0x1056 X D9PTR
0x004C   DA
0x12B5   DAMSG
0x1058 X DAPTR
0x5515   DAT_STRT
0x1F02   DATA
0x5587   DATABT
0x550F   DATFLG
0x554F   DATLIN
0x180A   DATSNR
0x558E   DC
0x30C3   DCBCDE
0x0012   DD
0x1819   DDERR
0x10DD   DDMSG
0x101E X DDPTR
0xFC62   DE2HL
0x054D   DEC_D
0x3EF5   DECLN1
0x34CA   DEEK
0x25E8   DEF
0x1700 X DEFFNKS
0x3D50   DEFSER
0x2539   DEFSIZ
0x1E0F   DEINT
0x007F   DEL
0x1A7F   DELCHR
0x1E09   DEPINT
0x3052   DETHL4
0x3054   DETHLB
0x3204   DIGTXT
0x23F4   DIM
0x23EB   DIMRET
0x1B3F   DINPOS
0x2EEE   DINT
0x5517   DIR_SCT
0x5513   DIR_STRT
0x3E81   DIRMOD
0xF0B5   DISK
0x2A8B   DISNMI
0x2F4B   DIV
0x53E5   DIV1
0x2F3F   DIV10
0x53E9   DIV2
0x53ED   DIV3
0x53F0   DIV4
0x419F   DIV_16_16
0x4190   DIV_16_8
0x4193   DIV_16_8LP
0x41B4   DIV_32_16
0x41B9   DIV_32_16LP
0x41CA   DIV_32_16OF
0x41CD   DIV_32_16SB
0x4180   DIV_8_8
0x4184   DIV_8_8LOOP
0x2F72   DIVLP
0x53E4   DIVSUP
0x5580   DKLNPT
0x557E   DKNMPT
0x3AC4   DLSZ
0x198B   DOAGN
0x05D4   DOCOLDRESET
0x2035   DOCOM
0x1A5F   DODEL
0x3244   DOEBIT
0x2615   DOFN
0x34D5   DOKE
0x55C1   DOS_EN
0xF038   DOS_ERR
0xF291   DOS_FT1
0xF342   DOS_FT10
0xF2AB   DOS_FT2
0xF346   DOS_FT7
0xF348   DOS_FT8
0xF335   DOS_FT9
0xF31B   DOS_FTA
0xF283   DOS_FTC
0xFDA0   DOSBFR
0x5512   DOSER
0xFFE2   DOSJPTB
0x1404   DOSMSG
0x2063   DOSPC
0xEE70   DOSSTART
0xF62F   DOSVERSERR
0x204E   DOTAB
0x3136   DPOINT
0x3907   DRAW
0x3AE0   DRWCRL
0xF216   DSK_INIT
0xF34E   DSK_RNM
0xEE7F   DSKDIRADR
0xF0FC   DSKFRM
0xF620   DSKFULL
0xEE70   DSKHDR
0xF639   DSKNMTX
0xF198   DSKRNM
0xF18B   DSKUND
0xFAE4   DSKUNDFL
0xFAF0   DSKUNDFL1
0xFB21   DSKUNDFL2
0xFB0C   DSKUNDPR
0xFB26   DSKUNDTXT
0x26B4   DTSTR
0xF623   DUPLERR
0x41A4   DV16_16_LP
0x2F4D   DVBCDE
0x5590   DX
0x3A13   DXGR
0x5592   DY
0x0014   DZ
0x1813   DZERR
0x10F2   DZMSG
0x1020 X DZPTR
0x558A   E2
0x1A73   ECHDEL
0x031C   ECHO_CHAR
0x317D   EDIGIT
0x291B   EMPTINS
0x0C90   EMPTSNDBFR
0x0AD2   EMPTVRM
0x0AC8   EMPTY_VRAM
0x014F   EMPTYCHABFR
0x0181   EMPTYCHBBFR
0x0603   EMPTYG2
0x0633   EMPTYMC
0x05DB   EMPTYVIDBUF
0x3E3A   ENCHB
0x537A   END_OF_FW
0x1A56   ENDBUF
0x3149   ENDCON
0x3ADC   ENDCRL
0x0DD3   ENDCTRLCK
0x2598   ENDDIM
0x3A3C   ENDDRAW
0x2D42   ENDINK
0x201C   ENDINP
0x552E   ENDMEM
0x2416   ENDNAM
0x0A42   ENDOFLN
0x1DAB   ENDPRG
0x25AD   ENDTMR
0x5580   ENDTXT
0x04E7   ENDVDPSET
0x17D6   ENFMEM
0xF552   EOF
0xF568   EOF1
0x5588   ER
0x39B7   ER2
0xF058   ERASE
0x056C   ERASECLRTBL
0xF090   ERASED
0x184E   ERRIN
0x1DCF   ERRINT
0x5558   ERRLIN
0x1782   ERRMSG
0x182A   ERROR
0x105A X ERRORS
0x100C   ERRTBL
0xF082   ERSTX
0x001B   ESC
0x21FC   EVAL
0x21FF   EVAL1
0x2208   EVAL2
0x220B   EVAL3
0x22C1   EVLPAR
0x23D4   EVNOT
0x1D39   EXCUTE
0x04A5   EXG2MD
0x07B6   EXITCHAR2VID
0x0939   EXITCURSOR_ON
0x0923   EXITCURSORDOWN
0x0893   EXITCURSORLEFT
0x0903   EXITCURSORRGHT
0x08CF   EXITCURSORUP
0x17EA   EXITGM
0x380D   EXITPA2
0x3809   EXITPAI
0x4158   EXMUL16
0x3E48   EXNRM
0x32DE   EXP
0x3128   EXPLP
0x331E   EXPTAB
0x3256   EXPTEN
0x216B   EXTIG
0x2194   FANDT
0x0008   FC
0x1E24   FCERR
0x1093   FCMSG
0x1014 X FCPTR
0x217B   FDTLP
0xFA87   FIL_ERA1
0xFA92   FIL_ERA2
0xFA95   FIL_ERA3
0xFA66   FIL_ERA5
0xFA5F   FIL_ERA6
0xFA22   FIL_ERASE
0xF61A   FILALROP
0xFA9F   FILE_EXIST
0xF024   FILES
0xF794   FILETP
0xF617   FILOPCLER
0x2574   FINDEL
0x0DE9   FINDKEY
0x07C4   FLASHCURSOR
0xFAE2   FLEXST
0x3002   FLGDIF
0x3009   FLGREL
0xF629   FLNTFND
0x00EC   FMVEREND
0x55CC   FNARG
0x142C   FNCTAB
0x24E4   FNDARY
0x2579   FNDELP
0x1920   FNDEND
0xFB31   FNDFRENTR
0xFB3D   FNDFRENTR1
0xFB40   FNDFRENTR2
0xFB50   FNDFRENTR3
0xFB45   FNDFRENTR4
0x2A6D   FNDNUM
0x1C4D   FNDTOK
0x245B   FNDVAR
0x19DA   FNDWRD
0x542F   FNKEYS
0x0F04   FNKEYSORD
0x22EB   FNOFST
0x55CA   FNRGNM
0x2469   FNTHR
0x231C   FNVAL
0x2234   FOPRND
0x1CA0   FOR
0x5551   FORFLG
0x1CD0   FORFND
0x1CB4   FORSLP
0x2D60   FPADD
0x3038   FPBCDE
0x55D3   FPEXP
0x309F   FPINT
0x2E9B   FPMULT
0x55D0   FPREG
0x2DF8   FPROND
0x1E03   FPSINT
0x304F   FPTHL
0x25B2   FRE
0x25CE   FRENUM
0x557A   FRGNDCLR
0x22DD   FRMEVL
0xF15E   FRMTXT
0x00D0 X FWVER
0x0420   G1MD
0x0460   G2MD
0x2735   GARBGE
0x2738   GARBLP
0xF599   GET
0xF608   GET1
0xF5F7   GET2
0xEF21   GET4AR
0x1D59   GETCHR
0x187D   GETCMD
0xF60F   GETER
0x4081   GETHEX
0x34AC   GETINP
0x2A70   GETINT
0x2868   GETLEN
0x1A90   GETLIN
0x1E2A   GETLN
0x21EA   GETNUM
0x19F5   GETNXT
0x2832   GETSTR
0x23F9   GETVAR
0x002A   GM
0x3C46   GMERR
0x11B0   GMMSG
0x1AE7   GMNCR
0x1036 X GMPRT
0x276C   GNXARY
0x2324   GOFUNC
0x1EAE   GOSUB
0x1EBF   GOTO
0x3701   GPCPCH1
0x36B3   GPNT
0x36DD   GPNTCO1
0x3641   GPRINT
0x278C   GRBARY
0x270D   GRBDON
0x2746   GRBLP
0x2835   GSTRCU
0x2839   GSTRDE
0x2838   GSTRHL
0x2877 X GTFLNM
0x23FE   GTFNAM
0x1E2D   GTLNLP
0xFB89   GTNXTEN
0x31CE   GTSIXD
0x20E7   GTVLUS
0x5580   GX
0x5582   GY
0x3275   HALF
0x342E   HALFPI
0x0026   HE
0x3E8A   HELP
0x119A   HEMSG
0x1032 X HEPTR
0x4015   HEX
0x402D   HEX1
0x402F   HEX2
0x403C   HEX3
0x403E   HEX4
0x4098   HEXIT
0x4074   HEXLP
0x4079   HEXLP1
0x4068   HEXTFP
0xFC67   HL2DE
0x072B   HL2XY
0x3EA3   HLPERR
0x542B   HLPLN
0x0019   HOME
0x0032   HP
0x1205   HPMSG
0x103E X HPPTR
0x40A1   HXERR
0x0016   ID
0x1103   IDMSG
0x1022 X IDPTR
0x265D   IDTEST
0x1F91   IF
0x1FA8   IF0
0x1FB1   IF1
0x1F9F   IFGO
0x1D40   IFJMP
0x0034   IM
0x1825   IMERR
0x120F   IMMSG
0x1040 X IMPRT
0x304D   INCHL
0x1B3B   INCLEN
0x0294   INCTMR3
0x17B3   INDFND
0x18E8   INEWLN
0x02AE   INIT_HW
0x02B1   INIT_HW2
0x16A9   INITAB
0x1782   INITBE
0x0340   initCTC
0x0C8A   initPSG
0x4127   INITST
0x03D1   initVDP
0x2CFE   INKEY
0x2D18   INKEY2
0x1789   INMSG
0x2A2D   INP
0x2139   INPBIN
0x1DA8   INPBRK
0x541A   INPORT
0xF68A   INPR1
0x5419   INPSUB
0x209C   INPUT
0x31D7   INRNG
0x07E7   INSERTKEY
0x001A   INSRT
0x28C4   INSTR
0x30CA   INT
0x195C   INTVAR
0x3020   INVSGN
0xFDC0   IOBUFF
0x212A   ITMSEP
0xFFEB   JPCLOSE
0xFFF1   JPDISK
0xFFE2   JPEOF
0xFFF4   JPERAS
0xFFFD   JPFILS
0xFFE8   JPGET
0xFFF7   JPLOAD
0xFFEE   JPOPEN
0xFFE5   JPPUT
0xFFFA   JPSAVE
0x3260   JSTZER
0x55B6   KBDNPT
0x0F0C   KBMAP
0x0F8C   KBMAP_ALT
0x0FCC   KBMAP_CTRL
0x0F4C   KBMAP_SFT
0x55B7   KBTMP
0x3EA8   KEY
0x0D51   KEYBOARD
0x3EC5   KEYCH
0x542D   KEYDEL
0x55BB   KEYTMR
0x21DA   KILFOR
0x1A8A   KILIN
0x55B9   LASTKEYPRSD
0x550D   LCRFLG
0x04DE   LDCLRTBEX2
0x0457   LDCLRTBMD1
0x05F4   LDCOLSTOEMPTY
0xEEF2   LDEND
0xFBA7   LDENTRIES
0xEEF9   LDERR
0xF9BB   LDFL1
0xF9BF   LDFL2
0xF9DF   LDFL3
0xF99F   LDFL4
0xFA16   LDFL5
0xFA1D   LDFLEX
0x0ED0   LDFNKEYCHR
0x17F7   LDG1
0x1808   LDG1ND
0x3F57   LDKEY
0xFBB6   LDMSCT
0x0AF8   LDREGVLS
0xEF0F   LDSVPT
0x2894   LEFT
0x2864   LEN
0x1F19   LET
0x1F6C   LETNUM
0x1F34   LETSTR
0x000A   LF
0x2A23   LFRGNM
0x5429   LINEAT
0x3189   LINEIN
0x18D1   LINFND
0x1B77   LIST
0x1C0A   LISTLP
0xF95D   LK4FILE
0xF960   LK4FILE1
0x0B4A   LM80CLOGO
0x557C   LNS1
0x5580   LNS2
0xEEBC   LOAD
0x0708   LOAD_CRSR_POS
0x0B02   LOADCHARSET
0x35F4   LOADCLR
0x3046   LOADFP
0x0597   LOADLOGOCHRS
0x0E0F   LOADMAP
0x096C   LOADNEXTCOL
0xEEDD   LOADST
0x2B43   LOCATE
0xF62C   LODERR
0xF972   LODFILE
0x2E5A   LOG
0x526B   LOGOFONT
0x2E4D   LOGTAB
0x179D   LOKFOR
0x554D   LOOPST
0x001C   LS
0x113A   LSMSG
0x1028 X LSPTR
0x1BA3   LST01
0x1BA6   LST01H
0x1C01   LST02
0x1BEA   LST03
0x1BFE   LST05
0x1BC1   LST06
0x1C2F   LST07
0x1C2C   LST08
0xF66B   LST_FILES
0x1BD2   LSTALL
0x5552   LSTBIN
0x5577   LSTCSRSTA
0xF6BE   LSTFILES1
0xF6C1   LSTFILES2
0xF6EB   LSTFILES20
0xF6F3   LSTFILES21
0xF6FB   LSTFILES22
0xF6CF   LSTFILES3
0xF72A   LSTFILES6
0xF6FE   LSTFILESPR
0x3F2C   LSTKEYS
0x1C3B   LSTLP2
0x1C3E   LSTLP3
0x1BC5   LSTNOT
0x5510   LSTRAM
0x5415   LSTRND
0x5520   LSW_SCT
0x2144   LTSTND
0x0863   LVBKSP
0x05D2   LVCKSPLK
0x29A9   LVINSTR
0x0EB3   LVKBRDCHK2
0x0131   LVRXCHA
0x1C85   LVSRLN
0x541C   LWIDTH
0x2A73   MAKINT
0x31F3   MAKNUM
0x3112   MANLP
0x1A27   MATCH
0x0482   MCMD
0x1421   MEMMSG
0x29C4   MID
0x289A   MID1
0x2A28   MIDNUM
0x2DA0   MINCDE
0x22C9   MINUS
0x3621   MIXCLRS
0x557C   MIXCOL
0x26A1   MKTMST
0x30EB   MLDBLP
0x30E3   MLDEBC
0x1306   MLOOP
0x4148   MLP
0x414F   MLP1
0x2FE0   MLSP10
0x0CEC   MNGSNDS
0x1303   MNOASK
0x378E   MNPAINT
0x0024   MO
0x2EF6   MOD
0x118A   MOMSG
0x4108   MONOUT
0x1030 X MOPTR
0x2150   MORDT
0x1A99   MORINP
0x1907   MOVBUF
0x06CF   MOVCRS
0x1A2F   MOVDIR
0x17C2   MOVLP
0x06D5   MOVSHOWCRS
0x17BF   MOVSTR
0x17BC   MOVUP
0x1FBF   MRPRNT
0x0376   MSGTXT1
0x03B4   MSGTXT2
0x12F0   MSIZE
0xF13E   MSPTOK
0xF146   MSTTXT
0x551E   MSW_SCT
0x4165   MU32_1
0x4172   MU32_2
0x4140   MUL16
0x2EC6   MUL8LP
0x4167   MUL_32L
0x415A   MUL_U32
0x2E92   MULLN2
0x2E99   MULT
0x2EBD   MULT8
0x3154   MULTEN
0x55E2   MULVAL
0x0850   MVBKSP
0x0895   MVCRS2LFT
0x1F63   MVSTPT
0xF626   NAMERR
0x20E3   NEDMOR
0x328B   NEGAFT
0x4179   negHL
0x194C   NEW
0x06EA   NEWCRSRCOORD
0x0E63   NEWKEY
0x2072   NEXITM
0x219F   NEXT
0x21A2   NEXT1
0x0000   NF
0x1816   NFERR
0x105A   NFMSG
0x100C X NFPTR
0x0000   NLLCR
0x2A9C   NM1
0x2A81   NMI
0x2AAD   NMI2
0x2AB8   NMIDINT
0x2AB1   NMIEINT
0x5422   NMIFLG
0x2ABB   NMIINT
0x53DB   NMIUSR
0x2AC7   NMIVR1
0x0CBE   NOBEEP
0x0CDA   NOBPDAT
0x1A1F   NOCHNG
0x3263   NOENED
0x38D0   NOGD
0x2C61   NOISUP
0x0DD7   NOKEYPRSD
0x1DBE   NOLIN
0x2ED7   NOMADD
0x30F9   NOMLAD
0x20B6   NOPMPT
0x2DCB   NORMAL
0x2C8B   NOS1
0x2C9E   NOS2
0x2CB7   NOS3
0x1A16   NOSPC
0x4094   NOSUB7
0x2D7A   NOSWAP
0x2AF9   NOSYSPR
0x229E   NOTAMP
0x0208   NOTFULL
0x023F   NOTRDWRAP
0x2431   NOTSTR
0x0214   NOTWRAP
0x2A53   NOXOR
0x0036   NR
0x1828   NRERR
0x1225   NRMSG
0x1042 X NRPRT
0x2441   NSCFOR
0x5519   NTR_NBR
0x541E   NULFLG
0x319C   NUMASC
0x5588   NUMCHR
0x24F8   NXTARY
0x1A05   NXTBYT
0x0B16   NXTCHAR
0x1A46   NXTCHR
0x077A   NXTCPCK
0x55C8   NXTDAT
0x1F01   NXTDTA
0x0816   NXTINST
0x20DB   NXTITM
0x1C65   NXTLN
0x376F   NXTLOOP
0x5556   NXTOPR
0x1F08   NXTSTL
0x1F0B   NXTSTT
0x0006   OD
0x1087   ODMSG
0x1012 X ODPTR
0x178E   OKMSG
0x000C   OM
0x17E5   OMERR
0x10B2   OMMSG
0x1018 X OMPTR
0x1F73   ON
0x1F82   ONGO
0x1F83   ONGOLP
0x1D41   ONJMP
0xEE81   OPEN
0xF49A   OPFLRS
0xF3E9   OPNFIL
0xF4AB   OPNFILPT
0xF465   OPNFRD
0xF48F   OPNFRD1
0xF474   OPNFRD2
0xF46C   OPNFRD3
0x21F8   OPNPAR
0x3FB8   OPNQT
0x3FCE   OPNQT1
0xF4B3   OPNRDDET
0xF176   OPRCMP
0x2273   OPRND
0x5586   ORGSP
0x001A   OS
0x1126   OSMSG
0x1026 X OSPTR
0x1A87   OTKLN
0x53E2   OTPORT
0x1B1B   OUTC
0x3254   OUTEXP
0x1B01   OUTIT
0x1B04   OUTNBS
0x412F   OUTNCR
0x53E1   OUTSUB
0x1C57   OUTWRD
0x000A   OV
0x181F   OVERR
0x10A9   OVMSG
0x1016 X OVPTR
0x2FD3   OVTST1
0x2FD8   OVTST2
0x2FD9   OVTST3
0x3178   PADD
0x3731   PAINT
0x377C   PAINT0
0x378B   PAINT1
0x378A   PAINT11
0x37BE   PAINT2
0x37D1   PAINT3
0x37F0   PAINT4
0x3802   PAINT5
0x233D   PAND
0x2362 X PAND1
0x5588   PARBT
0x25E3   PASSA
0x34EC   PAUSE
0x55D5   PBUFF
0x2B09   PEEK
0x1DA3   PEND
0x3035   PHLTFP
0x0002 X PIO_CA
0x0003   PIO_CB
0x0000 X PIO_DA
0x0001   PIO_DB
0x2B1D   PKEPRMS
0x07C3   PLACEHOLDER
0x3874   PLOT
0x3AD3   PLTCRL
0x2E05   PLUCDE
0x2DD3   PNORM
0x5584   PNT
0x0EB0   PNT2VD
0x384B   PNTEND
0x3869   PNTRTN
0xF750   PNTSTATS
0x3821   POINT
0x2B33   POKE
0x2727   POPAF
0x2851   POPHL
0x2EE7   POPHRT
0x186F   POPNOK
0x2340   POR
0x2367   POR1
0x25E0   POS
0x06C5   POS_CURSOR
0x0A68   POS_TB_CRS_32
0x0A98   POS_TB_CRS_40
0x1E06 X POSINT
0x2A39   POUT
0x3299   POWER
0x32A9   POWER1
0x32C6   POWER2
0x3279   POWERS
0x1FC3   PRINT
0x168B   PRITAB
0xFC6F   PRN16ASCII
0xFC75   PRN16ASCIX
0xFC6C   PRN32ASCII
0x2026   PRNTCRLF
0x0EF7   PRNTFNK
0x0EB8   PRNTFNKEY
0x3191   PRNTHL
0x1FC6   PRNTLP
0x2009   PRNTNB
0x1870   PRNTOK
0x0A21   PRNTRETURN
0xFC7F   PRNTSIZ
0x200D   PRNTST
0x5578   PRNTVIDEO
0x26F1   PRNUMS
0x1AB2   PROCES
0x55C2   PROGND
0x55E5   PROGST
0x198F   PROMPT
0x26F2   PRS
0x26F5   PRS1
0x26FC   PRSLP
0x3F81   PRTCHR
0x3FD0   PRTCKEY
0x3FDD   PRTEND
0x3FD1   PRTK1
0x3F69   PRTK3
0x3F3E   PRTK4
0x5584   PRTNUM
0x0041   PSG_DAT
0x0040   PSG_REG
0x2D5B   PSUB
0x5584   PT
0x5586   PT1
0x5588   PT2
0xFB76   PT2FSEN
0x3F9E   PTCHR1
0x186B   PTLN
0x1914   PTRLP
0xF580   PUT
0x1AED   PUTBUF
0x0EA3   PUTCHRBUF
0x0EEA   PUTCHRBUF1
0x07E3   PUTCRSCHR
0x1AF2   PUTCTL
0x1D15   PUTFID
0xF371   PUTFIL
0xF3E2   PUTFIL2
0xF3AD   PUTNXSC
0x38D4   PXLSET
0x2345   PXOR
0x236F   PXOR1
0x26B7   QTSTLP
0x26B1   QTSTR
0x3432   QUARTR
0x5588   RADIUS
0x5522   RAM_PTR
0x532B   RAMRUN
0x027D   RAWPRINT
0x20D6   READ
0x0689   READ_VIDEO_LOC
0x06BE   READ_VSTAT
0x5553   READFG
0x0D3C   READKBLN
0x2079   REDO
0x1F04   REM
0xEFE1   RENFIL
0x2F85   RESDIV
0x33D0   RESEED
0x410B   RESET
0x4123   RESETE
0x3EB5   RESFN
0x0365   RESTMR
0x1D7E   RESTNL
0x1D69   RESTOR
0x2DC6   RESZER
0xF631   RET_ERR
0x24A8   RETADR
0xF57C   RETEOF
0xFCFE   RETERR
0x300E   RETINT
0x1EFC   RETLIN
0x1A2B   RETNAD
0x24AB   RETNUL
0x22D5   RETNUM
0x3000   RETREL
0x1EDD   RETURN
0x0004   RG
0x1072   RGMSG
0x1010 X RGPTR
0x29BA   RIGHT
0x2898   RIGHT1
0x5424   RINPUT
0x2218   RLTLP
0x336F   RND
0x33AB   RND1
0x33C7   RND2
0xFBD9   RND8
0xFBC2   RND_ID
0xFBC5   RND_ID1
0xF1BC   RNDKTX
0x33D8   RNDTAB
0x3266   RNGTST
0x5340   ROM2RAM
0x2DE7   RONDB
0x2DE6   RONDUP
0x2D4E   ROUND
0x2953   RP2INST
0x3C17   RPCLTMB
0x36C8   RPGPNT
0x0579   RPT100
0x051A   RPT101
0x051D   RPT102
0x0533   RPT103
0x053B   RPT104
0x3A97   RPTCL1
0x076D   RPTCPCK
0x3A84   RPTCRL
0x3C26   RPTCVBF
0x39C7   RPTDRW
0x05FA   RPTEMPTYBUF
0x09AF   RPTEMPTYROW
0x065F   RPTFLL1
0x292C   RPTINST
0x0D91   RPTKBDRD
0x35FD   RPTLDCL
0x09D9   RPTNLLSRC
0x0A5A   RPTNLLSRC2
0x34FA   RPTPS
0x3C8C   RPTRSSR
0x0CC4   RPTWLCMBP
0x2BB8   RPVOLCG
0x3172   RSCALE
0x0000 X RST00
0x0008 X RST08
0x0010 X RST10
0x0018 X RST18
0x06FF   RSTCHRCRS
0xFCA8   RSTIOBF
0x0C9B   RSTPSG
0x3C7F   RSTSERS
0x29DD   RSTSTR
0x0AE1   RSTVDPRAMREG
0x1E9A   RUN
0x1D19   RUNCNT
0x1958   RUNFST
0x1EBE   RUNLIN
0xF0F7   RWMSSC
0x0100   RX_CHA_AVAIL
0x0165   RX_CHB_AVAIL
0x022A   RXA
0x0255   RXA_EXIT
0x3CEF   RXEND
0x299E   RZINSTR
0x002E   SA
0x11D6   SAMSG
0x103A X SAPTR
0xEF59   SAVE
0xEFB3   SAVE1
0xEFC8   SAVESCT
0x2DC7   SAVEXP
0xF7A8   SAVFILE
0xF7D6   SAVFL1
0xF7FB   SAVFL10
0xF851   SAVFL12
0xF8CC   SAVFL2
0xF7CE   SAVFL3
0xF80D   SAVFL4
0xF7E9   SAVFL6
0xF8A4   SAVFL9
0xF858   SAVFLEXT
0x1D0C   SAVSTP
0x268C   SAVSTR
0x24B6   SBSCPT
0x002C   SC
0x2E25   SCALE
0x2E27   SCALLP
0x313D   SCALMI
0x3153   SCALPL
0x3E74   SCERR
0x3E70   SCERR1
0x11C1   SCMSG
0x27C3   SCNEND
0x24BC   SCPTLP
0x1038 X SCPTR
0x5573   SCR_CUR_NX
0x5574   SCR_CUR_NY
0x5571   SCR_CURS_X
0x5572   SCR_CURS_Y
0x556E   SCR_MODE
0x556F   SCR_NAM_TB
0x5575   SCR_ORG_CHR
0x556D   SCR_SIZE_H
0x556C   SCR_SIZE_W
0x350B   SCREEN
0x095A   SCROLLNXTRW
0x0942   SCROLLUP
0x551D   SCT_SIZ
0x3537   SCVDP
0x19F3   SEARCH
0x53F2   SEED
0x0B18   SENDCHRPTRNS
0x0E70   SENDKEY
0x0CC1   SENDSND
0xFFDD   SEQBYSZ
0xFFD6   SEQFL
0xFFD7   SEQFLS
0xFFDF   SEQPNT
0xFFDC   SEQSCSZ
0xFFDA   SEQSCTL
0xFFD8   SEQSCTM
0x0058   SER_BUFSIZE
0x0005   SER_EMPTYSIZE
0x0050   SER_FULLSIZE
0x55BF   SERABITS
0x55C0   SERBBITS
0x537A   SERBUF_START
0x53D6   serBufUsed
0x3C4B   SERIAL
0x55BE   SERIALS_EN
0x53D2   serInPtr
0x3CB5   SERLED
0x53D4   serRdPtr
0x3C6C   SERVAR
0x3D93   SET_CTC
0x0AE6   SET_GFX_MODE
0x0AEE   SET_GFX_MODE2
0x3D82   SET_PT
0x0583   SETBEEP
0x3608   SETBRCL
0x07A3   SETCRSRY
0x07A4   SETCSRCOORDS
0x1359   SETDSR
0x2A5D   SETIO
0x1A3D   SETLIT
0x0657   SETNAMETABLE
0x0E41   SETNEWAUTO
0x135C   SETNOD
0x3DCF   SETPAR
0x3DDA   SETPAR2
0xFB6E   SETPTEN
0x190F   SETPTR
0x3FDF   SETREP
0x3D5D   SETSER
0x0CE2   SETSNDREG
0x132A   SETTOP
0x138D   SETTP1
0x135D X SETTRAM
0x0669   SETVDPADRS
0x18D9   SFTPRG
0x3006   SGN
0x232D   SGNEXP
0x55D4   SGNRES
0x04F2   SHOW_LOGO
0x2E34   SHRITE
0x2E37   SHRLP
0x2E3B   SHRT1
0x13C3   SIGNON
0x305D   SIGNS
0x33EA   SIN
0x341A   SIN1
0x3436   SINTAB
0x01CB   SIO_A_DI
0x01E3   SIO_A_EI
0x0336   SIO_A_SETS
0x01D3   SIO_B_DI
0x01EB   SIO_B_EI
0x033C X SIO_B_SETS
0x0022   SIO_CA
0x0023   SIO_CB
0x0020   SIO_DA
0x0021   SIO_DB
0x019D   SIO_RTS_OFF
0x01BB   SIO_RTS_ON
0x01D9   SIO_RXDI
0x01F1   SIO_RXEN
0x558A   SIOBFR
0x31B9   SIXDIG
0x2757   SMPVAR
0x334E   SMSER1
0x0002   SN
0x2C26   SND1
0x1B4E   SND2VID
0x0A02   SNDCHRTOBFR
0x064D   SNDCLRSET
0x0E91   SNDKEYTOBFR
0x05AD   SNDLOGPT
0x2C5B   SNDOVR
0x0CA8   SNDREGCFG
0x1810   SNERR
0x106B   SNMSG
0x100E X SNPTR
0x0030   SO
0x3E79   SOERR
0x11EF   SOMSG
0x103C X SOPTR
0x2BCF   SOUND
0x0020   SPC
0x31AA   SPCFST
0x206A   SPCLP
0x0136   SPEC_RXA_CNDT
0x0168   SPEC_RXB_CNDT
0x3290   SQR
0x1C73   SRCHLIN
0x192C   SRCHLN
0x192F   SRCHLP
0x1C79   SRCLN
0x1C7A   SRCLN1
0x2B75   SREG
0x3E0F   SRLCNT
0x3CAF   SRPT2
0xFDA0 X SRTBFS
0x2D2C   SRTINK
0x552C   SRTMEM
0x557E   SRTTXT
0x2CEA   SSTAT
0x281F   SSTSA
0x001E   ST
0x54B7   STACK
0x3028   STAKFP
0x1D92   STALL
0x12C7   STARTB
0x064A   STARTEMPTY
0x55BA   STATUSKEY
0x225C   STKTHS
0x5649   STLOOK
0x114A   STMSG
0x1DA1   STOP
0x1E77   STORED
0x5589   STPBT
0x279A   STPOOL
0x102A X STPTR
0x267C   STR
0x2682   STR1
0x279D   STRADD
0x5549   STRBOT
0x39C4   STRE2
0x212D   STRENT
0x3DF7   STRPAR
0x5427   STRSPC
0x2014   STTLIN
0x2D5D   SUBCDE
0x2D57   SUBPHL
0x3357   SUMLP
0x333F   SUMSER
0x3E4F   SUP_BPS
0x3238   SUPTLZ
0xF515   SVCRNTSE
0xEFDA   SVEND
0xF85D   SVENTRY
0xF00F   SVERR
0x2415   SVNAM2
0xF4E7   SVSQFLNM
0x26AA   SVSTAD
0x558C   SX
0x558E   SY
0x2ADB   SYS
0x12D5   SYSINIT
0x2B07   SYSRET
0x344B   TAN
0x5509   TEMPSTACK
0x0DC0   TESTALT
0x0DCD   TESTCTRL
0x2729   TESTOS
0x270B   TESTR
0x558C   TF
0xF661   TLFLSTX
0xF645   TLSCTTX
0x0018   TM
0x1822   TMERR
0x1117   TMMSG
0x8000   TMP_FW_LOC
0x5584   TMPADR
0x557C   TMPBFR1
0x557E   TMPBFR2
0x5580   TMPBFR3
0x5582   TMPBFR4
0x557E   TMPCLR
0x5513   TMPDBF
0x558A   TMPHL
0x55B8   TMPKEYBFR
0xFFC6   TMPNAM
0x5545   TMPSTR
0x1024 X TMPTR
0x259C   TMR
0x555C   TMRCNT
0x5539   TMSTPL
0x5537   TMSTPT
0x2890   TOPOOL
0x2828   TOSTRA
0x558A   TP
0x5524   TPBF1
0x5526   TPBF2
0x5528   TPBF3
0x552A   TPBF4
0x5513   TPHL
0x3213   TRYAGN
0x2829   TSALP
0x1D84   TSTBRK
0x1318   TSTMEM
0x21ED   TSTNUM
0x26D2   TSTOPL
0x2374   TSTRED
0x1A40   TSTREM
0x2FF7   TSTSGN
0x1C87   TSTSPC
0x21EE   TSTSTR
0x1A90   TTYLIN
0x026C   TX_EMP
0x0259   TXA
0x0269   TXA_EXIT
0xEEFE   TXTLDG
0x03F6 X TXTMD
0xEFFE   TXTRNM
0xF014   TXTSVG
0x550E   TYPE
0x0022   UF
0x181C   UFERR
0x1174   UFMSG
0x102E X UFPTR
0x000E   UL
0x1ED8   ULERR
0x10C0   ULMSG
0x101A X ULPTR
0x2E49   UNITY
0xF521   UPCRNENT
0xF550   UPCRNENT1
0x1D7F   UPDATA
0x53DE   USR
0x29F4   VAL
0x2A12   VAL1
0x2A1C   VAL2
0x2A1F   VAL3
0x3BFF   VALIDX
0x3C04   VALIDY
0x55C4   VAREND
0x0030   VDP_DAT
0x0031   VDP_SET
0x0B22   VDPMODESET
0x0B2A X VDPMODESET1
0x0B32 X VDPMODESET2
0x0B42 X VDPMODESETEX2
0x0B3A X VDPMODESETMC
0x5584   VIDEOBUFF
0x55AC   VIDTMP1
0x55AE   VIDTMP2
0x2BC4   VOLCH
0x2B96   VOLUME
0x2B10   VPEEK
0x2B38   VPOKE
0x2CC3   VREG
0x2CDF   VSTAT
0x2A3F   WAIT
0x2A54   WAITLP
0x12C4   WARM
0x139D   WARMST
0x34C2   WIDTH
0x0CD2   WLCBPDAT
0x0CB8   WLCMBEEP
0x1474   WORDS
0x1617   WORDTB
0x069E   WRITE_VIDEO_LOC
0x06B3   WRITE_VREG
0x0994   WRITEBUF
0x53D8   WRKSPC
0xFA9A   WRT_ERR
0x2CAE   WRTSND
0x0CE7   WRTSNDREG
0x1C8D   WTSPC
0x557C   X1
0x396A   X1GR
0x5584   X2
0x5584   XC
0x558A   XI
0x38DC   XY2HL
0x557E   Y1
0x3994   Y1GR
0x5586   Y2
0x5586   YC
0x558C   YI
0x0083   ZDATA
0x00C6 X ZDINT
0x00C4 X ZDIV
0x00B2   ZELSE
0x0080   ZEND
0x00CC   ZEQUAL
0x2557   ZERARY
0x178D   ZERBYT
0x249A   ZEROLP
0x40B2   ZEROSUP
0x00BC   ZFN
0x0081   ZFOR
0x008C   ZGOSUB
0x0088   ZGOTO
0x00CB   ZGTR
0x00E5   ZINSTR
0x00EF   ZLEFT
0x00CD   ZLTH
0x00C2   ZMINUS
0x00C5 X ZMOD
0x00B9   ZNEW
0x00BF   ZNOT
0x2043   ZONELP
0x00CA   ZOR
0x00C1   ZPLUS
0x00E4   ZPOINT
0x00B3   ZPRINT
0x008E   ZREM
0x00CE   ZSGN
0x00BD   ZSPC
0x00C0   ZSTEP
0x00BA   ZTAB
0x00BE   ZTHEN
0x00C3 X ZTIMES
0x00BB   ZTO
