# file opened: LM80C_64K-firmware-r1.17.asm
   1  0000              ; ------------------------------------------------------------------------------
   2  0000              ; LM80C 64K - FIRMWARE - R1.16
   3  0000              ; ------------------------------------------------------------------------------
   4  0000              ; The following code is intended to be used with LM80C Z80-based computer
   5  0000              ; designed by Leonardo Miliani. More info at
   6  0000              ; www DOT leonardomiliani DOT com
   7  0000              ; ------------------------------------------------------------------------------
   8  0000              ; Coding/Editing/Compiling:
   9  0000              ; Original init code for MC68B05 by Grant Searle
  10  0000              ; Original SIO/CTC/PIO init code by Mario Blunk
  11  0000              ; NASCOM BASIC originally modified by Gran Searle
  12  0000              ; Code modified and adapted for LM80C by Leonardo Miliani
  13  0000              ;
  14  0000              ; Edited with Visual Studio Code
  15  0000              ;
  16  0000              ; Compiled with SjASMPlus assembler 1.18.2
  17  0000              ; https://github.com/z00m128/sjasmplus
  18  0000              ; ------------------------------------------------------------------------------
  19  0000              ; Copyright notes:
  20  0000              ; Parts of the code (c) Grant Searle - free for non commercial use
  21  0000              ; Please include this advice and the note to the attribution of the original
  22  0000              ; version to Grant Searle if you intend to redistribuite it
  23  0000              ; http://searle.hostei.com/grant/index.html
  24  0000              ; eMail: home.micros01@btinternet.com
  25  0000              ;
  26  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  27  0000              ; Parts of the code (c) Mario Blunk
  28  0000              ; http://www.trainÂ­z.de
  29  0000              ;
  30  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  31  0000              ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  32  0000              ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  33  0000              ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  34  0000              ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  35  0000              ; the original ROM code (checksum A934H). PA
  36  0000              ;
  37  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  38  0000              ; The following code is intended to be used with LM80C Z80-based computer
  39  0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
  40  0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
  41  0000              ; kind of warranty: you can use them at your own risk.
  42  0000              ; You are free to use them for any non-commercial use: you are only asked to
  43  0000              ; maintain the copyright notices, include this advice and the note to the
  44  0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  45  0000              ; redistribuite them.
  46  0000              ; https://www.leonardomiliani.com
  47  0000              ;
  48  0000              ; Please support me by visiting the following links:
  49  0000              ; Main project page: https://www.leonardomiliani.com
  50  0000              ; Schematics and code: https://github.com/leomil72/LM80C
  51  0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  52  0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  53  0000              ; ------------------------------------------------------------------------------
  54  0000              ; set name for binary output file
  55  0000                  OUTPUT "LM80C-64K-firmware-r1.17.bin"
  56  0000
  57  0000              ; set firmware version
  58  0000                  DEFINE VERSION "1.17"
  59  0000
  60  0000              ; set DOS version
  61  0000                  DEFINE  DOS_VER "1.05"
  62  0000
  63  0000              ; ------------------------------------------------------------------------------
  64  0000              ; include the latest version of the bootloader: this sets up the address aliases,
  65  0000              ; configure the hardware, checks if warm or cold startup and loads the BASIC interpreter
  66  0000                  INCLUDE "../include/bootloader/bootloader-1.07.asm"
# file opened: ../include/bootloader/bootloader-1.07.asm
   1+ 0000              ; ------------------------------------------------------------------------------
   2+ 0000              ; LM80C - BOOTLOADER - 1.07
   3+ 0000              ; ------------------------------------------------------------------------------
   4+ 0000              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0000              ; kind of warranty: you can use them at your own risk.
   8+ 0000              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0000              ; maintain the copyright notices, include this advice and the note to the
  10+ 0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0000              ; redistribuite them.
  12+ 0000              ; https://www.leonardomiliani.com
  13+ 0000              ;
  14+ 0000              ; Please support me by visiting the following links:
  15+ 0000              ; Main project page: https://www.leonardomiliani.com
  16+ 0000              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0000              ; ------------------------------------------------------------------------------
  20+ 0000
  21+ 0000              ; ADDRESS DECODING (bits A6/A5/A4)
  22+ 0000              ; 0000xxxx : PIO
  23+ 0000              ; 0001xxxx : CTC
  24+ 0000              ; 0010xxxx : SIO
  25+ 0000              ; 0011xxxx : VDP
  26+ 0000              ; 0100xxxx : PSG
  27+ 0000              ; 0101xxxx : C.F.
  28+ 0000
  29+ 0000
  30+ 0000              ; ------------------------------------------------------------------------------
  31+ 0000              ;               EQUATES
  32+ 0000              ; ------------------------------------------------------------------------------
  33+ 0000              ; label defining for PIO (Parallel Input/Output)
  34+ 0000              PIO_DA          equ %00000000
  35+ 0000              PIO_DB          equ %00000001
  36+ 0000              PIO_CA          equ %00000010
  37+ 0000              PIO_CB          equ %00000011
  38+ 0000
  39+ 0000              ; label defining for CTC (Counter Timer Circuit)
  40+ 0000              CTC_CH0         equ %00010000
  41+ 0000              CTC_CH1         equ %00010001
  42+ 0000              CTC_CH2         equ %00010010
  43+ 0000              CTC_CH3         equ %00010011
  44+ 0000
  45+ 0000              ;label defining for SIO (Serial Input/Output)
  46+ 0000              SIO_CA          equ %00100010
  47+ 0000              SIO_CB          equ %00100011
  48+ 0000              SIO_DA          equ %00100000
  49+ 0000              SIO_DB          equ %00100001
  50+ 0000
  51+ 0000              ;label defining for VDP (Video Display Processor)
  52+ 0000              VDP_DAT         equ %00110000
  53+ 0000              VDP_SET         equ %00110001
  54+ 0000
  55+ 0000              ; label defining for PSG (Programmable Sound Generator)
  56+ 0000              PSG_REG         equ %01000000
  57+ 0000              PSG_DAT         equ %01000001
  58+ 0000
  59+ 0000              ; Interrupt-driven serial I/O interface lead by the Z80 SIO to run modified
  60+ 0000              ; NASCOM Basic 4.7 - Full input buffering with incoming data hardware handshaking
  61+ 0000              ; Handshake shows full before the buffer is totally filled to allow run-on from the sender
  62+ 0000              SER_BUFSIZE     equ     $58
  63+ 0000              SER_FULLSIZE    equ     $50
  64+ 0000              SER_EMPTYSIZE   equ     $05
  65+ 0000
  66+ 0000
  67+ 0000              ;------------------------------------------------------------------------------
  68+ 0000              ;                                F I R M W A R E
  69+ 0000              ;------------------------------------------------------------------------------
  70+ 0000              ; BASE MEMORY - RESET LOCATION ($0000) -> the CPU jumps to $0000 after a reset
  71+ 0000                              org     $0000
  72+ 0000 F3           RST00:          di                      ; be sure that INTs are disabled
  73+ 0001 C3 43 53                     jp      ROM2RAM         ; jump to ROM/RAM switcher
  74+ 0004
  75+ 0004              ;------------------------------------------------------------------------------
  76+ 0004              ; interrupt vector when SIO ch.B has a char available in its buffer
  77+ 0004                              ;$0004
  78+ 0004 65 01                        defw    RX_CHB_AVAIL
  79+ 0006
  80+ 0006              ;------------------------------------------------------------------------------
  81+ 0006              ; interrupt vector for SIO ch.B special conditions (i.e. buf overrun)
  82+ 0006                              ;$0006
  83+ 0006 68 01                        defw    SPEC_RXB_CNDT
  84+ 0008
  85+ 0008              ;------------------------------------------------------------------------------
  86+ 0008              ; send a character over serial ch. A
  87+ 0008                              ;$0008
  88+ 0008 C3 59 02     RST08:          jp      TXA
  89+ 000B FF                           BLOCK   1,$FF   ; filler
  90+ 000C
  91+ 000C              ;------------------------------------------------------------------------------
  92+ 000C              ; interrupt vector when SIO ch.A has a char available in its buffer
  93+ 000C                              ;$000C
  94+ 000C 00 01                        defw    RX_CHA_AVAIL
  95+ 000E
  96+ 000E              ;------------------------------------------------------------------------------
  97+ 000E              ; interrupt vector for SIO ch.A special conditions (i.e. buf overrun)
  98+ 000E                              ;$000E
  99+ 000E 36 01                        defw    SPEC_RXA_CNDT
 100+ 0010
 101+ 0010              ;------------------------------------------------------------------------------
 102+ 0010              ; receive a character over serial ch. A
 103+ 0010                              ;$0010
 104+ 0010 C3 2A 02     RST10:          jp      RXA
 105+ 0013 FF FF FF...                  BLOCK   5,$FF   ; filler
 106+ 0018              ;------------------------------------------------------------------------------
 107+ 0018              ; check buffer state
 108+ 0018
 109+ 0018                              ;$0018
 110+ 0018 C3 78 02     RST18:          jp      CKINCHAR
 111+ 001B FF FF FF...                  BLOCK   $25,$FF ; filler
 112+ 0040              ;------------------------------------------------------------------------------
 113+ 0040              ; interrupt vectors for CTC
 114+ 0040                              ;$0040               ; for CH0 Timer - used in BASIC by serial 1 for bps
 115+ 0040 60 55                        defw    CTC0IV
 116+ 0042                              ;$0042               ; for CH1 Timer - used in BASIC by serial 2 for bps
 117+ 0042 63 55                        defw    CTC1IV
 118+ 0044                              ;$0044               ; for CH2 timer - unused
 119+ 0044 66 55                        defw    CTC2IV
 120+ 0046                              ;$0046               ; for CH3 Timer - used by FW for 100ths/s counter
 121+ 0046 69 55                        defw    CTC3IV
 122+ 0048 FF FF FF...                  BLOCK   $1E,$FF ; filler
 123+ 0066              ;------------------------------------------------------------------------------
 124+ 0066              ; interrupt routine for NMI
 125+ 0066                              ;$0066
 126+ 0066 C3 DB 53                     jp      NMIUSR              ; jump to execute NMI service routine
 127+ 0069 FF FF FF...                  BLOCK   $27,$FF ; filler
 128+ 0090              ;------------------------------------------------------------------------------
 129+ 0090
 130+ 0090                              ;$0090
 131+ 0090 4C 4D 38 30                  defb    $4C,$4D,$38,$30,$43,$20,$36,$34
 131+ 0094 43 20 36 34
 132+ 0098 4B 20 43 4F                  defb    $4B,$20,$43,$4F,$4C,$4F,$52,$00
 132+ 009C 4C 4F 52 00
 133+ 00A0 43 4F 4D 50                  defb    $43,$4F,$4D,$50,$55,$54,$45,$52
 133+ 00A4 55 54 45 52
 134+ 00A8 20 28 32 30                  defb    $20,$28,$32,$30,$32,$31,$29,$00
 134+ 00AC 32 31 29 00
 135+ 00B0 44 65 73 69                  defb    $44,$65,$73,$69,$67,$6E,$65,$64
 135+ 00B4 67 6E 65 64
 136+ 00B8 20 62 79 00                  defb    $20,$62,$79,$00,$00,$00,$00,$00
 136+ 00BC 00 00 00 00
 137+ 00C0 4C 65 6F 6E                  defb    $4C,$65,$6F,$6E,$61,$72,$64,$6F
 137+ 00C4 61 72 64 6F
 138+ 00C8 20 4D 69 6C                  defb    $20,$4D,$69,$6C,$69,$61,$6E,$69
 138+ 00CC 69 61 6E 69
 139+ 00D0 46 57 20 31  FWVER:          defm    "FW ","1.17",$20,"2021-04-08",$20,"15:00:01",$00
 139+ 00D4 2E 31 37 20
 139+ 00D8 32 30 32 31
 139+ 00DC 2D 30 34 2D
 139+ 00E0 30 38 20 31
 139+ 00E4 35 3A 30 30
 139+ 00E8 3A 30 31 00
 140+ 00EC              FMVEREND:       equ     $
 141+ 00EC FF FF FF...                  BLOCK   $100-FMVEREND,$FF   ; filler
 142+ 0100              ;------------------------------------------------------------------------------
 143+ 0100
 144+ 0100              ;-------------------------------------------------------------------------------
 145+ 0100              ;               Z80 SIO CH. A MANAGEMENT
 146+ 0100              ;-------------------------------------------------------------------------------
 147+ 0100
 148+ 0100              ;-------------------------------------------------------------------------------
 149+ 0100              ; interrupt driven routine to get chars from Z80 SIO ch.A
 150+ 0100              ; this is the only serial channel that can print received chars onto the screen
 151+ 0100                              ;$0100
 152+ 0100 F5           RX_CHA_AVAIL:   push    AF              ; store A
 153+ 0101 E5                           push    HL              ; and HL
 154+ 0102 CD 8F 01                     call    A_RTS_OFF       ; disable RTS line
 155+ 0105 DB 20                        in      A,(SIO_DA)      ; read char from RX buffer into A
 156+ 0107 32 B8 55                     ld      (TMPKEYBFR),A   ; store it into the temp key buffer
 157+ 010A CD FD 01                     call    CHARINTOBFR     ; sub-routine to put the char into the input buffer
 158+ 010D D2 31 01                     jp      NC,LVRXCHA      ; if buffer is full, then leave without doing anything else
 159+ 0110 3A B8 55                     ld      A,(TMPKEYBFR)   ; retrieve char
 160+ 0113 32 79 55                     ld      (CHR4VID),A     ; write into buffer for video printing
 161+ 0116 FE 0D                        cp      CR              ; is it RETURN?
 162+ 0118 CA 20 01                     jp      Z,CNTRXCHA      ; yes, continue
 163+ 011B FE 20                        cp      $20             ; is it another control char (code < 32)?
 164+ 011D DA 31 01                     jp      C,LVRXCHA       ; yes, leave w/o printing it on video nor sending back to serial
 165+ 0120 F5           CNTRXCHA:       push    AF              ; store char
 166+ 0121 AF                           xor     A
 167+ 0122 32 B6 55                     ld      (KBDNPT),A      ; a char from serial is like a char printed by BASIC
 168+ 0125 3A 78 55                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 169+ 0128 FE 01                        cp      $01             ; is the print on video on?
 170+ 012A CC 61 07                     call    Z,CHAR2VID      ; yes, print on screen
 171+ 012D F1                           pop     AF              ; retrieve char
 172+ 012E CD 59 02                     call    TXA             ; send back to serial
 173+ 0131 E1           LVRXCHA:        pop     HL              ; retrieve HL
 174+ 0132 F1                           pop     AF              ; and A
 175+ 0133 FB                           ei                      ; re-enable interrupts
 176+ 0134 ED 4D                        reti                    ; and exit
 177+ 0136
 178+ 0136              ;-------------------------------------------------------------------------------
 179+ 0136              ; special SIO ch.A condition (i.e., buffer overrun)
 180+ 0136              ; if buffer overruns then show an error, empty the RX buffer and send
 181+ 0136              ; a break char
 182+ 0136 F5           SPEC_RXA_CNDT:  push    AF              ; store AF
 183+ 0137 CD 8F 01                     call    A_RTS_OFF       ; disable RTS
 184+ 013A CD CB 01                     call    SIO_A_DI        ; disable RX on ch. A
 185+ 013D 3A BE 55                     ld      A,(SERIALS_EN)  ; load serial status
 186+ 0140 CB 97                        res     2,A             ; disable RX on port 1
 187+ 0142 32 BE 55                     ld      (SERIALS_EN),A  ; store new serial status
 188+ 0145 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 189+ 0147 CB E7                        set     4,A             ; set 5th pin ON
 190+ 0149 D3 01                        out     (PIO_DB),A      ; send new setting
 191+ 014B 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 192+ 014D D3 22                        out     (SIO_CA),A      ; send command to SIO
 193+ 014F AF           EMPTYCHABFR:    xor     A
 194+ 0150 D3 22                        out     (SIO_CA),A      ; write to WR0, select RR0
 195+ 0152 DB 22                        in      A,(SIO_CA)      ; read RR0 register
 196+ 0154 E6 01                        and     $01             ; check if input buffer if empty
 197+ 0156 CA 5D 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then leave
 198+ 0159 DB 20                        in      A,(SIO_DA)      ; read chars
 199+ 015B 18 F2                        jr      EMPTYCHABFR     ; repeat
 200+ 015D F1           CHABFREMPTY:    pop     AF              ; retrieve AF
 201+ 015E 21 7D 3E                     ld      HL,SOERR        ; return point set to Serial Buffer Overrun routine
 202+ 0161 E3                           ex      (SP),HL         ; store onto stack
 203+ 0162 FB                           ei                      ; re-enable interrupts
 204+ 0163 ED 4D                        reti                    ; return from interrupt and execute code at SOERR
 205+ 0165
 206+ 0165              ;-------------------------------------------------------------------------------
 207+ 0165              ;               Z80 SIO CH. A MANAGEMENT
 208+ 0165              ;-------------------------------------------------------------------------------
 209+ 0165
 210+ 0165              ;-------------------------------------------------------------------------------
 211+ 0165              ; interrupt driven routine to get chars from Z80 SIO ch.B
 212+ 0165 FB           RX_CHB_AVAIL:   ei
 213+ 0166 ED 4D                        reti
 214+ 0168
 215+ 0168              ;-------------------------------------------------------------------------------
 216+ 0168              ; special SIO ch.A condition (i.e., buffer overrun)
 217+ 0168              ; if buffer overruns then show an error, empty the RX buffer and send
 218+ 0168              ; a break char
 219+ 0168 F5           SPEC_RXB_CNDT:  push    AF              ; store A
 220+ 0169 CD 97 01                     call    B_RTS_OFF       ; disable RTS
 221+ 016C CD D3 01                     call    SIO_B_DI        ; disable RX on ch.B
 222+ 016F 3A BE 55                     ld      A,(SERIALS_EN)  ; load serial status
 223+ 0172 CB 9F                        res     3,A             ; disable RX on port 2
 224+ 0174 32 BE 55                     ld      (SERIALS_EN),A  ; store new serial status
 225+ 0177 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 226+ 0179 CB EF                        set     5,A             ; set 5th pin ON
 227+ 017B D3 01                        out     (PIO_DB),A      ; send new setting
 228+ 017D 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 229+ 017F D3 23                        out     (SIO_CB),A      ; send command to SIO
 230+ 0181 AF           EMPTYCHBBFR:    xor     A
 231+ 0182 D3 23                        out     (SIO_CB),A      ; write to WR0, select RR0
 232+ 0184 DB 23                        in      A,(SIO_CB)      ; read RR0 register
 233+ 0186 E6 01                        and     $01             ; check if input buffer if empty
 234+ 0188 CA 5D 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then jump to run "exit" code
 235+ 018B DB 21                        in      A,(SIO_DB)      ; read chars
 236+ 018D 18 F2                        jr      EMPTYCHBBFR     ; repeat
 237+ 018F
 238+ 018F
 239+ 018F              ;-------------------------------------------------------------------------------
 240+ 018F              ;               Z80 SIO MANAGEMENT
 241+ 018F              ;-------------------------------------------------------------------------------
 242+ 018F              ; disable RTS:
 243+ 018F              ; by resetting RTS bit (set to 0), the RTS line is disabled (HIGH)
 244+ 018F C5           A_RTS_OFF:      push    BC              ; store BC
 245+ 0190 0E 22                        ld      C,SIO_CA        ; select channel A
 246+ 0192 3A BF 55                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 247+ 0195 18 06                        jr      SIO_RTS_OFF
 248+ 0197 C5           B_RTS_OFF:      push    BC              ; store BC
 249+ 0198 0E 23                        ld      C,SIO_CB        ; select channel B
 250+ 019A 3A C0 55                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 251+ 019D CB 3F        SIO_RTS_OFF:    srl     A               ; position data bits in bits #5&6
 252+ 019F E6 60                        and     %01100000       ; get only bits #5&6
 253+ 01A1 47                           ld      B,A             ; store data bits
 254+ 01A2 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 255+ 01A4 ED 79                        out     (C),A
 256+ 01A6 3E 88                        ld      A,%10001000     ; enable DTR (b7) and TX (b4), disable RTS (b1)
 257+ 01A8 B0                           or      B               ; set data bits
 258+ 01A9 ED 79                        out     (C),A           ; send setting
 259+ 01AB C1                           pop     BC              ; retrieve BC
 260+ 01AC C9                           ret                     ; exit
 261+ 01AD
 262+ 01AD              ;-------------------------------------------------------------------------------
 263+ 01AD              ; enable RTS
 264+ 01AD              ; by setting RTS bit (set to 1), the RTS line is enabled (LOW)
 265+ 01AD C5           A_RTS_ON:       push    BC              ; store BC
 266+ 01AE 0E 22                        ld      C,SIO_CA        ; select channel A
 267+ 01B0 3A BF 55                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 268+ 01B3 18 06                        jr      SIO_RTS_ON
 269+ 01B5 C5           B_RTS_ON:       push    BC              ; store BC
 270+ 01B6 0E 23                        ld      C,SIO_CB        ; select channel B
 271+ 01B8 3A C0 55                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 272+ 01BB CB 3F        SIO_RTS_ON:     srl     A               ; position data bits in bits #5&6
 273+ 01BD E6 60                        and     %01100000       ; get only bits #5&6
 274+ 01BF 47                           ld      B,A             ; store data bits
 275+ 01C0 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 276+ 01C2 ED 79                        out     (C),A
 277+ 01C4 3E 8A                        ld      A,%10001010     ; enable DTR (b7), TX (b4), and RTS (b1)
 278+ 01C6 B0                           or      B               ; set data bits
 279+ 01C7 ED 79                        out     (C),A           ; send setting
 280+ 01C9 C1                           pop     BC              ; retrieve BC
 281+ 01CA C9                           ret                     ; return
 282+ 01CB
 283+ 01CB              ;-------------------------------------------------------------------------------
 284+ 01CB              ; disable SIO RX channel
 285+ 01CB C5           SIO_A_DI:       push    BC              ; store BC
 286+ 01CC 0E 22                        ld      C,SIO_CA        ; SIO channel A
 287+ 01CE 3A BF 55                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 288+ 01D1 18 06                        jr      SIO_RXDI        ; jump to disable RX
 289+ 01D3 C5           SIO_B_DI:       push    BC              ; store BC
 290+ 01D4 0E 23                        ld      C,SIO_CB        ; SIO channel B
 291+ 01D6 3A C0 55                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 292+ 01D9 47           SIO_RXDI:       ld      B,A             ; store data bits
 293+ 01DA 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 294+ 01DC ED 79                        out     (C),A
 295+ 01DE 78                           ld      A,B             ; retrieve data bits; RX disabled; auto enable is OFF
 296+ 01DF ED 79                        out     (C),A
 297+ 01E1 C1                           pop     BC              ; retrieve BC
 298+ 01E2 C9                           ret                     ; return
 299+ 01E3
 300+ 01E3              ;-------------------------------------------------------------------------------
 301+ 01E3              ; enable SIO RX channel
 302+ 01E3 C5           SIO_A_EI:       push    BC              ; store BC
 303+ 01E4 0E 22                        ld      C,SIO_CA
 304+ 01E6 3A BF 55                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 305+ 01E9 18 06                        jr      SIO_RXEN
 306+ 01EB C5           SIO_B_EI:       push    BC              ; store BC
 307+ 01EC 0E 23                        ld      C,SIO_CB
 308+ 01EE 3A C0 55                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 309+ 01F1 47           SIO_RXEN:       ld      B,A             ; store data bits
 310+ 01F2 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 311+ 01F4 ED 79                        out     (C),A           ; select register
 312+ 01F6 78                           ld      A,B             ; retrieve data bits
 313+ 01F7 CB C7                        set     0,A             ; set RX enabled; auto enable is OFF
 314+ 01F9 ED 79                        out     (C),A           ; send settings to SIO
 315+ 01FB C1                           pop     BC              ; retrieve BC
 316+ 01FC C9                           ret
 317+ 01FD
 318+ 01FD              ;------------------------------------------------------------------------------
 319+ 01FD              ; put a char into the input buffer, char is into A
 320+ 01FD              ; this sub is called both from the ISR "RX_CHA_AVAIL" and when
 321+ 01FD              ; the RETURN key is pressed on the keyboard
 322+ 01FD F5           CHARINTOBFR:    push    AF              ; store it
 323+ 01FE 3A D6 53                     ld      A,(serBufUsed)  ; load buffer size
 324+ 0201 FE 58                        cp      SER_BUFSIZE     ; if buffer is not full
 325+ 0203 DA 08 02                     jp      C,NOTFULL       ; then store the char
 326+ 0206 F1                           pop     AF              ; else drop it
 327+ 0207 C9                           ret                     ; and exit
 328+ 0208 2A D2 53     NOTFULL:        ld      HL,(serInPtr)   ; buffer is not full, can store the char
 329+ 020B 23                           inc     HL              ; load pointer to find first free cell
 330+ 020C 7D                           ld      A,L             ; only check low byte because buffer<256
 331+ 020D FE D2                        cp      bufWrap         ; check if the pointer is at the last cell
 332+ 020F 20 03                        jr      NZ,NOTWRAP      ; if not then continue
 333+ 0211 21 7A 53                     ld      HL,SERBUF_START ; else load the address of the first cell
 334+ 0214 22 D2 53     NOTWRAP:        ld      (serInPtr),HL   ; store the new pointer
 335+ 0217 F1                           pop     AF              ; then retrieve the char...
 336+ 0218 77                           ld      (HL),A          ; ...and store it in the appropriate cell
 337+ 0219 21 D6 53                     ld      HL,serBufUsed   ; size of the input buffer
 338+ 021C 34                           inc     (HL)            ; increment it
 339+ 021D 3E 50                        ld      A,SER_FULLSIZE  ; input buffer capacity
 340+ 021F BE                           cp      (HL)            ; check if input buffer is full
 341+ 0220 D8                           ret     C               ; exit if buffer is not full
 342+ 0221 3A BE 55                     ld      A,(SERIALS_EN)  ; check if serial 1 is open
 343+ 0224 1F                           rra                     ; bit 0 into Carry: if Carry is 1 then serial 0 is open and...
 344+ 0225 DC 8F 01                     call    C,A_RTS_OFF     ; ...receiving further chars must be stopped
 345+ 0228 37                           scf                     ; set Carry flag, because  we must inform that the char has been added before to disable RTS
 346+ 0229 C9                           ret
 347+ 022A
 348+ 022A
 349+ 022A              ;-------------------------------------------------------------------------------
 350+ 022A              ; retrieve a char from the input buffer
 351+ 022A 3A D6 53     RXA:            ld      A,(serBufUsed)  ; load the buffer size
 352+ 022D A7                           and     A               ; check if it's 0 (empty)
 353+ 022E CA 2A 02                     jp      Z,RXA           ; if it's empty, wait for a char
 354+ 0231 F3                           di                      ; disable interrupts
 355+ 0232 E5                           push    HL              ; store HL
 356+ 0233 2A D4 53                     ld      HL,(serRdPtr)   ; load pointer to first available char
 357+ 0236 23                           inc     HL              ; increment it (go to the next char)
 358+ 0237 7D                           ld      A,L             ; check if the end of the buffer has been reached
 359+ 0238 FE D2                        cp      bufWrap         ; (only check low byte because buffer<256)
 360+ 023A 20 03                        jr      NZ,NOTRDWRAP    ; if not, jump straight
 361+ 023C 21 7A 53                     ld      HL,SERBUF_START ; else reload the starting address of the buffer
 362+ 023F 22 D4 53     NOTRDWRAP:      ld      (serRdPtr),HL   ; store new pointer to the next char to read
 363+ 0242 3A D6 53                     ld      A,(serBufUsed)  ; load buffer size
 364+ 0245 3D                           dec     A               ; decrement it
 365+ 0246 32 D6 53                     ld      (serBufUsed),A  ; and store the new size
 366+ 0249 FE 05                        cp      SER_EMPTYSIZE   ; check if input buffer can be considered empty
 367+ 024B 30 08                        jr      NC,RXA_EXIT     ; if not empty yet, then exit
 368+ 024D 3A BE 55                     ld      A,(SERIALS_EN)  ; load serial state
 369+ 0250 EE 05                        xor     %00000101       ; check if serial 1 is open and RX enabled
 370+ 0252 CC AD 01                     call    Z,A_RTS_ON      ; yes, set RTS on
 371+ 0255 7E           RXA_EXIT:       ld      A,(HL)          ; recover the char and return it into A
 372+ 0256 E1                           pop     HL              ; retrieve HL
 373+ 0257 FB                           ei                      ; re-enable interrupts
 374+ 0258 C9                           ret                     ; return
 375+ 0259
 376+ 0259              ;------------------------------------------------------------------------------
 377+ 0259              ; sends a char over the serial - char is into A
 378+ 0259 F5           TXA:            push    AF              ; store AF
 379+ 025A C5                           push    BC              ; store BC
 380+ 025B 47                           ld      B,A             ; store char
 381+ 025C 3A BE 55                     ld      A,(SERIALS_EN)  ; load serial status
 382+ 025F EE 05                        xor     %00000101       ; check if serial 1 is open and RX is enabled
 383+ 0261 20 06                        jr      NZ,TXA_EXIT     ; no, jump over
 384+ 0263 78                           ld      A,B             ; retrieve char
 385+ 0264 D3 20                        out     (SIO_DA),A      ; send char to the SIO
 386+ 0266 CD 6C 02                     call    TX_EMP          ; wait for outgoing char to be sent
 387+ 0269 C1           TXA_EXIT:       pop     BC              ; retrieve BC
 388+ 026A F1                           pop     AF              ; retrieve AF
 389+ 026B C9                           ret                     ; return
 390+ 026C
 391+ 026C              ;------------------------------------------------------------------------------
 392+ 026C              ; wait until outgoing serial has been sent
 393+ 026C 97           TX_EMP:         sub     A               ; set A to 0
 394+ 026D 3C                           inc     A               ; set A to 1
 395+ 026E D3 22                        out     (SIO_CA),A      ; write to WR0, select RR1
 396+ 0270 DB 22                        in      A,(SIO_CA)      ; read RR1 register
 397+ 0272 CB 47                        bit     0,A             ; check if all chars have been sent
 398+ 0274 CA 6C 02                     jp      Z,TX_EMP        ; if not (bit 0 = 0) then retrieve
 399+ 0277 C9                           ret                     ; else exit
 400+ 0278
 401+ 0278
 402+ 0278              ;------------------------------------------------------------------------------
 403+ 0278              ; check if there is some chars into the buffer
 404+ 0278 3A D6 53     CKINCHAR:       ld      A,(serBufUsed)  ; load buffer size
 405+ 027B A7                           and     A               ; compare to 0
 406+ 027C C9                           ret                     ; return
 407+ 027D
 408+ 027D              ;------------------------------------------------------------------------------
 409+ 027D              ; print a text from memory, and terminate when $00 is found
 410+ 027D 7E           RAWPRINT:       ld      A,(HL)          ; load character from memory cell pointed by HL
 411+ 027E B7                           or      A               ; is it $00 (end string)?
 412+ 027F C8                           ret     Z               ; Yes, then return
 413+ 0280 32 79 55                     ld      (CHR4VID),A     ; store char
 414+ 0283 F3                           di
 415+ 0284 CD 61 07                     call    CHAR2VID        ; and send it to screen
 416+ 0287 FB                           ei
 417+ 0288 23                           inc     HL              ; and select the next one
 418+ 0289 18 F2                        jr      RAWPRINT        ; repeat
 419+ 028B
 420+ 028B              ;-------------------------------------------------
 421+ 028B              ; Interrupt service routine (ISR) for CH3 timer
 422+ 028B              ; this is used to increment the 100ths of a second counter and for cursor flashing
 423+ 028B F5           CH3_TIMER:      push    AF              ; save regs. A,
 424+ 028C C5                           push    BC              ; BC,
 425+ 028D D5                           push    DE              ; DE,
 426+ 028E E5                           push    HL              ; HL
 427+ 028F 21 5C 55                     ld      HL,TMRCNT       ; load starting address of the timer
 428+ 0292 06 04                        ld      B,$04           ; 4 bytes to check
 429+ 0294 34           INCTMR3:        inc     (HL)            ; increment timer
 430+ 0295 20 03                        jr      NZ,CHKCRSR      ; if not zero then exit (finished increment)
 431+ 0297 23                           inc     HL              ; if yes, there was an overflow, so increment next byte
 432+ 0298 10 FA                        djnz    INCTMR3         ; repeat for 4 bytes
 433+ 029A CD CB 07     CHKCRSR:        call    FLASHCURSOR     ; call the flashing cursor routine
 434+ 029D CD F3 0C                     call    MNGSNDS         ; call the tone managemenet
 435+ 02A0 3A 5C 55                     ld      A,(TMRCNT)      ; check for keyboard management
 436+ 02A3 1F                           rra                     ; bit 0 = 1 ?
 437+ 02A4 D4 58 0D                     call    NC,KEYBOARD     ; no, so read the keyboard inputs
 438+ 02A7 E1                           pop     HL              ; retrieve HL,
 439+ 02A8 D1                           pop     DE              ; DE,
 440+ 02A9 C1                           pop     BC              ; BC,
 441+ 02AA F1                           pop     AF              ; and A
 442+ 02AB FB                           ei                      ; re-enable interrupts
 443+ 02AC ED 4D                        reti                    ; exit from ISR
 444+ 02AE
 445+ 02AE              ;------------------------------------------------------------------------------
 446+ 02AE              ;               HARDWARE INITIALISATION
 447+ 02AE              ;------------------------------------------------------------------------------
 448+ 02AE              ; first run - setup HW & SW
 449+ 02AE              ; (on LN80C 64K runs from RAM)
 450+ 02AE 21 09 55     INIT_HW:        ld      HL,TEMPSTACK    ; load temp stack pointer
 451+ 02B1 F9           INIT_HW2:       ld      SP,HL           ; set stack to temp stack pointer
 452+ 02B2 21 7A 53                     ld      HL,SERBUF_START ; set beginning of input buffer
 453+ 02B5 22 D2 53                     ld      (serInPtr),HL   ; for incoming chars to store into buffer
 454+ 02B8 22 D4 53                     ld      (serRdPtr),HL   ; and for chars to be read from buffer
 455+ 02BB AF                           xor     A               ; reset A
 456+ 02BC 32 D6 53                     ld      (serBufUsed),A  ; actual buffer size is 0
 457+ 02BF 32 BE 55                     ld      (SERIALS_EN),A  ; set serial ports status to OFF
 458+ 02C2 CD 40 03                     call    initCTC         ; configure CTC, then...
 459+ 02C5 CD 91 0C                     call    initPSG         ; ...configure PSG
 460+ 02C8 CD F2 04                     call    SHOW_LOGO       ; show computer logo
 461+ 02CB 1E 01                        ld      E,$01           ; E chooses the video mode (graphics 1)
 462+ 02CD CD D1 03                     call    initVDP         ; set video display
 463+ 02D0 AF                           xor     A
 464+ 02D1 ED 47                        ld      I,A             ; set high byte of interrupt vectors to point to page 0
 465+ 02D3 ED 5E                        im      2               ; interrupt mode 2
 466+ 02D5 FB                           ei                      ; enable interrupts
 467+ 02D6                              ; print system messages
 468+ 02D6 AF                           xor     A               ; A=0 so...
 469+ 02D7 32 B6 55                     ld      (KBDNPT),A      ; ...inputs don't come from keyboard
 470+ 02DA 3C                           inc     A               ; A=1...
 471+ 02DB 32 78 55                     ld      (PRNTVIDEO),A   ; ...to activate the print-on-video
 472+ 02DE 21 76 03                     ld      HL,MSGTXT1      ; sign-on message
 473+ 02E1 CD 7D 02                     call    RAWPRINT        ; print message
 474+ 02E4 3A D7 53                     ld      A,(basicStarted); check if BASIC is already started
 475+ 02E7 FE 59                        cp      'Y'             ; to see if this is a power-up
 476+ 02E9 20 19                        jr      NZ,COLDSTART    ; if not, then do a COLD start
 477+ 02EB 21 B4 03                     ld      HL,MSGTXT2      ; message to choose kind of start
 478+ 02EE CD 7D 02                     call    RAWPRINT        ; print message
 479+ 02F1 CD 2D 09                     call    CURSOR_ON       ; enable cursor
 480+ 02F4 AF                           xor     A
 481+ 02F5 32 78 55                     ld      (PRNTVIDEO),A   ; disable print-on-video
 482+ 02F8 CD 2A 02     CORW:           call    RXA             ; look for a pressed key
 483+ 02FB E6 DF                        and     %11011111       ; only UPPERCASE char
 484+ 02FD FE 43                        cp      'C'             ; cold start?
 485+ 02FF 20 0E                        jr      NZ,CHECKWARM    ; no, let's check for warm start
 486+ 0301 CD 1C 03                     call    ECHO_CHAR       ; echoes the char
 487+ 0304 3E 59        COLDSTART:      ld      A,'Y'           ; yes, set the "BASIC started" flag
 488+ 0306 32 D7 53                     ld      (basicStarted),A
 489+ 0309 CD 42 09                     call    CURSOR_OFF      ; disable cursor
 490+ 030C C3 C8 12                     jp      COLD            ; start BASIC COLD
 491+ 030F FE 57        CHECKWARM:      cp      'W'
 492+ 0311 20 E5                        jr      NZ,CORW         ; char not recognized, wait again
 493+ 0313 CD 1C 03                     call    ECHO_CHAR       ; echoes the char
 494+ 0316 CD 42 09                     call    CURSOR_OFF      ; disable cursor
 495+ 0319 C3 CB 12                     jp      WARM            ; start BASIC WARM
 496+ 031C
 497+ 031C              ;-------------------------------------------------------------------------------
 498+ 031C              ; send back char received through ch. A
 499+ 031C 32 79 55     ECHO_CHAR:      ld      (CHR4VID),A     ; set char for video printing
 500+ 031F AF                           xor     A
 501+ 0320 32 B6 55                     ld      (KBDNPT),A      ; input is not from keyboard
 502+ 0323 F3                           di                      ; disable INTs
 503+ 0324 CD 61 07                     call    CHAR2VID        ; echoes back the pressed key,
 504+ 0327 3E 0D                        ld      A,CR            ; then set a CR
 505+ 0329 32 79 55                     ld      (CHR4VID),A     ; set char for video printing
 506+ 032C CD 61 07                     call    CHAR2VID        ; and send it to screen
 507+ 032F FB                           ei                      ; re-enable INTs
 508+ 0330 3E 01                        ld      A,$01
 509+ 0332 32 78 55                     ld      (PRNTVIDEO),A   ; re-enable video printing
 510+ 0335 C9                           ret                     ; return to caller
 511+ 0336
 512+ 0336
 513+ 0336              ;-------------------------------------------------------------------------------
 514+ 0336              ; Z80 SIO default settings for serial channels
 515+ 0336 30           SIO_A_SETS:     defb    %00110000       ; write into WR0: error reset, select WR0
 516+ 0337 18                           defb    %00011000       ; write into WR0: channel reset
 517+ 0338 04                           defb    %00000100       ; write into WR0: select WR4
 518+ 0339 44                           defb    %01000100       ; write into WR4: presc. 16x, 1 stop bit, no parity
 519+ 033A 05                           defb    %00000101       ; write into WR0: select WR5
 520+ 033B E8                           defb    %11101000       ; write into WR5: DTR on, TX 8 bits, BREAK off, TX on, RTS off
 521+ 033C 01           SIO_B_SETS:     defb    %00000001       ; write into WR0: select WR1
 522+ 033D 04                           defb    %00000100       ; write into WR1: status affects interrupt vectors
 523+ 033E 02                           defb    %00000010       ; write into WR0: select WR2
 524+ 033F 00                           defb    %00000000       ; write into WR2: set interrupt vector, but bits D3/D2/D1 of this vector
 525+ 0340                                                      ; will be affected by the channel & condition that raised the interrupt
 526+ 0340                                                      ; (see datasheet): in our example, 0x0C for Ch.A receiving A char, 0x0E
 527+ 0340                                                      ; for special conditions
 528+ 0340              ;------------------------------------------------------------------------------
 529+ 0340              ;               Z80 CTC SETTING UP
 530+ 0340              ;------------------------------------------------------------------------------
 531+ 0340              initCTC:
 532+ 0340 21 6A 03                     ld      HL,CTCCONF      ; CTC configuration
 533+ 0343 11 60 55                     ld      DE,CTC0IV       ; CTC interrupt vector table
 534+ 0346 01 0C 00                     ld      BC,$000C        ; 12 bytes
 535+ 0349 ED B0                        ldir                    ; copy data
 536+ 034B              ;CH0, CH1, & CH2 disabled
 537+ 034B 3E 03                        ld      A,%00000011     ; interrupt off, timer mode, prescaler=16, don't care ext. TRG edge,
 538+ 034D                                                      ; start timer on loading constant, no time constant follows, software reset, command word
 539+ 034D D3 10                        out     (CTC_CH0),A     ; set CH0
 540+ 034F D3 11                        out     (CTC_CH1),A     ; set CH1
 541+ 0351 D3 12                        out     (CTC_CH2),A     ; set CH2
 542+ 0353              ;init CH3
 543+ 0353              ;CH3 divides CPU CLK by 144*256 providing an interrupt signal at 100 Hz (1/100 sec).
 544+ 0353              ;f = CPU_CLK/(144*256) => 3,686,400 / ( 36,864 ) => 100Hz
 545+ 0353 3E A7                        ld      A,%10100111     ; interrupt on; timer mode; prescaler=256; don't care ext; automatic trigger;
 546+ 0355                                                      ; time constant follows; cont. operation; command word
 547+ 0355 D3 13                        out     (CTC_CH3),A     ; send to CH3
 548+ 0357 3E 90                        ld      A,$90           ; time constant - 90$ (144d)
 549+ 0359 D3 13                        out     (CTC_CH3),A     ; send to CH3
 550+ 035B 3E 40                        ld      A,%01000000     ; D7..D3 provide the first part of the int vector (in our case, $0100), followed by
 551+ 035D                                                      ; D2..D1, provided by the CTC (they point to the channel), D0=interrupt word
 552+ 035D                                                      ; so int vector is 01000xx00
 553+ 035D D3 10                        out     (CTC_CH0),A     ; send to CTC
 554+ 035F                              ; reset cells of 100ths of a second counter
 555+ 035F AF                           xor     A               ; reset A
 556+ 0360 21 5C 55                     ld      HL,TMRCNT       ; load TMR pointer
 557+ 0363 06 04                        ld      B,$04           ; 4 memory cells
 558+ 0365 77           RESTMR:         ld      (HL),A          ; reset n-cell of TMR
 559+ 0366 23                           inc     HL              ; next cell
 560+ 0367 10 FC                        djnz    RESTMR          ; repeat for 4 cells
 561+ 0369 C9                           ret
 562+ 036A
 563+ 036A
 564+ 036A              ;------------------------------------------------------------------------------
 565+ 036A              ; jump table for CHx interrupts
 566+ 036A FB ED 4D     CTCCONF:        defb    $FB,$ED,$4D     ; CTC0 interrupt vector (ei; reti)
 567+ 036D FB ED 4D                     defb    $FB,$ED,$4D     ; CTC1 interrupt vector (ei; reti)
 568+ 0370 FB ED 4D                     defb    $FB,$ED,$4D     ; CTC2 interrupt vector (ei; reti)
 569+ 0373 C3 8B 02                     jp      CH3_TIMER       ; CTC3 interrupt vector (jump to execute sys-tick timer)
 570+ 0376
 571+ 0376
 572+ 0376              ;------------------------------------------------------------------------------
 573+ 0376              ; welcome messages
 574+ 0376              MSGTXT1:
 575+ 0376 20 20 20 20                  defm    "    LM80C 64K Color Computer",CR
 575+ 037A 4C 4D 38 30
 575+ 037E 43 20 36 34
 575+ 0382 4B 20 43 6F
 575+ 0386 6C 6F 72 20
 575+ 038A 43 6F 6D 70
 575+ 038E 75 74 65 72
 575+ 0392 0D
 576+ 0393 20 62 79 20                  defm    " by Leonardo Miliani * FW R","1.17",CR,0
 576+ 0397 4C 65 6F 6E
 576+ 039B 61 72 64 6F
 576+ 039F 20 4D 69 6C
 576+ 03A3 69 61 6E 69
 576+ 03A7 20 2A 20 46
 576+ 03AB 57 20 52 31
 576+ 03AF 2E 31 37 0D
 576+ 03B3 00
 577+ 03B4 0D           MSGTXT2:        defb    CR
 578+ 03B5 20 20 20 3C                  defm    "   <C>old or <W>arm start? ",0
 578+ 03B9 43 3E 6F 6C
 578+ 03BD 64 20 6F 72
 578+ 03C1 20 3C 57 3E
 578+ 03C5 61 72 6D 20
 578+ 03C9 73 74 61 72
 578+ 03CD 74 3F 20 00
 579+ 03D1
# file closed: ../include/bootloader/bootloader-1.07.asm
  67  03D1
  68  03D1              ; incude the latest version of the VDP module
  69  03D1                  INCLUDE "../include/vdp/vdp-1.08.asm"
# file opened: ../include/vdp/vdp-1.08.asm
   1+ 03D1              ; ------------------------------------------------------------------------------
   2+ 03D1              ; LM80C - VDP ROUTINES - 1.07
   3+ 03D1              ; ------------------------------------------------------------------------------
   4+ 03D1              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 03D1              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 03D1              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 03D1              ; kind of warranty: you can use them at your own risk.
   8+ 03D1              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 03D1              ; maintain the copyright notices, include this advice and the note to the
  10+ 03D1              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 03D1              ; redistribuite them.
  12+ 03D1              ; https://www.leonardomiliani.com
  13+ 03D1              ;
  14+ 03D1              ; Please support me by visiting the following links:
  15+ 03D1              ; Main project page: https://www.leonardomiliani.com
  16+ 03D1              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 03D1              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 03D1              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 03D1              ; ------------------------------------------------------------------------------
  20+ 03D1              ;
  21+ 03D1              ;------------------------------------------------------------------------------
  22+ 03D1              ; VDP INITIALISATION
  23+ 03D1              ; initialize VDP for a specific graphics mode
  24+ 03D1              ; INPUT: E -> contains the graphics mode:
  25+ 03D1              ; 0=text; 1=graphics 1; 2=graphics 2; 3=multicolor; 4=extended graphics 2
  26+ 03D1 D5           initVDP:        push    DE              ; store E
  27+ 03D2 CD CF 0A                     call    EMPTY_VRAM      ; reset VRAM
  28+ 03D5 CD ED 0A                     call    SET_GFX_MODE    ; load register settings
  29+ 03D8 CD E2 0A                     call    CLR_RAM_REG     ; reset RAM registers
  30+ 03DB D1                           pop     DE              ; restore reg. E
  31+ 03DC AF                           xor     A               ; reset A
  32+ 03DD 47                           ld      B,A             ; reset B (will be used later)
  33+ 03DE 7B                           ld      A,E             ; move E into A
  34+ 03DF 32 6E 55                     ld      (SCR_MODE),A    ; store screen mode
  35+ 03E2 FE 01                        cp      $01             ; is it graphics 1 (A=1)?
  36+ 03E4 CA 20 04                     jp      Z,G1MD          ; yes, jump over
  37+ 03E7 FE 02                        cp      $02             ; is it graphics 2 (A=2)?
  38+ 03E9 CA 60 04                     jp      Z,G2MD          ; yes, jump over
  39+ 03EC FE 03                        cp      $03             ; is it multicolor (A=3)?
  40+ 03EE CA 82 04                     jp      Z,MCMD          ; yes, jump over
  41+ 03F1 FE 04                        cp      $04             ; is it extended graphics 2 (A=4)?
  42+ 03F3 CA A5 04                     jp      Z,EXG2MD        ; yes, jump over
  43+ 03F6                              ; otherwise, it must be $00 so we assume that it's text mode
  44+ 03F6
  45+ 03F6              ; LOAD VDP SETTINGS FOR SELECTED VIDEO MODE:
  46+ 03F6
  47+ 03F6                              ; TEXT MODE (G0)
  48+ 03F6                              ; load charset
  49+ 03F6 60           TXTMD:          ld      H,B
  50+ 03F7 68                           ld      L,B             ; HL=first pattern cell $0000
  51+ 03F8 CD 09 0B                     call    LOADCHARSET     ; load patterns into VRAM
  52+ 03FB                              ; set cursor & video overlay
  53+ 03FB AF                           xor     A               ; reset A
  54+ 03FC 32 71 55                     ld      (SCR_CURS_X),A  ; set cursor position at X=0
  55+ 03FF 32 72 55                     ld      (SCR_CURS_Y),A  ; and Y=0
  56+ 0402 3E 05                        ld      A,$05           ; light blue
  57+ 0404 32 7B 55                     ld      (BKGNDCLR),A    ; set background/border color
  58+ 0407 3E 28                        ld      A,$28
  59+ 0409 32 6C 55                     ld      (SCR_SIZE_W),A  ; screen width = 40 cols
  60+ 040C 3E 18                        ld      A,$18
  61+ 040E 32 6D 55                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  62+ 0411 3E 1E                        ld      A,$1E
  63+ 0413 32 1D 54                     ld      (COMMAN),A      ; width for commas (4 columns)
  64+ 0416 11 00 08                     ld      DE,$0800
  65+ 0419 ED 53 6F 55                  ld      (SCR_NAM_TB),DE ; set name table address
  66+ 041D C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
  67+ 0420
  68+ 0420                              ; GRAPHICS 1 MODE (G1)
  69+ 0420                              ; load pattern table
  70+ 0420 68           G1MD:           ld      L,B
  71+ 0421 60                           ld      H,B             ; HL=first pattern cell $0000
  72+ 0422 CD 09 0B                     call    LOADCHARSET     ; load patterns into VRAM
  73+ 0425                              ; set cursor & video overlay
  74+ 0425 AF                           xor     A               ; position cursor
  75+ 0426 32 71 55                     ld      (SCR_CURS_X),A  ; at X=0
  76+ 0429 32 72 55                     ld      (SCR_CURS_Y),A  ; and Y=0
  77+ 042C 3E 20                        ld      A,$20
  78+ 042E 32 6C 55                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
  79+ 0431 3E 18                        ld      A,$18
  80+ 0433 32 6D 55                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  81+ 0436 3E 14                        ld      A,$14
  82+ 0438 32 1D 54                     ld      (COMMAN),A      ; width for commas (3 columns)
  83+ 043B 11 00 18                     ld      DE,$1800
  84+ 043E ED 53 6F 55                  ld      (SCR_NAM_TB),DE ; set name table address
  85+ 0442                              ; load color table
  86+ 0442 21 00 20                     ld      HL,$2000        ; color table start: $2000
  87+ 0445 CD 70 06                     call    SETVDPADRS
  88+ 0448 3E 01                        ld      A,$01           ; foreground color...
  89+ 044A 32 7A 55                     ld      (FRGNDCLR),A    ; ...set to black
  90+ 044D 3E 0F                        ld      A,$0F           ; background color...
  91+ 044F 32 7B 55                     ld      (BKGNDCLR),A    ; ...set to white
  92+ 0452 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
  93+ 0454 06 20                        ld      B,$20           ; 32 bytes of colors
  94+ 0456 0D                           dec     C               ; VDP data mode
  95+ 0457 ED 79        LDCLRTBMD1:     out     (C),A           ; after the first byte, the VDP autoincrements VRAM pointer
  96+ 0459 00                           nop
  97+ 045A 00                           nop
  98+ 045B 10 FA                        djnz    LDCLRTBMD1      ; repeat for 32 bytes
  99+ 045D C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 100+ 0460
 101+ 0460                              ; GRAPHICS 2 MODE (G2)
 102+ 0460 AF           G2MD:           xor     A               ; position cursor
 103+ 0461 32 71 55                     ld      (SCR_CURS_X),A  ; at X=0
 104+ 0464 32 72 55                     ld      (SCR_CURS_Y),A  ; and Y=0
 105+ 0467 32 6C 55                     ld      (SCR_SIZE_W),A  ; screen width = 256 pixels (0=256)
 106+ 046A 3C                           inc     A               ; black on...
 107+ 046B 32 7A 55                     ld      (FRGNDCLR),A    ; ...foreground
 108+ 046E 3E 0F                        ld      A,$0F           ; white on...
 109+ 0470 32 7B 55                     ld      (BKGNDCLR),A    ; ...background
 110+ 0473 3E C0                        ld      A,$C0
 111+ 0475 32 6D 55                     ld      (SCR_SIZE_H),A  ; screen height = 192 pixels
 112+ 0478 11 00 18                     ld      DE,$1800
 113+ 047B ED 53 6F 55                  ld      (SCR_NAM_TB),DE ; set name table address
 114+ 047F C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 115+ 0482
 116+ 0482                              ; MULTICOLOR MODE (G3)
 117+ 0482 AF           MCMD:           xor     A               ; position cursor
 118+ 0483 32 71 55                     ld      (SCR_CURS_X),A  ; at X=0
 119+ 0486 32 72 55                     ld      (SCR_CURS_Y),A  ; and Y=0
 120+ 0489 3E 0F                        ld      A,$0F           ; white color for...
 121+ 048B 32 7B 55                     ld      (BKGNDCLR),A    ; ...background and...
 122+ 048E 32 7A 55                     ld      (FRGNDCLR),A    ; ...foreground (even this is not used in MC)
 123+ 0491 3E 40                        ld      A,$40
 124+ 0493 32 6C 55                     ld      (SCR_SIZE_W),A  ; screen width = 64 blocks
 125+ 0496 3E 30                        ld      A,$30
 126+ 0498 32 6D 55                     ld      (SCR_SIZE_H),A  ; screen height = 48 blocks
 127+ 049B 11 00 08                     ld      DE,$0800
 128+ 049E ED 53 6F 55                  ld      (SCR_NAM_TB),DE ; set name table address
 129+ 04A2 C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 130+ 04A5
 131+ 04A5                              ; EXTENDED GRAPHICS 2 (G4)
 132+ 04A5              EXG2MD:         ; load pattern table
 133+ 04A5 60                           ld      H,B
 134+ 04A6 68                           ld      L,B             ; HL=first pattern cell $0000
 135+ 04A7 CD 09 0B                     call    LOADCHARSET     ; load patterns into VRAM
 136+ 04AA                              ; set cursor & video overlay
 137+ 04AA AF                           xor     A               ; position cursor
 138+ 04AB 32 71 55                     ld      (SCR_CURS_X),A  ; at X=0
 139+ 04AE 32 72 55                     ld      (SCR_CURS_Y),A  ; and Y=0
 140+ 04B1 3E 20                        ld      A,$20
 141+ 04B3 32 6C 55                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
 142+ 04B6 3E 18                        ld      A,$18
 143+ 04B8 32 6D 55                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
 144+ 04BB 3E 14                        ld      A,$14
 145+ 04BD 32 1D 54                     ld      (COMMAN),A      ; width for commas (3 columns)
 146+ 04C0 11 00 38                     ld      DE,$3800
 147+ 04C3 ED 53 6F 55                  ld      (SCR_NAM_TB),DE ; set name table address
 148+ 04C7                               ; load color table
 149+ 04C7 21 00 20                     ld      HL,$2000        ; color table start: $2000
 150+ 04CA CD 70 06                     call    SETVDPADRS
 151+ 04CD 3E 01                        ld      A,$01           ; foreground color is...
 152+ 04CF 32 7A 55                     ld      (FRGNDCLR),A    ; ...set to black
 153+ 04D2 3E 0F                        ld      A,$0F           ; whitefor...
 154+ 04D4 32 7B 55                     ld      (BKGNDCLR),A    ; ...background
 155+ 04D7 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
 156+ 04D9 16 08                        ld      D,$08           ; 8 pages of
 157+ 04DB 06 00                        ld      B,$00           ; 256 bytes of colors (total of 2,048 cells)
 158+ 04DD 0D                           dec     C               ; VDP data mode
 159+ 04DE ED 79        LDCLRTBEX2:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
 160+ 04E0 00                           nop
 161+ 04E1 00                           nop
 162+ 04E2 10 FA                        djnz    LDCLRTBEX2      ; repeat for 256 bytes
 163+ 04E4 15                           dec     D               ; did we fill up all the cells?
 164+ 04E5 20 F7                        jr      NZ,LDCLRTBEX2   ; no, repeat
 165+ 04E7                              ; LAST VDP SETTINGS
 166+ 04E7 CD 42 09     ENDVDPSET:      call    CURSOR_OFF      ; disable cursor
 167+ 04EA CD E2 05                     call    EMPTYVIDBUF     ; empty video buffer
 168+ 04ED AF                           xor     A
 169+ 04EE 32 75 55                     ld      (SCR_ORG_CHR),A ; store byte used tochar used to empty the video buffer
 170+ 04F1 C9                           ret                     ; return to caller
 171+ 04F2
 172+ 04F2
 173+ 04F2              ; show initial logo
 174+ 04F2 CD CF 0A     SHOW_LOGO:      call    EMPTY_VRAM      ; reset VRAM
 175+ 04F5                              ; set VDP for G2 mode
 176+ 04F5 06 07                        ld      B,$07           ; set only the first 7 registers
 177+ 04F7 11 10 00                     ld      DE,$0010        ; load settings for G2 mode
 178+ 04FA CD F5 0A                     call    SET_GFX_MODE2   ; load register settings
 179+ 04FD 16 01                        ld      D,$01           ; backdrop color set to black
 180+ 04FF ED 51                        out     (C),D           ; send data to VDP
 181+ 0501 ED 79                        out     (C),A           ; indicate the register to send data to
 182+ 0503                              ; set name table
 183+ 0503 21 00 18                     ld      HL,$1800        ; name table address
 184+ 0506 CD 5E 06                     call    SETNAMETABLE    ; set name table (load names into table)
 185+ 0509 CD 73 05                     call    ERASECLRTBL     ; erase color table (set foreground & background to black)
 186+ 050C                              ; set colors for logo
 187+ 050C 21 00 28                     ld      HL,$2800        ; 2nd page of color table
 188+ 050F CD 70 06                     call    SETVDPADRS
 189+ 0512 06 05                        ld      B,$05           ; 5 bands
 190+ 0514 21 BE 05                     ld      HL,CLRTABLE
 191+ 0517 0D                           dec     C               ; set VDP_DAT
 192+ 0518 1E 08                        ld      E,$08           ; 8 pixels each pattern
 193+ 051A 16 40        RPT101:         ld      D,$40           ; 64 chars each band
 194+ 051C 7E                           ld      A,(HL)          ; load data
 195+ 051D ED 79        RPT102:         out     (C),A           ; send it to VRAM
 196+ 051F 00                           nop                     ; little delay
 197+ 0520 1D                           dec     E               ; decrement counter
 198+ 0521 20 FA                        jr      NZ,RPT102       ; repeat until zero
 199+ 0523 1E 08                        ld      E,$08           ; 8 pixels each pattern
 200+ 0525 15                           dec     D               ; decrement char band counter
 201+ 0526 20 F5                        jr      NZ,RPT102       ; repeat until zero
 202+ 0528 23                           inc     HL              ; next pattern
 203+ 0529 10 EF                        djnz    RPT101          ; repeat until covered every band
 204+ 052B                              ; set pattern table
 205+ 052B 21 00 08                     ld      HL,$0800        ; address of first cell of 2nd area of pattern table
 206+ 052E 11 51 0B                     ld      DE,LM80CLOGO    ; pointer to logo pattern
 207+ 0531 45                           ld      B,L             ; 256 bytes, 8 rows
 208+ 0532 CD 9E 05     RPT103:         call    LOADLOGOCHRS
 209+ 0535 13                           inc     DE              ; next logo pattern
 210+ 0536 10 FA                        djnz    RPT103
 211+ 0538 06 20                        ld      B,$20           ; repeat for another 2 rows
 212+ 053A CD 9E 05     RPT104:         call    LOADLOGOCHRS
 213+ 053D 13                           inc     DE              ; next logo pattern
 214+ 053E 10 FA                        djnz    RPT104
 215+ 0540                              ; show logo/message, play a beep, check for CTRL pressing (to disable DOS), and wait a while
 216+ 0540 06 02                        ld      B,$02           ; two times
 217+ 0542 AF                           xor     A               ; reset A
 218+ 0543 57                           ld      D,A             ; 256 times
 219+ 0544 5F                           ld      E,A             ; x 256 times
 220+ 0545 32 7C 55                     ld      (TMPBFR1),A     ; sound flag set to 0
 221+ 0548 3A D7 53                     ld      A,(basicStarted)
 222+ 054B FE 59                        cp      'Y'
 223+ 054D 28 05                        jr      Z,DEC_D
 224+ 054F 3E 01                        ld      A,$01           ; by default, I/O DOS buffer is enabled
 225+ 0551 32 C1 55                     ld      (DOS_EN),A      ; DOS enabled
 226+ 0554 00           DEC_D:          nop                     ; does nothing...
 227+ 0555 00                           nop
 228+ 0556 00                           nop
 229+ 0557 00                           nop
 230+ 0558 00                           nop
 231+ 0559 00                           nop                     ; ...until here
 232+ 055A 1D                           dec     E               ; decrement E
 233+ 055B 20 F7                        jr      NZ,DEC_D        ; repeat until $00
 234+ 055D 7A                           ld      A,D
 235+ 055E FE 40                        cp      $40             ; ...equal to 64
 236+ 0560 CC 8A 05                     call    Z,SETBEEP       ; if yes, start sound
 237+ 0563 15                           dec     D
 238+ 0564 20 EE                        jr      NZ,DEC_D        ; repeat
 239+ 0566 3A 7C 55                     ld      A,(TMPBFR1)     ; sound state
 240+ 0569 FE 02                        cp      $02             ; check if sound is to be set off
 241+ 056B C4 96 05                     call    NZ,BEEPOFF      ; yes
 242+ 056E CD C3 05                     call    CHKSPCK         ; check if special key (CTRL) has been pressed on keyboard
 243+ 0571                                                      ; on LM80C 64K, you can disabled the I/O DOS buffer
 244+ 0571 10 E1                        djnz    DEC_D           ; repeat
 245+ 0573              ERASECLRTBL:    ; erase color table
 246+ 0573 3E 11                        ld      A,$11           ; foreground and background set to black
 247+ 0575 16 0A                        ld      D,$0A           ; 10 pages
 248+ 0577 06 00                        ld      B,$00           ; 256 color cells per page
 249+ 0579 21 00 28                     ld      HL,$2800        ; first cell of 2nd color table
 250+ 057C CD 70 06                     call    SETVDPADRS      ; send address
 251+ 057F 0D                           dec     C               ; VDP address for passing data
 252+ 0580 ED 79        RPT100:         out     (C),A           ; send data
 253+ 0582 00                           nop
 254+ 0583 00                           nop                     ; little delay
 255+ 0584 10 FA                        djnz    RPT100          ; repeat for entire page
 256+ 0586 15                           dec     D
 257+ 0587 20 F7                        jr      NZ,RPT100       ; repeat for all the pages ($0A00 cells)
 258+ 0589 C9                           ret                     ; return to caller
 259+ 058A
 260+ 058A              ; play a beep
 261+ 058A 3A 7C 55     SETBEEP:        ld      A,(TMPBFR1)     ; check the already-beeped flag
 262+ 058D B7                           or      A               ; is it 0?
 263+ 058E C0                           ret     NZ              ; no, exit
 264+ 058F 3C                           inc     A               ; flag to 1
 265+ 0590 32 7C 55                     ld      (TMPBFR1),A     ; set sound
 266+ 0593 C3 BF 0C                     jp      WLCMBEEP        ; play a beep & return
 267+ 0596
 268+ 0596              ; beep off
 269+ 0596 3E 02        BEEPOFF:        ld      A,$02           ; flag for sound off
 270+ 0598 32 7C 55                     ld      (TMPBFR1),A     ; set flag
 271+ 059B C3 C5 0C                     jp      NOBEEP          ; stop beep and return
 272+ 059E
 273+ 059E
 274+ 059E              ; used to load the chars that will compose the logo of the splash screen
 275+ 059E 1A           LOADLOGOCHRS:   ld      A,(DE)          ; load a pattern char of the logo
 276+ 059F 87                           add     A,A
 277+ 05A0 87                           add     A,A
 278+ 05A1 87                           add     A,A             ; multiply times 8 to get the offset
 279+ 05A2 C5                           push    BC
 280+ 05A3 D5                           push    DE              ; store BC and DE
 281+ 05A4 E5                           push    HL              ; store VRAM address to write to
 282+ 05A5 21 6E 52                     ld      HL,LOGOFONT     ; start of logo font data
 283+ 05A8 5F                           ld      E,A
 284+ 05A9 16 00                        ld      D,$00           ; put offset (A) into DE
 285+ 05AB 19                           add     HL,DE           ; get address of pattern data
 286+ 05AC EB                           ex      DE,HL           ; move address into DE
 287+ 05AD E1                           pop     HL              ; retrieve VRAM address
 288+ 05AE 06 08                        ld      B,$08           ; 8 bytes per pattern
 289+ 05B0 CD 70 06                     call    SETVDPADRS      ; set VDP address
 290+ 05B3 0D                           dec     C               ; VDP_DAT
 291+ 05B4 1A           SNDLOGPT:       ld      A,(DE)          ; load data from RAM
 292+ 05B5 ED 79                        out     (C),A           ; and send to VRAM
 293+ 05B7 13                           inc     DE              ; next byte into RAM
 294+ 05B8 23                           inc     HL              ; next byte into VRAM (used in future iterations)
 295+ 05B9 10 F9                        djnz    SNDLOGPT        ; repeat 8 times
 296+ 05BB D1                           pop     DE
 297+ 05BC C1                           pop     BC              ; retrieve BC & DE
 298+ 05BD C9                           ret                     ; return to caller
 299+ 05BE              CLRTABLE:       equ $
 300+ 05BE 18 1B 13 14                  defb    $18,$1B,$13,$14,$1D ; colors of background bands of the logo
 300+ 05C2 1D
 301+ 05C3
 302+ 05C3
 303+ 05C3              ; while showing the logo, check if special key (CTRL) is being pressed
 304+ 05C3              ; if yes, then disable DOS functions recovering RAM
 305+ 05C3 F5           CHKSPCK:        push    AF
 306+ 05C4 3E FE                        ld      A,%11111110     ; select CTRL row
 307+ 05C6 CD 43 0D                     call    READKBLN        ; read row
 308+ 05C9 CB 5F                        bit     3,A             ; test for RUN/STOP
 309+ 05CB CA DB 05                     jp      Z,DOCOLDRESET   ; yes, do a cold reset
 310+ 05CE CB 57                        bit     2,A             ; test if CTRL key is pressed
 311+ 05D0 20 07                        jr      NZ,LVCKSPLK     ; no, leave
 312+ 05D2 AF                           xor     A               ; yes, so...
 313+ 05D3 32 C1 55                     ld      (DOS_EN),A      ; ...disable DOS
 314+ 05D6 32 D7 53                     ld      (basicStarted),A; reset BASIC warm start
 315+ 05D9 F1           LVCKSPLK:       pop     AF
 316+ 05DA C9                           ret
 317+ 05DB AF           DOCOLDRESET:    xor     A               ; reset A
 318+ 05DC 32 D7 53                     ld      (basicStarted),A; reset BASIC warm start
 319+ 05DF C3 00 00                     jp      $0000           ; restart
 320+ 05E2
 321+ 05E2
 322+ 05E2              ; empty video buffer
 323+ 05E2 3A 6E 55     EMPTYVIDBUF:    ld      A,(SCR_MODE)    ; check screen mode
 324+ 05E5 FE 02                        cp      $02             ; is it G2 mode?
 325+ 05E7 CA 0A 06                     jp      Z,EMPTYG2       ; yes, jump over
 326+ 05EA FE 03                        cp      $03             ; is it MC mode?
 327+ 05EC CA 3A 06                     jp      Z,EMPTYMC       ; yes, jump over
 328+ 05EF 3A 6D 55                     ld      A,(SCR_SIZE_H)  ; load height of screen
 329+ 05F2 47                           ld      B,A             ; move rows into B
 330+ 05F3 AF                           xor     A               ; filling char is $00
 331+ 05F4 2A 6F 55                     ld      HL,(SCR_NAM_TB) ; load the name table address
 332+ 05F7 CD 70 06                     call    SETVDPADRS      ; send address to VDP
 333+ 05FA 0D                           dec     C               ; VDP address for passing data
 334+ 05FB 5F           LDCOLSTOEMPTY:  ld      E,A             ; store filling char into E
 335+ 05FC 3A 6C 55                     ld      A,(SCR_SIZE_W)  ; load # of cols to empty into A
 336+ 05FF 57                           ld      D,A             ; move A into D
 337+ 0600 7B                           ld      A,E             ; recover filling char
 338+ 0601 ED 79        RPTEMPTYBUF:    out     (C),A           ; write empty byte into VRAM
 339+ 0603 00                           nop
 340+ 0604 15                           dec     D               ; decr. D
 341+ 0605 20 FA                        jr      NZ,RPTEMPTYBUF  ; repeat for the # of cols
 342+ 0607 10 F2                        djnz    LDCOLSTOEMPTY   ; repeat for the # of rows
 343+ 0609 C9                           ret                     ; return to caller
 344+ 060A 2A 6F 55     EMPTYG2:        ld      HL,(SCR_NAM_TB) ; yes, additional setup for G2 - load G2 name table address (usually $1800)
 345+ 060D CD 5E 06                     call    SETNAMETABLE    ; set name table
 346+ 0610 21 00 00                     ld      HL,$0000        ; set pattern table
 347+ 0613 CD 70 06                     call    SETVDPADRS      ; send address to VDP
 348+ 0616 AF                           xor     A               ; empty pattern
 349+ 0617 16 18                        ld      D,$18           ; 6144 ($1800) cell to clean, 24 pages ($18)
 350+ 0619 47                           ld      B,A             ; 256 bytes for page
 351+ 061A 0D                           dec     C               ; VDP data mode
 352+ 061B ED 79        CLRG2PTNTBL:    out     (C),A           ; clear pattern
 353+ 061D 00                           nop                     ; little delay
 354+ 061E 00                           nop
 355+ 061F 10 FA                        djnz    CLRG2PTNTBL     ; repeat for 1 page
 356+ 0621 15                           dec     D               ; next page
 357+ 0622 20 F7                        jr      NZ,CLRG2PTNTBL  ; repeat
 358+ 0624 21 00 20                     ld      HL,$2000        ; load the color table address
 359+ 0627 CD 70 06                     call    SETVDPADRS      ; send address to VDP
 360+ 062A 3A 7A 55                     ld      A,(FRGNDCLR)    ; load foreground
 361+ 062D 87                           add     A,A
 362+ 062E 87                           add     A,A
 363+ 062F 87                           add     A,A
 364+ 0630 87                           add     A,A             ; move to high nibble
 365+ 0631 57                           ld      D,A             ; store into D
 366+ 0632 3A 7B 55                     ld      A,(BKGNDCLR)    ; load background color
 367+ 0635 B2                           or      D               ; combine with background color
 368+ 0636 16 18                        ld      D,$18           ; 6144 ($1800) cells to fill, so 24 pages ($18)
 369+ 0638 18 17                        jr      STARTEMPTY
 370+ 063A 21 00 08     EMPTYMC:        ld      HL,$0800        ; MC name table
 371+ 063D CD 5E 06                     call    SETNAMETABLE    ; set name table
 372+ 0640 21 00 00                     ld      HL,$0000        ; color table address
 373+ 0643 CD 70 06                     call    SETVDPADRS      ; send address to VDP
 374+ 0646 3A 7B 55                     ld      A,(BKGNDCLR)    ; load background
 375+ 0649 57                           ld      D,A             ; store into D
 376+ 064A 87                           add     A,A
 377+ 064B 87                           add     A,A
 378+ 064C 87                           add     A,A
 379+ 064D 87                           add     A,A             ; move to high nibble
 380+ 064E B2                           or      D               ; set background color for high and low nibble
 381+ 064F 16 08                        ld      D,$08           ; 2048 ($0800) cells to fill, so 8 pages ($08)
 382+ 0651 0D           STARTEMPTY:     dec     C               ; VDP address for passing data
 383+ 0652 06 00                        ld      B,$00           ; 256 bytes each page ($00=256)
 384+ 0654 ED 79        SNDCLRSET:      out     (C),A           ; send color setting
 385+ 0656 00                           nop                     ; wait a while
 386+ 0657 00                           nop
 387+ 0658 10 FA                        djnz    SNDCLRSET       ; repeat for 1 page
 388+ 065A 15                           dec     D               ; have we filled all the pages?
 389+ 065B 20 F7                        jr      NZ,SNDCLRSET    ; no, repeat
 390+ 065D C9                           ret                     ; return to caller
 391+ 065E
 392+ 065E              ; set name table for G2 mode (patterns from $00 to $FF for each of the 3 areas of the screen)
 393+ 065E CD 70 06     SETNAMETABLE:   call    SETVDPADRS      ; send address to VDP
 394+ 0661 0D                           dec     C               ; VDP address for passing data
 395+ 0662 16 03                        ld      D,$03           ; 3 pages to fill into VRAM (768 cells)
 396+ 0664 AF                           xor     A               ; starting char name #0 (chars go from 0 to 255)
 397+ 0665 47                           ld      B,A             ; reset B
 398+ 0666 ED 79        RPTFLL1:        out     (C),A           ; send name to VRAM
 399+ 0668 00                           nop
 400+ 0669 3C                           inc     A               ; increment # of name
 401+ 066A 10 FA                        djnz    RPTFLL1         ; repeat for 256 cells (1 page)
 402+ 066C 15                           dec     D               ; did we fill all the pages?
 403+ 066D 20 F7                        jr      NZ,RPTFLL1      ; no, continue
 404+ 066F C9                           ret                     ; return to caller
 405+ 0670
 406+ 0670              ; set an address into VRAM: address is in HL - HL is changed after it
 407+ 0670 0E 31        SETVDPADRS:     ld      C,VDP_SET       ; VDP address mode
 408+ 0672 CB F4                        set     6,H             ; set bit #6 of address, to write to VRAM
 409+ 0674 ED 69                        out     (C),L           ; send low and...
 410+ 0676 ED 61                        out     (C),H           ; ...high byte of the first cell
 411+ 0678 C9                           ret                     ; return to caller
 412+ 0679
 413+ 0679              ; clear the video buffer and position the cursor at 0,0
 414+ 0679 CD E2 05     CLEARVIDBUF:    call    EMPTYVIDBUF     ; clear video buffer
 415+ 067C AF                           xor     A               ; reset A
 416+ 067D 32 71 55                     ld      (SCR_CURS_X),A  ; cursor X to 0
 417+ 0680 32 72 55                     ld      (SCR_CURS_Y),A  ; cursor Y to 0
 418+ 0683 C3 CC 06                     jp      POS_CURSOR      ; position cursor & return to caller
 419+ 0686
 420+ 0686              ; HOME: position the cursor at coords. 0,0
 421+ 0686 AF           ATHOME:         xor     A               ; position cursor at 0,0 by storing...
 422+ 0687 32 74 55                     ld      (SCR_CUR_NY),A  ; ...new Y...
 423+ 068A 32 73 55                     ld      (SCR_CUR_NX),A  ; ...and new X
 424+ 068D C3 D6 06                     jp      MOVCRS          ; move cursor to new location & return to caller
 425+ 0690
 426+ 0690              ; load the char or byte at the VRAM position set by HL
 427+ 0690              ; value is returned into A
 428+ 0690 C5           READ_VIDEO_LOC: push    BC              ; store BC
 429+ 0691 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 430+ 0693 44                           ld      B,H
 431+ 0694 CB B8                        res     7,B
 432+ 0696 CB B0                        res     6,B
 433+ 0698 ED 69                        out     (C),L           ; low byte then...
 434+ 069A ED 41                        out     (C),B           ; high byte
 435+ 069C 0D                           dec     C               ; VDP data mode
 436+ 069D 00                           nop                     ; added to compensate shorter instruction
 437+ 069E 00                           nop                     ; wait...
 438+ 069F 00                           nop                     ; ...a while
 439+ 06A0 00                           nop
 440+ 06A1 ED 78                        in      A,(C)           ; read byte at current VRAM location
 441+ 06A3 C1                           pop     BC              ; restore BC
 442+ 06A4 C9                           ret                     ; return to caller
 443+ 06A5
 444+ 06A5              ; write a byte at the VRAM position pointed by HL
 445+ 06A5              ; value is in A
 446+ 06A5 C5           WRITE_VIDEO_LOC:push    BC              ; store BC
 447+ 06A6 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 448+ 06A8 44                           ld      B,H             ; copy H into B
 449+ 06A9 CB B8                        res     7,B
 450+ 06AB CB F0                        set     6,B             ; write to VRAM
 451+ 06AD ED 69                        out     (C),L           ; low byte then...
 452+ 06AF ED 41                        out     (C),B           ; high byte of VRAM address
 453+ 06B1 0D                           dec     C               ; VDP data mode
 454+ 06B2 00                           nop                     ; added to compensate shorter instruction
 455+ 06B3 00                           nop                     ; wait...
 456+ 06B4 00                           nop                     ; ...a while
 457+ 06B5 00                           nop
 458+ 06B6 ED 79                        out     (C),A           ; write byte into VRAM
 459+ 06B8 C1                           pop     BC              ; restore BC
 460+ 06B9 C9                           ret                     ; return to caller
 461+ 06BA
 462+ 06BA              ; write a value into a specific VDP register
 463+ 06BA              ; value is in E, register is in A
 464+ 06BA C5           WRITE_VREG:     push    BC              ; store BC
 465+ 06BB C6 80                        add     A,$80           ; set VDP to write to registers
 466+ 06BD 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 467+ 06BF ED 59                        out     (C),E           ; send data to VDP
 468+ 06C1 ED 79                        out     (C),A           ; select the destination register
 469+ 06C3 C1                           pop     BC              ; restore BC
 470+ 06C4 C9                           ret                     ; return to caller
 471+ 06C5
 472+ 06C5              ; read VDP status register and return value into A
 473+ 06C5 C5           READ_VSTAT:     push    BC              ; store BC
 474+ 06C6 0E 31                        ld      C,VDP_SET       ; VDP register access
 475+ 06C8 ED 78                        in      A,(C)           ; read status register
 476+ 06CA C1                           pop     BC              ; restore BC
 477+ 06CB C9                           ret                     ; return to caller
 478+ 06CC
 479+ 06CC              ; position the cursor at the current coordinates, preserving underlying char
 480+ 06CC CD 0F 07     POS_CURSOR:     call    LOAD_CRSR_POS   ; load the VRAM address of cursor into HL
 481+ 06CF CD 90 06                     call    READ_VIDEO_LOC  ; load the current char at the cursor position (return in A)
 482+ 06D2 32 75 55                     ld      (SCR_ORG_CHR),A ; store the current char
 483+ 06D5 C9                           ret
 484+ 06D6
 485+ 06D6              ; move cursor to new X,Y coordinates
 486+ 06D6 CD 06 07     MOVCRS:         call    RSTCHRCRS       ; restore the char in the current cursor position
 487+ 06D9 CD F1 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 488+ 06DC CD CC 06     MOVSHOWCRS:     call    POS_CURSOR      ; position cursor into new location
 489+ 06DF 3A 76 55                     ld      A,(CRSR_STATE)  ; load status of cursor
 490+ 06E2 A7                           and     A               ; is cursor off?
 491+ 06E3 C8                           ret     Z               ; yes, return
 492+ 06E4 3A 5C 55                     ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
 493+ 06E7 F6 20                        or      $20             ; ...set cursor on
 494+ 06E9 32 77 55                     ld      (LSTCSRSTA),A   ; store the last cursor state
 495+ 06EC 3E FF                        ld      A,$FF           ; BTW, set cursor visible after moved it
 496+ 06EE C3 A5 06                     jp      WRITE_VIDEO_LOC ; write into video cell
 497+ 06F1
 498+ 06F1
 499+ 06F1              ; set new cursor's coordinates
 500+ 06F1 3A 73 55     NEWCRSRCOORD:   ld      A,(SCR_CUR_NX)  ; load new X
 501+ 06F4 32 71 55                     ld      (SCR_CURS_X),A  ; write new X
 502+ 06F7 3A 74 55                     ld      A,(SCR_CUR_NY)  ; load new Y
 503+ 06FA 32 72 55                     ld      (SCR_CURS_Y),A  ; write new Y
 504+ 06FD 3E FF                        ld      A,$FF           ; delete new values
 505+ 06FF 32 73 55                     ld      (SCR_CUR_NX),A  ; of X
 506+ 0702 32 74 55                     ld      (SCR_CUR_NY),A  ; and Y
 507+ 0705 C9                           ret
 508+ 0706
 509+ 0706              ; recover char under the cursor and prints it onto the screen
 510+ 0706 CD 0F 07     RSTCHRCRS:      call    LOAD_CRSR_POS   ; recover old cursor position
 511+ 0709 3A 75 55                     ld      A,(SCR_ORG_CHR) ; recover old char
 512+ 070C C3 A5 06                     jp      WRITE_VIDEO_LOC ; write char into VRAM & return
 513+ 070F
 514+ 070F              ; retrieve cursor position from either current coordinates or next place
 515+ 070F              ; return address position into HL
 516+ 070F 3A 72 55     LOAD_CRSR_POS:  ld      A,(SCR_CURS_Y)  ; load cursor Y
 517+ 0712 6F                           ld      L,A             ; move it into reg.L
 518+ 0713 AF                           xor     A               ; reset A
 519+ 0714 67                           ld      H,A             ; reset H
 520+ 0715 47                           ld      B,A             ; reset B
 521+ 0716 29                           add     HL,HL           ; create offset (each address is 2-bytes long so we need to double HL)
 522+ 0717 11 9F 0A                     ld      DE,POS_TB_CRS_40; load position table address of cursor for 40 cols
 523+ 071A 3A 6C 55                     ld      A,(SCR_SIZE_W)  ; load screen width
 524+ 071D FE 28                        cp      $28             ; is it 40 cols?
 525+ 071F 28 03                        jr      Z,CONT_POS_CURS ; yes, jump over
 526+ 0721 11 6F 0A                     ld      DE,POS_TB_CRS_32; no, load position table address of cursor for 32 cols
 527+ 0724 19           CONT_POS_CURS:  add     HL,DE           ; the correct starting address of the required row is now into HL
 528+ 0725 5E                           ld      E,(HL)          ; load starting address of the required row into DE
 529+ 0726 23                           inc     HL
 530+ 0727 56                           ld      D,(HL)
 531+ 0728 2A 6F 55                     ld      HL,(SCR_NAM_TB) ; load starting address of name table
 532+ 072B 19                           add     HL,DE           ; starting address of the current row into name table
 533+ 072C 3A 71 55                     ld      A,(SCR_CURS_X)  ; load cursor X
 534+ 072F 4F                           ld      C,A             ; transfer A into C
 535+ 0730 09                           add     HL,BC           ; add X offset: now HL contains the address of the current cursor position
 536+ 0731 C9                           ret
 537+ 0732
 538+ 0732              ; find X,Y coordinates of a screen address pointed in VRAM by HL
 539+ 0732              ; return them into L,A for X,Y
 540+ 0732 D5           HL2XY:          push    DE              ; store DE
 541+ 0733 ED 5B 6F 55                  ld      DE,(SCR_NAM_TB) ; load starting address of name table into DE
 542+ 0737 AF                           xor     A               ; clear Carry
 543+ 0738 ED 52                        sbc     HL,DE           ; find position relative to screen (from 0,0)
 544+ 073A D1                           pop     DE
 545+ 073B 3A 6C 55                     ld      A,(SCR_SIZE_W)  ; load screen width
 546+ 073E 4F                           ld      C,A             ; move it into C
 547+ 073F CD 93 41                     call    DIV_16_8        ; divide position by C: return Y into L and X into A
 548+ 0742 C9                           ret                     ; return to caller
 549+ 0743
 550+ 0743              ;-------------------------------------------------------------------------------
 551+ 0743              ; char table for jumps
 552+ 0743 19           CHRTBL:         defb    HOME
 553+ 0744 86 06                        defw    ATHOME          ; move the cursor to 0,0
 554+ 0746
 555+ 0746 0C                           defb    CS
 556+ 0747 79 06                        defw    CLEARVIDBUF     ; clear video buffer and position cursor at 0,0
 557+ 0749
 558+ 0749 0D                           defb    CR
 559+ 074A C2 09                        defw    CRGRETURN       ; go to the beginning of the next line
 560+ 074C
 561+ 074C 08                           defb    BKSP
 562+ 074D 30 08                        defw    BACKSPACE       ; move cursor left 1 position
 563+ 074F
 564+ 074F 1C                           defb    CRSLFT
 565+ 0750 73 08                        defw    CURSORLEFT      ; move cursor left
 566+ 0752
 567+ 0752 1E                           defb    CRSUP
 568+ 0753 BF 08                        defw    CURSORUP        ; move cursor up
 569+ 0755
 570+ 0755 1D                           defb    CRSRGT
 571+ 0756 D8 08                        defw    CURSORRIGHT     ; move cursor right
 572+ 0758
 573+ 0758 1F                           defb    CRSDN
 574+ 0759 0D 09                        defw    CURSORDOWN      ; move cursor up
 575+ 075B
 576+ 075B 1A                           defb    INSRT
 577+ 075C EE 07                        defw    INSERTKEY       ; insert a space
 578+ 075E
 579+ 075E 0A                           defb    LF
 580+ 075F CA 07                        defw    PLACEHOLDER     ; CURRENTLY WE DON'T PRINT LINE FEED
 581+ 0761
 582+ 0761              ; send current char to video buffer
 583+ 0761 F5           CHAR2VID:       push    AF              ; store AF
 584+ 0762 C5                           push    BC              ; store BC
 585+ 0763 D5                           push    DE              ; store DE
 586+ 0764 E5                           push    HL              ; store HL
 587+ 0765 3A 76 55                     ld      A,(CRSR_STATE)  ; store cursor state...
 588+ 0768 F5                           push    AF              ; into stack
 589+ 0769 CD 42 09                     call    CURSOR_OFF      ; cursor off
 590+ 076C 3A 79 55                     ld      A,(CHR4VID)     ; recover char
 591+ 076F 06 0A                        ld      B,$0A           ; 10 chars to check
 592+ 0771 21 43 07                     ld      HL,CHRTBL       ; address of key table
 593+ 0774 BE           RPTCPCK:        cp      (HL)            ; compare with char
 594+ 0775 23                           inc     HL              ; beginning of sub-routine address
 595+ 0776 20 09                        jr      NZ,NXTCPCK      ; different, go to next char
 596+ 0778 5E                           ld      E,(HL)          ; load addres into DE
 597+ 0779 23                           inc     HL
 598+ 077A 56                           ld      D,(HL)
 599+ 077B EB                           ex      DE,HL           ; move user routine's address into HL
 600+ 077C 11 BD 07                     ld      DE,EXITCHAR2VID ; set point of return after the user routine
 601+ 077F D5                           push    DE              ; store into stack
 602+ 0780 E9                           jp      (HL)            ; call user routine - then, the CPU will return (jump) to EXITCHAR2VID
 603+ 0781 23           NXTCPCK:        inc     HL              ; jump over 2 cells...
 604+ 0782 23                           inc     HL              ; ...to the next char code
 605+ 0783 10 EF                        djnz    RPTCPCK         ; repeat
 606+ 0785                              ; it'a not a special char, just print it
 607+ 0785 CD 0F 07                     call    LOAD_CRSR_POS   ; recover position of cursor
 608+ 0788 3A 79 55                     ld      A,(CHR4VID)     ; recover char to print
 609+ 078B CD A5 06                     call    WRITE_VIDEO_LOC ; write A into VRAM at (HL)
 610+ 078E 3A 72 55                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 611+ 0791 5F                           ld      E,A             ; store cursor Y into E
 612+ 0792 3A 71 55                     ld      A,(SCR_CURS_X)  ; load cursor X
 613+ 0795 3C                           inc     A               ; move 1 step to right
 614+ 0796 21 6C 55                     ld      HL,SCR_SIZE_W   ; cell that keeps the width of screen
 615+ 0799 BE                           cp      (HL)            ; have we reached the most right position?
 616+ 079A 20 0F                        jr      NZ,SETCSRCOORDS ; no, go over
 617+ 079C 1C                           inc     E               ; yes, increment cursor Y (go to next line)
 618+ 079D 7B                           ld      A,E             ; move cursor Y into A
 619+ 079E 21 6D 55                     ld      HL,SCR_SIZE_H   ; cell that keeps the height of screen
 620+ 07A1 BE                           cp      (HL)            ; have we reached the bottom of the screen?
 621+ 07A2 20 06                        jr      NZ,SETCRSRY     ; no, jump over
 622+ 07A4 D5                           push    DE
 623+ 07A5 CD 49 09                     call    SCROLLUP        ; scroll screen up
 624+ 07A8 D1                           pop     DE
 625+ 07A9 1D                           dec     E               ; decrement 1 row, to set cursor Y on the last line
 626+ 07AA AF           SETCRSRY:       xor     A               ; then set cursor X to 0 (go to beginning of line)
 627+ 07AB 32 71 55     SETCSRCOORDS:   ld      (SCR_CURS_X),A  ; store current cursor X
 628+ 07AE 7B                           ld      A,E             ; recover Y
 629+ 07AF 32 72 55                     ld      (SCR_CURS_Y),A  ; store current cursor Y
 630+ 07B2 CD CC 06                     call    POS_CURSOR      ; position cursor into new location
 631+ 07B5 3A 5C 55                     ld      A,(TMRCNT)      ; load status of cursor flashing
 632+ 07B8 E6 20                        and     $20             ; check cursor state
 633+ 07BA 32 77 55                     ld      (LSTCSRSTA),A   ; store the last cursor state
 634+ 07BD AF           EXITCHAR2VID:   xor     A               ; reset char
 635+ 07BE 32 79 55                     ld      (CHR4VID),A     ; to be sent to screen
 636+ 07C1 F1                           pop     AF              ; recover cursor state
 637+ 07C2 A7                           and     A               ; was it off (A=0)?
 638+ 07C3 C4 2D 09                     call    NZ,CURSOR_ON    ; no, set cursor on
 639+ 07C6 E1                           pop     HL              ; restore HL
 640+ 07C7 D1                           pop     DE              ; restore DE
 641+ 07C8 C1                           pop     BC              ; restore BC
 642+ 07C9 F1                           pop     AF              ; restore AF
 643+ 07CA C9           PLACEHOLDER:    ret                     ; return to caller
 644+ 07CB
 645+ 07CB              ; flash the cursor at the current position
 646+ 07CB              ; (this sub-routine is called by CH3 timer ISR)
 647+ 07CB 3A 76 55     FLASHCURSOR:    ld      A,(CRSR_STATE)  ; now, check the cursor
 648+ 07CE A7                           and     A               ; cursor off (A=0)?
 649+ 07CF C8                           ret     Z               ; yes, return
 650+ 07D0 3A 5C 55                     ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
 651+ 07D3 E6 20                        and     $20             ; check if it's time to flash the cursor (check bit #6)
 652+ 07D5 21 77 55                     ld      HL,LSTCSRSTA    ; load address of cell that stores the last cursor state
 653+ 07D8 BE                           cp      (HL)            ; compare current state with last state
 654+ 07D9 C8                           ret     Z               ; same state, no change required - exit
 655+ 07DA 77                           ld      (HL),A          ; save new state
 656+ 07DB F5                           push    AF              ; store A (keep state for later use)
 657+ 07DC CD 0F 07                     call    LOAD_CRSR_POS   ; load current cursor position into HL
 658+ 07DF F1                           pop     AF              ; recover current state
 659+ 07E0 06 FF                        ld      B,$FF           ; cursor char
 660+ 07E2 FE 20                        cp      $20             ; is the cursor on video (A == $20)?
 661+ 07E4 28 04                        jr      Z,PUTCRSCHR     ; yes, jump over
 662+ 07E6 3A 75 55                     ld      A,(SCR_ORG_CHR) ; no, load the original char
 663+ 07E9 47                           ld      B,A             ; move char into B
 664+ 07EA 78           PUTCRSCHR:      ld      A,B             ; recover char from B
 665+ 07EB C3 A5 06                     jp      WRITE_VIDEO_LOC ; print cursor/char at the current position & return
 666+ 07EE
 667+ 07EE
 668+ 07EE              ; insert an empty space at the current position of the cursor, moving the following text
 669+ 07EE              ; 1 cell straight
 670+ 07EE CD 06 07     INSERTKEY:      call    RSTCHRCRS       ; restore char under the cursor
 671+ 07F1 CD 0F 07                     call    LOAD_CRSR_POS   ; retrieve address of cursor cell
 672+ 07F4 22 7C 55                     ld      (CUR_POS),HL    ; store it
 673+ 07F7 CD 49 0A                     call    ENDOFLN         ; find address of first free cell after the end of the text from the current cursor position - address into HL -
 674+ 07FA                                                      ; DE is the address of the bottom right cell of the screen
 675+ 07FA 22 80 55                     ld      (ENDTXT),HL     ; store it
 676+ 07FD ED 4B 7C 55                  ld      BC,(CUR_POS)    ; load starting address
 677+ 0801 AF                           xor     A
 678+ 0802 ED 42                        sbc     HL,BC           ; how many positions to move?
 679+ 0804 CA DC 06                     jp      Z,MOVSHOWCRS    ; none - leave and re-place cursor
 680+ 0807 44 4D                        ld      BC,HL           ; number of chars to scroll into BC
 681+ 0809 2A 80 55                     ld      HL,(ENDTXT)     ; load address of the end of text
 682+ 080C 2B           CHKHL:          dec     HL              ; decrement to find the address of the char to move
 683+ 080D E5                           push    HL
 684+ 080E CD 38 41                     call    CMP16           ; is it the last cell (bottom right) of screen?
 685+ 0811 E1                           pop     HL
 686+ 0812 D2 1D 08                     jp      NC,NXTINST      ; yes, so jump over - nothing to do
 687+ 0815 CD 90 06                     call    READ_VIDEO_LOC  ; no, so read current char
 688+ 0818 23                           inc     HL              ; next cell
 689+ 0819 CD A5 06                     call    WRITE_VIDEO_LOC ; write into new position
 690+ 081C 2B                           dec     HL              ; decrement to old position
 691+ 081D 0B           NXTINST:        dec     BC              ; decrement number of chars to move
 692+ 081E 79                           ld      A,C
 693+ 081F B0                           or      B               ; finished?
 694+ 0820 20 EA                        jr      NZ,CHKHL        ; no, repeat
 695+ 0822 3E 20                        ld      A,SPC           ; load SPACE character
 696+ 0824 2A 7C 55                     ld      HL,(CUR_POS)    ; get cursor position
 697+ 0827 32 75 55                     ld      (SCR_ORG_CHR),A ; reset original char under the cursor
 698+ 082A CD A5 06                     call    WRITE_VIDEO_LOC ; empty current video location
 699+ 082D C3 DC 06                     jp      MOVSHOWCRS      ; re-place cursor
 700+ 0830
 701+ 0830              ; delete the char at the left of the cursor
 702+ 0830 CD 06 07     BACKSPACE:      call    RSTCHRCRS       ; restore char
 703+ 0833 2A 6F 55                     ld      HL,(SCR_NAM_TB) ; address of origin of screen (location 0,0)
 704+ 0836 44 4D                        ld      BC,HL           ; store into BC
 705+ 0838 CD 0F 07                     call    LOAD_CRSR_POS   ; load address of current cursor pos.
 706+ 083B 54 5D                        ld      DE,HL           ; copy into DE
 707+ 083D AF                           xor     A               ; reset Carry
 708+ 083E ED 42                        sbc     HL,BC           ; check how many chars between
 709+ 0840 CA 6A 08                     jp      Z,LVBKSP        ; none, so we are at the top left corner
 710+ 0843 ED 53 7C 55                  ld      (CUR_POS),DE    ; store current cursor position
 711+ 0847 CD 49 0A                     call    ENDOFLN         ; check end of text
 712+ 084A ED 5B 7C 55                  ld      DE,(CUR_POS)    ; retrieve cursor position
 713+ 084E AF                           xor     A               ; reset Carry
 714+ 084F ED 52                        sbc     HL,DE           ; check if none follows
 715+ 0851 CA 6A 08                     jp      Z,LVBKSP        ; no chars follow, so simply move the cursor
 716+ 0854 44 4D                        ld      BC,HL           ; save numbers of chars to move
 717+ 0856 EB                           ex      DE,HL           ; copy starting position into HL
 718+ 0857 CD 90 06     MVBKSP:         call    READ_VIDEO_LOC  ; read char
 719+ 085A 2B                           dec     HL              ; 1 position to left
 720+ 085B CD A5 06                     call    WRITE_VIDEO_LOC ; write char
 721+ 085E 23                           inc     HL              ; goto next char to copy (2 steps to right)
 722+ 085F 23                           inc     HL
 723+ 0860 0B                           dec     BC              ; decrement # of chars
 724+ 0861 79                           ld      A,C
 725+ 0862 B0                           or      B               ; 0 chars?
 726+ 0863 20 F2                        jr      NZ,MVBKSP       ; not finished, continue
 727+ 0865 2B                           dec     HL
 728+ 0866 AF                           xor     A
 729+ 0867 CD A5 06                     call    WRITE_VIDEO_LOC ; reset last char
 730+ 086A CD 9C 08     LVBKSP:         call    MVCRS2LFT       ; move cursor to new position
 731+ 086D CD F1 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 732+ 0870 C3 DC 06                     jp      MOVSHOWCRS      ; move cursor to the new location and set it ON
 733+ 0873
 734+ 0873
 735+ 0873              ; move cursor to left
 736+ 0873 F5           CURSORLEFT:     push    AF              ; store A
 737+ 0874 3A 71 55                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 738+ 0877 A7                           and     A               ; is it at the most left of the screen (X=0)?
 739+ 0878 28 0C                        jr      Z,CHCKYPOS      ; yes, check Y position
 740+ 087A 3D                           dec     A               ; no, decrement X
 741+ 087B 32 73 55                     ld      (SCR_CUR_NX),A  ; store new X
 742+ 087E 3A 72 55                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 743+ 0881 32 74 55                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 744+ 0884 18 11                        jr      CONTCRSLFT      ; go on moving cursor
 745+ 0886 3A 72 55     CHCKYPOS:       ld      A,(SCR_CURS_Y)  ; load cursor Y
 746+ 0889 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 747+ 088A 28 0E                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 748+ 088C 3D                           dec     A               ; no, decrement Y
 749+ 088D 32 74 55                     ld      (SCR_CUR_NY),A  ; store new Y
 750+ 0890 3A 6C 55                     ld      A,(SCR_SIZE_W)  ; load current screen width
 751+ 0893 3D                           dec     A               ; cursor to the most right position (width-0)
 752+ 0894 32 73 55                     ld      (SCR_CUR_NX),A  ; set new cursor X
 753+ 0897 CD D6 06     CONTCRSLFT:     call    MOVCRS          ; move cursor into new position
 754+ 089A F1           EXITCURSORLEFT: pop     AF              ; restore A
 755+ 089B C9                           ret                     ; return to caller
 756+ 089C
 757+ 089C              ; move cursor 1 position to the left
 758+ 089C 3A 71 55     MVCRS2LFT:      ld      A,(SCR_CURS_X)  ; load cursor X into A
 759+ 089F A7                           and     A               ; is it at the most left of the screen (X=0)?
 760+ 08A0 28 0B                        jr      Z,CHKYPOS       ; yes, check Y position
 761+ 08A2 3D                           dec     A               ; no, decrement X
 762+ 08A3 32 73 55                     ld      (SCR_CUR_NX),A  ; store new X
 763+ 08A6 3A 72 55                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 764+ 08A9 32 74 55                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 765+ 08AC C9                           ret                     ; go on moving cursor
 766+ 08AD 3A 72 55     CHKYPOS:        ld      A,(SCR_CURS_Y)  ; load cursor Y
 767+ 08B0 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 768+ 08B1 28 E7                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 769+ 08B3 3D                           dec     A               ; no, decrement Y
 770+ 08B4 32 74 55                     ld      (SCR_CUR_NY),A  ; store new Y
 771+ 08B7 3A 6C 55                     ld      A,(SCR_SIZE_W)  ; load current screen width
 772+ 08BA 3D                           dec     A               ; cursor to the most right position (width-1)
 773+ 08BB 32 73 55                     ld      (SCR_CUR_NX),A  ; set new cursor X
 774+ 08BE C9                           ret                     ; return to caller
 775+ 08BF
 776+ 08BF              ; move cursor up
 777+ 08BF F5           CURSORUP:       push    AF              ; store A
 778+ 08C0 3A 72 55                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 779+ 08C3 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 780+ 08C4 28 10                        jr      Z,EXITCURSORUP  ; yes, exit doing nothing
 781+ 08C6 3D                           dec     A               ; no, decrement Y
 782+ 08C7 32 74 55                     ld      (SCR_CUR_NY),A  ; store new Y
 783+ 08CA 3A 71 55                     ld      A,(SCR_CURS_X)  ; load current cursor X
 784+ 08CD 32 73 55                     ld      (SCR_CUR_NX),A  ; set new cursor X
 785+ 08D0 CD 06 07                     call    RSTCHRCRS       ; restore char under the cursor and print it
 786+ 08D3 CD D6 06                     call    MOVCRS          ; move cursor into new position
 787+ 08D6 F1           EXITCURSORUP:   pop     AF              ; restore A
 788+ 08D7 C9                           ret                     ; return to caller
 789+ 08D8
 790+ 08D8
 791+ 08D8              ; move cursor to right
 792+ 08D8 F5           CURSORRIGHT:    push    AF              ; store A
 793+ 08D9 C5                           push    BC              ; store B
 794+ 08DA 3A 6C 55                     ld      A,(SCR_SIZE_W)  ; load current screen width (in text modes it's 32 or 40)
 795+ 08DD 3D                           dec     A               ; decrement it (most right can only be 31 or 39)
 796+ 08DE 47                           ld      B,A             ; move A into B
 797+ 08DF 3A 71 55                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 798+ 08E2 B8                           cp      B               ; is cursor at the most right position on the screen?
 799+ 08E3 30 0C                        jr      NC,CHCKYPOS2    ; yes, so jump to check Y position
 800+ 08E5 3C                           inc     A               ; no, so increment X
 801+ 08E6 32 73 55                     ld      (SCR_CUR_NX),A  ; store new X
 802+ 08E9 3A 72 55                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 803+ 08EC 32 74 55                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 804+ 08EF 18 13                        jr      CONTCRSRGT      ; go on moving cursor
 805+ 08F1 3A 6D 55     CHCKYPOS2:      ld      A,(SCR_SIZE_H)  ; load screen height
 806+ 08F4 3D                           dec     A               ; decrement it (last row can only be 23)
 807+ 08F5 47                           ld      B,A             ; move bottom into B
 808+ 08F6 3A 72 55                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 809+ 08F9 B8                           cp      B               ; is the cursor at the bottom of the screen?
 810+ 08FA 30 0E                        jr      NC,EXITCURSORRGHT; yes, exit doing nothing
 811+ 08FC 3C                           inc     A               ; no, increment Y
 812+ 08FD 32 74 55                     ld      (SCR_CUR_NY),A  ; store new Y
 813+ 0900 AF                           xor     A               ; move cursor to top left
 814+ 0901 32 73 55                     ld      (SCR_CUR_NX),A  ; store new X
 815+ 0904 CD 06 07     CONTCRSRGT:     call    RSTCHRCRS       ; restore char under the cursor and print it
 816+ 0907 CD D6 06                     call    MOVCRS          ; move cursor into new position
 817+ 090A C1           EXITCURSORRGHT: pop     BC              ; retrieve BC
 818+ 090B F1                           pop     AF              ; restore A
 819+ 090C C9                           ret                     ; return to caller
 820+ 090D
 821+ 090D
 822+ 090D              ; move cursor down
 823+ 090D F5           CURSORDOWN:     push    AF              ; store A
 824+ 090E C5                           push    BC              ; store B
 825+ 090F 3A 6D 55                     ld      A,(SCR_SIZE_H)  ; load current screen height (in text modes it's 24)
 826+ 0912 3D                           dec     A               ; decrement it (positions can only vary between 0 and 23)
 827+ 0913 47                           ld      B,A             ; move X into B
 828+ 0914 3A 72 55                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 829+ 0917 B8                           cp      B               ; is current cursor position < 23?
 830+ 0918 30 10                        jr      NC,EXITCURSORDOWN; no, exit doing nothing
 831+ 091A 3C                           inc     A               ; yes, increment Y
 832+ 091B 32 74 55                     ld      (SCR_CUR_NY),A  ; store new Y
 833+ 091E 3A 71 55                     ld      A,(SCR_CURS_X)  ; load current cursor X
 834+ 0921 32 73 55                     ld      (SCR_CUR_NX),A  ; set new cursor X
 835+ 0924 CD 06 07                     call    RSTCHRCRS       ; restore char under the cursor and print it
 836+ 0927 CD D6 06                     call    MOVCRS          ; move cursor into new position
 837+ 092A C1           EXITCURSORDOWN: pop     BC              ; retrieve BC
 838+ 092B F1                           pop     AF              ; retrieve A
 839+ 092C C9                           ret                     ; return to caller
 840+ 092D
 841+ 092D
 842+ 092D              ; set cursor on (visible on screen)
 843+ 092D F5           CURSOR_ON:      push    AF              ; store AF
 844+ 092E 3A 76 55                     ld      A,(CRSR_STATE)  ; load cursor state
 845+ 0931 B7                           or      A               ; is it on?
 846+ 0932 20 0C                        jr      NZ,EXITCURSOR_ON; yes, so nothing to do
 847+ 0934 3A 6D 55                     ld      A,(SCR_SIZE_H)  ; check the video mode
 848+ 0937 FE 30                        cp      $30             ; graphics 2 or 3 (if value>=48)?
 849+ 0939 30 05                        jr      NC,EXITCURSOR_ON; yes, so exit (no cursor in graphics 2 or 3)
 850+ 093B 3E 01                        ld      A,$01           ; cursor state ON
 851+ 093D 32 76 55                     ld      (CRSR_STATE),A  ; set state
 852+ 0940 F1           EXITCURSOR_ON:  pop     AF              ; restore AF
 853+ 0941 C9                           ret                     ; return to caller
 854+ 0942
 855+ 0942              ; set cursor off (invisible on screen)
 856+ 0942 F5           CURSOR_OFF:     push    AF              ; store AF
 857+ 0943 AF                           xor     A               ; cursor state OFF
 858+ 0944 32 76 55                     ld      (CRSR_STATE),A  ; set state
 859+ 0947 F1                           pop     AF              ; restore AF
 860+ 0948 C9                           ret
 861+ 0949
 862+ 0949              ; scroll the screen 1 row up
 863+ 0949 AF           SCROLLUP:       xor     A               ; reset A
 864+ 094A 57                           ld      D,A             ; reset D
 865+ 094B 32 78 55                     ld      (PRNTVIDEO),A   ; no print on screen while scrolling
 866+ 094E 2A 6F 55                     ld      HL,(SCR_NAM_TB) ; start address of the name table
 867+ 0951 22 AC 55                     ld      (VIDTMP1),HL    ; store address of the destination row (1st row of the screen)
 868+ 0954 3A 6C 55                     ld      A,(SCR_SIZE_W)  ; load the screen width
 869+ 0957 5F                           ld      E,A             ; move width into E
 870+ 0958 19                           add     HL,DE           ; HL now contains the address of the source row (2nd row of the screen)
 871+ 0959 22 AE 55                     ld      (VIDTMP2),HL    ; store address of source row
 872+ 095C 3A 6D 55                     ld      A,(SCR_SIZE_H)  ; load the screen height
 873+ 095F 3D                           dec     A               ; decrement the # of rows: now, A contains the # of rows to be moved
 874+ 0960 47                           ld      B,A             ; move # of rows into B
 875+ 0961 3A 6C 55     SCROLLNXTRW:    ld      A,(SCR_SIZE_W)  ; (re)load the screen width
 876+ 0964 5F                           ld      E,A             ; move width into E
 877+ 0965 2A AE 55                     ld      HL,(VIDTMP2)    ; load source address
 878+ 0968 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 879+ 096A ED 69                        out     (C),L           ; low byte of source
 880+ 096C ED 61                        out     (C),H           ; high byte of source
 881+ 096E 21 84 55                     ld      HL,VIDEOBUFF    ; load address of the first cell of the video buffer
 882+ 0971 0D                           dec     C               ; VDP data mode
 883+ 0972 00                           nop                     ; added to compensate shorter instruction
 884+ 0973 ED 78        LOADNEXTCOL:    in      A,(C)           ; load char
 885+ 0975 77                           ld      (HL),A          ; store char
 886+ 0976 23                           inc     HL              ; next cell of the buffer
 887+ 0977 1D                           dec     E               ; count the chars to be read
 888+ 0978 20 F9                        jr      NZ,LOADNEXTCOL  ; repeat until we read the entire row
 889+ 097A 3A 6C 55                     ld      A,(SCR_SIZE_W)  ; reload the screen width
 890+ 097D 5F                           ld      E,A             ; move # of rows into E
 891+ 097E 16 00                        ld      D,$00           ; reset D
 892+ 0980 2A AC 55                     ld      HL,(VIDTMP1)    ; load address of destination row
 893+ 0983 E5                           push    HL              ; store HL
 894+ 0984 2A AE 55                     ld      HL,(VIDTMP2)    ; current source will be..
 895+ 0987 22 AC 55                     ld      (VIDTMP1),HL    ; ..new destination
 896+ 098A 19                           add     HL,DE           ; address of new
 897+ 098B 22 AE 55                     ld      (VIDTMP2),HL    ; source row
 898+ 098E E1                           pop     HL              ; restore address of current destination row
 899+ 098F CB F4                        set     6,H             ; writing mode
 900+ 0991 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 901+ 0993 ED 69                        out     (C),L           ; low byte
 902+ 0995 ED 61                        out     (C),H           ; high byte of address
 903+ 0997 21 84 55                     ld      HL,VIDEOBUFF    ; video buffer address
 904+ 099A 0D                           dec     C               ; VDP data mode
 905+ 099B 7E           WRITEBUF:       ld      A,(HL)          ; load char
 906+ 099C ED 79                        out     (C),A           ; send char
 907+ 099E 23                           inc     HL              ; increment buffer index
 908+ 099F 1D                           dec     E               ; next row
 909+ 09A0 20 F9                        jr      NZ,WRITEBUF     ; repeat until 0
 910+ 09A2 10 BD                        djnz    SCROLLNXTRW     ; repeat for the entire screen
 911+ 09A4 3A 6C 55                     ld      A,(SCR_SIZE_W)  ; reload screen width
 912+ 09A7 47                           ld      B,A             ; cells to empty into B
 913+ 09A8 AF                           xor     A               ; null char
 914+ 09A9 0E 31                        ld      C,VDP_SET       ; VDP set mode
 915+ 09AB 2A AC 55                     ld      HL,(VIDTMP1)    ; load address of the last row
 916+ 09AE CB F4                        set     6,H             ; writing mode
 917+ 09B0 ED 69                        out     (C),L           ; low byte then..
 918+ 09B2 ED 61                        out     (C),H           ; high byte of address
 919+ 09B4 0D                           dec     C               ; VDP data mode
 920+ 09B5 00                           nop                     ; delay
 921+ 09B6 ED 79        RPTEMPTYROW:    out     (C),A           ; empty cell
 922+ 09B8 00                           nop                     ; delay
 923+ 09B9 00                           nop
 924+ 09BA 10 FA                        djnz    RPTEMPTYROW     ; repeat until the last row has been cleaned
 925+ 09BC 3E 01                        ld      A,$01
 926+ 09BE 32 78 55                     ld      (PRNTVIDEO),A   ; set print-on-video on
 927+ 09C1 C9                           ret                     ; return to caller
 928+ 09C2
 929+ 09C2              ; carriage return: first, it looks for char $00 at the beginning of the line (look for the first null char),
 930+ 09C2              ; then it starts sendind every char it finds on the screen to the terminal buffer of the BASIC interpreter
 931+ 09C2              ; until another null char is found. Finally, move to the next line and position the cursor at the beginning
 932+ 09C2              ; of the row (equivalent to CR+LF), then gets back control to the screen editor to let it interpret the line
 933+ 09C2              CUR_POS         equ     TMPBFR1         ; cursor position
 934+ 09C2              SRTTXT          equ     TMPBFR2         ; start of text line
 935+ 09C2              ENDTXT          equ     TMPBFR3         ; end of text line
 936+ 09C2              CRGRETURN:      ; preliminary: disable cursor if on, and retrieve char under it
 937+ 09C2 3A 76 55                     ld      A,(CRSR_STATE)  ; recover cursor state
 938+ 09C5 32 82 55                     ld      (TMPBFR4),A     ; store status
 939+ 09C8 A7                           and     A               ; is cursor on?
 940+ 09C9 C4 42 09                     call    NZ,CURSOR_OFF   ; yes, so set cursor off
 941+ 09CC CD 06 07                     call    RSTCHRCRS       ; restore char under it
 942+ 09CF                              ; first, check if cursor if off, so that we just interpret return as a new line command
 943+ 09CF 3A B6 55                     ld      A,(KBDNPT)      ; check if input from keyboad
 944+ 09D2 A7                           and     A               ; if 0, input is not from keyboard...
 945+ 09D3 CA 28 0A                     jp      Z,PRNTRETURN    ; ...so just print a carriage return; otherwise, interpret the return
 946+ 09D6                              ; first part: look for the beginning of the text line on screen
 947+ 09D6 CD 0F 07                     call    LOAD_CRSR_POS   ; load cursor position into HL
 948+ 09D9 22 7C 55                     ld      (CUR_POS),HL    ; store it
 949+ 09DC ED 5B 6F 55                  ld      DE,(SCR_NAM_TB) ; load VRAM address of top-left cell of screen ("home")
 950+ 09E0 E5           RPTNLLSRC:      push    HL
 951+ 09E1 CD 38 41                     call    CMP16           ; check if at "home"
 952+ 09E4 E1                           pop     HL
 953+ 09E5 CA F0 09                     jp      Z,CNTNULL       ; yes, exit because there is nothing before
 954+ 09E8 2B                           dec     HL              ; go 1 step back
 955+ 09E9 CD 90 06                     call    READ_VIDEO_LOC  ; read char of current position
 956+ 09EC A7                           and     A               ; is it $00 (null char)?
 957+ 09ED 20 F1                        jr      NZ,RPTNLLSRC    ; no, continue searching
 958+ 09EF 23                           inc     HL              ; move 1 step forward to go back to the last cell with something in
 959+ 09F0                              ; second part: look for the ending of the text on screen
 960+ 09F0 22 7E 55     CNTNULL:        ld      (SRTTXT),HL     ; store beginning of text
 961+ 09F3 CD 49 0A                     call    ENDOFLN         ; find end of text line looking at the end of chars after the cursor position
 962+ 09F6 22 80 55                     ld      (ENDTXT),HL     ; store ending of text line
 963+ 09F9 ED 5B 7E 55                  ld      DE,(SRTTXT)     ; load beginning of text line
 964+ 09FD A7                           and     A               ; clear Carry
 965+ 09FE ED 52                        sbc     HL,DE           ; how many chars?
 966+ 0A00 28 26                        jr      Z,PRNTRETURN    ; no chars found (HL-DE=0), so just print return & leave
 967+ 0A02                              ;---    central part: send the text on the screen to the interpreter
 968+ 0A02 2A 7E 55                     ld      HL,(SRTTXT)     ; load beginning of text line
 969+ 0A05 ED 5B 80 55                  ld      DE,(ENDTXT)     ; load ending of text line
 970+ 0A09 CD 90 06     SNDCHRTOBFR:    call    READ_VIDEO_LOC  ; read char
 971+ 0A0C E5                           push    HL
 972+ 0A0D CD FD 01                     call    CHARINTOBFR     ; send char to buffer
 973+ 0A10 E1                           pop     HL
 974+ 0A11 23                           inc     HL              ; go to next char
 975+ 0A12 E5                           push    HL              ; store HL
 976+ 0A13 CD 38 41                     call    CMP16           ; check if DE=HL (finish chars)
 977+ 0A16 E1                           pop     HL
 978+ 0A17 20 F0                        jr      NZ,SNDCHRTOBFR  ; no, repeat
 979+ 0A19 3E 0D                        ld      A,CR            ; yes, so now send carriage return
 980+ 0A1B CD FD 01                     call    CHARINTOBFR     ; send to buffer
 981+ 0A1E 2A 80 55                     ld      HL,(ENDTXT)     ; recover address of last char of input text
 982+ 0A21 CD 32 07                     call    HL2XY           ; retrieve X,Y from address
 983+ 0A24 7D                           ld      A,L             ; move Y into A (we don't need X anymore)
 984+ 0A25 32 72 55                     ld      (SCR_CURS_Y),A  ; store new Y
 985+ 0A28                              ;---    final part: go at the beginning of a new line on the screen
 986+ 0A28 AF           PRNTRETURN:     xor     A               ; move to col 0
 987+ 0A29 32 71 55                     ld      (SCR_CURS_X),A  ; store new X
 988+ 0A2C 3A 72 55                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 989+ 0A2F 3C                           inc     A               ; new row
 990+ 0A30 21 6D 55                     ld      HL,SCR_SIZE_H   ; load address of cell that keeps screen height
 991+ 0A33 BE                           cp      (HL)            ; is the cursor over the bottom of the screen?
 992+ 0A34 38 06                        jr      C,ADDNEWLINE    ; no, jump over
 993+ 0A36 3D                           dec     A               ; yes, so come back 1 row, then...
 994+ 0A37 F5                           push    AF              ; (store A)
 995+ 0A38 CD 49 09                     call    SCROLLUP        ; ...scroll the screen before to...
 996+ 0A3B F1                           pop     AF              ; (retrieve A)
 997+ 0A3C 32 72 55     ADDNEWLINE:     ld      (SCR_CURS_Y),A  ; ...store new Y
 998+ 0A3F 3A 82 55                     ld      A,(TMPBFR4)     ; retrieve cursor state
 999+ 0A42 A7                           and     A               ; was it off (A=0)?
1000+ 0A43 C4 2D 09                     call    NZ,CURSOR_ON    ; no, set cursor on
1001+ 0A46 C3 CC 06                     jp      POS_CURSOR      ; position cursor to new location & return to caller
1002+ 0A49
1003+ 0A49              ; find end of text line
1004+ 0A49              ; destroys A, DE, and HL - store address of last char of text line into HL,
1005+ 0A49              ; while DE contains the address of the bottom right cell of the screen
1006+ 0A49 3A 6D 55     ENDOFLN:        ld      A,(SCR_SIZE_H)
1007+ 0A4C 5F                           ld      E,A             ; load screen height into DE
1008+ 0A4D 3A 6C 55                     ld      A,(SCR_SIZE_W)
1009+ 0A50 6F                           ld      L,A             ; load screen width into HL
1010+ 0A51 AF                           xor     A
1011+ 0A52 67                           ld      H,A
1012+ 0A53 57                           ld      D,A
1013+ 0A54 CD 43 41                     call    MUL16           ; multiply HL times DE to get the screen size
1014+ 0A57 ED 5B 6F 55                  ld      DE,(SCR_NAM_TB) ; load screen name table start address into DE
1015+ 0A5B 19                           add     HL,DE           ; get the address...
1016+ 0A5C 2B                           dec     HL              ; ...of the "last" video cell
1017+ 0A5D EB                           ex      DE,HL           ; store address into DE
1018+ 0A5E 2A 7C 55                     ld      HL,(CUR_POS)    ; retrieve original cursor position
1019+ 0A61 E5           RPTNLLSRC2:     push    HL
1020+ 0A62 CD 38 41                     call    CMP16           ; check if at last position on screen (bottom right corner)
1021+ 0A65 E1                           pop     HL
1022+ 0A66 C8                           ret     Z               ; if yes, exit because these is nothing after
1023+ 0A67 23                           inc     HL              ; 1 more step forward
1024+ 0A68 CD 90 06                     call    READ_VIDEO_LOC  ; read char of current position
1025+ 0A6B A7                           and     A               ; is it $00 (null char)?
1026+ 0A6C 20 F3                        jr      NZ,RPTNLLSRC2   ; no, continue searching
1027+ 0A6E C9                           ret                     ; yes: found end of text, return to caller
1028+ 0A6F
1029+ 0A6F
1030+ 0A6F              ; ------------------------------------------------------------------------------
1031+ 0A6F                              ; this table contains the values of the offsets to be added to
1032+ 0A6F                              ; the starting address of the name table to find the correct
1033+ 0A6F                              ; value of the first cell of the corresponding row
1034+ 0A6F                              ; (by doing so, it's faster than doing a multipication)
1035+ 0A6F                              ; table for graphics 1 text mode: 32 cols
1036+ 0A6F 00 00 20 00  POS_TB_CRS_32:  defw    $0000,$0020,$0040,$0060,$0080,$00A0,$00C0,$00E0
1036+ 0A73 40 00 60 00
1036+ 0A77 80 00 A0 00
1036+ 0A7B C0 00 E0 00
1037+ 0A7F 00 01 20 01                  defw    $0100,$0120,$0140,$0160,$0180,$01A0,$01C0,$01E0
1037+ 0A83 40 01 60 01
1037+ 0A87 80 01 A0 01
1037+ 0A8B C0 01 E0 01
1038+ 0A8F 00 02 20 02                  defw    $0200,$0220,$0240,$0260,$0280,$02A0,$02C0,$02E0
1038+ 0A93 40 02 60 02
1038+ 0A97 80 02 A0 02
1038+ 0A9B C0 02 E0 02
1039+ 0A9F                              ; table for pure text mode: 40 cols
1040+ 0A9F 00 00 28 00  POS_TB_CRS_40:  defw    $0000,$0028,$0050,$0078,$00A0,$00C8,$00F0,$0118
1040+ 0AA3 50 00 78 00
1040+ 0AA7 A0 00 C8 00
1040+ 0AAB F0 00 18 01
1041+ 0AAF 40 01 68 01                  defw    $0140,$0168,$0190,$01B8,$01E0,$0208,$0230,$0258
1041+ 0AB3 90 01 B8 01
1041+ 0AB7 E0 01 08 02
1041+ 0ABB 30 02 58 02
1042+ 0ABF 80 02 A8 02                  defw    $0280,$02A8,$02D0,$02F8,$0320,$0348,$0370,$0398
1042+ 0AC3 D0 02 F8 02
1042+ 0AC7 20 03 48 03
1042+ 0ACB 70 03 98 03
1043+ 0ACF
1044+ 0ACF              ; ------------------------------------------------------------------------------
1045+ 0ACF              ; reset VRAM
1046+ 0ACF AF           EMPTY_VRAM:     xor     A               ; reg.A cleared: we fill up VRAM with $00
1047+ 0AD0 67                           ld      H,A
1048+ 0AD1 6F                           ld      L,A             ; reset HL
1049+ 0AD2 CD 70 06                     call    SETVDPADRS      ; set address of first VRAM cell to $0000
1050+ 0AD5 06 40                        ld      B,$40           ; $40 pages of RAM...
1051+ 0AD7 57                           ld      D,A             ; ...each one with $100 cells (tot. $4000 bytes)
1052+ 0AD8 0D                           dec     C               ; VDP data mode
1053+ 0AD9 ED 79        EMPTVRM:        out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
1054+ 0ADB 14                           inc     D               ; next cell
1055+ 0ADC 00                           nop
1056+ 0ADD 20 FA                        jr      NZ,EMPTVRM      ; repeat until page is fully cleared
1057+ 0ADF 10 F8                        djnz    EMPTVRM         ; repeat for $40 pages
1058+ 0AE1 C9                           ret                     ; return to caller
1059+ 0AE2
1060+ 0AE2              ; clear video registers in SRAM
1061+ 0AE2 21 6C 55     CLR_RAM_REG:    ld      HL,SCR_SIZE_W   ; address of first register
1062+ 0AE5 AF                           xor     A               ; $00 to clean the registers
1063+ 0AE6 06 44                        ld      B,CHASNDDTN-SCR_SIZE_W; how many bytes (registers) to clean (dinamically calculated)
1064+ 0AE8 77           RSTVDPRAMREG:   ld      (HL),A          ; reset register
1065+ 0AE9 23                           inc     HL              ; next register
1066+ 0AEA 10 FC                        djnz    RSTVDPRAMREG    ; repeat
1067+ 0AEC C9                           ret                     ; return to caller
1068+ 0AED
1069+ 0AED              ; ------------------------------------------------------------------------------
1070+ 0AED              ; set a specific graphics mode, passed into reg. E
1071+ 0AED 06 08        SET_GFX_MODE:   ld      B,$08           ; 8 registers means 8 bytes..
1072+ 0AEF CB 23                        sla     E               ; multiply E by 8..
1073+ 0AF1 CB 23                        sla     E               ; so that reg. E can point..
1074+ 0AF3 CB 23                        sla     E               ; to the correct settings
1075+ 0AF5 16 00        SET_GFX_MODE2:  ld      D,$00           ; reset D
1076+ 0AF7 21 29 0B                     ld      HL,VDPMODESET   ; pointer to register settings | <= here points the SHOW_LOGO sub-routine
1077+ 0AFA 19                           add     HL,DE           ; add offset to get the correct set of values for the required mode
1078+ 0AFB 3E 80                        ld      A,$80           ; start with REG0 ($80+register number)
1079+ 0AFD 0E 31                        ld      C,VDP_SET       ; VDP set
1080+ 0AFF 56           LDREGVLS:       ld      D,(HL)          ; load register's value
1081+ 0B00 ED 51                        out     (C),D           ; send data to VDP
1082+ 0B02 ED 79                        out     (C),A           ; indicate the register to send data to
1083+ 0B04 3C                           inc     A               ; next register
1084+ 0B05 23                           inc     HL              ; next value
1085+ 0B06 10 F7                        djnz    LDREGVLS        ; repeat for 8 registers
1086+ 0B08 C9                           ret
1087+ 0B09
1088+ 0B09              ; ------------------------------------------------------------------------------
1089+ 0B09              LOADCHARSET:    ; reg. A contains the video mode
1090+ 0B09                              ; reg. HL contains address of pattern table into VRAM
1091+ 0B09 06 00                        ld      B,$00           ; 0=256 chars to load (complete charset)
1092+ 0B0B CB F4                        set     $06,H           ; add $4000 to address to indicate that we want to write into VRAM
1093+ 0B0D 0E 31                        ld      C,VDP_SET       ; load VDP address into C
1094+ 0B0F ED 69                        out     (C),L           ; send low byte of address
1095+ 0B11 ED 61                        out     (C),H           ; send high byte
1096+ 0B13 0D                           dec     C               ; VDP data mode
1097+ 0B14 21 6E 42                     ld      HL,CHRST68      ; starting address of 6x8 charset into ROM
1098+ 0B17 A7                           and     A               ; is it text mode (A=0)?
1099+ 0B18 28 03                        jr      Z,NXTCHAR       ; yes, so jump to load chars into VRAM
1100+ 0B1A 21 6E 4A                     ld      HL,CHRST88      ; no, so we change and load the 8x8 charset
1101+ 0B1D 16 08        NXTCHAR:        ld      D,$08           ; 8 bytes per pattern char
1102+ 0B1F 7E           SENDCHRPTRNS:   ld      A,(HL)          ; load byte to send to VDP
1103+ 0B20 ED 79                        out     (C),A           ; write byte into VRAM
1104+ 0B22 23                           inc     HL              ; inc byte pointer
1105+ 0B23 15                           dec     D               ; 8 bytes sents (0 char)?
1106+ 0B24 20 F9                        jr      NZ,SENDCHRPTRNS ; no, continue
1107+ 0B26 10 F5                        djnz    NXTCHAR         ; yes, decrement chars counter and continue for all the chars
1108+ 0B28 C9                           ret                     ; return to caller
1109+ 0B29
1110+ 0B29              ;------------------------------------------------------------------------------
1111+ 0B29              ; NAME TABLE:       buffer video - contains the chars to be shown on video
1112+ 0B29              ; PATTERN TABLE:    charset - contains the chars/tiles to be loaded into the name table
1113+ 0B29              ; COLOR TABLE:      color settings for chars/tiles
1114+ 0B29
1115+ 0B29                              ; VDP register settings for a text display
1116+ 0B29 00           VDPMODESET:     defb    %00000000       ; reg.0: external video off
1117+ 0B2A D0                           defb    %11010000       ; reg.1: 16K VRAM, video on, int. off, text mode (40x24)
1118+ 0B2B 02                           defb    $02             ; reg.2: name table set to $0800 ($02x$400)
1119+ 0B2C 00                           defb    $00             ; reg.3: not used in text mode
1120+ 0B2D 00                           defb    $00             ; reg.4: pattern table set to $0000
1121+ 0B2E 00                           defb    $00             ; reg.5: not used in text mode
1122+ 0B2F 00                           defb    $00             ; reg.6: not used in text mode
1123+ 0B30 F5                           defb    $f5             ; reg.7: white text on light blue background
1124+ 0B31
1125+ 0B31              VDPMODESET1:    ; VDP register settings for a graphics 1 mode
1126+ 0B31 00                           defb    %00000000       ; reg.0: ext. video off
1127+ 0B32 C0                           defb    %11000000       ; reg.1: 16K Vram; video on, int off, graphics mode 1, sprite size 8x8, sprite magn. 0
1128+ 0B33 06                           defb    $06             ; reg.2: name table address: $1800
1129+ 0B34 80                           defb    $80             ; reg.3: color table address: $2000
1130+ 0B35 00                           defb    $00             ; reg.4: pattern table address: $0000
1131+ 0B36 36                           defb    $36             ; reg.5: sprite attr. table address: $1B00
1132+ 0B37 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1133+ 0B38 05                           defb    $05             ; reg.7: backdrop color (light blue)
1134+ 0B39
1135+ 0B39              VDPMODESET2:    ; VDP register settings for a graphics 2 mode
1136+ 0B39 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1137+ 0B3A C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1138+ 0B3B 06                           defb    $06             ; reg.2: name table addr.: $1800
1139+ 0B3C FF                           defb    $FF             ; reg.3: color table addr.: $2000
1140+ 0B3D 03                           defb    $03             ; reg.4: pattern table addr.: $0000
1141+ 0B3E 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1142+ 0B3F 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1143+ 0B40 05                           defb    $05             ; reg.7: backdrop color: light blue
1144+ 0B41
1145+ 0B41              VDPMODESETMC:   ; VDP register settings for a multicolor mode
1146+ 0B41 00                           defb    %00000000       ; reg.0: ext. video dis.
1147+ 0B42 CB                           defb    %11001011       ; reg.1: 16K VRAM, video on, INT off, multicolor mode, sprite size 8x8, sprite magn. 0
1148+ 0B43 02                           defb    $02             ; reg.2: name table addr.: $0800
1149+ 0B44 00                           defb    $00             ; reg.3: don't care
1150+ 0B45 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1151+ 0B46 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1152+ 0B47 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1153+ 0B48 0F                           defb    $0F             ; reg.7: backdrop color (white)
1154+ 0B49
1155+ 0B49              VDPMODESETEX2:  ; VDP register settings for an extended graphics 2 mode
1156+ 0B49 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1157+ 0B4A C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1158+ 0B4B 0E                           defb    $0E             ; reg.2: name table addr.: $3800
1159+ 0B4C 9F                           defb    $9F             ; reg.3: color table addr.: $2000
1160+ 0B4D 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1161+ 0B4E 76                           defb    $76             ; reg.5: sprite attr. table addr.: $3B00
1162+ 0B4F 03                           defb    $03             ; reg.6: sprite pattern table addr.: $1800
1163+ 0B50 05                           defb    $05             ; reg.7: backdrop color: light blue
1164+ 0B51
1165+ 0B51              LM80CLOGO:      ; patterns to compose the splash screen logo
1166+ 0B51                              ; 1st band
1167+ 0B51 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1167+ 0B55 00 00 00 00
1167+ 0B59 00 00 00 00
1167+ 0B5D 00 00 00 00
1167+ 0B61 00 00 00 00
1167+ 0B65 00 00 00 00
1167+ 0B69 00 00 00 00
1167+ 0B6D 00 00 00 00
1168+ 0B71 00 00 0F 0A                  defb    0,0,15,10,11,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1168+ 0B75 0B 10 00 00
1168+ 0B79 00 00 00 00
1168+ 0B7D 00 00 00 00
1168+ 0B81 00 00 00 00
1168+ 0B85 00 00 00 00
1168+ 0B89 00 00 00 00
1168+ 0B8D 00 00 00 00
1169+ 0B91                              ; 2nd band
1170+ 0B91 00 00 0D 17                  defb    0,0,13,23,0,12,0,0,0,1,0,0,0,20,0,0,6,5,6,21,22,7,6,21,22,7,6,1,1,7,0,0
1170+ 0B95 00 0C 00 00
1170+ 0B99 00 01 00 00
1170+ 0B9D 00 14 00 00
1170+ 0BA1 06 05 06 15
1170+ 0BA5 16 07 06 15
1170+ 0BA9 16 07 06 01
1170+ 0BAD 01 07 00 00
1171+ 0BB1 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,20,6,1,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1171+ 0BB5 00 0C 00 00
1171+ 0BB9 00 01 00 00
1171+ 0BBD 00 01 14 06
1171+ 0BC1 01 05 03 05
1171+ 0BC5 03 05 03 05
1171+ 0BC9 03 05 03 05
1171+ 0BCD 03 05 00 00
1172+ 0BD1                              ; 3rd band
1173+ 0BD1 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,1,1,1,5,9,20,19,8,3,5,19,5,3,5,0,0,0,0
1173+ 0BD5 00 0C 00 00
1173+ 0BD9 00 01 00 00
1173+ 0BDD 00 01 01 01
1173+ 0BE1 01 05 09 14
1173+ 0BE5 13 08 03 05
1173+ 0BE9 13 05 03 05
1173+ 0BED 00 00 00 00
1174+ 0BF1 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,8,3,5,6,21,22,7,3,1,22,5,3,5,0,0,0,0
1174+ 0BF5 00 0C 00 00
1174+ 0BF9 00 01 00 00
1174+ 0BFD 00 01 00 08
1174+ 0C01 03 05 06 15
1174+ 0C05 16 07 03 01
1174+ 0C09 16 05 03 05
1174+ 0C0D 00 00 00 00
1175+ 0C11                              ; 4th band
1176+ 0C11 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,0,3,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1176+ 0C15 00 0C 00 00
1176+ 0C19 00 01 00 00
1176+ 0C1D 00 01 00 00
1176+ 0C21 03 05 03 05
1176+ 0C25 03 05 03 05
1176+ 0C29 03 05 03 05
1176+ 0C2D 03 05 00 00
1177+ 0C31 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,4,4,0,1,0,0,3,5,9,20,19,8,9,20,19,8,9,1,1,8,0,0
1177+ 0C35 00 0C 00 00
1177+ 0C39 00 01 04 04
1177+ 0C3D 00 01 00 00
1177+ 0C41 03 05 09 14
1177+ 0C45 13 08 09 14
1177+ 0C49 13 08 09 01
1177+ 0C4D 01 08 00 00
1178+ 0C51                              ; 5th band
1179+ 0C51 00 00 0E 12                  defb    0,0,14,18,18,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1179+ 0C55 12 11 00 00
1179+ 0C59 00 00 00 00
1179+ 0C5D 00 00 00 00
1179+ 0C61 00 00 00 00
1179+ 0C65 00 00 00 00
1179+ 0C69 00 00 00 00
1179+ 0C6D 00 00 00 00
1180+ 0C71 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1180+ 0C75 00 00 00 00
1180+ 0C79 00 00 00 00
1180+ 0C7D 00 00 00 00
1180+ 0C81 00 00 00 00
1180+ 0C85 00 00 00 00
1180+ 0C89 00 00 00 00
1180+ 0C8D 00 00 00 00
# file closed: ../include/vdp/vdp-1.08.asm
  70  0C91
  71  0C91              ; incude the latest version of the PSG module
  72  0C91                  INCLUDE "../include/psg/psg-1.1.asm"
# file opened: ../include/psg/psg-1.1.asm
   1+ 0C91              ; ------------------------------------------------------------------------------
   2+ 0C91              ; LM80C - PSG ROUTINES - 1.1
   3+ 0C91              ; ------------------------------------------------------------------------------
   4+ 0C91              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0C91              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0C91              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0C91              ; kind of warranty: you can use them at your own risk.
   8+ 0C91              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0C91              ; maintain the copyright notices, include this advice and the note to the
  10+ 0C91              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0C91              ; redistribuite them.
  12+ 0C91              ; https://www.leonardomiliani.com
  13+ 0C91              ;
  14+ 0C91              ; Please support me by visiting the following links:
  15+ 0C91              ; Main project page: https://www.leonardomiliani.com
  16+ 0C91              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0C91              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0C91              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0C91              ; ------------------------------------------------------------------------------
  20+ 0C91              ;
  21+ 0C91              ; ------------------------------------------------------------------------------
  22+ 0C91
  23+ 0C91              ;------------------------------------------------------------------------------
  24+ 0C91
  25+ 0C91              ; configure the PSG
  26+ 0C91 21 B0 55     initPSG:        ld      HL,CHASNDDTN    ; starting address of sound & keyboard RAM registers
  27+ 0C94 06 0E                        ld      B,SERIALS_EN-CHASNDDTN; # of PSG sound & keyboard registers
  28+ 0C96 AF                           xor     A               ; reset A
  29+ 0C97 77           EMPTSNDBFR:     ld      (HL),A          ; reset RAM register
  30+ 0C98 23                           inc     HL              ; next register
  31+ 0C99 10 FC                        djnz    EMPTSNDBFR      ; repeat
  32+ 0C9B 06 10        CLRPSGREGS:     ld      B,$10           ; 16 registers to set
  33+ 0C9D 21 AF 0C                     ld      HL,SNDREGCFG    ; starting address of register settings
  34+ 0CA0 16 00                        ld      D,$00           ; first register
  35+ 0CA2 7A           RSTPSG:         ld      A,D             ; register value
  36+ 0CA3 CD E9 0C                     call    SETSNDREG       ; select register
  37+ 0CA6 7E                           ld      A,(HL)          ; load value
  38+ 0CA7 CD EE 0C                     call    WRTSNDREG       ; write to register
  39+ 0CAA 14                           inc     D               ; next register
  40+ 0CAB 23                           inc     HL              ; next value
  41+ 0CAC 10 F4                        djnz    RSTPSG          ; repeat for each register
  42+ 0CAE C9                           ret                     ; return to caller
  43+ 0CAF
  44+ 0CAF 00 00 00 00  SNDREGCFG:      defb $00,$00,$00,$00,$00,$00,$00,%10111111
  44+ 0CB3 00 00 00 BF
  45+ 0CB7 00 00 00 00                  defb $00,$00,$00,$00,$00,$00,$ff,$ff
  45+ 0CBB 00 00 FF FF
  46+ 0CBF                              ; reg. 7: set I/O ch.A to OUTPUT, I/O ch.B to INPUT; set noise to OFF; set audio to OFF
  47+ 0CBF
  48+ 0CBF
  49+ 0CBF              ; routine to play a welcome beep on channel C (tone 4010) and to shut it off
  50+ 0CBF 21 D9 0C     WLCMBEEP:       ld      HL,WLCBPDAT     ; data address
  51+ 0CC2 C3 C8 0C                     jp      SENDSND
  52+ 0CC5 21 E1 0C     NOBEEP:         ld      HL,NOBPDAT      ; data address
  53+ 0CC8 C5           SENDSND:        push    BC
  54+ 0CC9 06 04                        ld      B,$04           ; 4 pairs
  55+ 0CCB 7E           RPTWLCMBP:      ld      A,(HL)          ; read register #
  56+ 0CCC CD E9 0C                     call    SETSNDREG
  57+ 0CCF 23                           inc     HL              ; next cell
  58+ 0CD0 7E                           ld      A,(HL)          ; read value
  59+ 0CD1 CD EE 0C                     call    WRTSNDREG
  60+ 0CD4 23                           inc     HL
  61+ 0CD5 10 F4                        djnz    RPTWLCMBP       ; repeat
  62+ 0CD7 C1                           pop     BC
  63+ 0CD8 C9                           ret                     ; return to caller
  64+ 0CD9
  65+ 0CD9 07 BB 04 56  WLCBPDAT:       defb    $07,%10111011,$04,$56,$05,$00,$0A,$0F
  65+ 0CDD 05 00 0A 0F
  66+ 0CE1 04 00 05 00  NOBPDAT:        defb    $04,$00,$05,$00,$0A,$00,$07,%10111111
  66+ 0CE5 0A 00 07 BF
  67+ 0CE9
  68+ 0CE9
  69+ 0CE9              ; select register on PSG
  70+ 0CE9 0E 40        SETSNDREG:      ld      C,PSG_REG       ; PSG register port
  71+ 0CEB ED 79                        out     (C),A           ; set register
  72+ 0CED C9                           ret                     ; return to caller
  73+ 0CEE
  74+ 0CEE              ; send data to PSG
  75+ 0CEE 0E 41        WRTSNDREG:      ld      C,PSG_DAT       ; PSG data port
  76+ 0CF0 ED 79                        out     (C),A           ; send data
  77+ 0CF2 C9                           ret                     ; return to caller
  78+ 0CF3
  79+ 0CF3              ; manage the sounds' duration: each time this subroutine is called, it
  80+ 0CF3              ; decrements the single sound durations (measured in ms) and eventually
  81+ 0CF3              ; shut off the audio channel whose counter has reached 0.
  82+ 0CF3              ; (this sub-routine is called by CH3 timer ISR)
  83+ 0CF3 DD E5        MNGSNDS:        push    IX              ; store IX
  84+ 0CF5 DD 21 B0 55                  ld      IX,CHASNDDTN    ; starting address of tones duration
  85+ 0CF9 06 03                        ld      B,$03           ; 3 channels to check
  86+ 0CFB 26 01                        ld      H,$01           ; mixer channels: A=>bit 1, B=>bit 2, C=>bit 3
  87+ 0CFD DD 5E 00     CHKSNDCH:       ld      E,(IX+0)        ; load LSB into E
  88+ 0D00 DD 56 01                     ld      D,(IX+1)        ; load MSB into D
  89+ 0D03 7B                           ld      A,E             ; load E into A
  90+ 0D04 B2                           or      D               ; check that DE=0
  91+ 0D05 28 31                        jr      Z,CNTCHKSND     ; yes, jump over
  92+ 0D07 1B                           dec     DE              ; no, so decrement DE
  93+ 0D08 7B                           ld      A,E             ; reload E into A...
  94+ 0D09 DD 73 00                     ld      (IX+0),E        ; store new...
  95+ 0D0C DD 72 01                     ld      (IX+1),D        ; ...duration and...
  96+ 0D0F B2                           or      D               ; ...do another check to see if DE=0
  97+ 0D10 20 26                        jr      NZ,CNTCHKSND    ; no, so jump over
  98+ 0D12                                                      ; if yes, let's shut down the corresponding channel
  99+ 0D12                                                      ; to shut down a tone we disable it into the mixer
 100+ 0D12                                                      ; then set 0 into its tone registers
 101+ 0D12 16 07                        ld      D,$07           ; mixer register
 102+ 0D14 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 103+ 0D16 ED 51                        out     (C),D           ; set mixer register
 104+ 0D18 ED 78                        in      A,(C)           ; load current value
 105+ 0D1A B4                           or      H               ; set off the channel into the mixer (remember that 1=OFF)
 106+ 0D1B ED 51                        out     (C),D           ; select mixer register
 107+ 0D1D 0E 41                        ld      C,PSG_DAT       ; PSG data port
 108+ 0D1F ED 79                        out     (C),A           ; send new value for the mixer
 109+ 0D21 3E 03                        ld      A,$03           ; three channels
 110+ 0D23 90                           sub     B               ; find current channel (0->A, 1->B, 2->C)
 111+ 0D24 87                           add     A,A             ; and find first register (A=>0, B=>2, C=>4)
 112+ 0D25 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 113+ 0D27 ED 79                        out     (C),A           ; select first tone register of channel
 114+ 0D29 2E 00                        ld      L,$00           ; value 0 into L
 115+ 0D2B 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 116+ 0D2D ED 69                        out     (C),L           ; write 0 into register
 117+ 0D2F 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 118+ 0D31 3C                           inc     A               ; next tone register
 119+ 0D32 ED 79                        out     (C),A           ; select second tone register of channel
 120+ 0D34 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 121+ 0D36 ED 69                        out     (C),L           ; write 0 into register
 122+ 0D38 DD 23        CNTCHKSND:      inc     IX              ; set for...
 123+ 0D3A DD 23                        inc     IX              ; ...next channel...
 124+ 0D3C CB 24                        sla     H               ; shift left H 1 bit
 125+ 0D3E 10 BD                        djnz    CHKSNDCH        ; repeat for 3 channels
 126+ 0D40 DD E1                        pop     IX              ; restore IX
 127+ 0D42 C9                           ret                     ; return to caller
 128+ 0D43
 129+ 0D43              ; read a specific row of the keyboard matrix, set by A
 130+ 0D43              ; return read into A
 131+ 0D43 C5           READKBLN:       push    BC              ; store BC
 132+ 0D44 06 0F                        ld      B,$0F           ; reg #15
 133+ 0D46 0E 40                        ld      C,PSG_REG       ; PSG register port
 134+ 0D48 ED 41                        out     (C),B           ; select reg #15
 135+ 0D4A 0E 41                        ld      C,PSG_DAT       ; PSG data port
 136+ 0D4C ED 79                        out     (C),A           ; activate the row
 137+ 0D4E 06 0E                        ld      B,$0E           ; register #14 (port B)
 138+ 0D50 0E 40                        ld      C,PSG_REG       ; PSG register port
 139+ 0D52 ED 41                        out     (C),B           ; select reg. 14 (port B)
 140+ 0D54 ED 78                        in      A,(C)           ; read register #14
 141+ 0D56 C1                           pop     BC              ; retrieve BC
 142+ 0D57 C9                           ret
 143+ 0D58
 144+ 0D58              ; read the keyboard matrix to look for a key pressure
 145+ 0D58 0E 40        KEYBOARD:       ld      C,PSG_REG       ; PSG register port
 146+ 0D5A 06 07                        ld      B,$07           ; set register #7...
 147+ 0D5C ED 41                        out     (C),B           ; ...to work with
 148+ 0D5E ED 78                        in      A,(C)           ; read register #7
 149+ 0D60 CB FF                        set     7,A             ; port A set to output
 150+ 0D62 CB B7                        res     6,A             ; port B set to input
 151+ 0D64 ED 41                        out     (C),B           ; set register #7
 152+ 0D66 0E 41                        ld      C,PSG_DAT       ; PSG data port
 153+ 0D68 ED 79                        out     (C),A           ; set I/O ports w/o altering the rest of the mixer
 154+ 0D6A                              ; check special keys (SHIFT/ALT/CTRL)
 155+ 0D6A 3E FD                        ld      A,%11111101     ; select SHIFT row
 156+ 0D6C CD 43 0D                     call    READKBLN        ; read row
 157+ 0D6F CB 5F                        bit     3,A             ; test if SHIFT key is pressed (4th bit is reset)
 158+ 0D71 20 05                        jr      NZ,CHECKALT     ; no, so go on
 159+ 0D73 21 BD 55                     ld      HL,CONTROLKEYS  ; control key flags
 160+ 0D76 36 01                        ld      (HL),%00000001  ; set SHIFT flag, reset CTRL & ALT flags (currently multiply control keys are NOT supported)
 161+ 0D78 3E FE        CHECKALT:       ld      A,%11111110     ; select ALT row
 162+ 0D7A CD 43 0D                     call    READKBLN        ; read ALT row
 163+ 0D7D CB 6F                        bit     5,A             ; test if ALT key is pressed (5th bit is reset)
 164+ 0D7F 20 05                        jr      NZ,CHECKCTRL    ; no, so go on
 165+ 0D81 21 BD 55                     ld      HL,CONTROLKEYS  ; control key flags
 166+ 0D84 36 04                        ld      (HL),%00000100  ; set ALT flag, reset SHIFT & CTRL flag (currently multiply control keys are NOT supported)
 167+ 0D86 3E FE        CHECKCTRL:      ld      A,%11111110     ; select CTRL row
 168+ 0D88 CD 43 0D                     call    READKBLN        ; read CTRL row
 169+ 0D8B CB 57                        bit     2,A             ; test if CTRL key is pressed (3rd bit is reset)
 170+ 0D8D 20 05                        jr      NZ,CHECKKBD     ; no, so make a normal reading
 171+ 0D8F 21 BD 55                     ld      HL,CONTROLKEYS  ; control key flags
 172+ 0D92 36 02                        ld      (HL),%00000010  ; set CTRL flag, reset SHIFT & ALT flags (currently multiply control keys are NOT supported)
 173+ 0D94 06 08        CHECKKBD:       ld      B,$08           ; 8 lines
 174+ 0D96 3E 7F                        ld      A,%01111111     ; start from the last line of the matrix
 175+ 0D98 16 0F        RPTKBDRD:       ld      D,$0F           ; register #15 (port B)
 176+ 0D9A 0E 40                        ld      C,PSG_REG       ; PSG register port
 177+ 0D9C ED 51                        out     (C),D           ; select reg. #15
 178+ 0D9E 0E 41                        ld      C,PSG_DAT       ; PSG data port
 179+ 0DA0 ED 79                        out     (C),A           ; activate 1 line (active line is grounded, i.e. with a LOW signal)
 180+ 0DA2 5F                           ld      E,A             ; save current line into E
 181+ 0DA3 16 0E                        ld      D,$0E           ; register #14 (port A)
 182+ 0DA5 0E 40                        ld      C,PSG_REG       ; PSG register port
 183+ 0DA7 ED 51                        out     (C),D           ; select reg. 14 (port A)
 184+ 0DA9 00                           nop
 185+ 0DAA ED 78                        in      A,(C)           ; read register #14
 186+ 0DAC FE FF                        cp      $FF             ; is there any line set to 0?
 187+ 0DAE 28 2E                        jr      Z,NOKEYPRSD     ; no, go to the next row
 188+ 0DB0                              ; check control keys
 189+ 0DB0 32 B7 55                     ld      (KBTMP),A       ; yes, check if a control key was pressed. First, store current row
 190+ 0DB3 78                           ld      A,B             ; copy current row (B) into A
 191+ 0DB4 FE 02                        cp      $02             ; is it the row of the SHIFT?
 192+ 0DB6 20 0F                        jr      NZ,TESTALT      ; no, continue checking the other control keys
 193+ 0DB8 3A B7 55                     ld      A,(KBTMP)       ; yes, retrieve current row data
 194+ 0DBB CB 5F                        bit     3,A             ; check SHIFT bit line
 195+ 0DBD 20 31                        jr      NZ,FINDKEY      ; no SHIFT, continue checking
 196+ 0DBF CB DF                        set     3,A             ; yes, it's the SHIFT. So remove SHIFT bit
 197+ 0DC1 FE FF                        cp      $FF             ; after deleting the SHIFT bit, is there any other bit selected?
 198+ 0DC3 20 2B                        jr      NZ,FINDKEY      ; yes, go to check which one
 199+ 0DC5 18 17                        jr      NOKEYPRSD       ; no, go to next row
 200+ 0DC7 FE 01        TESTALT:        cp      $01             ; is it the line of ALT & CTRL?
 201+ 0DC9 3A B7 55                     ld      A,(KBTMP)       ; retrieve current row data
 202+ 0DCC 20 22                        jr      NZ,FINDKEY      ; no, continue
 203+ 0DCE CB 6F                        bit     5,A             ; yes, check ALT bit line
 204+ 0DD0 20 02                        jr      NZ,TESTCTRL     ; no ALT, continue checking
 205+ 0DD2 CB EF                        set     5,A             ; yes, it's the ALT. So remove ALT bit
 206+ 0DD4 CB 57        TESTCTRL:       bit     2,A             ; check CTRL bit line
 207+ 0DD6 20 02                        jr      NZ,ENDCTRLCK    ; no CTRL, continue checking
 208+ 0DD8 CB D7                        set     2,A             ; delete CTRL bit flag
 209+ 0DDA FE FF        ENDCTRLCK:      cp      $FF             ; after deleting the ALT & CTRL bits, is there any other bit selected?
 210+ 0DDC 20 12                        jr      NZ,FINDKEY      ; yes, go to check which one
 211+ 0DDE 7B           NOKEYPRSD:      ld      A,E             ; no key pressed, load current output port
 212+ 0DDF 0F                           rrca                    ; rotate right by 1
 213+ 0DE0 10 B6                        djnz    RPTKBDRD        ; repeat for 8 lines
 214+ 0DE2 AF                           xor     A               ; if exit from here, no key has been pressed...
 215+ 0DE3 32 B9 55                     ld      (LASTKEYPRSD),A ; ...so reset the last key cell...
 216+ 0DE6 32 BD 55                     ld      (CONTROLKEYS),A ; ...reset contro key flags...
 217+ 0DE9 32 B6 55                     ld      (KBDNPT),A      ; ...no input from keyboard...
 218+ 0DEC 32 BA 55                     ld      (STATUSKEY),A   ; ...no auto-repeat...
 219+ 0DEF C9                           ret                     ; ...and leave
 220+ 0DF0 1E FF        FINDKEY:        ld      E,$FF           ; counter
 221+ 0DF2 1C           CHKLN:          inc     E               ; E goes from 0 to 7
 222+ 0DF3 CB 3F                        srl     A               ; is the first bit reset? (we're looking for a "0", meaning grounded line)
 223+ 0DF5 38 FB                        jr      C,CHKLN         ; no, check next bit
 224+ 0DF7 3A BD 55                     ld      A,(CONTROLKEYS) ; load control key flags
 225+ 0DFA 21 13 0F                     ld      HL,KBMAP        ; normal keymap
 226+ 0DFD FE 01                        cp      $01             ; SHIFT flag?
 227+ 0DFF 20 05                        jr      NZ,CHKCTRL      ; no, jump over
 228+ 0E01 21 53 0F                     ld      HL,KBMAP_SFT    ; SHIFT keymap
 229+ 0E04 18 10                        jr      LOADMAP         ; and load it
 230+ 0E06 FE 02        CHKCTRL:        cp      $02             ; CTRL flag?
 231+ 0E08 20 05                        jr      NZ,CHKALT       ; no, jump over
 232+ 0E0A 21 D3 0F                     ld      HL,KBMAP_CTRL   ; CTRL map
 233+ 0E0D 18 07                        jr      LOADMAP         ; and load it
 234+ 0E0F FE 04        CHKALT:         cp      $04             ; ALT flag?
 235+ 0E11 20 03                        jr      NZ,LOADMAP      ; no, check over
 236+ 0E13 21 93 0F                     ld      HL,KBMAP_ALT    ; ALT map
 237+ 0E16 05           LOADMAP:        dec     B               ; decrement row # (rows go from 0 to 7)
 238+ 0E17 48                           ld      C,B             ; move B into C and...
 239+ 0E18 CB 21                        sla     C               ; ...multiply it...
 240+ 0E1A CB 21                        sla     C               ; ...by 8 to find...
 241+ 0E1C CB 21                        sla     C               ; ...the current row into the matrix
 242+ 0E1E 06 00                        ld      B,$00           ; reset B
 243+ 0E20 09                           add     HL,BC           ; find the address of the current row
 244+ 0E21 50                           ld      D,B             ; reset D
 245+ 0E22 19                           add     HL,DE           ; find the current column - now (HL) stores the pressed key
 246+ 0E23 3A B9 55                     ld      A,(LASTKEYPRSD) ; load the last key pressed
 247+ 0E26 BE                           cp      (HL)            ; is it the same key?
 248+ 0E27 20 41                        jr      NZ,NEWKEY       ; no, it's a new key
 249+ 0E29 44 4D                        ld      BC,HL           ; store address of current keycode
 250+ 0E2B 2A 5C 55                     ld      HL,(TMRCNT)     ; load current system timer
 251+ 0E2E ED 5B BB 55                  ld      DE,(KEYTMR)     ; load auto-repeat timer
 252+ 0E32 3A BA 55                     ld      A,(STATUSKEY)   ; yes, load current status of auto-repeat
 253+ 0E35 FE 01                        cp      $01             ; is it initial pressure?
 254+ 0E37 20 1F                        jr      NZ,CHKAUTO      ; no, jump over
 255+ 0E39 AF                           xor     A               ; clear Carry
 256+ 0E3A ED 52                        sbc     HL,DE           ; startint time - actual time
 257+ 0E3C 16 00                        ld      D,$00           ; 64 ths/s > 640 ms
 258+ 0E3E 3A 2D 54                     ld      A,(KEYDEL)
 259+ 0E41 5F                           ld      E,A
 260+ 0E42 CD 38 41                     call    CMP16           ; time elapsed is >= $40?
 261+ 0E45 DA BA 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 262+ 0E48 3E 02        SETNEWAUTO:     ld      A,$02           ; yes set status to...
 263+ 0E4A 32 BA 55                     ld      (STATUSKEY),A   ; ...auto-repeat
 264+ 0E4D 2A 5C 55                     ld      HL,(TMRCNT)     ; load system timer
 265+ 0E50 22 BB 55                     ld      (KEYTMR),HL     ; store starting time
 266+ 0E53 60 69                        ld      HL,BC           ; retrieve address of current keycode
 267+ 0E55 C3 77 0E                     jp      SENDKEY         ; send key
 268+ 0E58 AF           CHKAUTO:        xor     A               ; clear Carry
 269+ 0E59 ED 52                        sbc     HL,DE           ; computer interval between initial pressure of key and current time
 270+ 0E5B 16 00                        ld      D,$00
 271+ 0E5D 3A 2E 54                     ld      A,(AUTOKE)
 272+ 0E60 5F                           ld      E,A             ; auto-repeat delay into DE
 273+ 0E61 CD 38 41                     call    CMP16           ; check if interval is greater than delay
 274+ 0E64 DA BA 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 275+ 0E67 C3 48 0E                     jp      SETNEWAUTO      ; set new loop and send key
 276+ 0E6A AF           NEWKEY:         xor     A               ; set initial state...
 277+ 0E6B 3C                           inc     A               ; ...for auto-repeat...
 278+ 0E6C 32 BA 55                     ld      (STATUSKEY),A   ; ...1=pressure init
 279+ 0E6F ED 4B 5C 55                  ld      BC,(TMRCNT)     ; load current system timer
 280+ 0E73 ED 43 BB 55                  ld      (KEYTMR),BC     ; set starting time
 281+ 0E77 7E           SENDKEY:        ld      A,(HL)          ; then, load key...
 282+ 0E78 32 B9 55                     ld      (LASTKEYPRSD),A ; ...store it...
 283+ 0E7B 32 B8 55                     ld      (TMPKEYBFR),A   ; ...insert it into the INKEY buffer...
 284+ 0E7E 32 79 55                     ld      (CHR4VID),A     ; ...and store char for video
 285+ 0E81 FE 03                        cp      CTRLC           ; is it RUN/STOP?
 286+ 0E83 20 05                        jr      NZ,CNTKBCK      ; no, jump over
 287+ 0E85 CD FD 01                     call    CHARINTOBFR     ; yes, send directly to buffer and...
 288+ 0E88 18 30                        jr      LVKBRDCHK2      ; ...leave
 289+ 0E8A 01 00 08     CNTKBCK:        ld      BC,$0800        ; 8 FN keys (B), FN key number (C)
 290+ 0E8D 21 0B 0F                     ld      HL,FNKEYSORD    ; FN keys codes
 291+ 0E90 BE           CHKFNK:         cp      (HL)            ; is it an FN key?
 292+ 0E91 CA BF 0E                     jp      Z,PRNTFNKEY     ; yes, jump over
 293+ 0E94 0C                           inc     C               ; next FN key
 294+ 0E95 23                           inc     HL              ; next FN key code
 295+ 0E96 10 F8                        djnz    CHKFNK          ; continue for 8 FN keys
 296+ 0E98 3E 01        SNDKEYTOBFR:    ld      A,$01           ; normal key - set input flag
 297+ 0E9A 32 B6 55                     ld      (KBDNPT),A      ; to keyboard
 298+ 0E9D 3A 78 55                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 299+ 0EA0 B7                           or      A               ; is the print-on-video disabled?
 300+ 0EA1 CA AA 0E                     jp      Z,PUTCHRBUF     ; yes, so send char to input buffer
 301+ 0EA4 3A 76 55                     ld      A,(CRSR_STATE)  ; check cursor state
 302+ 0EA7 B7                           or      A               ; is it 0 (cursor OFF)?
 303+ 0EA8 20 0D                        jr      NZ,PNT2VD       ; no, print on screen
 304+ 0EAA AF           PUTCHRBUF:      xor     A
 305+ 0EAB 32 B6 55                     ld      (KBDNPT),A      ; if send to input buffer, set RETURN as from BASIC
 306+ 0EAE 3A B8 55                     ld      A,(TMPKEYBFR)   ; retrieve char
 307+ 0EB1 CD FD 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 308+ 0EB4 C3 BA 0E                     jp      LVKBRDCHK2      ; ...and leave
 309+ 0EB7 CD 61 07     PNT2VD:         call    CHAR2VID        ; send char to video
 310+ 0EBA AF           LVKBRDCHK2:     xor     A
 311+ 0EBB 32 BD 55                     ld      (CONTROLKEYS),A ; reset control key flags
 312+ 0EBE C9                           ret                     ; return to caller: the current key code is into TMPKEYBFR
 313+ 0EBF                              ; manage FN keys
 314+ 0EBF 57           PRNTFNKEY:      ld      D,A             ; copy A into D
 315+ 0EC0 2A 29 54                     ld      HL,(LINEAT)     ; Get current line number
 316+ 0EC3 23                           inc     HL              ; -1 means direct statement
 317+ 0EC4 7C                           ld      A,H
 318+ 0EC5 B5                           or      L
 319+ 0EC6 7A                           ld      A,D             ; retrieve char
 320+ 0EC7 20 CF                        jr      NZ,SNDKEYTOBFR  ; indirect mode - just send FN key code to buffer
 321+ 0EC9 79                           ld      A,C             ; direct mode, so print text - first, get FN key number
 322+ 0ECA 87                           add     A,A
 323+ 0ECB 87                           add     A,A
 324+ 0ECC 87                           add     A,A
 325+ 0ECD 87                           add     A,A             ; FN key number * 16
 326+ 0ECE 4F                           ld      C,A             ; move it into C
 327+ 0ECF 06 00                        ld      B,$00           ; reset B, to get offset
 328+ 0ED1 21 2F 54                     ld      HL,FNKEYS       ; load address of FN keys texts
 329+ 0ED4 09                           add     HL,BC           ; get correct text address
 330+ 0ED5 06 10                        ld      B,$10           ; 16 chars
 331+ 0ED7 7E           LDFNKEYCHR:     ld      A,(HL)          ; load char
 332+ 0ED8 A7                           and     A               ; null char?
 333+ 0ED9 CA BA 0E                     jp      Z,LVKBRDCHK2    ; yes, so leave
 334+ 0EDC 57                           ld      D,A             ; pass char into D
 335+ 0EDD 3A 78 55                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 336+ 0EE0 B7                           or      A               ; is the print-on-video disabled?
 337+ 0EE1 CA F1 0E                     jp      Z,PUTCHRBUF1    ; yes, so send char to input buffer
 338+ 0EE4 3A 76 55                     ld      A,(CRSR_STATE)  ; check cursor state
 339+ 0EE7 B7                           or      A               ; is it 0 (cursor OFF)?
 340+ 0EE8 C4 FE 0E                     call    NZ,PRNTFNK      ; no, print on screen
 341+ 0EEB 23           CNTFNK:         inc     HL              ; next char
 342+ 0EEC 10 E9                        djnz    LDFNKEYCHR      ; repeat for max. 16 chars
 343+ 0EEE C3 BA 0E                     jp      LVKBRDCHK2      ; leave
 344+ 0EF1 AF           PUTCHRBUF1:     xor     A               ; if send to input buffer,...
 345+ 0EF2 32 B6 55                     ld      (KBDNPT),A      ; ...set input as from BASIC
 346+ 0EF5 7A                           ld      A,D             ; retrieve char
 347+ 0EF6 E5                           push    HL              ; store HL
 348+ 0EF7 CD FD 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 349+ 0EFA E1                           pop     HL              ; retrieve HL
 350+ 0EFB C3 EB 0E                     jp      CNTFNK          ; repeat
 351+ 0EFE 7A           PRNTFNK:        ld      A,D             ; recover char
 352+ 0EFF 32 79 55                     ld      (CHR4VID),A     ; store char for printing
 353+ 0F02 3E 01                        ld      A,$01           ; normal key - set input flag
 354+ 0F04 32 B6 55                     ld      (KBDNPT),A      ; to keyboard
 355+ 0F07 CD 61 07                     call    CHAR2VID        ; print on screen
 356+ 0F0A C9                           ret                     ; return to caller
 357+ 0F0B
 358+ 0F0B
 359+ 0F0B              ;-----------------------------------------------------------------------
 360+ 0F0B 01 02 04 05  FNKEYSORD:      defb 1,2,4,5,6,22,23,24                 ; order of FN Keys
 360+ 0F0F 06 16 17 18
 361+ 0F13              ;-----------------------------------------------------------------------
 362+ 0F13              ; key codes
 363+ 0F13 31 19 0E 03  KBMAP:          defb '1',25,14,3,' ',16,'q','2'         ; 25=HOME  14=CTRL  3=RUN/STOP 16=C=
 363+ 0F17 20 10 71 32
 364+ 0F1B 33 77 61 14                  defb '3','w','a',20,'z','s','e','4'     ; 20=SHIFT
 364+ 0F1F 7A 73 65 34
 365+ 0F23 35 72 64 78                  defb '5','r','d','x','c','f','t','6'
 365+ 0F27 63 66 74 36
 366+ 0F2B 37 79 67 76                  defb '7','y','g','v','b','h','u','8'
 366+ 0F2F 62 68 75 38
 367+ 0F33 39 69 6A 6E                  defb '9','i','j','n','m','k','o','0'
 367+ 0F37 6D 6B 6F 30
 368+ 0F3B 1F 70 6C 2C                  defb 31,'p','l',',','.',':','-',30      ; 31=CURSOR DOWN  30=CURSOR UP
 368+ 0F3F 2E 3A 2D 1E
 369+ 0F43 1C 2A 3B 2F                  defb 28,'*',';','/',27,'=','+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 369+ 0F47 1B 3D 2B 1D
 370+ 0F4B 08 0D FC 40                  defb 8,13,252,'@',1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 370+ 0F4F 01 02 04 18
 371+ 0F53
 372+ 0F53              ; shifted codes - not all the keys have the shifted version
 373+ 0F53 21 0C 0E 03  KBMAP_SFT:      defb '!',12,14,3,' ',16,'Q',34          ; 12=CLEAR  14=CTRL  3=RUN/STOP 16=C=   34="
 373+ 0F57 20 10 51 22
 374+ 0F5B 23 57 41 14                  defb '#','W','A',20,'Z','S','E','$'     ; 20=SHIFT
 374+ 0F5F 5A 53 45 24
 375+ 0F63 25 52 44 58                  defb '%','R','D','X','C','F','T','&'
 375+ 0F67 43 46 54 26
 376+ 0F6B 27 59 47 56                  defb 39,'Y','G','V','B','H','U','('     ; 39='
 376+ 0F6F 42 48 55 28
 377+ 0F73 29 49 4A 4E                  defb ')','I','J','N','M','K','O',94     ; 94=^
 377+ 0F77 4D 4B 4F 5E
 378+ 0F7B 1F 50 4C 3C                  defb 31,'P','L','<','>','[','_',30      ; 31=CURSOR DOWN  30=CURSOR UP
 378+ 0F7F 3E 5B 5F 1E
 379+ 0F83 1C 2A 5D 3F                  defb 28,'*',']','?',27,198,'+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 379+ 0F87 1B C6 2B 1D
 380+ 0F8B 1A 0D D3 40                  defb 26,13,211,'@',5,6,22,23            ; 26=INSERT, 211=â¬  5=F4  6=F5  22=F6  23=F7
 380+ 0F8F 05 06 16 17
 381+ 0F93
 382+ 0F93              ; ALT (C=) codes - not all the keys have the alt-ed version
 383+ 0F93 31 0C 0E 03  KBMAP_ALT:      defb '1',12,14,3,' ',16,222,196         ; 12=CLEAR  14=CTRL  3=RUN/STOP  16=C=  34="
 383+ 0F97 20 10 DE C4
 384+ 0F9B 33 DD 85 14                  defb '3',221,133,20,131,130,165,'4'     ; 20=SHIFT
 384+ 0F9F 83 82 A5 34
 385+ 0FA3 35 A2 A6 84                  defb '5',162,166,132,157,163,168,'6'
 385+ 0FA7 9D A3 A8 36
 386+ 0FAB 37 AB A9 A1                  defb '7',171,169,161,158,172,213,'8'    ;
 386+ 0FAF 9E AC D5 38
 387+ 0FB3 39 D6 D8 9F                  defb '9',214,216,159,160,215,135,195    ;
 387+ 0FB7 A0 D7 87 C3
 388+ 0FBB 1F 88 8A C1                  defb 31,136,138,193,192,123,144,30      ; 31=CURSOR DOWN  123={  30=CURSOR UP
 388+ 0FBF C0 7B 90 1E
 389+ 0FC3 1C 8F 7D FE                  defb 28,143,125,254,27,209,148,29       ; 28=CURSOR LEFT  125=}  27=ESCAPE  29=CURSOR RIGHT
 389+ 0FC7 1B D1 94 1D
 390+ 0FCB 08 0D E0 89                  defb 8,13,224,137,5,6,22,23             ; 8=DEL(backspace)  13=RETURN  252=Â£  5=F4  6=F5  22=F6  23=F7
 390+ 0FCF 05 06 16 17
 391+ 0FD3
 392+ 0FD3              ; CTRL codes - not all the keys have the control-ed version
 393+ 0FD3 31 19 0E 03  KBMAP_CTRL:     defb '1',25,14,3,' ',16,154,'2'         ; 25=HOME  14=CTRL  3=RUN/STOP  16=C=
 393+ 0FD7 20 10 9A 32
 394+ 0FDB 33 9C 95 14                  defb '3',156,149,20,152,150,153,'4'     ; 20=SHIFT
 394+ 0FDF 98 96 99 34
 395+ 0FE3 35 9B B0 97                  defb '5',155,176,151,177,175,165,'6'
 395+ 0FE7 B1 AF A5 36
 396+ 0FEB 37 A6 A8 B2                  defb '7',166,168,178,179,169,167,'8'
 396+ 0FEF B3 A9 A7 38
 397+ 0FF3 39 B8 AA AC                  defb '9',184,170,172,171,181,164,'0'
 397+ 0FF7 AB B5 A4 30
 398+ 0FFB 1F A3 AD 2C                  defb 31,163,173,',','.',':',186,30      ; 31=CURSOR DOWN  30=CURSOR UP
 398+ 0FFF 2E 3A BA 1E
 399+ 1003 1C E1 3B 2F                  defb 28,225,';','/',27,212,185,29       ; 28=CURSOR LEFT  27=ESCAPE  212=Ï  29=CURSOR RIGHT
 399+ 1007 1B D4 B9 1D
 400+ 100B 08 0D BD A2                  defb 8,13,189,162,1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 400+ 100F 01 02 04 18
# file closed: ../include/psg/psg-1.1.asm
  73  1013
  74  1013              ; include the latest version of the LM80C 64K BASIC interpreter
  75  1013                  INCLUDE "../include/basic/basic-1.12.asm"
# file opened: ../include/basic/basic-1.12.asm
   1+ 1013              ; ------------------------------------------------------------------------------
   2+ 1013              ; LM80C BASIC (32K/64K) - R3.25
   3+ 1013              ; ------------------------------------------------------------------------------
   4+ 1013              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 1013              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 1013              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 1013              ; kind of warranty: you can use them at your own risk.
   8+ 1013              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 1013              ; maintain the copyright notices, include this advice and the note to the
  10+ 1013              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 1013              ; redistribuite them.
  12+ 1013              ; https://www.leonardomiliani.com
  13+ 1013              ;
  14+ 1013              ; Please support me by visiting the following links:
  15+ 1013              ; Main project page: https://www.leonardomiliani.com
  16+ 1013              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 1013              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 1013              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 1013              ; ------------------------------------------------------------------------------
  20+ 1013              ; LM80C BASIC 64K - originally based on the following NASCOM BASIC versions:
  21+ 1013              ; 4.7  - original version by NASCOM/MICROSOFT
  22+ 1013              ; 4.7b - modified version by Grant Searle (additional commands & functions)
  23+ 1013
  24+ 1013
  25+ 1013              ;------------------------------------------------------------------------------
  26+ 1013              ;  L M 8 0 C   B A S I C
  27+ 1013              ;------------------------------------------------------------------------------
  28+ 1013
  29+ 1013              ; GENERAL EQUATES
  30+ 1013
  31+ 1013              NLLCR           equ     $00             ; null char (used as space/empty char in video prints)
  32+ 1013              CTRLC           equ     $03             ; Control "C"
  33+ 1013              CTRLG           equ     $07             ; Control "G"
  34+ 1013              BKSP            equ     $08             ; Back space
  35+ 1013              LF              equ     $0A             ; Line feed
  36+ 1013              CS              equ     $0C             ; Clear screen
  37+ 1013              CR              equ     $0D             ; Carriage return
  38+ 1013              CTRLO           equ     $0F             ; Control "O"
  39+ 1013              CTRLQ           equ     $11             ; Control "Q"
  40+ 1013              CTRLR           equ     $12             ; Control "R"
  41+ 1013              CTRLS           equ     $13             ; Control "S"
  42+ 1013              CTRLU           equ     $15             ; Control "U"
  43+ 1013              HOME            equ     $19             ; Home (cursor at 0,0)
  44+ 1013              ESC             equ     $1B             ; Escape
  45+ 1013              SPC             equ     $20             ; Space
  46+ 1013              DEL             equ     $7F             ; Delete
  47+ 1013              INSRT           equ     $1A             ; Insert Key
  48+ 1013              ; cursor ASCII codes
  49+ 1013              CRSLFT          equ     $1C             ; cursor left
  50+ 1013              CRSRGT          equ     $1D             ; cursor right
  51+ 1013              CRSUP           equ     $1E             ; cursor up
  52+ 1013              CRSDN           equ     $1F             ; cursor down
  53+ 1013
  54+ 1013
  55+ 1013              ;-------------------------------------------------------------------------
  56+ 1013              ; BASIC ERROR MESSAGES
  57+ 1013              ; the interpreter looks for a single-byte code in the following list,
  58+ 1013              ; then loads the corresponding memory pointer in "ERRTBL" table to
  59+ 1013              ; find where to retrieve the message text in "ERRORS"
  60+ 1013
  61+ 1013              ; BASIC ERROR CODE VALUES
  62+ 1013              ; These values act as an offset to point to the error message into the error table
  63+ 1013              ; must be incremented by 2 because they point to a word address jump
  64+ 1013              NF      equ     $00     ; NEXT without FOR
  65+ 1013              SN      equ     $02     ; Syntax error
  66+ 1013              RG      equ     $04     ; RETURN without GOSUB
  67+ 1013              OD      equ     $06     ; Out of DATA
  68+ 1013              FC      equ     $08     ; Function call error
  69+ 1013              OV      equ     $0A     ; Overflow
  70+ 1013              OM      equ     $0C     ; Out of memory
  71+ 1013              UL      equ     $0E     ; Undefined line number
  72+ 1013              BS      equ     $10     ; Bad subscript
  73+ 1013              DD      equ     $12     ; Re-Dimensioned array
  74+ 1013              DZ      equ     $14     ; Division by zero (/0)
  75+ 1013              ID      equ     $16     ; Illegal direct
  76+ 1013              TM      equ     $18     ; Type mis-match
  77+ 1013              OS      equ     $1A     ; Out of string space
  78+ 1013              LS      equ     $1C     ; String too long
  79+ 1013              ST      equ     $1E     ; String formula too complex
  80+ 1013              CN      equ     $20     ; Can't continue
  81+ 1013              UF      equ     $22     ; Undefined FN function
  82+ 1013              MO      equ     $24     ; Missing operand
  83+ 1013              HE      equ     $26     ; HEX error
  84+ 1013              BN      equ     $28     ; BIN error
  85+ 1013              GM      equ     $2A     ; No Graphics Mode
  86+ 1013              SC      equ     $2C     ; Serial configuration
  87+ 1013              SA      equ     $2E     ; Serial port already open
  88+ 1013              SO      equ     $30     ; Serial buffer overrun
  89+ 1013              HP      equ     $32     ; HELP call
  90+ 1013              IM      equ     $34     ; Illegal indirect
  91+ 1013              NR      equ     $36     ; Device not ready
  92+ 1013              D0      equ     $38     ; File open/close error
  93+ 1013              D1      equ     $3A     ; Disk/File name error
  94+ 1013              D2      equ     $3C     ; Disk geometry error
  95+ 1013              D3      equ     $3E     ; Save error
  96+ 1013              D4      equ     $40     ; Load error
  97+ 1013              D5      equ     $42     ; Disk full error
  98+ 1013              D6      equ     $44     ; Duplicate file name error
  99+ 1013              D7      equ     $46     ; DOS version error
 100+ 1013              D8      equ     $48     ; File not found error
 101+ 1013              D9      equ     $4A     ; File already open
 102+ 1013              DA      equ     $4C     ; End of file
 103+ 1013
 104+ 1013
 105+ 1013              ; BASIC ERROR POINTER TABLE
 106+ 1013              ERRTBL: equ $
 107+ 1013 61 10        NFPTR:  defw    NFMSG
 108+ 1015 72 10        SNPTR:  defw    SNMSG
 109+ 1017 79 10        RGPTR:  defw    RGMSG
 110+ 1019 8E 10        ODPTR:  defw    ODMSG
 111+ 101B 9A 10        FCPTR:  defw    FCMSG
 112+ 101D B0 10        OVPTR:  defw    OVMSG
 113+ 101F B9 10        OMPTR:  defw    OMMSG
 114+ 1021 C7 10        ULPTR:  defw    ULMSG
 115+ 1023 D6 10        BSPTR:  defw    BSMSG
 116+ 1025 E4 10        DDPTR:  defw    DDMSG
 117+ 1027 F9 10        DZPTR:  defw    DZMSG
 118+ 1029 0A 11        IDPTR:  defw    IDMSG
 119+ 102B 1E 11        TMPTR:  defw    TMMSG
 120+ 102D 2D 11        OSPTR:  defw    OSMSG
 121+ 102F 41 11        LSPTR:  defw    LSMSG
 122+ 1031 51 11        STPTR:  defw    STMSG
 123+ 1033 6C 11        CNPTR:  defw    CNMSG
 124+ 1035 7B 11        UFPTR:  defw    UFMSG
 125+ 1037 91 11        MOPTR:  defw    MOMSG
 126+ 1039 A1 11        HEPTR:  defw    HEMSG
 127+ 103B AC 11        BNPTR:  defw    BNMSG
 128+ 103D B7 11        GMPRT:  defw    GMMSG
 129+ 103F C8 11        SCPTR:  defw    SCMSG
 130+ 1041 DD 11        SAPTR:  defw    SAMSG
 131+ 1043 F6 11        SOPTR:  defw    SOMSG
 132+ 1045 0C 12        HPPTR:  defw    HPMSG
 133+ 1047 16 12        IMPRT:  defw    IMMSG
 134+ 1049 2C 12        NRPRT:  defw    NRMSG
 135+ 104B 3D 12        D0PTR:  defw    D0MSG
 136+ 104D 4D 12        D1PRT:  defw    D1MSG
 137+ 104F 59 12        D2PRT:  defw    D2MSG
 138+ 1051 67 12        D3PRT:  defw    D3MSG
 139+ 1053 6C 12        D4PTR:  defw    D4MSG
 140+ 1055 71 12        D5PTR:  defw    D5MSG
 141+ 1057 7B 12        D6PTR:  defw    D6MSG
 142+ 1059 8F 12        D7PRT:  defw    D7MSG
 143+ 105B 9B 12        D8PTR:  defw    D8MSG
 144+ 105D AA 12        D9PTR:  defw    D9MSG
 145+ 105F BC 12        DAPTR:  defw    DAMSG
 146+ 1061
 147+ 1061
 148+ 1061              ; BASIC ERROR MESSAGE LIST
 149+ 1061              ERRORS  equ $
 150+ 1061 4E 45 58 54  NFMSG:  defb    "NEXT Without FOR",0
 150+ 1065 20 57 69 74
 150+ 1069 68 6F 75 74
 150+ 106D 20 46 4F 52
 150+ 1071 00
 151+ 1072 53 79 6E 74  SNMSG:  defb    "Syntax",0
 151+ 1076 61 78 00
 152+ 1079 52 45 54 55  RGMSG:  defb    "RETURN without GOSUB",0
 152+ 107D 52 4E 20 77
 152+ 1081 69 74 68 6F
 152+ 1085 75 74 20 47
 152+ 1089 4F 53 55 42
 152+ 108D 00
 153+ 108E 4F 75 74 20  ODMSG:  defb    "Out of DATA",0
 153+ 1092 6F 66 20 44
 153+ 1096 41 54 41 00
 154+ 109A 49 6C 6C 65  FCMSG:  defb    "Illegal Function Call",0
 154+ 109E 67 61 6C 20
 154+ 10A2 46 75 6E 63
 154+ 10A6 74 69 6F 6E
 154+ 10AA 20 43 61 6C
 154+ 10AE 6C 00
 155+ 10B0 4F 76 65 72  OVMSG:  defb    "Overflow",0
 155+ 10B4 66 6C 6F 77
 155+ 10B8 00
 156+ 10B9 4F 75 74 20  OMMSG:  defb    "Out of Memory",0
 156+ 10BD 6F 66 20 4D
 156+ 10C1 65 6D 6F 72
 156+ 10C5 79 00
 157+ 10C7 55 6E 64 65  ULMSG:  defb    "Undefined Line",0
 157+ 10CB 66 69 6E 65
 157+ 10CF 64 20 4C 69
 157+ 10D3 6E 65 00
 158+ 10D6 42 61 64 20  BSMSG:  defb    "Bad Subscript",0
 158+ 10DA 53 75 62 73
 158+ 10DE 63 72 69 70
 158+ 10E2 74 00
 159+ 10E4 52 65 2D 44  DDMSG:  defb    "Re-Dimensioned Array",0
 159+ 10E8 69 6D 65 6E
 159+ 10EC 73 69 6F 6E
 159+ 10F0 65 64 20 41
 159+ 10F4 72 72 61 79
 159+ 10F8 00
 160+ 10F9 44 69 76 69  DZMSG:  defb    "Division by Zero",0
 160+ 10FD 73 69 6F 6E
 160+ 1101 20 62 79 20
 160+ 1105 5A 65 72 6F
 160+ 1109 00
 161+ 110A 49 6C 6C 65  IDMSG:  defb    "Illegal Direct Mode",0
 161+ 110E 67 61 6C 20
 161+ 1112 44 69 72 65
 161+ 1116 63 74 20 4D
 161+ 111A 6F 64 65 00
 162+ 111E 54 79 70 65  TMMSG:  defb    "Type Mis-match",0
 162+ 1122 20 4D 69 73
 162+ 1126 2D 6D 61 74
 162+ 112A 63 68 00
 163+ 112D 4F 75 74 20  OSMSG:  defb    "Out of String Space",0
 163+ 1131 6F 66 20 53
 163+ 1135 74 72 69 6E
 163+ 1139 67 20 53 70
 163+ 113D 61 63 65 00
 164+ 1141 53 74 72 69  LSMSG:  defb    "String Too Long",0
 164+ 1145 6E 67 20 54
 164+ 1149 6F 6F 20 4C
 164+ 114D 6F 6E 67 00
 165+ 1151 53 74 72 69  STMSG:  defb    "String Formula Too Complex",0
 165+ 1155 6E 67 20 46
 165+ 1159 6F 72 6D 75
 165+ 115D 6C 61 20 54
 165+ 1161 6F 6F 20 43
 165+ 1165 6F 6D 70 6C
 165+ 1169 65 78 00
 166+ 116C 43 61 6E 27  CNMSG:  defb    "Can't Continue",0
 166+ 1170 74 20 43 6F
 166+ 1174 6E 74 69 6E
 166+ 1178 75 65 00
 167+ 117B 55 6E 64 65  UFMSG:  defb    "Undefined FN Function",0
 167+ 117F 66 69 6E 65
 167+ 1183 64 20 46 4E
 167+ 1187 20 46 75 6E
 167+ 118B 63 74 69 6F
 167+ 118F 6E 00
 168+ 1191 4D 69 73 73  MOMSG:  defb    "Missing Operand",0
 168+ 1195 69 6E 67 20
 168+ 1199 4F 70 65 72
 168+ 119D 61 6E 64 00
 169+ 11A1 48 45 58 20  HEMSG:  defb    "HEX Format",0
 169+ 11A5 46 6F 72 6D
 169+ 11A9 61 74 00
 170+ 11AC 42 49 4E 20  BNMSG:  defb    "BIN Format",0
 170+ 11B0 46 6F 72 6D
 170+ 11B4 61 74 00
 171+ 11B7 4E 6F 20 47  GMMSG:  defb    "No Graphics Mode",0
 171+ 11BB 72 61 70 68
 171+ 11BF 69 63 73 20
 171+ 11C3 4D 6F 64 65
 171+ 11C7 00
 172+ 11C8 53 65 72 69  SCMSG:  defb    "Serial Configuration",0
 172+ 11CC 61 6C 20 43
 172+ 11D0 6F 6E 66 69
 172+ 11D4 67 75 72 61
 172+ 11D8 74 69 6F 6E
 172+ 11DC 00
 173+ 11DD 53 65 72 69  SAMSG:  defb    "Serial Port Already Open",0
 173+ 11E1 61 6C 20 50
 173+ 11E5 6F 72 74 20
 173+ 11E9 41 6C 72 65
 173+ 11ED 61 64 79 20
 173+ 11F1 4F 70 65 6E
 173+ 11F5 00
 174+ 11F6 53 65 72 69  SOMSG:  defb    "Serial Buffer Overrun",0
 174+ 11FA 61 6C 20 42
 174+ 11FE 75 66 66 65
 174+ 1202 72 20 4F 76
 174+ 1206 65 72 72 75
 174+ 120A 6E 00
 175+ 120C 48 45 4C 50  HPMSG:  defb    "HELP Call",0
 175+ 1210 20 43 61 6C
 175+ 1214 6C 00
 176+ 1216 49 6C 6C 65  IMMSG:  defb    "Illegal Indirect Mode",0
 176+ 121A 67 61 6C 20
 176+ 121E 49 6E 64 69
 176+ 1222 72 65 63 74
 176+ 1226 20 4D 6F 64
 176+ 122A 65 00
 177+ 122C 44 65 76 69  NRMSG:  defb    "Device Not Ready",0
 177+ 1230 63 65 20 4E
 177+ 1234 6F 74 20 52
 177+ 1238 65 61 64 79
 177+ 123C 00
 178+ 123D 46 69 6C 65  D0MSG:  defb    "File Open/Close",0
 178+ 1241 20 4F 70 65
 178+ 1245 6E 2F 43 6C
 178+ 1249 6F 73 65 00
 179+ 124D 4E 61 6D 65  D1MSG:  defb    "Name String",0
 179+ 1251 20 53 74 72
 179+ 1255 69 6E 67 00
 180+ 1259 44 69 73 6B  D2MSG:  defb    "Disk Geometry",0
 180+ 125D 20 47 65 6F
 180+ 1261 6D 65 74 72
 180+ 1265 79 00
 181+ 1267 53 61 76 65  D3MSG:  defb    "Save",0
 181+ 126B 00
 182+ 126C 4C 6F 61 64  D4MSG:  defb    "Load",0
 182+ 1270 00
 183+ 1271 44 69 73 6B  D5MSG:  defb    "Disk Full",0
 183+ 1275 20 46 75 6C
 183+ 1279 6C 00
 184+ 127B 44 75 70 6C  D6MSG:  defb    "Duplicate File Name",0
 184+ 127F 69 63 61 74
 184+ 1283 65 20 46 69
 184+ 1287 6C 65 20 4E
 184+ 128B 61 6D 65 00
 185+ 128F 44 4F 53 20  D7MSG:  defb    "DOS Version",0
 185+ 1293 56 65 72 73
 185+ 1297 69 6F 6E 00
 186+ 129B 46 69 6C 65  D8MSG:  defb    "File Not Found",0
 186+ 129F 20 4E 6F 74
 186+ 12A3 20 46 6F 75
 186+ 12A7 6E 64 00
 187+ 12AA 46 69 6C 65  D9MSG:  defb    "File Already Open",0
 187+ 12AE 20 41 6C 72
 187+ 12B2 65 61 64 79
 187+ 12B6 20 4F 70 65
 187+ 12BA 6E 00
 188+ 12BC 45 6E 64 20  DAMSG:  defb    "End Of File",0
 188+ 12C0 4F 66 20 46
 188+ 12C4 69 6C 65 00
 189+ 12C8
 190+ 12C8
 191+ 12C8              ;-----------------------------------------------------------------------------
 192+ 12C8              ; STARTING POINTS FOR BASIC BOOT
 193+ 12C8              ; COLD: reset every memory pointer, acting as a power-up boot
 194+ 12C8              ; WARM: preserve program in memory, keeping every current pointer
 195+ 12C8
 196+ 12C8 C3 CE 12     COLD:   jp      STARTB          ; Jump for cold start
 197+ 12CB C3 A4 13     WARM:   jp      WARMST          ; Jump for warm start
 198+ 12CE
 199+ 12CE C3 D5 12     STARTB: jp      CSTART          ; Jump to initialise
 200+ 12D1 14 1E                defw    DEINT           ; Get integer -32768 to 32767
 201+ 12D3 D9 25                defw    ABPASS          ; Return integer in AB
 202+ 12D5 21 D8 53     CSTART: ld      HL,WRKSPC       ; Start of workspace RAM
 203+ 12D8 F9                   ld      SP,HL           ; Set up a temporary stack
 204+ 12D9 C3 2B 41             jp      INITST          ; Go to initialise
 205+ 12DC
 206+ 12DC 21 B0 16     SYSINIT:ld      HL,INITAB       ; Initialise workspace
 207+ 12DF 01 DC 00             ld      BC,INITBE-INITAB+3; Bytes to copy
 208+ 12E2 11 D8 53             ld      DE,WRKSPC       ; Into workspace RAM
 209+ 12E5 ED B0                ldir                    ; Copy data
 210+ 12E7 EB                   ex      DE,HL           ; Copy DE into HL
 211+ 12E8 F9                   ld      SP,HL           ; Temporary stack
 212+ 12E9 CD 79 19             call    CLREG           ; Clear registers and stack
 213+ 12EC CD 2B 20             call    PRNTCRLF        ; Output CRLF
 214+ 12EF 32 0B 55             ld      (BUFFER+88+1),A ; Mark end of buffer
 215+ 12F2 32 E5 55             ld      (PROGST),A      ; Initialise program area
 216+ 12F5 18 13                jr      MNOASK          ; usually, don't ask for memory top (only when there are errors)
 217+ 12F7 21 28 14     MSIZE:  ld      HL,MEMMSG       ; Point to message
 218+ 12FA CD F7 26             call    PRS             ; Output "Memory size"
 219+ 12FD CD 96 19             call    PROMPT          ; Get input with '?'
 220+ 1300 CD 2D 09             call    CURSOR_ON       ; enable cursor
 221+ 1303 CD 5E 1D             call    GETCHR          ; Get next character
 222+ 1306 B7                   or      A               ; Set flags
 223+ 1307 C2 1F 13             jp      NZ,TSTMEM       ; If number - Test if RAM there
 224+ 130A 21 49 56     MNOASK: ld      HL,STLOOK       ; Point to start of RAM
 225+ 130D 23           MLOOP:  inc     HL              ; Next byte
 226+ 130E 7C                   ld      A,H             ; Above address FFFF ?
 227+ 130F B5                   or      L
 228+ 1310 CA 31 13             jp      Z,SETTOP        ; Yes - 64K RAM
 229+ 1313 7E                   ld      A,(HL)          ; Get contents
 230+ 1314 47                   ld      B,A             ; Save it
 231+ 1315 2F                   cpl                     ; Flip all bits
 232+ 1316 77                   ld      (HL),A          ; Put it back
 233+ 1317 BE                   cp      (HL)            ; RAM there if same
 234+ 1318 70                   ld      (HL),B          ; Restore old contents
 235+ 1319 CA 0D 13             jp      Z,MLOOP         ; If RAM - test next byte
 236+ 131C C3 31 13             jp      SETTOP          ; Top of RAM found
 237+ 131F
 238+ 131F CD 2E 1E     TSTMEM: call    ATOH            ; Get high memory into DE
 239+ 1322 B7                   or      A               ; Set flags on last byte
 240+ 1323 C2 17 18             jp      NZ,SNERR        ; ?SN Error if bad character
 241+ 1326 EB                   ex      DE,HL           ; Address into HL
 242+ 1327 2B                   dec     HL              ; Back one byte
 243+ 1328 3E D9                ld      A,%11011001     ; Test byte
 244+ 132A 46                   ld      B,(HL)          ; Get old contents
 245+ 132B 77                   ld      (HL),A          ; Load test byte
 246+ 132C BE                   cp      (HL)            ; RAM there if same
 247+ 132D 70                   ld      (HL),B          ; Restore old contents
 248+ 132E C2 F7 12             jp      NZ,MSIZE        ; Ask again if no RAM
 249+ 1331
 250+ 1331 CD 42 09     SETTOP: call    CURSOR_OFF      ; disable cursor
 251+ 1334 2B                   dec     HL              ; Back one byte
 252+ 1335 11 48 56             ld      DE,STLOOK-1     ; See if enough RAM
 253+ 1338 CD 0F 1B             call    CPDEHL          ; Compare DE with HL
 254+ 133B DA F7 12             jp      C,MSIZE         ; Ask again if not enough RAM
 255+ 133E 3A C1 55             ld      A,(DOS_EN)      ; read if the user enabled/disabled DOS while booting
 256+ 1341 1F                   rra                     ; is DOS enabled?
 257+ 1342 38 1C                jr      C,SETDSR        ; yes, so jump over
 258+ 1344 DD 21 E3 FF          ld      IX,DOSJPTB+1    ; point to 1st address of DOS jump table
 259+ 1348
 260+ 1348                      DEFINE  DOSNTRS 10      ; DOS entries <-- CHANGE THIS VALUE TO ALIGN IT WITH THE NUMBER OF ENTRIES
 261+ 1348
 262+ 1348 06 0A                ld      B,10       ; number of entries
 263+ 134A 11 17 18             ld      DE,SNERR        ; address of REM routine
 264+ 134D DD 73 00     CPDSTB: ld      (IX),E          ; copy REM address...
 265+ 1350 DD 23                inc     IX              ; ...into the...
 266+ 1352 DD 72 00             ld      (IX),D          ; ...jump entry
 267+ 1355 DD 23                inc     IX              ; next jump address
 268+ 1357 DD 23                inc     IX
 269+ 1359 10 F2                djnz    CPDSTB          ; repeat
 270+ 135B 11 E2 FF             ld      DE,0-(10*3); protect jump table (3 byte for each entry)
 271+ 135E 18 03                jr      SETNOD
 272+ 1360 11 68 EE     SETDSR: ld      DE,0-($FFFF-DOSSTART+1) ; no, so reserve RAM occupied by DOS & I/O buffers
 273+ 1363 19           SETNOD: add     HL,DE
 274+ 1364 22 10 55     SETTRAM:ld      (LSTRAM),HL     ; Save last available RAM
 275+ 1367 11 9C FF             ld      DE,0-100        ; now, reserve 100 bytes for string space
 276+ 136A 19                   add     HL,DE           ; Allocate string space
 277+ 136B 22 27 54             ld      (STRSPC),HL     ; Save string space
 278+ 136E CD 54 19             call    CLRPTR          ; Clear program area
 279+ 1371 2A 27 54             ld      HL,(STRSPC)     ; Get end of memory
 280+ 1374 11 EF FF             ld      DE,0-17         ; Offset for free bytes
 281+ 1377 19                   add     HL,DE           ; Adjust HL
 282+ 1378 11 E5 55             ld      DE,PROGST       ; Start of program text
 283+ 137B 7D                   ld      A,L             ; Get LSB
 284+ 137C 93                   sub     E               ; Adjust it
 285+ 137D 6F                   ld      L,A             ; Re-save
 286+ 137E 7C                   ld      A,H             ; Get MSB
 287+ 137F 9A                   sbc     A,D             ; Adjust it
 288+ 1380 67                   ld      H,A             ; Re-save
 289+ 1381 E5                   push    HL              ; Save bytes free
 290+ 1382 21 CA 13             ld      HL,SIGNON       ; Sign-on message
 291+ 1385 CD F7 26             call    PRS             ; Output string
 292+ 1388 3A C1 55             ld      A,(DOS_EN)      ; check if DOS is enabled
 293+ 138B B7                   or      A
 294+ 138C 28 06                jr      Z,SETTP1        ; no DOS, jump over
 295+ 138E 21 0B 14             ld      HL,DOSMSG       ; DOS message
 296+ 1391 CD F7 26             call    PRS
 297+ 1394 21 B3 13     SETTP1: ld      HL,BLNSPC       ; Empty space
 298+ 1397 CD F7 26             call    PRS             ; Output string
 299+ 139A E1                   pop     HL              ; Get bytes free back
 300+ 139B CD 96 31             call    PRNTHL          ; Output amount of free memory
 301+ 139E 21 BC 13             ld      HL,BFREE        ; " Bytes free" message
 302+ 13A1 CD F7 26             call    PRS             ; Output string
 303+ 13A4
 304+ 13A4 31 B7 54     WARMST: ld      SP,STACK        ; Temporary stack
 305+ 13A7 CD 79 19     BRKRET: call    CLREG           ; Clear registers and stack
 306+ 13AA CD B9 3E             call    RESFN           ; reset FN keys and auto-repeat
 307+ 13AD CD 2D 09             call    CURSOR_ON       ; enable cursor
 308+ 13B0 C3 77 18             jp      PRNTOK          ; Go to get command line
 309+ 13B3
 310+ 13B3 20 20 20 20  BLNSPC: defb    "        ",0    ; 8 empty cells to align the "XXXX Bytes free" message
 310+ 13B7 20 20 20 20
 310+ 13BB 00
 311+ 13BC 20 42 79 74  BFREE:  defb    " Bytes free",CR,CR,0
 311+ 13C0 65 73 20 66
 311+ 13C4 72 65 65 0D
 311+ 13C8 0D 00
 312+ 13CA
 313+ 13CA 4C 4D 38 30  SIGNON: defb    "LM80C BASIC 3.25 ",251,"2021 L.Miliani"
 313+ 13CE 43 20 42 41
 313+ 13D2 53 49 43 20
 313+ 13D6 33 2E 32 35
 313+ 13DA 20 FB 32 30
 313+ 13DE 32 31 20 4C
 313+ 13E2 2E 4D 69 6C
 313+ 13E6 69 61 6E 69
 314+ 13EA 20 5A 38 30          defb    " Z80 BASIC 4.7  ",251,"1978 Microsoft",CR,0
 314+ 13EE 20 42 41 53
 314+ 13F2 49 43 20 34
 314+ 13F6 2E 37 20 20
 314+ 13FA FB 31 39 37
 314+ 13FE 38 20 4D 69
 314+ 1402 63 72 6F 73
 314+ 1406 6F 66 74 0D
 314+ 140A 00
 315+ 140B 20 20 20 20  DOSMSG: defb    "     LM80C DOS ","1.05","  Loaded",CR,0
 315+ 140F 20 4C 4D 38
 315+ 1413 30 43 20 44
 315+ 1417 4F 53 20 31
 315+ 141B 2E 30 35 20
 315+ 141F 20 4C 6F 61
 315+ 1423 64 65 64 0D
 315+ 1427 00
 316+ 1428
 317+ 1428 4D 65 6D 6F  MEMMSG: defb    "Memory top",0
 317+ 142C 72 79 20 74
 317+ 1430 6F 70 00
 318+ 1433
 319+ 1433              ; The following list reports all the functions supported by the interpreter.
 320+ 1433              ; To add a custom function, the user must first insert the reserved word here,
 321+ 1433              ; then into the list of the reserved words below, and finally must increment the
 322+ 1433              ; ZSGN token value and all the following ones after ZSGN by 1 for every added
 323+ 1433              ; function.
 324+ 1433
 325+ 1433              ; FUNCTION ADDRESS TABLE (this is a sort of offset table)
 326+ 1433              ; this list must be coherent with the tokens' functions list. This means that every
 327+ 1433              ; entry here must have the corresponding entry in the tokens list.
 328+ 1433 0B 30        FNCTAB: defw    SGN
 329+ 1435 A1 25                defw    TMR         ; added by Leonardo Miliani
 330+ 1437 CF 30                defw    INT
 331+ 1439 21 30                defw    ABS_        ; '_' necessary to avoid assembler warnings
 332+ 143B DE 53                defw    USR
 333+ 143D B7 25                defw    FRE
 334+ 143F 32 2A                defw    INP
 335+ 1441 E5 25                defw    POS
 336+ 1443 95 32                defw    SQR
 337+ 1445 74 33                defw    RND
 338+ 1447 5F 2E                defw    LOG
 339+ 1449 E3 32                defw    EXP
 340+ 144B E9 33                defw    COS
 341+ 144D EF 33                defw    SIN
 342+ 144F 50 34                defw    TAN
 343+ 1451 65 34                defw    ATN
 344+ 1453 0E 2B                defw    PEEK
 345+ 1455 CF 34                defw    DEEK
 346+ 1457 15 2B                defw    VPEEK       ; added by Leonardo Miliani
 347+ 1459 E4 2C                defw    VSTAT       ; added by Leonardo Miliani
 348+ 145B EF 2C                defw    SSTAT       ; added by Leonardo Miliani
 349+ 145D 03 2D                defw    INKEY       ; added by Leonardo Miliani
 350+ 145F 26 38                defw    POINT       ; added by Leonardo Miliani
 351+ 1461 C9 28                defw    INSTR       ; added by Leonardo Miliani
 352+ 1463 E8 FF                defw    JPGET       ; added by Leonardo Miliani
 353+ 1465 E2 FF                defw    JPEOF       ; added by Leonardo Miliani
 354+ 1467 69 28                defw    LEN
 355+ 1469 81 26                defw    STR
 356+ 146B F9 29                defw    VAL
 357+ 146D 78 28                defw    ASC
 358+ 146F 89 28                defw    CHR
 359+ 1471 19 40                defw    HEX         ; added by Grant Searle
 360+ 1473 AA 40                defw    BIN         ; added by Grant Searle
 361+ 1475 99 28                defw    LEFT
 362+ 1477 BF 29                defw    RIGHT
 363+ 1479 C9 29                defw    MID
 364+ 147B
 365+ 147B              ; RESERVED WORD LIST
 366+ 147B              ; Here are all the reserved words used by the interpreter
 367+ 147B              ; To add custom functions/commands, the user must insert the keyword
 368+ 147B              ; in this list, following the schematic
 369+ 147B C5 4E 44     WORDS:  defb    'E'+$80,"ND"            ; from here the list contains the COMMANDS
 370+ 147E C6 4F 52             defb    'F'+$80,"OR"
 371+ 1481 CE 45 58 54          defb    'N'+$80,"EXT"
 372+ 1485 C4 41 54 41          defb    'D'+$80,"ATA"
 373+ 1489 C9 4E 50 55          defb    'I'+$80,"NPUT"
 373+ 148D 54
 374+ 148E C4 49 4D             defb    'D'+$80,"IM"
 375+ 1491 D2 45 41 44          defb    'R'+$80,"EAD"
 376+ 1495 CC 45 54             defb    'L'+$80,"ET"
 377+ 1498 C7 4F 54 4F          defb    'G'+$80,"OTO"
 378+ 149C D2 55 4E             defb    'R'+$80,"UN"
 379+ 149F C9 46                defb    'I'+$80,"F"
 380+ 14A1 D2 45 53 54          defb    'R'+$80,"ESTORE"
 380+ 14A5 4F 52 45
 381+ 14A8 C7 4F 53 55          defb    'G'+$80,"OSUB"
 381+ 14AC 42
 382+ 14AD D2 45 54 55          defb    'R'+$80,"ETURN"
 382+ 14B1 52 4E
 383+ 14B3 D2 45 4D             defb    'R'+$80,"EM"            ; original REM
 384+ 14B6 D3 54 4F 50          defb    'S'+$80,"TOP"
 385+ 14BA CF 55 54             defb    'O'+$80,"UT"
 386+ 14BD CF 4E                defb    'O'+$80,"N"
 387+ 14BF C6 49 4C 45          defb    'F'+$80,"ILES"          ; added by Leonardo Miliani
 387+ 14C3 53
 388+ 14C4 C5 52 41 53          defb    'E'+$80,"RASE"          ; added by Leonardo Miliani
 388+ 14C8 45
 389+ 14C9 C4 49 53 4B          defb    'D'+$80,"ISK"           ; added by Leonardo Miliani
 390+ 14CD CF 50 45 4E          defb    'O'+$80,"PEN"           ; added by Leonardo Miliani
 391+ 14D1 C3 4C 4F 53          defb    'C'+$80,"LOSE"          ; added by Leonardo Miliani
 391+ 14D5 45
 392+ 14D6 D0 55 54             defb    'P'+$80,"UT"            ; added by Leonardo Miliani
 393+ 14D9 D7 41 49 54          defb    'W'+$80,"AIT"
 394+ 14DD C4 45 46             defb    'D'+$80,"EF"
 395+ 14E0 D0 4F 4B 45          defb    'P'+$80,"OKE"
 396+ 14E4 C4 4F 4B 45          defb    'D'+$80,"OKE"
 397+ 14E8 D6 50 4F 4B          defb    'V'+$80,"POKE"          ; added by Leonardo Miliani
 397+ 14EC 45
 398+ 14ED D3 52 45 47          defb    'S'+$80,"REG"           ; added by Leonardo Miliani
 399+ 14F1 D6 52 45 47          defb    'V'+$80,"REG"           ; added by Leonardo Miliani
 400+ 14F5 D3 43 52 45          defb    'S'+$80,"CREEN"         ; changed by Leonardo Miliani
 400+ 14F9 45 4E
 401+ 14FB CC 4F 43 41          defb    'L'+$80,"OCATE"         ; added by Leonardo Miliani
 401+ 14FF 54 45
 402+ 1501 D3 4F 55 4E          defb    'S'+$80,"OUND"          ; added by Leonardo Miliani
 402+ 1505 44
 403+ 1506 D6 4F 4C 55          defb    'V'+$80,"OLUME"         ; added by Leonardo Miliani
 403+ 150A 4D 45
 404+ 150C D0 41 55 53          defb    'P'+$80,"AUSE"          ; added by Leonardo Miliani
 404+ 1510 45
 405+ 1511 C3 4F 4C 4F          defb    'C'+$80,"OLOR"          ; added by Leonardo Miliani
 405+ 1515 52
 406+ 1516 D0 4C 4F 54          defb    'P'+$80,"LOT"           ; added by Leonardo Miliani
 407+ 151A C4 52 41 57          defb    'D'+$80,"RAW"           ; added by Leonardo Miliani
 408+ 151E C3 49 52 43          defb    'C'+$80,"IRCLE"         ; added by Leonardo Miliani
 408+ 1522 4C 45
 409+ 1524 D0 41 49 4E          defb    'P'+$80,"AINT"          ; added by Leonardo Miliani
 409+ 1528 54
 410+ 1529 D3 45 52 49          defb    'S'+$80,"ERIAL"         ; added by Leonardo Miliani
 410+ 152D 41 4C
 411+ 152F C8 45 4C 50          defb    'H'+$80,"ELP"           ; changed by Leonardo Miliani - was LINES
 412+ 1533 C3 4C 53             defb    'C'+$80,"LS"            ; restored command
 413+ 1536 CB 45 59             defb    'K'+$80,"EY"            ; added by Leonardo Miliani
 414+ 1539 CE 4D 49             defb    'N'+$80,"MI"            ; added by Leonardo Miliani
 415+ 153C C7 50 52 49          defb    'G'+$80,"PRINT"         ; added by Leonardo Miliani
 415+ 1540 4E 54
 416+ 1542 D7 49 44 54          defb    'W'+$80,"IDTH"
 416+ 1546 48
 417+ 1547 D3 59 53             defb    'S'+$80,"YS"            ; added by Leonardo Miliani
 418+ 154A D2 45 53 45          defb    'R'+$80,"ESET"          ; changed by Leonardo Miliani
 418+ 154E 54
 419+ 154F C5 4C 53 45          defb    'E'+$80,"LSE"           ; added by Leonardo Miliani
 420+ 1553 D0 52 49 4E          defb    'P'+$80,"RINT"
 420+ 1557 54
 421+ 1558 C3 4F 4E 54          defb    'C'+$80,"ONT"
 422+ 155C CC 49 53 54          defb    'L'+$80,"IST"
 423+ 1560 C3 4C 45 41          defb    'C'+$80,"LEAR"
 423+ 1564 52
 424+ 1565 CC 4F 41 44          defb    'L'+$80,"OAD"
 425+ 1569 D3 41 56 45          defb    'S'+$80,"AVE"
 426+ 156D CE 45 57             defb    'N'+$80,"EW"
 427+ 1570 D4 41 42 28          defb    'T'+$80,"AB("
 428+ 1574 D4 4F                defb    'T'+$80,"O"
 429+ 1576 C6 4E                defb    'F'+$80,"N"
 430+ 1578 D3 50 43 28          defb    'S'+$80,"PC("
 431+ 157C D4 48 45 4E          defb    'T'+$80,"HEN"
 432+ 1580 CE 4F 54             defb    'N'+$80,"OT"
 433+ 1583 D3 54 45 50          defb    'S'+$80,"TEP"
 434+ 1587                      ; from here: operators
 435+ 1587 AB                   defb    '+'+$80
 436+ 1588 AD                   defb    '-'+$80
 437+ 1589 AA                   defb    '*'+$80
 438+ 158A AF                   defb    '/'+$80
 439+ 158B A5                   defb    '%'+$80
 440+ 158C A3                   defb    '#'+$80
 441+ 158D DE                   defb    '^'+$80
 442+ 158E C1 4E 44             defb    'A'+$80,"ND"
 443+ 1591 D8 4F 52             defb    'X'+$80,"OR"
 444+ 1594 CF 52                defb    'O'+$80,"R"
 445+ 1596 BE                   defb    '>'+$80
 446+ 1597 BD                   defb    '='+$80
 447+ 1598 BC                   defb    '<'+$80
 448+ 1599
 449+ 1599                      ; from here there are the tokens' FUNCTIONS list
 450+ 1599                      ; this list must be coherent with the functions list above
 451+ 1599 D3 47 4E             defb    'S'+$80,"GN"
 452+ 159C D4 4D 52             defb    'T'+$80,"MR"            ; added by Leonardo Miliani
 453+ 159F C9 4E 54             defb    'I'+$80,"NT"
 454+ 15A2 C1 42 53             defb    'A'+$80,"BS"
 455+ 15A5 D5 53 52             defb    'U'+$80,"SR"
 456+ 15A8 C6 52 45             defb    'F'+$80,"RE"
 457+ 15AB C9 4E 50             defb    'I'+$80,"NP"
 458+ 15AE D0 4F 53             defb    'P'+$80,"OS"
 459+ 15B1 D3 51 52             defb    'S'+$80,"QR"
 460+ 15B4 D2 4E 44             defb    'R'+$80,"ND"
 461+ 15B7 CC 4F 47             defb    'L'+$80,"OG"
 462+ 15BA C5 58 50             defb    'E'+$80,"XP"
 463+ 15BD C3 4F 53             defb    'C'+$80,"OS"
 464+ 15C0 D3 49 4E             defb    'S'+$80,"IN"
 465+ 15C3 D4 41 4E             defb    'T'+$80,"AN"
 466+ 15C6 C1 54 4E             defb    'A'+$80,"TN"
 467+ 15C9 D0 45 45 4B          defb    'P'+$80,"EEK"
 468+ 15CD C4 45 45 4B          defb    'D'+$80,"EEK"
 469+ 15D1 D6 50 45 45          defb    'V'+$80,"PEEK"          ; added by Leonardo Miliani
 469+ 15D5 4B
 470+ 15D6 D6 53 54 41          defb    'V'+$80,"STAT"          ; added by Leonardo Miliani
 470+ 15DA 54
 471+ 15DB D3 53 54 41          defb    'S'+$80,"STAT"          ; added by Leonardo Miliani
 471+ 15DF 54
 472+ 15E0 C9 4E 4B 45          defb    'I'+$80,"NKEY"          ; added by Leonardo Miliani
 472+ 15E4 59
 473+ 15E5 D0 4F 49 4E          defb    'P'+$80,"OINT"          ; added by Leonardo Miliani
 473+ 15E9 54
 474+ 15EA C9 4E 53 54          defb    'I'+$80,"NSTR"          ; added by Leonardo Miliani
 474+ 15EE 52
 475+ 15EF C7 45 54             defb    'G'+$80,"ET"            ; added by Leonardo Miliani
 476+ 15F2 C5 4F 46             defb    'E'+$80,"OF"            ; added by Leonardo Miliani
 477+ 15F5 CC 45 4E             defb    'L'+$80,"EN"
 478+ 15F8 D3 54 52 24          defb    'S'+$80,"TR$"
 479+ 15FC D6 41 4C             defb    'V'+$80,"AL"
 480+ 15FF C1 53 43             defb    'A'+$80,"SC"
 481+ 1602 C3 48 52 24          defb    'C'+$80,"HR$"
 482+ 1606 C8 45 58 24          defb    'H'+$80,"EX$"           ; added by Grant Searle
 483+ 160A C2 49 4E 24          defb    'B'+$80,"IN$"           ; added by Grant Searle
 484+ 160E CC 45 46 54          defb    'L'+$80,"EFT$"
 484+ 1612 24
 485+ 1613 D2 49 47 48          defb    'R'+$80,"IGHT$"
 485+ 1617 54 24
 486+ 1619 CD 49 44 24          defb    'M'+$80,"ID$"
 487+ 161D 80                   defb    $80                     ; End-of-list marker
 488+ 161E
 489+ 161E              ; COMMAND KEYWORD ADDRESS TABLE
 490+ 161E              ; this list must be coherent with the commands' tokens list above
 491+ 161E A8 1D        WORDTB: defw    PEND
 492+ 1620 A5 1C                defw    FOR
 493+ 1622 A4 21                defw    NEXT
 494+ 1624 07 1F                defw    DATA
 495+ 1626 A1 20                defw    INPUT
 496+ 1628 F9 23                defw    DIM
 497+ 162A DB 20                defw    READ
 498+ 162C 1E 1F                defw    LET
 499+ 162E C4 1E                defw    GOTO
 500+ 1630 9F 1E                defw    RUN
 501+ 1632 96 1F                defw    IF
 502+ 1634 6E 1D                defw    RESTOR
 503+ 1636 B3 1E                defw    GOSUB
 504+ 1638 E2 1E                defw    RETURN
 505+ 163A 09 1F                defw    REM         ; original REM
 506+ 163C A6 1D                defw    STOP
 507+ 163E 3E 2A                defw    POUT
 508+ 1640 78 1F                defw    ON
 509+ 1642 FD FF                defw    JPFILS      ; changed by Leonardo Miliani - was NULL
 510+ 1644 F4 FF                defw    JPERAS      ; added by Leonardo Miliani
 511+ 1646 F1 FF                defw    JPDISK      ; added by Leonardo Miliani
 512+ 1648 EE FF                defw    JPOPEN      ; added by Leonardo Miliani
 513+ 164A EB FF                defw    JPCLOSE     ; added by Leonardo Miliani
 514+ 164C E5 FF                defw    JPPUT       ; added by Leonardo Miliani
 515+ 164E 44 2A                defw    WAIT
 516+ 1650 ED 25                defw    DEF
 517+ 1652 38 2B                defw    POKE
 518+ 1654 DA 34                defw    DOKE
 519+ 1656 3D 2B                defw    VPOKE       ; added by Leonardo Miliani
 520+ 1658 7A 2B                defw    SREG        ; added by Leonardo Miliani
 521+ 165A C8 2C                defw    VREG        ; added by Leonardo Miliani
 522+ 165C 10 35                defw    SCREEN      ; new behaviour: now it sets up a graphics mode (Leonardo Miliani)
 523+ 165E 48 2B                defw    LOCATE      ; added by Leonardo Miliani
 524+ 1660 D4 2B                defw    SOUND       ; added by Leonardo Miliani
 525+ 1662 9B 2B                defw    VOLUME      ; added by Leonardo Miliani
 526+ 1664 F1 34                defw    PAUSE       ; added by Leonardo Miliani
 527+ 1666 8B 35                defw    COLOR       ; added by Leonardo Miliani
 528+ 1668 79 38                defw    PLOT        ; added by Leonardo Miliani
 529+ 166A 0B 39                defw    DRAW        ; added by Leonardo Miliani
 530+ 166C 44 3A                defw    CIRCLE      ; added by Leonardo Miliani
 531+ 166E 36 37                defw    PAINT       ; added by Leonardo Miliani
 532+ 1670 4F 3C                defw    SERIAL      ; added by Leonardo Miliani
 533+ 1672 8E 3E                defw    HELP        ; changed by Leonardo Miliani - was LINES
 534+ 1674 B3 34                defw    CLS
 535+ 1676 AC 3E                defw    KEY         ; added by Leonardo Miliani
 536+ 1678 86 2A                defw    NMI         ; added by Leonardo Miliani
 537+ 167A 46 36                defw    GPRINT      ; added by Leonardo Miliani
 538+ 167C C7 34                defw    WIDTH
 539+ 167E E0 2A                defw    SYS         ; added by Leonardo Miliani
 540+ 1680 0F 41                defw    RESET       ; new behaviour: now it resets the system
 541+ 1682 0B 1F                defw    REM+2       ; ELSE: added by Leonardo Miliani
 542+ 1684 C8 1F                defw    PRINT
 543+ 1686 DA 1D                defw    CONT
 544+ 1688 7C 1B                defw    LIST
 545+ 168A 53 1E                defw    CLEAR
 546+ 168C F7 FF                defw    JPLOAD      ; re-implemented by Leonardo Miliani (was CLOAD)
 547+ 168E FA FF                defw    JPSAVE      ; re-implemented by Leonardo Miliani (was CSAVE)
 548+ 1690 53 19                defw    NEW
 549+ 1692
 550+ 1692              ; RESERVED WORD TOKEN VALUES
 551+ 1692              ; if you add a function or command you must increment by 1
 552+ 1692              ; the values below. Pay attention that you must increment only the
 553+ 1692              ; values AFTER the position where you entered the function/command word
 554+ 1692              ; in the "Reserver word list" above. I.E.: VPOKE has been added between
 555+ 1692              ; DOKE and SCREEN, and since REM is the reserved work listed below
 556+ 1692              ; that is before the point where VPOKE has been entered, every entry
 557+ 1692              ; after REM has been incremented.
 558+ 1692              ; Another example: when TMR has been added, since it's a function, every
 559+ 1692              ; entry after & included ZSGN must be checked (read below)
 560+ 1692
 561+ 1692              ZEND    equ     $80             ; END        <-- from here, there are the commands
 562+ 1692              ZFOR    equ     $81             ; FOR
 563+ 1692              ZDATA   equ     $83             ; DATA
 564+ 1692              ZGOTO   equ     $88             ; GOTO
 565+ 1692              ZGOSUB  equ     $8C             ; GOSUB
 566+ 1692              ZREM    equ     $8E             ; REM
 567+ 1692              ZELSE   equ     $B2             ; ELSE
 568+ 1692              ZPRINT  equ     $B3             ; PRINT
 569+ 1692              ZNEW    equ     $B9             ; NEW
 570+ 1692
 571+ 1692              ZTAB    equ     $BA             ; TAB
 572+ 1692              ZTO     equ     $BB             ; TO
 573+ 1692              ZFN     equ     $BC             ; FN
 574+ 1692              ZSPC    equ     $BD             ; SPC
 575+ 1692              ZTHEN   equ     $BE             ; THEN
 576+ 1692              ZNOT    equ     $BF             ; NOT
 577+ 1692              ZSTEP   equ     $C0             ; STEP
 578+ 1692
 579+ 1692              ZPLUS   equ     $C1             ; +         <-- from here, there are the math operators
 580+ 1692              ZMINUS  equ     $C2             ; -
 581+ 1692              ZTIMES  equ     $C3             ; *
 582+ 1692              ZDIV    equ     $C4             ; /
 583+ 1692              ZMOD    equ     $C5             ; %
 584+ 1692              ZDINT   equ     $C6             ; #
 585+ 1692              ZOR     equ     $CA             ; OR
 586+ 1692              ZGTR    equ     $CB             ; >
 587+ 1692              ZEQUAL  equ     $CC             ; M
 588+ 1692              ZLTH    equ     $CD             ; <
 589+ 1692
 590+ 1692              ZSGN    equ     $CE             ; SGN       <-- from here, there are the functions
 591+ 1692              ZPOINT  equ     $E4             ; ZPOINT    <-- if the user enters a custom function, between
 592+ 1692                                              ;               SGN and POINT, he/she must increment this pointer by 1
 593+ 1692              ZINSTR  equ     $E5             ; ZINSTR    <-- same here
 594+ 1692              ZLEFT   equ     $EF             ; LEFT$     <-- if the user enters a custom function anywhere,
 595+ 1692                                              ;               he/she must increment this pointer by 1
 596+ 1692
 597+ 1692              ; ARITHMETIC PRECEDENCE TABLE
 598+ 1692              ; in the formulas below, <last> is a number stored into the stack that must be retrieved
 599+ 1692              ; with POP BC, POP DE; FPREG is a f.p. number store into the RAM register FPREG
 600+ 1692 79           PRITAB: defb    $79             ; Precedence value
 601+ 1693 7D 31                defw    PADD            ; FPREG = <last> + FPREG
 602+ 1695
 603+ 1695 79                   defb    $79             ; Precedence value
 604+ 1696 60 2D                defw    PSUB            ; FPREG = <last> - FPREG
 605+ 1698
 606+ 1698 7C                   defb    $7C             ; Precedence value
 607+ 1699 9E 2E                defw    MULT            ; PPREG = <last> * FPREG
 608+ 169B
 609+ 169B 7C                   defb    $7C             ; Precedence value
 610+ 169C 50 2F                defw    DIV             ; FPREG = <last> / FPREG
 611+ 169E
 612+ 169E 7C                   defb    $7C             ; Precedence value
 613+ 169F FB 2E                defw    MOD             ; FPREG = INT(<last>)-(INT(FPREG)*INT(<last>/FPREG))
 614+ 16A1
 615+ 16A1 7C                   defb    $7C             ; precedence value
 616+ 16A2 F3 2E                defw    DINT            ; FPREG = INT(<last> / FPREG )
 617+ 16A4
 618+ 16A4 7F                   defb    $7F             ; Precedence value
 619+ 16A5 9E 32                defw    POWER           ; FPREG = <last> ^ FPREG
 620+ 16A7
 621+ 16A7 50                   defb    $50             ; Precedence value
 622+ 16A8 42 23                defw    PAND            ; FPREG = <last> AND FPREG
 623+ 16AA
 624+ 16AA 4A                   defb    $4A             ; Precedence value
 625+ 16AB 4A 23                defw    PXOR            ; FPREG = <last> XOR FPREG
 626+ 16AD
 627+ 16AD 46                   defb    $46             ; Precedence value
 628+ 16AE 45 23                defw    POR             ; FPREG = <last> OR FPREG
 629+ 16B0
 630+ 16B0
 631+ 16B0              ; INITIALISATION TABLE -------------------------------------------------------
 632+ 16B0              ; these values are copied into RAM at startup
 633+ 16B0 C3 A4 13     INITAB: jp      WARMST          ; Warm start jump
 634+ 16B3 ED 45 00             defb    $ED,$45,$00     ; RETN + NOP for default NMI service routine
 635+ 16B6 C3 29 1E             jp      FCERR           ; "USR (X)" jump (Set to Error)
 636+ 16B9 D3 00                out     (0),A           ; "out p,n" skeleton
 637+ 16BB C9                   ret
 638+ 16BC D6 00                sub     $00             ; Division support routine
 639+ 16BE 6F                   ld      L,A
 640+ 16BF 7C                   ld      A,H
 641+ 16C0 DE 00                sbc     A,$00
 642+ 16C2 67                   ld      H,A
 643+ 16C3 78                   ld      A,B
 644+ 16C4 DE 00                sbc     A,$00
 645+ 16C6 47                   ld      B,A
 646+ 16C7 3E 00                ld      A,$00
 647+ 16C9 C9                   ret
 648+ 16CA 00 00 00             defb    $00,$00,$00     ; Random number seed table used by RND
 649+ 16CD 35 4A CA 99          defb    $35,$4A,$CA,$99 ;-2.65145E+07
 650+ 16D1 39 1C 76 98          defb    $39,$1C,$76,$98 ; 1.61291E+07
 651+ 16D5 22 95 B3 98          defb    $22,$95,$B3,$98 ;-1.17691E+07
 652+ 16D9 0A DD 47 98          defb    $0A,$DD,$47,$98 ; 1.30983E+07
 653+ 16DD 53 D1 99 99          defb    $53,$D1,$99,$99 ;-2-01612E+07
 654+ 16E1 0A 1A 9F 98          defb    $0A,$1A,$9F,$98 ;-1.04269E+07
 655+ 16E5 65 BC CD 98          defb    $65,$BC,$CD,$98 ;-1.34831E+07
 656+ 16E9 D6 77 3E 98          defb    $D6,$77,$3E,$98 ; 1.24825E+07
 657+ 16ED 52 C7 4F 80          defb    $52,$C7,$4F,$80 ; Last random number
 658+ 16F1 DB 00                in      A,($00)         ; INP (x) skeleton
 659+ 16F3 C9                   ret
 660+ 16F4 FF                   defb    $FF             ; Terminal width (255 = no auto CRLF)
 661+ 16F5 14                   defb    $14             ; Width for commas (at reset, 3 columns, for G1 mode)
 662+ 16F6 00                   defb    $00             ; No nulls after input bytes
 663+ 16F7 00                   defb    $00             ; Output enabled (^O off)
 664+ 16F8 00 00                defw    $00             ; Array load/save check sum
 665+ 16FA 00                   defb    $00             ; Break not by NMI
 666+ 16FB 00                   defb    $00             ; Break flag
 667+ 16FC C3 97 1A             jp      TTYLIN          ; Input reflection (set to TTY)
 668+ 16FF 49 56                defw    STLOOK          ; Temp string space
 669+ 1701 FE FF                defw    -2              ; Current line number (cold)
 670+ 1703 FF FF                defw    -1              ; Current line with errors (no errors)
 671+ 1705 40           AUTORP: defb    $40             ; delay for key auto-repeat start
 672+ 1706 08                   defb    $08             ; auto-repeat delay
 673+ 1707 4C 49 53 54  DEFFNKS:defm    "LIST",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 1
 673+ 170B 0D 00 00 00
 673+ 170F 00 00 00 00
 673+ 1713 00 00 00 00
 674+ 1717 52 55 4E 0D          defm    "RUN",13,0,0,0,0,0,0,0,0,0,0,0,0    ; KEY 2
 674+ 171B 00 00 00 00
 674+ 171F 00 00 00 00
 674+ 1723 00 00 00 00
 675+ 1727 53 43 52 45          defm    "SCREEN1",13,0,0,0,0,0,0,0,0        ; KEY 3
 675+ 172B 45 4E 31 0D
 675+ 172F 00 00 00 00
 675+ 1733 00 00 00 00
 676+ 1737 43 4F 4C 4F          defm    "COLOR1,15,5",13,0,0,0,0            ; KEY 4
 676+ 173B 52 31 2C 31
 676+ 173F 35 2C 35 0D
 676+ 1743 00 00 00 00
 677+ 1747 53 45 52 49          defm    "SERIAL1,38400",13,0,0              ; KEY 5
 677+ 174B 41 4C 31 2C
 677+ 174F 33 38 34 30
 677+ 1753 30 0D 00 00
 678+ 1757 53 43 52 45          defm    "SCREEN2",13,0,0,0,0,0,0,0,0        ; KEY 6
 678+ 175B 45 4E 32 0D
 678+ 175F 00 00 00 00
 678+ 1763 00 00 00 00
 679+ 1767 43 4F 4E 54          defm    "CONT",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 7
 679+ 176B 0D 00 00 00
 679+ 176F 00 00 00 00
 679+ 1773 00 00 00 00
 680+ 1777 48 45 4C 50          defm    "HELP",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 8 (HELP KEY)
 680+ 177B 0D 00 00 00
 680+ 177F 00 00 00 00
 680+ 1783 00 00 00 00
 681+ 1787 E6 55                defw    PROGST+1        ; Start of program text
 682+ 1789              INITBE:
 683+ 1789
 684+ 1789              ; END OF INITIALISATION TABLE ---------------------------------------------------
 685+ 1789
 686+ 1789 20 45 72 72  ERRMSG: defb    " Error",0
 686+ 178D 6F 72 00
 687+ 1790 20 69 6E 20  INMSG:  defb    " in ",0
 687+ 1794 00
 688+ 1795              ZERBYT  equ     $-1             ; A zero byte
 689+ 1795 4F 6B 0D 00  OKMSG:  defb    "Ok",CR,0,0
 689+ 1799 00
 690+ 179A 42 72 65 61  BRKMSG: defb    "Break",0
 690+ 179E 6B 00
 691+ 17A0
 692+ 17A0 21 04 00     BAKSTK: ld      HL,$04          ; Look for "FOR" block with
 693+ 17A3 39                   add     HL,SP           ; same index as specified
 694+ 17A4 7E           LOKFOR: ld      A,(HL)          ; Get block ID
 695+ 17A5 23                   inc     HL              ; Point to index address
 696+ 17A6 FE 81                cp      ZFOR            ; Is it a "FOR" token
 697+ 17A8 C0                   ret     NZ              ; No - exit
 698+ 17A9 4E                   ld      C,(HL)          ; BC = Address of "FOR" index
 699+ 17AA 23                   inc     HL
 700+ 17AB 46                   ld      B,(HL)
 701+ 17AC 23                   inc     HL              ; Point to sign of STEP
 702+ 17AD E5                   push    HL              ; Save pointer to sign
 703+ 17AE 69                   ld      L,C             ; HL = address of "FOR" index
 704+ 17AF 60                   ld      H,B
 705+ 17B0 7A                   ld      A,D             ; See if an index was specified
 706+ 17B1 B3                   or      E               ; DE = 0 if no index specified
 707+ 17B2 EB                   ex      DE,HL           ; Specified index into HL
 708+ 17B3 CA BA 17             jp      Z,INDFND        ; Skip if no index given
 709+ 17B6 EB                   ex      DE,HL           ; Index back into DE
 710+ 17B7 CD 0F 1B             call    CPDEHL          ; Compare index with one given
 711+ 17BA 01 0D 00     INDFND: ld      BC,16-3         ; Offset to next block
 712+ 17BD E1                   pop     HL              ; Restore pointer to sign
 713+ 17BE C8                   ret     Z               ; Return if block found
 714+ 17BF 09                   add     HL,BC           ; Point to next block
 715+ 17C0 C3 A4 17             jp      LOKFOR          ; Keep on looking
 716+ 17C3
 717+ 17C3 CD DD 17     MOVUP:  call    ENFMEM          ; See if enough memory
 718+ 17C6 C5           MOVSTR: push    BC              ; Save end of source
 719+ 17C7 E3                   ex      (SP),HL         ; Swap source and dest" end
 720+ 17C8 C1                   pop     BC              ; Get end of destination
 721+ 17C9 CD 0F 1B     MOVLP:  call    CPDEHL          ; See if list moved
 722+ 17CC 7E                   ld      A,(HL)          ; Get byte
 723+ 17CD 02                   ld      (BC),A          ; Move it
 724+ 17CE C8                   ret     Z               ; Exit if all done
 725+ 17CF 0B                   dec     BC              ; Next byte to move to
 726+ 17D0 2B                   dec     HL              ; Next byte to move
 727+ 17D1 C3 C9 17             jp      MOVLP           ; Loop until all bytes moved
 728+ 17D4
 729+ 17D4 E5           CHKSTK: push    HL              ; Save code string address
 730+ 17D5 2A C6 55             ld      HL,(ARREND)     ; Lowest free memory
 731+ 17D8 06 00                ld      B,$00           ; BC = Number of levels to test
 732+ 17DA 09                   add     HL,BC           ; 2 Bytes for each level
 733+ 17DB 09                   add     HL,BC
 734+ 17DC 3E                   defb    $3E             ; Skip "push HL"
 735+ 17DD E5           ENFMEM: push    HL              ; Save code string address
 736+ 17DE 3E D0                ld      A,$D0           ; LOW -48 ; 48 Bytes minimum RAM
 737+ 17E0 95                   sub     L
 738+ 17E1 6F                   ld      L,A
 739+ 17E2 3E FF                ld      A,$FF           ; HIGH (-48) ; 48 Bytes minimum RAM
 740+ 17E4 9C                   sbc     A,H
 741+ 17E5 DA EC 17             jp      C,OMERR         ; Not enough - ?OM Error
 742+ 17E8 67                   ld      H,A
 743+ 17E9 39                   add     HL,SP           ; Test if stack is overflowed
 744+ 17EA E1                   pop     HL              ; Restore code string address
 745+ 17EB D8                   ret     C               ; Return if enough memory
 746+ 17EC 1E 0C        OMERR:  ld      E,OM            ; ?OM Error
 747+ 17EE C3 31 18             jp      ERROR
 748+ 17F1
 749+ 17F1
 750+ 17F1              ; if in graphics mode, return to text (called by "NOLIN" and "ERROR")
 751+ 17F1 F5           EXITGM: push    AF              ; store AF
 752+ 17F2 3A 6E 55             ld      A,(SCR_MODE)    ; check screen mode
 753+ 17F5 FE 02                cp      $02             ; G2?
 754+ 17F7 CA FE 17             jp      Z,LDG1          ; yes, back to G1
 755+ 17FA FE 03                cp      $03             ; G3?
 756+ 17FC 20 11                jr      NZ,LDG1ND       ; no, so return
 757+ 17FE E5           LDG1:   push    HL              ; store HL
 758+ 17FF D5                   push    DE              ; store DE
 759+ 1800 11 01 00             ld      DE,$0001        ; sprites set to defaults, G1 mode
 760+ 1803 F3                   di                      ; disable INTs
 761+ 1804 CD D1 03             call    initVDP         ; initialize VDP with mode pointed by E
 762+ 1807 FB                   ei                      ; re-enable INTs
 763+ 1808 3E 01                ld      A,$01           ; activate the...
 764+ 180A 32 78 55             ld      (PRNTVIDEO),A   ; ...video buffer...
 765+ 180D D1                   pop     DE              ; retrieve DE
 766+ 180E E1                   pop     HL              ; retrieve HL
 767+ 180F F1           LDG1ND: pop     AF              ; retrieve AF
 768+ 1810 C9                   ret                     ; return to caller
 769+ 1811
 770+ 1811
 771+ 1811 2A 4F 55     DATSNR: ld      HL,(DATLIN)     ; Get line of current DATA item
 772+ 1814 22 29 54             ld      (LINEAT),HL     ; Save as current line
 773+ 1817 1E 02        SNERR:  ld      E,SN            ; ?SN Error
 774+ 1819 01                   defb    $01             ; Skip "ld E,DZ"
 775+ 181A 1E 14        DZERR:  ld      E,DZ            ; ?/0 Error
 776+ 181C 01                   defb    $01             ; Skip "ld E,NF"
 777+ 181D 1E 00        NFERR:  ld      E,NF            ; ?NF Error
 778+ 181F 01                   defb    $01             ; Skip "ld E,DD"
 779+ 1820 1E 12        DDERR:  ld      E,DD            ; ?DD Error
 780+ 1822 01                   defb    $01             ; Skip "ld E,UF"
 781+ 1823 1E 22        UFERR:  ld      E,UF            ; ?UF Error
 782+ 1825 01                   defb    $01             ; Skip "ld E,OV
 783+ 1826 1E 0A        OVERR:  ld      E,OV            ; ?OV Error
 784+ 1828 01                   defb    $01             ; Skip "ld E,TM"
 785+ 1829 1E 18        TMERR:  ld      E,TM            ; ?TM Error
 786+ 182B 01                   defb    $01             ; Skip next statement
 787+ 182C 1E 34        IMERR:  ld      E,IM            ; ?Illegal indirect mode error
 788+ 182E 01                   defb    $01             ; Skip next statement
 789+ 182F 1E 36        NRERR:  ld      E,NR            ; ?Device not ready error
 790+ 1831
 791+ 1831 CD 79 19     ERROR:  call    CLREG           ; Clear registers and stack
 792+ 1834 CD F1 17             call    EXITGM          ; exit from graphic modes
 793+ 1837 32 1F 54             ld      (CTLOFG),A      ; Enable output (A is 0)
 794+ 183A CD 2D 09             call    CURSOR_ON       ; enable cursor
 795+ 183D CD 19 20             call    STTLIN          ; Start new line
 796+ 1840 21 13 10             ld      HL,ERRTBL       ; Point to error codes
 797+ 1843 57                   ld      D,A             ; D = 0 (A is 0)
 798+ 1844 3E 3F                ld      A,'?'
 799+ 1846 CD 20 1B             call    OUTC            ; Output '?'
 800+ 1849 19                   add     HL,DE           ; Offset to correct error code
 801+ 184A 5E                   ld      E,(HL)          ; load pointer to error message
 802+ 184B 23                   inc     HL              ; by loading LSB,
 803+ 184C 56                   ld      D,(HL)          ; then MSB
 804+ 184D 62 6B                ld      HL,DE           ; load pointer to HL
 805+ 184F CD F7 26             call    PRS             ; Output error message
 806+ 1852 21 89 17             ld      HL,ERRMSG       ; "Error" message
 807+ 1855 CD F7 26     ERRIN:  call    PRS             ; Output message
 808+ 1858 2A 29 54             ld      HL,(LINEAT)     ; Get line of error
 809+ 185B 11 FE FF             ld      DE,-2           ; Cold start error if -2
 810+ 185E CD 0F 1B             call    CPDEHL          ; See if cold start error
 811+ 1861 CA D5 12             jp      Z,CSTART        ; Cold start error - Restart
 812+ 1864 7C                   ld      A,H             ; Was it a direct error?
 813+ 1865 A5                   and     L               ; Line = -1 if direct error
 814+ 1866 3C                   inc     A
 815+ 1867 CA 72 18             jp      Z,PTLN          ; Yes, jump over
 816+ 186A E5                   push    HL              ; indirect mode - store HL
 817+ 186B 2A 29 54             ld      HL,(LINEAT)     ; copy current line number
 818+ 186E 22 2B 54             ld      (HLPLN),HL      ; save in HELP line register
 819+ 1871 E1                   pop     HL              ; retrieve HL
 820+ 1872 C4 8E 31     PTLN:   call    NZ,LINEIN       ; No - output line of error
 821+ 1875
 822+ 1875 3E                   defb    $3E             ; Skip "pop BC"
 823+ 1876 C1           POPNOK: pop     BC              ; Drop address in input buffer
 824+ 1877
 825+ 1877              ; run into direct mode: print OK and get command
 826+ 1877 AF           PRNTOK: xor     A               ; Output "Ok" and get command
 827+ 1878 32 1F 54             ld      (CTLOFG),A      ; Enable output
 828+ 187B CD 19 20             call    STTLIN          ; Start new line
 829+ 187E 21 95 17             ld      HL,OKMSG        ; "Ok" message
 830+ 1881 CD F7 26             call    PRS             ; Output "Ok"
 831+ 1884 CD 2D 09     GETCMD: call    CURSOR_ON       ; enable cursor
 832+ 1887 3A BE 55             ld      A,(SERIALS_EN)  ; load serial state
 833+ 188A EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
 834+ 188C CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
 835+ 188F 21 FF FF             ld      HL,-1           ; Flag direct mode
 836+ 1892 22 29 54             ld      (LINEAT),HL     ; Save as current line
 837+ 1895 CD 97 1A             call    GETLIN          ; Get an input line
 838+ 1898 DA 84 18             jp      C,GETCMD        ; Get line again if break
 839+ 189B CD 5E 1D             call    GETCHR          ; Get first character
 840+ 189E 17                   rla                     ; 8th bit is copied into carry and original carry is copied into bit 0)
 841+ 189F DA 17 18             jp      C,SNERR         ; if char >=128 (8th bit set) then raise an error
 842+ 18A2 1F                   rra                     ; recover original char and Carry
 843+ 18A3 3C                   inc     A               ; Test if end of line
 844+ 18A4 3D                   dec     A               ; Without affecting Carry
 845+ 18A5 CA 84 18             jp      Z,GETCMD        ; Nothing entered - Get another
 846+ 18A8 F5                   push    AF              ; Save Carry status
 847+ 18A9 3A BE 55             ld      A,(SERIALS_EN)  ; load serial state
 848+ 18AC EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
 849+ 18AE CC 8F 01             call    Z,A_RTS_OFF      ; yes, set RTS on
 850+ 18B1 CD 42 09             call    CURSOR_OFF      ; cursor disabled
 851+ 18B4 CD 2E 1E             call    ATOH            ; Get line number into DE
 852+ 18B7 D5                   push    DE              ; Save line number
 853+ 18B8 CD AE 19             call    CRUNCH          ; Tokenise rest of line
 854+ 18BB 47                   ld      B,A             ; Length of tokenised line
 855+ 18BC D1                   pop     DE              ; Restore line number
 856+ 18BD F1                   pop     AF              ; Restore Carry
 857+ 18BE D2 3E 1D             jp      NC,EXCUTE       ; No line number - Direct mode
 858+ 18C1 D5                   push    DE              ; Save line number
 859+ 18C2 C5                   push    BC              ; Save length of tokenised line
 860+ 18C3 AF                   xor     A
 861+ 18C4 32 52 55             ld      (LSTBIN),A      ; Clear last byte input
 862+ 18C7 CD 5E 1D             call    GETCHR          ; Get next character
 863+ 18CA B7                   or      A               ; Set flags
 864+ 18CB F5                   push    AF              ; And save them
 865+ 18CC CD 33 19             call    SRCHLN          ; Search for line number in DE
 866+ 18CF DA D8 18             jp      C,LINFND        ; Jump if line found
 867+ 18D2 F1                   pop     AF              ; Get status
 868+ 18D3 F5                   push    AF              ; And re-save
 869+ 18D4 CA DD 1E             jp      Z,ULERR         ; Nothing after number - Error
 870+ 18D7 B7                   or      A               ; Clear Carry
 871+ 18D8 C5           LINFND: push    BC              ; Save address of line in prog
 872+ 18D9 D2 EF 18             jp      NC,INEWLN       ; Line not found - Insert new
 873+ 18DC EB                   ex      DE,HL           ; Next line address in DE
 874+ 18DD 2A C2 55             ld      HL,(PROGND)     ; End of program
 875+ 18E0 1A           SFTPRG: ld      A,(DE)          ; Shift rest of program down
 876+ 18E1 02                   ld      (BC),A
 877+ 18E2 03                   inc     BC              ; Next destination
 878+ 18E3 13                   inc     DE              ; Next source
 879+ 18E4 CD 0F 1B             call    CPDEHL          ; All done?
 880+ 18E7 C2 E0 18             jp      NZ,SFTPRG       ; More to do
 881+ 18EA 60                   ld      H,B             ; HL - New end of program
 882+ 18EB 69                   ld      L,C
 883+ 18EC 22 C2 55             ld      (PROGND),HL     ; Update end of program
 884+ 18EF
 885+ 18EF D1           INEWLN: pop     DE              ; Get address of line,
 886+ 18F0 F1                   pop     AF              ; Get status
 887+ 18F1 CA 16 19             jp      Z,SETPTR        ; No text - Set up pointers
 888+ 18F4 2A C2 55             ld      HL,(PROGND)     ; Get end of program
 889+ 18F7 E3                   ex      (SP),HL         ; Get length of input line
 890+ 18F8 C1                   pop     BC              ; End of program to BC
 891+ 18F9 09                   add     HL,BC           ; Find new end
 892+ 18FA E5                   push    HL              ; Save new end
 893+ 18FB CD C3 17             call    MOVUP           ; Make space for line
 894+ 18FE E1                   pop     HL              ; Restore new end
 895+ 18FF 22 C2 55             ld      (PROGND),HL     ; Update end of program pointer
 896+ 1902 EB                   ex      DE,HL           ; Get line to move up in HL
 897+ 1903 74                   ld      (HL),H          ; Save MSB
 898+ 1904 D1                   pop     DE              ; Get new line number
 899+ 1905 23                   inc     HL              ; Skip pointer
 900+ 1906 23                   inc     HL
 901+ 1907 73                   ld      (HL),E          ; Save LSB of line number
 902+ 1908 23                   inc     HL
 903+ 1909 72                   ld      (HL),D          ; Save MSB of line number
 904+ 190A 23                   inc     HL              ; To first byte in line
 905+ 190B 11 B2 54             ld      DE,BUFFER       ; Copy buffer to program
 906+ 190E 1A           MOVBUF: ld      A,(DE)          ; Get source
 907+ 190F 77                   ld      (HL),A          ; Save destinations
 908+ 1910 23                   inc     HL              ; Next source
 909+ 1911 13                   inc     DE              ; Next destination
 910+ 1912 B7                   or      A               ; Done?
 911+ 1913 C2 0E 19             jp      NZ,MOVBUF       ; No - Repeat
 912+ 1916 CD 5F 19     SETPTR: call    RUNFST          ; Set line pointers
 913+ 1919 23                   inc     HL              ; To LSB of pointer
 914+ 191A EB                   ex      DE,HL           ; Address to DE
 915+ 191B 62           PTRLP:  ld      H,D             ; Address to HL
 916+ 191C 6B                   ld      L,E
 917+ 191D 7E                   ld      A,(HL)          ; Get LSB of pointer
 918+ 191E 23                   inc     HL              ; To MSB of pointer
 919+ 191F B6                   or      (HL)            ; Compare with MSB pointer
 920+ 1920 CA 84 18             jp      Z,GETCMD        ; Get command line if end
 921+ 1923 23                   inc     HL              ; To LSB of line number
 922+ 1924 23                   inc     HL              ; Skip line number
 923+ 1925 23                   inc     HL              ; Point to first byte in line
 924+ 1926 AF                   xor     A               ; Looking for 00 byte
 925+ 1927 BE           FNDEND: cp      (HL)            ; Found end of line?
 926+ 1928 23                   inc     HL              ; Move to next byte
 927+ 1929 C2 27 19             jp      NZ,FNDEND       ; No - Keep looking
 928+ 192C EB                   ex      DE,HL           ; Next line address to HL
 929+ 192D 73                   ld      (HL),E          ; Save LSB of pointer
 930+ 192E 23                   inc     HL
 931+ 192F 72                   ld      (HL),D          ; Save MSB of pointer
 932+ 1930 C3 1B 19             jp      PTRLP           ; Do next line
 933+ 1933
 934+ 1933 2A AF 54     SRCHLN: ld      HL,(BASTXT)     ; Start of program text
 935+ 1936 44           SRCHLP: ld      B,H             ; BC = Address to look at
 936+ 1937 4D                   ld      C,L
 937+ 1938 7E                   ld      A,(HL)          ; Get address of next line
 938+ 1939 23                   inc     HL
 939+ 193A B6                   or      (HL)            ; End of program found?
 940+ 193B 2B                   dec     HL
 941+ 193C C8                   ret     Z               ; Yes - Line not found
 942+ 193D 23                   inc     HL
 943+ 193E 23                   inc     HL
 944+ 193F 7E                   ld      A,(HL)          ; Get LSB of line number
 945+ 1940 23                   inc     HL
 946+ 1941 66                   ld      H,(HL)          ; Get MSB of line number
 947+ 1942 6F                   ld      L,A
 948+ 1943 CD 0F 1B             call    CPDEHL          ; Compare with line in DE
 949+ 1946 60                   ld      H,B             ; HL = Start of this line
 950+ 1947 69                   ld      L,C
 951+ 1948 7E                   ld      A,(HL)          ; Get LSB of next line address
 952+ 1949 23                   inc     HL
 953+ 194A 66                   ld      H,(HL)          ; Get MSB of next line address
 954+ 194B 6F                   ld      L,A             ; Next line to HL
 955+ 194C 3F                   ccf
 956+ 194D C8                   ret     Z               ; Lines found - Exit
 957+ 194E 3F                   ccf
 958+ 194F D0                   ret     NC              ; Line not found,at line after
 959+ 1950 C3 36 19             jp      SRCHLP          ; Keep looking
 960+ 1953
 961+ 1953 C0           NEW:    ret     NZ              ; Return if any more on line
 962+ 1954 2A AF 54     CLRPTR: ld      HL,(BASTXT)     ; Point to start of program
 963+ 1957 AF                   xor     A               ; Set program area to empty
 964+ 1958 77                   ld      (HL),A          ; Save LSB = 00
 965+ 1959 23                   inc     HL
 966+ 195A 77                   ld      (HL),A          ; Save MSB = 00
 967+ 195B 23                   inc     HL
 968+ 195C 22 C2 55             ld      (PROGND),HL     ; Set program end
 969+ 195F
 970+ 195F 2A AF 54     RUNFST: ld      HL,(BASTXT)     ; Clear all variables
 971+ 1962 2B                   dec     HL
 972+ 1963
 973+ 1963 22 54 55     INTVAR: ld      (BRKLIN),HL     ; Initialise RUN variables
 974+ 1966 2A 10 55             ld      HL,(LSTRAM)     ; Get end of RAM
 975+ 1969 22 49 55             ld      (STRBOT),HL     ; Clear string space
 976+ 196C AF                   xor     A
 977+ 196D CD 6E 1D             call    RESTOR          ; Reset DATA pointers
 978+ 1970 2A C2 55             ld      HL,(PROGND)     ; Get end of program
 979+ 1973 22 C4 55             ld      (VAREND),HL     ; Clear variables
 980+ 1976 22 C6 55             ld      (ARREND),HL     ; Clear arrays
 981+ 1979
 982+ 1979 C1           CLREG:  pop     BC              ; Save return address
 983+ 197A 2A 27 54             ld      HL,(STRSPC)     ; Get end of working RAM
 984+ 197D F9                   ld      SP,HL           ; Set stack
 985+ 197E 21 39 55             ld      HL,TMSTPL       ; Temporary string pool
 986+ 1981 22 37 55             ld      (TMSTPT),HL     ; Reset temporary string ptr
 987+ 1984 AF                   xor     A               ; A = 00
 988+ 1985 6F                   ld      L,A             ; HL = 0000
 989+ 1986 67                   ld      H,A
 990+ 1987 22 5A 55             ld      (CONTAD),HL     ; No CONTinue
 991+ 198A 32 51 55             ld      (FORFLG),A      ; Clear FOR flag
 992+ 198D 22 CA 55             ld      (FNRGNM),HL     ; Clear FN argument
 993+ 1990 E5                   push    HL              ; HL = 0000
 994+ 1991 C5                   push    BC              ; Put back return
 995+ 1992 2A 54 55     DOAGN:  ld      HL,(BRKLIN)     ; Get address of code to RUN
 996+ 1995 C9                   ret                     ; Return to execution driver
 997+ 1996
 998+ 1996 3E 3F        PROMPT: ld      A,'?'           ; '?'
 999+ 1998 CD 20 1B             call    OUTC            ; Output character
1000+ 199B 3E 00                ld      A,NLLCR         ; null char
1001+ 199D CD 20 1B             call    OUTC            ; Output character
1002+ 19A0 CD 2D 09             call    CURSOR_ON       ; enable cursor
1003+ 19A3 3A BE 55             ld      A,(SERIALS_EN)  ; load serial state
1004+ 19A6 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
1005+ 19A8 CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
1006+ 19AB C3 24 54             jp      RINPUT          ; Get input line
1007+ 19AE
1008+ 19AE AF           CRUNCH: xor     A               ; Tokenise line @ HL to BUFFER
1009+ 19AF 32 0F 55             ld      (DATFLG),A      ; Reset literal flag
1010+ 19B2 0E 05                ld      C,2+3           ; 2 byte number and 3 nulls
1011+ 19B4 11 B2 54             ld      DE,BUFFER       ; Start of input buffer
1012+ 19B7 7E           CRNCLP: ld      A,(HL)          ; Get byte
1013+ 19B8 FE 20                cp      SPC             ; Is it a space?
1014+ 19BA CA 36 1A             jp      Z,MOVDIR        ; Yes - Copy direct
1015+ 19BD 47                   ld      B,A             ; Save character
1016+ 19BE FE 22                cp      $22             ; '"'             ; Is it a quote?
1017+ 19C0 CA 56 1A             jp      Z,CPYLIT        ; Yes - Copy literal string
1018+ 19C3 B7                   or      A               ; Is it end of buffer?
1019+ 19C4 CA 5D 1A             jp      Z,ENDBUF        ; Yes - End buffer
1020+ 19C7 3A 0F 55             ld      A,(DATFLG)      ; Get data type
1021+ 19CA B7                   or      A               ; Literal?
1022+ 19CB 7E                   ld      A,(HL)          ; Get byte to copy
1023+ 19CC C2 36 1A             jp      NZ,MOVDIR       ; Literal - Copy direct
1024+ 19CF FE 3F                cp      '?'             ; Is it '?' short for PRINT
1025+ 19D1 3E B3                ld      A,ZPRINT        ; "PRINT" token
1026+ 19D3 CA 36 1A             jp      Z,MOVDIR        ; Yes - replace it
1027+ 19D6 7E                   ld      A,(HL)          ; Get byte again
1028+ 19D7 FE 30                cp      '0'             ; Is it less than '0'
1029+ 19D9 DA E1 19             jp      C,FNDWRD        ; Yes - Look for reserved words
1030+ 19DC FE 3C                cp      $3C  ;60; ";"+1       ; Is it "0123456789:;" ?
1031+ 19DE DA 36 1A             jp      C,MOVDIR        ; Yes - copy it direct
1032+ 19E1 D5           FNDWRD: push    DE              ; Look for reserved words
1033+ 19E2 11 7A 14             ld      DE,WORDS-1      ; Point to table
1034+ 19E5 C5                   push    BC              ; Save count
1035+ 19E6 01 32 1A             ld      BC,RETNAD       ; Where to return to
1036+ 19E9 C5                   push    BC              ; Save return address
1037+ 19EA 06 7F                ld      B,ZEND-1        ; First token value -1
1038+ 19EC 7E                   ld      A,(HL)          ; Get byte
1039+ 19ED FE 61                cp      'a'             ; Less than 'a' ?
1040+ 19EF DA FA 19             jp      C,SEARCH        ; Yes - search for words
1041+ 19F2 FE 7B                cp      'z'+1           ; Greater than 'z' ?
1042+ 19F4 D2 FA 19             jp      NC,SEARCH       ; Yes - search for words
1043+ 19F7 E6 5F                and     %01011111       ; Force upper case
1044+ 19F9 77                   ld      (HL),A          ; Replace byte
1045+ 19FA 4E           SEARCH: ld      C,(HL)          ; Search for a word
1046+ 19FB EB                   ex      DE,HL
1047+ 19FC 23           GETNXT: inc     HL              ; Get next reserved word
1048+ 19FD B6                   or      (HL)            ; Start of word?
1049+ 19FE F2 FC 19             jp      P,GETNXT        ; No - move on
1050+ 1A01 04                   inc     B               ; Increment token value
1051+ 1A02 7E                   ld      A,(HL)          ; Get byte from table
1052+ 1A03 E6 7F                and     %01111111       ; Strip bit 7
1053+ 1A05 C8                   ret     Z               ; Return if end of list
1054+ 1A06 B9                   cp      C               ; Same character as in buffer?
1055+ 1A07 C2 FC 19             jp      NZ,GETNXT       ; No - get next word
1056+ 1A0A EB                   ex      DE,HL
1057+ 1A0B E5                   push    HL              ; Save start of word
1058+ 1A0C
1059+ 1A0C 13           NXTBYT: inc     DE              ; Look through rest of word
1060+ 1A0D 1A                   ld      A,(DE)          ; Get byte from table
1061+ 1A0E B7                   or      A               ; End of word ?
1062+ 1A0F FA 2E 1A             jp      M,MATCH         ; Yes - Match found
1063+ 1A12 4F                   ld      C,A             ; Save it
1064+ 1A13 78                   ld      A,B             ; Get token value
1065+ 1A14 FE 88                cp      ZGOTO           ; Is it "GOTO" token ?
1066+ 1A16 C2 1D 1A             jp      NZ,NOSPC        ; No - Don't allow spaces
1067+ 1A19 CD 5E 1D             call    GETCHR          ; Get next character
1068+ 1A1C 2B                   dec     HL              ; Cancel increment from GETCHR
1069+ 1A1D 23           NOSPC:  inc     HL              ; Next byte
1070+ 1A1E 7E                   ld      A,(HL)          ; Get byte
1071+ 1A1F FE 61                cp      'a'             ; Less than 'a' ?
1072+ 1A21 DA 26 1A             jp      C,NOCHNG        ; Yes - don't change
1073+ 1A24 E6 5F                and     %01011111       ; Make upper case
1074+ 1A26 B9           NOCHNG: cp      C               ; Same as in buffer ?
1075+ 1A27 CA 0C 1A             jp      Z,NXTBYT        ; Yes - keep testing
1076+ 1A2A E1                   pop     HL              ; Get back start of word
1077+ 1A2B C3 FA 19             jp      SEARCH          ; Look at next word
1078+ 1A2E
1079+ 1A2E 48           MATCH:  ld      C,B             ; Word found - Save token value
1080+ 1A2F F1                   pop     AF              ; Throw away return
1081+ 1A30 EB                   ex      DE,HL
1082+ 1A31 C9                   ret                     ; Return to "RETNAD"
1083+ 1A32 EB           RETNAD: ex      DE,HL           ; Get address in string
1084+ 1A33 79                   ld      A,C             ; Get token value
1085+ 1A34 C1                   pop     BC              ; Restore buffer length
1086+ 1A35 D1                   pop     DE              ; Get destination address
1087+ 1A36 23           MOVDIR: inc     HL              ; Next source in buffer
1088+ 1A37 12                   ld      (DE),A          ; Put byte in buffer
1089+ 1A38 13                   inc     DE              ; Move up buffer
1090+ 1A39 0C                   inc     C               ; Increment length of buffer
1091+ 1A3A D6 3A                sub     ':'             ; End of statement?
1092+ 1A3C CA 44 1A             jp      Z,SETLIT        ; Jump if multi-statement line
1093+ 1A3F FE 49                cp      ZDATA-$3A       ; Is it DATA statement ?
1094+ 1A41 C2 47 1A             jp      NZ,TSTREM       ; No - see if REM
1095+ 1A44 32 0F 55     SETLIT: ld      (DATFLG),A      ; Set literal flag
1096+ 1A47 D6 54        TSTREM: sub     ZREM-$3A        ; Is it REM?
1097+ 1A49 C2 B7 19             jp      NZ,CRNCLP       ; No - Leave flag
1098+ 1A4C 47                   ld      B,A             ; Copy rest of buffer
1099+ 1A4D 7E           NXTCHR: ld      A,(HL)          ; Get byte
1100+ 1A4E B7                   or      A               ; End of line ?
1101+ 1A4F CA 5D 1A             jp      Z,ENDBUF        ; Yes - Terminate buffer
1102+ 1A52 B8                   cp      B               ; End of statement ?
1103+ 1A53 CA 36 1A             jp      Z,MOVDIR        ; Yes - Get next one
1104+ 1A56 23           CPYLIT: inc     HL              ; Move up source string
1105+ 1A57 12                   ld      (DE),A          ; Save in destination
1106+ 1A58 0C                   inc     C               ; Increment length
1107+ 1A59 13                   inc     DE              ; Move up destination
1108+ 1A5A C3 4D 1A             jp      NXTCHR          ; Repeat
1109+ 1A5D
1110+ 1A5D 21 B1 54     ENDBUF: ld      HL,BUFFER-1     ; Point to start of buffer
1111+ 1A60 12                   ld      (DE),A          ; Mark end of buffer (A = 00)
1112+ 1A61 13                   inc     DE
1113+ 1A62 12                   ld      (DE),A          ; A = 00
1114+ 1A63 13                   inc     DE
1115+ 1A64 12                   ld      (DE),A          ; A = 00
1116+ 1A65 C9                   ret
1117+ 1A66
1118+ 1A66 3A 1E 54     DODEL:  ld      A,(NULFLG)      ; Get null flag status
1119+ 1A69 B7                   or      A               ; Is it zero?
1120+ 1A6A 3E 00                ld      A,$00           ; Zero A - Leave flags
1121+ 1A6C 32 1E 54             ld      (NULFLG),A      ; Zero null flag
1122+ 1A6F C2 7A 1A             jp      NZ,ECHDEL       ; Set - Echo it
1123+ 1A72 05                   dec     B               ; Decrement length
1124+ 1A73 CA 97 1A             jp      Z,GETLIN        ; Get line again if empty
1125+ 1A76 CD 20 1B             call    OUTC            ; Output null character
1126+ 1A79 3E                   defb    $3E             ; Skip "dec B"
1127+ 1A7A 05           ECHDEL: dec     B               ; Count bytes in buffer
1128+ 1A7B 2B                   dec     HL              ; Back space buffer
1129+ 1A7C CA 8E 1A             jp      Z,OTKLN         ; No buffer - Try again
1130+ 1A7F 7E                   ld      A,(HL)          ; Get deleted byte
1131+ 1A80 CD 20 1B             call    OUTC            ; Echo it
1132+ 1A83 C3 A0 1A             jp      MORINP          ; Get more input
1133+ 1A86
1134+ 1A86 05           DELCHR: dec     B               ; Count bytes in buffer
1135+ 1A87 2B                   dec     HL              ; Back space buffer
1136+ 1A88 CD 20 1B             call    OUTC            ; Output character in A
1137+ 1A8B C2 A0 1A             jp      NZ,MORINP       ; Not end - Get more
1138+ 1A8E CD 20 1B     OTKLN:  call    OUTC            ; Output character in A
1139+ 1A91 CD 2B 20     KILIN:  call    PRNTCRLF        ; Output CRLF
1140+ 1A94 C3 97 1A             jp      TTYLIN          ; Get line again
1141+ 1A97
1142+ 1A97              GETLIN:
1143+ 1A97 21 B2 54     TTYLIN: ld      HL,BUFFER       ; Get a line by character
1144+ 1A9A 06 01                ld      B,$01           ; Set buffer as empty
1145+ 1A9C AF                   xor     A
1146+ 1A9D 32 1E 54             ld      (NULFLG),A      ; Clear null flag
1147+ 1AA0 CD 61 1B     MORINP: call    CLOTST          ; Get character and test ^O
1148+ 1AA3 4F                   ld      C,A             ; Save character in C
1149+ 1AA4 FE 7F                cp      DEL             ; Delete character?
1150+ 1AA6 CA 66 1A             jp      Z,DODEL         ; Yes - Process it
1151+ 1AA9 3A 1E 54             ld      A,(NULFLG)      ; Get null flag
1152+ 1AAC B7                   or      A               ; Test null flag status
1153+ 1AAD CA B7 1A             jp      Z,PROCES        ; Reset - Process character
1154+ 1AB0 AF                   xor     A               ; Clear A
1155+ 1AB1 32 1E 54             ld      (NULFLG),A      ; Reset null flag
1156+ 1AB4 CD 20 1B             call    OUTC            ; Output null
1157+ 1AB7 79           PROCES: ld      A,C             ; Get character
1158+ 1AB8 FE 07                cp      CTRLG           ; Bell?
1159+ 1ABA CA F7 1A             jp      Z,PUTCTL        ; Yes - Save it
1160+ 1ABD FE 03                cp      CTRLC           ; Is it control "C"?
1161+ 1ABF CC EC 1A             call    Z,GMNCR         ; Yes - exit from graphic mode & Output CRLF
1162+ 1AC2 37                   scf                     ; Flag break
1163+ 1AC3 C8                   ret     Z               ; Return if control "C"
1164+ 1AC4 FE 0D                cp      CR              ; Is it enter?
1165+ 1AC6 CA 21 20             jp      Z,ENDINP        ; Yes - Terminate input
1166+ 1AC9 FE 15                cp      CTRLU           ; Is it control "U"?
1167+ 1ACB CA 91 1A             jp      Z,KILIN         ; Yes - Get another line
1168+ 1ACE FE 08                cp      BKSP            ; Is it backspace?
1169+ 1AD0 CA 86 1A             jp      Z,DELCHR        ; Yes - Delete character
1170+ 1AD3 FE 12                cp      CTRLR           ; Is it control "R"?
1171+ 1AD5 C2 F2 1A             jp      NZ,PUTBUF       ; No - Put in buffer
1172+ 1AD8 C5                   push    BC              ; Save buffer length
1173+ 1AD9 D5                   push    DE              ; Save DE
1174+ 1ADA E5                   push    HL              ; Save buffer address
1175+ 1ADB 36 00                ld      (HL),$00        ; Mark end of buffer
1176+ 1ADD CD 32 41             call    OUTNCR          ; Output and do CRLF
1177+ 1AE0 21 B2 54             ld      HL,BUFFER       ; Point to buffer start
1178+ 1AE3 CD F7 26             call    PRS             ; Output buffer
1179+ 1AE6 E1                   pop     HL              ; Restore buffer address
1180+ 1AE7 D1                   pop     DE              ; Restore DE
1181+ 1AE8 C1                   pop     BC              ; Restore buffer length
1182+ 1AE9 C3 A0 1A             jp      MORINP          ; Get another character
1183+ 1AEC CD F1 17     GMNCR:  call    EXITGM          ; exit from graphic mode
1184+ 1AEF C3 2B 20             jp      PRNTCRLF        ; output CRLF
1185+ 1AF2
1186+ 1AF2 FE 20        PUTBUF: cp      SPC             ; Is it a control code?
1187+ 1AF4 DA A0 1A             jp      C,MORINP        ; Yes - Ignore
1188+ 1AF7 78           PUTCTL: ld      A,B             ; Get number of bytes in buffer
1189+ 1AF8 FE 59                cp      $58+$01         ; Test for line overflow
1190+ 1AFA 3E 08                ld      A,BKSP          ; Set a bell
1191+ 1AFC D2 09 1B             jp      NC,OUTNBS       ; Ring bell if buffer full
1192+ 1AFF 79                   ld      A,C             ; Get character
1193+ 1B00 71                   ld      (HL),C          ; Save in buffer
1194+ 1B01 32 52 55             ld      (LSTBIN),A      ; Save last input byte
1195+ 1B04 23                   inc     HL              ; Move up buffer
1196+ 1B05 04                   inc     B               ; Increment length
1197+ 1B06 C3 A0 1A     OUTIT:  jp      MORINP          ; Get another character
1198+ 1B09
1199+ 1B09 CD 20 1B     OUTNBS: call    OUTC            ; Output bell and back over it
1200+ 1B0C C3 06 1B             jp      OUTIT           ; get more chars
1201+ 1B0F
1202+ 1B0F 7C           CPDEHL: ld      A,H             ; Get H
1203+ 1B10 92                   sub     D               ; Compare with D
1204+ 1B11 C0                   ret     NZ              ; Different - Exit
1205+ 1B12 7D                   ld      A,L             ; Get L
1206+ 1B13 93                   sub     E               ; Compare with E
1207+ 1B14 C9                   ret                     ; Return status
1208+ 1B15
1209+ 1B15 7E           CHKSYN: ld      A,(HL)          ; Check syntax of character
1210+ 1B16 E3                   ex      (SP),HL         ; Address of test byte
1211+ 1B17 BE                   cp      (HL)            ; Same as in code string?
1212+ 1B18 23                   inc     HL              ; Return address
1213+ 1B19 E3                   ex      (SP),HL         ; Put it back
1214+ 1B1A CA 5E 1D             jp      Z,GETCHR        ; Yes - Get next character
1215+ 1B1D C3 17 18             jp      SNERR           ; Different - ?SN Error
1216+ 1B20
1217+ 1B20 F5           OUTC:   push    AF              ; Save character
1218+ 1B21 3A 1F 54             ld      A,(CTLOFG)      ; Get control "O" flag
1219+ 1B24 B7                   or      A               ; Is it set?
1220+ 1B25 C2 2C 27             jp      NZ,POPAF        ; Yes - don't output
1221+ 1B28 F1                   pop     AF              ; Restore character
1222+ 1B29 C5                   push    BC              ; Save buffer length
1223+ 1B2A F5                   push    AF              ; Save character
1224+ 1B2B FE 20                cp      SPC             ; Is it a control code?
1225+ 1B2D DA 44 1B             jp      C,DINPOS        ; Yes - Don't inc POS(X)
1226+ 1B30 3A 1C 54             ld      A,(LWIDTH)      ; Get line width
1227+ 1B33 47                   ld      B,A             ; To B
1228+ 1B34 3A 0C 55             ld      A,(CURPOS)      ; Get cursor position
1229+ 1B37 04                   inc     B               ; Width 255?
1230+ 1B38 CA 40 1B             jp      Z,INCLEN        ; Yes - No width limit
1231+ 1B3B 05                   dec     B               ; Restore width
1232+ 1B3C B8                   cp      B               ; At end of line?
1233+ 1B3D CC 2B 20             call    Z,PRNTCRLF      ; Yes - output CRLF
1234+ 1B40 3C           INCLEN: inc     A               ; Move on one character
1235+ 1B41 32 0C 55             ld      (CURPOS),A      ; Save new position
1236+ 1B44 AF           DINPOS: xor     A
1237+ 1B45 32 B6 55             ld      (KBDNPT),A      ; set flag for no char from keyboard
1238+ 1B48 F1                   pop     AF              ; Restore character
1239+ 1B49 C1                   pop     BC              ; Restore buffer length
1240+ 1B4A F5                   push    AF
1241+ 1B4B CD 53 1B             call    SND2VID         ; send char to video
1242+ 1B4E F1                   pop     AF
1243+ 1B4F CD 0C 41             call    MONOUT          ; send char to serial if enabled
1244+ 1B52 C9                   ret
1245+ 1B53
1246+ 1B53              ; print char to video if cursor is on
1247+ 1B53 32 79 55     SND2VID:ld      (CHR4VID),A     ; store A
1248+ 1B56 3A 78 55             ld      A,(PRNTVIDEO)   ; check print-on-video
1249+ 1B59 B7                   or      A               ; is it off?
1250+ 1B5A C8                   ret     Z               ; yes, so return
1251+ 1B5B F3                   di                      ; disable INTs
1252+ 1B5C CD 61 07             call    CHAR2VID        ; cursor is on, so print char on screen
1253+ 1B5F FB                   ei                      ; re-enable INTs
1254+ 1B60 C9                   ret                     ; return to caller
1255+ 1B61
1256+ 1B61 CD B1 34     CLOTST: call    GETINP          ; Get input character
1257+ 1B64 FE 0F                cp      CTRLO           ; Is it control "O"?
1258+ 1B66 C0                   ret     NZ              ; No don't flip flag
1259+ 1B67 3A 1F 54             ld      A,(CTLOFG)      ; Get flag
1260+ 1B6A 2F                   cpl                     ; Flip it
1261+ 1B6B 32 1F 54             ld      (CTLOFG),A      ; Put it back
1262+ 1B6E A7                   and     A               ; is output enabled?
1263+ 1B6F CC 2D 09             call    Z,CURSOR_ON     ; yes, so cursor on
1264+ 1B72 3A BE 55             ld      A,(SERIALS_EN)  ; load serial state
1265+ 1B75 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
1266+ 1B77 CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
1267+ 1B7A AF                   xor     A               ; Null character
1268+ 1B7B C9                   ret
1269+ 1B7C
1270+ 1B7C              ; LIST: list the program stored into memory
1271+ 1B7C C1           LIST:   pop     BC              ; rubbish - not needed (legacy from original call of LIST)
1272+ 1B7D 2B                   dec     HL              ; dec 'cos GETCHR INCs
1273+ 1B7E CD 5E 1D             call    GETCHR          ; Get next character
1274+ 1B81 CA D7 1B             jp      Z,LSTALL        ; list all if nothing follows
1275+ 1B84 FE C2                cp      ZMINUS          ; is it '-'?
1276+ 1B86 20 20                jr      NZ,LST01        ; no, look for a line number
1277+ 1B88 11 00 00             ld      DE,$0000        ; yes, set search from 0
1278+ 1B8B CD 78 1C             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1279+ 1B8E ED 43 7C 55          ld      (TMPBFR1),BC    ; store address of starting line
1280+ 1B92 CD 15 1B             call    CHKSYN          ; skip '-'
1281+ 1B95 C2                   defb    ZMINUS
1282+ 1B96 CD 2E 1E             call    ATOH            ; now, look for another number (ASCII number to DE)
1283+ 1B99 CD 7E 1C             call    SRCLN           ; find a line, getting the previous if it doesn't exist
1284+ 1B9C ED 43 7E 55          ld      (TMPBFR2),BC    ; store address of ending line
1285+ 1BA0 ED 4B 7C 55          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1286+ 1BA4 C5                   push    BC              ; store address of line for later use
1287+ 1BA5 C3 0F 1C             jp      LISTLP          ; go listing
1288+ 1BA8 CD 2E 1E     LST01:  call    ATOH            ; get a line number (ASCII number to DE)
1289+ 1BAB ED 53 82 55  LST01H: ld      (TMPBFR4),DE    ; store ending line address for later use - N.B.: this is a hook for HELP command
1290+ 1BAF CD 78 1C             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1291+ 1BB2 ED 43 7C 55          ld      (TMPBFR1),BC    ; store address of starting line
1292+ 1BB6 ED 43 7E 55          ld      (TMPBFR2),BC    ; same address for ending line (we'll change it later if needed)
1293+ 1BBA 2B                   dec     HL              ; dec 'cos GETCHR INCs
1294+ 1BBB CD 5E 1D             call    GETCHR          ; Get next character
1295+ 1BBE CA CA 1B             jp      Z,LSTNOT        ; nothing follows, so ending & starting lines are the same
1296+ 1BC1 FE C2                cp      ZMINUS          ; is it '-'?
1297+ 1BC3 CA EF 1B             jp      Z,LST03         ; yes, read ending line
1298+ 1BC6 C5           LST06:  push    BC              ; store address for later use
1299+ 1BC7 C3 0F 1C             jp      LISTLP          ; jump to list
1300+ 1BCA ED 5B 82 55  LSTNOT: ld      DE,(TMPBFR4)
1301+ 1BCE CD 78 1C             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1302+ 1BD1 DA C6 1B             jp      C,LST06
1303+ 1BD4 C3 77 18             jp      PRNTOK
1304+ 1BD7 11 F9 FF     LSTALL: ld      DE,65529        ; set ending line to max. allowed line number
1305+ 1BDA CD 78 1C             call    SRCHLIN         ; get address of last line
1306+ 1BDD ED 43 7E 55          ld      (TMPBFR2),BC    ; store it
1307+ 1BE1 11 00 00             ld      DE,$0000        ; set start to first line in memory
1308+ 1BE4 CD 78 1C             call    SRCHLIN         ; get address of first line
1309+ 1BE7 ED 43 7C 55          ld      (TMPBFR1),BC    ; store it
1310+ 1BEB C5                   push    BC              ; store address of starting line for later use
1311+ 1BEC C3 0F 1C             jp      LISTLP          ; start printing
1312+ 1BEF CD 15 1B     LST03:  call    CHKSYN          ; skip '-'
1313+ 1BF2 C2                   defb    ZMINUS
1314+ 1BF3 CD 2E 1E             call    ATOH            ; look for another number (return into DE)
1315+ 1BF6 7A                   ld      A,D
1316+ 1BF7 B3                   or      E               ; is line=0?
1317+ 1BF8 20 09                jr      NZ,LST05        ; no, jump over
1318+ 1BFA 11 F9 FF             ld      DE,65529        ; yes set last valid line number
1319+ 1BFD CD 78 1C             call    SRCHLIN         ; get address of last line
1320+ 1C00 C3 06 1C             jp      LST02
1321+ 1C03 CD 7E 1C     LST05:  call    SRCLN           ; find a line, getting the previous if it doesn't exist
1322+ 1C06 ED 43 7E 55  LST02:  ld      (TMPBFR2),BC    ; store address of ending line
1323+ 1C0A ED 4B 7C 55          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1324+ 1C0E C5                   push    BC              ; store it for later use
1325+ 1C0F E1           LISTLP: pop     HL              ; Restore address of line
1326+ 1C10 4E                   ld      C,(HL)          ; Get LSB of next line
1327+ 1C11 23                   inc     HL
1328+ 1C12 46                   ld      B,(HL)          ; Get MSB of next line
1329+ 1C13 23                   inc     HL
1330+ 1C14 78                   ld      A,B             ; BC = 0 (End of program)?
1331+ 1C15 B1                   or      C
1332+ 1C16 CA 77 18             jp      Z,PRNTOK        ; Yes - Go to command mode
1333+ 1C19 CD 89 1D             call    TSTBRK          ; Test for break key
1334+ 1C1C CD 8C 1C             call    TSTSPC          ; test for space
1335+ 1C1F C5                   push    BC              ; Save address of next line
1336+ 1C20 3A 71 55             ld      A,(SCR_CURS_X)  ; load current X pos of cursor
1337+ 1C23 A7                   and     A               ; is it at the beginning of a new line?
1338+ 1C24 20 0B                jr      NZ,LST08        ; No, jump over
1339+ 1C26 3E 0D                ld      A,CR            ; yes, so just send a CR
1340+ 1C28 CD 0C 41             call    MONOUT          ; to serial if it's open
1341+ 1C2B AF                   xor     A               ; then, set cursor
1342+ 1C2C 32 0C 55             ld      (CURPOS),A      ; to position 0
1343+ 1C2F 18 03                jr      LST07           ; and continue
1344+ 1C31 CD 2B 20     LST08:  call    PRNTCRLF        ; output CRLF
1345+ 1C34 5E           LST07:  ld      E,(HL)          ; Get LSB of line number
1346+ 1C35 23                   inc     HL
1347+ 1C36 56                   ld      D,(HL)          ; Get MSB of line number
1348+ 1C37 23                   inc     HL
1349+ 1C38 E5                   push    HL              ; Save address of line start
1350+ 1C39 EB                   ex      DE,HL           ; Line number to HL
1351+ 1C3A CD 96 31             call    PRNTHL          ; Output line number in decimal
1352+ 1C3D 3E 20                ld      A,SPC           ; Space after line number
1353+ 1C3F E1                   pop     HL              ; Restore start of line address
1354+ 1C40 CD 20 1B     LSTLP2: call    OUTC            ; Output character in A
1355+ 1C43 7E           LSTLP3: ld      A,(HL)          ; Get next byte in line
1356+ 1C44 B7                   or      A               ; End of line?
1357+ 1C45 23                   inc     HL              ; To next byte in line
1358+ 1C46 CA 6A 1C             jp      Z,NXTLN         ; Yes - check next line
1359+ 1C49 F2 40 1C             jp      P,LSTLP2        ; No token - output it
1360+ 1C4C D6 7F                sub     ZEND-1          ; Find and output word
1361+ 1C4E 4F                   ld      C,A             ; Token offset+1 to C
1362+ 1C4F 11 7B 14             ld      DE,WORDS        ; Reserved word list
1363+ 1C52 1A           FNDTOK: ld      A,(DE)          ; Get character in list
1364+ 1C53 13                   inc     DE              ; Move on to next
1365+ 1C54 B7                   or      A               ; Is it start of word?
1366+ 1C55 F2 52 1C             jp      P,FNDTOK        ; No - Keep looking for word
1367+ 1C58 0D                   dec     C               ; Count words
1368+ 1C59 C2 52 1C             jp      NZ,FNDTOK       ; Not there - keep looking
1369+ 1C5C E6 7F        OUTWRD: and     %01111111       ; Strip bit 7
1370+ 1C5E CD 20 1B             call    OUTC            ; Output character
1371+ 1C61 1A                   ld      A,(DE)          ; Get next character
1372+ 1C62 13                   inc     DE              ; Move on to next
1373+ 1C63 B7                   or      A               ; Is it end of word?
1374+ 1C64 F2 5C 1C             jp      P,OUTWRD        ; No - output the rest
1375+ 1C67 C3 43 1C             jp      LSTLP3          ; Next byte in line
1376+ 1C6A D1           NXTLN:  pop     DE              ; recover address of current line
1377+ 1C6B 2A 7E 55             ld      HL,(TMPBFR2)    ; address of last line to print
1378+ 1C6E CD 38 41             call    CMP16           ; check if current line is over last printable line
1379+ 1C71 DA 77 18             jp      C,PRNTOK        ; finish - leave & print OK
1380+ 1C74 D5                   push    DE              ; store address of current line
1381+ 1C75 C3 0F 1C             jp      LISTLP          ; continue listing
1382+ 1C78              ; look for the address of a program line
1383+ 1C78 E5           SRCHLIN:push    HL              ; store HL (this is needed because HL store the pointer to the input buffer)
1384+ 1C79 CD 33 19             call    SRCHLN          ; search for line number in DE
1385+ 1C7C E1                   pop     HL              ; retrieve HL
1386+ 1C7D C9                   ret                     ; return to caller
1387+ 1C7E              ; look for the address of a program line - if the line isn't found,
1388+ 1C7E              ; it look backward for the previous line
1389+ 1C7E E5           SRCLN:  push    HL              ; store HL
1390+ 1C7F CD 33 19     SRCLN1: call    SRCHLN          ; search for line in DE
1391+ 1C82 DA 8A 1C             jp      C,LVSRLN        ; found it, leave loop
1392+ 1C85 1B                   dec     DE              ; not found, decrement number to look backward for an existing line
1393+ 1C86 7B                   ld      A,E
1394+ 1C87 B2                   or      D               ; is line number zero?
1395+ 1C88 20 F5                jr      NZ,SRCLN1       ; no, continue
1396+ 1C8A E1           LVSRLN: pop     HL              ; retrieve HL
1397+ 1C8B C9                   ret                     ; return to caller
1398+ 1C8C
1399+ 1C8C              ; during LISTing, check if PAUSE is pressed, then pause listing and
1400+ 1C8C              ; wait for another pressing of PAUSE to continue or CTRL-C/BREAK to exit
1401+ 1C8C 3A B8 55     TSTSPC: ld      A,(TMPKEYBFR)   ; Get input character
1402+ 1C8F FE 20                cp      SPC             ; Is it SPACE?
1403+ 1C91 C0                   ret     NZ              ; No, return
1404+ 1C92 CD B1 34     WTSPC:  call    GETINP          ; Yes, stop listing and wait for another space or BREAK
1405+ 1C95 FE 20                cp      SPC             ; is it SPACE?
1406+ 1C97 20 05                jr      NZ,CNTWTSP      ; no, continue
1407+ 1C99 AF                   xor     A
1408+ 1C9A 32 B8 55             ld      (TMPKEYBFR),A   ; reset key
1409+ 1C9D C9                   ret                     ; return to caller
1410+ 1C9E FE 03        CNTWTSP:cp      CTRLC           ; is it CTRL-C/BREAK?
1411+ 1CA0 20 F0                jr      NZ,WTSPC        ; no, loop
1412+ 1CA2 C3 A7 13             jp      BRKRET          ; exit and output "Ok"
1413+ 1CA5
1414+ 1CA5
1415+ 1CA5 3E 64        FOR:    ld      A,$64           ; Flag "FOR" assignment
1416+ 1CA7 32 51 55             ld      (FORFLG),A      ; Save "FOR" flag
1417+ 1CAA CD 1E 1F             call    LET             ; Set up initial index
1418+ 1CAD C1                   pop     BC              ; Drop RETurn address
1419+ 1CAE E5                   push    HL              ; Save code string address
1420+ 1CAF CD 07 1F             call    DATA            ; Get next statement address
1421+ 1CB2 22 4D 55             ld      (LOOPST),HL     ; Save it for start of loop
1422+ 1CB5 21 02 00             ld      HL,$0002        ; Offset for "FOR" block
1423+ 1CB8 39                   add     HL,SP           ; Point to it
1424+ 1CB9 CD A4 17     FORSLP: call    LOKFOR          ; Look for existing "FOR" block
1425+ 1CBC D1                   pop     DE              ; Get code string address
1426+ 1CBD C2 D5 1C             jp      NZ,FORFND       ; No nesting found
1427+ 1CC0 09                   add     HL,BC           ; Move into "FOR" block
1428+ 1CC1 D5                   push    DE              ; Save code string address
1429+ 1CC2 2B                   dec     HL
1430+ 1CC3 56                   ld      D,(HL)          ; Get MSB of loop statement
1431+ 1CC4 2B                   dec     HL
1432+ 1CC5 5E                   ld      E,(HL)          ; Get LSB of loop statement
1433+ 1CC6 23                   inc     HL
1434+ 1CC7 23                   inc     HL
1435+ 1CC8 E5                   push    HL              ; Save block address
1436+ 1CC9 2A 4D 55             ld      HL,(LOOPST)     ; Get address of loop statement
1437+ 1CCC CD 0F 1B             call    CPDEHL          ; Compare the FOR loops
1438+ 1CCF E1                   pop     HL              ; Restore block address
1439+ 1CD0 C2 B9 1C             jp      NZ,FORSLP       ; Different FORs - Find another
1440+ 1CD3 D1                   pop     DE              ; Restore code string address
1441+ 1CD4 F9                   ld      SP,HL           ; Remove all nested loops
1442+ 1CD5
1443+ 1CD5 EB           FORFND: ex      DE,HL           ; Code string address to HL
1444+ 1CD6 0E 08                ld      C,$08
1445+ 1CD8 CD D4 17             call    CHKSTK          ; Check for 8 levels of stack
1446+ 1CDB E5                   push    HL              ; Save code string address
1447+ 1CDC 2A 4D 55             ld      HL,(LOOPST)     ; Get first statement of loop
1448+ 1CDF E3                   ex      (SP),HL         ; Save and restore code string
1449+ 1CE0 E5                   push    HL              ; Re-save code string address
1450+ 1CE1 2A 29 54             ld      HL,(LINEAT)     ; Get current line number
1451+ 1CE4 E3                   ex      (SP),HL         ; Save and restore code string
1452+ 1CE5 CD F2 21             call    TSTNUM          ; Make sure it's a number
1453+ 1CE8 CD 15 1B             call    CHKSYN          ; Make sure "TO" is next
1454+ 1CEB BB                   defb    ZTO             ; "TO" token
1455+ 1CEC CD EF 21             call    GETNUM          ; Get "TO" expression value
1456+ 1CEF E5                   push    HL              ; Save code string address
1457+ 1CF0 CD 48 30             call    BCDEFP          ; Move "TO" value to BCDE
1458+ 1CF3 E1                   pop     HL              ; Restore code string address
1459+ 1CF4 C5                   push    BC              ; Save "TO" value in block
1460+ 1CF5 D5                   push    DE
1461+ 1CF6 01 00 81             ld      BC,$8100        ; BCDE - 1 (default STEP)
1462+ 1CF9 51                   ld      D,C             ; C=0
1463+ 1CFA 5A                   ld      E,D             ; D=0
1464+ 1CFB 7E                   ld      A,(HL)          ; Get next byte in code string
1465+ 1CFC FE C0                cp      ZSTEP           ; See if "STEP" is stated
1466+ 1CFE 3E 01                ld      A,$01           ; Sign of step = 1
1467+ 1D00 C2 11 1D             jp      NZ,SAVSTP       ; No STEP given - Default to 1
1468+ 1D03 CD 5E 1D             call    GETCHR          ; Jump over "STEP" token
1469+ 1D06 CD EF 21             call    GETNUM          ; Get step value
1470+ 1D09 E5                   push    HL              ; Save code string address
1471+ 1D0A CD 48 30             call    BCDEFP          ; Move STEP to BCDE
1472+ 1D0D CD FC 2F             call    TSTSGN          ; Test sign of FPREG
1473+ 1D10 E1                   pop     HL              ; Restore code string address
1474+ 1D11 C5           SAVSTP: push    BC              ; Save the STEP value in block
1475+ 1D12 D5                   push    DE
1476+ 1D13 F5                   push    AF              ; Save sign of STEP
1477+ 1D14 33                   inc     SP              ; Don't save flags
1478+ 1D15 E5                   push    HL              ; Save code string address
1479+ 1D16 2A 54 55             ld      HL,(BRKLIN)     ; Get address of index variable
1480+ 1D19 E3                   ex      (SP),HL         ; Save and restore code string
1481+ 1D1A 06 81        PUTFID: ld      B,ZFOR          ; "FOR" block marker
1482+ 1D1C C5                   push    BC              ; Save it
1483+ 1D1D 33                   inc     SP              ; Don't save C
1484+ 1D1E
1485+ 1D1E CD 89 1D     RUNCNT: call    TSTBRK          ; Execution driver - Test break
1486+ 1D21 22 54 55             ld      (BRKLIN),HL     ; Save code address for break
1487+ 1D24 7E                   ld      A,(HL)          ; Get next byte in code string
1488+ 1D25 FE 3A                cp      ':'             ; Multi statement line?
1489+ 1D27 CA 3E 1D             jp      Z,EXCUTE        ; Yes - Execute it
1490+ 1D2A B7                   or      A               ; End of line?
1491+ 1D2B C2 17 18             jp      NZ,SNERR        ; No - Syntax error
1492+ 1D2E 23                   inc     HL              ; Point to address of next line
1493+ 1D2F 7E                   ld      A,(HL)          ; Get LSB of line pointer
1494+ 1D30 23                   inc     HL
1495+ 1D31 B6                   or      (HL)            ; Is it zero (End of prog)?
1496+ 1D32 CA B0 1D             jp      Z,ENDPRG        ; Yes - Terminate execution
1497+ 1D35 23                   inc     HL              ; Point to line number
1498+ 1D36 5E                   ld      E,(HL)          ; Get LSB of line number
1499+ 1D37 23                   inc     HL
1500+ 1D38 56                   ld      D,(HL)          ; Get MSB of line number
1501+ 1D39 EB                   ex      DE,HL           ; Line number to HL
1502+ 1D3A 22 29 54             ld      (LINEAT),HL     ; Save as current line number
1503+ 1D3D EB                   ex      DE,HL           ; Line number back to DE
1504+ 1D3E CD 5E 1D     EXCUTE: call    GETCHR          ; Get key word
1505+ 1D41 11 1E 1D             ld      DE,RUNCNT       ; Where to RETurn to
1506+ 1D44 D5                   push    DE              ; Save for RETurn
1507+ 1D45 C8           IFJMP:  ret     Z               ; Go to RUNCNT if end of STMT
1508+ 1D46
1509+ 1D46 D6 80        ONJMP:  sub     ZEND            ; Is it a token?
1510+ 1D48 DA 1E 1F             jp      C,LET           ; No - try to assign it
1511+ 1D4B FE 3A                cp      ZNEW+1-ZEND     ; END to NEW ?
1512+ 1D4D D2 17 18             jp      NC,SNERR        ; Not a key word - ?SN Error
1513+ 1D50 07                   rlca                    ; Double it
1514+ 1D51 4F                   ld      C,A             ; BC = Offset into table
1515+ 1D52 06 00                ld      B,0
1516+ 1D54 EB                   ex      DE,HL           ; Save code string address
1517+ 1D55 21 1E 16             ld      HL,WORDTB       ; Keyword address table
1518+ 1D58 09                   add     HL,BC           ; Point to routine address
1519+ 1D59 4E                   ld      C,(HL)          ; Get LSB of routine address
1520+ 1D5A 23                   inc     HL
1521+ 1D5B 46                   ld      B,(HL)          ; Get MSB of routine address
1522+ 1D5C C5                   push    BC              ; Save routine address
1523+ 1D5D EB                   ex      DE,HL           ; Restore code string address
1524+ 1D5E
1525+ 1D5E              ; get a char from input buffer: exit with NC if character found is
1526+ 1D5E              ; not a number; exit with Z if nothing found; char is into A
1527+ 1D5E 23           GETCHR: inc     HL              ; Point to next character
1528+ 1D5F 7E                   ld      A,(HL)          ; Get next code string byte
1529+ 1D60 FE 3A                cp      ':'             ; Z if ':'
1530+ 1D62 D0                   ret     NC              ; NC if > "9"
1531+ 1D63 FE 20                cp      SPC
1532+ 1D65 CA 5E 1D             jp      Z,GETCHR        ; Skip over spaces
1533+ 1D68 FE 30                cp      '0'
1534+ 1D6A 3F                   ccf                     ; NC if < '0'
1535+ 1D6B 3C                   inc     A               ; Test for zero - Leave carry
1536+ 1D6C 3D                   dec     A               ; Z if Null
1537+ 1D6D C9                   ret
1538+ 1D6E
1539+ 1D6E EB           RESTOR: ex      DE,HL           ; Save code string address
1540+ 1D6F 2A AF 54             ld      HL,(BASTXT)     ; Point to start of program
1541+ 1D72 CA 83 1D             jp      Z,RESTNL        ; Just RESTORE - reset pointer
1542+ 1D75 EB                   ex      DE,HL           ; Restore code string address
1543+ 1D76 CD 2E 1E             call    ATOH            ; Get line number to DE
1544+ 1D79 E5                   push    HL              ; Save code string address
1545+ 1D7A CD 33 19             call    SRCHLN          ; Search for line number in DE
1546+ 1D7D 60                   ld      H,B             ; HL = Address of line
1547+ 1D7E 69                   ld      L,C
1548+ 1D7F D1                   pop     DE              ; Restore code string address
1549+ 1D80 D2 DD 1E             jp      NC,ULERR        ; ?UL Error if not found
1550+ 1D83 2B           RESTNL: dec     HL              ; Byte before DATA statement
1551+ 1D84 22 C8 55     UPDATA: ld      (NXTDAT),HL     ; Update DATA pointer
1552+ 1D87 EB                   ex      DE,HL           ; Restore code string address
1553+ 1D88 C9                   ret
1554+ 1D89
1555+ 1D89
1556+ 1D89              ; check if CTRL-C is into input buffer
1557+ 1D89 DF           TSTBRK: rst     $18             ; Check input status
1558+ 1D8A C8                   ret     Z               ; No key, go back
1559+ 1D8B D7                   rst     $10             ; Get the key into A
1560+ 1D8C FE 1B                cp      ESC             ; Escape key?
1561+ 1D8E 28 11                jr      Z,BRK           ; Yes, break
1562+ 1D90 FE 03                cp      CTRLC           ; <Ctrl-C>
1563+ 1D92 28 0D                jr      Z,BRK           ; Yes, break
1564+ 1D94 FE 13                cp      CTRLS           ; Stop scrolling?
1565+ 1D96 C0                   ret     NZ              ; Other key, ignore
1566+ 1D97
1567+ 1D97
1568+ 1D97              ; wait for a key while listing
1569+ 1D97 D7           STALL:  rst     $10             ; Wait for key
1570+ 1D98 FE 11                cp      CTRLQ           ; Resume scrolling?
1571+ 1D9A C8                   ret     Z               ; Release the chokehold
1572+ 1D9B FE 03                cp      CTRLC           ; Second break?
1573+ 1D9D 28 07                jr      Z,STOP          ; Break during hold exits prog
1574+ 1D9F 18 F6                jr      STALL           ; Loop until <Ctrl-Q> or <brk>
1575+ 1DA1
1576+ 1DA1 3E FF        BRK:    ld      A,$FF           ; Set BRKFLG
1577+ 1DA3 32 23 54             ld      (BRKFLG),A      ; Store it
1578+ 1DA6
1579+ 1DA6 C0           STOP:   ret     NZ              ; Exit if anything else
1580+ 1DA7 F6                   defb    $F6             ; Flag "STOP"
1581+ 1DA8 C0           PEND:   ret     NZ              ; Exit if anything else
1582+ 1DA9 22 54 55             ld      (BRKLIN),HL     ; Save point of break
1583+ 1DAC 21                   defb    $21             ; Skip "OR 11111111B"
1584+ 1DAD F6 FF        INPBRK: or      %11111111       ; Flag "Break" wanted
1585+ 1DAF C1                   pop     BC              ; Return not needed and more
1586+ 1DB0 2A 29 54     ENDPRG: ld      HL,(LINEAT)     ; Get current line number
1587+ 1DB3 F5                   push    AF              ; Save STOP / END status
1588+ 1DB4 7D                   ld      A,L             ; Is it direct break?
1589+ 1DB5 A4                   and     H
1590+ 1DB6 3C                   inc     A               ; Line is -1 if direct break
1591+ 1DB7 CA C3 1D             jp      Z,NOLIN         ; Yes - No line number
1592+ 1DBA 22 58 55             ld      (ERRLIN),HL     ; Save line of break
1593+ 1DBD 2A 54 55             ld      HL,(BRKLIN)     ; Get point of break
1594+ 1DC0 22 5A 55             ld      (CONTAD),HL     ; Save point to CONTinue
1595+ 1DC3 AF           NOLIN:  xor     A
1596+ 1DC4 32 1F 54             ld      (CTLOFG),A      ; Enable output
1597+ 1DC7 CD 19 20             call    STTLIN          ; Start a new line
1598+ 1DCA F1                   pop     AF              ; Restore STOP / END status
1599+ 1DCB 21 9A 17             ld      HL,BRKMSG       ; "Break" message
1600+ 1DCE C2 D4 1D             jp      NZ,ERRINT       ; "in line" wanted?
1601+ 1DD1 C3 77 18             jp      PRNTOK          ; Go to command mode
1602+ 1DD4 CD F1 17     ERRINT: call    EXITGM          ; exit from graphics mode
1603+ 1DD7 C3 55 18             jp      ERRIN           ; print message
1604+ 1DDA
1605+ 1DDA
1606+ 1DDA              ; CONTinue after a break/error
1607+ 1DDA 21 FF FF     CONT:   ld      HL,-1           ; reset...
1608+ 1DDD 22 2B 54             ld      (HLPLN),HL      ; ...HELP line register
1609+ 1DE0 2A 5A 55             ld      HL,(CONTAD)     ; Get CONTinue address
1610+ 1DE3 7C                   ld      A,H             ; Is it zero?
1611+ 1DE4 B5                   or      L
1612+ 1DE5 1E 20                ld      E,CN            ; ?CN Error
1613+ 1DE7 CA 31 18             jp      Z,ERROR         ; Yes - output "?CN Error"
1614+ 1DEA EB                   ex      DE,HL           ; Save code string address
1615+ 1DEB 2A 58 55             ld      HL,(ERRLIN)     ; Get line of last break
1616+ 1DEE 22 29 54             ld      (LINEAT),HL     ; Set up current line number
1617+ 1DF1 EB                   ex      DE,HL           ; Restore code string address
1618+ 1DF2 C9                   ret                     ; CONTinue where left off
1619+ 1DF3
1620+ 1DF3 E5           ACCSUM: push    HL              ; Save address in array
1621+ 1DF4 2A 20 54             ld      HL,(CHKSUM)     ; Get check sum
1622+ 1DF7 06 00                ld      B,$00           ; BC - Value of byte
1623+ 1DF9 4F                   ld      C,A
1624+ 1DFA 09                   add     HL,BC           ; Add byte to check sum
1625+ 1DFB 22 20 54             ld      (CHKSUM),HL     ; Re-save check sum
1626+ 1DFE E1                   pop     HL              ; Restore address in array
1627+ 1DFF C9                   ret
1628+ 1E00
1629+ 1E00 7E           CHKLTR: ld      A,(HL)          ; Get byte
1630+ 1E01 FE 41                cp      'A'             ; < 'a' ?
1631+ 1E03 D8                   ret     C               ; Carry set if not letter
1632+ 1E04 FE 5B                cp      'Z'+1           ; > 'z' ?
1633+ 1E06 3F                   ccf
1634+ 1E07 C9                   ret                     ; Carry set if not letter
1635+ 1E08
1636+ 1E08 CD 5E 1D     FPSINT: call    GETCHR          ; Get next character
1637+ 1E0B CD EF 21     POSINT: call    GETNUM          ; Get integer 0 to 32767
1638+ 1E0E CD FC 2F     DEPINT: call    TSTSGN          ; Test sign of FPREG
1639+ 1E11 FA 29 1E             jp      M,FCERR         ; Negative - ?FC Error
1640+ 1E14 3A D3 55     DEINT:  ld      A,(FPEXP)       ; Get integer value to DE
1641+ 1E17 FE 90                cp      $80+$10         ; Exponent in range (16 bits)?
1642+ 1E19 DA A4 30             jp      C,FPINT         ; Yes - convert it
1643+ 1E1C 01 80 90             ld      BC,$9080        ; BCDE = -32768
1644+ 1E1F 11 00 00             ld      DE,$0000
1645+ 1E22 E5                   push    HL              ; Save code string address
1646+ 1E23 CD 77 30             call    CMPNUM          ; Compare FPREG with BCDE
1647+ 1E26 E1                   pop     HL              ; Restore code string address
1648+ 1E27 51                   ld      D,C             ; MSB to D
1649+ 1E28 C8                   ret     Z               ; Return if in range
1650+ 1E29 1E 08        FCERR:  ld      E,FC            ; ?FC Error
1651+ 1E2B C3 31 18             jp      ERROR           ; Output error-
1652+ 1E2E
1653+ 1E2E
1654+ 1E2E              ; convert a number in ASCII chars into an integer and store it into DE
1655+ 1E2E 2B           ATOH:   dec     HL              ; ASCII number to DE binary
1656+ 1E2F 11 00 00     GETLN:  ld      DE,$0000        ; Get number to DE
1657+ 1E32 CD 5E 1D     GTLNLP: call    GETCHR          ; Get next character
1658+ 1E35 D0                   ret     NC              ; Exit if not a digit
1659+ 1E36 E5                   push    HL              ; Save code string address
1660+ 1E37 F5                   push    AF              ; Save digit
1661+ 1E38 21 98 19             ld      HL,65529/10     ; Largest number 65529
1662+ 1E3B CD 0F 1B             call    CPDEHL          ; Number in range?
1663+ 1E3E DA 17 18             jp      C,SNERR         ; No - ?SN Error
1664+ 1E41 62                   ld      H,D             ; HL = Number
1665+ 1E42 6B                   ld      L,E
1666+ 1E43 19                   add     HL,DE           ; Times 2
1667+ 1E44 29                   add     HL,HL           ; Times 4
1668+ 1E45 19                   add     HL,DE           ; Times 5
1669+ 1E46 29                   add     HL,HL           ; Times 10
1670+ 1E47 F1                   pop     AF              ; Restore digit
1671+ 1E48 D6 30                sub     '0'             ; Make it 0 to 9
1672+ 1E4A 5F                   ld      E,A             ; DE = Value of digit
1673+ 1E4B 16 00                ld      D,0
1674+ 1E4D 19                   add     HL,DE           ; Add to number
1675+ 1E4E EB                   ex      DE,HL           ; Number to DE
1676+ 1E4F E1                   pop     HL              ; Restore code string address
1677+ 1E50 C3 32 1E             jp      GTLNLP          ; Go to next character
1678+ 1E53
1679+ 1E53 CA 63 19     CLEAR:  jp      Z,INTVAR        ; Just "CLEAR" Keep parameters
1680+ 1E56 CD EF 21             call    GETNUM          ; Evaluate a number
1681+ 1E59 CD 14 1E             call    DEINT           ; Get integer -32768 to 32767 into DE
1682+ 1E5C 2B                   dec     HL              ; Cancel increment
1683+ 1E5D CD 5E 1D             call    GETCHR          ; Get next character
1684+ 1E60 E5                   push    HL              ; Save code string address
1685+ 1E61 2A 10 55             ld      HL,(LSTRAM)     ; Get end of RAM
1686+ 1E64 CA 7C 1E             jp      Z,STORED        ; No value given - Use stored
1687+ 1E67 E1                   pop     HL              ; Restore code string address
1688+ 1E68 CD 15 1B             call    CHKSYN          ; Check for comma
1689+ 1E6B 2C                   defb    ','
1690+ 1E6C D5                   push    DE              ; Save number
1691+ 1E6D CD EF 21             call    GETNUM          ; Evaluate a number
1692+ 1E70 CD 14 1E             call    DEINT           ; Get integer -32768 to 32767 into DE
1693+ 1E73 2B                   dec     HL              ; Cancel increment
1694+ 1E74 CD 5E 1D             call    GETCHR          ; Get next character
1695+ 1E77 C2 17 18             jp      NZ,SNERR        ; ?SN Error if more on line
1696+ 1E7A E3                   ex      (SP),HL         ; Save code string address
1697+ 1E7B EB                   ex      DE,HL           ; Number to DE
1698+ 1E7C 7D           STORED: ld      A,L             ; Get LSB of new RAM top
1699+ 1E7D 93                   sub     E               ; Subtract LSB of string space
1700+ 1E7E 5F                   ld      E,A             ; Save LSB
1701+ 1E7F 7C                   ld      A,H             ; Get MSB of new RAM top
1702+ 1E80 9A                   sbc     A,D             ; Subtract MSB of string space
1703+ 1E81 57                   ld      D,A             ; Save MSB
1704+ 1E82 DA EC 17             jp      C,OMERR         ; ?OM Error if not enough mem
1705+ 1E85 E5                   push    HL              ; Save RAM top
1706+ 1E86 2A C2 55             ld      HL,(PROGND)     ; Get program end
1707+ 1E89 01 28 00             ld      BC,$28          ; 40 Bytes minimum working RAM
1708+ 1E8C 09                   add     HL,BC           ; Get lowest address
1709+ 1E8D CD 0F 1B             call    CPDEHL          ; Enough memory?
1710+ 1E90 D2 EC 17             jp      NC,OMERR        ; No - ?OM Error
1711+ 1E93 EB                   ex      DE,HL           ; RAM top to HL
1712+ 1E94 22 27 54             ld      (STRSPC),HL     ; Set new string space
1713+ 1E97 E1                   pop     HL              ; End of memory to use
1714+ 1E98 22 10 55             ld      (LSTRAM),HL     ; Set new top of RAM
1715+ 1E9B E1                   pop     HL              ; Restore code string address
1716+ 1E9C C3 63 19             jp      INTVAR          ; Initialise variables
1717+ 1E9F
1718+ 1E9F E5           RUN:    push    HL              ; store HL
1719+ 1EA0 21 FF FF             ld      HL,-1           ; reset...
1720+ 1EA3 22 2B 54             ld      (HLPLN),HL      ; ...HELP line register
1721+ 1EA6 E1                   pop     HL              ; retrieve HL
1722+ 1EA7 CA 5F 19             jp      Z,RUNFST        ; RUN from start if just RUN
1723+ 1EAA CD 63 19             call    INTVAR          ; Initialise variables
1724+ 1EAD 01 1E 1D             ld      BC,RUNCNT       ; Execution driver loop
1725+ 1EB0 C3 C3 1E             jp      RUNLIN          ; RUN from line number
1726+ 1EB3
1727+ 1EB3 0E 03        GOSUB:  ld      C,$03           ; 3 Levels of stack needed
1728+ 1EB5 CD D4 17             call    CHKSTK          ; Check for 3 levels of stack
1729+ 1EB8 C1                   pop     BC              ; Get return address
1730+ 1EB9 E5                   push    HL              ; Save code string for RETURN
1731+ 1EBA E5                   push    HL              ; And for GOSUB routine
1732+ 1EBB 2A 29 54             ld      HL,(LINEAT)     ; Get current line
1733+ 1EBE E3                   ex      (SP),HL         ; Into stack - Code string out
1734+ 1EBF 3E 8C                ld      A,ZGOSUB        ; "GOSUB" token
1735+ 1EC1 F5                   push    AF              ; Save token
1736+ 1EC2 33                   inc     SP              ; Don't save flags
1737+ 1EC3
1738+ 1EC3 C5           RUNLIN: push    BC              ; Save return address
1739+ 1EC4 CD 2E 1E     GOTO:   call    ATOH            ; ASCII number to DE binary
1740+ 1EC7 CD 09 1F             call    REM             ; Get end of line
1741+ 1ECA E5                   push    HL              ; Save end of line
1742+ 1ECB 2A 29 54             ld      HL,(LINEAT)     ; Get current line
1743+ 1ECE CD 0F 1B             call    CPDEHL          ; Line after current?
1744+ 1ED1 E1                   pop     HL              ; Restore end of line
1745+ 1ED2 23                   inc     HL              ; Start of next line
1746+ 1ED3 DC 36 19             call    C,SRCHLP        ; Line is after current line
1747+ 1ED6 D4 33 19             call    NC,SRCHLN       ; Line is before current line
1748+ 1ED9 60                   ld      H,B             ; Set up code string address
1749+ 1EDA 69                   ld      L,C
1750+ 1EDB 2B                   dec     HL              ; Incremented after
1751+ 1EDC D8                   ret     C               ; Line found
1752+ 1EDD 1E 0E        ULERR:  ld      E,UL            ; ?UL Error
1753+ 1EDF C3 31 18             jp      ERROR           ; Output error message
1754+ 1EE2
1755+ 1EE2 C0           RETURN: ret     NZ              ; Return if not just RETURN
1756+ 1EE3 16 FF                ld      D,-1            ; Flag "GOSUB" search
1757+ 1EE5 CD A0 17             call    BAKSTK          ; Look "GOSUB" block
1758+ 1EE8 F9                   ld      SP,HL           ; Kill all FORs in subroutine
1759+ 1EE9 FE 8C                cp      ZGOSUB          ; Test for "GOSUB" token
1760+ 1EEB 1E 04                ld      E,RG            ; ?RG Error
1761+ 1EED C2 31 18             jp      NZ,ERROR        ; Error if no "GOSUB" found
1762+ 1EF0 E1                   pop     HL              ; Get RETURN line number
1763+ 1EF1 22 29 54             ld      (LINEAT),HL     ; Save as current
1764+ 1EF4 23                   inc     HL              ; Was it from direct statement?
1765+ 1EF5 7C                   ld      A,H
1766+ 1EF6 B5                   or      L               ; Return to line
1767+ 1EF7 C2 01 1F             jp      NZ,RETLIN       ; No - Return to line
1768+ 1EFA 3A 52 55             ld      A,(LSTBIN)      ; Any INPUT in subroutine?
1769+ 1EFD B7                   or      A               ; If so buffer is corrupted
1770+ 1EFE C2 76 18             jp      NZ,POPNOK       ; Yes - Go to command mode
1771+ 1F01 21 1E 1D     RETLIN: ld      HL,RUNCNT       ; Execution driver loop
1772+ 1F04 E3                   ex      (SP),HL         ; Into stack - Code string out
1773+ 1F05 3E                   defb    $3E             ; Skip "pop HL"
1774+ 1F06 E1           NXTDTA: pop     HL              ; Restore code string address
1775+ 1F07
1776+ 1F07 01 3A        DATA:   defb    $01,$3A         ; ':' End of statement (stands for LD BC,$0E3A - NOP)
1777+ 1F09 0E 00        REM:    ld      C,$00           ; 00  End of statement
1778+ 1F0B 06 00                ld      B,$00
1779+ 1F0D 79           NXTSTL: ld      A,C             ; Statement and byte
1780+ 1F0E 48                   ld      C,B
1781+ 1F0F 47                   ld      B,A             ; Statement end byte
1782+ 1F10 7E           NXTSTT: ld      A,(HL)          ; Get byte
1783+ 1F11 B7                   or      A               ; End of line?
1784+ 1F12 C8                   ret     Z               ; Yes - Exit
1785+ 1F13 B8                   cp      B               ; End of statement?
1786+ 1F14 C8                   ret     Z               ; Yes - Exit
1787+ 1F15 23                   inc     HL              ; Next byte
1788+ 1F16 FE 22                cp      $22             ; '"'             ; Literal string?
1789+ 1F18 CA 0D 1F             jp      Z,NXTSTL        ; Yes - Look for another '"'
1790+ 1F1B C3 10 1F             jp      NXTSTT          ; Keep looking
1791+ 1F1E
1792+ 1F1E CD FE 23     LET:    call    GETVAR          ; Get variable name
1793+ 1F21 CD 15 1B             call    CHKSYN          ; Make sure "=" follows
1794+ 1F24 CC                   defb    ZEQUAL          ; "=" token
1795+ 1F25 D5                   push    DE              ; Save address of variable
1796+ 1F26 3A 0E 55             ld      A,(TYPE)        ; Get data type
1797+ 1F29 F5                   push    AF              ; Save type
1798+ 1F2A CD 01 22             call    EVAL            ; Evaluate expression
1799+ 1F2D F1                   pop     AF              ; Restore type
1800+ 1F2E E3                   ex      (SP),HL         ; Save code - Get var addr
1801+ 1F2F 22 54 55             ld      (BRKLIN),HL     ; Save address of variable
1802+ 1F32 1F                   rra                     ; Adjust type
1803+ 1F33 CD F4 21             call    CHKTYP          ; Check types are the same
1804+ 1F36 CA 71 1F             jp      Z,LETNUM        ; Numeric - Move value
1805+ 1F39 E5           LETSTR: push    HL              ; Save address of string var
1806+ 1F3A 2A D0 55             ld      HL,(FPREG)      ; Pointer to string entry
1807+ 1F3D E5                   push    HL              ; Save it on stack
1808+ 1F3E 23                   inc     HL              ; Skip over length
1809+ 1F3F 23                   inc     HL
1810+ 1F40 5E                   ld      E,(HL)          ; LSB of string address
1811+ 1F41 23                   inc     HL
1812+ 1F42 56                   ld      D,(HL)          ; MSB of string address
1813+ 1F43 2A AF 54             ld      HL,(BASTXT)     ; Point to start of program
1814+ 1F46 CD 0F 1B             call    CPDEHL          ; Is string before program?
1815+ 1F49 D2 60 1F             jp      NC,CRESTR       ; Yes - Create string entry
1816+ 1F4C 2A 27 54             ld      HL,(STRSPC)     ; Point to string space
1817+ 1F4F CD 0F 1B             call    CPDEHL          ; Is string literal in program?
1818+ 1F52 D1                   pop     DE              ; Restore address of string
1819+ 1F53 D2 68 1F             jp      NC,MVSTPT       ; Yes - Set up pointer
1820+ 1F56 21 45 55             ld      HL,TMPSTR       ; Temporary string pool
1821+ 1F59 CD 0F 1B             call    CPDEHL          ; Is string in temporary pool?
1822+ 1F5C D2 68 1F             jp      NC,MVSTPT       ; No - Set up pointer
1823+ 1F5F 3E                   defb    $3E             ; Skip "pop DE"
1824+ 1F60 D1           CRESTR: pop     DE              ; Restore address of string
1825+ 1F61 CD 58 28             call    BAKTMP          ; Back to last tmp-str entry
1826+ 1F64 EB                   ex      DE,HL           ; Address of string entry
1827+ 1F65 CD 91 26             call    SAVSTR          ; Save string in string area
1828+ 1F68 CD 58 28     MVSTPT: call    BAKTMP          ; Back to last tmp-str entry
1829+ 1F6B E1                   pop     HL              ; Get string pointer
1830+ 1F6C CD 57 30             call    DETHL4          ; Move string pointer to var
1831+ 1F6F E1                   pop     HL              ; Restore code string address
1832+ 1F70 C9                   ret
1833+ 1F71
1834+ 1F71 E5           LETNUM: push    HL              ; Save address of variable
1835+ 1F72 CD 54 30             call    FPTHL           ; Move value to variable
1836+ 1F75 D1                   pop     DE              ; Restore address of variable
1837+ 1F76 E1                   pop     HL              ; Restore code string address
1838+ 1F77 C9                   ret
1839+ 1F78
1840+ 1F78 CD 75 2A     ON:     call    GETINT          ; Get integer 0-255
1841+ 1F7B 7E                   ld      A,(HL)          ; Get "GOTO" or "GOSUB" token
1842+ 1F7C 47                   ld      B,A             ; Save in B
1843+ 1F7D FE 8C                cp      ZGOSUB          ; "GOSUB" token?
1844+ 1F7F CA 87 1F             jp      Z,ONGO          ; Yes - Find line number
1845+ 1F82 CD 15 1B             call    CHKSYN          ; Make sure it's "GOTO"
1846+ 1F85 88                   defb    ZGOTO           ; "GOTO" token
1847+ 1F86 2B                   dec     HL              ; Cancel increment
1848+ 1F87 4B           ONGO:   ld      C,E             ; Integer of branch value
1849+ 1F88 0D           ONGOLP: dec     C               ; Count branches
1850+ 1F89 78                   ld      A,B             ; Get "GOTO" or "GOSUB" token
1851+ 1F8A CA 46 1D             jp      Z,ONJMP         ; Go to that line if right one
1852+ 1F8D CD 2F 1E             call    GETLN           ; Get line number to DE
1853+ 1F90 FE 2C                cp      ','             ; Another line number?
1854+ 1F92 C0                   ret     NZ              ; No - Drop through
1855+ 1F93 C3 88 1F             jp      ONGOLP          ; Yes - loop
1856+ 1F96
1857+ 1F96 CD 01 22     IF:     call    EVAL            ; Evaluate expression
1858+ 1F99 7E                   ld      A,(HL)          ; Get token
1859+ 1F9A FE 88                cp      ZGOTO           ; "GOTO" token?
1860+ 1F9C CA A4 1F             jp      Z,IFGO          ; Yes - Get line
1861+ 1F9F CD 15 1B             call    CHKSYN          ; Make sure it's "THEN"
1862+ 1FA2 BE                   defb    ZTHEN           ; "THEN" token
1863+ 1FA3 2B                   dec     HL              ; Cancel increment
1864+ 1FA4 CD F2 21     IFGO:   call    TSTNUM          ; Make sure it's numeric
1865+ 1FA7 CD FC 2F             call    TSTSGN          ; Test state of expression
1866+ 1FAA CA B6 1F             jp      Z,IF1           ; False - Jump over
1867+ 1FAD CD 5E 1D     IF0:    call    GETCHR          ; Get next character
1868+ 1FB0 DA C4 1E             jp      C,GOTO          ; Number - GOTO that line
1869+ 1FB3 C3 45 1D             jp      IFJMP           ; Otherwise do statement
1870+ 1FB6 0E B2        IF1:    ld      C,ZELSE
1871+ 1FB8 CD 0B 1F             call    REM+2           ; check statement
1872+ 1FBB B7                   or      A               ; end of line?
1873+ 1FBC C8                   ret     Z               ; yes, leave
1874+ 1FBD FE B2                cp      ZELSE
1875+ 1FBF 20 F5                jr      NZ,IF1          ; ELSE not found, continue check
1876+ 1FC1 C3 AD 1F             jp      IF0             ; return to IF
1877+ 1FC4
1878+ 1FC4
1879+ 1FC4 2B           MRPRNT: dec     HL              ; dec 'cos GETCHR INCs
1880+ 1FC5 CD 5E 1D             call    GETCHR          ; Get next character
1881+ 1FC8 CA 2B 20     PRINT:  jp      Z,PRNTCRLF      ; CRLF if just PRINT
1882+ 1FCB C8           PRNTLP: ret     Z               ; End of list - Exit
1883+ 1FCC FE BA                cp      ZTAB            ; "TAB(" token?
1884+ 1FCE CA 53 20             jp      Z,DOTAB         ; Yes - Do TAB routine
1885+ 1FD1 FE BD                cp      ZSPC            ; "SPC(" token?
1886+ 1FD3 CA 53 20             jp      Z,DOTAB         ; Yes - Do SPC routine
1887+ 1FD6 E5                   push    HL              ; Save code string address
1888+ 1FD7 FE 2C                cp      ','             ; Comma?
1889+ 1FD9 CA 3A 20             jp      Z,DOCOM         ; Yes - Move to next zone
1890+ 1FDC FE 3B                cp      ';'             ; Semi-colon?
1891+ 1FDE CA 77 20             jp      Z,NEXITM        ; Do semi-colon routine
1892+ 1FE1 C1                   pop     BC              ; Code string address to BC
1893+ 1FE2 CD 01 22             call    EVAL            ; Evaluate expression
1894+ 1FE5 E5                   push    HL              ; Save code string address
1895+ 1FE6 3A 0E 55             ld      A,(TYPE)        ; Get variable type
1896+ 1FE9 B7                   or      A               ; Is it a string variable?
1897+ 1FEA C2 12 20             jp      NZ,PRNTST       ; Yes - Output string contents
1898+ 1FED CD A1 31             call    NUMASC          ; Convert number to text
1899+ 1FF0 CD B5 26             call    CRTST           ; Create temporary string
1900+ 1FF3 36 00                ld      (HL),NLLCR      ; Followed by a NULL char (was SPC, space)
1901+ 1FF5 2A D0 55             ld      HL,(FPREG)      ; Get length of output
1902+ 1FF8 34                   inc     (HL)            ; Plus 1 for the space
1903+ 1FF9 2A D0 55             ld      HL,(FPREG)      ; < Not needed >
1904+ 1FFC 3A 1C 54             ld      A,(LWIDTH)      ; Get width of line
1905+ 1FFF 47                   ld      B,A             ; To B
1906+ 2000 04                   inc     B               ; Width 255 (No limit)?
1907+ 2001 CA 0E 20             jp      Z,PRNTNB        ; Yes - Output number string
1908+ 2004 04                   inc     B               ; Adjust it
1909+ 2005 3A 0C 55             ld      A,(CURPOS)      ; Get cursor position
1910+ 2008 86                   add     A,(HL)          ; Add length of string
1911+ 2009 3D                   dec     A               ; Adjust it
1912+ 200A B8                   cp      B               ; Will output fit on this line?
1913+ 200B D4 2B 20             call    NC,PRNTCRLF     ; No - CRLF first
1914+ 200E CD FA 26     PRNTNB: call    PRS1            ; Output string at (HL)
1915+ 2011 AF                   xor     A               ; Skip call by setting 'z' flag
1916+ 2012 C4 FA 26     PRNTST: call    NZ,PRS1         ; Output string at (HL)
1917+ 2015 E1                   pop     HL              ; Restore code string address
1918+ 2016 C3 C4 1F             jp      MRPRNT          ; See if more to PRINT
1919+ 2019
1920+ 2019 3A 0C 55     STTLIN: ld      A,(CURPOS)      ; Make sure on new line
1921+ 201C B7                   or      A               ; Already at start?
1922+ 201D C8                   ret     Z               ; Yes - Do nothing
1923+ 201E C3 2B 20             jp      PRNTCRLF        ; Start a new line
1924+ 2021
1925+ 2021 AF           ENDINP: xor     A
1926+ 2022 32 B6 55             ld      (KBDNPT),A      ; char is not from keyboard
1927+ 2025 77                   ld      (HL),A          ; Mark end of buffer
1928+ 2026 21 B1 54             ld      HL,BUFFER-1     ; Point to buffer
1929+ 2029 18 0A                jr      CNTEND
1930+ 202B 3E 0D        PRNTCRLF:ld     A,CR            ; Load a CR
1931+ 202D CD 20 1B             call    OUTC            ; Output character
1932+ 2030 3E 0A                ld      A,LF            ; Load a LF
1933+ 2032 CD 20 1B             call    OUTC            ; Output character
1934+ 2035 AF           CNTEND: xor     A               ; Set to position 0
1935+ 2036 32 0C 55             ld      (CURPOS),A      ; Store it
1936+ 2039 C9                   ret                     ; return to caller
1937+ 203A
1938+ 203A 3A 1D 54     DOCOM:  ld      A,(COMMAN)      ; Get comma width
1939+ 203D 47                   ld      B,A             ; Save in B
1940+ 203E 3A 71 55             ld      A,(SCR_CURS_X)  ; Get current position
1941+ 2041 B8                   cp      B               ; Within the limit?
1942+ 2042 D4 2B 20             call    NC,PRNTCRLF     ; No - output CRLF
1943+ 2045 D2 77 20             jp      NC,NEXITM       ; Get next item
1944+ 2048 D6 0A        ZONELP: sub     $0A             ; Next zone of 10 characters
1945+ 204A D2 48 20             jp      NC,ZONELP       ; Repeat if more zones
1946+ 204D 2F                   cpl                     ; Number of null chars to output
1947+ 204E 0E 00                ld      C,NLLCR         ; null char
1948+ 2050 C3 6D 20             jp      ASPCS           ; Output them
1949+ 2053
1950+ 2053 F5           DOTAB:  push    AF              ; Save token
1951+ 2054 CD 72 2A             call    FNDNUM          ; Evaluate expression
1952+ 2057 CD 15 1B             call    CHKSYN          ; Make sure ")" follows
1953+ 205A 29                   defb    ')'
1954+ 205B 2B                   dec     HL              ; Back space on to ")"
1955+ 205C F1                   pop     AF              ; Restore token
1956+ 205D 0E 00                ld      C,NLLCR         ; for SPC we use NULL char (was SPACE)
1957+ 205F D6 BD                sub     ZSPC            ; Was it "SPC(" ?
1958+ 2061 E5                   push    HL              ; Save code string address
1959+ 2062 CA 68 20             jp      Z,DOSPC         ; Yes - Do 'E' spaces
1960+ 2065 3A 71 55             ld      A,(SCR_CURS_X)  ; Get current X position
1961+ 2068 2F           DOSPC:  cpl                     ; Number of spaces to print to
1962+ 2069 83                   add     A,E             ; Total number to print
1963+ 206A D2 77 20             jp      NC,NEXITM       ; TAB < Current POS(X)
1964+ 206D 3C           ASPCS:  inc     A               ; Output A spaces
1965+ 206E 47                   ld      B,A             ; Save number to print
1966+ 206F 79           SPCLP:  ld      A,C             ; char to print
1967+ 2070 CD 20 1B             call    OUTC            ; Output character in A
1968+ 2073 05                   dec     B               ; Count them
1969+ 2074 C2 6F 20             jp      NZ,SPCLP        ; Repeat if more
1970+ 2077 E1           NEXITM: pop     HL              ; Restore code string address
1971+ 2078 CD 5E 1D             call    GETCHR          ; Get next character
1972+ 207B C3 CB 1F             jp      PRNTLP          ; More to print
1973+ 207E
1974+ 207E 3F 52 65 64  REDO:   defb    "?Redo from start",CR,0
1974+ 2082 6F 20 66 72
1974+ 2086 6F 6D 20 73
1974+ 208A 74 61 72 74
1974+ 208E 0D 00
1975+ 2090
1976+ 2090 3A 53 55     BADINP: ld      A,(READFG)      ; READ or INPUT?
1977+ 2093 B7                   or      A
1978+ 2094 C2 11 18             jp      NZ,DATSNR       ; READ - ?SN Error
1979+ 2097 C1                   pop     BC              ; Throw away code string addr
1980+ 2098 21 7E 20             ld      HL,REDO         ; "Redo from start" message
1981+ 209B CD F7 26             call    PRS             ; Output string
1982+ 209E C3 92 19             jp      DOAGN           ; Do last INPUT again
1983+ 20A1
1984+ 20A1 CD 62 26     INPUT:  call    IDTEST          ; Test for illegal direct
1985+ 20A4 7E                   ld      A,(HL)          ; Get character after "INPUT"
1986+ 20A5 FE 22                cp      $22             ; '"' ; Is there a prompt string?
1987+ 20A7 3E 00                ld      A,$00           ; Clear A and leave flags
1988+ 20A9 32 1F 54             ld      (CTLOFG),A      ; Enable output
1989+ 20AC C2 BB 20             jp      NZ,NOPMPT       ; No prompt - get input
1990+ 20AF CD B6 26             call    QTSTR           ; Get string terminated by '"'
1991+ 20B2 CD 15 1B             call    CHKSYN          ; Check for ';' after prompt
1992+ 20B5 3B                   defb    ";"
1993+ 20B6 E5                   push    HL              ; Save code string address
1994+ 20B7 CD FA 26             call    PRS1            ; Output prompt string
1995+ 20BA 3E                   defb    $3E             ; Skip "push HL"
1996+ 20BB E5           NOPMPT: push    HL              ; Save code string address
1997+ 20BC CD 96 19             call    PROMPT          ; Get input with "? " prompt
1998+ 20BF C1                   pop     BC              ; Restore code string address
1999+ 20C0 DA AD 1D             jp      C,INPBRK        ; Break pressed - Exit
2000+ 20C3 23                   inc     HL              ; Next byte
2001+ 20C4 7E                   ld      A,(HL)          ; Get it
2002+ 20C5 B7                   or      A               ; End of line?
2003+ 20C6 2B                   dec     HL              ; Back again
2004+ 20C7 C5                   push    BC              ; Re-save code string address
2005+ 20C8 3A BE 55             ld      A,(SERIALS_EN)  ; load serial state
2006+ 20CB EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
2007+ 20CD CC 8F 01             call    Z,A_RTS_OFF      ; yes, set RTS on
2008+ 20D0 CD 42 09             call    CURSOR_OFF      ; disable cursor
2009+ 20D3 CA 06 1F             jp      Z,NXTDTA        ; Yes - Find next DATA stmt
2010+ 20D6 36 2C                ld      (HL),','        ; Store comma as separator
2011+ 20D8 C3 E0 20             jp      NXTITM          ; Get next item
2012+ 20DB
2013+ 20DB E5           READ:   push    HL              ; Save code string address
2014+ 20DC 2A C8 55             ld      HL,(NXTDAT)     ; Next DATA statement
2015+ 20DF F6                   defb    $F6             ; Flag "READ"
2016+ 20E0 AF           NXTITM: xor     A               ; Flag "INPUT"
2017+ 20E1 32 53 55             ld      (READFG),A      ; Save "READ"/"INPUT" flag
2018+ 20E4 E3                   ex      (SP),HL         ; Get code str' , Save pointer
2019+ 20E5 C3 EC 20             jp      GTVLUS          ; Get values
2020+ 20E8
2021+ 20E8 CD 15 1B     NEDMOR: call    CHKSYN          ; Check for comma between items
2022+ 20EB 2C                   defb    ','
2023+ 20EC CD FE 23     GTVLUS: call    GETVAR          ; Get variable name
2024+ 20EF E3                   ex      (SP),HL         ; Save code str" , Get pointer
2025+ 20F0 D5                   push    DE              ; Save variable address
2026+ 20F1 7E                   ld      A,(HL)          ; Get next "INPUT"/"DATA" byte
2027+ 20F2 FE 2C                cp      ','             ; Comma?
2028+ 20F4 CA 14 21             jp      Z,ANTVLU        ; Yes - Get another value
2029+ 20F7 3A 53 55             ld      A,(READFG)      ; Is it READ?
2030+ 20FA B7                   or      A
2031+ 20FB C2 80 21             jp      NZ,FDTLP        ; Yes - Find next DATA stmt
2032+ 20FE 3E 3F                ld      A,'?'           ; More INPUT needed
2033+ 2100 CD 20 1B             call    OUTC            ; Output character
2034+ 2103 CD 96 19             call    PROMPT          ; Get INPUT with prompt
2035+ 2106 D1                   pop     DE              ; Variable address
2036+ 2107 C1                   pop     BC              ; Code string address
2037+ 2108 DA AD 1D             jp      C,INPBRK        ; Break pressed
2038+ 210B 23                   inc     HL              ; Point to next DATA byte
2039+ 210C 7E                   ld      A,(HL)          ; Get byte
2040+ 210D B7                   or      A               ; Is it zero (No input) ?
2041+ 210E 2B                   dec     HL              ; Back space INPUT pointer
2042+ 210F C5                   push    BC              ; Save code string address
2043+ 2110 CA 06 1F             jp      Z,NXTDTA        ; Find end of buffer
2044+ 2113 D5                   push    DE              ; Save variable address
2045+ 2114 3A 0E 55     ANTVLU: ld      A,(TYPE)        ; Check data type
2046+ 2117 B7                   or      A               ; Is it numeric?
2047+ 2118 CA 3E 21             jp      Z,INPBIN        ; Yes - Convert to binary
2048+ 211B CD 5E 1D             call    GETCHR          ; Get next character
2049+ 211E 57                   ld      D,A             ; Save input character
2050+ 211F 47                   ld      B,A             ; Again
2051+ 2120 FE 22                cp      $22             ; '"'     ; Start of literal sting?
2052+ 2122 CA 32 21             jp      Z,STRENT        ; Yes - Create string entry
2053+ 2125 3A 53 55             ld      A,(READFG)      ; "READ" or "INPUT" ?
2054+ 2128 B7                   or      A
2055+ 2129 57                   ld      D,A             ; Save 00 if "INPUT"
2056+ 212A CA 2F 21             jp      Z,ITMSEP        ; "INPUT" - End with 00
2057+ 212D 16 3A                ld      D,':'           ; "DATA" - End with 00 or ':'
2058+ 212F 06 2C        ITMSEP: ld      B,','           ; Item separator
2059+ 2131 2B                   dec     HL              ; Back space for DTSTR
2060+ 2132 CD B9 26     STRENT: call    DTSTR           ; Get string terminated by D
2061+ 2135 EB                   ex      DE,HL           ; String address to DE
2062+ 2136 21 49 21             ld      HL,LTSTND       ; Where to go after LETSTR
2063+ 2139 E3                   ex      (SP),HL         ; Save HL , get input pointer
2064+ 213A D5                   push    DE              ; Save address of string
2065+ 213B C3 39 1F             jp      LETSTR          ; Assign string to variable
2066+ 213E
2067+ 213E CD 5E 1D     INPBIN: call    GETCHR          ; Get next character
2068+ 2141 CD 03 31             call    ASCTFP          ; Convert ASCII to FP number
2069+ 2144 E3                   ex      (SP),HL         ; Save input ptr, Get var addr
2070+ 2145 CD 54 30             call    FPTHL           ; Move FPREG to variable
2071+ 2148 E1                   pop     HL              ; Restore input pointer
2072+ 2149 2B           LTSTND: dec     HL              ; dec 'cos GETCHR INCs
2073+ 214A CD 5E 1D             call    GETCHR          ; Get next character
2074+ 214D CA 55 21             jp      Z,MORDT         ; End of line - More needed?
2075+ 2150 FE 2C                cp      ','             ; Another value?
2076+ 2152 C2 90 20             jp      NZ,BADINP       ; No - Bad input
2077+ 2155 E3           MORDT:  ex      (SP),HL         ; Get code string address
2078+ 2156 2B                   dec     HL              ; dec 'cos GETCHR INCs
2079+ 2157 CD 5E 1D             call    GETCHR          ; Get next character
2080+ 215A C2 E8 20             jp      NZ,NEDMOR       ; More needed - Get it
2081+ 215D D1                   pop     DE              ; Restore DATA pointer
2082+ 215E 3A 53 55             ld      A,(READFG)      ; "READ" or "INPUT" ?
2083+ 2161 B7                   or      A
2084+ 2162 EB                   ex      DE,HL           ; DATA pointer to HL
2085+ 2163 C2 84 1D             jp      NZ,UPDATA       ; Update DATA pointer if "READ"
2086+ 2166 D5                   push    DE              ; Save code string address
2087+ 2167 B6                   or      (HL)            ; More input given?
2088+ 2168 21 70 21             ld      HL,EXTIG        ; "?Extra ignored" message
2089+ 216B C4 F7 26             call    NZ,PRS          ; Output string if extra given
2090+ 216E E1                   pop     HL              ; Restore code string address
2091+ 216F C9                   ret
2092+ 2170
2093+ 2170 3F 45 78 74  EXTIG:  defb    "?Extra ignored",CR,0
2093+ 2174 72 61 20 69
2093+ 2178 67 6E 6F 72
2093+ 217C 65 64 0D 00
2094+ 2180
2095+ 2180 CD 07 1F     FDTLP:  call    DATA            ; Get next statement
2096+ 2183 B7                   or      A               ; End of line?
2097+ 2184 C2 99 21             jp      NZ,FANDT        ; No - See if DATA statement
2098+ 2187 23                   inc     HL
2099+ 2188 7E                   ld      A,(HL)          ; End of program?
2100+ 2189 23                   inc     HL
2101+ 218A B6                   or      (HL)            ; 00 00 Ends program
2102+ 218B 1E 06                ld      E,OD            ; ?OD Error
2103+ 218D CA 31 18             jp      Z,ERROR         ; Yes - Out of DATA
2104+ 2190 23                   inc     HL
2105+ 2191 5E                   ld      E,(HL)          ; LSB of line number
2106+ 2192 23                   inc     HL
2107+ 2193 56                   ld      D,(HL)          ; MSB of line number
2108+ 2194 EB                   ex      DE,HL
2109+ 2195 22 4F 55             ld      (DATLIN),HL     ; Set line of current DATA item
2110+ 2198 EB                   ex      DE,HL
2111+ 2199 CD 5E 1D     FANDT:  call    GETCHR          ; Get next character
2112+ 219C FE 83                cp      ZDATA           ; "DATA" token
2113+ 219E C2 80 21             jp      NZ,FDTLP        ; No "DATA" - Keep looking
2114+ 21A1 C3 14 21             jp      ANTVLU          ; Found - Convert input
2115+ 21A4
2116+ 21A4 11 00 00     NEXT:   ld      DE,$0000        ; In case no index given
2117+ 21A7 C4 FE 23     NEXT1:  call    NZ,GETVAR       ; Get index address
2118+ 21AA 22 54 55             ld      (BRKLIN),HL     ; Save code string address
2119+ 21AD CD A0 17             call    BAKSTK          ; Look for "FOR" block
2120+ 21B0 C2 1D 18             jp      NZ,NFERR        ; No "FOR" - ?NF Error
2121+ 21B3 F9                   ld      SP,HL           ; Clear nested loops
2122+ 21B4 D5                   push    DE              ; Save index address
2123+ 21B5 7E                   ld      A,(HL)          ; Get sign of STEP
2124+ 21B6 23                   inc     HL
2125+ 21B7 F5                   push    AF              ; Save sign of STEP
2126+ 21B8 D5                   push    DE              ; Save index address
2127+ 21B9 CD 3A 30             call    PHLTFP          ; Move index value to FPREG
2128+ 21BC E3                   ex      (SP),HL         ; Save address of TO value
2129+ 21BD E5                   push    HL              ; Save address of index
2130+ 21BE CD 56 2D             call    ADDPHL          ; Add STEP to index value
2131+ 21C1 E1                   pop     HL              ; Restore address of index
2132+ 21C2 CD 54 30             call    FPTHL           ; Move value to index variable
2133+ 21C5 E1                   pop     HL              ; Restore address of TO value
2134+ 21C6 CD 4B 30             call    LOADFP          ; Move TO value to BCDE
2135+ 21C9 E5                   push    HL              ; Save address of line of FOR
2136+ 21CA CD 77 30             call    CMPNUM          ; Compare index with TO value
2137+ 21CD E1                   pop     HL              ; Restore address of line num
2138+ 21CE C1                   pop     BC              ; Address of sign of STEP
2139+ 21CF 90                   sub     B               ; Compare with expected sign
2140+ 21D0 CD 4B 30             call    LOADFP          ; BC = Loop stmt,DE = Line num
2141+ 21D3 CA DF 21             jp      Z,KILFOR        ; Loop finished - Terminate it
2142+ 21D6 EB                   ex      DE,HL           ; Loop statement line number
2143+ 21D7 22 29 54             ld      (LINEAT),HL     ; Set loop line number
2144+ 21DA 69                   ld      L,C             ; Set code string to loop
2145+ 21DB 60                   ld      H,B
2146+ 21DC C3 1A 1D             jp      PUTFID          ; Put back "FOR" and continue
2147+ 21DF
2148+ 21DF F9           KILFOR: ld      SP,HL           ; Remove "FOR" block
2149+ 21E0 2A 54 55             ld      HL,(BRKLIN)     ; Code string after "NEXT"
2150+ 21E3 7E                   ld      A,(HL)          ; Get next byte in code string
2151+ 21E4 FE 2C                cp      ','             ; More NEXTs ?
2152+ 21E6 C2 1E 1D             jp      NZ,RUNCNT       ; No - Do next statement
2153+ 21E9 CD 5E 1D             call    GETCHR          ; Position to index name
2154+ 21EC CD A7 21             call    NEXT1           ; Re-enter NEXT routine
2155+ 21EF              ; < will not RETurn to here , Exit to RUNCNT or Loop >
2156+ 21EF
2157+ 21EF CD 01 22     GETNUM: call    EVAL            ; Get a numeric expression
2158+ 21F2 F6           TSTNUM: defb    $F6             ; Clear carry (numeric)
2159+ 21F3 37           TSTSTR: scf                     ; Set carry (string)
2160+ 21F4 3A 0E 55     CHKTYP: ld      A,(TYPE)        ; Check types match
2161+ 21F7 8F                   adc     A,A             ; Expected + actual
2162+ 21F8 B7                   or      A               ; Clear carry , set parity
2163+ 21F9 E8                   ret     PE              ; Even parity - Types match
2164+ 21FA C3 29 18             jp      TMERR           ; Different types - Error
2165+ 21FD
2166+ 21FD CD 15 1B     OPNPAR: call    CHKSYN          ; Make sure "(" follows
2167+ 2200 28                   defb    '('
2168+ 2201 2B           EVAL:   dec     HL              ; Evaluate expression & save
2169+ 2202 16 00                ld      D,$00           ; Precedence value
2170+ 2204 D5           EVAL1:  push    DE              ; Save precedence
2171+ 2205 0E 01                ld      C,$01
2172+ 2207 CD D4 17             call    CHKSTK          ; Check for 1 level of stack
2173+ 220A CD 78 22             call    OPRND           ; Get next expression value
2174+ 220D 22 56 55     EVAL2:  ld      (NXTOPR),HL     ; Save address of next operator
2175+ 2210 2A 56 55     EVAL3:  ld      HL,(NXTOPR)     ; Restore address of next opr
2176+ 2213 C1                   pop     BC              ; Precedence value and operator
2177+ 2214 78                   ld      A,B             ; Get precedence value
2178+ 2215 FE 78                cp      $78             ; "AND", "OR", or "XOR" ?
2179+ 2217 D4 F2 21             call    NC,TSTNUM       ; No - Make sure it's a number
2180+ 221A 7E                   ld      A,(HL)          ; Get next operator / function
2181+ 221B 16 00                ld      D,$00           ; Clear Last relation
2182+ 221D D6 CB        RLTLP:  sub     ZGTR            ; ">" Token
2183+ 221F DA 39 22             jp      C,FOPRND        ; + - * / ^ AND OR XOR - Test it
2184+ 2222 FE 03                cp      ZLTH+1-ZGTR     ; < = >
2185+ 2224 D2 39 22             jp      NC,FOPRND       ; Function - Call it
2186+ 2227 FE 01                cp      ZEQUAL-ZGTR     ; "="
2187+ 2229 17                   rla                     ; <- Test for legal
2188+ 222A AA                   xor     D               ; <- combinations of < = >
2189+ 222B BA                   cp      D               ; <- by combining last token
2190+ 222C 57                   ld      D,A             ; <- with current one
2191+ 222D DA 17 18             jp      C,SNERR         ; Error if "<<' '==" or ">>"
2192+ 2230 22 4B 55             ld      (CUROPR),HL     ; Save address of current token
2193+ 2233 CD 5E 1D             call    GETCHR          ; Get next character
2194+ 2236 C3 1D 22             jp      RLTLP           ; Treat the two as one
2195+ 2239
2196+ 2239 7A           FOPRND: ld      A,D             ; < = > found ?
2197+ 223A B7                   or      A
2198+ 223B C2 79 23             jp      NZ,TSTRED       ; Yes - Test for reduction
2199+ 223E 7E                   ld      A,(HL)          ; Get operator token
2200+ 223F 22 4B 55             ld      (CUROPR),HL     ; Save operator address
2201+ 2242 D6 C1                sub     ZPLUS           ; Operator or function?
2202+ 2244 D8                   ret     C               ; Neither - Exit
2203+ 2245 FE 0A                cp      ZOR+1-ZPLUS     ; Is it + - * / ^ AND XOR OR ?
2204+ 2247 D0                   ret     NC              ; No - Exit
2205+ 2248 5F                   ld      E,A             ; Coded operator
2206+ 2249 3A 0E 55             ld      A,(TYPE)        ; Get data type
2207+ 224C 3D                   dec     A               ; FF = numeric , 00 = string
2208+ 224D B3                   or      E               ; Combine with coded operator
2209+ 224E 7B                   ld      A,E             ; Get coded operator
2210+ 224F CA ED 27             jp      Z,CONCAT        ; String concatenation
2211+ 2252 07                   rlca                    ; Times 2
2212+ 2253 83                   add     A,E             ; Times 3
2213+ 2254 5F                   ld      E,A             ; To DE (D is 0)
2214+ 2255 21 92 16             ld      HL,PRITAB       ; Precedence table
2215+ 2258 19                   add     HL,DE           ; To the operator concerned
2216+ 2259 78                   ld      A,B             ; Last operator precedence
2217+ 225A 56                   ld      D,(HL)          ; Get evaluation precedence
2218+ 225B BA                   cp      D               ; Compare with eval precedence
2219+ 225C D0                   ret     NC              ; Exit if higher precedence
2220+ 225D 23                   inc     HL              ; Point to routine address
2221+ 225E CD F2 21             call    TSTNUM          ; Make sure it's a number
2222+ 2261
2223+ 2261 C5           STKTHS: push    BC              ; Save last precedence & token
2224+ 2262 01 10 22             ld      BC,EVAL3        ; Where to go on prec' break
2225+ 2265 C5                   push    BC              ; Save on stack for return
2226+ 2266 43                   ld      B,E             ; Save operator
2227+ 2267 4A                   ld      C,D             ; Save precedence
2228+ 2268 CD 2D 30             call    STAKFP          ; Move value to stack
2229+ 226B 58                   ld      E,B             ; Restore operator
2230+ 226C 51                   ld      D,C             ; Restore precedence
2231+ 226D 4E                   ld      C,(HL)          ; Get LSB of routine address
2232+ 226E 23                   inc     HL
2233+ 226F 46                   ld      B,(HL)          ; Get MSB of routine address
2234+ 2270 23                   inc     HL
2235+ 2271 C5                   push    BC              ; Save routine address
2236+ 2272 2A 4B 55             ld      HL,(CUROPR)     ; Address of current operator
2237+ 2275 C3 04 22             jp      EVAL1           ; Loop until prec' break
2238+ 2278
2239+ 2278 AF           OPRND:  xor     A               ; Get operand routine
2240+ 2279 32 0E 55             ld      (TYPE),A        ; Set numeric expected
2241+ 227C CD 5E 1D             call    GETCHR          ; Get next character
2242+ 227F 1E 24                ld      E,MO            ; ?MO Error
2243+ 2281 CA 31 18             jp      Z,ERROR         ; No operand - Error
2244+ 2284 DA 03 31             jp      C,ASCTFP        ; Number - Get value
2245+ 2287 CD 00 1E             call    CHKLTR          ; See if a letter
2246+ 228A D2 DF 22             jp      NC,CONVAR       ; Letter - Find variable
2247+ 228D FE 26                cp      '&'             ; &H = HEX, &B = BINARY
2248+ 228F 20 12                jr      NZ,NOTAMP
2249+ 2291 CD 5E 1D             call    GETCHR          ; Get next character
2250+ 2294 FE 48                cp      'H'             ; Hex number indicated? [function added]
2251+ 2296 CA 6C 40             jp      Z,HEXTFP        ; Convert Hex to FPREG
2252+ 2299 FE 42                cp      'B'             ; Binary number indicated? [function added]
2253+ 229B CA DC 40             jp      Z,BINTFP        ; Convert Bin to FPREG
2254+ 229E 1E 02                ld      E,SN            ; If neither then a ?SN Error
2255+ 22A0 CA 31 18             jp      Z,ERROR         ;
2256+ 22A3 FE C1        NOTAMP: cp      ZPLUS           ; '+' Token ?
2257+ 22A5 CA 78 22             jp      Z,OPRND         ; Yes - Look for operand
2258+ 22A8 FE 2E                cp      '.'             ; '.' ?
2259+ 22AA CA 03 31             jp      Z,ASCTFP        ; Yes - Create FP number
2260+ 22AD FE C2                cp      ZMINUS          ; '-' Token ?
2261+ 22AF CA CE 22             jp      Z,MINUS         ; Yes - Do minus
2262+ 22B2 FE 22                cp      $22             ; '"'             ; Literal string ?
2263+ 22B4 CA B6 26             jp      Z,QTSTR         ; Get string terminated by '"'
2264+ 22B7 FE BF                cp      ZNOT            ; "NOT" Token ?
2265+ 22B9 CA D9 23             jp      Z,EVNOT         ; Yes - Eval NOT expression
2266+ 22BC FE BC                cp      ZFN             ; "FN" Token ?
2267+ 22BE CA 1A 26             jp      Z,DOFN          ; Yes - Do FN routine
2268+ 22C1 D6 CE                sub     ZSGN            ; Is it a function?
2269+ 22C3 D2 F0 22             jp      NC,FNOFST       ; Yes - Evaluate function
2270+ 22C6 CD FD 21     EVLPAR: call    OPNPAR          ; Evaluate expression in "()"
2271+ 22C9 CD 15 1B             call    CHKSYN          ; Make sure ")" follows
2272+ 22CC 29                   defb    ')'
2273+ 22CD C9                   ret
2274+ 22CE
2275+ 22CE 16 7D        MINUS:  ld      D,$7D           ; '-' precedence
2276+ 22D0 CD 04 22             call    EVAL1           ; Evaluate until prec' break
2277+ 22D3 2A 56 55             ld      HL,(NXTOPR)     ; Get next operator address
2278+ 22D6 E5                   push    HL              ; Save next operator address
2279+ 22D7 CD 25 30             call    INVSGN          ; Negate value
2280+ 22DA CD F2 21     RETNUM: call    TSTNUM          ; Make sure it's a number
2281+ 22DD E1                   pop     HL              ; Restore next operator address
2282+ 22DE C9                   ret
2283+ 22DF
2284+ 22DF CD FE 23     CONVAR: call    GETVAR          ; Get variable address to DE
2285+ 22E2 E5           FRMEVL: push    HL              ; Save code string address
2286+ 22E3 EB                   ex      DE,HL           ; Variable address to HL
2287+ 22E4 22 D0 55             ld      (FPREG),HL      ; Save address of variable
2288+ 22E7 3A 0E 55             ld      A,(TYPE)        ; Get type
2289+ 22EA B7                   or      A               ; Numeric?
2290+ 22EB CC 3A 30             call    Z,PHLTFP        ; Yes - Move contents to FPREG
2291+ 22EE E1                   pop     HL              ; Restore code string address
2292+ 22EF C9                   ret
2293+ 22F0
2294+ 22F0 06 00        FNOFST: ld      B,$00           ; Get address of function
2295+ 22F2 07                   rlca                    ; Double function offset
2296+ 22F3 4F                   ld      C,A             ; BC = Offset in function table
2297+ 22F4 C5                   push    BC              ; Save adjusted token value
2298+ 22F5 CD 5E 1D             call    GETCHR          ; Get next character
2299+ 22F8 79                   ld      A,C             ; Get adjusted token value
2300+ 22F9 FE 2C                cp      2*(ZPOINT-ZSGN) ; "POINT" token?
2301+ 22FB CA 26 38             jp      Z,POINT         ; Yes, do "POINT"
2302+ 22FE FE 2E                cp      2*(ZINSTR-ZSGN) ; "INSTR" token?
2303+ 2300 CA C9 28             jp      Z,INSTR         ; Yes, do "INSTR"
2304+ 2303 FE 41                cp      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
2305+ 2305 DA 21 23             jp      C,FNVAL         ; No - Do function
2306+ 2308 CD FD 21             call    OPNPAR          ; Evaluate expression  (X,...
2307+ 230B CD 15 1B             call    CHKSYN          ; Make sure ',' follows
2308+ 230E 2C                   defb    ','
2309+ 230F CD F3 21             call    TSTSTR          ; Make sure it's a string
2310+ 2312 EB                   ex      DE,HL           ; Save code string address
2311+ 2313 2A D0 55             ld      HL,(FPREG)      ; Get address of string
2312+ 2316 E3                   ex      (SP),HL         ; Save address of string
2313+ 2317 E5                   push    HL              ; Save adjusted token value
2314+ 2318 EB                   ex      DE,HL           ; Restore code string address
2315+ 2319 CD 75 2A             call    GETINT          ; Get integer 0-255
2316+ 231C EB                   ex      DE,HL           ; Save code string address
2317+ 231D E3                   ex      (SP),HL         ; Save integer,HL = adj' token
2318+ 231E C3 29 23             jp      GOFUNC          ; Jump to string function
2319+ 2321
2320+ 2321 CD C6 22     FNVAL:  call    EVLPAR          ; Evaluate expression
2321+ 2324 E3                   ex      (SP),HL         ; HL = Adjusted token value
2322+ 2325 11 DA 22             ld      DE,RETNUM       ; Return number from function
2323+ 2328 D5                   push    DE              ; Save on stack
2324+ 2329 01 33 14     GOFUNC: ld      BC,FNCTAB       ; Function routine addresses
2325+ 232C 09                   add     HL,BC           ; Point to right address
2326+ 232D 4E                   ld      C,(HL)          ; Get LSB of address
2327+ 232E 23                   inc     HL              ;
2328+ 232F 66                   ld      H,(HL)          ; Get MSB of address
2329+ 2330 69                   ld      L,C             ; Address to HL
2330+ 2331 E9                   jp      (HL)            ; Jump to function
2331+ 2332
2332+ 2332 15           SGNEXP: dec     D               ; Dee to flag negative exponent
2333+ 2333 FE C2                cp      ZMINUS          ; '-' token ?
2334+ 2335 C8                   ret     Z               ; Yes - Return
2335+ 2336 FE 2D                cp      '-'             ; '-' ASCII ?
2336+ 2338 C8                   ret     Z               ; Yes - Return
2337+ 2339 14                   inc     D               ; Inc to flag positive exponent
2338+ 233A FE 2B                cp      '+'             ; '+' ASCII ?
2339+ 233C C8                   ret     Z               ; Yes - Return
2340+ 233D FE C1                cp      ZPLUS           ; '+' token ?
2341+ 233F C8                   ret     Z               ; Yes - Return
2342+ 2340 2B                   dec     HL              ; dec 'cos GETCHR INCs
2343+ 2341 C9                   ret                     ; Return "NZ"
2344+ 2342
2345+ 2342              ; execute OR, AND, and XOR operations
2346+ 2342 AF           PAND:   xor     A               ; for AND, Z=1
2347+ 2343 18 07                jr      CNTLGC
2348+ 2345 AF           POR:    xor     A               ; for OR, Z=0, S=1
2349+ 2346 D6 01                sub     $01
2350+ 2348 18 02                jr      CNTLGC
2351+ 234A AF           PXOR:   xor     A               ; for XOR, Z=0, S=0
2352+ 234B 3C                   inc     A
2353+ 234C F5           CNTLGC: push    AF              ; store operand's flags
2354+ 234D CD F2 21             call    TSTNUM          ; Make sure it's a number
2355+ 2350 CD 14 1E             call    DEINT           ; Get integer -32768 to 32767
2356+ 2353 F1                   pop     AF              ; retrieve operand's flags
2357+ 2354 EB                   ex      DE,HL           ; <- Get last
2358+ 2355 C1                   pop     BC              ; <-  value
2359+ 2356 E3                   ex      (SP),HL         ; <-  from
2360+ 2357 EB                   ex      DE,HL           ; <-  stack
2361+ 2358 CD 3D 30             call    FPBCDE          ; Move last value to FPREG
2362+ 235B F5                   push    AF              ; store operand's flags
2363+ 235C CD 14 1E             call    DEINT           ; Get integer -32768 to 32767
2364+ 235F F1                   pop     AF              ; retrieve operand's flags
2365+ 2360 C1                   pop     BC              ; Get value
2366+ 2361 79                   ld      A,C             ; Get LSB
2367+ 2362 21 D8 25             ld      HL,ACPASS       ; Address of save AC as current
2368+ 2365 20 05                jr      NZ,POR1         ; if X/OR, jump over
2369+ 2367 A3           PAND1:  and     E               ; "AND" LSBs
2370+ 2368 4F                   ld      C,A             ; Save LSB
2371+ 2369 78                   ld      A,B             ; Get MSB
2372+ 236A A2                   and     D               ; "AND" MSBs
2373+ 236B E9                   jp      (HL)            ; Save AC as current (ACPASS)
2374+ 236C F2 74 23     POR1:   jp      P,PXOR1         ; if S=0, jump to XOR
2375+ 236F B3                   or      E               ; "OR" LSBs
2376+ 2370 4F                   ld      C,A             ; Save LSB
2377+ 2371 78                   ld      A,B             ; Get MSB
2378+ 2372 B2                   or      D               ; "OR" MSBs
2379+ 2373 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2380+ 2374 AB           PXOR1:  xor     E               ; "XOR" LSBs
2381+ 2375 4F                   ld      C,A             ; Save LSB
2382+ 2376 78                   ld      A,B             ; Get MSB
2383+ 2377 AA                   xor     D               ; "XOR" MSBs
2384+ 2378 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2385+ 2379
2386+ 2379 21 8B 23     TSTRED: ld      HL,CMPLOG       ; Logical compare routine
2387+ 237C 3A 0E 55             ld      A,(TYPE)        ; Get data type
2388+ 237F 1F                   rra                     ; Carry set = string
2389+ 2380 7A                   ld      A,D             ; Get last precedence value
2390+ 2381 17                   rla                     ; Times 2 plus carry
2391+ 2382 5F                   ld      E,A             ; To E
2392+ 2383 16 64                ld      D,$64           ; Relational precedence
2393+ 2385 78                   ld      A,B             ; Get current precedence
2394+ 2386 BA                   cp      D               ; Compare with last
2395+ 2387 D0                   ret     NC              ; Eval if last was rel' or log'
2396+ 2388 C3 61 22             jp      STKTHS          ; Stack this one and get next
2397+ 238B
2398+ 238B 8D 23        CMPLOG: defw    CMPLG1          ; Compare two values / strings
2399+ 238D 79           CMPLG1: ld      A,C             ; Get data type
2400+ 238E B7                   or      A
2401+ 238F 1F                   rra
2402+ 2390 C1                   pop     BC              ; Get last expression to BCDE
2403+ 2391 D1                   pop     DE
2404+ 2392 F5                   push    AF              ; Save status
2405+ 2393 CD F4 21             call    CHKTYP          ; Check that types match
2406+ 2396 21 CF 23             ld      HL,CMPRES       ; Result to comparison
2407+ 2399 E5                   push    HL              ; Save for RETurn
2408+ 239A CA 77 30             jp      Z,CMPNUM        ; Compare values if numeric
2409+ 239D AF                   xor     A               ; Compare two strings
2410+ 239E 32 0E 55             ld      (TYPE),A        ; Set type to numeric
2411+ 23A1 D5                   push    DE              ; Save string name
2412+ 23A2 CD 3A 28             call    GSTRCU          ; Get current string
2413+ 23A5 7E                   ld      A,(HL)          ; Get length of string
2414+ 23A6 23                   inc     HL
2415+ 23A7 23                   inc     HL
2416+ 23A8 4E                   ld      C,(HL)          ; Get LSB of address
2417+ 23A9 23                   inc     HL
2418+ 23AA 46                   ld      B,(HL)          ; Get MSB of address
2419+ 23AB D1                   pop     DE              ; Restore string name
2420+ 23AC C5                   push    BC              ; Save address of string
2421+ 23AD F5                   push    AF              ; Save length of string
2422+ 23AE CD 3E 28             call    GSTRDE          ; Get second string
2423+ 23B1 CD 4B 30             call    LOADFP          ; Get address of second string
2424+ 23B4 F1                   pop     AF              ; Restore length of string 1
2425+ 23B5 57                   ld      D,A             ; Length to D
2426+ 23B6 E1                   pop     HL              ; Restore address of string 1
2427+ 23B7 7B           CMPSTR: ld      A,E             ; Bytes of string 2 to do
2428+ 23B8 B2                   or      D               ; Bytes of string 1 to do
2429+ 23B9 C8                   ret     Z               ; Exit if all bytes compared
2430+ 23BA 7A                   ld      A,D             ; Get bytes of string 1 to do
2431+ 23BB D6 01                sub     $01
2432+ 23BD D8                   ret     C               ; Exit if end of string 1
2433+ 23BE AF                   xor     A
2434+ 23BF BB                   cp      E               ; Bytes of string 2 to do
2435+ 23C0 3C                   inc     A
2436+ 23C1 D0                   ret     NC              ; Exit if end of string 2
2437+ 23C2 15                   dec     D               ; Count bytes in string 1
2438+ 23C3 1D                   dec     E               ; Count bytes in string 2
2439+ 23C4 0A                   ld      A,(BC)          ; Byte in string 2
2440+ 23C5 BE                   cp      (HL)            ; Compare to byte in string 1
2441+ 23C6 23                   inc     HL              ; Move up string 1
2442+ 23C7 03                   inc     BC              ; Move up string 2
2443+ 23C8 CA B7 23             jp      Z,CMPSTR        ; Same - Try next bytes
2444+ 23CB 3F                   ccf                     ; Flag difference (">" or "<")
2445+ 23CC C3 07 30             jp      FLGDIF          ; "<" gives -1 , ">" gives +1
2446+ 23CF
2447+ 23CF 3C           CMPRES: inc     A               ; Increment current value
2448+ 23D0 8F                   adc     A,A             ; Double plus carry
2449+ 23D1 C1                   pop     BC              ; Get other value
2450+ 23D2 A0                   and     B               ; Combine them
2451+ 23D3 C6 FF                add     A,-1            ; Carry set if different
2452+ 23D5 9F                   sbc     A,A             ; 00 - Equal , FF - Different
2453+ 23D6 C3 0E 30             jp      FLGREL          ; Set current value & continue
2454+ 23D9
2455+ 23D9 16 5A        EVNOT:  ld      D,$5A           ; Precedence value for "NOT"
2456+ 23DB CD 04 22             call    EVAL1           ; Eval until precedence break
2457+ 23DE CD F2 21             call    TSTNUM          ; Make sure it's a number
2458+ 23E1 CD 14 1E             call    DEINT           ; Get integer -32768 - 32767
2459+ 23E4 7B                   ld      A,E             ; Get LSB
2460+ 23E5 2F                   cpl                     ; Invert LSB
2461+ 23E6 4F                   ld      C,A             ; Save "NOT" of LSB
2462+ 23E7 7A                   ld      A,D             ; Get MSB
2463+ 23E8 2F                   cpl                     ; Invert MSB
2464+ 23E9 CD D8 25             call    ACPASS          ; Save AC as current
2465+ 23EC C1                   pop     BC              ; Clean up stack
2466+ 23ED C3 10 22             jp      EVAL3           ; Continue evaluation
2467+ 23F0
2468+ 23F0 2B           DIMRET: dec     HL              ; dec 'cos GETCHR INCs
2469+ 23F1 CD 5E 1D             call    GETCHR          ; Get next character
2470+ 23F4 C8                   ret     Z               ; End of DIM statement
2471+ 23F5 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
2472+ 23F8 2C                   defb    ','
2473+ 23F9 01 F0 23     DIM:    ld      BC,DIMRET       ; Return to "DIMRET"
2474+ 23FC C5                   push    BC              ; Save on stack
2475+ 23FD F6                   defb    $F6             ; Flag "Create" variable
2476+ 23FE AF           GETVAR: xor     A               ; Find variable address,to DE
2477+ 23FF 32 0D 55             ld      (LCRFLG),A      ; Set locate / create flag
2478+ 2402 46                   ld      B,(HL)          ; Get First byte of name
2479+ 2403 CD 00 1E     GTFNAM: call    CHKLTR          ; See if a letter
2480+ 2406 DA 17 18             jp      C,SNERR         ; ?SN Error if not a letter
2481+ 2409 AF                   xor     A
2482+ 240A 4F                   ld      C,A             ; Clear second byte of name
2483+ 240B 32 0E 55             ld      (TYPE),A        ; Set type to numeric
2484+ 240E CD 5E 1D             call    GETCHR          ; Get next character
2485+ 2411 DA 1A 24             jp      C,SVNAM2        ; Numeric - Save in name
2486+ 2414 CD 00 1E             call    CHKLTR          ; See if a letter
2487+ 2417 DA 27 24             jp      C,CHARTY        ; Not a letter - Check type
2488+ 241A 4F           SVNAM2: ld      C,A             ; Save second byte of name
2489+ 241B CD 5E 1D     ENDNAM: call    GETCHR          ; Get next character
2490+ 241E DA 1B 24             jp      C,ENDNAM        ; Numeric - Get another
2491+ 2421 CD 00 1E             call    CHKLTR          ; See if a letter
2492+ 2424 D2 1B 24             jp      NC,ENDNAM       ; Letter - Get another
2493+ 2427 D6 24        CHARTY: sub     '$'             ; String variable?
2494+ 2429 C2 36 24             jp      NZ,NOTSTR       ; No - Numeric variable
2495+ 242C 3C                   inc     A               ; A = 1 (string type)
2496+ 242D 32 0E 55             ld      (TYPE),A        ; Set type to string
2497+ 2430 0F                   rrca                    ; A = 80H , Flag for string
2498+ 2431 81                   add     A,C             ; 2nd byte of name has bit 7 on
2499+ 2432 4F                   ld      C,A             ; Resave second byte on name
2500+ 2433 CD 5E 1D             call    GETCHR          ; Get next character
2501+ 2436 3A 51 55     NOTSTR: ld      A,(FORFLG)      ; Array name needed ?
2502+ 2439 3D                   dec     A
2503+ 243A CA E3 24             jp      Z,ARLDSV        ; Yes - Get array name
2504+ 243D F2 46 24             jp      P,NSCFOR        ; No array with "FOR" or "FN"
2505+ 2440 7E                   ld      A,(HL)          ; Get byte again
2506+ 2441 D6 28                sub     '('             ; Subscripted variable?
2507+ 2443 CA BB 24             jp      Z,SBSCPT        ; Yes - Sort out subscript
2508+ 2446
2509+ 2446 AF           NSCFOR: xor     A               ; Simple variable
2510+ 2447 32 51 55             ld      (FORFLG),A      ; Clear "FOR" flag
2511+ 244A E5                   push    HL              ; Save code string address
2512+ 244B 50                   ld      D,B             ; DE = Variable name to find
2513+ 244C 59                   ld      E,C
2514+ 244D 2A CA 55             ld      HL,(FNRGNM)     ; FN argument name
2515+ 2450 CD 0F 1B             call    CPDEHL          ; Is it the FN argument?
2516+ 2453 11 CC 55             ld      DE,FNARG        ; Point to argument value
2517+ 2456 CA EC 2E             jp      Z,POPHRT        ; Yes - Return FN argument value
2518+ 2459 2A C4 55             ld      HL,(VAREND)     ; End of variables
2519+ 245C EB                   ex      DE,HL           ; Address of end of search
2520+ 245D 2A C2 55             ld      HL,(PROGND)     ; Start of variables address
2521+ 2460 CD 0F 1B     FNDVAR: call    CPDEHL          ; End of variable list table?
2522+ 2463 CA 79 24             jp      Z,CFEVAL        ; Yes - Called from EVAL?
2523+ 2466 79                   ld      A,C             ; Get second byte of name
2524+ 2467 96                   sub     (HL)            ; Compare with name in list
2525+ 2468 23                   inc     HL              ; Move on to first byte
2526+ 2469 C2 6E 24             jp      NZ,FNTHR        ; Different - Find another
2527+ 246C 78                   ld      A,B             ; Get first byte of name
2528+ 246D 96                   sub     (HL)            ; Compare with name in list
2529+ 246E 23           FNTHR:  inc     HL              ; Move on to LSB of value
2530+ 246F CA AD 24             jp      Z,RETADR        ; Found - Return address
2531+ 2472 23                   inc     HL              ; <- Skip
2532+ 2473 23                   inc     HL              ; <- over
2533+ 2474 23                   inc     HL              ; <- F.P.
2534+ 2475 23                   inc     HL              ; <- value
2535+ 2476 C3 60 24             jp      FNDVAR          ; Keep looking
2536+ 2479
2537+ 2479 E1           CFEVAL: pop     HL              ; Restore code string address
2538+ 247A E3                   ex      (SP),HL         ; Get return address
2539+ 247B D5                   push    DE              ; Save address of variable
2540+ 247C 11 E2 22             ld      DE,FRMEVL       ; Return address in EVAL
2541+ 247F CD 0F 1B             call    CPDEHL          ; Called from EVAL ?
2542+ 2482 D1                   pop     DE              ; Restore address of variable
2543+ 2483 CA B0 24             jp      Z,RETNUL        ; Yes - Return null variable
2544+ 2486 E3                   ex      (SP),HL         ; Put back return
2545+ 2487 E5                   push    HL              ; Save code string address
2546+ 2488 C5                   push    BC              ; Save variable name
2547+ 2489 01 06 00             ld      BC,$0006        ; 2 byte name plus 4 byte data
2548+ 248C 2A C6 55             ld      HL,(ARREND)     ; End of arrays
2549+ 248F E5                   push    HL              ; Save end of arrays
2550+ 2490 09                   add     HL,BC           ; Move up 6 bytes
2551+ 2491 C1                   pop     BC              ; Source address in BC
2552+ 2492 E5                   push    HL              ; Save new end address
2553+ 2493 CD C3 17             call    MOVUP           ; Move arrays up
2554+ 2496 E1                   pop     HL              ; Restore new end address
2555+ 2497 22 C6 55             ld      (ARREND),HL     ; Set new end address
2556+ 249A 60                   ld      H,B             ; End of variables to HL
2557+ 249B 69                   ld      L,C
2558+ 249C 22 C4 55             ld      (VAREND),HL     ; Set new end address
2559+ 249F
2560+ 249F 2B           ZEROLP: dec     HL              ; Back through to zero variable
2561+ 24A0 36 00                ld      (HL),$00        ; Zero byte in variable
2562+ 24A2 CD 0F 1B             call    CPDEHL          ; Done them all?
2563+ 24A5 C2 9F 24             jp      NZ,ZEROLP       ; No - Keep on going
2564+ 24A8 D1                   pop     DE              ; Get variable name
2565+ 24A9 73                   ld      (HL),E          ; Store second character
2566+ 24AA 23                   inc     HL
2567+ 24AB 72                   ld      (HL),D          ; Store first character
2568+ 24AC 23                   inc     HL
2569+ 24AD EB           RETADR: ex      DE,HL           ; Address of variable in DE
2570+ 24AE E1                   pop     HL              ; Restore code string address
2571+ 24AF C9                   ret
2572+ 24B0
2573+ 24B0 32 D3 55     RETNUL: ld      (FPEXP),A       ; Set result to zero
2574+ 24B3 21 94 17             ld      HL,ZERBYT       ; Also set a null string
2575+ 24B6 22 D0 55             ld      (FPREG),HL      ; Save for EVAL
2576+ 24B9 E1                   pop     HL              ; Restore code string address
2577+ 24BA C9                   ret
2578+ 24BB
2579+ 24BB E5           SBSCPT: push    HL              ; Save code string address
2580+ 24BC 2A 0D 55             ld      HL,(LCRFLG)     ; Locate/Create and Type
2581+ 24BF E3                   ex      (SP),HL         ; Save and get code string
2582+ 24C0 57                   ld      D,A             ; Zero number of dimensions
2583+ 24C1 D5           SCPTLP: push    DE              ; Save number of dimensions
2584+ 24C2 C5                   push    BC              ; Save array name
2585+ 24C3 CD 08 1E             call    FPSINT          ; Get subscript (0-32767)
2586+ 24C6 C1                   pop     BC              ; Restore array name
2587+ 24C7 F1                   pop     AF              ; Get number of dimensions
2588+ 24C8 EB                   ex      DE,HL
2589+ 24C9 E3                   ex      (SP),HL         ; Save subscript value
2590+ 24CA E5                   push    HL              ; Save LCRFLG and TYPE
2591+ 24CB EB                   ex      DE,HL
2592+ 24CC 3C                   inc     A               ; Count dimensions
2593+ 24CD 57                   ld      D,A             ; Save in D
2594+ 24CE 7E                   ld      A,(HL)          ; Get next byte in code string
2595+ 24CF FE 2C                cp      ','             ; Comma (more to come)?
2596+ 24D1 CA C1 24             jp      Z,SCPTLP        ; Yes - More subscripts
2597+ 24D4 CD 15 1B             call    CHKSYN          ; Make sure ")" follows
2598+ 24D7 29                   defb    ')'
2599+ 24D8 22 56 55             ld      (NXTOPR),HL     ; Save code string address
2600+ 24DB E1                   pop     HL              ; Get LCRFLG and TYPE
2601+ 24DC 22 0D 55             ld      (LCRFLG),HL     ; Restore Locate/create & type
2602+ 24DF 1E 00                ld      E,$00           ; Flag not CSAVE* or CLOAD*
2603+ 24E1 D5                   push    DE              ; Save number of dimensions (D)
2604+ 24E2 11                   defb    $11             ; Skip "push HL" and "push AF'
2605+ 24E3
2606+ 24E3 E5           ARLDSV: push    HL              ; Save code string address
2607+ 24E4 F5                   push    AF              ; A = 00 , Flags set = Z,N
2608+ 24E5 2A C4 55             ld      HL,(VAREND)     ; Start of arrays
2609+ 24E8 3E                   defb    $3E             ; Skip "add HL,DE"
2610+ 24E9 19           FNDARY: add     HL,DE           ; Move to next array start
2611+ 24EA EB                   ex      DE,HL
2612+ 24EB 2A C6 55             ld      HL,(ARREND)     ; End of arrays
2613+ 24EE EB                   ex      DE,HL           ; Current array pointer
2614+ 24EF CD 0F 1B             call    CPDEHL          ; End of arrays found?
2615+ 24F2 CA 1B 25             jp      Z,CREARY        ; Yes - Create array
2616+ 24F5 7E                   ld      A,(HL)          ; Get second byte of name
2617+ 24F6 B9                   cp      C               ; Compare with name given
2618+ 24F7 23                   inc     HL              ; Move on
2619+ 24F8 C2 FD 24             jp      NZ,NXTARY       ; Different - Find next array
2620+ 24FB 7E                   ld      A,(HL)          ; Get first byte of name
2621+ 24FC B8                   cp      B               ; Compare with name given
2622+ 24FD 23           NXTARY: inc     HL              ; Move on
2623+ 24FE 5E                   ld      E,(HL)          ; Get LSB of next array address
2624+ 24FF 23                   inc     HL
2625+ 2500 56                   ld      D,(HL)          ; Get MSB of next array address
2626+ 2501 23                   inc     HL
2627+ 2502 C2 E9 24             jp      NZ,FNDARY       ; Not found - Keep looking
2628+ 2505 3A 0D 55             ld      A,(LCRFLG)      ; Found Locate or Create it?
2629+ 2508 B7                   or      A
2630+ 2509 C2 20 18             jp      NZ,DDERR        ; Create - ?DD Error
2631+ 250C F1                   pop     AF              ; Locate - Get number of dim'ns
2632+ 250D 44                   ld      B,H             ; BC Points to array dim'ns
2633+ 250E 4D                   ld      C,L
2634+ 250F CA EC 2E             jp      Z,POPHRT        ; Jump if array load/save
2635+ 2512 96                   sub     (HL)            ; Same number of dimensions?
2636+ 2513 CA 79 25             jp      Z,FINDEL        ; Yes - Find element
2637+ 2516 1E 10        BSERR:  ld      E,BS            ; ?BS Error
2638+ 2518 C3 31 18             jp      ERROR           ; Output error
2639+ 251B
2640+ 251B 11 04 00     CREARY: ld      DE,$0004        ; 4 Bytes per entry
2641+ 251E F1                   pop     AF              ; Array to save or 0 dim'ns?
2642+ 251F CA 29 1E             jp      Z,FCERR         ; Yes - ?FC Error
2643+ 2522 71                   ld      (HL),C          ; Save second byte of name
2644+ 2523 23                   inc     HL
2645+ 2524 70                   ld      (HL),B          ; Save first byte of name
2646+ 2525 23                   inc     HL
2647+ 2526 4F                   ld      C,A             ; Number of dimensions to C
2648+ 2527 CD D4 17             call    CHKSTK          ; Check if enough memory
2649+ 252A 23                   inc     HL              ; Point to number of dimensions
2650+ 252B 23                   inc     HL
2651+ 252C 22 4B 55             ld      (CUROPR),HL     ; Save address of pointer
2652+ 252F 71                   ld      (HL),C          ; Set number of dimensions
2653+ 2530 23                   inc     HL
2654+ 2531 3A 0D 55             ld      A,(LCRFLG)      ; Locate of Create?
2655+ 2534 17                   rla                     ; Carry set = Create
2656+ 2535 79                   ld      A,C             ; Get number of dimensions
2657+ 2536 01 0B 00     CRARLP: ld      BC,10+1         ; Default dimension size 10
2658+ 2539 D2 3E 25             jp      NC,DEFSIZ       ; Locate - Set default size
2659+ 253C C1                   pop     BC              ; Get specified dimension size
2660+ 253D 03                   inc     BC              ; Include zero element
2661+ 253E 71           DEFSIZ: ld      (HL),C          ; Save LSB of dimension size
2662+ 253F 23                   inc     HL
2663+ 2540 70                   ld      (HL),B          ; Save MSB of dimension size
2664+ 2541 23                   inc     HL
2665+ 2542 F5                   push    AF              ; Save num' of dim'ns an status
2666+ 2543 E5                   push    HL              ; Save address of dim'n size
2667+ 2544 CD E8 30             call    MLDEBC          ; Multiply DE by BC to find
2668+ 2547 EB                   ex      DE,HL           ; amount of mem needed (to DE)
2669+ 2548 E1                   pop     HL              ; Restore address of dimension
2670+ 2549 F1                   pop     AF              ; Restore number of dimensions
2671+ 254A 3D                   dec     A               ; Count them
2672+ 254B C2 36 25             jp      NZ,CRARLP       ; Do next dimension if more
2673+ 254E F5                   push    AF              ; Save locate/create flag
2674+ 254F 42                   ld      B,D             ; MSB of memory needed
2675+ 2550 4B                   ld      C,E             ; LSB of memory needed
2676+ 2551 EB                   ex      DE,HL
2677+ 2552 19                   add     HL,DE           ; Add bytes to array start
2678+ 2553 DA EC 17             jp      C,OMERR         ; Too big - Error
2679+ 2556 CD DD 17             call    ENFMEM          ; See if enough memory
2680+ 2559 22 C6 55             ld      (ARREND),HL     ; Save new end of array
2681+ 255C
2682+ 255C 2B           ZERARY: dec     HL              ; Back through array data
2683+ 255D 36 00                ld      (HL),$00        ; Set array element to zero
2684+ 255F CD 0F 1B             call    CPDEHL          ; All elements zeroed?
2685+ 2562 C2 5C 25             jp      NZ,ZERARY       ; No - Keep on going
2686+ 2565 03                   inc     BC              ; Number of bytes + 1
2687+ 2566 57                   ld      D,A             ; A=0
2688+ 2567 2A 4B 55             ld      HL,(CUROPR)     ; Get address of array
2689+ 256A 5E                   ld      E,(HL)          ; Number of dimensions
2690+ 256B EB                   ex      DE,HL           ; To HL
2691+ 256C 29                   add     HL,HL           ; Two bytes per dimension size
2692+ 256D 09                   add     HL,BC           ; Add number of bytes
2693+ 256E EB                   ex      DE,HL           ; Bytes needed to DE
2694+ 256F 2B                   dec     HL
2695+ 2570 2B                   dec     HL
2696+ 2571 73                   ld      (HL),E          ; Save LSB of bytes needed
2697+ 2572 23                   inc     HL
2698+ 2573 72                   ld      (HL),D          ; Save MSB of bytes needed
2699+ 2574 23                   inc     HL
2700+ 2575 F1                   pop     AF              ; Locate / Create?
2701+ 2576 DA 9D 25             jp      C,ENDDIM        ; A is 0 , End if create
2702+ 2579 47           FINDEL: ld      B,A             ; Find array element
2703+ 257A 4F                   ld      C,A
2704+ 257B 7E                   ld      A,(HL)          ; Number of dimensions
2705+ 257C 23                   inc     HL
2706+ 257D 16                   defb    $16             ; Skip "pop HL"
2707+ 257E E1           FNDELP: pop     HL              ; Address of next dim' size
2708+ 257F 5E                   ld      E,(HL)          ; Get LSB of dim'n size
2709+ 2580 23                   inc     HL
2710+ 2581 56                   ld      D,(HL)          ; Get MSB of dim'n size
2711+ 2582 23                   inc     HL
2712+ 2583 E3                   ex      (SP),HL         ; Save address - Get index
2713+ 2584 F5                   push    AF              ; Save number of dim'ns
2714+ 2585 CD 0F 1B             call    CPDEHL          ; Dimension too large?
2715+ 2588 D2 16 25             jp      NC,BSERR        ; Yes - ?BS Error
2716+ 258B E5                   push    HL              ; Save index
2717+ 258C CD E8 30             call    MLDEBC          ; Multiply previous by size
2718+ 258F D1                   pop     DE              ; Index supplied to DE
2719+ 2590 19                   add     HL,DE           ; Add index to pointer
2720+ 2591 F1                   pop     AF              ; Number of dimensions
2721+ 2592 3D                   dec     A               ; Count them
2722+ 2593 44                   ld      B,H             ; MSB of pointer
2723+ 2594 4D                   ld      C,L             ; LSB of pointer
2724+ 2595 C2 7E 25             jp      NZ,FNDELP       ; More - Keep going
2725+ 2598 29                   add     HL,HL           ; 4 Bytes per element
2726+ 2599 29                   add     HL,HL
2727+ 259A C1                   pop     BC              ; Start of array
2728+ 259B 09                   add     HL,BC           ; Point to element
2729+ 259C EB                   ex      DE,HL           ; Address of element to DE
2730+ 259D 2A 56 55     ENDDIM: ld      HL,(NXTOPR)     ; Got code string address
2731+ 25A0 C9                   ret
2732+ 25A1
2733+ 25A1
2734+ 25A1              ; returns the value of the 32-bit system tick counter as
2735+ 25A1              ; two 16-bit words
2736+ 25A1 CD F2 21     TMR:    call    TSTNUM          ; Make sure it's a number
2737+ 25A4 CD 14 1E             call    DEINT           ; Get integer (-32768 to 32767)
2738+ 25A7 2A 5C 55             ld      HL,(TMRCNT)     ; load the LSBytes of timer
2739+ 25AA 7B                   ld      A,E
2740+ 25AB B2                   or      D               ; is it 0?
2741+ 25AC CA B2 25             jp      Z,ENDTMR        ; yes, jump over
2742+ 25AF 2A 5E 55             ld      HL,(TMRCNT+2)   ; load the MSBytes of timer
2743+ 25B2 45           ENDTMR: ld      B,L             ; move bytes...
2744+ 25B3 7C                   ld      A,H             ; ...into AB
2745+ 25B4 C3 D9 25             jp      ABPASS          ; return word into AB
2746+ 25B7
2747+ 25B7
2748+ 25B7              ; returns the free space for BASIC or into the string pool
2749+ 25B7 2A C6 55     FRE:    ld      HL,(ARREND)     ; Start of free memory
2750+ 25BA EB                   ex      DE,HL           ; To DE
2751+ 25BB 21 00 00             ld      HL,$0000        ; End of free memory
2752+ 25BE 39                   add     HL,SP           ; Current stack value
2753+ 25BF 3A 0E 55             ld      A,(TYPE)        ; Dummy argument type
2754+ 25C2 B7                   or      A
2755+ 25C3 CA D3 25             jp      Z,FRENUM        ; Numeric - Free variable space
2756+ 25C6 CD 3A 28             call    GSTRCU          ; Current string to pool
2757+ 25C9 CD 3A 27             call    GARBGE          ; Garbage collection
2758+ 25CC 2A 27 54             ld      HL,(STRSPC)     ; Bottom of string space in use
2759+ 25CF EB                   ex      DE,HL           ; To DE
2760+ 25D0 2A 49 55             ld      HL,(STRBOT)     ; Bottom of string space
2761+ 25D3 7D           FRENUM: ld      A,L             ; Get LSB of end
2762+ 25D4 93                   sub     E               ; Subtract LSB of beginning
2763+ 25D5 4F                   ld      C,A             ; Save difference if C
2764+ 25D6 7C                   ld      A,H             ; Get MSB of end
2765+ 25D7 9A                   sbc     A,D             ; Subtract MSB of beginning
2766+ 25D8 41           ACPASS: ld      B,C             ; Return integer AC
2767+ 25D9 50           ABPASS: ld      D,B             ; Return integer AB
2768+ 25DA 1E 00                ld      E,$00
2769+ 25DC 21 0E 55             ld      HL,TYPE         ; Point to type
2770+ 25DF 73                   ld      (HL),E          ; Set type to numeric
2771+ 25E0 06 90                ld      B,$80+$10       ; 16 bit integer
2772+ 25E2 C3 13 30             jp      RETINT          ; Return the integer
2773+ 25E5
2774+ 25E5              ; returns the X position of the cursor during a print
2775+ 25E5 3A 0C 55     POS:    ld      A,(CURPOS)      ; Get cursor position
2776+ 25E8              ; return the value in A as a number
2777+ 25E8 47           PASSA:  ld      B,A             ; Put A into AB
2778+ 25E9 AF                   xor     A               ; Zero A
2779+ 25EA C3 D9 25             jp      ABPASS          ; Return integer AB
2780+ 25ED
2781+ 25ED CD 70 26     DEF:    call    CHEKFN          ; Get "FN" and name
2782+ 25F0 CD 62 26             call    IDTEST          ; Test for illegal direct
2783+ 25F3 01 07 1F             ld      BC,DATA         ; To get next statement
2784+ 25F6 C5                   push    BC              ; Save address for RETurn
2785+ 25F7 D5                   push    DE              ; Save address of function ptr
2786+ 25F8 CD 15 1B             call    CHKSYN          ; Make sure "(" follows
2787+ 25FB 28                   defb    '('
2788+ 25FC CD FE 23             call    GETVAR          ; Get argument variable name
2789+ 25FF E5                   push    HL              ; Save code string address
2790+ 2600 EB                   ex      DE,HL           ; Argument address to HL
2791+ 2601 2B                   dec     HL
2792+ 2602 56                   ld      D,(HL)          ; Get first byte of arg name
2793+ 2603 2B                   dec     HL
2794+ 2604 5E                   ld      E,(HL)          ; Get second byte of arg name
2795+ 2605 E1                   pop     HL              ; Restore code string address
2796+ 2606 CD F2 21             call    TSTNUM          ; Make sure numeric argument
2797+ 2609 CD 15 1B             call    CHKSYN          ; Make sure ")" follows
2798+ 260C 29                   defb    ')'
2799+ 260D CD 15 1B             call    CHKSYN          ; Make sure "=" follows
2800+ 2610 CC                   defb    ZEQUAL          ; "=" token
2801+ 2611 44                   ld      B,H             ; Code string address to BC
2802+ 2612 4D                   ld      C,L
2803+ 2613 E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2804+ 2614 71                   ld      (HL),C          ; Save LSB of FN code string
2805+ 2615 23                   inc     HL
2806+ 2616 70                   ld      (HL),B          ; Save MSB of FN code string
2807+ 2617 C3 AF 26             jp      SVSTAD          ; Save address and do function
2808+ 261A
2809+ 261A CD 70 26     DOFN:   call    CHEKFN          ; Make sure FN follows
2810+ 261D D5                   push    DE              ; Save function pointer address
2811+ 261E CD C6 22             call    EVLPAR          ; Evaluate expression in "()"
2812+ 2621 CD F2 21             call    TSTNUM          ; Make sure numeric result
2813+ 2624 E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2814+ 2625 5E                   ld      E,(HL)          ; Get LSB of FN code string
2815+ 2626 23                   inc     HL
2816+ 2627 56                   ld      D,(HL)          ; Get MSB of FN code string
2817+ 2628 23                   inc     HL
2818+ 2629 7A                   ld      A,D             ; And function DEFined?
2819+ 262A B3                   or      E
2820+ 262B CA 23 18             jp      Z,UFERR         ; No - ?UF Error
2821+ 262E 7E                   ld      A,(HL)          ; Get LSB of argument address
2822+ 262F 23                   inc     HL
2823+ 2630 66                   ld      H,(HL)          ; Get MSB of argument address
2824+ 2631 6F                   ld      L,A             ; HL = Arg variable address
2825+ 2632 E5                   push    HL              ; Save it
2826+ 2633 2A CA 55             ld      HL,(FNRGNM)     ; Get old argument name
2827+ 2636 E3                   ex      (SP),HL         ; Save old , Get new
2828+ 2637 22 CA 55             ld      (FNRGNM),HL     ; Set new argument name
2829+ 263A 2A CE 55             ld      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2830+ 263D E5                   push    HL              ; Save it
2831+ 263E 2A CC 55             ld      HL,(FNARG)      ; Get MSB,EXP of old arg value
2832+ 2641 E5                   push    HL              ; Save it
2833+ 2642 21 CC 55             ld      HL,FNARG        ; HL = Value of argument
2834+ 2645 D5                   push    DE              ; Save FN code string address
2835+ 2646 CD 54 30             call    FPTHL           ; Move FPREG to argument
2836+ 2649 E1                   pop     HL              ; Get FN code string address
2837+ 264A CD EF 21             call    GETNUM          ; Get value from function
2838+ 264D 2B                   dec     HL              ; dec 'cos GETCHR INCs
2839+ 264E CD 5E 1D             call    GETCHR          ; Get next character
2840+ 2651 C2 17 18             jp      NZ,SNERR        ; Bad character in FN - Error
2841+ 2654 E1                   pop     HL              ; Get MSB,EXP of old arg
2842+ 2655 22 CC 55             ld      (FNARG),HL      ; Restore it
2843+ 2658 E1                   pop     HL              ; Get LSB,NLSB of old arg
2844+ 2659 22 CE 55             ld      (FNARG+2),HL    ; Restore it
2845+ 265C E1                   pop     HL              ; Get name of old arg
2846+ 265D 22 CA 55             ld      (FNRGNM),HL     ; Restore it
2847+ 2660 E1                   pop     HL              ; Restore code string address
2848+ 2661 C9                   ret
2849+ 2662
2850+ 2662 E5           IDTEST: push    HL              ; Save code string address
2851+ 2663 2A 29 54             ld      HL,(LINEAT)     ; Get current line number
2852+ 2666 23                   inc     HL              ; -1 means direct statement
2853+ 2667 7C                   ld      A,H
2854+ 2668 B5                   or      L
2855+ 2669 E1                   pop     HL              ; Restore code string address
2856+ 266A C0                   ret     NZ              ; Return if in program
2857+ 266B 1E 16                ld      E,ID            ; ?ID Error
2858+ 266D C3 31 18             jp      ERROR
2859+ 2670
2860+ 2670 CD 15 1B     CHEKFN: call    CHKSYN          ; Make sure FN follows
2861+ 2673 BC                   defb    ZFN             ; "FN" token
2862+ 2674 3E 80                ld      A,$80
2863+ 2676 32 51 55             ld      (FORFLG),A      ; Flag FN name to find
2864+ 2679 B6                   or      (HL)            ; FN name has bit 7 set
2865+ 267A 47                   ld      B,A             ; in first byte of name
2866+ 267B CD 03 24             call    GTFNAM          ; Get FN name
2867+ 267E C3 F2 21             jp      TSTNUM          ; Make sure numeric function
2868+ 2681
2869+ 2681 CD F2 21     STR:    call    TSTNUM          ; Make sure it's a number
2870+ 2684 CD A1 31             call    NUMASC          ; Turn number into text
2871+ 2687 CD B5 26     STR1:   call    CRTST           ; Create string entry for it
2872+ 268A CD 3A 28             call    GSTRCU          ; Current string to pool
2873+ 268D 01 95 28             ld      BC,TOPOOL       ; Save in string pool
2874+ 2690 C5                   push    BC              ; Save address on stack
2875+ 2691
2876+ 2691 7E           SAVSTR: ld      A,(HL)          ; Get string length
2877+ 2692 23                   inc     HL
2878+ 2693 23                   inc     HL
2879+ 2694 E5                   push    HL              ; Save pointer to string
2880+ 2695 CD 10 27             call    TESTR           ; See if enough string space
2881+ 2698 E1                   pop     HL              ; Restore pointer to string
2882+ 2699 4E                   ld      C,(HL)          ; Get LSB of address
2883+ 269A 23                   inc     HL
2884+ 269B 46                   ld      B,(HL)          ; Get MSB of address
2885+ 269C CD A9 26             call    CRTMST          ; Create string entry
2886+ 269F E5                   push    HL              ; Save pointer to MSB of addr
2887+ 26A0 6F                   ld      L,A             ; Length of string
2888+ 26A1 CD 2D 28             call    TOSTRA          ; Move to string area
2889+ 26A4 D1                   pop     DE              ; Restore pointer to MSB
2890+ 26A5 C9                   ret
2891+ 26A6
2892+ 26A6 CD 10 27     MKTMST: call    TESTR           ; See if enough string space
2893+ 26A9 21 45 55     CRTMST: ld      HL,TMPSTR       ; Temporary string
2894+ 26AC E5                   push    HL              ; Save it
2895+ 26AD 77                   ld      (HL),A          ; Save length of string
2896+ 26AE 23                   inc     HL
2897+ 26AF 23           SVSTAD: inc     HL
2898+ 26B0 73                   ld      (HL),E          ; Save LSB of address
2899+ 26B1 23                   inc     HL
2900+ 26B2 72                   ld      (HL),D          ; Save MSB of address
2901+ 26B3 E1                   pop     HL              ; Restore pointer
2902+ 26B4 C9                   ret
2903+ 26B5
2904+ 26B5 2B           CRTST:  dec     HL              ; dec - INCed after
2905+ 26B6 06 22        QTSTR:  ld      B,$22           ; '"'           ; Terminating quote
2906+ 26B8 50                   ld      D,B             ; Quote to D
2907+ 26B9 E5           DTSTR:  push    HL              ; Save start
2908+ 26BA 0E FF                ld      C,-1            ; Set counter to -1
2909+ 26BC 23           QTSTLP: inc     HL              ; Move on
2910+ 26BD 7E                   ld      A,(HL)          ; Get byte
2911+ 26BE 0C                   inc     C               ; Count bytes
2912+ 26BF B7                   or      A               ; End of line?
2913+ 26C0 CA CB 26             jp      Z,CRTSTE        ; Yes - Create string entry
2914+ 26C3 BA                   cp      D               ; Terminator D found?
2915+ 26C4 CA CB 26             jp      Z,CRTSTE        ; Yes - Create string entry
2916+ 26C7 B8                   cp      B               ; Terminator B found?
2917+ 26C8 C2 BC 26             jp      NZ,QTSTLP       ; No - Keep looking
2918+ 26CB FE 22        CRTSTE: cp      $22             ; '"'             ; End with '"'?
2919+ 26CD CC 5E 1D             call    Z,GETCHR        ; Yes - Get next character
2920+ 26D0 E3                   ex      (SP),HL         ; Starting quote
2921+ 26D1 23                   inc     HL              ; First byte of string
2922+ 26D2 EB                   ex      DE,HL           ; To DE
2923+ 26D3 79                   ld      A,C             ; Get length
2924+ 26D4 CD A9 26             call    CRTMST          ; Create string entry
2925+ 26D7 11 45 55     TSTOPL: ld      DE,TMPSTR       ; Temporary string
2926+ 26DA 2A 37 55             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2927+ 26DD 22 D0 55             ld      (FPREG),HL      ; Save address of string ptr
2928+ 26E0 3E 01                ld      A,$01
2929+ 26E2 32 0E 55             ld      (TYPE),A        ; Set type to string
2930+ 26E5 CD 57 30             call    DETHL4          ; Move string to pool
2931+ 26E8 CD 0F 1B             call    CPDEHL          ; Out of string pool?
2932+ 26EB 22 37 55             ld      (TMSTPT),HL     ; Save new pointer
2933+ 26EE E1                   pop     HL              ; Restore code string address
2934+ 26EF 7E                   ld      A,(HL)          ; Get next code byte
2935+ 26F0 C0                   ret     NZ              ; Return if pool OK
2936+ 26F1 1E 1E                ld      E,ST            ; ?ST Error
2937+ 26F3 C3 31 18             jp      ERROR           ; String pool overflow
2938+ 26F6
2939+ 26F6 23           PRNUMS: inc     HL              ; Skip leading space
2940+ 26F7 CD B5 26     PRS:    call    CRTST           ; Create string entry for it
2941+ 26FA CD 3A 28     PRS1:   call    GSTRCU          ; Current string to pool
2942+ 26FD CD 4B 30             call    LOADFP          ; Move string block to BCDE
2943+ 2700 1C                   inc     E               ; Length + 1
2944+ 2701 1D           PRSLP:  dec     E               ; Count characters
2945+ 2702 C8                   ret     Z               ; End of string
2946+ 2703 0A                   ld      A,(BC)          ; Get byte to output
2947+ 2704 CD 20 1B             call    OUTC            ; Output character in A
2948+ 2707 FE 0D                cp      CR              ; Return?
2949+ 2709 CC 35 20             call    Z,CNTEND        ; Yes - Position cursor to 0
2950+ 270C 03                   inc     BC              ; Next byte in string
2951+ 270D C3 01 27             jp      PRSLP           ; More characters to output
2952+ 2710
2953+ 2710 B7           TESTR:  or      A               ; Test if enough room
2954+ 2711 0E                   defb    $0E             ; No garbage collection done
2955+ 2712 F1           GRBDON: pop     AF              ; Garbage collection done
2956+ 2713 F5                   push    AF              ; Save status
2957+ 2714 2A 27 54             ld      HL,(STRSPC)     ; Bottom of string space in use
2958+ 2717 EB                   ex      DE,HL           ; To DE
2959+ 2718 2A 49 55             ld      HL,(STRBOT)     ; Bottom of string area
2960+ 271B 2F                   cpl                     ; Negate length (Top down)
2961+ 271C 4F                   ld      C,A             ; -Length to BC
2962+ 271D 06 FF                ld      B,-1            ; BC = -ve length of string
2963+ 271F 09                   add     HL,BC           ; Add to bottom of space in use
2964+ 2720 23                   inc     HL              ; Plus one for 2's complement
2965+ 2721 CD 0F 1B             call    CPDEHL          ; Below string RAM area?
2966+ 2724 DA 2E 27             jp      C,TESTOS        ; Tidy up if not done else err
2967+ 2727 22 49 55             ld      (STRBOT),HL     ; Save new bottom of area
2968+ 272A 23                   inc     HL              ; Point to first byte of string
2969+ 272B EB                   ex      DE,HL           ; Address to DE
2970+ 272C F1           POPAF:  pop     AF              ; Throw away status push
2971+ 272D C9                   ret
2972+ 272E
2973+ 272E F1           TESTOS: pop     AF              ; Garbage collect been done?
2974+ 272F 1E 1A                ld      E,OS            ; ?OS Error
2975+ 2731 CA 31 18             jp      Z,ERROR         ; Yes - Not enough string space
2976+ 2734 BF                   cp      A               ; Flag garbage collect done
2977+ 2735 F5                   push    AF              ; Save status
2978+ 2736 01 12 27             ld      BC,GRBDON       ; Garbage collection done
2979+ 2739 C5                   push    BC              ; Save for RETurn
2980+ 273A 2A 10 55     GARBGE: ld      HL,(LSTRAM)     ; Get end of RAM pointer
2981+ 273D 22 49 55     GARBLP: ld      (STRBOT),HL     ; Reset string pointer
2982+ 2740 21 00 00             ld      HL,$0000
2983+ 2743 E5                   push    HL              ; Flag no string found
2984+ 2744 2A 27 54             ld      HL,(STRSPC)     ; Get bottom of string space
2985+ 2747 E5                   push    HL              ; Save bottom of string space
2986+ 2748 21 39 55             ld      HL,TMSTPL       ; Temporary string pool
2987+ 274B EB           GRBLP:  ex      DE,HL
2988+ 274C 2A 37 55             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2989+ 274F EB                   ex      DE,HL
2990+ 2750 CD 0F 1B             call    CPDEHL          ; Temporary string pool done?
2991+ 2753 01 4B 27             ld      BC,GRBLP        ; Loop until string pool done
2992+ 2756 C2 9F 27             jp      NZ,STPOOL       ; No - See if in string area
2993+ 2759 2A C2 55             ld      HL,(PROGND)     ; Start of simple variables
2994+ 275C EB           SMPVAR: ex      DE,HL
2995+ 275D 2A C4 55             ld      HL,(VAREND)     ; End of simple variables
2996+ 2760 EB                   ex      DE,HL
2997+ 2761 CD 0F 1B             call    CPDEHL          ; All simple strings done?
2998+ 2764 CA 72 27             jp      Z,ARRLP         ; Yes - Do string arrays
2999+ 2767 7E                   ld      A,(HL)          ; Get type of variable
3000+ 2768 23                   inc     HL
3001+ 2769 23                   inc     HL
3002+ 276A B7                   or      A               ; "S" flag set if string
3003+ 276B CD A2 27             call    STRADD          ; See if string in string area
3004+ 276E C3 5C 27             jp      SMPVAR          ; Loop until simple ones done
3005+ 2771
3006+ 2771 C1           GNXARY: pop     BC              ; Scrap address of this array
3007+ 2772 EB           ARRLP:  ex      DE,HL
3008+ 2773 2A C6 55             ld      HL,(ARREND)     ; End of string arrays
3009+ 2776 EB                   ex      DE,HL
3010+ 2777 CD 0F 1B             call    CPDEHL          ; All string arrays done?
3011+ 277A CA C8 27             jp      Z,SCNEND        ; Yes - Move string if found
3012+ 277D CD 4B 30             call    LOADFP          ; Get array name to BCDE
3013+ 2780 7B                   ld      A,E             ; Get type of array
3014+ 2781 E5                   push    HL              ; Save address of num of dim'ns
3015+ 2782 09                   add     HL,BC           ; Start of next array
3016+ 2783 B7                   or      A               ; Test type of array
3017+ 2784 F2 71 27             jp      P,GNXARY        ; Numeric array - Ignore it
3018+ 2787 22 4B 55             ld      (CUROPR),HL     ; Save address of next array
3019+ 278A E1                   pop     HL              ; Get address of num of dim'ns
3020+ 278B 4E                   ld      C,(HL)          ; BC = Number of dimensions
3021+ 278C 06 00                ld      B,$00
3022+ 278E 09                   add     HL,BC           ; Two bytes per dimension size
3023+ 278F 09                   add     HL,BC
3024+ 2790 23                   inc     HL              ; Plus one for number of dim'ns
3025+ 2791 EB           GRBARY: ex      DE,HL
3026+ 2792 2A 4B 55             ld      HL,(CUROPR)     ; Get address of next array
3027+ 2795 EB                   ex      DE,HL
3028+ 2796 CD 0F 1B             call    CPDEHL          ; Is this array finished?
3029+ 2799 CA 72 27             jp      Z,ARRLP         ; Yes - Get next one
3030+ 279C 01 91 27             ld      BC,GRBARY       ; Loop until array all done
3031+ 279F C5           STPOOL: push    BC              ; Save return address
3032+ 27A0 F6 80                or      $80             ; Flag string type
3033+ 27A2 7E           STRADD: ld      A,(HL)          ; Get string length
3034+ 27A3 23                   inc     HL
3035+ 27A4 23                   inc     HL
3036+ 27A5 5E                   ld      E,(HL)          ; Get LSB of string address
3037+ 27A6 23                   inc     HL
3038+ 27A7 56                   ld      D,(HL)          ; Get MSB of string address
3039+ 27A8 23                   inc     HL
3040+ 27A9 F0                   ret     P               ; Not a string - Return
3041+ 27AA B7                   or      A               ; Set flags on string length
3042+ 27AB C8                   ret     Z               ; Null string - Return
3043+ 27AC 44                   ld      B,H             ; Save variable pointer
3044+ 27AD 4D                   ld      C,L
3045+ 27AE 2A 49 55             ld      HL,(STRBOT)     ; Bottom of new area
3046+ 27B1 CD 0F 1B             call    CPDEHL          ; String been done?
3047+ 27B4 60                   ld      H,B             ; Restore variable pointer
3048+ 27B5 69                   ld      L,C
3049+ 27B6 D8                   ret     C               ; String done - Ignore
3050+ 27B7 E1                   pop     HL              ; Return address
3051+ 27B8 E3                   ex      (SP),HL         ; Lowest available string area
3052+ 27B9 CD 0F 1B             call    CPDEHL          ; String within string area?
3053+ 27BC E3                   ex      (SP),HL         ; Lowest available string area
3054+ 27BD E5                   push    HL              ; Re-save return address
3055+ 27BE 60                   ld      H,B             ; Restore variable pointer
3056+ 27BF 69                   ld      L,C
3057+ 27C0 D0                   ret     NC              ; Outside string area - Ignore
3058+ 27C1 C1                   pop     BC              ; Get return , Throw 2 away
3059+ 27C2 F1                   pop     AF              ;
3060+ 27C3 F1                   pop     AF              ;
3061+ 27C4 E5                   push    HL              ; Save variable pointer
3062+ 27C5 D5                   push    DE              ; Save address of current
3063+ 27C6 C5                   push    BC              ; Put back return address
3064+ 27C7 C9                   ret                     ; Go to it
3065+ 27C8
3066+ 27C8 D1           SCNEND: pop     DE              ; Addresses of strings
3067+ 27C9 E1                   pop     HL              ;
3068+ 27CA 7D                   ld      A,L             ; HL = 0 if no more to do
3069+ 27CB B4                   or      H
3070+ 27CC C8                   ret     Z               ; No more to do - Return
3071+ 27CD 2B                   dec     HL
3072+ 27CE 46                   ld      B,(HL)          ; MSB of address of string
3073+ 27CF 2B                   dec     HL
3074+ 27D0 4E                   ld      C,(HL)          ; LSB of address of string
3075+ 27D1 E5                   push    HL              ; Save variable address
3076+ 27D2 2B                   dec     HL
3077+ 27D3 2B                   dec     HL
3078+ 27D4 6E                   ld      L,(HL)          ; HL = Length of string
3079+ 27D5 26 00                ld      H,$00
3080+ 27D7 09                   add     HL,BC           ; Address of end of string+1
3081+ 27D8 50                   ld      D,B             ; String address to DE
3082+ 27D9 59                   ld      E,C
3083+ 27DA 2B                   dec     HL              ; Last byte in string
3084+ 27DB 44                   ld      B,H             ; Address to BC
3085+ 27DC 4D                   ld      C,L
3086+ 27DD 2A 49 55             ld      HL,(STRBOT)     ; Current bottom of string area
3087+ 27E0 CD C6 17             call    MOVSTR          ; Move string to new address
3088+ 27E3 E1                   pop     HL              ; Restore variable address
3089+ 27E4 71                   ld      (HL),C          ; Save new LSB of address
3090+ 27E5 23                   inc     HL
3091+ 27E6 70                   ld      (HL),B          ; Save new MSB of address
3092+ 27E7 69                   ld      L,C             ; Next string area+1 to HL
3093+ 27E8 60                   ld      H,B
3094+ 27E9 2B                   dec     HL              ; Next string area address
3095+ 27EA C3 3D 27             jp      GARBLP          ; Look for more strings
3096+ 27ED
3097+ 27ED C5           CONCAT: push    BC              ; Save prec' opr & code string
3098+ 27EE E5                   push    HL              ;
3099+ 27EF 2A D0 55             ld      HL,(FPREG)      ; Get first string
3100+ 27F2 E3                   ex      (SP),HL         ; Save first string
3101+ 27F3 CD 78 22             call    OPRND           ; Get second string
3102+ 27F6 E3                   ex      (SP),HL         ; Restore first string
3103+ 27F7 CD F3 21             call    TSTSTR          ; Make sure it's a string
3104+ 27FA 7E                   ld      A,(HL)          ; Get length of second string
3105+ 27FB E5                   push    HL              ; Save first string
3106+ 27FC 2A D0 55             ld      HL,(FPREG)      ; Get second string
3107+ 27FF E5                   push    HL              ; Save second string
3108+ 2800 86                   add     A,(HL)          ; Add length of second string
3109+ 2801 1E 1C                ld      E,LS            ; ?LS Error
3110+ 2803 DA 31 18             jp      C,ERROR         ; String too long - Error
3111+ 2806 CD A6 26             call    MKTMST          ; Make temporary string
3112+ 2809 D1                   pop     DE              ; Get second string to DE
3113+ 280A CD 3E 28             call    GSTRDE          ; Move to string pool if needed
3114+ 280D E3                   ex      (SP),HL         ; Get first string
3115+ 280E CD 3D 28             call    GSTRHL          ; Move to string pool if needed
3116+ 2811 E5                   push    HL              ; Save first string
3117+ 2812 2A 47 55             ld      HL,(TMPSTR+2)   ; Temporary string address
3118+ 2815 EB                   ex      DE,HL           ; To DE
3119+ 2816 CD 24 28             call    SSTSA           ; First string to string area
3120+ 2819 CD 24 28             call    SSTSA           ; Second string to string area
3121+ 281C 21 0D 22             ld      HL,EVAL2        ; Return to evaluation loop
3122+ 281F E3                   ex      (SP),HL         ; Save return,get code string
3123+ 2820 E5                   push    HL              ; Save code string address
3124+ 2821 C3 D7 26             jp      TSTOPL          ; To temporary string to pool
3125+ 2824
3126+ 2824 E1           SSTSA:  pop     HL              ; Return address
3127+ 2825 E3                   ex      (SP),HL         ; Get string block,save return
3128+ 2826 7E                   ld      A,(HL)          ; Get length of string
3129+ 2827 23                   inc     HL
3130+ 2828 23                   inc     HL
3131+ 2829 4E                   ld      C,(HL)          ; Get LSB of string address
3132+ 282A 23                   inc     HL
3133+ 282B 46                   ld      B,(HL)          ; Get MSB of string address
3134+ 282C 6F                   ld      L,A             ; Length to L
3135+ 282D 2C           TOSTRA: inc     L               ; inc - DECed after
3136+ 282E 2D           TSALP:  dec     L               ; Count bytes moved
3137+ 282F C8                   ret     Z               ; End of string - Return
3138+ 2830 0A                   ld      A,(BC)          ; Get source
3139+ 2831 12                   ld      (DE),A          ; Save destination
3140+ 2832 03                   inc     BC              ; Next source
3141+ 2833 13                   inc     DE              ; Next destination
3142+ 2834 C3 2E 28             jp      TSALP           ; Loop until string moved
3143+ 2837
3144+ 2837 CD F3 21     GETSTR: call    TSTSTR          ; Make sure it's a string
3145+ 283A 2A D0 55     GSTRCU: ld      HL,(FPREG)      ; Get current string
3146+ 283D EB           GSTRHL: ex      DE,HL           ; Save DE
3147+ 283E CD 58 28     GSTRDE: call    BAKTMP          ; Was it last tmp-str?
3148+ 2841 EB                   ex      DE,HL           ; Restore DE
3149+ 2842 C0                   ret     NZ              ; No - Return
3150+ 2843 D5                   push    DE              ; Save string
3151+ 2844 50                   ld      D,B             ; String block address to DE
3152+ 2845 59                   ld      E,C
3153+ 2846 1B                   dec     DE              ; Point to length
3154+ 2847 4E                   ld      C,(HL)          ; Get string length
3155+ 2848 2A 49 55             ld      HL,(STRBOT)     ; Current bottom of string area
3156+ 284B CD 0F 1B             call    CPDEHL          ; Last one in string area?
3157+ 284E C2 56 28             jp      NZ,POPHL        ; No - Return
3158+ 2851 47                   ld      B,A             ; Clear B (A=0)
3159+ 2852 09                   add     HL,BC           ; Remove string from str' area
3160+ 2853 22 49 55             ld      (STRBOT),HL     ; Save new bottom of str' area
3161+ 2856 E1           POPHL:  pop     HL              ; Restore string
3162+ 2857 C9                   ret
3163+ 2858
3164+ 2858 2A 37 55     BAKTMP: ld      HL,(TMSTPT)     ; Get temporary string pool top
3165+ 285B 2B                   dec     HL              ; Back
3166+ 285C 46                   ld      B,(HL)          ; Get MSB of address
3167+ 285D 2B                   dec     HL              ; Back
3168+ 285E 4E                   ld      C,(HL)          ; Get LSB of address
3169+ 285F 2B                   dec     HL              ; Back
3170+ 2860 2B                   dec     HL              ; Back
3171+ 2861 CD 0F 1B             call    CPDEHL          ; String last in string pool?
3172+ 2864 C0                   ret     NZ              ; Yes - Leave it
3173+ 2865 22 37 55             ld      (TMSTPT),HL     ; Save new string pool top
3174+ 2868 C9                   ret
3175+ 2869
3176+ 2869 01 E8 25     LEN:    ld      BC,PASSA        ; To return integer A
3177+ 286C C5                   push    BC              ; Save address
3178+ 286D CD 37 28     GETLEN: call    GETSTR          ; Get string and its length
3179+ 2870 AF                   xor     A
3180+ 2871 57                   ld      D,A             ; Clear D
3181+ 2872 32 0E 55             ld      (TYPE),A        ; Set type to numeric
3182+ 2875 7E                   ld      A,(HL)          ; Get length of string
3183+ 2876 B7                   or      A               ; Set status flags
3184+ 2877 C9                   ret
3185+ 2878
3186+ 2878 01 E8 25     ASC:    ld      BC,PASSA        ; To return integer A
3187+ 287B C5                   push    BC              ; Save address
3188+ 287C CD 6D 28     GTFLNM: call    GETLEN          ; Get length of string
3189+ 287F CA 29 1E             jp      Z,FCERR         ; Null string - Error
3190+ 2882 23                   inc     HL
3191+ 2883 23                   inc     HL
3192+ 2884 5E                   ld      E,(HL)          ; Get LSB of address
3193+ 2885 23                   inc     HL
3194+ 2886 56                   ld      D,(HL)          ; Get MSB of address
3195+ 2887 1A                   ld      A,(DE)          ; Get first byte of string
3196+ 2888 C9                   ret
3197+ 2889
3198+ 2889 3E 01        CHR:    ld      A,$01           ; One character string
3199+ 288B CD A6 26             call    MKTMST          ; Make a temporary string
3200+ 288E CD 78 2A             call    MAKINT          ; Make it integer A
3201+ 2891 2A 47 55             ld      HL,(TMPSTR+2)   ; Get address of string
3202+ 2894 73                   ld      (HL),E          ; Save character
3203+ 2895 C1           TOPOOL: pop     BC              ; Clean up stack
3204+ 2896 C3 D7 26             jp      TSTOPL          ; Temporary string to pool
3205+ 2899
3206+ 2899 CD 28 2A     LEFT:   call    LFRGNM          ; Get number and ending ")"
3207+ 289C AF                   xor     A               ; Start at first byte in string
3208+ 289D E3           RIGHT1: ex      (SP),HL         ; Save code string,Get string
3209+ 289E 4F                   ld      C,A             ; Starting position in string
3210+ 289F E5           MID1:   push    HL              ; Save string block address
3211+ 28A0 7E                   ld      A,(HL)          ; Get length of string
3212+ 28A1 B8                   cp      B               ; Compare with number given
3213+ 28A2 DA A7 28             jp      C,ALLFOL        ; All following bytes required
3214+ 28A5 78                   ld      A,B             ; Get new length
3215+ 28A6 11                   defb    $11             ; Skip "ld C,0"
3216+ 28A7 0E 00        ALLFOL: ld      C,$00           ; First byte of string
3217+ 28A9 C5                   push    BC              ; Save position in string
3218+ 28AA CD 10 27             call    TESTR           ; See if enough string space
3219+ 28AD C1                   pop     BC              ; Get position in string
3220+ 28AE E1                   pop     HL              ; Restore string block address
3221+ 28AF E5                   push    HL              ; And re-save it
3222+ 28B0 23                   inc     HL
3223+ 28B1 23                   inc     HL
3224+ 28B2 46                   ld      B,(HL)          ; Get LSB of address
3225+ 28B3 23                   inc     HL
3226+ 28B4 66                   ld      H,(HL)          ; Get MSB of address
3227+ 28B5 68                   ld      L,B             ; HL = address of string
3228+ 28B6 06 00                ld      B,$00           ; BC = starting address
3229+ 28B8 09                   add     HL,BC           ; Point to that byte
3230+ 28B9 44                   ld      B,H             ; BC = source string
3231+ 28BA 4D                   ld      C,L
3232+ 28BB CD A9 26             call    CRTMST          ; Create a string entry
3233+ 28BE 6F                   ld      L,A             ; Length of new string
3234+ 28BF CD 2D 28             call    TOSTRA          ; Move string to string area
3235+ 28C2 D1                   pop     DE              ; Clear stack
3236+ 28C3 CD 3E 28             call    GSTRDE          ; Move to string pool if needed
3237+ 28C6 C3 D7 26             jp      TSTOPL          ; Temporary string to pool
3238+ 28C9
3239+ 28C9
3240+ 28C9              ; INSTR statement - look for a string inside another string
3241+ 28C9              ; usage: INSTR(A$,B$) -> search for B$ into A$
3242+ 28C9              ; return 0 if B$ is not found into A$, or LEN(A$)<LEN(B$)
3243+ 28C9              ; return 1~255 to indicate the starting position of B$ into A$
3244+ 28C9              ; ex.: INSTR("HELLO","LO") returns 4 - INSTR("HOME","PC") returns 0
3245+ 28C9              LNS1    equ     TMPBFR1
3246+ 28C9              ADRS1   equ     TMPBFR2
3247+ 28C9              LNS2    equ     TMPBFR3
3248+ 28C9              ADRS2   equ     TMPBFR4
3249+ 28C9              PT      equ     VIDEOBUFF
3250+ 28C9              PT1     equ     VIDEOBUFF+2
3251+ 28C9              PT2     equ     VIDEOBUFF+4
3252+ 28C9              TP      equ     VIDEOBUFF+6
3253+ 28C9              TF      equ     VIDEOBUFF+8
3254+ 28C9 CD 15 1B     INSTR:  call    CHKSYN          ; make sure "(" follows
3255+ 28CC 28                   defb    '('
3256+ 28CD 2B                   dec     HL              ; dec 'cause GETCHR increments
3257+ 28CE CD 5E 1D             call    GETCHR          ; check if something follows
3258+ 28D1 CA 17 18             jp      Z,SNERR         ; if nothing else, raise a syntax error
3259+ 28D4 CD 01 22             call    EVAL            ; Evaluate expression
3260+ 28D7 CD F3 21             call    TSTSTR          ; Make sure it's a string
3261+ 28DA 22 84 55             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3262+ 28DD CD 3A 28             call    GSTRCU          ; check that a string follows
3263+ 28E0 CD 4B 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3264+ 28E3 ED 53 7C 55          ld      (LNS1),DE       ; store values into
3265+ 28E7 ED 43 7E 55          ld      (ADRS1),BC      ; temp buffers
3266+ 28EB 2A 84 55             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3267+ 28EE CD 15 1B             call    CHKSYN          ; Make sure ',' follows
3268+ 28F1 2C                   defb    ','
3269+ 28F2 2B                   dec     HL              ; dec 'cause GETCHR increments
3270+ 28F3 CD 5E 1D             call    GETCHR          ; check if something follows
3271+ 28F6 CA 17 18             jp      Z,SNERR         ; if nothing else, raise a syntax error
3272+ 28F9 CD 01 22             call    EVAL            ; Evaluate expression
3273+ 28FC CD F3 21             call    TSTSTR          ; Make sure it's a string
3274+ 28FF 22 84 55             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3275+ 2902 CD 3A 28             call    GSTRCU          ; check that a string follows
3276+ 2905 CD 4B 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3277+ 2908 ED 53 80 55          ld      (LNS2),DE       ; store values into
3278+ 290C ED 43 82 55          ld      (ADRS2),BC      ; temp buffers
3279+ 2910 2A 84 55             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3280+ 2913 CD 15 1B             call    CHKSYN          ; make sure ")" follows
3281+ 2916 29                   defb    ')'
3282+ 2917 E5                   push    HL              ; store current code string pointer (the point after the ")" ) ...
3283+ 2918 FD E1                pop     IY              ; ...into IY
3284+ 291A AF                   xor     A               ; reset 10 RAM cells
3285+ 291B 06 0A                ld      B,$0A           ; (INSTR registers)
3286+ 291D 21 84 55             ld      HL,PT           ; first cell
3287+ 2920 77           EMPTINS:ld      (HL),A          ; reset cell
3288+ 2921 23                   inc     HL              ; next cell
3289+ 2922 10 FC                djnz    EMPTINS         ; repeat
3290+ 2924 ED 5B 80 55          ld      DE,(LNS2)       ; load len(S2) into DE
3291+ 2928 2A 7C 55             ld      HL,(LNS1)       ; load len(S1) into HL
3292+ 292B CD 38 41             call    CMP16           ; check that len(S1)>=len(S2)
3293+ 292E DA A3 29             jp      C,RZINSTR       ; if len(S2)>len(S1) then return 0
3294+ 2931 AF           RPTINST:xor     A               ; reset...
3295+ 2932 32 8A 55             ld      (TP),A          ; ...TP...
3296+ 2935 32 8C 55             ld      (TF),A          ; ...and TF
3297+ 2938 ED 4B 84 55          ld      BC,(PT)         ; pointer to S1
3298+ 293C 2A 7E 55             ld      HL,(ADRS1)      ; first cell of S1
3299+ 293F 09                   add     HL,BC           ; get current position into RAM
3300+ 2940 7E                   ld      A,(HL)          ; load S1(PT)
3301+ 2941 2A 82 55             ld      HL,(ADRS2)      ; pointer to first char of S2
3302+ 2944 BE                   cp      (HL)            ; is S1(PT)=S2(0)?
3303+ 2945 20 3A                jr      NZ,CNT1INS      ; no, continue
3304+ 2947 3A 84 55             ld      A,(PT)          ; load current PT
3305+ 294A 32 8A 55             ld      (TP),A          ; TP=PT
3306+ 294D 32 86 55             ld      (PT1),A         ; P1=PT
3307+ 2950 AF                   xor     A               ; set...
3308+ 2951 32 88 55             ld      (PT2),A         ; ...PT2=0
3309+ 2954 3C                   inc     A               ;
3310+ 2955 32 8C 55             ld      (TF),A          ; set TF=1
3311+ 2958 ED 4B 86 55  RP2INST:ld      BC,(PT1)        ; load pointer PT1
3312+ 295C 2A 7E 55             ld      HL,(ADRS1)      ; load address of S1
3313+ 295F 09                   add     HL,BC           ; find char of S1 pointed by PT1
3314+ 2960 7E                   ld      A,(HL)          ; load S1(PT1)
3315+ 2961 ED 4B 88 55          ld      BC,(PT2)        ; load pointer PT2
3316+ 2965 2A 82 55             ld      HL,(ADRS2)      ; load char of S2 pointed by PT2
3317+ 2968 09                   add     HL,BC           ; find S2(PT2)
3318+ 2969 BE                   cp      (HL)            ; is S1(PT1)=S2(PT2)?
3319+ 296A 20 4C                jr      NZ,CNTZIN       ; no, exit inner loop
3320+ 296C 21 86 55             ld      HL,PT1
3321+ 296F 34                   inc     (HL)            ; increment PT1
3322+ 2970 3A 88 55             ld      A,(PT2)
3323+ 2973 3C                   inc     A               ; increment PT2
3324+ 2974 32 88 55             ld      (PT2),A
3325+ 2977 CA 81 29             jp      Z,CNT1INS       ; if PT2>255 then exit
3326+ 297A 21 80 55             ld      HL,LNS2         ; len(S2)
3327+ 297D BE                   cp      (HL)            ; PT2=len(S2)?
3328+ 297E DA 58 29             jp      C,RP2INST       ; no (PT2<len(S2) - repeat
3329+ 2981 3A 8C 55     CNT1INS:ld      A,(TF)          ; check TF
3330+ 2984 A7                   and     A               ; TF=0? (clears also Carry for next SBC)
3331+ 2985 20 1C                jr      NZ,RZINSTR      ; no, exit
3332+ 2987 2A 7C 55             ld      HL,(LNS1)       ; load len(S1)
3333+ 298A ED 4B 80 55          ld      BC,(LNS2)       ; load len(S2)
3334+ 298E ED 42                sbc     HL,BC           ; HL=len(S1)-len(S2)
3335+ 2990 ED 5B 84 55          ld      DE,(PT)         ; load pointer
3336+ 2994 1C                   inc     E               ; PT=PT+1
3337+ 2995 ED 53 84 55          ld      (PT),DE         ; store new value
3338+ 2999 EB                   ex      DE,HL           ; invert registers
3339+ 299A CD 38 41             call    CMP16           ; check if PT>len(S1)-len(S2)
3340+ 299D DA 31 29             jp      C,RPTINST       ; repeat if <
3341+ 29A0 CA 31 29             jp      Z,RPTINST       ; repeat if =
3342+ 29A3 3A 8C 55     RZINSTR:ld      A,(TF)          ; current value of TF
3343+ 29A6 A7                   and     A               ; is it 0?
3344+ 29A7 CA AE 29             jp      Z,LVINSTR       ; yes, return 0
3345+ 29AA 3A 8A 55             ld      A,(TP)          ; return TP...
3346+ 29AD 3C                   inc     A               ; ...incremented by 1
3347+ 29AE E1           LVINSTR:pop     HL              ; drop original return point
3348+ 29AF FD E5                push    IY              ; load current string address from IY into stack
3349+ 29B1 11 DA 22             ld      DE,RETNUM       ; Address of Return number from function...
3350+ 29B4 D5                   push    DE              ; ...saved on stack
3351+ 29B5 C3 E8 25             jp      PASSA           ; return TP
3352+ 29B8 AF           CNTZIN: xor     A               ; set...
3353+ 29B9 32 8C 55             ld      (TF),A          ; TF=0
3354+ 29BC C3 81 29             jp      CNT1INS         ; continue
3355+ 29BF
3356+ 29BF
3357+ 29BF              ; returns the right portion of a string
3358+ 29BF CD 28 2A     RIGHT:  call    LFRGNM          ; Get number and ending ")"
3359+ 29C2 D1                   pop     DE              ; Get string length
3360+ 29C3 D5                   push    DE              ; And re-save
3361+ 29C4 1A                   ld      A,(DE)          ; Get length
3362+ 29C5 90                   sub     B               ; Move back N bytes
3363+ 29C6 C3 9D 28             jp      RIGHT1          ; Go and get sub-string
3364+ 29C9
3365+ 29C9              ; returns a piece of a string
3366+ 29C9 EB           MID:    ex      DE,HL           ; Get code string address
3367+ 29CA 7E                   ld      A,(HL)          ; Get next byte ',' or ")"
3368+ 29CB CD 2D 2A             call    MIDNUM          ; Get number supplied
3369+ 29CE 04                   inc     B               ; Is it character zero?
3370+ 29CF 05                   dec     B
3371+ 29D0 CA 29 1E             jp      Z,FCERR         ; Yes - Error
3372+ 29D3 C5                   push    BC              ; Save starting position
3373+ 29D4 1E FF                ld      E,$FF           ; All of string
3374+ 29D6 FE 29                cp      ')'             ; Any length given?
3375+ 29D8 CA E2 29             jp      Z,RSTSTR        ; No - Rest of string
3376+ 29DB CD 15 1B             call    CHKSYN          ; Make sure ',' follows
3377+ 29DE 2C                   defb    ','
3378+ 29DF CD 75 2A             call    GETINT          ; Get integer 0-255
3379+ 29E2 CD 15 1B     RSTSTR: call    CHKSYN          ; Make sure ")" follows
3380+ 29E5 29                   defb    ')'
3381+ 29E6 F1                   pop     AF              ; Restore starting position
3382+ 29E7 E3                   ex      (SP),HL         ; Get string,save code string
3383+ 29E8 01 9F 28             ld      BC,MID1         ; Continuation of MID$ routine
3384+ 29EB C5                   push    BC              ; Save for return
3385+ 29EC 3D                   dec     A               ; Starting position-1
3386+ 29ED BE                   cp      (HL)            ; Compare with length
3387+ 29EE 06 00                ld      B,$00           ; Zero bytes length
3388+ 29F0 D0                   ret     NC              ; Null string if start past end
3389+ 29F1 4F                   ld      C,A             ; Save starting position-1
3390+ 29F2 7E                   ld      A,(HL)          ; Get length of string
3391+ 29F3 91                   sub     C               ; Subtract start
3392+ 29F4 BB                   cp      E               ; Enough string for it?
3393+ 29F5 47                   ld      B,A             ; Save maximum length available
3394+ 29F6 D8                   ret     C               ; Truncate string if needed
3395+ 29F7 43                   ld      B,E             ; Set specified length
3396+ 29F8 C9                   ret                     ; Go and create string
3397+ 29F9
3398+ 29F9
3399+ 29F9              ; return the value of a numeric string
3400+ 29F9 CD 6D 28     VAL:    call    GETLEN          ; Get length of string
3401+ 29FC CA CB 2D             jp      Z,RESZER        ; Result zero
3402+ 29FF 5F                   ld      E,A             ; Save length
3403+ 2A00 23                   inc     HL
3404+ 2A01 23                   inc     HL
3405+ 2A02 7E                   ld      A,(HL)          ; Get LSB of address
3406+ 2A03 23                   inc     HL
3407+ 2A04 66                   ld      H,(HL)          ; Get MSB of address
3408+ 2A05 6F                   ld      L,A             ; HL = String address
3409+ 2A06 E5                   push    HL              ; Save string address
3410+ 2A07 19                   add     HL,DE
3411+ 2A08 46                   ld      B,(HL)          ; Get end of string+1 byte
3412+ 2A09 72                   ld      (HL),D          ; Zero it to terminate
3413+ 2A0A E3                   ex      (SP),HL         ; Save string end,get start
3414+ 2A0B C5                   push    BC              ; Save end+1 byte
3415+ 2A0C 7E                   ld      A,(HL)          ; Get starting byte
3416+ 2A0D FE 24                cp      '$'             ; Hex number indicated? [function added]
3417+ 2A0F C2 17 2A             jp      NZ,VAL1
3418+ 2A12 CD 6C 40             call    HEXTFP          ; Convert Hex to FPREG
3419+ 2A15 18 0D                jr      VAL3
3420+ 2A17 FE 25        VAL1:   cp      '%'             ; Binary number indicated? [function added]
3421+ 2A19 C2 21 2A             jp      NZ,VAL2
3422+ 2A1C CD DC 40             call    BINTFP          ; Convert Bin to FPREG
3423+ 2A1F 18 03                jr      VAL3
3424+ 2A21 CD 03 31     VAL2:   call    ASCTFP          ; Convert ASCII string to FP
3425+ 2A24 C1           VAL3:   pop     BC              ; Restore end+1 byte
3426+ 2A25 E1                   pop     HL              ; Restore end+1 address
3427+ 2A26 70                   ld      (HL),B          ; Put back original byte
3428+ 2A27 C9                   ret
3429+ 2A28
3430+ 2A28 EB           LFRGNM: ex      DE,HL           ; Code string address to HL
3431+ 2A29 CD 15 1B             call    CHKSYN          ; Make sure ")" follows
3432+ 2A2C 29                   defb    ')'
3433+ 2A2D C1           MIDNUM: pop     BC              ; Get return address
3434+ 2A2E D1                   pop     DE              ; Get number supplied
3435+ 2A2F C5                   push    BC              ; Re-save return address
3436+ 2A30 43                   ld      B,E             ; Number to B
3437+ 2A31 C9                   ret
3438+ 2A32
3439+ 2A32 CD 78 2A     INP:    call    MAKINT          ; Make it integer A
3440+ 2A35 32 1A 54             ld      (INPORT),A      ; Set input port
3441+ 2A38 CD 19 54             call    INPSUB          ; Get input from port
3442+ 2A3B C3 E8 25             jp      PASSA           ; Return integer A
3443+ 2A3E
3444+ 2A3E CD 62 2A     POUT:   call    SETIO           ; Set up port number
3445+ 2A41 C3 E1 53             jp      OUTSUB          ; Output data and return
3446+ 2A44
3447+ 2A44 CD 62 2A     WAIT:   call    SETIO           ; Set up port number
3448+ 2A47 F5                   push    AF              ; Save AND mask
3449+ 2A48 1E 00                ld      E,$00           ; Assume zero if none given
3450+ 2A4A 2B                   dec     HL              ; dec 'cos GETCHR INCs
3451+ 2A4B CD 5E 1D             call    GETCHR          ; Get next character
3452+ 2A4E CA 58 2A             jp      Z,NOXOR         ; No XOR byte given
3453+ 2A51 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
3454+ 2A54 2C                   defb    ','
3455+ 2A55 CD 75 2A             call    GETINT          ; Get integer 0-255 to XOR with
3456+ 2A58 C1           NOXOR:  pop     BC              ; Restore AND mask
3457+ 2A59 CD 19 54     WAITLP: call    INPSUB          ; Get input
3458+ 2A5C AB                   xor     E               ; Flip selected bits
3459+ 2A5D A0                   and     B               ; Result non-zero?
3460+ 2A5E CA 59 2A             jp      Z,WAITLP        ; No = keep waiting
3461+ 2A61 C9                   ret
3462+ 2A62
3463+ 2A62 CD 75 2A     SETIO:  call    GETINT          ; Get integer 0-255
3464+ 2A65 32 1A 54             ld      (INPORT),A      ; Set input port
3465+ 2A68 32 E2 53             ld      (OTPORT),A      ; Set output port
3466+ 2A6B CD 15 1B             call    CHKSYN          ; Make sure ',' follows
3467+ 2A6E 2C                   defb    ','
3468+ 2A6F C3 75 2A             jp      GETINT          ; Get integer 0-255 and return
3469+ 2A72
3470+ 2A72 CD 5E 1D     FNDNUM: call    GETCHR          ; Get next character
3471+ 2A75 CD EF 21     GETINT: call    GETNUM          ; Get a number from 0 to 255
3472+ 2A78 CD 0E 1E     MAKINT: call    DEPINT          ; Make sure value 0 - 255
3473+ 2A7B 7A                   ld      A,D             ; Get MSB of number
3474+ 2A7C B7                   or      A               ; Zero?
3475+ 2A7D C2 29 1E             jp      NZ,FCERR        ; No - Error
3476+ 2A80 2B                   dec     HL              ; dec 'cos GETCHR INCs
3477+ 2A81 CD 5E 1D             call    GETCHR          ; Get next character
3478+ 2A84 7B                   ld      A,E             ; Get number to A
3479+ 2A85 C9                   ret
3480+ 2A86
3481+ 2A86
3482+ 2A86              ; activate a Non-Maskable Interrupt hooked to VDP interrupt signal
3483+ 2A86              ; address must point to an ISR routine that terminates with EI/RETN instructions
3484+ 2A86 CD EF 21     NMI:    call    GETNUM          ; Get memory address
3485+ 2A89 CD 14 1E             call    DEINT           ; get integer -32768 to 32767
3486+ 2A8C 7B                   ld      A,E             ; check if address is 0
3487+ 2A8D B2                   or      D
3488+ 2A8E 20 11                jr      NZ,NM1          ; no, so jump over
3489+ 2A90 F3           DISNMI: di                      ; disable INTs
3490+ 2A91 CD BD 2A             call    NMIDINT         ; disable VDP INT
3491+ 2A94 E5                   push    HL              ; store HL
3492+ 2A95 21 ED 45             ld      HL,$45ED        ; these are the op-codes for "RETN"
3493+ 2A98 22 DB 53             ld      (NMIUSR),HL     ; store RETN
3494+ 2A9B AF                   xor     A
3495+ 2A9C 32 DD 53             ld      (NMIUSR+2),A    ; "NOP"
3496+ 2A9F 18 11                jr      NMI2            ; execute the last part of code
3497+ 2AA1 E5           NM1:    push    HL              ; store current HL
3498+ 2AA2 EB                   ex      DE,HL           ; move address argument into HL
3499+ 2AA3 F3                   di                      ; disable INTs
3500+ 2AA4 CD BD 2A             call    NMIDINT         ; disable VDP INT, if enabled
3501+ 2AA7 3E C3                ld      A,$C3           ; "jp" instruction
3502+ 2AA9 32 DB 53             ld      (NMIUSR),A      ; store it
3503+ 2AAC 22 DC 53             ld      (NMIUSR+1),HL   ; store address
3504+ 2AAF CD B6 2A             call    NMIEINT         ; re-enable VDP INT
3505+ 2AB2 FB           NMI2:   ei                      ; re-enable INTS
3506+ 2AB3 00                   nop                     ; wait for INTs
3507+ 2AB4 E1                   pop    HL               ; retrieve HL
3508+ 2AB5 C9                   ret                     ; return to caller
3509+ 2AB6              ; enable VDP INT
3510+ 2AB6 CD CC 2A     NMIEINT:call    NMIVR1          ; load default VReg #1 setting
3511+ 2AB9 F6 20                or      %00100000       ; enable VDP INT
3512+ 2ABB 18 03                jr      NMIINT          ; rest of code is shared
3513+ 2ABD              ; disable VDP INT
3514+ 2ABD CD CC 2A     NMIDINT:call    NMIVR1          ; load default VReg #1 setting
3515+ 2AC0 D5           NMIINT: push    DE              ; store DE
3516+ 2AC1 5F                   ld      E,A             ; move value into E
3517+ 2AC2 3E 01                ld      A,$01           ; VREG #1
3518+ 2AC4 F3                   di                      ; disable INTs
3519+ 2AC5 CD BA 06             call    WRITE_VREG      ; disable VDP INT
3520+ 2AC8 FB                   ei                      ; re-enable INTs
3521+ 2AC9 00                   nop                     ; wait for INTs being enabled
3522+ 2ACA D1                   pop     DE              ; retrieve DE
3523+ 2ACB C9                   ret                     ; return to caller
3524+ 2ACC
3525+ 2ACC              ; load VREG #1 setting for current screen mode and return it into A
3526+ 2ACC E5           NMIVR1: push    HL              ; store HL
3527+ 2ACD D5                   push    DE              ; store DE
3528+ 2ACE 3A 6E 55             ld      A,(SCR_MODE)    ; check screen mode
3529+ 2AD1 87                   add     A,A             ; multiply A by 8...
3530+ 2AD2 87                   add     A,A             ; ...so that reg. A can points..
3531+ 2AD3 87                   add     A,A             ; to the correct settings
3532+ 2AD4 3C                   inc     A               ; need to change VREG 1
3533+ 2AD5 5F                   ld      E,A             ; copy A into E
3534+ 2AD6 16 00                ld      D,$00           ; reset D
3535+ 2AD8 21 29 0B             ld      HL,VDPMODESET   ; pointer to register #1 setting...
3536+ 2ADB 19                   add     HL,DE           ; ...for current screen mode
3537+ 2ADC 7E                   ld      A,(HL)          ; load current setting
3538+ 2ADD D1                   pop     DE              ; retrieve DE
3539+ 2ADE E1                   pop     HL              ; retrieve HL
3540+ 2ADF C9                   ret                     ; return to caller
3541+ 2AE0
3542+ 2AE0              ; execute a machine language routine, eventually passing a param into A
3543+ 2AE0 CD EF 21     SYS:    call    GETNUM          ; Get memory address
3544+ 2AE3 CD 14 1E             call    DEINT           ; Get integer -32768 to 32767
3545+ 2AE6 ED 53 7E 55          ld      (TMPBFR2),DE    ; store user routine's address
3546+ 2AEA AF                   xor     A               ; reset A
3547+ 2AEB 32 7C 55             ld      (TMPBFR1),A     ; store into temp buffer
3548+ 2AEE 2B                   dec     HL              ; dec 'cos GETCHR INCs
3549+ 2AEF CD 5E 1D             call    GETCHR          ; check next character
3550+ 2AF2 28 0A                jr      Z,NOSYSPR       ; jump if nothing follows
3551+ 2AF4 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
3552+ 2AF7 2C                   defb    ','
3553+ 2AF8 CD 75 2A             call    GETINT          ; get byte value (0~255) if something follows
3554+ 2AFB 32 7C 55             ld      (TMPBFR1),A     ; store into temp buffer
3555+ 2AFE 3A 7C 55     NOSYSPR:ld      A,(TMPBFR1)     ; recover A
3556+ 2B01 ED 5B 7E 55          ld      DE,(TMPBFR2)    ; recover user routine's address
3557+ 2B05 E5                   push    HL              ; save code string address
3558+ 2B06 EB                   ex      DE,HL           ; move user routine's address into HL
3559+ 2B07 11 0C 2B             ld      DE,SYSRET       ; set point of return after the user routine
3560+ 2B0A D5                   push    DE              ; store into stack
3561+ 2B0B E9                   jp      (HL)            ; call user routine
3562+ 2B0C E1           SYSRET: pop     HL              ; retrieve code string address
3563+ 2B0D C9                   ret                     ; return to caller
3564+ 2B0E
3565+ 2B0E
3566+ 2B0E              ; read the contents of a RAM location
3567+ 2B0E CD 14 1E     PEEK:   call    DEINT           ; Get memory address into DE
3568+ 2B11 1A                   ld      A,(DE)          ; Read value of memory cell
3569+ 2B12 C3 E8 25             jp      PASSA           ; Return into A
3570+ 2B15
3571+ 2B15              ; read the contents of a VRAM location
3572+ 2B15 CD 14 1E     VPEEK:  call    DEINT           ; Get VRAM address into DE
3573+ 2B18 EB                   ex      DE,HL           ; Copy param into HL
3574+ 2B19 F3                   di                      ; Disable interrupts
3575+ 2B1A CD 90 06             call    READ_VIDEO_LOC  ; Read data from VRAM at address HL
3576+ 2B1D FB                   ei                      ; Re-enable interrupts
3577+ 2B1E EB                   ex      DE,HL           ; Restore HL
3578+ 2B1F C3 E8 25             jp      PASSA           ; Return value into A
3579+ 2B22
3580+ 2B22              ; recover params for POKE/VPOKE commands
3581+ 2B22              ; returns address into DE and byte to be written into A
3582+ 2B22 CD EF 21     PKEPRMS:call    GETNUM          ; Get memory address
3583+ 2B25 CD 14 1E             call    DEINT           ; Get integer -32768 to 32767
3584+ 2B28 ED 53 7C 55          ld      (TMPBFR1),DE    ; Store DE into a temp. buffer
3585+ 2B2C CD 15 1B             call    CHKSYN          ; Make sure ',' follows
3586+ 2B2F 2C                   defb    ','
3587+ 2B30 CD 75 2A             call    GETINT          ; Get integer 0-255
3588+ 2B33 ED 5B 7C 55          ld      DE,(TMPBFR1)    ; Restore memory address
3589+ 2B37 C9                   ret                     ; Return to caller
3590+ 2B38
3591+ 2B38              ; write a byte into a RAM location
3592+ 2B38 CD 22 2B     POKE:   call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3593+ 2B3B 12                   ld      (DE),A          ; Load it into memory
3594+ 2B3C C9                   ret
3595+ 2B3D
3596+ 2B3D              ; write a byte into a VRAM location
3597+ 2B3D CD 22 2B     VPOKE:  call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3598+ 2B40 EB                   ex      DE,HL           ; Copy address into HL
3599+ 2B41 F3                   di                      ; Disable interrupts
3600+ 2B42 CD A5 06             call    WRITE_VIDEO_LOC ; write data into VRAM at address HL
3601+ 2B45 FB                   ei                      ; Re-enable interrupts
3602+ 2B46 EB                   ex      DE,HL           ; Restore HL
3603+ 2B47 C9                   ret                     ; Return to caller
3604+ 2B48
3605+ 2B48              ; position the cursor at a specific X,Y location onto screen
3606+ 2B48 CD 75 2A     LOCATE: call    GETINT          ; get the first param into A
3607+ 2B4B E5                   push    HL              ; store HL
3608+ 2B4C 21 6C 55             ld      HL,SCR_SIZE_W   ; load address of screen width
3609+ 2B4F 5E                   ld      E,(HL)          ; load screen width into E
3610+ 2B50 E1                   pop     HL              ; restore HL
3611+ 2B51 BB                   cp      E               ; compare witdh with param
3612+ 2B52 D2 29 1E             jp      NC,FCERR        ; value over the width of the screen, exit with Illegal F.C. error
3613+ 2B55 32 7C 55             ld      (TMPBFR1),A     ; Store X into a temp. buffer
3614+ 2B58 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
3615+ 2B5B 2C                   defb    ','
3616+ 2B5C CD 75 2A             call    GETINT          ; Get the second param into A
3617+ 2B5F E5                   push    HL              ; store HL
3618+ 2B60 21 6D 55             ld      HL,SCR_SIZE_H   ; load address of screen width
3619+ 2B63 5E                   ld      E,(HL)          ; load screen width into A
3620+ 2B64 E1                   pop     HL              ; restore HL
3621+ 2B65 BB                   cp      E               ; compare witdh with param
3622+ 2B66 D2 29 1E             jp      NC,FCERR        ; value over the height of the screen, exit with Illegal F.C. error
3623+ 2B69 32 74 55             ld      (SCR_CUR_NY),A  ; store new Y
3624+ 2B6C 3A 7C 55             ld      A,(TMPBFR1)     ; recover the new X
3625+ 2B6F 32 73 55             ld      (SCR_CUR_NX),A  ; store new X
3626+ 2B72 E5                   push    HL              ; store HL
3627+ 2B73 F3                   di                      ; disable INTs
3628+ 2B74 CD D6 06             call    MOVCRS          ; move cursor to new location
3629+ 2B77 FB                   ei                      ; re-enable INTs
3630+ 2B78 E1                   pop     HL              ; restore HL
3631+ 2B79 C9                   ret                     ; return to caller
3632+ 2B7A
3633+ 2B7A              ; write a byte into one of the PSG registers
3634+ 2B7A CD 75 2A     SREG:   call    GETINT          ; Get register number back into A
3635+ 2B7D FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3636+ 2B7F D2 29 1E             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3637+ 2B82 32 7C 55             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3638+ 2B85 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
3639+ 2B88 2C                   defb    ','
3640+ 2B89 CD 75 2A             call    GETINT          ; get second value (0-255), returned into A
3641+ 2B8C 5F                   ld      E,A             ; store value into E
3642+ 2B8D 3A 7C 55             ld      A,(TMPBFR1)     ; recover VDP register and store into D
3643+ 2B90 F3                   di                      ; disable INTs
3644+ 2B91 0E 40                ld      C,PSG_REG       ; output port to access PSG registers
3645+ 2B93 ED 79                out     (C),A           ; send register # to PSG
3646+ 2B95 0E 41                ld      C,PSG_DAT       ; output port to send data to PSG
3647+ 2B97 ED 59                out     (C),E           ; send byte to write into selected register
3648+ 2B99 FB                   ei                      ; re-enable INTs
3649+ 2B9A C9                   ret                     ; return to caller
3650+ 2B9B
3651+ 2B9B              ; VOLUME ch,vol
3652+ 2B9B              ; set the volume for the audio channels
3653+ 2B9B              ; "ch" is 1~3 for corresponding channel, or 0 for all; "vol" is 0~15 (0=OFF, 15=MAX)
3654+ 2B9B CD 75 2A     VOLUME: call    GETINT          ; get integer 0-255 (recover channel)
3655+ 2B9E FE 04                cp      $04             ; check if it's in the range 0~3
3656+ 2BA0 D2 29 1E             jp      NC,FCERR        ; if not, exit with Illegal function call error
3657+ 2BA3 32 7C 55             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3658+ 2BA6 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
3659+ 2BA9 2C                   defb    ','
3660+ 2BAA CD 75 2A             call    GETINT          ; get integer 0-255 (recover channel)
3661+ 2BAD FE 10                cp      $10             ; check if it's in the range 0~15
3662+ 2BAF D2 29 1E             jp      NC,FCERR        ; if not, exit with Illegal funcion call
3663+ 2BB2 57                   ld      D,A             ; store volume into D
3664+ 2BB3 3A 7C 55             ld      A,(TMPBFR1)     ; retrieve channel
3665+ 2BB6 A7                   and     A               ; is it 0? (0=every channel)
3666+ 2BB7 20 10                jr      NZ,VOLCH        ; no, jump over
3667+ 2BB9 06 03                ld      B,$03           ; yes, set every channel
3668+ 2BBB 1E 08                ld      E,$08           ; register volume of first channel
3669+ 2BBD 0E 40        RPVOLCG:ld      C,PSG_REG       ; PSG register port
3670+ 2BBF ED 59                out     (C),E           ; set register #
3671+ 2BC1 0E 41                ld      C,PSG_DAT       ; PSG data port
3672+ 2BC3 ED 51                out     (C),D           ; send volume
3673+ 2BC5 1C                   inc     E               ; next register
3674+ 2BC6 10 F5                djnz    RPVOLCG         ; repeat for each channel
3675+ 2BC8 C9                   ret                     ; return to caller
3676+ 2BC9 0E 40        VOLCH:  ld      C,PSG_REG       ; PSG register port
3677+ 2BCB C6 07                add     $07             ; add 7 to A so that we have the correct register (1->8, 2->9, 3->10)
3678+ 2BCD ED 79                out     (C),A           ; set register
3679+ 2BCF 0E 41                ld      C,PSG_DAT       ; PSG data port
3680+ 2BD1 ED 51                out     (C),D           ; send volume level
3681+ 2BD3 C9                   ret                     ; return to caller
3682+ 2BD4
3683+ 2BD4              ; SOUND ch,tone,dur
3684+ 2BD4              ; play a tone or noise of "tone" frequency from selected channel "ch" for duration "dur"
3685+ 2BD4              ; "ch" is 1~6 (0=means sound OFF,1~3 for tone, 4~6 for noise) / "tone" is 1~4,095 (0=means no tone) /
3686+ 2BD4              ; "dur" is 1~16383 h.o.s.,0.001~163s (0=means non-stop tone)
3687+ 2BD4 CD 75 2A     SOUND:  call    GETINT          ; get integer 0-255 (recover channel)
3688+ 2BD7 A7                   and     A               ; is it zero?
3689+ 2BD8 20 08                jr      NZ,CTSNDC       ; no, continue with checking of params
3690+ 2BDA E5                   push    HL              ; store HL
3691+ 2BDB F3                   di                      ; disable INTs
3692+ 2BDC CD 9B 0C             call    CLRPSGREGS      ; yes, it's zero, so reset PSG registers to shut down every sound
3693+ 2BDF FB                   ei                      ; re-enable INTs
3694+ 2BE0 E1                   pop     HL              ; retrieve HL
3695+ 2BE1 C9                   ret                     ; return to caller
3696+ 2BE2 32 7C 55     CTSNDC: ld      (TMPBFR1),A     ; no, continue by storing A into a temp. buffer
3697+ 2BE5 FE 04                cp      $04             ; is channel >3?
3698+ 2BE7 D2 66 2C             jp      NC,NOISUP       ; Yes - check to see if it's a noise channel
3699+ 2BEA CD 15 1B             call    CHKSYN          ; No, continue checking by making sure ',' follows
3700+ 2BED 2C                   defb    ','
3701+ 2BEE CD EF 21             call    GETNUM          ; Get tone frequency
3702+ 2BF1 CD 14 1E             call    DEINT           ; Get integer -32768 to 32767
3703+ 2BF4 ED 53 7E 55          ld      (TMPBFR2),DE    ; Store frequency
3704+ 2BF8 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
3705+ 2BFB 2C                   defb    ','
3706+ 2BFC CD EF 21             call    GETNUM          ; Get duration
3707+ 2BFF CD 14 1E             call    DEINT           ; Get integer -32768 to 32767
3708+ 2C02 ED 53 80 55          ld      (TMPBFR3),DE    ; Store duration
3709+ 2C06                                              ; CHECK CHANNEL
3710+ 2C06 3A 7C 55             ld      A,(TMPBFR1)     ; recover channel
3711+ 2C09 FE 01                cp      $01             ; is channel <1?
3712+ 2C0B DA 29 1E             jp      C,FCERR         ; Yes - Illegal function call error
3713+ 2C0E                                              ; CHECK FREQUENCY
3714+ 2C0E ED 5B 7E 55          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3715+ 2C12 7A                   ld      A,D             ; move D into A and check if it is in the range 0~4095...
3716+ 2C13 FE 10                cp      $10             ; ...so D must not be greater than $0F (15)
3717+ 2C15 D2 29 1E             jp      NC,FCERR        ; if not in the range, exit with an Illegal function call error
3718+ 2C18                                              ; CHECK DURATION
3719+ 2C18 ED 5B 80 55          ld      DE,(TMPBFR3)    ; restore duration from temp buffer
3720+ 2C1C 7A                   ld      A,D             ; check if it is in the range 0~16383...
3721+ 2C1D E6 C0                and     $C0             ; ...(15th & 14th bits must not be set)
3722+ 2C1F C2 29 1E             jp      NZ,FCERR        ; if not in the range, exit with an Illegal function call error
3723+ 2C22                                              ;
3724+ 2C22                                              ; SET TONE:
3725+ 2C22                                              ; let's start by setting up the channel
3726+ 2C22 3A 7C 55             ld      A,(TMPBFR1)     ; restore channel value
3727+ 2C25 FE 03                cp      $03             ; is it 3?
3728+ 2C27 20 02                jr      NZ,SND1         ; no, jump over
3729+ 2C29 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3730+ 2C2B 2F           SND1:   cpl                     ; complement of A - this is used later to set on the channel into the mixer
3731+ 2C2C CD B3 2C             call    WRTSND          ; enable line into mixer of channel stored in A
3732+ 2C2F                                              ; SET FREQUENCY
3733+ 2C2F                                              ; we simply get frequency and subtract from 4096. The result
3734+ 2C2F                                              ; is put into register pair of the corresponding freq tone channel
3735+ 2C2F ED 5B 7E 55          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3736+ 2C33 E5                   push    HL              ; store HL (it will be used by the subroutine)
3737+ 2C34 21 00 10             ld      HL,$1000        ; load 4096 into HL
3738+ 2C37 A7                   and     A               ; reset C flag
3739+ 2C38 ED 52                sbc     HL,DE           ; subtract freq from HL - now the frequency is inverted, so we will send the low as high and vice-versa
3740+ 2C3A 3A 7C 55             ld      A,(TMPBFR1)     ; restore channel value
3741+ 2C3D 3D                   dec     A               ; set A into the range 0~2
3742+ 2C3E 87                   add     A,A             ; double A to find the register pair that correspond to the channel (A->0,1 / B->2,3, C->4,5)
3743+ 2C3F 0E 40                ld      C,PSG_REG       ; PSG register port
3744+ 2C41 ED 79                out     (C),A           ; select first register of the pair
3745+ 2C43 0E 41                ld      C,PSG_DAT       ; PSG data port
3746+ 2C45 ED 69                out     (C),L           ; send high byte
3747+ 2C47 0E 40                ld      C,PSG_REG       ; PSG register support
3748+ 2C49 3C                   inc     A               ; second register of the pair
3749+ 2C4A ED 79                out     (C),A           ; select register
3750+ 2C4C 0E 41                ld      C,PSG_DAT       ; PSG data port
3751+ 2C4E ED 61                out     (C),H           ; send low byte
3752+ 2C50 ED 5B 80 55          ld      DE,(TMPBFR3)    ; recover duration
3753+ 2C54 3A 7C 55             ld      A,(TMPBFR1)     ; recover channel value
3754+ 2C57 3D                   dec     A               ; set channel into the range 0~2
3755+ 2C58 87                   add     A,A             ; double A to find the correct offset
3756+ 2C59 21 B0 55             ld      HL,CHASNDDTN    ; set duration into...
3757+ 2C5C 85                   add     A,L             ; ...the proper...
3758+ 2C5D 30 01                jr      NC,SNDOVR       ; (is there a rest? no, jump over
3759+ 2C5F 24                   inc     H               ; yes, increment H)
3760+ 2C60 6F           SNDOVR: ld      L,A             ; ...register pair...
3761+ 2C61 73                   ld      (HL),E          ; ...and store the value
3762+ 2C62 23                   inc     HL
3763+ 2C63 72                   ld      (HL),D
3764+ 2C64 E1                   pop     HL              ; retrieve HL
3765+ 2C65 C9                   ret                     ; Return to caller
3766+ 2C66 FE 07        NOISUP: cp      $07             ; is channel in range 4 to 6 (for a noise)?
3767+ 2C68 D2 29 1E             jp      NC,FCERR        ; no, so ILLEGAL FUNCTION CALL
3768+ 2C6B CD 15 1B             call    CHKSYN          ; yes, continue checking by making sure ',' follows
3769+ 2C6E 2C                   defb    ','
3770+ 2C6F CD 75 2A             call    GETINT          ; get integer 0-255 (frequency)
3771+ 2C72 FE 20                cp      $20             ; make sure it's in range 0~31
3772+ 2C74 D2 29 1E             jp      NC,FCERR        ; no, so Illegal function call
3773+ 2C77 32 7E 55             ld      (TMPBFR2),A     ; store freq.
3774+ 2C7A 2B                   dec     HL              ; dec 'cos GETCHR INCs
3775+ 2C7B CD 5E 1D             call    GETCHR          ; check that nothing follows
3776+ 2C7E C2 17 18             jp      NZ,SNERR        ; error if no empty line
3777+ 2C81 3A 7E 55             ld      A,(TMPBFR2)     ; retrieve freq.
3778+ 2C84 5F                   ld      E,A             ; store freq into E
3779+ 2C85 3A 7C 55             ld      A,(TMPBFR1)     ; retrieve channel
3780+ 2C88 D6 03                sub     $03             ; subtract 3 to get channel in range 1~3
3781+ 2C8A FE 03                cp      $03             ; is it 3?
3782+ 2C8C 20 02                jr      NZ,NOS1         ; no, jump over
3783+ 2C8E 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3784+ 2C90 87           NOS1:   add     A,A
3785+ 2C91 87                   add     A,A
3786+ 2C92 87                   add     A,A             ; let's move A 3 bits to left
3787+ 2C93 47                   ld      B,A             ; store channel into B
3788+ 2C94 7B                   ld      A,E             ; check if
3789+ 2C95 A7                   and     A               ; freq is 0 (means that noise reproduction must be halted)
3790+ 2C96 F3                   di                      ; disable INts
3791+ 2C97 20 0A                jr      NZ,NOS2         ; no, so jump over
3792+ 2C99 3E 07                ld      A,$07           ; mixer register
3793+ 2C9B CD E9 0C             call    SETSNDREG       ; set mixer register
3794+ 2C9E ED 78                in      A,(C)           ; load current mixer value
3795+ 2CA0 B0                   or      B               ; disable noise
3796+ 2CA1 18 19                jr      NOS3            ; continue over
3797+ 2CA3 78           NOS2:   ld      A,B             ; recover channel
3798+ 2CA4 2F                   cpl                     ; complement of A - this is used to set on the channel into the mixer
3799+ 2CA5 CD B3 2C             call    WRTSND          ; enable line into mixer of channel stored in A
3800+ 2CA8 3E 06                ld      A,$06           ; write into noise register
3801+ 2CAA CD E9 0C             call    SETSNDREG       ; set register into PSG
3802+ 2CAD 7B                   ld      A,E             ; load value for noise frequency
3803+ 2CAE CD EE 0C             call    WRTSNDREG       ; write data into register $06
3804+ 2CB1 FB                   ei                      ; re-enable INTs
3805+ 2CB2 C9                   ret
3806+ 2CB3                      ; enable line into mixer of channel stored in A
3807+ 2CB3 47           WRTSND: ld      B,A             ; move channel into B
3808+ 2CB4 3E 07                ld      A,$07           ; mixer register
3809+ 2CB6 CD E9 0C             call    SETSNDREG       ; set mixer register
3810+ 2CB9 ED 78                in      A,(C)           ; load current value
3811+ 2CBB A0                   and     B               ; set on the channel into the mixer (remember that 0=ON)
3812+ 2CBC                                              ; example: if channel is A (1), complement of 1 is 254 (11111110). So, 255 (in case
3813+ 2CBC                                              ; the register is still unchanged after reset) is 11111111 and
3814+ 2CBC                                              ; 11111111 AND 11111110 is equal to 11111110
3815+ 2CBC                                              ; 11111001 AND 11111110 is equal to 11111000 (in case channels B & C are ON)
3816+ 2CBC 47           NOS3:   ld      B,A             ; store new mixer value into B
3817+ 2CBD 3E 07                ld      A,$07           ; mixer address
3818+ 2CBF CD E9 0C             call    SETSNDREG       ; set register
3819+ 2CC2 78                   ld      A,B             ; retrieve new mixer value from B
3820+ 2CC3 CD EE 0C             call    WRTSNDREG       ; send new value for the mixer
3821+ 2CC6 FB                   ei                      ; re-enable INTs
3822+ 2CC7 C9                   ret                     ; return to caller
3823+ 2CC8
3824+ 2CC8              ; write a byte into one of the VDP registers
3825+ 2CC8 CD 75 2A     VREG:   call    GETINT          ; Get register number back into A
3826+ 2CCB FE 08                cp      $08             ; check if value is equal or greater than 8 (VDP registers are only 8, from 0 to 7)
3827+ 2CCD D2 29 1E             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3828+ 2CD0 32 7C 55             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3829+ 2CD3 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
3830+ 2CD6 2C                   defb    ','
3831+ 2CD7 CD 75 2A             call    GETINT          ; get value (0-255)
3832+ 2CDA 5F                   ld      E,A             ; store value into E
3833+ 2CDB 3A 7C 55             ld      A,(TMPBFR1)     ; recover VDP register and store into A
3834+ 2CDE F3                   di                      ; disable INTs
3835+ 2CDF CD BA 06             call    WRITE_VREG      ; write value into VDP register
3836+ 2CE2 FB                   ei                      ; re-enable INTs
3837+ 2CE3 C9                   ret                     ; return to caller
3838+ 2CE4
3839+ 2CE4              ; read the VDP status register and return it into A
3840+ 2CE4 CD 14 1E     VSTAT:  call    DEINT           ; Get integer -32768 to 32767 (Note: we do NOT use it)
3841+ 2CE7 F3                   di                      ; disable INTs
3842+ 2CE8 CD C5 06             call    READ_VSTAT      ; read VDP register status
3843+ 2CEB FB                   ei                      ; re-enable INTs
3844+ 2CEC C3 E8 25             jp      PASSA           ; Return integer A
3845+ 2CEF
3846+ 2CEF              ; read from PSG register and return it into A
3847+ 2CEF CD 14 1E     SSTAT:  call    DEINT           ; get integer -32768 to 32767
3848+ 2CF2 7B                   ld      A,E             ; consider LSB
3849+ 2CF3 FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3850+ 2CF5 D2 29 1E             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3851+ 2CF8 F3                   di                      ; disable INts
3852+ 2CF9 0E 40                ld      C,PSG_REG       ; output port to set PSG register
3853+ 2CFB ED 79                out     (C),A           ; send register to read from
3854+ 2CFD ED 78                in      A,(C)           ; read register's contents and store into A
3855+ 2CFF FB                   ei                      ; re-enable INTs
3856+ 2D00 C3 E8 25             jp      PASSA           ; return A
3857+ 2D03
3858+ 2D03              ; read the temp key buffer and return the value of the current key being pressed
3859+ 2D03              ; can wait for the number of 100thds of second before to return
3860+ 2D03 CD 62 26     INKEY:  call    IDTEST          ; Test for illegal direct
3861+ 2D06 CD 14 1E             call    DEINT           ; get number param (100thds of second to wait) into DE
3862+ 2D09 C5                   push    BC              ; store BC
3863+ 2D0A 3A 5C 55             ld      A,(TMRCNT)      ; Load current value of system timer
3864+ 2D0D 47                   ld      B,A             ; move it into B
3865+ 2D0E 3A 5C 55     CMP_A:  ld      A,(TMRCNT)      ; make a little delay of 1/100 sec...
3866+ 2D11 B8                   cp      B               ; ...to let the sniffer collect...
3867+ 2D12 20 FA                jr      NZ,CMP_A        ; ...at least 1 char before to continue
3868+ 2D14 7A                   ld      A,D             ; check the param
3869+ 2D15 B3                   or      E               ; if DE<>0 then...
3870+ 2D16 20 05                jr      NZ,INKEY2       ; ...jump over...
3871+ 2D18 3A B8 55             ld      A,(TMPKEYBFR)   ; ...else read the buffer and...
3872+ 2D1B 18 2A                jr      ENDINK          ; ...return it
3873+ 2D1D 7A           INKEY2: ld      A,D             ; check if param>1023
3874+ 2D1E FE 04                cp      $04             ; to do this we check if MSB>3
3875+ 2D20 D2 29 1E             jp      NC,FCERR        ; if MSB >=4 then error
3876+ 2D23 E5                   push    HL              ; store HL
3877+ 2D24 21 09 00             ld      HL,$0009        ; check if value
3878+ 2D27 CD 38 41             call    CMP16           ; is < 10
3879+ 2D2A E1                   pop     HL              ; retrieve HL
3880+ 2D2B DA 31 2D             jp      C,SRTINK        ; if value >= 10 then jump over
3881+ 2D2E 11 0A 00             ld      DE,$000A        ; else, use 10 (no intervals shorter than 10/100s)
3882+ 2D31 3A 5C 55     SRTINK: ld      A,(TMRCNT)      ; Load the first byte of the system timer
3883+ 2D34 47                   ld      B,A             ; move it into B
3884+ 2D35 3A B8 55     CHKINK: ld      A,(TMPKEYBFR)   ; load char code from buffer
3885+ 2D38 A7                   and     A               ; is it 0?
3886+ 2D39 20 0C                jr      NZ,ENDINK       ; no, so we can return it
3887+ 2D3B 3A 5C 55             ld      A,(TMRCNT)      ; load the first byte of the system timer
3888+ 2D3E B8                   cp      B               ; is it the same value?
3889+ 2D3F 28 F4                jr      Z,CHKINK        ; yes, so read again
3890+ 2D41 47                   ld      B,A             ; store new value
3891+ 2D42 1B                   dec     DE              ; no, decrement timer
3892+ 2D43 7A                   ld      A,D             ; check if zero reached
3893+ 2D44 B3                   or      E               ; by ORing D and E
3894+ 2D45 20 EE                jr      NZ,CHKINK       ; if not 0, repeat
3895+ 2D47 C1           ENDINK: pop     BC              ; restore BC
3896+ 2D48 F5                   push    AF              ; store A
3897+ 2D49 F3                   di                      ; disable INTs
3898+ 2D4A AF                   xor     A               ; clear the...
3899+ 2D4B 32 B8 55             ld      (TMPKEYBFR),A   ; ...TMP KEY buffer for the next read
3900+ 2D4E FB                   ei                      ; re-enable INTs
3901+ 2D4F F1                   pop     AF              ; retrieve A
3902+ 2D50 C3 E8 25             jp      PASSA           ; return A as ASCII value
3903+ 2D53
3904+ 2D53
3905+ 2D53 21 7A 32     ROUND:  ld      HL,HALF         ; Add 0.5 to FPREG
3906+ 2D56 CD 4B 30     ADDPHL: call    LOADFP          ; Load FP at (HL) to BCDE
3907+ 2D59 C3 65 2D             jp      FPADD           ; Add BCDE to FPREG
3908+ 2D5C
3909+ 2D5C
3910+ 2D5C CD 4B 30     SUBPHL: call    LOADFP          ; FPREG = -FPREG + number at HL
3911+ 2D5F 21                   defb    $21             ; Skip "pop BC" and "pop DE"
3912+ 2D60 C1           PSUB:   pop     BC              ; Get FP number from stack
3913+ 2D61 D1                   pop     DE
3914+ 2D62 CD 25 30     SUBCDE: call    INVSGN          ; Negate FPREG
3915+ 2D65 78           FPADD:  ld      A,B             ; Get FP exponent
3916+ 2D66 B7                   or      A               ; Is number zero?
3917+ 2D67 C8                   ret     Z               ; Yes - Nothing to add
3918+ 2D68 3A D3 55             ld      A,(FPEXP)       ; Get FPREG exponent
3919+ 2D6B B7                   or      A               ; Is this number zero?
3920+ 2D6C CA 3D 30             jp      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3921+ 2D6F 90                   sub     B               ; BCDE number larger?
3922+ 2D70 D2 7F 2D             jp      NC,NOSWAP       ; No - Don't swap them
3923+ 2D73 2F                   cpl                     ; Two's complement
3924+ 2D74 3C                   inc     A               ;  FP exponent
3925+ 2D75 EB                   ex      DE,HL
3926+ 2D76 CD 2D 30             call    STAKFP          ; Put FPREG on stack
3927+ 2D79 EB                   ex      DE,HL
3928+ 2D7A CD 3D 30             call    FPBCDE          ; Move BCDE to FPREG
3929+ 2D7D C1                   pop     BC              ; Restore number from stack
3930+ 2D7E D1                   pop     DE
3931+ 2D7F FE 19        NOSWAP: cp      24+1            ; Second number insignificant?
3932+ 2D81 D0                   ret     NC              ; Yes - First number is result
3933+ 2D82 F5                   push    AF              ; Save number of bits to scale
3934+ 2D83 CD 62 30             call    SIGNS           ; Set MSBs & sign of result
3935+ 2D86 67                   ld      H,A             ; Save sign of result
3936+ 2D87 F1                   pop     AF              ; Restore scaling factor
3937+ 2D88 CD 2A 2E             call    SCALE           ; Scale BCDE to same exponent
3938+ 2D8B B4                   or      H               ; Result to be positive?
3939+ 2D8C 21 D0 55             ld      HL,FPREG        ; Point to FPREG
3940+ 2D8F F2 A5 2D             jp      P,MINCDE        ; No - Subtract FPREG from CDE
3941+ 2D92 CD 0A 2E             call    PLUCDE          ; Add FPREG to CDE
3942+ 2D95 D2 EB 2D             jp      NC,RONDUP       ; No overflow - Round it up
3943+ 2D98 23                   inc     HL              ; Point to exponent
3944+ 2D99 34                   inc     (HL)            ; Increment it
3945+ 2D9A CA 26 18             jp      Z,OVERR         ; Number overflowed - Error
3946+ 2D9D 2E 01                ld      L,$01           ; 1 bit to shift right
3947+ 2D9F CD 40 2E             call    SHRT1           ; Shift result right
3948+ 2DA2 C3 EB 2D             jp      RONDUP          ; Round it up
3949+ 2DA5
3950+ 2DA5 AF           MINCDE: xor     A               ; Clear A and carry
3951+ 2DA6 90                   sub     B               ; Negate exponent
3952+ 2DA7 47                   ld      B,A             ; Re-save exponent
3953+ 2DA8 7E                   ld      A,(HL)          ; Get LSB of FPREG
3954+ 2DA9 9B                   sbc     A, E            ; Subtract LSB of BCDE
3955+ 2DAA 5F                   ld      E,A             ; Save LSB of BCDE
3956+ 2DAB 23                   inc     HL
3957+ 2DAC 7E                   ld      A,(HL)          ; Get NMSB of FPREG
3958+ 2DAD 9A                   sbc     A,D             ; Subtract NMSB of BCDE
3959+ 2DAE 57                   ld      D,A             ; Save NMSB of BCDE
3960+ 2DAF 23                   inc     HL
3961+ 2DB0 7E                   ld      A,(HL)          ; Get MSB of FPREG
3962+ 2DB1 99                   sbc     A,C             ; Subtract MSB of BCDE
3963+ 2DB2 4F                   ld      C,A             ; Save MSB of BCDE
3964+ 2DB3 DC 16 2E     CONPOS: call    C,COMPL         ; Overflow - Make it positive
3965+ 2DB6
3966+ 2DB6 68           BNORM:  ld      L,B             ; L = Exponent
3967+ 2DB7 63                   ld      H,E             ; H = LSB
3968+ 2DB8 AF                   xor     A
3969+ 2DB9 47           BNRMLP: ld      B,A             ; Save bit count
3970+ 2DBA 79                   ld      A,C             ; Get MSB
3971+ 2DBB B7                   or      A               ; Is it zero?
3972+ 2DBC C2 D8 2D             jp      NZ,PNORM        ; No - Do it bit at a time
3973+ 2DBF 4A                   ld      C,D             ; MSB = NMSB
3974+ 2DC0 54                   ld      D,H             ; NMSB= LSB
3975+ 2DC1 65                   ld      H,L             ; LSB = VLSB
3976+ 2DC2 6F                   ld      L,A             ; VLSB= 0
3977+ 2DC3 78                   ld      A,B             ; Get exponent
3978+ 2DC4 D6 08                sub     $08             ; Count 8 bits
3979+ 2DC6 FE E0                cp      -24-8           ; Was number zero?
3980+ 2DC8 C2 B9 2D             jp      NZ,BNRMLP       ; No - Keep normalising
3981+ 2DCB AF           RESZER: xor     A               ; Result is zero
3982+ 2DCC 32 D3 55     SAVEXP: ld      (FPEXP),A       ; Save result as zero
3983+ 2DCF C9                   ret
3984+ 2DD0
3985+ 2DD0 05           NORMAL: dec     B               ; Count bits
3986+ 2DD1 29                   add     HL,HL           ; Shift HL left
3987+ 2DD2 7A                   ld      A,D             ; Get NMSB
3988+ 2DD3 17                   rla                     ; Shift left with last bit
3989+ 2DD4 57                   ld      D,A             ; Save NMSB
3990+ 2DD5 79                   ld      A,C             ; Get MSB
3991+ 2DD6 8F                   adc     A,A             ; Shift left with last bit
3992+ 2DD7 4F                   ld      C,A             ; Save MSB
3993+ 2DD8 F2 D0 2D     PNORM:  jp      P,NORMAL        ; Not done - Keep going
3994+ 2DDB 78                   ld      A,B             ; Number of bits shifted
3995+ 2DDC 5C                   ld      E,H             ; Save HL in EB
3996+ 2DDD 45                   ld      B,L
3997+ 2DDE B7                   or      A               ; Any shifting done?
3998+ 2DDF CA EB 2D             jp      Z,RONDUP        ; No - Round it up
3999+ 2DE2 21 D3 55             ld      HL,FPEXP        ; Point to exponent
4000+ 2DE5 86                   add     A,(HL)          ; Add shifted bits
4001+ 2DE6 77                   ld      (HL),A          ; Re-save exponent
4002+ 2DE7 D2 CB 2D             jp      NC,RESZER       ; Underflow - Result is zero
4003+ 2DEA C8                   ret     Z               ; Result is zero
4004+ 2DEB 78           RONDUP: ld      A,B             ; Get VLSB of number
4005+ 2DEC 21 D3 55     RONDB:  ld      HL,FPEXP        ; Point to exponent
4006+ 2DEF B7                   or      A               ; Any rounding?
4007+ 2DF0 FC FD 2D             call    M,FPROND        ; Yes - Round number up
4008+ 2DF3 46                   ld      B,(HL)          ; B = Exponent
4009+ 2DF4 23                   inc     HL
4010+ 2DF5 7E                   ld      A,(HL)          ; Get sign of result
4011+ 2DF6 E6 80                and     %10000000       ; Only bit 7 needed
4012+ 2DF8 A9                   xor     C               ; Set correct sign
4013+ 2DF9 4F                   ld      C,A             ; Save correct sign in number
4014+ 2DFA C3 3D 30             jp      FPBCDE          ; Move BCDE to FPREG
4015+ 2DFD
4016+ 2DFD 1C           FPROND: inc     E               ; Round LSB
4017+ 2DFE C0                   ret     NZ              ; Return if ok
4018+ 2DFF 14                   inc     D               ; Round NMSB
4019+ 2E00 C0                   ret     NZ              ; Return if ok
4020+ 2E01 0C                   inc     C               ; Round MSB
4021+ 2E02 C0                   ret     NZ              ; Return if ok
4022+ 2E03 0E 80                ld      C,$80           ; Set normal value
4023+ 2E05 34                   inc     (HL)            ; Increment exponent
4024+ 2E06 C0                   ret     NZ              ; Return if ok
4025+ 2E07 C3 26 18             jp      OVERR           ; Overflow error
4026+ 2E0A
4027+ 2E0A 7E           PLUCDE: ld      A,(HL)          ; Get LSB of FPREG
4028+ 2E0B 83                   add     A,E             ; Add LSB of BCDE
4029+ 2E0C 5F                   ld      E,A             ; Save LSB of BCDE
4030+ 2E0D 23                   inc     HL
4031+ 2E0E 7E                   ld      A,(HL)          ; Get NMSB of FPREG
4032+ 2E0F 8A                   adc     A,D             ; Add NMSB of BCDE
4033+ 2E10 57                   ld      D,A             ; Save NMSB of BCDE
4034+ 2E11 23                   inc     HL
4035+ 2E12 7E                   ld      A,(HL)          ; Get MSB of FPREG
4036+ 2E13 89                   adc     A,C             ; Add MSB of BCDE
4037+ 2E14 4F                   ld      C,A             ; Save MSB of BCDE
4038+ 2E15 C9                   ret
4039+ 2E16
4040+ 2E16 21 D4 55     COMPL:  ld      HL,SGNRES       ; Sign of result
4041+ 2E19 7E                   ld      A,(HL)          ; Get sign of result
4042+ 2E1A 2F                   cpl                     ; Negate it
4043+ 2E1B 77                   ld      (HL),A          ; Put it back
4044+ 2E1C AF                   xor     A
4045+ 2E1D 6F                   ld      L,A             ; Set L to zero
4046+ 2E1E 90                   sub     B               ; Negate exponent,set carry
4047+ 2E1F 47                   ld      B,A             ; Re-save exponent
4048+ 2E20 7D                   ld      A,L             ; Load zero
4049+ 2E21 9B                   sbc     A,E             ; Negate LSB
4050+ 2E22 5F                   ld      E,A             ; Re-save LSB
4051+ 2E23 7D                   ld      A,L             ; Load zero
4052+ 2E24 9A                   sbc     A,D             ; Negate NMSB
4053+ 2E25 57                   ld      D,A             ; Re-save NMSB
4054+ 2E26 7D                   ld      A,L             ; Load zero
4055+ 2E27 99                   sbc     A,C             ; Negate MSB
4056+ 2E28 4F                   ld      C,A             ; Re-save MSB
4057+ 2E29 C9                   ret
4058+ 2E2A
4059+ 2E2A 06 00        SCALE:  ld      B,$00           ; Clear underflow
4060+ 2E2C D6 08        SCALLP: sub     $08             ; 8 bits (a whole byte)?
4061+ 2E2E DA 39 2E             jp      C,SHRITE        ; No - Shift right A bits
4062+ 2E31 43                   ld      B,E             ; <- Shift
4063+ 2E32 5A                   ld      E,D             ; <- right
4064+ 2E33 51                   ld      D,C             ; <- eight
4065+ 2E34 0E 00                ld      C,$00           ; <- bits
4066+ 2E36 C3 2C 2E             jp      SCALLP          ; More bits to shift
4067+ 2E39
4068+ 2E39 C6 09        SHRITE: add     A,8+1           ; Adjust count
4069+ 2E3B 6F                   ld      L,A             ; Save bits to shift
4070+ 2E3C AF           SHRLP:  xor     A               ; Flag for all done
4071+ 2E3D 2D                   dec     L               ; All shifting done?
4072+ 2E3E C8                   ret     Z               ; Yes - Return
4073+ 2E3F 79                   ld      A,C             ; Get MSB
4074+ 2E40 1F           SHRT1:  rra                     ; Shift it right
4075+ 2E41 4F                   ld      C,A             ; Re-save
4076+ 2E42 7A                   ld      A,D             ; Get NMSB
4077+ 2E43 1F                   rra                     ; Shift right with last bit
4078+ 2E44 57                   ld      D,A             ; Re-save it
4079+ 2E45 7B                   ld      A,E             ; Get LSB
4080+ 2E46 1F                   rra                     ; Shift right with last bit
4081+ 2E47 5F                   ld      E,A             ; Re-save it
4082+ 2E48 78                   ld      A,B             ; Get underflow
4083+ 2E49 1F                   rra                     ; Shift right with last bit
4084+ 2E4A 47                   ld      B,A             ; Re-save underflow
4085+ 2E4B C3 3C 2E             jp      SHRLP           ; More bits to do
4086+ 2E4E
4087+ 2E4E 00 00 00 81  UNITY:  defb    $00,$00,$00,$81 ; 1.00000
4088+ 2E52
4089+ 2E52 03           LOGTAB: defb    $03             ; Table used by LOG
4090+ 2E53 AA 56 19 80          defb    $AA,$56,$19,$80 ; 0.59898
4091+ 2E57 F1 22 76 80          defb    $F1,$22,$76,$80 ; 0.96147
4092+ 2E5B 45 AA 38 82          defb    $45,$AA,$38,$82 ; 2.88539
4093+ 2E5F
4094+ 2E5F CD FC 2F     LOG:    call    TSTSGN          ; Test sign of value
4095+ 2E62 B7                   or      A
4096+ 2E63 EA 29 1E             jp      PE,FCERR        ; ?FC Error if <= zero
4097+ 2E66 21 D3 55             ld      HL,FPEXP        ; Point to exponent
4098+ 2E69 7E                   ld      A,(HL)          ; Get exponent
4099+ 2E6A 01 35 80             ld      BC,$8035        ; BCDE = SQR(1/2)
4100+ 2E6D 11 F3 04             ld      DE,$04F3
4101+ 2E70 90                   sub     B               ; Scale value to be < 1
4102+ 2E71 F5                   push    AF              ; Save scale factor
4103+ 2E72 70                   ld      (HL),B          ; Save new exponent
4104+ 2E73 D5                   push    DE              ; Save SQR(1/2)
4105+ 2E74 C5                   push    BC
4106+ 2E75 CD 65 2D             call    FPADD           ; Add SQR(1/2) to value
4107+ 2E78 C1                   pop     BC              ; Restore SQR(1/2)
4108+ 2E79 D1                   pop     DE
4109+ 2E7A 04                   inc     B               ; Make it SQR(2)
4110+ 2E7B CD 52 2F             call    DVBCDE          ; Divide by SQR(2)
4111+ 2E7E 21 4E 2E             ld      HL,UNITY        ; Point to 1.
4112+ 2E81 CD 5C 2D             call    SUBPHL          ; Subtract FPREG from 1
4113+ 2E84 21 52 2E             ld      HL,LOGTAB       ; Coefficient table
4114+ 2E87 CD 44 33             call    SUMSER          ; Evaluate sum of series
4115+ 2E8A 01 80 80             ld      BC,$8080        ; BCDE = -0.5
4116+ 2E8D 11 00 00             ld      DE,$0000
4117+ 2E90 CD 65 2D             call    FPADD           ; Subtract 0.5 from FPREG
4118+ 2E93 F1                   pop     AF              ; Restore scale factor
4119+ 2E94 CD 77 31             call    RSCALE          ; Re-scale number
4120+ 2E97 01 31 80     MULLN2: ld      BC,$8031        ; BCDE = Ln(2)
4121+ 2E9A 11 18 72             ld      DE,$7218
4122+ 2E9D 21                   defb    $21             ; Skip "pop BC" and "pop DE"
4123+ 2E9E
4124+ 2E9E C1           MULT:   pop     BC              ; Get number from stack
4125+ 2E9F D1                   pop     DE
4126+ 2EA0 CD FC 2F     FPMULT: call    TSTSGN          ; Test sign of FPREG
4127+ 2EA3 C8                   ret     Z               ; Return zero if zero
4128+ 2EA4 2E 00                ld      L,$00           ; Flag add exponents
4129+ 2EA6 CD BA 2F             call    ADDEXP          ; Add exponents
4130+ 2EA9 79                   ld      A,C             ; Get MSB of multiplier
4131+ 2EAA 32 E2 55             ld      (MULVAL),A      ; Save MSB of multiplier
4132+ 2EAD EB                   ex      DE,HL
4133+ 2EAE 22 E3 55             ld      (MULVAL+1),HL   ; Save rest of multiplier
4134+ 2EB1 01 00 00             ld      BC,$0000        ; Partial product (BCDE) = zero
4135+ 2EB4 50                   ld      D,B
4136+ 2EB5 58                   ld      E,B
4137+ 2EB6 21 B6 2D             ld      HL,BNORM        ; Address of normalise
4138+ 2EB9 E5                   push    HL              ; Save for return
4139+ 2EBA 21 C2 2E             ld      HL,MULT8        ; Address of 8 bit multiply
4140+ 2EBD E5                   push    HL              ; Save for NMSB,MSB
4141+ 2EBE E5                   push    HL              ;
4142+ 2EBF 21 D0 55             ld      HL,FPREG        ; Point to number
4143+ 2EC2 7E           MULT8:  ld      A,(HL)          ; Get LSB of number
4144+ 2EC3 23                   inc     HL              ; Point to NMSB
4145+ 2EC4 B7                   or      A               ; Test LSB
4146+ 2EC5 CA EE 2E             jp      Z,BYTSFT        ; Zero - shift to next byte
4147+ 2EC8 E5                   push    HL              ; Save address of number
4148+ 2EC9 2E 08                ld      L,$08           ; 8 bits to multiply by
4149+ 2ECB 1F           MUL8LP: rra                     ; Shift LSB right
4150+ 2ECC 67                   ld      H,A             ; Save LSB
4151+ 2ECD 79                   ld      A,C             ; Get MSB
4152+ 2ECE D2 DC 2E             jp      NC,NOMADD       ; Bit was zero - Don't add
4153+ 2ED1 E5                   push    HL              ; Save LSB and count
4154+ 2ED2 2A E3 55             ld      HL,(MULVAL+1)   ; Get LSB and NMSB
4155+ 2ED5 19                   add     HL,DE           ; Add NMSB and LSB
4156+ 2ED6 EB                   ex      DE,HL           ; Leave sum in DE
4157+ 2ED7 E1                   pop     HL              ; Restore MSB and count
4158+ 2ED8 3A E2 55             ld      A,(MULVAL)      ; Get MSB of multiplier
4159+ 2EDB 89                   adc     A,C             ; Add MSB
4160+ 2EDC 1F           NOMADD: rra                     ; Shift MSB right
4161+ 2EDD 4F                   ld      C,A             ; Re-save MSB
4162+ 2EDE 7A                   ld      A,D             ; Get NMSB
4163+ 2EDF 1F                   rra                     ; Shift NMSB right
4164+ 2EE0 57                   ld      D,A             ; Re-save NMSB
4165+ 2EE1 7B                   ld      A,E             ; Get LSB
4166+ 2EE2 1F                   rra                     ; Shift LSB right
4167+ 2EE3 5F                   ld      E,A             ; Re-save LSB
4168+ 2EE4 78                   ld      A,B             ; Get VLSB
4169+ 2EE5 1F                   rra                     ; Shift VLSB right
4170+ 2EE6 47                   ld      B,A             ; Re-save VLSB
4171+ 2EE7 2D                   dec     L               ; Count bits multiplied
4172+ 2EE8 7C                   ld      A,H             ; Get LSB of multiplier
4173+ 2EE9 C2 CB 2E             jp      NZ,MUL8LP       ; More - Do it
4174+ 2EEC E1           POPHRT: pop     HL              ; Restore address of number
4175+ 2EED C9                   ret
4176+ 2EEE
4177+ 2EEE 43           BYTSFT: ld      B,E             ; Shift partial product left
4178+ 2EEF 5A                   ld      E,D
4179+ 2EF0 51                   ld      D,C
4180+ 2EF1 4F                   ld      C,A
4181+ 2EF2 C9                   ret
4182+ 2EF3
4183+ 2EF3
4184+ 2EF3              ; WORKING ââ
4185+ 2EF3 C1           DINT:   pop     BC              ; Get number from stack
4186+ 2EF4 D1                   pop     DE
4187+ 2EF5 CD 52 2F             call    DVBCDE          ; get BCDE/FPREG and store result into FPREG
4188+ 2EF8 C3 CF 30             jp      INT             ; return INT(FPREG)
4189+ 2EFB
4190+ 2EFB
4191+ 2EFB              ; A MODULO B - return remainder of the integer division A/B where:
4192+ 2EFB              ; A is in stack; B is in FPREG
4193+ 2EFB              ; math is:
4194+ 2EFB              ; A=INT(A); B=INT(B); R=A-(B*INT(A/B))
4195+ 2EFB CD CF 30     MOD:    call    INT             ; B=INT(B)
4196+ 2EFE CD 48 30             call    BCDEFP          ; copy B (from FPREG) into BCDE
4197+ 2F01 ED 53 80 55          ld      (TMPBFR3),DE    ; store B into...
4198+ 2F05 ED 43 82 55          ld      (TMPBFR4),BC    ; ...a temp buffer
4199+ 2F09 C1                   pop     BC              ; recover A...
4200+ 2F0A D1                   pop     DE              ; ...from stack
4201+ 2F0B CD 3D 30             call    FPBCDE          ; store A into FPREG
4202+ 2F0E CD CF 30             call    INT             ; get integer part: A=INT(A)
4203+ 2F11 CD 48 30             call    BCDEFP          ; copy A (from FPREG) into BCDE
4204+ 2F14 ED 53 7C 55          ld      (TMPBFR1),DE    ; store A into...
4205+ 2F18 ED 43 7E 55          ld      (TMPBFR2),BC    ; ...a temp buffer
4206+ 2F1C                                              ; begin calculation
4207+ 2F1C 2A 80 55             ld      HL,(TMPBFR3)    ; move B...
4208+ 2F1F 22 D0 55             ld      (FPREG),HL      ; ...from...
4209+ 2F22 2A 82 55             ld      HL,(TMPBFR4)    ; ...temp buffer...
4210+ 2F25 22 D2 55             ld      (FPREG+2),HL    ; ...into FPREG
4211+ 2F28 CD 52 2F             call    DVBCDE          ; compute A/B and store into FPREG
4212+ 2F2B CD CF 30             call    INT             ; get integer part of result: now FPREG = INT(A/B)
4213+ 2F2E ED 5B 80 55          ld      DE,(TMPBFR3)    ; load B...
4214+ 2F32 ED 4B 82 55          ld      BC,(TMPBFR4)    ; ...into BCDE
4215+ 2F36 CD A0 2E             call    FPMULT          ; get B*INT(A/B) and store into FPREG
4216+ 2F39 ED 5B 7C 55          ld      DE,(TMPBFR1)    ; retrieve A from...
4217+ 2F3D ED 4B 7E 55          ld      BC,(TMPBFR2)    ; ...temp buffer
4218+ 2F41 C3 62 2D             jp      SUBCDE          ; return result of A-(B*INT(A/B))
4219+ 2F44
4220+ 2F44
4221+ 2F44 CD 2D 30     DIV10:  call    STAKFP          ; Save FPREG on stack
4222+ 2F47 01 20 84             ld      BC,$8420        ; BCDE = 10.
4223+ 2F4A 11 00 00             ld      DE,$0000
4224+ 2F4D CD 3D 30             call    FPBCDE          ; Move 10 to FPREG
4225+ 2F50
4226+ 2F50 C1           DIV:    pop     BC              ; Get number from stack
4227+ 2F51 D1                   pop     DE
4228+ 2F52 CD FC 2F     DVBCDE: call    TSTSGN          ; Test sign of FPREG
4229+ 2F55 CA 1A 18             jp      Z,DZERR         ; Error if division by zero
4230+ 2F58 2E FF                ld      L,-1            ; Flag subtract exponents
4231+ 2F5A CD BA 2F             call    ADDEXP          ; Subtract exponents
4232+ 2F5D 34                   inc     (HL)            ; Add 2 to exponent to adjust
4233+ 2F5E 34                   inc     (HL)
4234+ 2F5F 2B                   dec     HL              ; Point to MSB
4235+ 2F60 7E                   ld      A,(HL)          ; Get MSB of dividend
4236+ 2F61 32 ED 53             ld      (DIV3),A        ; Save for subtraction
4237+ 2F64 2B                   dec     HL
4238+ 2F65 7E                   ld      A,(HL)          ; Get NMSB of dividend
4239+ 2F66 32 E9 53             ld      (DIV2),A        ; Save for subtraction
4240+ 2F69 2B                   dec     HL
4241+ 2F6A 7E                   ld      A,(HL)          ; Get MSB of dividend
4242+ 2F6B 32 E5 53             ld      (DIV1),A        ; Save for subtraction
4243+ 2F6E 41                   ld      B,C             ; Get MSB
4244+ 2F6F EB                   ex      DE,HL           ; NMSB,LSB to HL
4245+ 2F70 AF                   xor     A
4246+ 2F71 4F                   ld      C,A             ; Clear MSB of quotient
4247+ 2F72 57                   ld      D,A             ; Clear NMSB of quotient
4248+ 2F73 5F                   ld      E,A             ; Clear LSB of quotient
4249+ 2F74 32 F0 53             ld      (DIV4),A        ; Clear overflow count
4250+ 2F77 E5           DIVLP:  push    HL              ; Save divisor
4251+ 2F78 C5                   push    BC
4252+ 2F79 7D                   ld      A,L             ; Get LSB of number
4253+ 2F7A CD E4 53             call    DIVSUP          ; Subt' divisor from dividend
4254+ 2F7D DE 00                sbc     A,$00           ; Count for overflows
4255+ 2F7F 3F                   ccf
4256+ 2F80 D2 8A 2F             jp      NC,RESDIV       ; Restore divisor if borrow
4257+ 2F83 32 F0 53             ld      (DIV4),A        ; Re-save overflow count
4258+ 2F86 F1                   pop     AF              ; Scrap divisor
4259+ 2F87 F1                   pop     AF
4260+ 2F88 37                   scf                     ; Set carry to
4261+ 2F89 D2                   defb    $D2             ; Skip "pop BC" and "pop HL"
4262+ 2F8A
4263+ 2F8A C1           RESDIV: pop     BC              ; Restore divisor
4264+ 2F8B E1                   pop     HL
4265+ 2F8C 79                   ld      A,C             ; Get MSB of quotient
4266+ 2F8D 3C                   inc     A
4267+ 2F8E 3D                   dec     A
4268+ 2F8F 1F                   rra                     ; Bit 0 to bit 7
4269+ 2F90 FA EC 2D             jp      M,RONDB         ; Done - Normalise result
4270+ 2F93 17                   rla                     ; Restore carry
4271+ 2F94 7B                   ld      A,E             ; Get LSB of quotient
4272+ 2F95 17                   rla                     ; Double it
4273+ 2F96 5F                   ld      E,A             ; Put it back
4274+ 2F97 7A                   ld      A,D             ; Get NMSB of quotient
4275+ 2F98 17                   rla                     ; Double it
4276+ 2F99 57                   ld      D,A             ; Put it back
4277+ 2F9A 79                   ld      A,C             ; Get MSB of quotient
4278+ 2F9B 17                   rla                     ; Double it
4279+ 2F9C 4F                   ld      C,A             ; Put it back
4280+ 2F9D 29                   add     HL,HL           ; Double NMSB,LSB of divisor
4281+ 2F9E 78                   ld      A,B             ; Get MSB of divisor
4282+ 2F9F 17                   rla                     ; Double it
4283+ 2FA0 47                   ld      B,A             ; Put it back
4284+ 2FA1 3A F0 53             ld      A,(DIV4)        ; Get VLSB of quotient
4285+ 2FA4 17                   rla                     ; Double it
4286+ 2FA5 32 F0 53             ld      (DIV4),A        ; Put it back
4287+ 2FA8 79                   ld      A,C             ; Get MSB of quotient
4288+ 2FA9 B2                   or      D               ; Merge NMSB
4289+ 2FAA B3                   or      E               ; Merge LSB
4290+ 2FAB C2 77 2F             jp      NZ,DIVLP        ; Not done - Keep dividing
4291+ 2FAE E5                   push    HL              ; Save divisor
4292+ 2FAF 21 D3 55             ld      HL,FPEXP        ; Point to exponent
4293+ 2FB2 35                   dec     (HL)            ; Divide by 2
4294+ 2FB3 E1                   pop     HL              ; Restore divisor
4295+ 2FB4 C2 77 2F             jp      NZ,DIVLP        ; Ok - Keep going
4296+ 2FB7 C3 26 18             jp      OVERR           ; Overflow error
4297+ 2FBA
4298+ 2FBA
4299+ 2FBA 78           ADDEXP: ld      A,B             ; Get exponent of dividend
4300+ 2FBB B7                   or      A               ; Test it
4301+ 2FBC CA DE 2F             jp      Z,OVTST3        ; Zero - Result zero
4302+ 2FBF 7D                   ld      A,L             ; Get add/subtract flag
4303+ 2FC0 21 D3 55             ld      HL,FPEXP        ; Point to exponent
4304+ 2FC3 AE                   xor     (HL)            ; Add or subtract it
4305+ 2FC4 80                   add     A,B             ; Add the other exponent
4306+ 2FC5 47                   ld      B,A             ; Save new exponent
4307+ 2FC6 1F                   rra                     ; Test exponent for overflow
4308+ 2FC7 A8                   xor     B
4309+ 2FC8 78                   ld      A,B             ; Get exponent
4310+ 2FC9 F2 DD 2F             jp      P,OVTST2        ; Positive - Test for overflow
4311+ 2FCC C6 80                add     A,$80           ; Add excess 128
4312+ 2FCE 77                   ld      (HL),A          ; Save new exponent
4313+ 2FCF CA EC 2E             jp      Z,POPHRT        ; Zero - Result zero
4314+ 2FD2 CD 62 30             call    SIGNS           ; Set MSBs and sign of result
4315+ 2FD5 77                   ld      (HL),A          ; Save new exponent
4316+ 2FD6 2B                   dec     HL              ; Point to MSB
4317+ 2FD7 C9                   ret
4318+ 2FD8
4319+ 2FD8 CD FC 2F     OVTST1: call    TSTSGN          ; Test sign of FPREG
4320+ 2FDB 2F                   cpl                     ; Invert sign
4321+ 2FDC E1                   pop     HL              ; Clean up stack
4322+ 2FDD B7           OVTST2: or      A               ; Test if new exponent zero
4323+ 2FDE E1           OVTST3: pop     HL              ; Clear off return address
4324+ 2FDF F2 CB 2D             jp      P,RESZER        ; Result zero
4325+ 2FE2 C3 26 18             jp      OVERR           ; Overflow error
4326+ 2FE5
4327+ 2FE5 CD 48 30     MLSP10: call    BCDEFP          ; Move FPREG to BCDE
4328+ 2FE8 78                   ld      A,B             ; Get exponent
4329+ 2FE9 B7                   or      A               ; Is it zero?
4330+ 2FEA C8                   ret     Z               ; Yes - Result is zero
4331+ 2FEB C6 02                add     A,$02           ; Multiply by 4
4332+ 2FED DA 26 18             jp      C,OVERR         ; Overflow - ?OV Error
4333+ 2FF0 47                   ld      B,A             ; Re-save exponent
4334+ 2FF1 CD 65 2D             call    FPADD           ; Add BCDE to FPREG (Times 5)
4335+ 2FF4 21 D3 55             ld      HL,FPEXP        ; Point to exponent
4336+ 2FF7 34                   inc     (HL)            ; Double number (Times 10)
4337+ 2FF8 C0                   ret     NZ              ; Ok - Return
4338+ 2FF9 C3 26 18             jp      OVERR           ; Overflow error
4339+ 2FFC
4340+ 2FFC 3A D3 55     TSTSGN: ld      A,(FPEXP)       ; Get sign of FPREG
4341+ 2FFF B7                   or      A
4342+ 3000 C8                   ret     Z               ; RETurn if number is zero
4343+ 3001 3A D2 55             ld      A,(FPREG+2)     ; Get MSB of FPREG
4344+ 3004 FE                   defb    0FEH            ; Test sign
4345+ 3005 2F           RETREL: cpl                     ; Invert sign
4346+ 3006 17                   rla                     ; Sign bit to carry
4347+ 3007 9F           FLGDIF: sbc     A,A             ; Carry to all bits of A
4348+ 3008 C0                   ret     NZ              ; Return -1 if negative
4349+ 3009 3C                   inc     A               ; Bump to +1
4350+ 300A C9                   ret                     ; Positive - Return +1
4351+ 300B
4352+ 300B CD FC 2F     SGN:    call    TSTSGN          ; Test sign of FPREG
4353+ 300E 06 88        FLGREL: ld      B,$80+8         ; 8 bit integer in exponent
4354+ 3010 11 00 00             ld      DE,0            ; Zero NMSB and LSB
4355+ 3013 21 D3 55     RETINT: ld      HL,FPEXP        ; Point to exponent
4356+ 3016 4F                   ld      C,A             ; CDE = MSB,NMSB and LSB
4357+ 3017 70                   ld      (HL),B          ; Save exponent
4358+ 3018 06 00                ld      B,0             ; CDE = integer to normalise
4359+ 301A 23                   inc     HL              ; Point to sign of result
4360+ 301B 36 80                ld      (HL),$80        ; Set sign of result
4361+ 301D 17                   rla                     ; Carry = sign of integer
4362+ 301E C3 B3 2D             jp      CONPOS          ; Set sign of result
4363+ 3021
4364+ 3021 CD FC 2F     ABS_:   call    TSTSGN          ; Test sign of FPREG
4365+ 3024 F0                   ret     P               ; Return if positive
4366+ 3025 21 D2 55     INVSGN: ld      HL,FPREG+2      ; Point to MSB
4367+ 3028 7E                   ld      A,(HL)          ; Get sign of mantissa
4368+ 3029 EE 80                xor     $80             ; Invert sign of mantissa
4369+ 302B 77                   ld      (HL),A          ; Re-save sign of mantissa
4370+ 302C C9                   ret
4371+ 302D
4372+ 302D EB           STAKFP: ex      DE,HL           ; Save code string address
4373+ 302E 2A D0 55             ld      HL,(FPREG)      ; LSB,NLSB of FPREG
4374+ 3031 E3                   ex      (SP),HL         ; Stack them,get return
4375+ 3032 E5                   push    HL              ; Re-save return
4376+ 3033 2A D2 55             ld      HL,(FPREG+2)    ; MSB and exponent of FPREG
4377+ 3036 E3                   ex      (SP),HL         ; Stack them,get return
4378+ 3037 E5                   push    HL              ; Re-save return
4379+ 3038 EB                   ex      DE,HL           ; Restore code string address
4380+ 3039 C9                   ret
4381+ 303A
4382+ 303A              ; store F.P. number from BCDE into (FPREG)
4383+ 303A CD 4B 30     PHLTFP: call    LOADFP          ; Number at HL to BCDE
4384+ 303D EB           FPBCDE: ex      DE,HL           ; Save code string address
4385+ 303E 22 D0 55             ld      (FPREG),HL      ; Save LSB,NLSB of number
4386+ 3041 60                   ld      H,B             ; Exponent of number
4387+ 3042 69                   ld      L,C             ; MSB of number
4388+ 3043 22 D2 55             ld      (FPREG+2),HL    ; Save MSB and exponent
4389+ 3046 EB                   ex      DE,HL           ; Restore code string address
4390+ 3047 C9                   ret
4391+ 3048
4392+ 3048              ; load F.P. number from (FPREG) into BCDE
4393+ 3048 21 D0 55     BCDEFP: ld      HL,FPREG        ; Point to FPREG
4394+ 304B 5E           LOADFP: ld      E,(HL)          ; Get LSB of number
4395+ 304C 23                   inc     HL
4396+ 304D 56                   ld      D,(HL)          ; Get NMSB of number
4397+ 304E 23                   inc     HL
4398+ 304F 4E                   ld      C,(HL)          ; Get MSB of number
4399+ 3050 23                   inc     HL
4400+ 3051 46                   ld      B,(HL)          ; Get exponent of number
4401+ 3052 23           INCHL:  inc     HL              ; Used for conditional "inc HL"
4402+ 3053 C9                   ret
4403+ 3054
4404+ 3054              ; move floating point from (FPREG) into (HL)
4405+ 3054 11 D0 55     FPTHL:  ld      DE,FPREG        ; Point to FPREG
4406+ 3057 06 04        DETHL4: ld      B,$04           ; 4 bytes to move
4407+ 3059 1A           DETHLB: ld      A,(DE)          ; Get source
4408+ 305A 77                   ld      (HL),A          ; Save destination
4409+ 305B 13                   inc     DE              ; Next source
4410+ 305C 23                   inc     HL              ; Next destination
4411+ 305D 05                   dec     B               ; Count bytes
4412+ 305E C2 59 30             jp      NZ,DETHLB       ; Loop if more
4413+ 3061 C9                   ret
4414+ 3062
4415+ 3062 21 D2 55     SIGNS:  ld      HL,FPREG+2      ; Point to MSB of FPREG
4416+ 3065 7E                   ld      A,(HL)          ; Get MSB
4417+ 3066 07                   rlca                    ; Old sign to carry
4418+ 3067 37                   scf                     ; Set MSBit
4419+ 3068 1F                   rra                     ; Set MSBit of MSB
4420+ 3069 77                   ld      (HL),A          ; Save new MSB
4421+ 306A 3F                   ccf                     ; Complement sign
4422+ 306B 1F                   rra                     ; Old sign to carry
4423+ 306C 23                   inc     HL
4424+ 306D 23                   inc     HL
4425+ 306E 77                   ld      (HL),A          ; Set sign of result
4426+ 306F 79                   ld      A,C             ; Get MSB
4427+ 3070 07                   rlca                    ; Old sign to carry
4428+ 3071 37                   scf                     ; Set MSBit
4429+ 3072 1F                   rra                     ; Set MSBit of MSB
4430+ 3073 4F                   ld      C,A             ; Save MSB
4431+ 3074 1F                   rra
4432+ 3075 AE                   xor     (HL)            ; New sign of result
4433+ 3076 C9                   ret
4434+ 3077
4435+ 3077 78           CMPNUM: ld      A,B             ; Get exponent of number
4436+ 3078 B7                   or      A
4437+ 3079 CA FC 2F             jp      Z,TSTSGN        ; Zero - Test sign of FPREG
4438+ 307C 21 05 30             ld      HL,RETREL       ; Return relation routine
4439+ 307F E5                   push    HL              ; Save for return
4440+ 3080 CD FC 2F             call    TSTSGN          ; Test sign of FPREG
4441+ 3083 79                   ld      A,C             ; Get MSB of number
4442+ 3084 C8                   ret     Z               ; FPREG zero - Number's MSB
4443+ 3085 21 D2 55             ld      HL,FPREG+2      ; MSB of FPREG
4444+ 3088 AE                   xor     (HL)            ; Combine signs
4445+ 3089 79                   ld      A,C             ; Get MSB of number
4446+ 308A F8                   ret     M               ; Exit if signs different
4447+ 308B CD 91 30             call    CMPFP           ; Compare FP numbers
4448+ 308E 1F                   rra                     ; Get carry to sign
4449+ 308F A9                   xor     C               ; Combine with MSB of number
4450+ 3090 C9                   ret
4451+ 3091
4452+ 3091 23           CMPFP:  inc     HL              ; Point to exponent
4453+ 3092 78                   ld      A,B             ; Get exponent
4454+ 3093 BE                   cp      (HL)            ; Compare exponents
4455+ 3094 C0                   ret     NZ              ; Different
4456+ 3095 2B                   dec     HL              ; Point to MBS
4457+ 3096 79                   ld      A,C             ; Get MSB
4458+ 3097 BE                   cp      (HL)            ; Compare MSBs
4459+ 3098 C0                   ret     NZ              ; Different
4460+ 3099 2B                   dec     HL              ; Point to NMSB
4461+ 309A 7A                   ld      A,D             ; Get NMSB
4462+ 309B BE                   cp      (HL)            ; Compare NMSBs
4463+ 309C C0                   ret     NZ              ; Different
4464+ 309D 2B                   dec     HL              ; Point to LSB
4465+ 309E 7B                   ld      A,E             ; Get LSB
4466+ 309F 96                   sub     (HL)            ; Compare LSBs
4467+ 30A0 C0                   ret     NZ              ; Different
4468+ 30A1 E1                   pop     HL              ; Drop RETurn
4469+ 30A2 E1                   pop     HL              ; Drop another RETurn
4470+ 30A3 C9                   ret
4471+ 30A4
4472+ 30A4 47           FPINT:  ld      B,A             ; <- Move
4473+ 30A5 4F                   ld      C,A             ; <- exponent
4474+ 30A6 57                   ld      D,A             ; <- to all
4475+ 30A7 5F                   ld      E,A             ; <- bits
4476+ 30A8 B7                   or      A               ; Test exponent
4477+ 30A9 C8                   ret     Z               ; Zero - Return zero
4478+ 30AA E5                   push    HL              ; Save pointer to number
4479+ 30AB CD 48 30             call    BCDEFP          ; Move FPREG to BCDE
4480+ 30AE CD 62 30             call    SIGNS           ; Set MSBs & sign of result
4481+ 30B1 AE                   xor     (HL)            ; Combine with sign of FPREG
4482+ 30B2 67                   ld      H,A             ; Save combined signs
4483+ 30B3 FC C8 30             call    M,DCBCDE        ; Negative - Decrement BCDE
4484+ 30B6 3E 98                ld      A,$80+24        ; 24 bits
4485+ 30B8 90                   sub     B               ; Bits to shift
4486+ 30B9 CD 2A 2E             call    SCALE           ; Shift BCDE
4487+ 30BC 7C                   ld      A,H             ; Get combined sign
4488+ 30BD 17                   rla                     ; Sign to carry
4489+ 30BE DC FD 2D             call    C,FPROND        ; Negative - Round number up
4490+ 30C1 06 00                ld      B,$00           ; Zero exponent
4491+ 30C3 DC 16 2E             call    C,COMPL         ; If negative make positive
4492+ 30C6 E1                   pop     HL              ; Restore pointer to number
4493+ 30C7 C9                   ret
4494+ 30C8
4495+ 30C8 1B           DCBCDE: dec     DE              ; Decrement BCDE
4496+ 30C9 7A                   ld      A,D             ; Test LSBs
4497+ 30CA A3                   and     E
4498+ 30CB 3C                   inc     A
4499+ 30CC C0                   ret     NZ              ; Exit if LSBs not FFFF
4500+ 30CD 0B                   dec     BC              ; Decrement MSBs
4501+ 30CE C9                   ret
4502+ 30CF
4503+ 30CF 21 D3 55     INT:    ld      HL,FPEXP        ; Point to exponent
4504+ 30D2 7E                   ld      A,(HL)          ; Get exponent
4505+ 30D3 FE 98                cp      $80+24          ; Integer accuracy only?
4506+ 30D5 3A D0 55             ld      A,(FPREG)       ; Get LSB
4507+ 30D8 D0                   ret     NC              ; Yes - Already integer
4508+ 30D9 7E                   ld      A,(HL)          ; Get exponent
4509+ 30DA CD A4 30             call    FPINT           ; F.P to integer
4510+ 30DD 36 98                ld      (HL),$80+24     ; Save 24 bit integer
4511+ 30DF 7B                   ld      A,E             ; Get LSB of number
4512+ 30E0 F5                   push    AF              ; Save LSB
4513+ 30E1 79                   ld      A,C             ; Get MSB of number
4514+ 30E2 17                   rla                     ; Sign to carry
4515+ 30E3 CD B3 2D             call    CONPOS          ; Set sign of result
4516+ 30E6 F1                   pop     AF              ; Restore LSB of number
4517+ 30E7 C9                   ret
4518+ 30E8
4519+ 30E8 21 00 00     MLDEBC: ld      HL,$0000        ; Clear partial product
4520+ 30EB 78                   ld      A,B             ; Test multiplier
4521+ 30EC B1                   or      C
4522+ 30ED C8                   ret     Z               ; Return zero if zero
4523+ 30EE 3E 10                ld      A,$10           ; 16 bits
4524+ 30F0 29           MLDBLP: add     HL,HL           ; Shift P.P left
4525+ 30F1 DA 16 25             jp      C,BSERR         ; ?BS Error if overflow
4526+ 30F4 EB                   ex      DE,HL
4527+ 30F5 29                   add     HL,HL           ; Shift multiplier left
4528+ 30F6 EB                   ex      DE,HL
4529+ 30F7 D2 FE 30             jp      NC,NOMLAD       ; Bit was zero - No add
4530+ 30FA 09                   add     HL,BC           ; Add multiplicand
4531+ 30FB DA 16 25             jp      C,BSERR         ; ?BS Error if overflow
4532+ 30FE 3D           NOMLAD: dec     A               ; Count bits
4533+ 30FF C2 F0 30             jp      NZ,MLDBLP       ; More
4534+ 3102 C9                   ret
4535+ 3103
4536+ 3103 FE 2D        ASCTFP: cp      '-'             ; Negative?
4537+ 3105 F5                   push    AF              ; Save it and flags
4538+ 3106 CA 0F 31             jp      Z,CNVNUM        ; Yes - Convert number
4539+ 3109 FE 2B                cp      '+'             ; Positive?
4540+ 310B CA 0F 31             jp      Z,CNVNUM        ; Yes - Convert number
4541+ 310E 2B                   dec     HL              ; dec 'cos GETCHR INCs
4542+ 310F CD CB 2D     CNVNUM: call    RESZER          ; Set result to zero
4543+ 3112 47                   ld      B,A             ; Digits after point counter
4544+ 3113 57                   ld      D,A             ; Sign of exponent
4545+ 3114 5F                   ld      E,A             ; Exponent of ten
4546+ 3115 2F                   cpl
4547+ 3116 4F                   ld      C,A             ; Before or after point flag
4548+ 3117 CD 5E 1D     MANLP:  call    GETCHR          ; Get next character
4549+ 311A DA 60 31             jp      C,ADDIG         ; Digit - Add to number
4550+ 311D FE 2E                cp      '.'
4551+ 311F CA 3B 31             jp      Z,DPOINT        ; '.' - Flag point
4552+ 3122 FE 45                cp      'E'
4553+ 3124 C2 3F 31             jp      NZ,CONEXP       ; Not 'E' - Scale number
4554+ 3127 CD 5E 1D             call    GETCHR          ; Get next character
4555+ 312A CD 32 23             call    SGNEXP          ; Get sign of exponent
4556+ 312D CD 5E 1D     EXPLP:  call    GETCHR          ; Get next character
4557+ 3130 DA 82 31             jp      C,EDIGIT        ; Digit - Add to exponent
4558+ 3133 14                   inc     D               ; Is sign negative?
4559+ 3134 C2 3F 31             jp      NZ,CONEXP       ; No - Scale number
4560+ 3137 AF                   xor     A
4561+ 3138 93                   sub     E               ; Negate exponent
4562+ 3139 5F                   ld      E,A             ; And re-save it
4563+ 313A 0C                   inc     C               ; Flag end of number
4564+ 313B 0C           DPOINT: inc     C               ; Flag point passed
4565+ 313C CA 17 31             jp      Z,MANLP         ; Zero - Get another digit
4566+ 313F E5           CONEXP: push    HL              ; Save code string address
4567+ 3140 7B                   ld      A,E             ; Get exponent
4568+ 3141 90                   sub     B               ; Subtract digits after point
4569+ 3142 F4 58 31     SCALMI: call    P,SCALPL        ; Positive - Multiply number
4570+ 3145 F2 4E 31             jp      P,ENDCON        ; Positive - All done
4571+ 3148 F5                   push    AF              ; Save number of times to /10
4572+ 3149 CD 44 2F             call    DIV10           ; Divide by 10
4573+ 314C F1                   pop     AF              ; Restore count
4574+ 314D 3C                   inc     A               ; Count divides
4575+ 314E
4576+ 314E C2 42 31     ENDCON: jp      NZ,SCALMI       ; More to do
4577+ 3151 D1                   pop     DE              ; Restore code string address
4578+ 3152 F1                   pop     AF              ; Restore sign of number
4579+ 3153 CC 25 30             call    Z,INVSGN        ; Negative - Negate number
4580+ 3156 EB                   ex      DE,HL           ; Code string address to HL
4581+ 3157 C9                   ret
4582+ 3158
4583+ 3158 C8           SCALPL: ret     Z               ; Exit if no scaling needed
4584+ 3159 F5           MULTEN: push    AF              ; Save count
4585+ 315A CD E5 2F             call    MLSP10          ; Multiply number by 10
4586+ 315D F1                   pop     AF              ; Restore count
4587+ 315E 3D                   dec     A               ; Count multiplies
4588+ 315F C9                   ret
4589+ 3160
4590+ 3160 D5           ADDIG:  push    DE              ; Save sign of exponent
4591+ 3161 57                   ld      D,A             ; Save digit
4592+ 3162 78                   ld      A,B             ; Get digits after point
4593+ 3163 89                   adc     A,C             ; Add one if after point
4594+ 3164 47                   ld      B,A             ; Re-save counter
4595+ 3165 C5                   push    BC              ; Save point flags
4596+ 3166 E5                   push    HL              ; Save code string address
4597+ 3167 D5                   push    DE              ; Save digit
4598+ 3168 CD E5 2F             call    MLSP10          ; Multiply number by 10
4599+ 316B F1                   pop     AF              ; Restore digit
4600+ 316C D6 30                sub     '0'             ; Make it absolute
4601+ 316E CD 77 31             call    RSCALE          ; Re-scale number
4602+ 3171 E1                   pop     HL              ; Restore code string address
4603+ 3172 C1                   pop     BC              ; Restore point flags
4604+ 3173 D1                   pop     DE              ; Restore sign of exponent
4605+ 3174 C3 17 31             jp      MANLP           ; Get another digit
4606+ 3177
4607+ 3177 CD 2D 30     RSCALE: call    STAKFP          ; Put number on stack
4608+ 317A CD 0E 30             call    FLGREL          ; Digit to add to FPREG
4609+ 317D C1           PADD:   pop     BC              ; Restore number
4610+ 317E D1                   pop     DE
4611+ 317F C3 65 2D             jp      FPADD           ; Add BCDE to FPREG and return
4612+ 3182
4613+ 3182 7B           EDIGIT: ld      A,E             ; Get digit
4614+ 3183 07                   rlca                    ; Times 2
4615+ 3184 07                   rlca                    ; Times 4
4616+ 3185 83                   add     A,E             ; Times 5
4617+ 3186 07                   rlca                    ; Times 10
4618+ 3187 86                   add     A,(HL)          ; Add next digit
4619+ 3188 D6 30                sub     '0'             ; Make it absolute
4620+ 318A 5F                   ld      E,A             ; Save new digit
4621+ 318B C3 2D 31             jp      EXPLP           ; Look for another digit
4622+ 318E
4623+ 318E E5           LINEIN: push    HL              ; Save code string address
4624+ 318F 21 90 17             ld      HL,INMSG        ; Output " in "
4625+ 3192 CD F7 26             call    PRS             ; Output string at HL
4626+ 3195 E1                   pop     HL              ; Restore code string address
4627+ 3196 EB           PRNTHL: ex      DE,HL           ; Code string address to DE
4628+ 3197 AF                   xor     A
4629+ 3198 06 98                ld      B,$80+24        ; 24 bits
4630+ 319A CD 13 30             call    RETINT          ; Return the integer
4631+ 319D 21 F6 26             ld      HL,PRNUMS       ; Print number string
4632+ 31A0 E5                   push    HL              ; Save for return
4633+ 31A1              ; conmvert FP number into ASCII chars
4634+ 31A1 21 D5 55     NUMASC: ld      HL,PBUFF        ; Convert number to ASCII
4635+ 31A4 E5                   push    HL              ; Save for return
4636+ 31A5 CD FC 2F             call    TSTSGN          ; Test sign of FPREG
4637+ 31A8 36 20                ld      (HL),SPC        ; Space at start
4638+ 31AA F2 AF 31             jp      P,SPCFST        ; Positive - Space to start
4639+ 31AD 36 2D                ld      (HL),'-'        ; '-' sign at start
4640+ 31AF 23           SPCFST: inc     HL              ; First byte of number
4641+ 31B0 36 30                ld      (HL),'0'        ; '0' if zero
4642+ 31B2 CA 65 32             jp      Z,JSTZER        ; Return '0' if zero
4643+ 31B5 E5                   push    HL              ; Save buffer address
4644+ 31B6 FC 25 30             call    M,INVSGN        ; Negate FPREG if negative
4645+ 31B9 AF                   xor     A               ; Zero A
4646+ 31BA F5                   push    AF              ; Save it
4647+ 31BB CD 6B 32             call    RNGTST          ; Test number is in range
4648+ 31BE 01 43 91     SIXDIG: ld      BC,$9143        ; BCDE - 99999.9
4649+ 31C1 11 F8 4F             ld      DE,$4FF8
4650+ 31C4 CD 77 30             call    CMPNUM          ; Compare numbers
4651+ 31C7 B7                   or      A
4652+ 31C8 E2 DC 31             jp      PO,INRNG        ; > 99999.9 - Sort it out
4653+ 31CB F1                   pop     AF              ; Restore count
4654+ 31CC CD 59 31             call    MULTEN          ; Multiply by ten
4655+ 31CF F5                   push    AF              ; Re-save count
4656+ 31D0 C3 BE 31             jp      SIXDIG          ; Test it again
4657+ 31D3
4658+ 31D3 CD 44 2F     GTSIXD: call    DIV10           ; Divide by 10
4659+ 31D6 F1                   pop     AF              ; Get count
4660+ 31D7 3C                   inc     A               ; Count divides
4661+ 31D8 F5                   push    AF              ; Re-save count
4662+ 31D9 CD 6B 32             call    RNGTST          ; Test number is in range
4663+ 31DC CD 53 2D     INRNG:  call    ROUND           ; Add 0.5 to FPREG
4664+ 31DF 3C                   inc     A
4665+ 31E0 CD A4 30             call    FPINT           ; F.P to integer
4666+ 31E3 CD 3D 30             call    FPBCDE          ; Move BCDE to FPREG
4667+ 31E6 01 06 03             ld      BC,$0306        ; 1E+06 to 1E-03 range
4668+ 31E9 F1                   pop     AF              ; Restore count
4669+ 31EA 81                   add     A,C             ; 6 digits before point
4670+ 31EB 3C                   inc     A               ; Add one
4671+ 31EC FA F8 31             jp      M,MAKNUM        ; Do it in 'E' form if < 1E-02
4672+ 31EF FE 08                cp      6+1+1           ; More than 999999 ?
4673+ 31F1 D2 F8 31             jp      NC,MAKNUM       ; Yes - Do it in 'E' form
4674+ 31F4 3C                   inc     A               ; Adjust for exponent
4675+ 31F5 47                   ld      B,A             ; Exponent of number
4676+ 31F6 3E 02                ld      A,2             ; Make it zero after
4677+ 31F8
4678+ 31F8 3D           MAKNUM: dec     A               ; Adjust for digits to do
4679+ 31F9 3D                   dec     A
4680+ 31FA E1                   pop     HL              ; Restore buffer address
4681+ 31FB F5                   push    AF              ; Save count
4682+ 31FC 11 7E 32             ld      DE,POWERS       ; Powers of ten
4683+ 31FF 05                   dec     B               ; Count digits before point
4684+ 3200 C2 09 32             jp      NZ,DIGTXT       ; Not zero - Do number
4685+ 3203 36 2E                ld      (HL),'.'        ; Save point
4686+ 3205 23                   inc     HL              ; Move on
4687+ 3206 36 30                ld      (HL),'0'        ; Save zero
4688+ 3208 23                   inc     HL              ; Move on
4689+ 3209 05           DIGTXT: dec     B               ; Count digits before point
4690+ 320A 36 2E                ld      (HL),'.'        ; Save point in case
4691+ 320C CC 52 30             call    Z,INCHL         ; Last digit - move on
4692+ 320F C5                   push    BC              ; Save digits before point
4693+ 3210 E5                   push    HL              ; Save buffer address
4694+ 3211 D5                   push    DE              ; Save powers of ten
4695+ 3212 CD 48 30             call    BCDEFP          ; Move FPREG to BCDE
4696+ 3215 E1                   pop     HL              ; Powers of ten table
4697+ 3216 06 2F                ld      B,'0'-1         ; ASCII '0' - 1
4698+ 3218 04           TRYAGN: inc     B               ; Count subtractions
4699+ 3219 7B                   ld      A,E             ; Get LSB
4700+ 321A 96                   sub     (HL)            ; Subtract LSB
4701+ 321B 5F                   ld      E,A             ; Save LSB
4702+ 321C 23                   inc     HL
4703+ 321D 7A                   ld      A,D             ; Get NMSB
4704+ 321E 9E                   sbc     A,(HL)          ; Subtract NMSB
4705+ 321F 57                   ld      D,A             ; Save NMSB
4706+ 3220 23                   inc     HL
4707+ 3221 79                   ld      A,C             ; Get MSB
4708+ 3222 9E                   sbc     A,(HL)          ; Subtract MSB
4709+ 3223 4F                   ld      C,A             ; Save MSB
4710+ 3224 2B                   dec     HL              ; Point back to start
4711+ 3225 2B                   dec     HL
4712+ 3226 D2 18 32             jp      NC,TRYAGN       ; No overflow - Try again
4713+ 3229 CD 0A 2E             call    PLUCDE          ; Restore number
4714+ 322C 23                   inc     HL              ; Start of next number
4715+ 322D CD 3D 30             call    FPBCDE          ; Move BCDE to FPREG
4716+ 3230 EB                   ex      DE,HL           ; Save point in table
4717+ 3231 E1                   pop     HL              ; Restore buffer address
4718+ 3232 70                   ld      (HL),B          ; Save digit in buffer
4719+ 3233 23                   inc     HL              ; And move on
4720+ 3234 C1                   pop     BC              ; Restore digit count
4721+ 3235 0D                   dec     C               ; Count digits
4722+ 3236 C2 09 32             jp      NZ,DIGTXT       ; More - Do them
4723+ 3239 05                   dec     B               ; Any decimal part?
4724+ 323A CA 49 32             jp      Z,DOEBIT        ; No - Do 'E' bit
4725+ 323D 2B           SUPTLZ: dec     HL              ; Move back through buffer
4726+ 323E 7E                   ld      A,(HL)          ; Get character
4727+ 323F FE 30                cp      '0'             ; '0' character?
4728+ 3241 CA 3D 32             jp      Z,SUPTLZ        ; Yes - Look back for more
4729+ 3244 FE 2E                cp      '.'             ; A decimal point?
4730+ 3246 C4 52 30             call    NZ,INCHL        ; Move back over digit
4731+ 3249
4732+ 3249 F1           DOEBIT: pop     AF              ; Get 'E' flag
4733+ 324A CA 68 32             jp      Z,NOENED        ; No 'E' needed - End buffer
4734+ 324D 36 45                ld      (HL),'E'        ; Put 'E' in buffer
4735+ 324F 23                   inc     HL              ; And move on
4736+ 3250 36 2B                ld      (HL),'+'        ; Put '+' in buffer
4737+ 3252 F2 59 32             jp      P,OUTEXP        ; Positive - Output exponent
4738+ 3255 36 2D                ld      (HL),'-'        ; Put '-' in buffer
4739+ 3257 2F                   cpl                     ; Negate exponent
4740+ 3258 3C                   inc     A
4741+ 3259 06 2F        OUTEXP: ld      B,'0'-1         ; ASCII '0' - 1
4742+ 325B 04           EXPTEN: inc     B               ; Count subtractions
4743+ 325C D6 0A                sub     $0A             ; Tens digit
4744+ 325E D2 5B 32             jp      NC,EXPTEN       ; More to do
4745+ 3261 C6 3A                add     A,'0'+10        ; Restore and make ASCII
4746+ 3263 23                   inc     HL              ; Move on
4747+ 3264 70                   ld      (HL),B          ; Save MSB of exponent
4748+ 3265 23           JSTZER: inc     HL              ;
4749+ 3266 77                   ld      (HL),A          ; Save LSB of exponent
4750+ 3267 23                   inc     HL
4751+ 3268 71           NOENED: ld      (HL),C          ; Mark end of buffer
4752+ 3269 E1                   pop     HL              ; Restore code string address
4753+ 326A C9                   ret
4754+ 326B
4755+ 326B 01 74 94     RNGTST: ld      BC,$9474        ; BCDE = 999999.
4756+ 326E 11 F7 23             ld      DE,$23F7
4757+ 3271 CD 77 30             call    CMPNUM          ; Compare numbers
4758+ 3274 B7                   or      A
4759+ 3275 E1                   pop     HL              ; Return address to HL
4760+ 3276 E2 D3 31             jp      PO,GTSIXD       ; Too big - Divide by ten
4761+ 3279 E9                   jp      (HL)            ; Otherwise return to caller
4762+ 327A
4763+ 327A 00 00 00 80  HALF:   defb    $00,$00,$00,$80 ; 0.5
4764+ 327E
4765+ 327E A0 86 01     POWERS: defb    $A0,$86,$01  ; 100000
4766+ 3281 10 27 00             defb    $10,$27,$00  ;  10000
4767+ 3284 E8 03 00             defb    $E8,$03,$00  ;   1000
4768+ 3287 64 00 00             defb    $64,$00,$00  ;    100
4769+ 328A 0A 00 00             defb    $0A,$00,$00  ;     10
4770+ 328D 01 00 00             defb    $01,$00,$00  ;      1
4771+ 3290
4772+ 3290 21 25 30     NEGAFT: ld      HL,INVSGN       ; Negate result
4773+ 3293 E3                   ex      (SP),HL         ; To be done after caller
4774+ 3294 E9                   jp      (HL)            ; Return to caller
4775+ 3295
4776+ 3295 CD 2D 30     SQR:    call    STAKFP          ; Put value on stack
4777+ 3298 21 7A 32             ld      HL,HALF         ; Set power to 1/2
4778+ 329B CD 3A 30             call    PHLTFP          ; Move 1/2 to FPREG
4779+ 329E
4780+ 329E C1           POWER:  pop     BC              ; Get base
4781+ 329F D1                   pop     DE
4782+ 32A0 CD FC 2F             call    TSTSGN          ; Test sign of power
4783+ 32A3 78                   ld      A,B             ; Get exponent of base
4784+ 32A4 CA E3 32             jp      Z,EXP           ; Make result 1 if zero
4785+ 32A7 F2 AE 32             jp      P,POWER1        ; Positive base - Ok
4786+ 32AA B7                   or      A               ; Zero to negative power?
4787+ 32AB CA 1A 18             jp      Z,DZERR         ; Yes - ?/0 Error
4788+ 32AE B7           POWER1: or      A               ; Base zero?
4789+ 32AF CA CC 2D             jp      Z,SAVEXP        ; Yes - Return zero
4790+ 32B2 D5                   push    DE              ; Save base
4791+ 32B3 C5                   push    BC
4792+ 32B4 79                   ld      A,C             ; Get MSB of base
4793+ 32B5 F6 7F                or      %01111111       ; Get sign status
4794+ 32B7 CD 48 30             call    BCDEFP          ; Move power to BCDE
4795+ 32BA F2 CB 32             jp      P,POWER2        ; Positive base - Ok
4796+ 32BD D5                   push    DE              ; Save power
4797+ 32BE C5                   push    BC
4798+ 32BF CD CF 30             call    INT             ; Get integer of power
4799+ 32C2 C1                   pop     BC              ; Restore power
4800+ 32C3 D1                   pop     DE
4801+ 32C4 F5                   push    AF              ; MSB of base
4802+ 32C5 CD 77 30             call    CMPNUM          ; Power an integer?
4803+ 32C8 E1                   pop     HL              ; Restore MSB of base
4804+ 32C9 7C                   ld      A,H             ; but don't affect flags
4805+ 32CA 1F                   rra                     ; Exponent odd or even?
4806+ 32CB E1           POWER2: pop     HL              ; Restore MSB and exponent
4807+ 32CC 22 D2 55             ld      (FPREG+2),HL    ; Save base in FPREG
4808+ 32CF E1                   pop     HL              ; LSBs of base
4809+ 32D0 22 D0 55             ld      (FPREG),HL      ; Save in FPREG
4810+ 32D3 DC 90 32             call    C,NEGAFT        ; Odd power - Negate result
4811+ 32D6 CC 25 30             call    Z,INVSGN        ; Negative base - Negate it
4812+ 32D9 D5                   push    DE              ; Save power
4813+ 32DA C5                   push    BC
4814+ 32DB CD 5F 2E             call    LOG             ; Get LOG of base
4815+ 32DE C1                   pop     BC              ; Restore power
4816+ 32DF D1                   pop     DE
4817+ 32E0 CD A0 2E             call    FPMULT          ; Multiply LOG by power
4818+ 32E3
4819+ 32E3 CD 2D 30     EXP:    call    STAKFP          ; Put value on stack
4820+ 32E6 01 38 81             ld      BC,$8138        ; BCDE = 1/Ln(2)
4821+ 32E9 11 3B AA             ld      DE,$AA3B
4822+ 32EC CD A0 2E             call    FPMULT          ; Multiply value by 1/LN(2)
4823+ 32EF 3A D3 55             ld      A,(FPEXP)       ; Get exponent
4824+ 32F2 FE 88                cp      $80+8           ; Is it in range?
4825+ 32F4 D2 D8 2F             jp      NC,OVTST1       ; No - Test for overflow
4826+ 32F7 CD CF 30             call    INT             ; Get INT of FPREG
4827+ 32FA C6 80                add     A,$80           ; For excess 128
4828+ 32FC C6 02                add     A,$02           ; Exponent > 126?
4829+ 32FE DA D8 2F             jp      C,OVTST1        ; Yes - Test for overflow
4830+ 3301 F5                   push    AF              ; Save scaling factor
4831+ 3302 21 4E 2E             ld      HL,UNITY        ; Point to 1.
4832+ 3305 CD 56 2D             call    ADDPHL          ; Add 1 to FPREG
4833+ 3308 CD 97 2E             call    MULLN2          ; Multiply by LN(2)
4834+ 330B F1                   pop     AF              ; Restore scaling factor
4835+ 330C C1                   pop     BC              ; Restore exponent
4836+ 330D D1                   pop     DE
4837+ 330E F5                   push    AF              ; Save scaling factor
4838+ 330F CD 62 2D             call    SUBCDE          ; Subtract exponent from FPREG
4839+ 3312 CD 25 30             call    INVSGN          ; Negate result
4840+ 3315 21 23 33             ld      HL,EXPTAB       ; Coefficient table
4841+ 3318 CD 53 33             call    SMSER1          ; Sum the series
4842+ 331B 11 00 00             ld      DE,$0000        ; Zero LSBs
4843+ 331E C1                   pop     BC              ; Scaling factor
4844+ 331F 4A                   ld      C,D             ; Zero MSB
4845+ 3320 C3 A0 2E             jp      FPMULT          ; Scale result to correct value
4846+ 3323
4847+ 3323 08           EXPTAB: defb    $08             ; Table used by EXP
4848+ 3324 40 2E 94 74          defb    $40,$2E,$94,$74 ; -1/7! (-1/5040)
4849+ 3328 70 4F 2E 77          defb    $70,$4F,$2E,$77 ;  1/6! ( 1/720)
4850+ 332C 6E 02 88 7A          defb    $6E,$02,$88,$7A ; -1/5! (-1/120)
4851+ 3330 E6 A0 2A 7C          defb    $E6,$A0,$2A,$7C ;  1/4! ( 1/24)
4852+ 3334 50 AA AA 7E          defb    $50,$AA,$AA,$7E ; -1/3! (-1/6)
4853+ 3338 FF FF 7F 7F          defb    $FF,$FF,$7F,$7F ;  1/2! ( 1/2)
4854+ 333C 00 00 80 81          defb    $00,$00,$80,$81 ; -1/1! (-1/1)
4855+ 3340 00 00 00 81          defb    $00,$00,$00,$81 ;  1/0! ( 1/1)
4856+ 3344
4857+ 3344 CD 2D 30     SUMSER: call    STAKFP          ; Put FPREG on stack
4858+ 3347 11 9E 2E             ld      DE,MULT         ; Multiply by "X"
4859+ 334A D5                   push    DE              ; To be done after
4860+ 334B E5                   push    HL              ; Save address of table
4861+ 334C CD 48 30             call    BCDEFP          ; Move FPREG to BCDE
4862+ 334F CD A0 2E             call    FPMULT          ; Square the value
4863+ 3352 E1                   pop     HL              ; Restore address of table
4864+ 3353 CD 2D 30     SMSER1: call    STAKFP          ; Put value on stack
4865+ 3356 7E                   ld      A,(HL)          ; Get number of coefficients
4866+ 3357 23                   inc     HL              ; Point to start of table
4867+ 3358 CD 3A 30             call    PHLTFP          ; Move coefficient to FPREG
4868+ 335B 06                   defb    06H             ; Skip "pop AF"
4869+ 335C F1           SUMLP:  pop     AF              ; Restore count
4870+ 335D C1                   pop     BC              ; Restore number
4871+ 335E D1                   pop     DE
4872+ 335F 3D                   dec     A               ; Cont coefficients
4873+ 3360 C8                   ret     Z               ; All done
4874+ 3361 D5                   push    DE              ; Save number
4875+ 3362 C5                   push    BC
4876+ 3363 F5                   push    AF              ; Save count
4877+ 3364 E5                   push    HL              ; Save address in table
4878+ 3365 CD A0 2E             call    FPMULT          ; Multiply FPREG by BCDE
4879+ 3368 E1                   pop     HL              ; Restore address in table
4880+ 3369 CD 4B 30             call    LOADFP          ; Number at HL to BCDE
4881+ 336C E5                   push    HL              ; Save address in table
4882+ 336D CD 65 2D             call    FPADD           ; Add coefficient to FPREG
4883+ 3370 E1                   pop     HL              ; Restore address in table
4884+ 3371 C3 5C 33             jp      SUMLP           ; More coefficients
4885+ 3374
4886+ 3374
4887+ 3374              ; random number generator
4888+ 3374              ; a negative argument is used as a seed for the RNG
4889+ 3374              ; 0 is used to repeat the last random number
4890+ 3374              ; a positive argument generates a new random number
4891+ 3374 CD FC 2F     RND:    call    TSTSGN          ; Test sign of FPREG
4892+ 3377 21 F4 53             ld      HL,SEED+2       ; Random number seed
4893+ 337A FA D5 33             jp      M,RESEED        ; Negative - Re-seed
4894+ 337D 21 15 54             ld      HL,LSTRND       ; Last random number
4895+ 3380 CD 3A 30             call    PHLTFP          ; Move last RND to FPREG
4896+ 3383 21 F4 53             ld      HL,SEED+2       ; Random number seed
4897+ 3386 C8                   ret     Z               ; Return if RND(0)
4898+ 3387 86                   add     A,(HL)          ; Add (SEED+2)
4899+ 3388 E6 07                and     %00000111       ; 0 to 7
4900+ 338A 06 00                ld      B,$00
4901+ 338C 77                   ld      (HL),A          ; Re-save seed
4902+ 338D 23                   inc     HL              ; Move to coefficient table
4903+ 338E 87                   add     A,A             ; 4 bytes
4904+ 338F 87                   add     A,A             ; per entry
4905+ 3390 4F                   ld      C,A             ; BC = Offset into table
4906+ 3391 09                   add     HL,BC           ; Point to coefficient
4907+ 3392 CD 4B 30             call    LOADFP          ; Coefficient to BCDE
4908+ 3395 CD A0 2E             call    FPMULT          ; Multiply FPREG by coefficient
4909+ 3398 3A F3 53             ld      A,(SEED+1)      ; Get (SEED+1)
4910+ 339B 3C                   inc     A               ; Add 1
4911+ 339C E6 03                and     %00000011       ; 0 to 3
4912+ 339E 06 00                ld      B,$00
4913+ 33A0 FE 01                cp      $01             ; Is it zero?
4914+ 33A2 88                   adc     A,B             ; Yes - Make it 1
4915+ 33A3 32 F3 53             ld      (SEED+1),A      ; Re-save seed
4916+ 33A6 21 D9 33             ld      HL,RNDTAB-4     ; Addition table
4917+ 33A9 87                   add     A,A             ; 4 bytes
4918+ 33AA 87                   add     A,A             ; per entry
4919+ 33AB 4F                   ld      C,A             ; BC = Offset into table
4920+ 33AC 09                   add     HL,BC           ; Point to value
4921+ 33AD CD 56 2D             call    ADDPHL          ; Add value to FPREG
4922+ 33B0 CD 48 30     RND1:   call    BCDEFP          ; Move FPREG to BCDE
4923+ 33B3 7B                   ld      A,E             ; Get LSB
4924+ 33B4 59                   ld      E,C             ; LSB = MSB
4925+ 33B5 EE 4F                xor     %01001111       ; Fiddle around
4926+ 33B7 4F                   ld      C,A             ; New MSB
4927+ 33B8 36 80                ld      (HL),$80        ; Set exponent
4928+ 33BA 2B                   dec     HL              ; Point to MSB
4929+ 33BB 46                   ld      B,(HL)          ; Get MSB
4930+ 33BC 36 80                ld      (HL),$80        ; Make value -0.5
4931+ 33BE 21 F2 53             ld      HL,SEED         ; Random number seed
4932+ 33C1 34                   inc     (HL)            ; Count seed
4933+ 33C2 7E                   ld      A,(HL)          ; Get seed
4934+ 33C3 D6 AB                sub     $AB             ; Do it modulo 171
4935+ 33C5 C2 CC 33             jp      NZ,RND2         ; Non-zero - Ok
4936+ 33C8 77                   ld      (HL),A          ; Zero seed
4937+ 33C9 0C                   inc     C               ; Fillde about
4938+ 33CA 15                   dec     D               ; with the
4939+ 33CB 1C                   inc     E               ; number
4940+ 33CC CD B6 2D     RND2:   call    BNORM           ; Normalise number
4941+ 33CF 21 15 54             ld      HL,LSTRND       ; Save random number
4942+ 33D2 C3 54 30             jp      FPTHL           ; Move FPREG to last and return
4943+ 33D5
4944+ 33D5 77           RESEED: ld      (HL),A          ; Re-seed random numbers
4945+ 33D6 2B                   dec     HL
4946+ 33D7 77                   ld      (HL),A
4947+ 33D8 2B                   dec     HL
4948+ 33D9 77                   ld      (HL),A
4949+ 33DA C3 B0 33             jp      RND1            ; Return RND seed
4950+ 33DD
4951+ 33DD 68 B1 46 68  RNDTAB: defb    $68,$B1,$46,$68 ; Table used by RND
4952+ 33E1 99 E9 92 69          defb    $99,$E9,$92,$69
4953+ 33E5 10 D1 75 68          defb    $10,$D1,$75,$68
4954+ 33E9
4955+ 33E9              ; COS and SIN functions
4956+ 33E9 21 33 34     COS:    ld      HL,HALFPI       ; Point to PI/2
4957+ 33EC CD 56 2D             call    ADDPHL          ; Add it to PPREG
4958+ 33EF CD 2D 30     SIN:    call    STAKFP          ; Put angle on stack
4959+ 33F2 01 49 83             ld      BC,$8349        ; BCDE = 2 PI
4960+ 33F5 11 DB 0F             ld      DE,$0FDB
4961+ 33F8 CD 3D 30             call    FPBCDE          ; Move 2 PI to FPREG
4962+ 33FB C1                   pop     BC              ; Restore angle
4963+ 33FC D1                   pop     DE
4964+ 33FD CD 52 2F             call    DVBCDE          ; Divide angle by 2 PI
4965+ 3400 CD 2D 30             call    STAKFP          ; Put it on stack
4966+ 3403 CD CF 30             call    INT             ; Get INT of result
4967+ 3406 C1                   pop     BC              ; Restore number
4968+ 3407 D1                   pop     DE
4969+ 3408 CD 62 2D             call    SUBCDE          ; Make it 0 <= value < 1
4970+ 340B 21 37 34             ld      HL,QUARTR       ; Point to 0.25
4971+ 340E CD 5C 2D             call    SUBPHL          ; Subtract value from 0.25
4972+ 3411 CD FC 2F             call    TSTSGN          ; Test sign of value
4973+ 3414 37                   scf                     ; Flag positive
4974+ 3415 F2 1F 34             jp      P,SIN1          ; Positive - Ok
4975+ 3418 CD 53 2D             call    ROUND           ; Add 0.5 to value
4976+ 341B CD FC 2F             call    TSTSGN          ; Test sign of value
4977+ 341E B7                   or      A               ; Flag negative
4978+ 341F F5           SIN1:   push    AF              ; Save sign
4979+ 3420 F4 25 30             call    P,INVSGN        ; Negate value if positive
4980+ 3423 21 37 34             ld      HL,QUARTR       ; Point to 0.25
4981+ 3426 CD 56 2D             call    ADDPHL          ; Add 0.25 to value
4982+ 3429 F1                   pop     AF              ; Restore sign
4983+ 342A D4 25 30             call    NC,INVSGN       ; Negative - Make positive
4984+ 342D 21 3B 34             ld      HL,SINTAB       ; Coefficient table
4985+ 3430 C3 44 33             jp      SUMSER          ; Evaluate sum of series
4986+ 3433
4987+ 3433 DB 0F 49 81  HALFPI: defb    $DB,$0F,$49,$81 ; 1.5708 (PI/2)
4988+ 3437
4989+ 3437 00 00 00 7F  QUARTR: defb    $00,$00,$00,$7F ; 0.25
4990+ 343B
4991+ 343B 05           SINTAB: defb    $05             ; Table used by SIN
4992+ 343C BA D7 1E 86          defb    $BA,$D7,$1E,$86 ; 39.711
4993+ 3440 64 26 99 87          defb    $64,$26,$99,$87 ;-76.575
4994+ 3444 58 34 23 87          defb    $58,$34,$23,$87 ; 81.602
4995+ 3448 E0 5D A5 86          defb    $E0,$5D,$A5,$86 ;-41.342
4996+ 344C DA 0F 49 83          defb    $DA,$0F,$49,$83 ;  6.2832
4997+ 3450
4998+ 3450 CD 2D 30     TAN:    call    STAKFP          ; Put angle on stack
4999+ 3453 CD EF 33             call    SIN             ; Get SIN of angle
5000+ 3456 C1                   pop     BC              ; Restore angle
5001+ 3457 E1                   pop     HL
5002+ 3458 CD 2D 30             call    STAKFP          ; Save SIN of angle
5003+ 345B EB                   ex      DE,HL           ; BCDE = Angle
5004+ 345C CD 3D 30             call    FPBCDE          ; Angle to FPREG
5005+ 345F CD E9 33             call    COS             ; Get COS of angle
5006+ 3462 C3 50 2F             jp      DIV             ; TAN = SIN / COS
5007+ 3465
5008+ 3465 CD FC 2F     ATN:    call    TSTSGN          ; Test sign of value
5009+ 3468 FC 90 32             call    M,NEGAFT        ; Negate result after if -ve
5010+ 346B FC 25 30             call    M,INVSGN        ; Negate value if -ve
5011+ 346E 3A D3 55             ld      A,(FPEXP)       ; Get exponent
5012+ 3471 FE 81                cp      81H             ; Number less than 1?
5013+ 3473 DA 82 34             jp      C,ATN1          ; Yes - Get arc tangnt
5014+ 3476 01 00 81             ld      BC,$8100        ; BCDE = 1
5015+ 3479 51                   ld      D,C
5016+ 347A 59                   ld      E,C
5017+ 347B CD 52 2F             call    DVBCDE          ; Get reciprocal of number
5018+ 347E 21 5C 2D             ld      HL,SUBPHL       ; Sub angle from PI/2
5019+ 3481 E5                   push    HL              ; Save for angle > 1
5020+ 3482 21 8C 34     ATN1:   ld      HL,ATNTAB       ; Coefficient table
5021+ 3485 CD 44 33             call    SUMSER          ; Evaluate sum of series
5022+ 3488 21 33 34             ld      HL,HALFPI       ; PI/2 - angle in case > 1
5023+ 348B C9                   ret                     ; Number > 1 - Sub from PI/2
5024+ 348C
5025+ 348C 09           ATNTAB: defb    $09             ; Table used by ATN
5026+ 348D 4A D7 3B 78          defb    $4A,$D7,$3B,$78 ; 1/17
5027+ 3491 02 6E 84 7B          defb    $02,$6E,$84,$7B ;-1/15
5028+ 3495 FE C1 2F 7C          defb    $FE,$C1,$2F,$7C ; 1/13
5029+ 3499 74 31 9A 7D          defb    $74,$31,$9A,$7D ;-1/11
5030+ 349D 84 3D 5A 7D          defb    $84,$3D,$5A,$7D ; 1/9
5031+ 34A1 C8 7F 91 7E          defb    $C8,$7F,$91,$7E ;-1/7
5032+ 34A5 E4 BB 4C 7E          defb    $E4,$BB,$4C,$7E ; 1/5
5033+ 34A9 6C AA AA 7F          defb    $6C,$AA,$AA,$7F ;-1/3
5034+ 34AD 00 00 00 81          defb    $00,$00,$00,$81 ; 1/1
5035+ 34B1
5036+ 34B1
5037+ 34B1 D7           GETINP: rst     $10             ; input a character
5038+ 34B2 C9                   ret
5039+ 34B3
5040+ 34B3 E5           CLS:    push    HL
5041+ 34B4 D5                   push    DE
5042+ 34B5 3A 6E 55             ld      A,(SCR_MODE)    ; check screen mode
5043+ 34B8 FE 02                cp      $02             ; G2 mode?
5044+ 34BA CC E2 05             call    Z,EMPTYVIDBUF   ; yes, reset video buffer
5045+ 34BD D1                   pop     DE
5046+ 34BE E1                   pop     HL
5047+ 34BF 3E 0C                ld      A,CS            ; ASCII Clear screen
5048+ 34C1 CD 53 1B             call    SND2VID         ; send to screen
5049+ 34C4 C3 0C 41             jp      MONOUT          ; Output character
5050+ 34C7
5051+ 34C7 CD 75 2A     WIDTH:  call    GETINT          ; Get integer 0-255
5052+ 34CA 7B                   ld      A,E             ; Width to A
5053+ 34CB 32 1C 54             ld      (LWIDTH),A      ; Set width
5054+ 34CE C9                   ret
5055+ 34CF
5056+ 34CF
5057+ 34CF              ; read a word (2 bytes) from a couple of RAM locations, in little-endian format
5058+ 34CF              ; i.e., the first location is the LSB, while the second one is the MSB
5059+ 34CF CD 14 1E     DEEK:   call    DEINT           ; Get integer -32768 to 32767
5060+ 34D2 D5                   push    DE              ; Save number
5061+ 34D3 E1                   pop     HL              ; Number to HL
5062+ 34D4 46                   ld      B,(HL)          ; Get LSB of contents
5063+ 34D5 23                   inc     HL
5064+ 34D6 7E                   ld      A,(HL)          ; Get MSB of contents
5065+ 34D7 C3 D9 25             jp      ABPASS          ; Return integer AB
5066+ 34DA
5067+ 34DA              ; write a word (2 bytes) into a couple of RAM locations, in little-endian format
5068+ 34DA              ; i.e., the LSB will go into the first location, while the MSB into the second one
5069+ 34DA CD EF 21     DOKE:   call    GETNUM          ; Get a number
5070+ 34DD CD 14 1E             call    DEINT           ; Get integer -32768 to 32767
5071+ 34E0 D5                   push    DE              ; Save address
5072+ 34E1 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
5073+ 34E4 2C                   defb    ','
5074+ 34E5 CD EF 21             call    GETNUM          ; Get a number
5075+ 34E8 CD 14 1E             call    DEINT           ; Get integer -32768 to 32767
5076+ 34EB E3                   ex      (SP),HL         ; Save value,get address
5077+ 34EC 73                   ld      (HL),E          ; Save LSB of value
5078+ 34ED 23                   inc     HL
5079+ 34EE 72                   ld      (HL),D          ; Save MSB of value
5080+ 34EF E1                   pop     HL              ; Restore code string address
5081+ 34F0 C9                   ret
5082+ 34F1
5083+ 34F1              ; stop the execution of code for a certain bit of time. The pause
5084+ 34F1              ; is between $0000 and $FFFF 100ths of a second (0~655.5 secs)
5085+ 34F1 CD EF 21     PAUSE:  call    GETNUM          ; Get a number
5086+ 34F4 CD 14 1E             call    DEINT           ; Get integer -32768 to 32767
5087+ 34F7 7A                   ld      A,D             ; load D into A
5088+ 34F8 B3                   or      E               ; are D & E equal to $00?
5089+ 34F9 C8                   ret     Z               ; if yes, then return
5090+ 34FA C5                   push    BC              ; store BC
5091+ 34FB 3A 5C 55             ld      A,(TMRCNT)      ; Load current value of system timer
5092+ 34FE 47                   ld      B,A             ; move it into B
5093+ 34FF CD 89 1D     RPTPS:  call    TSTBRK          ; Test for break key
5094+ 3502 3A 5C 55             ld      A,(TMRCNT)      ; Load current value of system timer
5095+ 3505 B8                   cp      B               ; is it the same value?
5096+ 3506 28 F7                jr      Z,RPTPS         ; yes, so read again
5097+ 3508 47                   ld      B,A             ; no, so store the new value
5098+ 3509 1B                   dec     DE              ; decrement interval
5099+ 350A 7A                   ld      A,D             ; load D into A
5100+ 350B B3                   or      E               ; check if DE is equal to 0 (if D & e are $00 then result is 0)
5101+ 350C 20 F1                jr      NZ,RPTPS        ; no, repeat
5102+ 350E C1                   pop     BC              ; yes, recover BC and continue
5103+ 350F C9                   ret
5104+ 3510
5105+ 3510              ; change the screen mode and set some graphic features. Usage: SCREEN X[,Y][,Z]
5106+ 3510              ; where X is graphic mode:
5107+ 3510              ; 0=text mode (40x24), 1=graphic mode 1 (32x24 chars); 2=graphic mode 2 (256x192 pixels);
5108+ 3510              ; 3=multicolor mode (64x48 pixels); 4=extended graphic mode 2 (32x24 chars mixed between G1 and G2)
5109+ 3510              ; Y is: 0=8x8 sprites, 1=16x16 sprites
5110+ 3510              ; Z is: 0=no sprite magnification; 1=sprite magnification x2 (8x8=>16x16, and 16x16=32x32)
5111+ 3510              ; (the latters are accepted only in graphic modes G1, G2, G3, and G4)
5112+ 3510 AF           SCREEN: xor     A
5113+ 3511 32 7E 55             ld      (TMPBFR2),A     ; sprite size & magnif. byte set to 0
5114+ 3514 CD 75 2A             call    GETINT          ; Get integer 0-255
5115+ 3517 FE 05                cp      $05             ; is it a valid mode (0~4)?
5116+ 3519 D2 29 1E             jp      NC,FCERR        ; No - Illegal function call Error
5117+ 351C 32 7C 55             ld      (TMPBFR1),A     ; store graphic mode
5118+ 351F A7                   and     A               ; is it 0 (text mode)?
5119+ 3520 CA 3C 35             jp      Z,SCVDP         ; yes, ignore other arguments and set mode immediately
5120+ 3523 CD 7B 35             call    CHKSCAR         ; no, check if sprite size follows
5121+ 3526 DA 2E 35             jp      C,CKMAGN        ; no (set to 0 or missing), so jump over
5122+ 3529 3E 02                ld      A,$02           ; no, so set sprite size
5123+ 352B 32 7E 55             ld      (TMPBFR2),A     ; ...to 16x16
5124+ 352E CD 7B 35     CKMAGN: call    CHKSCAR         ; check if sprite magnification follows
5125+ 3531 DA 3C 35             jp      C,SCVDP         ; no (set to 0 or missing), so jump over
5126+ 3534 3A 7E 55             ld      A,(TMPBFR2)     ; yes, so retrieve sprite attributes...
5127+ 3537 F6 01                or      $01             ; ...set sprite magnification to 2x...
5128+ 3539 32 7E 55             ld      (TMPBFR2),A     ; ...and save flags again
5129+ 353C F3           SCVDP:  di                      ; disable INTs
5130+ 353D D5                   push    DE              ; store DE
5131+ 353E E5                   push    HL              ; store HL
5132+ 353F 3A 7C 55             ld      A,(TMPBFR1)     ; recover graphic mode
5133+ 3542 5F                   ld      E,A             ; and store it into E
5134+ 3543 3A 7E 55             ld      A,(TMPBFR2)     ; recover sprite flags
5135+ 3546 57                   ld      D,A             ; and store them into D
5136+ 3547 D5                   push    DE              ; store D & E
5137+ 3548 CD D1 03             call    initVDP         ; initialize VDP with mode pointed by E
5138+ 354B D1                   pop     DE              ; retrieve D & E
5139+ 354C 7B                   ld      A,E             ; move graphic mode into A
5140+ 354D 87                   add     A,A
5141+ 354E 87                   add     A,A
5142+ 354F 87                   add     A,A             ; multiply A times 8 to get offset of graphic mode
5143+ 3550 5F                   ld      E,A             ; and pass it into E
5144+ 3551 D5                   push    DE              ; store sprite flags in E
5145+ 3552 16 00                ld      D,$00           ; reset D
5146+ 3554 21 2A 0B             ld      HL,VDPMODESET+1 ; load address of VDP settings for reg#1
5147+ 3557 19                   add     HL,DE           ; load correct reg#1 setting
5148+ 3558 D1                   pop     DE              ; retrieve sprite flags from E
5149+ 3559 7E                   ld      A,(HL)          ; load reg#1 setting
5150+ 355A E6 FC                and     %11111100       ; reset size & magn. bits
5151+ 355C B2                   or      D               ; set size & magn. bits
5152+ 355D 5F                   ld      E,A             ; value into E
5153+ 355E 3E 01                ld      A,$01           ; reg #1
5154+ 3560 CD BA 06             call    WRITE_VREG      ; send setting to reg #1
5155+ 3563 2A 29 54             ld      HL,(LINEAT)     ; Get current line number
5156+ 3566 23                   inc     HL              ; -1 means direct statement
5157+ 3567 7C                   ld      A,H
5158+ 3568 B5                   or      L
5159+ 3569 CC 2D 09             call    Z,CURSOR_ON     ; enable cursor if not in program mode
5160+ 356C FB                   ei                      ; re-enable interrupts
5161+ 356D E1                   pop     HL              ; restore HL
5162+ 356E D1                   pop     DE              ; restore DE
5163+ 356F 3A 6D 55             ld      A,(SCR_SIZE_H)  ; check the screen mode by looking at the screen height
5164+ 3572 FE 30                cp      $30             ; is it 48 chars or 192 pixels (MC and G2 modes)?
5165+ 3574 D0                   ret     NC              ; yes, so exit (in graphics 2 and multicolor no print-on-video)
5166+ 3575 3E 01                ld      A,$01           ; no (we are in Text, G1 or ExG2), so activate the...
5167+ 3577 32 78 55             ld      (PRNTVIDEO),A   ; ...video buffer...
5168+ 357A C9                   ret                     ; ...and return to caller
5169+ 357B
5170+ 357B              ; check an additional argument for SCREEN - There are 2 ways of working:
5171+ 357B              ; to check if something follows: Carry is 1 is no argument follows, 0 otherwise
5172+ 357B              ; to check the value of the following argument: 0 is argument is 1, 1 is argument is <> 1
5173+ 357B 2B           CHKSCAR:dec     HL              ; dec 'cos GETCHR INCs
5174+ 357C CD 5E 1D             call    GETCHR          ; Get next character
5175+ 357F 37                   scf                     ; set carry flag
5176+ 3580 C8                   ret     Z               ; return if nothing follows with Carry=1
5177+ 3581 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
5178+ 3584 2C                   defb    ','
5179+ 3585 CD 75 2A             call    GETINT          ; get value
5180+ 3588 1F                   rra                     ; Carry=bit #0
5181+ 3589 3F                   ccf                     ; invert Carry, so Carry=0 if arg. is 1, and Carry=1 otherwise (arg<>1)
5182+ 358A C9                   ret                     ; return
5183+ 358B
5184+ 358B
5185+ 358B              ; change the colors of the screen - Syntax is COLOR a,b,c where:
5186+ 358B              ; a=foreground color / b=background color / c=border color
5187+ 358B              ; a,b,c must be in a range between 1 and 15 (0 is transparent and it's not supported)
5188+ 358B              ; the number of arguments is based on the current screen mode
5189+ 358B CD 75 2A     COLOR:  call    GETINT          ; get first value
5190+ 358E CD 33 36             call    CHKCLR1         ; check if it's in range 1~15
5191+ 3591 32 7C 55             ld      (TMPBFR1),A     ; store it
5192+ 3594 3A 6E 55             ld      A,(SCR_MODE)    ; check screen mode
5193+ 3597 FE 03                cp      $03             ; is it multicolor mode?
5194+ 3599 20 0D                jr      NZ,CNTCKCL      ; no, continue
5195+ 359B 3E 0F                ld      A,$0F           ; white for...
5196+ 359D 32 7A 55             ld      (FRGNDCLR),A    ; ...foreground (even it's not used in MC)
5197+ 35A0 3A 7C 55             ld      A,(TMPBFR1)     ; yes, so we stop here because in MC mode we just support border color
5198+ 35A3 32 80 55             ld      (TMPBFR3),A     ; move color into temp buffer 3
5199+ 35A6 18 31                jr      CLRMC           ; jump to set color
5200+ 35A8 CD 15 1B     CNTCKCL:call    CHKSYN          ; Make sure ',' follows
5201+ 35AB 2C                   defb    ','
5202+ 35AC CD 75 2A             call    GETINT          ; get second value
5203+ 35AF CD 33 36             call    CHKCLR1         ; check if it's in range 1~15
5204+ 35B2 32 7E 55             ld      (TMPBFR2),A     ; store it
5205+ 35B5 3A 6E 55             ld      A,(SCR_MODE)    ; check screen mode
5206+ 35B8 A7                   and     A               ; is it text mode?
5207+ 35B9 28 1B                jr      Z,CLRTXT        ; yes, stop here because in text mode, background and border colors coincide
5208+ 35BB CD 15 1B             call    CHKSYN          ; Make sure ',' follows
5209+ 35BE 2C                   defb    ','
5210+ 35BF CD 75 2A             call    GETINT          ; get third value
5211+ 35C2 CD 33 36             call    CHKCLR1         ; check if it's in range 1~15
5212+ 35C5 32 80 55             ld      (TMPBFR3),A     ; store it
5213+ 35C8 D5                   push    DE              ; store DE
5214+ 35C9 3A 6E 55             ld      A,(SCR_MODE)    ; check screen mode
5215+ 35CC FE 01                cp      $01             ; is it G1 mode?
5216+ 35CE 28 10                jr      Z,CLRG1         ; yes, jump over
5217+ 35D0 FE 02                cp      $02             ; is it G2 mode?
5218+ 35D2 28 15                jr      Z,CLRG2         ; yes, jump over
5219+ 35D4 18 1C                jr      CLREX2          ; last case can only be ExG2
5220+ 35D6 CD 26 36     CLRTXT: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5221+ 35D9 32 80 55     CLRMC:  ld      (TMPBFR3),A     ; store color settings (for MC mode, we only set border color)
5222+ 35DC D5                   push    DE              ; store DE
5223+ 35DD F3                   di                      ; disable INTs
5224+ 35DE 18 2D                jr      SETBRCL         ; set colors and exit
5225+ 35E0 CD 26 36     CLRG1:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5226+ 35E3 16 01                ld      D,$01           ; repeat 1 time
5227+ 35E5 06 20                ld      B,$20           ; 32 bytes of colors
5228+ 35E7 18 10                jr      LOADCLR         ; load colors
5229+ 35E9 CD 26 36     CLRG2:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5230+ 35EC 16 18                ld      D,$18           ; 18 pages of...
5231+ 35EE 06 00                ld      B,$00           ; ...256 bytes each
5232+ 35F0 18 07                jr      LOADCLR         ; load colors
5233+ 35F2 CD 26 36     CLREX2: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5234+ 35F5 16 08                ld      D,$08           ; 8 pages of...
5235+ 35F7 06 00                ld      B,$00           ; ...256 bytes each
5236+ 35F9 E5           LOADCLR:push    HL              ; store HL
5237+ 35FA 21 00 20             ld      HL,$2000        ; color table start: $2000
5238+ 35FD F3                   di                      ; disable INTs
5239+ 35FE CD 70 06             call    SETVDPADRS
5240+ 3601 0D                   dec     C               ; VDP data mode
5241+ 3602 ED 79        RPTLDCL:out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
5242+ 3604 00                   nop
5243+ 3605 00                   nop
5244+ 3606 10 FA                djnz    RPTLDCL         ; repeat for 256 bytes (1 page)
5245+ 3608 15                   dec     D               ; did we fill up all the pages?
5246+ 3609 20 F7                jr      NZ,RPTLDCL      ; no, repeat
5247+ 360B FB                   ei
5248+ 360C E1                   pop     HL              ; retrieve HL
5249+ 360D 3A 7C 55     SETBRCL:ld      A,(TMPBFR1)     ; retrieve foreground color
5250+ 3610 32 7A 55             ld      (FRGNDCLR),A    ; store it
5251+ 3613 3A 7E 55             ld      A,(TMPBFR2)     ; retrieve background color
5252+ 3616 32 7B 55             ld      (BKGNDCLR),A    ; store it
5253+ 3619 3A 80 55             ld      A,(TMPBFR3)     ; recover border color
5254+ 361C 5F                   ld      E,A             ; move it into E
5255+ 361D 3E 07                ld      A,$07           ; set VDP register 7
5256+ 361F F3                   di
5257+ 3620 CD BA 06             call    WRITE_VREG      ; send value to VDP: set border color
5258+ 3623 FB                   ei                      ; re-enable INTs
5259+ 3624 D1                   pop     DE              ; retrieve DE
5260+ 3625 C9                   ret                     ; return to caller
5261+ 3626
5262+ 3626
5263+ 3626              ; mix 2 color nibbles in 1 byte
5264+ 3626 3A 7E 55     MIXCLRS:ld      A,(TMPBFR2)     ; retrieve background color
5265+ 3629 47                   ld      B,A             ; move it into B
5266+ 362A 3A 7C 55             ld      A,(TMPBFR1)     ; retrieve foreground color
5267+ 362D 87                   add     A,A             ; move foreground color into the high nibble of A
5268+ 362E 87                   add     A,A
5269+ 362F 87                   add     A,A
5270+ 3630 87                   add     A,A
5271+ 3631 B0                   or      B               ; put background color into the low nibble of A
5272+ 3632 C9                   ret                     ; return to caller
5273+ 3633
5274+ 3633
5275+ 3633              ; check if the color is not 0 and into the range 1~15
5276+ 3633 A7           CHKCLR1:and     A               ; is it 0?
5277+ 3634 CA 17 18             jp      Z,SNERR         ; yes, raise a SN error
5278+ 3637 FE 10        CHKCLR0:cp      $10             ; is it in range 0~15?
5279+ 3639 D2 17 18             jp      NC,SNERR        ; no, raise a SN error
5280+ 363C C9                   ret                     ; param is OK, can return
5281+ 363D
5282+ 363D
5283+ 363D              ; check if in graphics 2 mode
5284+ 363D 3A 6E 55     CHKG2M: ld      A,(SCR_MODE)    ; check screen mode
5285+ 3640 FE 02                cp      $02             ; actually, we can paint only in G2
5286+ 3642 C2 4A 3C             jp      NZ,GMERR        ; no G2, print a No Graphics Mode Error
5287+ 3645 C9                   ret                     ; return to caller
5288+ 3646
5289+ 3646
5290+ 3646              ; print a text in screen 2
5291+ 3646              ; GPRINT text,x,y[,fc[,bc]]
5292+ 3646              ; where "text" is an expression that can be converted into a sequence of ASCII chars,
5293+ 3646              ; x & y are the coordinates (0<=x<=31, 0<=y<=23), fc & bc are foreground and background
5294+ 3646              ; colors (1~15), resp.
5295+ 3646              ; (portions of code are from nippur72)
5296+ 3646              GX      equ     TMPBFR3
5297+ 3646              GY      equ     TMPBFR4
5298+ 3646              TMPCLR  equ     TMPBFR2
5299+ 3646              MIXCOL  equ     TMPBFR1
5300+ 3646              TMPADR  equ     VIDEOBUFF
5301+ 3646              CHRPNT  equ     VIDEOBUFF+$02
5302+ 3646              NUMCHR  equ     VIDEOBUFF+$04
5303+ 3646              TMPHL   equ     VIDEOBUFF+$06
5304+ 3646 CD 3D 36     GPRINT: call    CHKG2M          ; check if in graphic mode 2
5305+ 3649 2B                   dec     HL              ; dec 'cos GETCHR INCs
5306+ 364A CD 5E 1D             call    GETCHR          ; check if something follows
5307+ 364D CA 17 18             jp      Z,SNERR         ; if nothing else, raise a syntax error
5308+ 3650 22 84 55             ld      (TMPADR),HL     ; save current code string pointer
5309+ 3653 CD 01 22             call    EVAL            ; Evaluate expression
5310+ 3656 CD F3 21             call    TSTSTR          ; Make sure it's a string
5311+ 3659 22 8A 55             ld      (TMPHL),HL      ; store code string pointer
5312+ 365C CD 3A 28             call    GSTRCU          ; Current string to pool
5313+ 365F CD 4B 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
5314+ 3662 ED 43 86 55          ld      (CHRPNT),BC     ; store string pointer
5315+ 3666 ED 53 88 55          ld      (NUMCHR),DE     ; store string lenght
5316+ 366A 2A 8A 55             ld      HL,(TMPHL)      ; restore code string pointer
5317+ 366D CD 15 1B             call    CHKSYN          ; Make sure ',' follows
5318+ 3670 2C                   defb    ','
5319+ 3671 CD 75 2A             call    GETINT          ; get X coord.
5320+ 3674 FE 20                cp      $20             ; is it in rage 0~31?
5321+ 3676 D2 29 1E             jp      NC,FCERR        ; Illegal function call error
5322+ 3679 32 80 55             ld      (GX),A          ; store into temp. buffer
5323+ 367C CD 15 1B             call    CHKSYN          ; Make sure ',' follows
5324+ 367F 2C                   defb    ','
5325+ 3680 CD 75 2A             call    GETINT          ; get Y coord.
5326+ 3683 FE 18                cp      $18             ; is it in range 0~23?
5327+ 3685 D2 29 1E             jp      NC,FCERR        ; Illegal function call error
5328+ 3688 32 82 55             ld      (GY),A          ; store into temp. buffer
5329+ 368B 11 7E 55             ld      DE,TMPCLR
5330+ 368E 3A 7B 55             ld      A,(BKGNDCLR)    ; load background color
5331+ 3691 12                   ld      (DE),A          ; store into temp buff
5332+ 3692 3A 7A 55             ld      A,(FRGNDCLR)    ; load foreground color
5333+ 3695 1B                   dec     DE
5334+ 3696 1B                   dec     DE
5335+ 3697 12                   ld      (DE),A          ; store into temp buff
5336+ 3698 CD 23 37             call    CKCOL           ; check color
5337+ 369B CA A3 36             jp      Z,CNTGPT2       ; if anything follows, jump over
5338+ 369E 13                   inc     DE
5339+ 369F 13                   inc     DE
5340+ 36A0 CD 23 37             call    CKCOL           ; check background color
5341+ 36A3 CD 26 36     CNTGPT2:call    MIXCLRS         ; mix foreground & background colors
5342+ 36A6 32 7C 55             ld      (MIXCOL),A      ; store mixed colors
5343+ 36A9 E5                   push    HL              ; store code string address
5344+ 36AA ED 4B 86 55          ld      BC,(CHRPNT)     ; retrieve string pointer
5345+ 36AE ED 5B 88 55          ld      DE,(NUMCHR)     ; retrieve string lenght
5346+ 36B2 1C                   inc     E               ; Length + 1
5347+ 36B3 CD B8 36             call    GPNT            ; print on G2
5348+ 36B6 E1                   pop     HL              ; recover HL
5349+ 36B7 C9                   ret                     ; return to caller
5350+ 36B8 D5           GPNT:   push    DE              ; store string lenght (E)
5351+ 36B9                      ; calculate VRAM address of first char
5352+ 36B9 3A 80 55             LD      A,(GX)          ; load X
5353+ 36BC 6F                   ld      L,A             ;
5354+ 36BD 26 00                ld      H,0             ; HL = X
5355+ 36BF 29                   add     HL,HL           ;
5356+ 36C0 29                   add     HL,HL           ;
5357+ 36C1 29                   add     HL,HL           ; X=X*8
5358+ 36C2 3A 82 55             ld      A,(GY)          ; load Y
5359+ 36C5 57                   ld      D,A             ; move it into D
5360+ 36C6 1E 00                ld      E,0             ; DE =Y*256
5361+ 36C8 19                   add     HL,DE           ; address = X*8 + Y*256
5362+ 36C9 22 84 55             ld      (TMPADR),HL     ; store VRAM address of first VRAM cell
5363+ 36CC D1                   pop     DE              ; retrieve # of chars to be printed yet (E)
5364+ 36CD 1D           RPGPNT: dec     E               ; Count characters
5365+ 36CE C8                   ret     Z               ; End of string - return
5366+ 36CF D5                   push    DE              ; store chars counter
5367+ 36D0                      ; calculate dest address in color vram
5368+ 36D0 2A 84 55             ld      HL,(TMPADR)     ; recover VRAM address
5369+ 36D3 11 00 20             ld      DE,$2000        ; color map address
5370+ 36D6 19                   add     HL,DE           ; HL = $2000 + XY address
5371+ 36D7 F3                   di                      ; disable INTs
5372+ 36D8                      ; send color settings
5373+ 36D8 CD 70 06             call    SETVDPADRS      ; set VRAM address for color cell
5374+ 36DB 3A 7C 55             ld      A,(MIXCOL)      ; load color settings
5375+ 36DE 06 08                ld      B,$08           ; repeat for 8 rows
5376+ 36E0 0E 30                ld      C,VDP_DAT       ; VDP data mode
5377+ 36E2 ED 79        GPNTCO1:out     (C),A           ; send data (VRAM pointer auto-increments)
5378+ 36E4 00                   nop                     ; wait...
5379+ 36E5 00                   nop                     ; ...a...
5380+ 36E6 00                   nop                     ; ...while
5381+ 36E7 10 F9                djnz    GPNTCO1         ; repeat for 8 cells
5382+ 36E9                      ; calculate source address
5383+ 36E9 2A 86 55             ld      HL,(CHRPNT)     ; load char pointer
5384+ 36EC 7E                   ld      A,(HL)          ; get char
5385+ 36ED 23                   inc     HL              ; increment char pointer
5386+ 36EE 22 86 55             ld      (CHRPNT),HL     ; store char pointer
5387+ 36F1 6F                   ld      L,A             ;
5388+ 36F2 26 00                ld      H,$00           ; char into HL
5389+ 36F4 29                   add     HL,HL           ;
5390+ 36F5 29                   add     HL,HL           ;
5391+ 36F6 29                   add     HL,HL           ; get offset of char into ROM (charcode * 8)
5392+ 36F7 11 6E 4A             ld      DE,CHRST88      ; DE = start of 8x8 fonts in ROM
5393+ 36FA 19                   add     HL,DE           ; HL = start of characters in ROM
5394+ 36FB EB                   ex      DE,HL           ; store address into DE
5395+ 36FC 2A 84 55             ld      HL,(TMPADR)     ; load VRAM address
5396+ 36FF CD 70 06             call    SETVDPADRS      ; send it to VDP
5397+ 3702 EB                   ex      DE,HL           ; restore address into HL
5398+ 3703 06 08                ld      B,$08           ; repeat for 8 rows
5399+ 3705 0D                   dec     C               ; VDP data mode
5400+ 3706 ED A3        GPCPCH1:outi                    ; load a byte from ROM and send to VRAM
5401+ 3708 00                   nop                     ; wait...
5402+ 3709 00                   nop                     ; ...a...
5403+ 370A 00                   nop                     ; ...while
5404+ 370B 20 F9                jr      NZ,GPCPCH1      ; repeat for 8 chars
5405+ 370D FB                   ei                      ; re-enable INTs
5406+ 370E 11 08 00             ld      DE,$0008        ; 8 bytes to go to the next video cell
5407+ 3711 2A 84 55             ld      HL,(TMPADR)     ; load VRAM address
5408+ 3714 19                   add     HL,DE           ; get address of next VRAM cell
5409+ 3715 22 84 55             ld      (TMPADR),HL     ; store new VRAM address
5410+ 3718 11 00 18             ld      DE,$1800        ; forbidden address
5411+ 371B CD 38 41             call    CMP16           ; check if the printing has gone out of the screen
5412+ 371E D1                   pop     DE              ; retrieve number of chars to be printed
5413+ 371F D0                   ret     NC              ; if HL>=$1800 then leave
5414+ 3720 C3 CD 36             jp      RPGPNT          ; otherwise, check if more chars to output
5415+ 3723
5416+ 3723              ; used by GPRINT to get a color argument (if present)
5417+ 3723 2B           CKCOL:  dec     HL              ; dec 'cos GETCHR INCs
5418+ 3724 CD 5E 1D             call    GETCHR          ; Get next character
5419+ 3727 C8                   ret     Z               ; return if nothing follows
5420+ 3728 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
5421+ 372B 2C                   defb    ','
5422+ 372C D5                   push    DE              ; store DE
5423+ 372D CD 75 2A             call    GETINT          ; get value
5424+ 3730 CD 33 36             call    CHKCLR1         ; check if color is in range 1~15
5425+ 3733 D1                   pop     DE              ; retrieve DE
5426+ 3734 12                   ld      (DE),A          ; store color into temp buffer
5427+ 3735 C9                   ret                     ; return to caller
5428+ 3736
5429+ 3736
5430+ 3736              ; paint X,Y[,C]: in graphics mode, fills an area starting
5431+ 3736              ; at point X,Y, using default color or, if used, with
5432+ 3736              ; color set by C
5433+ 3736              ; TMPBFR1       X
5434+ 3736              ; TMPBFR2       Y
5435+ 3736              ; TMPBFR3       COLOR
5436+ 3736              PNT     equ     VIDEOBUFF
5437+ 3736              ORGSP   equ     VIDEOBUFF+$02
5438+ 3736 CD 3D 36     PAINT:  call    CHKG2M          ; check if in graphic mode 2
5439+ 3739 CD 75 2A             call    GETINT          ; get X
5440+ 373C 32 7C 55             ld      (TMPBFR1),A     ; store X
5441+ 373F CD 15 1B             call    CHKSYN          ; Make sure ',' follows
5442+ 3742 2C                   defb    ','
5443+ 3743 CD 75 2A             call    GETINT          ; get Y coords,
5444+ 3746 FE C0                cp      $C0             ; check if Y is in range 0~191
5445+ 3748 D2 29 1E             jp      NC,FCERR        ; no, raise an FC error
5446+ 374B 32 7E 55             ld      (TMPBFR2),A     ; store Y
5447+ 374E CD 31 3C             call    CLRPRM          ; check if color has been passed
5448+ 3751 3A 80 55             ld      A,(TMPBFR3)     ; load color
5449+ 3754 A7                   and     A               ; check if 0
5450+ 3755 CA 29 1E             jp      Z,FCERR         ; yes, raise an error
5451+ 3758 E5                   push    HL              ; store HL
5452+ 3759 C5                   push    BC              ; store BC
5453+ 375A D5                   push    DE              ; store DE
5454+ 375B                      ; start algorithm
5455+ 375B CD 6E 38             call    PNTRTN          ; check if pixel is already set
5456+ 375E C2 12 38             jp      NZ,EXITPA2      ; if yes, then leave PAINT
5457+ 3761 ED 73 86 55          ld      (ORGSP),SP      ; no, store current Stack Pointer
5458+ 3765 21 01 00             ld      HL,$0001        ; HL=1
5459+ 3768 22 84 55             ld      (PNT),HL        ; set PNT
5460+ 376B 3A 7C 55             ld      A,(TMPBFR1)     ; load starting X...
5461+ 376E 47                   ld      B,A             ; ...into B
5462+ 376F 3A 7E 55             ld      A,(TMPBFR2)     ; load starting Y...
5463+ 3772 4F                   ld      C,A             ; ...into C
5464+ 3773 C5                   push    BC              ; store starting X,Y into stack
5465+ 3774                      ; main loop
5466+ 3774 2A 84 55     NXTLOOP:ld      HL,(PNT)        ; retrieve PNT
5467+ 3777 7C                   ld      A,H             ; check if PNT=0
5468+ 3778 B5                   or      L
5469+ 3779 CA 0E 38             jp      Z,EXITPAI       ; yes, no more points to process - exit
5470+ 377C 2B                   dec     HL              ; no, so decrement PNT...
5471+ 377D 22 84 55             ld      (PNT),HL        ; ...and store it
5472+ 3780 C1                   pop     BC              ; retrieve pixel coordinates X,Y into BC
5473+ 3781 CD 16 38     PAINT0: call    CHECKPA         ; check if pixel is set/reset
5474+ 3784 20 09                jr      NZ,PAINT11      ; pixel is set, so jump over
5475+ 3786 78                   ld      A,B             ; pixel is reset, check if X1=0
5476+ 3787 A7                   and     A               ; (reached the limit of the screen)
5477+ 3788 CA 90 37             jp      Z,PAINT1        ; yes, jump over
5478+ 378B 05                   dec     B               ; no, decrement X1...
5479+ 378C C3 81 37             jp      PAINT0          ; ...and repeat
5480+ 378F 04           PAINT11:inc     B               ; if found a pixel on, the re-increment X1
5481+ 3790 AF           PAINT1: xor     A               ; reset A
5482+ 3791 57                   ld      D,A             ; set SA=0
5483+ 3792 5F                   ld      E,A             ; set SB=0
5484+ 3793 CD 16 38     MNPAINT:call    CHECKPA         ; check if pixel is set/reset
5485+ 3796 20 DC                jr      NZ,NXTLOOP      ; it's set, so goto next loop
5486+ 3798 78                   ld      A,B             ; copy X1
5487+ 3799 32 7C 55             ld      (TMPBFR1),A     ; into buffer
5488+ 379C 79                   ld      A,C             ; copy Y
5489+ 379D 32 7E 55             ld      (TMPBFR2),A     ; into buffer
5490+ 37A0 CD 94 38             call    CNTPLOT         ; plot pixel X1,Y
5491+ 37A3 7A                   ld      A,D             ; load SA into A
5492+ 37A4 A7                   and     A               ; SA=0?
5493+ 37A5 20 1C                jr      NZ,PAINT2       ; no, jump over
5494+ 37A7 79                   ld      A,C             ; load Y
5495+ 37A8 FE 01                cp      $01             ; Y>0?
5496+ 37AA DA C3 37             jp      C,PAINT2        ; no, jump over
5497+ 37AD 3D                   dec     A               ; yes, Y=Y-1
5498+ 37AE CD 17 38             call    CHECKPY         ; check pixel X1,Y-1
5499+ 37B1 20 10                jr      NZ,PAINT2       ; it's set, so jump over
5500+ 37B3 0D                   dec     C               ; Y=Y-1
5501+ 37B4 C5                   push    BC              ; insert pixel(X1,Y-1) into stack
5502+ 37B5 0C                   inc     C               ; retrieve original Y
5503+ 37B6 2A 84 55             ld      HL,(PNT)        ; load PNT
5504+ 37B9 23                   inc     HL              ; increment PNT
5505+ 37BA 22 84 55             ld      (PNT),HL        ; store new PNT
5506+ 37BD 3E 01                ld      A,$01           ; set SA=1 and...
5507+ 37BF 57                   ld      D,A             ; ...store SA into memory
5508+ 37C0 C3 D6 37             jp      PAINT3          ; jump over
5509+ 37C3 7A           PAINT2: ld      A,D             ; load SA into A
5510+ 37C4 1F                   rra                     ; check if SA=1
5511+ 37C5 30 0F                jr      NC,PAINT3       ; no, jump over
5512+ 37C7 79                   ld      A,C             ; load Y
5513+ 37C8 FE 01                cp      $01             ; Y>0?
5514+ 37CA DA D6 37             jp      C,PAINT3        ; no, jump over
5515+ 37CD 3D                   dec     A               ; Y=Y-1
5516+ 37CE CD 17 38             call    CHECKPY         ; check pixel X1,Y-1
5517+ 37D1 CA D6 37             jp      Z,PAINT3        ; if pixel is off, jump over
5518+ 37D4 AF                   xor     A               ; pixel is on, so...
5519+ 37D5 57                   ld      D,A             ; ...set SA=0
5520+ 37D6 7B           PAINT3: ld      A,E             ; check if...
5521+ 37D7 A7                   and     A               ; SB=0
5522+ 37D8 20 1B                jr      NZ,PAINT4       ; no, jump over
5523+ 37DA 79                   ld      A,C             ; load Y
5524+ 37DB FE BF                cp      $BF             ; Y<191?
5525+ 37DD 30 16                jr      NC,PAINT4       ; no, jump over
5526+ 37DF 3C                   inc     A               ; Y=Y+1
5527+ 37E0 CD 17 38             call    CHECKPY         ; check pixel X1,Y+1
5528+ 37E3 20 10                jr      NZ,PAINT4       ; pixel is on, so jump over
5529+ 37E5 0C                   inc     C               ; Y=Y+1
5530+ 37E6 C5                   push    BC              ; insert pixel(X1,Y+1) into stack
5531+ 37E7 0D                   dec     C               ; retrieve original Y
5532+ 37E8 2A 84 55             ld      HL,(PNT)        ; PNT
5533+ 37EB 23                   inc     HL              ; PNT=PNT+1
5534+ 37EC 22 84 55             ld      (PNT),HL        ; store PNT
5535+ 37EF 3E 01                ld      A,$01           ; SB=1
5536+ 37F1 5F                   ld      E,A             ; set SB
5537+ 37F2 C3 07 38             jp      PAINT5          ; jump over
5538+ 37F5 7B           PAINT4: ld      A,E             ; load SB
5539+ 37F6 1F                   rra                     ; check if SB=1
5540+ 37F7 30 0E                jr      NC,PAINT5       ; no, jump over
5541+ 37F9 79                   ld      A,C             ; load Y
5542+ 37FA FE BF                cp      $BF             ; Y<191?
5543+ 37FC 30 09                jr      NC,PAINT5       ; no, jump over
5544+ 37FE 3C                   inc     A               ; Y=Y+1
5545+ 37FF CD 17 38             call    CHECKPY         ; check pixel X1,Y+1
5546+ 3802 CA 07 38             jp      Z,PAINT5        ; if pixel is off, jump over
5547+ 3805 AF                   xor     A               ; pixel is on, so...
5548+ 3806 5F                   ld      E,A             ; ...set SB=0
5549+ 3807 04           PAINT5: inc     B               ; X1=X1+1
5550+ 3808 CA 74 37             jp      Z,NXTLOOP       ; if X1>255 (X1=0) then goto next loop
5551+ 380B C3 93 37             jp      MNPAINT         ; otherwise, repeat for next X
5552+ 380E ED 7B 86 55  EXITPAI:ld      SP,(ORGSP)      ; retrieve original SP pointer
5553+ 3812 D1           EXITPA2:pop     DE              ; retrieve DE
5554+ 3813 C1                   pop     BC              ; retrieve BC
5555+ 3814 E1                   pop     HL              ; retrieve HL
5556+ 3815 C9                   ret                     ; return to caller
5557+ 3816 79           CHECKPA:ld      A,C             ; copy Y into A
5558+ 3817 32 7E 55     CHECKPY:ld      (TMPBFR2),A     ; store Y
5559+ 381A 78                   ld      A,B             ; copy X1 into A
5560+ 381B 32 7C 55             ld      (TMPBFR1),A     ; store X1
5561+ 381E C5                   push    BC              ; save X1,Y
5562+ 381F D5                   push    DE
5563+ 3820 CD 6E 38             call    PNTRTN          ; check if pixel is set/reset
5564+ 3823 D1                   pop     DE
5565+ 3824 C1                   pop     BC              ; retrieve X1,Y
5566+ 3825 C9                   ret                     ; return to caller
5567+ 3826
5568+ 3826
5569+ 3826              ; POINT(x,y): return if a pixel is set (returns color) or if it's reset (0)
5570+ 3826 CD 3D 36     POINT:  call    CHKG2M          ; check if in graphic mode 2
5571+ 3829 CD 15 1B             call    CHKSYN          ; make sure "(" follows
5572+ 382C 28                   defb    '('
5573+ 382D CD 75 2A             call    GETINT          ; get X coords.
5574+ 3830 32 7C 55             ld      (TMPBFR1),A     ; store it into a temp buffer
5575+ 3833 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
5576+ 3836 2C                   defb    ','
5577+ 3837 CD 75 2A             call    GETINT          ; get Y coords,
5578+ 383A FE C0                cp      $C0             ; check if Y is in range 0~191
5579+ 383C D2 29 1E             jp      NC,FCERR        ; no, raise an FC error
5580+ 383F 32 7E 55             ld      (TMPBFR2),A     ; store into a temp buffer
5581+ 3842 CD 15 1B             call    CHKSYN          ; make sure ")" follows
5582+ 3845 29                   defb    ')'
5583+ 3846 E5                   push    HL              ; store current string address - the point after the ")" - ...
5584+ 3847 FD E1                pop     IY              ; ...into IY
5585+ 3849 CD 6E 38             call    PNTRTN          ; check if pixel is set or reset
5586+ 384C 20 0C                jr      NZ,CTPOINT      ; it's ON, jump over
5587+ 384E AF                   xor     A               ; no, it's OFF. make sure to reset A...
5588+ 384F 47                   ld      B,A             ; ...and B
5589+ 3850 E1           PNTEND: pop     HL              ; drop original return point
5590+ 3851 FD E5                push    IY              ; load current string address from IY into stack
5591+ 3853 11 DA 22             ld      DE,RETNUM       ; Address of Return number from function...
5592+ 3856 D5                   push    DE              ; ...saved on stack
5593+ 3857 C3 D9 25             jp      ABPASS          ; return AB
5594+ 385A CB EC        CTPOINT:set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5595+ 385C F3                   di
5596+ 385D CD 90 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5597+ 3860 FB                   ei
5598+ 3861 CB 3F                srl     A               ; shift A...
5599+ 3863 CB 3F                srl     A               ; ...4 times...
5600+ 3865 CB 3F                srl     A               ; ...to move foreground color...
5601+ 3867 CB 3F                srl     A               ; ...into lowest nibble
5602+ 3869 47                   ld      B,A             ; color into B
5603+ 386A AF                   xor     A               ; reset MSB
5604+ 386B C3 50 38             jp      PNTEND          ; return AB
5605+ 386E CD E1 38     PNTRTN: call    XY2HL           ; find HL address of pixel at X,Y
5606+ 3871 57                   ld      D,A             ; store pixel index
5607+ 3872 F3                   di                      ; disable INTs
5608+ 3873 CD 90 06             call    READ_VIDEO_LOC  ; read contents of VRAM cell addressed by HL
5609+ 3876 FB                   ei                      ; re-enable INTs
5610+ 3877 A2                   and     D               ; is the pixel ON or OFF? (will be checked later)
5611+ 3878 C9                   ret                     ; return to caller
5612+ 3879
5613+ 3879
5614+ 3879              ; PLOT X,Y[,color]
5615+ 3879              ; plot a pixel in graphic mode 2
5616+ 3879 CD 3D 36     PLOT:   call    CHKG2M          ; check if in G2 mode
5617+ 387C CD 75 2A             call    GETINT          ; get X coords.
5618+ 387F 32 7C 55             ld      (TMPBFR1),A     ; store it into a temp buffer
5619+ 3882 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
5620+ 3885 2C                   defb    ','
5621+ 3886 CD 75 2A             call    GETINT          ; get Y coords,
5622+ 3889 FE C0                cp      $C0             ; check if Y is in range 0~191
5623+ 388B D2 29 1E             jp      NC,FCERR        ; no, raise an FC error
5624+ 388E 32 7E 55             ld      (TMPBFR2),A     ; store into a temp buffer
5625+ 3891 CD 31 3C             call    CLRPRM          ; check if param "color" has been passed
5626+ 3894 E5           CNTPLOT:push    HL              ; store HL
5627+ 3895 C5                   push    BC              ; store BC
5628+ 3896 D5                   push    DE              ; store DE
5629+ 3897 CD E1 38             call    XY2HL           ; find VRAM address of byte containing pixel at X,Y & return into HL
5630+ 389A D2 D5 38             jp      NC,NOGD         ; if carry is reset, there was an error -> so leave
5631+ 389D 57                   ld      D,A             ; move pixel value into D
5632+ 389E 3A 80 55             ld      A,(TMPBFR3)     ; retrieve color
5633+ 38A1 A7                   and     A               ; is it 0? (background, or reset pixel)
5634+ 38A2 20 11                jr      NZ,CNTPLT1      ; no, continue
5635+ 38A4 F3                   di                      ; yes - so, disable INTs
5636+ 38A5 CD 90 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5637+ 38A8 FB                   ei                      ; re-enable INTs
5638+ 38A9 5F                   ld      E,A             ; store value of cell
5639+ 38AA 7A                   ld      A,D             ; retrieve pixel
5640+ 38AB 2F                   cpl                     ; revert bits
5641+ 38AC A3                   and     E               ; set video pixel to off
5642+ 38AD F3                   di                      ; disable INTs
5643+ 38AE CD A5 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5644+ 38B1 FB                   ei                      ; re-enable INTs
5645+ 38B2 C3 D5 38             jp      NOGD            ; leave
5646+ 38B5 87           CNTPLT1:add     A,A             ; now we move low nibble
5647+ 38B6 87                   add     A,A             ; in the high nibble
5648+ 38B7 87                   add     A,A             ; by adding A to itself
5649+ 38B8 87                   add     A,A             ; 4 times (this is a shift left 4)
5650+ 38B9 5F                   ld      E,A             ; move it into E
5651+ 38BA F3                   di                      ; disable INTs
5652+ 38BB CD 90 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5653+ 38BE FB                   ei
5654+ 38BF B2                   or      D               ; merge new pixel preserving original pattern
5655+ 38C0 F3                   di
5656+ 38C1 CD A5 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5657+ 38C4 FB                   ei
5658+ 38C5 CB EC                set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5659+ 38C7 F3                   di
5660+ 38C8 CD 90 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5661+ 38CB FB                   ei
5662+ 38CC E6 0F                and     %00001111       ; reset high nibble (the foreground color)
5663+ 38CE B3                   or      E               ; set new foreground color
5664+ 38CF F3                   di
5665+ 38D0 CD A5 06             call    WRITE_VIDEO_LOC ; write new color settings
5666+ 38D3 FB                   ei                      ; re-enable INTs
5667+ 38D4 00                   nop                     ; wait for INTs to be enabled again
5668+ 38D5 D1           NOGD:   pop     DE              ; retrieve DE
5669+ 38D6 C1                   pop     BC              ; retrieve BC
5670+ 38D7 E1                   pop     HL              ; retrieve HL
5671+ 38D8 C9                   ret                     ; return to caller
5672+ 38D9 80 40 20 10  PXLSET: defb    $80,$40,$20,$10,$08,$04,$02,$01 ; pixel to be set ON
5672+ 38DD 08 04 02 01
5673+ 38E1                      ; where R(X/8)=> 0=80h, 1=40h, 2=20h, 3=10h, 4=08h, 5=04h, 6=02h, 7=$01
5674+ 38E1
5675+ 38E1
5676+ 38E1              ; compute the VRAM address of the byte containing the pixel
5677+ 38E1              ; being pointed by X,Y (TMPBFR1,TMPBFR2)
5678+ 38E1              ; byte address is returned into HL
5679+ 38E1              ; pixel is returned into A
5680+ 38E1              XY2HL:  ; formula is: ADDRESS=(INT(X/8))*8 + (INT(Y/8))*256 + R(Y/8)
5681+ 38E1                      ; where R(Y/8) is the remainder of (Y/8)
5682+ 38E1                      ; the pixel to be set is given by R(X/8), and data is taken from the array
5683+ 38E1 3A 7E 55             ld      A,(TMPBFR2)     ; retrieve Y
5684+ 38E4 FE C0                cp      $C0             ; Y>=192?
5685+ 38E6 D0                   ret     NC              ; yes, so leave
5686+ 38E7 1E 08                ld      E,$08           ; load E with divisor
5687+ 38E9 57                   ld      D,A             ; and store into D (dividend)
5688+ 38EA CD 83 41             call    DIV_8_8         ; get Y/8, D is quotient=INT(Y/8), and A is remainder
5689+ 38ED 4F                   ld      C,A             ; store remainder into C
5690+ 38EE 42                   ld      B,D             ; B=(INT(Y/8))*256 (we simply copy quotient into B)
5691+ 38EF 60 69                ld      HL,BC           ; copy BC into HL: now HL has the VRAM address of the byte being set
5692+ 38F1 3A 7C 55             ld      A,(TMPBFR1)     ; retrieve X
5693+ 38F4 57                   ld      D,A             ; and move it into D (dividend)
5694+ 38F5 CD 83 41             call    DIV_8_8         ; get X/8, D is quotient=INT(X/8), and A is remainder
5695+ 38F8 4F                   ld      C,A             ; store remainder into C
5696+ 38F9 7A                   ld      A,D             ; move quotient into A
5697+ 38FA 87                   add     A,A             ; multiply quotient by 8
5698+ 38FB 87                   add     A,A
5699+ 38FC 87                   add     A,A
5700+ 38FD 5F                   ld      E,A             ; store result into E
5701+ 38FE 16 00                ld      D,$00           ; reset D
5702+ 3900 42                   ld      B,D             ; reset B
5703+ 3901 19                   add     HL,DE           ; add DE to HL, getting the final VRAM address
5704+ 3902 EB                   ex      DE,HL           ; move VRAM address into DE
5705+ 3903 21 D9 38             ld      HL,PXLSET       ; starting address of table for pixel to draw
5706+ 3906 09                   add     HL,BC           ; add C (remainder of X/8) to get address of pixel to turn on
5707+ 3907 7E                   ld      A,(HL)          ; load pixel data
5708+ 3908 EB                   ex      DE,HL           ; retrieve VRAM pattern address into HL
5709+ 3909 37                   scf                     ; set Carry for normal exit
5710+ 390A C9                   ret                     ; return to caller
5711+ 390B
5712+ 390B
5713+ 390B              ; DRAW X1,Y1,X2,Y2[,color]
5714+ 390B              ; Draw a line using Bresenham's line algorithm from X1,Y1 to X2,Y2
5715+ 390B              ; X1,Y1 can be either less than or greater than X2,Y2 (meaning that)
5716+ 390B              ; the drawing will be ever done from X1,Y2 to X2,Y2, regardless of
5717+ 390B              ; the values. If color is not specified, the foreground color set
5718+ 390B              ; with COLOR will be used
5719+ 390B              X1      equ     TMPBFR1
5720+ 390B              Y1      equ     TMPBFR2
5721+ 390B              X2      equ     VIDEOBUFF
5722+ 390B              Y2      equ     VIDEOBUFF+$02
5723+ 390B              ER      equ     VIDEOBUFF+$04
5724+ 390B              E2      equ     VIDEOBUFF+$06
5725+ 390B              SX      equ     VIDEOBUFF+$08
5726+ 390B              SY      equ     VIDEOBUFF+$0A
5727+ 390B              DX      equ     VIDEOBUFF+$0C
5728+ 390B              DY      equ     VIDEOBUFF+$0E
5729+ 390B CD 3D 36     DRAW:   call    CHKG2M          ; check if in G2 mode
5730+ 390E CD 13 3C             call    CLRTMBF         ; clear TMPBFRx
5731+ 3911 CD 22 3C             call    CLRVDBF         ; clear VIDEOBUFF
5732+ 3914 CD 75 2A             call    GETINT          ; get X1 coords.
5733+ 3917 32 7C 55             ld      (X1),A          ; store it into a temp buffer
5734+ 391A CD 15 1B             call    CHKSYN          ; Make sure ',' follows
5735+ 391D 2C                   defb    ','
5736+ 391E CD 75 2A             call    GETINT          ; get Y1 coords.
5737+ 3921 FE C0                cp      $C0             ; check if Y1 is in range 0~191
5738+ 3923 D2 29 1E             jp      NC,FCERR        ; no, raise an FC error
5739+ 3926 32 7E 55             ld      (Y1),A          ; store into a temp buffer
5740+ 3929 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
5741+ 392C 2C                   defb    ','
5742+ 392D CD 75 2A             call    GETINT          ; get X2 coords.
5743+ 3930 32 84 55             ld      (X2),A          ; store it into a temp buffer
5744+ 3933 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
5745+ 3936 2C                   defb    ','
5746+ 3937 CD 75 2A             call    GETINT          ; get Y2 coords
5747+ 393A FE C0                cp      $C0             ; check if Y2 is in range 0~191
5748+ 393C D2 29 1E             jp      NC,FCERR        ; no, raise an FC error
5749+ 393F 32 86 55             ld      (Y2),A          ; store it into a temp buffer
5750+ 3942 CD 31 3C             call    CLRPRM          ; check for arg. "color" and store it into TMPBFR3
5751+ 3945 E5                   push    HL              ; store register we'll use
5752+ 3946 D5                   push    DE
5753+ 3947 C5                   push    BC
5754+ 3948 ED 5B 7C 55          ld      DE,(X1)         ; load X1 and
5755+ 394C 2A 84 55             ld      HL,(X2)         ; X2
5756+ 394F B7                   or      A               ; clear CARRY
5757+ 3950 ED 52                sbc     HL,DE           ; DX=X2-X1
5758+ 3952 CD 79 41             call    absHL           ; DX=ABS(DX)
5759+ 3955 22 90 55             ld      (DX),HL         ; store DX
5760+ 3958 01 FF FF             ld      BC,$FFFF        ; SX=-1
5761+ 395B 2A 7C 55             ld      HL,(X1)
5762+ 395E ED 5B 84 55          ld      DE,(X2)
5763+ 3962 CD 38 41             call    CMP16           ; X1<X2?
5764+ 3965 CA 6E 39             jp      Z,X1GR          ; no, X1=X2
5765+ 3968 F2 6E 39             jp      P,X1GR          ; no, X1>X2
5766+ 396B 01 01 00             ld      BC,$0001        ; yes, so set SX=1
5767+ 396E ED 43 8C 55  X1GR:   ld      (SX),BC         ; store SX
5768+ 3972 ED 5B 7E 55          ld      DE,(Y1)
5769+ 3976 2A 86 55             ld      HL,(Y2)
5770+ 3979 B7                   or      A               ; clear Carry
5771+ 397A ED 52                sbc     HL,DE           ; DY=Y2-Y1
5772+ 397C CD 79 41             call    absHL           ; DY=ABS(DY)
5773+ 397F 22 92 55             ld      (DY),HL         ; store DY
5774+ 3982 01 FF FF             ld      BC,$FFFF        ; SY=-1
5775+ 3985 2A 7E 55             ld      HL,(Y1)
5776+ 3988 ED 5B 86 55          ld      DE,(Y2)
5777+ 398C CD 38 41             call    CMP16           ; is Y1<Y2?
5778+ 398F CA 98 39             jp      Z,Y1GR          ; no, Y1=Y2
5779+ 3992 F2 98 39             jp      P,Y1GR          ; no, Y1>Y2 - jump over
5780+ 3995 01 01 00             ld      BC,$0001        ; yes, so set SY=1
5781+ 3998 ED 43 8E 55  Y1GR:   ld      (SY),BC         ; store SY
5782+ 399C 2A 92 55             ld      HL,(DY)         ; ER=DY
5783+ 399F CD 7C 41             call    negHL           ; ER=-DY
5784+ 39A2 22 88 55             ld      (ER),HL         ; store ER
5785+ 39A5 2A 90 55             ld      HL,(DX)
5786+ 39A8 ED 5B 92 55          ld      DE,(DY)
5787+ 39AC CD 38 41             call    CMP16           ; DX>DY?
5788+ 39AF CA BB 39             jp      Z,ER2           ; no, DX=DY
5789+ 39B2 FA BB 39             jp      M,ER2           ; no, DX<DY
5790+ 39B5 2A 90 55             ld      HL,(DX)         ; reload DX
5791+ 39B8 22 88 55             ld      (ER),HL         ; yes: DX>DY, so ER=DX
5792+ 39BB 2A 88 55     ER2:    ld      HL,(ER)         ; load ER
5793+ 39BE CB 2C                sra     H               ; right shift (and preserve sign)...
5794+ 39C0 CB 1D                rr      L               ; ...of HL, so ER=INT(ER/2)
5795+ 39C2 CB 7C                bit     7,H             ; is the number negative?
5796+ 39C4 CA C8 39             jp      Z,STRE2         ; no, jump over
5797+ 39C7 23                   inc     HL              ; yes, add 1 'cos INT of a negative number needs to be incremented
5798+ 39C8 22 88 55     STRE2:  ld      (ER),HL         ; store ER
5799+ 39CB CD 94 38     RPTDRW: call    CNTPLOT         ; plot first pixel
5800+ 39CE 2A 7C 55             ld      HL,(X1)
5801+ 39D1 ED 5B 84 55          ld      DE,(X2)
5802+ 39D5 CD 38 41             call    CMP16           ; X1=X2?
5803+ 39D8 20 0D                jr      NZ,CNTDRW       ; no, continue drawing
5804+ 39DA 2A 7E 55             ld      HL,(Y1)         ; yes, so check
5805+ 39DD ED 5B 86 55          ld      DE,(Y2)         ; also Y
5806+ 39E1 CD 38 41             call    CMP16           ; Y1=Y2?
5807+ 39E4 CA 40 3A             jp      Z,ENDDRAW       ; yes, finished drawing: exit
5808+ 39E7 ED 5B 88 55  CNTDRW: ld      DE,(ER)
5809+ 39EB ED 53 8A 55          ld      (E2),DE         ; E2=ER
5810+ 39EF 2A 90 55             ld      HL,(DX)
5811+ 39F2 CD 7C 41             call    negHL           ; DX=-DX
5812+ 39F5 EB                   ex      DE,HL           ; invert DE and HL => HL=E2, DE=-DX
5813+ 39F6 CD 38 41             call    CMP16           ; E2>-DX?
5814+ 39F9 CA 17 3A             jp      Z,DXGR          ; no, E2=-DX: jump
5815+ 39FC FA 17 3A             jp      M,DXGR          ; no, E2<-DX: jump
5816+ 39FF 2A 88 55             ld      HL,(ER)         ; yes
5817+ 3A02 ED 5B 92 55          ld      DE,(DY)
5818+ 3A06 B7                   or      A               ; clear CARRY
5819+ 3A07 ED 52                sbc     HL,DE           ; ER=ER-DY
5820+ 3A09 22 88 55             ld      (ER),HL
5821+ 3A0C 2A 7C 55             ld      HL,(X1)
5822+ 3A0F ED 5B 8C 55          ld      DE,(SX)
5823+ 3A13 19                   add     HL,DE           ; X1=X1+SX (increment X1)
5824+ 3A14 22 7C 55             ld      (X1),HL
5825+ 3A17 2A 8A 55     DXGR:   ld      HL,(E2)
5826+ 3A1A ED 5B 92 55          ld      DE,(DY)
5827+ 3A1E CD 38 41             call    CMP16           ; E2<DY?
5828+ 3A21 CA CB 39             jp      Z,RPTDRW        ; no, E2=DY: jump
5829+ 3A24 F2 CB 39             jp      P,RPTDRW        ; no, E2>DY: jump
5830+ 3A27 2A 88 55             ld      HL,(ER)         ; yes
5831+ 3A2A ED 5B 90 55          ld      DE,(DX)
5832+ 3A2E 19                   add     HL,DE           ; ER=ER+DX
5833+ 3A2F 22 88 55             ld      (ER),HL
5834+ 3A32 2A 7E 55             ld      HL,(Y1)
5835+ 3A35 ED 5B 8E 55          ld      DE,(SY)
5836+ 3A39 19                   add     HL,DE           ; Y1=Y1+SY (increment Y1)
5837+ 3A3A 22 7E 55             ld      (Y1),HL
5838+ 3A3D C3 CB 39             jp      RPTDRW          ; repeat
5839+ 3A40 C1           ENDDRAW:pop     BC              ; retrieve BC
5840+ 3A41 D1                   pop     DE              ; retrieve DE
5841+ 3A42 E1                   pop     HL              ; retrieve HL
5842+ 3A43 C9                   ret                     ; return to caller
5843+ 3A44
5844+ 3A44
5845+ 3A44              ; CIRCLE X,Y,R[,C]
5846+ 3A44              ; Draw a circle using Bresenham's circle algorithm with center in X,Y
5847+ 3A44              ; and radius R, with optional color C. If color is not specified, the
5848+ 3A44              ; foreground color set with COLOR will be used
5849+ 3A44              XC      equ     VIDEOBUFF
5850+ 3A44              YC      equ     VIDEOBUFF+$02
5851+ 3A44              RADIUS  equ     VIDEOBUFF+$04
5852+ 3A44              XI      equ     VIDEOBUFF+$06
5853+ 3A44              YI      equ     VIDEOBUFF+$08
5854+ 3A44              DC      equ     VIDEOBUFF+$0A
5855+ 3A44 CD 3D 36     CIRCLE: call    CHKG2M          ; check if in G2 mode
5856+ 3A47 CD 22 3C             call    CLRVDBF         ; clear VIDEOBUFF
5857+ 3A4A CD 75 2A             call    GETINT          ; get X coords.
5858+ 3A4D 32 84 55             ld      (XC),A          ; store it into a temp buffer
5859+ 3A50 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
5860+ 3A53 2C                   defb    ','
5861+ 3A54 CD 75 2A             call    GETINT          ; get Y coords,
5862+ 3A57 32 86 55             ld      (YC),A          ; store it into a temp buffer
5863+ 3A5A CD 15 1B             call    CHKSYN          ; Make sure ',' follows
5864+ 3A5D 2C                   defb    ','
5865+ 3A5E CD 75 2A             call    GETINT          ; get radius
5866+ 3A61 32 88 55             ld      (RADIUS),A      ; store it into a temp buffer
5867+ 3A64 CD 31 3C             call    CLRPRM          ; check if param "color" has been passed
5868+ 3A67 C5                   push    BC              ; store BC
5869+ 3A68 D5                   push    DE              ; store DE
5870+ 3A69 E5                   push    HL              ; store HL
5871+ 3A6A AF                   xor     A               ; clear A,
5872+ 3A6B 47                   ld      B,A             ; B,
5873+ 3A6C 4F                   ld      C,A             ; C,
5874+ 3A6D 57                   ld      D,A             ; D,
5875+ 3A6E 67                   ld      H,A             ; and H
5876+ 3A6F ED 43 8A 55          ld      (XI),BC         ; clear XI
5877+ 3A73 3A 88 55             ld      A,(RADIUS)      ; load RADIUS into A
5878+ 3A76 6F                   ld      L,A             ; HL now contains R
5879+ 3A77 22 8C 55             ld      (YI),HL         ; YI=RADIUS
5880+ 3A7A 29                   add     HL,HL           ; R*2
5881+ 3A7B EB                   ex      DE,HL           ; put HL into DE
5882+ 3A7C 21 03 00             ld      HL,$0003        ; HL = 3
5883+ 3A7F AF                   xor     A               ; clear Carry
5884+ 3A80 ED 52                sbc     HL,DE           ; D=3-(2*R) => HL
5885+ 3A82 22 8E 55             ld      (DC),HL         ; store D
5886+ 3A85 CD E4 3A             call    DRWCRL          ; draw initial point
5887+ 3A88 ED 5B 8A 55  RPTCRL: ld      DE,(XI)         ; load XI
5888+ 3A8C 2A 8C 55             ld      HL,(YI)         ; load YI
5889+ 3A8F CD 38 41             call    CMP16           ; is YI<DI?
5890+ 3A92 CA 9B 3A             jp      Z,RPTCL1        ; no, YI=XI
5891+ 3A95 F2 9B 3A             jp      P,RPTCL1        ; no, YI>XI
5892+ 3A98 C3 E0 3A             jp      ENDCRL          ; yes, so we've finished
5893+ 3A9B 21 8A 55     RPTCL1: ld      HL,XI
5894+ 3A9E 34                   inc     (HL)            ; XI=XI+1
5895+ 3A9F 2A 8E 55             ld      HL,(DC)         ; load D
5896+ 3AA2 7C                   ld      A,H
5897+ 3AA3 B5                   or      L               ; is D=0? Yes, jump over
5898+ 3AA4 CA C8 3A             jp      Z,DLSZ
5899+ 3AA7 CB 7C                bit     7,H             ; is D<0?
5900+ 3AA9 20 1D                jr      NZ,DLSZ         ; yes, jump over
5901+ 3AAB ED 5B 8C 55          ld      DE,(YI)         ; D>0
5902+ 3AAF 1B                   dec     DE              ; so, YI=YI-1
5903+ 3AB0 ED 53 8C 55          ld      (YI),DE         ; store YI
5904+ 3AB4 AF                   xor     A               ; clear Carry
5905+ 3AB5 2A 8A 55             ld      HL,(XI)
5906+ 3AB8 ED 52                sbc     HL,DE           ; HL=XI-YI
5907+ 3ABA 29                   add     HL,HL
5908+ 3ABB 29                   add     HL,HL           ; HL=HL*4
5909+ 3ABC 11 0A 00             ld      DE,10
5910+ 3ABF 19                   add     HL,DE           ; HL=HL+10
5911+ 3AC0 ED 5B 8E 55          ld      DE,(DC)         ; load D
5912+ 3AC4 EB                   ex      DE,HL           ; invert DE and HL, so that HL=4*(XI-YI)+10 and DE=D
5913+ 3AC5 19                   add     HL,DE           ; D=D+4*(XI-YI)+10
5914+ 3AC6 18 0F                jr      PLTCRL          ; plot next pixel
5915+ 3AC8 2A 8A 55     DLSZ:   ld      HL,(XI)         ; load XI
5916+ 3ACB 29                   add     HL,HL
5917+ 3ACC 29                   add     HL,HL           ; XI=XI*4
5918+ 3ACD 11 06 00             ld      DE,$0006
5919+ 3AD0 19                   add     HL,DE
5920+ 3AD1 ED 5B 8E 55          ld      DE,(DC)
5921+ 3AD5 EB                   ex      DE,HL           ; HL=D and DE=4*XI+6
5922+ 3AD6 19                   add     HL,DE           ; D=D+4*XI+6
5923+ 3AD7 22 8E 55     PLTCRL: ld      (DC),HL         ; store new D
5924+ 3ADA CD E4 3A             call    DRWCRL          ; plot pixel
5925+ 3ADD C3 88 3A             jp      RPTCRL          ; repeat
5926+ 3AE0 E1           ENDCRL: pop     HL
5927+ 3AE1 D1                   pop     DE
5928+ 3AE2 C1                   pop     BC
5929+ 3AE3 C9                   ret                     ; return to caller
5930+ 3AE4 2A 84 55     DRWCRL: ld      HL,(XC)
5931+ 3AE7 ED 5B 8A 55          ld      DE,(XI)
5932+ 3AEB 19                   add     HL,DE           ; X=XC+XI
5933+ 3AEC 22 7C 55             ld      (X1),HL         ; store X
5934+ 3AEF CD 03 3C             call    VALIDX          ; check if X is valid (0~255)
5935+ 3AF2 DA 06 3B             jp      C,CNTCL1        ; if Carry is set, X is not valid
5936+ 3AF5 2A 86 55             ld      HL,(YC)
5937+ 3AF8 ED 5B 8C 55          ld      DE,(YI)
5938+ 3AFC 19                   add     HL,DE           ; Y=YC+YI
5939+ 3AFD 22 7E 55             ld      (Y1),HL         ; store Y
5940+ 3B00 CD 08 3C             call    VALIDY          ; check if Y is valid (0~191)
5941+ 3B03 D4 94 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5942+ 3B06 AF           CNTCL1: xor     A               ; clear Carry
5943+ 3B07 2A 84 55             ld      HL,(XC)
5944+ 3B0A ED 5B 8A 55          ld      DE,(XI)
5945+ 3B0E ED 52                sbc     HL,DE           ; X=XC-XI
5946+ 3B10 22 7C 55             ld      (X1),HL         ; store X
5947+ 3B13 CD 03 3C             call    VALIDX          ; check if X is valid (0~255)
5948+ 3B16 DA 2A 3B             jp      C,CNTCL2        ; if Carry is set, X is not valid
5949+ 3B19 2A 86 55             ld      HL,(YC)
5950+ 3B1C ED 5B 8C 55          ld      DE,(YI)
5951+ 3B20 19                   add     HL,DE           ; Y=YC+YI
5952+ 3B21 22 7E 55             ld      (Y1),HL         ; store Y
5953+ 3B24 CD 08 3C             call    VALIDY          ; check if Y is valid (0~191)
5954+ 3B27 D4 94 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5955+ 3B2A 2A 84 55     CNTCL2: ld      HL,(XC)
5956+ 3B2D ED 5B 8A 55          ld      DE,(XI)
5957+ 3B31 19                   add     HL,DE           ; X=XC+XI
5958+ 3B32 22 7C 55             ld      (X1),HL         ; store X
5959+ 3B35 CD 03 3C             call    VALIDX          ; check if X is valid (0~255)
5960+ 3B38 DA 4E 3B             jp      C,CNTCL3        ; if Carry is set, X is not valid
5961+ 3B3B AF                   xor     A               ; clear Carry
5962+ 3B3C 2A 86 55             ld      HL,(YC)
5963+ 3B3F ED 5B 8C 55          ld      DE,(YI)
5964+ 3B43 ED 52                sbc     HL,DE           ; Y=YC-YI
5965+ 3B45 22 7E 55             ld      (Y1),HL         ; store Y
5966+ 3B48 CD 08 3C             call    VALIDY          ; check if Y is valid (0~191)
5967+ 3B4B D4 94 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5968+ 3B4E AF           CNTCL3: xor     A               ; clear Carry
5969+ 3B4F 2A 84 55             ld      HL,(XC)
5970+ 3B52 ED 5B 8A 55          ld      DE,(XI)
5971+ 3B56 ED 52                sbc     HL,DE           ; X=XC-XI
5972+ 3B58 22 7C 55             ld      (X1),HL         ; store X
5973+ 3B5B CD 03 3C             call    VALIDX          ; check if X is valid (0~255)
5974+ 3B5E DA 74 3B             jp      C,CNTCL4        ; if Carry is set, X is not valid
5975+ 3B61 AF                   xor     A               ; clear Carry
5976+ 3B62 2A 86 55             ld      HL,(YC)
5977+ 3B65 ED 5B 8C 55          ld      DE,(YI)
5978+ 3B69 ED 52                sbc     HL,DE           ; Y=YC-YI
5979+ 3B6B 22 7E 55             ld      (Y1),HL         ; store Y
5980+ 3B6E CD 08 3C             call    VALIDY          ; check if Y is valid (0~191)
5981+ 3B71 D4 94 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5982+ 3B74 2A 84 55     CNTCL4: ld      HL,(XC)
5983+ 3B77 ED 5B 8C 55          ld      DE,(YI)
5984+ 3B7B 19                   add     HL,DE           ; X=XC+YI
5985+ 3B7C 22 7C 55             ld      (X1),HL         ; store X
5986+ 3B7F CD 03 3C             call    VALIDX          ; check if X is valid (0~255)
5987+ 3B82 DA 96 3B             jp      C,CNTCL5        ; if Carry is set, X is not valid
5988+ 3B85 2A 86 55             ld      HL,(YC)
5989+ 3B88 ED 5B 8A 55          ld      DE,(XI)
5990+ 3B8C 19                   add     HL,DE           ; Y=YC+XI
5991+ 3B8D 22 7E 55             ld      (Y1),HL         ; store Y
5992+ 3B90 CD 08 3C             call    VALIDY          ; check if Y is valid (0~191)
5993+ 3B93 D4 94 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5994+ 3B96 AF           CNTCL5: xor     A               ; clear Carry
5995+ 3B97 2A 84 55             ld      HL,(XC)
5996+ 3B9A ED 5B 8C 55          ld      DE,(YI)
5997+ 3B9E ED 52                sbc     HL,DE           ; X=XC-YI
5998+ 3BA0 22 7C 55             ld      (X1),HL         ; store X
5999+ 3BA3 CD 03 3C             call    VALIDX          ; check if X is valid (0~255)
6000+ 3BA6 DA BA 3B             jp      C,CNTCL6        ; if Carry is set, X is not valid
6001+ 3BA9 2A 86 55             ld      HL,(YC)
6002+ 3BAC ED 5B 8A 55          ld      DE,(XI)
6003+ 3BB0 19                   add     HL,DE           ; Y=YC+XI
6004+ 3BB1 22 7E 55             ld      (Y1),HL         ; store Y
6005+ 3BB4 CD 08 3C             call    VALIDY          ; check if Y is valid (0~191)
6006+ 3BB7 D4 94 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
6007+ 3BBA 2A 84 55     CNTCL6: ld      HL,(XC)
6008+ 3BBD ED 5B 8C 55          ld      DE,(YI)
6009+ 3BC1 19                   add     HL,DE           ; X=XC+YI
6010+ 3BC2 22 7C 55             ld      (X1),HL         ; store X
6011+ 3BC5 CD 03 3C             call    VALIDX          ; check if X is valid (0~255)
6012+ 3BC8 DA DE 3B             jp      C,CNTCL7        ; if Carry is set, X is not valid
6013+ 3BCB AF                   xor     A               ; clear Carry
6014+ 3BCC 2A 86 55             ld      HL,(YC)
6015+ 3BCF ED 5B 8A 55          ld      DE,(XI)
6016+ 3BD3 ED 52                sbc     HL,DE           ; Y=YC-XI
6017+ 3BD5 22 7E 55             ld      (Y1),HL         ; store Y
6018+ 3BD8 CD 08 3C             call    VALIDY          ; check if Y is valid (0~191)
6019+ 3BDB D4 94 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
6020+ 3BDE AF           CNTCL7: xor     A               ; clear Carry
6021+ 3BDF 2A 84 55             ld      HL,(XC)
6022+ 3BE2 ED 5B 8C 55          ld      DE,(YI)
6023+ 3BE6 ED 52                sbc     HL,DE           ; X=XC-YI
6024+ 3BE8 22 7C 55             ld      (X1),HL         ; store X
6025+ 3BEB CD 03 3C             call    VALIDX          ; check if X is valid (0~255)
6026+ 3BEE D8                   ret     C               ; if Carry is set, X is not valid
6027+ 3BEF AF                   xor     A               ; clear Carry
6028+ 3BF0 2A 86 55             ld      HL,(YC)
6029+ 3BF3 ED 5B 8A 55          ld      DE,(XI)
6030+ 3BF7 ED 52                sbc     HL,DE           ; Y=YC-XI
6031+ 3BF9 22 7E 55             ld      (Y1),HL         ; store Y
6032+ 3BFC CD 08 3C             call    VALIDY          ; check if Y is valid (0~191)
6033+ 3BFF D4 94 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
6034+ 3C02 C9                   ret                     ; return to caller
6035+ 3C03
6036+ 3C03              ; check if X,Y coordinates are valid: 0<=X<=255 and 0<=Y<=191
6037+ 3C03              ; input: HL (value to check), can be negative
6038+ 3C03              ; output: CARRY flag: reset => VALID  //  set => NOT VALID
6039+ 3C03              ; destroys: A
6040+ 3C03 AF           VALIDX: xor     A               ; reset A
6041+ 3C04 B4                   or      H               ; check if H is 0 (this means that X is in range 0~255 and not negative)
6042+ 3C05 C8                   ret     Z               ; yes, we can return (C is clear)
6043+ 3C06 37                   scf                     ; set Carry flag to raise error
6044+ 3C07 C9                   ret                     ; return to caller
6045+ 3C08
6046+ 3C08 AF           VALIDY: xor     A               ; reset A
6047+ 3C09 B4                   or      H               ; check if H is 0 (this means that Y is in range 0~255 and not negative)
6048+ 3C0A 28 02                jr      Z,CNTVALY       ; yes, continue checking
6049+ 3C0C 37                   scf                     ; no, raise error by setting Carry flag
6050+ 3C0D C9                   ret                     ; return to caller
6051+ 3C0E 7D           CNTVALY:ld      A,L
6052+ 3C0F FE C0                cp      $C0             ; is Y<192? Carry is set if Y<192
6053+ 3C11 3F                   ccf                     ; invert Carry, so Carry=0 means OK, Carry=1 means ERROR
6054+ 3C12 C9                   ret                     ; return to caller
6055+ 3C13
6056+ 3C13
6057+ 3C13
6058+ 3C13              ; cleat TMPBFR1-4 buffers before using them
6059+ 3C13 AF           CLRTMBF:xor     A               ; reset A
6060+ 3C14 E5                   push    HL              ; store HL
6061+ 3C15 C5                   push    BC              ; store BC
6062+ 3C16 21 7C 55             ld      HL,TMPBFR1      ; address of 1st location
6063+ 3C19 06 08                ld      B,$08           ; 8 locations
6064+ 3C1B 77           RPCLTMB:ld      (HL),A          ; clear byte
6065+ 3C1C 23                   inc     HL              ; next location
6066+ 3C1D 10 FC                djnz    RPCLTMB         ; repeat
6067+ 3C1F C1                   pop     BC              ; retrieve BC
6068+ 3C20 E1                   pop     HL              ; retrieve HL
6069+ 3C21 C9                   ret                     ; return to caller
6070+ 3C22
6071+ 3C22
6072+ 3C22              ; clear VIDEOBUFF before using it as temp buffer
6073+ 3C22 AF           CLRVDBF:xor     A               ; clear A
6074+ 3C23 C5                   push    BC              ; store BC
6075+ 3C24 E5                   push    HL              ; store HL
6076+ 3C25 06 28                ld      B,$28           ; 40 cells
6077+ 3C27 21 84 55             ld      HL,VIDEOBUFF    ; address of 1st cell
6078+ 3C2A 77           RPTCVBF:ld      (HL),A          ; clear cell
6079+ 3C2B 23                   inc     HL              ; next cell
6080+ 3C2C 10 FC                djnz    RPTCVBF         ; repeat
6081+ 3C2E E1                   pop     HL              ; retrieve HL
6082+ 3C2F C1                   pop     BC              ; retrieve BC
6083+ 3C30 C9                   ret                     ; return to caller
6084+ 3C31
6085+ 3C31
6086+ 3C31              ; check if a color is passed as argument with PLOT, DRAW, and CIRCLE
6087+ 3C31              ; commands. If not present, the default foreground color will be used
6088+ 3C31 3A 7A 55     CLRPRM: ld      A,(FRGNDCLR)    ; load foreground color
6089+ 3C34 32 80 55             ld      (TMPBFR3),A     ; store into temp buffer
6090+ 3C37 2B                   dec     HL              ; dec 'cos GETCHR INCs
6091+ 3C38 CD 5E 1D             call    GETCHR          ; Get next character
6092+ 3C3B C8                   ret     Z               ; return foreground color if nothing follows
6093+ 3C3C CD 15 1B             call    CHKSYN          ; Make sure ',' follows
6094+ 3C3F 2C                   defb    ','
6095+ 3C40 CD 75 2A             call    GETINT          ; get value
6096+ 3C43 CD 37 36             call    CHKCLR0         ; check if color is in range 0~15
6097+ 3C46 32 80 55             ld      (TMPBFR3),A     ; store color into temp buffer
6098+ 3C49 C9                   ret                     ; return to caller
6099+ 3C4A
6100+ 3C4A
6101+ 3C4A              ; no graphics mode error: raised when a graphics command is invoked
6102+ 3C4A              ; out of graphic 2 mode.
6103+ 3C4A 1E 2A        GMERR:  ld      E,GM            ; load Graphics Mode Error flag
6104+ 3C4C C3 31 18             jp      ERROR           ; print error
6105+ 3C4F
6106+ 3C4F
6107+ 3C4F              ; set a serial port: params are PORT,BPS,DATA,PARITY,STOP
6108+ 3C4F              ; PORT=1/2; BPS=1,200~57,600 (see below), DATA=5/6/7/8
6109+ 3C4F              ; PARITY: 0=no parity; 1=ODD parity; 2=EVEN parity;
6110+ 3C4F              ; STOP=0/1/2/3: 0=0 bit; 1=1 bit; 2=1.5 bits; 3=2 bits
6111+ 3C4F              ; PORT 1 acts as a char device; PORT 2 acts as a block device
6112+ 3C4F              ; DATA,PARITY, and STOP are optional: if nothing follows BPS,
6113+ 3C4F              ; they are assumed to be 8,0,1 resp.
6114+ 3C4F              PRTNUM  equ     VIDEOBUFF
6115+ 3C4F              BPS     equ     PRTNUM+$01
6116+ 3C4F              DATABT  equ     BPS+$02
6117+ 3C4F              PARBT   equ     DATABT+$01
6118+ 3C4F              STPBT   equ     PARBT+$01
6119+ 3C4F              SIOBFR  equ     STPBT+$01
6120+ 3C4F CD 75 2A     SERIAL: call    GETINT          ; get port #
6121+ 3C52 A7                   and     A               ; is it zero?
6122+ 3C53 CA 29 1E             jp      Z,FCERR         ; yes, error
6123+ 3C56 FE 03                cp      $03             ; is it 1 or 2?
6124+ 3C58 D2 78 3E             jp      NC,SCERR        ; no, error
6125+ 3C5B 32 84 55             ld      (PRTNUM),A      ; store port number into a temp buffer
6126+ 3C5E CD 15 1B             call    CHKSYN          ; Make sure ',' follows
6127+ 3C61 2C                   defb    ','
6128+ 3C62 2B                   dec     HL
6129+ 3C63 CD 5E 1D             call    GETCHR          ; check what's following
6130+ 3C66 CA 17 18             jp      Z,SNERR         ; error if nothing follows
6131+ 3C69 30 05                jr      NC,SERVAR       ; it's not a number, try a variable
6132+ 3C6B CD 2E 1E             call    ATOH            ; get bps (returned into DE)
6133+ 3C6E 18 0F                jr      CHKZSER         ; jump over
6134+ 3C70 CD EF 21     SERVAR: call    GETNUM          ; get number
6135+ 3C73 CD FC 2F             call    TSTSGN          ; check value
6136+ 3C76 FA 29 1E             jp      M,FCERR         ; negative - illegal function call
6137+ 3C79 3A D3 55             ld      A,(FPEXP)       ; Get integer value to DE
6138+ 3C7C CD A4 30             call    FPINT           ; get integer number into BCDE - drop BC 'cause isn't necessary
6139+ 3C7F 7A           CHKZSER:ld      A,D             ; bps is into DE - move MSB into A
6140+ 3C80 B3                   or      E               ; check if bps=0
6141+ 3C81 20 3A                jr      NZ,CNTSER       ; no, continue checking
6142+ 3C83                      ; if baud rate is 0, then close the serial comm.
6143+ 3C83 3A 84 55     RSTSERS:ld      A,(PRTNUM)      ; yes, so reset the channel. First, load port number
6144+ 3C86 3D                   dec     A               ; subtract 1, so that serial channel is 0=>A and 1=>B
6145+ 3C87 C6 22                add     SIO_CA          ; find correct channel
6146+ 3C89 4F                   ld      C,A             ; store serial channel
6147+ 3C8A F3                   di                      ; disable INTs
6148+ 3C8B AF                   xor     A               ; reset A
6149+ 3C8C 16 01                ld      D,$01           ; start from WR1
6150+ 3C8E 06 05                ld      B,$05           ; 5 registers
6151+ 3C90 ED 51        RPTRSSR:out     (C),D           ; select register
6152+ 3C92 ED 79                out     (C),A           ; reset register
6153+ 3C94 14                   inc     D               ; next register
6154+ 3C95 10 F9                djnz    RPTRSSR         ; repeat
6155+ 3C97 3E 30                ld      A,%00110000     ; write into WR0: error reset, select WR0
6156+ 3C99 ED 79                out     (C),A           ; send command to serial channel
6157+ 3C9B 3E 18                ld      A,%00011000     ; write into WR0: channel reset
6158+ 3C9D ED 79                out     (C),A           ; send command to serial channel
6159+ 3C9F FB                   ei                      ; re-enable INTs
6160+ 3CA0 E5                   push    HL              ; store HL
6161+ 3CA1 21 BE 55             ld      HL,SERIALS_EN   ; serials enabled status byte
6162+ 3CA4 DB 01                in      A,(PIO_DB)      ; read status LEDs
6163+ 3CA6 CB 41                bit     0,C             ; check serial port
6164+ 3CA8 20 09                jr      NZ,SRPT2        ; if bit is set, jump to port 2
6165+ 3CAA CB B7                res     6,A             ; it's port 1
6166+ 3CAC CB A7                res     4,A             ; remove possible error LED
6167+ 3CAE CB 86                res     0,(HL)          ; disable port 1
6168+ 3CB0 C3 B9 3C             jp      SERLED          ; jump over
6169+ 3CB3 CB BF        SRPT2:  res     7,A             ; it's port 2
6170+ 3CB5 CB AF                res     5,A             ; remove possible error LED
6171+ 3CB7 CB 8E                res     1,(HL)          ; disable port 2
6172+ 3CB9 D3 01        SERLED: out     (PIO_DB),A      ; send new configuration
6173+ 3CBB E1                   pop     HL              ; retrieve HL
6174+ 3CBC C9                   ret                     ; return to caller
6175+ 3CBD                      ; check if bps=1, meaning reactivate RX on serial
6176+ 3CBD 7A           CNTSER: ld      A,D
6177+ 3CBE B2                   or      D               ; check if bps<>1 by first checking D=0
6178+ 3CBF 20 36                jr      NZ,CNTSER2      ; if not, jump over
6179+ 3CC1 7B                   ld      A,E             ; then by checking that
6180+ 3CC2 FE 01                cp      $01             ; E=1
6181+ 3CC4 20 31                jr      NZ,CNTSER2      ; if not, jump over
6182+ 3CC6 3A 84 55             ld      A,(PRTNUM)      ; load port number
6183+ 3CC9 57                   ld      D,A             ; store port on D
6184+ 3CCA 3A BE 55             ld      A,(SERIALS_EN)  ; load address of serial status cell
6185+ 3CCD A2                   and     D               ; check status
6186+ 3CCE CA 78 3E             jp      Z,SCERR         ; port not open, raise error
6187+ 3CD1 F3                   di                      ; disable INTs
6188+ 3CD2 7A                   ld      A,D             ; move port # into A
6189+ 3CD3 5F                   ld      E,A             ; and also into E
6190+ 3CD4 87                   add     A
6191+ 3CD5 87                   add     A               ; move A to left times 2
6192+ 3CD6 57                   ld      D,A             ; move value into D
6193+ 3CD7 3A BE 55             ld      A,(SERIALS_EN)  ; load serial status byte
6194+ 3CDA B2                   or      D               ; re-enable RX
6195+ 3CDB 32 BE 55             ld      (SERIALS_EN),A  ; store new serial status
6196+ 3CDE 7B                   ld      A,E             ; recover port #
6197+ 3CDF 3D                   dec     A               ; check port
6198+ 3CE0 20 0A                jr      NZ,CNTRX2       ; port is #2
6199+ 3CE2 CD E3 01             call    SIO_A_EI        ; re-enable RX on port 1
6200+ 3CE5 DB 01                in      A,(PIO_DB)      ; load status LEDs
6201+ 3CE7 CB A7                res     4,A             ; remove error LED
6202+ 3CE9 C3 F3 3C             jp      RXEND           ; terminate setting
6203+ 3CEC CD EB 01     CNTRX2: call    SIO_B_EI        ; re-enable RX on port 2
6204+ 3CEF DB 01                in      A,(PIO_DB)      ; load status LEDs
6205+ 3CF1 CB AF                res     5,A             ; remove error LED
6206+ 3CF3 D3 01        RXEND:  out     (PIO_DB),A      ; set new status for LEDs
6207+ 3CF5 FB                   ei                      ; re-enable INTs
6208+ 3CF6 C9                   ret                     ; return to caller
6209+ 3CF7                      ; set serial port comm.
6210+ 3CF7 D5           CNTSER2:push    DE              ; store BPS
6211+ 3CF8 3A 84 55             ld      A,(PRTNUM)      ; load port number
6212+ 3CFB 57                   ld      D,A             ; move port # into D
6213+ 3CFC 3A BE 55             ld      A,(SERIALS_EN)  ; check if serial port is already open
6214+ 3CFF A2                   and     D               ; by ANDing A with D
6215+ 3D00 D1                   pop     DE              ; retrieve BPS
6216+ 3D01 CA 09 3D             jp      Z,CNTSER3       ; not open, continue
6217+ 3D04 1E 2E                ld      E,SA            ; already open, so raise a "Serial Port Already Error"
6218+ 3D06 C3 31 18             jp      ERROR           ; and leave
6219+ 3D09 E5           CNTSER3:push    HL              ; store HL
6220+ 3D0A 21 00 E1             ld      HL,$E100        ; check bps. start with HL=57,600
6221+ 3D0D CD 38 41             call    CMP16           ; is bps<=57,600?
6222+ 3D10 E1                   pop     HL              ; but first, recover HL
6223+ 3D11 DA 78 3E             jp      C,SCERR         ; no (bps>57,600) then error
6224+ 3D14 ED 53 85 55          ld      (BPS),DE        ; store bps
6225+ 3D18 2B                   dec     HL              ; dec 'cos GETCHR INCs
6226+ 3D19 CD 5E 1D             call    GETCHR          ; Get next character
6227+ 3D1C CA 54 3D             jp      Z,DEFSER        ; defaults if nothing follows
6228+ 3D1F CD 15 1B             call    CHKSYN          ; Make sure ',' follows
6229+ 3D22 2C                   defb    ','
6230+ 3D23 CD 75 2A             call    GETINT          ; get data bits
6231+ 3D26 FE 05                cp      $05             ; is it <5?
6232+ 3D28 DA 78 3E             jp      C,SCERR         ; yes, error
6233+ 3D2B FE 09                cp      $09             ; is it >=9?
6234+ 3D2D D2 29 1E             jp      NC,FCERR        ; yes, error
6235+ 3D30 32 87 55             ld      (DATABT),A      ; store data bits
6236+ 3D33 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
6237+ 3D36 2C                   defb    ','
6238+ 3D37 CD 75 2A             call    GETINT          ; get parity bits
6239+ 3D3A BF FE 03             cp      A,$03           ; check if parity is in range 0~2
6240+ 3D3D D2 78 3E             jp      NC,SCERR        ; no, error
6241+ 3D40 32 88 55             ld      (PARBT),A       ; store parity
6242+ 3D43 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
6243+ 3D46 2C                   defb    ','
6244+ 3D47 CD 75 2A             call    GETINT          ; get stop bits
6245+ 3D4A FE 03                cp      $03             ; is it >=3?
6246+ 3D4C D2 78 3E             jp      NC,SCERR        ; yes, error
6247+ 3D4F 32 89 55             ld      (STPBT),A       ; store stop bits
6248+ 3D52 18 0D                jr      SETSER          ; jump to set serial
6249+ 3D54 3E 08        DEFSER: ld      A,$08           ; 8 bits for data
6250+ 3D56 32 87 55             ld      (DATABT),A
6251+ 3D59 AF                   xor     A               ; no parity bit
6252+ 3D5A 32 88 55             ld      (PARBT),A
6253+ 3D5D 3C                   inc     A               ; 1 bit for stop
6254+ 3D5E 32 89 55             ld      (STPBT),A
6255+ 3D61                      ; check if bps are legal
6256+ 3D61 E5           SETSER: push    HL              ; store HL
6257+ 3D62 D5                   push    DE              ; store DE
6258+ 3D63 DD E5                push    IX              ; store IX
6259+ 3D65 DD 21 53 3E          ld      IX,SUP_BPS      ; allowed BPSs
6260+ 3D69 06 0B                ld      B,$0B           ; 11 items
6261+ 3D6B 0E 00                ld      C,$00           ; reset pointer
6262+ 3D6D 2A 85 55     CKBPS:  ld      HL,(BPS)        ; load BPS
6263+ 3D70 DD 5E 00             ld      E,(IX+0)        ; load LSB of item
6264+ 3D73 DD 56 01             ld      D,(IX+1)        ; load MSB of item
6265+ 3D76 CD 38 41             call    CMP16           ; is it equal?
6266+ 3D79 CA 86 3D             jp      Z,SET_PT        ; yes, found a correspondance
6267+ 3D7C DD 23                inc     IX
6268+ 3D7E DD 23                inc     IX              ; no, go to next entry
6269+ 3D80 0C                   inc     C               ; increment pointer
6270+ 3D81 10 EA                djnz    CKBPS           ; repeat for 10 entries
6271+ 3D83 C3 74 3E             jp      SCERR1          ; if nothing found, raise an error
6272+ 3D86              SET_PT: ;init CTC CH0: CH0 provides RX/TX clock to SIO port A
6273+ 3D86                      ; TO0 output frequency=INPUT CLK/time constant. Time constant is set to get 16 times
6274+ 3D86                      ; the requested baud rate. I.e., if bps is 19,200 then time constast is set to 6 because
6275+ 3D86                      ; 1,843,200/6 = 307,200 Hz (that is 19,200 x 16)
6276+ 3D86 F3                   di                      ; disable INTs
6277+ 3D87 06 00                ld      B,$00           ; reset B
6278+ 3D89 21 69 3E             ld      HL,CTC_CFG      ; address of first CTC divider
6279+ 3D8C 09                   add     HL,BC           ; adjust for correct CTC divider
6280+ 3D8D 0E 10                ld      C,CTC_CH0       ; CTC channel 0
6281+ 3D8F 3A 84 55             ld      A,(PRTNUM)      ; load port number
6282+ 3D92 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6283+ 3D93 DA 97 3D             jp      C,SET_CTC       ; port 1 => ch. 0, so continue
6284+ 3D96 0C                   inc     C               ; port 2 => ch. 1, increment address port into C
6285+ 3D97 3E 47        SET_CTC:ld      A,%01000111     ; interrupt off, counter mode, prsc=16 (doesn't matter), ext. start,
6286+ 3D99                                              ; start upon loading time constant, time constant follows, sw reset, command word
6287+ 3D99 ED 79                out     (C),A           ; configure CTC channel
6288+ 3D9B 7E                   ld      A,(HL)          ; load CTC divider
6289+ 3D9C ED 79                out     (C),A           ; send divider
6290+ 3D9E                      ; configure SIO
6291+ 3D9E 21 36 03             ld      HL,SIO_A_SETS   ; load default settings for SIO
6292+ 3DA1 11 8A 55             ld      DE,SIOBFR       ; into a temp buffer
6293+ 3DA4 01 0A 00             ld      BC,$000A        ; 10 items to copy
6294+ 3DA7 ED B0                ldir                    ; copy SIO settings into TEMP buffer
6295+ 3DA9 3A 8F 55             ld      A,(SIOBFR+5)    ; load WR5 setting
6296+ 3DAC 47                   ld      B,A             ; move it into B
6297+ 3DAD 3A 87 55             ld      A,(DATABT)      ; load DATA bits
6298+ 3DB0 FE 05                cp      $05             ; is it 5 bits?
6299+ 3DB2 20 06                jr      NZ,BITS6        ; no, jump over
6300+ 3DB4 CB B0                res     6,B
6301+ 3DB6 CB A8                res     5,B             ; set D6 & D5 to 0
6302+ 3DB8 18 19                jr      SETPAR          ; jump to set parity
6303+ 3DBA FE 06        BITS6:  cp      $06             ; is it 6 bits?
6304+ 3DBC 20 06                jr      NZ,BITS7        ; no, jump over
6305+ 3DBE CB F0                set     6,B
6306+ 3DC0 CB A8                res     5,B             ; set D6 & D5 to 1,0
6307+ 3DC2 18 0F                jr      SETPAR          ; jump to set parity
6308+ 3DC4 FE 07        BITS7:  cp      $07             ; is it 7 bits?
6309+ 3DC6 20 07                jr      NZ,BITS8        ; no, jump over
6310+ 3DC8 CB B0                res     6,B
6311+ 3DCA CB E8                set     5,B             ; set D6 & D5 to 0,1
6312+ 3DCC C3 D3 3D             jp      SETPAR          ; jump to set parity
6313+ 3DCF CB F0        BITS8:  set     6,B
6314+ 3DD1 CB E8                set     5,B             ; set D6 & D5 to 1,1
6315+ 3DD3 21 BF 55     SETPAR: ld      HL,SERABITS     ; load address for storing data bits
6316+ 3DD6 3A 84 55             ld      A,(PRTNUM)      ; check serial port number
6317+ 3DD9 3D                   dec     A               ; is it port #1?
6318+ 3DDA CA DE 3D             jp      Z,SETPAR2       ; yes, jump over
6319+ 3DDD 23                   inc     HL              ; port #2, use SERBBITS instead
6320+ 3DDE 78           SETPAR2:ld      A,B             ; retrieve DATA bits
6321+ 3DDF 32 8F 55             ld      (SIOBFR+5),A    ; save DATA bits
6322+ 3DE2 E6 60                and     %01100000       ; filter only D5&D6 bits
6323+ 3DE4 87                   add     A,A             ; shift left times 1
6324+ 3DE5 77                   ld      (HL),A          ; store for SIO_EI & SIO_DI functions
6325+ 3DE6 3A 89 55             ld      A,(STPBT)       ; load STOP bits
6326+ 3DE9 87                   add     A,A
6327+ 3DEA 87                   add     A,A             ; 2 left shifts
6328+ 3DEB 47                   ld      B,A             ; move forming byte into B
6329+ 3DEC 3A 88 55             ld      A,(PARBT)       ; load PARITY setting
6330+ 3DEF A7                   and     A               ; is it 0?
6331+ 3DF0 CA FB 3D             jp      Z,STRPAR        ; yes, jump over
6332+ 3DF3 CB C0                set     0,B             ; set PARITY on
6333+ 3DF5 3D                   dec     A               ; is parity ODD?
6334+ 3DF6 CA FB 3D             jp      Z,STRPAR        ; yes, so jump over
6335+ 3DF9 CB C8                set     1,B             ; no, it's EVEN so set the corresponding bit
6336+ 3DFB 3A 8D 55     STRPAR: ld      A,(SIOBFR+3)    ; load WR4 setting
6337+ 3DFE E6 F0                and     %11110000       ; reset STOP & PARITY bits
6338+ 3E00 B0                   or      B               ; set new STOP & PARITY bits
6339+ 3E01 32 8D 55             ld      (SIOBFR+3),A    ; store new value
6340+ 3E04                      ;set up TX and RX:
6341+ 3E04                      ; the followings are settings for channel A
6342+ 3E04 21 8A 55             ld      HL,SIOBFR       ; settings for SIO ch. A
6343+ 3E07 06 06                ld      B,$06           ; 6 bytes to send
6344+ 3E09 0E 22                ld      C,SIO_CA        ; I/O address of SIO ch.A
6345+ 3E0B 3A 84 55             ld      A,(PRTNUM)      ; load port number
6346+ 3E0E 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6347+ 3E0F DA 13 3E             jp      C,SRLCNT        ; port 1, continue
6348+ 3E12 0C                   inc     C               ; port 2, increment address port into C
6349+ 3E13 ED B3        SRLCNT: otir                    ; send bytes to SIO
6350+ 3E15                      ; the following are settings for channel B (don't need to load HL since settings are contigous)
6351+ 3E15 06 04                ld      B,$04           ; other 4 bytes to send
6352+ 3E17 51                   ld      D,C             ; store port address into D
6353+ 3E18 0E 23                ld      C,SIO_CB        ; I/O address of SIO ch.B
6354+ 3E1A ED B3                otir                    ; send bytes to SIO
6355+ 3E1C                      ; the following are settings for selected channel
6356+ 3E1C 3E 01                ld      A,$01           ; write into WR0: select WR1
6357+ 3E1E 4A                   ld      C,D             ; retrieve port address
6358+ 3E1F ED 79                out     (C),A
6359+ 3E21 3E 18                ld      A,%00011000     ; interrupts on every RX char; parity is no special condition;
6360+ 3E23                                              ; buffer overrun is special condition
6361+ 3E23 ED 79                out     (C),A
6362+ 3E25 21 BE 55             ld      HL,SERIALS_EN
6363+ 3E28 3A 84 55             ld      A,(PRTNUM)      ; retrieve serial channel
6364+ 3E2B 3D                   dec     A               ; channel A?
6365+ 3E2C 20 10                jr      NZ,ENCHB        ; no, jump over
6366+ 3E2E CD E3 01             call    SIO_A_EI        ; enable RX on SIO channel A
6367+ 3E31 CB C6                set     0,(HL)          ; set serial port 1 status ON
6368+ 3E33 CB D6                set     2,(HL)          ; set serial port 1 RX ON
6369+ 3E35                      ; back to normal running
6370+ 3E35 FB                   ei                      ; re-enable INTs
6371+ 3E36 DB 01                in      A,(PIO_DB)      ; load status LEDs
6372+ 3E38 CB F7                set     6,A             ; set status LED on
6373+ 3E3A CB A7                res     4,A             ; set error LED off
6374+ 3E3C 18 0E                jr      EXNRM           ; leave
6375+ 3E3E CD EB 01     ENCHB:  call    SIO_B_EI        ; enable RX on SIO channel B
6376+ 3E41 CB CE                set     1,(HL)          ; set serial port 2 status ON
6377+ 3E43 CB DE                set     3,(HL)          ; set serial port 2 RX ON
6378+ 3E45                      ; back to normal running
6379+ 3E45 FB                   ei                      ; re-enable INTs
6380+ 3E46 DB 01                in      A,(PIO_DB)      ; load status LEDs
6381+ 3E48 CB FF                set     7,A             ; set status LED on
6382+ 3E4A CB AF                res     5,A             ; set error LED off
6383+ 3E4C D3 01        EXNRM:  out     (PIO_DB),A      ; send new configuration
6384+ 3E4E DD E1                pop     IX              ; retrieve IX
6385+ 3E50 D1                   pop     DE              ; retrieve DE
6386+ 3E51 E1                   pop     HL              ; retrieve HL
6387+ 3E52 C9                   ret                     ; return to caller
6388+ 3E53
6389+ 3E53              ; allowed bps (Bauds per second)
6390+ 3E53 00 E1 00 96  SUP_BPS:defw    57600,38400,28800,19200,14400,9600,4800,3600,2400,1200,600
6390+ 3E57 80 70 00 4B
6390+ 3E5B 40 38 80 25
6390+ 3E5F C0 12 10 0E
6390+ 3E63 60 09 B0 04
6390+ 3E67 58 02
6391+ 3E69              ; corresponding CTC divider
6392+ 3E69 02 03 04 06  CTC_CFG:defb    2,3,4,6,8,12,24,32,48,96,192
6392+ 3E6D 08 0C 18 20
6392+ 3E71 30 60 C0
6393+ 3E74
6394+ 3E74
6395+ 3E74              ; serial configuration error
6396+ 3E74 DD E1        SCERR1: pop     IX              ; retrieve IX
6397+ 3E76 D1                   pop     DE              ; retrieve DE
6398+ 3E77 E1                   pop     HL              ; retrieve HL
6399+ 3E78 1E 2C        SCERR:  ld      E,SC            ; Serial Configuration Error
6400+ 3E7A C3 31 18             jp      ERROR           ; print error
6401+ 3E7D
6402+ 3E7D
6403+ 3E7D              ; serial buffer overrun
6404+ 3E7D CD 2B 20     SOERR:  call    PRNTCRLF
6405+ 3E80 1E 30                ld      E,SO            ; Serial Buffer Overrun
6406+ 3E82 C3 31 18             jp      ERROR
6407+ 3E85
6408+ 3E85
6409+ 3E85              ; check for direct mode:
6410+ 3E85              ; Z is set if in direct mode, reset otherwise
6411+ 3E85 E5           DIRMOD: push    HL              ; Save code string address
6412+ 3E86 2A 29 54             ld      HL,(LINEAT)     ; Get current line number
6413+ 3E89 23                   inc     HL              ; -1 means direct statement
6414+ 3E8A 7C                   ld      A,H
6415+ 3E8B B5                   or      L
6416+ 3E8C E1                   pop     HL              ; Restore code string address
6417+ 3E8D C9                   ret
6418+ 3E8E
6419+ 3E8E
6420+ 3E8E              ; HELP lists the line program where an error occured
6421+ 3E8E CD 85 3E     HELP:   call    DIRMOD          ; check if in direct mode
6422+ 3E91 C2 A7 3E             jp      NZ,HLPERR       ; raise error if in indirect mode
6423+ 3E94 E5                   push    HL              ; store HL
6424+ 3E95 2A 2B 54             ld      HL,(HLPLN)      ; load HELP line
6425+ 3E98 23                   inc     HL              ; increment HL
6426+ 3E99 7C                   ld      A,H
6427+ 3E9A B5                   or      L               ; check if there is a line into the HELP reg.
6428+ 3E9B E1                   pop     HL
6429+ 3E9C CA A7 3E             jp      Z,HLPERR        ; no line found, raise error
6430+ 3E9F ED 5B 2B 54          ld      DE,(HLPLN)      ; recover line
6431+ 3EA3 C1                   pop     BC              ; remove BC from stack since it's not needed anymore for LIST
6432+ 3EA4 C3 AB 1B             jp      LST01H          ; jump to list line
6433+ 3EA7 1E 32        HLPERR: ld      E,HP            ; HELP call error
6434+ 3EA9 C3 31 18             jp      ERROR           ; raise error
6435+ 3EAC
6436+ 3EAC
6437+ 3EAC              ; KEY command to list/modify function keys and auto-repeat
6438+ 3EAC 2B           KEY:    dec     HL              ; dec 'cos GETCHR INCs
6439+ 3EAD CD 5E 1D             call    GETCHR          ; Get next character
6440+ 3EB0 CA 30 3F             jp      Z,LSTKEYS       ; jump if nothing follows
6441+ 3EB3                      ; change FN keys
6442+ 3EB3 CD 75 2A             call    GETINT          ; get a number
6443+ 3EB6 A7                   and     A               ; is it 0?
6444+ 3EB7 20 10                jr      NZ,KEYCH        ; no, jump over
6445+ 3EB9 E5           RESFN:  push    HL              ; yes - reset FN keys to defaults
6446+ 3EBA D5                   push    DE              ; store HL & DE
6447+ 3EBB 21 05 17             ld      HL,AUTORP       ; pointer to default auto-repeat delays and FN keys texts
6448+ 3EBE 11 2D 54             ld      DE,KEYDEL       ; pointer to destination
6449+ 3EC1 01 82 00             ld      BC,$0082        ; 130 chars to be copied (2xauto-delay, 128xFN keys)
6450+ 3EC4 ED B0                ldir                    ; restore default texts
6451+ 3EC6 D1                   pop     DE              ; retrieve DE
6452+ 3EC7 E1                   pop     HL              ; retrieve HL
6453+ 3EC8 C9                   ret                     ; return to caller
6454+ 3EC9 FE 09        KEYCH:  cp      $09             ; is it >= 9?
6455+ 3ECB D2 E3 3F             jp      NC,SETREP       ; yes - jump over
6456+ 3ECE 3D                   dec     A               ; FN key in range 0~7
6457+ 3ECF 87                   add     A,A             ; multiply A...
6458+ 3ED0 87                   add     A,A             ; ... times 4...
6459+ 3ED1 87                   add     A,A             ; ... to get the correct...
6460+ 3ED2 87                   add     A,A             ; ... offset fo FN key text
6461+ 3ED3 32 7C 55             ld      (TMPBFR1),A     ; store FN key offset...
6462+ 3ED6 AF                   xor     A               ; ...in a...
6463+ 3ED7 32 7D 55             ld      (TMPBFR1+1),A   ; ...16-bit register
6464+ 3EDA CD 15 1B             call    CHKSYN          ; Make sure ',' follows
6465+ 3EDD 2C                   defb    ','
6466+ 3EDE 44 4D                ld      BC,HL           ; copy address into BC
6467+ 3EE0 CD 01 22             call    EVAL            ; Evaluate expression (in E there is the length)
6468+ 3EE3 E5                   push    HL              ; store string pointer
6469+ 3EE4 3A 0E 55             ld      A,(TYPE)        ; Get variable type
6470+ 3EE7 B7                   or      A               ; Is it a string variable?
6471+ 3EE8 CA 17 18             jp      Z,SNERR         ; no - syntax error
6472+ 3EEB CD 3A 28             call    GSTRCU          ; Current string to pool
6473+ 3EEE CD 4B 30             call    LOADFP          ; Move string block data to (BC=pointer, DE=length)
6474+ 3EF1 7B                   ld      A,E             ; copy length into A
6475+ 3EF2 FE 11                cp      $11             ; is length > 16?
6476+ 3EF4 DA F9 3E             jp      C,DECLN1        ; no, jump over
6477+ 3EF7 1E 10                ld      E,$10           ; yes, so set length to 16
6478+ 3EF9 3E 10        DECLN1: ld      A,$10           ; calculate how many...
6479+ 3EFB 93                   sub     E               ; ...null chars needed to fill up...
6480+ 3EFC 57                   ld      D,A             ; ...the FN key text
6481+ 3EFD C5                   push    BC              ; store address of string
6482+ 3EFE ED 4B 7C 55          ld      BC,(TMPBFR1)    ; load FN key offset
6483+ 3F02 21 2F 54             ld      HL,FNKEYS       ; load address of FN keys texts
6484+ 3F05 09                   add     HL,BC           ; get corrected address
6485+ 3F06 C1                   pop     BC              ; retrieve address of string chars
6486+ 3F07 0A           CPKEY:  ld      A,(BC)          ; load char from string
6487+ 3F08 FE 0D                cp      CR              ; return?
6488+ 3F0A CA 17 3F             jp      Z,CPKEY2        ; yes, store char
6489+ 3F0D FE 7B                cp      $7B             ; if char > "z" ?
6490+ 3F0F D2 17 18             jp      NC,SNERR        ; yes - syntax error
6491+ 3F12 FE 20                cp      $20             ; is char < space?
6492+ 3F14 DA 17 18             jp      C,SNERR         ; yes - syntax error
6493+ 3F17 FE 61        CPKEY2: cp      $61             ; is it >= 'a'?
6494+ 3F19 DA 1E 3F             jp      C,CPKEY3        ; no, continue
6495+ 3F1C E6 5F                and     %01011111       ; set letters to uppercase
6496+ 3F1E 77           CPKEY3: ld      (HL),A          ; store char
6497+ 3F1F 23                   inc     HL              ; next string char
6498+ 3F20 03                   inc     BC              ; next free cell
6499+ 3F21 1D                   dec     E               ; decrement E
6500+ 3F22 20 E3                jr      NZ,CPKEY        ; repeat until 0
6501+ 3F24 AF                   xor     A               ; null char
6502+ 3F25 14                   inc     D               ; +1 to decrement below
6503+ 3F26 15           CPKEY1: dec     D               ; how many null chars to insert?
6504+ 3F27 CA 2E 3F             jp      Z,CPKYEND       ; no more nulls, so exit
6505+ 3F2A 77                   ld      (HL),A          ; store it
6506+ 3F2B 23                   inc     HL              ; next cell
6507+ 3F2C 18 F8                jr      CPKEY1          ; repeat
6508+ 3F2E E1           CPKYEND:pop     HL              ; retrieve pointer to string
6509+ 3F2F C9                   ret                     ; return to caller
6510+ 3F30                                              ; list FN keys
6511+ 3F30 E5           LSTKEYS:push    HL              ; Save code string address
6512+ 3F31 2A 29 54             ld      HL,(LINEAT)     ; Get current line number
6513+ 3F34 23                   inc     HL              ; -1 means direct statement
6514+ 3F35 7C                   ld      A,H
6515+ 3F36 B5                   or      L
6516+ 3F37 E1                   pop     HL              ; Restore code string address
6517+ 3F38 C2 17 18             jp      NZ,SNERR        ; raise error if in indirect mode
6518+ 3F3B E5                   push    HL              ; store HL
6519+ 3F3C D5                   push    DE              ; store DE
6520+ 3F3D 21 2F 54             ld      HL,FNKEYS       ; load starting address of FN keys text
6521+ 3F40 0E 01                ld      C,$01           ; 8 function keys
6522+ 3F42 06 10        PRTK4:  ld      B,$10           ; 16 chars each
6523+ 3F44 11 05 40             ld      DE,CHKEY1       ; message "KEY "
6524+ 3F47 CD D4 3F             call    PRTCKEY         ; print it
6525+ 3F4A 79                   ld      A,C             ; load FN key
6526+ 3F4B C6 30                add     $30             ; get number in ASCI code
6527+ 3F4D CD 20 1B             call    OUTC            ; print it
6528+ 3F50 11 0A 40             ld      DE,CHKEY2       ; message ": ""
6529+ 3F53 CD D4 3F             call    PRTCKEY         ; print it
6530+ 3F56 3E 01                ld      A,$01           ; " opened
6531+ 3F58 32 7C 55             ld      (TMPBFR1),A
6532+ 3F5B 7E           LDKEY:  ld      A,(HL)          ; retrieve char
6533+ 3F5C A7                   and     A               ; is it zero?
6534+ 3F5D CA 70 3F             jp      Z,CNTLTK        ; yes, go next char
6535+ 3F60 CD BC 3F             call    OPNQT           ; check if quotes are opened
6536+ 3F63 FE 22                cp      $22             ; check if char is "?
6537+ 3F65 CA 85 3F             jp      Z,PRTCHR        ; yes, print "chr$("
6538+ 3F68 FE 0D                cp      CR              ; is it a CR?
6539+ 3F6A CA 85 3F             jp      Z,PRTCHR        ; yes, print "chr$("
6540+ 3F6D CD 20 1B     PRTK3:  call    OUTC            ; no, just print it
6541+ 3F70 23           CNTLTK: inc     HL              ; next char
6542+ 3F71 10 E8                djnz    LDKEY           ; continue until finished
6543+ 3F73 CD AA 3F             call    CLSQT           ; check if quotes are still open
6544+ 3F76 3E 0D                ld      A,CR            ; go next line
6545+ 3F78 CD 20 1B             call    OUTC            ; print it
6546+ 3F7B 0C                   inc     C               ; next FN key
6547+ 3F7C 79                   ld      A,C             ; check if...
6548+ 3F7D FE 09                cp      $09             ; finished keys?
6549+ 3F7F DA 42 3F             jp      C,PRTK4         ; no, repeat 1 more time
6550+ 3F82 D1                   pop     DE              ; retrieve DE
6551+ 3F83 E1                   pop     HL              ; retrieve HL
6552+ 3F84 C9                   ret                     ; return to caller
6553+ 3F85 E5           PRTCHR: push    HL              ; store HL
6554+ 3F86 CD AA 3F             call    CLSQT           ; check if quotes are closed
6555+ 3F89 3E 2B                ld      A,'+'           ; '+' char
6556+ 3F8B CD 20 1B             call    OUTC            ; print it
6557+ 3F8E 11 0D 40             ld      DE,CHKEY3       ; address of "CHR$("
6558+ 3F91 CD D4 3F             call    PRTCKEY         ; print it
6559+ 3F94 E1                   pop     HL              ; recover HL
6560+ 3F95 23                   inc     HL              ; next char
6561+ 3F96 05                   dec     B               ; increment char counter
6562+ 3F97 11 13 40             ld      DE,CHKEY4       ; load address of RETURN
6563+ 3F9A 7E                   ld      A,(HL)          ; load char
6564+ 3F9B FE 0D                cp      CR              ; is it a RETURN?
6565+ 3F9D 20 03                jr      NZ,PTCHR1       ; no, jump over
6566+ 3F9F 11 16 40             ld      DE,CHKEY5       ; yes, load address of "
6567+ 3FA2 CD D4 3F     PTCHR1: call    PRTCKEY         ; print it
6568+ 3FA5 3E 29                ld      A,')'           ; char )
6569+ 3FA7 C3 6D 3F             jp      PRTK3           ; continue
6570+ 3FAA F5           CLSQT:  push    AF              ; store A
6571+ 3FAB 3A 7C 55             ld      A,(TMPBFR1)     ; quote status
6572+ 3FAE A7                   and     A               ; are they closed?
6573+ 3FAF 28 09                jr      Z,CLSQT1        ; if yes, return
6574+ 3FB1 3E 22                ld      A,$22           ; no, so close them
6575+ 3FB3 CD 20 1B             call    OUTC            ; print "
6576+ 3FB6 AF                   xor     A               ; set quotes
6577+ 3FB7 32 7C 55             ld      (TMPBFR1),A     ; as closed
6578+ 3FBA F1           CLSQT1: pop     AF              ; retrieve A
6579+ 3FBB C9                   ret                     ; return to caller
6580+ 3FBC F5           OPNQT:  push    AF              ; store A
6581+ 3FBD 3A 7C 55             ld      A,(TMPBFR1)     ; quote status
6582+ 3FC0 A7                   and     A               ; are they open?
6583+ 3FC1 20 0F                jr      NZ,OPNQT1       ; if yes, return
6584+ 3FC3 3E 2B                ld      A,'+'           ; no, so add '+
6585+ 3FC5 CD 20 1B             call    OUTC            ; print it
6586+ 3FC8 3E 22                ld      A,$22           ; and then open quotes
6587+ 3FCA CD 20 1B             call    OUTC            ; print them
6588+ 3FCD 3E 01                ld      A,$01           ; set quotes
6589+ 3FCF 32 7C 55             ld      (TMPBFR1),A     ; as opened
6590+ 3FD2 F1           OPNQT1: pop     AF              ; retrieve A
6591+ 3FD3 C9                   ret                     ; return to caller
6592+ 3FD4 F5           PRTCKEY:push    AF              ; store original char
6593+ 3FD5 1A           PRTK1:  ld      A,(DE)          ; load char
6594+ 3FD6 A7                   and     A               ; is it 0?
6595+ 3FD7 CA E1 3F             jp      Z,PRTEND        ; yes, finished printing
6596+ 3FDA CD 20 1B             call    OUTC            ; no, print char
6597+ 3FDD 13                   inc     DE              ; next char
6598+ 3FDE C3 D5 3F             jp      PRTK1           ; repeat
6599+ 3FE1 F1           PRTEND: pop     AF              ; retrieve AF
6600+ 3FE2 C9                   ret                     ; return to caller
6601+ 3FE3 FE 09        SETREP: cp      $09             ; is it special key 9? (stands for auto-repeat)
6602+ 3FE5 C2 17 18             jp      NZ,SNERR        ; no, raise an error
6603+ 3FE8 CD 15 1B             call    CHKSYN          ; Check for comma
6604+ 3FEB 2C                   defb    ','
6605+ 3FEC CD 75 2A             call    GETINT          ; get a number
6606+ 3FEF 32 7C 55             ld      (TMPBFR1),A     ; store it
6607+ 3FF2 CD 15 1B             call    CHKSYN          ; Check for comma
6608+ 3FF5 2C                   defb    ','
6609+ 3FF6 CD 75 2A             call    GETINT          ; get another number
6610+ 3FF9 E5                   push    HL              ; store HL
6611+ 3FFA 21 2E 54             ld      HL,AUTOKE       ; address of second cell for key auto-repeat
6612+ 3FFD 77                   ld      (HL),A          ; store auto-repeat delay
6613+ 3FFE 2B                   dec     HL              ; previous cell
6614+ 3FFF 3A 7C 55             ld      A,(TMPBFR1)     ; retrieve value
6615+ 4002 77                   ld      (HL),A          ; store delay for auto-repeat
6616+ 4003 E1                   pop     HL              ; retrieve HL
6617+ 4004 C9                   ret
6618+ 4005 4B 45 59 20  CHKEY1: defb    "KEY ",0
6618+ 4009 00
6619+ 400A 3A 22 00     CHKEY2: defb    ":",34,0
6620+ 400D 63 68 72 24  CHKEY3: defb    "chr$(",0
6620+ 4011 28 00
6621+ 4013 31 33 00     CHKEY4: defb    "13",0
6622+ 4016 33 34 00     CHKEY5: defb    "34",0
6623+ 4019
6624+ 4019
6625+ 4019              ; HEX$(nn) Convert 16 bit number to Hexadecimal string
6626+ 4019 CD F2 21     HEX: 	call	TSTNUM          ; Verify it's a number
6627+ 401C CD 14 1E             call	DEINT           ; Get integer -32768 to 32767
6628+ 401F C5                   push	BC              ; Save contents of BC
6629+ 4020 21 D5 55             ld      HL,PBUFF        ; load address of PBUFF into HL
6630+ 4023 7A                   ld      A,D             ; Get MSB into A
6631+ 4024 B7                   or      A               ; OR with LSB to see if param=0
6632+ 4025 28 0C                jr      Z,HEX2          ; Skip output if both high digits are zero
6633+ 4027 CD 4F 40             call    BYT2ASC         ; Convert D to ASCII
6634+ 402A 78                   ld      A,B             ; cechk if B
6635+ 402B FE 30                cp      '0'             ; is 0
6636+ 402D 28 02                jr      Z,HEX1          ; Don't store high digit if zero
6637+ 402F 70                   ld      (HL),B          ; Store it to PBUFF
6638+ 4030 23                   inc     HL              ; Next location
6639+ 4031 71           HEX1:   ld      (HL),C          ; Store C to PBUFF+1
6640+ 4032 23                   inc     HL              ; Next location
6641+ 4033 7B           HEX2:   ld      A,E             ; Get lower byte
6642+ 4034 CD 4F 40             call    BYT2ASC         ; Convert E to ASCII
6643+ 4037 7A                   ld      A,D
6644+ 4038 B7                   or      A
6645+ 4039 20 05                jr      NZ,HEX3         ; If upper byte was not zero then always print lower byte
6646+ 403B 78                   ld      A,B
6647+ 403C FE 30                cp      '0'             ; If high digit of lower byte is zero then don't print
6648+ 403E 28 02                jr      Z,HEX4
6649+ 4040 70           HEX3:   ld      (HL),B          ; to PBUFF+2
6650+ 4041 23                   inc     HL              ; Next location
6651+ 4042 71           HEX4:   ld      (HL),C          ; to PBUFF+3
6652+ 4043 23                   inc     HL              ; PBUFF+4 to zero
6653+ 4044 AF                   xor     A               ; Terminating character
6654+ 4045 77                   ld      (HL),A          ; Store zero to terminate
6655+ 4046 23                   inc     HL              ; Make sure PBUFF is terminated
6656+ 4047 77                   ld      (HL),A          ; Store the double zero there
6657+ 4048 C1                   pop     BC              ; Get BC back
6658+ 4049 21 D5 55             ld      HL,PBUFF        ; Reset to start of PBUFF
6659+ 404C C3 87 26             jp      STR1            ; Convert the PBUFF to a string and return it
6660+ 404F 47           BYT2ASC:ld      B,A             ; Save original value
6661+ 4050 E6 0F                and     $0F             ; Strip off upper nybble
6662+ 4052 FE 0A                cp      $0A             ; 0-9?
6663+ 4054 38 02                jr      C,ADD30         ; If A-F, add 7 more
6664+ 4056 C6 07                add     A,$07           ; Bring value up to ASCII A-F
6665+ 4058 C6 30        ADD30:  add     A,$30           ; And make ASCII
6666+ 405A 4F                   ld      C,A             ; Save converted char to C
6667+ 405B 78                   ld      A,B             ; Retrieve original value
6668+ 405C 0F                   rrca                    ; and Rotate it right
6669+ 405D 0F                   rrca
6670+ 405E 0F                   rrca
6671+ 405F 0F                   rrca
6672+ 4060 E6 0F                and     $0F             ; Mask off upper nybble
6673+ 4062 FE 0A                cp      $0A             ; 0-9? < A hex?
6674+ 4064 38 02                jr      C,ADD301        ; Skip Add 7
6675+ 4066 C6 07                add     A,$07           ; Bring it up to ASCII A-F
6676+ 4068 C6 30        ADD301: add     A,$30           ; And make it full ASCII
6677+ 406A 47                   ld      B,A             ; Store high order byte
6678+ 406B C9                   ret
6679+ 406C
6680+ 406C              ; Convert "&Hnnnn" to FPREG
6681+ 406C              ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
6682+ 406C              ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
6683+ 406C EB           HEXTFP: ex      DE,HL           ; Move code string pointer to DE
6684+ 406D 21 00 00             ld      HL,$0000        ; Zero out the value
6685+ 4070 CD 85 40             call    GETHEX          ; Check the number for valid hex
6686+ 4073 DA A5 40             jp      C,HXERR         ; First value wasn't hex, HEX error
6687+ 4076 18 05                jr      HEXLP1          ; Convert first character
6688+ 4078 CD 85 40     HEXLP:  call    GETHEX          ; Get second and addtional characters
6689+ 407B 38 1F                jr      C,HEXIT         ; Exit if not a hex character
6690+ 407D 29           HEXLP1: add     HL,HL           ; Rotate 4 bits to the left
6691+ 407E 29                   add     HL,HL
6692+ 407F 29                   add     HL,HL
6693+ 4080 29                   add     HL,HL
6694+ 4081 B5                   or      L               ; Add in D0-D3 into L
6695+ 4082 6F                   ld      L,A             ; Save new value
6696+ 4083 18 F3                jr      HEXLP           ; And continue until all hex characters are in
6697+ 4085
6698+ 4085 13           GETHEX: inc     DE              ; Next location
6699+ 4086 1A                   ld      A,(DE)          ; Load character at pointer
6700+ 4087 FE 20                cp      SPC
6701+ 4089 CA 85 40             jp      Z,GETHEX        ; Skip spaces
6702+ 408C D6 30                sub     $30             ; Get absolute value
6703+ 408E D8                   ret     C               ; < "0", error
6704+ 408F FE 0A                cp      $0A
6705+ 4091 38 05                jr      C,NOSUB7        ; Is already in the range 0-9
6706+ 4093 D6 07                sub     $07             ; Reduce to A-F
6707+ 4095 FE 0A                cp      $0A             ; Value should be $0A-$0F at this point
6708+ 4097 D8                   ret     C               ; CY set if was :            ; < = > ? @
6709+ 4098 FE 10        NOSUB7: cp      $10             ; > Greater than "F"?
6710+ 409A 3F                   ccf
6711+ 409B C9                   ret                     ; CY set if it wasn't valid hex
6712+ 409C
6713+ 409C EB           HEXIT:  ex      DE,HL           ; Value into DE, Code string into HL
6714+ 409D 7A                   ld      A,D             ; Load DE into AC
6715+ 409E 4B                   ld      C,E             ; For prep to
6716+ 409F E5                   push    HL
6717+ 40A0 CD D8 25             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6718+ 40A3 E1                   pop     HL
6719+ 40A4 C9                   ret
6720+ 40A5
6721+ 40A5 1E 26        HXERR:  ld      E,HE            ; ?HEX Error
6722+ 40A7 C3 31 18             jp      ERROR
6723+ 40AA
6724+ 40AA              ; BIN$(NN) Convert integer to a 1-16 char binary string
6725+ 40AA CD F2 21     BIN:    call    TSTNUM          ; Verify it's a number
6726+ 40AD CD 14 1E             call    DEINT           ; Get integer -32768 to 32767
6727+ 40B0 C5                   push    BC              ; Save contents of BC
6728+ 40B1 21 D5 55             ld      HL,PBUFF
6729+ 40B4 06 11                ld      B,$11           ; One higher than max char count (16+1)
6730+ 40B6                      ; Suppress leading zeros
6731+ 40B6 05           ZEROSUP:dec     B               ; Max 16 chars
6732+ 40B7 78                   ld      A,B
6733+ 40B8 FE 01                cp      $01
6734+ 40BA 28 08                jr      Z,BITOUT        ; Always output at least one character
6735+ 40BC CB 13                rl      E
6736+ 40BE CB 12                rl      D
6737+ 40C0 30 F4                jr      NC,ZEROSUP
6738+ 40C2 18 04                jr      BITOUT2
6739+ 40C4 CB 13        BITOUT: rl      E
6740+ 40C6 CB 12                rl      D               ; Top bit now in carry
6741+ 40C8 3E 30        BITOUT2:ld      A,'0'           ; Char for '0'
6742+ 40CA CE 00                adc     A,$00           ; If carry set then '0' --> '1'
6743+ 40CC 77                   ld      (HL),A
6744+ 40CD 23                   inc     HL
6745+ 40CE 05                   dec     B
6746+ 40CF 20 F3                jr      NZ,BITOUT
6747+ 40D1 AF                   xor     A               ; Terminating character
6748+ 40D2 77                   ld      (HL),A          ; Store zero to terminate
6749+ 40D3 23                   inc     HL              ; Make sure PBUFF is terminated
6750+ 40D4 77                   ld      (HL),A          ; Store the double zero there
6751+ 40D5 C1                   pop     BC
6752+ 40D6 21 D5 55             ld      HL,PBUFF
6753+ 40D9 C3 87 26             jp      STR1
6754+ 40DC
6755+ 40DC              ; Convert "&Bnnnn" to FPREG
6756+ 40DC              ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
6757+ 40DC EB           BINTFP: ex      DE,HL           ; Move code string pointer to DE
6758+ 40DD 21 00 00             ld      HL,$0000        ; Zero out the value
6759+ 40E0 CD F9 40             call    CHKBIN          ; Check the number for valid bin
6760+ 40E3 DA 07 41             jp      C,BINERR        ; First value wasn't bin, BIN error
6761+ 40E6 D6 30        BINIT:  sub     '0'
6762+ 40E8 29                   add     HL,HL           ; Rotate HL left
6763+ 40E9 B5                   or      L
6764+ 40EA 6F                   ld      L,A
6765+ 40EB CD F9 40             call    CHKBIN          ; Get second and addtional characters
6766+ 40EE 30 F6                jr      NC,BINIT        ; Process if a bin character
6767+ 40F0 EB                   ex      DE,HL           ; Value into DE, Code string into HL
6768+ 40F1 7A                   ld      A,D             ; Load DE into AC
6769+ 40F2 4B                   ld      C,E             ; For prep to
6770+ 40F3 E5                   push    HL
6771+ 40F4 CD D8 25             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6772+ 40F7 E1                   pop     HL
6773+ 40F8 C9                   ret
6774+ 40F9
6775+ 40F9              ; Char is in A, NC if char is 0 or 1
6776+ 40F9 13           CHKBIN: inc     DE
6777+ 40FA 1A                   ld      A,(DE)
6778+ 40FB FE 20                cp      SPC
6779+ 40FD CA F9 40             jp      Z,CHKBIN        ; Skip spaces
6780+ 4100 FE 30                cp      '0'             ; Set C if < '0'
6781+ 4102 D8                   ret     C
6782+ 4103 FE 32                cp      '2'
6783+ 4105 3F                   ccf                     ; Set C if > '1'
6784+ 4106 C9                   ret
6785+ 4107
6786+ 4107 1E 28        BINERR: ld      E,BN            ; ?BIN Error
6787+ 4109 C3 31 18             jp      ERROR
6788+ 410C
6789+ 410C
6790+ 410C C3 08 00     MONOUT: jp      $0008           ; output a char
6791+ 410F
6792+ 410F
6793+ 410F CD 90 2A     RESET:  call    DISNMI          ; disable NMI vector
6794+ 4112 3A BE 55             ld      A,(SERIALS_EN)  ; load status of serial lines
6795+ 4115 E6 11                and     $11             ; are serial ports open?
6796+ 4117 C4 83 3C             call    NZ,RSTSERS      ; yes, reset serials
6797+ 411A 3A C1 55             ld      A,(DOS_EN)      ; check DOS status
6798+ 411D A7                   and     A               ; DOS enabled?
6799+ 411E 28 07                jr      Z,RESETE        ; no, jump over
6800+ 4120 CD 44 FD             call    CF_STANDBY      ; yes, put CF into standby mode
6801+ 4123 AF                   xor     A
6802+ 4124 32 D6 FF             ld      (SEQFL),A       ; close any seq. file opened
6803+ 4127 F3           RESETE: di                      ; disable INTs
6804+ 4128 C3 43 53             jp      ROM2RAM         ; Restart
6805+ 412B
6806+ 412B
6807+ 412B AF           INITST: xor     A              ; Clear break flag
6808+ 412C 32 23 54             ld      (BRKFLG),A
6809+ 412F C3 DC 12             jp      SYSINIT
6810+ 4132
6811+ 4132
6812+ 4132 CD 20 1B     OUTNCR: call    OUTC            ; Output character in A
6813+ 4135 C3 2B 20             jp      PRNTCRLF        ; Output CRLF
6814+ 4138
# file closed: ../include/basic/basic-1.12.asm
  76  4138
  77  4138              ; include utils
  78  4138                  INCLUDE "../include/utils/utils-r1.2.asm"
# file opened: ../include/utils/utils-r1.2.asm
   1+ 4138              ; ------------------------------------------------------------------------------
   2+ 4138              ; LM80C - UTILITY ROUTINES - R1.2
   3+ 4138              ; ------------------------------------------------------------------------------
   4+ 4138              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4138              ; designed by Leonardo Miliani. More info at
   6+ 4138              ; www DOT leonardomiliani DOT com
   7+ 4138              ;
   8+ 4138              ; *ALS are routines from "Z80 Assembly Language Subroutines" by Lance
   9+ 4138              ; A. Leventhal and Winthrop Saville - Ed. Osborne/McGraw-Hill (1983)
  10+ 4138              ;
  11+ 4138              ; * WKT are routines from WikiTI:
  12+ 4138              ; http://wikiti.brandonw.net/index.php?title=WikiTI_Home
  13+ 4138              ;
  14+ 4138              ; * LAC are routines from Learn@Cemetch
  15+ 4138              ; https://learn.cemetech.net/index.php/Main_Page
  16+ 4138              ;
  17+ 4138              ; ------------------------------------------------------------------------------
  18+ 4138              ; Code Revision:
  19+ 4138              ; R1.0 - 20200110 - First release: 16-bit comparision/multiplication/negation
  20+ 4138              ; R1.1 - 20200413 - Second release: added ABS(HL)
  21+ 4138              ; R1.2 - 20200131 - Added 32/16 bit multiplication/division and converter to
  22+ 4138              ;                   transform a 32-bit value into ASCII representation
  23+ 4138              ;
  24+ 4138              ; ------------------------------------------------------------------------------
  25+ 4138
  26+ 4138              ; compare two 16-bit registers, HL (minuend) and DE (subtrahend)
  27+ 4138              ; values can be both signed or unsigned words
  28+ 4138              ; inputs: HL, DE
  29+ 4138              ; destroys: A,F,HL
  30+ 4138              ;
  31+ 4138              ; returns: Z=1 if HL = DE
  32+ 4138              ; for UNSIGNED: C=1 if HL<DE  //  C=0 if HL>DE
  33+ 4138              ; for SIGNED:   S=1 (M) if HL<DE  //  S=0 (P) if HL>DE
  34+ 4138              ; if HL=DE: Z,P,NC  - Z=1, S=0; C=0
  35+ 4138              ; if HL>DE: NZ,P,NC - Z=0, S=0; C=0
  36+ 4138              ; if HL<DE: NZ,M,C  - Z=0, S=1; C=1
  37+ 4138              ; Source: ALS
  38+ 4138
  39+ 4138 B7           CMP16:  or      A           ; clear CARRY
  40+ 4139 ED 52                sbc     HL,DE       ; subtract DE from HL
  41+ 413B E0                   ret     PO          ; return if no overflow
  42+ 413C 7C                   ld      A,H         ; overflow - invert SIGN flag
  43+ 413D 1F                   rra                 ; save CARRY flag in bit 7
  44+ 413E EE 40                xor     %01000000   ; complement bit 6 (SIGN bit)
  45+ 4140 37                   scf                 ; ensure a Non-Zero result
  46+ 4141 8F                   adc     A,A         ; restore CARRY, complemented SIGN
  47+ 4142                                          ; ZERO flag = 0 for sure
  48+ 4142 C9                   ret                 ; return
  49+ 4143
  50+ 4143              ; ----------------------------------------------------------------------
  51+ 4143
  52+ 4143              ; multiply 2 signed/unsigned 16-bit words and return a 16-bit
  53+ 4143              ; signed/unsigned product
  54+ 4143              ; inputs: HL (multiplicand); DE (multiplier)
  55+ 4143              ; destroys: A,F
  56+ 4143              ; returns: HL (product)
  57+ 4143              ; Source: ALS
  58+ 4143
  59+ 4143              ; initialize partial product, bit count
  60+ 4143 C5           MUL16:  push    BC
  61+ 4144 4D                   ld      C,L         ; BC = multiplier
  62+ 4145 44                   ld      B,H
  63+ 4146 21 00 00             ld      HL,0        ; product = 0
  64+ 4149 3E 0F                ld      A,$0F       ; count = bit lenght - 1 (16-1)
  65+ 414B                      ; shift-and-add algorithm
  66+ 414B                      ; if MSB of multiplier is 1, add multiplicand to partial product
  67+ 414B                      ; shift partial product, multiplier left 1 bit
  68+ 414B CB 23        MLP:    sla     E           ; shift multiplier left 1 bit
  69+ 414D CB 12                rl      D
  70+ 414F 30 01                jr      NC,MLP1     ; jump if MSB of multiplier = 0
  71+ 4151 09                   add     HL,BC       ; add multiplicand to partial product
  72+ 4152 29           MLP1:   add     HL,HL       ; shift partial product left
  73+ 4153 3D                   dec     A
  74+ 4154 20 F5                jr      NZ,MLP      ; continue until count = 0
  75+ 4156                      ; add multiplicand one last time if MSB of multiplier is 1
  76+ 4156 B2                   or      D           ; sign flag = MSB of multiplier
  77+ 4157 F2 5B 41             jp      P,EXMUL16   ; exit if MSB of multiplier is 0
  78+ 415A 09                   add     HL,BC       ; add multiplicand to product
  79+ 415B C1           EXMUL16:pop     BC
  80+ 415C C9                   ret
  81+ 415D
  82+ 415D
  83+ 415D              ; ----------------------------------------------------------------------
  84+ 415D
  85+ 415D              ; multiply 2 unsigned 16-bit words and return a 32-bit unsigned product
  86+ 415D              ; inputs: BC (multiplicand); DE (multiplier)
  87+ 415D              ; destroys: A,F
  88+ 415D              ; operation: BC * DE
  89+ 415D              ; returns: DEHL (product)
  90+ 415D              ; Source: WKT
  91+ 415D
  92+ 415D 21 00 00     MUL_U32:ld      HL,$0000        ; reset HL
  93+ 4160 CB 23                sla     E		; optimised 1st iteration
  94+ 4162 CB 12                rl      D
  95+ 4164 30 02                jr      NC,MU32_1       ; if no Carry then jump over
  96+ 4166 60                   ld      H,B
  97+ 4167 69                   ld      L,C
  98+ 4168 3E 0F        MU32_1: ld      A,$0F
  99+ 416A 29           MUL_32L:add     HL,HL           ; main loop
 100+ 416B CB 13                rl      E
 101+ 416D CB 12                rl      D
 102+ 416F 30 04                jr      NC,MU32_2
 103+ 4171 09                   add     HL,BC
 104+ 4172 30 01                jr      NC,MU32_2
 105+ 4174 13                   inc     DE
 106+ 4175 3D           MU32_2: dec     A
 107+ 4176 20 F2                jr      NZ,MUL_32L
 108+ 4178 C9                   ret
 109+ 4179
 110+ 4179              ; ----------------------------------------------------------------------
 111+ 4179              ; absolute value of HL (same applies to other 16-bit register pairs)
 112+ 4179              ; also, invert value of HL (or any other 16-bit register, just adjust the code)
 113+ 4179              ;
 114+ 4179              ; inputs: HL
 115+ 4179              ; destroys: A
 116+ 4179              ; operation: ABS(HL)
 117+ 4179              ; returns: HL with no sign or negated
 118+ 4179              ; Source: WKT
 119+ 4179
 120+ 4179 CB 7C        absHL:  bit     7,H
 121+ 417B C8                   ret     Z
 122+ 417C AF           negHL:  xor     A
 123+ 417D 95                   sub     L
 124+ 417E 6F                   ld      L,A
 125+ 417F 9F                   sbc     A,A
 126+ 4180 94                   sub     H
 127+ 4181 67                   ld      H,A
 128+ 4182 C9                   ret
 129+ 4183
 130+ 4183              ; ------------------------------------------------------------------------------
 131+ 4183
 132+ 4183              ; 8/8 division
 133+ 4183              ; INPUT: D (dividend), E (divisor)
 134+ 4183              ; OPERATION: D/E
 135+ 4183              ; OUTPUT: D (quotient), A (remainder)
 136+ 4183 AF           DIV_8_8:    xor     A
 137+ 4184 C5                       push    BC
 138+ 4185 06 08                    ld      B,08h
 139+ 4187 CB 22        DIV_8_8LOOP:sla     D
 140+ 4189 17                       rla
 141+ 418A BB                       cp      E
 142+ 418B 38 02                    jr      C,$+4
 143+ 418D 93                       sub     E
 144+ 418E 14                       inc     D
 145+ 418F 10 F6                    djnz    DIV_8_8LOOP
 146+ 4191 C1                       pop     BC
 147+ 4192 C9                       ret
 148+ 4193
 149+ 4193              ; ----------------------------------------------------------------------
 150+ 4193              ; divide a 16-bit number by an 8-bit number
 151+ 4193              ; (16/8 division)
 152+ 4193              ;
 153+ 4193              ; inputs: HL (Dividend), C (divisor)
 154+ 4193              ; destroys: A, B
 155+ 4193              ; OPERATION: HL/C
 156+ 4193              ; returns: HL (quotient), A (remainder)
 157+ 4193              ; source: WKT
 158+ 4193
 159+ 4193 AF           DIV_16_8:   xor     A
 160+ 4194 06 10                    ld      B,16
 161+ 4196 29           DIV_16_8LP: add     HL,HL
 162+ 4197 17                       rla
 163+ 4198 38 03                    jr      C,$+5
 164+ 419A B9                       cp      C
 165+ 419B 38 02                    jr      C,$+4
 166+ 419D 91                       sub     C
 167+ 419E 2C                       inc     L
 168+ 419F 10 F5                    djnz    DIV_16_8LP
 169+ 41A1 C9                       ret
 170+ 41A2
 171+ 41A2              ; ----------------------------------------------------------------------
 172+ 41A2              ; divide a 16-bit number by a 16-bit number
 173+ 41A2              ; (16/16 division)
 174+ 41A2              ;
 175+ 41A2              ; inputs: AC (Dividend), DE (divisor)
 176+ 41A2              ; destroys: HL,A,C
 177+ 41A2              ; OPERATION: AC/DE
 178+ 41A2              ; returns: AC (quotient), HL (remainder)
 179+ 41A2              ; source: WKT
 180+ 41A2 21 00 00     DIV_16_16:  ld      HL, 0
 181+ 41A5 06 10                    ld      B, 16
 182+ 41A7 CB 21        DV16_16_LP: sla     C
 183+ 41A9 CB C1                    set     0,C         ; this simulates the SLL undocumented instruction
 184+ 41AB 17                       rla
 185+ 41AC ED 6A                    adc     HL,HL
 186+ 41AE ED 52                    sbc     HL,DE
 187+ 41B0 30 02                    jr      NC, $+4
 188+ 41B2 19                       add     HL,DE
 189+ 41B3 0D                       dec     C
 190+ 41B4 10 F1                    djnz    DV16_16_LP
 191+ 41B6 C9                       ret
 192+ 41B7
 193+ 41B7
 194+ 41B7              ; ----------------------------------------------------------------------
 195+ 41B7              ; divide a 32-bit number by a 16 bit-number
 196+ 41B7              ; (32/16 division)
 197+ 41B7              ;
 198+ 41B7              ; inputs: ACIX (Dividend), DE (divisor)
 199+ 41B7              ; destroys: HL,IX,BC
 200+ 41B7              ; OPERATION: ACIX/DE
 201+ 41B7              ; returns: ACIX (quotient), HL (remainder)
 202+ 41B7              ; source: WKT
 203+ 41B7
 204+ 41B7 21 00 00     DIV_32_16:  ld      HL,0
 205+ 41BA 06 20                    ld      B,32
 206+ 41BC DD 29        DIV_32_16LP:add     IX,IX
 207+ 41BE CB 11                    rl      C
 208+ 41C0 17                       rla
 209+ 41C1 ED 6A                    adc     HL,HL
 210+ 41C3 38 08                    jr      C,DIV_32_16OF
 211+ 41C5 ED 52                    sbc     HL,DE
 212+ 41C7 30 07                    jr      NC,DIV_32_16SB
 213+ 41C9 19                       add     HL,DE
 214+ 41CA 10 F0                    djnz    DIV_32_16LP
 215+ 41CC C9                       ret
 216+ 41CD B7           DIV_32_16OF:or      A                   ; overflow
 217+ 41CE ED 52                    sbc     HL,DE
 218+ 41D0 DD 23        DIV_32_16SB:inc     IX                  ; set bit
 219+ 41D2 10 E8                    djnz    DIV_32_16LP
 220+ 41D4 C9                       ret
 221+ 41D5
 222+ 41D5
 223+ 41D5              ; ----------------------------------------------------------------------
 224+ 41D5              ; convert a 32-bit number in ASCII string (terminated by '0')
 225+ 41D5              ;
 226+ 41D5              ; inputs: DEIX (Value), IY (dest. address in memory)
 227+ 41D5              ; destroys: AF, BC, DE, HL, IX
 228+ 41D5              ; outputs: IY (last char in dest. string)
 229+ 41D5              ; source: MSX Forum
 230+ 41D5
 231+ 41D5 01 00 00 00  CLCN32T:    defw    1,0,10,0,100,0,1000,0,10000,0
 231+ 41D9 0A 00 00 00
 231+ 41DD 64 00 00 00
 231+ 41E1 E8 03 00 00
 231+ 41E5 10 27 00 00
 232+ 41E9 A0 86 01 00              defw    $86A0,$1,$4240,$F,$9680,$98,$E100,$5F5,$CA00,$3B9A
 232+ 41ED 40 42 0F 00
 232+ 41F1 80 96 98 00
 232+ 41F5 00 E1 F5 05
 232+ 41F9 00 CA 9A 3B
 233+ 41FD 00 00 00 00  CLCN32Z:    defs    4
 234+ 4201
 235+ 4201 DD 22 FD 41  CLCN32:     ld      (CLCN32Z),IX
 236+ 4205 ED 53 FF 41              ld      (CLCN32Z+$02),DE
 237+ 4209 DD 21 F9 41              ld      IX,CLCN32T+$24
 238+ 420D 06 09                    ld      B,$09
 239+ 420F 0E 00                    ld      C,$00
 240+ 4211 3E 30        CLCN321:    ld      A,"0"
 241+ 4213 B7                       or      A
 242+ 4214 DD 5E 00     CLCN322:    ld      E,(IX+$00)
 243+ 4217 DD 56 01                 ld      D,(IX+$01)
 244+ 421A 2A FD 41                 ld      HL,(CLCN32Z)
 245+ 421D ED 52                    sbc     HL,DE
 246+ 421F 22 FD 41                 ld      (CLCN32Z),HL
 247+ 4222 DD 5E 02                 ld      E,(IX+$02)
 248+ 4225 DD 56 03                 ld      D,(IX+$03)
 249+ 4228 2A FF 41                 ld      HL,(CLCN32Z+$02)
 250+ 422B ED 52                    sbc     HL,DE
 251+ 422D 22 FF 41                 ld      (CLCN32Z+$02),HL
 252+ 4230 38 04                    jr      C,CLCN325
 253+ 4232 0C                       inc     C
 254+ 4233 3C                       inc     A
 255+ 4234 18 DE                    jr      CLCN322
 256+ 4236 DD 5E 00     CLCN325:    ld      E,(IX+$00)
 257+ 4239 DD 56 01                 ld      D,(IX+$01)
 258+ 423C 2A FD 41                 ld      HL,(CLCN32Z)
 259+ 423F 19                       add     HL,DE
 260+ 4240 22 FD 41                 ld      (CLCN32Z),HL
 261+ 4243 DD 5E 02                 ld      E,(IX+$02)
 262+ 4246 DD 56 03                 ld      D,(IX+$03)
 263+ 4249 2A FF 41                 ld      HL,(CLCN32Z+$02)
 264+ 424C ED 5A                    adc     HL,DE
 265+ 424E 22 FF 41                 ld      (CLCN32Z+$02),HL
 266+ 4251 11 FC FF                 ld      DE,-4
 267+ 4254 DD 19                    add     IX,DE
 268+ 4256 0C                       inc     C
 269+ 4257 0D                       dec     C
 270+ 4258 28 05                    jr      Z,CLCN323
 271+ 425A FD 77 00                 ld      (IY+$00),A
 272+ 425D FD 23                    inc     IY
 273+ 425F 10 B0        CLCN323:    djnz    CLCN321
 274+ 4261 3A FD 41                 ld      A,(CLCN32Z)
 275+ 4264 C6 30                    add     "0"
 276+ 4266 FD 77 00                 ld      (IY+$00),A
 277+ 4269 FD 36 01 00              ld      (IY+$01),0
 278+ 426D C9                       ret
# file closed: ../include/utils/utils-r1.2.asm
  79  426E
  80  426E              ; include the latest version of the font sets
  81  426E                  INCLUDE "../include/vdp/6x8fonts-r16.asm"
# file opened: ../include/vdp/6x8fonts-r16.asm
   1+ 426E              ; ------------------------------------------------------------------------------
   2+ 426E              ; LM80C - 6x8 CHARSET - R1.6
   3+ 426E              ; ------------------------------------------------------------------------------
   4+ 426E              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 426E              ; designed by Leonardo Miliani. More info at
   6+ 426E              ; www DOT leonardomiliani DOT com
   7+ 426E              ; ------------------------------------------------------------------------------
   8+ 426E              ; Code Revision:
   9+ 426E              ; R1.0 - 20190511 - First revision: ASCII chars (from 0 to 127)
  10+ 426E              ; R1.1 - 20190521 - Expanded to 255 chars
  11+ 426E              ; R1.2 - 20191209 - Start adding graphic chars to be coherent with 8x8 fonts
  12+ 426E              ; R1.3 - 20191226 - Added extended char codes (128-255)
  13+ 426E              ; R1.4 - 20200228 - adopted more usual hexadecimal & binary prefixes
  14+ 426E              ; R1.5 - 20200524 - New style for char #252
  15+ 426E              ; R1.6 - 20200704 - Redefined chars 105, 106, and 252
  16+ 426E              ; ------------------------------------------------------------------------------
  17+ 426E              ;
  18+ 426E              ;-------------------------------------------------------------------------------
  19+ 426E              ;
  20+ 426E              ;               6 x 8    C  H  A  R  S  E  T
  21+ 426E              ;
  22+ 426E              ;-------------------------------------------------------------------------------
  23+ 426E              ;
  24+ 426E              ;       6X8 CHARS, DESIGNED FOR TEXT BUT USABLE IN GRAPHICS 1 MODE TOO
  25+ 426E              ;       UPDATE: NOW GRAPHICS 1 MODE HAS ITS OWN CHAR SET
  26+ 426E
  27+ 426E              CHRST68 equ $
  28+ 426E 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  28+ 4272 00 00 00 00
  29+ 4276 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  29+ 427A 00 00 00 00
  30+ 427E 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  30+ 4282 00 00 00 00
  31+ 4286 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  31+ 428A 00 00 00 00
  32+ 428E 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  32+ 4292 00 00 00 00
  33+ 4296 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  33+ 429A 00 00 00 00
  34+ 429E 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  34+ 42A2 00 00 00 00
  35+ 42A6 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  35+ 42AA 00 00 00 00
  36+ 42AE 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
  36+ 42B2 00 00 00 00
  37+ 42B6 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  37+ 42BA 00 00 00 00
  38+ 42BE 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  38+ 42C2 00 00 00 00
  39+ 42C6 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11
  39+ 42CA 00 00 00 00
  40+ 42CE 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  40+ 42D2 00 00 00 00
  41+ 42D6 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
  41+ 42DA 00 00 00 00
  42+ 42DE 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
  42+ 42E2 00 00 00 00
  43+ 42E6 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  43+ 42EA 00 00 00 00
  44+ 42EE 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  44+ 42F2 00 00 00 00
  45+ 42F6 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  45+ 42FA 00 00 00 00
  46+ 42FE 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  46+ 4302 00 00 00 00
  47+ 4306 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  47+ 430A 00 00 00 00
  48+ 430E 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
  48+ 4312 00 00 00 00
  49+ 4316 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  49+ 431A 00 00 00 00
  50+ 431E 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
  50+ 4322 00 00 00 00
  51+ 4326 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
  51+ 432A 00 00 00 00
  52+ 432E 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
  52+ 4332 00 00 00 00
  53+ 4336 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
  53+ 433A 00 00 00 00
  54+ 433E 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
  54+ 4342 00 00 00 00
  55+ 4346 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
  55+ 434A 00 00 00 00
  56+ 434E 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
  56+ 4352 00 00 00 00
  57+ 4356 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
  57+ 435A 00 00 00 00
  58+ 435E 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
  58+ 4362 00 00 00 00
  59+ 4366 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
  59+ 436A 00 00 00 00
  60+ 436E 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32: space
  60+ 4372 00 00 00 00
  61+ 4376 20 20 20 20          defb $20,$20,$20,$20,$20,$00,$20,$00 ; char 33: !
  61+ 437A 20 00 20 00
  62+ 437E 50 50 00 00          defb $50,$50,$00,$00,$00,$00,$00,$00 ; char 34: "
  62+ 4382 00 00 00 00
  63+ 4386 50 50 F8 50          defb $50,$50,$f8,$50,$f8,$50,$50,$00 ; char 35: #
  63+ 438A F8 50 50 00
  64+ 438E 20 78 A0 70          defb $20,$78,$a0,$70,$28,$f0,$20,$00 ; char 36: $
  64+ 4392 28 F0 20 00
  65+ 4396 C0 C8 10 20          defb $c0,$c8,$10,$20,$40,$98,$18,$00 ; char 37: %
  65+ 439A 40 98 18 00
  66+ 439E 60 90 A0 40          defb $60,$90,$a0,$40,$a8,$90,$68,$00 ; char 38: &
  66+ 43A2 A8 90 68 00
  67+ 43A6 60 20 40 00          defb $60,$20,$40,$00,$00,$00,$00,$00 ; char 39: '
  67+ 43AA 00 00 00 00
  68+ 43AE 10 20 40 40          defb $10,$20,$40,$40,$40,$20,$10,$00 ; char 40: (
  68+ 43B2 40 20 10 00
  69+ 43B6 40 20 10 10          defb $40,$20,$10,$10,$10,$20,$40,$00 ; char 41: )
  69+ 43BA 10 20 40 00
  70+ 43BE 00 20 A8 70          defb $00,$20,$a8,$70,$a8,$20,$00,$00 ; char 42: *
  70+ 43C2 A8 20 00 00
  71+ 43C6 00 20 20 F8          defb $00,$20,$20,$f8,$20,$20,$00,$00 ; char 43: +
  71+ 43CA 20 20 00 00
  72+ 43CE 00 00 00 00          defb $00,$00,$00,$00,$60,$20,$40,$00 ; char 44: ,
  72+ 43D2 60 20 40 00
  73+ 43D6 00 00 00 F8          defb $00,$00,$00,$f8,$00,$00,$00,$00 ; char 45: -
  73+ 43DA 00 00 00 00
  74+ 43DE 00 00 00 00          defb $00,$00,$00,$00,$00,$60,$60,$00 ; char 46: .
  74+ 43E2 00 60 60 00
  75+ 43E6 00 08 10 20          defb $00,$08,$10,$20,$40,$80,$00,$00 ; char 47: /
  75+ 43EA 40 80 00 00
  76+ 43EE 70 88 98 A8          defb $70,$88,$98,$a8,$c8,$88,$70,$00 ; char 48: 0
  76+ 43F2 C8 88 70 00
  77+ 43F6 20 60 20 20          defb $20,$60,$20,$20,$20,$20,$70,$00 ; char 49: 1
  77+ 43FA 20 20 70 00
  78+ 43FE 70 88 08 10          defb $70,$88,$08,$10,$20,$40,$f8,$00 ; char 50: 2
  78+ 4402 20 40 F8 00
  79+ 4406 F8 10 20 10          defb $f8,$10,$20,$10,$08,$88,$70,$00 ; char 51: 3
  79+ 440A 08 88 70 00
  80+ 440E 10 30 50 90          defb $10,$30,$50,$90,$f8,$10,$10,$00 ; char 52: 4
  80+ 4412 F8 10 10 00
  81+ 4416 F8 80 F0 08          defb $f8,$80,$f0,$08,$08,$88,$70,$00 ; char 53: 5
  81+ 441A 08 88 70 00
  82+ 441E 30 40 80 F0          defb $30,$40,$80,$f0,$88,$88,$70,$00 ; char 54: 6
  82+ 4422 88 88 70 00
  83+ 4426 F8 08 10 20          defb $f8,$08,$10,$20,$40,$40,$40,$00 ; char 55: 7
  83+ 442A 40 40 40 00
  84+ 442E 70 88 88 70          defb $70,$88,$88,$70,$88,$88,$70,$00 ; char 56: 8
  84+ 4432 88 88 70 00
  85+ 4436 70 88 88 78          defb $70,$88,$88,$78,$08,$10,$60,$00 ; char 57: 9
  85+ 443A 08 10 60 00
  86+ 443E 00 30 30 00          defb $00,$30,$30,$00,$30,$30,$00,$00 ; char 58: :
  86+ 4442 30 30 00 00
  87+ 4446 00 30 30 00          defb $00,$30,$30,$00,$30,$10,$20,$00 ; char 59: ;
  87+ 444A 30 10 20 00
  88+ 444E 10 20 40 80          defb $10,$20,$40,$80,$40,$20,$10,$00 ; char 60: <
  88+ 4452 40 20 10 00
  89+ 4456 00 00 F8 00          defb $00,$00,$f8,$00,$f8,$00,$00,$00 ; char 61: =
  89+ 445A F8 00 00 00
  90+ 445E 40 20 10 08          defb $40,$20,$10,$08,$10,$20,$40,$00 ; char 62: >
  90+ 4462 10 20 40 00
  91+ 4466 70 88 08 10          defb $70,$88,$08,$10,$20,$00,$20,$00 ; char 63: ?
  91+ 446A 20 00 20 00
  92+ 446E 70 88 08 68          defb $70,$88,$08,$68,$a8,$a8,$70,$00 ; char 64: @
  92+ 4472 A8 A8 70 00
  93+ 4476 70 88 88 88          defb $70,$88,$88,$88,$f8,$88,$88,$00 ; char 65: A
  93+ 447A F8 88 88 00
  94+ 447E F0 88 88 F0          defb $f0,$88,$88,$f0,$88,$88,$f0,$00 ; char 66: B
  94+ 4482 88 88 F0 00
  95+ 4486 70 88 80 80          defb $70,$88,$80,$80,$80,$88,$70,$00 ; char 67: C
  95+ 448A 80 88 70 00
  96+ 448E E0 90 88 88          defb $e0,$90,$88,$88,$88,$90,$e0,$00 ; char 68: D
  96+ 4492 88 90 E0 00
  97+ 4496 F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$f8,$00 ; char 69: E
  97+ 449A 80 80 F8 00
  98+ 449E F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$80,$00 ; char 70: F
  98+ 44A2 80 80 80 00
  99+ 44A6 70 88 80 B8          defb $70,$88,$80,$b8,$88,$88,$78,$00 ; char 71: G
  99+ 44AA 88 88 78 00
 100+ 44AE 88 88 88 F8          defb $88,$88,$88,$f8,$88,$88,$88,$00 ; char 72: H
 100+ 44B2 88 88 88 00
 101+ 44B6 70 20 20 20          defb $70,$20,$20,$20,$20,$20,$70,$00 ; char 73: I
 101+ 44BA 20 20 70 00
 102+ 44BE 38 10 10 10          defb $38,$10,$10,$10,$10,$90,$60,$00 ; char 74: J
 102+ 44C2 10 90 60 00
 103+ 44C6 88 90 A0 C0          defb $88,$90,$a0,$c0,$a0,$90,$88,$00 ; char 75: K
 103+ 44CA A0 90 88 00
 104+ 44CE 80 80 80 80          defb $80,$80,$80,$80,$80,$80,$f8,$00 ; char 76: L
 104+ 44D2 80 80 F8 00
 105+ 44D6 88 D8 A8 A8          defb $88,$d8,$a8,$a8,$88,$88,$88,$00 ; char 77: M
 105+ 44DA 88 88 88 00
 106+ 44DE 88 C8 A8 98          defb $88,$c8,$a8,$98,$88,$88,$88,$00 ; char 78: N
 106+ 44E2 88 88 88 00
 107+ 44E6 70 88 88 88          defb $70,$88,$88,$88,$88,$88,$70,$00 ; char 79: O
 107+ 44EA 88 88 70 00
 108+ 44EE F0 88 88 F0          defb $f0,$88,$88,$f0,$80,$80,$80,$00 ; char 80: P
 108+ 44F2 80 80 80 00
 109+ 44F6 70 88 88 88          defb $70,$88,$88,$88,$a8,$90,$68,$00 ; char 81: Q
 109+ 44FA A8 90 68 00
 110+ 44FE F0 88 88 F0          defb $f0,$88,$88,$f0,$a0,$90,$88,$00 ; char 82: R
 110+ 4502 A0 90 88 00
 111+ 4506 78 80 80 70          defb $78,$80,$80,$70,$08,$08,$f0,$00 ; char 83: S
 111+ 450A 08 08 F0 00
 112+ 450E F8 20 20 20          defb $f8,$20,$20,$20,$20,$20,$20,$00 ; char 84: T
 112+ 4512 20 20 20 00
 113+ 4516 88 88 88 88          defb $88,$88,$88,$88,$88,$88,$70,$00 ; char 85: U
 113+ 451A 88 88 70 00
 114+ 451E 88 88 88 88          defb $88,$88,$88,$88,$88,$50,$20,$00 ; char 86: V
 114+ 4522 88 50 20 00
 115+ 4526 88 88 88 88          defb $88,$88,$88,$88,$a8,$a8,$50,$00 ; char 87: W
 115+ 452A A8 A8 50 00
 116+ 452E 88 88 50 20          defb $88,$88,$50,$20,$50,$88,$88,$00 ; char 88: X
 116+ 4532 50 88 88 00
 117+ 4536 88 88 88 50          defb $88,$88,$88,$50,$20,$20,$20,$00 ; char 89: Y
 117+ 453A 20 20 20 00
 118+ 453E F8 08 10 20          defb $f8,$08,$10,$20,$40,$80,$f8,$00 ; char 90: Z
 118+ 4542 40 80 F8 00
 119+ 4546 70 40 40 40          defb $70,$40,$40,$40,$40,$40,$70,$00 ; char 91: [
 119+ 454A 40 40 70 00
 120+ 454E 00 80 40 20          defb $00,$80,$40,$20,$10,$08,$00,$00 ; char 92: \
 120+ 4552 10 08 00 00
 121+ 4556 70 10 10 10          defb $70,$10,$10,$10,$10,$10,$70,$00 ; char 93: ]
 121+ 455A 10 10 70 00
 122+ 455E 20 50 88 00          defb $20,$50,$88,$00,$00,$00,$00,$00 ; char 94: ^
 122+ 4562 00 00 00 00
 123+ 4566 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$FC ; char 95: _ (underscore)
 123+ 456A 00 00 00 FC
 124+ 456E 40 20 10 00          defb $40,$20,$10,$00,$00,$00,$00,$00 ; char 96: `
 124+ 4572 00 00 00 00
 125+ 4576 00 00 70 08          defb $00,$00,$70,$08,$78,$88,$78,$00 ; char 97: a
 125+ 457A 78 88 78 00
 126+ 457E 80 80 80 B0          defb $80,$80,$80,$b0,$c8,$88,$f0,$00 ; char 98: b
 126+ 4582 C8 88 F0 00
 127+ 4586 00 00 70 80          defb $00,$00,$70,$80,$80,$88,$70,$00 ; char 99: c
 127+ 458A 80 88 70 00
 128+ 458E 08 08 08 68          defb $08,$08,$08,$68,$98,$88,$78,$00 ; char 100: d
 128+ 4592 98 88 78 00
 129+ 4596 00 00 70 88          defb $00,$00,$70,$88,$f8,$80,$70,$00 ; char 101: e
 129+ 459A F8 80 70 00
 130+ 459E 30 48 40 E0          defb $30,$48,$40,$e0,$40,$40,$40,$00 ; char 102: f
 130+ 45A2 40 40 40 00
 131+ 45A6 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$70,$00 ; char 103: g
 131+ 45AA 78 08 70 00
 132+ 45AE 80 80 B0 C8          defb $80,$80,$b0,$c8,$88,$88,$88,$00 ; char 104: h
 132+ 45B2 88 88 88 00
 133+ 45B6 20 00 20 20          defb $20,$00,$20,$20,$20,$20,$20,$00 ; char 105: i
 133+ 45BA 20 20 20 00
 134+ 45BE 08 00 18 08          defb $08,$00,$18,$08,$08,$88,$70,$00 ; char 106: j
 134+ 45C2 08 88 70 00
 135+ 45C6 80 80 90 A0          defb $80,$80,$90,$a0,$c0,$a0,$90,$00 ; char 107: k
 135+ 45CA C0 A0 90 00
 136+ 45CE 60 20 20 20          defb $60,$20,$20,$20,$20,$20,$70,$00 ; char 108: l
 136+ 45D2 20 20 70 00
 137+ 45D6 00 00 D0 A8          defb $00,$00,$d0,$a8,$a8,$88,$88,$00 ; char 109: m
 137+ 45DA A8 88 88 00
 138+ 45DE 00 00 B0 C8          defb $00,$00,$b0,$c8,$88,$88,$88,$00 ; char 110: n
 138+ 45E2 88 88 88 00
 139+ 45E6 00 00 70 88          defb $00,$00,$70,$88,$88,$88,$70,$00 ; char 111: o
 139+ 45EA 88 88 70 00
 140+ 45EE 00 00 F0 88          defb $00,$00,$f0,$88,$f0,$80,$80,$00 ; char 112: p
 140+ 45F2 F0 80 80 00
 141+ 45F6 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$08,$00 ; char 113: q
 141+ 45FA 78 08 08 00
 142+ 45FE 00 00 B0 C8          defb $00,$00,$b0,$c8,$80,$80,$80,$00 ; char 114: r
 142+ 4602 80 80 80 00
 143+ 4606 00 00 70 80          defb $00,$00,$70,$80,$70,$08,$f0,$00 ; char 115: s
 143+ 460A 70 08 F0 00
 144+ 460E 40 40 E0 40          defb $40,$40,$e0,$40,$40,$48,$30,$00 ; char 116: t
 144+ 4612 40 48 30 00
 145+ 4616 00 00 88 88          defb $00,$00,$88,$88,$88,$98,$68,$00 ; char 117: u
 145+ 461A 88 98 68 00
 146+ 461E 00 00 88 88          defb $00,$00,$88,$88,$88,$50,$20,$00 ; char 118: v
 146+ 4622 88 50 20 00
 147+ 4626 00 00 88 88          defb $00,$00,$88,$88,$a8,$a8,$50,$00 ; char 119: w
 147+ 462A A8 A8 50 00
 148+ 462E 00 00 88 50          defb $00,$00,$88,$50,$20,$50,$88,$00 ; char 120: x
 148+ 4632 20 50 88 00
 149+ 4636 00 00 88 98          defb $00,$00,$88,$98,$68,$08,$70,$00 ; char 121: y
 149+ 463A 68 08 70 00
 150+ 463E 00 00 F8 10          defb $00,$00,$f8,$10,$20,$40,$f8,$00 ; char 122: z
 150+ 4642 20 40 F8 00
 151+ 4646 10 20 20 40          defb $10,$20,$20,$40,$20,$20,$10,$00 ; char 123: {
 151+ 464A 20 20 10 00
 152+ 464E 20 20 20 20          defb $20,$20,$20,$20,$20,$20,$20,$00 ; char 124: |
 152+ 4652 20 20 20 00
 153+ 4656 20 10 10 08          defb $20,$10,$10,$08,$10,$10,$20,$00 ; char 125: }
 153+ 465A 10 10 20 00
 154+ 465E 00 28 50 00          defb $00,$28,$50,$00,$00,$00,$00,$00 ; char 126: ~
 154+ 4662 00 00 00 00
 155+ 4666 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 127: (delete) - here end the standard ASCII (0-127)
 155+ 466A 00 00 00 00
 156+ 466E 78 84 CC 84          defb %01111000,%10000100,%11001100,%10000100,%10110100,%10000100,%01111000,%00000000 ; char 128 (open face)
 156+ 4672 B4 84 78 00
 157+ 4676 78 FC B4 FC          defb %01111000,%11111100,%10110100,%11111100,%10110100,%11001100,%01111000,%00000000 ; char 129 (full face)
 157+ 467A B4 CC 78 00
 158+ 467E 48 FC FC FC          defb %01001000,%11111100,%11111100,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 130 (hearts)
 158+ 4682 FC 78 30 00
 159+ 4686 00 20 70 F8          defb %00000000,%00100000,%01110000,%11111000,%11111000,%01110000,%00100000,%00000000 ; char 131 (diamonds)
 159+ 468A F8 70 20 00
 160+ 468E 70 20 A8 F8          defb %01110000,%00100000,%10101000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 132 (clubs)
 160+ 4692 A8 20 70 00
 161+ 4696 20 70 F8 F8          defb %00100000,%01110000,%11111000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 133 (spades)
 161+ 469A A8 20 70 00
 162+ 469E 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 134
 162+ 46A2 FC 30 30 30
 163+ 46A6 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 135
 163+ 46AA 3C 30 30 30
 164+ 46AE 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 136
 164+ 46B2 F0 30 30 30
 165+ 46B6 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00000000,%00000000,%00000000 ; char 137
 165+ 46BA F0 00 00 00
 166+ 46BE 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00000000,%00000000,%00000000 ; char 138
 166+ 46C2 3C 00 00 00
 167+ 46C6 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 139
 167+ 46CA FC 00 00 00
 168+ 46CE 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 140
 168+ 46D2 3C 30 30 30
 169+ 46D6 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 141
 169+ 46DA FC 30 30 30
 170+ 46DE 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 142
 170+ 46E2 F0 30 30 30
 171+ 46E6 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 143
 171+ 46EA FC 00 00 00
 172+ 46EE 30 30 30 30          defb %00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000 ; char 144
 172+ 46F2 30 30 30 30
 173+ 46F6 0C 1C 18 38          defb %00001100,%00011100,%00011000,%00111000,%01110000,%01100000,%11100000,%11000000 ; char 145
 173+ 46FA 70 60 E0 C0
 174+ 46FE C0 E0 60 70          defb %11000000,%11100000,%01100000,%01110000,%00111000,%00011000,%00011100,%00001100 ; char 146
 174+ 4702 38 18 1C 0C
 175+ 4706 CC CC 78 30          defb %11001100,%11001100,%01111000,%00110000,%00110000,%01111000,%11001100,%11001100 ; char 147
 175+ 470A 30 78 CC CC
 176+ 470E 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 148
 176+ 4712 20 20 20 20
 177+ 4716 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 149
 177+ 471A 20 20 20 20
 178+ 471E 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 150
 178+ 4722 20 20 20 20
 179+ 4726 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 151
 179+ 472A 00 00 00 00
 180+ 472E 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00000000,%00000000,%00000000,%00000000 ; char 152
 180+ 4732 00 00 00 00
 181+ 4736 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 153
 181+ 473A 00 00 00 00
 182+ 473E 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 154
 182+ 4742 20 20 20 20
 183+ 4746 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 155
 183+ 474A 20 20 20 20
 184+ 474E 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 156
 184+ 4752 20 20 20 20
 185+ 4756 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 157
 185+ 475A 00 00 00 00
 186+ 475E 20 20 20 20          defb %00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000 ; char 158
 186+ 4762 20 20 20 20
 187+ 4766 04 08 08 10          defb %00000100,%00001000,%00001000,%00010000,%00100000,%01000000,%01000000,%10000000 ; char 159
 187+ 476A 20 40 40 80
 188+ 476E 80 40 40 20          defb %10000000,%01000000,%01000000,%00100000,%00010000,%00001000,%00001000,%00000100 ; char 160
 188+ 4772 10 08 08 04
 189+ 4776 84 48 48 30          defb %10000100,%01001000,%01001000,%00110000,%00110000,%01001000,%01001000,%10000100 ; char 161
 189+ 477A 30 48 48 84
 190+ 477E 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 162
 190+ 4782 00 00 FC FC
 191+ 4786 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111100,%11111100,%11111100,%11111100 ; char 163
 191+ 478A FC FC FC FC
 192+ 478E 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 164
 192+ 4792 FC FC FC FC
 193+ 4796 FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 193+ 479A 00 00 00 00
 194+ 479E FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 166
 194+ 47A2 00 00 00 00
 195+ 47A6 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 167
 195+ 47AA FC FC 00 00
 196+ 47AE 80 80 80 80          defb %10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000 ; char 168
 196+ 47B2 80 80 80 80
 197+ 47B6 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000 ; char 169
 197+ 47BA E0 E0 E0 E0
 198+ 47BE F8 F8 F8 F8          defb %11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000 ; char 170
 198+ 47C2 F8 F8 F8 F8
 199+ 47C6 04 04 04 04          defb %00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100 ; char 171
 199+ 47CA 04 04 04 04
 200+ 47CE 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100 ; char 172
 200+ 47D2 1C 1C 1C 1C
 201+ 47D6 7C 7C 7C 7C          defb %01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100 ; char 173
 201+ 47DA 7C 7C 7C 7C
 202+ 47DE FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 174
 202+ 47E2 84 84 84 FC
 203+ 47E6 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%11100000,%11100000,%11100000 ; char 175
 203+ 47EA E0 E0 E0 E0
 204+ 47EE 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00011100,%00011100,%00011100 ; char 176
 204+ 47F2 1C 1C 1C 1C
 205+ 47F6 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 177
 205+ 47FA 00 00 00 00
 206+ 47FE E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 178
 206+ 4802 00 00 00 00
 207+ 4806 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00011100,%00011100,%00011100,%00011100 ; char 179
 207+ 480A 1C 1C 1C 1C
 208+ 480E 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%11100000,%11100000,%11100000,%11100000 ; char 180
 208+ 4812 E0 E0 E0 E0
 209+ 4816 78 78 78 78          defb %01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000 ; char 181
 209+ 481A 78 78 78 78
 210+ 481E CC CC CC CC          defb %11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100 ; char 182
 210+ 4822 CC CC CC CC
 211+ 4826 FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 183
 211+ 482A 00 00 FC FC
 212+ 482E 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 184
 212+ 4832 FC FC 00 00
 213+ 4836 30 30 CC CC          defb %00110000,%00110000,%11001100,%11001100,%00110000,%00110000,%11001100,%11001100 ; char 185
 213+ 483A 30 30 CC CC
 214+ 483E 54 A8 54 A8          defb %01010100,%10101000,%01010100,%10101000,%01010100,%10101000,%01010100,%10101000 ; char 186
 214+ 4842 54 A8 54 A8
 215+ 4846 64 30 98 CC          defb %01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100 ; char 187
 215+ 484A 64 30 98 CC
 216+ 484E CC 64 30 98          defb %11001100,%01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000 ; char 188
 216+ 4852 CC 64 30 98
 217+ 4856 30 98 CC 64          defb %00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100,%01100100 ; char 189
 217+ 485A 30 98 CC 64
 218+ 485E 64 CC 98 30          defb %01100100,%11001100,%10011000,%00110000,%01100100,%11001100,%10011000,%00110000 ; char 190
 218+ 4862 64 CC 98 30
 219+ 4866 20 20 F8 20          defb %00100000,%00100000,%11111000,%00100000,%00100000,%00000000,%11111000,%00000000 ; char 191 (Â±)
 219+ 486A 20 00 F8 00
 220+ 486E C0 30 08 30          defb %11000000,%00110000,%00001000,%00110000,%11000000,%00000000,%11111000,%00000000 ; char 192 (â¥)
 220+ 4872 C0 00 F8 00
 221+ 4876 18 60 80 60          defb %00011000,%01100000,%10000000,%01100000,%00011000,%00000000,%11111000,%00000000 ; char 193 (â¤)
 221+ 487A 18 00 F8 00
 222+ 487E 3C 20 20 20          defb %00111100,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 222+ 4882 A0 60 20 00
 223+ 4886 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 223+ 488A 00 00 00 00
 224+ 488E 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 224+ 4892 70 00 00 00
 225+ 4896 00 00 54 A8          defb %00000000,%00000000,%01010100,%10101000,%00000000,%11111100,%00000000,%00000000 ; char 197
 225+ 489A 00 FC 00 00
 226+ 489E 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 226+ 48A2 54 A8 00 00
 227+ 48A6 00 80 C0 E0          defb %00000000,%10000000,%11000000,%11100000,%11100000,%11000000,%10000000,%00000000 ; char 199
 227+ 48AA E0 C0 80 00
 228+ 48AE FC 78 30 00          defb %11111100,%01111000,%00110000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 200
 228+ 48B2 00 00 00 00
 229+ 48B6 00 04 0C 1C          defb %00000000,%00000100,%00001100,%00011100,%00011100,%00001100,%00000100,%00000000 ; char 201
 229+ 48BA 1C 0C 04 00
 230+ 48BE 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00110000,%01111000,%11111100 ; char 202
 230+ 48C2 00 30 78 FC
 231+ 48C6 20 70 F8 20          defb %00100000,%01110000,%11111000,%00100000,%00100000,%00100000,%00100000,%00000000 ; char 203 (up arrow)
 231+ 48CA 20 20 20 00
 232+ 48CE 3C 1C 1C 24          defb %00111100,%00011100,%00011100,%00100100,%01000000,%10000000,%00000000,%00000000 ; char 204 (up right arrow)
 232+ 48D2 40 80 00 00
 233+ 48D6 00 10 18 FC          defb %00000000,%00010000,%00011000,%11111100,%00011000,%00010000,%00000000,%00000000 ; char 205 (right arrow)
 233+ 48DA 18 10 00 00
 234+ 48DE 00 00 80 40          defb %00000000,%00000000,%10000000,%01000000,%00100100,%00011100,%00011100,%00111100 ; char 206 (down right arrow)
 234+ 48E2 24 1C 1C 3C
 235+ 48E6 00 20 20 20          defb %00000000,%00100000,%00100000,%00100000,%00100000,%11111000,%01110000,%00100000 ; char 207 (down arrow)
 235+ 48EA 20 F8 70 20
 236+ 48EE 00 00 04 08          defb %00000000,%00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000 ; char 208 (down left arrow)
 236+ 48F2 90 E0 E0 F0
 237+ 48F6 00 20 60 FC          defb %00000000,%00100000,%01100000,%11111100,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 237+ 48FA 60 20 00 00
 238+ 48FE F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 238+ 4902 08 04 00 00
 239+ 4906 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 239+ 490A F0 44 38 00
 240+ 490E 00 04 78 A8          defb %00000000,%00000100,%01111000,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 240+ 4912 28 28 28 00
 241+ 4916 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00100000,%00100000,%00100000 ; char 213
 241+ 491A 1C 20 20 20
 242+ 491E 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%00010000,%00010000,%00010000 ; char 214
 242+ 4922 E0 10 10 10
 243+ 4926 10 10 10 E0          defb %00010000,%00010000,%00010000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 215
 243+ 492A 00 00 00 00
 244+ 492E 20 20 20 1C          defb %00100000,%00100000,%00100000,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 216
 244+ 4932 00 00 00 00
 245+ 4936 00 00 00 1C          defb %00000000,%00000000,%00000000,%00011100,%00111100,%00110000,%00110000,%00110000 ; char 217
 245+ 493A 3C 30 30 30
 246+ 493E 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00110000,%00110000,%00110000 ; char 218
 246+ 4942 F0 30 30 30
 247+ 4946 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 247+ 494A E0 00 00 00
 248+ 494E 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00011100,%00000000,%00000000,%00000000 ; char 220
 248+ 4952 1C 00 00 00
 249+ 4956 00 30 48 48          defb %00000000,%00110000,%01001000,%01001000,%01001000,%00110000,%00000000,%00000000 ; char 221
 249+ 495A 48 30 00 00
 250+ 495E 00 30 78 78          defb %00000000,%00110000,%01111000,%01111000,%01111000,%00110000,%00000000,%00000000 ; char 222
 250+ 4962 78 30 00 00
 251+ 4966 00 30 78 FC          defb %00000000,%00110000,%01111000,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 223
 251+ 496A FC 78 30 00
 252+ 496E FC F8 F0 E0          defb %11111100,%11111000,%11110000,%11100000,%11100000,%11000000,%10000000,%10000000 ; char 224
 252+ 4972 E0 C0 80 80
 253+ 4976 FC 7C 3C 1C          defb %11111100,%01111100,%00111100,%00011100,%00011100,%00001100,%00000100,%00000100 ; char 225
 253+ 497A 1C 0C 04 04
 254+ 497E 04 04 0C 1C          defb %00000100,%00000100,%00001100,%00011100,%00011100,%00111100,%01111100,%11111100 ; char 226
 254+ 4982 1C 3C 7C FC
 255+ 4986 80 80 C0 E0          defb %10000000,%10000000,%11000000,%11100000,%11100000,%11110000,%11111000,%11111100 ; char 227
 255+ 498A E0 F0 F8 FC
 256+ 498E 00 04 0C D8          defb %00000000,%00000100,%00001100,%11011000,%11110000,%11100000,%11000000,%00000000 ; char 228 (checkmark)
 256+ 4992 F0 E0 C0 00
 257+ 4996 00 CC 78 30          defb %00000000,%11001100,%01111000,%00110000,%01111000,%11001100,%00000000,%00000000 ; char 229 (x)
 257+ 499A 78 CC 00 00
 258+ 499E 70 88 88 88          defb %01110000,%10001000,%10001000,%10001000,%01110000,%00100000,%01110000,%00100000 ; char 230 (female)
 258+ 49A2 70 20 70 20
 259+ 49A6 00 1C 0C 74          defb %00000000,%00011100,%00001100,%01110100,%10010000,%10010000,%01100000,%00000000 ; char 231 (male)
 259+ 49AA 90 90 60 00
 260+ 49AE F8 84 84 84          defb %11111000,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 232 (new doc)
 260+ 49B2 84 84 84 FC
 261+ 49B6 00 F0 FC 84          defb %00000000,%11110000,%11111100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 233 (folder)
 261+ 49BA 84 84 84 FC
 262+ 49BE 30 78 FC 48          defb %00110000,%01111000,%11111100,%01001000,%01001000,%01001000,%01001000,%01111000 ; char 234 (trash bin)
 262+ 49C2 48 48 48 78
 263+ 49C6 FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%11111100,%10110100,%10110100,%11111100 ; char 235 (floppy disk)
 263+ 49CA FC B4 B4 FC
 264+ 49CE 00 00 D4 D8          defb %00000000,%00000000,%11010100,%11011000,%11010100,%11010100,%00000000,%00000000 ; char 236 (OK)
 264+ 49D2 D4 D4 00 00
 265+ 49D6 30 78 FC 78          defb %00110000,%01111000,%11111100,%01111000,%01111000,%01001000,%01001000,%01001000 ; char 237 (home)
 265+ 49DA 78 48 48 48
 266+ 49DE 78 84 A4 A4          defb %01111000,%10000100,%10100100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 238 (clock)
 266+ 49E2 B4 84 78 00
 267+ 49E6 00 00 08 F4          defb %00000000,%00000000,%00001000,%11110100,%10101000,%10000000,%00000000,%00000000 ; char 239 (key)
 267+ 49EA A8 80 00 00
 268+ 49EE 20 30 78 B0          defb %00100000,%00110000,%01111000,%10110000,%10100000,%10001000,%01110000,%00000000 ; char 240 (undo)
 268+ 49F2 A0 88 70 00
 269+ 49F6 00 FC CC B4          defb %00000000,%11111100,%11001100,%10110100,%10000100,%10000100,%11111100,%00000000 ; char 241 (letter)
 269+ 49FA 84 84 FC 00
 270+ 49FE 60 90 90 F0          defb %01100000,%10010000,%10010000,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 242 (lock)
 270+ 4A02 F0 F0 F0 00
 271+ 4A06 08 14 14 F0          defb %00001000,%00010100,%00010100,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 243 (unlock)
 271+ 4A0A F0 F0 F0 00
 272+ 4A0E FC FC 84 B4          defb %11111100,%11111100,%10000100,%10110100,%10010100,%10010100,%10000100,%11111100 ; char 244 (calendar)
 272+ 4A12 94 94 84 FC
 273+ 4A16 00 04 38 58          defb %00000000,%00000100,%00111000,%01011000,%01101000,%01110000,%10000000,%00000000 ; char 245 (diameter)
 273+ 4A1A 68 70 80 00
 274+ 4A1E 78 84 84 84          defb %01111000,%10000100,%10000100,%10000100,%01101100,%00011000,%00001000,%00000000 ; char 246 (baloon)
 274+ 4A22 6C 18 08 00
 275+ 4A26 30 28 28 28          defb %00110000,%00101000,%00101000,%00101000,%00100000,%01100000,%11100000,%01000000 ; char 247 (note)
 275+ 4A2A 20 60 E0 40
 276+ 4A2E 20 68 E4 E4          defb %00100000,%01101000,%11100100,%11100100,%11100100,%01101000,%00100000,%00000000 ; char 248 (audio on)
 276+ 4A32 E4 68 20 00
 277+ 4A36 20 60 E0 E0          defb %00100000,%01100000,%11100000,%11100000,%11100000,%01100000,%00100000,%00000000 ; char 249 (audio off)
 277+ 4A3A E0 60 20 00
 278+ 4A3E 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11110000,%10010000 ; char 250 (pointer)
 278+ 4A42 F8 FC F0 90
 279+ 4A46 78 84 B4 A4          defb %01111000,%10000100,%10110100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 251 (Â©)
 279+ 4A4A B4 84 78 00
 280+ 4A4E 30 48 40 E0          defb %00110000,%01001000,%01000000,%11100000,%01000000,%01001000,%10110000,%00000000 ; char 252 (Â£)
 280+ 4A52 40 48 B0 00
 281+ 4A56 78 84 F0 48          defb %01111000,%10000100,%11110000,%01001000,%01001000,%00111100,%10000100,%01111000 ; char 253 (Â§)
 281+ 4A5A 48 3C 84 78
 282+ 4A5E 00 00 20 00          defb %00000000,%00000000,%00100000,%00000000,%11111000,%00000000,%00100000,%00000000 ; char 254 (Ã·)
 282+ 4A62 F8 00 20 00
 283+ 4A66 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 255 (cursor)
 283+ 4A6A FC FC FC FC
 284+ 4A6E                      ; here ends the ASCII table
 285+ 4A6E
# file closed: ../include/vdp/6x8fonts-r16.asm
  82  4A6E                  INCLUDE "../include/vdp/8x8fonts-r18.asm"
# file opened: ../include/vdp/8x8fonts-r18.asm
   1+ 4A6E              ; ------------------------------------------------------------------------------
   2+ 4A6E              ; LM80C - 8x8 CHARSET - R1.8
   3+ 4A6E              ; ------------------------------------------------------------------------------
   4+ 4A6E              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4A6E              ; designed by Leonardo Miliani. More info at
   6+ 4A6E              ; www DOT leonardomiliani DOT com
   7+ 4A6E              ; ------------------------------------------------------------------------------
   8+ 4A6E              ; Code Revision:
   9+ 4A6E              ; R1.0 - 20190615 - First revision: ASCII chars (from 0 to 255) - actually, they are 6x8 pixels
  10+ 4A6E              ; R1.1 - 20190616 - Converted to 8x8 pixels
  11+ 4A6E              ; R1.2 - 20191013 - Added new graphic chars and reorganized previous ones
  12+ 4A6E              ; R1.3 - 20191015 - More graphic chars
  13+ 4A6E              ; R1.4 - 20191202 - Fixed char 11/12, added new special chars
  14+ 4A6E              ; R1.5 - 20191210 - Changed several graphic chars
  15+ 4A6E              ; R1.6 - 20200125 - Removed double chars, changed with new ones
  16+ 4A6E              ; R1.7 - 20200228 - adopted more usual hexadecimal & binary prefixes
  17+ 4A6E              ; R1.8 - 20200524 - New style for char #252
  18+ 4A6E              ; ------------------------------------------------------------------------------
  19+ 4A6E              ;
  20+ 4A6E              ;-------------------------------------------------------------------------------
  21+ 4A6E              ;
  22+ 4A6E              ;               8 x 8    C  H  A  R  S  E  T
  23+ 4A6E              ;
  24+ 4A6E              ;-------------------------------------------------------------------------------
  25+ 4A6E              ;
  26+ 4A6E              ;       8X8 CHARS, DESIGNED FOR GRAPHICS 1 MODE
  27+ 4A6E
  28+ 4A6E              CHRST88 equ $
  29+ 4A6E 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  29+ 4A72 00 00 00 00
  30+ 4A76 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  30+ 4A7A 00 00 00 00
  31+ 4A7E 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  31+ 4A82 00 00 00 00
  32+ 4A86 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  32+ 4A8A 00 00 00 00
  33+ 4A8E 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  33+ 4A92 00 00 00 00
  34+ 4A96 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  34+ 4A9A 00 00 00 00
  35+ 4A9E 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  35+ 4AA2 00 00 00 00
  36+ 4AA6 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  36+ 4AAA 00 00 00 00
  37+ 4AAE 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 DEL key (backspace)
  37+ 4AB2 00 00 00 00
  38+ 4AB6 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  38+ 4ABA 00 00 00 00
  39+ 4ABE 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  39+ 4AC2 00 00 00 00
  40+ 4AC6 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 (unused)
  40+ 4ACA 00 00 00 00
  41+ 4ACE 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  41+ 4AD2 00 00 00 00
  42+ 4AD6 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 RETURN key (carriage return)
  42+ 4ADA 00 00 00 00
  43+ 4ADE 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL key
  43+ 4AE2 00 00 00 00
  44+ 4AE6 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  44+ 4AEA 00 00 00 00
  45+ 4AEE 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  45+ 4AF2 00 00 00 00
  46+ 4AF6 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  46+ 4AFA 00 00 00 00
  47+ 4AFE 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  47+ 4B02 00 00 00 00
  48+ 4B06 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  48+ 4B0A 00 00 00 00
  49+ 4B0E 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT key
  49+ 4B12 00 00 00 00
  50+ 4B16 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  50+ 4B1A 00 00 00 00
  51+ 4B1E 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6 key
  51+ 4B22 00 00 00 00
  52+ 4B26 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7 key
  52+ 4B2A 00 00 00 00
  53+ 4B2E 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP key
  53+ 4B32 00 00 00 00
  54+ 4B36 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 HOME key
  54+ 4B3A 00 00 00 00
  55+ 4B3E 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26 INSERT key
  55+ 4B42 00 00 00 00
  56+ 4B46 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 ESCAPE key
  56+ 4B4A 00 00 00 00
  57+ 4B4E 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 CRSR LEFT key (cursor left)
  57+ 4B52 00 00 00 00
  58+ 4B56 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 CRSR RIGHT key (cursor right)
  58+ 4B5A 00 00 00 00
  59+ 4B5E 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 CRSR UP key (cursor up)
  59+ 4B62 00 00 00 00
  60+ 4B66 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 CRSR DOWN key (cursor down)
  60+ 4B6A 00 00 00 00
  61+ 4B6E 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32 SPACE key
  61+ 4B72 00 00 00 00
  62+ 4B76 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00000000,%00010000,%00000000 ; char 33 - !
  62+ 4B7A 10 00 10 00
  63+ 4B7E 28 28 28 00          defb %00101000,%00101000,%00101000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 34 - "
  63+ 4B82 00 00 00 00
  64+ 4B86 28 28 FE 28          defb %00101000,%00101000,%11111110,%00101000,%11111110,%00101000,%00101000,%00000000 ; char 35 - #
  64+ 4B8A FE 28 28 00
  65+ 4B8E 10 3C 50 38          defb %00010000,%00111100,%01010000,%00111000,%00010100,%01111000,%00010000,%00000000 ; char 36 - $
  65+ 4B92 14 78 10 00
  66+ 4B96 00 62 64 08          defb %00000000,%01100010,%01100100,%00001000,%00010000,%00100110,%01000110,%00000000 ; char 37 - %
  66+ 4B9A 10 26 46 00
  67+ 4B9E 00 30 48 30          defb %00000000,%00110000,%01001000,%00110000,%01001010,%01000100,%00111010,%00000000 ; char 38 - &
  67+ 4BA2 4A 44 3A 00
  68+ 4BA6 08 10 20 00          defb %00001000,%00010000,%00100000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 39 - '
  68+ 4BAA 00 00 00 00
  69+ 4BAE 08 10 20 20          defb %00001000,%00010000,%00100000,%00100000,%00100000,%00010000,%00001000,%00000000 ; char 40 - (
  69+ 4BB2 20 10 08 00
  70+ 4BB6 20 10 08 08          defb %00100000,%00010000,%00001000,%00001000,%00001000,%00010000,%00100000,%00000000 ; char 41 - )
  70+ 4BBA 08 10 20 00
  71+ 4BBE 00 10 54 38          defb %00000000,%00010000,%01010100,%00111000,%00111000,%01010100,%00010000,%00000000 ; char 42 - *
  71+ 4BC2 38 54 10 00
  72+ 4BC6 00 10 10 7C          defb %00000000,%00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%00000000 ; char 43 - +
  72+ 4BCA 10 10 00 00
  73+ 4BCE 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00001000,%00010000 ; char 44 - ,
  73+ 4BD2 00 18 08 10
  74+ 4BD6 00 00 00 7C          defb %00000000,%00000000,%00000000,%01111100,%00000000,%00000000,%00000000,%00000000 ; char 45 - -
  74+ 4BDA 00 00 00 00
  75+ 4BDE 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00011000,%00000000 ; char 46 - .
  75+ 4BE2 00 18 18 00
  76+ 4BE6 00 02 04 08          defb %00000000,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%00000000 ; char 47 - /
  76+ 4BEA 10 20 40 00
  77+ 4BEE 38 44 4C 54          defb %00111000,%01000100,%01001100,%01010100,%01100100,%01000100,%00111000,%00000000 ; char 48 - 0
  77+ 4BF2 64 44 38 00
  78+ 4BF6 10 30 50 10          defb %00010000,%00110000,%01010000,%00010000,%00010000,%00010000,%01111100,%00000000 ; char 49 - 1
  78+ 4BFA 10 10 7C 00
  79+ 4BFE 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 50 - 2
  79+ 4C02 10 20 7C 00
  80+ 4C06 7C 08 10 08          defb %01111100,%00001000,%00010000,%00001000,%00000100,%01000100,%00111000,%00000000 ; char 51 - 3
  80+ 4C0A 04 44 38 00
  81+ 4C0E 08 18 28 48          defb %00001000,%00011000,%00101000,%01001000,%01111100,%00001000,%00001000,%00000000 ; char 52 - 4
  81+ 4C12 7C 08 08 00
  82+ 4C16 7C 40 78 04          defb %01111100,%01000000,%01111000,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 53 - 5
  82+ 4C1A 04 44 38 00
  83+ 4C1E 38 44 40 78          defb %00111000,%01000100,%01000000,%01111000,%01000100,%01000100,%00111000,%00000000 ; char 54 - 6
  83+ 4C22 44 44 38 00
  84+ 4C26 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%00100000,%00100000,%00000000 ; char 55 - 7
  84+ 4C2A 20 20 20 00
  85+ 4C2E 38 44 44 38          defb %00111000,%01000100,%01000100,%00111000,%01000100,%01000100,%00111000,%00000000 ; char 56 - 8
  85+ 4C32 44 44 38 00
  86+ 4C36 38 44 44 3C          defb %00111000,%01000100,%01000100,%00111100,%00000100,%01000100,%00111000,%00000000 ; char 57 - 9
  86+ 4C3A 04 44 38 00
  87+ 4C3E 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00011000,%00000000,%00000000 ; char 58 - :
  87+ 4C42 18 18 00 00
  88+ 4C46 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00001000,%00010000,%00000000 ; char 59 - ;
  88+ 4C4A 18 08 10 00
  89+ 4C4E 04 08 10 20          defb %00000100,%00001000,%00010000,%00100000,%00010000,%00001000,%00000100,%00000000 ; char 60 - <
  89+ 4C52 10 08 04 00
  90+ 4C56 00 00 7E 00          defb %00000000,%00000000,%01111110,%00000000,%01111110,%00000000,%00000000,%00000000 ; char 61 - =
  90+ 4C5A 7E 00 00 00
  91+ 4C5E 20 10 08 04          defb %00100000,%00010000,%00001000,%00000100,%00001000,%00010000,%00100000,%00000000 ; char 62 - >
  91+ 4C62 08 10 20 00
  92+ 4C66 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00000000,%00010000,%00000000 ; char 63 - ?
  92+ 4C6A 10 00 10 00
  93+ 4C6E 78 84 BC AC          defb %01111000,%10000100,%10111100,%10101100,%10111000,%10000000,%10000100,%01111000 ; char 64 - @
  93+ 4C72 B8 80 84 78
  94+ 4C76 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%00000000 ; char 65 - A
  94+ 4C7A 7C 44 44 00
  95+ 4C7E 78 44 44 78          defb %01111000,%01000100,%01000100,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 66 - B
  95+ 4C82 44 44 78 00
  96+ 4C86 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 67 - C
  96+ 4C8A 40 44 38 00
  97+ 4C8E 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01000100,%01000100,%01111000,%00000000 ; char 68 - D
  97+ 4C92 44 44 78 00
  98+ 4C96 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01111100,%00000000 ; char 69 - E
  98+ 4C9A 40 40 7C 00
  99+ 4C9E 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01000000,%00000000 ; char 70 - F
  99+ 4CA2 40 40 40 00
 100+ 4CA6 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01011100,%01000100,%00111000,%00000000 ; char 71 - G
 100+ 4CAA 5C 44 38 00
 101+ 4CAE 44 44 44 7C          defb %01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%01000100,%00000000 ; char 72 - H
 101+ 4CB2 44 44 44 00
 102+ 4CB6 38 10 10 10          defb %00111000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 73 - I
 102+ 4CBA 10 10 38 00
 103+ 4CBE 3C 04 04 04          defb %00111100,%00000100,%00000100,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 74 - J
 103+ 4CC2 04 44 38 00
 104+ 4CC6 44 44 48 70          defb %01000100,%01000100,%01001000,%01110000,%01001000,%01000100,%01000100,%00000000 ; char 75 - K
 104+ 4CCA 48 44 44 00
 105+ 4CCE 40 40 40 40          defb %01000000,%01000000,%01000000,%01000000,%01000000,%01000000,%01111100,%00000000 ; char 76 - L
 105+ 4CD2 40 40 7C 00
 106+ 4CD6 42 66 5A 42          defb %01000010,%01100110,%01011010,%01000010,%01000010,%01000010,%01000010,%00000000 ; char 77 - M
 106+ 4CDA 42 42 42 00
 107+ 4CDE 44 64 54 4C          defb %01000100,%01100100,%01010100,%01001100,%01000100,%01000100,%01000100,%00000000 ; char 78 - N
 107+ 4CE2 44 44 44 00
 108+ 4CE6 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 79 - O
 108+ 4CEA 44 44 38 00
 109+ 4CEE 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01000000,%01000000,%00000000 ; char 80 - P
 109+ 4CF2 78 40 40 00
 110+ 4CF6 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01010100,%01001000,%00110100,%00000000 ; char 81 - Q
 110+ 4CFA 54 48 34 00
 111+ 4CFE 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01001000,%01000100,%00000000 ; char 82 - R
 111+ 4D02 78 48 44 00
 112+ 4D06 3C 40 40 38          defb %00111100,%01000000,%01000000,%00111000,%00000100,%00000100,%01111000,%00000000 ; char 83 - S
 112+ 4D0A 04 04 78 00
 113+ 4D0E 7C 10 10 10          defb %01111100,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 84 - T
 113+ 4D12 10 10 10 00
 114+ 4D16 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 85 - U
 114+ 4D1A 44 44 38 00
 115+ 4D1E 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 86 - V
 115+ 4D22 44 28 10 00
 116+ 4D26 42 42 42 42          defb %01000010,%01000010,%01000010,%01000010,%01011010,%01011010,%00100100,%00000000 ; char 87 - W
 116+ 4D2A 5A 5A 24 00
 117+ 4D2E 44 44 28 10          defb %01000100,%01000100,%00101000,%00010000,%00101000,%01000100,%01000100,%00000000 ; char 88 - X
 117+ 4D32 28 44 44 00
 118+ 4D36 44 44 44 28          defb %01000100,%01000100,%01000100,%00101000,%00010000,%00010000,%00010000,%00000000 ; char 89 - Y
 118+ 4D3A 10 10 10 00
 119+ 4D3E 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%01000000,%01111100,%00000000 ; char 90 - Z
 119+ 4D42 20 40 7C 00
 120+ 4D46 38 20 20 20          defb %00111000,%00100000,%00100000,%00100000,%00100000,%00100000,%00111000,%00000000 ; char 91 - [
 120+ 4D4A 20 20 38 00
 121+ 4D4E 00 40 20 10          defb %00000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000000 ; char 92 - \
 121+ 4D52 08 04 02 00
 122+ 4D56 38 08 08 08          defb %00111000,%00001000,%00001000,%00001000,%00001000,%00001000,%00111000,%00000000 ; char 93 - ]
 122+ 4D5A 08 08 38 00
 123+ 4D5E 10 28 44 00          defb %00010000,%00101000,%01000100,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 94 - ^
 123+ 4D62 00 00 00 00
 124+ 4D66 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%01111110,%00000000 ; char 95 _ (underscore)
 124+ 4D6A 00 00 7E 00
 125+ 4D6E 20 10 08 00          defb %00100000,%00010000,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 96 - `
 125+ 4D72 00 00 00 00
 126+ 4D76 00 00 38 04          defb %00000000,%00000000,%00111000,%00000100,%00111100,%01000100,%00111100,%00000000 ; char 97 - a
 126+ 4D7A 3C 44 3C 00
 127+ 4D7E 40 40 40 78          defb %01000000,%01000000,%01000000,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 98 - b
 127+ 4D82 44 44 78 00
 128+ 4D86 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 99 - c
 128+ 4D8A 40 44 38 00
 129+ 4D8E 04 04 04 3C          defb %00000100,%00000100,%00000100,%00111100,%01000100,%01000100,%00111100,%00000000 ; char 100 - d
 129+ 4D92 44 44 3C 00
 130+ 4D96 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01111100,%01000000,%00111000,%00000000 ; char 101 - e
 130+ 4D9A 7C 40 38 00
 131+ 4D9E 18 24 20 70          defb %00011000,%00100100,%00100000,%01110000,%00100000,%00100000,%00100000,%00000000 ; char 102 - f
 131+ 4DA2 20 20 20 00
 132+ 4DA6 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00111000 ; char 103 - g
 132+ 4DAA 44 3C 04 38
 133+ 4DAE 40 40 58 64          defb %01000000,%01000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 104 - h
 133+ 4DB2 44 44 44 00
 134+ 4DB6 00 10 00 10          defb %00000000,%00010000,%00000000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 105 - i
 134+ 4DBA 10 10 10 00
 135+ 4DBE 08 00 18 08          defb %00001000,%00000000,%00011000,%00001000,%00001000,%00001000,%01001000,%00110000 ; char 106 - j
 135+ 4DC2 08 08 48 30
 136+ 4DC6 40 40 48 50          defb %01000000,%01000000,%01001000,%01010000,%01100000,%01010000,%01001000,%00000000 ; char 107 - k
 136+ 4DCA 60 50 48 00
 137+ 4DCE 30 10 10 10          defb %00110000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 108 - l
 137+ 4DD2 10 10 38 00
 138+ 4DD6 00 00 54 6A          defb %00000000,%00000000,%01010100,%01101010,%01001010,%01000010,%01000010,%00000000 ; char 109 - m
 138+ 4DDA 4A 42 42 00
 139+ 4DDE 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 110 - n
 139+ 4DE2 44 44 44 00
 140+ 4DE6 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 111: o
 140+ 4DEA 44 44 38 00
 141+ 4DEE 00 00 78 44          defb %00000000,%00000000,%01111000,%01000100,%01000100,%01111000,%01000000,%01000000 ; char 112: p
 141+ 4DF2 44 78 40 40
 142+ 4DF6 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00000100 ; char 113: q
 142+ 4DFA 44 3C 04 04
 143+ 4DFE 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000000,%01000000,%01000000,%00000000 ; char 114: r
 143+ 4E02 40 40 40 00
 144+ 4E06 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%00111000,%00000100,%01111000,%00000000 ; char 115: s
 144+ 4E0A 38 04 78 00
 145+ 4E0E 20 20 70 20          defb %00100000,%00100000,%01110000,%00100000,%00100000,%00100100,%00011000,%00000000 ; char 116: t
 145+ 4E12 20 24 18 00
 146+ 4E16 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%01001100,%00110100,%00000000 ; char 117: u
 146+ 4E1A 44 4C 34 00
 147+ 4E1E 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 118: v
 147+ 4E22 44 28 10 00
 148+ 4E26 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01010100,%01010100,%00101000,%00000000 ; char 119: w
 148+ 4E2A 54 54 28 00
 149+ 4E2E 00 00 44 28          defb %00000000,%00000000,%01000100,%00101000,%00010000,%00101000,%01000100,%00000000 ; char 120: x
 149+ 4E32 10 28 44 00
 150+ 4E36 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01001100,%00110100,%00000100,%00111000 ; char 121: y
 150+ 4E3A 4C 34 04 38
 151+ 4E3E 00 00 7C 08          defb %00000000,%00000000,%01111100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 122: z
 151+ 4E42 10 20 7C 00
 152+ 4E46 18 20 20 40          defb %00011000,%00100000,%00100000,%01000000,%00100000,%00100000,%00011000,%00000000 ; char 123: {
 152+ 4E4A 20 20 18 00
 153+ 4E4E 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 124: |
 153+ 4E52 10 10 10 00
 154+ 4E56 30 08 08 04          defb %00110000,%00001000,%00001000,%00000100,%00001000,%00001000,%00110000,%00000000 ; char 125: }
 154+ 4E5A 08 08 30 00
 155+ 4E5E 20 54 08 00          defb %00100000,%01010100,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 126: ~
 155+ 4E62 00 00 00 00
 156+ 4E66 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 127 (delete) - end the standard ASCII (0-127)
 156+ 4E6A 00 00 00 00
 157+ 4E6E 3C 42 A5 81          defb %00111100,%01000010,%10100101,%10000001,%10100101,%10011001,%01000010,%00111100 ; char 128 (open face)
 157+ 4E72 A5 99 42 3C
 158+ 4E76 3C 7E DB FF          defb %00111100,%01111110,%11011011,%11111111,%11011011,%11100111,%01111110,%00111100 ; char 129 (full face)
 158+ 4E7A DB E7 7E 3C
 159+ 4E7E 6C FE FE FE          defb %01101100,%11111110,%11111110,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 130 (hearts)
 159+ 4E82 7C 38 10 00
 160+ 4E86 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 131 (diamonds)
 160+ 4E8A 7C 38 10 00
 161+ 4E8E 10 38 54 FE          defb %00010000,%00111000,%01010100,%11111110,%01010100,%00010000,%01111100,%00000000 ; char 132 (clus)
 161+ 4E92 54 10 7C 00
 162+ 4E96 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%11010110,%00010000,%01111100,%00000000 ; char 133 (spades)
 162+ 4E9A D6 10 7C 00
 163+ 4E9E 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 134
 163+ 4EA2 FF 18 18 18
 164+ 4EA6 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 135
 164+ 4EAA 1F 18 18 18
 165+ 4EAE 00 00 00 F8          defb %00000000,%00000000,%00000000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 136
 165+ 4EB2 F8 18 18 18
 166+ 4EB6 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00000000,%00000000,%00000000 ; char 137
 166+ 4EBA F8 00 00 00
 167+ 4EBE 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00000000,%00000000,%00000000 ; char 138
 167+ 4EC2 1F 00 00 00
 168+ 4EC6 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 139
 168+ 4ECA FF 00 00 00
 169+ 4ECE 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 140
 169+ 4ED2 1F 18 18 18
 170+ 4ED6 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 141
 170+ 4EDA FF 18 18 18
 171+ 4EDE 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 142
 171+ 4EE2 F8 18 18 18
 172+ 4EE6 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 143
 172+ 4EEA FF 00 00 00
 173+ 4EEE 18 18 18 18          defb %00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000 ; char 144
 173+ 4EF2 18 18 18 18
 174+ 4EF6 03 07 0E 1C          defb %00000011,%00000111,%00001110,%00011100,%00111000,%01110000,%11100000,%11000000 ; char 145
 174+ 4EFA 38 70 E0 C0
 175+ 4EFE C0 E0 70 38          defb %11000000,%11100000,%01110000,%00111000,%00011100,%00001110,%00000111,%00000011 ; char 146
 175+ 4F02 1C 0E 07 03
 176+ 4F06 C3 E7 7E 3C          defb %11000011,%11100111,%01111110,%00111100,%00111100,%01111110,%11100111,%11000011 ; char 147
 176+ 4F0A 3C 7E E7 C3
 177+ 4F0E 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 148
 177+ 4F12 10 10 10 10
 178+ 4F16 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 149
 178+ 4F1A 10 10 10 10
 179+ 4F1E 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 150
 179+ 4F22 10 10 10 10
 180+ 4F26 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 151
 180+ 4F2A 00 00 00 00
 181+ 4F2E 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00000000,%00000000,%00000000,%00000000 ; char 152
 181+ 4F32 00 00 00 00
 182+ 4F36 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 153
 182+ 4F3A 00 00 00 00
 183+ 4F3E 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 154
 183+ 4F42 10 10 10 10
 184+ 4F46 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 155
 184+ 4F4A 10 10 10 10
 185+ 4F4E 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 156
 185+ 4F52 10 10 10 10
 186+ 4F56 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 157
 186+ 4F5A 00 00 00 00
 187+ 4F5E 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000 ; char 158
 187+ 4F62 10 10 10 10
 188+ 4F66 01 02 04 08          defb %00000001,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%10000000 ; char 159
 188+ 4F6A 10 20 40 80
 189+ 4F6E 80 40 20 10          defb %10000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000001 ; char 160
 189+ 4F72 08 04 02 01
 190+ 4F76 81 42 24 18          defb %10000001,%01000010,%00100100,%00011000,%00011000,%00100100,%01000010,%10000001 ; char 161
 190+ 4F7A 18 24 42 81
 191+ 4F7E 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 162
 191+ 4F82 00 00 FF FF
 192+ 4F86 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; char 163
 192+ 4F8A FF FF FF FF
 193+ 4F8E 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 164
 193+ 4F92 FF FF FF FF
 194+ 4F96 FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 194+ 4F9A 00 00 00 00
 195+ 4F9E FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 166
 195+ 4FA2 00 00 00 00
 196+ 4FA6 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 167
 196+ 4FAA FF FF 00 00
 197+ 4FAE C0 C0 C0 C0          defb %11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000 ; char 168
 197+ 4FB2 C0 C0 C0 C0
 198+ 4FB6 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; char 169
 198+ 4FBA F0 F0 F0 F0
 199+ 4FBE FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 170
 199+ 4FC2 FC FC FC FC
 200+ 4FC6 03 03 03 03          defb %00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011 ; char 171
 200+ 4FCA 03 03 03 03
 201+ 4FCE 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; char 172
 201+ 4FD2 0F 0F 0F 0F
 202+ 4FD6 3F 3F 3F 3F          defb %00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111 ; char 173
 202+ 4FDA 3F 3F 3F 3F
 203+ 4FDE FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 174
 203+ 4FE2 81 81 81 FF
 204+ 4FE6 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; char 175
 204+ 4FEA F0 F0 F0 F0
 205+ 4FEE 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; char 176
 205+ 4FF2 0F 0F 0F 0F
 206+ 4FF6 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; char 177
 206+ 4FFA 00 00 00 00
 207+ 4FFE F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 178
 207+ 5002 00 00 00 00
 208+ 5006 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00001111,%00001111,%00001111,%00001111 ; char 179
 208+ 500A 0F 0F 0F 0F
 209+ 500E 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%11110000,%11110000,%11110000,%11110000 ; char 180
 209+ 5012 F0 F0 F0 F0
 210+ 5016 3C 3C 3C 3C          defb %00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100 ; char 181
 210+ 501A 3C 3C 3C 3C
 211+ 501E C3 C3 C3 C3          defb %11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011 ; char 182
 211+ 5022 C3 C3 C3 C3
 212+ 5026 FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 183
 212+ 502A 00 00 FF FF
 213+ 502E 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 184
 213+ 5032 FF FF 00 00
 214+ 5036 33 33 CC CC          defb %00110011,%00110011,%11001100,%11001100,%00110011,%00110011,%11001100,%11001100 ; char 185
 214+ 503A 33 33 CC CC
 215+ 503E 55 AA 55 AA          defb %01010101,%10101010,%01010101,%10101010,%01010101,%10101010,%01010101,%10101010 ; char 186
 215+ 5042 55 AA 55 AA
 216+ 5046 66 33 99 CC          defb %01100110,%00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100 ; char 187
 216+ 504A 66 33 99 CC
 217+ 504E CC 99 33 66          defb %11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011,%01100110 ; char 188
 217+ 5052 CC 99 33 66
 218+ 5056 33 99 CC 66          defb %00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100,%01100110 ; char 189
 218+ 505A 33 99 CC 66
 219+ 505E 66 CC 99 33          defb %01100110,%11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011 ; char 190
 219+ 5062 66 CC 99 33
 220+ 5066 10 10 7C 10          defb %00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%01111100,%00000000 ; char 191 (Â±)
 220+ 506A 10 00 7C 00
 221+ 506E 60 18 06 18          defb %01100000,%00011000,%00000110,%00011000,%01100000,%00000000,%01111110,%00000000 ; char 192 (â¥)
 221+ 5072 60 00 7E 00
 222+ 5076 06 18 60 18          defb %00000110,%00011000,%01100000,%00011000,%00000110,%00000000,%01111110,%00000000 ; char 193 (â¤)
 222+ 507A 06 00 7E 00
 223+ 507E 3E 20 20 20          defb %00111110,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 223+ 5082 A0 60 20 00
 224+ 5086 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 224+ 508A 00 00 00 00
 225+ 508E 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 225+ 5092 70 00 00 00
 226+ 5096 00 00 2A 54          defb %00000000,%00000000,%00101010,%01010100,%00000000,%01111110,%00000000,%00000000 ; char 197
 226+ 509A 00 7E 00 00
 227+ 509E 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 227+ 50A2 54 A8 00 00
 228+ 50A6 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11100000,%11000000,%10000000,%00000000 ; char 199
 228+ 50AA E0 C0 80 00
 229+ 50AE FE 7C 38 10          defb %11111110,%01111100,%00111000,%00010000,%00000000,%00000000,%00000000,%00000000 ; char 200
 229+ 50B2 00 00 00 00
 230+ 50B6 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00000111,%00000011,%00000001,%00000000 ; char 201
 230+ 50BA 07 03 01 00
 231+ 50BE 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00010000,%00111000,%01111100,%11111110 ; char 202
 231+ 50C2 10 38 7C FE
 232+ 50C6 10 38 7C 10          defb %00010000,%00111000,%01111100,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 203 (up arrow)
 232+ 50CA 10 10 10 00
 233+ 50CE 1E 0E 0E 12          defb %00011110,%00001110,%00001110,%00010010,%00100000,%01000000,%00000000,%00000000 ; char 204 (up right arrow)
 233+ 50D2 20 40 00 00
 234+ 50D6 00 08 0C FE          defb %00000000,%00001000,%00001100,%11111110,%00001100,%00001000,%00000000,%00000000 ; char 205 (right arrow)
 234+ 50DA 0C 08 00 00
 235+ 50DE 00 40 20 12          defb %00000000,%01000000,%00100000,%00010010,%00001110,%00001110,%00011110,%00000000 ; char 206 (down right arrow)
 235+ 50E2 0E 0E 1E 00
 236+ 50E6 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%01111100,%00111000,%00010000,%00000000 ; char 207 (down arrow)
 236+ 50EA 7C 38 10 00
 237+ 50EE 00 04 08 90          defb %00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000,%00000000 ; char 208 (down left arrow)
 237+ 50F2 E0 E0 F0 00
 238+ 50F6 00 20 60 FE          defb %00000000,%00100000,%01100000,%11111110,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 238+ 50FA 60 20 00 00
 239+ 50FE F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 239+ 5102 08 04 00 00
 240+ 5106 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 240+ 510A F0 44 38 00
 241+ 510E 00 02 7C A8          defb %00000000,%00000010,%01111100,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 241+ 5112 28 28 28 00
 242+ 5116 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001000,%00010000,%00010000,%00010000 ; char 213
 242+ 511A 08 10 10 10
 243+ 511E 00 00 00 C0          defb %00000000,%00000000,%00000000,%11000000,%00100000,%00010000,%00010000,%00010000 ; char 214
 243+ 5122 20 10 10 10
 244+ 5126 10 10 20 C0          defb %00010000,%00010000,%00100000,%11000000,%00000000,%00000000,%00000000,%00000000 ; char 215
 244+ 512A 00 00 00 00
 245+ 512E 10 10 08 07          defb %00010000,%00010000,%00001000,%00000111,%00000000,%00000000,%00000000,%00000000 ; char 216
 245+ 5132 00 00 00 00
 246+ 5136 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001111,%00011100,%00011000,%00011000 ; char 217
 246+ 513A 0F 1C 18 18
 247+ 513E 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00111000,%00011000,%00011000 ; char 218
 247+ 5142 F0 38 18 18
 248+ 5146 18 18 38 F0          defb %00011000,%00011000,%00111000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 248+ 514A E0 00 00 00
 249+ 514E 18 18 1C 0F          defb %00011000,%00011000,%00011100,%00001111,%00000111,%00000000,%00000000,%00000000 ; char 220
 249+ 5152 07 00 00 00
 250+ 5156 00 3C 42 42          defb %00000000,%00111100,%01000010,%01000010,%01000010,%01000010,%00111100,%00000000 ; char 221
 250+ 515A 42 42 3C 00
 251+ 515E 00 3C 7E 7E          defb %00000000,%00111100,%01111110,%01111110,%01111110,%01111110,%00111100,%00000000 ; char 222
 251+ 5162 7E 7E 3C 00
 252+ 5166 00 18 3C 7E          defb %00000000,%00011000,%00111100,%01111110,%01111110,%00111100,%00011000,%00000000 ; char 223
 252+ 516A 7E 3C 18 00
 253+ 516E FF FE FC F8          defb %11111111,%11111110,%11111100,%11111000,%11110000,%11100000,%11000000,%10000000 ; char 224
 253+ 5172 F0 E0 C0 80
 254+ 5176 FF 7F 3F 1F          defb %11111111,%01111111,%00111111,%00011111,%00001111,%00000111,%00000011,%00000001 ; char 225
 254+ 517A 0F 07 03 01
 255+ 517E 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00011111,%00111111,%01111111,%11111111 ; char 226
 255+ 5182 1F 3F 7F FF
 256+ 5186 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11111110,%11111111 ; char 227
 256+ 518A F8 FC FE FF
 257+ 518E 00 02 06 6C          defb %00000000,%00000010,%00000110,%01101100,%01111000,%01110000,%01100000,%00000000 ; char 228 (checkmark)
 257+ 5192 78 70 60 00
 258+ 5196 00 66 3C 18          defb %00000000,%01100110,%00111100,%00011000,%00111100,%01100110,%00000000,%00000000 ; char 229 (x)
 258+ 519A 3C 66 00 00
 259+ 519E 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%00111000,%00010000,%00111000,%00010000 ; char 230 (female)
 259+ 51A2 38 10 38 10
 260+ 51A6 07 03 3D 44          defb %00000111,%00000011,%00111101,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 231 (male)
 260+ 51AA 44 44 38 00
 261+ 51AE 78 44 42 42          defb %01111000,%01000100,%01000010,%01000010,%01000010,%01000010,%01000010,%01111110 ; char 232 (new doc)
 261+ 51B2 42 42 42 7E
 262+ 51B6 00 F8 FF 81          defb %00000000,%11111000,%11111111,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 233 (folder)
 262+ 51BA 81 81 81 FF
 263+ 51BE 10 7C FE 54          defb %00010000,%01111100,%11111110,%01010100,%01010100,%01010100,%01010100,%01111100 ; char 234 (trash bin)
 263+ 51C2 54 54 54 7C
 264+ 51C6 FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10111101,%10101101,%10101101,%11111111 ; char 235 (floppy disk)
 264+ 51CA BD AD AD FF
 265+ 51CE 00 EA AA AC          defb %00000000,%11101010,%10101010,%10101100,%10101100,%10101010,%11101010,%00000000 ; char 236 (OK)
 265+ 51D2 AC AA EA 00
 266+ 51D6 18 7E FF 7E          defb %00011000,%01111110,%11111111,%01111110,%01111110,%01100110,%01100110,%01100110 ; char 237 (home)
 266+ 51DA 7E 66 66 66
 267+ 51DE 3C 42 91 91          defb %00111100,%01000010,%10010001,%10010001,%10011101,%10000001,%01000010,%00111100 ; char 238 (clock)
 267+ 51E2 9D 81 42 3C
 268+ 51E6 00 02 05 FD          defb %00000000,%00000010,%00000101,%11111101,%10100101,%10100010,%00000000,%00000000 ; char 239 (key)
 268+ 51EA A5 A2 00 00
 269+ 51EE 08 0C 3E 4C          defb %00001000,%00001100,%00111110,%01001100,%01001000,%01000010,%01000010,%00111100 ; char 240 (undo)
 269+ 51F2 48 42 42 3C
 270+ 51F6 00 FF C3 A5          defb %00000000,%11111111,%11000011,%10100101,%10011001,%10000001,%11111111,%00000000 ; char 241 (letter)
 270+ 51FA 99 81 FF 00
 271+ 51FE 38 44 44 7C          defb %00111000,%01000100,%01000100,%01111100,%01111100,%01111100,%01111100,%00000000 ; char 242 (lock)
 271+ 5202 7C 7C 7C 00
 272+ 5206 06 09 09 F8          defb %00000110,%00001001,%00001001,%11111000,%11111000,%11111000,%11111000,%00000000 ; char 243 (unlock)
 272+ 520A F8 F8 F8 00
 273+ 520E FF FF 81 AD          defb %11111111,%11111111,%10000001,%10101101,%10100101,%10100101,%10000001,%11111111 ; char 244 (calendar)
 273+ 5212 A5 A5 81 FF
 274+ 5216 01 1A 24 4A          defb %00000001,%00011010,%00100100,%01001010,%01010010,%00100100,%01011000,%10000000 ; char 245 (diameter)
 274+ 521A 52 24 58 80
 275+ 521E 7E 81 81 81          defb %01111110,%10000001,%10000001,%10000001,%10000001,%01110110,%00001100,%00000100 ; char 246 (baloon)
 275+ 5222 81 76 0C 04
 276+ 5226 0C 0A 0A 0A          defb %00001100,%00001010,%00001010,%00001010,%00001000,%00011000,%00111000,%00010000 ; char 247 (note)
 276+ 522A 08 18 38 10
 277+ 522E 12 31 F5 F5          defb %00010010,%00110001,%11110101,%11110101,%11110101,%11110101,%00110001,%00010010 ; char 248 (audio on)
 277+ 5232 F5 F5 31 12
 278+ 5236 10 30 F0 F0          defb %00010000,%00110000,%11110000,%11110000,%11110000,%11110000,%00110000,%00010000 ; char 249 (audio off)
 278+ 523A F0 F0 30 10
 279+ 523E 40 60 70 78          defb %01000000,%01100000,%01110000,%01111000,%01111100,%01111110,%01111000,%01001000 ; char 250 (pointer)
 279+ 5242 7C 7E 78 48
 280+ 5246 3C 42 99 A1          defb %00111100,%01000010,%10011001,%10100001,%10100001,%10011001,%01000010,%00111100 ; char 251 (Â©)
 280+ 524A A1 99 42 3C
 281+ 524E 18 24 20 78          defb %00011000,%00100100,%00100000,%01111000,%00100000,%00100010,%01011100,%00000000 ; char 252 (Â£)
 281+ 5252 20 22 5C 00
 282+ 5256 3C 42 78 24          defb %00111100,%01000010,%01111000,%00100100,%00100100,%00011110,%01000010,%00111100 ; char 253 (Â§)
 282+ 525A 24 1E 42 3C
 283+ 525E 00 00 10 00          defb %00000000,%00000000,%00010000,%00000000,%01111100,%00000000,%00010000,%00000000 ; char 254 (Ã·)
 283+ 5262 7C 00 10 00
 284+ 5266 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 255 (cursor)
 284+ 526A FF FF FF FF
 285+ 526E
# file closed: ../include/vdp/8x8fonts-r18.asm
  83  526E                  INCLUDE "../include/vdp/logo-fonts.asm"
# file opened: ../include/vdp/logo-fonts.asm
   1+ 526E              ; ------------------------------------------------------------------------------
   2+ 526E              ; LM80C - LOGO CHARSET - R1.1
   3+ 526E              ; ------------------------------------------------------------------------------
   4+ 526E              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 526E              ; designed by Leonardo Miliani. More info at
   6+ 526E              ; www DOT leonardomiliani DOT com
   7+ 526E              ; ------------------------------------------------------------------------------
   8+ 526E              ; Code Revision:
   9+ 526E              ; R1.0 - 20200124 - First revision: logo chars
  10+ 526E              ; R1.1 - 20200229 - Adopted usual hexadecimal & binary prefixes
  11+ 526E              ; ------------------------------------------------------------------------------
  12+ 526E
  13+ 526E              LOGOFONT:   equ $
  14+ 526E 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; 0
  14+ 5272 00 00 00 00
  15+ 5276 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; 1
  15+ 527A FF FF FF FF
  16+ 527E FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; 2
  16+ 5282 00 00 00 00
  17+ 5286 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; 3
  17+ 528A 0F 0F 0F 0F
  18+ 528E 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; 4
  18+ 5292 FF FF FF FF
  19+ 5296 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; 5
  19+ 529A F0 F0 F0 F0
  20+ 529E 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; 6
  20+ 52A2 0F 0F 0F 0F
  21+ 52A6 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; 7
  21+ 52AA F0 F0 F0 F0
  22+ 52AE F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; 8
  22+ 52B2 00 00 00 00
  23+ 52B6 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; 9
  23+ 52BA 00 00 00 00
  24+ 52BE 00 00 00 FC              defb %00000000,%00000000,%00000000,%11111100,%11111111,%00000111,%00000011,%00000000 ; 10
  24+ 52C2 FF 07 03 00
  25+ 52C6 00 00 00 3F              defb %00000000,%00000000,%00000000,%00111111,%11111111,%11100000,%11000000,%00000000 ; 11
  25+ 52CA FF E0 C0 00
  26+ 52CE 18 18 1F 19              defb %00011000,%00011000,%00011111,%00011001,%00011001,%00011111,%00011000,%00011000 ; 12
  26+ 52D2 19 1F 18 18
  27+ 52D6 18 18 F8 98              defb %00011000,%00011000,%11111000,%10011000,%10011000,%11111000,%00011000,%00011000 ; 13
  27+ 52DA 98 F8 18 18
  28+ 52DE 18 18 1C 1F              defb %00011000,%00011000,%00011100,%00011111,%00001111,%00000000,%00000000,%00000000 ; 14
  28+ 52E2 0F 00 00 00
  29+ 52E6 00 00 00 0F              defb %00000000,%00000000,%00000000,%00001111,%00011111,%00011100,%00011000,%00011000 ; 15
  29+ 52EA 1F 1C 18 18
  30+ 52EE 00 00 00 F0              defb %00000000,%00000000,%00000000,%11110000,%11111000,%00111000,%00011000,%00011000 ; 16
  30+ 52F2 F8 38 18 18
  31+ 52F6 18 18 38 F8              defb %00011000,%00011000,%00111000,%11111000,%11110000,%00000000,%00000000,%00000000 ; 17
  31+ 52FA F0 00 00 00
  32+ 52FE 00 00 00 FF              defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; 18
  32+ 5302 FF 00 00 00
  33+ 5306 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%11111111,%11111111,%11111111,%11111111 ; 19
  33+ 530A FF FF FF FF
  34+ 530E F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11111111,%11111111,%11111111,%11111111 ; 20
  34+ 5312 FF FF FF FF
  35+ 5316 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11110000,%11110000,%11110000,%11110000 ; 21
  35+ 531A F0 F0 F0 F0
  36+ 531E FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00001111,%00001111,%00001111,%00001111 ; 22
  36+ 5322 0F 0F 0F 0F
  37+ 5326 00 30 78 78              defb %00000000,%00110000,%01111000,%01111000,%00110000,%00000000,%00000000,%00000000 ; 23
  37+ 532A 30 00 00 00
  38+ 532E
# file closed: ../include/vdp/logo-fonts.asm
  84  532E
  85  532E              ; include ROM/RAM switcher
  86  532E                  INCLUDE "../include/switcher/switcher-r1.03.asm"
# file opened: ../include/switcher/switcher-r1.03.asm
   1+ 532E              ; ------------------------------------------------------------------------------
   2+ 532E              ; LM80C - ROM/RAM SWITCHER - R1.02
   3+ 532E              ; ------------------------------------------------------------------------------
   4+ 532E              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 532E              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 532E              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 532E              ; kind of warranty: you can use them at your own risk.
   8+ 532E              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 532E              ; maintain the copyright notices, include this advice and the note to the
  10+ 532E              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 532E              ; redistribuite them.
  12+ 532E              ; https://www.leonardomiliani.com
  13+ 532E              ;
  14+ 532E              ; Please support me by visiting the following links:
  15+ 532E              ; Main project page: https://www.leonardomiliani.com
  16+ 532E              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 532E              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 532E              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 532E              ; ------------------------------------------------------------------------------
  20+ 532E              ; Code Revision:
  21+ 532E              ; R1.0   - 20200718 - First version
  22+ 532E              ; R1.1   - 20200827 - PIO settings now are part of the file
  23+ 532E              ; R1.02  - 20210319 - support for LM80C DOS and its repositioning into high-RAM
  24+ 532E              ;-------------------------------------------------------------------------------
  25+ 532E
  26+ 532E              TMP_FW_LOC:     equ     $8000           ; address from where to make a temporary copy of the FW
  27+ 532E              ;-------------------------------------------------------------------------------
  28+ 532E              ; THIS CODE WILL BE EXECUTED FROM RAM
  29+ 532E 3E FC        RAMRUN:         ld      A,%11111100     ; set ROM off and RAM on..
  30+ 5330 D3 01                        out     (PIO_DB),A      ; ...by setting bit #0 to 0 (and leave VRAM bank #0)
  31+ 5332 01 7A 53                     ld      BC,END_OF_FW    ; let's copy back FW into low RAM - bytes to copy
  32+ 5335 21 00 80                     ld      HL,TMP_FW_LOC   ; source address
  33+ 5338 11 00 00                     ld      DE,$0000        ; dest. address
  34+ 533B ED B0                        ldir                    ; copy!
  35+ 533D AF                           xor     A
  36+ 533E D3 01                        out     (PIO_DB),A      ; all LEDs off - finished copying
  37+ 5340 C3 AE 02                     jp      INIT_HW         ; return control to old init (now into RAM)
  38+ 5343
  39+ 5343              ;-------------------------------------------------------------------------------
  40+ 5343              ; copy the whole contents of ROM into RAM then disable the first memory
  41+ 5343 3A D7 53     ROM2RAM:        ld      A,(basicStarted); check if BASIC is already started
  42+ 5346 FE 59                        cp      'Y'             ; to see if this is a power-up
  43+ 5348 20 0C                        jr      NZ,CNTCP2RAM    ; no, continue copy to RAM
  44+ 534A                              ; WARNING: Do **NOT** change the following "out()" sequence, ABSOLUTELY!
  45+ 534A 3E CF                        ld      A,%11001111     ; set mode 3 ("control mode")
  46+ 534C D3 03                        out     (PIO_CB),A      ; for PIO port B
  47+ 534E AF                           xor     A               ; set LEDs off, RAM on, VRAM on bank #0
  48+ 534F D3 01                        out     (PIO_DB),A      ; send settings to PIO register
  49+ 5351 D3 03                        out     (PIO_CB),A      ; set pins following register's status
  50+ 5353 C3 AE 02                     jp      INIT_HW         ; jump to re-init HW
  51+ 5356
  52+ 5356                              ; WARNING: Do **NOT** change the following "out()" sequence, ABSOLUTELY!
  53+ 5356 3E CF        CNTCP2RAM:      ld      A,%11001111     ; set mode 3 (mode control)
  54+ 5358 D3 03                        out     (PIO_CB),A      ; for PIO port B
  55+ 535A 3E FD                        ld      A,%11111101     ; set pin #0 as HIGH to enable ROM
  56+ 535C D3 01                        out     (PIO_DB),A      ; store the value into the internal register
  57+ 535E AF                           xor     A               ; set pins to OUTPUT
  58+ 535F D3 03                        out     (PIO_CB),A      ; for port B, activating the RAM
  59+ 5361                              ; copy DOS
  60+ 5361 01 98 11                     ld      BC,$FFFF-DOSSTART+1 ; bytes to copy
  61+ 5364 21 7A 53                     ld      HL,END_OF_FW    ; load DOS from its original location and...
  62+ 5367 11 68 EE                     ld      DE,DOSSTART     ; ...store it into its portion of memory
  63+ 536A ED B0                        ldir                    ; copy!
  64+ 536C                              ; copy BASIC
  65+ 536C 01 7A 53                     ld      BC,END_OF_FW    ; copy FW from ROM to high RAM
  66+ 536F 21 00 00                     ld      HL,$0000        ; source address
  67+ 5372 11 00 80                     ld      DE,TMP_FW_LOC   ; dest. address
  68+ 5375 ED B0                        ldir                    ; copy!
  69+ 5377 C3 2E D3                     jp      RAMRUN+TMP_FW_LOC; jump to execute code into RAM
  70+ 537A
  71+ 537A              ;-------------------------------------------------------------------------------
  72+ 537A              END_OF_FW:      equ     $   ; this is the last cell of the firmware
# file closed: ../include/switcher/switcher-r1.03.asm
  87  537A
  88  537A              ; include workspace equates
  89  537A                  INCLUDE "../include/workspace/workspace-r1.02.asm"
# file opened: ../include/workspace/workspace-r1.02.asm
   1+ 537A              ; ------------------------------------------------------------------------------
   2+ 537A              ; LM80C 64K - WORKSPACE EQUATES - R1.02
   3+ 537A              ; ------------------------------------------------------------------------------
   4+ 537A              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 537A              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 537A              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 537A              ; kind of warranty: you can use them at your own risk.
   8+ 537A              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 537A              ; maintain the copyright notices, include this advice and the note to the
  10+ 537A              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 537A              ; redistribuite them.
  12+ 537A              ; https://www.leonardomiliani.com
  13+ 537A              ;
  14+ 537A              ; Please support me by visiting the following links:
  15+ 537A              ; Main project page: https://www.leonardomiliani.com
  16+ 537A              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 537A              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 537A              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 537A              ; ------------------------------------------------------------------------------
  20+ 537A
  21+ 537A              ; set starting of RAM based on computer model
  22+ 537A              SERBUF_START    equ     END_OF_FW       ; RAM starts here
  23+ 537A
  24+ 537A              ;-------------------------------------------------------------------------------
  25+ 537A              serInPtr        equ     SERBUF_START + SER_BUFSIZE
  26+ 537A              serRdPtr        equ     serInPtr+2
  27+ 537A              serBufUsed      equ     serRdPtr+2
  28+ 537A              basicStarted    equ     serBufUsed+1
  29+ 537A              bufWrap         equ     (SERBUF_START + SER_BUFSIZE) & $FF
  30+ 537A              TEMPSTACK       equ     CURPOS - 3      ; top of BASIC line input buffer so is "free ram" when BASIC resets
  31+ 537A
  32+ 537A              ; BASIC WORK SPACE LOCATIONS
  33+ 537A              ; THE INTERPRETER ALLOCATES THE FOLLOWING RAM CELLS
  34+ 537A              ; TO STORE IMPORTANT VALUES USED FOR SOME SPECIFIC FUNCTIONS:
  35+ 537A              ; THEY CAN BE VECTOR (ADDRESSES) FUNCTIONS, SYSTEM DATAS (I.E. VARIABLES)
  36+ 537A              ; AND SO ON. THE FIRST CELLS ARE FILLED WITH VALUES STORED INTO ROM AT $(INITAB) ADDRESS
  37+ 537A              WRKSPC          equ     basicStarted+$01; (3) BASIC Work space
  38+ 537A              NMIUSR          equ     WRKSPC+$03      ; (3) NMI exit point routine
  39+ 537A              USR             equ     NMIUSR+$03      ; (3) "USR (x)" jump  <-- in (USR+$01)/(USR+$02) the user can store the address of a specific machine language routine
  40+ 537A              OUTSUB          equ     USR+$03         ; (1) "out p,n"
  41+ 537A              OTPORT          equ     OUTSUB+$01      ; (2) Port (p)
  42+ 537A              DIVSUP          equ     OTPORT+$02      ; (1) Division support routine
  43+ 537A              DIV1            equ     DIVSUP+$01      ; (4) <- Values
  44+ 537A              DIV2            equ     DIV1+$04        ; (4) <-   to
  45+ 537A              DIV3            equ     DIV2+$04        ; (3) <-   be
  46+ 537A              DIV4            equ     DIV3+$03        ; (2) <-inserted
  47+ 537A              SEED            equ     DIV4+$02        ; (35) Random number seed  <-- starting address of a seed table
  48+ 537A              LSTRND          equ     SEED+$23        ; (4) Last random number
  49+ 537A              INPSUB          equ     LSTRND+$04      ; (1) INP A,(x) Routine
  50+ 537A              INPORT          equ     INPSUB+$01      ; (2) PORT (x)
  51+ 537A              LWIDTH          equ     INPORT+$02      ; (1) Terminal width
  52+ 537A              COMMAN          equ     LWIDTH+$01      ; (1) Width for commas
  53+ 537A              NULFLG          equ     COMMAN+$01      ; (1) Null after input byte flag
  54+ 537A              CTLOFG          equ     NULFLG+$01      ; (1) Control "O" flag
  55+ 537A              CHKSUM          equ     CTLOFG+$01      ; (2) Array load/save check sum
  56+ 537A              NMIFLG          equ     CHKSUM+$02      ; (1) Flag for NMI break routine
  57+ 537A              BRKFLG          equ     NMIFLG+$01      ; (1) Break flag
  58+ 537A              RINPUT          equ     BRKFLG+$01      ; (3) Input reflection
  59+ 537A              STRSPC          equ     RINPUT+$03      ; (2) Pointer to bottom (start) of string space - default is 100 bytes below the top of memory
  60+ 537A              LINEAT          equ     STRSPC+$02      ; (2) Current line number. -1 means "direct mode", while -2 means cold start.
  61+ 537A              HLPLN           equ     LINEAT+$02      ; (2) Current line with errors
  62+ 537A              KEYDEL          equ     HLPLN+$02       ; (1) delay before key auto-repeat starts
  63+ 537A              AUTOKE          equ     KEYDEL+$01      ; (1) delay for key auto-repeat
  64+ 537A              FNKEYS          equ     AUTOKE+$01      ; (128) default text of FN keys
  65+ 537A              BASTXT          equ     FNKEYS+$80      ; (3) Pointer to start of BASIC program in memory
  66+ 537A              ; - - - - - - - - - - - - - - - - - - -   the above are locations pre-filled by the firmware at startup
  67+ 537A              BUFFER          equ     BASTXT+$03      ; (5) Input buffer
  68+ 537A              STACK           equ     BUFFER+$05      ; (85) Initial stack
  69+ 537A              CURPOS          equ     STACK+$55       ; (1) Character position on line
  70+ 537A              LCRFLG          equ     CURPOS+$01      ; (1) Locate/Create flag for DIM statement
  71+ 537A              TYPE            equ     LCRFLG+$01      ; (1) Data type flag: 0=numeric, non-zero=string
  72+ 537A              DATFLG          equ     TYPE+$01        ; (1) Literal statement flag
  73+ 537A              LSTRAM          equ     DATFLG+$01      ; (2) Last available RAM location for BASIC
  74+ 537A              DOSER           equ     LSTRAM+$02      ; (1) Error from DOS
  75+ 537A              TMPDBF          equ     DOSER+$01       ; (36) Secondary buffer for DOS
  76+ 537A              TMSTPT          equ     TMPDBF+$24      ; (2) Temporary string pointer
  77+ 537A              TMSTPL          equ     TMSTPT+$02      ; (12) Temporary string pool
  78+ 537A              TMPSTR          equ     TMSTPL+$0C      ; (4) Temporary string
  79+ 537A              STRBOT          equ     TMPSTR+$04      ; (2) Bottom of string space
  80+ 537A              CUROPR          equ     STRBOT+$02      ; (2) Current operator in EVAL
  81+ 537A              LOOPST          equ     CUROPR+$02      ; (2) First statement of loop
  82+ 537A              DATLIN          equ     LOOPST+$02      ; (2) Line of current DATA item
  83+ 537A              FORFLG          equ     DATLIN+$02      ; (1) "FOR" loop flag
  84+ 537A              LSTBIN          equ     FORFLG+$01      ; (1) Last byte entered
  85+ 537A              READFG          equ     LSTBIN+$01      ; (1) Read/Input flag
  86+ 537A              BRKLIN          equ     READFG+$01      ; (2) Line of break
  87+ 537A              NXTOPR          equ     BRKLIN+$02      ; (2) Next operator in EVAL
  88+ 537A              ERRLIN          equ     NXTOPR+$02      ; (2) Line of error
  89+ 537A              CONTAD          equ     ERRLIN+$02      ; (2) Where to CONTinue
  90+ 537A              TMRCNT          equ     CONTAD+$02      ; (4) TMR counter for 1/100 seconds
  91+ 537A              CTC0IV          equ     TMRCNT+$04      ; (3) CTC0 interrupt vector
  92+ 537A              CTC1IV          equ     CTC0IV+$03      ; (3) CTC1 interrupt vector
  93+ 537A              CTC2IV          equ     CTC1IV+$03      ; (3) CTC2 interrupt vector
  94+ 537A              CTC3IV          equ     CTC2IV+$03      ; (3) CTC3 interrupt vector
  95+ 537A              ; - - - - - - - - - - - - - - - - - - -   VIDEO REGISTERS - FROM HERE...
  96+ 537A              SCR_SIZE_W      equ     CTC3IV+$03      ; (1) screen width (it can be either 40 chars or 32 chars/bytes)
  97+ 537A              SCR_SIZE_H      equ     SCR_SIZE_W+$01  ; (1) screen height (it can be 24/48/192: 24 for text, 48 for MC, 192 for graphics)
  98+ 537A              SCR_MODE        equ     SCR_SIZE_H+$01  ; (1) screen mode (0=text, 1=G1, 2=G2, 3=MC, 4=ExG2)
  99+ 537A              SCR_NAM_TB      equ     SCR_MODE+$01    ; (2) video name table address
 100+ 537A              SCR_CURS_X      equ     SCR_NAM_TB+$02  ; (1) cursor X
 101+ 537A              SCR_CURS_Y      equ     SCR_CURS_X+$01  ; (1) cursor Y
 102+ 537A              SCR_CUR_NX      equ     SCR_CURS_Y+$01  ; (1) new cursor X position
 103+ 537A              SCR_CUR_NY      equ     SCR_CUR_NX+$01  ; (1) new cursor Y position
 104+ 537A              SCR_ORG_CHR     equ     SCR_CUR_NY+$01  ; (1) original char positioned under the cursor
 105+ 537A              CRSR_STATE      equ     SCR_ORG_CHR+$01 ; (1) state of cursor (1=on, 0=off)
 106+ 537A              LSTCSRSTA       equ     CRSR_STATE+$01  ; (1) last cursor state
 107+ 537A              PRNTVIDEO       equ     LSTCSRSTA+$01   ; (1) print on video buffer (1=on / 0=off) set to off on graphic only modes
 108+ 537A              CHR4VID         equ     PRNTVIDEO+$01   ; (1) char for video buffer
 109+ 537A              FRGNDCLR        equ     CHR4VID+$01     ; (1) foreground color as set by SCREEN or COLOR commands
 110+ 537A              BKGNDCLR        equ     FRGNDCLR+$01    ; (1) background color as set by SCREEN or COLOR commands
 111+ 537A              TMPBFR1         equ     BKGNDCLR+$01    ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 112+ 537A              TMPBFR2         equ     TMPBFR1+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 113+ 537A              TMPBFR3         equ     TMPBFR2+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 114+ 537A              TMPBFR4         equ     TMPBFR3+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 115+ 537A              VIDEOBUFF       equ     TMPBFR4+$02     ; (40) buffer used for video scrolling and other purposes
 116+ 537A              VIDTMP1         equ     VIDEOBUFF+$28   ; (2) temporary video word
 117+ 537A              VIDTMP2         equ     VIDTMP1+$02     ; (2) temporary video word
 118+ 537A              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO VPD OUT OF THIS RANGE,
 119+ 537A                                                      ; OTHERWISE YOU WILL HAVE TO CHECK THE POINTER IN "CLR_RAM_REG" FUNCTION
 120+ 537A              ; - - - - - - - - - - - - - - - - - - -   SOUND & KEYBOARD REGISTERS - FROM HERE...
 121+ 537A              CHASNDDTN       equ     VIDTMP2+$02     ; (2) sound Ch.A duration (in 1/100s)
 122+ 537A              CHBSNDDTN       equ     CHASNDDTN+$02   ; (2) sound Ch.B duration (in 1/100s)
 123+ 537A              CHCSNDDTN       equ     CHBSNDDTN+$02   ; (2) sound Ch.C duration (in 1/100s)
 124+ 537A              KBDNPT          equ     CHCSNDDTN+$02   ; (1) temp cell used to flag if input comes from keyboard
 125+ 537A              KBTMP           equ     KBDNPT+$01      ; (1) temp cell used by keyboard scanner
 126+ 537A              TMPKEYBFR       equ     KBTMP+$01       ; (1) temp buffer for last key pressed
 127+ 537A              LASTKEYPRSD     equ     TMPKEYBFR+$01   ; (1) last key code pressed
 128+ 537A              STATUSKEY       equ     LASTKEYPRSD+$01 ; (1) status key, used for auto-repeat
 129+ 537A              KEYTMR          equ     STATUSKEY+$01   ; (2) timer used for auto-repeat key
 130+ 537A              CONTROLKEYS     equ     KEYTMR+$02      ; (1) flags for control keys (bit#0=SHIFT; bit#1=CTRL; bit#2=C=)
 131+ 537A              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO PSG OUT OF THIS RANGE,
 132+ 537A                                                      ; OTHERWISE YOU WILL HAVE TO CHANGE THE POINTER IN "initPSG" FUNCTION
 133+ 537A              SERIALS_EN      equ     CONTROLKEYS+$01 ; (1) serial ports status: bit 0 for Port1 (A), bit 1 for Port2 (B): 0=OFF, 1=ON
 134+ 537A              SERABITS        equ     SERIALS_EN+$01  ; (1) serial port A data bits
 135+ 537A              SERBBITS        equ     SERABITS+$01    ; (1) serial port B data bits
 136+ 537A              DOS_EN          equ     SERBBITS+$01    ; (1) DOS enable/disable (1/0)
 137+ 537A              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 138+ 537A                                                      ; from here there are the RAM locations that
 139+ 537A                                                      ; are saved during SAVE
 140+ 537A              PROGND          equ     DOS_EN+$01      ; (2) End of program
 141+ 537A              VAREND          equ     PROGND+$02      ; (2) End of variables
 142+ 537A              ARREND          equ     VAREND+$02      ; (2) End of arrays
 143+ 537A              NXTDAT          equ     ARREND+$02      ; (2) Next data item
 144+ 537A              FNRGNM          equ     NXTDAT+$02      ; (2) Name of FN argument
 145+ 537A              FNARG           equ     FNRGNM+$02      ; (4) FN argument value
 146+ 537A              FPREG           equ     FNARG+$04       ; (3) Floating point register
 147+ 537A              FPEXP           equ     FPREG+$03       ; (1) Floating point exponent
 148+ 537A              SGNRES          equ     FPEXP+$01       ; (1) Sign of result
 149+ 537A              PBUFF           equ     SGNRES+$01      ; (13) Number print buffer
 150+ 537A              MULVAL          equ     PBUFF+$0D       ; (3) Multiplier
 151+ 537A              PROGST          equ     MULVAL+$03      ; (100) Start of program text area
 152+ 537A              STLOOK          equ     PROGST+$64      ; Start of memory test
 153+ 537A
# file closed: ../include/workspace/workspace-r1.02.asm
  90  537A
  91  537A              ; include the latest versions of the CF & DOS modules
  92  537A              ; do NOT move these files from this position and
  93  537A              ; do NOT alter their order!
  94  537A                  INCLUDE "../include/dos/dos-1.05.asm"
# file opened: ../include/dos/dos-1.05.asm
   1+ 537A              ; ------------------------------------------------------------------------------
   2+ 537A              ; LM80C 64K - DOS ROUTINES - R1.05
   3+ 537A              ; ------------------------------------------------------------------------------
   4+ 537A              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 537A              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 537A              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 537A              ; kind of warranty: you can use them at your own risk.
   8+ 537A              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 537A              ; maintain the copyright notices, include this advice and the note to the
  10+ 537A              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 537A              ; redistribuite them.
  12+ 537A              ; https://www.leonardomiliani.com
  13+ 537A              ;
  14+ 537A              ; Please support me by visiting the following links:
  15+ 537A              ; Main project page: https://www.leonardomiliani.com
  16+ 537A              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 537A              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 537A              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 537A              ; ------------------------------------------------------------------------------
  20+ 537A              ;
  21+ 537A              ; ------------------------------------------------------------------------------
  22+ 537A              ; Code Revision:
  23+ 537A              ; R1.0  - 20210306 - first release
  24+ 537A              ; R1.01 - 20210309 - code cleaning & optimization - new behaviour for ERASE (full erase everything)
  25+ 537A              ; R1.02 - 20210310 - code optimization - new UNDELETE feature for DISK statement
  26+ 537A              ; R1.03 - 20210316 - code size enhancements
  27+ 537A              ; R1.04 - 20210319 - code re-organization and new positioning into RAM
  28+ 537A              ; R1.05 - 20210327 - added support for sequential files
  29+ 537A              ;
  30+ 537A              ;------------------------------------------------------------------------------
  31+ 537A
  32+ 537A
  33+ 537A                          org     $EE68
  34+ EE68
  35+ EE68              DOSSTART:   equ     $
  36+ EE68 4C 4D 38 30  DSKHDR      defb    "LM80C DOS",$00,"1.05",$00     ; disk header
  36+ EE6C 43 20 44 4F
  36+ EE70 53 00 31 2E
  36+ EE74 30 35 00
  37+ EE77 00 01        DSKDIRADR:  defb    $00,$01                         ; 1st sector of directory ($0001)
  38+ EE79
  39+ EE79              DIR_STRT:   equ     TMPDBF          ; (2) start of directory
  40+ EE79              DAT_STRT:   equ     DIR_STRT+$02    ; (2) start of DATA area
  41+ EE79              DIR_SCT:    equ     DAT_STRT+$02    ; (2) sector of first free entry in the directory
  42+ EE79              NTR_NBR:    equ     DIR_SCT+$02     ; (2) number of free entry
  43+ EE79              BYT_SIZ:    equ     NTR_NBR+$02     ; (2) file size in bytes
  44+ EE79              SCT_SIZ:    equ     BYT_SIZ+$02     ; (1) file size in sectors
  45+ EE79              MSW_SCT:    equ     SCT_SIZ+$01     ; (2) MSW sector of file
  46+ EE79              LSW_SCT:    equ     MSW_SCT+$02     ; (2) LSW sector of file
  47+ EE79              RAM_PTR:    equ     LSW_SCT+$02     ; (2) pointer to RAM
  48+ EE79              TPBF1:      equ     RAM_PTR+$02     ; (2) temp. word
  49+ EE79              TPBF2:      equ     TPBF1+$02       ; (2) temp. word
  50+ EE79              TPBF3:      equ     TPBF2+$02       ; (2) temp. word
  51+ EE79              TPBF4:      equ     TPBF3+$02       ; (2) temp. word
  52+ EE79              SRTMEM:     equ     TPBF4+$02       ; (2) temp. word
  53+ EE79              ENDMEM:     equ     SRTMEM+$02      ; (2) temp. word
  54+ EE79
  55+ EE79
  56+ EE79              ; **************************************************************************************
  57+ EE79              ;                            B A S I C    I N T E R F A C E
  58+ EE79              ;***************************************************************************************
  59+ EE79
  60+ EE79              ; OPEN a sequential file
  61+ EE79              ; OPEN "filename",flnm,mod = open file "filename" with #flnm for READ (mod=0) or WRITE (mod=1)
  62+ EE79 CD EA F1     OPEN:   call    CHKFLNM         ; check if a string follows
  63+ EE7C CD 15 1B             call    CHKSYN          ; Make sure ',' follows
  64+ EE7F 2C                   defb    ','
  65+ EE80 CD 75 2A             call    GETINT          ; get file number
  66+ EE83 32 13 55             ld      (TMPDBF),A      ; store it into a temp buffer
  67+ EE86 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
  68+ EE89 2C                   defb    ','
  69+ EE8A CD 75 2A             call    GETINT          ; get mode
  70+ EE8D FE 02                cp      $02             ; 0 or 1?
  71+ EE8F D2 29 1E             jp      NC,FCERR        ; no, illegal function call
  72+ EE92 32 14 55             ld      (TMPDBF+1),A    ; store it into a temp buffer
  73+ EE95 2B                   dec     HL              ; dec 'cos GETCHR INCs
  74+ EE96 CD 5E 1D             call    GETCHR          ; check if something follows
  75+ EE99 C2 17 18             jp      NZ,SNERR        ; if something more, raise a syntax error
  76+ EE9C E5                   push    HL              ; store code string pointer
  77+ EE9D CD EA F3             call    OPNFIL          ; call open file
  78+ EEA0 E1                   pop     HL              ; retrieve code string pointer
  79+ EEA1 DA 30 F0             jp      C,DOS_ERR       ; any error?
  80+ EEA4 C9                   ret                     ; return to caller
  81+ EEA5
  82+ EEA5
  83+ EEA5              ; CLOSE a file
  84+ EEA5 CD 75 2A     CLOSE:  call    GETINT          ; look for a number
  85+ EEA8 32 13 55             ld      (TMPDBF),A      ; store file number
  86+ EEAB E5                   push    HL              ; store code string pointer
  87+ EEAC CD F4 F4             call    CLOSFIL         ; close an open file
  88+ EEAF E1                   pop     HL              ; retrieve code string pointer
  89+ EEB0 DA 30 F0             jp      C,DOS_ERR
  90+ EEB3 C9                   ret                     ; return to caller
  91+ EEB4
  92+ EEB4
  93+ EEB4              ; LOAD "filename"[,1]  <- load a BASIC program from disk
  94+ EEB4              ; LOAD x,y,w,z         <- load a sector from disc, LBA address equals to ((((z*256)+w)*256)+y)*256)+x
  95+ EEB4 CD 07 EF     LOAD:   call    LDSVPT          ; check what's following
  96+ EEB7 CA D5 EE             jp      Z,LOADST        ; number - load a single sector
  97+ EEBA CD 85 3E             call    DIRMOD          ; a file can be loaded ONLY in direct mode
  98+ EEBD C2 2C 18             jp      NZ,IMERR        ; raise error if in indirect mode
  99+ EEC0 CD F4 F1             call    CHKFN1          ; string - evaluate file name
 100+ EEC3 CD 37 F0             call    CHK1AR          ; check for ",1" argument
 101+ EEC6 22 7C 55             ld      (TMPBFR1),HL    ; store HL
 102+ EEC9 21 F6 EE             ld      HL,TXTLDG       ; loading message
 103+ EECC CD F7 26             call    PRS             ; print
 104+ EECF CD 73 F9             call    LODFILE         ; load file into memory
 105+ EED2 C3 EA EE             jp      LDEND           ; retrieve registers and leave
 106+ EED5 2A 7C 55     LOADST: ld      HL,(TMPBFR1)    ; retrieve HL
 107+ EED8 CD 19 EF             call    GET4AR          ; get 4 arguments
 108+ EEDB 22 7C 55             ld      (TMPBFR1),HL    ; store HL
 109+ EEDE CD 0E FD             call    CF_SETSTR       ; set sector
 110+ EEE1 CD 50 FD             call    CF_RD_SEC       ; read sector
 111+ EEE4 38 0B                jr      C,LDERR         ; load error?
 112+ EEE6 CD 44 FD             call    CF_STANDBY      ; put CF in standby mode
 113+ EEE9 AF                   xor     A               ; clear Carry
 114+ EEEA 2A 7C 55     LDEND:  ld      HL,(TMPBFR1)    ; retrieve HL
 115+ EEED DA 30 F0             jp      C,DOS_ERR       ; jump if DOS error
 116+ EEF0 C9                   ret                     ; return to caller
 117+ EEF1 1E 40        LDERR:  ld      E,D4            ; load error
 118+ EEF3 C3 31 18             jp      ERROR
 119+ EEF6 4C 6F 61 64  TXTLDG: defb    "Loading file... ",0
 119+ EEFA 69 6E 67 20
 119+ EEFE 66 69 6C 65
 119+ EF02 2E 2E 2E 20
 119+ EF06 00
 120+ EF07
 121+ EF07
 122+ EF07              ; common code for LOAD/SAVE to check the type of operation required
 123+ EF07              ; (load/save a file or a single sector)
 124+ EF07              ; returns Z if argument is a number, NZ if it's a string
 125+ EF07 2B           LDSVPT: dec     HL              ; dec 'cos GETCHR INCs
 126+ EF08 CD 5E 1D             call    GETCHR          ; check if something follows
 127+ EF0B CA 17 18             jp      Z,SNERR         ; if anything else, raise a syntax error
 128+ EF0E 22 7C 55             ld      (TMPBFR1),HL    ; save current code string pointer
 129+ EF11 CD 01 22             call    EVAL            ; Evaluate expression
 130+ EF14 3A 0E 55             ld      A,(TYPE)        ; Get variable type
 131+ EF17 B7                   or      A               ; Is it a string variable?
 132+ EF18 C9                   ret                     ; return to caller
 133+ EF19
 134+ EF19
 135+ EF19              ; shared code between LOAD and SAVE
 136+ EF19              ; get 4 arguments after the command LOAD or SAVE
 137+ EF19              ; and load them into appropriate registers
 138+ EF19 2A 7C 55     GET4AR: ld      HL,(TMPBFR1)    ; retrieve string code pointer
 139+ EF1C CD 75 2A             call    GETINT          ; get 1st pointer
 140+ EF1F 32 13 55             ld      (TMPDBF),A      ; store it into a temp buffer
 141+ EF22 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
 142+ EF25 2C                   defb    ','
 143+ EF26 CD 75 2A             call    GETINT          ; get 2nd pointer
 144+ EF29 32 14 55             ld      (TMPDBF+1),A    ; store it into a temp buffer
 145+ EF2C CD 15 1B             call    CHKSYN          ; Make sure ',' follows
 146+ EF2F 2C                   defb    ','
 147+ EF30 CD 75 2A             call    GETINT          ; get 3rd pointer
 148+ EF33 32 15 55             ld      (TMPDBF+2),A    ; store it into a temp buffer
 149+ EF36 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
 150+ EF39 2C                   defb    ','
 151+ EF3A CD 75 2A             call    GETINT          ; get 4th pointer
 152+ EF3D 57                   ld      D,A             ; store it
 153+ EF3E 3A 13 55             ld      A,(TMPDBF)      ; retrieve 1st pointer
 154+ EF41 4F                   ld      C,A
 155+ EF42 3A 14 55             ld      A,(TMPDBF+1)    ; retrieve 2nd pointer
 156+ EF45 47                   ld      B,A
 157+ EF46 3A 15 55             ld      A,(TMPDBF+2)    ; retrieve 3rd pointer
 158+ EF49 5F                   ld      E,A
 159+ EF4A CD CC FC             call    CF_INIT         ; init CF card
 160+ EF4D DA 2F 18             jp      C,NRERR         ; error if device not available/ready
 161+ EF50 C9                   ret                     ; return to caller
 162+ EF51
 163+ EF51
 164+ EF51              ; save a file onto the disk
 165+ EF51              ; syntax: save "filename" to save a BASIC program
 166+ EF51              ; save x,y,z to save IO buffer into x-y-z sector
 167+ EF51              ; save "filename",start,end to save a portion of memory
 168+ EF51 2B           SAVE:   dec     HL              ; dec 'cos GETCHR INCs
 169+ EF52 CD 5E 1D             call    GETCHR          ; check if something follows
 170+ EF55 CA 17 18             jp      Z,SNERR         ; if nothing else, raise a syntax error
 171+ EF58 22 7C 55             ld      (TMPBFR1),HL    ; save current code string pointer
 172+ EF5B CD 01 22             call    EVAL            ; Evaluate expression
 173+ EF5E 3A 0E 55             ld      A,(TYPE)        ; Get variable type
 174+ EF61 B7                   or      A               ; Is it a string variable?
 175+ EF62 CA C0 EF             jp      Z,SAVESCT       ; no - save a single sector
 176+ EF65 CD F4 F1             call    CHKFN1          ; yes, load string name
 177+ EF68 ED 53 82 55          ld      (TMPBFR4),DE    ; store lenght into another buffer
 178+ EF6C ED 43 2C 55          ld      (TPBF4+2),BC    ; store address into another buffer
 179+ EF70 3E 80                ld      A,$80           ; set BAS as file type
 180+ EF72 32 2A 55             ld      (TPBF4),A
 181+ EF75 2B                   dec     HL              ; dec 'cos GETCHR INCs
 182+ EF76 CD 5E 1D             call    GETCHR          ; check if something follows
 183+ EF79 28 30                jr      Z,SAVE1         ; no, jump over
 184+ EF7B CD 15 1B             call    CHKSYN          ; yes - Make sure ',' follows
 185+ EF7E 2C                   defb    ','
 186+ EF7F 22 13 55             ld      (TMPDBF),HL     ; store code string pointer
 187+ EF82 CD 01 22             call    EVAL            ; check expression
 188+ EF85 2A 13 55             ld      HL,(TMPDBF)     ; point back to the beginning of epression
 189+ EF88 3A 0E 55             ld      A,(TYPE)        ; check result type
 190+ EF8B B7                   or      A               ; is it another string?
 191+ EF8C 20 4B                jr      NZ,RENFIL       ; yes, jump to rename file
 192+ EF8E CD EF 21             call    GETNUM          ; no, this is the memory address for a BIN file
 193+ EF91 CD 14 1E             call    DEINT           ; Get integer -32768 to 32767
 194+ EF94 ED 53 2C 55          ld      (SRTMEM),DE     ; Store DE into a temp. buffer
 195+ EF98 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
 196+ EF9B 2C                   defb    ','
 197+ EF9C CD EF 21             call    GETNUM          ; Get memory address
 198+ EF9F CD 14 1E             call    DEINT           ; Get integer -32768 to 32767
 199+ EFA2 ED 53 2E 55          ld      (ENDMEM),DE     ; Store DE into a temp. buffer
 200+ EFA6 3E 81                ld      A,$81           ; set BIN for file type
 201+ EFA8 32 2A 55             ld      (TPBF4),A
 202+ EFAB CD 85 3E     SAVE1:  call    DIRMOD          ; can be executed ONLY in direct mode
 203+ EFAE C2 2C 18             jp      NZ,IMERR        ; raise error if in indirect mode
 204+ EFB1 22 7C 55             ld      (TMPBFR1),HL    ; store code string pointer
 205+ EFB4 21 0C F0             ld      HL,TXTSVG       ; loading message
 206+ EFB7 CD F7 26             call    PRS             ; print
 207+ EFBA CD A9 F7             call    SAVFILE         ; load file into memory
 208+ EFBD C3 D2 EF             jp      SVEND           ; retrieve registers and leave
 209+ EFC0                      ;save a single sector
 210+ EFC0 2A 13 55     SAVESCT:ld      HL,(TMPDBF)     ; retrieve string code pointer
 211+ EFC3 CD 19 EF             call    GET4AR          ; get 4 arguments
 212+ EFC6 22 7C 55             ld      (TMPBFR1),HL    ; store code string pointer
 213+ EFC9 CD 77 FD             call    CF_WR_SEC       ; read sector
 214+ EFCC 38 39                jr      C,SVERR
 215+ EFCE CD 44 FD             call    CF_STANDBY      ; put CF in standby mode
 216+ EFD1 AF                   xor     A               ; clear Carry
 217+ EFD2 2A 7C 55     SVEND:  ld      HL,(TMPBFR1)    ; retrieve code string pointer
 218+ EFD5 DA 30 F0             jp      C,DOS_ERR       ; jump if DOS error
 219+ EFD8 C9                   ret                     ; return to caller
 220+ EFD9 CD 3A 28     RENFIL: call    GSTRCU          ; check that a string follows
 221+ EFDC CD 4B 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
 222+ EFDF ED 53 1B 55          ld      (BYT_SIZ),DE    ; store values into
 223+ EFE3 ED 43 22 55          ld      (RAM_PTR),BC    ; temp buffers
 224+ EFE7 E5                   push    HL              ; store code string pointer
 225+ EFE8 21 F6 EF             ld      HL,TXTRNM       ; point to "renaming file"
 226+ EFEB CD F7 26             call    PRS             ; print string
 227+ EFEE CD DF F8             call    CHNGNAM         ; rename file
 228+ EFF1 E1                   pop     HL              ; retrieve code string pointer
 229+ EFF2 DA 30 F0             jp      C,DOS_ERR       ; any error?
 230+ EFF5 C9                   ret                     ; return to caller
 231+ EFF6 52 65 6E 61  TXTRNM: defb    "Renaming file...",0
 231+ EFFA 6D 69 6E 67
 231+ EFFE 20 66 69 6C
 231+ F002 65 2E 2E 2E
 231+ F006 00
 232+ F007 1E 3E        SVERR:  ld      E,D3            ; save error
 233+ F009 C3 31 18             jp      ERROR
 234+ F00C 53 61 76 69  TXTSVG: defb    "Saving file... ",0
 234+ F010 6E 67 20 66
 234+ F014 69 6C 65 2E
 234+ F018 2E 2E 20 00
 235+ F01C
 236+ F01C
 237+ F01C              ; FILES
 238+ F01C              ; list files on disk
 239+ F01C CD 9F FC     FILES:  call    CLRIOBF         ; clear I/O buffer
 240+ F01F CD CC FC             call    CF_INIT         ; init CF card
 241+ F022 DA 30 F0             jp      C,DOS_ERR       ; error if device not available/ready
 242+ F025 E5                   push    HL              ; store code string pointer
 243+ F026 16 01                ld      D,$01           ; print disk details and file list
 244+ F028 CD 6C F6             call    LST_FILES       ; list files
 245+ F02B E1                   pop     HL              ; retrieve code string pointer
 246+ F02C DA 30 F0             jp      C,DOS_ERR       ; any error?
 247+ F02F C9                   ret                     ; return to caller
 248+ F030
 249+ F030
 250+ F030              ; raise a DOS error
 251+ F030 3A 12 55     DOS_ERR:ld      A,(DOSER)       ; load error code
 252+ F033 5F                   ld      E,A             ; copy into E
 253+ F034 C3 31 18             jp      ERROR           ; goto error routine
 254+ F037
 255+ F037
 256+ F037              ; check for ",1" argument
 257+ F037              ; check if 1 is passed as argument after LOAD and ERASE
 258+ F037 AF           CHK1AR: xor     A               ; reset A
 259+ F038 32 2A 55             ld      (TPBF4),A       ; default setting
 260+ F03B                                              ; (load=store file in RAM using current BASIC pointers
 261+ F03B                                              ; (erase=quick delete)
 262+ F03B 2B                   dec     HL              ; dec 'cause GETCHR increments
 263+ F03C CD 5E 1D             call    GETCHR          ; check if something follows
 264+ F03F C8                   ret     Z               ; if nothing follows, return
 265+ F040 CD 15 1B             call    CHKSYN          ; Make sure ',' follows
 266+ F043 2C                   defb    ','
 267+ F044 CD 75 2A             call    GETINT          ; get a value
 268+ F047 3D                   dec     A               ; decrement it
 269+ F048 C2 17 18             jp      NZ,SNERR        ; not '1' - raise an error
 270+ F04B 3C                   inc     A               ; A=1
 271+ F04C 32 2A 55             ld      (TPBF4),A       ; load=store file in RAM using address in file
 272+ F04F                                              ; erase=full delete
 273+ F04F C9                   ret                     ; return to caller
 274+ F050
 275+ F050
 276+ F050              ; ERASE "filename"
 277+ F050              ; erase a file from disk
 278+ F050 CD EA F1     ERASE:  call    CHKFLNM         ; check for a disk name
 279+ F053 CD 37 F0             call    CHK1AR          ; check for ",1" argument
 280+ F056 E5                   push    HL              ; store code string pointer
 281+ F057 21 7A F0             ld      HL,ERSTX        ; Point to message
 282+ F05A CD F7 26             call    PRS             ; print message for init confirmation
 283+ F05D E1                   pop     HL              ; retrieve HL
 284+ F05E CD C5 F1             call    CNFREQ          ; ask for confirmation
 285+ F061 38 33                jr      C,ABRTDS        ; if Carry set then abort
 286+ F063 CD CC FC             call    CF_INIT         ; init CF card
 287+ F066 DA 30 F0             jp      C,DOS_ERR       ; error if device not available/ready
 288+ F069 E5                   push    HL              ; store code string pointer
 289+ F06A CD 23 FA             call    FIL_ERASE       ; deleted file
 290+ F06D E1                   pop     HL              ; retrieve code string pointer
 291+ F06E DA 30 F0             jp      C,DOS_ERR       ; leave if error
 292+ F071 E5                   push    HL              ; store HL
 293+ F072 21 88 F0             ld      HL,ERASED       ; point to message of file deleted
 294+ F075 CD F7 26             call    PRS             ; print it
 295+ F078 E1                   pop     HL              ; retrieve HL
 296+ F079 C9                   ret                     ; return to caller
 297+ F07A 44 65 6C 65  ERSTX:  defb    "Delete file? ",0
 297+ F07E 74 65 20 66
 297+ F082 69 6C 65 3F
 297+ F086 20 00
 298+ F088 46 69 6C 65  ERASED: defb    "File deleted",CR,0
 298+ F08C 20 64 65 6C
 298+ F090 65 74 65 64
 298+ F094 0D 00
 299+ F096
 300+ F096
 301+ F096              ; disk operation aborted
 302+ F096 3E 01        ABRTDS: ld      A,$01           ; re-enable...
 303+ F098 32 78 55             ld      (PRNTVIDEO),A   ; ...print-on-video
 304+ F09B E5                   push    HL              ; store code string pointer
 305+ F09C 21 A4 F0             ld      HL,ABRTXT       ; Point to message
 306+ F09F CD F7 26             call    PRS             ; print message for leaving init procedure
 307+ F0A2 E1                   pop     HL              ; retrieve code string pointer
 308+ F0A3 C9                   ret                     ; return to caller
 309+ F0A4 0D 41 62 6F  ABRTXT: defb    CR,"Aborted",0
 309+ F0A8 72 74 65 64
 309+ F0AC 00
 310+ F0AD
 311+ F0AD
 312+ F0AD              ; **************************************************************************************
 313+ F0AD              ;                               D O S    R O U T I N E S
 314+ F0AD              ;***************************************************************************************
 315+ F0AD
 316+ F0AD              ; DISK command -------
 317+ F0AD              ; execute several operations on a disk:
 318+ F0AD              ; "F": format/rewrite Master Sector
 319+ F0AD              ; "R": rename disk
 320+ F0AD              ; "W": rewrite Master Sector
 321+ F0AD              ; "U": undelete deleted files
 322+ F0AD              ; syntax: DISK "arg1"[,"arg2"]
 323+ F0AD              TPHL:   equ     TMPDBF          ; temp. buffer for code string pointer
 324+ F0AD CD 85 3E     DISK:   call    DIRMOD          ; can be executed ONLY in direct mode
 325+ F0B0 C2 2C 18             jp      NZ,IMERR        ; raise error if in indirect mode
 326+ F0B3                      ; check first argument
 327+ F0B3 2B                   dec     HL              ; dec 'cause GETCHR increments
 328+ F0B4 CD 5E 1D             call    GETCHR          ; check if something follows
 329+ F0B7 CA 17 18             jp      Z,SNERR         ; if nothing else, raise a syntax error
 330+ F0BA CD 01 22             call    EVAL            ; Evaluate expression
 331+ F0BD CD F3 21             call    TSTSTR          ; Make sure it's a string
 332+ F0C0 22 13 55             ld      (TPHL),HL       ; store code string pointer into a temp buffer
 333+ F0C3 CD 3A 28             call    GSTRCU          ; check that a string follows
 334+ F0C6 CD 4B 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
 335+ F0C9 7B                   ld      A,E
 336+ F0CA 3D                   dec     A               ; lenght must be = 1
 337+ F0CB 2A 13 55             ld      HL,(TPHL)       ; retrieve code string pointer
 338+ F0CE C2 17 18             jp      NZ,SNERR
 339+ F0D1 AF                   xor     A
 340+ F0D2 32 2A 55             ld      (TPBF4),A       ; set default to full format
 341+ F0D5 0A                   ld      A,(BC)          ; load command
 342+ F0D6 E6 5F                and     %01011111       ; Force upper case
 343+ F0D8 FE 46                cp      'F'             ; format command?
 344+ F0DA CA F4 F0             jp      Z,DSKFRM        ; yes
 345+ F0DD FE 57                cp      'W'             ; rewrite master sector?
 346+ F0DF CA EF F0             jp      Z,RWMSSC        ; yes
 347+ F0E2 FE 52                cp      'R'             ; rename command?
 348+ F0E4 CA 93 F1             jp      Z,DSKRNM        ; yes
 349+ F0E7 FE 55                cp      'U'             ; undelete command?
 350+ F0E9 CA 83 F1             jp      Z,DSKUND        ; yes
 351+ F0EC C3 17 18             jp      SNERR           ; nothing more - raise a syntax error
 352+ F0EF
 353+ F0EF
 354+ F0EF              ; Format disk or rewrite Master sector
 355+ F0EF              ; syntax: DISK "F/W","disk name"
 356+ F0EF              ; "F" -> format disk, "W" -> rewrite master sector
 357+ F0EF              ; "disk name" is the name -> max 16 chars, allowed chars: "A" to "Z", "0" to "9","-", SPACE
 358+ F0EF              ; Format: set up a fresh new file system, creating the Master Sector and
 359+ F0EF              ; initializing the directory
 360+ F0EF              ; Master Sector rewriting: re-initialize the Master Sector, writing a new disk name and
 361+ F0EF              ; re-calculating disk geometry
 362+ F0EF              DKNMPT: equ     TMPBFR2         ; store the pointer to the disk name string
 363+ F0EF              DKLNPT: equ     TMPBFR3         ; store the pointer to the lenght of disk name string
 364+ F0EF 3E 01        RWMSSC  ld      A,$01           ; set rewriting of master sector
 365+ F0F1 32 2A 55             ld      (TPBF4),A
 366+ F0F4 CD 15 1B     DSKFRM: call    CHKSYN          ; Make sure ',' follows
 367+ F0F7 2C                   defb    ','
 368+ F0F8 CD EA F1             call    CHKFLNM         ; check for file name
 369+ F0FB 11 3E F1             ld      DE,MSTTXT       ; format message
 370+ F0FE 3A 2A 55             ld      A,(TPBF4)       ; check for type of operation
 371+ F101 B7                   or      A               ; A=0 (full format)?
 372+ F102 20 03                jr      NZ,CFINIT       ; no, jump over
 373+ F104 11 56 F1             ld      DE,FRMTXT       ; rewrite Master Sector
 374+ F107 E5           CFINIT: push    HL              ; store code string pointer
 375+ F108 62                   ld      H,D             ; Point to message
 376+ F109 6B                   ld      L,E
 377+ F10A CD F7 26             call    PRS             ; print message for confirmation
 378+ F10D E1                   pop     HL              ; retrieve HL
 379+ F10E CD C5 F1             call    CNFREQ          ; ask for confirmation
 380+ F111 DA 96 F0             jp      C,ABRTDS        ; if Carry set then abort
 381+ F114 CD CC FC             call    CF_INIT         ; init CF card
 382+ F117 DA 30 F0             jp      C,DOS_ERR       ; error if device not available/ready
 383+ F11A E5                   push    HL              ; store code string pointer
 384+ F11B CD 11 F2             call    DSK_INIT        ; init disk
 385+ F11E E1                   pop     HL              ; retrieve code string pointer
 386+ F11F DA 30 F0             jp      C,DOS_ERR       ; if Carry set, raise error
 387+ F122 E5                   push    HL              ; store code string pointer
 388+ F123 3A 7C 55             ld      A,(TMPBFR1)
 389+ F126 B7                   or      A               ; full formatting?
 390+ F127 20 0D                jr      NZ,MSPTOK       ; no
 391+ F129 21 6E F1             ld      HL,OPRCMP       ; yes, Point to message
 392+ F12C CD F7 26             call    PRS             ; print message for init confirmation
 393+ F12F 16 00                ld      D,$00           ; print only disk details, no file list
 394+ F131 CD 6C F6             call    LST_FILES       ; print details of disk and list files
 395+ F134 E1                   pop     HL              ; retrieve code string pointer
 396+ F135 C9                   ret                     ; return to caller
 397+ F136 21 6E F1     MSPTOK: ld      HL,OPRCMP       ; format OK message
 398+ F139 CD F7 26             call    PRS             ; print message for init confirmation
 399+ F13C E1                   pop     HL              ; retrieve code string pointer
 400+ F13D C9                   ret                     ; return to caller
 401+ F13E 52 65 77 72  MSTTXT: defb    "Rewrite Master Sector? ",0
 401+ F142 69 74 65 20
 401+ F146 4D 61 73 74
 401+ F14A 65 72 20 53
 401+ F14E 65 63 74 6F
 401+ F152 72 3F 20 00
 402+ F156 57 41 52 4E  FRMTXT: defb    "WARNING!! Format disk? ",0
 402+ F15A 49 4E 47 21
 402+ F15E 21 20 46 6F
 402+ F162 72 6D 61 74
 402+ F166 20 64 69 73
 402+ F16A 6B 3F 20 00
 403+ F16E 4F 70 65 72  OPRCMP: defb    "Operation completed",CR,0
 403+ F172 61 74 69 6F
 403+ F176 6E 20 63 6F
 403+ F17A 6D 70 6C 65
 403+ F17E 74 65 64 0D
 403+ F182 00
 404+ F183
 405+ F183
 406+ F183              ; undelete files
 407+ F183              ; look for files marked as "deleted" and undelete them
 408+ F183 2B           DSKUND: dec     HL              ; dec 'cause GETCHR increments
 409+ F184 CD 5E 1D             call    GETCHR          ; check if something follows
 410+ F187 C2 17 18             jp      NZ,SNERR        ; if something else, raise a syntax error
 411+ F18A E5                   push    HL              ; store code string pointer
 412+ F18B CD E5 FA             call    DSKUNDFL        ; undelete files
 413+ F18E E1                   pop     HL              ; retrieve code string pointer
 414+ F18F DA 30 F0             jp      C,DOS_ERR       ; DOS error
 415+ F192 C9                   ret                     ; return to caller
 416+ F193
 417+ F193
 418+ F193              ; disk rename
 419+ F193              ; change the name of the disk w/o altering anything else
 420+ F193 CD 15 1B     DSKRNM: call    CHKSYN          ; Make sure ',' follows
 421+ F196 2C                   defb    ','
 422+ F197 CD EA F1             call    CHKFLNM         ; check for file name
 423+ F19A E5                   push    HL              ; store code string pointer
 424+ F19B 21 B7 F1             ld      HL,RNDKTX       ; Point to message
 425+ F19E CD F7 26             call    PRS             ; print message for confirmation
 426+ F1A1 E1                   pop     HL              ; retrieve HL
 427+ F1A2 CD C5 F1             call    CNFREQ          ; ask for confirmation
 428+ F1A5 DA 96 F0             jp      C,ABRTDS        ; if Carry set then abort
 429+ F1A8 CD CC FC             call    CF_INIT         ; init CF card
 430+ F1AB DA 30 F0             jp      C,DOS_ERR       ; error if device not available/ready
 431+ F1AE E5                   push    HL              ; store code string pointer
 432+ F1AF CD 49 F3             call    DSK_RNM         ; init disk
 433+ F1B2 E1                   pop     HL              ; retrieve code string pointer
 434+ F1B3 DA 30 F0             jp      C,DOS_ERR       ; DOS error
 435+ F1B6 C9                   ret
 436+ F1B7 52 65 6E 61  RNDKTX: defb    "Rename disk? ",0
 436+ F1BB 6D 65 20 64
 436+ F1BF 69 73 6B 3F
 436+ F1C3 20 00
 437+ F1C5
 438+ F1C5
 439+ F1C5              ; confirmation required by the user ('y' or 'Y' DO confirm, otherwise DON'T)
 440+ F1C5 CD 2D 09     CNFREQ: call    CURSOR_ON       ; enable cursor
 441+ F1C8 AF                   xor     A
 442+ F1C9 32 78 55             ld      (PRNTVIDEO),A   ; disable print-on-video
 443+ F1CC CD 2A 02             call    RXA             ; look for a pressed key
 444+ F1CF FE 03                cp      CTRLC           ; is it RUN STOP?
 445+ F1D1 28 15                jr      Z,CNFRQN        ; yes, abort operation
 446+ F1D3 E6 DF                and     %11011111       ; only UPPERCASE char
 447+ F1D5 FE 59                cp      'Y'             ; 'Y'?
 448+ F1D7 20 0F                jr      NZ,CNFRQN       ; no, abort operation
 449+ F1D9 08                   ex      AF,AF'          ; store char into A'
 450+ F1DA 3E 01                ld      A,$01           ; re-enable...
 451+ F1DC 32 78 55             ld      (PRNTVIDEO),A   ; ...print-on-video
 452+ F1DF 08                   ex      AF,AF'          ; retrieve char from A'
 453+ F1E0 CD 1C 03             call    ECHO_CHAR       ; yes, echoes the char
 454+ F1E3 CD 42 09             call    CURSOR_OFF      ; disable cursor
 455+ F1E6 AF                   xor     A               ; reset Carry flag
 456+ F1E7 C9                   ret                     ; return to caller
 457+ F1E8 37           CNFRQN: scf                     ; set Carry flag
 458+ F1E9 C9                   ret                     ; return to caller
 459+ F1EA
 460+ F1EA
 461+ F1EA              ; check that a disk/file name follows
 462+ F1EA 2B           CHKFLNM:dec     HL              ; dec 'cause GETCHR increments
 463+ F1EB CD 5E 1D             call    GETCHR          ; check if something follows
 464+ F1EE CA 17 18             jp      Z,SNERR         ; if nothing else, raise a syntax error
 465+ F1F1 CD 01 22             call    EVAL            ; Evaluate expression
 466+ F1F4 CD F3 21     CHKFN1: call    TSTSTR          ; Make sure it's a string
 467+ F1F7 22 15 55             ld      (TMPDBF+2),HL   ; store code string pointer into a temp buffer
 468+ F1FA CD 3A 28             call    GSTRCU          ; get current string into pool
 469+ F1FD CD 4B 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
 470+ F200 7B                   ld      A,E             ; check if lenght = 0
 471+ F201 A7                   and     A               ; null string?
 472+ F202 CA 17 18             jp      Z,SNERR         ; yes, syntax error
 473+ F205 ED 53 80 55          ld      (DKLNPT),DE     ; no, store lenght
 474+ F209 ED 43 7E 55          ld      (DKNMPT),BC     ; store address of temp string
 475+ F20D 2A 15 55             ld      HL,(TMPDBF+2)   ; retrieve code string pointer
 476+ F210 C9                   ret                     ; return to caller
 477+ F211
 478+ F211
 479+ F211              ; *****************************************************************************
 480+ F211              ; D I S K    I N I T
 481+ F211              ; Functions: format a disk creating a fresh new file system on disk or
 482+ F211              ;            rewrite only the Master Sector
 483+ F211              ; *****************************************************************************
 484+ F211 CD 6A FB     DSK_INIT:   call    CHKSQFL         ; check if a seq. file is open
 485+ F214 C2 18 F6                 jp      NZ,FILOPCLER    ; jump if open
 486+ F217 3A 2A 55                 ld      A,(TPBF4)       ; load type of formatting
 487+ F21A 32 7C 55                 ld      (TMPBFR1),A     ; save onto another location for later use
 488+ F21D CD 9F FC                 call    CLRIOBF         ; clear I/O buffer
 489+ F220 CD B4 FC                 call    CLRDOSBF        ; clear DOS buffer
 490+ F223 3E E0                    ld 	    A,$E0           ; select CF as master, driver 0, LBA mode (bits #5-7=111)
 491+ F225 D3 56                    out     (CF_LBA3),A     ; send configuration
 492+ F227 3E EC                    ld      A,$EC           ; select "drive ID" command
 493+ F229 D3 57                    out     (CF_CMD),A      ; send command
 494+ F22B CD 01 FD                 call    CF_DAT_RDY      ; wait until data is ready to be read
 495+ F22E CD 63 FD                 call    CF_RD_CMD       ; read data and store into I/O buffer
 496+ F231 11 A0 FD                 ld      DE,DOSBFR       ; address of default conf. buffer
 497+ F234 21 C0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
 498+ F237 01 0E 00                 ld      BC,$000E        ; position of current disk size in sectors
 499+ F23A 09                       add     HL,BC           ; set into HL
 500+ F23B 0E 04                    ld      C,$04           ; 4 bytes to copy
 501+ F23D ED B0                    ldir                    ; copy (DE is auto-incremented)
 502+ F23F 21 C0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
 503+ F242 01 02 00                 ld      BC,$0002        ; 2 bytes to copy and also address of number of cylinders
 504+ F245 09                       add     HL,BC           ; get position of data
 505+ F246 ED B0                    ldir                    ; copy (DE is auto-incremented)
 506+ F248 21 C0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
 507+ F24B 01 0C 00                 ld      BC,$000C        ; address of number of sectors per cylinder
 508+ F24E 09                       add     HL,BC           ; get position of data
 509+ F24F 0E 02                    ld      C,$02           ; 2 bytes to copy
 510+ F251 ED B0                    ldir                    ; copy (DE is auto-incremented)
 511+ F253 21 C0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
 512+ F256 01 06 00                 ld      BC,$0006        ; address of number of heads
 513+ F259 09                       add     HL,BC           ; get position of data
 514+ F25A 0E 02                    ld      C,$02           ; 2 bytes to copy
 515+ F25C ED B0                    ldir                    ; copy (DE is auto-incremented)
 516+ F25E                          ; now we calculate the # of files allowed (1 file = 1 block = 64K)
 517+ F25E ED 53 2A 55              ld      (TPBF4),DE      ; store current pointer to temp. default conf. buffer
 518+ F262 21 A0 FD                 ld      HL,DOSBFR       ; load number of sectors
 519+ F265 4E                       ld      C,(HL)          ; MSW into AC
 520+ F266 23                       inc     HL
 521+ F267 7E                       ld      A,(HL)
 522+ F268 23                       inc     HL
 523+ F269 5E                       ld      E,(HL)          ; LSW into DE
 524+ F26A 23                       inc     HL
 525+ F26B 56                       ld      D,(HL)
 526+ F26C D5                       push    DE              ; move DE into IX
 527+ F26D DD E1                    pop     IX
 528+ F26F 11 80 00                 ld      DE,$0080        ; 128 sectors per block
 529+ F272 CD B7 41                 call    DIV_32_16       ; execute ACIX/DE; result is into ACIX, remainder into HL
 530+ F275 47                       ld      B,A             ; now result is into BCIX
 531+ F276 B1                       or      C               ; BC=$0000?
 532+ F277 28 05                    jr      Z,DOS_FTC       ; yes, but.....
 533+ F279 11 FF FF                 ld      DE,$FFFF        ; ... no more than $FFFF files, so set limit
 534+ F27C 18 0E                    jr      DOS_FT1         ; jump over
 535+ F27E DD E5        DOS_FTC:    push    IX              ; move IX into DE
 536+ F280 D1                       pop     DE              ; now result is into BCDE
 537+ F281 7C                       ld      A,H             ; remainder = zero?
 538+ F282 B5                       or      L
 539+ F283 CA 8C F2                 jp      Z,DOS_FT1       ; yes, jump over
 540+ F286 13                       inc     DE              ; no, increment DE
 541+ F287 7A                       ld      A,D             ; check if DE is zero
 542+ F288 B3                       or      E
 543+ F289 20 01                    jr      NZ,DOS_FT1      ; no, jump over
 544+ F28B 1B                       dec     DE              ; yes, so set files to limit of $FFFF
 545+ F28C 2A 2A 55     DOS_FT1:    ld      HL,(TPBF4)      ; retrieve current pointer to temp. def. conf. buffer
 546+ F28F CD 63 FC                 call    DE2HL           ; store # of entries
 547+ F292 D5                       push    DE              ; store entries
 548+ F293 EB                       ex      DE,HL           ; copy current pointer into DE
 549+ F294 21 77 EE                 ld      HL,DSKDIRADR    ; address of directory start
 550+ F297 01 02 00                 ld      BC,$0002        ; 2 bytes to copy
 551+ F29A ED B0                    ldir                    ; copy into buffer
 552+ F29C                          ; now we calculate the starting sector of data area
 553+ F29C E1                       pop     HL              ; entries into HL
 554+ F29D 0E 10                    ld      C,$10           ; 16 entries per sector
 555+ F29F CD 93 41                 call    DIV_16_8        ; calculare how many sectors for dir (HL/C)
 556+ F2A2 B7                       or      A               ; remainder = 0?
 557+ F2A3 28 01                    jr      Z,DOS_FT2       ; yes, jump over
 558+ F2A5 23                       inc     HL              ; increment sectors
 559+ F2A6 E5           DOS_FT2:    push    HL              ; store size of directory
 560+ F2A7 FD E1                    pop     IY              ; into IY
 561+ F2A9 23                       inc     HL              ; data area is 1 sector bigger than directory's size
 562+ F2AA EB                       ex      DE,HL           ; restore pointer into HL, and move sectors into DE
 563+ F2AB 73                       ld      (HL),E          ; store starting of
 564+ F2AC 23                       inc     HL              ; data area
 565+ F2AD 72                       ld      (HL),D          ; into buffer
 566+ F2AE                          ; now clean again the I/O buffer and copy the configuration into I/O buffer
 567+ F2AE CD 9F FC                 call    CLRIOBF         ; clear I/O buffer
 568+ F2B1 21 68 EE                 ld      HL,DSKHDR       ; address of disk header string
 569+ F2B4 11 C0 FD                 ld      DE,IOBUFF       ; address of I/O buffer
 570+ F2B7 01 0F 00                 ld      BC,$000F        ; 15 chars
 571+ F2BA ED B0                    ldir                    ; copy header into buffer
 572+ F2BC 21 A0 FD                 ld      HL,DOSBFR       ; first part of configuration
 573+ F2BF 01 10 00                 ld      BC,$0010        ; composed by 16 chars
 574+ F2C2 ED B0                    ldir                    ; copy (DE is auto-incremented)
 575+ F2C4 AF                       xor     A               ; A=$0
 576+ F2C5 12                       ld      (DE),A          ; marker at $1F
 577+ F2C6 13                       inc     DE
 578+ F2C7 CD 3B FC                 call    CHKNMVAL        ; copy disk name into buffer
 579+ F2CA DA 27 F6                 jp      C,NAMERR        ; disk name error
 580+ F2CD CD C3 FB                 call    RND_ID          ; generate a semi-random disk ID
 581+ F2D0 21 C0 FD                 ld      HL,IOBUFF       ; get starting address of I/O buffer
 582+ F2D3 54                       ld      D,H             ; copy into DE...
 583+ F2D4 5D                       ld      E,L             ; ...for later use
 584+ F2D5 01 FE 01                 ld      BC,$01FE        ; get address of last 2 bytes...
 585+ F2D8 09                       add     HL,BC           ; ...of the I/O buffer
 586+ F2D9 3E 38                    ld      A,'8'           ; write marker "80"
 587+ F2DB 77                       ld      (HL),A          ; ...
 588+ F2DC 23                       inc     HL              ; ...
 589+ F2DD 3E 30                    ld      A,'0'           ; ...
 590+ F2DF 77                       ld      (HL),A          ; ...into last 2 locations
 591+ F2E0 EB                       ex      DE,HL           ; copy beginning of I/O buffer from DE into HL
 592+ F2E1 AF                       xor     A               ; reset A - set sector # to $00000000
 593+ F2E2 47                       ld      B,A             ; LBA0=0
 594+ F2E3 4F                       ld      C,A             ; LBA1=0
 595+ F2E4 57                       ld      D,A             ; LBA2=0
 596+ F2E5 5F                       ld      E,A             ; LBA3=0
 597+ F2E6 CD 77 FD                 call    CF_WR_SEC       ; write sector to CF
 598+ F2E9 DA 1E F6                 jp      C,D2ERR
 599+ F2EC                          ; check if only re-writing of Master Sector was need
 600+ F2EC 3A 7C 55                 ld      A,(TMPBFR1)     ; retrieve type of formatting
 601+ F2EF 3D                       dec     A               ; A=1?
 602+ F2F0 C8                       ret     Z               ; yes, finished job
 603+ F2F1                          ; erase directory -----------------------------
 604+ F2F1                          ; create a progress bar
 605+ F2F1 3E 0D                    ld      A,CR            ; no, full format - go to new line
 606+ F2F3 CD 20 1B                 call    OUTC
 607+ F2F6 FD E5                    push    IY              ; copy directory's size...
 608+ F2F8 E1                       pop     HL              ; ...into HL
 609+ F2F9 01 18 00                 ld      BC,$0018        ; 24 steps
 610+ F2FC CD 93 41                 call    DIV_16_8        ; calculate HL/24 (remainder is ignored, here)
 611+ F2FF E5                       push    HL              ; store result...
 612+ F300 DD E1                    pop     IX              ; ...into IX...
 613+ F302 EB                       ex      DE,HL           ; ...and into DE
 614+ F303 3E 2D                    ld      A,'-'           ; print a progress bar
 615+ F305 CD 41 F3                 call    DOS_FT7         ; print it
 616+ F308 3E 1C                    ld      A,CRSLFT        ; CURSOR left
 617+ F30A CD 41 F3                 call    DOS_FT7         ; come back to beginning of line
 618+ F30D FD E5                    push    IY              ; copy directory's size
 619+ F30F E1                       pop     HL              ; into HL
 620+ F310 01 01 00                 ld      BC,$0001        ; first sector of directory
 621+ F313 CD 9F FC                 call    CLRIOBF         ; clear I/O buffer
 622+ F316 D5           DOS_FTA:    push    DE              ; store counter
 623+ F317 11 00 00                 ld      DE,$0000        ; reset MSW of sector pointer
 624+ F31A CD 77 FD                 call    CF_WR_SEC       ; write sector to CF
 625+ F31D DA 3D F3                 jp      C,DOS_FT10      ; error occured
 626+ F320 03                       inc     BC              ; next sector
 627+ F321 2B                       dec     HL              ; decrement HL
 628+ F322 D1                       pop     DE              ; retrieve counter
 629+ F323 1B                       dec     DE              ; decrement counter
 630+ F324 7B                       ld      A,E
 631+ F325 B2                       or      D               ; check if counter is zero
 632+ F326 20 08                    jr      NZ,DOS_FT9      ; no, jump over
 633+ F328 3E 2A                    ld      A,'*'           ; yes, print char
 634+ F32A CD 20 1B                 call    OUTC
 635+ F32D DD E5                    push    IX              ; re-set counter
 636+ F32F D1                       pop     DE
 637+ F330 7C           DOS_FT9:    ld      A,H             ; check if...
 638+ F331 B5                       or      L               ; ...HL = 0
 639+ F332 20 E2                    jr      NZ,DOS_FTA      ; if not, repeat
 640+ F334 3E 0D                    ld      A,CR            ; return
 641+ F336 CD 20 1B                 call    OUTC            ; next line
 642+ F339 CD 44 FD                 call    CF_STANDBY      ; set CF into stand-by mode
 643+ F33C C9                       ret
 644+ F33D D1           DOS_FT10:   pop     DE
 645+ F33E C3 1E F6                 jp      D2ERR           ; disk geometry error
 646+ F341
 647+ F341              ; print a char 24 times
 648+ F341 06 18        DOS_FT7:    ld      B,$18           ; 24 times
 649+ F343 CD 20 1B     DOS_FT8:    call    OUTC            ; print char
 650+ F346 10 FB                    djnz    DOS_FT8         ; repeat
 651+ F348 C9                       ret                     ; return to caller
 652+ F349
 653+ F349
 654+ F349              ; *****************************************************************************
 655+ F349              ; D I S K    R E N A M E
 656+ F349              ;******************************************************************************
 657+ F349 CD 03 FC     DSK_RNM:    call    CHKDSKVAL       ; check DOS version & load disk details
 658+ F34C DA 30 F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
 659+ F34F CD 9F FC                 call    CLRIOBF         ; clear I/O buffer
 660+ F352 CD B4 FC                 call    CLRDOSBF        ; clear DOS buff.
 661+ F355 CD B7 FB                 call    LDMSCT          ; load Master Sector
 662+ F358 21 C0 FD                 ld      HL,IOBUFF       ; point to start of I/O buffer
 663+ F35B 01 20 00                 ld      BC,$0020        ; offset for disk name
 664+ F35E 09                       add     HL,BC           ; get pointer
 665+ F35F EB                       ex      DE,HL           ; copy pointer into DE
 666+ F360 CD 3B FC                 call    CHKNMVAL        ; copy disk name into buffer
 667+ F363 DA 27 F6                 jp      C,NAMERR        ; disk name error
 668+ F366 11 00 00                 ld      DE,$0000        ; reset MSW sector
 669+ F369 42                       ld      B,D             ; reset LSW sector
 670+ F36A 4A                       ld      C,D
 671+ F36B CD 77 FD                 call    CF_WR_SEC       ; write sector
 672+ F36E DA 9B FA                 jp      C,WRT_ERR       ; error?
 673+ F371 C9                       ret                     ; no, return to caller
 674+ F372
 675+ F372
 676+ F372              ; *****************************************************************************
 677+ F372              ; PUT A CHAR INTO A SEQUENTIAL FILE
 678+ F372              ; when the buffer is full, it writes it on the disk,
 679+ F372              ; then move to another sector
 680+ F372              ; *****************************************************************************
 681+ F372 CD 6A FB     PUTFIL:     call    CHKSQFL         ; is there a seq. file open?
 682+ F375 CA 18 F6                 jp      Z,FILOPCLER     ; no, raise an error
 683+ F378 47                       ld      B,A             ; copy file number into B
 684+ F379 3A 13 55                 ld      A,(TMPDBF)      ; load argument
 685+ F37C B8                       cp      B               ; are they equal?
 686+ F37D C2 2A F6                 jp      NZ,FLNTFND      ; file not found
 687+ F380 3A D7 FF                 ld      A,(SEQFLS)      ; check access mode
 688+ F383 B7                       or      A               ; only reading?
 689+ F384 3E 3E                    ld      A,D3            ; prepare a save error
 690+ F386 CA 32 F6                 jp      Z,RET_ERR       ; yes, error
 691+ F389                          ; store byte
 692+ F389 ED 5B DD FF              ld      DE,(SEQBYSZ)    ; load size in bytes
 693+ F38D 13                       inc     DE              ; increment file size
 694+ F38E 7B                       ld      A,E             ; check if...
 695+ F38F B2                       or      D               ; ...rolled back to $0000
 696+ F390 CA 21 F6                 jp      Z,DSKFULL       ; yes, block is full
 697+ F393 ED 53 DD FF              ld      (SEQBYSZ),DE    ; no, store new size
 698+ F397 2A DF FF                 ld      HL,(SEQPNT)     ; pointer to byte
 699+ F39A 11 C0 FD                 ld      DE,IOBUFF       ; load starting address of I/O buffer
 700+ F39D 44                       ld      B,H             ; copy byte pointer...
 701+ F39E 4D                       ld      C,L             ; ...to BC
 702+ F39F 19                       add     HL,DE           ; point to new location
 703+ F3A0 3A 14 55                 ld      A,(TMPDBF+1)    ; retrieve byte
 704+ F3A3 77                       ld      (HL),A          ; store it
 705+ F3A4 03                       inc     BC              ; increment byte pointer
 706+ F3A5 ED 43 DF FF              ld      (SEQPNT),BC     ; store it
 707+ F3A9 CD AE F3                 call    PUTNXSC         ; check if I/O buffer is full
 708+ F3AC AF                       xor     A               ; clear Carry
 709+ F3AD C9                       ret                     ; return to caller
 710+ F3AE                          ; check if I/O buffer is full
 711+ F3AE                          ; if yes, store buffer and goto a new sector
 712+ F3AE 11 00 02     PUTNXSC:    ld      DE,$0200        ; max buffer size
 713+ F3B1 2A DF FF                 ld      HL,(SEQPNT)     ; pointer to byte
 714+ F3B4 CD 38 41                 call    CMP16           ; check if pointer < $200
 715+ F3B7 D8                       ret     C               ; yes, return
 716+ F3B8 ED 4B DA FF              ld      BC,(SEQSCTL)    ; load LSW of sector address
 717+ F3BC ED 5B D8 FF              ld      DE,(SEQSCTM)    ; load MSW of sector address
 718+ F3C0 CD 77 FD                 call    CF_WR_SEC       ; write buffer into sector
 719+ F3C3 3A DC FF                 ld      A,(SEQSCSZ)     ; load size in sectors
 720+ F3C6 3C                       inc     A               ; we need another sector
 721+ F3C7 67                       ld      H,A             ; store A into H
 722+ F3C8 FE 81                    cp      $81             ; A>128?
 723+ F3CA 3E 42                    ld      A,D5            ; prepare a disk full error
 724+ F3CC D2 10 F6                 jp      NC,GETER        ; yes, raise an error
 725+ F3CF 7C                       ld      A,H             ; no, retrieve sector counter
 726+ F3D0 32 DC FF                 ld      (SEQSCSZ),A     ; store new size in sectors
 727+ F3D3 21 00 00                 ld      HL,$0000        ; reset pointer
 728+ F3D6 22 DF FF                 ld      (SEQPNT),HL
 729+ F3D9 03                       inc     BC              ; next sector
 730+ F3DA 79                       ld      A,C             ; check if BC is rolled back to zero (overflow)
 731+ F3DB B0                       or      B
 732+ F3DC 20 05                    jr      NZ,PUTFIL2      ; no, jump over
 733+ F3DE 13                       inc     DE              ; yes, increment MSW of sector address
 734+ F3DF ED 53 D8 FF              ld      (SEQSCTM),DE    ; save new MSW of sector address
 735+ F3E3 ED 43 DA FF  PUTFIL2:    ld      (SEQSCTL),BC    ; save new LSW of sector address
 736+ F3E7 C3 90 F4                 jp      OPNFRD1         ; load sector and return
 737+ F3EA
 738+ F3EA
 739+ F3EA              ; *****************************************************************************
 740+ F3EA              ; OPEN A SEQUENTIAL FILE
 741+ F3EA              ; open a sequential file for read/write operations
 742+ F3EA              ; if file already exists, it appends new data at the end of the file
 743+ F3EA              ;******************************************************************************
 744+ F3EA CD 03 FC     OPNFIL:     call    CHKDSKVAL       ; check DOS version & load disk details
 745+ F3ED DA 30 F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
 746+ F3F0 CD 6A FB                 call    CHKSQFL         ; check if there is a file already opened
 747+ F3F3 C2 1B F6                 jp      NZ,FILALROP     ; yes, jump over
 748+ F3F6 CD C0 FC                 call    CLRSEQBF        ; clear seq. file buffer
 749+ F3F9 3A 13 55                 ld      A,(TMPDBF)      ; recover file number and...
 750+ F3FC 32 D6 FF                 ld      (SEQFL),A       ; ...store it
 751+ F3FF 3A 14 55                 ld      A,(TMPDBF+1)    ; load access mode
 752+ F402 32 D7 FF                 ld      (SEQFLS),A      ; store access mode
 753+ F405                          ; open file
 754+ F405 CD 9F FC                 call    CLRIOBF         ; clear I/O
 755+ F408 CD 41 F9                 call    CHKFLEXT        ; check if file already exists
 756+ F40B 1E 00                    ld      E,$00           ; reset E
 757+ F40D CB 13                    rl      E               ; store Carry into E (0=file not exists, 1=file exists)
 758+ F40F 3A D7 FF                 ld      A,(SEQFLS)      ; load access mode (0=read, 1=create/append)
 759+ F412 B3                       or      E               ; if read mode and file not exist...
 760+ F413 CA 2A F6                 jp      Z,FLNTFND       ; ...raise a file not found error
 761+ F416 3A D7 FF                 ld      A,(SEQFLS)      ; reload access mode (0=read, 1=create/append)
 762+ F419 B7                       or      A               ; read mode?
 763+ F41A 28 7F                    jr      Z,OPFLRS        ; yes, open file for read
 764+ F41C                          ; open file for writing
 765+ F41C 7B                       ld      A,E             ; no, open file for save
 766+ F41D B7                       or      A               ; check if file exists
 767+ F41E 20 46                    jr      NZ,OPNFRD       ; file exists, open for append
 768+ F420                          ; open file for creating (new file)
 769+ F420 CD 9F FC                 call    CLRIOBF         ; clear I/O buffer
 770+ F423 CD 32 FB                 call    FNDFRENTR       ; file doesn't exist, find a free entry in the directory
 771+ F426 DA 21 F6                 jp      C,DSKFULL       ; no entry, disk full error
 772+ F429 3E 82                    ld      A,$82           ; set seq. file type
 773+ F42B 32 2A 55                 ld      (TPBF4),A
 774+ F42E 3E 01                    ld      A,$01           ; set initial size to 1 sector
 775+ F430 32 DC FF                 ld      (SEQSCSZ),A     ; store it for seq. file manager
 776+ F433 32 1D 55                 ld      (SCT_SIZ),A     ; store it for DOS, too
 777+ F436 21 00 00                 ld      HL,$0000        ; set initial file size to 0 bytes
 778+ F439 22 1B 55                 ld      (BYT_SIZ),HL    ; store it for DOS
 779+ F43C 22 2C 55                 ld      (SRTMEM),HL     ; RAM starting address set to 0 (seq. file is not saved/loaded from/into RAM)
 780+ F43F CD 5E F8                 call    SVENTRY         ; save entry into directory
 781+ F442 ED 5B 1E 55              ld      DE,(MSW_SCT)    ; store MSW of sector address for DOS
 782+ F446 ED 53 D8 FF              ld      (SEQSCTM),DE    ; also for seq. file manager
 783+ F44A ED 4B 20 55              ld      BC,(LSW_SCT)    ; store LSW of sector address for DOS
 784+ F44E ED 43 DA FF              ld      (SEQSCTL),BC    ; also for seq. file manager
 785+ F452 CD E8 F4                 call    SVSQFLNM        ; store name
 786+ F455 CD 9F FC                 call    CLRIOBF         ; clear I/O buffer
 787+ F458 ED 5B 1E 55              ld      DE,(MSW_SCT)    ; load MSW of sector
 788+ F45C ED 4B 20 55              ld      BC,(LSW_SCT)    ; load LSW of sector
 789+ F460 CD 77 FD                 call    CF_WR_SEC       ; write sector
 790+ F463 C3 AC F4                 jp      OPNFILPT        ; go setting pointer
 791+ F466                          ; open file for append (add data after the end)
 792+ F466 CD B4 F4     OPNFRD:     call    OPNRDDET        ; load file details - size in bytes in DE - size in sectors in A
 793+ F469 21 00 02                 ld      HL,$0200        ; sector wide
 794+ F46C EB                       ex      DE,HL           ; move file size into HL and sector size into DE
 795+ F46D 3D           OPNFRD3:    dec     A               ; decrement sector counter
 796+ F46E 28 05                    jr      Z,OPNFRD2       ; reached 0? jump over
 797+ F470 B7                       or      A               ; reset Carry
 798+ F471 ED 52                    sbc     HL,DE           ; decrement sector size
 799+ F473 18 F8                    jr      OPNFRD3         ; repeat
 800+ F475 22 DF FF     OPNFRD2:    ld      (SEQPNT),HL     ; save pointer
 801+ F478 3A DC FF                 ld      A,(SEQSCSZ)     ; load size in sectors
 802+ F47B 3D                       dec     A               ; decrement by 1
 803+ F47C 4F                       ld      C,A             ; store into...
 804+ F47D 06 00                    ld      B,$00           ; ...HL
 805+ F47F 2A DA FF                 ld      HL,(SEQSCTL)    ; load LSW of sector address
 806+ F482 ED 5B D8 FF              ld      DE,(SEQSCTM)    ; load MSW of sector address
 807+ F486 09                       add     HL,BC           ; point to latest sector
 808+ F487 4D                       ld      C,L             ; copy HL into BC
 809+ F488 44                       ld      B,H
 810+ F489 30 05                    jr      NC,OPNFRD1      ; if LSW didn't overflow, jump over
 811+ F48B 13                       inc     DE              ; overflow, so increment MSW
 812+ F48C ED 53 D8 FF              ld      (SEQSCTM),DE    ; store new MSW of sector address
 813+ F490 ED 43 DA FF  OPNFRD1:    ld      (SEQSCTL),BC    ; store new LSW of sector address
 814+ F494 CD 0E FD                 call    CF_SETSTR       ; set sector to load
 815+ F497 CD 50 FD                 call    CF_RD_SEC       ; read sector
 816+ F49A C9                       ret                     ; return to caller
 817+ F49B                          ; open file for read & point to beginning of it
 818+ F49B CD B4 F4     OPFLRS:     call    OPNRDDET        ; load file details
 819+ F49E ED 5B D8 FF              ld      DE,(SEQSCTM)    ; load MSW of sector address
 820+ F4A2 ED 4B DA FF              ld      BC,(SEQSCTL)    ; load LSW of sector addres
 821+ F4A6 CD 0E FD                 call    CF_SETSTR       ; point to 1st sector
 822+ F4A9 CD 50 FD                 call    CF_RD_SEC       ; load sector
 823+ F4AC AF           OPNFILPT:   xor     A               ; A=0
 824+ F4AD 32 DF FF                 ld      (SEQPNT),A      ; file pointer...
 825+ F4B0 32 E0 FF                 ld      (SEQPNT+1),A    ; ...set to 0
 826+ F4B3 C9                       ret                     ; return to caller
 827+ F4B4
 828+ F4B4
 829+ F4B4              ; open an existing file and load details
 830+ F4B4 DD 5E 14     OPNRDDET:   ld      E,(IX+$14)      ; load MSW into DE
 831+ F4B7 DD 56 15                 ld      D,(IX+$15)
 832+ F4BA DD 4E 16                 ld      C,(IX+$16)      ; load LSW into BC
 833+ F4BD DD 46 17                 ld      B,(IX+$17)
 834+ F4C0 ED 53 1E 55              ld      (MSW_SCT),DE    ; store DE for DOS
 835+ F4C4 ED 53 D8 FF              ld      (SEQSCTM),DE    ; also for seq. file manager
 836+ F4C8 ED 43 20 55              ld      (LSW_SCT),BC    ; store BC dor DOS
 837+ F4CC ED 43 DA FF              ld      (SEQSCTL),BC    ; also for seq. file manager
 838+ F4D0 DD 5E 18                 ld      E,(IX+$18)      ; load size in bytes
 839+ F4D3 DD 56 19                 ld      D,(IX+$19)
 840+ F4D6 ED 53 1B 55              ld      (BYT_SIZ),DE    ; store it for DOS
 841+ F4DA ED 53 DD FF              ld      (SEQBYSZ),DE    ; store it for seq. file manager
 842+ F4DE DD 7E 1A                 ld      A,(IX+$1A)      ; load size in sectors
 843+ F4E1 32 1D 55                 ld      (SCT_SIZ),A     ; store it for DOS
 844+ F4E4 32 DC FF                 ld      (SEQSCSZ),A     ; and also for seq. file manager
 845+ F4E7 C9                       ret                     ; return to caller
 846+ F4E8
 847+ F4E8
 848+ F4E8              ; save file name into seq. buffer
 849+ F4E8 11 C6 FF     SVSQFLNM:   ld      DE,TMPNAM       ; temp. buff.
 850+ F4EB 01 10 00                 ld      BC,$0010        ; 10 chars
 851+ F4EE 21 A0 FD                 ld      HL,DOSBFR       ; pointer to file name
 852+ F4F1 ED B0                    ldir                    ; store filename
 853+ F4F3 C9                       ret                     ; return to caller
 854+ F4F4
 855+ F4F4              ; *****************************************************************************
 856+ F4F4              ; CLOSE A SEQUENTIAL FILE
 857+ F4F4              ; *****************************************************************************
 858+ F4F4 CD 6A FB     CLOSFIL:    call    CHKSQFL         ; is there a seq. file open?
 859+ F4F7 CA 18 F6                 jp      Z,FILOPCLER     ; no, raise an error
 860+ F4FA 47                       ld      B,A             ; copy file number into B
 861+ F4FB 3A 13 55                 ld      A,(TMPDBF)      ; load argument
 862+ F4FE B8                       cp      B               ; are they equal?
 863+ F4FF C2 2A F6                 jp      NZ,FLNTFND      ; file not found
 864+ F502 3A D7 FF                 ld      A,(SEQFLS)      ; check access mode
 865+ F505 B7                       or      A               ; only reading?
 866+ F506 28 09                    jr      Z,CLOSFIL1      ; yes, just mark file closed
 867+ F508 CD 16 F5                 call    SVCRNTSE        ; save current buffer
 868+ F50B CD 22 F5                 call    UPCRNENT        ; update entry into dir
 869+ F50E DA 2A F6                 jp      C,FLNTFND       ; file not found?
 870+ F511              CLOSFIL1:   ;call    CLRSEQBF        ; clear seq. buffer
 871+ F511 AF                       xor     A               ; mark file as closed
 872+ F512 32 D6 FF                 ld      (SEQFL),A
 873+ F515 C9                       ret                     ; return to caller
 874+ F516
 875+ F516
 876+ F516              ; save current buffer into a sequential file
 877+ F516 ED 5B D8 FF  SVCRNTSE:   ld      DE,(SEQSCTM)    ; MSW of sector address
 878+ F51A ED 4B DA FF              ld      BC,(SEQSCTL)    ; LSW of sector address
 879+ F51E CD 77 FD                 call    CF_WR_SEC       ; save current open sector
 880+ F521 C9                       ret
 881+ F522
 882+ F522
 883+ F522              ; update current entry (for a seq. file)
 884+ F522 11 10 00     UPCRNENT:   ld      DE,$0010
 885+ F525 ED 53 80 55              ld      (DKLNPT),DE     ; lenght of name
 886+ F529 11 C6 FF                 ld      DE,TMPNAM
 887+ F52C ED 53 7E 55              ld      (DKNMPT),DE     ; pointer to name
 888+ F530 CD 41 F9                 call    CHKFLEXT        ; check file existance
 889+ F533 D2 51 F5                 jp      NC,UPCRNENT1    ; file not found
 890+ F536 2A DD FF                 ld      HL,(SEQBYSZ)
 891+ F539 DD 75 18                 ld      (IX+$18),L      ; point to file size
 892+ F53C DD 74 19                 ld      (IX+$19),H
 893+ F53F 3A DC FF                 ld      A,(SEQSCSZ)     ; load size in sectors
 894+ F542 DD 77 1A                 ld      (IX+$1A),A
 895+ F545 ED 5B 26 55              ld      DE,(TPBF2)      ; retrieve MSW of current directory sector
 896+ F549 ED 4B 28 55              ld      BC,(TPBF3)      ; retrieve LSW of current directory secto
 897+ F54D CD 77 FD                 call    CF_WR_SEC       ; store entry
 898+ F550 37                       scf                     ; set Carry
 899+ F551 3F           UPCRNENT1:  ccf                     ; invert Carry
 900+ F552 C9                       ret
 901+ F553
 902+ F553
 903+ F553              ; *****************************************************************************
 904+ F553              ; E O F
 905+ F553              ; check EOF/size
 906+ F553              ; input: 0 => return size of current file
 907+ F553              ; input: file number => 1 if EOF, 0 otherwise
 908+ F553              ; *****************************************************************************
 909+ F553 CD 6A FB     EOF:        call    CHKSQFL         ; is there a seq. file open?
 910+ F556 1E 38                    ld      E,D0            ; prepare a file open error
 911+ F558 CA 31 18                 jp      Z,ERROR         ; no, raise an error
 912+ F55B CD 14 1E                 call    DEINT           ; get any number
 913+ F55E 7B                       ld      A,E             ; is it 0?
 914+ F55F B7                       or      A
 915+ F560 28 07                    jr      Z,EOF1          ; ok, jump over
 916+ F562 3A D6 FF                 ld      A,(SEQFL)       ; get current file number
 917+ F565 BB                       cp      E               ; same?
 918+ F566 C2 29 1E                 jp      NZ,FCERR        ; no, error
 919+ F569 D5           EOF1:       push    DE              ; store value
 920+ F56A E5                       push    HL              ; store code string pointer
 921+ F56B CD 5A FB                 call    CHKEOF          ; check EOF/size
 922+ F56E E1                       pop     HL              ; retrieve code string pointer
 923+ F56F C1                       pop     BC              ; retrieve argument
 924+ F570 3E 00                    ld      A,$00           ; reset A (w/o altering Carry)
 925+ F572 17                       rla                     ; copy Carry into bit #0
 926+ F573 47                       ld      B,A             ; copy A into B
 927+ F574 79                       ld      A,C             ; retrieve argument
 928+ F575 B7                       or      A               ; is it zero?
 929+ F576 20 05                    jr      NZ,RETEOF       ; return EOF
 930+ F578 7A                       ld      A,D             ; copy size into AB
 931+ F579 43                       ld      B,E
 932+ F57A C3 D9 25                 jp      ABPASS          ; return size into AB
 933+ F57D 78           RETEOF:     ld      A,B             ; retrieve EOF
 934+ F57E C3 E8 25                 jp      PASSA           ; return value
 935+ F581
 936+ F581
 937+ F581              ; *****************************************************************************
 938+ F581              ; P U T
 939+ F581              ; *****************************************************************************
 940+ F581 CD 75 2A     PUT:        call    GETINT          ; get file number
 941+ F584 32 13 55                 ld      (TMPDBF),A      ; store it
 942+ F587 CD 15 1B                 call    CHKSYN          ; Make sure ',' follows
 943+ F58A 2C                       defb    ','
 944+ F58B CD 75 2A                 call    GETINT          ; get mode
 945+ F58E 32 14 55                 ld      (TMPDBF+1),A    ; store it
 946+ F591 E5                       push    HL              ; store code string pointer
 947+ F592 CD 72 F3                 call    PUTFIL          ; insert data into file
 948+ F595 DA 30 F0                 jp      C,DOS_ERR       ; any error?
 949+ F598 E1                       pop     HL              ; retrieve code string pointer
 950+ F599 C9                       ret                     ; return to caller
 951+ F59A
 952+ F59A
 953+ F59A              ; *****************************************************************************
 954+ F59A              ; G E T
 955+ F59A              ; return a byte read from a sequential file
 956+ F59A              ; *****************************************************************************
 957+ F59A CD 14 1E     GET:        call    DEINT           ; get file number
 958+ F59D 7B                       ld      A,E             ; check if...
 959+ F59E B7                       or      A               ; ...it's zero
 960+ F59F CA 29 1E                 jp      Z,FCERR         ; yes, illegal function call
 961+ F5A2 CD 6A FB                 call    CHKSQFL         ; is there a seq. file opened?
 962+ F5A5 3E 38                    ld      A,D0            ; prepare a file open error
 963+ F5A7 28 67                    jr      Z,GETER         ; no, exit with error
 964+ F5A9 3A D7 FF                 ld      A,(SEQFLS)      ; check mode
 965+ F5AC B7                       or      A               ; is it write?
 966+ F5AD C2 29 1E                 jp      NZ,FCERR        ; yes, raise error
 967+ F5B0 3A D6 FF                 ld      A,(SEQFL)       ; file number
 968+ F5B3 BB                       cp      E               ; same?
 969+ F5B4 C2 29 1E                 jp      NZ,FCERR        ; no, error
 970+ F5B7                          ; load byte pointed by seq. file pointer
 971+ F5B7 E5                       push    HL              ; store code string pointer
 972+ F5B8 CD 5A FB                 call    CHKEOF          ; check if EOF
 973+ F5BB 1E 4C                    ld      E,DA
 974+ F5BD DA 31 18                 jp      C,ERROR         ; return EOF error
 975+ F5C0 2A DF FF                 ld      HL,(SEQPNT)     ; reload pointer in bytes
 976+ F5C3 7C                       ld      A,H             ; copy into AC
 977+ F5C4 4D                       ld      C,L
 978+ F5C5 11 00 02                 ld      DE,$0200        ; size of buffer
 979+ F5C8 CD A2 41                 call    DIV_16_16       ; calculate (pointer MOD $200) => HL=current pointer into buffer
 980+ F5CB 11 C0 FD                 ld      DE,IOBUFF       ; address of I/O buffer
 981+ F5CE 19                       add     HL,DE           ; find position of byte to load
 982+ F5CF 7E                       ld      A,(HL)          ; load byte
 983+ F5D0 32 7C 55                 ld      (TMPBFR1),A     ; store
 984+ F5D3 2A DF FF                 ld      HL,(SEQPNT)     ; load pointer
 985+ F5D6 23                       inc     HL              ; increment pointer
 986+ F5D7 22 DF FF                 ld      (SEQPNT),HL
 987+ F5DA 11 00 02                 ld      DE,$0200        ; sector size
 988+ F5DD 7C                       ld      A,H             ; copy HL into AC
 989+ F5DE 4D                       ld      C,L
 990+ F5DF CD A2 41                 call    DIV_16_16       ; calculate <pointer/$200>
 991+ F5E2 7D                       ld      A,L
 992+ F5E3 BC                       cp      H               ; check if remainder is 0 meaning that we read all the buffer ($200 chars)
 993+ F5E4 20 23                    jr      NZ,GET1         ; no, jump over
 994+ F5E6 ED 4B DA FF              ld      BC,(SEQSCTL)    ; load LSW of sector address
 995+ F5EA 03                       inc     BC              ; next sector
 996+ F5EB 79                       ld      A,C             ; check if BC is rolled back to zero (overflow)
 997+ F5EC B0                       or      B
 998+ F5ED 20 09                    jr      NZ,GET2         ; no, jump over
 999+ F5EF ED 5B D8 FF              ld      DE,(SEQSCTM)    ; load MSW of sector address
1000+ F5F3 13                       inc     DE              ; yes, increment MSW of sector address
1001+ F5F4 ED 53 D8 FF              ld      (SEQSCTM),DE    ; save MSW of sector address
1002+ F5F8 ED 43 DA FF  GET2:       ld      (SEQSCTL),BC    ; save LSW of sector address
1003+ F5FC ED 5B D8 FF              ld      DE,(SEQSCTM)    ; load MSW of sector address
1004+ F600 CD 0E FD                 call    CF_SETSTR       ; set sector to read
1005+ F603 CD 50 FD                 call    CF_RD_SEC       ; read next sector
1006+ F606 CD 44 FD                 call    CF_STANDBY      ; set CF to standby
1007+ F609 E1           GET1:       pop     HL              ; retrieve code string pointer
1008+ F60A 3A 7C 55                 ld      A,(TMPBFR1)
1009+ F60D C3 E8 25                 jp      PASSA           ; return A and then return to caller
1010+ F610 E1           GETER:      pop     HL              ; retrieve code string pointer
1011+ F611 5F                       ld      E,A             ; load error code
1012+ F612 CD 44 FD                 call    CF_STANDBY      ; set CF into stand-by
1013+ F615 C3 31 18                 jp      ERROR           ; raise error
1014+ F618
1015+ F618
1016+ F618              ; *****************************************************************************
1017+ F618              ; DOS ERRORS
1018+ F618              ; *****************************************************************************
1019+ F618 3E 38        FILOPCLER:  ld      A,D0            ; file open/close error
1020+ F61A 01                       defb    $01             ; Skip next statement
1021+ F61B 3E 4A        FILALROP:   ld      A,D9            ; file already open
1022+ F61D 01                       defb    $01             ; Skip next statement
1023+ F61E 3E 3C        D2ERR:      ld      A,D2            ; disk geometry error
1024+ F620 01                       defb    $01             ; Skip next statement
1025+ F621 3E 42        DSKFULL:    ld      A,D5            ; disk full error
1026+ F623 01                       defb    $01             ; Skip next statement
1027+ F624 3E 44        DUPLERR:    ld      A,D6            ; duplicate file name
1028+ F626 01                       defb    $01             ; Skip next statement
1029+ F627 3E 3A        NAMERR:     ld      A,D1            ; file name error
1030+ F629 01                       defb    $01             ; Skip next statement
1031+ F62A 3E 48        FLNTFND:    ld      A,D8            ; file not found
1032+ F62C 01                       defb    $01             ; Skip next statement
1033+ F62D 3E 40        LODERR:     ld      A,D4            ; generic load error
1034+ F62F 01                       defb    $01             ; Skip next statement
1035+ F630 3E 46        DOSVERSERR: ld      A,D7            ; DOS version error
1036+ F632 32 12 55     RET_ERR:    ld      (DOSER),A       ; store DOS error
1037+ F635 CD 44 FD                 call    CF_STANDBY      ; set CF into stand-by
1038+ F638 37                       scf                     ; set Carry for error
1039+ F639 C9                       ret                     ; return to caller
1040+ F63A
1041+ F63A
1042+ F63A              ; *****************************************************************************
1043+ F63A              ; L I S T    F I L E S
1044+ F63A              ; Function: print details of disk and list files
1045+ F63A              ; Input: D: $00=only disk details; $01=file list, too
1046+ F63A              ; *****************************************************************************
1047+ F63A 44 69 73 6B  DSKNMTX:    defb    "Disk name: ",0
1047+ F63E 20 6E 61 6D
1047+ F642 65 3A 20 00
1048+ F646 0D 53 65 63  TLSCTTX:    defb    CR,"Sectors: ",0
1048+ F64A 74 6F 72 73
1048+ F64E 3A 20 00
1049+ F651 0D 41 6C 6C  ALFLSTXT:   defb    CR,"Allowed files: ",0
1049+ F655 6F 77 65 64
1049+ F659 20 66 69 6C
1049+ F65D 65 73 3A 20
1049+ F661 00
1050+ F662 20 66 69 6C  TLFLSTX:    defb    " file(s)",CR,0
1050+ F666 65 28 73 29
1050+ F66A 0D 00
1051+ F66C CD 6A FB     LST_FILES:  call    CHKSQFL         ; check if a seq. file is open
1052+ F66F C2 18 F6                 jp      NZ,FILOPCLER    ; jump if open
1053+ F672 CD 03 FC                 call    CHKDSKVAL       ; check DOS version & load disk details
1054+ F675 DA 30 F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
1055+ F678 D5                       push    DE              ; store D
1056+ F679 CD B7 FB                 call    LDMSCT          ; load Master Sector
1057+ F67C 21 3A F6                 ld      HL,DSKNMTX      ; pointer to "Disk name" message
1058+ F67F CD F7 26                 call    PRS             ; print it
1059+ F682 21 C0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
1060+ F685 11 20 00                 ld      DE,$0020        ; position of disk name
1061+ F688 19                       add     HL,DE           ; get address
1062+ F689 06 10                    ld      B,$10           ; 16 chars
1063+ F68B 7E           INPR1:      ld      A,(HL)          ; load char
1064+ F68C CD 20 1B                 call    OUTC            ; print it
1065+ F68F 23                       inc     HL
1066+ F690 10 F9                    djnz    INPR1           ; repeat
1067+ F692 3E 0D                    ld      A,CR
1068+ F694 CD 20 1B                 call    OUTC            ; carriage return
1069+ F697 DD 21 00 00              ld      IX,$0000        ; reset file counter (for use in formatting)
1070+ F69B D1                       pop     DE              ; retrieve D
1071+ F69C 7A                       ld      A,D
1072+ F69D B7                       or      A               ; is D=0?
1073+ F69E CA 51 F7                 jp      Z,PNTSTATS      ; yes, jump over
1074+ F6A1                          ; print list of files
1075+ F6A1 21 C0 FD                 ld      HL,IOBUFF       ; start of I/O buffer
1076+ F6A4 11 0F 00                 ld      DE,$000F        ; point to details of disk
1077+ F6A7 19                       add     HL,DE           ; find address
1078+ F6A8 11 A0 FD                 ld      DE,DOSBFR       ; store into DOS buffer
1079+ F6AB 01 20 00                 ld      BC,$0020        ; 32 bytes
1080+ F6AE ED B0                    ldir                    ; copy
1081+ F6B0 CD A8 FB                 call    LDENTRIES       ; load entries
1082+ F6B3 FD 2A 19 55              ld      IY,(NTR_NBR)    ; load max entries
1083+ F6B7 D9                       exx
1084+ F6B8 01 00 00                 ld      BC,$0000        ; reset file counter
1085+ F6BB D9                       exx
1086+ F6BC CD 6F FB                 call    SETPTEN         ; point to 1st sector of dir
1087+ F6BF CD 77 FB     LSTFILES1:  call    PT2FSEN         ; point to 1st entry of a dir's sect
1088+ F6C2 CD 82 FB     LSTFILES2:  call    CKCREN          ; check current entry
1089+ F6C5 28 64                    jr      Z,LSTFILES6     ; if empty or deleted, ignore it
1090+ F6C7 C5                       push    BC              ; this is a valid entry - so, store BC (LSW of sect)
1091+ F6C8 FD E5                    push    IY              ; store IY (entries counter)
1092+ F6CA E5                       push    HL              ; store HL (sect entry counter)
1093+ F6CB D5                       push    DE              ; store DE (MSW of sector)
1094+ F6CC DD E5                    push    IX              ; store IX (pointer to first byte of entry)
1095+ F6CE 06 10                    ld      B,$10           ; 16 chars to read and print
1096+ F6D0 DD 7E 00     LSTFILES3:  ld      A,(IX)          ; load char from name
1097+ F6D3 CD 20 1B                 call    OUTC            ; print char
1098+ F6D6 DD 23                    inc     IX              ; next char
1099+ F6D8 10 F6                    djnz    LSTFILES3       ; repeat
1100+ F6DA 3E 20                    ld      A,SPC
1101+ F6DC CD 20 1B                 call    OUTC            ; print space
1102+ F6DF DD 7E 00                 ld      A,(IX)          ; file type
1103+ F6E2 D6 80                    sub     $80             ; types start from $80
1104+ F6E4 B7                       or      A               ; BAS type ($00)?
1105+ F6E5 20 05                    jr      NZ,LSTFILES20   ; no, jump over
1106+ F6E7 21 95 F7                 ld      HL,FILETP       ; print "BAS"
1107+ F6EA 18 13                    jr      LSTFILESPR
1108+ F6EC 3D           LSTFILES20: dec     A               ; BIN type ($01)?
1109+ F6ED 20 05                    jr      NZ,LSTFILES21   ; no, jump over
1110+ F6EF 21 9A F7                 ld      HL,FILETP+5     ; print "BIN"
1111+ F6F2 18 0B                    jr      LSTFILESPR
1112+ F6F4 3D           LSTFILES21: dec     A
1113+ F6F5 20 05                    jr      NZ,LSTFILES22
1114+ F6F7 21 9F F7                 ld      HL,FILETP+10    ; print "SEQ"
1115+ F6FA 18 03                    jr      LSTFILESPR
1116+ F6FC 21 9F F7     LSTFILES22: ld      HL,FILETP+10    ; print "???"
1117+ F6FF CD F7 26     LSTFILESPR: call    PRS
1118+ F702 01 08 00                 ld      BC,$0008
1119+ F705 DD 09                    add     IX,BC           ; point to file size in bytes
1120+ F707 DD 4E 00                 ld      C,(IX)          ; load size in BC, first LSW
1121+ F70A DD 23                    inc     IX
1122+ F70C DD 46 00                 ld      B,(IX)          ; then MSW
1123+ F70F C5                       push    BC              ; copy...
1124+ F710 DD E1                    pop     IX              ; ...into IX
1125+ F712 11 00 00                 ld      DE,$0000        ; reset DE
1126+ F715 FD E5                    push    IY
1127+ F717 CD 76 FC                 call    PRN16ASCIX      ; print size in bytes (DEIX)
1128+ F71A FD E1                    pop     IY
1129+ F71C 3E 0D                    ld      A,CR
1130+ F71E CD 20 1B                 call    OUTC            ; print carriage return
1131+ F721 D9                       exx                     ; set shadow registers
1132+ F722 03                       inc     BC              ; increment file counter
1133+ F723 D9                       exx                     ; restore main registers
1134+ F724 DD E1                    pop     IX              ; retrieve IX
1135+ F726 D1                       pop     DE              ; retrieve DE
1136+ F727 E1                       pop     HL              ; retrieve HL
1137+ F728 FD E1                    pop     IY              ; retrieve IY
1138+ F72A C1                       pop     BC              ; retrieve BC
1139+ F72B CD 89 1D     LSTFILES6:  call    TSTBRK          ; Test for break key
1140+ F72E CD 8C 1C                 call    TSTSPC          ; test for space
1141+ F731 CD 8A FB                 call    GTNXTEN         ; other entries in this sector?
1142+ F734 20 8C                    jr      NZ,LSTFILES2    ; yes, continue check
1143+ F736 CD 96 FB                 call    CKLSTEN         ; go to next sector
1144+ F739 D2 BF F6                 jp      NC,LSTFILES1    ; more entries? repeat
1145+ F73C D9                       exx                     ; set shadow registers
1146+ F73D C5                       push    BC              ; store file counter
1147+ F73E D9                       exx                     ; restore main registers
1148+ F73F DD E1                    pop     IX              ; retrieve file counter
1149+ F741 DD E5                    push    IX              ; store it again
1150+ F743 11 00 00                 ld      DE,$0000        ; reset DE
1151+ F746 CD 76 FC                 call    PRN16ASCIX      ; print number of files from DEIX
1152+ F749 21 62 F6                 ld      HL,TLFLSTX
1153+ F74C CD F7 26                 call    PRS             ; print "file(s)"
1154+ F74F DD E1                    pop     IX
1155+ F751 21 46 F6     PNTSTATS:   ld      HL,TLSCTTX      ; Point to message "Tot. sectors"
1156+ F754 CD F7 26                 call    PRS             ; print message
1157+ F757 21 A0 FD                 ld      HL,DOSBFR       ; reload address of I/O buffer and point to disk size
1158+ F75A DD E5                    push    IX
1159+ F75C CD 6D FC                 call    PRN32ASCII      ; print size
1160+ F75F 3E 2F                    ld      A,'/'
1161+ F761 CD 20 1B                 call    OUTC            ; print a "/""
1162+ F764 D1                       pop     DE              ; copy number of entries into DE
1163+ F765 01 80 00                 ld      BC,$0080        ; 128 sectors per entry block
1164+ F768 CD 5D 41                 call    MUL_U32         ; multiply BC times DE: returns DEHL
1165+ F76B ED 53 24 55              ld      (TPBF1),DE      ; store results
1166+ F76F 22 26 55                 ld      (TPBF2),HL
1167+ F772 21 24 55                 ld      HL,TPBF1        ; print results
1168+ F775 CD 6D FC                 call    PRN32ASCII
1169+ F778 21 51 F6                 ld      HL,ALFLSTXT     ; Point to message "Allowed files"
1170+ F77B CD F7 26                 call    PRS             ; print message
1171+ F77E 21 A0 FD                 ld      HL,DOSBFR       ; reload address of I/O buffer
1172+ F781 01 0A 00                 ld      BC,$000A        ; address of allowed files
1173+ F784 09                       add     HL,BC           ; find pointer
1174+ F785 11 00 00                 ld      DE,$0000        ; MSW set to $0000
1175+ F788 CD 70 FC                 call    PRN16ASCII      ; print max files
1176+ F78B 3E 0D                    ld      A,CR
1177+ F78D CD 20 1B                 call    OUTC            ; print a carriage return
1178+ F790 CD 44 FD                 call    CF_STANDBY      ; put CF into standby
1179+ F793 AF                       xor     A               ; clear Carry flag
1180+ F794 C9                       ret                     ; return to caller
1181+ F795 42 41 53 20  FILETP:     defb    "BAS ",0        ; BASIC type
1181+ F799 00
1182+ F79A 42 49 4E 20              defb    "BIN ",0        ; BINARY type
1182+ F79E 00
1183+ F79F 53 45 51 20              defb    "SEQ ",0        ; SEQUENTIAL type
1183+ F7A3 00
1184+ F7A4 3F 3F 3F 20              defb    "??? ",0        ; unkown
1184+ F7A8 00
1185+ F7A9
1186+ F7A9
1187+ F7A9              ; *****************************************************************************
1188+ F7A9              ; S A V E    F I L E
1189+ F7A9              ; save current BASIC program onto a file
1190+ F7A9              ; *****************************************************************************
1191+ F7A9 CD 6A FB     SAVFILE:    call    CHKSQFL         ; check if a seq. file is open
1192+ F7AC C2 18 F6                 jp      NZ,FILOPCLER    ; jump if open
1193+ F7AF CD 41 F9                 call    CHKFLEXT        ; file already exists?
1194+ F7B2 DA 24 F6                 jp      C,DUPLERR       ; name is present - error
1195+ F7B5 CD 32 FB                 call    FNDFRENTR       ; find a free entry in the directory
1196+ F7B8 DA 21 F6                 jp      C,DSKFULL       ; no entry, disk full error
1197+ F7BB 3A 2A 55                 ld      A,(TPBF4)       ; check what to save
1198+ F7BE FE 80                    cp      $80             ; BASIC program?
1199+ F7C0 C2 CF F7                 jp      NZ,SAVFL3       ; no, jump over
1200+ F7C3                          ; BASIC area to save starts at PROGND and ends at (PROGND)
1201+ F7C3 2A C2 55                 ld      HL,(PROGND)     ; load end of BASIC program <- WARNING: pay attention to (PROGND) and PROGND
1202+ F7C6 11 C2 55                 ld      DE,PROGND       ; start of RAM to be saved  <- WARNING: pay attention to (PROGND) and PROGND
1203+ F7C9 ED 53 2C 55              ld      (SRTMEM),DE     ; copy DE
1204+ F7CD 18 08                    jr      SAVFL1
1205+ F7CF 2A 2E 55     SAVFL3:     ld      HL,(ENDMEM)     ; save a portion of memory: HL <= end of portion
1206+ F7D2 23                       inc     HL              ; we always need 1 more byte to store the portion of memory
1207+ F7D3 ED 5B 2C 55              ld      DE,(SRTMEM)     ; DE <= start of portion
1208+ F7D7                          ; compute how many sectors/blocks are needed to save file
1209+ F7D7 AF           SAVFL1:     xor     A               ; reset Carry
1210+ F7D8 ED 52                    sbc     HL,DE           ; get how many bytes to save
1211+ F7DA 22 1B 55                 ld      (BYT_SIZ),HL    ; store into memory
1212+ F7DD 11 00 02                 ld      DE,$0200        ; 512 bytes per sector
1213+ F7E0 7C                       ld      A,H             ; move lenght...
1214+ F7E1 4D                       ld      C,L             ; ...into AC
1215+ F7E2 CD A2 41                 call    DIV_16_16       ; lenght/512 = nbr. of sectors: quotient in AC but A will be discarded
1216+ F7E5 7C                       ld      A,H             ; check if...
1217+ F7E6 B5                       or      L               ; ...remainder (HL) is 0
1218+ F7E7 28 01                    jr      Z,SAVFL6        ; yes, jump over
1219+ F7E9 03                       inc     BC              ; no, so we need another sector
1220+ F7EA 79           SAVFL6:     ld      A,C
1221+ F7EB 32 1D 55                 ld      (SCT_SIZ),A     ; store into memory
1222+ F7EE CD 5E F8                 call    SVENTRY         ; save new entry into dir
1223+ F7F1 CD 9F FC                 call    CLRIOBF         ; clear I/O buffer
1224+ F7F4                          ; start saving RAM
1225+ F7F4 ED 5B 2C 55              ld      DE,(SRTMEM)     ; load start of RAM
1226+ F7F8 ED 53 22 55              ld      (RAM_PTR),DE    ; store
1227+ F7FC CD 9F FC     SAVFL10:    call    CLRIOBF         ; clear I/O buffer
1228+ F7FF 2A 1B 55                 ld      HL,(BYT_SIZ)    ; load bytes left to be copied
1229+ F802 11 00 02                 ld      DE,$0200        ; are they < 512?
1230+ F805 CD 38 41                 call    CMP16
1231+ F808 30 04                    jr      NC,SAVFL4       ; no, jump over
1232+ F80A ED 5B 1B 55              ld      DE,(BYT_SIZ)    ; yes, so load remaining bytes
1233+ F80E 4B           SAVFL4:     ld      C,E             ; bytes to copy
1234+ F80F 42                       ld      B,D             ; into BC
1235+ F810 2A 22 55                 ld      HL,(RAM_PTR)    ; load pointer to RAM to be saved
1236+ F813 11 C0 FD                 ld      DE,IOBUFF       ; load start of I/O buffer
1237+ F816 ED B0                    ldir                    ; copy data
1238+ F818 ED 5B 1E 55              ld      DE,(MSW_SCT)    ; load MSW of sector
1239+ F81C ED 4B 20 55              ld      BC,(LSW_SCT)    ; load LSW of sector
1240+ F820 CD 77 FD                 call    CF_WR_SEC       ; write sector
1241+ F823 DA 9B FA                 jp      C,WRT_ERR       ; error?
1242+ F826 21 1D 55                 ld      HL,SCT_SIZ      ; sector counter
1243+ F829 35                       dec     (HL)            ; copied all the sectors?
1244+ F82A CA 59 F8                 jp      Z,SAVFLEXT      ; yes, exit
1245+ F82D 2A 22 55                 ld      HL,(RAM_PTR)    ; pointer to RAM
1246+ F830 11 00 02                 ld      DE,$0200        ; block of 512 bytes copied
1247+ F833 19                       add     HL,DE           ; calculate next starting address
1248+ F834 22 22 55                 ld      (RAM_PTR),HL    ; store next block
1249+ F837 AF                       xor     A               ; reset Carry
1250+ F838 2A 1B 55                 ld      HL,(BYT_SIZ)    ; load left bytes
1251+ F83B ED 52                    sbc     HL,DE           ; subtract copied bytes
1252+ F83D 22 1B 55                 ld      (BYT_SIZ),HL    ; store left bytes
1253+ F840 ED 4B 20 55              ld      BC,(LSW_SCT)    ; load LSW of sector
1254+ F844 03                       inc     BC              ; next sector
1255+ F845 78                       ld      A,B             ; BC=$0000?
1256+ F846 B1                       or      C
1257+ F847 20 09                    jr      NZ,SAVFL12      ; no, jump over
1258+ F849 ED 5B 1E 55              ld      DE,(MSW_SCT)    ; load MSW of sector
1259+ F84D 13                       inc     DE              ; increment DE
1260+ F84E ED 53 1E 55              ld      (MSW_SCT),DE    ; store new MSW of sector
1261+ F852 ED 43 20 55  SAVFL12:    ld      (LSW_SCT),BC    ; store new LSW of sector
1262+ F856 C3 FC F7                 jp      SAVFL10         ; repeat
1263+ F859 CD 44 FD     SAVFLEXT:   call    CF_STANDBY      ; set CF into stand-by mode
1264+ F85C AF                       xor     A               ; clear Carry flag
1265+ F85D C9                       ret                     ; return to caller
1266+ F85E
1267+ F85E
1268+ F85E              ; save entry on disk
1269+ F85E 11 00 00     SVENTRY:    ld      DE,$0000        ; directory is always from sector 0000-0001
1270+ F861 ED 4B 17 55              ld      BC,(DIR_SCT)    ; load sector of dir where to save file entry
1271+ F865 CD 0E FD                 call    CF_SETSTR       ; set sector to read
1272+ F868 CD 50 FD                 call    CF_RD_SEC       ; read sector
1273+ F86B 3A 19 55                 ld      A,(NTR_NBR)     ; load entry number (ignoring MSB)
1274+ F86E E6 0F                    and     %00001111       ; be sure to get only low nibble
1275+ F870 87                       add     A,A             ; multiply...
1276+ F871 87                       add     A,A             ; ...times 16 by...
1277+ F872 87                       add     A,A             ; ...adding...
1278+ F873 87                       add     A,A             ; ...4 times
1279+ F874 CB 27                    sla     A               ; left shift to multiply times 32 - Carry is set if results is > 255
1280+ F876 5F                       ld      E,A             ; copy into C
1281+ F877 CB 12                    rl      D               ; if Carry, then increment D (D was 0, see above)
1282+ F879                          ; set name
1283+ F879 21 C0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
1284+ F87C 19                       add     HL,DE           ; add offset to get address of entry
1285+ F87D 11 A0 FD                 ld      DE,DOSBFR       ; pointer to file name
1286+ F880 01 10 00                 ld      BC,$0010        ; 16 chars
1287+ F883 EB                       ex      DE,HL           ; move source into HL and destination into DE
1288+ F884 ED B0                    ldir                    ; copy file name
1289+ F886 EB                       ex      DE,HL           ; move current buffer pointer into HL
1290+ F887 3A 2A 55                 ld      A,(TPBF4)       ; load the type of file
1291+ F88A 77                       ld      (HL),A          ; store it
1292+ F88B 23                       inc     HL
1293+ F88C AF                       xor     A               ; file attributes - AT THE MOMENT, NO ATTRIBUTES
1294+ F88D 77                       ld      (HL),A
1295+ F88E 23                       inc     HL
1296+ F88F ED 5B 19 55              ld      DE,(NTR_NBR)    ; reload entry number
1297+ F893 CD 63 FC                 call    DE2HL           ; store entry into buffer
1298+ F896 E5                       push    HL              ; store pointer
1299+ F897 01 80 00                 ld      BC,$0080        ; 128 sectors per entry block
1300+ F89A CD 5D 41                 call    MUL_U32         ; multiply BC times DE: returns DEHL
1301+ F89D ED 4B 15 55              ld      BC,(DAT_STRT)   ; load start of data
1302+ F8A1 09                       add     HL,BC           ; add sector of data area
1303+ F8A2 30 01                    jr      NC,SAVFL9       ; overflow?
1304+ F8A4 13                       inc     DE              ; yes, increment DE
1305+ F8A5 ED 53 1E 55  SAVFL9:     ld      (MSW_SCT),DE    ; store MSW of sector
1306+ F8A9 22 20 55                 ld      (LSW_SCT),HL    ; store LSW of sector
1307+ F8AC E1                       pop     HL              ; retrieve pointer
1308+ F8AD CD 63 FC                 call    DE2HL           ; also copy MSW of sector into entry
1309+ F8B0 ED 5B 20 55              ld      DE,(LSW_SCT)    ; retrieve LSW
1310+ F8B4 CD 63 FC                 call    DE2HL           ; also copy LSW of sector into entry
1311+ F8B7 ED 5B 1B 55              ld      DE,(BYT_SIZ)    ; retrieve file size in bytes
1312+ F8BB CD 63 FC                 call    DE2HL           ; copy file size into buffer
1313+ F8BE 3A 1D 55                 ld      A,(SCT_SIZ)     ; retrieve file size in sectors
1314+ F8C1 77                       ld      (HL),A          ; copy into buffer
1315+ F8C2 23                       inc     HL              ; next location
1316+ F8C3 ED 5B 2C 55              ld      DE,(SRTMEM)     ; start of address of file in RAM
1317+ F8C7 CD 63 FC                 call    DE2HL           ; copy into buffer
1318+ F8CA 06 03                    ld      B,$03           ; remaining chars...
1319+ F8CC AF                       xor     A               ; ...set to $00
1320+ F8CD 77           SAVFL2:     ld      (HL),A          ; reset byte
1321+ F8CE 23                       inc     HL              ; next cell
1322+ F8CF 10 FC                    djnz    SAVFL2          ; repeat
1323+ F8D1                          ; save entry into directory
1324+ F8D1 11 00 00                 ld      DE,$0000        ; block 0
1325+ F8D4 ED 4B 17 55              ld      BC,(DIR_SCT)    ; load sector of dir where to save file entry
1326+ F8D8 CD 77 FD                 call    CF_WR_SEC       ; write new entry into directory
1327+ F8DB DA 1E F6                 jp      C,D2ERR         ; error occured
1328+ F8DE C9                       ret
1329+ F8DF
1330+ F8DF
1331+ F8DF              ; *****************************************************************************
1332+ F8DF              ; C H A N G E    F I L E N A M E
1333+ F8DF              ; change name to a file
1334+ F8DF              ; *****************************************************************************
1335+ F8DF ED 5B 1B 55  CHNGNAM:    ld      DE,(BYT_SIZ)    ; load lenght
1336+ F8E3 ED 53 80 55              ld      (DKLNPT),DE     ; store it
1337+ F8E7 ED 5B 22 55              ld      DE,(RAM_PTR)    ; load address
1338+ F8EB ED 53 7E 55              ld      (DKNMPT),DE     ; store it
1339+ F8EF CD 41 F9                 call    CHKFLEXT        ; destination file already exists?
1340+ F8F2 DA 24 F6                 jp      C,DUPLERR       ; file name already exists
1341+ F8F5 CD 9F FC                 call    CLRIOBF         ; clear I/O buffer
1342+ F8F8 ED 5B 82 55              ld      DE,(TMPBFR4)    ; load lenght
1343+ F8FC ED 53 80 55              ld      (DKLNPT),DE     ; store it
1344+ F900 ED 5B 2C 55              ld      DE,(TPBF4+2)    ; load address
1345+ F904 ED 53 7E 55              ld      (DKNMPT),DE     ; store it
1346+ F908 CD 5E F9                 call    LK4FILE         ; look for file
1347+ F90B D2 2A F6                 jp      NC,FLNTFND      ; file not found error
1348+ F90E ED 5B 1B 55              ld      DE,(BYT_SIZ)    ; load lenght
1349+ F912 ED 53 80 55              ld      (DKLNPT),DE     ; store it
1350+ F916 ED 5B 22 55              ld      DE,(RAM_PTR)    ; load address
1351+ F91A ED 53 7E 55              ld      (DKNMPT),DE     ; store it
1352+ F91E CD B4 FC                 call    CLRDOSBF        ; clear DOS buffer
1353+ F921 11 A0 FD                 ld      DE,DOSBFR       ; DE set to beginning of DOS buffer
1354+ F924 CD 3B FC                 call    CHKNMVAL        ; check and copy file name
1355+ F927 21 A0 FD                 ld      HL,DOSBFR       ; retrieve new name pointer
1356+ F92A DD E5                    push    IX              ; copy dest. address...
1357+ F92C D1                       pop     DE              ; ...into DE
1358+ F92D 01 10 00                 ld      BC,$0010        ; 16 chars to copy
1359+ F930 ED B0                    ldir                    ; copy
1360+ F932 ED 5B 26 55              ld      DE,(TPBF2)      ; retrieve MSW of dir. sector
1361+ F936 ED 4B 28 55              ld      BC,(TPBF3)      ; retrieve LSW of dir. sector
1362+ F93A CD 77 FD                 call    CF_WR_SEC       ; write sector
1363+ F93D CD 44 FD                 call    CF_STANDBY      ; put CF in standby
1364+ F940 C9                       ret                     ; return to caller
1365+ F941
1366+ F941
1367+ F941              ; *****************************************************************************
1368+ F941              ; C H E C K    F I L E    E X I S T A N C E
1369+ F941              ; check if a file with the given name exists into dir
1370+ F941              ; Carry set if exist
1371+ F941              ; *****************************************************************************
1372+ F941 CD 9F FC     CHKFLEXT:   call    CLRIOBF         ; clear I/O
1373+ F944 CD 03 FC                 call    CHKDSKVAL       ; check DOS version & load disk details
1374+ F947 DA 30 F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
1375+ F94A CD A8 FB                 call    LDENTRIES       ; load entries into RAM register NTR_NBR
1376+ F94D CD 68 FC                 call    HL2DE           ; get start of directory into DE
1377+ F950 ED 53 13 55              ld      (DIR_STRT),DE   ; store
1378+ F954 CD 68 FC                 call    HL2DE           ; get start of data area into DE
1379+ F957 ED 53 15 55              ld      (DAT_STRT),DE   ; store
1380+ F95B C3 61 F9                 jp      LK4FILE1        ; check for name already present in dir and return to caller
1381+ F95E
1382+ F95E
1383+ F95E              ; *****************************************************************************
1384+ F95E              ; L O O K    F O R    A    F I L E
1385+ F95E              ; look for the given file into the dir
1386+ F95E              ; Carry is reset if not found, set otherwise
1387+ F95E              ; *****************************************************************************
1388+ F95E CD A8 FB     LK4FILE:    call    LDENTRIES       ; load entries into RAM register NTR_NBR
1389+ F961 CD 9F FC     LK4FILE1:   call    CLRIOBF         ; clear IO buffer
1390+ F964 CD B4 FC                 call    CLRDOSBF        ; clear DOS buffer
1391+ F967 11 A0 FD                 ld      DE,DOSBFR       ; DE set to beginning of DOS buffer
1392+ F96A CD 3B FC                 call    CHKNMVAL        ; check and copy file name
1393+ F96D DA 27 F6                 jp      C,NAMERR        ; if Carry, file name error
1394+ F970 C3 A0 FA                 jp      FILE_EXIST      ; check if file exists and return to caller
1395+ F973
1396+ F973
1397+ F973              ; *****************************************************************************
1398+ F973              ; F I L E    L O A D
1399+ F973              ; load a file from the disk into the memory
1400+ F973              ; *****************************************************************************
1401+ F973 CD 6A FB     LODFILE:    call    CHKSQFL         ; check if a seq. file is open
1402+ F976 C2 18 F6                 jp      NZ,FILOPCLER    ; jump if open
1403+ F979 CD 9F FC                 call    CLRIOBF         ; clear I/O
1404+ F97C CD 03 FC                 call    CHKDSKVAL       ; check DOS version & load disk details
1405+ F97F DA 30 F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
1406+ F982 CD 5E F9                 call    LK4FILE         ; look for given file
1407+ F985 D2 2A F6                 jp      NC,FLNTFND      ; file not found - error
1408+ F988 DD E5                    push    IX              ; copy pointer to file...
1409+ F98A E1                       pop     HL              ; ...into HL
1410+ F98B 01 10 00                 ld      BC,$0010        ; skip file name (16 chars)...
1411+ F98E 09                       add     HL,BC           ; ...by getting pointer to file details
1412+ F98F 7E                       ld      A,(HL)          ; load file type
1413+ F990 FE 80                    cp      $80             ; 'BAS' type?
1414+ F992 28 0C                    jr      Z,LDFL4         ; yes, jump over
1415+ F994 FE 81                    cp      $81             ; 'BIN' type?
1416+ F996 C2 2D F6                 jp      NZ,LODERR       ; no, raise error
1417+ F999 3A 2A 55                 ld      A,(TPBF4)       ; if BIN file, file must be loaded into its original position
1418+ F99C B7                       or      A               ; did the user set this?
1419+ F99D CA 2D F6                 jp      Z,LODERR        ; no, raise an error
1420+ F9A0 0E 04        LDFL4:      ld      C,$04           ; 4 steps forward and also 4 bytes to copy
1421+ F9A2 09                       add     HL,BC           ; point to starting sector
1422+ F9A3 11 1E 55                 ld      DE,MSW_SCT      ; point to store sector address of file
1423+ F9A6 ED B0                    ldir                    ; copy MSW/LSW from entry into buffer
1424+ F9A8 11 1B 55                 ld      DE,BYT_SIZ      ; point to store size of file
1425+ F9AB 01 03 00                 ld      BC,$0003        ; 3 bytes to copy
1426+ F9AE ED B0                    ldir                    ; copy size in bytes and sectors from entry into buffer
1427+ F9B0 11 C2 55                 ld      DE,PROGND       ; load start of BASIC RAM
1428+ F9B3 3A 2A 55                 ld      A,(TPBF4)       ; check where to save the data from
1429+ F9B6 B7                       or      A               ; is it 0? (meaning from the current BASIC pointers)
1430+ F9B7 28 03                    jr      Z,LDFL1         ; yes, don't re-load the file from the address stored into the file
1431+ F9B9 CD 68 FC                 call    HL2DE           ; no, load RAM address from disk
1432+ F9BC ED 53 22 55  LDFL1:      ld      (RAM_PTR),DE    ; store starting pointer
1433+ F9C0                          ; start loading from disk
1434+ F9C0 CD 9F FC     LDFL2:      call    CLRIOBF         ; clear I/O buffer
1435+ F9C3 ED 5B 1E 55              ld      DE,(MSW_SCT)    ; load MSW of sector
1436+ F9C7 ED 4B 20 55              ld      BC,(LSW_SCT)    ; load LSW of sector
1437+ F9CB CD 0E FD                 call    CF_SETSTR       ; set sector
1438+ F9CE CD 50 FD                 call    CF_RD_SEC       ; read sector
1439+ F9D1 2A 1B 55                 ld      HL,(BYT_SIZ)    ; load bytes left to be copied
1440+ F9D4 11 00 02                 ld      DE,$0200        ; are they < 512?
1441+ F9D7 CD 38 41                 call    CMP16
1442+ F9DA 30 04                    jr      NC,LDFL3        ; no, jump over
1443+ F9DC ED 5B 1B 55              ld      DE,(BYT_SIZ)    ; yes, so load only remaining bytes
1444+ F9E0 4B           LDFL3:      ld      C,E             ; move bytes to copy...
1445+ F9E1 42                       ld      B,D             ; ...into BC
1446+ F9E2 21 C0 FD                 ld      HL,IOBUFF       ; point to I/O buffer
1447+ F9E5 ED 5B 22 55              ld      DE,(RAM_PTR)    ; point to RAM where to save
1448+ F9E9 ED B0                    ldir                    ; copy data
1449+ F9EB 21 1D 55                 ld      HL,SCT_SIZ      ; sector counter
1450+ F9EE 35                       dec     (HL)            ; copied all the sectors?
1451+ F9EF CA 1E FA                 jp      Z,LDFLEX        ; yes, exit
1452+ F9F2 2A 22 55                 ld      HL,(RAM_PTR)    ; pointer to RAM
1453+ F9F5 11 00 02                 ld      DE,$0200        ; block of 512 bytes copied
1454+ F9F8 19                       add     HL,DE           ; calculate next starting address
1455+ F9F9 22 22 55                 ld      (RAM_PTR),HL    ; store next block
1456+ F9FC AF                       xor     A               ; reset Carry
1457+ F9FD 2A 1B 55                 ld      HL,(BYT_SIZ)    ; load left bytes
1458+ FA00 ED 52                    sbc     HL,DE           ; subtract copied bytes
1459+ FA02 22 1B 55                 ld      (BYT_SIZ),HL    ; store left bytes
1460+ FA05 ED 4B 20 55              ld      BC,(LSW_SCT)    ; load LSW of sector
1461+ FA09 03                       inc     BC              ; next sector
1462+ FA0A 78                       ld      A,B             ; BC=$0000?
1463+ FA0B B1                       or      C
1464+ FA0C 20 09                    jr      NZ,LDFL5        ; no, jump over
1465+ FA0E ED 5B 1E 55              ld      DE,(MSW_SCT)    ; load MSW of sector
1466+ FA12 13                       inc     DE              ; increment DE
1467+ FA13 ED 53 1E 55              ld      (MSW_SCT),DE    ; store new MSW of sector
1468+ FA17 ED 43 20 55  LDFL5:      ld      (LSW_SCT),BC    ; store new LSW of sector
1469+ FA1B C3 C0 F9                 jp      LDFL2           ; repeat
1470+ FA1E CD 44 FD     LDFLEX:     call    CF_STANDBY      ; set CF into stand-by mode
1471+ FA21 AF                       xor     A               ; clear Carry flag
1472+ FA22 C9                       ret                     ; return to caller
1473+ FA23
1474+ FA23
1475+ FA23              ; *****************************************************************************
1476+ FA23              ; F I L E    E R A S E
1477+ FA23              ; erase a file from disk, freeing its block
1478+ FA23              ; *****************************************************************************
1479+ FA23 CD 6A FB     FIL_ERASE:  call    CHKSQFL         ; check if a seq. file is open
1480+ FA26 C2 18 F6                 jp      NZ,FILOPCLER    ; jump if open
1481+ FA29 CD 9F FC                 call    CLRIOBF         ; clear I/O
1482+ FA2C CD 03 FC                 call    CHKDSKVAL       ; check DOS version & load disk details
1483+ FA2F DA 30 F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
1484+ FA32 CD 5E F9                 call    LK4FILE         ; look for given file
1485+ FA35 D2 2A F6                 jp      NC,FLNTFND      ; file not found - error
1486+ FA38 DD 5E 14                 ld      E,(IX+$14)      ; load MSW into DE
1487+ FA3B DD 56 15                 ld      D,(IX+$15)
1488+ FA3E DD 4E 16                 ld      C,(IX+$16)      ; load LSW into BC
1489+ FA41 DD 46 17                 ld      B,(IX+$17)
1490+ FA44 ED 53 1E 55              ld      (MSW_SCT),DE    ; store DE
1491+ FA48 ED 43 20 55              ld      (LSW_SCT),BC    ; store BC
1492+ FA4C DD 7E 1A                 ld      A,(IX+$1A)      ; load size in sectors
1493+ FA4F 32 1D 55                 ld      (SCT_SIZ),A     ; store it
1494+ FA52 3E 7F                    ld      A,$7F           ; marker for file deleted
1495+ FA54 DD 77 00                 ld      (IX),A          ; set file as deleted (quick erase)
1496+ FA57 3A 2A 55                 ld      A,(TPBF4)       ; check for quick or full delete
1497+ FA5A B7                       or      A               ; A=0 quick erase
1498+ FA5B 28 0A                    jr      Z,FIL_ERA5      ; jump if quick erase
1499+ FA5D AF                       xor     A               ; clear A
1500+ FA5E 06 20                    ld      B,$20           ; full erase - clean entry (32 cells)
1501+ FA60 DD 77 00     FIL_ERA6:   ld      (IX),A          ; reset cell
1502+ FA63 DD 23                    inc     IX              ; next cell
1503+ FA65 10 F9                    djnz    FIL_ERA6        ; repeat
1504+ FA67 ED 5B 26 55  FIL_ERA5:   ld      DE,(TPBF2)      ; retrieve MSW of current directory sector
1505+ FA6B ED 4B 28 55              ld      BC,(TPBF3)      ; retrieve LSW of current directory sector
1506+ FA6F CD 77 FD                 call    CF_WR_SEC       ; write sector
1507+ FA72 38 27                    jr      C,WRT_ERR       ; error?
1508+ FA74 3A 2A 55                 ld      A,(TPBF4)       ; check for quick or full delete
1509+ FA77 B7                       or      A               ; if A=0 then quick erase
1510+ FA78 28 1C                    jr      Z,FIL_ERA3      ; yes, leave
1511+ FA7A CD 9F FC                 call    CLRIOBF         ; no, full delete - clear I/O buffer
1512+ FA7D ED 5B 1E 55              ld      DE,(MSW_SCT)    ; load MSW of 1st sector of file block
1513+ FA81 ED 4B 20 55              ld      BC,(LSW_SCT)    ; load LSW of 1st sector of file block
1514+ FA85 21 1D 55                 ld      HL,SCT_SIZ      ; pointer to size in sectors
1515+ FA88 CD 77 FD     FIL_ERA1:   call    CF_WR_SEC       ; erase sector
1516+ FA8B 38 0E                    jr      C,WRT_ERR       ; error?
1517+ FA8D 03                       inc     BC              ; next sector
1518+ FA8E 78                       ld      A,B             ; is LSW rolled back to 0?
1519+ FA8F B1                       or      C
1520+ FA90 20 01                    jr      NZ,FIL_ERA2     ; no, jump over
1521+ FA92 13                       inc     DE              ; yes, increment MSW
1522+ FA93 35           FIL_ERA2:   dec     (HL)            ; decrement sector counter
1523+ FA94 20 F2                    jr      NZ,FIL_ERA1     ; repeat if other sectors
1524+ FA96 CD 44 FD     FIL_ERA3:   call    CF_STANDBY      ; set CF into stand-by mode
1525+ FA99 AF                       xor     A               ; clear Carry
1526+ FA9A C9                       ret
1527+ FA9B CD 44 FD     WRT_ERR:    call    CF_STANDBY      ; put CF into stand-by
1528+ FA9E 37                       scf                     ; set error
1529+ FA9F C9                       ret                     ; return to caller
1530+ FAA0
1531+ FAA0
1532+ FAA0              ; *****************************************************************************
1533+ FAA0              ; F I L E    C H E C K
1534+ FAA0              ; check if file name already exists in directory
1535+ FAA0              ; file name must be stored from DOSBFR   for 16 chars
1536+ FAA0              ; *****************************************************************************
1537+ FAA0 FD 2A 19 55  FILE_EXIST: ld      IY,(NTR_NBR)    ; load max entries
1538+ FAA4 CD 6F FB                 call    SETPTEN         ; point to 1st sector of dir
1539+ FAA7 CD 77 FB     CHKSTNM1:   call    PT2FSEN         ; point to 1st entry of a dir's sect
1540+ FAAA CD 82 FB     CHKSTNM2:   call    CKCREN          ; check current entry
1541+ FAAD 28 28                    jr      Z,CHKSTNM10     ; if empty or deleted, jump over
1542+ FAAF 22 24 55                 ld      (TPBF1),HL      ; store HL
1543+ FAB2 ED 53 26 55              ld      (TPBF2),DE      ; store DE
1544+ FAB6 ED 43 28 55              ld      (TPBF3),BC      ; store BC
1545+ FABA DD E5                    push    IX              ; copy IX...
1546+ FABC E1                       pop     HL              ; ...into HL
1547+ FABD 11 A0 FD                 ld      DE,DOSBFR       ; beginning of name file
1548+ FAC0 06 10                    ld      B,$10           ; 16 chars to check
1549+ FAC2 1A           CHKSTNM3:   ld      A,(DE)          ; load a char from name on disk
1550+ FAC3 ED A1                    cpi                     ; compare with name from user
1551+ FAC5 20 05                    jr      NZ,CHKSTNM6     ; chars are different, leave
1552+ FAC7 13                       inc     DE              ; inc DE (HL is incremented by "cpi")
1553+ FAC8 10 F8                    djnz    CHKSTNM3        ; repeat for 16 chars
1554+ FACA 18 17                    jr      FLEXST          ; file exists in dir
1555+ FACC 2A 24 55     CHKSTNM6:   ld      HL,(TPBF1)      ; retrieve HL
1556+ FACF ED 5B 26 55              ld      DE,(TPBF2)      ; retrieve DE
1557+ FAD3 ED 4B 28 55              ld      BC,(TPBF3)      ; retrieve sector counter
1558+ FAD7 CD 8A FB     CHKSTNM10:  call    GTNXTEN         ; other entries in this sector?
1559+ FADA 20 CE                    jr      NZ,CHKSTNM2     ; yes, continue check
1560+ FADC CD 96 FB                 call    CKLSTEN         ; go to next sector
1561+ FADF 30 C6                    jr      NC,CHKSTNM1     ; more entries? repeat
1562+ FAE1 AF                       xor     A               ; file not found, reset Carry
1563+ FAE2 C9                       ret                     ; return
1564+ FAE3 37           FLEXST:     scf                     ; file is present - set Carry flag for error
1565+ FAE4 C9                       ret
1566+ FAE5
1567+ FAE5
1568+ FAE5              ; *****************************************************************************
1569+ FAE5              ; UNDELETE DELETED FILES
1570+ FAE5              ; look for deleted files and undelete them
1571+ FAE5              ; *****************************************************************************
1572+ FAE5 CD 9F FC     DSKUNDFL:   call    CLRIOBF         ; clear I/O
1573+ FAE8 CD 03 FC                 call    CHKDSKVAL       ; check DOS version & load disk details
1574+ FAEB DA 30 F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
1575+ FAEE CD 32 FB                 call    FNDFRENTR       ; find a free entry
1576+ FAF1 D8           DSKUNDFL1:  ret     C               ; return if entries are finished
1577+ FAF2 DD 7E 00                 ld      A,(IX)          ; reload first char of entry
1578+ FAF5 FE 7F                    cp      $7F             ; is it a deleted entry?
1579+ FAF7 20 29                    jr      NZ,DSKUNDFL2    ; no, jump over
1580+ FAF9 CD DA FB                 call    RND8            ; get a random char
1581+ FAFC CD F8 FB                 call    CHATOZ          ; transform it into a letter
1582+ FAFF DD 77 00                 ld      (IX),A          ; store it as the first letter of filename
1583+ FB02 CD 77 FD                 call    CF_WR_SEC       ; write sector (address is into DEBC)
1584+ FB05 E5                       push    HL              ; store HL
1585+ FB06 C5                       push    BC              ; store BC
1586+ FB07 D5                       push    DE              ; store DE
1587+ FB08 DD E5                    push    IX              ; copy IX...
1588+ FB0A E1                       pop     HL              ; ...into HL
1589+ FB0B 06 10                    ld      B,$10           ; 16 chars
1590+ FB0D 7E           DSKUNDPR:   ld      A,(HL)          ; retrieve char from filename
1591+ FB0E CD 20 1B                 call    OUTC            ; print char
1592+ FB11 23                       inc     HL              ; next char
1593+ FB12 10 F9                    djnz    DSKUNDPR        ; repeat
1594+ FB14 3E 20                    ld      A,SPC           ; print a space
1595+ FB16 CD 20 1B                 call    OUTC
1596+ FB19 21 27 FB                 ld      HL,DSKUNDTXT    ; print undeleted message
1597+ FB1C CD F7 26                 call    PRS
1598+ FB1F D1                       pop     DE              ; retrieve DE
1599+ FB20 C1                       pop     BC              ; retrieve BC
1600+ FB21 E1                       pop     HL              ; retrieve HL
1601+ FB22 CD 46 FB     DSKUNDFL2:  call    FNDFRENTR4      ; goto next entry
1602+ FB25 18 CA                    jr      DSKUNDFL1       ; repeat
1603+ FB27 75 6E 64 65  DSKUNDTXT:  defb    "undeleted",CR,0
1603+ FB2B 6C 65 74 65
1603+ FB2F 64 0D 00
1604+ FB32
1605+ FB32
1606+ FB32              ; *****************************************************************************
1607+ FB32              ; FIND A FREE ENTRY
1608+ FB32              ; find a free entry in the directory to store a new file
1609+ FB32              ; *****************************************************************************
1610+ FB32 CD B7 FB     FNDFRENTR:  call    LDMSCT          ; read Master Sector
1611+ FB35 CD A8 FB                 call    LDENTRIES       ; load entries into RAM register NTR_NBR and DE
1612+ FB38 D5                       push    DE              ; copy number of entries...
1613+ FB39 FD E1                    pop     IY              ; ...into IY
1614+ FB3B CD 6F FB                 call    SETPTEN         ; point to first entry
1615+ FB3E CD 77 FB     FNDFRENTR1: call    PT2FSEN         ; point to 1st entry of sector
1616+ FB41 CD 82 FB     FNDFRENTR2: call    CKCREN          ; check current entry
1617+ FB44 28 0B                    jr      Z,FNDFRENTR3    ; found a free entry
1618+ FB46 CD 8A FB     FNDFRENTR4: call    GTNXTEN         ; other entries in this sector?
1619+ FB49 20 F6                    jr      NZ,FNDFRENTR2   ; yes, continue check
1620+ FB4B CD 96 FB                 call    CKLSTEN         ; go to next sector
1621+ FB4E 30 EE                    jr      NC,FNDFRENTR1   ; more entries? repeat
1622+ FB50 C9                       ret                     ; entries finished - leave
1623+ FB51 ED 43 17 55  FNDFRENTR3: ld      (DIR_SCT),BC    ; store sector of dir
1624+ FB55 22 19 55                 ld      (NTR_NBR),HL    ; store entry number
1625+ FB58 AF                       xor     A               ; reset Carry
1626+ FB59 C9                       ret
1627+ FB5A
1628+ FB5A
1629+ FB5A              ; *****************************************************************************
1630+ FB5A              ;   U T I L I T I E S
1631+ FB5A              ; *****************************************************************************
1632+ FB5A
1633+ FB5A
1634+ FB5A              ; check if EOF for seq. file
1635+ FB5A              ; C is set if EOF, NC otherwise
1636+ FB5A              ; destroys DE & HL
1637+ FB5A              ; return: DE=size of seq. file; C=1 if EOF, C=0 otherwise
1638+ FB5A ED 5B DD FF  CHKEOF:     ld      DE,(SEQBYSZ)    ; size of seq. file
1639+ FB5E 7B                       ld      A,E             ; check if file size...
1640+ FB5F B2                       or      D               ; ...is 0
1641+ FB60 28 06                    jr      Z,CHKEOFC       ; yes, EOF
1642+ FB62 2A DF FF                 ld      HL,(SEQPNT)     ; pointer to last byte of seq. file
1643+ FB65 CD 38 41                 call    CMP16           ; over the EOF?
1644+ FB68 3F           CHKEOFC:    ccf                     ; invert Carry
1645+ FB69 C9                       ret
1646+ FB6A
1647+ FB6A
1648+ FB6A              ; check if a sequential file is open
1649+ FB6A 3A D6 FF     CHKSQFL:    ld      A,(SEQFL)       ; seq. file status
1650+ FB6D B7                       or      A               ; if A<>0 then a file is open
1651+ FB6E C9                       ret                     ; return to caller
1652+ FB6F
1653+ FB6F
1654+ FB6F              ; set up registers to point to first sector of directory
1655+ FB6F 01 01 00     SETPTEN:    ld      BC,$0001        ; BC=$0001 (starting sector of dir) (LSW)
1656+ FB72 50                       ld      D,B             ; DE=$0000 (starting sector of dir) (MSW)
1657+ FB73 58                       ld      E,B
1658+ FB74 60                       ld      H,B             ; HL=$0000 (entry counter)
1659+ FB75 68                       ld      L,B
1660+ FB76 C9                       ret                     ; return to caller
1661+ FB77
1662+ FB77
1663+ FB77              ; load a sector and point to first entry
1664+ FB77 CD 0E FD     PT2FSEN:    call    CF_SETSTR       ; set sector to read (BC-DE)
1665+ FB7A CD 50 FD                 call    CF_RD_SEC       ; read sector
1666+ FB7D DD 21 C0 FD              ld      IX,IOBUFF       ; beginning of I/O buffer
1667+ FB81 C9                       ret
1668+ FB82
1669+ FB82
1670+ FB82              ; check current entry
1671+ FB82 DD 7E 00     CKCREN:     ld      A,(IX)          ; load 1st char of entry name
1672+ FB85                          ;dec     IY              ; decrement number of entries
1673+ FB85 B7                       or      A               ; is it $00 (empty entry)?
1674+ FB86 C8                       ret     Z               ; yes, found an entry
1675+ FB87 FE 7F                    cp      $7F             ; is it $7F (deleted entry)?
1676+ FB89 C9                       ret
1677+ FB8A
1678+ FB8A
1679+ FB8A              ; goto next entry
1680+ FB8A C5           GTNXTEN:    push    BC              ; store BC
1681+ FB8B 01 20 00                 ld      BC,$0020        ; load BC with directory entry size (32 bytes)
1682+ FB8E DD 09                    add     IX,BC           ; next entry in current sector
1683+ FB90 C1                       pop     BC              ; retrieve sector pointer
1684+ FB91 23                       inc     HL              ; increment entry counter
1685+ FB92 7D                       ld      A,L
1686+ FB93 E6 0F                    and     %00001111       ; just done 16 entries?
1687+ FB95 C9                       ret
1688+ FB96
1689+ FB96
1690+ FB96              ; check if reached last entry
1691+ FB96              ; Carry is set if entries finished
1692+ FB96 03           CKLSTEN:    inc     BC              ; entries in this sector finished .. goto next sector
1693+ FB97 78                       ld      A,B             ; check if...
1694+ FB98 B1                       or      C               ; ...BC=$000
1695+ FB99 20 01                    jr      NZ,CKLSTEN1     ; no, jump over
1696+ FB9B 13                       inc     DE              ; yes, increment DE (MSW)
1697+ FB9C E5           CKLSTEN1:   push    HL              ; preserve current entry
1698+ FB9D D5                       push    DE
1699+ FB9E FD E5                    push    IY              ; copy max allowed files...
1700+ FBA0 D1                       pop     DE              ; ...into HL
1701+ FBA1 CD 38 41                 call    CMP16           ; check if reached max allowed entries
1702+ FBA4 D1                       pop     DE
1703+ FBA5 E1                       pop     HL              ; (retrieve current entry)
1704+ FBA6 3F                       ccf
1705+ FBA7 C9                       ret                     ; return
1706+ FBA8
1707+ FBA8
1708+ FBA8              ; load entries intro RAM register
1709+ FBA8 21 C0 FD     LDENTRIES:  ld      HL,IOBUFF       ; start of I/O buffer
1710+ FBAB 01 19 00                 ld      BC,$0019        ; point to max. allowed entries
1711+ FBAE 09                       add     HL,BC           ; get address
1712+ FBAF CD 68 FC                 call    HL2DE           ; get entries into DE
1713+ FBB2 ED 53 19 55              ld      (NTR_NBR),DE    ; store
1714+ FBB6 C9                       ret                     ; return to caller
1715+ FBB7
1716+ FBB7
1717+ FBB7              ; load Master Sector (sector #0)
1718+ FBB7 01 00 00     LDMSCT:     ld      BC,$0000        ; LSW of sector
1719+ FBBA 50                       ld      D,B             ; MSW of sector
1720+ FBBB 58                       ld      E,B
1721+ FBBC CD 0E FD                 call    CF_SETSTR       ; set sector
1722+ FBBF CD 50 FD                 call    CF_RD_SEC       ; read sector
1723+ FBC2 C9                       ret
1724+ FBC3
1725+ FBC3
1726+ FBC3              ; generate random disk ID
1727+ FBC3 C5           RND_ID:     push    BC
1728+ FBC4 06 02                    ld      B,$02           ; repeat 2 times
1729+ FBC6 CD DA FB     RND_ID1:    call    RND8            ; get a random value
1730+ FBC9 CD F8 FB                 call    CHATOZ          ; transform it into a letter
1731+ FBCC 12                       ld      (DE),A          ; store it
1732+ FBCD 13                       inc     DE              ; inc pointer
1733+ FBCE CD DA FB                 call    RND8            ; get a random value
1734+ FBD1 CD ED FB                 call    CH0TO9          ; transform it into a number from 0 to 9
1735+ FBD4 12                       ld      (DE),A          ; store it
1736+ FBD5 13                       inc     DE              ; inc pointer
1737+ FBD6 10 EE                    djnz    RND_ID1         ; repeat
1738+ FBD8 C1                       pop     BC
1739+ FBD9 C9                       ret                     ; return to caller
1740+ FBDA
1741+ FBDA
1742+ FBDA              ; generate a pseudo-random number using TMR and R registers
1743+ FBDA C5           RND8:       push    BC              ; store B
1744+ FBDB 3A 5C 55                 ld      A,(TMRCNT)      ; load LSW of sys-timer
1745+ FBDE 47                       ld      B,A             ; copy into B
1746+ FBDF ED 5F                    ld      A,R             ; load refresh register
1747+ FBE1 A8                       xor     B               ; A xor B
1748+ FBE2 47                       ld      B,A             ; copy into B
1749+ FBE3 0F                       rrca                    ; multiply by 32
1750+ FBE4 0F                       rrca
1751+ FBE5 0F                       rrca
1752+ FBE6 EE 1F                    xor     $1F             ; a XOR to mix bits
1753+ FBE8 80                       add     A,B             ; add B
1754+ FBE9 DE FF                    sbc     A,255           ; carry
1755+ FBEB C1                       pop     BC              ; retrieve B
1756+ FBEC C9                       ret                     ; return to caller
1757+ FBED
1758+ FBED
1759+ FBED              ; char ported into 0-9 interval
1760+ FBED E6 0F        CH0TO9:     and     %00001111       ; get only low nibble
1761+ FBEF FE 0A                    cp      $0A             ; is it < 10?
1762+ FBF1 38 02                    jr      C,CH0TO9E       ; yes, jump over
1763+ FBF3 D6 0A                    sub     $0A             ; subract 10
1764+ FBF5 C6 30        CH0TO9E:    add     $30             ; get a number from 0 to 9
1765+ FBF7 C9                       ret
1766+ FBF8
1767+ FBF8
1768+ FBF8              ; char ported into A-Z interval
1769+ FBF8 E6 1F        CHATOZ:     and     %00011111       ; get only first 5 bits
1770+ FBFA FE 1A                    cp      $1A             ; is it < 26?
1771+ FBFC 38 02                    jr      C,CHATOZE       ; yes, jump over
1772+ FBFE D6 1A                    sub     $1A             ; no, subtract 26
1773+ FC00 C6 41        CHATOZE:    add     $41             ; get a letter from 'A' to 'Z'
1774+ FC02 C9                       ret                     ; return to caller
1775+ FC03
1776+ FC03
1777+ FC03              ; first check DOS validity then load disk details
1778+ FC03 CD CC FC     CHKDSKVAL:  call    CF_INIT         ; open CF card comm.
1779+ FC06 D8                       ret     C               ; if errors, leave
1780+ FC07 C5                       push    BC              ; store BC
1781+ FC08 D5                       push    DE              ; store DE
1782+ FC09 E5                       push    HL              ; store HL
1783+ FC0A 01 00 00                 ld      BC,$0000        ; reset LSW of sector
1784+ FC0D 50                       ld      D,B             ; reset MSW of sector
1785+ FC0E 58                       ld      E,B
1786+ FC0F CD 0E FD                 call    CF_SETSTR       ; set sector #0
1787+ FC12 CD 50 FD                 call    CF_RD_SEC       ; read sector
1788+ FC15 21 C0 FD                 ld      HL,IOBUFF       ; address of default conf. buffer
1789+ FC18 11 0A 00                 ld      DE,$000A        ; point to disk DOS version
1790+ FC1B 19                       add     HL,DE
1791+ FC1C 11 72 EE                 ld      DE,DSKHDR+10    ; get starting address of I/O buffer
1792+ FC1F 06 04                    ld      B,$04           ; 4 chars
1793+ FC21 1A           CHKDSKVAL1: ld      A,(DE)          ; load char from DOS version into memory
1794+ FC22 BE                       cp      (HL)            ; compare with disk DOS version
1795+ FC23 20 11                    jr      NZ,CHKDSKVALE   ; no match - so error
1796+ FC25 13                       inc     DE              ; next source
1797+ FC26 23                       inc     HL              ; next comparison
1798+ FC27 10 F8                    djnz    CHKDSKVAL1      ; repeat
1799+ FC29 21 A0 FD                 ld      HL,DOSBFR       ; address of default conf. buffer
1800+ FC2C 11 1D 00                 ld      DE,$001D        ; point to address of data area
1801+ FC2F 19                       add     HL,DE           ; set pointer to beginning of identifies
1802+ FC30 CD 68 FC                 call    HL2DE           ; first sector of data area into DE
1803+ FC33 AF                       xor     A               ; no error - clear Carry flag
1804+ FC34 18 01                    jr      CHKDSKVAL2      ; jump over
1805+ FC36 37           CHKDSKVALE: scf                     ; error - set carry flag
1806+ FC37 E1           CHKDSKVAL2: pop     HL
1807+ FC38 D1                       pop     DE
1808+ FC39 C1                       pop     BC
1809+ FC3A C9                       ret                     ; return to caller
1810+ FC3B
1811+ FC3B
1812+ FC3B              ; check name validity (only allowed chars) and copy it from string pool into a temp buff
1813+ FC3B              ; Inputs: DE: pointer to dest. buffer
1814+ FC3B              ; operation: copy (HL)->(DE) and pads to get a 16-chars name
1815+ FC3B              ; destroys: A, BC, DE, HL
1816+ FC3B ED 4B 80 55  CHKNMVAL:   ld      BC,(DKLNPT)     ; load lenght of name
1817+ FC3F 79                       ld      A,C             ; lenght is max. 16 char, so we only check C
1818+ FC40 FE 11                    cp      $11             ; is it <=16?
1819+ FC42 38 02                    jr      C,CHKNMVAL1     ; yes, so jump over
1820+ FC44 0E 10                    ld      C,$10           ; no, get only 16 chars
1821+ FC46 41           CHKNMVAL1:  ld      B,C             ; copy lenght into B
1822+ FC47 0E 10                    ld      C,$10           ; char counter
1823+ FC49 2A 7E 55                 ld      HL,(DKNMPT)     ; pointer to name
1824+ FC4C 7E           CHKNMVAL2:  ld      A,(HL)          ; get a char from string name
1825+ FC4D CD 89 FC                 call    CHK_NAM         ; check if valid
1826+ FC50 D8                       ret     C               ; no, name error
1827+ FC51 12                       ld      (DE),A          ; yes, store char
1828+ FC52 13                       inc     DE              ; next I/O location
1829+ FC53 23                       inc     HL              ; next name char
1830+ FC54 0D                       dec     C               ; decrement number of chars copied
1831+ FC55 10 F5                    djnz    CHKNMVAL2       ; repeat until name ends
1832+ FC57 79                       ld      A,C             ; check if there are no empty chars in file
1833+ FC58 B7                       or      A
1834+ FC59 C8                       ret     Z               ; yes, job finished - return
1835+ FC5A 3E 20                    ld      A,SPC           ; no, padding required
1836+ FC5C 12           CHKNMVAL3:  ld      (DE),A          ; store char
1837+ FC5D 13                       inc     DE              ; next location
1838+ FC5E 0D                       dec     C               ; check if padding is over
1839+ FC5F 20 FB                    jr      NZ,CHKNMVAL3    ; no, continue
1840+ FC61 AF                       xor     A               ; clear Carry flag
1841+ FC62 C9                       ret                     ; return to caller
1842+ FC63
1843+ FC63
1844+ FC63              ; store DE into (HL) and (HL+1)
1845+ FC63 73           DE2HL:      ld      (HL),E          ; LSW of size
1846+ FC64 23                       inc     HL
1847+ FC65 72                       ld      (HL),D          ; MSW of size
1848+ FC66 23                       inc     HL
1849+ FC67 C9                       ret                     ; return to caller
1850+ FC68
1851+ FC68
1852+ FC68              ; get DE from (HL) and (HL+1)
1853+ FC68 5E           HL2DE:      ld      E,(HL)          ; get LSW into E
1854+ FC69 23                       inc     HL              ; next location
1855+ FC6A 56                       ld      D,(HL)          ; get MSW into D
1856+ FC6B 23                       inc     HL              ; next location
1857+ FC6C C9                       ret                     ; return to caller
1858+ FC6D
1859+ FC6D
1860+ FC6D              ; convert a 16/32-bit number into an ASCII string and print it
1861+ FC6D              ; inputs: HL pointer to 32-bit number
1862+ FC6D CD 68 FC     PRN32ASCII: call    HL2DE           ; load MSW into DE  <-- entry for 32-bit
1863+ FC70 4E           PRN16ASCII: ld      C,(HL)          ; load LSW into BC   <-- entry for 16-bit (set DE to $0000 before to call)
1864+ FC71 23                       inc     HL
1865+ FC72 46                       ld      B,(HL)
1866+ FC73 C5                       push    BC              ; copy BC...
1867+ FC74 DD E1                    pop     IX              ; ...into IX
1868+ FC76 FD 21 24 55  PRN16ASCIX: ld      IY,TPBF1        ; number is into DEIX - now, load pointer to destination buffer
1869+ FC7A CD 01 42                 call    CLCN32          ; convert number in DEIX into ASCII number
1870+ FC7D 21 24 55                 ld      HL,TPBF1        ; address of ASCII number
1871+ FC80 7E           PRNTSIZ:    ld      A,(HL)          ; get a char
1872+ FC81 B7                       or      A               ; is it $00 (end of string)?
1873+ FC82 C8                       ret     Z               ; yes, leave
1874+ FC83 CD 20 1B                 call    OUTC            ; no, print char
1875+ FC86 23                       inc     HL              ; next char
1876+ FC87 18 F7                    jr      PRNTSIZ         ; repeat
1877+ FC89
1878+ FC89
1879+ FC89              ; check for non-allowed chars in disk/file names - allowed chars: '0'-'9', 'A'-'Z', '-', SPACE
1880+ FC89              ; input: A -> char to check
1881+ FC89              ; return: C is set if ERROR, reset otherwise
1882+ FC89 FE 20        CHK_NAM:    cp      SPC             ; is it a space?
1883+ FC8B C8                       ret     Z               ; return if equal (C is reset)
1884+ FC8C FE 2D                    cp      '-'             ; is it a minus?
1885+ FC8E C8                       ret     Z               ; return if equal
1886+ FC8F FE 30                    cp      '0'             ; char < '0' ?
1887+ FC91 D8                       ret     C               ; yes, disk name error
1888+ FC92 FE 3A                    cp      ':'             ; is char <= '9' ?
1889+ FC94 38 07                    jr      C,CHK_C_CF      ; yes, leave
1890+ FC96 E6 5F                    and     %01011111       ; for letters, only UPPER CASE
1891+ FC98 FE 41                    cp      'A'             ; is char >= 'A' ?
1892+ FC9A D8                       ret     C               ; no, error
1893+ FC9B FE 5B                    cp      '['             ; is char <= 'Z' ? (if yes, C=1, then C=0; otherwise, C=0 then C=1)
1894+ FC9D 3F           CHK_C_CF:   ccf                     ; Carry complement (invert Carry)
1895+ FC9E C9                       ret                     ; return to caller
1896+ FC9F
1897+ FC9F
1898+ FC9F              ; clear I/O buffer
1899+ FC9F F5           CLRIOBF:    push    AF              ; store AF
1900+ FCA0 C5                       push    BC              ; store BC
1901+ FCA1 E5                       push    HL              ; store HL
1902+ FCA2 21 C0 FD                 ld 	    HL,IOBUFF       ; load address of I/O buffer
1903+ FCA5 01 02 00                 ld      BC,$0002        ; B=256 iterations ($00); C=repeat 2 times
1904+ FCA8 AF           CLRBUFF:    xor     A               ; reset A   ----- common part -----
1905+ FCA9 77           RSTIOBF:    ld      (HL),A          ; reset cell
1906+ FCAA 23                       inc     HL              ; next cell
1907+ FCAB 10 FC                    djnz    RSTIOBF         ; repeat for 256 times
1908+ FCAD 0D                       dec     C               ; decrement C
1909+ FCAE 20 F9                    jr      NZ,RSTIOBF      ; repeat if not zero
1910+ FCB0 E1                       pop     HL              ; retrieve HL
1911+ FCB1 C1                       pop     BC              ; retrieve BC
1912+ FCB2 F1                       pop     AF              ; retrieve AF
1913+ FCB3 C9                       ret                     ; return to caller
1914+ FCB4
1915+ FCB4
1916+ FCB4              ; clear DOS buffer
1917+ FCB4 F5           CLRDOSBF:   push    AF              ; store AF
1918+ FCB5 C5                       push    BC              ; store BC
1919+ FCB6 E5                       push    HL              ; store HL
1920+ FCB7 21 A0 FD                 ld 	    HL,DOSBFR       ; load address of DOS buffer
1921+ FCBA 01 01 20                 ld      BC,$2001        ; B=32 iterations; C=repeat 1 time
1922+ FCBD C3 A8 FC                 jp      CLRBUFF         ; continue to common part
1923+ FCC0
1924+ FCC0
1925+ FCC0              ; clear seq. file buffer
1926+ FCC0 F5           CLRSEQBF:   push    AF              ; store AF
1927+ FCC1 C5                       push    BC              ; store BC
1928+ FCC2 E5                       push    HL              ; store HL
1929+ FCC3 21 D6 FF                 ld 	    HL,SEQFL        ; load address of DOS buffer
1930+ FCC6 01 01 0B                 ld      BC,$0B01        ; B=11 iterations; C=repeat 1 time
1931+ FCC9 C3 A8 FC                 jp      CLRBUFF         ; continue to common part
1932+ FCCC
# file closed: ../include/dos/dos-1.05.asm
  95  FCCC                  INCLUDE "../include/dos/bios-1.03.asm"
# file opened: ../include/dos/bios-1.03.asm
   1+ FCCC              ; ------------------------------------------------------------------------------
   2+ FCCC              ; LM80C 64K - BIOS ROUTINES - R1.03
   3+ FCCC              ; ------------------------------------------------------------------------------
   4+ FCCC              ; The following code is intended to be used with LM80C Z80-based computer
   5+ FCCC              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ FCCC              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ FCCC              ; kind of warranty: you can use them at your own risk.
   8+ FCCC              ; You are free to use them for any non-commercial use: you are only asked to
   9+ FCCC              ; maintain the copyright notices, include this advice and the note to the
  10+ FCCC              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ FCCC              ; redistribuite them.
  12+ FCCC              ; https://www.leonardomiliani.com
  13+ FCCC              ;
  14+ FCCC              ; Please support me by visiting the following links:
  15+ FCCC              ; Main project page: https://www.leonardomiliani.com
  16+ FCCC              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ FCCC              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ FCCC              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ FCCC              ; ------------------------------------------------------------------------------
  20+ FCCC              ;
  21+ FCCC              ; ------------------------------------------------------------------------------
  22+ FCCC              ; Code Revision:
  23+ FCCC              ; R1.0  - 20210307 - first release
  24+ FCCC              ; R1.01 - 20210310 - Code optimizing & better error handling
  25+ FCCC              ; R1.02 - 20210316 - disk speed improvements with INIR and OTIR
  26+ FCCC              ; R1.03 - 20210319 - code re-organization and new positioning into RAM
  27+ FCCC              ;
  28+ FCCC              ;------------------------------------------------------------------------------
  29+ FCCC
  30+ FCCC              ; equates for CF at port $50
  31+ FCCC              CF_DATA:        equ %01010000   ; ($50) Data register (R/W)
  32+ FCCC              CF_ERR:         equ %01010001   ; ($51) Error (R)
  33+ FCCC              CF_FTR:         equ %01010001   ; ($51) Features (W)
  34+ FCCC              CF_SECCNT:      equ %01010010   ; ($52) Sector count register (R/W)
  35+ FCCC              CF_LBA0:        equ %01010011   ; ($53) LBA register 0 (bits 0-7) (R/W)
  36+ FCCC              CF_LBA1:        equ %01010100   ; ($54) LBA register 1 (bits 8-15) (R/W)
  37+ FCCC              CF_LBA2:        equ %01010101   ; ($55) LBA register 2 (bits 16-23) (R/W)
  38+ FCCC              CF_LBA3:        equ %01010110   ; ($56) LBA register 3 (bits 24-27) (R/W) - bits 28-31 must be set to 111 in LBA mode
  39+ FCCC              CF_STAT:        equ %01010111   ; ($57) Status (R)
  40+ FCCC              CF_CMD:         equ %01010111   ; ($57) Command register (W)
  41+ FCCC
  42+ FCCC
  43+ FCCC              ;------------------------------------------------------------------------------
  44+ FCCC              ; R O U T I N E S
  45+ FCCC              ;------------------------------------------------------------------------------
  46+ FCCC
  47+ FCCC              BIOSSTART:  equ     $
  48+ FCCC              ; initilialize CF to work with, wakeing it up from standby and setting it to work in 8-bit mode
  49+ FCCC CD E2 FC     CF_INIT:    call    CF_NOP          ; execute a NOP to wake up the CF
  50+ FCCF CD 30 FD                 call    CR_DEV_RDY      ; wait for CF available and ready
  51+ FCD2 D8                       ret     C               ; no card or I/O error, leave
  52+ FCD3 3E 01                    ld      A,$01           ; 8-bit mode
  53+ FCD5 D3 51                    out     (CF_FTR),A      ; set mode
  54+ FCD7 CD EB FC                 call    CF_BUSY         ; wait for CF being ready
  55+ FCDA 3E EF                    ld      A,$EF           ; command to set mode
  56+ FCDC D3 57                    out     (CF_CMD),A      ; execute command
  57+ FCDE CD EB FC                 call    CF_BUSY         ; wait for CF being ready
  58+ FCE1 C9                       ret                     ; return to caller
  59+ FCE2
  60+ FCE2
  61+ FCE2              ; a NOP command, just used to wake up the CF card
  62+ FCE2 3E 69        CF_NOP:     ld      A,$69           ; NOP command
  63+ FCE4 D3 51                    out     (CF_FTR),A      ; send it
  64+ FCE6 3E EF                    ld      A,$EF           ; set mode command
  65+ FCE8 D3 57                    out     (CF_CMD),A      ; execute NOP
  66+ FCEA C9                       ret                     ; return to caller
  67+ FCEB
  68+ FCEB
  69+ FCEB              ; wait until BUSY bit is 0 (means CF has executed the requested job)
  70+ FCEB DB 57        CF_BUSY:    in      A,(CF_STAT)     ; read status register
  71+ FCED 07                       rlca                    ; copy bit #7 into the Carry
  72+ FCEE DA EB FC                 jp      C,CF_BUSY       ; loop while bit #7 is 1
  73+ FCF1 C9                       ret                     ; bit #7 cleared - return to caller
  74+ FCF2
  75+ FCF2
  76+ FCF2              ; check that CF is ready to get commands
  77+ FCF2 DB 57        CF_CMDRDY:  in      A,(CF_STAT)     ; read status register
  78+ FCF4 CB 47                    bit     0,A             ; any error?
  79+ FCF6 20 07                    jr      NZ,RETERR       ; yes, return error
  80+ FCF8 E6 C0                    and     %11000000       ; check only bits #6 & #7
  81+ FCFA EE 40                    xor     %01000000       ; bit #7 (BUSY) must be 0 and bit #6 (DRVRDY) must be 1
  82+ FCFC 20 F4                    jr      NZ,CF_CMDRDY    ; wait
  83+ FCFE C9                       ret                     ; return to caller
  84+ FCFF 37           RETERR:     scf                     ; set carry flag
  85+ FD00 C9                       ret                     ; return
  86+ FD01
  87+ FD01
  88+ FD01              ; wait until data is ready to be read
  89+ FD01 DB 57        CF_DAT_RDY: in      A,(CF_STAT)     ; read status register
  90+ FD03 CB 47                    bit     0,A             ; any error?
  91+ FD05 20 F8                    jr      NZ,RETERR       ; yes, return error
  92+ FD07 E6 88                    and     %10001000       ; check only bits #7 & #3
  93+ FD09 EE 08                    xor     %00001000       ; bit #7 (BUSY) must be 0 and bit #3 (DRQ) must be 1
  94+ FD0B 20 F4                    jr      NZ,CF_DAT_RDY   ; wait until data is ready
  95+ FD0D C9                       ret                     ; return to caller
  96+ FD0E
  97+ FD0E
  98+ FD0E              ; set sector to read from/write to - sector number is into DEBC (C=LSB, D=MSB)
  99+ FD0E CD F2 FC     CF_SETSTR:  call    CF_CMDRDY       ; Make sure drive is ready for command
 100+ FD11 3E 01                    ld      A,$01           ; 1 sector at a time
 101+ FD13 D3 52                    out     (CF_SECCNT),A   ; set number of sectors
 102+ FD15 CD F2 FC                 call    CF_CMDRDY       ; Make sure drive is ready for command
 103+ FD18 79                       ld      A,C             ; load LBA0 byte
 104+ FD19 D3 53                    out     (CF_LBA0),A     ; send it
 105+ FD1B CD F2 FC                 call    CF_CMDRDY       ; Make sure drive is ready for command
 106+ FD1E 78                       ld      A,B             ; load LBA1 byte
 107+ FD1F D3 54                    out     (CF_LBA1),A     ; send it
 108+ FD21 CD F2 FC                 call    CF_CMDRDY       ; Make sure drive is ready for command
 109+ FD24 7B                       ld      A,E             ; load LBA2 byte
 110+ FD25 D3 55                    out     (CF_LBA2),A     ; send it
 111+ FD27 CD F2 FC                 call    CF_CMDRDY       ; Make sure drive is ready for command
 112+ FD2A 3E E0                    ld      A,$E0           ; load LBA3 byte+master+LBA addressing
 113+ FD2C B2                       or      D               ; add LBA sector
 114+ FD2D D3 56                    out     (CF_LBA3),A     ; send it
 115+ FD2F C9                       ret                     ; return to caller
 116+ FD30
 117+ FD30
 118+ FD30              ; check if device is available & ready - try a bit of times, then exit with
 119+ FD30              ; error if no response, otherwise wait until device is ready
 120+ FD30              ; return Carry = 0 if device is available and ready, Carry = 1 if errors
 121+ FD30 C5           CR_DEV_RDY: push    BC              ; store HL
 122+ FD31 06 00                    ld      B,$00           ; 256 tries
 123+ FD33 0E 57                    ld      C,CF_STAT       ; address of status register
 124+ FD35 ED 78        CR_DV_RD_1: in      A,(C)           ; load status register (curiously, with no CF attached, in(CF_STAT) returns %01111000)
 125+ FD37 FE 40                    cp      %01000000       ; busy=0, rdy=1
 126+ FD39 28 07                    jr      Z,CR_DV_RD_E    ; got a response, so leave
 127+ FD3B FE 50                    cp      %01010000       ; busy=0, rdy=1, dsc=1
 128+ FD3D 28 03                    jr      Z,CR_DV_RD_E    ; got a response, so leave
 129+ FD3F 10 F4                    djnz    CR_DV_RD_1      ; repeat until timeout (Carry=1 while HL<DE)
 130+ FD41 37                       scf                     ; exit with Carry = 1 (device NOT ready)
 131+ FD42 C1           CR_DV_RD_E: pop     BC              ; retrieve HL
 132+ FD43 C9                       ret                     ; return to caller
 133+ FD44
 134+ FD44
 135+ FD44              ; put the CF into stand-by mode
 136+ FD44 3E E0        CF_STANDBY: ld 	    A,$E0   		; select CF as master, driver 0, LBA mode (bits #5-7=111)
 137+ FD46 D3 56                    out 	(CF_LBA3),A     ; send configuration
 138+ FD48 3E 92                    ld      A,$92           ; standby mode
 139+ FD4A D3 57                    out     (CF_CMD),A      ; send command
 140+ FD4C CD EB FC                 call    CF_BUSY         ; wait for CF being ready
 141+ FD4F C9                       ret                     ; return to caller
 142+ FD50
 143+ FD50
 144+ FD50              ;***************************************************************************
 145+ FD50              ; CF_RD_SEC
 146+ FD50              ; Function: load a sector (512 bytes) into RAM buffer.
 147+ FD50              ;***************************************************************************
 148+ FD50 CD F2 FC     CF_RD_SEC:  call    CF_CMDRDY       ; Make sure drive is ready for command
 149+ FD53 D8                       ret     C               ; return if error
 150+ FD54 3E 20                    ld      A,$20           ; Prepare read command
 151+ FD56 D3 57                    out     (CF_CMD),A      ; Send read command
 152+ FD58 CD 01 FD                 call    CF_DAT_RDY      ; Wait until data is ready to be read
 153+ FD5B D8                       ret     C               ; return if error
 154+ FD5C DB 57                    in      A,(CF_STAT)     ; Read status
 155+ FD5E E6 01                    and     %00000001       ; mask off error bit
 156+ FD60 C2 50 FD                 jp      NZ,CF_RD_SEC    ; Try again if error
 157+ FD63              ; read CF buffer after it's been filled up by a previous command
 158+ FD63              ; and store data into the I/O buffer
 159+ FD63 C5           CF_RD_CMD:  push    BC              ; store BC
 160+ FD64 E5                       push    HL              ; store HL
 161+ FD65 CD 01 FD                 call    CF_DAT_RDY	    ; wait for data from CF to be ready
 162+ FD68 38 0A                    jr      C,CF_RD_EXIT    ; if error, leave
 163+ FD6A 01 50 00                 ld      BC,CF_DATA      ; set 256 bytes per loop (B=$00) and CF port (C=CF_DATA)
 164+ FD6D 21 C0 FD                 ld      HL,IOBUFF       ; get starting address of I/O buffer
 165+ FD70 ED B2                    inir                    ; get 256 bytes
 166+ FD72 ED B2                    inir                    ; get 256 bytes
 167+ FD74 E1           CF_RD_EXIT: pop     HL              ; retrieve HL
 168+ FD75 C1                       pop     BC              ; retrieve BC
 169+ FD76 C9                       ret                     ; return to caller
 170+ FD77
 171+ FD77
 172+ FD77              ;***************************************************************************
 173+ FD77              ; CF_WR_SEC
 174+ FD77              ; Function: write a sector to Compact Flash - sector address is into BCDE - source address is into HL
 175+ FD77              ;***************************************************************************
 176+ FD77 C5           CF_WR_SEC:  push    BC              ; store BC
 177+ FD78 E5                       push    HL              ; store HL
 178+ FD79 CD 0E FD                 call    CF_SETSTR       ; set sector
 179+ FD7C CD F2 FC                 call    CF_CMDRDY       ; Make sure drive is ready for command
 180+ FD7F 38 17                    jr      C,CF_WR_EXIT    ; return if error
 181+ FD81 3E 30                    ld      A,$30           ; set write command
 182+ FD83 D3 57                    out     (CF_CMD),A      ; send command
 183+ FD85 CD 01 FD                 call    CF_DAT_RDY      ; Make sure drive is ready to get data
 184+ FD88 38 0E                    jr      C,CF_WR_EXIT    ; return if error
 185+ FD8A 21 C0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
 186+ FD8D 01 50 00                 ld      BC,CF_DATA      ; set 256 bytes per loop (B=$00) and CF port (C=CF_DATA)
 187+ FD90 ED B3                    otir                    ; output 256 bytes
 188+ FD92 ED B3                    otir                    ; output 256 bytes
 189+ FD94 CD EB FC                 call    CF_BUSY         ; wait for CF to complete the writing
 190+ FD97 AF                       xor     A               ; clear Carry
 191+ FD98 E1           CF_WR_EXIT: pop     HL              ; retrieve HL
 192+ FD99 C1                       pop     BC              ; retrieve BC
 193+ FD9A C9                       ret                     ; return to caller
 194+ FD9B
 195+ FD9B              BIOSEND:    equ     $               ; end of BIOS
# file closed: ../include/dos/bios-1.03.asm
  96  FD9B                  INCLUDE "../include/dos/buffers-1.01.asm"
# file opened: ../include/dos/buffers-1.01.asm
   1+ FD9B              ; ------------------------------------------------------------------------------
   2+ FD9B              ; LM80C 64K - BUFFERS - R1.00
   3+ FD9B              ; ------------------------------------------------------------------------------
   4+ FD9B              ; The following code is intended to be used with LM80C Z80-based computer
   5+ FD9B              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ FD9B              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ FD9B              ; kind of warranty: you can use them at your own risk.
   8+ FD9B              ; You are free to use them for any non-commercial use: you are only asked to
   9+ FD9B              ; maintain the copyright notices, include this advice and the note to the
  10+ FD9B              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ FD9B              ; redistribuite them.
  12+ FD9B              ; https://www.leonardomiliani.com
  13+ FD9B              ;
  14+ FD9B              ; Please support me by visiting the following links:
  15+ FD9B              ; Main project page: https://www.leonardomiliani.com
  16+ FD9B              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ FD9B              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ FD9B              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ FD9B              ; ------------------------------------------------------------------------------
  20+ FD9B              ;
  21+ FD9B              ; ------------------------------------------------------------------------------
  22+ FD9B              ; Code Revision:
  23+ FD9B              ; R1.00 - 20210319 - first release
  24+ FD9B              ; R1.01 - 20210327 - added support for sequential files
  25+ FD9B              ;
  26+ FD9B              ;------------------------------------------------------------------------------
  27+ FD9B
  28+ FD9B
  29+ FD9B                          DEFINE  DOSJPTBLS   $FDA0       ; beginning of DOS jump table & buffers
  30+ FD9B FF FF FF...              BLOCK     $FDA0-BIOSEND,$FF   ; filler
  31+ FDA0
  32+ FDA0              ;DOS jump table & buffers
  33+ FDA0                          org       $FDA0
  34+ FDA0              SRTBFS:     equ     $
  35+ FDA0
  36+ FDA0                          ; buffers
  37+ FDA0 FF FF FF...  DOSBFR:     BLOCK   $20,$FF         ; 32 bytes buffer
  38+ FDC0 FF FF FF...  IOBUFF:     BLOCK   $200,$FF        ; 512 bytes buffer
  39+ FFC0
  40+ FFC0 FF FF FF...              BLOCK   $06,$FF
  41+ FFC6                          ; pointers for sequential file
  42+ FFC6              TMPNAM:     equ     $
  43+ FFC6 00 00 00...              BLOCK   $10,$00         ; 16 butes wide
  44+ FFD6 00           SEQFL:      defb    $00             ; (1) 0=no seq. file open / >1=seq. file number
  45+ FFD7 00           SEQFLS:     defb    $00             ; (1) seq. file mode: 0 read / 1 write
  46+ FFD8 00 00        SEQSCTM:    defb    $00,$00         ; (2) MSW of sector address
  47+ FFDA 00 00        SEQSCTL:    defb    $00,$00         ; (2) LSW of sector address
  48+ FFDC 00           SEQSCSZ:    defb    $00             ; (1) size in sectors
  49+ FFDD 00 00        SEQBYSZ:    defb    $00,$00         ; (2) size in bytes
  50+ FFDF 00 00        SEQPNT:     defb    $00,$00         ; (2) pointer to byte
  51+ FFE1
  52+ FFE1 FF                       defb    $FF
  53+ FFE2                          ; DOS jump table
  54+ FFE2              DOSJPTB     equ     $               ; address of 1st entry
  55+ FFE2 C3 53 F5     JPEOF:      jp      EOF             ; jump to EOF statement
  56+ FFE5 C3 81 F5     JPPUT:      jp      PUT             ; jump to PUT statement
  57+ FFE8 C3 9A F5     JPGET:      jp      GET             ; jump to GET statement
  58+ FFEB C3 A5 EE     JPCLOSE:    jp      CLOSE           ; jump to CLOSE statement
  59+ FFEE C3 79 EE     JPOPEN:     jp      OPEN            ; jump to OPEN statement
  60+ FFF1 C3 AD F0     JPDISK:     jp      DISK            ; jump to DISK statement
  61+ FFF4 C3 50 F0     JPERAS:     jp      ERASE           ; jump to ERASE statement
  62+ FFF7 C3 B4 EE     JPLOAD:     jp      LOAD            ; jump to LOAD statement
  63+ FFFA C3 51 EF     JPSAVE:     jp      SAVE            ; jump to SAVE statement
  64+ FFFD C3 1C F0     JPFILS:     jp      FILES           ; jump to FILES statement
  65+ 0000
# file closed: ../include/dos/buffers-1.01.asm
  97  0000
  98  0000              ; END OF ASSEMBLY SOURCE
  99  0000              ;-------------------------------------------------------------------------------
 100  0000
# file closed: LM80C_64K-firmware-r1.17.asm

Value    Label
------ - -----------------------------------------------------------
0xFDA0 X SRTBFS
0xFD9B   BIOSEND
0xFD98   CF_WR_EXIT
0xFD74   CF_RD_EXIT
0xFD42   CR_DV_RD_E
0xFCFF   RETERR
0xFCF2   CF_CMDRDY
0xFD30   CR_DEV_RDY
0xFCE2   CF_NOP
0xFCCC X BIOSSTART
0x0057   CF_STAT
0x0055   CF_LBA2
0x0054   CF_LBA1
0x0053   CF_LBA0
0x0052   CF_SECCNT
0x0051   CF_FTR
0x0051 X CF_ERR
0x0050   CF_DATA
0xFCA9   RSTIOBF
0xFCA8   CLRBUFF
0xFC9D   CHK_C_CF
0xFC80   PRNTSIZ
0xFC5C   CHKNMVAL3
0xFC89   CHK_NAM
0xFC4C   CHKNMVAL2
0xFC37   CHKDSKVAL2
0xFC36   CHKDSKVALE
0xFC21   CHKDSKVAL1
0xFC00   CHATOZE
0xFBF5   CH0TO9E
0xFBED   CH0TO9
0xFBC6   RND_ID1
0xFB9C   CKLSTEN1
0xFB68   CHKEOFC
0xFB51   FNDFRENTR3
0xFB41   FNDFRENTR2
0xFB3E   FNDFRENTR1
0xFB46   FNDFRENTR4
0xFB27   DSKUNDTXT
0xFB0D   DSKUNDPR
0xFBF8   CHATOZ
0xFBDA   RND8
0xFB22   DSKUNDFL2
0xFAF1   DSKUNDFL1
0xFAE3   FLEXST
0xFACC   CHKSTNM6
0xFAC2   CHKSTNM3
0xFAD7   CHKSTNM10
0xFAAA   CHKSTNM2
0xFAA7   CHKSTNM1
0xFA93   FIL_ERA2
0xFA88   FIL_ERA1
0xFA96   FIL_ERA3
0xFA60   FIL_ERA6
0xFA67   FIL_ERA5
0xFA17   LDFL5
0xFA1E   LDFLEX
0xF9E0   LDFL3
0xF9C0   LDFL2
0xF9BC   LDFL1
0xF9A0   LDFL4
0xFAA0   FILE_EXIST
0xF961   LK4FILE1
0xFC68   HL2DE
0xF95E   LK4FILE
0xF8CD   SAVFL2
0xF8A5   SAVFL9
0xF852   SAVFL12
0xF859   SAVFLEXT
0xF80E   SAVFL4
0xF7FC   SAVFL10
0xF7EA   SAVFL6
0xF7D7   SAVFL1
0xF7CF   SAVFL3
0xFC70   PRN16ASCII
0xFC6D   PRN32ASCII
0xFB96   CKLSTEN
0xFB8A   GTNXTEN
0xFC76   PRN16ASCIX
0xF6FC   LSTFILES22
0xF6F4   LSTFILES21
0xF6FF   LSTFILESPR
0xF795   FILETP
0xF6EC   LSTFILES20
0xF6D0   LSTFILES3
0xFB82   CKCREN
0xF6C2   LSTFILES2
0xFB77   PT2FSEN
0xF6BF   LSTFILES1
0xFB6F   SETPTEN
0xFBA8   LDENTRIES
0xF751   PNTSTATS
0xF68B   INPR1
0xF662   TLFLSTX
0xF651   ALFLSTXT
0xF646   TLSCTTX
0xF63A   DSKNMTX
0xF62D   LODERR
0xF624   DUPLERR
0xF5F8   GET2
0xF609   GET1
0xF59A   GET
0xF581   PUT
0xF57D   RETEOF
0xFB5A   CHKEOF
0xF569   EOF1
0xF553   EOF
0xF551   UPCRNENT1
0xF522   UPCRNENT
0xF516   SVCRNTSE
0xF511   CLOSFIL1
0xFFC6   TMPNAM
0xF475   OPNFRD2
0xF46D   OPNFRD3
0xF4B4   OPNRDDET
0xF4AC   OPNFILPT
0xF4E8   SVSQFLNM
0xF85E   SVENTRY
0xFB32   FNDFRENTR
0xF466   OPNFRD
0xF49B   OPFLRS
0xF941   CHKFLEXT
0xFCC0   CLRSEQBF
0xF61B   FILALROP
0xF490   OPNFRD1
0xF3E3   PUTFIL2
0xF610   GETER
0xFFDC   SEQSCSZ
0xFFD8   SEQSCTM
0xFFDA   SEQSCTL
0xF3AE   PUTNXSC
0xFFDF   SEQPNT
0xF621   DSKFULL
0xFFDD   SEQBYSZ
0xF632   RET_ERR
0xF62A   FLNTFND
0xF372   PUTFIL
0xFA9B   WRT_ERR
0xFBB7   LDMSCT
0xF630   DOSVERSERR
0xFC03   CHKDSKVAL
0xF343   DOS_FT8
0xF330   DOS_FT9
0xF33D   DOS_FT10
0xF316   DOS_FTA
0xF341   DOS_FT7
0xF61E   D2ERR
0xFBC3   RND_ID
0xF627   NAMERR
0xFC3B   CHKNMVAL
0xF2A6   DOS_FT2
0xFC63   DE2HL
0xF28C   DOS_FT1
0xF27E   DOS_FTC
0xFDA0   DOSBFR
0xFD63   CF_RD_CMD
0xFD01   CF_DAT_RDY
0x0057   CF_CMD
0x0056   CF_LBA3
0xFCB4   CLRDOSBF
0xF618   FILOPCLER
0xFB6A   CHKSQFL
0xF1E8   CNFRQN
0xF349   DSK_RNM
0xF1B7   RNDKTX
0xF16E   OPRCMP
0xF136   MSPTOK
0xF211   DSK_INIT
0xF156   FRMTXT
0xF107   CFINIT
0xF13E   MSTTXT
0x5580   DKLNPT
0x557E   DKNMPT
0xF183   DSKUND
0xF193   DSKRNM
0xF0EF   RWMSSC
0xF0F4   DSKFRM
0xF0AD   DISK
0x5513   TPHL
0xF0A4   ABRTXT
0xF088   ERASED
0xFA23   FIL_ERASE
0xF096   ABRTDS
0xF1C5   CNFREQ
0xF07A   ERSTX
0xF050   ERASE
0xF66C   LST_FILES
0xFC9F   CLRIOBF
0xF01C   FILES
0xEFF6   TXTRNM
0xF007   SVERR
0xFD77   CF_WR_SEC
0xEFD2   SVEND
0xF7A9   SAVFILE
0xF00C   TXTSVG
0xEFD9   RENFIL
0xEFAB   SAVE1
0xEFC0   SAVESCT
0xEF51   SAVE
0xFCCC   CF_INIT
0xEEF1   LDERR
0xFD50   CF_RD_SEC
0xF72B   LSTFILES6
0xFD0E   CF_SETSTR
0xEF19   GET4AR
0xEEEA   LDEND
0xF973   LODFILE
0xEEF6   TXTLDG
0xF037   CHK1AR
0xF1F4   CHKFN1
0xEED5   LOADST
0xEF07   LDSVPT
0xEEB4   LOAD
0xF4F4   CLOSFIL
0xEEA5   CLOSE
0xF030   DOS_ERR
0xF3EA   OPNFIL
0xF1EA   CHKFLNM
0xEE79   OPEN
0x552E   ENDMEM
0x552C   SRTMEM
0x552A   TPBF4
0x5526   TPBF2
0x5524   TPBF1
0x5522   RAM_PTR
0x5520   LSW_SCT
0x551E   MSW_SCT
0x551D   SCT_SIZ
0x551B   BYT_SIZ
0x5519   NTR_NBR
0x5517   DIR_SCT
0xFD35   CR_DV_RD_1
0x5515   DAT_STRT
0x5513   DIR_STRT
0xEE77   DSKDIRADR
0xEE68   DSKHDR
0x55B4   CHCSNDDTN
0x55B2   CHBSNDDTN
0x5513   TMPDBF
0x5512   DOSER
0x5422   NMIFLG
0x5356   CNTCP2RAM
0x537A   END_OF_FW
0x532E   RAMRUN
0x8000   TMP_FW_LOC
0x425F   CLCN323
0x4236   CLCN325
0x4214   CLCN322
0x4211   CLCN321
0x4201   CLCN32
0x41FD   CLCN32Z
0x41D5   CLCN32T
0x41D0   DIV_32_16SB
0x41CD   DIV_32_16OF
0x41BC   DIV_32_16LP
0x41B7   DIV_32_16
0x41A7   DV16_16_LP
0x41A2   DIV_16_16
0x4196   DIV_16_8LP
0x4187   DIV_8_8LOOP
0x4175   MU32_2
0x416A   MUL_32L
0x415D   MUL_U32
0x415B   EXMUL16
0x4152   MLP1
0x414B   MLP
0xFD44   CF_STANDBY
0x4127   RESETE
0x40E6   BINIT
0x40F9   CHKBIN
0x40C8   BITOUT2
0x40C4   BITOUT
0x40B6   ZEROSUP
0x4098   NOSUB7
0x409C   HEXIT
0x4078   HEXLP
0x407D   HEXLP1
0x40A5   HXERR
0x4085   GETHEX
0x4068   ADD301
0x4058   ADD30
0x4042   HEX4
0x4040   HEX3
0x4031   HEX1
0x4033   HEX2
0x3FE1   PRTEND
0x3FD5   PRTK1
0x3FD2   OPNQT1
0x3FBA   CLSQT1
0x4016   CHKEY5
0x3FA2   PTCHR1
0x4013   CHKEY4
0x3FAA   CLSQT
0x3F6D   PRTK3
0x3F85   PRTCHR
0x3FBC   OPNQT
0x3F70   CNTLTK
0x3F5B   LDKEY
0x400A   CHKEY2
0x3FD4   PRTCKEY
0x4005   CHKEY1
0x3F42   PRTK4
0x3F2E   CPKYEND
0x3F26   CPKEY1
0x3F1E   CPKEY3
0x3F17   CPKEY2
0x3F07   CPKEY
0x3EF9   DECLN1
0x3FE3   SETREP
0x3EC9   KEYCH
0x3F30   LSTKEYS
0x3EA7   HLPERR
0x3E85   DIRMOD
0x3E4C   EXNRM
0x3E3E   ENCHB
0x3E13   SRLCNT
0x3DFB   STRPAR
0x3DDE   SETPAR2
0x3DCF   BITS8
0x3DC4   BITS7
0x3DD3   SETPAR
0x3DBA   BITS6
0x3D97   SET_CTC
0x3E69   CTC_CFG
0x3E74   SCERR1
0x3D86   SET_PT
0x3D6D   CKBPS
0x3E53   SUP_BPS
0x3D61   SETSER
0x3D54   DEFSER
0x3D09   CNTSER3
0x3CEC   CNTRX2
0x3CF7   CNTSER2
0x3CB9   SERLED
0x3CB3   SRPT2
0x3C90   RPTRSSR
0x3C83   RSTSERS
0x3CBD   CNTSER
0x3C7F   CHKZSER
0x3C70   SERVAR
0x3E78   SCERR
0x558A   SIOBFR
0x5589   STPBT
0x5588   PARBT
0x5587   DATABT
0x5585   BPS
0x5584   PRTNUM
0x3C2A   RPTCVBF
0x3C1B   RPCLTMB
0x3C0E   CNTVALY
0x3BDE   CNTCL7
0x3BBA   CNTCL6
0x3B96   CNTCL5
0x3B74   CNTCL4
0x3B4E   CNTCL3
0x3B2A   CNTCL2
0x3C08   VALIDY
0x3B06   CNTCL1
0x3C03   VALIDX
0x3AD7   PLTCRL
0x3AC8   DLSZ
0x3AE0   ENDCRL
0x3A9B   RPTCL1
0x3A88   RPTCRL
0x3AE4   DRWCRL
0x558E   DC
0x558C   YI
0x558A   XI
0x5528   TPBF3
0x5588   RADIUS
0x5586   YC
0x5584   XC
0x3A17   DXGR
0x3A40   ENDDRAW
0x39E7   CNTDRW
0x39CB   RPTDRW
0x39C8   STRE2
0x39BB   ER2
0x417C   negHL
0x3998   Y1GR
0x396E   X1GR
0x4179   absHL
0x3C22   CLRVDBF
0x3C13   CLRTMBF
0x5590   DX
0x558E   SY
0x558C   SX
0x558A   E2
0x5588   ER
0x5586   Y2
0x5584   X2
0x557E   Y1
0x557C   X1
0x4183   DIV_8_8
0x38D9   PXLSET
0x38B5   CNTPLT1
0x38D5   NOGD
0x38E1   XY2HL
0x3850   PNTEND
0x385A   CTPOINT
0x3807   PAINT5
0x37D6   PAINT3
0x3817   CHECKPY
0x37C3   PAINT2
0x3894   CNTPLOT
0x3793   MNPAINT
0x3790   PAINT1
0x378F   PAINT11
0x3816   CHECKPA
0x3781   PAINT0
0x380E   EXITPAI
0x3774   NXTLOOP
0x3812   EXITPA2
0x386E   PNTRTN
0x3C31   CLRPRM
0x5586   ORGSP
0x5584   PNT
0x3706   GPCPCH1
0x36E2   GPNTCO1
0x36CD   RPGPNT
0x36B8   GPNT
0x36A3   CNTGPT2
0x3723   CKCOL
0x558A   TMPHL
0x5588   NUMCHR
0x5586   CHRPNT
0x5584   TMPADR
0x557C   MIXCOL
0x557E   TMPCLR
0x5582   GY
0x5580   GX
0x3C4A   GMERR
0x363D   CHKG2M
0x3637   CHKCLR0
0x3602   RPTLDCL
0x35F9   LOADCLR
0x360D   SETBRCL
0x3626   MIXCLRS
0x35F2   CLREX2
0x35E9   CLRG2
0x35E0   CLRG1
0x35D6   CLRTXT
0x35D9   CLRMC
0x3633   CHKCLR1
0x352E   CKMAGN
0x357B   CHKSCAR
0x353C   SCVDP
0x34FF   RPTPS
0x348C   ATNTAB
0x3482   ATN1
0x343B   SINTAB
0x341F   SIN1
0x3437   QUARTR
0x3433   HALFPI
0x33CC   RND2
0x33B0   RND1
0x33DD   RNDTAB
0x5415   LSTRND
0x33D5   RESEED
0x53F2   SEED
0x335C   SUMLP
0x3353   SMSER1
0x3323   EXPTAB
0x32CB   POWER2
0x32AE   POWER1
0x3290   NEGAFT
0x325B   EXPTEN
0xFDC0   IOBUFF
0x3259   OUTEXP
0x3268   NOENED
0x323D   SUPTLZ
0x3249   DOEBIT
0x3218   TRYAGN
0x3209   DIGTXT
0x327E   POWERS
0x31F8   MAKNUM
0x31D3   GTSIXD
0x31DC   INRNG
0x31BE   SIXDIG
0x326B   RNGTST
0x3265   JSTZER
0x31AF   SPCFST
0x55D5   PBUFF
0x3159   MULTEN
0x314E   ENDCON
0x3158   SCALPL
0x3142   SCALMI
0x3182   EDIGIT
0x312D   EXPLP
0x313F   CONEXP
0x313B   DPOINT
0x3160   ADDIG
0x3117   MANLP
0x310F   CNVNUM
0x30F0   MLDBLP
0x30C8   DCBCDE
0x3091   CMPFP
0x3059   DETHLB
0x3052   INCHL
0x3005   RETREL
0x2FE5   MLSP10
0x2FD8   OVTST1
0x2FDD   OVTST2
0x2FDE   OVTST3
0x2F8A   RESDIV
0x53E4   DIVSUP
0x2F77   DIVLP
0x53F0   DIV4
0x53E5   DIV1
0x53E9   DIV2
0x53ED   DIV3
0x2F44   DIV10
0x2EDC   NOMADD
0x2ECB   MUL8LP
0x2EEE   BYTSFT
0x2EC2   MULT8
0x55E2   MULVAL
0x2FBA   ADDEXP
0x2EA0   FPMULT
0x2E97   MULLN2
0x3177   RSCALE
0x3344   SUMSER
0x2F52   DVBCDE
0x2E52   LOGTAB
0x2E4E   UNITY
0x2E3C   SHRLP
0x2E39   SHRITE
0x2E2C   SCALLP
0x55D4   SGNRES
0x2DFD   FPROND
0x2DEC   RONDB
0x2DD0   NORMAL
0x2DCC   SAVEXP
0x2DD8   PNORM
0x2DB3   CONPOS
0x2E40   SHRT1
0x2DEB   RONDUP
0x2E0A   PLUCDE
0x2DA5   MINCDE
0x2E2A   SCALE
0x3062   SIGNS
0x2D7F   NOSWAP
0x2D62   SUBCDE
0x2D5C   SUBPHL
0x2D65   FPADD
0x327A   HALF
0x2D53   ROUND
0x2D35   CHKINK
0x2D31   SRTINK
0x2D47   ENDINK
0x2D1D   INKEY2
0x2D0E   CMP_A
0x2CBC   NOS3
0x2CA3   NOS2
0x2C90   NOS1
0x2C60   SNDOVR
0x2CB3   WRTSND
0x2C2B   SND1
0x2BBD   RPVOLCG
0x2BC9   VOLCH
0x2B22   PKEPRMS
0x2B0C   SYSRET
0x2AFE   NOSYSPR
0x2AC0   NMIINT
0x2ACC   NMIVR1
0x2AB6   NMIEINT
0x2AB2   NMI2
0x2ABD   NMIDINT
0x2A90   DISNMI
0x2AA1   NM1
0x53E2   OTPORT
0x2A59   WAITLP
0x2A58   NOXOR
0x53E1   OUTSUB
0x2A62   SETIO
0x5419   INPSUB
0x541A   INPORT
0x2A21   VAL2
0x2A24   VAL3
0xFAE5   DSKUNDFL
0x2A17   VAL1
0x2DCB   RESZER
0x29E2   RSTSTR
0x2A2D   MIDNUM
0x29AE   LVINSTR
0x29B8   CNTZIN
0x2958   RP2INST
0x2981   CNT1INS
0x2931   RPTINST
0x29A3   RZINSTR
0x5592   DY
0x2920   EMPTINS
0x558C   TF
0x558A   TP
0x5588   PT2
0x5584   PT
0x5582   ADRS2
0x5580   LNS2
0x557E   ADRS1
0x557C   LNS1
0x28A7   ALLFOL
0x289F   MID1
0x4107   BINERR
0x289D   RIGHT1
0x2A28   LFRGNM
0x2A78   MAKINT
0x287C X GTFLNM
0x286D   GETLEN
0x2856   POPHL
0x2837   GETSTR
0x282E   TSALP
0x2824   SSTSA
0x283D   GSTRHL
0x2791   GRBARY
0x27C8   SCNEND
0x2771   GNXARY
0x27A2   STRADD
0x2772   ARRLP
0x275C   SMPVAR
0x279F   STPOOL
0x274B   GRBLP
0x273D   GARBLP
0x272E   TESTOS
0x2712   GRBDON
0x2701   PRSLP
0x26F6   PRNUMS
0x26D7   TSTOPL
0x26CB   CRTSTE
0x26BC   QTSTLP
0x26A6   MKTMST
0x26A9   CRTMST
0x2710   TESTR
0x2895   TOPOOL
0x2687   STR1
0x26AF   SVSTAD
0x2670   CHEKFN
0x25E8   PASSA
0x3013   RETINT
0x273A   GARBGE
0x25D3   FRENUM
0x25B2   ENDTMR
0x257E   FNDELP
0x259D   ENDDIM
0x255C   ZERARY
0x30E8   MLDEBC
0x253E   DEFSIZ
0x2536   CRARLP
0x2516   BSERR
0x2579   FINDEL
0x24FD   NXTARY
0x251B   CREARY
0x24E9   FNDARY
0x24C1   SCPTLP
0x249F   ZEROLP
0x24B0   RETNUL
0x24AD   RETADR
0x246E   FNTHR
0x2479   CFEVAL
0x2460   FNDVAR
0x2EEC   POPHRT
0x55CC   FNARG
0x24BB   SBSCPT
0x2446   NSCFOR
0x24E3   ARLDSV
0x2436   NOTSTR
0x241B   ENDNAM
0x2427   CHARTY
0x241A   SVNAM2
0x2403   GTFNAM
0x550D   LCRFLG
0x23F0   DIMRET
0x300E   FLGREL
0x3007   FLGDIF
0x23B7   CMPSTR
0x283E   GSTRDE
0x283A   GSTRCU
0x23CF   CMPRES
0x238D   CMPLG1
0x238B   CMPLOG
0x2374   PXOR1
0x2367 X PAND1
0x236C   POR1
0x25D8   ACPASS
0x303D   FPBCDE
0x234C   CNTLGC
0x2332   SGNEXP
0x2329   GOFUNC
0x2321   FNVAL
0x22E2   FRMEVL
0x22DA   RETNUM
0x3025   INVSGN
0x22C6   EVLPAR
0x22F0   FNOFST
0x261A   DOFN
0x23D9   EVNOT
0x22CE   MINUS
0x40DC   BINTFP
0x406C   HEXTFP
0x22A3   NOTAMP
0x22DF   CONVAR
0x302D   STAKFP
0x2261   STKTHS
0x27ED   CONCAT
0x2379   TSTRED
0x554B   CUROPR
0x2239   FOPRND
0x221D   RLTLP
0x2210   EVAL3
0x5556   NXTOPR
0x220D   EVAL2
0x2278   OPRND
0x2204   EVAL1
0x21FD   OPNPAR
0x21F3   TSTSTR
0x21DF   KILFOR
0x304B   LOADFP
0x2D56   ADDPHL
0x303A   PHLTFP
0x21A7   NEXT1
0x2199   FANDT
0x2170   EXTIG
0x2155   MORDT
0x3103   ASCTFP
0x2149   LTSTND
0x26B9   DTSTR
0x212F   ITMSEP
0x2132   STRENT
0x213E   INPBIN
0x2180   FDTLP
0x2114   ANTVLU
0x20E8   NEDMOR
0x20EC   GTVLUS
0x20E0   NXTITM
0x20BB   NOPMPT
0x2662   IDTEST
0x5553   READFG
0x2090   BADINP
0x207E   REDO
0x206F   SPCLP
0x2068   DOSPC
0x2A72   FNDNUM
0x2048   ZONELP
0x2035   CNTEND
0x26FA   PRS1
0x26B5   CRTST
0x31A1   NUMASC
0x2012   PRNTST
0x2077   NEXITM
0x203A   DOCOM
0x2053   DOTAB
0x1FCB   PRNTLP
0x1FC4   MRPRNT
0x1FAD   IF0
0x1FB6   IF1
0x1FA4   IFGO
0x1F88   ONGOLP
0x1F87   ONGO
0x2A75   GETINT
0x3054   FPTHL
0x3057   DETHL4
0x2691   SAVSTR
0x2858   BAKTMP
0x5545   TMPSTR
0x1F68   MVSTPT
0x1F60   CRESTR
0x55D0   FPREG
0x1F39   LETSTR
0x1F71   LETNUM
0x21F4   CHKTYP
0x2201   EVAL
0x550E   TYPE
0x23FE   GETVAR
0x1F10   NXTSTT
0x1F0D   NXTSTL
0x1F06   NXTDTA
0x1F01   RETLIN
0x1EC3   RUNLIN
0x1E7C   STORED
0x1E32   GTLNLP
0x1E2F   GETLN
0x3077   CMPNUM
0x30A4   FPINT
0x55D3   FPEXP
0x1E0E   DEPINT
0x1E0B X POSINT
0x2C66   NOISUP
0x1E08   FPSINT
0x1E00   CHKLTR
0x5420   CHKSUM
0x1DF3 X ACCSUM
0x1DD4   ERRINT
0x5558   ERRLIN
0x1DC3   NOLIN
0x1DAD   INPBRK
0x5423   BRKFLG
0x1D97   STALL
0x1DA1   BRK
0x55C8   NXTDAT
0x1D84   UPDATA
0x1D83   RESTNL
0x1D46   ONJMP
0x1D45   IFJMP
0x1DB0   ENDPRG
0x1D1E   RUNCNT
0x1D1A   PUTFID
0x2FFC   TSTSGN
0x1D11   SAVSTP
0x3048   BCDEFP
0x21EF   GETNUM
0x21F2   TSTNUM
0x1CD5   FORFND
0x1CB9   FORSLP
0x554D   LOOPST
0x1C9E   CNTWTSP
0x1C92   WTSPC
0x1C8A   LVSRLN
0x1C7F   SRCLN1
0x1C5C   OUTWRD
0x1C6A   NXTLN
0x1C43   LSTLP3
0x1C40   LSTLP2
0x1C34   LST07
0x1C31   LST08
0x1C8C   TSTSPC
0x1D89   TSTBRK
0x37F5   PAINT4
0x1C06   LST02
0x1BC6   LST06
0x1BEF   LST03
0x1BCA   LSTNOT
0x1BAB   LST01H
0x1C0F   LISTLP
0x1C7E   SRCLN
0x1C78   SRCHLIN
0x1BA8   LST01
0x1BD7   LSTALL
0x34B1   GETINP
0x410C   MONOUT
0x1B53   SND2VID
0x1B40   INCLEN
0x550C   CURPOS
0x541C   LWIDTH
0x1B44   DINPOS
0x272C   POPAF
0x1B15   CHKSYN
0x1B06   OUTIT
0x1B09   OUTNBS
0x4132   OUTNCR
0x1AF2   PUTBUF
0x2021   ENDINP
0x1AEC   GMNCR
0x1AF7   PUTCTL
0xFFD7   SEQFLS
0x1AB7   PROCES
0x1B61   CLOTST
0x1A91   KILIN
0x1A86   DELCHR
0x1AA0   MORINP
0x1A8E   OTKLN
0x1A7A   ECHDEL
0x541E   NULFLG
0x1A66   DODEL
0x1A4D   NXTCHR
0x1A47   TSTREM
0x1A44   SETLIT
0x1A26   NOCHNG
0x1A1D   NOSPC
0x1A2E   MATCH
0x1A0C   NXTBYT
0x19FC   GETNXT
0x19FA   SEARCH
0x1A32   RETNAD
0x19E1   FNDWRD
0x1A5D   ENDBUF
0x1A56   CPYLIT
0x1A36   MOVDIR
0x19B7   CRNCLP
0x550F   DATFLG
0x5424   RINPUT
0x1992   DOAGN
0x55CA   FNRGNM
0x5551   FORFLG
0x555A   CONTAD
0x5537   TMSTPT
0x5539   TMSTPL
0x55C4   VAREND
0x5549   STRBOT
0x5554   BRKLIN
0x1963   INTVAR
0x1936   SRCHLP
0x54AF   BASTXT
0x1927   FNDEND
0x191B   PTRLP
0x195F   RUNFST
0x190E   MOVBUF
0x1916   SETPTR
0x18E0   SFTPRG
0x55C2   PROGND
0x18EF   INEWLN
0x1EDD   ULERR
0x18D8   LINFND
0x1933   SRCHLN
0x5552   LSTBIN
0x1D3E   EXCUTE
0x19AE   CRUNCH
0x1A97   GETLIN
0x1884   GETCMD
0x1876   POPNOK
0x318E   LINEIN
0x542B   HLPLN
0x1872   PTLN
0x1855   ERRIN
0x1B20   OUTC
0x2019   STTLIN
0x541F   CTLOFG
0x182F   NRERR
0x182C   IMERR
0x1829   TMERR
0x1826   OVERR
0x1823   UFERR
0x1820   DDERR
0x181D   NFERR
0x181A   DZERR
0x554F   DATLIN
0x1811   DATSNR
0x180F   LDG1ND
0x17FE   LDG1
0x17F1   EXITGM
0x1831   ERROR
0x17EC   OMERR
0x55C6   ARREND
0x17D4   CHKSTK
0x17C9   MOVLP
0x17C6   MOVSTR
0x17DD   ENFMEM
0x17C3   MOVUP
0x17BA   INDFND
0x17A4   LOKFOR
0x17A0   BAKSTK
0x179A   BRKMSG
0x1795   OKMSG
0x1794   ZERBYT
0x1790   INMSG
0x1789   ERRMSG
0x1707 X DEFFNKS
0x1705   AUTORP
0x1A97   TTYLIN
0x1E29   FCERR
0x2345   POR
0x234A   PXOR
0x2342   PAND
0x2DB6   BNORM
0x329E   POWER
0x2EF3   DINT
0x2EFB   MOD
0x2F50   DIV
0x2E9E   MULT
0x2D60   PSUB
0x317D   PADD
0x1692   PRITAB
0x00EF   ZLEFT
0x00E5   ZINSTR
0x00E4   ZPOINT
0x00CE   ZSGN
0x00CD   ZLTH
0x00CC   ZEQUAL
0x00CB   ZGTR
0x00CA   ZOR
0x00C6 X ZDINT
0x00C5 X ZMOD
0x00C4 X ZDIV
0x00C3 X ZTIMES
0x00C2   ZMINUS
0x00C1   ZPLUS
0x00C0   ZSTEP
0x00BF   ZNOT
0x00BE   ZTHEN
0x00BD   ZSPC
0x00BC   ZFN
0x00BB   ZTO
0x00BA   ZTAB
0x00B9   ZNEW
0x00B3   ZPRINT
0x00B2   ZELSE
0x008E   ZREM
0x008C   ZGOSUB
0x0088   ZGOTO
0x0083   ZDATA
0x0081   ZFOR
0x0080   ZEND
0x1953   NEW
0xFFFA   JPSAVE
0xFFF7   JPLOAD
0x1E53   CLEAR
0x1B7C   LIST
0x1DDA   CONT
0x1FC8   PRINT
0x410F   RESET
0x2AE0   SYS
0x34C7   WIDTH
0x3646   GPRINT
0x2A86   NMI
0x3EAC   KEY
0x34B3   CLS
0x3E8E   HELP
0x3C4F   SERIAL
0x3736   PAINT
0x3A44   CIRCLE
0xF8DF   CHNGNAM
0x390B   DRAW
0x3879   PLOT
0x358B   COLOR
0x34F1   PAUSE
0x2B9B   VOLUME
0x2BD4   SOUND
0x2B48   LOCATE
0x2CC8   VREG
0x2B7A   SREG
0x2B3D   VPOKE
0x34DA   DOKE
0x2B38   POKE
0x25ED   DEF
0x2A44   WAIT
0xFFE5   JPPUT
0xFFEB   JPCLOSE
0xFFEE   JPOPEN
0xFFF1   JPDISK
0xFFF4   JPERAS
0xFFFD   JPFILS
0x1F78   ON
0x2A3E   POUT
0x1DA6   STOP
0x1F09   REM
0x1EE2   RETURN
0x1EB3   GOSUB
0x1D6E   RESTOR
0x1F96   IF
0x1E9F   RUN
0x1EC4   GOTO
0x1F1E   LET
0x20DB   READ
0x23F9   DIM
0x20A1   INPUT
0x1F07   DATA
0x21A4   NEXT
0x1CA5   FOR
0x1DA8   PEND
0x161E   WORDTB
0x147B   WORDS
0x29C9   MID
0x29BF   RIGHT
0x2899   LEFT
0x40AA   BIN
0x4019   HEX
0x2889   CHR
0x2878   ASC
0x29F9   VAL
0x2681   STR
0x3CF3   RXEND
0x2869   LEN
0xFFE2   JPEOF
0x1C03   LST05
0xFFE8   JPGET
0x28C9   INSTR
0x3826   POINT
0x2D03   INKEY
0x2CEF   SSTAT
0x2CE4   VSTAT
0x2B15   VPEEK
0x34CF   DEEK
0x2B0E   PEEK
0x3465   ATN
0x3450   TAN
0x3510   SCREEN
0x33EF   SIN
0x33E9   COS
0x32E3   EXP
0x2E5F   LOG
0x3374   RND
0x3295   SQR
0x25E5   POS
0x2A32   INP
0x25B7   FRE
0x5586   PT1
0x53DE   USR
0x3021   ABS_
0x30CF   INT
0x25A1   TMR
0x300B   SGN
0x1433   FNCTAB
0x1877   PRNTOK
0x3EB9   RESFN
0x13A7   BRKRET
0x54B7   STACK
0x13BC   BFREE
0x3196   PRNTHL
0x13B3   BLNSPC
0x140B   DOSMSG
0x1394   SETTP1
0x13CA   SIGNON
0x1954   CLRPTR
0x5427   STRSPC
0x5510   LSTRAM
0x1364 X SETTRAM
0xEE68   DOSSTART
0x1363   SETNOD
0x134D   CPDSTB
0xFFE2   DOSJPTB
0x1360   SETDSR
0x1B0F   CPDEHL
0x1817   SNERR
0x1E2E   ATOH
0x1331   SETTOP
0x130D   MLOOP
0x5649   STLOOK
0x131F   TSTMEM
0x1D5E   GETCHR
0x1996   PROMPT
0x26F7   PRS
0x1428   MEMMSG
0x12F7   MSIZE
0x130A   MNOASK
0x2BE2   CTSNDC
0x55E5   PROGST
0xFC46   CHKNMVAL1
0x54B2   BUFFER
0x202B   PRNTCRLF
0x1979   CLREG
0x1C52   FNDTOK
0x1789   INITBE
0x16B0   INITAB
0x12DC   SYSINIT
0x53D8   WRKSPC
0x25D9   ABPASS
0x200E   PRNTNB
0x1E14   DEINT
0x12D5   CSTART
0x13A4   WARMST
0x12CE   STARTB
0x1061 X ERRORS
0x12BC   DAMSG
0x105F X DAPTR
0x282D   TOSTRA
0x12AA   D9MSG
0x105D X D9PTR
0x129B   D8MSG
0x105B X D8PTR
0x128F   D7MSG
0x1059 X D7PRT
0x127B   D6MSG
0x1057 X D6PTR
0x1271   D5MSG
0x1055 X D5PTR
0x126C   D4MSG
0x1053 X D4PTR
0x1267   D3MSG
0x30FE   NOMLAD
0x1051 X D3PRT
0x1259   D2MSG
0x104F X D2PRT
0x124D   D1MSG
0x104D X D1PRT
0x123D   D0MSG
0x104B X D0PTR
0x122C   NRMSG
0x1049 X NRPRT
0x1216   IMMSG
0x1047 X IMPRT
0x120C   HPMSG
0x1045 X HPPTR
0x11F6   SOMSG
0x11DD   SAMSG
0x1041 X SAPTR
0x11C8   SCMSG
0x103F X SCPTR
0x103D X GMPRT
0x11AC   BNMSG
0x103B X BNPTR
0x11A1   HEMSG
0x1039 X HEPTR
0x1191   MOMSG
0x1037 X MOPTR
0x404F   BYT2ASC
0x117B   UFMSG
0x1035 X UFPTR
0x116C   CNMSG
0x1033 X CNPTR
0x1151   STMSG
0x1031 X STPTR
0x1043 X SOPTR
0x1141   LSMSG
0x102F X LSPTR
0x112D   OSMSG
0x4168   MU32_1
0x102D X OSPTR
0x111E   TMMSG
0x102B X TMPTR
0x110A   IDMSG
0x1029 X IDPTR
0x10F9   DZMSG
0x1027 X DZPTR
0x10E4   DDMSG
0x1025 X DDPTR
0x10D6   BSMSG
0x1023 X BSPTR
0x10C7   ULMSG
0x400D   CHKEY3
0x1021 X ULPTR
0x10B9   OMMSG
0x101F X OMPTR
0x10B0   OVMSG
0x101D X OVPTR
0x109A   FCMSG
0x101B X FCPTR
0x108E   ODMSG
0x1019 X ODPTR
0x1079   RGMSG
0x1017 X RGPTR
0x1072   SNMSG
0x1015 X SNPTR
0x1061   NFMSG
0x1013 X NFPTR
0x1013   ERRTBL
0x004C   DA
0x004A   D9
0x0048   D8
0x0046   D7
0x0044   D6
0x0042   D5
0x0040   D4
0x003E   D3
0x003C   D2
0x003A   D1
0x0038   D0
0x0036   NR
0x0034   IM
0x0032   HP
0x0030   SO
0x002E   SA
0x002C   SC
0x002A   GM
0x0028   BN
0x0026   HE
0x0024   MO
0x0022   UF
0x0020   CN
0x001E   ST
0x206D   ASPCS
0x001C   LS
0x001A   OS
0x0018   TM
0x0016   ID
0x0014   DZ
0x0012   DD
0x0010   BS
0x000E   UL
0x000C   OM
0x000A   OV
0x0008   FC
0x0006   OD
0x0004   RG
0x0002   SN
0x0000   NF
0x007F   DEL
0x001B   ESC
0x0015   CTRLU
0x0013   CTRLS
0x0012   CTRLR
0x0011   CTRLQ
0x000F   CTRLO
0x0007   CTRLG
0x0EEB   CNTFNK
0x0EFE   PRNTFNK
0x0EF1   PUTCHRBUF1
0x0ED7   LDFNKEYCHR
0x542F   FNKEYS
0x5429   LINEAT
0x0EB7   PNT2VD
0x0EAA   PUTCHRBUF
0x0E98   SNDKEYTOBFR
0x0EBF   PRNTFNKEY
0x0E90   CHKFNK
0x0F0B   FNKEYSORD
0x0E8A   CNTKBCK
0x0003   CTRLC
0x542E   AUTOKE
0x2DB9   BNRMLP
0x0E77   SENDKEY
0x0E48   SETNEWAUTO
0x0EBA   LVKBRDCHK2
0x542D   KEYDEL
0x0E58   CHKAUTO
0x55BB   KEYTMR
0x0E6A   NEWKEY
0x0F93   KBMAP_ALT
0x0FD3   KBMAP_CTRL
0x0E0F   CHKALT
0x0E16   LOADMAP
0x0F53   KBMAP_SFT
0x0E06   CHKCTRL
0x0F13   KBMAP
0x0DF2   CHKLN
0x55BA   STATUSKEY
0x55B9   LASTKEYPRSD
0x0DDA   ENDCTRLCK
0x0DD4   TESTCTRL
0x0DF0   FINDKEY
0x0DC7   TESTALT
0x55B7   KBTMP
0x0DDE   NOKEYPRSD
0x0D98   RPTKBDRD
0x0D94   CHECKKBD
0x0D86   CHECKCTRL
0x55BD   CONTROLKEYS
0x0D78   CHECKALT
0x0D38   CNTCHKSND
0x0CFD   CHKSNDCH
0x0CCB   RPTWLCMBP
0x0CE1   NOBPDAT
0x0CC8   SENDSND
0x0CD9   WLCBPDAT
0x0CEE   WRTSNDREG
0x0CE9   SETSNDREG
0x0CAF   SNDREGCFG
0x0C9B   CLRPSGREGS
0x0C97   EMPTSNDBFR
0x0B49 X VDPMODESETEX2
0x0B41 X VDPMODESETMC
0x0B39 X VDPMODESET2
0x26B6   QTSTR
0x0B31 X VDPMODESET1
0x0B1F   SENDCHRPTRNS
0x4A6E   CHRST88
0x0B1D   NXTCHAR
0x426E   CHRST68
0x0AFF   LDREGVLS
0x0B29   VDPMODESET
0x0AE8   RSTVDPRAMREG
0x55B0   CHASNDDTN
0x0AD9   EMPTVRM
0x0A61   RPTNLLSRC2
0x4143   MUL16
0x0A3C   ADDNEWLINE
0x0A09   SNDCHRTOBFR
0x09F0   CNTNULL
0x09E0   RPTNLLSRC
0x0A28   PRNTRETURN
0x5582   TMPBFR4
0x5580   TMPBFR3
0x557E   SRTTXT
0x557E   TMPBFR2
0x09B6   RPTEMPTYROW
0x099B   WRITEBUF
0xFFD6   SEQFL
0x0973   LOADNEXTCOL
0x5584   VIDEOBUFF
0x0961   SCROLLNXTRW
0x55AE   VIDTMP2
0x55AC   VIDTMP1
0x0940   EXITCURSOR_ON
0x092A   EXITCURSORDOWN
0x090A   EXITCURSORRGHT
0x0904   CONTCRSRGT
0x08F1   CHCKYPOS2
0x08D6   EXITCURSORUP
0x08AD   CHKYPOS
0x089A   EXITCURSORLEFT
0x0897   CONTCRSLFT
0x0886   CHCKYPOS
0x089C   MVCRS2LFT
0x0857   MVBKSP
0x086A   LVBKSP
0x0020   SPC
0x081D   NXTINST
0x4138   CMP16
0x080C   CHKHL
0x5580   ENDTXT
0x0A49   ENDOFLN
0x557C   CUR_POS
0x07EA   PUTCRSCHR
0x0949   SCROLLUP
0x07AA   SETCRSRY
0xFCEB   CF_BUSY
0x07AB   SETCSRCOORDS
0x07BD   EXITCHAR2VID
0x0781   NXTCPCK
0x0774   RPTCPCK
0x07CA   PLACEHOLDER
0x000A   LF
0x07EE   INSERTKEY
0x001A   INSRT
0x090D   CURSORDOWN
0x001F   CRSDN
0x08D8   CURSORRIGHT
0x001D   CRSRGT
0x08BF   CURSORUP
0x001E   CRSUP
0x0873   CURSORLEFT
0x001C   CRSLFT
0x0830   BACKSPACE
0x35A8   CNTCKCL
0x0008   BKSP
0x09C2   CRGRETURN
0x000C   CS
0x0019   HOME
0x0743   CHRTBL
0x4193   DIV_16_8
0x0732   HL2XY
0x0A6F   POS_TB_CRS_32
0x0724   CONT_POS_CURS
0x0A9F   POS_TB_CRS_40
0x5577   LSTCSRSTA
0x5576   CRSR_STATE
0x06DC   MOVSHOWCRS
0x06F1   NEWCRSRCOORD
0x0706   RSTCHRCRS
0x070F   LOAD_CRSR_POS
0x06C5   READ_VSTAT
0x06BA   WRITE_VREG
0x06A5   WRITE_VIDEO_LOC
0x0690   READ_VIDEO_LOC
0x06D6   MOVCRS
0x5573   SCR_CUR_NX
0x0000   NLLCR
0x5574   SCR_CUR_NY
0x0686   ATHOME
0x06CC   POS_CURSOR
0x0679   CLEARVIDBUF
0x0666   RPTFLL1
0x0654   SNDCLRSET
0x0651   STARTEMPTY
0x061B   CLRG2PTNTBL
0x0601   RPTEMPTYBUF
0x05FB   LDCOLSTOEMPTY
0x063A   EMPTYMC
0x060A   EMPTYG2
0x05D9   LVCKSPLK
0x05DB   DOCOLDRESET
0x0D43   READKBLN
0x05B4   SNDLOGPT
0x2E16   COMPL
0x526E   LOGOFONT
0x0CC5   NOBEEP
0x0CBF   WLCMBEEP
0x0580   RPT100
0x05C3   CHKSPCK
0x0596   BEEPOFF
0x058A   SETBEEP
0x55C1   DOS_EN
0x0554   DEC_D
0x557C   TMPBFR1
0x053A   RPT104
0x059E   LOADLOGOCHRS
0x0532   RPT103
0x0B51   LM80CLOGO
0x051D   RPT102
0x0CA2   RSTPSG
0x051A   RPT101
0x05BE   CLRTABLE
0x0573   ERASECLRTBL
0x065E   SETNAMETABLE
0x0AF5   SET_GFX_MODE2
0x5575   SCR_ORG_CHR
0x05E2   EMPTYVIDBUF
0x0457   LDCLRTBMD1
0x557A   FRGNDCLR
0x0670   SETVDPADRS
0x04E7   ENDVDPSET
0x556F   SCR_NAM_TB
0x541D   COMMAN
0x556D   SCR_SIZE_H
0x556C   SCR_SIZE_W
0x557B   BKGNDCLR
0x5572   SCR_CURS_Y
0x04DE   LDCLRTBEX2
0x5571   SCR_CURS_X
0x0B09   LOADCHARSET
0x03F6 X TXTMD
0x04A5   EXG2MD
0x0482   MCMD
0x0460   G2MD
0x0420   G1MD
0x556E   SCR_MODE
0x0AE2   CLR_RAM_REG
0x0AED   SET_GFX_MODE
0x0ACF   EMPTY_VRAM
0x0365   RESTMR
0x036A   CTCCONF
0x033C X SIO_B_SETS
0x0336   SIO_A_SETS
0x12CB   WARM
0x12C8   COLD
0x0942   CURSOR_OFF
0x031C   ECHO_CHAR
0x030F   CHECKWARM
0x02F8   CORW
0x092D   CURSOR_ON
0x03B4   MSGTXT2
0x0304   COLDSTART
0x53D7   basicStarted
0x0376   MSGTXT1
0x412B   INITST
0x03D1   initVDP
0x04F2   SHOW_LOGO
0x0C91   initPSG
0x0340   initCTC
0x02B1 X INIT_HW2
0x5509   TEMPSTACK
0x02AE   INIT_HW
0x0D58   KEYBOARD
0x0CF3   MNGSNDS
0x07CB   FLASHCURSOR
0x029A   CHKCRSR
0x0294   INCTMR3
0x555C   TMRCNT
0x028B   CH3_TIMER
0x027D   RAWPRINT
0x026C   TX_EMP
0x0269   TXA_EXIT
0x0255   RXA_EXIT
0x023F   NOTRDWRAP
0x53D4   serRdPtr
0x537A   SERBUF_START
0x0214   NOTWRAP
0x00D2   bufWrap
0x53D2   serInPtr
0x0208   NOTFULL
0x53D6   serBufUsed
0x01EB   SIO_B_EI
0x01F1   SIO_RXEN
0x01E3   SIO_A_EI
0x01D9   SIO_RXDI
0x01B5 X B_RTS_ON
0x01BB   SIO_RTS_ON
0x01AD   A_RTS_ON
0x55C0   SERBBITS
0x019D   SIO_RTS_OFF
0x55BF   SERABITS
0x0181   EMPTYCHBBFR
0x01D3   SIO_B_DI
0x0197   B_RTS_OFF
0x3E7D   SOERR
0x015D   CHABFREMPTY
0x014F   EMPTYCHABFR
0x55BE   SERIALS_EN
0x01CB   SIO_A_DI
0x11B7   GMMSG
0x0761   CHAR2VID
0x5578   PRNTVIDEO
0x55B6   KBDNPT
0x0120   CNTRXCHA
0x000D   CR
0x5579   CHR4VID
0x0131   LVRXCHA
0x01FD   CHARINTOBFR
0x55B8   TMPKEYBFR
0x018F   A_RTS_OFF
0x00EC   FMVEREND
0x00D0 X FWVER
0x53DB   NMIUSR
0x5569   CTC3IV
0x5566   CTC2IV
0x5563   CTC1IV
0x5560   CTC0IV
0x0278   CKINCHAR
0x0018 X RST18
0x022A   RXA
0x0010 X RST10
0x0136   SPEC_RXA_CNDT
0x0100   RX_CHA_AVAIL
0x0259   TXA
0x0008 X RST08
0x0168   SPEC_RXB_CNDT
0x0165   RX_CHB_AVAIL
0x5343   ROM2RAM
0x0000 X RST00
0x0005   SER_EMPTYSIZE
0x0050   SER_FULLSIZE
0x0058   SER_BUFSIZE
0x0041   PSG_DAT
0x0040   PSG_REG
0x0031   VDP_SET
0x0030   VDP_DAT
0x0021   SIO_DB
0x0020   SIO_DA
0x0023   SIO_CB
0x0022   SIO_CA
0x0013   CTC_CH3
0x0012   CTC_CH2
0x0011   CTC_CH1
0x0010   CTC_CH0
0x0003   PIO_CB
0x0002 X PIO_CA
0x0001   PIO_DB
0x0000 X PIO_DA
