# file opened: LM80C-firmware-r3.19.asm
   1  0000              ; ------------------------------------------------------------------------------
   2  0000              ; LM80C - FIRMWARE - R3.19
   3  0000              ; ------------------------------------------------------------------------------
   4  0000              ; The following code is intended to be used with LM80C Z80-based computer
   5  0000              ; designed by Leonardo Miliani. More info at
   6  0000              ; www DOT leonardomiliani DOT com
   7  0000              ; ------------------------------------------------------------------------------
   8  0000              ; Coding/Editing/Compiling:
   9  0000              ; Original init code for MC68B05 by Grant Searle
  10  0000              ; Original SIO/CTC/PIO init code by Mario Blunk
  11  0000              ; NASCOM BASIC originally modified by Gran Searle
  12  0000              ; Code modified and adapted for LM80C by Leonardo Miliani
  13  0000              ;
  14  0000              ; Edited with Visual Studio Code
  15  0000              ;
  16  0000              ; Compiled with SjASMPlus assembler 1.18.0
  17  0000              ; https://github.com/z00m128/sjasmplus
  18  0000              ; ------------------------------------------------------------------------------
  19  0000              ; Copyright notes:
  20  0000              ; Parts of the code (c) Grant Searle - free for non commercial use
  21  0000              ; Please include this advice and the note to the attribution of the original
  22  0000              ; version to Grant Searle if you intend to redistribuite it
  23  0000              ; http://searle.hostei.com/grant/index.html
  24  0000              ; eMail: home.micros01@btinternet.com
  25  0000              ;
  26  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  27  0000              ; Parts of the code (c) Mario Blunk
  28  0000              ; http://www.trainÂ­z.de
  29  0000              ;
  30  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  31  0000              ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  32  0000              ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  33  0000              ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  34  0000              ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  35  0000              ; the original ROM code (checksum A934H). PA
  36  0000              ;
  37  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  38  0000              ; The following code is intended to be used with LM80C Z80-based computer
  39  0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
  40  0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
  41  0000              ; kind of warranty: you can use them at your own risk.
  42  0000              ; You are free to use them for any non-commercial use: you are only asked to
  43  0000              ; maintain the copyright notices, include this advice and the note to the
  44  0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  45  0000              ; redistribuite them.
  46  0000              ; https://www.leonardomiliani.com
  47  0000              ;
  48  0000              ; Please support me by visiting the following links:
  49  0000              ; Main project page: https://www.leonardomiliani.com
  50  0000              ; Schematics and code: https://github.com/leomil72/LM80C
  51  0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  52  0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  53  0000              ; ------------------------------------------------------------------------------
  54  0000              ; output binary file
  55  0000                  OUTPUT "LM80C-firmware-r3.19.bin"
  56  0000
  57  0000              ; set computer model
  58  0000                  DEFINE LM80C
  59  0000
  60  0000              ; set firmware version
  61  0000                  DEFINE VERSION "3.19"
  62  0000
  63  0000              ; define shorter VDP_DAT load instruction and additional delay for VDP access
  64  0000                  DEFINE LD_VDP_DAT ld      C,VDP_DAT
  65  0000                  DEFINE LM64K_NOP
  66  0000
  67  0000              ; ------------------------------------------------------------------------------
  68  0000              ; include the latest version of the bootloader: this sets up the address aliases,
  69  0000              ; configure the hardware, checks if warm or cold startup and loads the BASIC interpreter
  70  0000                  INCLUDE "../include/bootloader/bootloader-1.06.asm"
# file opened: ../include/bootloader/bootloader-1.06.asm
   1+ 0000              ; ------------------------------------------------------------------------------
   2+ 0000              ; LM80C - BOOTLOADER - 1.06
   3+ 0000              ; ------------------------------------------------------------------------------
   4+ 0000              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0000              ; kind of warranty: you can use them at your own risk.
   8+ 0000              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0000              ; maintain the copyright notices, include this advice and the note to the
  10+ 0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0000              ; redistribuite them.
  12+ 0000              ; https://www.leonardomiliani.com
  13+ 0000              ;
  14+ 0000              ; Please support me by visiting the following links:
  15+ 0000              ; Main project page: https://www.leonardomiliani.com
  16+ 0000              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0000              ; ------------------------------------------------------------------------------
  20+ 0000
  21+ 0000              ; ADDRESS DECODING (bits A6/A5/A4)
  22+ 0000              ; 0000xxxx : PIO
  23+ 0000              ; 0001xxxx : CTC
  24+ 0000              ; 0010xxxx : SIO
  25+ 0000              ; 0011xxxx : VDP
  26+ 0000              ; 0100xxxx : PSG
  27+ 0000              ; 0101xxxx : C.F.
  28+ 0000
  29+ 0000
  30+ 0000              ; ------------------------------------------------------------------------------
  31+ 0000              ;               EQUATES
  32+ 0000              ; ------------------------------------------------------------------------------
  33+ 0000              ; label defining for PIO (Parallel Input/Output)
  34+ 0000              PIO_DA          equ %00000000
  35+ 0000              PIO_DB          equ %00000001
  36+ 0000              PIO_CA          equ %00000010
  37+ 0000              PIO_CB          equ %00000011
  38+ 0000
  39+ 0000              ; label defining for CTC (Counter Timer Circuit)
  40+ 0000              CTC_CH0         equ %00010000
  41+ 0000              CTC_CH1         equ %00010001
  42+ 0000              CTC_CH2         equ %00010010
  43+ 0000              CTC_CH3         equ %00010011
  44+ 0000
  45+ 0000              ;label defining for SIO (Serial Input/Output)
  46+ 0000              SIO_CA          equ %00100010
  47+ 0000              SIO_CB          equ %00100011
  48+ 0000              SIO_DA          equ %00100000
  49+ 0000              SIO_DB          equ %00100001
  50+ 0000
  51+ 0000              ;label defining for VDP (Video Display Processor)
  52+ 0000              VDP_DAT         equ %00110000
  53+ 0000                  IFDEF LM80C64K
  54+ 0000 ~            VDP_SET         equ %00110001
  55+ 0000                  ELSE
  56+ 0000              VDP_SET         equ %00110010
  57+ 0000                  ENDIF
  58+ 0000
  59+ 0000              ; label defining for PSG (Programmable Sound Generator)
  60+ 0000              PSG_REG         equ %01000000
  61+ 0000              PSG_DAT         equ %01000001
  62+ 0000
  63+ 0000              ; Interrupt-driven serial I/O interface lead by the Z80 SIO to run modified
  64+ 0000              ; NASCOM Basic 4.7 - Full input buffering with incoming data hardware handshaking
  65+ 0000              ; Handshake shows full before the buffer is totally filled to allow run-on from the sender
  66+ 0000              SER_BUFSIZE     equ     $58
  67+ 0000              SER_FULLSIZE    equ     $50
  68+ 0000              SER_EMPTYSIZE   equ     $05
  69+ 0000
  70+ 0000
  71+ 0000              ;------------------------------------------------------------------------------
  72+ 0000              ;                                F I R M W A R E
  73+ 0000              ;------------------------------------------------------------------------------
  74+ 0000              ; BASE MEMORY - RESET LOCATION ($0000) -> the CPU jumps to $0000 after a reset
  75+ 0000                              org     $0000
  76+ 0000 F3           RST00:          di                      ; be sure that INTs are disabled
  77+ 0001                  IFDEF LM80C64K
  78+ 0001 ~                            jp      ROM2RAM         ; jump to ROM/RAM switcher
  79+ 0001                  ELSE
  80+ 0001 C3 AE 02                     jp      INIT_HW         ; jump to system initialization
  81+ 0004                  ENDIF
  82+ 0004
  83+ 0004              ;------------------------------------------------------------------------------
  84+ 0004              ; interrupt vector when SIO ch.B has a char available in its buffer
  85+ 0004                              ;$0004
  86+ 0004 65 01                        defw    RX_CHB_AVAIL
  87+ 0006
  88+ 0006              ;------------------------------------------------------------------------------
  89+ 0006              ; interrupt vector for SIO ch.B special conditions (i.e. buf overrun)
  90+ 0006                              ;$0006
  91+ 0006 68 01                        defw    SPEC_RXB_CNDT
  92+ 0008
  93+ 0008              ;------------------------------------------------------------------------------
  94+ 0008              ; send a character over serial ch. A
  95+ 0008                              ;$0008
  96+ 0008 C3 59 02     RST08:          jp      TXA
  97+ 000B FF                           BLOCK   1,$FF   ; filler
  98+ 000C
  99+ 000C              ;------------------------------------------------------------------------------
 100+ 000C              ; interrupt vector when SIO ch.A has a char available in its buffer
 101+ 000C                              ;$000C
 102+ 000C 00 01                        defw    RX_CHA_AVAIL
 103+ 000E
 104+ 000E              ;------------------------------------------------------------------------------
 105+ 000E              ; interrupt vector for SIO ch.A special conditions (i.e. buf overrun)
 106+ 000E                              ;$000E
 107+ 000E 36 01                        defw    SPEC_RXA_CNDT
 108+ 0010
 109+ 0010              ;------------------------------------------------------------------------------
 110+ 0010              ; receive a character over serial ch. A
 111+ 0010                              ;$0010
 112+ 0010 C3 2A 02     RST10:          jp      RXA
 113+ 0013 FF FF FF...                  BLOCK   5,$FF   ; filler
 114+ 0018              ;------------------------------------------------------------------------------
 115+ 0018              ; check buffer state
 116+ 0018
 117+ 0018                              ;$0018
 118+ 0018 C3 78 02     RST18:          jp      CKINCHAR
 119+ 001B FF FF FF...                  BLOCK   $25,$FF ; filler
 120+ 0040              ;------------------------------------------------------------------------------
 121+ 0040              ; interrupt vectors for CTC
 122+ 0040                              ;$0040               ; for CH0 Timer - used in BASIC by serial 1 for bps
 123+ 0040 C1 81                        defw    CTC0IV
 124+ 0042                              ;$0042               ; for CH1 Timer - used in BASIC by serial 2 for bps
 125+ 0042 C4 81                        defw    CTC1IV
 126+ 0044                              ;$0044               ; for CH2 timer - unused
 127+ 0044 C7 81                        defw    CTC2IV
 128+ 0046                              ;$0046               ; for CH3 Timer - used by FW for 100ths/s counter
 129+ 0046 CA 81                        defw    CTC3IV
 130+ 0048 FF FF FF...                  BLOCK   $1E,$FF ; filler
 131+ 0066              ;------------------------------------------------------------------------------
 132+ 0066              ; interrupt routine for NMI
 133+ 0066                              ;$0066
 134+ 0066 C3 61 80                     jp      NMIUSR              ; jump to execute NMI service routine
 135+ 0069 FF FF FF...                  BLOCK   $27,$FF ; filler
 136+ 0090              ;------------------------------------------------------------------------------
 137+ 0090
 138+ 0090                              ;$0090
 139+ 0090                  IFDEF LM80C
 140+ 0090 4C 4D 38 30                  defb    $4C,$4D,$38,$30,$43,$20,$43,$4F
 140+ 0094 43 20 43 4F
 141+ 0098 4C 4F 52 00                  defb    $4C,$4F,$52,$00,$00,$00,$00,$00
 141+ 009C 00 00 00 00
 142+ 00A0                  ELSE
 143+ 00A0 ~                            defb    $4C,$4D,$38,$30,$43,$20,$36,$34
 144+ 00A0 ~                            defb    $4B,$20,$43,$4F,$4C,$4F,$52,$00
 145+ 00A0                  ENDIF
 146+ 00A0 43 4F 4D 50                  defb    $43,$4F,$4D,$50,$55,$54,$45,$52
 146+ 00A4 55 54 45 52
 147+ 00A8 20 28 32 30                  defb    $20,$28,$32,$30,$32,$30,$29,$00
 147+ 00AC 32 30 29 00
 148+ 00B0 44 65 73 69                  defb    $44,$65,$73,$69,$67,$6E,$65,$64
 148+ 00B4 67 6E 65 64
 149+ 00B8 20 62 79 00                  defb    $20,$62,$79,$00,$00,$00,$00,$00
 149+ 00BC 00 00 00 00
 150+ 00C0 4C 65 6F 6E                  defb    $4C,$65,$6F,$6E,$61,$72,$64,$6F
 150+ 00C4 61 72 64 6F
 151+ 00C8 20 4D 69 6C                  defb    $20,$4D,$69,$6C,$69,$61,$6E,$69
 151+ 00CC 69 61 6E 69
 152+ 00D0 46 57 20 33  FWVER:          defm    "FW ","3.19",$20,"2021-01-19",$20,"22:47:02",$00
 152+ 00D4 2E 31 39 20
 152+ 00D8 32 30 32 31
 152+ 00DC 2D 30 31 2D
 152+ 00E0 31 39 20 32
 152+ 00E4 32 3A 34 37
 152+ 00E8 3A 30 32 00
 153+ 00EC              FMVEREND:       equ     $
 154+ 00EC FF FF FF...                  BLOCK   $100-FMVEREND,$FF   ; filler
 155+ 0100              ;------------------------------------------------------------------------------
 156+ 0100
 157+ 0100              ;-------------------------------------------------------------------------------
 158+ 0100              ;               Z80 SIO CH. A MANAGEMENT
 159+ 0100              ;-------------------------------------------------------------------------------
 160+ 0100
 161+ 0100              ;-------------------------------------------------------------------------------
 162+ 0100              ; interrupt driven routine to get chars from Z80 SIO ch.A
 163+ 0100              ; this is the only serial channel that can print received chars onto the screen
 164+ 0100                              ;$0100
 165+ 0100 F5           RX_CHA_AVAIL:   push    AF              ; store A
 166+ 0101 E5                           push    HL              ; and HL
 167+ 0102 CD 8F 01                     call    A_RTS_OFF       ; disable RTS line
 168+ 0105 DB 20                        in      A,(SIO_DA)      ; read char from RX buffer into A
 169+ 0107 32 19 82                     ld      (TMPKEYBFR),A   ; store it into the temp key buffer
 170+ 010A CD FD 01                     call    CHARINTOBFR     ; sub-routine to put the char into the input buffer
 171+ 010D D2 31 01                     jp      NC,LVRXCHA      ; if buffer is full, then leave without doing anything else
 172+ 0110 3A 19 82                     ld      A,(TMPKEYBFR)   ; retrieve char
 173+ 0113 32 DA 81                     ld      (CHR4VID),A     ; write into buffer for video printing
 174+ 0116 FE 0D                        cp      CR              ; is it RETURN?
 175+ 0118 CA 20 01                     jp      Z,CNTRXCHA      ; yes, continue
 176+ 011B FE 20                        cp      $20             ; is it another control char (code < 32)?
 177+ 011D DA 31 01                     jp      C,LVRXCHA       ; yes, leave w/o printing it on video nor sending back to serial
 178+ 0120 F5           CNTRXCHA:       push    AF              ; store char
 179+ 0121 AF                           xor     A
 180+ 0122 32 17 82                     ld      (KBDNPT),A      ; a char from serial is like a char printed by BASIC
 181+ 0125 3A D9 81                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 182+ 0128 FE 01                        cp      $01             ; is the print on video on?
 183+ 012A CC 6C 07                     call    Z,CHAR2VID      ; yes, print on screen
 184+ 012D F1                           pop     AF              ; retrieve char
 185+ 012E CD 59 02                     call    TXA             ; send back to serial
 186+ 0131 E1           LVRXCHA:        pop     HL              ; retrieve HL
 187+ 0132 F1                           pop     AF              ; and A
 188+ 0133 FB                           ei                      ; re-enable interrupts
 189+ 0134 ED 4D                        reti                    ; and exit
 190+ 0136
 191+ 0136              ;-------------------------------------------------------------------------------
 192+ 0136              ; special SIO ch.A condition (i.e., buffer overrun)
 193+ 0136              ; if buffer overruns then show an error, empty the RX buffer and send
 194+ 0136              ; a break char
 195+ 0136 F5           SPEC_RXA_CNDT:  push    AF              ; store AF
 196+ 0137 CD 8F 01                     call    A_RTS_OFF       ; disable RTS
 197+ 013A CD CB 01                     call    SIO_A_DI        ; disable RX on ch. A
 198+ 013D 3A 1F 82                     ld      A,(SERIALS_EN)  ; load serial status
 199+ 0140 CB 97                        res     2,A             ; disable RX on port 1
 200+ 0142 32 1F 82                     ld      (SERIALS_EN),A  ; store new serial status
 201+ 0145 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 202+ 0147 CB E7                        set     4,A             ; set 5th pin ON
 203+ 0149 D3 01                        out     (PIO_DB),A      ; send new setting
 204+ 014B 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 205+ 014D D3 22                        out     (SIO_CA),A      ; send command to SIO
 206+ 014F AF           EMPTYCHABFR:    xor     A
 207+ 0150 D3 22                        out     (SIO_CA),A      ; write to WR0, select RR0
 208+ 0152 DB 22                        in      A,(SIO_CA)      ; read RR0 register
 209+ 0154 E6 01                        and     $01             ; check if input buffer if empty
 210+ 0156 CA 5D 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then leave
 211+ 0159 DB 20                        in      A,(SIO_DA)      ; read chars
 212+ 015B 18 F2                        jr      EMPTYCHABFR     ; repeat
 213+ 015D F1           CHABFREMPTY:    pop     AF              ; retrieve AF
 214+ 015E 21 4A 3D                     ld      HL,SOERR        ; return point set to Serial Buffer Overrun routine
 215+ 0161 E3                           ex      (SP),HL         ; store onto stack
 216+ 0162 FB                           ei                      ; re-enable interrupts
 217+ 0163 ED 4D                        reti                    ; return from interrupt and execute code at SOERR
 218+ 0165
 219+ 0165              ;-------------------------------------------------------------------------------
 220+ 0165              ;               Z80 SIO CH. A MANAGEMENT
 221+ 0165              ;-------------------------------------------------------------------------------
 222+ 0165
 223+ 0165              ;-------------------------------------------------------------------------------
 224+ 0165              ; interrupt driven routine to get chars from Z80 SIO ch.B
 225+ 0165 FB           RX_CHB_AVAIL:   ei
 226+ 0166 ED 4D                        reti
 227+ 0168
 228+ 0168              ;-------------------------------------------------------------------------------
 229+ 0168              ; special SIO ch.A condition (i.e., buffer overrun)
 230+ 0168              ; if buffer overruns then show an error, empty the RX buffer and send
 231+ 0168              ; a break char
 232+ 0168 F5           SPEC_RXB_CNDT:  push    AF              ; store A
 233+ 0169 CD 97 01                     call    B_RTS_OFF       ; disable RTS
 234+ 016C CD D3 01                     call    SIO_B_DI        ; disable RX on ch.B
 235+ 016F 3A 1F 82                     ld      A,(SERIALS_EN)  ; load serial status
 236+ 0172 CB 9F                        res     3,A             ; disable RX on port 2
 237+ 0174 32 1F 82                     ld      (SERIALS_EN),A  ; store new serial status
 238+ 0177 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 239+ 0179 CB EF                        set     5,A             ; set 5th pin ON
 240+ 017B D3 01                        out     (PIO_DB),A      ; send new setting
 241+ 017D 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 242+ 017F D3 23                        out     (SIO_CB),A      ; send command to SIO
 243+ 0181 AF           EMPTYCHBBFR:    xor     A
 244+ 0182 D3 23                        out     (SIO_CB),A      ; write to WR0, select RR0
 245+ 0184 DB 23                        in      A,(SIO_CB)      ; read RR0 register
 246+ 0186 E6 01                        and     $01             ; check if input buffer if empty
 247+ 0188 CA 5D 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then jump to run "exit" code
 248+ 018B DB 21                        in      A,(SIO_DB)      ; read chars
 249+ 018D 18 F2                        jr      EMPTYCHBBFR     ; repeat
 250+ 018F
 251+ 018F
 252+ 018F              ;-------------------------------------------------------------------------------
 253+ 018F              ;               Z80 SIO MANAGEMENT
 254+ 018F              ;-------------------------------------------------------------------------------
 255+ 018F              ; disable RTS:
 256+ 018F              ; by resetting RTS bit (set to 0), the RTS line is disabled (HIGH)
 257+ 018F C5           A_RTS_OFF:      push    BC              ; store BC
 258+ 0190 0E 22                        ld      C,SIO_CA        ; select channel A
 259+ 0192 3A 20 82                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 260+ 0195 18 06                        jr      SIO_RTS_OFF
 261+ 0197 C5           B_RTS_OFF:      push    BC              ; store BC
 262+ 0198 0E 23                        ld      C,SIO_CB        ; select channel B
 263+ 019A 3A 21 82                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 264+ 019D CB 3F        SIO_RTS_OFF:    srl     A               ; position data bits in bits #5&6
 265+ 019F E6 60                        and     %01100000       ; get only bits #5&6
 266+ 01A1 47                           ld      B,A             ; store data bits
 267+ 01A2 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 268+ 01A4 ED 79                        out     (C),A
 269+ 01A6 3E 88                        ld      A,%10001000     ; enable DTR (b7) and TX (b4), disable RTS (b1)
 270+ 01A8 B0                           or      B               ; set data bits
 271+ 01A9 ED 79                        out     (C),A           ; send setting
 272+ 01AB C1                           pop     BC              ; retrieve BC
 273+ 01AC C9                           ret                     ; exit
 274+ 01AD
 275+ 01AD              ;-------------------------------------------------------------------------------
 276+ 01AD              ; enable RTS
 277+ 01AD              ; by setting RTS bit (set to 1), the RTS line is enabled (LOW)
 278+ 01AD C5           A_RTS_ON:       push    BC              ; store BC
 279+ 01AE 0E 22                        ld      C,SIO_CA        ; select channel A
 280+ 01B0 3A 20 82                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 281+ 01B3 18 06                        jr      SIO_RTS_ON
 282+ 01B5 C5           B_RTS_ON:       push    BC              ; store BC
 283+ 01B6 0E 23                        ld      C,SIO_CB        ; select channel B
 284+ 01B8 3A 21 82                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 285+ 01BB CB 3F        SIO_RTS_ON:     srl     A               ; position data bits in bits #5&6
 286+ 01BD E6 60                        and     %01100000       ; get only bits #5&6
 287+ 01BF 47                           ld      B,A             ; store data bits
 288+ 01C0 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 289+ 01C2 ED 79                        out     (C),A
 290+ 01C4 3E 8A                        ld      A,%10001010     ; enable DTR (b7), TX (b4), and RTS (b1)
 291+ 01C6 B0                           or      B               ; set data bits
 292+ 01C7 ED 79                        out     (C),A           ; send setting
 293+ 01C9 C1                           pop     BC              ; retrieve BC
 294+ 01CA C9                           ret                     ; return
 295+ 01CB
 296+ 01CB              ;-------------------------------------------------------------------------------
 297+ 01CB              ; disable SIO RX channel
 298+ 01CB C5           SIO_A_DI:       push    BC              ; store BC
 299+ 01CC 0E 22                        ld      C,SIO_CA        ; SIO channel A
 300+ 01CE 3A 20 82                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 301+ 01D1 18 06                        jr      SIO_RXDI        ; jump to disable RX
 302+ 01D3 C5           SIO_B_DI:       push    BC              ; store BC
 303+ 01D4 0E 23                        ld      C,SIO_CB        ; SIO channel B
 304+ 01D6 3A 21 82                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 305+ 01D9 47           SIO_RXDI:       ld      B,A             ; store data bits
 306+ 01DA 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 307+ 01DC ED 79                        out     (C),A
 308+ 01DE 78                           ld      A,B             ; retrieve data bits; RX disabled; auto enable is OFF
 309+ 01DF ED 79                        out     (C),A
 310+ 01E1 C1                           pop     BC              ; retrieve BC
 311+ 01E2 C9                           ret                     ; return
 312+ 01E3
 313+ 01E3              ;-------------------------------------------------------------------------------
 314+ 01E3              ; enable SIO RX channel
 315+ 01E3 C5           SIO_A_EI:       push    BC              ; store BC
 316+ 01E4 0E 22                        ld      C,SIO_CA
 317+ 01E6 3A 20 82                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 318+ 01E9 18 06                        jr      SIO_RXEN
 319+ 01EB C5           SIO_B_EI:       push    BC              ; store BC
 320+ 01EC 0E 23                        ld      C,SIO_CB
 321+ 01EE 3A 21 82                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 322+ 01F1 47           SIO_RXEN:       ld      B,A             ; store data bits
 323+ 01F2 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 324+ 01F4 ED 79                        out     (C),A           ; select register
 325+ 01F6 78                           ld      A,B             ; retrieve data bits
 326+ 01F7 CB C7                        set     0,A             ; set RX enabled; auto enable is OFF
 327+ 01F9 ED 79                        out     (C),A           ; send settings to SIO
 328+ 01FB C1                           pop     BC              ; retrieve BC
 329+ 01FC C9                           ret
 330+ 01FD
 331+ 01FD              ;------------------------------------------------------------------------------
 332+ 01FD              ; put a char into the input buffer, char is into A
 333+ 01FD              ; this sub is called both from the ISR "RX_CHA_AVAIL" and when
 334+ 01FD              ; the RETURN key is pressed on the keyboard
 335+ 01FD F5           CHARINTOBFR:    push    AF              ; store it
 336+ 01FE 3A 5C 80                     ld      A,(serBufUsed)  ; load buffer size
 337+ 0201 FE 58                        cp      SER_BUFSIZE     ; if buffer is not full
 338+ 0203 DA 08 02                     jp      C,NOTFULL       ; then store the char
 339+ 0206 F1                           pop     AF              ; else drop it
 340+ 0207 C9                           ret                     ; and exit
 341+ 0208 2A 58 80     NOTFULL:        ld      HL,(serInPtr)   ; buffer is not full, can store the char
 342+ 020B 23                           inc     HL              ; load pointer to find first free cell
 343+ 020C 7D                           ld      A,L             ; only check low byte because buffer<256
 344+ 020D FE 58                        cp      bufWrap         ; check if the pointer is at the last cell
 345+ 020F 20 03                        jr      NZ,NOTWRAP      ; if not then continue
 346+ 0211 21 00 80                     ld      HL,SERBUF_START ; else load the address of the first cell
 347+ 0214 22 58 80     NOTWRAP:        ld      (serInPtr),HL   ; store the new pointer
 348+ 0217 F1                           pop     AF              ; then retrieve the char...
 349+ 0218 77                           ld      (HL),A          ; ...and store it in the appropriate cell
 350+ 0219 21 5C 80                     ld      HL,serBufUsed   ; size of the input buffer
 351+ 021C 34                           inc     (HL)            ; increment it
 352+ 021D 3E 50                        ld      A,SER_FULLSIZE  ; input buffer capacity
 353+ 021F BE                           cp      (HL)            ; check if input buffer is full
 354+ 0220 D8                           ret     C               ; exit if buffer is not full
 355+ 0221 3A 1F 82                     ld      A,(SERIALS_EN)  ; check if serial 1 is open
 356+ 0224 1F                           rra                     ; bit 0 into Carry: if Carry is 1 then serial 0 is open and...
 357+ 0225 DC 8F 01                     call    C,A_RTS_OFF     ; ...receiving further chars must be stopped
 358+ 0228 37                           scf                     ; set Carry flag, because  we must inform that the char has been added before to disable RTS
 359+ 0229 C9                           ret
 360+ 022A
 361+ 022A
 362+ 022A              ;-------------------------------------------------------------------------------
 363+ 022A              ; retrieve a char from the input buffer
 364+ 022A 3A 5C 80     RXA:            ld      A,(serBufUsed)  ; load the buffer size
 365+ 022D A7                           and     A               ; check if it's 0 (empty)
 366+ 022E CA 2A 02                     jp      Z,RXA           ; if it's empty, wait for a char
 367+ 0231 F3                           di                      ; disable interrupts
 368+ 0232 E5                           push    HL              ; store HL
 369+ 0233 2A 5A 80                     ld      HL,(serRdPtr)   ; load pointer to first available char
 370+ 0236 23                           inc     HL              ; increment it (go to the next char)
 371+ 0237 7D                           ld      A,L             ; check if the end of the buffer has been reached
 372+ 0238 FE 58                        cp      bufWrap         ; (only check low byte because buffer<256)
 373+ 023A 20 03                        jr      NZ,NOTRDWRAP    ; if not, jump straight
 374+ 023C 21 00 80                     ld      HL,SERBUF_START ; else reload the starting address of the buffer
 375+ 023F 22 5A 80     NOTRDWRAP:      ld      (serRdPtr),HL   ; store new pointer to the next char to read
 376+ 0242 3A 5C 80                     ld      A,(serBufUsed)  ; load buffer size
 377+ 0245 3D                           dec     A               ; decrement it
 378+ 0246 32 5C 80                     ld      (serBufUsed),A  ; and store the new size
 379+ 0249 FE 05                        cp      SER_EMPTYSIZE   ; check if input buffer can be considered empty
 380+ 024B 30 08                        jr      NC,RXA_EXIT     ; if not empty yet, then exit
 381+ 024D 3A 1F 82                     ld      A,(SERIALS_EN)  ; load serial state
 382+ 0250 EE 05                        xor     %00000101       ; check if serial 1 is open and RX enabled
 383+ 0252 CC AD 01                     call    Z,A_RTS_ON      ; yes, set RTS on
 384+ 0255 7E           RXA_EXIT:       ld      A,(HL)          ; recover the char and return it into A
 385+ 0256 E1                           pop     HL              ; retrieve HL
 386+ 0257 FB                           ei                      ; re-enable interrupts
 387+ 0258 C9                           ret                     ; return
 388+ 0259
 389+ 0259              ;------------------------------------------------------------------------------
 390+ 0259              ; sends a char over the serial - char is into A
 391+ 0259 F5           TXA:            push    AF              ; store AF
 392+ 025A C5                           push    BC              ; store BC
 393+ 025B 47                           ld      B,A             ; store char
 394+ 025C 3A 1F 82                     ld      A,(SERIALS_EN)  ; load serial status
 395+ 025F EE 05                        xor     %00000101       ; check if serial 1 is open and RX is enabled
 396+ 0261 20 06                        jr      NZ,TXA_EXIT     ; no, jump over
 397+ 0263 78                           ld      A,B             ; retrieve char
 398+ 0264 D3 20                        out     (SIO_DA),A      ; send char to the SIO
 399+ 0266 CD 6C 02                     call    TX_EMP          ; wait for outgoing char to be sent
 400+ 0269 C1           TXA_EXIT:       pop     BC              ; retrieve BC
 401+ 026A F1                           pop     AF              ; retrieve AF
 402+ 026B C9                           ret                     ; return
 403+ 026C
 404+ 026C              ;------------------------------------------------------------------------------
 405+ 026C              ; wait until outgoing serial has been sent
 406+ 026C 97           TX_EMP:         sub     A               ; set A to 0
 407+ 026D 3C                           inc     A               ; set A to 1
 408+ 026E D3 22                        out     (SIO_CA),A      ; write to WR0, select RR1
 409+ 0270 DB 22                        in      A,(SIO_CA)      ; read RR1 register
 410+ 0272 CB 47                        bit     0,A             ; check if all chars have been sent
 411+ 0274 CA 6C 02                     jp      Z,TX_EMP        ; if not (bit 0 = 0) then retrieve
 412+ 0277 C9                           ret                     ; else exit
 413+ 0278
 414+ 0278
 415+ 0278              ;------------------------------------------------------------------------------
 416+ 0278              ; check if there is some chars into the buffer
 417+ 0278 3A 5C 80     CKINCHAR:       ld      A,(serBufUsed)  ; load buffer size
 418+ 027B A7                           and     A               ; compare to 0
 419+ 027C C9                           ret                     ; return
 420+ 027D
 421+ 027D              ;------------------------------------------------------------------------------
 422+ 027D              ; print a text from memory, and terminate when $00 is found
 423+ 027D 7E           RAWPRINT:       ld      A,(HL)          ; load character from memory cell pointed by HL
 424+ 027E B7                           or      A               ; is it $00 (end string)?
 425+ 027F C8                           ret     Z               ; Yes, then return
 426+ 0280 32 DA 81                     ld      (CHR4VID),A     ; store char
 427+ 0283 F3                           di
 428+ 0284 CD 6C 07                     call    CHAR2VID        ; and send it to screen
 429+ 0287 FB                           ei
 430+ 0288 23                           inc     HL              ; and select the next one
 431+ 0289 18 F2                        jr      RAWPRINT        ; repeat
 432+ 028B
 433+ 028B              ;-------------------------------------------------
 434+ 028B              ; Interrupt service routine (ISR) for CH3 timer
 435+ 028B              ; this is used to increment the 100ths of a second counter and for cursor flashing
 436+ 028B F5           CH3_TIMER:      push    AF              ; save regs. A,
 437+ 028C C5                           push    BC              ; BC,
 438+ 028D D5                           push    DE              ; DE,
 439+ 028E E5                           push    HL              ; HL
 440+ 028F 21 BD 81                     ld      HL,TMRCNT       ; load starting address of the timer
 441+ 0292 06 04                        ld      B,$04           ; 4 bytes to check
 442+ 0294 34           INCTMR3:        inc     (HL)            ; increment timer
 443+ 0295 20 03                        jr      NZ,CHKCRSR      ; if not zero then exit (finished increment)
 444+ 0297 23                           inc     HL              ; if yes, there was an overflow, so increment next byte
 445+ 0298 10 FA                        djnz    INCTMR3         ; repeat for 4 bytes
 446+ 029A CD D6 07     CHKCRSR:        call    FLASHCURSOR     ; call the flashing cursor routine
 447+ 029D CD 01 0D                     call    MNGSNDS         ; call the tone managemenet
 448+ 02A0 3A BD 81                     ld      A,(TMRCNT)      ; check for keyboard management
 449+ 02A3 1F                           rra                     ; bit 0 = 1 ?
 450+ 02A4 D4 66 0D                     call    NC,KEYBOARD     ; no, so read the keyboard inputs
 451+ 02A7 E1                           pop     HL              ; retrieve HL,
 452+ 02A8 D1                           pop     DE              ; DE,
 453+ 02A9 C1                           pop     BC              ; BC,
 454+ 02AA F1                           pop     AF              ; and A
 455+ 02AB FB                           ei                      ; re-enable interrupts
 456+ 02AC ED 4D                        reti                    ; exit from ISR
 457+ 02AE
 458+ 02AE              ;------------------------------------------------------------------------------
 459+ 02AE              ;               HARDWARE INITIALISATION
 460+ 02AE              ;------------------------------------------------------------------------------
 461+ 02AE              ; first run - setup HW & SW
 462+ 02AE              ; (on LN80C 64K runs from RAM)
 463+ 02AE 21 8F 81     INIT_HW:        ld      HL,TEMPSTACK    ; load temp stack pointer
 464+ 02B1 F9           INIT_HW2:       ld      SP,HL           ; set stack to temp stack pointer
 465+ 02B2 21 00 80                     ld      HL,SERBUF_START ; set beginning of input buffer
 466+ 02B5 22 58 80                     ld      (serInPtr),HL   ; for incoming chars to store into buffer
 467+ 02B8 22 5A 80                     ld      (serRdPtr),HL   ; and for chars to be read from buffer
 468+ 02BB AF                           xor     A               ; reset A
 469+ 02BC 32 5C 80                     ld      (serBufUsed),A  ; actual buffer size is 0
 470+ 02BF 32 1F 82                     ld      (SERIALS_EN),A  ; set serial ports status to OFF
 471+ 02C2                  IFDEF LM80C
 472+ 02C2 CD 39 03                     call    HELLOWRLD       ; little serial blink with LEDs
 473+ 02C5                  ENDIF
 474+ 02C5 CD 5E 03                     call    initCTC         ; configure CTC, then...
 475+ 02C8 CD 9F 0C                     call    initPSG         ; ...configure PSG
 476+ 02CB CD 10 05                     call    SHOW_LOGO       ; show computer logo
 477+ 02CE 1E 01                        ld      E,$01           ; E chooses the video mode (graphics 1)
 478+ 02D0 CD ED 03                     call    initVDP         ; set video display
 479+ 02D3 AF                           xor     A
 480+ 02D4 ED 47                        ld      I,A             ; set high byte of interrupt vectors to point to page 0
 481+ 02D6 ED 5E                        im      2               ; interrupt mode 2
 482+ 02D8 FB                           ei                      ; enable interrupts
 483+ 02D9                              ; print system messages
 484+ 02D9 AF                           xor     A               ; A=0 so...
 485+ 02DA 32 17 82                     ld      (KBDNPT),A      ; ...inputs don't come from keyboard
 486+ 02DD 3C                           inc     A               ; A=1...
 487+ 02DE 32 D9 81                     ld      (PRNTVIDEO),A   ; ...to activate the print-on-video
 488+ 02E1 21 94 03                     ld      HL,MSGTXT1      ; sign-on message
 489+ 02E4 CD 7D 02                     call    RAWPRINT        ; print message
 490+ 02E7 3A 5D 80                     ld      A,(basicStarted); check if BASIC is already started
 491+ 02EA FE 59                        cp      'Y'             ; to see if this is a power-up
 492+ 02EC 20 19                        jr      NZ,COLDSTART    ; if not, then do a COLD start
 493+ 02EE 21 D0 03                     ld      HL,MSGTXT2      ; message to choose kind of start
 494+ 02F1 CD 7D 02                     call    RAWPRINT        ; print message
 495+ 02F4 CD 38 09                     call    CURSOR_ON       ; enable cursor
 496+ 02F7 AF                           xor     A
 497+ 02F8 32 D9 81                     ld      (PRNTVIDEO),A   ; disable print-on-video
 498+ 02FB CD 2A 02     CORW:           call    RXA             ; look for a pressed key
 499+ 02FE E6 DF                        and     %11011111       ; only UPPERCASE char
 500+ 0300 FE 43                        cp      'C'             ; cold start?
 501+ 0302 20 0E                        jr      NZ,CHECKWARM    ; no, let's check for warm start
 502+ 0304 CD 1F 03                     call    ECHO_CHAR       ; echoes the char
 503+ 0307 3E 59        COLDSTART:      ld      A,'Y'           ; yes, set the "BASIC started" flag
 504+ 0309 32 5D 80                     ld      (basicStarted),A
 505+ 030C CD 4D 09                     call    CURSOR_OFF      ; disable cursor
 506+ 030F C3 05 12                     jp      COLD            ; start BASIC COLD
 507+ 0312 FE 57        CHECKWARM:      cp      'W'
 508+ 0314 20 E5                        jr      NZ,CORW         ; char not recognized, wait again
 509+ 0316 CD 1F 03                     call    ECHO_CHAR       ; echoes the char
 510+ 0319 CD 4D 09                     call    CURSOR_OFF      ; disable cursor
 511+ 031C C3 08 12                     jp      WARM            ; start BASIC WARM
 512+ 031F
 513+ 031F              ;-------------------------------------------------------------------------------
 514+ 031F              ; send back char received through ch. A
 515+ 031F 32 DA 81     ECHO_CHAR:      ld      (CHR4VID),A     ; set char for video printing
 516+ 0322 AF                           xor     A
 517+ 0323 32 17 82                     ld      (KBDNPT),A      ; input is not from keyboard
 518+ 0326 F3                           di                      ; disable INTs
 519+ 0327 CD 6C 07                     call    CHAR2VID        ; echoes back the pressed key,
 520+ 032A 3E 0D                        ld      A,CR            ; then set a CR
 521+ 032C 32 DA 81                     ld      (CHR4VID),A     ; set char for video printing
 522+ 032F CD 6C 07                     call    CHAR2VID        ; and send it to screen
 523+ 0332 FB                           ei                      ; re-enable INTs
 524+ 0333 3E 01                        ld      A,$01
 525+ 0335 32 D9 81                     ld      (PRNTVIDEO),A   ; re-enable video printing
 526+ 0338 C9                           ret                     ; return to caller
 527+ 0339
 528+ 0339                  IFDEF LM80C
 529+ 0339              ;-------------------------------------------------------------------------------
 530+ 0339              ; little serial blink with LEDs
 531+ 0339 0E 09        HELLOWRLD:      ld      C,$09           ; 8 LEDs to be turned off + 1 more step to turn off the last LED
 532+ 033B 3E CF                        ld      A,%11001111     ; set mode 3 (mode control)
 533+ 033D D3 03                        out     (PIO_CB),A      ; for PIO port B
 534+ 033F AF                           xor     A               ; set pins to OUTPUT
 535+ 0340 D3 03                        out     (PIO_CB),A      ; for port B
 536+ 0342 3C                           inc     A               ; LSB on
 537+ 0343 D3 01        LEDLIGHT:       out     (PIO_DB),A      ; turn LEDs on/off for a "Supercar" sequence
 538+ 0345 1E 20                        ld      E,$20           ; little delay
 539+ 0347 06 00        DEC_E:          ld      B,$00           ; count to 256
 540+ 0349 10 FE        COUNTER:        djnz    COUNTER         ; decrement inner counter
 541+ 034B 1D                           dec     E               ; decrement outer counter
 542+ 034C 20 F9                        jr      NZ,DEC_E        ; finish delay
 543+ 034E CB 27                        sla     A               ; shift reg.A to left 1 bit
 544+ 0350 0D                           dec     C               ; next LED
 545+ 0351 20 F0                        jr      NZ,LEDLIGHT     ; all LEDs done? no, repeat
 546+ 0353 C9                           ret                     ; return to caller
 547+ 0354                  ENDIF
 548+ 0354              ;-------------------------------------------------------------------------------
 549+ 0354              ; Z80 SIO default settings for serial channels
 550+ 0354 30           SIO_A_SETS:     defb    %00110000       ; write into WR0: error reset, select WR0
 551+ 0355 18                           defb    %00011000       ; write into WR0: channel reset
 552+ 0356 04                           defb    %00000100       ; write into WR0: select WR4
 553+ 0357 44                           defb    %01000100       ; write into WR4: presc. 16x, 1 stop bit, no parity
 554+ 0358 05                           defb    %00000101       ; write into WR0: select WR5
 555+ 0359 E8                           defb    %11101000       ; write into WR5: DTR on, TX 8 bits, BREAK off, TX on, RTS off
 556+ 035A 01           SIO_B_SETS:     defb    %00000001       ; write into WR0: select WR1
 557+ 035B 04                           defb    %00000100       ; write into WR1: status affects interrupt vectors
 558+ 035C 02                           defb    %00000010       ; write into WR0: select WR2
 559+ 035D 00                           defb    %00000000       ; write into WR2: set interrupt vector, but bits D3/D2/D1 of this vector
 560+ 035E                                                      ; will be affected by the channel & condition that raised the interrupt
 561+ 035E                                                      ; (see datasheet): in our example, 0x0C for Ch.A receiving A char, 0x0E
 562+ 035E                                                      ; for special conditions
 563+ 035E              ;------------------------------------------------------------------------------
 564+ 035E              ;               Z80 CTC SETTING UP
 565+ 035E              ;------------------------------------------------------------------------------
 566+ 035E              initCTC:
 567+ 035E 21 88 03                     ld      HL,CTCCONF      ; CTC configuration
 568+ 0361 11 C1 81                     ld      DE,CTC0IV       ; CTC interrupt vector table
 569+ 0364 01 0C 00                     ld      BC,$000C        ; 12 bytes
 570+ 0367 ED B0                        ldir                    ; copy data
 571+ 0369              ;CH0, CH1, & CH2 disabled
 572+ 0369 3E 03                        ld      A,%00000011     ; interrupt off, timer mode, prescaler=16, don't care ext. TRG edge,
 573+ 036B                                                      ; start timer on loading constant, no time constant follows, software reset, command word
 574+ 036B D3 10                        out     (CTC_CH0),A     ; set CH0
 575+ 036D D3 11                        out     (CTC_CH1),A     ; set CH1
 576+ 036F D3 12                        out     (CTC_CH2),A     ; set CH2
 577+ 0371              ;init CH3
 578+ 0371              ;CH3 divides CPU CLK by 144*256 providing an interrupt signal at 100 Hz (1/100 sec).
 579+ 0371              ;f = CPU_CLK/(144*256) => 3,686,400 / ( 36,864 ) => 100Hz
 580+ 0371 3E A7                        ld      A,%10100111     ; interrupt on; timer mode; prescaler=256; don't care ext; automatic trigger;
 581+ 0373                                                      ; time constant follows; cont. operation; command word
 582+ 0373 D3 13                        out     (CTC_CH3),A     ; send to CH3
 583+ 0375 3E 90                        ld      A,$90           ; time constant - 90$ (144d)
 584+ 0377 D3 13                        out     (CTC_CH3),A     ; send to CH3
 585+ 0379 3E 40                        ld      A,%01000000     ; D7..D3 provide the first part of the int vector (in our case, $0100), followed by
 586+ 037B                                                      ; D2..D1, provided by the CTC (they point to the channel), D0=interrupt word
 587+ 037B                                                      ; so int vector is 01000xx00
 588+ 037B D3 10                        out     (CTC_CH0),A     ; send to CTC
 589+ 037D                              ; reset cells of 100ths of a second counter
 590+ 037D AF                           xor     A               ; reset A
 591+ 037E 21 BD 81                     ld      HL,TMRCNT       ; load TMR pointer
 592+ 0381 06 04                        ld      B,$04           ; 4 memory cells
 593+ 0383 77           RESTMR:         ld      (HL),A          ; reset n-cell of TMR
 594+ 0384 23                           inc     HL              ; next cell
 595+ 0385 10 FC                        djnz    RESTMR          ; repeat for 4 cells
 596+ 0387 C9                           ret
 597+ 0388
 598+ 0388
 599+ 0388              ;------------------------------------------------------------------------------
 600+ 0388              ; jump table for CHx interrupts
 601+ 0388 FB ED 4D     CTCCONF:        defb    $FB,$ED,$4D     ; CTC0 interrupt vector (ei; reti)
 602+ 038B FB ED 4D                     defb    $FB,$ED,$4D     ; CTC1 interrupt vector (ei; reti)
 603+ 038E FB ED 4D                     defb    $FB,$ED,$4D     ; CTC2 interrupt vector (ei; reti)
 604+ 0391 C3 8B 02                     jp      CH3_TIMER       ; CTC3 interrupt vector (jump to execute sys-tick timer)
 605+ 0394
 606+ 0394
 607+ 0394              ;------------------------------------------------------------------------------
 608+ 0394              ; welcome messages
 609+ 0394              MSGTXT1:
 610+ 0394                  IFDEF LM80C64K
 611+ 0394 ~                            defm    "    LM80C 64K Color Computer",CR
 612+ 0394                  ELSE
 613+ 0394 20 20 20 20                  defm    "      LM80C Color Computer",CR
 613+ 0398 20 20 4C 4D
 613+ 039C 38 30 43 20
 613+ 03A0 43 6F 6C 6F
 613+ 03A4 72 20 43 6F
 613+ 03A8 6D 70 75 74
 613+ 03AC 65 72 0D
 614+ 03AF                  ENDIF
 615+ 03AF 20 62 79 20                  defm    " by Leonardo Miliani * FW R","3.19",CR,0
 615+ 03B3 4C 65 6F 6E
 615+ 03B7 61 72 64 6F
 615+ 03BB 20 4D 69 6C
 615+ 03BF 69 61 6E 69
 615+ 03C3 20 2A 20 46
 615+ 03C7 57 20 52 33
 615+ 03CB 2E 31 39 0D
 615+ 03CF 00
 616+ 03D0 0D           MSGTXT2:        defb    CR
 617+ 03D1 20 20 20 3C                  defm    "   <C>old or <W>arm start? ",0
 617+ 03D5 43 3E 6F 6C
 617+ 03D9 64 20 6F 72
 617+ 03DD 20 3C 57 3E
 617+ 03E1 61 72 6D 20
 617+ 03E5 73 74 61 72
 617+ 03E9 74 3F 20 00
 618+ 03ED
# file closed: ../include/bootloader/bootloader-1.06.asm
  71  03ED
  72  03ED              ; incude the latest version of the VDP module
  73  03ED                  INCLUDE "../include/vdp/vdp-1.4.asm"
# file opened: ../include/vdp/vdp-1.4.asm
   1+ 03ED              ; ------------------------------------------------------------------------------
   2+ 03ED              ; LM80C - VDP ROUTINES - 1.4
   3+ 03ED              ; ------------------------------------------------------------------------------
   4+ 03ED              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 03ED              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 03ED              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 03ED              ; kind of warranty: you can use them at your own risk.
   8+ 03ED              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 03ED              ; maintain the copyright notices, include this advice and the note to the
  10+ 03ED              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 03ED              ; redistribuite them.
  12+ 03ED              ; https://www.leonardomiliani.com
  13+ 03ED              ;
  14+ 03ED              ; Please support me by visiting the following links:
  15+ 03ED              ; Main project page: https://www.leonardomiliani.com
  16+ 03ED              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 03ED              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 03ED              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 03ED              ; ------------------------------------------------------------------------------
  20+ 03ED              ;
  21+ 03ED              ;------------------------------------------------------------------------------
  22+ 03ED              ; VDP INITIALISATION
  23+ 03ED              ; initialize VDP for a specific graphics mode
  24+ 03ED              ; INPUT: E -> contains the graphics mode:
  25+ 03ED              ; 0=text; 1=graphics 1; 2=graphics 2; 3=multicolor; 4=extended graphics 2
  26+ 03ED D5           initVDP:        push    DE              ; store E
  27+ 03EE CD DB 0A                     call    EMPTY_VRAM      ; reset VRAM
  28+ 03F1 CD FA 0A                     call    SET_GFX_MODE    ; load register settings
  29+ 03F4 CD EF 0A                     call    CLR_RAM_REG     ; reset RAM registers
  30+ 03F7 D1                           pop     DE              ; restore reg. E
  31+ 03F8 AF                           xor     A               ; reset A
  32+ 03F9 47                           ld      B,A             ; reset B (will be used later)
  33+ 03FA 7B                           ld      A,E             ; move E into A
  34+ 03FB 32 CF 81                     ld      (SCR_MODE),A    ; store screen mode
  35+ 03FE FE 01                        cp      $01             ; is it graphics 1 (A=1)?
  36+ 0400 CA 3C 04                     jp      Z,G1MD          ; yes, jump over
  37+ 0403 FE 02                        cp      $02             ; is it graphics 2 (A=2)?
  38+ 0405 CA 7D 04                     jp      Z,G2MD          ; yes, jump over
  39+ 0408 FE 03                        cp      $03             ; is it multicolor (A=3)?
  40+ 040A CA 9F 04                     jp      Z,MCMD          ; yes, jump over
  41+ 040D FE 04                        cp      $04             ; is it extended graphics 2 (A=4)?
  42+ 040F CA C2 04                     jp      Z,EXG2MD        ; yes, jump over
  43+ 0412                              ; otherwise, it must be $00 so we assume that it's text mode
  44+ 0412
  45+ 0412              ; LOAD VDP SETTINGS FOR SELECTED VIDEO MODE:
  46+ 0412
  47+ 0412                              ; TEXT MODE (G0)
  48+ 0412                              ; load charset
  49+ 0412 60           TXTMD:          ld      H,B
  50+ 0413 68                           ld      L,B             ; HL=first pattern cell $0000
  51+ 0414 CD 16 0B                     call    LOADCHARSET     ; load patterns into VRAM
  52+ 0417                              ; set cursor & video overlay
  53+ 0417 AF                           xor     A               ; reset A
  54+ 0418 32 D2 81                     ld      (SCR_CURS_X),A  ; set cursor position at X=0
  55+ 041B 32 D3 81                     ld      (SCR_CURS_Y),A  ; and Y=0
  56+ 041E 3E 05                        ld      A,$05           ; light blue
  57+ 0420 32 DC 81                     ld      (BKGNDCLR),A    ; set background/border color
  58+ 0423 3E 28                        ld      A,$28
  59+ 0425 32 CD 81                     ld      (SCR_SIZE_W),A  ; screen width = 40 cols
  60+ 0428 3E 18                        ld      A,$18
  61+ 042A 32 CE 81                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  62+ 042D 3E 1E                        ld      A,$1E
  63+ 042F 32 A3 80                     ld      (COMMAN),A      ; width for commas (4 columns)
  64+ 0432 11 00 08                     ld      DE,$0800
  65+ 0435 ED 53 D0 81                  ld      (SCR_NAM_TB),DE ; set name table address
  66+ 0439 C3 05 05                     jp      ENDVDPSET       ; execute the rest of the video setting
  67+ 043C
  68+ 043C                              ; GRAPHICS 1 MODE (G1)
  69+ 043C                              ; load pattern table
  70+ 043C 68           G1MD:           ld      L,B
  71+ 043D 60                           ld      H,B             ; HL=first pattern cell $0000
  72+ 043E CD 16 0B                     call    LOADCHARSET     ; load patterns into VRAM
  73+ 0441                              ; set cursor & video overlay
  74+ 0441 AF                           xor     A               ; position cursor
  75+ 0442 32 D2 81                     ld      (SCR_CURS_X),A  ; at X=0
  76+ 0445 32 D3 81                     ld      (SCR_CURS_Y),A  ; and Y=0
  77+ 0448 3E 20                        ld      A,$20
  78+ 044A 32 CD 81                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
  79+ 044D 3E 18                        ld      A,$18
  80+ 044F 32 CE 81                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  81+ 0452 3E 14                        ld      A,$14
  82+ 0454 32 A3 80                     ld      (COMMAN),A      ; width for commas (3 columns)
  83+ 0457 11 00 18                     ld      DE,$1800
  84+ 045A ED 53 D0 81                  ld      (SCR_NAM_TB),DE ; set name table address
  85+ 045E                              ; load color table
  86+ 045E 21 00 20                     ld      HL,$2000        ; color table start: $2000
  87+ 0461 CD 7B 06                     call    SETVDPADRS
  88+ 0464 3E 01                        ld      A,$01           ; foreground color...
  89+ 0466 32 DB 81                     ld      (FRGNDCLR),A    ; ...set to black
  90+ 0469 3E 0F                        ld      A,$0F           ; background color...
  91+ 046B 32 DC 81                     ld      (BKGNDCLR),A    ; ...set to white
  92+ 046E 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
  93+ 0470 06 20                        ld      B,$20           ; 32 bytes of colors
  94+ 0472 0E 30                        ld      C,VDP_DAT              ; VDP data mode
  95+ 0474 ED 79        LDCLRTBMD1:     out     (C),A           ; after the first byte, the VDP autoincrements VRAM pointer
  96+ 0476 00                           nop
  97+ 0477 00                           nop
  98+ 0478 10 FA                        djnz    LDCLRTBMD1      ; repeat for 32 bytes
  99+ 047A C3 05 05                     jp      ENDVDPSET       ; execute the rest of the video setting
 100+ 047D
 101+ 047D                              ; GRAPHICS 2 MODE (G2)
 102+ 047D AF           G2MD:           xor     A               ; position cursor
 103+ 047E 32 D2 81                     ld      (SCR_CURS_X),A  ; at X=0
 104+ 0481 32 D3 81                     ld      (SCR_CURS_Y),A  ; and Y=0
 105+ 0484 32 CD 81                     ld      (SCR_SIZE_W),A  ; screen width = 256 pixels (0=256)
 106+ 0487 3C                           inc     A               ; black on...
 107+ 0488 32 DB 81                     ld      (FRGNDCLR),A    ; ...foreground
 108+ 048B 3E 0F                        ld      A,$0F           ; white on...
 109+ 048D 32 DC 81                     ld      (BKGNDCLR),A    ; ...background
 110+ 0490 3E C0                        ld      A,$C0
 111+ 0492 32 CE 81                     ld      (SCR_SIZE_H),A  ; screen height = 192 pixels
 112+ 0495 11 00 18                     ld      DE,$1800
 113+ 0498 ED 53 D0 81                  ld      (SCR_NAM_TB),DE ; set name table address
 114+ 049C C3 05 05                     jp      ENDVDPSET       ; execute the rest of the video setting
 115+ 049F
 116+ 049F                              ; MULTICOLOR MODE (G3)
 117+ 049F AF           MCMD:           xor     A               ; position cursor
 118+ 04A0 32 D2 81                     ld      (SCR_CURS_X),A  ; at X=0
 119+ 04A3 32 D3 81                     ld      (SCR_CURS_Y),A  ; and Y=0
 120+ 04A6 3E 0F                        ld      A,$0F           ; white color for...
 121+ 04A8 32 DC 81                     ld      (BKGNDCLR),A    ; ...background and...
 122+ 04AB 32 DB 81                     ld      (FRGNDCLR),A    ; ...foreground (even this is not used in MC)
 123+ 04AE 3E 40                        ld      A,$40
 124+ 04B0 32 CD 81                     ld      (SCR_SIZE_W),A  ; screen width = 64 blocks
 125+ 04B3 3E 30                        ld      A,$30
 126+ 04B5 32 CE 81                     ld      (SCR_SIZE_H),A  ; screen height = 48 blocks
 127+ 04B8 11 00 08                     ld      DE,$0800
 128+ 04BB ED 53 D0 81                  ld      (SCR_NAM_TB),DE ; set name table address
 129+ 04BF C3 05 05                     jp      ENDVDPSET       ; execute the rest of the video setting
 130+ 04C2
 131+ 04C2                              ; EXTENDED GRAPHICS 2 (G4)
 132+ 04C2              EXG2MD:         ; load pattern table
 133+ 04C2 60                           ld      H,B
 134+ 04C3 68                           ld      L,B             ; HL=first pattern cell $0000
 135+ 04C4 CD 16 0B                     call    LOADCHARSET     ; load patterns into VRAM
 136+ 04C7                              ; set cursor & video overlay
 137+ 04C7 AF                           xor     A               ; position cursor
 138+ 04C8 32 D2 81                     ld      (SCR_CURS_X),A  ; at X=0
 139+ 04CB 32 D3 81                     ld      (SCR_CURS_Y),A  ; and Y=0
 140+ 04CE 3E 20                        ld      A,$20
 141+ 04D0 32 CD 81                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
 142+ 04D3 3E 18                        ld      A,$18
 143+ 04D5 32 CE 81                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
 144+ 04D8 3E 14                        ld      A,$14
 145+ 04DA 32 A3 80                     ld      (COMMAN),A      ; width for commas (3 columns)
 146+ 04DD 11 00 38                     ld      DE,$3800
 147+ 04E0 ED 53 D0 81                  ld      (SCR_NAM_TB),DE ; set name table address
 148+ 04E4                               ; load color table
 149+ 04E4 21 00 20                     ld      HL,$2000        ; color table start: $2000
 150+ 04E7 CD 7B 06                     call    SETVDPADRS
 151+ 04EA 3E 01                        ld      A,$01           ; foreground color is...
 152+ 04EC 32 DB 81                     ld      (FRGNDCLR),A    ; ...set to black
 153+ 04EF 3E 0F                        ld      A,$0F           ; whitefor...
 154+ 04F1 32 DC 81                     ld      (BKGNDCLR),A    ; ...background
 155+ 04F4 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
 156+ 04F6 16 08                        ld      D,$08           ; 8 pages of
 157+ 04F8 06 00                        ld      B,$00           ; 256 bytes of colors (total of 2,048 cells)
 158+ 04FA 0E 30                        ld      C,VDP_DAT              ; VDP data mode
 159+ 04FC ED 79        LDCLRTBEX2:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
 160+ 04FE 00                           nop
 161+ 04FF 00                           nop
 162+ 0500 10 FA                        djnz    LDCLRTBEX2      ; repeat for 256 bytes
 163+ 0502 15                           dec     D               ; did we fill up all the cells?
 164+ 0503 20 F7                        jr      NZ,LDCLRTBEX2   ; no, repeat
 165+ 0505                              ; LAST VDP SETTINGS
 166+ 0505 CD 4D 09     ENDVDPSET:      call    CURSOR_OFF      ; disable cursor
 167+ 0508 CD E9 05                     call    EMPTYVIDBUF     ; empty video buffer
 168+ 050B AF                           xor     A
 169+ 050C 32 D6 81                     ld      (SCR_ORG_CHR),A ; store byte used tochar used to empty the video buffer
 170+ 050F C9                           ret                     ; return to caller
 171+ 0510
 172+ 0510
 173+ 0510              ; show initial logo
 174+ 0510 CD DB 0A     SHOW_LOGO:      call    EMPTY_VRAM      ; reset VRAM
 175+ 0513                              ; set VDP for G2 mode
 176+ 0513 06 07                        ld      B,$07           ; set only the first 7 registers
 177+ 0515 11 10 00                     ld      DE,$0010        ; load settings for G2 mode
 178+ 0518 CD 02 0B                     call    SET_GFX_MODE2   ; load register settings
 179+ 051B 16 01                        ld      D,$01           ; backdrop color set to black
 180+ 051D ED 51                        out     (C),D           ; send data to VDP
 181+ 051F ED 79                        out     (C),A           ; indicate the register to send data to
 182+ 0521                              ; set name table
 183+ 0521 21 00 18                     ld      HL,$1800        ; name table address
 184+ 0524 CD 68 06                     call    SETNAMETABLE    ; set name table (load names into table)
 185+ 0527 CD 87 05                     call    ERASECLRTBL     ; erase color table (set foreground & background to black)
 186+ 052A                              ; set colors for logo
 187+ 052A 21 00 28                     ld      HL,$2800        ; 2nd page of color table
 188+ 052D CD 7B 06                     call    SETVDPADRS
 189+ 0530 06 05                        ld      B,$05           ; 5 bands
 190+ 0532 21 D4 05                     ld      HL,CLRTABLE
 191+ 0535 0E 30                        ld      C,VDP_DAT              ; set VDP_DAT
 192+ 0537 1E 08                        ld      E,$08           ; 8 pixels each pattern
 193+ 0539 16 40        RPT101:         ld      D,$40           ; 64 chars each band
 194+ 053B 7E                           ld      A,(HL)          ; load data
 195+ 053C ED 79        RPT102:         out     (C),A           ; send it to VRAM
 196+ 053E 00                           nop                     ; little delay
 197+ 053F 1D                           dec     E               ; decrement counter
 198+ 0540 20 FA                        jr      NZ,RPT102       ; repeat until zero
 199+ 0542 1E 08                        ld      E,$08           ; 8 pixels each pattern
 200+ 0544 15                           dec     D               ; decrement char band counter
 201+ 0545 20 F5                        jr      NZ,RPT102       ; repeat until zero
 202+ 0547 23                           inc     HL              ; next pattern
 203+ 0548 10 EF                        djnz    RPT101          ; repeat until covered every band
 204+ 054A                              ; set pattern table
 205+ 054A 21 00 08                     ld      HL,$0800        ; address of first cell of 2nd area of pattern table
 206+ 054D 11 5F 0B                     ld      DE,LM80CLOGO    ; pointer to logo pattern
 207+ 0550 06 00                        ld      B,$00           ; 256 bytes, 8 rows
 208+ 0552 CD B3 05     RPT103:         call    LOADLOGOCHRS
 209+ 0555 13                           inc     DE              ; next logo pattern
 210+ 0556 10 FA                        djnz    RPT103
 211+ 0558 06 20                        ld      B,$20           ; repeat for another 2 rows
 212+ 055A CD B3 05     RPT104:         call    LOADLOGOCHRS
 213+ 055D 13                           inc     DE              ; next logo pattern
 214+ 055E 10 FA                        djnz    RPT104
 215+ 0560                              ; show logo/message, play a beep, check for SHIFT pressure (to disable DOS), and wait a while
 216+ 0560 06 02                        ld      B,$02           ; two times
 217+ 0562 AF                           xor     A               ; reset A
 218+ 0563 57                           ld      D,A             ; 256 times
 219+ 0564 5F                           ld      E,A             ; x 256 times
 220+ 0565 32 DD 81                     ld      (TMPBFR1),A     ; sound flag set to 0
 221+ 0568                  IFDEF LM80C64K
 222+ 0568 ~                            inc     A               ; by default, I/O DOS buffer is enabled on LM80C 64K, disabled on LM80C
 223+ 0568                  ENDIF
 224+ 0568 32 22 82                     ld      (DOS_EN),A      ; DOS enabled
 225+ 056B 00           DEC_D:          nop                     ; does nothing...
 226+ 056C 00                           nop
 227+ 056D 00                           nop
 228+ 056E 00                           nop
 229+ 056F 00                           nop
 230+ 0570 00                           nop                     ; ...until here
 231+ 0571 1D                           dec     E               ; decrement E
 232+ 0572 20 F7                        jr      NZ,DEC_D        ; repeat until $00
 233+ 0574 7A                           ld      A,D
 234+ 0575 FE 40                        cp      $40             ; ...equal to 64
 235+ 0577 CC 9F 05                     call    Z,SETBEEP       ; if yes, start sound
 236+ 057A 15                           dec     D
 237+ 057B 20 EE                        jr      NZ,DEC_D        ; repeat
 238+ 057D 3A DD 81                     ld      A,(TMPBFR1)     ; sound state
 239+ 0580 FE 02                        cp      $02             ; check if sound is to be set off
 240+ 0582 C4 AB 05                     call    NZ,BEEPOFF      ; yes
 241+ 0585                  IFDEF LM80C64K
 242+ 0585 ~                            call    CHKSPCK         ; check if special key (CTRL) has been pressed on keyboard
 243+ 0585 ~                                                    ; on LM80C 64K, you can disabled the I/O DOS buffer, on LM80C you can't
 244+ 0585                  ENDIF
 245+ 0585 10 E4                        djnz    DEC_D           ; repeat
 246+ 0587              ERASECLRTBL:    ; erase color table
 247+ 0587 3E 11                        ld      A,$11           ; foreground and background set to black
 248+ 0589 16 0A                        ld      D,$0A           ; 10 pages
 249+ 058B 06 00                        ld      B,$00           ; 256 color cells per page
 250+ 058D 21 00 28                     ld      HL,$2800        ; first cell of 2nd color table
 251+ 0590 CD 7B 06                     call    SETVDPADRS      ; send address
 252+ 0593 0E 30                        ld      C,VDP_DAT              ; VDP address for passing data
 253+ 0595 ED 79        RPT100:         out     (C),A           ; send data
 254+ 0597 00                           nop
 255+ 0598 00                           nop                     ; little delay
 256+ 0599 10 FA                        djnz    RPT100          ; repeat for entire page
 257+ 059B 15                           dec     D
 258+ 059C 20 F7                        jr      NZ,RPT100       ; repeat for all the pages ($0A00 cells)
 259+ 059E C9                           ret                     ; return to caller
 260+ 059F
 261+ 059F              ; play a beep
 262+ 059F 3A DD 81     SETBEEP:        ld      A,(TMPBFR1)     ; check the already-beeped flag
 263+ 05A2 B7                           or      A               ; is it 0?
 264+ 05A3 C0                           ret     NZ              ; no, exit
 265+ 05A4 3C                           inc     A               ; flag to 1
 266+ 05A5 32 DD 81                     ld      (TMPBFR1),A     ; set sound
 267+ 05A8 C3 CD 0C                     jp      WLCMBEEP        ; play a beep & return
 268+ 05AB
 269+ 05AB              ; beep off
 270+ 05AB 3E 02        BEEPOFF:        ld      A,$02           ; flag for sound off
 271+ 05AD 32 DD 81                     ld      (TMPBFR1),A     ; set flag
 272+ 05B0 C3 D3 0C                     jp      NOBEEP          ; stop beep and return
 273+ 05B3
 274+ 05B3
 275+ 05B3              ; used to load the chars that will compose the logo of the splash screen
 276+ 05B3 1A           LOADLOGOCHRS:   ld      A,(DE)          ; load a pattern char of the logo
 277+ 05B4 87                           add     A,A
 278+ 05B5 87                           add     A,A
 279+ 05B6 87                           add     A,A             ; multiply times 8 to get the offset
 280+ 05B7 C5                           push    BC
 281+ 05B8 D5                           push    DE              ; store BC and DE
 282+ 05B9 E5                           push    HL              ; store VRAM address to write to
 283+ 05BA 21 67 50                     ld      HL,LOGOFONT     ; start of logo font data
 284+ 05BD 5F                           ld      E,A
 285+ 05BE 16 00                        ld      D,$00           ; put offset (A) into DE
 286+ 05C0 19                           add     HL,DE           ; get address of pattern data
 287+ 05C1 EB                           ex      DE,HL           ; move address into DE
 288+ 05C2 E1                           pop     HL              ; retrieve VRAM address
 289+ 05C3 06 08                        ld      B,$08           ; 8 bytes per pattern
 290+ 05C5 CD 7B 06                     call    SETVDPADRS      ; set VDP address
 291+ 05C8 0E 30                        ld      C,VDP_DAT              ; VDP_DAT
 292+ 05CA 1A           SNDLOGPT:       ld      A,(DE)          ; load data from RAM
 293+ 05CB ED 79                        out     (C),A           ; and send to VRAM
 294+ 05CD 13                           inc     DE              ; next byte into RAM
 295+ 05CE 23                           inc     HL              ; next byte into VRAM (used in future iterations)
 296+ 05CF 10 F9                        djnz    SNDLOGPT        ; repeat 8 times
 297+ 05D1 D1                           pop     DE
 298+ 05D2 C1                           pop     BC              ; retrieve BC & DE
 299+ 05D3 C9                           ret                     ; return to caller
 300+ 05D4              CLRTABLE:       equ $
 301+ 05D4 18 1B 13 14                  defb    $18,$1B,$13,$14,$1D ; colors of background bands of the logo
 301+ 05D8 1D
 302+ 05D9
 303+ 05D9
 304+ 05D9              ; while showing the logo, check if special key (CTRL) is being pressed
 305+ 05D9              ; if yes, then disable DOS functions recovering RAM
 306+ 05D9 F5           CHKSPCK:        push    AF
 307+ 05DA 3E FE                        ld      A,%11111110     ; select CTRL row
 308+ 05DC CD 51 0D                     call    READKBLN        ; read row
 309+ 05DF CB 57                        bit     2,A             ; test if CTRL key is pressed
 310+ 05E1 20 04                        jr      NZ,LVCKSPLK     ; no, leave
 311+ 05E3 AF                           xor     A               ; yes, so...
 312+ 05E4 32 22 82                     ld      (DOS_EN),A      ; ...disable DOS
 313+ 05E7 F1           LVCKSPLK:       pop     AF
 314+ 05E8 C9                           ret
 315+ 05E9
 316+ 05E9
 317+ 05E9              ; empty video buffer
 318+ 05E9 3A CF 81     EMPTYVIDBUF:    ld      A,(SCR_MODE)    ; check screen mode
 319+ 05EC FE 02                        cp      $02             ; is it G2 mode?
 320+ 05EE CA 12 06                     jp      Z,EMPTYG2       ; yes, jump over
 321+ 05F1 FE 03                        cp      $03             ; is it MC mode?
 322+ 05F3 CA 43 06                     jp      Z,EMPTYMC       ; yes, jump over
 323+ 05F6 3A CE 81                     ld      A,(SCR_SIZE_H)  ; load height of screen
 324+ 05F9 47                           ld      B,A             ; move rows into B
 325+ 05FA AF                           xor     A               ; filling char is $00
 326+ 05FB 2A D0 81                     ld      HL,(SCR_NAM_TB) ; load the name table address
 327+ 05FE CD 7B 06                     call    SETVDPADRS      ; send address to VDP
 328+ 0601 0E 30                        ld      C,VDP_DAT              ; VDP address for passing data
 329+ 0603 5F           LDCOLSTOEMPTY:  ld      E,A             ; store filling char into E
 330+ 0604 3A CD 81                     ld      A,(SCR_SIZE_W)  ; load # of cols to empty into A
 331+ 0607 57                           ld      D,A             ; move A into D
 332+ 0608 7B                           ld      A,E             ; recover filling char
 333+ 0609 ED 79        RPTEMPTYBUF:    out     (C),A           ; write empty byte into VRAM
 334+ 060B 00                           nop
 335+ 060C 15                           dec     D               ; decr. D
 336+ 060D 20 FA                        jr      NZ,RPTEMPTYBUF  ; repeat for the # of cols
 337+ 060F 10 F2                        djnz    LDCOLSTOEMPTY   ; repeat for the # of rows
 338+ 0611 C9                           ret                     ; return to caller
 339+ 0612 2A D0 81     EMPTYG2:        ld      HL,(SCR_NAM_TB) ; yes, additional setup for G2 - load G2 name table address (usually $1800)
 340+ 0615 CD 68 06                     call    SETNAMETABLE    ; set name table
 341+ 0618 21 00 00                     ld      HL,$0000        ; set pattern table
 342+ 061B CD 7B 06                     call    SETVDPADRS      ; send address to VDP
 343+ 061E AF                           xor     A               ; empty pattern
 344+ 061F 16 18                        ld      D,$18           ; 6144 ($1800) cell to clean, 24 pages ($18)
 345+ 0621 47                           ld      B,A             ; 256 bytes for page
 346+ 0622 0E 30                        ld      C,VDP_DAT              ; VDP data mode
 347+ 0624 ED 79        CLRG2PTNTBL:    out     (C),A           ; clear pattern
 348+ 0626 00                           nop                     ; little delay
 349+ 0627 00                           nop
 350+ 0628 10 FA                        djnz    CLRG2PTNTBL     ; repeat for 1 page
 351+ 062A 15                           dec     D               ; next page
 352+ 062B 20 F7                        jr      NZ,CLRG2PTNTBL  ; repeat
 353+ 062D 21 00 20                     ld      HL,$2000        ; load the color table address
 354+ 0630 CD 7B 06                     call    SETVDPADRS      ; send address to VDP
 355+ 0633 3A DB 81                     ld      A,(FRGNDCLR)    ; load foreground
 356+ 0636 87                           add     A,A
 357+ 0637 87                           add     A,A
 358+ 0638 87                           add     A,A
 359+ 0639 87                           add     A,A             ; move to high nibble
 360+ 063A 57                           ld      D,A             ; store into D
 361+ 063B 3A DC 81                     ld      A,(BKGNDCLR)    ; load background color
 362+ 063E B2                           or      D               ; combine with background color
 363+ 063F 16 18                        ld      D,$18           ; 6144 ($1800) cells to fill, so 24 pages ($18)
 364+ 0641 18 17                        jr      STARTEMPTY
 365+ 0643 21 00 08     EMPTYMC:        ld      HL,$0800        ; MC name table
 366+ 0646 CD 68 06                     call    SETNAMETABLE    ; set name table
 367+ 0649 21 00 00                     ld      HL,$0000        ; color table address
 368+ 064C CD 7B 06                     call    SETVDPADRS      ; send address to VDP
 369+ 064F 3A DC 81                     ld      A,(BKGNDCLR)    ; load background
 370+ 0652 57                           ld      D,A             ; store into D
 371+ 0653 87                           add     A,A
 372+ 0654 87                           add     A,A
 373+ 0655 87                           add     A,A
 374+ 0656 87                           add     A,A             ; move to high nibble
 375+ 0657 B2                           or      D               ; set background color for high and low nibble
 376+ 0658 16 08                        ld      D,$08           ; 2048 ($0800) cells to fill, so 8 pages ($08)
 377+ 065A 0E 30        STARTEMPTY:     ld      C,VDP_DAT              ; VDP address for passing data
 378+ 065C 06 00                        ld      B,$00           ; 256 bytes each page ($00=256)
 379+ 065E ED 79        SNDCLRSET:      out     (C),A           ; send color setting
 380+ 0660 00                           nop                     ; wait a while
 381+ 0661 00                           nop
 382+ 0662 10 FA                        djnz    SNDCLRSET       ; repeat for 1 page
 383+ 0664 15                           dec     D               ; have we filled all the pages?
 384+ 0665 20 F7                        jr      NZ,SNDCLRSET    ; no, repeat
 385+ 0667 C9                           ret                     ; return to caller
 386+ 0668
 387+ 0668              ; set name table for G2 mode (patterns from $00 to $FF for each of the 3 areas of the screen)
 388+ 0668 CD 7B 06     SETNAMETABLE:   call    SETVDPADRS      ; send address to VDP
 389+ 066B 0E 30                        ld      C,VDP_DAT              ; VDP address for passing data
 390+ 066D 16 03                        ld      D,$03           ; 3 pages to fill into VRAM (768 cells)
 391+ 066F AF                           xor     A               ; starting char name #0 (chars go from 0 to 255)
 392+ 0670 47                           ld      B,A             ; reset B
 393+ 0671 ED 79        RPTFLL1:        out     (C),A           ; send name to VRAM
 394+ 0673 00                           nop
 395+ 0674 3C                           inc     A               ; increment # of name
 396+ 0675 10 FA                        djnz    RPTFLL1         ; repeat for 256 cells (1 page)
 397+ 0677 15                           dec     D               ; did we fill all the pages?
 398+ 0678 20 F7                        jr      NZ,RPTFLL1      ; no, continue
 399+ 067A C9                           ret                     ; return to caller
 400+ 067B
 401+ 067B              ; set an address into VRAM: address is in HL - HL is changed after it
 402+ 067B 0E 32        SETVDPADRS:     ld      C,VDP_SET       ; VDP address mode
 403+ 067D CB F4                        set     6,H             ; set bit #6 of address, to write to VRAM
 404+ 067F ED 69                        out     (C),L           ; send low and...
 405+ 0681 ED 61                        out     (C),H           ; ...high byte of the first cell
 406+ 0683 C9                           ret                     ; return to caller
 407+ 0684
 408+ 0684              ; clear the video buffer and position the cursor at 0,0
 409+ 0684 CD E9 05     CLEARVIDBUF:    call    EMPTYVIDBUF     ; clear video buffer
 410+ 0687 AF                           xor     A               ; reset A
 411+ 0688 32 D2 81                     ld      (SCR_CURS_X),A  ; cursor X to 0
 412+ 068B 32 D3 81                     ld      (SCR_CURS_Y),A  ; cursor Y to 0
 413+ 068E C3 D7 06                     jp      POS_CURSOR      ; position cursor & return to caller
 414+ 0691
 415+ 0691              ; HOME: position the cursor at coords. 0,0
 416+ 0691 AF           ATHOME:         xor     A               ; position cursor at 0,0 by storing...
 417+ 0692 32 D5 81                     ld      (SCR_CUR_NY),A  ; ...new Y...
 418+ 0695 32 D4 81                     ld      (SCR_CUR_NX),A  ; ...and new X
 419+ 0698 C3 E1 06                     jp      MOVCRS          ; move cursor to new location & return to caller
 420+ 069B
 421+ 069B              ; load the char or byte at the VRAM position set by HL
 422+ 069B              ; value is returned into A
 423+ 069B C5           READ_VIDEO_LOC: push    BC              ; store BC
 424+ 069C 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 425+ 069E 44                           ld      B,H
 426+ 069F CB B8                        res     7,B
 427+ 06A1 CB B0                        res     6,B
 428+ 06A3 ED 69                        out     (C),L           ; low byte then...
 429+ 06A5 ED 41                        out     (C),B           ; high byte
 430+ 06A7 0E 30                        ld      C,VDP_DAT              ; VDP data mode
 431+ 06A9 ~                            LM64K_NOP               ; added to compensate shorter instruction
 432+ 06A9 00                           nop                     ; wait...
 433+ 06AA 00                           nop                     ; ...a while
 434+ 06AB 00                           nop
 435+ 06AC ED 78                        in      A,(C)           ; read byte at current VRAM location
 436+ 06AE C1                           pop     BC              ; restore BC
 437+ 06AF C9                           ret                     ; return to caller
 438+ 06B0
 439+ 06B0              ; write a byte at the VRAM position pointed by HL
 440+ 06B0              ; value is in A
 441+ 06B0 C5           WRITE_VIDEO_LOC:push    BC              ; store BC
 442+ 06B1 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 443+ 06B3 44                           ld      B,H             ; copy H into B
 444+ 06B4 CB B8                        res     7,B
 445+ 06B6 CB F0                        set     6,B             ; write to VRAM
 446+ 06B8 ED 69                        out     (C),L           ; low byte then...
 447+ 06BA ED 41                        out     (C),B           ; high byte of VRAM address
 448+ 06BC 0E 30                        ld      C,VDP_DAT              ; VDP data mode
 449+ 06BE ~                            LM64K_NOP               ; added to compensate shorter instruction
 450+ 06BE 00                           nop                     ; wait...
 451+ 06BF 00                           nop                     ; ...a while
 452+ 06C0 00                           nop
 453+ 06C1 ED 79                        out     (C),A           ; write byte into VRAM
 454+ 06C3 C1                           pop     BC              ; restore BC
 455+ 06C4 C9                           ret                     ; return to caller
 456+ 06C5
 457+ 06C5              ; write a value into a specific VDP register
 458+ 06C5              ; value is in E, register is in A
 459+ 06C5 C5           WRITE_VREG:     push    BC              ; store BC
 460+ 06C6 C6 80                        add     A,$80           ; set VDP to write to registers
 461+ 06C8 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 462+ 06CA ED 59                        out     (C),E           ; send data to VDP
 463+ 06CC ED 79                        out     (C),A           ; select the destination register
 464+ 06CE C1                           pop     BC              ; restore BC
 465+ 06CF C9                           ret                     ; return to caller
 466+ 06D0
 467+ 06D0              ; read VDP status register and return value into A
 468+ 06D0 C5           READ_VSTAT:     push    BC              ; store BC
 469+ 06D1 0E 32                        ld      C,VDP_SET       ; VDP register access
 470+ 06D3 ED 78                        in      A,(C)           ; read status register
 471+ 06D5 C1                           pop     BC              ; restore BC
 472+ 06D6 C9                           ret                     ; return to caller
 473+ 06D7
 474+ 06D7              ; position the cursor at the current coordinates, preserving underlying char
 475+ 06D7 CD 1A 07     POS_CURSOR:     call    LOAD_CRSR_POS   ; load the VRAM address of cursor into HL
 476+ 06DA CD 9B 06                     call    READ_VIDEO_LOC  ; load the current char at the cursor position (return in A)
 477+ 06DD 32 D6 81                     ld      (SCR_ORG_CHR),A ; store the current char
 478+ 06E0 C9                           ret
 479+ 06E1
 480+ 06E1              ; move cursor to new X,Y coordinates
 481+ 06E1 CD 11 07     MOVCRS:         call    RSTCHRCRS       ; restore the char in the current cursor position
 482+ 06E4 CD FC 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 483+ 06E7 CD D7 06     MOVSHOWCRS:     call    POS_CURSOR      ; position cursor into new location
 484+ 06EA 3A D7 81                     ld      A,(CRSR_STATE)  ; load status of cursor
 485+ 06ED A7                           and     A               ; is cursor off?
 486+ 06EE C8                           ret     Z               ; yes, return
 487+ 06EF 3A D8 81                     ld      A,(LSTCSRSTA)   ; it's visible, so...
 488+ 06F2 F6 20                        or      $20             ; ...set cursor on
 489+ 06F4 32 D8 81                     ld      (LSTCSRSTA),A   ; store the last cursor state
 490+ 06F7 3E FF                        ld      A,$FF           ; BTW, set cursor visible after moved it
 491+ 06F9 C3 B0 06                     jp      WRITE_VIDEO_LOC ; write into video cell
 492+ 06FC
 493+ 06FC
 494+ 06FC              ; set new cursor's coordinates
 495+ 06FC 3A D4 81     NEWCRSRCOORD:   ld      A,(SCR_CUR_NX)  ; load new X
 496+ 06FF 32 D2 81                     ld      (SCR_CURS_X),A  ; write new X
 497+ 0702 3A D5 81                     ld      A,(SCR_CUR_NY)  ; load new Y
 498+ 0705 32 D3 81                     ld      (SCR_CURS_Y),A  ; write new Y
 499+ 0708 3E FF                        ld      A,$FF           ; delete new values
 500+ 070A 32 D4 81                     ld      (SCR_CUR_NX),A  ; of X
 501+ 070D 32 D5 81                     ld      (SCR_CUR_NY),A  ; and Y
 502+ 0710 C9                           ret
 503+ 0711
 504+ 0711              ; recover char under the cursor and prints it onto the screen
 505+ 0711 CD 1A 07     RSTCHRCRS:      call    LOAD_CRSR_POS   ; recover old cursor position
 506+ 0714 3A D6 81                     ld      A,(SCR_ORG_CHR) ; recover old char
 507+ 0717 C3 B0 06                     jp      WRITE_VIDEO_LOC ; write char into VRAM & return
 508+ 071A
 509+ 071A              ; retrieve cursor position from either current coordinates or next place
 510+ 071A              ; return address position into HL
 511+ 071A 3A D3 81     LOAD_CRSR_POS:  ld      A,(SCR_CURS_Y)  ; load cursor Y
 512+ 071D 6F                           ld      L,A             ; move it into reg.L
 513+ 071E AF                           xor     A               ; reset A
 514+ 071F 67                           ld      H,A             ; reset H
 515+ 0720 47                           ld      B,A             ; reset B
 516+ 0721 29                           add     HL,HL           ; create offset (each address is 2-bytes long so we need to double HL)
 517+ 0722 11 AB 0A                     ld      DE,POS_TB_CRS_40; load position table address of cursor for 40 cols
 518+ 0725 3A CD 81                     ld      A,(SCR_SIZE_W)  ; load screen width
 519+ 0728 FE 28                        cp      $28             ; is it 40 cols?
 520+ 072A 28 03                        jr      Z,CONT_POS_CURS ; yes, jump over
 521+ 072C 11 7B 0A                     ld      DE,POS_TB_CRS_32; no, load position table address of cursor for 32 cols
 522+ 072F 19           CONT_POS_CURS:  add     HL,DE           ; the correct starting address of the required row is now into HL
 523+ 0730 5E                           ld      E,(HL)          ; load starting address of the required row into DE
 524+ 0731 23                           inc     HL
 525+ 0732 56                           ld      D,(HL)
 526+ 0733 2A D0 81                     ld      HL,(SCR_NAM_TB) ; load starting address of name table
 527+ 0736 19                           add     HL,DE           ; starting address of the current row into name table
 528+ 0737 3A D2 81                     ld      A,(SCR_CURS_X)  ; load cursor X
 529+ 073A 4F                           ld      C,A             ; transfer A into C
 530+ 073B 09                           add     HL,BC           ; add X offset: now HL contains the address of the current cursor position
 531+ 073C C9                           ret
 532+ 073D
 533+ 073D              ; find X,Y coordinates of a screen address pointed in VRAM by HL
 534+ 073D              ; return them into L,A for X,Y
 535+ 073D D5           HL2XY:          push    DE              ; store DE
 536+ 073E ED 5B D0 81                  ld      DE,(SCR_NAM_TB) ; load starting address of name table into DE
 537+ 0742 AF                           xor     A               ; clear Carry
 538+ 0743 ED 52                        sbc     HL,DE           ; find position relative to screen (from 0,0)
 539+ 0745 D1                           pop     DE
 540+ 0746 3A CD 81                     ld      A,(SCR_SIZE_W)  ; load screen width
 541+ 0749 4F                           ld      C,A             ; move it into C
 542+ 074A CD 43 40                     call    DIV_16_8        ; divide position by C: return Y into L and X into A
 543+ 074D C9                           ret                     ; return to caller
 544+ 074E
 545+ 074E              ;-------------------------------------------------------------------------------
 546+ 074E              ; char table for jumps
 547+ 074E 19           CHRTBL:         defb    HOME
 548+ 074F 91 06                        defw    ATHOME          ; move the cursor to 0,0
 549+ 0751
 550+ 0751 0C                           defb    CS
 551+ 0752 84 06                        defw    CLEARVIDBUF     ; clear video buffer and position cursor at 0,0
 552+ 0754
 553+ 0754 0D                           defb    CR
 554+ 0755 CE 09                        defw    CRGRETURN       ; go to the beginning of the next line
 555+ 0757
 556+ 0757 08                           defb    BKSP
 557+ 0758 3B 08                        defw    BACKSPACE       ; move cursor left 1 position
 558+ 075A
 559+ 075A 1C                           defb    CRSLFT
 560+ 075B 7E 08                        defw    CURSORLEFT      ; move cursor left
 561+ 075D
 562+ 075D 1E                           defb    CRSUP
 563+ 075E CA 08                        defw    CURSORUP        ; move cursor up
 564+ 0760
 565+ 0760 1D                           defb    CRSRGT
 566+ 0761 E3 08                        defw    CURSORRIGHT     ; move cursor right
 567+ 0763
 568+ 0763 1F                           defb    CRSDN
 569+ 0764 18 09                        defw    CURSORDOWN      ; move cursor up
 570+ 0766
 571+ 0766 1A                           defb    INSRT
 572+ 0767 F9 07                        defw    INSERTKEY       ; insert a space
 573+ 0769
 574+ 0769 0A                           defb    LF
 575+ 076A D5 07                        defw    PLACEHOLDER     ; CURRENTLY WE DON'T PRINT LINE FEED
 576+ 076C
 577+ 076C              ; send current char to video buffer
 578+ 076C F5           CHAR2VID:       push    AF              ; store AF
 579+ 076D C5                           push    BC              ; store BC
 580+ 076E D5                           push    DE              ; store DE
 581+ 076F E5                           push    HL              ; store HL
 582+ 0770 3A D7 81                     ld      A,(CRSR_STATE)  ; store cursor state...
 583+ 0773 F5                           push    AF              ; into stack
 584+ 0774 CD 4D 09                     call    CURSOR_OFF      ; cursor off
 585+ 0777 3A DA 81                     ld      A,(CHR4VID)     ; recover char
 586+ 077A 06 0A                        ld      B,$0A           ; 10 chars to check
 587+ 077C 21 4E 07                     ld      HL,CHRTBL       ; address of key table
 588+ 077F BE           RPTCPCK:        cp      (HL)            ; compare with char
 589+ 0780 23                           inc     HL              ; beginning of sub-routine address
 590+ 0781 20 09                        jr      NZ,NXTCPCK      ; different, go to next char
 591+ 0783 5E                           ld      E,(HL)          ; load addres into DE
 592+ 0784 23                           inc     HL
 593+ 0785 56                           ld      D,(HL)
 594+ 0786 EB                           ex      DE,HL           ; move user routine's address into HL
 595+ 0787 11 C8 07                     ld      DE,EXITCHAR2VID ; set point of return after the user routine
 596+ 078A D5                           push    DE              ; store into stack
 597+ 078B E9                           jp      (HL)            ; call user routine - then, the CPU will return (jump) to EXITCHAR2VID
 598+ 078C 23           NXTCPCK:        inc     HL              ; jump over 2 cells...
 599+ 078D 23                           inc     HL              ; ...to the next char code
 600+ 078E 10 EF                        djnz    RPTCPCK         ; repeat
 601+ 0790                              ; it'a not a special char, just print it
 602+ 0790 CD 1A 07                     call    LOAD_CRSR_POS   ; recover position of cursor
 603+ 0793 3A DA 81                     ld      A,(CHR4VID)     ; recover char to print
 604+ 0796 CD B0 06                     call    WRITE_VIDEO_LOC ; write A into VRAM at (HL)
 605+ 0799 3A D3 81                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 606+ 079C 5F                           ld      E,A             ; store cursor Y into E
 607+ 079D 3A D2 81                     ld      A,(SCR_CURS_X)  ; load cursor X
 608+ 07A0 3C                           inc     A               ; move 1 step to right
 609+ 07A1 21 CD 81                     ld      HL,SCR_SIZE_W   ; cell that keeps the width of screen
 610+ 07A4 BE                           cp      (HL)            ; have we reached the most right position?
 611+ 07A5 20 0F                        jr      NZ,SETCSRCOORDS ; no, go over
 612+ 07A7 1C                           inc     E               ; yes, increment cursor Y (go to next line)
 613+ 07A8 7B                           ld      A,E             ; move cursor Y into A
 614+ 07A9 21 CE 81                     ld      HL,SCR_SIZE_H   ; cell that keeps the height of screen
 615+ 07AC BE                           cp      (HL)            ; have we reached the bottom of the screen?
 616+ 07AD 20 06                        jr      NZ,SETCRSRY     ; no, jump over
 617+ 07AF D5                           push    DE
 618+ 07B0 CD 54 09                     call    SCROLLUP        ; scroll screen up
 619+ 07B3 D1                           pop     DE
 620+ 07B4 1D                           dec     E               ; decrement 1 row, to set cursor Y on the last line
 621+ 07B5 AF           SETCRSRY:       xor     A               ; then set cursor X to 0 (go to beginning of line)
 622+ 07B6 32 D2 81     SETCSRCOORDS:   ld      (SCR_CURS_X),A  ; store current cursor X
 623+ 07B9 7B                           ld      A,E             ; recover Y
 624+ 07BA 32 D3 81                     ld      (SCR_CURS_Y),A  ; store current cursor Y
 625+ 07BD CD D7 06                     call    POS_CURSOR      ; position cursor into new location
 626+ 07C0 3A BD 81                     ld      A,(TMRCNT)      ; load status of cursor flashing
 627+ 07C3 E6 20                        and     $20             ; check cursor state
 628+ 07C5 32 D8 81                     ld      (LSTCSRSTA),A   ; store the last cursor state
 629+ 07C8 AF           EXITCHAR2VID:   xor     A               ; reset char
 630+ 07C9 32 DA 81                     ld      (CHR4VID),A     ; to be sent to screen
 631+ 07CC F1                           pop     AF              ; recover cursor state
 632+ 07CD A7                           and     A               ; was it off (A=0)?
 633+ 07CE C4 38 09                     call    NZ,CURSOR_ON    ; no, set cursor on
 634+ 07D1 E1                           pop     HL              ; restore HL
 635+ 07D2 D1                           pop     DE              ; restore DE
 636+ 07D3 C1                           pop     BC              ; restore BC
 637+ 07D4 F1                           pop     AF              ; restore AF
 638+ 07D5 C9           PLACEHOLDER:    ret                     ; return to caller
 639+ 07D6
 640+ 07D6              ; flash the cursor at the current position
 641+ 07D6              ; (this sub-routine is called by CH3 timer ISR)
 642+ 07D6 3A D7 81     FLASHCURSOR:    ld      A,(CRSR_STATE)  ; now, check the cursor
 643+ 07D9 A7                           and     A               ; cursor off (A=0)?
 644+ 07DA C8                           ret     Z               ; yes, return
 645+ 07DB 3A BD 81                     ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
 646+ 07DE E6 20                        and     $20             ; check if it's time to flash the cursor (check bit #6)
 647+ 07E0 21 D8 81                     ld      HL,LSTCSRSTA    ; load address of cell that stores the last cursor state
 648+ 07E3 BE                           cp      (HL)            ; compare current state with last state
 649+ 07E4 C8                           ret     Z               ; same state, no change required - exit
 650+ 07E5 77                           ld      (HL),A          ; save new state
 651+ 07E6 F5                           push    AF              ; store A (keep state for later use)
 652+ 07E7 CD 1A 07                     call    LOAD_CRSR_POS   ; load current cursor position into HL
 653+ 07EA F1                           pop     AF              ; recover current state
 654+ 07EB 06 FF                        ld      B,$FF           ; cursor char
 655+ 07ED FE 20                        cp      $20             ; is the cursor on video (A == $20)?
 656+ 07EF 28 04                        jr      Z,PUTCRSCHR     ; yes, jump over
 657+ 07F1 3A D6 81                     ld      A,(SCR_ORG_CHR) ; no, load the original char
 658+ 07F4 47                           ld      B,A             ; move char into B
 659+ 07F5 78           PUTCRSCHR:      ld      A,B             ; recover char from B
 660+ 07F6 C3 B0 06                     jp      WRITE_VIDEO_LOC ; print cursor/char at the current position & return
 661+ 07F9
 662+ 07F9
 663+ 07F9              ; insert an empty space at the current position of the cursor, moving the following text
 664+ 07F9              ; 1 cell straight
 665+ 07F9 CD 11 07     INSERTKEY:      call    RSTCHRCRS       ; restore char under the cursor
 666+ 07FC CD 1A 07                     call    LOAD_CRSR_POS   ; retrieve address of cursor cell
 667+ 07FF 22 DD 81                     ld      (CUR_POS),HL    ; store it
 668+ 0802 CD 55 0A                     call    ENDOFLN         ; find address of first free cell after the end of the text from the current cursor position - address into HL -
 669+ 0805                                                      ; DE is the address of the bottom right cell of the screen
 670+ 0805 22 E1 81                     ld      (ENDTXT),HL     ; store it
 671+ 0808 ED 4B DD 81                  ld      BC,(CUR_POS)    ; load starting address
 672+ 080C AF                           xor     A
 673+ 080D ED 42                        sbc     HL,BC           ; how many positions to move?
 674+ 080F CA E7 06                     jp      Z,MOVSHOWCRS    ; none - leave and re-place cursor
 675+ 0812 44 4D                        ld      BC,HL           ; number of chars to scroll into BC
 676+ 0814 2A E1 81                     ld      HL,(ENDTXT)     ; load address of the end of text
 677+ 0817 2B           CHKHL:          dec     HL              ; decrement to find the address of the char to move
 678+ 0818 E5                           push    HL
 679+ 0819 CD 04 40                     call    CMP16           ; is it the last cell (bottom right) of screen?
 680+ 081C E1                           pop     HL
 681+ 081D D2 28 08                     jp      NC,NXTINST      ; yes, so jump over - nothing to do
 682+ 0820 CD 9B 06                     call    READ_VIDEO_LOC  ; no, so read current char
 683+ 0823 23                           inc     HL              ; next cell
 684+ 0824 CD B0 06                     call    WRITE_VIDEO_LOC ; write into new position
 685+ 0827 2B                           dec     HL              ; decrement to old position
 686+ 0828 0B           NXTINST:        dec     BC              ; decrement number of chars to move
 687+ 0829 79                           ld      A,C
 688+ 082A B0                           or      B               ; finished?
 689+ 082B 20 EA                        jr      NZ,CHKHL        ; no, repeat
 690+ 082D 3E 20        ENDINSRT:       ld      A,SPC           ; load SPACE character
 691+ 082F 2A DD 81                     ld      HL,(CUR_POS)    ; get cursor position
 692+ 0832 32 D6 81                     ld      (SCR_ORG_CHR),A ; reset original char under the cursor
 693+ 0835 CD B0 06                     call    WRITE_VIDEO_LOC ; empty current video location
 694+ 0838 C3 E7 06                     jp      MOVSHOWCRS      ; re-place cursor
 695+ 083B
 696+ 083B              ; delete the char at the left of the cursor
 697+ 083B CD 11 07     BACKSPACE:      call    RSTCHRCRS       ; restore char
 698+ 083E 2A D0 81                     ld      HL,(SCR_NAM_TB) ; address of origin of screen (location 0,0)
 699+ 0841 44 4D                        ld      BC,HL           ; store into BC
 700+ 0843 CD 1A 07                     call    LOAD_CRSR_POS   ; load address of current cursor pos.
 701+ 0846 54 5D                        ld      DE,HL           ; copy into DE
 702+ 0848 AF                           xor     A               ; reset Carry
 703+ 0849 ED 42                        sbc     HL,BC           ; check how many chars between
 704+ 084B CA 75 08                     jp      Z,LVBKSP        ; none, so we are at the top left corner
 705+ 084E ED 53 DD 81                  ld      (CUR_POS),DE    ; store current cursor position
 706+ 0852 CD 55 0A                     call    ENDOFLN         ; check end of text
 707+ 0855 ED 5B DD 81                  ld      DE,(CUR_POS)    ; retrieve cursor position
 708+ 0859 AF                           xor     A               ; reset Carry
 709+ 085A ED 52                        sbc     HL,DE           ; check if none follows
 710+ 085C CA 75 08                     jp      Z,LVBKSP        ; no chars follow, so simply move the cursor
 711+ 085F 44 4D                        ld      BC,HL           ; save numbers of chars to move
 712+ 0861 EB                           ex      DE,HL           ; copy starting position into HL
 713+ 0862 CD 9B 06     MVBKSP:         call    READ_VIDEO_LOC  ; read char
 714+ 0865 2B                           dec     HL              ; 1 position to left
 715+ 0866 CD B0 06                     call    WRITE_VIDEO_LOC ; write char
 716+ 0869 23                           inc     HL              ; goto next char to copy (2 steps to right)
 717+ 086A 23                           inc     HL
 718+ 086B 0B                           dec     BC              ; decrement # of chars
 719+ 086C 79                           ld      A,C
 720+ 086D B0                           or      B               ; 0 chars?
 721+ 086E 20 F2                        jr      NZ,MVBKSP       ; not finished, continue
 722+ 0870 2B                           dec     HL
 723+ 0871 AF                           xor     A
 724+ 0872 CD B0 06                     call    WRITE_VIDEO_LOC ; reset last char
 725+ 0875 CD A7 08     LVBKSP:         call    MVCRS2LFT       ; move cursor to new position
 726+ 0878 CD FC 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 727+ 087B C3 E7 06                     jp      MOVSHOWCRS      ; move cursor to the new location and set it ON
 728+ 087E
 729+ 087E
 730+ 087E              ; move cursor to left
 731+ 087E F5           CURSORLEFT:     push    AF              ; store A
 732+ 087F 3A D2 81                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 733+ 0882 A7                           and     A               ; is it at the most left of the screen (X=0)?
 734+ 0883 28 0C                        jr      Z,CHCKYPOS      ; yes, check Y position
 735+ 0885 3D                           dec     A               ; no, decrement X
 736+ 0886 32 D4 81                     ld      (SCR_CUR_NX),A  ; store new X
 737+ 0889 3A D3 81                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 738+ 088C 32 D5 81                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 739+ 088F 18 11                        jr      CONTCRSLFT      ; go on moving cursor
 740+ 0891 3A D3 81     CHCKYPOS:       ld      A,(SCR_CURS_Y)  ; load cursor Y
 741+ 0894 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 742+ 0895 28 0E                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 743+ 0897 3D                           dec     A               ; no, decrement Y
 744+ 0898 32 D5 81                     ld      (SCR_CUR_NY),A  ; store new Y
 745+ 089B 3A CD 81                     ld      A,(SCR_SIZE_W)  ; load current screen width
 746+ 089E 3D                           dec     A               ; cursor to the most right position (width-0)
 747+ 089F 32 D4 81                     ld      (SCR_CUR_NX),A  ; set new cursor X
 748+ 08A2 CD E1 06     CONTCRSLFT:     call    MOVCRS          ; move cursor into new position
 749+ 08A5 F1           EXITCURSORLEFT: pop     AF              ; restore A
 750+ 08A6 C9                           ret                     ; return to caller
 751+ 08A7
 752+ 08A7              ; move cursor 1 position to the left
 753+ 08A7 3A D2 81     MVCRS2LFT:      ld      A,(SCR_CURS_X)  ; load cursor X into A
 754+ 08AA A7                           and     A               ; is it at the most left of the screen (X=0)?
 755+ 08AB 28 0B                        jr      Z,CHKYPOS       ; yes, check Y position
 756+ 08AD 3D                           dec     A               ; no, decrement X
 757+ 08AE 32 D4 81                     ld      (SCR_CUR_NX),A  ; store new X
 758+ 08B1 3A D3 81                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 759+ 08B4 32 D5 81                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 760+ 08B7 C9                           ret                     ; go on moving cursor
 761+ 08B8 3A D3 81     CHKYPOS:        ld      A,(SCR_CURS_Y)  ; load cursor Y
 762+ 08BB A7                           and     A               ; is it at the most top of the screen (Y=0)?
 763+ 08BC 28 E7                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 764+ 08BE 3D                           dec     A               ; no, decrement Y
 765+ 08BF 32 D5 81                     ld      (SCR_CUR_NY),A  ; store new Y
 766+ 08C2 3A CD 81                     ld      A,(SCR_SIZE_W)  ; load current screen width
 767+ 08C5 3D                           dec     A               ; cursor to the most right position (width-1)
 768+ 08C6 32 D4 81                     ld      (SCR_CUR_NX),A  ; set new cursor X
 769+ 08C9 C9                           ret                     ; return to caller
 770+ 08CA
 771+ 08CA              ; move cursor up
 772+ 08CA F5           CURSORUP:       push    AF              ; store A
 773+ 08CB 3A D3 81                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 774+ 08CE A7                           and     A               ; is it at the most top of the screen (Y=0)?
 775+ 08CF 28 10                        jr      Z,EXITCURSORUP  ; yes, exit doing nothing
 776+ 08D1 3D                           dec     A               ; no, decrement Y
 777+ 08D2 32 D5 81                     ld      (SCR_CUR_NY),A  ; store new Y
 778+ 08D5 3A D2 81                     ld      A,(SCR_CURS_X)  ; load current cursor X
 779+ 08D8 32 D4 81                     ld      (SCR_CUR_NX),A  ; set new cursor X
 780+ 08DB CD 11 07                     call    RSTCHRCRS       ; restore char under the cursor and print it
 781+ 08DE CD E1 06                     call    MOVCRS          ; move cursor into new position
 782+ 08E1 F1           EXITCURSORUP:   pop     AF              ; restore A
 783+ 08E2 C9                           ret                     ; return to caller
 784+ 08E3
 785+ 08E3
 786+ 08E3              ; move cursor to right
 787+ 08E3 F5           CURSORRIGHT:    push    AF              ; store A
 788+ 08E4 C5                           push    BC              ; store B
 789+ 08E5 3A CD 81                     ld      A,(SCR_SIZE_W)  ; load current screen width (in text modes it's 32 or 40)
 790+ 08E8 3D                           dec     A               ; decrement it (most right can only be 31 or 39)
 791+ 08E9 47                           ld      B,A             ; move A into B
 792+ 08EA 3A D2 81                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 793+ 08ED B8                           cp      B               ; is cursor at the most right position on the screen?
 794+ 08EE 30 0C                        jr      NC,CHCKYPOS2    ; yes, so jump to check Y position
 795+ 08F0 3C                           inc     A               ; no, so increment X
 796+ 08F1 32 D4 81                     ld      (SCR_CUR_NX),A  ; store new X
 797+ 08F4 3A D3 81                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 798+ 08F7 32 D5 81                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 799+ 08FA 18 13                        jr      CONTCRSRGT      ; go on moving cursor
 800+ 08FC 3A CE 81     CHCKYPOS2:      ld      A,(SCR_SIZE_H)  ; load screen height
 801+ 08FF 3D                           dec     A               ; decrement it (last row can only be 23)
 802+ 0900 47                           ld      B,A             ; move bottom into B
 803+ 0901 3A D3 81                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 804+ 0904 B8                           cp      B               ; is the cursor at the bottom of the screen?
 805+ 0905 30 0E                        jr      NC,EXITCURSORRGHT; yes, exit doing nothing
 806+ 0907 3C                           inc     A               ; no, increment Y
 807+ 0908 32 D5 81                     ld      (SCR_CUR_NY),A  ; store new Y
 808+ 090B AF                           xor     A               ; move cursor to top left
 809+ 090C 32 D4 81                     ld      (SCR_CUR_NX),A  ; store new X
 810+ 090F CD 11 07     CONTCRSRGT:     call    RSTCHRCRS       ; restore char under the cursor and print it
 811+ 0912 CD E1 06                     call    MOVCRS          ; move cursor into new position
 812+ 0915 C1           EXITCURSORRGHT: pop     BC              ; retrieve BC
 813+ 0916 F1                           pop     AF              ; restore A
 814+ 0917 C9                           ret                     ; return to caller
 815+ 0918
 816+ 0918
 817+ 0918              ; move cursor down
 818+ 0918 F5           CURSORDOWN:     push    AF              ; store A
 819+ 0919 C5                           push    BC              ; store B
 820+ 091A 3A CE 81                     ld      A,(SCR_SIZE_H)  ; load current screen height (in text modes it's 24)
 821+ 091D 3D                           dec     A               ; decrement it (positions can only vary between 0 and 23)
 822+ 091E 47                           ld      B,A             ; move X into B
 823+ 091F 3A D3 81                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 824+ 0922 B8                           cp      B               ; is current cursor position < 23?
 825+ 0923 30 10                        jr      NC,EXITCURSORDOWN; no, exit doing nothing
 826+ 0925 3C                           inc     A               ; yes, increment Y
 827+ 0926 32 D5 81                     ld      (SCR_CUR_NY),A  ; store new Y
 828+ 0929 3A D2 81                     ld      A,(SCR_CURS_X)  ; load current cursor X
 829+ 092C 32 D4 81                     ld      (SCR_CUR_NX),A  ; set new cursor X
 830+ 092F CD 11 07                     call    RSTCHRCRS       ; restore char under the cursor and print it
 831+ 0932 CD E1 06                     call    MOVCRS          ; move cursor into new position
 832+ 0935 C1           EXITCURSORDOWN: pop     BC              ; retrieve BC
 833+ 0936 F1                           pop     AF              ; retrieve A
 834+ 0937 C9                           ret                     ; return to caller
 835+ 0938
 836+ 0938
 837+ 0938              ; set cursor on (visible on screen)
 838+ 0938 F5           CURSOR_ON:      push    AF              ; store AF
 839+ 0939 3A D7 81                     ld      A,(CRSR_STATE)  ; load cursor state
 840+ 093C B7                           or      A               ; is it on?
 841+ 093D 20 0C                        jr      NZ,EXITCURSOR_ON; yes, so nothing to do
 842+ 093F 3A CE 81                     ld      A,(SCR_SIZE_H)  ; check the video mode
 843+ 0942 FE 30                        cp      $30             ; graphics 2 or 3 (if value>=48)?
 844+ 0944 30 05                        jr      NC,EXITCURSOR_ON; yes, so exit (no cursor in graphics 2 or 3)
 845+ 0946 3E 01                        ld      A,$01           ; cursor state ON
 846+ 0948 32 D7 81                     ld      (CRSR_STATE),A  ; set state
 847+ 094B F1           EXITCURSOR_ON:  pop     AF              ; restore AF
 848+ 094C C9                           ret                     ; return to caller
 849+ 094D
 850+ 094D              ; set cursor off (invisible on screen)
 851+ 094D F5           CURSOR_OFF:     push    AF              ; store AF
 852+ 094E AF                           xor     A               ; cursor state OFF
 853+ 094F 32 D7 81                     ld      (CRSR_STATE),A  ; set state
 854+ 0952 F1                           pop     AF              ; restore AF
 855+ 0953 C9                           ret
 856+ 0954
 857+ 0954              ; scroll the screen 1 row up
 858+ 0954 AF           SCROLLUP:       xor     A               ; reset A
 859+ 0955 57                           ld      D,A             ; reset D
 860+ 0956 32 D9 81                     ld      (PRNTVIDEO),A   ; no print on screen while scrolling
 861+ 0959 2A D0 81                     ld      HL,(SCR_NAM_TB) ; start address of the name table
 862+ 095C 22 0D 82                     ld      (VIDTMP1),HL    ; store address of the destination row (1st row of the screen)
 863+ 095F 3A CD 81                     ld      A,(SCR_SIZE_W)  ; load the screen width
 864+ 0962 5F                           ld      E,A             ; move width into E
 865+ 0963 19                           add     HL,DE           ; HL now contains the address of the source row (2nd row of the screen)
 866+ 0964 22 0F 82                     ld      (VIDTMP2),HL    ; store address of source row
 867+ 0967 3A CE 81                     ld      A,(SCR_SIZE_H)  ; load the screen height
 868+ 096A 3D                           dec     A               ; decrement the # of rows: now, A contains the # of rows to be moved
 869+ 096B 47                           ld      B,A             ; move # of rows into B
 870+ 096C 3A CD 81     SCROLLNXTRW:    ld      A,(SCR_SIZE_W)  ; (re)load the screen width
 871+ 096F 5F                           ld      E,A             ; move width into E
 872+ 0970 2A 0F 82                     ld      HL,(VIDTMP2)    ; load source address
 873+ 0973 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 874+ 0975 ED 69                        out     (C),L           ; low byte of source
 875+ 0977 ED 61                        out     (C),H           ; high byte of source
 876+ 0979 21 E5 81                     ld      HL,VIDEOBUFF    ; load address of the first cell of the video buffer
 877+ 097C 0E 30                        ld      C,VDP_DAT              ; VDP data mode
 878+ 097E ~                            LM64K_NOP               ; added to compensate shorter instruction
 879+ 097E ED 78        LOADNEXTCOL:    in      A,(C)           ; load char
 880+ 0980 77                           ld      (HL),A          ; store char
 881+ 0981 23                           inc     HL              ; next cell of the buffer
 882+ 0982 1D                           dec     E               ; count the chars to be read
 883+ 0983 20 F9                        jr      NZ,LOADNEXTCOL  ; repeat until we read the entire row
 884+ 0985 3A CD 81                     ld      A,(SCR_SIZE_W)  ; reload the screen width
 885+ 0988 5F                           ld      E,A             ; move # of rows into E
 886+ 0989 16 00                        ld      D,$00           ; reset D
 887+ 098B 2A 0D 82                     ld      HL,(VIDTMP1)    ; load address of destination row
 888+ 098E E5                           push    HL              ; store HL
 889+ 098F 2A 0F 82                     ld      HL,(VIDTMP2)    ; current source will be..
 890+ 0992 22 0D 82                     ld      (VIDTMP1),HL    ; ..new destination
 891+ 0995 19                           add     HL,DE           ; address of new
 892+ 0996 22 0F 82                     ld      (VIDTMP2),HL    ; source row
 893+ 0999 E1                           pop     HL              ; restore address of current destination row
 894+ 099A CB F4                        set     6,H             ; writing mode
 895+ 099C 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 896+ 099E ED 69                        out     (C),L           ; low byte
 897+ 09A0 ED 61                        out     (C),H           ; high byte of address
 898+ 09A2 21 E5 81                     ld      HL,VIDEOBUFF    ; video buffer address
 899+ 09A5 0E 30                        ld      C,VDP_DAT              ; VDP data mode
 900+ 09A7 7E           WRITEBUF:       ld      A,(HL)          ; load char
 901+ 09A8 ED 79                        out     (C),A           ; send char
 902+ 09AA 23                           inc     HL              ; increment buffer index
 903+ 09AB 1D                           dec     E               ; next row
 904+ 09AC 20 F9                        jr      NZ,WRITEBUF     ; repeat until 0
 905+ 09AE 10 BC                        djnz    SCROLLNXTRW     ; repeat for the entire screen
 906+ 09B0 3A CD 81                     ld      A,(SCR_SIZE_W)  ; reload screen width
 907+ 09B3 47                           ld      B,A             ; cells to empty into B
 908+ 09B4 AF                           xor     A               ; null char
 909+ 09B5 0E 32                        ld      C,VDP_SET       ; VDP set mode
 910+ 09B7 2A 0D 82                     ld      HL,(VIDTMP1)    ; load address of the last row
 911+ 09BA CB F4                        set     6,H             ; writing mode
 912+ 09BC ED 69                        out     (C),L           ; low byte then..
 913+ 09BE ED 61                        out     (C),H           ; high byte of address
 914+ 09C0 0E 30                        ld      C,VDP_DAT              ; VDP data mode
 915+ 09C2 ~                            LM64K_NOP               ; delay
 916+ 09C2 ED 79        RPTEMPTYROW:    out     (C),A           ; empty cell
 917+ 09C4 00                           nop                     ; delay
 918+ 09C5 00                           nop
 919+ 09C6 10 FA                        djnz    RPTEMPTYROW     ; repeat until the last row has been cleaned
 920+ 09C8 3E 01                        ld      A,$01
 921+ 09CA 32 D9 81                     ld      (PRNTVIDEO),A   ; set print-on-video on
 922+ 09CD C9                           ret                     ; return to caller
 923+ 09CE
 924+ 09CE              ; carriage return: first, it looks for char $00 at the beginning of the line (look for the first null char),
 925+ 09CE              ; then it starts sendind every char it finds on the screen to the terminal buffer of the BASIC interpreter
 926+ 09CE              ; until another null char is found. Finally, move to the next line and position the cursor at the beginning
 927+ 09CE              ; of the row (equivalent to CR+LF), then gets back control to the screen editor to let it interpret the line
 928+ 09CE              CUR_POS         equ     TMPBFR1         ; cursor position
 929+ 09CE              SRTTXT          equ     TMPBFR2         ; start of text line
 930+ 09CE              ENDTXT          equ     TMPBFR3         ; end of text line
 931+ 09CE              CRGRETURN:      ; preliminary: disable cursor if on, and retrieve char under it
 932+ 09CE 3A D7 81                     ld      A,(CRSR_STATE)  ; recover cursor state
 933+ 09D1 32 E3 81                     ld      (TMPBFR4),A     ; store status
 934+ 09D4 A7                           and     A               ; is cursor on?
 935+ 09D5 C4 4D 09                     call    NZ,CURSOR_OFF   ; yes, so set cursor off
 936+ 09D8 CD 11 07                     call    RSTCHRCRS       ; restore char under it
 937+ 09DB                              ; first, check if cursor if off, so that we just interpret return as a new line command
 938+ 09DB 3A 17 82                     ld      A,(KBDNPT)      ; check if input from keyboad
 939+ 09DE A7                           and     A               ; if 0, input is not from keyboard...
 940+ 09DF CA 34 0A                     jp      Z,PRNTRETURN    ; ...so just print a carriage return; otherwise, interpret the return
 941+ 09E2                              ; first part: look for the beginning of the text line on screen
 942+ 09E2 CD 1A 07                     call    LOAD_CRSR_POS   ; load cursor position into HL
 943+ 09E5 22 DD 81                     ld      (CUR_POS),HL    ; store it
 944+ 09E8 ED 5B D0 81                  ld      DE,(SCR_NAM_TB) ; load VRAM address of top-left cell of screen ("home")
 945+ 09EC E5           RPTNLLSRC:      push    HL
 946+ 09ED CD 04 40                     call    CMP16           ; check if at "home"
 947+ 09F0 E1                           pop     HL
 948+ 09F1 CA FC 09                     jp      Z,CNTNULL       ; yes, exit because there is nothing before
 949+ 09F4 2B                           dec     HL              ; go 1 step back
 950+ 09F5 CD 9B 06                     call    READ_VIDEO_LOC  ; read char of current position
 951+ 09F8 A7                           and     A               ; is it $00 (null char)?
 952+ 09F9 20 F1                        jr      NZ,RPTNLLSRC    ; no, continue searching
 953+ 09FB 23                           inc     HL              ; move 1 step forward to go back to the last cell with something in
 954+ 09FC                              ; second part: look for the ending of the text on screen
 955+ 09FC 22 DF 81     CNTNULL:        ld      (SRTTXT),HL     ; store beginning of text
 956+ 09FF CD 55 0A                     call    ENDOFLN         ; find end of text line looking at the end of chars after the cursor position
 957+ 0A02 22 E1 81                     ld      (ENDTXT),HL     ; store ending of text line
 958+ 0A05 ED 5B DF 81                  ld      DE,(SRTTXT)     ; load beginning of text line
 959+ 0A09 A7                           and     A               ; clear Carry
 960+ 0A0A ED 52                        sbc     HL,DE           ; how many chars?
 961+ 0A0C 28 26                        jr      Z,PRNTRETURN    ; no chars found (HL-DE=0), so just print return & leave
 962+ 0A0E                              ;---    central part: send the text on the screen to the interpreter
 963+ 0A0E 2A DF 81                     ld      HL,(SRTTXT)     ; load beginning of text line
 964+ 0A11 ED 5B E1 81                  ld      DE,(ENDTXT)     ; load ending of text line
 965+ 0A15 CD 9B 06     SNDCHRTOBFR:    call    READ_VIDEO_LOC  ; read char
 966+ 0A18 E5                           push    HL
 967+ 0A19 CD FD 01                     call    CHARINTOBFR     ; send char to buffer
 968+ 0A1C E1                           pop     HL
 969+ 0A1D 23                           inc     HL              ; go to next char
 970+ 0A1E E5                           push    HL              ; store HL
 971+ 0A1F CD 04 40                     call    CMP16           ; check if DE=HL (finish chars)
 972+ 0A22 E1                           pop     HL
 973+ 0A23 20 F0                        jr      NZ,SNDCHRTOBFR  ; no, repeat
 974+ 0A25 3E 0D                        ld      A,CR            ; yes, so now send carriage return
 975+ 0A27 CD FD 01                     call    CHARINTOBFR     ; send to buffer
 976+ 0A2A 2A E1 81                     ld      HL,(ENDTXT)     ; recover address of last char of input text
 977+ 0A2D CD 3D 07                     call    HL2XY           ; retrieve X,Y from address
 978+ 0A30 7D                           ld      A,L             ; move Y into A (we don't need X anymore)
 979+ 0A31 32 D3 81                     ld      (SCR_CURS_Y),A  ; store new Y
 980+ 0A34                              ;---    final part: go at the beginning of a new line on the screen
 981+ 0A34 AF           PRNTRETURN:     xor     A               ; move to col 0
 982+ 0A35 32 D2 81                     ld      (SCR_CURS_X),A  ; store new X
 983+ 0A38 3A D3 81                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 984+ 0A3B 3C                           inc     A               ; new row
 985+ 0A3C 21 CE 81                     ld      HL,SCR_SIZE_H   ; load address of cell that keeps screen height
 986+ 0A3F BE                           cp      (HL)            ; is the cursor over the bottom of the screen?
 987+ 0A40 38 06                        jr      C,ADDNEWLINE    ; no, jump over
 988+ 0A42 3D                           dec     A               ; yes, so come back 1 row, then...
 989+ 0A43 F5                           push    AF              ; (store A)
 990+ 0A44 CD 54 09                     call    SCROLLUP        ; ...scroll the screen before to...
 991+ 0A47 F1                           pop     AF              ; (retrieve A)
 992+ 0A48 32 D3 81     ADDNEWLINE:     ld      (SCR_CURS_Y),A  ; ...store new Y
 993+ 0A4B 3A E3 81                     ld      A,(TMPBFR4)     ; retrieve cursor state
 994+ 0A4E A7                           and     A               ; was it off (A=0)?
 995+ 0A4F C4 38 09                     call    NZ,CURSOR_ON    ; no, set cursor on
 996+ 0A52 C3 D7 06                     jp      POS_CURSOR      ; position cursor to new location & return to caller
 997+ 0A55
 998+ 0A55              ; find end of text line
 999+ 0A55              ; destroys A, DE, and HL - store address of last char of text line into HL,
1000+ 0A55              ; while DE contains the address of the bottom right cell of the screen
1001+ 0A55 3A CE 81     ENDOFLN:        ld      A,(SCR_SIZE_H)
1002+ 0A58 5F                           ld      E,A             ; load screen height into DE
1003+ 0A59 3A CD 81                     ld      A,(SCR_SIZE_W)
1004+ 0A5C 6F                           ld      L,A             ; load screen width into HL
1005+ 0A5D AF                           xor     A
1006+ 0A5E 67                           ld      H,A
1007+ 0A5F 57                           ld      D,A
1008+ 0A60 CD 0F 40                     call    MUL16           ; multiply HL times DE to get the screen size
1009+ 0A63 ED 5B D0 81                  ld      DE,(SCR_NAM_TB) ; load screen name table start address into DE
1010+ 0A67 19                           add     HL,DE           ; get the address...
1011+ 0A68 2B                           dec     HL              ; ...of the "last" video cell
1012+ 0A69 EB                           ex      DE,HL           ; store address into DE
1013+ 0A6A 2A DD 81                     ld      HL,(CUR_POS)    ; retrieve original cursor position
1014+ 0A6D E5           RPTNLLSRC2:     push    HL
1015+ 0A6E CD 04 40                     call    CMP16           ; check if at last position on screen (bottom right corner)
1016+ 0A71 E1                           pop     HL
1017+ 0A72 C8                           ret     Z               ; if yes, exit because these is nothing after
1018+ 0A73 23                           inc     HL              ; 1 more step forward
1019+ 0A74 CD 9B 06                     call    READ_VIDEO_LOC  ; read char of current position
1020+ 0A77 A7                           and     A               ; is it $00 (null char)?
1021+ 0A78 20 F3                        jr      NZ,RPTNLLSRC2   ; no, continue searching
1022+ 0A7A C9           CNTNULL2:       ret                     ; yes: found end of text, return to caller
1023+ 0A7B
1024+ 0A7B
1025+ 0A7B              ; ------------------------------------------------------------------------------
1026+ 0A7B                              ; this table contains the values of the offsets to be added to
1027+ 0A7B                              ; the starting address of the name table to find the correct
1028+ 0A7B                              ; value of the first cell of the corresponding row
1029+ 0A7B                              ; (by doing so, it's faster than doing a multipication)
1030+ 0A7B                              ; table for graphics 1 text mode: 32 cols
1031+ 0A7B 00 00 20 00  POS_TB_CRS_32:  defw    $0000,$0020,$0040,$0060,$0080,$00A0,$00C0,$00E0
1031+ 0A7F 40 00 60 00
1031+ 0A83 80 00 A0 00
1031+ 0A87 C0 00 E0 00
1032+ 0A8B 00 01 20 01                  defw    $0100,$0120,$0140,$0160,$0180,$01A0,$01C0,$01E0
1032+ 0A8F 40 01 60 01
1032+ 0A93 80 01 A0 01
1032+ 0A97 C0 01 E0 01
1033+ 0A9B 00 02 20 02                  defw    $0200,$0220,$0240,$0260,$0280,$02A0,$02C0,$02E0
1033+ 0A9F 40 02 60 02
1033+ 0AA3 80 02 A0 02
1033+ 0AA7 C0 02 E0 02
1034+ 0AAB                              ; table for pure text mode: 40 cols
1035+ 0AAB 00 00 28 00  POS_TB_CRS_40:  defw    $0000,$0028,$0050,$0078,$00A0,$00C8,$00F0,$0118
1035+ 0AAF 50 00 78 00
1035+ 0AB3 A0 00 C8 00
1035+ 0AB7 F0 00 18 01
1036+ 0ABB 40 01 68 01                  defw    $0140,$0168,$0190,$01B8,$01E0,$0208,$0230,$0258
1036+ 0ABF 90 01 B8 01
1036+ 0AC3 E0 01 08 02
1036+ 0AC7 30 02 58 02
1037+ 0ACB 80 02 A8 02                  defw    $0280,$02A8,$02D0,$02F8,$0320,$0348,$0370,$0398
1037+ 0ACF D0 02 F8 02
1037+ 0AD3 20 03 48 03
1037+ 0AD7 70 03 98 03
1038+ 0ADB
1039+ 0ADB              ; ------------------------------------------------------------------------------
1040+ 0ADB              ; reset VRAM
1041+ 0ADB AF           EMPTY_VRAM:     xor     A               ; reg.A cleared: we fill up VRAM with $00
1042+ 0ADC 67                           ld      H,A
1043+ 0ADD 6F                           ld      L,A             ; reset HL
1044+ 0ADE CD 7B 06                     call    SETVDPADRS      ; set address of first VRAM cell to $0000
1045+ 0AE1 06 40                        ld      B,$40           ; $40 pages of RAM...
1046+ 0AE3 57                           ld      D,A             ; ...each one with $100 cells (tot. $4000 bytes)
1047+ 0AE4 0E 30                        ld      C,VDP_DAT              ; VDP data mode
1048+ 0AE6 ED 79        EMPTVRM:        out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
1049+ 0AE8 14                           inc     D               ; next cell
1050+ 0AE9 00                           nop
1051+ 0AEA 20 FA                        jr      NZ,EMPTVRM      ; repeat until page is fully cleared
1052+ 0AEC 10 F8                        djnz    EMPTVRM         ; repeat for $40 pages
1053+ 0AEE C9                           ret                     ; return to caller
1054+ 0AEF
1055+ 0AEF              ; clear video registers in SRAM
1056+ 0AEF 21 CD 81     CLR_RAM_REG:    ld      HL,SCR_SIZE_W   ; address of first register
1057+ 0AF2 AF                           xor     A               ; $00 to clean the registers
1058+ 0AF3 06 44                        ld      B,CHASNDDTN-SCR_SIZE_W; how many bytes (registers) to clean (dinamically calculated)
1059+ 0AF5 77           RSTVDPRAMREG:   ld      (HL),A          ; reset register
1060+ 0AF6 23                           inc     HL              ; next register
1061+ 0AF7 10 FC                        djnz    RSTVDPRAMREG    ; repeat
1062+ 0AF9 C9                           ret                     ; return to caller
1063+ 0AFA
1064+ 0AFA              ; ------------------------------------------------------------------------------
1065+ 0AFA              ; set a specific graphics mode, passed into reg. E
1066+ 0AFA 06 08        SET_GFX_MODE:   ld      B,$08           ; 8 registers means 8 bytes..
1067+ 0AFC CB 23                        sla     E               ; multiply E by 8..
1068+ 0AFE CB 23                        sla     E               ; so that reg. E can point..
1069+ 0B00 CB 23                        sla     E               ; to the correct settings
1070+ 0B02 16 00        SET_GFX_MODE2:  ld      D,$00           ; reset D
1071+ 0B04 21 37 0B                     ld      HL,VDPMODESET   ; pointer to register settings | <= here points the SHOW_LOGO sub-routine
1072+ 0B07 19                           add     HL,DE           ; add offset to get the correct set of values for the required mode
1073+ 0B08 3E 80                        ld      A,$80           ; start with REG0 ($80+register number)
1074+ 0B0A 0E 32                        ld      C,VDP_SET       ; VDP set
1075+ 0B0C 56           LDREGVLS:       ld      D,(HL)          ; load register's value
1076+ 0B0D ED 51                        out     (C),D           ; send data to VDP
1077+ 0B0F ED 79                        out     (C),A           ; indicate the register to send data to
1078+ 0B11 3C                           inc     A               ; next register
1079+ 0B12 23                           inc     HL              ; next value
1080+ 0B13 10 F7                        djnz    LDREGVLS        ; repeat for 8 registers
1081+ 0B15 C9                           ret
1082+ 0B16
1083+ 0B16              ; ------------------------------------------------------------------------------
1084+ 0B16              LOADCHARSET:    ; reg. A contains the video mode
1085+ 0B16                              ; reg. HL contains address of pattern table into VRAM
1086+ 0B16 06 00                        ld      B,$00           ; 0=256 chars to load (complete charset)
1087+ 0B18 CB F4                        set     $06,H           ; add $4000 to address to indicate that we want to write into VRAM
1088+ 0B1A 0E 32                        ld      C,VDP_SET       ; load VDP address into C
1089+ 0B1C ED 69                        out     (C),L           ; send low byte of address
1090+ 0B1E ED 61                        out     (C),H           ; send high byte
1091+ 0B20 0E 30                        ld      C,VDP_DAT              ; VDP data mode
1092+ 0B22 21 67 40                     ld      HL,CHRST68      ; starting address of 6x8 charset into ROM
1093+ 0B25 A7                           and     A               ; is it text mode (A=0)?
1094+ 0B26 28 03                        jr      Z,NXTCHAR       ; yes, so jump to load chars into VRAM
1095+ 0B28 21 67 48                     ld      HL,CHRST88      ; no, so we change and load the 8x8 charset
1096+ 0B2B 16 08        NXTCHAR:        ld      D,$08           ; 8 bytes per pattern char
1097+ 0B2D 7E           SENDCHRPTRNS:   ld      A,(HL)          ; load byte to send to VDP
1098+ 0B2E ED 79                        out     (C),A           ; write byte into VRAM
1099+ 0B30 23                           inc     HL              ; inc byte pointer
1100+ 0B31 15                           dec     D               ; 8 bytes sents (0 char)?
1101+ 0B32 20 F9                        jr      NZ,SENDCHRPTRNS ; no, continue
1102+ 0B34 10 F5                        djnz    NXTCHAR         ; yes, decrement chars counter and continue for all the chars
1103+ 0B36 C9                           ret                     ; return to caller
1104+ 0B37
1105+ 0B37              ;------------------------------------------------------------------------------
1106+ 0B37              ; NAME TABLE:       buffer video - contains the chars to be shown on video
1107+ 0B37              ; PATTERN TABLE:    charset - contains the chars/tiles to be loaded into the name table
1108+ 0B37              ; COLOR TABLE:      color settings for chars/tiles
1109+ 0B37
1110+ 0B37                              ; VDP register settings for a text display
1111+ 0B37 00           VDPMODESET:     defb    %00000000       ; reg.0: external video off
1112+ 0B38 D0                           defb    %11010000       ; reg.1: 16K VRAM, video on, int. off, text mode (40x24)
1113+ 0B39 02                           defb    $02             ; reg.2: name table set to $0800 ($02x$400)
1114+ 0B3A 00                           defb    $00             ; reg.3: not used in text mode
1115+ 0B3B 00                           defb    $00             ; reg.4: pattern table set to $0000
1116+ 0B3C 00                           defb    $00             ; reg.5: not used in text mode
1117+ 0B3D 00                           defb    $00             ; reg.6: not used in text mode
1118+ 0B3E F5                           defb    $f5             ; reg.7: white text on light blue background
1119+ 0B3F
1120+ 0B3F              VDPMODESET1:    ; VDP register settings for a graphics 1 mode
1121+ 0B3F 00                           defb    %00000000       ; reg.0: ext. video off
1122+ 0B40 C0                           defb    %11000000       ; reg.1: 16K Vram; video on, int off, graphics mode 1, sprite size 8x8, sprite magn. 0
1123+ 0B41 06                           defb    $06             ; reg.2: name table address: $1800
1124+ 0B42 80                           defb    $80             ; reg.3: color table address: $2000
1125+ 0B43 00                           defb    $00             ; reg.4: pattern table address: $0000
1126+ 0B44 36                           defb    $36             ; reg.5: sprite attr. table address: $1B00
1127+ 0B45 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1128+ 0B46 05                           defb    $05             ; reg.7: backdrop color (light blue)
1129+ 0B47
1130+ 0B47              VDPMODESET2:    ; VDP register settings for a graphics 2 mode
1131+ 0B47 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1132+ 0B48 C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1133+ 0B49 06                           defb    $06             ; reg.2: name table addr.: $1800
1134+ 0B4A FF                           defb    $FF             ; reg.3: color table addr.: $2000
1135+ 0B4B 03                           defb    $03             ; reg.4: pattern table addr.: $0000
1136+ 0B4C 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1137+ 0B4D 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1138+ 0B4E 05                           defb    $05             ; reg.7: backdrop color: light blue
1139+ 0B4F
1140+ 0B4F              VDPMODESETMC:   ; VDP register settings for a multicolor mode
1141+ 0B4F 00                           defb    %00000000       ; reg.0: ext. video dis.
1142+ 0B50 CB                           defb    %11001011       ; reg.1: 16K VRAM, video on, INT off, multicolor mode, sprite size 8x8, sprite magn. 0
1143+ 0B51 02                           defb    $02             ; reg.2: name table addr.: $0800
1144+ 0B52 00                           defb    $00             ; reg.3: don't care
1145+ 0B53 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1146+ 0B54 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1147+ 0B55 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1148+ 0B56 0F                           defb    $0F             ; reg.7: backdrop color (white)
1149+ 0B57
1150+ 0B57              VDPMODESETEX2:  ; VDP register settings for an extended graphics 2 mode
1151+ 0B57 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1152+ 0B58 C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1153+ 0B59 0E                           defb    $0E             ; reg.2: name table addr.: $3800
1154+ 0B5A 9F                           defb    $9F             ; reg.3: color table addr.: $2000
1155+ 0B5B 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1156+ 0B5C 76                           defb    $76             ; reg.5: sprite attr. table addr.: $3B00
1157+ 0B5D 03                           defb    $03             ; reg.6: sprite pattern table addr.: $1800
1158+ 0B5E 05                           defb    $05             ; reg.7: backdrop color: light blue
1159+ 0B5F
1160+ 0B5F              LM80CLOGO:      ; patterns to compose the splash screen logo
1161+ 0B5F                              ; 1st band
1162+ 0B5F 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1162+ 0B63 00 00 00 00
1162+ 0B67 00 00 00 00
1162+ 0B6B 00 00 00 00
1162+ 0B6F 00 00 00 00
1162+ 0B73 00 00 00 00
1162+ 0B77 00 00 00 00
1162+ 0B7B 00 00 00 00
1163+ 0B7F 00 00 0F 0A                  defb    0,0,15,10,11,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1163+ 0B83 0B 10 00 00
1163+ 0B87 00 00 00 00
1163+ 0B8B 00 00 00 00
1163+ 0B8F 00 00 00 00
1163+ 0B93 00 00 00 00
1163+ 0B97 00 00 00 00
1163+ 0B9B 00 00 00 00
1164+ 0B9F                              ; 2nd band
1165+ 0B9F 00 00 0D 17                  defb    0,0,13,23,0,12,0,0,0,1,0,0,0,20,0,0,6,5,6,21,22,7,6,21,22,7,6,1,1,7,0,0
1165+ 0BA3 00 0C 00 00
1165+ 0BA7 00 01 00 00
1165+ 0BAB 00 14 00 00
1165+ 0BAF 06 05 06 15
1165+ 0BB3 16 07 06 15
1165+ 0BB7 16 07 06 01
1165+ 0BBB 01 07 00 00
1166+ 0BBF 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,20,6,1,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1166+ 0BC3 00 0C 00 00
1166+ 0BC7 00 01 00 00
1166+ 0BCB 00 01 14 06
1166+ 0BCF 01 05 03 05
1166+ 0BD3 03 05 03 05
1166+ 0BD7 03 05 03 05
1166+ 0BDB 03 05 00 00
1167+ 0BDF                              ; 3rd band
1168+ 0BDF 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,1,1,1,5,9,20,19,8,3,5,19,5,3,5,0,0,0,0
1168+ 0BE3 00 0C 00 00
1168+ 0BE7 00 01 00 00
1168+ 0BEB 00 01 01 01
1168+ 0BEF 01 05 09 14
1168+ 0BF3 13 08 03 05
1168+ 0BF7 13 05 03 05
1168+ 0BFB 00 00 00 00
1169+ 0BFF 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,8,3,5,6,21,22,7,3,1,22,5,3,5,0,0,0,0
1169+ 0C03 00 0C 00 00
1169+ 0C07 00 01 00 00
1169+ 0C0B 00 01 00 08
1169+ 0C0F 03 05 06 15
1169+ 0C13 16 07 03 01
1169+ 0C17 16 05 03 05
1169+ 0C1B 00 00 00 00
1170+ 0C1F                              ; 4th band
1171+ 0C1F 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,0,3,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1171+ 0C23 00 0C 00 00
1171+ 0C27 00 01 00 00
1171+ 0C2B 00 01 00 00
1171+ 0C2F 03 05 03 05
1171+ 0C33 03 05 03 05
1171+ 0C37 03 05 03 05
1171+ 0C3B 03 05 00 00
1172+ 0C3F 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,4,4,0,1,0,0,3,5,9,20,19,8,9,20,19,8,9,1,1,8,0,0
1172+ 0C43 00 0C 00 00
1172+ 0C47 00 01 04 04
1172+ 0C4B 00 01 00 00
1172+ 0C4F 03 05 09 14
1172+ 0C53 13 08 09 14
1172+ 0C57 13 08 09 01
1172+ 0C5B 01 08 00 00
1173+ 0C5F                              ; 5th band
1174+ 0C5F 00 00 0E 12                  defb    0,0,14,18,18,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1174+ 0C63 12 11 00 00
1174+ 0C67 00 00 00 00
1174+ 0C6B 00 00 00 00
1174+ 0C6F 00 00 00 00
1174+ 0C73 00 00 00 00
1174+ 0C77 00 00 00 00
1174+ 0C7B 00 00 00 00
1175+ 0C7F 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1175+ 0C83 00 00 00 00
1175+ 0C87 00 00 00 00
1175+ 0C8B 00 00 00 00
1175+ 0C8F 00 00 00 00
1175+ 0C93 00 00 00 00
1175+ 0C97 00 00 00 00
1175+ 0C9B 00 00 00 00
# file closed: ../include/vdp/vdp-1.4.asm
  74  0C9F
  75  0C9F              ; incude the latest version of the PSG module
  76  0C9F                  INCLUDE "../include/psg/psg-1.1.asm"
# file opened: ../include/psg/psg-1.1.asm
   1+ 0C9F              ; ------------------------------------------------------------------------------
   2+ 0C9F              ; LM80C - PSG ROUTINES - 1.1
   3+ 0C9F              ; ------------------------------------------------------------------------------
   4+ 0C9F              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0C9F              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0C9F              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0C9F              ; kind of warranty: you can use them at your own risk.
   8+ 0C9F              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0C9F              ; maintain the copyright notices, include this advice and the note to the
  10+ 0C9F              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0C9F              ; redistribuite them.
  12+ 0C9F              ; https://www.leonardomiliani.com
  13+ 0C9F              ;
  14+ 0C9F              ; Please support me by visiting the following links:
  15+ 0C9F              ; Main project page: https://www.leonardomiliani.com
  16+ 0C9F              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0C9F              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0C9F              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0C9F              ; ------------------------------------------------------------------------------
  20+ 0C9F              ;
  21+ 0C9F              ; ------------------------------------------------------------------------------
  22+ 0C9F
  23+ 0C9F              ;------------------------------------------------------------------------------
  24+ 0C9F
  25+ 0C9F              ; configure the PSG
  26+ 0C9F 21 11 82     initPSG:        ld      HL,CHASNDDTN    ; starting address of sound & keyboard RAM registers
  27+ 0CA2 06 0E                        ld      B,SERIALS_EN-CHASNDDTN; # of PSG sound & keyboard registers
  28+ 0CA4 AF                           xor     A               ; reset A
  29+ 0CA5 77           EMPTSNDBFR:     ld      (HL),A          ; reset RAM register
  30+ 0CA6 23                           inc     HL              ; next register
  31+ 0CA7 10 FC                        djnz    EMPTSNDBFR      ; repeat
  32+ 0CA9 06 10        CLRPSGREGS:     ld      B,$10           ; 16 registers to set
  33+ 0CAB 21 BD 0C                     ld      HL,SNDREGCFG    ; starting address of register settings
  34+ 0CAE 16 00                        ld      D,$00           ; first register
  35+ 0CB0 7A           RSTPSG:         ld      A,D             ; register value
  36+ 0CB1 CD F7 0C                     call    SETSNDREG       ; select register
  37+ 0CB4 7E                           ld      A,(HL)          ; load value
  38+ 0CB5 CD FC 0C                     call    WRTSNDREG       ; write to register
  39+ 0CB8 14                           inc     D               ; next register
  40+ 0CB9 23                           inc     HL              ; next value
  41+ 0CBA 10 F4                        djnz    RSTPSG          ; repeat for each register
  42+ 0CBC C9                           ret                     ; return to caller
  43+ 0CBD
  44+ 0CBD 00 00 00 00  SNDREGCFG:      defb $00,$00,$00,$00,$00,$00,$00,%10111111
  44+ 0CC1 00 00 00 BF
  45+ 0CC5 00 00 00 00                  defb $00,$00,$00,$00,$00,$00,$ff,$ff
  45+ 0CC9 00 00 FF FF
  46+ 0CCD                              ; reg. 7: set I/O ch.A to OUTPUT, I/O ch.B to INPUT; set noise to OFF; set audio to OFF
  47+ 0CCD
  48+ 0CCD
  49+ 0CCD              ; routine to play a welcome beep on channel C (tone 4010) and to shut it off
  50+ 0CCD 21 E7 0C     WLCMBEEP:       ld      HL,WLCBPDAT     ; data address
  51+ 0CD0 C3 D6 0C                     jp      SENDSND
  52+ 0CD3 21 EF 0C     NOBEEP:         ld      HL,NOBPDAT      ; data address
  53+ 0CD6 C5           SENDSND:        push    BC
  54+ 0CD7 06 04                        ld      B,$04           ; 4 pairs
  55+ 0CD9 7E           RPTWLCMBP:      ld      A,(HL)          ; read register #
  56+ 0CDA CD F7 0C                     call    SETSNDREG
  57+ 0CDD 23                           inc     HL              ; next cell
  58+ 0CDE 7E                           ld      A,(HL)          ; read value
  59+ 0CDF CD FC 0C                     call    WRTSNDREG
  60+ 0CE2 23                           inc     HL
  61+ 0CE3 10 F4                        djnz    RPTWLCMBP       ; repeat
  62+ 0CE5 C1                           pop     BC
  63+ 0CE6 C9                           ret                     ; return to caller
  64+ 0CE7
  65+ 0CE7 07 BB 04 56  WLCBPDAT:       defb    $07,%10111011,$04,$56,$05,$00,$0A,$0F
  65+ 0CEB 05 00 0A 0F
  66+ 0CEF 04 00 05 00  NOBPDAT:        defb    $04,$00,$05,$00,$0A,$00,$07,%10111111
  66+ 0CF3 0A 00 07 BF
  67+ 0CF7
  68+ 0CF7
  69+ 0CF7              ; select register on PSG
  70+ 0CF7 0E 40        SETSNDREG:      ld      C,PSG_REG       ; PSG register port
  71+ 0CF9 ED 79                        out     (C),A           ; set register
  72+ 0CFB C9                           ret                     ; return to caller
  73+ 0CFC
  74+ 0CFC              ; send data to PSG
  75+ 0CFC 0E 41        WRTSNDREG:      ld      C,PSG_DAT       ; PSG data port
  76+ 0CFE ED 79                        out     (C),A           ; send data
  77+ 0D00 C9                           ret                     ; return to caller
  78+ 0D01
  79+ 0D01              ; manage the sounds' duration: each time this subroutine is called, it
  80+ 0D01              ; decrements the single sound durations (measured in ms) and eventually
  81+ 0D01              ; shut off the audio channel whose counter has reached 0.
  82+ 0D01              ; (this sub-routine is called by CH3 timer ISR)
  83+ 0D01 DD E5        MNGSNDS:        push    IX              ; store IX
  84+ 0D03 DD 21 11 82                  ld      IX,CHASNDDTN    ; starting address of tones duration
  85+ 0D07 06 03                        ld      B,$03           ; 3 channels to check
  86+ 0D09 26 01                        ld      H,$01           ; mixer channels: A=>bit 1, B=>bit 2, C=>bit 3
  87+ 0D0B DD 5E 00     CHKSNDCH:       ld      E,(IX+0)        ; load LSB into E
  88+ 0D0E DD 56 01                     ld      D,(IX+1)        ; load MSB into D
  89+ 0D11 7B                           ld      A,E             ; load E into A
  90+ 0D12 B2                           or      D               ; check that DE=0
  91+ 0D13 28 31                        jr      Z,CNTCHKSND     ; yes, jump over
  92+ 0D15 1B                           dec     DE              ; no, so decrement DE
  93+ 0D16 7B                           ld      A,E             ; reload E into A...
  94+ 0D17 DD 73 00                     ld      (IX+0),E        ; store new...
  95+ 0D1A DD 72 01                     ld      (IX+1),D        ; ...duration and...
  96+ 0D1D B2                           or      D               ; ...do another check to see if DE=0
  97+ 0D1E 20 26                        jr      NZ,CNTCHKSND    ; no, so jump over
  98+ 0D20                                                      ; if yes, let's shut down the corresponding channel
  99+ 0D20                                                      ; to shut down a tone we disable it into the mixer
 100+ 0D20                                                      ; then set 0 into its tone registers
 101+ 0D20 16 07                        ld      D,$07           ; mixer register
 102+ 0D22 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 103+ 0D24 ED 51                        out     (C),D           ; set mixer register
 104+ 0D26 ED 78                        in      A,(C)           ; load current value
 105+ 0D28 B4                           or      H               ; set off the channel into the mixer (remember that 1=OFF)
 106+ 0D29 ED 51                        out     (C),D           ; select mixer register
 107+ 0D2B 0E 41                        ld      C,PSG_DAT       ; PSG data port
 108+ 0D2D ED 79                        out     (C),A           ; send new value for the mixer
 109+ 0D2F 3E 03                        ld      A,$03           ; three channels
 110+ 0D31 90                           sub     B               ; find current channel (0->A, 1->B, 2->C)
 111+ 0D32 87                           add     A,A             ; and find first register (A=>0, B=>2, C=>4)
 112+ 0D33 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 113+ 0D35 ED 79                        out     (C),A           ; select first tone register of channel
 114+ 0D37 2E 00                        ld      L,$00           ; value 0 into L
 115+ 0D39 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 116+ 0D3B ED 69                        out     (C),L           ; write 0 into register
 117+ 0D3D 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 118+ 0D3F 3C                           inc     A               ; next tone register
 119+ 0D40 ED 79                        out     (C),A           ; select second tone register of channel
 120+ 0D42 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 121+ 0D44 ED 69                        out     (C),L           ; write 0 into register
 122+ 0D46 DD 23        CNTCHKSND:      inc     IX              ; set for...
 123+ 0D48 DD 23                        inc     IX              ; ...next channel...
 124+ 0D4A CB 24                        sla     H               ; shift left H 1 bit
 125+ 0D4C 10 BD                        djnz    CHKSNDCH        ; repeat for 3 channels
 126+ 0D4E DD E1                        pop     IX              ; restore IX
 127+ 0D50 C9                           ret                     ; return to caller
 128+ 0D51
 129+ 0D51              ; read a specific row of the keyboard matrix, set by A
 130+ 0D51              ; return read into A
 131+ 0D51 C5           READKBLN:       push    BC              ; store BC
 132+ 0D52 06 0F                        ld      B,$0F           ; reg #15
 133+ 0D54 0E 40                        ld      C,PSG_REG       ; PSG register port
 134+ 0D56 ED 41                        out     (C),B           ; select reg #15
 135+ 0D58 0E 41                        ld      C,PSG_DAT       ; PSG data port
 136+ 0D5A ED 79                        out     (C),A           ; activate the row
 137+ 0D5C 06 0E                        ld      B,$0E           ; register #14 (port B)
 138+ 0D5E 0E 40                        ld      C,PSG_REG       ; PSG register port
 139+ 0D60 ED 41                        out     (C),B           ; select reg. 14 (port B)
 140+ 0D62 ED 78                        in      A,(C)           ; read register #14
 141+ 0D64 C1                           pop     BC              ; retrieve BC
 142+ 0D65 C9                           ret
 143+ 0D66
 144+ 0D66              ; read the keyboard matrix to look for a key pressure
 145+ 0D66 0E 40        KEYBOARD:       ld      C,PSG_REG       ; PSG register port
 146+ 0D68 06 07                        ld      B,$07           ; set register #7...
 147+ 0D6A ED 41                        out     (C),B           ; ...to work with
 148+ 0D6C ED 78                        in      A,(C)           ; read register #7
 149+ 0D6E CB FF                        set     7,A             ; port A set to output
 150+ 0D70 CB B7                        res     6,A             ; port B set to input
 151+ 0D72 ED 41                        out     (C),B           ; set register #7
 152+ 0D74 0E 41                        ld      C,PSG_DAT       ; PSG data port
 153+ 0D76 ED 79                        out     (C),A           ; set I/O ports w/o altering the rest of the mixer
 154+ 0D78                              ; check special keys (SHIFT/ALT/CTRL)
 155+ 0D78 3E FD                        ld      A,%11111101     ; select SHIFT row
 156+ 0D7A CD 51 0D                     call    READKBLN        ; read row
 157+ 0D7D CB 5F                        bit     3,A             ; test if SHIFT key is pressed (4th bit is reset)
 158+ 0D7F 20 05                        jr      NZ,CHECKALT     ; no, so go on
 159+ 0D81 21 1E 82                     ld      HL,CONTROLKEYS  ; control key flags
 160+ 0D84 36 01                        ld      (HL),%00000001  ; set SHIFT flag, reset CTRL & ALT flags (currently multiply control keys are NOT supported)
 161+ 0D86 3E FE        CHECKALT:       ld      A,%11111110     ; select ALT row
 162+ 0D88 CD 51 0D                     call    READKBLN        ; read ALT row
 163+ 0D8B CB 6F                        bit     5,A             ; test if ALT key is pressed (5th bit is reset)
 164+ 0D8D 20 05                        jr      NZ,CHECKCTRL    ; no, so go on
 165+ 0D8F 21 1E 82                     ld      HL,CONTROLKEYS  ; control key flags
 166+ 0D92 36 04                        ld      (HL),%00000100  ; set ALT flag, reset SHIFT & CTRL flag (currently multiply control keys are NOT supported)
 167+ 0D94 3E FE        CHECKCTRL:      ld      A,%11111110     ; select CTRL row
 168+ 0D96 CD 51 0D                     call    READKBLN        ; read CTRL row
 169+ 0D99 CB 57                        bit     2,A             ; test if CTRL key is pressed (3rd bit is reset)
 170+ 0D9B 20 05                        jr      NZ,CHECKKBD     ; no, so make a normal reading
 171+ 0D9D 21 1E 82                     ld      HL,CONTROLKEYS  ; control key flags
 172+ 0DA0 36 02                        ld      (HL),%00000010  ; set CTRL flag, reset SHIFT & ALT flags (currently multiply control keys are NOT supported)
 173+ 0DA2 06 08        CHECKKBD:       ld      B,$08           ; 8 lines
 174+ 0DA4 3E 7F                        ld      A,%01111111     ; start from the last line of the matrix
 175+ 0DA6 16 0F        RPTKBDRD:       ld      D,$0F           ; register #15 (port B)
 176+ 0DA8 0E 40                        ld      C,PSG_REG       ; PSG register port
 177+ 0DAA ED 51                        out     (C),D           ; select reg. #15
 178+ 0DAC 0E 41                        ld      C,PSG_DAT       ; PSG data port
 179+ 0DAE ED 79                        out     (C),A           ; activate 1 line (active line is grounded, i.e. with a LOW signal)
 180+ 0DB0 5F                           ld      E,A             ; save current line into E
 181+ 0DB1 16 0E                        ld      D,$0E           ; register #14 (port A)
 182+ 0DB3 0E 40                        ld      C,PSG_REG       ; PSG register port
 183+ 0DB5 ED 51                        out     (C),D           ; select reg. 14 (port A)
 184+ 0DB7 00                           nop
 185+ 0DB8 ED 78                        in      A,(C)           ; read register #14
 186+ 0DBA FE FF                        cp      $FF             ; is there any line set to 0?
 187+ 0DBC 28 2E                        jr      Z,NOKEYPRSD     ; no, go to the next row
 188+ 0DBE                              ; check control keys
 189+ 0DBE 32 18 82                     ld      (KBTMP),A       ; yes, check if a control key was pressed. First, store current row
 190+ 0DC1 78                           ld      A,B             ; copy current row (B) into A
 191+ 0DC2 FE 02                        cp      $02             ; is it the row of the SHIFT?
 192+ 0DC4 20 0F                        jr      NZ,TESTALT      ; no, continue checking the other control keys
 193+ 0DC6 3A 18 82                     ld      A,(KBTMP)       ; yes, retrieve current row data
 194+ 0DC9 CB 5F                        bit     3,A             ; check SHIFT bit line
 195+ 0DCB 20 31                        jr      NZ,FINDKEY      ; no SHIFT, continue checking
 196+ 0DCD CB DF                        set     3,A             ; yes, it's the SHIFT. So remove SHIFT bit
 197+ 0DCF FE FF                        cp      $FF             ; after deleting the SHIFT bit, is there any other bit selected?
 198+ 0DD1 20 2B                        jr      NZ,FINDKEY      ; yes, go to check which one
 199+ 0DD3 18 17                        jr      NOKEYPRSD       ; no, go to next row
 200+ 0DD5 FE 01        TESTALT:        cp      $01             ; is it the line of ALT & CTRL?
 201+ 0DD7 3A 18 82                     ld      A,(KBTMP)       ; retrieve current row data
 202+ 0DDA 20 22                        jr      NZ,FINDKEY      ; no, continue
 203+ 0DDC CB 6F                        bit     5,A             ; yes, check ALT bit line
 204+ 0DDE 20 02                        jr      NZ,TESTCTRL     ; no ALT, continue checking
 205+ 0DE0 CB EF                        set     5,A             ; yes, it's the ALT. So remove ALT bit
 206+ 0DE2 CB 57        TESTCTRL:       bit     2,A             ; check CTRL bit line
 207+ 0DE4 20 02                        jr      NZ,ENDCTRLCK    ; no CTRL, continue checking
 208+ 0DE6 CB D7                        set     2,A             ; delete CTRL bit flag
 209+ 0DE8 FE FF        ENDCTRLCK:      cp      $FF             ; after deleting the ALT & CTRL bits, is there any other bit selected?
 210+ 0DEA 20 12                        jr      NZ,FINDKEY      ; yes, go to check which one
 211+ 0DEC 7B           NOKEYPRSD:      ld      A,E             ; no key pressed, load current output port
 212+ 0DED 0F                           rrca                    ; rotate right by 1
 213+ 0DEE 10 B6                        djnz    RPTKBDRD        ; repeat for 8 lines
 214+ 0DF0 AF                           xor     A               ; if exit from here, no key has been pressed...
 215+ 0DF1 32 1A 82                     ld      (LASTKEYPRSD),A ; ...so reset the last key cell...
 216+ 0DF4 32 1E 82                     ld      (CONTROLKEYS),A ; ...reset contro key flags...
 217+ 0DF7 32 17 82                     ld      (KBDNPT),A      ; ...no input from keyboard...
 218+ 0DFA 32 1B 82                     ld      (STATUSKEY),A   ; ...no auto-repeat...
 219+ 0DFD C9                           ret                     ; ...and leave
 220+ 0DFE 1E FF        FINDKEY:        ld      E,$FF           ; counter
 221+ 0E00 1C           CHKLN:          inc     E               ; E goes from 0 to 7
 222+ 0E01 CB 3F                        srl     A               ; is the first bit reset? (we're looking for a "0", meaning grounded line)
 223+ 0E03 38 FB                        jr      C,CHKLN         ; no, check next bit
 224+ 0E05 3A 1E 82                     ld      A,(CONTROLKEYS) ; load control key flags
 225+ 0E08 21 21 0F                     ld      HL,KBMAP        ; normal keymap
 226+ 0E0B FE 01                        cp      $01             ; SHIFT flag?
 227+ 0E0D 20 05                        jr      NZ,CHKCTRL      ; no, jump over
 228+ 0E0F 21 61 0F                     ld      HL,KBMAP_SFT    ; SHIFT keymap
 229+ 0E12 18 10                        jr      LOADMAP         ; and load it
 230+ 0E14 FE 02        CHKCTRL:        cp      $02             ; CTRL flag?
 231+ 0E16 20 05                        jr      NZ,CHKALT       ; no, jump over
 232+ 0E18 21 E1 0F                     ld      HL,KBMAP_CTRL   ; CTRL map
 233+ 0E1B 18 07                        jr      LOADMAP         ; and load it
 234+ 0E1D FE 04        CHKALT:         cp      $04             ; ALT flag?
 235+ 0E1F 20 03                        jr      NZ,LOADMAP      ; no, check over
 236+ 0E21 21 A1 0F                     ld      HL,KBMAP_ALT    ; ALT map
 237+ 0E24 05           LOADMAP:        dec     B               ; decrement row # (rows go from 0 to 7)
 238+ 0E25 48                           ld      C,B             ; move B into C and...
 239+ 0E26 CB 21                        sla     C               ; ...multiply it...
 240+ 0E28 CB 21                        sla     C               ; ...by 8 to find...
 241+ 0E2A CB 21                        sla     C               ; ...the current row into the matrix
 242+ 0E2C 06 00                        ld      B,$00           ; reset B
 243+ 0E2E 09                           add     HL,BC           ; find the address of the current row
 244+ 0E2F 50                           ld      D,B             ; reset D
 245+ 0E30 19                           add     HL,DE           ; find the current column - now (HL) stores the pressed key
 246+ 0E31 3A 1A 82                     ld      A,(LASTKEYPRSD) ; load the last key pressed
 247+ 0E34 BE                           cp      (HL)            ; is it the same key?
 248+ 0E35 20 41                        jr      NZ,NEWKEY       ; no, it's a new key
 249+ 0E37 44 4D                        ld      BC,HL           ; store address of current keycode
 250+ 0E39 2A BD 81                     ld      HL,(TMRCNT)     ; load current system timer
 251+ 0E3C ED 5B 1C 82                  ld      DE,(KEYTMR)     ; load auto-repeat timer
 252+ 0E40 3A 1B 82                     ld      A,(STATUSKEY)   ; yes, load current status of auto-repeat
 253+ 0E43 FE 01                        cp      $01             ; is it initial pressure?
 254+ 0E45 20 1F                        jr      NZ,CHKAUTO      ; no, jump over
 255+ 0E47 AF                           xor     A               ; clear Carry
 256+ 0E48 ED 52                        sbc     HL,DE           ; startint time - actual time
 257+ 0E4A 16 00                        ld      D,$00           ; 64 ths/s > 640 ms
 258+ 0E4C 3A B3 80                     ld      A,(KEYDEL)
 259+ 0E4F 5F                           ld      E,A
 260+ 0E50 CD 04 40                     call    CMP16           ; time elapsed is >= $40?
 261+ 0E53 DA C8 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 262+ 0E56 3E 02        SETNEWAUTO:     ld      A,$02           ; yes set status to...
 263+ 0E58 32 1B 82                     ld      (STATUSKEY),A   ; ...auto-repeat
 264+ 0E5B 2A BD 81                     ld      HL,(TMRCNT)     ; load system timer
 265+ 0E5E 22 1C 82                     ld      (KEYTMR),HL     ; store starting time
 266+ 0E61 60 69                        ld      HL,BC           ; retrieve address of current keycode
 267+ 0E63 C3 85 0E                     jp      SENDKEY         ; send key
 268+ 0E66 AF           CHKAUTO:        xor     A               ; clear Carry
 269+ 0E67 ED 52                        sbc     HL,DE           ; computer interval between initial pressure of key and current time
 270+ 0E69 16 00                        ld      D,$00
 271+ 0E6B 3A B4 80                     ld      A,(AUTOKE)
 272+ 0E6E 5F                           ld      E,A             ; auto-repeat delay into DE
 273+ 0E6F CD 04 40                     call    CMP16           ; check if interval is greater than delay
 274+ 0E72 DA C8 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 275+ 0E75 C3 56 0E                     jp      SETNEWAUTO      ; set new loop and send key
 276+ 0E78 AF           NEWKEY:         xor     A               ; set initial state...
 277+ 0E79 3C                           inc     A               ; ...for auto-repeat...
 278+ 0E7A 32 1B 82                     ld      (STATUSKEY),A   ; ...1=pressure init
 279+ 0E7D ED 4B BD 81                  ld      BC,(TMRCNT)     ; load current system timer
 280+ 0E81 ED 43 1C 82                  ld      (KEYTMR),BC     ; set starting time
 281+ 0E85 7E           SENDKEY:        ld      A,(HL)          ; then, load key...
 282+ 0E86 32 1A 82                     ld      (LASTKEYPRSD),A ; ...store it...
 283+ 0E89 32 19 82                     ld      (TMPKEYBFR),A   ; ...insert it into the INKEY buffer...
 284+ 0E8C 32 DA 81                     ld      (CHR4VID),A     ; ...and store char for video
 285+ 0E8F FE 03                        cp      CTRLC           ; is it RUN/STOP?
 286+ 0E91 20 05                        jr      NZ,CNTKBCK      ; no, jump over
 287+ 0E93 CD FD 01                     call    CHARINTOBFR     ; yes, send directly to buffer and...
 288+ 0E96 18 30                        jr      LVKBRDCHK2      ; ...leave
 289+ 0E98 01 00 08     CNTKBCK:        ld      BC,$0800        ; 8 FN keys (B), FN key number (C)
 290+ 0E9B 21 19 0F                     ld      HL,FNKEYSORD    ; FN keys codes
 291+ 0E9E BE           CHKFNK:         cp      (HL)            ; is it an FN key?
 292+ 0E9F CA CD 0E                     jp      Z,PRNTFNKEY     ; yes, jump over
 293+ 0EA2 0C                           inc     C               ; next FN key
 294+ 0EA3 23                           inc     HL              ; next FN key code
 295+ 0EA4 10 F8                        djnz    CHKFNK          ; continue for 8 FN keys
 296+ 0EA6 3E 01        SNDKEYTOBFR:    ld      A,$01           ; normal key - set input flag
 297+ 0EA8 32 17 82                     ld      (KBDNPT),A      ; to keyboard
 298+ 0EAB 3A D9 81                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 299+ 0EAE B7                           or      A               ; is the print-on-video disabled?
 300+ 0EAF CA B8 0E                     jp      Z,PUTCHRBUF     ; yes, so send char to input buffer
 301+ 0EB2 3A D7 81                     ld      A,(CRSR_STATE)  ; check cursor state
 302+ 0EB5 B7                           or      A               ; is it 0 (cursor OFF)?
 303+ 0EB6 20 0D                        jr      NZ,PNT2VD       ; no, print on screen
 304+ 0EB8 AF           PUTCHRBUF:      xor     A
 305+ 0EB9 32 17 82                     ld      (KBDNPT),A      ; if send to input buffer, set RETURN as from BASIC
 306+ 0EBC 3A 19 82                     ld      A,(TMPKEYBFR)   ; retrieve char
 307+ 0EBF CD FD 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 308+ 0EC2 C3 C8 0E                     jp      LVKBRDCHK2      ; ...and leave
 309+ 0EC5 CD 6C 07     PNT2VD:         call    CHAR2VID        ; send char to video
 310+ 0EC8 AF           LVKBRDCHK2:     xor     A
 311+ 0EC9 32 1E 82                     ld      (CONTROLKEYS),A ; reset control key flags
 312+ 0ECC C9           LVKBRDCHK:      ret                     ; return to caller: the current key code is into TMPKEYBFR
 313+ 0ECD                              ; manage FN keys
 314+ 0ECD 57           PRNTFNKEY:      ld      D,A             ; copy A into D
 315+ 0ECE 2A AF 80                     ld      HL,(LINEAT)     ; Get current line number
 316+ 0ED1 23                           inc     HL              ; -1 means direct statement
 317+ 0ED2 7C                           ld      A,H
 318+ 0ED3 B5                           or      L
 319+ 0ED4 7A                           ld      A,D             ; retrieve char
 320+ 0ED5 20 CF                        jr      NZ,SNDKEYTOBFR  ; indirect mode - just send FN key code to buffer
 321+ 0ED7 79                           ld      A,C             ; direct mode, so print text - first, get FN key number
 322+ 0ED8 87                           add     A,A
 323+ 0ED9 87                           add     A,A
 324+ 0EDA 87                           add     A,A
 325+ 0EDB 87                           add     A,A             ; FN key number * 16
 326+ 0EDC 4F                           ld      C,A             ; move it into C
 327+ 0EDD 06 00                        ld      B,$00           ; reset B, to get offset
 328+ 0EDF 21 B5 80                     ld      HL,FNKEYS       ; load address of FN keys texts
 329+ 0EE2 09                           add     HL,BC           ; get correct text address
 330+ 0EE3 06 10                        ld      B,$10           ; 16 chars
 331+ 0EE5 7E           LDFNKEYCHR:     ld      A,(HL)          ; load char
 332+ 0EE6 A7                           and     A               ; null char?
 333+ 0EE7 CA C8 0E                     jp      Z,LVKBRDCHK2    ; yes, so leave
 334+ 0EEA 57                           ld      D,A             ; pass char into D
 335+ 0EEB 3A D9 81                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 336+ 0EEE B7                           or      A               ; is the print-on-video disabled?
 337+ 0EEF CA FF 0E                     jp      Z,PUTCHRBUF1    ; yes, so send char to input buffer
 338+ 0EF2 3A D7 81                     ld      A,(CRSR_STATE)  ; check cursor state
 339+ 0EF5 B7                           or      A               ; is it 0 (cursor OFF)?
 340+ 0EF6 C4 0C 0F                     call    NZ,PRNTFNK      ; no, print on screen
 341+ 0EF9 23           CNTFNK:         inc     HL              ; next char
 342+ 0EFA 10 E9                        djnz    LDFNKEYCHR      ; repeat for max. 16 chars
 343+ 0EFC C3 C8 0E                     jp      LVKBRDCHK2      ; leave
 344+ 0EFF AF           PUTCHRBUF1:     xor     A               ; if send to input buffer,...
 345+ 0F00 32 17 82                     ld      (KBDNPT),A      ; ...set input as from BASIC
 346+ 0F03 7A                           ld      A,D             ; retrieve char
 347+ 0F04 E5                           push    HL              ; store HL
 348+ 0F05 CD FD 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 349+ 0F08 E1                           pop     HL              ; retrieve HL
 350+ 0F09 C3 F9 0E                     jp      CNTFNK          ; repeat
 351+ 0F0C 7A           PRNTFNK:        ld      A,D             ; recover char
 352+ 0F0D 32 DA 81                     ld      (CHR4VID),A     ; store char for printing
 353+ 0F10 3E 01                        ld      A,$01           ; normal key - set input flag
 354+ 0F12 32 17 82                     ld      (KBDNPT),A      ; to keyboard
 355+ 0F15 CD 6C 07                     call    CHAR2VID        ; print on screen
 356+ 0F18 C9                           ret                     ; return to caller
 357+ 0F19
 358+ 0F19
 359+ 0F19              ;-----------------------------------------------------------------------
 360+ 0F19 01 02 04 05  FNKEYSORD:      defb 1,2,4,5,6,22,23,24                 ; order of FN Keys
 360+ 0F1D 06 16 17 18
 361+ 0F21              ;-----------------------------------------------------------------------
 362+ 0F21              ; key codes
 363+ 0F21 31 19 0E 03  KBMAP:          defb '1',25,14,3,' ',16,'q','2'         ; 25=HOME  14=CTRL  3=RUN/STOP 16=C=
 363+ 0F25 20 10 71 32
 364+ 0F29 33 77 61 14                  defb '3','w','a',20,'z','s','e','4'     ; 20=SHIFT
 364+ 0F2D 7A 73 65 34
 365+ 0F31 35 72 64 78                  defb '5','r','d','x','c','f','t','6'
 365+ 0F35 63 66 74 36
 366+ 0F39 37 79 67 76                  defb '7','y','g','v','b','h','u','8'
 366+ 0F3D 62 68 75 38
 367+ 0F41 39 69 6A 6E                  defb '9','i','j','n','m','k','o','0'
 367+ 0F45 6D 6B 6F 30
 368+ 0F49 1F 70 6C 2C                  defb 31,'p','l',',','.',':','-',30      ; 31=CURSOR DOWN  30=CURSOR UP
 368+ 0F4D 2E 3A 2D 1E
 369+ 0F51 1C 2A 3B 2F                  defb 28,'*',';','/',27,'=','+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 369+ 0F55 1B 3D 2B 1D
 370+ 0F59 08 0D FC 40                  defb 8,13,252,'@',1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 370+ 0F5D 01 02 04 18
 371+ 0F61
 372+ 0F61              ; shifted codes - not all the keys have the shifted version
 373+ 0F61 21 0C 0E 03  KBMAP_SFT:      defb '!',12,14,3,' ',16,'Q',34          ; 12=CLEAR  14=CTRL  3=RUN/STOP 16=C=   34="
 373+ 0F65 20 10 51 22
 374+ 0F69 23 57 41 14                  defb '#','W','A',20,'Z','S','E','$'     ; 20=SHIFT
 374+ 0F6D 5A 53 45 24
 375+ 0F71 25 52 44 58                  defb '%','R','D','X','C','F','T','&'
 375+ 0F75 43 46 54 26
 376+ 0F79 27 59 47 56                  defb 39,'Y','G','V','B','H','U','('     ; 39='
 376+ 0F7D 42 48 55 28
 377+ 0F81 29 49 4A 4E                  defb ')','I','J','N','M','K','O',94     ; 94=^
 377+ 0F85 4D 4B 4F 5E
 378+ 0F89 1F 50 4C 3C                  defb 31,'P','L','<','>','[','_',30      ; 31=CURSOR DOWN  30=CURSOR UP
 378+ 0F8D 3E 5B 5F 1E
 379+ 0F91 1C 2A 5D 3F                  defb 28,'*',']','?',27,198,'+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 379+ 0F95 1B C6 2B 1D
 380+ 0F99 1A 0D D3 40                  defb 26,13,211,'@',5,6,22,23            ; 26=INSERT, 211=â¬  5=F4  6=F5  22=F6  23=F7
 380+ 0F9D 05 06 16 17
 381+ 0FA1
 382+ 0FA1              ; ALT (C=) codes - not all the keys have the alt-ed version
 383+ 0FA1 31 0C 0E 03  KBMAP_ALT:      defb '1',12,14,3,' ',16,222,196         ; 12=CLEAR  14=CTRL  3=RUN/STOP  16=C=  34="
 383+ 0FA5 20 10 DE C4
 384+ 0FA9 33 DD 85 14                  defb '3',221,133,20,131,130,165,'4'     ; 20=SHIFT
 384+ 0FAD 83 82 A5 34
 385+ 0FB1 35 A2 A6 84                  defb '5',162,166,132,157,163,168,'6'
 385+ 0FB5 9D A3 A8 36
 386+ 0FB9 37 AB A9 A1                  defb '7',171,169,161,158,172,213,'8'    ;
 386+ 0FBD 9E AC D5 38
 387+ 0FC1 39 D6 D8 9F                  defb '9',214,216,159,160,215,135,195    ;
 387+ 0FC5 A0 D7 87 C3
 388+ 0FC9 1F 88 8A C1                  defb 31,136,138,193,192,123,144,30      ; 31=CURSOR DOWN  123={  30=CURSOR UP
 388+ 0FCD C0 7B 90 1E
 389+ 0FD1 1C 8F 7D FE                  defb 28,143,125,254,27,209,148,29       ; 28=CURSOR LEFT  125=}  27=ESCAPE  29=CURSOR RIGHT
 389+ 0FD5 1B D1 94 1D
 390+ 0FD9 08 0D E0 89                  defb 8,13,224,137,5,6,22,23             ; 8=DEL(backspace)  13=RETURN  252=Â£  5=F4  6=F5  22=F6  23=F7
 390+ 0FDD 05 06 16 17
 391+ 0FE1
 392+ 0FE1              ; CTRL codes - not all the keys have the control-ed version
 393+ 0FE1 31 19 0E 03  KBMAP_CTRL:     defb '1',25,14,3,' ',16,154,'2'         ; 25=HOME  14=CTRL  3=RUN/STOP  16=C=
 393+ 0FE5 20 10 9A 32
 394+ 0FE9 33 9C 95 14                  defb '3',156,149,20,152,150,153,'4'     ; 20=SHIFT
 394+ 0FED 98 96 99 34
 395+ 0FF1 35 9B B0 97                  defb '5',155,176,151,177,175,165,'6'
 395+ 0FF5 B1 AF A5 36
 396+ 0FF9 37 A6 A8 B2                  defb '7',166,168,178,179,169,167,'8'
 396+ 0FFD B3 A9 A7 38
 397+ 1001 39 B8 AA AC                  defb '9',184,170,172,171,181,164,'0'
 397+ 1005 AB B5 A4 30
 398+ 1009 1F A3 AD 2C                  defb 31,163,173,',','.',':',186,30      ; 31=CURSOR DOWN  30=CURSOR UP
 398+ 100D 2E 3A BA 1E
 399+ 1011 1C E1 3B 2F                  defb 28,225,';','/',27,212,185,29       ; 28=CURSOR LEFT  27=ESCAPE  212=Ï  29=CURSOR RIGHT
 399+ 1015 1B D4 B9 1D
 400+ 1019 08 0D BD A2                  defb 8,13,189,162,1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 400+ 101D 01 02 04 18
# file closed: ../include/psg/psg-1.1.asm
  77  1021
  78  1021              ; include the latest version of the LM80C BASIC interpreter
  79  1021                  INCLUDE "../include/basic/basic-1.04.asm"
# file opened: ../include/basic/basic-1.04.asm
   1+ 1021              ; ------------------------------------------------------------------------------
   2+ 1021              ; LM80C BASIC (32K/64K) - R3.18
   3+ 1021              ; ------------------------------------------------------------------------------
   4+ 1021              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 1021              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 1021              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 1021              ; kind of warranty: you can use them at your own risk.
   8+ 1021              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 1021              ; maintain the copyright notices, include this advice and the note to the
  10+ 1021              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 1021              ; redistribuite them.
  12+ 1021              ; https://www.leonardomiliani.com
  13+ 1021              ;
  14+ 1021              ; Please support me by visiting the following links:
  15+ 1021              ; Main project page: https://www.leonardomiliani.com
  16+ 1021              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 1021              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 1021              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 1021              ; ------------------------------------------------------------------------------
  20+ 1021              ; LM80C BASIC 64K - originally based on the following NASCOM BASIC versions:
  21+ 1021              ; 4.7  - original version by NASCOM/MICROSOFT
  22+ 1021              ; 4.7b - modified version by Grant Searle (additional commands & functions)
  23+ 1021
  24+ 1021
  25+ 1021              ;------------------------------------------------------------------------------
  26+ 1021              ;  L M 8 0 C   B A S I C
  27+ 1021              ;------------------------------------------------------------------------------
  28+ 1021
  29+ 1021              ; GENERAL EQUATES
  30+ 1021
  31+ 1021              NLLCR           equ     $00             ; null char (used as space/empty char in video prints)
  32+ 1021              CTRLC           equ     $03             ; Control "C"
  33+ 1021              CTRLG           equ     $07             ; Control "G"
  34+ 1021              BKSP            equ     $08             ; Back space
  35+ 1021              LF              equ     $0A             ; Line feed
  36+ 1021              CS              equ     $0C             ; Clear screen
  37+ 1021              CR              equ     $0D             ; Carriage return
  38+ 1021              CTRLO           equ     $0F             ; Control "O"
  39+ 1021              CTRLQ           equ     $11             ; Control "Q"
  40+ 1021              CTRLR           equ     $12             ; Control "R"
  41+ 1021              CTRLS           equ     $13             ; Control "S"
  42+ 1021              CTRLU           equ     $15             ; Control "U"
  43+ 1021              HOME            equ     $19             ; Home (cursor at 0,0)
  44+ 1021              ESC             equ     $1B             ; Escape
  45+ 1021              SPC             equ     $20             ; Space
  46+ 1021              DEL             equ     $7F             ; Delete
  47+ 1021              INSRT           equ     $1A             ; Insert Key
  48+ 1021              ; cursor ASCII codes
  49+ 1021              CRSLFT          equ     $1C             ; cursor left
  50+ 1021              CRSRGT          equ     $1D             ; cursor right
  51+ 1021              CRSUP           equ     $1E             ; cursor up
  52+ 1021              CRSDN           equ     $1F             ; cursor down
  53+ 1021
  54+ 1021
  55+ 1021              ;-------------------------------------------------------------------------
  56+ 1021              ; BASIC ERROR MESSAGES
  57+ 1021              ; the interpreter looks for a single-byte code in the following list,
  58+ 1021              ; then loads the corresponding memory pointer in "ERRTBL" table to
  59+ 1021              ; find where to retrieve the message text in "ERRORS"
  60+ 1021
  61+ 1021              ; BASIC ERROR CODE VALUES
  62+ 1021              ; These values act as an offset to point to the error message into the error table
  63+ 1021              ; must be incremented by 2 because they point to a word address jump
  64+ 1021              NF              equ     $00     ; NEXT without FOR
  65+ 1021              SN              equ     $02     ; Syntax error
  66+ 1021              RG              equ     $04     ; RETURN without GOSUB
  67+ 1021              OD              equ     $06     ; Out of DATA
  68+ 1021              FC              equ     $08     ; Function call error
  69+ 1021              OV              equ     $0A     ; Overflow
  70+ 1021              OM              equ     $0C     ; Out of memory
  71+ 1021              UL              equ     $0E     ; Undefined line number
  72+ 1021              BS              equ     $10     ; Bad subscript
  73+ 1021              DD              equ     $12     ; Re-Dimensioned array
  74+ 1021              DZ              equ     $14     ; Division by zero (/0)
  75+ 1021              ID              equ     $16     ; Illegal direct
  76+ 1021              TM              equ     $18     ; Type mis-match
  77+ 1021              OS              equ     $1A     ; Out of string space
  78+ 1021              LS              equ     $1C     ; String too long
  79+ 1021              ST              equ     $1E     ; String formula too complex
  80+ 1021              CN              equ     $20     ; Can't continue
  81+ 1021              UF              equ     $22     ; Undefined FN function
  82+ 1021              MO              equ     $24     ; Missing operand
  83+ 1021              HX              equ     $26     ; HEX error
  84+ 1021              BN              equ     $28     ; BIN error
  85+ 1021              GM              equ     $2A     ; No Graphics Mode
  86+ 1021              SC              equ     $2C     ; Serial configuration
  87+ 1021              SA              equ     $2E     ; Serial port already open
  88+ 1021              SO              equ     $30     ; Serial buffer overrun
  89+ 1021              HP              equ     $32     ; HELP call
  90+ 1021
  91+ 1021              ; BASIC ERROR POINTER TABLE
  92+ 1021              ERRTBL: equ $
  93+ 1021 55 10        NFPTR:  defw    NFMSG
  94+ 1023 66 10        SNPTR:  defw    SNMSG
  95+ 1025 6D 10        RGPTR:  defw    RGMSG
  96+ 1027 82 10        ODPTR:  defw    ODMSG
  97+ 1029 8E 10        FCPTR:  defw    FCMSG
  98+ 102B A4 10        OVPTR:  defw    OVMSG
  99+ 102D AD 10        OMPTR:  defw    OMMSG
 100+ 102F BB 10        ULPTR:  defw    ULMSG
 101+ 1031 CA 10        BSPTR:  defw    BSMSG
 102+ 1033 D8 10        DDPTR:  defw    DDMSG
 103+ 1035 ED 10        DZPTR:  defw    DZMSG
 104+ 1037 FE 10        IDPTR:  defw    IDMSG
 105+ 1039 0D 11        TMPTR:  defw    TMMSG
 106+ 103B 1C 11        OSPTR:  defw    OSMSG
 107+ 103D 30 11        LSPTR:  defw    LSMSG
 108+ 103F 40 11        STPTR:  defw    STMSG
 109+ 1041 5B 11        CNPTR:  defw    CNMSG
 110+ 1043 6A 11        UFPTR:  defw    UFMSG
 111+ 1045 80 11        MOPTR:  defw    MOMSG
 112+ 1047 90 11        HXPTR:  defw    HXMSG
 113+ 1049 9B 11        BNPTR:  defw    BNMSG
 114+ 104B A6 11        GMPRT:  defw    GMMSG
 115+ 104D B7 11        SCPTR:  defw    SCMSG
 116+ 104F CC 11        SAPTR:  defw    SAMSG
 117+ 1051 E5 11        SOPTR:  defw    SOMSG
 118+ 1053 FB 11        HPPTR:  defw    HPMSG
 119+ 1055
 120+ 1055              ; BASIC ERROR MESSAGE LIST
 121+ 1055              ERRORS  equ $
 122+ 1055 4E 45 58 54  NFMSG:  defb    "NEXT Without FOR",0
 122+ 1059 20 57 69 74
 122+ 105D 68 6F 75 74
 122+ 1061 20 46 4F 52
 122+ 1065 00
 123+ 1066 53 79 6E 74  SNMSG:  defb    "Syntax",0
 123+ 106A 61 78 00
 124+ 106D 52 45 54 55  RGMSG:  defb    "RETURN without GOSUB",0
 124+ 1071 52 4E 20 77
 124+ 1075 69 74 68 6F
 124+ 1079 75 74 20 47
 124+ 107D 4F 53 55 42
 124+ 1081 00
 125+ 1082 4F 75 74 20  ODMSG:  defb    "Out of DATA",0
 125+ 1086 6F 66 20 44
 125+ 108A 41 54 41 00
 126+ 108E 49 6C 6C 65  FCMSG:  defb    "Illegal Function Call",0
 126+ 1092 67 61 6C 20
 126+ 1096 46 75 6E 63
 126+ 109A 74 69 6F 6E
 126+ 109E 20 43 61 6C
 126+ 10A2 6C 00
 127+ 10A4 4F 76 65 72  OVMSG:  defb    "Overflow",0
 127+ 10A8 66 6C 6F 77
 127+ 10AC 00
 128+ 10AD 4F 75 74 20  OMMSG:  defb    "Out of Memory",0
 128+ 10B1 6F 66 20 4D
 128+ 10B5 65 6D 6F 72
 128+ 10B9 79 00
 129+ 10BB 55 6E 64 65  ULMSG:  defb    "Undefined Line",0
 129+ 10BF 66 69 6E 65
 129+ 10C3 64 20 4C 69
 129+ 10C7 6E 65 00
 130+ 10CA 42 61 64 20  BSMSG:  defb    "Bad Subscript",0
 130+ 10CE 53 75 62 73
 130+ 10D2 63 72 69 70
 130+ 10D6 74 00
 131+ 10D8 52 65 2D 44  DDMSG:  defb    "Re-Dimensioned Array",0
 131+ 10DC 69 6D 65 6E
 131+ 10E0 73 69 6F 6E
 131+ 10E4 65 64 20 41
 131+ 10E8 72 72 61 79
 131+ 10EC 00
 132+ 10ED 44 69 76 69  DZMSG:  defb    "Division by Zero",0
 132+ 10F1 73 69 6F 6E
 132+ 10F5 20 62 79 20
 132+ 10F9 5A 65 72 6F
 132+ 10FD 00
 133+ 10FE 49 6C 6C 65  IDMSG:  defb    "Illegal Direct",0
 133+ 1102 67 61 6C 20
 133+ 1106 44 69 72 65
 133+ 110A 63 74 00
 134+ 110D 54 79 70 65  TMMSG:  defb    "Type Mis-match",0
 134+ 1111 20 4D 69 73
 134+ 1115 2D 6D 61 74
 134+ 1119 63 68 00
 135+ 111C 4F 75 74 20  OSMSG:  defb    "Out of String Space",0
 135+ 1120 6F 66 20 53
 135+ 1124 74 72 69 6E
 135+ 1128 67 20 53 70
 135+ 112C 61 63 65 00
 136+ 1130 53 74 72 69  LSMSG:  defb    "String Too Long",0
 136+ 1134 6E 67 20 54
 136+ 1138 6F 6F 20 4C
 136+ 113C 6F 6E 67 00
 137+ 1140 53 74 72 69  STMSG:  defb    "String Formula Too Complex",0
 137+ 1144 6E 67 20 46
 137+ 1148 6F 72 6D 75
 137+ 114C 6C 61 20 54
 137+ 1150 6F 6F 20 43
 137+ 1154 6F 6D 70 6C
 137+ 1158 65 78 00
 138+ 115B 43 61 6E 27  CNMSG:  defb    "Can't Continue",0
 138+ 115F 74 20 43 6F
 138+ 1163 6E 74 69 6E
 138+ 1167 75 65 00
 139+ 116A 55 6E 64 65  UFMSG:  defb    "Undefined FN Function",0
 139+ 116E 66 69 6E 65
 139+ 1172 64 20 46 4E
 139+ 1176 20 46 75 6E
 139+ 117A 63 74 69 6F
 139+ 117E 6E 00
 140+ 1180 4D 69 73 73  MOMSG:  defb    "Missing Operand",0
 140+ 1184 69 6E 67 20
 140+ 1188 4F 70 65 72
 140+ 118C 61 6E 64 00
 141+ 1190 48 45 58 20  HXMSG:  defb    "HEX Format",0
 141+ 1194 46 6F 72 6D
 141+ 1198 61 74 00
 142+ 119B 42 49 4E 20  BNMSG:  defb    "BIN Format",0
 142+ 119F 46 6F 72 6D
 142+ 11A3 61 74 00
 143+ 11A6 4E 6F 20 47  GMMSG:  defb    "No Graphics Mode",0
 143+ 11AA 72 61 70 68
 143+ 11AE 69 63 73 20
 143+ 11B2 4D 6F 64 65
 143+ 11B6 00
 144+ 11B7 53 65 72 69  SCMSG:  defb    "Serial Configuration",0
 144+ 11BB 61 6C 20 43
 144+ 11BF 6F 6E 66 69
 144+ 11C3 67 75 72 61
 144+ 11C7 74 69 6F 6E
 144+ 11CB 00
 145+ 11CC 53 65 72 69  SAMSG:  defb    "Serial Port Already Open",0
 145+ 11D0 61 6C 20 50
 145+ 11D4 6F 72 74 20
 145+ 11D8 41 6C 72 65
 145+ 11DC 61 64 79 20
 145+ 11E0 4F 70 65 6E
 145+ 11E4 00
 146+ 11E5 53 65 72 69  SOMSG:  defb    "Serial Buffer Overrun",0
 146+ 11E9 61 6C 20 42
 146+ 11ED 75 66 66 65
 146+ 11F1 72 20 4F 76
 146+ 11F5 65 72 72 75
 146+ 11F9 6E 00
 147+ 11FB 48 45 4C 50  HPMSG:  defb    "HELP Call",0
 147+ 11FF 20 43 61 6C
 147+ 1203 6C 00
 148+ 1205
 149+ 1205
 150+ 1205              ;-----------------------------------------------------------------------------
 151+ 1205              ; STARTING POINTS FOR BASIC BOOT
 152+ 1205              ; COLD: reset every memory pointer, acting as a power-up boot
 153+ 1205              ; WARM: preserve program in memory, keeping every current pointer
 154+ 1205
 155+ 1205 C3 0B 12     COLD:   jp      STARTB          ; Jump for cold start
 156+ 1208 C3 B9 12     WARM:   jp      WARMST          ; Jump for warm start
 157+ 120B
 158+ 120B C3 12 12     STARTB: jp      CSTART          ; Jump to initialise
 159+ 120E E6 1C                defw    DEINT           ; Get integer -32768 to 32767
 160+ 1210 AB 24                defw    ABPASS          ; Return integer in AB
 161+ 1212 21 5E 80     CSTART: ld      HL,WRKSPC       ; Start of workspace RAM
 162+ 1215 F9                   ld      SP,HL           ; Set up a temporary stack
 163+ 1216 C3 EF 3F             jp      INITST          ; Go to initialise
 164+ 1219
 165+ 1219 21 86 15     INIT:   ld      HL,INITAB       ; Initialise workspace
 166+ 121C 01 DC 00             ld      BC,INITBE-INITAB+3; Bytes to copy
 167+ 121F 11 5E 80             ld      DE,WRKSPC       ; Into workspace RAM
 168+ 1222 ED B0                ldir                    ; Copy data
 169+ 1224 EB                   ex      DE,HL           ; Copy DE into HL
 170+ 1225 F9                   ld      SP,HL           ; Temporary stack
 171+ 1226 CD 49 18             call    CLREG           ; Clear registers and stack
 172+ 1229 CD FD 1E             call    PRNTCRLF        ; Output CRLF
 173+ 122C 32 91 81             ld      (BUFFER+88+1),A ; Mark end of buffer
 174+ 122F 32 46 82             ld      (PROGST),A      ; Initialise program area
 175+ 1232 18 13                jr      MNOASK          ; usually, don't ask for memory top (only when there are errors)
 176+ 1234 21 20 13     MSIZE:  ld      HL,MEMMSG       ; Point to message
 177+ 1237 CD C9 25             call    PRS             ; Output "Memory size"
 178+ 123A CD 66 18             call    PROMPT          ; Get input with '?'
 179+ 123D CD 38 09             call    CURSOR_ON       ; enable cursor
 180+ 1240 CD 30 1C             call    GETCHR          ; Get next character
 181+ 1243 B7                   or      A               ; Set flags
 182+ 1244 C2 5C 12             jp      NZ,TSTMEM       ; If number - Test if RAM there
 183+ 1247 21 AA 82     MNOASK: ld      HL,STLOOK       ; Point to start of RAM
 184+ 124A 23           MLOOP:  inc     HL              ; Next byte
 185+ 124B 7C                   ld      A,H             ; Above address FFFF ?
 186+ 124C B5                   or      L
 187+ 124D CA 6E 12             jp      Z,SETTOP        ; Yes - 64K RAM
 188+ 1250 7E                   ld      A,(HL)          ; Get contents
 189+ 1251 47                   ld      B,A             ; Save it
 190+ 1252 2F                   cpl                     ; Flip all bits
 191+ 1253 77                   ld      (HL),A          ; Put it back
 192+ 1254 BE                   cp      (HL)            ; RAM there if same
 193+ 1255 70                   ld      (HL),B          ; Restore old contents
 194+ 1256 CA 4A 12             jp      Z,MLOOP         ; If RAM - test next byte
 195+ 1259 C3 6E 12             jp      SETTOP          ; Top of RAM found
 196+ 125C
 197+ 125C CD 00 1D     TSTMEM: call    ATOH            ; Get high memory into DE
 198+ 125F B7                   or      A               ; Set flags on last byte
 199+ 1260 C2 ED 16             jp      NZ,SNERR        ; ?SN Error if bad character
 200+ 1263 EB                   ex      DE,HL           ; Address into HL
 201+ 1264 2B                   dec     HL              ; Back one byte
 202+ 1265 3E D9                ld      A,%11011001     ; Test byte
 203+ 1267 46                   ld      B,(HL)          ; Get old contents
 204+ 1268 77                   ld      (HL),A          ; Load test byte
 205+ 1269 BE                   cp      (HL)            ; RAM there if same
 206+ 126A 70                   ld      (HL),B          ; Restore old contents
 207+ 126B C2 34 12             jp      NZ,MSIZE        ; Ask again if no RAM
 208+ 126E
 209+ 126E CD 4D 09     SETTOP: call    CURSOR_OFF      ; disable cursor
 210+ 1271 2B                   dec     HL              ; Back one byte
 211+ 1272 11 A9 82             ld      DE,STLOOK-1     ; See if enough RAM
 212+ 1275 CD E1 19             call    CPDEHL          ; Compare DE with HL
 213+ 1278 DA 34 12             jp      C,MSIZE         ; Ask again if not enough RAM
 214+ 127B 3A 22 82             ld      A,(DOS_EN)      ; read if the user enabled/disabled DOS while booting
 215+ 127E 1F                   rra                     ; is DOS disabled?
 216+ 127F 30 04                jr      NC,NODOS        ; yes, so jump over
 217+ 1281 11 00 FE             ld      DE,0-512        ; no, so reserve 512 bytes on top of RAM...
 218+ 1284 19                   add     HL,DE           ; ...for I/O buffer
 219+ 1285 11 9C FF     NODOS:  ld      DE,0-100        ; 100 Bytes string space
 220+ 1288 22 96 81             ld      (LSTRAM),HL     ; Save last available RAM
 221+ 128B 19                   add     HL,DE           ; Allocate string space
 222+ 128C 22 AD 80             ld      (STRSPC),HL     ; Save string space
 223+ 128F CD 24 18             call    CLRPTR          ; Clear program area
 224+ 1292 2A AD 80             ld      HL,(STRSPC)     ; Get end of memory
 225+ 1295 11 EF FF             ld      DE,0-17         ; Offset for free bytes
 226+ 1298 19                   add     HL,DE           ; Adjust HL
 227+ 1299 11 46 82             ld      DE,PROGST       ; Start of program text
 228+ 129C 7D                   ld      A,L             ; Get LSB
 229+ 129D 93                   sub     E               ; Adjust it
 230+ 129E 6F                   ld      L,A             ; Re-save
 231+ 129F 7C                   ld      A,H             ; Get MSB
 232+ 12A0 9A                   sbc     A,D             ; Adjust it
 233+ 12A1 67                   ld      H,A             ; Re-save
 234+ 12A2 E5                   push    HL              ; Save bytes free
 235+ 12A3 21 DF 12             ld      HL,SIGNON       ; Sign-on message
 236+ 12A6 CD C9 25             call    PRS             ; Output string
 237+ 12A9 21 C8 12             ld      HL,BLNSPC       ; Empty space
 238+ 12AC CD C9 25             call    PRS             ; Output string
 239+ 12AF E1                   pop     HL              ; Get bytes free back
 240+ 12B0 CD 68 30             call    PRNTHL          ; Output amount of free memory
 241+ 12B3 21 D1 12             ld      HL,BFREE        ; " Bytes free" message
 242+ 12B6 CD C9 25             call    PRS             ; Output string
 243+ 12B9
 244+ 12B9 31 3D 81     WARMST: ld      SP,STACK        ; Temporary stack
 245+ 12BC CD 49 18     BRKRET: call    CLREG           ; Clear registers and stack
 246+ 12BF CD 86 3D             call    RESFN           ; reset FN keys and auto-repeat
 247+ 12C2 CD 38 09             call    CURSOR_ON       ; enable cursor
 248+ 12C5 C3 47 17             jp      PRNTOK          ; Go to get command line
 249+ 12C8
 250+ 12C8 20 20 20 20  BLNSPC: defb    "        ",0    ; 8 empty cells to align the "XXXX Bytes free" message
 250+ 12CC 20 20 20 20
 250+ 12D0 00
 251+ 12D1 20 42 79 74  BFREE:  defb    " Bytes free",CR,CR,0
 251+ 12D5 65 73 20 66
 251+ 12D9 72 65 65 0D
 251+ 12DD 0D 00
 252+ 12DF
 253+ 12DF 4C 4D 38 30  SIGNON: defb    "LM80C BASIC 3.18 ",251,"2021 L.Miliani"
 253+ 12E3 43 20 42 41
 253+ 12E7 53 49 43 20
 253+ 12EB 33 2E 31 38
 253+ 12EF 20 FB 32 30
 253+ 12F3 32 31 20 4C
 253+ 12F7 2E 4D 69 6C
 253+ 12FB 69 61 6E 69
 254+ 12FF 20 5A 38 30          defb    " Z80 BASIC 4.7  ",251,"1978 Microsoft",CR,0
 254+ 1303 20 42 41 53
 254+ 1307 49 43 20 34
 254+ 130B 2E 37 20 20
 254+ 130F FB 31 39 37
 254+ 1313 38 20 4D 69
 254+ 1317 63 72 6F 73
 254+ 131B 6F 66 74 0D
 254+ 131F 00
 255+ 1320
 256+ 1320 4D 65 6D 6F  MEMMSG: defb    "Memory top",0
 256+ 1324 72 79 20 74
 256+ 1328 6F 70 00
 257+ 132B
 258+ 132B              ; The following list reports all the functions supported by the interpreter.
 259+ 132B              ; To add a custom function, the user must first insert the reserved word here,
 260+ 132B              ; then into the list of the reserved words below, and finally must increment the
 261+ 132B              ; ZSGN token value and all the following ones after ZSGN by 1 for every added
 262+ 132B              ; function.
 263+ 132B
 264+ 132B              ; FUNCTION ADDRESS TABLE (this is a sort of offset table)
 265+ 132B              ; this list must be coherent with the tokens' functions list. This means that every
 266+ 132B              ; entry here must have the corresponding entry in the tokens list.
 267+ 132B DD 2E        FNCTAB: defw    SGN
 268+ 132D 73 24                defw    TMR         ; added by Leonardo Miliani
 269+ 132F A1 2F                defw    INT
 270+ 1331 F3 2E                defw    ABS_        ; _ necessary for assembler warning
 271+ 1333 64 80                defw    USR
 272+ 1335 89 24                defw    FRE
 273+ 1337 04 29                defw    INP
 274+ 1339 B7 24                defw    POS
 275+ 133B 67 31                defw    SQR
 276+ 133D 46 32                defw    RND
 277+ 133F 31 2D                defw    LOG
 278+ 1341 B5 31                defw    EXP
 279+ 1343 BB 32                defw    COS
 280+ 1345 C1 32                defw    SIN
 281+ 1347 22 33                defw    TAN
 282+ 1349 37 33                defw    ATN
 283+ 134B E0 29                defw    PEEK
 284+ 134D A2 33                defw    DEEK
 285+ 134F E7 29                defw    VPEEK       ; added by Leonardo Miliani
 286+ 1351 B6 2B                defw    VSTAT       ; added by Leonardo Miliani
 287+ 1353 C1 2B                defw    SSTAT       ; added by Leonardo Miliani
 288+ 1355 D5 2B                defw    INKEY       ; added by Leonardo Miliani
 289+ 1357 FB 36                defw    POINT       ; added by Leonardo Miliani
 290+ 1359 9B 27                defw    INSTR       ; added by Leonardo Miliani
 291+ 135B 3B 27                defw    LEN
 292+ 135D 53 25                defw    STR
 293+ 135F CB 28                defw    VAL
 294+ 1361 4A 27                defw    ASC
 295+ 1363 5B 27                defw    CHR
 296+ 1365 EA 3E                defw    HEX         ; added by Grant Searle
 297+ 1367 7B 3F                defw    BIN         ; added by Grant Searle
 298+ 1369 6B 27                defw    LEFT
 299+ 136B 91 28                defw    RIGHT
 300+ 136D 9B 28                defw    MID
 301+ 136F
 302+ 136F              ; RESERVED WORD LIST
 303+ 136F              ; Here are all the reserved words used by the interpreter
 304+ 136F              ; To add custom functions/commands, the user must insert the keyword
 305+ 136F              ; in this list, following the schematic
 306+ 136F C5 4E 44     WORDS:  defb    'E'+$80,"ND"            ; from here the list contains the COMMANDS
 307+ 1372 C6 4F 52             defb    'F'+$80,"OR"
 308+ 1375 CE 45 58 54          defb    'N'+$80,"EXT"
 309+ 1379 C4 41 54 41          defb    'D'+$80,"ATA"
 310+ 137D C9 4E 50 55          defb    'I'+$80,"NPUT"
 310+ 1381 54
 311+ 1382 C4 49 4D             defb    'D'+$80,"IM"
 312+ 1385 D2 45 41 44          defb    'R'+$80,"EAD"
 313+ 1389 CC 45 54             defb    'L'+$80,"ET"
 314+ 138C C7 4F 54 4F          defb    'G'+$80,"OTO"
 315+ 1390 D2 55 4E             defb    'R'+$80,"UN"
 316+ 1393 C9 46                defb    'I'+$80,"F"
 317+ 1395 D2 45 53 54          defb    'R'+$80,"ESTORE"
 317+ 1399 4F 52 45
 318+ 139C C7 4F 53 55          defb    'G'+$80,"OSUB"
 318+ 13A0 42
 319+ 13A1 D2 45 54 55          defb    'R'+$80,"ETURN"
 319+ 13A5 52 4E
 320+ 13A7 D2 45 4D             defb    'R'+$80,"EM"            ; original REM
 321+ 13AA D3 54 4F 50          defb    'S'+$80,"TOP"
 322+ 13AE CF 55 54             defb    'O'+$80,"UT"
 323+ 13B1 CF 4E                defb    'O'+$80,"N"
 324+ 13B3 C6 49 4C 45          defb    'F'+$80,"ILES"
 324+ 13B7 53
 325+ 13B8 C5 52 41 53          defb    'E'+$80,"RASE"          ; added by Leonardo Miliani
 325+ 13BC 45
 326+ 13BD D7 41 49 54          defb    'W'+$80,"AIT"
 327+ 13C1 C4 45 46             defb    'D'+$80,"EF"
 328+ 13C4 D0 4F 4B 45          defb    'P'+$80,"OKE"
 329+ 13C8 C4 4F 4B 45          defb    'D'+$80,"OKE"
 330+ 13CC D6 50 4F 4B          defb    'V'+$80,"POKE"          ; added by Leonardo Miliani
 330+ 13D0 45
 331+ 13D1 D3 52 45 47          defb    'S'+$80,"REG"           ; added by Leonardo Miliani
 332+ 13D5 D6 52 45 47          defb    'V'+$80,"REG"           ; added by Leonardo Miliani
 333+ 13D9 D3 43 52 45          defb    'S'+$80,"CREEN"         ; changed by Leonardo Miliani
 333+ 13DD 45 4E
 334+ 13DF CC 4F 43 41          defb    'L'+$80,"OCATE"         ; added by Leonardo Miliani
 334+ 13E3 54 45
 335+ 13E5 D3 4F 55 4E          defb    'S'+$80,"OUND"          ; added by Leonardo Miliani
 335+ 13E9 44
 336+ 13EA D6 4F 4C 55          defb    'V'+$80,"OLUME"         ; added by Leonardo Miliani
 336+ 13EE 4D 45
 337+ 13F0 D0 41 55 53          defb    'P'+$80,"AUSE"          ; added by Leonardo Miliani
 337+ 13F4 45
 338+ 13F5 C3 4F 4C 4F          defb    'C'+$80,"OLOR"          ; added by Leonardo Miliani
 338+ 13F9 52
 339+ 13FA D0 4C 4F 54          defb    'P'+$80,"LOT"           ; added by Leonardo Miliani
 340+ 13FE C4 52 41 57          defb    'D'+$80,"RAW"           ; added by Leonardo Miliani
 341+ 1402 C3 49 52 43          defb    'C'+$80,"IRCLE"         ; added by Leonardo Miliani
 341+ 1406 4C 45
 342+ 1408 D0 41 49 4E          defb    'P'+$80,"AINT"          ; added by Leonardo Miliani
 342+ 140C 54
 343+ 140D D3 45 52 49          defb    'S'+$80,"ERIAL"         ; added by Leonardo Miliani
 343+ 1411 41 4C
 344+ 1413 C8 45 4C 50          defb    'H'+$80,"ELP"           ; changed by Leonardo Miliani - was LINES
 345+ 1417 C3 4C 53             defb    'C'+$80,"LS"            ; restored command
 346+ 141A CB 45 59             defb    'K'+$80,"EY"            ; added by Leonardo Miliani
 347+ 141D CE 4D 49             defb    'N'+$80,"MI"            ; added by Leonardo Miliani
 348+ 1420 C7 50 52 49          defb    'G'+$80,"PRINT"         ; added by Leonardo Miliani
 348+ 1424 4E 54
 349+ 1426 D7 49 44 54          defb    'W'+$80,"IDTH"
 349+ 142A 48
 350+ 142B D3 59 53             defb    'S'+$80,"YS"            ; added by Leonardo Miliani
 351+ 142E D2 45 53 45          defb    'R'+$80,"ESET"          ; changed by Leonardo Miliani
 351+ 1432 54
 352+ 1433 C5 4C 53 45          defb    'E'+$80,"LSE"           ; added by Leonardo Miliani
 353+ 1437 D0 52 49 4E          defb    'P'+$80,"RINT"
 353+ 143B 54
 354+ 143C C3 4F 4E 54          defb    'C'+$80,"ONT"
 355+ 1440 CC 49 53 54          defb    'L'+$80,"IST"
 356+ 1444 C3 4C 45 41          defb    'C'+$80,"LEAR"
 356+ 1448 52
 357+ 1449 CC 4F 41 44          defb    'L'+$80,"OAD"
 358+ 144D D3 41 56 45          defb    'S'+$80,"AVE"
 359+ 1451 CE 45 57             defb    'N'+$80,"EW"
 360+ 1454 D4 41 42 28          defb    'T'+$80,"AB("
 361+ 1458 D4 4F                defb    'T'+$80,"O"
 362+ 145A C6 4E                defb    'F'+$80,"N"
 363+ 145C D3 50 43 28          defb    'S'+$80,"PC("
 364+ 1460 D4 48 45 4E          defb    'T'+$80,"HEN"
 365+ 1464 CE 4F 54             defb    'N'+$80,"OT"
 366+ 1467 D3 54 45 50          defb    'S'+$80,"TEP"
 367+ 146B                      ; from here: operators
 368+ 146B AB                   defb    '+'+$80
 369+ 146C AD                   defb    '-'+$80
 370+ 146D AA                   defb    '*'+$80
 371+ 146E AF                   defb    '/'+$80
 372+ 146F A5                   defb    '%'+$80
 373+ 1470 A3                   defb    '#'+$80
 374+ 1471 DE                   defb    '^'+$80
 375+ 1472 C1 4E 44             defb    'A'+$80,"ND"
 376+ 1475 D8 4F 52             defb    'X'+$80,"OR"
 377+ 1478 CF 52                defb    'O'+$80,"R"
 378+ 147A BE                   defb    '>'+$80
 379+ 147B BD                   defb    '='+$80
 380+ 147C BC                   defb    '<'+$80
 381+ 147D
 382+ 147D                      ; from here there are the tokens' FUNCTIONS list
 383+ 147D                      ; this list must be coherent with the functions list above
 384+ 147D D3 47 4E             defb    'S'+$80,"GN"
 385+ 1480 D4 4D 52             defb    'T'+$80,"MR"            ; added by Leonardo Miliani
 386+ 1483 C9 4E 54             defb    'I'+$80,"NT"
 387+ 1486 C1 42 53             defb    'A'+$80,"BS"
 388+ 1489 D5 53 52             defb    'U'+$80,"SR"
 389+ 148C C6 52 45             defb    'F'+$80,"RE"
 390+ 148F C9 4E 50             defb    'I'+$80,"NP"
 391+ 1492 D0 4F 53             defb    'P'+$80,"OS"
 392+ 1495 D3 51 52             defb    'S'+$80,"QR"
 393+ 1498 D2 4E 44             defb    'R'+$80,"ND"
 394+ 149B CC 4F 47             defb    'L'+$80,"OG"
 395+ 149E C5 58 50             defb    'E'+$80,"XP"
 396+ 14A1 C3 4F 53             defb    'C'+$80,"OS"
 397+ 14A4 D3 49 4E             defb    'S'+$80,"IN"
 398+ 14A7 D4 41 4E             defb    'T'+$80,"AN"
 399+ 14AA C1 54 4E             defb    'A'+$80,"TN"
 400+ 14AD D0 45 45 4B          defb    'P'+$80,"EEK"
 401+ 14B1 C4 45 45 4B          defb    'D'+$80,"EEK"
 402+ 14B5 D6 50 45 45          defb    'V'+$80,"PEEK"          ; added by Leonardo Miliani
 402+ 14B9 4B
 403+ 14BA D6 53 54 41          defb    'V'+$80,"STAT"          ; added by Leonardo Miliani
 403+ 14BE 54
 404+ 14BF D3 53 54 41          defb    'S'+$80,"STAT"          ; added by Leonardo Miliani
 404+ 14C3 54
 405+ 14C4 C9 4E 4B 45          defb    'I'+$80,"NKEY"          ; added by Leonardo Miliani
 405+ 14C8 59
 406+ 14C9 D0 4F 49 4E          defb    'P'+$80,"OINT"          ; added by Leonardo Miliani
 406+ 14CD 54
 407+ 14CE C9 4E 53 54          defb    'I'+$80,"NSTR"          ; added by Leonardo Miliani
 407+ 14D2 52
 408+ 14D3 CC 45 4E             defb    'L'+$80,"EN"
 409+ 14D6 D3 54 52 24          defb    'S'+$80,"TR$"
 410+ 14DA D6 41 4C             defb    'V'+$80,"AL"
 411+ 14DD C1 53 43             defb    'A'+$80,"SC"
 412+ 14E0 C3 48 52 24          defb    'C'+$80,"HR$"
 413+ 14E4 C8 45 58 24          defb    'H'+$80,"EX$"           ; added by Grant Searle
 414+ 14E8 C2 49 4E 24          defb    'B'+$80,"IN$"           ; added by Grant Searle
 415+ 14EC CC 45 46 54          defb    'L'+$80,"EFT$"
 415+ 14F0 24
 416+ 14F1 D2 49 47 48          defb    'R'+$80,"IGHT$"
 416+ 14F5 54 24
 417+ 14F7 CD 49 44 24          defb    'M'+$80,"ID$"
 418+ 14FB 80                   defb    $80                     ; End-of-list marker
 419+ 14FC
 420+ 14FC              ; KEYWORD ADDRESS TABLE
 421+ 14FC              ; this list must be coherent with the commands'
 422+ 14FC              ; tokens list above
 423+ 14FC 7A 1C        WORDTB: defw    PEND
 424+ 14FE 77 1B                defw    FOR
 425+ 1500 76 20                defw    NEXT
 426+ 1502 D9 1D                defw    DATA
 427+ 1504 73 1F                defw    INPUT
 428+ 1506 CB 22                defw    DIM
 429+ 1508 AD 1F                defw    READ
 430+ 150A F0 1D                defw    LET
 431+ 150C 96 1D                defw    GOTO
 432+ 150E 71 1D                defw    RUN
 433+ 1510 68 1E                defw    IF
 434+ 1512 40 1C                defw    RESTOR
 435+ 1514 85 1D                defw    GOSUB
 436+ 1516 B4 1D                defw    RETURN
 437+ 1518 DB 1D                defw    REM         ; original REM
 438+ 151A 78 1C                defw    STOP
 439+ 151C 10 29                defw    POUT
 440+ 151E 4A 1E                defw    ON
 441+ 1520 E8 3E                defw    FILES       ; changed by Leonardo Miliani - was NULL
 442+ 1522 E9 3E                defw    ERASE       ; added by Leonardo Miliani
 443+ 1524 16 29                defw    WAIT
 444+ 1526 BF 24                defw    DEF
 445+ 1528 0A 2A                defw    POKE
 446+ 152A AD 33                defw    DOKE
 447+ 152C 0F 2A                defw    VPOKE       ; added by Leonardo Miliani
 448+ 152E 4C 2A                defw    SREG        ; added by Leonardo Miliani
 449+ 1530 9A 2B                defw    VREG        ; added by Leonardo Miliani
 450+ 1532 E3 33                defw    SCREEN      ; new behaviour: now it sets up a graphics mode (Leonardo Miliani)
 451+ 1534 1A 2A                defw    LOCATE      ; added by Leonardo Miliani
 452+ 1536 A6 2A                defw    SOUND       ; added by Leonardo Miliani
 453+ 1538 6D 2A                defw    VOLUME      ; added by Leonardo Miliani
 454+ 153A C4 33                defw    PAUSE       ; added by Leonardo Miliani
 455+ 153C 5E 34                defw    COLOR       ; added by Leonardo Miliani
 456+ 153E 4E 37                defw    PLOT        ; added by Leonardo Miliani
 457+ 1540 E1 37                defw    DRAW        ; added by Leonardo Miliani
 458+ 1542 17 39                defw    CIRCLE      ; added by Leonardo Miliani
 459+ 1544 0B 36                defw    PAINT       ; added by Leonardo Miliani
 460+ 1546 1C 3B                defw    SERIAL      ; added by Leonardo Miliani
 461+ 1548 5E 3D                defw    HELP        ; changed by Leonardo Miliani - was LINES
 462+ 154A 86 33                defw    CLS
 463+ 154C 79 3D                defw    KEY         ; added by Leonardo Miliani
 464+ 154E 58 29                defw    NMI         ; added by Leonardo Miliani
 465+ 1550 1A 35                defw    GPRINT      ; added by Leonardo Miliani
 466+ 1552 9A 33                defw    WIDTH
 467+ 1554 B2 29                defw    SYS         ; added by Leonardo Miliani
 468+ 1556 E0 3F                defw    RESET       ; new behaviour: now it resets the system
 469+ 1558 DD 1D                defw    REM+2       ; ELSE: added by Leonardo Miliani
 470+ 155A 9A 1E                defw    PRINT
 471+ 155C AC 1C                defw    CONT
 472+ 155E 4E 1A                defw    LIST
 473+ 1560 25 1D                defw    CLEAR
 474+ 1562 E6 3E                defw    LOAD        ; re-implemented by Leonardo Miliani (was CLOAD)
 475+ 1564 E7 3E                defw    SAVE        ; re-implemented by Leonardo Miliani (was CSAVE)
 476+ 1566 23 18                defw    NEW
 477+ 1568
 478+ 1568              ; RESERVED WORD TOKEN VALUES
 479+ 1568              ; if you add a function or command you must increment by 1
 480+ 1568              ; the values below. Pay attention that you must increment only the
 481+ 1568              ; values AFTER the position where you entered the function/command word
 482+ 1568              ; in the "Reserver word list" above. I.E.: VPOKE has been added between
 483+ 1568              ; DOKE and SCREEN, and since REM is the reserved work listed below
 484+ 1568              ; that is before the point where VPOKE has been entered, every entry
 485+ 1568              ; after REM has been incremented.
 486+ 1568              ; Another example: when TMR has been added, since it's a function, every
 487+ 1568              ; entry after & included ZSGN must be checked (read below)
 488+ 1568
 489+ 1568              ZEND    equ     $80             ; END        <-- from here, there are the commands
 490+ 1568              ZFOR    equ     $81             ; FOR
 491+ 1568              ZDATA   equ     $83             ; DATA
 492+ 1568              ZGOTO   equ     $88             ; GOTO
 493+ 1568              ZGOSUB  equ     $8C             ; GOSUB
 494+ 1568              ZREM    equ     $8E             ; REM
 495+ 1568              ZELSE   equ     $AE             ; ELSE
 496+ 1568              ZPRINT  equ     $AF             ; PRINT
 497+ 1568              ZNEW    equ     $B5             ; NEW
 498+ 1568
 499+ 1568              ZTAB    equ     $B6             ; TAB
 500+ 1568              ZTO     equ     $B7             ; TO
 501+ 1568              ZFN     equ     $B8             ; FN
 502+ 1568              ZSPC    equ     $B9             ; SPC
 503+ 1568              ZTHEN   equ     $BA             ; THEN
 504+ 1568              ZNOT    equ     $BB             ; NOT
 505+ 1568              ZSTEP   equ     $BC             ; STEP
 506+ 1568
 507+ 1568              ZPLUS   equ     $BD             ; +         <-- from here, there are the math operators
 508+ 1568              ZMINUS  equ     $BE             ; -
 509+ 1568              ZTIMES  equ     $BF             ; *
 510+ 1568              ZDIV    equ     $C0             ; /
 511+ 1568              ZMOD    equ     $C1             ; %
 512+ 1568              ZDINT   equ     $C2             ; #
 513+ 1568              ZOR     equ     $C6             ; OR
 514+ 1568              ZGTR    equ     $C7             ; >
 515+ 1568              ZEQUAL  equ     $C8             ; M
 516+ 1568              ZLTH    equ     $C9             ; <
 517+ 1568
 518+ 1568              ZSGN    equ     $CA             ; SGN       <-- from here, there are the functions
 519+ 1568              ZPOINT  equ     $E0             ; ZPOINT    <-- if the user enters a custom function, between
 520+ 1568                                              ;               SGN and POINT, he/she must increment this pointer by 1
 521+ 1568              ZINSTR  equ     $E1             ; ZINSTR    <-- same here
 522+ 1568              ZLEFT   equ     $E9             ; LEFT$     <-- if the user enters a custom function anywhere,
 523+ 1568                                              ;               he/she must increment this pointer by 1
 524+ 1568
 525+ 1568              ; ARITHMETIC PRECEDENCE TABLE
 526+ 1568              ; in the formulas below, <last> is a number stored into the stack that must be retrieved
 527+ 1568              ; with POP BC, POP DE; FPREG is a f.p. number store into the RAM register FPREG
 528+ 1568 79           PRITAB: defb    $79             ; Precedence value
 529+ 1569 4F 30                defw    PADD            ; FPREG = <last> + FPREG
 530+ 156B
 531+ 156B 79                   defb    $79             ; Precedence value
 532+ 156C 32 2C                defw    PSUB            ; FPREG = <last> - FPREG
 533+ 156E
 534+ 156E 7C                   defb    $7C             ; Precedence value
 535+ 156F 70 2D                defw    MULT            ; PPREG = <last> * FPREG
 536+ 1571
 537+ 1571 7C                   defb    $7C             ; Precedence value
 538+ 1572 22 2E                defw    DIV             ; FPREG = <last> / FPREG
 539+ 1574
 540+ 1574 7C                   defb    $7C             ; Precedence value
 541+ 1575 CD 2D                defw    MOD             ; FPREG = INT(<last>)-(INT(FPREG)*INT(<last>/FPREG))
 542+ 1577
 543+ 1577 7C                   defb    $7C             ; precedence value
 544+ 1578 C5 2D                defw    DINT            ; FPREG = INT(<last> / FPREG )
 545+ 157A
 546+ 157A 7F                   defb    $7F             ; Precedence value
 547+ 157B 70 31                defw    POWER           ; FPREG = <last> ^ FPREG
 548+ 157D
 549+ 157D 50                   defb    $50             ; Precedence value
 550+ 157E 14 22                defw    PAND            ; FPREG = <last> AND FPREG
 551+ 1580
 552+ 1580 4A                   defb    $4A             ; Precedence value
 553+ 1581 1C 22                defw    PXOR            ; FPREG = <last> XOR FPREG
 554+ 1583
 555+ 1583 46                   defb    $46             ; Precedence value
 556+ 1584 17 22                defw    POR             ; FPREG = <last> OR FPREG
 557+ 1586
 558+ 1586
 559+ 1586              ; INITIALISATION TABLE -------------------------------------------------------
 560+ 1586              ; these values are copied into RAM at startup
 561+ 1586 C3 B9 12     INITAB: jp      WARMST          ; Warm start jump
 562+ 1589 ED 45 00             defb    $ED,$45,$00     ; RETN + NOP for default NMI service routine
 563+ 158C C3 FB 1C             jp      FCERR           ; "USR (X)" jump (Set to Error)
 564+ 158F D3 00                out     (0),A           ; "out p,n" skeleton
 565+ 1591 C9                   ret
 566+ 1592 D6 00                sub     $00             ; Division support routine
 567+ 1594 6F                   ld      L,A
 568+ 1595 7C                   ld      A,H
 569+ 1596 DE 00                sbc     A,$00
 570+ 1598 67                   ld      H,A
 571+ 1599 78                   ld      A,B
 572+ 159A DE 00                sbc     A,$00
 573+ 159C 47                   ld      B,A
 574+ 159D 3E 00                ld      A,$00
 575+ 159F C9                   ret
 576+ 15A0 00 00 00             defb    $00,$00,$00     ; Random number seed table used by RND
 577+ 15A3 35 4A CA 99          defb    $35,$4A,$CA,$99 ;-2.65145E+07
 578+ 15A7 39 1C 76 98          defb    $39,$1C,$76,$98 ; 1.61291E+07
 579+ 15AB 22 95 B3 98          defb    $22,$95,$B3,$98 ;-1.17691E+07
 580+ 15AF 0A DD 47 98          defb    $0A,$DD,$47,$98 ; 1.30983E+07
 581+ 15B3 53 D1 99 99          defb    $53,$D1,$99,$99 ;-2-01612E+07
 582+ 15B7 0A 1A 9F 98          defb    $0A,$1A,$9F,$98 ;-1.04269E+07
 583+ 15BB 65 BC CD 98          defb    $65,$BC,$CD,$98 ;-1.34831E+07
 584+ 15BF D6 77 3E 98          defb    $D6,$77,$3E,$98 ; 1.24825E+07
 585+ 15C3 52 C7 4F 80          defb    $52,$C7,$4F,$80 ; Last random number
 586+ 15C7 DB 00                in      A,($00)         ; INP (x) skeleton
 587+ 15C9 C9                   ret
 588+ 15CA FF                   defb    $FF             ; Terminal width (255 = no auto CRLF)
 589+ 15CB 14                   defb    $14             ; Width for commas (at reset, 3 columns, for G1 mode)
 590+ 15CC 00                   defb    $00             ; No nulls after input bytes
 591+ 15CD 00                   defb    $00             ; Output enabled (^O off)
 592+ 15CE 00 00                defw    $00             ; Array load/save check sum
 593+ 15D0 00                   defb    $00             ; Break not by NMI
 594+ 15D1 00                   defb    $00             ; Break flag
 595+ 15D2 C3 67 19             jp      TTYLIN          ; Input reflection (set to TTY)
 596+ 15D5 AA 82                defw    STLOOK          ; Temp string space
 597+ 15D7 FE FF                defw    -2              ; Current line number (cold)
 598+ 15D9 FF FF                defw    -1              ; Current line with errors (no errors)
 599+ 15DB 40           AUTORP: defb    $40             ; delay for key auto-repeat start
 600+ 15DC 08                   defb    $08             ; auto-repeat delay
 601+ 15DD 4C 49 53 54  DEFFNKS:defm    "LIST",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 1
 601+ 15E1 0D 00 00 00
 601+ 15E5 00 00 00 00
 601+ 15E9 00 00 00 00
 602+ 15ED 52 55 4E 0D          defm    "RUN",13,0,0,0,0,0,0,0,0,0,0,0,0    ; KEY 2
 602+ 15F1 00 00 00 00
 602+ 15F5 00 00 00 00
 602+ 15F9 00 00 00 00
 603+ 15FD 53 43 52 45          defm    "SCREEN1",13,0,0,0,0,0,0,0,0        ; KEY 3
 603+ 1601 45 4E 31 0D
 603+ 1605 00 00 00 00
 603+ 1609 00 00 00 00
 604+ 160D 43 4F 4C 4F          defm    "COLOR1,15,5",13,0,0,0,0            ; KEY 4
 604+ 1611 52 31 2C 31
 604+ 1615 35 2C 35 0D
 604+ 1619 00 00 00 00
 605+ 161D 53 45 52 49          defm    "SERIAL1,38400",13,0,0              ; KEY 5
 605+ 1621 41 4C 31 2C
 605+ 1625 33 38 34 30
 605+ 1629 30 0D 00 00
 606+ 162D 53 43 52 45          defm    "SCREEN2",13,0,0,0,0,0,0,0,0        ; KEY 6
 606+ 1631 45 4E 32 0D
 606+ 1635 00 00 00 00
 606+ 1639 00 00 00 00
 607+ 163D 43 4F 4E 54          defm    "CONT",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 7
 607+ 1641 0D 00 00 00
 607+ 1645 00 00 00 00
 607+ 1649 00 00 00 00
 608+ 164D 48 45 4C 50          defm    "HELP",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 8 (HELP KEY)
 608+ 1651 0D 00 00 00
 608+ 1655 00 00 00 00
 608+ 1659 00 00 00 00
 609+ 165D 47 82                defw    PROGST+1        ; Start of program text
 610+ 165F              INITBE:
 611+ 165F
 612+ 165F              ; END OF INITIALISATION TABLE ---------------------------------------------------
 613+ 165F
 614+ 165F 20 45 72 72  ERRMSG: defb    " Error",0
 614+ 1663 6F 72 00
 615+ 1666 20 69 6E 20  INMSG:  defb    " in ",0
 615+ 166A 00
 616+ 166B              ZERBYT  equ     $-1             ; A zero byte
 617+ 166B 4F 6B 0D 00  OKMSG:  defb    "Ok",CR,0,0
 617+ 166F 00
 618+ 1670 42 72 65 61  BRKMSG: defb    "Break",0
 618+ 1674 6B 00
 619+ 1676
 620+ 1676 21 04 00     BAKSTK: ld      HL,$04          ; Look for "FOR" block with
 621+ 1679 39                   add     HL,SP           ; same index as specified
 622+ 167A 7E           LOKFOR: ld      A,(HL)          ; Get block ID
 623+ 167B 23                   inc     HL              ; Point to index address
 624+ 167C FE 81                cp      ZFOR            ; Is it a "FOR" token
 625+ 167E C0                   ret     NZ              ; No - exit
 626+ 167F 4E                   ld      C,(HL)          ; BC = Address of "FOR" index
 627+ 1680 23                   inc     HL
 628+ 1681 46                   ld      B,(HL)
 629+ 1682 23                   inc     HL              ; Point to sign of STEP
 630+ 1683 E5                   push    HL              ; Save pointer to sign
 631+ 1684 69                   ld      L,C             ; HL = address of "FOR" index
 632+ 1685 60                   ld      H,B
 633+ 1686 7A                   ld      A,D             ; See if an index was specified
 634+ 1687 B3                   or      E               ; DE = 0 if no index specified
 635+ 1688 EB                   ex      DE,HL           ; Specified index into HL
 636+ 1689 CA 90 16             jp      Z,INDFND        ; Skip if no index given
 637+ 168C EB                   ex      DE,HL           ; Index back into DE
 638+ 168D CD E1 19             call    CPDEHL          ; Compare index with one given
 639+ 1690 01 0D 00     INDFND: ld      BC,16-3         ; Offset to next block
 640+ 1693 E1                   pop     HL              ; Restore pointer to sign
 641+ 1694 C8                   ret     Z               ; Return if block found
 642+ 1695 09                   add     HL,BC           ; Point to next block
 643+ 1696 C3 7A 16             jp      LOKFOR          ; Keep on looking
 644+ 1699
 645+ 1699 CD B3 16     MOVUP:  call    ENFMEM          ; See if enough memory
 646+ 169C C5           MOVSTR: push    BC              ; Save end of source
 647+ 169D E3                   ex      (SP),HL         ; Swap source and dest" end
 648+ 169E C1                   pop     BC              ; Get end of destination
 649+ 169F CD E1 19     MOVLP:  call    CPDEHL          ; See if list moved
 650+ 16A2 7E                   ld      A,(HL)          ; Get byte
 651+ 16A3 02                   ld      (BC),A          ; Move it
 652+ 16A4 C8                   ret     Z               ; Exit if all done
 653+ 16A5 0B                   dec     BC              ; Next byte to move to
 654+ 16A6 2B                   dec     HL              ; Next byte to move
 655+ 16A7 C3 9F 16             jp      MOVLP           ; Loop until all bytes moved
 656+ 16AA
 657+ 16AA E5           CHKSTK: push    HL              ; Save code string address
 658+ 16AB 2A 27 82             ld      HL,(ARREND)     ; Lowest free memory
 659+ 16AE 06 00                ld      B,$00           ; BC = Number of levels to test
 660+ 16B0 09                   add     HL,BC           ; 2 Bytes for each level
 661+ 16B1 09                   add     HL,BC
 662+ 16B2 3E                   defb    $3E             ; Skip "push HL"
 663+ 16B3 E5           ENFMEM: push    HL              ; Save code string address
 664+ 16B4 3E D0                ld      A,$D0           ; LOW -48 ; 48 Bytes minimum RAM
 665+ 16B6 95                   sub     L
 666+ 16B7 6F                   ld      L,A
 667+ 16B8 3E FF                ld      A,$FF           ; HIGH (-48) ; 48 Bytes minimum RAM
 668+ 16BA 9C                   sbc     A,H
 669+ 16BB DA C2 16             jp      C,OMERR         ; Not enough - ?OM Error
 670+ 16BE 67                   ld      H,A
 671+ 16BF 39                   add     HL,SP           ; Test if stack is overflowed
 672+ 16C0 E1                   pop     HL              ; Restore code string address
 673+ 16C1 D8                   ret     C               ; Return if enough memory
 674+ 16C2 1E 0C        OMERR:  ld      E,OM            ; ?OM Error
 675+ 16C4 C3 01 17             jp      ERROR
 676+ 16C7
 677+ 16C7
 678+ 16C7              ; if in graphics mode, return to text (called by "NOLIN" and "ERROR")
 679+ 16C7 F5           EXITGM: push    AF              ; store AF
 680+ 16C8 3A CF 81             ld      A,(SCR_MODE)    ; check screen mode
 681+ 16CB FE 02                cp      $02             ; G2?
 682+ 16CD CA D4 16             jp      Z,LDG1          ; yes, back to G1
 683+ 16D0 FE 03                cp      $03             ; G3?
 684+ 16D2 20 11                jr      NZ,LDG1ND       ; no, so return
 685+ 16D4 E5           LDG1:   push    HL              ; store HL
 686+ 16D5 D5                   push    DE              ; store DE
 687+ 16D6 11 01 00             ld      DE,$0001        ; sprites set to defaults, G1 mode
 688+ 16D9 F3                   di                      ; disable INTs
 689+ 16DA CD ED 03             call    initVDP         ; initialize VDP with mode pointed by E
 690+ 16DD FB                   ei                      ; re-enable INTs
 691+ 16DE 3E 01                ld      A,$01           ; activate the...
 692+ 16E0 32 D9 81             ld      (PRNTVIDEO),A   ; ...video buffer...
 693+ 16E3 D1                   pop     DE              ; retrieve DE
 694+ 16E4 E1                   pop     HL              ; retrieve HL
 695+ 16E5 F1           LDG1ND: pop     AF              ; retrieve AF
 696+ 16E6 C9                   ret                     ; return to caller
 697+ 16E7
 698+ 16E7
 699+ 16E7 2A B0 81     DATSNR: ld      HL,(DATLIN)     ; Get line of current DATA item
 700+ 16EA 22 AF 80             ld      (LINEAT),HL     ; Save as current line
 701+ 16ED 1E 02        SNERR:  ld      E,SN            ; ?SN Error
 702+ 16EF 01                   defb    $01             ; Skip "ld E,DZ"
 703+ 16F0 1E 14        DZERR:  ld      E,DZ            ; ?/0 Error
 704+ 16F2 01                   defb    $01             ; Skip "ld E,NF"
 705+ 16F3 1E 00        NFERR:  ld      E,NF            ; ?NF Error
 706+ 16F5 01                   defb    $01             ; Skip "ld E,DD"
 707+ 16F6 1E 12        DDERR:  ld      E,DD            ; ?DD Error
 708+ 16F8 01                   defb    $01             ; Skip "ld E,UF"
 709+ 16F9 1E 22        UFERR:  ld      E,UF            ; ?UF Error
 710+ 16FB 01                   defb    $01             ; Skip "ld E,OV
 711+ 16FC 1E 0A        OVERR:  ld      E,OV            ; ?OV Error
 712+ 16FE 01                   defb    $01             ; Skip "ld E,TM"
 713+ 16FF 1E 18        TMERR:  ld      E,TM            ; ?TM Error
 714+ 1701
 715+ 1701 CD 49 18     ERROR:  call    CLREG           ; Clear registers and stack
 716+ 1704 CD C7 16             call    EXITGM          ; exit from graphic modes
 717+ 1707 32 A5 80             ld      (CTLOFG),A      ; Enable output (A is 0)
 718+ 170A CD 38 09             call    CURSOR_ON       ; enable cursor
 719+ 170D CD EB 1E             call    STTLIN          ; Start new line
 720+ 1710 21 21 10             ld      HL,ERRTBL       ; Point to error codes
 721+ 1713 57                   ld      D,A             ; D = 0 (A is 0)
 722+ 1714 3E 3F                ld      A,'?'
 723+ 1716 CD F2 19             call    OUTC            ; Output '?'
 724+ 1719 19                   add     HL,DE           ; Offset to correct error code
 725+ 171A 5E                   ld      E,(HL)          ; load pointer to error message
 726+ 171B 23                   inc     HL              ; by loading LSB,
 727+ 171C 56                   ld      D,(HL)          ; then MSB
 728+ 171D 62 6B                ld      HL,DE           ; load pointer to HL
 729+ 171F CD C9 25             call    PRS             ; Output error message
 730+ 1722 21 5F 16             ld      HL,ERRMSG       ; "Error" message
 731+ 1725 CD C9 25     ERRIN:  call    PRS             ; Output message
 732+ 1728 2A AF 80             ld      HL,(LINEAT)     ; Get line of error
 733+ 172B 11 FE FF             ld      DE,-2           ; Cold start error if -2
 734+ 172E CD E1 19             call    CPDEHL          ; See if cold start error
 735+ 1731 CA 12 12             jp      Z,CSTART        ; Cold start error - Restart
 736+ 1734 7C                   ld      A,H             ; Was it a direct error?
 737+ 1735 A5                   and     L               ; Line = -1 if direct error
 738+ 1736 3C                   inc     A
 739+ 1737 CA 42 17             jp      Z,PTLN          ; Yes, jump over
 740+ 173A E5                   push    HL              ; indirect mode - store HL
 741+ 173B 2A AF 80             ld      HL,(LINEAT)     ; copy current line number
 742+ 173E 22 B1 80             ld      (HLPLN),HL      ; save in HELP line register
 743+ 1741 E1                   pop     HL              ; retrieve HL
 744+ 1742 C4 60 30     PTLN:   call    NZ,LINEIN       ; No - output line of error
 745+ 1745
 746+ 1745 3E                   defb    $3E             ; Skip "pop BC"
 747+ 1746 C1           POPNOK: pop     BC              ; Drop address in input buffer
 748+ 1747
 749+ 1747              ; run into direct mode: print OK and get command
 750+ 1747 AF           PRNTOK: xor     A               ; Output "Ok" and get command
 751+ 1748 32 A5 80             ld      (CTLOFG),A      ; Enable output
 752+ 174B CD EB 1E             call    STTLIN          ; Start new line
 753+ 174E 21 6B 16             ld      HL,OKMSG        ; "Ok" message
 754+ 1751 CD C9 25             call    PRS             ; Output "Ok"
 755+ 1754 CD 38 09     GETCMD: call    CURSOR_ON       ; enable cursor
 756+ 1757 3A 1F 82             ld      A,(SERIALS_EN)  ; load serial state
 757+ 175A EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
 758+ 175C CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
 759+ 175F 21 FF FF             ld      HL,-1           ; Flag direct mode
 760+ 1762 22 AF 80             ld      (LINEAT),HL     ; Save as current line
 761+ 1765 CD 67 19             call    GETLIN          ; Get an input line
 762+ 1768 DA 54 17             jp      C,GETCMD        ; Get line again if break
 763+ 176B CD 30 1C             call    GETCHR          ; Get first character
 764+ 176E 17                   rla                     ; 8th bit is copied into carry and original carry is copied into bit 0)
 765+ 176F DA ED 16             jp      C,SNERR         ; if char >=128 (8th bit set) then raise an error
 766+ 1772 1F                   rra                     ; recover original char and Carry
 767+ 1773 3C                   inc     A               ; Test if end of line
 768+ 1774 3D                   dec     A               ; Without affecting Carry
 769+ 1775 CA 54 17             jp      Z,GETCMD        ; Nothing entered - Get another
 770+ 1778 F5                   push    AF              ; Save Carry status
 771+ 1779 3A 1F 82             ld      A,(SERIALS_EN)  ; load serial state
 772+ 177C EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
 773+ 177E CC 8F 01             call    Z,A_RTS_OFF      ; yes, set RTS on
 774+ 1781 CD 4D 09             call    CURSOR_OFF      ; cursor disabled
 775+ 1784 CD 00 1D             call    ATOH            ; Get line number into DE
 776+ 1787 D5                   push    DE              ; Save line number
 777+ 1788 CD 7E 18             call    CRUNCH          ; Tokenise rest of line
 778+ 178B 47                   ld      B,A             ; Length of tokenised line
 779+ 178C D1                   pop     DE              ; Restore line number
 780+ 178D F1                   pop     AF              ; Restore Carry
 781+ 178E D2 10 1C             jp      NC,EXCUTE       ; No line number - Direct mode
 782+ 1791 D5                   push    DE              ; Save line number
 783+ 1792 C5                   push    BC              ; Save length of tokenised line
 784+ 1793 AF                   xor     A
 785+ 1794 32 B3 81             ld      (LSTBIN),A      ; Clear last byte input
 786+ 1797 CD 30 1C             call    GETCHR          ; Get next character
 787+ 179A B7                   or      A               ; Set flags
 788+ 179B F5                   push    AF              ; And save them
 789+ 179C CD 03 18             call    SRCHLN          ; Search for line number in DE
 790+ 179F DA A8 17             jp      C,LINFND        ; Jump if line found
 791+ 17A2 F1                   pop     AF              ; Get status
 792+ 17A3 F5                   push    AF              ; And re-save
 793+ 17A4 CA AF 1D             jp      Z,ULERR         ; Nothing after number - Error
 794+ 17A7 B7                   or      A               ; Clear Carry
 795+ 17A8 C5           LINFND: push    BC              ; Save address of line in prog
 796+ 17A9 D2 BF 17             jp      NC,INEWLN       ; Line not found - Insert new
 797+ 17AC EB                   ex      DE,HL           ; Next line address in DE
 798+ 17AD 2A 23 82             ld      HL,(PROGND)     ; End of program
 799+ 17B0 1A           SFTPRG: ld      A,(DE)          ; Shift rest of program down
 800+ 17B1 02                   ld      (BC),A
 801+ 17B2 03                   inc     BC              ; Next destination
 802+ 17B3 13                   inc     DE              ; Next source
 803+ 17B4 CD E1 19             call    CPDEHL          ; All done?
 804+ 17B7 C2 B0 17             jp      NZ,SFTPRG       ; More to do
 805+ 17BA 60                   ld      H,B             ; HL - New end of program
 806+ 17BB 69                   ld      L,C
 807+ 17BC 22 23 82             ld      (PROGND),HL     ; Update end of program
 808+ 17BF
 809+ 17BF D1           INEWLN: pop     DE              ; Get address of line,
 810+ 17C0 F1                   pop     AF              ; Get status
 811+ 17C1 CA E6 17             jp      Z,SETPTR        ; No text - Set up pointers
 812+ 17C4 2A 23 82             ld      HL,(PROGND)     ; Get end of program
 813+ 17C7 E3                   ex      (SP),HL         ; Get length of input line
 814+ 17C8 C1                   pop     BC              ; End of program to BC
 815+ 17C9 09                   add     HL,BC           ; Find new end
 816+ 17CA E5                   push    HL              ; Save new end
 817+ 17CB CD 99 16             call    MOVUP           ; Make space for line
 818+ 17CE E1                   pop     HL              ; Restore new end
 819+ 17CF 22 23 82             ld      (PROGND),HL     ; Update end of program pointer
 820+ 17D2 EB                   ex      DE,HL           ; Get line to move up in HL
 821+ 17D3 74                   ld      (HL),H          ; Save MSB
 822+ 17D4 D1                   pop     DE              ; Get new line number
 823+ 17D5 23                   inc     HL              ; Skip pointer
 824+ 17D6 23                   inc     HL
 825+ 17D7 73                   ld      (HL),E          ; Save LSB of line number
 826+ 17D8 23                   inc     HL
 827+ 17D9 72                   ld      (HL),D          ; Save MSB of line number
 828+ 17DA 23                   inc     HL              ; To first byte in line
 829+ 17DB 11 38 81             ld      DE,BUFFER       ; Copy buffer to program
 830+ 17DE 1A           MOVBUF: ld      A,(DE)          ; Get source
 831+ 17DF 77                   ld      (HL),A          ; Save destinations
 832+ 17E0 23                   inc     HL              ; Next source
 833+ 17E1 13                   inc     DE              ; Next destination
 834+ 17E2 B7                   or      A               ; Done?
 835+ 17E3 C2 DE 17             jp      NZ,MOVBUF       ; No - Repeat
 836+ 17E6 CD 2F 18     SETPTR: call    RUNFST          ; Set line pointers
 837+ 17E9 23                   inc     HL              ; To LSB of pointer
 838+ 17EA EB                   ex      DE,HL           ; Address to DE
 839+ 17EB 62           PTRLP:  ld      H,D             ; Address to HL
 840+ 17EC 6B                   ld      L,E
 841+ 17ED 7E                   ld      A,(HL)          ; Get LSB of pointer
 842+ 17EE 23                   inc     HL              ; To MSB of pointer
 843+ 17EF B6                   or      (HL)            ; Compare with MSB pointer
 844+ 17F0 CA 54 17             jp      Z,GETCMD        ; Get command line if end
 845+ 17F3 23                   inc     HL              ; To LSB of line number
 846+ 17F4 23                   inc     HL              ; Skip line number
 847+ 17F5 23                   inc     HL              ; Point to first byte in line
 848+ 17F6 AF                   xor     A               ; Looking for 00 byte
 849+ 17F7 BE           FNDEND: cp      (HL)            ; Found end of line?
 850+ 17F8 23                   inc     HL              ; Move to next byte
 851+ 17F9 C2 F7 17             jp      NZ,FNDEND       ; No - Keep looking
 852+ 17FC EB                   ex      DE,HL           ; Next line address to HL
 853+ 17FD 73                   ld      (HL),E          ; Save LSB of pointer
 854+ 17FE 23                   inc     HL
 855+ 17FF 72                   ld      (HL),D          ; Save MSB of pointer
 856+ 1800 C3 EB 17             jp      PTRLP           ; Do next line
 857+ 1803
 858+ 1803 2A 35 81     SRCHLN: ld      HL,(BASTXT)     ; Start of program text
 859+ 1806 44           SRCHLP: ld      B,H             ; BC = Address to look at
 860+ 1807 4D                   ld      C,L
 861+ 1808 7E                   ld      A,(HL)          ; Get address of next line
 862+ 1809 23                   inc     HL
 863+ 180A B6                   or      (HL)            ; End of program found?
 864+ 180B 2B                   dec     HL
 865+ 180C C8                   ret     Z               ; Yes - Line not found
 866+ 180D 23                   inc     HL
 867+ 180E 23                   inc     HL
 868+ 180F 7E                   ld      A,(HL)          ; Get LSB of line number
 869+ 1810 23                   inc     HL
 870+ 1811 66                   ld      H,(HL)          ; Get MSB of line number
 871+ 1812 6F                   ld      L,A
 872+ 1813 CD E1 19             call    CPDEHL          ; Compare with line in DE
 873+ 1816 60                   ld      H,B             ; HL = Start of this line
 874+ 1817 69                   ld      L,C
 875+ 1818 7E                   ld      A,(HL)          ; Get LSB of next line address
 876+ 1819 23                   inc     HL
 877+ 181A 66                   ld      H,(HL)          ; Get MSB of next line address
 878+ 181B 6F                   ld      L,A             ; Next line to HL
 879+ 181C 3F                   ccf
 880+ 181D C8                   ret     Z               ; Lines found - Exit
 881+ 181E 3F                   ccf
 882+ 181F D0                   ret     NC              ; Line not found,at line after
 883+ 1820 C3 06 18             jp      SRCHLP          ; Keep looking
 884+ 1823
 885+ 1823 C0           NEW:    ret     NZ              ; Return if any more on line
 886+ 1824 2A 35 81     CLRPTR: ld      HL,(BASTXT)     ; Point to start of program
 887+ 1827 AF                   xor     A               ; Set program area to empty
 888+ 1828 77                   ld      (HL),A          ; Save LSB = 00
 889+ 1829 23                   inc     HL
 890+ 182A 77                   ld      (HL),A          ; Save MSB = 00
 891+ 182B 23                   inc     HL
 892+ 182C 22 23 82             ld      (PROGND),HL     ; Set program end
 893+ 182F
 894+ 182F 2A 35 81     RUNFST: ld      HL,(BASTXT)     ; Clear all variables
 895+ 1832 2B                   dec     HL
 896+ 1833
 897+ 1833 22 B5 81     INTVAR: ld      (BRKLIN),HL     ; Initialise RUN variables
 898+ 1836 2A 96 81             ld      HL,(LSTRAM)     ; Get end of RAM
 899+ 1839 22 AA 81             ld      (STRBOT),HL     ; Clear string space
 900+ 183C AF                   xor     A
 901+ 183D CD 40 1C             call    RESTOR          ; Reset DATA pointers
 902+ 1840 2A 23 82             ld      HL,(PROGND)     ; Get end of program
 903+ 1843 22 25 82             ld      (VAREND),HL     ; Clear variables
 904+ 1846 22 27 82             ld      (ARREND),HL     ; Clear arrays
 905+ 1849
 906+ 1849 C1           CLREG:  pop     BC              ; Save return address
 907+ 184A 2A AD 80             ld      HL,(STRSPC)     ; Get end of working RAM
 908+ 184D F9                   ld      SP,HL           ; Set stack
 909+ 184E 21 9A 81             ld      HL,TMSTPL       ; Temporary string pool
 910+ 1851 22 98 81             ld      (TMSTPT),HL     ; Reset temporary string ptr
 911+ 1854 AF                   xor     A               ; A = 00
 912+ 1855 6F                   ld      L,A             ; HL = 0000
 913+ 1856 67                   ld      H,A
 914+ 1857 22 BB 81             ld      (CONTAD),HL     ; No CONTinue
 915+ 185A 32 B2 81             ld      (FORFLG),A      ; Clear FOR flag
 916+ 185D 22 2B 82             ld      (FNRGNM),HL     ; Clear FN argument
 917+ 1860 E5                   push    HL              ; HL = 0000
 918+ 1861 C5                   push    BC              ; Put back return
 919+ 1862 2A B5 81     DOAGN:  ld      HL,(BRKLIN)     ; Get address of code to RUN
 920+ 1865 C9                   ret                     ; Return to execution driver
 921+ 1866
 922+ 1866 3E 3F        PROMPT: ld      A,'?'           ; '?'
 923+ 1868 CD F2 19             call    OUTC            ; Output character
 924+ 186B 3E 00                ld      A,NLLCR         ; null char
 925+ 186D CD F2 19             call    OUTC            ; Output character
 926+ 1870 CD 38 09             call    CURSOR_ON       ; enable cursor
 927+ 1873 3A 1F 82             ld      A,(SERIALS_EN)  ; load serial state
 928+ 1876 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
 929+ 1878 CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
 930+ 187B C3 AA 80             jp      RINPUT          ; Get input line
 931+ 187E
 932+ 187E AF           CRUNCH: xor     A               ; Tokenise line @ HL to BUFFER
 933+ 187F 32 95 81             ld      (DATFLG),A      ; Reset literal flag
 934+ 1882 0E 05                ld      C,2+3           ; 2 byte number and 3 nulls
 935+ 1884 11 38 81             ld      DE,BUFFER       ; Start of input buffer
 936+ 1887 7E           CRNCLP: ld      A,(HL)          ; Get byte
 937+ 1888 FE 20                cp      SPC             ; Is it a space?
 938+ 188A CA 06 19             jp      Z,MOVDIR        ; Yes - Copy direct
 939+ 188D 47                   ld      B,A             ; Save character
 940+ 188E FE 22                cp      $22             ; '"'             ; Is it a quote?
 941+ 1890 CA 26 19             jp      Z,CPYLIT        ; Yes - Copy literal string
 942+ 1893 B7                   or      A               ; Is it end of buffer?
 943+ 1894 CA 2D 19             jp      Z,ENDBUF        ; Yes - End buffer
 944+ 1897 3A 95 81             ld      A,(DATFLG)      ; Get data type
 945+ 189A B7                   or      A               ; Literal?
 946+ 189B 7E                   ld      A,(HL)          ; Get byte to copy
 947+ 189C C2 06 19             jp      NZ,MOVDIR       ; Literal - Copy direct
 948+ 189F FE 3F                cp      '?'             ; Is it '?' short for PRINT
 949+ 18A1 3E AF                ld      A,ZPRINT        ; "PRINT" token
 950+ 18A3 CA 06 19             jp      Z,MOVDIR        ; Yes - replace it
 951+ 18A6 7E                   ld      A,(HL)          ; Get byte again
 952+ 18A7 FE 30                cp      '0'             ; Is it less than '0'
 953+ 18A9 DA B1 18             jp      C,FNDWRD        ; Yes - Look for reserved words
 954+ 18AC FE 3C                cp      $3C  ;60; ";"+1       ; Is it "0123456789:;" ?
 955+ 18AE DA 06 19             jp      C,MOVDIR        ; Yes - copy it direct
 956+ 18B1 D5           FNDWRD: push    DE              ; Look for reserved words
 957+ 18B2 11 6E 13             ld      DE,WORDS-1      ; Point to table
 958+ 18B5 C5                   push    BC              ; Save count
 959+ 18B6 01 02 19             ld      BC,RETNAD       ; Where to return to
 960+ 18B9 C5                   push    BC              ; Save return address
 961+ 18BA 06 7F                ld      B,ZEND-1        ; First token value -1
 962+ 18BC 7E                   ld      A,(HL)          ; Get byte
 963+ 18BD FE 61                cp      'a'             ; Less than 'a' ?
 964+ 18BF DA CA 18             jp      C,SEARCH        ; Yes - search for words
 965+ 18C2 FE 7B                cp      'z'+1           ; Greater than 'z' ?
 966+ 18C4 D2 CA 18             jp      NC,SEARCH       ; Yes - search for words
 967+ 18C7 E6 5F                and     %01011111       ; Force upper case
 968+ 18C9 77                   ld      (HL),A          ; Replace byte
 969+ 18CA 4E           SEARCH: ld      C,(HL)          ; Search for a word
 970+ 18CB EB                   ex      DE,HL
 971+ 18CC 23           GETNXT: inc     HL              ; Get next reserved word
 972+ 18CD B6                   or      (HL)            ; Start of word?
 973+ 18CE F2 CC 18             jp      P,GETNXT        ; No - move on
 974+ 18D1 04                   inc     B               ; Increment token value
 975+ 18D2 7E                   ld      A,(HL)          ; Get byte from table
 976+ 18D3 E6 7F                and     %01111111       ; Strip bit 7
 977+ 18D5 C8                   ret     Z               ; Return if end of list
 978+ 18D6 B9                   cp      C               ; Same character as in buffer?
 979+ 18D7 C2 CC 18             jp      NZ,GETNXT       ; No - get next word
 980+ 18DA EB                   ex      DE,HL
 981+ 18DB E5                   push    HL              ; Save start of word
 982+ 18DC
 983+ 18DC 13           NXTBYT: inc     DE              ; Look through rest of word
 984+ 18DD 1A                   ld      A,(DE)          ; Get byte from table
 985+ 18DE B7                   or      A               ; End of word ?
 986+ 18DF FA FE 18             jp      M,MATCH         ; Yes - Match found
 987+ 18E2 4F                   ld      C,A             ; Save it
 988+ 18E3 78                   ld      A,B             ; Get token value
 989+ 18E4 FE 88                cp      ZGOTO           ; Is it "GOTO" token ?
 990+ 18E6 C2 ED 18             jp      NZ,NOSPC        ; No - Don't allow spaces
 991+ 18E9 CD 30 1C             call    GETCHR          ; Get next character
 992+ 18EC 2B                   dec     HL              ; Cancel increment from GETCHR
 993+ 18ED 23           NOSPC:  inc     HL              ; Next byte
 994+ 18EE 7E                   ld      A,(HL)          ; Get byte
 995+ 18EF FE 61                cp      'a'             ; Less than 'a' ?
 996+ 18F1 DA F6 18             jp      C,NOCHNG        ; Yes - don't change
 997+ 18F4 E6 5F                and     %01011111       ; Make upper case
 998+ 18F6 B9           NOCHNG: cp      C               ; Same as in buffer ?
 999+ 18F7 CA DC 18             jp      Z,NXTBYT        ; Yes - keep testing
1000+ 18FA E1                   pop     HL              ; Get back start of word
1001+ 18FB C3 CA 18             jp      SEARCH          ; Look at next word
1002+ 18FE
1003+ 18FE 48           MATCH:  ld      C,B             ; Word found - Save token value
1004+ 18FF F1                   pop     AF              ; Throw away return
1005+ 1900 EB                   ex      DE,HL
1006+ 1901 C9                   ret                     ; Return to "RETNAD"
1007+ 1902 EB           RETNAD: ex      DE,HL           ; Get address in string
1008+ 1903 79                   ld      A,C             ; Get token value
1009+ 1904 C1                   pop     BC              ; Restore buffer length
1010+ 1905 D1                   pop     DE              ; Get destination address
1011+ 1906 23           MOVDIR: inc     HL              ; Next source in buffer
1012+ 1907 12                   ld      (DE),A          ; Put byte in buffer
1013+ 1908 13                   inc     DE              ; Move up buffer
1014+ 1909 0C                   inc     C               ; Increment length of buffer
1015+ 190A D6 3A                sub     ':'             ; End of statement?
1016+ 190C CA 14 19             jp      Z,SETLIT        ; Jump if multi-statement line
1017+ 190F FE 49                cp      ZDATA-$3A       ; Is it DATA statement ?
1018+ 1911 C2 17 19             jp      NZ,TSTREM       ; No - see if REM
1019+ 1914 32 95 81     SETLIT: ld      (DATFLG),A      ; Set literal flag
1020+ 1917 D6 54        TSTREM: sub     ZREM-$3A        ; Is it REM?
1021+ 1919 C2 87 18             jp      NZ,CRNCLP       ; No - Leave flag
1022+ 191C 47                   ld      B,A             ; Copy rest of buffer
1023+ 191D 7E           NXTCHR: ld      A,(HL)          ; Get byte
1024+ 191E B7                   or      A               ; End of line ?
1025+ 191F CA 2D 19             jp      Z,ENDBUF        ; Yes - Terminate buffer
1026+ 1922 B8                   cp      B               ; End of statement ?
1027+ 1923 CA 06 19             jp      Z,MOVDIR        ; Yes - Get next one
1028+ 1926 23           CPYLIT: inc     HL              ; Move up source string
1029+ 1927 12                   ld      (DE),A          ; Save in destination
1030+ 1928 0C                   inc     C               ; Increment length
1031+ 1929 13                   inc     DE              ; Move up destination
1032+ 192A C3 1D 19             jp      NXTCHR          ; Repeat
1033+ 192D
1034+ 192D 21 37 81     ENDBUF: ld      HL,BUFFER-1     ; Point to start of buffer
1035+ 1930 12                   ld      (DE),A          ; Mark end of buffer (A = 00)
1036+ 1931 13                   inc     DE
1037+ 1932 12                   ld      (DE),A          ; A = 00
1038+ 1933 13                   inc     DE
1039+ 1934 12                   ld      (DE),A          ; A = 00
1040+ 1935 C9                   ret
1041+ 1936
1042+ 1936 3A A4 80     DODEL:  ld      A,(NULFLG)      ; Get null flag status
1043+ 1939 B7                   or      A               ; Is it zero?
1044+ 193A 3E 00                ld      A,$00           ; Zero A - Leave flags
1045+ 193C 32 A4 80             ld      (NULFLG),A      ; Zero null flag
1046+ 193F C2 4A 19             jp      NZ,ECHDEL       ; Set - Echo it
1047+ 1942 05                   dec     B               ; Decrement length
1048+ 1943 CA 67 19             jp      Z,GETLIN        ; Get line again if empty
1049+ 1946 CD F2 19             call    OUTC            ; Output null character
1050+ 1949 3E                   defb    $3E             ; Skip "dec B"
1051+ 194A 05           ECHDEL: dec     B               ; Count bytes in buffer
1052+ 194B 2B                   dec     HL              ; Back space buffer
1053+ 194C CA 5E 19             jp      Z,OTKLN         ; No buffer - Try again
1054+ 194F 7E                   ld      A,(HL)          ; Get deleted byte
1055+ 1950 CD F2 19             call    OUTC            ; Echo it
1056+ 1953 C3 70 19             jp      MORINP          ; Get more input
1057+ 1956
1058+ 1956 05           DELCHR: dec     B               ; Count bytes in buffer
1059+ 1957 2B                   dec     HL              ; Back space buffer
1060+ 1958 CD F2 19             call    OUTC            ; Output character in A
1061+ 195B C2 70 19             jp      NZ,MORINP       ; Not end - Get more
1062+ 195E CD F2 19     OTKLN:  call    OUTC            ; Output character in A
1063+ 1961 CD FD 1E     KILIN:  call    PRNTCRLF        ; Output CRLF
1064+ 1964 C3 67 19             jp      TTYLIN          ; Get line again
1065+ 1967
1066+ 1967              GETLIN:
1067+ 1967 21 38 81     TTYLIN: ld      HL,BUFFER       ; Get a line by character
1068+ 196A 06 01                ld      B,$01           ; Set buffer as empty
1069+ 196C AF                   xor     A
1070+ 196D 32 A4 80             ld      (NULFLG),A      ; Clear null flag
1071+ 1970 CD 33 1A     MORINP: call    CLOTST          ; Get character and test ^O
1072+ 1973 4F                   ld      C,A             ; Save character in C
1073+ 1974 FE 7F                cp      DEL             ; Delete character?
1074+ 1976 CA 36 19             jp      Z,DODEL         ; Yes - Process it
1075+ 1979 3A A4 80             ld      A,(NULFLG)      ; Get null flag
1076+ 197C B7                   or      A               ; Test null flag status
1077+ 197D CA 89 19             jp      Z,PROCES        ; Reset - Process character
1078+ 1980 3E 00                ld      A,$00           ; Set a null
1079+ 1982 CD F2 19             call    OUTC            ; Output null
1080+ 1985 AF                   xor     A               ; Clear A
1081+ 1986 32 A4 80             ld      (NULFLG),A      ; Reset null flag
1082+ 1989 79           PROCES: ld      A,C             ; Get character
1083+ 198A FE 07                cp      CTRLG           ; Bell?
1084+ 198C CA C9 19             jp      Z,PUTCTL        ; Yes - Save it
1085+ 198F FE 03                cp      CTRLC           ; Is it control "C"?
1086+ 1991 CC BE 19             call    Z,GMNCR         ; Yes - exit from graphic mode & Output CRLF
1087+ 1994 37                   scf                     ; Flag break
1088+ 1995 C8                   ret     Z               ; Return if control "C"
1089+ 1996 FE 0D                cp      CR              ; Is it enter?
1090+ 1998 CA F3 1E             jp      Z,ENDINP        ; Yes - Terminate input
1091+ 199B FE 15                cp      CTRLU           ; Is it control "U"?
1092+ 199D CA 61 19             jp      Z,KILIN         ; Yes - Get another line
1093+ 19A0 FE 08                cp      BKSP            ; Is it backspace?
1094+ 19A2 CA 56 19             jp      Z,DELCHR        ; Yes - Delete character
1095+ 19A5 FE 12                cp      CTRLR           ; Is it control "R"?
1096+ 19A7 C2 C4 19             jp      NZ,PUTBUF       ; No - Put in buffer
1097+ 19AA C5                   push    BC              ; Save buffer length
1098+ 19AB D5                   push    DE              ; Save DE
1099+ 19AC E5                   push    HL              ; Save buffer address
1100+ 19AD 36 00                ld      (HL),$00        ; Mark end of buffer
1101+ 19AF CD FE 3F             call    OUTNCR          ; Output and do CRLF
1102+ 19B2 21 38 81             ld      HL,BUFFER       ; Point to buffer start
1103+ 19B5 CD C9 25             call    PRS             ; Output buffer
1104+ 19B8 E1                   pop     HL              ; Restore buffer address
1105+ 19B9 D1                   pop     DE              ; Restore DE
1106+ 19BA C1                   pop     BC              ; Restore buffer length
1107+ 19BB C3 70 19             jp      MORINP          ; Get another character
1108+ 19BE CD C7 16     GMNCR:  call    EXITGM          ; exit from graphic mode
1109+ 19C1 C3 FD 1E             jp      PRNTCRLF        ; output CRLF
1110+ 19C4
1111+ 19C4 FE 20        PUTBUF: cp      SPC             ; Is it a control code?
1112+ 19C6 DA 70 19             jp      C,MORINP        ; Yes - Ignore
1113+ 19C9 78           PUTCTL: ld      A,B             ; Get number of bytes in buffer
1114+ 19CA FE 59                cp      $58+$01         ; Test for line overflow
1115+ 19CC 3E 08                ld      A,BKSP          ; Set a bell
1116+ 19CE D2 DB 19             jp      NC,OUTNBS       ; Ring bell if buffer full
1117+ 19D1 79                   ld      A,C             ; Get character
1118+ 19D2 71                   ld      (HL),C          ; Save in buffer
1119+ 19D3 32 B3 81             ld      (LSTBIN),A      ; Save last input byte
1120+ 19D6 23                   inc     HL              ; Move up buffer
1121+ 19D7 04                   inc     B               ; Increment length
1122+ 19D8 C3 70 19     OUTIT:  jp      MORINP          ; Get another character
1123+ 19DB
1124+ 19DB CD F2 19     OUTNBS: call    OUTC            ; Output bell and back over it
1125+ 19DE C3 D8 19             jp      OUTIT           ; get more chars
1126+ 19E1
1127+ 19E1 7C           CPDEHL: ld      A,H             ; Get H
1128+ 19E2 92                   sub     D               ; Compare with D
1129+ 19E3 C0                   ret     NZ              ; Different - Exit
1130+ 19E4 7D                   ld      A,L             ; Get L
1131+ 19E5 93                   sub     E               ; Compare with E
1132+ 19E6 C9                   ret                     ; Return status
1133+ 19E7
1134+ 19E7 7E           CHKSYN: ld      A,(HL)          ; Check syntax of character
1135+ 19E8 E3                   ex      (SP),HL         ; Address of test byte
1136+ 19E9 BE                   cp      (HL)            ; Same as in code string?
1137+ 19EA 23                   inc     HL              ; Return address
1138+ 19EB E3                   ex      (SP),HL         ; Put it back
1139+ 19EC CA 30 1C             jp      Z,GETCHR        ; Yes - Get next character
1140+ 19EF C3 ED 16             jp      SNERR           ; Different - ?SN Error
1141+ 19F2
1142+ 19F2 F5           OUTC:   push    AF              ; Save character
1143+ 19F3 3A A5 80             ld      A,(CTLOFG)      ; Get control "O" flag
1144+ 19F6 B7                   or      A               ; Is it set?
1145+ 19F7 C2 FE 25             jp      NZ,POPAF        ; Yes - don't output
1146+ 19FA F1                   pop     AF              ; Restore character
1147+ 19FB C5                   push    BC              ; Save buffer length
1148+ 19FC F5                   push    AF              ; Save character
1149+ 19FD FE 20                cp      SPC             ; Is it a control code?
1150+ 19FF DA 16 1A             jp      C,DINPOS        ; Yes - Don't inc POS(X)
1151+ 1A02 3A A2 80             ld      A,(LWIDTH)      ; Get line width
1152+ 1A05 47                   ld      B,A             ; To B
1153+ 1A06 3A 92 81             ld      A,(CURPOS)      ; Get cursor position
1154+ 1A09 04                   inc     B               ; Width 255?
1155+ 1A0A CA 12 1A             jp      Z,INCLEN        ; Yes - No width limit
1156+ 1A0D 05                   dec     B               ; Restore width
1157+ 1A0E B8                   cp      B               ; At end of line?
1158+ 1A0F CC FD 1E             call    Z,PRNTCRLF      ; Yes - output CRLF
1159+ 1A12 3C           INCLEN: inc     A               ; Move on one character
1160+ 1A13 32 92 81             ld      (CURPOS),A      ; Save new position
1161+ 1A16 AF           DINPOS: xor     A
1162+ 1A17 32 17 82             ld      (KBDNPT),A      ; set flag for no char from keyboard
1163+ 1A1A F1                   pop     AF              ; Restore character
1164+ 1A1B C1                   pop     BC              ; Restore buffer length
1165+ 1A1C F5                   push    AF
1166+ 1A1D CD 25 1A             call    SND2VID         ; send char to video
1167+ 1A20 F1                   pop     AF
1168+ 1A21 CD DD 3F             call    MONOUT          ; send char to serial if enabled
1169+ 1A24 C9                   ret
1170+ 1A25
1171+ 1A25              ; print char to video if cursor is on
1172+ 1A25 32 DA 81     SND2VID:ld      (CHR4VID),A     ; store A
1173+ 1A28 3A D9 81             ld      A,(PRNTVIDEO)   ; check print-on-video
1174+ 1A2B B7                   or      A               ; is it off?
1175+ 1A2C C8                   ret     Z               ; yes, so return
1176+ 1A2D F3                   di                      ; disable INTs
1177+ 1A2E CD 6C 07             call    CHAR2VID        ; cursor is on, so print char on screen
1178+ 1A31 FB                   ei                      ; re-enable INTs
1179+ 1A32 C9                   ret                     ; return to caller
1180+ 1A33
1181+ 1A33 CD 84 33     CLOTST: call    GETINP          ; Get input character
1182+ 1A36 FE 0F                cp      CTRLO           ; Is it control "O"?
1183+ 1A38 C0                   ret     NZ              ; No don't flip flag
1184+ 1A39 3A A5 80             ld      A,(CTLOFG)      ; Get flag
1185+ 1A3C 2F                   cpl                     ; Flip it
1186+ 1A3D 32 A5 80             ld      (CTLOFG),A      ; Put it back
1187+ 1A40 A7                   and     A               ; is output enabled?
1188+ 1A41 CC 38 09             call    Z,CURSOR_ON     ; yes, so cursor on
1189+ 1A44 3A 1F 82             ld      A,(SERIALS_EN)  ; load serial state
1190+ 1A47 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
1191+ 1A49 CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
1192+ 1A4C AF                   xor     A               ; Null character
1193+ 1A4D C9                   ret
1194+ 1A4E
1195+ 1A4E              ; LIST: list the program stored into memory
1196+ 1A4E C1           LIST:   pop     BC              ; rubbish - not needed (legacy from original call of LIST)
1197+ 1A4F 2B                   dec     HL              ; dec 'cos GETCHR INCs
1198+ 1A50 CD 30 1C             call    GETCHR          ; Get next character
1199+ 1A53 CA A9 1A             jp      Z,LSTALL        ; list all if nothing follows
1200+ 1A56 FE BE                cp      ZMINUS          ; is it '-'?
1201+ 1A58 20 20                jr      NZ,LST01        ; no, look for a line number
1202+ 1A5A 11 00 00             ld      DE,$0000        ; yes, set search from 0
1203+ 1A5D CD 4A 1B             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1204+ 1A60 ED 43 DD 81          ld      (TMPBFR1),BC    ; store address of starting line
1205+ 1A64 CD E7 19             call    CHKSYN          ; skip '-'
1206+ 1A67 BE                   defb    ZMINUS
1207+ 1A68 CD 00 1D             call    ATOH            ; now, look for another number (ASCII number to DE)
1208+ 1A6B CD 50 1B             call    SRCLN           ; find a line, getting the previous if it doesn't exist
1209+ 1A6E ED 43 DF 81          ld      (TMPBFR2),BC    ; store address of ending line
1210+ 1A72 ED 4B DD 81          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1211+ 1A76 C5                   push    BC              ; store address of line for later use
1212+ 1A77 C3 E1 1A             jp      LISTLP          ; go listing
1213+ 1A7A CD 00 1D     LST01:  call    ATOH            ; get a line number (ASCII number to DE)
1214+ 1A7D ED 53 E3 81  LST01H: ld      (TMPBFR4),DE    ; store ending line address for later use - N.B.: this is a hook for HELP command
1215+ 1A81 CD 4A 1B             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1216+ 1A84 ED 43 DD 81          ld      (TMPBFR1),BC    ; store address of starting line
1217+ 1A88 ED 43 DF 81          ld      (TMPBFR2),BC    ; same address for ending line (we'll change it later if needed)
1218+ 1A8C 2B                   dec     HL              ; dec 'cos GETCHR INCs
1219+ 1A8D CD 30 1C             call    GETCHR          ; Get next character
1220+ 1A90 CA 9C 1A             jp      Z,LSTNOT        ; nothing follows, so ending & starting lines are the same
1221+ 1A93 FE BE                cp      ZMINUS          ; is it '-'?
1222+ 1A95 CA C1 1A             jp      Z,LST03         ; yes, read ending line
1223+ 1A98 C5           LST06:  push    BC              ; store address for later use
1224+ 1A99 C3 E1 1A             jp      LISTLP          ; jump to list
1225+ 1A9C ED 5B E3 81  LSTNOT: ld      DE,(TMPBFR4)
1226+ 1AA0 CD 4A 1B             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1227+ 1AA3 DA 98 1A             jp      C,LST06
1228+ 1AA6 C3 47 17             jp      PRNTOK
1229+ 1AA9 11 F9 FF     LSTALL: ld      DE,65529        ; set ending line to max. allowed line number
1230+ 1AAC CD 4A 1B             call    SRCHLIN         ; get address of last line
1231+ 1AAF ED 43 DF 81          ld      (TMPBFR2),BC    ; store it
1232+ 1AB3 11 00 00             ld      DE,$0000        ; set start to first line in memory
1233+ 1AB6 CD 4A 1B             call    SRCHLIN         ; get address of first line
1234+ 1AB9 ED 43 DD 81          ld      (TMPBFR1),BC    ; store it
1235+ 1ABD C5                   push    BC              ; store address of starting line for later use
1236+ 1ABE C3 E1 1A             jp      LISTLP          ; start printing
1237+ 1AC1 CD E7 19     LST03:  call    CHKSYN          ; skip '-'
1238+ 1AC4 BE                   defb    ZMINUS
1239+ 1AC5 CD 00 1D             call    ATOH            ; look for another number (return into DE)
1240+ 1AC8 7A                   ld      A,D
1241+ 1AC9 B3                   or      E               ; is line=0?
1242+ 1ACA 20 09                jr      NZ,LST05        ; no, jump over
1243+ 1ACC 11 F9 FF             ld      DE,65529        ; yes set last valid line number
1244+ 1ACF CD 4A 1B             call    SRCHLIN         ; get address of last line
1245+ 1AD2 C3 D8 1A             jp      LST02
1246+ 1AD5 CD 50 1B     LST05:  call    SRCLN           ; find a line, getting the previous if it doesn't exist
1247+ 1AD8 ED 43 DF 81  LST02:  ld      (TMPBFR2),BC    ; store address of ending line
1248+ 1ADC ED 4B DD 81          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1249+ 1AE0 C5                   push    BC              ; store it for later use
1250+ 1AE1 E1           LISTLP: pop     HL              ; Restore address of line
1251+ 1AE2 4E                   ld      C,(HL)          ; Get LSB of next line
1252+ 1AE3 23                   inc     HL
1253+ 1AE4 46                   ld      B,(HL)          ; Get MSB of next line
1254+ 1AE5 23                   inc     HL
1255+ 1AE6 78                   ld      A,B             ; BC = 0 (End of program)?
1256+ 1AE7 B1                   or      C
1257+ 1AE8 CA 47 17             jp      Z,PRNTOK        ; Yes - Go to command mode
1258+ 1AEB CD 5B 1C             call    TSTBRK          ; Test for break key
1259+ 1AEE CD 5E 1B             call    TSTSPC          ; test for space
1260+ 1AF1 C5                   push    BC              ; Save address of next line
1261+ 1AF2 3A D2 81             ld      A,(SCR_CURS_X)  ; load current X pos of cursor
1262+ 1AF5 A7                   and     A               ; is it at the beginning of a new line?
1263+ 1AF6 20 0B                jr      NZ,LST08        ; No, jump over
1264+ 1AF8 3E 0D                ld      A,CR            ; yes, so just send a CR
1265+ 1AFA CD DD 3F             call    MONOUT          ; to serial if it's open
1266+ 1AFD AF                   xor     A               ; then, set cursor
1267+ 1AFE 32 92 81             ld      (CURPOS),A      ; to position 0
1268+ 1B01 18 03                jr      LST07           ; and continue
1269+ 1B03 CD FD 1E     LST08:  call    PRNTCRLF        ; output CRLF
1270+ 1B06 5E           LST07:  ld      E,(HL)          ; Get LSB of line number
1271+ 1B07 23                   inc     HL
1272+ 1B08 56                   ld      D,(HL)          ; Get MSB of line number
1273+ 1B09 23                   inc     HL
1274+ 1B0A E5                   push    HL              ; Save address of line start
1275+ 1B0B EB                   ex      DE,HL           ; Line number to HL
1276+ 1B0C CD 68 30             call    PRNTHL          ; Output line number in decimal
1277+ 1B0F 3E 20                ld      A,SPC           ; Space after line number
1278+ 1B11 E1                   pop     HL              ; Restore start of line address
1279+ 1B12 CD F2 19     LSTLP2: call    OUTC            ; Output character in A
1280+ 1B15 7E           LSTLP3: ld      A,(HL)          ; Get next byte in line
1281+ 1B16 B7                   or      A               ; End of line?
1282+ 1B17 23                   inc     HL              ; To next byte in line
1283+ 1B18 CA 3C 1B             jp      Z,NXTLN         ; Yes - check next line
1284+ 1B1B F2 12 1B             jp      P,LSTLP2        ; No token - output it
1285+ 1B1E D6 7F                sub     ZEND-1          ; Find and output word
1286+ 1B20 4F                   ld      C,A             ; Token offset+1 to C
1287+ 1B21 11 6F 13             ld      DE,WORDS        ; Reserved word list
1288+ 1B24 1A           FNDTOK: ld      A,(DE)          ; Get character in list
1289+ 1B25 13                   inc     DE              ; Move on to next
1290+ 1B26 B7                   or      A               ; Is it start of word?
1291+ 1B27 F2 24 1B             jp      P,FNDTOK        ; No - Keep looking for word
1292+ 1B2A 0D                   dec     C               ; Count words
1293+ 1B2B C2 24 1B             jp      NZ,FNDTOK       ; Not there - keep looking
1294+ 1B2E E6 7F        OUTWRD: and     %01111111       ; Strip bit 7
1295+ 1B30 CD F2 19             call    OUTC            ; Output character
1296+ 1B33 1A                   ld      A,(DE)          ; Get next character
1297+ 1B34 13                   inc     DE              ; Move on to next
1298+ 1B35 B7                   or      A               ; Is it end of word?
1299+ 1B36 F2 2E 1B             jp      P,OUTWRD        ; No - output the rest
1300+ 1B39 C3 15 1B             jp      LSTLP3          ; Next byte in line
1301+ 1B3C D1           NXTLN:  pop     DE              ; recover address of current line
1302+ 1B3D 2A DF 81             ld      HL,(TMPBFR2)    ; address of last line to print
1303+ 1B40 CD 04 40             call    CMP16           ; check if current line is over last printable line
1304+ 1B43 DA 47 17             jp      C,PRNTOK        ; finish - leave & print OK
1305+ 1B46 D5                   push    DE              ; store address of current line
1306+ 1B47 C3 E1 1A             jp      LISTLP          ; continue listing
1307+ 1B4A              ; look for the address of a program line
1308+ 1B4A E5           SRCHLIN:push    HL              ; store HL (this is needed because HL store the pointer to the input buffer)
1309+ 1B4B CD 03 18             call    SRCHLN          ; search for line number in DE
1310+ 1B4E E1                   pop     HL              ; retrieve HL
1311+ 1B4F C9                   ret                     ; return to caller
1312+ 1B50              ; look for the address of a program line - if the line isn't found,
1313+ 1B50              ; it look backward for the previous line
1314+ 1B50 E5           SRCLN:  push    HL              ; store HL
1315+ 1B51 CD 03 18     SRCLN1: call    SRCHLN          ; search for line in DE
1316+ 1B54 DA 5C 1B             jp      C,LVSRLN        ; found it, leave loop
1317+ 1B57 1B                   dec     DE              ; not found, decrement number to look backward for an existing line
1318+ 1B58 7B                   ld      A,E
1319+ 1B59 B2                   or      D               ; is line number zero?
1320+ 1B5A 20 F5                jr      NZ,SRCLN1       ; no, continue
1321+ 1B5C E1           LVSRLN: pop     HL              ; retrieve HL
1322+ 1B5D C9                   ret                     ; return to caller
1323+ 1B5E
1324+ 1B5E              ; during LISTing, check if PAUSE is pressed, then pause listing and
1325+ 1B5E              ; wait for another pressing of PAUSE to continue or CTRL-C/BREAK to exit
1326+ 1B5E 3A 19 82     TSTSPC: ld      A,(TMPKEYBFR)   ; Get input character
1327+ 1B61 FE 20                cp      SPC             ; Is it SPACE?
1328+ 1B63 C0                   ret     NZ              ; No, return
1329+ 1B64 CD 84 33     WTSPC:  call    GETINP          ; Yes, stop listing and wait for another space or BREAK
1330+ 1B67 FE 20                cp      SPC             ; is it SPACE?
1331+ 1B69 20 05                jr      NZ,CNTWTSP      ; no, continue
1332+ 1B6B AF                   xor     A
1333+ 1B6C 32 19 82             ld      (TMPKEYBFR),A   ; reset key
1334+ 1B6F C9                   ret                     ; return to caller
1335+ 1B70 FE 03        CNTWTSP:cp      CTRLC           ; is it CTRL-C/BREAK?
1336+ 1B72 20 F0                jr      NZ,WTSPC        ; no, loop
1337+ 1B74 C3 BC 12             jp      BRKRET          ; exit and output "Ok"
1338+ 1B77
1339+ 1B77
1340+ 1B77 3E 64        FOR:    ld      A,$64           ; Flag "FOR" assignment
1341+ 1B79 32 B2 81             ld      (FORFLG),A      ; Save "FOR" flag
1342+ 1B7C CD F0 1D             call    LET             ; Set up initial index
1343+ 1B7F C1                   pop     BC              ; Drop RETurn address
1344+ 1B80 E5                   push    HL              ; Save code string address
1345+ 1B81 CD D9 1D             call    DATA            ; Get next statement address
1346+ 1B84 22 AE 81             ld      (LOOPST),HL     ; Save it for start of loop
1347+ 1B87 21 02 00             ld      HL,$0002        ; Offset for "FOR" block
1348+ 1B8A 39                   add     HL,SP           ; Point to it
1349+ 1B8B CD 7A 16     FORSLP: call    LOKFOR          ; Look for existing "FOR" block
1350+ 1B8E D1                   pop     DE              ; Get code string address
1351+ 1B8F C2 A7 1B             jp      NZ,FORFND       ; No nesting found
1352+ 1B92 09                   add     HL,BC           ; Move into "FOR" block
1353+ 1B93 D5                   push    DE              ; Save code string address
1354+ 1B94 2B                   dec     HL
1355+ 1B95 56                   ld      D,(HL)          ; Get MSB of loop statement
1356+ 1B96 2B                   dec     HL
1357+ 1B97 5E                   ld      E,(HL)          ; Get LSB of loop statement
1358+ 1B98 23                   inc     HL
1359+ 1B99 23                   inc     HL
1360+ 1B9A E5                   push    HL              ; Save block address
1361+ 1B9B 2A AE 81             ld      HL,(LOOPST)     ; Get address of loop statement
1362+ 1B9E CD E1 19             call    CPDEHL          ; Compare the FOR loops
1363+ 1BA1 E1                   pop     HL              ; Restore block address
1364+ 1BA2 C2 8B 1B             jp      NZ,FORSLP       ; Different FORs - Find another
1365+ 1BA5 D1                   pop     DE              ; Restore code string address
1366+ 1BA6 F9                   ld      SP,HL           ; Remove all nested loops
1367+ 1BA7
1368+ 1BA7 EB           FORFND: ex      DE,HL           ; Code string address to HL
1369+ 1BA8 0E 08                ld      C,$08
1370+ 1BAA CD AA 16             call    CHKSTK          ; Check for 8 levels of stack
1371+ 1BAD E5                   push    HL              ; Save code string address
1372+ 1BAE 2A AE 81             ld      HL,(LOOPST)     ; Get first statement of loop
1373+ 1BB1 E3                   ex      (SP),HL         ; Save and restore code string
1374+ 1BB2 E5                   push    HL              ; Re-save code string address
1375+ 1BB3 2A AF 80             ld      HL,(LINEAT)     ; Get current line number
1376+ 1BB6 E3                   ex      (SP),HL         ; Save and restore code string
1377+ 1BB7 CD C4 20             call    TSTNUM          ; Make sure it's a number
1378+ 1BBA CD E7 19             call    CHKSYN          ; Make sure "TO" is next
1379+ 1BBD B7                   defb    ZTO             ; "TO" token
1380+ 1BBE CD C1 20             call    GETNUM          ; Get "TO" expression value
1381+ 1BC1 E5                   push    HL              ; Save code string address
1382+ 1BC2 CD 1A 2F             call    BCDEFP          ; Move "TO" value to BCDE
1383+ 1BC5 E1                   pop     HL              ; Restore code string address
1384+ 1BC6 C5                   push    BC              ; Save "TO" value in block
1385+ 1BC7 D5                   push    DE
1386+ 1BC8 01 00 81             ld      BC,$8100        ; BCDE - 1 (default STEP)
1387+ 1BCB 51                   ld      D,C             ; C=0
1388+ 1BCC 5A                   ld      E,D             ; D=0
1389+ 1BCD 7E                   ld      A,(HL)          ; Get next byte in code string
1390+ 1BCE FE BC                cp      ZSTEP           ; See if "STEP" is stated
1391+ 1BD0 3E 01                ld      A,$01           ; Sign of step = 1
1392+ 1BD2 C2 E3 1B             jp      NZ,SAVSTP       ; No STEP given - Default to 1
1393+ 1BD5 CD 30 1C             call    GETCHR          ; Jump over "STEP" token
1394+ 1BD8 CD C1 20             call    GETNUM          ; Get step value
1395+ 1BDB E5                   push    HL              ; Save code string address
1396+ 1BDC CD 1A 2F             call    BCDEFP          ; Move STEP to BCDE
1397+ 1BDF CD CE 2E             call    TSTSGN          ; Test sign of FPREG
1398+ 1BE2 E1                   pop     HL              ; Restore code string address
1399+ 1BE3 C5           SAVSTP: push    BC              ; Save the STEP value in block
1400+ 1BE4 D5                   push    DE
1401+ 1BE5 F5                   push    AF              ; Save sign of STEP
1402+ 1BE6 33                   inc     SP              ; Don't save flags
1403+ 1BE7 E5                   push    HL              ; Save code string address
1404+ 1BE8 2A B5 81             ld      HL,(BRKLIN)     ; Get address of index variable
1405+ 1BEB E3                   ex      (SP),HL         ; Save and restore code string
1406+ 1BEC 06 81        PUTFID: ld      B,ZFOR          ; "FOR" block marker
1407+ 1BEE C5                   push    BC              ; Save it
1408+ 1BEF 33                   inc     SP              ; Don't save C
1409+ 1BF0
1410+ 1BF0 CD 5B 1C     RUNCNT: call    TSTBRK          ; Execution driver - Test break
1411+ 1BF3 22 B5 81             ld      (BRKLIN),HL     ; Save code address for break
1412+ 1BF6 7E                   ld      A,(HL)          ; Get next byte in code string
1413+ 1BF7 FE 3A                cp      ':'             ; Multi statement line?
1414+ 1BF9 CA 10 1C             jp      Z,EXCUTE        ; Yes - Execute it
1415+ 1BFC B7                   or      A               ; End of line?
1416+ 1BFD C2 ED 16             jp      NZ,SNERR        ; No - Syntax error
1417+ 1C00 23                   inc     HL              ; Point to address of next line
1418+ 1C01 7E                   ld      A,(HL)          ; Get LSB of line pointer
1419+ 1C02 23                   inc     HL
1420+ 1C03 B6                   or      (HL)            ; Is it zero (End of prog)?
1421+ 1C04 CA 82 1C             jp      Z,ENDPRG        ; Yes - Terminate execution
1422+ 1C07 23                   inc     HL              ; Point to line number
1423+ 1C08 5E                   ld      E,(HL)          ; Get LSB of line number
1424+ 1C09 23                   inc     HL
1425+ 1C0A 56                   ld      D,(HL)          ; Get MSB of line number
1426+ 1C0B EB                   ex      DE,HL           ; Line number to HL
1427+ 1C0C 22 AF 80             ld      (LINEAT),HL     ; Save as current line number
1428+ 1C0F EB                   ex      DE,HL           ; Line number back to DE
1429+ 1C10 CD 30 1C     EXCUTE: call    GETCHR          ; Get key word
1430+ 1C13 11 F0 1B             ld      DE,RUNCNT       ; Where to RETurn to
1431+ 1C16 D5                   push    DE              ; Save for RETurn
1432+ 1C17 C8           IFJMP:  ret     Z               ; Go to RUNCNT if end of STMT
1433+ 1C18
1434+ 1C18 D6 80        ONJMP:  sub     ZEND            ; Is it a token?
1435+ 1C1A DA F0 1D             jp      C,LET           ; No - try to assign it
1436+ 1C1D FE 36                cp      ZNEW+1-ZEND     ; END to NEW ?
1437+ 1C1F D2 ED 16             jp      NC,SNERR        ; Not a key word - ?SN Error
1438+ 1C22 07                   rlca                    ; Double it
1439+ 1C23 4F                   ld      C,A             ; BC = Offset into table
1440+ 1C24 06 00                ld      B,0
1441+ 1C26 EB                   ex      DE,HL           ; Save code string address
1442+ 1C27 21 FC 14             ld      HL,WORDTB       ; Keyword address table
1443+ 1C2A 09                   add     HL,BC           ; Point to routine address
1444+ 1C2B 4E                   ld      C,(HL)          ; Get LSB of routine address
1445+ 1C2C 23                   inc     HL
1446+ 1C2D 46                   ld      B,(HL)          ; Get MSB of routine address
1447+ 1C2E C5                   push    BC              ; Save routine address
1448+ 1C2F EB                   ex      DE,HL           ; Restore code string address
1449+ 1C30
1450+ 1C30              ; get a char from input buffer: exit with NC if character found is
1451+ 1C30              ; not a number; exit with Z if nothing found; char is into A
1452+ 1C30 23           GETCHR: inc     HL              ; Point to next character
1453+ 1C31 7E                   ld      A,(HL)          ; Get next code string byte
1454+ 1C32 FE 3A                cp      ':'             ; Z if ':'
1455+ 1C34 D0                   ret     NC              ; NC if > "9"
1456+ 1C35 FE 20                cp      SPC
1457+ 1C37 CA 30 1C             jp      Z,GETCHR        ; Skip over spaces
1458+ 1C3A FE 30                cp      '0'
1459+ 1C3C 3F                   ccf                     ; NC if < '0'
1460+ 1C3D 3C                   inc     A               ; Test for zero - Leave carry
1461+ 1C3E 3D                   dec     A               ; Z if Null
1462+ 1C3F C9                   ret
1463+ 1C40
1464+ 1C40 EB           RESTOR: ex      DE,HL           ; Save code string address
1465+ 1C41 2A 35 81             ld      HL,(BASTXT)     ; Point to start of program
1466+ 1C44 CA 55 1C             jp      Z,RESTNL        ; Just RESTORE - reset pointer
1467+ 1C47 EB                   ex      DE,HL           ; Restore code string address
1468+ 1C48 CD 00 1D             call    ATOH            ; Get line number to DE
1469+ 1C4B E5                   push    HL              ; Save code string address
1470+ 1C4C CD 03 18             call    SRCHLN          ; Search for line number in DE
1471+ 1C4F 60                   ld      H,B             ; HL = Address of line
1472+ 1C50 69                   ld      L,C
1473+ 1C51 D1                   pop     DE              ; Restore code string address
1474+ 1C52 D2 AF 1D             jp      NC,ULERR        ; ?UL Error if not found
1475+ 1C55 2B           RESTNL: dec     HL              ; Byte before DATA statement
1476+ 1C56 22 29 82     UPDATA: ld      (NXTDAT),HL     ; Update DATA pointer
1477+ 1C59 EB                   ex      DE,HL           ; Restore code string address
1478+ 1C5A C9                   ret
1479+ 1C5B
1480+ 1C5B
1481+ 1C5B              ; check if CTRL-C is into input buffer
1482+ 1C5B DF           TSTBRK: rst     $18             ; Check input status
1483+ 1C5C C8                   ret     Z               ; No key, go back
1484+ 1C5D D7                   rst     $10             ; Get the key into A
1485+ 1C5E FE 1B                cp      ESC             ; Escape key?
1486+ 1C60 28 11                jr      Z,BRK           ; Yes, break
1487+ 1C62 FE 03                cp      CTRLC           ; <Ctrl-C>
1488+ 1C64 28 0D                jr      Z,BRK           ; Yes, break
1489+ 1C66 FE 13                cp      CTRLS           ; Stop scrolling?
1490+ 1C68 C0                   ret     NZ              ; Other key, ignore
1491+ 1C69
1492+ 1C69
1493+ 1C69              ; wait for a key while listing
1494+ 1C69 D7           STALL:  rst     $10             ; Wait for key
1495+ 1C6A FE 11                cp      CTRLQ           ; Resume scrolling?
1496+ 1C6C C8                   ret     Z               ; Release the chokehold
1497+ 1C6D FE 03                cp      CTRLC           ; Second break?
1498+ 1C6F 28 07                jr      Z,STOP          ; Break during hold exits prog
1499+ 1C71 18 F6                jr      STALL           ; Loop until <Ctrl-Q> or <brk>
1500+ 1C73
1501+ 1C73 3E FF        BRK:    ld      A,$FF           ; Set BRKFLG
1502+ 1C75 32 A9 80             ld      (BRKFLG),A      ; Store it
1503+ 1C78
1504+ 1C78 C0           STOP:   ret     NZ              ; Exit if anything else
1505+ 1C79 F6                   defb    $F6             ; Flag "STOP"
1506+ 1C7A C0           PEND:   ret     NZ              ; Exit if anything else
1507+ 1C7B 22 B5 81             ld      (BRKLIN),HL     ; Save point of break
1508+ 1C7E 21                   defb    $21             ; Skip "OR 11111111B"
1509+ 1C7F F6 FF        INPBRK: or      %11111111       ; Flag "Break" wanted
1510+ 1C81 C1                   pop     BC              ; Return not needed and more
1511+ 1C82 2A AF 80     ENDPRG: ld      HL,(LINEAT)     ; Get current line number
1512+ 1C85 F5                   push    AF              ; Save STOP / END status
1513+ 1C86 7D                   ld      A,L             ; Is it direct break?
1514+ 1C87 A4                   and     H
1515+ 1C88 3C                   inc     A               ; Line is -1 if direct break
1516+ 1C89 CA 95 1C             jp      Z,NOLIN         ; Yes - No line number
1517+ 1C8C 22 B9 81             ld      (ERRLIN),HL     ; Save line of break
1518+ 1C8F 2A B5 81             ld      HL,(BRKLIN)     ; Get point of break
1519+ 1C92 22 BB 81             ld      (CONTAD),HL     ; Save point to CONTinue
1520+ 1C95 AF           NOLIN:  xor     A
1521+ 1C96 32 A5 80             ld      (CTLOFG),A      ; Enable output
1522+ 1C99 CD EB 1E             call    STTLIN          ; Start a new line
1523+ 1C9C F1                   pop     AF              ; Restore STOP / END status
1524+ 1C9D 21 70 16             ld      HL,BRKMSG       ; "Break" message
1525+ 1CA0 C2 A6 1C             jp      NZ,ERRINT       ; "in line" wanted?
1526+ 1CA3 C3 47 17             jp      PRNTOK          ; Go to command mode
1527+ 1CA6 CD C7 16     ERRINT: call    EXITGM          ; exit from graphics mode
1528+ 1CA9 C3 25 17             jp      ERRIN           ; print message
1529+ 1CAC
1530+ 1CAC
1531+ 1CAC              ; CONTinue after a break/error
1532+ 1CAC 21 FF FF     CONT:   ld      HL,-1           ; reset...
1533+ 1CAF 22 B1 80             ld      (HLPLN),HL      ; ...HELP line register
1534+ 1CB2 2A BB 81             ld      HL,(CONTAD)     ; Get CONTinue address
1535+ 1CB5 7C                   ld      A,H             ; Is it zero?
1536+ 1CB6 B5                   or      L
1537+ 1CB7 1E 20                ld      E,CN            ; ?CN Error
1538+ 1CB9 CA 01 17             jp      Z,ERROR         ; Yes - output "?CN Error"
1539+ 1CBC EB                   ex      DE,HL           ; Save code string address
1540+ 1CBD 2A B9 81             ld      HL,(ERRLIN)     ; Get line of last break
1541+ 1CC0 22 AF 80             ld      (LINEAT),HL     ; Set up current line number
1542+ 1CC3 EB                   ex      DE,HL           ; Restore code string address
1543+ 1CC4 C9                   ret                     ; CONTinue where left off
1544+ 1CC5
1545+ 1CC5 E5           ACCSUM: push    HL              ; Save address in array
1546+ 1CC6 2A A6 80             ld      HL,(CHKSUM)     ; Get check sum
1547+ 1CC9 06 00                ld      B,$00           ; BC - Value of byte
1548+ 1CCB 4F                   ld      C,A
1549+ 1CCC 09                   add     HL,BC           ; Add byte to check sum
1550+ 1CCD 22 A6 80             ld      (CHKSUM),HL     ; Re-save check sum
1551+ 1CD0 E1                   pop     HL              ; Restore address in array
1552+ 1CD1 C9                   ret
1553+ 1CD2
1554+ 1CD2 7E           CHKLTR: ld      A,(HL)          ; Get byte
1555+ 1CD3 FE 41                cp      'A'             ; < 'a' ?
1556+ 1CD5 D8                   ret     C               ; Carry set if not letter
1557+ 1CD6 FE 5B                cp      'Z'+1           ; > 'z' ?
1558+ 1CD8 3F                   ccf
1559+ 1CD9 C9                   ret                     ; Carry set if not letter
1560+ 1CDA
1561+ 1CDA CD 30 1C     FPSINT: call    GETCHR          ; Get next character
1562+ 1CDD CD C1 20     POSINT: call    GETNUM          ; Get integer 0 to 32767
1563+ 1CE0 CD CE 2E     DEPINT: call    TSTSGN          ; Test sign of FPREG
1564+ 1CE3 FA FB 1C             jp      M,FCERR         ; Negative - ?FC Error
1565+ 1CE6 3A 34 82     DEINT:  ld      A,(FPEXP)       ; Get integer value to DE
1566+ 1CE9 FE 90                cp      $80+$10         ; Exponent in range (16 bits)?
1567+ 1CEB DA 76 2F             jp      C,FPINT         ; Yes - convert it
1568+ 1CEE 01 80 90             ld      BC,$9080        ; BCDE = -32768
1569+ 1CF1 11 00 00             ld      DE,$0000
1570+ 1CF4 E5                   push    HL              ; Save code string address
1571+ 1CF5 CD 49 2F             call    CMPNUM          ; Compare FPREG with BCDE
1572+ 1CF8 E1                   pop     HL              ; Restore code string address
1573+ 1CF9 51                   ld      D,C             ; MSB to D
1574+ 1CFA C8                   ret     Z               ; Return if in range
1575+ 1CFB 1E 08        FCERR:  ld      E,FC            ; ?FC Error
1576+ 1CFD C3 01 17             jp      ERROR           ; Output error-
1577+ 1D00
1578+ 1D00
1579+ 1D00              ; convert a number in ASCII chars into an integer into DE
1580+ 1D00 2B           ATOH:   dec     HL              ; ASCII number to DE binary
1581+ 1D01 11 00 00     GETLN:  ld      DE,$0000        ; Get number to DE
1582+ 1D04 CD 30 1C     GTLNLP: call    GETCHR          ; Get next character
1583+ 1D07 D0                   ret     NC              ; Exit if not a digit
1584+ 1D08 E5                   push    HL              ; Save code string address
1585+ 1D09 F5                   push    AF              ; Save digit
1586+ 1D0A 21 98 19             ld      HL,65529/10     ; Largest number 65529
1587+ 1D0D CD E1 19             call    CPDEHL          ; Number in range?
1588+ 1D10 DA ED 16             jp      C,SNERR         ; No - ?SN Error
1589+ 1D13 62                   ld      H,D             ; HL = Number
1590+ 1D14 6B                   ld      L,E
1591+ 1D15 19                   add     HL,DE           ; Times 2
1592+ 1D16 29                   add     HL,HL           ; Times 4
1593+ 1D17 19                   add     HL,DE           ; Times 5
1594+ 1D18 29                   add     HL,HL           ; Times 10
1595+ 1D19 F1                   pop     AF              ; Restore digit
1596+ 1D1A D6 30                sub     '0'             ; Make it 0 to 9
1597+ 1D1C 5F                   ld      E,A             ; DE = Value of digit
1598+ 1D1D 16 00                ld      D,0
1599+ 1D1F 19                   add     HL,DE           ; Add to number
1600+ 1D20 EB                   ex      DE,HL           ; Number to DE
1601+ 1D21 E1                   pop     HL              ; Restore code string address
1602+ 1D22 C3 04 1D             jp      GTLNLP          ; Go to next character
1603+ 1D25
1604+ 1D25 CA 33 18     CLEAR:  jp      Z,INTVAR        ; Just "CLEAR" Keep parameters
1605+ 1D28 CD C1 20             call    GETNUM          ; Evaluate a number
1606+ 1D2B CD E6 1C             call    DEINT           ; Get integer -32768 to 32767 into DE
1607+ 1D2E 2B                   dec     HL              ; Cancel increment
1608+ 1D2F CD 30 1C             call    GETCHR          ; Get next character
1609+ 1D32 E5                   push    HL              ; Save code string address
1610+ 1D33 2A 96 81             ld      HL,(LSTRAM)     ; Get end of RAM
1611+ 1D36 CA 4E 1D             jp      Z,STORED        ; No value given - Use stored
1612+ 1D39 E1                   pop     HL              ; Restore code string address
1613+ 1D3A CD E7 19             call    CHKSYN          ; Check for comma
1614+ 1D3D 2C                   defb    ','
1615+ 1D3E D5                   push    DE              ; Save number
1616+ 1D3F CD C1 20             call    GETNUM          ; Evaluate a number
1617+ 1D42 CD E6 1C             call    DEINT           ; Get integer -32768 to 32767 into DE
1618+ 1D45 2B                   dec     HL              ; Cancel increment
1619+ 1D46 CD 30 1C             call    GETCHR          ; Get next character
1620+ 1D49 C2 ED 16             jp      NZ,SNERR        ; ?SN Error if more on line
1621+ 1D4C E3                   ex      (SP),HL         ; Save code string address
1622+ 1D4D EB                   ex      DE,HL           ; Number to DE
1623+ 1D4E 7D           STORED: ld      A,L             ; Get LSB of new RAM top
1624+ 1D4F 93                   sub     E               ; Subtract LSB of string space
1625+ 1D50 5F                   ld      E,A             ; Save LSB
1626+ 1D51 7C                   ld      A,H             ; Get MSB of new RAM top
1627+ 1D52 9A                   sbc     A,D             ; Subtract MSB of string space
1628+ 1D53 57                   ld      D,A             ; Save MSB
1629+ 1D54 DA C2 16             jp      C,OMERR         ; ?OM Error if not enough mem
1630+ 1D57 E5                   push    HL              ; Save RAM top
1631+ 1D58 2A 23 82             ld      HL,(PROGND)     ; Get program end
1632+ 1D5B 01 28 00             ld      BC,$28          ; 40 Bytes minimum working RAM
1633+ 1D5E 09                   add     HL,BC           ; Get lowest address
1634+ 1D5F CD E1 19             call    CPDEHL          ; Enough memory?
1635+ 1D62 D2 C2 16             jp      NC,OMERR        ; No - ?OM Error
1636+ 1D65 EB                   ex      DE,HL           ; RAM top to HL
1637+ 1D66 22 AD 80             ld      (STRSPC),HL     ; Set new string space
1638+ 1D69 E1                   pop     HL              ; End of memory to use
1639+ 1D6A 22 96 81             ld      (LSTRAM),HL     ; Set new top of RAM
1640+ 1D6D E1                   pop     HL              ; Restore code string address
1641+ 1D6E C3 33 18             jp      INTVAR          ; Initialise variables
1642+ 1D71
1643+ 1D71 E5           RUN:    push    HL              ; store HL
1644+ 1D72 21 FF FF             ld      HL,-1           ; reset...
1645+ 1D75 22 B1 80             ld      (HLPLN),HL      ; ...HELP line register
1646+ 1D78 E1                   pop     HL              ; retrieve HL
1647+ 1D79 CA 2F 18             jp      Z,RUNFST        ; RUN from start if just RUN
1648+ 1D7C CD 33 18             call    INTVAR          ; Initialise variables
1649+ 1D7F 01 F0 1B             ld      BC,RUNCNT       ; Execution driver loop
1650+ 1D82 C3 95 1D             jp      RUNLIN          ; RUN from line number
1651+ 1D85
1652+ 1D85 0E 03        GOSUB:  ld      C,$03           ; 3 Levels of stack needed
1653+ 1D87 CD AA 16             call    CHKSTK          ; Check for 3 levels of stack
1654+ 1D8A C1                   pop     BC              ; Get return address
1655+ 1D8B E5                   push    HL              ; Save code string for RETURN
1656+ 1D8C E5                   push    HL              ; And for GOSUB routine
1657+ 1D8D 2A AF 80             ld      HL,(LINEAT)     ; Get current line
1658+ 1D90 E3                   ex      (SP),HL         ; Into stack - Code string out
1659+ 1D91 3E 8C                ld      A,ZGOSUB        ; "GOSUB" token
1660+ 1D93 F5                   push    AF              ; Save token
1661+ 1D94 33                   inc     SP              ; Don't save flags
1662+ 1D95
1663+ 1D95 C5           RUNLIN: push    BC              ; Save return address
1664+ 1D96 CD 00 1D     GOTO:   call    ATOH            ; ASCII number to DE binary
1665+ 1D99 CD DB 1D             call    REM             ; Get end of line
1666+ 1D9C E5                   push    HL              ; Save end of line
1667+ 1D9D 2A AF 80             ld      HL,(LINEAT)     ; Get current line
1668+ 1DA0 CD E1 19             call    CPDEHL          ; Line after current?
1669+ 1DA3 E1                   pop     HL              ; Restore end of line
1670+ 1DA4 23                   inc     HL              ; Start of next line
1671+ 1DA5 DC 06 18             call    C,SRCHLP        ; Line is after current line
1672+ 1DA8 D4 03 18             call    NC,SRCHLN       ; Line is before current line
1673+ 1DAB 60                   ld      H,B             ; Set up code string address
1674+ 1DAC 69                   ld      L,C
1675+ 1DAD 2B                   dec     HL              ; Incremented after
1676+ 1DAE D8                   ret     C               ; Line found
1677+ 1DAF 1E 0E        ULERR:  ld      E,UL            ; ?UL Error
1678+ 1DB1 C3 01 17             jp      ERROR           ; Output error message
1679+ 1DB4
1680+ 1DB4 C0           RETURN: ret     NZ              ; Return if not just RETURN
1681+ 1DB5 16 FF                ld      D,-1            ; Flag "GOSUB" search
1682+ 1DB7 CD 76 16             call    BAKSTK          ; Look "GOSUB" block
1683+ 1DBA F9                   ld      SP,HL           ; Kill all FORs in subroutine
1684+ 1DBB FE 8C                cp      ZGOSUB          ; Test for "GOSUB" token
1685+ 1DBD 1E 04                ld      E,RG            ; ?RG Error
1686+ 1DBF C2 01 17             jp      NZ,ERROR        ; Error if no "GOSUB" found
1687+ 1DC2 E1                   pop     HL              ; Get RETURN line number
1688+ 1DC3 22 AF 80             ld      (LINEAT),HL     ; Save as current
1689+ 1DC6 23                   inc     HL              ; Was it from direct statement?
1690+ 1DC7 7C                   ld      A,H
1691+ 1DC8 B5                   or      L               ; Return to line
1692+ 1DC9 C2 D3 1D             jp      NZ,RETLIN       ; No - Return to line
1693+ 1DCC 3A B3 81             ld      A,(LSTBIN)      ; Any INPUT in subroutine?
1694+ 1DCF B7                   or      A               ; If so buffer is corrupted
1695+ 1DD0 C2 46 17             jp      NZ,POPNOK       ; Yes - Go to command mode
1696+ 1DD3 21 F0 1B     RETLIN: ld      HL,RUNCNT       ; Execution driver loop
1697+ 1DD6 E3                   ex      (SP),HL         ; Into stack - Code string out
1698+ 1DD7 3E                   defb    $3E             ; Skip "pop HL"
1699+ 1DD8 E1           NXTDTA: pop     HL              ; Restore code string address
1700+ 1DD9
1701+ 1DD9 01 3A        DATA:   defb    $01,$3A         ; ':' End of statement (stands for LD BC,$0E3A - NOP)
1702+ 1DDB 0E 00        REM:    ld      C,$00           ; 00  End of statement
1703+ 1DDD 06 00                ld      B,$00
1704+ 1DDF 79           NXTSTL: ld      A,C             ; Statement and byte
1705+ 1DE0 48                   ld      C,B
1706+ 1DE1 47                   ld      B,A             ; Statement end byte
1707+ 1DE2 7E           NXTSTT: ld      A,(HL)          ; Get byte
1708+ 1DE3 B7                   or      A               ; End of line?
1709+ 1DE4 C8                   ret     Z               ; Yes - Exit
1710+ 1DE5 B8                   cp      B               ; End of statement?
1711+ 1DE6 C8                   ret     Z               ; Yes - Exit
1712+ 1DE7 23                   inc     HL              ; Next byte
1713+ 1DE8 FE 22                cp      $22             ; '"'             ; Literal string?
1714+ 1DEA CA DF 1D             jp      Z,NXTSTL        ; Yes - Look for another '"'
1715+ 1DED C3 E2 1D             jp      NXTSTT          ; Keep looking
1716+ 1DF0
1717+ 1DF0 CD D0 22     LET:    call    GETVAR          ; Get variable name
1718+ 1DF3 CD E7 19             call    CHKSYN          ; Make sure "=" follows
1719+ 1DF6 C8                   defb    ZEQUAL          ; "=" token
1720+ 1DF7 D5                   push    DE              ; Save address of variable
1721+ 1DF8 3A 94 81             ld      A,(TYPE)        ; Get data type
1722+ 1DFB F5                   push    AF              ; Save type
1723+ 1DFC CD D3 20             call    EVAL            ; Evaluate expression
1724+ 1DFF F1                   pop     AF              ; Restore type
1725+ 1E00 E3                   ex      (SP),HL         ; Save code - Get var addr
1726+ 1E01 22 B5 81             ld      (BRKLIN),HL     ; Save address of variable
1727+ 1E04 1F                   rra                     ; Adjust type
1728+ 1E05 CD C6 20             call    CHKTYP          ; Check types are the same
1729+ 1E08 CA 43 1E             jp      Z,LETNUM        ; Numeric - Move value
1730+ 1E0B E5           LETSTR: push    HL              ; Save address of string var
1731+ 1E0C 2A 31 82             ld      HL,(FPREG)      ; Pointer to string entry
1732+ 1E0F E5                   push    HL              ; Save it on stack
1733+ 1E10 23                   inc     HL              ; Skip over length
1734+ 1E11 23                   inc     HL
1735+ 1E12 5E                   ld      E,(HL)          ; LSB of string address
1736+ 1E13 23                   inc     HL
1737+ 1E14 56                   ld      D,(HL)          ; MSB of string address
1738+ 1E15 2A 35 81             ld      HL,(BASTXT)     ; Point to start of program
1739+ 1E18 CD E1 19             call    CPDEHL          ; Is string before program?
1740+ 1E1B D2 32 1E             jp      NC,CRESTR       ; Yes - Create string entry
1741+ 1E1E 2A AD 80             ld      HL,(STRSPC)     ; Point to string space
1742+ 1E21 CD E1 19             call    CPDEHL          ; Is string literal in program?
1743+ 1E24 D1                   pop     DE              ; Restore address of string
1744+ 1E25 D2 3A 1E             jp      NC,MVSTPT       ; Yes - Set up pointer
1745+ 1E28 21 A6 81             ld      HL,TMPSTR       ; Temporary string pool
1746+ 1E2B CD E1 19             call    CPDEHL          ; Is string in temporary pool?
1747+ 1E2E D2 3A 1E             jp      NC,MVSTPT       ; No - Set up pointer
1748+ 1E31 3E                   defb    $3E             ; Skip "pop DE"
1749+ 1E32 D1           CRESTR: pop     DE              ; Restore address of string
1750+ 1E33 CD 2A 27             call    BAKTMP          ; Back to last tmp-str entry
1751+ 1E36 EB                   ex      DE,HL           ; Address of string entry
1752+ 1E37 CD 63 25             call    SAVSTR          ; Save string in string area
1753+ 1E3A CD 2A 27     MVSTPT: call    BAKTMP          ; Back to last tmp-str entry
1754+ 1E3D E1                   pop     HL              ; Get string pointer
1755+ 1E3E CD 29 2F             call    DETHL4          ; Move string pointer to var
1756+ 1E41 E1                   pop     HL              ; Restore code string address
1757+ 1E42 C9                   ret
1758+ 1E43
1759+ 1E43 E5           LETNUM: push    HL              ; Save address of variable
1760+ 1E44 CD 26 2F             call    FPTHL           ; Move value to variable
1761+ 1E47 D1                   pop     DE              ; Restore address of variable
1762+ 1E48 E1                   pop     HL              ; Restore code string address
1763+ 1E49 C9                   ret
1764+ 1E4A
1765+ 1E4A CD 47 29     ON:     call    GETINT          ; Get integer 0-255
1766+ 1E4D 7E                   ld      A,(HL)          ; Get "GOTO" or "GOSUB" token
1767+ 1E4E 47                   ld      B,A             ; Save in B
1768+ 1E4F FE 8C                cp      ZGOSUB          ; "GOSUB" token?
1769+ 1E51 CA 59 1E             jp      Z,ONGO          ; Yes - Find line number
1770+ 1E54 CD E7 19             call    CHKSYN          ; Make sure it's "GOTO"
1771+ 1E57 88                   defb    ZGOTO           ; "GOTO" token
1772+ 1E58 2B                   dec     HL              ; Cancel increment
1773+ 1E59 4B           ONGO:   ld      C,E             ; Integer of branch value
1774+ 1E5A 0D           ONGOLP: dec     C               ; Count branches
1775+ 1E5B 78                   ld      A,B             ; Get "GOTO" or "GOSUB" token
1776+ 1E5C CA 18 1C             jp      Z,ONJMP         ; Go to that line if right one
1777+ 1E5F CD 01 1D             call    GETLN           ; Get line number to DE
1778+ 1E62 FE 2C                cp      ','             ; Another line number?
1779+ 1E64 C0                   ret     NZ              ; No - Drop through
1780+ 1E65 C3 5A 1E             jp      ONGOLP          ; Yes - loop
1781+ 1E68
1782+ 1E68 CD D3 20     IF:     call    EVAL            ; Evaluate expression
1783+ 1E6B 7E                   ld      A,(HL)          ; Get token
1784+ 1E6C FE 88                cp      ZGOTO           ; "GOTO" token?
1785+ 1E6E CA 76 1E             jp      Z,IFGO          ; Yes - Get line
1786+ 1E71 CD E7 19             call    CHKSYN          ; Make sure it's "THEN"
1787+ 1E74 BA                   defb    ZTHEN           ; "THEN" token
1788+ 1E75 2B                   dec     HL              ; Cancel increment
1789+ 1E76 CD C4 20     IFGO:   call    TSTNUM          ; Make sure it's numeric
1790+ 1E79 CD CE 2E             call    TSTSGN          ; Test state of expression
1791+ 1E7C CA 88 1E             jp      Z,IF1           ; False - Jump over
1792+ 1E7F CD 30 1C     IF0:    call    GETCHR          ; Get next character
1793+ 1E82 DA 96 1D             jp      C,GOTO          ; Number - GOTO that line
1794+ 1E85 C3 17 1C             jp      IFJMP           ; Otherwise do statement
1795+ 1E88 0E AE        IF1:    ld      C,ZELSE
1796+ 1E8A CD DD 1D             call    REM+2           ; check statement
1797+ 1E8D B7                   or      A               ; end of line?
1798+ 1E8E C8                   ret     Z               ; yes, leave
1799+ 1E8F FE AE                cp      ZELSE
1800+ 1E91 20 F5                jr      NZ,IF1          ; ELSE not found, continue check
1801+ 1E93 C3 7F 1E             jp      IF0             ; return to IF
1802+ 1E96
1803+ 1E96
1804+ 1E96 2B           MRPRNT: dec     HL              ; dec 'cos GETCHR INCs
1805+ 1E97 CD 30 1C             call    GETCHR          ; Get next character
1806+ 1E9A CA FD 1E     PRINT:  jp      Z,PRNTCRLF      ; CRLF if just PRINT
1807+ 1E9D C8           PRNTLP: ret     Z               ; End of list - Exit
1808+ 1E9E FE B6                cp      ZTAB            ; "TAB(" token?
1809+ 1EA0 CA 25 1F             jp      Z,DOTAB         ; Yes - Do TAB routine
1810+ 1EA3 FE B9                cp      ZSPC            ; "SPC(" token?
1811+ 1EA5 CA 25 1F             jp      Z,DOTAB         ; Yes - Do SPC routine
1812+ 1EA8 E5                   push    HL              ; Save code string address
1813+ 1EA9 FE 2C                cp      ','             ; Comma?
1814+ 1EAB CA 0C 1F             jp      Z,DOCOM         ; Yes - Move to next zone
1815+ 1EAE FE 3B                cp      ';'             ; Semi-colon?
1816+ 1EB0 CA 49 1F             jp      Z,NEXITM        ; Do semi-colon routine
1817+ 1EB3 C1                   pop     BC              ; Code string address to BC
1818+ 1EB4 CD D3 20             call    EVAL            ; Evaluate expression
1819+ 1EB7 E5                   push    HL              ; Save code string address
1820+ 1EB8 3A 94 81             ld      A,(TYPE)        ; Get variable type
1821+ 1EBB B7                   or      A               ; Is it a string variable?
1822+ 1EBC C2 E4 1E             jp      NZ,PRNTST       ; Yes - Output string contents
1823+ 1EBF CD 73 30             call    NUMASC          ; Convert number to text
1824+ 1EC2 CD 87 25             call    CRTST           ; Create temporary string
1825+ 1EC5 36 00                ld      (HL),NLLCR      ; Followed by a NULL char (was SPC, space)
1826+ 1EC7 2A 31 82             ld      HL,(FPREG)      ; Get length of output
1827+ 1ECA 34                   inc     (HL)            ; Plus 1 for the space
1828+ 1ECB 2A 31 82             ld      HL,(FPREG)      ; < Not needed >
1829+ 1ECE 3A A2 80             ld      A,(LWIDTH)      ; Get width of line
1830+ 1ED1 47                   ld      B,A             ; To B
1831+ 1ED2 04                   inc     B               ; Width 255 (No limit)?
1832+ 1ED3 CA E0 1E             jp      Z,PRNTNB        ; Yes - Output number string
1833+ 1ED6 04                   inc     B               ; Adjust it
1834+ 1ED7 3A 92 81             ld      A,(CURPOS)      ; Get cursor position
1835+ 1EDA 86                   add     A,(HL)          ; Add length of string
1836+ 1EDB 3D                   dec     A               ; Adjust it
1837+ 1EDC B8                   cp      B               ; Will output fit on this line?
1838+ 1EDD D4 FD 1E             call    NC,PRNTCRLF     ; No - CRLF first
1839+ 1EE0 CD CC 25     PRNTNB: call    PRS1            ; Output string at (HL)
1840+ 1EE3 AF                   xor     A               ; Skip call by setting 'z' flag
1841+ 1EE4 C4 CC 25     PRNTST: call    NZ,PRS1         ; Output string at (HL)
1842+ 1EE7 E1                   pop     HL              ; Restore code string address
1843+ 1EE8 C3 96 1E             jp      MRPRNT          ; See if more to PRINT
1844+ 1EEB
1845+ 1EEB 3A 92 81     STTLIN: ld      A,(CURPOS)      ; Make sure on new line
1846+ 1EEE B7                   or      A               ; Already at start?
1847+ 1EEF C8                   ret     Z               ; Yes - Do nothing
1848+ 1EF0 C3 FD 1E             jp      PRNTCRLF        ; Start a new line
1849+ 1EF3
1850+ 1EF3 AF           ENDINP: xor     A
1851+ 1EF4 32 17 82             ld      (KBDNPT),A      ; char is not from keyboard
1852+ 1EF7 77                   ld      (HL),A          ; Mark end of buffer
1853+ 1EF8 21 37 81             ld      HL,BUFFER-1     ; Point to buffer
1854+ 1EFB 18 0A                jr      CNTEND
1855+ 1EFD 3E 0D        PRNTCRLF:ld     A,CR            ; Load a CR
1856+ 1EFF CD F2 19             call    OUTC            ; Output character
1857+ 1F02 3E 0A                ld      A,LF            ; Load a LF
1858+ 1F04 CD F2 19             call    OUTC            ; Output character
1859+ 1F07 AF           CNTEND: xor     A               ; Set to position 0
1860+ 1F08 32 92 81             ld      (CURPOS),A      ; Store it
1861+ 1F0B C9                   ret                     ; return to caller
1862+ 1F0C
1863+ 1F0C 3A A3 80     DOCOM:  ld      A,(COMMAN)      ; Get comma width
1864+ 1F0F 47                   ld      B,A             ; Save in B
1865+ 1F10 3A D2 81             ld      A,(SCR_CURS_X)  ; Get current position
1866+ 1F13 B8                   cp      B               ; Within the limit?
1867+ 1F14 D4 FD 1E             call    NC,PRNTCRLF     ; No - output CRLF
1868+ 1F17 D2 49 1F             jp      NC,NEXITM       ; Get next item
1869+ 1F1A D6 0A        ZONELP: sub     $0A             ; Next zone of 10 characters
1870+ 1F1C D2 1A 1F             jp      NC,ZONELP       ; Repeat if more zones
1871+ 1F1F 2F                   cpl                     ; Number of null chars to output
1872+ 1F20 0E 00                ld      C,NLLCR         ; null char
1873+ 1F22 C3 3F 1F             jp      ASPCS           ; Output them
1874+ 1F25
1875+ 1F25 F5           DOTAB:  push    AF              ; Save token
1876+ 1F26 CD 44 29             call    FNDNUM          ; Evaluate expression
1877+ 1F29 CD E7 19             call    CHKSYN          ; Make sure ")" follows
1878+ 1F2C 29                   defb    ')'
1879+ 1F2D 2B                   dec     HL              ; Back space on to ")"
1880+ 1F2E F1                   pop     AF              ; Restore token
1881+ 1F2F 0E 00                ld      C,NLLCR         ; for SPC we use NULL char (was SPACE)
1882+ 1F31 D6 B9                sub     ZSPC            ; Was it "SPC(" ?
1883+ 1F33 E5                   push    HL              ; Save code string address
1884+ 1F34 CA 3A 1F             jp      Z,DOSPC         ; Yes - Do 'E' spaces
1885+ 1F37 3A D2 81             ld      A,(SCR_CURS_X)  ; Get current X position
1886+ 1F3A 2F           DOSPC:  cpl                     ; Number of spaces to print to
1887+ 1F3B 83                   add     A,E             ; Total number to print
1888+ 1F3C D2 49 1F             jp      NC,NEXITM       ; TAB < Current POS(X)
1889+ 1F3F 3C           ASPCS:  inc     A               ; Output A spaces
1890+ 1F40 47                   ld      B,A             ; Save number to print
1891+ 1F41 79           SPCLP:  ld      A,C             ; char to print
1892+ 1F42 CD F2 19             call    OUTC            ; Output character in A
1893+ 1F45 05                   dec     B               ; Count them
1894+ 1F46 C2 41 1F             jp      NZ,SPCLP        ; Repeat if more
1895+ 1F49 E1           NEXITM: pop     HL              ; Restore code string address
1896+ 1F4A CD 30 1C             call    GETCHR          ; Get next character
1897+ 1F4D C3 9D 1E             jp      PRNTLP          ; More to print
1898+ 1F50
1899+ 1F50 3F 52 65 64  REDO:   defb    "?Redo from start",CR,0
1899+ 1F54 6F 20 66 72
1899+ 1F58 6F 6D 20 73
1899+ 1F5C 74 61 72 74
1899+ 1F60 0D 00
1900+ 1F62
1901+ 1F62 3A B4 81     BADINP: ld      A,(READFG)      ; READ or INPUT?
1902+ 1F65 B7                   or      A
1903+ 1F66 C2 E7 16             jp      NZ,DATSNR       ; READ - ?SN Error
1904+ 1F69 C1                   pop     BC              ; Throw away code string addr
1905+ 1F6A 21 50 1F             ld      HL,REDO         ; "Redo from start" message
1906+ 1F6D CD C9 25             call    PRS             ; Output string
1907+ 1F70 C3 62 18             jp      DOAGN           ; Do last INPUT again
1908+ 1F73
1909+ 1F73 CD 34 25     INPUT:  call    IDTEST          ; Test for illegal direct
1910+ 1F76 7E                   ld      A,(HL)          ; Get character after "INPUT"
1911+ 1F77 FE 22                cp      $22             ; '"' ; Is there a prompt string?
1912+ 1F79 3E 00                ld      A,$00           ; Clear A and leave flags
1913+ 1F7B 32 A5 80             ld      (CTLOFG),A      ; Enable output
1914+ 1F7E C2 8D 1F             jp      NZ,NOPMPT       ; No prompt - get input
1915+ 1F81 CD 88 25             call    QTSTR           ; Get string terminated by '"'
1916+ 1F84 CD E7 19             call    CHKSYN          ; Check for ';' after prompt
1917+ 1F87 3B                   defb    ";"
1918+ 1F88 E5                   push    HL              ; Save code string address
1919+ 1F89 CD CC 25             call    PRS1            ; Output prompt string
1920+ 1F8C 3E                   defb    $3E             ; Skip "push HL"
1921+ 1F8D E5           NOPMPT: push    HL              ; Save code string address
1922+ 1F8E CD 66 18             call    PROMPT          ; Get input with "? " prompt
1923+ 1F91 C1                   pop     BC              ; Restore code string address
1924+ 1F92 DA 7F 1C             jp      C,INPBRK        ; Break pressed - Exit
1925+ 1F95 23                   inc     HL              ; Next byte
1926+ 1F96 7E                   ld      A,(HL)          ; Get it
1927+ 1F97 B7                   or      A               ; End of line?
1928+ 1F98 2B                   dec     HL              ; Back again
1929+ 1F99 C5                   push    BC              ; Re-save code string address
1930+ 1F9A 3A 1F 82             ld      A,(SERIALS_EN)  ; load serial state
1931+ 1F9D EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
1932+ 1F9F CC 8F 01             call    Z,A_RTS_OFF      ; yes, set RTS on
1933+ 1FA2 CD 4D 09             call    CURSOR_OFF      ; disable cursor
1934+ 1FA5 CA D8 1D             jp      Z,NXTDTA        ; Yes - Find next DATA stmt
1935+ 1FA8 36 2C                ld      (HL),','        ; Store comma as separator
1936+ 1FAA C3 B2 1F             jp      NXTITM          ; Get next item
1937+ 1FAD
1938+ 1FAD E5           READ:   push    HL              ; Save code string address
1939+ 1FAE 2A 29 82             ld      HL,(NXTDAT)     ; Next DATA statement
1940+ 1FB1 F6                   defb    $F6             ; Flag "READ"
1941+ 1FB2 AF           NXTITM: xor     A               ; Flag "INPUT"
1942+ 1FB3 32 B4 81             ld      (READFG),A      ; Save "READ"/"INPUT" flag
1943+ 1FB6 E3                   ex      (SP),HL         ; Get code str' , Save pointer
1944+ 1FB7 C3 BE 1F             jp      GTVLUS          ; Get values
1945+ 1FBA
1946+ 1FBA CD E7 19     NEDMOR: call    CHKSYN          ; Check for comma between items
1947+ 1FBD 2C                   defb    ','
1948+ 1FBE CD D0 22     GTVLUS: call    GETVAR          ; Get variable name
1949+ 1FC1 E3                   ex      (SP),HL         ; Save code str" , Get pointer
1950+ 1FC2 D5                   push    DE              ; Save variable address
1951+ 1FC3 7E                   ld      A,(HL)          ; Get next "INPUT"/"DATA" byte
1952+ 1FC4 FE 2C                cp      ','             ; Comma?
1953+ 1FC6 CA E6 1F             jp      Z,ANTVLU        ; Yes - Get another value
1954+ 1FC9 3A B4 81             ld      A,(READFG)      ; Is it READ?
1955+ 1FCC B7                   or      A
1956+ 1FCD C2 52 20             jp      NZ,FDTLP        ; Yes - Find next DATA stmt
1957+ 1FD0 3E 3F                ld      A,'?'           ; More INPUT needed
1958+ 1FD2 CD F2 19             call    OUTC            ; Output character
1959+ 1FD5 CD 66 18             call    PROMPT          ; Get INPUT with prompt
1960+ 1FD8 D1                   pop     DE              ; Variable address
1961+ 1FD9 C1                   pop     BC              ; Code string address
1962+ 1FDA DA 7F 1C             jp      C,INPBRK        ; Break pressed
1963+ 1FDD 23                   inc     HL              ; Point to next DATA byte
1964+ 1FDE 7E                   ld      A,(HL)          ; Get byte
1965+ 1FDF B7                   or      A               ; Is it zero (No input) ?
1966+ 1FE0 2B                   dec     HL              ; Back space INPUT pointer
1967+ 1FE1 C5                   push    BC              ; Save code string address
1968+ 1FE2 CA D8 1D             jp      Z,NXTDTA        ; Find end of buffer
1969+ 1FE5 D5                   push    DE              ; Save variable address
1970+ 1FE6 3A 94 81     ANTVLU: ld      A,(TYPE)        ; Check data type
1971+ 1FE9 B7                   or      A               ; Is it numeric?
1972+ 1FEA CA 10 20             jp      Z,INPBIN        ; Yes - Convert to binary
1973+ 1FED CD 30 1C             call    GETCHR          ; Get next character
1974+ 1FF0 57                   ld      D,A             ; Save input character
1975+ 1FF1 47                   ld      B,A             ; Again
1976+ 1FF2 FE 22                cp      $22             ; '"'     ; Start of literal sting?
1977+ 1FF4 CA 04 20             jp      Z,STRENT        ; Yes - Create string entry
1978+ 1FF7 3A B4 81             ld      A,(READFG)      ; "READ" or "INPUT" ?
1979+ 1FFA B7                   or      A
1980+ 1FFB 57                   ld      D,A             ; Save 00 if "INPUT"
1981+ 1FFC CA 01 20             jp      Z,ITMSEP        ; "INPUT" - End with 00
1982+ 1FFF 16 3A                ld      D,':'           ; "DATA" - End with 00 or ':'
1983+ 2001 06 2C        ITMSEP: ld      B,','           ; Item separator
1984+ 2003 2B                   dec     HL              ; Back space for DTSTR
1985+ 2004 CD 8B 25     STRENT: call    DTSTR           ; Get string terminated by D
1986+ 2007 EB                   ex      DE,HL           ; String address to DE
1987+ 2008 21 1B 20             ld      HL,LTSTND       ; Where to go after LETSTR
1988+ 200B E3                   ex      (SP),HL         ; Save HL , get input pointer
1989+ 200C D5                   push    DE              ; Save address of string
1990+ 200D C3 0B 1E             jp      LETSTR          ; Assign string to variable
1991+ 2010
1992+ 2010 CD 30 1C     INPBIN: call    GETCHR          ; Get next character
1993+ 2013 CD D5 2F             call    ASCTFP          ; Convert ASCII to FP number
1994+ 2016 E3                   ex      (SP),HL         ; Save input ptr, Get var addr
1995+ 2017 CD 26 2F             call    FPTHL           ; Move FPREG to variable
1996+ 201A E1                   pop     HL              ; Restore input pointer
1997+ 201B 2B           LTSTND: dec     HL              ; dec 'cos GETCHR INCs
1998+ 201C CD 30 1C             call    GETCHR          ; Get next character
1999+ 201F CA 27 20             jp      Z,MORDT         ; End of line - More needed?
2000+ 2022 FE 2C                cp      ','             ; Another value?
2001+ 2024 C2 62 1F             jp      NZ,BADINP       ; No - Bad input
2002+ 2027 E3           MORDT:  ex      (SP),HL         ; Get code string address
2003+ 2028 2B                   dec     HL              ; dec 'cos GETCHR INCs
2004+ 2029 CD 30 1C             call    GETCHR          ; Get next character
2005+ 202C C2 BA 1F             jp      NZ,NEDMOR       ; More needed - Get it
2006+ 202F D1                   pop     DE              ; Restore DATA pointer
2007+ 2030 3A B4 81             ld      A,(READFG)      ; "READ" or "INPUT" ?
2008+ 2033 B7                   or      A
2009+ 2034 EB                   ex      DE,HL           ; DATA pointer to HL
2010+ 2035 C2 56 1C             jp      NZ,UPDATA       ; Update DATA pointer if "READ"
2011+ 2038 D5                   push    DE              ; Save code string address
2012+ 2039 B6                   or      (HL)            ; More input given?
2013+ 203A 21 42 20             ld      HL,EXTIG        ; "?Extra ignored" message
2014+ 203D C4 C9 25             call    NZ,PRS          ; Output string if extra given
2015+ 2040 E1                   pop     HL              ; Restore code string address
2016+ 2041 C9                   ret
2017+ 2042
2018+ 2042 3F 45 78 74  EXTIG:  defb    "?Extra ignored",CR,0
2018+ 2046 72 61 20 69
2018+ 204A 67 6E 6F 72
2018+ 204E 65 64 0D 00
2019+ 2052
2020+ 2052 CD D9 1D     FDTLP:  call    DATA            ; Get next statement
2021+ 2055 B7                   or      A               ; End of line?
2022+ 2056 C2 6B 20             jp      NZ,FANDT        ; No - See if DATA statement
2023+ 2059 23                   inc     HL
2024+ 205A 7E                   ld      A,(HL)          ; End of program?
2025+ 205B 23                   inc     HL
2026+ 205C B6                   or      (HL)            ; 00 00 Ends program
2027+ 205D 1E 06                ld      E,OD            ; ?OD Error
2028+ 205F CA 01 17             jp      Z,ERROR         ; Yes - Out of DATA
2029+ 2062 23                   inc     HL
2030+ 2063 5E                   ld      E,(HL)          ; LSB of line number
2031+ 2064 23                   inc     HL
2032+ 2065 56                   ld      D,(HL)          ; MSB of line number
2033+ 2066 EB                   ex      DE,HL
2034+ 2067 22 B0 81             ld      (DATLIN),HL     ; Set line of current DATA item
2035+ 206A EB                   ex      DE,HL
2036+ 206B CD 30 1C     FANDT:  call    GETCHR          ; Get next character
2037+ 206E FE 83                cp      ZDATA           ; "DATA" token
2038+ 2070 C2 52 20             jp      NZ,FDTLP        ; No "DATA" - Keep looking
2039+ 2073 C3 E6 1F             jp      ANTVLU          ; Found - Convert input
2040+ 2076
2041+ 2076 11 00 00     NEXT:   ld      DE,$0000        ; In case no index given
2042+ 2079 C4 D0 22     NEXT1:  call    NZ,GETVAR       ; Get index address
2043+ 207C 22 B5 81             ld      (BRKLIN),HL     ; Save code string address
2044+ 207F CD 76 16             call    BAKSTK          ; Look for "FOR" block
2045+ 2082 C2 F3 16             jp      NZ,NFERR        ; No "FOR" - ?NF Error
2046+ 2085 F9                   ld      SP,HL           ; Clear nested loops
2047+ 2086 D5                   push    DE              ; Save index address
2048+ 2087 7E                   ld      A,(HL)          ; Get sign of STEP
2049+ 2088 23                   inc     HL
2050+ 2089 F5                   push    AF              ; Save sign of STEP
2051+ 208A D5                   push    DE              ; Save index address
2052+ 208B CD 0C 2F             call    PHLTFP          ; Move index value to FPREG
2053+ 208E E3                   ex      (SP),HL         ; Save address of TO value
2054+ 208F E5                   push    HL              ; Save address of index
2055+ 2090 CD 28 2C             call    ADDPHL          ; Add STEP to index value
2056+ 2093 E1                   pop     HL              ; Restore address of index
2057+ 2094 CD 26 2F             call    FPTHL           ; Move value to index variable
2058+ 2097 E1                   pop     HL              ; Restore address of TO value
2059+ 2098 CD 1D 2F             call    LOADFP          ; Move TO value to BCDE
2060+ 209B E5                   push    HL              ; Save address of line of FOR
2061+ 209C CD 49 2F             call    CMPNUM          ; Compare index with TO value
2062+ 209F E1                   pop     HL              ; Restore address of line num
2063+ 20A0 C1                   pop     BC              ; Address of sign of STEP
2064+ 20A1 90                   sub     B               ; Compare with expected sign
2065+ 20A2 CD 1D 2F             call    LOADFP          ; BC = Loop stmt,DE = Line num
2066+ 20A5 CA B1 20             jp      Z,KILFOR        ; Loop finished - Terminate it
2067+ 20A8 EB                   ex      DE,HL           ; Loop statement line number
2068+ 20A9 22 AF 80             ld      (LINEAT),HL     ; Set loop line number
2069+ 20AC 69                   ld      L,C             ; Set code string to loop
2070+ 20AD 60                   ld      H,B
2071+ 20AE C3 EC 1B             jp      PUTFID          ; Put back "FOR" and continue
2072+ 20B1
2073+ 20B1 F9           KILFOR: ld      SP,HL           ; Remove "FOR" block
2074+ 20B2 2A B5 81             ld      HL,(BRKLIN)     ; Code string after "NEXT"
2075+ 20B5 7E                   ld      A,(HL)          ; Get next byte in code string
2076+ 20B6 FE 2C                cp      ','             ; More NEXTs ?
2077+ 20B8 C2 F0 1B             jp      NZ,RUNCNT       ; No - Do next statement
2078+ 20BB CD 30 1C             call    GETCHR          ; Position to index name
2079+ 20BE CD 79 20             call    NEXT1           ; Re-enter NEXT routine
2080+ 20C1              ; < will not RETurn to here , Exit to RUNCNT or Loop >
2081+ 20C1
2082+ 20C1 CD D3 20     GETNUM: call    EVAL            ; Get a numeric expression
2083+ 20C4 F6           TSTNUM: defb    $F6             ; Clear carry (numeric)
2084+ 20C5 37           TSTSTR: scf                     ; Set carry (string)
2085+ 20C6 3A 94 81     CHKTYP: ld      A,(TYPE)        ; Check types match
2086+ 20C9 8F                   adc     A,A             ; Expected + actual
2087+ 20CA B7                   or      A               ; Clear carry , set parity
2088+ 20CB E8                   ret     PE              ; Even parity - Types match
2089+ 20CC C3 FF 16             jp      TMERR           ; Different types - Error
2090+ 20CF
2091+ 20CF CD E7 19     OPNPAR: call    CHKSYN          ; Make sure "(" follows
2092+ 20D2 28                   defb    '('
2093+ 20D3 2B           EVAL:   dec     HL              ; Evaluate expression & save
2094+ 20D4 16 00                ld      D,$00           ; Precedence value
2095+ 20D6 D5           EVAL1:  push    DE              ; Save precedence
2096+ 20D7 0E 01                ld      C,$01
2097+ 20D9 CD AA 16             call    CHKSTK          ; Check for 1 level of stack
2098+ 20DC CD 4A 21             call    OPRND           ; Get next expression value
2099+ 20DF 22 B7 81     EVAL2:  ld      (NXTOPR),HL     ; Save address of next operator
2100+ 20E2 2A B7 81     EVAL3:  ld      HL,(NXTOPR)     ; Restore address of next opr
2101+ 20E5 C1                   pop     BC              ; Precedence value and operator
2102+ 20E6 78                   ld      A,B             ; Get precedence value
2103+ 20E7 FE 78                cp      $78             ; "AND", "OR", or "XOR" ?
2104+ 20E9 D4 C4 20             call    NC,TSTNUM       ; No - Make sure it's a number
2105+ 20EC 7E                   ld      A,(HL)          ; Get next operator / function
2106+ 20ED 16 00                ld      D,$00           ; Clear Last relation
2107+ 20EF D6 C7        RLTLP:  sub     ZGTR            ; ">" Token
2108+ 20F1 DA 0B 21             jp      C,FOPRND        ; + - * / ^ AND OR XOR - Test it
2109+ 20F4 FE 03                cp      ZLTH+1-ZGTR     ; < = >
2110+ 20F6 D2 0B 21             jp      NC,FOPRND       ; Function - Call it
2111+ 20F9 FE 01                cp      ZEQUAL-ZGTR     ; "="
2112+ 20FB 17                   rla                     ; <- Test for legal
2113+ 20FC AA                   xor     D               ; <- combinations of < = >
2114+ 20FD BA                   cp      D               ; <- by combining last token
2115+ 20FE 57                   ld      D,A             ; <- with current one
2116+ 20FF DA ED 16             jp      C,SNERR         ; Error if "<<' '==" or ">>"
2117+ 2102 22 AC 81             ld      (CUROPR),HL     ; Save address of current token
2118+ 2105 CD 30 1C             call    GETCHR          ; Get next character
2119+ 2108 C3 EF 20             jp      RLTLP           ; Treat the two as one
2120+ 210B
2121+ 210B 7A           FOPRND: ld      A,D             ; < = > found ?
2122+ 210C B7                   or      A
2123+ 210D C2 4B 22             jp      NZ,TSTRED       ; Yes - Test for reduction
2124+ 2110 7E                   ld      A,(HL)          ; Get operator token
2125+ 2111 22 AC 81             ld      (CUROPR),HL     ; Save operator address
2126+ 2114 D6 BD                sub     ZPLUS           ; Operator or function?
2127+ 2116 D8                   ret     C               ; Neither - Exit
2128+ 2117 FE 0A                cp      ZOR+1-ZPLUS     ; Is it + - * / ^ AND XOR OR ?
2129+ 2119 D0                   ret     NC              ; No - Exit
2130+ 211A 5F                   ld      E,A             ; Coded operator
2131+ 211B 3A 94 81             ld      A,(TYPE)        ; Get data type
2132+ 211E 3D                   dec     A               ; FF = numeric , 00 = string
2133+ 211F B3                   or      E               ; Combine with coded operator
2134+ 2120 7B                   ld      A,E             ; Get coded operator
2135+ 2121 CA BF 26             jp      Z,CONCAT        ; String concatenation
2136+ 2124 07                   rlca                    ; Times 2
2137+ 2125 83                   add     A,E             ; Times 3
2138+ 2126 5F                   ld      E,A             ; To DE (D is 0)
2139+ 2127 21 68 15             ld      HL,PRITAB       ; Precedence table
2140+ 212A 19                   add     HL,DE           ; To the operator concerned
2141+ 212B 78                   ld      A,B             ; Last operator precedence
2142+ 212C 56                   ld      D,(HL)          ; Get evaluation precedence
2143+ 212D BA                   cp      D               ; Compare with eval precedence
2144+ 212E D0                   ret     NC              ; Exit if higher precedence
2145+ 212F 23                   inc     HL              ; Point to routine address
2146+ 2130 CD C4 20             call    TSTNUM          ; Make sure it's a number
2147+ 2133
2148+ 2133 C5           STKTHS: push    BC              ; Save last precedence & token
2149+ 2134 01 E2 20             ld      BC,EVAL3        ; Where to go on prec' break
2150+ 2137 C5                   push    BC              ; Save on stack for return
2151+ 2138 43                   ld      B,E             ; Save operator
2152+ 2139 4A                   ld      C,D             ; Save precedence
2153+ 213A CD FF 2E             call    STAKFP          ; Move value to stack
2154+ 213D 58                   ld      E,B             ; Restore operator
2155+ 213E 51                   ld      D,C             ; Restore precedence
2156+ 213F 4E                   ld      C,(HL)          ; Get LSB of routine address
2157+ 2140 23                   inc     HL
2158+ 2141 46                   ld      B,(HL)          ; Get MSB of routine address
2159+ 2142 23                   inc     HL
2160+ 2143 C5                   push    BC              ; Save routine address
2161+ 2144 2A AC 81             ld      HL,(CUROPR)     ; Address of current operator
2162+ 2147 C3 D6 20             jp      EVAL1           ; Loop until prec' break
2163+ 214A
2164+ 214A AF           OPRND:  xor     A               ; Get operand routine
2165+ 214B 32 94 81             ld      (TYPE),A        ; Set numeric expected
2166+ 214E CD 30 1C             call    GETCHR          ; Get next character
2167+ 2151 1E 24                ld      E,MO            ; ?MO Error
2168+ 2153 CA 01 17             jp      Z,ERROR         ; No operand - Error
2169+ 2156 DA D5 2F             jp      C,ASCTFP        ; Number - Get value
2170+ 2159 CD D2 1C             call    CHKLTR          ; See if a letter
2171+ 215C D2 B1 21             jp      NC,CONVAR       ; Letter - Find variable
2172+ 215F FE 26                cp      '&'             ; &H = HEX, &B = BINARY
2173+ 2161 20 12                jr      NZ,NOTAMP
2174+ 2163 CD 30 1C             call    GETCHR          ; Get next character
2175+ 2166 FE 48                cp      'H'             ; Hex number indicated? [function added]
2176+ 2168 CA 3D 3F             jp      Z,HEXTFP        ; Convert Hex to FPREG
2177+ 216B FE 42                cp      'B'             ; Binary number indicated? [function added]
2178+ 216D CA AD 3F             jp      Z,BINTFP        ; Convert Bin to FPREG
2179+ 2170 1E 02                ld      E,SN            ; If neither then a ?SN Error
2180+ 2172 CA 01 17             jp      Z,ERROR         ;
2181+ 2175 FE BD        NOTAMP: cp      ZPLUS           ; '+' Token ?
2182+ 2177 CA 4A 21             jp      Z,OPRND         ; Yes - Look for operand
2183+ 217A FE 2E                cp      '.'             ; '.' ?
2184+ 217C CA D5 2F             jp      Z,ASCTFP        ; Yes - Create FP number
2185+ 217F FE BE                cp      ZMINUS          ; '-' Token ?
2186+ 2181 CA A0 21             jp      Z,MINUS         ; Yes - Do minus
2187+ 2184 FE 22                cp      $22             ; '"'             ; Literal string ?
2188+ 2186 CA 88 25             jp      Z,QTSTR         ; Get string terminated by '"'
2189+ 2189 FE BB                cp      ZNOT            ; "NOT" Token ?
2190+ 218B CA AB 22             jp      Z,EVNOT         ; Yes - Eval NOT expression
2191+ 218E FE B8                cp      ZFN             ; "FN" Token ?
2192+ 2190 CA EC 24             jp      Z,DOFN          ; Yes - Do FN routine
2193+ 2193 D6 CA                sub     ZSGN            ; Is it a function?
2194+ 2195 D2 C2 21             jp      NC,FNOFST       ; Yes - Evaluate function
2195+ 2198 CD CF 20     EVLPAR: call    OPNPAR          ; Evaluate expression in "()"
2196+ 219B CD E7 19             call    CHKSYN          ; Make sure ")" follows
2197+ 219E 29                   defb    ')'
2198+ 219F C9                   ret
2199+ 21A0
2200+ 21A0 16 7D        MINUS:  ld      D,$7D           ; '-' precedence
2201+ 21A2 CD D6 20             call    EVAL1           ; Evaluate until prec' break
2202+ 21A5 2A B7 81             ld      HL,(NXTOPR)     ; Get next operator address
2203+ 21A8 E5                   push    HL              ; Save next operator address
2204+ 21A9 CD F7 2E             call    INVSGN          ; Negate value
2205+ 21AC CD C4 20     RETNUM: call    TSTNUM          ; Make sure it's a number
2206+ 21AF E1                   pop     HL              ; Restore next operator address
2207+ 21B0 C9                   ret
2208+ 21B1
2209+ 21B1 CD D0 22     CONVAR: call    GETVAR          ; Get variable address to DE
2210+ 21B4 E5           FRMEVL: push    HL              ; Save code string address
2211+ 21B5 EB                   ex      DE,HL           ; Variable address to HL
2212+ 21B6 22 31 82             ld      (FPREG),HL      ; Save address of variable
2213+ 21B9 3A 94 81             ld      A,(TYPE)        ; Get type
2214+ 21BC B7                   or      A               ; Numeric?
2215+ 21BD CC 0C 2F             call    Z,PHLTFP        ; Yes - Move contents to FPREG
2216+ 21C0 E1                   pop     HL              ; Restore code string address
2217+ 21C1 C9                   ret
2218+ 21C2
2219+ 21C2 06 00        FNOFST: ld      B,$00           ; Get address of function
2220+ 21C4 07                   rlca                    ; Double function offset
2221+ 21C5 4F                   ld      C,A             ; BC = Offset in function table
2222+ 21C6 C5                   push    BC              ; Save adjusted token value
2223+ 21C7 CD 30 1C             call    GETCHR          ; Get next character
2224+ 21CA 79                   ld      A,C             ; Get adjusted token value
2225+ 21CB FE 2C                cp      2*(ZPOINT-ZSGN) ; "POINT" token?
2226+ 21CD CA FB 36             jp      Z,POINT         ; Yes, do "POINT"
2227+ 21D0 FE 2E                cp      2*(ZINSTR-ZSGN) ; "INSTR" token?
2228+ 21D2 CA 9B 27             jp      Z,INSTR         ; Yes, do "INSTR"
2229+ 21D5 FE 3D                cp      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
2230+ 21D7 DA F3 21             jp      C,FNVAL         ; No - Do function
2231+ 21DA CD CF 20             call    OPNPAR          ; Evaluate expression  (X,...
2232+ 21DD CD E7 19             call    CHKSYN          ; Make sure ',' follows
2233+ 21E0 2C                   defb    ','
2234+ 21E1 CD C5 20             call    TSTSTR          ; Make sure it's a string
2235+ 21E4 EB                   ex      DE,HL           ; Save code string address
2236+ 21E5 2A 31 82             ld      HL,(FPREG)      ; Get address of string
2237+ 21E8 E3                   ex      (SP),HL         ; Save address of string
2238+ 21E9 E5                   push    HL              ; Save adjusted token value
2239+ 21EA EB                   ex      DE,HL           ; Restore code string address
2240+ 21EB CD 47 29             call    GETINT          ; Get integer 0-255
2241+ 21EE EB                   ex      DE,HL           ; Save code string address
2242+ 21EF E3                   ex      (SP),HL         ; Save integer,HL = adj' token
2243+ 21F0 C3 FB 21             jp      GOFUNC          ; Jump to string function
2244+ 21F3
2245+ 21F3 CD 98 21     FNVAL:  call    EVLPAR          ; Evaluate expression
2246+ 21F6 E3                   ex      (SP),HL         ; HL = Adjusted token value
2247+ 21F7 11 AC 21             ld      DE,RETNUM       ; Return number from function
2248+ 21FA D5                   push    DE              ; Save on stack
2249+ 21FB 01 2B 13     GOFUNC: ld      BC,FNCTAB       ; Function routine addresses
2250+ 21FE 09                   add     HL,BC           ; Point to right address
2251+ 21FF 4E                   ld      C,(HL)          ; Get LSB of address
2252+ 2200 23                   inc     HL              ;
2253+ 2201 66                   ld      H,(HL)          ; Get MSB of address
2254+ 2202 69                   ld      L,C             ; Address to HL
2255+ 2203 E9                   jp      (HL)            ; Jump to function
2256+ 2204
2257+ 2204 15           SGNEXP: dec     D               ; Dee to flag negative exponent
2258+ 2205 FE BE                cp      ZMINUS          ; '-' token ?
2259+ 2207 C8                   ret     Z               ; Yes - Return
2260+ 2208 FE 2D                cp      '-'             ; '-' ASCII ?
2261+ 220A C8                   ret     Z               ; Yes - Return
2262+ 220B 14                   inc     D               ; Inc to flag positive exponent
2263+ 220C FE 2B                cp      '+'             ; '+' ASCII ?
2264+ 220E C8                   ret     Z               ; Yes - Return
2265+ 220F FE BD                cp      ZPLUS           ; '+' token ?
2266+ 2211 C8                   ret     Z               ; Yes - Return
2267+ 2212 2B                   dec     HL              ; dec 'cos GETCHR INCs
2268+ 2213 C9                   ret                     ; Return "NZ"
2269+ 2214
2270+ 2214              ; execute OR, AND, and XOR operations
2271+ 2214 AF           PAND:   xor     A               ; for AND, Z=1
2272+ 2215 18 07                jr      CNTLGC
2273+ 2217 AF           POR:    xor     A               ; for OR, Z=0, S=1
2274+ 2218 D6 01                sub     $01
2275+ 221A 18 02                jr      CNTLGC
2276+ 221C AF           PXOR:   xor     A               ; for XOR, Z=0, S=0
2277+ 221D 3C                   inc     A
2278+ 221E F5           CNTLGC: push    AF              ; store operand's flags
2279+ 221F CD C4 20             call    TSTNUM          ; Make sure it's a number
2280+ 2222 CD E6 1C             call    DEINT           ; Get integer -32768 to 32767
2281+ 2225 F1                   pop     AF              ; retrieve operand's flags
2282+ 2226 EB                   ex      DE,HL           ; <- Get last
2283+ 2227 C1                   pop     BC              ; <-  value
2284+ 2228 E3                   ex      (SP),HL         ; <-  from
2285+ 2229 EB                   ex      DE,HL           ; <-  stack
2286+ 222A CD 0F 2F             call    FPBCDE          ; Move last value to FPREG
2287+ 222D F5                   push    AF              ; store operand's flags
2288+ 222E CD E6 1C             call    DEINT           ; Get integer -32768 to 32767
2289+ 2231 F1                   pop     AF              ; retrieve operand's flags
2290+ 2232 C1                   pop     BC              ; Get value
2291+ 2233 79                   ld      A,C             ; Get LSB
2292+ 2234 21 AA 24             ld      HL,ACPASS       ; Address of save AC as current
2293+ 2237 20 05                jr      NZ,POR1         ; if X/OR, jump over
2294+ 2239 A3           PAND1:  and     E               ; "AND" LSBs
2295+ 223A 4F                   ld      C,A             ; Save LSB
2296+ 223B 78                   ld      A,B             ; Get MSB
2297+ 223C A2                   and     D               ; "AND" MSBs
2298+ 223D E9                   jp      (HL)            ; Save AC as current (ACPASS)
2299+ 223E F2 46 22     POR1:   jp      P,PXOR1         ; if S=0, jump to XOR
2300+ 2241 B3                   or      E               ; "OR" LSBs
2301+ 2242 4F                   ld      C,A             ; Save LSB
2302+ 2243 78                   ld      A,B             ; Get MSB
2303+ 2244 B2                   or      D               ; "OR" MSBs
2304+ 2245 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2305+ 2246 AB           PXOR1:  xor     E               ; "XOR" LSBs
2306+ 2247 4F                   ld      C,A             ; Save LSB
2307+ 2248 78                   ld      A,B             ; Get MSB
2308+ 2249 AA                   xor     D               ; "XOR" MSBs
2309+ 224A E9                   jp      (HL)            ; Save AC as current (ACPASS)
2310+ 224B
2311+ 224B 21 5D 22     TSTRED: ld      HL,CMPLOG       ; Logical compare routine
2312+ 224E 3A 94 81             ld      A,(TYPE)        ; Get data type
2313+ 2251 1F                   rra                     ; Carry set = string
2314+ 2252 7A                   ld      A,D             ; Get last precedence value
2315+ 2253 17                   rla                     ; Times 2 plus carry
2316+ 2254 5F                   ld      E,A             ; To E
2317+ 2255 16 64                ld      D,$64           ; Relational precedence
2318+ 2257 78                   ld      A,B             ; Get current precedence
2319+ 2258 BA                   cp      D               ; Compare with last
2320+ 2259 D0                   ret     NC              ; Eval if last was rel' or log'
2321+ 225A C3 33 21             jp      STKTHS          ; Stack this one and get next
2322+ 225D
2323+ 225D 5F 22        CMPLOG: defw    CMPLG1          ; Compare two values / strings
2324+ 225F 79           CMPLG1: ld      A,C             ; Get data type
2325+ 2260 B7                   or      A
2326+ 2261 1F                   rra
2327+ 2262 C1                   pop     BC              ; Get last expression to BCDE
2328+ 2263 D1                   pop     DE
2329+ 2264 F5                   push    AF              ; Save status
2330+ 2265 CD C6 20             call    CHKTYP          ; Check that types match
2331+ 2268 21 A1 22             ld      HL,CMPRES       ; Result to comparison
2332+ 226B E5                   push    HL              ; Save for RETurn
2333+ 226C CA 49 2F             jp      Z,CMPNUM        ; Compare values if numeric
2334+ 226F AF                   xor     A               ; Compare two strings
2335+ 2270 32 94 81             ld      (TYPE),A        ; Set type to numeric
2336+ 2273 D5                   push    DE              ; Save string name
2337+ 2274 CD 0C 27             call    GSTRCU          ; Get current string
2338+ 2277 7E                   ld      A,(HL)          ; Get length of string
2339+ 2278 23                   inc     HL
2340+ 2279 23                   inc     HL
2341+ 227A 4E                   ld      C,(HL)          ; Get LSB of address
2342+ 227B 23                   inc     HL
2343+ 227C 46                   ld      B,(HL)          ; Get MSB of address
2344+ 227D D1                   pop     DE              ; Restore string name
2345+ 227E C5                   push    BC              ; Save address of string
2346+ 227F F5                   push    AF              ; Save length of string
2347+ 2280 CD 10 27             call    GSTRDE          ; Get second string
2348+ 2283 CD 1D 2F             call    LOADFP          ; Get address of second string
2349+ 2286 F1                   pop     AF              ; Restore length of string 1
2350+ 2287 57                   ld      D,A             ; Length to D
2351+ 2288 E1                   pop     HL              ; Restore address of string 1
2352+ 2289 7B           CMPSTR: ld      A,E             ; Bytes of string 2 to do
2353+ 228A B2                   or      D               ; Bytes of string 1 to do
2354+ 228B C8                   ret     Z               ; Exit if all bytes compared
2355+ 228C 7A                   ld      A,D             ; Get bytes of string 1 to do
2356+ 228D D6 01                sub     $01
2357+ 228F D8                   ret     C               ; Exit if end of string 1
2358+ 2290 AF                   xor     A
2359+ 2291 BB                   cp      E               ; Bytes of string 2 to do
2360+ 2292 3C                   inc     A
2361+ 2293 D0                   ret     NC              ; Exit if end of string 2
2362+ 2294 15                   dec     D               ; Count bytes in string 1
2363+ 2295 1D                   dec     E               ; Count bytes in string 2
2364+ 2296 0A                   ld      A,(BC)          ; Byte in string 2
2365+ 2297 BE                   cp      (HL)            ; Compare to byte in string 1
2366+ 2298 23                   inc     HL              ; Move up string 1
2367+ 2299 03                   inc     BC              ; Move up string 2
2368+ 229A CA 89 22             jp      Z,CMPSTR        ; Same - Try next bytes
2369+ 229D 3F                   ccf                     ; Flag difference (">" or "<")
2370+ 229E C3 D9 2E             jp      FLGDIF          ; "<" gives -1 , ">" gives +1
2371+ 22A1
2372+ 22A1 3C           CMPRES: inc     A               ; Increment current value
2373+ 22A2 8F                   adc     A,A             ; Double plus carry
2374+ 22A3 C1                   pop     BC              ; Get other value
2375+ 22A4 A0                   and     B               ; Combine them
2376+ 22A5 C6 FF                add     A,-1            ; Carry set if different
2377+ 22A7 9F                   sbc     A,A             ; 00 - Equal , FF - Different
2378+ 22A8 C3 E0 2E             jp      FLGREL          ; Set current value & continue
2379+ 22AB
2380+ 22AB 16 5A        EVNOT:  ld      D,$5A           ; Precedence value for "NOT"
2381+ 22AD CD D6 20             call    EVAL1           ; Eval until precedence break
2382+ 22B0 CD C4 20             call    TSTNUM          ; Make sure it's a number
2383+ 22B3 CD E6 1C             call    DEINT           ; Get integer -32768 - 32767
2384+ 22B6 7B                   ld      A,E             ; Get LSB
2385+ 22B7 2F                   cpl                     ; Invert LSB
2386+ 22B8 4F                   ld      C,A             ; Save "NOT" of LSB
2387+ 22B9 7A                   ld      A,D             ; Get MSB
2388+ 22BA 2F                   cpl                     ; Invert MSB
2389+ 22BB CD AA 24             call    ACPASS          ; Save AC as current
2390+ 22BE C1                   pop     BC              ; Clean up stack
2391+ 22BF C3 E2 20             jp      EVAL3           ; Continue evaluation
2392+ 22C2
2393+ 22C2 2B           DIMRET: dec     HL              ; dec 'cos GETCHR INCs
2394+ 22C3 CD 30 1C             call    GETCHR          ; Get next character
2395+ 22C6 C8                   ret     Z               ; End of DIM statement
2396+ 22C7 CD E7 19             call    CHKSYN          ; Make sure ',' follows
2397+ 22CA 2C                   defb    ','
2398+ 22CB 01 C2 22     DIM:    ld      BC,DIMRET       ; Return to "DIMRET"
2399+ 22CE C5                   push    BC              ; Save on stack
2400+ 22CF F6                   defb    $F6             ; Flag "Create" variable
2401+ 22D0 AF           GETVAR: xor     A               ; Find variable address,to DE
2402+ 22D1 32 93 81             ld      (LCRFLG),A      ; Set locate / create flag
2403+ 22D4 46                   ld      B,(HL)          ; Get First byte of name
2404+ 22D5 CD D2 1C     GTFNAM: call    CHKLTR          ; See if a letter
2405+ 22D8 DA ED 16             jp      C,SNERR         ; ?SN Error if not a letter
2406+ 22DB AF                   xor     A
2407+ 22DC 4F                   ld      C,A             ; Clear second byte of name
2408+ 22DD 32 94 81             ld      (TYPE),A        ; Set type to numeric
2409+ 22E0 CD 30 1C             call    GETCHR          ; Get next character
2410+ 22E3 DA EC 22             jp      C,SVNAM2        ; Numeric - Save in name
2411+ 22E6 CD D2 1C             call    CHKLTR          ; See if a letter
2412+ 22E9 DA F9 22             jp      C,CHARTY        ; Not a letter - Check type
2413+ 22EC 4F           SVNAM2: ld      C,A             ; Save second byte of name
2414+ 22ED CD 30 1C     ENDNAM: call    GETCHR          ; Get next character
2415+ 22F0 DA ED 22             jp      C,ENDNAM        ; Numeric - Get another
2416+ 22F3 CD D2 1C             call    CHKLTR          ; See if a letter
2417+ 22F6 D2 ED 22             jp      NC,ENDNAM       ; Letter - Get another
2418+ 22F9 D6 24        CHARTY: sub     '$'             ; String variable?
2419+ 22FB C2 08 23             jp      NZ,NOTSTR       ; No - Numeric variable
2420+ 22FE 3C                   inc     A               ; A = 1 (string type)
2421+ 22FF 32 94 81             ld      (TYPE),A        ; Set type to string
2422+ 2302 0F                   rrca                    ; A = 80H , Flag for string
2423+ 2303 81                   add     A,C             ; 2nd byte of name has bit 7 on
2424+ 2304 4F                   ld      C,A             ; Resave second byte on name
2425+ 2305 CD 30 1C             call    GETCHR          ; Get next character
2426+ 2308 3A B2 81     NOTSTR: ld      A,(FORFLG)      ; Array name needed ?
2427+ 230B 3D                   dec     A
2428+ 230C CA B5 23             jp      Z,ARLDSV        ; Yes - Get array name
2429+ 230F F2 18 23             jp      P,NSCFOR        ; No array with "FOR" or "FN"
2430+ 2312 7E                   ld      A,(HL)          ; Get byte again
2431+ 2313 D6 28                sub     '('             ; Subscripted variable?
2432+ 2315 CA 8D 23             jp      Z,SBSCPT        ; Yes - Sort out subscript
2433+ 2318
2434+ 2318 AF           NSCFOR: xor     A               ; Simple variable
2435+ 2319 32 B2 81             ld      (FORFLG),A      ; Clear "FOR" flag
2436+ 231C E5                   push    HL              ; Save code string address
2437+ 231D 50                   ld      D,B             ; DE = Variable name to find
2438+ 231E 59                   ld      E,C
2439+ 231F 2A 2B 82             ld      HL,(FNRGNM)     ; FN argument name
2440+ 2322 CD E1 19             call    CPDEHL          ; Is it the FN argument?
2441+ 2325 11 2D 82             ld      DE,FNARG        ; Point to argument value
2442+ 2328 CA BE 2D             jp      Z,POPHRT        ; Yes - Return FN argument value
2443+ 232B 2A 25 82             ld      HL,(VAREND)     ; End of variables
2444+ 232E EB                   ex      DE,HL           ; Address of end of search
2445+ 232F 2A 23 82             ld      HL,(PROGND)     ; Start of variables address
2446+ 2332 CD E1 19     FNDVAR: call    CPDEHL          ; End of variable list table?
2447+ 2335 CA 4B 23             jp      Z,CFEVAL        ; Yes - Called from EVAL?
2448+ 2338 79                   ld      A,C             ; Get second byte of name
2449+ 2339 96                   sub     (HL)            ; Compare with name in list
2450+ 233A 23                   inc     HL              ; Move on to first byte
2451+ 233B C2 40 23             jp      NZ,FNTHR        ; Different - Find another
2452+ 233E 78                   ld      A,B             ; Get first byte of name
2453+ 233F 96                   sub     (HL)            ; Compare with name in list
2454+ 2340 23           FNTHR:  inc     HL              ; Move on to LSB of value
2455+ 2341 CA 7F 23             jp      Z,RETADR        ; Found - Return address
2456+ 2344 23                   inc     HL              ; <- Skip
2457+ 2345 23                   inc     HL              ; <- over
2458+ 2346 23                   inc     HL              ; <- F.P.
2459+ 2347 23                   inc     HL              ; <- value
2460+ 2348 C3 32 23             jp      FNDVAR          ; Keep looking
2461+ 234B
2462+ 234B E1           CFEVAL: pop     HL              ; Restore code string address
2463+ 234C E3                   ex      (SP),HL         ; Get return address
2464+ 234D D5                   push    DE              ; Save address of variable
2465+ 234E 11 B4 21             ld      DE,FRMEVL       ; Return address in EVAL
2466+ 2351 CD E1 19             call    CPDEHL          ; Called from EVAL ?
2467+ 2354 D1                   pop     DE              ; Restore address of variable
2468+ 2355 CA 82 23             jp      Z,RETNUL        ; Yes - Return null variable
2469+ 2358 E3                   ex      (SP),HL         ; Put back return
2470+ 2359 E5                   push    HL              ; Save code string address
2471+ 235A C5                   push    BC              ; Save variable name
2472+ 235B 01 06 00             ld      BC,$0006        ; 2 byte name plus 4 byte data
2473+ 235E 2A 27 82             ld      HL,(ARREND)     ; End of arrays
2474+ 2361 E5                   push    HL              ; Save end of arrays
2475+ 2362 09                   add     HL,BC           ; Move up 6 bytes
2476+ 2363 C1                   pop     BC              ; Source address in BC
2477+ 2364 E5                   push    HL              ; Save new end address
2478+ 2365 CD 99 16             call    MOVUP           ; Move arrays up
2479+ 2368 E1                   pop     HL              ; Restore new end address
2480+ 2369 22 27 82             ld      (ARREND),HL     ; Set new end address
2481+ 236C 60                   ld      H,B             ; End of variables to HL
2482+ 236D 69                   ld      L,C
2483+ 236E 22 25 82             ld      (VAREND),HL     ; Set new end address
2484+ 2371
2485+ 2371 2B           ZEROLP: dec     HL              ; Back through to zero variable
2486+ 2372 36 00                ld      (HL),$00        ; Zero byte in variable
2487+ 2374 CD E1 19             call    CPDEHL          ; Done them all?
2488+ 2377 C2 71 23             jp      NZ,ZEROLP       ; No - Keep on going
2489+ 237A D1                   pop     DE              ; Get variable name
2490+ 237B 73                   ld      (HL),E          ; Store second character
2491+ 237C 23                   inc     HL
2492+ 237D 72                   ld      (HL),D          ; Store first character
2493+ 237E 23                   inc     HL
2494+ 237F EB           RETADR: ex      DE,HL           ; Address of variable in DE
2495+ 2380 E1                   pop     HL              ; Restore code string address
2496+ 2381 C9                   ret
2497+ 2382
2498+ 2382 32 34 82     RETNUL: ld      (FPEXP),A       ; Set result to zero
2499+ 2385 21 6A 16             ld      HL,ZERBYT       ; Also set a null string
2500+ 2388 22 31 82             ld      (FPREG),HL      ; Save for EVAL
2501+ 238B E1                   pop     HL              ; Restore code string address
2502+ 238C C9                   ret
2503+ 238D
2504+ 238D E5           SBSCPT: push    HL              ; Save code string address
2505+ 238E 2A 93 81             ld      HL,(LCRFLG)     ; Locate/Create and Type
2506+ 2391 E3                   ex      (SP),HL         ; Save and get code string
2507+ 2392 57                   ld      D,A             ; Zero number of dimensions
2508+ 2393 D5           SCPTLP: push    DE              ; Save number of dimensions
2509+ 2394 C5                   push    BC              ; Save array name
2510+ 2395 CD DA 1C             call    FPSINT          ; Get subscript (0-32767)
2511+ 2398 C1                   pop     BC              ; Restore array name
2512+ 2399 F1                   pop     AF              ; Get number of dimensions
2513+ 239A EB                   ex      DE,HL
2514+ 239B E3                   ex      (SP),HL         ; Save subscript value
2515+ 239C E5                   push    HL              ; Save LCRFLG and TYPE
2516+ 239D EB                   ex      DE,HL
2517+ 239E 3C                   inc     A               ; Count dimensions
2518+ 239F 57                   ld      D,A             ; Save in D
2519+ 23A0 7E                   ld      A,(HL)          ; Get next byte in code string
2520+ 23A1 FE 2C                cp      ','             ; Comma (more to come)?
2521+ 23A3 CA 93 23             jp      Z,SCPTLP        ; Yes - More subscripts
2522+ 23A6 CD E7 19             call    CHKSYN          ; Make sure ")" follows
2523+ 23A9 29                   defb    ')'
2524+ 23AA 22 B7 81             ld      (NXTOPR),HL     ; Save code string address
2525+ 23AD E1                   pop     HL              ; Get LCRFLG and TYPE
2526+ 23AE 22 93 81             ld      (LCRFLG),HL     ; Restore Locate/create & type
2527+ 23B1 1E 00                ld      E,$00           ; Flag not CSAVE* or CLOAD*
2528+ 23B3 D5                   push    DE              ; Save number of dimensions (D)
2529+ 23B4 11                   defb    $11             ; Skip "push HL" and "push AF'
2530+ 23B5
2531+ 23B5 E5           ARLDSV: push    HL              ; Save code string address
2532+ 23B6 F5                   push    AF              ; A = 00 , Flags set = Z,N
2533+ 23B7 2A 25 82             ld      HL,(VAREND)     ; Start of arrays
2534+ 23BA 3E                   defb    $3E             ; Skip "add HL,DE"
2535+ 23BB 19           FNDARY: add     HL,DE           ; Move to next array start
2536+ 23BC EB                   ex      DE,HL
2537+ 23BD 2A 27 82             ld      HL,(ARREND)     ; End of arrays
2538+ 23C0 EB                   ex      DE,HL           ; Current array pointer
2539+ 23C1 CD E1 19             call    CPDEHL          ; End of arrays found?
2540+ 23C4 CA ED 23             jp      Z,CREARY        ; Yes - Create array
2541+ 23C7 7E                   ld      A,(HL)          ; Get second byte of name
2542+ 23C8 B9                   cp      C               ; Compare with name given
2543+ 23C9 23                   inc     HL              ; Move on
2544+ 23CA C2 CF 23             jp      NZ,NXTARY       ; Different - Find next array
2545+ 23CD 7E                   ld      A,(HL)          ; Get first byte of name
2546+ 23CE B8                   cp      B               ; Compare with name given
2547+ 23CF 23           NXTARY: inc     HL              ; Move on
2548+ 23D0 5E                   ld      E,(HL)          ; Get LSB of next array address
2549+ 23D1 23                   inc     HL
2550+ 23D2 56                   ld      D,(HL)          ; Get MSB of next array address
2551+ 23D3 23                   inc     HL
2552+ 23D4 C2 BB 23             jp      NZ,FNDARY       ; Not found - Keep looking
2553+ 23D7 3A 93 81             ld      A,(LCRFLG)      ; Found Locate or Create it?
2554+ 23DA B7                   or      A
2555+ 23DB C2 F6 16             jp      NZ,DDERR        ; Create - ?DD Error
2556+ 23DE F1                   pop     AF              ; Locate - Get number of dim'ns
2557+ 23DF 44                   ld      B,H             ; BC Points to array dim'ns
2558+ 23E0 4D                   ld      C,L
2559+ 23E1 CA BE 2D             jp      Z,POPHRT        ; Jump if array load/save
2560+ 23E4 96                   sub     (HL)            ; Same number of dimensions?
2561+ 23E5 CA 4B 24             jp      Z,FINDEL        ; Yes - Find element
2562+ 23E8 1E 10        BSERR:  ld      E,BS            ; ?BS Error
2563+ 23EA C3 01 17             jp      ERROR           ; Output error
2564+ 23ED
2565+ 23ED 11 04 00     CREARY: ld      DE,$0004        ; 4 Bytes per entry
2566+ 23F0 F1                   pop     AF              ; Array to save or 0 dim'ns?
2567+ 23F1 CA FB 1C             jp      Z,FCERR         ; Yes - ?FC Error
2568+ 23F4 71                   ld      (HL),C          ; Save second byte of name
2569+ 23F5 23                   inc     HL
2570+ 23F6 70                   ld      (HL),B          ; Save first byte of name
2571+ 23F7 23                   inc     HL
2572+ 23F8 4F                   ld      C,A             ; Number of dimensions to C
2573+ 23F9 CD AA 16             call    CHKSTK          ; Check if enough memory
2574+ 23FC 23                   inc     HL              ; Point to number of dimensions
2575+ 23FD 23                   inc     HL
2576+ 23FE 22 AC 81             ld      (CUROPR),HL     ; Save address of pointer
2577+ 2401 71                   ld      (HL),C          ; Set number of dimensions
2578+ 2402 23                   inc     HL
2579+ 2403 3A 93 81             ld      A,(LCRFLG)      ; Locate of Create?
2580+ 2406 17                   rla                     ; Carry set = Create
2581+ 2407 79                   ld      A,C             ; Get number of dimensions
2582+ 2408 01 0B 00     CRARLP: ld      BC,10+1         ; Default dimension size 10
2583+ 240B D2 10 24             jp      NC,DEFSIZ       ; Locate - Set default size
2584+ 240E C1                   pop     BC              ; Get specified dimension size
2585+ 240F 03                   inc     BC              ; Include zero element
2586+ 2410 71           DEFSIZ: ld      (HL),C          ; Save LSB of dimension size
2587+ 2411 23                   inc     HL
2588+ 2412 70                   ld      (HL),B          ; Save MSB of dimension size
2589+ 2413 23                   inc     HL
2590+ 2414 F5                   push    AF              ; Save num' of dim'ns an status
2591+ 2415 E5                   push    HL              ; Save address of dim'n size
2592+ 2416 CD BA 2F             call    MLDEBC          ; Multiply DE by BC to find
2593+ 2419 EB                   ex      DE,HL           ; amount of mem needed (to DE)
2594+ 241A E1                   pop     HL              ; Restore address of dimension
2595+ 241B F1                   pop     AF              ; Restore number of dimensions
2596+ 241C 3D                   dec     A               ; Count them
2597+ 241D C2 08 24             jp      NZ,CRARLP       ; Do next dimension if more
2598+ 2420 F5                   push    AF              ; Save locate/create flag
2599+ 2421 42                   ld      B,D             ; MSB of memory needed
2600+ 2422 4B                   ld      C,E             ; LSB of memory needed
2601+ 2423 EB                   ex      DE,HL
2602+ 2424 19                   add     HL,DE           ; Add bytes to array start
2603+ 2425 DA C2 16             jp      C,OMERR         ; Too big - Error
2604+ 2428 CD B3 16             call    ENFMEM          ; See if enough memory
2605+ 242B 22 27 82             ld      (ARREND),HL     ; Save new end of array
2606+ 242E
2607+ 242E 2B           ZERARY: dec     HL              ; Back through array data
2608+ 242F 36 00                ld      (HL),$00        ; Set array element to zero
2609+ 2431 CD E1 19             call    CPDEHL          ; All elements zeroed?
2610+ 2434 C2 2E 24             jp      NZ,ZERARY       ; No - Keep on going
2611+ 2437 03                   inc     BC              ; Number of bytes + 1
2612+ 2438 57                   ld      D,A             ; A=0
2613+ 2439 2A AC 81             ld      HL,(CUROPR)     ; Get address of array
2614+ 243C 5E                   ld      E,(HL)          ; Number of dimensions
2615+ 243D EB                   ex      DE,HL           ; To HL
2616+ 243E 29                   add     HL,HL           ; Two bytes per dimension size
2617+ 243F 09                   add     HL,BC           ; Add number of bytes
2618+ 2440 EB                   ex      DE,HL           ; Bytes needed to DE
2619+ 2441 2B                   dec     HL
2620+ 2442 2B                   dec     HL
2621+ 2443 73                   ld      (HL),E          ; Save LSB of bytes needed
2622+ 2444 23                   inc     HL
2623+ 2445 72                   ld      (HL),D          ; Save MSB of bytes needed
2624+ 2446 23                   inc     HL
2625+ 2447 F1                   pop     AF              ; Locate / Create?
2626+ 2448 DA 6F 24             jp      C,ENDDIM        ; A is 0 , End if create
2627+ 244B 47           FINDEL: ld      B,A             ; Find array element
2628+ 244C 4F                   ld      C,A
2629+ 244D 7E                   ld      A,(HL)          ; Number of dimensions
2630+ 244E 23                   inc     HL
2631+ 244F 16                   defb    $16             ; Skip "pop HL"
2632+ 2450 E1           FNDELP: pop     HL              ; Address of next dim' size
2633+ 2451 5E                   ld      E,(HL)          ; Get LSB of dim'n size
2634+ 2452 23                   inc     HL
2635+ 2453 56                   ld      D,(HL)          ; Get MSB of dim'n size
2636+ 2454 23                   inc     HL
2637+ 2455 E3                   ex      (SP),HL         ; Save address - Get index
2638+ 2456 F5                   push    AF              ; Save number of dim'ns
2639+ 2457 CD E1 19             call    CPDEHL          ; Dimension too large?
2640+ 245A D2 E8 23             jp      NC,BSERR        ; Yes - ?BS Error
2641+ 245D E5                   push    HL              ; Save index
2642+ 245E CD BA 2F             call    MLDEBC          ; Multiply previous by size
2643+ 2461 D1                   pop     DE              ; Index supplied to DE
2644+ 2462 19                   add     HL,DE           ; Add index to pointer
2645+ 2463 F1                   pop     AF              ; Number of dimensions
2646+ 2464 3D                   dec     A               ; Count them
2647+ 2465 44                   ld      B,H             ; MSB of pointer
2648+ 2466 4D                   ld      C,L             ; LSB of pointer
2649+ 2467 C2 50 24             jp      NZ,FNDELP       ; More - Keep going
2650+ 246A 29                   add     HL,HL           ; 4 Bytes per element
2651+ 246B 29                   add     HL,HL
2652+ 246C C1                   pop     BC              ; Start of array
2653+ 246D 09                   add     HL,BC           ; Point to element
2654+ 246E EB                   ex      DE,HL           ; Address of element to DE
2655+ 246F 2A B7 81     ENDDIM: ld      HL,(NXTOPR)     ; Got code string address
2656+ 2472 C9                   ret
2657+ 2473
2658+ 2473
2659+ 2473              ; returns the value of the 32-bit system tick counter as
2660+ 2473              ; two 16-bit words
2661+ 2473 CD C4 20     TMR:    call    TSTNUM          ; Make sure it's a number
2662+ 2476 CD E6 1C             call    DEINT           ; Get integer (-32768 to 32767)
2663+ 2479 2A BD 81             ld      HL,(TMRCNT)     ; load the LSBytes of timer
2664+ 247C 7B                   ld      A,E
2665+ 247D B2                   or      D               ; is it 0?
2666+ 247E CA 84 24             jp      Z,ENDTMR        ; yes, jump over
2667+ 2481 2A BF 81             ld      HL,(TMRCNT+2)   ; load the MSBytes of timer
2668+ 2484 45           ENDTMR: ld      B,L             ; move bytes...
2669+ 2485 7C                   ld      A,H             ; ...into AB
2670+ 2486 C3 AB 24             jp      ABPASS          ; return word into AB
2671+ 2489
2672+ 2489
2673+ 2489              ; returns the free space for BASIC or into the string pool
2674+ 2489 2A 27 82     FRE:    ld      HL,(ARREND)     ; Start of free memory
2675+ 248C EB                   ex      DE,HL           ; To DE
2676+ 248D 21 00 00             ld      HL,$0000        ; End of free memory
2677+ 2490 39                   add     HL,SP           ; Current stack value
2678+ 2491 3A 94 81             ld      A,(TYPE)        ; Dummy argument type
2679+ 2494 B7                   or      A
2680+ 2495 CA A5 24             jp      Z,FRENUM        ; Numeric - Free variable space
2681+ 2498 CD 0C 27             call    GSTRCU          ; Current string to pool
2682+ 249B CD 0C 26             call    GARBGE          ; Garbage collection
2683+ 249E 2A AD 80             ld      HL,(STRSPC)     ; Bottom of string space in use
2684+ 24A1 EB                   ex      DE,HL           ; To DE
2685+ 24A2 2A AA 81             ld      HL,(STRBOT)     ; Bottom of string space
2686+ 24A5 7D           FRENUM: ld      A,L             ; Get LSB of end
2687+ 24A6 93                   sub     E               ; Subtract LSB of beginning
2688+ 24A7 4F                   ld      C,A             ; Save difference if C
2689+ 24A8 7C                   ld      A,H             ; Get MSB of end
2690+ 24A9 9A                   sbc     A,D             ; Subtract MSB of beginning
2691+ 24AA 41           ACPASS: ld      B,C             ; Return integer AC
2692+ 24AB 50           ABPASS: ld      D,B             ; Return integer AB
2693+ 24AC 1E 00                ld      E,$00
2694+ 24AE 21 94 81             ld      HL,TYPE         ; Point to type
2695+ 24B1 73                   ld      (HL),E          ; Set type to numeric
2696+ 24B2 06 90                ld      B,$80+$10       ; 16 bit integer
2697+ 24B4 C3 E5 2E             jp      RETINT          ; Return the integer
2698+ 24B7
2699+ 24B7              ; returns the X position of the cursor during a print
2700+ 24B7 3A 92 81     POS:    ld      A,(CURPOS)      ; Get cursor position
2701+ 24BA 47           PASSA:  ld      B,A             ; Put A into AB
2702+ 24BB AF                   xor     A               ; Zero A
2703+ 24BC C3 AB 24             jp      ABPASS          ; Return integer AB
2704+ 24BF
2705+ 24BF CD 42 25     DEF:    call    CHEKFN          ; Get "FN" and name
2706+ 24C2 CD 34 25             call    IDTEST          ; Test for illegal direct
2707+ 24C5 01 D9 1D             ld      BC,DATA         ; To get next statement
2708+ 24C8 C5                   push    BC              ; Save address for RETurn
2709+ 24C9 D5                   push    DE              ; Save address of function ptr
2710+ 24CA CD E7 19             call    CHKSYN          ; Make sure "(" follows
2711+ 24CD 28                   defb    '('
2712+ 24CE CD D0 22             call    GETVAR          ; Get argument variable name
2713+ 24D1 E5                   push    HL              ; Save code string address
2714+ 24D2 EB                   ex      DE,HL           ; Argument address to HL
2715+ 24D3 2B                   dec     HL
2716+ 24D4 56                   ld      D,(HL)          ; Get first byte of arg name
2717+ 24D5 2B                   dec     HL
2718+ 24D6 5E                   ld      E,(HL)          ; Get second byte of arg name
2719+ 24D7 E1                   pop     HL              ; Restore code string address
2720+ 24D8 CD C4 20             call    TSTNUM          ; Make sure numeric argument
2721+ 24DB CD E7 19             call    CHKSYN          ; Make sure ")" follows
2722+ 24DE 29                   defb    ')'
2723+ 24DF CD E7 19             call    CHKSYN          ; Make sure "=" follows
2724+ 24E2 C8                   defb    ZEQUAL          ; "=" token
2725+ 24E3 44                   ld      B,H             ; Code string address to BC
2726+ 24E4 4D                   ld      C,L
2727+ 24E5 E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2728+ 24E6 71                   ld      (HL),C          ; Save LSB of FN code string
2729+ 24E7 23                   inc     HL
2730+ 24E8 70                   ld      (HL),B          ; Save MSB of FN code string
2731+ 24E9 C3 81 25             jp      SVSTAD          ; Save address and do function
2732+ 24EC
2733+ 24EC CD 42 25     DOFN:   call    CHEKFN          ; Make sure FN follows
2734+ 24EF D5                   push    DE              ; Save function pointer address
2735+ 24F0 CD 98 21             call    EVLPAR          ; Evaluate expression in "()"
2736+ 24F3 CD C4 20             call    TSTNUM          ; Make sure numeric result
2737+ 24F6 E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2738+ 24F7 5E                   ld      E,(HL)          ; Get LSB of FN code string
2739+ 24F8 23                   inc     HL
2740+ 24F9 56                   ld      D,(HL)          ; Get MSB of FN code string
2741+ 24FA 23                   inc     HL
2742+ 24FB 7A                   ld      A,D             ; And function DEFined?
2743+ 24FC B3                   or      E
2744+ 24FD CA F9 16             jp      Z,UFERR         ; No - ?UF Error
2745+ 2500 7E                   ld      A,(HL)          ; Get LSB of argument address
2746+ 2501 23                   inc     HL
2747+ 2502 66                   ld      H,(HL)          ; Get MSB of argument address
2748+ 2503 6F                   ld      L,A             ; HL = Arg variable address
2749+ 2504 E5                   push    HL              ; Save it
2750+ 2505 2A 2B 82             ld      HL,(FNRGNM)     ; Get old argument name
2751+ 2508 E3                   ex      (SP),HL         ; Save old , Get new
2752+ 2509 22 2B 82             ld      (FNRGNM),HL     ; Set new argument name
2753+ 250C 2A 2F 82             ld      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2754+ 250F E5                   push    HL              ; Save it
2755+ 2510 2A 2D 82             ld      HL,(FNARG)      ; Get MSB,EXP of old arg value
2756+ 2513 E5                   push    HL              ; Save it
2757+ 2514 21 2D 82             ld      HL,FNARG        ; HL = Value of argument
2758+ 2517 D5                   push    DE              ; Save FN code string address
2759+ 2518 CD 26 2F             call    FPTHL           ; Move FPREG to argument
2760+ 251B E1                   pop     HL              ; Get FN code string address
2761+ 251C CD C1 20             call    GETNUM          ; Get value from function
2762+ 251F 2B                   dec     HL              ; dec 'cos GETCHR INCs
2763+ 2520 CD 30 1C             call    GETCHR          ; Get next character
2764+ 2523 C2 ED 16             jp      NZ,SNERR        ; Bad character in FN - Error
2765+ 2526 E1                   pop     HL              ; Get MSB,EXP of old arg
2766+ 2527 22 2D 82             ld      (FNARG),HL      ; Restore it
2767+ 252A E1                   pop     HL              ; Get LSB,NLSB of old arg
2768+ 252B 22 2F 82             ld      (FNARG+2),HL    ; Restore it
2769+ 252E E1                   pop     HL              ; Get name of old arg
2770+ 252F 22 2B 82             ld      (FNRGNM),HL     ; Restore it
2771+ 2532 E1                   pop     HL              ; Restore code string address
2772+ 2533 C9                   ret
2773+ 2534
2774+ 2534 E5           IDTEST: push    HL              ; Save code string address
2775+ 2535 2A AF 80             ld      HL,(LINEAT)     ; Get current line number
2776+ 2538 23                   inc     HL              ; -1 means direct statement
2777+ 2539 7C                   ld      A,H
2778+ 253A B5                   or      L
2779+ 253B E1                   pop     HL              ; Restore code string address
2780+ 253C C0                   ret     NZ              ; Return if in program
2781+ 253D 1E 16                ld      E,ID            ; ?ID Error
2782+ 253F C3 01 17             jp      ERROR
2783+ 2542
2784+ 2542 CD E7 19     CHEKFN: call    CHKSYN          ; Make sure FN follows
2785+ 2545 B8                   defb    ZFN             ; "FN" token
2786+ 2546 3E 80                ld      A,$80
2787+ 2548 32 B2 81             ld      (FORFLG),A      ; Flag FN name to find
2788+ 254B B6                   or      (HL)            ; FN name has bit 7 set
2789+ 254C 47                   ld      B,A             ; in first byte of name
2790+ 254D CD D5 22             call    GTFNAM          ; Get FN name
2791+ 2550 C3 C4 20             jp      TSTNUM          ; Make sure numeric function
2792+ 2553
2793+ 2553 CD C4 20     STR:    call    TSTNUM          ; Make sure it's a number
2794+ 2556 CD 73 30             call    NUMASC          ; Turn number into text
2795+ 2559 CD 87 25     STR1:   call    CRTST           ; Create string entry for it
2796+ 255C CD 0C 27             call    GSTRCU          ; Current string to pool
2797+ 255F 01 67 27             ld      BC,TOPOOL       ; Save in string pool
2798+ 2562 C5                   push    BC              ; Save address on stack
2799+ 2563
2800+ 2563 7E           SAVSTR: ld      A,(HL)          ; Get string length
2801+ 2564 23                   inc     HL
2802+ 2565 23                   inc     HL
2803+ 2566 E5                   push    HL              ; Save pointer to string
2804+ 2567 CD E2 25             call    TESTR           ; See if enough string space
2805+ 256A E1                   pop     HL              ; Restore pointer to string
2806+ 256B 4E                   ld      C,(HL)          ; Get LSB of address
2807+ 256C 23                   inc     HL
2808+ 256D 46                   ld      B,(HL)          ; Get MSB of address
2809+ 256E CD 7B 25             call    CRTMST          ; Create string entry
2810+ 2571 E5                   push    HL              ; Save pointer to MSB of addr
2811+ 2572 6F                   ld      L,A             ; Length of string
2812+ 2573 CD FF 26             call    TOSTRA          ; Move to string area
2813+ 2576 D1                   pop     DE              ; Restore pointer to MSB
2814+ 2577 C9                   ret
2815+ 2578
2816+ 2578 CD E2 25     MKTMST: call    TESTR           ; See if enough string space
2817+ 257B 21 A6 81     CRTMST: ld      HL,TMPSTR       ; Temporary string
2818+ 257E E5                   push    HL              ; Save it
2819+ 257F 77                   ld      (HL),A          ; Save length of string
2820+ 2580 23                   inc     HL
2821+ 2581 23           SVSTAD: inc     HL
2822+ 2582 73                   ld      (HL),E          ; Save LSB of address
2823+ 2583 23                   inc     HL
2824+ 2584 72                   ld      (HL),D          ; Save MSB of address
2825+ 2585 E1                   pop     HL              ; Restore pointer
2826+ 2586 C9                   ret
2827+ 2587
2828+ 2587 2B           CRTST:  dec     HL              ; dec - INCed after
2829+ 2588 06 22        QTSTR:  ld      B,$22           ; '"'           ; Terminating quote
2830+ 258A 50                   ld      D,B             ; Quote to D
2831+ 258B E5           DTSTR:  push    HL              ; Save start
2832+ 258C 0E FF                ld      C,-1            ; Set counter to -1
2833+ 258E 23           QTSTLP: inc     HL              ; Move on
2834+ 258F 7E                   ld      A,(HL)          ; Get byte
2835+ 2590 0C                   inc     C               ; Count bytes
2836+ 2591 B7                   or      A               ; End of line?
2837+ 2592 CA 9D 25             jp      Z,CRTSTE        ; Yes - Create string entry
2838+ 2595 BA                   cp      D               ; Terminator D found?
2839+ 2596 CA 9D 25             jp      Z,CRTSTE        ; Yes - Create string entry
2840+ 2599 B8                   cp      B               ; Terminator B found?
2841+ 259A C2 8E 25             jp      NZ,QTSTLP       ; No - Keep looking
2842+ 259D FE 22        CRTSTE: cp      $22             ; '"'             ; End with '"'?
2843+ 259F CC 30 1C             call    Z,GETCHR        ; Yes - Get next character
2844+ 25A2 E3                   ex      (SP),HL         ; Starting quote
2845+ 25A3 23                   inc     HL              ; First byte of string
2846+ 25A4 EB                   ex      DE,HL           ; To DE
2847+ 25A5 79                   ld      A,C             ; Get length
2848+ 25A6 CD 7B 25             call    CRTMST          ; Create string entry
2849+ 25A9 11 A6 81     TSTOPL: ld      DE,TMPSTR       ; Temporary string
2850+ 25AC 2A 98 81             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2851+ 25AF 22 31 82             ld      (FPREG),HL      ; Save address of string ptr
2852+ 25B2 3E 01                ld      A,$01
2853+ 25B4 32 94 81             ld      (TYPE),A        ; Set type to string
2854+ 25B7 CD 29 2F             call    DETHL4          ; Move string to pool
2855+ 25BA CD E1 19             call    CPDEHL          ; Out of string pool?
2856+ 25BD 22 98 81             ld      (TMSTPT),HL     ; Save new pointer
2857+ 25C0 E1                   pop     HL              ; Restore code string address
2858+ 25C1 7E                   ld      A,(HL)          ; Get next code byte
2859+ 25C2 C0                   ret     NZ              ; Return if pool OK
2860+ 25C3 1E 1E                ld      E,ST            ; ?ST Error
2861+ 25C5 C3 01 17             jp      ERROR           ; String pool overflow
2862+ 25C8
2863+ 25C8 23           PRNUMS: inc     HL              ; Skip leading space
2864+ 25C9 CD 87 25     PRS:    call    CRTST           ; Create string entry for it
2865+ 25CC CD 0C 27     PRS1:   call    GSTRCU          ; Current string to pool
2866+ 25CF CD 1D 2F             call    LOADFP          ; Move string block to BCDE
2867+ 25D2 1C                   inc     E               ; Length + 1
2868+ 25D3 1D           PRSLP:  dec     E               ; Count characters
2869+ 25D4 C8                   ret     Z               ; End of string
2870+ 25D5 0A                   ld      A,(BC)          ; Get byte to output
2871+ 25D6 CD F2 19             call    OUTC            ; Output character in A
2872+ 25D9 FE 0D                cp      CR              ; Return?
2873+ 25DB CC 07 1F             call    Z,CNTEND        ; Yes - Position cursor to 0
2874+ 25DE 03                   inc     BC              ; Next byte in string
2875+ 25DF C3 D3 25             jp      PRSLP           ; More characters to output
2876+ 25E2
2877+ 25E2 B7           TESTR:  or      A               ; Test if enough room
2878+ 25E3 0E                   defb    $0E             ; No garbage collection done
2879+ 25E4 F1           GRBDON: pop     AF              ; Garbage collection done
2880+ 25E5 F5                   push    AF              ; Save status
2881+ 25E6 2A AD 80             ld      HL,(STRSPC)     ; Bottom of string space in use
2882+ 25E9 EB                   ex      DE,HL           ; To DE
2883+ 25EA 2A AA 81             ld      HL,(STRBOT)     ; Bottom of string area
2884+ 25ED 2F                   cpl                     ; Negate length (Top down)
2885+ 25EE 4F                   ld      C,A             ; -Length to BC
2886+ 25EF 06 FF                ld      B,-1            ; BC = -ve length of string
2887+ 25F1 09                   add     HL,BC           ; Add to bottom of space in use
2888+ 25F2 23                   inc     HL              ; Plus one for 2's complement
2889+ 25F3 CD E1 19             call    CPDEHL          ; Below string RAM area?
2890+ 25F6 DA 00 26             jp      C,TESTOS        ; Tidy up if not done else err
2891+ 25F9 22 AA 81             ld      (STRBOT),HL     ; Save new bottom of area
2892+ 25FC 23                   inc     HL              ; Point to first byte of string
2893+ 25FD EB                   ex      DE,HL           ; Address to DE
2894+ 25FE F1           POPAF:  pop     AF              ; Throw away status push
2895+ 25FF C9                   ret
2896+ 2600
2897+ 2600 F1           TESTOS: pop     AF              ; Garbage collect been done?
2898+ 2601 1E 1A                ld      E,OS            ; ?OS Error
2899+ 2603 CA 01 17             jp      Z,ERROR         ; Yes - Not enough string space
2900+ 2606 BF                   cp      A               ; Flag garbage collect done
2901+ 2607 F5                   push    AF              ; Save status
2902+ 2608 01 E4 25             ld      BC,GRBDON       ; Garbage collection done
2903+ 260B C5                   push    BC              ; Save for RETurn
2904+ 260C 2A 96 81     GARBGE: ld      HL,(LSTRAM)     ; Get end of RAM pointer
2905+ 260F 22 AA 81     GARBLP: ld      (STRBOT),HL     ; Reset string pointer
2906+ 2612 21 00 00             ld      HL,$0000
2907+ 2615 E5                   push    HL              ; Flag no string found
2908+ 2616 2A AD 80             ld      HL,(STRSPC)     ; Get bottom of string space
2909+ 2619 E5                   push    HL              ; Save bottom of string space
2910+ 261A 21 9A 81             ld      HL,TMSTPL       ; Temporary string pool
2911+ 261D EB           GRBLP:  ex      DE,HL
2912+ 261E 2A 98 81             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2913+ 2621 EB                   ex      DE,HL
2914+ 2622 CD E1 19             call    CPDEHL          ; Temporary string pool done?
2915+ 2625 01 1D 26             ld      BC,GRBLP        ; Loop until string pool done
2916+ 2628 C2 71 26             jp      NZ,STPOOL       ; No - See if in string area
2917+ 262B 2A 23 82             ld      HL,(PROGND)     ; Start of simple variables
2918+ 262E EB           SMPVAR: ex      DE,HL
2919+ 262F 2A 25 82             ld      HL,(VAREND)     ; End of simple variables
2920+ 2632 EB                   ex      DE,HL
2921+ 2633 CD E1 19             call    CPDEHL          ; All simple strings done?
2922+ 2636 CA 44 26             jp      Z,ARRLP         ; Yes - Do string arrays
2923+ 2639 7E                   ld      A,(HL)          ; Get type of variable
2924+ 263A 23                   inc     HL
2925+ 263B 23                   inc     HL
2926+ 263C B7                   or      A               ; "S" flag set if string
2927+ 263D CD 74 26             call    STRADD          ; See if string in string area
2928+ 2640 C3 2E 26             jp      SMPVAR          ; Loop until simple ones done
2929+ 2643
2930+ 2643 C1           GNXARY: pop     BC              ; Scrap address of this array
2931+ 2644 EB           ARRLP:  ex      DE,HL
2932+ 2645 2A 27 82             ld      HL,(ARREND)     ; End of string arrays
2933+ 2648 EB                   ex      DE,HL
2934+ 2649 CD E1 19             call    CPDEHL          ; All string arrays done?
2935+ 264C CA 9A 26             jp      Z,SCNEND        ; Yes - Move string if found
2936+ 264F CD 1D 2F             call    LOADFP          ; Get array name to BCDE
2937+ 2652 7B                   ld      A,E             ; Get type of array
2938+ 2653 E5                   push    HL              ; Save address of num of dim'ns
2939+ 2654 09                   add     HL,BC           ; Start of next array
2940+ 2655 B7                   or      A               ; Test type of array
2941+ 2656 F2 43 26             jp      P,GNXARY        ; Numeric array - Ignore it
2942+ 2659 22 AC 81             ld      (CUROPR),HL     ; Save address of next array
2943+ 265C E1                   pop     HL              ; Get address of num of dim'ns
2944+ 265D 4E                   ld      C,(HL)          ; BC = Number of dimensions
2945+ 265E 06 00                ld      B,$00
2946+ 2660 09                   add     HL,BC           ; Two bytes per dimension size
2947+ 2661 09                   add     HL,BC
2948+ 2662 23                   inc     HL              ; Plus one for number of dim'ns
2949+ 2663 EB           GRBARY: ex      DE,HL
2950+ 2664 2A AC 81             ld      HL,(CUROPR)     ; Get address of next array
2951+ 2667 EB                   ex      DE,HL
2952+ 2668 CD E1 19             call    CPDEHL          ; Is this array finished?
2953+ 266B CA 44 26             jp      Z,ARRLP         ; Yes - Get next one
2954+ 266E 01 63 26             ld      BC,GRBARY       ; Loop until array all done
2955+ 2671 C5           STPOOL: push    BC              ; Save return address
2956+ 2672 F6 80                or      $80             ; Flag string type
2957+ 2674 7E           STRADD: ld      A,(HL)          ; Get string length
2958+ 2675 23                   inc     HL
2959+ 2676 23                   inc     HL
2960+ 2677 5E                   ld      E,(HL)          ; Get LSB of string address
2961+ 2678 23                   inc     HL
2962+ 2679 56                   ld      D,(HL)          ; Get MSB of string address
2963+ 267A 23                   inc     HL
2964+ 267B F0                   ret     P               ; Not a string - Return
2965+ 267C B7                   or      A               ; Set flags on string length
2966+ 267D C8                   ret     Z               ; Null string - Return
2967+ 267E 44                   ld      B,H             ; Save variable pointer
2968+ 267F 4D                   ld      C,L
2969+ 2680 2A AA 81             ld      HL,(STRBOT)     ; Bottom of new area
2970+ 2683 CD E1 19             call    CPDEHL          ; String been done?
2971+ 2686 60                   ld      H,B             ; Restore variable pointer
2972+ 2687 69                   ld      L,C
2973+ 2688 D8                   ret     C               ; String done - Ignore
2974+ 2689 E1                   pop     HL              ; Return address
2975+ 268A E3                   ex      (SP),HL         ; Lowest available string area
2976+ 268B CD E1 19             call    CPDEHL          ; String within string area?
2977+ 268E E3                   ex      (SP),HL         ; Lowest available string area
2978+ 268F E5                   push    HL              ; Re-save return address
2979+ 2690 60                   ld      H,B             ; Restore variable pointer
2980+ 2691 69                   ld      L,C
2981+ 2692 D0                   ret     NC              ; Outside string area - Ignore
2982+ 2693 C1                   pop     BC              ; Get return , Throw 2 away
2983+ 2694 F1                   pop     AF              ;
2984+ 2695 F1                   pop     AF              ;
2985+ 2696 E5                   push    HL              ; Save variable pointer
2986+ 2697 D5                   push    DE              ; Save address of current
2987+ 2698 C5                   push    BC              ; Put back return address
2988+ 2699 C9                   ret                     ; Go to it
2989+ 269A
2990+ 269A D1           SCNEND: pop     DE              ; Addresses of strings
2991+ 269B E1                   pop     HL              ;
2992+ 269C 7D                   ld      A,L             ; HL = 0 if no more to do
2993+ 269D B4                   or      H
2994+ 269E C8                   ret     Z               ; No more to do - Return
2995+ 269F 2B                   dec     HL
2996+ 26A0 46                   ld      B,(HL)          ; MSB of address of string
2997+ 26A1 2B                   dec     HL
2998+ 26A2 4E                   ld      C,(HL)          ; LSB of address of string
2999+ 26A3 E5                   push    HL              ; Save variable address
3000+ 26A4 2B                   dec     HL
3001+ 26A5 2B                   dec     HL
3002+ 26A6 6E                   ld      L,(HL)          ; HL = Length of string
3003+ 26A7 26 00                ld      H,$00
3004+ 26A9 09                   add     HL,BC           ; Address of end of string+1
3005+ 26AA 50                   ld      D,B             ; String address to DE
3006+ 26AB 59                   ld      E,C
3007+ 26AC 2B                   dec     HL              ; Last byte in string
3008+ 26AD 44                   ld      B,H             ; Address to BC
3009+ 26AE 4D                   ld      C,L
3010+ 26AF 2A AA 81             ld      HL,(STRBOT)     ; Current bottom of string area
3011+ 26B2 CD 9C 16             call    MOVSTR          ; Move string to new address
3012+ 26B5 E1                   pop     HL              ; Restore variable address
3013+ 26B6 71                   ld      (HL),C          ; Save new LSB of address
3014+ 26B7 23                   inc     HL
3015+ 26B8 70                   ld      (HL),B          ; Save new MSB of address
3016+ 26B9 69                   ld      L,C             ; Next string area+1 to HL
3017+ 26BA 60                   ld      H,B
3018+ 26BB 2B                   dec     HL              ; Next string area address
3019+ 26BC C3 0F 26             jp      GARBLP          ; Look for more strings
3020+ 26BF
3021+ 26BF C5           CONCAT: push    BC              ; Save prec' opr & code string
3022+ 26C0 E5                   push    HL              ;
3023+ 26C1 2A 31 82             ld      HL,(FPREG)      ; Get first string
3024+ 26C4 E3                   ex      (SP),HL         ; Save first string
3025+ 26C5 CD 4A 21             call    OPRND           ; Get second string
3026+ 26C8 E3                   ex      (SP),HL         ; Restore first string
3027+ 26C9 CD C5 20             call    TSTSTR          ; Make sure it's a string
3028+ 26CC 7E                   ld      A,(HL)          ; Get length of second string
3029+ 26CD E5                   push    HL              ; Save first string
3030+ 26CE 2A 31 82             ld      HL,(FPREG)      ; Get second string
3031+ 26D1 E5                   push    HL              ; Save second string
3032+ 26D2 86                   add     A,(HL)          ; Add length of second string
3033+ 26D3 1E 1C                ld      E,LS            ; ?LS Error
3034+ 26D5 DA 01 17             jp      C,ERROR         ; String too long - Error
3035+ 26D8 CD 78 25             call    MKTMST          ; Make temporary string
3036+ 26DB D1                   pop     DE              ; Get second string to DE
3037+ 26DC CD 10 27             call    GSTRDE          ; Move to string pool if needed
3038+ 26DF E3                   ex      (SP),HL         ; Get first string
3039+ 26E0 CD 0F 27             call    GSTRHL          ; Move to string pool if needed
3040+ 26E3 E5                   push    HL              ; Save first string
3041+ 26E4 2A A8 81             ld      HL,(TMPSTR+2)   ; Temporary string address
3042+ 26E7 EB                   ex      DE,HL           ; To DE
3043+ 26E8 CD F6 26             call    SSTSA           ; First string to string area
3044+ 26EB CD F6 26             call    SSTSA           ; Second string to string area
3045+ 26EE 21 DF 20             ld      HL,EVAL2        ; Return to evaluation loop
3046+ 26F1 E3                   ex      (SP),HL         ; Save return,get code string
3047+ 26F2 E5                   push    HL              ; Save code string address
3048+ 26F3 C3 A9 25             jp      TSTOPL          ; To temporary string to pool
3049+ 26F6
3050+ 26F6 E1           SSTSA:  pop     HL              ; Return address
3051+ 26F7 E3                   ex      (SP),HL         ; Get string block,save return
3052+ 26F8 7E                   ld      A,(HL)          ; Get length of string
3053+ 26F9 23                   inc     HL
3054+ 26FA 23                   inc     HL
3055+ 26FB 4E                   ld      C,(HL)          ; Get LSB of string address
3056+ 26FC 23                   inc     HL
3057+ 26FD 46                   ld      B,(HL)          ; Get MSB of string address
3058+ 26FE 6F                   ld      L,A             ; Length to L
3059+ 26FF 2C           TOSTRA: inc     L               ; inc - DECed after
3060+ 2700 2D           TSALP:  dec     L               ; Count bytes moved
3061+ 2701 C8                   ret     Z               ; End of string - Return
3062+ 2702 0A                   ld      A,(BC)          ; Get source
3063+ 2703 12                   ld      (DE),A          ; Save destination
3064+ 2704 03                   inc     BC              ; Next source
3065+ 2705 13                   inc     DE              ; Next destination
3066+ 2706 C3 00 27             jp      TSALP           ; Loop until string moved
3067+ 2709
3068+ 2709 CD C5 20     GETSTR: call    TSTSTR          ; Make sure it's a string
3069+ 270C 2A 31 82     GSTRCU: ld      HL,(FPREG)      ; Get current string
3070+ 270F EB           GSTRHL: ex      DE,HL           ; Save DE
3071+ 2710 CD 2A 27     GSTRDE: call    BAKTMP          ; Was it last tmp-str?
3072+ 2713 EB                   ex      DE,HL           ; Restore DE
3073+ 2714 C0                   ret     NZ              ; No - Return
3074+ 2715 D5                   push    DE              ; Save string
3075+ 2716 50                   ld      D,B             ; String block address to DE
3076+ 2717 59                   ld      E,C
3077+ 2718 1B                   dec     DE              ; Point to length
3078+ 2719 4E                   ld      C,(HL)          ; Get string length
3079+ 271A 2A AA 81             ld      HL,(STRBOT)     ; Current bottom of string area
3080+ 271D CD E1 19             call    CPDEHL          ; Last one in string area?
3081+ 2720 C2 28 27             jp      NZ,POPHL        ; No - Return
3082+ 2723 47                   ld      B,A             ; Clear B (A=0)
3083+ 2724 09                   add     HL,BC           ; Remove string from str' area
3084+ 2725 22 AA 81             ld      (STRBOT),HL     ; Save new bottom of str' area
3085+ 2728 E1           POPHL:  pop     HL              ; Restore string
3086+ 2729 C9                   ret
3087+ 272A
3088+ 272A 2A 98 81     BAKTMP: ld      HL,(TMSTPT)     ; Get temporary string pool top
3089+ 272D 2B                   dec     HL              ; Back
3090+ 272E 46                   ld      B,(HL)          ; Get MSB of address
3091+ 272F 2B                   dec     HL              ; Back
3092+ 2730 4E                   ld      C,(HL)          ; Get LSB of address
3093+ 2731 2B                   dec     HL              ; Back
3094+ 2732 2B                   dec     HL              ; Back
3095+ 2733 CD E1 19             call    CPDEHL          ; String last in string pool?
3096+ 2736 C0                   ret     NZ              ; Yes - Leave it
3097+ 2737 22 98 81             ld      (TMSTPT),HL     ; Save new string pool top
3098+ 273A C9                   ret
3099+ 273B
3100+ 273B 01 BA 24     LEN:    ld      BC,PASSA        ; To return integer A
3101+ 273E C5                   push    BC              ; Save address
3102+ 273F CD 09 27     GETLEN: call    GETSTR          ; Get string and its length
3103+ 2742 AF                   xor     A
3104+ 2743 57                   ld      D,A             ; Clear D
3105+ 2744 32 94 81             ld      (TYPE),A        ; Set type to numeric
3106+ 2747 7E                   ld      A,(HL)          ; Get length of string
3107+ 2748 B7                   or      A               ; Set status flags
3108+ 2749 C9                   ret
3109+ 274A
3110+ 274A 01 BA 24     ASC:    ld      BC,PASSA        ; To return integer A
3111+ 274D C5                   push    BC              ; Save address
3112+ 274E CD 3F 27     GTFLNM: call    GETLEN          ; Get length of string
3113+ 2751 CA FB 1C             jp      Z,FCERR         ; Null string - Error
3114+ 2754 23                   inc     HL
3115+ 2755 23                   inc     HL
3116+ 2756 5E                   ld      E,(HL)          ; Get LSB of address
3117+ 2757 23                   inc     HL
3118+ 2758 56                   ld      D,(HL)          ; Get MSB of address
3119+ 2759 1A                   ld      A,(DE)          ; Get first byte of string
3120+ 275A C9                   ret
3121+ 275B
3122+ 275B 3E 01        CHR:    ld      A,$01           ; One character string
3123+ 275D CD 78 25             call    MKTMST          ; Make a temporary string
3124+ 2760 CD 4A 29             call    MAKINT          ; Make it integer A
3125+ 2763 2A A8 81             ld      HL,(TMPSTR+2)   ; Get address of string
3126+ 2766 73                   ld      (HL),E          ; Save character
3127+ 2767 C1           TOPOOL: pop     BC              ; Clean up stack
3128+ 2768 C3 A9 25             jp      TSTOPL          ; Temporary string to pool
3129+ 276B
3130+ 276B CD FA 28     LEFT:   call    LFRGNM          ; Get number and ending ")"
3131+ 276E AF                   xor     A               ; Start at first byte in string
3132+ 276F E3           RIGHT1: ex      (SP),HL         ; Save code string,Get string
3133+ 2770 4F                   ld      C,A             ; Starting position in string
3134+ 2771 E5           MID1:   push    HL              ; Save string block address
3135+ 2772 7E                   ld      A,(HL)          ; Get length of string
3136+ 2773 B8                   cp      B               ; Compare with number given
3137+ 2774 DA 79 27             jp      C,ALLFOL        ; All following bytes required
3138+ 2777 78                   ld      A,B             ; Get new length
3139+ 2778 11                   defb    $11             ; Skip "ld C,0"
3140+ 2779 0E 00        ALLFOL: ld      C,$00           ; First byte of string
3141+ 277B C5                   push    BC              ; Save position in string
3142+ 277C CD E2 25             call    TESTR           ; See if enough string space
3143+ 277F C1                   pop     BC              ; Get position in string
3144+ 2780 E1                   pop     HL              ; Restore string block address
3145+ 2781 E5                   push    HL              ; And re-save it
3146+ 2782 23                   inc     HL
3147+ 2783 23                   inc     HL
3148+ 2784 46                   ld      B,(HL)          ; Get LSB of address
3149+ 2785 23                   inc     HL
3150+ 2786 66                   ld      H,(HL)          ; Get MSB of address
3151+ 2787 68                   ld      L,B             ; HL = address of string
3152+ 2788 06 00                ld      B,$00           ; BC = starting address
3153+ 278A 09                   add     HL,BC           ; Point to that byte
3154+ 278B 44                   ld      B,H             ; BC = source string
3155+ 278C 4D                   ld      C,L
3156+ 278D CD 7B 25             call    CRTMST          ; Create a string entry
3157+ 2790 6F                   ld      L,A             ; Length of new string
3158+ 2791 CD FF 26             call    TOSTRA          ; Move string to string area
3159+ 2794 D1                   pop     DE              ; Clear stack
3160+ 2795 CD 10 27             call    GSTRDE          ; Move to string pool if needed
3161+ 2798 C3 A9 25             jp      TSTOPL          ; Temporary string to pool
3162+ 279B
3163+ 279B
3164+ 279B              ; INSTR statement - look for a string inside another string
3165+ 279B              ; usage: INSTR(A$,B$) -> search for B$ into A$
3166+ 279B              ; return 0 if B$ is not found into A$, or LEN(A$)<LEN(B$)
3167+ 279B              ; return 1~255 to indicate the starting position of B$ into A$
3168+ 279B              ; ex.: INSTR("HELLO","LO") returns 4 - INSTR("HOME","PC") returns 0
3169+ 279B              LNS1    equ     TMPBFR1
3170+ 279B              ADRS1   equ     TMPBFR2
3171+ 279B              LNS2    equ     TMPBFR3
3172+ 279B              ADRS2   equ     TMPBFR4
3173+ 279B              PT      equ     VIDEOBUFF
3174+ 279B              PT1     equ     VIDEOBUFF+2
3175+ 279B              PT2     equ     VIDEOBUFF+4
3176+ 279B              TP      equ     VIDEOBUFF+6
3177+ 279B              TF      equ     VIDEOBUFF+8
3178+ 279B CD E7 19     INSTR:  call    CHKSYN          ; make sure "(" follows
3179+ 279E 28                   defb    '('
3180+ 279F 2B                   dec     HL              ; dec 'cause GETCHR increments
3181+ 27A0 CD 30 1C             call    GETCHR          ; check if something follows
3182+ 27A3 CA ED 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
3183+ 27A6 CD D3 20             call    EVAL            ; Evaluate expression
3184+ 27A9 CD C5 20             call    TSTSTR          ; Make sure it's a string
3185+ 27AC 22 E5 81             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3186+ 27AF CD 0C 27             call    GSTRCU          ; check that a string follows
3187+ 27B2 CD 1D 2F             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3188+ 27B5 ED 53 DD 81          ld      (LNS1),DE       ; store values into
3189+ 27B9 ED 43 DF 81          ld      (ADRS1),BC      ; temp buffers
3190+ 27BD 2A E5 81             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3191+ 27C0 CD E7 19             call    CHKSYN          ; Make sure ',' follows
3192+ 27C3 2C                   defb    ','
3193+ 27C4 2B                   dec     HL              ; dec 'cause GETCHR increments
3194+ 27C5 CD 30 1C             call    GETCHR          ; check if something follows
3195+ 27C8 CA ED 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
3196+ 27CB CD D3 20             call    EVAL            ; Evaluate expression
3197+ 27CE CD C5 20             call    TSTSTR          ; Make sure it's a string
3198+ 27D1 22 E5 81             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3199+ 27D4 CD 0C 27             call    GSTRCU          ; check that a string follows
3200+ 27D7 CD 1D 2F             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3201+ 27DA ED 53 E1 81          ld      (LNS2),DE       ; store values into
3202+ 27DE ED 43 E3 81          ld      (ADRS2),BC      ; temp buffers
3203+ 27E2 2A E5 81             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3204+ 27E5 CD E7 19             call    CHKSYN          ; make sure ")" follows
3205+ 27E8 29                   defb    ')'
3206+ 27E9 E5                   push    HL              ; store current code string pointer (the point after the ")" ) ...
3207+ 27EA FD E1                pop     IY              ; ...into IY
3208+ 27EC AF                   xor     A               ; reset 10 RAM cells
3209+ 27ED 06 0A                ld      B,$0A           ; (INSTR registers)
3210+ 27EF 21 E5 81             ld      HL,PT           ; first cell
3211+ 27F2 77           EMPTINS:ld      (HL),A          ; reset cell
3212+ 27F3 23                   inc     HL              ; next cell
3213+ 27F4 10 FC                djnz    EMPTINS         ; repeat
3214+ 27F6 ED 5B E1 81          ld      DE,(LNS2)       ; load len(S2) into DE
3215+ 27FA 2A DD 81             ld      HL,(LNS1)       ; load len(S1) into HL
3216+ 27FD CD 04 40             call    CMP16           ; check that len(S1)>=len(S2)
3217+ 2800 DA 75 28             jp      C,RZINSTR       ; if len(S2)>len(S1) then return 0
3218+ 2803 AF           RPTINST:xor     A               ; reset...
3219+ 2804 32 EB 81             ld      (TP),A          ; ...TP...
3220+ 2807 32 ED 81             ld      (TF),A          ; ...and TF
3221+ 280A ED 4B E5 81          ld      BC,(PT)         ; pointer to S1
3222+ 280E 2A DF 81             ld      HL,(ADRS1)      ; first cell of S1
3223+ 2811 09                   add     HL,BC           ; get current position into RAM
3224+ 2812 7E                   ld      A,(HL)          ; load S1(PT)
3225+ 2813 2A E3 81             ld      HL,(ADRS2)      ; pointer to first char of S2
3226+ 2816 BE                   cp      (HL)            ; is S1(PT)=S2(0)?
3227+ 2817 20 3A                jr      NZ,CNT1INS      ; no, continue
3228+ 2819 3A E5 81             ld      A,(PT)          ; load current PT
3229+ 281C 32 EB 81             ld      (TP),A          ; TP=PT
3230+ 281F 32 E7 81             ld      (PT1),A         ; P1=PT
3231+ 2822 AF                   xor     A               ; set...
3232+ 2823 32 E9 81             ld      (PT2),A         ; ...PT2=0
3233+ 2826 3C                   inc     A               ;
3234+ 2827 32 ED 81             ld      (TF),A          ; set TF=1
3235+ 282A ED 4B E7 81  RP2INST:ld      BC,(PT1)        ; load pointer PT1
3236+ 282E 2A DF 81             ld      HL,(ADRS1)      ; load address of S1
3237+ 2831 09                   add     HL,BC           ; find char of S1 pointed by PT1
3238+ 2832 7E                   ld      A,(HL)          ; load S1(PT1)
3239+ 2833 ED 4B E9 81          ld      BC,(PT2)        ; load pointer PT2
3240+ 2837 2A E3 81             ld      HL,(ADRS2)      ; load char of S2 pointed by PT2
3241+ 283A 09                   add     HL,BC           ; find S2(PT2)
3242+ 283B BE                   cp      (HL)            ; is S1(PT1)=S2(PT2)?
3243+ 283C 20 4C                jr      NZ,CNTZIN       ; no, exit inner loop
3244+ 283E 21 E7 81             ld      HL,PT1
3245+ 2841 34                   inc     (HL)            ; increment PT1
3246+ 2842 3A E9 81             ld      A,(PT2)
3247+ 2845 3C                   inc     A               ; increment PT2
3248+ 2846 32 E9 81             ld      (PT2),A
3249+ 2849 CA 53 28             jp      Z,CNT1INS       ; if PT2>255 then exit
3250+ 284C 21 E1 81             ld      HL,LNS2         ; len(S2)
3251+ 284F BE                   cp      (HL)            ; PT2=len(S2)?
3252+ 2850 DA 2A 28             jp      C,RP2INST       ; no (PT2<len(S2) - repeat
3253+ 2853 3A ED 81     CNT1INS:ld      A,(TF)          ; check TF
3254+ 2856 A7                   and     A               ; TF=0? (clears also Carry for next SBC)
3255+ 2857 20 1C                jr      NZ,RZINSTR      ; no, exit
3256+ 2859 2A DD 81             ld      HL,(LNS1)       ; load len(S1)
3257+ 285C ED 4B E1 81          ld      BC,(LNS2)       ; load len(S2)
3258+ 2860 ED 42                sbc     HL,BC           ; HL=len(S1)-len(S2)
3259+ 2862 ED 5B E5 81          ld      DE,(PT)         ; load pointer
3260+ 2866 1C                   inc     E               ; PT=PT+1
3261+ 2867 ED 53 E5 81          ld      (PT),DE         ; store new value
3262+ 286B EB                   ex      DE,HL           ; invert registers
3263+ 286C CD 04 40             call    CMP16           ; check if PT>len(S1)-len(S2)
3264+ 286F DA 03 28             jp      C,RPTINST       ; repeat if <
3265+ 2872 CA 03 28             jp      Z,RPTINST       ; repeat if =
3266+ 2875 3A ED 81     RZINSTR:ld      A,(TF)          ; current value of TF
3267+ 2878 A7                   and     A               ; is it 0?
3268+ 2879 CA 80 28             jp      Z,LVINSTR       ; yes, return 0
3269+ 287C 3A EB 81             ld      A,(TP)          ; return TP...
3270+ 287F 3C                   inc     A               ; ...incremented by 1
3271+ 2880 E1           LVINSTR:pop     HL              ; drop original return point
3272+ 2881 FD E5                push    IY              ; load current string address from IY into stack
3273+ 2883 11 AC 21             ld      DE,RETNUM       ; Address of Return number from function...
3274+ 2886 D5                   push    DE              ; ...saved on stack
3275+ 2887 C3 BA 24             jp      PASSA           ; return TP
3276+ 288A AF           CNTZIN: xor     A               ; set...
3277+ 288B 32 ED 81             ld      (TF),A          ; TF=0
3278+ 288E C3 53 28             jp      CNT1INS         ; continue
3279+ 2891
3280+ 2891
3281+ 2891              ; returns the right portion of a string
3282+ 2891 CD FA 28     RIGHT:  call    LFRGNM          ; Get number and ending ")"
3283+ 2894 D1                   pop     DE              ; Get string length
3284+ 2895 D5                   push    DE              ; And re-save
3285+ 2896 1A                   ld      A,(DE)          ; Get length
3286+ 2897 90                   sub     B               ; Move back N bytes
3287+ 2898 C3 6F 27             jp      RIGHT1          ; Go and get sub-string
3288+ 289B
3289+ 289B              ; returns a piece of a string
3290+ 289B EB           MID:    ex      DE,HL           ; Get code string address
3291+ 289C 7E                   ld      A,(HL)          ; Get next byte ',' or ")"
3292+ 289D CD FF 28             call    MIDNUM          ; Get number supplied
3293+ 28A0 04                   inc     B               ; Is it character zero?
3294+ 28A1 05                   dec     B
3295+ 28A2 CA FB 1C             jp      Z,FCERR         ; Yes - Error
3296+ 28A5 C5                   push    BC              ; Save starting position
3297+ 28A6 1E FF                ld      E,$FF           ; All of string
3298+ 28A8 FE 29                cp      ')'             ; Any length given?
3299+ 28AA CA B4 28             jp      Z,RSTSTR        ; No - Rest of string
3300+ 28AD CD E7 19             call    CHKSYN          ; Make sure ',' follows
3301+ 28B0 2C                   defb    ','
3302+ 28B1 CD 47 29             call    GETINT          ; Get integer 0-255
3303+ 28B4 CD E7 19     RSTSTR: call    CHKSYN          ; Make sure ")" follows
3304+ 28B7 29                   defb    ')'
3305+ 28B8 F1                   pop     AF              ; Restore starting position
3306+ 28B9 E3                   ex      (SP),HL         ; Get string,save code string
3307+ 28BA 01 71 27             ld      BC,MID1         ; Continuation of MID$ routine
3308+ 28BD C5                   push    BC              ; Save for return
3309+ 28BE 3D                   dec     A               ; Starting position-1
3310+ 28BF BE                   cp      (HL)            ; Compare with length
3311+ 28C0 06 00                ld      B,$00           ; Zero bytes length
3312+ 28C2 D0                   ret     NC              ; Null string if start past end
3313+ 28C3 4F                   ld      C,A             ; Save starting position-1
3314+ 28C4 7E                   ld      A,(HL)          ; Get length of string
3315+ 28C5 91                   sub     C               ; Subtract start
3316+ 28C6 BB                   cp      E               ; Enough string for it?
3317+ 28C7 47                   ld      B,A             ; Save maximum length available
3318+ 28C8 D8                   ret     C               ; Truncate string if needed
3319+ 28C9 43                   ld      B,E             ; Set specified length
3320+ 28CA C9                   ret                     ; Go and create string
3321+ 28CB
3322+ 28CB
3323+ 28CB              ; return the value of a numeric string
3324+ 28CB CD 3F 27     VAL:    call    GETLEN          ; Get length of string
3325+ 28CE CA 9D 2C             jp      Z,RESZER        ; Result zero
3326+ 28D1 5F                   ld      E,A             ; Save length
3327+ 28D2 23                   inc     HL
3328+ 28D3 23                   inc     HL
3329+ 28D4 7E                   ld      A,(HL)          ; Get LSB of address
3330+ 28D5 23                   inc     HL
3331+ 28D6 66                   ld      H,(HL)          ; Get MSB of address
3332+ 28D7 6F                   ld      L,A             ; HL = String address
3333+ 28D8 E5                   push    HL              ; Save string address
3334+ 28D9 19                   add     HL,DE
3335+ 28DA 46                   ld      B,(HL)          ; Get end of string+1 byte
3336+ 28DB 72                   ld      (HL),D          ; Zero it to terminate
3337+ 28DC E3                   ex      (SP),HL         ; Save string end,get start
3338+ 28DD C5                   push    BC              ; Save end+1 byte
3339+ 28DE 7E                   ld      A,(HL)          ; Get starting byte
3340+ 28DF FE 24                cp      '$'             ; Hex number indicated? [function added]
3341+ 28E1 C2 E9 28             jp      NZ,VAL1
3342+ 28E4 CD 3D 3F             call    HEXTFP          ; Convert Hex to FPREG
3343+ 28E7 18 0D                jr      VAL3
3344+ 28E9 FE 25        VAL1:   cp      '%'             ; Binary number indicated? [function added]
3345+ 28EB C2 F3 28             jp      NZ,VAL2
3346+ 28EE CD AD 3F             call    BINTFP          ; Convert Bin to FPREG
3347+ 28F1 18 03                jr      VAL3
3348+ 28F3 CD D5 2F     VAL2:   call    ASCTFP          ; Convert ASCII string to FP
3349+ 28F6 C1           VAL3:   pop     BC              ; Restore end+1 byte
3350+ 28F7 E1                   pop     HL              ; Restore end+1 address
3351+ 28F8 70                   ld      (HL),B          ; Put back original byte
3352+ 28F9 C9                   ret
3353+ 28FA
3354+ 28FA EB           LFRGNM: ex      DE,HL           ; Code string address to HL
3355+ 28FB CD E7 19             call    CHKSYN          ; Make sure ")" follows
3356+ 28FE 29                   defb    ')'
3357+ 28FF C1           MIDNUM: pop     BC              ; Get return address
3358+ 2900 D1                   pop     DE              ; Get number supplied
3359+ 2901 C5                   push    BC              ; Re-save return address
3360+ 2902 43                   ld      B,E             ; Number to B
3361+ 2903 C9                   ret
3362+ 2904
3363+ 2904 CD 4A 29     INP:    call    MAKINT          ; Make it integer A
3364+ 2907 32 A0 80             ld      (INPORT),A      ; Set input port
3365+ 290A CD 9F 80             call    INPSUB          ; Get input from port
3366+ 290D C3 BA 24             jp      PASSA           ; Return integer A
3367+ 2910
3368+ 2910 CD 34 29     POUT:   call    SETIO           ; Set up port number
3369+ 2913 C3 67 80             jp      OUTSUB          ; Output data and return
3370+ 2916
3371+ 2916 CD 34 29     WAIT:   call    SETIO           ; Set up port number
3372+ 2919 F5                   push    AF              ; Save AND mask
3373+ 291A 1E 00                ld      E,$00           ; Assume zero if none given
3374+ 291C 2B                   dec     HL              ; dec 'cos GETCHR INCs
3375+ 291D CD 30 1C             call    GETCHR          ; Get next character
3376+ 2920 CA 2A 29             jp      Z,NOXOR         ; No XOR byte given
3377+ 2923 CD E7 19             call    CHKSYN          ; Make sure ',' follows
3378+ 2926 2C                   defb    ','
3379+ 2927 CD 47 29             call    GETINT          ; Get integer 0-255 to XOR with
3380+ 292A C1           NOXOR:  pop     BC              ; Restore AND mask
3381+ 292B CD 9F 80     WAITLP: call    INPSUB          ; Get input
3382+ 292E AB                   xor     E               ; Flip selected bits
3383+ 292F A0                   and     B               ; Result non-zero?
3384+ 2930 CA 2B 29             jp      Z,WAITLP        ; No = keep waiting
3385+ 2933 C9                   ret
3386+ 2934
3387+ 2934 CD 47 29     SETIO:  call    GETINT          ; Get integer 0-255
3388+ 2937 32 A0 80             ld      (INPORT),A      ; Set input port
3389+ 293A 32 68 80             ld      (OTPORT),A      ; Set output port
3390+ 293D CD E7 19             call    CHKSYN          ; Make sure ',' follows
3391+ 2940 2C                   defb    ','
3392+ 2941 C3 47 29             jp      GETINT          ; Get integer 0-255 and return
3393+ 2944
3394+ 2944 CD 30 1C     FNDNUM: call    GETCHR          ; Get next character
3395+ 2947 CD C1 20     GETINT: call    GETNUM          ; Get a number from 0 to 255
3396+ 294A CD E0 1C     MAKINT: call    DEPINT          ; Make sure value 0 - 255
3397+ 294D 7A                   ld      A,D             ; Get MSB of number
3398+ 294E B7                   or      A               ; Zero?
3399+ 294F C2 FB 1C             jp      NZ,FCERR        ; No - Error
3400+ 2952 2B                   dec     HL              ; dec 'cos GETCHR INCs
3401+ 2953 CD 30 1C             call    GETCHR          ; Get next character
3402+ 2956 7B                   ld      A,E             ; Get number to A
3403+ 2957 C9                   ret
3404+ 2958
3405+ 2958
3406+ 2958              ; activate a Non-Maskable Interrupt hooked to VDP interrupt signal
3407+ 2958              ; address must point to an ISR routine that terminates with EI/RETN instructions
3408+ 2958 CD C1 20     NMI:    call    GETNUM          ; Get memory address
3409+ 295B CD E6 1C             call    DEINT           ; get integer -32768 to 32767
3410+ 295E 7B                   ld      A,E             ; check if address is 0
3411+ 295F B2                   or      D
3412+ 2960 20 11                jr      NZ,NM1          ; no, so jump over
3413+ 2962 F3           DISNMI: di                      ; disable INTs
3414+ 2963 CD 8F 29             call    NMIDINT         ; disable VDP INT
3415+ 2966 E5                   push    HL              ; store HL
3416+ 2967 21 ED 45             ld      HL,$45ED        ; these are the op-codes for "RETN"
3417+ 296A 22 61 80             ld      (NMIUSR),HL     ; store RETN
3418+ 296D AF                   xor     A
3419+ 296E 32 63 80             ld      (NMIUSR+2),A    ; "NOP"
3420+ 2971 18 11                jr      NMI2            ; execute the last part of code
3421+ 2973 E5           NM1:    push    HL              ; store current HL
3422+ 2974 EB                   ex      DE,HL           ; move address argument into HL
3423+ 2975 F3                   di                      ; disable INTs
3424+ 2976 CD 8F 29             call    NMIDINT         ; disable VDP INT, if enabled
3425+ 2979 3E C3                ld      A,$C3           ; "jp" instruction
3426+ 297B 32 61 80             ld      (NMIUSR),A      ; store it
3427+ 297E 22 62 80             ld      (NMIUSR+1),HL   ; store address
3428+ 2981 CD 88 29             call    NMIEINT         ; re-enable VDP INT
3429+ 2984 FB           NMI2:   ei                      ; re-enable INTS
3430+ 2985 00                   nop                     ; wait for INTs
3431+ 2986 E1                   pop    HL               ; retrieve HL
3432+ 2987 C9                   ret                     ; return to caller
3433+ 2988              ; enable VDP INT
3434+ 2988 CD 9E 29     NMIEINT:call    NMIVR1          ; load default VReg #1 setting
3435+ 298B F6 20                or      %00100000       ; enable VDP INT
3436+ 298D 18 03                jr      NMIINT          ; rest of code is shared
3437+ 298F              ; disable VDP INT
3438+ 298F CD 9E 29     NMIDINT:call    NMIVR1          ; load default VReg #1 setting
3439+ 2992 D5           NMIINT: push    DE              ; store DE
3440+ 2993 5F                   ld      E,A             ; move value into E
3441+ 2994 3E 01                ld      A,$01           ; VREG #1
3442+ 2996 F3                   di                      ; disable INTs
3443+ 2997 CD C5 06             call    WRITE_VREG      ; disable VDP INT
3444+ 299A FB                   ei                      ; re-enable INTs
3445+ 299B 00                   nop                     ; wait for INTs being enabled
3446+ 299C D1                   pop     DE              ; retrieve DE
3447+ 299D C9                   ret                     ; return to caller
3448+ 299E
3449+ 299E              ; load VREG #1 setting for current screen mode and return it into A
3450+ 299E E5           NMIVR1: push    HL              ; store HL
3451+ 299F D5                   push    DE              ; store DE
3452+ 29A0 3A CF 81             ld      A,(SCR_MODE)    ; check screen mode
3453+ 29A3 87                   add     A,A             ; multiply A by 8...
3454+ 29A4 87                   add     A,A             ; ...so that reg. A can points..
3455+ 29A5 87                   add     A,A             ; to the correct settings
3456+ 29A6 3C                   inc     A               ; need to change VREG 1
3457+ 29A7 5F                   ld      E,A             ; copy A into E
3458+ 29A8 16 00                ld      D,$00           ; reset D
3459+ 29AA 21 37 0B             ld      HL,VDPMODESET   ; pointer to register #1 setting...
3460+ 29AD 19                   add     HL,DE           ; ...for current screen mode
3461+ 29AE 7E                   ld      A,(HL)          ; load current setting
3462+ 29AF D1                   pop     DE              ; retrieve DE
3463+ 29B0 E1                   pop     HL              ; retrieve HL
3464+ 29B1 C9                   ret                     ; return to caller
3465+ 29B2
3466+ 29B2              ; execute a machine language routine, eventually passing a param into A
3467+ 29B2 CD C1 20     SYS:    call    GETNUM          ; Get memory address
3468+ 29B5 CD E6 1C             call    DEINT           ; Get integer -32768 to 32767
3469+ 29B8 ED 53 DF 81          ld      (TMPBFR2),DE    ; store user routine's address
3470+ 29BC AF                   xor     A               ; reset A
3471+ 29BD 32 DD 81             ld      (TMPBFR1),A     ; store into temp buffer
3472+ 29C0 2B                   dec     HL              ; dec 'cos GETCHR INCs
3473+ 29C1 CD 30 1C             call    GETCHR          ; check next character
3474+ 29C4 28 0A                jr      Z,NOSYSPR       ; jump if nothing follows
3475+ 29C6 CD E7 19             call    CHKSYN          ; Make sure ',' follows
3476+ 29C9 2C                   defb    ','
3477+ 29CA CD 47 29             call    GETINT          ; get byte value (0~255) if something follows
3478+ 29CD 32 DD 81             ld      (TMPBFR1),A     ; store into temp buffer
3479+ 29D0 3A DD 81     NOSYSPR:ld      A,(TMPBFR1)     ; recover A
3480+ 29D3 ED 5B DF 81          ld      DE,(TMPBFR2)    ; recover user routine's address
3481+ 29D7 E5                   push    HL              ; save code string address
3482+ 29D8 EB                   ex      DE,HL           ; move user routine's address into HL
3483+ 29D9 11 DE 29             ld      DE,SYSRET       ; set point of return after the user routine
3484+ 29DC D5                   push    DE              ; store into stack
3485+ 29DD E9                   jp      (HL)            ; call user routine
3486+ 29DE E1           SYSRET: pop     HL              ; retrieve code string address
3487+ 29DF C9                   ret                     ; return to caller
3488+ 29E0
3489+ 29E0
3490+ 29E0              ; read the contents of a RAM location
3491+ 29E0 CD E6 1C     PEEK:   call    DEINT           ; Get memory address into DE
3492+ 29E3 1A                   ld      A,(DE)          ; Read value of memory cell
3493+ 29E4 C3 BA 24             jp      PASSA           ; Return into A
3494+ 29E7
3495+ 29E7              ; read the contents of a VRAM location
3496+ 29E7 CD E6 1C     VPEEK:  call    DEINT           ; Get VRAM address into DE
3497+ 29EA EB                   ex      DE,HL           ; Copy param into HL
3498+ 29EB F3                   di                      ; Disable interrupts
3499+ 29EC CD 9B 06             call    READ_VIDEO_LOC  ; Read data from VRAM at address HL
3500+ 29EF FB                   ei                      ; Re-enable interrupts
3501+ 29F0 EB                   ex      DE,HL           ; Restore HL
3502+ 29F1 C3 BA 24             jp      PASSA           ; Return value into A
3503+ 29F4
3504+ 29F4              ; recover params for POKE/VPOKE commands
3505+ 29F4              ; returns address into DE and byte to be written into A
3506+ 29F4 CD C1 20     PKEPRMS:call    GETNUM          ; Get memory address
3507+ 29F7 CD E6 1C             call    DEINT           ; Get integer -32768 to 32767
3508+ 29FA ED 53 DD 81          ld      (TMPBFR1),DE    ; Store DE into a temp. buffer
3509+ 29FE CD E7 19             call    CHKSYN          ; Make sure ',' follows
3510+ 2A01 2C                   defb    ','
3511+ 2A02 CD 47 29             call    GETINT          ; Get integer 0-255
3512+ 2A05 ED 5B DD 81          ld      DE,(TMPBFR1)    ; Restore memory address
3513+ 2A09 C9                   ret                     ; Return to caller
3514+ 2A0A
3515+ 2A0A              ; write a byte into a RAM location
3516+ 2A0A CD F4 29     POKE:   call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3517+ 2A0D 12                   ld      (DE),A          ; Load it into memory
3518+ 2A0E C9                   ret
3519+ 2A0F
3520+ 2A0F              ; write a byte into a VRAM location
3521+ 2A0F CD F4 29     VPOKE:  call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3522+ 2A12 EB                   ex      DE,HL           ; Copy address into HL
3523+ 2A13 F3                   di                      ; Disable interrupts
3524+ 2A14 CD B0 06             call    WRITE_VIDEO_LOC ; write data into VRAM at address HL
3525+ 2A17 FB                   ei                      ; Re-enable interrupts
3526+ 2A18 EB                   ex      DE,HL           ; Restore HL
3527+ 2A19 C9                   ret                     ; Return to caller
3528+ 2A1A
3529+ 2A1A              ; position the cursor at a specific X,Y location onto screen
3530+ 2A1A CD 47 29     LOCATE: call    GETINT          ; get the first param into A
3531+ 2A1D E5                   push    HL              ; store HL
3532+ 2A1E 21 CD 81             ld      HL,SCR_SIZE_W   ; load address of screen width
3533+ 2A21 5E                   ld      E,(HL)          ; load screen width into E
3534+ 2A22 E1                   pop     HL              ; restore HL
3535+ 2A23 BB                   cp      E               ; compare witdh with param
3536+ 2A24 D2 FB 1C             jp      NC,FCERR        ; value over the width of the screen, exit with Illegal F.C. error
3537+ 2A27 32 DD 81             ld      (TMPBFR1),A     ; Store X into a temp. buffer
3538+ 2A2A CD E7 19             call    CHKSYN          ; Make sure ',' follows
3539+ 2A2D 2C                   defb    ','
3540+ 2A2E CD 47 29             call    GETINT          ; Get the second param into A
3541+ 2A31 E5                   push    HL              ; store HL
3542+ 2A32 21 CE 81             ld      HL,SCR_SIZE_H   ; load address of screen width
3543+ 2A35 5E                   ld      E,(HL)          ; load screen width into A
3544+ 2A36 E1                   pop     HL              ; restore HL
3545+ 2A37 BB                   cp      E               ; compare witdh with param
3546+ 2A38 D2 FB 1C             jp      NC,FCERR        ; value over the height of the screen, exit with Illegal F.C. error
3547+ 2A3B 32 D5 81             ld      (SCR_CUR_NY),A  ; store new Y
3548+ 2A3E 3A DD 81             ld      A,(TMPBFR1)     ; recover the new X
3549+ 2A41 32 D4 81             ld      (SCR_CUR_NX),A  ; store new X
3550+ 2A44 E5                   push    HL              ; store HL
3551+ 2A45 F3                   di                      ; disable INTs
3552+ 2A46 CD E1 06             call    MOVCRS          ; move cursor to new location
3553+ 2A49 FB                   ei                      ; re-enable INTs
3554+ 2A4A E1                   pop     HL              ; restore HL
3555+ 2A4B C9                   ret                     ; return to caller
3556+ 2A4C
3557+ 2A4C              ; write a byte into one of the PSG registers
3558+ 2A4C CD 47 29     SREG:   call    GETINT          ; Get register number back into A
3559+ 2A4F FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3560+ 2A51 D2 FB 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3561+ 2A54 32 DD 81             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3562+ 2A57 CD E7 19             call    CHKSYN          ; Make sure ',' follows
3563+ 2A5A 2C                   defb    ','
3564+ 2A5B CD 47 29             call    GETINT          ; get second value (0-255), returned into A
3565+ 2A5E 5F                   ld      E,A             ; store value into E
3566+ 2A5F 3A DD 81             ld      A,(TMPBFR1)     ; recover VDP register and store into D
3567+ 2A62 F3                   di                      ; disable INTs
3568+ 2A63 0E 40                ld      C,PSG_REG       ; output port to access PSG registers
3569+ 2A65 ED 79                out     (C),A           ; send register # to PSG
3570+ 2A67 0E 41                ld      C,PSG_DAT       ; output port to send data to PSG
3571+ 2A69 ED 59                out     (C),E           ; send byte to write into selected register
3572+ 2A6B FB                   ei                      ; re-enable INTs
3573+ 2A6C C9                   ret                     ; return to caller
3574+ 2A6D
3575+ 2A6D              ; VOLUME ch,vol
3576+ 2A6D              ; set the volume for the audio channels
3577+ 2A6D              ; "ch" is 1~3 for corresponding channel, or 0 for all; "vol" is 0~15 (0=OFF, 15=MAX)
3578+ 2A6D CD 47 29     VOLUME: call    GETINT          ; get integer 0-255 (recover channel)
3579+ 2A70 FE 04                cp      $04             ; check if it's in the range 0~3
3580+ 2A72 D2 FB 1C             jp      NC,FCERR        ; if not, exit with Illegal function call error
3581+ 2A75 32 DD 81             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3582+ 2A78 CD E7 19             call    CHKSYN          ; Make sure ',' follows
3583+ 2A7B 2C                   defb    ','
3584+ 2A7C CD 47 29             call    GETINT          ; get integer 0-255 (recover channel)
3585+ 2A7F FE 10                cp      $10             ; check if it's in the range 0~15
3586+ 2A81 D2 FB 1C             jp      NC,FCERR        ; if not, exit with Illegal funcion call
3587+ 2A84 57                   ld      D,A             ; store volume into D
3588+ 2A85 3A DD 81             ld      A,(TMPBFR1)     ; retrieve channel
3589+ 2A88 A7                   and     A               ; is it 0? (0=every channel)
3590+ 2A89 20 10                jr      NZ,VOLCH        ; no, jump over
3591+ 2A8B 06 03                ld      B,$03           ; yes, set every channel
3592+ 2A8D 1E 08                ld      E,$08           ; register volume of first channel
3593+ 2A8F 0E 40        RPVOLCG:ld      C,PSG_REG       ; PSG register port
3594+ 2A91 ED 59                out     (C),E           ; set register #
3595+ 2A93 0E 41                ld      C,PSG_DAT       ; PSG data port
3596+ 2A95 ED 51                out     (C),D           ; send volume
3597+ 2A97 1C                   inc     E               ; next register
3598+ 2A98 10 F5                djnz    RPVOLCG         ; repeat for each channel
3599+ 2A9A C9                   ret                     ; return to caller
3600+ 2A9B 0E 40        VOLCH:  ld      C,PSG_REG       ; PSG register port
3601+ 2A9D C6 07                add     $07             ; add 7 to A so that we have the correct register (1->8, 2->9, 3->10)
3602+ 2A9F ED 79                out     (C),A           ; set register
3603+ 2AA1 0E 41                ld      C,PSG_DAT       ; PSG data port
3604+ 2AA3 ED 51                out     (C),D           ; send volume level
3605+ 2AA5 C9                   ret                     ; return to caller
3606+ 2AA6
3607+ 2AA6              ; SOUND ch,tone,dur
3608+ 2AA6              ; play a tone or noise of "tone" frequency from selected channel "ch" for duration "dur"
3609+ 2AA6              ; "ch" is 1~6 (0=means sound OFF,1~3 for tone, 4~6 for noise) / "tone" is 1~4,095 (0=means no tone) /
3610+ 2AA6              ; "dur" is 1~16383 h.o.s.,0.001~163s (0=means non-stop tone)
3611+ 2AA6 CD 47 29     SOUND:  call    GETINT          ; get integer 0-255 (recover channel)
3612+ 2AA9 A7                   and     A               ; is it zero?
3613+ 2AAA 20 08                jr      NZ,CTSNDC       ; no, continue with checking of params
3614+ 2AAC E5                   push    HL              ; store HL
3615+ 2AAD F3                   di                      ; disable INTs
3616+ 2AAE CD A9 0C             call    CLRPSGREGS      ; yes, it's zero, so reset PSG registers to shut down every sound
3617+ 2AB1 FB                   ei                      ; re-enable INTs
3618+ 2AB2 E1                   pop     HL              ; retrieve HL
3619+ 2AB3 C9                   ret                     ; return to caller
3620+ 2AB4 32 DD 81     CTSNDC: ld      (TMPBFR1),A     ; no, continue by storing A into a temp. buffer
3621+ 2AB7 FE 04                cp      $04             ; is channel >3?
3622+ 2AB9 D2 38 2B             jp      NC,NOISUP       ; Yes - check to see if it's a noise channel
3623+ 2ABC CD E7 19             call    CHKSYN          ; No, continue checking by making sure ',' follows
3624+ 2ABF 2C                   defb    ','
3625+ 2AC0 CD C1 20             call    GETNUM          ; Get tone frequency
3626+ 2AC3 CD E6 1C             call    DEINT           ; Get integer -32768 to 32767
3627+ 2AC6 ED 53 DF 81          ld      (TMPBFR2),DE    ; Store frequency
3628+ 2ACA CD E7 19             call    CHKSYN          ; Make sure ',' follows
3629+ 2ACD 2C                   defb    ','
3630+ 2ACE CD C1 20             call    GETNUM          ; Get duration
3631+ 2AD1 CD E6 1C             call    DEINT           ; Get integer -32768 to 32767
3632+ 2AD4 ED 53 E1 81          ld      (TMPBFR3),DE    ; Store duration
3633+ 2AD8                                              ; CHECK CHANNEL
3634+ 2AD8 3A DD 81             ld      A,(TMPBFR1)     ; recover channel
3635+ 2ADB FE 01                cp      $01             ; is channel <1?
3636+ 2ADD DA FB 1C             jp      C,FCERR         ; Yes - Illegal function call error
3637+ 2AE0                                              ; CHECK FREQUENCY
3638+ 2AE0 ED 5B DF 81          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3639+ 2AE4 7A                   ld      A,D             ; move D into A and check if it is in the range 0~4095...
3640+ 2AE5 FE 10                cp      $10             ; ...so D must not be greater than $0F (15)
3641+ 2AE7 D2 FB 1C             jp      NC,FCERR        ; if not in the range, exit with an Illegal function call error
3642+ 2AEA                                              ; CHECK DURATION
3643+ 2AEA ED 5B E1 81          ld      DE,(TMPBFR3)    ; restore duration from temp buffer
3644+ 2AEE 7A                   ld      A,D             ; check if it is in the range 0~16383...
3645+ 2AEF E6 C0                and     $C0             ; ...(15th & 14th bits must not be set)
3646+ 2AF1 C2 FB 1C             jp      NZ,FCERR        ; if not in the range, exit with an Illegal function call error
3647+ 2AF4                                              ;
3648+ 2AF4                                              ; SET TONE:
3649+ 2AF4                                              ; let's start by setting up the channel
3650+ 2AF4 3A DD 81             ld      A,(TMPBFR1)     ; restore channel value
3651+ 2AF7 FE 03                cp      $03             ; is it 3?
3652+ 2AF9 20 02                jr      NZ,SND1         ; no, jump over
3653+ 2AFB 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3654+ 2AFD 2F           SND1:   cpl                     ; complement of A - this is used later to set on the channel into the mixer
3655+ 2AFE CD 85 2B             call    WRTSND          ; enable line into mixer of channel stored in A
3656+ 2B01                                              ; SET FREQUENCY
3657+ 2B01                                              ; we simply get frequency and subtract from 4096. The result
3658+ 2B01                                              ; is put into register pair of the corresponding freq tone channel
3659+ 2B01 ED 5B DF 81          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3660+ 2B05 E5                   push    HL              ; store HL (it will be used by the subroutine)
3661+ 2B06 21 00 10             ld      HL,$1000        ; load 4096 into HL
3662+ 2B09 A7                   and     A               ; reset C flag
3663+ 2B0A ED 52                sbc     HL,DE           ; subtract freq from HL - now the frequency is inverted, so we will send the low as high and vice-versa
3664+ 2B0C 3A DD 81             ld      A,(TMPBFR1)     ; restore channel value
3665+ 2B0F 3D                   dec     A               ; set A into the range 0~2
3666+ 2B10 87                   add     A,A             ; double A to find the register pair that correspond to the channel (A->0,1 / B->2,3, C->4,5)
3667+ 2B11 0E 40                ld      C,PSG_REG       ; PSG register port
3668+ 2B13 ED 79                out     (C),A           ; select first register of the pair
3669+ 2B15 0E 41                ld      C,PSG_DAT       ; PSG data port
3670+ 2B17 ED 69                out     (C),L           ; send high byte
3671+ 2B19 0E 40                ld      C,PSG_REG       ; PSG register support
3672+ 2B1B 3C                   inc     A               ; second register of the pair
3673+ 2B1C ED 79                out     (C),A           ; select register
3674+ 2B1E 0E 41                ld      C,PSG_DAT       ; PSG data port
3675+ 2B20 ED 61                out     (C),H           ; send low byte
3676+ 2B22 ED 5B E1 81          ld      DE,(TMPBFR3)    ; recover duration
3677+ 2B26 3A DD 81             ld      A,(TMPBFR1)     ; recover channel value
3678+ 2B29 3D                   dec     A               ; set channel into the range 0~2
3679+ 2B2A 87                   add     A,A             ; double A to find the correct offset
3680+ 2B2B 21 11 82             ld      HL,CHASNDDTN    ; set duration into...
3681+ 2B2E 85                   add     A,L             ; ...the proper...
3682+ 2B2F 30 01                jr      NC,SNDOVR       ; (is there a rest? no, jump over
3683+ 2B31 24                   inc     H               ; yes, increment H)
3684+ 2B32 6F           SNDOVR: ld      L,A             ; ...register pair...
3685+ 2B33 73                   ld      (HL),E          ; ...and store the value
3686+ 2B34 23                   inc     HL
3687+ 2B35 72                   ld      (HL),D
3688+ 2B36 E1                   pop     HL              ; retrieve HL
3689+ 2B37 C9                   ret                     ; Return to caller
3690+ 2B38 FE 07        NOISUP: cp      $07             ; is channel in range 4 to 6 (for a noise)?
3691+ 2B3A D2 FB 1C             jp      NC,FCERR        ; no, so ILLEGAL FUNCTION CALL
3692+ 2B3D CD E7 19             call    CHKSYN          ; yes, continue checking by making sure ',' follows
3693+ 2B40 2C                   defb    ','
3694+ 2B41 CD 47 29             call    GETINT          ; get integer 0-255 (frequency)
3695+ 2B44 FE 20                cp      $20             ; make sure it's in range 0~31
3696+ 2B46 D2 FB 1C             jp      NC,FCERR        ; no, so Illegal function call
3697+ 2B49 32 DF 81             ld      (TMPBFR2),A     ; store freq.
3698+ 2B4C 2B                   dec     HL              ; dec 'cos GETCHR INCs
3699+ 2B4D CD 30 1C             call    GETCHR          ; check that nothing follows
3700+ 2B50 C2 ED 16             jp      NZ,SNERR        ; error if no empty line
3701+ 2B53 3A DF 81             ld      A,(TMPBFR2)     ; retrieve freq.
3702+ 2B56 5F                   ld      E,A             ; store freq into E
3703+ 2B57 3A DD 81             ld      A,(TMPBFR1)     ; retrieve channel
3704+ 2B5A D6 03                sub     $03             ; subtract 3 to get channel in range 1~3
3705+ 2B5C FE 03                cp      $03             ; is it 3?
3706+ 2B5E 20 02                jr      NZ,NOS1         ; no, jump over
3707+ 2B60 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3708+ 2B62 87           NOS1:   add     A,A
3709+ 2B63 87                   add     A,A
3710+ 2B64 87                   add     A,A             ; let's move A 3 bits to left
3711+ 2B65 47                   ld      B,A             ; store channel into B
3712+ 2B66 7B                   ld      A,E             ; check if
3713+ 2B67 A7                   and     A               ; freq is 0 (means that noise reproduction must be halted)
3714+ 2B68 F3                   di                      ; disable INts
3715+ 2B69 20 0A                jr      NZ,NOS2         ; no, so jump over
3716+ 2B6B 3E 07                ld      A,$07           ; mixer register
3717+ 2B6D CD F7 0C             call    SETSNDREG       ; set mixer register
3718+ 2B70 ED 78                in      A,(C)           ; load current mixer value
3719+ 2B72 B0                   or      B               ; disable noise
3720+ 2B73 18 19                jr      NOS3            ; continue over
3721+ 2B75 78           NOS2:   ld      A,B             ; recover channel
3722+ 2B76 2F                   cpl                     ; complement of A - this is used to set on the channel into the mixer
3723+ 2B77 CD 85 2B             call    WRTSND          ; enable line into mixer of channel stored in A
3724+ 2B7A 3E 06                ld      A,$06           ; write into noise register
3725+ 2B7C CD F7 0C             call    SETSNDREG       ; set register into PSG
3726+ 2B7F 7B                   ld      A,E             ; load value for noise frequency
3727+ 2B80 CD FC 0C             call    WRTSNDREG       ; write data into register $06
3728+ 2B83 FB                   ei                      ; re-enable INTs
3729+ 2B84 C9                   ret
3730+ 2B85                      ; enable line into mixer of channel stored in A
3731+ 2B85 47           WRTSND: ld      B,A             ; move channel into B
3732+ 2B86 3E 07                ld      A,$07           ; mixer register
3733+ 2B88 CD F7 0C             call    SETSNDREG       ; set mixer register
3734+ 2B8B ED 78                in      A,(C)           ; load current value
3735+ 2B8D A0                   and     B               ; set on the channel into the mixer (remember that 0=ON)
3736+ 2B8E                                              ; example: if channel is A (1), complement of 1 is 254 (11111110). So, 255 (in case
3737+ 2B8E                                              ; the register is still unchanged after reset) is 11111111 and
3738+ 2B8E                                              ; 11111111 AND 11111110 is equal to 11111110
3739+ 2B8E                                              ; 11111001 AND 11111110 is equal to 11111000 (in case channels B & C are ON)
3740+ 2B8E 47           NOS3:   ld      B,A             ; store new mixer value into B
3741+ 2B8F 3E 07                ld      A,$07           ; mixer address
3742+ 2B91 CD F7 0C             call    SETSNDREG       ; set register
3743+ 2B94 78                   ld      A,B             ; retrieve new mixer value from B
3744+ 2B95 CD FC 0C             call    WRTSNDREG       ; send new value for the mixer
3745+ 2B98 FB                   ei                      ; re-enable INTs
3746+ 2B99 C9                   ret                     ; return to caller
3747+ 2B9A
3748+ 2B9A              ; write a byte into one of the VDP registers
3749+ 2B9A CD 47 29     VREG:   call    GETINT          ; Get register number back into A
3750+ 2B9D FE 08                cp      $08             ; check if value is equal or greater than 8 (VDP registers are only 8, from 0 to 7)
3751+ 2B9F D2 FB 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3752+ 2BA2 32 DD 81             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3753+ 2BA5 CD E7 19             call    CHKSYN          ; Make sure ',' follows
3754+ 2BA8 2C                   defb    ','
3755+ 2BA9 CD 47 29             call    GETINT          ; get value (0-255)
3756+ 2BAC 5F                   ld      E,A             ; store value into E
3757+ 2BAD 3A DD 81             ld      A,(TMPBFR1)     ; recover VDP register and store into A
3758+ 2BB0 F3                   di                      ; disable INTs
3759+ 2BB1 CD C5 06             call    WRITE_VREG      ; write value into VDP register
3760+ 2BB4 FB                   ei                      ; re-enable INTs
3761+ 2BB5 C9                   ret                     ; return to caller
3762+ 2BB6
3763+ 2BB6              ; read the VDP status register and return it into A
3764+ 2BB6 CD E6 1C     VSTAT:  call    DEINT           ; Get integer -32768 to 32767 (Note: we do NOT use it)
3765+ 2BB9 F3                   di                      ; disable INTs
3766+ 2BBA CD D0 06             call    READ_VSTAT      ; read VDP register status
3767+ 2BBD FB                   ei                      ; re-enable INTs
3768+ 2BBE C3 BA 24             jp      PASSA           ; Return integer A
3769+ 2BC1
3770+ 2BC1              ; read from PSG register and return it into A
3771+ 2BC1 CD E6 1C     SSTAT:  call    DEINT           ; get integer -32768 to 32767
3772+ 2BC4 7B                   ld      A,E             ; consider LSB
3773+ 2BC5 FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3774+ 2BC7 D2 FB 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3775+ 2BCA F3                   di                      ; disable INts
3776+ 2BCB 0E 40                ld      C,PSG_REG       ; output port to set PSG register
3777+ 2BCD ED 79                out     (C),A           ; send register to read from
3778+ 2BCF ED 78                in      A,(C)           ; read register's contents and store into A
3779+ 2BD1 FB                   ei                      ; re-enable INTs
3780+ 2BD2 C3 BA 24             jp      PASSA           ; return A
3781+ 2BD5
3782+ 2BD5              ; read the temp key buffer and return the value of the current key being pressed
3783+ 2BD5              ; can wait for the number of 100thds of second before to return
3784+ 2BD5 CD 34 25     INKEY:  call    IDTEST          ; Test for illegal direct
3785+ 2BD8 CD E6 1C             call    DEINT           ; get number param (100thds of second to wait) into DE
3786+ 2BDB C5                   push    BC              ; store BC
3787+ 2BDC 3A BD 81             ld      A,(TMRCNT)      ; Load current value of system timer
3788+ 2BDF 47                   ld      B,A             ; move it into B
3789+ 2BE0 3A BD 81     CMP_A:  ld      A,(TMRCNT)      ; make a little delay of 1/100 sec...
3790+ 2BE3 B8                   cp      B               ; ...to let the sniffer collect...
3791+ 2BE4 20 FA                jr      NZ,CMP_A        ; ...at least 1 char before to continue
3792+ 2BE6 7A                   ld      A,D             ; check the param
3793+ 2BE7 B3                   or      E               ; if DE<>0 then...
3794+ 2BE8 20 05                jr      NZ,INKEY2       ; ...jump over...
3795+ 2BEA 3A 19 82             ld      A,(TMPKEYBFR)   ; ...else read the buffer and...
3796+ 2BED 18 2A                jr      ENDINK          ; ...return it
3797+ 2BEF 7A           INKEY2: ld      A,D             ; check if param>1023
3798+ 2BF0 FE 04                cp      $04             ; to do this we check if MSB>3
3799+ 2BF2 D2 FB 1C             jp      NC,FCERR        ; if MSB >=4 then error
3800+ 2BF5 E5                   push    HL              ; store HL
3801+ 2BF6 21 09 00             ld      HL,$0009        ; check if value
3802+ 2BF9 CD 04 40             call    CMP16           ; is < 10
3803+ 2BFC E1                   pop     HL              ; retrieve HL
3804+ 2BFD DA 03 2C             jp      C,SRTINK        ; if value >= 10 then jump over
3805+ 2C00 11 0A 00             ld      DE,$000A        ; else, use 10 (no intervals shorter than 10/100s)
3806+ 2C03 3A BD 81     SRTINK: ld      A,(TMRCNT)      ; Load the first byte of the system timer
3807+ 2C06 47                   ld      B,A             ; move it into B
3808+ 2C07 3A 19 82     CHKINK: ld      A,(TMPKEYBFR)   ; load char code from buffer
3809+ 2C0A A7                   and     A               ; is it 0?
3810+ 2C0B 20 0C                jr      NZ,ENDINK       ; no, so we can return it
3811+ 2C0D 3A BD 81             ld      A,(TMRCNT)      ; load the first byte of the system timer
3812+ 2C10 B8                   cp      B               ; is it the same value?
3813+ 2C11 28 F4                jr      Z,CHKINK        ; yes, so read again
3814+ 2C13 47                   ld      B,A             ; store new value
3815+ 2C14 1B                   dec     DE              ; no, decrement timer
3816+ 2C15 7A                   ld      A,D             ; check if zero reached
3817+ 2C16 B3                   or      E               ; by ORing D and E
3818+ 2C17 20 EE                jr      NZ,CHKINK       ; if not 0, repeat
3819+ 2C19 C1           ENDINK: pop     BC              ; restore BC
3820+ 2C1A F5                   push    AF              ; store A
3821+ 2C1B F3                   di                      ; disable INTs
3822+ 2C1C AF                   xor     A               ; clear the...
3823+ 2C1D 32 19 82             ld      (TMPKEYBFR),A   ; ...TMP KEY buffer for the next read
3824+ 2C20 FB                   ei                      ; re-enable INTs
3825+ 2C21 F1                   pop     AF              ; retrieve A
3826+ 2C22 C3 BA 24     ENDINK2:jp      PASSA           ; return A as ASCII value
3827+ 2C25
3828+ 2C25
3829+ 2C25 21 4C 31     ROUND:  ld      HL,HALF         ; Add 0.5 to FPREG
3830+ 2C28 CD 1D 2F     ADDPHL: call    LOADFP          ; Load FP at (HL) to BCDE
3831+ 2C2B C3 37 2C             jp      FPADD           ; Add BCDE to FPREG
3832+ 2C2E
3833+ 2C2E
3834+ 2C2E CD 1D 2F     SUBPHL: call    LOADFP          ; FPREG = -FPREG + number at HL
3835+ 2C31 21                   defb    $21             ; Skip "pop BC" and "pop DE"
3836+ 2C32 C1           PSUB:   pop     BC              ; Get FP number from stack
3837+ 2C33 D1                   pop     DE
3838+ 2C34 CD F7 2E     SUBCDE: call    INVSGN          ; Negate FPREG
3839+ 2C37 78           FPADD:  ld      A,B             ; Get FP exponent
3840+ 2C38 B7                   or      A               ; Is number zero?
3841+ 2C39 C8                   ret     Z               ; Yes - Nothing to add
3842+ 2C3A 3A 34 82             ld      A,(FPEXP)       ; Get FPREG exponent
3843+ 2C3D B7                   or      A               ; Is this number zero?
3844+ 2C3E CA 0F 2F             jp      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3845+ 2C41 90                   sub     B               ; BCDE number larger?
3846+ 2C42 D2 51 2C             jp      NC,NOSWAP       ; No - Don't swap them
3847+ 2C45 2F                   cpl                     ; Two's complement
3848+ 2C46 3C                   inc     A               ;  FP exponent
3849+ 2C47 EB                   ex      DE,HL
3850+ 2C48 CD FF 2E             call    STAKFP          ; Put FPREG on stack
3851+ 2C4B EB                   ex      DE,HL
3852+ 2C4C CD 0F 2F             call    FPBCDE          ; Move BCDE to FPREG
3853+ 2C4F C1                   pop     BC              ; Restore number from stack
3854+ 2C50 D1                   pop     DE
3855+ 2C51 FE 19        NOSWAP: cp      24+1            ; Second number insignificant?
3856+ 2C53 D0                   ret     NC              ; Yes - First number is result
3857+ 2C54 F5                   push    AF              ; Save number of bits to scale
3858+ 2C55 CD 34 2F             call    SIGNS           ; Set MSBs & sign of result
3859+ 2C58 67                   ld      H,A             ; Save sign of result
3860+ 2C59 F1                   pop     AF              ; Restore scaling factor
3861+ 2C5A CD FC 2C             call    SCALE           ; Scale BCDE to same exponent
3862+ 2C5D B4                   or      H               ; Result to be positive?
3863+ 2C5E 21 31 82             ld      HL,FPREG        ; Point to FPREG
3864+ 2C61 F2 77 2C             jp      P,MINCDE        ; No - Subtract FPREG from CDE
3865+ 2C64 CD DC 2C             call    PLUCDE          ; Add FPREG to CDE
3866+ 2C67 D2 BD 2C             jp      NC,RONDUP       ; No overflow - Round it up
3867+ 2C6A 23                   inc     HL              ; Point to exponent
3868+ 2C6B 34                   inc     (HL)            ; Increment it
3869+ 2C6C CA FC 16             jp      Z,OVERR         ; Number overflowed - Error
3870+ 2C6F 2E 01                ld      L,$01           ; 1 bit to shift right
3871+ 2C71 CD 12 2D             call    SHRT1           ; Shift result right
3872+ 2C74 C3 BD 2C             jp      RONDUP          ; Round it up
3873+ 2C77
3874+ 2C77 AF           MINCDE: xor     A               ; Clear A and carry
3875+ 2C78 90                   sub     B               ; Negate exponent
3876+ 2C79 47                   ld      B,A             ; Re-save exponent
3877+ 2C7A 7E                   ld      A,(HL)          ; Get LSB of FPREG
3878+ 2C7B 9B                   sbc     A, E            ; Subtract LSB of BCDE
3879+ 2C7C 5F                   ld      E,A             ; Save LSB of BCDE
3880+ 2C7D 23                   inc     HL
3881+ 2C7E 7E                   ld      A,(HL)          ; Get NMSB of FPREG
3882+ 2C7F 9A                   sbc     A,D             ; Subtract NMSB of BCDE
3883+ 2C80 57                   ld      D,A             ; Save NMSB of BCDE
3884+ 2C81 23                   inc     HL
3885+ 2C82 7E                   ld      A,(HL)          ; Get MSB of FPREG
3886+ 2C83 99                   sbc     A,C             ; Subtract MSB of BCDE
3887+ 2C84 4F                   ld      C,A             ; Save MSB of BCDE
3888+ 2C85 DC E8 2C     CONPOS: call    C,COMPL         ; Overflow - Make it positive
3889+ 2C88
3890+ 2C88 68           BNORM:  ld      L,B             ; L = Exponent
3891+ 2C89 63                   ld      H,E             ; H = LSB
3892+ 2C8A AF                   xor     A
3893+ 2C8B 47           BNRMLP: ld      B,A             ; Save bit count
3894+ 2C8C 79                   ld      A,C             ; Get MSB
3895+ 2C8D B7                   or      A               ; Is it zero?
3896+ 2C8E C2 AA 2C             jp      NZ,PNORM        ; No - Do it bit at a time
3897+ 2C91 4A                   ld      C,D             ; MSB = NMSB
3898+ 2C92 54                   ld      D,H             ; NMSB= LSB
3899+ 2C93 65                   ld      H,L             ; LSB = VLSB
3900+ 2C94 6F                   ld      L,A             ; VLSB= 0
3901+ 2C95 78                   ld      A,B             ; Get exponent
3902+ 2C96 D6 08                sub     $08             ; Count 8 bits
3903+ 2C98 FE E0                cp      -24-8           ; Was number zero?
3904+ 2C9A C2 8B 2C             jp      NZ,BNRMLP       ; No - Keep normalising
3905+ 2C9D AF           RESZER: xor     A               ; Result is zero
3906+ 2C9E 32 34 82     SAVEXP: ld      (FPEXP),A       ; Save result as zero
3907+ 2CA1 C9                   ret
3908+ 2CA2
3909+ 2CA2 05           NORMAL: dec     B               ; Count bits
3910+ 2CA3 29                   add     HL,HL           ; Shift HL left
3911+ 2CA4 7A                   ld      A,D             ; Get NMSB
3912+ 2CA5 17                   rla                     ; Shift left with last bit
3913+ 2CA6 57                   ld      D,A             ; Save NMSB
3914+ 2CA7 79                   ld      A,C             ; Get MSB
3915+ 2CA8 8F                   adc     A,A             ; Shift left with last bit
3916+ 2CA9 4F                   ld      C,A             ; Save MSB
3917+ 2CAA F2 A2 2C     PNORM:  jp      P,NORMAL        ; Not done - Keep going
3918+ 2CAD 78                   ld      A,B             ; Number of bits shifted
3919+ 2CAE 5C                   ld      E,H             ; Save HL in EB
3920+ 2CAF 45                   ld      B,L
3921+ 2CB0 B7                   or      A               ; Any shifting done?
3922+ 2CB1 CA BD 2C             jp      Z,RONDUP        ; No - Round it up
3923+ 2CB4 21 34 82             ld      HL,FPEXP        ; Point to exponent
3924+ 2CB7 86                   add     A,(HL)          ; Add shifted bits
3925+ 2CB8 77                   ld      (HL),A          ; Re-save exponent
3926+ 2CB9 D2 9D 2C             jp      NC,RESZER       ; Underflow - Result is zero
3927+ 2CBC C8                   ret     Z               ; Result is zero
3928+ 2CBD 78           RONDUP: ld      A,B             ; Get VLSB of number
3929+ 2CBE 21 34 82     RONDB:  ld      HL,FPEXP        ; Point to exponent
3930+ 2CC1 B7                   or      A               ; Any rounding?
3931+ 2CC2 FC CF 2C             call    M,FPROND        ; Yes - Round number up
3932+ 2CC5 46                   ld      B,(HL)          ; B = Exponent
3933+ 2CC6 23                   inc     HL
3934+ 2CC7 7E                   ld      A,(HL)          ; Get sign of result
3935+ 2CC8 E6 80                and     %10000000       ; Only bit 7 needed
3936+ 2CCA A9                   xor     C               ; Set correct sign
3937+ 2CCB 4F                   ld      C,A             ; Save correct sign in number
3938+ 2CCC C3 0F 2F             jp      FPBCDE          ; Move BCDE to FPREG
3939+ 2CCF
3940+ 2CCF 1C           FPROND: inc     E               ; Round LSB
3941+ 2CD0 C0                   ret     NZ              ; Return if ok
3942+ 2CD1 14                   inc     D               ; Round NMSB
3943+ 2CD2 C0                   ret     NZ              ; Return if ok
3944+ 2CD3 0C                   inc     C               ; Round MSB
3945+ 2CD4 C0                   ret     NZ              ; Return if ok
3946+ 2CD5 0E 80                ld      C,$80           ; Set normal value
3947+ 2CD7 34                   inc     (HL)            ; Increment exponent
3948+ 2CD8 C0                   ret     NZ              ; Return if ok
3949+ 2CD9 C3 FC 16             jp      OVERR           ; Overflow error
3950+ 2CDC
3951+ 2CDC 7E           PLUCDE: ld      A,(HL)          ; Get LSB of FPREG
3952+ 2CDD 83                   add     A,E             ; Add LSB of BCDE
3953+ 2CDE 5F                   ld      E,A             ; Save LSB of BCDE
3954+ 2CDF 23                   inc     HL
3955+ 2CE0 7E                   ld      A,(HL)          ; Get NMSB of FPREG
3956+ 2CE1 8A                   adc     A,D             ; Add NMSB of BCDE
3957+ 2CE2 57                   ld      D,A             ; Save NMSB of BCDE
3958+ 2CE3 23                   inc     HL
3959+ 2CE4 7E                   ld      A,(HL)          ; Get MSB of FPREG
3960+ 2CE5 89                   adc     A,C             ; Add MSB of BCDE
3961+ 2CE6 4F                   ld      C,A             ; Save MSB of BCDE
3962+ 2CE7 C9                   ret
3963+ 2CE8
3964+ 2CE8 21 35 82     COMPL:  ld      HL,SGNRES       ; Sign of result
3965+ 2CEB 7E                   ld      A,(HL)          ; Get sign of result
3966+ 2CEC 2F                   cpl                     ; Negate it
3967+ 2CED 77                   ld      (HL),A          ; Put it back
3968+ 2CEE AF                   xor     A
3969+ 2CEF 6F                   ld      L,A             ; Set L to zero
3970+ 2CF0 90                   sub     B               ; Negate exponent,set carry
3971+ 2CF1 47                   ld      B,A             ; Re-save exponent
3972+ 2CF2 7D                   ld      A,L             ; Load zero
3973+ 2CF3 9B                   sbc     A,E             ; Negate LSB
3974+ 2CF4 5F                   ld      E,A             ; Re-save LSB
3975+ 2CF5 7D                   ld      A,L             ; Load zero
3976+ 2CF6 9A                   sbc     A,D             ; Negate NMSB
3977+ 2CF7 57                   ld      D,A             ; Re-save NMSB
3978+ 2CF8 7D                   ld      A,L             ; Load zero
3979+ 2CF9 99                   sbc     A,C             ; Negate MSB
3980+ 2CFA 4F                   ld      C,A             ; Re-save MSB
3981+ 2CFB C9                   ret
3982+ 2CFC
3983+ 2CFC 06 00        SCALE:  ld      B,$00           ; Clear underflow
3984+ 2CFE D6 08        SCALLP: sub     $08             ; 8 bits (a whole byte)?
3985+ 2D00 DA 0B 2D             jp      C,SHRITE        ; No - Shift right A bits
3986+ 2D03 43                   ld      B,E             ; <- Shift
3987+ 2D04 5A                   ld      E,D             ; <- right
3988+ 2D05 51                   ld      D,C             ; <- eight
3989+ 2D06 0E 00                ld      C,$00           ; <- bits
3990+ 2D08 C3 FE 2C             jp      SCALLP          ; More bits to shift
3991+ 2D0B
3992+ 2D0B C6 09        SHRITE: add     A,8+1           ; Adjust count
3993+ 2D0D 6F                   ld      L,A             ; Save bits to shift
3994+ 2D0E AF           SHRLP:  xor     A               ; Flag for all done
3995+ 2D0F 2D                   dec     L               ; All shifting done?
3996+ 2D10 C8                   ret     Z               ; Yes - Return
3997+ 2D11 79                   ld      A,C             ; Get MSB
3998+ 2D12 1F           SHRT1:  rra                     ; Shift it right
3999+ 2D13 4F                   ld      C,A             ; Re-save
4000+ 2D14 7A                   ld      A,D             ; Get NMSB
4001+ 2D15 1F                   rra                     ; Shift right with last bit
4002+ 2D16 57                   ld      D,A             ; Re-save it
4003+ 2D17 7B                   ld      A,E             ; Get LSB
4004+ 2D18 1F                   rra                     ; Shift right with last bit
4005+ 2D19 5F                   ld      E,A             ; Re-save it
4006+ 2D1A 78                   ld      A,B             ; Get underflow
4007+ 2D1B 1F                   rra                     ; Shift right with last bit
4008+ 2D1C 47                   ld      B,A             ; Re-save underflow
4009+ 2D1D C3 0E 2D             jp      SHRLP           ; More bits to do
4010+ 2D20
4011+ 2D20 00 00 00 81  UNITY:  defb    $00,$00,$00,$81 ; 1.00000
4012+ 2D24
4013+ 2D24 03           LOGTAB: defb    $03             ; Table used by LOG
4014+ 2D25 AA 56 19 80          defb    $AA,$56,$19,$80 ; 0.59898
4015+ 2D29 F1 22 76 80          defb    $F1,$22,$76,$80 ; 0.96147
4016+ 2D2D 45 AA 38 82          defb    $45,$AA,$38,$82 ; 2.88539
4017+ 2D31
4018+ 2D31 CD CE 2E     LOG:    call    TSTSGN          ; Test sign of value
4019+ 2D34 B7                   or      A
4020+ 2D35 EA FB 1C             jp      PE,FCERR        ; ?FC Error if <= zero
4021+ 2D38 21 34 82             ld      HL,FPEXP        ; Point to exponent
4022+ 2D3B 7E                   ld      A,(HL)          ; Get exponent
4023+ 2D3C 01 35 80             ld      BC,$8035        ; BCDE = SQR(1/2)
4024+ 2D3F 11 F3 04             ld      DE,$04F3
4025+ 2D42 90                   sub     B               ; Scale value to be < 1
4026+ 2D43 F5                   push    AF              ; Save scale factor
4027+ 2D44 70                   ld      (HL),B          ; Save new exponent
4028+ 2D45 D5                   push    DE              ; Save SQR(1/2)
4029+ 2D46 C5                   push    BC
4030+ 2D47 CD 37 2C             call    FPADD           ; Add SQR(1/2) to value
4031+ 2D4A C1                   pop     BC              ; Restore SQR(1/2)
4032+ 2D4B D1                   pop     DE
4033+ 2D4C 04                   inc     B               ; Make it SQR(2)
4034+ 2D4D CD 24 2E             call    DVBCDE          ; Divide by SQR(2)
4035+ 2D50 21 20 2D             ld      HL,UNITY        ; Point to 1.
4036+ 2D53 CD 2E 2C             call    SUBPHL          ; Subtract FPREG from 1
4037+ 2D56 21 24 2D             ld      HL,LOGTAB       ; Coefficient table
4038+ 2D59 CD 16 32             call    SUMSER          ; Evaluate sum of series
4039+ 2D5C 01 80 80             ld      BC,$8080        ; BCDE = -0.5
4040+ 2D5F 11 00 00             ld      DE,$0000
4041+ 2D62 CD 37 2C             call    FPADD           ; Subtract 0.5 from FPREG
4042+ 2D65 F1                   pop     AF              ; Restore scale factor
4043+ 2D66 CD 49 30             call    RSCALE          ; Re-scale number
4044+ 2D69 01 31 80     MULLN2: ld      BC,$8031        ; BCDE = Ln(2)
4045+ 2D6C 11 18 72             ld      DE,$7218
4046+ 2D6F 21                   defb    $21             ; Skip "pop BC" and "pop DE"
4047+ 2D70
4048+ 2D70 C1           MULT:   pop     BC              ; Get number from stack
4049+ 2D71 D1                   pop     DE
4050+ 2D72 CD CE 2E     FPMULT: call    TSTSGN          ; Test sign of FPREG
4051+ 2D75 C8                   ret     Z               ; Return zero if zero
4052+ 2D76 2E 00                ld      L,$00           ; Flag add exponents
4053+ 2D78 CD 8C 2E             call    ADDEXP          ; Add exponents
4054+ 2D7B 79                   ld      A,C             ; Get MSB of multiplier
4055+ 2D7C 32 43 82             ld      (MULVAL),A      ; Save MSB of multiplier
4056+ 2D7F EB                   ex      DE,HL
4057+ 2D80 22 44 82             ld      (MULVAL+1),HL   ; Save rest of multiplier
4058+ 2D83 01 00 00             ld      BC,$0000        ; Partial product (BCDE) = zero
4059+ 2D86 50                   ld      D,B
4060+ 2D87 58                   ld      E,B
4061+ 2D88 21 88 2C             ld      HL,BNORM        ; Address of normalise
4062+ 2D8B E5                   push    HL              ; Save for return
4063+ 2D8C 21 94 2D             ld      HL,MULT8        ; Address of 8 bit multiply
4064+ 2D8F E5                   push    HL              ; Save for NMSB,MSB
4065+ 2D90 E5                   push    HL              ;
4066+ 2D91 21 31 82             ld      HL,FPREG        ; Point to number
4067+ 2D94 7E           MULT8:  ld      A,(HL)          ; Get LSB of number
4068+ 2D95 23                   inc     HL              ; Point to NMSB
4069+ 2D96 B7                   or      A               ; Test LSB
4070+ 2D97 CA C0 2D             jp      Z,BYTSFT        ; Zero - shift to next byte
4071+ 2D9A E5                   push    HL              ; Save address of number
4072+ 2D9B 2E 08                ld      L,$08           ; 8 bits to multiply by
4073+ 2D9D 1F           MUL8LP: rra                     ; Shift LSB right
4074+ 2D9E 67                   ld      H,A             ; Save LSB
4075+ 2D9F 79                   ld      A,C             ; Get MSB
4076+ 2DA0 D2 AE 2D             jp      NC,NOMADD       ; Bit was zero - Don't add
4077+ 2DA3 E5                   push    HL              ; Save LSB and count
4078+ 2DA4 2A 44 82             ld      HL,(MULVAL+1)   ; Get LSB and NMSB
4079+ 2DA7 19                   add     HL,DE           ; Add NMSB and LSB
4080+ 2DA8 EB                   ex      DE,HL           ; Leave sum in DE
4081+ 2DA9 E1                   pop     HL              ; Restore MSB and count
4082+ 2DAA 3A 43 82             ld      A,(MULVAL)      ; Get MSB of multiplier
4083+ 2DAD 89                   adc     A,C             ; Add MSB
4084+ 2DAE 1F           NOMADD: rra                     ; Shift MSB right
4085+ 2DAF 4F                   ld      C,A             ; Re-save MSB
4086+ 2DB0 7A                   ld      A,D             ; Get NMSB
4087+ 2DB1 1F                   rra                     ; Shift NMSB right
4088+ 2DB2 57                   ld      D,A             ; Re-save NMSB
4089+ 2DB3 7B                   ld      A,E             ; Get LSB
4090+ 2DB4 1F                   rra                     ; Shift LSB right
4091+ 2DB5 5F                   ld      E,A             ; Re-save LSB
4092+ 2DB6 78                   ld      A,B             ; Get VLSB
4093+ 2DB7 1F                   rra                     ; Shift VLSB right
4094+ 2DB8 47                   ld      B,A             ; Re-save VLSB
4095+ 2DB9 2D                   dec     L               ; Count bits multiplied
4096+ 2DBA 7C                   ld      A,H             ; Get LSB of multiplier
4097+ 2DBB C2 9D 2D             jp      NZ,MUL8LP       ; More - Do it
4098+ 2DBE E1           POPHRT: pop     HL              ; Restore address of number
4099+ 2DBF C9                   ret
4100+ 2DC0
4101+ 2DC0 43           BYTSFT: ld      B,E             ; Shift partial product left
4102+ 2DC1 5A                   ld      E,D
4103+ 2DC2 51                   ld      D,C
4104+ 2DC3 4F                   ld      C,A
4105+ 2DC4 C9                   ret
4106+ 2DC5
4107+ 2DC5
4108+ 2DC5              ; WORKING ââ
4109+ 2DC5 C1           DINT:   pop     BC              ; Get number from stack
4110+ 2DC6 D1                   pop     DE
4111+ 2DC7 CD 24 2E             call    DVBCDE          ; get BCDE/FPREG and store result into FPREG
4112+ 2DCA C3 A1 2F             jp      INT             ; return INT(FPREG)
4113+ 2DCD
4114+ 2DCD
4115+ 2DCD              ; A MODULO B - return remainder of the integer division A/B where:
4116+ 2DCD              ; A is in stack; B is in FPREG
4117+ 2DCD              ; math is:
4118+ 2DCD              ; A=INT(A); B=INT(B); R=A-(B*INT(A/B))
4119+ 2DCD CD A1 2F     MOD:    call    INT             ; B=INT(B)
4120+ 2DD0 CD 1A 2F             call    BCDEFP          ; copy B (from FPREG) into BCDE
4121+ 2DD3 ED 53 E1 81          ld      (TMPBFR3),DE    ; store B into...
4122+ 2DD7 ED 43 E3 81          ld      (TMPBFR4),BC    ; ...a temp buffer
4123+ 2DDB C1                   pop     BC              ; recover A...
4124+ 2DDC D1                   pop     DE              ; ...from stack
4125+ 2DDD CD 0F 2F             call    FPBCDE          ; store A into FPREG
4126+ 2DE0 CD A1 2F             call    INT             ; get integer part: A=INT(A)
4127+ 2DE3 CD 1A 2F             call    BCDEFP          ; copy A (from FPREG) into BCDE
4128+ 2DE6 ED 53 DD 81          ld      (TMPBFR1),DE    ; store A into...
4129+ 2DEA ED 43 DF 81          ld      (TMPBFR2),BC    ; ...a temp buffer
4130+ 2DEE                                              ; begin calculation
4131+ 2DEE 2A E1 81             ld      HL,(TMPBFR3)    ; move B...
4132+ 2DF1 22 31 82             ld      (FPREG),HL      ; ...from...
4133+ 2DF4 2A E3 81             ld      HL,(TMPBFR4)    ; ...temp buffer...
4134+ 2DF7 22 33 82             ld      (FPREG+2),HL    ; ...into FPREG
4135+ 2DFA CD 24 2E             call    DVBCDE          ; compute A/B and store into FPREG
4136+ 2DFD CD A1 2F             call    INT             ; get integer part of result: now FPREG = INT(A/B)
4137+ 2E00 ED 5B E1 81          ld      DE,(TMPBFR3)    ; load B...
4138+ 2E04 ED 4B E3 81          ld      BC,(TMPBFR4)    ; ...into BCDE
4139+ 2E08 CD 72 2D             call    FPMULT          ; get B*INT(A/B) and store into FPREG
4140+ 2E0B ED 5B DD 81          ld      DE,(TMPBFR1)    ; retrieve A from...
4141+ 2E0F ED 4B DF 81          ld      BC,(TMPBFR2)    ; ...temp buffer
4142+ 2E13 C3 34 2C             jp      SUBCDE          ; return result of A-(B*INT(A/B))
4143+ 2E16
4144+ 2E16
4145+ 2E16 CD FF 2E     DIV10:  call    STAKFP          ; Save FPREG on stack
4146+ 2E19 01 20 84             ld      BC,$8420        ; BCDE = 10.
4147+ 2E1C 11 00 00             ld      DE,$0000
4148+ 2E1F CD 0F 2F             call    FPBCDE          ; Move 10 to FPREG
4149+ 2E22
4150+ 2E22 C1           DIV:    pop     BC              ; Get number from stack
4151+ 2E23 D1                   pop     DE
4152+ 2E24 CD CE 2E     DVBCDE: call    TSTSGN          ; Test sign of FPREG
4153+ 2E27 CA F0 16             jp      Z,DZERR         ; Error if division by zero
4154+ 2E2A 2E FF                ld      L,-1            ; Flag subtract exponents
4155+ 2E2C CD 8C 2E             call    ADDEXP          ; Subtract exponents
4156+ 2E2F 34                   inc     (HL)            ; Add 2 to exponent to adjust
4157+ 2E30 34                   inc     (HL)
4158+ 2E31 2B                   dec     HL              ; Point to MSB
4159+ 2E32 7E                   ld      A,(HL)          ; Get MSB of dividend
4160+ 2E33 32 73 80             ld      (DIV3),A        ; Save for subtraction
4161+ 2E36 2B                   dec     HL
4162+ 2E37 7E                   ld      A,(HL)          ; Get NMSB of dividend
4163+ 2E38 32 6F 80             ld      (DIV2),A        ; Save for subtraction
4164+ 2E3B 2B                   dec     HL
4165+ 2E3C 7E                   ld      A,(HL)          ; Get MSB of dividend
4166+ 2E3D 32 6B 80             ld      (DIV1),A        ; Save for subtraction
4167+ 2E40 41                   ld      B,C             ; Get MSB
4168+ 2E41 EB                   ex      DE,HL           ; NMSB,LSB to HL
4169+ 2E42 AF                   xor     A
4170+ 2E43 4F                   ld      C,A             ; Clear MSB of quotient
4171+ 2E44 57                   ld      D,A             ; Clear NMSB of quotient
4172+ 2E45 5F                   ld      E,A             ; Clear LSB of quotient
4173+ 2E46 32 76 80             ld      (DIV4),A        ; Clear overflow count
4174+ 2E49 E5           DIVLP:  push    HL              ; Save divisor
4175+ 2E4A C5                   push    BC
4176+ 2E4B 7D                   ld      A,L             ; Get LSB of number
4177+ 2E4C CD 6A 80             call    DIVSUP          ; Subt' divisor from dividend
4178+ 2E4F DE 00                sbc     A,$00           ; Count for overflows
4179+ 2E51 3F                   ccf
4180+ 2E52 D2 5C 2E             jp      NC,RESDIV       ; Restore divisor if borrow
4181+ 2E55 32 76 80             ld      (DIV4),A        ; Re-save overflow count
4182+ 2E58 F1                   pop     AF              ; Scrap divisor
4183+ 2E59 F1                   pop     AF
4184+ 2E5A 37                   scf                     ; Set carry to
4185+ 2E5B D2                   defb    $D2             ; Skip "pop BC" and "pop HL"
4186+ 2E5C
4187+ 2E5C C1           RESDIV: pop     BC              ; Restore divisor
4188+ 2E5D E1                   pop     HL
4189+ 2E5E 79                   ld      A,C             ; Get MSB of quotient
4190+ 2E5F 3C                   inc     A
4191+ 2E60 3D                   dec     A
4192+ 2E61 1F                   rra                     ; Bit 0 to bit 7
4193+ 2E62 FA BE 2C             jp      M,RONDB         ; Done - Normalise result
4194+ 2E65 17                   rla                     ; Restore carry
4195+ 2E66 7B                   ld      A,E             ; Get LSB of quotient
4196+ 2E67 17                   rla                     ; Double it
4197+ 2E68 5F                   ld      E,A             ; Put it back
4198+ 2E69 7A                   ld      A,D             ; Get NMSB of quotient
4199+ 2E6A 17                   rla                     ; Double it
4200+ 2E6B 57                   ld      D,A             ; Put it back
4201+ 2E6C 79                   ld      A,C             ; Get MSB of quotient
4202+ 2E6D 17                   rla                     ; Double it
4203+ 2E6E 4F                   ld      C,A             ; Put it back
4204+ 2E6F 29                   add     HL,HL           ; Double NMSB,LSB of divisor
4205+ 2E70 78                   ld      A,B             ; Get MSB of divisor
4206+ 2E71 17                   rla                     ; Double it
4207+ 2E72 47                   ld      B,A             ; Put it back
4208+ 2E73 3A 76 80             ld      A,(DIV4)        ; Get VLSB of quotient
4209+ 2E76 17                   rla                     ; Double it
4210+ 2E77 32 76 80             ld      (DIV4),A        ; Put it back
4211+ 2E7A 79                   ld      A,C             ; Get MSB of quotient
4212+ 2E7B B2                   or      D               ; Merge NMSB
4213+ 2E7C B3                   or      E               ; Merge LSB
4214+ 2E7D C2 49 2E             jp      NZ,DIVLP        ; Not done - Keep dividing
4215+ 2E80 E5                   push    HL              ; Save divisor
4216+ 2E81 21 34 82             ld      HL,FPEXP        ; Point to exponent
4217+ 2E84 35                   dec     (HL)            ; Divide by 2
4218+ 2E85 E1                   pop     HL              ; Restore divisor
4219+ 2E86 C2 49 2E             jp      NZ,DIVLP        ; Ok - Keep going
4220+ 2E89 C3 FC 16             jp      OVERR           ; Overflow error
4221+ 2E8C
4222+ 2E8C
4223+ 2E8C 78           ADDEXP: ld      A,B             ; Get exponent of dividend
4224+ 2E8D B7                   or      A               ; Test it
4225+ 2E8E CA B0 2E             jp      Z,OVTST3        ; Zero - Result zero
4226+ 2E91 7D                   ld      A,L             ; Get add/subtract flag
4227+ 2E92 21 34 82             ld      HL,FPEXP        ; Point to exponent
4228+ 2E95 AE                   xor     (HL)            ; Add or subtract it
4229+ 2E96 80                   add     A,B             ; Add the other exponent
4230+ 2E97 47                   ld      B,A             ; Save new exponent
4231+ 2E98 1F                   rra                     ; Test exponent for overflow
4232+ 2E99 A8                   xor     B
4233+ 2E9A 78                   ld      A,B             ; Get exponent
4234+ 2E9B F2 AF 2E             jp      P,OVTST2        ; Positive - Test for overflow
4235+ 2E9E C6 80                add     A,$80           ; Add excess 128
4236+ 2EA0 77                   ld      (HL),A          ; Save new exponent
4237+ 2EA1 CA BE 2D             jp      Z,POPHRT        ; Zero - Result zero
4238+ 2EA4 CD 34 2F             call    SIGNS           ; Set MSBs and sign of result
4239+ 2EA7 77                   ld      (HL),A          ; Save new exponent
4240+ 2EA8 2B                   dec     HL              ; Point to MSB
4241+ 2EA9 C9                   ret
4242+ 2EAA
4243+ 2EAA CD CE 2E     OVTST1: call    TSTSGN          ; Test sign of FPREG
4244+ 2EAD 2F                   cpl                     ; Invert sign
4245+ 2EAE E1                   pop     HL              ; Clean up stack
4246+ 2EAF B7           OVTST2: or      A               ; Test if new exponent zero
4247+ 2EB0 E1           OVTST3: pop     HL              ; Clear off return address
4248+ 2EB1 F2 9D 2C             jp      P,RESZER        ; Result zero
4249+ 2EB4 C3 FC 16             jp      OVERR           ; Overflow error
4250+ 2EB7
4251+ 2EB7 CD 1A 2F     MLSP10: call    BCDEFP          ; Move FPREG to BCDE
4252+ 2EBA 78                   ld      A,B             ; Get exponent
4253+ 2EBB B7                   or      A               ; Is it zero?
4254+ 2EBC C8                   ret     Z               ; Yes - Result is zero
4255+ 2EBD C6 02                add     A,$02           ; Multiply by 4
4256+ 2EBF DA FC 16             jp      C,OVERR         ; Overflow - ?OV Error
4257+ 2EC2 47                   ld      B,A             ; Re-save exponent
4258+ 2EC3 CD 37 2C             call    FPADD           ; Add BCDE to FPREG (Times 5)
4259+ 2EC6 21 34 82             ld      HL,FPEXP        ; Point to exponent
4260+ 2EC9 34                   inc     (HL)            ; Double number (Times 10)
4261+ 2ECA C0                   ret     NZ              ; Ok - Return
4262+ 2ECB C3 FC 16             jp      OVERR           ; Overflow error
4263+ 2ECE
4264+ 2ECE 3A 34 82     TSTSGN: ld      A,(FPEXP)       ; Get sign of FPREG
4265+ 2ED1 B7                   or      A
4266+ 2ED2 C8                   ret     Z               ; RETurn if number is zero
4267+ 2ED3 3A 33 82             ld      A,(FPREG+2)     ; Get MSB of FPREG
4268+ 2ED6 FE                   defb    0FEH            ; Test sign
4269+ 2ED7 2F           RETREL: cpl                     ; Invert sign
4270+ 2ED8 17                   rla                     ; Sign bit to carry
4271+ 2ED9 9F           FLGDIF: sbc     A,A             ; Carry to all bits of A
4272+ 2EDA C0                   ret     NZ              ; Return -1 if negative
4273+ 2EDB 3C                   inc     A               ; Bump to +1
4274+ 2EDC C9                   ret                     ; Positive - Return +1
4275+ 2EDD
4276+ 2EDD CD CE 2E     SGN:    call    TSTSGN          ; Test sign of FPREG
4277+ 2EE0 06 88        FLGREL: ld      B,$80+8         ; 8 bit integer in exponent
4278+ 2EE2 11 00 00             ld      DE,0            ; Zero NMSB and LSB
4279+ 2EE5 21 34 82     RETINT: ld      HL,FPEXP        ; Point to exponent
4280+ 2EE8 4F                   ld      C,A             ; CDE = MSB,NMSB and LSB
4281+ 2EE9 70                   ld      (HL),B          ; Save exponent
4282+ 2EEA 06 00                ld      B,0             ; CDE = integer to normalise
4283+ 2EEC 23                   inc     HL              ; Point to sign of result
4284+ 2EED 36 80                ld      (HL),$80        ; Set sign of result
4285+ 2EEF 17                   rla                     ; Carry = sign of integer
4286+ 2EF0 C3 85 2C             jp      CONPOS          ; Set sign of result
4287+ 2EF3
4288+ 2EF3 CD CE 2E     ABS_:   call    TSTSGN          ; Test sign of FPREG
4289+ 2EF6 F0                   ret     P               ; Return if positive
4290+ 2EF7 21 33 82     INVSGN: ld      HL,FPREG+2      ; Point to MSB
4291+ 2EFA 7E                   ld      A,(HL)          ; Get sign of mantissa
4292+ 2EFB EE 80                xor     $80             ; Invert sign of mantissa
4293+ 2EFD 77                   ld      (HL),A          ; Re-save sign of mantissa
4294+ 2EFE C9                   ret
4295+ 2EFF
4296+ 2EFF EB           STAKFP: ex      DE,HL           ; Save code string address
4297+ 2F00 2A 31 82             ld      HL,(FPREG)      ; LSB,NLSB of FPREG
4298+ 2F03 E3                   ex      (SP),HL         ; Stack them,get return
4299+ 2F04 E5                   push    HL              ; Re-save return
4300+ 2F05 2A 33 82             ld      HL,(FPREG+2)    ; MSB and exponent of FPREG
4301+ 2F08 E3                   ex      (SP),HL         ; Stack them,get return
4302+ 2F09 E5                   push    HL              ; Re-save return
4303+ 2F0A EB                   ex      DE,HL           ; Restore code string address
4304+ 2F0B C9                   ret
4305+ 2F0C
4306+ 2F0C              ; store F.P. number from BCDE into (FPREG)
4307+ 2F0C CD 1D 2F     PHLTFP: call    LOADFP          ; Number at HL to BCDE
4308+ 2F0F EB           FPBCDE: ex      DE,HL           ; Save code string address
4309+ 2F10 22 31 82             ld      (FPREG),HL      ; Save LSB,NLSB of number
4310+ 2F13 60                   ld      H,B             ; Exponent of number
4311+ 2F14 69                   ld      L,C             ; MSB of number
4312+ 2F15 22 33 82             ld      (FPREG+2),HL    ; Save MSB and exponent
4313+ 2F18 EB                   ex      DE,HL           ; Restore code string address
4314+ 2F19 C9                   ret
4315+ 2F1A
4316+ 2F1A              ; load F.P. number from (FPREG) into BCDE
4317+ 2F1A 21 31 82     BCDEFP: ld      HL,FPREG        ; Point to FPREG
4318+ 2F1D 5E           LOADFP: ld      E,(HL)          ; Get LSB of number
4319+ 2F1E 23                   inc     HL
4320+ 2F1F 56                   ld      D,(HL)          ; Get NMSB of number
4321+ 2F20 23                   inc     HL
4322+ 2F21 4E                   ld      C,(HL)          ; Get MSB of number
4323+ 2F22 23                   inc     HL
4324+ 2F23 46                   ld      B,(HL)          ; Get exponent of number
4325+ 2F24 23           INCHL:  inc     HL              ; Used for conditional "inc HL"
4326+ 2F25 C9                   ret
4327+ 2F26
4328+ 2F26              ; move floating point from (FPREG) into (HL)
4329+ 2F26 11 31 82     FPTHL:  ld      DE,FPREG        ; Point to FPREG
4330+ 2F29 06 04        DETHL4: ld      B,$04           ; 4 bytes to move
4331+ 2F2B 1A           DETHLB: ld      A,(DE)          ; Get source
4332+ 2F2C 77                   ld      (HL),A          ; Save destination
4333+ 2F2D 13                   inc     DE              ; Next source
4334+ 2F2E 23                   inc     HL              ; Next destination
4335+ 2F2F 05                   dec     B               ; Count bytes
4336+ 2F30 C2 2B 2F             jp      NZ,DETHLB       ; Loop if more
4337+ 2F33 C9                   ret
4338+ 2F34
4339+ 2F34 21 33 82     SIGNS:  ld      HL,FPREG+2      ; Point to MSB of FPREG
4340+ 2F37 7E                   ld      A,(HL)          ; Get MSB
4341+ 2F38 07                   rlca                    ; Old sign to carry
4342+ 2F39 37                   scf                     ; Set MSBit
4343+ 2F3A 1F                   rra                     ; Set MSBit of MSB
4344+ 2F3B 77                   ld      (HL),A          ; Save new MSB
4345+ 2F3C 3F                   ccf                     ; Complement sign
4346+ 2F3D 1F                   rra                     ; Old sign to carry
4347+ 2F3E 23                   inc     HL
4348+ 2F3F 23                   inc     HL
4349+ 2F40 77                   ld      (HL),A          ; Set sign of result
4350+ 2F41 79                   ld      A,C             ; Get MSB
4351+ 2F42 07                   rlca                    ; Old sign to carry
4352+ 2F43 37                   scf                     ; Set MSBit
4353+ 2F44 1F                   rra                     ; Set MSBit of MSB
4354+ 2F45 4F                   ld      C,A             ; Save MSB
4355+ 2F46 1F                   rra
4356+ 2F47 AE                   xor     (HL)            ; New sign of result
4357+ 2F48 C9                   ret
4358+ 2F49
4359+ 2F49 78           CMPNUM: ld      A,B             ; Get exponent of number
4360+ 2F4A B7                   or      A
4361+ 2F4B CA CE 2E             jp      Z,TSTSGN        ; Zero - Test sign of FPREG
4362+ 2F4E 21 D7 2E             ld      HL,RETREL       ; Return relation routine
4363+ 2F51 E5                   push    HL              ; Save for return
4364+ 2F52 CD CE 2E             call    TSTSGN          ; Test sign of FPREG
4365+ 2F55 79                   ld      A,C             ; Get MSB of number
4366+ 2F56 C8                   ret     Z               ; FPREG zero - Number's MSB
4367+ 2F57 21 33 82             ld      HL,FPREG+2      ; MSB of FPREG
4368+ 2F5A AE                   xor     (HL)            ; Combine signs
4369+ 2F5B 79                   ld      A,C             ; Get MSB of number
4370+ 2F5C F8                   ret     M               ; Exit if signs different
4371+ 2F5D CD 63 2F             call    CMPFP           ; Compare FP numbers
4372+ 2F60 1F                   rra                     ; Get carry to sign
4373+ 2F61 A9                   xor     C               ; Combine with MSB of number
4374+ 2F62 C9                   ret
4375+ 2F63
4376+ 2F63 23           CMPFP:  inc     HL              ; Point to exponent
4377+ 2F64 78                   ld      A,B             ; Get exponent
4378+ 2F65 BE                   cp      (HL)            ; Compare exponents
4379+ 2F66 C0                   ret     NZ              ; Different
4380+ 2F67 2B                   dec     HL              ; Point to MBS
4381+ 2F68 79                   ld      A,C             ; Get MSB
4382+ 2F69 BE                   cp      (HL)            ; Compare MSBs
4383+ 2F6A C0                   ret     NZ              ; Different
4384+ 2F6B 2B                   dec     HL              ; Point to NMSB
4385+ 2F6C 7A                   ld      A,D             ; Get NMSB
4386+ 2F6D BE                   cp      (HL)            ; Compare NMSBs
4387+ 2F6E C0                   ret     NZ              ; Different
4388+ 2F6F 2B                   dec     HL              ; Point to LSB
4389+ 2F70 7B                   ld      A,E             ; Get LSB
4390+ 2F71 96                   sub     (HL)            ; Compare LSBs
4391+ 2F72 C0                   ret     NZ              ; Different
4392+ 2F73 E1                   pop     HL              ; Drop RETurn
4393+ 2F74 E1                   pop     HL              ; Drop another RETurn
4394+ 2F75 C9                   ret
4395+ 2F76
4396+ 2F76 47           FPINT:  ld      B,A             ; <- Move
4397+ 2F77 4F                   ld      C,A             ; <- exponent
4398+ 2F78 57                   ld      D,A             ; <- to all
4399+ 2F79 5F                   ld      E,A             ; <- bits
4400+ 2F7A B7                   or      A               ; Test exponent
4401+ 2F7B C8                   ret     Z               ; Zero - Return zero
4402+ 2F7C E5                   push    HL              ; Save pointer to number
4403+ 2F7D CD 1A 2F             call    BCDEFP          ; Move FPREG to BCDE
4404+ 2F80 CD 34 2F             call    SIGNS           ; Set MSBs & sign of result
4405+ 2F83 AE                   xor     (HL)            ; Combine with sign of FPREG
4406+ 2F84 67                   ld      H,A             ; Save combined signs
4407+ 2F85 FC 9A 2F             call    M,DCBCDE        ; Negative - Decrement BCDE
4408+ 2F88 3E 98                ld      A,$80+24        ; 24 bits
4409+ 2F8A 90                   sub     B               ; Bits to shift
4410+ 2F8B CD FC 2C             call    SCALE           ; Shift BCDE
4411+ 2F8E 7C                   ld      A,H             ; Get combined sign
4412+ 2F8F 17                   rla                     ; Sign to carry
4413+ 2F90 DC CF 2C             call    C,FPROND        ; Negative - Round number up
4414+ 2F93 06 00                ld      B,$00           ; Zero exponent
4415+ 2F95 DC E8 2C             call    C,COMPL         ; If negative make positive
4416+ 2F98 E1                   pop     HL              ; Restore pointer to number
4417+ 2F99 C9                   ret
4418+ 2F9A
4419+ 2F9A 1B           DCBCDE: dec     DE              ; Decrement BCDE
4420+ 2F9B 7A                   ld      A,D             ; Test LSBs
4421+ 2F9C A3                   and     E
4422+ 2F9D 3C                   inc     A
4423+ 2F9E C0                   ret     NZ              ; Exit if LSBs not FFFF
4424+ 2F9F 0B                   dec     BC              ; Decrement MSBs
4425+ 2FA0 C9                   ret
4426+ 2FA1
4427+ 2FA1 21 34 82     INT:    ld      HL,FPEXP        ; Point to exponent
4428+ 2FA4 7E                   ld      A,(HL)          ; Get exponent
4429+ 2FA5 FE 98                cp      $80+24          ; Integer accuracy only?
4430+ 2FA7 3A 31 82             ld      A,(FPREG)       ; Get LSB
4431+ 2FAA D0                   ret     NC              ; Yes - Already integer
4432+ 2FAB 7E                   ld      A,(HL)          ; Get exponent
4433+ 2FAC CD 76 2F             call    FPINT           ; F.P to integer
4434+ 2FAF 36 98                ld      (HL),$80+24     ; Save 24 bit integer
4435+ 2FB1 7B                   ld      A,E             ; Get LSB of number
4436+ 2FB2 F5                   push    AF              ; Save LSB
4437+ 2FB3 79                   ld      A,C             ; Get MSB of number
4438+ 2FB4 17                   rla                     ; Sign to carry
4439+ 2FB5 CD 85 2C             call    CONPOS          ; Set sign of result
4440+ 2FB8 F1                   pop     AF              ; Restore LSB of number
4441+ 2FB9 C9                   ret
4442+ 2FBA
4443+ 2FBA 21 00 00     MLDEBC: ld      HL,$0000        ; Clear partial product
4444+ 2FBD 78                   ld      A,B             ; Test multiplier
4445+ 2FBE B1                   or      C
4446+ 2FBF C8                   ret     Z               ; Return zero if zero
4447+ 2FC0 3E 10                ld      A,$10           ; 16 bits
4448+ 2FC2 29           MLDBLP: add     HL,HL           ; Shift P.P left
4449+ 2FC3 DA E8 23             jp      C,BSERR         ; ?BS Error if overflow
4450+ 2FC6 EB                   ex      DE,HL
4451+ 2FC7 29                   add     HL,HL           ; Shift multiplier left
4452+ 2FC8 EB                   ex      DE,HL
4453+ 2FC9 D2 D0 2F             jp      NC,NOMLAD       ; Bit was zero - No add
4454+ 2FCC 09                   add     HL,BC           ; Add multiplicand
4455+ 2FCD DA E8 23             jp      C,BSERR         ; ?BS Error if overflow
4456+ 2FD0 3D           NOMLAD: dec     A               ; Count bits
4457+ 2FD1 C2 C2 2F             jp      NZ,MLDBLP       ; More
4458+ 2FD4 C9                   ret
4459+ 2FD5
4460+ 2FD5 FE 2D        ASCTFP: cp      '-'             ; Negative?
4461+ 2FD7 F5                   push    AF              ; Save it and flags
4462+ 2FD8 CA E1 2F             jp      Z,CNVNUM        ; Yes - Convert number
4463+ 2FDB FE 2B                cp      '+'             ; Positive?
4464+ 2FDD CA E1 2F             jp      Z,CNVNUM        ; Yes - Convert number
4465+ 2FE0 2B                   dec     HL              ; dec 'cos GETCHR INCs
4466+ 2FE1 CD 9D 2C     CNVNUM: call    RESZER          ; Set result to zero
4467+ 2FE4 47                   ld      B,A             ; Digits after point counter
4468+ 2FE5 57                   ld      D,A             ; Sign of exponent
4469+ 2FE6 5F                   ld      E,A             ; Exponent of ten
4470+ 2FE7 2F                   cpl
4471+ 2FE8 4F                   ld      C,A             ; Before or after point flag
4472+ 2FE9 CD 30 1C     MANLP:  call    GETCHR          ; Get next character
4473+ 2FEC DA 32 30             jp      C,ADDIG         ; Digit - Add to number
4474+ 2FEF FE 2E                cp      '.'
4475+ 2FF1 CA 0D 30             jp      Z,DPOINT        ; '.' - Flag point
4476+ 2FF4 FE 45                cp      'E'
4477+ 2FF6 C2 11 30             jp      NZ,CONEXP       ; Not 'E' - Scale number
4478+ 2FF9 CD 30 1C             call    GETCHR          ; Get next character
4479+ 2FFC CD 04 22             call    SGNEXP          ; Get sign of exponent
4480+ 2FFF CD 30 1C     EXPLP:  call    GETCHR          ; Get next character
4481+ 3002 DA 54 30             jp      C,EDIGIT        ; Digit - Add to exponent
4482+ 3005 14                   inc     D               ; Is sign negative?
4483+ 3006 C2 11 30             jp      NZ,CONEXP       ; No - Scale number
4484+ 3009 AF                   xor     A
4485+ 300A 93                   sub     E               ; Negate exponent
4486+ 300B 5F                   ld      E,A             ; And re-save it
4487+ 300C 0C                   inc     C               ; Flag end of number
4488+ 300D 0C           DPOINT: inc     C               ; Flag point passed
4489+ 300E CA E9 2F             jp      Z,MANLP         ; Zero - Get another digit
4490+ 3011 E5           CONEXP: push    HL              ; Save code string address
4491+ 3012 7B                   ld      A,E             ; Get exponent
4492+ 3013 90                   sub     B               ; Subtract digits after point
4493+ 3014 F4 2A 30     SCALMI: call    P,SCALPL        ; Positive - Multiply number
4494+ 3017 F2 20 30             jp      P,ENDCON        ; Positive - All done
4495+ 301A F5                   push    AF              ; Save number of times to /10
4496+ 301B CD 16 2E             call    DIV10           ; Divide by 10
4497+ 301E F1                   pop     AF              ; Restore count
4498+ 301F 3C                   inc     A               ; Count divides
4499+ 3020
4500+ 3020 C2 14 30     ENDCON: jp      NZ,SCALMI       ; More to do
4501+ 3023 D1                   pop     DE              ; Restore code string address
4502+ 3024 F1                   pop     AF              ; Restore sign of number
4503+ 3025 CC F7 2E             call    Z,INVSGN        ; Negative - Negate number
4504+ 3028 EB                   ex      DE,HL           ; Code string address to HL
4505+ 3029 C9                   ret
4506+ 302A
4507+ 302A C8           SCALPL: ret     Z               ; Exit if no scaling needed
4508+ 302B F5           MULTEN: push    AF              ; Save count
4509+ 302C CD B7 2E             call    MLSP10          ; Multiply number by 10
4510+ 302F F1                   pop     AF              ; Restore count
4511+ 3030 3D                   dec     A               ; Count multiplies
4512+ 3031 C9                   ret
4513+ 3032
4514+ 3032 D5           ADDIG:  push    DE              ; Save sign of exponent
4515+ 3033 57                   ld      D,A             ; Save digit
4516+ 3034 78                   ld      A,B             ; Get digits after point
4517+ 3035 89                   adc     A,C             ; Add one if after point
4518+ 3036 47                   ld      B,A             ; Re-save counter
4519+ 3037 C5                   push    BC              ; Save point flags
4520+ 3038 E5                   push    HL              ; Save code string address
4521+ 3039 D5                   push    DE              ; Save digit
4522+ 303A CD B7 2E             call    MLSP10          ; Multiply number by 10
4523+ 303D F1                   pop     AF              ; Restore digit
4524+ 303E D6 30                sub     '0'             ; Make it absolute
4525+ 3040 CD 49 30             call    RSCALE          ; Re-scale number
4526+ 3043 E1                   pop     HL              ; Restore code string address
4527+ 3044 C1                   pop     BC              ; Restore point flags
4528+ 3045 D1                   pop     DE              ; Restore sign of exponent
4529+ 3046 C3 E9 2F             jp      MANLP           ; Get another digit
4530+ 3049
4531+ 3049 CD FF 2E     RSCALE: call    STAKFP          ; Put number on stack
4532+ 304C CD E0 2E             call    FLGREL          ; Digit to add to FPREG
4533+ 304F C1           PADD:   pop     BC              ; Restore number
4534+ 3050 D1                   pop     DE
4535+ 3051 C3 37 2C             jp      FPADD           ; Add BCDE to FPREG and return
4536+ 3054
4537+ 3054 7B           EDIGIT: ld      A,E             ; Get digit
4538+ 3055 07                   rlca                    ; Times 2
4539+ 3056 07                   rlca                    ; Times 4
4540+ 3057 83                   add     A,E             ; Times 5
4541+ 3058 07                   rlca                    ; Times 10
4542+ 3059 86                   add     A,(HL)          ; Add next digit
4543+ 305A D6 30                sub     '0'             ; Make it absolute
4544+ 305C 5F                   ld      E,A             ; Save new digit
4545+ 305D C3 FF 2F             jp      EXPLP           ; Look for another digit
4546+ 3060
4547+ 3060 E5           LINEIN: push    HL              ; Save code string address
4548+ 3061 21 66 16             ld      HL,INMSG        ; Output " in "
4549+ 3064 CD C9 25             call    PRS             ; Output string at HL
4550+ 3067 E1                   pop     HL              ; Restore code string address
4551+ 3068 EB           PRNTHL: ex      DE,HL           ; Code string address to DE
4552+ 3069 AF                   xor     A
4553+ 306A 06 98                ld      B,$80+24        ; 24 bits
4554+ 306C CD E5 2E             call    RETINT          ; Return the integer
4555+ 306F 21 C8 25             ld      HL,PRNUMS       ; Print number string
4556+ 3072 E5                   push    HL              ; Save for return
4557+ 3073 21 36 82     NUMASC: ld      HL,PBUFF        ; Convert number to ASCII
4558+ 3076 E5                   push    HL              ; Save for return
4559+ 3077 CD CE 2E             call    TSTSGN          ; Test sign of FPREG
4560+ 307A 36 20                ld      (HL),SPC        ; Space at start
4561+ 307C F2 81 30             jp      P,SPCFST        ; Positive - Space to start
4562+ 307F 36 2D                ld      (HL),'-'        ; '-' sign at start
4563+ 3081 23           SPCFST: inc     HL              ; First byte of number
4564+ 3082 36 30                ld      (HL),'0'        ; '0' if zero
4565+ 3084 CA 37 31             jp      Z,JSTZER        ; Return '0' if zero
4566+ 3087 E5                   push    HL              ; Save buffer address
4567+ 3088 FC F7 2E             call    M,INVSGN        ; Negate FPREG if negative
4568+ 308B AF                   xor     A               ; Zero A
4569+ 308C F5                   push    AF              ; Save it
4570+ 308D CD 3D 31             call    RNGTST          ; Test number is in range
4571+ 3090 01 43 91     SIXDIG: ld      BC,$9143        ; BCDE - 99999.9
4572+ 3093 11 F8 4F             ld      DE,$4FF8
4573+ 3096 CD 49 2F             call    CMPNUM          ; Compare numbers
4574+ 3099 B7                   or      A
4575+ 309A E2 AE 30             jp      PO,INRNG        ; > 99999.9 - Sort it out
4576+ 309D F1                   pop     AF              ; Restore count
4577+ 309E CD 2B 30             call    MULTEN          ; Multiply by ten
4578+ 30A1 F5                   push    AF              ; Re-save count
4579+ 30A2 C3 90 30             jp      SIXDIG          ; Test it again
4580+ 30A5
4581+ 30A5 CD 16 2E     GTSIXD: call    DIV10           ; Divide by 10
4582+ 30A8 F1                   pop     AF              ; Get count
4583+ 30A9 3C                   inc     A               ; Count divides
4584+ 30AA F5                   push    AF              ; Re-save count
4585+ 30AB CD 3D 31             call    RNGTST          ; Test number is in range
4586+ 30AE CD 25 2C     INRNG:  call    ROUND           ; Add 0.5 to FPREG
4587+ 30B1 3C                   inc     A
4588+ 30B2 CD 76 2F             call    FPINT           ; F.P to integer
4589+ 30B5 CD 0F 2F             call    FPBCDE          ; Move BCDE to FPREG
4590+ 30B8 01 06 03             ld      BC,$0306        ; 1E+06 to 1E-03 range
4591+ 30BB F1                   pop     AF              ; Restore count
4592+ 30BC 81                   add     A,C             ; 6 digits before point
4593+ 30BD 3C                   inc     A               ; Add one
4594+ 30BE FA CA 30             jp      M,MAKNUM        ; Do it in 'E' form if < 1E-02
4595+ 30C1 FE 08                cp      6+1+1           ; More than 999999 ?
4596+ 30C3 D2 CA 30             jp      NC,MAKNUM       ; Yes - Do it in 'E' form
4597+ 30C6 3C                   inc     A               ; Adjust for exponent
4598+ 30C7 47                   ld      B,A             ; Exponent of number
4599+ 30C8 3E 02                ld      A,2             ; Make it zero after
4600+ 30CA
4601+ 30CA 3D           MAKNUM: dec     A               ; Adjust for digits to do
4602+ 30CB 3D                   dec     A
4603+ 30CC E1                   pop     HL              ; Restore buffer address
4604+ 30CD F5                   push    AF              ; Save count
4605+ 30CE 11 50 31             ld      DE,POWERS       ; Powers of ten
4606+ 30D1 05                   dec     B               ; Count digits before point
4607+ 30D2 C2 DB 30             jp      NZ,DIGTXT       ; Not zero - Do number
4608+ 30D5 36 2E                ld      (HL),'.'        ; Save point
4609+ 30D7 23                   inc     HL              ; Move on
4610+ 30D8 36 30                ld      (HL),'0'        ; Save zero
4611+ 30DA 23                   inc     HL              ; Move on
4612+ 30DB 05           DIGTXT: dec     B               ; Count digits before point
4613+ 30DC 36 2E                ld      (HL),'.'        ; Save point in case
4614+ 30DE CC 24 2F             call    Z,INCHL         ; Last digit - move on
4615+ 30E1 C5                   push    BC              ; Save digits before point
4616+ 30E2 E5                   push    HL              ; Save buffer address
4617+ 30E3 D5                   push    DE              ; Save powers of ten
4618+ 30E4 CD 1A 2F             call    BCDEFP          ; Move FPREG to BCDE
4619+ 30E7 E1                   pop     HL              ; Powers of ten table
4620+ 30E8 06 2F                ld      B,'0'-1         ; ASCII '0' - 1
4621+ 30EA 04           TRYAGN: inc     B               ; Count subtractions
4622+ 30EB 7B                   ld      A,E             ; Get LSB
4623+ 30EC 96                   sub     (HL)            ; Subtract LSB
4624+ 30ED 5F                   ld      E,A             ; Save LSB
4625+ 30EE 23                   inc     HL
4626+ 30EF 7A                   ld      A,D             ; Get NMSB
4627+ 30F0 9E                   sbc     A,(HL)          ; Subtract NMSB
4628+ 30F1 57                   ld      D,A             ; Save NMSB
4629+ 30F2 23                   inc     HL
4630+ 30F3 79                   ld      A,C             ; Get MSB
4631+ 30F4 9E                   sbc     A,(HL)          ; Subtract MSB
4632+ 30F5 4F                   ld      C,A             ; Save MSB
4633+ 30F6 2B                   dec     HL              ; Point back to start
4634+ 30F7 2B                   dec     HL
4635+ 30F8 D2 EA 30             jp      NC,TRYAGN       ; No overflow - Try again
4636+ 30FB CD DC 2C             call    PLUCDE          ; Restore number
4637+ 30FE 23                   inc     HL              ; Start of next number
4638+ 30FF CD 0F 2F             call    FPBCDE          ; Move BCDE to FPREG
4639+ 3102 EB                   ex      DE,HL           ; Save point in table
4640+ 3103 E1                   pop     HL              ; Restore buffer address
4641+ 3104 70                   ld      (HL),B          ; Save digit in buffer
4642+ 3105 23                   inc     HL              ; And move on
4643+ 3106 C1                   pop     BC              ; Restore digit count
4644+ 3107 0D                   dec     C               ; Count digits
4645+ 3108 C2 DB 30             jp      NZ,DIGTXT       ; More - Do them
4646+ 310B 05                   dec     B               ; Any decimal part?
4647+ 310C CA 1B 31             jp      Z,DOEBIT        ; No - Do 'E' bit
4648+ 310F 2B           SUPTLZ: dec     HL              ; Move back through buffer
4649+ 3110 7E                   ld      A,(HL)          ; Get character
4650+ 3111 FE 30                cp      '0'             ; '0' character?
4651+ 3113 CA 0F 31             jp      Z,SUPTLZ        ; Yes - Look back for more
4652+ 3116 FE 2E                cp      '.'             ; A decimal point?
4653+ 3118 C4 24 2F             call    NZ,INCHL        ; Move back over digit
4654+ 311B
4655+ 311B F1           DOEBIT: pop     AF              ; Get 'E' flag
4656+ 311C CA 3A 31             jp      Z,NOENED        ; No 'E' needed - End buffer
4657+ 311F 36 45                ld      (HL),'E'        ; Put 'E' in buffer
4658+ 3121 23                   inc     HL              ; And move on
4659+ 3122 36 2B                ld      (HL),'+'        ; Put '+' in buffer
4660+ 3124 F2 2B 31             jp      P,OUTEXP        ; Positive - Output exponent
4661+ 3127 36 2D                ld      (HL),'-'        ; Put '-' in buffer
4662+ 3129 2F                   cpl                     ; Negate exponent
4663+ 312A 3C                   inc     A
4664+ 312B 06 2F        OUTEXP: ld      B,'0'-1         ; ASCII '0' - 1
4665+ 312D 04           EXPTEN: inc     B               ; Count subtractions
4666+ 312E D6 0A                sub     $0A             ; Tens digit
4667+ 3130 D2 2D 31             jp      NC,EXPTEN       ; More to do
4668+ 3133 C6 3A                add     A,'0'+10        ; Restore and make ASCII
4669+ 3135 23                   inc     HL              ; Move on
4670+ 3136 70                   ld      (HL),B          ; Save MSB of exponent
4671+ 3137 23           JSTZER: inc     HL              ;
4672+ 3138 77                   ld      (HL),A          ; Save LSB of exponent
4673+ 3139 23                   inc     HL
4674+ 313A 71           NOENED: ld      (HL),C          ; Mark end of buffer
4675+ 313B E1                   pop     HL              ; Restore code string address
4676+ 313C C9                   ret
4677+ 313D
4678+ 313D 01 74 94     RNGTST: ld      BC,$9474        ; BCDE = 999999.
4679+ 3140 11 F7 23             ld      DE,$23F7
4680+ 3143 CD 49 2F             call    CMPNUM          ; Compare numbers
4681+ 3146 B7                   or      A
4682+ 3147 E1                   pop     HL              ; Return address to HL
4683+ 3148 E2 A5 30             jp      PO,GTSIXD       ; Too big - Divide by ten
4684+ 314B E9                   jp      (HL)            ; Otherwise return to caller
4685+ 314C
4686+ 314C 00 00 00 80  HALF:   defb    $00,$00,$00,$80 ; 0.5
4687+ 3150
4688+ 3150 A0 86 01     POWERS: defb    $A0,$86,$01  ; 100000
4689+ 3153 10 27 00             defb    $10,$27,$00  ;  10000
4690+ 3156 E8 03 00             defb    $E8,$03,$00  ;   1000
4691+ 3159 64 00 00             defb    $64,$00,$00  ;    100
4692+ 315C 0A 00 00             defb    $0A,$00,$00  ;     10
4693+ 315F 01 00 00             defb    $01,$00,$00  ;      1
4694+ 3162
4695+ 3162 21 F7 2E     NEGAFT: ld      HL,INVSGN       ; Negate result
4696+ 3165 E3                   ex      (SP),HL         ; To be done after caller
4697+ 3166 E9                   jp      (HL)            ; Return to caller
4698+ 3167
4699+ 3167 CD FF 2E     SQR:    call    STAKFP          ; Put value on stack
4700+ 316A 21 4C 31             ld      HL,HALF         ; Set power to 1/2
4701+ 316D CD 0C 2F             call    PHLTFP          ; Move 1/2 to FPREG
4702+ 3170
4703+ 3170 C1           POWER:  pop     BC              ; Get base
4704+ 3171 D1                   pop     DE
4705+ 3172 CD CE 2E             call    TSTSGN          ; Test sign of power
4706+ 3175 78                   ld      A,B             ; Get exponent of base
4707+ 3176 CA B5 31             jp      Z,EXP           ; Make result 1 if zero
4708+ 3179 F2 80 31             jp      P,POWER1        ; Positive base - Ok
4709+ 317C B7                   or      A               ; Zero to negative power?
4710+ 317D CA F0 16             jp      Z,DZERR         ; Yes - ?/0 Error
4711+ 3180 B7           POWER1: or      A               ; Base zero?
4712+ 3181 CA 9E 2C             jp      Z,SAVEXP        ; Yes - Return zero
4713+ 3184 D5                   push    DE              ; Save base
4714+ 3185 C5                   push    BC
4715+ 3186 79                   ld      A,C             ; Get MSB of base
4716+ 3187 F6 7F                or      %01111111       ; Get sign status
4717+ 3189 CD 1A 2F             call    BCDEFP          ; Move power to BCDE
4718+ 318C F2 9D 31             jp      P,POWER2        ; Positive base - Ok
4719+ 318F D5                   push    DE              ; Save power
4720+ 3190 C5                   push    BC
4721+ 3191 CD A1 2F             call    INT             ; Get integer of power
4722+ 3194 C1                   pop     BC              ; Restore power
4723+ 3195 D1                   pop     DE
4724+ 3196 F5                   push    AF              ; MSB of base
4725+ 3197 CD 49 2F             call    CMPNUM          ; Power an integer?
4726+ 319A E1                   pop     HL              ; Restore MSB of base
4727+ 319B 7C                   ld      A,H             ; but don't affect flags
4728+ 319C 1F                   rra                     ; Exponent odd or even?
4729+ 319D E1           POWER2: pop     HL              ; Restore MSB and exponent
4730+ 319E 22 33 82             ld      (FPREG+2),HL    ; Save base in FPREG
4731+ 31A1 E1                   pop     HL              ; LSBs of base
4732+ 31A2 22 31 82             ld      (FPREG),HL      ; Save in FPREG
4733+ 31A5 DC 62 31             call    C,NEGAFT        ; Odd power - Negate result
4734+ 31A8 CC F7 2E             call    Z,INVSGN        ; Negative base - Negate it
4735+ 31AB D5                   push    DE              ; Save power
4736+ 31AC C5                   push    BC
4737+ 31AD CD 31 2D             call    LOG             ; Get LOG of base
4738+ 31B0 C1                   pop     BC              ; Restore power
4739+ 31B1 D1                   pop     DE
4740+ 31B2 CD 72 2D             call    FPMULT          ; Multiply LOG by power
4741+ 31B5
4742+ 31B5 CD FF 2E     EXP:    call    STAKFP          ; Put value on stack
4743+ 31B8 01 38 81             ld      BC,$8138        ; BCDE = 1/Ln(2)
4744+ 31BB 11 3B AA             ld      DE,$AA3B
4745+ 31BE CD 72 2D             call    FPMULT          ; Multiply value by 1/LN(2)
4746+ 31C1 3A 34 82             ld      A,(FPEXP)       ; Get exponent
4747+ 31C4 FE 88                cp      $80+8           ; Is it in range?
4748+ 31C6 D2 AA 2E             jp      NC,OVTST1       ; No - Test for overflow
4749+ 31C9 CD A1 2F             call    INT             ; Get INT of FPREG
4750+ 31CC C6 80                add     A,$80           ; For excess 128
4751+ 31CE C6 02                add     A,$02           ; Exponent > 126?
4752+ 31D0 DA AA 2E             jp      C,OVTST1        ; Yes - Test for overflow
4753+ 31D3 F5                   push    AF              ; Save scaling factor
4754+ 31D4 21 20 2D             ld      HL,UNITY        ; Point to 1.
4755+ 31D7 CD 28 2C             call    ADDPHL          ; Add 1 to FPREG
4756+ 31DA CD 69 2D             call    MULLN2          ; Multiply by LN(2)
4757+ 31DD F1                   pop     AF              ; Restore scaling factor
4758+ 31DE C1                   pop     BC              ; Restore exponent
4759+ 31DF D1                   pop     DE
4760+ 31E0 F5                   push    AF              ; Save scaling factor
4761+ 31E1 CD 34 2C             call    SUBCDE          ; Subtract exponent from FPREG
4762+ 31E4 CD F7 2E             call    INVSGN          ; Negate result
4763+ 31E7 21 F5 31             ld      HL,EXPTAB       ; Coefficient table
4764+ 31EA CD 25 32             call    SMSER1          ; Sum the series
4765+ 31ED 11 00 00             ld      DE,$0000        ; Zero LSBs
4766+ 31F0 C1                   pop     BC              ; Scaling factor
4767+ 31F1 4A                   ld      C,D             ; Zero MSB
4768+ 31F2 C3 72 2D             jp      FPMULT          ; Scale result to correct value
4769+ 31F5
4770+ 31F5 08           EXPTAB: defb    $08             ; Table used by EXP
4771+ 31F6 40 2E 94 74          defb    $40,$2E,$94,$74 ; -1/7! (-1/5040)
4772+ 31FA 70 4F 2E 77          defb    $70,$4F,$2E,$77 ;  1/6! ( 1/720)
4773+ 31FE 6E 02 88 7A          defb    $6E,$02,$88,$7A ; -1/5! (-1/120)
4774+ 3202 E6 A0 2A 7C          defb    $E6,$A0,$2A,$7C ;  1/4! ( 1/24)
4775+ 3206 50 AA AA 7E          defb    $50,$AA,$AA,$7E ; -1/3! (-1/6)
4776+ 320A FF FF 7F 7F          defb    $FF,$FF,$7F,$7F ;  1/2! ( 1/2)
4777+ 320E 00 00 80 81          defb    $00,$00,$80,$81 ; -1/1! (-1/1)
4778+ 3212 00 00 00 81          defb    $00,$00,$00,$81 ;  1/0! ( 1/1)
4779+ 3216
4780+ 3216 CD FF 2E     SUMSER: call    STAKFP          ; Put FPREG on stack
4781+ 3219 11 70 2D             ld      DE,MULT         ; Multiply by "X"
4782+ 321C D5                   push    DE              ; To be done after
4783+ 321D E5                   push    HL              ; Save address of table
4784+ 321E CD 1A 2F             call    BCDEFP          ; Move FPREG to BCDE
4785+ 3221 CD 72 2D             call    FPMULT          ; Square the value
4786+ 3224 E1                   pop     HL              ; Restore address of table
4787+ 3225 CD FF 2E     SMSER1: call    STAKFP          ; Put value on stack
4788+ 3228 7E                   ld      A,(HL)          ; Get number of coefficients
4789+ 3229 23                   inc     HL              ; Point to start of table
4790+ 322A CD 0C 2F             call    PHLTFP          ; Move coefficient to FPREG
4791+ 322D 06                   defb    06H             ; Skip "pop AF"
4792+ 322E F1           SUMLP:  pop     AF              ; Restore count
4793+ 322F C1                   pop     BC              ; Restore number
4794+ 3230 D1                   pop     DE
4795+ 3231 3D                   dec     A               ; Cont coefficients
4796+ 3232 C8                   ret     Z               ; All done
4797+ 3233 D5                   push    DE              ; Save number
4798+ 3234 C5                   push    BC
4799+ 3235 F5                   push    AF              ; Save count
4800+ 3236 E5                   push    HL              ; Save address in table
4801+ 3237 CD 72 2D             call    FPMULT          ; Multiply FPREG by BCDE
4802+ 323A E1                   pop     HL              ; Restore address in table
4803+ 323B CD 1D 2F             call    LOADFP          ; Number at HL to BCDE
4804+ 323E E5                   push    HL              ; Save address in table
4805+ 323F CD 37 2C             call    FPADD           ; Add coefficient to FPREG
4806+ 3242 E1                   pop     HL              ; Restore address in table
4807+ 3243 C3 2E 32             jp      SUMLP           ; More coefficients
4808+ 3246
4809+ 3246
4810+ 3246              ; random number generator
4811+ 3246              ; a negative argument is used as a seed for the RNG
4812+ 3246              ; 0 is used to repeat the last random number
4813+ 3246              ; a positive argument generates a new random number
4814+ 3246 CD CE 2E     RND:    call    TSTSGN          ; Test sign of FPREG
4815+ 3249 21 7A 80             ld      HL,SEED+2       ; Random number seed
4816+ 324C FA A7 32             jp      M,RESEED        ; Negative - Re-seed
4817+ 324F 21 9B 80             ld      HL,LSTRND       ; Last random number
4818+ 3252 CD 0C 2F             call    PHLTFP          ; Move last RND to FPREG
4819+ 3255 21 7A 80             ld      HL,SEED+2       ; Random number seed
4820+ 3258 C8                   ret     Z               ; Return if RND(0)
4821+ 3259 86                   add     A,(HL)          ; Add (SEED)+2)
4822+ 325A E6 07                and     %00000111       ; 0 to 7
4823+ 325C 06 00                ld      B,$00
4824+ 325E 77                   ld      (HL),A          ; Re-save seed
4825+ 325F 23                   inc     HL              ; Move to coefficient table
4826+ 3260 87                   add     A,A             ; 4 bytes
4827+ 3261 87                   add     A,A             ; per entry
4828+ 3262 4F                   ld      C,A             ; BC = Offset into table
4829+ 3263 09                   add     HL,BC           ; Point to coefficient
4830+ 3264 CD 1D 2F             call    LOADFP          ; Coefficient to BCDE
4831+ 3267 CD 72 2D             call    FPMULT  ;       ; Multiply FPREG by coefficient
4832+ 326A 3A 79 80             ld      A,(SEED+1)      ; Get (SEED+1)
4833+ 326D 3C                   inc     A               ; Add 1
4834+ 326E E6 03                and     %00000011       ; 0 to 3
4835+ 3270 06 00                ld      B,$00
4836+ 3272 FE 01                cp      $01             ; Is it zero?
4837+ 3274 88                   adc     A,B             ; Yes - Make it 1
4838+ 3275 32 79 80             ld      (SEED+1),A      ; Re-save seed
4839+ 3278 21 AB 32             ld      HL,RNDTAB-4     ; Addition table
4840+ 327B 87                   add     A,A             ; 4 bytes
4841+ 327C 87                   add     A,A             ; per entry
4842+ 327D 4F                   ld      C,A             ; BC = Offset into table
4843+ 327E 09                   add     HL,BC           ; Point to value
4844+ 327F CD 28 2C             call    ADDPHL          ; Add value to FPREG
4845+ 3282 CD 1A 2F     RND1:   call    BCDEFP          ; Move FPREG to BCDE
4846+ 3285 7B                   ld      A,E             ; Get LSB
4847+ 3286 59                   ld      E,C             ; LSB = MSB
4848+ 3287 EE 4F                xor     %01001111       ; Fiddle around
4849+ 3289 4F                   ld      C,A             ; New MSB
4850+ 328A 36 80                ld      (HL),$80        ; Set exponent
4851+ 328C 2B                   dec     HL              ; Point to MSB
4852+ 328D 46                   ld      B,(HL)          ; Get MSB
4853+ 328E 36 80                ld      (HL),$80        ; Make value -0.5
4854+ 3290 21 78 80             ld      HL,SEED         ; Random number seed
4855+ 3293 34                   inc     (HL)            ; Count seed
4856+ 3294 7E                   ld      A,(HL)          ; Get seed
4857+ 3295 D6 AB                sub     $AB             ; Do it modulo 171
4858+ 3297 C2 9E 32             jp      NZ,RND2         ; Non-zero - Ok
4859+ 329A 77                   ld      (HL),A          ; Zero seed
4860+ 329B 0C                   inc     C               ; Fillde about
4861+ 329C 15                   dec     D               ; with the
4862+ 329D 1C                   inc     E               ; number
4863+ 329E CD 88 2C     RND2:   call    BNORM           ; Normalise number
4864+ 32A1 21 9B 80             ld      HL,LSTRND       ; Save random number
4865+ 32A4 C3 26 2F             jp      FPTHL           ; Move FPREG to last and return
4866+ 32A7
4867+ 32A7 77           RESEED: ld      (HL),A          ; Re-seed random numbers
4868+ 32A8 2B                   dec     HL
4869+ 32A9 77                   ld      (HL),A
4870+ 32AA 2B                   dec     HL
4871+ 32AB 77                   ld      (HL),A
4872+ 32AC C3 82 32             jp      RND1            ; Return RND seed
4873+ 32AF
4874+ 32AF 68 B1 46 68  RNDTAB: defb    $68,$B1,$46,$68 ; Table used by RND
4875+ 32B3 99 E9 92 69          defb    $99,$E9,$92,$69
4876+ 32B7 10 D1 75 68          defb    $10,$D1,$75,$68
4877+ 32BB
4878+ 32BB              ; COS and SIN functions
4879+ 32BB 21 05 33     COS:    ld      HL,HALFPI       ; Point to PI/2
4880+ 32BE CD 28 2C             call    ADDPHL          ; Add it to PPREG
4881+ 32C1 CD FF 2E     SIN:    call    STAKFP          ; Put angle on stack
4882+ 32C4 01 49 83             ld      BC,$8349        ; BCDE = 2 PI
4883+ 32C7 11 DB 0F             ld      DE,$0FDB
4884+ 32CA CD 0F 2F             call    FPBCDE          ; Move 2 PI to FPREG
4885+ 32CD C1                   pop     BC              ; Restore angle
4886+ 32CE D1                   pop     DE
4887+ 32CF CD 24 2E             call    DVBCDE          ; Divide angle by 2 PI
4888+ 32D2 CD FF 2E             call    STAKFP          ; Put it on stack
4889+ 32D5 CD A1 2F             call    INT             ; Get INT of result
4890+ 32D8 C1                   pop     BC              ; Restore number
4891+ 32D9 D1                   pop     DE
4892+ 32DA CD 34 2C             call    SUBCDE          ; Make it 0 <= value < 1
4893+ 32DD 21 09 33             ld      HL,QUARTR       ; Point to 0.25
4894+ 32E0 CD 2E 2C             call    SUBPHL          ; Subtract value from 0.25
4895+ 32E3 CD CE 2E             call    TSTSGN          ; Test sign of value
4896+ 32E6 37                   scf                     ; Flag positive
4897+ 32E7 F2 F1 32             jp      P,SIN1          ; Positive - Ok
4898+ 32EA CD 25 2C             call    ROUND           ; Add 0.5 to value
4899+ 32ED CD CE 2E             call    TSTSGN          ; Test sign of value
4900+ 32F0 B7                   or      A               ; Flag negative
4901+ 32F1 F5           SIN1:   push    AF              ; Save sign
4902+ 32F2 F4 F7 2E             call    P,INVSGN        ; Negate value if positive
4903+ 32F5 21 09 33             ld      HL,QUARTR       ; Point to 0.25
4904+ 32F8 CD 28 2C             call    ADDPHL          ; Add 0.25 to value
4905+ 32FB F1                   pop     AF              ; Restore sign
4906+ 32FC D4 F7 2E             call    NC,INVSGN       ; Negative - Make positive
4907+ 32FF 21 0D 33             ld      HL,SINTAB       ; Coefficient table
4908+ 3302 C3 16 32             jp      SUMSER          ; Evaluate sum of series
4909+ 3305
4910+ 3305 DB 0F 49 81  HALFPI: defb    $DB,$0F,$49,$81 ; 1.5708 (PI/2)
4911+ 3309
4912+ 3309 00 00 00 7F  QUARTR: defb    $00,$00,$00,$7F ; 0.25
4913+ 330D
4914+ 330D 05           SINTAB: defb    $05             ; Table used by SIN
4915+ 330E BA D7 1E 86          defb    $BA,$D7,$1E,$86 ; 39.711
4916+ 3312 64 26 99 87          defb    $64,$26,$99,$87 ;-76.575
4917+ 3316 58 34 23 87          defb    $58,$34,$23,$87 ; 81.602
4918+ 331A E0 5D A5 86          defb    $E0,$5D,$A5,$86 ;-41.342
4919+ 331E DA 0F 49 83          defb    $DA,$0F,$49,$83 ;  6.2832
4920+ 3322
4921+ 3322 CD FF 2E     TAN:    call    STAKFP          ; Put angle on stack
4922+ 3325 CD C1 32             call    SIN             ; Get SIN of angle
4923+ 3328 C1                   pop     BC              ; Restore angle
4924+ 3329 E1                   pop     HL
4925+ 332A CD FF 2E             call    STAKFP          ; Save SIN of angle
4926+ 332D EB                   ex      DE,HL           ; BCDE = Angle
4927+ 332E CD 0F 2F             call    FPBCDE          ; Angle to FPREG
4928+ 3331 CD BB 32             call    COS             ; Get COS of angle
4929+ 3334 C3 22 2E             jp      DIV             ; TAN = SIN / COS
4930+ 3337
4931+ 3337 CD CE 2E     ATN:    call    TSTSGN          ; Test sign of value
4932+ 333A FC 62 31             call    M,NEGAFT        ; Negate result after if -ve
4933+ 333D FC F7 2E             call    M,INVSGN        ; Negate value if -ve
4934+ 3340 3A 34 82             ld      A,(FPEXP)       ; Get exponent
4935+ 3343 FE 81                cp      81H             ; Number less than 1?
4936+ 3345 DA 54 33             jp      C,ATN1          ; Yes - Get arc tangnt
4937+ 3348 01 00 81             ld      BC,$8100        ; BCDE = 1
4938+ 334B 51                   ld      D,C
4939+ 334C 59                   ld      E,C
4940+ 334D CD 24 2E             call    DVBCDE          ; Get reciprocal of number
4941+ 3350 21 2E 2C             ld      HL,SUBPHL       ; Sub angle from PI/2
4942+ 3353 E5                   push    HL              ; Save for angle > 1
4943+ 3354 21 5E 33     ATN1:   ld      HL,ATNTAB       ; Coefficient table
4944+ 3357 CD 16 32             call    SUMSER          ; Evaluate sum of series
4945+ 335A 21 05 33             ld      HL,HALFPI       ; PI/2 - angle in case > 1
4946+ 335D C9                   ret                     ; Number > 1 - Sub from PI/2
4947+ 335E
4948+ 335E 09           ATNTAB: defb    $09             ; Table used by ATN
4949+ 335F 4A D7 3B 78          defb    $4A,$D7,$3B,$78 ; 1/17
4950+ 3363 02 6E 84 7B          defb    $02,$6E,$84,$7B ;-1/15
4951+ 3367 FE C1 2F 7C          defb    $FE,$C1,$2F,$7C ; 1/13
4952+ 336B 74 31 9A 7D          defb    $74,$31,$9A,$7D ;-1/11
4953+ 336F 84 3D 5A 7D          defb    $84,$3D,$5A,$7D ; 1/9
4954+ 3373 C8 7F 91 7E          defb    $C8,$7F,$91,$7E ;-1/7
4955+ 3377 E4 BB 4C 7E          defb    $E4,$BB,$4C,$7E ; 1/5
4956+ 337B 6C AA AA 7F          defb    $6C,$AA,$AA,$7F ;-1/3
4957+ 337F 00 00 00 81          defb    $00,$00,$00,$81 ; 1/1
4958+ 3383
4959+ 3383
4960+ 3383 C9           ARET:   ret                     ; A RETurn instruction
4961+ 3384
4962+ 3384 D7           GETINP: rst     $10             ; input a character
4963+ 3385 C9                   ret
4964+ 3386
4965+ 3386 E5           CLS:    push    HL
4966+ 3387 D5                   push    DE
4967+ 3388 3A CF 81             ld      A,(SCR_MODE)    ; check screen mode
4968+ 338B FE 02                cp      $02             ; G2 mode?
4969+ 338D CC E9 05             call    Z,EMPTYVIDBUF   ; yes, reset video buffer
4970+ 3390 D1                   pop     DE
4971+ 3391 E1                   pop     HL
4972+ 3392 3E 0C                ld      A,CS            ; ASCII Clear screen
4973+ 3394 CD 25 1A             call    SND2VID         ; send to screen
4974+ 3397 C3 DD 3F             jp      MONOUT          ; Output character
4975+ 339A
4976+ 339A CD 47 29     WIDTH:  call    GETINT          ; Get integer 0-255
4977+ 339D 7B                   ld      A,E             ; Width to A
4978+ 339E 32 A2 80             ld      (LWIDTH),A      ; Set width
4979+ 33A1 C9                   ret
4980+ 33A2
4981+ 33A2
4982+ 33A2              ; read a word (2 bytes) from a couple of RAM locations, in little-endian format
4983+ 33A2              ; i.e., the first location is the LSB, while the second one is the MSB
4984+ 33A2 CD E6 1C     DEEK:   call    DEINT           ; Get integer -32768 to 32767
4985+ 33A5 D5                   push    DE              ; Save number
4986+ 33A6 E1                   pop     HL              ; Number to HL
4987+ 33A7 46           RECWRD: ld      B,(HL)          ; Get LSB of contents
4988+ 33A8 23                   inc     HL
4989+ 33A9 7E                   ld      A,(HL)          ; Get MSB of contents
4990+ 33AA C3 AB 24             jp      ABPASS          ; Return integer AB
4991+ 33AD
4992+ 33AD              ; write a word (2 bytes) into a couple of RAM locations, in little-endian format
4993+ 33AD              ; i.e., the LSB will go into the first location, while the MSB into the second one
4994+ 33AD CD C1 20     DOKE:   call    GETNUM          ; Get a number
4995+ 33B0 CD E6 1C             call    DEINT           ; Get integer -32768 to 32767
4996+ 33B3 D5                   push    DE              ; Save address
4997+ 33B4 CD E7 19             call    CHKSYN          ; Make sure ',' follows
4998+ 33B7 2C                   defb    ','
4999+ 33B8 CD C1 20             call    GETNUM          ; Get a number
5000+ 33BB CD E6 1C             call    DEINT           ; Get integer -32768 to 32767
5001+ 33BE E3                   ex      (SP),HL         ; Save value,get address
5002+ 33BF 73                   ld      (HL),E          ; Save LSB of value
5003+ 33C0 23                   inc     HL
5004+ 33C1 72                   ld      (HL),D          ; Save MSB of value
5005+ 33C2 E1                   pop     HL              ; Restore code string address
5006+ 33C3 C9                   ret
5007+ 33C4
5008+ 33C4              ; stop the execution of code for a certain bit of time. The pause
5009+ 33C4              ; is between $0000 and $FFFF 100ths of a second (0~655.5 secs)
5010+ 33C4 CD C1 20     PAUSE:  call    GETNUM          ; Get a number
5011+ 33C7 CD E6 1C             call    DEINT           ; Get integer -32768 to 32767
5012+ 33CA 7A                   ld      A,D             ; load D into A
5013+ 33CB B3                   or      E               ; are D & E equal to $00?
5014+ 33CC C8                   ret     Z               ; if yes, then return
5015+ 33CD C5           DIR_PAU:push    BC              ; store BC
5016+ 33CE 3A BD 81             ld      A,(TMRCNT)      ; Load current value of system timer
5017+ 33D1 47                   ld      B,A             ; move it into B
5018+ 33D2 CD 5B 1C     RPTPS:  call    TSTBRK          ; Test for break key
5019+ 33D5 3A BD 81             ld      A,(TMRCNT)      ; Load current value of system timer
5020+ 33D8 B8                   cp      B               ; is it the same value?
5021+ 33D9 28 F7                jr      Z,RPTPS         ; yes, so read again
5022+ 33DB 47                   ld      B,A             ; no, so store the new value
5023+ 33DC 1B                   dec     DE              ; decrement interval
5024+ 33DD 7A                   ld      A,D             ; load D into A
5025+ 33DE B3                   or      E               ; check if DE is equal to 0 (if D & e are $00 then result is 0)
5026+ 33DF 20 F1                jr      NZ,RPTPS        ; no, repeat
5027+ 33E1 C1                   pop     BC              ; yes, recover BC and continue
5028+ 33E2 C9                   ret
5029+ 33E3
5030+ 33E3              ; change the screen mode and set some graphic features. Usage: SCREEN X[,Y][,Z]
5031+ 33E3              ; where X is graphic mode:
5032+ 33E3              ; 0=text mode (40x24), 1=graphic mode 1 (32x24 chars); 2=graphic mode 2 (256x192 pixels);
5033+ 33E3              ; 3=multicolor mode (64x48 pixels); 4=extended graphic mode 2 (32x24 chars mixed between G1 and G2)
5034+ 33E3              ; Y is: 0=8x8 sprites, 1=16x16 sprites
5035+ 33E3              ; Z is: 0=no sprite magnification; 1=sprite magnification x2 (8x8=>16x16, and 16x16=32x32)
5036+ 33E3              ; (the latters are accepted only in graphic modes G1, G2, G3, and G4)
5037+ 33E3 AF           SCREEN: xor     A
5038+ 33E4 32 DF 81             ld      (TMPBFR2),A     ; sprite size & magnif. byte set to 0
5039+ 33E7 CD 47 29             call    GETINT          ; Get integer 0-255
5040+ 33EA FE 05                cp      $05             ; is it a valid mode (0~4)?
5041+ 33EC D2 FB 1C             jp      NC,FCERR        ; No - Illegal function call Error
5042+ 33EF 32 DD 81             ld      (TMPBFR1),A     ; store graphic mode
5043+ 33F2 A7                   and     A               ; is it 0 (text mode)?
5044+ 33F3 CA 0F 34             jp      Z,SCVDP         ; yes, ignore other arguments and set mode immediately
5045+ 33F6 CD 4E 34     SETVDP: call    CHKSCAR         ; no, check if sprite size follows
5046+ 33F9 DA 01 34             jp      C,CKMAGN        ; no (set to 0 or missing), so jump over
5047+ 33FC 3E 02                ld      A,$02           ; no, so set sprite size
5048+ 33FE 32 DF 81             ld      (TMPBFR2),A     ; ...to 16x16
5049+ 3401 CD 4E 34     CKMAGN: call    CHKSCAR         ; check if sprite magnification follows
5050+ 3404 DA 0F 34             jp      C,SCVDP         ; no (set to 0 or missing), so jump over
5051+ 3407 3A DF 81             ld      A,(TMPBFR2)     ; yes, so retrieve sprite attributes...
5052+ 340A F6 01                or      $01             ; ...set sprite magnification to 2x...
5053+ 340C 32 DF 81             ld      (TMPBFR2),A     ; ...and save flags again
5054+ 340F F3           SCVDP:  di                      ; disable INTs
5055+ 3410 D5                   push    DE              ; store DE
5056+ 3411 E5                   push    HL              ; store HL
5057+ 3412 3A DD 81             ld      A,(TMPBFR1)     ; recover graphic mode
5058+ 3415 5F                   ld      E,A             ; and store it into E
5059+ 3416 3A DF 81             ld      A,(TMPBFR2)     ; recover sprite flags
5060+ 3419 57                   ld      D,A             ; and store them into D
5061+ 341A D5                   push    DE              ; store D & E
5062+ 341B CD ED 03             call    initVDP         ; initialize VDP with mode pointed by E
5063+ 341E D1                   pop     DE              ; retrieve D & E
5064+ 341F 7B                   ld      A,E             ; move graphic mode into A
5065+ 3420 87                   add     A,A
5066+ 3421 87                   add     A,A
5067+ 3422 87                   add     A,A             ; multiply A times 8 to get offset of graphic mode
5068+ 3423 5F                   ld      E,A             ; and pass it into E
5069+ 3424 D5                   push    DE              ; store sprite flags in E
5070+ 3425 16 00                ld      D,$00           ; reset D
5071+ 3427 21 38 0B             ld      HL,VDPMODESET+1 ; load address of VDP settings for reg#1
5072+ 342A 19                   add     HL,DE           ; load correct reg#1 setting
5073+ 342B D1                   pop     DE              ; retrieve sprite flags from E
5074+ 342C 7E                   ld      A,(HL)          ; load reg#1 setting
5075+ 342D E6 FC                and     %11111100       ; reset size & magn. bits
5076+ 342F B2                   or      D               ; set size & magn. bits
5077+ 3430 5F                   ld      E,A             ; value into E
5078+ 3431 3E 01                ld      A,$01           ; reg #1
5079+ 3433 CD C5 06             call    WRITE_VREG      ; send setting to reg #1
5080+ 3436 2A AF 80             ld      HL,(LINEAT)     ; Get current line number
5081+ 3439 23                   inc     HL              ; -1 means direct statement
5082+ 343A 7C                   ld      A,H
5083+ 343B B5                   or      L
5084+ 343C CC 38 09             call    Z,CURSOR_ON     ; enable cursor if not in program mode
5085+ 343F FB                   ei                      ; re-enable interrupts
5086+ 3440 E1                   pop     HL              ; restore HL
5087+ 3441 D1                   pop     DE              ; restore DE
5088+ 3442 3A CE 81             ld      A,(SCR_SIZE_H)  ; check the screen mode by looking at the screen height
5089+ 3445 FE 30                cp      $30             ; is it 48 chars or 192 pixels (MC and G2 modes)?
5090+ 3447 D0                   ret     NC              ; yes, so exit (in graphics 2 and multicolor no print-on-video)
5091+ 3448 3E 01                ld      A,$01           ; no (we are in Text, G1 or ExG2), so activate the...
5092+ 344A 32 D9 81             ld      (PRNTVIDEO),A   ; ...video buffer...
5093+ 344D C9                   ret                     ; ...and return to caller
5094+ 344E
5095+ 344E              ; check an additional argument for SCREEN - There are 2 ways of working:
5096+ 344E              ; to check if something follows: Carry is 1 is no argument follows, 0 otherwise
5097+ 344E              ; to check the value of the following argument: 0 is argument is 1, 1 is argument is <> 1
5098+ 344E 2B           CHKSCAR:dec     HL              ; dec 'cos GETCHR INCs
5099+ 344F CD 30 1C             call    GETCHR          ; Get next character
5100+ 3452 37                   scf                     ; set carry flag
5101+ 3453 C8                   ret     Z               ; return if nothing follows with Carry=1
5102+ 3454 CD E7 19             call    CHKSYN          ; Make sure ',' follows
5103+ 3457 2C                   defb    ','
5104+ 3458 CD 47 29             call    GETINT          ; get value
5105+ 345B 1F                   rra                     ; Carry=bit #0
5106+ 345C 3F                   ccf                     ; invert Carry, so Carry=0 if arg. is 1, and Carry=1 otherwise (arg<>1)
5107+ 345D C9                   ret                     ; return
5108+ 345E
5109+ 345E
5110+ 345E              ; change the colors of the screen - Syntax is COLOR a,b,c where:
5111+ 345E              ; a=foreground color / b=background color / c=border color
5112+ 345E              ; a,b,c must be in a range between 1 and 15 (0 is transparent and it's not supported)
5113+ 345E              ; the number of arguments is based on the current screen mode
5114+ 345E CD 47 29     COLOR:  call    GETINT          ; get first value
5115+ 3461 CD 07 35             call    CHKCLR1         ; check if it's in range 1~15
5116+ 3464 32 DD 81             ld      (TMPBFR1),A     ; store it
5117+ 3467 3A CF 81             ld      A,(SCR_MODE)    ; check screen mode
5118+ 346A FE 03                cp      $03             ; is it multicolor mode?
5119+ 346C 20 0D                jr      NZ,CNTCKCL      ; no, continue
5120+ 346E 3E 0F                ld      A,$0F           ; white for...
5121+ 3470 32 DB 81             ld      (FRGNDCLR),A    ; ...foreground (even it's not used in MC)
5122+ 3473 3A DD 81             ld      A,(TMPBFR1)     ; yes, so we stop here because in MC mode we just support border color
5123+ 3476 32 E1 81             ld      (TMPBFR3),A     ; move color into temp buffer 3
5124+ 3479 18 31                jr      CLRMC           ; jump to set color
5125+ 347B CD E7 19     CNTCKCL:call    CHKSYN          ; Make sure ',' follows
5126+ 347E 2C                   defb    ','
5127+ 347F CD 47 29             call    GETINT          ; get second value
5128+ 3482 CD 07 35             call    CHKCLR1         ; check if it's in range 1~15
5129+ 3485 32 DF 81             ld      (TMPBFR2),A     ; store it
5130+ 3488 3A CF 81             ld      A,(SCR_MODE)    ; check screen mode
5131+ 348B A7                   and     A               ; is it text mode?
5132+ 348C 28 1B                jr      Z,CLRTXT        ; yes, stop here because in text mode, background and border colors coincide
5133+ 348E CD E7 19             call    CHKSYN          ; Make sure ',' follows
5134+ 3491 2C                   defb    ','
5135+ 3492 CD 47 29             call    GETINT          ; get third value
5136+ 3495 CD 07 35             call    CHKCLR1         ; check if it's in range 1~15
5137+ 3498 32 E1 81             ld      (TMPBFR3),A     ; store it
5138+ 349B D5                   push    DE              ; store DE
5139+ 349C 3A CF 81             ld      A,(SCR_MODE)    ; check screen mode
5140+ 349F FE 01                cp      $01             ; is it G1 mode?
5141+ 34A1 28 10                jr      Z,CLRG1         ; yes, jump over
5142+ 34A3 FE 02                cp      $02             ; is it G2 mode?
5143+ 34A5 28 15                jr      Z,CLRG2         ; yes, jump over
5144+ 34A7 18 1C                jr      CLREX2          ; last case can only be ExG2
5145+ 34A9 CD FA 34     CLRTXT: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5146+ 34AC 32 E1 81     CLRMC:  ld      (TMPBFR3),A     ; store color settings (for MC mode, we only set border color)
5147+ 34AF D5                   push    DE              ; store DE
5148+ 34B0 F3                   di                      ; disable INTs
5149+ 34B1 18 2E                jr      SETBRCL         ; set colors and exit
5150+ 34B3 CD FA 34     CLRG1:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5151+ 34B6 16 01                ld      D,$01           ; repeat 1 time
5152+ 34B8 06 20                ld      B,$20           ; 32 bytes of colors
5153+ 34BA 18 10                jr      LOADCLR         ; load colors
5154+ 34BC CD FA 34     CLRG2:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5155+ 34BF 16 18                ld      D,$18           ; 18 pages of...
5156+ 34C1 06 00                ld      B,$00           ; ...256 bytes each
5157+ 34C3 18 07                jr      LOADCLR         ; load colors
5158+ 34C5 CD FA 34     CLREX2: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5159+ 34C8 16 08                ld      D,$08           ; 8 pages of...
5160+ 34CA 06 00                ld      B,$00           ; ...256 bytes each
5161+ 34CC E5           LOADCLR:push    HL              ; store HL
5162+ 34CD 21 00 20             ld      HL,$2000        ; color table start: $2000
5163+ 34D0 F3                   di                      ; disable INTs
5164+ 34D1 CD 7B 06             call    SETVDPADRS
5165+ 34D4 0E 30                ld      C,VDP_DAT              ; VDP data mode
5166+ 34D6 ED 79        RPTLDCL:out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
5167+ 34D8 00                   nop
5168+ 34D9 00                   nop
5169+ 34DA 10 FA                djnz    RPTLDCL         ; repeat for 256 bytes (1 page)
5170+ 34DC 15                   dec     D               ; did we fill up all the pages?
5171+ 34DD 20 F7                jr      NZ,RPTLDCL      ; no, repeat
5172+ 34DF FB                   ei
5173+ 34E0 E1                   pop     HL              ; retrieve HL
5174+ 34E1 3A DD 81     SETBRCL:ld      A,(TMPBFR1)     ; retrieve foreground color
5175+ 34E4 32 DB 81             ld      (FRGNDCLR),A    ; store it
5176+ 34E7 3A DF 81             ld      A,(TMPBFR2)     ; retrieve background color
5177+ 34EA 32 DC 81             ld      (BKGNDCLR),A    ; store it
5178+ 34ED 3A E1 81             ld      A,(TMPBFR3)     ; recover border color
5179+ 34F0 5F                   ld      E,A             ; move it into E
5180+ 34F1 3E 07                ld      A,$07           ; set VDP register 7
5181+ 34F3 F3                   di
5182+ 34F4 CD C5 06             call    WRITE_VREG      ; send value to VDP: set border color
5183+ 34F7 FB                   ei                      ; re-enable INTs
5184+ 34F8 D1                   pop     DE              ; retrieve DE
5185+ 34F9 C9                   ret                     ; return to caller
5186+ 34FA
5187+ 34FA
5188+ 34FA              ; mix 2 color nibbles in 1 byte
5189+ 34FA 3A DF 81     MIXCLRS:ld      A,(TMPBFR2)     ; retrieve background color
5190+ 34FD 47                   ld      B,A             ; move it into B
5191+ 34FE 3A DD 81             ld      A,(TMPBFR1)     ; retrieve foreground color
5192+ 3501 87                   add     A,A             ; move foreground color into the high nibble of A
5193+ 3502 87                   add     A,A
5194+ 3503 87                   add     A,A
5195+ 3504 87                   add     A,A
5196+ 3505 B0                   or      B               ; put background color into the low nibble of A
5197+ 3506 C9                   ret                     ; return to caller
5198+ 3507
5199+ 3507
5200+ 3507              ; check if the color is not 0 and into the range 1~15
5201+ 3507 A7           CHKCLR1:and     A               ; is it 0?
5202+ 3508 CA ED 16             jp      Z,SNERR         ; yes, raise a SN error
5203+ 350B FE 10        CHKCLR0:cp      $10             ; is it in range 0~15?
5204+ 350D D2 ED 16             jp      NC,SNERR        ; no, raise a SN error
5205+ 3510 C9                   ret                     ; param is OK, can return
5206+ 3511
5207+ 3511
5208+ 3511              ; check if in graphics 2 mode
5209+ 3511 3A CF 81     CHKG2M: ld      A,(SCR_MODE)    ; check screen mode
5210+ 3514 FE 02                cp      $02             ; actually, we can paint only in G2
5211+ 3516 C2 17 3B             jp      NZ,GMERR        ; no G2, print a No Graphics Mode Error
5212+ 3519 C9                   ret                     ; return to caller
5213+ 351A
5214+ 351A
5215+ 351A              ; print a text in screen 2
5216+ 351A              ; GPRINT text,x,y[,fc[,bc]]
5217+ 351A              ; where "text" is an expression that can be converted into a sequence of ASCII chars,
5218+ 351A              ; x & y are the coordinates (0<=x<=31, 0<=y<=23), fc & bc are foreground and background
5219+ 351A              ; colors (1~15), resp.
5220+ 351A              ; (portions of code are from nippur72)
5221+ 351A              GX      equ     TMPBFR3
5222+ 351A              GY      equ     TMPBFR4
5223+ 351A              TMPCLR  equ     TMPBFR2
5224+ 351A              MIXCOL  equ     TMPBFR1
5225+ 351A              TMPADR  equ     VIDEOBUFF
5226+ 351A              CHRPNT  equ     VIDEOBUFF+$02
5227+ 351A              NUMCHR  equ     VIDEOBUFF+$04
5228+ 351A              TMPHL   equ     VIDEOBUFF+$06
5229+ 351A CD 11 35     GPRINT: call    CHKG2M          ; check if in graphic mode 2
5230+ 351D 2B                   dec     HL              ; dec 'cos GETCHR INCs
5231+ 351E CD 30 1C             call    GETCHR          ; check if something follows
5232+ 3521 CA ED 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
5233+ 3524 22 E5 81             ld      (VIDEOBUFF),HL  ; save current code string pointer
5234+ 3527 CD D3 20             call    EVAL            ; Evaluate expression
5235+ 352A CD C5 20             call    TSTSTR          ; Make sure it's a string
5236+ 352D 22 EB 81             ld      (TMPHL),HL      ; store code string pointer
5237+ 3530 CD 0C 27             call    GSTRCU          ; Current string to pool
5238+ 3533 CD 1D 2F             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
5239+ 3536 ED 43 E7 81          ld      (CHRPNT),BC     ; store string pointer
5240+ 353A ED 53 E9 81          ld      (NUMCHR),DE     ; store string lenght
5241+ 353E 2A EB 81             ld      HL,(TMPHL)      ; store code string pointer
5242+ 3541 CD E7 19             call    CHKSYN          ; Make sure ',' follows
5243+ 3544 2C                   defb    ','
5244+ 3545 CD 47 29             call    GETINT          ; get X coord.
5245+ 3548 FE 20                cp      $20             ; is it in rage 0~31?
5246+ 354A D2 FB 1C             jp      NC,FCERR        ; Illegal function call error
5247+ 354D 32 E1 81             ld      (GX),A          ; store into temp. buffer
5248+ 3550 CD E7 19             call    CHKSYN          ; Make sure ',' follows
5249+ 3553 2C                   defb    ','
5250+ 3554 CD 47 29             call    GETINT          ; get Y coord.
5251+ 3557 FE 18                cp      $18             ; is it in range 0~23?
5252+ 3559 D2 FB 1C             jp      NC,FCERR        ; Illegal function call error
5253+ 355C 32 E3 81             ld      (GY),A          ; store into temp. buffer
5254+ 355F 11 DF 81             ld      DE,TMPCLR
5255+ 3562 3A DC 81             ld      A,(BKGNDCLR)    ; load background color
5256+ 3565 12                   ld      (DE),A          ; store into temp buff
5257+ 3566 3A DB 81             ld      A,(FRGNDCLR)    ; load foreground color
5258+ 3569 1B                   dec     DE
5259+ 356A 1B                   dec     DE
5260+ 356B 12                   ld      (DE),A          ; store into temp buff
5261+ 356C CD F8 35             call    CKCOL           ; check color
5262+ 356F CA 77 35             jp      Z,CNTGPT2       ; if anything follows, jump over
5263+ 3572 13                   inc     DE
5264+ 3573 13                   inc     DE
5265+ 3574 CD F8 35             call    CKCOL           ; check background color
5266+ 3577 CD FA 34     CNTGPT2:call    MIXCLRS         ; mix foreground & background colors
5267+ 357A 32 DD 81             ld      (MIXCOL),A      ; store mixed colors
5268+ 357D E5                   push    HL              ; store code string address
5269+ 357E ED 4B E7 81          ld      BC,(CHRPNT)     ; retrieve string pointer
5270+ 3582 ED 5B E9 81          ld      DE,(NUMCHR)     ; retrieve string lenght
5271+ 3586 1C                   inc     E               ; Length + 1
5272+ 3587 CD 8C 35             call    GPNT            ; print on G2
5273+ 358A E1                   pop     HL              ; recover HL
5274+ 358B C9                   ret                     ; return to caller
5275+ 358C D5           GPNT:   push    DE              ; store string lenght (E)
5276+ 358D                      ; calculate VRAM address of first char
5277+ 358D 3A E1 81             LD      A,(GX)          ; load X
5278+ 3590 6F                   ld      L,A             ;
5279+ 3591 26 00                ld      H,0             ; HL = X
5280+ 3593 29                   add     HL,HL           ;
5281+ 3594 29                   add     HL,HL           ;
5282+ 3595 29                   add     HL,HL           ; X=X*8
5283+ 3596 3A E3 81             ld      A,(GY)          ; load Y
5284+ 3599 57                   ld      D,A             ; move it into D
5285+ 359A 1E 00                ld      E,0             ; DE =Y*256
5286+ 359C 19                   add     HL,DE           ; address = X*8 + Y*256
5287+ 359D 22 E5 81             ld      (TMPADR),HL     ; store VRAM address of first VRAM cell
5288+ 35A0 D1                   pop     DE              ; retrieve # of chars to be printed yet (E)
5289+ 35A1 1D           RPGPNT: dec     E               ; Count characters
5290+ 35A2 C8                   ret     Z               ; End of string - return
5291+ 35A3 D5                   push    DE              ; store chars counter
5292+ 35A4                      ; calculate dest address in color vram
5293+ 35A4 2A E5 81             ld      HL,(TMPADR)     ; recover VRAM address
5294+ 35A7 11 00 20             ld      DE,$2000        ; color map address
5295+ 35AA 19                   add     HL,DE           ; HL = $2000 + XY address
5296+ 35AB F3                   di                      ; disable INTs
5297+ 35AC                      ; send color settings
5298+ 35AC CD 7B 06     GPNTCOL:call    SETVDPADRS      ; set VRAM address for color cell
5299+ 35AF 3A DD 81             ld      A,(MIXCOL)      ; load color settings
5300+ 35B2 06 08                ld      B,$08           ; repeat for 8 rows
5301+ 35B4 0E 30                ld      C,VDP_DAT       ; VDP data mode
5302+ 35B6 ED 79        GPNTCO1:out     (C),A           ; send data (VRAM pointer auto-increments)
5303+ 35B8 00                   nop                     ; wait...
5304+ 35B9 00                   nop                     ; ...a...
5305+ 35BA 00                   nop                     ; ...while
5306+ 35BB 10 F9                djnz    GPNTCO1         ; repeat for 8 cells
5307+ 35BD                      ; calculate source address
5308+ 35BD 2A E7 81             ld      HL,(CHRPNT)     ; load char pointer
5309+ 35C0 7E                   ld      A,(HL)          ; get char
5310+ 35C1 23                   inc     HL              ; increment char pointer
5311+ 35C2 22 E7 81             ld      (CHRPNT),HL     ; store char pointer
5312+ 35C5 6F                   ld      L,A             ;
5313+ 35C6 26 00                ld      H,$00           ; char into HL
5314+ 35C8 29                   add     HL,HL           ;
5315+ 35C9 29                   add     HL,HL           ;
5316+ 35CA 29                   add     HL,HL           ; get offset of char into ROM (charcode * 8)
5317+ 35CB 11 67 48             ld      DE,CHRST88      ; DE = start of 8x8 fonts in ROM
5318+ 35CE 19                   add     HL,DE           ; HL = start of characters in ROM
5319+ 35CF EB                   ex      DE,HL           ; store address into DE
5320+ 35D0 2A E5 81     GPCPCHR:ld      HL,(TMPADR)     ; load VRAM address
5321+ 35D3 CD 7B 06             call    SETVDPADRS      ; send it to VDP
5322+ 35D6 EB                   ex      DE,HL           ; restore address into HL
5323+ 35D7 06 08                ld      B,$08           ; repeat for 8 rows
5324+ 35D9 0E 30                ld      C,VDP_DAT              ; VDP data mode
5325+ 35DB ED A3        GPCPCH1:outi                    ; load a byte from ROM and send to VRAM
5326+ 35DD 00                   nop                     ; wait...
5327+ 35DE 00                   nop                     ; ...a...
5328+ 35DF 00                   nop                     ; ...while
5329+ 35E0 20 F9                jr      NZ,GPCPCH1      ; repeat for 8 chars
5330+ 35E2 FB                   ei                      ; re-enable INTs
5331+ 35E3 11 08 00             ld      DE,$0008        ; 8 bytes to go to the next video cell
5332+ 35E6 2A E5 81             ld      HL,(TMPADR)     ; load VRAM address
5333+ 35E9 19                   add     HL,DE           ; get address of next VRAM cell
5334+ 35EA 22 E5 81             ld      (TMPADR),HL     ; store new VRAM address
5335+ 35ED 11 00 18             ld      DE,$1800        ; forbidden address
5336+ 35F0 CD 04 40             call    CMP16           ; check if the printing has gone out of the screen
5337+ 35F3 D1                   pop     DE              ; retrieve number of chars to be printed
5338+ 35F4 D0                   ret     NC              ; if HL>=$1800 then leave
5339+ 35F5 C3 A1 35             jp      RPGPNT          ; otherwise, check if more chars to output
5340+ 35F8
5341+ 35F8              ; used by GPRINT to get a color argument (if present)
5342+ 35F8 2B           CKCOL:  dec     HL              ; dec 'cos GETCHR INCs
5343+ 35F9 CD 30 1C             call    GETCHR          ; Get next character
5344+ 35FC C8                   ret     Z               ; return if nothing follows
5345+ 35FD CD E7 19             call    CHKSYN          ; Make sure ',' follows
5346+ 3600 2C                   defb    ','
5347+ 3601 D5                   push    DE              ; store DE
5348+ 3602 CD 47 29             call    GETINT          ; get value
5349+ 3605 CD 07 35             call    CHKCLR1         ; check if color is in range 1~15
5350+ 3608 D1                   pop     DE              ; retrieve DE
5351+ 3609 12                   ld      (DE),A          ; store color into temp buffer
5352+ 360A C9                   ret                     ; return to caller
5353+ 360B
5354+ 360B
5355+ 360B              ; paint X,Y[,C]: in graphics mode, fills an area starting
5356+ 360B              ; at point X,Y, using default color or, if used, with
5357+ 360B              ; color set by C
5358+ 360B              ; TMPBFR1       X
5359+ 360B              ; TMPBFR2       Y
5360+ 360B              ; TMPBFR3       COLOR
5361+ 360B              PNT     equ     VIDEOBUFF
5362+ 360B              SPA     equ     VIDEOBUFF+$02
5363+ 360B              SPB     equ     VIDEOBUFF+$03
5364+ 360B              ORGSP   equ     VIDEOBUFF+$04
5365+ 360B CD 11 35     PAINT:  call    CHKG2M          ; check if in graphic mode 2
5366+ 360E CD 47 29             call    GETINT          ; get X
5367+ 3611 32 DD 81             ld      (TMPBFR1),A     ; store X
5368+ 3614 CD E7 19             call    CHKSYN          ; Make sure ',' follows
5369+ 3617 2C                   defb    ','
5370+ 3618 CD 47 29             call    GETINT          ; get Y coords,
5371+ 361B FE C0                cp      $C0             ; check if Y is in range 0~191
5372+ 361D D2 FB 1C             jp      NC,FCERR        ; no, raise an FC error
5373+ 3620 32 DF 81             ld      (TMPBFR2),A     ; store Y
5374+ 3623 CD FE 3A             call    CLRPRM          ; check if color has been passed
5375+ 3626 3A E1 81             ld      A,(TMPBFR3)     ; load color
5376+ 3629 A7                   and     A               ; check if 0
5377+ 362A CA FB 1C             jp      Z,FCERR         ; yes, raise an error
5378+ 362D E5                   push    HL              ; store HL
5379+ 362E C5                   push    BC              ; store BC
5380+ 362F D5                   push    DE              ; store DE
5381+ 3630                      ; start algorithm
5382+ 3630 CD 43 37             call    PNTRTN          ; check if pixel is already set
5383+ 3633 C2 E7 36             jp      NZ,EXITPA2      ; if yes, then leave PAINT
5384+ 3636 ED 73 E9 81          ld      (ORGSP),SP      ; no, store current Stack Pointer
5385+ 363A 21 01 00             ld      HL,$0001        ; HL=1
5386+ 363D 22 E5 81             ld      (PNT),HL        ; set PNT
5387+ 3640 3A DD 81             ld      A,(TMPBFR1)     ; load starting X...
5388+ 3643 47                   ld      B,A             ; ...into B
5389+ 3644 3A DF 81             ld      A,(TMPBFR2)     ; load starting Y...
5390+ 3647 4F                   ld      C,A             ; ...into C
5391+ 3648 C5                   push    BC              ; store starting X,Y into stack
5392+ 3649                      ; main loop
5393+ 3649 2A E5 81     NXTLOOP:ld      HL,(PNT)        ; retrieve PNT
5394+ 364C 7C                   ld      A,H             ; check if PNT=0
5395+ 364D B5                   or      L
5396+ 364E CA E3 36             jp      Z,EXITPAI       ; yes, no more points to process - exit
5397+ 3651 2B                   dec     HL              ; no, so decrement PNT...
5398+ 3652 22 E5 81             ld      (PNT),HL        ; ...and store it
5399+ 3655 C1                   pop     BC              ; retrieve pixel coordinates X,Y into BC
5400+ 3656 CD EB 36     PAINT0: call    CHECKPA         ; check if pixel is set/reset
5401+ 3659 20 09                jr      NZ,PAINT11      ; pixel is set, so jump over
5402+ 365B 78                   ld      A,B             ; pixel is reset, check if X1=0
5403+ 365C A7                   and     A               ; (reached the limit of the screen)
5404+ 365D CA 65 36             jp      Z,PAINT1        ; yes, jump over
5405+ 3660 05                   dec     B               ; no, decrement X1...
5406+ 3661 C3 56 36             jp      PAINT0          ; ...and repeat
5407+ 3664 04           PAINT11:inc     B               ; if found a pixel on, the re-increment X1
5408+ 3665 AF           PAINT1: xor     A               ; reset A
5409+ 3666 57                   ld      D,A             ; set SA=0
5410+ 3667 5F                   ld      E,A             ; set SB=0
5411+ 3668 CD EB 36     MNPAINT:call    CHECKPA         ; check if pixel is set/reset
5412+ 366B 20 DC                jr      NZ,NXTLOOP      ; it's set, so goto next loop
5413+ 366D 78                   ld      A,B             ; copy X1
5414+ 366E 32 DD 81             ld      (TMPBFR1),A     ; into buffer
5415+ 3671 79                   ld      A,C             ; copy Y
5416+ 3672 32 DF 81             ld      (TMPBFR2),A     ; into buffer
5417+ 3675 CD 69 37             call    CNTPLOT         ; plot pixel X1,Y
5418+ 3678 7A                   ld      A,D             ; load SA into A
5419+ 3679 A7                   and     A               ; SA=0?
5420+ 367A 20 1C                jr      NZ,PAINT2       ; no, jump over
5421+ 367C 79                   ld      A,C             ; load Y
5422+ 367D FE 01                cp      $01             ; Y>0?
5423+ 367F DA 98 36             jp      C,PAINT2        ; no, jump over
5424+ 3682 3D                   dec     A               ; yes, Y=Y-1
5425+ 3683 CD EC 36             call    CHECKPY         ; check pixel X1,Y-1
5426+ 3686 20 10                jr      NZ,PAINT2       ; it's set, so jump over
5427+ 3688 0D                   dec     C               ; Y=Y-1
5428+ 3689 C5                   push    BC              ; insert pixel(X1,Y-1) into stack
5429+ 368A 0C                   inc     C               ; retrieve original Y
5430+ 368B 2A E5 81             ld      HL,(PNT)        ; load PNT
5431+ 368E 23                   inc     HL              ; increment PNT
5432+ 368F 22 E5 81             ld      (PNT),HL        ; store new PNT
5433+ 3692 3E 01                ld      A,$01           ; set SA=1 and...
5434+ 3694 57                   ld      D,A             ; ...store SA into memory
5435+ 3695 C3 AB 36             jp      PAINT3          ; jump over
5436+ 3698 7A           PAINT2: ld      A,D             ; load SA into A
5437+ 3699 1F                   rra                     ; check if SA=1
5438+ 369A 30 0F                jr      NC,PAINT3       ; no, jump over
5439+ 369C 79                   ld      A,C             ; load Y
5440+ 369D FE 01                cp      $01             ; Y>0?
5441+ 369F DA AB 36             jp      C,PAINT3        ; no, jump over
5442+ 36A2 3D                   dec     A               ; Y=Y-1
5443+ 36A3 CD EC 36             call    CHECKPY         ; check pixel X1,Y-1
5444+ 36A6 CA AB 36             jp      Z,PAINT3        ; if pixel is off, jump over
5445+ 36A9 AF                   xor     A               ; pixel is on, so...
5446+ 36AA 57                   ld      D,A             ; ...set SA=0
5447+ 36AB 7B           PAINT3: ld      A,E             ; check if...
5448+ 36AC A7                   and     A               ; SB=0
5449+ 36AD 20 1B                jr      NZ,PAINT4       ; no, jump over
5450+ 36AF 79                   ld      A,C             ; load Y
5451+ 36B0 FE BF                cp      $BF             ; Y<191?
5452+ 36B2 30 16                jr      NC,PAINT4       ; no, jump over
5453+ 36B4 3C                   inc     A               ; Y=Y+1
5454+ 36B5 CD EC 36             call    CHECKPY         ; check pixel X1,Y+1
5455+ 36B8 20 10                jr      NZ,PAINT4       ; pixel is on, so jump over
5456+ 36BA 0C                   inc     C               ; Y=Y+1
5457+ 36BB C5                   push    BC              ; insert pixel(X1,Y+1) into stack
5458+ 36BC 0D                   dec     C               ; retrieve original Y
5459+ 36BD 2A E5 81             ld      HL,(PNT)        ; PNT
5460+ 36C0 23                   inc     HL              ; PNT=PNT+1
5461+ 36C1 22 E5 81             ld      (PNT),HL        ; store PNT
5462+ 36C4 3E 01                ld      A,$01           ; SB=1
5463+ 36C6 5F                   ld      E,A             ; set SB
5464+ 36C7 C3 DC 36             jp      PAINT5          ; jump over
5465+ 36CA 7B           PAINT4: ld      A,E             ; load SB
5466+ 36CB 1F                   rra                     ; check if SB=1
5467+ 36CC 30 0E                jr      NC,PAINT5       ; no, jump over
5468+ 36CE 79                   ld      A,C             ; load Y
5469+ 36CF FE BF                cp      $BF             ; Y<191?
5470+ 36D1 30 09                jr      NC,PAINT5       ; no, jump over
5471+ 36D3 3C                   inc     A               ; Y=Y+1
5472+ 36D4 CD EC 36             call    CHECKPY         ; check pixel X1,Y+1
5473+ 36D7 CA DC 36             jp      Z,PAINT5        ; if pixel is off, jump over
5474+ 36DA AF                   xor     A               ; pixel is on, so...
5475+ 36DB 5F                   ld      E,A             ; ...set SB=0
5476+ 36DC 04           PAINT5: inc     B               ; X1=X1+1
5477+ 36DD CA 49 36             jp      Z,NXTLOOP       ; if X1>255 (X1=0) then goto next loop
5478+ 36E0 C3 68 36             jp      MNPAINT         ; otherwise, repeat for next X
5479+ 36E3 ED 7B E9 81  EXITPAI:ld      SP,(ORGSP)      ; retrieve original SP pointer
5480+ 36E7 D1           EXITPA2:pop     DE              ; retrieve DE
5481+ 36E8 C1                   pop     BC              ; retrieve BC
5482+ 36E9 E1                   pop     HL              ; retrieve HL
5483+ 36EA C9                   ret                     ; return to caller
5484+ 36EB 79           CHECKPA:ld      A,C             ; copy Y into A
5485+ 36EC 32 DF 81     CHECKPY:ld      (TMPBFR2),A     ; store Y
5486+ 36EF 78                   ld      A,B             ; copy X1 into A
5487+ 36F0 32 DD 81             ld      (TMPBFR1),A     ; store X1
5488+ 36F3 C5                   push    BC              ; save X1,Y
5489+ 36F4 D5                   push    DE
5490+ 36F5 CD 43 37             call    PNTRTN          ; check if pixel is set/reset
5491+ 36F8 D1                   pop     DE
5492+ 36F9 C1                   pop     BC              ; retrieve X1,Y
5493+ 36FA C9                   ret                     ; return to caller
5494+ 36FB
5495+ 36FB
5496+ 36FB              ; POINT(x,y): return if a pixel is set (returns color) or if it's reset (0)
5497+ 36FB CD 11 35     POINT:  call    CHKG2M          ; check if in graphic mode 2
5498+ 36FE CD E7 19             call    CHKSYN          ; make sure "(" follows
5499+ 3701 28                   defb    '('
5500+ 3702 CD 47 29             call    GETINT          ; get X coords.
5501+ 3705 32 DD 81             ld      (TMPBFR1),A     ; store it into a temp buffer
5502+ 3708 CD E7 19             call    CHKSYN          ; Make sure ',' follows
5503+ 370B 2C                   defb    ','
5504+ 370C CD 47 29             call    GETINT          ; get Y coords,
5505+ 370F FE C0                cp      $C0             ; check if Y is in range 0~191
5506+ 3711 D2 FB 1C             jp      NC,FCERR        ; no, raise an FC error
5507+ 3714 32 DF 81             ld      (TMPBFR2),A     ; store into a temp buffer
5508+ 3717 CD E7 19             call    CHKSYN          ; make sure ")" follows
5509+ 371A 29                   defb    ')'
5510+ 371B E5                   push    HL              ; store current string address - the point after the ")" - ...
5511+ 371C FD E1                pop     IY              ; ...into IY
5512+ 371E CD 43 37             call    PNTRTN          ; check if pixel is set or reset
5513+ 3721 20 0C                jr      NZ,CTPOINT      ; it's ON, jump over
5514+ 3723 AF                   xor     A               ; no, it's OFF. make sure to reset A...
5515+ 3724 47                   ld      B,A             ; ...and B
5516+ 3725 E1           PNTEND: pop     HL              ; drop original return point
5517+ 3726 FD E5                push    IY              ; load current string address from IY into stack
5518+ 3728 11 AC 21             ld      DE,RETNUM       ; Address of Return number from function...
5519+ 372B D5                   push    DE              ; ...saved on stack
5520+ 372C C3 AB 24             jp      ABPASS          ; return AB
5521+ 372F CB EC        CTPOINT:set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5522+ 3731 F3                   di
5523+ 3732 CD 9B 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5524+ 3735 FB                   ei
5525+ 3736 CB 3F                srl     A               ; shift A...
5526+ 3738 CB 3F                srl     A               ; ...4 times...
5527+ 373A CB 3F                srl     A               ; ...to move foreground color...
5528+ 373C CB 3F                srl     A               ; ...into lowest nibble
5529+ 373E 47                   ld      B,A             ; color into B
5530+ 373F AF                   xor     A               ; reset MSB
5531+ 3740 C3 25 37             jp      PNTEND          ; return AB
5532+ 3743 CD B6 37     PNTRTN: call    XY2HL           ; find HL address of pixel at X,Y
5533+ 3746 57                   ld      D,A             ; store pixel index
5534+ 3747 F3                   di                      ; disable INTs
5535+ 3748 CD 9B 06             call    READ_VIDEO_LOC  ; read contents of VRAM cell addressed by HL
5536+ 374B FB                   ei                      ; re-enable INTs
5537+ 374C A2                   and     D               ; is the pixel ON or OFF? (will be checked later)
5538+ 374D C9                   ret                     ; return to caller
5539+ 374E
5540+ 374E
5541+ 374E              ; PLOT X,Y[,color]
5542+ 374E              ; plot a pixel in graphic mode 2
5543+ 374E CD 11 35     PLOT:   call    CHKG2M          ; check if in G2 mode
5544+ 3751 CD 47 29             call    GETINT          ; get X coords.
5545+ 3754 32 DD 81             ld      (TMPBFR1),A     ; store it into a temp buffer
5546+ 3757 CD E7 19             call    CHKSYN          ; Make sure ',' follows
5547+ 375A 2C                   defb    ','
5548+ 375B CD 47 29             call    GETINT          ; get Y coords,
5549+ 375E FE C0                cp      $C0             ; check if Y is in range 0~191
5550+ 3760 D2 FB 1C             jp      NC,FCERR        ; no, raise an FC error
5551+ 3763 32 DF 81             ld      (TMPBFR2),A     ; store into a temp buffer
5552+ 3766 CD FE 3A             call    CLRPRM          ; check if param "color" has been passed
5553+ 3769 E5           CNTPLOT:push    HL              ; store HL
5554+ 376A C5                   push    BC              ; store BC
5555+ 376B D5                   push    DE              ; store DE
5556+ 376C CD B6 37             call    XY2HL           ; find VRAM address of byte containing pixel at X,Y & return into HL
5557+ 376F D2 AA 37             jp      NC,NOGD         ; if carry is reset, there was an error -> so leave
5558+ 3772 57                   ld      D,A             ; move pixel value into D
5559+ 3773 3A E1 81             ld      A,(TMPBFR3)     ; retrieve color
5560+ 3776 A7                   and     A               ; is it 0? (background, or reset pixel)
5561+ 3777 20 11                jr      NZ,CNTPLT1      ; no, continue
5562+ 3779 F3                   di                      ; yes - so, disable INTs
5563+ 377A CD 9B 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5564+ 377D FB                   ei                      ; re-enable INTs
5565+ 377E 5F                   ld      E,A             ; store value of cell
5566+ 377F 7A                   ld      A,D             ; retrieve pixel
5567+ 3780 2F                   cpl                     ; revert bits
5568+ 3781 A3                   and     E               ; set video pixel to off
5569+ 3782 F3                   di                      ; disable INTs
5570+ 3783 CD B0 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5571+ 3786 FB                   ei                      ; re-enable INTs
5572+ 3787 C3 AA 37             jp      NOGD            ; leave
5573+ 378A 87           CNTPLT1:add     A,A             ; now we move low nibble
5574+ 378B 87                   add     A,A             ; in the high nibble
5575+ 378C 87                   add     A,A             ; by adding A to itself
5576+ 378D 87                   add     A,A             ; 4 times (this is a shift left 4)
5577+ 378E 5F                   ld      E,A             ; move it into E
5578+ 378F F3                   di                      ; disable INTs
5579+ 3790 CD 9B 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5580+ 3793 FB                   ei
5581+ 3794 B2                   or      D               ; merge new pixel preserving original pattern
5582+ 3795 F3                   di
5583+ 3796 CD B0 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5584+ 3799 FB                   ei
5585+ 379A CB EC                set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5586+ 379C F3                   di
5587+ 379D CD 9B 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5588+ 37A0 FB                   ei
5589+ 37A1 E6 0F                and     %00001111       ; reset high nibble (the foreground color)
5590+ 37A3 B3                   or      E               ; set new foreground color
5591+ 37A4 F3                   di
5592+ 37A5 CD B0 06             call    WRITE_VIDEO_LOC ; write new color settings
5593+ 37A8 FB                   ei                      ; re-enable INTs
5594+ 37A9 00                   nop                     ; wait for INTs to be enabled again
5595+ 37AA D1           NOGD:   pop     DE              ; retrieve DE
5596+ 37AB C1                   pop     BC              ; retrieve BC
5597+ 37AC E1                   pop     HL              ; retrieve HL
5598+ 37AD C9                   ret                     ; return to caller
5599+ 37AE 80 40 20 10  PXLSET: defb    $80,$40,$20,$10,$08,$04,$02,$01 ; pixel to be set ON
5599+ 37B2 08 04 02 01
5600+ 37B6                      ; where R(X/8)=> 0=80h, 1=40h, 2=20h, 3=10h, 4=08h, 5=04h, 6=02h, 7=$01
5601+ 37B6
5602+ 37B6
5603+ 37B6              ; compute the VRAM address of the byte containing the pixel
5604+ 37B6              ; being pointed by X,Y (TMPBFR1,TMPBFR1)
5605+ 37B6              ; byte address is returned into HL
5606+ 37B6              ; pixel is returned into A
5607+ 37B6              XY2HL:  ; formula is: ADDRESS=(INT(X/8))*8 + (INT(Y/8))*256 + R(Y/8)
5608+ 37B6                      ; where R(Y/8) is the remainder of (Y/8)
5609+ 37B6                      ; the pixel to be set is given by R(X/8), and data is taken from the array
5610+ 37B6 3A DF 81             ld      A,(TMPBFR2)     ; retrieve Y
5611+ 37B9 FE C0                cp      $C0             ; Y>=192?
5612+ 37BB D0                   ret     NC              ; yes, so leave
5613+ 37BC 1E 08                ld      E,$08           ; load E with divisor
5614+ 37BE 57                   ld      D,A             ; and store into D (dividend)
5615+ 37BF CD 33 40             call    DIV_8_8         ; get Y/8, D is quotient=INT(Y/8), and A is remainder
5616+ 37C2 4F                   ld      C,A             ; store remainder into C
5617+ 37C3 42                   ld      B,D             ; B=(INT(Y/8))*256 (we simply copy quotient into B)
5618+ 37C4 60 69                ld      HL,BC           ; copy BC into HL: now HL has the VRAM address of the byte being set
5619+ 37C6 3A DD 81             ld      A,(TMPBFR1)     ; retrieve X
5620+ 37C9 57                   ld      D,A             ; and move it into D (dividend)
5621+ 37CA CD 33 40             call    DIV_8_8         ; get X/8, D is quotient=INT(X/8), and A is remainder
5622+ 37CD 4F                   ld      C,A             ; store remainder into C
5623+ 37CE 7A                   ld      A,D             ; move quotient into A
5624+ 37CF 87                   add     A,A             ; multiply quotient by 8
5625+ 37D0 87                   add     A,A
5626+ 37D1 87                   add     A,A
5627+ 37D2 5F                   ld      E,A             ; store result into E
5628+ 37D3 16 00                ld      D,$00           ; reset D
5629+ 37D5 19                   add     HL,DE           ; add DE to HL, getting the final VRAM address
5630+ 37D6 EB                   ex      DE,HL           ; move VRAM address into DE
5631+ 37D7 21 AE 37             ld      HL,PXLSET       ; starting address of table for pixel to draw
5632+ 37DA 06 00                ld      B,$00           ; reset B
5633+ 37DC 09                   add     HL,BC           ; add C (remainder of X/8) to get address of pixel to turn on
5634+ 37DD 7E                   ld      A,(HL)          ; load pixel data
5635+ 37DE EB                   ex      DE,HL           ; retrieve VRAM pattern address into HL
5636+ 37DF 37                   scf                     ; set Carry for normal exit
5637+ 37E0 C9                   ret                     ; return to caller
5638+ 37E1
5639+ 37E1
5640+ 37E1              ; DRAW X1,Y1,X2,Y2[,color]
5641+ 37E1              ; Draw a line using Bresenham's line algorithm from X1,Y1 to X2,Y2
5642+ 37E1              ; X1,Y1 can be either less than or greater than X2,Y2 (meaning that)
5643+ 37E1              ; the drawing will be ever done from X1,Y2 to X2,Y2, regardless of
5644+ 37E1              ; the values. If color is not specified, the foreground color set
5645+ 37E1              ; with COLOR will be used
5646+ 37E1              X1      equ     TMPBFR1
5647+ 37E1              Y1      equ     TMPBFR2
5648+ 37E1              X2      equ     VIDEOBUFF
5649+ 37E1              Y2      equ     VIDEOBUFF+$02
5650+ 37E1              ER      equ     VIDEOBUFF+$04
5651+ 37E1              E2      equ     VIDEOBUFF+$06
5652+ 37E1              SX      equ     VIDEOBUFF+$08
5653+ 37E1              SY      equ     VIDEOBUFF+$0A
5654+ 37E1              DX      equ     VIDEOBUFF+$0C
5655+ 37E1              DY      equ     VIDEOBUFF+$0E
5656+ 37E1 CD 11 35     DRAW:   call    CHKG2M          ; check if in G2 mode
5657+ 37E4 CD E6 3A             call    CLRVDBF         ; clear VIDEOBUFF
5658+ 37E7 CD 47 29             call    GETINT          ; get X1 coords.
5659+ 37EA 32 DD 81             ld      (X1),A          ; store it into a temp buffer
5660+ 37ED CD E7 19             call    CHKSYN          ; Make sure ',' follows
5661+ 37F0 2C                   defb    ','
5662+ 37F1 CD 47 29             call    GETINT          ; get Y1 coords.
5663+ 37F4 FE C0                cp      $C0             ; check if Y1 is in range 0~191
5664+ 37F6 D2 FB 1C             jp      NC,FCERR        ; no, raise an FC error
5665+ 37F9 32 DF 81             ld      (Y1),A          ; store into a temp buffer
5666+ 37FC CD E7 19             call    CHKSYN          ; Make sure ',' follows
5667+ 37FF 2C                   defb    ','
5668+ 3800 CD 47 29             call    GETINT          ; get X2 coords.
5669+ 3803 32 E5 81             ld      (X2),A          ; store it into a temp buffer
5670+ 3806 CD E7 19             call    CHKSYN          ; Make sure ',' follows
5671+ 3809 2C                   defb    ','
5672+ 380A CD 47 29             call    GETINT          ; get Y2 coords
5673+ 380D FE C0                cp      $C0             ; check if Y2 is in range 0~191
5674+ 380F D2 FB 1C             jp      NC,FCERR        ; no, raise an FC error
5675+ 3812 32 E7 81             ld      (Y2),A          ; store it into a temp buffer
5676+ 3815 CD FE 3A             call    CLRPRM          ; check for arg. "color" and store it into TMPBFR3
5677+ 3818 E5                   push    HL              ; store register we'll use
5678+ 3819 D5                   push    DE
5679+ 381A C5                   push    BC
5680+ 381B ED 5B DD 81          ld      DE,(X1)         ; load X1 and
5681+ 381F 2A E5 81             ld      HL,(X2)         ; X2
5682+ 3822 B7                   or      A               ; clear CARRY
5683+ 3823 ED 52                sbc     HL,DE           ; DX=X2-X1
5684+ 3825 CD 29 40             call    absHL           ; DX=ABS(DX)
5685+ 3828 22 F1 81             ld      (DX),HL         ; store DX
5686+ 382B 01 FF FF             ld      BC,$FFFF        ; SX=-1
5687+ 382E 2A DD 81             ld      HL,(X1)
5688+ 3831 ED 5B E5 81          ld      DE,(X2)
5689+ 3835 CD 04 40             call    CMP16           ; X1<X2?
5690+ 3838 CA 41 38             jp      Z,X1GR          ; no, X1=X2
5691+ 383B F2 41 38             jp      P,X1GR          ; no, X1>X2
5692+ 383E 01 01 00             ld      BC,$0001        ; yes, so set SX=1
5693+ 3841 ED 43 ED 81  X1GR:   ld      (SX),BC         ; store SX
5694+ 3845 ED 5B DF 81          ld      DE,(Y1)
5695+ 3849 2A E7 81             ld      HL,(Y2)
5696+ 384C B7                   or      A               ; clear Carry
5697+ 384D ED 52                sbc     HL,DE           ; DY=Y2-Y1
5698+ 384F CD 29 40             call    absHL           ; DY=ABS(DY)
5699+ 3852 22 F3 81             ld      (DY),HL         ; store DY
5700+ 3855 01 FF FF             ld      BC,$FFFF        ; SY=-1
5701+ 3858 2A DF 81             ld      HL,(Y1)
5702+ 385B ED 5B E7 81          ld      DE,(Y2)
5703+ 385F CD 04 40             call    CMP16           ; is Y1<Y2?
5704+ 3862 CA 6B 38             jp      Z,Y1GR          ; no, Y1=Y2
5705+ 3865 F2 6B 38             jp      P,Y1GR          ; no, Y1>Y2 - jump over
5706+ 3868 01 01 00             ld      BC,$0001        ; yes, so set SY=1
5707+ 386B ED 43 EF 81  Y1GR:   ld      (SY),BC         ; store SY
5708+ 386F 2A F3 81             ld      HL,(DY)         ; ER=DY
5709+ 3872 CD 2C 40             call    negHL           ; ER=-DY
5710+ 3875 22 E9 81             ld      (ER),HL         ; store ER
5711+ 3878 2A F1 81             ld      HL,(DX)
5712+ 387B ED 5B F3 81          ld      DE,(DY)
5713+ 387F CD 04 40             call    CMP16           ; DX>DY?
5714+ 3882 CA 8E 38             jp      Z,ER2           ; no, DX=DY
5715+ 3885 FA 8E 38             jp      M,ER2           ; no, DX<DY
5716+ 3888 2A F1 81             ld      HL,(DX)         ; reload DX
5717+ 388B 22 E9 81             ld      (ER),HL         ; yes: DX>DY, so ER=DX
5718+ 388E 2A E9 81     ER2:    ld      HL,(ER)         ; load ER
5719+ 3891 CB 2C                sra     H               ; right shift (and preserve sign)...
5720+ 3893 CB 1D                rr      L               ; ...of HL, so ER=INT(ER/2)
5721+ 3895 CB 7C                bit     7,H             ; is the number negative?
5722+ 3897 CA 9B 38             jp      Z,STRE2         ; no, jump over
5723+ 389A 23                   inc     HL              ; yes, add 1 'cos INT of a negative number needs to be incremented
5724+ 389B 22 E9 81     STRE2:  ld      (ER),HL         ; store ER
5725+ 389E CD 69 37     RPTDRW: call    CNTPLOT         ; plot first pixel
5726+ 38A1 2A DD 81             ld      HL,(X1)
5727+ 38A4 ED 5B E5 81          ld      DE,(X2)
5728+ 38A8 CD 04 40             call    CMP16           ; X1=X2?
5729+ 38AB 20 0D                jr      NZ,CNTDRW       ; no, continue drawing
5730+ 38AD 2A DF 81             ld      HL,(Y1)         ; yes, so check
5731+ 38B0 ED 5B E7 81          ld      DE,(Y2)         ; also Y
5732+ 38B4 CD 04 40             call    CMP16           ; Y1=Y2?
5733+ 38B7 CA 13 39             jp      Z,ENDDRAW       ; yes, finished drawing: exit
5734+ 38BA ED 5B E9 81  CNTDRW: ld      DE,(ER)
5735+ 38BE ED 53 EB 81          ld      (E2),DE         ; E2=ER
5736+ 38C2 2A F1 81             ld      HL,(DX)
5737+ 38C5 CD 2C 40             call    negHL           ; DX=-DX
5738+ 38C8 EB                   ex      DE,HL           ; invert DE and HL => HL=E2, DE=-DX
5739+ 38C9 CD 04 40             call    CMP16           ; E2>-DX?
5740+ 38CC CA EA 38             jp      Z,DXGR          ; no, E2=-DX: jump
5741+ 38CF FA EA 38             jp      M,DXGR          ; no, E2<-DX: jump
5742+ 38D2 2A E9 81             ld      HL,(ER)         ; yes
5743+ 38D5 ED 5B F3 81          ld      DE,(DY)
5744+ 38D9 B7                   or      A               ; clear CARRY
5745+ 38DA ED 52                sbc     HL,DE           ; ER=ER-DY
5746+ 38DC 22 E9 81             ld      (ER),HL
5747+ 38DF 2A DD 81             ld      HL,(X1)
5748+ 38E2 ED 5B ED 81          ld      DE,(SX)
5749+ 38E6 19                   add     HL,DE           ; X1=X1+SX (increment X1)
5750+ 38E7 22 DD 81             ld      (X1),HL
5751+ 38EA 2A EB 81     DXGR:   ld      HL,(E2)
5752+ 38ED ED 5B F3 81          ld      DE,(DY)
5753+ 38F1 CD 04 40             call    CMP16           ; E2<DY?
5754+ 38F4 CA 9E 38             jp      Z,RPTDRW        ; no, E2=DY: jump
5755+ 38F7 F2 9E 38             jp      P,RPTDRW        ; no, E2>DY: jump
5756+ 38FA 2A E9 81             ld      HL,(ER)         ; yes
5757+ 38FD ED 5B F1 81          ld      DE,(DX)
5758+ 3901 19                   add     HL,DE           ; ER=ER+DX
5759+ 3902 22 E9 81             ld      (ER),HL
5760+ 3905 2A DF 81             ld      HL,(Y1)
5761+ 3908 ED 5B EF 81          ld      DE,(SY)
5762+ 390C 19                   add     HL,DE           ; Y1=Y1+SY (increment Y1)
5763+ 390D 22 DF 81             ld      (Y1),HL
5764+ 3910 C3 9E 38             jp      RPTDRW          ; repeat
5765+ 3913 C1           ENDDRAW:pop     BC              ; retrieve BC
5766+ 3914 D1                   pop     DE              ; retrieve DE
5767+ 3915 E1                   pop     HL              ; retrieve HL
5768+ 3916 C9                   ret                     ; return to caller
5769+ 3917
5770+ 3917
5771+ 3917              ; CIRCLE X,Y,R[,C]
5772+ 3917              ; Draw a circle using Bresenham's circle algorithm with center in X,Y
5773+ 3917              ; and radius R, with optional color C. If color is not specified, the
5774+ 3917              ; foreground color set with COLOR will be used
5775+ 3917              XC      equ     VIDEOBUFF
5776+ 3917              YC      equ     VIDEOBUFF+$02
5777+ 3917              RADIUS  equ     VIDEOBUFF+$04
5778+ 3917              XI      equ     VIDEOBUFF+$06
5779+ 3917              YI      equ     VIDEOBUFF+$08
5780+ 3917              DC      equ     VIDEOBUFF+$0A
5781+ 3917 CD 11 35     CIRCLE: call    CHKG2M          ; check if in G2 mode
5782+ 391A CD E6 3A             call    CLRVDBF         ; clear VIDEOBUFF
5783+ 391D CD 47 29             call    GETINT          ; get X coords.
5784+ 3920 32 E5 81             ld      (XC),A          ; store it into a temp buffer
5785+ 3923 CD E7 19             call    CHKSYN          ; Make sure ',' follows
5786+ 3926 2C                   defb    ','
5787+ 3927 CD 47 29             call    GETINT          ; get Y coords,
5788+ 392A 32 E7 81             ld      (YC),A          ; store it into a temp buffer
5789+ 392D CD E7 19             call    CHKSYN          ; Make sure ',' follows
5790+ 3930 2C                   defb    ','
5791+ 3931 CD 47 29             call    GETINT          ; get radius
5792+ 3934 32 E9 81             ld      (RADIUS),A      ; store it into a temp buffer
5793+ 3937 CD FE 3A             call    CLRPRM          ; check if param "color" has been passed
5794+ 393A C5                   push    BC              ; store BC
5795+ 393B D5                   push    DE              ; store DE
5796+ 393C E5                   push    HL              ; store HL
5797+ 393D AF                   xor     A               ; clear A,
5798+ 393E 47                   ld      B,A             ; B,
5799+ 393F 4F                   ld      C,A             ; C,
5800+ 3940 57                   ld      D,A             ; D,
5801+ 3941 67                   ld      H,A             ; and H
5802+ 3942 ED 43 EB 81          ld      (XI),BC         ; clear XI
5803+ 3946 3A E9 81             ld      A,(RADIUS)      ; load RADIUS into A
5804+ 3949 6F                   ld      L,A             ; HL now contains R
5805+ 394A 22 ED 81             ld      (YI),HL         ; YI=RADIUS
5806+ 394D 29                   add     HL,HL           ; R*2
5807+ 394E EB                   ex      DE,HL           ; put HL into DE
5808+ 394F 21 03 00             ld      HL,$0003        ; HL = 3
5809+ 3952 AF                   xor     A               ; clear Carry
5810+ 3953 ED 52                sbc     HL,DE           ; D=3-(2*R) => HL
5811+ 3955 22 EF 81             ld      (DC),HL         ; store D
5812+ 3958 CD B7 39             call    DRWCRL          ; draw initial point
5813+ 395B ED 5B EB 81  RPTCRL: ld      DE,(XI)         ; load XI
5814+ 395F 2A ED 81             ld      HL,(YI)         ; load YI
5815+ 3962 CD 04 40             call    CMP16           ; is YI<DI?
5816+ 3965 CA 6E 39             jp      Z,RPTCL1        ; no, YI=XI
5817+ 3968 F2 6E 39             jp      P,RPTCL1        ; no, YI>XI
5818+ 396B C3 B3 39             jp      ENDCRL          ; yes, so we've finished
5819+ 396E 21 EB 81     RPTCL1: ld      HL,XI
5820+ 3971 34                   inc     (HL)            ; XI=XI+1
5821+ 3972 2A EF 81             ld      HL,(DC)         ; load D
5822+ 3975 7C                   ld      A,H
5823+ 3976 B5                   or      L               ; is D=0? Yes, jump over
5824+ 3977 CA 9B 39             jp      Z,DLSZ
5825+ 397A CB 7C                bit     7,H             ; is D<0?
5826+ 397C 20 1D                jr      NZ,DLSZ         ; yes, jump over
5827+ 397E ED 5B ED 81          ld      DE,(YI)         ; D>0
5828+ 3982 1B                   dec     DE              ; so, YI=YI-1
5829+ 3983 ED 53 ED 81          ld      (YI),DE         ; store YI
5830+ 3987 AF                   xor     A               ; clear Carry
5831+ 3988 2A EB 81             ld      HL,(XI)
5832+ 398B ED 52                sbc     HL,DE           ; HL=XI-YI
5833+ 398D 29                   add     HL,HL
5834+ 398E 29                   add     HL,HL           ; HL=HL*4
5835+ 398F 11 0A 00             ld      DE,10
5836+ 3992 19                   add     HL,DE           ; HL=HL+10
5837+ 3993 ED 5B EF 81          ld      DE,(DC)         ; load D
5838+ 3997 EB                   ex      DE,HL           ; invert DE and HL, so that HL=4*(XI-YI)+10 and DE=D
5839+ 3998 19                   add     HL,DE           ; D=D+4*(XI-YI)+10
5840+ 3999 18 0F                jr      PLTCRL          ; plot next pixel
5841+ 399B 2A EB 81     DLSZ:   ld      HL,(XI)         ; load XI
5842+ 399E 29                   add     HL,HL
5843+ 399F 29                   add     HL,HL           ; XI=XI*4
5844+ 39A0 11 06 00             ld      DE,$0006
5845+ 39A3 19                   add     HL,DE
5846+ 39A4 ED 5B EF 81          ld      DE,(DC)
5847+ 39A8 EB                   ex      DE,HL           ; HL=D and DE=4*XI+6
5848+ 39A9 19                   add     HL,DE           ; D=D+4*XI+6
5849+ 39AA 22 EF 81     PLTCRL: ld      (DC),HL         ; store new D
5850+ 39AD CD B7 39             call    DRWCRL          ; plot pixel
5851+ 39B0 C3 5B 39             jp      RPTCRL          ; repeat
5852+ 39B3 E1           ENDCRL: pop     HL
5853+ 39B4 D1                   pop     DE
5854+ 39B5 C1                   pop     BC
5855+ 39B6 C9                   ret                     ; return to caller
5856+ 39B7 2A E5 81     DRWCRL: ld      HL,(XC)
5857+ 39BA ED 5B EB 81          ld      DE,(XI)
5858+ 39BE 19                   add     HL,DE           ; X=XC+XI
5859+ 39BF 22 DD 81             ld      (X1),HL         ; store X
5860+ 39C2 CD D6 3A             call    VALIDX          ; check if X is valid (0~255)
5861+ 39C5 DA D9 39             jp      C,CNTCL1        ; if Carry is set, X is not valid
5862+ 39C8 2A E7 81             ld      HL,(YC)
5863+ 39CB ED 5B ED 81          ld      DE,(YI)
5864+ 39CF 19                   add     HL,DE           ; Y=YC+YI
5865+ 39D0 22 DF 81             ld      (Y1),HL         ; store Y
5866+ 39D3 CD DB 3A             call    VALIDY          ; check if Y is valid (0~191)
5867+ 39D6 D4 69 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5868+ 39D9 AF           CNTCL1: xor     A               ; clear Carry
5869+ 39DA 2A E5 81             ld      HL,(XC)
5870+ 39DD ED 5B EB 81          ld      DE,(XI)
5871+ 39E1 ED 52                sbc     HL,DE           ; X=XC-XI
5872+ 39E3 22 DD 81             ld      (X1),HL         ; store X
5873+ 39E6 CD D6 3A             call    VALIDX          ; check if X is valid (0~255)
5874+ 39E9 DA FD 39             jp      C,CNTCL2        ; if Carry is set, X is not valid
5875+ 39EC 2A E7 81             ld      HL,(YC)
5876+ 39EF ED 5B ED 81          ld      DE,(YI)
5877+ 39F3 19                   add     HL,DE           ; Y=YC+YI
5878+ 39F4 22 DF 81             ld      (Y1),HL         ; store Y
5879+ 39F7 CD DB 3A             call    VALIDY          ; check if Y is valid (0~191)
5880+ 39FA D4 69 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5881+ 39FD 2A E5 81     CNTCL2: ld      HL,(XC)
5882+ 3A00 ED 5B EB 81          ld      DE,(XI)
5883+ 3A04 19                   add     HL,DE           ; X=XC+XI
5884+ 3A05 22 DD 81             ld      (X1),HL         ; store X
5885+ 3A08 CD D6 3A             call    VALIDX          ; check if X is valid (0~255)
5886+ 3A0B DA 21 3A             jp      C,CNTCL3        ; if Carry is set, X is not valid
5887+ 3A0E AF                   xor     A               ; clear Carry
5888+ 3A0F 2A E7 81             ld      HL,(YC)
5889+ 3A12 ED 5B ED 81          ld      DE,(YI)
5890+ 3A16 ED 52                sbc     HL,DE           ; Y=YC-YI
5891+ 3A18 22 DF 81             ld      (Y1),HL         ; store Y
5892+ 3A1B CD DB 3A             call    VALIDY          ; check if Y is valid (0~191)
5893+ 3A1E D4 69 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5894+ 3A21 AF           CNTCL3: xor     A               ; clear Carry
5895+ 3A22 2A E5 81             ld      HL,(XC)
5896+ 3A25 ED 5B EB 81          ld      DE,(XI)
5897+ 3A29 ED 52                sbc     HL,DE           ; X=XC-XI
5898+ 3A2B 22 DD 81             ld      (X1),HL         ; store X
5899+ 3A2E CD D6 3A             call    VALIDX          ; check if X is valid (0~255)
5900+ 3A31 DA 47 3A             jp      C,CNTCL4        ; if Carry is set, X is not valid
5901+ 3A34 AF                   xor     A               ; clear Carry
5902+ 3A35 2A E7 81             ld      HL,(YC)
5903+ 3A38 ED 5B ED 81          ld      DE,(YI)
5904+ 3A3C ED 52                sbc     HL,DE           ; Y=YC-YI
5905+ 3A3E 22 DF 81             ld      (Y1),HL         ; store Y
5906+ 3A41 CD DB 3A             call    VALIDY          ; check if Y is valid (0~191)
5907+ 3A44 D4 69 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5908+ 3A47 2A E5 81     CNTCL4: ld      HL,(XC)
5909+ 3A4A ED 5B ED 81          ld      DE,(YI)
5910+ 3A4E 19                   add     HL,DE           ; X=XC+YI
5911+ 3A4F 22 DD 81             ld      (X1),HL         ; store X
5912+ 3A52 CD D6 3A             call    VALIDX          ; check if X is valid (0~255)
5913+ 3A55 DA 69 3A             jp      C,CNTCL5        ; if Carry is set, X is not valid
5914+ 3A58 2A E7 81             ld      HL,(YC)
5915+ 3A5B ED 5B EB 81          ld      DE,(XI)
5916+ 3A5F 19                   add     HL,DE           ; Y=YC+XI
5917+ 3A60 22 DF 81             ld      (Y1),HL         ; store Y
5918+ 3A63 CD DB 3A             call    VALIDY          ; check if Y is valid (0~191)
5919+ 3A66 D4 69 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5920+ 3A69 AF           CNTCL5: xor     A               ; clear Carry
5921+ 3A6A 2A E5 81             ld      HL,(XC)
5922+ 3A6D ED 5B ED 81          ld      DE,(YI)
5923+ 3A71 ED 52                sbc     HL,DE           ; X=XC-YI
5924+ 3A73 22 DD 81             ld      (X1),HL         ; store X
5925+ 3A76 CD D6 3A             call    VALIDX          ; check if X is valid (0~255)
5926+ 3A79 DA 8D 3A             jp      C,CNTCL6        ; if Carry is set, X is not valid
5927+ 3A7C 2A E7 81             ld      HL,(YC)
5928+ 3A7F ED 5B EB 81          ld      DE,(XI)
5929+ 3A83 19                   add     HL,DE           ; Y=YC+XI
5930+ 3A84 22 DF 81             ld      (Y1),HL         ; store Y
5931+ 3A87 CD DB 3A             call    VALIDY          ; check if Y is valid (0~191)
5932+ 3A8A D4 69 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5933+ 3A8D 2A E5 81     CNTCL6: ld      HL,(XC)
5934+ 3A90 ED 5B ED 81          ld      DE,(YI)
5935+ 3A94 19                   add     HL,DE           ; X=XC+YI
5936+ 3A95 22 DD 81             ld      (X1),HL         ; store X
5937+ 3A98 CD D6 3A             call    VALIDX          ; check if X is valid (0~255)
5938+ 3A9B DA B1 3A             jp      C,CNTCL7        ; if Carry is set, X is not valid
5939+ 3A9E AF                   xor     A               ; clear Carry
5940+ 3A9F 2A E7 81             ld      HL,(YC)
5941+ 3AA2 ED 5B EB 81          ld      DE,(XI)
5942+ 3AA6 ED 52                sbc     HL,DE           ; Y=YC-XI
5943+ 3AA8 22 DF 81             ld      (Y1),HL         ; store Y
5944+ 3AAB CD DB 3A             call    VALIDY          ; check if Y is valid (0~191)
5945+ 3AAE D4 69 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5946+ 3AB1 AF           CNTCL7: xor     A               ; clear Carry
5947+ 3AB2 2A E5 81             ld      HL,(XC)
5948+ 3AB5 ED 5B ED 81          ld      DE,(YI)
5949+ 3AB9 ED 52                sbc     HL,DE           ; X=XC-YI
5950+ 3ABB 22 DD 81             ld      (X1),HL         ; store X
5951+ 3ABE CD D6 3A             call    VALIDX          ; check if X is valid (0~255)
5952+ 3AC1 D8                   ret     C               ; if Carry is set, X is not valid
5953+ 3AC2 AF                   xor     A               ; clear Carry
5954+ 3AC3 2A E7 81             ld      HL,(YC)
5955+ 3AC6 ED 5B EB 81          ld      DE,(XI)
5956+ 3ACA ED 52                sbc     HL,DE           ; Y=YC-XI
5957+ 3ACC 22 DF 81             ld      (Y1),HL         ; store Y
5958+ 3ACF CD DB 3A             call    VALIDY          ; check if Y is valid (0~191)
5959+ 3AD2 D4 69 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5960+ 3AD5 C9                   ret                     ; return to caller
5961+ 3AD6
5962+ 3AD6              ; check if X,Y coordinates are valid: 0<=X<=255 and 0<=Y<=191
5963+ 3AD6              ; input: HL (value to check), can be negative
5964+ 3AD6              ; output: CARRY flag: reset => VALID  //  set => NOT VALID
5965+ 3AD6              ; destroys: A
5966+ 3AD6 AF           VALIDX: xor     A               ; reset A
5967+ 3AD7 B4                   or      H               ; check if H is 0 (this means that X is in range 0~255 and not negative)
5968+ 3AD8 C8                   ret     Z               ; yes, we can return (C is clear)
5969+ 3AD9 37                   scf                     ; set Carry flag to raise error
5970+ 3ADA C9                   ret                     ; return to caller
5971+ 3ADB
5972+ 3ADB AF           VALIDY: xor     A               ; reset A
5973+ 3ADC B4                   or      H               ; check if H is 0 (this means that Y is in range 0~255 and not negative)
5974+ 3ADD 28 02                jr      Z,CNTVALY       ; yes, continue checking
5975+ 3ADF 37                   scf                     ; no, raise error by setting Carry flag
5976+ 3AE0 C9                   ret                     ; return to caller
5977+ 3AE1 7D           CNTVALY:ld      A,L
5978+ 3AE2 FE C0                cp      $C0             ; is Y<192? Carry is set if Y<192
5979+ 3AE4 3F                   ccf                     ; invert Carry, so Carry=0 means OK, Carry=1 means ERROR
5980+ 3AE5 C9                   ret                     ; return to caller
5981+ 3AE6
5982+ 3AE6
5983+ 3AE6              ; clear VIDEOBUFF before using it as temp buffer
5984+ 3AE6 AF           CLRVDBF:xor     A               ; clear A
5985+ 3AE7 C5                   push    BC              ; store BC
5986+ 3AE8 E5                   push    HL              ; store HL
5987+ 3AE9 21 DD 81             ld      HL,TMPBFR1      ; address of 1st cell
5988+ 3AEC 06 06                ld      B,$06           ; 6 cells
5989+ 3AEE 77           RPTCVB1:ld      (HL),A          ; clear cell
5990+ 3AEF 23                   inc     HL              ; next cell
5991+ 3AF0 10 FC                djnz    RPTCVB1         ; repeat
5992+ 3AF2 06 28                ld      B,$28           ; 40 cells
5993+ 3AF4 21 E5 81             ld      HL,VIDEOBUFF    ; address of 1st cell
5994+ 3AF7 77           RPTCVB2:ld      (HL),A          ; clear cell
5995+ 3AF8 23                   inc     HL              ; next cell
5996+ 3AF9 10 FC                djnz    RPTCVB2         ; repeat
5997+ 3AFB E1                   pop     HL              ; retrieve HL
5998+ 3AFC C1                   pop     BC              ; retrieve BC
5999+ 3AFD C9                   ret                     ; return to caller
6000+ 3AFE
6001+ 3AFE
6002+ 3AFE              ; check if a color is passed as argument with PLOT, DRAW, and CIRCLE
6003+ 3AFE              ; commands. If not present, the default foreground color will be used
6004+ 3AFE 3A DB 81     CLRPRM: ld      A,(FRGNDCLR)    ; load foreground color
6005+ 3B01 32 E1 81             ld      (TMPBFR3),A     ; store into temp buffer
6006+ 3B04 2B                   dec     HL              ; dec 'cos GETCHR INCs
6007+ 3B05 CD 30 1C             call    GETCHR          ; Get next character
6008+ 3B08 C8                   ret     Z               ; return foreground color if nothing follows
6009+ 3B09 CD E7 19             call    CHKSYN          ; Make sure ',' follows
6010+ 3B0C 2C                   defb    ','
6011+ 3B0D CD 47 29             call    GETINT          ; get value
6012+ 3B10 CD 0B 35             call    CHKCLR0         ; check if color is in range 0~15
6013+ 3B13 32 E1 81             ld      (TMPBFR3),A     ; store color into temp buffer
6014+ 3B16 C9                   ret                     ; return to caller
6015+ 3B17
6016+ 3B17
6017+ 3B17              ; no graphics mode error: raised when a graphics command is invoked
6018+ 3B17              ; out of graphic 2 mode.
6019+ 3B17 1E 2A        GMERR:  ld      E,GM            ; load Graphics Mode Error flag
6020+ 3B19 C3 01 17             jp      ERROR           ; print error
6021+ 3B1C
6022+ 3B1C
6023+ 3B1C              ; set a serial port: params are PORT,BPS,DATA,PARITY,STOP
6024+ 3B1C              ; PORT=1/2; BPS=1,200~57,600 (see below), DATA=5/6/7/8
6025+ 3B1C              ; PARITY: 0=no parity; 1=ODD parity; 2=EVEN parity;
6026+ 3B1C              ; STOP=0/1/2/3: 0=0 bit; 1=1 bit; 2=1.5 bits; 3=2 bits
6027+ 3B1C              ; PORT 1 acts as a char device; PORT 2 acts as a block device
6028+ 3B1C              ; DATA,PARITY, and STOP are optional: if nothing follows BPS,
6029+ 3B1C              ; they are assumed to be 8,0,1 resp.
6030+ 3B1C              PRTNUM  equ     VIDEOBUFF
6031+ 3B1C              BPS     equ     PRTNUM+$01
6032+ 3B1C              DATABT  equ     BPS+$02
6033+ 3B1C              PARBT   equ     DATABT+$01
6034+ 3B1C              STPBT   equ     PARBT+$01
6035+ 3B1C              SIOBFR  equ     STPBT+$01
6036+ 3B1C CD 47 29     SERIAL: call    GETINT          ; get port #
6037+ 3B1F A7                   and     A               ; is it zero?
6038+ 3B20 CA FB 1C             jp      Z,FCERR         ; yes, error
6039+ 3B23 FE 03                cp      $03             ; is it 1 or 2?
6040+ 3B25 D2 45 3D             jp      NC,SCERR        ; no, error
6041+ 3B28 32 E5 81             ld      (PRTNUM),A      ; store port number into a temp buffer
6042+ 3B2B CD E7 19             call    CHKSYN          ; Make sure ',' follows
6043+ 3B2E 2C                   defb    ','
6044+ 3B2F 2B                   dec     HL
6045+ 3B30 CD 30 1C             call    GETCHR          ; check what's following
6046+ 3B33 CA ED 16             jp      Z,SNERR         ; error if nothing follows
6047+ 3B36 30 05                jr      NC,SERVAR       ; it's not a number, try a variable
6048+ 3B38 CD 00 1D             call    ATOH            ; get bps (returned into DE)
6049+ 3B3B 18 0F                jr      CHKZSER         ; jump over
6050+ 3B3D CD C1 20     SERVAR: call    GETNUM          ; get number
6051+ 3B40 CD CE 2E             call    TSTSGN          ; check value
6052+ 3B43 FA FB 1C             jp      M,FCERR         ; negative - illegal function call
6053+ 3B46 3A 34 82             ld      A,(FPEXP)       ; Get integer value to DE
6054+ 3B49 CD 76 2F             call    FPINT           ; get integer number into BCDE - drop BC 'cause isn't necessary
6055+ 3B4C 7A           CHKZSER:ld      A,D             ; bps is into DE - move MSB into A
6056+ 3B4D B3                   or      E               ; check if bps=0
6057+ 3B4E 20 3A                jr      NZ,CNTSER       ; no, continue checking
6058+ 3B50                      ; if baud rate is 0, then close the serial comm.
6059+ 3B50 3A E5 81     RSTSERS:ld      A,(PRTNUM)      ; yes, so reset the channel. First, load port number
6060+ 3B53 3D                   dec     A               ; subtract 1, so that serial channel is 0=>A and 1=>B
6061+ 3B54 C6 22                add     SIO_CA          ; find correct channel
6062+ 3B56 4F                   ld      C,A             ; store serial channel
6063+ 3B57 F3                   di                      ; disable INTs
6064+ 3B58 AF                   xor     A               ; reset A
6065+ 3B59 16 01                ld      D,$01           ; start from WR1
6066+ 3B5B 06 05                ld      B,$05           ; 5 registers
6067+ 3B5D ED 51        RPTRSSR:out     (C),D           ; select register
6068+ 3B5F ED 79                out     (C),A           ; reset register
6069+ 3B61 14                   inc     D               ; next register
6070+ 3B62 10 F9                djnz    RPTRSSR         ; repeat
6071+ 3B64 3E 30                ld      A,%00110000     ; write into WR0: error reset, select WR0
6072+ 3B66 ED 79                out     (C),A           ; send command to serial channel
6073+ 3B68 3E 18                ld      A,%00011000     ; write into WR0: channel reset
6074+ 3B6A ED 79                out     (C),A           ; send command to serial channel
6075+ 3B6C FB                   ei                      ; re-enable INTs
6076+ 3B6D E5                   push    HL              ; store HL
6077+ 3B6E 21 1F 82             ld      HL,SERIALS_EN   ; serials enabled status byte
6078+ 3B71 DB 01                in      A,(PIO_DB)      ; read status LEDs
6079+ 3B73 CB 41                bit     0,C             ; check serial port
6080+ 3B75 20 09                jr      NZ,SRPT2        ; if bit is set, jump to port 2
6081+ 3B77 CB B7                res     6,A             ; it's port 1
6082+ 3B79 CB A7                res     4,A             ; remove possible error LED
6083+ 3B7B CB 86                res     0,(HL)          ; disable port 1
6084+ 3B7D C3 86 3B             jp      SERLED          ; jump over
6085+ 3B80 CB BF        SRPT2:  res     7,A             ; it's port 2
6086+ 3B82 CB AF                res     5,A             ; remove possible error LED
6087+ 3B84 CB 8E                res     1,(HL)          ; disable port 2
6088+ 3B86 D3 01        SERLED: out     (PIO_DB),A      ; send new configuration
6089+ 3B88 E1                   pop     HL              ; retrieve HL
6090+ 3B89 C9                   ret                     ; return to caller
6091+ 3B8A                      ; check if bps=1, meaning reactivate RX on serial
6092+ 3B8A 7A           CNTSER: ld      A,D
6093+ 3B8B B2                   or      D               ; check if bps<>1 by first checking D=0
6094+ 3B8C 20 36                jr      NZ,CNTSER2      ; if not, jump over
6095+ 3B8E 7B                   ld      A,E             ; then by checking that
6096+ 3B8F FE 01                cp      $01             ; E=1
6097+ 3B91 20 31                jr      NZ,CNTSER2      ; if not, jump over
6098+ 3B93 3A E5 81             ld      A,(PRTNUM)      ; load port number
6099+ 3B96 57                   ld      D,A             ; store port on D
6100+ 3B97 3A 1F 82             ld      A,(SERIALS_EN)  ; load address of serial status cell
6101+ 3B9A A2                   and     D               ; check status
6102+ 3B9B CA 45 3D             jp      Z,SCERR         ; port not open, raise error
6103+ 3B9E F3                   di                      ; disable INTs
6104+ 3B9F 7A                   ld      A,D             ; move port # into A
6105+ 3BA0 5F                   ld      E,A             ; and also into E
6106+ 3BA1 87                   add     A
6107+ 3BA2 87                   add     A               ; move A to left times 2
6108+ 3BA3 57                   ld      D,A             ; move value into D
6109+ 3BA4 3A 1F 82             ld      A,(SERIALS_EN)  ; load serial status byte
6110+ 3BA7 B2                   or      D               ; re-enable RX
6111+ 3BA8 32 1F 82             ld      (SERIALS_EN),A  ; store new serial status
6112+ 3BAB 7B                   ld      A,E             ; recover port #
6113+ 3BAC 3D                   dec     A               ; check port
6114+ 3BAD 20 0A                jr      NZ,CNTRX2       ; port is #2
6115+ 3BAF CD E3 01             call    SIO_A_EI        ; re-enable RX on port 1
6116+ 3BB2 DB 01                in      A,(PIO_DB)      ; load status LEDs
6117+ 3BB4 CB A7                res     4,A             ; remove error LED
6118+ 3BB6 C3 C0 3B             jp      RXEND           ; terminate setting
6119+ 3BB9 CD EB 01     CNTRX2: call    SIO_B_EI        ; re-enable RX on port 2
6120+ 3BBC DB 01                in      A,(PIO_DB)      ; load status LEDs
6121+ 3BBE CB AF                res     5,A             ; remove error LED
6122+ 3BC0 D3 01        RXEND:  out     (PIO_DB),A      ; set new status for LEDs
6123+ 3BC2 FB                   ei                      ; re-enable INTs
6124+ 3BC3 C9                   ret                     ; return to caller
6125+ 3BC4                      ; set serial port comm.
6126+ 3BC4 D5           CNTSER2:push    DE              ; store BPS
6127+ 3BC5 3A E5 81             ld      A,(PRTNUM)      ; load port number
6128+ 3BC8 57                   ld      D,A             ; move port # into D
6129+ 3BC9 3A 1F 82             ld      A,(SERIALS_EN)  ; check if serial port is already open
6130+ 3BCC A2                   and     D               ; by ANDing A with D
6131+ 3BCD D1                   pop     DE              ; retrieve BPS
6132+ 3BCE CA D6 3B             jp      Z,CNTSER3       ; not open, continue
6133+ 3BD1 1E 2E                ld      E,SA            ; already open, so raise a "Serial Port Already Error"
6134+ 3BD3 C3 01 17             jp      ERROR           ; and leave
6135+ 3BD6 E5           CNTSER3:push    HL              ; store HL
6136+ 3BD7 21 00 E1             ld      HL,$E100        ; check bps. start with HL=57,600
6137+ 3BDA CD 04 40             call    CMP16           ; is bps<=57,600?
6138+ 3BDD E1                   pop     HL              ; but first, recover HL
6139+ 3BDE DA 45 3D             jp      C,SCERR         ; no (bps>57,600) then error
6140+ 3BE1 ED 53 E6 81          ld      (BPS),DE        ; store bps
6141+ 3BE5 2B                   dec     HL              ; dec 'cos GETCHR INCs
6142+ 3BE6 CD 30 1C             call    GETCHR          ; Get next character
6143+ 3BE9 CA 21 3C             jp      Z,DEFSER        ; defaults if nothing follows
6144+ 3BEC CD E7 19             call    CHKSYN          ; Make sure ',' follows
6145+ 3BEF 2C                   defb    ','
6146+ 3BF0 CD 47 29             call    GETINT          ; get data bits
6147+ 3BF3 FE 05                cp      $05             ; is it <5?
6148+ 3BF5 DA 45 3D             jp      C,SCERR         ; yes, error
6149+ 3BF8 FE 09                cp      $09             ; is it >=9?
6150+ 3BFA D2 FB 1C             jp      NC,FCERR        ; yes, error
6151+ 3BFD 32 E8 81             ld      (DATABT),A      ; store data bits
6152+ 3C00 CD E7 19             call    CHKSYN          ; Make sure ',' follows
6153+ 3C03 2C                   defb    ','
6154+ 3C04 CD 47 29             call    GETINT          ; get parity bits
6155+ 3C07 BF FE 03             cp      A,$03           ; check if parity is in range 0~2
6156+ 3C0A D2 45 3D             jp      NC,SCERR        ; no, error
6157+ 3C0D 32 E9 81             ld      (PARBT),A       ; store parity
6158+ 3C10 CD E7 19             call    CHKSYN          ; Make sure ',' follows
6159+ 3C13 2C                   defb    ','
6160+ 3C14 CD 47 29             call    GETINT          ; get stop bits
6161+ 3C17 FE 03                cp      $03             ; is it >=3?
6162+ 3C19 D2 45 3D             jp      NC,SCERR        ; yes, error
6163+ 3C1C 32 EA 81             ld      (STPBT),A       ; store stop bits
6164+ 3C1F 18 0D                jr      SETSER          ; jump to set serial
6165+ 3C21 3E 08        DEFSER: ld      A,$08           ; 8 bits for data
6166+ 3C23 32 E8 81             ld      (DATABT),A
6167+ 3C26 AF                   xor     A               ; no parity bit
6168+ 3C27 32 E9 81             ld      (PARBT),A
6169+ 3C2A 3C                   inc     A               ; 1 bit for stop
6170+ 3C2B 32 EA 81             ld      (STPBT),A
6171+ 3C2E                      ; check if bps are legal
6172+ 3C2E E5           SETSER: push    HL              ; store HL
6173+ 3C2F D5                   push    DE              ; store DE
6174+ 3C30 DD E5                push    IX              ; store IX
6175+ 3C32 DD 21 20 3D          ld      IX,SUP_BPS      ; allowed BPSs
6176+ 3C36 06 0B                ld      B,$0B           ; 11 items
6177+ 3C38 0E 00                ld      C,$00           ; reset pointer
6178+ 3C3A 2A E6 81     CKBPS:  ld      HL,(BPS)        ; load BPS
6179+ 3C3D DD 5E 00             ld      E,(IX+0)        ; load LSB of item
6180+ 3C40 DD 56 01             ld      D,(IX+1)        ; load MSB of item
6181+ 3C43 CD 04 40             call    CMP16           ; is it equal?
6182+ 3C46 CA 53 3C             jp      Z,SET_PT        ; yes, found a correspondance
6183+ 3C49 DD 23                inc     IX
6184+ 3C4B DD 23                inc     IX              ; no, go to next entry
6185+ 3C4D 0C                   inc     C               ; increment pointer
6186+ 3C4E 10 EA                djnz    CKBPS           ; repeat for 10 entries
6187+ 3C50 C3 41 3D             jp      SCERR1          ; if nothing found, raise an error
6188+ 3C53              SET_PT: ;init CTC CH0: CH0 provides RX/TX clock to SIO port A
6189+ 3C53                      ; TO0 output frequency=INPUT CLK/time constant. Time constant is set to get 16 times
6190+ 3C53                      ; the requested baud rate. I.e., if bps is 19,200 then time constast is set to 6 because
6191+ 3C53                      ; 1,843,200/6 = 307,200 Hz (that is 19,200 x 16)
6192+ 3C53 F3                   di                      ; disable INTs
6193+ 3C54 06 00                ld      B,$00           ; reset B
6194+ 3C56 21 36 3D             ld      HL,CTC_CFG      ; address of first CTC divider
6195+ 3C59 09                   add     HL,BC           ; adjust for correct CTC divider
6196+ 3C5A 0E 10                ld      C,CTC_CH0       ; CTC channel 0
6197+ 3C5C 3A E5 81             ld      A,(PRTNUM)      ; load port number
6198+ 3C5F 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6199+ 3C60 DA 64 3C             jp      C,SET_CTC       ; port 1 => ch. 0, so continue
6200+ 3C63 0C                   inc     C               ; port 2 => ch. 1, increment address port into C
6201+ 3C64 3E 47        SET_CTC:ld      A,%01000111     ; interrupt off, counter mode, prsc=16 (doesn't matter), ext. start,
6202+ 3C66                                              ; start upon loading time constant, time constant follows, sw reset, command word
6203+ 3C66 ED 79                out     (C),A           ; configure CTC channel
6204+ 3C68 7E                   ld      A,(HL)          ; load CTC divider
6205+ 3C69 ED 79                out     (C),A           ; send divider
6206+ 3C6B                      ; configure SIO
6207+ 3C6B 21 54 03             ld      HL,SIO_A_SETS   ; load default settings for SIO
6208+ 3C6E 11 EB 81             ld      DE,SIOBFR       ; into a temp buffer
6209+ 3C71 01 0A 00             ld      BC,$000A        ; 10 items to copy
6210+ 3C74 ED B0                ldir                    ; copy SIO settings into TEMP buffer
6211+ 3C76 3A F0 81             ld      A,(SIOBFR+5)    ; load WR5 setting
6212+ 3C79 47                   ld      B,A             ; move it into B
6213+ 3C7A 3A E8 81             ld      A,(DATABT)      ; load DATA bits
6214+ 3C7D FE 05                cp      $05             ; is it 5 bits?
6215+ 3C7F 20 06                jr      NZ,BITS6        ; no, jump over
6216+ 3C81 CB B0                res     6,B
6217+ 3C83 CB A8                res     5,B             ; set D6 & D5 to 0
6218+ 3C85 18 19                jr      SETPAR          ; jump to set parity
6219+ 3C87 FE 06        BITS6:  cp      $06             ; is it 6 bits?
6220+ 3C89 20 06                jr      NZ,BITS7        ; no, jump over
6221+ 3C8B CB F0                set     6,B
6222+ 3C8D CB A8                res     5,B             ; set D6 & D5 to 1,0
6223+ 3C8F 18 0F                jr      SETPAR          ; jump to set parity
6224+ 3C91 FE 07        BITS7:  cp      $07             ; is it 7 bits?
6225+ 3C93 20 07                jr      NZ,BITS8        ; no, jump over
6226+ 3C95 CB B0                res     6,B
6227+ 3C97 CB E8                set     5,B             ; set D6 & D5 to 0,1
6228+ 3C99 C3 A0 3C             jp      SETPAR          ; jump to set parity
6229+ 3C9C CB F0        BITS8:  set     6,B
6230+ 3C9E CB E8                set     5,B             ; set D6 & D5 to 1,1
6231+ 3CA0 21 20 82     SETPAR: ld      HL,SERABITS     ; load address for storing data bits
6232+ 3CA3 3A E5 81             ld      A,(PRTNUM)      ; check serial port number
6233+ 3CA6 3D                   dec     A               ; is it port #1?
6234+ 3CA7 CA AB 3C             jp      Z,SETPAR2       ; yes, jump over
6235+ 3CAA 23                   inc     HL              ; port #2, use SERBBITS instead
6236+ 3CAB 78           SETPAR2:ld      A,B             ; retrieve DATA bits
6237+ 3CAC 32 F0 81             ld      (SIOBFR+5),A    ; save DATA bits
6238+ 3CAF E6 60                and     %01100000       ; filter only D5&D6 bits
6239+ 3CB1 87                   add     A,A             ; shift left times 1
6240+ 3CB2 77                   ld      (HL),A          ; store for SIO_EI & SIO_DI functions
6241+ 3CB3 3A EA 81             ld      A,(STPBT)       ; load STOP bits
6242+ 3CB6 87                   add     A,A
6243+ 3CB7 87                   add     A,A             ; 2 left shifts
6244+ 3CB8 47                   ld      B,A             ; move forming byte into B
6245+ 3CB9 3A E9 81             ld      A,(PARBT)       ; load PARITY setting
6246+ 3CBC A7                   and     A               ; is it 0?
6247+ 3CBD CA C8 3C             jp      Z,STRPAR        ; yes, jump over
6248+ 3CC0 CB C0                set     0,B             ; set PARITY on
6249+ 3CC2 3D                   dec     A               ; is parity ODD?
6250+ 3CC3 CA C8 3C             jp      Z,STRPAR        ; yes, so jump over
6251+ 3CC6 CB C8                set     1,B             ; no, it's EVEN so set the corresponding bit
6252+ 3CC8 3A EE 81     STRPAR: ld      A,(SIOBFR+3)    ; load WR4 setting
6253+ 3CCB E6 F0                and     %11110000       ; reset STOP & PARITY bits
6254+ 3CCD B0                   or      B               ; set new STOP & PARITY bits
6255+ 3CCE 32 EE 81             ld      (SIOBFR+3),A    ; store new value
6256+ 3CD1                      ;set up TX and RX:
6257+ 3CD1                      ; the followings are settings for channel A
6258+ 3CD1 21 EB 81             ld      HL,SIOBFR       ; settings for SIO ch. A
6259+ 3CD4 06 06                ld      B,$06           ; 6 bytes to send
6260+ 3CD6 0E 22                ld      C,SIO_CA        ; I/O address of SIO ch.A
6261+ 3CD8 3A E5 81             ld      A,(PRTNUM)      ; load port number
6262+ 3CDB 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6263+ 3CDC DA E0 3C             jp      C,SRLCNT        ; port 1, continue
6264+ 3CDF 0C                   inc     C               ; port 2, increment address port into C
6265+ 3CE0 ED B3        SRLCNT: otir                    ; send bytes to SIO
6266+ 3CE2                      ; the following are settings for channel B (don't need to load HL since settings are contigous)
6267+ 3CE2 06 04                ld      B,$04           ; other 4 bytes to send
6268+ 3CE4 51                   ld      D,C             ; store port address into D
6269+ 3CE5 0E 23                ld      C,SIO_CB        ; I/O address of SIO ch.B
6270+ 3CE7 ED B3                otir                    ; send bytes to SIO
6271+ 3CE9                      ; the following are settings for selected channel
6272+ 3CE9 3E 01                ld      A,$01           ; write into WR0: select WR1
6273+ 3CEB 4A                   ld      C,D             ; retrieve port address
6274+ 3CEC ED 79                out     (C),A
6275+ 3CEE 3E 18                ld      A,%00011000     ; interrupts on every RX char; parity is no special condition;
6276+ 3CF0                                              ; buffer overrun is special condition
6277+ 3CF0 ED 79                out     (C),A
6278+ 3CF2 21 1F 82             ld      HL,SERIALS_EN
6279+ 3CF5 3A E5 81             ld      A,(PRTNUM)      ; retrieve serial channel
6280+ 3CF8 3D                   dec     A               ; channel A?
6281+ 3CF9 20 10                jr      NZ,ENCHB        ; no, jump over
6282+ 3CFB CD E3 01             call    SIO_A_EI        ; enable RX on SIO channel A
6283+ 3CFE CB C6                set     0,(HL)          ; set serial port 1 status ON
6284+ 3D00 CB D6                set     2,(HL)          ; set serial port 1 RX ON
6285+ 3D02                      ; back to normal running
6286+ 3D02 FB                   ei                      ; re-enable INTs
6287+ 3D03 DB 01                in      A,(PIO_DB)      ; load status LEDs
6288+ 3D05 CB F7                set     6,A             ; set status LED on
6289+ 3D07 CB A7                res     4,A             ; set error LED off
6290+ 3D09 18 0E                jr      EXNRM           ; leave
6291+ 3D0B CD EB 01     ENCHB:  call    SIO_B_EI        ; enable RX on SIO channel B
6292+ 3D0E CB CE                set     1,(HL)          ; set serial port 2 status ON
6293+ 3D10 CB DE                set     3,(HL)          ; set serial port 2 RX ON
6294+ 3D12                      ; back to normal running
6295+ 3D12 FB                   ei                      ; re-enable INTs
6296+ 3D13 DB 01                in      A,(PIO_DB)      ; load status LEDs
6297+ 3D15 CB FF                set     7,A             ; set status LED on
6298+ 3D17 CB AF                res     5,A             ; set error LED off
6299+ 3D19 D3 01        EXNRM:  out     (PIO_DB),A      ; send new configuration
6300+ 3D1B DD E1                pop     IX              ; retrieve IX
6301+ 3D1D D1                   pop     DE              ; retrieve DE
6302+ 3D1E E1                   pop     HL              ; retrieve HL
6303+ 3D1F C9                   ret                     ; return to caller
6304+ 3D20
6305+ 3D20              ; allowed bps (Bauds per second)
6306+ 3D20 00 E1 00 96  SUP_BPS:defw    57600,38400,28800,19200,14400,9600,4800,3600,2400,1200,600
6306+ 3D24 80 70 00 4B
6306+ 3D28 40 38 80 25
6306+ 3D2C C0 12 10 0E
6306+ 3D30 60 09 B0 04
6306+ 3D34 58 02
6307+ 3D36              ; corresponding CTC divider
6308+ 3D36 02 03 04 06  CTC_CFG:defb    2,3,4,6,8,12,24,32,48,96,192
6308+ 3D3A 08 0C 18 20
6308+ 3D3E 30 60 C0
6309+ 3D41
6310+ 3D41
6311+ 3D41              ; serial configuration error
6312+ 3D41 DD E1        SCERR1: pop     IX              ; retrieve IX
6313+ 3D43 D1                   pop     DE              ; retrieve DE
6314+ 3D44 E1                   pop     HL              ; retrieve HL
6315+ 3D45 1E 2C        SCERR:  ld      E,SC            ; Serial Configuration Error
6316+ 3D47 C3 01 17             jp      ERROR           ; print error
6317+ 3D4A
6318+ 3D4A
6319+ 3D4A              ; serial buffer overrun
6320+ 3D4A CD FD 1E     SOERR:  call    PRNTCRLF
6321+ 3D4D 1E 30                ld      E,SO            ; Serial Buffer Overrun
6322+ 3D4F C3 01 17             jp      ERROR
6323+ 3D52
6324+ 3D52
6325+ 3D52              ; check for direct mode
6326+ 3D52 E5           DIRMOD: push    HL              ; Save code string address
6327+ 3D53 2A AF 80             ld      HL,(LINEAT)     ; Get current line number
6328+ 3D56 23                   inc     HL              ; -1 means direct statement
6329+ 3D57 7C                   ld      A,H
6330+ 3D58 B5                   or      L
6331+ 3D59 E1                   pop     HL              ; Restore code string address
6332+ 3D5A C2 74 3D             jp      NZ,HLPERR       ; raise error if in indirect mode
6333+ 3D5D C9                   ret
6334+ 3D5E
6335+ 3D5E
6336+ 3D5E              ; HELP lists the line program where an error occured
6337+ 3D5E CD 52 3D     HELP:   call    DIRMOD          ; check if in direct mode
6338+ 3D61 E5                   push    HL              ; store HL
6339+ 3D62 2A B1 80             ld      HL,(HLPLN)      ; load HELP line
6340+ 3D65 23                   inc     HL              ; increment HL
6341+ 3D66 7C                   ld      A,H
6342+ 3D67 B5                   or      L               ; check if there is a line into the HELP reg.
6343+ 3D68 E1                   pop     HL
6344+ 3D69 CA 74 3D             jp      Z,HLPERR        ; no line found, raise error
6345+ 3D6C ED 5B B1 80          ld      DE,(HLPLN)      ; recover line
6346+ 3D70 C1                   pop     BC              ; remove BC from stack since it's not needed anymore for LIST
6347+ 3D71 C3 7D 1A             jp      LST01H          ; jump to list line
6348+ 3D74 1E 32        HLPERR: ld      E,HP            ; HELP call error
6349+ 3D76 C3 01 17             jp      ERROR           ; raise error
6350+ 3D79
6351+ 3D79
6352+ 3D79              ; KEY command to list/modify function keys and auto-repeat
6353+ 3D79 2B           KEY:    dec     HL              ; dec 'cos GETCHR INCs
6354+ 3D7A CD 30 1C             call    GETCHR          ; Get next character
6355+ 3D7D CA FD 3D             jp      Z,LSTKEYS       ; jump if nothing follows
6356+ 3D80                      ; change FN keys
6357+ 3D80 CD 47 29             call    GETINT          ; get a number
6358+ 3D83 A7                   and     A               ; is it 0?
6359+ 3D84 20 10                jr      NZ,KEYCH        ; no, jump over
6360+ 3D86 E5           RESFN:  push    HL              ; yes - reset FN keys to defaults
6361+ 3D87 D5                   push    DE              ; store HL & DE
6362+ 3D88 21 DB 15             ld      HL,AUTORP       ; pointer to default auto-repeat delays and FN keys texts
6363+ 3D8B 11 B3 80             ld      DE,KEYDEL       ; pointer to destination
6364+ 3D8E 01 82 00             ld      BC,$0082        ; 130 chars to be copied (2xauto-delay, 128xFN keys)
6365+ 3D91 ED B0                ldir                    ; restore default texts
6366+ 3D93 D1                   pop     DE              ; retrieve DE
6367+ 3D94 E1                   pop     HL              ; retrieve HL
6368+ 3D95 C9                   ret                     ; return to caller
6369+ 3D96 FE 09        KEYCH:  cp      $09             ; is it >= 9?
6370+ 3D98 D2 B0 3E             jp      NC,SETREP       ; yes - jump over
6371+ 3D9B 3D                   dec     A               ; FN key in range 0~7
6372+ 3D9C 87                   add     A,A             ; multiply A...
6373+ 3D9D 87                   add     A,A             ; ... times 4...
6374+ 3D9E 87                   add     A,A             ; ... to get the correct...
6375+ 3D9F 87                   add     A,A             ; ... offset fo FN key text
6376+ 3DA0 32 DD 81             ld      (TMPBFR1),A     ; store FN key offset...
6377+ 3DA3 AF                   xor     A               ; ...in a...
6378+ 3DA4 32 DE 81             ld      (TMPBFR1+1),A   ; ...16-bit register
6379+ 3DA7 CD E7 19             call    CHKSYN          ; Make sure ',' follows
6380+ 3DAA 2C                   defb    ','
6381+ 3DAB 44 4D                ld      BC,HL           ; copy address into BC
6382+ 3DAD CD D3 20             call    EVAL            ; Evaluate expression (in E there is the length)
6383+ 3DB0 E5                   push    HL              ; store string pointer
6384+ 3DB1 3A 94 81             ld      A,(TYPE)        ; Get variable type
6385+ 3DB4 B7                   or      A               ; Is it a string variable?
6386+ 3DB5 CA ED 16             jp      Z,SNERR         ; no - syntax error
6387+ 3DB8 CD 0C 27             call    GSTRCU          ; Current string to pool
6388+ 3DBB CD 1D 2F             call    LOADFP          ; Move string block data to (BC=pointer, DE=length)
6389+ 3DBE 7B                   ld      A,E             ; copy length into A
6390+ 3DBF FE 11                cp      $11             ; is length > 16?
6391+ 3DC1 DA C6 3D             jp      C,DECLN1        ; no, jump over
6392+ 3DC4 1E 10                ld      E,$10           ; yes, so set length to 16
6393+ 3DC6 3E 10        DECLN1: ld      A,$10           ; calculate how many...
6394+ 3DC8 93                   sub     E               ; ...null chars needed to fill up...
6395+ 3DC9 57                   ld      D,A             ; ...the FN key text
6396+ 3DCA C5                   push    BC              ; store address of string
6397+ 3DCB ED 4B DD 81          ld      BC,(TMPBFR1)    ; load FN key offset
6398+ 3DCF 21 B5 80             ld      HL,FNKEYS       ; load address of FN keys texts
6399+ 3DD2 09                   add     HL,BC           ; get corrected address
6400+ 3DD3 C1                   pop     BC              ; retrieve address of string chars
6401+ 3DD4 0A           CPKEY:  ld      A,(BC)          ; load char from string
6402+ 3DD5 FE 0D                cp      CR              ; return?
6403+ 3DD7 CA E4 3D             jp      Z,CPKEY2        ; yes, store char
6404+ 3DDA FE 7B                cp      $7B             ; if char > "z" ?
6405+ 3DDC D2 ED 16             jp      NC,SNERR        ; yes - syntax error
6406+ 3DDF FE 20                cp      $20             ; is char < space?
6407+ 3DE1 DA ED 16             jp      C,SNERR         ; yes - syntax error
6408+ 3DE4 FE 61        CPKEY2: cp      $61             ; is it >= 'a'?
6409+ 3DE6 DA EB 3D             jp      C,CPKEY3        ; no, continue
6410+ 3DE9 E6 5F                and     %01011111       ; set letters to uppercase
6411+ 3DEB 77           CPKEY3: ld      (HL),A          ; store char
6412+ 3DEC 23                   inc     HL              ; next string char
6413+ 3DED 03                   inc     BC              ; next free cell
6414+ 3DEE 1D                   dec     E               ; decrement E
6415+ 3DEF 20 E3                jr      NZ,CPKEY        ; repeat until 0
6416+ 3DF1 AF                   xor     A               ; null char
6417+ 3DF2 14                   inc     D               ; +1 to decrement below
6418+ 3DF3 15           CPKEY1: dec     D               ; how many null chars to insert?
6419+ 3DF4 CA FB 3D             jp      Z,CPKYEND       ; no more nulls, so exit
6420+ 3DF7 77                   ld      (HL),A          ; store it
6421+ 3DF8 23                   inc     HL              ; next cell
6422+ 3DF9 18 F8                jr      CPKEY1          ; repeat
6423+ 3DFB E1           CPKYEND:pop     HL              ; retrieve pointer to string
6424+ 3DFC C9                   ret                     ; return to caller
6425+ 3DFD                                              ; list FN keys
6426+ 3DFD E5           LSTKEYS:push    HL              ; Save code string address
6427+ 3DFE 2A AF 80             ld      HL,(LINEAT)     ; Get current line number
6428+ 3E01 23                   inc     HL              ; -1 means direct statement
6429+ 3E02 7C                   ld      A,H
6430+ 3E03 B5                   or      L
6431+ 3E04 E1                   pop     HL              ; Restore code string address
6432+ 3E05 C2 ED 16             jp      NZ,SNERR        ; raise error if in indirect mode
6433+ 3E08 E5                   push    HL              ; store HL
6434+ 3E09 D5                   push    DE              ; store DE
6435+ 3E0A 21 B5 80             ld      HL,FNKEYS       ; load starting address of FN keys text
6436+ 3E0D 0E 01                ld      C,$01           ; 8 function keys
6437+ 3E0F 06 10        PRTK4:  ld      B,$10           ; 16 chars each
6438+ 3E11 11 D2 3E     PRTK2:  ld      DE,CHKEY1       ; message "KEY "
6439+ 3E14 CD A1 3E             call    PRTCKEY         ; print it
6440+ 3E17 79                   ld      A,C             ; load FN key
6441+ 3E18 C6 30                add     $30             ; get number in ASCI code
6442+ 3E1A CD F2 19             call    OUTC            ; print it
6443+ 3E1D 11 D7 3E             ld      DE,CHKEY2       ; message ": ""
6444+ 3E20 CD A1 3E             call    PRTCKEY         ; print it
6445+ 3E23 3E 01                ld      A,$01           ; " opened
6446+ 3E25 32 DD 81             ld      (TMPBFR1),A
6447+ 3E28 7E           LDKEY:  ld      A,(HL)          ; retrieve char
6448+ 3E29 A7                   and     A               ; is it zero?
6449+ 3E2A CA 3D 3E             jp      Z,CNTLTK        ; yes, go next char
6450+ 3E2D CD 89 3E             call    OPNQT           ; check if quotes are opened
6451+ 3E30 FE 22                cp      $22             ; check if char is "?
6452+ 3E32 CA 52 3E             jp      Z,PRTCHR        ; yes, print "chr$("
6453+ 3E35 FE 0D                cp      CR              ; is it a CR?
6454+ 3E37 CA 52 3E             jp      Z,PRTCHR        ; yes, print "chr$("
6455+ 3E3A CD F2 19     PRTK3:  call    OUTC            ; no, just print it
6456+ 3E3D 23           CNTLTK: inc     HL              ; next char
6457+ 3E3E 10 E8                djnz    LDKEY           ; continue until finished
6458+ 3E40 CD 77 3E             call    CLSQT           ; check if quotes are still open
6459+ 3E43 3E 0D                ld      A,CR            ; go next line
6460+ 3E45 CD F2 19             call    OUTC            ; print it
6461+ 3E48 0C                   inc     C               ; next FN key
6462+ 3E49 79                   ld      A,C             ; check if...
6463+ 3E4A FE 09                cp      $09             ; finished keys?
6464+ 3E4C DA 0F 3E             jp      C,PRTK4         ; no, repeat 1 more time
6465+ 3E4F D1                   pop     DE              ; retrieve DE
6466+ 3E50 E1                   pop     HL              ; retrieve HL
6467+ 3E51 C9                   ret                     ; return to caller
6468+ 3E52 E5           PRTCHR: push    HL              ; store HL
6469+ 3E53 CD 77 3E             call    CLSQT           ; check if quotes are closed
6470+ 3E56 3E 2B                ld      A,'+'           ; '+' char
6471+ 3E58 CD F2 19             call    OUTC            ; print it
6472+ 3E5B 11 DA 3E             ld      DE,CHKEY3       ; address of "CHR$("
6473+ 3E5E CD A1 3E             call    PRTCKEY         ; print it
6474+ 3E61 E1                   pop     HL              ; recover HL
6475+ 3E62 23                   inc     HL              ; next char
6476+ 3E63 05                   dec     B               ; increment char counter
6477+ 3E64 11 E0 3E             ld      DE,CHKEY4       ; load address of RETURN
6478+ 3E67 7E                   ld      A,(HL)          ; load char
6479+ 3E68 FE 0D                cp      CR              ; is it a RETURN?
6480+ 3E6A 20 03                jr      NZ,PTCHR1       ; no, jump over
6481+ 3E6C 11 E3 3E             ld      DE,CHKEY5       ; yes, load address of "
6482+ 3E6F CD A1 3E     PTCHR1: call    PRTCKEY         ; print it
6483+ 3E72 3E 29                ld      A,')'           ; char )
6484+ 3E74 C3 3A 3E             jp      PRTK3           ; continue
6485+ 3E77 F5           CLSQT:  push    AF              ; store A
6486+ 3E78 3A DD 81             ld      A,(TMPBFR1)     ; quote status
6487+ 3E7B A7                   and     A               ; are they closed?
6488+ 3E7C 28 09                jr      Z,CLSQT1        ; if yes, return
6489+ 3E7E 3E 22                ld      A,$22           ; no, so close them
6490+ 3E80 CD F2 19             call    OUTC            ; print "
6491+ 3E83 AF                   xor     A               ; set quotes
6492+ 3E84 32 DD 81             ld      (TMPBFR1),A     ; as closed
6493+ 3E87 F1           CLSQT1: pop     AF              ; retrieve A
6494+ 3E88 C9                   ret                     ; return to caller
6495+ 3E89 F5           OPNQT:  push    AF              ; store A
6496+ 3E8A 3A DD 81             ld      A,(TMPBFR1)     ; quote status
6497+ 3E8D A7                   and     A               ; are they open?
6498+ 3E8E 20 0F                jr      NZ,OPNQT1       ; if yes, return
6499+ 3E90 3E 2B                ld      A,'+'           ; no, so add '+
6500+ 3E92 CD F2 19             call    OUTC            ; print it
6501+ 3E95 3E 22                ld      A,$22           ; and then open quotes
6502+ 3E97 CD F2 19             call    OUTC            ; print them
6503+ 3E9A 3E 01                ld      A,$01           ; set quotes
6504+ 3E9C 32 DD 81             ld      (TMPBFR1),A     ; as opened
6505+ 3E9F F1           OPNQT1: pop     AF              ; retrieve A
6506+ 3EA0 C9                   ret                     ; return to caller
6507+ 3EA1 F5           PRTCKEY:push    AF              ; store original char
6508+ 3EA2 1A           PRTK1:  ld      A,(DE)          ; load char
6509+ 3EA3 A7                   and     A               ; is it 0?
6510+ 3EA4 CA AE 3E             jp      Z,PRTEND        ; yes, finished printing
6511+ 3EA7 CD F2 19             call    OUTC            ; no, print char
6512+ 3EAA 13                   inc     DE              ; next char
6513+ 3EAB C3 A2 3E             jp      PRTK1           ; repeat
6514+ 3EAE F1           PRTEND: pop     AF              ; retrieve AF
6515+ 3EAF C9                   ret                     ; return to caller
6516+ 3EB0 FE 09        SETREP: cp      $09             ; is it special key 9? (stands for auto-repeat)
6517+ 3EB2 C2 ED 16             jp      NZ,SNERR        ; no, raise an error
6518+ 3EB5 CD E7 19             call    CHKSYN          ; Check for comma
6519+ 3EB8 2C                   defb    ','
6520+ 3EB9 CD 47 29             call    GETINT          ; get a number
6521+ 3EBC 32 DD 81             ld      (TMPBFR1),A     ; store it
6522+ 3EBF CD E7 19             call    CHKSYN          ; Check for comma
6523+ 3EC2 2C                   defb    ','
6524+ 3EC3 CD 47 29             call    GETINT          ; get another number
6525+ 3EC6 E5                   push    HL              ; store HL
6526+ 3EC7 21 B4 80             ld      HL,AUTOKE       ; address of second cell for key auto-repeat
6527+ 3ECA 77                   ld      (HL),A          ; store auto-repeat delay
6528+ 3ECB 2B                   dec     HL              ; previous cell
6529+ 3ECC 3A DD 81             ld      A,(TMPBFR1)     ; retrieve value
6530+ 3ECF 77                   ld      (HL),A          ; store delay for auto-repeat
6531+ 3ED0 E1                   pop     HL              ; retrieve HL
6532+ 3ED1 C9                   ret
6533+ 3ED2 4B 45 59 20  CHKEY1: defb    "KEY ",0
6533+ 3ED6 00
6534+ 3ED7 3A 22 00     CHKEY2: defb    ":",34,0
6535+ 3EDA 63 68 72 24  CHKEY3: defb    "chr$(",0
6535+ 3EDE 28 00
6536+ 3EE0 31 33 00     CHKEY4: defb    "13",0
6537+ 3EE3 33 34 00     CHKEY5: defb    "34",0
6538+ 3EE6
6539+ 3EE6
6540+ 3EE6              ; LOAD "filename"
6541+ 3EE6              ; load a BASIC program from disk
6542+ 3EE6 C9           LOAD:   ret                     ; currently a stub for LOAD
6543+ 3EE7
6544+ 3EE7
6545+ 3EE7              ; SAVE "filename"
6546+ 3EE7              ; save a BASIC program on disk
6547+ 3EE7 C9           SAVE:   ret                     ; currently a stub for SAVE
6548+ 3EE8
6549+ 3EE8
6550+ 3EE8              ; FILES
6551+ 3EE8              ; list files on disk
6552+ 3EE8 C9           FILES:  ret                     ; currently a stub for FILES
6553+ 3EE9
6554+ 3EE9
6555+ 3EE9              ; ERASE "filename"
6556+ 3EE9              ; erase a file from disk
6557+ 3EE9 C9           ERASE:  ret                     ; currently a stub for ERASE
6558+ 3EEA
6559+ 3EEA
6560+ 3EEA              ; HEX$(nn) Convert 16 bit number to Hexadecimal string
6561+ 3EEA CD C4 20     HEX: 	call	TSTNUM          ; Verify it's a number
6562+ 3EED CD E6 1C             call	DEINT           ; Get integer -32768 to 32767
6563+ 3EF0 C5                   push	BC              ; Save contents of BC
6564+ 3EF1 21 36 82             ld      HL,PBUFF        ; load address of PBUFF into HL
6565+ 3EF4 7A                   ld      A,D             ; Get MSB into A
6566+ 3EF5 B7                   or      A               ; OR with LSB to see if param=0
6567+ 3EF6 28 0C                jr      Z,HEX2          ; Skip output if both high digits are zero
6568+ 3EF8 CD 20 3F             call    BYT2ASC         ; Convert D to ASCII
6569+ 3EFB 78                   ld      A,B             ; cechk if B
6570+ 3EFC FE 30                cp      '0'             ; is 0
6571+ 3EFE 28 02                jr      Z,HEX1          ; Don't store high digit if zero
6572+ 3F00 70                   ld      (HL),B          ; Store it to PBUFF
6573+ 3F01 23                   inc     HL              ; Next location
6574+ 3F02 71           HEX1:   ld      (HL),C          ; Store C to PBUFF+1
6575+ 3F03 23                   inc     HL              ; Next location
6576+ 3F04 7B           HEX2:   ld      A,E             ; Get lower byte
6577+ 3F05 CD 20 3F             call    BYT2ASC         ; Convert E to ASCII
6578+ 3F08 7A                   ld      A,D
6579+ 3F09 B7                   or      A
6580+ 3F0A 20 05                jr      NZ,HEX3         ; If upper byte was not zero then always print lower byte
6581+ 3F0C 78                   ld      A,B
6582+ 3F0D FE 30                cp      '0'             ; If high digit of lower byte is zero then don't print
6583+ 3F0F 28 02                jr      Z,HEX4
6584+ 3F11 70           HEX3:   ld      (HL),B          ; to PBUFF+2
6585+ 3F12 23                   inc     HL              ; Next location
6586+ 3F13 71           HEX4:   ld      (HL),C          ; to PBUFF+3
6587+ 3F14 23                   inc     HL              ; PBUFF+4 to zero
6588+ 3F15 AF                   xor     A               ; Terminating character
6589+ 3F16 77                   ld      (HL),A          ; Store zero to terminate
6590+ 3F17 23                   inc     HL              ; Make sure PBUFF is terminated
6591+ 3F18 77                   ld      (HL),A          ; Store the double zero there
6592+ 3F19 C1                   pop     BC              ; Get BC back
6593+ 3F1A 21 36 82             ld      HL,PBUFF        ; Reset to start of PBUFF
6594+ 3F1D C3 59 25             jp      STR1            ; Convert the PBUFF to a string and return it
6595+ 3F20 47           BYT2ASC:ld      B,A             ; Save original value
6596+ 3F21 E6 0F                and     $0F             ; Strip off upper nybble
6597+ 3F23 FE 0A                cp      $0A             ; 0-9?
6598+ 3F25 38 02                jr      C,ADD30         ; If A-F, add 7 more
6599+ 3F27 C6 07                add     A,$07           ; Bring value up to ASCII A-F
6600+ 3F29 C6 30        ADD30:  add     A,$30           ; And make ASCII
6601+ 3F2B 4F                   ld      C,A             ; Save converted char to C
6602+ 3F2C 78                   ld      A,B             ; Retrieve original value
6603+ 3F2D 0F                   rrca                    ; and Rotate it right
6604+ 3F2E 0F                   rrca
6605+ 3F2F 0F                   rrca
6606+ 3F30 0F                   rrca
6607+ 3F31 E6 0F                and     $0F             ; Mask off upper nybble
6608+ 3F33 FE 0A                cp      $0A             ; 0-9? < A hex?
6609+ 3F35 38 02                jr      C,ADD301        ; Skip Add 7
6610+ 3F37 C6 07                add     A,$07           ; Bring it up to ASCII A-F
6611+ 3F39 C6 30        ADD301: add     A,$30           ; And make it full ASCII
6612+ 3F3B 47                   ld      B,A             ; Store high order byte
6613+ 3F3C C9                   ret
6614+ 3F3D
6615+ 3F3D              ; Convert "&Hnnnn" to FPREG
6616+ 3F3D              ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
6617+ 3F3D              ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
6618+ 3F3D EB           HEXTFP: ex      DE,HL           ; Move code string pointer to DE
6619+ 3F3E 21 00 00             ld      HL,$0000        ; Zero out the value
6620+ 3F41 CD 56 3F             call    GETHEX          ; Check the number for valid hex
6621+ 3F44 DA 76 3F             jp      C,HXERR         ; First value wasn't hex, HX error
6622+ 3F47 18 05                jr      HEXLP1          ; Convert first character
6623+ 3F49 CD 56 3F     HEXLP:  call    GETHEX          ; Get second and addtional characters
6624+ 3F4C 38 1F                jr      C,HEXIT         ; Exit if not a hex character
6625+ 3F4E 29           HEXLP1: add     HL,HL           ; Rotate 4 bits to the left
6626+ 3F4F 29                   add     HL,HL
6627+ 3F50 29                   add     HL,HL
6628+ 3F51 29                   add     HL,HL
6629+ 3F52 B5                   or      L               ; Add in D0-D3 into L
6630+ 3F53 6F                   ld      L,A             ; Save new value
6631+ 3F54 18 F3                jr      HEXLP           ; And continue until all hex characters are in
6632+ 3F56
6633+ 3F56 13           GETHEX: inc     DE              ; Next location
6634+ 3F57 1A                   ld      A,(DE)          ; Load character at pointer
6635+ 3F58 FE 20                cp      SPC
6636+ 3F5A CA 56 3F             jp      Z,GETHEX        ; Skip spaces
6637+ 3F5D D6 30                sub     $30             ; Get absolute value
6638+ 3F5F D8                   ret     C               ; < "0", error
6639+ 3F60 FE 0A                cp      $0A
6640+ 3F62 38 05                jr      C,NOSUB7        ; Is already in the range 0-9
6641+ 3F64 D6 07                sub     $07             ; Reduce to A-F
6642+ 3F66 FE 0A                cp      $0A             ; Value should be $0A-$0F at this point
6643+ 3F68 D8                   ret     C               ; CY set if was :            ; < = > ? @
6644+ 3F69 FE 10        NOSUB7: cp      $10             ; > Greater than "F"?
6645+ 3F6B 3F                   ccf
6646+ 3F6C C9                   ret                     ; CY set if it wasn't valid hex
6647+ 3F6D
6648+ 3F6D EB           HEXIT:  ex      DE,HL           ; Value into DE, Code string into HL
6649+ 3F6E 7A                   ld      A,D             ; Load DE into AC
6650+ 3F6F 4B                   ld      C,E             ; For prep to
6651+ 3F70 E5                   push    HL
6652+ 3F71 CD AA 24             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6653+ 3F74 E1                   pop     HL
6654+ 3F75 C9                   ret
6655+ 3F76
6656+ 3F76 DD 5C        HXERR:  ld      E,HX            ; ?HEX Error
6657+ 3F78 C3 01 17             jp      ERROR
6658+ 3F7B
6659+ 3F7B              ; BIN$(NN) Convert integer to a 1-16 char binary string
6660+ 3F7B CD C4 20     BIN:    call    TSTNUM          ; Verify it's a number
6661+ 3F7E CD E6 1C             call    DEINT           ; Get integer -32768 to 32767
6662+ 3F81 C5           BIN2:   push    BC              ; Save contents of BC
6663+ 3F82 21 36 82             ld      HL,PBUFF
6664+ 3F85 06 11                ld      B,$11           ; One higher than max char count (16+1)
6665+ 3F87              ZEROSUP:                        ; Suppress leading zeros
6666+ 3F87 05                   dec     B               ; Max 16 chars
6667+ 3F88 78                   ld      A,B
6668+ 3F89 FE 01                cp      $01
6669+ 3F8B 28 08                jr      Z,BITOUT        ; Always output at least one character
6670+ 3F8D CB 13                rl      E
6671+ 3F8F CB 12                rl      D
6672+ 3F91 30 F4                jr      NC,ZEROSUP
6673+ 3F93 18 04                jr      BITOUT2
6674+ 3F95 CB 13        BITOUT: rl      E
6675+ 3F97 CB 12                rl      D               ; Top bit now in carry
6676+ 3F99 3E 30        BITOUT2:ld      A,'0'           ; Char for '0'
6677+ 3F9B CE 00                adc     A,$00           ; If carry set then '0' --> '1'
6678+ 3F9D 77                   ld      (HL),A
6679+ 3F9E 23                   inc     HL
6680+ 3F9F 05                   dec     B
6681+ 3FA0 20 F3                jr      NZ,BITOUT
6682+ 3FA2 AF                   xor     A               ; Terminating character
6683+ 3FA3 77                   ld      (HL),A          ; Store zero to terminate
6684+ 3FA4 23                   inc     HL              ; Make sure PBUFF is terminated
6685+ 3FA5 77                   ld      (HL),A          ; Store the double zero there
6686+ 3FA6 C1                   pop     BC
6687+ 3FA7 21 36 82             ld      HL,PBUFF
6688+ 3FAA C3 59 25             jp      STR1
6689+ 3FAD
6690+ 3FAD              ; Convert "&Bnnnn" to FPREG
6691+ 3FAD              ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
6692+ 3FAD EB           BINTFP: ex      DE,HL           ; Move code string pointer to DE
6693+ 3FAE 21 00 00             ld      HL,$0000        ; Zero out the value
6694+ 3FB1 CD CA 3F             call    CHKBIN          ; Check the number for valid bin
6695+ 3FB4 DA D8 3F             jp      C,BINERR        ; First value wasn't bin, HX error
6696+ 3FB7 D6 30        BINIT:  sub     '0'
6697+ 3FB9 29                   add     HL,HL           ; Rotate HL left
6698+ 3FBA B5                   or      L
6699+ 3FBB 6F                   ld      L,A
6700+ 3FBC CD CA 3F             call    CHKBIN          ; Get second and addtional characters
6701+ 3FBF 30 F6                jr      NC,BINIT        ; Process if a bin character
6702+ 3FC1 EB                   ex      DE,HL           ; Value into DE, Code string into HL
6703+ 3FC2 7A                   ld      A,D             ; Load DE into AC
6704+ 3FC3 4B                   ld      C,E             ; For prep to
6705+ 3FC4 E5                   push    HL
6706+ 3FC5 CD AA 24             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6707+ 3FC8 E1                   pop     HL
6708+ 3FC9 C9                   ret
6709+ 3FCA
6710+ 3FCA              ; Char is in A, NC if char is 0 or 1
6711+ 3FCA 13           CHKBIN: inc     DE
6712+ 3FCB 1A                   ld      A,(DE)
6713+ 3FCC FE 20                cp      SPC
6714+ 3FCE CA CA 3F             jp      Z,CHKBIN        ; Skip spaces
6715+ 3FD1 FE 30                cp      '0'             ; Set C if < '0'
6716+ 3FD3 D8                   ret     C
6717+ 3FD4 FE 32                cp      '2'
6718+ 3FD6 3F                   ccf                     ; Set C if > '1'
6719+ 3FD7 C9                   ret
6720+ 3FD8
6721+ 3FD8 1E 28        BINERR: ld      E,BN            ; ?BIN Error
6722+ 3FDA C3 01 17             jp      ERROR
6723+ 3FDD
6724+ 3FDD
6725+ 3FDD C3 08 00     MONOUT: jp      $0008           ; output a char
6726+ 3FE0
6727+ 3FE0
6728+ 3FE0 3A 1F 82     RESET:  ld      A,(SERIALS_EN)
6729+ 3FE3 E6 11                and     $11             ; are serial ports open?
6730+ 3FE5 C4 50 3B             call    NZ,RSTSERS      ; yes, reset serials
6731+ 3FE8 CD 62 29             call    DISNMI          ; disable NMI vector
6732+ 3FEB F3                   di                      ; disable INTs
6733+ 3FEC                  IFDEF LM80C64K
6734+ 3FEC ~                    jp      ROM2RAM         ; Restart
6735+ 3FEC                  ELSE
6736+ 3FEC C3 00 00             jp      $0000           ; Restart
6737+ 3FEF                  ENDIF
6738+ 3FEF
6739+ 3FEF
6740+ 3FEF 3E 00        INITST: ld      A,$00           ; Clear break flag
6741+ 3FF1 32 A9 80             ld      (BRKFLG),A
6742+ 3FF4 C3 19 12             jp      INIT
6743+ 3FF7
6744+ 3FF7
6745+ 3FF7 F5           TSTBIT: push    AF              ; Save bit mask
6746+ 3FF8 A0                   and     B               ; Get common bits
6747+ 3FF9 C1                   pop     BC              ; Restore bit mask
6748+ 3FFA B8                   cp      B               ; Same bit set?
6749+ 3FFB 3E 00                ld      A,$00           ; Return 0 in A
6750+ 3FFD C9                   ret
6751+ 3FFE
6752+ 3FFE CD F2 19     OUTNCR: call    OUTC            ; Output character in A
6753+ 4001 C3 FD 1E             jp      PRNTCRLF        ; Output CRLF
6754+ 4004
# file closed: ../include/basic/basic-1.04.asm
  80  4004
  81  4004              ; include utils
  82  4004                  INCLUDE "../include/utils/utils-r11.asm"
# file opened: ../include/utils/utils-r11.asm
   1+ 4004              ; ------------------------------------------------------------------------------
   2+ 4004              ; LM80C - UTILITY ROUTINES - R1.1
   3+ 4004              ; ------------------------------------------------------------------------------
   4+ 4004              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4004              ; designed by Leonardo Miliani. More info at
   6+ 4004              ; www DOT leonardomiliani DOT com
   7+ 4004              ;
   8+ 4004              ; *ALS are routines from "Z80 Assembly Language Subroutines" by Lance
   9+ 4004              ; A. Leventhal and Winthrop Saville - Ed. Osborne/McGraw-Hill (1983)
  10+ 4004              ;
  11+ 4004              ; * WKT are routines from WikiTI:
  12+ 4004              ; http://wikiti.brandonw.net/index.php?title=WikiTI_Home
  13+ 4004              ;
  14+ 4004              ; * LAC are routines from Learn@Cemetch
  15+ 4004              ; https://learn.cemetech.net/index.php/Main_Page
  16+ 4004              ;
  17+ 4004              ; ------------------------------------------------------------------------------
  18+ 4004              ; Code Revision:
  19+ 4004              ; R1.0 - 20200110 - First release: 16-bit comparision/multiplication/negation
  20+ 4004              ; R1.1 - 20200413 - Second release: added ABS(HL)
  21+ 4004              ;
  22+ 4004              ; ------------------------------------------------------------------------------
  23+ 4004
  24+ 4004              ; compare two 16-bit registers, HL (minuend) and DE (subtrahend)
  25+ 4004              ; values can be both signed or unsigned words
  26+ 4004              ; inputs: HL, DE
  27+ 4004              ; destroys: A,F,HL
  28+ 4004              ;
  29+ 4004              ; returns: Z=1 if HL = DE
  30+ 4004              ; for UNSIGNED: C=1 if HL<DE  //  C=0 if HL>DE
  31+ 4004              ; for SIGNED:   S=1 (M) if HL<DE  //  S=0 (P) if HL>DE
  32+ 4004              ; if HL=DE: Z,P,NC  - Z=1, S=0; C=0
  33+ 4004              ; if HL>DE: NZ,P,NC - Z=0, S=0; C=0
  34+ 4004              ; if HL<DE: NZ,M,C  - Z=0, S=1; C=1
  35+ 4004              ; Source: ALS
  36+ 4004
  37+ 4004 B7           CMP16:  or      A           ; clear CARRY
  38+ 4005 ED 52                sbc     HL,DE       ; subtract DE from HL
  39+ 4007 E0                   ret     PO          ; return if no overflow
  40+ 4008 7C                   ld      A,H         ; overflow - invert SIGN flag
  41+ 4009 1F                   rra                 ; save CARRY flag in bit 7
  42+ 400A EE 40                xor     %01000000   ; complement bit 6 (SIGN bit)
  43+ 400C 37                   scf                 ; ensure a Non-Zero result
  44+ 400D 8F                   adc     A,A         ; restore CARRY, complemented SIGN
  45+ 400E                                          ; ZERO flag = 0 for sure
  46+ 400E C9                   ret                 ; return
  47+ 400F
  48+ 400F              ; ----------------------------------------------------------------------
  49+ 400F
  50+ 400F              ; multiply 2 signed/unsigned 16-bit words and return a 16-bit
  51+ 400F              ; signed/unsigned product
  52+ 400F              ; inputs: HL (multiplicand); DE (multiplier)
  53+ 400F              ; destroys: A,F
  54+ 400F              ; returns: HL (product)
  55+ 400F              ; Source: ALS
  56+ 400F
  57+ 400F              ; initialize partial product, bit count
  58+ 400F C5           MUL16:  push    BC
  59+ 4010 4D                   ld      C,L         ; BC = multiplier
  60+ 4011 44                   ld      B,H
  61+ 4012 21 00 00             ld      HL,0        ; product = 0
  62+ 4015 3E 0F                ld      A,$0F       ; count = bit lenght - 1 (16-1)
  63+ 4017                      ; shift-and-add algorithm
  64+ 4017                      ; if MSB of multiplier is 1, add multiplicand to partial product
  65+ 4017                      ; shift partial product, multiplier left 1 bit
  66+ 4017 CB 23        MLP:    sla     E           ; shift multiplier left 1 bit
  67+ 4019 CB 12                rl      D
  68+ 401B 30 01                jr      NC,MLP1     ; jump if MSB of multiplier = 0
  69+ 401D 09                   add     HL,BC       ; add multiplicand to partial product
  70+ 401E 29           MLP1:   add     HL,HL       ; shift partial product left
  71+ 401F 3D                   dec     A
  72+ 4020 20 F5                jr      NZ,MLP      ; continue until count = 0
  73+ 4022                      ; add multiplicand one last time if MSB of multiplier is 1
  74+ 4022 B2                   or      D           ; sign flag = MSB of multiplier
  75+ 4023 F2 27 40             jp      P,EXMUL16   ; exit if MSB of multiplier is 0
  76+ 4026 09                   add     HL,BC       ; add multiplicand to product
  77+ 4027 C1           EXMUL16:pop     BC
  78+ 4028 C9                   ret
  79+ 4029
  80+ 4029              ; ----------------------------------------------------------------------
  81+ 4029              ; absolute value of HL (same applies to other 16-bit register pairs)
  82+ 4029              ; also, invert value of HL (or any other 16-bit register, just adjust the code)
  83+ 4029              ;
  84+ 4029              ; inputs: HL
  85+ 4029              ; destroys: A
  86+ 4029              ; operation: ABS(HL)
  87+ 4029              ; returns: HL with no sign or negated
  88+ 4029              ; Source: WKT
  89+ 4029
  90+ 4029 CB 7C        absHL:  bit     7,H
  91+ 402B C8                   ret     Z
  92+ 402C AF           negHL:  xor     A
  93+ 402D 95                   sub     L
  94+ 402E 6F                   ld      L,A
  95+ 402F 9F                   sbc     A,A
  96+ 4030 94                   sub     H
  97+ 4031 67                   ld      H,A
  98+ 4032 C9                   ret
  99+ 4033
 100+ 4033              ; ------------------------------------------------------------------------------
 101+ 4033
 102+ 4033              ; 8/8 division
 103+ 4033              ; INPUT: D (dividend), E (divisor)
 104+ 4033              ; OPERATION: D/E
 105+ 4033              ; OUTPUT: D (quotient), A (remainder)
 106+ 4033 AF           DIV_8_8:    xor     A
 107+ 4034 C5                       push    BC
 108+ 4035 06 08                    ld      B,08h
 109+ 4037 CB 22        DIV_8_8LOOP:sla     D
 110+ 4039 17                       rla
 111+ 403A BB                       cp      E
 112+ 403B 38 02                    jr      C,$+4
 113+ 403D 93                       sub     E
 114+ 403E 14                       inc     D
 115+ 403F 10 F6                    djnz    DIV_8_8LOOP
 116+ 4041 C1                       pop     BC
 117+ 4042 C9                       ret
 118+ 4043
 119+ 4043              ; ----------------------------------------------------------------------
 120+ 4043              ; divide a 16-bit number by an 8-bit number
 121+ 4043              ; (16/8 division)
 122+ 4043              ;
 123+ 4043              ; inputs: HL (Dividend), C (divisor)
 124+ 4043              ; destroys: A
 125+ 4043              ; OPERATION: HL/C
 126+ 4043              ; returns: HL (quotient), A (remainder)
 127+ 4043              ; source: WKT
 128+ 4043
 129+ 4043 AF           DIV_16_8:   xor     A
 130+ 4044 06 10                    ld      B,16
 131+ 4046 29           DIV_16_8LP: add     HL,HL
 132+ 4047 17                       rla
 133+ 4048 38 03                    jr      C,$+5
 134+ 404A B9                       cp      C
 135+ 404B 38 02                    jr      C,$+4
 136+ 404D 91                       sub     C
 137+ 404E 2C                       inc     L
 138+ 404F 10 F5                    djnz    DIV_16_8LP
 139+ 4051 C9                       ret
 140+ 4052
 141+ 4052              ; ----------------------------------------------------------------------
 142+ 4052              ; divide a 16-bit number by a 16-bit number
 143+ 4052              ; (16/16 division)
 144+ 4052              ;
 145+ 4052              ; inputs: AC (Dividend), DE (divisor)
 146+ 4052              ; destroys: HL,A,C
 147+ 4052              ; OPERATION: AC/DE
 148+ 4052              ; returns: AC (quotient), HL (remainder)
 149+ 4052              ; source: WKT
 150+ 4052 21 00 00     DIV_16_16:  ld      HL, 0
 151+ 4055 06 10                    ld      B, 16
 152+ 4057 CB 21        DV16_16_LP: sla     C
 153+ 4059 CB C1                    set     0,C         ; this simulates the SLL undocumented instruction
 154+ 405B 17                       rla
 155+ 405C ED 6A                    adc     HL,HL
 156+ 405E ED 52                    sbc     HL,DE
 157+ 4060 30 02                    jr      NC, $+4
 158+ 4062 19                       add     HL,DE
 159+ 4063 0D                       dec     C
 160+ 4064 10 F1                    djnz    DV16_16_LP
 161+ 4066 C9                       ret
# file closed: ../include/utils/utils-r11.asm
  83  4067
  84  4067              ; include the latest version of the font sets
  85  4067                  INCLUDE "../include/vdp/6x8fonts-r16.asm"
# file opened: ../include/vdp/6x8fonts-r16.asm
   1+ 4067              ; ------------------------------------------------------------------------------
   2+ 4067              ; LM80C - 6x8 CHARSET - R1.6
   3+ 4067              ; ------------------------------------------------------------------------------
   4+ 4067              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4067              ; designed by Leonardo Miliani. More info at
   6+ 4067              ; www DOT leonardomiliani DOT com
   7+ 4067              ; ------------------------------------------------------------------------------
   8+ 4067              ; Code Revision:
   9+ 4067              ; R1.0 - 20190511 - First revision: ASCII chars (from 0 to 127)
  10+ 4067              ; R1.1 - 20190521 - Expanded to 255 chars
  11+ 4067              ; R1.2 - 20191209 - Start adding graphic chars to be coherent with 8x8 fonts
  12+ 4067              ; R1.3 - 20191226 - Added extended char codes (128-255)
  13+ 4067              ; R1.4 - 20200228 - adopted more usual hexadecimal & binary prefixes
  14+ 4067              ; R1.5 - 20200524 - New style for char #252
  15+ 4067              ; R1.6 - 20200704 - Redefined chars 105, 106, and 252
  16+ 4067              ; ------------------------------------------------------------------------------
  17+ 4067              ;
  18+ 4067              ;-------------------------------------------------------------------------------
  19+ 4067              ;
  20+ 4067              ;               6 x 8    C  H  A  R  S  E  T
  21+ 4067              ;
  22+ 4067              ;-------------------------------------------------------------------------------
  23+ 4067              ;
  24+ 4067              ;       6X8 CHARS, DESIGNED FOR TEXT BUT USABLE IN GRAPHICS 1 MODE TOO
  25+ 4067              ;       UPDATE: NOW GRAPHICS 1 MODE HAS ITS OWN CHAR SET
  26+ 4067
  27+ 4067              CHRST68 equ $
  28+ 4067 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  28+ 406B 00 00 00 00
  29+ 406F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  29+ 4073 00 00 00 00
  30+ 4077 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  30+ 407B 00 00 00 00
  31+ 407F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  31+ 4083 00 00 00 00
  32+ 4087 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  32+ 408B 00 00 00 00
  33+ 408F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  33+ 4093 00 00 00 00
  34+ 4097 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  34+ 409B 00 00 00 00
  35+ 409F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  35+ 40A3 00 00 00 00
  36+ 40A7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
  36+ 40AB 00 00 00 00
  37+ 40AF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  37+ 40B3 00 00 00 00
  38+ 40B7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  38+ 40BB 00 00 00 00
  39+ 40BF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11
  39+ 40C3 00 00 00 00
  40+ 40C7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  40+ 40CB 00 00 00 00
  41+ 40CF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
  41+ 40D3 00 00 00 00
  42+ 40D7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
  42+ 40DB 00 00 00 00
  43+ 40DF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  43+ 40E3 00 00 00 00
  44+ 40E7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  44+ 40EB 00 00 00 00
  45+ 40EF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  45+ 40F3 00 00 00 00
  46+ 40F7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  46+ 40FB 00 00 00 00
  47+ 40FF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  47+ 4103 00 00 00 00
  48+ 4107 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
  48+ 410B 00 00 00 00
  49+ 410F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  49+ 4113 00 00 00 00
  50+ 4117 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
  50+ 411B 00 00 00 00
  51+ 411F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
  51+ 4123 00 00 00 00
  52+ 4127 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
  52+ 412B 00 00 00 00
  53+ 412F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
  53+ 4133 00 00 00 00
  54+ 4137 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
  54+ 413B 00 00 00 00
  55+ 413F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
  55+ 4143 00 00 00 00
  56+ 4147 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
  56+ 414B 00 00 00 00
  57+ 414F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
  57+ 4153 00 00 00 00
  58+ 4157 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
  58+ 415B 00 00 00 00
  59+ 415F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
  59+ 4163 00 00 00 00
  60+ 4167 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32: space
  60+ 416B 00 00 00 00
  61+ 416F 20 20 20 20          defb $20,$20,$20,$20,$20,$00,$20,$00 ; char 33: !
  61+ 4173 20 00 20 00
  62+ 4177 50 50 00 00          defb $50,$50,$00,$00,$00,$00,$00,$00 ; char 34: "
  62+ 417B 00 00 00 00
  63+ 417F 50 50 F8 50          defb $50,$50,$f8,$50,$f8,$50,$50,$00 ; char 35: #
  63+ 4183 F8 50 50 00
  64+ 4187 20 78 A0 70          defb $20,$78,$a0,$70,$28,$f0,$20,$00 ; char 36: $
  64+ 418B 28 F0 20 00
  65+ 418F C0 C8 10 20          defb $c0,$c8,$10,$20,$40,$98,$18,$00 ; char 37: %
  65+ 4193 40 98 18 00
  66+ 4197 60 90 A0 40          defb $60,$90,$a0,$40,$a8,$90,$68,$00 ; char 38: &
  66+ 419B A8 90 68 00
  67+ 419F 60 20 40 00          defb $60,$20,$40,$00,$00,$00,$00,$00 ; char 39: '
  67+ 41A3 00 00 00 00
  68+ 41A7 10 20 40 40          defb $10,$20,$40,$40,$40,$20,$10,$00 ; char 40: (
  68+ 41AB 40 20 10 00
  69+ 41AF 40 20 10 10          defb $40,$20,$10,$10,$10,$20,$40,$00 ; char 41: )
  69+ 41B3 10 20 40 00
  70+ 41B7 00 20 A8 70          defb $00,$20,$a8,$70,$a8,$20,$00,$00 ; char 42: *
  70+ 41BB A8 20 00 00
  71+ 41BF 00 20 20 F8          defb $00,$20,$20,$f8,$20,$20,$00,$00 ; char 43: +
  71+ 41C3 20 20 00 00
  72+ 41C7 00 00 00 00          defb $00,$00,$00,$00,$60,$20,$40,$00 ; char 44: ,
  72+ 41CB 60 20 40 00
  73+ 41CF 00 00 00 F8          defb $00,$00,$00,$f8,$00,$00,$00,$00 ; char 45: -
  73+ 41D3 00 00 00 00
  74+ 41D7 00 00 00 00          defb $00,$00,$00,$00,$00,$60,$60,$00 ; char 46: .
  74+ 41DB 00 60 60 00
  75+ 41DF 00 08 10 20          defb $00,$08,$10,$20,$40,$80,$00,$00 ; char 47: /
  75+ 41E3 40 80 00 00
  76+ 41E7 70 88 98 A8          defb $70,$88,$98,$a8,$c8,$88,$70,$00 ; char 48: 0
  76+ 41EB C8 88 70 00
  77+ 41EF 20 60 20 20          defb $20,$60,$20,$20,$20,$20,$70,$00 ; char 49: 1
  77+ 41F3 20 20 70 00
  78+ 41F7 70 88 08 10          defb $70,$88,$08,$10,$20,$40,$f8,$00 ; char 50: 2
  78+ 41FB 20 40 F8 00
  79+ 41FF F8 10 20 10          defb $f8,$10,$20,$10,$08,$88,$70,$00 ; char 51: 3
  79+ 4203 08 88 70 00
  80+ 4207 10 30 50 90          defb $10,$30,$50,$90,$f8,$10,$10,$00 ; char 52: 4
  80+ 420B F8 10 10 00
  81+ 420F F8 80 F0 08          defb $f8,$80,$f0,$08,$08,$88,$70,$00 ; char 53: 5
  81+ 4213 08 88 70 00
  82+ 4217 30 40 80 F0          defb $30,$40,$80,$f0,$88,$88,$70,$00 ; char 54: 6
  82+ 421B 88 88 70 00
  83+ 421F F8 08 10 20          defb $f8,$08,$10,$20,$40,$40,$40,$00 ; char 55: 7
  83+ 4223 40 40 40 00
  84+ 4227 70 88 88 70          defb $70,$88,$88,$70,$88,$88,$70,$00 ; char 56: 8
  84+ 422B 88 88 70 00
  85+ 422F 70 88 88 78          defb $70,$88,$88,$78,$08,$10,$60,$00 ; char 57: 9
  85+ 4233 08 10 60 00
  86+ 4237 00 30 30 00          defb $00,$30,$30,$00,$30,$30,$00,$00 ; char 58: :
  86+ 423B 30 30 00 00
  87+ 423F 00 30 30 00          defb $00,$30,$30,$00,$30,$10,$20,$00 ; char 59: ;
  87+ 4243 30 10 20 00
  88+ 4247 10 20 40 80          defb $10,$20,$40,$80,$40,$20,$10,$00 ; char 60: <
  88+ 424B 40 20 10 00
  89+ 424F 00 00 F8 00          defb $00,$00,$f8,$00,$f8,$00,$00,$00 ; char 61: =
  89+ 4253 F8 00 00 00
  90+ 4257 40 20 10 08          defb $40,$20,$10,$08,$10,$20,$40,$00 ; char 62: >
  90+ 425B 10 20 40 00
  91+ 425F 70 88 08 10          defb $70,$88,$08,$10,$20,$00,$20,$00 ; char 63: ?
  91+ 4263 20 00 20 00
  92+ 4267 70 88 08 68          defb $70,$88,$08,$68,$a8,$a8,$70,$00 ; char 64: @
  92+ 426B A8 A8 70 00
  93+ 426F 70 88 88 88          defb $70,$88,$88,$88,$f8,$88,$88,$00 ; char 65: A
  93+ 4273 F8 88 88 00
  94+ 4277 F0 88 88 F0          defb $f0,$88,$88,$f0,$88,$88,$f0,$00 ; char 66: B
  94+ 427B 88 88 F0 00
  95+ 427F 70 88 80 80          defb $70,$88,$80,$80,$80,$88,$70,$00 ; char 67: C
  95+ 4283 80 88 70 00
  96+ 4287 E0 90 88 88          defb $e0,$90,$88,$88,$88,$90,$e0,$00 ; char 68: D
  96+ 428B 88 90 E0 00
  97+ 428F F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$f8,$00 ; char 69: E
  97+ 4293 80 80 F8 00
  98+ 4297 F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$80,$00 ; char 70: F
  98+ 429B 80 80 80 00
  99+ 429F 70 88 80 B8          defb $70,$88,$80,$b8,$88,$88,$78,$00 ; char 71: G
  99+ 42A3 88 88 78 00
 100+ 42A7 88 88 88 F8          defb $88,$88,$88,$f8,$88,$88,$88,$00 ; char 72: H
 100+ 42AB 88 88 88 00
 101+ 42AF 70 20 20 20          defb $70,$20,$20,$20,$20,$20,$70,$00 ; char 73: I
 101+ 42B3 20 20 70 00
 102+ 42B7 38 10 10 10          defb $38,$10,$10,$10,$10,$90,$60,$00 ; char 74: J
 102+ 42BB 10 90 60 00
 103+ 42BF 88 90 A0 C0          defb $88,$90,$a0,$c0,$a0,$90,$88,$00 ; char 75: K
 103+ 42C3 A0 90 88 00
 104+ 42C7 80 80 80 80          defb $80,$80,$80,$80,$80,$80,$f8,$00 ; char 76: L
 104+ 42CB 80 80 F8 00
 105+ 42CF 88 D8 A8 A8          defb $88,$d8,$a8,$a8,$88,$88,$88,$00 ; char 77: M
 105+ 42D3 88 88 88 00
 106+ 42D7 88 C8 A8 98          defb $88,$c8,$a8,$98,$88,$88,$88,$00 ; char 78: N
 106+ 42DB 88 88 88 00
 107+ 42DF 70 88 88 88          defb $70,$88,$88,$88,$88,$88,$70,$00 ; char 79: O
 107+ 42E3 88 88 70 00
 108+ 42E7 F0 88 88 F0          defb $f0,$88,$88,$f0,$80,$80,$80,$00 ; char 80: P
 108+ 42EB 80 80 80 00
 109+ 42EF 70 88 88 88          defb $70,$88,$88,$88,$a8,$90,$68,$00 ; char 81: Q
 109+ 42F3 A8 90 68 00
 110+ 42F7 F0 88 88 F0          defb $f0,$88,$88,$f0,$a0,$90,$88,$00 ; char 82: R
 110+ 42FB A0 90 88 00
 111+ 42FF 78 80 80 70          defb $78,$80,$80,$70,$08,$08,$f0,$00 ; char 83: S
 111+ 4303 08 08 F0 00
 112+ 4307 F8 20 20 20          defb $f8,$20,$20,$20,$20,$20,$20,$00 ; char 84: T
 112+ 430B 20 20 20 00
 113+ 430F 88 88 88 88          defb $88,$88,$88,$88,$88,$88,$70,$00 ; char 85: U
 113+ 4313 88 88 70 00
 114+ 4317 88 88 88 88          defb $88,$88,$88,$88,$88,$50,$20,$00 ; char 86: V
 114+ 431B 88 50 20 00
 115+ 431F 88 88 88 88          defb $88,$88,$88,$88,$a8,$a8,$50,$00 ; char 87: W
 115+ 4323 A8 A8 50 00
 116+ 4327 88 88 50 20          defb $88,$88,$50,$20,$50,$88,$88,$00 ; char 88: X
 116+ 432B 50 88 88 00
 117+ 432F 88 88 88 50          defb $88,$88,$88,$50,$20,$20,$20,$00 ; char 89: Y
 117+ 4333 20 20 20 00
 118+ 4337 F8 08 10 20          defb $f8,$08,$10,$20,$40,$80,$f8,$00 ; char 90: Z
 118+ 433B 40 80 F8 00
 119+ 433F 70 40 40 40          defb $70,$40,$40,$40,$40,$40,$70,$00 ; char 91: [
 119+ 4343 40 40 70 00
 120+ 4347 00 80 40 20          defb $00,$80,$40,$20,$10,$08,$00,$00 ; char 92: \
 120+ 434B 10 08 00 00
 121+ 434F 70 10 10 10          defb $70,$10,$10,$10,$10,$10,$70,$00 ; char 93: ]
 121+ 4353 10 10 70 00
 122+ 4357 20 50 88 00          defb $20,$50,$88,$00,$00,$00,$00,$00 ; char 94: ^
 122+ 435B 00 00 00 00
 123+ 435F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$FC ; char 95: _ (underscore)
 123+ 4363 00 00 00 FC
 124+ 4367 40 20 10 00          defb $40,$20,$10,$00,$00,$00,$00,$00 ; char 96: `
 124+ 436B 00 00 00 00
 125+ 436F 00 00 70 08          defb $00,$00,$70,$08,$78,$88,$78,$00 ; char 97: a
 125+ 4373 78 88 78 00
 126+ 4377 80 80 80 B0          defb $80,$80,$80,$b0,$c8,$88,$f0,$00 ; char 98: b
 126+ 437B C8 88 F0 00
 127+ 437F 00 00 70 80          defb $00,$00,$70,$80,$80,$88,$70,$00 ; char 99: c
 127+ 4383 80 88 70 00
 128+ 4387 08 08 08 68          defb $08,$08,$08,$68,$98,$88,$78,$00 ; char 100: d
 128+ 438B 98 88 78 00
 129+ 438F 00 00 70 88          defb $00,$00,$70,$88,$f8,$80,$70,$00 ; char 101: e
 129+ 4393 F8 80 70 00
 130+ 4397 30 48 40 E0          defb $30,$48,$40,$e0,$40,$40,$40,$00 ; char 102: f
 130+ 439B 40 40 40 00
 131+ 439F 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$70,$00 ; char 103: g
 131+ 43A3 78 08 70 00
 132+ 43A7 80 80 B0 C8          defb $80,$80,$b0,$c8,$88,$88,$88,$00 ; char 104: h
 132+ 43AB 88 88 88 00
 133+ 43AF 20 00 20 20          defb $20,$00,$20,$20,$20,$20,$20,$00 ; char 105: i
 133+ 43B3 20 20 20 00
 134+ 43B7 08 00 18 08          defb $08,$00,$18,$08,$08,$88,$70,$00 ; char 106: j
 134+ 43BB 08 88 70 00
 135+ 43BF 80 80 90 A0          defb $80,$80,$90,$a0,$c0,$a0,$90,$00 ; char 107: k
 135+ 43C3 C0 A0 90 00
 136+ 43C7 60 20 20 20          defb $60,$20,$20,$20,$20,$20,$70,$00 ; char 108: l
 136+ 43CB 20 20 70 00
 137+ 43CF 00 00 D0 A8          defb $00,$00,$d0,$a8,$a8,$88,$88,$00 ; char 109: m
 137+ 43D3 A8 88 88 00
 138+ 43D7 00 00 B0 C8          defb $00,$00,$b0,$c8,$88,$88,$88,$00 ; char 110: n
 138+ 43DB 88 88 88 00
 139+ 43DF 00 00 70 88          defb $00,$00,$70,$88,$88,$88,$70,$00 ; char 111: o
 139+ 43E3 88 88 70 00
 140+ 43E7 00 00 F0 88          defb $00,$00,$f0,$88,$f0,$80,$80,$00 ; char 112: p
 140+ 43EB F0 80 80 00
 141+ 43EF 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$08,$00 ; char 113: q
 141+ 43F3 78 08 08 00
 142+ 43F7 00 00 B0 C8          defb $00,$00,$b0,$c8,$80,$80,$80,$00 ; char 114: r
 142+ 43FB 80 80 80 00
 143+ 43FF 00 00 70 80          defb $00,$00,$70,$80,$70,$08,$f0,$00 ; char 115: s
 143+ 4403 70 08 F0 00
 144+ 4407 40 40 E0 40          defb $40,$40,$e0,$40,$40,$48,$30,$00 ; char 116: t
 144+ 440B 40 48 30 00
 145+ 440F 00 00 88 88          defb $00,$00,$88,$88,$88,$98,$68,$00 ; char 117: u
 145+ 4413 88 98 68 00
 146+ 4417 00 00 88 88          defb $00,$00,$88,$88,$88,$50,$20,$00 ; char 118: v
 146+ 441B 88 50 20 00
 147+ 441F 00 00 88 88          defb $00,$00,$88,$88,$a8,$a8,$50,$00 ; char 119: w
 147+ 4423 A8 A8 50 00
 148+ 4427 00 00 88 50          defb $00,$00,$88,$50,$20,$50,$88,$00 ; char 120: x
 148+ 442B 20 50 88 00
 149+ 442F 00 00 88 98          defb $00,$00,$88,$98,$68,$08,$70,$00 ; char 121: y
 149+ 4433 68 08 70 00
 150+ 4437 00 00 F8 10          defb $00,$00,$f8,$10,$20,$40,$f8,$00 ; char 122: z
 150+ 443B 20 40 F8 00
 151+ 443F 10 20 20 40          defb $10,$20,$20,$40,$20,$20,$10,$00 ; char 123: {
 151+ 4443 20 20 10 00
 152+ 4447 20 20 20 20          defb $20,$20,$20,$20,$20,$20,$20,$00 ; char 124: |
 152+ 444B 20 20 20 00
 153+ 444F 20 10 10 08          defb $20,$10,$10,$08,$10,$10,$20,$00 ; char 125: }
 153+ 4453 10 10 20 00
 154+ 4457 00 28 50 00          defb $00,$28,$50,$00,$00,$00,$00,$00 ; char 126: ~
 154+ 445B 00 00 00 00
 155+ 445F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 127: (delete) - here end the standard ASCII (0-127)
 155+ 4463 00 00 00 00
 156+ 4467 78 84 CC 84          defb %01111000,%10000100,%11001100,%10000100,%10110100,%10000100,%01111000,%00000000 ; char 128 (open face)
 156+ 446B B4 84 78 00
 157+ 446F 78 FC B4 FC          defb %01111000,%11111100,%10110100,%11111100,%10110100,%11001100,%01111000,%00000000 ; char 129 (full face)
 157+ 4473 B4 CC 78 00
 158+ 4477 48 FC FC FC          defb %01001000,%11111100,%11111100,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 130 (hearts)
 158+ 447B FC 78 30 00
 159+ 447F 00 20 70 F8          defb %00000000,%00100000,%01110000,%11111000,%11111000,%01110000,%00100000,%00000000 ; char 131 (diamonds)
 159+ 4483 F8 70 20 00
 160+ 4487 70 20 A8 F8          defb %01110000,%00100000,%10101000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 132 (clubs)
 160+ 448B A8 20 70 00
 161+ 448F 20 70 F8 F8          defb %00100000,%01110000,%11111000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 133 (spades)
 161+ 4493 A8 20 70 00
 162+ 4497 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 134
 162+ 449B FC 30 30 30
 163+ 449F 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 135
 163+ 44A3 3C 30 30 30
 164+ 44A7 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 136
 164+ 44AB F0 30 30 30
 165+ 44AF 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00000000,%00000000,%00000000 ; char 137
 165+ 44B3 F0 00 00 00
 166+ 44B7 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00000000,%00000000,%00000000 ; char 138
 166+ 44BB 3C 00 00 00
 167+ 44BF 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 139
 167+ 44C3 FC 00 00 00
 168+ 44C7 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 140
 168+ 44CB 3C 30 30 30
 169+ 44CF 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 141
 169+ 44D3 FC 30 30 30
 170+ 44D7 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 142
 170+ 44DB F0 30 30 30
 171+ 44DF 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 143
 171+ 44E3 FC 00 00 00
 172+ 44E7 30 30 30 30          defb %00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000 ; char 144
 172+ 44EB 30 30 30 30
 173+ 44EF 0C 1C 18 38          defb %00001100,%00011100,%00011000,%00111000,%01110000,%01100000,%11100000,%11000000 ; char 145
 173+ 44F3 70 60 E0 C0
 174+ 44F7 C0 E0 60 70          defb %11000000,%11100000,%01100000,%01110000,%00111000,%00011000,%00011100,%00001100 ; char 146
 174+ 44FB 38 18 1C 0C
 175+ 44FF CC CC 78 30          defb %11001100,%11001100,%01111000,%00110000,%00110000,%01111000,%11001100,%11001100 ; char 147
 175+ 4503 30 78 CC CC
 176+ 4507 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 148
 176+ 450B 20 20 20 20
 177+ 450F 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 149
 177+ 4513 20 20 20 20
 178+ 4517 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 150
 178+ 451B 20 20 20 20
 179+ 451F 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 151
 179+ 4523 00 00 00 00
 180+ 4527 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00000000,%00000000,%00000000,%00000000 ; char 152
 180+ 452B 00 00 00 00
 181+ 452F 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 153
 181+ 4533 00 00 00 00
 182+ 4537 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 154
 182+ 453B 20 20 20 20
 183+ 453F 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 155
 183+ 4543 20 20 20 20
 184+ 4547 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 156
 184+ 454B 20 20 20 20
 185+ 454F 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 157
 185+ 4553 00 00 00 00
 186+ 4557 20 20 20 20          defb %00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000 ; char 158
 186+ 455B 20 20 20 20
 187+ 455F 04 08 08 10          defb %00000100,%00001000,%00001000,%00010000,%00100000,%01000000,%01000000,%10000000 ; char 159
 187+ 4563 20 40 40 80
 188+ 4567 80 40 40 20          defb %10000000,%01000000,%01000000,%00100000,%00010000,%00001000,%00001000,%00000100 ; char 160
 188+ 456B 10 08 08 04
 189+ 456F 84 48 48 30          defb %10000100,%01001000,%01001000,%00110000,%00110000,%01001000,%01001000,%10000100 ; char 161
 189+ 4573 30 48 48 84
 190+ 4577 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 162
 190+ 457B 00 00 FC FC
 191+ 457F 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111100,%11111100,%11111100,%11111100 ; char 163
 191+ 4583 FC FC FC FC
 192+ 4587 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 164
 192+ 458B FC FC FC FC
 193+ 458F FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 193+ 4593 00 00 00 00
 194+ 4597 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 166
 194+ 459B 00 00 00 00
 195+ 459F FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 167
 195+ 45A3 FC FC 00 00
 196+ 45A7 80 80 80 80          defb %10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000 ; char 168
 196+ 45AB 80 80 80 80
 197+ 45AF E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000 ; char 169
 197+ 45B3 E0 E0 E0 E0
 198+ 45B7 F8 F8 F8 F8          defb %11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000 ; char 170
 198+ 45BB F8 F8 F8 F8
 199+ 45BF 04 04 04 04          defb %00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100 ; char 171
 199+ 45C3 04 04 04 04
 200+ 45C7 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100 ; char 172
 200+ 45CB 1C 1C 1C 1C
 201+ 45CF 7C 7C 7C 7C          defb %01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100 ; char 173
 201+ 45D3 7C 7C 7C 7C
 202+ 45D7 FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 174
 202+ 45DB 84 84 84 FC
 203+ 45DF 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%11100000,%11100000,%11100000 ; char 175
 203+ 45E3 E0 E0 E0 E0
 204+ 45E7 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00011100,%00011100,%00011100 ; char 176
 204+ 45EB 1C 1C 1C 1C
 205+ 45EF 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 177
 205+ 45F3 00 00 00 00
 206+ 45F7 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 178
 206+ 45FB 00 00 00 00
 207+ 45FF E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00011100,%00011100,%00011100,%00011100 ; char 179
 207+ 4603 1C 1C 1C 1C
 208+ 4607 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%11100000,%11100000,%11100000,%11100000 ; char 180
 208+ 460B E0 E0 E0 E0
 209+ 460F 78 78 78 78          defb %01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000 ; char 181
 209+ 4613 78 78 78 78
 210+ 4617 CC CC CC CC          defb %11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100 ; char 182
 210+ 461B CC CC CC CC
 211+ 461F FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 183
 211+ 4623 00 00 FC FC
 212+ 4627 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 184
 212+ 462B FC FC 00 00
 213+ 462F 30 30 CC CC          defb %00110000,%00110000,%11001100,%11001100,%00110000,%00110000,%11001100,%11001100 ; char 185
 213+ 4633 30 30 CC CC
 214+ 4637 54 A8 54 A8          defb %01010100,%10101000,%01010100,%10101000,%01010100,%10101000,%01010100,%10101000 ; char 186
 214+ 463B 54 A8 54 A8
 215+ 463F 64 30 98 CC          defb %01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100 ; char 187
 215+ 4643 64 30 98 CC
 216+ 4647 CC 64 30 98          defb %11001100,%01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000 ; char 188
 216+ 464B CC 64 30 98
 217+ 464F 30 98 CC 64          defb %00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100,%01100100 ; char 189
 217+ 4653 30 98 CC 64
 218+ 4657 64 CC 98 30          defb %01100100,%11001100,%10011000,%00110000,%01100100,%11001100,%10011000,%00110000 ; char 190
 218+ 465B 64 CC 98 30
 219+ 465F 20 20 F8 20          defb %00100000,%00100000,%11111000,%00100000,%00100000,%00000000,%11111000,%00000000 ; char 191 (Â±)
 219+ 4663 20 00 F8 00
 220+ 4667 C0 30 08 30          defb %11000000,%00110000,%00001000,%00110000,%11000000,%00000000,%11111000,%00000000 ; char 192 (â¥)
 220+ 466B C0 00 F8 00
 221+ 466F 18 60 80 60          defb %00011000,%01100000,%10000000,%01100000,%00011000,%00000000,%11111000,%00000000 ; char 193 (â¤)
 221+ 4673 18 00 F8 00
 222+ 4677 3C 20 20 20          defb %00111100,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 222+ 467B A0 60 20 00
 223+ 467F 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 223+ 4683 00 00 00 00
 224+ 4687 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 224+ 468B 70 00 00 00
 225+ 468F 00 00 54 A8          defb %00000000,%00000000,%01010100,%10101000,%00000000,%11111100,%00000000,%00000000 ; char 197
 225+ 4693 00 FC 00 00
 226+ 4697 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 226+ 469B 54 A8 00 00
 227+ 469F 00 80 C0 E0          defb %00000000,%10000000,%11000000,%11100000,%11100000,%11000000,%10000000,%00000000 ; char 199
 227+ 46A3 E0 C0 80 00
 228+ 46A7 FC 78 30 00          defb %11111100,%01111000,%00110000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 200
 228+ 46AB 00 00 00 00
 229+ 46AF 00 04 0C 1C          defb %00000000,%00000100,%00001100,%00011100,%00011100,%00001100,%00000100,%00000000 ; char 201
 229+ 46B3 1C 0C 04 00
 230+ 46B7 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00110000,%01111000,%11111100 ; char 202
 230+ 46BB 00 30 78 FC
 231+ 46BF 20 70 F8 20          defb %00100000,%01110000,%11111000,%00100000,%00100000,%00100000,%00100000,%00000000 ; char 203 (up arrow)
 231+ 46C3 20 20 20 00
 232+ 46C7 3C 1C 1C 24          defb %00111100,%00011100,%00011100,%00100100,%01000000,%10000000,%00000000,%00000000 ; char 204 (up right arrow)
 232+ 46CB 40 80 00 00
 233+ 46CF 00 10 18 FC          defb %00000000,%00010000,%00011000,%11111100,%00011000,%00010000,%00000000,%00000000 ; char 205 (right arrow)
 233+ 46D3 18 10 00 00
 234+ 46D7 00 00 80 40          defb %00000000,%00000000,%10000000,%01000000,%00100100,%00011100,%00011100,%00111100 ; char 206 (down right arrow)
 234+ 46DB 24 1C 1C 3C
 235+ 46DF 00 20 20 20          defb %00000000,%00100000,%00100000,%00100000,%00100000,%11111000,%01110000,%00100000 ; char 207 (down arrow)
 235+ 46E3 20 F8 70 20
 236+ 46E7 00 00 04 08          defb %00000000,%00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000 ; char 208 (down left arrow)
 236+ 46EB 90 E0 E0 F0
 237+ 46EF 00 20 60 FC          defb %00000000,%00100000,%01100000,%11111100,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 237+ 46F3 60 20 00 00
 238+ 46F7 F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 238+ 46FB 08 04 00 00
 239+ 46FF 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 239+ 4703 F0 44 38 00
 240+ 4707 00 04 78 A8          defb %00000000,%00000100,%01111000,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 240+ 470B 28 28 28 00
 241+ 470F 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00100000,%00100000,%00100000 ; char 213
 241+ 4713 1C 20 20 20
 242+ 4717 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%00010000,%00010000,%00010000 ; char 214
 242+ 471B E0 10 10 10
 243+ 471F 10 10 10 E0          defb %00010000,%00010000,%00010000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 215
 243+ 4723 00 00 00 00
 244+ 4727 20 20 20 1C          defb %00100000,%00100000,%00100000,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 216
 244+ 472B 00 00 00 00
 245+ 472F 00 00 00 1C          defb %00000000,%00000000,%00000000,%00011100,%00111100,%00110000,%00110000,%00110000 ; char 217
 245+ 4733 3C 30 30 30
 246+ 4737 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00110000,%00110000,%00110000 ; char 218
 246+ 473B F0 30 30 30
 247+ 473F 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 247+ 4743 E0 00 00 00
 248+ 4747 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00011100,%00000000,%00000000,%00000000 ; char 220
 248+ 474B 1C 00 00 00
 249+ 474F 00 30 48 48          defb %00000000,%00110000,%01001000,%01001000,%01001000,%00110000,%00000000,%00000000 ; char 221
 249+ 4753 48 30 00 00
 250+ 4757 00 30 78 78          defb %00000000,%00110000,%01111000,%01111000,%01111000,%00110000,%00000000,%00000000 ; char 222
 250+ 475B 78 30 00 00
 251+ 475F 00 30 78 FC          defb %00000000,%00110000,%01111000,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 223
 251+ 4763 FC 78 30 00
 252+ 4767 FC F8 F0 E0          defb %11111100,%11111000,%11110000,%11100000,%11100000,%11000000,%10000000,%10000000 ; char 224
 252+ 476B E0 C0 80 80
 253+ 476F FC 7C 3C 1C          defb %11111100,%01111100,%00111100,%00011100,%00011100,%00001100,%00000100,%00000100 ; char 225
 253+ 4773 1C 0C 04 04
 254+ 4777 04 04 0C 1C          defb %00000100,%00000100,%00001100,%00011100,%00011100,%00111100,%01111100,%11111100 ; char 226
 254+ 477B 1C 3C 7C FC
 255+ 477F 80 80 C0 E0          defb %10000000,%10000000,%11000000,%11100000,%11100000,%11110000,%11111000,%11111100 ; char 227
 255+ 4783 E0 F0 F8 FC
 256+ 4787 00 04 0C D8          defb %00000000,%00000100,%00001100,%11011000,%11110000,%11100000,%11000000,%00000000 ; char 228 (checkmark)
 256+ 478B F0 E0 C0 00
 257+ 478F 00 CC 78 30          defb %00000000,%11001100,%01111000,%00110000,%01111000,%11001100,%00000000,%00000000 ; char 229 (x)
 257+ 4793 78 CC 00 00
 258+ 4797 70 88 88 88          defb %01110000,%10001000,%10001000,%10001000,%01110000,%00100000,%01110000,%00100000 ; char 230 (female)
 258+ 479B 70 20 70 20
 259+ 479F 00 1C 0C 74          defb %00000000,%00011100,%00001100,%01110100,%10010000,%10010000,%01100000,%00000000 ; char 231 (male)
 259+ 47A3 90 90 60 00
 260+ 47A7 F8 84 84 84          defb %11111000,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 232 (new doc)
 260+ 47AB 84 84 84 FC
 261+ 47AF 00 F0 FC 84          defb %00000000,%11110000,%11111100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 233 (folder)
 261+ 47B3 84 84 84 FC
 262+ 47B7 30 78 FC 48          defb %00110000,%01111000,%11111100,%01001000,%01001000,%01001000,%01001000,%01111000 ; char 234 (trash bin)
 262+ 47BB 48 48 48 78
 263+ 47BF FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%11111100,%10110100,%10110100,%11111100 ; char 235 (floppy disk)
 263+ 47C3 FC B4 B4 FC
 264+ 47C7 00 00 D4 D8          defb %00000000,%00000000,%11010100,%11011000,%11010100,%11010100,%00000000,%00000000 ; char 236 (OK)
 264+ 47CB D4 D4 00 00
 265+ 47CF 30 78 FC 78          defb %00110000,%01111000,%11111100,%01111000,%01111000,%01001000,%01001000,%01001000 ; char 237 (home)
 265+ 47D3 78 48 48 48
 266+ 47D7 78 84 A4 A4          defb %01111000,%10000100,%10100100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 238 (clock)
 266+ 47DB B4 84 78 00
 267+ 47DF 00 00 08 F4          defb %00000000,%00000000,%00001000,%11110100,%10101000,%10000000,%00000000,%00000000 ; char 239 (key)
 267+ 47E3 A8 80 00 00
 268+ 47E7 20 30 78 B0          defb %00100000,%00110000,%01111000,%10110000,%10100000,%10001000,%01110000,%00000000 ; char 240 (undo)
 268+ 47EB A0 88 70 00
 269+ 47EF 00 FC CC B4          defb %00000000,%11111100,%11001100,%10110100,%10000100,%10000100,%11111100,%00000000 ; char 241 (letter)
 269+ 47F3 84 84 FC 00
 270+ 47F7 60 90 90 F0          defb %01100000,%10010000,%10010000,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 242 (lock)
 270+ 47FB F0 F0 F0 00
 271+ 47FF 08 14 14 F0          defb %00001000,%00010100,%00010100,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 243 (unlock)
 271+ 4803 F0 F0 F0 00
 272+ 4807 FC FC 84 B4          defb %11111100,%11111100,%10000100,%10110100,%10010100,%10010100,%10000100,%11111100 ; char 244 (calendar)
 272+ 480B 94 94 84 FC
 273+ 480F 00 04 38 58          defb %00000000,%00000100,%00111000,%01011000,%01101000,%01110000,%10000000,%00000000 ; char 245 (diameter)
 273+ 4813 68 70 80 00
 274+ 4817 78 84 84 84          defb %01111000,%10000100,%10000100,%10000100,%01101100,%00011000,%00001000,%00000000 ; char 246 (baloon)
 274+ 481B 6C 18 08 00
 275+ 481F 30 28 28 28          defb %00110000,%00101000,%00101000,%00101000,%00100000,%01100000,%11100000,%01000000 ; char 247 (note)
 275+ 4823 20 60 E0 40
 276+ 4827 20 68 E4 E4          defb %00100000,%01101000,%11100100,%11100100,%11100100,%01101000,%00100000,%00000000 ; char 248 (audio on)
 276+ 482B E4 68 20 00
 277+ 482F 20 60 E0 E0          defb %00100000,%01100000,%11100000,%11100000,%11100000,%01100000,%00100000,%00000000 ; char 249 (audio off)
 277+ 4833 E0 60 20 00
 278+ 4837 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11110000,%10010000 ; char 250 (pointer)
 278+ 483B F8 FC F0 90
 279+ 483F 78 84 B4 A4          defb %01111000,%10000100,%10110100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 251 (Â©)
 279+ 4843 B4 84 78 00
 280+ 4847 30 48 40 E0          defb %00110000,%01001000,%01000000,%11100000,%01000000,%01001000,%10110000,%00000000 ; char 252 (Â£)
 280+ 484B 40 48 B0 00
 281+ 484F 78 84 F0 48          defb %01111000,%10000100,%11110000,%01001000,%01001000,%00111100,%10000100,%01111000 ; char 253 (Â§)
 281+ 4853 48 3C 84 78
 282+ 4857 00 00 20 00          defb %00000000,%00000000,%00100000,%00000000,%11111000,%00000000,%00100000,%00000000 ; char 254 (Ã·)
 282+ 485B F8 00 20 00
 283+ 485F FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 255 (cursor)
 283+ 4863 FC FC FC FC
 284+ 4867                      ; here ends the ASCII table
 285+ 4867
# file closed: ../include/vdp/6x8fonts-r16.asm
  86  4867                  INCLUDE "../include/vdp/8x8fonts-r18.asm"
# file opened: ../include/vdp/8x8fonts-r18.asm
   1+ 4867              ; ------------------------------------------------------------------------------
   2+ 4867              ; LM80C - 8x8 CHARSET - R1.8
   3+ 4867              ; ------------------------------------------------------------------------------
   4+ 4867              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4867              ; designed by Leonardo Miliani. More info at
   6+ 4867              ; www DOT leonardomiliani DOT com
   7+ 4867              ; ------------------------------------------------------------------------------
   8+ 4867              ; Code Revision:
   9+ 4867              ; R1.0 - 20190615 - First revision: ASCII chars (from 0 to 255) - actually, they are 6x8 pixels
  10+ 4867              ; R1.1 - 20190616 - Converted to 8x8 pixels
  11+ 4867              ; R1.2 - 20191013 - Added new graphic chars and reorganized previous ones
  12+ 4867              ; R1.3 - 20191015 - More graphic chars
  13+ 4867              ; R1.4 - 20191202 - Fixed char 11/12, added new special chars
  14+ 4867              ; R1.5 - 20191210 - Changed several graphic chars
  15+ 4867              ; R1.6 - 20200125 - Removed double chars, changed with new ones
  16+ 4867              ; R1.7 - 20200228 - adopted more usual hexadecimal & binary prefixes
  17+ 4867              ; R1.8 - 20200524 - New style for char #252
  18+ 4867              ; ------------------------------------------------------------------------------
  19+ 4867              ;
  20+ 4867              ;-------------------------------------------------------------------------------
  21+ 4867              ;
  22+ 4867              ;               8 x 8    C  H  A  R  S  E  T
  23+ 4867              ;
  24+ 4867              ;-------------------------------------------------------------------------------
  25+ 4867              ;
  26+ 4867              ;       8X8 CHARS, DESIGNED FOR GRAPHICS 1 MODE
  27+ 4867
  28+ 4867              CHRST88 equ $
  29+ 4867 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  29+ 486B 00 00 00 00
  30+ 486F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  30+ 4873 00 00 00 00
  31+ 4877 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  31+ 487B 00 00 00 00
  32+ 487F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  32+ 4883 00 00 00 00
  33+ 4887 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  33+ 488B 00 00 00 00
  34+ 488F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  34+ 4893 00 00 00 00
  35+ 4897 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  35+ 489B 00 00 00 00
  36+ 489F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  36+ 48A3 00 00 00 00
  37+ 48A7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 DEL key (backspace)
  37+ 48AB 00 00 00 00
  38+ 48AF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  38+ 48B3 00 00 00 00
  39+ 48B7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  39+ 48BB 00 00 00 00
  40+ 48BF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 (unused)
  40+ 48C3 00 00 00 00
  41+ 48C7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  41+ 48CB 00 00 00 00
  42+ 48CF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 RETURN key (carriage return)
  42+ 48D3 00 00 00 00
  43+ 48D7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL key
  43+ 48DB 00 00 00 00
  44+ 48DF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  44+ 48E3 00 00 00 00
  45+ 48E7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  45+ 48EB 00 00 00 00
  46+ 48EF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  46+ 48F3 00 00 00 00
  47+ 48F7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  47+ 48FB 00 00 00 00
  48+ 48FF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  48+ 4903 00 00 00 00
  49+ 4907 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT key
  49+ 490B 00 00 00 00
  50+ 490F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  50+ 4913 00 00 00 00
  51+ 4917 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6 key
  51+ 491B 00 00 00 00
  52+ 491F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7 key
  52+ 4923 00 00 00 00
  53+ 4927 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP key
  53+ 492B 00 00 00 00
  54+ 492F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 HOME key
  54+ 4933 00 00 00 00
  55+ 4937 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26 INSERT key
  55+ 493B 00 00 00 00
  56+ 493F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 ESCAPE key
  56+ 4943 00 00 00 00
  57+ 4947 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 CRSR LEFT key (cursor left)
  57+ 494B 00 00 00 00
  58+ 494F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 CRSR RIGHT key (cursor right)
  58+ 4953 00 00 00 00
  59+ 4957 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 CRSR UP key (cursor up)
  59+ 495B 00 00 00 00
  60+ 495F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 CRSR DOWN key (cursor down)
  60+ 4963 00 00 00 00
  61+ 4967 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32 SPACE key
  61+ 496B 00 00 00 00
  62+ 496F 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00000000,%00010000,%00000000 ; char 33 - !
  62+ 4973 10 00 10 00
  63+ 4977 28 28 28 00          defb %00101000,%00101000,%00101000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 34 - "
  63+ 497B 00 00 00 00
  64+ 497F 28 28 FE 28          defb %00101000,%00101000,%11111110,%00101000,%11111110,%00101000,%00101000,%00000000 ; char 35 - #
  64+ 4983 FE 28 28 00
  65+ 4987 10 3C 50 38          defb %00010000,%00111100,%01010000,%00111000,%00010100,%01111000,%00010000,%00000000 ; char 36 - $
  65+ 498B 14 78 10 00
  66+ 498F 00 62 64 08          defb %00000000,%01100010,%01100100,%00001000,%00010000,%00100110,%01000110,%00000000 ; char 37 - %
  66+ 4993 10 26 46 00
  67+ 4997 00 30 48 30          defb %00000000,%00110000,%01001000,%00110000,%01001010,%01000100,%00111010,%00000000 ; char 38 - &
  67+ 499B 4A 44 3A 00
  68+ 499F 08 10 20 00          defb %00001000,%00010000,%00100000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 39 - '
  68+ 49A3 00 00 00 00
  69+ 49A7 08 10 20 20          defb %00001000,%00010000,%00100000,%00100000,%00100000,%00010000,%00001000,%00000000 ; char 40 - (
  69+ 49AB 20 10 08 00
  70+ 49AF 20 10 08 08          defb %00100000,%00010000,%00001000,%00001000,%00001000,%00010000,%00100000,%00000000 ; char 41 - )
  70+ 49B3 08 10 20 00
  71+ 49B7 00 10 54 38          defb %00000000,%00010000,%01010100,%00111000,%00111000,%01010100,%00010000,%00000000 ; char 42 - *
  71+ 49BB 38 54 10 00
  72+ 49BF 00 10 10 7C          defb %00000000,%00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%00000000 ; char 43 - +
  72+ 49C3 10 10 00 00
  73+ 49C7 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00001000,%00010000 ; char 44 - ,
  73+ 49CB 00 18 08 10
  74+ 49CF 00 00 00 7C          defb %00000000,%00000000,%00000000,%01111100,%00000000,%00000000,%00000000,%00000000 ; char 45 - -
  74+ 49D3 00 00 00 00
  75+ 49D7 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00011000,%00000000 ; char 46 - .
  75+ 49DB 00 18 18 00
  76+ 49DF 00 02 04 08          defb %00000000,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%00000000 ; char 47 - /
  76+ 49E3 10 20 40 00
  77+ 49E7 38 44 4C 54          defb %00111000,%01000100,%01001100,%01010100,%01100100,%01000100,%00111000,%00000000 ; char 48 - 0
  77+ 49EB 64 44 38 00
  78+ 49EF 10 30 50 10          defb %00010000,%00110000,%01010000,%00010000,%00010000,%00010000,%01111100,%00000000 ; char 49 - 1
  78+ 49F3 10 10 7C 00
  79+ 49F7 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 50 - 2
  79+ 49FB 10 20 7C 00
  80+ 49FF 7C 08 10 08          defb %01111100,%00001000,%00010000,%00001000,%00000100,%01000100,%00111000,%00000000 ; char 51 - 3
  80+ 4A03 04 44 38 00
  81+ 4A07 08 18 28 48          defb %00001000,%00011000,%00101000,%01001000,%01111100,%00001000,%00001000,%00000000 ; char 52 - 4
  81+ 4A0B 7C 08 08 00
  82+ 4A0F 7C 40 78 04          defb %01111100,%01000000,%01111000,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 53 - 5
  82+ 4A13 04 44 38 00
  83+ 4A17 38 44 40 78          defb %00111000,%01000100,%01000000,%01111000,%01000100,%01000100,%00111000,%00000000 ; char 54 - 6
  83+ 4A1B 44 44 38 00
  84+ 4A1F 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%00100000,%00100000,%00000000 ; char 55 - 7
  84+ 4A23 20 20 20 00
  85+ 4A27 38 44 44 38          defb %00111000,%01000100,%01000100,%00111000,%01000100,%01000100,%00111000,%00000000 ; char 56 - 8
  85+ 4A2B 44 44 38 00
  86+ 4A2F 38 44 44 3C          defb %00111000,%01000100,%01000100,%00111100,%00000100,%01000100,%00111000,%00000000 ; char 57 - 9
  86+ 4A33 04 44 38 00
  87+ 4A37 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00011000,%00000000,%00000000 ; char 58 - :
  87+ 4A3B 18 18 00 00
  88+ 4A3F 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00001000,%00010000,%00000000 ; char 59 - ;
  88+ 4A43 18 08 10 00
  89+ 4A47 04 08 10 20          defb %00000100,%00001000,%00010000,%00100000,%00010000,%00001000,%00000100,%00000000 ; char 60 - <
  89+ 4A4B 10 08 04 00
  90+ 4A4F 00 00 7E 00          defb %00000000,%00000000,%01111110,%00000000,%01111110,%00000000,%00000000,%00000000 ; char 61 - =
  90+ 4A53 7E 00 00 00
  91+ 4A57 20 10 08 04          defb %00100000,%00010000,%00001000,%00000100,%00001000,%00010000,%00100000,%00000000 ; char 62 - >
  91+ 4A5B 08 10 20 00
  92+ 4A5F 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00000000,%00010000,%00000000 ; char 63 - ?
  92+ 4A63 10 00 10 00
  93+ 4A67 78 84 BC AC          defb %01111000,%10000100,%10111100,%10101100,%10111000,%10000000,%10000100,%01111000 ; char 64 - @
  93+ 4A6B B8 80 84 78
  94+ 4A6F 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%00000000 ; char 65 - A
  94+ 4A73 7C 44 44 00
  95+ 4A77 78 44 44 78          defb %01111000,%01000100,%01000100,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 66 - B
  95+ 4A7B 44 44 78 00
  96+ 4A7F 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 67 - C
  96+ 4A83 40 44 38 00
  97+ 4A87 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01000100,%01000100,%01111000,%00000000 ; char 68 - D
  97+ 4A8B 44 44 78 00
  98+ 4A8F 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01111100,%00000000 ; char 69 - E
  98+ 4A93 40 40 7C 00
  99+ 4A97 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01000000,%00000000 ; char 70 - F
  99+ 4A9B 40 40 40 00
 100+ 4A9F 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01011100,%01000100,%00111000,%00000000 ; char 71 - G
 100+ 4AA3 5C 44 38 00
 101+ 4AA7 44 44 44 7C          defb %01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%01000100,%00000000 ; char 72 - H
 101+ 4AAB 44 44 44 00
 102+ 4AAF 38 10 10 10          defb %00111000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 73 - I
 102+ 4AB3 10 10 38 00
 103+ 4AB7 3C 04 04 04          defb %00111100,%00000100,%00000100,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 74 - J
 103+ 4ABB 04 44 38 00
 104+ 4ABF 44 44 48 70          defb %01000100,%01000100,%01001000,%01110000,%01001000,%01000100,%01000100,%00000000 ; char 75 - K
 104+ 4AC3 48 44 44 00
 105+ 4AC7 40 40 40 40          defb %01000000,%01000000,%01000000,%01000000,%01000000,%01000000,%01111100,%00000000 ; char 76 - L
 105+ 4ACB 40 40 7C 00
 106+ 4ACF 42 66 5A 42          defb %01000010,%01100110,%01011010,%01000010,%01000010,%01000010,%01000010,%00000000 ; char 77 - M
 106+ 4AD3 42 42 42 00
 107+ 4AD7 44 64 54 4C          defb %01000100,%01100100,%01010100,%01001100,%01000100,%01000100,%01000100,%00000000 ; char 78 - N
 107+ 4ADB 44 44 44 00
 108+ 4ADF 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 79 - O
 108+ 4AE3 44 44 38 00
 109+ 4AE7 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01000000,%01000000,%00000000 ; char 80 - P
 109+ 4AEB 78 40 40 00
 110+ 4AEF 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01010100,%01001000,%00110100,%00000000 ; char 81 - Q
 110+ 4AF3 54 48 34 00
 111+ 4AF7 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01001000,%01000100,%00000000 ; char 82 - R
 111+ 4AFB 78 48 44 00
 112+ 4AFF 3C 40 40 38          defb %00111100,%01000000,%01000000,%00111000,%00000100,%00000100,%01111000,%00000000 ; char 83 - S
 112+ 4B03 04 04 78 00
 113+ 4B07 7C 10 10 10          defb %01111100,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 84 - T
 113+ 4B0B 10 10 10 00
 114+ 4B0F 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 85 - U
 114+ 4B13 44 44 38 00
 115+ 4B17 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 86 - V
 115+ 4B1B 44 28 10 00
 116+ 4B1F 42 42 42 42          defb %01000010,%01000010,%01000010,%01000010,%01011010,%01011010,%00100100,%00000000 ; char 87 - W
 116+ 4B23 5A 5A 24 00
 117+ 4B27 44 44 28 10          defb %01000100,%01000100,%00101000,%00010000,%00101000,%01000100,%01000100,%00000000 ; char 88 - X
 117+ 4B2B 28 44 44 00
 118+ 4B2F 44 44 44 28          defb %01000100,%01000100,%01000100,%00101000,%00010000,%00010000,%00010000,%00000000 ; char 89 - Y
 118+ 4B33 10 10 10 00
 119+ 4B37 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%01000000,%01111100,%00000000 ; char 90 - Z
 119+ 4B3B 20 40 7C 00
 120+ 4B3F 38 20 20 20          defb %00111000,%00100000,%00100000,%00100000,%00100000,%00100000,%00111000,%00000000 ; char 91 - [
 120+ 4B43 20 20 38 00
 121+ 4B47 00 40 20 10          defb %00000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000000 ; char 92 - \
 121+ 4B4B 08 04 02 00
 122+ 4B4F 38 08 08 08          defb %00111000,%00001000,%00001000,%00001000,%00001000,%00001000,%00111000,%00000000 ; char 93 - ]
 122+ 4B53 08 08 38 00
 123+ 4B57 10 28 44 00          defb %00010000,%00101000,%01000100,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 94 - ^
 123+ 4B5B 00 00 00 00
 124+ 4B5F 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%01111110,%00000000 ; char 95 _ (underscore)
 124+ 4B63 00 00 7E 00
 125+ 4B67 20 10 08 00          defb %00100000,%00010000,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 96 - `
 125+ 4B6B 00 00 00 00
 126+ 4B6F 00 00 38 04          defb %00000000,%00000000,%00111000,%00000100,%00111100,%01000100,%00111100,%00000000 ; char 97 - a
 126+ 4B73 3C 44 3C 00
 127+ 4B77 40 40 40 78          defb %01000000,%01000000,%01000000,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 98 - b
 127+ 4B7B 44 44 78 00
 128+ 4B7F 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 99 - c
 128+ 4B83 40 44 38 00
 129+ 4B87 04 04 04 3C          defb %00000100,%00000100,%00000100,%00111100,%01000100,%01000100,%00111100,%00000000 ; char 100 - d
 129+ 4B8B 44 44 3C 00
 130+ 4B8F 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01111100,%01000000,%00111000,%00000000 ; char 101 - e
 130+ 4B93 7C 40 38 00
 131+ 4B97 18 24 20 70          defb %00011000,%00100100,%00100000,%01110000,%00100000,%00100000,%00100000,%00000000 ; char 102 - f
 131+ 4B9B 20 20 20 00
 132+ 4B9F 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00111000 ; char 103 - g
 132+ 4BA3 44 3C 04 38
 133+ 4BA7 40 40 58 64          defb %01000000,%01000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 104 - h
 133+ 4BAB 44 44 44 00
 134+ 4BAF 00 10 00 10          defb %00000000,%00010000,%00000000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 105 - i
 134+ 4BB3 10 10 10 00
 135+ 4BB7 08 00 18 08          defb %00001000,%00000000,%00011000,%00001000,%00001000,%00001000,%01001000,%00110000 ; char 106 - j
 135+ 4BBB 08 08 48 30
 136+ 4BBF 40 40 48 50          defb %01000000,%01000000,%01001000,%01010000,%01100000,%01010000,%01001000,%00000000 ; char 107 - k
 136+ 4BC3 60 50 48 00
 137+ 4BC7 30 10 10 10          defb %00110000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 108 - l
 137+ 4BCB 10 10 38 00
 138+ 4BCF 00 00 54 6A          defb %00000000,%00000000,%01010100,%01101010,%01001010,%01000010,%01000010,%00000000 ; char 109 - m
 138+ 4BD3 4A 42 42 00
 139+ 4BD7 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 110 - n
 139+ 4BDB 44 44 44 00
 140+ 4BDF 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 111: o
 140+ 4BE3 44 44 38 00
 141+ 4BE7 00 00 78 44          defb %00000000,%00000000,%01111000,%01000100,%01000100,%01111000,%01000000,%01000000 ; char 112: p
 141+ 4BEB 44 78 40 40
 142+ 4BEF 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00000100 ; char 113: q
 142+ 4BF3 44 3C 04 04
 143+ 4BF7 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000000,%01000000,%01000000,%00000000 ; char 114: r
 143+ 4BFB 40 40 40 00
 144+ 4BFF 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%00111000,%00000100,%01111000,%00000000 ; char 115: s
 144+ 4C03 38 04 78 00
 145+ 4C07 20 20 70 20          defb %00100000,%00100000,%01110000,%00100000,%00100000,%00100100,%00011000,%00000000 ; char 116: t
 145+ 4C0B 20 24 18 00
 146+ 4C0F 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%01001100,%00110100,%00000000 ; char 117: u
 146+ 4C13 44 4C 34 00
 147+ 4C17 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 118: v
 147+ 4C1B 44 28 10 00
 148+ 4C1F 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01010100,%01010100,%00101000,%00000000 ; char 119: w
 148+ 4C23 54 54 28 00
 149+ 4C27 00 00 44 28          defb %00000000,%00000000,%01000100,%00101000,%00010000,%00101000,%01000100,%00000000 ; char 120: x
 149+ 4C2B 10 28 44 00
 150+ 4C2F 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01001100,%00110100,%00000100,%00111000 ; char 121: y
 150+ 4C33 4C 34 04 38
 151+ 4C37 00 00 7C 08          defb %00000000,%00000000,%01111100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 122: z
 151+ 4C3B 10 20 7C 00
 152+ 4C3F 18 20 20 40          defb %00011000,%00100000,%00100000,%01000000,%00100000,%00100000,%00011000,%00000000 ; char 123: {
 152+ 4C43 20 20 18 00
 153+ 4C47 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 124: |
 153+ 4C4B 10 10 10 00
 154+ 4C4F 30 08 08 04          defb %00110000,%00001000,%00001000,%00000100,%00001000,%00001000,%00110000,%00000000 ; char 125: }
 154+ 4C53 08 08 30 00
 155+ 4C57 20 54 08 00          defb %00100000,%01010100,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 126: ~
 155+ 4C5B 00 00 00 00
 156+ 4C5F 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 127 (delete) - end the standard ASCII (0-127)
 156+ 4C63 00 00 00 00
 157+ 4C67 3C 42 A5 81          defb %00111100,%01000010,%10100101,%10000001,%10100101,%10011001,%01000010,%00111100 ; char 128 (open face)
 157+ 4C6B A5 99 42 3C
 158+ 4C6F 3C 7E DB FF          defb %00111100,%01111110,%11011011,%11111111,%11011011,%11100111,%01111110,%00111100 ; char 129 (full face)
 158+ 4C73 DB E7 7E 3C
 159+ 4C77 6C FE FE FE          defb %01101100,%11111110,%11111110,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 130 (hearts)
 159+ 4C7B 7C 38 10 00
 160+ 4C7F 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 131 (diamonds)
 160+ 4C83 7C 38 10 00
 161+ 4C87 10 38 54 FE          defb %00010000,%00111000,%01010100,%11111110,%01010100,%00010000,%01111100,%00000000 ; char 132 (clus)
 161+ 4C8B 54 10 7C 00
 162+ 4C8F 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%11010110,%00010000,%01111100,%00000000 ; char 133 (spades)
 162+ 4C93 D6 10 7C 00
 163+ 4C97 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 134
 163+ 4C9B FF 18 18 18
 164+ 4C9F 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 135
 164+ 4CA3 1F 18 18 18
 165+ 4CA7 00 00 00 F8          defb %00000000,%00000000,%00000000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 136
 165+ 4CAB F8 18 18 18
 166+ 4CAF 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00000000,%00000000,%00000000 ; char 137
 166+ 4CB3 F8 00 00 00
 167+ 4CB7 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00000000,%00000000,%00000000 ; char 138
 167+ 4CBB 1F 00 00 00
 168+ 4CBF 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 139
 168+ 4CC3 FF 00 00 00
 169+ 4CC7 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 140
 169+ 4CCB 1F 18 18 18
 170+ 4CCF 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 141
 170+ 4CD3 FF 18 18 18
 171+ 4CD7 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 142
 171+ 4CDB F8 18 18 18
 172+ 4CDF 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 143
 172+ 4CE3 FF 00 00 00
 173+ 4CE7 18 18 18 18          defb %00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000 ; char 144
 173+ 4CEB 18 18 18 18
 174+ 4CEF 03 07 0E 1C          defb %00000011,%00000111,%00001110,%00011100,%00111000,%01110000,%11100000,%11000000 ; char 145
 174+ 4CF3 38 70 E0 C0
 175+ 4CF7 C0 E0 70 38          defb %11000000,%11100000,%01110000,%00111000,%00011100,%00001110,%00000111,%00000011 ; char 146
 175+ 4CFB 1C 0E 07 03
 176+ 4CFF C3 E7 7E 3C          defb %11000011,%11100111,%01111110,%00111100,%00111100,%01111110,%11100111,%11000011 ; char 147
 176+ 4D03 3C 7E E7 C3
 177+ 4D07 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 148
 177+ 4D0B 10 10 10 10
 178+ 4D0F 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 149
 178+ 4D13 10 10 10 10
 179+ 4D17 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 150
 179+ 4D1B 10 10 10 10
 180+ 4D1F 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 151
 180+ 4D23 00 00 00 00
 181+ 4D27 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00000000,%00000000,%00000000,%00000000 ; char 152
 181+ 4D2B 00 00 00 00
 182+ 4D2F 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 153
 182+ 4D33 00 00 00 00
 183+ 4D37 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 154
 183+ 4D3B 10 10 10 10
 184+ 4D3F 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 155
 184+ 4D43 10 10 10 10
 185+ 4D47 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 156
 185+ 4D4B 10 10 10 10
 186+ 4D4F 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 157
 186+ 4D53 00 00 00 00
 187+ 4D57 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000 ; char 158
 187+ 4D5B 10 10 10 10
 188+ 4D5F 01 02 04 08          defb %00000001,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%10000000 ; char 159
 188+ 4D63 10 20 40 80
 189+ 4D67 80 40 20 10          defb %10000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000001 ; char 160
 189+ 4D6B 08 04 02 01
 190+ 4D6F 81 42 24 18          defb %10000001,%01000010,%00100100,%00011000,%00011000,%00100100,%01000010,%10000001 ; char 161
 190+ 4D73 18 24 42 81
 191+ 4D77 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 162
 191+ 4D7B 00 00 FF FF
 192+ 4D7F 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; char 163
 192+ 4D83 FF FF FF FF
 193+ 4D87 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 164
 193+ 4D8B FF FF FF FF
 194+ 4D8F FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 194+ 4D93 00 00 00 00
 195+ 4D97 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 166
 195+ 4D9B 00 00 00 00
 196+ 4D9F FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 167
 196+ 4DA3 FF FF 00 00
 197+ 4DA7 C0 C0 C0 C0          defb %11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000 ; char 168
 197+ 4DAB C0 C0 C0 C0
 198+ 4DAF F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; char 169
 198+ 4DB3 F0 F0 F0 F0
 199+ 4DB7 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 170
 199+ 4DBB FC FC FC FC
 200+ 4DBF 03 03 03 03          defb %00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011 ; char 171
 200+ 4DC3 03 03 03 03
 201+ 4DC7 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; char 172
 201+ 4DCB 0F 0F 0F 0F
 202+ 4DCF 3F 3F 3F 3F          defb %00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111 ; char 173
 202+ 4DD3 3F 3F 3F 3F
 203+ 4DD7 FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 174
 203+ 4DDB 81 81 81 FF
 204+ 4DDF 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; char 175
 204+ 4DE3 F0 F0 F0 F0
 205+ 4DE7 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; char 176
 205+ 4DEB 0F 0F 0F 0F
 206+ 4DEF 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; char 177
 206+ 4DF3 00 00 00 00
 207+ 4DF7 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 178
 207+ 4DFB 00 00 00 00
 208+ 4DFF F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00001111,%00001111,%00001111,%00001111 ; char 179
 208+ 4E03 0F 0F 0F 0F
 209+ 4E07 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%11110000,%11110000,%11110000,%11110000 ; char 180
 209+ 4E0B F0 F0 F0 F0
 210+ 4E0F 3C 3C 3C 3C          defb %00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100 ; char 181
 210+ 4E13 3C 3C 3C 3C
 211+ 4E17 C3 C3 C3 C3          defb %11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011 ; char 182
 211+ 4E1B C3 C3 C3 C3
 212+ 4E1F FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 183
 212+ 4E23 00 00 FF FF
 213+ 4E27 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 184
 213+ 4E2B FF FF 00 00
 214+ 4E2F 33 33 CC CC          defb %00110011,%00110011,%11001100,%11001100,%00110011,%00110011,%11001100,%11001100 ; char 185
 214+ 4E33 33 33 CC CC
 215+ 4E37 55 AA 55 AA          defb %01010101,%10101010,%01010101,%10101010,%01010101,%10101010,%01010101,%10101010 ; char 186
 215+ 4E3B 55 AA 55 AA
 216+ 4E3F 66 33 99 CC          defb %01100110,%00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100 ; char 187
 216+ 4E43 66 33 99 CC
 217+ 4E47 CC 99 33 66          defb %11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011,%01100110 ; char 188
 217+ 4E4B CC 99 33 66
 218+ 4E4F 33 99 CC 66          defb %00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100,%01100110 ; char 189
 218+ 4E53 33 99 CC 66
 219+ 4E57 66 CC 99 33          defb %01100110,%11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011 ; char 190
 219+ 4E5B 66 CC 99 33
 220+ 4E5F 10 10 7C 10          defb %00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%01111100,%00000000 ; char 191 (Â±)
 220+ 4E63 10 00 7C 00
 221+ 4E67 60 18 06 18          defb %01100000,%00011000,%00000110,%00011000,%01100000,%00000000,%01111110,%00000000 ; char 192 (â¥)
 221+ 4E6B 60 00 7E 00
 222+ 4E6F 06 18 60 18          defb %00000110,%00011000,%01100000,%00011000,%00000110,%00000000,%01111110,%00000000 ; char 193 (â¤)
 222+ 4E73 06 00 7E 00
 223+ 4E77 3E 20 20 20          defb %00111110,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 223+ 4E7B A0 60 20 00
 224+ 4E7F 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 224+ 4E83 00 00 00 00
 225+ 4E87 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 225+ 4E8B 70 00 00 00
 226+ 4E8F 00 00 2A 54          defb %00000000,%00000000,%00101010,%01010100,%00000000,%01111110,%00000000,%00000000 ; char 197
 226+ 4E93 00 7E 00 00
 227+ 4E97 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 227+ 4E9B 54 A8 00 00
 228+ 4E9F 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11100000,%11000000,%10000000,%00000000 ; char 199
 228+ 4EA3 E0 C0 80 00
 229+ 4EA7 FE 7C 38 10          defb %11111110,%01111100,%00111000,%00010000,%00000000,%00000000,%00000000,%00000000 ; char 200
 229+ 4EAB 00 00 00 00
 230+ 4EAF 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00000111,%00000011,%00000001,%00000000 ; char 201
 230+ 4EB3 07 03 01 00
 231+ 4EB7 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00010000,%00111000,%01111100,%11111110 ; char 202
 231+ 4EBB 10 38 7C FE
 232+ 4EBF 10 38 7C 10          defb %00010000,%00111000,%01111100,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 203 (up arrow)
 232+ 4EC3 10 10 10 00
 233+ 4EC7 1E 0E 0E 12          defb %00011110,%00001110,%00001110,%00010010,%00100000,%01000000,%00000000,%00000000 ; char 204 (up right arrow)
 233+ 4ECB 20 40 00 00
 234+ 4ECF 00 08 0C FE          defb %00000000,%00001000,%00001100,%11111110,%00001100,%00001000,%00000000,%00000000 ; char 205 (right arrow)
 234+ 4ED3 0C 08 00 00
 235+ 4ED7 00 40 20 12          defb %00000000,%01000000,%00100000,%00010010,%00001110,%00001110,%00011110,%00000000 ; char 206 (down right arrow)
 235+ 4EDB 0E 0E 1E 00
 236+ 4EDF 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%01111100,%00111000,%00010000,%00000000 ; char 207 (down arrow)
 236+ 4EE3 7C 38 10 00
 237+ 4EE7 00 04 08 90          defb %00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000,%00000000 ; char 208 (down left arrow)
 237+ 4EEB E0 E0 F0 00
 238+ 4EEF 00 20 60 FE          defb %00000000,%00100000,%01100000,%11111110,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 238+ 4EF3 60 20 00 00
 239+ 4EF7 F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 239+ 4EFB 08 04 00 00
 240+ 4EFF 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 240+ 4F03 F0 44 38 00
 241+ 4F07 00 02 7C A8          defb %00000000,%00000010,%01111100,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 241+ 4F0B 28 28 28 00
 242+ 4F0F 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001000,%00010000,%00010000,%00010000 ; char 213
 242+ 4F13 08 10 10 10
 243+ 4F17 00 00 00 C0          defb %00000000,%00000000,%00000000,%11000000,%00100000,%00010000,%00010000,%00010000 ; char 214
 243+ 4F1B 20 10 10 10
 244+ 4F1F 10 10 20 C0          defb %00010000,%00010000,%00100000,%11000000,%00000000,%00000000,%00000000,%00000000 ; char 215
 244+ 4F23 00 00 00 00
 245+ 4F27 10 10 08 07          defb %00010000,%00010000,%00001000,%00000111,%00000000,%00000000,%00000000,%00000000 ; char 216
 245+ 4F2B 00 00 00 00
 246+ 4F2F 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001111,%00011100,%00011000,%00011000 ; char 217
 246+ 4F33 0F 1C 18 18
 247+ 4F37 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00111000,%00011000,%00011000 ; char 218
 247+ 4F3B F0 38 18 18
 248+ 4F3F 18 18 38 F0          defb %00011000,%00011000,%00111000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 248+ 4F43 E0 00 00 00
 249+ 4F47 18 18 1C 0F          defb %00011000,%00011000,%00011100,%00001111,%00000111,%00000000,%00000000,%00000000 ; char 220
 249+ 4F4B 07 00 00 00
 250+ 4F4F 00 3C 42 42          defb %00000000,%00111100,%01000010,%01000010,%01000010,%01000010,%00111100,%00000000 ; char 221
 250+ 4F53 42 42 3C 00
 251+ 4F57 00 3C 7E 7E          defb %00000000,%00111100,%01111110,%01111110,%01111110,%01111110,%00111100,%00000000 ; char 222
 251+ 4F5B 7E 7E 3C 00
 252+ 4F5F 00 18 3C 7E          defb %00000000,%00011000,%00111100,%01111110,%01111110,%00111100,%00011000,%00000000 ; char 223
 252+ 4F63 7E 3C 18 00
 253+ 4F67 FF FE FC F8          defb %11111111,%11111110,%11111100,%11111000,%11110000,%11100000,%11000000,%10000000 ; char 224
 253+ 4F6B F0 E0 C0 80
 254+ 4F6F FF 7F 3F 1F          defb %11111111,%01111111,%00111111,%00011111,%00001111,%00000111,%00000011,%00000001 ; char 225
 254+ 4F73 0F 07 03 01
 255+ 4F77 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00011111,%00111111,%01111111,%11111111 ; char 226
 255+ 4F7B 1F 3F 7F FF
 256+ 4F7F 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11111110,%11111111 ; char 227
 256+ 4F83 F8 FC FE FF
 257+ 4F87 00 02 06 6C          defb %00000000,%00000010,%00000110,%01101100,%01111000,%01110000,%01100000,%00000000 ; char 228 (checkmark)
 257+ 4F8B 78 70 60 00
 258+ 4F8F 00 66 3C 18          defb %00000000,%01100110,%00111100,%00011000,%00111100,%01100110,%00000000,%00000000 ; char 229 (x)
 258+ 4F93 3C 66 00 00
 259+ 4F97 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%00111000,%00010000,%00111000,%00010000 ; char 230 (female)
 259+ 4F9B 38 10 38 10
 260+ 4F9F 07 03 3D 44          defb %00000111,%00000011,%00111101,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 231 (male)
 260+ 4FA3 44 44 38 00
 261+ 4FA7 78 44 42 42          defb %01111000,%01000100,%01000010,%01000010,%01000010,%01000010,%01000010,%01111110 ; char 232 (new doc)
 261+ 4FAB 42 42 42 7E
 262+ 4FAF 00 F8 FF 81          defb %00000000,%11111000,%11111111,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 233 (folder)
 262+ 4FB3 81 81 81 FF
 263+ 4FB7 10 7C FE 54          defb %00010000,%01111100,%11111110,%01010100,%01010100,%01010100,%01010100,%01111100 ; char 234 (trash bin)
 263+ 4FBB 54 54 54 7C
 264+ 4FBF FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10111101,%10101101,%10101101,%11111111 ; char 235 (floppy disk)
 264+ 4FC3 BD AD AD FF
 265+ 4FC7 00 EA AA AC          defb %00000000,%11101010,%10101010,%10101100,%10101100,%10101010,%11101010,%00000000 ; char 236 (OK)
 265+ 4FCB AC AA EA 00
 266+ 4FCF 18 7E FF 7E          defb %00011000,%01111110,%11111111,%01111110,%01111110,%01100110,%01100110,%01100110 ; char 237 (home)
 266+ 4FD3 7E 66 66 66
 267+ 4FD7 3C 42 91 91          defb %00111100,%01000010,%10010001,%10010001,%10011101,%10000001,%01000010,%00111100 ; char 238 (clock)
 267+ 4FDB 9D 81 42 3C
 268+ 4FDF 00 02 05 FD          defb %00000000,%00000010,%00000101,%11111101,%10100101,%10100010,%00000000,%00000000 ; char 239 (key)
 268+ 4FE3 A5 A2 00 00
 269+ 4FE7 08 0C 3E 4C          defb %00001000,%00001100,%00111110,%01001100,%01001000,%01000010,%01000010,%00111100 ; char 240 (undo)
 269+ 4FEB 48 42 42 3C
 270+ 4FEF 00 FF C3 A5          defb %00000000,%11111111,%11000011,%10100101,%10011001,%10000001,%11111111,%00000000 ; char 241 (letter)
 270+ 4FF3 99 81 FF 00
 271+ 4FF7 38 44 44 7C          defb %00111000,%01000100,%01000100,%01111100,%01111100,%01111100,%01111100,%00000000 ; char 242 (lock)
 271+ 4FFB 7C 7C 7C 00
 272+ 4FFF 06 09 09 F8          defb %00000110,%00001001,%00001001,%11111000,%11111000,%11111000,%11111000,%00000000 ; char 243 (unlock)
 272+ 5003 F8 F8 F8 00
 273+ 5007 FF FF 81 AD          defb %11111111,%11111111,%10000001,%10101101,%10100101,%10100101,%10000001,%11111111 ; char 244 (calendar)
 273+ 500B A5 A5 81 FF
 274+ 500F 01 1A 24 4A          defb %00000001,%00011010,%00100100,%01001010,%01010010,%00100100,%01011000,%10000000 ; char 245 (diameter)
 274+ 5013 52 24 58 80
 275+ 5017 7E 81 81 81          defb %01111110,%10000001,%10000001,%10000001,%10000001,%01110110,%00001100,%00000100 ; char 246 (baloon)
 275+ 501B 81 76 0C 04
 276+ 501F 0C 0A 0A 0A          defb %00001100,%00001010,%00001010,%00001010,%00001000,%00011000,%00111000,%00010000 ; char 247 (note)
 276+ 5023 08 18 38 10
 277+ 5027 12 31 F5 F5          defb %00010010,%00110001,%11110101,%11110101,%11110101,%11110101,%00110001,%00010010 ; char 248 (audio on)
 277+ 502B F5 F5 31 12
 278+ 502F 10 30 F0 F0          defb %00010000,%00110000,%11110000,%11110000,%11110000,%11110000,%00110000,%00010000 ; char 249 (audio off)
 278+ 5033 F0 F0 30 10
 279+ 5037 40 60 70 78          defb %01000000,%01100000,%01110000,%01111000,%01111100,%01111110,%01111000,%01001000 ; char 250 (pointer)
 279+ 503B 7C 7E 78 48
 280+ 503F 3C 42 99 A1          defb %00111100,%01000010,%10011001,%10100001,%10100001,%10011001,%01000010,%00111100 ; char 251 (Â©)
 280+ 5043 A1 99 42 3C
 281+ 5047 18 24 20 78          defb %00011000,%00100100,%00100000,%01111000,%00100000,%00100010,%01011100,%00000000 ; char 252 (Â£)
 281+ 504B 20 22 5C 00
 282+ 504F 3C 42 78 24          defb %00111100,%01000010,%01111000,%00100100,%00100100,%00011110,%01000010,%00111100 ; char 253 (Â§)
 282+ 5053 24 1E 42 3C
 283+ 5057 00 00 10 00          defb %00000000,%00000000,%00010000,%00000000,%01111100,%00000000,%00010000,%00000000 ; char 254 (Ã·)
 283+ 505B 7C 00 10 00
 284+ 505F FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 255 (cursor)
 284+ 5063 FF FF FF FF
 285+ 5067
# file closed: ../include/vdp/8x8fonts-r18.asm
  87  5067                  INCLUDE "../include/vdp/logo-fonts.asm"
# file opened: ../include/vdp/logo-fonts.asm
   1+ 5067              ; ------------------------------------------------------------------------------
   2+ 5067              ; LM80C - LOGO CHARSET - R1.1
   3+ 5067              ; ------------------------------------------------------------------------------
   4+ 5067              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 5067              ; designed by Leonardo Miliani. More info at
   6+ 5067              ; www DOT leonardomiliani DOT com
   7+ 5067              ; ------------------------------------------------------------------------------
   8+ 5067              ; Code Revision:
   9+ 5067              ; R1.0 - 20200124 - First revision: logo chars
  10+ 5067              ; R1.1 - 20200229 - Adopted usual hexadecimal & binary prefixes
  11+ 5067              ; ------------------------------------------------------------------------------
  12+ 5067
  13+ 5067              LOGOFONT:   equ $
  14+ 5067 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; 0
  14+ 506B 00 00 00 00
  15+ 506F FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; 1
  15+ 5073 FF FF FF FF
  16+ 5077 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; 2
  16+ 507B 00 00 00 00
  17+ 507F 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; 3
  17+ 5083 0F 0F 0F 0F
  18+ 5087 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; 4
  18+ 508B FF FF FF FF
  19+ 508F F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; 5
  19+ 5093 F0 F0 F0 F0
  20+ 5097 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; 6
  20+ 509B 0F 0F 0F 0F
  21+ 509F 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; 7
  21+ 50A3 F0 F0 F0 F0
  22+ 50A7 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; 8
  22+ 50AB 00 00 00 00
  23+ 50AF 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; 9
  23+ 50B3 00 00 00 00
  24+ 50B7 00 00 00 FC              defb %00000000,%00000000,%00000000,%11111100,%11111111,%00000111,%00000011,%00000000 ; 10
  24+ 50BB FF 07 03 00
  25+ 50BF 00 00 00 3F              defb %00000000,%00000000,%00000000,%00111111,%11111111,%11100000,%11000000,%00000000 ; 11
  25+ 50C3 FF E0 C0 00
  26+ 50C7 18 18 1F 19              defb %00011000,%00011000,%00011111,%00011001,%00011001,%00011111,%00011000,%00011000 ; 12
  26+ 50CB 19 1F 18 18
  27+ 50CF 18 18 F8 98              defb %00011000,%00011000,%11111000,%10011000,%10011000,%11111000,%00011000,%00011000 ; 13
  27+ 50D3 98 F8 18 18
  28+ 50D7 18 18 1C 1F              defb %00011000,%00011000,%00011100,%00011111,%00001111,%00000000,%00000000,%00000000 ; 14
  28+ 50DB 0F 00 00 00
  29+ 50DF 00 00 00 0F              defb %00000000,%00000000,%00000000,%00001111,%00011111,%00011100,%00011000,%00011000 ; 15
  29+ 50E3 1F 1C 18 18
  30+ 50E7 00 00 00 F0              defb %00000000,%00000000,%00000000,%11110000,%11111000,%00111000,%00011000,%00011000 ; 16
  30+ 50EB F8 38 18 18
  31+ 50EF 18 18 38 F8              defb %00011000,%00011000,%00111000,%11111000,%11110000,%00000000,%00000000,%00000000 ; 17
  31+ 50F3 F0 00 00 00
  32+ 50F7 00 00 00 FF              defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; 18
  32+ 50FB FF 00 00 00
  33+ 50FF 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%11111111,%11111111,%11111111,%11111111 ; 19
  33+ 5103 FF FF FF FF
  34+ 5107 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11111111,%11111111,%11111111,%11111111 ; 20
  34+ 510B FF FF FF FF
  35+ 510F FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11110000,%11110000,%11110000,%11110000 ; 21
  35+ 5113 F0 F0 F0 F0
  36+ 5117 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00001111,%00001111,%00001111,%00001111 ; 22
  36+ 511B 0F 0F 0F 0F
  37+ 511F 00 30 78 78              defb %00000000,%00110000,%01111000,%01111000,%00110000,%00000000,%00000000,%00000000 ; 23
  37+ 5123 30 00 00 00
  38+ 5127
# file closed: ../include/vdp/logo-fonts.asm
  88  5127
  89  5127              ; include workspace equates
  90  5127                  INCLUDE "../include/workspace/workspace-r1.0.asm"
# file opened: ../include/workspace/workspace-r1.0.asm
   1+ 5127              ; ------------------------------------------------------------------------------
   2+ 5127              ; LM80C 64K - WORKSPACE EQUATES - R1.0
   3+ 5127              ; ------------------------------------------------------------------------------
   4+ 5127              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 5127              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 5127              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 5127              ; kind of warranty: you can use them at your own risk.
   8+ 5127              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 5127              ; maintain the copyright notices, include this advice and the note to the
  10+ 5127              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 5127              ; redistribuite them.
  12+ 5127              ; https://www.leonardomiliani.com
  13+ 5127              ;
  14+ 5127              ; Please support me by visiting the following links:
  15+ 5127              ; Main project page: https://www.leonardomiliani.com
  16+ 5127              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 5127              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 5127              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 5127              ; ------------------------------------------------------------------------------
  20+ 5127
  21+ 5127              ; set starting of RAM based on computer model
  22+ 5127                  IFDEF LM80C64K
  23+ 5127 ~            SERBUF_START    equ     END_OF_FW       ; RAM starts here
  24+ 5127                  ELSE
  25+ 5127              SERBUF_START    equ     $8000           ; RAM starts here
  26+ 5127                  ENDIF
  27+ 5127
  28+ 5127              ;-------------------------------------------------------------------------------
  29+ 5127              serInPtr        equ     SERBUF_START + SER_BUFSIZE
  30+ 5127              serRdPtr        equ     serInPtr+2
  31+ 5127              serBufUsed      equ     serRdPtr+2
  32+ 5127              basicStarted    equ     serBufUsed+1
  33+ 5127              bufWrap         equ     (SERBUF_START + SER_BUFSIZE) & $FF
  34+ 5127              TEMPSTACK       equ     CURPOS - 3      ; top of BASIC line input buffer so is "free ram" when BASIC resets
  35+ 5127
  36+ 5127              ; BASIC WORK SPACE LOCATIONS
  37+ 5127              ; THE INTERPRETER ALLOCATES THE FOLLOWING RAM CELLS
  38+ 5127              ; TO STORE IMPORTANT VALUES USED FOR SOME SPECIFIC FUNCTIONS:
  39+ 5127              ; THEY CAN BE VECTOR (ADDRESSES) FUNCTIONS, SYSTEM DATAS (I.E. VARIABLES)
  40+ 5127              ; AND SO ON. THE FIRST CELLS ARE FILLED WITH VALUES STORED INTO ROM AT $(INITAB) ADDRESS
  41+ 5127              WRKSPC          equ     basicStarted+$01; (3) BASIC Work space
  42+ 5127              NMIUSR          equ     WRKSPC+$03      ; (3) NMI exit point routine
  43+ 5127              USR             equ     NMIUSR+$03      ; (3) "USR (x)" jump  <-- in (USR+$01)/(USR+$02) the user can store the address of a specific machine language routine
  44+ 5127              OUTSUB          equ     USR+$03         ; (1) "out p,n"
  45+ 5127              OTPORT          equ     OUTSUB+$01      ; (2) Port (p)
  46+ 5127              DIVSUP          equ     OTPORT+$02      ; (1) Division support routine
  47+ 5127              DIV1            equ     DIVSUP+$01      ; (4) <- Values
  48+ 5127              DIV2            equ     DIV1+$04        ; (4) <-   to
  49+ 5127              DIV3            equ     DIV2+$04        ; (3) <-   be
  50+ 5127              DIV4            equ     DIV3+$03        ; (2) <-inserted
  51+ 5127              SEED            equ     DIV4+$02        ; (35) Random number seed  <-- starting address of a seed table
  52+ 5127              LSTRND          equ     SEED+$23        ; (4) Last random number
  53+ 5127              INPSUB          equ     LSTRND+$04      ; (1) INP A,(x) Routine
  54+ 5127              INPORT          equ     INPSUB+$01      ; (2) PORT (x)
  55+ 5127              LWIDTH          equ     INPORT+$02      ; (1) Terminal width
  56+ 5127              COMMAN          equ     LWIDTH+$01      ; (1) Width for commas
  57+ 5127              NULFLG          equ     COMMAN+$01      ; (1) Null after input byte flag
  58+ 5127              CTLOFG          equ     NULFLG+$01      ; (1) Control "O" flag
  59+ 5127              CHKSUM          equ     CTLOFG+$01      ; (2) Array load/save check sum
  60+ 5127              NMIFLG          equ     CHKSUM+$02      ; (1) Flag for NMI break routine
  61+ 5127              BRKFLG          equ     NMIFLG+$01      ; (1) Break flag
  62+ 5127              RINPUT          equ     BRKFLG+$01      ; (3) Input reflection
  63+ 5127              STRSPC          equ     RINPUT+$03      ; (2) Pointer to bottom (start) of string space - default is 100 bytes below the top of memory
  64+ 5127              LINEAT          equ     STRSPC+$02      ; (2) Current line number. -1 means "direct mode", while -2 means cold start.
  65+ 5127              HLPLN           equ     LINEAT+$02      ; (2) Current line with errors
  66+ 5127              KEYDEL          equ     HLPLN+$02       ; (1) delay before key auto-repeat starts
  67+ 5127              AUTOKE          equ     KEYDEL+$01      ; (1) delay for key auto-repeat
  68+ 5127              FNKEYS          equ     AUTOKE+$01      ; (128) default text of FN keys
  69+ 5127              BASTXT          equ     FNKEYS+$80      ; (3) Pointer to start of BASIC program in memory
  70+ 5127              ; - - - - - - - - - - - - - - - - - - -   the above are locations pre-filled by the firmware at startup
  71+ 5127              BUFFER          equ     BASTXT+$03      ; (5) Input buffer
  72+ 5127              STACK           equ     BUFFER+$05      ; (85) Initial stack
  73+ 5127              CURPOS          equ     STACK+$55       ; (1) Character position on line
  74+ 5127              LCRFLG          equ     CURPOS+$01      ; (1) Locate/Create flag for DIM statement
  75+ 5127              TYPE            equ     LCRFLG+$01      ; (1) Data type flag: 0=numeric, non-zero=string
  76+ 5127              DATFLG          equ     TYPE+$01        ; (1) Literal statement flag
  77+ 5127              LSTRAM          equ     DATFLG+$01      ; (2) Last available RAM location usable by BASIC
  78+ 5127              TMSTPT          equ     LSTRAM+$02      ; (2) Temporary string pointer
  79+ 5127              TMSTPL          equ     TMSTPT+$02      ; (12) Temporary string pool
  80+ 5127              TMPSTR          equ     TMSTPL+$0C      ; (4) Temporary string
  81+ 5127              STRBOT          equ     TMPSTR+$04      ; (2) Bottom of string space
  82+ 5127              CUROPR          equ     STRBOT+$02      ; (2) Current operator in EVAL
  83+ 5127              LOOPST          equ     CUROPR+$02      ; (2) First statement of loop
  84+ 5127              DATLIN          equ     LOOPST+$02      ; (2) Line of current DATA item
  85+ 5127              FORFLG          equ     DATLIN+$02      ; (1) "FOR" loop flag
  86+ 5127              LSTBIN          equ     FORFLG+$01      ; (1) Last byte entered
  87+ 5127              READFG          equ     LSTBIN+$01      ; (1) Read/Input flag
  88+ 5127              BRKLIN          equ     READFG+$01      ; (2) Line of break
  89+ 5127              NXTOPR          equ     BRKLIN+$02      ; (2) Next operator in EVAL
  90+ 5127              ERRLIN          equ     NXTOPR+$02      ; (2) Line of error
  91+ 5127              CONTAD          equ     ERRLIN+$02      ; (2) Where to CONTinue
  92+ 5127              TMRCNT          equ     CONTAD+$02      ; (4) TMR counter for 1/100 seconds
  93+ 5127              CTC0IV          equ     TMRCNT+$04      ; (3) CTC0 interrupt vector
  94+ 5127              CTC1IV          equ     CTC0IV+$03      ; (3) CTC1 interrupt vector
  95+ 5127              CTC2IV          equ     CTC1IV+$03      ; (3) CTC2 interrupt vector
  96+ 5127              CTC3IV          equ     CTC2IV+$03      ; (3) CTC3 interrupt vector
  97+ 5127              ; - - - - - - - - - - - - - - - - - - -   VIDEO REGISTERS - FROM HERE...
  98+ 5127              SCR_SIZE_W      equ     CTC3IV+$03      ; (1) screen width (it can be either 40 chars or 32 chars/bytes)
  99+ 5127              SCR_SIZE_H      equ     SCR_SIZE_W+$01  ; (1) screen height (it can be 24/48/192: 24 for text, 48 for MC, 192 for graphics)
 100+ 5127              SCR_MODE        equ     SCR_SIZE_H+$01  ; (1) screen mode (0=text, 1=G1, 2=G2, 3=MC, 4=ExG2)
 101+ 5127              SCR_NAM_TB      equ     SCR_MODE+$01    ; (2) video name table address
 102+ 5127              SCR_CURS_X      equ     SCR_NAM_TB+$02  ; (1) cursor X
 103+ 5127              SCR_CURS_Y      equ     SCR_CURS_X+$01  ; (1) cursor Y
 104+ 5127              SCR_CUR_NX      equ     SCR_CURS_Y+$01  ; (1) new cursor X position
 105+ 5127              SCR_CUR_NY      equ     SCR_CUR_NX+$01  ; (1) new cursor Y position
 106+ 5127              SCR_ORG_CHR     equ     SCR_CUR_NY+$01  ; (1) original char positioned under the cursor
 107+ 5127              CRSR_STATE      equ     SCR_ORG_CHR+$01 ; (1) state of cursor (1=on, 0=off)
 108+ 5127              LSTCSRSTA       equ     CRSR_STATE+$01  ; (1) last cursor state
 109+ 5127              PRNTVIDEO       equ     LSTCSRSTA+$01   ; (1) print on video buffer (1=on / 0=off) set to off on graphic only modes
 110+ 5127              CHR4VID         equ     PRNTVIDEO+$01   ; (1) char for video buffer
 111+ 5127              FRGNDCLR        equ     CHR4VID+$01     ; (1) foreground color as set by SCREEN or COLOR commands
 112+ 5127              BKGNDCLR        equ     FRGNDCLR+$01    ; (1) background color as set by SCREEN or COLOR commands
 113+ 5127              TMPBFR1         equ     BKGNDCLR+$01    ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 114+ 5127              TMPBFR2         equ     TMPBFR1+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 115+ 5127              TMPBFR3         equ     TMPBFR2+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 116+ 5127              TMPBFR4         equ     TMPBFR3+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 117+ 5127              VIDEOBUFF       equ     TMPBFR4+$02     ; (40) buffer used for video scrolling and other purposes
 118+ 5127              VIDTMP1         equ     VIDEOBUFF+$28   ; (2) temporary video word
 119+ 5127              VIDTMP2         equ     VIDTMP1+$02     ; (2) temporary video word
 120+ 5127              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO VPD OUT OF THIS RANGE,
 121+ 5127                                                      ; OTHERWISE YOU WILL HAVE TO CHECK THE POINTER IN "CLR_RAM_REG" FUNCTION
 122+ 5127              ; - - - - - - - - - - - - - - - - - - -   SOUND & KEYBOARD REGISTERS - FROM HERE...
 123+ 5127              CHASNDDTN       equ     VIDTMP2+$02     ; (2) sound Ch.A duration (in 1/100s)
 124+ 5127              CHBSNDDTN       equ     CHASNDDTN+$02   ; (2) sound Ch.B duration (in 1/100s)
 125+ 5127              CHCSNDDTN       equ     CHBSNDDTN+$02   ; (2) sound Ch.C duration (in 1/100s)
 126+ 5127              KBDNPT          equ     CHCSNDDTN+$02   ; (1) temp cell used to flag if input comes from keyboard
 127+ 5127              KBTMP           equ     KBDNPT+$01      ; (1) temp cell used by keyboard scanner
 128+ 5127              TMPKEYBFR       equ     KBTMP+$01       ; (1) temp buffer for last key pressed
 129+ 5127              LASTKEYPRSD     equ     TMPKEYBFR+$01   ; (1) last key code pressed
 130+ 5127              STATUSKEY       equ     LASTKEYPRSD+$01 ; (1) status key, used for auto-repeat
 131+ 5127              KEYTMR          equ     STATUSKEY+$01   ; (2) timer used for auto-repeat key
 132+ 5127              CONTROLKEYS     equ     KEYTMR+$02      ; (1) flags for control keys (bit#0=SHIFT; bit#1=CTRL; bit#2=C=)
 133+ 5127              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO PSG OUT OF THIS RANGE,
 134+ 5127                                                      ; OTHERWISE YOU WILL HAVE TO CHANGE THE POINTER IN "initPSG" FUNCTION
 135+ 5127              SERIALS_EN      equ     CONTROLKEYS+$01 ; (1) serial ports status: bit 0 for Port1 (A), bit 1 for Port2 (B): 0=OFF, 1=ON
 136+ 5127              SERABITS        equ     SERIALS_EN+$01  ; (1) serial port A data bits
 137+ 5127              SERBBITS        equ     SERABITS+$01    ; (1) serial port B data bits
 138+ 5127              DOS_EN          equ     SERBBITS+$01    ; (1) DOS enable/disable (1/0)
 139+ 5127              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 140+ 5127                                                      ; from here there are the RAM locations that
 141+ 5127                                                      ; are saved during SAVE
 142+ 5127              PROGND          equ     DOS_EN+$01      ; (2) End of program
 143+ 5127              VAREND          equ     PROGND+$02      ; (2) End of variables
 144+ 5127              ARREND          equ     VAREND+$02      ; (2) End of arrays
 145+ 5127              NXTDAT          equ     ARREND+$02      ; (2) Next data item
 146+ 5127              FNRGNM          equ     NXTDAT+$02      ; (2) Name of FN argument
 147+ 5127              FNARG           equ     FNRGNM+$02      ; (4) FN argument value
 148+ 5127              FPREG           equ     FNARG+$04       ; (3) Floating point register
 149+ 5127              FPEXP           equ     FPREG+$03       ; (1) Floating point exponent
 150+ 5127              SGNRES          equ     FPEXP+$01       ; (1) Sign of result
 151+ 5127              PBUFF           equ     SGNRES+$01      ; (13) Number print buffer
 152+ 5127              MULVAL          equ     PBUFF+$0D       ; (3) Multiplier
 153+ 5127              PROGST          equ     MULVAL+$03      ; (100) Start of program text area
 154+ 5127              STLOOK          equ     PROGST+$64      ; Start of memory test
 155+ 5127
# file closed: ../include/workspace/workspace-r1.0.asm
  91  5127
  92  5127              ; END OF ASSEMBLY SOURCE
  93  5127              ;-------------------------------------------------------------------------------
  94  5127
# file closed: LM80C-firmware-r3.19.asm

Value    Label
------ - -----------------------------------------------------------
0x018F   A_RTS_OFF
0x01AD   A_RTS_ON
0x24AB   ABPASS
0x2EF3   ABS_
0x4029   absHL
0x1CC5 X ACCSUM
0x24AA   ACPASS
0x3F29   ADD30
0x3F39   ADD301
0x2E8C   ADDEXP
0x3032   ADDIG
0x0A48   ADDNEWLINE
0x2C28   ADDPHL
0x81DF   ADRS1
0x81E3   ADRS2
0x2779   ALLFOL
0x1FE6   ANTVLU
0x3383 X ARET
0x23B5   ARLDSV
0x8227   ARREND
0x2644   ARRLP
0x274A   ASC
0x2FD5   ASCTFP
0x1F3F   ASPCS
0x0691   ATHOME
0x3337   ATN
0x3354   ATN1
0x335E   ATNTAB
0x1D00   ATOH
0x80B4   AUTOKE
0x15DB   AUTORP
0x0197   B_RTS_OFF
0x01B5 X B_RTS_ON
0x083B   BACKSPACE
0x1F62   BADINP
0x1676   BAKSTK
0x272A   BAKTMP
0x805D   basicStarted
0x8135   BASTXT
0x2F1A   BCDEFP
0x05AB   BEEPOFF
0x12D1   BFREE
0x3F7B   BIN
0x3F81 X BIN2
0x3FD8   BINERR
0x3FB7   BINIT
0x3FAD   BINTFP
0x3F95   BITOUT
0x3F99   BITOUT2
0x3C87   BITS6
0x3C91   BITS7
0x3C9C   BITS8
0x81DC   BKGNDCLR
0x0008   BKSP
0x12C8   BLNSPC
0x0028   BN
0x119B   BNMSG
0x2C88   BNORM
0x1049 X BNPTR
0x2C8B   BNRMLP
0x81E6   BPS
0x1C73   BRK
0x80A9   BRKFLG
0x81B5   BRKLIN
0x1670   BRKMSG
0x12BC   BRKRET
0x0010   BS
0x23E8   BSERR
0x10CA   BSMSG
0x1031 X BSPTR
0x8138   BUFFER
0x0058   bufWrap
0x3F20   BYT2ASC
0x2DC0   BYTSFT
0x234B   CFEVAL
0x028B   CH3_TIMER
0x015D   CHABFREMPTY
0x076C   CHAR2VID
0x01FD   CHARINTOBFR
0x22F9   CHARTY
0x8211   CHASNDDTN
0x8213   CHBSNDDTN
0x0891   CHCKYPOS
0x08FC   CHCKYPOS2
0x8215   CHCSNDDTN
0x0D86   CHECKALT
0x0D94   CHECKCTRL
0x0DA2   CHECKKBD
0x36EB   CHECKPA
0x36EC   CHECKPY
0x0312   CHECKWARM
0x2542   CHEKFN
0x0E1D   CHKALT
0x0E66   CHKAUTO
0x3FCA   CHKBIN
0x350B   CHKCLR0
0x3507   CHKCLR1
0x029A   CHKCRSR
0x0E14   CHKCTRL
0x3ED2   CHKEY1
0x3ED7   CHKEY2
0x3EDA   CHKEY3
0x3EE0   CHKEY4
0x3EE3   CHKEY5
0x0E9E   CHKFNK
0x3511   CHKG2M
0x0817   CHKHL
0x2C07   CHKINK
0x0E00   CHKLN
0x1CD2   CHKLTR
0x344E   CHKSCAR
0x0D0B   CHKSNDCH
0x05D9 X CHKSPCK
0x16AA   CHKSTK
0x80A6   CHKSUM
0x19E7   CHKSYN
0x20C6   CHKTYP
0x08B8   CHKYPOS
0x3B4C   CHKZSER
0x275B   CHR
0x81DA   CHR4VID
0x81E7   CHRPNT
0x4067   CHRST68
0x4867   CHRST88
0x074E   CHRTBL
0x3917   CIRCLE
0x3C3A   CKBPS
0x35F8   CKCOL
0x0278   CKINCHAR
0x3401   CKMAGN
0x1D25   CLEAR
0x0684   CLEARVIDBUF
0x1A33   CLOTST
0x0AEF   CLR_RAM_REG
0x1849   CLREG
0x34C5   CLREX2
0x34B3   CLRG1
0x34BC   CLRG2
0x0624   CLRG2PTNTBL
0x34AC   CLRMC
0x3AFE   CLRPRM
0x0CA9   CLRPSGREGS
0x1824   CLRPTR
0x05D4   CLRTABLE
0x34A9   CLRTXT
0x3AE6   CLRVDBF
0x3386   CLS
0x3E77   CLSQT
0x3E87   CLSQT1
0x4004   CMP16
0x2BE0   CMP_A
0x2F63   CMPFP
0x225F   CMPLG1
0x225D   CMPLOG
0x2F49   CMPNUM
0x22A1   CMPRES
0x2289   CMPSTR
0x0020   CN
0x115B   CNMSG
0x1041 X CNPTR
0x2853   CNT1INS
0x0D46   CNTCHKSND
0x347B   CNTCKCL
0x39D9   CNTCL1
0x39FD   CNTCL2
0x3A21   CNTCL3
0x3A47   CNTCL4
0x3A69   CNTCL5
0x3A8D   CNTCL6
0x3AB1   CNTCL7
0x38BA   CNTDRW
0x1F07   CNTEND
0x0EF9   CNTFNK
0x3577   CNTGPT2
0x0E98   CNTKBCK
0x221E   CNTLGC
0x3E3D   CNTLTK
0x09FC   CNTNULL
0x0A7A X CNTNULL2
0x3769   CNTPLOT
0x378A   CNTPLT1
0x3BB9   CNTRX2
0x0120   CNTRXCHA
0x3B8A   CNTSER
0x3BC4   CNTSER2
0x3BD6   CNTSER3
0x3AE1   CNTVALY
0x1B70   CNTWTSP
0x288A   CNTZIN
0x2FE1   CNVNUM
0x1205   COLD
0x0307   COLDSTART
0x345E   COLOR
0x80A3   COMMAN
0x2CE8   COMPL
0x26BF   CONCAT
0x3011   CONEXP
0x2C85   CONPOS
0x1CAC   CONT
0x072F   CONT_POS_CURS
0x81BB   CONTAD
0x08A2   CONTCRSLFT
0x090F   CONTCRSRGT
0x821E   CONTROLKEYS
0x21B1   CONVAR
0x02FB   CORW
0x32BB   COS
0x0349   COUNTER
0x19E1   CPDEHL
0x3DD4   CPKEY
0x3DF3   CPKEY1
0x3DE4   CPKEY2
0x3DEB   CPKEY3
0x3DFB   CPKYEND
0x1926   CPYLIT
0x000D   CR
0x2408   CRARLP
0x23ED   CREARY
0x1E32   CRESTR
0x09CE   CRGRETURN
0x1887   CRNCLP
0x001F   CRSDN
0x001C   CRSLFT
0x81D7   CRSR_STATE
0x001D   CRSRGT
0x001E   CRSUP
0x257B   CRTMST
0x2587   CRTST
0x259D   CRTSTE
0x187E   CRUNCH
0x000C   CS
0x1212   CSTART
0x81C1   CTC0IV
0x81C4   CTC1IV
0x81C7   CTC2IV
0x81CA   CTC3IV
0x3D36   CTC_CFG
0x0010   CTC_CH0
0x0011   CTC_CH1
0x0012   CTC_CH2
0x0013   CTC_CH3
0x0388   CTCCONF
0x80A5   CTLOFG
0x372F   CTPOINT
0x0003   CTRLC
0x0007   CTRLG
0x000F   CTRLO
0x0011   CTRLQ
0x0012   CTRLR
0x0013   CTRLS
0x0015   CTRLU
0x2AB4   CTSNDC
0x81DD   CUR_POS
0x81AC   CUROPR
0x8192   CURPOS
0x094D   CURSOR_OFF
0x0938   CURSOR_ON
0x0918   CURSORDOWN
0x087E   CURSORLEFT
0x08E3   CURSORRIGHT
0x08CA   CURSORUP
0x1DD9   DATA
0x81E8   DATABT
0x8195   DATFLG
0x81B0   DATLIN
0x16E7   DATSNR
0x81EF   DC
0x2F9A   DCBCDE
0x0012   DD
0x16F6   DDERR
0x10D8   DDMSG
0x1033 X DDPTR
0x056B   DEC_D
0x0347   DEC_E
0x3DC6   DECLN1
0x33A2   DEEK
0x24BF   DEF
0x15DD X DEFFNKS
0x3C21   DEFSER
0x2410   DEFSIZ
0x1CE6   DEINT
0x007F   DEL
0x1956   DELCHR
0x1CE0   DEPINT
0x2F29   DETHL4
0x2F2B   DETHLB
0x30DB   DIGTXT
0x22CB   DIM
0x22C2   DIMRET
0x1A16   DINPOS
0x2DC5   DINT
0x33CD X DIR_PAU
0x3D52   DIRMOD
0x2962   DISNMI
0x2E22   DIV
0x806B   DIV1
0x2E16   DIV10
0x806F   DIV2
0x8073   DIV3
0x8076   DIV4
0x4052 X DIV_16_16
0x4043   DIV_16_8
0x4046   DIV_16_8LP
0x4033   DIV_8_8
0x4037   DIV_8_8LOOP
0x2E49   DIVLP
0x806A   DIVSUP
0x399B   DLSZ
0x1862   DOAGN
0x1F0C   DOCOM
0x1936   DODEL
0x311B   DOEBIT
0x24EC   DOFN
0x33AD   DOKE
0x8222   DOS_EN
0x1F3A   DOSPC
0x1F25   DOTAB
0x300D   DPOINT
0x37E1   DRAW
0x39B7   DRWCRL
0x258B   DTSTR
0x4057   DV16_16_LP
0x2E24   DVBCDE
0x81F1   DX
0x38EA   DXGR
0x81F3   DY
0x0014   DZ
0x16F0   DZERR
0x10ED   DZMSG
0x1035 X DZPTR
0x81EB   E2
0x194A   ECHDEL
0x031F   ECHO_CHAR
0x3054   EDIGIT
0x27F2   EMPTINS
0x0CA5   EMPTSNDBFR
0x0AE6   EMPTVRM
0x0ADB   EMPTY_VRAM
0x014F   EMPTYCHABFR
0x0181   EMPTYCHBBFR
0x0612   EMPTYG2
0x0643   EMPTYMC
0x05E9   EMPTYVIDBUF
0x3D0B   ENCHB
0x192D   ENDBUF
0x3020   ENDCON
0x39B3   ENDCRL
0x0DE8   ENDCTRLCK
0x246F   ENDDIM
0x3913   ENDDRAW
0x2C19   ENDINK
0x2C22 X ENDINK2
0x1EF3   ENDINP
0x082D X ENDINSRT
0x22ED   ENDNAM
0x0A55   ENDOFLN
0x1C82   ENDPRG
0x2484   ENDTMR
0x81E1   ENDTXT
0x0505   ENDVDPSET
0x16B3   ENFMEM
0x81E9   ER
0x388E   ER2
0x3EE9   ERASE
0x0587   ERASECLRTBL
0x1725   ERRIN
0x1CA6   ERRINT
0x81B9   ERRLIN
0x165F   ERRMSG
0x1701   ERROR
0x1055 X ERRORS
0x1021   ERRTBL
0x001B   ESC
0x20D3   EVAL
0x20D6   EVAL1
0x20DF   EVAL2
0x20E2   EVAL3
0x2198   EVLPAR
0x22AB   EVNOT
0x1C10   EXCUTE
0x04C2   EXG2MD
0x07C8   EXITCHAR2VID
0x094B   EXITCURSOR_ON
0x0935   EXITCURSORDOWN
0x08A5   EXITCURSORLEFT
0x0915   EXITCURSORRGHT
0x08E1   EXITCURSORUP
0x16C7   EXITGM
0x36E7   EXITPA2
0x36E3   EXITPAI
0x4027   EXMUL16
0x3D19   EXNRM
0x31B5   EXP
0x2FFF   EXPLP
0x31F5   EXPTAB
0x312D   EXPTEN
0x2042   EXTIG
0x206B   FANDT
0x0008   FC
0x1CFB   FCERR
0x108E   FCMSG
0x1029 X FCPTR
0x2052   FDTLP
0x3EE8   FILES
0x244B   FINDEL
0x0DFE   FINDKEY
0x07D6   FLASHCURSOR
0x2ED9   FLGDIF
0x2EE0   FLGREL
0x00EC   FMVEREND
0x822D   FNARG
0x132B   FNCTAB
0x23BB   FNDARY
0x2450   FNDELP
0x17F7   FNDEND
0x2944   FNDNUM
0x1B24   FNDTOK
0x2332   FNDVAR
0x18B1   FNDWRD
0x80B5   FNKEYS
0x0F19   FNKEYSORD
0x21C2   FNOFST
0x822B   FNRGNM
0x2340   FNTHR
0x21F3   FNVAL
0x210B   FOPRND
0x1B77   FOR
0x81B2   FORFLG
0x1BA7   FORFND
0x1B8B   FORSLP
0x2C37   FPADD
0x2F0F   FPBCDE
0x8234   FPEXP
0x2F76   FPINT
0x2D72   FPMULT
0x8231   FPREG
0x2CCF   FPROND
0x1CDA   FPSINT
0x2F26   FPTHL
0x2489   FRE
0x24A5   FRENUM
0x81DB   FRGNDCLR
0x21B4   FRMEVL
0x00D0 X FWVER
0x043C   G1MD
0x047D   G2MD
0x260C   GARBGE
0x260F   GARBLP
0x1C30   GETCHR
0x1754   GETCMD
0x3F56   GETHEX
0x3384   GETINP
0x2947   GETINT
0x273F   GETLEN
0x1967   GETLIN
0x1D01   GETLN
0x20C1   GETNUM
0x18CC   GETNXT
0x2709   GETSTR
0x22D0   GETVAR
0x002A   GM
0x3B17   GMERR
0x11A6   GMMSG
0x19BE   GMNCR
0x104B X GMPRT
0x2643   GNXARY
0x21FB   GOFUNC
0x1D85   GOSUB
0x1D96   GOTO
0x35DB   GPCPCH1
0x35D0 X GPCPCHR
0x358C   GPNT
0x35B6   GPNTCO1
0x35AC X GPNTCOL
0x351A   GPRINT
0x2663   GRBARY
0x25E4   GRBDON
0x261D   GRBLP
0x270C   GSTRCU
0x2710   GSTRDE
0x270F   GSTRHL
0x274E X GTFLNM
0x22D5   GTFNAM
0x1D04   GTLNLP
0x30A5   GTSIXD
0x1FBE   GTVLUS
0x81E1   GX
0x81E3   GY
0x314C   HALF
0x3305   HALFPI
0x0339   HELLOWRLD
0x3D5E   HELP
0x3EEA   HEX
0x3F02   HEX1
0x3F04   HEX2
0x3F11   HEX3
0x3F13   HEX4
0x3F6D   HEXIT
0x3F49   HEXLP
0x3F4E   HEXLP1
0x3F3D   HEXTFP
0x073D   HL2XY
0x3D74   HLPERR
0x80B1   HLPLN
0x0019   HOME
0x0032   HP
0x11FB   HPMSG
0x1053 X HPPTR
0x0026 X HX
0x3F76   HXERR
0x1190   HXMSG
0x1047 X HXPTR
0x0016   ID
0x10FE   IDMSG
0x1037 X IDPTR
0x2534   IDTEST
0x1E68   IF
0x1E7F   IF0
0x1E88   IF1
0x1E76   IFGO
0x1C17   IFJMP
0x2F24   INCHL
0x1A12   INCLEN
0x0294   INCTMR3
0x1690   INDFND
0x17BF   INEWLN
0x1219   INIT
0x02AE   INIT_HW
0x02B1 X INIT_HW2
0x1586   INITAB
0x165F   INITBE
0x035E   initCTC
0x0C9F   initPSG
0x3FEF   INITST
0x03ED   initVDP
0x2BD5   INKEY
0x2BEF   INKEY2
0x1666   INMSG
0x2904   INP
0x2010   INPBIN
0x1C7F   INPBRK
0x80A0   INPORT
0x809F   INPSUB
0x1F73   INPUT
0x30AE   INRNG
0x07F9   INSERTKEY
0x001A   INSRT
0x279B   INSTR
0x2FA1   INT
0x1833   INTVAR
0x2EF7   INVSGN
0x2001   ITMSEP
0x3137   JSTZER
0x8217   KBDNPT
0x0F21   KBMAP
0x0FA1   KBMAP_ALT
0x0FE1   KBMAP_CTRL
0x0F61   KBMAP_SFT
0x8218   KBTMP
0x3D79   KEY
0x0D66   KEYBOARD
0x3D96   KEYCH
0x80B3   KEYDEL
0x821C   KEYTMR
0x20B1   KILFOR
0x1961   KILIN
0x821A   LASTKEYPRSD
0x8193   LCRFLG
0x04FC   LDCLRTBEX2
0x0474   LDCLRTBMD1
0x0603   LDCOLSTOEMPTY
0x0EE5   LDFNKEYCHR
0x16D4   LDG1
0x16E5   LDG1ND
0x3E28   LDKEY
0x0B0C   LDREGVLS
0x0343   LEDLIGHT
0x276B   LEFT
0x273B   LEN
0x1DF0   LET
0x1E43   LETNUM
0x1E0B   LETSTR
0x000A   LF
0x28FA   LFRGNM
0x80AF   LINEAT
0x3060   LINEIN
0x17A8   LINFND
0x1A4E   LIST
0x1AE1   LISTLP
0x0B5F   LM80CLOGO
0x81DD   LNS1
0x81E1   LNS2
0x3EE6   LOAD
0x071A   LOAD_CRSR_POS
0x0B16   LOADCHARSET
0x34CC   LOADCLR
0x2F1D   LOADFP
0x05B3   LOADLOGOCHRS
0x0E24   LOADMAP
0x097E   LOADNEXTCOL
0x2A1A   LOCATE
0x2D31   LOG
0x5067   LOGOFONT
0x2D24   LOGTAB
0x167A   LOKFOR
0x81AE   LOOPST
0x001C   LS
0x1130   LSMSG
0x103D X LSPTR
0x1A7A   LST01
0x1A7D   LST01H
0x1AD8   LST02
0x1AC1   LST03
0x1AD5   LST05
0x1A98   LST06
0x1B06   LST07
0x1B03   LST08
0x1AA9   LSTALL
0x81B3   LSTBIN
0x81D8   LSTCSRSTA
0x3DFD   LSTKEYS
0x1B12   LSTLP2
0x1B15   LSTLP3
0x1A9C   LSTNOT
0x8196   LSTRAM
0x809B   LSTRND
0x201B   LTSTND
0x0875   LVBKSP
0x05E7   LVCKSPLK
0x2880   LVINSTR
0x0ECC X LVKBRDCHK
0x0EC8   LVKBRDCHK2
0x0131   LVRXCHA
0x1B5C   LVSRLN
0x80A2   LWIDTH
0x294A   MAKINT
0x30CA   MAKNUM
0x2FE9   MANLP
0x18FE   MATCH
0x049F   MCMD
0x1320   MEMMSG
0x289B   MID
0x2771   MID1
0x28FF   MIDNUM
0x2C77   MINCDE
0x21A0   MINUS
0x34FA   MIXCLRS
0x81DD   MIXCOL
0x2578   MKTMST
0x2FC2   MLDBLP
0x2FBA   MLDEBC
0x124A   MLOOP
0x4017   MLP
0x401E   MLP1
0x2EB7   MLSP10
0x0D01   MNGSNDS
0x1247   MNOASK
0x3668   MNPAINT
0x0024   MO
0x2DCD   MOD
0x1180   MOMSG
0x3FDD   MONOUT
0x1045 X MOPTR
0x2027   MORDT
0x1970   MORINP
0x17DE   MOVBUF
0x06E1   MOVCRS
0x1906   MOVDIR
0x169F   MOVLP
0x06E7   MOVSHOWCRS
0x169C   MOVSTR
0x1699   MOVUP
0x1E96   MRPRNT
0x0394   MSGTXT1
0x03D0   MSGTXT2
0x1234   MSIZE
0x400F   MUL16
0x2D9D   MUL8LP
0x2D69   MULLN2
0x2D70   MULT
0x2D94   MULT8
0x302B   MULTEN
0x8243   MULVAL
0x0862   MVBKSP
0x08A7   MVCRS2LFT
0x1E3A   MVSTPT
0x1FBA   NEDMOR
0x3162   NEGAFT
0x402C   negHL
0x1823   NEW
0x06FC   NEWCRSRCOORD
0x0E78   NEWKEY
0x1F49   NEXITM
0x2076   NEXT
0x2079   NEXT1
0x0000   NF
0x16F3   NFERR
0x1055   NFMSG
0x1021 X NFPTR
0x0000   NLLCR
0x2973   NM1
0x2958   NMI
0x2984   NMI2
0x298F   NMIDINT
0x2988   NMIEINT
0x80A8   NMIFLG
0x2992   NMIINT
0x8061   NMIUSR
0x299E   NMIVR1
0x0CD3   NOBEEP
0x0CEF   NOBPDAT
0x18F6   NOCHNG
0x1285   NODOS
0x313A   NOENED
0x37AA   NOGD
0x2B38   NOISUP
0x0DEC   NOKEYPRSD
0x1C95   NOLIN
0x2DAE   NOMADD
0x2FD0   NOMLAD
0x1F8D   NOPMPT
0x2CA2   NORMAL
0x2B62   NOS1
0x2B75   NOS2
0x2B8E   NOS3
0x18ED   NOSPC
0x3F69   NOSUB7
0x2C51   NOSWAP
0x29D0   NOSYSPR
0x2175   NOTAMP
0x0208   NOTFULL
0x023F   NOTRDWRAP
0x2308   NOTSTR
0x0214   NOTWRAP
0x292A   NOXOR
0x2318   NSCFOR
0x80A4   NULFLG
0x3073   NUMASC
0x81E9   NUMCHR
0x23CF   NXTARY
0x18DC   NXTBYT
0x0B2B   NXTCHAR
0x191D   NXTCHR
0x078C   NXTCPCK
0x8229   NXTDAT
0x1DD8   NXTDTA
0x0828   NXTINST
0x1FB2   NXTITM
0x1B3C   NXTLN
0x3649   NXTLOOP
0x81B7   NXTOPR
0x1DDF   NXTSTL
0x1DE2   NXTSTT
0x0006   OD
0x1082   ODMSG
0x1027 X ODPTR
0x166B   OKMSG
0x000C   OM
0x16C2   OMERR
0x10AD   OMMSG
0x102D X OMPTR
0x1E4A   ON
0x1E59   ONGO
0x1E5A   ONGOLP
0x1C18   ONJMP
0x20CF   OPNPAR
0x3E89   OPNQT
0x3E9F   OPNQT1
0x214A   OPRND
0x81E9   ORGSP
0x001A   OS
0x111C   OSMSG
0x103B X OSPTR
0x195E   OTKLN
0x8068   OTPORT
0x19F2   OUTC
0x312B   OUTEXP
0x19D8   OUTIT
0x19DB   OUTNBS
0x3FFE   OUTNCR
0x8067   OUTSUB
0x1B2E   OUTWRD
0x000A   OV
0x16FC   OVERR
0x10A4   OVMSG
0x102B X OVPTR
0x2EAA   OVTST1
0x2EAF   OVTST2
0x2EB0   OVTST3
0x304F   PADD
0x360B   PAINT
0x3656   PAINT0
0x3665   PAINT1
0x3664   PAINT11
0x3698   PAINT2
0x36AB   PAINT3
0x36CA   PAINT4
0x36DC   PAINT5
0x2214   PAND
0x2239 X PAND1
0x81E9   PARBT
0x24BA   PASSA
0x33C4   PAUSE
0x8236   PBUFF
0x29E0   PEEK
0x1C7A   PEND
0x2F0C   PHLTFP
0x0002 X PIO_CA
0x0003   PIO_CB
0x0000 X PIO_DA
0x0001   PIO_DB
0x29F4   PKEPRMS
0x07D5   PLACEHOLDER
0x374E   PLOT
0x39AA   PLTCRL
0x2CDC   PLUCDE
0x2CAA   PNORM
0x81E5   PNT
0x0EC5   PNT2VD
0x3725   PNTEND
0x3743   PNTRTN
0x36FB   POINT
0x2A0A   POKE
0x25FE   POPAF
0x2728   POPHL
0x2DBE   POPHRT
0x1746   POPNOK
0x2217   POR
0x223E   POR1
0x24B7   POS
0x06D7   POS_CURSOR
0x0A7B   POS_TB_CRS_32
0x0AAB   POS_TB_CRS_40
0x1CDD X POSINT
0x2910   POUT
0x3170   POWER
0x3180   POWER1
0x319D   POWER2
0x3150   POWERS
0x1E9A   PRINT
0x1568   PRITAB
0x1EFD   PRNTCRLF
0x0F0C   PRNTFNK
0x0ECD   PRNTFNKEY
0x3068   PRNTHL
0x1E9D   PRNTLP
0x1EE0   PRNTNB
0x1747   PRNTOK
0x0A34   PRNTRETURN
0x1EE4   PRNTST
0x81D9   PRNTVIDEO
0x25C8   PRNUMS
0x1989   PROCES
0x8223   PROGND
0x8246   PROGST
0x1866   PROMPT
0x25C9   PRS
0x25CC   PRS1
0x25D3   PRSLP
0x3E52   PRTCHR
0x3EA1   PRTCKEY
0x3EAE   PRTEND
0x3EA2   PRTK1
0x3E11 X PRTK2
0x3E3A   PRTK3
0x3E0F   PRTK4
0x81E5   PRTNUM
0x0041   PSG_DAT
0x0040   PSG_REG
0x2C32   PSUB
0x81E5   PT
0x81E7   PT1
0x81E9   PT2
0x3E6F   PTCHR1
0x1742   PTLN
0x17EB   PTRLP
0x19C4   PUTBUF
0x0EB8   PUTCHRBUF
0x0EFF   PUTCHRBUF1
0x07F5   PUTCRSCHR
0x19C9   PUTCTL
0x1BEC   PUTFID
0x37AE   PXLSET
0x221C   PXOR
0x2246   PXOR1
0x258E   QTSTLP
0x2588   QTSTR
0x3309   QUARTR
0x81E9   RADIUS
0x027D   RAWPRINT
0x1FAD   READ
0x069B   READ_VIDEO_LOC
0x06D0   READ_VSTAT
0x81B4   READFG
0x0D51   READKBLN
0x33A7 X RECWRD
0x1F50   REDO
0x1DDB   REM
0x2E5C   RESDIV
0x32A7   RESEED
0x3FE0   RESET
0x3D86   RESFN
0x0383   RESTMR
0x1C55   RESTNL
0x1C40   RESTOR
0x2C9D   RESZER
0x237F   RETADR
0x2EE5   RETINT
0x1DD3   RETLIN
0x1902   RETNAD
0x2382   RETNUL
0x21AC   RETNUM
0x2ED7   RETREL
0x1DB4   RETURN
0x0004   RG
0x106D   RGMSG
0x1025 X RGPTR
0x2891   RIGHT
0x276F   RIGHT1
0x80AA   RINPUT
0x20EF   RLTLP
0x3246   RND
0x3282   RND1
0x329E   RND2
0x32AF   RNDTAB
0x313D   RNGTST
0x2CBE   RONDB
0x2CBD   RONDUP
0x2C25   ROUND
0x282A   RP2INST
0x35A1   RPGPNT
0x0595   RPT100
0x0539   RPT101
0x053C   RPT102
0x0552   RPT103
0x055A   RPT104
0x396E   RPTCL1
0x077F   RPTCPCK
0x395B   RPTCRL
0x3AEE   RPTCVB1
0x3AF7   RPTCVB2
0x389E   RPTDRW
0x0609   RPTEMPTYBUF
0x09C2   RPTEMPTYROW
0x0671   RPTFLL1
0x2803   RPTINST
0x0DA6   RPTKBDRD
0x34D6   RPTLDCL
0x09EC   RPTNLLSRC
0x0A6D   RPTNLLSRC2
0x33D2   RPTPS
0x3B5D   RPTRSSR
0x0CD9   RPTWLCMBP
0x2A8F   RPVOLCG
0x3049   RSCALE
0x0000 X RST00
0x0008 X RST08
0x0010 X RST10
0x0018 X RST18
0x0711   RSTCHRCRS
0x0CB0   RSTPSG
0x3B50   RSTSERS
0x28B4   RSTSTR
0x0AF5   RSTVDPRAMREG
0x1D71   RUN
0x1BF0   RUNCNT
0x182F   RUNFST
0x1D95   RUNLIN
0x0100   RX_CHA_AVAIL
0x0165   RX_CHB_AVAIL
0x022A   RXA
0x0255   RXA_EXIT
0x3BC0   RXEND
0x2875   RZINSTR
0x002E   SA
0x11CC   SAMSG
0x104F X SAPTR
0x3EE7   SAVE
0x2C9E   SAVEXP
0x1BE3   SAVSTP
0x2563   SAVSTR
0x238D   SBSCPT
0x002C   SC
0x2CFC   SCALE
0x2CFE   SCALLP
0x3014   SCALMI
0x302A   SCALPL
0x3D45   SCERR
0x3D41   SCERR1
0x11B7   SCMSG
0x269A   SCNEND
0x2393   SCPTLP
0x104D X SCPTR
0x81D4   SCR_CUR_NX
0x81D5   SCR_CUR_NY
0x81D2   SCR_CURS_X
0x81D3   SCR_CURS_Y
0x81CF   SCR_MODE
0x81D0   SCR_NAM_TB
0x81D6   SCR_ORG_CHR
0x81CE   SCR_SIZE_H
0x81CD   SCR_SIZE_W
0x33E3   SCREEN
0x096C   SCROLLNXTRW
0x0954   SCROLLUP
0x340F   SCVDP
0x18CA   SEARCH
0x8078   SEED
0x0B2D   SENDCHRPTRNS
0x0E85   SENDKEY
0x0CD6   SENDSND
0x0058   SER_BUFSIZE
0x0005   SER_EMPTYSIZE
0x0050   SER_FULLSIZE
0x8220   SERABITS
0x8221   SERBBITS
0x8000   SERBUF_START
0x805C   serBufUsed
0x3B1C   SERIAL
0x821F   SERIALS_EN
0x8058   serInPtr
0x3B86   SERLED
0x805A   serRdPtr
0x3B3D   SERVAR
0x3C64   SET_CTC
0x0AFA   SET_GFX_MODE
0x0B02   SET_GFX_MODE2
0x3C53   SET_PT
0x059F   SETBEEP
0x34E1   SETBRCL
0x07B5   SETCRSRY
0x07B6   SETCSRCOORDS
0x2934   SETIO
0x1914   SETLIT
0x0668   SETNAMETABLE
0x0E56   SETNEWAUTO
0x3CA0   SETPAR
0x3CAB   SETPAR2
0x17E6   SETPTR
0x3EB0   SETREP
0x3C2E   SETSER
0x0CF7   SETSNDREG
0x126E   SETTOP
0x33F6 X SETVDP
0x067B   SETVDPADRS
0x17B0   SFTPRG
0x2EDD   SGN
0x2204   SGNEXP
0x8235   SGNRES
0x0510   SHOW_LOGO
0x2D0B   SHRITE
0x2D0E   SHRLP
0x2D12   SHRT1
0x12DF   SIGNON
0x2F34   SIGNS
0x32C1   SIN
0x32F1   SIN1
0x330D   SINTAB
0x01CB   SIO_A_DI
0x01E3   SIO_A_EI
0x0354   SIO_A_SETS
0x01D3   SIO_B_DI
0x01EB   SIO_B_EI
0x035A X SIO_B_SETS
0x0022   SIO_CA
0x0023   SIO_CB
0x0020   SIO_DA
0x0021   SIO_DB
0x019D   SIO_RTS_OFF
0x01BB   SIO_RTS_ON
0x01D9   SIO_RXDI
0x01F1   SIO_RXEN
0x81EB   SIOBFR
0x3090   SIXDIG
0x262E   SMPVAR
0x3225   SMSER1
0x0002   SN
0x2AFD   SND1
0x1A25   SND2VID
0x0A15   SNDCHRTOBFR
0x065E   SNDCLRSET
0x0EA6   SNDKEYTOBFR
0x05CA   SNDLOGPT
0x2B32   SNDOVR
0x0CBD   SNDREGCFG
0x16ED   SNERR
0x1066   SNMSG
0x1023 X SNPTR
0x0030   SO
0x3D4A   SOERR
0x11E5   SOMSG
0x1051 X SOPTR
0x2AA6   SOUND
0x81E7 X SPA
0x81E8 X SPB
0x0020   SPC
0x3081   SPCFST
0x1F41   SPCLP
0x0136   SPEC_RXA_CNDT
0x0168   SPEC_RXB_CNDT
0x3167   SQR
0x1B4A   SRCHLIN
0x1803   SRCHLN
0x1806   SRCHLP
0x1B50   SRCLN
0x1B51   SRCLN1
0x2A4C   SREG
0x3CE0   SRLCNT
0x3B80   SRPT2
0x2C03   SRTINK
0x81DF   SRTTXT
0x2BC1   SSTAT
0x26F6   SSTSA
0x001E   ST
0x813D   STACK
0x2EFF   STAKFP
0x1C69   STALL
0x120B   STARTB
0x065A   STARTEMPTY
0x821B   STATUSKEY
0x2133   STKTHS
0x82AA   STLOOK
0x1140   STMSG
0x1C78   STOP
0x1D4E   STORED
0x81EA   STPBT
0x2671   STPOOL
0x103F X STPTR
0x2553   STR
0x2559   STR1
0x2674   STRADD
0x81AA   STRBOT
0x389B   STRE2
0x2004   STRENT
0x3CC8   STRPAR
0x80AD   STRSPC
0x1EEB   STTLIN
0x2C34   SUBCDE
0x2C2E   SUBPHL
0x322E   SUMLP
0x3216   SUMSER
0x3D20   SUP_BPS
0x310F   SUPTLZ
0x22EC   SVNAM2
0x2581   SVSTAD
0x81ED   SX
0x81EF   SY
0x29B2   SYS
0x29DE   SYSRET
0x3322   TAN
0x818F   TEMPSTACK
0x0DD5   TESTALT
0x0DE2   TESTCTRL
0x2600   TESTOS
0x25E2   TESTR
0x81ED   TF
0x0018   TM
0x16FF   TMERR
0x110D   TMMSG
0x81E5   TMPADR
0x81DD   TMPBFR1
0x81DF   TMPBFR2
0x81E1   TMPBFR3
0x81E3   TMPBFR4
0x81DF   TMPCLR
0x81EB   TMPHL
0x8219   TMPKEYBFR
0x81A6   TMPSTR
0x1039 X TMPTR
0x2473   TMR
0x81BD   TMRCNT
0x819A   TMSTPL
0x8198   TMSTPT
0x2767   TOPOOL
0x26FF   TOSTRA
0x81EB   TP
0x30EA   TRYAGN
0x2700   TSALP
0x3FF7 X TSTBIT
0x1C5B   TSTBRK
0x125C   TSTMEM
0x20C4   TSTNUM
0x25A9   TSTOPL
0x224B   TSTRED
0x1917   TSTREM
0x2ECE   TSTSGN
0x1B5E   TSTSPC
0x20C5   TSTSTR
0x1967   TTYLIN
0x026C   TX_EMP
0x0259   TXA
0x0269   TXA_EXIT
0x0412 X TXTMD
0x8194   TYPE
0x0022   UF
0x16F9   UFERR
0x116A   UFMSG
0x1043 X UFPTR
0x000E   UL
0x1DAF   ULERR
0x10BB   ULMSG
0x102F X ULPTR
0x2D20   UNITY
0x1C56   UPDATA
0x8064   USR
0x28CB   VAL
0x28E9   VAL1
0x28F3   VAL2
0x28F6   VAL3
0x3AD6   VALIDX
0x3ADB   VALIDY
0x8225   VAREND
0x0030   VDP_DAT
0x0032   VDP_SET
0x0B37   VDPMODESET
0x0B3F X VDPMODESET1
0x0B47 X VDPMODESET2
0x0B57 X VDPMODESETEX2
0x0B4F X VDPMODESETMC
0x81E5   VIDEOBUFF
0x820D   VIDTMP1
0x820F   VIDTMP2
0x2A9B   VOLCH
0x2A6D   VOLUME
0x29E7   VPEEK
0x2A0F   VPOKE
0x2B9A   VREG
0x2BB6   VSTAT
0x2916   WAIT
0x292B   WAITLP
0x1208   WARM
0x12B9   WARMST
0x339A   WIDTH
0x0CE7   WLCBPDAT
0x0CCD   WLCMBEEP
0x136F   WORDS
0x14FC   WORDTB
0x06B0   WRITE_VIDEO_LOC
0x06C5   WRITE_VREG
0x09A7   WRITEBUF
0x805E   WRKSPC
0x2B85   WRTSND
0x0CFC   WRTSNDREG
0x1B64   WTSPC
0x81DD   X1
0x3841   X1GR
0x81E5   X2
0x81E5   XC
0x81EB   XI
0x37B6   XY2HL
0x81DF   Y1
0x386B   Y1GR
0x81E7   Y2
0x81E7   YC
0x81ED   YI
0x0083   ZDATA
0x00C2 X ZDINT
0x00C0 X ZDIV
0x00AE   ZELSE
0x0080   ZEND
0x00C8   ZEQUAL
0x242E   ZERARY
0x166A   ZERBYT
0x2371   ZEROLP
0x3F87   ZEROSUP
0x00B8   ZFN
0x0081   ZFOR
0x008C   ZGOSUB
0x0088   ZGOTO
0x00C7   ZGTR
0x00E1   ZINSTR
0x00E9   ZLEFT
0x00C9   ZLTH
0x00BE   ZMINUS
0x00C1 X ZMOD
0x00B5   ZNEW
0x00BB   ZNOT
0x1F1A   ZONELP
0x00C6   ZOR
0x00BD   ZPLUS
0x00E0   ZPOINT
0x00AF   ZPRINT
0x008E   ZREM
0x00CA   ZSGN
0x00B9   ZSPC
0x00BC   ZSTEP
0x00B6   ZTAB
0x00BA   ZTHEN
0x00BF X ZTIMES
0x00B7   ZTO
