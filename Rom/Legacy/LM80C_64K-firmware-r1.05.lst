# file opened: LM80C_64K-firmware-r1.05.asm
   1  0000              ; ------------------------------------------------------------------------------
   2  0000              ; LM80C 64K - FIRMWARE - R1.05
   3  0000              ; ------------------------------------------------------------------------------
   4  0000              ; The following code is intended to be used with LM80C Z80-based computer
   5  0000              ; designed by Leonardo Miliani. More info at
   6  0000              ; www DOT leonardomiliani DOT com
   7  0000              ; ------------------------------------------------------------------------------
   8  0000              ; Coding/Editing/Compiling:
   9  0000              ; Original init code for MC68B05 by Grant Searle
  10  0000              ; Original SIO/CTC/PIO init code by Mario Blunk
  11  0000              ; NASCOM BASIC originally modified by Gran Searle
  12  0000              ; Code modified and adapted for LM80C by Leonardo Miliani
  13  0000              ;
  14  0000              ; Edited with Visual Studio Code
  15  0000              ;
  16  0000              ; Compiled with SjASMPlus assembler 1.18.0
  17  0000              ; https://github.com/z00m128/sjasmplus
  18  0000              ; ------------------------------------------------------------------------------
  19  0000              ; Copyright notes:
  20  0000              ; Parts of the code (c) Grant Searle - free for non commercial use
  21  0000              ; Please include this advice and the note to the attribution of the original
  22  0000              ; version to Grant Searle if you intend to redistribuite it
  23  0000              ; http://searle.hostei.com/grant/index.html
  24  0000              ; eMail: home.micros01@btinternet.com
  25  0000              ;
  26  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  27  0000              ; Parts of the code (c) Mario Blunk
  28  0000              ; http://www.trainÂ­z.de
  29  0000              ;
  30  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  31  0000              ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  32  0000              ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  33  0000              ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  34  0000              ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  35  0000              ; the original ROM code (checksum A934H). PA
  36  0000              ;
  37  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  38  0000              ; The following code is intended to be used with LM80C Z80-based computer
  39  0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
  40  0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
  41  0000              ; kind of warranty: you can use them at your own risk.
  42  0000              ; You are free to use them for any non-commercial use: you are only asked to
  43  0000              ; maintain the copyright notices, include this advice and the note to the
  44  0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  45  0000              ; redistribuite them.
  46  0000              ; https://www.leonardomiliani.com
  47  0000              ;
  48  0000              ; Please support me by visiting the following links:
  49  0000              ; Main project page: https://www.leonardomiliani.com
  50  0000              ; Schematics and code: https://github.com/leomil72/LM80C
  51  0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  52  0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  53  0000              ; ------------------------------------------------------------------------------
  54  0000              ; set name for binary output file
  55  0000                  OUTPUT "LM80C-64K-firmware-r1.05.bin"
  56  0000
  57  0000              ; set computer model
  58  0000                  DEFINE LM80C64K
  59  0000
  60  0000              ; set firmware version
  61  0000                  DEFINE VERSION "1.05"
  62  0000
  63  0000              ; define shorter VDP_DAT load instruction and additional delay for VDP access
  64  0000                  DEFINE LD_VDP_DAT dec     C
  65  0000                  DEFINE LM64K_NOP nop
  66  0000
  67  0000              ; ------------------------------------------------------------------------------
  68  0000              ; include the latest version of the bootloader: this sets up the address aliases,
  69  0000              ; configure the hardware, checks if warm or cold startup and loads the BASIC interpreter
  70  0000                  INCLUDE "../include/bootloader/bootloader-1.06.asm"
# file opened: ../include/bootloader/bootloader-1.06.asm
   1+ 0000              ; ------------------------------------------------------------------------------
   2+ 0000              ; LM80C - BOOTLOADER - 1.06
   3+ 0000              ; ------------------------------------------------------------------------------
   4+ 0000              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0000              ; kind of warranty: you can use them at your own risk.
   8+ 0000              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0000              ; maintain the copyright notices, include this advice and the note to the
  10+ 0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0000              ; redistribuite them.
  12+ 0000              ; https://www.leonardomiliani.com
  13+ 0000              ;
  14+ 0000              ; Please support me by visiting the following links:
  15+ 0000              ; Main project page: https://www.leonardomiliani.com
  16+ 0000              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0000              ; ------------------------------------------------------------------------------
  20+ 0000
  21+ 0000              ; ADDRESS DECODING (bits A6/A5/A4)
  22+ 0000              ; 0000xxxx : PIO
  23+ 0000              ; 0001xxxx : CTC
  24+ 0000              ; 0010xxxx : SIO
  25+ 0000              ; 0011xxxx : VDP
  26+ 0000              ; 0100xxxx : PSG
  27+ 0000              ; 0101xxxx : C.F.
  28+ 0000
  29+ 0000
  30+ 0000              ; ------------------------------------------------------------------------------
  31+ 0000              ;               EQUATES
  32+ 0000              ; ------------------------------------------------------------------------------
  33+ 0000              ; label defining for PIO (Parallel Input/Output)
  34+ 0000              PIO_DA          equ %00000000
  35+ 0000              PIO_DB          equ %00000001
  36+ 0000              PIO_CA          equ %00000010
  37+ 0000              PIO_CB          equ %00000011
  38+ 0000
  39+ 0000              ; label defining for CTC (Counter Timer Circuit)
  40+ 0000              CTC_CH0         equ %00010000
  41+ 0000              CTC_CH1         equ %00010001
  42+ 0000              CTC_CH2         equ %00010010
  43+ 0000              CTC_CH3         equ %00010011
  44+ 0000
  45+ 0000              ;label defining for SIO (Serial Input/Output)
  46+ 0000              SIO_CA          equ %00100010
  47+ 0000              SIO_CB          equ %00100011
  48+ 0000              SIO_DA          equ %00100000
  49+ 0000              SIO_DB          equ %00100001
  50+ 0000
  51+ 0000              ;label defining for VDP (Video Display Processor)
  52+ 0000              VDP_DAT         equ %00110000
  53+ 0000                  IFDEF LM80C64K
  54+ 0000              VDP_SET         equ %00110001
  55+ 0000                  ELSE
  56+ 0000 ~            VDP_SET         equ %00110010
  57+ 0000                  ENDIF
  58+ 0000
  59+ 0000              ; label defining for PSG (Programmable Sound Generator)
  60+ 0000              PSG_REG         equ %01000000
  61+ 0000              PSG_DAT         equ %01000001
  62+ 0000
  63+ 0000              ; Interrupt-driven serial I/O interface lead by the Z80 SIO to run modified
  64+ 0000              ; NASCOM Basic 4.7 - Full input buffering with incoming data hardware handshaking
  65+ 0000              ; Handshake shows full before the buffer is totally filled to allow run-on from the sender
  66+ 0000              SER_BUFSIZE     equ     $58
  67+ 0000              SER_FULLSIZE    equ     $50
  68+ 0000              SER_EMPTYSIZE   equ     $05
  69+ 0000
  70+ 0000
  71+ 0000              ;------------------------------------------------------------------------------
  72+ 0000              ;                                F I R M W A R E
  73+ 0000              ;------------------------------------------------------------------------------
  74+ 0000              ; BASE MEMORY - RESET LOCATION ($0000) -> the CPU jumps to $0000 after a reset
  75+ 0000                              org     $0000
  76+ 0000 F3           RST00:          di                      ; be sure that INTs are disabled
  77+ 0001                  IFDEF LM80C64K
  78+ 0001 C3 16 51                     jp      ROM2RAM         ; jump to ROM/RAM switcher
  79+ 0004                  ELSE
  80+ 0004 ~                            jp      INIT_HW         ; jump to system initialization
  81+ 0004                  ENDIF
  82+ 0004
  83+ 0004              ;------------------------------------------------------------------------------
  84+ 0004              ; interrupt vector when SIO ch.B has a char available in its buffer
  85+ 0004                              ;$0004
  86+ 0004 65 01                        defw    RX_CHB_AVAIL
  87+ 0006
  88+ 0006              ;------------------------------------------------------------------------------
  89+ 0006              ; interrupt vector for SIO ch.B special conditions (i.e. buf overrun)
  90+ 0006                              ;$0006
  91+ 0006 68 01                        defw    SPEC_RXB_CNDT
  92+ 0008
  93+ 0008              ;------------------------------------------------------------------------------
  94+ 0008              ; send a character over serial ch. A
  95+ 0008                              ;$0008
  96+ 0008 C3 59 02     RST08:          jp      TXA
  97+ 000B FF                           BLOCK   1,$FF   ; filler
  98+ 000C
  99+ 000C              ;------------------------------------------------------------------------------
 100+ 000C              ; interrupt vector when SIO ch.A has a char available in its buffer
 101+ 000C                              ;$000C
 102+ 000C 00 01                        defw    RX_CHA_AVAIL
 103+ 000E
 104+ 000E              ;------------------------------------------------------------------------------
 105+ 000E              ; interrupt vector for SIO ch.A special conditions (i.e. buf overrun)
 106+ 000E                              ;$000E
 107+ 000E 36 01                        defw    SPEC_RXA_CNDT
 108+ 0010
 109+ 0010              ;------------------------------------------------------------------------------
 110+ 0010              ; receive a character over serial ch. A
 111+ 0010                              ;$0010
 112+ 0010 C3 2A 02     RST10:          jp      RXA
 113+ 0013 FF FF FF...                  BLOCK   5,$FF   ; filler
 114+ 0018              ;------------------------------------------------------------------------------
 115+ 0018              ; check buffer state
 116+ 0018
 117+ 0018                              ;$0018
 118+ 0018 C3 78 02     RST18:          jp      CKINCHAR
 119+ 001B FF FF FF...                  BLOCK   $25,$FF ; filler
 120+ 0040              ;------------------------------------------------------------------------------
 121+ 0040              ; interrupt vectors for CTC
 122+ 0040                              ;$0040               ; for CH0 Timer - used in BASIC by serial 1 for bps
 123+ 0040 06 53                        defw    CTC0IV
 124+ 0042                              ;$0042               ; for CH1 Timer - used in BASIC by serial 2 for bps
 125+ 0042 09 53                        defw    CTC1IV
 126+ 0044                              ;$0044               ; for CH2 timer - unused
 127+ 0044 0C 53                        defw    CTC2IV
 128+ 0046                              ;$0046               ; for CH3 Timer - used by FW for 100ths/s counter
 129+ 0046 0F 53                        defw    CTC3IV
 130+ 0048 FF FF FF...                  BLOCK   $1E,$FF ; filler
 131+ 0066              ;------------------------------------------------------------------------------
 132+ 0066              ; interrupt routine for NMI
 133+ 0066                              ;$0066
 134+ 0066 C3 A6 51                     jp      NMIUSR              ; jump to execute NMI service routine
 135+ 0069 FF FF FF...                  BLOCK   $27,$FF ; filler
 136+ 0090              ;------------------------------------------------------------------------------
 137+ 0090
 138+ 0090                              ;$0090
 139+ 0090                  IFDEF LM80C
 140+ 0090 ~                            defb    $4C,$4D,$38,$30,$43,$20,$43,$4F
 141+ 0090 ~                            defb    $4C,$4F,$52,$00,$00,$00,$00,$00
 142+ 0090                  ELSE
 143+ 0090 4C 4D 38 30                  defb    $4C,$4D,$38,$30,$43,$20,$36,$34
 143+ 0094 43 20 36 34
 144+ 0098 4B 20 43 4F                  defb    $4B,$20,$43,$4F,$4C,$4F,$52,$00
 144+ 009C 4C 4F 52 00
 145+ 00A0                  ENDIF
 146+ 00A0 43 4F 4D 50                  defb    $43,$4F,$4D,$50,$55,$54,$45,$52
 146+ 00A4 55 54 45 52
 147+ 00A8 20 28 32 30                  defb    $20,$28,$32,$30,$32,$30,$29,$00
 147+ 00AC 32 30 29 00
 148+ 00B0 44 65 73 69                  defb    $44,$65,$73,$69,$67,$6E,$65,$64
 148+ 00B4 67 6E 65 64
 149+ 00B8 20 62 79 00                  defb    $20,$62,$79,$00,$00,$00,$00,$00
 149+ 00BC 00 00 00 00
 150+ 00C0 4C 65 6F 6E                  defb    $4C,$65,$6F,$6E,$61,$72,$64,$6F
 150+ 00C4 61 72 64 6F
 151+ 00C8 20 4D 69 6C                  defb    $20,$4D,$69,$6C,$69,$61,$6E,$69
 151+ 00CC 69 61 6E 69
 152+ 00D0 46 57 20 31  FWVER:          defm    "FW ","1.05",$20,"2021-01-19",$20,"22:46:58",$00
 152+ 00D4 2E 30 35 20
 152+ 00D8 32 30 32 31
 152+ 00DC 2D 30 31 2D
 152+ 00E0 31 39 20 32
 152+ 00E4 32 3A 34 36
 152+ 00E8 3A 35 38 00
 153+ 00EC              FMVEREND:       equ     $
 154+ 00EC FF FF FF...                  BLOCK   $100-FMVEREND,$FF   ; filler
 155+ 0100              ;------------------------------------------------------------------------------
 156+ 0100
 157+ 0100              ;-------------------------------------------------------------------------------
 158+ 0100              ;               Z80 SIO CH. A MANAGEMENT
 159+ 0100              ;-------------------------------------------------------------------------------
 160+ 0100
 161+ 0100              ;-------------------------------------------------------------------------------
 162+ 0100              ; interrupt driven routine to get chars from Z80 SIO ch.A
 163+ 0100              ; this is the only serial channel that can print received chars onto the screen
 164+ 0100                              ;$0100
 165+ 0100 F5           RX_CHA_AVAIL:   push    AF              ; store A
 166+ 0101 E5                           push    HL              ; and HL
 167+ 0102 CD 8F 01                     call    A_RTS_OFF       ; disable RTS line
 168+ 0105 DB 20                        in      A,(SIO_DA)      ; read char from RX buffer into A
 169+ 0107 32 5E 53                     ld      (TMPKEYBFR),A   ; store it into the temp key buffer
 170+ 010A CD FD 01                     call    CHARINTOBFR     ; sub-routine to put the char into the input buffer
 171+ 010D D2 31 01                     jp      NC,LVRXCHA      ; if buffer is full, then leave without doing anything else
 172+ 0110 3A 5E 53                     ld      A,(TMPKEYBFR)   ; retrieve char
 173+ 0113 32 1F 53                     ld      (CHR4VID),A     ; write into buffer for video printing
 174+ 0116 FE 0D                        cp      CR              ; is it RETURN?
 175+ 0118 CA 20 01                     jp      Z,CNTRXCHA      ; yes, continue
 176+ 011B FE 20                        cp      $20             ; is it another control char (code < 32)?
 177+ 011D DA 31 01                     jp      C,LVRXCHA       ; yes, leave w/o printing it on video nor sending back to serial
 178+ 0120 F5           CNTRXCHA:       push    AF              ; store char
 179+ 0121 AF                           xor     A
 180+ 0122 32 5C 53                     ld      (KBDNPT),A      ; a char from serial is like a char printed by BASIC
 181+ 0125 3A 1E 53                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 182+ 0128 FE 01                        cp      $01             ; is the print on video on?
 183+ 012A CC 4B 07                     call    Z,CHAR2VID      ; yes, print on screen
 184+ 012D F1                           pop     AF              ; retrieve char
 185+ 012E CD 59 02                     call    TXA             ; send back to serial
 186+ 0131 E1           LVRXCHA:        pop     HL              ; retrieve HL
 187+ 0132 F1                           pop     AF              ; and A
 188+ 0133 FB                           ei                      ; re-enable interrupts
 189+ 0134 ED 4D                        reti                    ; and exit
 190+ 0136
 191+ 0136              ;-------------------------------------------------------------------------------
 192+ 0136              ; special SIO ch.A condition (i.e., buffer overrun)
 193+ 0136              ; if buffer overruns then show an error, empty the RX buffer and send
 194+ 0136              ; a break char
 195+ 0136 F5           SPEC_RXA_CNDT:  push    AF              ; store AF
 196+ 0137 CD 8F 01                     call    A_RTS_OFF       ; disable RTS
 197+ 013A CD CB 01                     call    SIO_A_DI        ; disable RX on ch. A
 198+ 013D 3A 64 53                     ld      A,(SERIALS_EN)  ; load serial status
 199+ 0140 CB 97                        res     2,A             ; disable RX on port 1
 200+ 0142 32 64 53                     ld      (SERIALS_EN),A  ; store new serial status
 201+ 0145 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 202+ 0147 CB E7                        set     4,A             ; set 5th pin ON
 203+ 0149 D3 01                        out     (PIO_DB),A      ; send new setting
 204+ 014B 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 205+ 014D D3 22                        out     (SIO_CA),A      ; send command to SIO
 206+ 014F AF           EMPTYCHABFR:    xor     A
 207+ 0150 D3 22                        out     (SIO_CA),A      ; write to WR0, select RR0
 208+ 0152 DB 22                        in      A,(SIO_CA)      ; read RR0 register
 209+ 0154 E6 01                        and     $01             ; check if input buffer if empty
 210+ 0156 CA 5D 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then leave
 211+ 0159 DB 20                        in      A,(SIO_DA)      ; read chars
 212+ 015B 18 F2                        jr      EMPTYCHABFR     ; repeat
 213+ 015D F1           CHABFREMPTY:    pop     AF              ; retrieve AF
 214+ 015E 21 24 3D                     ld      HL,SOERR        ; return point set to Serial Buffer Overrun routine
 215+ 0161 E3                           ex      (SP),HL         ; store onto stack
 216+ 0162 FB                           ei                      ; re-enable interrupts
 217+ 0163 ED 4D                        reti                    ; return from interrupt and execute code at SOERR
 218+ 0165
 219+ 0165              ;-------------------------------------------------------------------------------
 220+ 0165              ;               Z80 SIO CH. A MANAGEMENT
 221+ 0165              ;-------------------------------------------------------------------------------
 222+ 0165
 223+ 0165              ;-------------------------------------------------------------------------------
 224+ 0165              ; interrupt driven routine to get chars from Z80 SIO ch.B
 225+ 0165 FB           RX_CHB_AVAIL:   ei
 226+ 0166 ED 4D                        reti
 227+ 0168
 228+ 0168              ;-------------------------------------------------------------------------------
 229+ 0168              ; special SIO ch.A condition (i.e., buffer overrun)
 230+ 0168              ; if buffer overruns then show an error, empty the RX buffer and send
 231+ 0168              ; a break char
 232+ 0168 F5           SPEC_RXB_CNDT:  push    AF              ; store A
 233+ 0169 CD 97 01                     call    B_RTS_OFF       ; disable RTS
 234+ 016C CD D3 01                     call    SIO_B_DI        ; disable RX on ch.B
 235+ 016F 3A 64 53                     ld      A,(SERIALS_EN)  ; load serial status
 236+ 0172 CB 9F                        res     3,A             ; disable RX on port 2
 237+ 0174 32 64 53                     ld      (SERIALS_EN),A  ; store new serial status
 238+ 0177 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 239+ 0179 CB EF                        set     5,A             ; set 5th pin ON
 240+ 017B D3 01                        out     (PIO_DB),A      ; send new setting
 241+ 017D 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 242+ 017F D3 23                        out     (SIO_CB),A      ; send command to SIO
 243+ 0181 AF           EMPTYCHBBFR:    xor     A
 244+ 0182 D3 23                        out     (SIO_CB),A      ; write to WR0, select RR0
 245+ 0184 DB 23                        in      A,(SIO_CB)      ; read RR0 register
 246+ 0186 E6 01                        and     $01             ; check if input buffer if empty
 247+ 0188 CA 5D 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then jump to run "exit" code
 248+ 018B DB 21                        in      A,(SIO_DB)      ; read chars
 249+ 018D 18 F2                        jr      EMPTYCHBBFR     ; repeat
 250+ 018F
 251+ 018F
 252+ 018F              ;-------------------------------------------------------------------------------
 253+ 018F              ;               Z80 SIO MANAGEMENT
 254+ 018F              ;-------------------------------------------------------------------------------
 255+ 018F              ; disable RTS:
 256+ 018F              ; by resetting RTS bit (set to 0), the RTS line is disabled (HIGH)
 257+ 018F C5           A_RTS_OFF:      push    BC              ; store BC
 258+ 0190 0E 22                        ld      C,SIO_CA        ; select channel A
 259+ 0192 3A 65 53                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 260+ 0195 18 06                        jr      SIO_RTS_OFF
 261+ 0197 C5           B_RTS_OFF:      push    BC              ; store BC
 262+ 0198 0E 23                        ld      C,SIO_CB        ; select channel B
 263+ 019A 3A 66 53                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 264+ 019D CB 3F        SIO_RTS_OFF:    srl     A               ; position data bits in bits #5&6
 265+ 019F E6 60                        and     %01100000       ; get only bits #5&6
 266+ 01A1 47                           ld      B,A             ; store data bits
 267+ 01A2 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 268+ 01A4 ED 79                        out     (C),A
 269+ 01A6 3E 88                        ld      A,%10001000     ; enable DTR (b7) and TX (b4), disable RTS (b1)
 270+ 01A8 B0                           or      B               ; set data bits
 271+ 01A9 ED 79                        out     (C),A           ; send setting
 272+ 01AB C1                           pop     BC              ; retrieve BC
 273+ 01AC C9                           ret                     ; exit
 274+ 01AD
 275+ 01AD              ;-------------------------------------------------------------------------------
 276+ 01AD              ; enable RTS
 277+ 01AD              ; by setting RTS bit (set to 1), the RTS line is enabled (LOW)
 278+ 01AD C5           A_RTS_ON:       push    BC              ; store BC
 279+ 01AE 0E 22                        ld      C,SIO_CA        ; select channel A
 280+ 01B0 3A 65 53                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 281+ 01B3 18 06                        jr      SIO_RTS_ON
 282+ 01B5 C5           B_RTS_ON:       push    BC              ; store BC
 283+ 01B6 0E 23                        ld      C,SIO_CB        ; select channel B
 284+ 01B8 3A 66 53                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 285+ 01BB CB 3F        SIO_RTS_ON:     srl     A               ; position data bits in bits #5&6
 286+ 01BD E6 60                        and     %01100000       ; get only bits #5&6
 287+ 01BF 47                           ld      B,A             ; store data bits
 288+ 01C0 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 289+ 01C2 ED 79                        out     (C),A
 290+ 01C4 3E 8A                        ld      A,%10001010     ; enable DTR (b7), TX (b4), and RTS (b1)
 291+ 01C6 B0                           or      B               ; set data bits
 292+ 01C7 ED 79                        out     (C),A           ; send setting
 293+ 01C9 C1                           pop     BC              ; retrieve BC
 294+ 01CA C9                           ret                     ; return
 295+ 01CB
 296+ 01CB              ;-------------------------------------------------------------------------------
 297+ 01CB              ; disable SIO RX channel
 298+ 01CB C5           SIO_A_DI:       push    BC              ; store BC
 299+ 01CC 0E 22                        ld      C,SIO_CA        ; SIO channel A
 300+ 01CE 3A 65 53                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 301+ 01D1 18 06                        jr      SIO_RXDI        ; jump to disable RX
 302+ 01D3 C5           SIO_B_DI:       push    BC              ; store BC
 303+ 01D4 0E 23                        ld      C,SIO_CB        ; SIO channel B
 304+ 01D6 3A 66 53                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 305+ 01D9 47           SIO_RXDI:       ld      B,A             ; store data bits
 306+ 01DA 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 307+ 01DC ED 79                        out     (C),A
 308+ 01DE 78                           ld      A,B             ; retrieve data bits; RX disabled; auto enable is OFF
 309+ 01DF ED 79                        out     (C),A
 310+ 01E1 C1                           pop     BC              ; retrieve BC
 311+ 01E2 C9                           ret                     ; return
 312+ 01E3
 313+ 01E3              ;-------------------------------------------------------------------------------
 314+ 01E3              ; enable SIO RX channel
 315+ 01E3 C5           SIO_A_EI:       push    BC              ; store BC
 316+ 01E4 0E 22                        ld      C,SIO_CA
 317+ 01E6 3A 65 53                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 318+ 01E9 18 06                        jr      SIO_RXEN
 319+ 01EB C5           SIO_B_EI:       push    BC              ; store BC
 320+ 01EC 0E 23                        ld      C,SIO_CB
 321+ 01EE 3A 66 53                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 322+ 01F1 47           SIO_RXEN:       ld      B,A             ; store data bits
 323+ 01F2 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 324+ 01F4 ED 79                        out     (C),A           ; select register
 325+ 01F6 78                           ld      A,B             ; retrieve data bits
 326+ 01F7 CB C7                        set     0,A             ; set RX enabled; auto enable is OFF
 327+ 01F9 ED 79                        out     (C),A           ; send settings to SIO
 328+ 01FB C1                           pop     BC              ; retrieve BC
 329+ 01FC C9                           ret
 330+ 01FD
 331+ 01FD              ;------------------------------------------------------------------------------
 332+ 01FD              ; put a char into the input buffer, char is into A
 333+ 01FD              ; this sub is called both from the ISR "RX_CHA_AVAIL" and when
 334+ 01FD              ; the RETURN key is pressed on the keyboard
 335+ 01FD F5           CHARINTOBFR:    push    AF              ; store it
 336+ 01FE 3A A1 51                     ld      A,(serBufUsed)  ; load buffer size
 337+ 0201 FE 58                        cp      SER_BUFSIZE     ; if buffer is not full
 338+ 0203 DA 08 02                     jp      C,NOTFULL       ; then store the char
 339+ 0206 F1                           pop     AF              ; else drop it
 340+ 0207 C9                           ret                     ; and exit
 341+ 0208 2A 9D 51     NOTFULL:        ld      HL,(serInPtr)   ; buffer is not full, can store the char
 342+ 020B 23                           inc     HL              ; load pointer to find first free cell
 343+ 020C 7D                           ld      A,L             ; only check low byte because buffer<256
 344+ 020D FE 9D                        cp      bufWrap         ; check if the pointer is at the last cell
 345+ 020F 20 03                        jr      NZ,NOTWRAP      ; if not then continue
 346+ 0211 21 45 51                     ld      HL,SERBUF_START ; else load the address of the first cell
 347+ 0214 22 9D 51     NOTWRAP:        ld      (serInPtr),HL   ; store the new pointer
 348+ 0217 F1                           pop     AF              ; then retrieve the char...
 349+ 0218 77                           ld      (HL),A          ; ...and store it in the appropriate cell
 350+ 0219 21 A1 51                     ld      HL,serBufUsed   ; size of the input buffer
 351+ 021C 34                           inc     (HL)            ; increment it
 352+ 021D 3E 50                        ld      A,SER_FULLSIZE  ; input buffer capacity
 353+ 021F BE                           cp      (HL)            ; check if input buffer is full
 354+ 0220 D8                           ret     C               ; exit if buffer is not full
 355+ 0221 3A 64 53                     ld      A,(SERIALS_EN)  ; check if serial 1 is open
 356+ 0224 1F                           rra                     ; bit 0 into Carry: if Carry is 1 then serial 0 is open and...
 357+ 0225 DC 8F 01                     call    C,A_RTS_OFF     ; ...receiving further chars must be stopped
 358+ 0228 37                           scf                     ; set Carry flag, because  we must inform that the char has been added before to disable RTS
 359+ 0229 C9                           ret
 360+ 022A
 361+ 022A
 362+ 022A              ;-------------------------------------------------------------------------------
 363+ 022A              ; retrieve a char from the input buffer
 364+ 022A 3A A1 51     RXA:            ld      A,(serBufUsed)  ; load the buffer size
 365+ 022D A7                           and     A               ; check if it's 0 (empty)
 366+ 022E CA 2A 02                     jp      Z,RXA           ; if it's empty, wait for a char
 367+ 0231 F3                           di                      ; disable interrupts
 368+ 0232 E5                           push    HL              ; store HL
 369+ 0233 2A 9F 51                     ld      HL,(serRdPtr)   ; load pointer to first available char
 370+ 0236 23                           inc     HL              ; increment it (go to the next char)
 371+ 0237 7D                           ld      A,L             ; check if the end of the buffer has been reached
 372+ 0238 FE 9D                        cp      bufWrap         ; (only check low byte because buffer<256)
 373+ 023A 20 03                        jr      NZ,NOTRDWRAP    ; if not, jump straight
 374+ 023C 21 45 51                     ld      HL,SERBUF_START ; else reload the starting address of the buffer
 375+ 023F 22 9F 51     NOTRDWRAP:      ld      (serRdPtr),HL   ; store new pointer to the next char to read
 376+ 0242 3A A1 51                     ld      A,(serBufUsed)  ; load buffer size
 377+ 0245 3D                           dec     A               ; decrement it
 378+ 0246 32 A1 51                     ld      (serBufUsed),A  ; and store the new size
 379+ 0249 FE 05                        cp      SER_EMPTYSIZE   ; check if input buffer can be considered empty
 380+ 024B 30 08                        jr      NC,RXA_EXIT     ; if not empty yet, then exit
 381+ 024D 3A 64 53                     ld      A,(SERIALS_EN)  ; load serial state
 382+ 0250 EE 05                        xor     %00000101       ; check if serial 1 is open and RX enabled
 383+ 0252 CC AD 01                     call    Z,A_RTS_ON      ; yes, set RTS on
 384+ 0255 7E           RXA_EXIT:       ld      A,(HL)          ; recover the char and return it into A
 385+ 0256 E1                           pop     HL              ; retrieve HL
 386+ 0257 FB                           ei                      ; re-enable interrupts
 387+ 0258 C9                           ret                     ; return
 388+ 0259
 389+ 0259              ;------------------------------------------------------------------------------
 390+ 0259              ; sends a char over the serial - char is into A
 391+ 0259 F5           TXA:            push    AF              ; store AF
 392+ 025A C5                           push    BC              ; store BC
 393+ 025B 47                           ld      B,A             ; store char
 394+ 025C 3A 64 53                     ld      A,(SERIALS_EN)  ; load serial status
 395+ 025F EE 05                        xor     %00000101       ; check if serial 1 is open and RX is enabled
 396+ 0261 20 06                        jr      NZ,TXA_EXIT     ; no, jump over
 397+ 0263 78                           ld      A,B             ; retrieve char
 398+ 0264 D3 20                        out     (SIO_DA),A      ; send char to the SIO
 399+ 0266 CD 6C 02                     call    TX_EMP          ; wait for outgoing char to be sent
 400+ 0269 C1           TXA_EXIT:       pop     BC              ; retrieve BC
 401+ 026A F1                           pop     AF              ; retrieve AF
 402+ 026B C9                           ret                     ; return
 403+ 026C
 404+ 026C              ;------------------------------------------------------------------------------
 405+ 026C              ; wait until outgoing serial has been sent
 406+ 026C 97           TX_EMP:         sub     A               ; set A to 0
 407+ 026D 3C                           inc     A               ; set A to 1
 408+ 026E D3 22                        out     (SIO_CA),A      ; write to WR0, select RR1
 409+ 0270 DB 22                        in      A,(SIO_CA)      ; read RR1 register
 410+ 0272 CB 47                        bit     0,A             ; check if all chars have been sent
 411+ 0274 CA 6C 02                     jp      Z,TX_EMP        ; if not (bit 0 = 0) then retrieve
 412+ 0277 C9                           ret                     ; else exit
 413+ 0278
 414+ 0278
 415+ 0278              ;------------------------------------------------------------------------------
 416+ 0278              ; check if there is some chars into the buffer
 417+ 0278 3A A1 51     CKINCHAR:       ld      A,(serBufUsed)  ; load buffer size
 418+ 027B A7                           and     A               ; compare to 0
 419+ 027C C9                           ret                     ; return
 420+ 027D
 421+ 027D              ;------------------------------------------------------------------------------
 422+ 027D              ; print a text from memory, and terminate when $00 is found
 423+ 027D 7E           RAWPRINT:       ld      A,(HL)          ; load character from memory cell pointed by HL
 424+ 027E B7                           or      A               ; is it $00 (end string)?
 425+ 027F C8                           ret     Z               ; Yes, then return
 426+ 0280 32 1F 53                     ld      (CHR4VID),A     ; store char
 427+ 0283 F3                           di
 428+ 0284 CD 4B 07                     call    CHAR2VID        ; and send it to screen
 429+ 0287 FB                           ei
 430+ 0288 23                           inc     HL              ; and select the next one
 431+ 0289 18 F2                        jr      RAWPRINT        ; repeat
 432+ 028B
 433+ 028B              ;-------------------------------------------------
 434+ 028B              ; Interrupt service routine (ISR) for CH3 timer
 435+ 028B              ; this is used to increment the 100ths of a second counter and for cursor flashing
 436+ 028B F5           CH3_TIMER:      push    AF              ; save regs. A,
 437+ 028C C5                           push    BC              ; BC,
 438+ 028D D5                           push    DE              ; DE,
 439+ 028E E5                           push    HL              ; HL
 440+ 028F 21 02 53                     ld      HL,TMRCNT       ; load starting address of the timer
 441+ 0292 06 04                        ld      B,$04           ; 4 bytes to check
 442+ 0294 34           INCTMR3:        inc     (HL)            ; increment timer
 443+ 0295 20 03                        jr      NZ,CHKCRSR      ; if not zero then exit (finished increment)
 444+ 0297 23                           inc     HL              ; if yes, there was an overflow, so increment next byte
 445+ 0298 10 FA                        djnz    INCTMR3         ; repeat for 4 bytes
 446+ 029A CD B5 07     CHKCRSR:        call    FLASHCURSOR     ; call the flashing cursor routine
 447+ 029D CD DD 0C                     call    MNGSNDS         ; call the tone managemenet
 448+ 02A0 3A 02 53                     ld      A,(TMRCNT)      ; check for keyboard management
 449+ 02A3 1F                           rra                     ; bit 0 = 1 ?
 450+ 02A4 D4 42 0D                     call    NC,KEYBOARD     ; no, so read the keyboard inputs
 451+ 02A7 E1                           pop     HL              ; retrieve HL,
 452+ 02A8 D1                           pop     DE              ; DE,
 453+ 02A9 C1                           pop     BC              ; BC,
 454+ 02AA F1                           pop     AF              ; and A
 455+ 02AB FB                           ei                      ; re-enable interrupts
 456+ 02AC ED 4D                        reti                    ; exit from ISR
 457+ 02AE
 458+ 02AE              ;------------------------------------------------------------------------------
 459+ 02AE              ;               HARDWARE INITIALISATION
 460+ 02AE              ;------------------------------------------------------------------------------
 461+ 02AE              ; first run - setup HW & SW
 462+ 02AE              ; (on LN80C 64K runs from RAM)
 463+ 02AE 21 D4 52     INIT_HW:        ld      HL,TEMPSTACK    ; load temp stack pointer
 464+ 02B1 F9           INIT_HW2:       ld      SP,HL           ; set stack to temp stack pointer
 465+ 02B2 21 45 51                     ld      HL,SERBUF_START ; set beginning of input buffer
 466+ 02B5 22 9D 51                     ld      (serInPtr),HL   ; for incoming chars to store into buffer
 467+ 02B8 22 9F 51                     ld      (serRdPtr),HL   ; and for chars to be read from buffer
 468+ 02BB AF                           xor     A               ; reset A
 469+ 02BC 32 A1 51                     ld      (serBufUsed),A  ; actual buffer size is 0
 470+ 02BF 32 64 53                     ld      (SERIALS_EN),A  ; set serial ports status to OFF
 471+ 02C2                  IFDEF LM80C
 472+ 02C2 ~                            call    HELLOWRLD       ; little serial blink with LEDs
 473+ 02C2                  ENDIF
 474+ 02C2 CD 40 03                     call    initCTC         ; configure CTC, then...
 475+ 02C5 CD 7B 0C                     call    initPSG         ; ...configure PSG
 476+ 02C8 CD F2 04                     call    SHOW_LOGO       ; show computer logo
 477+ 02CB 1E 01                        ld      E,$01           ; E chooses the video mode (graphics 1)
 478+ 02CD CD D1 03                     call    initVDP         ; set video display
 479+ 02D0 AF                           xor     A
 480+ 02D1 ED 47                        ld      I,A             ; set high byte of interrupt vectors to point to page 0
 481+ 02D3 ED 5E                        im      2               ; interrupt mode 2
 482+ 02D5 FB                           ei                      ; enable interrupts
 483+ 02D6                              ; print system messages
 484+ 02D6 AF                           xor     A               ; A=0 so...
 485+ 02D7 32 5C 53                     ld      (KBDNPT),A      ; ...inputs don't come from keyboard
 486+ 02DA 3C                           inc     A               ; A=1...
 487+ 02DB 32 1E 53                     ld      (PRNTVIDEO),A   ; ...to activate the print-on-video
 488+ 02DE 21 76 03                     ld      HL,MSGTXT1      ; sign-on message
 489+ 02E1 CD 7D 02                     call    RAWPRINT        ; print message
 490+ 02E4 3A A2 51                     ld      A,(basicStarted); check if BASIC is already started
 491+ 02E7 FE 59                        cp      'Y'             ; to see if this is a power-up
 492+ 02E9 20 19                        jr      NZ,COLDSTART    ; if not, then do a COLD start
 493+ 02EB 21 B4 03                     ld      HL,MSGTXT2      ; message to choose kind of start
 494+ 02EE CD 7D 02                     call    RAWPRINT        ; print message
 495+ 02F1 CD 17 09                     call    CURSOR_ON       ; enable cursor
 496+ 02F4 AF                           xor     A
 497+ 02F5 32 1E 53                     ld      (PRNTVIDEO),A   ; disable print-on-video
 498+ 02F8 CD 2A 02     CORW:           call    RXA             ; look for a pressed key
 499+ 02FB E6 DF                        and     %11011111       ; only UPPERCASE char
 500+ 02FD FE 43                        cp      'C'             ; cold start?
 501+ 02FF 20 0E                        jr      NZ,CHECKWARM    ; no, let's check for warm start
 502+ 0301 CD 1C 03                     call    ECHO_CHAR       ; echoes the char
 503+ 0304 3E 59        COLDSTART:      ld      A,'Y'           ; yes, set the "BASIC started" flag
 504+ 0306 32 A2 51                     ld      (basicStarted),A
 505+ 0309 CD 2C 09                     call    CURSOR_OFF      ; disable cursor
 506+ 030C C3 E1 11                     jp      COLD            ; start BASIC COLD
 507+ 030F FE 57        CHECKWARM:      cp      'W'
 508+ 0311 20 E5                        jr      NZ,CORW         ; char not recognized, wait again
 509+ 0313 CD 1C 03                     call    ECHO_CHAR       ; echoes the char
 510+ 0316 CD 2C 09                     call    CURSOR_OFF      ; disable cursor
 511+ 0319 C3 E4 11                     jp      WARM            ; start BASIC WARM
 512+ 031C
 513+ 031C              ;-------------------------------------------------------------------------------
 514+ 031C              ; send back char received through ch. A
 515+ 031C 32 1F 53     ECHO_CHAR:      ld      (CHR4VID),A     ; set char for video printing
 516+ 031F AF                           xor     A
 517+ 0320 32 5C 53                     ld      (KBDNPT),A      ; input is not from keyboard
 518+ 0323 F3                           di                      ; disable INTs
 519+ 0324 CD 4B 07                     call    CHAR2VID        ; echoes back the pressed key,
 520+ 0327 3E 0D                        ld      A,CR            ; then set a CR
 521+ 0329 32 1F 53                     ld      (CHR4VID),A     ; set char for video printing
 522+ 032C CD 4B 07                     call    CHAR2VID        ; and send it to screen
 523+ 032F FB                           ei                      ; re-enable INTs
 524+ 0330 3E 01                        ld      A,$01
 525+ 0332 32 1E 53                     ld      (PRNTVIDEO),A   ; re-enable video printing
 526+ 0335 C9                           ret                     ; return to caller
 527+ 0336
 528+ 0336                  IFDEF LM80C
 529+ 0336 ~            ;-------------------------------------------------------------------------------
 530+ 0336 ~            ; little serial blink with LEDs
 531+ 0336 ~            HELLOWRLD:      ld      C,$09           ; 8 LEDs to be turned off + 1 more step to turn off the last LED
 532+ 0336 ~                            ld      A,%11001111     ; set mode 3 (mode control)
 533+ 0336 ~                            out     (PIO_CB),A      ; for PIO port B
 534+ 0336 ~                            xor     A               ; set pins to OUTPUT
 535+ 0336 ~                            out     (PIO_CB),A      ; for port B
 536+ 0336 ~                            inc     A               ; LSB on
 537+ 0336 ~            LEDLIGHT:       out     (PIO_DB),A      ; turn LEDs on/off for a "Supercar" sequence
 538+ 0336 ~                            ld      E,$20           ; little delay
 539+ 0336 ~            DEC_E:          ld      B,$00           ; count to 256
 540+ 0336 ~            COUNTER:        djnz    COUNTER         ; decrement inner counter
 541+ 0336 ~                            dec     E               ; decrement outer counter
 542+ 0336 ~                            jr      NZ,DEC_E        ; finish delay
 543+ 0336 ~                            sla     A               ; shift reg.A to left 1 bit
 544+ 0336 ~                            dec     C               ; next LED
 545+ 0336 ~                            jr      NZ,LEDLIGHT     ; all LEDs done? no, repeat
 546+ 0336 ~                            ret                     ; return to caller
 547+ 0336                  ENDIF
 548+ 0336              ;-------------------------------------------------------------------------------
 549+ 0336              ; Z80 SIO default settings for serial channels
 550+ 0336 30           SIO_A_SETS:     defb    %00110000       ; write into WR0: error reset, select WR0
 551+ 0337 18                           defb    %00011000       ; write into WR0: channel reset
 552+ 0338 04                           defb    %00000100       ; write into WR0: select WR4
 553+ 0339 44                           defb    %01000100       ; write into WR4: presc. 16x, 1 stop bit, no parity
 554+ 033A 05                           defb    %00000101       ; write into WR0: select WR5
 555+ 033B E8                           defb    %11101000       ; write into WR5: DTR on, TX 8 bits, BREAK off, TX on, RTS off
 556+ 033C 01           SIO_B_SETS:     defb    %00000001       ; write into WR0: select WR1
 557+ 033D 04                           defb    %00000100       ; write into WR1: status affects interrupt vectors
 558+ 033E 02                           defb    %00000010       ; write into WR0: select WR2
 559+ 033F 00                           defb    %00000000       ; write into WR2: set interrupt vector, but bits D3/D2/D1 of this vector
 560+ 0340                                                      ; will be affected by the channel & condition that raised the interrupt
 561+ 0340                                                      ; (see datasheet): in our example, 0x0C for Ch.A receiving A char, 0x0E
 562+ 0340                                                      ; for special conditions
 563+ 0340              ;------------------------------------------------------------------------------
 564+ 0340              ;               Z80 CTC SETTING UP
 565+ 0340              ;------------------------------------------------------------------------------
 566+ 0340              initCTC:
 567+ 0340 21 6A 03                     ld      HL,CTCCONF      ; CTC configuration
 568+ 0343 11 06 53                     ld      DE,CTC0IV       ; CTC interrupt vector table
 569+ 0346 01 0C 00                     ld      BC,$000C        ; 12 bytes
 570+ 0349 ED B0                        ldir                    ; copy data
 571+ 034B              ;CH0, CH1, & CH2 disabled
 572+ 034B 3E 03                        ld      A,%00000011     ; interrupt off, timer mode, prescaler=16, don't care ext. TRG edge,
 573+ 034D                                                      ; start timer on loading constant, no time constant follows, software reset, command word
 574+ 034D D3 10                        out     (CTC_CH0),A     ; set CH0
 575+ 034F D3 11                        out     (CTC_CH1),A     ; set CH1
 576+ 0351 D3 12                        out     (CTC_CH2),A     ; set CH2
 577+ 0353              ;init CH3
 578+ 0353              ;CH3 divides CPU CLK by 144*256 providing an interrupt signal at 100 Hz (1/100 sec).
 579+ 0353              ;f = CPU_CLK/(144*256) => 3,686,400 / ( 36,864 ) => 100Hz
 580+ 0353 3E A7                        ld      A,%10100111     ; interrupt on; timer mode; prescaler=256; don't care ext; automatic trigger;
 581+ 0355                                                      ; time constant follows; cont. operation; command word
 582+ 0355 D3 13                        out     (CTC_CH3),A     ; send to CH3
 583+ 0357 3E 90                        ld      A,$90           ; time constant - 90$ (144d)
 584+ 0359 D3 13                        out     (CTC_CH3),A     ; send to CH3
 585+ 035B 3E 40                        ld      A,%01000000     ; D7..D3 provide the first part of the int vector (in our case, $0100), followed by
 586+ 035D                                                      ; D2..D1, provided by the CTC (they point to the channel), D0=interrupt word
 587+ 035D                                                      ; so int vector is 01000xx00
 588+ 035D D3 10                        out     (CTC_CH0),A     ; send to CTC
 589+ 035F                              ; reset cells of 100ths of a second counter
 590+ 035F AF                           xor     A               ; reset A
 591+ 0360 21 02 53                     ld      HL,TMRCNT       ; load TMR pointer
 592+ 0363 06 04                        ld      B,$04           ; 4 memory cells
 593+ 0365 77           RESTMR:         ld      (HL),A          ; reset n-cell of TMR
 594+ 0366 23                           inc     HL              ; next cell
 595+ 0367 10 FC                        djnz    RESTMR          ; repeat for 4 cells
 596+ 0369 C9                           ret
 597+ 036A
 598+ 036A
 599+ 036A              ;------------------------------------------------------------------------------
 600+ 036A              ; jump table for CHx interrupts
 601+ 036A FB ED 4D     CTCCONF:        defb    $FB,$ED,$4D     ; CTC0 interrupt vector (ei; reti)
 602+ 036D FB ED 4D                     defb    $FB,$ED,$4D     ; CTC1 interrupt vector (ei; reti)
 603+ 0370 FB ED 4D                     defb    $FB,$ED,$4D     ; CTC2 interrupt vector (ei; reti)
 604+ 0373 C3 8B 02                     jp      CH3_TIMER       ; CTC3 interrupt vector (jump to execute sys-tick timer)
 605+ 0376
 606+ 0376
 607+ 0376              ;------------------------------------------------------------------------------
 608+ 0376              ; welcome messages
 609+ 0376              MSGTXT1:
 610+ 0376                  IFDEF LM80C64K
 611+ 0376 20 20 20 20                  defm    "    LM80C 64K Color Computer",CR
 611+ 037A 4C 4D 38 30
 611+ 037E 43 20 36 34
 611+ 0382 4B 20 43 6F
 611+ 0386 6C 6F 72 20
 611+ 038A 43 6F 6D 70
 611+ 038E 75 74 65 72
 611+ 0392 0D
 612+ 0393                  ELSE
 613+ 0393 ~                            defm    "      LM80C Color Computer",CR
 614+ 0393                  ENDIF
 615+ 0393 20 62 79 20                  defm    " by Leonardo Miliani * FW R","1.05",CR,0
 615+ 0397 4C 65 6F 6E
 615+ 039B 61 72 64 6F
 615+ 039F 20 4D 69 6C
 615+ 03A3 69 61 6E 69
 615+ 03A7 20 2A 20 46
 615+ 03AB 57 20 52 31
 615+ 03AF 2E 30 35 0D
 615+ 03B3 00
 616+ 03B4 0D           MSGTXT2:        defb    CR
 617+ 03B5 20 20 20 3C                  defm    "   <C>old or <W>arm start? ",0
 617+ 03B9 43 3E 6F 6C
 617+ 03BD 64 20 6F 72
 617+ 03C1 20 3C 57 3E
 617+ 03C5 61 72 6D 20
 617+ 03C9 73 74 61 72
 617+ 03CD 74 3F 20 00
 618+ 03D1
# file closed: ../include/bootloader/bootloader-1.06.asm
  71  03D1
  72  03D1              ; incude the latest version of the VDP module
  73  03D1                  INCLUDE "../include/vdp/vdp-1.4.asm"
# file opened: ../include/vdp/vdp-1.4.asm
   1+ 03D1              ; ------------------------------------------------------------------------------
   2+ 03D1              ; LM80C - VDP ROUTINES - 1.4
   3+ 03D1              ; ------------------------------------------------------------------------------
   4+ 03D1              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 03D1              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 03D1              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 03D1              ; kind of warranty: you can use them at your own risk.
   8+ 03D1              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 03D1              ; maintain the copyright notices, include this advice and the note to the
  10+ 03D1              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 03D1              ; redistribuite them.
  12+ 03D1              ; https://www.leonardomiliani.com
  13+ 03D1              ;
  14+ 03D1              ; Please support me by visiting the following links:
  15+ 03D1              ; Main project page: https://www.leonardomiliani.com
  16+ 03D1              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 03D1              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 03D1              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 03D1              ; ------------------------------------------------------------------------------
  20+ 03D1              ;
  21+ 03D1              ;------------------------------------------------------------------------------
  22+ 03D1              ; VDP INITIALISATION
  23+ 03D1              ; initialize VDP for a specific graphics mode
  24+ 03D1              ; INPUT: E -> contains the graphics mode:
  25+ 03D1              ; 0=text; 1=graphics 1; 2=graphics 2; 3=multicolor; 4=extended graphics 2
  26+ 03D1 D5           initVDP:        push    DE              ; store E
  27+ 03D2 CD B9 0A                     call    EMPTY_VRAM      ; reset VRAM
  28+ 03D5 CD D7 0A                     call    SET_GFX_MODE    ; load register settings
  29+ 03D8 CD CC 0A                     call    CLR_RAM_REG     ; reset RAM registers
  30+ 03DB D1                           pop     DE              ; restore reg. E
  31+ 03DC AF                           xor     A               ; reset A
  32+ 03DD 47                           ld      B,A             ; reset B (will be used later)
  33+ 03DE 7B                           ld      A,E             ; move E into A
  34+ 03DF 32 14 53                     ld      (SCR_MODE),A    ; store screen mode
  35+ 03E2 FE 01                        cp      $01             ; is it graphics 1 (A=1)?
  36+ 03E4 CA 20 04                     jp      Z,G1MD          ; yes, jump over
  37+ 03E7 FE 02                        cp      $02             ; is it graphics 2 (A=2)?
  38+ 03E9 CA 60 04                     jp      Z,G2MD          ; yes, jump over
  39+ 03EC FE 03                        cp      $03             ; is it multicolor (A=3)?
  40+ 03EE CA 82 04                     jp      Z,MCMD          ; yes, jump over
  41+ 03F1 FE 04                        cp      $04             ; is it extended graphics 2 (A=4)?
  42+ 03F3 CA A5 04                     jp      Z,EXG2MD        ; yes, jump over
  43+ 03F6                              ; otherwise, it must be $00 so we assume that it's text mode
  44+ 03F6
  45+ 03F6              ; LOAD VDP SETTINGS FOR SELECTED VIDEO MODE:
  46+ 03F6
  47+ 03F6                              ; TEXT MODE (G0)
  48+ 03F6                              ; load charset
  49+ 03F6 60           TXTMD:          ld      H,B
  50+ 03F7 68                           ld      L,B             ; HL=first pattern cell $0000
  51+ 03F8 CD F3 0A                     call    LOADCHARSET     ; load patterns into VRAM
  52+ 03FB                              ; set cursor & video overlay
  53+ 03FB AF                           xor     A               ; reset A
  54+ 03FC 32 17 53                     ld      (SCR_CURS_X),A  ; set cursor position at X=0
  55+ 03FF 32 18 53                     ld      (SCR_CURS_Y),A  ; and Y=0
  56+ 0402 3E 05                        ld      A,$05           ; light blue
  57+ 0404 32 21 53                     ld      (BKGNDCLR),A    ; set background/border color
  58+ 0407 3E 28                        ld      A,$28
  59+ 0409 32 12 53                     ld      (SCR_SIZE_W),A  ; screen width = 40 cols
  60+ 040C 3E 18                        ld      A,$18
  61+ 040E 32 13 53                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  62+ 0411 3E 1E                        ld      A,$1E
  63+ 0413 32 E8 51                     ld      (COMMAN),A      ; width for commas (4 columns)
  64+ 0416 11 00 08                     ld      DE,$0800
  65+ 0419 ED 53 15 53                  ld      (SCR_NAM_TB),DE ; set name table address
  66+ 041D C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
  67+ 0420
  68+ 0420                              ; GRAPHICS 1 MODE (G1)
  69+ 0420                              ; load pattern table
  70+ 0420 68           G1MD:           ld      L,B
  71+ 0421 60                           ld      H,B             ; HL=first pattern cell $0000
  72+ 0422 CD F3 0A                     call    LOADCHARSET     ; load patterns into VRAM
  73+ 0425                              ; set cursor & video overlay
  74+ 0425 AF                           xor     A               ; position cursor
  75+ 0426 32 17 53                     ld      (SCR_CURS_X),A  ; at X=0
  76+ 0429 32 18 53                     ld      (SCR_CURS_Y),A  ; and Y=0
  77+ 042C 3E 20                        ld      A,$20
  78+ 042E 32 12 53                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
  79+ 0431 3E 18                        ld      A,$18
  80+ 0433 32 13 53                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  81+ 0436 3E 14                        ld      A,$14
  82+ 0438 32 E8 51                     ld      (COMMAN),A      ; width for commas (3 columns)
  83+ 043B 11 00 18                     ld      DE,$1800
  84+ 043E ED 53 15 53                  ld      (SCR_NAM_TB),DE ; set name table address
  85+ 0442                              ; load color table
  86+ 0442 21 00 20                     ld      HL,$2000        ; color table start: $2000
  87+ 0445 CD 5A 06                     call    SETVDPADRS
  88+ 0448 3E 01                        ld      A,$01           ; foreground color...
  89+ 044A 32 20 53                     ld      (FRGNDCLR),A    ; ...set to black
  90+ 044D 3E 0F                        ld      A,$0F           ; background color...
  91+ 044F 32 21 53                     ld      (BKGNDCLR),A    ; ...set to white
  92+ 0452 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
  93+ 0454 06 20                        ld      B,$20           ; 32 bytes of colors
  94+ 0456 0D                           dec     C              ; VDP data mode
  95+ 0457 ED 79        LDCLRTBMD1:     out     (C),A           ; after the first byte, the VDP autoincrements VRAM pointer
  96+ 0459 00                           nop
  97+ 045A 00                           nop
  98+ 045B 10 FA                        djnz    LDCLRTBMD1      ; repeat for 32 bytes
  99+ 045D C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 100+ 0460
 101+ 0460                              ; GRAPHICS 2 MODE (G2)
 102+ 0460 AF           G2MD:           xor     A               ; position cursor
 103+ 0461 32 17 53                     ld      (SCR_CURS_X),A  ; at X=0
 104+ 0464 32 18 53                     ld      (SCR_CURS_Y),A  ; and Y=0
 105+ 0467 32 12 53                     ld      (SCR_SIZE_W),A  ; screen width = 256 pixels (0=256)
 106+ 046A 3C                           inc     A               ; black on...
 107+ 046B 32 20 53                     ld      (FRGNDCLR),A    ; ...foreground
 108+ 046E 3E 0F                        ld      A,$0F           ; white on...
 109+ 0470 32 21 53                     ld      (BKGNDCLR),A    ; ...background
 110+ 0473 3E C0                        ld      A,$C0
 111+ 0475 32 13 53                     ld      (SCR_SIZE_H),A  ; screen height = 192 pixels
 112+ 0478 11 00 18                     ld      DE,$1800
 113+ 047B ED 53 15 53                  ld      (SCR_NAM_TB),DE ; set name table address
 114+ 047F C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 115+ 0482
 116+ 0482                              ; MULTICOLOR MODE (G3)
 117+ 0482 AF           MCMD:           xor     A               ; position cursor
 118+ 0483 32 17 53                     ld      (SCR_CURS_X),A  ; at X=0
 119+ 0486 32 18 53                     ld      (SCR_CURS_Y),A  ; and Y=0
 120+ 0489 3E 0F                        ld      A,$0F           ; white color for...
 121+ 048B 32 21 53                     ld      (BKGNDCLR),A    ; ...background and...
 122+ 048E 32 20 53                     ld      (FRGNDCLR),A    ; ...foreground (even this is not used in MC)
 123+ 0491 3E 40                        ld      A,$40
 124+ 0493 32 12 53                     ld      (SCR_SIZE_W),A  ; screen width = 64 blocks
 125+ 0496 3E 30                        ld      A,$30
 126+ 0498 32 13 53                     ld      (SCR_SIZE_H),A  ; screen height = 48 blocks
 127+ 049B 11 00 08                     ld      DE,$0800
 128+ 049E ED 53 15 53                  ld      (SCR_NAM_TB),DE ; set name table address
 129+ 04A2 C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 130+ 04A5
 131+ 04A5                              ; EXTENDED GRAPHICS 2 (G4)
 132+ 04A5              EXG2MD:         ; load pattern table
 133+ 04A5 60                           ld      H,B
 134+ 04A6 68                           ld      L,B             ; HL=first pattern cell $0000
 135+ 04A7 CD F3 0A                     call    LOADCHARSET     ; load patterns into VRAM
 136+ 04AA                              ; set cursor & video overlay
 137+ 04AA AF                           xor     A               ; position cursor
 138+ 04AB 32 17 53                     ld      (SCR_CURS_X),A  ; at X=0
 139+ 04AE 32 18 53                     ld      (SCR_CURS_Y),A  ; and Y=0
 140+ 04B1 3E 20                        ld      A,$20
 141+ 04B3 32 12 53                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
 142+ 04B6 3E 18                        ld      A,$18
 143+ 04B8 32 13 53                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
 144+ 04BB 3E 14                        ld      A,$14
 145+ 04BD 32 E8 51                     ld      (COMMAN),A      ; width for commas (3 columns)
 146+ 04C0 11 00 38                     ld      DE,$3800
 147+ 04C3 ED 53 15 53                  ld      (SCR_NAM_TB),DE ; set name table address
 148+ 04C7                               ; load color table
 149+ 04C7 21 00 20                     ld      HL,$2000        ; color table start: $2000
 150+ 04CA CD 5A 06                     call    SETVDPADRS
 151+ 04CD 3E 01                        ld      A,$01           ; foreground color is...
 152+ 04CF 32 20 53                     ld      (FRGNDCLR),A    ; ...set to black
 153+ 04D2 3E 0F                        ld      A,$0F           ; whitefor...
 154+ 04D4 32 21 53                     ld      (BKGNDCLR),A    ; ...background
 155+ 04D7 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
 156+ 04D9 16 08                        ld      D,$08           ; 8 pages of
 157+ 04DB 06 00                        ld      B,$00           ; 256 bytes of colors (total of 2,048 cells)
 158+ 04DD 0D                           dec     C              ; VDP data mode
 159+ 04DE ED 79        LDCLRTBEX2:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
 160+ 04E0 00                           nop
 161+ 04E1 00                           nop
 162+ 04E2 10 FA                        djnz    LDCLRTBEX2      ; repeat for 256 bytes
 163+ 04E4 15                           dec     D               ; did we fill up all the cells?
 164+ 04E5 20 F7                        jr      NZ,LDCLRTBEX2   ; no, repeat
 165+ 04E7                              ; LAST VDP SETTINGS
 166+ 04E7 CD 2C 09     ENDVDPSET:      call    CURSOR_OFF      ; disable cursor
 167+ 04EA CD CC 05                     call    EMPTYVIDBUF     ; empty video buffer
 168+ 04ED AF                           xor     A
 169+ 04EE 32 1B 53                     ld      (SCR_ORG_CHR),A ; store byte used tochar used to empty the video buffer
 170+ 04F1 C9                           ret                     ; return to caller
 171+ 04F2
 172+ 04F2
 173+ 04F2              ; show initial logo
 174+ 04F2 CD B9 0A     SHOW_LOGO:      call    EMPTY_VRAM      ; reset VRAM
 175+ 04F5                              ; set VDP for G2 mode
 176+ 04F5 06 07                        ld      B,$07           ; set only the first 7 registers
 177+ 04F7 11 10 00                     ld      DE,$0010        ; load settings for G2 mode
 178+ 04FA CD DF 0A                     call    SET_GFX_MODE2   ; load register settings
 179+ 04FD 16 01                        ld      D,$01           ; backdrop color set to black
 180+ 04FF ED 51                        out     (C),D           ; send data to VDP
 181+ 0501 ED 79                        out     (C),A           ; indicate the register to send data to
 182+ 0503                              ; set name table
 183+ 0503 21 00 18                     ld      HL,$1800        ; name table address
 184+ 0506 CD 48 06                     call    SETNAMETABLE    ; set name table (load names into table)
 185+ 0509 CD 6C 05                     call    ERASECLRTBL     ; erase color table (set foreground & background to black)
 186+ 050C                              ; set colors for logo
 187+ 050C 21 00 28                     ld      HL,$2800        ; 2nd page of color table
 188+ 050F CD 5A 06                     call    SETVDPADRS
 189+ 0512 06 05                        ld      B,$05           ; 5 bands
 190+ 0514 21 B7 05                     ld      HL,CLRTABLE
 191+ 0517 0D                           dec     C              ; set VDP_DAT
 192+ 0518 1E 08                        ld      E,$08           ; 8 pixels each pattern
 193+ 051A 16 40        RPT101:         ld      D,$40           ; 64 chars each band
 194+ 051C 7E                           ld      A,(HL)          ; load data
 195+ 051D ED 79        RPT102:         out     (C),A           ; send it to VRAM
 196+ 051F 00                           nop                     ; little delay
 197+ 0520 1D                           dec     E               ; decrement counter
 198+ 0521 20 FA                        jr      NZ,RPT102       ; repeat until zero
 199+ 0523 1E 08                        ld      E,$08           ; 8 pixels each pattern
 200+ 0525 15                           dec     D               ; decrement char band counter
 201+ 0526 20 F5                        jr      NZ,RPT102       ; repeat until zero
 202+ 0528 23                           inc     HL              ; next pattern
 203+ 0529 10 EF                        djnz    RPT101          ; repeat until covered every band
 204+ 052B                              ; set pattern table
 205+ 052B 21 00 08                     ld      HL,$0800        ; address of first cell of 2nd area of pattern table
 206+ 052E 11 3B 0B                     ld      DE,LM80CLOGO    ; pointer to logo pattern
 207+ 0531 06 00                        ld      B,$00           ; 256 bytes, 8 rows
 208+ 0533 CD 97 05     RPT103:         call    LOADLOGOCHRS
 209+ 0536 13                           inc     DE              ; next logo pattern
 210+ 0537 10 FA                        djnz    RPT103
 211+ 0539 06 20                        ld      B,$20           ; repeat for another 2 rows
 212+ 053B CD 97 05     RPT104:         call    LOADLOGOCHRS
 213+ 053E 13                           inc     DE              ; next logo pattern
 214+ 053F 10 FA                        djnz    RPT104
 215+ 0541                              ; show logo/message, play a beep, check for SHIFT pressure (to disable DOS), and wait a while
 216+ 0541 06 02                        ld      B,$02           ; two times
 217+ 0543 AF                           xor     A               ; reset A
 218+ 0544 57                           ld      D,A             ; 256 times
 219+ 0545 5F                           ld      E,A             ; x 256 times
 220+ 0546 32 22 53                     ld      (TMPBFR1),A     ; sound flag set to 0
 221+ 0549                  IFDEF LM80C64K
 222+ 0549 3C                           inc     A               ; by default, I/O DOS buffer is enabled on LM80C 64K, disabled on LM80C
 223+ 054A                  ENDIF
 224+ 054A 32 67 53                     ld      (DOS_EN),A      ; DOS enabled
 225+ 054D 00           DEC_D:          nop                     ; does nothing...
 226+ 054E 00                           nop
 227+ 054F 00                           nop
 228+ 0550 00                           nop
 229+ 0551 00                           nop
 230+ 0552 00                           nop                     ; ...until here
 231+ 0553 1D                           dec     E               ; decrement E
 232+ 0554 20 F7                        jr      NZ,DEC_D        ; repeat until $00
 233+ 0556 7A                           ld      A,D
 234+ 0557 FE 40                        cp      $40             ; ...equal to 64
 235+ 0559 CC 83 05                     call    Z,SETBEEP       ; if yes, start sound
 236+ 055C 15                           dec     D
 237+ 055D 20 EE                        jr      NZ,DEC_D        ; repeat
 238+ 055F 3A 22 53                     ld      A,(TMPBFR1)     ; sound state
 239+ 0562 FE 02                        cp      $02             ; check if sound is to be set off
 240+ 0564 C4 8F 05                     call    NZ,BEEPOFF      ; yes
 241+ 0567                  IFDEF LM80C64K
 242+ 0567 CD BC 05                     call    CHKSPCK         ; check if special key (CTRL) has been pressed on keyboard
 243+ 056A                                                      ; on LM80C 64K, you can disabled the I/O DOS buffer, on LM80C you can't
 244+ 056A                  ENDIF
 245+ 056A 10 E1                        djnz    DEC_D           ; repeat
 246+ 056C              ERASECLRTBL:    ; erase color table
 247+ 056C 3E 11                        ld      A,$11           ; foreground and background set to black
 248+ 056E 16 0A                        ld      D,$0A           ; 10 pages
 249+ 0570 06 00                        ld      B,$00           ; 256 color cells per page
 250+ 0572 21 00 28                     ld      HL,$2800        ; first cell of 2nd color table
 251+ 0575 CD 5A 06                     call    SETVDPADRS      ; send address
 252+ 0578 0D                           dec     C              ; VDP address for passing data
 253+ 0579 ED 79        RPT100:         out     (C),A           ; send data
 254+ 057B 00                           nop
 255+ 057C 00                           nop                     ; little delay
 256+ 057D 10 FA                        djnz    RPT100          ; repeat for entire page
 257+ 057F 15                           dec     D
 258+ 0580 20 F7                        jr      NZ,RPT100       ; repeat for all the pages ($0A00 cells)
 259+ 0582 C9                           ret                     ; return to caller
 260+ 0583
 261+ 0583              ; play a beep
 262+ 0583 3A 22 53     SETBEEP:        ld      A,(TMPBFR1)     ; check the already-beeped flag
 263+ 0586 B7                           or      A               ; is it 0?
 264+ 0587 C0                           ret     NZ              ; no, exit
 265+ 0588 3C                           inc     A               ; flag to 1
 266+ 0589 32 22 53                     ld      (TMPBFR1),A     ; set sound
 267+ 058C C3 A9 0C                     jp      WLCMBEEP        ; play a beep & return
 268+ 058F
 269+ 058F              ; beep off
 270+ 058F 3E 02        BEEPOFF:        ld      A,$02           ; flag for sound off
 271+ 0591 32 22 53                     ld      (TMPBFR1),A     ; set flag
 272+ 0594 C3 AF 0C                     jp      NOBEEP          ; stop beep and return
 273+ 0597
 274+ 0597
 275+ 0597              ; used to load the chars that will compose the logo of the splash screen
 276+ 0597 1A           LOADLOGOCHRS:   ld      A,(DE)          ; load a pattern char of the logo
 277+ 0598 87                           add     A,A
 278+ 0599 87                           add     A,A
 279+ 059A 87                           add     A,A             ; multiply times 8 to get the offset
 280+ 059B C5                           push    BC
 281+ 059C D5                           push    DE              ; store BC and DE
 282+ 059D E5                           push    HL              ; store VRAM address to write to
 283+ 059E 21 41 50                     ld      HL,LOGOFONT     ; start of logo font data
 284+ 05A1 5F                           ld      E,A
 285+ 05A2 16 00                        ld      D,$00           ; put offset (A) into DE
 286+ 05A4 19                           add     HL,DE           ; get address of pattern data
 287+ 05A5 EB                           ex      DE,HL           ; move address into DE
 288+ 05A6 E1                           pop     HL              ; retrieve VRAM address
 289+ 05A7 06 08                        ld      B,$08           ; 8 bytes per pattern
 290+ 05A9 CD 5A 06                     call    SETVDPADRS      ; set VDP address
 291+ 05AC 0D                           dec     C              ; VDP_DAT
 292+ 05AD 1A           SNDLOGPT:       ld      A,(DE)          ; load data from RAM
 293+ 05AE ED 79                        out     (C),A           ; and send to VRAM
 294+ 05B0 13                           inc     DE              ; next byte into RAM
 295+ 05B1 23                           inc     HL              ; next byte into VRAM (used in future iterations)
 296+ 05B2 10 F9                        djnz    SNDLOGPT        ; repeat 8 times
 297+ 05B4 D1                           pop     DE
 298+ 05B5 C1                           pop     BC              ; retrieve BC & DE
 299+ 05B6 C9                           ret                     ; return to caller
 300+ 05B7              CLRTABLE:       equ $
 301+ 05B7 18 1B 13 14                  defb    $18,$1B,$13,$14,$1D ; colors of background bands of the logo
 301+ 05BB 1D
 302+ 05BC
 303+ 05BC
 304+ 05BC              ; while showing the logo, check if special key (CTRL) is being pressed
 305+ 05BC              ; if yes, then disable DOS functions recovering RAM
 306+ 05BC F5           CHKSPCK:        push    AF
 307+ 05BD 3E FE                        ld      A,%11111110     ; select CTRL row
 308+ 05BF CD 2D 0D                     call    READKBLN        ; read row
 309+ 05C2 CB 57                        bit     2,A             ; test if CTRL key is pressed
 310+ 05C4 20 04                        jr      NZ,LVCKSPLK     ; no, leave
 311+ 05C6 AF                           xor     A               ; yes, so...
 312+ 05C7 32 67 53                     ld      (DOS_EN),A      ; ...disable DOS
 313+ 05CA F1           LVCKSPLK:       pop     AF
 314+ 05CB C9                           ret
 315+ 05CC
 316+ 05CC
 317+ 05CC              ; empty video buffer
 318+ 05CC 3A 14 53     EMPTYVIDBUF:    ld      A,(SCR_MODE)    ; check screen mode
 319+ 05CF FE 02                        cp      $02             ; is it G2 mode?
 320+ 05D1 CA F4 05                     jp      Z,EMPTYG2       ; yes, jump over
 321+ 05D4 FE 03                        cp      $03             ; is it MC mode?
 322+ 05D6 CA 24 06                     jp      Z,EMPTYMC       ; yes, jump over
 323+ 05D9 3A 13 53                     ld      A,(SCR_SIZE_H)  ; load height of screen
 324+ 05DC 47                           ld      B,A             ; move rows into B
 325+ 05DD AF                           xor     A               ; filling char is $00
 326+ 05DE 2A 15 53                     ld      HL,(SCR_NAM_TB) ; load the name table address
 327+ 05E1 CD 5A 06                     call    SETVDPADRS      ; send address to VDP
 328+ 05E4 0D                           dec     C              ; VDP address for passing data
 329+ 05E5 5F           LDCOLSTOEMPTY:  ld      E,A             ; store filling char into E
 330+ 05E6 3A 12 53                     ld      A,(SCR_SIZE_W)  ; load # of cols to empty into A
 331+ 05E9 57                           ld      D,A             ; move A into D
 332+ 05EA 7B                           ld      A,E             ; recover filling char
 333+ 05EB ED 79        RPTEMPTYBUF:    out     (C),A           ; write empty byte into VRAM
 334+ 05ED 00                           nop
 335+ 05EE 15                           dec     D               ; decr. D
 336+ 05EF 20 FA                        jr      NZ,RPTEMPTYBUF  ; repeat for the # of cols
 337+ 05F1 10 F2                        djnz    LDCOLSTOEMPTY   ; repeat for the # of rows
 338+ 05F3 C9                           ret                     ; return to caller
 339+ 05F4 2A 15 53     EMPTYG2:        ld      HL,(SCR_NAM_TB) ; yes, additional setup for G2 - load G2 name table address (usually $1800)
 340+ 05F7 CD 48 06                     call    SETNAMETABLE    ; set name table
 341+ 05FA 21 00 00                     ld      HL,$0000        ; set pattern table
 342+ 05FD CD 5A 06                     call    SETVDPADRS      ; send address to VDP
 343+ 0600 AF                           xor     A               ; empty pattern
 344+ 0601 16 18                        ld      D,$18           ; 6144 ($1800) cell to clean, 24 pages ($18)
 345+ 0603 47                           ld      B,A             ; 256 bytes for page
 346+ 0604 0D                           dec     C              ; VDP data mode
 347+ 0605 ED 79        CLRG2PTNTBL:    out     (C),A           ; clear pattern
 348+ 0607 00                           nop                     ; little delay
 349+ 0608 00                           nop
 350+ 0609 10 FA                        djnz    CLRG2PTNTBL     ; repeat for 1 page
 351+ 060B 15                           dec     D               ; next page
 352+ 060C 20 F7                        jr      NZ,CLRG2PTNTBL  ; repeat
 353+ 060E 21 00 20                     ld      HL,$2000        ; load the color table address
 354+ 0611 CD 5A 06                     call    SETVDPADRS      ; send address to VDP
 355+ 0614 3A 20 53                     ld      A,(FRGNDCLR)    ; load foreground
 356+ 0617 87                           add     A,A
 357+ 0618 87                           add     A,A
 358+ 0619 87                           add     A,A
 359+ 061A 87                           add     A,A             ; move to high nibble
 360+ 061B 57                           ld      D,A             ; store into D
 361+ 061C 3A 21 53                     ld      A,(BKGNDCLR)    ; load background color
 362+ 061F B2                           or      D               ; combine with background color
 363+ 0620 16 18                        ld      D,$18           ; 6144 ($1800) cells to fill, so 24 pages ($18)
 364+ 0622 18 17                        jr      STARTEMPTY
 365+ 0624 21 00 08     EMPTYMC:        ld      HL,$0800        ; MC name table
 366+ 0627 CD 48 06                     call    SETNAMETABLE    ; set name table
 367+ 062A 21 00 00                     ld      HL,$0000        ; color table address
 368+ 062D CD 5A 06                     call    SETVDPADRS      ; send address to VDP
 369+ 0630 3A 21 53                     ld      A,(BKGNDCLR)    ; load background
 370+ 0633 57                           ld      D,A             ; store into D
 371+ 0634 87                           add     A,A
 372+ 0635 87                           add     A,A
 373+ 0636 87                           add     A,A
 374+ 0637 87                           add     A,A             ; move to high nibble
 375+ 0638 B2                           or      D               ; set background color for high and low nibble
 376+ 0639 16 08                        ld      D,$08           ; 2048 ($0800) cells to fill, so 8 pages ($08)
 377+ 063B 0D           STARTEMPTY:     dec     C              ; VDP address for passing data
 378+ 063C 06 00                        ld      B,$00           ; 256 bytes each page ($00=256)
 379+ 063E ED 79        SNDCLRSET:      out     (C),A           ; send color setting
 380+ 0640 00                           nop                     ; wait a while
 381+ 0641 00                           nop
 382+ 0642 10 FA                        djnz    SNDCLRSET       ; repeat for 1 page
 383+ 0644 15                           dec     D               ; have we filled all the pages?
 384+ 0645 20 F7                        jr      NZ,SNDCLRSET    ; no, repeat
 385+ 0647 C9                           ret                     ; return to caller
 386+ 0648
 387+ 0648              ; set name table for G2 mode (patterns from $00 to $FF for each of the 3 areas of the screen)
 388+ 0648 CD 5A 06     SETNAMETABLE:   call    SETVDPADRS      ; send address to VDP
 389+ 064B 0D                           dec     C              ; VDP address for passing data
 390+ 064C 16 03                        ld      D,$03           ; 3 pages to fill into VRAM (768 cells)
 391+ 064E AF                           xor     A               ; starting char name #0 (chars go from 0 to 255)
 392+ 064F 47                           ld      B,A             ; reset B
 393+ 0650 ED 79        RPTFLL1:        out     (C),A           ; send name to VRAM
 394+ 0652 00                           nop
 395+ 0653 3C                           inc     A               ; increment # of name
 396+ 0654 10 FA                        djnz    RPTFLL1         ; repeat for 256 cells (1 page)
 397+ 0656 15                           dec     D               ; did we fill all the pages?
 398+ 0657 20 F7                        jr      NZ,RPTFLL1      ; no, continue
 399+ 0659 C9                           ret                     ; return to caller
 400+ 065A
 401+ 065A              ; set an address into VRAM: address is in HL - HL is changed after it
 402+ 065A 0E 31        SETVDPADRS:     ld      C,VDP_SET       ; VDP address mode
 403+ 065C CB F4                        set     6,H             ; set bit #6 of address, to write to VRAM
 404+ 065E ED 69                        out     (C),L           ; send low and...
 405+ 0660 ED 61                        out     (C),H           ; ...high byte of the first cell
 406+ 0662 C9                           ret                     ; return to caller
 407+ 0663
 408+ 0663              ; clear the video buffer and position the cursor at 0,0
 409+ 0663 CD CC 05     CLEARVIDBUF:    call    EMPTYVIDBUF     ; clear video buffer
 410+ 0666 AF                           xor     A               ; reset A
 411+ 0667 32 17 53                     ld      (SCR_CURS_X),A  ; cursor X to 0
 412+ 066A 32 18 53                     ld      (SCR_CURS_Y),A  ; cursor Y to 0
 413+ 066D C3 B6 06                     jp      POS_CURSOR      ; position cursor & return to caller
 414+ 0670
 415+ 0670              ; HOME: position the cursor at coords. 0,0
 416+ 0670 AF           ATHOME:         xor     A               ; position cursor at 0,0 by storing...
 417+ 0671 32 1A 53                     ld      (SCR_CUR_NY),A  ; ...new Y...
 418+ 0674 32 19 53                     ld      (SCR_CUR_NX),A  ; ...and new X
 419+ 0677 C3 C0 06                     jp      MOVCRS          ; move cursor to new location & return to caller
 420+ 067A
 421+ 067A              ; load the char or byte at the VRAM position set by HL
 422+ 067A              ; value is returned into A
 423+ 067A C5           READ_VIDEO_LOC: push    BC              ; store BC
 424+ 067B 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 425+ 067D 44                           ld      B,H
 426+ 067E CB B8                        res     7,B
 427+ 0680 CB B0                        res     6,B
 428+ 0682 ED 69                        out     (C),L           ; low byte then...
 429+ 0684 ED 41                        out     (C),B           ; high byte
 430+ 0686 0D                           dec     C              ; VDP data mode
 431+ 0687 00                           nop               ; added to compensate shorter instruction
 432+ 0688 00                           nop                     ; wait...
 433+ 0689 00                           nop                     ; ...a while
 434+ 068A 00                           nop
 435+ 068B ED 78                        in      A,(C)           ; read byte at current VRAM location
 436+ 068D C1                           pop     BC              ; restore BC
 437+ 068E C9                           ret                     ; return to caller
 438+ 068F
 439+ 068F              ; write a byte at the VRAM position pointed by HL
 440+ 068F              ; value is in A
 441+ 068F C5           WRITE_VIDEO_LOC:push    BC              ; store BC
 442+ 0690 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 443+ 0692 44                           ld      B,H             ; copy H into B
 444+ 0693 CB B8                        res     7,B
 445+ 0695 CB F0                        set     6,B             ; write to VRAM
 446+ 0697 ED 69                        out     (C),L           ; low byte then...
 447+ 0699 ED 41                        out     (C),B           ; high byte of VRAM address
 448+ 069B 0D                           dec     C              ; VDP data mode
 449+ 069C 00                           nop               ; added to compensate shorter instruction
 450+ 069D 00                           nop                     ; wait...
 451+ 069E 00                           nop                     ; ...a while
 452+ 069F 00                           nop
 453+ 06A0 ED 79                        out     (C),A           ; write byte into VRAM
 454+ 06A2 C1                           pop     BC              ; restore BC
 455+ 06A3 C9                           ret                     ; return to caller
 456+ 06A4
 457+ 06A4              ; write a value into a specific VDP register
 458+ 06A4              ; value is in E, register is in A
 459+ 06A4 C5           WRITE_VREG:     push    BC              ; store BC
 460+ 06A5 C6 80                        add     A,$80           ; set VDP to write to registers
 461+ 06A7 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 462+ 06A9 ED 59                        out     (C),E           ; send data to VDP
 463+ 06AB ED 79                        out     (C),A           ; select the destination register
 464+ 06AD C1                           pop     BC              ; restore BC
 465+ 06AE C9                           ret                     ; return to caller
 466+ 06AF
 467+ 06AF              ; read VDP status register and return value into A
 468+ 06AF C5           READ_VSTAT:     push    BC              ; store BC
 469+ 06B0 0E 31                        ld      C,VDP_SET       ; VDP register access
 470+ 06B2 ED 78                        in      A,(C)           ; read status register
 471+ 06B4 C1                           pop     BC              ; restore BC
 472+ 06B5 C9                           ret                     ; return to caller
 473+ 06B6
 474+ 06B6              ; position the cursor at the current coordinates, preserving underlying char
 475+ 06B6 CD F9 06     POS_CURSOR:     call    LOAD_CRSR_POS   ; load the VRAM address of cursor into HL
 476+ 06B9 CD 7A 06                     call    READ_VIDEO_LOC  ; load the current char at the cursor position (return in A)
 477+ 06BC 32 1B 53                     ld      (SCR_ORG_CHR),A ; store the current char
 478+ 06BF C9                           ret
 479+ 06C0
 480+ 06C0              ; move cursor to new X,Y coordinates
 481+ 06C0 CD F0 06     MOVCRS:         call    RSTCHRCRS       ; restore the char in the current cursor position
 482+ 06C3 CD DB 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 483+ 06C6 CD B6 06     MOVSHOWCRS:     call    POS_CURSOR      ; position cursor into new location
 484+ 06C9 3A 1C 53                     ld      A,(CRSR_STATE)  ; load status of cursor
 485+ 06CC A7                           and     A               ; is cursor off?
 486+ 06CD C8                           ret     Z               ; yes, return
 487+ 06CE 3A 1D 53                     ld      A,(LSTCSRSTA)   ; it's visible, so...
 488+ 06D1 F6 20                        or      $20             ; ...set cursor on
 489+ 06D3 32 1D 53                     ld      (LSTCSRSTA),A   ; store the last cursor state
 490+ 06D6 3E FF                        ld      A,$FF           ; BTW, set cursor visible after moved it
 491+ 06D8 C3 8F 06                     jp      WRITE_VIDEO_LOC ; write into video cell
 492+ 06DB
 493+ 06DB
 494+ 06DB              ; set new cursor's coordinates
 495+ 06DB 3A 19 53     NEWCRSRCOORD:   ld      A,(SCR_CUR_NX)  ; load new X
 496+ 06DE 32 17 53                     ld      (SCR_CURS_X),A  ; write new X
 497+ 06E1 3A 1A 53                     ld      A,(SCR_CUR_NY)  ; load new Y
 498+ 06E4 32 18 53                     ld      (SCR_CURS_Y),A  ; write new Y
 499+ 06E7 3E FF                        ld      A,$FF           ; delete new values
 500+ 06E9 32 19 53                     ld      (SCR_CUR_NX),A  ; of X
 501+ 06EC 32 1A 53                     ld      (SCR_CUR_NY),A  ; and Y
 502+ 06EF C9                           ret
 503+ 06F0
 504+ 06F0              ; recover char under the cursor and prints it onto the screen
 505+ 06F0 CD F9 06     RSTCHRCRS:      call    LOAD_CRSR_POS   ; recover old cursor position
 506+ 06F3 3A 1B 53                     ld      A,(SCR_ORG_CHR) ; recover old char
 507+ 06F6 C3 8F 06                     jp      WRITE_VIDEO_LOC ; write char into VRAM & return
 508+ 06F9
 509+ 06F9              ; retrieve cursor position from either current coordinates or next place
 510+ 06F9              ; return address position into HL
 511+ 06F9 3A 18 53     LOAD_CRSR_POS:  ld      A,(SCR_CURS_Y)  ; load cursor Y
 512+ 06FC 6F                           ld      L,A             ; move it into reg.L
 513+ 06FD AF                           xor     A               ; reset A
 514+ 06FE 67                           ld      H,A             ; reset H
 515+ 06FF 47                           ld      B,A             ; reset B
 516+ 0700 29                           add     HL,HL           ; create offset (each address is 2-bytes long so we need to double HL)
 517+ 0701 11 89 0A                     ld      DE,POS_TB_CRS_40; load position table address of cursor for 40 cols
 518+ 0704 3A 12 53                     ld      A,(SCR_SIZE_W)  ; load screen width
 519+ 0707 FE 28                        cp      $28             ; is it 40 cols?
 520+ 0709 28 03                        jr      Z,CONT_POS_CURS ; yes, jump over
 521+ 070B 11 59 0A                     ld      DE,POS_TB_CRS_32; no, load position table address of cursor for 32 cols
 522+ 070E 19           CONT_POS_CURS:  add     HL,DE           ; the correct starting address of the required row is now into HL
 523+ 070F 5E                           ld      E,(HL)          ; load starting address of the required row into DE
 524+ 0710 23                           inc     HL
 525+ 0711 56                           ld      D,(HL)
 526+ 0712 2A 15 53                     ld      HL,(SCR_NAM_TB) ; load starting address of name table
 527+ 0715 19                           add     HL,DE           ; starting address of the current row into name table
 528+ 0716 3A 17 53                     ld      A,(SCR_CURS_X)  ; load cursor X
 529+ 0719 4F                           ld      C,A             ; transfer A into C
 530+ 071A 09                           add     HL,BC           ; add X offset: now HL contains the address of the current cursor position
 531+ 071B C9                           ret
 532+ 071C
 533+ 071C              ; find X,Y coordinates of a screen address pointed in VRAM by HL
 534+ 071C              ; return them into L,A for X,Y
 535+ 071C D5           HL2XY:          push    DE              ; store DE
 536+ 071D ED 5B 15 53                  ld      DE,(SCR_NAM_TB) ; load starting address of name table into DE
 537+ 0721 AF                           xor     A               ; clear Carry
 538+ 0722 ED 52                        sbc     HL,DE           ; find position relative to screen (from 0,0)
 539+ 0724 D1                           pop     DE
 540+ 0725 3A 12 53                     ld      A,(SCR_SIZE_W)  ; load screen width
 541+ 0728 4F                           ld      C,A             ; move it into C
 542+ 0729 CD 1D 40                     call    DIV_16_8        ; divide position by C: return Y into L and X into A
 543+ 072C C9                           ret                     ; return to caller
 544+ 072D
 545+ 072D              ;-------------------------------------------------------------------------------
 546+ 072D              ; char table for jumps
 547+ 072D 19           CHRTBL:         defb    HOME
 548+ 072E 70 06                        defw    ATHOME          ; move the cursor to 0,0
 549+ 0730
 550+ 0730 0C                           defb    CS
 551+ 0731 63 06                        defw    CLEARVIDBUF     ; clear video buffer and position cursor at 0,0
 552+ 0733
 553+ 0733 0D                           defb    CR
 554+ 0734 AC 09                        defw    CRGRETURN       ; go to the beginning of the next line
 555+ 0736
 556+ 0736 08                           defb    BKSP
 557+ 0737 1A 08                        defw    BACKSPACE       ; move cursor left 1 position
 558+ 0739
 559+ 0739 1C                           defb    CRSLFT
 560+ 073A 5D 08                        defw    CURSORLEFT      ; move cursor left
 561+ 073C
 562+ 073C 1E                           defb    CRSUP
 563+ 073D A9 08                        defw    CURSORUP        ; move cursor up
 564+ 073F
 565+ 073F 1D                           defb    CRSRGT
 566+ 0740 C2 08                        defw    CURSORRIGHT     ; move cursor right
 567+ 0742
 568+ 0742 1F                           defb    CRSDN
 569+ 0743 F7 08                        defw    CURSORDOWN      ; move cursor up
 570+ 0745
 571+ 0745 1A                           defb    INSRT
 572+ 0746 D8 07                        defw    INSERTKEY       ; insert a space
 573+ 0748
 574+ 0748 0A                           defb    LF
 575+ 0749 B4 07                        defw    PLACEHOLDER     ; CURRENTLY WE DON'T PRINT LINE FEED
 576+ 074B
 577+ 074B              ; send current char to video buffer
 578+ 074B F5           CHAR2VID:       push    AF              ; store AF
 579+ 074C C5                           push    BC              ; store BC
 580+ 074D D5                           push    DE              ; store DE
 581+ 074E E5                           push    HL              ; store HL
 582+ 074F 3A 1C 53                     ld      A,(CRSR_STATE)  ; store cursor state...
 583+ 0752 F5                           push    AF              ; into stack
 584+ 0753 CD 2C 09                     call    CURSOR_OFF      ; cursor off
 585+ 0756 3A 1F 53                     ld      A,(CHR4VID)     ; recover char
 586+ 0759 06 0A                        ld      B,$0A           ; 10 chars to check
 587+ 075B 21 2D 07                     ld      HL,CHRTBL       ; address of key table
 588+ 075E BE           RPTCPCK:        cp      (HL)            ; compare with char
 589+ 075F 23                           inc     HL              ; beginning of sub-routine address
 590+ 0760 20 09                        jr      NZ,NXTCPCK      ; different, go to next char
 591+ 0762 5E                           ld      E,(HL)          ; load addres into DE
 592+ 0763 23                           inc     HL
 593+ 0764 56                           ld      D,(HL)
 594+ 0765 EB                           ex      DE,HL           ; move user routine's address into HL
 595+ 0766 11 A7 07                     ld      DE,EXITCHAR2VID ; set point of return after the user routine
 596+ 0769 D5                           push    DE              ; store into stack
 597+ 076A E9                           jp      (HL)            ; call user routine - then, the CPU will return (jump) to EXITCHAR2VID
 598+ 076B 23           NXTCPCK:        inc     HL              ; jump over 2 cells...
 599+ 076C 23                           inc     HL              ; ...to the next char code
 600+ 076D 10 EF                        djnz    RPTCPCK         ; repeat
 601+ 076F                              ; it'a not a special char, just print it
 602+ 076F CD F9 06                     call    LOAD_CRSR_POS   ; recover position of cursor
 603+ 0772 3A 1F 53                     ld      A,(CHR4VID)     ; recover char to print
 604+ 0775 CD 8F 06                     call    WRITE_VIDEO_LOC ; write A into VRAM at (HL)
 605+ 0778 3A 18 53                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 606+ 077B 5F                           ld      E,A             ; store cursor Y into E
 607+ 077C 3A 17 53                     ld      A,(SCR_CURS_X)  ; load cursor X
 608+ 077F 3C                           inc     A               ; move 1 step to right
 609+ 0780 21 12 53                     ld      HL,SCR_SIZE_W   ; cell that keeps the width of screen
 610+ 0783 BE                           cp      (HL)            ; have we reached the most right position?
 611+ 0784 20 0F                        jr      NZ,SETCSRCOORDS ; no, go over
 612+ 0786 1C                           inc     E               ; yes, increment cursor Y (go to next line)
 613+ 0787 7B                           ld      A,E             ; move cursor Y into A
 614+ 0788 21 13 53                     ld      HL,SCR_SIZE_H   ; cell that keeps the height of screen
 615+ 078B BE                           cp      (HL)            ; have we reached the bottom of the screen?
 616+ 078C 20 06                        jr      NZ,SETCRSRY     ; no, jump over
 617+ 078E D5                           push    DE
 618+ 078F CD 33 09                     call    SCROLLUP        ; scroll screen up
 619+ 0792 D1                           pop     DE
 620+ 0793 1D                           dec     E               ; decrement 1 row, to set cursor Y on the last line
 621+ 0794 AF           SETCRSRY:       xor     A               ; then set cursor X to 0 (go to beginning of line)
 622+ 0795 32 17 53     SETCSRCOORDS:   ld      (SCR_CURS_X),A  ; store current cursor X
 623+ 0798 7B                           ld      A,E             ; recover Y
 624+ 0799 32 18 53                     ld      (SCR_CURS_Y),A  ; store current cursor Y
 625+ 079C CD B6 06                     call    POS_CURSOR      ; position cursor into new location
 626+ 079F 3A 02 53                     ld      A,(TMRCNT)      ; load status of cursor flashing
 627+ 07A2 E6 20                        and     $20             ; check cursor state
 628+ 07A4 32 1D 53                     ld      (LSTCSRSTA),A   ; store the last cursor state
 629+ 07A7 AF           EXITCHAR2VID:   xor     A               ; reset char
 630+ 07A8 32 1F 53                     ld      (CHR4VID),A     ; to be sent to screen
 631+ 07AB F1                           pop     AF              ; recover cursor state
 632+ 07AC A7                           and     A               ; was it off (A=0)?
 633+ 07AD C4 17 09                     call    NZ,CURSOR_ON    ; no, set cursor on
 634+ 07B0 E1                           pop     HL              ; restore HL
 635+ 07B1 D1                           pop     DE              ; restore DE
 636+ 07B2 C1                           pop     BC              ; restore BC
 637+ 07B3 F1                           pop     AF              ; restore AF
 638+ 07B4 C9           PLACEHOLDER:    ret                     ; return to caller
 639+ 07B5
 640+ 07B5              ; flash the cursor at the current position
 641+ 07B5              ; (this sub-routine is called by CH3 timer ISR)
 642+ 07B5 3A 1C 53     FLASHCURSOR:    ld      A,(CRSR_STATE)  ; now, check the cursor
 643+ 07B8 A7                           and     A               ; cursor off (A=0)?
 644+ 07B9 C8                           ret     Z               ; yes, return
 645+ 07BA 3A 02 53                     ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
 646+ 07BD E6 20                        and     $20             ; check if it's time to flash the cursor (check bit #6)
 647+ 07BF 21 1D 53                     ld      HL,LSTCSRSTA    ; load address of cell that stores the last cursor state
 648+ 07C2 BE                           cp      (HL)            ; compare current state with last state
 649+ 07C3 C8                           ret     Z               ; same state, no change required - exit
 650+ 07C4 77                           ld      (HL),A          ; save new state
 651+ 07C5 F5                           push    AF              ; store A (keep state for later use)
 652+ 07C6 CD F9 06                     call    LOAD_CRSR_POS   ; load current cursor position into HL
 653+ 07C9 F1                           pop     AF              ; recover current state
 654+ 07CA 06 FF                        ld      B,$FF           ; cursor char
 655+ 07CC FE 20                        cp      $20             ; is the cursor on video (A == $20)?
 656+ 07CE 28 04                        jr      Z,PUTCRSCHR     ; yes, jump over
 657+ 07D0 3A 1B 53                     ld      A,(SCR_ORG_CHR) ; no, load the original char
 658+ 07D3 47                           ld      B,A             ; move char into B
 659+ 07D4 78           PUTCRSCHR:      ld      A,B             ; recover char from B
 660+ 07D5 C3 8F 06                     jp      WRITE_VIDEO_LOC ; print cursor/char at the current position & return
 661+ 07D8
 662+ 07D8
 663+ 07D8              ; insert an empty space at the current position of the cursor, moving the following text
 664+ 07D8              ; 1 cell straight
 665+ 07D8 CD F0 06     INSERTKEY:      call    RSTCHRCRS       ; restore char under the cursor
 666+ 07DB CD F9 06                     call    LOAD_CRSR_POS   ; retrieve address of cursor cell
 667+ 07DE 22 22 53                     ld      (CUR_POS),HL    ; store it
 668+ 07E1 CD 33 0A                     call    ENDOFLN         ; find address of first free cell after the end of the text from the current cursor position - address into HL -
 669+ 07E4                                                      ; DE is the address of the bottom right cell of the screen
 670+ 07E4 22 26 53                     ld      (ENDTXT),HL     ; store it
 671+ 07E7 ED 4B 22 53                  ld      BC,(CUR_POS)    ; load starting address
 672+ 07EB AF                           xor     A
 673+ 07EC ED 42                        sbc     HL,BC           ; how many positions to move?
 674+ 07EE CA C6 06                     jp      Z,MOVSHOWCRS    ; none - leave and re-place cursor
 675+ 07F1 44 4D                        ld      BC,HL           ; number of chars to scroll into BC
 676+ 07F3 2A 26 53                     ld      HL,(ENDTXT)     ; load address of the end of text
 677+ 07F6 2B           CHKHL:          dec     HL              ; decrement to find the address of the char to move
 678+ 07F7 E5                           push    HL
 679+ 07F8 CD DE 3F                     call    CMP16           ; is it the last cell (bottom right) of screen?
 680+ 07FB E1                           pop     HL
 681+ 07FC D2 07 08                     jp      NC,NXTINST      ; yes, so jump over - nothing to do
 682+ 07FF CD 7A 06                     call    READ_VIDEO_LOC  ; no, so read current char
 683+ 0802 23                           inc     HL              ; next cell
 684+ 0803 CD 8F 06                     call    WRITE_VIDEO_LOC ; write into new position
 685+ 0806 2B                           dec     HL              ; decrement to old position
 686+ 0807 0B           NXTINST:        dec     BC              ; decrement number of chars to move
 687+ 0808 79                           ld      A,C
 688+ 0809 B0                           or      B               ; finished?
 689+ 080A 20 EA                        jr      NZ,CHKHL        ; no, repeat
 690+ 080C 3E 20        ENDINSRT:       ld      A,SPC           ; load SPACE character
 691+ 080E 2A 22 53                     ld      HL,(CUR_POS)    ; get cursor position
 692+ 0811 32 1B 53                     ld      (SCR_ORG_CHR),A ; reset original char under the cursor
 693+ 0814 CD 8F 06                     call    WRITE_VIDEO_LOC ; empty current video location
 694+ 0817 C3 C6 06                     jp      MOVSHOWCRS      ; re-place cursor
 695+ 081A
 696+ 081A              ; delete the char at the left of the cursor
 697+ 081A CD F0 06     BACKSPACE:      call    RSTCHRCRS       ; restore char
 698+ 081D 2A 15 53                     ld      HL,(SCR_NAM_TB) ; address of origin of screen (location 0,0)
 699+ 0820 44 4D                        ld      BC,HL           ; store into BC
 700+ 0822 CD F9 06                     call    LOAD_CRSR_POS   ; load address of current cursor pos.
 701+ 0825 54 5D                        ld      DE,HL           ; copy into DE
 702+ 0827 AF                           xor     A               ; reset Carry
 703+ 0828 ED 42                        sbc     HL,BC           ; check how many chars between
 704+ 082A CA 54 08                     jp      Z,LVBKSP        ; none, so we are at the top left corner
 705+ 082D ED 53 22 53                  ld      (CUR_POS),DE    ; store current cursor position
 706+ 0831 CD 33 0A                     call    ENDOFLN         ; check end of text
 707+ 0834 ED 5B 22 53                  ld      DE,(CUR_POS)    ; retrieve cursor position
 708+ 0838 AF                           xor     A               ; reset Carry
 709+ 0839 ED 52                        sbc     HL,DE           ; check if none follows
 710+ 083B CA 54 08                     jp      Z,LVBKSP        ; no chars follow, so simply move the cursor
 711+ 083E 44 4D                        ld      BC,HL           ; save numbers of chars to move
 712+ 0840 EB                           ex      DE,HL           ; copy starting position into HL
 713+ 0841 CD 7A 06     MVBKSP:         call    READ_VIDEO_LOC  ; read char
 714+ 0844 2B                           dec     HL              ; 1 position to left
 715+ 0845 CD 8F 06                     call    WRITE_VIDEO_LOC ; write char
 716+ 0848 23                           inc     HL              ; goto next char to copy (2 steps to right)
 717+ 0849 23                           inc     HL
 718+ 084A 0B                           dec     BC              ; decrement # of chars
 719+ 084B 79                           ld      A,C
 720+ 084C B0                           or      B               ; 0 chars?
 721+ 084D 20 F2                        jr      NZ,MVBKSP       ; not finished, continue
 722+ 084F 2B                           dec     HL
 723+ 0850 AF                           xor     A
 724+ 0851 CD 8F 06                     call    WRITE_VIDEO_LOC ; reset last char
 725+ 0854 CD 86 08     LVBKSP:         call    MVCRS2LFT       ; move cursor to new position
 726+ 0857 CD DB 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 727+ 085A C3 C6 06                     jp      MOVSHOWCRS      ; move cursor to the new location and set it ON
 728+ 085D
 729+ 085D
 730+ 085D              ; move cursor to left
 731+ 085D F5           CURSORLEFT:     push    AF              ; store A
 732+ 085E 3A 17 53                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 733+ 0861 A7                           and     A               ; is it at the most left of the screen (X=0)?
 734+ 0862 28 0C                        jr      Z,CHCKYPOS      ; yes, check Y position
 735+ 0864 3D                           dec     A               ; no, decrement X
 736+ 0865 32 19 53                     ld      (SCR_CUR_NX),A  ; store new X
 737+ 0868 3A 18 53                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 738+ 086B 32 1A 53                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 739+ 086E 18 11                        jr      CONTCRSLFT      ; go on moving cursor
 740+ 0870 3A 18 53     CHCKYPOS:       ld      A,(SCR_CURS_Y)  ; load cursor Y
 741+ 0873 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 742+ 0874 28 0E                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 743+ 0876 3D                           dec     A               ; no, decrement Y
 744+ 0877 32 1A 53                     ld      (SCR_CUR_NY),A  ; store new Y
 745+ 087A 3A 12 53                     ld      A,(SCR_SIZE_W)  ; load current screen width
 746+ 087D 3D                           dec     A               ; cursor to the most right position (width-0)
 747+ 087E 32 19 53                     ld      (SCR_CUR_NX),A  ; set new cursor X
 748+ 0881 CD C0 06     CONTCRSLFT:     call    MOVCRS          ; move cursor into new position
 749+ 0884 F1           EXITCURSORLEFT: pop     AF              ; restore A
 750+ 0885 C9                           ret                     ; return to caller
 751+ 0886
 752+ 0886              ; move cursor 1 position to the left
 753+ 0886 3A 17 53     MVCRS2LFT:      ld      A,(SCR_CURS_X)  ; load cursor X into A
 754+ 0889 A7                           and     A               ; is it at the most left of the screen (X=0)?
 755+ 088A 28 0B                        jr      Z,CHKYPOS       ; yes, check Y position
 756+ 088C 3D                           dec     A               ; no, decrement X
 757+ 088D 32 19 53                     ld      (SCR_CUR_NX),A  ; store new X
 758+ 0890 3A 18 53                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 759+ 0893 32 1A 53                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 760+ 0896 C9                           ret                     ; go on moving cursor
 761+ 0897 3A 18 53     CHKYPOS:        ld      A,(SCR_CURS_Y)  ; load cursor Y
 762+ 089A A7                           and     A               ; is it at the most top of the screen (Y=0)?
 763+ 089B 28 E7                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 764+ 089D 3D                           dec     A               ; no, decrement Y
 765+ 089E 32 1A 53                     ld      (SCR_CUR_NY),A  ; store new Y
 766+ 08A1 3A 12 53                     ld      A,(SCR_SIZE_W)  ; load current screen width
 767+ 08A4 3D                           dec     A               ; cursor to the most right position (width-1)
 768+ 08A5 32 19 53                     ld      (SCR_CUR_NX),A  ; set new cursor X
 769+ 08A8 C9                           ret                     ; return to caller
 770+ 08A9
 771+ 08A9              ; move cursor up
 772+ 08A9 F5           CURSORUP:       push    AF              ; store A
 773+ 08AA 3A 18 53                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 774+ 08AD A7                           and     A               ; is it at the most top of the screen (Y=0)?
 775+ 08AE 28 10                        jr      Z,EXITCURSORUP  ; yes, exit doing nothing
 776+ 08B0 3D                           dec     A               ; no, decrement Y
 777+ 08B1 32 1A 53                     ld      (SCR_CUR_NY),A  ; store new Y
 778+ 08B4 3A 17 53                     ld      A,(SCR_CURS_X)  ; load current cursor X
 779+ 08B7 32 19 53                     ld      (SCR_CUR_NX),A  ; set new cursor X
 780+ 08BA CD F0 06                     call    RSTCHRCRS       ; restore char under the cursor and print it
 781+ 08BD CD C0 06                     call    MOVCRS          ; move cursor into new position
 782+ 08C0 F1           EXITCURSORUP:   pop     AF              ; restore A
 783+ 08C1 C9                           ret                     ; return to caller
 784+ 08C2
 785+ 08C2
 786+ 08C2              ; move cursor to right
 787+ 08C2 F5           CURSORRIGHT:    push    AF              ; store A
 788+ 08C3 C5                           push    BC              ; store B
 789+ 08C4 3A 12 53                     ld      A,(SCR_SIZE_W)  ; load current screen width (in text modes it's 32 or 40)
 790+ 08C7 3D                           dec     A               ; decrement it (most right can only be 31 or 39)
 791+ 08C8 47                           ld      B,A             ; move A into B
 792+ 08C9 3A 17 53                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 793+ 08CC B8                           cp      B               ; is cursor at the most right position on the screen?
 794+ 08CD 30 0C                        jr      NC,CHCKYPOS2    ; yes, so jump to check Y position
 795+ 08CF 3C                           inc     A               ; no, so increment X
 796+ 08D0 32 19 53                     ld      (SCR_CUR_NX),A  ; store new X
 797+ 08D3 3A 18 53                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 798+ 08D6 32 1A 53                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 799+ 08D9 18 13                        jr      CONTCRSRGT      ; go on moving cursor
 800+ 08DB 3A 13 53     CHCKYPOS2:      ld      A,(SCR_SIZE_H)  ; load screen height
 801+ 08DE 3D                           dec     A               ; decrement it (last row can only be 23)
 802+ 08DF 47                           ld      B,A             ; move bottom into B
 803+ 08E0 3A 18 53                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 804+ 08E3 B8                           cp      B               ; is the cursor at the bottom of the screen?
 805+ 08E4 30 0E                        jr      NC,EXITCURSORRGHT; yes, exit doing nothing
 806+ 08E6 3C                           inc     A               ; no, increment Y
 807+ 08E7 32 1A 53                     ld      (SCR_CUR_NY),A  ; store new Y
 808+ 08EA AF                           xor     A               ; move cursor to top left
 809+ 08EB 32 19 53                     ld      (SCR_CUR_NX),A  ; store new X
 810+ 08EE CD F0 06     CONTCRSRGT:     call    RSTCHRCRS       ; restore char under the cursor and print it
 811+ 08F1 CD C0 06                     call    MOVCRS          ; move cursor into new position
 812+ 08F4 C1           EXITCURSORRGHT: pop     BC              ; retrieve BC
 813+ 08F5 F1                           pop     AF              ; restore A
 814+ 08F6 C9                           ret                     ; return to caller
 815+ 08F7
 816+ 08F7
 817+ 08F7              ; move cursor down
 818+ 08F7 F5           CURSORDOWN:     push    AF              ; store A
 819+ 08F8 C5                           push    BC              ; store B
 820+ 08F9 3A 13 53                     ld      A,(SCR_SIZE_H)  ; load current screen height (in text modes it's 24)
 821+ 08FC 3D                           dec     A               ; decrement it (positions can only vary between 0 and 23)
 822+ 08FD 47                           ld      B,A             ; move X into B
 823+ 08FE 3A 18 53                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 824+ 0901 B8                           cp      B               ; is current cursor position < 23?
 825+ 0902 30 10                        jr      NC,EXITCURSORDOWN; no, exit doing nothing
 826+ 0904 3C                           inc     A               ; yes, increment Y
 827+ 0905 32 1A 53                     ld      (SCR_CUR_NY),A  ; store new Y
 828+ 0908 3A 17 53                     ld      A,(SCR_CURS_X)  ; load current cursor X
 829+ 090B 32 19 53                     ld      (SCR_CUR_NX),A  ; set new cursor X
 830+ 090E CD F0 06                     call    RSTCHRCRS       ; restore char under the cursor and print it
 831+ 0911 CD C0 06                     call    MOVCRS          ; move cursor into new position
 832+ 0914 C1           EXITCURSORDOWN: pop     BC              ; retrieve BC
 833+ 0915 F1                           pop     AF              ; retrieve A
 834+ 0916 C9                           ret                     ; return to caller
 835+ 0917
 836+ 0917
 837+ 0917              ; set cursor on (visible on screen)
 838+ 0917 F5           CURSOR_ON:      push    AF              ; store AF
 839+ 0918 3A 1C 53                     ld      A,(CRSR_STATE)  ; load cursor state
 840+ 091B B7                           or      A               ; is it on?
 841+ 091C 20 0C                        jr      NZ,EXITCURSOR_ON; yes, so nothing to do
 842+ 091E 3A 13 53                     ld      A,(SCR_SIZE_H)  ; check the video mode
 843+ 0921 FE 30                        cp      $30             ; graphics 2 or 3 (if value>=48)?
 844+ 0923 30 05                        jr      NC,EXITCURSOR_ON; yes, so exit (no cursor in graphics 2 or 3)
 845+ 0925 3E 01                        ld      A,$01           ; cursor state ON
 846+ 0927 32 1C 53                     ld      (CRSR_STATE),A  ; set state
 847+ 092A F1           EXITCURSOR_ON:  pop     AF              ; restore AF
 848+ 092B C9                           ret                     ; return to caller
 849+ 092C
 850+ 092C              ; set cursor off (invisible on screen)
 851+ 092C F5           CURSOR_OFF:     push    AF              ; store AF
 852+ 092D AF                           xor     A               ; cursor state OFF
 853+ 092E 32 1C 53                     ld      (CRSR_STATE),A  ; set state
 854+ 0931 F1                           pop     AF              ; restore AF
 855+ 0932 C9                           ret
 856+ 0933
 857+ 0933              ; scroll the screen 1 row up
 858+ 0933 AF           SCROLLUP:       xor     A               ; reset A
 859+ 0934 57                           ld      D,A             ; reset D
 860+ 0935 32 1E 53                     ld      (PRNTVIDEO),A   ; no print on screen while scrolling
 861+ 0938 2A 15 53                     ld      HL,(SCR_NAM_TB) ; start address of the name table
 862+ 093B 22 52 53                     ld      (VIDTMP1),HL    ; store address of the destination row (1st row of the screen)
 863+ 093E 3A 12 53                     ld      A,(SCR_SIZE_W)  ; load the screen width
 864+ 0941 5F                           ld      E,A             ; move width into E
 865+ 0942 19                           add     HL,DE           ; HL now contains the address of the source row (2nd row of the screen)
 866+ 0943 22 54 53                     ld      (VIDTMP2),HL    ; store address of source row
 867+ 0946 3A 13 53                     ld      A,(SCR_SIZE_H)  ; load the screen height
 868+ 0949 3D                           dec     A               ; decrement the # of rows: now, A contains the # of rows to be moved
 869+ 094A 47                           ld      B,A             ; move # of rows into B
 870+ 094B 3A 12 53     SCROLLNXTRW:    ld      A,(SCR_SIZE_W)  ; (re)load the screen width
 871+ 094E 5F                           ld      E,A             ; move width into E
 872+ 094F 2A 54 53                     ld      HL,(VIDTMP2)    ; load source address
 873+ 0952 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 874+ 0954 ED 69                        out     (C),L           ; low byte of source
 875+ 0956 ED 61                        out     (C),H           ; high byte of source
 876+ 0958 21 2A 53                     ld      HL,VIDEOBUFF    ; load address of the first cell of the video buffer
 877+ 095B 0D                           dec     C              ; VDP data mode
 878+ 095C 00                           nop               ; added to compensate shorter instruction
 879+ 095D ED 78        LOADNEXTCOL:    in      A,(C)           ; load char
 880+ 095F 77                           ld      (HL),A          ; store char
 881+ 0960 23                           inc     HL              ; next cell of the buffer
 882+ 0961 1D                           dec     E               ; count the chars to be read
 883+ 0962 20 F9                        jr      NZ,LOADNEXTCOL  ; repeat until we read the entire row
 884+ 0964 3A 12 53                     ld      A,(SCR_SIZE_W)  ; reload the screen width
 885+ 0967 5F                           ld      E,A             ; move # of rows into E
 886+ 0968 16 00                        ld      D,$00           ; reset D
 887+ 096A 2A 52 53                     ld      HL,(VIDTMP1)    ; load address of destination row
 888+ 096D E5                           push    HL              ; store HL
 889+ 096E 2A 54 53                     ld      HL,(VIDTMP2)    ; current source will be..
 890+ 0971 22 52 53                     ld      (VIDTMP1),HL    ; ..new destination
 891+ 0974 19                           add     HL,DE           ; address of new
 892+ 0975 22 54 53                     ld      (VIDTMP2),HL    ; source row
 893+ 0978 E1                           pop     HL              ; restore address of current destination row
 894+ 0979 CB F4                        set     6,H             ; writing mode
 895+ 097B 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 896+ 097D ED 69                        out     (C),L           ; low byte
 897+ 097F ED 61                        out     (C),H           ; high byte of address
 898+ 0981 21 2A 53                     ld      HL,VIDEOBUFF    ; video buffer address
 899+ 0984 0D                           dec     C              ; VDP data mode
 900+ 0985 7E           WRITEBUF:       ld      A,(HL)          ; load char
 901+ 0986 ED 79                        out     (C),A           ; send char
 902+ 0988 23                           inc     HL              ; increment buffer index
 903+ 0989 1D                           dec     E               ; next row
 904+ 098A 20 F9                        jr      NZ,WRITEBUF     ; repeat until 0
 905+ 098C 10 BD                        djnz    SCROLLNXTRW     ; repeat for the entire screen
 906+ 098E 3A 12 53                     ld      A,(SCR_SIZE_W)  ; reload screen width
 907+ 0991 47                           ld      B,A             ; cells to empty into B
 908+ 0992 AF                           xor     A               ; null char
 909+ 0993 0E 31                        ld      C,VDP_SET       ; VDP set mode
 910+ 0995 2A 52 53                     ld      HL,(VIDTMP1)    ; load address of the last row
 911+ 0998 CB F4                        set     6,H             ; writing mode
 912+ 099A ED 69                        out     (C),L           ; low byte then..
 913+ 099C ED 61                        out     (C),H           ; high byte of address
 914+ 099E 0D                           dec     C              ; VDP data mode
 915+ 099F 00                           nop               ; delay
 916+ 09A0 ED 79        RPTEMPTYROW:    out     (C),A           ; empty cell
 917+ 09A2 00                           nop                     ; delay
 918+ 09A3 00                           nop
 919+ 09A4 10 FA                        djnz    RPTEMPTYROW     ; repeat until the last row has been cleaned
 920+ 09A6 3E 01                        ld      A,$01
 921+ 09A8 32 1E 53                     ld      (PRNTVIDEO),A   ; set print-on-video on
 922+ 09AB C9                           ret                     ; return to caller
 923+ 09AC
 924+ 09AC              ; carriage return: first, it looks for char $00 at the beginning of the line (look for the first null char),
 925+ 09AC              ; then it starts sendind every char it finds on the screen to the terminal buffer of the BASIC interpreter
 926+ 09AC              ; until another null char is found. Finally, move to the next line and position the cursor at the beginning
 927+ 09AC              ; of the row (equivalent to CR+LF), then gets back control to the screen editor to let it interpret the line
 928+ 09AC              CUR_POS         equ     TMPBFR1         ; cursor position
 929+ 09AC              SRTTXT          equ     TMPBFR2         ; start of text line
 930+ 09AC              ENDTXT          equ     TMPBFR3         ; end of text line
 931+ 09AC              CRGRETURN:      ; preliminary: disable cursor if on, and retrieve char under it
 932+ 09AC 3A 1C 53                     ld      A,(CRSR_STATE)  ; recover cursor state
 933+ 09AF 32 28 53                     ld      (TMPBFR4),A     ; store status
 934+ 09B2 A7                           and     A               ; is cursor on?
 935+ 09B3 C4 2C 09                     call    NZ,CURSOR_OFF   ; yes, so set cursor off
 936+ 09B6 CD F0 06                     call    RSTCHRCRS       ; restore char under it
 937+ 09B9                              ; first, check if cursor if off, so that we just interpret return as a new line command
 938+ 09B9 3A 5C 53                     ld      A,(KBDNPT)      ; check if input from keyboad
 939+ 09BC A7                           and     A               ; if 0, input is not from keyboard...
 940+ 09BD CA 12 0A                     jp      Z,PRNTRETURN    ; ...so just print a carriage return; otherwise, interpret the return
 941+ 09C0                              ; first part: look for the beginning of the text line on screen
 942+ 09C0 CD F9 06                     call    LOAD_CRSR_POS   ; load cursor position into HL
 943+ 09C3 22 22 53                     ld      (CUR_POS),HL    ; store it
 944+ 09C6 ED 5B 15 53                  ld      DE,(SCR_NAM_TB) ; load VRAM address of top-left cell of screen ("home")
 945+ 09CA E5           RPTNLLSRC:      push    HL
 946+ 09CB CD DE 3F                     call    CMP16           ; check if at "home"
 947+ 09CE E1                           pop     HL
 948+ 09CF CA DA 09                     jp      Z,CNTNULL       ; yes, exit because there is nothing before
 949+ 09D2 2B                           dec     HL              ; go 1 step back
 950+ 09D3 CD 7A 06                     call    READ_VIDEO_LOC  ; read char of current position
 951+ 09D6 A7                           and     A               ; is it $00 (null char)?
 952+ 09D7 20 F1                        jr      NZ,RPTNLLSRC    ; no, continue searching
 953+ 09D9 23                           inc     HL              ; move 1 step forward to go back to the last cell with something in
 954+ 09DA                              ; second part: look for the ending of the text on screen
 955+ 09DA 22 24 53     CNTNULL:        ld      (SRTTXT),HL     ; store beginning of text
 956+ 09DD CD 33 0A                     call    ENDOFLN         ; find end of text line looking at the end of chars after the cursor position
 957+ 09E0 22 26 53                     ld      (ENDTXT),HL     ; store ending of text line
 958+ 09E3 ED 5B 24 53                  ld      DE,(SRTTXT)     ; load beginning of text line
 959+ 09E7 A7                           and     A               ; clear Carry
 960+ 09E8 ED 52                        sbc     HL,DE           ; how many chars?
 961+ 09EA 28 26                        jr      Z,PRNTRETURN    ; no chars found (HL-DE=0), so just print return & leave
 962+ 09EC                              ;---    central part: send the text on the screen to the interpreter
 963+ 09EC 2A 24 53                     ld      HL,(SRTTXT)     ; load beginning of text line
 964+ 09EF ED 5B 26 53                  ld      DE,(ENDTXT)     ; load ending of text line
 965+ 09F3 CD 7A 06     SNDCHRTOBFR:    call    READ_VIDEO_LOC  ; read char
 966+ 09F6 E5                           push    HL
 967+ 09F7 CD FD 01                     call    CHARINTOBFR     ; send char to buffer
 968+ 09FA E1                           pop     HL
 969+ 09FB 23                           inc     HL              ; go to next char
 970+ 09FC E5                           push    HL              ; store HL
 971+ 09FD CD DE 3F                     call    CMP16           ; check if DE=HL (finish chars)
 972+ 0A00 E1                           pop     HL
 973+ 0A01 20 F0                        jr      NZ,SNDCHRTOBFR  ; no, repeat
 974+ 0A03 3E 0D                        ld      A,CR            ; yes, so now send carriage return
 975+ 0A05 CD FD 01                     call    CHARINTOBFR     ; send to buffer
 976+ 0A08 2A 26 53                     ld      HL,(ENDTXT)     ; recover address of last char of input text
 977+ 0A0B CD 1C 07                     call    HL2XY           ; retrieve X,Y from address
 978+ 0A0E 7D                           ld      A,L             ; move Y into A (we don't need X anymore)
 979+ 0A0F 32 18 53                     ld      (SCR_CURS_Y),A  ; store new Y
 980+ 0A12                              ;---    final part: go at the beginning of a new line on the screen
 981+ 0A12 AF           PRNTRETURN:     xor     A               ; move to col 0
 982+ 0A13 32 17 53                     ld      (SCR_CURS_X),A  ; store new X
 983+ 0A16 3A 18 53                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 984+ 0A19 3C                           inc     A               ; new row
 985+ 0A1A 21 13 53                     ld      HL,SCR_SIZE_H   ; load address of cell that keeps screen height
 986+ 0A1D BE                           cp      (HL)            ; is the cursor over the bottom of the screen?
 987+ 0A1E 38 06                        jr      C,ADDNEWLINE    ; no, jump over
 988+ 0A20 3D                           dec     A               ; yes, so come back 1 row, then...
 989+ 0A21 F5                           push    AF              ; (store A)
 990+ 0A22 CD 33 09                     call    SCROLLUP        ; ...scroll the screen before to...
 991+ 0A25 F1                           pop     AF              ; (retrieve A)
 992+ 0A26 32 18 53     ADDNEWLINE:     ld      (SCR_CURS_Y),A  ; ...store new Y
 993+ 0A29 3A 28 53                     ld      A,(TMPBFR4)     ; retrieve cursor state
 994+ 0A2C A7                           and     A               ; was it off (A=0)?
 995+ 0A2D C4 17 09                     call    NZ,CURSOR_ON    ; no, set cursor on
 996+ 0A30 C3 B6 06                     jp      POS_CURSOR      ; position cursor to new location & return to caller
 997+ 0A33
 998+ 0A33              ; find end of text line
 999+ 0A33              ; destroys A, DE, and HL - store address of last char of text line into HL,
1000+ 0A33              ; while DE contains the address of the bottom right cell of the screen
1001+ 0A33 3A 13 53     ENDOFLN:        ld      A,(SCR_SIZE_H)
1002+ 0A36 5F                           ld      E,A             ; load screen height into DE
1003+ 0A37 3A 12 53                     ld      A,(SCR_SIZE_W)
1004+ 0A3A 6F                           ld      L,A             ; load screen width into HL
1005+ 0A3B AF                           xor     A
1006+ 0A3C 67                           ld      H,A
1007+ 0A3D 57                           ld      D,A
1008+ 0A3E CD E9 3F                     call    MUL16           ; multiply HL times DE to get the screen size
1009+ 0A41 ED 5B 15 53                  ld      DE,(SCR_NAM_TB) ; load screen name table start address into DE
1010+ 0A45 19                           add     HL,DE           ; get the address...
1011+ 0A46 2B                           dec     HL              ; ...of the "last" video cell
1012+ 0A47 EB                           ex      DE,HL           ; store address into DE
1013+ 0A48 2A 22 53                     ld      HL,(CUR_POS)    ; retrieve original cursor position
1014+ 0A4B E5           RPTNLLSRC2:     push    HL
1015+ 0A4C CD DE 3F                     call    CMP16           ; check if at last position on screen (bottom right corner)
1016+ 0A4F E1                           pop     HL
1017+ 0A50 C8                           ret     Z               ; if yes, exit because these is nothing after
1018+ 0A51 23                           inc     HL              ; 1 more step forward
1019+ 0A52 CD 7A 06                     call    READ_VIDEO_LOC  ; read char of current position
1020+ 0A55 A7                           and     A               ; is it $00 (null char)?
1021+ 0A56 20 F3                        jr      NZ,RPTNLLSRC2   ; no, continue searching
1022+ 0A58 C9           CNTNULL2:       ret                     ; yes: found end of text, return to caller
1023+ 0A59
1024+ 0A59
1025+ 0A59              ; ------------------------------------------------------------------------------
1026+ 0A59                              ; this table contains the values of the offsets to be added to
1027+ 0A59                              ; the starting address of the name table to find the correct
1028+ 0A59                              ; value of the first cell of the corresponding row
1029+ 0A59                              ; (by doing so, it's faster than doing a multipication)
1030+ 0A59                              ; table for graphics 1 text mode: 32 cols
1031+ 0A59 00 00 20 00  POS_TB_CRS_32:  defw    $0000,$0020,$0040,$0060,$0080,$00A0,$00C0,$00E0
1031+ 0A5D 40 00 60 00
1031+ 0A61 80 00 A0 00
1031+ 0A65 C0 00 E0 00
1032+ 0A69 00 01 20 01                  defw    $0100,$0120,$0140,$0160,$0180,$01A0,$01C0,$01E0
1032+ 0A6D 40 01 60 01
1032+ 0A71 80 01 A0 01
1032+ 0A75 C0 01 E0 01
1033+ 0A79 00 02 20 02                  defw    $0200,$0220,$0240,$0260,$0280,$02A0,$02C0,$02E0
1033+ 0A7D 40 02 60 02
1033+ 0A81 80 02 A0 02
1033+ 0A85 C0 02 E0 02
1034+ 0A89                              ; table for pure text mode: 40 cols
1035+ 0A89 00 00 28 00  POS_TB_CRS_40:  defw    $0000,$0028,$0050,$0078,$00A0,$00C8,$00F0,$0118
1035+ 0A8D 50 00 78 00
1035+ 0A91 A0 00 C8 00
1035+ 0A95 F0 00 18 01
1036+ 0A99 40 01 68 01                  defw    $0140,$0168,$0190,$01B8,$01E0,$0208,$0230,$0258
1036+ 0A9D 90 01 B8 01
1036+ 0AA1 E0 01 08 02
1036+ 0AA5 30 02 58 02
1037+ 0AA9 80 02 A8 02                  defw    $0280,$02A8,$02D0,$02F8,$0320,$0348,$0370,$0398
1037+ 0AAD D0 02 F8 02
1037+ 0AB1 20 03 48 03
1037+ 0AB5 70 03 98 03
1038+ 0AB9
1039+ 0AB9              ; ------------------------------------------------------------------------------
1040+ 0AB9              ; reset VRAM
1041+ 0AB9 AF           EMPTY_VRAM:     xor     A               ; reg.A cleared: we fill up VRAM with $00
1042+ 0ABA 67                           ld      H,A
1043+ 0ABB 6F                           ld      L,A             ; reset HL
1044+ 0ABC CD 5A 06                     call    SETVDPADRS      ; set address of first VRAM cell to $0000
1045+ 0ABF 06 40                        ld      B,$40           ; $40 pages of RAM...
1046+ 0AC1 57                           ld      D,A             ; ...each one with $100 cells (tot. $4000 bytes)
1047+ 0AC2 0D                           dec     C              ; VDP data mode
1048+ 0AC3 ED 79        EMPTVRM:        out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
1049+ 0AC5 14                           inc     D               ; next cell
1050+ 0AC6 00                           nop
1051+ 0AC7 20 FA                        jr      NZ,EMPTVRM      ; repeat until page is fully cleared
1052+ 0AC9 10 F8                        djnz    EMPTVRM         ; repeat for $40 pages
1053+ 0ACB C9                           ret                     ; return to caller
1054+ 0ACC
1055+ 0ACC              ; clear video registers in SRAM
1056+ 0ACC 21 12 53     CLR_RAM_REG:    ld      HL,SCR_SIZE_W   ; address of first register
1057+ 0ACF AF                           xor     A               ; $00 to clean the registers
1058+ 0AD0 06 44                        ld      B,CHASNDDTN-SCR_SIZE_W; how many bytes (registers) to clean (dinamically calculated)
1059+ 0AD2 77           RSTVDPRAMREG:   ld      (HL),A          ; reset register
1060+ 0AD3 23                           inc     HL              ; next register
1061+ 0AD4 10 FC                        djnz    RSTVDPRAMREG    ; repeat
1062+ 0AD6 C9                           ret                     ; return to caller
1063+ 0AD7
1064+ 0AD7              ; ------------------------------------------------------------------------------
1065+ 0AD7              ; set a specific graphics mode, passed into reg. E
1066+ 0AD7 06 08        SET_GFX_MODE:   ld      B,$08           ; 8 registers means 8 bytes..
1067+ 0AD9 CB 23                        sla     E               ; multiply E by 8..
1068+ 0ADB CB 23                        sla     E               ; so that reg. E can point..
1069+ 0ADD CB 23                        sla     E               ; to the correct settings
1070+ 0ADF 16 00        SET_GFX_MODE2:  ld      D,$00           ; reset D
1071+ 0AE1 21 13 0B                     ld      HL,VDPMODESET   ; pointer to register settings | <= here points the SHOW_LOGO sub-routine
1072+ 0AE4 19                           add     HL,DE           ; add offset to get the correct set of values for the required mode
1073+ 0AE5 3E 80                        ld      A,$80           ; start with REG0 ($80+register number)
1074+ 0AE7 0E 31                        ld      C,VDP_SET       ; VDP set
1075+ 0AE9 56           LDREGVLS:       ld      D,(HL)          ; load register's value
1076+ 0AEA ED 51                        out     (C),D           ; send data to VDP
1077+ 0AEC ED 79                        out     (C),A           ; indicate the register to send data to
1078+ 0AEE 3C                           inc     A               ; next register
1079+ 0AEF 23                           inc     HL              ; next value
1080+ 0AF0 10 F7                        djnz    LDREGVLS        ; repeat for 8 registers
1081+ 0AF2 C9                           ret
1082+ 0AF3
1083+ 0AF3              ; ------------------------------------------------------------------------------
1084+ 0AF3              LOADCHARSET:    ; reg. A contains the video mode
1085+ 0AF3                              ; reg. HL contains address of pattern table into VRAM
1086+ 0AF3 06 00                        ld      B,$00           ; 0=256 chars to load (complete charset)
1087+ 0AF5 CB F4                        set     $06,H           ; add $4000 to address to indicate that we want to write into VRAM
1088+ 0AF7 0E 31                        ld      C,VDP_SET       ; load VDP address into C
1089+ 0AF9 ED 69                        out     (C),L           ; send low byte of address
1090+ 0AFB ED 61                        out     (C),H           ; send high byte
1091+ 0AFD 0D                           dec     C              ; VDP data mode
1092+ 0AFE 21 41 40                     ld      HL,CHRST68      ; starting address of 6x8 charset into ROM
1093+ 0B01 A7                           and     A               ; is it text mode (A=0)?
1094+ 0B02 28 03                        jr      Z,NXTCHAR       ; yes, so jump to load chars into VRAM
1095+ 0B04 21 41 48                     ld      HL,CHRST88      ; no, so we change and load the 8x8 charset
1096+ 0B07 16 08        NXTCHAR:        ld      D,$08           ; 8 bytes per pattern char
1097+ 0B09 7E           SENDCHRPTRNS:   ld      A,(HL)          ; load byte to send to VDP
1098+ 0B0A ED 79                        out     (C),A           ; write byte into VRAM
1099+ 0B0C 23                           inc     HL              ; inc byte pointer
1100+ 0B0D 15                           dec     D               ; 8 bytes sents (0 char)?
1101+ 0B0E 20 F9                        jr      NZ,SENDCHRPTRNS ; no, continue
1102+ 0B10 10 F5                        djnz    NXTCHAR         ; yes, decrement chars counter and continue for all the chars
1103+ 0B12 C9                           ret                     ; return to caller
1104+ 0B13
1105+ 0B13              ;------------------------------------------------------------------------------
1106+ 0B13              ; NAME TABLE:       buffer video - contains the chars to be shown on video
1107+ 0B13              ; PATTERN TABLE:    charset - contains the chars/tiles to be loaded into the name table
1108+ 0B13              ; COLOR TABLE:      color settings for chars/tiles
1109+ 0B13
1110+ 0B13                              ; VDP register settings for a text display
1111+ 0B13 00           VDPMODESET:     defb    %00000000       ; reg.0: external video off
1112+ 0B14 D0                           defb    %11010000       ; reg.1: 16K VRAM, video on, int. off, text mode (40x24)
1113+ 0B15 02                           defb    $02             ; reg.2: name table set to $0800 ($02x$400)
1114+ 0B16 00                           defb    $00             ; reg.3: not used in text mode
1115+ 0B17 00                           defb    $00             ; reg.4: pattern table set to $0000
1116+ 0B18 00                           defb    $00             ; reg.5: not used in text mode
1117+ 0B19 00                           defb    $00             ; reg.6: not used in text mode
1118+ 0B1A F5                           defb    $f5             ; reg.7: white text on light blue background
1119+ 0B1B
1120+ 0B1B              VDPMODESET1:    ; VDP register settings for a graphics 1 mode
1121+ 0B1B 00                           defb    %00000000       ; reg.0: ext. video off
1122+ 0B1C C0                           defb    %11000000       ; reg.1: 16K Vram; video on, int off, graphics mode 1, sprite size 8x8, sprite magn. 0
1123+ 0B1D 06                           defb    $06             ; reg.2: name table address: $1800
1124+ 0B1E 80                           defb    $80             ; reg.3: color table address: $2000
1125+ 0B1F 00                           defb    $00             ; reg.4: pattern table address: $0000
1126+ 0B20 36                           defb    $36             ; reg.5: sprite attr. table address: $1B00
1127+ 0B21 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1128+ 0B22 05                           defb    $05             ; reg.7: backdrop color (light blue)
1129+ 0B23
1130+ 0B23              VDPMODESET2:    ; VDP register settings for a graphics 2 mode
1131+ 0B23 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1132+ 0B24 C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1133+ 0B25 06                           defb    $06             ; reg.2: name table addr.: $1800
1134+ 0B26 FF                           defb    $FF             ; reg.3: color table addr.: $2000
1135+ 0B27 03                           defb    $03             ; reg.4: pattern table addr.: $0000
1136+ 0B28 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1137+ 0B29 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1138+ 0B2A 05                           defb    $05             ; reg.7: backdrop color: light blue
1139+ 0B2B
1140+ 0B2B              VDPMODESETMC:   ; VDP register settings for a multicolor mode
1141+ 0B2B 00                           defb    %00000000       ; reg.0: ext. video dis.
1142+ 0B2C CB                           defb    %11001011       ; reg.1: 16K VRAM, video on, INT off, multicolor mode, sprite size 8x8, sprite magn. 0
1143+ 0B2D 02                           defb    $02             ; reg.2: name table addr.: $0800
1144+ 0B2E 00                           defb    $00             ; reg.3: don't care
1145+ 0B2F 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1146+ 0B30 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1147+ 0B31 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1148+ 0B32 0F                           defb    $0F             ; reg.7: backdrop color (white)
1149+ 0B33
1150+ 0B33              VDPMODESETEX2:  ; VDP register settings for an extended graphics 2 mode
1151+ 0B33 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1152+ 0B34 C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1153+ 0B35 0E                           defb    $0E             ; reg.2: name table addr.: $3800
1154+ 0B36 9F                           defb    $9F             ; reg.3: color table addr.: $2000
1155+ 0B37 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1156+ 0B38 76                           defb    $76             ; reg.5: sprite attr. table addr.: $3B00
1157+ 0B39 03                           defb    $03             ; reg.6: sprite pattern table addr.: $1800
1158+ 0B3A 05                           defb    $05             ; reg.7: backdrop color: light blue
1159+ 0B3B
1160+ 0B3B              LM80CLOGO:      ; patterns to compose the splash screen logo
1161+ 0B3B                              ; 1st band
1162+ 0B3B 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1162+ 0B3F 00 00 00 00
1162+ 0B43 00 00 00 00
1162+ 0B47 00 00 00 00
1162+ 0B4B 00 00 00 00
1162+ 0B4F 00 00 00 00
1162+ 0B53 00 00 00 00
1162+ 0B57 00 00 00 00
1163+ 0B5B 00 00 0F 0A                  defb    0,0,15,10,11,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1163+ 0B5F 0B 10 00 00
1163+ 0B63 00 00 00 00
1163+ 0B67 00 00 00 00
1163+ 0B6B 00 00 00 00
1163+ 0B6F 00 00 00 00
1163+ 0B73 00 00 00 00
1163+ 0B77 00 00 00 00
1164+ 0B7B                              ; 2nd band
1165+ 0B7B 00 00 0D 17                  defb    0,0,13,23,0,12,0,0,0,1,0,0,0,20,0,0,6,5,6,21,22,7,6,21,22,7,6,1,1,7,0,0
1165+ 0B7F 00 0C 00 00
1165+ 0B83 00 01 00 00
1165+ 0B87 00 14 00 00
1165+ 0B8B 06 05 06 15
1165+ 0B8F 16 07 06 15
1165+ 0B93 16 07 06 01
1165+ 0B97 01 07 00 00
1166+ 0B9B 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,20,6,1,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1166+ 0B9F 00 0C 00 00
1166+ 0BA3 00 01 00 00
1166+ 0BA7 00 01 14 06
1166+ 0BAB 01 05 03 05
1166+ 0BAF 03 05 03 05
1166+ 0BB3 03 05 03 05
1166+ 0BB7 03 05 00 00
1167+ 0BBB                              ; 3rd band
1168+ 0BBB 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,1,1,1,5,9,20,19,8,3,5,19,5,3,5,0,0,0,0
1168+ 0BBF 00 0C 00 00
1168+ 0BC3 00 01 00 00
1168+ 0BC7 00 01 01 01
1168+ 0BCB 01 05 09 14
1168+ 0BCF 13 08 03 05
1168+ 0BD3 13 05 03 05
1168+ 0BD7 00 00 00 00
1169+ 0BDB 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,8,3,5,6,21,22,7,3,1,22,5,3,5,0,0,0,0
1169+ 0BDF 00 0C 00 00
1169+ 0BE3 00 01 00 00
1169+ 0BE7 00 01 00 08
1169+ 0BEB 03 05 06 15
1169+ 0BEF 16 07 03 01
1169+ 0BF3 16 05 03 05
1169+ 0BF7 00 00 00 00
1170+ 0BFB                              ; 4th band
1171+ 0BFB 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,0,3,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1171+ 0BFF 00 0C 00 00
1171+ 0C03 00 01 00 00
1171+ 0C07 00 01 00 00
1171+ 0C0B 03 05 03 05
1171+ 0C0F 03 05 03 05
1171+ 0C13 03 05 03 05
1171+ 0C17 03 05 00 00
1172+ 0C1B 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,4,4,0,1,0,0,3,5,9,20,19,8,9,20,19,8,9,1,1,8,0,0
1172+ 0C1F 00 0C 00 00
1172+ 0C23 00 01 04 04
1172+ 0C27 00 01 00 00
1172+ 0C2B 03 05 09 14
1172+ 0C2F 13 08 09 14
1172+ 0C33 13 08 09 01
1172+ 0C37 01 08 00 00
1173+ 0C3B                              ; 5th band
1174+ 0C3B 00 00 0E 12                  defb    0,0,14,18,18,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1174+ 0C3F 12 11 00 00
1174+ 0C43 00 00 00 00
1174+ 0C47 00 00 00 00
1174+ 0C4B 00 00 00 00
1174+ 0C4F 00 00 00 00
1174+ 0C53 00 00 00 00
1174+ 0C57 00 00 00 00
1175+ 0C5B 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1175+ 0C5F 00 00 00 00
1175+ 0C63 00 00 00 00
1175+ 0C67 00 00 00 00
1175+ 0C6B 00 00 00 00
1175+ 0C6F 00 00 00 00
1175+ 0C73 00 00 00 00
1175+ 0C77 00 00 00 00
# file closed: ../include/vdp/vdp-1.4.asm
  74  0C7B
  75  0C7B              ; incude the latest version of the PSG module
  76  0C7B                  INCLUDE "../include/psg/psg-1.1.asm"
# file opened: ../include/psg/psg-1.1.asm
   1+ 0C7B              ; ------------------------------------------------------------------------------
   2+ 0C7B              ; LM80C - PSG ROUTINES - 1.1
   3+ 0C7B              ; ------------------------------------------------------------------------------
   4+ 0C7B              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0C7B              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0C7B              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0C7B              ; kind of warranty: you can use them at your own risk.
   8+ 0C7B              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0C7B              ; maintain the copyright notices, include this advice and the note to the
  10+ 0C7B              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0C7B              ; redistribuite them.
  12+ 0C7B              ; https://www.leonardomiliani.com
  13+ 0C7B              ;
  14+ 0C7B              ; Please support me by visiting the following links:
  15+ 0C7B              ; Main project page: https://www.leonardomiliani.com
  16+ 0C7B              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0C7B              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0C7B              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0C7B              ; ------------------------------------------------------------------------------
  20+ 0C7B              ;
  21+ 0C7B              ; ------------------------------------------------------------------------------
  22+ 0C7B
  23+ 0C7B              ;------------------------------------------------------------------------------
  24+ 0C7B
  25+ 0C7B              ; configure the PSG
  26+ 0C7B 21 56 53     initPSG:        ld      HL,CHASNDDTN    ; starting address of sound & keyboard RAM registers
  27+ 0C7E 06 0E                        ld      B,SERIALS_EN-CHASNDDTN; # of PSG sound & keyboard registers
  28+ 0C80 AF                           xor     A               ; reset A
  29+ 0C81 77           EMPTSNDBFR:     ld      (HL),A          ; reset RAM register
  30+ 0C82 23                           inc     HL              ; next register
  31+ 0C83 10 FC                        djnz    EMPTSNDBFR      ; repeat
  32+ 0C85 06 10        CLRPSGREGS:     ld      B,$10           ; 16 registers to set
  33+ 0C87 21 99 0C                     ld      HL,SNDREGCFG    ; starting address of register settings
  34+ 0C8A 16 00                        ld      D,$00           ; first register
  35+ 0C8C 7A           RSTPSG:         ld      A,D             ; register value
  36+ 0C8D CD D3 0C                     call    SETSNDREG       ; select register
  37+ 0C90 7E                           ld      A,(HL)          ; load value
  38+ 0C91 CD D8 0C                     call    WRTSNDREG       ; write to register
  39+ 0C94 14                           inc     D               ; next register
  40+ 0C95 23                           inc     HL              ; next value
  41+ 0C96 10 F4                        djnz    RSTPSG          ; repeat for each register
  42+ 0C98 C9                           ret                     ; return to caller
  43+ 0C99
  44+ 0C99 00 00 00 00  SNDREGCFG:      defb $00,$00,$00,$00,$00,$00,$00,%10111111
  44+ 0C9D 00 00 00 BF
  45+ 0CA1 00 00 00 00                  defb $00,$00,$00,$00,$00,$00,$ff,$ff
  45+ 0CA5 00 00 FF FF
  46+ 0CA9                              ; reg. 7: set I/O ch.A to OUTPUT, I/O ch.B to INPUT; set noise to OFF; set audio to OFF
  47+ 0CA9
  48+ 0CA9
  49+ 0CA9              ; routine to play a welcome beep on channel C (tone 4010) and to shut it off
  50+ 0CA9 21 C3 0C     WLCMBEEP:       ld      HL,WLCBPDAT     ; data address
  51+ 0CAC C3 B2 0C                     jp      SENDSND
  52+ 0CAF 21 CB 0C     NOBEEP:         ld      HL,NOBPDAT      ; data address
  53+ 0CB2 C5           SENDSND:        push    BC
  54+ 0CB3 06 04                        ld      B,$04           ; 4 pairs
  55+ 0CB5 7E           RPTWLCMBP:      ld      A,(HL)          ; read register #
  56+ 0CB6 CD D3 0C                     call    SETSNDREG
  57+ 0CB9 23                           inc     HL              ; next cell
  58+ 0CBA 7E                           ld      A,(HL)          ; read value
  59+ 0CBB CD D8 0C                     call    WRTSNDREG
  60+ 0CBE 23                           inc     HL
  61+ 0CBF 10 F4                        djnz    RPTWLCMBP       ; repeat
  62+ 0CC1 C1                           pop     BC
  63+ 0CC2 C9                           ret                     ; return to caller
  64+ 0CC3
  65+ 0CC3 07 BB 04 56  WLCBPDAT:       defb    $07,%10111011,$04,$56,$05,$00,$0A,$0F
  65+ 0CC7 05 00 0A 0F
  66+ 0CCB 04 00 05 00  NOBPDAT:        defb    $04,$00,$05,$00,$0A,$00,$07,%10111111
  66+ 0CCF 0A 00 07 BF
  67+ 0CD3
  68+ 0CD3
  69+ 0CD3              ; select register on PSG
  70+ 0CD3 0E 40        SETSNDREG:      ld      C,PSG_REG       ; PSG register port
  71+ 0CD5 ED 79                        out     (C),A           ; set register
  72+ 0CD7 C9                           ret                     ; return to caller
  73+ 0CD8
  74+ 0CD8              ; send data to PSG
  75+ 0CD8 0E 41        WRTSNDREG:      ld      C,PSG_DAT       ; PSG data port
  76+ 0CDA ED 79                        out     (C),A           ; send data
  77+ 0CDC C9                           ret                     ; return to caller
  78+ 0CDD
  79+ 0CDD              ; manage the sounds' duration: each time this subroutine is called, it
  80+ 0CDD              ; decrements the single sound durations (measured in ms) and eventually
  81+ 0CDD              ; shut off the audio channel whose counter has reached 0.
  82+ 0CDD              ; (this sub-routine is called by CH3 timer ISR)
  83+ 0CDD DD E5        MNGSNDS:        push    IX              ; store IX
  84+ 0CDF DD 21 56 53                  ld      IX,CHASNDDTN    ; starting address of tones duration
  85+ 0CE3 06 03                        ld      B,$03           ; 3 channels to check
  86+ 0CE5 26 01                        ld      H,$01           ; mixer channels: A=>bit 1, B=>bit 2, C=>bit 3
  87+ 0CE7 DD 5E 00     CHKSNDCH:       ld      E,(IX+0)        ; load LSB into E
  88+ 0CEA DD 56 01                     ld      D,(IX+1)        ; load MSB into D
  89+ 0CED 7B                           ld      A,E             ; load E into A
  90+ 0CEE B2                           or      D               ; check that DE=0
  91+ 0CEF 28 31                        jr      Z,CNTCHKSND     ; yes, jump over
  92+ 0CF1 1B                           dec     DE              ; no, so decrement DE
  93+ 0CF2 7B                           ld      A,E             ; reload E into A...
  94+ 0CF3 DD 73 00                     ld      (IX+0),E        ; store new...
  95+ 0CF6 DD 72 01                     ld      (IX+1),D        ; ...duration and...
  96+ 0CF9 B2                           or      D               ; ...do another check to see if DE=0
  97+ 0CFA 20 26                        jr      NZ,CNTCHKSND    ; no, so jump over
  98+ 0CFC                                                      ; if yes, let's shut down the corresponding channel
  99+ 0CFC                                                      ; to shut down a tone we disable it into the mixer
 100+ 0CFC                                                      ; then set 0 into its tone registers
 101+ 0CFC 16 07                        ld      D,$07           ; mixer register
 102+ 0CFE 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 103+ 0D00 ED 51                        out     (C),D           ; set mixer register
 104+ 0D02 ED 78                        in      A,(C)           ; load current value
 105+ 0D04 B4                           or      H               ; set off the channel into the mixer (remember that 1=OFF)
 106+ 0D05 ED 51                        out     (C),D           ; select mixer register
 107+ 0D07 0E 41                        ld      C,PSG_DAT       ; PSG data port
 108+ 0D09 ED 79                        out     (C),A           ; send new value for the mixer
 109+ 0D0B 3E 03                        ld      A,$03           ; three channels
 110+ 0D0D 90                           sub     B               ; find current channel (0->A, 1->B, 2->C)
 111+ 0D0E 87                           add     A,A             ; and find first register (A=>0, B=>2, C=>4)
 112+ 0D0F 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 113+ 0D11 ED 79                        out     (C),A           ; select first tone register of channel
 114+ 0D13 2E 00                        ld      L,$00           ; value 0 into L
 115+ 0D15 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 116+ 0D17 ED 69                        out     (C),L           ; write 0 into register
 117+ 0D19 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 118+ 0D1B 3C                           inc     A               ; next tone register
 119+ 0D1C ED 79                        out     (C),A           ; select second tone register of channel
 120+ 0D1E 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 121+ 0D20 ED 69                        out     (C),L           ; write 0 into register
 122+ 0D22 DD 23        CNTCHKSND:      inc     IX              ; set for...
 123+ 0D24 DD 23                        inc     IX              ; ...next channel...
 124+ 0D26 CB 24                        sla     H               ; shift left H 1 bit
 125+ 0D28 10 BD                        djnz    CHKSNDCH        ; repeat for 3 channels
 126+ 0D2A DD E1                        pop     IX              ; restore IX
 127+ 0D2C C9                           ret                     ; return to caller
 128+ 0D2D
 129+ 0D2D              ; read a specific row of the keyboard matrix, set by A
 130+ 0D2D              ; return read into A
 131+ 0D2D C5           READKBLN:       push    BC              ; store BC
 132+ 0D2E 06 0F                        ld      B,$0F           ; reg #15
 133+ 0D30 0E 40                        ld      C,PSG_REG       ; PSG register port
 134+ 0D32 ED 41                        out     (C),B           ; select reg #15
 135+ 0D34 0E 41                        ld      C,PSG_DAT       ; PSG data port
 136+ 0D36 ED 79                        out     (C),A           ; activate the row
 137+ 0D38 06 0E                        ld      B,$0E           ; register #14 (port B)
 138+ 0D3A 0E 40                        ld      C,PSG_REG       ; PSG register port
 139+ 0D3C ED 41                        out     (C),B           ; select reg. 14 (port B)
 140+ 0D3E ED 78                        in      A,(C)           ; read register #14
 141+ 0D40 C1                           pop     BC              ; retrieve BC
 142+ 0D41 C9                           ret
 143+ 0D42
 144+ 0D42              ; read the keyboard matrix to look for a key pressure
 145+ 0D42 0E 40        KEYBOARD:       ld      C,PSG_REG       ; PSG register port
 146+ 0D44 06 07                        ld      B,$07           ; set register #7...
 147+ 0D46 ED 41                        out     (C),B           ; ...to work with
 148+ 0D48 ED 78                        in      A,(C)           ; read register #7
 149+ 0D4A CB FF                        set     7,A             ; port A set to output
 150+ 0D4C CB B7                        res     6,A             ; port B set to input
 151+ 0D4E ED 41                        out     (C),B           ; set register #7
 152+ 0D50 0E 41                        ld      C,PSG_DAT       ; PSG data port
 153+ 0D52 ED 79                        out     (C),A           ; set I/O ports w/o altering the rest of the mixer
 154+ 0D54                              ; check special keys (SHIFT/ALT/CTRL)
 155+ 0D54 3E FD                        ld      A,%11111101     ; select SHIFT row
 156+ 0D56 CD 2D 0D                     call    READKBLN        ; read row
 157+ 0D59 CB 5F                        bit     3,A             ; test if SHIFT key is pressed (4th bit is reset)
 158+ 0D5B 20 05                        jr      NZ,CHECKALT     ; no, so go on
 159+ 0D5D 21 63 53                     ld      HL,CONTROLKEYS  ; control key flags
 160+ 0D60 36 01                        ld      (HL),%00000001  ; set SHIFT flag, reset CTRL & ALT flags (currently multiply control keys are NOT supported)
 161+ 0D62 3E FE        CHECKALT:       ld      A,%11111110     ; select ALT row
 162+ 0D64 CD 2D 0D                     call    READKBLN        ; read ALT row
 163+ 0D67 CB 6F                        bit     5,A             ; test if ALT key is pressed (5th bit is reset)
 164+ 0D69 20 05                        jr      NZ,CHECKCTRL    ; no, so go on
 165+ 0D6B 21 63 53                     ld      HL,CONTROLKEYS  ; control key flags
 166+ 0D6E 36 04                        ld      (HL),%00000100  ; set ALT flag, reset SHIFT & CTRL flag (currently multiply control keys are NOT supported)
 167+ 0D70 3E FE        CHECKCTRL:      ld      A,%11111110     ; select CTRL row
 168+ 0D72 CD 2D 0D                     call    READKBLN        ; read CTRL row
 169+ 0D75 CB 57                        bit     2,A             ; test if CTRL key is pressed (3rd bit is reset)
 170+ 0D77 20 05                        jr      NZ,CHECKKBD     ; no, so make a normal reading
 171+ 0D79 21 63 53                     ld      HL,CONTROLKEYS  ; control key flags
 172+ 0D7C 36 02                        ld      (HL),%00000010  ; set CTRL flag, reset SHIFT & ALT flags (currently multiply control keys are NOT supported)
 173+ 0D7E 06 08        CHECKKBD:       ld      B,$08           ; 8 lines
 174+ 0D80 3E 7F                        ld      A,%01111111     ; start from the last line of the matrix
 175+ 0D82 16 0F        RPTKBDRD:       ld      D,$0F           ; register #15 (port B)
 176+ 0D84 0E 40                        ld      C,PSG_REG       ; PSG register port
 177+ 0D86 ED 51                        out     (C),D           ; select reg. #15
 178+ 0D88 0E 41                        ld      C,PSG_DAT       ; PSG data port
 179+ 0D8A ED 79                        out     (C),A           ; activate 1 line (active line is grounded, i.e. with a LOW signal)
 180+ 0D8C 5F                           ld      E,A             ; save current line into E
 181+ 0D8D 16 0E                        ld      D,$0E           ; register #14 (port A)
 182+ 0D8F 0E 40                        ld      C,PSG_REG       ; PSG register port
 183+ 0D91 ED 51                        out     (C),D           ; select reg. 14 (port A)
 184+ 0D93 00                           nop
 185+ 0D94 ED 78                        in      A,(C)           ; read register #14
 186+ 0D96 FE FF                        cp      $FF             ; is there any line set to 0?
 187+ 0D98 28 2E                        jr      Z,NOKEYPRSD     ; no, go to the next row
 188+ 0D9A                              ; check control keys
 189+ 0D9A 32 5D 53                     ld      (KBTMP),A       ; yes, check if a control key was pressed. First, store current row
 190+ 0D9D 78                           ld      A,B             ; copy current row (B) into A
 191+ 0D9E FE 02                        cp      $02             ; is it the row of the SHIFT?
 192+ 0DA0 20 0F                        jr      NZ,TESTALT      ; no, continue checking the other control keys
 193+ 0DA2 3A 5D 53                     ld      A,(KBTMP)       ; yes, retrieve current row data
 194+ 0DA5 CB 5F                        bit     3,A             ; check SHIFT bit line
 195+ 0DA7 20 31                        jr      NZ,FINDKEY      ; no SHIFT, continue checking
 196+ 0DA9 CB DF                        set     3,A             ; yes, it's the SHIFT. So remove SHIFT bit
 197+ 0DAB FE FF                        cp      $FF             ; after deleting the SHIFT bit, is there any other bit selected?
 198+ 0DAD 20 2B                        jr      NZ,FINDKEY      ; yes, go to check which one
 199+ 0DAF 18 17                        jr      NOKEYPRSD       ; no, go to next row
 200+ 0DB1 FE 01        TESTALT:        cp      $01             ; is it the line of ALT & CTRL?
 201+ 0DB3 3A 5D 53                     ld      A,(KBTMP)       ; retrieve current row data
 202+ 0DB6 20 22                        jr      NZ,FINDKEY      ; no, continue
 203+ 0DB8 CB 6F                        bit     5,A             ; yes, check ALT bit line
 204+ 0DBA 20 02                        jr      NZ,TESTCTRL     ; no ALT, continue checking
 205+ 0DBC CB EF                        set     5,A             ; yes, it's the ALT. So remove ALT bit
 206+ 0DBE CB 57        TESTCTRL:       bit     2,A             ; check CTRL bit line
 207+ 0DC0 20 02                        jr      NZ,ENDCTRLCK    ; no CTRL, continue checking
 208+ 0DC2 CB D7                        set     2,A             ; delete CTRL bit flag
 209+ 0DC4 FE FF        ENDCTRLCK:      cp      $FF             ; after deleting the ALT & CTRL bits, is there any other bit selected?
 210+ 0DC6 20 12                        jr      NZ,FINDKEY      ; yes, go to check which one
 211+ 0DC8 7B           NOKEYPRSD:      ld      A,E             ; no key pressed, load current output port
 212+ 0DC9 0F                           rrca                    ; rotate right by 1
 213+ 0DCA 10 B6                        djnz    RPTKBDRD        ; repeat for 8 lines
 214+ 0DCC AF                           xor     A               ; if exit from here, no key has been pressed...
 215+ 0DCD 32 5F 53                     ld      (LASTKEYPRSD),A ; ...so reset the last key cell...
 216+ 0DD0 32 63 53                     ld      (CONTROLKEYS),A ; ...reset contro key flags...
 217+ 0DD3 32 5C 53                     ld      (KBDNPT),A      ; ...no input from keyboard...
 218+ 0DD6 32 60 53                     ld      (STATUSKEY),A   ; ...no auto-repeat...
 219+ 0DD9 C9                           ret                     ; ...and leave
 220+ 0DDA 1E FF        FINDKEY:        ld      E,$FF           ; counter
 221+ 0DDC 1C           CHKLN:          inc     E               ; E goes from 0 to 7
 222+ 0DDD CB 3F                        srl     A               ; is the first bit reset? (we're looking for a "0", meaning grounded line)
 223+ 0DDF 38 FB                        jr      C,CHKLN         ; no, check next bit
 224+ 0DE1 3A 63 53                     ld      A,(CONTROLKEYS) ; load control key flags
 225+ 0DE4 21 FD 0E                     ld      HL,KBMAP        ; normal keymap
 226+ 0DE7 FE 01                        cp      $01             ; SHIFT flag?
 227+ 0DE9 20 05                        jr      NZ,CHKCTRL      ; no, jump over
 228+ 0DEB 21 3D 0F                     ld      HL,KBMAP_SFT    ; SHIFT keymap
 229+ 0DEE 18 10                        jr      LOADMAP         ; and load it
 230+ 0DF0 FE 02        CHKCTRL:        cp      $02             ; CTRL flag?
 231+ 0DF2 20 05                        jr      NZ,CHKALT       ; no, jump over
 232+ 0DF4 21 BD 0F                     ld      HL,KBMAP_CTRL   ; CTRL map
 233+ 0DF7 18 07                        jr      LOADMAP         ; and load it
 234+ 0DF9 FE 04        CHKALT:         cp      $04             ; ALT flag?
 235+ 0DFB 20 03                        jr      NZ,LOADMAP      ; no, check over
 236+ 0DFD 21 7D 0F                     ld      HL,KBMAP_ALT    ; ALT map
 237+ 0E00 05           LOADMAP:        dec     B               ; decrement row # (rows go from 0 to 7)
 238+ 0E01 48                           ld      C,B             ; move B into C and...
 239+ 0E02 CB 21                        sla     C               ; ...multiply it...
 240+ 0E04 CB 21                        sla     C               ; ...by 8 to find...
 241+ 0E06 CB 21                        sla     C               ; ...the current row into the matrix
 242+ 0E08 06 00                        ld      B,$00           ; reset B
 243+ 0E0A 09                           add     HL,BC           ; find the address of the current row
 244+ 0E0B 50                           ld      D,B             ; reset D
 245+ 0E0C 19                           add     HL,DE           ; find the current column - now (HL) stores the pressed key
 246+ 0E0D 3A 5F 53                     ld      A,(LASTKEYPRSD) ; load the last key pressed
 247+ 0E10 BE                           cp      (HL)            ; is it the same key?
 248+ 0E11 20 41                        jr      NZ,NEWKEY       ; no, it's a new key
 249+ 0E13 44 4D                        ld      BC,HL           ; store address of current keycode
 250+ 0E15 2A 02 53                     ld      HL,(TMRCNT)     ; load current system timer
 251+ 0E18 ED 5B 61 53                  ld      DE,(KEYTMR)     ; load auto-repeat timer
 252+ 0E1C 3A 60 53                     ld      A,(STATUSKEY)   ; yes, load current status of auto-repeat
 253+ 0E1F FE 01                        cp      $01             ; is it initial pressure?
 254+ 0E21 20 1F                        jr      NZ,CHKAUTO      ; no, jump over
 255+ 0E23 AF                           xor     A               ; clear Carry
 256+ 0E24 ED 52                        sbc     HL,DE           ; startint time - actual time
 257+ 0E26 16 00                        ld      D,$00           ; 64 ths/s > 640 ms
 258+ 0E28 3A F8 51                     ld      A,(KEYDEL)
 259+ 0E2B 5F                           ld      E,A
 260+ 0E2C CD DE 3F                     call    CMP16           ; time elapsed is >= $40?
 261+ 0E2F DA A4 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 262+ 0E32 3E 02        SETNEWAUTO:     ld      A,$02           ; yes set status to...
 263+ 0E34 32 60 53                     ld      (STATUSKEY),A   ; ...auto-repeat
 264+ 0E37 2A 02 53                     ld      HL,(TMRCNT)     ; load system timer
 265+ 0E3A 22 61 53                     ld      (KEYTMR),HL     ; store starting time
 266+ 0E3D 60 69                        ld      HL,BC           ; retrieve address of current keycode
 267+ 0E3F C3 61 0E                     jp      SENDKEY         ; send key
 268+ 0E42 AF           CHKAUTO:        xor     A               ; clear Carry
 269+ 0E43 ED 52                        sbc     HL,DE           ; computer interval between initial pressure of key and current time
 270+ 0E45 16 00                        ld      D,$00
 271+ 0E47 3A F9 51                     ld      A,(AUTOKE)
 272+ 0E4A 5F                           ld      E,A             ; auto-repeat delay into DE
 273+ 0E4B CD DE 3F                     call    CMP16           ; check if interval is greater than delay
 274+ 0E4E DA A4 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 275+ 0E51 C3 32 0E                     jp      SETNEWAUTO      ; set new loop and send key
 276+ 0E54 AF           NEWKEY:         xor     A               ; set initial state...
 277+ 0E55 3C                           inc     A               ; ...for auto-repeat...
 278+ 0E56 32 60 53                     ld      (STATUSKEY),A   ; ...1=pressure init
 279+ 0E59 ED 4B 02 53                  ld      BC,(TMRCNT)     ; load current system timer
 280+ 0E5D ED 43 61 53                  ld      (KEYTMR),BC     ; set starting time
 281+ 0E61 7E           SENDKEY:        ld      A,(HL)          ; then, load key...
 282+ 0E62 32 5F 53                     ld      (LASTKEYPRSD),A ; ...store it...
 283+ 0E65 32 5E 53                     ld      (TMPKEYBFR),A   ; ...insert it into the INKEY buffer...
 284+ 0E68 32 1F 53                     ld      (CHR4VID),A     ; ...and store char for video
 285+ 0E6B FE 03                        cp      CTRLC           ; is it RUN/STOP?
 286+ 0E6D 20 05                        jr      NZ,CNTKBCK      ; no, jump over
 287+ 0E6F CD FD 01                     call    CHARINTOBFR     ; yes, send directly to buffer and...
 288+ 0E72 18 30                        jr      LVKBRDCHK2      ; ...leave
 289+ 0E74 01 00 08     CNTKBCK:        ld      BC,$0800        ; 8 FN keys (B), FN key number (C)
 290+ 0E77 21 F5 0E                     ld      HL,FNKEYSORD    ; FN keys codes
 291+ 0E7A BE           CHKFNK:         cp      (HL)            ; is it an FN key?
 292+ 0E7B CA A9 0E                     jp      Z,PRNTFNKEY     ; yes, jump over
 293+ 0E7E 0C                           inc     C               ; next FN key
 294+ 0E7F 23                           inc     HL              ; next FN key code
 295+ 0E80 10 F8                        djnz    CHKFNK          ; continue for 8 FN keys
 296+ 0E82 3E 01        SNDKEYTOBFR:    ld      A,$01           ; normal key - set input flag
 297+ 0E84 32 5C 53                     ld      (KBDNPT),A      ; to keyboard
 298+ 0E87 3A 1E 53                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 299+ 0E8A B7                           or      A               ; is the print-on-video disabled?
 300+ 0E8B CA 94 0E                     jp      Z,PUTCHRBUF     ; yes, so send char to input buffer
 301+ 0E8E 3A 1C 53                     ld      A,(CRSR_STATE)  ; check cursor state
 302+ 0E91 B7                           or      A               ; is it 0 (cursor OFF)?
 303+ 0E92 20 0D                        jr      NZ,PNT2VD       ; no, print on screen
 304+ 0E94 AF           PUTCHRBUF:      xor     A
 305+ 0E95 32 5C 53                     ld      (KBDNPT),A      ; if send to input buffer, set RETURN as from BASIC
 306+ 0E98 3A 5E 53                     ld      A,(TMPKEYBFR)   ; retrieve char
 307+ 0E9B CD FD 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 308+ 0E9E C3 A4 0E                     jp      LVKBRDCHK2      ; ...and leave
 309+ 0EA1 CD 4B 07     PNT2VD:         call    CHAR2VID        ; send char to video
 310+ 0EA4 AF           LVKBRDCHK2:     xor     A
 311+ 0EA5 32 63 53                     ld      (CONTROLKEYS),A ; reset control key flags
 312+ 0EA8 C9           LVKBRDCHK:      ret                     ; return to caller: the current key code is into TMPKEYBFR
 313+ 0EA9                              ; manage FN keys
 314+ 0EA9 57           PRNTFNKEY:      ld      D,A             ; copy A into D
 315+ 0EAA 2A F4 51                     ld      HL,(LINEAT)     ; Get current line number
 316+ 0EAD 23                           inc     HL              ; -1 means direct statement
 317+ 0EAE 7C                           ld      A,H
 318+ 0EAF B5                           or      L
 319+ 0EB0 7A                           ld      A,D             ; retrieve char
 320+ 0EB1 20 CF                        jr      NZ,SNDKEYTOBFR  ; indirect mode - just send FN key code to buffer
 321+ 0EB3 79                           ld      A,C             ; direct mode, so print text - first, get FN key number
 322+ 0EB4 87                           add     A,A
 323+ 0EB5 87                           add     A,A
 324+ 0EB6 87                           add     A,A
 325+ 0EB7 87                           add     A,A             ; FN key number * 16
 326+ 0EB8 4F                           ld      C,A             ; move it into C
 327+ 0EB9 06 00                        ld      B,$00           ; reset B, to get offset
 328+ 0EBB 21 FA 51                     ld      HL,FNKEYS       ; load address of FN keys texts
 329+ 0EBE 09                           add     HL,BC           ; get correct text address
 330+ 0EBF 06 10                        ld      B,$10           ; 16 chars
 331+ 0EC1 7E           LDFNKEYCHR:     ld      A,(HL)          ; load char
 332+ 0EC2 A7                           and     A               ; null char?
 333+ 0EC3 CA A4 0E                     jp      Z,LVKBRDCHK2    ; yes, so leave
 334+ 0EC6 57                           ld      D,A             ; pass char into D
 335+ 0EC7 3A 1E 53                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 336+ 0ECA B7                           or      A               ; is the print-on-video disabled?
 337+ 0ECB CA DB 0E                     jp      Z,PUTCHRBUF1    ; yes, so send char to input buffer
 338+ 0ECE 3A 1C 53                     ld      A,(CRSR_STATE)  ; check cursor state
 339+ 0ED1 B7                           or      A               ; is it 0 (cursor OFF)?
 340+ 0ED2 C4 E8 0E                     call    NZ,PRNTFNK      ; no, print on screen
 341+ 0ED5 23           CNTFNK:         inc     HL              ; next char
 342+ 0ED6 10 E9                        djnz    LDFNKEYCHR      ; repeat for max. 16 chars
 343+ 0ED8 C3 A4 0E                     jp      LVKBRDCHK2      ; leave
 344+ 0EDB AF           PUTCHRBUF1:     xor     A               ; if send to input buffer,...
 345+ 0EDC 32 5C 53                     ld      (KBDNPT),A      ; ...set input as from BASIC
 346+ 0EDF 7A                           ld      A,D             ; retrieve char
 347+ 0EE0 E5                           push    HL              ; store HL
 348+ 0EE1 CD FD 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 349+ 0EE4 E1                           pop     HL              ; retrieve HL
 350+ 0EE5 C3 D5 0E                     jp      CNTFNK          ; repeat
 351+ 0EE8 7A           PRNTFNK:        ld      A,D             ; recover char
 352+ 0EE9 32 1F 53                     ld      (CHR4VID),A     ; store char for printing
 353+ 0EEC 3E 01                        ld      A,$01           ; normal key - set input flag
 354+ 0EEE 32 5C 53                     ld      (KBDNPT),A      ; to keyboard
 355+ 0EF1 CD 4B 07                     call    CHAR2VID        ; print on screen
 356+ 0EF4 C9                           ret                     ; return to caller
 357+ 0EF5
 358+ 0EF5
 359+ 0EF5              ;-----------------------------------------------------------------------
 360+ 0EF5 01 02 04 05  FNKEYSORD:      defb 1,2,4,5,6,22,23,24                 ; order of FN Keys
 360+ 0EF9 06 16 17 18
 361+ 0EFD              ;-----------------------------------------------------------------------
 362+ 0EFD              ; key codes
 363+ 0EFD 31 19 0E 03  KBMAP:          defb '1',25,14,3,' ',16,'q','2'         ; 25=HOME  14=CTRL  3=RUN/STOP 16=C=
 363+ 0F01 20 10 71 32
 364+ 0F05 33 77 61 14                  defb '3','w','a',20,'z','s','e','4'     ; 20=SHIFT
 364+ 0F09 7A 73 65 34
 365+ 0F0D 35 72 64 78                  defb '5','r','d','x','c','f','t','6'
 365+ 0F11 63 66 74 36
 366+ 0F15 37 79 67 76                  defb '7','y','g','v','b','h','u','8'
 366+ 0F19 62 68 75 38
 367+ 0F1D 39 69 6A 6E                  defb '9','i','j','n','m','k','o','0'
 367+ 0F21 6D 6B 6F 30
 368+ 0F25 1F 70 6C 2C                  defb 31,'p','l',',','.',':','-',30      ; 31=CURSOR DOWN  30=CURSOR UP
 368+ 0F29 2E 3A 2D 1E
 369+ 0F2D 1C 2A 3B 2F                  defb 28,'*',';','/',27,'=','+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 369+ 0F31 1B 3D 2B 1D
 370+ 0F35 08 0D FC 40                  defb 8,13,252,'@',1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 370+ 0F39 01 02 04 18
 371+ 0F3D
 372+ 0F3D              ; shifted codes - not all the keys have the shifted version
 373+ 0F3D 21 0C 0E 03  KBMAP_SFT:      defb '!',12,14,3,' ',16,'Q',34          ; 12=CLEAR  14=CTRL  3=RUN/STOP 16=C=   34="
 373+ 0F41 20 10 51 22
 374+ 0F45 23 57 41 14                  defb '#','W','A',20,'Z','S','E','$'     ; 20=SHIFT
 374+ 0F49 5A 53 45 24
 375+ 0F4D 25 52 44 58                  defb '%','R','D','X','C','F','T','&'
 375+ 0F51 43 46 54 26
 376+ 0F55 27 59 47 56                  defb 39,'Y','G','V','B','H','U','('     ; 39='
 376+ 0F59 42 48 55 28
 377+ 0F5D 29 49 4A 4E                  defb ')','I','J','N','M','K','O',94     ; 94=^
 377+ 0F61 4D 4B 4F 5E
 378+ 0F65 1F 50 4C 3C                  defb 31,'P','L','<','>','[','_',30      ; 31=CURSOR DOWN  30=CURSOR UP
 378+ 0F69 3E 5B 5F 1E
 379+ 0F6D 1C 2A 5D 3F                  defb 28,'*',']','?',27,198,'+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 379+ 0F71 1B C6 2B 1D
 380+ 0F75 1A 0D D3 40                  defb 26,13,211,'@',5,6,22,23            ; 26=INSERT, 211=â¬  5=F4  6=F5  22=F6  23=F7
 380+ 0F79 05 06 16 17
 381+ 0F7D
 382+ 0F7D              ; ALT (C=) codes - not all the keys have the alt-ed version
 383+ 0F7D 31 0C 0E 03  KBMAP_ALT:      defb '1',12,14,3,' ',16,222,196         ; 12=CLEAR  14=CTRL  3=RUN/STOP  16=C=  34="
 383+ 0F81 20 10 DE C4
 384+ 0F85 33 DD 85 14                  defb '3',221,133,20,131,130,165,'4'     ; 20=SHIFT
 384+ 0F89 83 82 A5 34
 385+ 0F8D 35 A2 A6 84                  defb '5',162,166,132,157,163,168,'6'
 385+ 0F91 9D A3 A8 36
 386+ 0F95 37 AB A9 A1                  defb '7',171,169,161,158,172,213,'8'    ;
 386+ 0F99 9E AC D5 38
 387+ 0F9D 39 D6 D8 9F                  defb '9',214,216,159,160,215,135,195    ;
 387+ 0FA1 A0 D7 87 C3
 388+ 0FA5 1F 88 8A C1                  defb 31,136,138,193,192,123,144,30      ; 31=CURSOR DOWN  123={  30=CURSOR UP
 388+ 0FA9 C0 7B 90 1E
 389+ 0FAD 1C 8F 7D FE                  defb 28,143,125,254,27,209,148,29       ; 28=CURSOR LEFT  125=}  27=ESCAPE  29=CURSOR RIGHT
 389+ 0FB1 1B D1 94 1D
 390+ 0FB5 08 0D E0 89                  defb 8,13,224,137,5,6,22,23             ; 8=DEL(backspace)  13=RETURN  252=Â£  5=F4  6=F5  22=F6  23=F7
 390+ 0FB9 05 06 16 17
 391+ 0FBD
 392+ 0FBD              ; CTRL codes - not all the keys have the control-ed version
 393+ 0FBD 31 19 0E 03  KBMAP_CTRL:     defb '1',25,14,3,' ',16,154,'2'         ; 25=HOME  14=CTRL  3=RUN/STOP  16=C=
 393+ 0FC1 20 10 9A 32
 394+ 0FC5 33 9C 95 14                  defb '3',156,149,20,152,150,153,'4'     ; 20=SHIFT
 394+ 0FC9 98 96 99 34
 395+ 0FCD 35 9B B0 97                  defb '5',155,176,151,177,175,165,'6'
 395+ 0FD1 B1 AF A5 36
 396+ 0FD5 37 A6 A8 B2                  defb '7',166,168,178,179,169,167,'8'
 396+ 0FD9 B3 A9 A7 38
 397+ 0FDD 39 B8 AA AC                  defb '9',184,170,172,171,181,164,'0'
 397+ 0FE1 AB B5 A4 30
 398+ 0FE5 1F A3 AD 2C                  defb 31,163,173,',','.',':',186,30      ; 31=CURSOR DOWN  30=CURSOR UP
 398+ 0FE9 2E 3A BA 1E
 399+ 0FED 1C E1 3B 2F                  defb 28,225,';','/',27,212,185,29       ; 28=CURSOR LEFT  27=ESCAPE  212=Ï  29=CURSOR RIGHT
 399+ 0FF1 1B D4 B9 1D
 400+ 0FF5 08 0D BD A2                  defb 8,13,189,162,1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 400+ 0FF9 01 02 04 18
# file closed: ../include/psg/psg-1.1.asm
  77  0FFD
  78  0FFD              ; include the latest version of the LM80C 64K BASIC interpreter
  79  0FFD                  INCLUDE "../include/basic/basic-1.04.asm"
# file opened: ../include/basic/basic-1.04.asm
   1+ 0FFD              ; ------------------------------------------------------------------------------
   2+ 0FFD              ; LM80C BASIC (32K/64K) - R3.18
   3+ 0FFD              ; ------------------------------------------------------------------------------
   4+ 0FFD              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0FFD              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0FFD              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0FFD              ; kind of warranty: you can use them at your own risk.
   8+ 0FFD              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0FFD              ; maintain the copyright notices, include this advice and the note to the
  10+ 0FFD              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0FFD              ; redistribuite them.
  12+ 0FFD              ; https://www.leonardomiliani.com
  13+ 0FFD              ;
  14+ 0FFD              ; Please support me by visiting the following links:
  15+ 0FFD              ; Main project page: https://www.leonardomiliani.com
  16+ 0FFD              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0FFD              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0FFD              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0FFD              ; ------------------------------------------------------------------------------
  20+ 0FFD              ; LM80C BASIC 64K - originally based on the following NASCOM BASIC versions:
  21+ 0FFD              ; 4.7  - original version by NASCOM/MICROSOFT
  22+ 0FFD              ; 4.7b - modified version by Grant Searle (additional commands & functions)
  23+ 0FFD
  24+ 0FFD
  25+ 0FFD              ;------------------------------------------------------------------------------
  26+ 0FFD              ;  L M 8 0 C   B A S I C
  27+ 0FFD              ;------------------------------------------------------------------------------
  28+ 0FFD
  29+ 0FFD              ; GENERAL EQUATES
  30+ 0FFD
  31+ 0FFD              NLLCR           equ     $00             ; null char (used as space/empty char in video prints)
  32+ 0FFD              CTRLC           equ     $03             ; Control "C"
  33+ 0FFD              CTRLG           equ     $07             ; Control "G"
  34+ 0FFD              BKSP            equ     $08             ; Back space
  35+ 0FFD              LF              equ     $0A             ; Line feed
  36+ 0FFD              CS              equ     $0C             ; Clear screen
  37+ 0FFD              CR              equ     $0D             ; Carriage return
  38+ 0FFD              CTRLO           equ     $0F             ; Control "O"
  39+ 0FFD              CTRLQ           equ     $11             ; Control "Q"
  40+ 0FFD              CTRLR           equ     $12             ; Control "R"
  41+ 0FFD              CTRLS           equ     $13             ; Control "S"
  42+ 0FFD              CTRLU           equ     $15             ; Control "U"
  43+ 0FFD              HOME            equ     $19             ; Home (cursor at 0,0)
  44+ 0FFD              ESC             equ     $1B             ; Escape
  45+ 0FFD              SPC             equ     $20             ; Space
  46+ 0FFD              DEL             equ     $7F             ; Delete
  47+ 0FFD              INSRT           equ     $1A             ; Insert Key
  48+ 0FFD              ; cursor ASCII codes
  49+ 0FFD              CRSLFT          equ     $1C             ; cursor left
  50+ 0FFD              CRSRGT          equ     $1D             ; cursor right
  51+ 0FFD              CRSUP           equ     $1E             ; cursor up
  52+ 0FFD              CRSDN           equ     $1F             ; cursor down
  53+ 0FFD
  54+ 0FFD
  55+ 0FFD              ;-------------------------------------------------------------------------
  56+ 0FFD              ; BASIC ERROR MESSAGES
  57+ 0FFD              ; the interpreter looks for a single-byte code in the following list,
  58+ 0FFD              ; then loads the corresponding memory pointer in "ERRTBL" table to
  59+ 0FFD              ; find where to retrieve the message text in "ERRORS"
  60+ 0FFD
  61+ 0FFD              ; BASIC ERROR CODE VALUES
  62+ 0FFD              ; These values act as an offset to point to the error message into the error table
  63+ 0FFD              ; must be incremented by 2 because they point to a word address jump
  64+ 0FFD              NF              equ     $00     ; NEXT without FOR
  65+ 0FFD              SN              equ     $02     ; Syntax error
  66+ 0FFD              RG              equ     $04     ; RETURN without GOSUB
  67+ 0FFD              OD              equ     $06     ; Out of DATA
  68+ 0FFD              FC              equ     $08     ; Function call error
  69+ 0FFD              OV              equ     $0A     ; Overflow
  70+ 0FFD              OM              equ     $0C     ; Out of memory
  71+ 0FFD              UL              equ     $0E     ; Undefined line number
  72+ 0FFD              BS              equ     $10     ; Bad subscript
  73+ 0FFD              DD              equ     $12     ; Re-Dimensioned array
  74+ 0FFD              DZ              equ     $14     ; Division by zero (/0)
  75+ 0FFD              ID              equ     $16     ; Illegal direct
  76+ 0FFD              TM              equ     $18     ; Type mis-match
  77+ 0FFD              OS              equ     $1A     ; Out of string space
  78+ 0FFD              LS              equ     $1C     ; String too long
  79+ 0FFD              ST              equ     $1E     ; String formula too complex
  80+ 0FFD              CN              equ     $20     ; Can't continue
  81+ 0FFD              UF              equ     $22     ; Undefined FN function
  82+ 0FFD              MO              equ     $24     ; Missing operand
  83+ 0FFD              HX              equ     $26     ; HEX error
  84+ 0FFD              BN              equ     $28     ; BIN error
  85+ 0FFD              GM              equ     $2A     ; No Graphics Mode
  86+ 0FFD              SC              equ     $2C     ; Serial configuration
  87+ 0FFD              SA              equ     $2E     ; Serial port already open
  88+ 0FFD              SO              equ     $30     ; Serial buffer overrun
  89+ 0FFD              HP              equ     $32     ; HELP call
  90+ 0FFD
  91+ 0FFD              ; BASIC ERROR POINTER TABLE
  92+ 0FFD              ERRTBL: equ $
  93+ 0FFD 31 10        NFPTR:  defw    NFMSG
  94+ 0FFF 42 10        SNPTR:  defw    SNMSG
  95+ 1001 49 10        RGPTR:  defw    RGMSG
  96+ 1003 5E 10        ODPTR:  defw    ODMSG
  97+ 1005 6A 10        FCPTR:  defw    FCMSG
  98+ 1007 80 10        OVPTR:  defw    OVMSG
  99+ 1009 89 10        OMPTR:  defw    OMMSG
 100+ 100B 97 10        ULPTR:  defw    ULMSG
 101+ 100D A6 10        BSPTR:  defw    BSMSG
 102+ 100F B4 10        DDPTR:  defw    DDMSG
 103+ 1011 C9 10        DZPTR:  defw    DZMSG
 104+ 1013 DA 10        IDPTR:  defw    IDMSG
 105+ 1015 E9 10        TMPTR:  defw    TMMSG
 106+ 1017 F8 10        OSPTR:  defw    OSMSG
 107+ 1019 0C 11        LSPTR:  defw    LSMSG
 108+ 101B 1C 11        STPTR:  defw    STMSG
 109+ 101D 37 11        CNPTR:  defw    CNMSG
 110+ 101F 46 11        UFPTR:  defw    UFMSG
 111+ 1021 5C 11        MOPTR:  defw    MOMSG
 112+ 1023 6C 11        HXPTR:  defw    HXMSG
 113+ 1025 77 11        BNPTR:  defw    BNMSG
 114+ 1027 82 11        GMPRT:  defw    GMMSG
 115+ 1029 93 11        SCPTR:  defw    SCMSG
 116+ 102B A8 11        SAPTR:  defw    SAMSG
 117+ 102D C1 11        SOPTR:  defw    SOMSG
 118+ 102F D7 11        HPPTR:  defw    HPMSG
 119+ 1031
 120+ 1031              ; BASIC ERROR MESSAGE LIST
 121+ 1031              ERRORS  equ $
 122+ 1031 4E 45 58 54  NFMSG:  defb    "NEXT Without FOR",0
 122+ 1035 20 57 69 74
 122+ 1039 68 6F 75 74
 122+ 103D 20 46 4F 52
 122+ 1041 00
 123+ 1042 53 79 6E 74  SNMSG:  defb    "Syntax",0
 123+ 1046 61 78 00
 124+ 1049 52 45 54 55  RGMSG:  defb    "RETURN without GOSUB",0
 124+ 104D 52 4E 20 77
 124+ 1051 69 74 68 6F
 124+ 1055 75 74 20 47
 124+ 1059 4F 53 55 42
 124+ 105D 00
 125+ 105E 4F 75 74 20  ODMSG:  defb    "Out of DATA",0
 125+ 1062 6F 66 20 44
 125+ 1066 41 54 41 00
 126+ 106A 49 6C 6C 65  FCMSG:  defb    "Illegal Function Call",0
 126+ 106E 67 61 6C 20
 126+ 1072 46 75 6E 63
 126+ 1076 74 69 6F 6E
 126+ 107A 20 43 61 6C
 126+ 107E 6C 00
 127+ 1080 4F 76 65 72  OVMSG:  defb    "Overflow",0
 127+ 1084 66 6C 6F 77
 127+ 1088 00
 128+ 1089 4F 75 74 20  OMMSG:  defb    "Out of Memory",0
 128+ 108D 6F 66 20 4D
 128+ 1091 65 6D 6F 72
 128+ 1095 79 00
 129+ 1097 55 6E 64 65  ULMSG:  defb    "Undefined Line",0
 129+ 109B 66 69 6E 65
 129+ 109F 64 20 4C 69
 129+ 10A3 6E 65 00
 130+ 10A6 42 61 64 20  BSMSG:  defb    "Bad Subscript",0
 130+ 10AA 53 75 62 73
 130+ 10AE 63 72 69 70
 130+ 10B2 74 00
 131+ 10B4 52 65 2D 44  DDMSG:  defb    "Re-Dimensioned Array",0
 131+ 10B8 69 6D 65 6E
 131+ 10BC 73 69 6F 6E
 131+ 10C0 65 64 20 41
 131+ 10C4 72 72 61 79
 131+ 10C8 00
 132+ 10C9 44 69 76 69  DZMSG:  defb    "Division by Zero",0
 132+ 10CD 73 69 6F 6E
 132+ 10D1 20 62 79 20
 132+ 10D5 5A 65 72 6F
 132+ 10D9 00
 133+ 10DA 49 6C 6C 65  IDMSG:  defb    "Illegal Direct",0
 133+ 10DE 67 61 6C 20
 133+ 10E2 44 69 72 65
 133+ 10E6 63 74 00
 134+ 10E9 54 79 70 65  TMMSG:  defb    "Type Mis-match",0
 134+ 10ED 20 4D 69 73
 134+ 10F1 2D 6D 61 74
 134+ 10F5 63 68 00
 135+ 10F8 4F 75 74 20  OSMSG:  defb    "Out of String Space",0
 135+ 10FC 6F 66 20 53
 135+ 1100 74 72 69 6E
 135+ 1104 67 20 53 70
 135+ 1108 61 63 65 00
 136+ 110C 53 74 72 69  LSMSG:  defb    "String Too Long",0
 136+ 1110 6E 67 20 54
 136+ 1114 6F 6F 20 4C
 136+ 1118 6F 6E 67 00
 137+ 111C 53 74 72 69  STMSG:  defb    "String Formula Too Complex",0
 137+ 1120 6E 67 20 46
 137+ 1124 6F 72 6D 75
 137+ 1128 6C 61 20 54
 137+ 112C 6F 6F 20 43
 137+ 1130 6F 6D 70 6C
 137+ 1134 65 78 00
 138+ 1137 43 61 6E 27  CNMSG:  defb    "Can't Continue",0
 138+ 113B 74 20 43 6F
 138+ 113F 6E 74 69 6E
 138+ 1143 75 65 00
 139+ 1146 55 6E 64 65  UFMSG:  defb    "Undefined FN Function",0
 139+ 114A 66 69 6E 65
 139+ 114E 64 20 46 4E
 139+ 1152 20 46 75 6E
 139+ 1156 63 74 69 6F
 139+ 115A 6E 00
 140+ 115C 4D 69 73 73  MOMSG:  defb    "Missing Operand",0
 140+ 1160 69 6E 67 20
 140+ 1164 4F 70 65 72
 140+ 1168 61 6E 64 00
 141+ 116C 48 45 58 20  HXMSG:  defb    "HEX Format",0
 141+ 1170 46 6F 72 6D
 141+ 1174 61 74 00
 142+ 1177 42 49 4E 20  BNMSG:  defb    "BIN Format",0
 142+ 117B 46 6F 72 6D
 142+ 117F 61 74 00
 143+ 1182 4E 6F 20 47  GMMSG:  defb    "No Graphics Mode",0
 143+ 1186 72 61 70 68
 143+ 118A 69 63 73 20
 143+ 118E 4D 6F 64 65
 143+ 1192 00
 144+ 1193 53 65 72 69  SCMSG:  defb    "Serial Configuration",0
 144+ 1197 61 6C 20 43
 144+ 119B 6F 6E 66 69
 144+ 119F 67 75 72 61
 144+ 11A3 74 69 6F 6E
 144+ 11A7 00
 145+ 11A8 53 65 72 69  SAMSG:  defb    "Serial Port Already Open",0
 145+ 11AC 61 6C 20 50
 145+ 11B0 6F 72 74 20
 145+ 11B4 41 6C 72 65
 145+ 11B8 61 64 79 20
 145+ 11BC 4F 70 65 6E
 145+ 11C0 00
 146+ 11C1 53 65 72 69  SOMSG:  defb    "Serial Buffer Overrun",0
 146+ 11C5 61 6C 20 42
 146+ 11C9 75 66 66 65
 146+ 11CD 72 20 4F 76
 146+ 11D1 65 72 72 75
 146+ 11D5 6E 00
 147+ 11D7 48 45 4C 50  HPMSG:  defb    "HELP Call",0
 147+ 11DB 20 43 61 6C
 147+ 11DF 6C 00
 148+ 11E1
 149+ 11E1
 150+ 11E1              ;-----------------------------------------------------------------------------
 151+ 11E1              ; STARTING POINTS FOR BASIC BOOT
 152+ 11E1              ; COLD: reset every memory pointer, acting as a power-up boot
 153+ 11E1              ; WARM: preserve program in memory, keeping every current pointer
 154+ 11E1
 155+ 11E1 C3 E7 11     COLD:   jp      STARTB          ; Jump for cold start
 156+ 11E4 C3 95 12     WARM:   jp      WARMST          ; Jump for warm start
 157+ 11E7
 158+ 11E7 C3 EE 11     STARTB: jp      CSTART          ; Jump to initialise
 159+ 11EA C2 1C                defw    DEINT           ; Get integer -32768 to 32767
 160+ 11EC 87 24                defw    ABPASS          ; Return integer in AB
 161+ 11EE 21 A3 51     CSTART: ld      HL,WRKSPC       ; Start of workspace RAM
 162+ 11F1 F9                   ld      SP,HL           ; Set up a temporary stack
 163+ 11F2 C3 C9 3F             jp      INITST          ; Go to initialise
 164+ 11F5
 165+ 11F5 21 62 15     INIT:   ld      HL,INITAB       ; Initialise workspace
 166+ 11F8 01 DC 00             ld      BC,INITBE-INITAB+3; Bytes to copy
 167+ 11FB 11 A3 51             ld      DE,WRKSPC       ; Into workspace RAM
 168+ 11FE ED B0                ldir                    ; Copy data
 169+ 1200 EB                   ex      DE,HL           ; Copy DE into HL
 170+ 1201 F9                   ld      SP,HL           ; Temporary stack
 171+ 1202 CD 25 18             call    CLREG           ; Clear registers and stack
 172+ 1205 CD D9 1E             call    PRNTCRLF        ; Output CRLF
 173+ 1208 32 D6 52             ld      (BUFFER+88+1),A ; Mark end of buffer
 174+ 120B 32 8B 53             ld      (PROGST),A      ; Initialise program area
 175+ 120E 18 13                jr      MNOASK          ; usually, don't ask for memory top (only when there are errors)
 176+ 1210 21 FC 12     MSIZE:  ld      HL,MEMMSG       ; Point to message
 177+ 1213 CD A5 25             call    PRS             ; Output "Memory size"
 178+ 1216 CD 42 18             call    PROMPT          ; Get input with '?'
 179+ 1219 CD 17 09             call    CURSOR_ON       ; enable cursor
 180+ 121C CD 0C 1C             call    GETCHR          ; Get next character
 181+ 121F B7                   or      A               ; Set flags
 182+ 1220 C2 38 12             jp      NZ,TSTMEM       ; If number - Test if RAM there
 183+ 1223 21 EF 53     MNOASK: ld      HL,STLOOK       ; Point to start of RAM
 184+ 1226 23           MLOOP:  inc     HL              ; Next byte
 185+ 1227 7C                   ld      A,H             ; Above address FFFF ?
 186+ 1228 B5                   or      L
 187+ 1229 CA 4A 12             jp      Z,SETTOP        ; Yes - 64K RAM
 188+ 122C 7E                   ld      A,(HL)          ; Get contents
 189+ 122D 47                   ld      B,A             ; Save it
 190+ 122E 2F                   cpl                     ; Flip all bits
 191+ 122F 77                   ld      (HL),A          ; Put it back
 192+ 1230 BE                   cp      (HL)            ; RAM there if same
 193+ 1231 70                   ld      (HL),B          ; Restore old contents
 194+ 1232 CA 26 12             jp      Z,MLOOP         ; If RAM - test next byte
 195+ 1235 C3 4A 12             jp      SETTOP          ; Top of RAM found
 196+ 1238
 197+ 1238 CD DC 1C     TSTMEM: call    ATOH            ; Get high memory into DE
 198+ 123B B7                   or      A               ; Set flags on last byte
 199+ 123C C2 C9 16             jp      NZ,SNERR        ; ?SN Error if bad character
 200+ 123F EB                   ex      DE,HL           ; Address into HL
 201+ 1240 2B                   dec     HL              ; Back one byte
 202+ 1241 3E D9                ld      A,%11011001     ; Test byte
 203+ 1243 46                   ld      B,(HL)          ; Get old contents
 204+ 1244 77                   ld      (HL),A          ; Load test byte
 205+ 1245 BE                   cp      (HL)            ; RAM there if same
 206+ 1246 70                   ld      (HL),B          ; Restore old contents
 207+ 1247 C2 10 12             jp      NZ,MSIZE        ; Ask again if no RAM
 208+ 124A
 209+ 124A CD 2C 09     SETTOP: call    CURSOR_OFF      ; disable cursor
 210+ 124D 2B                   dec     HL              ; Back one byte
 211+ 124E 11 EE 53             ld      DE,STLOOK-1     ; See if enough RAM
 212+ 1251 CD BD 19             call    CPDEHL          ; Compare DE with HL
 213+ 1254 DA 10 12             jp      C,MSIZE         ; Ask again if not enough RAM
 214+ 1257 3A 67 53             ld      A,(DOS_EN)      ; read if the user enabled/disabled DOS while booting
 215+ 125A 1F                   rra                     ; is DOS disabled?
 216+ 125B 30 04                jr      NC,NODOS        ; yes, so jump over
 217+ 125D 11 00 FE             ld      DE,0-512        ; no, so reserve 512 bytes on top of RAM...
 218+ 1260 19                   add     HL,DE           ; ...for I/O buffer
 219+ 1261 11 9C FF     NODOS:  ld      DE,0-100        ; 100 Bytes string space
 220+ 1264 22 DB 52             ld      (LSTRAM),HL     ; Save last available RAM
 221+ 1267 19                   add     HL,DE           ; Allocate string space
 222+ 1268 22 F2 51             ld      (STRSPC),HL     ; Save string space
 223+ 126B CD 00 18             call    CLRPTR          ; Clear program area
 224+ 126E 2A F2 51             ld      HL,(STRSPC)     ; Get end of memory
 225+ 1271 11 EF FF             ld      DE,0-17         ; Offset for free bytes
 226+ 1274 19                   add     HL,DE           ; Adjust HL
 227+ 1275 11 8B 53             ld      DE,PROGST       ; Start of program text
 228+ 1278 7D                   ld      A,L             ; Get LSB
 229+ 1279 93                   sub     E               ; Adjust it
 230+ 127A 6F                   ld      L,A             ; Re-save
 231+ 127B 7C                   ld      A,H             ; Get MSB
 232+ 127C 9A                   sbc     A,D             ; Adjust it
 233+ 127D 67                   ld      H,A             ; Re-save
 234+ 127E E5                   push    HL              ; Save bytes free
 235+ 127F 21 BB 12             ld      HL,SIGNON       ; Sign-on message
 236+ 1282 CD A5 25             call    PRS             ; Output string
 237+ 1285 21 A4 12             ld      HL,BLNSPC       ; Empty space
 238+ 1288 CD A5 25             call    PRS             ; Output string
 239+ 128B E1                   pop     HL              ; Get bytes free back
 240+ 128C CD 44 30             call    PRNTHL          ; Output amount of free memory
 241+ 128F 21 AD 12             ld      HL,BFREE        ; " Bytes free" message
 242+ 1292 CD A5 25             call    PRS             ; Output string
 243+ 1295
 244+ 1295 31 82 52     WARMST: ld      SP,STACK        ; Temporary stack
 245+ 1298 CD 25 18     BRKRET: call    CLREG           ; Clear registers and stack
 246+ 129B CD 60 3D             call    RESFN           ; reset FN keys and auto-repeat
 247+ 129E CD 17 09             call    CURSOR_ON       ; enable cursor
 248+ 12A1 C3 23 17             jp      PRNTOK          ; Go to get command line
 249+ 12A4
 250+ 12A4 20 20 20 20  BLNSPC: defb    "        ",0    ; 8 empty cells to align the "XXXX Bytes free" message
 250+ 12A8 20 20 20 20
 250+ 12AC 00
 251+ 12AD 20 42 79 74  BFREE:  defb    " Bytes free",CR,CR,0
 251+ 12B1 65 73 20 66
 251+ 12B5 72 65 65 0D
 251+ 12B9 0D 00
 252+ 12BB
 253+ 12BB 4C 4D 38 30  SIGNON: defb    "LM80C BASIC 3.18 ",251,"2021 L.Miliani"
 253+ 12BF 43 20 42 41
 253+ 12C3 53 49 43 20
 253+ 12C7 33 2E 31 38
 253+ 12CB 20 FB 32 30
 253+ 12CF 32 31 20 4C
 253+ 12D3 2E 4D 69 6C
 253+ 12D7 69 61 6E 69
 254+ 12DB 20 5A 38 30          defb    " Z80 BASIC 4.7  ",251,"1978 Microsoft",CR,0
 254+ 12DF 20 42 41 53
 254+ 12E3 49 43 20 34
 254+ 12E7 2E 37 20 20
 254+ 12EB FB 31 39 37
 254+ 12EF 38 20 4D 69
 254+ 12F3 63 72 6F 73
 254+ 12F7 6F 66 74 0D
 254+ 12FB 00
 255+ 12FC
 256+ 12FC 4D 65 6D 6F  MEMMSG: defb    "Memory top",0
 256+ 1300 72 79 20 74
 256+ 1304 6F 70 00
 257+ 1307
 258+ 1307              ; The following list reports all the functions supported by the interpreter.
 259+ 1307              ; To add a custom function, the user must first insert the reserved word here,
 260+ 1307              ; then into the list of the reserved words below, and finally must increment the
 261+ 1307              ; ZSGN token value and all the following ones after ZSGN by 1 for every added
 262+ 1307              ; function.
 263+ 1307
 264+ 1307              ; FUNCTION ADDRESS TABLE (this is a sort of offset table)
 265+ 1307              ; this list must be coherent with the tokens' functions list. This means that every
 266+ 1307              ; entry here must have the corresponding entry in the tokens list.
 267+ 1307 B9 2E        FNCTAB: defw    SGN
 268+ 1309 4F 24                defw    TMR         ; added by Leonardo Miliani
 269+ 130B 7D 2F                defw    INT
 270+ 130D CF 2E                defw    ABS_        ; _ necessary for assembler warning
 271+ 130F A9 51                defw    USR
 272+ 1311 65 24                defw    FRE
 273+ 1313 E0 28                defw    INP
 274+ 1315 93 24                defw    POS
 275+ 1317 43 31                defw    SQR
 276+ 1319 22 32                defw    RND
 277+ 131B 0D 2D                defw    LOG
 278+ 131D 91 31                defw    EXP
 279+ 131F 97 32                defw    COS
 280+ 1321 9D 32                defw    SIN
 281+ 1323 FE 32                defw    TAN
 282+ 1325 13 33                defw    ATN
 283+ 1327 BC 29                defw    PEEK
 284+ 1329 7E 33                defw    DEEK
 285+ 132B C3 29                defw    VPEEK       ; added by Leonardo Miliani
 286+ 132D 92 2B                defw    VSTAT       ; added by Leonardo Miliani
 287+ 132F 9D 2B                defw    SSTAT       ; added by Leonardo Miliani
 288+ 1331 B1 2B                defw    INKEY       ; added by Leonardo Miliani
 289+ 1333 D5 36                defw    POINT       ; added by Leonardo Miliani
 290+ 1335 77 27                defw    INSTR       ; added by Leonardo Miliani
 291+ 1337 17 27                defw    LEN
 292+ 1339 2F 25                defw    STR
 293+ 133B A7 28                defw    VAL
 294+ 133D 26 27                defw    ASC
 295+ 133F 37 27                defw    CHR
 296+ 1341 C4 3E                defw    HEX         ; added by Grant Searle
 297+ 1343 55 3F                defw    BIN         ; added by Grant Searle
 298+ 1345 47 27                defw    LEFT
 299+ 1347 6D 28                defw    RIGHT
 300+ 1349 77 28                defw    MID
 301+ 134B
 302+ 134B              ; RESERVED WORD LIST
 303+ 134B              ; Here are all the reserved words used by the interpreter
 304+ 134B              ; To add custom functions/commands, the user must insert the keyword
 305+ 134B              ; in this list, following the schematic
 306+ 134B C5 4E 44     WORDS:  defb    'E'+$80,"ND"            ; from here the list contains the COMMANDS
 307+ 134E C6 4F 52             defb    'F'+$80,"OR"
 308+ 1351 CE 45 58 54          defb    'N'+$80,"EXT"
 309+ 1355 C4 41 54 41          defb    'D'+$80,"ATA"
 310+ 1359 C9 4E 50 55          defb    'I'+$80,"NPUT"
 310+ 135D 54
 311+ 135E C4 49 4D             defb    'D'+$80,"IM"
 312+ 1361 D2 45 41 44          defb    'R'+$80,"EAD"
 313+ 1365 CC 45 54             defb    'L'+$80,"ET"
 314+ 1368 C7 4F 54 4F          defb    'G'+$80,"OTO"
 315+ 136C D2 55 4E             defb    'R'+$80,"UN"
 316+ 136F C9 46                defb    'I'+$80,"F"
 317+ 1371 D2 45 53 54          defb    'R'+$80,"ESTORE"
 317+ 1375 4F 52 45
 318+ 1378 C7 4F 53 55          defb    'G'+$80,"OSUB"
 318+ 137C 42
 319+ 137D D2 45 54 55          defb    'R'+$80,"ETURN"
 319+ 1381 52 4E
 320+ 1383 D2 45 4D             defb    'R'+$80,"EM"            ; original REM
 321+ 1386 D3 54 4F 50          defb    'S'+$80,"TOP"
 322+ 138A CF 55 54             defb    'O'+$80,"UT"
 323+ 138D CF 4E                defb    'O'+$80,"N"
 324+ 138F C6 49 4C 45          defb    'F'+$80,"ILES"
 324+ 1393 53
 325+ 1394 C5 52 41 53          defb    'E'+$80,"RASE"          ; added by Leonardo Miliani
 325+ 1398 45
 326+ 1399 D7 41 49 54          defb    'W'+$80,"AIT"
 327+ 139D C4 45 46             defb    'D'+$80,"EF"
 328+ 13A0 D0 4F 4B 45          defb    'P'+$80,"OKE"
 329+ 13A4 C4 4F 4B 45          defb    'D'+$80,"OKE"
 330+ 13A8 D6 50 4F 4B          defb    'V'+$80,"POKE"          ; added by Leonardo Miliani
 330+ 13AC 45
 331+ 13AD D3 52 45 47          defb    'S'+$80,"REG"           ; added by Leonardo Miliani
 332+ 13B1 D6 52 45 47          defb    'V'+$80,"REG"           ; added by Leonardo Miliani
 333+ 13B5 D3 43 52 45          defb    'S'+$80,"CREEN"         ; changed by Leonardo Miliani
 333+ 13B9 45 4E
 334+ 13BB CC 4F 43 41          defb    'L'+$80,"OCATE"         ; added by Leonardo Miliani
 334+ 13BF 54 45
 335+ 13C1 D3 4F 55 4E          defb    'S'+$80,"OUND"          ; added by Leonardo Miliani
 335+ 13C5 44
 336+ 13C6 D6 4F 4C 55          defb    'V'+$80,"OLUME"         ; added by Leonardo Miliani
 336+ 13CA 4D 45
 337+ 13CC D0 41 55 53          defb    'P'+$80,"AUSE"          ; added by Leonardo Miliani
 337+ 13D0 45
 338+ 13D1 C3 4F 4C 4F          defb    'C'+$80,"OLOR"          ; added by Leonardo Miliani
 338+ 13D5 52
 339+ 13D6 D0 4C 4F 54          defb    'P'+$80,"LOT"           ; added by Leonardo Miliani
 340+ 13DA C4 52 41 57          defb    'D'+$80,"RAW"           ; added by Leonardo Miliani
 341+ 13DE C3 49 52 43          defb    'C'+$80,"IRCLE"         ; added by Leonardo Miliani
 341+ 13E2 4C 45
 342+ 13E4 D0 41 49 4E          defb    'P'+$80,"AINT"          ; added by Leonardo Miliani
 342+ 13E8 54
 343+ 13E9 D3 45 52 49          defb    'S'+$80,"ERIAL"         ; added by Leonardo Miliani
 343+ 13ED 41 4C
 344+ 13EF C8 45 4C 50          defb    'H'+$80,"ELP"           ; changed by Leonardo Miliani - was LINES
 345+ 13F3 C3 4C 53             defb    'C'+$80,"LS"            ; restored command
 346+ 13F6 CB 45 59             defb    'K'+$80,"EY"            ; added by Leonardo Miliani
 347+ 13F9 CE 4D 49             defb    'N'+$80,"MI"            ; added by Leonardo Miliani
 348+ 13FC C7 50 52 49          defb    'G'+$80,"PRINT"         ; added by Leonardo Miliani
 348+ 1400 4E 54
 349+ 1402 D7 49 44 54          defb    'W'+$80,"IDTH"
 349+ 1406 48
 350+ 1407 D3 59 53             defb    'S'+$80,"YS"            ; added by Leonardo Miliani
 351+ 140A D2 45 53 45          defb    'R'+$80,"ESET"          ; changed by Leonardo Miliani
 351+ 140E 54
 352+ 140F C5 4C 53 45          defb    'E'+$80,"LSE"           ; added by Leonardo Miliani
 353+ 1413 D0 52 49 4E          defb    'P'+$80,"RINT"
 353+ 1417 54
 354+ 1418 C3 4F 4E 54          defb    'C'+$80,"ONT"
 355+ 141C CC 49 53 54          defb    'L'+$80,"IST"
 356+ 1420 C3 4C 45 41          defb    'C'+$80,"LEAR"
 356+ 1424 52
 357+ 1425 CC 4F 41 44          defb    'L'+$80,"OAD"
 358+ 1429 D3 41 56 45          defb    'S'+$80,"AVE"
 359+ 142D CE 45 57             defb    'N'+$80,"EW"
 360+ 1430 D4 41 42 28          defb    'T'+$80,"AB("
 361+ 1434 D4 4F                defb    'T'+$80,"O"
 362+ 1436 C6 4E                defb    'F'+$80,"N"
 363+ 1438 D3 50 43 28          defb    'S'+$80,"PC("
 364+ 143C D4 48 45 4E          defb    'T'+$80,"HEN"
 365+ 1440 CE 4F 54             defb    'N'+$80,"OT"
 366+ 1443 D3 54 45 50          defb    'S'+$80,"TEP"
 367+ 1447                      ; from here: operators
 368+ 1447 AB                   defb    '+'+$80
 369+ 1448 AD                   defb    '-'+$80
 370+ 1449 AA                   defb    '*'+$80
 371+ 144A AF                   defb    '/'+$80
 372+ 144B A5                   defb    '%'+$80
 373+ 144C A3                   defb    '#'+$80
 374+ 144D DE                   defb    '^'+$80
 375+ 144E C1 4E 44             defb    'A'+$80,"ND"
 376+ 1451 D8 4F 52             defb    'X'+$80,"OR"
 377+ 1454 CF 52                defb    'O'+$80,"R"
 378+ 1456 BE                   defb    '>'+$80
 379+ 1457 BD                   defb    '='+$80
 380+ 1458 BC                   defb    '<'+$80
 381+ 1459
 382+ 1459                      ; from here there are the tokens' FUNCTIONS list
 383+ 1459                      ; this list must be coherent with the functions list above
 384+ 1459 D3 47 4E             defb    'S'+$80,"GN"
 385+ 145C D4 4D 52             defb    'T'+$80,"MR"            ; added by Leonardo Miliani
 386+ 145F C9 4E 54             defb    'I'+$80,"NT"
 387+ 1462 C1 42 53             defb    'A'+$80,"BS"
 388+ 1465 D5 53 52             defb    'U'+$80,"SR"
 389+ 1468 C6 52 45             defb    'F'+$80,"RE"
 390+ 146B C9 4E 50             defb    'I'+$80,"NP"
 391+ 146E D0 4F 53             defb    'P'+$80,"OS"
 392+ 1471 D3 51 52             defb    'S'+$80,"QR"
 393+ 1474 D2 4E 44             defb    'R'+$80,"ND"
 394+ 1477 CC 4F 47             defb    'L'+$80,"OG"
 395+ 147A C5 58 50             defb    'E'+$80,"XP"
 396+ 147D C3 4F 53             defb    'C'+$80,"OS"
 397+ 1480 D3 49 4E             defb    'S'+$80,"IN"
 398+ 1483 D4 41 4E             defb    'T'+$80,"AN"
 399+ 1486 C1 54 4E             defb    'A'+$80,"TN"
 400+ 1489 D0 45 45 4B          defb    'P'+$80,"EEK"
 401+ 148D C4 45 45 4B          defb    'D'+$80,"EEK"
 402+ 1491 D6 50 45 45          defb    'V'+$80,"PEEK"          ; added by Leonardo Miliani
 402+ 1495 4B
 403+ 1496 D6 53 54 41          defb    'V'+$80,"STAT"          ; added by Leonardo Miliani
 403+ 149A 54
 404+ 149B D3 53 54 41          defb    'S'+$80,"STAT"          ; added by Leonardo Miliani
 404+ 149F 54
 405+ 14A0 C9 4E 4B 45          defb    'I'+$80,"NKEY"          ; added by Leonardo Miliani
 405+ 14A4 59
 406+ 14A5 D0 4F 49 4E          defb    'P'+$80,"OINT"          ; added by Leonardo Miliani
 406+ 14A9 54
 407+ 14AA C9 4E 53 54          defb    'I'+$80,"NSTR"          ; added by Leonardo Miliani
 407+ 14AE 52
 408+ 14AF CC 45 4E             defb    'L'+$80,"EN"
 409+ 14B2 D3 54 52 24          defb    'S'+$80,"TR$"
 410+ 14B6 D6 41 4C             defb    'V'+$80,"AL"
 411+ 14B9 C1 53 43             defb    'A'+$80,"SC"
 412+ 14BC C3 48 52 24          defb    'C'+$80,"HR$"
 413+ 14C0 C8 45 58 24          defb    'H'+$80,"EX$"           ; added by Grant Searle
 414+ 14C4 C2 49 4E 24          defb    'B'+$80,"IN$"           ; added by Grant Searle
 415+ 14C8 CC 45 46 54          defb    'L'+$80,"EFT$"
 415+ 14CC 24
 416+ 14CD D2 49 47 48          defb    'R'+$80,"IGHT$"
 416+ 14D1 54 24
 417+ 14D3 CD 49 44 24          defb    'M'+$80,"ID$"
 418+ 14D7 80                   defb    $80                     ; End-of-list marker
 419+ 14D8
 420+ 14D8              ; KEYWORD ADDRESS TABLE
 421+ 14D8              ; this list must be coherent with the commands'
 422+ 14D8              ; tokens list above
 423+ 14D8 56 1C        WORDTB: defw    PEND
 424+ 14DA 53 1B                defw    FOR
 425+ 14DC 52 20                defw    NEXT
 426+ 14DE B5 1D                defw    DATA
 427+ 14E0 4F 1F                defw    INPUT
 428+ 14E2 A7 22                defw    DIM
 429+ 14E4 89 1F                defw    READ
 430+ 14E6 CC 1D                defw    LET
 431+ 14E8 72 1D                defw    GOTO
 432+ 14EA 4D 1D                defw    RUN
 433+ 14EC 44 1E                defw    IF
 434+ 14EE 1C 1C                defw    RESTOR
 435+ 14F0 61 1D                defw    GOSUB
 436+ 14F2 90 1D                defw    RETURN
 437+ 14F4 B7 1D                defw    REM         ; original REM
 438+ 14F6 54 1C                defw    STOP
 439+ 14F8 EC 28                defw    POUT
 440+ 14FA 26 1E                defw    ON
 441+ 14FC C2 3E                defw    FILES       ; changed by Leonardo Miliani - was NULL
 442+ 14FE C3 3E                defw    ERASE       ; added by Leonardo Miliani
 443+ 1500 F2 28                defw    WAIT
 444+ 1502 9B 24                defw    DEF
 445+ 1504 E6 29                defw    POKE
 446+ 1506 89 33                defw    DOKE
 447+ 1508 EB 29                defw    VPOKE       ; added by Leonardo Miliani
 448+ 150A 28 2A                defw    SREG        ; added by Leonardo Miliani
 449+ 150C 76 2B                defw    VREG        ; added by Leonardo Miliani
 450+ 150E BF 33                defw    SCREEN      ; new behaviour: now it sets up a graphics mode (Leonardo Miliani)
 451+ 1510 F6 29                defw    LOCATE      ; added by Leonardo Miliani
 452+ 1512 82 2A                defw    SOUND       ; added by Leonardo Miliani
 453+ 1514 49 2A                defw    VOLUME      ; added by Leonardo Miliani
 454+ 1516 A0 33                defw    PAUSE       ; added by Leonardo Miliani
 455+ 1518 3A 34                defw    COLOR       ; added by Leonardo Miliani
 456+ 151A 28 37                defw    PLOT        ; added by Leonardo Miliani
 457+ 151C BB 37                defw    DRAW        ; added by Leonardo Miliani
 458+ 151E F1 38                defw    CIRCLE      ; added by Leonardo Miliani
 459+ 1520 E5 35                defw    PAINT       ; added by Leonardo Miliani
 460+ 1522 F6 3A                defw    SERIAL      ; added by Leonardo Miliani
 461+ 1524 38 3D                defw    HELP        ; changed by Leonardo Miliani - was LINES
 462+ 1526 62 33                defw    CLS
 463+ 1528 53 3D                defw    KEY         ; added by Leonardo Miliani
 464+ 152A 34 29                defw    NMI         ; added by Leonardo Miliani
 465+ 152C F5 34                defw    GPRINT      ; added by Leonardo Miliani
 466+ 152E 76 33                defw    WIDTH
 467+ 1530 8E 29                defw    SYS         ; added by Leonardo Miliani
 468+ 1532 BA 3F                defw    RESET       ; new behaviour: now it resets the system
 469+ 1534 B9 1D                defw    REM+2       ; ELSE: added by Leonardo Miliani
 470+ 1536 76 1E                defw    PRINT
 471+ 1538 88 1C                defw    CONT
 472+ 153A 2A 1A                defw    LIST
 473+ 153C 01 1D                defw    CLEAR
 474+ 153E C0 3E                defw    LOAD        ; re-implemented by Leonardo Miliani (was CLOAD)
 475+ 1540 C1 3E                defw    SAVE        ; re-implemented by Leonardo Miliani (was CSAVE)
 476+ 1542 FF 17                defw    NEW
 477+ 1544
 478+ 1544              ; RESERVED WORD TOKEN VALUES
 479+ 1544              ; if you add a function or command you must increment by 1
 480+ 1544              ; the values below. Pay attention that you must increment only the
 481+ 1544              ; values AFTER the position where you entered the function/command word
 482+ 1544              ; in the "Reserver word list" above. I.E.: VPOKE has been added between
 483+ 1544              ; DOKE and SCREEN, and since REM is the reserved work listed below
 484+ 1544              ; that is before the point where VPOKE has been entered, every entry
 485+ 1544              ; after REM has been incremented.
 486+ 1544              ; Another example: when TMR has been added, since it's a function, every
 487+ 1544              ; entry after & included ZSGN must be checked (read below)
 488+ 1544
 489+ 1544              ZEND    equ     $80             ; END        <-- from here, there are the commands
 490+ 1544              ZFOR    equ     $81             ; FOR
 491+ 1544              ZDATA   equ     $83             ; DATA
 492+ 1544              ZGOTO   equ     $88             ; GOTO
 493+ 1544              ZGOSUB  equ     $8C             ; GOSUB
 494+ 1544              ZREM    equ     $8E             ; REM
 495+ 1544              ZELSE   equ     $AE             ; ELSE
 496+ 1544              ZPRINT  equ     $AF             ; PRINT
 497+ 1544              ZNEW    equ     $B5             ; NEW
 498+ 1544
 499+ 1544              ZTAB    equ     $B6             ; TAB
 500+ 1544              ZTO     equ     $B7             ; TO
 501+ 1544              ZFN     equ     $B8             ; FN
 502+ 1544              ZSPC    equ     $B9             ; SPC
 503+ 1544              ZTHEN   equ     $BA             ; THEN
 504+ 1544              ZNOT    equ     $BB             ; NOT
 505+ 1544              ZSTEP   equ     $BC             ; STEP
 506+ 1544
 507+ 1544              ZPLUS   equ     $BD             ; +         <-- from here, there are the math operators
 508+ 1544              ZMINUS  equ     $BE             ; -
 509+ 1544              ZTIMES  equ     $BF             ; *
 510+ 1544              ZDIV    equ     $C0             ; /
 511+ 1544              ZMOD    equ     $C1             ; %
 512+ 1544              ZDINT   equ     $C2             ; #
 513+ 1544              ZOR     equ     $C6             ; OR
 514+ 1544              ZGTR    equ     $C7             ; >
 515+ 1544              ZEQUAL  equ     $C8             ; M
 516+ 1544              ZLTH    equ     $C9             ; <
 517+ 1544
 518+ 1544              ZSGN    equ     $CA             ; SGN       <-- from here, there are the functions
 519+ 1544              ZPOINT  equ     $E0             ; ZPOINT    <-- if the user enters a custom function, between
 520+ 1544                                              ;               SGN and POINT, he/she must increment this pointer by 1
 521+ 1544              ZINSTR  equ     $E1             ; ZINSTR    <-- same here
 522+ 1544              ZLEFT   equ     $E9             ; LEFT$     <-- if the user enters a custom function anywhere,
 523+ 1544                                              ;               he/she must increment this pointer by 1
 524+ 1544
 525+ 1544              ; ARITHMETIC PRECEDENCE TABLE
 526+ 1544              ; in the formulas below, <last> is a number stored into the stack that must be retrieved
 527+ 1544              ; with POP BC, POP DE; FPREG is a f.p. number store into the RAM register FPREG
 528+ 1544 79           PRITAB: defb    $79             ; Precedence value
 529+ 1545 2B 30                defw    PADD            ; FPREG = <last> + FPREG
 530+ 1547
 531+ 1547 79                   defb    $79             ; Precedence value
 532+ 1548 0E 2C                defw    PSUB            ; FPREG = <last> - FPREG
 533+ 154A
 534+ 154A 7C                   defb    $7C             ; Precedence value
 535+ 154B 4C 2D                defw    MULT            ; PPREG = <last> * FPREG
 536+ 154D
 537+ 154D 7C                   defb    $7C             ; Precedence value
 538+ 154E FE 2D                defw    DIV             ; FPREG = <last> / FPREG
 539+ 1550
 540+ 1550 7C                   defb    $7C             ; Precedence value
 541+ 1551 A9 2D                defw    MOD             ; FPREG = INT(<last>)-(INT(FPREG)*INT(<last>/FPREG))
 542+ 1553
 543+ 1553 7C                   defb    $7C             ; precedence value
 544+ 1554 A1 2D                defw    DINT            ; FPREG = INT(<last> / FPREG )
 545+ 1556
 546+ 1556 7F                   defb    $7F             ; Precedence value
 547+ 1557 4C 31                defw    POWER           ; FPREG = <last> ^ FPREG
 548+ 1559
 549+ 1559 50                   defb    $50             ; Precedence value
 550+ 155A F0 21                defw    PAND            ; FPREG = <last> AND FPREG
 551+ 155C
 552+ 155C 4A                   defb    $4A             ; Precedence value
 553+ 155D F8 21                defw    PXOR            ; FPREG = <last> XOR FPREG
 554+ 155F
 555+ 155F 46                   defb    $46             ; Precedence value
 556+ 1560 F3 21                defw    POR             ; FPREG = <last> OR FPREG
 557+ 1562
 558+ 1562
 559+ 1562              ; INITIALISATION TABLE -------------------------------------------------------
 560+ 1562              ; these values are copied into RAM at startup
 561+ 1562 C3 95 12     INITAB: jp      WARMST          ; Warm start jump
 562+ 1565 ED 45 00             defb    $ED,$45,$00     ; RETN + NOP for default NMI service routine
 563+ 1568 C3 D7 1C             jp      FCERR           ; "USR (X)" jump (Set to Error)
 564+ 156B D3 00                out     (0),A           ; "out p,n" skeleton
 565+ 156D C9                   ret
 566+ 156E D6 00                sub     $00             ; Division support routine
 567+ 1570 6F                   ld      L,A
 568+ 1571 7C                   ld      A,H
 569+ 1572 DE 00                sbc     A,$00
 570+ 1574 67                   ld      H,A
 571+ 1575 78                   ld      A,B
 572+ 1576 DE 00                sbc     A,$00
 573+ 1578 47                   ld      B,A
 574+ 1579 3E 00                ld      A,$00
 575+ 157B C9                   ret
 576+ 157C 00 00 00             defb    $00,$00,$00     ; Random number seed table used by RND
 577+ 157F 35 4A CA 99          defb    $35,$4A,$CA,$99 ;-2.65145E+07
 578+ 1583 39 1C 76 98          defb    $39,$1C,$76,$98 ; 1.61291E+07
 579+ 1587 22 95 B3 98          defb    $22,$95,$B3,$98 ;-1.17691E+07
 580+ 158B 0A DD 47 98          defb    $0A,$DD,$47,$98 ; 1.30983E+07
 581+ 158F 53 D1 99 99          defb    $53,$D1,$99,$99 ;-2-01612E+07
 582+ 1593 0A 1A 9F 98          defb    $0A,$1A,$9F,$98 ;-1.04269E+07
 583+ 1597 65 BC CD 98          defb    $65,$BC,$CD,$98 ;-1.34831E+07
 584+ 159B D6 77 3E 98          defb    $D6,$77,$3E,$98 ; 1.24825E+07
 585+ 159F 52 C7 4F 80          defb    $52,$C7,$4F,$80 ; Last random number
 586+ 15A3 DB 00                in      A,($00)         ; INP (x) skeleton
 587+ 15A5 C9                   ret
 588+ 15A6 FF                   defb    $FF             ; Terminal width (255 = no auto CRLF)
 589+ 15A7 14                   defb    $14             ; Width for commas (at reset, 3 columns, for G1 mode)
 590+ 15A8 00                   defb    $00             ; No nulls after input bytes
 591+ 15A9 00                   defb    $00             ; Output enabled (^O off)
 592+ 15AA 00 00                defw    $00             ; Array load/save check sum
 593+ 15AC 00                   defb    $00             ; Break not by NMI
 594+ 15AD 00                   defb    $00             ; Break flag
 595+ 15AE C3 43 19             jp      TTYLIN          ; Input reflection (set to TTY)
 596+ 15B1 EF 53                defw    STLOOK          ; Temp string space
 597+ 15B3 FE FF                defw    -2              ; Current line number (cold)
 598+ 15B5 FF FF                defw    -1              ; Current line with errors (no errors)
 599+ 15B7 40           AUTORP: defb    $40             ; delay for key auto-repeat start
 600+ 15B8 08                   defb    $08             ; auto-repeat delay
 601+ 15B9 4C 49 53 54  DEFFNKS:defm    "LIST",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 1
 601+ 15BD 0D 00 00 00
 601+ 15C1 00 00 00 00
 601+ 15C5 00 00 00 00
 602+ 15C9 52 55 4E 0D          defm    "RUN",13,0,0,0,0,0,0,0,0,0,0,0,0    ; KEY 2
 602+ 15CD 00 00 00 00
 602+ 15D1 00 00 00 00
 602+ 15D5 00 00 00 00
 603+ 15D9 53 43 52 45          defm    "SCREEN1",13,0,0,0,0,0,0,0,0        ; KEY 3
 603+ 15DD 45 4E 31 0D
 603+ 15E1 00 00 00 00
 603+ 15E5 00 00 00 00
 604+ 15E9 43 4F 4C 4F          defm    "COLOR1,15,5",13,0,0,0,0            ; KEY 4
 604+ 15ED 52 31 2C 31
 604+ 15F1 35 2C 35 0D
 604+ 15F5 00 00 00 00
 605+ 15F9 53 45 52 49          defm    "SERIAL1,38400",13,0,0              ; KEY 5
 605+ 15FD 41 4C 31 2C
 605+ 1601 33 38 34 30
 605+ 1605 30 0D 00 00
 606+ 1609 53 43 52 45          defm    "SCREEN2",13,0,0,0,0,0,0,0,0        ; KEY 6
 606+ 160D 45 4E 32 0D
 606+ 1611 00 00 00 00
 606+ 1615 00 00 00 00
 607+ 1619 43 4F 4E 54          defm    "CONT",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 7
 607+ 161D 0D 00 00 00
 607+ 1621 00 00 00 00
 607+ 1625 00 00 00 00
 608+ 1629 48 45 4C 50          defm    "HELP",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 8 (HELP KEY)
 608+ 162D 0D 00 00 00
 608+ 1631 00 00 00 00
 608+ 1635 00 00 00 00
 609+ 1639 8C 53                defw    PROGST+1        ; Start of program text
 610+ 163B              INITBE:
 611+ 163B
 612+ 163B              ; END OF INITIALISATION TABLE ---------------------------------------------------
 613+ 163B
 614+ 163B 20 45 72 72  ERRMSG: defb    " Error",0
 614+ 163F 6F 72 00
 615+ 1642 20 69 6E 20  INMSG:  defb    " in ",0
 615+ 1646 00
 616+ 1647              ZERBYT  equ     $-1             ; A zero byte
 617+ 1647 4F 6B 0D 00  OKMSG:  defb    "Ok",CR,0,0
 617+ 164B 00
 618+ 164C 42 72 65 61  BRKMSG: defb    "Break",0
 618+ 1650 6B 00
 619+ 1652
 620+ 1652 21 04 00     BAKSTK: ld      HL,$04          ; Look for "FOR" block with
 621+ 1655 39                   add     HL,SP           ; same index as specified
 622+ 1656 7E           LOKFOR: ld      A,(HL)          ; Get block ID
 623+ 1657 23                   inc     HL              ; Point to index address
 624+ 1658 FE 81                cp      ZFOR            ; Is it a "FOR" token
 625+ 165A C0                   ret     NZ              ; No - exit
 626+ 165B 4E                   ld      C,(HL)          ; BC = Address of "FOR" index
 627+ 165C 23                   inc     HL
 628+ 165D 46                   ld      B,(HL)
 629+ 165E 23                   inc     HL              ; Point to sign of STEP
 630+ 165F E5                   push    HL              ; Save pointer to sign
 631+ 1660 69                   ld      L,C             ; HL = address of "FOR" index
 632+ 1661 60                   ld      H,B
 633+ 1662 7A                   ld      A,D             ; See if an index was specified
 634+ 1663 B3                   or      E               ; DE = 0 if no index specified
 635+ 1664 EB                   ex      DE,HL           ; Specified index into HL
 636+ 1665 CA 6C 16             jp      Z,INDFND        ; Skip if no index given
 637+ 1668 EB                   ex      DE,HL           ; Index back into DE
 638+ 1669 CD BD 19             call    CPDEHL          ; Compare index with one given
 639+ 166C 01 0D 00     INDFND: ld      BC,16-3         ; Offset to next block
 640+ 166F E1                   pop     HL              ; Restore pointer to sign
 641+ 1670 C8                   ret     Z               ; Return if block found
 642+ 1671 09                   add     HL,BC           ; Point to next block
 643+ 1672 C3 56 16             jp      LOKFOR          ; Keep on looking
 644+ 1675
 645+ 1675 CD 8F 16     MOVUP:  call    ENFMEM          ; See if enough memory
 646+ 1678 C5           MOVSTR: push    BC              ; Save end of source
 647+ 1679 E3                   ex      (SP),HL         ; Swap source and dest" end
 648+ 167A C1                   pop     BC              ; Get end of destination
 649+ 167B CD BD 19     MOVLP:  call    CPDEHL          ; See if list moved
 650+ 167E 7E                   ld      A,(HL)          ; Get byte
 651+ 167F 02                   ld      (BC),A          ; Move it
 652+ 1680 C8                   ret     Z               ; Exit if all done
 653+ 1681 0B                   dec     BC              ; Next byte to move to
 654+ 1682 2B                   dec     HL              ; Next byte to move
 655+ 1683 C3 7B 16             jp      MOVLP           ; Loop until all bytes moved
 656+ 1686
 657+ 1686 E5           CHKSTK: push    HL              ; Save code string address
 658+ 1687 2A 6C 53             ld      HL,(ARREND)     ; Lowest free memory
 659+ 168A 06 00                ld      B,$00           ; BC = Number of levels to test
 660+ 168C 09                   add     HL,BC           ; 2 Bytes for each level
 661+ 168D 09                   add     HL,BC
 662+ 168E 3E                   defb    $3E             ; Skip "push HL"
 663+ 168F E5           ENFMEM: push    HL              ; Save code string address
 664+ 1690 3E D0                ld      A,$D0           ; LOW -48 ; 48 Bytes minimum RAM
 665+ 1692 95                   sub     L
 666+ 1693 6F                   ld      L,A
 667+ 1694 3E FF                ld      A,$FF           ; HIGH (-48) ; 48 Bytes minimum RAM
 668+ 1696 9C                   sbc     A,H
 669+ 1697 DA 9E 16             jp      C,OMERR         ; Not enough - ?OM Error
 670+ 169A 67                   ld      H,A
 671+ 169B 39                   add     HL,SP           ; Test if stack is overflowed
 672+ 169C E1                   pop     HL              ; Restore code string address
 673+ 169D D8                   ret     C               ; Return if enough memory
 674+ 169E 1E 0C        OMERR:  ld      E,OM            ; ?OM Error
 675+ 16A0 C3 DD 16             jp      ERROR
 676+ 16A3
 677+ 16A3
 678+ 16A3              ; if in graphics mode, return to text (called by "NOLIN" and "ERROR")
 679+ 16A3 F5           EXITGM: push    AF              ; store AF
 680+ 16A4 3A 14 53             ld      A,(SCR_MODE)    ; check screen mode
 681+ 16A7 FE 02                cp      $02             ; G2?
 682+ 16A9 CA B0 16             jp      Z,LDG1          ; yes, back to G1
 683+ 16AC FE 03                cp      $03             ; G3?
 684+ 16AE 20 11                jr      NZ,LDG1ND       ; no, so return
 685+ 16B0 E5           LDG1:   push    HL              ; store HL
 686+ 16B1 D5                   push    DE              ; store DE
 687+ 16B2 11 01 00             ld      DE,$0001        ; sprites set to defaults, G1 mode
 688+ 16B5 F3                   di                      ; disable INTs
 689+ 16B6 CD D1 03             call    initVDP         ; initialize VDP with mode pointed by E
 690+ 16B9 FB                   ei                      ; re-enable INTs
 691+ 16BA 3E 01                ld      A,$01           ; activate the...
 692+ 16BC 32 1E 53             ld      (PRNTVIDEO),A   ; ...video buffer...
 693+ 16BF D1                   pop     DE              ; retrieve DE
 694+ 16C0 E1                   pop     HL              ; retrieve HL
 695+ 16C1 F1           LDG1ND: pop     AF              ; retrieve AF
 696+ 16C2 C9                   ret                     ; return to caller
 697+ 16C3
 698+ 16C3
 699+ 16C3 2A F5 52     DATSNR: ld      HL,(DATLIN)     ; Get line of current DATA item
 700+ 16C6 22 F4 51             ld      (LINEAT),HL     ; Save as current line
 701+ 16C9 1E 02        SNERR:  ld      E,SN            ; ?SN Error
 702+ 16CB 01                   defb    $01             ; Skip "ld E,DZ"
 703+ 16CC 1E 14        DZERR:  ld      E,DZ            ; ?/0 Error
 704+ 16CE 01                   defb    $01             ; Skip "ld E,NF"
 705+ 16CF 1E 00        NFERR:  ld      E,NF            ; ?NF Error
 706+ 16D1 01                   defb    $01             ; Skip "ld E,DD"
 707+ 16D2 1E 12        DDERR:  ld      E,DD            ; ?DD Error
 708+ 16D4 01                   defb    $01             ; Skip "ld E,UF"
 709+ 16D5 1E 22        UFERR:  ld      E,UF            ; ?UF Error
 710+ 16D7 01                   defb    $01             ; Skip "ld E,OV
 711+ 16D8 1E 0A        OVERR:  ld      E,OV            ; ?OV Error
 712+ 16DA 01                   defb    $01             ; Skip "ld E,TM"
 713+ 16DB 1E 18        TMERR:  ld      E,TM            ; ?TM Error
 714+ 16DD
 715+ 16DD CD 25 18     ERROR:  call    CLREG           ; Clear registers and stack
 716+ 16E0 CD A3 16             call    EXITGM          ; exit from graphic modes
 717+ 16E3 32 EA 51             ld      (CTLOFG),A      ; Enable output (A is 0)
 718+ 16E6 CD 17 09             call    CURSOR_ON       ; enable cursor
 719+ 16E9 CD C7 1E             call    STTLIN          ; Start new line
 720+ 16EC 21 FD 0F             ld      HL,ERRTBL       ; Point to error codes
 721+ 16EF 57                   ld      D,A             ; D = 0 (A is 0)
 722+ 16F0 3E 3F                ld      A,'?'
 723+ 16F2 CD CE 19             call    OUTC            ; Output '?'
 724+ 16F5 19                   add     HL,DE           ; Offset to correct error code
 725+ 16F6 5E                   ld      E,(HL)          ; load pointer to error message
 726+ 16F7 23                   inc     HL              ; by loading LSB,
 727+ 16F8 56                   ld      D,(HL)          ; then MSB
 728+ 16F9 62 6B                ld      HL,DE           ; load pointer to HL
 729+ 16FB CD A5 25             call    PRS             ; Output error message
 730+ 16FE 21 3B 16             ld      HL,ERRMSG       ; "Error" message
 731+ 1701 CD A5 25     ERRIN:  call    PRS             ; Output message
 732+ 1704 2A F4 51             ld      HL,(LINEAT)     ; Get line of error
 733+ 1707 11 FE FF             ld      DE,-2           ; Cold start error if -2
 734+ 170A CD BD 19             call    CPDEHL          ; See if cold start error
 735+ 170D CA EE 11             jp      Z,CSTART        ; Cold start error - Restart
 736+ 1710 7C                   ld      A,H             ; Was it a direct error?
 737+ 1711 A5                   and     L               ; Line = -1 if direct error
 738+ 1712 3C                   inc     A
 739+ 1713 CA 1E 17             jp      Z,PTLN          ; Yes, jump over
 740+ 1716 E5                   push    HL              ; indirect mode - store HL
 741+ 1717 2A F4 51             ld      HL,(LINEAT)     ; copy current line number
 742+ 171A 22 F6 51             ld      (HLPLN),HL      ; save in HELP line register
 743+ 171D E1                   pop     HL              ; retrieve HL
 744+ 171E C4 3C 30     PTLN:   call    NZ,LINEIN       ; No - output line of error
 745+ 1721
 746+ 1721 3E                   defb    $3E             ; Skip "pop BC"
 747+ 1722 C1           POPNOK: pop     BC              ; Drop address in input buffer
 748+ 1723
 749+ 1723              ; run into direct mode: print OK and get command
 750+ 1723 AF           PRNTOK: xor     A               ; Output "Ok" and get command
 751+ 1724 32 EA 51             ld      (CTLOFG),A      ; Enable output
 752+ 1727 CD C7 1E             call    STTLIN          ; Start new line
 753+ 172A 21 47 16             ld      HL,OKMSG        ; "Ok" message
 754+ 172D CD A5 25             call    PRS             ; Output "Ok"
 755+ 1730 CD 17 09     GETCMD: call    CURSOR_ON       ; enable cursor
 756+ 1733 3A 64 53             ld      A,(SERIALS_EN)  ; load serial state
 757+ 1736 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
 758+ 1738 CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
 759+ 173B 21 FF FF             ld      HL,-1           ; Flag direct mode
 760+ 173E 22 F4 51             ld      (LINEAT),HL     ; Save as current line
 761+ 1741 CD 43 19             call    GETLIN          ; Get an input line
 762+ 1744 DA 30 17             jp      C,GETCMD        ; Get line again if break
 763+ 1747 CD 0C 1C             call    GETCHR          ; Get first character
 764+ 174A 17                   rla                     ; 8th bit is copied into carry and original carry is copied into bit 0)
 765+ 174B DA C9 16             jp      C,SNERR         ; if char >=128 (8th bit set) then raise an error
 766+ 174E 1F                   rra                     ; recover original char and Carry
 767+ 174F 3C                   inc     A               ; Test if end of line
 768+ 1750 3D                   dec     A               ; Without affecting Carry
 769+ 1751 CA 30 17             jp      Z,GETCMD        ; Nothing entered - Get another
 770+ 1754 F5                   push    AF              ; Save Carry status
 771+ 1755 3A 64 53             ld      A,(SERIALS_EN)  ; load serial state
 772+ 1758 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
 773+ 175A CC 8F 01             call    Z,A_RTS_OFF      ; yes, set RTS on
 774+ 175D CD 2C 09             call    CURSOR_OFF      ; cursor disabled
 775+ 1760 CD DC 1C             call    ATOH            ; Get line number into DE
 776+ 1763 D5                   push    DE              ; Save line number
 777+ 1764 CD 5A 18             call    CRUNCH          ; Tokenise rest of line
 778+ 1767 47                   ld      B,A             ; Length of tokenised line
 779+ 1768 D1                   pop     DE              ; Restore line number
 780+ 1769 F1                   pop     AF              ; Restore Carry
 781+ 176A D2 EC 1B             jp      NC,EXCUTE       ; No line number - Direct mode
 782+ 176D D5                   push    DE              ; Save line number
 783+ 176E C5                   push    BC              ; Save length of tokenised line
 784+ 176F AF                   xor     A
 785+ 1770 32 F8 52             ld      (LSTBIN),A      ; Clear last byte input
 786+ 1773 CD 0C 1C             call    GETCHR          ; Get next character
 787+ 1776 B7                   or      A               ; Set flags
 788+ 1777 F5                   push    AF              ; And save them
 789+ 1778 CD DF 17             call    SRCHLN          ; Search for line number in DE
 790+ 177B DA 84 17             jp      C,LINFND        ; Jump if line found
 791+ 177E F1                   pop     AF              ; Get status
 792+ 177F F5                   push    AF              ; And re-save
 793+ 1780 CA 8B 1D             jp      Z,ULERR         ; Nothing after number - Error
 794+ 1783 B7                   or      A               ; Clear Carry
 795+ 1784 C5           LINFND: push    BC              ; Save address of line in prog
 796+ 1785 D2 9B 17             jp      NC,INEWLN       ; Line not found - Insert new
 797+ 1788 EB                   ex      DE,HL           ; Next line address in DE
 798+ 1789 2A 68 53             ld      HL,(PROGND)     ; End of program
 799+ 178C 1A           SFTPRG: ld      A,(DE)          ; Shift rest of program down
 800+ 178D 02                   ld      (BC),A
 801+ 178E 03                   inc     BC              ; Next destination
 802+ 178F 13                   inc     DE              ; Next source
 803+ 1790 CD BD 19             call    CPDEHL          ; All done?
 804+ 1793 C2 8C 17             jp      NZ,SFTPRG       ; More to do
 805+ 1796 60                   ld      H,B             ; HL - New end of program
 806+ 1797 69                   ld      L,C
 807+ 1798 22 68 53             ld      (PROGND),HL     ; Update end of program
 808+ 179B
 809+ 179B D1           INEWLN: pop     DE              ; Get address of line,
 810+ 179C F1                   pop     AF              ; Get status
 811+ 179D CA C2 17             jp      Z,SETPTR        ; No text - Set up pointers
 812+ 17A0 2A 68 53             ld      HL,(PROGND)     ; Get end of program
 813+ 17A3 E3                   ex      (SP),HL         ; Get length of input line
 814+ 17A4 C1                   pop     BC              ; End of program to BC
 815+ 17A5 09                   add     HL,BC           ; Find new end
 816+ 17A6 E5                   push    HL              ; Save new end
 817+ 17A7 CD 75 16             call    MOVUP           ; Make space for line
 818+ 17AA E1                   pop     HL              ; Restore new end
 819+ 17AB 22 68 53             ld      (PROGND),HL     ; Update end of program pointer
 820+ 17AE EB                   ex      DE,HL           ; Get line to move up in HL
 821+ 17AF 74                   ld      (HL),H          ; Save MSB
 822+ 17B0 D1                   pop     DE              ; Get new line number
 823+ 17B1 23                   inc     HL              ; Skip pointer
 824+ 17B2 23                   inc     HL
 825+ 17B3 73                   ld      (HL),E          ; Save LSB of line number
 826+ 17B4 23                   inc     HL
 827+ 17B5 72                   ld      (HL),D          ; Save MSB of line number
 828+ 17B6 23                   inc     HL              ; To first byte in line
 829+ 17B7 11 7D 52             ld      DE,BUFFER       ; Copy buffer to program
 830+ 17BA 1A           MOVBUF: ld      A,(DE)          ; Get source
 831+ 17BB 77                   ld      (HL),A          ; Save destinations
 832+ 17BC 23                   inc     HL              ; Next source
 833+ 17BD 13                   inc     DE              ; Next destination
 834+ 17BE B7                   or      A               ; Done?
 835+ 17BF C2 BA 17             jp      NZ,MOVBUF       ; No - Repeat
 836+ 17C2 CD 0B 18     SETPTR: call    RUNFST          ; Set line pointers
 837+ 17C5 23                   inc     HL              ; To LSB of pointer
 838+ 17C6 EB                   ex      DE,HL           ; Address to DE
 839+ 17C7 62           PTRLP:  ld      H,D             ; Address to HL
 840+ 17C8 6B                   ld      L,E
 841+ 17C9 7E                   ld      A,(HL)          ; Get LSB of pointer
 842+ 17CA 23                   inc     HL              ; To MSB of pointer
 843+ 17CB B6                   or      (HL)            ; Compare with MSB pointer
 844+ 17CC CA 30 17             jp      Z,GETCMD        ; Get command line if end
 845+ 17CF 23                   inc     HL              ; To LSB of line number
 846+ 17D0 23                   inc     HL              ; Skip line number
 847+ 17D1 23                   inc     HL              ; Point to first byte in line
 848+ 17D2 AF                   xor     A               ; Looking for 00 byte
 849+ 17D3 BE           FNDEND: cp      (HL)            ; Found end of line?
 850+ 17D4 23                   inc     HL              ; Move to next byte
 851+ 17D5 C2 D3 17             jp      NZ,FNDEND       ; No - Keep looking
 852+ 17D8 EB                   ex      DE,HL           ; Next line address to HL
 853+ 17D9 73                   ld      (HL),E          ; Save LSB of pointer
 854+ 17DA 23                   inc     HL
 855+ 17DB 72                   ld      (HL),D          ; Save MSB of pointer
 856+ 17DC C3 C7 17             jp      PTRLP           ; Do next line
 857+ 17DF
 858+ 17DF 2A 7A 52     SRCHLN: ld      HL,(BASTXT)     ; Start of program text
 859+ 17E2 44           SRCHLP: ld      B,H             ; BC = Address to look at
 860+ 17E3 4D                   ld      C,L
 861+ 17E4 7E                   ld      A,(HL)          ; Get address of next line
 862+ 17E5 23                   inc     HL
 863+ 17E6 B6                   or      (HL)            ; End of program found?
 864+ 17E7 2B                   dec     HL
 865+ 17E8 C8                   ret     Z               ; Yes - Line not found
 866+ 17E9 23                   inc     HL
 867+ 17EA 23                   inc     HL
 868+ 17EB 7E                   ld      A,(HL)          ; Get LSB of line number
 869+ 17EC 23                   inc     HL
 870+ 17ED 66                   ld      H,(HL)          ; Get MSB of line number
 871+ 17EE 6F                   ld      L,A
 872+ 17EF CD BD 19             call    CPDEHL          ; Compare with line in DE
 873+ 17F2 60                   ld      H,B             ; HL = Start of this line
 874+ 17F3 69                   ld      L,C
 875+ 17F4 7E                   ld      A,(HL)          ; Get LSB of next line address
 876+ 17F5 23                   inc     HL
 877+ 17F6 66                   ld      H,(HL)          ; Get MSB of next line address
 878+ 17F7 6F                   ld      L,A             ; Next line to HL
 879+ 17F8 3F                   ccf
 880+ 17F9 C8                   ret     Z               ; Lines found - Exit
 881+ 17FA 3F                   ccf
 882+ 17FB D0                   ret     NC              ; Line not found,at line after
 883+ 17FC C3 E2 17             jp      SRCHLP          ; Keep looking
 884+ 17FF
 885+ 17FF C0           NEW:    ret     NZ              ; Return if any more on line
 886+ 1800 2A 7A 52     CLRPTR: ld      HL,(BASTXT)     ; Point to start of program
 887+ 1803 AF                   xor     A               ; Set program area to empty
 888+ 1804 77                   ld      (HL),A          ; Save LSB = 00
 889+ 1805 23                   inc     HL
 890+ 1806 77                   ld      (HL),A          ; Save MSB = 00
 891+ 1807 23                   inc     HL
 892+ 1808 22 68 53             ld      (PROGND),HL     ; Set program end
 893+ 180B
 894+ 180B 2A 7A 52     RUNFST: ld      HL,(BASTXT)     ; Clear all variables
 895+ 180E 2B                   dec     HL
 896+ 180F
 897+ 180F 22 FA 52     INTVAR: ld      (BRKLIN),HL     ; Initialise RUN variables
 898+ 1812 2A DB 52             ld      HL,(LSTRAM)     ; Get end of RAM
 899+ 1815 22 EF 52             ld      (STRBOT),HL     ; Clear string space
 900+ 1818 AF                   xor     A
 901+ 1819 CD 1C 1C             call    RESTOR          ; Reset DATA pointers
 902+ 181C 2A 68 53             ld      HL,(PROGND)     ; Get end of program
 903+ 181F 22 6A 53             ld      (VAREND),HL     ; Clear variables
 904+ 1822 22 6C 53             ld      (ARREND),HL     ; Clear arrays
 905+ 1825
 906+ 1825 C1           CLREG:  pop     BC              ; Save return address
 907+ 1826 2A F2 51             ld      HL,(STRSPC)     ; Get end of working RAM
 908+ 1829 F9                   ld      SP,HL           ; Set stack
 909+ 182A 21 DF 52             ld      HL,TMSTPL       ; Temporary string pool
 910+ 182D 22 DD 52             ld      (TMSTPT),HL     ; Reset temporary string ptr
 911+ 1830 AF                   xor     A               ; A = 00
 912+ 1831 6F                   ld      L,A             ; HL = 0000
 913+ 1832 67                   ld      H,A
 914+ 1833 22 00 53             ld      (CONTAD),HL     ; No CONTinue
 915+ 1836 32 F7 52             ld      (FORFLG),A      ; Clear FOR flag
 916+ 1839 22 70 53             ld      (FNRGNM),HL     ; Clear FN argument
 917+ 183C E5                   push    HL              ; HL = 0000
 918+ 183D C5                   push    BC              ; Put back return
 919+ 183E 2A FA 52     DOAGN:  ld      HL,(BRKLIN)     ; Get address of code to RUN
 920+ 1841 C9                   ret                     ; Return to execution driver
 921+ 1842
 922+ 1842 3E 3F        PROMPT: ld      A,'?'           ; '?'
 923+ 1844 CD CE 19             call    OUTC            ; Output character
 924+ 1847 3E 00                ld      A,NLLCR         ; null char
 925+ 1849 CD CE 19             call    OUTC            ; Output character
 926+ 184C CD 17 09             call    CURSOR_ON       ; enable cursor
 927+ 184F 3A 64 53             ld      A,(SERIALS_EN)  ; load serial state
 928+ 1852 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
 929+ 1854 CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
 930+ 1857 C3 EF 51             jp      RINPUT          ; Get input line
 931+ 185A
 932+ 185A AF           CRUNCH: xor     A               ; Tokenise line @ HL to BUFFER
 933+ 185B 32 DA 52             ld      (DATFLG),A      ; Reset literal flag
 934+ 185E 0E 05                ld      C,2+3           ; 2 byte number and 3 nulls
 935+ 1860 11 7D 52             ld      DE,BUFFER       ; Start of input buffer
 936+ 1863 7E           CRNCLP: ld      A,(HL)          ; Get byte
 937+ 1864 FE 20                cp      SPC             ; Is it a space?
 938+ 1866 CA E2 18             jp      Z,MOVDIR        ; Yes - Copy direct
 939+ 1869 47                   ld      B,A             ; Save character
 940+ 186A FE 22                cp      $22             ; '"'             ; Is it a quote?
 941+ 186C CA 02 19             jp      Z,CPYLIT        ; Yes - Copy literal string
 942+ 186F B7                   or      A               ; Is it end of buffer?
 943+ 1870 CA 09 19             jp      Z,ENDBUF        ; Yes - End buffer
 944+ 1873 3A DA 52             ld      A,(DATFLG)      ; Get data type
 945+ 1876 B7                   or      A               ; Literal?
 946+ 1877 7E                   ld      A,(HL)          ; Get byte to copy
 947+ 1878 C2 E2 18             jp      NZ,MOVDIR       ; Literal - Copy direct
 948+ 187B FE 3F                cp      '?'             ; Is it '?' short for PRINT
 949+ 187D 3E AF                ld      A,ZPRINT        ; "PRINT" token
 950+ 187F CA E2 18             jp      Z,MOVDIR        ; Yes - replace it
 951+ 1882 7E                   ld      A,(HL)          ; Get byte again
 952+ 1883 FE 30                cp      '0'             ; Is it less than '0'
 953+ 1885 DA 8D 18             jp      C,FNDWRD        ; Yes - Look for reserved words
 954+ 1888 FE 3C                cp      $3C  ;60; ";"+1       ; Is it "0123456789:;" ?
 955+ 188A DA E2 18             jp      C,MOVDIR        ; Yes - copy it direct
 956+ 188D D5           FNDWRD: push    DE              ; Look for reserved words
 957+ 188E 11 4A 13             ld      DE,WORDS-1      ; Point to table
 958+ 1891 C5                   push    BC              ; Save count
 959+ 1892 01 DE 18             ld      BC,RETNAD       ; Where to return to
 960+ 1895 C5                   push    BC              ; Save return address
 961+ 1896 06 7F                ld      B,ZEND-1        ; First token value -1
 962+ 1898 7E                   ld      A,(HL)          ; Get byte
 963+ 1899 FE 61                cp      'a'             ; Less than 'a' ?
 964+ 189B DA A6 18             jp      C,SEARCH        ; Yes - search for words
 965+ 189E FE 7B                cp      'z'+1           ; Greater than 'z' ?
 966+ 18A0 D2 A6 18             jp      NC,SEARCH       ; Yes - search for words
 967+ 18A3 E6 5F                and     %01011111       ; Force upper case
 968+ 18A5 77                   ld      (HL),A          ; Replace byte
 969+ 18A6 4E           SEARCH: ld      C,(HL)          ; Search for a word
 970+ 18A7 EB                   ex      DE,HL
 971+ 18A8 23           GETNXT: inc     HL              ; Get next reserved word
 972+ 18A9 B6                   or      (HL)            ; Start of word?
 973+ 18AA F2 A8 18             jp      P,GETNXT        ; No - move on
 974+ 18AD 04                   inc     B               ; Increment token value
 975+ 18AE 7E                   ld      A,(HL)          ; Get byte from table
 976+ 18AF E6 7F                and     %01111111       ; Strip bit 7
 977+ 18B1 C8                   ret     Z               ; Return if end of list
 978+ 18B2 B9                   cp      C               ; Same character as in buffer?
 979+ 18B3 C2 A8 18             jp      NZ,GETNXT       ; No - get next word
 980+ 18B6 EB                   ex      DE,HL
 981+ 18B7 E5                   push    HL              ; Save start of word
 982+ 18B8
 983+ 18B8 13           NXTBYT: inc     DE              ; Look through rest of word
 984+ 18B9 1A                   ld      A,(DE)          ; Get byte from table
 985+ 18BA B7                   or      A               ; End of word ?
 986+ 18BB FA DA 18             jp      M,MATCH         ; Yes - Match found
 987+ 18BE 4F                   ld      C,A             ; Save it
 988+ 18BF 78                   ld      A,B             ; Get token value
 989+ 18C0 FE 88                cp      ZGOTO           ; Is it "GOTO" token ?
 990+ 18C2 C2 C9 18             jp      NZ,NOSPC        ; No - Don't allow spaces
 991+ 18C5 CD 0C 1C             call    GETCHR          ; Get next character
 992+ 18C8 2B                   dec     HL              ; Cancel increment from GETCHR
 993+ 18C9 23           NOSPC:  inc     HL              ; Next byte
 994+ 18CA 7E                   ld      A,(HL)          ; Get byte
 995+ 18CB FE 61                cp      'a'             ; Less than 'a' ?
 996+ 18CD DA D2 18             jp      C,NOCHNG        ; Yes - don't change
 997+ 18D0 E6 5F                and     %01011111       ; Make upper case
 998+ 18D2 B9           NOCHNG: cp      C               ; Same as in buffer ?
 999+ 18D3 CA B8 18             jp      Z,NXTBYT        ; Yes - keep testing
1000+ 18D6 E1                   pop     HL              ; Get back start of word
1001+ 18D7 C3 A6 18             jp      SEARCH          ; Look at next word
1002+ 18DA
1003+ 18DA 48           MATCH:  ld      C,B             ; Word found - Save token value
1004+ 18DB F1                   pop     AF              ; Throw away return
1005+ 18DC EB                   ex      DE,HL
1006+ 18DD C9                   ret                     ; Return to "RETNAD"
1007+ 18DE EB           RETNAD: ex      DE,HL           ; Get address in string
1008+ 18DF 79                   ld      A,C             ; Get token value
1009+ 18E0 C1                   pop     BC              ; Restore buffer length
1010+ 18E1 D1                   pop     DE              ; Get destination address
1011+ 18E2 23           MOVDIR: inc     HL              ; Next source in buffer
1012+ 18E3 12                   ld      (DE),A          ; Put byte in buffer
1013+ 18E4 13                   inc     DE              ; Move up buffer
1014+ 18E5 0C                   inc     C               ; Increment length of buffer
1015+ 18E6 D6 3A                sub     ':'             ; End of statement?
1016+ 18E8 CA F0 18             jp      Z,SETLIT        ; Jump if multi-statement line
1017+ 18EB FE 49                cp      ZDATA-$3A       ; Is it DATA statement ?
1018+ 18ED C2 F3 18             jp      NZ,TSTREM       ; No - see if REM
1019+ 18F0 32 DA 52     SETLIT: ld      (DATFLG),A      ; Set literal flag
1020+ 18F3 D6 54        TSTREM: sub     ZREM-$3A        ; Is it REM?
1021+ 18F5 C2 63 18             jp      NZ,CRNCLP       ; No - Leave flag
1022+ 18F8 47                   ld      B,A             ; Copy rest of buffer
1023+ 18F9 7E           NXTCHR: ld      A,(HL)          ; Get byte
1024+ 18FA B7                   or      A               ; End of line ?
1025+ 18FB CA 09 19             jp      Z,ENDBUF        ; Yes - Terminate buffer
1026+ 18FE B8                   cp      B               ; End of statement ?
1027+ 18FF CA E2 18             jp      Z,MOVDIR        ; Yes - Get next one
1028+ 1902 23           CPYLIT: inc     HL              ; Move up source string
1029+ 1903 12                   ld      (DE),A          ; Save in destination
1030+ 1904 0C                   inc     C               ; Increment length
1031+ 1905 13                   inc     DE              ; Move up destination
1032+ 1906 C3 F9 18             jp      NXTCHR          ; Repeat
1033+ 1909
1034+ 1909 21 7C 52     ENDBUF: ld      HL,BUFFER-1     ; Point to start of buffer
1035+ 190C 12                   ld      (DE),A          ; Mark end of buffer (A = 00)
1036+ 190D 13                   inc     DE
1037+ 190E 12                   ld      (DE),A          ; A = 00
1038+ 190F 13                   inc     DE
1039+ 1910 12                   ld      (DE),A          ; A = 00
1040+ 1911 C9                   ret
1041+ 1912
1042+ 1912 3A E9 51     DODEL:  ld      A,(NULFLG)      ; Get null flag status
1043+ 1915 B7                   or      A               ; Is it zero?
1044+ 1916 3E 00                ld      A,$00           ; Zero A - Leave flags
1045+ 1918 32 E9 51             ld      (NULFLG),A      ; Zero null flag
1046+ 191B C2 26 19             jp      NZ,ECHDEL       ; Set - Echo it
1047+ 191E 05                   dec     B               ; Decrement length
1048+ 191F CA 43 19             jp      Z,GETLIN        ; Get line again if empty
1049+ 1922 CD CE 19             call    OUTC            ; Output null character
1050+ 1925 3E                   defb    $3E             ; Skip "dec B"
1051+ 1926 05           ECHDEL: dec     B               ; Count bytes in buffer
1052+ 1927 2B                   dec     HL              ; Back space buffer
1053+ 1928 CA 3A 19             jp      Z,OTKLN         ; No buffer - Try again
1054+ 192B 7E                   ld      A,(HL)          ; Get deleted byte
1055+ 192C CD CE 19             call    OUTC            ; Echo it
1056+ 192F C3 4C 19             jp      MORINP          ; Get more input
1057+ 1932
1058+ 1932 05           DELCHR: dec     B               ; Count bytes in buffer
1059+ 1933 2B                   dec     HL              ; Back space buffer
1060+ 1934 CD CE 19             call    OUTC            ; Output character in A
1061+ 1937 C2 4C 19             jp      NZ,MORINP       ; Not end - Get more
1062+ 193A CD CE 19     OTKLN:  call    OUTC            ; Output character in A
1063+ 193D CD D9 1E     KILIN:  call    PRNTCRLF        ; Output CRLF
1064+ 1940 C3 43 19             jp      TTYLIN          ; Get line again
1065+ 1943
1066+ 1943              GETLIN:
1067+ 1943 21 7D 52     TTYLIN: ld      HL,BUFFER       ; Get a line by character
1068+ 1946 06 01                ld      B,$01           ; Set buffer as empty
1069+ 1948 AF                   xor     A
1070+ 1949 32 E9 51             ld      (NULFLG),A      ; Clear null flag
1071+ 194C CD 0F 1A     MORINP: call    CLOTST          ; Get character and test ^O
1072+ 194F 4F                   ld      C,A             ; Save character in C
1073+ 1950 FE 7F                cp      DEL             ; Delete character?
1074+ 1952 CA 12 19             jp      Z,DODEL         ; Yes - Process it
1075+ 1955 3A E9 51             ld      A,(NULFLG)      ; Get null flag
1076+ 1958 B7                   or      A               ; Test null flag status
1077+ 1959 CA 65 19             jp      Z,PROCES        ; Reset - Process character
1078+ 195C 3E 00                ld      A,$00           ; Set a null
1079+ 195E CD CE 19             call    OUTC            ; Output null
1080+ 1961 AF                   xor     A               ; Clear A
1081+ 1962 32 E9 51             ld      (NULFLG),A      ; Reset null flag
1082+ 1965 79           PROCES: ld      A,C             ; Get character
1083+ 1966 FE 07                cp      CTRLG           ; Bell?
1084+ 1968 CA A5 19             jp      Z,PUTCTL        ; Yes - Save it
1085+ 196B FE 03                cp      CTRLC           ; Is it control "C"?
1086+ 196D CC 9A 19             call    Z,GMNCR         ; Yes - exit from graphic mode & Output CRLF
1087+ 1970 37                   scf                     ; Flag break
1088+ 1971 C8                   ret     Z               ; Return if control "C"
1089+ 1972 FE 0D                cp      CR              ; Is it enter?
1090+ 1974 CA CF 1E             jp      Z,ENDINP        ; Yes - Terminate input
1091+ 1977 FE 15                cp      CTRLU           ; Is it control "U"?
1092+ 1979 CA 3D 19             jp      Z,KILIN         ; Yes - Get another line
1093+ 197C FE 08                cp      BKSP            ; Is it backspace?
1094+ 197E CA 32 19             jp      Z,DELCHR        ; Yes - Delete character
1095+ 1981 FE 12                cp      CTRLR           ; Is it control "R"?
1096+ 1983 C2 A0 19             jp      NZ,PUTBUF       ; No - Put in buffer
1097+ 1986 C5                   push    BC              ; Save buffer length
1098+ 1987 D5                   push    DE              ; Save DE
1099+ 1988 E5                   push    HL              ; Save buffer address
1100+ 1989 36 00                ld      (HL),$00        ; Mark end of buffer
1101+ 198B CD D8 3F             call    OUTNCR          ; Output and do CRLF
1102+ 198E 21 7D 52             ld      HL,BUFFER       ; Point to buffer start
1103+ 1991 CD A5 25             call    PRS             ; Output buffer
1104+ 1994 E1                   pop     HL              ; Restore buffer address
1105+ 1995 D1                   pop     DE              ; Restore DE
1106+ 1996 C1                   pop     BC              ; Restore buffer length
1107+ 1997 C3 4C 19             jp      MORINP          ; Get another character
1108+ 199A CD A3 16     GMNCR:  call    EXITGM          ; exit from graphic mode
1109+ 199D C3 D9 1E             jp      PRNTCRLF        ; output CRLF
1110+ 19A0
1111+ 19A0 FE 20        PUTBUF: cp      SPC             ; Is it a control code?
1112+ 19A2 DA 4C 19             jp      C,MORINP        ; Yes - Ignore
1113+ 19A5 78           PUTCTL: ld      A,B             ; Get number of bytes in buffer
1114+ 19A6 FE 59                cp      $58+$01         ; Test for line overflow
1115+ 19A8 3E 08                ld      A,BKSP          ; Set a bell
1116+ 19AA D2 B7 19             jp      NC,OUTNBS       ; Ring bell if buffer full
1117+ 19AD 79                   ld      A,C             ; Get character
1118+ 19AE 71                   ld      (HL),C          ; Save in buffer
1119+ 19AF 32 F8 52             ld      (LSTBIN),A      ; Save last input byte
1120+ 19B2 23                   inc     HL              ; Move up buffer
1121+ 19B3 04                   inc     B               ; Increment length
1122+ 19B4 C3 4C 19     OUTIT:  jp      MORINP          ; Get another character
1123+ 19B7
1124+ 19B7 CD CE 19     OUTNBS: call    OUTC            ; Output bell and back over it
1125+ 19BA C3 B4 19             jp      OUTIT           ; get more chars
1126+ 19BD
1127+ 19BD 7C           CPDEHL: ld      A,H             ; Get H
1128+ 19BE 92                   sub     D               ; Compare with D
1129+ 19BF C0                   ret     NZ              ; Different - Exit
1130+ 19C0 7D                   ld      A,L             ; Get L
1131+ 19C1 93                   sub     E               ; Compare with E
1132+ 19C2 C9                   ret                     ; Return status
1133+ 19C3
1134+ 19C3 7E           CHKSYN: ld      A,(HL)          ; Check syntax of character
1135+ 19C4 E3                   ex      (SP),HL         ; Address of test byte
1136+ 19C5 BE                   cp      (HL)            ; Same as in code string?
1137+ 19C6 23                   inc     HL              ; Return address
1138+ 19C7 E3                   ex      (SP),HL         ; Put it back
1139+ 19C8 CA 0C 1C             jp      Z,GETCHR        ; Yes - Get next character
1140+ 19CB C3 C9 16             jp      SNERR           ; Different - ?SN Error
1141+ 19CE
1142+ 19CE F5           OUTC:   push    AF              ; Save character
1143+ 19CF 3A EA 51             ld      A,(CTLOFG)      ; Get control "O" flag
1144+ 19D2 B7                   or      A               ; Is it set?
1145+ 19D3 C2 DA 25             jp      NZ,POPAF        ; Yes - don't output
1146+ 19D6 F1                   pop     AF              ; Restore character
1147+ 19D7 C5                   push    BC              ; Save buffer length
1148+ 19D8 F5                   push    AF              ; Save character
1149+ 19D9 FE 20                cp      SPC             ; Is it a control code?
1150+ 19DB DA F2 19             jp      C,DINPOS        ; Yes - Don't inc POS(X)
1151+ 19DE 3A E7 51             ld      A,(LWIDTH)      ; Get line width
1152+ 19E1 47                   ld      B,A             ; To B
1153+ 19E2 3A D7 52             ld      A,(CURPOS)      ; Get cursor position
1154+ 19E5 04                   inc     B               ; Width 255?
1155+ 19E6 CA EE 19             jp      Z,INCLEN        ; Yes - No width limit
1156+ 19E9 05                   dec     B               ; Restore width
1157+ 19EA B8                   cp      B               ; At end of line?
1158+ 19EB CC D9 1E             call    Z,PRNTCRLF      ; Yes - output CRLF
1159+ 19EE 3C           INCLEN: inc     A               ; Move on one character
1160+ 19EF 32 D7 52             ld      (CURPOS),A      ; Save new position
1161+ 19F2 AF           DINPOS: xor     A
1162+ 19F3 32 5C 53             ld      (KBDNPT),A      ; set flag for no char from keyboard
1163+ 19F6 F1                   pop     AF              ; Restore character
1164+ 19F7 C1                   pop     BC              ; Restore buffer length
1165+ 19F8 F5                   push    AF
1166+ 19F9 CD 01 1A             call    SND2VID         ; send char to video
1167+ 19FC F1                   pop     AF
1168+ 19FD CD B7 3F             call    MONOUT          ; send char to serial if enabled
1169+ 1A00 C9                   ret
1170+ 1A01
1171+ 1A01              ; print char to video if cursor is on
1172+ 1A01 32 1F 53     SND2VID:ld      (CHR4VID),A     ; store A
1173+ 1A04 3A 1E 53             ld      A,(PRNTVIDEO)   ; check print-on-video
1174+ 1A07 B7                   or      A               ; is it off?
1175+ 1A08 C8                   ret     Z               ; yes, so return
1176+ 1A09 F3                   di                      ; disable INTs
1177+ 1A0A CD 4B 07             call    CHAR2VID        ; cursor is on, so print char on screen
1178+ 1A0D FB                   ei                      ; re-enable INTs
1179+ 1A0E C9                   ret                     ; return to caller
1180+ 1A0F
1181+ 1A0F CD 60 33     CLOTST: call    GETINP          ; Get input character
1182+ 1A12 FE 0F                cp      CTRLO           ; Is it control "O"?
1183+ 1A14 C0                   ret     NZ              ; No don't flip flag
1184+ 1A15 3A EA 51             ld      A,(CTLOFG)      ; Get flag
1185+ 1A18 2F                   cpl                     ; Flip it
1186+ 1A19 32 EA 51             ld      (CTLOFG),A      ; Put it back
1187+ 1A1C A7                   and     A               ; is output enabled?
1188+ 1A1D CC 17 09             call    Z,CURSOR_ON     ; yes, so cursor on
1189+ 1A20 3A 64 53             ld      A,(SERIALS_EN)  ; load serial state
1190+ 1A23 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
1191+ 1A25 CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
1192+ 1A28 AF                   xor     A               ; Null character
1193+ 1A29 C9                   ret
1194+ 1A2A
1195+ 1A2A              ; LIST: list the program stored into memory
1196+ 1A2A C1           LIST:   pop     BC              ; rubbish - not needed (legacy from original call of LIST)
1197+ 1A2B 2B                   dec     HL              ; dec 'cos GETCHR INCs
1198+ 1A2C CD 0C 1C             call    GETCHR          ; Get next character
1199+ 1A2F CA 85 1A             jp      Z,LSTALL        ; list all if nothing follows
1200+ 1A32 FE BE                cp      ZMINUS          ; is it '-'?
1201+ 1A34 20 20                jr      NZ,LST01        ; no, look for a line number
1202+ 1A36 11 00 00             ld      DE,$0000        ; yes, set search from 0
1203+ 1A39 CD 26 1B             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1204+ 1A3C ED 43 22 53          ld      (TMPBFR1),BC    ; store address of starting line
1205+ 1A40 CD C3 19             call    CHKSYN          ; skip '-'
1206+ 1A43 BE                   defb    ZMINUS
1207+ 1A44 CD DC 1C             call    ATOH            ; now, look for another number (ASCII number to DE)
1208+ 1A47 CD 2C 1B             call    SRCLN           ; find a line, getting the previous if it doesn't exist
1209+ 1A4A ED 43 24 53          ld      (TMPBFR2),BC    ; store address of ending line
1210+ 1A4E ED 4B 22 53          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1211+ 1A52 C5                   push    BC              ; store address of line for later use
1212+ 1A53 C3 BD 1A             jp      LISTLP          ; go listing
1213+ 1A56 CD DC 1C     LST01:  call    ATOH            ; get a line number (ASCII number to DE)
1214+ 1A59 ED 53 28 53  LST01H: ld      (TMPBFR4),DE    ; store ending line address for later use - N.B.: this is a hook for HELP command
1215+ 1A5D CD 26 1B             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1216+ 1A60 ED 43 22 53          ld      (TMPBFR1),BC    ; store address of starting line
1217+ 1A64 ED 43 24 53          ld      (TMPBFR2),BC    ; same address for ending line (we'll change it later if needed)
1218+ 1A68 2B                   dec     HL              ; dec 'cos GETCHR INCs
1219+ 1A69 CD 0C 1C             call    GETCHR          ; Get next character
1220+ 1A6C CA 78 1A             jp      Z,LSTNOT        ; nothing follows, so ending & starting lines are the same
1221+ 1A6F FE BE                cp      ZMINUS          ; is it '-'?
1222+ 1A71 CA 9D 1A             jp      Z,LST03         ; yes, read ending line
1223+ 1A74 C5           LST06:  push    BC              ; store address for later use
1224+ 1A75 C3 BD 1A             jp      LISTLP          ; jump to list
1225+ 1A78 ED 5B 28 53  LSTNOT: ld      DE,(TMPBFR4)
1226+ 1A7C CD 26 1B             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1227+ 1A7F DA 74 1A             jp      C,LST06
1228+ 1A82 C3 23 17             jp      PRNTOK
1229+ 1A85 11 F9 FF     LSTALL: ld      DE,65529        ; set ending line to max. allowed line number
1230+ 1A88 CD 26 1B             call    SRCHLIN         ; get address of last line
1231+ 1A8B ED 43 24 53          ld      (TMPBFR2),BC    ; store it
1232+ 1A8F 11 00 00             ld      DE,$0000        ; set start to first line in memory
1233+ 1A92 CD 26 1B             call    SRCHLIN         ; get address of first line
1234+ 1A95 ED 43 22 53          ld      (TMPBFR1),BC    ; store it
1235+ 1A99 C5                   push    BC              ; store address of starting line for later use
1236+ 1A9A C3 BD 1A             jp      LISTLP          ; start printing
1237+ 1A9D CD C3 19     LST03:  call    CHKSYN          ; skip '-'
1238+ 1AA0 BE                   defb    ZMINUS
1239+ 1AA1 CD DC 1C             call    ATOH            ; look for another number (return into DE)
1240+ 1AA4 7A                   ld      A,D
1241+ 1AA5 B3                   or      E               ; is line=0?
1242+ 1AA6 20 09                jr      NZ,LST05        ; no, jump over
1243+ 1AA8 11 F9 FF             ld      DE,65529        ; yes set last valid line number
1244+ 1AAB CD 26 1B             call    SRCHLIN         ; get address of last line
1245+ 1AAE C3 B4 1A             jp      LST02
1246+ 1AB1 CD 2C 1B     LST05:  call    SRCLN           ; find a line, getting the previous if it doesn't exist
1247+ 1AB4 ED 43 24 53  LST02:  ld      (TMPBFR2),BC    ; store address of ending line
1248+ 1AB8 ED 4B 22 53          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1249+ 1ABC C5                   push    BC              ; store it for later use
1250+ 1ABD E1           LISTLP: pop     HL              ; Restore address of line
1251+ 1ABE 4E                   ld      C,(HL)          ; Get LSB of next line
1252+ 1ABF 23                   inc     HL
1253+ 1AC0 46                   ld      B,(HL)          ; Get MSB of next line
1254+ 1AC1 23                   inc     HL
1255+ 1AC2 78                   ld      A,B             ; BC = 0 (End of program)?
1256+ 1AC3 B1                   or      C
1257+ 1AC4 CA 23 17             jp      Z,PRNTOK        ; Yes - Go to command mode
1258+ 1AC7 CD 37 1C             call    TSTBRK          ; Test for break key
1259+ 1ACA CD 3A 1B             call    TSTSPC          ; test for space
1260+ 1ACD C5                   push    BC              ; Save address of next line
1261+ 1ACE 3A 17 53             ld      A,(SCR_CURS_X)  ; load current X pos of cursor
1262+ 1AD1 A7                   and     A               ; is it at the beginning of a new line?
1263+ 1AD2 20 0B                jr      NZ,LST08        ; No, jump over
1264+ 1AD4 3E 0D                ld      A,CR            ; yes, so just send a CR
1265+ 1AD6 CD B7 3F             call    MONOUT          ; to serial if it's open
1266+ 1AD9 AF                   xor     A               ; then, set cursor
1267+ 1ADA 32 D7 52             ld      (CURPOS),A      ; to position 0
1268+ 1ADD 18 03                jr      LST07           ; and continue
1269+ 1ADF CD D9 1E     LST08:  call    PRNTCRLF        ; output CRLF
1270+ 1AE2 5E           LST07:  ld      E,(HL)          ; Get LSB of line number
1271+ 1AE3 23                   inc     HL
1272+ 1AE4 56                   ld      D,(HL)          ; Get MSB of line number
1273+ 1AE5 23                   inc     HL
1274+ 1AE6 E5                   push    HL              ; Save address of line start
1275+ 1AE7 EB                   ex      DE,HL           ; Line number to HL
1276+ 1AE8 CD 44 30             call    PRNTHL          ; Output line number in decimal
1277+ 1AEB 3E 20                ld      A,SPC           ; Space after line number
1278+ 1AED E1                   pop     HL              ; Restore start of line address
1279+ 1AEE CD CE 19     LSTLP2: call    OUTC            ; Output character in A
1280+ 1AF1 7E           LSTLP3: ld      A,(HL)          ; Get next byte in line
1281+ 1AF2 B7                   or      A               ; End of line?
1282+ 1AF3 23                   inc     HL              ; To next byte in line
1283+ 1AF4 CA 18 1B             jp      Z,NXTLN         ; Yes - check next line
1284+ 1AF7 F2 EE 1A             jp      P,LSTLP2        ; No token - output it
1285+ 1AFA D6 7F                sub     ZEND-1          ; Find and output word
1286+ 1AFC 4F                   ld      C,A             ; Token offset+1 to C
1287+ 1AFD 11 4B 13             ld      DE,WORDS        ; Reserved word list
1288+ 1B00 1A           FNDTOK: ld      A,(DE)          ; Get character in list
1289+ 1B01 13                   inc     DE              ; Move on to next
1290+ 1B02 B7                   or      A               ; Is it start of word?
1291+ 1B03 F2 00 1B             jp      P,FNDTOK        ; No - Keep looking for word
1292+ 1B06 0D                   dec     C               ; Count words
1293+ 1B07 C2 00 1B             jp      NZ,FNDTOK       ; Not there - keep looking
1294+ 1B0A E6 7F        OUTWRD: and     %01111111       ; Strip bit 7
1295+ 1B0C CD CE 19             call    OUTC            ; Output character
1296+ 1B0F 1A                   ld      A,(DE)          ; Get next character
1297+ 1B10 13                   inc     DE              ; Move on to next
1298+ 1B11 B7                   or      A               ; Is it end of word?
1299+ 1B12 F2 0A 1B             jp      P,OUTWRD        ; No - output the rest
1300+ 1B15 C3 F1 1A             jp      LSTLP3          ; Next byte in line
1301+ 1B18 D1           NXTLN:  pop     DE              ; recover address of current line
1302+ 1B19 2A 24 53             ld      HL,(TMPBFR2)    ; address of last line to print
1303+ 1B1C CD DE 3F             call    CMP16           ; check if current line is over last printable line
1304+ 1B1F DA 23 17             jp      C,PRNTOK        ; finish - leave & print OK
1305+ 1B22 D5                   push    DE              ; store address of current line
1306+ 1B23 C3 BD 1A             jp      LISTLP          ; continue listing
1307+ 1B26              ; look for the address of a program line
1308+ 1B26 E5           SRCHLIN:push    HL              ; store HL (this is needed because HL store the pointer to the input buffer)
1309+ 1B27 CD DF 17             call    SRCHLN          ; search for line number in DE
1310+ 1B2A E1                   pop     HL              ; retrieve HL
1311+ 1B2B C9                   ret                     ; return to caller
1312+ 1B2C              ; look for the address of a program line - if the line isn't found,
1313+ 1B2C              ; it look backward for the previous line
1314+ 1B2C E5           SRCLN:  push    HL              ; store HL
1315+ 1B2D CD DF 17     SRCLN1: call    SRCHLN          ; search for line in DE
1316+ 1B30 DA 38 1B             jp      C,LVSRLN        ; found it, leave loop
1317+ 1B33 1B                   dec     DE              ; not found, decrement number to look backward for an existing line
1318+ 1B34 7B                   ld      A,E
1319+ 1B35 B2                   or      D               ; is line number zero?
1320+ 1B36 20 F5                jr      NZ,SRCLN1       ; no, continue
1321+ 1B38 E1           LVSRLN: pop     HL              ; retrieve HL
1322+ 1B39 C9                   ret                     ; return to caller
1323+ 1B3A
1324+ 1B3A              ; during LISTing, check if PAUSE is pressed, then pause listing and
1325+ 1B3A              ; wait for another pressing of PAUSE to continue or CTRL-C/BREAK to exit
1326+ 1B3A 3A 5E 53     TSTSPC: ld      A,(TMPKEYBFR)   ; Get input character
1327+ 1B3D FE 20                cp      SPC             ; Is it SPACE?
1328+ 1B3F C0                   ret     NZ              ; No, return
1329+ 1B40 CD 60 33     WTSPC:  call    GETINP          ; Yes, stop listing and wait for another space or BREAK
1330+ 1B43 FE 20                cp      SPC             ; is it SPACE?
1331+ 1B45 20 05                jr      NZ,CNTWTSP      ; no, continue
1332+ 1B47 AF                   xor     A
1333+ 1B48 32 5E 53             ld      (TMPKEYBFR),A   ; reset key
1334+ 1B4B C9                   ret                     ; return to caller
1335+ 1B4C FE 03        CNTWTSP:cp      CTRLC           ; is it CTRL-C/BREAK?
1336+ 1B4E 20 F0                jr      NZ,WTSPC        ; no, loop
1337+ 1B50 C3 98 12             jp      BRKRET          ; exit and output "Ok"
1338+ 1B53
1339+ 1B53
1340+ 1B53 3E 64        FOR:    ld      A,$64           ; Flag "FOR" assignment
1341+ 1B55 32 F7 52             ld      (FORFLG),A      ; Save "FOR" flag
1342+ 1B58 CD CC 1D             call    LET             ; Set up initial index
1343+ 1B5B C1                   pop     BC              ; Drop RETurn address
1344+ 1B5C E5                   push    HL              ; Save code string address
1345+ 1B5D CD B5 1D             call    DATA            ; Get next statement address
1346+ 1B60 22 F3 52             ld      (LOOPST),HL     ; Save it for start of loop
1347+ 1B63 21 02 00             ld      HL,$0002        ; Offset for "FOR" block
1348+ 1B66 39                   add     HL,SP           ; Point to it
1349+ 1B67 CD 56 16     FORSLP: call    LOKFOR          ; Look for existing "FOR" block
1350+ 1B6A D1                   pop     DE              ; Get code string address
1351+ 1B6B C2 83 1B             jp      NZ,FORFND       ; No nesting found
1352+ 1B6E 09                   add     HL,BC           ; Move into "FOR" block
1353+ 1B6F D5                   push    DE              ; Save code string address
1354+ 1B70 2B                   dec     HL
1355+ 1B71 56                   ld      D,(HL)          ; Get MSB of loop statement
1356+ 1B72 2B                   dec     HL
1357+ 1B73 5E                   ld      E,(HL)          ; Get LSB of loop statement
1358+ 1B74 23                   inc     HL
1359+ 1B75 23                   inc     HL
1360+ 1B76 E5                   push    HL              ; Save block address
1361+ 1B77 2A F3 52             ld      HL,(LOOPST)     ; Get address of loop statement
1362+ 1B7A CD BD 19             call    CPDEHL          ; Compare the FOR loops
1363+ 1B7D E1                   pop     HL              ; Restore block address
1364+ 1B7E C2 67 1B             jp      NZ,FORSLP       ; Different FORs - Find another
1365+ 1B81 D1                   pop     DE              ; Restore code string address
1366+ 1B82 F9                   ld      SP,HL           ; Remove all nested loops
1367+ 1B83
1368+ 1B83 EB           FORFND: ex      DE,HL           ; Code string address to HL
1369+ 1B84 0E 08                ld      C,$08
1370+ 1B86 CD 86 16             call    CHKSTK          ; Check for 8 levels of stack
1371+ 1B89 E5                   push    HL              ; Save code string address
1372+ 1B8A 2A F3 52             ld      HL,(LOOPST)     ; Get first statement of loop
1373+ 1B8D E3                   ex      (SP),HL         ; Save and restore code string
1374+ 1B8E E5                   push    HL              ; Re-save code string address
1375+ 1B8F 2A F4 51             ld      HL,(LINEAT)     ; Get current line number
1376+ 1B92 E3                   ex      (SP),HL         ; Save and restore code string
1377+ 1B93 CD A0 20             call    TSTNUM          ; Make sure it's a number
1378+ 1B96 CD C3 19             call    CHKSYN          ; Make sure "TO" is next
1379+ 1B99 B7                   defb    ZTO             ; "TO" token
1380+ 1B9A CD 9D 20             call    GETNUM          ; Get "TO" expression value
1381+ 1B9D E5                   push    HL              ; Save code string address
1382+ 1B9E CD F6 2E             call    BCDEFP          ; Move "TO" value to BCDE
1383+ 1BA1 E1                   pop     HL              ; Restore code string address
1384+ 1BA2 C5                   push    BC              ; Save "TO" value in block
1385+ 1BA3 D5                   push    DE
1386+ 1BA4 01 00 81             ld      BC,$8100        ; BCDE - 1 (default STEP)
1387+ 1BA7 51                   ld      D,C             ; C=0
1388+ 1BA8 5A                   ld      E,D             ; D=0
1389+ 1BA9 7E                   ld      A,(HL)          ; Get next byte in code string
1390+ 1BAA FE BC                cp      ZSTEP           ; See if "STEP" is stated
1391+ 1BAC 3E 01                ld      A,$01           ; Sign of step = 1
1392+ 1BAE C2 BF 1B             jp      NZ,SAVSTP       ; No STEP given - Default to 1
1393+ 1BB1 CD 0C 1C             call    GETCHR          ; Jump over "STEP" token
1394+ 1BB4 CD 9D 20             call    GETNUM          ; Get step value
1395+ 1BB7 E5                   push    HL              ; Save code string address
1396+ 1BB8 CD F6 2E             call    BCDEFP          ; Move STEP to BCDE
1397+ 1BBB CD AA 2E             call    TSTSGN          ; Test sign of FPREG
1398+ 1BBE E1                   pop     HL              ; Restore code string address
1399+ 1BBF C5           SAVSTP: push    BC              ; Save the STEP value in block
1400+ 1BC0 D5                   push    DE
1401+ 1BC1 F5                   push    AF              ; Save sign of STEP
1402+ 1BC2 33                   inc     SP              ; Don't save flags
1403+ 1BC3 E5                   push    HL              ; Save code string address
1404+ 1BC4 2A FA 52             ld      HL,(BRKLIN)     ; Get address of index variable
1405+ 1BC7 E3                   ex      (SP),HL         ; Save and restore code string
1406+ 1BC8 06 81        PUTFID: ld      B,ZFOR          ; "FOR" block marker
1407+ 1BCA C5                   push    BC              ; Save it
1408+ 1BCB 33                   inc     SP              ; Don't save C
1409+ 1BCC
1410+ 1BCC CD 37 1C     RUNCNT: call    TSTBRK          ; Execution driver - Test break
1411+ 1BCF 22 FA 52             ld      (BRKLIN),HL     ; Save code address for break
1412+ 1BD2 7E                   ld      A,(HL)          ; Get next byte in code string
1413+ 1BD3 FE 3A                cp      ':'             ; Multi statement line?
1414+ 1BD5 CA EC 1B             jp      Z,EXCUTE        ; Yes - Execute it
1415+ 1BD8 B7                   or      A               ; End of line?
1416+ 1BD9 C2 C9 16             jp      NZ,SNERR        ; No - Syntax error
1417+ 1BDC 23                   inc     HL              ; Point to address of next line
1418+ 1BDD 7E                   ld      A,(HL)          ; Get LSB of line pointer
1419+ 1BDE 23                   inc     HL
1420+ 1BDF B6                   or      (HL)            ; Is it zero (End of prog)?
1421+ 1BE0 CA 5E 1C             jp      Z,ENDPRG        ; Yes - Terminate execution
1422+ 1BE3 23                   inc     HL              ; Point to line number
1423+ 1BE4 5E                   ld      E,(HL)          ; Get LSB of line number
1424+ 1BE5 23                   inc     HL
1425+ 1BE6 56                   ld      D,(HL)          ; Get MSB of line number
1426+ 1BE7 EB                   ex      DE,HL           ; Line number to HL
1427+ 1BE8 22 F4 51             ld      (LINEAT),HL     ; Save as current line number
1428+ 1BEB EB                   ex      DE,HL           ; Line number back to DE
1429+ 1BEC CD 0C 1C     EXCUTE: call    GETCHR          ; Get key word
1430+ 1BEF 11 CC 1B             ld      DE,RUNCNT       ; Where to RETurn to
1431+ 1BF2 D5                   push    DE              ; Save for RETurn
1432+ 1BF3 C8           IFJMP:  ret     Z               ; Go to RUNCNT if end of STMT
1433+ 1BF4
1434+ 1BF4 D6 80        ONJMP:  sub     ZEND            ; Is it a token?
1435+ 1BF6 DA CC 1D             jp      C,LET           ; No - try to assign it
1436+ 1BF9 FE 36                cp      ZNEW+1-ZEND     ; END to NEW ?
1437+ 1BFB D2 C9 16             jp      NC,SNERR        ; Not a key word - ?SN Error
1438+ 1BFE 07                   rlca                    ; Double it
1439+ 1BFF 4F                   ld      C,A             ; BC = Offset into table
1440+ 1C00 06 00                ld      B,0
1441+ 1C02 EB                   ex      DE,HL           ; Save code string address
1442+ 1C03 21 D8 14             ld      HL,WORDTB       ; Keyword address table
1443+ 1C06 09                   add     HL,BC           ; Point to routine address
1444+ 1C07 4E                   ld      C,(HL)          ; Get LSB of routine address
1445+ 1C08 23                   inc     HL
1446+ 1C09 46                   ld      B,(HL)          ; Get MSB of routine address
1447+ 1C0A C5                   push    BC              ; Save routine address
1448+ 1C0B EB                   ex      DE,HL           ; Restore code string address
1449+ 1C0C
1450+ 1C0C              ; get a char from input buffer: exit with NC if character found is
1451+ 1C0C              ; not a number; exit with Z if nothing found; char is into A
1452+ 1C0C 23           GETCHR: inc     HL              ; Point to next character
1453+ 1C0D 7E                   ld      A,(HL)          ; Get next code string byte
1454+ 1C0E FE 3A                cp      ':'             ; Z if ':'
1455+ 1C10 D0                   ret     NC              ; NC if > "9"
1456+ 1C11 FE 20                cp      SPC
1457+ 1C13 CA 0C 1C             jp      Z,GETCHR        ; Skip over spaces
1458+ 1C16 FE 30                cp      '0'
1459+ 1C18 3F                   ccf                     ; NC if < '0'
1460+ 1C19 3C                   inc     A               ; Test for zero - Leave carry
1461+ 1C1A 3D                   dec     A               ; Z if Null
1462+ 1C1B C9                   ret
1463+ 1C1C
1464+ 1C1C EB           RESTOR: ex      DE,HL           ; Save code string address
1465+ 1C1D 2A 7A 52             ld      HL,(BASTXT)     ; Point to start of program
1466+ 1C20 CA 31 1C             jp      Z,RESTNL        ; Just RESTORE - reset pointer
1467+ 1C23 EB                   ex      DE,HL           ; Restore code string address
1468+ 1C24 CD DC 1C             call    ATOH            ; Get line number to DE
1469+ 1C27 E5                   push    HL              ; Save code string address
1470+ 1C28 CD DF 17             call    SRCHLN          ; Search for line number in DE
1471+ 1C2B 60                   ld      H,B             ; HL = Address of line
1472+ 1C2C 69                   ld      L,C
1473+ 1C2D D1                   pop     DE              ; Restore code string address
1474+ 1C2E D2 8B 1D             jp      NC,ULERR        ; ?UL Error if not found
1475+ 1C31 2B           RESTNL: dec     HL              ; Byte before DATA statement
1476+ 1C32 22 6E 53     UPDATA: ld      (NXTDAT),HL     ; Update DATA pointer
1477+ 1C35 EB                   ex      DE,HL           ; Restore code string address
1478+ 1C36 C9                   ret
1479+ 1C37
1480+ 1C37
1481+ 1C37              ; check if CTRL-C is into input buffer
1482+ 1C37 DF           TSTBRK: rst     $18             ; Check input status
1483+ 1C38 C8                   ret     Z               ; No key, go back
1484+ 1C39 D7                   rst     $10             ; Get the key into A
1485+ 1C3A FE 1B                cp      ESC             ; Escape key?
1486+ 1C3C 28 11                jr      Z,BRK           ; Yes, break
1487+ 1C3E FE 03                cp      CTRLC           ; <Ctrl-C>
1488+ 1C40 28 0D                jr      Z,BRK           ; Yes, break
1489+ 1C42 FE 13                cp      CTRLS           ; Stop scrolling?
1490+ 1C44 C0                   ret     NZ              ; Other key, ignore
1491+ 1C45
1492+ 1C45
1493+ 1C45              ; wait for a key while listing
1494+ 1C45 D7           STALL:  rst     $10             ; Wait for key
1495+ 1C46 FE 11                cp      CTRLQ           ; Resume scrolling?
1496+ 1C48 C8                   ret     Z               ; Release the chokehold
1497+ 1C49 FE 03                cp      CTRLC           ; Second break?
1498+ 1C4B 28 07                jr      Z,STOP          ; Break during hold exits prog
1499+ 1C4D 18 F6                jr      STALL           ; Loop until <Ctrl-Q> or <brk>
1500+ 1C4F
1501+ 1C4F 3E FF        BRK:    ld      A,$FF           ; Set BRKFLG
1502+ 1C51 32 EE 51             ld      (BRKFLG),A      ; Store it
1503+ 1C54
1504+ 1C54 C0           STOP:   ret     NZ              ; Exit if anything else
1505+ 1C55 F6                   defb    $F6             ; Flag "STOP"
1506+ 1C56 C0           PEND:   ret     NZ              ; Exit if anything else
1507+ 1C57 22 FA 52             ld      (BRKLIN),HL     ; Save point of break
1508+ 1C5A 21                   defb    $21             ; Skip "OR 11111111B"
1509+ 1C5B F6 FF        INPBRK: or      %11111111       ; Flag "Break" wanted
1510+ 1C5D C1                   pop     BC              ; Return not needed and more
1511+ 1C5E 2A F4 51     ENDPRG: ld      HL,(LINEAT)     ; Get current line number
1512+ 1C61 F5                   push    AF              ; Save STOP / END status
1513+ 1C62 7D                   ld      A,L             ; Is it direct break?
1514+ 1C63 A4                   and     H
1515+ 1C64 3C                   inc     A               ; Line is -1 if direct break
1516+ 1C65 CA 71 1C             jp      Z,NOLIN         ; Yes - No line number
1517+ 1C68 22 FE 52             ld      (ERRLIN),HL     ; Save line of break
1518+ 1C6B 2A FA 52             ld      HL,(BRKLIN)     ; Get point of break
1519+ 1C6E 22 00 53             ld      (CONTAD),HL     ; Save point to CONTinue
1520+ 1C71 AF           NOLIN:  xor     A
1521+ 1C72 32 EA 51             ld      (CTLOFG),A      ; Enable output
1522+ 1C75 CD C7 1E             call    STTLIN          ; Start a new line
1523+ 1C78 F1                   pop     AF              ; Restore STOP / END status
1524+ 1C79 21 4C 16             ld      HL,BRKMSG       ; "Break" message
1525+ 1C7C C2 82 1C             jp      NZ,ERRINT       ; "in line" wanted?
1526+ 1C7F C3 23 17             jp      PRNTOK          ; Go to command mode
1527+ 1C82 CD A3 16     ERRINT: call    EXITGM          ; exit from graphics mode
1528+ 1C85 C3 01 17             jp      ERRIN           ; print message
1529+ 1C88
1530+ 1C88
1531+ 1C88              ; CONTinue after a break/error
1532+ 1C88 21 FF FF     CONT:   ld      HL,-1           ; reset...
1533+ 1C8B 22 F6 51             ld      (HLPLN),HL      ; ...HELP line register
1534+ 1C8E 2A 00 53             ld      HL,(CONTAD)     ; Get CONTinue address
1535+ 1C91 7C                   ld      A,H             ; Is it zero?
1536+ 1C92 B5                   or      L
1537+ 1C93 1E 20                ld      E,CN            ; ?CN Error
1538+ 1C95 CA DD 16             jp      Z,ERROR         ; Yes - output "?CN Error"
1539+ 1C98 EB                   ex      DE,HL           ; Save code string address
1540+ 1C99 2A FE 52             ld      HL,(ERRLIN)     ; Get line of last break
1541+ 1C9C 22 F4 51             ld      (LINEAT),HL     ; Set up current line number
1542+ 1C9F EB                   ex      DE,HL           ; Restore code string address
1543+ 1CA0 C9                   ret                     ; CONTinue where left off
1544+ 1CA1
1545+ 1CA1 E5           ACCSUM: push    HL              ; Save address in array
1546+ 1CA2 2A EB 51             ld      HL,(CHKSUM)     ; Get check sum
1547+ 1CA5 06 00                ld      B,$00           ; BC - Value of byte
1548+ 1CA7 4F                   ld      C,A
1549+ 1CA8 09                   add     HL,BC           ; Add byte to check sum
1550+ 1CA9 22 EB 51             ld      (CHKSUM),HL     ; Re-save check sum
1551+ 1CAC E1                   pop     HL              ; Restore address in array
1552+ 1CAD C9                   ret
1553+ 1CAE
1554+ 1CAE 7E           CHKLTR: ld      A,(HL)          ; Get byte
1555+ 1CAF FE 41                cp      'A'             ; < 'a' ?
1556+ 1CB1 D8                   ret     C               ; Carry set if not letter
1557+ 1CB2 FE 5B                cp      'Z'+1           ; > 'z' ?
1558+ 1CB4 3F                   ccf
1559+ 1CB5 C9                   ret                     ; Carry set if not letter
1560+ 1CB6
1561+ 1CB6 CD 0C 1C     FPSINT: call    GETCHR          ; Get next character
1562+ 1CB9 CD 9D 20     POSINT: call    GETNUM          ; Get integer 0 to 32767
1563+ 1CBC CD AA 2E     DEPINT: call    TSTSGN          ; Test sign of FPREG
1564+ 1CBF FA D7 1C             jp      M,FCERR         ; Negative - ?FC Error
1565+ 1CC2 3A 79 53     DEINT:  ld      A,(FPEXP)       ; Get integer value to DE
1566+ 1CC5 FE 90                cp      $80+$10         ; Exponent in range (16 bits)?
1567+ 1CC7 DA 52 2F             jp      C,FPINT         ; Yes - convert it
1568+ 1CCA 01 80 90             ld      BC,$9080        ; BCDE = -32768
1569+ 1CCD 11 00 00             ld      DE,$0000
1570+ 1CD0 E5                   push    HL              ; Save code string address
1571+ 1CD1 CD 25 2F             call    CMPNUM          ; Compare FPREG with BCDE
1572+ 1CD4 E1                   pop     HL              ; Restore code string address
1573+ 1CD5 51                   ld      D,C             ; MSB to D
1574+ 1CD6 C8                   ret     Z               ; Return if in range
1575+ 1CD7 1E 08        FCERR:  ld      E,FC            ; ?FC Error
1576+ 1CD9 C3 DD 16             jp      ERROR           ; Output error-
1577+ 1CDC
1578+ 1CDC
1579+ 1CDC              ; convert a number in ASCII chars into an integer into DE
1580+ 1CDC 2B           ATOH:   dec     HL              ; ASCII number to DE binary
1581+ 1CDD 11 00 00     GETLN:  ld      DE,$0000        ; Get number to DE
1582+ 1CE0 CD 0C 1C     GTLNLP: call    GETCHR          ; Get next character
1583+ 1CE3 D0                   ret     NC              ; Exit if not a digit
1584+ 1CE4 E5                   push    HL              ; Save code string address
1585+ 1CE5 F5                   push    AF              ; Save digit
1586+ 1CE6 21 98 19             ld      HL,65529/10     ; Largest number 65529
1587+ 1CE9 CD BD 19             call    CPDEHL          ; Number in range?
1588+ 1CEC DA C9 16             jp      C,SNERR         ; No - ?SN Error
1589+ 1CEF 62                   ld      H,D             ; HL = Number
1590+ 1CF0 6B                   ld      L,E
1591+ 1CF1 19                   add     HL,DE           ; Times 2
1592+ 1CF2 29                   add     HL,HL           ; Times 4
1593+ 1CF3 19                   add     HL,DE           ; Times 5
1594+ 1CF4 29                   add     HL,HL           ; Times 10
1595+ 1CF5 F1                   pop     AF              ; Restore digit
1596+ 1CF6 D6 30                sub     '0'             ; Make it 0 to 9
1597+ 1CF8 5F                   ld      E,A             ; DE = Value of digit
1598+ 1CF9 16 00                ld      D,0
1599+ 1CFB 19                   add     HL,DE           ; Add to number
1600+ 1CFC EB                   ex      DE,HL           ; Number to DE
1601+ 1CFD E1                   pop     HL              ; Restore code string address
1602+ 1CFE C3 E0 1C             jp      GTLNLP          ; Go to next character
1603+ 1D01
1604+ 1D01 CA 0F 18     CLEAR:  jp      Z,INTVAR        ; Just "CLEAR" Keep parameters
1605+ 1D04 CD 9D 20             call    GETNUM          ; Evaluate a number
1606+ 1D07 CD C2 1C             call    DEINT           ; Get integer -32768 to 32767 into DE
1607+ 1D0A 2B                   dec     HL              ; Cancel increment
1608+ 1D0B CD 0C 1C             call    GETCHR          ; Get next character
1609+ 1D0E E5                   push    HL              ; Save code string address
1610+ 1D0F 2A DB 52             ld      HL,(LSTRAM)     ; Get end of RAM
1611+ 1D12 CA 2A 1D             jp      Z,STORED        ; No value given - Use stored
1612+ 1D15 E1                   pop     HL              ; Restore code string address
1613+ 1D16 CD C3 19             call    CHKSYN          ; Check for comma
1614+ 1D19 2C                   defb    ','
1615+ 1D1A D5                   push    DE              ; Save number
1616+ 1D1B CD 9D 20             call    GETNUM          ; Evaluate a number
1617+ 1D1E CD C2 1C             call    DEINT           ; Get integer -32768 to 32767 into DE
1618+ 1D21 2B                   dec     HL              ; Cancel increment
1619+ 1D22 CD 0C 1C             call    GETCHR          ; Get next character
1620+ 1D25 C2 C9 16             jp      NZ,SNERR        ; ?SN Error if more on line
1621+ 1D28 E3                   ex      (SP),HL         ; Save code string address
1622+ 1D29 EB                   ex      DE,HL           ; Number to DE
1623+ 1D2A 7D           STORED: ld      A,L             ; Get LSB of new RAM top
1624+ 1D2B 93                   sub     E               ; Subtract LSB of string space
1625+ 1D2C 5F                   ld      E,A             ; Save LSB
1626+ 1D2D 7C                   ld      A,H             ; Get MSB of new RAM top
1627+ 1D2E 9A                   sbc     A,D             ; Subtract MSB of string space
1628+ 1D2F 57                   ld      D,A             ; Save MSB
1629+ 1D30 DA 9E 16             jp      C,OMERR         ; ?OM Error if not enough mem
1630+ 1D33 E5                   push    HL              ; Save RAM top
1631+ 1D34 2A 68 53             ld      HL,(PROGND)     ; Get program end
1632+ 1D37 01 28 00             ld      BC,$28          ; 40 Bytes minimum working RAM
1633+ 1D3A 09                   add     HL,BC           ; Get lowest address
1634+ 1D3B CD BD 19             call    CPDEHL          ; Enough memory?
1635+ 1D3E D2 9E 16             jp      NC,OMERR        ; No - ?OM Error
1636+ 1D41 EB                   ex      DE,HL           ; RAM top to HL
1637+ 1D42 22 F2 51             ld      (STRSPC),HL     ; Set new string space
1638+ 1D45 E1                   pop     HL              ; End of memory to use
1639+ 1D46 22 DB 52             ld      (LSTRAM),HL     ; Set new top of RAM
1640+ 1D49 E1                   pop     HL              ; Restore code string address
1641+ 1D4A C3 0F 18             jp      INTVAR          ; Initialise variables
1642+ 1D4D
1643+ 1D4D E5           RUN:    push    HL              ; store HL
1644+ 1D4E 21 FF FF             ld      HL,-1           ; reset...
1645+ 1D51 22 F6 51             ld      (HLPLN),HL      ; ...HELP line register
1646+ 1D54 E1                   pop     HL              ; retrieve HL
1647+ 1D55 CA 0B 18             jp      Z,RUNFST        ; RUN from start if just RUN
1648+ 1D58 CD 0F 18             call    INTVAR          ; Initialise variables
1649+ 1D5B 01 CC 1B             ld      BC,RUNCNT       ; Execution driver loop
1650+ 1D5E C3 71 1D             jp      RUNLIN          ; RUN from line number
1651+ 1D61
1652+ 1D61 0E 03        GOSUB:  ld      C,$03           ; 3 Levels of stack needed
1653+ 1D63 CD 86 16             call    CHKSTK          ; Check for 3 levels of stack
1654+ 1D66 C1                   pop     BC              ; Get return address
1655+ 1D67 E5                   push    HL              ; Save code string for RETURN
1656+ 1D68 E5                   push    HL              ; And for GOSUB routine
1657+ 1D69 2A F4 51             ld      HL,(LINEAT)     ; Get current line
1658+ 1D6C E3                   ex      (SP),HL         ; Into stack - Code string out
1659+ 1D6D 3E 8C                ld      A,ZGOSUB        ; "GOSUB" token
1660+ 1D6F F5                   push    AF              ; Save token
1661+ 1D70 33                   inc     SP              ; Don't save flags
1662+ 1D71
1663+ 1D71 C5           RUNLIN: push    BC              ; Save return address
1664+ 1D72 CD DC 1C     GOTO:   call    ATOH            ; ASCII number to DE binary
1665+ 1D75 CD B7 1D             call    REM             ; Get end of line
1666+ 1D78 E5                   push    HL              ; Save end of line
1667+ 1D79 2A F4 51             ld      HL,(LINEAT)     ; Get current line
1668+ 1D7C CD BD 19             call    CPDEHL          ; Line after current?
1669+ 1D7F E1                   pop     HL              ; Restore end of line
1670+ 1D80 23                   inc     HL              ; Start of next line
1671+ 1D81 DC E2 17             call    C,SRCHLP        ; Line is after current line
1672+ 1D84 D4 DF 17             call    NC,SRCHLN       ; Line is before current line
1673+ 1D87 60                   ld      H,B             ; Set up code string address
1674+ 1D88 69                   ld      L,C
1675+ 1D89 2B                   dec     HL              ; Incremented after
1676+ 1D8A D8                   ret     C               ; Line found
1677+ 1D8B 1E 0E        ULERR:  ld      E,UL            ; ?UL Error
1678+ 1D8D C3 DD 16             jp      ERROR           ; Output error message
1679+ 1D90
1680+ 1D90 C0           RETURN: ret     NZ              ; Return if not just RETURN
1681+ 1D91 16 FF                ld      D,-1            ; Flag "GOSUB" search
1682+ 1D93 CD 52 16             call    BAKSTK          ; Look "GOSUB" block
1683+ 1D96 F9                   ld      SP,HL           ; Kill all FORs in subroutine
1684+ 1D97 FE 8C                cp      ZGOSUB          ; Test for "GOSUB" token
1685+ 1D99 1E 04                ld      E,RG            ; ?RG Error
1686+ 1D9B C2 DD 16             jp      NZ,ERROR        ; Error if no "GOSUB" found
1687+ 1D9E E1                   pop     HL              ; Get RETURN line number
1688+ 1D9F 22 F4 51             ld      (LINEAT),HL     ; Save as current
1689+ 1DA2 23                   inc     HL              ; Was it from direct statement?
1690+ 1DA3 7C                   ld      A,H
1691+ 1DA4 B5                   or      L               ; Return to line
1692+ 1DA5 C2 AF 1D             jp      NZ,RETLIN       ; No - Return to line
1693+ 1DA8 3A F8 52             ld      A,(LSTBIN)      ; Any INPUT in subroutine?
1694+ 1DAB B7                   or      A               ; If so buffer is corrupted
1695+ 1DAC C2 22 17             jp      NZ,POPNOK       ; Yes - Go to command mode
1696+ 1DAF 21 CC 1B     RETLIN: ld      HL,RUNCNT       ; Execution driver loop
1697+ 1DB2 E3                   ex      (SP),HL         ; Into stack - Code string out
1698+ 1DB3 3E                   defb    $3E             ; Skip "pop HL"
1699+ 1DB4 E1           NXTDTA: pop     HL              ; Restore code string address
1700+ 1DB5
1701+ 1DB5 01 3A        DATA:   defb    $01,$3A         ; ':' End of statement (stands for LD BC,$0E3A - NOP)
1702+ 1DB7 0E 00        REM:    ld      C,$00           ; 00  End of statement
1703+ 1DB9 06 00                ld      B,$00
1704+ 1DBB 79           NXTSTL: ld      A,C             ; Statement and byte
1705+ 1DBC 48                   ld      C,B
1706+ 1DBD 47                   ld      B,A             ; Statement end byte
1707+ 1DBE 7E           NXTSTT: ld      A,(HL)          ; Get byte
1708+ 1DBF B7                   or      A               ; End of line?
1709+ 1DC0 C8                   ret     Z               ; Yes - Exit
1710+ 1DC1 B8                   cp      B               ; End of statement?
1711+ 1DC2 C8                   ret     Z               ; Yes - Exit
1712+ 1DC3 23                   inc     HL              ; Next byte
1713+ 1DC4 FE 22                cp      $22             ; '"'             ; Literal string?
1714+ 1DC6 CA BB 1D             jp      Z,NXTSTL        ; Yes - Look for another '"'
1715+ 1DC9 C3 BE 1D             jp      NXTSTT          ; Keep looking
1716+ 1DCC
1717+ 1DCC CD AC 22     LET:    call    GETVAR          ; Get variable name
1718+ 1DCF CD C3 19             call    CHKSYN          ; Make sure "=" follows
1719+ 1DD2 C8                   defb    ZEQUAL          ; "=" token
1720+ 1DD3 D5                   push    DE              ; Save address of variable
1721+ 1DD4 3A D9 52             ld      A,(TYPE)        ; Get data type
1722+ 1DD7 F5                   push    AF              ; Save type
1723+ 1DD8 CD AF 20             call    EVAL            ; Evaluate expression
1724+ 1DDB F1                   pop     AF              ; Restore type
1725+ 1DDC E3                   ex      (SP),HL         ; Save code - Get var addr
1726+ 1DDD 22 FA 52             ld      (BRKLIN),HL     ; Save address of variable
1727+ 1DE0 1F                   rra                     ; Adjust type
1728+ 1DE1 CD A2 20             call    CHKTYP          ; Check types are the same
1729+ 1DE4 CA 1F 1E             jp      Z,LETNUM        ; Numeric - Move value
1730+ 1DE7 E5           LETSTR: push    HL              ; Save address of string var
1731+ 1DE8 2A 76 53             ld      HL,(FPREG)      ; Pointer to string entry
1732+ 1DEB E5                   push    HL              ; Save it on stack
1733+ 1DEC 23                   inc     HL              ; Skip over length
1734+ 1DED 23                   inc     HL
1735+ 1DEE 5E                   ld      E,(HL)          ; LSB of string address
1736+ 1DEF 23                   inc     HL
1737+ 1DF0 56                   ld      D,(HL)          ; MSB of string address
1738+ 1DF1 2A 7A 52             ld      HL,(BASTXT)     ; Point to start of program
1739+ 1DF4 CD BD 19             call    CPDEHL          ; Is string before program?
1740+ 1DF7 D2 0E 1E             jp      NC,CRESTR       ; Yes - Create string entry
1741+ 1DFA 2A F2 51             ld      HL,(STRSPC)     ; Point to string space
1742+ 1DFD CD BD 19             call    CPDEHL          ; Is string literal in program?
1743+ 1E00 D1                   pop     DE              ; Restore address of string
1744+ 1E01 D2 16 1E             jp      NC,MVSTPT       ; Yes - Set up pointer
1745+ 1E04 21 EB 52             ld      HL,TMPSTR       ; Temporary string pool
1746+ 1E07 CD BD 19             call    CPDEHL          ; Is string in temporary pool?
1747+ 1E0A D2 16 1E             jp      NC,MVSTPT       ; No - Set up pointer
1748+ 1E0D 3E                   defb    $3E             ; Skip "pop DE"
1749+ 1E0E D1           CRESTR: pop     DE              ; Restore address of string
1750+ 1E0F CD 06 27             call    BAKTMP          ; Back to last tmp-str entry
1751+ 1E12 EB                   ex      DE,HL           ; Address of string entry
1752+ 1E13 CD 3F 25             call    SAVSTR          ; Save string in string area
1753+ 1E16 CD 06 27     MVSTPT: call    BAKTMP          ; Back to last tmp-str entry
1754+ 1E19 E1                   pop     HL              ; Get string pointer
1755+ 1E1A CD 05 2F             call    DETHL4          ; Move string pointer to var
1756+ 1E1D E1                   pop     HL              ; Restore code string address
1757+ 1E1E C9                   ret
1758+ 1E1F
1759+ 1E1F E5           LETNUM: push    HL              ; Save address of variable
1760+ 1E20 CD 02 2F             call    FPTHL           ; Move value to variable
1761+ 1E23 D1                   pop     DE              ; Restore address of variable
1762+ 1E24 E1                   pop     HL              ; Restore code string address
1763+ 1E25 C9                   ret
1764+ 1E26
1765+ 1E26 CD 23 29     ON:     call    GETINT          ; Get integer 0-255
1766+ 1E29 7E                   ld      A,(HL)          ; Get "GOTO" or "GOSUB" token
1767+ 1E2A 47                   ld      B,A             ; Save in B
1768+ 1E2B FE 8C                cp      ZGOSUB          ; "GOSUB" token?
1769+ 1E2D CA 35 1E             jp      Z,ONGO          ; Yes - Find line number
1770+ 1E30 CD C3 19             call    CHKSYN          ; Make sure it's "GOTO"
1771+ 1E33 88                   defb    ZGOTO           ; "GOTO" token
1772+ 1E34 2B                   dec     HL              ; Cancel increment
1773+ 1E35 4B           ONGO:   ld      C,E             ; Integer of branch value
1774+ 1E36 0D           ONGOLP: dec     C               ; Count branches
1775+ 1E37 78                   ld      A,B             ; Get "GOTO" or "GOSUB" token
1776+ 1E38 CA F4 1B             jp      Z,ONJMP         ; Go to that line if right one
1777+ 1E3B CD DD 1C             call    GETLN           ; Get line number to DE
1778+ 1E3E FE 2C                cp      ','             ; Another line number?
1779+ 1E40 C0                   ret     NZ              ; No - Drop through
1780+ 1E41 C3 36 1E             jp      ONGOLP          ; Yes - loop
1781+ 1E44
1782+ 1E44 CD AF 20     IF:     call    EVAL            ; Evaluate expression
1783+ 1E47 7E                   ld      A,(HL)          ; Get token
1784+ 1E48 FE 88                cp      ZGOTO           ; "GOTO" token?
1785+ 1E4A CA 52 1E             jp      Z,IFGO          ; Yes - Get line
1786+ 1E4D CD C3 19             call    CHKSYN          ; Make sure it's "THEN"
1787+ 1E50 BA                   defb    ZTHEN           ; "THEN" token
1788+ 1E51 2B                   dec     HL              ; Cancel increment
1789+ 1E52 CD A0 20     IFGO:   call    TSTNUM          ; Make sure it's numeric
1790+ 1E55 CD AA 2E             call    TSTSGN          ; Test state of expression
1791+ 1E58 CA 64 1E             jp      Z,IF1           ; False - Jump over
1792+ 1E5B CD 0C 1C     IF0:    call    GETCHR          ; Get next character
1793+ 1E5E DA 72 1D             jp      C,GOTO          ; Number - GOTO that line
1794+ 1E61 C3 F3 1B             jp      IFJMP           ; Otherwise do statement
1795+ 1E64 0E AE        IF1:    ld      C,ZELSE
1796+ 1E66 CD B9 1D             call    REM+2           ; check statement
1797+ 1E69 B7                   or      A               ; end of line?
1798+ 1E6A C8                   ret     Z               ; yes, leave
1799+ 1E6B FE AE                cp      ZELSE
1800+ 1E6D 20 F5                jr      NZ,IF1          ; ELSE not found, continue check
1801+ 1E6F C3 5B 1E             jp      IF0             ; return to IF
1802+ 1E72
1803+ 1E72
1804+ 1E72 2B           MRPRNT: dec     HL              ; dec 'cos GETCHR INCs
1805+ 1E73 CD 0C 1C             call    GETCHR          ; Get next character
1806+ 1E76 CA D9 1E     PRINT:  jp      Z,PRNTCRLF      ; CRLF if just PRINT
1807+ 1E79 C8           PRNTLP: ret     Z               ; End of list - Exit
1808+ 1E7A FE B6                cp      ZTAB            ; "TAB(" token?
1809+ 1E7C CA 01 1F             jp      Z,DOTAB         ; Yes - Do TAB routine
1810+ 1E7F FE B9                cp      ZSPC            ; "SPC(" token?
1811+ 1E81 CA 01 1F             jp      Z,DOTAB         ; Yes - Do SPC routine
1812+ 1E84 E5                   push    HL              ; Save code string address
1813+ 1E85 FE 2C                cp      ','             ; Comma?
1814+ 1E87 CA E8 1E             jp      Z,DOCOM         ; Yes - Move to next zone
1815+ 1E8A FE 3B                cp      ';'             ; Semi-colon?
1816+ 1E8C CA 25 1F             jp      Z,NEXITM        ; Do semi-colon routine
1817+ 1E8F C1                   pop     BC              ; Code string address to BC
1818+ 1E90 CD AF 20             call    EVAL            ; Evaluate expression
1819+ 1E93 E5                   push    HL              ; Save code string address
1820+ 1E94 3A D9 52             ld      A,(TYPE)        ; Get variable type
1821+ 1E97 B7                   or      A               ; Is it a string variable?
1822+ 1E98 C2 C0 1E             jp      NZ,PRNTST       ; Yes - Output string contents
1823+ 1E9B CD 4F 30             call    NUMASC          ; Convert number to text
1824+ 1E9E CD 63 25             call    CRTST           ; Create temporary string
1825+ 1EA1 36 00                ld      (HL),NLLCR      ; Followed by a NULL char (was SPC, space)
1826+ 1EA3 2A 76 53             ld      HL,(FPREG)      ; Get length of output
1827+ 1EA6 34                   inc     (HL)            ; Plus 1 for the space
1828+ 1EA7 2A 76 53             ld      HL,(FPREG)      ; < Not needed >
1829+ 1EAA 3A E7 51             ld      A,(LWIDTH)      ; Get width of line
1830+ 1EAD 47                   ld      B,A             ; To B
1831+ 1EAE 04                   inc     B               ; Width 255 (No limit)?
1832+ 1EAF CA BC 1E             jp      Z,PRNTNB        ; Yes - Output number string
1833+ 1EB2 04                   inc     B               ; Adjust it
1834+ 1EB3 3A D7 52             ld      A,(CURPOS)      ; Get cursor position
1835+ 1EB6 86                   add     A,(HL)          ; Add length of string
1836+ 1EB7 3D                   dec     A               ; Adjust it
1837+ 1EB8 B8                   cp      B               ; Will output fit on this line?
1838+ 1EB9 D4 D9 1E             call    NC,PRNTCRLF     ; No - CRLF first
1839+ 1EBC CD A8 25     PRNTNB: call    PRS1            ; Output string at (HL)
1840+ 1EBF AF                   xor     A               ; Skip call by setting 'z' flag
1841+ 1EC0 C4 A8 25     PRNTST: call    NZ,PRS1         ; Output string at (HL)
1842+ 1EC3 E1                   pop     HL              ; Restore code string address
1843+ 1EC4 C3 72 1E             jp      MRPRNT          ; See if more to PRINT
1844+ 1EC7
1845+ 1EC7 3A D7 52     STTLIN: ld      A,(CURPOS)      ; Make sure on new line
1846+ 1ECA B7                   or      A               ; Already at start?
1847+ 1ECB C8                   ret     Z               ; Yes - Do nothing
1848+ 1ECC C3 D9 1E             jp      PRNTCRLF        ; Start a new line
1849+ 1ECF
1850+ 1ECF AF           ENDINP: xor     A
1851+ 1ED0 32 5C 53             ld      (KBDNPT),A      ; char is not from keyboard
1852+ 1ED3 77                   ld      (HL),A          ; Mark end of buffer
1853+ 1ED4 21 7C 52             ld      HL,BUFFER-1     ; Point to buffer
1854+ 1ED7 18 0A                jr      CNTEND
1855+ 1ED9 3E 0D        PRNTCRLF:ld     A,CR            ; Load a CR
1856+ 1EDB CD CE 19             call    OUTC            ; Output character
1857+ 1EDE 3E 0A                ld      A,LF            ; Load a LF
1858+ 1EE0 CD CE 19             call    OUTC            ; Output character
1859+ 1EE3 AF           CNTEND: xor     A               ; Set to position 0
1860+ 1EE4 32 D7 52             ld      (CURPOS),A      ; Store it
1861+ 1EE7 C9                   ret                     ; return to caller
1862+ 1EE8
1863+ 1EE8 3A E8 51     DOCOM:  ld      A,(COMMAN)      ; Get comma width
1864+ 1EEB 47                   ld      B,A             ; Save in B
1865+ 1EEC 3A 17 53             ld      A,(SCR_CURS_X)  ; Get current position
1866+ 1EEF B8                   cp      B               ; Within the limit?
1867+ 1EF0 D4 D9 1E             call    NC,PRNTCRLF     ; No - output CRLF
1868+ 1EF3 D2 25 1F             jp      NC,NEXITM       ; Get next item
1869+ 1EF6 D6 0A        ZONELP: sub     $0A             ; Next zone of 10 characters
1870+ 1EF8 D2 F6 1E             jp      NC,ZONELP       ; Repeat if more zones
1871+ 1EFB 2F                   cpl                     ; Number of null chars to output
1872+ 1EFC 0E 00                ld      C,NLLCR         ; null char
1873+ 1EFE C3 1B 1F             jp      ASPCS           ; Output them
1874+ 1F01
1875+ 1F01 F5           DOTAB:  push    AF              ; Save token
1876+ 1F02 CD 20 29             call    FNDNUM          ; Evaluate expression
1877+ 1F05 CD C3 19             call    CHKSYN          ; Make sure ")" follows
1878+ 1F08 29                   defb    ')'
1879+ 1F09 2B                   dec     HL              ; Back space on to ")"
1880+ 1F0A F1                   pop     AF              ; Restore token
1881+ 1F0B 0E 00                ld      C,NLLCR         ; for SPC we use NULL char (was SPACE)
1882+ 1F0D D6 B9                sub     ZSPC            ; Was it "SPC(" ?
1883+ 1F0F E5                   push    HL              ; Save code string address
1884+ 1F10 CA 16 1F             jp      Z,DOSPC         ; Yes - Do 'E' spaces
1885+ 1F13 3A 17 53             ld      A,(SCR_CURS_X)  ; Get current X position
1886+ 1F16 2F           DOSPC:  cpl                     ; Number of spaces to print to
1887+ 1F17 83                   add     A,E             ; Total number to print
1888+ 1F18 D2 25 1F             jp      NC,NEXITM       ; TAB < Current POS(X)
1889+ 1F1B 3C           ASPCS:  inc     A               ; Output A spaces
1890+ 1F1C 47                   ld      B,A             ; Save number to print
1891+ 1F1D 79           SPCLP:  ld      A,C             ; char to print
1892+ 1F1E CD CE 19             call    OUTC            ; Output character in A
1893+ 1F21 05                   dec     B               ; Count them
1894+ 1F22 C2 1D 1F             jp      NZ,SPCLP        ; Repeat if more
1895+ 1F25 E1           NEXITM: pop     HL              ; Restore code string address
1896+ 1F26 CD 0C 1C             call    GETCHR          ; Get next character
1897+ 1F29 C3 79 1E             jp      PRNTLP          ; More to print
1898+ 1F2C
1899+ 1F2C 3F 52 65 64  REDO:   defb    "?Redo from start",CR,0
1899+ 1F30 6F 20 66 72
1899+ 1F34 6F 6D 20 73
1899+ 1F38 74 61 72 74
1899+ 1F3C 0D 00
1900+ 1F3E
1901+ 1F3E 3A F9 52     BADINP: ld      A,(READFG)      ; READ or INPUT?
1902+ 1F41 B7                   or      A
1903+ 1F42 C2 C3 16             jp      NZ,DATSNR       ; READ - ?SN Error
1904+ 1F45 C1                   pop     BC              ; Throw away code string addr
1905+ 1F46 21 2C 1F             ld      HL,REDO         ; "Redo from start" message
1906+ 1F49 CD A5 25             call    PRS             ; Output string
1907+ 1F4C C3 3E 18             jp      DOAGN           ; Do last INPUT again
1908+ 1F4F
1909+ 1F4F CD 10 25     INPUT:  call    IDTEST          ; Test for illegal direct
1910+ 1F52 7E                   ld      A,(HL)          ; Get character after "INPUT"
1911+ 1F53 FE 22                cp      $22             ; '"' ; Is there a prompt string?
1912+ 1F55 3E 00                ld      A,$00           ; Clear A and leave flags
1913+ 1F57 32 EA 51             ld      (CTLOFG),A      ; Enable output
1914+ 1F5A C2 69 1F             jp      NZ,NOPMPT       ; No prompt - get input
1915+ 1F5D CD 64 25             call    QTSTR           ; Get string terminated by '"'
1916+ 1F60 CD C3 19             call    CHKSYN          ; Check for ';' after prompt
1917+ 1F63 3B                   defb    ";"
1918+ 1F64 E5                   push    HL              ; Save code string address
1919+ 1F65 CD A8 25             call    PRS1            ; Output prompt string
1920+ 1F68 3E                   defb    $3E             ; Skip "push HL"
1921+ 1F69 E5           NOPMPT: push    HL              ; Save code string address
1922+ 1F6A CD 42 18             call    PROMPT          ; Get input with "? " prompt
1923+ 1F6D C1                   pop     BC              ; Restore code string address
1924+ 1F6E DA 5B 1C             jp      C,INPBRK        ; Break pressed - Exit
1925+ 1F71 23                   inc     HL              ; Next byte
1926+ 1F72 7E                   ld      A,(HL)          ; Get it
1927+ 1F73 B7                   or      A               ; End of line?
1928+ 1F74 2B                   dec     HL              ; Back again
1929+ 1F75 C5                   push    BC              ; Re-save code string address
1930+ 1F76 3A 64 53             ld      A,(SERIALS_EN)  ; load serial state
1931+ 1F79 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
1932+ 1F7B CC 8F 01             call    Z,A_RTS_OFF      ; yes, set RTS on
1933+ 1F7E CD 2C 09             call    CURSOR_OFF      ; disable cursor
1934+ 1F81 CA B4 1D             jp      Z,NXTDTA        ; Yes - Find next DATA stmt
1935+ 1F84 36 2C                ld      (HL),','        ; Store comma as separator
1936+ 1F86 C3 8E 1F             jp      NXTITM          ; Get next item
1937+ 1F89
1938+ 1F89 E5           READ:   push    HL              ; Save code string address
1939+ 1F8A 2A 6E 53             ld      HL,(NXTDAT)     ; Next DATA statement
1940+ 1F8D F6                   defb    $F6             ; Flag "READ"
1941+ 1F8E AF           NXTITM: xor     A               ; Flag "INPUT"
1942+ 1F8F 32 F9 52             ld      (READFG),A      ; Save "READ"/"INPUT" flag
1943+ 1F92 E3                   ex      (SP),HL         ; Get code str' , Save pointer
1944+ 1F93 C3 9A 1F             jp      GTVLUS          ; Get values
1945+ 1F96
1946+ 1F96 CD C3 19     NEDMOR: call    CHKSYN          ; Check for comma between items
1947+ 1F99 2C                   defb    ','
1948+ 1F9A CD AC 22     GTVLUS: call    GETVAR          ; Get variable name
1949+ 1F9D E3                   ex      (SP),HL         ; Save code str" , Get pointer
1950+ 1F9E D5                   push    DE              ; Save variable address
1951+ 1F9F 7E                   ld      A,(HL)          ; Get next "INPUT"/"DATA" byte
1952+ 1FA0 FE 2C                cp      ','             ; Comma?
1953+ 1FA2 CA C2 1F             jp      Z,ANTVLU        ; Yes - Get another value
1954+ 1FA5 3A F9 52             ld      A,(READFG)      ; Is it READ?
1955+ 1FA8 B7                   or      A
1956+ 1FA9 C2 2E 20             jp      NZ,FDTLP        ; Yes - Find next DATA stmt
1957+ 1FAC 3E 3F                ld      A,'?'           ; More INPUT needed
1958+ 1FAE CD CE 19             call    OUTC            ; Output character
1959+ 1FB1 CD 42 18             call    PROMPT          ; Get INPUT with prompt
1960+ 1FB4 D1                   pop     DE              ; Variable address
1961+ 1FB5 C1                   pop     BC              ; Code string address
1962+ 1FB6 DA 5B 1C             jp      C,INPBRK        ; Break pressed
1963+ 1FB9 23                   inc     HL              ; Point to next DATA byte
1964+ 1FBA 7E                   ld      A,(HL)          ; Get byte
1965+ 1FBB B7                   or      A               ; Is it zero (No input) ?
1966+ 1FBC 2B                   dec     HL              ; Back space INPUT pointer
1967+ 1FBD C5                   push    BC              ; Save code string address
1968+ 1FBE CA B4 1D             jp      Z,NXTDTA        ; Find end of buffer
1969+ 1FC1 D5                   push    DE              ; Save variable address
1970+ 1FC2 3A D9 52     ANTVLU: ld      A,(TYPE)        ; Check data type
1971+ 1FC5 B7                   or      A               ; Is it numeric?
1972+ 1FC6 CA EC 1F             jp      Z,INPBIN        ; Yes - Convert to binary
1973+ 1FC9 CD 0C 1C             call    GETCHR          ; Get next character
1974+ 1FCC 57                   ld      D,A             ; Save input character
1975+ 1FCD 47                   ld      B,A             ; Again
1976+ 1FCE FE 22                cp      $22             ; '"'     ; Start of literal sting?
1977+ 1FD0 CA E0 1F             jp      Z,STRENT        ; Yes - Create string entry
1978+ 1FD3 3A F9 52             ld      A,(READFG)      ; "READ" or "INPUT" ?
1979+ 1FD6 B7                   or      A
1980+ 1FD7 57                   ld      D,A             ; Save 00 if "INPUT"
1981+ 1FD8 CA DD 1F             jp      Z,ITMSEP        ; "INPUT" - End with 00
1982+ 1FDB 16 3A                ld      D,':'           ; "DATA" - End with 00 or ':'
1983+ 1FDD 06 2C        ITMSEP: ld      B,','           ; Item separator
1984+ 1FDF 2B                   dec     HL              ; Back space for DTSTR
1985+ 1FE0 CD 67 25     STRENT: call    DTSTR           ; Get string terminated by D
1986+ 1FE3 EB                   ex      DE,HL           ; String address to DE
1987+ 1FE4 21 F7 1F             ld      HL,LTSTND       ; Where to go after LETSTR
1988+ 1FE7 E3                   ex      (SP),HL         ; Save HL , get input pointer
1989+ 1FE8 D5                   push    DE              ; Save address of string
1990+ 1FE9 C3 E7 1D             jp      LETSTR          ; Assign string to variable
1991+ 1FEC
1992+ 1FEC CD 0C 1C     INPBIN: call    GETCHR          ; Get next character
1993+ 1FEF CD B1 2F             call    ASCTFP          ; Convert ASCII to FP number
1994+ 1FF2 E3                   ex      (SP),HL         ; Save input ptr, Get var addr
1995+ 1FF3 CD 02 2F             call    FPTHL           ; Move FPREG to variable
1996+ 1FF6 E1                   pop     HL              ; Restore input pointer
1997+ 1FF7 2B           LTSTND: dec     HL              ; dec 'cos GETCHR INCs
1998+ 1FF8 CD 0C 1C             call    GETCHR          ; Get next character
1999+ 1FFB CA 03 20             jp      Z,MORDT         ; End of line - More needed?
2000+ 1FFE FE 2C                cp      ','             ; Another value?
2001+ 2000 C2 3E 1F             jp      NZ,BADINP       ; No - Bad input
2002+ 2003 E3           MORDT:  ex      (SP),HL         ; Get code string address
2003+ 2004 2B                   dec     HL              ; dec 'cos GETCHR INCs
2004+ 2005 CD 0C 1C             call    GETCHR          ; Get next character
2005+ 2008 C2 96 1F             jp      NZ,NEDMOR       ; More needed - Get it
2006+ 200B D1                   pop     DE              ; Restore DATA pointer
2007+ 200C 3A F9 52             ld      A,(READFG)      ; "READ" or "INPUT" ?
2008+ 200F B7                   or      A
2009+ 2010 EB                   ex      DE,HL           ; DATA pointer to HL
2010+ 2011 C2 32 1C             jp      NZ,UPDATA       ; Update DATA pointer if "READ"
2011+ 2014 D5                   push    DE              ; Save code string address
2012+ 2015 B6                   or      (HL)            ; More input given?
2013+ 2016 21 1E 20             ld      HL,EXTIG        ; "?Extra ignored" message
2014+ 2019 C4 A5 25             call    NZ,PRS          ; Output string if extra given
2015+ 201C E1                   pop     HL              ; Restore code string address
2016+ 201D C9                   ret
2017+ 201E
2018+ 201E 3F 45 78 74  EXTIG:  defb    "?Extra ignored",CR,0
2018+ 2022 72 61 20 69
2018+ 2026 67 6E 6F 72
2018+ 202A 65 64 0D 00
2019+ 202E
2020+ 202E CD B5 1D     FDTLP:  call    DATA            ; Get next statement
2021+ 2031 B7                   or      A               ; End of line?
2022+ 2032 C2 47 20             jp      NZ,FANDT        ; No - See if DATA statement
2023+ 2035 23                   inc     HL
2024+ 2036 7E                   ld      A,(HL)          ; End of program?
2025+ 2037 23                   inc     HL
2026+ 2038 B6                   or      (HL)            ; 00 00 Ends program
2027+ 2039 1E 06                ld      E,OD            ; ?OD Error
2028+ 203B CA DD 16             jp      Z,ERROR         ; Yes - Out of DATA
2029+ 203E 23                   inc     HL
2030+ 203F 5E                   ld      E,(HL)          ; LSB of line number
2031+ 2040 23                   inc     HL
2032+ 2041 56                   ld      D,(HL)          ; MSB of line number
2033+ 2042 EB                   ex      DE,HL
2034+ 2043 22 F5 52             ld      (DATLIN),HL     ; Set line of current DATA item
2035+ 2046 EB                   ex      DE,HL
2036+ 2047 CD 0C 1C     FANDT:  call    GETCHR          ; Get next character
2037+ 204A FE 83                cp      ZDATA           ; "DATA" token
2038+ 204C C2 2E 20             jp      NZ,FDTLP        ; No "DATA" - Keep looking
2039+ 204F C3 C2 1F             jp      ANTVLU          ; Found - Convert input
2040+ 2052
2041+ 2052 11 00 00     NEXT:   ld      DE,$0000        ; In case no index given
2042+ 2055 C4 AC 22     NEXT1:  call    NZ,GETVAR       ; Get index address
2043+ 2058 22 FA 52             ld      (BRKLIN),HL     ; Save code string address
2044+ 205B CD 52 16             call    BAKSTK          ; Look for "FOR" block
2045+ 205E C2 CF 16             jp      NZ,NFERR        ; No "FOR" - ?NF Error
2046+ 2061 F9                   ld      SP,HL           ; Clear nested loops
2047+ 2062 D5                   push    DE              ; Save index address
2048+ 2063 7E                   ld      A,(HL)          ; Get sign of STEP
2049+ 2064 23                   inc     HL
2050+ 2065 F5                   push    AF              ; Save sign of STEP
2051+ 2066 D5                   push    DE              ; Save index address
2052+ 2067 CD E8 2E             call    PHLTFP          ; Move index value to FPREG
2053+ 206A E3                   ex      (SP),HL         ; Save address of TO value
2054+ 206B E5                   push    HL              ; Save address of index
2055+ 206C CD 04 2C             call    ADDPHL          ; Add STEP to index value
2056+ 206F E1                   pop     HL              ; Restore address of index
2057+ 2070 CD 02 2F             call    FPTHL           ; Move value to index variable
2058+ 2073 E1                   pop     HL              ; Restore address of TO value
2059+ 2074 CD F9 2E             call    LOADFP          ; Move TO value to BCDE
2060+ 2077 E5                   push    HL              ; Save address of line of FOR
2061+ 2078 CD 25 2F             call    CMPNUM          ; Compare index with TO value
2062+ 207B E1                   pop     HL              ; Restore address of line num
2063+ 207C C1                   pop     BC              ; Address of sign of STEP
2064+ 207D 90                   sub     B               ; Compare with expected sign
2065+ 207E CD F9 2E             call    LOADFP          ; BC = Loop stmt,DE = Line num
2066+ 2081 CA 8D 20             jp      Z,KILFOR        ; Loop finished - Terminate it
2067+ 2084 EB                   ex      DE,HL           ; Loop statement line number
2068+ 2085 22 F4 51             ld      (LINEAT),HL     ; Set loop line number
2069+ 2088 69                   ld      L,C             ; Set code string to loop
2070+ 2089 60                   ld      H,B
2071+ 208A C3 C8 1B             jp      PUTFID          ; Put back "FOR" and continue
2072+ 208D
2073+ 208D F9           KILFOR: ld      SP,HL           ; Remove "FOR" block
2074+ 208E 2A FA 52             ld      HL,(BRKLIN)     ; Code string after "NEXT"
2075+ 2091 7E                   ld      A,(HL)          ; Get next byte in code string
2076+ 2092 FE 2C                cp      ','             ; More NEXTs ?
2077+ 2094 C2 CC 1B             jp      NZ,RUNCNT       ; No - Do next statement
2078+ 2097 CD 0C 1C             call    GETCHR          ; Position to index name
2079+ 209A CD 55 20             call    NEXT1           ; Re-enter NEXT routine
2080+ 209D              ; < will not RETurn to here , Exit to RUNCNT or Loop >
2081+ 209D
2082+ 209D CD AF 20     GETNUM: call    EVAL            ; Get a numeric expression
2083+ 20A0 F6           TSTNUM: defb    $F6             ; Clear carry (numeric)
2084+ 20A1 37           TSTSTR: scf                     ; Set carry (string)
2085+ 20A2 3A D9 52     CHKTYP: ld      A,(TYPE)        ; Check types match
2086+ 20A5 8F                   adc     A,A             ; Expected + actual
2087+ 20A6 B7                   or      A               ; Clear carry , set parity
2088+ 20A7 E8                   ret     PE              ; Even parity - Types match
2089+ 20A8 C3 DB 16             jp      TMERR           ; Different types - Error
2090+ 20AB
2091+ 20AB CD C3 19     OPNPAR: call    CHKSYN          ; Make sure "(" follows
2092+ 20AE 28                   defb    '('
2093+ 20AF 2B           EVAL:   dec     HL              ; Evaluate expression & save
2094+ 20B0 16 00                ld      D,$00           ; Precedence value
2095+ 20B2 D5           EVAL1:  push    DE              ; Save precedence
2096+ 20B3 0E 01                ld      C,$01
2097+ 20B5 CD 86 16             call    CHKSTK          ; Check for 1 level of stack
2098+ 20B8 CD 26 21             call    OPRND           ; Get next expression value
2099+ 20BB 22 FC 52     EVAL2:  ld      (NXTOPR),HL     ; Save address of next operator
2100+ 20BE 2A FC 52     EVAL3:  ld      HL,(NXTOPR)     ; Restore address of next opr
2101+ 20C1 C1                   pop     BC              ; Precedence value and operator
2102+ 20C2 78                   ld      A,B             ; Get precedence value
2103+ 20C3 FE 78                cp      $78             ; "AND", "OR", or "XOR" ?
2104+ 20C5 D4 A0 20             call    NC,TSTNUM       ; No - Make sure it's a number
2105+ 20C8 7E                   ld      A,(HL)          ; Get next operator / function
2106+ 20C9 16 00                ld      D,$00           ; Clear Last relation
2107+ 20CB D6 C7        RLTLP:  sub     ZGTR            ; ">" Token
2108+ 20CD DA E7 20             jp      C,FOPRND        ; + - * / ^ AND OR XOR - Test it
2109+ 20D0 FE 03                cp      ZLTH+1-ZGTR     ; < = >
2110+ 20D2 D2 E7 20             jp      NC,FOPRND       ; Function - Call it
2111+ 20D5 FE 01                cp      ZEQUAL-ZGTR     ; "="
2112+ 20D7 17                   rla                     ; <- Test for legal
2113+ 20D8 AA                   xor     D               ; <- combinations of < = >
2114+ 20D9 BA                   cp      D               ; <- by combining last token
2115+ 20DA 57                   ld      D,A             ; <- with current one
2116+ 20DB DA C9 16             jp      C,SNERR         ; Error if "<<' '==" or ">>"
2117+ 20DE 22 F1 52             ld      (CUROPR),HL     ; Save address of current token
2118+ 20E1 CD 0C 1C             call    GETCHR          ; Get next character
2119+ 20E4 C3 CB 20             jp      RLTLP           ; Treat the two as one
2120+ 20E7
2121+ 20E7 7A           FOPRND: ld      A,D             ; < = > found ?
2122+ 20E8 B7                   or      A
2123+ 20E9 C2 27 22             jp      NZ,TSTRED       ; Yes - Test for reduction
2124+ 20EC 7E                   ld      A,(HL)          ; Get operator token
2125+ 20ED 22 F1 52             ld      (CUROPR),HL     ; Save operator address
2126+ 20F0 D6 BD                sub     ZPLUS           ; Operator or function?
2127+ 20F2 D8                   ret     C               ; Neither - Exit
2128+ 20F3 FE 0A                cp      ZOR+1-ZPLUS     ; Is it + - * / ^ AND XOR OR ?
2129+ 20F5 D0                   ret     NC              ; No - Exit
2130+ 20F6 5F                   ld      E,A             ; Coded operator
2131+ 20F7 3A D9 52             ld      A,(TYPE)        ; Get data type
2132+ 20FA 3D                   dec     A               ; FF = numeric , 00 = string
2133+ 20FB B3                   or      E               ; Combine with coded operator
2134+ 20FC 7B                   ld      A,E             ; Get coded operator
2135+ 20FD CA 9B 26             jp      Z,CONCAT        ; String concatenation
2136+ 2100 07                   rlca                    ; Times 2
2137+ 2101 83                   add     A,E             ; Times 3
2138+ 2102 5F                   ld      E,A             ; To DE (D is 0)
2139+ 2103 21 44 15             ld      HL,PRITAB       ; Precedence table
2140+ 2106 19                   add     HL,DE           ; To the operator concerned
2141+ 2107 78                   ld      A,B             ; Last operator precedence
2142+ 2108 56                   ld      D,(HL)          ; Get evaluation precedence
2143+ 2109 BA                   cp      D               ; Compare with eval precedence
2144+ 210A D0                   ret     NC              ; Exit if higher precedence
2145+ 210B 23                   inc     HL              ; Point to routine address
2146+ 210C CD A0 20             call    TSTNUM          ; Make sure it's a number
2147+ 210F
2148+ 210F C5           STKTHS: push    BC              ; Save last precedence & token
2149+ 2110 01 BE 20             ld      BC,EVAL3        ; Where to go on prec' break
2150+ 2113 C5                   push    BC              ; Save on stack for return
2151+ 2114 43                   ld      B,E             ; Save operator
2152+ 2115 4A                   ld      C,D             ; Save precedence
2153+ 2116 CD DB 2E             call    STAKFP          ; Move value to stack
2154+ 2119 58                   ld      E,B             ; Restore operator
2155+ 211A 51                   ld      D,C             ; Restore precedence
2156+ 211B 4E                   ld      C,(HL)          ; Get LSB of routine address
2157+ 211C 23                   inc     HL
2158+ 211D 46                   ld      B,(HL)          ; Get MSB of routine address
2159+ 211E 23                   inc     HL
2160+ 211F C5                   push    BC              ; Save routine address
2161+ 2120 2A F1 52             ld      HL,(CUROPR)     ; Address of current operator
2162+ 2123 C3 B2 20             jp      EVAL1           ; Loop until prec' break
2163+ 2126
2164+ 2126 AF           OPRND:  xor     A               ; Get operand routine
2165+ 2127 32 D9 52             ld      (TYPE),A        ; Set numeric expected
2166+ 212A CD 0C 1C             call    GETCHR          ; Get next character
2167+ 212D 1E 24                ld      E,MO            ; ?MO Error
2168+ 212F CA DD 16             jp      Z,ERROR         ; No operand - Error
2169+ 2132 DA B1 2F             jp      C,ASCTFP        ; Number - Get value
2170+ 2135 CD AE 1C             call    CHKLTR          ; See if a letter
2171+ 2138 D2 8D 21             jp      NC,CONVAR       ; Letter - Find variable
2172+ 213B FE 26                cp      '&'             ; &H = HEX, &B = BINARY
2173+ 213D 20 12                jr      NZ,NOTAMP
2174+ 213F CD 0C 1C             call    GETCHR          ; Get next character
2175+ 2142 FE 48                cp      'H'             ; Hex number indicated? [function added]
2176+ 2144 CA 17 3F             jp      Z,HEXTFP        ; Convert Hex to FPREG
2177+ 2147 FE 42                cp      'B'             ; Binary number indicated? [function added]
2178+ 2149 CA 87 3F             jp      Z,BINTFP        ; Convert Bin to FPREG
2179+ 214C 1E 02                ld      E,SN            ; If neither then a ?SN Error
2180+ 214E CA DD 16             jp      Z,ERROR         ;
2181+ 2151 FE BD        NOTAMP: cp      ZPLUS           ; '+' Token ?
2182+ 2153 CA 26 21             jp      Z,OPRND         ; Yes - Look for operand
2183+ 2156 FE 2E                cp      '.'             ; '.' ?
2184+ 2158 CA B1 2F             jp      Z,ASCTFP        ; Yes - Create FP number
2185+ 215B FE BE                cp      ZMINUS          ; '-' Token ?
2186+ 215D CA 7C 21             jp      Z,MINUS         ; Yes - Do minus
2187+ 2160 FE 22                cp      $22             ; '"'             ; Literal string ?
2188+ 2162 CA 64 25             jp      Z,QTSTR         ; Get string terminated by '"'
2189+ 2165 FE BB                cp      ZNOT            ; "NOT" Token ?
2190+ 2167 CA 87 22             jp      Z,EVNOT         ; Yes - Eval NOT expression
2191+ 216A FE B8                cp      ZFN             ; "FN" Token ?
2192+ 216C CA C8 24             jp      Z,DOFN          ; Yes - Do FN routine
2193+ 216F D6 CA                sub     ZSGN            ; Is it a function?
2194+ 2171 D2 9E 21             jp      NC,FNOFST       ; Yes - Evaluate function
2195+ 2174 CD AB 20     EVLPAR: call    OPNPAR          ; Evaluate expression in "()"
2196+ 2177 CD C3 19             call    CHKSYN          ; Make sure ")" follows
2197+ 217A 29                   defb    ')'
2198+ 217B C9                   ret
2199+ 217C
2200+ 217C 16 7D        MINUS:  ld      D,$7D           ; '-' precedence
2201+ 217E CD B2 20             call    EVAL1           ; Evaluate until prec' break
2202+ 2181 2A FC 52             ld      HL,(NXTOPR)     ; Get next operator address
2203+ 2184 E5                   push    HL              ; Save next operator address
2204+ 2185 CD D3 2E             call    INVSGN          ; Negate value
2205+ 2188 CD A0 20     RETNUM: call    TSTNUM          ; Make sure it's a number
2206+ 218B E1                   pop     HL              ; Restore next operator address
2207+ 218C C9                   ret
2208+ 218D
2209+ 218D CD AC 22     CONVAR: call    GETVAR          ; Get variable address to DE
2210+ 2190 E5           FRMEVL: push    HL              ; Save code string address
2211+ 2191 EB                   ex      DE,HL           ; Variable address to HL
2212+ 2192 22 76 53             ld      (FPREG),HL      ; Save address of variable
2213+ 2195 3A D9 52             ld      A,(TYPE)        ; Get type
2214+ 2198 B7                   or      A               ; Numeric?
2215+ 2199 CC E8 2E             call    Z,PHLTFP        ; Yes - Move contents to FPREG
2216+ 219C E1                   pop     HL              ; Restore code string address
2217+ 219D C9                   ret
2218+ 219E
2219+ 219E 06 00        FNOFST: ld      B,$00           ; Get address of function
2220+ 21A0 07                   rlca                    ; Double function offset
2221+ 21A1 4F                   ld      C,A             ; BC = Offset in function table
2222+ 21A2 C5                   push    BC              ; Save adjusted token value
2223+ 21A3 CD 0C 1C             call    GETCHR          ; Get next character
2224+ 21A6 79                   ld      A,C             ; Get adjusted token value
2225+ 21A7 FE 2C                cp      2*(ZPOINT-ZSGN) ; "POINT" token?
2226+ 21A9 CA D5 36             jp      Z,POINT         ; Yes, do "POINT"
2227+ 21AC FE 2E                cp      2*(ZINSTR-ZSGN) ; "INSTR" token?
2228+ 21AE CA 77 27             jp      Z,INSTR         ; Yes, do "INSTR"
2229+ 21B1 FE 3D                cp      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
2230+ 21B3 DA CF 21             jp      C,FNVAL         ; No - Do function
2231+ 21B6 CD AB 20             call    OPNPAR          ; Evaluate expression  (X,...
2232+ 21B9 CD C3 19             call    CHKSYN          ; Make sure ',' follows
2233+ 21BC 2C                   defb    ','
2234+ 21BD CD A1 20             call    TSTSTR          ; Make sure it's a string
2235+ 21C0 EB                   ex      DE,HL           ; Save code string address
2236+ 21C1 2A 76 53             ld      HL,(FPREG)      ; Get address of string
2237+ 21C4 E3                   ex      (SP),HL         ; Save address of string
2238+ 21C5 E5                   push    HL              ; Save adjusted token value
2239+ 21C6 EB                   ex      DE,HL           ; Restore code string address
2240+ 21C7 CD 23 29             call    GETINT          ; Get integer 0-255
2241+ 21CA EB                   ex      DE,HL           ; Save code string address
2242+ 21CB E3                   ex      (SP),HL         ; Save integer,HL = adj' token
2243+ 21CC C3 D7 21             jp      GOFUNC          ; Jump to string function
2244+ 21CF
2245+ 21CF CD 74 21     FNVAL:  call    EVLPAR          ; Evaluate expression
2246+ 21D2 E3                   ex      (SP),HL         ; HL = Adjusted token value
2247+ 21D3 11 88 21             ld      DE,RETNUM       ; Return number from function
2248+ 21D6 D5                   push    DE              ; Save on stack
2249+ 21D7 01 07 13     GOFUNC: ld      BC,FNCTAB       ; Function routine addresses
2250+ 21DA 09                   add     HL,BC           ; Point to right address
2251+ 21DB 4E                   ld      C,(HL)          ; Get LSB of address
2252+ 21DC 23                   inc     HL              ;
2253+ 21DD 66                   ld      H,(HL)          ; Get MSB of address
2254+ 21DE 69                   ld      L,C             ; Address to HL
2255+ 21DF E9                   jp      (HL)            ; Jump to function
2256+ 21E0
2257+ 21E0 15           SGNEXP: dec     D               ; Dee to flag negative exponent
2258+ 21E1 FE BE                cp      ZMINUS          ; '-' token ?
2259+ 21E3 C8                   ret     Z               ; Yes - Return
2260+ 21E4 FE 2D                cp      '-'             ; '-' ASCII ?
2261+ 21E6 C8                   ret     Z               ; Yes - Return
2262+ 21E7 14                   inc     D               ; Inc to flag positive exponent
2263+ 21E8 FE 2B                cp      '+'             ; '+' ASCII ?
2264+ 21EA C8                   ret     Z               ; Yes - Return
2265+ 21EB FE BD                cp      ZPLUS           ; '+' token ?
2266+ 21ED C8                   ret     Z               ; Yes - Return
2267+ 21EE 2B                   dec     HL              ; dec 'cos GETCHR INCs
2268+ 21EF C9                   ret                     ; Return "NZ"
2269+ 21F0
2270+ 21F0              ; execute OR, AND, and XOR operations
2271+ 21F0 AF           PAND:   xor     A               ; for AND, Z=1
2272+ 21F1 18 07                jr      CNTLGC
2273+ 21F3 AF           POR:    xor     A               ; for OR, Z=0, S=1
2274+ 21F4 D6 01                sub     $01
2275+ 21F6 18 02                jr      CNTLGC
2276+ 21F8 AF           PXOR:   xor     A               ; for XOR, Z=0, S=0
2277+ 21F9 3C                   inc     A
2278+ 21FA F5           CNTLGC: push    AF              ; store operand's flags
2279+ 21FB CD A0 20             call    TSTNUM          ; Make sure it's a number
2280+ 21FE CD C2 1C             call    DEINT           ; Get integer -32768 to 32767
2281+ 2201 F1                   pop     AF              ; retrieve operand's flags
2282+ 2202 EB                   ex      DE,HL           ; <- Get last
2283+ 2203 C1                   pop     BC              ; <-  value
2284+ 2204 E3                   ex      (SP),HL         ; <-  from
2285+ 2205 EB                   ex      DE,HL           ; <-  stack
2286+ 2206 CD EB 2E             call    FPBCDE          ; Move last value to FPREG
2287+ 2209 F5                   push    AF              ; store operand's flags
2288+ 220A CD C2 1C             call    DEINT           ; Get integer -32768 to 32767
2289+ 220D F1                   pop     AF              ; retrieve operand's flags
2290+ 220E C1                   pop     BC              ; Get value
2291+ 220F 79                   ld      A,C             ; Get LSB
2292+ 2210 21 86 24             ld      HL,ACPASS       ; Address of save AC as current
2293+ 2213 20 05                jr      NZ,POR1         ; if X/OR, jump over
2294+ 2215 A3           PAND1:  and     E               ; "AND" LSBs
2295+ 2216 4F                   ld      C,A             ; Save LSB
2296+ 2217 78                   ld      A,B             ; Get MSB
2297+ 2218 A2                   and     D               ; "AND" MSBs
2298+ 2219 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2299+ 221A F2 22 22     POR1:   jp      P,PXOR1         ; if S=0, jump to XOR
2300+ 221D B3                   or      E               ; "OR" LSBs
2301+ 221E 4F                   ld      C,A             ; Save LSB
2302+ 221F 78                   ld      A,B             ; Get MSB
2303+ 2220 B2                   or      D               ; "OR" MSBs
2304+ 2221 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2305+ 2222 AB           PXOR1:  xor     E               ; "XOR" LSBs
2306+ 2223 4F                   ld      C,A             ; Save LSB
2307+ 2224 78                   ld      A,B             ; Get MSB
2308+ 2225 AA                   xor     D               ; "XOR" MSBs
2309+ 2226 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2310+ 2227
2311+ 2227 21 39 22     TSTRED: ld      HL,CMPLOG       ; Logical compare routine
2312+ 222A 3A D9 52             ld      A,(TYPE)        ; Get data type
2313+ 222D 1F                   rra                     ; Carry set = string
2314+ 222E 7A                   ld      A,D             ; Get last precedence value
2315+ 222F 17                   rla                     ; Times 2 plus carry
2316+ 2230 5F                   ld      E,A             ; To E
2317+ 2231 16 64                ld      D,$64           ; Relational precedence
2318+ 2233 78                   ld      A,B             ; Get current precedence
2319+ 2234 BA                   cp      D               ; Compare with last
2320+ 2235 D0                   ret     NC              ; Eval if last was rel' or log'
2321+ 2236 C3 0F 21             jp      STKTHS          ; Stack this one and get next
2322+ 2239
2323+ 2239 3B 22        CMPLOG: defw    CMPLG1          ; Compare two values / strings
2324+ 223B 79           CMPLG1: ld      A,C             ; Get data type
2325+ 223C B7                   or      A
2326+ 223D 1F                   rra
2327+ 223E C1                   pop     BC              ; Get last expression to BCDE
2328+ 223F D1                   pop     DE
2329+ 2240 F5                   push    AF              ; Save status
2330+ 2241 CD A2 20             call    CHKTYP          ; Check that types match
2331+ 2244 21 7D 22             ld      HL,CMPRES       ; Result to comparison
2332+ 2247 E5                   push    HL              ; Save for RETurn
2333+ 2248 CA 25 2F             jp      Z,CMPNUM        ; Compare values if numeric
2334+ 224B AF                   xor     A               ; Compare two strings
2335+ 224C 32 D9 52             ld      (TYPE),A        ; Set type to numeric
2336+ 224F D5                   push    DE              ; Save string name
2337+ 2250 CD E8 26             call    GSTRCU          ; Get current string
2338+ 2253 7E                   ld      A,(HL)          ; Get length of string
2339+ 2254 23                   inc     HL
2340+ 2255 23                   inc     HL
2341+ 2256 4E                   ld      C,(HL)          ; Get LSB of address
2342+ 2257 23                   inc     HL
2343+ 2258 46                   ld      B,(HL)          ; Get MSB of address
2344+ 2259 D1                   pop     DE              ; Restore string name
2345+ 225A C5                   push    BC              ; Save address of string
2346+ 225B F5                   push    AF              ; Save length of string
2347+ 225C CD EC 26             call    GSTRDE          ; Get second string
2348+ 225F CD F9 2E             call    LOADFP          ; Get address of second string
2349+ 2262 F1                   pop     AF              ; Restore length of string 1
2350+ 2263 57                   ld      D,A             ; Length to D
2351+ 2264 E1                   pop     HL              ; Restore address of string 1
2352+ 2265 7B           CMPSTR: ld      A,E             ; Bytes of string 2 to do
2353+ 2266 B2                   or      D               ; Bytes of string 1 to do
2354+ 2267 C8                   ret     Z               ; Exit if all bytes compared
2355+ 2268 7A                   ld      A,D             ; Get bytes of string 1 to do
2356+ 2269 D6 01                sub     $01
2357+ 226B D8                   ret     C               ; Exit if end of string 1
2358+ 226C AF                   xor     A
2359+ 226D BB                   cp      E               ; Bytes of string 2 to do
2360+ 226E 3C                   inc     A
2361+ 226F D0                   ret     NC              ; Exit if end of string 2
2362+ 2270 15                   dec     D               ; Count bytes in string 1
2363+ 2271 1D                   dec     E               ; Count bytes in string 2
2364+ 2272 0A                   ld      A,(BC)          ; Byte in string 2
2365+ 2273 BE                   cp      (HL)            ; Compare to byte in string 1
2366+ 2274 23                   inc     HL              ; Move up string 1
2367+ 2275 03                   inc     BC              ; Move up string 2
2368+ 2276 CA 65 22             jp      Z,CMPSTR        ; Same - Try next bytes
2369+ 2279 3F                   ccf                     ; Flag difference (">" or "<")
2370+ 227A C3 B5 2E             jp      FLGDIF          ; "<" gives -1 , ">" gives +1
2371+ 227D
2372+ 227D 3C           CMPRES: inc     A               ; Increment current value
2373+ 227E 8F                   adc     A,A             ; Double plus carry
2374+ 227F C1                   pop     BC              ; Get other value
2375+ 2280 A0                   and     B               ; Combine them
2376+ 2281 C6 FF                add     A,-1            ; Carry set if different
2377+ 2283 9F                   sbc     A,A             ; 00 - Equal , FF - Different
2378+ 2284 C3 BC 2E             jp      FLGREL          ; Set current value & continue
2379+ 2287
2380+ 2287 16 5A        EVNOT:  ld      D,$5A           ; Precedence value for "NOT"
2381+ 2289 CD B2 20             call    EVAL1           ; Eval until precedence break
2382+ 228C CD A0 20             call    TSTNUM          ; Make sure it's a number
2383+ 228F CD C2 1C             call    DEINT           ; Get integer -32768 - 32767
2384+ 2292 7B                   ld      A,E             ; Get LSB
2385+ 2293 2F                   cpl                     ; Invert LSB
2386+ 2294 4F                   ld      C,A             ; Save "NOT" of LSB
2387+ 2295 7A                   ld      A,D             ; Get MSB
2388+ 2296 2F                   cpl                     ; Invert MSB
2389+ 2297 CD 86 24             call    ACPASS          ; Save AC as current
2390+ 229A C1                   pop     BC              ; Clean up stack
2391+ 229B C3 BE 20             jp      EVAL3           ; Continue evaluation
2392+ 229E
2393+ 229E 2B           DIMRET: dec     HL              ; dec 'cos GETCHR INCs
2394+ 229F CD 0C 1C             call    GETCHR          ; Get next character
2395+ 22A2 C8                   ret     Z               ; End of DIM statement
2396+ 22A3 CD C3 19             call    CHKSYN          ; Make sure ',' follows
2397+ 22A6 2C                   defb    ','
2398+ 22A7 01 9E 22     DIM:    ld      BC,DIMRET       ; Return to "DIMRET"
2399+ 22AA C5                   push    BC              ; Save on stack
2400+ 22AB F6                   defb    $F6             ; Flag "Create" variable
2401+ 22AC AF           GETVAR: xor     A               ; Find variable address,to DE
2402+ 22AD 32 D8 52             ld      (LCRFLG),A      ; Set locate / create flag
2403+ 22B0 46                   ld      B,(HL)          ; Get First byte of name
2404+ 22B1 CD AE 1C     GTFNAM: call    CHKLTR          ; See if a letter
2405+ 22B4 DA C9 16             jp      C,SNERR         ; ?SN Error if not a letter
2406+ 22B7 AF                   xor     A
2407+ 22B8 4F                   ld      C,A             ; Clear second byte of name
2408+ 22B9 32 D9 52             ld      (TYPE),A        ; Set type to numeric
2409+ 22BC CD 0C 1C             call    GETCHR          ; Get next character
2410+ 22BF DA C8 22             jp      C,SVNAM2        ; Numeric - Save in name
2411+ 22C2 CD AE 1C             call    CHKLTR          ; See if a letter
2412+ 22C5 DA D5 22             jp      C,CHARTY        ; Not a letter - Check type
2413+ 22C8 4F           SVNAM2: ld      C,A             ; Save second byte of name
2414+ 22C9 CD 0C 1C     ENDNAM: call    GETCHR          ; Get next character
2415+ 22CC DA C9 22             jp      C,ENDNAM        ; Numeric - Get another
2416+ 22CF CD AE 1C             call    CHKLTR          ; See if a letter
2417+ 22D2 D2 C9 22             jp      NC,ENDNAM       ; Letter - Get another
2418+ 22D5 D6 24        CHARTY: sub     '$'             ; String variable?
2419+ 22D7 C2 E4 22             jp      NZ,NOTSTR       ; No - Numeric variable
2420+ 22DA 3C                   inc     A               ; A = 1 (string type)
2421+ 22DB 32 D9 52             ld      (TYPE),A        ; Set type to string
2422+ 22DE 0F                   rrca                    ; A = 80H , Flag for string
2423+ 22DF 81                   add     A,C             ; 2nd byte of name has bit 7 on
2424+ 22E0 4F                   ld      C,A             ; Resave second byte on name
2425+ 22E1 CD 0C 1C             call    GETCHR          ; Get next character
2426+ 22E4 3A F7 52     NOTSTR: ld      A,(FORFLG)      ; Array name needed ?
2427+ 22E7 3D                   dec     A
2428+ 22E8 CA 91 23             jp      Z,ARLDSV        ; Yes - Get array name
2429+ 22EB F2 F4 22             jp      P,NSCFOR        ; No array with "FOR" or "FN"
2430+ 22EE 7E                   ld      A,(HL)          ; Get byte again
2431+ 22EF D6 28                sub     '('             ; Subscripted variable?
2432+ 22F1 CA 69 23             jp      Z,SBSCPT        ; Yes - Sort out subscript
2433+ 22F4
2434+ 22F4 AF           NSCFOR: xor     A               ; Simple variable
2435+ 22F5 32 F7 52             ld      (FORFLG),A      ; Clear "FOR" flag
2436+ 22F8 E5                   push    HL              ; Save code string address
2437+ 22F9 50                   ld      D,B             ; DE = Variable name to find
2438+ 22FA 59                   ld      E,C
2439+ 22FB 2A 70 53             ld      HL,(FNRGNM)     ; FN argument name
2440+ 22FE CD BD 19             call    CPDEHL          ; Is it the FN argument?
2441+ 2301 11 72 53             ld      DE,FNARG        ; Point to argument value
2442+ 2304 CA 9A 2D             jp      Z,POPHRT        ; Yes - Return FN argument value
2443+ 2307 2A 6A 53             ld      HL,(VAREND)     ; End of variables
2444+ 230A EB                   ex      DE,HL           ; Address of end of search
2445+ 230B 2A 68 53             ld      HL,(PROGND)     ; Start of variables address
2446+ 230E CD BD 19     FNDVAR: call    CPDEHL          ; End of variable list table?
2447+ 2311 CA 27 23             jp      Z,CFEVAL        ; Yes - Called from EVAL?
2448+ 2314 79                   ld      A,C             ; Get second byte of name
2449+ 2315 96                   sub     (HL)            ; Compare with name in list
2450+ 2316 23                   inc     HL              ; Move on to first byte
2451+ 2317 C2 1C 23             jp      NZ,FNTHR        ; Different - Find another
2452+ 231A 78                   ld      A,B             ; Get first byte of name
2453+ 231B 96                   sub     (HL)            ; Compare with name in list
2454+ 231C 23           FNTHR:  inc     HL              ; Move on to LSB of value
2455+ 231D CA 5B 23             jp      Z,RETADR        ; Found - Return address
2456+ 2320 23                   inc     HL              ; <- Skip
2457+ 2321 23                   inc     HL              ; <- over
2458+ 2322 23                   inc     HL              ; <- F.P.
2459+ 2323 23                   inc     HL              ; <- value
2460+ 2324 C3 0E 23             jp      FNDVAR          ; Keep looking
2461+ 2327
2462+ 2327 E1           CFEVAL: pop     HL              ; Restore code string address
2463+ 2328 E3                   ex      (SP),HL         ; Get return address
2464+ 2329 D5                   push    DE              ; Save address of variable
2465+ 232A 11 90 21             ld      DE,FRMEVL       ; Return address in EVAL
2466+ 232D CD BD 19             call    CPDEHL          ; Called from EVAL ?
2467+ 2330 D1                   pop     DE              ; Restore address of variable
2468+ 2331 CA 5E 23             jp      Z,RETNUL        ; Yes - Return null variable
2469+ 2334 E3                   ex      (SP),HL         ; Put back return
2470+ 2335 E5                   push    HL              ; Save code string address
2471+ 2336 C5                   push    BC              ; Save variable name
2472+ 2337 01 06 00             ld      BC,$0006        ; 2 byte name plus 4 byte data
2473+ 233A 2A 6C 53             ld      HL,(ARREND)     ; End of arrays
2474+ 233D E5                   push    HL              ; Save end of arrays
2475+ 233E 09                   add     HL,BC           ; Move up 6 bytes
2476+ 233F C1                   pop     BC              ; Source address in BC
2477+ 2340 E5                   push    HL              ; Save new end address
2478+ 2341 CD 75 16             call    MOVUP           ; Move arrays up
2479+ 2344 E1                   pop     HL              ; Restore new end address
2480+ 2345 22 6C 53             ld      (ARREND),HL     ; Set new end address
2481+ 2348 60                   ld      H,B             ; End of variables to HL
2482+ 2349 69                   ld      L,C
2483+ 234A 22 6A 53             ld      (VAREND),HL     ; Set new end address
2484+ 234D
2485+ 234D 2B           ZEROLP: dec     HL              ; Back through to zero variable
2486+ 234E 36 00                ld      (HL),$00        ; Zero byte in variable
2487+ 2350 CD BD 19             call    CPDEHL          ; Done them all?
2488+ 2353 C2 4D 23             jp      NZ,ZEROLP       ; No - Keep on going
2489+ 2356 D1                   pop     DE              ; Get variable name
2490+ 2357 73                   ld      (HL),E          ; Store second character
2491+ 2358 23                   inc     HL
2492+ 2359 72                   ld      (HL),D          ; Store first character
2493+ 235A 23                   inc     HL
2494+ 235B EB           RETADR: ex      DE,HL           ; Address of variable in DE
2495+ 235C E1                   pop     HL              ; Restore code string address
2496+ 235D C9                   ret
2497+ 235E
2498+ 235E 32 79 53     RETNUL: ld      (FPEXP),A       ; Set result to zero
2499+ 2361 21 46 16             ld      HL,ZERBYT       ; Also set a null string
2500+ 2364 22 76 53             ld      (FPREG),HL      ; Save for EVAL
2501+ 2367 E1                   pop     HL              ; Restore code string address
2502+ 2368 C9                   ret
2503+ 2369
2504+ 2369 E5           SBSCPT: push    HL              ; Save code string address
2505+ 236A 2A D8 52             ld      HL,(LCRFLG)     ; Locate/Create and Type
2506+ 236D E3                   ex      (SP),HL         ; Save and get code string
2507+ 236E 57                   ld      D,A             ; Zero number of dimensions
2508+ 236F D5           SCPTLP: push    DE              ; Save number of dimensions
2509+ 2370 C5                   push    BC              ; Save array name
2510+ 2371 CD B6 1C             call    FPSINT          ; Get subscript (0-32767)
2511+ 2374 C1                   pop     BC              ; Restore array name
2512+ 2375 F1                   pop     AF              ; Get number of dimensions
2513+ 2376 EB                   ex      DE,HL
2514+ 2377 E3                   ex      (SP),HL         ; Save subscript value
2515+ 2378 E5                   push    HL              ; Save LCRFLG and TYPE
2516+ 2379 EB                   ex      DE,HL
2517+ 237A 3C                   inc     A               ; Count dimensions
2518+ 237B 57                   ld      D,A             ; Save in D
2519+ 237C 7E                   ld      A,(HL)          ; Get next byte in code string
2520+ 237D FE 2C                cp      ','             ; Comma (more to come)?
2521+ 237F CA 6F 23             jp      Z,SCPTLP        ; Yes - More subscripts
2522+ 2382 CD C3 19             call    CHKSYN          ; Make sure ")" follows
2523+ 2385 29                   defb    ')'
2524+ 2386 22 FC 52             ld      (NXTOPR),HL     ; Save code string address
2525+ 2389 E1                   pop     HL              ; Get LCRFLG and TYPE
2526+ 238A 22 D8 52             ld      (LCRFLG),HL     ; Restore Locate/create & type
2527+ 238D 1E 00                ld      E,$00           ; Flag not CSAVE* or CLOAD*
2528+ 238F D5                   push    DE              ; Save number of dimensions (D)
2529+ 2390 11                   defb    $11             ; Skip "push HL" and "push AF'
2530+ 2391
2531+ 2391 E5           ARLDSV: push    HL              ; Save code string address
2532+ 2392 F5                   push    AF              ; A = 00 , Flags set = Z,N
2533+ 2393 2A 6A 53             ld      HL,(VAREND)     ; Start of arrays
2534+ 2396 3E                   defb    $3E             ; Skip "add HL,DE"
2535+ 2397 19           FNDARY: add     HL,DE           ; Move to next array start
2536+ 2398 EB                   ex      DE,HL
2537+ 2399 2A 6C 53             ld      HL,(ARREND)     ; End of arrays
2538+ 239C EB                   ex      DE,HL           ; Current array pointer
2539+ 239D CD BD 19             call    CPDEHL          ; End of arrays found?
2540+ 23A0 CA C9 23             jp      Z,CREARY        ; Yes - Create array
2541+ 23A3 7E                   ld      A,(HL)          ; Get second byte of name
2542+ 23A4 B9                   cp      C               ; Compare with name given
2543+ 23A5 23                   inc     HL              ; Move on
2544+ 23A6 C2 AB 23             jp      NZ,NXTARY       ; Different - Find next array
2545+ 23A9 7E                   ld      A,(HL)          ; Get first byte of name
2546+ 23AA B8                   cp      B               ; Compare with name given
2547+ 23AB 23           NXTARY: inc     HL              ; Move on
2548+ 23AC 5E                   ld      E,(HL)          ; Get LSB of next array address
2549+ 23AD 23                   inc     HL
2550+ 23AE 56                   ld      D,(HL)          ; Get MSB of next array address
2551+ 23AF 23                   inc     HL
2552+ 23B0 C2 97 23             jp      NZ,FNDARY       ; Not found - Keep looking
2553+ 23B3 3A D8 52             ld      A,(LCRFLG)      ; Found Locate or Create it?
2554+ 23B6 B7                   or      A
2555+ 23B7 C2 D2 16             jp      NZ,DDERR        ; Create - ?DD Error
2556+ 23BA F1                   pop     AF              ; Locate - Get number of dim'ns
2557+ 23BB 44                   ld      B,H             ; BC Points to array dim'ns
2558+ 23BC 4D                   ld      C,L
2559+ 23BD CA 9A 2D             jp      Z,POPHRT        ; Jump if array load/save
2560+ 23C0 96                   sub     (HL)            ; Same number of dimensions?
2561+ 23C1 CA 27 24             jp      Z,FINDEL        ; Yes - Find element
2562+ 23C4 1E 10        BSERR:  ld      E,BS            ; ?BS Error
2563+ 23C6 C3 DD 16             jp      ERROR           ; Output error
2564+ 23C9
2565+ 23C9 11 04 00     CREARY: ld      DE,$0004        ; 4 Bytes per entry
2566+ 23CC F1                   pop     AF              ; Array to save or 0 dim'ns?
2567+ 23CD CA D7 1C             jp      Z,FCERR         ; Yes - ?FC Error
2568+ 23D0 71                   ld      (HL),C          ; Save second byte of name
2569+ 23D1 23                   inc     HL
2570+ 23D2 70                   ld      (HL),B          ; Save first byte of name
2571+ 23D3 23                   inc     HL
2572+ 23D4 4F                   ld      C,A             ; Number of dimensions to C
2573+ 23D5 CD 86 16             call    CHKSTK          ; Check if enough memory
2574+ 23D8 23                   inc     HL              ; Point to number of dimensions
2575+ 23D9 23                   inc     HL
2576+ 23DA 22 F1 52             ld      (CUROPR),HL     ; Save address of pointer
2577+ 23DD 71                   ld      (HL),C          ; Set number of dimensions
2578+ 23DE 23                   inc     HL
2579+ 23DF 3A D8 52             ld      A,(LCRFLG)      ; Locate of Create?
2580+ 23E2 17                   rla                     ; Carry set = Create
2581+ 23E3 79                   ld      A,C             ; Get number of dimensions
2582+ 23E4 01 0B 00     CRARLP: ld      BC,10+1         ; Default dimension size 10
2583+ 23E7 D2 EC 23             jp      NC,DEFSIZ       ; Locate - Set default size
2584+ 23EA C1                   pop     BC              ; Get specified dimension size
2585+ 23EB 03                   inc     BC              ; Include zero element
2586+ 23EC 71           DEFSIZ: ld      (HL),C          ; Save LSB of dimension size
2587+ 23ED 23                   inc     HL
2588+ 23EE 70                   ld      (HL),B          ; Save MSB of dimension size
2589+ 23EF 23                   inc     HL
2590+ 23F0 F5                   push    AF              ; Save num' of dim'ns an status
2591+ 23F1 E5                   push    HL              ; Save address of dim'n size
2592+ 23F2 CD 96 2F             call    MLDEBC          ; Multiply DE by BC to find
2593+ 23F5 EB                   ex      DE,HL           ; amount of mem needed (to DE)
2594+ 23F6 E1                   pop     HL              ; Restore address of dimension
2595+ 23F7 F1                   pop     AF              ; Restore number of dimensions
2596+ 23F8 3D                   dec     A               ; Count them
2597+ 23F9 C2 E4 23             jp      NZ,CRARLP       ; Do next dimension if more
2598+ 23FC F5                   push    AF              ; Save locate/create flag
2599+ 23FD 42                   ld      B,D             ; MSB of memory needed
2600+ 23FE 4B                   ld      C,E             ; LSB of memory needed
2601+ 23FF EB                   ex      DE,HL
2602+ 2400 19                   add     HL,DE           ; Add bytes to array start
2603+ 2401 DA 9E 16             jp      C,OMERR         ; Too big - Error
2604+ 2404 CD 8F 16             call    ENFMEM          ; See if enough memory
2605+ 2407 22 6C 53             ld      (ARREND),HL     ; Save new end of array
2606+ 240A
2607+ 240A 2B           ZERARY: dec     HL              ; Back through array data
2608+ 240B 36 00                ld      (HL),$00        ; Set array element to zero
2609+ 240D CD BD 19             call    CPDEHL          ; All elements zeroed?
2610+ 2410 C2 0A 24             jp      NZ,ZERARY       ; No - Keep on going
2611+ 2413 03                   inc     BC              ; Number of bytes + 1
2612+ 2414 57                   ld      D,A             ; A=0
2613+ 2415 2A F1 52             ld      HL,(CUROPR)     ; Get address of array
2614+ 2418 5E                   ld      E,(HL)          ; Number of dimensions
2615+ 2419 EB                   ex      DE,HL           ; To HL
2616+ 241A 29                   add     HL,HL           ; Two bytes per dimension size
2617+ 241B 09                   add     HL,BC           ; Add number of bytes
2618+ 241C EB                   ex      DE,HL           ; Bytes needed to DE
2619+ 241D 2B                   dec     HL
2620+ 241E 2B                   dec     HL
2621+ 241F 73                   ld      (HL),E          ; Save LSB of bytes needed
2622+ 2420 23                   inc     HL
2623+ 2421 72                   ld      (HL),D          ; Save MSB of bytes needed
2624+ 2422 23                   inc     HL
2625+ 2423 F1                   pop     AF              ; Locate / Create?
2626+ 2424 DA 4B 24             jp      C,ENDDIM        ; A is 0 , End if create
2627+ 2427 47           FINDEL: ld      B,A             ; Find array element
2628+ 2428 4F                   ld      C,A
2629+ 2429 7E                   ld      A,(HL)          ; Number of dimensions
2630+ 242A 23                   inc     HL
2631+ 242B 16                   defb    $16             ; Skip "pop HL"
2632+ 242C E1           FNDELP: pop     HL              ; Address of next dim' size
2633+ 242D 5E                   ld      E,(HL)          ; Get LSB of dim'n size
2634+ 242E 23                   inc     HL
2635+ 242F 56                   ld      D,(HL)          ; Get MSB of dim'n size
2636+ 2430 23                   inc     HL
2637+ 2431 E3                   ex      (SP),HL         ; Save address - Get index
2638+ 2432 F5                   push    AF              ; Save number of dim'ns
2639+ 2433 CD BD 19             call    CPDEHL          ; Dimension too large?
2640+ 2436 D2 C4 23             jp      NC,BSERR        ; Yes - ?BS Error
2641+ 2439 E5                   push    HL              ; Save index
2642+ 243A CD 96 2F             call    MLDEBC          ; Multiply previous by size
2643+ 243D D1                   pop     DE              ; Index supplied to DE
2644+ 243E 19                   add     HL,DE           ; Add index to pointer
2645+ 243F F1                   pop     AF              ; Number of dimensions
2646+ 2440 3D                   dec     A               ; Count them
2647+ 2441 44                   ld      B,H             ; MSB of pointer
2648+ 2442 4D                   ld      C,L             ; LSB of pointer
2649+ 2443 C2 2C 24             jp      NZ,FNDELP       ; More - Keep going
2650+ 2446 29                   add     HL,HL           ; 4 Bytes per element
2651+ 2447 29                   add     HL,HL
2652+ 2448 C1                   pop     BC              ; Start of array
2653+ 2449 09                   add     HL,BC           ; Point to element
2654+ 244A EB                   ex      DE,HL           ; Address of element to DE
2655+ 244B 2A FC 52     ENDDIM: ld      HL,(NXTOPR)     ; Got code string address
2656+ 244E C9                   ret
2657+ 244F
2658+ 244F
2659+ 244F              ; returns the value of the 32-bit system tick counter as
2660+ 244F              ; two 16-bit words
2661+ 244F CD A0 20     TMR:    call    TSTNUM          ; Make sure it's a number
2662+ 2452 CD C2 1C             call    DEINT           ; Get integer (-32768 to 32767)
2663+ 2455 2A 02 53             ld      HL,(TMRCNT)     ; load the LSBytes of timer
2664+ 2458 7B                   ld      A,E
2665+ 2459 B2                   or      D               ; is it 0?
2666+ 245A CA 60 24             jp      Z,ENDTMR        ; yes, jump over
2667+ 245D 2A 04 53             ld      HL,(TMRCNT+2)   ; load the MSBytes of timer
2668+ 2460 45           ENDTMR: ld      B,L             ; move bytes...
2669+ 2461 7C                   ld      A,H             ; ...into AB
2670+ 2462 C3 87 24             jp      ABPASS          ; return word into AB
2671+ 2465
2672+ 2465
2673+ 2465              ; returns the free space for BASIC or into the string pool
2674+ 2465 2A 6C 53     FRE:    ld      HL,(ARREND)     ; Start of free memory
2675+ 2468 EB                   ex      DE,HL           ; To DE
2676+ 2469 21 00 00             ld      HL,$0000        ; End of free memory
2677+ 246C 39                   add     HL,SP           ; Current stack value
2678+ 246D 3A D9 52             ld      A,(TYPE)        ; Dummy argument type
2679+ 2470 B7                   or      A
2680+ 2471 CA 81 24             jp      Z,FRENUM        ; Numeric - Free variable space
2681+ 2474 CD E8 26             call    GSTRCU          ; Current string to pool
2682+ 2477 CD E8 25             call    GARBGE          ; Garbage collection
2683+ 247A 2A F2 51             ld      HL,(STRSPC)     ; Bottom of string space in use
2684+ 247D EB                   ex      DE,HL           ; To DE
2685+ 247E 2A EF 52             ld      HL,(STRBOT)     ; Bottom of string space
2686+ 2481 7D           FRENUM: ld      A,L             ; Get LSB of end
2687+ 2482 93                   sub     E               ; Subtract LSB of beginning
2688+ 2483 4F                   ld      C,A             ; Save difference if C
2689+ 2484 7C                   ld      A,H             ; Get MSB of end
2690+ 2485 9A                   sbc     A,D             ; Subtract MSB of beginning
2691+ 2486 41           ACPASS: ld      B,C             ; Return integer AC
2692+ 2487 50           ABPASS: ld      D,B             ; Return integer AB
2693+ 2488 1E 00                ld      E,$00
2694+ 248A 21 D9 52             ld      HL,TYPE         ; Point to type
2695+ 248D 73                   ld      (HL),E          ; Set type to numeric
2696+ 248E 06 90                ld      B,$80+$10       ; 16 bit integer
2697+ 2490 C3 C1 2E             jp      RETINT          ; Return the integer
2698+ 2493
2699+ 2493              ; returns the X position of the cursor during a print
2700+ 2493 3A D7 52     POS:    ld      A,(CURPOS)      ; Get cursor position
2701+ 2496 47           PASSA:  ld      B,A             ; Put A into AB
2702+ 2497 AF                   xor     A               ; Zero A
2703+ 2498 C3 87 24             jp      ABPASS          ; Return integer AB
2704+ 249B
2705+ 249B CD 1E 25     DEF:    call    CHEKFN          ; Get "FN" and name
2706+ 249E CD 10 25             call    IDTEST          ; Test for illegal direct
2707+ 24A1 01 B5 1D             ld      BC,DATA         ; To get next statement
2708+ 24A4 C5                   push    BC              ; Save address for RETurn
2709+ 24A5 D5                   push    DE              ; Save address of function ptr
2710+ 24A6 CD C3 19             call    CHKSYN          ; Make sure "(" follows
2711+ 24A9 28                   defb    '('
2712+ 24AA CD AC 22             call    GETVAR          ; Get argument variable name
2713+ 24AD E5                   push    HL              ; Save code string address
2714+ 24AE EB                   ex      DE,HL           ; Argument address to HL
2715+ 24AF 2B                   dec     HL
2716+ 24B0 56                   ld      D,(HL)          ; Get first byte of arg name
2717+ 24B1 2B                   dec     HL
2718+ 24B2 5E                   ld      E,(HL)          ; Get second byte of arg name
2719+ 24B3 E1                   pop     HL              ; Restore code string address
2720+ 24B4 CD A0 20             call    TSTNUM          ; Make sure numeric argument
2721+ 24B7 CD C3 19             call    CHKSYN          ; Make sure ")" follows
2722+ 24BA 29                   defb    ')'
2723+ 24BB CD C3 19             call    CHKSYN          ; Make sure "=" follows
2724+ 24BE C8                   defb    ZEQUAL          ; "=" token
2725+ 24BF 44                   ld      B,H             ; Code string address to BC
2726+ 24C0 4D                   ld      C,L
2727+ 24C1 E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2728+ 24C2 71                   ld      (HL),C          ; Save LSB of FN code string
2729+ 24C3 23                   inc     HL
2730+ 24C4 70                   ld      (HL),B          ; Save MSB of FN code string
2731+ 24C5 C3 5D 25             jp      SVSTAD          ; Save address and do function
2732+ 24C8
2733+ 24C8 CD 1E 25     DOFN:   call    CHEKFN          ; Make sure FN follows
2734+ 24CB D5                   push    DE              ; Save function pointer address
2735+ 24CC CD 74 21             call    EVLPAR          ; Evaluate expression in "()"
2736+ 24CF CD A0 20             call    TSTNUM          ; Make sure numeric result
2737+ 24D2 E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2738+ 24D3 5E                   ld      E,(HL)          ; Get LSB of FN code string
2739+ 24D4 23                   inc     HL
2740+ 24D5 56                   ld      D,(HL)          ; Get MSB of FN code string
2741+ 24D6 23                   inc     HL
2742+ 24D7 7A                   ld      A,D             ; And function DEFined?
2743+ 24D8 B3                   or      E
2744+ 24D9 CA D5 16             jp      Z,UFERR         ; No - ?UF Error
2745+ 24DC 7E                   ld      A,(HL)          ; Get LSB of argument address
2746+ 24DD 23                   inc     HL
2747+ 24DE 66                   ld      H,(HL)          ; Get MSB of argument address
2748+ 24DF 6F                   ld      L,A             ; HL = Arg variable address
2749+ 24E0 E5                   push    HL              ; Save it
2750+ 24E1 2A 70 53             ld      HL,(FNRGNM)     ; Get old argument name
2751+ 24E4 E3                   ex      (SP),HL         ; Save old , Get new
2752+ 24E5 22 70 53             ld      (FNRGNM),HL     ; Set new argument name
2753+ 24E8 2A 74 53             ld      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2754+ 24EB E5                   push    HL              ; Save it
2755+ 24EC 2A 72 53             ld      HL,(FNARG)      ; Get MSB,EXP of old arg value
2756+ 24EF E5                   push    HL              ; Save it
2757+ 24F0 21 72 53             ld      HL,FNARG        ; HL = Value of argument
2758+ 24F3 D5                   push    DE              ; Save FN code string address
2759+ 24F4 CD 02 2F             call    FPTHL           ; Move FPREG to argument
2760+ 24F7 E1                   pop     HL              ; Get FN code string address
2761+ 24F8 CD 9D 20             call    GETNUM          ; Get value from function
2762+ 24FB 2B                   dec     HL              ; dec 'cos GETCHR INCs
2763+ 24FC CD 0C 1C             call    GETCHR          ; Get next character
2764+ 24FF C2 C9 16             jp      NZ,SNERR        ; Bad character in FN - Error
2765+ 2502 E1                   pop     HL              ; Get MSB,EXP of old arg
2766+ 2503 22 72 53             ld      (FNARG),HL      ; Restore it
2767+ 2506 E1                   pop     HL              ; Get LSB,NLSB of old arg
2768+ 2507 22 74 53             ld      (FNARG+2),HL    ; Restore it
2769+ 250A E1                   pop     HL              ; Get name of old arg
2770+ 250B 22 70 53             ld      (FNRGNM),HL     ; Restore it
2771+ 250E E1                   pop     HL              ; Restore code string address
2772+ 250F C9                   ret
2773+ 2510
2774+ 2510 E5           IDTEST: push    HL              ; Save code string address
2775+ 2511 2A F4 51             ld      HL,(LINEAT)     ; Get current line number
2776+ 2514 23                   inc     HL              ; -1 means direct statement
2777+ 2515 7C                   ld      A,H
2778+ 2516 B5                   or      L
2779+ 2517 E1                   pop     HL              ; Restore code string address
2780+ 2518 C0                   ret     NZ              ; Return if in program
2781+ 2519 1E 16                ld      E,ID            ; ?ID Error
2782+ 251B C3 DD 16             jp      ERROR
2783+ 251E
2784+ 251E CD C3 19     CHEKFN: call    CHKSYN          ; Make sure FN follows
2785+ 2521 B8                   defb    ZFN             ; "FN" token
2786+ 2522 3E 80                ld      A,$80
2787+ 2524 32 F7 52             ld      (FORFLG),A      ; Flag FN name to find
2788+ 2527 B6                   or      (HL)            ; FN name has bit 7 set
2789+ 2528 47                   ld      B,A             ; in first byte of name
2790+ 2529 CD B1 22             call    GTFNAM          ; Get FN name
2791+ 252C C3 A0 20             jp      TSTNUM          ; Make sure numeric function
2792+ 252F
2793+ 252F CD A0 20     STR:    call    TSTNUM          ; Make sure it's a number
2794+ 2532 CD 4F 30             call    NUMASC          ; Turn number into text
2795+ 2535 CD 63 25     STR1:   call    CRTST           ; Create string entry for it
2796+ 2538 CD E8 26             call    GSTRCU          ; Current string to pool
2797+ 253B 01 43 27             ld      BC,TOPOOL       ; Save in string pool
2798+ 253E C5                   push    BC              ; Save address on stack
2799+ 253F
2800+ 253F 7E           SAVSTR: ld      A,(HL)          ; Get string length
2801+ 2540 23                   inc     HL
2802+ 2541 23                   inc     HL
2803+ 2542 E5                   push    HL              ; Save pointer to string
2804+ 2543 CD BE 25             call    TESTR           ; See if enough string space
2805+ 2546 E1                   pop     HL              ; Restore pointer to string
2806+ 2547 4E                   ld      C,(HL)          ; Get LSB of address
2807+ 2548 23                   inc     HL
2808+ 2549 46                   ld      B,(HL)          ; Get MSB of address
2809+ 254A CD 57 25             call    CRTMST          ; Create string entry
2810+ 254D E5                   push    HL              ; Save pointer to MSB of addr
2811+ 254E 6F                   ld      L,A             ; Length of string
2812+ 254F CD DB 26             call    TOSTRA          ; Move to string area
2813+ 2552 D1                   pop     DE              ; Restore pointer to MSB
2814+ 2553 C9                   ret
2815+ 2554
2816+ 2554 CD BE 25     MKTMST: call    TESTR           ; See if enough string space
2817+ 2557 21 EB 52     CRTMST: ld      HL,TMPSTR       ; Temporary string
2818+ 255A E5                   push    HL              ; Save it
2819+ 255B 77                   ld      (HL),A          ; Save length of string
2820+ 255C 23                   inc     HL
2821+ 255D 23           SVSTAD: inc     HL
2822+ 255E 73                   ld      (HL),E          ; Save LSB of address
2823+ 255F 23                   inc     HL
2824+ 2560 72                   ld      (HL),D          ; Save MSB of address
2825+ 2561 E1                   pop     HL              ; Restore pointer
2826+ 2562 C9                   ret
2827+ 2563
2828+ 2563 2B           CRTST:  dec     HL              ; dec - INCed after
2829+ 2564 06 22        QTSTR:  ld      B,$22           ; '"'           ; Terminating quote
2830+ 2566 50                   ld      D,B             ; Quote to D
2831+ 2567 E5           DTSTR:  push    HL              ; Save start
2832+ 2568 0E FF                ld      C,-1            ; Set counter to -1
2833+ 256A 23           QTSTLP: inc     HL              ; Move on
2834+ 256B 7E                   ld      A,(HL)          ; Get byte
2835+ 256C 0C                   inc     C               ; Count bytes
2836+ 256D B7                   or      A               ; End of line?
2837+ 256E CA 79 25             jp      Z,CRTSTE        ; Yes - Create string entry
2838+ 2571 BA                   cp      D               ; Terminator D found?
2839+ 2572 CA 79 25             jp      Z,CRTSTE        ; Yes - Create string entry
2840+ 2575 B8                   cp      B               ; Terminator B found?
2841+ 2576 C2 6A 25             jp      NZ,QTSTLP       ; No - Keep looking
2842+ 2579 FE 22        CRTSTE: cp      $22             ; '"'             ; End with '"'?
2843+ 257B CC 0C 1C             call    Z,GETCHR        ; Yes - Get next character
2844+ 257E E3                   ex      (SP),HL         ; Starting quote
2845+ 257F 23                   inc     HL              ; First byte of string
2846+ 2580 EB                   ex      DE,HL           ; To DE
2847+ 2581 79                   ld      A,C             ; Get length
2848+ 2582 CD 57 25             call    CRTMST          ; Create string entry
2849+ 2585 11 EB 52     TSTOPL: ld      DE,TMPSTR       ; Temporary string
2850+ 2588 2A DD 52             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2851+ 258B 22 76 53             ld      (FPREG),HL      ; Save address of string ptr
2852+ 258E 3E 01                ld      A,$01
2853+ 2590 32 D9 52             ld      (TYPE),A        ; Set type to string
2854+ 2593 CD 05 2F             call    DETHL4          ; Move string to pool
2855+ 2596 CD BD 19             call    CPDEHL          ; Out of string pool?
2856+ 2599 22 DD 52             ld      (TMSTPT),HL     ; Save new pointer
2857+ 259C E1                   pop     HL              ; Restore code string address
2858+ 259D 7E                   ld      A,(HL)          ; Get next code byte
2859+ 259E C0                   ret     NZ              ; Return if pool OK
2860+ 259F 1E 1E                ld      E,ST            ; ?ST Error
2861+ 25A1 C3 DD 16             jp      ERROR           ; String pool overflow
2862+ 25A4
2863+ 25A4 23           PRNUMS: inc     HL              ; Skip leading space
2864+ 25A5 CD 63 25     PRS:    call    CRTST           ; Create string entry for it
2865+ 25A8 CD E8 26     PRS1:   call    GSTRCU          ; Current string to pool
2866+ 25AB CD F9 2E             call    LOADFP          ; Move string block to BCDE
2867+ 25AE 1C                   inc     E               ; Length + 1
2868+ 25AF 1D           PRSLP:  dec     E               ; Count characters
2869+ 25B0 C8                   ret     Z               ; End of string
2870+ 25B1 0A                   ld      A,(BC)          ; Get byte to output
2871+ 25B2 CD CE 19             call    OUTC            ; Output character in A
2872+ 25B5 FE 0D                cp      CR              ; Return?
2873+ 25B7 CC E3 1E             call    Z,CNTEND        ; Yes - Position cursor to 0
2874+ 25BA 03                   inc     BC              ; Next byte in string
2875+ 25BB C3 AF 25             jp      PRSLP           ; More characters to output
2876+ 25BE
2877+ 25BE B7           TESTR:  or      A               ; Test if enough room
2878+ 25BF 0E                   defb    $0E             ; No garbage collection done
2879+ 25C0 F1           GRBDON: pop     AF              ; Garbage collection done
2880+ 25C1 F5                   push    AF              ; Save status
2881+ 25C2 2A F2 51             ld      HL,(STRSPC)     ; Bottom of string space in use
2882+ 25C5 EB                   ex      DE,HL           ; To DE
2883+ 25C6 2A EF 52             ld      HL,(STRBOT)     ; Bottom of string area
2884+ 25C9 2F                   cpl                     ; Negate length (Top down)
2885+ 25CA 4F                   ld      C,A             ; -Length to BC
2886+ 25CB 06 FF                ld      B,-1            ; BC = -ve length of string
2887+ 25CD 09                   add     HL,BC           ; Add to bottom of space in use
2888+ 25CE 23                   inc     HL              ; Plus one for 2's complement
2889+ 25CF CD BD 19             call    CPDEHL          ; Below string RAM area?
2890+ 25D2 DA DC 25             jp      C,TESTOS        ; Tidy up if not done else err
2891+ 25D5 22 EF 52             ld      (STRBOT),HL     ; Save new bottom of area
2892+ 25D8 23                   inc     HL              ; Point to first byte of string
2893+ 25D9 EB                   ex      DE,HL           ; Address to DE
2894+ 25DA F1           POPAF:  pop     AF              ; Throw away status push
2895+ 25DB C9                   ret
2896+ 25DC
2897+ 25DC F1           TESTOS: pop     AF              ; Garbage collect been done?
2898+ 25DD 1E 1A                ld      E,OS            ; ?OS Error
2899+ 25DF CA DD 16             jp      Z,ERROR         ; Yes - Not enough string space
2900+ 25E2 BF                   cp      A               ; Flag garbage collect done
2901+ 25E3 F5                   push    AF              ; Save status
2902+ 25E4 01 C0 25             ld      BC,GRBDON       ; Garbage collection done
2903+ 25E7 C5                   push    BC              ; Save for RETurn
2904+ 25E8 2A DB 52     GARBGE: ld      HL,(LSTRAM)     ; Get end of RAM pointer
2905+ 25EB 22 EF 52     GARBLP: ld      (STRBOT),HL     ; Reset string pointer
2906+ 25EE 21 00 00             ld      HL,$0000
2907+ 25F1 E5                   push    HL              ; Flag no string found
2908+ 25F2 2A F2 51             ld      HL,(STRSPC)     ; Get bottom of string space
2909+ 25F5 E5                   push    HL              ; Save bottom of string space
2910+ 25F6 21 DF 52             ld      HL,TMSTPL       ; Temporary string pool
2911+ 25F9 EB           GRBLP:  ex      DE,HL
2912+ 25FA 2A DD 52             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2913+ 25FD EB                   ex      DE,HL
2914+ 25FE CD BD 19             call    CPDEHL          ; Temporary string pool done?
2915+ 2601 01 F9 25             ld      BC,GRBLP        ; Loop until string pool done
2916+ 2604 C2 4D 26             jp      NZ,STPOOL       ; No - See if in string area
2917+ 2607 2A 68 53             ld      HL,(PROGND)     ; Start of simple variables
2918+ 260A EB           SMPVAR: ex      DE,HL
2919+ 260B 2A 6A 53             ld      HL,(VAREND)     ; End of simple variables
2920+ 260E EB                   ex      DE,HL
2921+ 260F CD BD 19             call    CPDEHL          ; All simple strings done?
2922+ 2612 CA 20 26             jp      Z,ARRLP         ; Yes - Do string arrays
2923+ 2615 7E                   ld      A,(HL)          ; Get type of variable
2924+ 2616 23                   inc     HL
2925+ 2617 23                   inc     HL
2926+ 2618 B7                   or      A               ; "S" flag set if string
2927+ 2619 CD 50 26             call    STRADD          ; See if string in string area
2928+ 261C C3 0A 26             jp      SMPVAR          ; Loop until simple ones done
2929+ 261F
2930+ 261F C1           GNXARY: pop     BC              ; Scrap address of this array
2931+ 2620 EB           ARRLP:  ex      DE,HL
2932+ 2621 2A 6C 53             ld      HL,(ARREND)     ; End of string arrays
2933+ 2624 EB                   ex      DE,HL
2934+ 2625 CD BD 19             call    CPDEHL          ; All string arrays done?
2935+ 2628 CA 76 26             jp      Z,SCNEND        ; Yes - Move string if found
2936+ 262B CD F9 2E             call    LOADFP          ; Get array name to BCDE
2937+ 262E 7B                   ld      A,E             ; Get type of array
2938+ 262F E5                   push    HL              ; Save address of num of dim'ns
2939+ 2630 09                   add     HL,BC           ; Start of next array
2940+ 2631 B7                   or      A               ; Test type of array
2941+ 2632 F2 1F 26             jp      P,GNXARY        ; Numeric array - Ignore it
2942+ 2635 22 F1 52             ld      (CUROPR),HL     ; Save address of next array
2943+ 2638 E1                   pop     HL              ; Get address of num of dim'ns
2944+ 2639 4E                   ld      C,(HL)          ; BC = Number of dimensions
2945+ 263A 06 00                ld      B,$00
2946+ 263C 09                   add     HL,BC           ; Two bytes per dimension size
2947+ 263D 09                   add     HL,BC
2948+ 263E 23                   inc     HL              ; Plus one for number of dim'ns
2949+ 263F EB           GRBARY: ex      DE,HL
2950+ 2640 2A F1 52             ld      HL,(CUROPR)     ; Get address of next array
2951+ 2643 EB                   ex      DE,HL
2952+ 2644 CD BD 19             call    CPDEHL          ; Is this array finished?
2953+ 2647 CA 20 26             jp      Z,ARRLP         ; Yes - Get next one
2954+ 264A 01 3F 26             ld      BC,GRBARY       ; Loop until array all done
2955+ 264D C5           STPOOL: push    BC              ; Save return address
2956+ 264E F6 80                or      $80             ; Flag string type
2957+ 2650 7E           STRADD: ld      A,(HL)          ; Get string length
2958+ 2651 23                   inc     HL
2959+ 2652 23                   inc     HL
2960+ 2653 5E                   ld      E,(HL)          ; Get LSB of string address
2961+ 2654 23                   inc     HL
2962+ 2655 56                   ld      D,(HL)          ; Get MSB of string address
2963+ 2656 23                   inc     HL
2964+ 2657 F0                   ret     P               ; Not a string - Return
2965+ 2658 B7                   or      A               ; Set flags on string length
2966+ 2659 C8                   ret     Z               ; Null string - Return
2967+ 265A 44                   ld      B,H             ; Save variable pointer
2968+ 265B 4D                   ld      C,L
2969+ 265C 2A EF 52             ld      HL,(STRBOT)     ; Bottom of new area
2970+ 265F CD BD 19             call    CPDEHL          ; String been done?
2971+ 2662 60                   ld      H,B             ; Restore variable pointer
2972+ 2663 69                   ld      L,C
2973+ 2664 D8                   ret     C               ; String done - Ignore
2974+ 2665 E1                   pop     HL              ; Return address
2975+ 2666 E3                   ex      (SP),HL         ; Lowest available string area
2976+ 2667 CD BD 19             call    CPDEHL          ; String within string area?
2977+ 266A E3                   ex      (SP),HL         ; Lowest available string area
2978+ 266B E5                   push    HL              ; Re-save return address
2979+ 266C 60                   ld      H,B             ; Restore variable pointer
2980+ 266D 69                   ld      L,C
2981+ 266E D0                   ret     NC              ; Outside string area - Ignore
2982+ 266F C1                   pop     BC              ; Get return , Throw 2 away
2983+ 2670 F1                   pop     AF              ;
2984+ 2671 F1                   pop     AF              ;
2985+ 2672 E5                   push    HL              ; Save variable pointer
2986+ 2673 D5                   push    DE              ; Save address of current
2987+ 2674 C5                   push    BC              ; Put back return address
2988+ 2675 C9                   ret                     ; Go to it
2989+ 2676
2990+ 2676 D1           SCNEND: pop     DE              ; Addresses of strings
2991+ 2677 E1                   pop     HL              ;
2992+ 2678 7D                   ld      A,L             ; HL = 0 if no more to do
2993+ 2679 B4                   or      H
2994+ 267A C8                   ret     Z               ; No more to do - Return
2995+ 267B 2B                   dec     HL
2996+ 267C 46                   ld      B,(HL)          ; MSB of address of string
2997+ 267D 2B                   dec     HL
2998+ 267E 4E                   ld      C,(HL)          ; LSB of address of string
2999+ 267F E5                   push    HL              ; Save variable address
3000+ 2680 2B                   dec     HL
3001+ 2681 2B                   dec     HL
3002+ 2682 6E                   ld      L,(HL)          ; HL = Length of string
3003+ 2683 26 00                ld      H,$00
3004+ 2685 09                   add     HL,BC           ; Address of end of string+1
3005+ 2686 50                   ld      D,B             ; String address to DE
3006+ 2687 59                   ld      E,C
3007+ 2688 2B                   dec     HL              ; Last byte in string
3008+ 2689 44                   ld      B,H             ; Address to BC
3009+ 268A 4D                   ld      C,L
3010+ 268B 2A EF 52             ld      HL,(STRBOT)     ; Current bottom of string area
3011+ 268E CD 78 16             call    MOVSTR          ; Move string to new address
3012+ 2691 E1                   pop     HL              ; Restore variable address
3013+ 2692 71                   ld      (HL),C          ; Save new LSB of address
3014+ 2693 23                   inc     HL
3015+ 2694 70                   ld      (HL),B          ; Save new MSB of address
3016+ 2695 69                   ld      L,C             ; Next string area+1 to HL
3017+ 2696 60                   ld      H,B
3018+ 2697 2B                   dec     HL              ; Next string area address
3019+ 2698 C3 EB 25             jp      GARBLP          ; Look for more strings
3020+ 269B
3021+ 269B C5           CONCAT: push    BC              ; Save prec' opr & code string
3022+ 269C E5                   push    HL              ;
3023+ 269D 2A 76 53             ld      HL,(FPREG)      ; Get first string
3024+ 26A0 E3                   ex      (SP),HL         ; Save first string
3025+ 26A1 CD 26 21             call    OPRND           ; Get second string
3026+ 26A4 E3                   ex      (SP),HL         ; Restore first string
3027+ 26A5 CD A1 20             call    TSTSTR          ; Make sure it's a string
3028+ 26A8 7E                   ld      A,(HL)          ; Get length of second string
3029+ 26A9 E5                   push    HL              ; Save first string
3030+ 26AA 2A 76 53             ld      HL,(FPREG)      ; Get second string
3031+ 26AD E5                   push    HL              ; Save second string
3032+ 26AE 86                   add     A,(HL)          ; Add length of second string
3033+ 26AF 1E 1C                ld      E,LS            ; ?LS Error
3034+ 26B1 DA DD 16             jp      C,ERROR         ; String too long - Error
3035+ 26B4 CD 54 25             call    MKTMST          ; Make temporary string
3036+ 26B7 D1                   pop     DE              ; Get second string to DE
3037+ 26B8 CD EC 26             call    GSTRDE          ; Move to string pool if needed
3038+ 26BB E3                   ex      (SP),HL         ; Get first string
3039+ 26BC CD EB 26             call    GSTRHL          ; Move to string pool if needed
3040+ 26BF E5                   push    HL              ; Save first string
3041+ 26C0 2A ED 52             ld      HL,(TMPSTR+2)   ; Temporary string address
3042+ 26C3 EB                   ex      DE,HL           ; To DE
3043+ 26C4 CD D2 26             call    SSTSA           ; First string to string area
3044+ 26C7 CD D2 26             call    SSTSA           ; Second string to string area
3045+ 26CA 21 BB 20             ld      HL,EVAL2        ; Return to evaluation loop
3046+ 26CD E3                   ex      (SP),HL         ; Save return,get code string
3047+ 26CE E5                   push    HL              ; Save code string address
3048+ 26CF C3 85 25             jp      TSTOPL          ; To temporary string to pool
3049+ 26D2
3050+ 26D2 E1           SSTSA:  pop     HL              ; Return address
3051+ 26D3 E3                   ex      (SP),HL         ; Get string block,save return
3052+ 26D4 7E                   ld      A,(HL)          ; Get length of string
3053+ 26D5 23                   inc     HL
3054+ 26D6 23                   inc     HL
3055+ 26D7 4E                   ld      C,(HL)          ; Get LSB of string address
3056+ 26D8 23                   inc     HL
3057+ 26D9 46                   ld      B,(HL)          ; Get MSB of string address
3058+ 26DA 6F                   ld      L,A             ; Length to L
3059+ 26DB 2C           TOSTRA: inc     L               ; inc - DECed after
3060+ 26DC 2D           TSALP:  dec     L               ; Count bytes moved
3061+ 26DD C8                   ret     Z               ; End of string - Return
3062+ 26DE 0A                   ld      A,(BC)          ; Get source
3063+ 26DF 12                   ld      (DE),A          ; Save destination
3064+ 26E0 03                   inc     BC              ; Next source
3065+ 26E1 13                   inc     DE              ; Next destination
3066+ 26E2 C3 DC 26             jp      TSALP           ; Loop until string moved
3067+ 26E5
3068+ 26E5 CD A1 20     GETSTR: call    TSTSTR          ; Make sure it's a string
3069+ 26E8 2A 76 53     GSTRCU: ld      HL,(FPREG)      ; Get current string
3070+ 26EB EB           GSTRHL: ex      DE,HL           ; Save DE
3071+ 26EC CD 06 27     GSTRDE: call    BAKTMP          ; Was it last tmp-str?
3072+ 26EF EB                   ex      DE,HL           ; Restore DE
3073+ 26F0 C0                   ret     NZ              ; No - Return
3074+ 26F1 D5                   push    DE              ; Save string
3075+ 26F2 50                   ld      D,B             ; String block address to DE
3076+ 26F3 59                   ld      E,C
3077+ 26F4 1B                   dec     DE              ; Point to length
3078+ 26F5 4E                   ld      C,(HL)          ; Get string length
3079+ 26F6 2A EF 52             ld      HL,(STRBOT)     ; Current bottom of string area
3080+ 26F9 CD BD 19             call    CPDEHL          ; Last one in string area?
3081+ 26FC C2 04 27             jp      NZ,POPHL        ; No - Return
3082+ 26FF 47                   ld      B,A             ; Clear B (A=0)
3083+ 2700 09                   add     HL,BC           ; Remove string from str' area
3084+ 2701 22 EF 52             ld      (STRBOT),HL     ; Save new bottom of str' area
3085+ 2704 E1           POPHL:  pop     HL              ; Restore string
3086+ 2705 C9                   ret
3087+ 2706
3088+ 2706 2A DD 52     BAKTMP: ld      HL,(TMSTPT)     ; Get temporary string pool top
3089+ 2709 2B                   dec     HL              ; Back
3090+ 270A 46                   ld      B,(HL)          ; Get MSB of address
3091+ 270B 2B                   dec     HL              ; Back
3092+ 270C 4E                   ld      C,(HL)          ; Get LSB of address
3093+ 270D 2B                   dec     HL              ; Back
3094+ 270E 2B                   dec     HL              ; Back
3095+ 270F CD BD 19             call    CPDEHL          ; String last in string pool?
3096+ 2712 C0                   ret     NZ              ; Yes - Leave it
3097+ 2713 22 DD 52             ld      (TMSTPT),HL     ; Save new string pool top
3098+ 2716 C9                   ret
3099+ 2717
3100+ 2717 01 96 24     LEN:    ld      BC,PASSA        ; To return integer A
3101+ 271A C5                   push    BC              ; Save address
3102+ 271B CD E5 26     GETLEN: call    GETSTR          ; Get string and its length
3103+ 271E AF                   xor     A
3104+ 271F 57                   ld      D,A             ; Clear D
3105+ 2720 32 D9 52             ld      (TYPE),A        ; Set type to numeric
3106+ 2723 7E                   ld      A,(HL)          ; Get length of string
3107+ 2724 B7                   or      A               ; Set status flags
3108+ 2725 C9                   ret
3109+ 2726
3110+ 2726 01 96 24     ASC:    ld      BC,PASSA        ; To return integer A
3111+ 2729 C5                   push    BC              ; Save address
3112+ 272A CD 1B 27     GTFLNM: call    GETLEN          ; Get length of string
3113+ 272D CA D7 1C             jp      Z,FCERR         ; Null string - Error
3114+ 2730 23                   inc     HL
3115+ 2731 23                   inc     HL
3116+ 2732 5E                   ld      E,(HL)          ; Get LSB of address
3117+ 2733 23                   inc     HL
3118+ 2734 56                   ld      D,(HL)          ; Get MSB of address
3119+ 2735 1A                   ld      A,(DE)          ; Get first byte of string
3120+ 2736 C9                   ret
3121+ 2737
3122+ 2737 3E 01        CHR:    ld      A,$01           ; One character string
3123+ 2739 CD 54 25             call    MKTMST          ; Make a temporary string
3124+ 273C CD 26 29             call    MAKINT          ; Make it integer A
3125+ 273F 2A ED 52             ld      HL,(TMPSTR+2)   ; Get address of string
3126+ 2742 73                   ld      (HL),E          ; Save character
3127+ 2743 C1           TOPOOL: pop     BC              ; Clean up stack
3128+ 2744 C3 85 25             jp      TSTOPL          ; Temporary string to pool
3129+ 2747
3130+ 2747 CD D6 28     LEFT:   call    LFRGNM          ; Get number and ending ")"
3131+ 274A AF                   xor     A               ; Start at first byte in string
3132+ 274B E3           RIGHT1: ex      (SP),HL         ; Save code string,Get string
3133+ 274C 4F                   ld      C,A             ; Starting position in string
3134+ 274D E5           MID1:   push    HL              ; Save string block address
3135+ 274E 7E                   ld      A,(HL)          ; Get length of string
3136+ 274F B8                   cp      B               ; Compare with number given
3137+ 2750 DA 55 27             jp      C,ALLFOL        ; All following bytes required
3138+ 2753 78                   ld      A,B             ; Get new length
3139+ 2754 11                   defb    $11             ; Skip "ld C,0"
3140+ 2755 0E 00        ALLFOL: ld      C,$00           ; First byte of string
3141+ 2757 C5                   push    BC              ; Save position in string
3142+ 2758 CD BE 25             call    TESTR           ; See if enough string space
3143+ 275B C1                   pop     BC              ; Get position in string
3144+ 275C E1                   pop     HL              ; Restore string block address
3145+ 275D E5                   push    HL              ; And re-save it
3146+ 275E 23                   inc     HL
3147+ 275F 23                   inc     HL
3148+ 2760 46                   ld      B,(HL)          ; Get LSB of address
3149+ 2761 23                   inc     HL
3150+ 2762 66                   ld      H,(HL)          ; Get MSB of address
3151+ 2763 68                   ld      L,B             ; HL = address of string
3152+ 2764 06 00                ld      B,$00           ; BC = starting address
3153+ 2766 09                   add     HL,BC           ; Point to that byte
3154+ 2767 44                   ld      B,H             ; BC = source string
3155+ 2768 4D                   ld      C,L
3156+ 2769 CD 57 25             call    CRTMST          ; Create a string entry
3157+ 276C 6F                   ld      L,A             ; Length of new string
3158+ 276D CD DB 26             call    TOSTRA          ; Move string to string area
3159+ 2770 D1                   pop     DE              ; Clear stack
3160+ 2771 CD EC 26             call    GSTRDE          ; Move to string pool if needed
3161+ 2774 C3 85 25             jp      TSTOPL          ; Temporary string to pool
3162+ 2777
3163+ 2777
3164+ 2777              ; INSTR statement - look for a string inside another string
3165+ 2777              ; usage: INSTR(A$,B$) -> search for B$ into A$
3166+ 2777              ; return 0 if B$ is not found into A$, or LEN(A$)<LEN(B$)
3167+ 2777              ; return 1~255 to indicate the starting position of B$ into A$
3168+ 2777              ; ex.: INSTR("HELLO","LO") returns 4 - INSTR("HOME","PC") returns 0
3169+ 2777              LNS1    equ     TMPBFR1
3170+ 2777              ADRS1   equ     TMPBFR2
3171+ 2777              LNS2    equ     TMPBFR3
3172+ 2777              ADRS2   equ     TMPBFR4
3173+ 2777              PT      equ     VIDEOBUFF
3174+ 2777              PT1     equ     VIDEOBUFF+2
3175+ 2777              PT2     equ     VIDEOBUFF+4
3176+ 2777              TP      equ     VIDEOBUFF+6
3177+ 2777              TF      equ     VIDEOBUFF+8
3178+ 2777 CD C3 19     INSTR:  call    CHKSYN          ; make sure "(" follows
3179+ 277A 28                   defb    '('
3180+ 277B 2B                   dec     HL              ; dec 'cause GETCHR increments
3181+ 277C CD 0C 1C             call    GETCHR          ; check if something follows
3182+ 277F CA C9 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
3183+ 2782 CD AF 20             call    EVAL            ; Evaluate expression
3184+ 2785 CD A1 20             call    TSTSTR          ; Make sure it's a string
3185+ 2788 22 2A 53             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3186+ 278B CD E8 26             call    GSTRCU          ; check that a string follows
3187+ 278E CD F9 2E             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3188+ 2791 ED 53 22 53          ld      (LNS1),DE       ; store values into
3189+ 2795 ED 43 24 53          ld      (ADRS1),BC      ; temp buffers
3190+ 2799 2A 2A 53             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3191+ 279C CD C3 19             call    CHKSYN          ; Make sure ',' follows
3192+ 279F 2C                   defb    ','
3193+ 27A0 2B                   dec     HL              ; dec 'cause GETCHR increments
3194+ 27A1 CD 0C 1C             call    GETCHR          ; check if something follows
3195+ 27A4 CA C9 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
3196+ 27A7 CD AF 20             call    EVAL            ; Evaluate expression
3197+ 27AA CD A1 20             call    TSTSTR          ; Make sure it's a string
3198+ 27AD 22 2A 53             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3199+ 27B0 CD E8 26             call    GSTRCU          ; check that a string follows
3200+ 27B3 CD F9 2E             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3201+ 27B6 ED 53 26 53          ld      (LNS2),DE       ; store values into
3202+ 27BA ED 43 28 53          ld      (ADRS2),BC      ; temp buffers
3203+ 27BE 2A 2A 53             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3204+ 27C1 CD C3 19             call    CHKSYN          ; make sure ")" follows
3205+ 27C4 29                   defb    ')'
3206+ 27C5 E5                   push    HL              ; store current code string pointer (the point after the ")" ) ...
3207+ 27C6 FD E1                pop     IY              ; ...into IY
3208+ 27C8 AF                   xor     A               ; reset 10 RAM cells
3209+ 27C9 06 0A                ld      B,$0A           ; (INSTR registers)
3210+ 27CB 21 2A 53             ld      HL,PT           ; first cell
3211+ 27CE 77           EMPTINS:ld      (HL),A          ; reset cell
3212+ 27CF 23                   inc     HL              ; next cell
3213+ 27D0 10 FC                djnz    EMPTINS         ; repeat
3214+ 27D2 ED 5B 26 53          ld      DE,(LNS2)       ; load len(S2) into DE
3215+ 27D6 2A 22 53             ld      HL,(LNS1)       ; load len(S1) into HL
3216+ 27D9 CD DE 3F             call    CMP16           ; check that len(S1)>=len(S2)
3217+ 27DC DA 51 28             jp      C,RZINSTR       ; if len(S2)>len(S1) then return 0
3218+ 27DF AF           RPTINST:xor     A               ; reset...
3219+ 27E0 32 30 53             ld      (TP),A          ; ...TP...
3220+ 27E3 32 32 53             ld      (TF),A          ; ...and TF
3221+ 27E6 ED 4B 2A 53          ld      BC,(PT)         ; pointer to S1
3222+ 27EA 2A 24 53             ld      HL,(ADRS1)      ; first cell of S1
3223+ 27ED 09                   add     HL,BC           ; get current position into RAM
3224+ 27EE 7E                   ld      A,(HL)          ; load S1(PT)
3225+ 27EF 2A 28 53             ld      HL,(ADRS2)      ; pointer to first char of S2
3226+ 27F2 BE                   cp      (HL)            ; is S1(PT)=S2(0)?
3227+ 27F3 20 3A                jr      NZ,CNT1INS      ; no, continue
3228+ 27F5 3A 2A 53             ld      A,(PT)          ; load current PT
3229+ 27F8 32 30 53             ld      (TP),A          ; TP=PT
3230+ 27FB 32 2C 53             ld      (PT1),A         ; P1=PT
3231+ 27FE AF                   xor     A               ; set...
3232+ 27FF 32 2E 53             ld      (PT2),A         ; ...PT2=0
3233+ 2802 3C                   inc     A               ;
3234+ 2803 32 32 53             ld      (TF),A          ; set TF=1
3235+ 2806 ED 4B 2C 53  RP2INST:ld      BC,(PT1)        ; load pointer PT1
3236+ 280A 2A 24 53             ld      HL,(ADRS1)      ; load address of S1
3237+ 280D 09                   add     HL,BC           ; find char of S1 pointed by PT1
3238+ 280E 7E                   ld      A,(HL)          ; load S1(PT1)
3239+ 280F ED 4B 2E 53          ld      BC,(PT2)        ; load pointer PT2
3240+ 2813 2A 28 53             ld      HL,(ADRS2)      ; load char of S2 pointed by PT2
3241+ 2816 09                   add     HL,BC           ; find S2(PT2)
3242+ 2817 BE                   cp      (HL)            ; is S1(PT1)=S2(PT2)?
3243+ 2818 20 4C                jr      NZ,CNTZIN       ; no, exit inner loop
3244+ 281A 21 2C 53             ld      HL,PT1
3245+ 281D 34                   inc     (HL)            ; increment PT1
3246+ 281E 3A 2E 53             ld      A,(PT2)
3247+ 2821 3C                   inc     A               ; increment PT2
3248+ 2822 32 2E 53             ld      (PT2),A
3249+ 2825 CA 2F 28             jp      Z,CNT1INS       ; if PT2>255 then exit
3250+ 2828 21 26 53             ld      HL,LNS2         ; len(S2)
3251+ 282B BE                   cp      (HL)            ; PT2=len(S2)?
3252+ 282C DA 06 28             jp      C,RP2INST       ; no (PT2<len(S2) - repeat
3253+ 282F 3A 32 53     CNT1INS:ld      A,(TF)          ; check TF
3254+ 2832 A7                   and     A               ; TF=0? (clears also Carry for next SBC)
3255+ 2833 20 1C                jr      NZ,RZINSTR      ; no, exit
3256+ 2835 2A 22 53             ld      HL,(LNS1)       ; load len(S1)
3257+ 2838 ED 4B 26 53          ld      BC,(LNS2)       ; load len(S2)
3258+ 283C ED 42                sbc     HL,BC           ; HL=len(S1)-len(S2)
3259+ 283E ED 5B 2A 53          ld      DE,(PT)         ; load pointer
3260+ 2842 1C                   inc     E               ; PT=PT+1
3261+ 2843 ED 53 2A 53          ld      (PT),DE         ; store new value
3262+ 2847 EB                   ex      DE,HL           ; invert registers
3263+ 2848 CD DE 3F             call    CMP16           ; check if PT>len(S1)-len(S2)
3264+ 284B DA DF 27             jp      C,RPTINST       ; repeat if <
3265+ 284E CA DF 27             jp      Z,RPTINST       ; repeat if =
3266+ 2851 3A 32 53     RZINSTR:ld      A,(TF)          ; current value of TF
3267+ 2854 A7                   and     A               ; is it 0?
3268+ 2855 CA 5C 28             jp      Z,LVINSTR       ; yes, return 0
3269+ 2858 3A 30 53             ld      A,(TP)          ; return TP...
3270+ 285B 3C                   inc     A               ; ...incremented by 1
3271+ 285C E1           LVINSTR:pop     HL              ; drop original return point
3272+ 285D FD E5                push    IY              ; load current string address from IY into stack
3273+ 285F 11 88 21             ld      DE,RETNUM       ; Address of Return number from function...
3274+ 2862 D5                   push    DE              ; ...saved on stack
3275+ 2863 C3 96 24             jp      PASSA           ; return TP
3276+ 2866 AF           CNTZIN: xor     A               ; set...
3277+ 2867 32 32 53             ld      (TF),A          ; TF=0
3278+ 286A C3 2F 28             jp      CNT1INS         ; continue
3279+ 286D
3280+ 286D
3281+ 286D              ; returns the right portion of a string
3282+ 286D CD D6 28     RIGHT:  call    LFRGNM          ; Get number and ending ")"
3283+ 2870 D1                   pop     DE              ; Get string length
3284+ 2871 D5                   push    DE              ; And re-save
3285+ 2872 1A                   ld      A,(DE)          ; Get length
3286+ 2873 90                   sub     B               ; Move back N bytes
3287+ 2874 C3 4B 27             jp      RIGHT1          ; Go and get sub-string
3288+ 2877
3289+ 2877              ; returns a piece of a string
3290+ 2877 EB           MID:    ex      DE,HL           ; Get code string address
3291+ 2878 7E                   ld      A,(HL)          ; Get next byte ',' or ")"
3292+ 2879 CD DB 28             call    MIDNUM          ; Get number supplied
3293+ 287C 04                   inc     B               ; Is it character zero?
3294+ 287D 05                   dec     B
3295+ 287E CA D7 1C             jp      Z,FCERR         ; Yes - Error
3296+ 2881 C5                   push    BC              ; Save starting position
3297+ 2882 1E FF                ld      E,$FF           ; All of string
3298+ 2884 FE 29                cp      ')'             ; Any length given?
3299+ 2886 CA 90 28             jp      Z,RSTSTR        ; No - Rest of string
3300+ 2889 CD C3 19             call    CHKSYN          ; Make sure ',' follows
3301+ 288C 2C                   defb    ','
3302+ 288D CD 23 29             call    GETINT          ; Get integer 0-255
3303+ 2890 CD C3 19     RSTSTR: call    CHKSYN          ; Make sure ")" follows
3304+ 2893 29                   defb    ')'
3305+ 2894 F1                   pop     AF              ; Restore starting position
3306+ 2895 E3                   ex      (SP),HL         ; Get string,save code string
3307+ 2896 01 4D 27             ld      BC,MID1         ; Continuation of MID$ routine
3308+ 2899 C5                   push    BC              ; Save for return
3309+ 289A 3D                   dec     A               ; Starting position-1
3310+ 289B BE                   cp      (HL)            ; Compare with length
3311+ 289C 06 00                ld      B,$00           ; Zero bytes length
3312+ 289E D0                   ret     NC              ; Null string if start past end
3313+ 289F 4F                   ld      C,A             ; Save starting position-1
3314+ 28A0 7E                   ld      A,(HL)          ; Get length of string
3315+ 28A1 91                   sub     C               ; Subtract start
3316+ 28A2 BB                   cp      E               ; Enough string for it?
3317+ 28A3 47                   ld      B,A             ; Save maximum length available
3318+ 28A4 D8                   ret     C               ; Truncate string if needed
3319+ 28A5 43                   ld      B,E             ; Set specified length
3320+ 28A6 C9                   ret                     ; Go and create string
3321+ 28A7
3322+ 28A7
3323+ 28A7              ; return the value of a numeric string
3324+ 28A7 CD 1B 27     VAL:    call    GETLEN          ; Get length of string
3325+ 28AA CA 79 2C             jp      Z,RESZER        ; Result zero
3326+ 28AD 5F                   ld      E,A             ; Save length
3327+ 28AE 23                   inc     HL
3328+ 28AF 23                   inc     HL
3329+ 28B0 7E                   ld      A,(HL)          ; Get LSB of address
3330+ 28B1 23                   inc     HL
3331+ 28B2 66                   ld      H,(HL)          ; Get MSB of address
3332+ 28B3 6F                   ld      L,A             ; HL = String address
3333+ 28B4 E5                   push    HL              ; Save string address
3334+ 28B5 19                   add     HL,DE
3335+ 28B6 46                   ld      B,(HL)          ; Get end of string+1 byte
3336+ 28B7 72                   ld      (HL),D          ; Zero it to terminate
3337+ 28B8 E3                   ex      (SP),HL         ; Save string end,get start
3338+ 28B9 C5                   push    BC              ; Save end+1 byte
3339+ 28BA 7E                   ld      A,(HL)          ; Get starting byte
3340+ 28BB FE 24                cp      '$'             ; Hex number indicated? [function added]
3341+ 28BD C2 C5 28             jp      NZ,VAL1
3342+ 28C0 CD 17 3F             call    HEXTFP          ; Convert Hex to FPREG
3343+ 28C3 18 0D                jr      VAL3
3344+ 28C5 FE 25        VAL1:   cp      '%'             ; Binary number indicated? [function added]
3345+ 28C7 C2 CF 28             jp      NZ,VAL2
3346+ 28CA CD 87 3F             call    BINTFP          ; Convert Bin to FPREG
3347+ 28CD 18 03                jr      VAL3
3348+ 28CF CD B1 2F     VAL2:   call    ASCTFP          ; Convert ASCII string to FP
3349+ 28D2 C1           VAL3:   pop     BC              ; Restore end+1 byte
3350+ 28D3 E1                   pop     HL              ; Restore end+1 address
3351+ 28D4 70                   ld      (HL),B          ; Put back original byte
3352+ 28D5 C9                   ret
3353+ 28D6
3354+ 28D6 EB           LFRGNM: ex      DE,HL           ; Code string address to HL
3355+ 28D7 CD C3 19             call    CHKSYN          ; Make sure ")" follows
3356+ 28DA 29                   defb    ')'
3357+ 28DB C1           MIDNUM: pop     BC              ; Get return address
3358+ 28DC D1                   pop     DE              ; Get number supplied
3359+ 28DD C5                   push    BC              ; Re-save return address
3360+ 28DE 43                   ld      B,E             ; Number to B
3361+ 28DF C9                   ret
3362+ 28E0
3363+ 28E0 CD 26 29     INP:    call    MAKINT          ; Make it integer A
3364+ 28E3 32 E5 51             ld      (INPORT),A      ; Set input port
3365+ 28E6 CD E4 51             call    INPSUB          ; Get input from port
3366+ 28E9 C3 96 24             jp      PASSA           ; Return integer A
3367+ 28EC
3368+ 28EC CD 10 29     POUT:   call    SETIO           ; Set up port number
3369+ 28EF C3 AC 51             jp      OUTSUB          ; Output data and return
3370+ 28F2
3371+ 28F2 CD 10 29     WAIT:   call    SETIO           ; Set up port number
3372+ 28F5 F5                   push    AF              ; Save AND mask
3373+ 28F6 1E 00                ld      E,$00           ; Assume zero if none given
3374+ 28F8 2B                   dec     HL              ; dec 'cos GETCHR INCs
3375+ 28F9 CD 0C 1C             call    GETCHR          ; Get next character
3376+ 28FC CA 06 29             jp      Z,NOXOR         ; No XOR byte given
3377+ 28FF CD C3 19             call    CHKSYN          ; Make sure ',' follows
3378+ 2902 2C                   defb    ','
3379+ 2903 CD 23 29             call    GETINT          ; Get integer 0-255 to XOR with
3380+ 2906 C1           NOXOR:  pop     BC              ; Restore AND mask
3381+ 2907 CD E4 51     WAITLP: call    INPSUB          ; Get input
3382+ 290A AB                   xor     E               ; Flip selected bits
3383+ 290B A0                   and     B               ; Result non-zero?
3384+ 290C CA 07 29             jp      Z,WAITLP        ; No = keep waiting
3385+ 290F C9                   ret
3386+ 2910
3387+ 2910 CD 23 29     SETIO:  call    GETINT          ; Get integer 0-255
3388+ 2913 32 E5 51             ld      (INPORT),A      ; Set input port
3389+ 2916 32 AD 51             ld      (OTPORT),A      ; Set output port
3390+ 2919 CD C3 19             call    CHKSYN          ; Make sure ',' follows
3391+ 291C 2C                   defb    ','
3392+ 291D C3 23 29             jp      GETINT          ; Get integer 0-255 and return
3393+ 2920
3394+ 2920 CD 0C 1C     FNDNUM: call    GETCHR          ; Get next character
3395+ 2923 CD 9D 20     GETINT: call    GETNUM          ; Get a number from 0 to 255
3396+ 2926 CD BC 1C     MAKINT: call    DEPINT          ; Make sure value 0 - 255
3397+ 2929 7A                   ld      A,D             ; Get MSB of number
3398+ 292A B7                   or      A               ; Zero?
3399+ 292B C2 D7 1C             jp      NZ,FCERR        ; No - Error
3400+ 292E 2B                   dec     HL              ; dec 'cos GETCHR INCs
3401+ 292F CD 0C 1C             call    GETCHR          ; Get next character
3402+ 2932 7B                   ld      A,E             ; Get number to A
3403+ 2933 C9                   ret
3404+ 2934
3405+ 2934
3406+ 2934              ; activate a Non-Maskable Interrupt hooked to VDP interrupt signal
3407+ 2934              ; address must point to an ISR routine that terminates with EI/RETN instructions
3408+ 2934 CD 9D 20     NMI:    call    GETNUM          ; Get memory address
3409+ 2937 CD C2 1C             call    DEINT           ; get integer -32768 to 32767
3410+ 293A 7B                   ld      A,E             ; check if address is 0
3411+ 293B B2                   or      D
3412+ 293C 20 11                jr      NZ,NM1          ; no, so jump over
3413+ 293E F3           DISNMI: di                      ; disable INTs
3414+ 293F CD 6B 29             call    NMIDINT         ; disable VDP INT
3415+ 2942 E5                   push    HL              ; store HL
3416+ 2943 21 ED 45             ld      HL,$45ED        ; these are the op-codes for "RETN"
3417+ 2946 22 A6 51             ld      (NMIUSR),HL     ; store RETN
3418+ 2949 AF                   xor     A
3419+ 294A 32 A8 51             ld      (NMIUSR+2),A    ; "NOP"
3420+ 294D 18 11                jr      NMI2            ; execute the last part of code
3421+ 294F E5           NM1:    push    HL              ; store current HL
3422+ 2950 EB                   ex      DE,HL           ; move address argument into HL
3423+ 2951 F3                   di                      ; disable INTs
3424+ 2952 CD 6B 29             call    NMIDINT         ; disable VDP INT, if enabled
3425+ 2955 3E C3                ld      A,$C3           ; "jp" instruction
3426+ 2957 32 A6 51             ld      (NMIUSR),A      ; store it
3427+ 295A 22 A7 51             ld      (NMIUSR+1),HL   ; store address
3428+ 295D CD 64 29             call    NMIEINT         ; re-enable VDP INT
3429+ 2960 FB           NMI2:   ei                      ; re-enable INTS
3430+ 2961 00                   nop                     ; wait for INTs
3431+ 2962 E1                   pop    HL               ; retrieve HL
3432+ 2963 C9                   ret                     ; return to caller
3433+ 2964              ; enable VDP INT
3434+ 2964 CD 7A 29     NMIEINT:call    NMIVR1          ; load default VReg #1 setting
3435+ 2967 F6 20                or      %00100000       ; enable VDP INT
3436+ 2969 18 03                jr      NMIINT          ; rest of code is shared
3437+ 296B              ; disable VDP INT
3438+ 296B CD 7A 29     NMIDINT:call    NMIVR1          ; load default VReg #1 setting
3439+ 296E D5           NMIINT: push    DE              ; store DE
3440+ 296F 5F                   ld      E,A             ; move value into E
3441+ 2970 3E 01                ld      A,$01           ; VREG #1
3442+ 2972 F3                   di                      ; disable INTs
3443+ 2973 CD A4 06             call    WRITE_VREG      ; disable VDP INT
3444+ 2976 FB                   ei                      ; re-enable INTs
3445+ 2977 00                   nop                     ; wait for INTs being enabled
3446+ 2978 D1                   pop     DE              ; retrieve DE
3447+ 2979 C9                   ret                     ; return to caller
3448+ 297A
3449+ 297A              ; load VREG #1 setting for current screen mode and return it into A
3450+ 297A E5           NMIVR1: push    HL              ; store HL
3451+ 297B D5                   push    DE              ; store DE
3452+ 297C 3A 14 53             ld      A,(SCR_MODE)    ; check screen mode
3453+ 297F 87                   add     A,A             ; multiply A by 8...
3454+ 2980 87                   add     A,A             ; ...so that reg. A can points..
3455+ 2981 87                   add     A,A             ; to the correct settings
3456+ 2982 3C                   inc     A               ; need to change VREG 1
3457+ 2983 5F                   ld      E,A             ; copy A into E
3458+ 2984 16 00                ld      D,$00           ; reset D
3459+ 2986 21 13 0B             ld      HL,VDPMODESET   ; pointer to register #1 setting...
3460+ 2989 19                   add     HL,DE           ; ...for current screen mode
3461+ 298A 7E                   ld      A,(HL)          ; load current setting
3462+ 298B D1                   pop     DE              ; retrieve DE
3463+ 298C E1                   pop     HL              ; retrieve HL
3464+ 298D C9                   ret                     ; return to caller
3465+ 298E
3466+ 298E              ; execute a machine language routine, eventually passing a param into A
3467+ 298E CD 9D 20     SYS:    call    GETNUM          ; Get memory address
3468+ 2991 CD C2 1C             call    DEINT           ; Get integer -32768 to 32767
3469+ 2994 ED 53 24 53          ld      (TMPBFR2),DE    ; store user routine's address
3470+ 2998 AF                   xor     A               ; reset A
3471+ 2999 32 22 53             ld      (TMPBFR1),A     ; store into temp buffer
3472+ 299C 2B                   dec     HL              ; dec 'cos GETCHR INCs
3473+ 299D CD 0C 1C             call    GETCHR          ; check next character
3474+ 29A0 28 0A                jr      Z,NOSYSPR       ; jump if nothing follows
3475+ 29A2 CD C3 19             call    CHKSYN          ; Make sure ',' follows
3476+ 29A5 2C                   defb    ','
3477+ 29A6 CD 23 29             call    GETINT          ; get byte value (0~255) if something follows
3478+ 29A9 32 22 53             ld      (TMPBFR1),A     ; store into temp buffer
3479+ 29AC 3A 22 53     NOSYSPR:ld      A,(TMPBFR1)     ; recover A
3480+ 29AF ED 5B 24 53          ld      DE,(TMPBFR2)    ; recover user routine's address
3481+ 29B3 E5                   push    HL              ; save code string address
3482+ 29B4 EB                   ex      DE,HL           ; move user routine's address into HL
3483+ 29B5 11 BA 29             ld      DE,SYSRET       ; set point of return after the user routine
3484+ 29B8 D5                   push    DE              ; store into stack
3485+ 29B9 E9                   jp      (HL)            ; call user routine
3486+ 29BA E1           SYSRET: pop     HL              ; retrieve code string address
3487+ 29BB C9                   ret                     ; return to caller
3488+ 29BC
3489+ 29BC
3490+ 29BC              ; read the contents of a RAM location
3491+ 29BC CD C2 1C     PEEK:   call    DEINT           ; Get memory address into DE
3492+ 29BF 1A                   ld      A,(DE)          ; Read value of memory cell
3493+ 29C0 C3 96 24             jp      PASSA           ; Return into A
3494+ 29C3
3495+ 29C3              ; read the contents of a VRAM location
3496+ 29C3 CD C2 1C     VPEEK:  call    DEINT           ; Get VRAM address into DE
3497+ 29C6 EB                   ex      DE,HL           ; Copy param into HL
3498+ 29C7 F3                   di                      ; Disable interrupts
3499+ 29C8 CD 7A 06             call    READ_VIDEO_LOC  ; Read data from VRAM at address HL
3500+ 29CB FB                   ei                      ; Re-enable interrupts
3501+ 29CC EB                   ex      DE,HL           ; Restore HL
3502+ 29CD C3 96 24             jp      PASSA           ; Return value into A
3503+ 29D0
3504+ 29D0              ; recover params for POKE/VPOKE commands
3505+ 29D0              ; returns address into DE and byte to be written into A
3506+ 29D0 CD 9D 20     PKEPRMS:call    GETNUM          ; Get memory address
3507+ 29D3 CD C2 1C             call    DEINT           ; Get integer -32768 to 32767
3508+ 29D6 ED 53 22 53          ld      (TMPBFR1),DE    ; Store DE into a temp. buffer
3509+ 29DA CD C3 19             call    CHKSYN          ; Make sure ',' follows
3510+ 29DD 2C                   defb    ','
3511+ 29DE CD 23 29             call    GETINT          ; Get integer 0-255
3512+ 29E1 ED 5B 22 53          ld      DE,(TMPBFR1)    ; Restore memory address
3513+ 29E5 C9                   ret                     ; Return to caller
3514+ 29E6
3515+ 29E6              ; write a byte into a RAM location
3516+ 29E6 CD D0 29     POKE:   call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3517+ 29E9 12                   ld      (DE),A          ; Load it into memory
3518+ 29EA C9                   ret
3519+ 29EB
3520+ 29EB              ; write a byte into a VRAM location
3521+ 29EB CD D0 29     VPOKE:  call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3522+ 29EE EB                   ex      DE,HL           ; Copy address into HL
3523+ 29EF F3                   di                      ; Disable interrupts
3524+ 29F0 CD 8F 06             call    WRITE_VIDEO_LOC ; write data into VRAM at address HL
3525+ 29F3 FB                   ei                      ; Re-enable interrupts
3526+ 29F4 EB                   ex      DE,HL           ; Restore HL
3527+ 29F5 C9                   ret                     ; Return to caller
3528+ 29F6
3529+ 29F6              ; position the cursor at a specific X,Y location onto screen
3530+ 29F6 CD 23 29     LOCATE: call    GETINT          ; get the first param into A
3531+ 29F9 E5                   push    HL              ; store HL
3532+ 29FA 21 12 53             ld      HL,SCR_SIZE_W   ; load address of screen width
3533+ 29FD 5E                   ld      E,(HL)          ; load screen width into E
3534+ 29FE E1                   pop     HL              ; restore HL
3535+ 29FF BB                   cp      E               ; compare witdh with param
3536+ 2A00 D2 D7 1C             jp      NC,FCERR        ; value over the width of the screen, exit with Illegal F.C. error
3537+ 2A03 32 22 53             ld      (TMPBFR1),A     ; Store X into a temp. buffer
3538+ 2A06 CD C3 19             call    CHKSYN          ; Make sure ',' follows
3539+ 2A09 2C                   defb    ','
3540+ 2A0A CD 23 29             call    GETINT          ; Get the second param into A
3541+ 2A0D E5                   push    HL              ; store HL
3542+ 2A0E 21 13 53             ld      HL,SCR_SIZE_H   ; load address of screen width
3543+ 2A11 5E                   ld      E,(HL)          ; load screen width into A
3544+ 2A12 E1                   pop     HL              ; restore HL
3545+ 2A13 BB                   cp      E               ; compare witdh with param
3546+ 2A14 D2 D7 1C             jp      NC,FCERR        ; value over the height of the screen, exit with Illegal F.C. error
3547+ 2A17 32 1A 53             ld      (SCR_CUR_NY),A  ; store new Y
3548+ 2A1A 3A 22 53             ld      A,(TMPBFR1)     ; recover the new X
3549+ 2A1D 32 19 53             ld      (SCR_CUR_NX),A  ; store new X
3550+ 2A20 E5                   push    HL              ; store HL
3551+ 2A21 F3                   di                      ; disable INTs
3552+ 2A22 CD C0 06             call    MOVCRS          ; move cursor to new location
3553+ 2A25 FB                   ei                      ; re-enable INTs
3554+ 2A26 E1                   pop     HL              ; restore HL
3555+ 2A27 C9                   ret                     ; return to caller
3556+ 2A28
3557+ 2A28              ; write a byte into one of the PSG registers
3558+ 2A28 CD 23 29     SREG:   call    GETINT          ; Get register number back into A
3559+ 2A2B FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3560+ 2A2D D2 D7 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3561+ 2A30 32 22 53             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3562+ 2A33 CD C3 19             call    CHKSYN          ; Make sure ',' follows
3563+ 2A36 2C                   defb    ','
3564+ 2A37 CD 23 29             call    GETINT          ; get second value (0-255), returned into A
3565+ 2A3A 5F                   ld      E,A             ; store value into E
3566+ 2A3B 3A 22 53             ld      A,(TMPBFR1)     ; recover VDP register and store into D
3567+ 2A3E F3                   di                      ; disable INTs
3568+ 2A3F 0E 40                ld      C,PSG_REG       ; output port to access PSG registers
3569+ 2A41 ED 79                out     (C),A           ; send register # to PSG
3570+ 2A43 0E 41                ld      C,PSG_DAT       ; output port to send data to PSG
3571+ 2A45 ED 59                out     (C),E           ; send byte to write into selected register
3572+ 2A47 FB                   ei                      ; re-enable INTs
3573+ 2A48 C9                   ret                     ; return to caller
3574+ 2A49
3575+ 2A49              ; VOLUME ch,vol
3576+ 2A49              ; set the volume for the audio channels
3577+ 2A49              ; "ch" is 1~3 for corresponding channel, or 0 for all; "vol" is 0~15 (0=OFF, 15=MAX)
3578+ 2A49 CD 23 29     VOLUME: call    GETINT          ; get integer 0-255 (recover channel)
3579+ 2A4C FE 04                cp      $04             ; check if it's in the range 0~3
3580+ 2A4E D2 D7 1C             jp      NC,FCERR        ; if not, exit with Illegal function call error
3581+ 2A51 32 22 53             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3582+ 2A54 CD C3 19             call    CHKSYN          ; Make sure ',' follows
3583+ 2A57 2C                   defb    ','
3584+ 2A58 CD 23 29             call    GETINT          ; get integer 0-255 (recover channel)
3585+ 2A5B FE 10                cp      $10             ; check if it's in the range 0~15
3586+ 2A5D D2 D7 1C             jp      NC,FCERR        ; if not, exit with Illegal funcion call
3587+ 2A60 57                   ld      D,A             ; store volume into D
3588+ 2A61 3A 22 53             ld      A,(TMPBFR1)     ; retrieve channel
3589+ 2A64 A7                   and     A               ; is it 0? (0=every channel)
3590+ 2A65 20 10                jr      NZ,VOLCH        ; no, jump over
3591+ 2A67 06 03                ld      B,$03           ; yes, set every channel
3592+ 2A69 1E 08                ld      E,$08           ; register volume of first channel
3593+ 2A6B 0E 40        RPVOLCG:ld      C,PSG_REG       ; PSG register port
3594+ 2A6D ED 59                out     (C),E           ; set register #
3595+ 2A6F 0E 41                ld      C,PSG_DAT       ; PSG data port
3596+ 2A71 ED 51                out     (C),D           ; send volume
3597+ 2A73 1C                   inc     E               ; next register
3598+ 2A74 10 F5                djnz    RPVOLCG         ; repeat for each channel
3599+ 2A76 C9                   ret                     ; return to caller
3600+ 2A77 0E 40        VOLCH:  ld      C,PSG_REG       ; PSG register port
3601+ 2A79 C6 07                add     $07             ; add 7 to A so that we have the correct register (1->8, 2->9, 3->10)
3602+ 2A7B ED 79                out     (C),A           ; set register
3603+ 2A7D 0E 41                ld      C,PSG_DAT       ; PSG data port
3604+ 2A7F ED 51                out     (C),D           ; send volume level
3605+ 2A81 C9                   ret                     ; return to caller
3606+ 2A82
3607+ 2A82              ; SOUND ch,tone,dur
3608+ 2A82              ; play a tone or noise of "tone" frequency from selected channel "ch" for duration "dur"
3609+ 2A82              ; "ch" is 1~6 (0=means sound OFF,1~3 for tone, 4~6 for noise) / "tone" is 1~4,095 (0=means no tone) /
3610+ 2A82              ; "dur" is 1~16383 h.o.s.,0.001~163s (0=means non-stop tone)
3611+ 2A82 CD 23 29     SOUND:  call    GETINT          ; get integer 0-255 (recover channel)
3612+ 2A85 A7                   and     A               ; is it zero?
3613+ 2A86 20 08                jr      NZ,CTSNDC       ; no, continue with checking of params
3614+ 2A88 E5                   push    HL              ; store HL
3615+ 2A89 F3                   di                      ; disable INTs
3616+ 2A8A CD 85 0C             call    CLRPSGREGS      ; yes, it's zero, so reset PSG registers to shut down every sound
3617+ 2A8D FB                   ei                      ; re-enable INTs
3618+ 2A8E E1                   pop     HL              ; retrieve HL
3619+ 2A8F C9                   ret                     ; return to caller
3620+ 2A90 32 22 53     CTSNDC: ld      (TMPBFR1),A     ; no, continue by storing A into a temp. buffer
3621+ 2A93 FE 04                cp      $04             ; is channel >3?
3622+ 2A95 D2 14 2B             jp      NC,NOISUP       ; Yes - check to see if it's a noise channel
3623+ 2A98 CD C3 19             call    CHKSYN          ; No, continue checking by making sure ',' follows
3624+ 2A9B 2C                   defb    ','
3625+ 2A9C CD 9D 20             call    GETNUM          ; Get tone frequency
3626+ 2A9F CD C2 1C             call    DEINT           ; Get integer -32768 to 32767
3627+ 2AA2 ED 53 24 53          ld      (TMPBFR2),DE    ; Store frequency
3628+ 2AA6 CD C3 19             call    CHKSYN          ; Make sure ',' follows
3629+ 2AA9 2C                   defb    ','
3630+ 2AAA CD 9D 20             call    GETNUM          ; Get duration
3631+ 2AAD CD C2 1C             call    DEINT           ; Get integer -32768 to 32767
3632+ 2AB0 ED 53 26 53          ld      (TMPBFR3),DE    ; Store duration
3633+ 2AB4                                              ; CHECK CHANNEL
3634+ 2AB4 3A 22 53             ld      A,(TMPBFR1)     ; recover channel
3635+ 2AB7 FE 01                cp      $01             ; is channel <1?
3636+ 2AB9 DA D7 1C             jp      C,FCERR         ; Yes - Illegal function call error
3637+ 2ABC                                              ; CHECK FREQUENCY
3638+ 2ABC ED 5B 24 53          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3639+ 2AC0 7A                   ld      A,D             ; move D into A and check if it is in the range 0~4095...
3640+ 2AC1 FE 10                cp      $10             ; ...so D must not be greater than $0F (15)
3641+ 2AC3 D2 D7 1C             jp      NC,FCERR        ; if not in the range, exit with an Illegal function call error
3642+ 2AC6                                              ; CHECK DURATION
3643+ 2AC6 ED 5B 26 53          ld      DE,(TMPBFR3)    ; restore duration from temp buffer
3644+ 2ACA 7A                   ld      A,D             ; check if it is in the range 0~16383...
3645+ 2ACB E6 C0                and     $C0             ; ...(15th & 14th bits must not be set)
3646+ 2ACD C2 D7 1C             jp      NZ,FCERR        ; if not in the range, exit with an Illegal function call error
3647+ 2AD0                                              ;
3648+ 2AD0                                              ; SET TONE:
3649+ 2AD0                                              ; let's start by setting up the channel
3650+ 2AD0 3A 22 53             ld      A,(TMPBFR1)     ; restore channel value
3651+ 2AD3 FE 03                cp      $03             ; is it 3?
3652+ 2AD5 20 02                jr      NZ,SND1         ; no, jump over
3653+ 2AD7 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3654+ 2AD9 2F           SND1:   cpl                     ; complement of A - this is used later to set on the channel into the mixer
3655+ 2ADA CD 61 2B             call    WRTSND          ; enable line into mixer of channel stored in A
3656+ 2ADD                                              ; SET FREQUENCY
3657+ 2ADD                                              ; we simply get frequency and subtract from 4096. The result
3658+ 2ADD                                              ; is put into register pair of the corresponding freq tone channel
3659+ 2ADD ED 5B 24 53          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3660+ 2AE1 E5                   push    HL              ; store HL (it will be used by the subroutine)
3661+ 2AE2 21 00 10             ld      HL,$1000        ; load 4096 into HL
3662+ 2AE5 A7                   and     A               ; reset C flag
3663+ 2AE6 ED 52                sbc     HL,DE           ; subtract freq from HL - now the frequency is inverted, so we will send the low as high and vice-versa
3664+ 2AE8 3A 22 53             ld      A,(TMPBFR1)     ; restore channel value
3665+ 2AEB 3D                   dec     A               ; set A into the range 0~2
3666+ 2AEC 87                   add     A,A             ; double A to find the register pair that correspond to the channel (A->0,1 / B->2,3, C->4,5)
3667+ 2AED 0E 40                ld      C,PSG_REG       ; PSG register port
3668+ 2AEF ED 79                out     (C),A           ; select first register of the pair
3669+ 2AF1 0E 41                ld      C,PSG_DAT       ; PSG data port
3670+ 2AF3 ED 69                out     (C),L           ; send high byte
3671+ 2AF5 0E 40                ld      C,PSG_REG       ; PSG register support
3672+ 2AF7 3C                   inc     A               ; second register of the pair
3673+ 2AF8 ED 79                out     (C),A           ; select register
3674+ 2AFA 0E 41                ld      C,PSG_DAT       ; PSG data port
3675+ 2AFC ED 61                out     (C),H           ; send low byte
3676+ 2AFE ED 5B 26 53          ld      DE,(TMPBFR3)    ; recover duration
3677+ 2B02 3A 22 53             ld      A,(TMPBFR1)     ; recover channel value
3678+ 2B05 3D                   dec     A               ; set channel into the range 0~2
3679+ 2B06 87                   add     A,A             ; double A to find the correct offset
3680+ 2B07 21 56 53             ld      HL,CHASNDDTN    ; set duration into...
3681+ 2B0A 85                   add     A,L             ; ...the proper...
3682+ 2B0B 30 01                jr      NC,SNDOVR       ; (is there a rest? no, jump over
3683+ 2B0D 24                   inc     H               ; yes, increment H)
3684+ 2B0E 6F           SNDOVR: ld      L,A             ; ...register pair...
3685+ 2B0F 73                   ld      (HL),E          ; ...and store the value
3686+ 2B10 23                   inc     HL
3687+ 2B11 72                   ld      (HL),D
3688+ 2B12 E1                   pop     HL              ; retrieve HL
3689+ 2B13 C9                   ret                     ; Return to caller
3690+ 2B14 FE 07        NOISUP: cp      $07             ; is channel in range 4 to 6 (for a noise)?
3691+ 2B16 D2 D7 1C             jp      NC,FCERR        ; no, so ILLEGAL FUNCTION CALL
3692+ 2B19 CD C3 19             call    CHKSYN          ; yes, continue checking by making sure ',' follows
3693+ 2B1C 2C                   defb    ','
3694+ 2B1D CD 23 29             call    GETINT          ; get integer 0-255 (frequency)
3695+ 2B20 FE 20                cp      $20             ; make sure it's in range 0~31
3696+ 2B22 D2 D7 1C             jp      NC,FCERR        ; no, so Illegal function call
3697+ 2B25 32 24 53             ld      (TMPBFR2),A     ; store freq.
3698+ 2B28 2B                   dec     HL              ; dec 'cos GETCHR INCs
3699+ 2B29 CD 0C 1C             call    GETCHR          ; check that nothing follows
3700+ 2B2C C2 C9 16             jp      NZ,SNERR        ; error if no empty line
3701+ 2B2F 3A 24 53             ld      A,(TMPBFR2)     ; retrieve freq.
3702+ 2B32 5F                   ld      E,A             ; store freq into E
3703+ 2B33 3A 22 53             ld      A,(TMPBFR1)     ; retrieve channel
3704+ 2B36 D6 03                sub     $03             ; subtract 3 to get channel in range 1~3
3705+ 2B38 FE 03                cp      $03             ; is it 3?
3706+ 2B3A 20 02                jr      NZ,NOS1         ; no, jump over
3707+ 2B3C 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3708+ 2B3E 87           NOS1:   add     A,A
3709+ 2B3F 87                   add     A,A
3710+ 2B40 87                   add     A,A             ; let's move A 3 bits to left
3711+ 2B41 47                   ld      B,A             ; store channel into B
3712+ 2B42 7B                   ld      A,E             ; check if
3713+ 2B43 A7                   and     A               ; freq is 0 (means that noise reproduction must be halted)
3714+ 2B44 F3                   di                      ; disable INts
3715+ 2B45 20 0A                jr      NZ,NOS2         ; no, so jump over
3716+ 2B47 3E 07                ld      A,$07           ; mixer register
3717+ 2B49 CD D3 0C             call    SETSNDREG       ; set mixer register
3718+ 2B4C ED 78                in      A,(C)           ; load current mixer value
3719+ 2B4E B0                   or      B               ; disable noise
3720+ 2B4F 18 19                jr      NOS3            ; continue over
3721+ 2B51 78           NOS2:   ld      A,B             ; recover channel
3722+ 2B52 2F                   cpl                     ; complement of A - this is used to set on the channel into the mixer
3723+ 2B53 CD 61 2B             call    WRTSND          ; enable line into mixer of channel stored in A
3724+ 2B56 3E 06                ld      A,$06           ; write into noise register
3725+ 2B58 CD D3 0C             call    SETSNDREG       ; set register into PSG
3726+ 2B5B 7B                   ld      A,E             ; load value for noise frequency
3727+ 2B5C CD D8 0C             call    WRTSNDREG       ; write data into register $06
3728+ 2B5F FB                   ei                      ; re-enable INTs
3729+ 2B60 C9                   ret
3730+ 2B61                      ; enable line into mixer of channel stored in A
3731+ 2B61 47           WRTSND: ld      B,A             ; move channel into B
3732+ 2B62 3E 07                ld      A,$07           ; mixer register
3733+ 2B64 CD D3 0C             call    SETSNDREG       ; set mixer register
3734+ 2B67 ED 78                in      A,(C)           ; load current value
3735+ 2B69 A0                   and     B               ; set on the channel into the mixer (remember that 0=ON)
3736+ 2B6A                                              ; example: if channel is A (1), complement of 1 is 254 (11111110). So, 255 (in case
3737+ 2B6A                                              ; the register is still unchanged after reset) is 11111111 and
3738+ 2B6A                                              ; 11111111 AND 11111110 is equal to 11111110
3739+ 2B6A                                              ; 11111001 AND 11111110 is equal to 11111000 (in case channels B & C are ON)
3740+ 2B6A 47           NOS3:   ld      B,A             ; store new mixer value into B
3741+ 2B6B 3E 07                ld      A,$07           ; mixer address
3742+ 2B6D CD D3 0C             call    SETSNDREG       ; set register
3743+ 2B70 78                   ld      A,B             ; retrieve new mixer value from B
3744+ 2B71 CD D8 0C             call    WRTSNDREG       ; send new value for the mixer
3745+ 2B74 FB                   ei                      ; re-enable INTs
3746+ 2B75 C9                   ret                     ; return to caller
3747+ 2B76
3748+ 2B76              ; write a byte into one of the VDP registers
3749+ 2B76 CD 23 29     VREG:   call    GETINT          ; Get register number back into A
3750+ 2B79 FE 08                cp      $08             ; check if value is equal or greater than 8 (VDP registers are only 8, from 0 to 7)
3751+ 2B7B D2 D7 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3752+ 2B7E 32 22 53             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3753+ 2B81 CD C3 19             call    CHKSYN          ; Make sure ',' follows
3754+ 2B84 2C                   defb    ','
3755+ 2B85 CD 23 29             call    GETINT          ; get value (0-255)
3756+ 2B88 5F                   ld      E,A             ; store value into E
3757+ 2B89 3A 22 53             ld      A,(TMPBFR1)     ; recover VDP register and store into A
3758+ 2B8C F3                   di                      ; disable INTs
3759+ 2B8D CD A4 06             call    WRITE_VREG      ; write value into VDP register
3760+ 2B90 FB                   ei                      ; re-enable INTs
3761+ 2B91 C9                   ret                     ; return to caller
3762+ 2B92
3763+ 2B92              ; read the VDP status register and return it into A
3764+ 2B92 CD C2 1C     VSTAT:  call    DEINT           ; Get integer -32768 to 32767 (Note: we do NOT use it)
3765+ 2B95 F3                   di                      ; disable INTs
3766+ 2B96 CD AF 06             call    READ_VSTAT      ; read VDP register status
3767+ 2B99 FB                   ei                      ; re-enable INTs
3768+ 2B9A C3 96 24             jp      PASSA           ; Return integer A
3769+ 2B9D
3770+ 2B9D              ; read from PSG register and return it into A
3771+ 2B9D CD C2 1C     SSTAT:  call    DEINT           ; get integer -32768 to 32767
3772+ 2BA0 7B                   ld      A,E             ; consider LSB
3773+ 2BA1 FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3774+ 2BA3 D2 D7 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3775+ 2BA6 F3                   di                      ; disable INts
3776+ 2BA7 0E 40                ld      C,PSG_REG       ; output port to set PSG register
3777+ 2BA9 ED 79                out     (C),A           ; send register to read from
3778+ 2BAB ED 78                in      A,(C)           ; read register's contents and store into A
3779+ 2BAD FB                   ei                      ; re-enable INTs
3780+ 2BAE C3 96 24             jp      PASSA           ; return A
3781+ 2BB1
3782+ 2BB1              ; read the temp key buffer and return the value of the current key being pressed
3783+ 2BB1              ; can wait for the number of 100thds of second before to return
3784+ 2BB1 CD 10 25     INKEY:  call    IDTEST          ; Test for illegal direct
3785+ 2BB4 CD C2 1C             call    DEINT           ; get number param (100thds of second to wait) into DE
3786+ 2BB7 C5                   push    BC              ; store BC
3787+ 2BB8 3A 02 53             ld      A,(TMRCNT)      ; Load current value of system timer
3788+ 2BBB 47                   ld      B,A             ; move it into B
3789+ 2BBC 3A 02 53     CMP_A:  ld      A,(TMRCNT)      ; make a little delay of 1/100 sec...
3790+ 2BBF B8                   cp      B               ; ...to let the sniffer collect...
3791+ 2BC0 20 FA                jr      NZ,CMP_A        ; ...at least 1 char before to continue
3792+ 2BC2 7A                   ld      A,D             ; check the param
3793+ 2BC3 B3                   or      E               ; if DE<>0 then...
3794+ 2BC4 20 05                jr      NZ,INKEY2       ; ...jump over...
3795+ 2BC6 3A 5E 53             ld      A,(TMPKEYBFR)   ; ...else read the buffer and...
3796+ 2BC9 18 2A                jr      ENDINK          ; ...return it
3797+ 2BCB 7A           INKEY2: ld      A,D             ; check if param>1023
3798+ 2BCC FE 04                cp      $04             ; to do this we check if MSB>3
3799+ 2BCE D2 D7 1C             jp      NC,FCERR        ; if MSB >=4 then error
3800+ 2BD1 E5                   push    HL              ; store HL
3801+ 2BD2 21 09 00             ld      HL,$0009        ; check if value
3802+ 2BD5 CD DE 3F             call    CMP16           ; is < 10
3803+ 2BD8 E1                   pop     HL              ; retrieve HL
3804+ 2BD9 DA DF 2B             jp      C,SRTINK        ; if value >= 10 then jump over
3805+ 2BDC 11 0A 00             ld      DE,$000A        ; else, use 10 (no intervals shorter than 10/100s)
3806+ 2BDF 3A 02 53     SRTINK: ld      A,(TMRCNT)      ; Load the first byte of the system timer
3807+ 2BE2 47                   ld      B,A             ; move it into B
3808+ 2BE3 3A 5E 53     CHKINK: ld      A,(TMPKEYBFR)   ; load char code from buffer
3809+ 2BE6 A7                   and     A               ; is it 0?
3810+ 2BE7 20 0C                jr      NZ,ENDINK       ; no, so we can return it
3811+ 2BE9 3A 02 53             ld      A,(TMRCNT)      ; load the first byte of the system timer
3812+ 2BEC B8                   cp      B               ; is it the same value?
3813+ 2BED 28 F4                jr      Z,CHKINK        ; yes, so read again
3814+ 2BEF 47                   ld      B,A             ; store new value
3815+ 2BF0 1B                   dec     DE              ; no, decrement timer
3816+ 2BF1 7A                   ld      A,D             ; check if zero reached
3817+ 2BF2 B3                   or      E               ; by ORing D and E
3818+ 2BF3 20 EE                jr      NZ,CHKINK       ; if not 0, repeat
3819+ 2BF5 C1           ENDINK: pop     BC              ; restore BC
3820+ 2BF6 F5                   push    AF              ; store A
3821+ 2BF7 F3                   di                      ; disable INTs
3822+ 2BF8 AF                   xor     A               ; clear the...
3823+ 2BF9 32 5E 53             ld      (TMPKEYBFR),A   ; ...TMP KEY buffer for the next read
3824+ 2BFC FB                   ei                      ; re-enable INTs
3825+ 2BFD F1                   pop     AF              ; retrieve A
3826+ 2BFE C3 96 24     ENDINK2:jp      PASSA           ; return A as ASCII value
3827+ 2C01
3828+ 2C01
3829+ 2C01 21 28 31     ROUND:  ld      HL,HALF         ; Add 0.5 to FPREG
3830+ 2C04 CD F9 2E     ADDPHL: call    LOADFP          ; Load FP at (HL) to BCDE
3831+ 2C07 C3 13 2C             jp      FPADD           ; Add BCDE to FPREG
3832+ 2C0A
3833+ 2C0A
3834+ 2C0A CD F9 2E     SUBPHL: call    LOADFP          ; FPREG = -FPREG + number at HL
3835+ 2C0D 21                   defb    $21             ; Skip "pop BC" and "pop DE"
3836+ 2C0E C1           PSUB:   pop     BC              ; Get FP number from stack
3837+ 2C0F D1                   pop     DE
3838+ 2C10 CD D3 2E     SUBCDE: call    INVSGN          ; Negate FPREG
3839+ 2C13 78           FPADD:  ld      A,B             ; Get FP exponent
3840+ 2C14 B7                   or      A               ; Is number zero?
3841+ 2C15 C8                   ret     Z               ; Yes - Nothing to add
3842+ 2C16 3A 79 53             ld      A,(FPEXP)       ; Get FPREG exponent
3843+ 2C19 B7                   or      A               ; Is this number zero?
3844+ 2C1A CA EB 2E             jp      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3845+ 2C1D 90                   sub     B               ; BCDE number larger?
3846+ 2C1E D2 2D 2C             jp      NC,NOSWAP       ; No - Don't swap them
3847+ 2C21 2F                   cpl                     ; Two's complement
3848+ 2C22 3C                   inc     A               ;  FP exponent
3849+ 2C23 EB                   ex      DE,HL
3850+ 2C24 CD DB 2E             call    STAKFP          ; Put FPREG on stack
3851+ 2C27 EB                   ex      DE,HL
3852+ 2C28 CD EB 2E             call    FPBCDE          ; Move BCDE to FPREG
3853+ 2C2B C1                   pop     BC              ; Restore number from stack
3854+ 2C2C D1                   pop     DE
3855+ 2C2D FE 19        NOSWAP: cp      24+1            ; Second number insignificant?
3856+ 2C2F D0                   ret     NC              ; Yes - First number is result
3857+ 2C30 F5                   push    AF              ; Save number of bits to scale
3858+ 2C31 CD 10 2F             call    SIGNS           ; Set MSBs & sign of result
3859+ 2C34 67                   ld      H,A             ; Save sign of result
3860+ 2C35 F1                   pop     AF              ; Restore scaling factor
3861+ 2C36 CD D8 2C             call    SCALE           ; Scale BCDE to same exponent
3862+ 2C39 B4                   or      H               ; Result to be positive?
3863+ 2C3A 21 76 53             ld      HL,FPREG        ; Point to FPREG
3864+ 2C3D F2 53 2C             jp      P,MINCDE        ; No - Subtract FPREG from CDE
3865+ 2C40 CD B8 2C             call    PLUCDE          ; Add FPREG to CDE
3866+ 2C43 D2 99 2C             jp      NC,RONDUP       ; No overflow - Round it up
3867+ 2C46 23                   inc     HL              ; Point to exponent
3868+ 2C47 34                   inc     (HL)            ; Increment it
3869+ 2C48 CA D8 16             jp      Z,OVERR         ; Number overflowed - Error
3870+ 2C4B 2E 01                ld      L,$01           ; 1 bit to shift right
3871+ 2C4D CD EE 2C             call    SHRT1           ; Shift result right
3872+ 2C50 C3 99 2C             jp      RONDUP          ; Round it up
3873+ 2C53
3874+ 2C53 AF           MINCDE: xor     A               ; Clear A and carry
3875+ 2C54 90                   sub     B               ; Negate exponent
3876+ 2C55 47                   ld      B,A             ; Re-save exponent
3877+ 2C56 7E                   ld      A,(HL)          ; Get LSB of FPREG
3878+ 2C57 9B                   sbc     A, E            ; Subtract LSB of BCDE
3879+ 2C58 5F                   ld      E,A             ; Save LSB of BCDE
3880+ 2C59 23                   inc     HL
3881+ 2C5A 7E                   ld      A,(HL)          ; Get NMSB of FPREG
3882+ 2C5B 9A                   sbc     A,D             ; Subtract NMSB of BCDE
3883+ 2C5C 57                   ld      D,A             ; Save NMSB of BCDE
3884+ 2C5D 23                   inc     HL
3885+ 2C5E 7E                   ld      A,(HL)          ; Get MSB of FPREG
3886+ 2C5F 99                   sbc     A,C             ; Subtract MSB of BCDE
3887+ 2C60 4F                   ld      C,A             ; Save MSB of BCDE
3888+ 2C61 DC C4 2C     CONPOS: call    C,COMPL         ; Overflow - Make it positive
3889+ 2C64
3890+ 2C64 68           BNORM:  ld      L,B             ; L = Exponent
3891+ 2C65 63                   ld      H,E             ; H = LSB
3892+ 2C66 AF                   xor     A
3893+ 2C67 47           BNRMLP: ld      B,A             ; Save bit count
3894+ 2C68 79                   ld      A,C             ; Get MSB
3895+ 2C69 B7                   or      A               ; Is it zero?
3896+ 2C6A C2 86 2C             jp      NZ,PNORM        ; No - Do it bit at a time
3897+ 2C6D 4A                   ld      C,D             ; MSB = NMSB
3898+ 2C6E 54                   ld      D,H             ; NMSB= LSB
3899+ 2C6F 65                   ld      H,L             ; LSB = VLSB
3900+ 2C70 6F                   ld      L,A             ; VLSB= 0
3901+ 2C71 78                   ld      A,B             ; Get exponent
3902+ 2C72 D6 08                sub     $08             ; Count 8 bits
3903+ 2C74 FE E0                cp      -24-8           ; Was number zero?
3904+ 2C76 C2 67 2C             jp      NZ,BNRMLP       ; No - Keep normalising
3905+ 2C79 AF           RESZER: xor     A               ; Result is zero
3906+ 2C7A 32 79 53     SAVEXP: ld      (FPEXP),A       ; Save result as zero
3907+ 2C7D C9                   ret
3908+ 2C7E
3909+ 2C7E 05           NORMAL: dec     B               ; Count bits
3910+ 2C7F 29                   add     HL,HL           ; Shift HL left
3911+ 2C80 7A                   ld      A,D             ; Get NMSB
3912+ 2C81 17                   rla                     ; Shift left with last bit
3913+ 2C82 57                   ld      D,A             ; Save NMSB
3914+ 2C83 79                   ld      A,C             ; Get MSB
3915+ 2C84 8F                   adc     A,A             ; Shift left with last bit
3916+ 2C85 4F                   ld      C,A             ; Save MSB
3917+ 2C86 F2 7E 2C     PNORM:  jp      P,NORMAL        ; Not done - Keep going
3918+ 2C89 78                   ld      A,B             ; Number of bits shifted
3919+ 2C8A 5C                   ld      E,H             ; Save HL in EB
3920+ 2C8B 45                   ld      B,L
3921+ 2C8C B7                   or      A               ; Any shifting done?
3922+ 2C8D CA 99 2C             jp      Z,RONDUP        ; No - Round it up
3923+ 2C90 21 79 53             ld      HL,FPEXP        ; Point to exponent
3924+ 2C93 86                   add     A,(HL)          ; Add shifted bits
3925+ 2C94 77                   ld      (HL),A          ; Re-save exponent
3926+ 2C95 D2 79 2C             jp      NC,RESZER       ; Underflow - Result is zero
3927+ 2C98 C8                   ret     Z               ; Result is zero
3928+ 2C99 78           RONDUP: ld      A,B             ; Get VLSB of number
3929+ 2C9A 21 79 53     RONDB:  ld      HL,FPEXP        ; Point to exponent
3930+ 2C9D B7                   or      A               ; Any rounding?
3931+ 2C9E FC AB 2C             call    M,FPROND        ; Yes - Round number up
3932+ 2CA1 46                   ld      B,(HL)          ; B = Exponent
3933+ 2CA2 23                   inc     HL
3934+ 2CA3 7E                   ld      A,(HL)          ; Get sign of result
3935+ 2CA4 E6 80                and     %10000000       ; Only bit 7 needed
3936+ 2CA6 A9                   xor     C               ; Set correct sign
3937+ 2CA7 4F                   ld      C,A             ; Save correct sign in number
3938+ 2CA8 C3 EB 2E             jp      FPBCDE          ; Move BCDE to FPREG
3939+ 2CAB
3940+ 2CAB 1C           FPROND: inc     E               ; Round LSB
3941+ 2CAC C0                   ret     NZ              ; Return if ok
3942+ 2CAD 14                   inc     D               ; Round NMSB
3943+ 2CAE C0                   ret     NZ              ; Return if ok
3944+ 2CAF 0C                   inc     C               ; Round MSB
3945+ 2CB0 C0                   ret     NZ              ; Return if ok
3946+ 2CB1 0E 80                ld      C,$80           ; Set normal value
3947+ 2CB3 34                   inc     (HL)            ; Increment exponent
3948+ 2CB4 C0                   ret     NZ              ; Return if ok
3949+ 2CB5 C3 D8 16             jp      OVERR           ; Overflow error
3950+ 2CB8
3951+ 2CB8 7E           PLUCDE: ld      A,(HL)          ; Get LSB of FPREG
3952+ 2CB9 83                   add     A,E             ; Add LSB of BCDE
3953+ 2CBA 5F                   ld      E,A             ; Save LSB of BCDE
3954+ 2CBB 23                   inc     HL
3955+ 2CBC 7E                   ld      A,(HL)          ; Get NMSB of FPREG
3956+ 2CBD 8A                   adc     A,D             ; Add NMSB of BCDE
3957+ 2CBE 57                   ld      D,A             ; Save NMSB of BCDE
3958+ 2CBF 23                   inc     HL
3959+ 2CC0 7E                   ld      A,(HL)          ; Get MSB of FPREG
3960+ 2CC1 89                   adc     A,C             ; Add MSB of BCDE
3961+ 2CC2 4F                   ld      C,A             ; Save MSB of BCDE
3962+ 2CC3 C9                   ret
3963+ 2CC4
3964+ 2CC4 21 7A 53     COMPL:  ld      HL,SGNRES       ; Sign of result
3965+ 2CC7 7E                   ld      A,(HL)          ; Get sign of result
3966+ 2CC8 2F                   cpl                     ; Negate it
3967+ 2CC9 77                   ld      (HL),A          ; Put it back
3968+ 2CCA AF                   xor     A
3969+ 2CCB 6F                   ld      L,A             ; Set L to zero
3970+ 2CCC 90                   sub     B               ; Negate exponent,set carry
3971+ 2CCD 47                   ld      B,A             ; Re-save exponent
3972+ 2CCE 7D                   ld      A,L             ; Load zero
3973+ 2CCF 9B                   sbc     A,E             ; Negate LSB
3974+ 2CD0 5F                   ld      E,A             ; Re-save LSB
3975+ 2CD1 7D                   ld      A,L             ; Load zero
3976+ 2CD2 9A                   sbc     A,D             ; Negate NMSB
3977+ 2CD3 57                   ld      D,A             ; Re-save NMSB
3978+ 2CD4 7D                   ld      A,L             ; Load zero
3979+ 2CD5 99                   sbc     A,C             ; Negate MSB
3980+ 2CD6 4F                   ld      C,A             ; Re-save MSB
3981+ 2CD7 C9                   ret
3982+ 2CD8
3983+ 2CD8 06 00        SCALE:  ld      B,$00           ; Clear underflow
3984+ 2CDA D6 08        SCALLP: sub     $08             ; 8 bits (a whole byte)?
3985+ 2CDC DA E7 2C             jp      C,SHRITE        ; No - Shift right A bits
3986+ 2CDF 43                   ld      B,E             ; <- Shift
3987+ 2CE0 5A                   ld      E,D             ; <- right
3988+ 2CE1 51                   ld      D,C             ; <- eight
3989+ 2CE2 0E 00                ld      C,$00           ; <- bits
3990+ 2CE4 C3 DA 2C             jp      SCALLP          ; More bits to shift
3991+ 2CE7
3992+ 2CE7 C6 09        SHRITE: add     A,8+1           ; Adjust count
3993+ 2CE9 6F                   ld      L,A             ; Save bits to shift
3994+ 2CEA AF           SHRLP:  xor     A               ; Flag for all done
3995+ 2CEB 2D                   dec     L               ; All shifting done?
3996+ 2CEC C8                   ret     Z               ; Yes - Return
3997+ 2CED 79                   ld      A,C             ; Get MSB
3998+ 2CEE 1F           SHRT1:  rra                     ; Shift it right
3999+ 2CEF 4F                   ld      C,A             ; Re-save
4000+ 2CF0 7A                   ld      A,D             ; Get NMSB
4001+ 2CF1 1F                   rra                     ; Shift right with last bit
4002+ 2CF2 57                   ld      D,A             ; Re-save it
4003+ 2CF3 7B                   ld      A,E             ; Get LSB
4004+ 2CF4 1F                   rra                     ; Shift right with last bit
4005+ 2CF5 5F                   ld      E,A             ; Re-save it
4006+ 2CF6 78                   ld      A,B             ; Get underflow
4007+ 2CF7 1F                   rra                     ; Shift right with last bit
4008+ 2CF8 47                   ld      B,A             ; Re-save underflow
4009+ 2CF9 C3 EA 2C             jp      SHRLP           ; More bits to do
4010+ 2CFC
4011+ 2CFC 00 00 00 81  UNITY:  defb    $00,$00,$00,$81 ; 1.00000
4012+ 2D00
4013+ 2D00 03           LOGTAB: defb    $03             ; Table used by LOG
4014+ 2D01 AA 56 19 80          defb    $AA,$56,$19,$80 ; 0.59898
4015+ 2D05 F1 22 76 80          defb    $F1,$22,$76,$80 ; 0.96147
4016+ 2D09 45 AA 38 82          defb    $45,$AA,$38,$82 ; 2.88539
4017+ 2D0D
4018+ 2D0D CD AA 2E     LOG:    call    TSTSGN          ; Test sign of value
4019+ 2D10 B7                   or      A
4020+ 2D11 EA D7 1C             jp      PE,FCERR        ; ?FC Error if <= zero
4021+ 2D14 21 79 53             ld      HL,FPEXP        ; Point to exponent
4022+ 2D17 7E                   ld      A,(HL)          ; Get exponent
4023+ 2D18 01 35 80             ld      BC,$8035        ; BCDE = SQR(1/2)
4024+ 2D1B 11 F3 04             ld      DE,$04F3
4025+ 2D1E 90                   sub     B               ; Scale value to be < 1
4026+ 2D1F F5                   push    AF              ; Save scale factor
4027+ 2D20 70                   ld      (HL),B          ; Save new exponent
4028+ 2D21 D5                   push    DE              ; Save SQR(1/2)
4029+ 2D22 C5                   push    BC
4030+ 2D23 CD 13 2C             call    FPADD           ; Add SQR(1/2) to value
4031+ 2D26 C1                   pop     BC              ; Restore SQR(1/2)
4032+ 2D27 D1                   pop     DE
4033+ 2D28 04                   inc     B               ; Make it SQR(2)
4034+ 2D29 CD 00 2E             call    DVBCDE          ; Divide by SQR(2)
4035+ 2D2C 21 FC 2C             ld      HL,UNITY        ; Point to 1.
4036+ 2D2F CD 0A 2C             call    SUBPHL          ; Subtract FPREG from 1
4037+ 2D32 21 00 2D             ld      HL,LOGTAB       ; Coefficient table
4038+ 2D35 CD F2 31             call    SUMSER          ; Evaluate sum of series
4039+ 2D38 01 80 80             ld      BC,$8080        ; BCDE = -0.5
4040+ 2D3B 11 00 00             ld      DE,$0000
4041+ 2D3E CD 13 2C             call    FPADD           ; Subtract 0.5 from FPREG
4042+ 2D41 F1                   pop     AF              ; Restore scale factor
4043+ 2D42 CD 25 30             call    RSCALE          ; Re-scale number
4044+ 2D45 01 31 80     MULLN2: ld      BC,$8031        ; BCDE = Ln(2)
4045+ 2D48 11 18 72             ld      DE,$7218
4046+ 2D4B 21                   defb    $21             ; Skip "pop BC" and "pop DE"
4047+ 2D4C
4048+ 2D4C C1           MULT:   pop     BC              ; Get number from stack
4049+ 2D4D D1                   pop     DE
4050+ 2D4E CD AA 2E     FPMULT: call    TSTSGN          ; Test sign of FPREG
4051+ 2D51 C8                   ret     Z               ; Return zero if zero
4052+ 2D52 2E 00                ld      L,$00           ; Flag add exponents
4053+ 2D54 CD 68 2E             call    ADDEXP          ; Add exponents
4054+ 2D57 79                   ld      A,C             ; Get MSB of multiplier
4055+ 2D58 32 88 53             ld      (MULVAL),A      ; Save MSB of multiplier
4056+ 2D5B EB                   ex      DE,HL
4057+ 2D5C 22 89 53             ld      (MULVAL+1),HL   ; Save rest of multiplier
4058+ 2D5F 01 00 00             ld      BC,$0000        ; Partial product (BCDE) = zero
4059+ 2D62 50                   ld      D,B
4060+ 2D63 58                   ld      E,B
4061+ 2D64 21 64 2C             ld      HL,BNORM        ; Address of normalise
4062+ 2D67 E5                   push    HL              ; Save for return
4063+ 2D68 21 70 2D             ld      HL,MULT8        ; Address of 8 bit multiply
4064+ 2D6B E5                   push    HL              ; Save for NMSB,MSB
4065+ 2D6C E5                   push    HL              ;
4066+ 2D6D 21 76 53             ld      HL,FPREG        ; Point to number
4067+ 2D70 7E           MULT8:  ld      A,(HL)          ; Get LSB of number
4068+ 2D71 23                   inc     HL              ; Point to NMSB
4069+ 2D72 B7                   or      A               ; Test LSB
4070+ 2D73 CA 9C 2D             jp      Z,BYTSFT        ; Zero - shift to next byte
4071+ 2D76 E5                   push    HL              ; Save address of number
4072+ 2D77 2E 08                ld      L,$08           ; 8 bits to multiply by
4073+ 2D79 1F           MUL8LP: rra                     ; Shift LSB right
4074+ 2D7A 67                   ld      H,A             ; Save LSB
4075+ 2D7B 79                   ld      A,C             ; Get MSB
4076+ 2D7C D2 8A 2D             jp      NC,NOMADD       ; Bit was zero - Don't add
4077+ 2D7F E5                   push    HL              ; Save LSB and count
4078+ 2D80 2A 89 53             ld      HL,(MULVAL+1)   ; Get LSB and NMSB
4079+ 2D83 19                   add     HL,DE           ; Add NMSB and LSB
4080+ 2D84 EB                   ex      DE,HL           ; Leave sum in DE
4081+ 2D85 E1                   pop     HL              ; Restore MSB and count
4082+ 2D86 3A 88 53             ld      A,(MULVAL)      ; Get MSB of multiplier
4083+ 2D89 89                   adc     A,C             ; Add MSB
4084+ 2D8A 1F           NOMADD: rra                     ; Shift MSB right
4085+ 2D8B 4F                   ld      C,A             ; Re-save MSB
4086+ 2D8C 7A                   ld      A,D             ; Get NMSB
4087+ 2D8D 1F                   rra                     ; Shift NMSB right
4088+ 2D8E 57                   ld      D,A             ; Re-save NMSB
4089+ 2D8F 7B                   ld      A,E             ; Get LSB
4090+ 2D90 1F                   rra                     ; Shift LSB right
4091+ 2D91 5F                   ld      E,A             ; Re-save LSB
4092+ 2D92 78                   ld      A,B             ; Get VLSB
4093+ 2D93 1F                   rra                     ; Shift VLSB right
4094+ 2D94 47                   ld      B,A             ; Re-save VLSB
4095+ 2D95 2D                   dec     L               ; Count bits multiplied
4096+ 2D96 7C                   ld      A,H             ; Get LSB of multiplier
4097+ 2D97 C2 79 2D             jp      NZ,MUL8LP       ; More - Do it
4098+ 2D9A E1           POPHRT: pop     HL              ; Restore address of number
4099+ 2D9B C9                   ret
4100+ 2D9C
4101+ 2D9C 43           BYTSFT: ld      B,E             ; Shift partial product left
4102+ 2D9D 5A                   ld      E,D
4103+ 2D9E 51                   ld      D,C
4104+ 2D9F 4F                   ld      C,A
4105+ 2DA0 C9                   ret
4106+ 2DA1
4107+ 2DA1
4108+ 2DA1              ; WORKING ââ
4109+ 2DA1 C1           DINT:   pop     BC              ; Get number from stack
4110+ 2DA2 D1                   pop     DE
4111+ 2DA3 CD 00 2E             call    DVBCDE          ; get BCDE/FPREG and store result into FPREG
4112+ 2DA6 C3 7D 2F             jp      INT             ; return INT(FPREG)
4113+ 2DA9
4114+ 2DA9
4115+ 2DA9              ; A MODULO B - return remainder of the integer division A/B where:
4116+ 2DA9              ; A is in stack; B is in FPREG
4117+ 2DA9              ; math is:
4118+ 2DA9              ; A=INT(A); B=INT(B); R=A-(B*INT(A/B))
4119+ 2DA9 CD 7D 2F     MOD:    call    INT             ; B=INT(B)
4120+ 2DAC CD F6 2E             call    BCDEFP          ; copy B (from FPREG) into BCDE
4121+ 2DAF ED 53 26 53          ld      (TMPBFR3),DE    ; store B into...
4122+ 2DB3 ED 43 28 53          ld      (TMPBFR4),BC    ; ...a temp buffer
4123+ 2DB7 C1                   pop     BC              ; recover A...
4124+ 2DB8 D1                   pop     DE              ; ...from stack
4125+ 2DB9 CD EB 2E             call    FPBCDE          ; store A into FPREG
4126+ 2DBC CD 7D 2F             call    INT             ; get integer part: A=INT(A)
4127+ 2DBF CD F6 2E             call    BCDEFP          ; copy A (from FPREG) into BCDE
4128+ 2DC2 ED 53 22 53          ld      (TMPBFR1),DE    ; store A into...
4129+ 2DC6 ED 43 24 53          ld      (TMPBFR2),BC    ; ...a temp buffer
4130+ 2DCA                                              ; begin calculation
4131+ 2DCA 2A 26 53             ld      HL,(TMPBFR3)    ; move B...
4132+ 2DCD 22 76 53             ld      (FPREG),HL      ; ...from...
4133+ 2DD0 2A 28 53             ld      HL,(TMPBFR4)    ; ...temp buffer...
4134+ 2DD3 22 78 53             ld      (FPREG+2),HL    ; ...into FPREG
4135+ 2DD6 CD 00 2E             call    DVBCDE          ; compute A/B and store into FPREG
4136+ 2DD9 CD 7D 2F             call    INT             ; get integer part of result: now FPREG = INT(A/B)
4137+ 2DDC ED 5B 26 53          ld      DE,(TMPBFR3)    ; load B...
4138+ 2DE0 ED 4B 28 53          ld      BC,(TMPBFR4)    ; ...into BCDE
4139+ 2DE4 CD 4E 2D             call    FPMULT          ; get B*INT(A/B) and store into FPREG
4140+ 2DE7 ED 5B 22 53          ld      DE,(TMPBFR1)    ; retrieve A from...
4141+ 2DEB ED 4B 24 53          ld      BC,(TMPBFR2)    ; ...temp buffer
4142+ 2DEF C3 10 2C             jp      SUBCDE          ; return result of A-(B*INT(A/B))
4143+ 2DF2
4144+ 2DF2
4145+ 2DF2 CD DB 2E     DIV10:  call    STAKFP          ; Save FPREG on stack
4146+ 2DF5 01 20 84             ld      BC,$8420        ; BCDE = 10.
4147+ 2DF8 11 00 00             ld      DE,$0000
4148+ 2DFB CD EB 2E             call    FPBCDE          ; Move 10 to FPREG
4149+ 2DFE
4150+ 2DFE C1           DIV:    pop     BC              ; Get number from stack
4151+ 2DFF D1                   pop     DE
4152+ 2E00 CD AA 2E     DVBCDE: call    TSTSGN          ; Test sign of FPREG
4153+ 2E03 CA CC 16             jp      Z,DZERR         ; Error if division by zero
4154+ 2E06 2E FF                ld      L,-1            ; Flag subtract exponents
4155+ 2E08 CD 68 2E             call    ADDEXP          ; Subtract exponents
4156+ 2E0B 34                   inc     (HL)            ; Add 2 to exponent to adjust
4157+ 2E0C 34                   inc     (HL)
4158+ 2E0D 2B                   dec     HL              ; Point to MSB
4159+ 2E0E 7E                   ld      A,(HL)          ; Get MSB of dividend
4160+ 2E0F 32 B8 51             ld      (DIV3),A        ; Save for subtraction
4161+ 2E12 2B                   dec     HL
4162+ 2E13 7E                   ld      A,(HL)          ; Get NMSB of dividend
4163+ 2E14 32 B4 51             ld      (DIV2),A        ; Save for subtraction
4164+ 2E17 2B                   dec     HL
4165+ 2E18 7E                   ld      A,(HL)          ; Get MSB of dividend
4166+ 2E19 32 B0 51             ld      (DIV1),A        ; Save for subtraction
4167+ 2E1C 41                   ld      B,C             ; Get MSB
4168+ 2E1D EB                   ex      DE,HL           ; NMSB,LSB to HL
4169+ 2E1E AF                   xor     A
4170+ 2E1F 4F                   ld      C,A             ; Clear MSB of quotient
4171+ 2E20 57                   ld      D,A             ; Clear NMSB of quotient
4172+ 2E21 5F                   ld      E,A             ; Clear LSB of quotient
4173+ 2E22 32 BB 51             ld      (DIV4),A        ; Clear overflow count
4174+ 2E25 E5           DIVLP:  push    HL              ; Save divisor
4175+ 2E26 C5                   push    BC
4176+ 2E27 7D                   ld      A,L             ; Get LSB of number
4177+ 2E28 CD AF 51             call    DIVSUP          ; Subt' divisor from dividend
4178+ 2E2B DE 00                sbc     A,$00           ; Count for overflows
4179+ 2E2D 3F                   ccf
4180+ 2E2E D2 38 2E             jp      NC,RESDIV       ; Restore divisor if borrow
4181+ 2E31 32 BB 51             ld      (DIV4),A        ; Re-save overflow count
4182+ 2E34 F1                   pop     AF              ; Scrap divisor
4183+ 2E35 F1                   pop     AF
4184+ 2E36 37                   scf                     ; Set carry to
4185+ 2E37 D2                   defb    $D2             ; Skip "pop BC" and "pop HL"
4186+ 2E38
4187+ 2E38 C1           RESDIV: pop     BC              ; Restore divisor
4188+ 2E39 E1                   pop     HL
4189+ 2E3A 79                   ld      A,C             ; Get MSB of quotient
4190+ 2E3B 3C                   inc     A
4191+ 2E3C 3D                   dec     A
4192+ 2E3D 1F                   rra                     ; Bit 0 to bit 7
4193+ 2E3E FA 9A 2C             jp      M,RONDB         ; Done - Normalise result
4194+ 2E41 17                   rla                     ; Restore carry
4195+ 2E42 7B                   ld      A,E             ; Get LSB of quotient
4196+ 2E43 17                   rla                     ; Double it
4197+ 2E44 5F                   ld      E,A             ; Put it back
4198+ 2E45 7A                   ld      A,D             ; Get NMSB of quotient
4199+ 2E46 17                   rla                     ; Double it
4200+ 2E47 57                   ld      D,A             ; Put it back
4201+ 2E48 79                   ld      A,C             ; Get MSB of quotient
4202+ 2E49 17                   rla                     ; Double it
4203+ 2E4A 4F                   ld      C,A             ; Put it back
4204+ 2E4B 29                   add     HL,HL           ; Double NMSB,LSB of divisor
4205+ 2E4C 78                   ld      A,B             ; Get MSB of divisor
4206+ 2E4D 17                   rla                     ; Double it
4207+ 2E4E 47                   ld      B,A             ; Put it back
4208+ 2E4F 3A BB 51             ld      A,(DIV4)        ; Get VLSB of quotient
4209+ 2E52 17                   rla                     ; Double it
4210+ 2E53 32 BB 51             ld      (DIV4),A        ; Put it back
4211+ 2E56 79                   ld      A,C             ; Get MSB of quotient
4212+ 2E57 B2                   or      D               ; Merge NMSB
4213+ 2E58 B3                   or      E               ; Merge LSB
4214+ 2E59 C2 25 2E             jp      NZ,DIVLP        ; Not done - Keep dividing
4215+ 2E5C E5                   push    HL              ; Save divisor
4216+ 2E5D 21 79 53             ld      HL,FPEXP        ; Point to exponent
4217+ 2E60 35                   dec     (HL)            ; Divide by 2
4218+ 2E61 E1                   pop     HL              ; Restore divisor
4219+ 2E62 C2 25 2E             jp      NZ,DIVLP        ; Ok - Keep going
4220+ 2E65 C3 D8 16             jp      OVERR           ; Overflow error
4221+ 2E68
4222+ 2E68
4223+ 2E68 78           ADDEXP: ld      A,B             ; Get exponent of dividend
4224+ 2E69 B7                   or      A               ; Test it
4225+ 2E6A CA 8C 2E             jp      Z,OVTST3        ; Zero - Result zero
4226+ 2E6D 7D                   ld      A,L             ; Get add/subtract flag
4227+ 2E6E 21 79 53             ld      HL,FPEXP        ; Point to exponent
4228+ 2E71 AE                   xor     (HL)            ; Add or subtract it
4229+ 2E72 80                   add     A,B             ; Add the other exponent
4230+ 2E73 47                   ld      B,A             ; Save new exponent
4231+ 2E74 1F                   rra                     ; Test exponent for overflow
4232+ 2E75 A8                   xor     B
4233+ 2E76 78                   ld      A,B             ; Get exponent
4234+ 2E77 F2 8B 2E             jp      P,OVTST2        ; Positive - Test for overflow
4235+ 2E7A C6 80                add     A,$80           ; Add excess 128
4236+ 2E7C 77                   ld      (HL),A          ; Save new exponent
4237+ 2E7D CA 9A 2D             jp      Z,POPHRT        ; Zero - Result zero
4238+ 2E80 CD 10 2F             call    SIGNS           ; Set MSBs and sign of result
4239+ 2E83 77                   ld      (HL),A          ; Save new exponent
4240+ 2E84 2B                   dec     HL              ; Point to MSB
4241+ 2E85 C9                   ret
4242+ 2E86
4243+ 2E86 CD AA 2E     OVTST1: call    TSTSGN          ; Test sign of FPREG
4244+ 2E89 2F                   cpl                     ; Invert sign
4245+ 2E8A E1                   pop     HL              ; Clean up stack
4246+ 2E8B B7           OVTST2: or      A               ; Test if new exponent zero
4247+ 2E8C E1           OVTST3: pop     HL              ; Clear off return address
4248+ 2E8D F2 79 2C             jp      P,RESZER        ; Result zero
4249+ 2E90 C3 D8 16             jp      OVERR           ; Overflow error
4250+ 2E93
4251+ 2E93 CD F6 2E     MLSP10: call    BCDEFP          ; Move FPREG to BCDE
4252+ 2E96 78                   ld      A,B             ; Get exponent
4253+ 2E97 B7                   or      A               ; Is it zero?
4254+ 2E98 C8                   ret     Z               ; Yes - Result is zero
4255+ 2E99 C6 02                add     A,$02           ; Multiply by 4
4256+ 2E9B DA D8 16             jp      C,OVERR         ; Overflow - ?OV Error
4257+ 2E9E 47                   ld      B,A             ; Re-save exponent
4258+ 2E9F CD 13 2C             call    FPADD           ; Add BCDE to FPREG (Times 5)
4259+ 2EA2 21 79 53             ld      HL,FPEXP        ; Point to exponent
4260+ 2EA5 34                   inc     (HL)            ; Double number (Times 10)
4261+ 2EA6 C0                   ret     NZ              ; Ok - Return
4262+ 2EA7 C3 D8 16             jp      OVERR           ; Overflow error
4263+ 2EAA
4264+ 2EAA 3A 79 53     TSTSGN: ld      A,(FPEXP)       ; Get sign of FPREG
4265+ 2EAD B7                   or      A
4266+ 2EAE C8                   ret     Z               ; RETurn if number is zero
4267+ 2EAF 3A 78 53             ld      A,(FPREG+2)     ; Get MSB of FPREG
4268+ 2EB2 FE                   defb    0FEH            ; Test sign
4269+ 2EB3 2F           RETREL: cpl                     ; Invert sign
4270+ 2EB4 17                   rla                     ; Sign bit to carry
4271+ 2EB5 9F           FLGDIF: sbc     A,A             ; Carry to all bits of A
4272+ 2EB6 C0                   ret     NZ              ; Return -1 if negative
4273+ 2EB7 3C                   inc     A               ; Bump to +1
4274+ 2EB8 C9                   ret                     ; Positive - Return +1
4275+ 2EB9
4276+ 2EB9 CD AA 2E     SGN:    call    TSTSGN          ; Test sign of FPREG
4277+ 2EBC 06 88        FLGREL: ld      B,$80+8         ; 8 bit integer in exponent
4278+ 2EBE 11 00 00             ld      DE,0            ; Zero NMSB and LSB
4279+ 2EC1 21 79 53     RETINT: ld      HL,FPEXP        ; Point to exponent
4280+ 2EC4 4F                   ld      C,A             ; CDE = MSB,NMSB and LSB
4281+ 2EC5 70                   ld      (HL),B          ; Save exponent
4282+ 2EC6 06 00                ld      B,0             ; CDE = integer to normalise
4283+ 2EC8 23                   inc     HL              ; Point to sign of result
4284+ 2EC9 36 80                ld      (HL),$80        ; Set sign of result
4285+ 2ECB 17                   rla                     ; Carry = sign of integer
4286+ 2ECC C3 61 2C             jp      CONPOS          ; Set sign of result
4287+ 2ECF
4288+ 2ECF CD AA 2E     ABS_:   call    TSTSGN          ; Test sign of FPREG
4289+ 2ED2 F0                   ret     P               ; Return if positive
4290+ 2ED3 21 78 53     INVSGN: ld      HL,FPREG+2      ; Point to MSB
4291+ 2ED6 7E                   ld      A,(HL)          ; Get sign of mantissa
4292+ 2ED7 EE 80                xor     $80             ; Invert sign of mantissa
4293+ 2ED9 77                   ld      (HL),A          ; Re-save sign of mantissa
4294+ 2EDA C9                   ret
4295+ 2EDB
4296+ 2EDB EB           STAKFP: ex      DE,HL           ; Save code string address
4297+ 2EDC 2A 76 53             ld      HL,(FPREG)      ; LSB,NLSB of FPREG
4298+ 2EDF E3                   ex      (SP),HL         ; Stack them,get return
4299+ 2EE0 E5                   push    HL              ; Re-save return
4300+ 2EE1 2A 78 53             ld      HL,(FPREG+2)    ; MSB and exponent of FPREG
4301+ 2EE4 E3                   ex      (SP),HL         ; Stack them,get return
4302+ 2EE5 E5                   push    HL              ; Re-save return
4303+ 2EE6 EB                   ex      DE,HL           ; Restore code string address
4304+ 2EE7 C9                   ret
4305+ 2EE8
4306+ 2EE8              ; store F.P. number from BCDE into (FPREG)
4307+ 2EE8 CD F9 2E     PHLTFP: call    LOADFP          ; Number at HL to BCDE
4308+ 2EEB EB           FPBCDE: ex      DE,HL           ; Save code string address
4309+ 2EEC 22 76 53             ld      (FPREG),HL      ; Save LSB,NLSB of number
4310+ 2EEF 60                   ld      H,B             ; Exponent of number
4311+ 2EF0 69                   ld      L,C             ; MSB of number
4312+ 2EF1 22 78 53             ld      (FPREG+2),HL    ; Save MSB and exponent
4313+ 2EF4 EB                   ex      DE,HL           ; Restore code string address
4314+ 2EF5 C9                   ret
4315+ 2EF6
4316+ 2EF6              ; load F.P. number from (FPREG) into BCDE
4317+ 2EF6 21 76 53     BCDEFP: ld      HL,FPREG        ; Point to FPREG
4318+ 2EF9 5E           LOADFP: ld      E,(HL)          ; Get LSB of number
4319+ 2EFA 23                   inc     HL
4320+ 2EFB 56                   ld      D,(HL)          ; Get NMSB of number
4321+ 2EFC 23                   inc     HL
4322+ 2EFD 4E                   ld      C,(HL)          ; Get MSB of number
4323+ 2EFE 23                   inc     HL
4324+ 2EFF 46                   ld      B,(HL)          ; Get exponent of number
4325+ 2F00 23           INCHL:  inc     HL              ; Used for conditional "inc HL"
4326+ 2F01 C9                   ret
4327+ 2F02
4328+ 2F02              ; move floating point from (FPREG) into (HL)
4329+ 2F02 11 76 53     FPTHL:  ld      DE,FPREG        ; Point to FPREG
4330+ 2F05 06 04        DETHL4: ld      B,$04           ; 4 bytes to move
4331+ 2F07 1A           DETHLB: ld      A,(DE)          ; Get source
4332+ 2F08 77                   ld      (HL),A          ; Save destination
4333+ 2F09 13                   inc     DE              ; Next source
4334+ 2F0A 23                   inc     HL              ; Next destination
4335+ 2F0B 05                   dec     B               ; Count bytes
4336+ 2F0C C2 07 2F             jp      NZ,DETHLB       ; Loop if more
4337+ 2F0F C9                   ret
4338+ 2F10
4339+ 2F10 21 78 53     SIGNS:  ld      HL,FPREG+2      ; Point to MSB of FPREG
4340+ 2F13 7E                   ld      A,(HL)          ; Get MSB
4341+ 2F14 07                   rlca                    ; Old sign to carry
4342+ 2F15 37                   scf                     ; Set MSBit
4343+ 2F16 1F                   rra                     ; Set MSBit of MSB
4344+ 2F17 77                   ld      (HL),A          ; Save new MSB
4345+ 2F18 3F                   ccf                     ; Complement sign
4346+ 2F19 1F                   rra                     ; Old sign to carry
4347+ 2F1A 23                   inc     HL
4348+ 2F1B 23                   inc     HL
4349+ 2F1C 77                   ld      (HL),A          ; Set sign of result
4350+ 2F1D 79                   ld      A,C             ; Get MSB
4351+ 2F1E 07                   rlca                    ; Old sign to carry
4352+ 2F1F 37                   scf                     ; Set MSBit
4353+ 2F20 1F                   rra                     ; Set MSBit of MSB
4354+ 2F21 4F                   ld      C,A             ; Save MSB
4355+ 2F22 1F                   rra
4356+ 2F23 AE                   xor     (HL)            ; New sign of result
4357+ 2F24 C9                   ret
4358+ 2F25
4359+ 2F25 78           CMPNUM: ld      A,B             ; Get exponent of number
4360+ 2F26 B7                   or      A
4361+ 2F27 CA AA 2E             jp      Z,TSTSGN        ; Zero - Test sign of FPREG
4362+ 2F2A 21 B3 2E             ld      HL,RETREL       ; Return relation routine
4363+ 2F2D E5                   push    HL              ; Save for return
4364+ 2F2E CD AA 2E             call    TSTSGN          ; Test sign of FPREG
4365+ 2F31 79                   ld      A,C             ; Get MSB of number
4366+ 2F32 C8                   ret     Z               ; FPREG zero - Number's MSB
4367+ 2F33 21 78 53             ld      HL,FPREG+2      ; MSB of FPREG
4368+ 2F36 AE                   xor     (HL)            ; Combine signs
4369+ 2F37 79                   ld      A,C             ; Get MSB of number
4370+ 2F38 F8                   ret     M               ; Exit if signs different
4371+ 2F39 CD 3F 2F             call    CMPFP           ; Compare FP numbers
4372+ 2F3C 1F                   rra                     ; Get carry to sign
4373+ 2F3D A9                   xor     C               ; Combine with MSB of number
4374+ 2F3E C9                   ret
4375+ 2F3F
4376+ 2F3F 23           CMPFP:  inc     HL              ; Point to exponent
4377+ 2F40 78                   ld      A,B             ; Get exponent
4378+ 2F41 BE                   cp      (HL)            ; Compare exponents
4379+ 2F42 C0                   ret     NZ              ; Different
4380+ 2F43 2B                   dec     HL              ; Point to MBS
4381+ 2F44 79                   ld      A,C             ; Get MSB
4382+ 2F45 BE                   cp      (HL)            ; Compare MSBs
4383+ 2F46 C0                   ret     NZ              ; Different
4384+ 2F47 2B                   dec     HL              ; Point to NMSB
4385+ 2F48 7A                   ld      A,D             ; Get NMSB
4386+ 2F49 BE                   cp      (HL)            ; Compare NMSBs
4387+ 2F4A C0                   ret     NZ              ; Different
4388+ 2F4B 2B                   dec     HL              ; Point to LSB
4389+ 2F4C 7B                   ld      A,E             ; Get LSB
4390+ 2F4D 96                   sub     (HL)            ; Compare LSBs
4391+ 2F4E C0                   ret     NZ              ; Different
4392+ 2F4F E1                   pop     HL              ; Drop RETurn
4393+ 2F50 E1                   pop     HL              ; Drop another RETurn
4394+ 2F51 C9                   ret
4395+ 2F52
4396+ 2F52 47           FPINT:  ld      B,A             ; <- Move
4397+ 2F53 4F                   ld      C,A             ; <- exponent
4398+ 2F54 57                   ld      D,A             ; <- to all
4399+ 2F55 5F                   ld      E,A             ; <- bits
4400+ 2F56 B7                   or      A               ; Test exponent
4401+ 2F57 C8                   ret     Z               ; Zero - Return zero
4402+ 2F58 E5                   push    HL              ; Save pointer to number
4403+ 2F59 CD F6 2E             call    BCDEFP          ; Move FPREG to BCDE
4404+ 2F5C CD 10 2F             call    SIGNS           ; Set MSBs & sign of result
4405+ 2F5F AE                   xor     (HL)            ; Combine with sign of FPREG
4406+ 2F60 67                   ld      H,A             ; Save combined signs
4407+ 2F61 FC 76 2F             call    M,DCBCDE        ; Negative - Decrement BCDE
4408+ 2F64 3E 98                ld      A,$80+24        ; 24 bits
4409+ 2F66 90                   sub     B               ; Bits to shift
4410+ 2F67 CD D8 2C             call    SCALE           ; Shift BCDE
4411+ 2F6A 7C                   ld      A,H             ; Get combined sign
4412+ 2F6B 17                   rla                     ; Sign to carry
4413+ 2F6C DC AB 2C             call    C,FPROND        ; Negative - Round number up
4414+ 2F6F 06 00                ld      B,$00           ; Zero exponent
4415+ 2F71 DC C4 2C             call    C,COMPL         ; If negative make positive
4416+ 2F74 E1                   pop     HL              ; Restore pointer to number
4417+ 2F75 C9                   ret
4418+ 2F76
4419+ 2F76 1B           DCBCDE: dec     DE              ; Decrement BCDE
4420+ 2F77 7A                   ld      A,D             ; Test LSBs
4421+ 2F78 A3                   and     E
4422+ 2F79 3C                   inc     A
4423+ 2F7A C0                   ret     NZ              ; Exit if LSBs not FFFF
4424+ 2F7B 0B                   dec     BC              ; Decrement MSBs
4425+ 2F7C C9                   ret
4426+ 2F7D
4427+ 2F7D 21 79 53     INT:    ld      HL,FPEXP        ; Point to exponent
4428+ 2F80 7E                   ld      A,(HL)          ; Get exponent
4429+ 2F81 FE 98                cp      $80+24          ; Integer accuracy only?
4430+ 2F83 3A 76 53             ld      A,(FPREG)       ; Get LSB
4431+ 2F86 D0                   ret     NC              ; Yes - Already integer
4432+ 2F87 7E                   ld      A,(HL)          ; Get exponent
4433+ 2F88 CD 52 2F             call    FPINT           ; F.P to integer
4434+ 2F8B 36 98                ld      (HL),$80+24     ; Save 24 bit integer
4435+ 2F8D 7B                   ld      A,E             ; Get LSB of number
4436+ 2F8E F5                   push    AF              ; Save LSB
4437+ 2F8F 79                   ld      A,C             ; Get MSB of number
4438+ 2F90 17                   rla                     ; Sign to carry
4439+ 2F91 CD 61 2C             call    CONPOS          ; Set sign of result
4440+ 2F94 F1                   pop     AF              ; Restore LSB of number
4441+ 2F95 C9                   ret
4442+ 2F96
4443+ 2F96 21 00 00     MLDEBC: ld      HL,$0000        ; Clear partial product
4444+ 2F99 78                   ld      A,B             ; Test multiplier
4445+ 2F9A B1                   or      C
4446+ 2F9B C8                   ret     Z               ; Return zero if zero
4447+ 2F9C 3E 10                ld      A,$10           ; 16 bits
4448+ 2F9E 29           MLDBLP: add     HL,HL           ; Shift P.P left
4449+ 2F9F DA C4 23             jp      C,BSERR         ; ?BS Error if overflow
4450+ 2FA2 EB                   ex      DE,HL
4451+ 2FA3 29                   add     HL,HL           ; Shift multiplier left
4452+ 2FA4 EB                   ex      DE,HL
4453+ 2FA5 D2 AC 2F             jp      NC,NOMLAD       ; Bit was zero - No add
4454+ 2FA8 09                   add     HL,BC           ; Add multiplicand
4455+ 2FA9 DA C4 23             jp      C,BSERR         ; ?BS Error if overflow
4456+ 2FAC 3D           NOMLAD: dec     A               ; Count bits
4457+ 2FAD C2 9E 2F             jp      NZ,MLDBLP       ; More
4458+ 2FB0 C9                   ret
4459+ 2FB1
4460+ 2FB1 FE 2D        ASCTFP: cp      '-'             ; Negative?
4461+ 2FB3 F5                   push    AF              ; Save it and flags
4462+ 2FB4 CA BD 2F             jp      Z,CNVNUM        ; Yes - Convert number
4463+ 2FB7 FE 2B                cp      '+'             ; Positive?
4464+ 2FB9 CA BD 2F             jp      Z,CNVNUM        ; Yes - Convert number
4465+ 2FBC 2B                   dec     HL              ; dec 'cos GETCHR INCs
4466+ 2FBD CD 79 2C     CNVNUM: call    RESZER          ; Set result to zero
4467+ 2FC0 47                   ld      B,A             ; Digits after point counter
4468+ 2FC1 57                   ld      D,A             ; Sign of exponent
4469+ 2FC2 5F                   ld      E,A             ; Exponent of ten
4470+ 2FC3 2F                   cpl
4471+ 2FC4 4F                   ld      C,A             ; Before or after point flag
4472+ 2FC5 CD 0C 1C     MANLP:  call    GETCHR          ; Get next character
4473+ 2FC8 DA 0E 30             jp      C,ADDIG         ; Digit - Add to number
4474+ 2FCB FE 2E                cp      '.'
4475+ 2FCD CA E9 2F             jp      Z,DPOINT        ; '.' - Flag point
4476+ 2FD0 FE 45                cp      'E'
4477+ 2FD2 C2 ED 2F             jp      NZ,CONEXP       ; Not 'E' - Scale number
4478+ 2FD5 CD 0C 1C             call    GETCHR          ; Get next character
4479+ 2FD8 CD E0 21             call    SGNEXP          ; Get sign of exponent
4480+ 2FDB CD 0C 1C     EXPLP:  call    GETCHR          ; Get next character
4481+ 2FDE DA 30 30             jp      C,EDIGIT        ; Digit - Add to exponent
4482+ 2FE1 14                   inc     D               ; Is sign negative?
4483+ 2FE2 C2 ED 2F             jp      NZ,CONEXP       ; No - Scale number
4484+ 2FE5 AF                   xor     A
4485+ 2FE6 93                   sub     E               ; Negate exponent
4486+ 2FE7 5F                   ld      E,A             ; And re-save it
4487+ 2FE8 0C                   inc     C               ; Flag end of number
4488+ 2FE9 0C           DPOINT: inc     C               ; Flag point passed
4489+ 2FEA CA C5 2F             jp      Z,MANLP         ; Zero - Get another digit
4490+ 2FED E5           CONEXP: push    HL              ; Save code string address
4491+ 2FEE 7B                   ld      A,E             ; Get exponent
4492+ 2FEF 90                   sub     B               ; Subtract digits after point
4493+ 2FF0 F4 06 30     SCALMI: call    P,SCALPL        ; Positive - Multiply number
4494+ 2FF3 F2 FC 2F             jp      P,ENDCON        ; Positive - All done
4495+ 2FF6 F5                   push    AF              ; Save number of times to /10
4496+ 2FF7 CD F2 2D             call    DIV10           ; Divide by 10
4497+ 2FFA F1                   pop     AF              ; Restore count
4498+ 2FFB 3C                   inc     A               ; Count divides
4499+ 2FFC
4500+ 2FFC C2 F0 2F     ENDCON: jp      NZ,SCALMI       ; More to do
4501+ 2FFF D1                   pop     DE              ; Restore code string address
4502+ 3000 F1                   pop     AF              ; Restore sign of number
4503+ 3001 CC D3 2E             call    Z,INVSGN        ; Negative - Negate number
4504+ 3004 EB                   ex      DE,HL           ; Code string address to HL
4505+ 3005 C9                   ret
4506+ 3006
4507+ 3006 C8           SCALPL: ret     Z               ; Exit if no scaling needed
4508+ 3007 F5           MULTEN: push    AF              ; Save count
4509+ 3008 CD 93 2E             call    MLSP10          ; Multiply number by 10
4510+ 300B F1                   pop     AF              ; Restore count
4511+ 300C 3D                   dec     A               ; Count multiplies
4512+ 300D C9                   ret
4513+ 300E
4514+ 300E D5           ADDIG:  push    DE              ; Save sign of exponent
4515+ 300F 57                   ld      D,A             ; Save digit
4516+ 3010 78                   ld      A,B             ; Get digits after point
4517+ 3011 89                   adc     A,C             ; Add one if after point
4518+ 3012 47                   ld      B,A             ; Re-save counter
4519+ 3013 C5                   push    BC              ; Save point flags
4520+ 3014 E5                   push    HL              ; Save code string address
4521+ 3015 D5                   push    DE              ; Save digit
4522+ 3016 CD 93 2E             call    MLSP10          ; Multiply number by 10
4523+ 3019 F1                   pop     AF              ; Restore digit
4524+ 301A D6 30                sub     '0'             ; Make it absolute
4525+ 301C CD 25 30             call    RSCALE          ; Re-scale number
4526+ 301F E1                   pop     HL              ; Restore code string address
4527+ 3020 C1                   pop     BC              ; Restore point flags
4528+ 3021 D1                   pop     DE              ; Restore sign of exponent
4529+ 3022 C3 C5 2F             jp      MANLP           ; Get another digit
4530+ 3025
4531+ 3025 CD DB 2E     RSCALE: call    STAKFP          ; Put number on stack
4532+ 3028 CD BC 2E             call    FLGREL          ; Digit to add to FPREG
4533+ 302B C1           PADD:   pop     BC              ; Restore number
4534+ 302C D1                   pop     DE
4535+ 302D C3 13 2C             jp      FPADD           ; Add BCDE to FPREG and return
4536+ 3030
4537+ 3030 7B           EDIGIT: ld      A,E             ; Get digit
4538+ 3031 07                   rlca                    ; Times 2
4539+ 3032 07                   rlca                    ; Times 4
4540+ 3033 83                   add     A,E             ; Times 5
4541+ 3034 07                   rlca                    ; Times 10
4542+ 3035 86                   add     A,(HL)          ; Add next digit
4543+ 3036 D6 30                sub     '0'             ; Make it absolute
4544+ 3038 5F                   ld      E,A             ; Save new digit
4545+ 3039 C3 DB 2F             jp      EXPLP           ; Look for another digit
4546+ 303C
4547+ 303C E5           LINEIN: push    HL              ; Save code string address
4548+ 303D 21 42 16             ld      HL,INMSG        ; Output " in "
4549+ 3040 CD A5 25             call    PRS             ; Output string at HL
4550+ 3043 E1                   pop     HL              ; Restore code string address
4551+ 3044 EB           PRNTHL: ex      DE,HL           ; Code string address to DE
4552+ 3045 AF                   xor     A
4553+ 3046 06 98                ld      B,$80+24        ; 24 bits
4554+ 3048 CD C1 2E             call    RETINT          ; Return the integer
4555+ 304B 21 A4 25             ld      HL,PRNUMS       ; Print number string
4556+ 304E E5                   push    HL              ; Save for return
4557+ 304F 21 7B 53     NUMASC: ld      HL,PBUFF        ; Convert number to ASCII
4558+ 3052 E5                   push    HL              ; Save for return
4559+ 3053 CD AA 2E             call    TSTSGN          ; Test sign of FPREG
4560+ 3056 36 20                ld      (HL),SPC        ; Space at start
4561+ 3058 F2 5D 30             jp      P,SPCFST        ; Positive - Space to start
4562+ 305B 36 2D                ld      (HL),'-'        ; '-' sign at start
4563+ 305D 23           SPCFST: inc     HL              ; First byte of number
4564+ 305E 36 30                ld      (HL),'0'        ; '0' if zero
4565+ 3060 CA 13 31             jp      Z,JSTZER        ; Return '0' if zero
4566+ 3063 E5                   push    HL              ; Save buffer address
4567+ 3064 FC D3 2E             call    M,INVSGN        ; Negate FPREG if negative
4568+ 3067 AF                   xor     A               ; Zero A
4569+ 3068 F5                   push    AF              ; Save it
4570+ 3069 CD 19 31             call    RNGTST          ; Test number is in range
4571+ 306C 01 43 91     SIXDIG: ld      BC,$9143        ; BCDE - 99999.9
4572+ 306F 11 F8 4F             ld      DE,$4FF8
4573+ 3072 CD 25 2F             call    CMPNUM          ; Compare numbers
4574+ 3075 B7                   or      A
4575+ 3076 E2 8A 30             jp      PO,INRNG        ; > 99999.9 - Sort it out
4576+ 3079 F1                   pop     AF              ; Restore count
4577+ 307A CD 07 30             call    MULTEN          ; Multiply by ten
4578+ 307D F5                   push    AF              ; Re-save count
4579+ 307E C3 6C 30             jp      SIXDIG          ; Test it again
4580+ 3081
4581+ 3081 CD F2 2D     GTSIXD: call    DIV10           ; Divide by 10
4582+ 3084 F1                   pop     AF              ; Get count
4583+ 3085 3C                   inc     A               ; Count divides
4584+ 3086 F5                   push    AF              ; Re-save count
4585+ 3087 CD 19 31             call    RNGTST          ; Test number is in range
4586+ 308A CD 01 2C     INRNG:  call    ROUND           ; Add 0.5 to FPREG
4587+ 308D 3C                   inc     A
4588+ 308E CD 52 2F             call    FPINT           ; F.P to integer
4589+ 3091 CD EB 2E             call    FPBCDE          ; Move BCDE to FPREG
4590+ 3094 01 06 03             ld      BC,$0306        ; 1E+06 to 1E-03 range
4591+ 3097 F1                   pop     AF              ; Restore count
4592+ 3098 81                   add     A,C             ; 6 digits before point
4593+ 3099 3C                   inc     A               ; Add one
4594+ 309A FA A6 30             jp      M,MAKNUM        ; Do it in 'E' form if < 1E-02
4595+ 309D FE 08                cp      6+1+1           ; More than 999999 ?
4596+ 309F D2 A6 30             jp      NC,MAKNUM       ; Yes - Do it in 'E' form
4597+ 30A2 3C                   inc     A               ; Adjust for exponent
4598+ 30A3 47                   ld      B,A             ; Exponent of number
4599+ 30A4 3E 02                ld      A,2             ; Make it zero after
4600+ 30A6
4601+ 30A6 3D           MAKNUM: dec     A               ; Adjust for digits to do
4602+ 30A7 3D                   dec     A
4603+ 30A8 E1                   pop     HL              ; Restore buffer address
4604+ 30A9 F5                   push    AF              ; Save count
4605+ 30AA 11 2C 31             ld      DE,POWERS       ; Powers of ten
4606+ 30AD 05                   dec     B               ; Count digits before point
4607+ 30AE C2 B7 30             jp      NZ,DIGTXT       ; Not zero - Do number
4608+ 30B1 36 2E                ld      (HL),'.'        ; Save point
4609+ 30B3 23                   inc     HL              ; Move on
4610+ 30B4 36 30                ld      (HL),'0'        ; Save zero
4611+ 30B6 23                   inc     HL              ; Move on
4612+ 30B7 05           DIGTXT: dec     B               ; Count digits before point
4613+ 30B8 36 2E                ld      (HL),'.'        ; Save point in case
4614+ 30BA CC 00 2F             call    Z,INCHL         ; Last digit - move on
4615+ 30BD C5                   push    BC              ; Save digits before point
4616+ 30BE E5                   push    HL              ; Save buffer address
4617+ 30BF D5                   push    DE              ; Save powers of ten
4618+ 30C0 CD F6 2E             call    BCDEFP          ; Move FPREG to BCDE
4619+ 30C3 E1                   pop     HL              ; Powers of ten table
4620+ 30C4 06 2F                ld      B,'0'-1         ; ASCII '0' - 1
4621+ 30C6 04           TRYAGN: inc     B               ; Count subtractions
4622+ 30C7 7B                   ld      A,E             ; Get LSB
4623+ 30C8 96                   sub     (HL)            ; Subtract LSB
4624+ 30C9 5F                   ld      E,A             ; Save LSB
4625+ 30CA 23                   inc     HL
4626+ 30CB 7A                   ld      A,D             ; Get NMSB
4627+ 30CC 9E                   sbc     A,(HL)          ; Subtract NMSB
4628+ 30CD 57                   ld      D,A             ; Save NMSB
4629+ 30CE 23                   inc     HL
4630+ 30CF 79                   ld      A,C             ; Get MSB
4631+ 30D0 9E                   sbc     A,(HL)          ; Subtract MSB
4632+ 30D1 4F                   ld      C,A             ; Save MSB
4633+ 30D2 2B                   dec     HL              ; Point back to start
4634+ 30D3 2B                   dec     HL
4635+ 30D4 D2 C6 30             jp      NC,TRYAGN       ; No overflow - Try again
4636+ 30D7 CD B8 2C             call    PLUCDE          ; Restore number
4637+ 30DA 23                   inc     HL              ; Start of next number
4638+ 30DB CD EB 2E             call    FPBCDE          ; Move BCDE to FPREG
4639+ 30DE EB                   ex      DE,HL           ; Save point in table
4640+ 30DF E1                   pop     HL              ; Restore buffer address
4641+ 30E0 70                   ld      (HL),B          ; Save digit in buffer
4642+ 30E1 23                   inc     HL              ; And move on
4643+ 30E2 C1                   pop     BC              ; Restore digit count
4644+ 30E3 0D                   dec     C               ; Count digits
4645+ 30E4 C2 B7 30             jp      NZ,DIGTXT       ; More - Do them
4646+ 30E7 05                   dec     B               ; Any decimal part?
4647+ 30E8 CA F7 30             jp      Z,DOEBIT        ; No - Do 'E' bit
4648+ 30EB 2B           SUPTLZ: dec     HL              ; Move back through buffer
4649+ 30EC 7E                   ld      A,(HL)          ; Get character
4650+ 30ED FE 30                cp      '0'             ; '0' character?
4651+ 30EF CA EB 30             jp      Z,SUPTLZ        ; Yes - Look back for more
4652+ 30F2 FE 2E                cp      '.'             ; A decimal point?
4653+ 30F4 C4 00 2F             call    NZ,INCHL        ; Move back over digit
4654+ 30F7
4655+ 30F7 F1           DOEBIT: pop     AF              ; Get 'E' flag
4656+ 30F8 CA 16 31             jp      Z,NOENED        ; No 'E' needed - End buffer
4657+ 30FB 36 45                ld      (HL),'E'        ; Put 'E' in buffer
4658+ 30FD 23                   inc     HL              ; And move on
4659+ 30FE 36 2B                ld      (HL),'+'        ; Put '+' in buffer
4660+ 3100 F2 07 31             jp      P,OUTEXP        ; Positive - Output exponent
4661+ 3103 36 2D                ld      (HL),'-'        ; Put '-' in buffer
4662+ 3105 2F                   cpl                     ; Negate exponent
4663+ 3106 3C                   inc     A
4664+ 3107 06 2F        OUTEXP: ld      B,'0'-1         ; ASCII '0' - 1
4665+ 3109 04           EXPTEN: inc     B               ; Count subtractions
4666+ 310A D6 0A                sub     $0A             ; Tens digit
4667+ 310C D2 09 31             jp      NC,EXPTEN       ; More to do
4668+ 310F C6 3A                add     A,'0'+10        ; Restore and make ASCII
4669+ 3111 23                   inc     HL              ; Move on
4670+ 3112 70                   ld      (HL),B          ; Save MSB of exponent
4671+ 3113 23           JSTZER: inc     HL              ;
4672+ 3114 77                   ld      (HL),A          ; Save LSB of exponent
4673+ 3115 23                   inc     HL
4674+ 3116 71           NOENED: ld      (HL),C          ; Mark end of buffer
4675+ 3117 E1                   pop     HL              ; Restore code string address
4676+ 3118 C9                   ret
4677+ 3119
4678+ 3119 01 74 94     RNGTST: ld      BC,$9474        ; BCDE = 999999.
4679+ 311C 11 F7 23             ld      DE,$23F7
4680+ 311F CD 25 2F             call    CMPNUM          ; Compare numbers
4681+ 3122 B7                   or      A
4682+ 3123 E1                   pop     HL              ; Return address to HL
4683+ 3124 E2 81 30             jp      PO,GTSIXD       ; Too big - Divide by ten
4684+ 3127 E9                   jp      (HL)            ; Otherwise return to caller
4685+ 3128
4686+ 3128 00 00 00 80  HALF:   defb    $00,$00,$00,$80 ; 0.5
4687+ 312C
4688+ 312C A0 86 01     POWERS: defb    $A0,$86,$01  ; 100000
4689+ 312F 10 27 00             defb    $10,$27,$00  ;  10000
4690+ 3132 E8 03 00             defb    $E8,$03,$00  ;   1000
4691+ 3135 64 00 00             defb    $64,$00,$00  ;    100
4692+ 3138 0A 00 00             defb    $0A,$00,$00  ;     10
4693+ 313B 01 00 00             defb    $01,$00,$00  ;      1
4694+ 313E
4695+ 313E 21 D3 2E     NEGAFT: ld      HL,INVSGN       ; Negate result
4696+ 3141 E3                   ex      (SP),HL         ; To be done after caller
4697+ 3142 E9                   jp      (HL)            ; Return to caller
4698+ 3143
4699+ 3143 CD DB 2E     SQR:    call    STAKFP          ; Put value on stack
4700+ 3146 21 28 31             ld      HL,HALF         ; Set power to 1/2
4701+ 3149 CD E8 2E             call    PHLTFP          ; Move 1/2 to FPREG
4702+ 314C
4703+ 314C C1           POWER:  pop     BC              ; Get base
4704+ 314D D1                   pop     DE
4705+ 314E CD AA 2E             call    TSTSGN          ; Test sign of power
4706+ 3151 78                   ld      A,B             ; Get exponent of base
4707+ 3152 CA 91 31             jp      Z,EXP           ; Make result 1 if zero
4708+ 3155 F2 5C 31             jp      P,POWER1        ; Positive base - Ok
4709+ 3158 B7                   or      A               ; Zero to negative power?
4710+ 3159 CA CC 16             jp      Z,DZERR         ; Yes - ?/0 Error
4711+ 315C B7           POWER1: or      A               ; Base zero?
4712+ 315D CA 7A 2C             jp      Z,SAVEXP        ; Yes - Return zero
4713+ 3160 D5                   push    DE              ; Save base
4714+ 3161 C5                   push    BC
4715+ 3162 79                   ld      A,C             ; Get MSB of base
4716+ 3163 F6 7F                or      %01111111       ; Get sign status
4717+ 3165 CD F6 2E             call    BCDEFP          ; Move power to BCDE
4718+ 3168 F2 79 31             jp      P,POWER2        ; Positive base - Ok
4719+ 316B D5                   push    DE              ; Save power
4720+ 316C C5                   push    BC
4721+ 316D CD 7D 2F             call    INT             ; Get integer of power
4722+ 3170 C1                   pop     BC              ; Restore power
4723+ 3171 D1                   pop     DE
4724+ 3172 F5                   push    AF              ; MSB of base
4725+ 3173 CD 25 2F             call    CMPNUM          ; Power an integer?
4726+ 3176 E1                   pop     HL              ; Restore MSB of base
4727+ 3177 7C                   ld      A,H             ; but don't affect flags
4728+ 3178 1F                   rra                     ; Exponent odd or even?
4729+ 3179 E1           POWER2: pop     HL              ; Restore MSB and exponent
4730+ 317A 22 78 53             ld      (FPREG+2),HL    ; Save base in FPREG
4731+ 317D E1                   pop     HL              ; LSBs of base
4732+ 317E 22 76 53             ld      (FPREG),HL      ; Save in FPREG
4733+ 3181 DC 3E 31             call    C,NEGAFT        ; Odd power - Negate result
4734+ 3184 CC D3 2E             call    Z,INVSGN        ; Negative base - Negate it
4735+ 3187 D5                   push    DE              ; Save power
4736+ 3188 C5                   push    BC
4737+ 3189 CD 0D 2D             call    LOG             ; Get LOG of base
4738+ 318C C1                   pop     BC              ; Restore power
4739+ 318D D1                   pop     DE
4740+ 318E CD 4E 2D             call    FPMULT          ; Multiply LOG by power
4741+ 3191
4742+ 3191 CD DB 2E     EXP:    call    STAKFP          ; Put value on stack
4743+ 3194 01 38 81             ld      BC,$8138        ; BCDE = 1/Ln(2)
4744+ 3197 11 3B AA             ld      DE,$AA3B
4745+ 319A CD 4E 2D             call    FPMULT          ; Multiply value by 1/LN(2)
4746+ 319D 3A 79 53             ld      A,(FPEXP)       ; Get exponent
4747+ 31A0 FE 88                cp      $80+8           ; Is it in range?
4748+ 31A2 D2 86 2E             jp      NC,OVTST1       ; No - Test for overflow
4749+ 31A5 CD 7D 2F             call    INT             ; Get INT of FPREG
4750+ 31A8 C6 80                add     A,$80           ; For excess 128
4751+ 31AA C6 02                add     A,$02           ; Exponent > 126?
4752+ 31AC DA 86 2E             jp      C,OVTST1        ; Yes - Test for overflow
4753+ 31AF F5                   push    AF              ; Save scaling factor
4754+ 31B0 21 FC 2C             ld      HL,UNITY        ; Point to 1.
4755+ 31B3 CD 04 2C             call    ADDPHL          ; Add 1 to FPREG
4756+ 31B6 CD 45 2D             call    MULLN2          ; Multiply by LN(2)
4757+ 31B9 F1                   pop     AF              ; Restore scaling factor
4758+ 31BA C1                   pop     BC              ; Restore exponent
4759+ 31BB D1                   pop     DE
4760+ 31BC F5                   push    AF              ; Save scaling factor
4761+ 31BD CD 10 2C             call    SUBCDE          ; Subtract exponent from FPREG
4762+ 31C0 CD D3 2E             call    INVSGN          ; Negate result
4763+ 31C3 21 D1 31             ld      HL,EXPTAB       ; Coefficient table
4764+ 31C6 CD 01 32             call    SMSER1          ; Sum the series
4765+ 31C9 11 00 00             ld      DE,$0000        ; Zero LSBs
4766+ 31CC C1                   pop     BC              ; Scaling factor
4767+ 31CD 4A                   ld      C,D             ; Zero MSB
4768+ 31CE C3 4E 2D             jp      FPMULT          ; Scale result to correct value
4769+ 31D1
4770+ 31D1 08           EXPTAB: defb    $08             ; Table used by EXP
4771+ 31D2 40 2E 94 74          defb    $40,$2E,$94,$74 ; -1/7! (-1/5040)
4772+ 31D6 70 4F 2E 77          defb    $70,$4F,$2E,$77 ;  1/6! ( 1/720)
4773+ 31DA 6E 02 88 7A          defb    $6E,$02,$88,$7A ; -1/5! (-1/120)
4774+ 31DE E6 A0 2A 7C          defb    $E6,$A0,$2A,$7C ;  1/4! ( 1/24)
4775+ 31E2 50 AA AA 7E          defb    $50,$AA,$AA,$7E ; -1/3! (-1/6)
4776+ 31E6 FF FF 7F 7F          defb    $FF,$FF,$7F,$7F ;  1/2! ( 1/2)
4777+ 31EA 00 00 80 81          defb    $00,$00,$80,$81 ; -1/1! (-1/1)
4778+ 31EE 00 00 00 81          defb    $00,$00,$00,$81 ;  1/0! ( 1/1)
4779+ 31F2
4780+ 31F2 CD DB 2E     SUMSER: call    STAKFP          ; Put FPREG on stack
4781+ 31F5 11 4C 2D             ld      DE,MULT         ; Multiply by "X"
4782+ 31F8 D5                   push    DE              ; To be done after
4783+ 31F9 E5                   push    HL              ; Save address of table
4784+ 31FA CD F6 2E             call    BCDEFP          ; Move FPREG to BCDE
4785+ 31FD CD 4E 2D             call    FPMULT          ; Square the value
4786+ 3200 E1                   pop     HL              ; Restore address of table
4787+ 3201 CD DB 2E     SMSER1: call    STAKFP          ; Put value on stack
4788+ 3204 7E                   ld      A,(HL)          ; Get number of coefficients
4789+ 3205 23                   inc     HL              ; Point to start of table
4790+ 3206 CD E8 2E             call    PHLTFP          ; Move coefficient to FPREG
4791+ 3209 06                   defb    06H             ; Skip "pop AF"
4792+ 320A F1           SUMLP:  pop     AF              ; Restore count
4793+ 320B C1                   pop     BC              ; Restore number
4794+ 320C D1                   pop     DE
4795+ 320D 3D                   dec     A               ; Cont coefficients
4796+ 320E C8                   ret     Z               ; All done
4797+ 320F D5                   push    DE              ; Save number
4798+ 3210 C5                   push    BC
4799+ 3211 F5                   push    AF              ; Save count
4800+ 3212 E5                   push    HL              ; Save address in table
4801+ 3213 CD 4E 2D             call    FPMULT          ; Multiply FPREG by BCDE
4802+ 3216 E1                   pop     HL              ; Restore address in table
4803+ 3217 CD F9 2E             call    LOADFP          ; Number at HL to BCDE
4804+ 321A E5                   push    HL              ; Save address in table
4805+ 321B CD 13 2C             call    FPADD           ; Add coefficient to FPREG
4806+ 321E E1                   pop     HL              ; Restore address in table
4807+ 321F C3 0A 32             jp      SUMLP           ; More coefficients
4808+ 3222
4809+ 3222
4810+ 3222              ; random number generator
4811+ 3222              ; a negative argument is used as a seed for the RNG
4812+ 3222              ; 0 is used to repeat the last random number
4813+ 3222              ; a positive argument generates a new random number
4814+ 3222 CD AA 2E     RND:    call    TSTSGN          ; Test sign of FPREG
4815+ 3225 21 BF 51             ld      HL,SEED+2       ; Random number seed
4816+ 3228 FA 83 32             jp      M,RESEED        ; Negative - Re-seed
4817+ 322B 21 E0 51             ld      HL,LSTRND       ; Last random number
4818+ 322E CD E8 2E             call    PHLTFP          ; Move last RND to FPREG
4819+ 3231 21 BF 51             ld      HL,SEED+2       ; Random number seed
4820+ 3234 C8                   ret     Z               ; Return if RND(0)
4821+ 3235 86                   add     A,(HL)          ; Add (SEED)+2)
4822+ 3236 E6 07                and     %00000111       ; 0 to 7
4823+ 3238 06 00                ld      B,$00
4824+ 323A 77                   ld      (HL),A          ; Re-save seed
4825+ 323B 23                   inc     HL              ; Move to coefficient table
4826+ 323C 87                   add     A,A             ; 4 bytes
4827+ 323D 87                   add     A,A             ; per entry
4828+ 323E 4F                   ld      C,A             ; BC = Offset into table
4829+ 323F 09                   add     HL,BC           ; Point to coefficient
4830+ 3240 CD F9 2E             call    LOADFP          ; Coefficient to BCDE
4831+ 3243 CD 4E 2D             call    FPMULT  ;       ; Multiply FPREG by coefficient
4832+ 3246 3A BE 51             ld      A,(SEED+1)      ; Get (SEED+1)
4833+ 3249 3C                   inc     A               ; Add 1
4834+ 324A E6 03                and     %00000011       ; 0 to 3
4835+ 324C 06 00                ld      B,$00
4836+ 324E FE 01                cp      $01             ; Is it zero?
4837+ 3250 88                   adc     A,B             ; Yes - Make it 1
4838+ 3251 32 BE 51             ld      (SEED+1),A      ; Re-save seed
4839+ 3254 21 87 32             ld      HL,RNDTAB-4     ; Addition table
4840+ 3257 87                   add     A,A             ; 4 bytes
4841+ 3258 87                   add     A,A             ; per entry
4842+ 3259 4F                   ld      C,A             ; BC = Offset into table
4843+ 325A 09                   add     HL,BC           ; Point to value
4844+ 325B CD 04 2C             call    ADDPHL          ; Add value to FPREG
4845+ 325E CD F6 2E     RND1:   call    BCDEFP          ; Move FPREG to BCDE
4846+ 3261 7B                   ld      A,E             ; Get LSB
4847+ 3262 59                   ld      E,C             ; LSB = MSB
4848+ 3263 EE 4F                xor     %01001111       ; Fiddle around
4849+ 3265 4F                   ld      C,A             ; New MSB
4850+ 3266 36 80                ld      (HL),$80        ; Set exponent
4851+ 3268 2B                   dec     HL              ; Point to MSB
4852+ 3269 46                   ld      B,(HL)          ; Get MSB
4853+ 326A 36 80                ld      (HL),$80        ; Make value -0.5
4854+ 326C 21 BD 51             ld      HL,SEED         ; Random number seed
4855+ 326F 34                   inc     (HL)            ; Count seed
4856+ 3270 7E                   ld      A,(HL)          ; Get seed
4857+ 3271 D6 AB                sub     $AB             ; Do it modulo 171
4858+ 3273 C2 7A 32             jp      NZ,RND2         ; Non-zero - Ok
4859+ 3276 77                   ld      (HL),A          ; Zero seed
4860+ 3277 0C                   inc     C               ; Fillde about
4861+ 3278 15                   dec     D               ; with the
4862+ 3279 1C                   inc     E               ; number
4863+ 327A CD 64 2C     RND2:   call    BNORM           ; Normalise number
4864+ 327D 21 E0 51             ld      HL,LSTRND       ; Save random number
4865+ 3280 C3 02 2F             jp      FPTHL           ; Move FPREG to last and return
4866+ 3283
4867+ 3283 77           RESEED: ld      (HL),A          ; Re-seed random numbers
4868+ 3284 2B                   dec     HL
4869+ 3285 77                   ld      (HL),A
4870+ 3286 2B                   dec     HL
4871+ 3287 77                   ld      (HL),A
4872+ 3288 C3 5E 32             jp      RND1            ; Return RND seed
4873+ 328B
4874+ 328B 68 B1 46 68  RNDTAB: defb    $68,$B1,$46,$68 ; Table used by RND
4875+ 328F 99 E9 92 69          defb    $99,$E9,$92,$69
4876+ 3293 10 D1 75 68          defb    $10,$D1,$75,$68
4877+ 3297
4878+ 3297              ; COS and SIN functions
4879+ 3297 21 E1 32     COS:    ld      HL,HALFPI       ; Point to PI/2
4880+ 329A CD 04 2C             call    ADDPHL          ; Add it to PPREG
4881+ 329D CD DB 2E     SIN:    call    STAKFP          ; Put angle on stack
4882+ 32A0 01 49 83             ld      BC,$8349        ; BCDE = 2 PI
4883+ 32A3 11 DB 0F             ld      DE,$0FDB
4884+ 32A6 CD EB 2E             call    FPBCDE          ; Move 2 PI to FPREG
4885+ 32A9 C1                   pop     BC              ; Restore angle
4886+ 32AA D1                   pop     DE
4887+ 32AB CD 00 2E             call    DVBCDE          ; Divide angle by 2 PI
4888+ 32AE CD DB 2E             call    STAKFP          ; Put it on stack
4889+ 32B1 CD 7D 2F             call    INT             ; Get INT of result
4890+ 32B4 C1                   pop     BC              ; Restore number
4891+ 32B5 D1                   pop     DE
4892+ 32B6 CD 10 2C             call    SUBCDE          ; Make it 0 <= value < 1
4893+ 32B9 21 E5 32             ld      HL,QUARTR       ; Point to 0.25
4894+ 32BC CD 0A 2C             call    SUBPHL          ; Subtract value from 0.25
4895+ 32BF CD AA 2E             call    TSTSGN          ; Test sign of value
4896+ 32C2 37                   scf                     ; Flag positive
4897+ 32C3 F2 CD 32             jp      P,SIN1          ; Positive - Ok
4898+ 32C6 CD 01 2C             call    ROUND           ; Add 0.5 to value
4899+ 32C9 CD AA 2E             call    TSTSGN          ; Test sign of value
4900+ 32CC B7                   or      A               ; Flag negative
4901+ 32CD F5           SIN1:   push    AF              ; Save sign
4902+ 32CE F4 D3 2E             call    P,INVSGN        ; Negate value if positive
4903+ 32D1 21 E5 32             ld      HL,QUARTR       ; Point to 0.25
4904+ 32D4 CD 04 2C             call    ADDPHL          ; Add 0.25 to value
4905+ 32D7 F1                   pop     AF              ; Restore sign
4906+ 32D8 D4 D3 2E             call    NC,INVSGN       ; Negative - Make positive
4907+ 32DB 21 E9 32             ld      HL,SINTAB       ; Coefficient table
4908+ 32DE C3 F2 31             jp      SUMSER          ; Evaluate sum of series
4909+ 32E1
4910+ 32E1 DB 0F 49 81  HALFPI: defb    $DB,$0F,$49,$81 ; 1.5708 (PI/2)
4911+ 32E5
4912+ 32E5 00 00 00 7F  QUARTR: defb    $00,$00,$00,$7F ; 0.25
4913+ 32E9
4914+ 32E9 05           SINTAB: defb    $05             ; Table used by SIN
4915+ 32EA BA D7 1E 86          defb    $BA,$D7,$1E,$86 ; 39.711
4916+ 32EE 64 26 99 87          defb    $64,$26,$99,$87 ;-76.575
4917+ 32F2 58 34 23 87          defb    $58,$34,$23,$87 ; 81.602
4918+ 32F6 E0 5D A5 86          defb    $E0,$5D,$A5,$86 ;-41.342
4919+ 32FA DA 0F 49 83          defb    $DA,$0F,$49,$83 ;  6.2832
4920+ 32FE
4921+ 32FE CD DB 2E     TAN:    call    STAKFP          ; Put angle on stack
4922+ 3301 CD 9D 32             call    SIN             ; Get SIN of angle
4923+ 3304 C1                   pop     BC              ; Restore angle
4924+ 3305 E1                   pop     HL
4925+ 3306 CD DB 2E             call    STAKFP          ; Save SIN of angle
4926+ 3309 EB                   ex      DE,HL           ; BCDE = Angle
4927+ 330A CD EB 2E             call    FPBCDE          ; Angle to FPREG
4928+ 330D CD 97 32             call    COS             ; Get COS of angle
4929+ 3310 C3 FE 2D             jp      DIV             ; TAN = SIN / COS
4930+ 3313
4931+ 3313 CD AA 2E     ATN:    call    TSTSGN          ; Test sign of value
4932+ 3316 FC 3E 31             call    M,NEGAFT        ; Negate result after if -ve
4933+ 3319 FC D3 2E             call    M,INVSGN        ; Negate value if -ve
4934+ 331C 3A 79 53             ld      A,(FPEXP)       ; Get exponent
4935+ 331F FE 81                cp      81H             ; Number less than 1?
4936+ 3321 DA 30 33             jp      C,ATN1          ; Yes - Get arc tangnt
4937+ 3324 01 00 81             ld      BC,$8100        ; BCDE = 1
4938+ 3327 51                   ld      D,C
4939+ 3328 59                   ld      E,C
4940+ 3329 CD 00 2E             call    DVBCDE          ; Get reciprocal of number
4941+ 332C 21 0A 2C             ld      HL,SUBPHL       ; Sub angle from PI/2
4942+ 332F E5                   push    HL              ; Save for angle > 1
4943+ 3330 21 3A 33     ATN1:   ld      HL,ATNTAB       ; Coefficient table
4944+ 3333 CD F2 31             call    SUMSER          ; Evaluate sum of series
4945+ 3336 21 E1 32             ld      HL,HALFPI       ; PI/2 - angle in case > 1
4946+ 3339 C9                   ret                     ; Number > 1 - Sub from PI/2
4947+ 333A
4948+ 333A 09           ATNTAB: defb    $09             ; Table used by ATN
4949+ 333B 4A D7 3B 78          defb    $4A,$D7,$3B,$78 ; 1/17
4950+ 333F 02 6E 84 7B          defb    $02,$6E,$84,$7B ;-1/15
4951+ 3343 FE C1 2F 7C          defb    $FE,$C1,$2F,$7C ; 1/13
4952+ 3347 74 31 9A 7D          defb    $74,$31,$9A,$7D ;-1/11
4953+ 334B 84 3D 5A 7D          defb    $84,$3D,$5A,$7D ; 1/9
4954+ 334F C8 7F 91 7E          defb    $C8,$7F,$91,$7E ;-1/7
4955+ 3353 E4 BB 4C 7E          defb    $E4,$BB,$4C,$7E ; 1/5
4956+ 3357 6C AA AA 7F          defb    $6C,$AA,$AA,$7F ;-1/3
4957+ 335B 00 00 00 81          defb    $00,$00,$00,$81 ; 1/1
4958+ 335F
4959+ 335F
4960+ 335F C9           ARET:   ret                     ; A RETurn instruction
4961+ 3360
4962+ 3360 D7           GETINP: rst     $10             ; input a character
4963+ 3361 C9                   ret
4964+ 3362
4965+ 3362 E5           CLS:    push    HL
4966+ 3363 D5                   push    DE
4967+ 3364 3A 14 53             ld      A,(SCR_MODE)    ; check screen mode
4968+ 3367 FE 02                cp      $02             ; G2 mode?
4969+ 3369 CC CC 05             call    Z,EMPTYVIDBUF   ; yes, reset video buffer
4970+ 336C D1                   pop     DE
4971+ 336D E1                   pop     HL
4972+ 336E 3E 0C                ld      A,CS            ; ASCII Clear screen
4973+ 3370 CD 01 1A             call    SND2VID         ; send to screen
4974+ 3373 C3 B7 3F             jp      MONOUT          ; Output character
4975+ 3376
4976+ 3376 CD 23 29     WIDTH:  call    GETINT          ; Get integer 0-255
4977+ 3379 7B                   ld      A,E             ; Width to A
4978+ 337A 32 E7 51             ld      (LWIDTH),A      ; Set width
4979+ 337D C9                   ret
4980+ 337E
4981+ 337E
4982+ 337E              ; read a word (2 bytes) from a couple of RAM locations, in little-endian format
4983+ 337E              ; i.e., the first location is the LSB, while the second one is the MSB
4984+ 337E CD C2 1C     DEEK:   call    DEINT           ; Get integer -32768 to 32767
4985+ 3381 D5                   push    DE              ; Save number
4986+ 3382 E1                   pop     HL              ; Number to HL
4987+ 3383 46           RECWRD: ld      B,(HL)          ; Get LSB of contents
4988+ 3384 23                   inc     HL
4989+ 3385 7E                   ld      A,(HL)          ; Get MSB of contents
4990+ 3386 C3 87 24             jp      ABPASS          ; Return integer AB
4991+ 3389
4992+ 3389              ; write a word (2 bytes) into a couple of RAM locations, in little-endian format
4993+ 3389              ; i.e., the LSB will go into the first location, while the MSB into the second one
4994+ 3389 CD 9D 20     DOKE:   call    GETNUM          ; Get a number
4995+ 338C CD C2 1C             call    DEINT           ; Get integer -32768 to 32767
4996+ 338F D5                   push    DE              ; Save address
4997+ 3390 CD C3 19             call    CHKSYN          ; Make sure ',' follows
4998+ 3393 2C                   defb    ','
4999+ 3394 CD 9D 20             call    GETNUM          ; Get a number
5000+ 3397 CD C2 1C             call    DEINT           ; Get integer -32768 to 32767
5001+ 339A E3                   ex      (SP),HL         ; Save value,get address
5002+ 339B 73                   ld      (HL),E          ; Save LSB of value
5003+ 339C 23                   inc     HL
5004+ 339D 72                   ld      (HL),D          ; Save MSB of value
5005+ 339E E1                   pop     HL              ; Restore code string address
5006+ 339F C9                   ret
5007+ 33A0
5008+ 33A0              ; stop the execution of code for a certain bit of time. The pause
5009+ 33A0              ; is between $0000 and $FFFF 100ths of a second (0~655.5 secs)
5010+ 33A0 CD 9D 20     PAUSE:  call    GETNUM          ; Get a number
5011+ 33A3 CD C2 1C             call    DEINT           ; Get integer -32768 to 32767
5012+ 33A6 7A                   ld      A,D             ; load D into A
5013+ 33A7 B3                   or      E               ; are D & E equal to $00?
5014+ 33A8 C8                   ret     Z               ; if yes, then return
5015+ 33A9 C5           DIR_PAU:push    BC              ; store BC
5016+ 33AA 3A 02 53             ld      A,(TMRCNT)      ; Load current value of system timer
5017+ 33AD 47                   ld      B,A             ; move it into B
5018+ 33AE CD 37 1C     RPTPS:  call    TSTBRK          ; Test for break key
5019+ 33B1 3A 02 53             ld      A,(TMRCNT)      ; Load current value of system timer
5020+ 33B4 B8                   cp      B               ; is it the same value?
5021+ 33B5 28 F7                jr      Z,RPTPS         ; yes, so read again
5022+ 33B7 47                   ld      B,A             ; no, so store the new value
5023+ 33B8 1B                   dec     DE              ; decrement interval
5024+ 33B9 7A                   ld      A,D             ; load D into A
5025+ 33BA B3                   or      E               ; check if DE is equal to 0 (if D & e are $00 then result is 0)
5026+ 33BB 20 F1                jr      NZ,RPTPS        ; no, repeat
5027+ 33BD C1                   pop     BC              ; yes, recover BC and continue
5028+ 33BE C9                   ret
5029+ 33BF
5030+ 33BF              ; change the screen mode and set some graphic features. Usage: SCREEN X[,Y][,Z]
5031+ 33BF              ; where X is graphic mode:
5032+ 33BF              ; 0=text mode (40x24), 1=graphic mode 1 (32x24 chars); 2=graphic mode 2 (256x192 pixels);
5033+ 33BF              ; 3=multicolor mode (64x48 pixels); 4=extended graphic mode 2 (32x24 chars mixed between G1 and G2)
5034+ 33BF              ; Y is: 0=8x8 sprites, 1=16x16 sprites
5035+ 33BF              ; Z is: 0=no sprite magnification; 1=sprite magnification x2 (8x8=>16x16, and 16x16=32x32)
5036+ 33BF              ; (the latters are accepted only in graphic modes G1, G2, G3, and G4)
5037+ 33BF AF           SCREEN: xor     A
5038+ 33C0 32 24 53             ld      (TMPBFR2),A     ; sprite size & magnif. byte set to 0
5039+ 33C3 CD 23 29             call    GETINT          ; Get integer 0-255
5040+ 33C6 FE 05                cp      $05             ; is it a valid mode (0~4)?
5041+ 33C8 D2 D7 1C             jp      NC,FCERR        ; No - Illegal function call Error
5042+ 33CB 32 22 53             ld      (TMPBFR1),A     ; store graphic mode
5043+ 33CE A7                   and     A               ; is it 0 (text mode)?
5044+ 33CF CA EB 33             jp      Z,SCVDP         ; yes, ignore other arguments and set mode immediately
5045+ 33D2 CD 2A 34     SETVDP: call    CHKSCAR         ; no, check if sprite size follows
5046+ 33D5 DA DD 33             jp      C,CKMAGN        ; no (set to 0 or missing), so jump over
5047+ 33D8 3E 02                ld      A,$02           ; no, so set sprite size
5048+ 33DA 32 24 53             ld      (TMPBFR2),A     ; ...to 16x16
5049+ 33DD CD 2A 34     CKMAGN: call    CHKSCAR         ; check if sprite magnification follows
5050+ 33E0 DA EB 33             jp      C,SCVDP         ; no (set to 0 or missing), so jump over
5051+ 33E3 3A 24 53             ld      A,(TMPBFR2)     ; yes, so retrieve sprite attributes...
5052+ 33E6 F6 01                or      $01             ; ...set sprite magnification to 2x...
5053+ 33E8 32 24 53             ld      (TMPBFR2),A     ; ...and save flags again
5054+ 33EB F3           SCVDP:  di                      ; disable INTs
5055+ 33EC D5                   push    DE              ; store DE
5056+ 33ED E5                   push    HL              ; store HL
5057+ 33EE 3A 22 53             ld      A,(TMPBFR1)     ; recover graphic mode
5058+ 33F1 5F                   ld      E,A             ; and store it into E
5059+ 33F2 3A 24 53             ld      A,(TMPBFR2)     ; recover sprite flags
5060+ 33F5 57                   ld      D,A             ; and store them into D
5061+ 33F6 D5                   push    DE              ; store D & E
5062+ 33F7 CD D1 03             call    initVDP         ; initialize VDP with mode pointed by E
5063+ 33FA D1                   pop     DE              ; retrieve D & E
5064+ 33FB 7B                   ld      A,E             ; move graphic mode into A
5065+ 33FC 87                   add     A,A
5066+ 33FD 87                   add     A,A
5067+ 33FE 87                   add     A,A             ; multiply A times 8 to get offset of graphic mode
5068+ 33FF 5F                   ld      E,A             ; and pass it into E
5069+ 3400 D5                   push    DE              ; store sprite flags in E
5070+ 3401 16 00                ld      D,$00           ; reset D
5071+ 3403 21 14 0B             ld      HL,VDPMODESET+1 ; load address of VDP settings for reg#1
5072+ 3406 19                   add     HL,DE           ; load correct reg#1 setting
5073+ 3407 D1                   pop     DE              ; retrieve sprite flags from E
5074+ 3408 7E                   ld      A,(HL)          ; load reg#1 setting
5075+ 3409 E6 FC                and     %11111100       ; reset size & magn. bits
5076+ 340B B2                   or      D               ; set size & magn. bits
5077+ 340C 5F                   ld      E,A             ; value into E
5078+ 340D 3E 01                ld      A,$01           ; reg #1
5079+ 340F CD A4 06             call    WRITE_VREG      ; send setting to reg #1
5080+ 3412 2A F4 51             ld      HL,(LINEAT)     ; Get current line number
5081+ 3415 23                   inc     HL              ; -1 means direct statement
5082+ 3416 7C                   ld      A,H
5083+ 3417 B5                   or      L
5084+ 3418 CC 17 09             call    Z,CURSOR_ON     ; enable cursor if not in program mode
5085+ 341B FB                   ei                      ; re-enable interrupts
5086+ 341C E1                   pop     HL              ; restore HL
5087+ 341D D1                   pop     DE              ; restore DE
5088+ 341E 3A 13 53             ld      A,(SCR_SIZE_H)  ; check the screen mode by looking at the screen height
5089+ 3421 FE 30                cp      $30             ; is it 48 chars or 192 pixels (MC and G2 modes)?
5090+ 3423 D0                   ret     NC              ; yes, so exit (in graphics 2 and multicolor no print-on-video)
5091+ 3424 3E 01                ld      A,$01           ; no (we are in Text, G1 or ExG2), so activate the...
5092+ 3426 32 1E 53             ld      (PRNTVIDEO),A   ; ...video buffer...
5093+ 3429 C9                   ret                     ; ...and return to caller
5094+ 342A
5095+ 342A              ; check an additional argument for SCREEN - There are 2 ways of working:
5096+ 342A              ; to check if something follows: Carry is 1 is no argument follows, 0 otherwise
5097+ 342A              ; to check the value of the following argument: 0 is argument is 1, 1 is argument is <> 1
5098+ 342A 2B           CHKSCAR:dec     HL              ; dec 'cos GETCHR INCs
5099+ 342B CD 0C 1C             call    GETCHR          ; Get next character
5100+ 342E 37                   scf                     ; set carry flag
5101+ 342F C8                   ret     Z               ; return if nothing follows with Carry=1
5102+ 3430 CD C3 19             call    CHKSYN          ; Make sure ',' follows
5103+ 3433 2C                   defb    ','
5104+ 3434 CD 23 29             call    GETINT          ; get value
5105+ 3437 1F                   rra                     ; Carry=bit #0
5106+ 3438 3F                   ccf                     ; invert Carry, so Carry=0 if arg. is 1, and Carry=1 otherwise (arg<>1)
5107+ 3439 C9                   ret                     ; return
5108+ 343A
5109+ 343A
5110+ 343A              ; change the colors of the screen - Syntax is COLOR a,b,c where:
5111+ 343A              ; a=foreground color / b=background color / c=border color
5112+ 343A              ; a,b,c must be in a range between 1 and 15 (0 is transparent and it's not supported)
5113+ 343A              ; the number of arguments is based on the current screen mode
5114+ 343A CD 23 29     COLOR:  call    GETINT          ; get first value
5115+ 343D CD E2 34             call    CHKCLR1         ; check if it's in range 1~15
5116+ 3440 32 22 53             ld      (TMPBFR1),A     ; store it
5117+ 3443 3A 14 53             ld      A,(SCR_MODE)    ; check screen mode
5118+ 3446 FE 03                cp      $03             ; is it multicolor mode?
5119+ 3448 20 0D                jr      NZ,CNTCKCL      ; no, continue
5120+ 344A 3E 0F                ld      A,$0F           ; white for...
5121+ 344C 32 20 53             ld      (FRGNDCLR),A    ; ...foreground (even it's not used in MC)
5122+ 344F 3A 22 53             ld      A,(TMPBFR1)     ; yes, so we stop here because in MC mode we just support border color
5123+ 3452 32 26 53             ld      (TMPBFR3),A     ; move color into temp buffer 3
5124+ 3455 18 31                jr      CLRMC           ; jump to set color
5125+ 3457 CD C3 19     CNTCKCL:call    CHKSYN          ; Make sure ',' follows
5126+ 345A 2C                   defb    ','
5127+ 345B CD 23 29             call    GETINT          ; get second value
5128+ 345E CD E2 34             call    CHKCLR1         ; check if it's in range 1~15
5129+ 3461 32 24 53             ld      (TMPBFR2),A     ; store it
5130+ 3464 3A 14 53             ld      A,(SCR_MODE)    ; check screen mode
5131+ 3467 A7                   and     A               ; is it text mode?
5132+ 3468 28 1B                jr      Z,CLRTXT        ; yes, stop here because in text mode, background and border colors coincide
5133+ 346A CD C3 19             call    CHKSYN          ; Make sure ',' follows
5134+ 346D 2C                   defb    ','
5135+ 346E CD 23 29             call    GETINT          ; get third value
5136+ 3471 CD E2 34             call    CHKCLR1         ; check if it's in range 1~15
5137+ 3474 32 26 53             ld      (TMPBFR3),A     ; store it
5138+ 3477 D5                   push    DE              ; store DE
5139+ 3478 3A 14 53             ld      A,(SCR_MODE)    ; check screen mode
5140+ 347B FE 01                cp      $01             ; is it G1 mode?
5141+ 347D 28 10                jr      Z,CLRG1         ; yes, jump over
5142+ 347F FE 02                cp      $02             ; is it G2 mode?
5143+ 3481 28 15                jr      Z,CLRG2         ; yes, jump over
5144+ 3483 18 1C                jr      CLREX2          ; last case can only be ExG2
5145+ 3485 CD D5 34     CLRTXT: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5146+ 3488 32 26 53     CLRMC:  ld      (TMPBFR3),A     ; store color settings (for MC mode, we only set border color)
5147+ 348B D5                   push    DE              ; store DE
5148+ 348C F3                   di                      ; disable INTs
5149+ 348D 18 2D                jr      SETBRCL         ; set colors and exit
5150+ 348F CD D5 34     CLRG1:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5151+ 3492 16 01                ld      D,$01           ; repeat 1 time
5152+ 3494 06 20                ld      B,$20           ; 32 bytes of colors
5153+ 3496 18 10                jr      LOADCLR         ; load colors
5154+ 3498 CD D5 34     CLRG2:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5155+ 349B 16 18                ld      D,$18           ; 18 pages of...
5156+ 349D 06 00                ld      B,$00           ; ...256 bytes each
5157+ 349F 18 07                jr      LOADCLR         ; load colors
5158+ 34A1 CD D5 34     CLREX2: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5159+ 34A4 16 08                ld      D,$08           ; 8 pages of...
5160+ 34A6 06 00                ld      B,$00           ; ...256 bytes each
5161+ 34A8 E5           LOADCLR:push    HL              ; store HL
5162+ 34A9 21 00 20             ld      HL,$2000        ; color table start: $2000
5163+ 34AC F3                   di                      ; disable INTs
5164+ 34AD CD 5A 06             call    SETVDPADRS
5165+ 34B0 0D                   dec     C              ; VDP data mode
5166+ 34B1 ED 79        RPTLDCL:out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
5167+ 34B3 00                   nop
5168+ 34B4 00                   nop
5169+ 34B5 10 FA                djnz    RPTLDCL         ; repeat for 256 bytes (1 page)
5170+ 34B7 15                   dec     D               ; did we fill up all the pages?
5171+ 34B8 20 F7                jr      NZ,RPTLDCL      ; no, repeat
5172+ 34BA FB                   ei
5173+ 34BB E1                   pop     HL              ; retrieve HL
5174+ 34BC 3A 22 53     SETBRCL:ld      A,(TMPBFR1)     ; retrieve foreground color
5175+ 34BF 32 20 53             ld      (FRGNDCLR),A    ; store it
5176+ 34C2 3A 24 53             ld      A,(TMPBFR2)     ; retrieve background color
5177+ 34C5 32 21 53             ld      (BKGNDCLR),A    ; store it
5178+ 34C8 3A 26 53             ld      A,(TMPBFR3)     ; recover border color
5179+ 34CB 5F                   ld      E,A             ; move it into E
5180+ 34CC 3E 07                ld      A,$07           ; set VDP register 7
5181+ 34CE F3                   di
5182+ 34CF CD A4 06             call    WRITE_VREG      ; send value to VDP: set border color
5183+ 34D2 FB                   ei                      ; re-enable INTs
5184+ 34D3 D1                   pop     DE              ; retrieve DE
5185+ 34D4 C9                   ret                     ; return to caller
5186+ 34D5
5187+ 34D5
5188+ 34D5              ; mix 2 color nibbles in 1 byte
5189+ 34D5 3A 24 53     MIXCLRS:ld      A,(TMPBFR2)     ; retrieve background color
5190+ 34D8 47                   ld      B,A             ; move it into B
5191+ 34D9 3A 22 53             ld      A,(TMPBFR1)     ; retrieve foreground color
5192+ 34DC 87                   add     A,A             ; move foreground color into the high nibble of A
5193+ 34DD 87                   add     A,A
5194+ 34DE 87                   add     A,A
5195+ 34DF 87                   add     A,A
5196+ 34E0 B0                   or      B               ; put background color into the low nibble of A
5197+ 34E1 C9                   ret                     ; return to caller
5198+ 34E2
5199+ 34E2
5200+ 34E2              ; check if the color is not 0 and into the range 1~15
5201+ 34E2 A7           CHKCLR1:and     A               ; is it 0?
5202+ 34E3 CA C9 16             jp      Z,SNERR         ; yes, raise a SN error
5203+ 34E6 FE 10        CHKCLR0:cp      $10             ; is it in range 0~15?
5204+ 34E8 D2 C9 16             jp      NC,SNERR        ; no, raise a SN error
5205+ 34EB C9                   ret                     ; param is OK, can return
5206+ 34EC
5207+ 34EC
5208+ 34EC              ; check if in graphics 2 mode
5209+ 34EC 3A 14 53     CHKG2M: ld      A,(SCR_MODE)    ; check screen mode
5210+ 34EF FE 02                cp      $02             ; actually, we can paint only in G2
5211+ 34F1 C2 F1 3A             jp      NZ,GMERR        ; no G2, print a No Graphics Mode Error
5212+ 34F4 C9                   ret                     ; return to caller
5213+ 34F5
5214+ 34F5
5215+ 34F5              ; print a text in screen 2
5216+ 34F5              ; GPRINT text,x,y[,fc[,bc]]
5217+ 34F5              ; where "text" is an expression that can be converted into a sequence of ASCII chars,
5218+ 34F5              ; x & y are the coordinates (0<=x<=31, 0<=y<=23), fc & bc are foreground and background
5219+ 34F5              ; colors (1~15), resp.
5220+ 34F5              ; (portions of code are from nippur72)
5221+ 34F5              GX      equ     TMPBFR3
5222+ 34F5              GY      equ     TMPBFR4
5223+ 34F5              TMPCLR  equ     TMPBFR2
5224+ 34F5              MIXCOL  equ     TMPBFR1
5225+ 34F5              TMPADR  equ     VIDEOBUFF
5226+ 34F5              CHRPNT  equ     VIDEOBUFF+$02
5227+ 34F5              NUMCHR  equ     VIDEOBUFF+$04
5228+ 34F5              TMPHL   equ     VIDEOBUFF+$06
5229+ 34F5 CD EC 34     GPRINT: call    CHKG2M          ; check if in graphic mode 2
5230+ 34F8 2B                   dec     HL              ; dec 'cos GETCHR INCs
5231+ 34F9 CD 0C 1C             call    GETCHR          ; check if something follows
5232+ 34FC CA C9 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
5233+ 34FF 22 2A 53             ld      (VIDEOBUFF),HL  ; save current code string pointer
5234+ 3502 CD AF 20             call    EVAL            ; Evaluate expression
5235+ 3505 CD A1 20             call    TSTSTR          ; Make sure it's a string
5236+ 3508 22 30 53             ld      (TMPHL),HL      ; store code string pointer
5237+ 350B CD E8 26             call    GSTRCU          ; Current string to pool
5238+ 350E CD F9 2E             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
5239+ 3511 ED 43 2C 53          ld      (CHRPNT),BC     ; store string pointer
5240+ 3515 ED 53 2E 53          ld      (NUMCHR),DE     ; store string lenght
5241+ 3519 2A 30 53             ld      HL,(TMPHL)      ; store code string pointer
5242+ 351C CD C3 19             call    CHKSYN          ; Make sure ',' follows
5243+ 351F 2C                   defb    ','
5244+ 3520 CD 23 29             call    GETINT          ; get X coord.
5245+ 3523 FE 20                cp      $20             ; is it in rage 0~31?
5246+ 3525 D2 D7 1C             jp      NC,FCERR        ; Illegal function call error
5247+ 3528 32 26 53             ld      (GX),A          ; store into temp. buffer
5248+ 352B CD C3 19             call    CHKSYN          ; Make sure ',' follows
5249+ 352E 2C                   defb    ','
5250+ 352F CD 23 29             call    GETINT          ; get Y coord.
5251+ 3532 FE 18                cp      $18             ; is it in range 0~23?
5252+ 3534 D2 D7 1C             jp      NC,FCERR        ; Illegal function call error
5253+ 3537 32 28 53             ld      (GY),A          ; store into temp. buffer
5254+ 353A 11 24 53             ld      DE,TMPCLR
5255+ 353D 3A 21 53             ld      A,(BKGNDCLR)    ; load background color
5256+ 3540 12                   ld      (DE),A          ; store into temp buff
5257+ 3541 3A 20 53             ld      A,(FRGNDCLR)    ; load foreground color
5258+ 3544 1B                   dec     DE
5259+ 3545 1B                   dec     DE
5260+ 3546 12                   ld      (DE),A          ; store into temp buff
5261+ 3547 CD D2 35             call    CKCOL           ; check color
5262+ 354A CA 52 35             jp      Z,CNTGPT2       ; if anything follows, jump over
5263+ 354D 13                   inc     DE
5264+ 354E 13                   inc     DE
5265+ 354F CD D2 35             call    CKCOL           ; check background color
5266+ 3552 CD D5 34     CNTGPT2:call    MIXCLRS         ; mix foreground & background colors
5267+ 3555 32 22 53             ld      (MIXCOL),A      ; store mixed colors
5268+ 3558 E5                   push    HL              ; store code string address
5269+ 3559 ED 4B 2C 53          ld      BC,(CHRPNT)     ; retrieve string pointer
5270+ 355D ED 5B 2E 53          ld      DE,(NUMCHR)     ; retrieve string lenght
5271+ 3561 1C                   inc     E               ; Length + 1
5272+ 3562 CD 67 35             call    GPNT            ; print on G2
5273+ 3565 E1                   pop     HL              ; recover HL
5274+ 3566 C9                   ret                     ; return to caller
5275+ 3567 D5           GPNT:   push    DE              ; store string lenght (E)
5276+ 3568                      ; calculate VRAM address of first char
5277+ 3568 3A 26 53             LD      A,(GX)          ; load X
5278+ 356B 6F                   ld      L,A             ;
5279+ 356C 26 00                ld      H,0             ; HL = X
5280+ 356E 29                   add     HL,HL           ;
5281+ 356F 29                   add     HL,HL           ;
5282+ 3570 29                   add     HL,HL           ; X=X*8
5283+ 3571 3A 28 53             ld      A,(GY)          ; load Y
5284+ 3574 57                   ld      D,A             ; move it into D
5285+ 3575 1E 00                ld      E,0             ; DE =Y*256
5286+ 3577 19                   add     HL,DE           ; address = X*8 + Y*256
5287+ 3578 22 2A 53             ld      (TMPADR),HL     ; store VRAM address of first VRAM cell
5288+ 357B D1                   pop     DE              ; retrieve # of chars to be printed yet (E)
5289+ 357C 1D           RPGPNT: dec     E               ; Count characters
5290+ 357D C8                   ret     Z               ; End of string - return
5291+ 357E D5                   push    DE              ; store chars counter
5292+ 357F                      ; calculate dest address in color vram
5293+ 357F 2A 2A 53             ld      HL,(TMPADR)     ; recover VRAM address
5294+ 3582 11 00 20             ld      DE,$2000        ; color map address
5295+ 3585 19                   add     HL,DE           ; HL = $2000 + XY address
5296+ 3586 F3                   di                      ; disable INTs
5297+ 3587                      ; send color settings
5298+ 3587 CD 5A 06     GPNTCOL:call    SETVDPADRS      ; set VRAM address for color cell
5299+ 358A 3A 22 53             ld      A,(MIXCOL)      ; load color settings
5300+ 358D 06 08                ld      B,$08           ; repeat for 8 rows
5301+ 358F 0E 30                ld      C,VDP_DAT       ; VDP data mode
5302+ 3591 ED 79        GPNTCO1:out     (C),A           ; send data (VRAM pointer auto-increments)
5303+ 3593 00                   nop                     ; wait...
5304+ 3594 00                   nop                     ; ...a...
5305+ 3595 00                   nop                     ; ...while
5306+ 3596 10 F9                djnz    GPNTCO1         ; repeat for 8 cells
5307+ 3598                      ; calculate source address
5308+ 3598 2A 2C 53             ld      HL,(CHRPNT)     ; load char pointer
5309+ 359B 7E                   ld      A,(HL)          ; get char
5310+ 359C 23                   inc     HL              ; increment char pointer
5311+ 359D 22 2C 53             ld      (CHRPNT),HL     ; store char pointer
5312+ 35A0 6F                   ld      L,A             ;
5313+ 35A1 26 00                ld      H,$00           ; char into HL
5314+ 35A3 29                   add     HL,HL           ;
5315+ 35A4 29                   add     HL,HL           ;
5316+ 35A5 29                   add     HL,HL           ; get offset of char into ROM (charcode * 8)
5317+ 35A6 11 41 48             ld      DE,CHRST88      ; DE = start of 8x8 fonts in ROM
5318+ 35A9 19                   add     HL,DE           ; HL = start of characters in ROM
5319+ 35AA EB                   ex      DE,HL           ; store address into DE
5320+ 35AB 2A 2A 53     GPCPCHR:ld      HL,(TMPADR)     ; load VRAM address
5321+ 35AE CD 5A 06             call    SETVDPADRS      ; send it to VDP
5322+ 35B1 EB                   ex      DE,HL           ; restore address into HL
5323+ 35B2 06 08                ld      B,$08           ; repeat for 8 rows
5324+ 35B4 0D                   dec     C              ; VDP data mode
5325+ 35B5 ED A3        GPCPCH1:outi                    ; load a byte from ROM and send to VRAM
5326+ 35B7 00                   nop                     ; wait...
5327+ 35B8 00                   nop                     ; ...a...
5328+ 35B9 00                   nop                     ; ...while
5329+ 35BA 20 F9                jr      NZ,GPCPCH1      ; repeat for 8 chars
5330+ 35BC FB                   ei                      ; re-enable INTs
5331+ 35BD 11 08 00             ld      DE,$0008        ; 8 bytes to go to the next video cell
5332+ 35C0 2A 2A 53             ld      HL,(TMPADR)     ; load VRAM address
5333+ 35C3 19                   add     HL,DE           ; get address of next VRAM cell
5334+ 35C4 22 2A 53             ld      (TMPADR),HL     ; store new VRAM address
5335+ 35C7 11 00 18             ld      DE,$1800        ; forbidden address
5336+ 35CA CD DE 3F             call    CMP16           ; check if the printing has gone out of the screen
5337+ 35CD D1                   pop     DE              ; retrieve number of chars to be printed
5338+ 35CE D0                   ret     NC              ; if HL>=$1800 then leave
5339+ 35CF C3 7C 35             jp      RPGPNT          ; otherwise, check if more chars to output
5340+ 35D2
5341+ 35D2              ; used by GPRINT to get a color argument (if present)
5342+ 35D2 2B           CKCOL:  dec     HL              ; dec 'cos GETCHR INCs
5343+ 35D3 CD 0C 1C             call    GETCHR          ; Get next character
5344+ 35D6 C8                   ret     Z               ; return if nothing follows
5345+ 35D7 CD C3 19             call    CHKSYN          ; Make sure ',' follows
5346+ 35DA 2C                   defb    ','
5347+ 35DB D5                   push    DE              ; store DE
5348+ 35DC CD 23 29             call    GETINT          ; get value
5349+ 35DF CD E2 34             call    CHKCLR1         ; check if color is in range 1~15
5350+ 35E2 D1                   pop     DE              ; retrieve DE
5351+ 35E3 12                   ld      (DE),A          ; store color into temp buffer
5352+ 35E4 C9                   ret                     ; return to caller
5353+ 35E5
5354+ 35E5
5355+ 35E5              ; paint X,Y[,C]: in graphics mode, fills an area starting
5356+ 35E5              ; at point X,Y, using default color or, if used, with
5357+ 35E5              ; color set by C
5358+ 35E5              ; TMPBFR1       X
5359+ 35E5              ; TMPBFR2       Y
5360+ 35E5              ; TMPBFR3       COLOR
5361+ 35E5              PNT     equ     VIDEOBUFF
5362+ 35E5              SPA     equ     VIDEOBUFF+$02
5363+ 35E5              SPB     equ     VIDEOBUFF+$03
5364+ 35E5              ORGSP   equ     VIDEOBUFF+$04
5365+ 35E5 CD EC 34     PAINT:  call    CHKG2M          ; check if in graphic mode 2
5366+ 35E8 CD 23 29             call    GETINT          ; get X
5367+ 35EB 32 22 53             ld      (TMPBFR1),A     ; store X
5368+ 35EE CD C3 19             call    CHKSYN          ; Make sure ',' follows
5369+ 35F1 2C                   defb    ','
5370+ 35F2 CD 23 29             call    GETINT          ; get Y coords,
5371+ 35F5 FE C0                cp      $C0             ; check if Y is in range 0~191
5372+ 35F7 D2 D7 1C             jp      NC,FCERR        ; no, raise an FC error
5373+ 35FA 32 24 53             ld      (TMPBFR2),A     ; store Y
5374+ 35FD CD D8 3A             call    CLRPRM          ; check if color has been passed
5375+ 3600 3A 26 53             ld      A,(TMPBFR3)     ; load color
5376+ 3603 A7                   and     A               ; check if 0
5377+ 3604 CA D7 1C             jp      Z,FCERR         ; yes, raise an error
5378+ 3607 E5                   push    HL              ; store HL
5379+ 3608 C5                   push    BC              ; store BC
5380+ 3609 D5                   push    DE              ; store DE
5381+ 360A                      ; start algorithm
5382+ 360A CD 1D 37             call    PNTRTN          ; check if pixel is already set
5383+ 360D C2 C1 36             jp      NZ,EXITPA2      ; if yes, then leave PAINT
5384+ 3610 ED 73 2E 53          ld      (ORGSP),SP      ; no, store current Stack Pointer
5385+ 3614 21 01 00             ld      HL,$0001        ; HL=1
5386+ 3617 22 2A 53             ld      (PNT),HL        ; set PNT
5387+ 361A 3A 22 53             ld      A,(TMPBFR1)     ; load starting X...
5388+ 361D 47                   ld      B,A             ; ...into B
5389+ 361E 3A 24 53             ld      A,(TMPBFR2)     ; load starting Y...
5390+ 3621 4F                   ld      C,A             ; ...into C
5391+ 3622 C5                   push    BC              ; store starting X,Y into stack
5392+ 3623                      ; main loop
5393+ 3623 2A 2A 53     NXTLOOP:ld      HL,(PNT)        ; retrieve PNT
5394+ 3626 7C                   ld      A,H             ; check if PNT=0
5395+ 3627 B5                   or      L
5396+ 3628 CA BD 36             jp      Z,EXITPAI       ; yes, no more points to process - exit
5397+ 362B 2B                   dec     HL              ; no, so decrement PNT...
5398+ 362C 22 2A 53             ld      (PNT),HL        ; ...and store it
5399+ 362F C1                   pop     BC              ; retrieve pixel coordinates X,Y into BC
5400+ 3630 CD C5 36     PAINT0: call    CHECKPA         ; check if pixel is set/reset
5401+ 3633 20 09                jr      NZ,PAINT11      ; pixel is set, so jump over
5402+ 3635 78                   ld      A,B             ; pixel is reset, check if X1=0
5403+ 3636 A7                   and     A               ; (reached the limit of the screen)
5404+ 3637 CA 3F 36             jp      Z,PAINT1        ; yes, jump over
5405+ 363A 05                   dec     B               ; no, decrement X1...
5406+ 363B C3 30 36             jp      PAINT0          ; ...and repeat
5407+ 363E 04           PAINT11:inc     B               ; if found a pixel on, the re-increment X1
5408+ 363F AF           PAINT1: xor     A               ; reset A
5409+ 3640 57                   ld      D,A             ; set SA=0
5410+ 3641 5F                   ld      E,A             ; set SB=0
5411+ 3642 CD C5 36     MNPAINT:call    CHECKPA         ; check if pixel is set/reset
5412+ 3645 20 DC                jr      NZ,NXTLOOP      ; it's set, so goto next loop
5413+ 3647 78                   ld      A,B             ; copy X1
5414+ 3648 32 22 53             ld      (TMPBFR1),A     ; into buffer
5415+ 364B 79                   ld      A,C             ; copy Y
5416+ 364C 32 24 53             ld      (TMPBFR2),A     ; into buffer
5417+ 364F CD 43 37             call    CNTPLOT         ; plot pixel X1,Y
5418+ 3652 7A                   ld      A,D             ; load SA into A
5419+ 3653 A7                   and     A               ; SA=0?
5420+ 3654 20 1C                jr      NZ,PAINT2       ; no, jump over
5421+ 3656 79                   ld      A,C             ; load Y
5422+ 3657 FE 01                cp      $01             ; Y>0?
5423+ 3659 DA 72 36             jp      C,PAINT2        ; no, jump over
5424+ 365C 3D                   dec     A               ; yes, Y=Y-1
5425+ 365D CD C6 36             call    CHECKPY         ; check pixel X1,Y-1
5426+ 3660 20 10                jr      NZ,PAINT2       ; it's set, so jump over
5427+ 3662 0D                   dec     C               ; Y=Y-1
5428+ 3663 C5                   push    BC              ; insert pixel(X1,Y-1) into stack
5429+ 3664 0C                   inc     C               ; retrieve original Y
5430+ 3665 2A 2A 53             ld      HL,(PNT)        ; load PNT
5431+ 3668 23                   inc     HL              ; increment PNT
5432+ 3669 22 2A 53             ld      (PNT),HL        ; store new PNT
5433+ 366C 3E 01                ld      A,$01           ; set SA=1 and...
5434+ 366E 57                   ld      D,A             ; ...store SA into memory
5435+ 366F C3 85 36             jp      PAINT3          ; jump over
5436+ 3672 7A           PAINT2: ld      A,D             ; load SA into A
5437+ 3673 1F                   rra                     ; check if SA=1
5438+ 3674 30 0F                jr      NC,PAINT3       ; no, jump over
5439+ 3676 79                   ld      A,C             ; load Y
5440+ 3677 FE 01                cp      $01             ; Y>0?
5441+ 3679 DA 85 36             jp      C,PAINT3        ; no, jump over
5442+ 367C 3D                   dec     A               ; Y=Y-1
5443+ 367D CD C6 36             call    CHECKPY         ; check pixel X1,Y-1
5444+ 3680 CA 85 36             jp      Z,PAINT3        ; if pixel is off, jump over
5445+ 3683 AF                   xor     A               ; pixel is on, so...
5446+ 3684 57                   ld      D,A             ; ...set SA=0
5447+ 3685 7B           PAINT3: ld      A,E             ; check if...
5448+ 3686 A7                   and     A               ; SB=0
5449+ 3687 20 1B                jr      NZ,PAINT4       ; no, jump over
5450+ 3689 79                   ld      A,C             ; load Y
5451+ 368A FE BF                cp      $BF             ; Y<191?
5452+ 368C 30 16                jr      NC,PAINT4       ; no, jump over
5453+ 368E 3C                   inc     A               ; Y=Y+1
5454+ 368F CD C6 36             call    CHECKPY         ; check pixel X1,Y+1
5455+ 3692 20 10                jr      NZ,PAINT4       ; pixel is on, so jump over
5456+ 3694 0C                   inc     C               ; Y=Y+1
5457+ 3695 C5                   push    BC              ; insert pixel(X1,Y+1) into stack
5458+ 3696 0D                   dec     C               ; retrieve original Y
5459+ 3697 2A 2A 53             ld      HL,(PNT)        ; PNT
5460+ 369A 23                   inc     HL              ; PNT=PNT+1
5461+ 369B 22 2A 53             ld      (PNT),HL        ; store PNT
5462+ 369E 3E 01                ld      A,$01           ; SB=1
5463+ 36A0 5F                   ld      E,A             ; set SB
5464+ 36A1 C3 B6 36             jp      PAINT5          ; jump over
5465+ 36A4 7B           PAINT4: ld      A,E             ; load SB
5466+ 36A5 1F                   rra                     ; check if SB=1
5467+ 36A6 30 0E                jr      NC,PAINT5       ; no, jump over
5468+ 36A8 79                   ld      A,C             ; load Y
5469+ 36A9 FE BF                cp      $BF             ; Y<191?
5470+ 36AB 30 09                jr      NC,PAINT5       ; no, jump over
5471+ 36AD 3C                   inc     A               ; Y=Y+1
5472+ 36AE CD C6 36             call    CHECKPY         ; check pixel X1,Y+1
5473+ 36B1 CA B6 36             jp      Z,PAINT5        ; if pixel is off, jump over
5474+ 36B4 AF                   xor     A               ; pixel is on, so...
5475+ 36B5 5F                   ld      E,A             ; ...set SB=0
5476+ 36B6 04           PAINT5: inc     B               ; X1=X1+1
5477+ 36B7 CA 23 36             jp      Z,NXTLOOP       ; if X1>255 (X1=0) then goto next loop
5478+ 36BA C3 42 36             jp      MNPAINT         ; otherwise, repeat for next X
5479+ 36BD ED 7B 2E 53  EXITPAI:ld      SP,(ORGSP)      ; retrieve original SP pointer
5480+ 36C1 D1           EXITPA2:pop     DE              ; retrieve DE
5481+ 36C2 C1                   pop     BC              ; retrieve BC
5482+ 36C3 E1                   pop     HL              ; retrieve HL
5483+ 36C4 C9                   ret                     ; return to caller
5484+ 36C5 79           CHECKPA:ld      A,C             ; copy Y into A
5485+ 36C6 32 24 53     CHECKPY:ld      (TMPBFR2),A     ; store Y
5486+ 36C9 78                   ld      A,B             ; copy X1 into A
5487+ 36CA 32 22 53             ld      (TMPBFR1),A     ; store X1
5488+ 36CD C5                   push    BC              ; save X1,Y
5489+ 36CE D5                   push    DE
5490+ 36CF CD 1D 37             call    PNTRTN          ; check if pixel is set/reset
5491+ 36D2 D1                   pop     DE
5492+ 36D3 C1                   pop     BC              ; retrieve X1,Y
5493+ 36D4 C9                   ret                     ; return to caller
5494+ 36D5
5495+ 36D5
5496+ 36D5              ; POINT(x,y): return if a pixel is set (returns color) or if it's reset (0)
5497+ 36D5 CD EC 34     POINT:  call    CHKG2M          ; check if in graphic mode 2
5498+ 36D8 CD C3 19             call    CHKSYN          ; make sure "(" follows
5499+ 36DB 28                   defb    '('
5500+ 36DC CD 23 29             call    GETINT          ; get X coords.
5501+ 36DF 32 22 53             ld      (TMPBFR1),A     ; store it into a temp buffer
5502+ 36E2 CD C3 19             call    CHKSYN          ; Make sure ',' follows
5503+ 36E5 2C                   defb    ','
5504+ 36E6 CD 23 29             call    GETINT          ; get Y coords,
5505+ 36E9 FE C0                cp      $C0             ; check if Y is in range 0~191
5506+ 36EB D2 D7 1C             jp      NC,FCERR        ; no, raise an FC error
5507+ 36EE 32 24 53             ld      (TMPBFR2),A     ; store into a temp buffer
5508+ 36F1 CD C3 19             call    CHKSYN          ; make sure ")" follows
5509+ 36F4 29                   defb    ')'
5510+ 36F5 E5                   push    HL              ; store current string address - the point after the ")" - ...
5511+ 36F6 FD E1                pop     IY              ; ...into IY
5512+ 36F8 CD 1D 37             call    PNTRTN          ; check if pixel is set or reset
5513+ 36FB 20 0C                jr      NZ,CTPOINT      ; it's ON, jump over
5514+ 36FD AF                   xor     A               ; no, it's OFF. make sure to reset A...
5515+ 36FE 47                   ld      B,A             ; ...and B
5516+ 36FF E1           PNTEND: pop     HL              ; drop original return point
5517+ 3700 FD E5                push    IY              ; load current string address from IY into stack
5518+ 3702 11 88 21             ld      DE,RETNUM       ; Address of Return number from function...
5519+ 3705 D5                   push    DE              ; ...saved on stack
5520+ 3706 C3 87 24             jp      ABPASS          ; return AB
5521+ 3709 CB EC        CTPOINT:set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5522+ 370B F3                   di
5523+ 370C CD 7A 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5524+ 370F FB                   ei
5525+ 3710 CB 3F                srl     A               ; shift A...
5526+ 3712 CB 3F                srl     A               ; ...4 times...
5527+ 3714 CB 3F                srl     A               ; ...to move foreground color...
5528+ 3716 CB 3F                srl     A               ; ...into lowest nibble
5529+ 3718 47                   ld      B,A             ; color into B
5530+ 3719 AF                   xor     A               ; reset MSB
5531+ 371A C3 FF 36             jp      PNTEND          ; return AB
5532+ 371D CD 90 37     PNTRTN: call    XY2HL           ; find HL address of pixel at X,Y
5533+ 3720 57                   ld      D,A             ; store pixel index
5534+ 3721 F3                   di                      ; disable INTs
5535+ 3722 CD 7A 06             call    READ_VIDEO_LOC  ; read contents of VRAM cell addressed by HL
5536+ 3725 FB                   ei                      ; re-enable INTs
5537+ 3726 A2                   and     D               ; is the pixel ON or OFF? (will be checked later)
5538+ 3727 C9                   ret                     ; return to caller
5539+ 3728
5540+ 3728
5541+ 3728              ; PLOT X,Y[,color]
5542+ 3728              ; plot a pixel in graphic mode 2
5543+ 3728 CD EC 34     PLOT:   call    CHKG2M          ; check if in G2 mode
5544+ 372B CD 23 29             call    GETINT          ; get X coords.
5545+ 372E 32 22 53             ld      (TMPBFR1),A     ; store it into a temp buffer
5546+ 3731 CD C3 19             call    CHKSYN          ; Make sure ',' follows
5547+ 3734 2C                   defb    ','
5548+ 3735 CD 23 29             call    GETINT          ; get Y coords,
5549+ 3738 FE C0                cp      $C0             ; check if Y is in range 0~191
5550+ 373A D2 D7 1C             jp      NC,FCERR        ; no, raise an FC error
5551+ 373D 32 24 53             ld      (TMPBFR2),A     ; store into a temp buffer
5552+ 3740 CD D8 3A             call    CLRPRM          ; check if param "color" has been passed
5553+ 3743 E5           CNTPLOT:push    HL              ; store HL
5554+ 3744 C5                   push    BC              ; store BC
5555+ 3745 D5                   push    DE              ; store DE
5556+ 3746 CD 90 37             call    XY2HL           ; find VRAM address of byte containing pixel at X,Y & return into HL
5557+ 3749 D2 84 37             jp      NC,NOGD         ; if carry is reset, there was an error -> so leave
5558+ 374C 57                   ld      D,A             ; move pixel value into D
5559+ 374D 3A 26 53             ld      A,(TMPBFR3)     ; retrieve color
5560+ 3750 A7                   and     A               ; is it 0? (background, or reset pixel)
5561+ 3751 20 11                jr      NZ,CNTPLT1      ; no, continue
5562+ 3753 F3                   di                      ; yes - so, disable INTs
5563+ 3754 CD 7A 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5564+ 3757 FB                   ei                      ; re-enable INTs
5565+ 3758 5F                   ld      E,A             ; store value of cell
5566+ 3759 7A                   ld      A,D             ; retrieve pixel
5567+ 375A 2F                   cpl                     ; revert bits
5568+ 375B A3                   and     E               ; set video pixel to off
5569+ 375C F3                   di                      ; disable INTs
5570+ 375D CD 8F 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5571+ 3760 FB                   ei                      ; re-enable INTs
5572+ 3761 C3 84 37             jp      NOGD            ; leave
5573+ 3764 87           CNTPLT1:add     A,A             ; now we move low nibble
5574+ 3765 87                   add     A,A             ; in the high nibble
5575+ 3766 87                   add     A,A             ; by adding A to itself
5576+ 3767 87                   add     A,A             ; 4 times (this is a shift left 4)
5577+ 3768 5F                   ld      E,A             ; move it into E
5578+ 3769 F3                   di                      ; disable INTs
5579+ 376A CD 7A 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5580+ 376D FB                   ei
5581+ 376E B2                   or      D               ; merge new pixel preserving original pattern
5582+ 376F F3                   di
5583+ 3770 CD 8F 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5584+ 3773 FB                   ei
5585+ 3774 CB EC                set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5586+ 3776 F3                   di
5587+ 3777 CD 7A 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5588+ 377A FB                   ei
5589+ 377B E6 0F                and     %00001111       ; reset high nibble (the foreground color)
5590+ 377D B3                   or      E               ; set new foreground color
5591+ 377E F3                   di
5592+ 377F CD 8F 06             call    WRITE_VIDEO_LOC ; write new color settings
5593+ 3782 FB                   ei                      ; re-enable INTs
5594+ 3783 00                   nop                     ; wait for INTs to be enabled again
5595+ 3784 D1           NOGD:   pop     DE              ; retrieve DE
5596+ 3785 C1                   pop     BC              ; retrieve BC
5597+ 3786 E1                   pop     HL              ; retrieve HL
5598+ 3787 C9                   ret                     ; return to caller
5599+ 3788 80 40 20 10  PXLSET: defb    $80,$40,$20,$10,$08,$04,$02,$01 ; pixel to be set ON
5599+ 378C 08 04 02 01
5600+ 3790                      ; where R(X/8)=> 0=80h, 1=40h, 2=20h, 3=10h, 4=08h, 5=04h, 6=02h, 7=$01
5601+ 3790
5602+ 3790
5603+ 3790              ; compute the VRAM address of the byte containing the pixel
5604+ 3790              ; being pointed by X,Y (TMPBFR1,TMPBFR1)
5605+ 3790              ; byte address is returned into HL
5606+ 3790              ; pixel is returned into A
5607+ 3790              XY2HL:  ; formula is: ADDRESS=(INT(X/8))*8 + (INT(Y/8))*256 + R(Y/8)
5608+ 3790                      ; where R(Y/8) is the remainder of (Y/8)
5609+ 3790                      ; the pixel to be set is given by R(X/8), and data is taken from the array
5610+ 3790 3A 24 53             ld      A,(TMPBFR2)     ; retrieve Y
5611+ 3793 FE C0                cp      $C0             ; Y>=192?
5612+ 3795 D0                   ret     NC              ; yes, so leave
5613+ 3796 1E 08                ld      E,$08           ; load E with divisor
5614+ 3798 57                   ld      D,A             ; and store into D (dividend)
5615+ 3799 CD 0D 40             call    DIV_8_8         ; get Y/8, D is quotient=INT(Y/8), and A is remainder
5616+ 379C 4F                   ld      C,A             ; store remainder into C
5617+ 379D 42                   ld      B,D             ; B=(INT(Y/8))*256 (we simply copy quotient into B)
5618+ 379E 60 69                ld      HL,BC           ; copy BC into HL: now HL has the VRAM address of the byte being set
5619+ 37A0 3A 22 53             ld      A,(TMPBFR1)     ; retrieve X
5620+ 37A3 57                   ld      D,A             ; and move it into D (dividend)
5621+ 37A4 CD 0D 40             call    DIV_8_8         ; get X/8, D is quotient=INT(X/8), and A is remainder
5622+ 37A7 4F                   ld      C,A             ; store remainder into C
5623+ 37A8 7A                   ld      A,D             ; move quotient into A
5624+ 37A9 87                   add     A,A             ; multiply quotient by 8
5625+ 37AA 87                   add     A,A
5626+ 37AB 87                   add     A,A
5627+ 37AC 5F                   ld      E,A             ; store result into E
5628+ 37AD 16 00                ld      D,$00           ; reset D
5629+ 37AF 19                   add     HL,DE           ; add DE to HL, getting the final VRAM address
5630+ 37B0 EB                   ex      DE,HL           ; move VRAM address into DE
5631+ 37B1 21 88 37             ld      HL,PXLSET       ; starting address of table for pixel to draw
5632+ 37B4 06 00                ld      B,$00           ; reset B
5633+ 37B6 09                   add     HL,BC           ; add C (remainder of X/8) to get address of pixel to turn on
5634+ 37B7 7E                   ld      A,(HL)          ; load pixel data
5635+ 37B8 EB                   ex      DE,HL           ; retrieve VRAM pattern address into HL
5636+ 37B9 37                   scf                     ; set Carry for normal exit
5637+ 37BA C9                   ret                     ; return to caller
5638+ 37BB
5639+ 37BB
5640+ 37BB              ; DRAW X1,Y1,X2,Y2[,color]
5641+ 37BB              ; Draw a line using Bresenham's line algorithm from X1,Y1 to X2,Y2
5642+ 37BB              ; X1,Y1 can be either less than or greater than X2,Y2 (meaning that)
5643+ 37BB              ; the drawing will be ever done from X1,Y2 to X2,Y2, regardless of
5644+ 37BB              ; the values. If color is not specified, the foreground color set
5645+ 37BB              ; with COLOR will be used
5646+ 37BB              X1      equ     TMPBFR1
5647+ 37BB              Y1      equ     TMPBFR2
5648+ 37BB              X2      equ     VIDEOBUFF
5649+ 37BB              Y2      equ     VIDEOBUFF+$02
5650+ 37BB              ER      equ     VIDEOBUFF+$04
5651+ 37BB              E2      equ     VIDEOBUFF+$06
5652+ 37BB              SX      equ     VIDEOBUFF+$08
5653+ 37BB              SY      equ     VIDEOBUFF+$0A
5654+ 37BB              DX      equ     VIDEOBUFF+$0C
5655+ 37BB              DY      equ     VIDEOBUFF+$0E
5656+ 37BB CD EC 34     DRAW:   call    CHKG2M          ; check if in G2 mode
5657+ 37BE CD C0 3A             call    CLRVDBF         ; clear VIDEOBUFF
5658+ 37C1 CD 23 29             call    GETINT          ; get X1 coords.
5659+ 37C4 32 22 53             ld      (X1),A          ; store it into a temp buffer
5660+ 37C7 CD C3 19             call    CHKSYN          ; Make sure ',' follows
5661+ 37CA 2C                   defb    ','
5662+ 37CB CD 23 29             call    GETINT          ; get Y1 coords.
5663+ 37CE FE C0                cp      $C0             ; check if Y1 is in range 0~191
5664+ 37D0 D2 D7 1C             jp      NC,FCERR        ; no, raise an FC error
5665+ 37D3 32 24 53             ld      (Y1),A          ; store into a temp buffer
5666+ 37D6 CD C3 19             call    CHKSYN          ; Make sure ',' follows
5667+ 37D9 2C                   defb    ','
5668+ 37DA CD 23 29             call    GETINT          ; get X2 coords.
5669+ 37DD 32 2A 53             ld      (X2),A          ; store it into a temp buffer
5670+ 37E0 CD C3 19             call    CHKSYN          ; Make sure ',' follows
5671+ 37E3 2C                   defb    ','
5672+ 37E4 CD 23 29             call    GETINT          ; get Y2 coords
5673+ 37E7 FE C0                cp      $C0             ; check if Y2 is in range 0~191
5674+ 37E9 D2 D7 1C             jp      NC,FCERR        ; no, raise an FC error
5675+ 37EC 32 2C 53             ld      (Y2),A          ; store it into a temp buffer
5676+ 37EF CD D8 3A             call    CLRPRM          ; check for arg. "color" and store it into TMPBFR3
5677+ 37F2 E5                   push    HL              ; store register we'll use
5678+ 37F3 D5                   push    DE
5679+ 37F4 C5                   push    BC
5680+ 37F5 ED 5B 22 53          ld      DE,(X1)         ; load X1 and
5681+ 37F9 2A 2A 53             ld      HL,(X2)         ; X2
5682+ 37FC B7                   or      A               ; clear CARRY
5683+ 37FD ED 52                sbc     HL,DE           ; DX=X2-X1
5684+ 37FF CD 03 40             call    absHL           ; DX=ABS(DX)
5685+ 3802 22 36 53             ld      (DX),HL         ; store DX
5686+ 3805 01 FF FF             ld      BC,$FFFF        ; SX=-1
5687+ 3808 2A 22 53             ld      HL,(X1)
5688+ 380B ED 5B 2A 53          ld      DE,(X2)
5689+ 380F CD DE 3F             call    CMP16           ; X1<X2?
5690+ 3812 CA 1B 38             jp      Z,X1GR          ; no, X1=X2
5691+ 3815 F2 1B 38             jp      P,X1GR          ; no, X1>X2
5692+ 3818 01 01 00             ld      BC,$0001        ; yes, so set SX=1
5693+ 381B ED 43 32 53  X1GR:   ld      (SX),BC         ; store SX
5694+ 381F ED 5B 24 53          ld      DE,(Y1)
5695+ 3823 2A 2C 53             ld      HL,(Y2)
5696+ 3826 B7                   or      A               ; clear Carry
5697+ 3827 ED 52                sbc     HL,DE           ; DY=Y2-Y1
5698+ 3829 CD 03 40             call    absHL           ; DY=ABS(DY)
5699+ 382C 22 38 53             ld      (DY),HL         ; store DY
5700+ 382F 01 FF FF             ld      BC,$FFFF        ; SY=-1
5701+ 3832 2A 24 53             ld      HL,(Y1)
5702+ 3835 ED 5B 2C 53          ld      DE,(Y2)
5703+ 3839 CD DE 3F             call    CMP16           ; is Y1<Y2?
5704+ 383C CA 45 38             jp      Z,Y1GR          ; no, Y1=Y2
5705+ 383F F2 45 38             jp      P,Y1GR          ; no, Y1>Y2 - jump over
5706+ 3842 01 01 00             ld      BC,$0001        ; yes, so set SY=1
5707+ 3845 ED 43 34 53  Y1GR:   ld      (SY),BC         ; store SY
5708+ 3849 2A 38 53             ld      HL,(DY)         ; ER=DY
5709+ 384C CD 06 40             call    negHL           ; ER=-DY
5710+ 384F 22 2E 53             ld      (ER),HL         ; store ER
5711+ 3852 2A 36 53             ld      HL,(DX)
5712+ 3855 ED 5B 38 53          ld      DE,(DY)
5713+ 3859 CD DE 3F             call    CMP16           ; DX>DY?
5714+ 385C CA 68 38             jp      Z,ER2           ; no, DX=DY
5715+ 385F FA 68 38             jp      M,ER2           ; no, DX<DY
5716+ 3862 2A 36 53             ld      HL,(DX)         ; reload DX
5717+ 3865 22 2E 53             ld      (ER),HL         ; yes: DX>DY, so ER=DX
5718+ 3868 2A 2E 53     ER2:    ld      HL,(ER)         ; load ER
5719+ 386B CB 2C                sra     H               ; right shift (and preserve sign)...
5720+ 386D CB 1D                rr      L               ; ...of HL, so ER=INT(ER/2)
5721+ 386F CB 7C                bit     7,H             ; is the number negative?
5722+ 3871 CA 75 38             jp      Z,STRE2         ; no, jump over
5723+ 3874 23                   inc     HL              ; yes, add 1 'cos INT of a negative number needs to be incremented
5724+ 3875 22 2E 53     STRE2:  ld      (ER),HL         ; store ER
5725+ 3878 CD 43 37     RPTDRW: call    CNTPLOT         ; plot first pixel
5726+ 387B 2A 22 53             ld      HL,(X1)
5727+ 387E ED 5B 2A 53          ld      DE,(X2)
5728+ 3882 CD DE 3F             call    CMP16           ; X1=X2?
5729+ 3885 20 0D                jr      NZ,CNTDRW       ; no, continue drawing
5730+ 3887 2A 24 53             ld      HL,(Y1)         ; yes, so check
5731+ 388A ED 5B 2C 53          ld      DE,(Y2)         ; also Y
5732+ 388E CD DE 3F             call    CMP16           ; Y1=Y2?
5733+ 3891 CA ED 38             jp      Z,ENDDRAW       ; yes, finished drawing: exit
5734+ 3894 ED 5B 2E 53  CNTDRW: ld      DE,(ER)
5735+ 3898 ED 53 30 53          ld      (E2),DE         ; E2=ER
5736+ 389C 2A 36 53             ld      HL,(DX)
5737+ 389F CD 06 40             call    negHL           ; DX=-DX
5738+ 38A2 EB                   ex      DE,HL           ; invert DE and HL => HL=E2, DE=-DX
5739+ 38A3 CD DE 3F             call    CMP16           ; E2>-DX?
5740+ 38A6 CA C4 38             jp      Z,DXGR          ; no, E2=-DX: jump
5741+ 38A9 FA C4 38             jp      M,DXGR          ; no, E2<-DX: jump
5742+ 38AC 2A 2E 53             ld      HL,(ER)         ; yes
5743+ 38AF ED 5B 38 53          ld      DE,(DY)
5744+ 38B3 B7                   or      A               ; clear CARRY
5745+ 38B4 ED 52                sbc     HL,DE           ; ER=ER-DY
5746+ 38B6 22 2E 53             ld      (ER),HL
5747+ 38B9 2A 22 53             ld      HL,(X1)
5748+ 38BC ED 5B 32 53          ld      DE,(SX)
5749+ 38C0 19                   add     HL,DE           ; X1=X1+SX (increment X1)
5750+ 38C1 22 22 53             ld      (X1),HL
5751+ 38C4 2A 30 53     DXGR:   ld      HL,(E2)
5752+ 38C7 ED 5B 38 53          ld      DE,(DY)
5753+ 38CB CD DE 3F             call    CMP16           ; E2<DY?
5754+ 38CE CA 78 38             jp      Z,RPTDRW        ; no, E2=DY: jump
5755+ 38D1 F2 78 38             jp      P,RPTDRW        ; no, E2>DY: jump
5756+ 38D4 2A 2E 53             ld      HL,(ER)         ; yes
5757+ 38D7 ED 5B 36 53          ld      DE,(DX)
5758+ 38DB 19                   add     HL,DE           ; ER=ER+DX
5759+ 38DC 22 2E 53             ld      (ER),HL
5760+ 38DF 2A 24 53             ld      HL,(Y1)
5761+ 38E2 ED 5B 34 53          ld      DE,(SY)
5762+ 38E6 19                   add     HL,DE           ; Y1=Y1+SY (increment Y1)
5763+ 38E7 22 24 53             ld      (Y1),HL
5764+ 38EA C3 78 38             jp      RPTDRW          ; repeat
5765+ 38ED C1           ENDDRAW:pop     BC              ; retrieve BC
5766+ 38EE D1                   pop     DE              ; retrieve DE
5767+ 38EF E1                   pop     HL              ; retrieve HL
5768+ 38F0 C9                   ret                     ; return to caller
5769+ 38F1
5770+ 38F1
5771+ 38F1              ; CIRCLE X,Y,R[,C]
5772+ 38F1              ; Draw a circle using Bresenham's circle algorithm with center in X,Y
5773+ 38F1              ; and radius R, with optional color C. If color is not specified, the
5774+ 38F1              ; foreground color set with COLOR will be used
5775+ 38F1              XC      equ     VIDEOBUFF
5776+ 38F1              YC      equ     VIDEOBUFF+$02
5777+ 38F1              RADIUS  equ     VIDEOBUFF+$04
5778+ 38F1              XI      equ     VIDEOBUFF+$06
5779+ 38F1              YI      equ     VIDEOBUFF+$08
5780+ 38F1              DC      equ     VIDEOBUFF+$0A
5781+ 38F1 CD EC 34     CIRCLE: call    CHKG2M          ; check if in G2 mode
5782+ 38F4 CD C0 3A             call    CLRVDBF         ; clear VIDEOBUFF
5783+ 38F7 CD 23 29             call    GETINT          ; get X coords.
5784+ 38FA 32 2A 53             ld      (XC),A          ; store it into a temp buffer
5785+ 38FD CD C3 19             call    CHKSYN          ; Make sure ',' follows
5786+ 3900 2C                   defb    ','
5787+ 3901 CD 23 29             call    GETINT          ; get Y coords,
5788+ 3904 32 2C 53             ld      (YC),A          ; store it into a temp buffer
5789+ 3907 CD C3 19             call    CHKSYN          ; Make sure ',' follows
5790+ 390A 2C                   defb    ','
5791+ 390B CD 23 29             call    GETINT          ; get radius
5792+ 390E 32 2E 53             ld      (RADIUS),A      ; store it into a temp buffer
5793+ 3911 CD D8 3A             call    CLRPRM          ; check if param "color" has been passed
5794+ 3914 C5                   push    BC              ; store BC
5795+ 3915 D5                   push    DE              ; store DE
5796+ 3916 E5                   push    HL              ; store HL
5797+ 3917 AF                   xor     A               ; clear A,
5798+ 3918 47                   ld      B,A             ; B,
5799+ 3919 4F                   ld      C,A             ; C,
5800+ 391A 57                   ld      D,A             ; D,
5801+ 391B 67                   ld      H,A             ; and H
5802+ 391C ED 43 30 53          ld      (XI),BC         ; clear XI
5803+ 3920 3A 2E 53             ld      A,(RADIUS)      ; load RADIUS into A
5804+ 3923 6F                   ld      L,A             ; HL now contains R
5805+ 3924 22 32 53             ld      (YI),HL         ; YI=RADIUS
5806+ 3927 29                   add     HL,HL           ; R*2
5807+ 3928 EB                   ex      DE,HL           ; put HL into DE
5808+ 3929 21 03 00             ld      HL,$0003        ; HL = 3
5809+ 392C AF                   xor     A               ; clear Carry
5810+ 392D ED 52                sbc     HL,DE           ; D=3-(2*R) => HL
5811+ 392F 22 34 53             ld      (DC),HL         ; store D
5812+ 3932 CD 91 39             call    DRWCRL          ; draw initial point
5813+ 3935 ED 5B 30 53  RPTCRL: ld      DE,(XI)         ; load XI
5814+ 3939 2A 32 53             ld      HL,(YI)         ; load YI
5815+ 393C CD DE 3F             call    CMP16           ; is YI<DI?
5816+ 393F CA 48 39             jp      Z,RPTCL1        ; no, YI=XI
5817+ 3942 F2 48 39             jp      P,RPTCL1        ; no, YI>XI
5818+ 3945 C3 8D 39             jp      ENDCRL          ; yes, so we've finished
5819+ 3948 21 30 53     RPTCL1: ld      HL,XI
5820+ 394B 34                   inc     (HL)            ; XI=XI+1
5821+ 394C 2A 34 53             ld      HL,(DC)         ; load D
5822+ 394F 7C                   ld      A,H
5823+ 3950 B5                   or      L               ; is D=0? Yes, jump over
5824+ 3951 CA 75 39             jp      Z,DLSZ
5825+ 3954 CB 7C                bit     7,H             ; is D<0?
5826+ 3956 20 1D                jr      NZ,DLSZ         ; yes, jump over
5827+ 3958 ED 5B 32 53          ld      DE,(YI)         ; D>0
5828+ 395C 1B                   dec     DE              ; so, YI=YI-1
5829+ 395D ED 53 32 53          ld      (YI),DE         ; store YI
5830+ 3961 AF                   xor     A               ; clear Carry
5831+ 3962 2A 30 53             ld      HL,(XI)
5832+ 3965 ED 52                sbc     HL,DE           ; HL=XI-YI
5833+ 3967 29                   add     HL,HL
5834+ 3968 29                   add     HL,HL           ; HL=HL*4
5835+ 3969 11 0A 00             ld      DE,10
5836+ 396C 19                   add     HL,DE           ; HL=HL+10
5837+ 396D ED 5B 34 53          ld      DE,(DC)         ; load D
5838+ 3971 EB                   ex      DE,HL           ; invert DE and HL, so that HL=4*(XI-YI)+10 and DE=D
5839+ 3972 19                   add     HL,DE           ; D=D+4*(XI-YI)+10
5840+ 3973 18 0F                jr      PLTCRL          ; plot next pixel
5841+ 3975 2A 30 53     DLSZ:   ld      HL,(XI)         ; load XI
5842+ 3978 29                   add     HL,HL
5843+ 3979 29                   add     HL,HL           ; XI=XI*4
5844+ 397A 11 06 00             ld      DE,$0006
5845+ 397D 19                   add     HL,DE
5846+ 397E ED 5B 34 53          ld      DE,(DC)
5847+ 3982 EB                   ex      DE,HL           ; HL=D and DE=4*XI+6
5848+ 3983 19                   add     HL,DE           ; D=D+4*XI+6
5849+ 3984 22 34 53     PLTCRL: ld      (DC),HL         ; store new D
5850+ 3987 CD 91 39             call    DRWCRL          ; plot pixel
5851+ 398A C3 35 39             jp      RPTCRL          ; repeat
5852+ 398D E1           ENDCRL: pop     HL
5853+ 398E D1                   pop     DE
5854+ 398F C1                   pop     BC
5855+ 3990 C9                   ret                     ; return to caller
5856+ 3991 2A 2A 53     DRWCRL: ld      HL,(XC)
5857+ 3994 ED 5B 30 53          ld      DE,(XI)
5858+ 3998 19                   add     HL,DE           ; X=XC+XI
5859+ 3999 22 22 53             ld      (X1),HL         ; store X
5860+ 399C CD B0 3A             call    VALIDX          ; check if X is valid (0~255)
5861+ 399F DA B3 39             jp      C,CNTCL1        ; if Carry is set, X is not valid
5862+ 39A2 2A 2C 53             ld      HL,(YC)
5863+ 39A5 ED 5B 32 53          ld      DE,(YI)
5864+ 39A9 19                   add     HL,DE           ; Y=YC+YI
5865+ 39AA 22 24 53             ld      (Y1),HL         ; store Y
5866+ 39AD CD B5 3A             call    VALIDY          ; check if Y is valid (0~191)
5867+ 39B0 D4 43 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5868+ 39B3 AF           CNTCL1: xor     A               ; clear Carry
5869+ 39B4 2A 2A 53             ld      HL,(XC)
5870+ 39B7 ED 5B 30 53          ld      DE,(XI)
5871+ 39BB ED 52                sbc     HL,DE           ; X=XC-XI
5872+ 39BD 22 22 53             ld      (X1),HL         ; store X
5873+ 39C0 CD B0 3A             call    VALIDX          ; check if X is valid (0~255)
5874+ 39C3 DA D7 39             jp      C,CNTCL2        ; if Carry is set, X is not valid
5875+ 39C6 2A 2C 53             ld      HL,(YC)
5876+ 39C9 ED 5B 32 53          ld      DE,(YI)
5877+ 39CD 19                   add     HL,DE           ; Y=YC+YI
5878+ 39CE 22 24 53             ld      (Y1),HL         ; store Y
5879+ 39D1 CD B5 3A             call    VALIDY          ; check if Y is valid (0~191)
5880+ 39D4 D4 43 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5881+ 39D7 2A 2A 53     CNTCL2: ld      HL,(XC)
5882+ 39DA ED 5B 30 53          ld      DE,(XI)
5883+ 39DE 19                   add     HL,DE           ; X=XC+XI
5884+ 39DF 22 22 53             ld      (X1),HL         ; store X
5885+ 39E2 CD B0 3A             call    VALIDX          ; check if X is valid (0~255)
5886+ 39E5 DA FB 39             jp      C,CNTCL3        ; if Carry is set, X is not valid
5887+ 39E8 AF                   xor     A               ; clear Carry
5888+ 39E9 2A 2C 53             ld      HL,(YC)
5889+ 39EC ED 5B 32 53          ld      DE,(YI)
5890+ 39F0 ED 52                sbc     HL,DE           ; Y=YC-YI
5891+ 39F2 22 24 53             ld      (Y1),HL         ; store Y
5892+ 39F5 CD B5 3A             call    VALIDY          ; check if Y is valid (0~191)
5893+ 39F8 D4 43 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5894+ 39FB AF           CNTCL3: xor     A               ; clear Carry
5895+ 39FC 2A 2A 53             ld      HL,(XC)
5896+ 39FF ED 5B 30 53          ld      DE,(XI)
5897+ 3A03 ED 52                sbc     HL,DE           ; X=XC-XI
5898+ 3A05 22 22 53             ld      (X1),HL         ; store X
5899+ 3A08 CD B0 3A             call    VALIDX          ; check if X is valid (0~255)
5900+ 3A0B DA 21 3A             jp      C,CNTCL4        ; if Carry is set, X is not valid
5901+ 3A0E AF                   xor     A               ; clear Carry
5902+ 3A0F 2A 2C 53             ld      HL,(YC)
5903+ 3A12 ED 5B 32 53          ld      DE,(YI)
5904+ 3A16 ED 52                sbc     HL,DE           ; Y=YC-YI
5905+ 3A18 22 24 53             ld      (Y1),HL         ; store Y
5906+ 3A1B CD B5 3A             call    VALIDY          ; check if Y is valid (0~191)
5907+ 3A1E D4 43 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5908+ 3A21 2A 2A 53     CNTCL4: ld      HL,(XC)
5909+ 3A24 ED 5B 32 53          ld      DE,(YI)
5910+ 3A28 19                   add     HL,DE           ; X=XC+YI
5911+ 3A29 22 22 53             ld      (X1),HL         ; store X
5912+ 3A2C CD B0 3A             call    VALIDX          ; check if X is valid (0~255)
5913+ 3A2F DA 43 3A             jp      C,CNTCL5        ; if Carry is set, X is not valid
5914+ 3A32 2A 2C 53             ld      HL,(YC)
5915+ 3A35 ED 5B 30 53          ld      DE,(XI)
5916+ 3A39 19                   add     HL,DE           ; Y=YC+XI
5917+ 3A3A 22 24 53             ld      (Y1),HL         ; store Y
5918+ 3A3D CD B5 3A             call    VALIDY          ; check if Y is valid (0~191)
5919+ 3A40 D4 43 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5920+ 3A43 AF           CNTCL5: xor     A               ; clear Carry
5921+ 3A44 2A 2A 53             ld      HL,(XC)
5922+ 3A47 ED 5B 32 53          ld      DE,(YI)
5923+ 3A4B ED 52                sbc     HL,DE           ; X=XC-YI
5924+ 3A4D 22 22 53             ld      (X1),HL         ; store X
5925+ 3A50 CD B0 3A             call    VALIDX          ; check if X is valid (0~255)
5926+ 3A53 DA 67 3A             jp      C,CNTCL6        ; if Carry is set, X is not valid
5927+ 3A56 2A 2C 53             ld      HL,(YC)
5928+ 3A59 ED 5B 30 53          ld      DE,(XI)
5929+ 3A5D 19                   add     HL,DE           ; Y=YC+XI
5930+ 3A5E 22 24 53             ld      (Y1),HL         ; store Y
5931+ 3A61 CD B5 3A             call    VALIDY          ; check if Y is valid (0~191)
5932+ 3A64 D4 43 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5933+ 3A67 2A 2A 53     CNTCL6: ld      HL,(XC)
5934+ 3A6A ED 5B 32 53          ld      DE,(YI)
5935+ 3A6E 19                   add     HL,DE           ; X=XC+YI
5936+ 3A6F 22 22 53             ld      (X1),HL         ; store X
5937+ 3A72 CD B0 3A             call    VALIDX          ; check if X is valid (0~255)
5938+ 3A75 DA 8B 3A             jp      C,CNTCL7        ; if Carry is set, X is not valid
5939+ 3A78 AF                   xor     A               ; clear Carry
5940+ 3A79 2A 2C 53             ld      HL,(YC)
5941+ 3A7C ED 5B 30 53          ld      DE,(XI)
5942+ 3A80 ED 52                sbc     HL,DE           ; Y=YC-XI
5943+ 3A82 22 24 53             ld      (Y1),HL         ; store Y
5944+ 3A85 CD B5 3A             call    VALIDY          ; check if Y is valid (0~191)
5945+ 3A88 D4 43 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5946+ 3A8B AF           CNTCL7: xor     A               ; clear Carry
5947+ 3A8C 2A 2A 53             ld      HL,(XC)
5948+ 3A8F ED 5B 32 53          ld      DE,(YI)
5949+ 3A93 ED 52                sbc     HL,DE           ; X=XC-YI
5950+ 3A95 22 22 53             ld      (X1),HL         ; store X
5951+ 3A98 CD B0 3A             call    VALIDX          ; check if X is valid (0~255)
5952+ 3A9B D8                   ret     C               ; if Carry is set, X is not valid
5953+ 3A9C AF                   xor     A               ; clear Carry
5954+ 3A9D 2A 2C 53             ld      HL,(YC)
5955+ 3AA0 ED 5B 30 53          ld      DE,(XI)
5956+ 3AA4 ED 52                sbc     HL,DE           ; Y=YC-XI
5957+ 3AA6 22 24 53             ld      (Y1),HL         ; store Y
5958+ 3AA9 CD B5 3A             call    VALIDY          ; check if Y is valid (0~191)
5959+ 3AAC D4 43 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5960+ 3AAF C9                   ret                     ; return to caller
5961+ 3AB0
5962+ 3AB0              ; check if X,Y coordinates are valid: 0<=X<=255 and 0<=Y<=191
5963+ 3AB0              ; input: HL (value to check), can be negative
5964+ 3AB0              ; output: CARRY flag: reset => VALID  //  set => NOT VALID
5965+ 3AB0              ; destroys: A
5966+ 3AB0 AF           VALIDX: xor     A               ; reset A
5967+ 3AB1 B4                   or      H               ; check if H is 0 (this means that X is in range 0~255 and not negative)
5968+ 3AB2 C8                   ret     Z               ; yes, we can return (C is clear)
5969+ 3AB3 37                   scf                     ; set Carry flag to raise error
5970+ 3AB4 C9                   ret                     ; return to caller
5971+ 3AB5
5972+ 3AB5 AF           VALIDY: xor     A               ; reset A
5973+ 3AB6 B4                   or      H               ; check if H is 0 (this means that Y is in range 0~255 and not negative)
5974+ 3AB7 28 02                jr      Z,CNTVALY       ; yes, continue checking
5975+ 3AB9 37                   scf                     ; no, raise error by setting Carry flag
5976+ 3ABA C9                   ret                     ; return to caller
5977+ 3ABB 7D           CNTVALY:ld      A,L
5978+ 3ABC FE C0                cp      $C0             ; is Y<192? Carry is set if Y<192
5979+ 3ABE 3F                   ccf                     ; invert Carry, so Carry=0 means OK, Carry=1 means ERROR
5980+ 3ABF C9                   ret                     ; return to caller
5981+ 3AC0
5982+ 3AC0
5983+ 3AC0              ; clear VIDEOBUFF before using it as temp buffer
5984+ 3AC0 AF           CLRVDBF:xor     A               ; clear A
5985+ 3AC1 C5                   push    BC              ; store BC
5986+ 3AC2 E5                   push    HL              ; store HL
5987+ 3AC3 21 22 53             ld      HL,TMPBFR1      ; address of 1st cell
5988+ 3AC6 06 06                ld      B,$06           ; 6 cells
5989+ 3AC8 77           RPTCVB1:ld      (HL),A          ; clear cell
5990+ 3AC9 23                   inc     HL              ; next cell
5991+ 3ACA 10 FC                djnz    RPTCVB1         ; repeat
5992+ 3ACC 06 28                ld      B,$28           ; 40 cells
5993+ 3ACE 21 2A 53             ld      HL,VIDEOBUFF    ; address of 1st cell
5994+ 3AD1 77           RPTCVB2:ld      (HL),A          ; clear cell
5995+ 3AD2 23                   inc     HL              ; next cell
5996+ 3AD3 10 FC                djnz    RPTCVB2         ; repeat
5997+ 3AD5 E1                   pop     HL              ; retrieve HL
5998+ 3AD6 C1                   pop     BC              ; retrieve BC
5999+ 3AD7 C9                   ret                     ; return to caller
6000+ 3AD8
6001+ 3AD8
6002+ 3AD8              ; check if a color is passed as argument with PLOT, DRAW, and CIRCLE
6003+ 3AD8              ; commands. If not present, the default foreground color will be used
6004+ 3AD8 3A 20 53     CLRPRM: ld      A,(FRGNDCLR)    ; load foreground color
6005+ 3ADB 32 26 53             ld      (TMPBFR3),A     ; store into temp buffer
6006+ 3ADE 2B                   dec     HL              ; dec 'cos GETCHR INCs
6007+ 3ADF CD 0C 1C             call    GETCHR          ; Get next character
6008+ 3AE2 C8                   ret     Z               ; return foreground color if nothing follows
6009+ 3AE3 CD C3 19             call    CHKSYN          ; Make sure ',' follows
6010+ 3AE6 2C                   defb    ','
6011+ 3AE7 CD 23 29             call    GETINT          ; get value
6012+ 3AEA CD E6 34             call    CHKCLR0         ; check if color is in range 0~15
6013+ 3AED 32 26 53             ld      (TMPBFR3),A     ; store color into temp buffer
6014+ 3AF0 C9                   ret                     ; return to caller
6015+ 3AF1
6016+ 3AF1
6017+ 3AF1              ; no graphics mode error: raised when a graphics command is invoked
6018+ 3AF1              ; out of graphic 2 mode.
6019+ 3AF1 1E 2A        GMERR:  ld      E,GM            ; load Graphics Mode Error flag
6020+ 3AF3 C3 DD 16             jp      ERROR           ; print error
6021+ 3AF6
6022+ 3AF6
6023+ 3AF6              ; set a serial port: params are PORT,BPS,DATA,PARITY,STOP
6024+ 3AF6              ; PORT=1/2; BPS=1,200~57,600 (see below), DATA=5/6/7/8
6025+ 3AF6              ; PARITY: 0=no parity; 1=ODD parity; 2=EVEN parity;
6026+ 3AF6              ; STOP=0/1/2/3: 0=0 bit; 1=1 bit; 2=1.5 bits; 3=2 bits
6027+ 3AF6              ; PORT 1 acts as a char device; PORT 2 acts as a block device
6028+ 3AF6              ; DATA,PARITY, and STOP are optional: if nothing follows BPS,
6029+ 3AF6              ; they are assumed to be 8,0,1 resp.
6030+ 3AF6              PRTNUM  equ     VIDEOBUFF
6031+ 3AF6              BPS     equ     PRTNUM+$01
6032+ 3AF6              DATABT  equ     BPS+$02
6033+ 3AF6              PARBT   equ     DATABT+$01
6034+ 3AF6              STPBT   equ     PARBT+$01
6035+ 3AF6              SIOBFR  equ     STPBT+$01
6036+ 3AF6 CD 23 29     SERIAL: call    GETINT          ; get port #
6037+ 3AF9 A7                   and     A               ; is it zero?
6038+ 3AFA CA D7 1C             jp      Z,FCERR         ; yes, error
6039+ 3AFD FE 03                cp      $03             ; is it 1 or 2?
6040+ 3AFF D2 1F 3D             jp      NC,SCERR        ; no, error
6041+ 3B02 32 2A 53             ld      (PRTNUM),A      ; store port number into a temp buffer
6042+ 3B05 CD C3 19             call    CHKSYN          ; Make sure ',' follows
6043+ 3B08 2C                   defb    ','
6044+ 3B09 2B                   dec     HL
6045+ 3B0A CD 0C 1C             call    GETCHR          ; check what's following
6046+ 3B0D CA C9 16             jp      Z,SNERR         ; error if nothing follows
6047+ 3B10 30 05                jr      NC,SERVAR       ; it's not a number, try a variable
6048+ 3B12 CD DC 1C             call    ATOH            ; get bps (returned into DE)
6049+ 3B15 18 0F                jr      CHKZSER         ; jump over
6050+ 3B17 CD 9D 20     SERVAR: call    GETNUM          ; get number
6051+ 3B1A CD AA 2E             call    TSTSGN          ; check value
6052+ 3B1D FA D7 1C             jp      M,FCERR         ; negative - illegal function call
6053+ 3B20 3A 79 53             ld      A,(FPEXP)       ; Get integer value to DE
6054+ 3B23 CD 52 2F             call    FPINT           ; get integer number into BCDE - drop BC 'cause isn't necessary
6055+ 3B26 7A           CHKZSER:ld      A,D             ; bps is into DE - move MSB into A
6056+ 3B27 B3                   or      E               ; check if bps=0
6057+ 3B28 20 3A                jr      NZ,CNTSER       ; no, continue checking
6058+ 3B2A                      ; if baud rate is 0, then close the serial comm.
6059+ 3B2A 3A 2A 53     RSTSERS:ld      A,(PRTNUM)      ; yes, so reset the channel. First, load port number
6060+ 3B2D 3D                   dec     A               ; subtract 1, so that serial channel is 0=>A and 1=>B
6061+ 3B2E C6 22                add     SIO_CA          ; find correct channel
6062+ 3B30 4F                   ld      C,A             ; store serial channel
6063+ 3B31 F3                   di                      ; disable INTs
6064+ 3B32 AF                   xor     A               ; reset A
6065+ 3B33 16 01                ld      D,$01           ; start from WR1
6066+ 3B35 06 05                ld      B,$05           ; 5 registers
6067+ 3B37 ED 51        RPTRSSR:out     (C),D           ; select register
6068+ 3B39 ED 79                out     (C),A           ; reset register
6069+ 3B3B 14                   inc     D               ; next register
6070+ 3B3C 10 F9                djnz    RPTRSSR         ; repeat
6071+ 3B3E 3E 30                ld      A,%00110000     ; write into WR0: error reset, select WR0
6072+ 3B40 ED 79                out     (C),A           ; send command to serial channel
6073+ 3B42 3E 18                ld      A,%00011000     ; write into WR0: channel reset
6074+ 3B44 ED 79                out     (C),A           ; send command to serial channel
6075+ 3B46 FB                   ei                      ; re-enable INTs
6076+ 3B47 E5                   push    HL              ; store HL
6077+ 3B48 21 64 53             ld      HL,SERIALS_EN   ; serials enabled status byte
6078+ 3B4B DB 01                in      A,(PIO_DB)      ; read status LEDs
6079+ 3B4D CB 41                bit     0,C             ; check serial port
6080+ 3B4F 20 09                jr      NZ,SRPT2        ; if bit is set, jump to port 2
6081+ 3B51 CB B7                res     6,A             ; it's port 1
6082+ 3B53 CB A7                res     4,A             ; remove possible error LED
6083+ 3B55 CB 86                res     0,(HL)          ; disable port 1
6084+ 3B57 C3 60 3B             jp      SERLED          ; jump over
6085+ 3B5A CB BF        SRPT2:  res     7,A             ; it's port 2
6086+ 3B5C CB AF                res     5,A             ; remove possible error LED
6087+ 3B5E CB 8E                res     1,(HL)          ; disable port 2
6088+ 3B60 D3 01        SERLED: out     (PIO_DB),A      ; send new configuration
6089+ 3B62 E1                   pop     HL              ; retrieve HL
6090+ 3B63 C9                   ret                     ; return to caller
6091+ 3B64                      ; check if bps=1, meaning reactivate RX on serial
6092+ 3B64 7A           CNTSER: ld      A,D
6093+ 3B65 B2                   or      D               ; check if bps<>1 by first checking D=0
6094+ 3B66 20 36                jr      NZ,CNTSER2      ; if not, jump over
6095+ 3B68 7B                   ld      A,E             ; then by checking that
6096+ 3B69 FE 01                cp      $01             ; E=1
6097+ 3B6B 20 31                jr      NZ,CNTSER2      ; if not, jump over
6098+ 3B6D 3A 2A 53             ld      A,(PRTNUM)      ; load port number
6099+ 3B70 57                   ld      D,A             ; store port on D
6100+ 3B71 3A 64 53             ld      A,(SERIALS_EN)  ; load address of serial status cell
6101+ 3B74 A2                   and     D               ; check status
6102+ 3B75 CA 1F 3D             jp      Z,SCERR         ; port not open, raise error
6103+ 3B78 F3                   di                      ; disable INTs
6104+ 3B79 7A                   ld      A,D             ; move port # into A
6105+ 3B7A 5F                   ld      E,A             ; and also into E
6106+ 3B7B 87                   add     A
6107+ 3B7C 87                   add     A               ; move A to left times 2
6108+ 3B7D 57                   ld      D,A             ; move value into D
6109+ 3B7E 3A 64 53             ld      A,(SERIALS_EN)  ; load serial status byte
6110+ 3B81 B2                   or      D               ; re-enable RX
6111+ 3B82 32 64 53             ld      (SERIALS_EN),A  ; store new serial status
6112+ 3B85 7B                   ld      A,E             ; recover port #
6113+ 3B86 3D                   dec     A               ; check port
6114+ 3B87 20 0A                jr      NZ,CNTRX2       ; port is #2
6115+ 3B89 CD E3 01             call    SIO_A_EI        ; re-enable RX on port 1
6116+ 3B8C DB 01                in      A,(PIO_DB)      ; load status LEDs
6117+ 3B8E CB A7                res     4,A             ; remove error LED
6118+ 3B90 C3 9A 3B             jp      RXEND           ; terminate setting
6119+ 3B93 CD EB 01     CNTRX2: call    SIO_B_EI        ; re-enable RX on port 2
6120+ 3B96 DB 01                in      A,(PIO_DB)      ; load status LEDs
6121+ 3B98 CB AF                res     5,A             ; remove error LED
6122+ 3B9A D3 01        RXEND:  out     (PIO_DB),A      ; set new status for LEDs
6123+ 3B9C FB                   ei                      ; re-enable INTs
6124+ 3B9D C9                   ret                     ; return to caller
6125+ 3B9E                      ; set serial port comm.
6126+ 3B9E D5           CNTSER2:push    DE              ; store BPS
6127+ 3B9F 3A 2A 53             ld      A,(PRTNUM)      ; load port number
6128+ 3BA2 57                   ld      D,A             ; move port # into D
6129+ 3BA3 3A 64 53             ld      A,(SERIALS_EN)  ; check if serial port is already open
6130+ 3BA6 A2                   and     D               ; by ANDing A with D
6131+ 3BA7 D1                   pop     DE              ; retrieve BPS
6132+ 3BA8 CA B0 3B             jp      Z,CNTSER3       ; not open, continue
6133+ 3BAB 1E 2E                ld      E,SA            ; already open, so raise a "Serial Port Already Error"
6134+ 3BAD C3 DD 16             jp      ERROR           ; and leave
6135+ 3BB0 E5           CNTSER3:push    HL              ; store HL
6136+ 3BB1 21 00 E1             ld      HL,$E100        ; check bps. start with HL=57,600
6137+ 3BB4 CD DE 3F             call    CMP16           ; is bps<=57,600?
6138+ 3BB7 E1                   pop     HL              ; but first, recover HL
6139+ 3BB8 DA 1F 3D             jp      C,SCERR         ; no (bps>57,600) then error
6140+ 3BBB ED 53 2B 53          ld      (BPS),DE        ; store bps
6141+ 3BBF 2B                   dec     HL              ; dec 'cos GETCHR INCs
6142+ 3BC0 CD 0C 1C             call    GETCHR          ; Get next character
6143+ 3BC3 CA FB 3B             jp      Z,DEFSER        ; defaults if nothing follows
6144+ 3BC6 CD C3 19             call    CHKSYN          ; Make sure ',' follows
6145+ 3BC9 2C                   defb    ','
6146+ 3BCA CD 23 29             call    GETINT          ; get data bits
6147+ 3BCD FE 05                cp      $05             ; is it <5?
6148+ 3BCF DA 1F 3D             jp      C,SCERR         ; yes, error
6149+ 3BD2 FE 09                cp      $09             ; is it >=9?
6150+ 3BD4 D2 D7 1C             jp      NC,FCERR        ; yes, error
6151+ 3BD7 32 2D 53             ld      (DATABT),A      ; store data bits
6152+ 3BDA CD C3 19             call    CHKSYN          ; Make sure ',' follows
6153+ 3BDD 2C                   defb    ','
6154+ 3BDE CD 23 29             call    GETINT          ; get parity bits
6155+ 3BE1 BF FE 03             cp      A,$03           ; check if parity is in range 0~2
6156+ 3BE4 D2 1F 3D             jp      NC,SCERR        ; no, error
6157+ 3BE7 32 2E 53             ld      (PARBT),A       ; store parity
6158+ 3BEA CD C3 19             call    CHKSYN          ; Make sure ',' follows
6159+ 3BED 2C                   defb    ','
6160+ 3BEE CD 23 29             call    GETINT          ; get stop bits
6161+ 3BF1 FE 03                cp      $03             ; is it >=3?
6162+ 3BF3 D2 1F 3D             jp      NC,SCERR        ; yes, error
6163+ 3BF6 32 2F 53             ld      (STPBT),A       ; store stop bits
6164+ 3BF9 18 0D                jr      SETSER          ; jump to set serial
6165+ 3BFB 3E 08        DEFSER: ld      A,$08           ; 8 bits for data
6166+ 3BFD 32 2D 53             ld      (DATABT),A
6167+ 3C00 AF                   xor     A               ; no parity bit
6168+ 3C01 32 2E 53             ld      (PARBT),A
6169+ 3C04 3C                   inc     A               ; 1 bit for stop
6170+ 3C05 32 2F 53             ld      (STPBT),A
6171+ 3C08                      ; check if bps are legal
6172+ 3C08 E5           SETSER: push    HL              ; store HL
6173+ 3C09 D5                   push    DE              ; store DE
6174+ 3C0A DD E5                push    IX              ; store IX
6175+ 3C0C DD 21 FA 3C          ld      IX,SUP_BPS      ; allowed BPSs
6176+ 3C10 06 0B                ld      B,$0B           ; 11 items
6177+ 3C12 0E 00                ld      C,$00           ; reset pointer
6178+ 3C14 2A 2B 53     CKBPS:  ld      HL,(BPS)        ; load BPS
6179+ 3C17 DD 5E 00             ld      E,(IX+0)        ; load LSB of item
6180+ 3C1A DD 56 01             ld      D,(IX+1)        ; load MSB of item
6181+ 3C1D CD DE 3F             call    CMP16           ; is it equal?
6182+ 3C20 CA 2D 3C             jp      Z,SET_PT        ; yes, found a correspondance
6183+ 3C23 DD 23                inc     IX
6184+ 3C25 DD 23                inc     IX              ; no, go to next entry
6185+ 3C27 0C                   inc     C               ; increment pointer
6186+ 3C28 10 EA                djnz    CKBPS           ; repeat for 10 entries
6187+ 3C2A C3 1B 3D             jp      SCERR1          ; if nothing found, raise an error
6188+ 3C2D              SET_PT: ;init CTC CH0: CH0 provides RX/TX clock to SIO port A
6189+ 3C2D                      ; TO0 output frequency=INPUT CLK/time constant. Time constant is set to get 16 times
6190+ 3C2D                      ; the requested baud rate. I.e., if bps is 19,200 then time constast is set to 6 because
6191+ 3C2D                      ; 1,843,200/6 = 307,200 Hz (that is 19,200 x 16)
6192+ 3C2D F3                   di                      ; disable INTs
6193+ 3C2E 06 00                ld      B,$00           ; reset B
6194+ 3C30 21 10 3D             ld      HL,CTC_CFG      ; address of first CTC divider
6195+ 3C33 09                   add     HL,BC           ; adjust for correct CTC divider
6196+ 3C34 0E 10                ld      C,CTC_CH0       ; CTC channel 0
6197+ 3C36 3A 2A 53             ld      A,(PRTNUM)      ; load port number
6198+ 3C39 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6199+ 3C3A DA 3E 3C             jp      C,SET_CTC       ; port 1 => ch. 0, so continue
6200+ 3C3D 0C                   inc     C               ; port 2 => ch. 1, increment address port into C
6201+ 3C3E 3E 47        SET_CTC:ld      A,%01000111     ; interrupt off, counter mode, prsc=16 (doesn't matter), ext. start,
6202+ 3C40                                              ; start upon loading time constant, time constant follows, sw reset, command word
6203+ 3C40 ED 79                out     (C),A           ; configure CTC channel
6204+ 3C42 7E                   ld      A,(HL)          ; load CTC divider
6205+ 3C43 ED 79                out     (C),A           ; send divider
6206+ 3C45                      ; configure SIO
6207+ 3C45 21 36 03             ld      HL,SIO_A_SETS   ; load default settings for SIO
6208+ 3C48 11 30 53             ld      DE,SIOBFR       ; into a temp buffer
6209+ 3C4B 01 0A 00             ld      BC,$000A        ; 10 items to copy
6210+ 3C4E ED B0                ldir                    ; copy SIO settings into TEMP buffer
6211+ 3C50 3A 35 53             ld      A,(SIOBFR+5)    ; load WR5 setting
6212+ 3C53 47                   ld      B,A             ; move it into B
6213+ 3C54 3A 2D 53             ld      A,(DATABT)      ; load DATA bits
6214+ 3C57 FE 05                cp      $05             ; is it 5 bits?
6215+ 3C59 20 06                jr      NZ,BITS6        ; no, jump over
6216+ 3C5B CB B0                res     6,B
6217+ 3C5D CB A8                res     5,B             ; set D6 & D5 to 0
6218+ 3C5F 18 19                jr      SETPAR          ; jump to set parity
6219+ 3C61 FE 06        BITS6:  cp      $06             ; is it 6 bits?
6220+ 3C63 20 06                jr      NZ,BITS7        ; no, jump over
6221+ 3C65 CB F0                set     6,B
6222+ 3C67 CB A8                res     5,B             ; set D6 & D5 to 1,0
6223+ 3C69 18 0F                jr      SETPAR          ; jump to set parity
6224+ 3C6B FE 07        BITS7:  cp      $07             ; is it 7 bits?
6225+ 3C6D 20 07                jr      NZ,BITS8        ; no, jump over
6226+ 3C6F CB B0                res     6,B
6227+ 3C71 CB E8                set     5,B             ; set D6 & D5 to 0,1
6228+ 3C73 C3 7A 3C             jp      SETPAR          ; jump to set parity
6229+ 3C76 CB F0        BITS8:  set     6,B
6230+ 3C78 CB E8                set     5,B             ; set D6 & D5 to 1,1
6231+ 3C7A 21 65 53     SETPAR: ld      HL,SERABITS     ; load address for storing data bits
6232+ 3C7D 3A 2A 53             ld      A,(PRTNUM)      ; check serial port number
6233+ 3C80 3D                   dec     A               ; is it port #1?
6234+ 3C81 CA 85 3C             jp      Z,SETPAR2       ; yes, jump over
6235+ 3C84 23                   inc     HL              ; port #2, use SERBBITS instead
6236+ 3C85 78           SETPAR2:ld      A,B             ; retrieve DATA bits
6237+ 3C86 32 35 53             ld      (SIOBFR+5),A    ; save DATA bits
6238+ 3C89 E6 60                and     %01100000       ; filter only D5&D6 bits
6239+ 3C8B 87                   add     A,A             ; shift left times 1
6240+ 3C8C 77                   ld      (HL),A          ; store for SIO_EI & SIO_DI functions
6241+ 3C8D 3A 2F 53             ld      A,(STPBT)       ; load STOP bits
6242+ 3C90 87                   add     A,A
6243+ 3C91 87                   add     A,A             ; 2 left shifts
6244+ 3C92 47                   ld      B,A             ; move forming byte into B
6245+ 3C93 3A 2E 53             ld      A,(PARBT)       ; load PARITY setting
6246+ 3C96 A7                   and     A               ; is it 0?
6247+ 3C97 CA A2 3C             jp      Z,STRPAR        ; yes, jump over
6248+ 3C9A CB C0                set     0,B             ; set PARITY on
6249+ 3C9C 3D                   dec     A               ; is parity ODD?
6250+ 3C9D CA A2 3C             jp      Z,STRPAR        ; yes, so jump over
6251+ 3CA0 CB C8                set     1,B             ; no, it's EVEN so set the corresponding bit
6252+ 3CA2 3A 33 53     STRPAR: ld      A,(SIOBFR+3)    ; load WR4 setting
6253+ 3CA5 E6 F0                and     %11110000       ; reset STOP & PARITY bits
6254+ 3CA7 B0                   or      B               ; set new STOP & PARITY bits
6255+ 3CA8 32 33 53             ld      (SIOBFR+3),A    ; store new value
6256+ 3CAB                      ;set up TX and RX:
6257+ 3CAB                      ; the followings are settings for channel A
6258+ 3CAB 21 30 53             ld      HL,SIOBFR       ; settings for SIO ch. A
6259+ 3CAE 06 06                ld      B,$06           ; 6 bytes to send
6260+ 3CB0 0E 22                ld      C,SIO_CA        ; I/O address of SIO ch.A
6261+ 3CB2 3A 2A 53             ld      A,(PRTNUM)      ; load port number
6262+ 3CB5 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6263+ 3CB6 DA BA 3C             jp      C,SRLCNT        ; port 1, continue
6264+ 3CB9 0C                   inc     C               ; port 2, increment address port into C
6265+ 3CBA ED B3        SRLCNT: otir                    ; send bytes to SIO
6266+ 3CBC                      ; the following are settings for channel B (don't need to load HL since settings are contigous)
6267+ 3CBC 06 04                ld      B,$04           ; other 4 bytes to send
6268+ 3CBE 51                   ld      D,C             ; store port address into D
6269+ 3CBF 0E 23                ld      C,SIO_CB        ; I/O address of SIO ch.B
6270+ 3CC1 ED B3                otir                    ; send bytes to SIO
6271+ 3CC3                      ; the following are settings for selected channel
6272+ 3CC3 3E 01                ld      A,$01           ; write into WR0: select WR1
6273+ 3CC5 4A                   ld      C,D             ; retrieve port address
6274+ 3CC6 ED 79                out     (C),A
6275+ 3CC8 3E 18                ld      A,%00011000     ; interrupts on every RX char; parity is no special condition;
6276+ 3CCA                                              ; buffer overrun is special condition
6277+ 3CCA ED 79                out     (C),A
6278+ 3CCC 21 64 53             ld      HL,SERIALS_EN
6279+ 3CCF 3A 2A 53             ld      A,(PRTNUM)      ; retrieve serial channel
6280+ 3CD2 3D                   dec     A               ; channel A?
6281+ 3CD3 20 10                jr      NZ,ENCHB        ; no, jump over
6282+ 3CD5 CD E3 01             call    SIO_A_EI        ; enable RX on SIO channel A
6283+ 3CD8 CB C6                set     0,(HL)          ; set serial port 1 status ON
6284+ 3CDA CB D6                set     2,(HL)          ; set serial port 1 RX ON
6285+ 3CDC                      ; back to normal running
6286+ 3CDC FB                   ei                      ; re-enable INTs
6287+ 3CDD DB 01                in      A,(PIO_DB)      ; load status LEDs
6288+ 3CDF CB F7                set     6,A             ; set status LED on
6289+ 3CE1 CB A7                res     4,A             ; set error LED off
6290+ 3CE3 18 0E                jr      EXNRM           ; leave
6291+ 3CE5 CD EB 01     ENCHB:  call    SIO_B_EI        ; enable RX on SIO channel B
6292+ 3CE8 CB CE                set     1,(HL)          ; set serial port 2 status ON
6293+ 3CEA CB DE                set     3,(HL)          ; set serial port 2 RX ON
6294+ 3CEC                      ; back to normal running
6295+ 3CEC FB                   ei                      ; re-enable INTs
6296+ 3CED DB 01                in      A,(PIO_DB)      ; load status LEDs
6297+ 3CEF CB FF                set     7,A             ; set status LED on
6298+ 3CF1 CB AF                res     5,A             ; set error LED off
6299+ 3CF3 D3 01        EXNRM:  out     (PIO_DB),A      ; send new configuration
6300+ 3CF5 DD E1                pop     IX              ; retrieve IX
6301+ 3CF7 D1                   pop     DE              ; retrieve DE
6302+ 3CF8 E1                   pop     HL              ; retrieve HL
6303+ 3CF9 C9                   ret                     ; return to caller
6304+ 3CFA
6305+ 3CFA              ; allowed bps (Bauds per second)
6306+ 3CFA 00 E1 00 96  SUP_BPS:defw    57600,38400,28800,19200,14400,9600,4800,3600,2400,1200,600
6306+ 3CFE 80 70 00 4B
6306+ 3D02 40 38 80 25
6306+ 3D06 C0 12 10 0E
6306+ 3D0A 60 09 B0 04
6306+ 3D0E 58 02
6307+ 3D10              ; corresponding CTC divider
6308+ 3D10 02 03 04 06  CTC_CFG:defb    2,3,4,6,8,12,24,32,48,96,192
6308+ 3D14 08 0C 18 20
6308+ 3D18 30 60 C0
6309+ 3D1B
6310+ 3D1B
6311+ 3D1B              ; serial configuration error
6312+ 3D1B DD E1        SCERR1: pop     IX              ; retrieve IX
6313+ 3D1D D1                   pop     DE              ; retrieve DE
6314+ 3D1E E1                   pop     HL              ; retrieve HL
6315+ 3D1F 1E 2C        SCERR:  ld      E,SC            ; Serial Configuration Error
6316+ 3D21 C3 DD 16             jp      ERROR           ; print error
6317+ 3D24
6318+ 3D24
6319+ 3D24              ; serial buffer overrun
6320+ 3D24 CD D9 1E     SOERR:  call    PRNTCRLF
6321+ 3D27 1E 30                ld      E,SO            ; Serial Buffer Overrun
6322+ 3D29 C3 DD 16             jp      ERROR
6323+ 3D2C
6324+ 3D2C
6325+ 3D2C              ; check for direct mode
6326+ 3D2C E5           DIRMOD: push    HL              ; Save code string address
6327+ 3D2D 2A F4 51             ld      HL,(LINEAT)     ; Get current line number
6328+ 3D30 23                   inc     HL              ; -1 means direct statement
6329+ 3D31 7C                   ld      A,H
6330+ 3D32 B5                   or      L
6331+ 3D33 E1                   pop     HL              ; Restore code string address
6332+ 3D34 C2 4E 3D             jp      NZ,HLPERR       ; raise error if in indirect mode
6333+ 3D37 C9                   ret
6334+ 3D38
6335+ 3D38
6336+ 3D38              ; HELP lists the line program where an error occured
6337+ 3D38 CD 2C 3D     HELP:   call    DIRMOD          ; check if in direct mode
6338+ 3D3B E5                   push    HL              ; store HL
6339+ 3D3C 2A F6 51             ld      HL,(HLPLN)      ; load HELP line
6340+ 3D3F 23                   inc     HL              ; increment HL
6341+ 3D40 7C                   ld      A,H
6342+ 3D41 B5                   or      L               ; check if there is a line into the HELP reg.
6343+ 3D42 E1                   pop     HL
6344+ 3D43 CA 4E 3D             jp      Z,HLPERR        ; no line found, raise error
6345+ 3D46 ED 5B F6 51          ld      DE,(HLPLN)      ; recover line
6346+ 3D4A C1                   pop     BC              ; remove BC from stack since it's not needed anymore for LIST
6347+ 3D4B C3 59 1A             jp      LST01H          ; jump to list line
6348+ 3D4E 1E 32        HLPERR: ld      E,HP            ; HELP call error
6349+ 3D50 C3 DD 16             jp      ERROR           ; raise error
6350+ 3D53
6351+ 3D53
6352+ 3D53              ; KEY command to list/modify function keys and auto-repeat
6353+ 3D53 2B           KEY:    dec     HL              ; dec 'cos GETCHR INCs
6354+ 3D54 CD 0C 1C             call    GETCHR          ; Get next character
6355+ 3D57 CA D7 3D             jp      Z,LSTKEYS       ; jump if nothing follows
6356+ 3D5A                      ; change FN keys
6357+ 3D5A CD 23 29             call    GETINT          ; get a number
6358+ 3D5D A7                   and     A               ; is it 0?
6359+ 3D5E 20 10                jr      NZ,KEYCH        ; no, jump over
6360+ 3D60 E5           RESFN:  push    HL              ; yes - reset FN keys to defaults
6361+ 3D61 D5                   push    DE              ; store HL & DE
6362+ 3D62 21 B7 15             ld      HL,AUTORP       ; pointer to default auto-repeat delays and FN keys texts
6363+ 3D65 11 F8 51             ld      DE,KEYDEL       ; pointer to destination
6364+ 3D68 01 82 00             ld      BC,$0082        ; 130 chars to be copied (2xauto-delay, 128xFN keys)
6365+ 3D6B ED B0                ldir                    ; restore default texts
6366+ 3D6D D1                   pop     DE              ; retrieve DE
6367+ 3D6E E1                   pop     HL              ; retrieve HL
6368+ 3D6F C9                   ret                     ; return to caller
6369+ 3D70 FE 09        KEYCH:  cp      $09             ; is it >= 9?
6370+ 3D72 D2 8A 3E             jp      NC,SETREP       ; yes - jump over
6371+ 3D75 3D                   dec     A               ; FN key in range 0~7
6372+ 3D76 87                   add     A,A             ; multiply A...
6373+ 3D77 87                   add     A,A             ; ... times 4...
6374+ 3D78 87                   add     A,A             ; ... to get the correct...
6375+ 3D79 87                   add     A,A             ; ... offset fo FN key text
6376+ 3D7A 32 22 53             ld      (TMPBFR1),A     ; store FN key offset...
6377+ 3D7D AF                   xor     A               ; ...in a...
6378+ 3D7E 32 23 53             ld      (TMPBFR1+1),A   ; ...16-bit register
6379+ 3D81 CD C3 19             call    CHKSYN          ; Make sure ',' follows
6380+ 3D84 2C                   defb    ','
6381+ 3D85 44 4D                ld      BC,HL           ; copy address into BC
6382+ 3D87 CD AF 20             call    EVAL            ; Evaluate expression (in E there is the length)
6383+ 3D8A E5                   push    HL              ; store string pointer
6384+ 3D8B 3A D9 52             ld      A,(TYPE)        ; Get variable type
6385+ 3D8E B7                   or      A               ; Is it a string variable?
6386+ 3D8F CA C9 16             jp      Z,SNERR         ; no - syntax error
6387+ 3D92 CD E8 26             call    GSTRCU          ; Current string to pool
6388+ 3D95 CD F9 2E             call    LOADFP          ; Move string block data to (BC=pointer, DE=length)
6389+ 3D98 7B                   ld      A,E             ; copy length into A
6390+ 3D99 FE 11                cp      $11             ; is length > 16?
6391+ 3D9B DA A0 3D             jp      C,DECLN1        ; no, jump over
6392+ 3D9E 1E 10                ld      E,$10           ; yes, so set length to 16
6393+ 3DA0 3E 10        DECLN1: ld      A,$10           ; calculate how many...
6394+ 3DA2 93                   sub     E               ; ...null chars needed to fill up...
6395+ 3DA3 57                   ld      D,A             ; ...the FN key text
6396+ 3DA4 C5                   push    BC              ; store address of string
6397+ 3DA5 ED 4B 22 53          ld      BC,(TMPBFR1)    ; load FN key offset
6398+ 3DA9 21 FA 51             ld      HL,FNKEYS       ; load address of FN keys texts
6399+ 3DAC 09                   add     HL,BC           ; get corrected address
6400+ 3DAD C1                   pop     BC              ; retrieve address of string chars
6401+ 3DAE 0A           CPKEY:  ld      A,(BC)          ; load char from string
6402+ 3DAF FE 0D                cp      CR              ; return?
6403+ 3DB1 CA BE 3D             jp      Z,CPKEY2        ; yes, store char
6404+ 3DB4 FE 7B                cp      $7B             ; if char > "z" ?
6405+ 3DB6 D2 C9 16             jp      NC,SNERR        ; yes - syntax error
6406+ 3DB9 FE 20                cp      $20             ; is char < space?
6407+ 3DBB DA C9 16             jp      C,SNERR         ; yes - syntax error
6408+ 3DBE FE 61        CPKEY2: cp      $61             ; is it >= 'a'?
6409+ 3DC0 DA C5 3D             jp      C,CPKEY3        ; no, continue
6410+ 3DC3 E6 5F                and     %01011111       ; set letters to uppercase
6411+ 3DC5 77           CPKEY3: ld      (HL),A          ; store char
6412+ 3DC6 23                   inc     HL              ; next string char
6413+ 3DC7 03                   inc     BC              ; next free cell
6414+ 3DC8 1D                   dec     E               ; decrement E
6415+ 3DC9 20 E3                jr      NZ,CPKEY        ; repeat until 0
6416+ 3DCB AF                   xor     A               ; null char
6417+ 3DCC 14                   inc     D               ; +1 to decrement below
6418+ 3DCD 15           CPKEY1: dec     D               ; how many null chars to insert?
6419+ 3DCE CA D5 3D             jp      Z,CPKYEND       ; no more nulls, so exit
6420+ 3DD1 77                   ld      (HL),A          ; store it
6421+ 3DD2 23                   inc     HL              ; next cell
6422+ 3DD3 18 F8                jr      CPKEY1          ; repeat
6423+ 3DD5 E1           CPKYEND:pop     HL              ; retrieve pointer to string
6424+ 3DD6 C9                   ret                     ; return to caller
6425+ 3DD7                                              ; list FN keys
6426+ 3DD7 E5           LSTKEYS:push    HL              ; Save code string address
6427+ 3DD8 2A F4 51             ld      HL,(LINEAT)     ; Get current line number
6428+ 3DDB 23                   inc     HL              ; -1 means direct statement
6429+ 3DDC 7C                   ld      A,H
6430+ 3DDD B5                   or      L
6431+ 3DDE E1                   pop     HL              ; Restore code string address
6432+ 3DDF C2 C9 16             jp      NZ,SNERR        ; raise error if in indirect mode
6433+ 3DE2 E5                   push    HL              ; store HL
6434+ 3DE3 D5                   push    DE              ; store DE
6435+ 3DE4 21 FA 51             ld      HL,FNKEYS       ; load starting address of FN keys text
6436+ 3DE7 0E 01                ld      C,$01           ; 8 function keys
6437+ 3DE9 06 10        PRTK4:  ld      B,$10           ; 16 chars each
6438+ 3DEB 11 AC 3E     PRTK2:  ld      DE,CHKEY1       ; message "KEY "
6439+ 3DEE CD 7B 3E             call    PRTCKEY         ; print it
6440+ 3DF1 79                   ld      A,C             ; load FN key
6441+ 3DF2 C6 30                add     $30             ; get number in ASCI code
6442+ 3DF4 CD CE 19             call    OUTC            ; print it
6443+ 3DF7 11 B1 3E             ld      DE,CHKEY2       ; message ": ""
6444+ 3DFA CD 7B 3E             call    PRTCKEY         ; print it
6445+ 3DFD 3E 01                ld      A,$01           ; " opened
6446+ 3DFF 32 22 53             ld      (TMPBFR1),A
6447+ 3E02 7E           LDKEY:  ld      A,(HL)          ; retrieve char
6448+ 3E03 A7                   and     A               ; is it zero?
6449+ 3E04 CA 17 3E             jp      Z,CNTLTK        ; yes, go next char
6450+ 3E07 CD 63 3E             call    OPNQT           ; check if quotes are opened
6451+ 3E0A FE 22                cp      $22             ; check if char is "?
6452+ 3E0C CA 2C 3E             jp      Z,PRTCHR        ; yes, print "chr$("
6453+ 3E0F FE 0D                cp      CR              ; is it a CR?
6454+ 3E11 CA 2C 3E             jp      Z,PRTCHR        ; yes, print "chr$("
6455+ 3E14 CD CE 19     PRTK3:  call    OUTC            ; no, just print it
6456+ 3E17 23           CNTLTK: inc     HL              ; next char
6457+ 3E18 10 E8                djnz    LDKEY           ; continue until finished
6458+ 3E1A CD 51 3E             call    CLSQT           ; check if quotes are still open
6459+ 3E1D 3E 0D                ld      A,CR            ; go next line
6460+ 3E1F CD CE 19             call    OUTC            ; print it
6461+ 3E22 0C                   inc     C               ; next FN key
6462+ 3E23 79                   ld      A,C             ; check if...
6463+ 3E24 FE 09                cp      $09             ; finished keys?
6464+ 3E26 DA E9 3D             jp      C,PRTK4         ; no, repeat 1 more time
6465+ 3E29 D1                   pop     DE              ; retrieve DE
6466+ 3E2A E1                   pop     HL              ; retrieve HL
6467+ 3E2B C9                   ret                     ; return to caller
6468+ 3E2C E5           PRTCHR: push    HL              ; store HL
6469+ 3E2D CD 51 3E             call    CLSQT           ; check if quotes are closed
6470+ 3E30 3E 2B                ld      A,'+'           ; '+' char
6471+ 3E32 CD CE 19             call    OUTC            ; print it
6472+ 3E35 11 B4 3E             ld      DE,CHKEY3       ; address of "CHR$("
6473+ 3E38 CD 7B 3E             call    PRTCKEY         ; print it
6474+ 3E3B E1                   pop     HL              ; recover HL
6475+ 3E3C 23                   inc     HL              ; next char
6476+ 3E3D 05                   dec     B               ; increment char counter
6477+ 3E3E 11 BA 3E             ld      DE,CHKEY4       ; load address of RETURN
6478+ 3E41 7E                   ld      A,(HL)          ; load char
6479+ 3E42 FE 0D                cp      CR              ; is it a RETURN?
6480+ 3E44 20 03                jr      NZ,PTCHR1       ; no, jump over
6481+ 3E46 11 BD 3E             ld      DE,CHKEY5       ; yes, load address of "
6482+ 3E49 CD 7B 3E     PTCHR1: call    PRTCKEY         ; print it
6483+ 3E4C 3E 29                ld      A,')'           ; char )
6484+ 3E4E C3 14 3E             jp      PRTK3           ; continue
6485+ 3E51 F5           CLSQT:  push    AF              ; store A
6486+ 3E52 3A 22 53             ld      A,(TMPBFR1)     ; quote status
6487+ 3E55 A7                   and     A               ; are they closed?
6488+ 3E56 28 09                jr      Z,CLSQT1        ; if yes, return
6489+ 3E58 3E 22                ld      A,$22           ; no, so close them
6490+ 3E5A CD CE 19             call    OUTC            ; print "
6491+ 3E5D AF                   xor     A               ; set quotes
6492+ 3E5E 32 22 53             ld      (TMPBFR1),A     ; as closed
6493+ 3E61 F1           CLSQT1: pop     AF              ; retrieve A
6494+ 3E62 C9                   ret                     ; return to caller
6495+ 3E63 F5           OPNQT:  push    AF              ; store A
6496+ 3E64 3A 22 53             ld      A,(TMPBFR1)     ; quote status
6497+ 3E67 A7                   and     A               ; are they open?
6498+ 3E68 20 0F                jr      NZ,OPNQT1       ; if yes, return
6499+ 3E6A 3E 2B                ld      A,'+'           ; no, so add '+
6500+ 3E6C CD CE 19             call    OUTC            ; print it
6501+ 3E6F 3E 22                ld      A,$22           ; and then open quotes
6502+ 3E71 CD CE 19             call    OUTC            ; print them
6503+ 3E74 3E 01                ld      A,$01           ; set quotes
6504+ 3E76 32 22 53             ld      (TMPBFR1),A     ; as opened
6505+ 3E79 F1           OPNQT1: pop     AF              ; retrieve A
6506+ 3E7A C9                   ret                     ; return to caller
6507+ 3E7B F5           PRTCKEY:push    AF              ; store original char
6508+ 3E7C 1A           PRTK1:  ld      A,(DE)          ; load char
6509+ 3E7D A7                   and     A               ; is it 0?
6510+ 3E7E CA 88 3E             jp      Z,PRTEND        ; yes, finished printing
6511+ 3E81 CD CE 19             call    OUTC            ; no, print char
6512+ 3E84 13                   inc     DE              ; next char
6513+ 3E85 C3 7C 3E             jp      PRTK1           ; repeat
6514+ 3E88 F1           PRTEND: pop     AF              ; retrieve AF
6515+ 3E89 C9                   ret                     ; return to caller
6516+ 3E8A FE 09        SETREP: cp      $09             ; is it special key 9? (stands for auto-repeat)
6517+ 3E8C C2 C9 16             jp      NZ,SNERR        ; no, raise an error
6518+ 3E8F CD C3 19             call    CHKSYN          ; Check for comma
6519+ 3E92 2C                   defb    ','
6520+ 3E93 CD 23 29             call    GETINT          ; get a number
6521+ 3E96 32 22 53             ld      (TMPBFR1),A     ; store it
6522+ 3E99 CD C3 19             call    CHKSYN          ; Check for comma
6523+ 3E9C 2C                   defb    ','
6524+ 3E9D CD 23 29             call    GETINT          ; get another number
6525+ 3EA0 E5                   push    HL              ; store HL
6526+ 3EA1 21 F9 51             ld      HL,AUTOKE       ; address of second cell for key auto-repeat
6527+ 3EA4 77                   ld      (HL),A          ; store auto-repeat delay
6528+ 3EA5 2B                   dec     HL              ; previous cell
6529+ 3EA6 3A 22 53             ld      A,(TMPBFR1)     ; retrieve value
6530+ 3EA9 77                   ld      (HL),A          ; store delay for auto-repeat
6531+ 3EAA E1                   pop     HL              ; retrieve HL
6532+ 3EAB C9                   ret
6533+ 3EAC 4B 45 59 20  CHKEY1: defb    "KEY ",0
6533+ 3EB0 00
6534+ 3EB1 3A 22 00     CHKEY2: defb    ":",34,0
6535+ 3EB4 63 68 72 24  CHKEY3: defb    "chr$(",0
6535+ 3EB8 28 00
6536+ 3EBA 31 33 00     CHKEY4: defb    "13",0
6537+ 3EBD 33 34 00     CHKEY5: defb    "34",0
6538+ 3EC0
6539+ 3EC0
6540+ 3EC0              ; LOAD "filename"
6541+ 3EC0              ; load a BASIC program from disk
6542+ 3EC0 C9           LOAD:   ret                     ; currently a stub for LOAD
6543+ 3EC1
6544+ 3EC1
6545+ 3EC1              ; SAVE "filename"
6546+ 3EC1              ; save a BASIC program on disk
6547+ 3EC1 C9           SAVE:   ret                     ; currently a stub for SAVE
6548+ 3EC2
6549+ 3EC2
6550+ 3EC2              ; FILES
6551+ 3EC2              ; list files on disk
6552+ 3EC2 C9           FILES:  ret                     ; currently a stub for FILES
6553+ 3EC3
6554+ 3EC3
6555+ 3EC3              ; ERASE "filename"
6556+ 3EC3              ; erase a file from disk
6557+ 3EC3 C9           ERASE:  ret                     ; currently a stub for ERASE
6558+ 3EC4
6559+ 3EC4
6560+ 3EC4              ; HEX$(nn) Convert 16 bit number to Hexadecimal string
6561+ 3EC4 CD A0 20     HEX: 	call	TSTNUM          ; Verify it's a number
6562+ 3EC7 CD C2 1C             call	DEINT           ; Get integer -32768 to 32767
6563+ 3ECA C5                   push	BC              ; Save contents of BC
6564+ 3ECB 21 7B 53             ld      HL,PBUFF        ; load address of PBUFF into HL
6565+ 3ECE 7A                   ld      A,D             ; Get MSB into A
6566+ 3ECF B7                   or      A               ; OR with LSB to see if param=0
6567+ 3ED0 28 0C                jr      Z,HEX2          ; Skip output if both high digits are zero
6568+ 3ED2 CD FA 3E             call    BYT2ASC         ; Convert D to ASCII
6569+ 3ED5 78                   ld      A,B             ; cechk if B
6570+ 3ED6 FE 30                cp      '0'             ; is 0
6571+ 3ED8 28 02                jr      Z,HEX1          ; Don't store high digit if zero
6572+ 3EDA 70                   ld      (HL),B          ; Store it to PBUFF
6573+ 3EDB 23                   inc     HL              ; Next location
6574+ 3EDC 71           HEX1:   ld      (HL),C          ; Store C to PBUFF+1
6575+ 3EDD 23                   inc     HL              ; Next location
6576+ 3EDE 7B           HEX2:   ld      A,E             ; Get lower byte
6577+ 3EDF CD FA 3E             call    BYT2ASC         ; Convert E to ASCII
6578+ 3EE2 7A                   ld      A,D
6579+ 3EE3 B7                   or      A
6580+ 3EE4 20 05                jr      NZ,HEX3         ; If upper byte was not zero then always print lower byte
6581+ 3EE6 78                   ld      A,B
6582+ 3EE7 FE 30                cp      '0'             ; If high digit of lower byte is zero then don't print
6583+ 3EE9 28 02                jr      Z,HEX4
6584+ 3EEB 70           HEX3:   ld      (HL),B          ; to PBUFF+2
6585+ 3EEC 23                   inc     HL              ; Next location
6586+ 3EED 71           HEX4:   ld      (HL),C          ; to PBUFF+3
6587+ 3EEE 23                   inc     HL              ; PBUFF+4 to zero
6588+ 3EEF AF                   xor     A               ; Terminating character
6589+ 3EF0 77                   ld      (HL),A          ; Store zero to terminate
6590+ 3EF1 23                   inc     HL              ; Make sure PBUFF is terminated
6591+ 3EF2 77                   ld      (HL),A          ; Store the double zero there
6592+ 3EF3 C1                   pop     BC              ; Get BC back
6593+ 3EF4 21 7B 53             ld      HL,PBUFF        ; Reset to start of PBUFF
6594+ 3EF7 C3 35 25             jp      STR1            ; Convert the PBUFF to a string and return it
6595+ 3EFA 47           BYT2ASC:ld      B,A             ; Save original value
6596+ 3EFB E6 0F                and     $0F             ; Strip off upper nybble
6597+ 3EFD FE 0A                cp      $0A             ; 0-9?
6598+ 3EFF 38 02                jr      C,ADD30         ; If A-F, add 7 more
6599+ 3F01 C6 07                add     A,$07           ; Bring value up to ASCII A-F
6600+ 3F03 C6 30        ADD30:  add     A,$30           ; And make ASCII
6601+ 3F05 4F                   ld      C,A             ; Save converted char to C
6602+ 3F06 78                   ld      A,B             ; Retrieve original value
6603+ 3F07 0F                   rrca                    ; and Rotate it right
6604+ 3F08 0F                   rrca
6605+ 3F09 0F                   rrca
6606+ 3F0A 0F                   rrca
6607+ 3F0B E6 0F                and     $0F             ; Mask off upper nybble
6608+ 3F0D FE 0A                cp      $0A             ; 0-9? < A hex?
6609+ 3F0F 38 02                jr      C,ADD301        ; Skip Add 7
6610+ 3F11 C6 07                add     A,$07           ; Bring it up to ASCII A-F
6611+ 3F13 C6 30        ADD301: add     A,$30           ; And make it full ASCII
6612+ 3F15 47                   ld      B,A             ; Store high order byte
6613+ 3F16 C9                   ret
6614+ 3F17
6615+ 3F17              ; Convert "&Hnnnn" to FPREG
6616+ 3F17              ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
6617+ 3F17              ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
6618+ 3F17 EB           HEXTFP: ex      DE,HL           ; Move code string pointer to DE
6619+ 3F18 21 00 00             ld      HL,$0000        ; Zero out the value
6620+ 3F1B CD 30 3F             call    GETHEX          ; Check the number for valid hex
6621+ 3F1E DA 50 3F             jp      C,HXERR         ; First value wasn't hex, HX error
6622+ 3F21 18 05                jr      HEXLP1          ; Convert first character
6623+ 3F23 CD 30 3F     HEXLP:  call    GETHEX          ; Get second and addtional characters
6624+ 3F26 38 1F                jr      C,HEXIT         ; Exit if not a hex character
6625+ 3F28 29           HEXLP1: add     HL,HL           ; Rotate 4 bits to the left
6626+ 3F29 29                   add     HL,HL
6627+ 3F2A 29                   add     HL,HL
6628+ 3F2B 29                   add     HL,HL
6629+ 3F2C B5                   or      L               ; Add in D0-D3 into L
6630+ 3F2D 6F                   ld      L,A             ; Save new value
6631+ 3F2E 18 F3                jr      HEXLP           ; And continue until all hex characters are in
6632+ 3F30
6633+ 3F30 13           GETHEX: inc     DE              ; Next location
6634+ 3F31 1A                   ld      A,(DE)          ; Load character at pointer
6635+ 3F32 FE 20                cp      SPC
6636+ 3F34 CA 30 3F             jp      Z,GETHEX        ; Skip spaces
6637+ 3F37 D6 30                sub     $30             ; Get absolute value
6638+ 3F39 D8                   ret     C               ; < "0", error
6639+ 3F3A FE 0A                cp      $0A
6640+ 3F3C 38 05                jr      C,NOSUB7        ; Is already in the range 0-9
6641+ 3F3E D6 07                sub     $07             ; Reduce to A-F
6642+ 3F40 FE 0A                cp      $0A             ; Value should be $0A-$0F at this point
6643+ 3F42 D8                   ret     C               ; CY set if was :            ; < = > ? @
6644+ 3F43 FE 10        NOSUB7: cp      $10             ; > Greater than "F"?
6645+ 3F45 3F                   ccf
6646+ 3F46 C9                   ret                     ; CY set if it wasn't valid hex
6647+ 3F47
6648+ 3F47 EB           HEXIT:  ex      DE,HL           ; Value into DE, Code string into HL
6649+ 3F48 7A                   ld      A,D             ; Load DE into AC
6650+ 3F49 4B                   ld      C,E             ; For prep to
6651+ 3F4A E5                   push    HL
6652+ 3F4B CD 86 24             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6653+ 3F4E E1                   pop     HL
6654+ 3F4F C9                   ret
6655+ 3F50
6656+ 3F50 DD 5C        HXERR:  ld      E,HX            ; ?HEX Error
6657+ 3F52 C3 DD 16             jp      ERROR
6658+ 3F55
6659+ 3F55              ; BIN$(NN) Convert integer to a 1-16 char binary string
6660+ 3F55 CD A0 20     BIN:    call    TSTNUM          ; Verify it's a number
6661+ 3F58 CD C2 1C             call    DEINT           ; Get integer -32768 to 32767
6662+ 3F5B C5           BIN2:   push    BC              ; Save contents of BC
6663+ 3F5C 21 7B 53             ld      HL,PBUFF
6664+ 3F5F 06 11                ld      B,$11           ; One higher than max char count (16+1)
6665+ 3F61              ZEROSUP:                        ; Suppress leading zeros
6666+ 3F61 05                   dec     B               ; Max 16 chars
6667+ 3F62 78                   ld      A,B
6668+ 3F63 FE 01                cp      $01
6669+ 3F65 28 08                jr      Z,BITOUT        ; Always output at least one character
6670+ 3F67 CB 13                rl      E
6671+ 3F69 CB 12                rl      D
6672+ 3F6B 30 F4                jr      NC,ZEROSUP
6673+ 3F6D 18 04                jr      BITOUT2
6674+ 3F6F CB 13        BITOUT: rl      E
6675+ 3F71 CB 12                rl      D               ; Top bit now in carry
6676+ 3F73 3E 30        BITOUT2:ld      A,'0'           ; Char for '0'
6677+ 3F75 CE 00                adc     A,$00           ; If carry set then '0' --> '1'
6678+ 3F77 77                   ld      (HL),A
6679+ 3F78 23                   inc     HL
6680+ 3F79 05                   dec     B
6681+ 3F7A 20 F3                jr      NZ,BITOUT
6682+ 3F7C AF                   xor     A               ; Terminating character
6683+ 3F7D 77                   ld      (HL),A          ; Store zero to terminate
6684+ 3F7E 23                   inc     HL              ; Make sure PBUFF is terminated
6685+ 3F7F 77                   ld      (HL),A          ; Store the double zero there
6686+ 3F80 C1                   pop     BC
6687+ 3F81 21 7B 53             ld      HL,PBUFF
6688+ 3F84 C3 35 25             jp      STR1
6689+ 3F87
6690+ 3F87              ; Convert "&Bnnnn" to FPREG
6691+ 3F87              ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
6692+ 3F87 EB           BINTFP: ex      DE,HL           ; Move code string pointer to DE
6693+ 3F88 21 00 00             ld      HL,$0000        ; Zero out the value
6694+ 3F8B CD A4 3F             call    CHKBIN          ; Check the number for valid bin
6695+ 3F8E DA B2 3F             jp      C,BINERR        ; First value wasn't bin, HX error
6696+ 3F91 D6 30        BINIT:  sub     '0'
6697+ 3F93 29                   add     HL,HL           ; Rotate HL left
6698+ 3F94 B5                   or      L
6699+ 3F95 6F                   ld      L,A
6700+ 3F96 CD A4 3F             call    CHKBIN          ; Get second and addtional characters
6701+ 3F99 30 F6                jr      NC,BINIT        ; Process if a bin character
6702+ 3F9B EB                   ex      DE,HL           ; Value into DE, Code string into HL
6703+ 3F9C 7A                   ld      A,D             ; Load DE into AC
6704+ 3F9D 4B                   ld      C,E             ; For prep to
6705+ 3F9E E5                   push    HL
6706+ 3F9F CD 86 24             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6707+ 3FA2 E1                   pop     HL
6708+ 3FA3 C9                   ret
6709+ 3FA4
6710+ 3FA4              ; Char is in A, NC if char is 0 or 1
6711+ 3FA4 13           CHKBIN: inc     DE
6712+ 3FA5 1A                   ld      A,(DE)
6713+ 3FA6 FE 20                cp      SPC
6714+ 3FA8 CA A4 3F             jp      Z,CHKBIN        ; Skip spaces
6715+ 3FAB FE 30                cp      '0'             ; Set C if < '0'
6716+ 3FAD D8                   ret     C
6717+ 3FAE FE 32                cp      '2'
6718+ 3FB0 3F                   ccf                     ; Set C if > '1'
6719+ 3FB1 C9                   ret
6720+ 3FB2
6721+ 3FB2 1E 28        BINERR: ld      E,BN            ; ?BIN Error
6722+ 3FB4 C3 DD 16             jp      ERROR
6723+ 3FB7
6724+ 3FB7
6725+ 3FB7 C3 08 00     MONOUT: jp      $0008           ; output a char
6726+ 3FBA
6727+ 3FBA
6728+ 3FBA 3A 64 53     RESET:  ld      A,(SERIALS_EN)
6729+ 3FBD E6 11                and     $11             ; are serial ports open?
6730+ 3FBF C4 2A 3B             call    NZ,RSTSERS      ; yes, reset serials
6731+ 3FC2 CD 3E 29             call    DISNMI          ; disable NMI vector
6732+ 3FC5 F3                   di                      ; disable INTs
6733+ 3FC6                  IFDEF LM80C64K
6734+ 3FC6 C3 16 51             jp      ROM2RAM         ; Restart
6735+ 3FC9                  ELSE
6736+ 3FC9 ~                    jp      $0000           ; Restart
6737+ 3FC9                  ENDIF
6738+ 3FC9
6739+ 3FC9
6740+ 3FC9 3E 00        INITST: ld      A,$00           ; Clear break flag
6741+ 3FCB 32 EE 51             ld      (BRKFLG),A
6742+ 3FCE C3 F5 11             jp      INIT
6743+ 3FD1
6744+ 3FD1
6745+ 3FD1 F5           TSTBIT: push    AF              ; Save bit mask
6746+ 3FD2 A0                   and     B               ; Get common bits
6747+ 3FD3 C1                   pop     BC              ; Restore bit mask
6748+ 3FD4 B8                   cp      B               ; Same bit set?
6749+ 3FD5 3E 00                ld      A,$00           ; Return 0 in A
6750+ 3FD7 C9                   ret
6751+ 3FD8
6752+ 3FD8 CD CE 19     OUTNCR: call    OUTC            ; Output character in A
6753+ 3FDB C3 D9 1E             jp      PRNTCRLF        ; Output CRLF
6754+ 3FDE
# file closed: ../include/basic/basic-1.04.asm
  80  3FDE
  81  3FDE              ; include utils
  82  3FDE                  INCLUDE "../include/utils/utils-r11.asm"
# file opened: ../include/utils/utils-r11.asm
   1+ 3FDE              ; ------------------------------------------------------------------------------
   2+ 3FDE              ; LM80C - UTILITY ROUTINES - R1.1
   3+ 3FDE              ; ------------------------------------------------------------------------------
   4+ 3FDE              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 3FDE              ; designed by Leonardo Miliani. More info at
   6+ 3FDE              ; www DOT leonardomiliani DOT com
   7+ 3FDE              ;
   8+ 3FDE              ; *ALS are routines from "Z80 Assembly Language Subroutines" by Lance
   9+ 3FDE              ; A. Leventhal and Winthrop Saville - Ed. Osborne/McGraw-Hill (1983)
  10+ 3FDE              ;
  11+ 3FDE              ; * WKT are routines from WikiTI:
  12+ 3FDE              ; http://wikiti.brandonw.net/index.php?title=WikiTI_Home
  13+ 3FDE              ;
  14+ 3FDE              ; * LAC are routines from Learn@Cemetch
  15+ 3FDE              ; https://learn.cemetech.net/index.php/Main_Page
  16+ 3FDE              ;
  17+ 3FDE              ; ------------------------------------------------------------------------------
  18+ 3FDE              ; Code Revision:
  19+ 3FDE              ; R1.0 - 20200110 - First release: 16-bit comparision/multiplication/negation
  20+ 3FDE              ; R1.1 - 20200413 - Second release: added ABS(HL)
  21+ 3FDE              ;
  22+ 3FDE              ; ------------------------------------------------------------------------------
  23+ 3FDE
  24+ 3FDE              ; compare two 16-bit registers, HL (minuend) and DE (subtrahend)
  25+ 3FDE              ; values can be both signed or unsigned words
  26+ 3FDE              ; inputs: HL, DE
  27+ 3FDE              ; destroys: A,F,HL
  28+ 3FDE              ;
  29+ 3FDE              ; returns: Z=1 if HL = DE
  30+ 3FDE              ; for UNSIGNED: C=1 if HL<DE  //  C=0 if HL>DE
  31+ 3FDE              ; for SIGNED:   S=1 (M) if HL<DE  //  S=0 (P) if HL>DE
  32+ 3FDE              ; if HL=DE: Z,P,NC  - Z=1, S=0; C=0
  33+ 3FDE              ; if HL>DE: NZ,P,NC - Z=0, S=0; C=0
  34+ 3FDE              ; if HL<DE: NZ,M,C  - Z=0, S=1; C=1
  35+ 3FDE              ; Source: ALS
  36+ 3FDE
  37+ 3FDE B7           CMP16:  or      A           ; clear CARRY
  38+ 3FDF ED 52                sbc     HL,DE       ; subtract DE from HL
  39+ 3FE1 E0                   ret     PO          ; return if no overflow
  40+ 3FE2 7C                   ld      A,H         ; overflow - invert SIGN flag
  41+ 3FE3 1F                   rra                 ; save CARRY flag in bit 7
  42+ 3FE4 EE 40                xor     %01000000   ; complement bit 6 (SIGN bit)
  43+ 3FE6 37                   scf                 ; ensure a Non-Zero result
  44+ 3FE7 8F                   adc     A,A         ; restore CARRY, complemented SIGN
  45+ 3FE8                                          ; ZERO flag = 0 for sure
  46+ 3FE8 C9                   ret                 ; return
  47+ 3FE9
  48+ 3FE9              ; ----------------------------------------------------------------------
  49+ 3FE9
  50+ 3FE9              ; multiply 2 signed/unsigned 16-bit words and return a 16-bit
  51+ 3FE9              ; signed/unsigned product
  52+ 3FE9              ; inputs: HL (multiplicand); DE (multiplier)
  53+ 3FE9              ; destroys: A,F
  54+ 3FE9              ; returns: HL (product)
  55+ 3FE9              ; Source: ALS
  56+ 3FE9
  57+ 3FE9              ; initialize partial product, bit count
  58+ 3FE9 C5           MUL16:  push    BC
  59+ 3FEA 4D                   ld      C,L         ; BC = multiplier
  60+ 3FEB 44                   ld      B,H
  61+ 3FEC 21 00 00             ld      HL,0        ; product = 0
  62+ 3FEF 3E 0F                ld      A,$0F       ; count = bit lenght - 1 (16-1)
  63+ 3FF1                      ; shift-and-add algorithm
  64+ 3FF1                      ; if MSB of multiplier is 1, add multiplicand to partial product
  65+ 3FF1                      ; shift partial product, multiplier left 1 bit
  66+ 3FF1 CB 23        MLP:    sla     E           ; shift multiplier left 1 bit
  67+ 3FF3 CB 12                rl      D
  68+ 3FF5 30 01                jr      NC,MLP1     ; jump if MSB of multiplier = 0
  69+ 3FF7 09                   add     HL,BC       ; add multiplicand to partial product
  70+ 3FF8 29           MLP1:   add     HL,HL       ; shift partial product left
  71+ 3FF9 3D                   dec     A
  72+ 3FFA 20 F5                jr      NZ,MLP      ; continue until count = 0
  73+ 3FFC                      ; add multiplicand one last time if MSB of multiplier is 1
  74+ 3FFC B2                   or      D           ; sign flag = MSB of multiplier
  75+ 3FFD F2 01 40             jp      P,EXMUL16   ; exit if MSB of multiplier is 0
  76+ 4000 09                   add     HL,BC       ; add multiplicand to product
  77+ 4001 C1           EXMUL16:pop     BC
  78+ 4002 C9                   ret
  79+ 4003
  80+ 4003              ; ----------------------------------------------------------------------
  81+ 4003              ; absolute value of HL (same applies to other 16-bit register pairs)
  82+ 4003              ; also, invert value of HL (or any other 16-bit register, just adjust the code)
  83+ 4003              ;
  84+ 4003              ; inputs: HL
  85+ 4003              ; destroys: A
  86+ 4003              ; operation: ABS(HL)
  87+ 4003              ; returns: HL with no sign or negated
  88+ 4003              ; Source: WKT
  89+ 4003
  90+ 4003 CB 7C        absHL:  bit     7,H
  91+ 4005 C8                   ret     Z
  92+ 4006 AF           negHL:  xor     A
  93+ 4007 95                   sub     L
  94+ 4008 6F                   ld      L,A
  95+ 4009 9F                   sbc     A,A
  96+ 400A 94                   sub     H
  97+ 400B 67                   ld      H,A
  98+ 400C C9                   ret
  99+ 400D
 100+ 400D              ; ------------------------------------------------------------------------------
 101+ 400D
 102+ 400D              ; 8/8 division
 103+ 400D              ; INPUT: D (dividend), E (divisor)
 104+ 400D              ; OPERATION: D/E
 105+ 400D              ; OUTPUT: D (quotient), A (remainder)
 106+ 400D AF           DIV_8_8:    xor     A
 107+ 400E C5                       push    BC
 108+ 400F 06 08                    ld      B,08h
 109+ 4011 CB 22        DIV_8_8LOOP:sla     D
 110+ 4013 17                       rla
 111+ 4014 BB                       cp      E
 112+ 4015 38 02                    jr      C,$+4
 113+ 4017 93                       sub     E
 114+ 4018 14                       inc     D
 115+ 4019 10 F6                    djnz    DIV_8_8LOOP
 116+ 401B C1                       pop     BC
 117+ 401C C9                       ret
 118+ 401D
 119+ 401D              ; ----------------------------------------------------------------------
 120+ 401D              ; divide a 16-bit number by an 8-bit number
 121+ 401D              ; (16/8 division)
 122+ 401D              ;
 123+ 401D              ; inputs: HL (Dividend), C (divisor)
 124+ 401D              ; destroys: A
 125+ 401D              ; OPERATION: HL/C
 126+ 401D              ; returns: HL (quotient), A (remainder)
 127+ 401D              ; source: WKT
 128+ 401D
 129+ 401D AF           DIV_16_8:   xor     A
 130+ 401E 06 10                    ld      B,16
 131+ 4020 29           DIV_16_8LP: add     HL,HL
 132+ 4021 17                       rla
 133+ 4022 38 03                    jr      C,$+5
 134+ 4024 B9                       cp      C
 135+ 4025 38 02                    jr      C,$+4
 136+ 4027 91                       sub     C
 137+ 4028 2C                       inc     L
 138+ 4029 10 F5                    djnz    DIV_16_8LP
 139+ 402B C9                       ret
 140+ 402C
 141+ 402C              ; ----------------------------------------------------------------------
 142+ 402C              ; divide a 16-bit number by a 16-bit number
 143+ 402C              ; (16/16 division)
 144+ 402C              ;
 145+ 402C              ; inputs: AC (Dividend), DE (divisor)
 146+ 402C              ; destroys: HL,A,C
 147+ 402C              ; OPERATION: AC/DE
 148+ 402C              ; returns: AC (quotient), HL (remainder)
 149+ 402C              ; source: WKT
 150+ 402C 21 00 00     DIV_16_16:  ld      HL, 0
 151+ 402F 06 10                    ld      B, 16
 152+ 4031 CB 21        DV16_16_LP: sla     C
 153+ 4033 CB C1                    set     0,C         ; this simulates the SLL undocumented instruction
 154+ 4035 17                       rla
 155+ 4036 ED 6A                    adc     HL,HL
 156+ 4038 ED 52                    sbc     HL,DE
 157+ 403A 30 02                    jr      NC, $+4
 158+ 403C 19                       add     HL,DE
 159+ 403D 0D                       dec     C
 160+ 403E 10 F1                    djnz    DV16_16_LP
 161+ 4040 C9                       ret
# file closed: ../include/utils/utils-r11.asm
  83  4041
  84  4041              ; include the latest version of the font sets
  85  4041                  INCLUDE "../include/vdp/6x8fonts-r16.asm"
# file opened: ../include/vdp/6x8fonts-r16.asm
   1+ 4041              ; ------------------------------------------------------------------------------
   2+ 4041              ; LM80C - 6x8 CHARSET - R1.6
   3+ 4041              ; ------------------------------------------------------------------------------
   4+ 4041              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4041              ; designed by Leonardo Miliani. More info at
   6+ 4041              ; www DOT leonardomiliani DOT com
   7+ 4041              ; ------------------------------------------------------------------------------
   8+ 4041              ; Code Revision:
   9+ 4041              ; R1.0 - 20190511 - First revision: ASCII chars (from 0 to 127)
  10+ 4041              ; R1.1 - 20190521 - Expanded to 255 chars
  11+ 4041              ; R1.2 - 20191209 - Start adding graphic chars to be coherent with 8x8 fonts
  12+ 4041              ; R1.3 - 20191226 - Added extended char codes (128-255)
  13+ 4041              ; R1.4 - 20200228 - adopted more usual hexadecimal & binary prefixes
  14+ 4041              ; R1.5 - 20200524 - New style for char #252
  15+ 4041              ; R1.6 - 20200704 - Redefined chars 105, 106, and 252
  16+ 4041              ; ------------------------------------------------------------------------------
  17+ 4041              ;
  18+ 4041              ;-------------------------------------------------------------------------------
  19+ 4041              ;
  20+ 4041              ;               6 x 8    C  H  A  R  S  E  T
  21+ 4041              ;
  22+ 4041              ;-------------------------------------------------------------------------------
  23+ 4041              ;
  24+ 4041              ;       6X8 CHARS, DESIGNED FOR TEXT BUT USABLE IN GRAPHICS 1 MODE TOO
  25+ 4041              ;       UPDATE: NOW GRAPHICS 1 MODE HAS ITS OWN CHAR SET
  26+ 4041
  27+ 4041              CHRST68 equ $
  28+ 4041 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  28+ 4045 00 00 00 00
  29+ 4049 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  29+ 404D 00 00 00 00
  30+ 4051 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  30+ 4055 00 00 00 00
  31+ 4059 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  31+ 405D 00 00 00 00
  32+ 4061 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  32+ 4065 00 00 00 00
  33+ 4069 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  33+ 406D 00 00 00 00
  34+ 4071 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  34+ 4075 00 00 00 00
  35+ 4079 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  35+ 407D 00 00 00 00
  36+ 4081 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
  36+ 4085 00 00 00 00
  37+ 4089 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  37+ 408D 00 00 00 00
  38+ 4091 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  38+ 4095 00 00 00 00
  39+ 4099 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11
  39+ 409D 00 00 00 00
  40+ 40A1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  40+ 40A5 00 00 00 00
  41+ 40A9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
  41+ 40AD 00 00 00 00
  42+ 40B1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
  42+ 40B5 00 00 00 00
  43+ 40B9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  43+ 40BD 00 00 00 00
  44+ 40C1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  44+ 40C5 00 00 00 00
  45+ 40C9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  45+ 40CD 00 00 00 00
  46+ 40D1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  46+ 40D5 00 00 00 00
  47+ 40D9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  47+ 40DD 00 00 00 00
  48+ 40E1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
  48+ 40E5 00 00 00 00
  49+ 40E9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  49+ 40ED 00 00 00 00
  50+ 40F1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
  50+ 40F5 00 00 00 00
  51+ 40F9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
  51+ 40FD 00 00 00 00
  52+ 4101 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
  52+ 4105 00 00 00 00
  53+ 4109 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
  53+ 410D 00 00 00 00
  54+ 4111 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
  54+ 4115 00 00 00 00
  55+ 4119 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
  55+ 411D 00 00 00 00
  56+ 4121 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
  56+ 4125 00 00 00 00
  57+ 4129 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
  57+ 412D 00 00 00 00
  58+ 4131 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
  58+ 4135 00 00 00 00
  59+ 4139 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
  59+ 413D 00 00 00 00
  60+ 4141 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32: space
  60+ 4145 00 00 00 00
  61+ 4149 20 20 20 20          defb $20,$20,$20,$20,$20,$00,$20,$00 ; char 33: !
  61+ 414D 20 00 20 00
  62+ 4151 50 50 00 00          defb $50,$50,$00,$00,$00,$00,$00,$00 ; char 34: "
  62+ 4155 00 00 00 00
  63+ 4159 50 50 F8 50          defb $50,$50,$f8,$50,$f8,$50,$50,$00 ; char 35: #
  63+ 415D F8 50 50 00
  64+ 4161 20 78 A0 70          defb $20,$78,$a0,$70,$28,$f0,$20,$00 ; char 36: $
  64+ 4165 28 F0 20 00
  65+ 4169 C0 C8 10 20          defb $c0,$c8,$10,$20,$40,$98,$18,$00 ; char 37: %
  65+ 416D 40 98 18 00
  66+ 4171 60 90 A0 40          defb $60,$90,$a0,$40,$a8,$90,$68,$00 ; char 38: &
  66+ 4175 A8 90 68 00
  67+ 4179 60 20 40 00          defb $60,$20,$40,$00,$00,$00,$00,$00 ; char 39: '
  67+ 417D 00 00 00 00
  68+ 4181 10 20 40 40          defb $10,$20,$40,$40,$40,$20,$10,$00 ; char 40: (
  68+ 4185 40 20 10 00
  69+ 4189 40 20 10 10          defb $40,$20,$10,$10,$10,$20,$40,$00 ; char 41: )
  69+ 418D 10 20 40 00
  70+ 4191 00 20 A8 70          defb $00,$20,$a8,$70,$a8,$20,$00,$00 ; char 42: *
  70+ 4195 A8 20 00 00
  71+ 4199 00 20 20 F8          defb $00,$20,$20,$f8,$20,$20,$00,$00 ; char 43: +
  71+ 419D 20 20 00 00
  72+ 41A1 00 00 00 00          defb $00,$00,$00,$00,$60,$20,$40,$00 ; char 44: ,
  72+ 41A5 60 20 40 00
  73+ 41A9 00 00 00 F8          defb $00,$00,$00,$f8,$00,$00,$00,$00 ; char 45: -
  73+ 41AD 00 00 00 00
  74+ 41B1 00 00 00 00          defb $00,$00,$00,$00,$00,$60,$60,$00 ; char 46: .
  74+ 41B5 00 60 60 00
  75+ 41B9 00 08 10 20          defb $00,$08,$10,$20,$40,$80,$00,$00 ; char 47: /
  75+ 41BD 40 80 00 00
  76+ 41C1 70 88 98 A8          defb $70,$88,$98,$a8,$c8,$88,$70,$00 ; char 48: 0
  76+ 41C5 C8 88 70 00
  77+ 41C9 20 60 20 20          defb $20,$60,$20,$20,$20,$20,$70,$00 ; char 49: 1
  77+ 41CD 20 20 70 00
  78+ 41D1 70 88 08 10          defb $70,$88,$08,$10,$20,$40,$f8,$00 ; char 50: 2
  78+ 41D5 20 40 F8 00
  79+ 41D9 F8 10 20 10          defb $f8,$10,$20,$10,$08,$88,$70,$00 ; char 51: 3
  79+ 41DD 08 88 70 00
  80+ 41E1 10 30 50 90          defb $10,$30,$50,$90,$f8,$10,$10,$00 ; char 52: 4
  80+ 41E5 F8 10 10 00
  81+ 41E9 F8 80 F0 08          defb $f8,$80,$f0,$08,$08,$88,$70,$00 ; char 53: 5
  81+ 41ED 08 88 70 00
  82+ 41F1 30 40 80 F0          defb $30,$40,$80,$f0,$88,$88,$70,$00 ; char 54: 6
  82+ 41F5 88 88 70 00
  83+ 41F9 F8 08 10 20          defb $f8,$08,$10,$20,$40,$40,$40,$00 ; char 55: 7
  83+ 41FD 40 40 40 00
  84+ 4201 70 88 88 70          defb $70,$88,$88,$70,$88,$88,$70,$00 ; char 56: 8
  84+ 4205 88 88 70 00
  85+ 4209 70 88 88 78          defb $70,$88,$88,$78,$08,$10,$60,$00 ; char 57: 9
  85+ 420D 08 10 60 00
  86+ 4211 00 30 30 00          defb $00,$30,$30,$00,$30,$30,$00,$00 ; char 58: :
  86+ 4215 30 30 00 00
  87+ 4219 00 30 30 00          defb $00,$30,$30,$00,$30,$10,$20,$00 ; char 59: ;
  87+ 421D 30 10 20 00
  88+ 4221 10 20 40 80          defb $10,$20,$40,$80,$40,$20,$10,$00 ; char 60: <
  88+ 4225 40 20 10 00
  89+ 4229 00 00 F8 00          defb $00,$00,$f8,$00,$f8,$00,$00,$00 ; char 61: =
  89+ 422D F8 00 00 00
  90+ 4231 40 20 10 08          defb $40,$20,$10,$08,$10,$20,$40,$00 ; char 62: >
  90+ 4235 10 20 40 00
  91+ 4239 70 88 08 10          defb $70,$88,$08,$10,$20,$00,$20,$00 ; char 63: ?
  91+ 423D 20 00 20 00
  92+ 4241 70 88 08 68          defb $70,$88,$08,$68,$a8,$a8,$70,$00 ; char 64: @
  92+ 4245 A8 A8 70 00
  93+ 4249 70 88 88 88          defb $70,$88,$88,$88,$f8,$88,$88,$00 ; char 65: A
  93+ 424D F8 88 88 00
  94+ 4251 F0 88 88 F0          defb $f0,$88,$88,$f0,$88,$88,$f0,$00 ; char 66: B
  94+ 4255 88 88 F0 00
  95+ 4259 70 88 80 80          defb $70,$88,$80,$80,$80,$88,$70,$00 ; char 67: C
  95+ 425D 80 88 70 00
  96+ 4261 E0 90 88 88          defb $e0,$90,$88,$88,$88,$90,$e0,$00 ; char 68: D
  96+ 4265 88 90 E0 00
  97+ 4269 F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$f8,$00 ; char 69: E
  97+ 426D 80 80 F8 00
  98+ 4271 F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$80,$00 ; char 70: F
  98+ 4275 80 80 80 00
  99+ 4279 70 88 80 B8          defb $70,$88,$80,$b8,$88,$88,$78,$00 ; char 71: G
  99+ 427D 88 88 78 00
 100+ 4281 88 88 88 F8          defb $88,$88,$88,$f8,$88,$88,$88,$00 ; char 72: H
 100+ 4285 88 88 88 00
 101+ 4289 70 20 20 20          defb $70,$20,$20,$20,$20,$20,$70,$00 ; char 73: I
 101+ 428D 20 20 70 00
 102+ 4291 38 10 10 10          defb $38,$10,$10,$10,$10,$90,$60,$00 ; char 74: J
 102+ 4295 10 90 60 00
 103+ 4299 88 90 A0 C0          defb $88,$90,$a0,$c0,$a0,$90,$88,$00 ; char 75: K
 103+ 429D A0 90 88 00
 104+ 42A1 80 80 80 80          defb $80,$80,$80,$80,$80,$80,$f8,$00 ; char 76: L
 104+ 42A5 80 80 F8 00
 105+ 42A9 88 D8 A8 A8          defb $88,$d8,$a8,$a8,$88,$88,$88,$00 ; char 77: M
 105+ 42AD 88 88 88 00
 106+ 42B1 88 C8 A8 98          defb $88,$c8,$a8,$98,$88,$88,$88,$00 ; char 78: N
 106+ 42B5 88 88 88 00
 107+ 42B9 70 88 88 88          defb $70,$88,$88,$88,$88,$88,$70,$00 ; char 79: O
 107+ 42BD 88 88 70 00
 108+ 42C1 F0 88 88 F0          defb $f0,$88,$88,$f0,$80,$80,$80,$00 ; char 80: P
 108+ 42C5 80 80 80 00
 109+ 42C9 70 88 88 88          defb $70,$88,$88,$88,$a8,$90,$68,$00 ; char 81: Q
 109+ 42CD A8 90 68 00
 110+ 42D1 F0 88 88 F0          defb $f0,$88,$88,$f0,$a0,$90,$88,$00 ; char 82: R
 110+ 42D5 A0 90 88 00
 111+ 42D9 78 80 80 70          defb $78,$80,$80,$70,$08,$08,$f0,$00 ; char 83: S
 111+ 42DD 08 08 F0 00
 112+ 42E1 F8 20 20 20          defb $f8,$20,$20,$20,$20,$20,$20,$00 ; char 84: T
 112+ 42E5 20 20 20 00
 113+ 42E9 88 88 88 88          defb $88,$88,$88,$88,$88,$88,$70,$00 ; char 85: U
 113+ 42ED 88 88 70 00
 114+ 42F1 88 88 88 88          defb $88,$88,$88,$88,$88,$50,$20,$00 ; char 86: V
 114+ 42F5 88 50 20 00
 115+ 42F9 88 88 88 88          defb $88,$88,$88,$88,$a8,$a8,$50,$00 ; char 87: W
 115+ 42FD A8 A8 50 00
 116+ 4301 88 88 50 20          defb $88,$88,$50,$20,$50,$88,$88,$00 ; char 88: X
 116+ 4305 50 88 88 00
 117+ 4309 88 88 88 50          defb $88,$88,$88,$50,$20,$20,$20,$00 ; char 89: Y
 117+ 430D 20 20 20 00
 118+ 4311 F8 08 10 20          defb $f8,$08,$10,$20,$40,$80,$f8,$00 ; char 90: Z
 118+ 4315 40 80 F8 00
 119+ 4319 70 40 40 40          defb $70,$40,$40,$40,$40,$40,$70,$00 ; char 91: [
 119+ 431D 40 40 70 00
 120+ 4321 00 80 40 20          defb $00,$80,$40,$20,$10,$08,$00,$00 ; char 92: \
 120+ 4325 10 08 00 00
 121+ 4329 70 10 10 10          defb $70,$10,$10,$10,$10,$10,$70,$00 ; char 93: ]
 121+ 432D 10 10 70 00
 122+ 4331 20 50 88 00          defb $20,$50,$88,$00,$00,$00,$00,$00 ; char 94: ^
 122+ 4335 00 00 00 00
 123+ 4339 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$FC ; char 95: _ (underscore)
 123+ 433D 00 00 00 FC
 124+ 4341 40 20 10 00          defb $40,$20,$10,$00,$00,$00,$00,$00 ; char 96: `
 124+ 4345 00 00 00 00
 125+ 4349 00 00 70 08          defb $00,$00,$70,$08,$78,$88,$78,$00 ; char 97: a
 125+ 434D 78 88 78 00
 126+ 4351 80 80 80 B0          defb $80,$80,$80,$b0,$c8,$88,$f0,$00 ; char 98: b
 126+ 4355 C8 88 F0 00
 127+ 4359 00 00 70 80          defb $00,$00,$70,$80,$80,$88,$70,$00 ; char 99: c
 127+ 435D 80 88 70 00
 128+ 4361 08 08 08 68          defb $08,$08,$08,$68,$98,$88,$78,$00 ; char 100: d
 128+ 4365 98 88 78 00
 129+ 4369 00 00 70 88          defb $00,$00,$70,$88,$f8,$80,$70,$00 ; char 101: e
 129+ 436D F8 80 70 00
 130+ 4371 30 48 40 E0          defb $30,$48,$40,$e0,$40,$40,$40,$00 ; char 102: f
 130+ 4375 40 40 40 00
 131+ 4379 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$70,$00 ; char 103: g
 131+ 437D 78 08 70 00
 132+ 4381 80 80 B0 C8          defb $80,$80,$b0,$c8,$88,$88,$88,$00 ; char 104: h
 132+ 4385 88 88 88 00
 133+ 4389 20 00 20 20          defb $20,$00,$20,$20,$20,$20,$20,$00 ; char 105: i
 133+ 438D 20 20 20 00
 134+ 4391 08 00 18 08          defb $08,$00,$18,$08,$08,$88,$70,$00 ; char 106: j
 134+ 4395 08 88 70 00
 135+ 4399 80 80 90 A0          defb $80,$80,$90,$a0,$c0,$a0,$90,$00 ; char 107: k
 135+ 439D C0 A0 90 00
 136+ 43A1 60 20 20 20          defb $60,$20,$20,$20,$20,$20,$70,$00 ; char 108: l
 136+ 43A5 20 20 70 00
 137+ 43A9 00 00 D0 A8          defb $00,$00,$d0,$a8,$a8,$88,$88,$00 ; char 109: m
 137+ 43AD A8 88 88 00
 138+ 43B1 00 00 B0 C8          defb $00,$00,$b0,$c8,$88,$88,$88,$00 ; char 110: n
 138+ 43B5 88 88 88 00
 139+ 43B9 00 00 70 88          defb $00,$00,$70,$88,$88,$88,$70,$00 ; char 111: o
 139+ 43BD 88 88 70 00
 140+ 43C1 00 00 F0 88          defb $00,$00,$f0,$88,$f0,$80,$80,$00 ; char 112: p
 140+ 43C5 F0 80 80 00
 141+ 43C9 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$08,$00 ; char 113: q
 141+ 43CD 78 08 08 00
 142+ 43D1 00 00 B0 C8          defb $00,$00,$b0,$c8,$80,$80,$80,$00 ; char 114: r
 142+ 43D5 80 80 80 00
 143+ 43D9 00 00 70 80          defb $00,$00,$70,$80,$70,$08,$f0,$00 ; char 115: s
 143+ 43DD 70 08 F0 00
 144+ 43E1 40 40 E0 40          defb $40,$40,$e0,$40,$40,$48,$30,$00 ; char 116: t
 144+ 43E5 40 48 30 00
 145+ 43E9 00 00 88 88          defb $00,$00,$88,$88,$88,$98,$68,$00 ; char 117: u
 145+ 43ED 88 98 68 00
 146+ 43F1 00 00 88 88          defb $00,$00,$88,$88,$88,$50,$20,$00 ; char 118: v
 146+ 43F5 88 50 20 00
 147+ 43F9 00 00 88 88          defb $00,$00,$88,$88,$a8,$a8,$50,$00 ; char 119: w
 147+ 43FD A8 A8 50 00
 148+ 4401 00 00 88 50          defb $00,$00,$88,$50,$20,$50,$88,$00 ; char 120: x
 148+ 4405 20 50 88 00
 149+ 4409 00 00 88 98          defb $00,$00,$88,$98,$68,$08,$70,$00 ; char 121: y
 149+ 440D 68 08 70 00
 150+ 4411 00 00 F8 10          defb $00,$00,$f8,$10,$20,$40,$f8,$00 ; char 122: z
 150+ 4415 20 40 F8 00
 151+ 4419 10 20 20 40          defb $10,$20,$20,$40,$20,$20,$10,$00 ; char 123: {
 151+ 441D 20 20 10 00
 152+ 4421 20 20 20 20          defb $20,$20,$20,$20,$20,$20,$20,$00 ; char 124: |
 152+ 4425 20 20 20 00
 153+ 4429 20 10 10 08          defb $20,$10,$10,$08,$10,$10,$20,$00 ; char 125: }
 153+ 442D 10 10 20 00
 154+ 4431 00 28 50 00          defb $00,$28,$50,$00,$00,$00,$00,$00 ; char 126: ~
 154+ 4435 00 00 00 00
 155+ 4439 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 127: (delete) - here end the standard ASCII (0-127)
 155+ 443D 00 00 00 00
 156+ 4441 78 84 CC 84          defb %01111000,%10000100,%11001100,%10000100,%10110100,%10000100,%01111000,%00000000 ; char 128 (open face)
 156+ 4445 B4 84 78 00
 157+ 4449 78 FC B4 FC          defb %01111000,%11111100,%10110100,%11111100,%10110100,%11001100,%01111000,%00000000 ; char 129 (full face)
 157+ 444D B4 CC 78 00
 158+ 4451 48 FC FC FC          defb %01001000,%11111100,%11111100,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 130 (hearts)
 158+ 4455 FC 78 30 00
 159+ 4459 00 20 70 F8          defb %00000000,%00100000,%01110000,%11111000,%11111000,%01110000,%00100000,%00000000 ; char 131 (diamonds)
 159+ 445D F8 70 20 00
 160+ 4461 70 20 A8 F8          defb %01110000,%00100000,%10101000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 132 (clubs)
 160+ 4465 A8 20 70 00
 161+ 4469 20 70 F8 F8          defb %00100000,%01110000,%11111000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 133 (spades)
 161+ 446D A8 20 70 00
 162+ 4471 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 134
 162+ 4475 FC 30 30 30
 163+ 4479 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 135
 163+ 447D 3C 30 30 30
 164+ 4481 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 136
 164+ 4485 F0 30 30 30
 165+ 4489 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00000000,%00000000,%00000000 ; char 137
 165+ 448D F0 00 00 00
 166+ 4491 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00000000,%00000000,%00000000 ; char 138
 166+ 4495 3C 00 00 00
 167+ 4499 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 139
 167+ 449D FC 00 00 00
 168+ 44A1 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 140
 168+ 44A5 3C 30 30 30
 169+ 44A9 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 141
 169+ 44AD FC 30 30 30
 170+ 44B1 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 142
 170+ 44B5 F0 30 30 30
 171+ 44B9 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 143
 171+ 44BD FC 00 00 00
 172+ 44C1 30 30 30 30          defb %00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000 ; char 144
 172+ 44C5 30 30 30 30
 173+ 44C9 0C 1C 18 38          defb %00001100,%00011100,%00011000,%00111000,%01110000,%01100000,%11100000,%11000000 ; char 145
 173+ 44CD 70 60 E0 C0
 174+ 44D1 C0 E0 60 70          defb %11000000,%11100000,%01100000,%01110000,%00111000,%00011000,%00011100,%00001100 ; char 146
 174+ 44D5 38 18 1C 0C
 175+ 44D9 CC CC 78 30          defb %11001100,%11001100,%01111000,%00110000,%00110000,%01111000,%11001100,%11001100 ; char 147
 175+ 44DD 30 78 CC CC
 176+ 44E1 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 148
 176+ 44E5 20 20 20 20
 177+ 44E9 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 149
 177+ 44ED 20 20 20 20
 178+ 44F1 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 150
 178+ 44F5 20 20 20 20
 179+ 44F9 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 151
 179+ 44FD 00 00 00 00
 180+ 4501 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00000000,%00000000,%00000000,%00000000 ; char 152
 180+ 4505 00 00 00 00
 181+ 4509 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 153
 181+ 450D 00 00 00 00
 182+ 4511 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 154
 182+ 4515 20 20 20 20
 183+ 4519 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 155
 183+ 451D 20 20 20 20
 184+ 4521 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 156
 184+ 4525 20 20 20 20
 185+ 4529 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 157
 185+ 452D 00 00 00 00
 186+ 4531 20 20 20 20          defb %00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000 ; char 158
 186+ 4535 20 20 20 20
 187+ 4539 04 08 08 10          defb %00000100,%00001000,%00001000,%00010000,%00100000,%01000000,%01000000,%10000000 ; char 159
 187+ 453D 20 40 40 80
 188+ 4541 80 40 40 20          defb %10000000,%01000000,%01000000,%00100000,%00010000,%00001000,%00001000,%00000100 ; char 160
 188+ 4545 10 08 08 04
 189+ 4549 84 48 48 30          defb %10000100,%01001000,%01001000,%00110000,%00110000,%01001000,%01001000,%10000100 ; char 161
 189+ 454D 30 48 48 84
 190+ 4551 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 162
 190+ 4555 00 00 FC FC
 191+ 4559 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111100,%11111100,%11111100,%11111100 ; char 163
 191+ 455D FC FC FC FC
 192+ 4561 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 164
 192+ 4565 FC FC FC FC
 193+ 4569 FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 193+ 456D 00 00 00 00
 194+ 4571 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 166
 194+ 4575 00 00 00 00
 195+ 4579 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 167
 195+ 457D FC FC 00 00
 196+ 4581 80 80 80 80          defb %10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000 ; char 168
 196+ 4585 80 80 80 80
 197+ 4589 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000 ; char 169
 197+ 458D E0 E0 E0 E0
 198+ 4591 F8 F8 F8 F8          defb %11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000 ; char 170
 198+ 4595 F8 F8 F8 F8
 199+ 4599 04 04 04 04          defb %00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100 ; char 171
 199+ 459D 04 04 04 04
 200+ 45A1 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100 ; char 172
 200+ 45A5 1C 1C 1C 1C
 201+ 45A9 7C 7C 7C 7C          defb %01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100 ; char 173
 201+ 45AD 7C 7C 7C 7C
 202+ 45B1 FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 174
 202+ 45B5 84 84 84 FC
 203+ 45B9 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%11100000,%11100000,%11100000 ; char 175
 203+ 45BD E0 E0 E0 E0
 204+ 45C1 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00011100,%00011100,%00011100 ; char 176
 204+ 45C5 1C 1C 1C 1C
 205+ 45C9 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 177
 205+ 45CD 00 00 00 00
 206+ 45D1 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 178
 206+ 45D5 00 00 00 00
 207+ 45D9 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00011100,%00011100,%00011100,%00011100 ; char 179
 207+ 45DD 1C 1C 1C 1C
 208+ 45E1 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%11100000,%11100000,%11100000,%11100000 ; char 180
 208+ 45E5 E0 E0 E0 E0
 209+ 45E9 78 78 78 78          defb %01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000 ; char 181
 209+ 45ED 78 78 78 78
 210+ 45F1 CC CC CC CC          defb %11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100 ; char 182
 210+ 45F5 CC CC CC CC
 211+ 45F9 FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 183
 211+ 45FD 00 00 FC FC
 212+ 4601 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 184
 212+ 4605 FC FC 00 00
 213+ 4609 30 30 CC CC          defb %00110000,%00110000,%11001100,%11001100,%00110000,%00110000,%11001100,%11001100 ; char 185
 213+ 460D 30 30 CC CC
 214+ 4611 54 A8 54 A8          defb %01010100,%10101000,%01010100,%10101000,%01010100,%10101000,%01010100,%10101000 ; char 186
 214+ 4615 54 A8 54 A8
 215+ 4619 64 30 98 CC          defb %01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100 ; char 187
 215+ 461D 64 30 98 CC
 216+ 4621 CC 64 30 98          defb %11001100,%01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000 ; char 188
 216+ 4625 CC 64 30 98
 217+ 4629 30 98 CC 64          defb %00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100,%01100100 ; char 189
 217+ 462D 30 98 CC 64
 218+ 4631 64 CC 98 30          defb %01100100,%11001100,%10011000,%00110000,%01100100,%11001100,%10011000,%00110000 ; char 190
 218+ 4635 64 CC 98 30
 219+ 4639 20 20 F8 20          defb %00100000,%00100000,%11111000,%00100000,%00100000,%00000000,%11111000,%00000000 ; char 191 (Â±)
 219+ 463D 20 00 F8 00
 220+ 4641 C0 30 08 30          defb %11000000,%00110000,%00001000,%00110000,%11000000,%00000000,%11111000,%00000000 ; char 192 (â¥)
 220+ 4645 C0 00 F8 00
 221+ 4649 18 60 80 60          defb %00011000,%01100000,%10000000,%01100000,%00011000,%00000000,%11111000,%00000000 ; char 193 (â¤)
 221+ 464D 18 00 F8 00
 222+ 4651 3C 20 20 20          defb %00111100,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 222+ 4655 A0 60 20 00
 223+ 4659 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 223+ 465D 00 00 00 00
 224+ 4661 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 224+ 4665 70 00 00 00
 225+ 4669 00 00 54 A8          defb %00000000,%00000000,%01010100,%10101000,%00000000,%11111100,%00000000,%00000000 ; char 197
 225+ 466D 00 FC 00 00
 226+ 4671 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 226+ 4675 54 A8 00 00
 227+ 4679 00 80 C0 E0          defb %00000000,%10000000,%11000000,%11100000,%11100000,%11000000,%10000000,%00000000 ; char 199
 227+ 467D E0 C0 80 00
 228+ 4681 FC 78 30 00          defb %11111100,%01111000,%00110000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 200
 228+ 4685 00 00 00 00
 229+ 4689 00 04 0C 1C          defb %00000000,%00000100,%00001100,%00011100,%00011100,%00001100,%00000100,%00000000 ; char 201
 229+ 468D 1C 0C 04 00
 230+ 4691 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00110000,%01111000,%11111100 ; char 202
 230+ 4695 00 30 78 FC
 231+ 4699 20 70 F8 20          defb %00100000,%01110000,%11111000,%00100000,%00100000,%00100000,%00100000,%00000000 ; char 203 (up arrow)
 231+ 469D 20 20 20 00
 232+ 46A1 3C 1C 1C 24          defb %00111100,%00011100,%00011100,%00100100,%01000000,%10000000,%00000000,%00000000 ; char 204 (up right arrow)
 232+ 46A5 40 80 00 00
 233+ 46A9 00 10 18 FC          defb %00000000,%00010000,%00011000,%11111100,%00011000,%00010000,%00000000,%00000000 ; char 205 (right arrow)
 233+ 46AD 18 10 00 00
 234+ 46B1 00 00 80 40          defb %00000000,%00000000,%10000000,%01000000,%00100100,%00011100,%00011100,%00111100 ; char 206 (down right arrow)
 234+ 46B5 24 1C 1C 3C
 235+ 46B9 00 20 20 20          defb %00000000,%00100000,%00100000,%00100000,%00100000,%11111000,%01110000,%00100000 ; char 207 (down arrow)
 235+ 46BD 20 F8 70 20
 236+ 46C1 00 00 04 08          defb %00000000,%00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000 ; char 208 (down left arrow)
 236+ 46C5 90 E0 E0 F0
 237+ 46C9 00 20 60 FC          defb %00000000,%00100000,%01100000,%11111100,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 237+ 46CD 60 20 00 00
 238+ 46D1 F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 238+ 46D5 08 04 00 00
 239+ 46D9 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 239+ 46DD F0 44 38 00
 240+ 46E1 00 04 78 A8          defb %00000000,%00000100,%01111000,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 240+ 46E5 28 28 28 00
 241+ 46E9 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00100000,%00100000,%00100000 ; char 213
 241+ 46ED 1C 20 20 20
 242+ 46F1 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%00010000,%00010000,%00010000 ; char 214
 242+ 46F5 E0 10 10 10
 243+ 46F9 10 10 10 E0          defb %00010000,%00010000,%00010000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 215
 243+ 46FD 00 00 00 00
 244+ 4701 20 20 20 1C          defb %00100000,%00100000,%00100000,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 216
 244+ 4705 00 00 00 00
 245+ 4709 00 00 00 1C          defb %00000000,%00000000,%00000000,%00011100,%00111100,%00110000,%00110000,%00110000 ; char 217
 245+ 470D 3C 30 30 30
 246+ 4711 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00110000,%00110000,%00110000 ; char 218
 246+ 4715 F0 30 30 30
 247+ 4719 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 247+ 471D E0 00 00 00
 248+ 4721 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00011100,%00000000,%00000000,%00000000 ; char 220
 248+ 4725 1C 00 00 00
 249+ 4729 00 30 48 48          defb %00000000,%00110000,%01001000,%01001000,%01001000,%00110000,%00000000,%00000000 ; char 221
 249+ 472D 48 30 00 00
 250+ 4731 00 30 78 78          defb %00000000,%00110000,%01111000,%01111000,%01111000,%00110000,%00000000,%00000000 ; char 222
 250+ 4735 78 30 00 00
 251+ 4739 00 30 78 FC          defb %00000000,%00110000,%01111000,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 223
 251+ 473D FC 78 30 00
 252+ 4741 FC F8 F0 E0          defb %11111100,%11111000,%11110000,%11100000,%11100000,%11000000,%10000000,%10000000 ; char 224
 252+ 4745 E0 C0 80 80
 253+ 4749 FC 7C 3C 1C          defb %11111100,%01111100,%00111100,%00011100,%00011100,%00001100,%00000100,%00000100 ; char 225
 253+ 474D 1C 0C 04 04
 254+ 4751 04 04 0C 1C          defb %00000100,%00000100,%00001100,%00011100,%00011100,%00111100,%01111100,%11111100 ; char 226
 254+ 4755 1C 3C 7C FC
 255+ 4759 80 80 C0 E0          defb %10000000,%10000000,%11000000,%11100000,%11100000,%11110000,%11111000,%11111100 ; char 227
 255+ 475D E0 F0 F8 FC
 256+ 4761 00 04 0C D8          defb %00000000,%00000100,%00001100,%11011000,%11110000,%11100000,%11000000,%00000000 ; char 228 (checkmark)
 256+ 4765 F0 E0 C0 00
 257+ 4769 00 CC 78 30          defb %00000000,%11001100,%01111000,%00110000,%01111000,%11001100,%00000000,%00000000 ; char 229 (x)
 257+ 476D 78 CC 00 00
 258+ 4771 70 88 88 88          defb %01110000,%10001000,%10001000,%10001000,%01110000,%00100000,%01110000,%00100000 ; char 230 (female)
 258+ 4775 70 20 70 20
 259+ 4779 00 1C 0C 74          defb %00000000,%00011100,%00001100,%01110100,%10010000,%10010000,%01100000,%00000000 ; char 231 (male)
 259+ 477D 90 90 60 00
 260+ 4781 F8 84 84 84          defb %11111000,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 232 (new doc)
 260+ 4785 84 84 84 FC
 261+ 4789 00 F0 FC 84          defb %00000000,%11110000,%11111100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 233 (folder)
 261+ 478D 84 84 84 FC
 262+ 4791 30 78 FC 48          defb %00110000,%01111000,%11111100,%01001000,%01001000,%01001000,%01001000,%01111000 ; char 234 (trash bin)
 262+ 4795 48 48 48 78
 263+ 4799 FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%11111100,%10110100,%10110100,%11111100 ; char 235 (floppy disk)
 263+ 479D FC B4 B4 FC
 264+ 47A1 00 00 D4 D8          defb %00000000,%00000000,%11010100,%11011000,%11010100,%11010100,%00000000,%00000000 ; char 236 (OK)
 264+ 47A5 D4 D4 00 00
 265+ 47A9 30 78 FC 78          defb %00110000,%01111000,%11111100,%01111000,%01111000,%01001000,%01001000,%01001000 ; char 237 (home)
 265+ 47AD 78 48 48 48
 266+ 47B1 78 84 A4 A4          defb %01111000,%10000100,%10100100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 238 (clock)
 266+ 47B5 B4 84 78 00
 267+ 47B9 00 00 08 F4          defb %00000000,%00000000,%00001000,%11110100,%10101000,%10000000,%00000000,%00000000 ; char 239 (key)
 267+ 47BD A8 80 00 00
 268+ 47C1 20 30 78 B0          defb %00100000,%00110000,%01111000,%10110000,%10100000,%10001000,%01110000,%00000000 ; char 240 (undo)
 268+ 47C5 A0 88 70 00
 269+ 47C9 00 FC CC B4          defb %00000000,%11111100,%11001100,%10110100,%10000100,%10000100,%11111100,%00000000 ; char 241 (letter)
 269+ 47CD 84 84 FC 00
 270+ 47D1 60 90 90 F0          defb %01100000,%10010000,%10010000,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 242 (lock)
 270+ 47D5 F0 F0 F0 00
 271+ 47D9 08 14 14 F0          defb %00001000,%00010100,%00010100,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 243 (unlock)
 271+ 47DD F0 F0 F0 00
 272+ 47E1 FC FC 84 B4          defb %11111100,%11111100,%10000100,%10110100,%10010100,%10010100,%10000100,%11111100 ; char 244 (calendar)
 272+ 47E5 94 94 84 FC
 273+ 47E9 00 04 38 58          defb %00000000,%00000100,%00111000,%01011000,%01101000,%01110000,%10000000,%00000000 ; char 245 (diameter)
 273+ 47ED 68 70 80 00
 274+ 47F1 78 84 84 84          defb %01111000,%10000100,%10000100,%10000100,%01101100,%00011000,%00001000,%00000000 ; char 246 (baloon)
 274+ 47F5 6C 18 08 00
 275+ 47F9 30 28 28 28          defb %00110000,%00101000,%00101000,%00101000,%00100000,%01100000,%11100000,%01000000 ; char 247 (note)
 275+ 47FD 20 60 E0 40
 276+ 4801 20 68 E4 E4          defb %00100000,%01101000,%11100100,%11100100,%11100100,%01101000,%00100000,%00000000 ; char 248 (audio on)
 276+ 4805 E4 68 20 00
 277+ 4809 20 60 E0 E0          defb %00100000,%01100000,%11100000,%11100000,%11100000,%01100000,%00100000,%00000000 ; char 249 (audio off)
 277+ 480D E0 60 20 00
 278+ 4811 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11110000,%10010000 ; char 250 (pointer)
 278+ 4815 F8 FC F0 90
 279+ 4819 78 84 B4 A4          defb %01111000,%10000100,%10110100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 251 (Â©)
 279+ 481D B4 84 78 00
 280+ 4821 30 48 40 E0          defb %00110000,%01001000,%01000000,%11100000,%01000000,%01001000,%10110000,%00000000 ; char 252 (Â£)
 280+ 4825 40 48 B0 00
 281+ 4829 78 84 F0 48          defb %01111000,%10000100,%11110000,%01001000,%01001000,%00111100,%10000100,%01111000 ; char 253 (Â§)
 281+ 482D 48 3C 84 78
 282+ 4831 00 00 20 00          defb %00000000,%00000000,%00100000,%00000000,%11111000,%00000000,%00100000,%00000000 ; char 254 (Ã·)
 282+ 4835 F8 00 20 00
 283+ 4839 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 255 (cursor)
 283+ 483D FC FC FC FC
 284+ 4841                      ; here ends the ASCII table
 285+ 4841
# file closed: ../include/vdp/6x8fonts-r16.asm
  86  4841                  INCLUDE "../include/vdp/8x8fonts-r18.asm"
# file opened: ../include/vdp/8x8fonts-r18.asm
   1+ 4841              ; ------------------------------------------------------------------------------
   2+ 4841              ; LM80C - 8x8 CHARSET - R1.8
   3+ 4841              ; ------------------------------------------------------------------------------
   4+ 4841              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4841              ; designed by Leonardo Miliani. More info at
   6+ 4841              ; www DOT leonardomiliani DOT com
   7+ 4841              ; ------------------------------------------------------------------------------
   8+ 4841              ; Code Revision:
   9+ 4841              ; R1.0 - 20190615 - First revision: ASCII chars (from 0 to 255) - actually, they are 6x8 pixels
  10+ 4841              ; R1.1 - 20190616 - Converted to 8x8 pixels
  11+ 4841              ; R1.2 - 20191013 - Added new graphic chars and reorganized previous ones
  12+ 4841              ; R1.3 - 20191015 - More graphic chars
  13+ 4841              ; R1.4 - 20191202 - Fixed char 11/12, added new special chars
  14+ 4841              ; R1.5 - 20191210 - Changed several graphic chars
  15+ 4841              ; R1.6 - 20200125 - Removed double chars, changed with new ones
  16+ 4841              ; R1.7 - 20200228 - adopted more usual hexadecimal & binary prefixes
  17+ 4841              ; R1.8 - 20200524 - New style for char #252
  18+ 4841              ; ------------------------------------------------------------------------------
  19+ 4841              ;
  20+ 4841              ;-------------------------------------------------------------------------------
  21+ 4841              ;
  22+ 4841              ;               8 x 8    C  H  A  R  S  E  T
  23+ 4841              ;
  24+ 4841              ;-------------------------------------------------------------------------------
  25+ 4841              ;
  26+ 4841              ;       8X8 CHARS, DESIGNED FOR GRAPHICS 1 MODE
  27+ 4841
  28+ 4841              CHRST88 equ $
  29+ 4841 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  29+ 4845 00 00 00 00
  30+ 4849 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  30+ 484D 00 00 00 00
  31+ 4851 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  31+ 4855 00 00 00 00
  32+ 4859 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  32+ 485D 00 00 00 00
  33+ 4861 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  33+ 4865 00 00 00 00
  34+ 4869 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  34+ 486D 00 00 00 00
  35+ 4871 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  35+ 4875 00 00 00 00
  36+ 4879 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  36+ 487D 00 00 00 00
  37+ 4881 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 DEL key (backspace)
  37+ 4885 00 00 00 00
  38+ 4889 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  38+ 488D 00 00 00 00
  39+ 4891 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  39+ 4895 00 00 00 00
  40+ 4899 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 (unused)
  40+ 489D 00 00 00 00
  41+ 48A1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  41+ 48A5 00 00 00 00
  42+ 48A9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 RETURN key (carriage return)
  42+ 48AD 00 00 00 00
  43+ 48B1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL key
  43+ 48B5 00 00 00 00
  44+ 48B9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  44+ 48BD 00 00 00 00
  45+ 48C1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  45+ 48C5 00 00 00 00
  46+ 48C9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  46+ 48CD 00 00 00 00
  47+ 48D1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  47+ 48D5 00 00 00 00
  48+ 48D9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  48+ 48DD 00 00 00 00
  49+ 48E1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT key
  49+ 48E5 00 00 00 00
  50+ 48E9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  50+ 48ED 00 00 00 00
  51+ 48F1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6 key
  51+ 48F5 00 00 00 00
  52+ 48F9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7 key
  52+ 48FD 00 00 00 00
  53+ 4901 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP key
  53+ 4905 00 00 00 00
  54+ 4909 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 HOME key
  54+ 490D 00 00 00 00
  55+ 4911 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26 INSERT key
  55+ 4915 00 00 00 00
  56+ 4919 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 ESCAPE key
  56+ 491D 00 00 00 00
  57+ 4921 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 CRSR LEFT key (cursor left)
  57+ 4925 00 00 00 00
  58+ 4929 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 CRSR RIGHT key (cursor right)
  58+ 492D 00 00 00 00
  59+ 4931 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 CRSR UP key (cursor up)
  59+ 4935 00 00 00 00
  60+ 4939 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 CRSR DOWN key (cursor down)
  60+ 493D 00 00 00 00
  61+ 4941 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32 SPACE key
  61+ 4945 00 00 00 00
  62+ 4949 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00000000,%00010000,%00000000 ; char 33 - !
  62+ 494D 10 00 10 00
  63+ 4951 28 28 28 00          defb %00101000,%00101000,%00101000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 34 - "
  63+ 4955 00 00 00 00
  64+ 4959 28 28 FE 28          defb %00101000,%00101000,%11111110,%00101000,%11111110,%00101000,%00101000,%00000000 ; char 35 - #
  64+ 495D FE 28 28 00
  65+ 4961 10 3C 50 38          defb %00010000,%00111100,%01010000,%00111000,%00010100,%01111000,%00010000,%00000000 ; char 36 - $
  65+ 4965 14 78 10 00
  66+ 4969 00 62 64 08          defb %00000000,%01100010,%01100100,%00001000,%00010000,%00100110,%01000110,%00000000 ; char 37 - %
  66+ 496D 10 26 46 00
  67+ 4971 00 30 48 30          defb %00000000,%00110000,%01001000,%00110000,%01001010,%01000100,%00111010,%00000000 ; char 38 - &
  67+ 4975 4A 44 3A 00
  68+ 4979 08 10 20 00          defb %00001000,%00010000,%00100000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 39 - '
  68+ 497D 00 00 00 00
  69+ 4981 08 10 20 20          defb %00001000,%00010000,%00100000,%00100000,%00100000,%00010000,%00001000,%00000000 ; char 40 - (
  69+ 4985 20 10 08 00
  70+ 4989 20 10 08 08          defb %00100000,%00010000,%00001000,%00001000,%00001000,%00010000,%00100000,%00000000 ; char 41 - )
  70+ 498D 08 10 20 00
  71+ 4991 00 10 54 38          defb %00000000,%00010000,%01010100,%00111000,%00111000,%01010100,%00010000,%00000000 ; char 42 - *
  71+ 4995 38 54 10 00
  72+ 4999 00 10 10 7C          defb %00000000,%00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%00000000 ; char 43 - +
  72+ 499D 10 10 00 00
  73+ 49A1 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00001000,%00010000 ; char 44 - ,
  73+ 49A5 00 18 08 10
  74+ 49A9 00 00 00 7C          defb %00000000,%00000000,%00000000,%01111100,%00000000,%00000000,%00000000,%00000000 ; char 45 - -
  74+ 49AD 00 00 00 00
  75+ 49B1 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00011000,%00000000 ; char 46 - .
  75+ 49B5 00 18 18 00
  76+ 49B9 00 02 04 08          defb %00000000,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%00000000 ; char 47 - /
  76+ 49BD 10 20 40 00
  77+ 49C1 38 44 4C 54          defb %00111000,%01000100,%01001100,%01010100,%01100100,%01000100,%00111000,%00000000 ; char 48 - 0
  77+ 49C5 64 44 38 00
  78+ 49C9 10 30 50 10          defb %00010000,%00110000,%01010000,%00010000,%00010000,%00010000,%01111100,%00000000 ; char 49 - 1
  78+ 49CD 10 10 7C 00
  79+ 49D1 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 50 - 2
  79+ 49D5 10 20 7C 00
  80+ 49D9 7C 08 10 08          defb %01111100,%00001000,%00010000,%00001000,%00000100,%01000100,%00111000,%00000000 ; char 51 - 3
  80+ 49DD 04 44 38 00
  81+ 49E1 08 18 28 48          defb %00001000,%00011000,%00101000,%01001000,%01111100,%00001000,%00001000,%00000000 ; char 52 - 4
  81+ 49E5 7C 08 08 00
  82+ 49E9 7C 40 78 04          defb %01111100,%01000000,%01111000,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 53 - 5
  82+ 49ED 04 44 38 00
  83+ 49F1 38 44 40 78          defb %00111000,%01000100,%01000000,%01111000,%01000100,%01000100,%00111000,%00000000 ; char 54 - 6
  83+ 49F5 44 44 38 00
  84+ 49F9 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%00100000,%00100000,%00000000 ; char 55 - 7
  84+ 49FD 20 20 20 00
  85+ 4A01 38 44 44 38          defb %00111000,%01000100,%01000100,%00111000,%01000100,%01000100,%00111000,%00000000 ; char 56 - 8
  85+ 4A05 44 44 38 00
  86+ 4A09 38 44 44 3C          defb %00111000,%01000100,%01000100,%00111100,%00000100,%01000100,%00111000,%00000000 ; char 57 - 9
  86+ 4A0D 04 44 38 00
  87+ 4A11 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00011000,%00000000,%00000000 ; char 58 - :
  87+ 4A15 18 18 00 00
  88+ 4A19 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00001000,%00010000,%00000000 ; char 59 - ;
  88+ 4A1D 18 08 10 00
  89+ 4A21 04 08 10 20          defb %00000100,%00001000,%00010000,%00100000,%00010000,%00001000,%00000100,%00000000 ; char 60 - <
  89+ 4A25 10 08 04 00
  90+ 4A29 00 00 7E 00          defb %00000000,%00000000,%01111110,%00000000,%01111110,%00000000,%00000000,%00000000 ; char 61 - =
  90+ 4A2D 7E 00 00 00
  91+ 4A31 20 10 08 04          defb %00100000,%00010000,%00001000,%00000100,%00001000,%00010000,%00100000,%00000000 ; char 62 - >
  91+ 4A35 08 10 20 00
  92+ 4A39 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00000000,%00010000,%00000000 ; char 63 - ?
  92+ 4A3D 10 00 10 00
  93+ 4A41 78 84 BC AC          defb %01111000,%10000100,%10111100,%10101100,%10111000,%10000000,%10000100,%01111000 ; char 64 - @
  93+ 4A45 B8 80 84 78
  94+ 4A49 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%00000000 ; char 65 - A
  94+ 4A4D 7C 44 44 00
  95+ 4A51 78 44 44 78          defb %01111000,%01000100,%01000100,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 66 - B
  95+ 4A55 44 44 78 00
  96+ 4A59 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 67 - C
  96+ 4A5D 40 44 38 00
  97+ 4A61 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01000100,%01000100,%01111000,%00000000 ; char 68 - D
  97+ 4A65 44 44 78 00
  98+ 4A69 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01111100,%00000000 ; char 69 - E
  98+ 4A6D 40 40 7C 00
  99+ 4A71 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01000000,%00000000 ; char 70 - F
  99+ 4A75 40 40 40 00
 100+ 4A79 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01011100,%01000100,%00111000,%00000000 ; char 71 - G
 100+ 4A7D 5C 44 38 00
 101+ 4A81 44 44 44 7C          defb %01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%01000100,%00000000 ; char 72 - H
 101+ 4A85 44 44 44 00
 102+ 4A89 38 10 10 10          defb %00111000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 73 - I
 102+ 4A8D 10 10 38 00
 103+ 4A91 3C 04 04 04          defb %00111100,%00000100,%00000100,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 74 - J
 103+ 4A95 04 44 38 00
 104+ 4A99 44 44 48 70          defb %01000100,%01000100,%01001000,%01110000,%01001000,%01000100,%01000100,%00000000 ; char 75 - K
 104+ 4A9D 48 44 44 00
 105+ 4AA1 40 40 40 40          defb %01000000,%01000000,%01000000,%01000000,%01000000,%01000000,%01111100,%00000000 ; char 76 - L
 105+ 4AA5 40 40 7C 00
 106+ 4AA9 42 66 5A 42          defb %01000010,%01100110,%01011010,%01000010,%01000010,%01000010,%01000010,%00000000 ; char 77 - M
 106+ 4AAD 42 42 42 00
 107+ 4AB1 44 64 54 4C          defb %01000100,%01100100,%01010100,%01001100,%01000100,%01000100,%01000100,%00000000 ; char 78 - N
 107+ 4AB5 44 44 44 00
 108+ 4AB9 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 79 - O
 108+ 4ABD 44 44 38 00
 109+ 4AC1 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01000000,%01000000,%00000000 ; char 80 - P
 109+ 4AC5 78 40 40 00
 110+ 4AC9 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01010100,%01001000,%00110100,%00000000 ; char 81 - Q
 110+ 4ACD 54 48 34 00
 111+ 4AD1 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01001000,%01000100,%00000000 ; char 82 - R
 111+ 4AD5 78 48 44 00
 112+ 4AD9 3C 40 40 38          defb %00111100,%01000000,%01000000,%00111000,%00000100,%00000100,%01111000,%00000000 ; char 83 - S
 112+ 4ADD 04 04 78 00
 113+ 4AE1 7C 10 10 10          defb %01111100,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 84 - T
 113+ 4AE5 10 10 10 00
 114+ 4AE9 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 85 - U
 114+ 4AED 44 44 38 00
 115+ 4AF1 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 86 - V
 115+ 4AF5 44 28 10 00
 116+ 4AF9 42 42 42 42          defb %01000010,%01000010,%01000010,%01000010,%01011010,%01011010,%00100100,%00000000 ; char 87 - W
 116+ 4AFD 5A 5A 24 00
 117+ 4B01 44 44 28 10          defb %01000100,%01000100,%00101000,%00010000,%00101000,%01000100,%01000100,%00000000 ; char 88 - X
 117+ 4B05 28 44 44 00
 118+ 4B09 44 44 44 28          defb %01000100,%01000100,%01000100,%00101000,%00010000,%00010000,%00010000,%00000000 ; char 89 - Y
 118+ 4B0D 10 10 10 00
 119+ 4B11 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%01000000,%01111100,%00000000 ; char 90 - Z
 119+ 4B15 20 40 7C 00
 120+ 4B19 38 20 20 20          defb %00111000,%00100000,%00100000,%00100000,%00100000,%00100000,%00111000,%00000000 ; char 91 - [
 120+ 4B1D 20 20 38 00
 121+ 4B21 00 40 20 10          defb %00000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000000 ; char 92 - \
 121+ 4B25 08 04 02 00
 122+ 4B29 38 08 08 08          defb %00111000,%00001000,%00001000,%00001000,%00001000,%00001000,%00111000,%00000000 ; char 93 - ]
 122+ 4B2D 08 08 38 00
 123+ 4B31 10 28 44 00          defb %00010000,%00101000,%01000100,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 94 - ^
 123+ 4B35 00 00 00 00
 124+ 4B39 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%01111110,%00000000 ; char 95 _ (underscore)
 124+ 4B3D 00 00 7E 00
 125+ 4B41 20 10 08 00          defb %00100000,%00010000,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 96 - `
 125+ 4B45 00 00 00 00
 126+ 4B49 00 00 38 04          defb %00000000,%00000000,%00111000,%00000100,%00111100,%01000100,%00111100,%00000000 ; char 97 - a
 126+ 4B4D 3C 44 3C 00
 127+ 4B51 40 40 40 78          defb %01000000,%01000000,%01000000,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 98 - b
 127+ 4B55 44 44 78 00
 128+ 4B59 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 99 - c
 128+ 4B5D 40 44 38 00
 129+ 4B61 04 04 04 3C          defb %00000100,%00000100,%00000100,%00111100,%01000100,%01000100,%00111100,%00000000 ; char 100 - d
 129+ 4B65 44 44 3C 00
 130+ 4B69 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01111100,%01000000,%00111000,%00000000 ; char 101 - e
 130+ 4B6D 7C 40 38 00
 131+ 4B71 18 24 20 70          defb %00011000,%00100100,%00100000,%01110000,%00100000,%00100000,%00100000,%00000000 ; char 102 - f
 131+ 4B75 20 20 20 00
 132+ 4B79 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00111000 ; char 103 - g
 132+ 4B7D 44 3C 04 38
 133+ 4B81 40 40 58 64          defb %01000000,%01000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 104 - h
 133+ 4B85 44 44 44 00
 134+ 4B89 00 10 00 10          defb %00000000,%00010000,%00000000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 105 - i
 134+ 4B8D 10 10 10 00
 135+ 4B91 08 00 18 08          defb %00001000,%00000000,%00011000,%00001000,%00001000,%00001000,%01001000,%00110000 ; char 106 - j
 135+ 4B95 08 08 48 30
 136+ 4B99 40 40 48 50          defb %01000000,%01000000,%01001000,%01010000,%01100000,%01010000,%01001000,%00000000 ; char 107 - k
 136+ 4B9D 60 50 48 00
 137+ 4BA1 30 10 10 10          defb %00110000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 108 - l
 137+ 4BA5 10 10 38 00
 138+ 4BA9 00 00 54 6A          defb %00000000,%00000000,%01010100,%01101010,%01001010,%01000010,%01000010,%00000000 ; char 109 - m
 138+ 4BAD 4A 42 42 00
 139+ 4BB1 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 110 - n
 139+ 4BB5 44 44 44 00
 140+ 4BB9 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 111: o
 140+ 4BBD 44 44 38 00
 141+ 4BC1 00 00 78 44          defb %00000000,%00000000,%01111000,%01000100,%01000100,%01111000,%01000000,%01000000 ; char 112: p
 141+ 4BC5 44 78 40 40
 142+ 4BC9 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00000100 ; char 113: q
 142+ 4BCD 44 3C 04 04
 143+ 4BD1 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000000,%01000000,%01000000,%00000000 ; char 114: r
 143+ 4BD5 40 40 40 00
 144+ 4BD9 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%00111000,%00000100,%01111000,%00000000 ; char 115: s
 144+ 4BDD 38 04 78 00
 145+ 4BE1 20 20 70 20          defb %00100000,%00100000,%01110000,%00100000,%00100000,%00100100,%00011000,%00000000 ; char 116: t
 145+ 4BE5 20 24 18 00
 146+ 4BE9 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%01001100,%00110100,%00000000 ; char 117: u
 146+ 4BED 44 4C 34 00
 147+ 4BF1 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 118: v
 147+ 4BF5 44 28 10 00
 148+ 4BF9 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01010100,%01010100,%00101000,%00000000 ; char 119: w
 148+ 4BFD 54 54 28 00
 149+ 4C01 00 00 44 28          defb %00000000,%00000000,%01000100,%00101000,%00010000,%00101000,%01000100,%00000000 ; char 120: x
 149+ 4C05 10 28 44 00
 150+ 4C09 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01001100,%00110100,%00000100,%00111000 ; char 121: y
 150+ 4C0D 4C 34 04 38
 151+ 4C11 00 00 7C 08          defb %00000000,%00000000,%01111100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 122: z
 151+ 4C15 10 20 7C 00
 152+ 4C19 18 20 20 40          defb %00011000,%00100000,%00100000,%01000000,%00100000,%00100000,%00011000,%00000000 ; char 123: {
 152+ 4C1D 20 20 18 00
 153+ 4C21 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 124: |
 153+ 4C25 10 10 10 00
 154+ 4C29 30 08 08 04          defb %00110000,%00001000,%00001000,%00000100,%00001000,%00001000,%00110000,%00000000 ; char 125: }
 154+ 4C2D 08 08 30 00
 155+ 4C31 20 54 08 00          defb %00100000,%01010100,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 126: ~
 155+ 4C35 00 00 00 00
 156+ 4C39 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 127 (delete) - end the standard ASCII (0-127)
 156+ 4C3D 00 00 00 00
 157+ 4C41 3C 42 A5 81          defb %00111100,%01000010,%10100101,%10000001,%10100101,%10011001,%01000010,%00111100 ; char 128 (open face)
 157+ 4C45 A5 99 42 3C
 158+ 4C49 3C 7E DB FF          defb %00111100,%01111110,%11011011,%11111111,%11011011,%11100111,%01111110,%00111100 ; char 129 (full face)
 158+ 4C4D DB E7 7E 3C
 159+ 4C51 6C FE FE FE          defb %01101100,%11111110,%11111110,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 130 (hearts)
 159+ 4C55 7C 38 10 00
 160+ 4C59 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 131 (diamonds)
 160+ 4C5D 7C 38 10 00
 161+ 4C61 10 38 54 FE          defb %00010000,%00111000,%01010100,%11111110,%01010100,%00010000,%01111100,%00000000 ; char 132 (clus)
 161+ 4C65 54 10 7C 00
 162+ 4C69 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%11010110,%00010000,%01111100,%00000000 ; char 133 (spades)
 162+ 4C6D D6 10 7C 00
 163+ 4C71 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 134
 163+ 4C75 FF 18 18 18
 164+ 4C79 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 135
 164+ 4C7D 1F 18 18 18
 165+ 4C81 00 00 00 F8          defb %00000000,%00000000,%00000000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 136
 165+ 4C85 F8 18 18 18
 166+ 4C89 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00000000,%00000000,%00000000 ; char 137
 166+ 4C8D F8 00 00 00
 167+ 4C91 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00000000,%00000000,%00000000 ; char 138
 167+ 4C95 1F 00 00 00
 168+ 4C99 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 139
 168+ 4C9D FF 00 00 00
 169+ 4CA1 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 140
 169+ 4CA5 1F 18 18 18
 170+ 4CA9 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 141
 170+ 4CAD FF 18 18 18
 171+ 4CB1 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 142
 171+ 4CB5 F8 18 18 18
 172+ 4CB9 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 143
 172+ 4CBD FF 00 00 00
 173+ 4CC1 18 18 18 18          defb %00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000 ; char 144
 173+ 4CC5 18 18 18 18
 174+ 4CC9 03 07 0E 1C          defb %00000011,%00000111,%00001110,%00011100,%00111000,%01110000,%11100000,%11000000 ; char 145
 174+ 4CCD 38 70 E0 C0
 175+ 4CD1 C0 E0 70 38          defb %11000000,%11100000,%01110000,%00111000,%00011100,%00001110,%00000111,%00000011 ; char 146
 175+ 4CD5 1C 0E 07 03
 176+ 4CD9 C3 E7 7E 3C          defb %11000011,%11100111,%01111110,%00111100,%00111100,%01111110,%11100111,%11000011 ; char 147
 176+ 4CDD 3C 7E E7 C3
 177+ 4CE1 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 148
 177+ 4CE5 10 10 10 10
 178+ 4CE9 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 149
 178+ 4CED 10 10 10 10
 179+ 4CF1 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 150
 179+ 4CF5 10 10 10 10
 180+ 4CF9 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 151
 180+ 4CFD 00 00 00 00
 181+ 4D01 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00000000,%00000000,%00000000,%00000000 ; char 152
 181+ 4D05 00 00 00 00
 182+ 4D09 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 153
 182+ 4D0D 00 00 00 00
 183+ 4D11 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 154
 183+ 4D15 10 10 10 10
 184+ 4D19 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 155
 184+ 4D1D 10 10 10 10
 185+ 4D21 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 156
 185+ 4D25 10 10 10 10
 186+ 4D29 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 157
 186+ 4D2D 00 00 00 00
 187+ 4D31 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000 ; char 158
 187+ 4D35 10 10 10 10
 188+ 4D39 01 02 04 08          defb %00000001,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%10000000 ; char 159
 188+ 4D3D 10 20 40 80
 189+ 4D41 80 40 20 10          defb %10000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000001 ; char 160
 189+ 4D45 08 04 02 01
 190+ 4D49 81 42 24 18          defb %10000001,%01000010,%00100100,%00011000,%00011000,%00100100,%01000010,%10000001 ; char 161
 190+ 4D4D 18 24 42 81
 191+ 4D51 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 162
 191+ 4D55 00 00 FF FF
 192+ 4D59 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; char 163
 192+ 4D5D FF FF FF FF
 193+ 4D61 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 164
 193+ 4D65 FF FF FF FF
 194+ 4D69 FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 194+ 4D6D 00 00 00 00
 195+ 4D71 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 166
 195+ 4D75 00 00 00 00
 196+ 4D79 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 167
 196+ 4D7D FF FF 00 00
 197+ 4D81 C0 C0 C0 C0          defb %11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000 ; char 168
 197+ 4D85 C0 C0 C0 C0
 198+ 4D89 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; char 169
 198+ 4D8D F0 F0 F0 F0
 199+ 4D91 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 170
 199+ 4D95 FC FC FC FC
 200+ 4D99 03 03 03 03          defb %00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011 ; char 171
 200+ 4D9D 03 03 03 03
 201+ 4DA1 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; char 172
 201+ 4DA5 0F 0F 0F 0F
 202+ 4DA9 3F 3F 3F 3F          defb %00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111 ; char 173
 202+ 4DAD 3F 3F 3F 3F
 203+ 4DB1 FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 174
 203+ 4DB5 81 81 81 FF
 204+ 4DB9 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; char 175
 204+ 4DBD F0 F0 F0 F0
 205+ 4DC1 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; char 176
 205+ 4DC5 0F 0F 0F 0F
 206+ 4DC9 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; char 177
 206+ 4DCD 00 00 00 00
 207+ 4DD1 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 178
 207+ 4DD5 00 00 00 00
 208+ 4DD9 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00001111,%00001111,%00001111,%00001111 ; char 179
 208+ 4DDD 0F 0F 0F 0F
 209+ 4DE1 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%11110000,%11110000,%11110000,%11110000 ; char 180
 209+ 4DE5 F0 F0 F0 F0
 210+ 4DE9 3C 3C 3C 3C          defb %00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100 ; char 181
 210+ 4DED 3C 3C 3C 3C
 211+ 4DF1 C3 C3 C3 C3          defb %11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011 ; char 182
 211+ 4DF5 C3 C3 C3 C3
 212+ 4DF9 FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 183
 212+ 4DFD 00 00 FF FF
 213+ 4E01 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 184
 213+ 4E05 FF FF 00 00
 214+ 4E09 33 33 CC CC          defb %00110011,%00110011,%11001100,%11001100,%00110011,%00110011,%11001100,%11001100 ; char 185
 214+ 4E0D 33 33 CC CC
 215+ 4E11 55 AA 55 AA          defb %01010101,%10101010,%01010101,%10101010,%01010101,%10101010,%01010101,%10101010 ; char 186
 215+ 4E15 55 AA 55 AA
 216+ 4E19 66 33 99 CC          defb %01100110,%00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100 ; char 187
 216+ 4E1D 66 33 99 CC
 217+ 4E21 CC 99 33 66          defb %11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011,%01100110 ; char 188
 217+ 4E25 CC 99 33 66
 218+ 4E29 33 99 CC 66          defb %00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100,%01100110 ; char 189
 218+ 4E2D 33 99 CC 66
 219+ 4E31 66 CC 99 33          defb %01100110,%11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011 ; char 190
 219+ 4E35 66 CC 99 33
 220+ 4E39 10 10 7C 10          defb %00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%01111100,%00000000 ; char 191 (Â±)
 220+ 4E3D 10 00 7C 00
 221+ 4E41 60 18 06 18          defb %01100000,%00011000,%00000110,%00011000,%01100000,%00000000,%01111110,%00000000 ; char 192 (â¥)
 221+ 4E45 60 00 7E 00
 222+ 4E49 06 18 60 18          defb %00000110,%00011000,%01100000,%00011000,%00000110,%00000000,%01111110,%00000000 ; char 193 (â¤)
 222+ 4E4D 06 00 7E 00
 223+ 4E51 3E 20 20 20          defb %00111110,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 223+ 4E55 A0 60 20 00
 224+ 4E59 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 224+ 4E5D 00 00 00 00
 225+ 4E61 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 225+ 4E65 70 00 00 00
 226+ 4E69 00 00 2A 54          defb %00000000,%00000000,%00101010,%01010100,%00000000,%01111110,%00000000,%00000000 ; char 197
 226+ 4E6D 00 7E 00 00
 227+ 4E71 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 227+ 4E75 54 A8 00 00
 228+ 4E79 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11100000,%11000000,%10000000,%00000000 ; char 199
 228+ 4E7D E0 C0 80 00
 229+ 4E81 FE 7C 38 10          defb %11111110,%01111100,%00111000,%00010000,%00000000,%00000000,%00000000,%00000000 ; char 200
 229+ 4E85 00 00 00 00
 230+ 4E89 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00000111,%00000011,%00000001,%00000000 ; char 201
 230+ 4E8D 07 03 01 00
 231+ 4E91 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00010000,%00111000,%01111100,%11111110 ; char 202
 231+ 4E95 10 38 7C FE
 232+ 4E99 10 38 7C 10          defb %00010000,%00111000,%01111100,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 203 (up arrow)
 232+ 4E9D 10 10 10 00
 233+ 4EA1 1E 0E 0E 12          defb %00011110,%00001110,%00001110,%00010010,%00100000,%01000000,%00000000,%00000000 ; char 204 (up right arrow)
 233+ 4EA5 20 40 00 00
 234+ 4EA9 00 08 0C FE          defb %00000000,%00001000,%00001100,%11111110,%00001100,%00001000,%00000000,%00000000 ; char 205 (right arrow)
 234+ 4EAD 0C 08 00 00
 235+ 4EB1 00 40 20 12          defb %00000000,%01000000,%00100000,%00010010,%00001110,%00001110,%00011110,%00000000 ; char 206 (down right arrow)
 235+ 4EB5 0E 0E 1E 00
 236+ 4EB9 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%01111100,%00111000,%00010000,%00000000 ; char 207 (down arrow)
 236+ 4EBD 7C 38 10 00
 237+ 4EC1 00 04 08 90          defb %00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000,%00000000 ; char 208 (down left arrow)
 237+ 4EC5 E0 E0 F0 00
 238+ 4EC9 00 20 60 FE          defb %00000000,%00100000,%01100000,%11111110,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 238+ 4ECD 60 20 00 00
 239+ 4ED1 F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 239+ 4ED5 08 04 00 00
 240+ 4ED9 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 240+ 4EDD F0 44 38 00
 241+ 4EE1 00 02 7C A8          defb %00000000,%00000010,%01111100,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 241+ 4EE5 28 28 28 00
 242+ 4EE9 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001000,%00010000,%00010000,%00010000 ; char 213
 242+ 4EED 08 10 10 10
 243+ 4EF1 00 00 00 C0          defb %00000000,%00000000,%00000000,%11000000,%00100000,%00010000,%00010000,%00010000 ; char 214
 243+ 4EF5 20 10 10 10
 244+ 4EF9 10 10 20 C0          defb %00010000,%00010000,%00100000,%11000000,%00000000,%00000000,%00000000,%00000000 ; char 215
 244+ 4EFD 00 00 00 00
 245+ 4F01 10 10 08 07          defb %00010000,%00010000,%00001000,%00000111,%00000000,%00000000,%00000000,%00000000 ; char 216
 245+ 4F05 00 00 00 00
 246+ 4F09 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001111,%00011100,%00011000,%00011000 ; char 217
 246+ 4F0D 0F 1C 18 18
 247+ 4F11 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00111000,%00011000,%00011000 ; char 218
 247+ 4F15 F0 38 18 18
 248+ 4F19 18 18 38 F0          defb %00011000,%00011000,%00111000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 248+ 4F1D E0 00 00 00
 249+ 4F21 18 18 1C 0F          defb %00011000,%00011000,%00011100,%00001111,%00000111,%00000000,%00000000,%00000000 ; char 220
 249+ 4F25 07 00 00 00
 250+ 4F29 00 3C 42 42          defb %00000000,%00111100,%01000010,%01000010,%01000010,%01000010,%00111100,%00000000 ; char 221
 250+ 4F2D 42 42 3C 00
 251+ 4F31 00 3C 7E 7E          defb %00000000,%00111100,%01111110,%01111110,%01111110,%01111110,%00111100,%00000000 ; char 222
 251+ 4F35 7E 7E 3C 00
 252+ 4F39 00 18 3C 7E          defb %00000000,%00011000,%00111100,%01111110,%01111110,%00111100,%00011000,%00000000 ; char 223
 252+ 4F3D 7E 3C 18 00
 253+ 4F41 FF FE FC F8          defb %11111111,%11111110,%11111100,%11111000,%11110000,%11100000,%11000000,%10000000 ; char 224
 253+ 4F45 F0 E0 C0 80
 254+ 4F49 FF 7F 3F 1F          defb %11111111,%01111111,%00111111,%00011111,%00001111,%00000111,%00000011,%00000001 ; char 225
 254+ 4F4D 0F 07 03 01
 255+ 4F51 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00011111,%00111111,%01111111,%11111111 ; char 226
 255+ 4F55 1F 3F 7F FF
 256+ 4F59 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11111110,%11111111 ; char 227
 256+ 4F5D F8 FC FE FF
 257+ 4F61 00 02 06 6C          defb %00000000,%00000010,%00000110,%01101100,%01111000,%01110000,%01100000,%00000000 ; char 228 (checkmark)
 257+ 4F65 78 70 60 00
 258+ 4F69 00 66 3C 18          defb %00000000,%01100110,%00111100,%00011000,%00111100,%01100110,%00000000,%00000000 ; char 229 (x)
 258+ 4F6D 3C 66 00 00
 259+ 4F71 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%00111000,%00010000,%00111000,%00010000 ; char 230 (female)
 259+ 4F75 38 10 38 10
 260+ 4F79 07 03 3D 44          defb %00000111,%00000011,%00111101,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 231 (male)
 260+ 4F7D 44 44 38 00
 261+ 4F81 78 44 42 42          defb %01111000,%01000100,%01000010,%01000010,%01000010,%01000010,%01000010,%01111110 ; char 232 (new doc)
 261+ 4F85 42 42 42 7E
 262+ 4F89 00 F8 FF 81          defb %00000000,%11111000,%11111111,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 233 (folder)
 262+ 4F8D 81 81 81 FF
 263+ 4F91 10 7C FE 54          defb %00010000,%01111100,%11111110,%01010100,%01010100,%01010100,%01010100,%01111100 ; char 234 (trash bin)
 263+ 4F95 54 54 54 7C
 264+ 4F99 FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10111101,%10101101,%10101101,%11111111 ; char 235 (floppy disk)
 264+ 4F9D BD AD AD FF
 265+ 4FA1 00 EA AA AC          defb %00000000,%11101010,%10101010,%10101100,%10101100,%10101010,%11101010,%00000000 ; char 236 (OK)
 265+ 4FA5 AC AA EA 00
 266+ 4FA9 18 7E FF 7E          defb %00011000,%01111110,%11111111,%01111110,%01111110,%01100110,%01100110,%01100110 ; char 237 (home)
 266+ 4FAD 7E 66 66 66
 267+ 4FB1 3C 42 91 91          defb %00111100,%01000010,%10010001,%10010001,%10011101,%10000001,%01000010,%00111100 ; char 238 (clock)
 267+ 4FB5 9D 81 42 3C
 268+ 4FB9 00 02 05 FD          defb %00000000,%00000010,%00000101,%11111101,%10100101,%10100010,%00000000,%00000000 ; char 239 (key)
 268+ 4FBD A5 A2 00 00
 269+ 4FC1 08 0C 3E 4C          defb %00001000,%00001100,%00111110,%01001100,%01001000,%01000010,%01000010,%00111100 ; char 240 (undo)
 269+ 4FC5 48 42 42 3C
 270+ 4FC9 00 FF C3 A5          defb %00000000,%11111111,%11000011,%10100101,%10011001,%10000001,%11111111,%00000000 ; char 241 (letter)
 270+ 4FCD 99 81 FF 00
 271+ 4FD1 38 44 44 7C          defb %00111000,%01000100,%01000100,%01111100,%01111100,%01111100,%01111100,%00000000 ; char 242 (lock)
 271+ 4FD5 7C 7C 7C 00
 272+ 4FD9 06 09 09 F8          defb %00000110,%00001001,%00001001,%11111000,%11111000,%11111000,%11111000,%00000000 ; char 243 (unlock)
 272+ 4FDD F8 F8 F8 00
 273+ 4FE1 FF FF 81 AD          defb %11111111,%11111111,%10000001,%10101101,%10100101,%10100101,%10000001,%11111111 ; char 244 (calendar)
 273+ 4FE5 A5 A5 81 FF
 274+ 4FE9 01 1A 24 4A          defb %00000001,%00011010,%00100100,%01001010,%01010010,%00100100,%01011000,%10000000 ; char 245 (diameter)
 274+ 4FED 52 24 58 80
 275+ 4FF1 7E 81 81 81          defb %01111110,%10000001,%10000001,%10000001,%10000001,%01110110,%00001100,%00000100 ; char 246 (baloon)
 275+ 4FF5 81 76 0C 04
 276+ 4FF9 0C 0A 0A 0A          defb %00001100,%00001010,%00001010,%00001010,%00001000,%00011000,%00111000,%00010000 ; char 247 (note)
 276+ 4FFD 08 18 38 10
 277+ 5001 12 31 F5 F5          defb %00010010,%00110001,%11110101,%11110101,%11110101,%11110101,%00110001,%00010010 ; char 248 (audio on)
 277+ 5005 F5 F5 31 12
 278+ 5009 10 30 F0 F0          defb %00010000,%00110000,%11110000,%11110000,%11110000,%11110000,%00110000,%00010000 ; char 249 (audio off)
 278+ 500D F0 F0 30 10
 279+ 5011 40 60 70 78          defb %01000000,%01100000,%01110000,%01111000,%01111100,%01111110,%01111000,%01001000 ; char 250 (pointer)
 279+ 5015 7C 7E 78 48
 280+ 5019 3C 42 99 A1          defb %00111100,%01000010,%10011001,%10100001,%10100001,%10011001,%01000010,%00111100 ; char 251 (Â©)
 280+ 501D A1 99 42 3C
 281+ 5021 18 24 20 78          defb %00011000,%00100100,%00100000,%01111000,%00100000,%00100010,%01011100,%00000000 ; char 252 (Â£)
 281+ 5025 20 22 5C 00
 282+ 5029 3C 42 78 24          defb %00111100,%01000010,%01111000,%00100100,%00100100,%00011110,%01000010,%00111100 ; char 253 (Â§)
 282+ 502D 24 1E 42 3C
 283+ 5031 00 00 10 00          defb %00000000,%00000000,%00010000,%00000000,%01111100,%00000000,%00010000,%00000000 ; char 254 (Ã·)
 283+ 5035 7C 00 10 00
 284+ 5039 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 255 (cursor)
 284+ 503D FF FF FF FF
 285+ 5041
# file closed: ../include/vdp/8x8fonts-r18.asm
  87  5041                  INCLUDE "../include/vdp/logo-fonts.asm"
# file opened: ../include/vdp/logo-fonts.asm
   1+ 5041              ; ------------------------------------------------------------------------------
   2+ 5041              ; LM80C - LOGO CHARSET - R1.1
   3+ 5041              ; ------------------------------------------------------------------------------
   4+ 5041              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 5041              ; designed by Leonardo Miliani. More info at
   6+ 5041              ; www DOT leonardomiliani DOT com
   7+ 5041              ; ------------------------------------------------------------------------------
   8+ 5041              ; Code Revision:
   9+ 5041              ; R1.0 - 20200124 - First revision: logo chars
  10+ 5041              ; R1.1 - 20200229 - Adopted usual hexadecimal & binary prefixes
  11+ 5041              ; ------------------------------------------------------------------------------
  12+ 5041
  13+ 5041              LOGOFONT:   equ $
  14+ 5041 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; 0
  14+ 5045 00 00 00 00
  15+ 5049 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; 1
  15+ 504D FF FF FF FF
  16+ 5051 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; 2
  16+ 5055 00 00 00 00
  17+ 5059 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; 3
  17+ 505D 0F 0F 0F 0F
  18+ 5061 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; 4
  18+ 5065 FF FF FF FF
  19+ 5069 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; 5
  19+ 506D F0 F0 F0 F0
  20+ 5071 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; 6
  20+ 5075 0F 0F 0F 0F
  21+ 5079 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; 7
  21+ 507D F0 F0 F0 F0
  22+ 5081 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; 8
  22+ 5085 00 00 00 00
  23+ 5089 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; 9
  23+ 508D 00 00 00 00
  24+ 5091 00 00 00 FC              defb %00000000,%00000000,%00000000,%11111100,%11111111,%00000111,%00000011,%00000000 ; 10
  24+ 5095 FF 07 03 00
  25+ 5099 00 00 00 3F              defb %00000000,%00000000,%00000000,%00111111,%11111111,%11100000,%11000000,%00000000 ; 11
  25+ 509D FF E0 C0 00
  26+ 50A1 18 18 1F 19              defb %00011000,%00011000,%00011111,%00011001,%00011001,%00011111,%00011000,%00011000 ; 12
  26+ 50A5 19 1F 18 18
  27+ 50A9 18 18 F8 98              defb %00011000,%00011000,%11111000,%10011000,%10011000,%11111000,%00011000,%00011000 ; 13
  27+ 50AD 98 F8 18 18
  28+ 50B1 18 18 1C 1F              defb %00011000,%00011000,%00011100,%00011111,%00001111,%00000000,%00000000,%00000000 ; 14
  28+ 50B5 0F 00 00 00
  29+ 50B9 00 00 00 0F              defb %00000000,%00000000,%00000000,%00001111,%00011111,%00011100,%00011000,%00011000 ; 15
  29+ 50BD 1F 1C 18 18
  30+ 50C1 00 00 00 F0              defb %00000000,%00000000,%00000000,%11110000,%11111000,%00111000,%00011000,%00011000 ; 16
  30+ 50C5 F8 38 18 18
  31+ 50C9 18 18 38 F8              defb %00011000,%00011000,%00111000,%11111000,%11110000,%00000000,%00000000,%00000000 ; 17
  31+ 50CD F0 00 00 00
  32+ 50D1 00 00 00 FF              defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; 18
  32+ 50D5 FF 00 00 00
  33+ 50D9 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%11111111,%11111111,%11111111,%11111111 ; 19
  33+ 50DD FF FF FF FF
  34+ 50E1 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11111111,%11111111,%11111111,%11111111 ; 20
  34+ 50E5 FF FF FF FF
  35+ 50E9 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11110000,%11110000,%11110000,%11110000 ; 21
  35+ 50ED F0 F0 F0 F0
  36+ 50F1 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00001111,%00001111,%00001111,%00001111 ; 22
  36+ 50F5 0F 0F 0F 0F
  37+ 50F9 00 30 78 78              defb %00000000,%00110000,%01111000,%01111000,%00110000,%00000000,%00000000,%00000000 ; 23
  37+ 50FD 30 00 00 00
  38+ 5101
# file closed: ../include/vdp/logo-fonts.asm
  88  5101
  89  5101              ; include ROM/RAM switcher
  90  5101                  INCLUDE "../include/switcher/switcher-r11.asm"
# file opened: ../include/switcher/switcher-r11.asm
   1+ 5101              ; ------------------------------------------------------------------------------
   2+ 5101              ; LM80C - ROM/RAM SWITCHER - R1.1
   3+ 5101              ; ------------------------------------------------------------------------------
   4+ 5101              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 5101              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 5101              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 5101              ; kind of warranty: you can use them at your own risk.
   8+ 5101              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 5101              ; maintain the copyright notices, include this advice and the note to the
  10+ 5101              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 5101              ; redistribuite them.
  12+ 5101              ; https://www.leonardomiliani.com
  13+ 5101              ;
  14+ 5101              ; Please support me by visiting the following links:
  15+ 5101              ; Main project page: https://www.leonardomiliani.com
  16+ 5101              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 5101              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 5101              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 5101              ; ------------------------------------------------------------------------------
  20+ 5101              ; Code Revision:
  21+ 5101              ; R1.0   - 20200718 - First version
  22+ 5101              ; R1.1   - 20200827 - PIO settings now are part of the file
  23+ 5101              ;-------------------------------------------------------------------------------
  24+ 5101
  25+ 5101              TMP_FW_LOC:     equ     $8000           ; address from where to make a temporary copy of the FW
  26+ 5101              ;-------------------------------------------------------------------------------
  27+ 5101              ; THIS CODE WILL BE EXECUTED FROM RAM
  28+ 5101 3E FC        RAMRUN:         ld      A,%11111100     ; set ROM off and RAM on..
  29+ 5103 D3 01                        out     (PIO_DB),A      ; ...by setting bit #0 to 0 (and leave VRAM bank #0)
  30+ 5105 01 45 51                     ld      BC,END_OF_FW    ; let's copy back FW into low RAM - bytes to copy
  31+ 5108 21 00 80                     ld      HL,TMP_FW_LOC   ; source address
  32+ 510B 11 00 00                     ld      DE,$0000        ; dest. address
  33+ 510E ED B0                        ldir                    ; copy!
  34+ 5110 AF                           xor     A
  35+ 5111 D3 01                        out     (PIO_DB),A      ; all LEDs off - finished copying
  36+ 5113 C3 AE 02                     jp      INIT_HW         ; return control to old init (now into RAM)
  37+ 5116
  38+ 5116              ;-------------------------------------------------------------------------------
  39+ 5116              ; copy the whole contents of ROM into RAM then disable the first memory
  40+ 5116 3A A2 51     ROM2RAM:        ld      A,(basicStarted); check if BASIC is already started
  41+ 5119 FE 59                        cp      'Y'             ; to see if this is a power-up
  42+ 511B 20 0F                        jr      NZ,CNTCP2RAM    ; no, continue copy to RAM
  43+ 511D                              ; WARNING: Do **NOT** change the following "out()" sequence, ABSOLUTELY!
  44+ 511D 3E CF                        ld      A,%11001111     ; set mode 3 ("control mode")
  45+ 511F D3 03                        out     (PIO_CB),A      ; for PIO port B
  46+ 5121 AF                           xor     A               ; set LEDs off, RAM on, VRAM on bank #0
  47+ 5122 D3 01                        out     (PIO_DB),A      ; send settings to PIO register
  48+ 5124 D3 03                        out     (PIO_CB),A      ; set pins following register's status
  49+ 5126 21 D4 52                     ld      HL,TEMPSTACK    ; temporary stack
  50+ 5129 C3 B1 02                     jp      INIT_HW2        ; jump to re-init HW
  51+ 512C
  52+ 512C                              ; WARNING: Do **NOT** change the following "out()" sequence, ABSOLUTELY!
  53+ 512C 3E CF        CNTCP2RAM:      ld      A,%11001111     ; set mode 3 (mode control)
  54+ 512E D3 03                        out     (PIO_CB),A      ; for PIO port B
  55+ 5130 3E FD                        ld      A,%11111101     ; set pin #0 as HIGH to enable ROM
  56+ 5132 D3 01                        out     (PIO_DB),A      ; store the value into the internal register
  57+ 5134 AF                           xor     A               ; set pins to OUTPUT
  58+ 5135 D3 03                        out     (PIO_CB),A      ; for port B, activating the RAM
  59+ 5137 01 45 51                     ld      BC,END_OF_FW    ; copy FW from ROM to high RAM
  60+ 513A 21 00 00                     ld      HL,$0000        ; source address
  61+ 513D 11 00 80                     ld      DE,TMP_FW_LOC   ; dest. address
  62+ 5140 ED B0                        ldir                    ; copy!
  63+ 5142 C3 01 D1                     jp      RAMRUN+TMP_FW_LOC; jump to execute code into RAM
  64+ 5145
  65+ 5145              ;-------------------------------------------------------------------------------
  66+ 5145              END_OF_FW:      equ     $   ; this is the last cell of the firmware
# file closed: ../include/switcher/switcher-r11.asm
  91  5145
  92  5145              ; include workspace equates
  93  5145                  INCLUDE "../include/workspace/workspace-r1.0.asm"
# file opened: ../include/workspace/workspace-r1.0.asm
   1+ 5145              ; ------------------------------------------------------------------------------
   2+ 5145              ; LM80C 64K - WORKSPACE EQUATES - R1.0
   3+ 5145              ; ------------------------------------------------------------------------------
   4+ 5145              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 5145              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 5145              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 5145              ; kind of warranty: you can use them at your own risk.
   8+ 5145              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 5145              ; maintain the copyright notices, include this advice and the note to the
  10+ 5145              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 5145              ; redistribuite them.
  12+ 5145              ; https://www.leonardomiliani.com
  13+ 5145              ;
  14+ 5145              ; Please support me by visiting the following links:
  15+ 5145              ; Main project page: https://www.leonardomiliani.com
  16+ 5145              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 5145              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 5145              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 5145              ; ------------------------------------------------------------------------------
  20+ 5145
  21+ 5145              ; set starting of RAM based on computer model
  22+ 5145                  IFDEF LM80C64K
  23+ 5145              SERBUF_START    equ     END_OF_FW       ; RAM starts here
  24+ 5145                  ELSE
  25+ 5145 ~            SERBUF_START    equ     $8000           ; RAM starts here
  26+ 5145                  ENDIF
  27+ 5145
  28+ 5145              ;-------------------------------------------------------------------------------
  29+ 5145              serInPtr        equ     SERBUF_START + SER_BUFSIZE
  30+ 5145              serRdPtr        equ     serInPtr+2
  31+ 5145              serBufUsed      equ     serRdPtr+2
  32+ 5145              basicStarted    equ     serBufUsed+1
  33+ 5145              bufWrap         equ     (SERBUF_START + SER_BUFSIZE) & $FF
  34+ 5145              TEMPSTACK       equ     CURPOS - 3      ; top of BASIC line input buffer so is "free ram" when BASIC resets
  35+ 5145
  36+ 5145              ; BASIC WORK SPACE LOCATIONS
  37+ 5145              ; THE INTERPRETER ALLOCATES THE FOLLOWING RAM CELLS
  38+ 5145              ; TO STORE IMPORTANT VALUES USED FOR SOME SPECIFIC FUNCTIONS:
  39+ 5145              ; THEY CAN BE VECTOR (ADDRESSES) FUNCTIONS, SYSTEM DATAS (I.E. VARIABLES)
  40+ 5145              ; AND SO ON. THE FIRST CELLS ARE FILLED WITH VALUES STORED INTO ROM AT $(INITAB) ADDRESS
  41+ 5145              WRKSPC          equ     basicStarted+$01; (3) BASIC Work space
  42+ 5145              NMIUSR          equ     WRKSPC+$03      ; (3) NMI exit point routine
  43+ 5145              USR             equ     NMIUSR+$03      ; (3) "USR (x)" jump  <-- in (USR+$01)/(USR+$02) the user can store the address of a specific machine language routine
  44+ 5145              OUTSUB          equ     USR+$03         ; (1) "out p,n"
  45+ 5145              OTPORT          equ     OUTSUB+$01      ; (2) Port (p)
  46+ 5145              DIVSUP          equ     OTPORT+$02      ; (1) Division support routine
  47+ 5145              DIV1            equ     DIVSUP+$01      ; (4) <- Values
  48+ 5145              DIV2            equ     DIV1+$04        ; (4) <-   to
  49+ 5145              DIV3            equ     DIV2+$04        ; (3) <-   be
  50+ 5145              DIV4            equ     DIV3+$03        ; (2) <-inserted
  51+ 5145              SEED            equ     DIV4+$02        ; (35) Random number seed  <-- starting address of a seed table
  52+ 5145              LSTRND          equ     SEED+$23        ; (4) Last random number
  53+ 5145              INPSUB          equ     LSTRND+$04      ; (1) INP A,(x) Routine
  54+ 5145              INPORT          equ     INPSUB+$01      ; (2) PORT (x)
  55+ 5145              LWIDTH          equ     INPORT+$02      ; (1) Terminal width
  56+ 5145              COMMAN          equ     LWIDTH+$01      ; (1) Width for commas
  57+ 5145              NULFLG          equ     COMMAN+$01      ; (1) Null after input byte flag
  58+ 5145              CTLOFG          equ     NULFLG+$01      ; (1) Control "O" flag
  59+ 5145              CHKSUM          equ     CTLOFG+$01      ; (2) Array load/save check sum
  60+ 5145              NMIFLG          equ     CHKSUM+$02      ; (1) Flag for NMI break routine
  61+ 5145              BRKFLG          equ     NMIFLG+$01      ; (1) Break flag
  62+ 5145              RINPUT          equ     BRKFLG+$01      ; (3) Input reflection
  63+ 5145              STRSPC          equ     RINPUT+$03      ; (2) Pointer to bottom (start) of string space - default is 100 bytes below the top of memory
  64+ 5145              LINEAT          equ     STRSPC+$02      ; (2) Current line number. -1 means "direct mode", while -2 means cold start.
  65+ 5145              HLPLN           equ     LINEAT+$02      ; (2) Current line with errors
  66+ 5145              KEYDEL          equ     HLPLN+$02       ; (1) delay before key auto-repeat starts
  67+ 5145              AUTOKE          equ     KEYDEL+$01      ; (1) delay for key auto-repeat
  68+ 5145              FNKEYS          equ     AUTOKE+$01      ; (128) default text of FN keys
  69+ 5145              BASTXT          equ     FNKEYS+$80      ; (3) Pointer to start of BASIC program in memory
  70+ 5145              ; - - - - - - - - - - - - - - - - - - -   the above are locations pre-filled by the firmware at startup
  71+ 5145              BUFFER          equ     BASTXT+$03      ; (5) Input buffer
  72+ 5145              STACK           equ     BUFFER+$05      ; (85) Initial stack
  73+ 5145              CURPOS          equ     STACK+$55       ; (1) Character position on line
  74+ 5145              LCRFLG          equ     CURPOS+$01      ; (1) Locate/Create flag for DIM statement
  75+ 5145              TYPE            equ     LCRFLG+$01      ; (1) Data type flag: 0=numeric, non-zero=string
  76+ 5145              DATFLG          equ     TYPE+$01        ; (1) Literal statement flag
  77+ 5145              LSTRAM          equ     DATFLG+$01      ; (2) Last available RAM location usable by BASIC
  78+ 5145              TMSTPT          equ     LSTRAM+$02      ; (2) Temporary string pointer
  79+ 5145              TMSTPL          equ     TMSTPT+$02      ; (12) Temporary string pool
  80+ 5145              TMPSTR          equ     TMSTPL+$0C      ; (4) Temporary string
  81+ 5145              STRBOT          equ     TMPSTR+$04      ; (2) Bottom of string space
  82+ 5145              CUROPR          equ     STRBOT+$02      ; (2) Current operator in EVAL
  83+ 5145              LOOPST          equ     CUROPR+$02      ; (2) First statement of loop
  84+ 5145              DATLIN          equ     LOOPST+$02      ; (2) Line of current DATA item
  85+ 5145              FORFLG          equ     DATLIN+$02      ; (1) "FOR" loop flag
  86+ 5145              LSTBIN          equ     FORFLG+$01      ; (1) Last byte entered
  87+ 5145              READFG          equ     LSTBIN+$01      ; (1) Read/Input flag
  88+ 5145              BRKLIN          equ     READFG+$01      ; (2) Line of break
  89+ 5145              NXTOPR          equ     BRKLIN+$02      ; (2) Next operator in EVAL
  90+ 5145              ERRLIN          equ     NXTOPR+$02      ; (2) Line of error
  91+ 5145              CONTAD          equ     ERRLIN+$02      ; (2) Where to CONTinue
  92+ 5145              TMRCNT          equ     CONTAD+$02      ; (4) TMR counter for 1/100 seconds
  93+ 5145              CTC0IV          equ     TMRCNT+$04      ; (3) CTC0 interrupt vector
  94+ 5145              CTC1IV          equ     CTC0IV+$03      ; (3) CTC1 interrupt vector
  95+ 5145              CTC2IV          equ     CTC1IV+$03      ; (3) CTC2 interrupt vector
  96+ 5145              CTC3IV          equ     CTC2IV+$03      ; (3) CTC3 interrupt vector
  97+ 5145              ; - - - - - - - - - - - - - - - - - - -   VIDEO REGISTERS - FROM HERE...
  98+ 5145              SCR_SIZE_W      equ     CTC3IV+$03      ; (1) screen width (it can be either 40 chars or 32 chars/bytes)
  99+ 5145              SCR_SIZE_H      equ     SCR_SIZE_W+$01  ; (1) screen height (it can be 24/48/192: 24 for text, 48 for MC, 192 for graphics)
 100+ 5145              SCR_MODE        equ     SCR_SIZE_H+$01  ; (1) screen mode (0=text, 1=G1, 2=G2, 3=MC, 4=ExG2)
 101+ 5145              SCR_NAM_TB      equ     SCR_MODE+$01    ; (2) video name table address
 102+ 5145              SCR_CURS_X      equ     SCR_NAM_TB+$02  ; (1) cursor X
 103+ 5145              SCR_CURS_Y      equ     SCR_CURS_X+$01  ; (1) cursor Y
 104+ 5145              SCR_CUR_NX      equ     SCR_CURS_Y+$01  ; (1) new cursor X position
 105+ 5145              SCR_CUR_NY      equ     SCR_CUR_NX+$01  ; (1) new cursor Y position
 106+ 5145              SCR_ORG_CHR     equ     SCR_CUR_NY+$01  ; (1) original char positioned under the cursor
 107+ 5145              CRSR_STATE      equ     SCR_ORG_CHR+$01 ; (1) state of cursor (1=on, 0=off)
 108+ 5145              LSTCSRSTA       equ     CRSR_STATE+$01  ; (1) last cursor state
 109+ 5145              PRNTVIDEO       equ     LSTCSRSTA+$01   ; (1) print on video buffer (1=on / 0=off) set to off on graphic only modes
 110+ 5145              CHR4VID         equ     PRNTVIDEO+$01   ; (1) char for video buffer
 111+ 5145              FRGNDCLR        equ     CHR4VID+$01     ; (1) foreground color as set by SCREEN or COLOR commands
 112+ 5145              BKGNDCLR        equ     FRGNDCLR+$01    ; (1) background color as set by SCREEN or COLOR commands
 113+ 5145              TMPBFR1         equ     BKGNDCLR+$01    ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 114+ 5145              TMPBFR2         equ     TMPBFR1+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 115+ 5145              TMPBFR3         equ     TMPBFR2+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 116+ 5145              TMPBFR4         equ     TMPBFR3+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 117+ 5145              VIDEOBUFF       equ     TMPBFR4+$02     ; (40) buffer used for video scrolling and other purposes
 118+ 5145              VIDTMP1         equ     VIDEOBUFF+$28   ; (2) temporary video word
 119+ 5145              VIDTMP2         equ     VIDTMP1+$02     ; (2) temporary video word
 120+ 5145              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO VPD OUT OF THIS RANGE,
 121+ 5145                                                      ; OTHERWISE YOU WILL HAVE TO CHECK THE POINTER IN "CLR_RAM_REG" FUNCTION
 122+ 5145              ; - - - - - - - - - - - - - - - - - - -   SOUND & KEYBOARD REGISTERS - FROM HERE...
 123+ 5145              CHASNDDTN       equ     VIDTMP2+$02     ; (2) sound Ch.A duration (in 1/100s)
 124+ 5145              CHBSNDDTN       equ     CHASNDDTN+$02   ; (2) sound Ch.B duration (in 1/100s)
 125+ 5145              CHCSNDDTN       equ     CHBSNDDTN+$02   ; (2) sound Ch.C duration (in 1/100s)
 126+ 5145              KBDNPT          equ     CHCSNDDTN+$02   ; (1) temp cell used to flag if input comes from keyboard
 127+ 5145              KBTMP           equ     KBDNPT+$01      ; (1) temp cell used by keyboard scanner
 128+ 5145              TMPKEYBFR       equ     KBTMP+$01       ; (1) temp buffer for last key pressed
 129+ 5145              LASTKEYPRSD     equ     TMPKEYBFR+$01   ; (1) last key code pressed
 130+ 5145              STATUSKEY       equ     LASTKEYPRSD+$01 ; (1) status key, used for auto-repeat
 131+ 5145              KEYTMR          equ     STATUSKEY+$01   ; (2) timer used for auto-repeat key
 132+ 5145              CONTROLKEYS     equ     KEYTMR+$02      ; (1) flags for control keys (bit#0=SHIFT; bit#1=CTRL; bit#2=C=)
 133+ 5145              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO PSG OUT OF THIS RANGE,
 134+ 5145                                                      ; OTHERWISE YOU WILL HAVE TO CHANGE THE POINTER IN "initPSG" FUNCTION
 135+ 5145              SERIALS_EN      equ     CONTROLKEYS+$01 ; (1) serial ports status: bit 0 for Port1 (A), bit 1 for Port2 (B): 0=OFF, 1=ON
 136+ 5145              SERABITS        equ     SERIALS_EN+$01  ; (1) serial port A data bits
 137+ 5145              SERBBITS        equ     SERABITS+$01    ; (1) serial port B data bits
 138+ 5145              DOS_EN          equ     SERBBITS+$01    ; (1) DOS enable/disable (1/0)
 139+ 5145              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 140+ 5145                                                      ; from here there are the RAM locations that
 141+ 5145                                                      ; are saved during SAVE
 142+ 5145              PROGND          equ     DOS_EN+$01      ; (2) End of program
 143+ 5145              VAREND          equ     PROGND+$02      ; (2) End of variables
 144+ 5145              ARREND          equ     VAREND+$02      ; (2) End of arrays
 145+ 5145              NXTDAT          equ     ARREND+$02      ; (2) Next data item
 146+ 5145              FNRGNM          equ     NXTDAT+$02      ; (2) Name of FN argument
 147+ 5145              FNARG           equ     FNRGNM+$02      ; (4) FN argument value
 148+ 5145              FPREG           equ     FNARG+$04       ; (3) Floating point register
 149+ 5145              FPEXP           equ     FPREG+$03       ; (1) Floating point exponent
 150+ 5145              SGNRES          equ     FPEXP+$01       ; (1) Sign of result
 151+ 5145              PBUFF           equ     SGNRES+$01      ; (13) Number print buffer
 152+ 5145              MULVAL          equ     PBUFF+$0D       ; (3) Multiplier
 153+ 5145              PROGST          equ     MULVAL+$03      ; (100) Start of program text area
 154+ 5145              STLOOK          equ     PROGST+$64      ; Start of memory test
 155+ 5145
# file closed: ../include/workspace/workspace-r1.0.asm
  94  5145
  95  5145              ; END OF ASSEMBLY SOURCE
  96  5145              ;-------------------------------------------------------------------------------
  97  5145
# file closed: LM80C_64K-firmware-r1.05.asm

Value    Label
------ - -----------------------------------------------------------
0x018F   A_RTS_OFF
0x01AD   A_RTS_ON
0x2487   ABPASS
0x2ECF   ABS_
0x4003   absHL
0x1CA1 X ACCSUM
0x2486   ACPASS
0x3F03   ADD30
0x3F13   ADD301
0x2E68   ADDEXP
0x300E   ADDIG
0x0A26   ADDNEWLINE
0x2C04   ADDPHL
0x5324   ADRS1
0x5328   ADRS2
0x2755   ALLFOL
0x1FC2   ANTVLU
0x335F X ARET
0x2391   ARLDSV
0x536C   ARREND
0x2620   ARRLP
0x2726   ASC
0x2FB1   ASCTFP
0x1F1B   ASPCS
0x0670   ATHOME
0x3313   ATN
0x3330   ATN1
0x333A   ATNTAB
0x1CDC   ATOH
0x51F9   AUTOKE
0x15B7   AUTORP
0x0197   B_RTS_OFF
0x01B5 X B_RTS_ON
0x081A   BACKSPACE
0x1F3E   BADINP
0x1652   BAKSTK
0x2706   BAKTMP
0x51A2   basicStarted
0x527A   BASTXT
0x2EF6   BCDEFP
0x058F   BEEPOFF
0x12AD   BFREE
0x3F55   BIN
0x3F5B X BIN2
0x3FB2   BINERR
0x3F91   BINIT
0x3F87   BINTFP
0x3F6F   BITOUT
0x3F73   BITOUT2
0x3C61   BITS6
0x3C6B   BITS7
0x3C76   BITS8
0x5321   BKGNDCLR
0x0008   BKSP
0x12A4   BLNSPC
0x0028   BN
0x1177   BNMSG
0x2C64   BNORM
0x1025 X BNPTR
0x2C67   BNRMLP
0x532B   BPS
0x1C4F   BRK
0x51EE   BRKFLG
0x52FA   BRKLIN
0x164C   BRKMSG
0x1298   BRKRET
0x0010   BS
0x23C4   BSERR
0x10A6   BSMSG
0x100D X BSPTR
0x527D   BUFFER
0x009D   bufWrap
0x3EFA   BYT2ASC
0x2D9C   BYTSFT
0x2327   CFEVAL
0x028B   CH3_TIMER
0x015D   CHABFREMPTY
0x074B   CHAR2VID
0x01FD   CHARINTOBFR
0x22D5   CHARTY
0x5356   CHASNDDTN
0x5358   CHBSNDDTN
0x0870   CHCKYPOS
0x08DB   CHCKYPOS2
0x535A   CHCSNDDTN
0x0D62   CHECKALT
0x0D70   CHECKCTRL
0x0D7E   CHECKKBD
0x36C5   CHECKPA
0x36C6   CHECKPY
0x030F   CHECKWARM
0x251E   CHEKFN
0x0DF9   CHKALT
0x0E42   CHKAUTO
0x3FA4   CHKBIN
0x34E6   CHKCLR0
0x34E2   CHKCLR1
0x029A   CHKCRSR
0x0DF0   CHKCTRL
0x3EAC   CHKEY1
0x3EB1   CHKEY2
0x3EB4   CHKEY3
0x3EBA   CHKEY4
0x3EBD   CHKEY5
0x0E7A   CHKFNK
0x34EC   CHKG2M
0x07F6   CHKHL
0x2BE3   CHKINK
0x0DDC   CHKLN
0x1CAE   CHKLTR
0x342A   CHKSCAR
0x0CE7   CHKSNDCH
0x05BC   CHKSPCK
0x1686   CHKSTK
0x51EB   CHKSUM
0x19C3   CHKSYN
0x20A2   CHKTYP
0x0897   CHKYPOS
0x3B26   CHKZSER
0x2737   CHR
0x531F   CHR4VID
0x532C   CHRPNT
0x4041   CHRST68
0x4841   CHRST88
0x072D   CHRTBL
0x38F1   CIRCLE
0x3C14   CKBPS
0x35D2   CKCOL
0x0278   CKINCHAR
0x33DD   CKMAGN
0x1D01   CLEAR
0x0663   CLEARVIDBUF
0x1A0F   CLOTST
0x0ACC   CLR_RAM_REG
0x1825   CLREG
0x34A1   CLREX2
0x348F   CLRG1
0x3498   CLRG2
0x0605   CLRG2PTNTBL
0x3488   CLRMC
0x3AD8   CLRPRM
0x0C85   CLRPSGREGS
0x1800   CLRPTR
0x05B7   CLRTABLE
0x3485   CLRTXT
0x3AC0   CLRVDBF
0x3362   CLS
0x3E51   CLSQT
0x3E61   CLSQT1
0x3FDE   CMP16
0x2BBC   CMP_A
0x2F3F   CMPFP
0x223B   CMPLG1
0x2239   CMPLOG
0x2F25   CMPNUM
0x227D   CMPRES
0x2265   CMPSTR
0x0020   CN
0x1137   CNMSG
0x101D X CNPTR
0x282F   CNT1INS
0x0D22   CNTCHKSND
0x3457   CNTCKCL
0x39B3   CNTCL1
0x39D7   CNTCL2
0x39FB   CNTCL3
0x3A21   CNTCL4
0x3A43   CNTCL5
0x3A67   CNTCL6
0x3A8B   CNTCL7
0x512C   CNTCP2RAM
0x3894   CNTDRW
0x1EE3   CNTEND
0x0ED5   CNTFNK
0x3552   CNTGPT2
0x0E74   CNTKBCK
0x21FA   CNTLGC
0x3E17   CNTLTK
0x09DA   CNTNULL
0x0A58 X CNTNULL2
0x3743   CNTPLOT
0x3764   CNTPLT1
0x3B93   CNTRX2
0x0120   CNTRXCHA
0x3B64   CNTSER
0x3B9E   CNTSER2
0x3BB0   CNTSER3
0x3ABB   CNTVALY
0x1B4C   CNTWTSP
0x2866   CNTZIN
0x2FBD   CNVNUM
0x11E1   COLD
0x0304   COLDSTART
0x343A   COLOR
0x51E8   COMMAN
0x2CC4   COMPL
0x269B   CONCAT
0x2FED   CONEXP
0x2C61   CONPOS
0x1C88   CONT
0x070E   CONT_POS_CURS
0x5300   CONTAD
0x0881   CONTCRSLFT
0x08EE   CONTCRSRGT
0x5363   CONTROLKEYS
0x218D   CONVAR
0x02F8   CORW
0x3297   COS
0x19BD   CPDEHL
0x3DAE   CPKEY
0x3DCD   CPKEY1
0x3DBE   CPKEY2
0x3DC5   CPKEY3
0x3DD5   CPKYEND
0x1902   CPYLIT
0x000D   CR
0x23E4   CRARLP
0x23C9   CREARY
0x1E0E   CRESTR
0x09AC   CRGRETURN
0x1863   CRNCLP
0x001F   CRSDN
0x001C   CRSLFT
0x531C   CRSR_STATE
0x001D   CRSRGT
0x001E   CRSUP
0x2557   CRTMST
0x2563   CRTST
0x2579   CRTSTE
0x185A   CRUNCH
0x000C   CS
0x11EE   CSTART
0x5306   CTC0IV
0x5309   CTC1IV
0x530C   CTC2IV
0x530F   CTC3IV
0x3D10   CTC_CFG
0x0010   CTC_CH0
0x0011   CTC_CH1
0x0012   CTC_CH2
0x0013   CTC_CH3
0x036A   CTCCONF
0x51EA   CTLOFG
0x3709   CTPOINT
0x0003   CTRLC
0x0007   CTRLG
0x000F   CTRLO
0x0011   CTRLQ
0x0012   CTRLR
0x0013   CTRLS
0x0015   CTRLU
0x2A90   CTSNDC
0x5322   CUR_POS
0x52F1   CUROPR
0x52D7   CURPOS
0x092C   CURSOR_OFF
0x0917   CURSOR_ON
0x08F7   CURSORDOWN
0x085D   CURSORLEFT
0x08C2   CURSORRIGHT
0x08A9   CURSORUP
0x1DB5   DATA
0x532D   DATABT
0x52DA   DATFLG
0x52F5   DATLIN
0x16C3   DATSNR
0x5334   DC
0x2F76   DCBCDE
0x0012   DD
0x16D2   DDERR
0x10B4   DDMSG
0x100F X DDPTR
0x054D   DEC_D
0x3DA0   DECLN1
0x337E   DEEK
0x249B   DEF
0x15B9 X DEFFNKS
0x3BFB   DEFSER
0x23EC   DEFSIZ
0x1CC2   DEINT
0x007F   DEL
0x1932   DELCHR
0x1CBC   DEPINT
0x2F05   DETHL4
0x2F07   DETHLB
0x30B7   DIGTXT
0x22A7   DIM
0x229E   DIMRET
0x19F2   DINPOS
0x2DA1   DINT
0x33A9 X DIR_PAU
0x3D2C   DIRMOD
0x293E   DISNMI
0x2DFE   DIV
0x51B0   DIV1
0x2DF2   DIV10
0x51B4   DIV2
0x51B8   DIV3
0x51BB   DIV4
0x402C X DIV_16_16
0x401D   DIV_16_8
0x4020   DIV_16_8LP
0x400D   DIV_8_8
0x4011   DIV_8_8LOOP
0x2E25   DIVLP
0x51AF   DIVSUP
0x3975   DLSZ
0x183E   DOAGN
0x1EE8   DOCOM
0x1912   DODEL
0x30F7   DOEBIT
0x24C8   DOFN
0x3389   DOKE
0x5367   DOS_EN
0x1F16   DOSPC
0x1F01   DOTAB
0x2FE9   DPOINT
0x37BB   DRAW
0x3991   DRWCRL
0x2567   DTSTR
0x4031   DV16_16_LP
0x2E00   DVBCDE
0x5336   DX
0x38C4   DXGR
0x5338   DY
0x0014   DZ
0x16CC   DZERR
0x10C9   DZMSG
0x1011 X DZPTR
0x5330   E2
0x1926   ECHDEL
0x031C   ECHO_CHAR
0x3030   EDIGIT
0x27CE   EMPTINS
0x0C81   EMPTSNDBFR
0x0AC3   EMPTVRM
0x0AB9   EMPTY_VRAM
0x014F   EMPTYCHABFR
0x0181   EMPTYCHBBFR
0x05F4   EMPTYG2
0x0624   EMPTYMC
0x05CC   EMPTYVIDBUF
0x3CE5   ENCHB
0x5145   END_OF_FW
0x1909   ENDBUF
0x2FFC   ENDCON
0x398D   ENDCRL
0x0DC4   ENDCTRLCK
0x244B   ENDDIM
0x38ED   ENDDRAW
0x2BF5   ENDINK
0x2BFE X ENDINK2
0x1ECF   ENDINP
0x080C X ENDINSRT
0x22C9   ENDNAM
0x0A33   ENDOFLN
0x1C5E   ENDPRG
0x2460   ENDTMR
0x5326   ENDTXT
0x04E7   ENDVDPSET
0x168F   ENFMEM
0x532E   ER
0x3868   ER2
0x3EC3   ERASE
0x056C   ERASECLRTBL
0x1701   ERRIN
0x1C82   ERRINT
0x52FE   ERRLIN
0x163B   ERRMSG
0x16DD   ERROR
0x1031 X ERRORS
0x0FFD   ERRTBL
0x001B   ESC
0x20AF   EVAL
0x20B2   EVAL1
0x20BB   EVAL2
0x20BE   EVAL3
0x2174   EVLPAR
0x2287   EVNOT
0x1BEC   EXCUTE
0x04A5   EXG2MD
0x07A7   EXITCHAR2VID
0x092A   EXITCURSOR_ON
0x0914   EXITCURSORDOWN
0x0884   EXITCURSORLEFT
0x08F4   EXITCURSORRGHT
0x08C0   EXITCURSORUP
0x16A3   EXITGM
0x36C1   EXITPA2
0x36BD   EXITPAI
0x4001   EXMUL16
0x3CF3   EXNRM
0x3191   EXP
0x2FDB   EXPLP
0x31D1   EXPTAB
0x3109   EXPTEN
0x201E   EXTIG
0x2047   FANDT
0x0008   FC
0x1CD7   FCERR
0x106A   FCMSG
0x1005 X FCPTR
0x202E   FDTLP
0x3EC2   FILES
0x2427   FINDEL
0x0DDA   FINDKEY
0x07B5   FLASHCURSOR
0x2EB5   FLGDIF
0x2EBC   FLGREL
0x00EC   FMVEREND
0x5372   FNARG
0x1307   FNCTAB
0x2397   FNDARY
0x242C   FNDELP
0x17D3   FNDEND
0x2920   FNDNUM
0x1B00   FNDTOK
0x230E   FNDVAR
0x188D   FNDWRD
0x51FA   FNKEYS
0x0EF5   FNKEYSORD
0x219E   FNOFST
0x5370   FNRGNM
0x231C   FNTHR
0x21CF   FNVAL
0x20E7   FOPRND
0x1B53   FOR
0x52F7   FORFLG
0x1B83   FORFND
0x1B67   FORSLP
0x2C13   FPADD
0x2EEB   FPBCDE
0x5379   FPEXP
0x2F52   FPINT
0x2D4E   FPMULT
0x5376   FPREG
0x2CAB   FPROND
0x1CB6   FPSINT
0x2F02   FPTHL
0x2465   FRE
0x2481   FRENUM
0x5320   FRGNDCLR
0x2190   FRMEVL
0x00D0 X FWVER
0x0420   G1MD
0x0460   G2MD
0x25E8   GARBGE
0x25EB   GARBLP
0x1C0C   GETCHR
0x1730   GETCMD
0x3F30   GETHEX
0x3360   GETINP
0x2923   GETINT
0x271B   GETLEN
0x1943   GETLIN
0x1CDD   GETLN
0x209D   GETNUM
0x18A8   GETNXT
0x26E5   GETSTR
0x22AC   GETVAR
0x002A   GM
0x3AF1   GMERR
0x1182   GMMSG
0x199A   GMNCR
0x1027 X GMPRT
0x261F   GNXARY
0x21D7   GOFUNC
0x1D61   GOSUB
0x1D72   GOTO
0x35B5   GPCPCH1
0x35AB X GPCPCHR
0x3567   GPNT
0x3591   GPNTCO1
0x3587 X GPNTCOL
0x34F5   GPRINT
0x263F   GRBARY
0x25C0   GRBDON
0x25F9   GRBLP
0x26E8   GSTRCU
0x26EC   GSTRDE
0x26EB   GSTRHL
0x272A X GTFLNM
0x22B1   GTFNAM
0x1CE0   GTLNLP
0x3081   GTSIXD
0x1F9A   GTVLUS
0x5326   GX
0x5328   GY
0x3128   HALF
0x32E1   HALFPI
0x3D38   HELP
0x3EC4   HEX
0x3EDC   HEX1
0x3EDE   HEX2
0x3EEB   HEX3
0x3EED   HEX4
0x3F47   HEXIT
0x3F23   HEXLP
0x3F28   HEXLP1
0x3F17   HEXTFP
0x071C   HL2XY
0x3D4E   HLPERR
0x51F6   HLPLN
0x0019   HOME
0x0032   HP
0x11D7   HPMSG
0x102F X HPPTR
0x0026 X HX
0x3F50   HXERR
0x116C   HXMSG
0x1023 X HXPTR
0x0016   ID
0x10DA   IDMSG
0x1013 X IDPTR
0x2510   IDTEST
0x1E44   IF
0x1E5B   IF0
0x1E64   IF1
0x1E52   IFGO
0x1BF3   IFJMP
0x2F00   INCHL
0x19EE   INCLEN
0x0294   INCTMR3
0x166C   INDFND
0x179B   INEWLN
0x11F5   INIT
0x02AE   INIT_HW
0x02B1   INIT_HW2
0x1562   INITAB
0x163B   INITBE
0x0340   initCTC
0x0C7B   initPSG
0x3FC9   INITST
0x03D1   initVDP
0x2BB1   INKEY
0x2BCB   INKEY2
0x1642   INMSG
0x28E0   INP
0x1FEC   INPBIN
0x1C5B   INPBRK
0x51E5   INPORT
0x51E4   INPSUB
0x1F4F   INPUT
0x308A   INRNG
0x07D8   INSERTKEY
0x001A   INSRT
0x2777   INSTR
0x2F7D   INT
0x180F   INTVAR
0x2ED3   INVSGN
0x1FDD   ITMSEP
0x3113   JSTZER
0x535C   KBDNPT
0x0EFD   KBMAP
0x0F7D   KBMAP_ALT
0x0FBD   KBMAP_CTRL
0x0F3D   KBMAP_SFT
0x535D   KBTMP
0x3D53   KEY
0x0D42   KEYBOARD
0x3D70   KEYCH
0x51F8   KEYDEL
0x5361   KEYTMR
0x208D   KILFOR
0x193D   KILIN
0x535F   LASTKEYPRSD
0x52D8   LCRFLG
0x04DE   LDCLRTBEX2
0x0457   LDCLRTBMD1
0x05E5   LDCOLSTOEMPTY
0x0EC1   LDFNKEYCHR
0x16B0   LDG1
0x16C1   LDG1ND
0x3E02   LDKEY
0x0AE9   LDREGVLS
0x2747   LEFT
0x2717   LEN
0x1DCC   LET
0x1E1F   LETNUM
0x1DE7   LETSTR
0x000A   LF
0x28D6   LFRGNM
0x51F4   LINEAT
0x303C   LINEIN
0x1784   LINFND
0x1A2A   LIST
0x1ABD   LISTLP
0x0B3B   LM80CLOGO
0x5322   LNS1
0x5326   LNS2
0x3EC0   LOAD
0x06F9   LOAD_CRSR_POS
0x0AF3   LOADCHARSET
0x34A8   LOADCLR
0x2EF9   LOADFP
0x0597   LOADLOGOCHRS
0x0E00   LOADMAP
0x095D   LOADNEXTCOL
0x29F6   LOCATE
0x2D0D   LOG
0x5041   LOGOFONT
0x2D00   LOGTAB
0x1656   LOKFOR
0x52F3   LOOPST
0x001C   LS
0x110C   LSMSG
0x1019 X LSPTR
0x1A56   LST01
0x1A59   LST01H
0x1AB4   LST02
0x1A9D   LST03
0x1AB1   LST05
0x1A74   LST06
0x1AE2   LST07
0x1ADF   LST08
0x1A85   LSTALL
0x52F8   LSTBIN
0x531D   LSTCSRSTA
0x3DD7   LSTKEYS
0x1AEE   LSTLP2
0x1AF1   LSTLP3
0x1A78   LSTNOT
0x52DB   LSTRAM
0x51E0   LSTRND
0x1FF7   LTSTND
0x0854   LVBKSP
0x05CA   LVCKSPLK
0x285C   LVINSTR
0x0EA8 X LVKBRDCHK
0x0EA4   LVKBRDCHK2
0x0131   LVRXCHA
0x1B38   LVSRLN
0x51E7   LWIDTH
0x2926   MAKINT
0x30A6   MAKNUM
0x2FC5   MANLP
0x18DA   MATCH
0x0482   MCMD
0x12FC   MEMMSG
0x2877   MID
0x274D   MID1
0x28DB   MIDNUM
0x2C53   MINCDE
0x217C   MINUS
0x34D5   MIXCLRS
0x5322   MIXCOL
0x2554   MKTMST
0x2F9E   MLDBLP
0x2F96   MLDEBC
0x1226   MLOOP
0x3FF1   MLP
0x3FF8   MLP1
0x2E93   MLSP10
0x0CDD   MNGSNDS
0x1223   MNOASK
0x3642   MNPAINT
0x0024   MO
0x2DA9   MOD
0x115C   MOMSG
0x3FB7   MONOUT
0x1021 X MOPTR
0x2003   MORDT
0x194C   MORINP
0x17BA   MOVBUF
0x06C0   MOVCRS
0x18E2   MOVDIR
0x167B   MOVLP
0x06C6   MOVSHOWCRS
0x1678   MOVSTR
0x1675   MOVUP
0x1E72   MRPRNT
0x0376   MSGTXT1
0x03B4   MSGTXT2
0x1210   MSIZE
0x3FE9   MUL16
0x2D79   MUL8LP
0x2D45   MULLN2
0x2D4C   MULT
0x2D70   MULT8
0x3007   MULTEN
0x5388   MULVAL
0x0841   MVBKSP
0x0886   MVCRS2LFT
0x1E16   MVSTPT
0x1F96   NEDMOR
0x313E   NEGAFT
0x4006   negHL
0x17FF   NEW
0x06DB   NEWCRSRCOORD
0x0E54   NEWKEY
0x1F25   NEXITM
0x2052   NEXT
0x2055   NEXT1
0x0000   NF
0x16CF   NFERR
0x1031   NFMSG
0x0FFD X NFPTR
0x0000   NLLCR
0x294F   NM1
0x2934   NMI
0x2960   NMI2
0x296B   NMIDINT
0x2964   NMIEINT
0x51ED   NMIFLG
0x296E   NMIINT
0x51A6   NMIUSR
0x297A   NMIVR1
0x0CAF   NOBEEP
0x0CCB   NOBPDAT
0x18D2   NOCHNG
0x1261   NODOS
0x3116   NOENED
0x3784   NOGD
0x2B14   NOISUP
0x0DC8   NOKEYPRSD
0x1C71   NOLIN
0x2D8A   NOMADD
0x2FAC   NOMLAD
0x1F69   NOPMPT
0x2C7E   NORMAL
0x2B3E   NOS1
0x2B51   NOS2
0x2B6A   NOS3
0x18C9   NOSPC
0x3F43   NOSUB7
0x2C2D   NOSWAP
0x29AC   NOSYSPR
0x2151   NOTAMP
0x0208   NOTFULL
0x023F   NOTRDWRAP
0x22E4   NOTSTR
0x0214   NOTWRAP
0x2906   NOXOR
0x22F4   NSCFOR
0x51E9   NULFLG
0x304F   NUMASC
0x532E   NUMCHR
0x23AB   NXTARY
0x18B8   NXTBYT
0x0B07   NXTCHAR
0x18F9   NXTCHR
0x076B   NXTCPCK
0x536E   NXTDAT
0x1DB4   NXTDTA
0x0807   NXTINST
0x1F8E   NXTITM
0x1B18   NXTLN
0x3623   NXTLOOP
0x52FC   NXTOPR
0x1DBB   NXTSTL
0x1DBE   NXTSTT
0x0006   OD
0x105E   ODMSG
0x1003 X ODPTR
0x1647   OKMSG
0x000C   OM
0x169E   OMERR
0x1089   OMMSG
0x1009 X OMPTR
0x1E26   ON
0x1E35   ONGO
0x1E36   ONGOLP
0x1BF4   ONJMP
0x20AB   OPNPAR
0x3E63   OPNQT
0x3E79   OPNQT1
0x2126   OPRND
0x532E   ORGSP
0x001A   OS
0x10F8   OSMSG
0x1017 X OSPTR
0x193A   OTKLN
0x51AD   OTPORT
0x19CE   OUTC
0x3107   OUTEXP
0x19B4   OUTIT
0x19B7   OUTNBS
0x3FD8   OUTNCR
0x51AC   OUTSUB
0x1B0A   OUTWRD
0x000A   OV
0x16D8   OVERR
0x1080   OVMSG
0x1007 X OVPTR
0x2E86   OVTST1
0x2E8B   OVTST2
0x2E8C   OVTST3
0x302B   PADD
0x35E5   PAINT
0x3630   PAINT0
0x363F   PAINT1
0x363E   PAINT11
0x3672   PAINT2
0x3685   PAINT3
0x36A4   PAINT4
0x36B6   PAINT5
0x21F0   PAND
0x2215 X PAND1
0x532E   PARBT
0x2496   PASSA
0x33A0   PAUSE
0x537B   PBUFF
0x29BC   PEEK
0x1C56   PEND
0x2EE8   PHLTFP
0x0002 X PIO_CA
0x0003   PIO_CB
0x0000 X PIO_DA
0x0001   PIO_DB
0x29D0   PKEPRMS
0x07B4   PLACEHOLDER
0x3728   PLOT
0x3984   PLTCRL
0x2CB8   PLUCDE
0x2C86   PNORM
0x532A   PNT
0x0EA1   PNT2VD
0x36FF   PNTEND
0x371D   PNTRTN
0x36D5   POINT
0x29E6   POKE
0x25DA   POPAF
0x2704   POPHL
0x2D9A   POPHRT
0x1722   POPNOK
0x21F3   POR
0x221A   POR1
0x2493   POS
0x06B6   POS_CURSOR
0x0A59   POS_TB_CRS_32
0x0A89   POS_TB_CRS_40
0x1CB9 X POSINT
0x28EC   POUT
0x314C   POWER
0x315C   POWER1
0x3179   POWER2
0x312C   POWERS
0x1E76   PRINT
0x1544   PRITAB
0x1ED9   PRNTCRLF
0x0EE8   PRNTFNK
0x0EA9   PRNTFNKEY
0x3044   PRNTHL
0x1E79   PRNTLP
0x1EBC   PRNTNB
0x1723   PRNTOK
0x0A12   PRNTRETURN
0x1EC0   PRNTST
0x531E   PRNTVIDEO
0x25A4   PRNUMS
0x1965   PROCES
0x5368   PROGND
0x538B   PROGST
0x1842   PROMPT
0x25A5   PRS
0x25A8   PRS1
0x25AF   PRSLP
0x3E2C   PRTCHR
0x3E7B   PRTCKEY
0x3E88   PRTEND
0x3E7C   PRTK1
0x3DEB X PRTK2
0x3E14   PRTK3
0x3DE9   PRTK4
0x532A   PRTNUM
0x0041   PSG_DAT
0x0040   PSG_REG
0x2C0E   PSUB
0x532A   PT
0x532C   PT1
0x532E   PT2
0x3E49   PTCHR1
0x171E   PTLN
0x17C7   PTRLP
0x19A0   PUTBUF
0x0E94   PUTCHRBUF
0x0EDB   PUTCHRBUF1
0x07D4   PUTCRSCHR
0x19A5   PUTCTL
0x1BC8   PUTFID
0x3788   PXLSET
0x21F8   PXOR
0x2222   PXOR1
0x256A   QTSTLP
0x2564   QTSTR
0x32E5   QUARTR
0x532E   RADIUS
0x5101   RAMRUN
0x027D   RAWPRINT
0x1F89   READ
0x067A   READ_VIDEO_LOC
0x06AF   READ_VSTAT
0x52F9   READFG
0x0D2D   READKBLN
0x3383 X RECWRD
0x1F2C   REDO
0x1DB7   REM
0x2E38   RESDIV
0x3283   RESEED
0x3FBA   RESET
0x3D60   RESFN
0x0365   RESTMR
0x1C31   RESTNL
0x1C1C   RESTOR
0x2C79   RESZER
0x235B   RETADR
0x2EC1   RETINT
0x1DAF   RETLIN
0x18DE   RETNAD
0x235E   RETNUL
0x2188   RETNUM
0x2EB3   RETREL
0x1D90   RETURN
0x0004   RG
0x1049   RGMSG
0x1001 X RGPTR
0x286D   RIGHT
0x274B   RIGHT1
0x51EF   RINPUT
0x20CB   RLTLP
0x3222   RND
0x325E   RND1
0x327A   RND2
0x328B   RNDTAB
0x3119   RNGTST
0x5116   ROM2RAM
0x2C9A   RONDB
0x2C99   RONDUP
0x2C01   ROUND
0x2806   RP2INST
0x357C   RPGPNT
0x0579   RPT100
0x051A   RPT101
0x051D   RPT102
0x0533   RPT103
0x053B   RPT104
0x3948   RPTCL1
0x075E   RPTCPCK
0x3935   RPTCRL
0x3AC8   RPTCVB1
0x3AD1   RPTCVB2
0x3878   RPTDRW
0x05EB   RPTEMPTYBUF
0x09A0   RPTEMPTYROW
0x0650   RPTFLL1
0x27DF   RPTINST
0x0D82   RPTKBDRD
0x34B1   RPTLDCL
0x09CA   RPTNLLSRC
0x0A4B   RPTNLLSRC2
0x33AE   RPTPS
0x3B37   RPTRSSR
0x0CB5   RPTWLCMBP
0x2A6B   RPVOLCG
0x3025   RSCALE
0x0000 X RST00
0x0008 X RST08
0x0010 X RST10
0x0018 X RST18
0x06F0   RSTCHRCRS
0x0C8C   RSTPSG
0x3B2A   RSTSERS
0x2890   RSTSTR
0x0AD2   RSTVDPRAMREG
0x1D4D   RUN
0x1BCC   RUNCNT
0x180B   RUNFST
0x1D71   RUNLIN
0x0100   RX_CHA_AVAIL
0x0165   RX_CHB_AVAIL
0x022A   RXA
0x0255   RXA_EXIT
0x3B9A   RXEND
0x2851   RZINSTR
0x002E   SA
0x11A8   SAMSG
0x102B X SAPTR
0x3EC1   SAVE
0x2C7A   SAVEXP
0x1BBF   SAVSTP
0x253F   SAVSTR
0x2369   SBSCPT
0x002C   SC
0x2CD8   SCALE
0x2CDA   SCALLP
0x2FF0   SCALMI
0x3006   SCALPL
0x3D1F   SCERR
0x3D1B   SCERR1
0x1193   SCMSG
0x2676   SCNEND
0x236F   SCPTLP
0x1029 X SCPTR
0x5319   SCR_CUR_NX
0x531A   SCR_CUR_NY
0x5317   SCR_CURS_X
0x5318   SCR_CURS_Y
0x5314   SCR_MODE
0x5315   SCR_NAM_TB
0x531B   SCR_ORG_CHR
0x5313   SCR_SIZE_H
0x5312   SCR_SIZE_W
0x33BF   SCREEN
0x094B   SCROLLNXTRW
0x0933   SCROLLUP
0x33EB   SCVDP
0x18A6   SEARCH
0x51BD   SEED
0x0B09   SENDCHRPTRNS
0x0E61   SENDKEY
0x0CB2   SENDSND
0x0058   SER_BUFSIZE
0x0005   SER_EMPTYSIZE
0x0050   SER_FULLSIZE
0x5365   SERABITS
0x5366   SERBBITS
0x5145   SERBUF_START
0x51A1   serBufUsed
0x3AF6   SERIAL
0x5364   SERIALS_EN
0x519D   serInPtr
0x3B60   SERLED
0x519F   serRdPtr
0x3B17   SERVAR
0x3C3E   SET_CTC
0x0AD7   SET_GFX_MODE
0x0ADF   SET_GFX_MODE2
0x3C2D   SET_PT
0x0583   SETBEEP
0x34BC   SETBRCL
0x0794   SETCRSRY
0x0795   SETCSRCOORDS
0x2910   SETIO
0x18F0   SETLIT
0x0648   SETNAMETABLE
0x0E32   SETNEWAUTO
0x3C7A   SETPAR
0x3C85   SETPAR2
0x17C2   SETPTR
0x3E8A   SETREP
0x3C08   SETSER
0x0CD3   SETSNDREG
0x124A   SETTOP
0x33D2 X SETVDP
0x065A   SETVDPADRS
0x178C   SFTPRG
0x2EB9   SGN
0x21E0   SGNEXP
0x537A   SGNRES
0x04F2   SHOW_LOGO
0x2CE7   SHRITE
0x2CEA   SHRLP
0x2CEE   SHRT1
0x12BB   SIGNON
0x2F10   SIGNS
0x329D   SIN
0x32CD   SIN1
0x32E9   SINTAB
0x01CB   SIO_A_DI
0x01E3   SIO_A_EI
0x0336   SIO_A_SETS
0x01D3   SIO_B_DI
0x01EB   SIO_B_EI
0x033C X SIO_B_SETS
0x0022   SIO_CA
0x0023   SIO_CB
0x0020   SIO_DA
0x0021   SIO_DB
0x019D   SIO_RTS_OFF
0x01BB   SIO_RTS_ON
0x01D9   SIO_RXDI
0x01F1   SIO_RXEN
0x5330   SIOBFR
0x306C   SIXDIG
0x260A   SMPVAR
0x3201   SMSER1
0x0002   SN
0x2AD9   SND1
0x1A01   SND2VID
0x09F3   SNDCHRTOBFR
0x063E   SNDCLRSET
0x0E82   SNDKEYTOBFR
0x05AD   SNDLOGPT
0x2B0E   SNDOVR
0x0C99   SNDREGCFG
0x16C9   SNERR
0x1042   SNMSG
0x0FFF X SNPTR
0x0030   SO
0x3D24   SOERR
0x11C1   SOMSG
0x102D X SOPTR
0x2A82   SOUND
0x532C X SPA
0x532D X SPB
0x0020   SPC
0x305D   SPCFST
0x1F1D   SPCLP
0x0136   SPEC_RXA_CNDT
0x0168   SPEC_RXB_CNDT
0x3143   SQR
0x1B26   SRCHLIN
0x17DF   SRCHLN
0x17E2   SRCHLP
0x1B2C   SRCLN
0x1B2D   SRCLN1
0x2A28   SREG
0x3CBA   SRLCNT
0x3B5A   SRPT2
0x2BDF   SRTINK
0x5324   SRTTXT
0x2B9D   SSTAT
0x26D2   SSTSA
0x001E   ST
0x5282   STACK
0x2EDB   STAKFP
0x1C45   STALL
0x11E7   STARTB
0x063B   STARTEMPTY
0x5360   STATUSKEY
0x210F   STKTHS
0x53EF   STLOOK
0x111C   STMSG
0x1C54   STOP
0x1D2A   STORED
0x532F   STPBT
0x264D   STPOOL
0x101B X STPTR
0x252F   STR
0x2535   STR1
0x2650   STRADD
0x52EF   STRBOT
0x3875   STRE2
0x1FE0   STRENT
0x3CA2   STRPAR
0x51F2   STRSPC
0x1EC7   STTLIN
0x2C10   SUBCDE
0x2C0A   SUBPHL
0x320A   SUMLP
0x31F2   SUMSER
0x3CFA   SUP_BPS
0x30EB   SUPTLZ
0x22C8   SVNAM2
0x255D   SVSTAD
0x5332   SX
0x5334   SY
0x298E   SYS
0x29BA   SYSRET
0x32FE   TAN
0x52D4   TEMPSTACK
0x0DB1   TESTALT
0x0DBE   TESTCTRL
0x25DC   TESTOS
0x25BE   TESTR
0x5332   TF
0x0018   TM
0x16DB   TMERR
0x10E9   TMMSG
0x8000   TMP_FW_LOC
0x532A   TMPADR
0x5322   TMPBFR1
0x5324   TMPBFR2
0x5326   TMPBFR3
0x5328   TMPBFR4
0x5324   TMPCLR
0x5330   TMPHL
0x535E   TMPKEYBFR
0x52EB   TMPSTR
0x1015 X TMPTR
0x244F   TMR
0x5302   TMRCNT
0x52DF   TMSTPL
0x52DD   TMSTPT
0x2743   TOPOOL
0x26DB   TOSTRA
0x5330   TP
0x30C6   TRYAGN
0x26DC   TSALP
0x3FD1 X TSTBIT
0x1C37   TSTBRK
0x1238   TSTMEM
0x20A0   TSTNUM
0x2585   TSTOPL
0x2227   TSTRED
0x18F3   TSTREM
0x2EAA   TSTSGN
0x1B3A   TSTSPC
0x20A1   TSTSTR
0x1943   TTYLIN
0x026C   TX_EMP
0x0259   TXA
0x0269   TXA_EXIT
0x03F6 X TXTMD
0x52D9   TYPE
0x0022   UF
0x16D5   UFERR
0x1146   UFMSG
0x101F X UFPTR
0x000E   UL
0x1D8B   ULERR
0x1097   ULMSG
0x100B X ULPTR
0x2CFC   UNITY
0x1C32   UPDATA
0x51A9   USR
0x28A7   VAL
0x28C5   VAL1
0x28CF   VAL2
0x28D2   VAL3
0x3AB0   VALIDX
0x3AB5   VALIDY
0x536A   VAREND
0x0030   VDP_DAT
0x0031   VDP_SET
0x0B13   VDPMODESET
0x0B1B X VDPMODESET1
0x0B23 X VDPMODESET2
0x0B33 X VDPMODESETEX2
0x0B2B X VDPMODESETMC
0x532A   VIDEOBUFF
0x5352   VIDTMP1
0x5354   VIDTMP2
0x2A77   VOLCH
0x2A49   VOLUME
0x29C3   VPEEK
0x29EB   VPOKE
0x2B76   VREG
0x2B92   VSTAT
0x28F2   WAIT
0x2907   WAITLP
0x11E4   WARM
0x1295   WARMST
0x3376   WIDTH
0x0CC3   WLCBPDAT
0x0CA9   WLCMBEEP
0x134B   WORDS
0x14D8   WORDTB
0x068F   WRITE_VIDEO_LOC
0x06A4   WRITE_VREG
0x0985   WRITEBUF
0x51A3   WRKSPC
0x2B61   WRTSND
0x0CD8   WRTSNDREG
0x1B40   WTSPC
0x5322   X1
0x381B   X1GR
0x532A   X2
0x532A   XC
0x5330   XI
0x3790   XY2HL
0x5324   Y1
0x3845   Y1GR
0x532C   Y2
0x532C   YC
0x5332   YI
0x0083   ZDATA
0x00C2 X ZDINT
0x00C0 X ZDIV
0x00AE   ZELSE
0x0080   ZEND
0x00C8   ZEQUAL
0x240A   ZERARY
0x1646   ZERBYT
0x234D   ZEROLP
0x3F61   ZEROSUP
0x00B8   ZFN
0x0081   ZFOR
0x008C   ZGOSUB
0x0088   ZGOTO
0x00C7   ZGTR
0x00E1   ZINSTR
0x00E9   ZLEFT
0x00C9   ZLTH
0x00BE   ZMINUS
0x00C1 X ZMOD
0x00B5   ZNEW
0x00BB   ZNOT
0x1EF6   ZONELP
0x00C6   ZOR
0x00BD   ZPLUS
0x00E0   ZPOINT
0x00AF   ZPRINT
0x008E   ZREM
0x00CA   ZSGN
0x00B9   ZSPC
0x00BC   ZSTEP
0x00B6   ZTAB
0x00BA   ZTHEN
0x00BF X ZTIMES
0x00B7   ZTO
