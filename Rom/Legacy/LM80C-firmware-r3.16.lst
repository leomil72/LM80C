# file opened: LM80C-firmware-r3.16.asm
   1  0000              ; ------------------------------------------------------------------------------
   2  0000              ; LM80C - FIRMWARE - R3.16
   3  0000              ; ------------------------------------------------------------------------------
   4  0000              ; The following code is intended to be used with LM80C Z80-based computer
   5  0000              ; designed by Leonardo Miliani. More info at
   6  0000              ; www DOT leonardomiliani DOT com
   7  0000              ; ------------------------------------------------------------------------------
   8  0000              ; Coding/Editing/Compiling:
   9  0000              ; Original init code for MC68B05 by Grant Searle
  10  0000              ; Original SIO/CTC/PIO init code by Mario Blunk
  11  0000              ; NASCOM BASIC originally modified by Gran Searle
  12  0000              ; Code modified and adapted for LM80C by Leonardo Miliani
  13  0000              ;
  14  0000              ; Edited with Visual Studio Code
  15  0000              ;
  16  0000              ; Compiled with SjASMPlus assembler 1.18.0
  17  0000              ; https://github.com/z00m128/sjasmplus
  18  0000              ; ------------------------------------------------------------------------------
  19  0000              ; Copyright notes:
  20  0000              ; Parts of the code (c) Grant Searle - free for non commercial use
  21  0000              ; Please include this advice and the note to the attribution of the original
  22  0000              ; version to Grant Searle if you intend to redistribuite it
  23  0000              ; http://searle.hostei.com/grant/index.html
  24  0000              ; eMail: home.micros01@btinternet.com
  25  0000              ;
  26  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  27  0000              ; Parts of the code (c) Mario Blunk
  28  0000              ; http://www.trainÂ­z.de
  29  0000              ;
  30  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  31  0000              ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  32  0000              ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  33  0000              ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  34  0000              ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  35  0000              ; the original ROM code (checksum A934H). PA
  36  0000              ;
  37  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  38  0000              ; The following code is intended to be used with LM80C Z80-based computer
  39  0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
  40  0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
  41  0000              ; kind of warranty: you can use them at your own risk.
  42  0000              ; You are free to use them for any non-commercial use: you are only asked to
  43  0000              ; maintain the copyright notices, include this advice and the note to the
  44  0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  45  0000              ; redistribuite them.
  46  0000              ; https://www.leonardomiliani.com
  47  0000              ;
  48  0000              ; Please support me by visiting the following links:
  49  0000              ; Main project page: https://www.leonardomiliani.com
  50  0000              ; Schematics and code: https://github.com/leomil72/LM80C
  51  0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  52  0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  53  0000              ; ------------------------------------------------------------------------------
  54  0000              ; output binary file
  55  0000                  OUTPUT "LM80C-firmware-r3.16.bin"
  56  0000
  57  0000              ; set computer model
  58  0000                  DEFINE  LM80C
  59  0000
  60  0000              ; ------------------------------------------------------------------------------
  61  0000              ; include the latest version of the bootloader: this sets up the address aliases
  62  0000              ; configure the hardware, checks if warm or cold startup and loads the BASIC interpreter
  63  0000                  INCLUDE "../include/bootloader/bootloader-r316.asm"
# file opened: ../include/bootloader/bootloader-r316.asm
   1+ 0000              ; ------------------------------------------------------------------------------
   2+ 0000              ; LM80C - BOOTLOADER - R3.16
   3+ 0000              ; ------------------------------------------------------------------------------
   4+ 0000              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0000              ; kind of warranty: you can use them at your own risk.
   8+ 0000              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0000              ; maintain the copyright notices, include this advice and the note to the
  10+ 0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0000              ; redistribuite them.
  12+ 0000              ; https://www.leonardomiliani.com
  13+ 0000              ;
  14+ 0000              ; Please support me by visiting the following links:
  15+ 0000              ; Main project page: https://www.leonardomiliani.com
  16+ 0000              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0000              ; ------------------------------------------------------------------------------
  20+ 0000
  21+ 0000              ; ADDRESS DECODING (bits A6/A5/A4)
  22+ 0000              ; 0000xxxx : PIO
  23+ 0000              ; 0001xxxx : CTC
  24+ 0000              ; 0010xxxx : SIO
  25+ 0000              ; 0011xxxx : VDP
  26+ 0000              ; 0100xxxx : PSG
  27+ 0000              ; 0101xxxx : C.F.
  28+ 0000
  29+ 0000
  30+ 0000              ; ------------------------------------------------------------------------------
  31+ 0000              ;               EQUATES
  32+ 0000              ; ------------------------------------------------------------------------------
  33+ 0000              ; label defining for PIO (Parallel Input/Output)
  34+ 0000              PIO_DA          equ %00000000
  35+ 0000              PIO_DB          equ %00000001
  36+ 0000              PIO_CA          equ %00000010
  37+ 0000              PIO_CB          equ %00000011
  38+ 0000
  39+ 0000              ; label defining for CTC (Counter Timer Circuit)
  40+ 0000              CTC_CH0         equ %00010000
  41+ 0000              CTC_CH1         equ %00010001
  42+ 0000              CTC_CH2         equ %00010010
  43+ 0000              CTC_CH3         equ %00010011
  44+ 0000
  45+ 0000              ;label defining for SIO (Serial Input/Output)
  46+ 0000              SIO_CA          equ %00100010
  47+ 0000              SIO_CB          equ %00100011
  48+ 0000              SIO_DA          equ %00100000
  49+ 0000              SIO_DB          equ %00100001
  50+ 0000
  51+ 0000              ;label defining for VDP (Video Display Processor)
  52+ 0000              VDP_DAT         equ %00110000
  53+ 0000              VDP_SET         equ %00110010
  54+ 0000
  55+ 0000              ; label defining for PSG (Programmable Sound Generator)
  56+ 0000              PSG_REG         equ %01000000
  57+ 0000              PSG_DAT         equ %01000001
  58+ 0000
  59+ 0000              ; Interrupt-driven serial I/O interface lead by the Z80 SIO to run modified
  60+ 0000              ; NASCOM Basic 4.7 - Full input buffering with incoming data hardware handshaking
  61+ 0000              ; Handshake shows full before the buffer is totally filled to allow run-on from the sender
  62+ 0000              SER_BUFSIZE     equ     $58
  63+ 0000              SER_FULLSIZE    equ     $50
  64+ 0000              SER_EMPTYSIZE   equ     $05
  65+ 0000
  66+ 0000
  67+ 0000              ;------------------------------------------------------------------------------
  68+ 0000              ;                                F I R M W A R E
  69+ 0000              ;------------------------------------------------------------------------------
  70+ 0000              ; BASE MEMORY - RESET LOCATION ($0000) -> the CPU jumps to $0000 after a reset
  71+ 0000                              org     $0000
  72+ 0000 F3           RST00:          di                      ; be sure that INTs are disabled
  73+ 0001 C3 B0 02                     jp      INIT_HW         ; jump to system initialization
  74+ 0004
  75+ 0004              ;------------------------------------------------------------------------------
  76+ 0004              ; interrupt vector when SIO ch.B has a char available in its buffer
  77+ 0004                              ;$0004
  78+ 0004 64 01                        defw    RX_CHB_AVAIL
  79+ 0006
  80+ 0006              ;------------------------------------------------------------------------------
  81+ 0006              ; interrupt vector for SIO ch.B special conditions (i.e. buf overrun)
  82+ 0006                              ;$0006
  83+ 0006 67 01                        defw    SPEC_RXB_CNDT
  84+ 0008
  85+ 0008              ;------------------------------------------------------------------------------
  86+ 0008              ; send a character over serial ch. A
  87+ 0008                              ;$0008
  88+ 0008 C3 4D 02     RST08:          jp      TXA
  89+ 000B FF                           BLOCK   1,$FF   ; filler
  90+ 000C
  91+ 000C              ;------------------------------------------------------------------------------
  92+ 000C              ; interrupt vector when SIO ch.A has a char available in its buffer
  93+ 000C                              ;$000C
  94+ 000C 00 01                        defw    RX_CHA_AVAIL
  95+ 000E
  96+ 000E              ;------------------------------------------------------------------------------
  97+ 000E              ; interrupt vector for SIO ch.A special conditions (i.e. buf overrun)
  98+ 000E                              ;$000E
  99+ 000E 35 01                        defw    SPEC_RXA_CNDT
 100+ 0010
 101+ 0010              ;------------------------------------------------------------------------------
 102+ 0010              ; receive a character over serial ch. A
 103+ 0010                              ;$0010
 104+ 0010 C3 23 02     RST10:          jp      RXA
 105+ 0013 FF FF FF...                  BLOCK   5,$FF   ; filler
 106+ 0018              ;------------------------------------------------------------------------------
 107+ 0018              ; check serial status
 108+ 0018
 109+ 0018                              ;$0018
 110+ 0018 C3 7A 02     RST18:          jp      CKINCHAR
 111+ 001B FF FF FF...                  BLOCK   $25,$FF ; filler
 112+ 0040              ;------------------------------------------------------------------------------
 113+ 0040              ; interrupt vectors for CTC
 114+ 0040                              ;$0040               ; for CH0 Timer - used in BASIC by serial 1 for bps
 115+ 0040 C1 81                        defw    CTC0IV
 116+ 0042                              ;$0042               ; for CH1 Timer - used in BASIC by serial 2 for bps
 117+ 0042 C4 81                        defw    CTC1IV
 118+ 0044                              ;$0044               ; for CH2 timer - unused
 119+ 0044 C7 81                        defw    CTC2IV
 120+ 0046                              ;$0046               ; for CH3 Timer - used by FW for 100ths/s counter
 121+ 0046 CA 81                        defw    CTC3IV
 122+ 0048 FF FF FF...                  BLOCK   $1E,$FF ; filler
 123+ 0066              ;------------------------------------------------------------------------------
 124+ 0066              ; interrupt routine for NMI
 125+ 0066                              ;$0066
 126+ 0066 C3 61 80                     jp      NMIUSR              ; jump to execute NMI service routine
 127+ 0069 FF FF FF...                  BLOCK   $27,$FF ; filler
 128+ 0090              ;------------------------------------------------------------------------------
 129+ 0090                  LUA
 130+ 0090 ~                    sj.insert_define("TIME", '"' .. os.date("%d-%m-%Y %H:%M:%S") .. '"')
 131+ 0090              	ENDLUA
 132+ 0090                              ;$0090
 133+ 0090 4C 4D 38 30                  defb    $4C,$4D,$38,$30,$43,$20,$43,$4F
 133+ 0094 43 20 43 4F
 134+ 0098 4C 4F 52 00                  defb    $4C,$4F,$52,$00,$00,$00,$00,$00
 134+ 009C 00 00 00 00
 135+ 00A0 43 4F 4D 50                  defb    $43,$4F,$4D,$50,$55,$54,$45,$52
 135+ 00A4 55 54 45 52
 136+ 00A8 20 28 32 30                  defb    $20,$28,$32,$30,$32,$30,$29,$00
 136+ 00AC 32 30 29 00
 137+ 00B0 44 65 73 69                  defb    $44,$65,$73,$69,$67,$6E,$65,$64
 137+ 00B4 67 6E 65 64
 138+ 00B8 20 62 79 00                  defb    $20,$62,$79,$00,$00,$00,$00,$00
 138+ 00BC 00 00 00 00
 139+ 00C0 4C 65 6F 6E                  defb    $4C,$65,$6F,$6E,$61,$72,$64,$6F
 139+ 00C4 61 72 64 6F
 140+ 00C8 20 4D 69 6C                  defb    $20,$4D,$69,$6C,$69,$61,$6E,$69
 140+ 00CC 69 61 6E 69
 141+ 00D0 46 57 20 31  FWVER:          defm    "FW 1.02",$20,"03-01-2021 18:03:43",$00
 141+ 00D4 2E 30 32 20
 141+ 00D8 30 33 2D 30
 141+ 00DC 31 2D 32 30
 141+ 00E0 32 31 20 31
 141+ 00E4 38 3A 30 33
 141+ 00E8 3A 34 33 00
bootloader-r316.asm(142): warning: Label has different value in pass 3: previous value 218 not equal 236
 142+ 00EC              FMVEREND:       equ     $
 143+ 00EC FF FF FF...                  BLOCK   $100-FMVEREND,$FF   ; filler
 144+ 0100              ;------------------------------------------------------------------------------
 145+ 0100
 146+ 0100              ;-------------------------------------------------------------------------------
 147+ 0100              ;               Z80 SIO CH. A MANAGEMENT
 148+ 0100              ;-------------------------------------------------------------------------------
 149+ 0100
 150+ 0100              ;-------------------------------------------------------------------------------
 151+ 0100              ; interrupt driven routine to get chars from Z80 SIO ch.A
 152+ 0100              ; this is the only channel that can print received chars onto the screen
 153+ 0100                              ;$0100
 154+ 0100 F5           RX_CHA_AVAIL:   push    AF              ; store A
 155+ 0101 E5                           push    HL              ; and HL
 156+ 0102 CD 8E 01                     call    A_RTS_OFF       ; disable RTS line
 157+ 0105 DB 20                        in      A,(SIO_DA)      ; read char from RX buffer into A
 158+ 0107 32 1A 82                     ld      (TMPKEYBFR),A   ; store it into the temp key buffer
 159+ 010A CD F4 01                     call    CHARINTOBFR     ; sub-routine to put the char into the input buffer
 160+ 010D D2 30 01                     jp      NC,LVRXCHA      ; if buffer is full, then leave without doing anything else
 161+ 0110 3A 1A 82                     ld      A,(TMPKEYBFR)   ; retrieve char
 162+ 0113 32 DB 81                     ld      (CHR4VID),A     ; write into buffer for video printing
 163+ 0116 FE 0D                        cp      CR              ; is it RETURN?
 164+ 0118 CA 20 01                     jp      Z,CNTRXCHA      ; yes, continue
 165+ 011B FE 20                        cp      $20             ; is it another control char (code < 32)?
 166+ 011D DA 30 01                     jp      C,LVRXCHA       ; yes, leave w/o printing it on video nor sending back to serial
 167+ 0120 F5           CNTRXCHA:       push    AF              ; store char
 168+ 0121 AF                           xor     A
 169+ 0122 32 18 82                     ld      (KBDNPT),A      ; a char from serial is like a char printed by BASIC
 170+ 0125 3A D8 81                     ld      A,(CRSR_STATE)  ; check cursor state
 171+ 0128 B7                           or      A               ; is it on?
 172+ 0129 C4 6E 07                     call    NZ,CHAR2VID     ; yes, print on screen
 173+ 012C F1                           pop     AF              ; retrieve char
 174+ 012D CD 4D 02                     call    TXA             ; send back to serial
 175+ 0130 E1           LVRXCHA:        pop     HL              ; retrieve HL
 176+ 0131 F1                           pop     AF              ; and A
 177+ 0132 FB                           ei                      ; re-enable interrupts
 178+ 0133 ED 4D                        reti                    ; and exit
 179+ 0135
 180+ 0135              ;-------------------------------------------------------------------------------
 181+ 0135              ; special SIO ch.A condition (i.e., buffer overrun)
 182+ 0135              ; if buffer overruns then show an error, empty the RX buffer and send
 183+ 0135              ; a break char
 184+ 0135 F5           SPEC_RXA_CNDT:  push    AF              ; store AF
 185+ 0136 CD 8E 01                     call    A_RTS_OFF       ; disable RTS
 186+ 0139 CD C2 01                     call    SIO_A_DI        ; disable RX on ch. A
 187+ 013C 3A 20 82                     ld      A,(SERIALS_EN)  ; load serial status
 188+ 013F CB 97                        res     2,A             ; disable RX on port 1
 189+ 0141 32 20 82                     ld      (SERIALS_EN),A  ; store new serial status
 190+ 0144 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 191+ 0146 CB E7                        set     4,A             ; set 5th pin ON
 192+ 0148 D3 01                        out     (PIO_DB),A      ; send new setting
 193+ 014A 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 194+ 014C D3 22                        out     (SIO_CA),A      ; send command to SIO
 195+ 014E AF           EMPTYCHABFR:    xor     A
 196+ 014F D3 22                        out     (SIO_CA),A      ; write to WR0, select RR0
 197+ 0151 DB 22                        in      A,(SIO_CA)      ; read RR0 register
 198+ 0153 E6 01                        and     $01             ; check if input buffer if empty
 199+ 0155 CA 5C 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then leave
 200+ 0158 DB 20                        in      A,(SIO_DA)      ; read chars
 201+ 015A 18 F2                        jr      EMPTYCHABFR     ; repeat
 202+ 015C F1           CHABFREMPTY:    pop     AF              ; retrieve AF
 203+ 015D 21 F5 3C                     ld      HL,SOERR        ; return point set to Serial Buffer Overrun routine
 204+ 0160 E3                           ex      (SP),HL         ; store onto stack
 205+ 0161 FB                           ei                      ; re-enable interrupts
 206+ 0162 ED 4D                        reti                    ; return from interrupt and execute code at SOERR
 207+ 0164
 208+ 0164              ;-------------------------------------------------------------------------------
 209+ 0164              ;               Z80 SIO CH. A MANAGEMENT
 210+ 0164              ;-------------------------------------------------------------------------------
 211+ 0164
 212+ 0164              ;-------------------------------------------------------------------------------
 213+ 0164              ; interrupt driven routine to get chars from Z80 SIO ch.B
 214+ 0164 FB           RX_CHB_AVAIL:   ei
 215+ 0165 ED 4D                        reti
 216+ 0167
 217+ 0167              ;-------------------------------------------------------------------------------
 218+ 0167              ; special SIO ch.A condition (i.e., buffer overrun)
 219+ 0167              ; if buffer overruns then show an error, empty the RX buffer and send
 220+ 0167              ; a break char
 221+ 0167 F5           SPEC_RXB_CNDT:  push    AF              ; store A
 222+ 0168 CD 96 01                     call    B_RTS_OFF       ; disable RTS
 223+ 016B CD CA 01                     call    SIO_B_DI        ; disable RX on ch.B
 224+ 016E 3A 20 82                     ld      A,(SERIALS_EN)  ; load serial status
 225+ 0171 CB 9F                        res     3,A             ; disable RX on port 2
 226+ 0173 32 20 82                     ld      (SERIALS_EN),A  ; store new serial status
 227+ 0176 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 228+ 0178 CB EF                        set     5,A             ; set 5th pin ON
 229+ 017A D3 01                        out     (PIO_DB),A      ; send new setting
 230+ 017C 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 231+ 017E D3 23                        out     (SIO_CB),A      ; send command to SIO
 232+ 0180 AF           EMPTYCHBBFR:    xor     A
 233+ 0181 D3 23                        out     (SIO_CB),A      ; write to WR0, select RR0
 234+ 0183 DB 23                        in      A,(SIO_CB)      ; read RR0 register
 235+ 0185 E6 01                        and     $01             ; check if input buffer if empty
 236+ 0187 CA 5C 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then jump to run "exit" code
 237+ 018A DB 21                        in      A,(SIO_DB)      ; read chars
 238+ 018C 18 F2                        jr      EMPTYCHBBFR     ; repeat
 239+ 018E
 240+ 018E
 241+ 018E              ;-------------------------------------------------------------------------------
 242+ 018E              ;               Z80 SIO MANAGEMENT
 243+ 018E              ;-------------------------------------------------------------------------------
 244+ 018E              ; disable RTS:
 245+ 018E              ; by resetting RTS bit (set to 0), the RTS line is disabled (HIGH)
 246+ 018E C5           A_RTS_OFF:      push    BC              ; store BC
 247+ 018F 0E 22                        ld      C,SIO_CA        ; select channel A
 248+ 0191 3A 21 82                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 249+ 0194 18 06                        jr      SIO_RTS_OFF
 250+ 0196 C5           B_RTS_OFF:      push    BC              ; store BC
 251+ 0197 0E 23                        ld      C,SIO_CB        ; select channel B
 252+ 0199 3A 22 82                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 253+ 019C 47           SIO_RTS_OFF:    ld      B,A             ; store data bits
 254+ 019D 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 255+ 019F ED 79                        out     (C),A
 256+ 01A1 78                           ld      A,B             ; retrieve data bits
 257+ 01A2 F6 28                        or      %00101000       ; TX enable; RTS disable
 258+ 01A4 ED 79                        out     (C),A           ; send setting
 259+ 01A6 C1                           pop     BC              ; retrieve BC
 260+ 01A7 C9                           ret                     ; exit
 261+ 01A8
 262+ 01A8              ;-------------------------------------------------------------------------------
 263+ 01A8              ; enable RTS
 264+ 01A8              ; by setting RTS bit (set to 1), the RTS line is enabled (LOW)
 265+ 01A8 C5           A_RTS_ON:       push    BC              ; store BC
 266+ 01A9 0E 22                        ld      C,SIO_CA        ; select channel A
 267+ 01AB 3A 21 82                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 268+ 01AE 18 06                        jr      SIO_RTS_ON
 269+ 01B0 C5           B_RTS_ON:       push    BC              ; store BC
 270+ 01B1 0E 23                        ld      C,SIO_CB        ; select channel B
 271+ 01B3 3A 22 82                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 272+ 01B6 47           SIO_RTS_ON:     ld      B,A             ; store data bits
 273+ 01B7 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 274+ 01B9 ED 79                        out     (C),A
 275+ 01BB 78                           ld      A,B             ; retrieve data bits
 276+ 01BC F6 2A                        or      %00101010       ; TX enable; RTS enable
 277+ 01BE ED 79                        out     (C),A           ; send setting
 278+ 01C0 C1                           pop     BC              ; retrieve BC
 279+ 01C1 C9                           ret                     ; return
 280+ 01C2
 281+ 01C2              ;-------------------------------------------------------------------------------
 282+ 01C2              ; disable SIO RX channel
 283+ 01C2 C5           SIO_A_DI:       push    BC              ; store BC
 284+ 01C3 0E 22                        ld      C,SIO_CA        ; SIO channel A
 285+ 01C5 3A 21 82                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 286+ 01C8 18 06                        jr      SIO_RXDI        ; jump to disable RX
 287+ 01CA C5           SIO_B_DI:       push    BC              ; store BC
 288+ 01CB 0E 23                        ld      C,SIO_CB        ; SIO channel B
 289+ 01CD 3A 22 82                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 290+ 01D0 47           SIO_RXDI:       ld      B,A             ; store data bits
 291+ 01D1 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 292+ 01D3 ED 79                        out     (C),A
 293+ 01D5 78                           ld      A,B             ; retrieve data bits; RX disabled; auto enable is OFF
 294+ 01D6 ED 79                        out     (C),A
 295+ 01D8 C1                           pop     BC              ; retrieve BC
 296+ 01D9 C9                           ret                     ; return
 297+ 01DA
 298+ 01DA              ;-------------------------------------------------------------------------------
 299+ 01DA              ; enable SIO RX channel
 300+ 01DA C5           SIO_A_EI:       push    BC              ; store BC
 301+ 01DB 0E 22                        ld      C,SIO_CA
 302+ 01DD 3A 21 82                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 303+ 01E0 18 06                        jr      SIO_RXEN
 304+ 01E2 C5           SIO_B_EI:       push    BC              ; store BC
 305+ 01E3 0E 23                        ld      C,SIO_CB
 306+ 01E5 3A 22 82                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 307+ 01E8 47           SIO_RXEN:       ld      B,A             ; store data bits
 308+ 01E9 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 309+ 01EB ED 79                        out     (C),A           ; select register
 310+ 01ED 78                           ld      A,B             ; retrieve data bits
 311+ 01EE CB C7                        set     0,A             ; set RX enabled; auto enable is OFF
 312+ 01F0 ED 79                        out     (C),A           ; send settings to SIO
 313+ 01F2 C1                           pop     BC              ; retrieve BC
 314+ 01F3 C9                           ret
 315+ 01F4
 316+ 01F4              ;------------------------------------------------------------------------------
 317+ 01F4              ; put a char into the input buffer, char is into A
 318+ 01F4              ; this sub is called both from the ISR "RX_CHA_AVAIL" and when
 319+ 01F4              ; the RETURN key is pressed on the keyboard
 320+ 01F4 F5           CHARINTOBFR:    push    AF              ; store it
 321+ 01F5 3A 5C 80                     ld      A,(serBufUsed)  ; load buffer size
 322+ 01F8 FE 58                        cp      SER_BUFSIZE     ; if buffer is not full
 323+ 01FA DA FF 01                     jp      C,NOTFULL       ; then store the char
 324+ 01FD F1                           pop     AF              ; else drop it
 325+ 01FE C9                           ret                     ; and exit
 326+ 01FF 2A 58 80     NOTFULL:        ld      HL,(serInPtr)   ; buffer is not full, can store the char
 327+ 0202 23                           inc     HL              ; load pointer to find first free cell
 328+ 0203 7D                           ld      A,L             ; only check low byte because buffer<256
 329+ 0204 FE 58                        cp      bufWrap         ; check if the pointer is at the last cell
 330+ 0206 20 03                        jr      NZ,NOTWRAP      ; if not then continue
 331+ 0208 21 00 80                     ld      HL,SERBUF_START ; else load the address of the first cell
 332+ 020B 22 58 80     NOTWRAP:        ld      (serInPtr),HL   ; store the new pointer
 333+ 020E F1                           pop     AF              ; then recover the char
 334+ 020F 77                           ld      (HL),A          ; and store it in the appropriate cell
 335+ 0210 3A 5C 80                     ld      A,(serBufUsed)  ; load the size of the input buffer
 336+ 0213 3C                           inc     A               ; increment it
 337+ 0214 32 5C 80                     ld      (serBufUsed),A  ; and store the new size
 338+ 0217 FE 50                        cp      SER_FULLSIZE    ; check if input buffer is full
 339+ 0219 D8                           ret     C               ; exit if buffer is not full
 340+ 021A 3A 20 82                     ld      A,(SERIALS_EN)  ; check if serial 1 is open
 341+ 021D 1F                           rra                     ; bit 0 into Carry: if Carry is 1 then serial 0 is open and...
 342+ 021E DC 8E 01                     call    C,A_RTS_OFF     ; ...stop receiving further chars
 343+ 0221 AF                           xor     A               ; clear Carry to set a buffer full condition
 344+ 0222 C9                           ret
 345+ 0223
 346+ 0223
 347+ 0223              ;-------------------------------------------------------------------------------
 348+ 0223              ; retrieve a char from the input buffer
 349+ 0223 3A 5C 80     RXA:            ld      A,(serBufUsed)  ; load the buffer size
 350+ 0226 A7                           and     A               ; check if it's 0 (empty)
 351+ 0227 CA 23 02                     jp      Z,RXA           ; if it's empty, wait for a char
 352+ 022A F3                           di                      ; disable interrupts
 353+ 022B E5                           push    HL              ; store HL
 354+ 022C 2A 5A 80                     ld      HL,(serRdPtr)   ; load pointer to first available char
 355+ 022F 23                           inc     HL              ; increment it (go to the next char)
 356+ 0230 7D                           ld      A,L             ; check if the end of the buffer has been reached
 357+ 0231 FE 58                        cp      bufWrap         ; (only check low byte because buffer<256)
 358+ 0233 20 03                        jr      NZ,NOTRDWRAP    ; if not, jump straight
 359+ 0235 21 00 80                     ld      HL,SERBUF_START ; else reload the starting address of the buffer
 360+ 0238 22 5A 80     NOTRDWRAP:      ld      (serRdPtr),HL   ; store new pointer to the next char to read
 361+ 023B 3A 5C 80                     ld      A,(serBufUsed)  ; load buffer size
 362+ 023E 3D                           dec     A               ; decrement it
 363+ 023F 32 5C 80                     ld      (serBufUsed),A  ; and store the new size
 364+ 0242 FE 05                        cp      SER_EMPTYSIZE   ; check if input buffer can be considered empty
 365+ 0244 30 03                        jr      NC,RXA_EXIT     ; if not empty yet, then exit
 366+ 0246 CD A8 01                     call    A_RTS_ON        ; else re-enable receiving chars
 367+ 0249 7E           RXA_EXIT:       ld      A,(HL)          ; recover the char and return it into A
 368+ 024A E1                           pop     HL              ; retrieve HL
 369+ 024B FB                           ei                      ; re-enable interrupts
 370+ 024C C9                           ret                     ; return
 371+ 024D
 372+ 024D              ;------------------------------------------------------------------------------
 373+ 024D              ; sends a char over the serial (trick for INTs from WikiTI)
 374+ 024D              ; char is into A
 375+ 024D F5           TXA:            push    AF              ; store AF
 376+ 024E C5                           push    BC              ; store BC
 377+ 024F 47                           ld      B,A             ; store char
 378+ 0250 ED 57                        ld      A,I             ; when loading I into A, P/V is set to the value of IFF (P/V is set if INTs enabled)
 379+ 0252 EA 57 02                     jp      PE,CNTTXA       ; if set, jump over
 380+ 0255 ED 57                        ld      A,I             ; if not set, test again to fix "false negative" from interrupt occurring at first test
 381+ 0257 F5           CNTTXA:         push    AF              ; store current P/V flag
 382+ 0258 F3                           di                      ; disable INTs
 383+ 0259 3A 20 82                     ld      A,(SERIALS_EN)  ; load serial status
 384+ 025C FE 05                        cp      %00000101       ; check if serial 1 is open and RX/TX is enabled
 385+ 025E 20 06                        jr      NZ,TXA_EXIT     ; no, jump over
 386+ 0260 78                           ld      A,B             ; retrieve char
 387+ 0261 D3 20                        out     (SIO_DA),A      ; send char to the SIO
 388+ 0263 CD 6E 02                     call    TX_EMP          ; wait for outgoing char to be sent
 389+ 0266 F1           TXA_EXIT:       pop     AF              ; retrieve P/V flag
 390+ 0267 E2 6B 02                     jp      PO,EXTXA        ; if P is reset, INTs were disabled so we can leave right now
 391+ 026A FB                           ei                      ; INTs were enabled, so re-enable interrupts
 392+ 026B C1           EXTXA:          pop     BC              ; retrieve BC
 393+ 026C F1                           pop     AF              ; retrieve AF
 394+ 026D C9                           ret                     ; return
 395+ 026E
 396+ 026E              ;------------------------------------------------------------------------------
 397+ 026E              ; wait until outgoing serial has been sent
 398+ 026E 97           TX_EMP:         sub     A               ; set A to 0
 399+ 026F 3C                           inc     A               ; set A to 1
 400+ 0270 D3 22                        out     (SIO_CA),A      ; write to WR0, select RR1
 401+ 0272 DB 22                        in      A,(SIO_CA)      ; read RR1 register
 402+ 0274 CB 47                        bit     0,A             ; check if all chars have been sent
 403+ 0276 CA 6E 02                     jp      Z,TX_EMP        ; if not (bit 0 = 0) then retrieve
 404+ 0279 C9                           ret                     ; else exit
 405+ 027A
 406+ 027A
 407+ 027A              ;------------------------------------------------------------------------------
 408+ 027A              ; check if there is some chars into the buffer
 409+ 027A 3A 5C 80     CKINCHAR:       ld      A,(serBufUsed)  ; load char in buffer
 410+ 027D A7                           and     A               ; compare to 0
 411+ 027E C9                           ret                     ; return
 412+ 027F
 413+ 027F              ;------------------------------------------------------------------------------
 414+ 027F              ; print a text from memory, and terminate when $00 is found
 415+ 027F 7E           RAWPRINT:       ld      A,(HL)          ; load character from memory cell pointed by HL
 416+ 0280 B7                           or      A               ; is it $00 (end string)?
 417+ 0281 C8                           ret     Z               ; Yes, then return
 418+ 0282 32 DB 81                     ld      (CHR4VID),A     ; store char
 419+ 0285 F3                           di
 420+ 0286 CD 6E 07                     call    CHAR2VID        ; and send it to screen
 421+ 0289 FB                           ei
 422+ 028A 23                           inc     HL              ; and select the next one
 423+ 028B 18 F2                        jr      RAWPRINT        ; repeat
 424+ 028D
 425+ 028D              ;-------------------------------------------------
 426+ 028D              ; Interrupt service routine (ISR) for CH3 timer
 427+ 028D              ; this is used to increment the 100ths of a second counter and for cursor flashing
 428+ 028D F5           CH3_TIMER:      push    AF              ; save regs. A,
 429+ 028E C5                           push    BC              ; BC,
 430+ 028F D5                           push    DE              ; DE,
 431+ 0290 E5                           push    HL              ; HL
 432+ 0291 21 BD 81                     ld      HL,TMRCNT       ; load starting address of the timer
 433+ 0294 06 04                        ld      B,$04           ; 4 bytes to check
 434+ 0296 34           INCTMR3:        inc     (HL)            ; increment timer
 435+ 0297 20 03                        jr      NZ,CHKCRSR      ; if not zero then exit (finished increment)
 436+ 0299 23                           inc     HL              ; if yes, there was an overflow, so increment next byte
 437+ 029A 10 FA                        djnz    INCTMR3         ; repeat for 4 bytes
 438+ 029C CD D8 07     CHKCRSR:        call    FLASHCURSOR     ; call the flashing cursor routine
 439+ 029F CD D4 0C                     call    MNGSNDS         ; call the tone managemenet
 440+ 02A2 3A BD 81                     ld      A,(TMRCNT)      ; check for keyboard management
 441+ 02A5 1F                           rra                     ; bit 0 = 1 ?
 442+ 02A6 D4 39 0D                     call    NC,KEYBOARD     ; no, so read the keyboard inputs
 443+ 02A9 E1                           pop     HL              ; retrieve HL,
 444+ 02AA D1                           pop     DE              ; DE,
 445+ 02AB C1                           pop     BC              ; BC,
 446+ 02AC F1                           pop     AF              ; and A
 447+ 02AD FB                           ei                      ; re-enable interrupts
 448+ 02AE ED 4D                        reti                    ; exit from ISR
 449+ 02B0
 450+ 02B0              ;------------------------------------------------------------------------------
 451+ 02B0              ;               HARDWARE INITIALISATION
 452+ 02B0              ;------------------------------------------------------------------------------
 453+ 02B0              ; first run - setup HW & SW
 454+ 02B0              ;
 455+ 02B0 21 8F 81     INIT_HW:        ld      HL,TEMPSTACK    ; load temp stack pointer
 456+ 02B3 F9                           ld      SP,HL           ; set stack to temp stack pointer
 457+ 02B4 21 00 80                     ld      HL,SERBUF_START ; set beginning of input buffer
 458+ 02B7 22 58 80                     ld      (serInPtr),HL   ; for incoming chars to store into buffer
 459+ 02BA 22 5A 80                     ld      (serRdPtr),HL   ; and for chars to be read from buffer
 460+ 02BD AF                           xor     A               ; reset A
 461+ 02BE 32 5C 80                     ld      (serBufUsed),A  ; actual buffer size is 0
 462+ 02C1 32 20 82                     ld      (SERIALS_EN),A  ; set serial ports status to OFF
 463+ 02C4 CD 3B 03                     call    HELLOWRLD       ; little serial blink with LEDs
 464+ 02C7 CD 60 03                     call    initCTC         ; configure CTC, then...
 465+ 02CA CD 72 0C                     call    initPSG         ; ...configure PSG
 466+ 02CD CD 12 05                     call    SHOW_LOGO       ; show computer logo
 467+ 02D0 1E 01                        ld      E,$01           ; E chooses the video mode (graphics 1)
 468+ 02D2 CD EF 03                     call    initVDP         ; set video display
 469+ 02D5 AF                           xor     A
 470+ 02D6 ED 47                        ld      I,A             ; set high byte of interrupt vectors to point to page 0
 471+ 02D8 ED 5E                        im      2               ; interrupt mode 2
 472+ 02DA FB                           ei                      ; enable interrupts
 473+ 02DB                              ; print system messages
 474+ 02DB AF                           xor     A               ; A=0 so...
 475+ 02DC 32 18 82                     ld      (KBDNPT),A      ; ...inputs don't come from keyboard
 476+ 02DF 3C                           inc     A               ; A=1...
 477+ 02E0 32 DA 81                     ld      (PRNTVIDEO),A   ; ...to activate the print-on-video
 478+ 02E3 21 96 03                     ld      HL,MSGTXT1      ; sign-on message
 479+ 02E6 CD 7F 02                     call    RAWPRINT        ; print message
 480+ 02E9 3A 5D 80                     ld      A,(basicStarted); check if BASIC is already started
 481+ 02EC FE 59                        cp      'Y'             ; to see if this is a power-up
 482+ 02EE 20 19                        jr      NZ,COLDSTART    ; if not, then do a COLD start
 483+ 02F0 21 D2 03                     ld      HL,MSGTXT2      ; message to choose kind of start
 484+ 02F3 CD 7F 02                     call    RAWPRINT        ; print message
 485+ 02F6 CD 0A 09                     call    CURSOR_ON       ; enable cursor
 486+ 02F9 AF                           xor     A
 487+ 02FA 32 DA 81                     ld      (PRNTVIDEO),A   ; disable print-on-video
 488+ 02FD CD 23 02     CORW:           call    RXA             ; look for a pressed key
 489+ 0300 E6 DF                        and     %11011111       ; only UPPERCASE char
 490+ 0302 FE 43                        cp      'C'             ; cold start?
 491+ 0304 20 0E                        jr      NZ,CHECKWARM    ; no, let's check for warm start
 492+ 0306 CD 21 03                     call    ECHO_CHAR       ; echoes the char
 493+ 0309 3E 59        COLDSTART:      ld      A,'Y'           ; yes, set the "BASIC started" flag
 494+ 030B 32 5D 80                     ld      (basicStarted),A
 495+ 030E CD 1F 09                     call    CURSOR_OFF      ; disable cursor
 496+ 0311 C3 D8 11                     jp      COLD            ; start BASIC COLD
 497+ 0314 FE 57        CHECKWARM:      cp      'W'
 498+ 0316 20 E5                        jr      NZ,CORW         ; char not recognized, wait again
 499+ 0318 CD 21 03                     call    ECHO_CHAR       ; echoes the char
 500+ 031B CD 1F 09                     call    CURSOR_OFF      ; disable cursor
 501+ 031E C3 DB 11                     jp      WARM            ; start BASIC WARM
 502+ 0321
 503+ 0321              ;-------------------------------------------------------------------------------
 504+ 0321              ; send back char received through ch. A
 505+ 0321 32 DB 81     ECHO_CHAR:      ld      (CHR4VID),A     ; set char for video printing
 506+ 0324 AF                           xor     A
 507+ 0325 32 18 82                     ld      (KBDNPT),A      ; input is not from keyboard
 508+ 0328 F3                           di                      ; disable INTs
 509+ 0329 CD 6E 07                     call    CHAR2VID        ; echoes back the pressed key,
 510+ 032C 3E 0D                        ld      A,CR            ; then set a CR
 511+ 032E 32 DB 81                     ld      (CHR4VID),A     ; set char for video printing
 512+ 0331 CD 6E 07                     call    CHAR2VID        ; and send it to screen
 513+ 0334 FB                           ei                      ; re-enable INTs
 514+ 0335 3E 01                        ld      A,$01
 515+ 0337 32 DA 81                     ld      (PRNTVIDEO),A   ; re-enable video printing
 516+ 033A C9                           ret                     ; return to caller
 517+ 033B
 518+ 033B              ;-------------------------------------------------------------------------------
 519+ 033B              ; little serial blink with LEDs
 520+ 033B 0E 09        HELLOWRLD:      ld      C,$09           ; 8 LEDs to be turned off + 1 more step to turn off the last LED
 521+ 033D 3E CF                        ld      A,%11001111     ; set mode 3 (mode control)
 522+ 033F D3 03                        out     (PIO_CB),A      ; for PIO port B
 523+ 0341 AF                           xor     A               ; set pins to OUTPUT
 524+ 0342 D3 03                        out     (PIO_CB),A      ; for port B
 525+ 0344 3C                           inc     A               ; LSB on
 526+ 0345 D3 01        LEDLIGHT:       out     (PIO_DB),A      ; turn LEDs on/off for a "Supercar" sequence
 527+ 0347 1E 20                        ld      E,$20           ; little delay
 528+ 0349 06 00        DEC_E:          ld      B,$00           ; count to 256
 529+ 034B 10 FE        COUNTER:        djnz    COUNTER         ; decrement inner counter
 530+ 034D 1D                           dec     E               ; decrement outer counter
 531+ 034E 20 F9                        jr      NZ,DEC_E        ; finish delay
 532+ 0350 CB 27                        sla     A               ; shift reg.A to left 1 bit
 533+ 0352 0D                           dec     C               ; next LED
 534+ 0353 20 F0                        jr      NZ,LEDLIGHT     ; all LEDs done? no, repeat
 535+ 0355 C9                           ret                     ; return to caller
 536+ 0356
 537+ 0356              ;-------------------------------------------------------------------------------
 538+ 0356              ; Z80 SIO default settings for serial channels
 539+ 0356 30           SIO_A_SETS:     defb    %00110000       ; write into WR0: error reset, select WR0
 540+ 0357 18                           defb    %00011000       ; write into WR0: channel reset
 541+ 0358 04                           defb    %00000100       ; write into WR0: select WR4
 542+ 0359 44                           defb    %01000100       ; write into WR4: presc. 16x, 1 stop bit, no parity
 543+ 035A 05                           defb    %00000101       ; write into WR0: select WR5
 544+ 035B E8                           defb    %11101000       ; write into WR5: DTR on, TX 8 bits, BREAK off, TX on, RTS off
 545+ 035C 01           SIO_B_SETS:     defb    %00000001       ; write into WR0: select WR1
 546+ 035D 04                           defb    %00000100       ; write into WR1: status affects interrupt vectors
 547+ 035E 02                           defb    %00000010       ; write into WR0: select WR2
 548+ 035F 00                           defb    %00000000       ; write into WR2: set interrupt vector, but bits D3/D2/D1 of this vector
 549+ 0360                                                      ; will be affected by the channel & condition that raised the interrupt
 550+ 0360                                                      ; (see datasheet): in our example, 0x0C for Ch.A receiving A char, 0x0E
 551+ 0360                                                      ; for special conditions
 552+ 0360              ;------------------------------------------------------------------------------
 553+ 0360              ;               Z80 CTC SETTING UP
 554+ 0360              ;------------------------------------------------------------------------------
 555+ 0360              initCTC:
 556+ 0360 21 8A 03                     ld      HL,CTCCONF      ; CTC configuration
 557+ 0363 11 C1 81                     ld      DE,CTC0IV       ; CTC interrupt vector table
 558+ 0366 01 0C 00                     ld      BC,$000C        ; 12 bytes
 559+ 0369 ED B0                        ldir                    ; copy data
 560+ 036B              ;CH0, CH1, & CH2 disabled
 561+ 036B 3E 03                        ld      A,%00000011     ; interrupt off, timer mode, prescaler=16, don't care ext. TRG edge,
 562+ 036D                                                      ; start timer on loading constant, no time constant follows, software reset, command word
 563+ 036D D3 10                        out     (CTC_CH0),A     ; set CH0
 564+ 036F D3 11                        out     (CTC_CH1),A     ; set CH1
 565+ 0371 D3 12                        out     (CTC_CH2),A     ; set CH2
 566+ 0373              ;init CH3
 567+ 0373              ;CH3 divides CPU CLK by 144*256 providing an interrupt signal at 100 Hz (1/100 sec).
 568+ 0373              ;f = CPU_CLK/(144*256) => 3,686,400 / ( 36,864 ) => 100Hz
 569+ 0373 3E A7                        ld      A,%10100111     ; interrupt on; timer mode; prescaler=256; don't care ext; automatic trigger;
 570+ 0375                                                      ; time constant follows; cont. operation; command word
 571+ 0375 D3 13                        out     (CTC_CH3),A     ; send to CH3
 572+ 0377 3E 90                        ld      A,$90           ; time constant - 90$ (144d)
 573+ 0379 D3 13                        out     (CTC_CH3),A     ; send to CH3
 574+ 037B 3E 40                        ld      A,%01000000     ; D7..D3 provide the first part of the int vector (in our case, $0100), followed by
 575+ 037D                                                      ; D2..D1, provided by the CTC (they point to the channel), D0=interrupt word
 576+ 037D                                                      ; so int vector is 01000xx00
 577+ 037D D3 10                        out     (CTC_CH0),A     ; send to CTC
 578+ 037F                              ; reset cells of 100ths of a second counter
 579+ 037F AF                           xor     A               ; reset A
 580+ 0380 21 BD 81                     ld      HL,TMRCNT       ; load TMR pointer
 581+ 0383 06 04                        ld      B,$04           ; 4 memory cells
 582+ 0385 77           RESTMR:         ld      (HL),A          ; reset n-cell of TMR
 583+ 0386 23                           inc     HL              ; next cell
 584+ 0387 10 FC                        djnz    RESTMR          ; repeat for 4 cells
 585+ 0389 C9                           ret
 586+ 038A
 587+ 038A
 588+ 038A              ;------------------------------------------------------------------------------
 589+ 038A              ; jump table for CHx interrupts
 590+ 038A FB ED 4D     CTCCONF:        defb    $FB,$ED,$4D     ; CTC0 interrupt vector (ei; reti)
 591+ 038D FB ED 4D                     defb    $FB,$ED,$4D     ; CTC1 interrupt vector (ei; reti)
 592+ 0390 FB ED 4D                     defb    $FB,$ED,$4D     ; CTC2 interrupt vector (ei; reti)
 593+ 0393 C3 8D 02                     jp      CH3_TIMER       ; CTC3 interrupt vector (jump to execute sys-tick timer)
 594+ 0396
 595+ 0396
 596+ 0396              ;------------------------------------------------------------------------------
 597+ 0396              ; welcome messages
 598+ 0396 20 20 20 20  MSGTXT1:        defm    "      LM80C Color Computer",CR
 598+ 039A 20 20 4C 4D
 598+ 039E 38 30 43 20
 598+ 03A2 43 6F 6C 6F
 598+ 03A6 72 20 43 6F
 598+ 03AA 6D 70 75 74
 598+ 03AE 65 72 0D
 599+ 03B1 20 62 79 20                  defm    " by Leonardo Miliani * FW R3.16",CR,0
 599+ 03B5 4C 65 6F 6E
 599+ 03B9 61 72 64 6F
 599+ 03BD 20 4D 69 6C
 599+ 03C1 69 61 6E 69
 599+ 03C5 20 2A 20 46
 599+ 03C9 57 20 52 33
 599+ 03CD 2E 31 36 0D
 599+ 03D1 00
 600+ 03D2 0D           MSGTXT2:        defb    CR
 601+ 03D3 20 20 20 3C                  defm    "   <C>old or <W>arm start? ",0
 601+ 03D7 43 3E 6F 6C
 601+ 03DB 64 20 6F 72
 601+ 03DF 20 3C 57 3E
 601+ 03E3 61 72 6D 20
 601+ 03E7 73 74 61 72
 601+ 03EB 74 3F 20 00
 602+ 03EF
# file closed: ../include/bootloader/bootloader-r316.asm
  64  03EF
  65  03EF              ; incude the latest version of the VDP module
  66  03EF                  INCLUDE "../include/vdp/vdp-r316.asm"
# file opened: ../include/vdp/vdp-r316.asm
   1+ 03EF              ; ------------------------------------------------------------------------------
   2+ 03EF              ; LM80C - VDP ROUTINES - R3.16
   3+ 03EF              ; ------------------------------------------------------------------------------
   4+ 03EF              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 03EF              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 03EF              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 03EF              ; kind of warranty: you can use them at your own risk.
   8+ 03EF              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 03EF              ; maintain the copyright notices, include this advice and the note to the
  10+ 03EF              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 03EF              ; redistribuite them.
  12+ 03EF              ; https://www.leonardomiliani.com
  13+ 03EF              ;
  14+ 03EF              ; Please support me by visiting the following links:
  15+ 03EF              ; Main project page: https://www.leonardomiliani.com
  16+ 03EF              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 03EF              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 03EF              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 03EF              ; ------------------------------------------------------------------------------
  20+ 03EF              ;
  21+ 03EF              ;------------------------------------------------------------------------------
  22+ 03EF              ; VDP INITIALISATION
  23+ 03EF              ; initialize VDP for a specific graphics mode
  24+ 03EF              ; INPUT: E -> contains the graphics mode:
  25+ 03EF              ; 0=text; 1=graphics 1; 2=graphics 2; 3=multicolor; 4=extended graphics 2
  26+ 03EF D5           initVDP:        push    DE              ; store E
  27+ 03F0 CD AE 0A                     call    EMPTY_VRAM      ; reset VRAM
  28+ 03F3 CD CD 0A                     call    SET_GFX_MODE    ; load register settings
  29+ 03F6 CD C2 0A                     call    CLR_RAM_REG     ; reset RAM registers
  30+ 03F9 D1                           pop     DE              ; restore reg. E
  31+ 03FA AF                           xor     A               ; reset A
  32+ 03FB 47                           ld      B,A             ; reset B (will be used later)
  33+ 03FC 7B                           ld      A,E             ; move E into A
  34+ 03FD 32 CF 81                     ld      (SCR_MODE),A    ; store screen mode
  35+ 0400 FE 01                        cp      $01             ; is it graphics 1 (A=1)?
  36+ 0402 CA 3E 04                     jp      Z,G1MD          ; yes, jump over
  37+ 0405 FE 02                        cp      $02             ; is it graphics 2 (A=2)?
  38+ 0407 CA 7F 04                     jp      Z,G2MD          ; yes, jump over
  39+ 040A FE 03                        cp      $03             ; is it multicolor (A=3)?
  40+ 040C CA A1 04                     jp      Z,MCMD          ; yes, jump over
  41+ 040F FE 04                        cp      $04             ; is it extended graphics 2 (A=4)?
  42+ 0411 CA C4 04                     jp      Z,EXG2MD        ; yes, jump over; otherwise, it must be $00 so we assume that it's text mode
  43+ 0414
  44+ 0414                              ; LOAD VDP SETTINGS FOR SELECTED VIDEO MODE:
  45+ 0414                              ; TEXT MODE (G0)
  46+ 0414              TXTMD:          ; load charset
  47+ 0414 60                           ld      H,B
  48+ 0415 68                           ld      L,B             ; HL=first pattern cell $0000
  49+ 0416 CD E9 0A                     call    LOADCHARSET     ; load patterns into VRAM
  50+ 0419                              ; set cursor & video overlay
  51+ 0419 AF                           xor     A               ; reset A
  52+ 041A 32 D3 81                     ld      (SCR_CURS_X),A  ; set cursor position at X=0
  53+ 041D 32 D4 81                     ld      (SCR_CURS_Y),A  ; and Y=0
  54+ 0420 3E 05                        ld      A,$05           ; light blue
  55+ 0422 32 DD 81                     ld      (BKGNDCLR),A    ; set background/border color
  56+ 0425 3E 28                        ld      A,$28
  57+ 0427 32 CD 81                     ld      (SCR_SIZE_W),A  ; screen width = 40 cols
  58+ 042A 3E 18                        ld      A,$18
  59+ 042C 32 CE 81                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  60+ 042F 3E 1E                        ld      A,$1E
  61+ 0431 32 A3 80                     ld      (COMMAN),A      ; width for commas (4 columns)
  62+ 0434 11 00 08                     ld      DE,$0800
  63+ 0437 ED 53 D1 81                  ld      (SCR_NAM_TB),DE ; set name table address
  64+ 043B C3 07 05                     jp      ENDVDPSET       ; execute the rest of the video setting
  65+ 043E
  66+ 043E                              ; GRAPHICS 1 MODE (G1)
  67+ 043E              G1MD:           ; load pattern table
  68+ 043E 68                           ld      L,B
  69+ 043F 60                           ld      H,B             ; HL=first pattern cell $0000
  70+ 0440 CD E9 0A                     call    LOADCHARSET     ; load patterns into VRAM
  71+ 0443                              ; set cursor & video overlay
  72+ 0443 AF                           xor     A               ; position cursor
  73+ 0444 32 D3 81                     ld      (SCR_CURS_X),A  ; at X=0
  74+ 0447 32 D4 81                     ld      (SCR_CURS_Y),A  ; and Y=0
  75+ 044A 3E 20                        ld      A,$20
  76+ 044C 32 CD 81                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
  77+ 044F 3E 18                        ld      A,$18
  78+ 0451 32 CE 81                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  79+ 0454 3E 14                        ld      A,$14
  80+ 0456 32 A3 80                     ld      (COMMAN),A      ; width for commas (3 columns)
  81+ 0459 11 00 18                     ld      DE,$1800
  82+ 045C ED 53 D1 81                  ld      (SCR_NAM_TB),DE ; set name table address
  83+ 0460                              ; load color table
  84+ 0460 21 00 20                     ld      HL,$2000        ; color table start: $2000
  85+ 0463 CD 7D 06                     call    SETVDPADRS
  86+ 0466 3E 01                        ld      A,$01           ; foreground color...
  87+ 0468 32 DC 81                     ld      (FRGNDCLR),A    ; ...set to black
  88+ 046B 3E 0F                        ld      A,$0F           ; background color...
  89+ 046D 32 DD 81                     ld      (BKGNDCLR),A    ; ...set to white
  90+ 0470 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
  91+ 0472 06 20                        ld      B,$20           ; 32 bytes of colors
  92+ 0474 0E 30                        ld      C,VDP_DAT       ; VDP data mode
  93+ 0476 ED 79        LDCLRTBMD1:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
  94+ 0478 00                           nop
  95+ 0479 00                           nop
  96+ 047A 10 FA                        djnz    LDCLRTBMD1      ; repeat for 32 bytes
  97+ 047C C3 07 05                     jp      ENDVDPSET       ; execute the rest of the video setting
  98+ 047F
  99+ 047F                              ; GRAPHICS 2 MODE (G2)
 100+ 047F AF           G2MD:           xor     A               ; position cursor
 101+ 0480 32 D3 81                     ld      (SCR_CURS_X),A  ; at X=0
 102+ 0483 32 D4 81                     ld      (SCR_CURS_Y),A  ; and Y=0
 103+ 0486 32 CD 81                     ld      (SCR_SIZE_W),A  ; screen width = 256 pixels (0=256)
 104+ 0489 3C                           inc     A               ; black on...
 105+ 048A 32 DC 81                     ld      (FRGNDCLR),A    ; ...foreground
 106+ 048D 3E 0F                        ld      A,$0F           ; white on...
 107+ 048F 32 DD 81                     ld      (BKGNDCLR),A    ; ...background
 108+ 0492 3E C0                        ld      A,$C0
 109+ 0494 32 CE 81                     ld      (SCR_SIZE_H),A  ; screen height = 192 pixels
 110+ 0497 11 00 18                     ld      DE,$1800
 111+ 049A ED 53 D1 81                  ld      (SCR_NAM_TB),DE ; set name table address
 112+ 049E C3 07 05                     jp      ENDVDPSET       ; execute the rest of the video setting
 113+ 04A1
 114+ 04A1                              ; MULTICOLOR MODE (G3)
 115+ 04A1 AF           MCMD:           xor     A               ; position cursor
 116+ 04A2 32 D3 81                     ld      (SCR_CURS_X),A  ; at X=0
 117+ 04A5 32 D4 81                     ld      (SCR_CURS_Y),A  ; and Y=0
 118+ 04A8 3E 0F                        ld      A,$0F           ; white color for...
 119+ 04AA 32 DD 81                     ld      (BKGNDCLR),A    ; ...background and...
 120+ 04AD 32 DC 81                     ld      (FRGNDCLR),A    ; ...foreground (even this is not used in MC)
 121+ 04B0 3E 40                        ld      A,$40
 122+ 04B2 32 CD 81                     ld      (SCR_SIZE_W),A  ; screen width = 64 blocks
 123+ 04B5 3E 30                        ld      A,$30
 124+ 04B7 32 CE 81                     ld      (SCR_SIZE_H),A  ; screen height = 48 blocks
 125+ 04BA 11 00 08                     ld      DE,$0800
 126+ 04BD ED 53 D1 81                  ld      (SCR_NAM_TB),DE ; set name table address
 127+ 04C1 C3 07 05                     jp      ENDVDPSET       ; execute the rest of the video setting
 128+ 04C4
 129+ 04C4                              ; EXTENDED GRAPHICS 2 (G4)
 130+ 04C4              EXG2MD:         ; load pattern table
 131+ 04C4 60                           ld      H,B
 132+ 04C5 68                           ld      L,B             ; HL=first pattern cell $0000
 133+ 04C6 CD E9 0A                     call    LOADCHARSET     ; load patterns into VRAM
 134+ 04C9                              ; set cursor & video overlay
 135+ 04C9 AF                           xor     A               ; position cursor
 136+ 04CA 32 D3 81                     ld      (SCR_CURS_X),A  ; at X=0
 137+ 04CD 32 D4 81                     ld      (SCR_CURS_Y),A  ; and Y=0
 138+ 04D0 3E 20                        ld      A,$20
 139+ 04D2 32 CD 81                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
 140+ 04D5 3E 18                        ld      A,$18
 141+ 04D7 32 CE 81                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
 142+ 04DA 3E 14                        ld      A,$14
 143+ 04DC 32 A3 80                     ld      (COMMAN),A      ; width for commas (3 columns)
 144+ 04DF 11 00 38                     ld      DE,$3800
 145+ 04E2 ED 53 D1 81                  ld      (SCR_NAM_TB),DE ; set name table address
 146+ 04E6                               ; load color table
 147+ 04E6 21 00 20                     ld      HL,$2000        ; color table start: $2000
 148+ 04E9 CD 7D 06                     call    SETVDPADRS
 149+ 04EC 3E 01                        ld      A,$01           ; foreground color is...
 150+ 04EE 32 DC 81                     ld      (FRGNDCLR),A    ; ...set to black
 151+ 04F1 3E 0F                        ld      A,$0F           ; whitefor...
 152+ 04F3 32 DD 81                     ld      (BKGNDCLR),A    ; ...background
 153+ 04F6 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
 154+ 04F8 16 08                        ld      D,$08           ; 8 pages of
 155+ 04FA 06 00                        ld      B,$00           ; 256 bytes of colors (total of 2,048 cells)
 156+ 04FC 0E 30                        ld      C,VDP_DAT       ; VDP data mode
 157+ 04FE ED 79        LDCLRTBEX2:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
 158+ 0500 00                           nop
 159+ 0501 00                           nop
 160+ 0502 10 FA                        djnz    LDCLRTBEX2      ; repeat for 256 bytes
 161+ 0504 15                           dec     D               ; did we fill up all the cells?
 162+ 0505 20 F7                        jr      NZ,LDCLRTBEX2   ; no, repeat
 163+ 0507                              ; LAST VDP SETTINGS
 164+ 0507 CD 1F 09     ENDVDPSET:      call    CURSOR_OFF      ; disable cursor
 165+ 050A CD EB 05                     call    EMPTYVIDBUF     ; empty video buffer
 166+ 050D AF                           xor     A
 167+ 050E 32 D7 81                     ld      (SCR_ORG_CHR),A ; store byte used tochar used to empty the video buffer
 168+ 0511 C9                           ret                     ; return to caller
 169+ 0512
 170+ 0512
 171+ 0512              ; show initial logo
 172+ 0512 CD AE 0A     SHOW_LOGO:      call    EMPTY_VRAM      ; reset VRAM
 173+ 0515                              ; set VDP for G2 mode
 174+ 0515 06 07                        ld      B,$07           ; set only the first 7 registers
 175+ 0517 11 10 00                     ld      DE,$0010        ; load settings for G2 mode
 176+ 051A CD D5 0A                     call    SET_GFX_MODE2   ; load register settings
 177+ 051D 16 01                        ld      D,$01           ; backdrop color set to black
 178+ 051F ED 51                        out     (C),D           ; send data to VDP
 179+ 0521 ED 79                        out     (C),A           ; indicate the register to send data to
 180+ 0523                              ; set name table
 181+ 0523 21 00 18                     ld      HL,$1800        ; name table address
 182+ 0526 CD 6A 06                     call    SETNAMETABLE    ; set name table (load names into table)
 183+ 0529 CD 89 05                     call    ERASECLRTBL     ; erase color table (set foreground & background to black)
 184+ 052C                              ; set colors for logo
 185+ 052C 21 00 28                     ld      HL,$2800        ; 2nd page of color table
 186+ 052F CD 7D 06                     call    SETVDPADRS
 187+ 0532 06 05                        ld      B,5             ; 5 bands
 188+ 0534 21 D6 05                     ld      HL,CLRTABLE
 189+ 0537 0E 30                        ld      C,VDP_DAT
 190+ 0539 1E 08                        ld      E,$08           ; 8 pixels each pattern
 191+ 053B 16 40        RPT101:         ld      D,$40           ; 64 chars each band
 192+ 053D 7E                           ld      A,(HL)
 193+ 053E ED 79        RPT102:         out     (C),A
 194+ 0540 00                           nop
 195+ 0541 1D                           dec     E
 196+ 0542 20 FA                        jr      NZ,RPT102
 197+ 0544 1E 08                        ld      E,$08
 198+ 0546 15                           dec     D
 199+ 0547 20 F5                        jr      NZ,RPT102
 200+ 0549 23                           inc     HL
 201+ 054A 10 EF                        djnz    RPT101
 202+ 054C                              ; set pattern table
 203+ 054C 21 00 08                     ld      HL,$0800        ; address of first cell of 2nd area of pattern table
 204+ 054F 11 32 0B                     ld      DE,LM80CLOGO    ; pointer to logo pattern
 205+ 0552 06 00                        ld      B,$00           ; 256 bytes, 8 rows
 206+ 0554 CD B5 05     RPT103:         call    LOADLOGOCHRS
 207+ 0557 13                           inc     DE              ; next logo pattern
 208+ 0558 10 FA                        djnz    RPT103
 209+ 055A 06 20                        ld      B,$20           ; repeat for another 2 rows
 210+ 055C CD B5 05     RPT104:         call    LOADLOGOCHRS
 211+ 055F 13                           inc     DE              ; next logo pattern
 212+ 0560 10 FA                        djnz    RPT104
 213+ 0562                              ; show logo/message, play a beep, check for SHIFT pressure (to disable DOS), and wait a while
 214+ 0562 06 02                        ld      B,$02
 215+ 0564 AF                           xor     A
 216+ 0565 57                           ld      D,A             ; 256 times
 217+ 0566 5F                           ld      E,A             ; x 256 times
 218+ 0567 32 DE 81                     ld      (TMPBFR1),A     ; sound flag set to 0
 219+ 056A                              ;inc     A               ; A=1 ----- DISABLED AT THE MOMENT!
 220+ 056A 32 23 82                     ld      (DOS_EN),A      ; DOS enabled
 221+ 056D 00           DEC_D:          nop                     ; does nothing...
 222+ 056E 00                           nop
 223+ 056F 00                           nop
 224+ 0570 00                           nop
 225+ 0571 00                           nop
 226+ 0572 00                           nop
 227+ 0573 1D                           dec     E               ; decrement E
 228+ 0574 20 F7                        jr      NZ,DEC_D        ; repeat until $00
 229+ 0576 7A                           ld      A,D
 230+ 0577 FE 40                        cp      $40             ; ...equal to 64
 231+ 0579 CC A1 05                     call    Z,SETBEEP       ; if yes, start sound
 232+ 057C 15                           dec     D
 233+ 057D 20 EE                        jr      NZ,DEC_D        ; repeat
 234+ 057F 3A DE 81                     ld      A,(TMPBFR1)
 235+ 0582 FE 02                        cp      $02
 236+ 0584 C4 AD 05                     call    NZ,BEEPOFF
 237+ 0587                              ;call    CHECKSHIFT     DISABLED AT THE MOMENT!
 238+ 0587 10 E4                        djnz    DEC_D
 239+ 0589              ERASECLRTBL:    ; erase color table
 240+ 0589 3E 11                        ld      A,$11           ; foreground and background set to black
 241+ 058B 16 0A                        ld      D,$0A           ; 10 pages
 242+ 058D 06 00                        ld      B,$00           ; 256 color cells per page
 243+ 058F 21 00 28                     ld      HL,$2800        ; first cell of 2nd color table
 244+ 0592 CD 7D 06                     call    SETVDPADRS      ; send address
 245+ 0595 0E 30                        ld      C,VDP_DAT       ; VDP address for passing data
 246+ 0597 ED 79        RPT100:         out     (C),A           ; send data
 247+ 0599 00                           nop
 248+ 059A 00                           nop                     ; little delay
 249+ 059B 10 FA                        djnz    RPT100          ; repeat for entire page
 250+ 059D 15                           dec     D
 251+ 059E 20 F7                        jr      NZ,RPT100       ; repeat for all the pages ($0A00 cells)
 252+ 05A0 C9                           ret                     ; return to caller
 253+ 05A1
 254+ 05A1              ; play a beep
 255+ 05A1 3A DE 81     SETBEEP:        ld      A,(TMPBFR1)     ; check the already-beeped flag
 256+ 05A4 B7                           or      A               ; is it 0?
 257+ 05A5 C0                           ret     NZ              ; no, exit
 258+ 05A6 3C                           inc     A               ; flag to 1
 259+ 05A7 32 DE 81                     ld      (TMPBFR1),A     ; set sound
 260+ 05AA C3 A0 0C                     jp      WLCMBEEP        ; play a beep & return
 261+ 05AD
 262+ 05AD              ; beep off
 263+ 05AD 3E 02        BEEPOFF:        ld      A,$02           ; flag for sound off
 264+ 05AF 32 DE 81                     ld      (TMPBFR1),A     ; set flag
 265+ 05B2 C3 A6 0C                     jp      NOBEEP          ; stop beep and return
 266+ 05B5
 267+ 05B5
 268+ 05B5              ; used to load the chars that will compose the logo of the splash screen
 269+ 05B5 1A           LOADLOGOCHRS:   ld      A,(DE)          ; load a pattern char of the logo
 270+ 05B6 87                           add     A,A
 271+ 05B7 87                           add     A,A
 272+ 05B8 87                           add     A,A             ; multiply times 8 to get the offset
 273+ 05B9 C5                           push    BC
 274+ 05BA D5                           push    DE              ; store BC and DE
 275+ 05BB E5                           push    HL              ; store VRAM address to write to
 276+ 05BC 21 12 50                     ld      HL,LOGOFONT     ; start of logo font data
 277+ 05BF 5F                           ld      E,A
 278+ 05C0 16 00                        ld      D,$00           ; put offset (A) into DE
 279+ 05C2 19                           add     HL,DE           ; get address of pattern data
 280+ 05C3 EB                           ex      DE,HL           ; move address into DE
 281+ 05C4 E1                           pop     HL              ; retrieve VRAM address
 282+ 05C5 06 08                        ld      B,$08           ; 8 bytes per pattern
 283+ 05C7 CD 7D 06                     call    SETVDPADRS      ; set VDP address
 284+ 05CA 0E 30                        ld      C,VDP_DAT
 285+ 05CC 1A           SNDLOGPT:       ld      A,(DE)          ; load data from RAM
 286+ 05CD ED 79                        out     (C),A           ; and send to VRAM
 287+ 05CF 13                           inc     DE              ; next byte into RAM
 288+ 05D0 23                           inc     HL              ; next byte into VRAM (used in future iterations)
 289+ 05D1 10 F9                        djnz    SNDLOGPT        ; repeat 8 times
 290+ 05D3 D1                           pop     DE
 291+ 05D4 C1                           pop     BC              ; retrieve BC & DE
 292+ 05D5 C9                           ret                     ; return to caller
 293+ 05D6              CLRTABLE:       equ $
 294+ 05D6 18 1B 13 14                  defb    $18,$1B,$13,$14,$1D ; colors of background bands of the logo
 294+ 05DA 1D
 295+ 05DB
 296+ 05DB
 297+ 05DB              ; while showing the logo, check if SPACE bar is being pressed
 298+ 05DB              ; if yes, then disable DOS functions recovering RAM
 299+ 05DB F5           CHECKSHIFT:     push    AF
 300+ 05DC 3E FD                        ld      A,%11111101     ; select SHIFT row
 301+ 05DE CD 24 0D                     call    READKBLN        ; read row
 302+ 05E1 CB 5F                        bit     3,A             ; test if SHIFT key is pressed (4th bit is reset)
 303+ 05E3 20 04                        jr      NZ,LVCKSHF      ; no, leave
 304+ 05E5 AF                           xor     A               ; yes, so...
 305+ 05E6 32 23 82                     ld      (DOS_EN),A      ; ...disable DOS
 306+ 05E9 F1           LVCKSHF:        pop     AF
 307+ 05EA C9                           ret
 308+ 05EB
 309+ 05EB
 310+ 05EB              ; empty video buffer
 311+ 05EB 3A CF 81     EMPTYVIDBUF:    ld      A,(SCR_MODE)    ; check screen mode
 312+ 05EE FE 02                        cp      $02             ; is it G2 mode?
 313+ 05F0 CA 14 06                     jp      Z,EMPTYG2       ; yes, jump over
 314+ 05F3 FE 03                        cp      $03             ; is it MC mode?
 315+ 05F5 CA 45 06                     jp      Z,EMPTYMC       ; yes, jump over
 316+ 05F8 3A CE 81                     ld      A,(SCR_SIZE_H)  ; load height of screen
 317+ 05FB 47                           ld      B,A             ; move rows into B
 318+ 05FC AF                           xor     A               ; filling char is $00
 319+ 05FD 2A D1 81                     ld      HL,(SCR_NAM_TB) ; load the name table address
 320+ 0600 CD 7D 06                     call    SETVDPADRS      ; send address to VDP
 321+ 0603 0E 30                        ld      C,VDP_DAT       ; VDP address for passing data
 322+ 0605 5F           LDCOLSTOEMPTY:  ld      E,A             ; store filling char into E
 323+ 0606 3A CD 81                     ld      A,(SCR_SIZE_W)  ; load # of cols to empty into A
 324+ 0609 57                           ld      D,A             ; move A into D
 325+ 060A 7B                           ld      A,E             ; recover filling char
 326+ 060B ED 79        RPTEMPTYBUF:    out     (C),A           ; write empty byte into VRAM
 327+ 060D 00                           nop
 328+ 060E 15                           dec     D               ; decr. D
 329+ 060F 20 FA                        jr      NZ,RPTEMPTYBUF  ; repeat for the # of cols
 330+ 0611 10 F2                        djnz    LDCOLSTOEMPTY   ; repeat for the # of rows
 331+ 0613 C9                           ret                     ; return to caller
 332+ 0614 2A D1 81     EMPTYG2:        ld      HL,(SCR_NAM_TB) ; yes, additional setup for G2 - load G2 name table address (usually $1800)
 333+ 0617 CD 6A 06                     call    SETNAMETABLE    ; set name table
 334+ 061A 21 00 00                     ld      HL,$0000        ; set pattern table
 335+ 061D CD 7D 06                     call    SETVDPADRS      ; send address to VDP
 336+ 0620 AF                           xor     A               ; empty pattern
 337+ 0621 16 18                        ld      D,$18           ; 6144 ($1800) cell to clean, 24 pages ($18)
 338+ 0623 47                           ld      B,A             ; 256 bytes for page
 339+ 0624 0E 30                        ld      C,VDP_DAT       ; VDP data mode
 340+ 0626 ED 79        CLRG2PTNTBL:    out     (C),A           ; clear pattern
 341+ 0628 00                           nop                     ; little delay
 342+ 0629 00                           nop
 343+ 062A 10 FA                        djnz    CLRG2PTNTBL     ; repeat for 1 page
 344+ 062C 15                           dec     D               ; next page
 345+ 062D 20 F7                        jr      NZ,CLRG2PTNTBL  ; repeat
 346+ 062F 21 00 20                     ld      HL,$2000        ; load the color table address
 347+ 0632 CD 7D 06                     call    SETVDPADRS      ; send address to VDP
 348+ 0635 3A DC 81                     ld      A,(FRGNDCLR)    ; load foreground
 349+ 0638 87                           add     A,A
 350+ 0639 87                           add     A,A
 351+ 063A 87                           add     A,A
 352+ 063B 87                           add     A,A             ; move to high nibble
 353+ 063C 57                           ld      D,A             ; store into D
 354+ 063D 3A DD 81                     ld      A,(BKGNDCLR)    ; load background color
 355+ 0640 B2                           or      D               ; combine with background color
 356+ 0641 16 18                        ld      D,$18           ; 6144 ($1800) cells to fill, so 24 pages ($18)
 357+ 0643 18 17                        jr      STARTEMPTY
 358+ 0645 21 00 08     EMPTYMC:        ld      HL,$0800        ; MC name table
 359+ 0648 CD 6A 06                     call    SETNAMETABLE    ; set name table
 360+ 064B 21 00 00                     ld      HL,$0000        ; color table address
 361+ 064E CD 7D 06                     call    SETVDPADRS      ; send address to VDP
 362+ 0651 3A DD 81                     ld      A,(BKGNDCLR)    ; load background
 363+ 0654 57                           ld      D,A             ; store into D
 364+ 0655 87                           add     A,A
 365+ 0656 87                           add     A,A
 366+ 0657 87                           add     A,A
 367+ 0658 87                           add     A,A             ; move to high nibble
 368+ 0659 B2                           or      D               ; set background color for high and low nibble
 369+ 065A 16 08                        ld      D,$08           ; 2048 ($0800) cells to fill, so 8 pages ($08)
 370+ 065C 0E 30        STARTEMPTY:     ld      C,VDP_DAT       ; VDP address for passing data
 371+ 065E 06 00                        ld      B,$00           ; 256 bytes each page ($00=256)
 372+ 0660 ED 79        SNDCLRSET:      out     (C),A           ; send color setting
 373+ 0662 00                           nop                     ; wait a while
 374+ 0663 00                           nop
 375+ 0664 10 FA                        djnz    SNDCLRSET       ; repeat for 1 page
 376+ 0666 15                           dec     D               ; have we filled all the pages?
 377+ 0667 20 F7                        jr      NZ,SNDCLRSET    ; no, repeat
 378+ 0669 C9                           ret                     ; return to caller
 379+ 066A
 380+ 066A              ; set name table for G2 mode (patterns from $00 to $FF for each of the 3 areas of the screen)
 381+ 066A CD 7D 06     SETNAMETABLE:   call    SETVDPADRS      ; send address to VDP
 382+ 066D 0E 30                        ld      C,VDP_DAT       ; VDP address for passing data
 383+ 066F 16 03                        ld      D,$03           ; 3 pages to fill into VRAM (768 cells)
 384+ 0671 AF                           xor     A               ; starting char name #0 (chars go from 0 to 255)
 385+ 0672 47                           ld      B,A             ; reset B
 386+ 0673 ED 79        RPTFLL1:        out     (C),A           ; send name to VRAM
 387+ 0675 00                           nop
 388+ 0676 3C                           inc     A               ; increment # of name
 389+ 0677 10 FA                        djnz    RPTFLL1         ; repeat for 256 cells (1 page)
 390+ 0679 15                           dec     D               ; did we fill all the pages?
 391+ 067A 20 F7                        jr      NZ,RPTFLL1      ; no, continue
 392+ 067C C9                           ret                     ; return to caller
 393+ 067D
 394+ 067D              ; set an address into VRAM: address is in HL
 395+ 067D 0E 32        SETVDPADRS:     ld      C,VDP_SET       ; VDP address mode
 396+ 067F CB F4                        set     6,H             ; set bit #6 of address, to write to VRAM
 397+ 0681 ED 69                        out     (C),L           ; send low and...
 398+ 0683 ED 61                        out     (C),H           ; ...high byte of the first cell
 399+ 0685 C9                           ret                     ; return to caller
 400+ 0686
 401+ 0686              ; clear the video buffer and position the cursor at 0,0
 402+ 0686 CD EB 05     CLEARVIDBUF:    call    EMPTYVIDBUF     ; clear video buffer
 403+ 0689 AF                           xor     A               ; reset A
 404+ 068A 32 D3 81                     ld      (SCR_CURS_X),A  ; cursor X to 0
 405+ 068D 32 D4 81                     ld      (SCR_CURS_Y),A  ; cursor Y to 0
 406+ 0690 C3 D9 06                     jp      POS_CURSOR      ; position cursor & return to caller
 407+ 0693
 408+ 0693              ; HOME: position the cursor at coords. 0,0
 409+ 0693 AF           ATHOME:         xor     A               ; position cursor at 0,0 by storing...
 410+ 0694 32 D6 81                     ld      (SCR_CUR_NY),A  ; ...new Y...
 411+ 0697 32 D5 81                     ld      (SCR_CUR_NX),A  ; ...and new X
 412+ 069A C3 E3 06                     jp      MOVCRS          ; move cursor to new location & return to caller
 413+ 069D
 414+ 069D              ; load the char or byte at the VRAM position set by HL
 415+ 069D              ; value is returned into A
 416+ 069D C5           READ_VIDEO_LOC: push    BC              ; store BC
 417+ 069E 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 418+ 06A0 44                           ld      B,H
 419+ 06A1 CB B8                        res     7,B
 420+ 06A3 CB B0                        res     6,B
 421+ 06A5 ED 69                        out     (C),L           ; low byte then...
 422+ 06A7 ED 41                        out     (C),B           ; high byte
 423+ 06A9 0E 30                        ld      C,VDP_DAT       ; VDP data mode
 424+ 06AB 00                           nop                     ; wait...
 425+ 06AC 00                           nop                     ; ...a while
 426+ 06AD 00                           nop
 427+ 06AE ED 78                        in      A,(C)           ; read byte at current VRAM location
 428+ 06B0 C1                           pop     BC              ; restore BC
 429+ 06B1 C9                           ret                     ; return to caller
 430+ 06B2
 431+ 06B2              ; write a byte at the VRAM position pointed by HL
 432+ 06B2              ; value is in A
 433+ 06B2 C5           WRITE_VIDEO_LOC:push    BC              ; store BC
 434+ 06B3 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 435+ 06B5 44                           ld      B,H             ; copy H into B
 436+ 06B6 CB B8                        res     7,B
 437+ 06B8 CB F0                        set     6,B             ; write to VRAM
 438+ 06BA ED 69                        out     (C),L           ; low byte then...
 439+ 06BC ED 41                        out     (C),B           ; high byte of VRAM address
 440+ 06BE 0E 30                        ld      C,VDP_DAT       ; VDP data mode
 441+ 06C0 00                           nop                     ; wait...
 442+ 06C1 00                           nop                     ; ...a while
 443+ 06C2 00                           nop
 444+ 06C3 ED 79                        out     (C),A           ; write byte into VRAM
 445+ 06C5 C1                           pop     BC              ; restore BC
 446+ 06C6 C9                           ret                     ; return to caller
 447+ 06C7
 448+ 06C7              ; write a value into a specific VDP register
 449+ 06C7              ; value is in E, register is in A
 450+ 06C7 C5           WRITE_VREG:     push    BC              ; store BC
 451+ 06C8 C6 80                        add     A,$80           ; set VDP to write to registers
 452+ 06CA 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 453+ 06CC ED 59                        out     (C),E           ; send data to VDP
 454+ 06CE ED 79                        out     (C),A           ; select the destination register
 455+ 06D0 C1                           pop     BC              ; restore BC
 456+ 06D1 C9                           ret                     ; return to caller
 457+ 06D2
 458+ 06D2              ; read VDP status register and return value into A
 459+ 06D2 C5           READ_VSTAT:     push    BC              ; store BC
 460+ 06D3 0E 32                        ld      C,VDP_SET       ; VDP register access
 461+ 06D5 ED 78                        in      A,(C)           ; read status register
 462+ 06D7 C1                           pop     BC              ; restore BC
 463+ 06D8 C9                           ret                     ; return to caller
 464+ 06D9
 465+ 06D9              ; position the cursor at the current coordinates, preserving underlying char
 466+ 06D9 CD 1C 07     POS_CURSOR:     call    LOAD_CRSR_POS   ; load the VRAM address of cursor into HL
 467+ 06DC CD 9D 06                     call    READ_VIDEO_LOC  ; load the current char at the cursor position (return in A)
 468+ 06DF 32 D7 81                     ld      (SCR_ORG_CHR),A ; store the current char
 469+ 06E2 C9                           ret
 470+ 06E3
 471+ 06E3              ; move cursor to new X,Y coordinates
 472+ 06E3 CD 13 07     MOVCRS:         call    RSTCHRCRS       ; restore the char in the current cursor position
 473+ 06E6 CD FE 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 474+ 06E9 CD D9 06     MOVSHOWCRS:     call    POS_CURSOR      ; position cursor into new location
 475+ 06EC 3A D8 81                     ld      A,(CRSR_STATE)  ; load status of cursor
 476+ 06EF A7                           and     A               ; is cursor off?
 477+ 06F0 C8                           ret     Z               ; yes, return
 478+ 06F1 3A BD 81                     ld      A,(TMRCNT)      ; it's visible, so...
 479+ 06F4 E6 20                        and     $20             ; ...set cursor on
 480+ 06F6 32 D9 81                     ld      (LSTCSRSTA),A   ; store the last cursor state
 481+ 06F9 3E FF                        ld      A,$FF           ; set cursor visible after moved it
 482+ 06FB C3 B2 06                     jp      WRITE_VIDEO_LOC ; write into video cell
 483+ 06FE
 484+ 06FE
 485+ 06FE              ; set new cursor's coordinates:
 486+ 06FE 3A D5 81     NEWCRSRCOORD:   ld      A,(SCR_CUR_NX)  ; load new X
 487+ 0701 32 D3 81                     ld      (SCR_CURS_X),A  ; write new X
 488+ 0704 3A D6 81                     ld      A,(SCR_CUR_NY)  ; load new Y
 489+ 0707 32 D4 81                     ld      (SCR_CURS_Y),A  ; write new Y
 490+ 070A 3E FF                        ld      A,$FF           ; delete new values
 491+ 070C 32 D5 81                     ld      (SCR_CUR_NX),A  ; of X
 492+ 070F 32 D6 81                     ld      (SCR_CUR_NY),A  ; and Y
 493+ 0712 C9                           ret
 494+ 0713
 495+ 0713              ; recover char under the cursor and prints it onto the screen
 496+ 0713 CD 1C 07     RSTCHRCRS:      call    LOAD_CRSR_POS   ; recover old cursor position
 497+ 0716 3A D7 81                     ld      A,(SCR_ORG_CHR) ; recover old char
 498+ 0719 C3 B2 06                     jp      WRITE_VIDEO_LOC ; write char into VRAM & return
 499+ 071C
 500+ 071C              ; retrieve cursor position from either current coordinates or next place
 501+ 071C              ; return address position into HL
 502+ 071C 3A D4 81     LOAD_CRSR_POS:  ld      A,(SCR_CURS_Y)  ; load cursor Y
 503+ 071F 6F                           ld      L,A             ; move it into reg.L
 504+ 0720 AF                           xor     A               ; reset A
 505+ 0721 67                           ld      H,A             ; reset H
 506+ 0722 47                           ld      B,A             ; reset B
 507+ 0723 29                           add     HL,HL           ; create offset (each address is 2-bytes long so we need to double HL)
 508+ 0724 11 7E 0A                     ld      DE,POS_TB_CRS_40; load position table address of cursor for 40 cols
 509+ 0727 3A CD 81                     ld      A,(SCR_SIZE_W)  ; load screen width
 510+ 072A FE 28                        cp      $28             ; is it 40 cols?
 511+ 072C 28 03                        jr      Z,CONT_POS_CURS ; yes, jump over
 512+ 072E 11 4E 0A                     ld      DE,POS_TB_CRS_32; no, load position table address of cursor for 32 cols
 513+ 0731 19           CONT_POS_CURS:  add     HL,DE           ; the correct starting address of the required row is now into HL
 514+ 0732 5E                           ld      E,(HL)          ; load starting address of the required row into DE
 515+ 0733 23                           inc     HL
 516+ 0734 56                           ld      D,(HL)
 517+ 0735 2A D1 81                     ld      HL,(SCR_NAM_TB) ; load starting address of name table
 518+ 0738 19                           add     HL,DE           ; starting address of the current row into name table
 519+ 0739 3A D3 81                     ld      A,(SCR_CURS_X)  ; load cursor X
 520+ 073C 4F                           ld      C,A             ; transfer A into C
 521+ 073D 09                           add     HL,BC           ; add X offset: now HL contains the address of the current cursor position
 522+ 073E C9                           ret
 523+ 073F
 524+ 073F              ; find X,Y coordinates of a screen address pointed in VRAM by HL
 525+ 073F              ; return them into L,A for X,Y
 526+ 073F D5           HL2XY:          push    DE              ; store DE
 527+ 0740 ED 5B D1 81                  ld      DE,(SCR_NAM_TB) ; load starting address of name table into DE
 528+ 0744 AF                           xor     A               ; clear Carry
 529+ 0745 ED 52                        sbc     HL,DE           ; find position relative to screen (from 0,0)
 530+ 0747 D1                           pop     DE
 531+ 0748 3A CD 81                     ld      A,(SCR_SIZE_W)  ; load screen width
 532+ 074B 4F                           ld      C,A             ; move it into C
 533+ 074C CD EE 3F                     call    DIV_16_8        ; divide position by C: return Y into L and X into A
 534+ 074F C9                           ret                     ; return to caller
 535+ 0750
 536+ 0750              ;-------------------------------------------------------------------------------
 537+ 0750              ; char table for jumps
 538+ 0750 19           CHRTBL:         defb    HOME
 539+ 0751 93 06                        defw    ATHOME          ; move the cursor to 0,0
 540+ 0753
 541+ 0753 0C                           defb    CS
 542+ 0754 86 06                        defw    CLEARVIDBUF     ; clear video buffer and position cursor at 0,0
 543+ 0756
 544+ 0756 0D                           defb    CR
 545+ 0757 A1 09                        defw    CRGRETURN       ; go to the beginning of the next line
 546+ 0759
 547+ 0759 08                           defb    BKSP
 548+ 075A 3D 08                        defw    BACKSPACE       ; move cursor left 1 position
 549+ 075C
 550+ 075C 1C                           defb    CRSLFT
 551+ 075D 50 08                        defw    CURSORLEFT      ; move cursor left
 552+ 075F
 553+ 075F 1E                           defb    CRSUP
 554+ 0760 9C 08                        defw    CURSORUP        ; move cursor up
 555+ 0762
 556+ 0762 1D                           defb    CRSRGT
 557+ 0763 B5 08                        defw    CURSORRIGHT     ; move cursor right
 558+ 0765
 559+ 0765 1F                           defb    CRSDN
 560+ 0766 EA 08                        defw    CURSORDOWN      ; move cursor up
 561+ 0768
 562+ 0768 1A                           defb    INSRT
 563+ 0769 FC 07                        defw    INSERTKEY       ; insert a space
 564+ 076B
 565+ 076B 0A                           defb    LF
 566+ 076C D7 07                        defw    PLACEHOLDER     ; CURRENTLY WE DON'T PRINT LINE FEED
 567+ 076E
 568+ 076E              ; send current char to video buffer
 569+ 076E F5           CHAR2VID:       push    AF              ; store AF
 570+ 076F C5                           push    BC              ; store BC
 571+ 0770 D5                           push    DE              ; store DE
 572+ 0771 E5                           push    HL              ; store HL
 573+ 0772 3A D8 81                     ld      A,(CRSR_STATE)  ; store cursor state...
 574+ 0775 F5                           push    AF              ; into stack
 575+ 0776 CD 1F 09                     call    CURSOR_OFF      ; cursor off
 576+ 0779 3A DB 81                     ld      A,(CHR4VID)     ; recover char
 577+ 077C 06 0A                        ld      B,$0A           ; 10 chars to check
 578+ 077E 21 50 07                     ld      HL,CHRTBL       ; address of key table
 579+ 0781 BE           RPTCPCK:        cp      (HL)            ; compare with char
 580+ 0782 23                           inc     HL              ; beginning of sub-routine address
 581+ 0783 20 09                        jr      NZ,NXTCPCK      ; different, go to next char
 582+ 0785 5E                           ld      E,(HL)          ; load addres into DE
 583+ 0786 23                           inc     HL
 584+ 0787 56                           ld      D,(HL)
 585+ 0788 EB                           ex      DE,HL           ; move user routine's address into HL
 586+ 0789 11 CA 07                     ld      DE,EXITCHAR2VID ; set point of return after the user routine
 587+ 078C D5                           push    DE              ; store into stack
 588+ 078D E9                           jp      (HL)            ; call user routine - then, the CPU will return (jump) to EXITCHAR2VID
 589+ 078E 23           NXTCPCK:        inc     HL              ; jump over 2 cells...
 590+ 078F 23                           inc     HL              ; ...to the next char code
 591+ 0790 10 EF                        djnz    RPTCPCK         ; repeat
 592+ 0792                              ; it'a not a special char, just print it
 593+ 0792 CD 1C 07                     call    LOAD_CRSR_POS   ; recover position of cursor
 594+ 0795 3A DB 81                     ld      A,(CHR4VID)     ; recover char to print
 595+ 0798 CD B2 06                     call    WRITE_VIDEO_LOC ; write A into VRAM at (HL)
 596+ 079B 3A D4 81                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 597+ 079E 5F                           ld      E,A             ; store cursor Y into E
 598+ 079F 3A D3 81                     ld      A,(SCR_CURS_X)  ; load cursor X
 599+ 07A2 3C                           inc     A               ; move 1 step to right
 600+ 07A3 21 CD 81                     ld      HL,SCR_SIZE_W   ; cell that keeps the width of screen
 601+ 07A6 BE                           cp      (HL)            ; have we reached the most right position?
 602+ 07A7 20 0F                        jr      NZ,SETCSRCOORDS ; no, go over
 603+ 07A9 1C                           inc     E               ; yes, increment cursor Y (go to next line)
 604+ 07AA 7B                           ld      A,E             ; move cursor Y into A
 605+ 07AB 21 CE 81                     ld      HL,SCR_SIZE_H   ; cell that keeps the height of screen
 606+ 07AE BE                           cp      (HL)            ; have we reached the bottom of the screen?
 607+ 07AF 20 06                        jr      NZ,SETCRSRY     ; no, jump over
 608+ 07B1 D5                           push    DE
 609+ 07B2 CD 26 09                     call    SCROLLUP        ; scroll screen up
 610+ 07B5 D1                           pop     DE
 611+ 07B6 1D                           dec     E               ; decrement 1 row, to set cursor Y on the last line
 612+ 07B7 AF           SETCRSRY:       xor     A               ; then set cursor X to 0 (go to beginning of line)
 613+ 07B8 32 D3 81     SETCSRCOORDS:   ld      (SCR_CURS_X),A  ; store current cursor X
 614+ 07BB 7B                           ld      A,E             ; recover Y
 615+ 07BC 32 D4 81                     ld      (SCR_CURS_Y),A  ; store current cursor Y
 616+ 07BF CD D9 06                     call    POS_CURSOR      ; position cursor into new location
 617+ 07C2 3A BD 81                     ld      A,(TMRCNT)      ; load status of cursor flashing
 618+ 07C5 E6 20                        and     $20             ; check cursor state
 619+ 07C7 32 D9 81                     ld      (LSTCSRSTA),A   ; store the last cursor state
 620+ 07CA AF           EXITCHAR2VID:   xor     A               ; reset char
 621+ 07CB 32 DB 81                     ld      (CHR4VID),A     ; to be sent to screen
 622+ 07CE F1                           pop     AF              ; recover cursor state
 623+ 07CF A7                           and     A               ; was it off (A=0)?
 624+ 07D0 C4 0A 09                     call    NZ,CURSOR_ON    ; no, set cursor on
 625+ 07D3 E1                           pop     HL              ; restore HL
 626+ 07D4 D1                           pop     DE              ; restore DE
 627+ 07D5 C1                           pop     BC              ; restore BC
 628+ 07D6 F1                           pop     AF              ; restore AF
 629+ 07D7 C9           PLACEHOLDER:    ret                     ; return to caller
 630+ 07D8
 631+ 07D8              ; flash the cursor at the current position
 632+ 07D8              ; (this sub-routine is called by CH3 timer ISR)
 633+ 07D8 3A D8 81     FLASHCURSOR:    ld      A,(CRSR_STATE)  ; now, check the cursor
 634+ 07DB A7                           and     A               ; cursor off (A=0)?
 635+ 07DC C8                           ret     Z               ; yes, return
 636+ 07DD 3A BD 81                     ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
 637+ 07E0 E6 20                        and     $20             ; check if it's time to flash the cursor (check bit #6)
 638+ 07E2 21 D9 81                     ld      HL,LSTCSRSTA    ; load address of cell that stores the last cursor state
 639+ 07E5 46                           ld      B,(HL)          ; load last state
 640+ 07E6 B8                           cp      B               ; compare current state with last state
 641+ 07E7 C8                           ret     Z               ; same state, no change required - exit
 642+ 07E8 77                           ld      (HL),A          ; save new state
 643+ 07E9 F5                           push    AF              ; store A (keep state for later use)
 644+ 07EA CD 1C 07                     call    LOAD_CRSR_POS   ; load current cursor position into HL
 645+ 07ED F1                           pop     AF              ; recover current state
 646+ 07EE 06 FF                        ld      B,$FF           ; cursor char
 647+ 07F0 FE 20                        cp      $20             ; is the cursor on video (A == $20)?
 648+ 07F2 28 04                        jr      Z,PUTCRSCHR     ; yes, jump over
 649+ 07F4 3A D7 81                     ld      A,(SCR_ORG_CHR) ; no, load the original char
 650+ 07F7 47                           ld      B,A             ; move char into B
 651+ 07F8 78           PUTCRSCHR:      ld      A,B             ; recover char from B
 652+ 07F9 C3 B2 06                     jp      WRITE_VIDEO_LOC ; print cursor/char at the current position & return
 653+ 07FC
 654+ 07FC
 655+ 07FC              ; insert an empty space at the current position of the cursor, moving the following text
 656+ 07FC              ; 1 cell straight
 657+ 07FC CD 13 07     INSERTKEY:      call    RSTCHRCRS       ; restore char under the cursor
 658+ 07FF CD 1C 07                     call    LOAD_CRSR_POS   ; retrieve address of cursor cell
 659+ 0802 22 DE 81                     ld      (CUR_POS),HL    ; store it
 660+ 0805 CD 28 0A                     call    ENDOFLN         ; find address of first free cell after the end of the text from the current cursor position - address into HL -
 661+ 0808                                                      ; DE is the address of the bottom right cell of the screen
 662+ 0808 22 E2 81                     ld      (ENDTXT),HL     ; store it
 663+ 080B ED 4B DE 81                  ld      BC,(CUR_POS)    ; load starting address
 664+ 080F AF                           xor     A
 665+ 0810 ED 42                        sbc     HL,BC           ; how many positions to move?
 666+ 0812 CA E9 06                     jp      Z,MOVSHOWCRS    ; none - leave and re-place cursor
 667+ 0815 44 4D                        ld      BC,HL           ; number of chars to scroll into BC
 668+ 0817 2A E2 81                     ld      HL,(ENDTXT)     ; load address of the end of text
 669+ 081A 2B           CHKHL:          dec     HL              ; decrement to find the address of the char to move
 670+ 081B E5                           push    HL
 671+ 081C CD AF 3F                     call    CMP16           ; is it the last cell (bottom right) of screen?
 672+ 081F E1                           pop     HL
 673+ 0820 D2 2B 08                     jp      NC,NXTINST      ; yes, so jump over - nothing to do
 674+ 0823 CD 9D 06                     call    READ_VIDEO_LOC  ; no, so read current char
 675+ 0826 23                           inc     HL              ; next cell
 676+ 0827 CD B2 06                     call    WRITE_VIDEO_LOC ; write into new position
 677+ 082A 2B                           dec     HL              ; decrement to old position
 678+ 082B 0B           NXTINST:        dec     BC              ; decrement number of chars to move
 679+ 082C 79                           ld      A,C
 680+ 082D B0                           or      B               ; finished?
 681+ 082E 20 EA                        jr      NZ,CHKHL        ; no, repeat
 682+ 0830 AF           ENDINSRT:       xor     A
 683+ 0831 2A DE 81                     ld      HL,(CUR_POS)
 684+ 0834 32 D7 81                     ld      (SCR_ORG_CHR),A ; reset original char under the cursor
 685+ 0837 CD B2 06                     call    WRITE_VIDEO_LOC ; empty current video location
 686+ 083A C3 E9 06                     jp      MOVSHOWCRS      ; re-place cursor
 687+ 083D
 688+ 083D              ; delete the char at the left of the cursor
 689+ 083D CD 79 08     BACKSPACE:      call    MVCRS2LFT       ; prepare to move cursor to left
 690+ 0840 CD 13 07                     call    RSTCHRCRS       ; restore char under the cursor
 691+ 0843 CD FE 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 692+ 0846 CD 1C 07                     call    LOAD_CRSR_POS   ; find address of new video cell
 693+ 0849 AF                           xor     A               ; null char
 694+ 084A CD B2 06                     call    WRITE_VIDEO_LOC ; write into video cell
 695+ 084D C3 E9 06                     jp      MOVSHOWCRS      ; move cursor to the new location and set it ON
 696+ 0850
 697+ 0850
 698+ 0850              ; move cursor to left
 699+ 0850 F5           CURSORLEFT:     push    AF              ; store A
 700+ 0851 3A D3 81                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 701+ 0854 A7                           and     A               ; is it at the most left of the screen (X=0)?
 702+ 0855 28 0C                        jr      Z,CHCKYPOS      ; yes, check Y position
 703+ 0857 3D                           dec     A               ; no, decrement X
 704+ 0858 32 D5 81                     ld      (SCR_CUR_NX),A  ; store new X
 705+ 085B 3A D4 81                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 706+ 085E 32 D6 81                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 707+ 0861 18 11                        jr      CONTCRSLFT      ; go on moving cursor
 708+ 0863 3A D4 81     CHCKYPOS:       ld      A,(SCR_CURS_Y)  ; load cursor Y
 709+ 0866 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 710+ 0867 28 0E                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 711+ 0869 3D                           dec     A               ; no, decrement Y
 712+ 086A 32 D6 81                     ld      (SCR_CUR_NY),A  ; store new Y
 713+ 086D 3A CD 81                     ld      A,(SCR_SIZE_W)  ; load current screen width
 714+ 0870 3D                           dec     A               ; cursor to the most right position (width-0)
 715+ 0871 32 D5 81                     ld      (SCR_CUR_NX),A  ; set new cursor X
 716+ 0874 CD E3 06     CONTCRSLFT:     call    MOVCRS          ; move cursor into new position
 717+ 0877 F1           EXITCURSORLEFT: pop     AF              ; restore A
 718+ 0878 C9                           ret                     ; return to caller
 719+ 0879
 720+ 0879              ; move cursor 1 position to the left
 721+ 0879 3A D3 81     MVCRS2LFT:      ld      A,(SCR_CURS_X)  ; load cursor X into A
 722+ 087C A7                           and     A               ; is it at the most left of the screen (X=0)?
 723+ 087D 28 0B                        jr      Z,CHKYPOS       ; yes, check Y position
 724+ 087F 3D                           dec     A               ; no, decrement X
 725+ 0880 32 D5 81                     ld      (SCR_CUR_NX),A  ; store new X
 726+ 0883 3A D4 81                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 727+ 0886 32 D6 81                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 728+ 0889 C9                           ret                     ; go on moving cursor
 729+ 088A 3A D4 81     CHKYPOS:        ld      A,(SCR_CURS_Y)  ; load cursor Y
 730+ 088D A7                           and     A               ; is it at the most top of the screen (Y=0)?
 731+ 088E 28 E7                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 732+ 0890 3D                           dec     A               ; no, decrement Y
 733+ 0891 32 D6 81                     ld      (SCR_CUR_NY),A  ; store new Y
 734+ 0894 3A CD 81                     ld      A,(SCR_SIZE_W)  ; load current screen width
 735+ 0897 3D                           dec     A               ; cursor to the most right position (width-1)
 736+ 0898 32 D5 81                     ld      (SCR_CUR_NX),A  ; set new cursor X
 737+ 089B C9                           ret                     ; return to caller
 738+ 089C
 739+ 089C              ; move cursor up
 740+ 089C F5           CURSORUP:       push    AF              ; store A
 741+ 089D 3A D4 81                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 742+ 08A0 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 743+ 08A1 28 10                        jr      Z,EXITCURSORUP  ; yes, exit doing nothing
 744+ 08A3 3D                           dec     A               ; no, decrement Y
 745+ 08A4 32 D6 81                     ld      (SCR_CUR_NY),A  ; store new Y
 746+ 08A7 3A D3 81                     ld      A,(SCR_CURS_X)  ; load current cursor X
 747+ 08AA 32 D5 81                     ld      (SCR_CUR_NX),A  ; set new cursor X
 748+ 08AD CD 13 07                     call    RSTCHRCRS       ; restore char under the cursor and print it
 749+ 08B0 CD E3 06                     call    MOVCRS          ; move cursor into new position
 750+ 08B3 F1           EXITCURSORUP:   pop     AF              ; restore A
 751+ 08B4 C9                           ret                     ; return to caller
 752+ 08B5
 753+ 08B5
 754+ 08B5              ; move cursor to right
 755+ 08B5 F5           CURSORRIGHT:    push    AF              ; store A
 756+ 08B6 C5                           push    BC              ; store B
 757+ 08B7 3A CD 81                     ld      A,(SCR_SIZE_W)  ; load current screen width (in text modes it's 32 or 40)
 758+ 08BA 3D                           dec     A               ; decrement it (most right can only be 31 or 39)
 759+ 08BB 47                           ld      B,A             ; move A into B
 760+ 08BC 3A D3 81                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 761+ 08BF B8                           cp      B               ; is cursor at the most right position on the screen?
 762+ 08C0 30 0C                        jr      NC,CHCKYPOS2    ; yes, so jump to check Y position
 763+ 08C2 3C                           inc     A               ; no, so increment X
 764+ 08C3 32 D5 81                     ld      (SCR_CUR_NX),A  ; store new X
 765+ 08C6 3A D4 81                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 766+ 08C9 32 D6 81                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 767+ 08CC 18 13                        jr      CONTCRSRGT      ; go on moving cursor
 768+ 08CE 3A CE 81     CHCKYPOS2:      ld      A,(SCR_SIZE_H)  ; load screen height
 769+ 08D1 3D                           dec     A               ; decrement it (last row can only be 23)
 770+ 08D2 47                           ld      B,A             ; move bottom into B
 771+ 08D3 3A D4 81                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 772+ 08D6 B8                           cp      B               ; is the cursor at the bottom of the screen?
 773+ 08D7 30 0E                        jr      NC,EXITCURSORRGHT; yes, exit doing nothing
 774+ 08D9 3C                           inc     A               ; no, increment Y
 775+ 08DA 32 D6 81                     ld      (SCR_CUR_NY),A  ; store new Y
 776+ 08DD AF                           xor     A               ; move cursor to top left
 777+ 08DE 32 D5 81                     ld      (SCR_CUR_NX),A  ; store new X
 778+ 08E1 CD 13 07     CONTCRSRGT:     call    RSTCHRCRS       ; restore char under the cursor and print it
 779+ 08E4 CD E3 06                     call    MOVCRS          ; move cursor into new position
 780+ 08E7 C1           EXITCURSORRGHT: pop     BC              ; retrieve BC
 781+ 08E8 F1                           pop     AF              ; restore A
 782+ 08E9 C9                           ret                     ; return to caller
 783+ 08EA
 784+ 08EA
 785+ 08EA              ; move cursor down
 786+ 08EA F5           CURSORDOWN:     push    AF              ; store A
 787+ 08EB C5                           push    BC              ; store B
 788+ 08EC 3A CE 81                     ld      A,(SCR_SIZE_H)  ; load current screen height (in text modes it's 24)
 789+ 08EF 3D                           dec     A               ; decrement it (positions can only vary between 0 and 23)
 790+ 08F0 47                           ld      B,A             ; move X into B
 791+ 08F1 3A D4 81                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 792+ 08F4 B8                           cp      B               ; is current cursor position < 23?
 793+ 08F5 30 10                        jr      NC,EXITCURSORDOWN; no, exit doing nothing
 794+ 08F7 3C                           inc     A               ; yes, increment Y
 795+ 08F8 32 D6 81                     ld      (SCR_CUR_NY),A  ; store new Y
 796+ 08FB 3A D3 81                     ld      A,(SCR_CURS_X)  ; load current cursor X
 797+ 08FE 32 D5 81                     ld      (SCR_CUR_NX),A  ; set new cursor X
 798+ 0901 CD 13 07                     call    RSTCHRCRS       ; restore char under the cursor and print it
 799+ 0904 CD E3 06                     call    MOVCRS          ; move cursor into new position
 800+ 0907 C1           EXITCURSORDOWN: pop     BC              ; retrieve BC
 801+ 0908 F1                           pop     AF              ; retrieve A
 802+ 0909 C9                           ret                     ; return to caller
 803+ 090A
 804+ 090A
 805+ 090A              ; set cursor on (visible on screen)
 806+ 090A F5           CURSOR_ON:      push    AF              ; store AF
 807+ 090B 3A D8 81                     ld      A,(CRSR_STATE)  ; load cursor state
 808+ 090E B7                           or      A               ; is it on?
 809+ 090F 20 0C                        jr      NZ,EXITCURSOR_ON; yes, so nothing to do
 810+ 0911 3A CE 81                     ld      A,(SCR_SIZE_H)  ; check the video mode
 811+ 0914 FE 30                        cp      $30             ; graphics 2 or 3 (if value>=48)?
 812+ 0916 30 05                        jr      NC,EXITCURSOR_ON; yes, so exit (no cursor in graphics 2 or 3)
 813+ 0918 3E 01                        ld      A,$01           ; cursor state ON
 814+ 091A 32 D8 81                     ld      (CRSR_STATE),A  ; set state
 815+ 091D F1           EXITCURSOR_ON:  pop     AF              ; restore AF
 816+ 091E C9                           ret                     ; return to caller
 817+ 091F
 818+ 091F              ; set cursor off (invisible on screen)
 819+ 091F F5           CURSOR_OFF:     push    AF              ; store AF
 820+ 0920 AF                           xor     A               ; cursor state OFF
 821+ 0921 32 D8 81                     ld      (CRSR_STATE),A  ; set state
 822+ 0924 F1                           pop     AF              ; restore AF
 823+ 0925 C9                           ret
 824+ 0926
 825+ 0926              ; scroll the screen 1 row up
 826+ 0926 AF           SCROLLUP:       xor     A
 827+ 0927 32 DA 81                     ld      (PRNTVIDEO),A
 828+ 092A 2A D1 81                     ld      HL,(SCR_NAM_TB) ; start address of the name table
 829+ 092D 22 0E 82                     ld      (VIDTMP1),HL    ; store address of the destination row (1st row of the screen)
 830+ 0930 3A CD 81                     ld      A,(SCR_SIZE_W)  ; load the screen width
 831+ 0933 5F                           ld      E,A             ; move width into E
 832+ 0934 16 00                        ld      D,$00           ; reset D
 833+ 0936 19                           add     HL,DE           ; HL now contains the address of the source row (2nd row of the screen)
 834+ 0937 22 10 82                     ld      (VIDTMP2),HL    ; store address of source row
 835+ 093A 3A CE 81                     ld      A,(SCR_SIZE_H)  ; load the screen height
 836+ 093D 3D                           dec     A               ; decrement the # of rows: now, A contains the # of rows to be moved
 837+ 093E 47                           ld      B,A             ; move # of rows into B
 838+ 093F 3A CD 81     SCROLLNXTRW:    ld      A,(SCR_SIZE_W)  ; (re)load the screen width
 839+ 0942 5F                           ld      E,A             ; move width into E
 840+ 0943 2A 10 82                     ld      HL,(VIDTMP2)    ; load source address
 841+ 0946 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 842+ 0948 ED 69                        out     (C),L           ; low byte of source
 843+ 094A ED 61                        out     (C),H           ; high byte of source
 844+ 094C 21 E6 81                     ld      HL,VIDEOBUFF    ; load address of the first cell of the video buffer
 845+ 094F 0E 30                        ld      C,VDP_DAT       ; VDP data mode
 846+ 0951 ED 78        LOADNEXTCOL:    in      A,(C)           ; load char
 847+ 0953 77                           ld      (HL),A          ; store char
 848+ 0954 23                           inc     HL              ; next cell of the buffer
 849+ 0955 1D                           dec     E               ; count the chars to be read
 850+ 0956 20 F9                        jr      NZ,LOADNEXTCOL  ; repeat until we read the entire row
 851+ 0958 3A CD 81                     ld      A,(SCR_SIZE_W)  ; reload the screen width
 852+ 095B 5F                           ld      E,A             ; move # of rows into E
 853+ 095C 16 00                        ld      D,$00           ; reset D
 854+ 095E 2A 0E 82                     ld      HL,(VIDTMP1)    ; load address of destination row
 855+ 0961 E5                           push    HL              ; store HL
 856+ 0962 2A 10 82                     ld      HL,(VIDTMP2)    ; current source will be..
 857+ 0965 22 0E 82                     ld      (VIDTMP1),HL    ; ..new destination
 858+ 0968 19                           add     HL,DE           ; address of new
 859+ 0969 22 10 82                     ld      (VIDTMP2),HL    ; source row
 860+ 096C E1                           pop     HL              ; restore address of current destination row
 861+ 096D CB F4                        set     6,H             ; writing mode
 862+ 096F 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 863+ 0971 ED 69                        out     (C),L           ; low byte
 864+ 0973 ED 61                        out     (C),H           ; high byte of address
 865+ 0975 21 E6 81                     ld      HL,VIDEOBUFF    ; video buffer address
 866+ 0978 0E 30                        ld      C,VDP_DAT       ; VDP data mode
 867+ 097A 7E           WRITEBUF:       ld      A,(HL)          ; load char
 868+ 097B ED 79                        out     (C),A           ; send char
 869+ 097D 23                           inc     HL              ; increment buffer index
 870+ 097E 1D                           dec     E               ; next row
 871+ 097F 20 F9                        jr      NZ,WRITEBUF     ; repeat until 0
 872+ 0981 10 BC                        djnz    SCROLLNXTRW     ; repeat for the entire screen
 873+ 0983 3A CD 81                     ld      A,(SCR_SIZE_W)  ; reload screen width
 874+ 0986 47                           ld      B,A             ; cells to empty into B
 875+ 0987 AF                           xor     A               ; null char
 876+ 0988 0E 32                        ld      C,VDP_SET       ; VDP set mode
 877+ 098A 2A 0E 82                     ld      HL,(VIDTMP1)    ; load address of the last row
 878+ 098D CB F4                        set     6,H             ; writing mode
 879+ 098F ED 69                        out     (C),L           ; low byte then..
 880+ 0991 ED 61                        out     (C),H           ; high byte of address
 881+ 0993 0E 30                        ld      C,VDP_DAT       ; VDP data mode
 882+ 0995 ED 79        RPTEMPTYROW:    out     (C),A           ; empty cell
 883+ 0997 00                           nop                     ; delay
 884+ 0998 00                           nop
 885+ 0999 10 FA                        djnz    RPTEMPTYROW     ; repeat until the last row has been cleaned
 886+ 099B 3E 01                        ld      A,$01
 887+ 099D 32 DA 81                     ld      (PRNTVIDEO),A   ; set print-on-video on
 888+ 09A0 C9                           ret                     ; return to caller
 889+ 09A1
 890+ 09A1              ; carriage return: first, it looks for char $00 at the beginning of the line (look for the first null char),
 891+ 09A1              ; then it starts sendind every char it finds on the screen to the terminal buffer of the BASIC interpreter
 892+ 09A1              ; until another null char is found. Finally, move to the next line and position the cursor at the beginning
 893+ 09A1              ; of the row (equivalent to CR+LF), then gets back control to the screen editor to let it interpret the line
 894+ 09A1              CUR_POS         equ     TMPBFR1         ; cursor position
 895+ 09A1              SRTTXT          equ     TMPBFR2         ; start of text line
 896+ 09A1              ENDTXT          equ     TMPBFR3         ; end of text line
 897+ 09A1              CRGRETURN:      ; preliminary: disable cursor if on, and retrieve char under it
 898+ 09A1 3A D8 81                     ld      A,(CRSR_STATE)  ; recover cursor state
 899+ 09A4 32 E4 81                     ld      (TMPBFR4),A     ; store status
 900+ 09A7 A7                           and     A               ; is cursor on?
 901+ 09A8 C4 1F 09                     call    NZ,CURSOR_OFF   ; yes, so set cursor off
 902+ 09AB CD 13 07                     call    RSTCHRCRS       ; restore char under it
 903+ 09AE                              ; first, check if cursor if off, so that we just interpret return as a new line command
 904+ 09AE 3A 18 82                     ld      A,(KBDNPT)      ; check if input from keyboad
 905+ 09B1 A7                           and     A               ; if 0, input is not from keyboard...
 906+ 09B2 CA 07 0A                     jp      Z,PRNTRETURN    ; ...so just print a carriage return; otherwise, interpret the return
 907+ 09B5                              ; first part: look for the beginning of the text line on screen
 908+ 09B5 CD 1C 07                     call    LOAD_CRSR_POS   ; load cursor position into HL
 909+ 09B8 22 DE 81                     ld      (CUR_POS),HL    ; store it
 910+ 09BB ED 5B D1 81                  ld      DE,(SCR_NAM_TB) ; load VRAM address of top-left cell of screen ("home")
 911+ 09BF E5           RPTNLLSRC:      push    HL
 912+ 09C0 CD AF 3F                     call    CMP16           ; check if at "home"
 913+ 09C3 E1                           pop     HL
 914+ 09C4 CA CF 09                     jp      Z,CNTNULL       ; yes, exit because there is nothing before
 915+ 09C7 2B                           dec     HL              ; go 1 step back
 916+ 09C8 CD 9D 06                     call    READ_VIDEO_LOC  ; read char of current position
 917+ 09CB A7                           and     A               ; is it $00 (null char)?
 918+ 09CC 20 F1                        jr      NZ,RPTNLLSRC    ; no, continue searching
 919+ 09CE 23                           inc     HL              ; move 1 step forward to go back to the last cell with something in
 920+ 09CF                              ; second part: look for the ending of the text on screen
 921+ 09CF 22 E0 81     CNTNULL:        ld      (SRTTXT),HL     ; store beginning of text
 922+ 09D2 CD 28 0A                     call    ENDOFLN         ; find end of text line looking at the end of chars after the cursor position
 923+ 09D5 22 E2 81                     ld      (ENDTXT),HL     ; store ending of text line
 924+ 09D8 ED 5B E0 81                  ld      DE,(SRTTXT)     ; load beginning of text line
 925+ 09DC A7                           and     A               ; clear Carry
 926+ 09DD ED 52                        sbc     HL,DE           ; how many chars?
 927+ 09DF 28 26                        jr      Z,PRNTRETURN    ; no chars found (HL-DE=0), so just print return & leave
 928+ 09E1                              ;---    central part: send the text on the screen to the interpreter
 929+ 09E1 2A E0 81                     ld      HL,(SRTTXT)     ; load beginning of text line
 930+ 09E4 ED 5B E2 81                  ld      DE,(ENDTXT)     ; load ending of text line
 931+ 09E8 CD 9D 06     SNDCHRTOBFR:    call    READ_VIDEO_LOC  ; read char
 932+ 09EB E5                           push    HL
 933+ 09EC CD F4 01                     call    CHARINTOBFR     ; send char to buffer
 934+ 09EF E1                           pop     HL
 935+ 09F0 23                           inc     HL              ; go to next char
 936+ 09F1 E5                           push    HL              ; store HL
 937+ 09F2 CD AF 3F                     call    CMP16           ; check if DE=HL (finish chars)
 938+ 09F5 E1                           pop     HL
 939+ 09F6 20 F0                        jr      NZ,SNDCHRTOBFR  ; no, repeat
 940+ 09F8 3E 0D                        ld      A,CR            ; yes, so now send carriage return
 941+ 09FA CD F4 01                     call    CHARINTOBFR     ; send to buffer
 942+ 09FD 2A E2 81                     ld      HL,(ENDTXT)     ; recover address of last char of input text
 943+ 0A00 CD 3F 07                     call    HL2XY           ; retrieve X,Y from address
 944+ 0A03 7D                           ld      A,L             ; move Y into A (we don't need X anymore)
 945+ 0A04 32 D4 81                     ld      (SCR_CURS_Y),A  ; store new Y
 946+ 0A07                              ;---    final part: go at the beginning of a new line on the screen
 947+ 0A07 AF           PRNTRETURN:     xor     A               ; move to col 0
 948+ 0A08 32 D3 81                     ld      (SCR_CURS_X),A  ; store new X
 949+ 0A0B 3A D4 81                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 950+ 0A0E 3C                           inc     A               ; new row
 951+ 0A0F 21 CE 81                     ld      HL,SCR_SIZE_H   ; load address of cell that keeps screen height
 952+ 0A12 BE                           cp      (HL)            ; is the cursor over the bottom of the screen?
 953+ 0A13 38 06                        jr      C,ADDNEWLINE    ; no, jump over
 954+ 0A15 3D                           dec     A               ; yes, so come back 1 row, then...
 955+ 0A16 F5                           push    AF              ; (store A)
 956+ 0A17 CD 26 09                     call    SCROLLUP        ; ...scroll the screen before to...
 957+ 0A1A F1                           pop     AF              ; (retrieve A)
 958+ 0A1B 32 D4 81     ADDNEWLINE:     ld      (SCR_CURS_Y),A  ; ...store new Y
 959+ 0A1E 3A E4 81                     ld      A,(TMPBFR4)     ; retrieve cursor state
 960+ 0A21 A7                           and     A               ; was it off (A=0)?
 961+ 0A22 C4 0A 09                     call    NZ,CURSOR_ON    ; no, set cursor on
 962+ 0A25 C3 D9 06                     jp      POS_CURSOR      ; position cursor to new location & return to caller
 963+ 0A28
 964+ 0A28              ; find end of text line
 965+ 0A28              ; destroys A, DE, and HL - store address of last char of text line into HL,
 966+ 0A28              ; while DE contains the address of the bottom right cell of the screen
 967+ 0A28 3A CE 81     ENDOFLN:        ld      A,(SCR_SIZE_H)
 968+ 0A2B 5F                           ld      E,A             ; load screen height into DE
 969+ 0A2C 3A CD 81                     ld      A,(SCR_SIZE_W)
 970+ 0A2F 6F                           ld      L,A             ; load screen width into HL
 971+ 0A30 AF                           xor     A
 972+ 0A31 67                           ld      H,A
 973+ 0A32 57                           ld      D,A
 974+ 0A33 CD BA 3F                     call    MUL16           ; multiply HL times DE to get the screen size
 975+ 0A36 ED 5B D1 81                  ld      DE,(SCR_NAM_TB) ; load screen name table start address into DE
 976+ 0A3A 19                           add     HL,DE           ; get the address...
 977+ 0A3B 2B                           dec     HL              ; ...of the "last" video cell
 978+ 0A3C EB                           ex      DE,HL           ; store address into DE
 979+ 0A3D 2A DE 81                     ld      HL,(CUR_POS)    ; retrieve original cursor position
 980+ 0A40 E5           RPTNLLSRC2:     push    HL
 981+ 0A41 CD AF 3F                     call    CMP16           ; check if at last position on screen (bottom right corner)
 982+ 0A44 E1                           pop     HL
 983+ 0A45 C8                           ret     Z               ; if yes, exit because these is nothing after
 984+ 0A46 23                           inc     HL              ; 1 more step forward
 985+ 0A47 CD 9D 06                     call    READ_VIDEO_LOC  ; read char of current position
 986+ 0A4A A7                           and     A               ; is it $00 (null char)?
 987+ 0A4B 20 F3                        jr      NZ,RPTNLLSRC2   ; no, continue searching
 988+ 0A4D C9           CNTNULL2:       ret                     ; yes: found end of text, return to caller
 989+ 0A4E
 990+ 0A4E
 991+ 0A4E              ; ------------------------------------------------------------------------------
 992+ 0A4E                              ; this table contains the values of the offsets to be added to
 993+ 0A4E                              ; the starting address of the name table to find the correct
 994+ 0A4E                              ; value of the first cell of the corresponding row
 995+ 0A4E                              ; (by doing so, it's faster than doing a multipication)
 996+ 0A4E                              ; table for graphics 1 text mode: 32 cols
 997+ 0A4E 00 00 20 00  POS_TB_CRS_32:  defw    $0000,$0020,$0040,$0060,$0080,$00A0,$00C0,$00E0
 997+ 0A52 40 00 60 00
 997+ 0A56 80 00 A0 00
 997+ 0A5A C0 00 E0 00
 998+ 0A5E 00 01 20 01                  defw    $0100,$0120,$0140,$0160,$0180,$01A0,$01C0,$01E0
 998+ 0A62 40 01 60 01
 998+ 0A66 80 01 A0 01
 998+ 0A6A C0 01 E0 01
 999+ 0A6E 00 02 20 02                  defw    $0200,$0220,$0240,$0260,$0280,$02A0,$02C0,$02E0
 999+ 0A72 40 02 60 02
 999+ 0A76 80 02 A0 02
 999+ 0A7A C0 02 E0 02
1000+ 0A7E                              ; table for pure text mode: 40 cols
1001+ 0A7E 00 00 28 00  POS_TB_CRS_40:  defw    $0000,$0028,$0050,$0078,$00A0,$00C8,$00F0,$0118
1001+ 0A82 50 00 78 00
1001+ 0A86 A0 00 C8 00
1001+ 0A8A F0 00 18 01
1002+ 0A8E 40 01 68 01                  defw    $0140,$0168,$0190,$01B8,$01E0,$0208,$0230,$0258
1002+ 0A92 90 01 B8 01
1002+ 0A96 E0 01 08 02
1002+ 0A9A 30 02 58 02
1003+ 0A9E 80 02 A8 02                  defw    $0280,$02A8,$02D0,$02F8,$0320,$0348,$0370,$0398
1003+ 0AA2 D0 02 F8 02
1003+ 0AA6 20 03 48 03
1003+ 0AAA 70 03 98 03
1004+ 0AAE
1005+ 0AAE              ; ------------------------------------------------------------------------------
1006+ 0AAE              ; reset VRAM
1007+ 0AAE AF           EMPTY_VRAM:     xor     A               ; reg.A cleared: we fill up VRAM with $00
1008+ 0AAF 67                           ld      H,A
1009+ 0AB0 6F                           ld      L,A             ; reset HL
1010+ 0AB1 CD 7D 06                     call    SETVDPADRS      ; set address of first VRAM cell to $0000
1011+ 0AB4 06 40                        ld      B,$40           ; $40 pages of RAM...
1012+ 0AB6 57                           ld      D,A             ; ...each one with $100 cells (tot. $4000 bytes)
1013+ 0AB7 0E 30                        ld      C,VDP_DAT       ; VDP data mode
1014+ 0AB9 ED 79        EMPTVRM:        out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
1015+ 0ABB 14                           inc     D               ; next cell
1016+ 0ABC 00                           nop
1017+ 0ABD 20 FA                        jr      NZ,EMPTVRM      ; repeat until page is fully cleared
1018+ 0ABF 10 F8                        djnz    EMPTVRM         ; repeat for $40 pages
1019+ 0AC1 C9                           ret                     ; return to caller
1020+ 0AC2
1021+ 0AC2              ; clear video registers in SRAM
1022+ 0AC2 21 CD 81     CLR_RAM_REG:    ld      HL,SCR_SIZE_W   ; address of first register
1023+ 0AC5 AF                           xor     A               ; $00 to clean the registers
1024+ 0AC6 06 45                        ld      B,CHASNDDTN-SCR_SIZE_W; how many bytes (registers) to clean (dinamically calculated)
1025+ 0AC8 77           RSTVDPRAMREG:   ld      (HL),A          ; reset register
1026+ 0AC9 23                           inc     HL              ; next register
1027+ 0ACA 10 FC                        djnz    RSTVDPRAMREG    ; repeat
1028+ 0ACC C9                           ret                     ; return to caller
1029+ 0ACD
1030+ 0ACD              ; ------------------------------------------------------------------------------
1031+ 0ACD              ; set a specific graphics mode, passed into reg. E
1032+ 0ACD 06 08        SET_GFX_MODE:   ld      B,$08           ; 8 registers means 8 bytes..
1033+ 0ACF CB 23                        sla     E               ; multiply E by 8..
1034+ 0AD1 CB 23                        sla     E               ; so that reg. E can point..
1035+ 0AD3 CB 23                        sla     E               ; to the correct settings
1036+ 0AD5 16 00        SET_GFX_MODE2:  ld      D,$00           ; reset D
1037+ 0AD7 21 0A 0B                     ld      HL,VDPMODESET   ; pointer to register settings | <= here points the SHOW_LOGO sub-routine
1038+ 0ADA 19                           add     HL,DE           ; add offset to get the correct set of values for the required mode
1039+ 0ADB 3E 80                        ld      A,$80           ; start with REG0 ($80+register number)
1040+ 0ADD 0E 32                        ld      C,VDP_SET       ; VDP set
1041+ 0ADF 56           LDREGVLS:       ld      D,(HL)          ; load register's value
1042+ 0AE0 ED 51                        out     (C),D           ; send data to VDP
1043+ 0AE2 ED 79                        out     (C),A           ; indicate the register to send data to
1044+ 0AE4 3C                           inc     A               ; next register
1045+ 0AE5 23                           inc     HL              ; next value
1046+ 0AE6 10 F7                        djnz    LDREGVLS        ; repeat for 8 registers
1047+ 0AE8 C9                           ret
1048+ 0AE9
1049+ 0AE9              ; ------------------------------------------------------------------------------
1050+ 0AE9              LOADCHARSET:    ; reg. A contains the video mode
1051+ 0AE9                              ; reg. HL contains address of pattern table into VRAM
1052+ 0AE9 06 00                        ld      B,$00           ; 0=256 chars to load (complete charset)
1053+ 0AEB CB F4                        set     $06,H           ; add $4000 to address to indicate that we want to write into VRAM
1054+ 0AED 0E 32                        ld      C,VDP_SET       ; load VDP address into C
1055+ 0AEF ED 69                        out     (C),L           ; send low byte of address
1056+ 0AF1 ED 61                        out     (C),H           ; send high byte
1057+ 0AF3 21 12 40                     ld      HL,CHRST68      ; starting address of 6x8 charset into ROM
1058+ 0AF6 A7                           and     A               ; is it text mode (A=0)?
1059+ 0AF7 28 03                        jr      Z,NXTCHAR       ; yes, so jump to load chars into VRAM
1060+ 0AF9 21 12 48                     ld      HL,CHRST88      ; no, so we change and load the 8x8 charset
1061+ 0AFC 16 08        NXTCHAR:        ld      D,$08           ; 8 bytes per pattern char
1062+ 0AFE 0E 30                        ld      C,VDP_DAT       ; VDP data mode
1063+ 0B00 7E           SENDCHRPTRNS:   ld      A,(HL)          ; load byte to send to VDP
1064+ 0B01 ED 79                        out     (C),A           ; write byte into VRAM
1065+ 0B03 23                           inc     HL              ; inc byte pointer
1066+ 0B04 15                           dec     D               ; 8 bytes sents (0 char)?
1067+ 0B05 20 F9                        jr      NZ,SENDCHRPTRNS ; no, continue
1068+ 0B07 10 F3                        djnz    NXTCHAR         ; yes, decrement chars counter and continue for all the chars
1069+ 0B09 C9                           ret                     ; return to caller
1070+ 0B0A
1071+ 0B0A              ;------------------------------------------------------------------------------
1072+ 0B0A              ; NAME TABLE:       buffer video - contains the chars to be shown on video
1073+ 0B0A              ; PATTERN TABLE:    charset - contains the chars/tiles to be loaded into the name table
1074+ 0B0A              ; COLOR TABLE:      color settings for chars/tiles
1075+ 0B0A
1076+ 0B0A                              ; VDP register settings for a text display
1077+ 0B0A 00           VDPMODESET:     defb    %00000000       ; reg.0: external video off
1078+ 0B0B D0                           defb    %11010000       ; reg.1: 16K VRAM, video on, int. off, text mode (40x24)
1079+ 0B0C 02                           defb    $02             ; reg.2: name table set to $0800 ($02x$400)
1080+ 0B0D 00                           defb    $00             ; reg.3: not used in text mode
1081+ 0B0E 00                           defb    $00             ; reg.4: pattern table set to $0000
1082+ 0B0F 00                           defb    $00             ; reg.5: not used in text mode
1083+ 0B10 00                           defb    $00             ; reg.6: not used in text mode
1084+ 0B11 F5                           defb    $f5             ; reg.7: white text on light blue background
1085+ 0B12
1086+ 0B12              VDPMODESET1:    ; VDP register settings for a graphics 1 mode
1087+ 0B12 00                           defb    %00000000       ; reg.0: ext. video off
1088+ 0B13 C0                           defb    %11000000       ; reg.1: 16K Vram; video on, int off, graphics mode 1, sprite size 8x8, sprite magn. 0
1089+ 0B14 06                           defb    $06             ; reg.2: name table address: $1800
1090+ 0B15 80                           defb    $80             ; reg.3: color table address: $2000
1091+ 0B16 00                           defb    $00             ; reg.4: pattern table address: $0000
1092+ 0B17 36                           defb    $36             ; reg.5: sprite attr. table address: $1B00
1093+ 0B18 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1094+ 0B19 05                           defb    $05             ; reg.7: backdrop color (light blue)
1095+ 0B1A
1096+ 0B1A              VDPMODESET2:    ; VDP register settings for a graphics 2 mode
1097+ 0B1A 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1098+ 0B1B C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1099+ 0B1C 06                           defb    $06             ; reg.2: name table addr.: $1800
1100+ 0B1D FF                           defb    $FF             ; reg.3: color table addr.: $2000
1101+ 0B1E 03                           defb    $03             ; reg.4: pattern table addr.: $0000
1102+ 0B1F 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1103+ 0B20 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1104+ 0B21 05                           defb    $05             ; reg.7: backdrop color: light blue
1105+ 0B22
1106+ 0B22              VDPMODESETMC:   ; VDP register settings for a multicolor mode
1107+ 0B22 00                           defb    %00000000       ; reg.0: ext. video dis.
1108+ 0B23 CB                           defb    %11001011       ; reg.1: 16K VRAM, video on, INT off, multicolor mode, sprite size 8x8, sprite magn. 0
1109+ 0B24 02                           defb    $02             ; reg.2: name table addr.: $0800
1110+ 0B25 00                           defb    $00             ; reg.3: don't care
1111+ 0B26 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1112+ 0B27 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1113+ 0B28 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1114+ 0B29 0F                           defb    $0F             ; reg.7: backdrop color (white)
1115+ 0B2A
1116+ 0B2A              VDPMODESETEX2:  ; VDP register settings for an extended graphics 2 mode
1117+ 0B2A 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1118+ 0B2B C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1119+ 0B2C 0E                           defb    $0E             ; reg.2: name table addr.: $3800
1120+ 0B2D 9F                           defb    $9F             ; reg.3: color table addr.: $2000
1121+ 0B2E 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1122+ 0B2F 76                           defb    $76             ; reg.5: sprite attr. table addr.: $3B00
1123+ 0B30 03                           defb    $03             ; reg.6: sprite pattern table addr.: $1800
1124+ 0B31 05                           defb    $05             ; reg.7: backdrop color: light blue
1125+ 0B32
1126+ 0B32              LM80CLOGO:      ; patterns to compose the splash screen logo
1127+ 0B32 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1127+ 0B36 00 00 00 00
1127+ 0B3A 00 00 00 00
1127+ 0B3E 00 00 00 00
1127+ 0B42 00 00 00 00
1127+ 0B46 00 00 00 00
1127+ 0B4A 00 00 00 00
1127+ 0B4E 00 00 00 00
1128+ 0B52 00 00 0F 0A                  defb    0,0,15,10,11,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1128+ 0B56 0B 10 00 00
1128+ 0B5A 00 00 00 00
1128+ 0B5E 00 00 00 00
1128+ 0B62 00 00 00 00
1128+ 0B66 00 00 00 00
1128+ 0B6A 00 00 00 00
1128+ 0B6E 00 00 00 00
1129+ 0B72 00 00 0D 17                  defb    0,0,13,23,0,12,0,0,0,1,0,0,0,20,0,0,6,5,6,21,22,7,6,21,22,7,6,1,1,7,0,0
1129+ 0B76 00 0C 00 00
1129+ 0B7A 00 01 00 00
1129+ 0B7E 00 14 00 00
1129+ 0B82 06 05 06 15
1129+ 0B86 16 07 06 15
1129+ 0B8A 16 07 06 01
1129+ 0B8E 01 07 00 00
1130+ 0B92 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,20,6,1,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1130+ 0B96 00 0C 00 00
1130+ 0B9A 00 01 00 00
1130+ 0B9E 00 01 14 06
1130+ 0BA2 01 05 03 05
1130+ 0BA6 03 05 03 05
1130+ 0BAA 03 05 03 05
1130+ 0BAE 03 05 00 00
1131+ 0BB2 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,1,1,1,5,9,20,19,8,3,5,19,5,3,5,0,0,0,0
1131+ 0BB6 00 0C 00 00
1131+ 0BBA 00 01 00 00
1131+ 0BBE 00 01 01 01
1131+ 0BC2 01 05 09 14
1131+ 0BC6 13 08 03 05
1131+ 0BCA 13 05 03 05
1131+ 0BCE 00 00 00 00
1132+ 0BD2 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,8,3,5,6,21,22,7,3,1,22,5,3,5,0,0,0,0
1132+ 0BD6 00 0C 00 00
1132+ 0BDA 00 01 00 00
1132+ 0BDE 00 01 00 08
1132+ 0BE2 03 05 06 15
1132+ 0BE6 16 07 03 01
1132+ 0BEA 16 05 03 05
1132+ 0BEE 00 00 00 00
1133+ 0BF2 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,0,3,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1133+ 0BF6 00 0C 00 00
1133+ 0BFA 00 01 00 00
1133+ 0BFE 00 01 00 00
1133+ 0C02 03 05 03 05
1133+ 0C06 03 05 03 05
1133+ 0C0A 03 05 03 05
1133+ 0C0E 03 05 00 00
1134+ 0C12 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,4,4,0,1,0,0,3,5,9,20,19,8,9,20,19,8,9,1,1,8,0,0
1134+ 0C16 00 0C 00 00
1134+ 0C1A 00 01 04 04
1134+ 0C1E 00 01 00 00
1134+ 0C22 03 05 09 14
1134+ 0C26 13 08 09 14
1134+ 0C2A 13 08 09 01
1134+ 0C2E 01 08 00 00
1135+ 0C32 00 00 0E 12                  defb    0,0,14,18,18,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1135+ 0C36 12 11 00 00
1135+ 0C3A 00 00 00 00
1135+ 0C3E 00 00 00 00
1135+ 0C42 00 00 00 00
1135+ 0C46 00 00 00 00
1135+ 0C4A 00 00 00 00
1135+ 0C4E 00 00 00 00
1136+ 0C52 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1136+ 0C56 00 00 00 00
1136+ 0C5A 00 00 00 00
1136+ 0C5E 00 00 00 00
1136+ 0C62 00 00 00 00
1136+ 0C66 00 00 00 00
1136+ 0C6A 00 00 00 00
1136+ 0C6E 00 00 00 00
# file closed: ../include/vdp/vdp-r316.asm
  67  0C72
  68  0C72              ; incude the latest version of the PSG module
  69  0C72                  INCLUDE "../include/psg/psg-r316.asm"
# file opened: ../include/psg/psg-r316.asm
   1+ 0C72              ; ------------------------------------------------------------------------------
   2+ 0C72              ; LM80C - PSG ROUTINES - R3.16
   3+ 0C72              ; ------------------------------------------------------------------------------
   4+ 0C72              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0C72              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0C72              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0C72              ; kind of warranty: you can use them at your own risk.
   8+ 0C72              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0C72              ; maintain the copyright notices, include this advice and the note to the
  10+ 0C72              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0C72              ; redistribuite them.
  12+ 0C72              ; https://www.leonardomiliani.com
  13+ 0C72              ;
  14+ 0C72              ; Please support me by visiting the following links:
  15+ 0C72              ; Main project page: https://www.leonardomiliani.com
  16+ 0C72              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0C72              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0C72              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0C72              ; ------------------------------------------------------------------------------
  20+ 0C72              ;
  21+ 0C72              ; ------------------------------------------------------------------------------
  22+ 0C72
  23+ 0C72              ;------------------------------------------------------------------------------
  24+ 0C72              ; configure the PSG
  25+ 0C72 21 12 82     initPSG:        ld      HL,CHASNDDTN    ; starting address of sound & keyboard RAM registers
  26+ 0C75 06 0E                        ld      B,SERIALS_EN-CHASNDDTN; # of PSG sound & keyboard registers
  27+ 0C77 AF                           xor     A               ; reset A
  28+ 0C78 77           EMPTSNDBFR:     ld      (HL),A          ; reset RAM register
  29+ 0C79 23                           inc     HL              ; next register
  30+ 0C7A 10 FC                        djnz    EMPTSNDBFR      ; repeat
  31+ 0C7C 06 10        CLRPSGREGS:     ld      B,$10           ; 16 registers to set
  32+ 0C7E 21 90 0C                     ld      HL,SNDREGCFG    ; starting address of register settings
  33+ 0C81 16 00                        ld      D,$00           ; first register
  34+ 0C83 7A           RSTPSG:         ld      A,D             ; register value
  35+ 0C84 CD CA 0C                     call    SETSNDREG       ; select register
  36+ 0C87 7E                           ld      A,(HL)          ; load value
  37+ 0C88 CD CF 0C                     call    WRTSNDREG       ; write to register
  38+ 0C8B 14                           inc     D               ; next register
  39+ 0C8C 23                           inc     HL              ; next value
  40+ 0C8D 10 F4                        djnz    RSTPSG          ; repeat for each register
  41+ 0C8F C9                           ret                     ; return to caller
  42+ 0C90
  43+ 0C90 00 00 00 00  SNDREGCFG:      defb $00,$00,$00,$00,$00,$00,$00,%10111111
  43+ 0C94 00 00 00 BF
  44+ 0C98 00 00 00 00                  defb $00,$00,$00,$00,$00,$00,$ff,$ff
  44+ 0C9C 00 00 FF FF
  45+ 0CA0                              ; reg. 7: set I/O ch.A to OUTPUT, I/O ch.B to INPUT; set noise to OFF; set audio to OFF
  46+ 0CA0
  47+ 0CA0
  48+ 0CA0              ; routine to play a welcome beep on channel C (tone 4010) and to shut it off
  49+ 0CA0 21 BA 0C     WLCMBEEP:       ld      HL,WLCBPDAT     ; data address
  50+ 0CA3 C3 A9 0C                     jp      SENDSND
  51+ 0CA6 21 C2 0C     NOBEEP:         ld      HL,NOBPDAT      ; data address
  52+ 0CA9 C5           SENDSND:        push    BC
  53+ 0CAA 06 04                        ld      B,$04           ; 4 pairs
  54+ 0CAC 7E           RPTWLCMBP:      ld      A,(HL)          ; read register #
  55+ 0CAD CD CA 0C                     call    SETSNDREG
  56+ 0CB0 23                           inc     HL              ; next cell
  57+ 0CB1 7E                           ld      A,(HL)          ; read value
  58+ 0CB2 CD CF 0C                     call    WRTSNDREG
  59+ 0CB5 23                           inc     HL
  60+ 0CB6 10 F4                        djnz    RPTWLCMBP       ; repeat
  61+ 0CB8 C1                           pop     BC
  62+ 0CB9 C9                           ret                     ; return to caller
  63+ 0CBA
  64+ 0CBA 07 BB 04 56  WLCBPDAT:       defb    $07,%10111011,$04,$56,$05,$00,$0A,$0F
  64+ 0CBE 05 00 0A 0F
  65+ 0CC2 04 00 05 00  NOBPDAT:        defb    $04,$00,$05,$00,$0A,$00,$07,%10111111
  65+ 0CC6 0A 00 07 BF
  66+ 0CCA
  67+ 0CCA
  68+ 0CCA              ; select register on PSG
  69+ 0CCA 0E 40        SETSNDREG:      ld      C,PSG_REG       ; PSG register port
  70+ 0CCC ED 79                        out     (C),A           ; set register
  71+ 0CCE C9                           ret                     ; return to caller
  72+ 0CCF
  73+ 0CCF              ; send data to PSG
  74+ 0CCF 0E 41        WRTSNDREG:      ld      C,PSG_DAT       ; PSG data port
  75+ 0CD1 ED 79                        out     (C),A           ; send data
  76+ 0CD3 C9                           ret                     ; return to caller
  77+ 0CD4
  78+ 0CD4              ; manage the sounds' duration: each time this subroutine is called, it
  79+ 0CD4              ; decrements the single sound durations (measured in ms) and eventually
  80+ 0CD4              ; shut off the audio channel whose counter has reached 0.
  81+ 0CD4              ; (this sub-routine is called by CH3 timer ISR)
  82+ 0CD4 DD E5        MNGSNDS:        push    IX              ; store IX
  83+ 0CD6 DD 21 12 82                  ld      IX,CHASNDDTN    ; starting address of tones duration
  84+ 0CDA 06 03                        ld      B,$03           ; 3 channels to check
  85+ 0CDC 26 01                        ld      H,$01           ; mixer channels: A=>bit 1, B=>bit 2, C=>bit 3
  86+ 0CDE DD 5E 00     CHKSNDCH:       ld      E,(IX+0)        ; load LSB into E
  87+ 0CE1 DD 56 01                     ld      D,(IX+1)        ; load MSB into D
  88+ 0CE4 7B                           ld      A,E             ; load E into A
  89+ 0CE5 B2                           or      D               ; check that DE=0
  90+ 0CE6 28 31                        jr      Z,CNTCHKSND     ; yes, jump over
  91+ 0CE8 1B                           dec     DE              ; no, so decrement DE
  92+ 0CE9 7B                           ld      A,E             ; reload E into A...
  93+ 0CEA DD 73 00                     ld      (IX+0),E        ; store new...
  94+ 0CED DD 72 01                     ld      (IX+1),D        ; ...duration and...
  95+ 0CF0 B2                           or      D               ; ...do another check to see if DE=0
  96+ 0CF1 20 26                        jr      NZ,CNTCHKSND    ; no, so jump over
  97+ 0CF3                                                      ; if yes, let's shut down the corresponding channel
  98+ 0CF3                                                      ; to shut down a tone we disable it into the mixer
  99+ 0CF3                                                      ; then set 0 into its tone registers
 100+ 0CF3 16 07                        ld      D,$07           ; mixer register
 101+ 0CF5 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 102+ 0CF7 ED 51                        out     (C),D           ; set mixer register
 103+ 0CF9 ED 78                        in      A,(C)           ; load current value
 104+ 0CFB B4                           or      H               ; set off the channel into the mixer (remember that 1=OFF)
 105+ 0CFC ED 51                        out     (C),D           ; select mixer register
 106+ 0CFE 0E 41                        ld      C,PSG_DAT       ; PSG data port
 107+ 0D00 ED 79                        out     (C),A           ; send new value for the mixer
 108+ 0D02 3E 03                        ld      A,$03           ; three channels
 109+ 0D04 90                           sub     B               ; find current channel (0->A, 1->B, 2->C)
 110+ 0D05 87                           add     A,A             ; and find first register (A=>0, B=>2, C=>4)
 111+ 0D06 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 112+ 0D08 ED 79                        out     (C),A           ; select first tone register of channel
 113+ 0D0A 2E 00                        ld      L,$00           ; value 0 into L
 114+ 0D0C 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 115+ 0D0E ED 69                        out     (C),L           ; write 0 into register
 116+ 0D10 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 117+ 0D12 3C                           inc     A               ; next tone register
 118+ 0D13 ED 79                        out     (C),A           ; select second tone register of channel
 119+ 0D15 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 120+ 0D17 ED 69                        out     (C),L           ; write 0 into register
 121+ 0D19 DD 23        CNTCHKSND:      inc     IX              ; set for...
 122+ 0D1B DD 23                        inc     IX              ; ...next channel...
 123+ 0D1D CB 24                        sla     H               ; shift left H 1 bit
 124+ 0D1F 10 BD                        djnz    CHKSNDCH        ; repeat for 3 channels
 125+ 0D21 DD E1                        pop     IX              ; restore IX
 126+ 0D23 C9                           ret                     ; return to caller
 127+ 0D24
 128+ 0D24              ; read a specific row of the keyboard matrix, set by A
 129+ 0D24              ; return read into A
 130+ 0D24 C5           READKBLN:       push    BC              ; store BC
 131+ 0D25 06 0F                        ld      B,$0F           ; reg #15
 132+ 0D27 0E 40                        ld      C,PSG_REG       ; PSG register port
 133+ 0D29 ED 41                        out     (C),B           ; select reg #15
 134+ 0D2B 0E 41                        ld      C,PSG_DAT       ; PSG data port
 135+ 0D2D ED 79                        out     (C),A           ; activate the row
 136+ 0D2F 06 0E                        ld      B,$0E           ; register #14 (port B)
 137+ 0D31 0E 40                        ld      C,PSG_REG       ; PSG register port
 138+ 0D33 ED 41                        out     (C),B           ; select reg. 14 (port B)
 139+ 0D35 ED 78                        in      A,(C)           ; read register #14
 140+ 0D37 C1                           pop     BC              ; retrieve BC
 141+ 0D38 C9                           ret
 142+ 0D39
 143+ 0D39              ; read the keyboard matrix to look for a key pressure
 144+ 0D39 0E 40        KEYBOARD:       ld      C,PSG_REG       ; PSG register port
 145+ 0D3B 06 07                        ld      B,$07           ; set register #7...
 146+ 0D3D ED 41                        out     (C),B           ; ...to work with
 147+ 0D3F ED 78                        in      A,(C)           ; read register #7
 148+ 0D41 CB FF                        set     7,A             ; port A set to output
 149+ 0D43 CB B7                        res     6,A             ; port B set to input
 150+ 0D45 ED 41                        out     (C),B           ; set register #7
 151+ 0D47 0E 41                        ld      C,PSG_DAT       ; PSG data port
 152+ 0D49 ED 79                        out     (C),A           ; set I/O ports w/o altering the rest of the mixer
 153+ 0D4B                              ; check special keys (SHIFT/ALT/CTRL)
 154+ 0D4B 3E FD                        ld      A,%11111101     ; select SHIFT row
 155+ 0D4D CD 24 0D                     call    READKBLN        ; read row
 156+ 0D50 CB 5F                        bit     3,A             ; test if SHIFT key is pressed (4th bit is reset)
 157+ 0D52 20 05                        jr      NZ,CHECKALT     ; no, so go on
 158+ 0D54 21 1F 82                     ld      HL,CONTROLKEYS  ; control key flags
 159+ 0D57 36 01                        ld      (HL),%00000001  ; set SHIFT flag, reset CTRL & ALT flags (currently multiply control keys are NOT supported)
 160+ 0D59 3E FE        CHECKALT:       ld      A,%11111110     ; select ALT row
 161+ 0D5B CD 24 0D                     call    READKBLN        ; read ALT row
 162+ 0D5E CB 6F                        bit     5,A             ; test if ALT key is pressed (5th bit is reset)
 163+ 0D60 20 05                        jr      NZ,CHECKCTRL    ; no, so go on
 164+ 0D62 21 1F 82                     ld      HL,CONTROLKEYS  ; control key flags
 165+ 0D65 36 04                        ld      (HL),%00000100  ; set ALT flag, reset SHIFT & CTRL flag (currently multiply control keys are NOT supported)
 166+ 0D67 3E FE        CHECKCTRL:      ld      A,%11111110     ; select CTRL row
 167+ 0D69 CD 24 0D                     call    READKBLN        ; read CTRL row
 168+ 0D6C CB 57                        bit     2,A             ; test if CTRL key is pressed (3rd bit is reset)
 169+ 0D6E 20 05                        jr      NZ,CHECKKBD     ; no, so make a normal reading
 170+ 0D70 21 1F 82                     ld      HL,CONTROLKEYS  ; control key flags
 171+ 0D73 36 02                        ld      (HL),%00000010  ; set CTRL flag, reset SHIFT & ALT flags (currently multiply control keys are NOT supported)
 172+ 0D75 06 08        CHECKKBD:       ld      B,$08           ; 8 lines
 173+ 0D77 3E 7F                        ld      A,%01111111     ; start from the last line of the matrix
 174+ 0D79 16 0F        RPTKBDRD:       ld      D,$0F           ; register #15 (port B)
 175+ 0D7B 0E 40                        ld      C,PSG_REG       ; PSG register port
 176+ 0D7D ED 51                        out     (C),D           ; select reg. #15
 177+ 0D7F 0E 41                        ld      C,PSG_DAT       ; PSG data port
 178+ 0D81 ED 79                        out     (C),A           ; activate 1 line (active line is grounded, i.e. with a LOW signal)
 179+ 0D83 5F                           ld      E,A             ; save current line into E
 180+ 0D84 16 0E                        ld      D,$0E           ; register #14 (port A)
 181+ 0D86 0E 40                        ld      C,PSG_REG       ; PSG register port
 182+ 0D88 ED 51                        out     (C),D           ; select reg. 14 (port A)
 183+ 0D8A 00                           nop
 184+ 0D8B ED 78                        in      A,(C)           ; read register #14
 185+ 0D8D FE FF                        cp      $FF             ; is there any line set to 0?
 186+ 0D8F 28 2E                        jr      Z,NOKEYPRSD     ; no, go to the next row
 187+ 0D91                              ; check control keys
 188+ 0D91 32 19 82                     ld      (KBTMP),A       ; yes, check if a control key was pressed. First, store current row
 189+ 0D94 78                           ld      A,B             ; copy current row (B) into A
 190+ 0D95 FE 02                        cp      $02             ; is it the row of the SHIFT?
 191+ 0D97 20 0F                        jr      NZ,TESTALT      ; no, continue checking the other control keys
 192+ 0D99 3A 19 82                     ld      A,(KBTMP)       ; yes, retrieve current row data
 193+ 0D9C CB 5F                        bit     3,A             ; check SHIFT bit line
 194+ 0D9E 20 31                        jr      NZ,FINDKEY      ; no SHIFT, continue checking
 195+ 0DA0 CB DF                        set     3,A             ; yes, it's the SHIFT. So remove SHIFT bit
 196+ 0DA2 FE FF                        cp      $FF             ; after deleting the SHIFT bit, is there any other bit selected?
 197+ 0DA4 20 2B                        jr      NZ,FINDKEY      ; yes, go to check which one
 198+ 0DA6 18 17                        jr      NOKEYPRSD       ; no, go to next row
 199+ 0DA8 FE 01        TESTALT:        cp      $01             ; is it the line of ALT & CTRL?
 200+ 0DAA 3A 19 82                     ld      A,(KBTMP)       ; retrieve current row data
 201+ 0DAD 20 22                        jr      NZ,FINDKEY      ; no, continue
 202+ 0DAF CB 6F                        bit     5,A             ; yes, check ALT bit line
 203+ 0DB1 20 02                        jr      NZ,TESTCTRL     ; no ALT, continue checking
 204+ 0DB3 CB EF                        set     5,A             ; yes, it's the ALT. So remove ALT bit
 205+ 0DB5 CB 57        TESTCTRL:       bit     2,A             ; check CTRL bit line
 206+ 0DB7 20 02                        jr      NZ,ENDCTRLCK    ; no CTRL, continue checking
 207+ 0DB9 CB D7                        set     2,A             ; delete CTRL bit flag
 208+ 0DBB FE FF        ENDCTRLCK:      cp      $FF             ; after deleting the ALT & CTRL bits, is there any other bit selected?
 209+ 0DBD 20 12                        jr      NZ,FINDKEY      ; yes, go to check which one
 210+ 0DBF 7B           NOKEYPRSD:      ld      A,E             ; no key pressed, load current output port
 211+ 0DC0 0F                           rrca                    ; rotate right by 1
 212+ 0DC1 10 B6                        djnz    RPTKBDRD        ; repeat for 8 lines
 213+ 0DC3 AF                           xor     A               ; if exit from here, no key has been pressed...
 214+ 0DC4 32 1B 82                     ld      (LASTKEYPRSD),A ; ...so reset the last key cell...
 215+ 0DC7 32 1F 82                     ld      (CONTROLKEYS),A ; ...reset contro key flags...
 216+ 0DCA 32 18 82                     ld      (KBDNPT),A      ; ...no input from keyboard...
 217+ 0DCD 32 1C 82                     ld      (STATUSKEY),A   ; ...no auto-repeat...
 218+ 0DD0 C9                           ret                     ; ...and leave
 219+ 0DD1 1E FF        FINDKEY:        ld      E,$FF           ; counter
 220+ 0DD3 1C           CHKLN:          inc     E               ; E goes from 0 to 7
 221+ 0DD4 CB 3F                        srl     A               ; is the first bit reset? (we're looking for a "0", meaning grounded line)
 222+ 0DD6 38 FB                        jr      C,CHKLN         ; no, check next bit
 223+ 0DD8 3A 1F 82                     ld      A,(CONTROLKEYS) ; load control key flags
 224+ 0DDB 21 F4 0E                     ld      HL,KBMAP        ; normal keymap
 225+ 0DDE FE 01                        cp      $01             ; SHIFT flag?
 226+ 0DE0 20 05                        jr      NZ,CHKCTRL      ; no, jump over
 227+ 0DE2 21 34 0F                     ld      HL,KBMAP_SFT    ; SHIFT keymap
 228+ 0DE5 18 10                        jr      LOADMAP         ; and load it
 229+ 0DE7 FE 02        CHKCTRL:        cp      $02             ; CTRL flag?
 230+ 0DE9 20 05                        jr      NZ,CHKALT       ; no, jump over
 231+ 0DEB 21 B4 0F                     ld      HL,KBMAP_CTRL   ; CTRL map
 232+ 0DEE 18 07                        jr      LOADMAP         ; and load it
 233+ 0DF0 FE 04        CHKALT:         cp      $04             ; ALT flag?
 234+ 0DF2 20 03                        jr      NZ,LOADMAP      ; no, check over
 235+ 0DF4 21 74 0F                     ld      HL,KBMAP_ALT    ; ALT map
 236+ 0DF7 05           LOADMAP:        dec     B               ; decrement row # (rows go from 0 to 7)
 237+ 0DF8 48                           ld      C,B             ; move B into C and...
 238+ 0DF9 CB 21                        sla     C               ; ...multiply it...
 239+ 0DFB CB 21                        sla     C               ; ...by 8 to find...
 240+ 0DFD CB 21                        sla     C               ; ...the current row into the matrix
 241+ 0DFF 06 00                        ld      B,$00           ; reset B
 242+ 0E01 09                           add     HL,BC           ; find the address of the current row
 243+ 0E02 50                           ld      D,B             ; reset D
 244+ 0E03 19                           add     HL,DE           ; find the current column - now (HL) stores the pressed key
 245+ 0E04 3A 1B 82                     ld      A,(LASTKEYPRSD) ; load the last key pressed
 246+ 0E07 BE                           cp      (HL)            ; is it the same key?
 247+ 0E08 20 41                        jr      NZ,NEWKEY       ; no, it's a new key
 248+ 0E0A 44 4D                        ld      BC,HL           ; store address of current keycode
 249+ 0E0C 2A BD 81                     ld      HL,(TMRCNT)     ; load current system timer
 250+ 0E0F ED 5B 1D 82                  ld      DE,(KEYTMR)     ; load auto-repeat timer
 251+ 0E13 3A 1C 82                     ld      A,(STATUSKEY)   ; yes, load current status of auto-repeat
 252+ 0E16 FE 01                        cp      $01             ; is it initial pressure?
 253+ 0E18 20 1F                        jr      NZ,CHKAUTO      ; no, jump over
 254+ 0E1A AF                           xor     A               ; clear Carry
 255+ 0E1B ED 52                        sbc     HL,DE           ; startint time - actual time
 256+ 0E1D 16 00                        ld      D,$00           ; 64 ths/s > 640 ms
 257+ 0E1F 3A B3 80                     ld      A,(KEYDEL)
 258+ 0E22 5F                           ld      E,A
 259+ 0E23 CD AF 3F                     call    CMP16           ; time elapsed is >= $40?
 260+ 0E26 DA 9B 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 261+ 0E29 3E 02        SETNEWAUTO:     ld      A,$02           ; yes set status to...
 262+ 0E2B 32 1C 82                     ld      (STATUSKEY),A   ; ...auto-repeat
 263+ 0E2E 2A BD 81                     ld      HL,(TMRCNT)     ; load system timer
 264+ 0E31 22 1D 82                     ld      (KEYTMR),HL     ; store starting time
 265+ 0E34 60 69                        ld      HL,BC           ; retrieve address of current keycode
 266+ 0E36 C3 58 0E                     jp      SENDKEY         ; send key
 267+ 0E39 AF           CHKAUTO:        xor     A               ; clear Carry
 268+ 0E3A ED 52                        sbc     HL,DE           ; computer interval between initial pressure of key and current time
 269+ 0E3C 16 00                        ld      D,$00
 270+ 0E3E 3A B4 80                     ld      A,(AUTOKE)
 271+ 0E41 5F                           ld      E,A             ; auto-repeat delay into DE
 272+ 0E42 CD AF 3F                     call    CMP16           ; check if interval is greater than delay
 273+ 0E45 DA 9B 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 274+ 0E48 C3 29 0E                     jp      SETNEWAUTO      ; set new loop and send key
 275+ 0E4B AF           NEWKEY:         xor     A               ; set initial state...
 276+ 0E4C 3C                           inc     A               ; ...for auto-repeat...
 277+ 0E4D 32 1C 82                     ld      (STATUSKEY),A   ; ...1=pressure init
 278+ 0E50 ED 4B BD 81                  ld      BC,(TMRCNT)     ; load current system timer
 279+ 0E54 ED 43 1D 82                  ld      (KEYTMR),BC     ; set starting time
 280+ 0E58 7E           SENDKEY:        ld      A,(HL)          ; then, load key...
 281+ 0E59 32 1B 82                     ld      (LASTKEYPRSD),A ; ...store it...
 282+ 0E5C 32 1A 82                     ld      (TMPKEYBFR),A   ; ...insert it into the INKEY buffer...
 283+ 0E5F 32 DB 81                     ld      (CHR4VID),A     ; ...and store char for video
 284+ 0E62 FE 03                        cp      CTRLC           ; is it RUN/STOP?
 285+ 0E64 20 05                        jr      NZ,CNTKBCK      ; no, jump over
 286+ 0E66 CD F4 01                     call    CHARINTOBFR     ; yes, send directly to buffer and...
 287+ 0E69 18 30                        jr      LVKBRDCHK2      ; ...leave
 288+ 0E6B 01 00 08     CNTKBCK:        ld      BC,$0800        ; 8 FN keys (B), FN key number (C)
 289+ 0E6E 21 EC 0E                     ld      HL,FNKEYSORD    ; FN keys codes
 290+ 0E71 BE           CHKFNK:         cp      (HL)            ; is it an FN key?
 291+ 0E72 CA A0 0E                     jp      Z,PRNTFNKEY     ; yes, jump over
 292+ 0E75 0C                           inc     C               ; next FN key
 293+ 0E76 23                           inc     HL              ; next FN key code
 294+ 0E77 10 F8                        djnz    CHKFNK          ; continue for 8 FN keys
 295+ 0E79 3E 01        SNDKEYTOBFR:    ld      A,$01           ; normal key - set input flag
 296+ 0E7B 32 18 82                     ld      (KBDNPT),A      ; to keyboard
 297+ 0E7E 3A DA 81                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 298+ 0E81 B7                           or      A               ; is the print-on-video disabled?
 299+ 0E82 CA 8B 0E                     jp      Z,PUTCHRBUF     ; yes, so send char to input buffer
 300+ 0E85 3A D8 81                     ld      A,(CRSR_STATE)  ; check cursor state
 301+ 0E88 B7                           or      A               ; is it 0 (cursor OFF)?
 302+ 0E89 20 0D                        jr      NZ,PNT2VD       ; no, print on screen
 303+ 0E8B AF           PUTCHRBUF:      xor     A
 304+ 0E8C 32 18 82                     ld      (KBDNPT),A      ; if send to input buffer, set RETURN as from BASIC
 305+ 0E8F 3A 1A 82                     ld      A,(TMPKEYBFR)   ; retrieve char
 306+ 0E92 CD F4 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 307+ 0E95 C3 9B 0E                     jp      LVKBRDCHK2      ; ...and leave
 308+ 0E98 CD 6E 07     PNT2VD:         call    CHAR2VID        ; send char to video
 309+ 0E9B AF           LVKBRDCHK2:     xor     A
 310+ 0E9C 32 1F 82                     ld      (CONTROLKEYS),A ; reset control key flags
 311+ 0E9F C9           LVKBRDCHK:      ret                     ; return to caller: the current key code is into TMPKEYBFR
 312+ 0EA0                              ; manage FN keys
 313+ 0EA0 57           PRNTFNKEY:      ld      D,A             ; copy A into D
 314+ 0EA1 2A AF 80                     ld      HL,(LINEAT)     ; Get current line number
 315+ 0EA4 23                           inc     HL              ; -1 means direct statement
 316+ 0EA5 7C                           ld      A,H
 317+ 0EA6 B5                           or      L
 318+ 0EA7 7A                           ld      A,D             ; retrieve char
 319+ 0EA8 20 CF                        jr      NZ,SNDKEYTOBFR  ; indirect mode - just send FN key code to buffer
 320+ 0EAA 79                           ld      A,C             ; direct mode, so print text - first, get FN key number
 321+ 0EAB 87                           add     A,A
 322+ 0EAC 87                           add     A,A
 323+ 0EAD 87                           add     A,A
 324+ 0EAE 87                           add     A,A             ; FN key number * 16
 325+ 0EAF 4F                           ld      C,A             ; move it into C
 326+ 0EB0 06 00                        ld      B,$00           ; reset B, to get offset
 327+ 0EB2 21 B5 80                     ld      HL,FNKEYS       ; load address of FN keys texts
 328+ 0EB5 09                           add     HL,BC           ; get correct text address
 329+ 0EB6 06 10                        ld      B,$10           ; 16 chars
 330+ 0EB8 7E           LDFNKEYCHR:     ld      A,(HL)          ; load char
 331+ 0EB9 A7                           and     A               ; null char?
 332+ 0EBA CA 9B 0E                     jp      Z,LVKBRDCHK2    ; yes, so leave
 333+ 0EBD 57                           ld      D,A             ; pass char into D
 334+ 0EBE 3A DA 81                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 335+ 0EC1 B7                           or      A               ; is the print-on-video disabled?
 336+ 0EC2 CA D2 0E                     jp      Z,PUTCHRBUF1    ; yes, so send char to input buffer
 337+ 0EC5 3A D8 81                     ld      A,(CRSR_STATE)  ; check cursor state
 338+ 0EC8 B7                           or      A               ; is it 0 (cursor OFF)?
 339+ 0EC9 C4 DF 0E                     call    NZ,PRNTFNK      ; no, print on screen
 340+ 0ECC 23           CNTFNK:         inc     HL              ; next char
 341+ 0ECD 10 E9                        djnz    LDFNKEYCHR      ; repeat for max. 16 chars
 342+ 0ECF C3 9B 0E                     jp      LVKBRDCHK2      ; leave
 343+ 0ED2 AF           PUTCHRBUF1:     xor     A               ; if send to input buffer,...
 344+ 0ED3 32 18 82                     ld      (KBDNPT),A      ; ...set input as from BASIC
 345+ 0ED6 7A                           ld      A,D             ; retrieve char
 346+ 0ED7 E5                           push    HL              ; store HL
 347+ 0ED8 CD F4 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 348+ 0EDB E1                           pop     HL              ; retrieve HL
 349+ 0EDC C3 CC 0E                     jp      CNTFNK          ; repeat
 350+ 0EDF 7A           PRNTFNK:        ld      A,D             ; recover char
 351+ 0EE0 32 DB 81                     ld      (CHR4VID),A     ; store char for printing
 352+ 0EE3 3E 01                        ld      A,$01           ; normal key - set input flag
 353+ 0EE5 32 18 82                     ld      (KBDNPT),A      ; to keyboard
 354+ 0EE8 CD 6E 07                     call    CHAR2VID        ; print on screen
 355+ 0EEB C9                           ret                     ; return to caller
 356+ 0EEC
 357+ 0EEC
 358+ 0EEC              ;-----------------------------------------------------------------------
 359+ 0EEC 01 02 04 05  FNKEYSORD:      defb 1,2,4,5,6,22,23,24                 ; order of FN Keys
 359+ 0EF0 06 16 17 18
 360+ 0EF4              ;-----------------------------------------------------------------------
 361+ 0EF4              ; key codes
 362+ 0EF4 31 19 0E 03  KBMAP:          defb '1',25,14,3,' ',16,'q','2'         ; 25=HOME  14=CTRL  3=RUN/STOP 16=C=
 362+ 0EF8 20 10 71 32
 363+ 0EFC 33 77 61 14                  defb '3','w','a',20,'z','s','e','4'     ; 20=SHIFT
 363+ 0F00 7A 73 65 34
 364+ 0F04 35 72 64 78                  defb '5','r','d','x','c','f','t','6'
 364+ 0F08 63 66 74 36
 365+ 0F0C 37 79 67 76                  defb '7','y','g','v','b','h','u','8'
 365+ 0F10 62 68 75 38
 366+ 0F14 39 69 6A 6E                  defb '9','i','j','n','m','k','o','0'
 366+ 0F18 6D 6B 6F 30
 367+ 0F1C 1F 70 6C 2C                  defb 31,'p','l',',','.',':','-',30      ; 31=CURSOR DOWN  30=CURSOR UP
 367+ 0F20 2E 3A 2D 1E
 368+ 0F24 1C 2A 3B 2F                  defb 28,'*',';','/',27,'=','+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 368+ 0F28 1B 3D 2B 1D
 369+ 0F2C 08 0D FC 40                  defb 8,13,252,'@',1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 369+ 0F30 01 02 04 18
 370+ 0F34
 371+ 0F34              ; shifted codes - not all the keys have the shifted version
 372+ 0F34 21 0C 0E 03  KBMAP_SFT:      defb '!',12,14,3,' ',16,'Q',34          ; 12=CLEAR  14=CTRL  3=RUN/STOP 16=C=   34="
 372+ 0F38 20 10 51 22
 373+ 0F3C 23 57 41 14                  defb '#','W','A',20,'Z','S','E','$'     ; 20=SHIFT
 373+ 0F40 5A 53 45 24
 374+ 0F44 25 52 44 58                  defb '%','R','D','X','C','F','T','&'
 374+ 0F48 43 46 54 26
 375+ 0F4C 27 59 47 56                  defb 39,'Y','G','V','B','H','U','('     ; 39='
 375+ 0F50 42 48 55 28
 376+ 0F54 29 49 4A 4E                  defb ')','I','J','N','M','K','O',94     ; 94=^
 376+ 0F58 4D 4B 4F 5E
 377+ 0F5C 1F 50 4C 3C                  defb 31,'P','L','<','>','[','_',30      ; 31=CURSOR DOWN  30=CURSOR UP
 377+ 0F60 3E 5B 5F 1E
 378+ 0F64 1C 2A 5D 3F                  defb 28,'*',']','?',27,198,'+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 378+ 0F68 1B C6 2B 1D
 379+ 0F6C 1A 0D D3 40                  defb 26,13,211,'@',5,6,22,23            ; 26=INSERT, 211=â¬  5=F4  6=F5  22=F6  23=F7
 379+ 0F70 05 06 16 17
 380+ 0F74
 381+ 0F74              ; ALT (C=) codes - not all the keys have the alt-ed version
 382+ 0F74 31 0C 0E 03  KBMAP_ALT:      defb '1',12,14,3,' ',16,222,196         ; 12=CLEAR  14=CTRL  3=RUN/STOP  16=C=  34="
 382+ 0F78 20 10 DE C4
 383+ 0F7C 33 DD 85 14                  defb '3',221,133,20,131,130,165,'4'     ; 20=SHIFT
 383+ 0F80 83 82 A5 34
 384+ 0F84 35 A2 A6 84                  defb '5',162,166,132,157,163,168,'6'
 384+ 0F88 9D A3 A8 36
 385+ 0F8C 37 AB A9 A1                  defb '7',171,169,161,158,172,213,'8'    ;
 385+ 0F90 9E AC D5 38
 386+ 0F94 39 D6 D8 9F                  defb '9',214,216,159,160,215,135,195    ;
 386+ 0F98 A0 D7 87 C3
 387+ 0F9C 1F 88 8A C1                  defb 31,136,138,193,192,123,144,30      ; 31=CURSOR DOWN  123={  30=CURSOR UP
 387+ 0FA0 C0 7B 90 1E
 388+ 0FA4 1C 8F 7D FE                  defb 28,143,125,254,27,209,148,29       ; 28=CURSOR LEFT  125=}  27=ESCAPE  29=CURSOR RIGHT
 388+ 0FA8 1B D1 94 1D
 389+ 0FAC 08 0D E0 89                  defb 8,13,224,137,5,6,22,23             ; 8=DEL(backspace)  13=RETURN  252=Â£  5=F4  6=F5  22=F6  23=F7
 389+ 0FB0 05 06 16 17
 390+ 0FB4
 391+ 0FB4              ; CTRL codes - not all the keys have the control-ed version
 392+ 0FB4 31 19 0E 03  KBMAP_CTRL:     defb '1',25,14,3,' ',16,154,'2'         ; 25=HOME  14=CTRL  3=RUN/STOP  16=C=
 392+ 0FB8 20 10 9A 32
 393+ 0FBC 33 9C 95 14                  defb '3',156,149,20,152,150,153,'4'     ; 20=SHIFT
 393+ 0FC0 98 96 99 34
 394+ 0FC4 35 9B B0 97                  defb '5',155,176,151,177,175,165,'6'
 394+ 0FC8 B1 AF A5 36
 395+ 0FCC 37 A6 A8 B2                  defb '7',166,168,178,179,169,167,'8'
 395+ 0FD0 B3 A9 A7 38
 396+ 0FD4 39 B8 AA AC                  defb '9',184,170,172,171,181,164,'0'
 396+ 0FD8 AB B5 A4 30
 397+ 0FDC 1F A3 AD 2C                  defb 31,163,173,',','.',':',186,30      ; 31=CURSOR DOWN  30=CURSOR UP
 397+ 0FE0 2E 3A BA 1E
 398+ 0FE4 1C E1 3B 2F                  defb 28,225,';','/',27,212,185,29       ; 28=CURSOR LEFT  27=ESCAPE  212=Ï  29=CURSOR RIGHT
 398+ 0FE8 1B D4 B9 1D
 399+ 0FEC 08 0D BD A2                  defb 8,13,189,162,1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 399+ 0FF0 01 02 04 18
# file closed: ../include/psg/psg-r316.asm
  70  0FF4
  71  0FF4              ; include the latest version of the LM80C BASIC interpreter
  72  0FF4                  INCLUDE "../include/basic/basic32k-r316.asm"
# file opened: ../include/basic/basic32k-r316.asm
   1+ 0FF4              ; ------------------------------------------------------------------------------
   2+ 0FF4              ; LM80C BASIC - R3.16
   3+ 0FF4              ; ------------------------------------------------------------------------------
   4+ 0FF4              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0FF4              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0FF4              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0FF4              ; kind of warranty: you can use them at your own risk.
   8+ 0FF4              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0FF4              ; maintain the copyright notices, include this advice and the note to the
  10+ 0FF4              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0FF4              ; redistribuite them.
  12+ 0FF4              ; https://www.leonardomiliani.com
  13+ 0FF4              ;
  14+ 0FF4              ; Please support me by visiting the following links:
  15+ 0FF4              ; Main project page: https://www.leonardomiliani.com
  16+ 0FF4              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0FF4              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0FF4              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0FF4              ; ------------------------------------------------------------------------------
  20+ 0FF4              ; LM80C BASIC originally based on the following NASCOM BASIC versions:
  21+ 0FF4              ; 4.7  - original version by NASCOM/MICROSOFT
  22+ 0FF4              ; 4.7b - modified version by Grant Searle (additional commands & functions)
  23+ 0FF4
  24+ 0FF4
  25+ 0FF4              ;------------------------------------------------------------------------------
  26+ 0FF4              ;  L M 8 0 C   B A S I C
  27+ 0FF4              ;------------------------------------------------------------------------------
  28+ 0FF4
  29+ 0FF4              ; GENERAL EQUATES
  30+ 0FF4
  31+ 0FF4              NLLCR           equ     $00             ; null char (used as space/empty char in video prints)
  32+ 0FF4              CTRLC           equ     $03             ; Control "C"
  33+ 0FF4              CTRLG           equ     $07             ; Control "G"
  34+ 0FF4              BKSP            equ     $08             ; Back space
  35+ 0FF4              LF              equ     $0A             ; Line feed
  36+ 0FF4              CS              equ     $0C             ; Clear screen
  37+ 0FF4              CR              equ     $0D             ; Carriage return
  38+ 0FF4              CTRLO           equ     $0F             ; Control "O"
  39+ 0FF4              CTRLQ           equ     $11             ; Control "Q"
  40+ 0FF4              CTRLR           equ     $12             ; Control "R"
  41+ 0FF4              CTRLS           equ     $13             ; Control "S"
  42+ 0FF4              CTRLU           equ     $15             ; Control "U"
  43+ 0FF4              HOME            equ     $19             ; Home (cursor at 0,0)
  44+ 0FF4              ESC             equ     $1B             ; Escape
  45+ 0FF4              SPC             equ     $20             ; Space
  46+ 0FF4              DEL             equ     $7F             ; Delete
  47+ 0FF4              INSRT           equ     $1A             ; Insert Key
  48+ 0FF4              ; cursor ASCII codes
  49+ 0FF4              CRSLFT          equ     $1C             ; cursor left
  50+ 0FF4              CRSRGT          equ     $1D             ; cursor right
  51+ 0FF4              CRSUP           equ     $1E             ; cursor up
  52+ 0FF4              CRSDN           equ     $1F             ; cursor down
  53+ 0FF4
  54+ 0FF4
  55+ 0FF4              ;-------------------------------------------------------------------------
  56+ 0FF4              ; BASIC ERROR MESSAGES
  57+ 0FF4              ; the interpreter looks for a single-byte code in the following list,
  58+ 0FF4              ; then loads the corresponding memory pointer in "ERRTBL" table to
  59+ 0FF4              ; find where to retrieve the message text in "ERRORS"
  60+ 0FF4
  61+ 0FF4              ; BASIC ERROR CODE VALUES
  62+ 0FF4              ; These values act as an offset to point to the error message into the error table
  63+ 0FF4              ; must be incremented by 2 because they point to a word address jump
  64+ 0FF4              NF              equ     $00     ; NEXT without FOR
  65+ 0FF4              SN              equ     $02     ; Syntax error
  66+ 0FF4              RG              equ     $04     ; RETURN without GOSUB
  67+ 0FF4              OD              equ     $06     ; Out of DATA
  68+ 0FF4              FC              equ     $08     ; Function call error
  69+ 0FF4              OV              equ     $0A     ; Overflow
  70+ 0FF4              OM              equ     $0C     ; Out of memory
  71+ 0FF4              UL              equ     $0E     ; Undefined line number
  72+ 0FF4              BS              equ     $10     ; Bad subscript
  73+ 0FF4              DD              equ     $12     ; Re-Dimensioned array
  74+ 0FF4              DZ              equ     $14     ; Division by zero (/0)
  75+ 0FF4              ID              equ     $16     ; Illegal direct
  76+ 0FF4              TM              equ     $18     ; Type mis-match
  77+ 0FF4              OS              equ     $1A     ; Out of string space
  78+ 0FF4              LS              equ     $1C     ; String too long
  79+ 0FF4              ST              equ     $1E     ; String formula too complex
  80+ 0FF4              CN              equ     $20     ; Can't continue
  81+ 0FF4              UF              equ     $22     ; Undefined FN function
  82+ 0FF4              MO              equ     $24     ; Missing operand
  83+ 0FF4              HX              equ     $26     ; HEX error
  84+ 0FF4              BN              equ     $28     ; BIN error
  85+ 0FF4              GM              equ     $2A     ; No Graphics Mode
  86+ 0FF4              SC              equ     $2C     ; Serial configuration
  87+ 0FF4              SA              equ     $2E     ; Serial port already open
  88+ 0FF4              SO              equ     $30     ; Serial buffer overrun
  89+ 0FF4              HP              equ     $32     ; HELP call
  90+ 0FF4
  91+ 0FF4              ; BASIC ERROR POINTER TABLE
  92+ 0FF4              ERRTBL: equ $
  93+ 0FF4 28 10        NFPTR:  defw    NFMSG
  94+ 0FF6 39 10        SNPTR:  defw    SNMSG
  95+ 0FF8 40 10        RGPTR:  defw    RGMSG
  96+ 0FFA 55 10        ODPTR:  defw    ODMSG
  97+ 0FFC 61 10        FCPTR:  defw    FCMSG
  98+ 0FFE 77 10        OVPTR:  defw    OVMSG
  99+ 1000 80 10        OMPTR:  defw    OMMSG
 100+ 1002 8E 10        ULPTR:  defw    ULMSG
 101+ 1004 9D 10        BSPTR:  defw    BSMSG
 102+ 1006 AB 10        DDPTR:  defw    DDMSG
 103+ 1008 C0 10        DZPTR:  defw    DZMSG
 104+ 100A D1 10        IDPTR:  defw    IDMSG
 105+ 100C E0 10        TMPTR:  defw    TMMSG
 106+ 100E EF 10        OSPTR:  defw    OSMSG
 107+ 1010 03 11        LSPTR:  defw    LSMSG
 108+ 1012 13 11        STPTR:  defw    STMSG
 109+ 1014 2E 11        CNPTR:  defw    CNMSG
 110+ 1016 3D 11        UFPTR:  defw    UFMSG
 111+ 1018 53 11        MOPTR:  defw    MOMSG
 112+ 101A 63 11        HXPTR:  defw    HXMSG
 113+ 101C 6E 11        BNPTR:  defw    BNMSG
 114+ 101E 79 11        GMPRT:  defw    GMMSG
 115+ 1020 8A 11        SCPTR:  defw    SCMSG
 116+ 1022 9F 11        SAPTR:  defw    SAMSG
 117+ 1024 B8 11        SOPTR:  defw    SOMSG
 118+ 1026 CE 11        HPPTR:  defw    HPMSG
 119+ 1028
 120+ 1028              ; BASIC ERROR MESSAGE LIST
 121+ 1028              ERRORS  equ $
 122+ 1028 4E 45 58 54  NFMSG:  defb    "NEXT Without FOR",0
 122+ 102C 20 57 69 74
 122+ 1030 68 6F 75 74
 122+ 1034 20 46 4F 52
 122+ 1038 00
 123+ 1039 53 79 6E 74  SNMSG:  defb    "Syntax",0
 123+ 103D 61 78 00
 124+ 1040 52 45 54 55  RGMSG:  defb    "RETURN without GOSUB",0
 124+ 1044 52 4E 20 77
 124+ 1048 69 74 68 6F
 124+ 104C 75 74 20 47
 124+ 1050 4F 53 55 42
 124+ 1054 00
 125+ 1055 4F 75 74 20  ODMSG:  defb    "Out of DATA",0
 125+ 1059 6F 66 20 44
 125+ 105D 41 54 41 00
 126+ 1061 49 6C 6C 65  FCMSG:  defb    "Illegal Function Call",0
 126+ 1065 67 61 6C 20
 126+ 1069 46 75 6E 63
 126+ 106D 74 69 6F 6E
 126+ 1071 20 43 61 6C
 126+ 1075 6C 00
 127+ 1077 4F 76 65 72  OVMSG:  defb    "Overflow",0
 127+ 107B 66 6C 6F 77
 127+ 107F 00
 128+ 1080 4F 75 74 20  OMMSG:  defb    "Out of Memory",0
 128+ 1084 6F 66 20 4D
 128+ 1088 65 6D 6F 72
 128+ 108C 79 00
 129+ 108E 55 6E 64 65  ULMSG:  defb    "Undefined Line",0
 129+ 1092 66 69 6E 65
 129+ 1096 64 20 4C 69
 129+ 109A 6E 65 00
 130+ 109D 42 61 64 20  BSMSG:  defb    "Bad Subscript",0
 130+ 10A1 53 75 62 73
 130+ 10A5 63 72 69 70
 130+ 10A9 74 00
 131+ 10AB 52 65 2D 44  DDMSG:  defb    "Re-Dimensioned Array",0
 131+ 10AF 69 6D 65 6E
 131+ 10B3 73 69 6F 6E
 131+ 10B7 65 64 20 41
 131+ 10BB 72 72 61 79
 131+ 10BF 00
 132+ 10C0 44 69 76 69  DZMSG:  defb    "Division by Zero",0
 132+ 10C4 73 69 6F 6E
 132+ 10C8 20 62 79 20
 132+ 10CC 5A 65 72 6F
 132+ 10D0 00
 133+ 10D1 49 6C 6C 65  IDMSG:  defb    "Illegal Direct",0
 133+ 10D5 67 61 6C 20
 133+ 10D9 44 69 72 65
 133+ 10DD 63 74 00
 134+ 10E0 54 79 70 65  TMMSG:  defb    "Type Mis-match",0
 134+ 10E4 20 4D 69 73
 134+ 10E8 2D 6D 61 74
 134+ 10EC 63 68 00
 135+ 10EF 4F 75 74 20  OSMSG:  defb    "Out of String Space",0
 135+ 10F3 6F 66 20 53
 135+ 10F7 74 72 69 6E
 135+ 10FB 67 20 53 70
 135+ 10FF 61 63 65 00
 136+ 1103 53 74 72 69  LSMSG:  defb    "String Too Long",0
 136+ 1107 6E 67 20 54
 136+ 110B 6F 6F 20 4C
 136+ 110F 6F 6E 67 00
 137+ 1113 53 74 72 69  STMSG:  defb    "String Formula Too Complex",0
 137+ 1117 6E 67 20 46
 137+ 111B 6F 72 6D 75
 137+ 111F 6C 61 20 54
 137+ 1123 6F 6F 20 43
 137+ 1127 6F 6D 70 6C
 137+ 112B 65 78 00
 138+ 112E 43 61 6E 27  CNMSG:  defb    "Can't Continue",0
 138+ 1132 74 20 43 6F
 138+ 1136 6E 74 69 6E
 138+ 113A 75 65 00
 139+ 113D 55 6E 64 65  UFMSG:  defb    "Undefined FN Function",0
 139+ 1141 66 69 6E 65
 139+ 1145 64 20 46 4E
 139+ 1149 20 46 75 6E
 139+ 114D 63 74 69 6F
 139+ 1151 6E 00
 140+ 1153 4D 69 73 73  MOMSG:  defb    "Missing Operand",0
 140+ 1157 69 6E 67 20
 140+ 115B 4F 70 65 72
 140+ 115F 61 6E 64 00
 141+ 1163 48 45 58 20  HXMSG:  defb    "HEX Format",0
 141+ 1167 46 6F 72 6D
 141+ 116B 61 74 00
 142+ 116E 42 49 4E 20  BNMSG:  defb    "BIN Format",0
 142+ 1172 46 6F 72 6D
 142+ 1176 61 74 00
 143+ 1179 4E 6F 20 47  GMMSG:  defb    "No Graphics Mode",0
 143+ 117D 72 61 70 68
 143+ 1181 69 63 73 20
 143+ 1185 4D 6F 64 65
 143+ 1189 00
 144+ 118A 53 65 72 69  SCMSG:  defb    "Serial Configuration",0
 144+ 118E 61 6C 20 43
 144+ 1192 6F 6E 66 69
 144+ 1196 67 75 72 61
 144+ 119A 74 69 6F 6E
 144+ 119E 00
 145+ 119F 53 65 72 69  SAMSG:  defb    "Serial Port Already Open",0
 145+ 11A3 61 6C 20 50
 145+ 11A7 6F 72 74 20
 145+ 11AB 41 6C 72 65
 145+ 11AF 61 64 79 20
 145+ 11B3 4F 70 65 6E
 145+ 11B7 00
 146+ 11B8 53 65 72 69  SOMSG:  defb    "Serial Buffer Overrun",0
 146+ 11BC 61 6C 20 42
 146+ 11C0 75 66 66 65
 146+ 11C4 72 20 4F 76
 146+ 11C8 65 72 72 75
 146+ 11CC 6E 00
 147+ 11CE 48 45 4C 50  HPMSG:  defb    "HELP Call",0
 147+ 11D2 20 43 61 6C
 147+ 11D6 6C 00
 148+ 11D8
 149+ 11D8
 150+ 11D8              ;-----------------------------------------------------------------------------
 151+ 11D8              ; STARTING POINTS FOR BASIC BOOT
 152+ 11D8              ; COLD: reset every memory pointer, acting as a power-up boot
 153+ 11D8              ; WARM: preserve program in memory, keeping every current pointer
 154+ 11D8
 155+ 11D8 C3 DE 11     COLD:   jp      STARTB          ; Jump for cold start
 156+ 11DB C3 8C 12     WARM:   jp      WARMST          ; Jump for warm start
 157+ 11DE
 158+ 11DE C3 E5 11     STARTB: jp      CSTART          ; Jump to initialise
 159+ 11E1 99 1C                defw    DEINT           ; Get integer -32768 to 32767
 160+ 11E3 56 24                defw    ABPASS          ; Return integer in AB
 161+ 11E5 21 5E 80     CSTART: ld      HL,WRKSPC       ; Start of workspace RAM
 162+ 11E8 F9                   ld      SP,HL           ; Set up a temporary stack
 163+ 11E9 C3 9A 3F             jp      INITST          ; Go to initialise
 164+ 11EC
 165+ 11EC 21 59 15     INIT:   ld      HL,INITAB       ; Initialise workspace
 166+ 11EF 01 DC 00             ld      BC,INITBE-INITAB+3; Bytes to copy
 167+ 11F2 11 5E 80             ld      DE,WRKSPC       ; Into workspace RAM
 168+ 11F5 ED B0                ldir                    ; Copy data
 169+ 11F7 EB                   ex      DE,HL           ; Copy DE into HL
 170+ 11F8 F9                   ld      SP,HL           ; Temporary stack
 171+ 11F9 CD 0C 18             call    CLREG           ; Clear registers and stack
 172+ 11FC CD B0 1E             call    PRNTCRLF        ; Output CRLF
 173+ 11FF 32 91 81             ld      (BUFFER+88+1),A ; Mark end of buffer
 174+ 1202 32 47 82             ld      (PROGST),A      ; Initialise program area
 175+ 1205 18 13                jr      MNOASK          ; usually, don't ask for memory top (only when there are errors)
 176+ 1207 21 F3 12     MSIZE:  ld      HL,MEMMSG       ; Point to message
 177+ 120A CD 74 25             call    PRS             ; Output "Memory size"
 178+ 120D CD 29 18             call    PROMPT          ; Get input with '?'
 179+ 1210 CD 0A 09             call    CURSOR_ON       ; enable cursor
 180+ 1213 CD E3 1B             call    GETCHR          ; Get next character
 181+ 1216 B7                   or      A               ; Set flags
 182+ 1217 C2 2F 12             jp      NZ,TSTMEM       ; If number - Test if RAM there
 183+ 121A 21 AB 82     MNOASK: ld      HL,STLOOK       ; Point to start of RAM
 184+ 121D 23           MLOOP:  inc     HL              ; Next byte
 185+ 121E 7C                   ld      A,H             ; Above address FFFF ?
 186+ 121F B5                   or      L
 187+ 1220 CA 41 12             jp      Z,SETTOP        ; Yes - 64K RAM
 188+ 1223 7E                   ld      A,(HL)          ; Get contents
 189+ 1224 47                   ld      B,A             ; Save it
 190+ 1225 2F                   cpl                     ; Flip all bits
 191+ 1226 77                   ld      (HL),A          ; Put it back
 192+ 1227 BE                   cp      (HL)            ; RAM there if same
 193+ 1228 70                   ld      (HL),B          ; Restore old contents
 194+ 1229 CA 1D 12             jp      Z,MLOOP         ; If RAM - test next byte
 195+ 122C C3 41 12             jp      SETTOP          ; Top of RAM found
 196+ 122F
 197+ 122F CD B3 1C     TSTMEM: call    ATOH            ; Get high memory into DE
 198+ 1232 B7                   or      A               ; Set flags on last byte
 199+ 1233 C2 C0 16             jp      NZ,SNERR        ; ?SN Error if bad character
 200+ 1236 EB                   ex      DE,HL           ; Address into HL
 201+ 1237 2B                   dec     HL              ; Back one byte
 202+ 1238 3E D9                ld      A,%11011001     ; Test byte
 203+ 123A 46                   ld      B,(HL)          ; Get old contents
 204+ 123B 77                   ld      (HL),A          ; Load test byte
 205+ 123C BE                   cp      (HL)            ; RAM there if same
 206+ 123D 70                   ld      (HL),B          ; Restore old contents
 207+ 123E C2 07 12             jp      NZ,MSIZE        ; Ask again if no RAM
 208+ 1241
 209+ 1241 CD 1F 09     SETTOP: call    CURSOR_OFF      ; disable cursor
 210+ 1244 2B                   dec     HL              ; Back one byte
 211+ 1245 11 AA 82             ld      DE,STLOOK-1     ; See if enough RAM
 212+ 1248 CD 9C 19             call    CPDEHL          ; Compare DE with HL
 213+ 124B DA 07 12             jp      C,MSIZE         ; Ask again if not enough RAM
 214+ 124E 3A 23 82             ld      A,(DOS_EN)      ; read if the user enabled/disabled DOS while booting
 215+ 1251 1F                   rra                     ; is DOS disabled?
 216+ 1252 30 04                jr      NC,NODOS        ; yes, so jump over
 217+ 1254 11 00 FE             ld      DE,0-512        ; no, so reserve 512 bytes on top of RAM...
 218+ 1257 19                   add     HL,DE           ; ...for I/O buffer
 219+ 1258 11 9C FF     NODOS:  ld      DE,0-100        ; 100 Bytes string space
 220+ 125B 22 96 81             ld      (LSTRAM),HL     ; Save last available RAM
 221+ 125E 19                   add     HL,DE           ; Allocate string space
 222+ 125F 22 AD 80             ld      (STRSPC),HL     ; Save string space
 223+ 1262 CD E7 17             call    CLRPTR          ; Clear program area
 224+ 1265 2A AD 80             ld      HL,(STRSPC)     ; Get end of memory
 225+ 1268 11 EF FF             ld      DE,0-17         ; Offset for free bytes
 226+ 126B 19                   add     HL,DE           ; Adjust HL
 227+ 126C 11 47 82             ld      DE,PROGST       ; Start of program text
 228+ 126F 7D                   ld      A,L             ; Get LSB
 229+ 1270 93                   sub     E               ; Adjust it
 230+ 1271 6F                   ld      L,A             ; Re-save
 231+ 1272 7C                   ld      A,H             ; Get MSB
 232+ 1273 9A                   sbc     A,D             ; Adjust it
 233+ 1274 67                   ld      H,A             ; Re-save
 234+ 1275 E5                   push    HL              ; Save bytes free
 235+ 1276 21 B2 12             ld      HL,SIGNON       ; Sign-on message
 236+ 1279 CD 74 25             call    PRS             ; Output string
 237+ 127C 21 9B 12             ld      HL,BLNSPC       ; Empty space
 238+ 127F CD 74 25             call    PRS             ; Output string
 239+ 1282 E1                   pop     HL              ; Get bytes free back
 240+ 1283 CD 13 30             call    PRNTHL          ; Output amount of free memory
 241+ 1286 21 A4 12             ld      HL,BFREE        ; " Bytes free" message
 242+ 1289 CD 74 25             call    PRS             ; Output string
 243+ 128C
 244+ 128C 31 3D 81     WARMST: ld      SP,STACK        ; Temporary stack
 245+ 128F CD 0C 18     BRKRET: call    CLREG           ; Clear registers and stack
 246+ 1292 CD 31 3D             call    RESFN           ; reset FN keys and auto-repeat
 247+ 1295 CD 0A 09             call    CURSOR_ON       ; enable cursor
 248+ 1298 C3 1A 17             jp      PRNTOK          ; Go to get command line
 249+ 129B
 250+ 129B 20 20 20 20  BLNSPC: defb    "        ",0    ; 8 empty cells to align the "XXXX Bytes free" message
 250+ 129F 20 20 20 20
 250+ 12A3 00
 251+ 12A4 20 42 79 74  BFREE:  defb    " Bytes free",CR,CR,0
 251+ 12A8 65 73 20 66
 251+ 12AC 72 65 65 0D
 251+ 12B0 0D 00
 252+ 12B2
 253+ 12B2 4C 4D 38 30  SIGNON: defb    "LM80C BASIC 3.16 ",251,"2021 L.Miliani"
 253+ 12B6 43 20 42 41
 253+ 12BA 53 49 43 20
 253+ 12BE 33 2E 31 36
 253+ 12C2 20 FB 32 30
 253+ 12C6 32 31 20 4C
 253+ 12CA 2E 4D 69 6C
 253+ 12CE 69 61 6E 69
 254+ 12D2 20 5A 38 30          defb    " Z80 BASIC 4.7  ",251,"1978 Microsoft",CR,0
 254+ 12D6 20 42 41 53
 254+ 12DA 49 43 20 34
 254+ 12DE 2E 37 20 20
 254+ 12E2 FB 31 39 37
 254+ 12E6 38 20 4D 69
 254+ 12EA 63 72 6F 73
 254+ 12EE 6F 66 74 0D
 254+ 12F2 00
 255+ 12F3
 256+ 12F3 4D 65 6D 6F  MEMMSG: defb    "Memory top",0
 256+ 12F7 72 79 20 74
 256+ 12FB 6F 70 00
 257+ 12FE
 258+ 12FE              ; The following list reports all the functions supported by the interpreter.
 259+ 12FE              ; To add a custom function, the user must first insert the reserved word here,
 260+ 12FE              ; then into the list of the reserved words below, and finally must increment the
 261+ 12FE              ; ZSGN token value and all the following ones after ZSGN by 1 for every added
 262+ 12FE              ; function.
 263+ 12FE
 264+ 12FE              ; FUNCTION ADDRESS TABLE (this is a sort of offset table)
 265+ 12FE              ; this list must be coherent with the tokens' functions list. This means that every
 266+ 12FE              ; entry here must have the corresponding entry in the tokens list.
 267+ 12FE 88 2E        FNCTAB: defw    SGN
 268+ 1300 1E 24                defw    TMR         ; added by Leonardo Miliani
 269+ 1302 4C 2F                defw    INT
 270+ 1304 9E 2E                defw    ABS_        ; _ necessary for assembler warning
 271+ 1306 64 80                defw    USR
 272+ 1308 34 24                defw    FRE
 273+ 130A AF 28                defw    INP
 274+ 130C 62 24                defw    POS
 275+ 130E 12 31                defw    SQR
 276+ 1310 F1 31                defw    RND
 277+ 1312 DC 2C                defw    LOG
 278+ 1314 60 31                defw    EXP
 279+ 1316 66 32                defw    COS
 280+ 1318 6C 32                defw    SIN
 281+ 131A CD 32                defw    TAN
 282+ 131C E2 32                defw    ATN
 283+ 131E 8B 29                defw    PEEK
 284+ 1320 4D 33                defw    DEEK
 285+ 1322 92 29                defw    VPEEK       ; added by Leonardo Miliani
 286+ 1324 61 2B                defw    VSTAT       ; added by Leonardo Miliani
 287+ 1326 6C 2B                defw    SSTAT       ; added by Leonardo Miliani
 288+ 1328 80 2B                defw    INKEY       ; added by Leonardo Miliani
 289+ 132A A6 36                defw    POINT       ; added by Leonardo Miliani
 290+ 132C 46 27                defw    INSTR       ; added by Leonardo Miliani
 291+ 132E E6 26                defw    LEN
 292+ 1330 FE 24                defw    STR
 293+ 1332 76 28                defw    VAL
 294+ 1334 F5 26                defw    ASC
 295+ 1336 06 27                defw    CHR
 296+ 1338 95 3E                defw    HEX         ; added by Grant Searle
 297+ 133A 26 3F                defw    BIN         ; added by Grant Searle
 298+ 133C 16 27                defw    LEFT
 299+ 133E 3C 28                defw    RIGHT
 300+ 1340 46 28                defw    MID
 301+ 1342
 302+ 1342              ; RESERVED WORD LIST
 303+ 1342              ; Here are all the reserved words used by the interpreter
 304+ 1342              ; To add custom functions/commands, the user must insert the keyword
 305+ 1342              ; in this list, following the schematic
 306+ 1342 C5 4E 44     WORDS:  defb    'E'+$80,"ND"            ; from here the list contains the COMMANDS
 307+ 1345 C6 4F 52             defb    'F'+$80,"OR"
 308+ 1348 CE 45 58 54          defb    'N'+$80,"EXT"
 309+ 134C C4 41 54 41          defb    'D'+$80,"ATA"
 310+ 1350 C9 4E 50 55          defb    'I'+$80,"NPUT"
 310+ 1354 54
 311+ 1355 C4 49 4D             defb    'D'+$80,"IM"
 312+ 1358 D2 45 41 44          defb    'R'+$80,"EAD"
 313+ 135C CC 45 54             defb    'L'+$80,"ET"
 314+ 135F C7 4F 54 4F          defb    'G'+$80,"OTO"
 315+ 1363 D2 55 4E             defb    'R'+$80,"UN"
 316+ 1366 C9 46                defb    'I'+$80,"F"
 317+ 1368 D2 45 53 54          defb    'R'+$80,"ESTORE"
 317+ 136C 4F 52 45
 318+ 136F C7 4F 53 55          defb    'G'+$80,"OSUB"
 318+ 1373 42
 319+ 1374 D2 45 54 55          defb    'R'+$80,"ETURN"
 319+ 1378 52 4E
 320+ 137A D2 45 4D             defb    'R'+$80,"EM"            ; original REM
 321+ 137D D3 54 4F 50          defb    'S'+$80,"TOP"
 322+ 1381 CF 55 54             defb    'O'+$80,"UT"
 323+ 1384 CF 4E                defb    'O'+$80,"N"
 324+ 1386 C6 49 4C 45          defb    'F'+$80,"ILES"
 324+ 138A 53
 325+ 138B C5 52 41 53          defb    'E'+$80,"RASE"          ; added by Leonardo Miliani
 325+ 138F 45
 326+ 1390 D7 41 49 54          defb    'W'+$80,"AIT"
 327+ 1394 C4 45 46             defb    'D'+$80,"EF"
 328+ 1397 D0 4F 4B 45          defb    'P'+$80,"OKE"
 329+ 139B C4 4F 4B 45          defb    'D'+$80,"OKE"
 330+ 139F D6 50 4F 4B          defb    'V'+$80,"POKE"          ; added by Leonardo Miliani
 330+ 13A3 45
 331+ 13A4 D3 52 45 47          defb    'S'+$80,"REG"           ; added by Leonardo Miliani
 332+ 13A8 D6 52 45 47          defb    'V'+$80,"REG"           ; added by Leonardo Miliani
 333+ 13AC D3 43 52 45          defb    'S'+$80,"CREEN"         ; changed by Leonardo Miliani
 333+ 13B0 45 4E
 334+ 13B2 CC 4F 43 41          defb    'L'+$80,"OCATE"         ; added by Leonardo Miliani
 334+ 13B6 54 45
 335+ 13B8 D3 4F 55 4E          defb    'S'+$80,"OUND"          ; added by Leonardo Miliani
 335+ 13BC 44
 336+ 13BD D6 4F 4C 55          defb    'V'+$80,"OLUME"         ; added by Leonardo Miliani
 336+ 13C1 4D 45
 337+ 13C3 D0 41 55 53          defb    'P'+$80,"AUSE"          ; added by Leonardo Miliani
 337+ 13C7 45
 338+ 13C8 C3 4F 4C 4F          defb    'C'+$80,"OLOR"          ; added by Leonardo Miliani
 338+ 13CC 52
 339+ 13CD D0 4C 4F 54          defb    'P'+$80,"LOT"           ; added by Leonardo Miliani
 340+ 13D1 C4 52 41 57          defb    'D'+$80,"RAW"           ; added by Leonardo Miliani
 341+ 13D5 C3 49 52 43          defb    'C'+$80,"IRCLE"         ; added by Leonardo Miliani
 341+ 13D9 4C 45
 342+ 13DB D0 41 49 4E          defb    'P'+$80,"AINT"          ; added by Leonardo Miliani
 342+ 13DF 54
 343+ 13E0 D3 45 52 49          defb    'S'+$80,"ERIAL"         ; added by Leonardo Miliani
 343+ 13E4 41 4C
 344+ 13E6 C8 45 4C 50          defb    'H'+$80,"ELP"           ; changed by Leonardo Miliani - was LINES
 345+ 13EA C3 4C 53             defb    'C'+$80,"LS"            ; restored command
 346+ 13ED CB 45 59             defb    'K'+$80,"EY"            ; added by Leonardo Miliani
 347+ 13F0 CE 4D 49             defb    'N'+$80,"MI"            ; added by Leonardo Miliani
 348+ 13F3 C7 50 52 49          defb    'G'+$80,"PRINT"         ; added by Leonardo Miliani
 348+ 13F7 4E 54
 349+ 13F9 D7 49 44 54          defb    'W'+$80,"IDTH"
 349+ 13FD 48
 350+ 13FE D3 59 53             defb    'S'+$80,"YS"            ; added by Leonardo Miliani
 351+ 1401 D2 45 53 45          defb    'R'+$80,"ESET"          ; changed by Leonardo Miliani
 351+ 1405 54
 352+ 1406 C5 4C 53 45          defb    'E'+$80,"LSE"           ; added by Leonardo Miliani
 353+ 140A D0 52 49 4E          defb    'P'+$80,"RINT"
 353+ 140E 54
 354+ 140F C3 4F 4E 54          defb    'C'+$80,"ONT"
 355+ 1413 CC 49 53 54          defb    'L'+$80,"IST"
 356+ 1417 C3 4C 45 41          defb    'C'+$80,"LEAR"
 356+ 141B 52
 357+ 141C CC 4F 41 44          defb    'L'+$80,"OAD"
 358+ 1420 D3 41 56 45          defb    'S'+$80,"AVE"
 359+ 1424 CE 45 57             defb    'N'+$80,"EW"
 360+ 1427 D4 41 42 28          defb    'T'+$80,"AB("
 361+ 142B D4 4F                defb    'T'+$80,"O"
 362+ 142D C6 4E                defb    'F'+$80,"N"
 363+ 142F D3 50 43 28          defb    'S'+$80,"PC("
 364+ 1433 D4 48 45 4E          defb    'T'+$80,"HEN"
 365+ 1437 CE 4F 54             defb    'N'+$80,"OT"
 366+ 143A D3 54 45 50          defb    'S'+$80,"TEP"
 367+ 143E                      ; from here: operators
 368+ 143E AB                   defb    '+'+$80
 369+ 143F AD                   defb    '-'+$80
 370+ 1440 AA                   defb    '*'+$80
 371+ 1441 AF                   defb    '/'+$80
 372+ 1442 A5                   defb    '%'+$80
 373+ 1443 A3                   defb    '#'+$80
 374+ 1444 DE                   defb    '^'+$80
 375+ 1445 C1 4E 44             defb    'A'+$80,"ND"
 376+ 1448 D8 4F 52             defb    'X'+$80,"OR"
 377+ 144B CF 52                defb    'O'+$80,"R"
 378+ 144D BE                   defb    '>'+$80
 379+ 144E BD                   defb    '='+$80
 380+ 144F BC                   defb    '<'+$80
 381+ 1450
 382+ 1450                      ; from here there are the tokens' FUNCTIONS list
 383+ 1450                      ; this list must be coherent with the functions list above
 384+ 1450 D3 47 4E             defb    'S'+$80,"GN"
 385+ 1453 D4 4D 52             defb    'T'+$80,"MR"            ; added by Leonardo Miliani
 386+ 1456 C9 4E 54             defb    'I'+$80,"NT"
 387+ 1459 C1 42 53             defb    'A'+$80,"BS"
 388+ 145C D5 53 52             defb    'U'+$80,"SR"
 389+ 145F C6 52 45             defb    'F'+$80,"RE"
 390+ 1462 C9 4E 50             defb    'I'+$80,"NP"
 391+ 1465 D0 4F 53             defb    'P'+$80,"OS"
 392+ 1468 D3 51 52             defb    'S'+$80,"QR"
 393+ 146B D2 4E 44             defb    'R'+$80,"ND"
 394+ 146E CC 4F 47             defb    'L'+$80,"OG"
 395+ 1471 C5 58 50             defb    'E'+$80,"XP"
 396+ 1474 C3 4F 53             defb    'C'+$80,"OS"
 397+ 1477 D3 49 4E             defb    'S'+$80,"IN"
 398+ 147A D4 41 4E             defb    'T'+$80,"AN"
 399+ 147D C1 54 4E             defb    'A'+$80,"TN"
 400+ 1480 D0 45 45 4B          defb    'P'+$80,"EEK"
 401+ 1484 C4 45 45 4B          defb    'D'+$80,"EEK"
 402+ 1488 D6 50 45 45          defb    'V'+$80,"PEEK"          ; added by Leonardo Miliani
 402+ 148C 4B
 403+ 148D D6 53 54 41          defb    'V'+$80,"STAT"          ; added by Leonardo Miliani
 403+ 1491 54
 404+ 1492 D3 53 54 41          defb    'S'+$80,"STAT"          ; added by Leonardo Miliani
 404+ 1496 54
 405+ 1497 C9 4E 4B 45          defb    'I'+$80,"NKEY"          ; added by Leonardo Miliani
 405+ 149B 59
 406+ 149C D0 4F 49 4E          defb    'P'+$80,"OINT"          ; added by Leonardo Miliani
 406+ 14A0 54
 407+ 14A1 C9 4E 53 54          defb    'I'+$80,"NSTR"          ; added by Leonardo Miliani
 407+ 14A5 52
 408+ 14A6 CC 45 4E             defb    'L'+$80,"EN"
 409+ 14A9 D3 54 52 24          defb    'S'+$80,"TR$"
 410+ 14AD D6 41 4C             defb    'V'+$80,"AL"
 411+ 14B0 C1 53 43             defb    'A'+$80,"SC"
 412+ 14B3 C3 48 52 24          defb    'C'+$80,"HR$"
 413+ 14B7 C8 45 58 24          defb    'H'+$80,"EX$"           ; added by Grant Searle
 414+ 14BB C2 49 4E 24          defb    'B'+$80,"IN$"           ; added by Grant Searle
 415+ 14BF CC 45 46 54          defb    'L'+$80,"EFT$"
 415+ 14C3 24
 416+ 14C4 D2 49 47 48          defb    'R'+$80,"IGHT$"
 416+ 14C8 54 24
 417+ 14CA CD 49 44 24          defb    'M'+$80,"ID$"
 418+ 14CE 80                   defb    $80                     ; End-of-list marker
 419+ 14CF
 420+ 14CF              ; KEYWORD ADDRESS TABLE
 421+ 14CF              ; this list must be coherent with the commands'
 422+ 14CF              ; tokens list above
 423+ 14CF 2D 1C        WORDTB: defw    PEND
 424+ 14D1 2A 1B                defw    FOR
 425+ 14D3 21 20                defw    NEXT
 426+ 14D5 8C 1D                defw    DATA
 427+ 14D7 26 1F                defw    INPUT
 428+ 14D9 76 22                defw    DIM
 429+ 14DB 58 1F                defw    READ
 430+ 14DD A3 1D                defw    LET
 431+ 14DF 49 1D                defw    GOTO
 432+ 14E1 24 1D                defw    RUN
 433+ 14E3 1B 1E                defw    IF
 434+ 14E5 F3 1B                defw    RESTOR
 435+ 14E7 38 1D                defw    GOSUB
 436+ 14E9 67 1D                defw    RETURN
 437+ 14EB 8E 1D                defw    REM         ; original REM
 438+ 14ED 2B 1C                defw    STOP
 439+ 14EF BB 28                defw    POUT
 440+ 14F1 FD 1D                defw    ON
 441+ 14F3 93 3E                defw    FILES       ; changed by Leonardo Miliani - was NULL
 442+ 14F5 94 3E                defw    ERASE       ; added by Leonardo Miliani
 443+ 14F7 C1 28                defw    WAIT
 444+ 14F9 6A 24                defw    DEF
 445+ 14FB B5 29                defw    POKE
 446+ 14FD 58 33                defw    DOKE
 447+ 14FF BA 29                defw    VPOKE       ; added by Leonardo Miliani
 448+ 1501 F7 29                defw    SREG        ; added by Leonardo Miliani
 449+ 1503 45 2B                defw    VREG        ; added by Leonardo Miliani
 450+ 1505 8E 33                defw    SCREEN      ; new behaviour: now it sets up a graphics mode (Leonardo Miliani)
 451+ 1507 C5 29                defw    LOCATE      ; added by Leonardo Miliani
 452+ 1509 51 2A                defw    SOUND       ; added by Leonardo Miliani
 453+ 150B 18 2A                defw    VOLUME      ; added by Leonardo Miliani
 454+ 150D 6F 33                defw    PAUSE       ; added by Leonardo Miliani
 455+ 150F 09 34                defw    COLOR       ; added by Leonardo Miliani
 456+ 1511 F9 36                defw    PLOT        ; added by Leonardo Miliani
 457+ 1513 8C 37                defw    DRAW        ; added by Leonardo Miliani
 458+ 1515 C2 38                defw    CIRCLE      ; added by Leonardo Miliani
 459+ 1517 B6 35                defw    PAINT       ; added by Leonardo Miliani
 460+ 1519 C7 3A                defw    SERIAL      ; added by Leonardo Miliani
 461+ 151B 09 3D                defw    HELP        ; changed by Leonardo Miliani - was LINES
 462+ 151D 31 33                defw    CLS
 463+ 151F 24 3D                defw    KEY         ; added by Leonardo Miliani
 464+ 1521 03 29                defw    NMI         ; added by Leonardo Miliani
 465+ 1523 C5 34                defw    GPRINT      ; added by Leonardo Miliani
 466+ 1525 45 33                defw    WIDTH
 467+ 1527 5D 29                defw    SYS         ; added by Leonardo Miliani
 468+ 1529 8B 3F                defw    RESET       ; new behaviour: now it resets the system
 469+ 152B 90 1D                defw    REM+2       ; ELSE: added by Leonardo Miliani
 470+ 152D 4D 1E                defw    PRINT
 471+ 152F 5F 1C                defw    CONT
 472+ 1531 01 1A                defw    LIST
 473+ 1533 D8 1C                defw    CLEAR
 474+ 1535 91 3E                defw    LOAD        ; re-implemented by Leonardo Miliani (was CLOAD)
 475+ 1537 92 3E                defw    SAVE        ; re-implemented by Leonardo Miliani (was CSAVE)
 476+ 1539 E6 17                defw    NEW
 477+ 153B
 478+ 153B              ; RESERVED WORD TOKEN VALUES
 479+ 153B              ; if you add a function or command you must increment by 1
 480+ 153B              ; the values below. Pay attention that you must increment only the
 481+ 153B              ; values AFTER the position where you entered the function/command word
 482+ 153B              ; in the "Reserver word list" above. I.E.: VPOKE has been added between
 483+ 153B              ; DOKE and SCREEN, and since REM is the reserved work listed below
 484+ 153B              ; that is before the point where VPOKE has been entered, every entry
 485+ 153B              ; after REM has been incremented.
 486+ 153B              ; Another example: when TMR has been added, since it's a function, every
 487+ 153B              ; entry after & included ZSGN must be checked (read below)
 488+ 153B
 489+ 153B              ZEND    equ     $80             ; END        <-- from here, there are the commands
 490+ 153B              ZFOR    equ     $81             ; FOR
 491+ 153B              ZDATA   equ     $83             ; DATA
 492+ 153B              ZGOTO   equ     $88             ; GOTO
 493+ 153B              ZGOSUB  equ     $8C             ; GOSUB
 494+ 153B              ZREM    equ     $8E             ; REM
 495+ 153B              ZELSE   equ     $AE             ; ELSE
 496+ 153B              ZPRINT  equ     $AF             ; PRINT
 497+ 153B              ZNEW    equ     $B5             ; NEW
 498+ 153B
 499+ 153B              ZTAB    equ     $B6             ; TAB
 500+ 153B              ZTO     equ     $B7             ; TO
 501+ 153B              ZFN     equ     $B8             ; FN
 502+ 153B              ZSPC    equ     $B9             ; SPC
 503+ 153B              ZTHEN   equ     $BA             ; THEN
 504+ 153B              ZNOT    equ     $BB             ; NOT
 505+ 153B              ZSTEP   equ     $BC             ; STEP
 506+ 153B
 507+ 153B              ZPLUS   equ     $BD             ; +         <-- from here, there are the math operators
 508+ 153B              ZMINUS  equ     $BE             ; -
 509+ 153B              ZTIMES  equ     $BF             ; *
 510+ 153B              ZDIV    equ     $C0             ; /
 511+ 153B              ZMOD    equ     $C1             ; %
 512+ 153B              ZDINT   equ     $C2             ; #
 513+ 153B              ZOR     equ     $C6             ; OR
 514+ 153B              ZGTR    equ     $C7             ; >
 515+ 153B              ZEQUAL  equ     $C8             ; M
 516+ 153B              ZLTH    equ     $C9             ; <
 517+ 153B
 518+ 153B              ZSGN    equ     $CA             ; SGN       <-- from here, there are the functions
 519+ 153B              ZPOINT  equ     $E0             ; ZPOINT    <-- if the user enters a custom function, between
 520+ 153B                                              ;               SGN and POINT, he/she must increment this pointer by 1
 521+ 153B              ZINSTR  equ     $E1             ; ZINSTR    <-- same here
 522+ 153B              ZLEFT   equ     $E9             ; LEFT$     <-- if the user enters a custom function anywhere,
 523+ 153B                                              ;               he/she must increment this pointer by 1
 524+ 153B
 525+ 153B              ; ARITHMETIC PRECEDENCE TABLE
 526+ 153B              ; in the formulas below, <last> is a number stored into the stack that must be retrieved
 527+ 153B              ; with POP BC, POP DE; FPREG is a f.p. number store into the RAM register FPREG
 528+ 153B 79           PRITAB: defb    $79             ; Precedence value
 529+ 153C FA 2F                defw    PADD            ; FPREG = <last> + FPREG
 530+ 153E
 531+ 153E 79                   defb    $79             ; Precedence value
 532+ 153F DD 2B                defw    PSUB            ; FPREG = <last> - FPREG
 533+ 1541
 534+ 1541 7C                   defb    $7C             ; Precedence value
 535+ 1542 1B 2D                defw    MULT            ; PPREG = <last> * FPREG
 536+ 1544
 537+ 1544 7C                   defb    $7C             ; Precedence value
 538+ 1545 CD 2D                defw    DIV             ; FPREG = <last> / FPREG
 539+ 1547
 540+ 1547 7C                   defb    $7C             ; Precedence value
 541+ 1548 78 2D                defw    MOD             ; FPREG = INT(<last>)-(INT(FPREG)*INT(<last>/FPREG))
 542+ 154A
 543+ 154A 7C                   defb    $7C             ; precedence value
 544+ 154B 70 2D                defw    DINT            ; FPREG = INT(<last> / FPREG )
 545+ 154D
 546+ 154D 7F                   defb    $7F             ; Precedence value
 547+ 154E 1B 31                defw    POWER           ; FPREG = <last> ^ FPREG
 548+ 1550
 549+ 1550 50                   defb    $50             ; Precedence value
 550+ 1551 BF 21                defw    PAND            ; FPREG = <last> AND FPREG
 551+ 1553
 552+ 1553 4A                   defb    $4A             ; Precedence value
 553+ 1554 C7 21                defw    PXOR            ; FPREG = <last> XOR FPREG
 554+ 1556
 555+ 1556 46                   defb    $46             ; Precedence value
 556+ 1557 C2 21                defw    POR             ; FPREG = <last> OR FPREG
 557+ 1559
 558+ 1559
 559+ 1559              ; INITIALISATION TABLE -------------------------------------------------------
 560+ 1559              ; these values are copied into RAM at startup
 561+ 1559 C3 8C 12     INITAB: jp      WARMST          ; Warm start jump
 562+ 155C ED 45 00             defb    $ED,$45,$00     ; RETN + NOP for default NMI service routine
 563+ 155F C3 AE 1C             jp      FCERR           ; "USR (X)" jump (Set to Error)
 564+ 1562 D3 00                out     (0),A           ; "out p,n" skeleton
 565+ 1564 C9                   ret
 566+ 1565 D6 00                sub     $00             ; Division support routine
 567+ 1567 6F                   ld      L,A
 568+ 1568 7C                   ld      A,H
 569+ 1569 DE 00                sbc     A,$00
 570+ 156B 67                   ld      H,A
 571+ 156C 78                   ld      A,B
 572+ 156D DE 00                sbc     A,$00
 573+ 156F 47                   ld      B,A
 574+ 1570 3E 00                ld      A,$00
 575+ 1572 C9                   ret
 576+ 1573 00 00 00             defb    $00,$00,$00     ; Random number seed table used by RND
 577+ 1576 35 4A CA 99          defb    $35,$4A,$CA,$99 ;-2.65145E+07
 578+ 157A 39 1C 76 98          defb    $39,$1C,$76,$98 ; 1.61291E+07
 579+ 157E 22 95 B3 98          defb    $22,$95,$B3,$98 ;-1.17691E+07
 580+ 1582 0A DD 47 98          defb    $0A,$DD,$47,$98 ; 1.30983E+07
 581+ 1586 53 D1 99 99          defb    $53,$D1,$99,$99 ;-2-01612E+07
 582+ 158A 0A 1A 9F 98          defb    $0A,$1A,$9F,$98 ;-1.04269E+07
 583+ 158E 65 BC CD 98          defb    $65,$BC,$CD,$98 ;-1.34831E+07
 584+ 1592 D6 77 3E 98          defb    $D6,$77,$3E,$98 ; 1.24825E+07
 585+ 1596 52 C7 4F 80          defb    $52,$C7,$4F,$80 ; Last random number
 586+ 159A DB 00                in      A,($00)         ; INP (x) skeleton
 587+ 159C C9                   ret
 588+ 159D FF                   defb    $FF             ; Terminal width (255 = no auto CRLF)
 589+ 159E 14                   defb    $14             ; Width for commas (at reset, 3 columns, for G1 mode)
 590+ 159F 00                   defb    $00             ; No nulls after input bytes
 591+ 15A0 00                   defb    $00             ; Output enabled (^O off)
 592+ 15A1 00 00                defw    $00             ; Array load/save check sum
 593+ 15A3 00                   defb    $00             ; Break not by NMI
 594+ 15A4 00                   defb    $00             ; Break flag
 595+ 15A5 C3 22 19             jp      TTYLIN          ; Input reflection (set to TTY)
 596+ 15A8 AB 82                defw    STLOOK          ; Temp string space
 597+ 15AA FE FF                defw    -2              ; Current line number (cold)
 598+ 15AC FF FF                defw    -1              ; Current line with errors (no errors)
 599+ 15AE 40           AUTORP: defb    $40             ; delay for key auto-repeat start
 600+ 15AF 08                   defb    $08             ; auto-repeat delay
 601+ 15B0 4C 49 53 54  DEFFNKS:defm    "LIST",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 1
 601+ 15B4 0D 00 00 00
 601+ 15B8 00 00 00 00
 601+ 15BC 00 00 00 00
 602+ 15C0 52 55 4E 0D          defm    "RUN",13,0,0,0,0,0,0,0,0,0,0,0,0    ; KEY 2
 602+ 15C4 00 00 00 00
 602+ 15C8 00 00 00 00
 602+ 15CC 00 00 00 00
 603+ 15D0 53 43 52 45          defm    "SCREEN1",13,0,0,0,0,0,0,0,0        ; KEY 3
 603+ 15D4 45 4E 31 0D
 603+ 15D8 00 00 00 00
 603+ 15DC 00 00 00 00
 604+ 15E0 43 4F 4C 4F          defm    "COLOR1,15,5",13,0,0,0,0            ; KEY 4
 604+ 15E4 52 31 2C 31
 604+ 15E8 35 2C 35 0D
 604+ 15EC 00 00 00 00
 605+ 15F0 53 45 52 49          defm    "SERIAL1,38400",13,0,0              ; KEY 5
 605+ 15F4 41 4C 31 2C
 605+ 15F8 33 38 34 30
 605+ 15FC 30 0D 00 00
 606+ 1600 53 43 52 45          defm    "SCREEN2",13,0,0,0,0,0,0,0,0        ; KEY 6
 606+ 1604 45 4E 32 0D
 606+ 1608 00 00 00 00
 606+ 160C 00 00 00 00
 607+ 1610 43 4F 4E 54          defm    "CONT",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 7
 607+ 1614 0D 00 00 00
 607+ 1618 00 00 00 00
 607+ 161C 00 00 00 00
 608+ 1620 48 45 4C 50          defm    "HELP",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 8 (HELP KEY)
 608+ 1624 0D 00 00 00
 608+ 1628 00 00 00 00
 608+ 162C 00 00 00 00
 609+ 1630 48 82                defw    PROGST+1        ; Start of program text
 610+ 1632              INITBE:
 611+ 1632
 612+ 1632              ; END OF INITIALISATION TABLE ---------------------------------------------------
 613+ 1632
 614+ 1632 20 45 72 72  ERRMSG: defb    " Error",0
 614+ 1636 6F 72 00
 615+ 1639 20 69 6E 20  INMSG:  defb    " in ",0
 615+ 163D 00
 616+ 163E              ZERBYT  equ     $-1             ; A zero byte
 617+ 163E 4F 6B 0D 00  OKMSG:  defb    "Ok",CR,0,0
 617+ 1642 00
 618+ 1643 42 72 65 61  BRKMSG: defb    "Break",0
 618+ 1647 6B 00
 619+ 1649
 620+ 1649 21 04 00     BAKSTK: ld      HL,$04          ; Look for "FOR" block with
 621+ 164C 39                   add     HL,SP           ; same index as specified
 622+ 164D 7E           LOKFOR: ld      A,(HL)          ; Get block ID
 623+ 164E 23                   inc     HL              ; Point to index address
 624+ 164F FE 81                cp      ZFOR            ; Is it a "FOR" token
 625+ 1651 C0                   ret     NZ              ; No - exit
 626+ 1652 4E                   ld      C,(HL)          ; BC = Address of "FOR" index
 627+ 1653 23                   inc     HL
 628+ 1654 46                   ld      B,(HL)
 629+ 1655 23                   inc     HL              ; Point to sign of STEP
 630+ 1656 E5                   push    HL              ; Save pointer to sign
 631+ 1657 69                   ld      L,C             ; HL = address of "FOR" index
 632+ 1658 60                   ld      H,B
 633+ 1659 7A                   ld      A,D             ; See if an index was specified
 634+ 165A B3                   or      E               ; DE = 0 if no index specified
 635+ 165B EB                   ex      DE,HL           ; Specified index into HL
 636+ 165C CA 63 16             jp      Z,INDFND        ; Skip if no index given
 637+ 165F EB                   ex      DE,HL           ; Index back into DE
 638+ 1660 CD 9C 19             call    CPDEHL          ; Compare index with one given
 639+ 1663 01 0D 00     INDFND: ld      BC,16-3         ; Offset to next block
 640+ 1666 E1                   pop     HL              ; Restore pointer to sign
 641+ 1667 C8                   ret     Z               ; Return if block found
 642+ 1668 09                   add     HL,BC           ; Point to next block
 643+ 1669 C3 4D 16             jp      LOKFOR          ; Keep on looking
 644+ 166C
 645+ 166C CD 86 16     MOVUP:  call    ENFMEM          ; See if enough memory
 646+ 166F C5           MOVSTR: push    BC              ; Save end of source
 647+ 1670 E3                   ex      (SP),HL         ; Swap source and dest" end
 648+ 1671 C1                   pop     BC              ; Get end of destination
 649+ 1672 CD 9C 19     MOVLP:  call    CPDEHL          ; See if list moved
 650+ 1675 7E                   ld      A,(HL)          ; Get byte
 651+ 1676 02                   ld      (BC),A          ; Move it
 652+ 1677 C8                   ret     Z               ; Exit if all done
 653+ 1678 0B                   dec     BC              ; Next byte to move to
 654+ 1679 2B                   dec     HL              ; Next byte to move
 655+ 167A C3 72 16             jp      MOVLP           ; Loop until all bytes moved
 656+ 167D
 657+ 167D E5           CHKSTK: push    HL              ; Save code string address
 658+ 167E 2A 28 82             ld      HL,(ARREND)     ; Lowest free memory
 659+ 1681 06 00                ld      B,$00           ; BC = Number of levels to test
 660+ 1683 09                   add     HL,BC           ; 2 Bytes for each level
 661+ 1684 09                   add     HL,BC
 662+ 1685 3E                   defb    $3E             ; Skip "push HL"
 663+ 1686 E5           ENFMEM: push    HL              ; Save code string address
 664+ 1687 3E D0                ld      A,$D0           ; LOW -48 ; 48 Bytes minimum RAM
 665+ 1689 95                   sub     L
 666+ 168A 6F                   ld      L,A
 667+ 168B 3E FF                ld      A,$FF           ; HIGH (-48) ; 48 Bytes minimum RAM
 668+ 168D 9C                   sbc     A,H
 669+ 168E DA 95 16             jp      C,OMERR         ; Not enough - ?OM Error
 670+ 1691 67                   ld      H,A
 671+ 1692 39                   add     HL,SP           ; Test if stack is overflowed
 672+ 1693 E1                   pop     HL              ; Restore code string address
 673+ 1694 D8                   ret     C               ; Return if enough memory
 674+ 1695 1E 0C        OMERR:  ld      E,OM            ; ?OM Error
 675+ 1697 C3 D4 16             jp      ERROR
 676+ 169A
 677+ 169A
 678+ 169A              ; if in graphics mode, return to text (called by "NOLIN" and "ERROR")
 679+ 169A F5           EXITGM: push    AF              ; store AF
 680+ 169B 3A CF 81             ld      A,(SCR_MODE)    ; check screen mode
 681+ 169E FE 02                cp      $02             ; G2?
 682+ 16A0 CA A7 16             jp      Z,LDG1          ; yes, back to G1
 683+ 16A3 FE 03                cp      $03             ; G3?
 684+ 16A5 20 11                jr      NZ,LDG1ND       ; no, so return
 685+ 16A7 E5           LDG1:   push    HL              ; store HL
 686+ 16A8 D5                   push    DE              ; store DE
 687+ 16A9 11 01 00             ld      DE,$0001        ; sprites set to defaults, G1 mode
 688+ 16AC F3                   di                      ; disable INTs
 689+ 16AD CD EF 03             call    initVDP         ; initialize VDP with mode pointed by E
 690+ 16B0 FB                   ei                      ; re-enable INTs
 691+ 16B1 3E 01                ld      A,$01           ; activate the...
 692+ 16B3 32 DA 81             ld      (PRNTVIDEO),A   ; ...video buffer...
 693+ 16B6 D1                   pop     DE              ; retrieve DE
 694+ 16B7 E1                   pop     HL              ; retrieve HL
 695+ 16B8 F1           LDG1ND: pop     AF              ; retrieve AF
 696+ 16B9 C9                   ret                     ; return to caller
 697+ 16BA
 698+ 16BA
 699+ 16BA 2A B0 81     DATSNR: ld      HL,(DATLIN)     ; Get line of current DATA item
 700+ 16BD 22 AF 80             ld      (LINEAT),HL     ; Save as current line
 701+ 16C0 1E 02        SNERR:  ld      E,SN            ; ?SN Error
 702+ 16C2 01                   defb    $01             ; Skip "ld E,DZ"
 703+ 16C3 1E 14        DZERR:  ld      E,DZ            ; ?/0 Error
 704+ 16C5 01                   defb    $01             ; Skip "ld E,NF"
 705+ 16C6 1E 00        NFERR:  ld      E,NF            ; ?NF Error
 706+ 16C8 01                   defb    $01             ; Skip "ld E,DD"
 707+ 16C9 1E 12        DDERR:  ld      E,DD            ; ?DD Error
 708+ 16CB 01                   defb    $01             ; Skip "ld E,UF"
 709+ 16CC 1E 22        UFERR:  ld      E,UF            ; ?UF Error
 710+ 16CE 01                   defb    $01             ; Skip "ld E,OV
 711+ 16CF 1E 0A        OVERR:  ld      E,OV            ; ?OV Error
 712+ 16D1 01                   defb    $01             ; Skip "ld E,TM"
 713+ 16D2 1E 18        TMERR:  ld      E,TM            ; ?TM Error
 714+ 16D4
 715+ 16D4 CD 0C 18     ERROR:  call    CLREG           ; Clear registers and stack
 716+ 16D7 CD 9A 16             call    EXITGM          ; exit from graphic modes
 717+ 16DA 32 A5 80             ld      (CTLOFG),A      ; Enable output (A is 0)
 718+ 16DD CD 0A 09             call    CURSOR_ON       ; enable cursor
 719+ 16E0 CD 9E 1E             call    STTLIN          ; Start new line
 720+ 16E3 21 F4 0F             ld      HL,ERRTBL       ; Point to error codes
 721+ 16E6 57                   ld      D,A             ; D = 0 (A is 0)
 722+ 16E7 3E 3F                ld      A,'?'
 723+ 16E9 CD AD 19             call    OUTC            ; Output '?'
 724+ 16EC 19                   add     HL,DE           ; Offset to correct error code
 725+ 16ED 5E                   ld      E,(HL)          ; load pointer to error message
 726+ 16EE 23                   inc     HL              ; by loading LSB,
 727+ 16EF 56                   ld      D,(HL)          ; then MSB
 728+ 16F0 62 6B                ld      HL,DE           ; load pointer to HL
 729+ 16F2 CD 74 25             call    PRS             ; Output error message
 730+ 16F5 21 32 16             ld      HL,ERRMSG       ; "Error" message
 731+ 16F8 CD 74 25     ERRIN:  call    PRS             ; Output message
 732+ 16FB 2A AF 80             ld      HL,(LINEAT)     ; Get line of error
 733+ 16FE 11 FE FF             ld      DE,-2           ; Cold start error if -2
 734+ 1701 CD 9C 19             call    CPDEHL          ; See if cold start error
 735+ 1704 CA E5 11             jp      Z,CSTART        ; Cold start error - Restart
 736+ 1707 7C                   ld      A,H             ; Was it a direct error?
 737+ 1708 A5                   and     L               ; Line = -1 if direct error
 738+ 1709 3C                   inc     A
 739+ 170A CA 15 17             jp      Z,PTLN          ; Yes, jump over
 740+ 170D E5                   push    HL              ; indirect mode - store HL
 741+ 170E 2A AF 80             ld      HL,(LINEAT)     ; copy current line number
 742+ 1711 22 B1 80             ld      (HLPLN),HL      ; save in HELP line register
 743+ 1714 E1                   pop     HL              ; retrieve HL
 744+ 1715 C4 0B 30     PTLN:   call    NZ,LINEIN       ; No - output line of error
 745+ 1718
 746+ 1718 3E                   defb    $3E             ; Skip "pop BC"
 747+ 1719 C1           POPNOK: pop     BC              ; Drop address in input buffer
 748+ 171A
 749+ 171A              ; run into direct mode: print OK and get command
 750+ 171A AF           PRNTOK: xor     A               ; Output "Ok" and get command
 751+ 171B 32 A5 80             ld      (CTLOFG),A      ; Enable output
 752+ 171E CD 9E 1E             call    STTLIN          ; Start new line
 753+ 1721 21 3E 16             ld      HL,OKMSG        ; "Ok" message
 754+ 1724 CD 74 25             call    PRS             ; Output "Ok"
 755+ 1727 CD 0A 09     GETCMD: call    CURSOR_ON       ; enable cursor
 756+ 172A 21 FF FF             ld      HL,-1           ; Flag direct mode
 757+ 172D 22 AF 80             ld      (LINEAT),HL     ; Save as current line
 758+ 1730 CD 22 19             call    GETLIN          ; Get an input line
 759+ 1733 DA 27 17             jp      C,GETCMD        ; Get line again if break
 760+ 1736 CD E3 1B             call    GETCHR          ; Get first character
 761+ 1739 17                   rla                     ; 8th bit is copied into carry and original carry is copied into bit 0)
 762+ 173A DA C0 16             jp      C,SNERR         ; if char >=128 (8th bit set) then raise an error
 763+ 173D 1F                   rra                     ; recover original char and Carry
 764+ 173E 3C                   inc     A               ; Test if end of line
 765+ 173F 3D                   dec     A               ; Without affecting Carry
 766+ 1740 CA 27 17             jp      Z,GETCMD        ; Nothing entered - Get another
 767+ 1743 F5                   push    AF              ; Save Carry status
 768+ 1744 CD 1F 09             call    CURSOR_OFF      ; cursor disabled
 769+ 1747 CD B3 1C             call    ATOH            ; Get line number into DE
 770+ 174A D5                   push    DE              ; Save line number
 771+ 174B CD 39 18             call    CRUNCH          ; Tokenise rest of line
 772+ 174E 47                   ld      B,A             ; Length of tokenised line
 773+ 174F D1                   pop     DE              ; Restore line number
 774+ 1750 F1                   pop     AF              ; Restore Carry
 775+ 1751 D2 C3 1B             jp      NC,EXCUTE       ; No line number - Direct mode
 776+ 1754 D5                   push    DE              ; Save line number
 777+ 1755 C5                   push    BC              ; Save length of tokenised line
 778+ 1756 AF                   xor     A
 779+ 1757 32 B3 81             ld      (LSTBIN),A      ; Clear last byte input
 780+ 175A CD E3 1B             call    GETCHR          ; Get next character
 781+ 175D B7                   or      A               ; Set flags
 782+ 175E F5                   push    AF              ; And save them
 783+ 175F CD C6 17             call    SRCHLN          ; Search for line number in DE
 784+ 1762 DA 6B 17             jp      C,LINFND        ; Jump if line found
 785+ 1765 F1                   pop     AF              ; Get status
 786+ 1766 F5                   push    AF              ; And re-save
 787+ 1767 CA 62 1D             jp      Z,ULERR         ; Nothing after number - Error
 788+ 176A B7                   or      A               ; Clear Carry
 789+ 176B C5           LINFND: push    BC              ; Save address of line in prog
 790+ 176C D2 82 17             jp      NC,INEWLN       ; Line not found - Insert new
 791+ 176F EB                   ex      DE,HL           ; Next line address in DE
 792+ 1770 2A 24 82             ld      HL,(PROGND)     ; End of program
 793+ 1773 1A           SFTPRG: ld      A,(DE)          ; Shift rest of program down
 794+ 1774 02                   ld      (BC),A
 795+ 1775 03                   inc     BC              ; Next destination
 796+ 1776 13                   inc     DE              ; Next source
 797+ 1777 CD 9C 19             call    CPDEHL          ; All done?
 798+ 177A C2 73 17             jp      NZ,SFTPRG       ; More to do
 799+ 177D 60                   ld      H,B             ; HL - New end of program
 800+ 177E 69                   ld      L,C
 801+ 177F 22 24 82             ld      (PROGND),HL     ; Update end of program
 802+ 1782
 803+ 1782 D1           INEWLN: pop     DE              ; Get address of line,
 804+ 1783 F1                   pop     AF              ; Get status
 805+ 1784 CA A9 17             jp      Z,SETPTR        ; No text - Set up pointers
 806+ 1787 2A 24 82             ld      HL,(PROGND)     ; Get end of program
 807+ 178A E3                   ex      (SP),HL         ; Get length of input line
 808+ 178B C1                   pop     BC              ; End of program to BC
 809+ 178C 09                   add     HL,BC           ; Find new end
 810+ 178D E5                   push    HL              ; Save new end
 811+ 178E CD 6C 16             call    MOVUP           ; Make space for line
 812+ 1791 E1                   pop     HL              ; Restore new end
 813+ 1792 22 24 82             ld      (PROGND),HL     ; Update end of program pointer
 814+ 1795 EB                   ex      DE,HL           ; Get line to move up in HL
 815+ 1796 74                   ld      (HL),H          ; Save MSB
 816+ 1797 D1                   pop     DE              ; Get new line number
 817+ 1798 23                   inc     HL              ; Skip pointer
 818+ 1799 23                   inc     HL
 819+ 179A 73                   ld      (HL),E          ; Save LSB of line number
 820+ 179B 23                   inc     HL
 821+ 179C 72                   ld      (HL),D          ; Save MSB of line number
 822+ 179D 23                   inc     HL              ; To first byte in line
 823+ 179E 11 38 81             ld      DE,BUFFER       ; Copy buffer to program
 824+ 17A1 1A           MOVBUF: ld      A,(DE)          ; Get source
 825+ 17A2 77                   ld      (HL),A          ; Save destinations
 826+ 17A3 23                   inc     HL              ; Next source
 827+ 17A4 13                   inc     DE              ; Next destination
 828+ 17A5 B7                   or      A               ; Done?
 829+ 17A6 C2 A1 17             jp      NZ,MOVBUF       ; No - Repeat
 830+ 17A9 CD F2 17     SETPTR: call    RUNFST          ; Set line pointers
 831+ 17AC 23                   inc     HL              ; To LSB of pointer
 832+ 17AD EB                   ex      DE,HL           ; Address to DE
 833+ 17AE 62           PTRLP:  ld      H,D             ; Address to HL
 834+ 17AF 6B                   ld      L,E
 835+ 17B0 7E                   ld      A,(HL)          ; Get LSB of pointer
 836+ 17B1 23                   inc     HL              ; To MSB of pointer
 837+ 17B2 B6                   or      (HL)            ; Compare with MSB pointer
 838+ 17B3 CA 27 17             jp      Z,GETCMD        ; Get command line if end
 839+ 17B6 23                   inc     HL              ; To LSB of line number
 840+ 17B7 23                   inc     HL              ; Skip line number
 841+ 17B8 23                   inc     HL              ; Point to first byte in line
 842+ 17B9 AF                   xor     A               ; Looking for 00 byte
 843+ 17BA BE           FNDEND: cp      (HL)            ; Found end of line?
 844+ 17BB 23                   inc     HL              ; Move to next byte
 845+ 17BC C2 BA 17             jp      NZ,FNDEND       ; No - Keep looking
 846+ 17BF EB                   ex      DE,HL           ; Next line address to HL
 847+ 17C0 73                   ld      (HL),E          ; Save LSB of pointer
 848+ 17C1 23                   inc     HL
 849+ 17C2 72                   ld      (HL),D          ; Save MSB of pointer
 850+ 17C3 C3 AE 17             jp      PTRLP           ; Do next line
 851+ 17C6
 852+ 17C6 2A 35 81     SRCHLN: ld      HL,(BASTXT)     ; Start of program text
 853+ 17C9 44           SRCHLP: ld      B,H             ; BC = Address to look at
 854+ 17CA 4D                   ld      C,L
 855+ 17CB 7E                   ld      A,(HL)          ; Get address of next line
 856+ 17CC 23                   inc     HL
 857+ 17CD B6                   or      (HL)            ; End of program found?
 858+ 17CE 2B                   dec     HL
 859+ 17CF C8                   ret     Z               ; Yes - Line not found
 860+ 17D0 23                   inc     HL
 861+ 17D1 23                   inc     HL
 862+ 17D2 7E                   ld      A,(HL)          ; Get LSB of line number
 863+ 17D3 23                   inc     HL
 864+ 17D4 66                   ld      H,(HL)          ; Get MSB of line number
 865+ 17D5 6F                   ld      L,A
 866+ 17D6 CD 9C 19             call    CPDEHL          ; Compare with line in DE
 867+ 17D9 60                   ld      H,B             ; HL = Start of this line
 868+ 17DA 69                   ld      L,C
 869+ 17DB 7E                   ld      A,(HL)          ; Get LSB of next line address
 870+ 17DC 23                   inc     HL
 871+ 17DD 66                   ld      H,(HL)          ; Get MSB of next line address
 872+ 17DE 6F                   ld      L,A             ; Next line to HL
 873+ 17DF 3F                   ccf
 874+ 17E0 C8                   ret     Z               ; Lines found - Exit
 875+ 17E1 3F                   ccf
 876+ 17E2 D0                   ret     NC              ; Line not found,at line after
 877+ 17E3 C3 C9 17             jp      SRCHLP          ; Keep looking
 878+ 17E6
 879+ 17E6 C0           NEW:    ret     NZ              ; Return if any more on line
 880+ 17E7 2A 35 81     CLRPTR: ld      HL,(BASTXT)     ; Point to start of program
 881+ 17EA AF                   xor     A               ; Set program area to empty
 882+ 17EB 77                   ld      (HL),A          ; Save LSB = 00
 883+ 17EC 23                   inc     HL
 884+ 17ED 77                   ld      (HL),A          ; Save MSB = 00
 885+ 17EE 23                   inc     HL
 886+ 17EF 22 24 82             ld      (PROGND),HL     ; Set program end
 887+ 17F2
 888+ 17F2 2A 35 81     RUNFST: ld      HL,(BASTXT)     ; Clear all variables
 889+ 17F5 2B                   dec     HL
 890+ 17F6
 891+ 17F6 22 B5 81     INTVAR: ld      (BRKLIN),HL     ; Initialise RUN variables
 892+ 17F9 2A 96 81             ld      HL,(LSTRAM)     ; Get end of RAM
 893+ 17FC 22 AA 81             ld      (STRBOT),HL     ; Clear string space
 894+ 17FF AF                   xor     A
 895+ 1800 CD F3 1B             call    RESTOR          ; Reset DATA pointers
 896+ 1803 2A 24 82             ld      HL,(PROGND)     ; Get end of program
 897+ 1806 22 26 82             ld      (VAREND),HL     ; Clear variables
 898+ 1809 22 28 82             ld      (ARREND),HL     ; Clear arrays
 899+ 180C
 900+ 180C C1           CLREG:  pop     BC              ; Save return address
 901+ 180D 2A AD 80             ld      HL,(STRSPC)     ; Get end of working RAM
 902+ 1810 F9                   ld      SP,HL           ; Set stack
 903+ 1811 21 9A 81             ld      HL,TMSTPL       ; Temporary string pool
 904+ 1814 22 98 81             ld      (TMSTPT),HL     ; Reset temporary string ptr
 905+ 1817 AF                   xor     A               ; A = 00
 906+ 1818 6F                   ld      L,A             ; HL = 0000
 907+ 1819 67                   ld      H,A
 908+ 181A 22 BB 81             ld      (CONTAD),HL     ; No CONTinue
 909+ 181D 32 B2 81             ld      (FORFLG),A      ; Clear FOR flag
 910+ 1820 22 2C 82             ld      (FNRGNM),HL     ; Clear FN argument
 911+ 1823 E5                   push    HL              ; HL = 0000
 912+ 1824 C5                   push    BC              ; Put back return
 913+ 1825 2A B5 81     DOAGN:  ld      HL,(BRKLIN)     ; Get address of code to RUN
 914+ 1828 C9                   ret                     ; Return to execution driver
 915+ 1829
 916+ 1829 3E 3F        PROMPT: ld      A,'?'           ; '?'
 917+ 182B CD AD 19             call    OUTC            ; Output character
 918+ 182E 3E 00                ld      A,NLLCR         ; null char
 919+ 1830 CD AD 19             call    OUTC            ; Output character
 920+ 1833 CD 0A 09             call    CURSOR_ON       ; enable cursor
 921+ 1836 C3 AA 80             jp      RINPUT          ; Get input line
 922+ 1839
 923+ 1839 AF           CRUNCH: xor     A               ; Tokenise line @ HL to BUFFER
 924+ 183A 32 95 81             ld      (DATFLG),A      ; Reset literal flag
 925+ 183D 0E 05                ld      C,2+3           ; 2 byte number and 3 nulls
 926+ 183F 11 38 81             ld      DE,BUFFER       ; Start of input buffer
 927+ 1842 7E           CRNCLP: ld      A,(HL)          ; Get byte
 928+ 1843 FE 20                cp      SPC             ; Is it a space?
 929+ 1845 CA C1 18             jp      Z,MOVDIR        ; Yes - Copy direct
 930+ 1848 47                   ld      B,A             ; Save character
 931+ 1849 FE 22                cp      $22             ; '"'             ; Is it a quote?
 932+ 184B CA E1 18             jp      Z,CPYLIT        ; Yes - Copy literal string
 933+ 184E B7                   or      A               ; Is it end of buffer?
 934+ 184F CA E8 18             jp      Z,ENDBUF        ; Yes - End buffer
 935+ 1852 3A 95 81             ld      A,(DATFLG)      ; Get data type
 936+ 1855 B7                   or      A               ; Literal?
 937+ 1856 7E                   ld      A,(HL)          ; Get byte to copy
 938+ 1857 C2 C1 18             jp      NZ,MOVDIR       ; Literal - Copy direct
 939+ 185A FE 3F                cp      '?'             ; Is it '?' short for PRINT
 940+ 185C 3E AF                ld      A,ZPRINT        ; "PRINT" token
 941+ 185E CA C1 18             jp      Z,MOVDIR        ; Yes - replace it
 942+ 1861 7E                   ld      A,(HL)          ; Get byte again
 943+ 1862 FE 30                cp      '0'             ; Is it less than '0'
 944+ 1864 DA 6C 18             jp      C,FNDWRD        ; Yes - Look for reserved words
 945+ 1867 FE 3C                cp      $3C  ;60; ";"+1       ; Is it "0123456789:;" ?
 946+ 1869 DA C1 18             jp      C,MOVDIR        ; Yes - copy it direct
 947+ 186C D5           FNDWRD: push    DE              ; Look for reserved words
 948+ 186D 11 41 13             ld      DE,WORDS-1      ; Point to table
 949+ 1870 C5                   push    BC              ; Save count
 950+ 1871 01 BD 18             ld      BC,RETNAD       ; Where to return to
 951+ 1874 C5                   push    BC              ; Save return address
 952+ 1875 06 7F                ld      B,ZEND-1        ; First token value -1
 953+ 1877 7E                   ld      A,(HL)          ; Get byte
 954+ 1878 FE 61                cp      'a'             ; Less than 'a' ?
 955+ 187A DA 85 18             jp      C,SEARCH        ; Yes - search for words
 956+ 187D FE 7B                cp      'z'+1           ; Greater than 'z' ?
 957+ 187F D2 85 18             jp      NC,SEARCH       ; Yes - search for words
 958+ 1882 E6 5F                and     %01011111       ; Force upper case
 959+ 1884 77                   ld      (HL),A          ; Replace byte
 960+ 1885 4E           SEARCH: ld      C,(HL)          ; Search for a word
 961+ 1886 EB                   ex      DE,HL
 962+ 1887 23           GETNXT: inc     HL              ; Get next reserved word
 963+ 1888 B6                   or      (HL)            ; Start of word?
 964+ 1889 F2 87 18             jp      P,GETNXT        ; No - move on
 965+ 188C 04                   inc     B               ; Increment token value
 966+ 188D 7E                   ld      A,(HL)          ; Get byte from table
 967+ 188E E6 7F                and     %01111111       ; Strip bit 7
 968+ 1890 C8                   ret     Z               ; Return if end of list
 969+ 1891 B9                   cp      C               ; Same character as in buffer?
 970+ 1892 C2 87 18             jp      NZ,GETNXT       ; No - get next word
 971+ 1895 EB                   ex      DE,HL
 972+ 1896 E5                   push    HL              ; Save start of word
 973+ 1897
 974+ 1897 13           NXTBYT: inc     DE              ; Look through rest of word
 975+ 1898 1A                   ld      A,(DE)          ; Get byte from table
 976+ 1899 B7                   or      A               ; End of word ?
 977+ 189A FA B9 18             jp      M,MATCH         ; Yes - Match found
 978+ 189D 4F                   ld      C,A             ; Save it
 979+ 189E 78                   ld      A,B             ; Get token value
 980+ 189F FE 88                cp      ZGOTO           ; Is it "GOTO" token ?
 981+ 18A1 C2 A8 18             jp      NZ,NOSPC        ; No - Don't allow spaces
 982+ 18A4 CD E3 1B             call    GETCHR          ; Get next character
 983+ 18A7 2B                   dec     HL              ; Cancel increment from GETCHR
 984+ 18A8 23           NOSPC:  inc     HL              ; Next byte
 985+ 18A9 7E                   ld      A,(HL)          ; Get byte
 986+ 18AA FE 61                cp      'a'             ; Less than 'a' ?
 987+ 18AC DA B1 18             jp      C,NOCHNG        ; Yes - don't change
 988+ 18AF E6 5F                and     %01011111       ; Make upper case
 989+ 18B1 B9           NOCHNG: cp      C               ; Same as in buffer ?
 990+ 18B2 CA 97 18             jp      Z,NXTBYT        ; Yes - keep testing
 991+ 18B5 E1                   pop     HL              ; Get back start of word
 992+ 18B6 C3 85 18             jp      SEARCH          ; Look at next word
 993+ 18B9
 994+ 18B9 48           MATCH:  ld      C,B             ; Word found - Save token value
 995+ 18BA F1                   pop     AF              ; Throw away return
 996+ 18BB EB                   ex      DE,HL
 997+ 18BC C9                   ret                     ; Return to "RETNAD"
 998+ 18BD EB           RETNAD: ex      DE,HL           ; Get address in string
 999+ 18BE 79                   ld      A,C             ; Get token value
1000+ 18BF C1                   pop     BC              ; Restore buffer length
1001+ 18C0 D1                   pop     DE              ; Get destination address
1002+ 18C1 23           MOVDIR: inc     HL              ; Next source in buffer
1003+ 18C2 12                   ld      (DE),A          ; Put byte in buffer
1004+ 18C3 13                   inc     DE              ; Move up buffer
1005+ 18C4 0C                   inc     C               ; Increment length of buffer
1006+ 18C5 D6 3A                sub     ':'             ; End of statement?
1007+ 18C7 CA CF 18             jp      Z,SETLIT        ; Jump if multi-statement line
1008+ 18CA FE 49                cp      ZDATA-$3A       ; Is it DATA statement ?
1009+ 18CC C2 D2 18             jp      NZ,TSTREM       ; No - see if REM
1010+ 18CF 32 95 81     SETLIT: ld      (DATFLG),A      ; Set literal flag
1011+ 18D2 D6 54        TSTREM: sub     ZREM-$3A        ; Is it REM?
1012+ 18D4 C2 42 18             jp      NZ,CRNCLP       ; No - Leave flag
1013+ 18D7 47                   ld      B,A             ; Copy rest of buffer
1014+ 18D8 7E           NXTCHR: ld      A,(HL)          ; Get byte
1015+ 18D9 B7                   or      A               ; End of line ?
1016+ 18DA CA E8 18             jp      Z,ENDBUF        ; Yes - Terminate buffer
1017+ 18DD B8                   cp      B               ; End of statement ?
1018+ 18DE CA C1 18             jp      Z,MOVDIR        ; Yes - Get next one
1019+ 18E1 23           CPYLIT: inc     HL              ; Move up source string
1020+ 18E2 12                   ld      (DE),A          ; Save in destination
1021+ 18E3 0C                   inc     C               ; Increment length
1022+ 18E4 13                   inc     DE              ; Move up destination
1023+ 18E5 C3 D8 18             jp      NXTCHR          ; Repeat
1024+ 18E8
1025+ 18E8 21 37 81     ENDBUF: ld      HL,BUFFER-1     ; Point to start of buffer
1026+ 18EB 12                   ld      (DE),A          ; Mark end of buffer (A = 00)
1027+ 18EC 13                   inc     DE
1028+ 18ED 12                   ld      (DE),A          ; A = 00
1029+ 18EE 13                   inc     DE
1030+ 18EF 12                   ld      (DE),A          ; A = 00
1031+ 18F0 C9                   ret
1032+ 18F1
1033+ 18F1 3A A4 80     DODEL:  ld      A,(NULFLG)      ; Get null flag status
1034+ 18F4 B7                   or      A               ; Is it zero?
1035+ 18F5 3E 00                ld      A,$00           ; Zero A - Leave flags
1036+ 18F7 32 A4 80             ld      (NULFLG),A      ; Zero null flag
1037+ 18FA C2 05 19             jp      NZ,ECHDEL       ; Set - Echo it
1038+ 18FD 05                   dec     B               ; Decrement length
1039+ 18FE CA 22 19             jp      Z,GETLIN        ; Get line again if empty
1040+ 1901 CD AD 19             call    OUTC            ; Output null character
1041+ 1904 3E                   defb    $3E             ; Skip "dec B"
1042+ 1905 05           ECHDEL: dec     B               ; Count bytes in buffer
1043+ 1906 2B                   dec     HL              ; Back space buffer
1044+ 1907 CA 19 19             jp      Z,OTKLN         ; No buffer - Try again
1045+ 190A 7E                   ld      A,(HL)          ; Get deleted byte
1046+ 190B CD AD 19             call    OUTC            ; Echo it
1047+ 190E C3 2B 19             jp      MORINP          ; Get more input
1048+ 1911
1049+ 1911 05           DELCHR: dec     B               ; Count bytes in buffer
1050+ 1912 2B                   dec     HL              ; Back space buffer
1051+ 1913 CD AD 19             call    OUTC            ; Output character in A
1052+ 1916 C2 2B 19             jp      NZ,MORINP       ; Not end - Get more
1053+ 1919 CD AD 19     OTKLN:  call    OUTC            ; Output character in A
1054+ 191C CD B0 1E     KILIN:  call    PRNTCRLF        ; Output CRLF
1055+ 191F C3 22 19             jp      TTYLIN          ; Get line again
1056+ 1922
1057+ 1922              GETLIN:
1058+ 1922 21 38 81     TTYLIN: ld      HL,BUFFER       ; Get a line by character
1059+ 1925 06 01                ld      B,$01           ; Set buffer as empty
1060+ 1927 AF                   xor     A
1061+ 1928 32 A4 80             ld      (NULFLG),A      ; Clear null flag
1062+ 192B CD EE 19     MORINP: call    CLOTST          ; Get character and test ^O
1063+ 192E 4F                   ld      C,A             ; Save character in C
1064+ 192F FE 7F                cp      DEL             ; Delete character?
1065+ 1931 CA F1 18             jp      Z,DODEL         ; Yes - Process it
1066+ 1934 3A A4 80             ld      A,(NULFLG)      ; Get null flag
1067+ 1937 B7                   or      A               ; Test null flag status
1068+ 1938 CA 44 19             jp      Z,PROCES        ; Reset - Process character
1069+ 193B 3E 00                ld      A,$00           ; Set a null
1070+ 193D CD AD 19             call    OUTC            ; Output null
1071+ 1940 AF                   xor     A               ; Clear A
1072+ 1941 32 A4 80             ld      (NULFLG),A      ; Reset null flag
1073+ 1944 79           PROCES: ld      A,C             ; Get character
1074+ 1945 FE 07                cp      CTRLG           ; Bell?
1075+ 1947 CA 84 19             jp      Z,PUTCTL        ; Yes - Save it
1076+ 194A FE 03                cp      CTRLC           ; Is it control "C"?
1077+ 194C CC 79 19             call    Z,GMNCR         ; Yes - exit from graphic mode & Output CRLF
1078+ 194F 37                   scf                     ; Flag break
1079+ 1950 C8                   ret     Z               ; Return if control "C"
1080+ 1951 FE 0D                cp      CR              ; Is it enter?
1081+ 1953 CA A6 1E             jp      Z,ENDINP        ; Yes - Terminate input
1082+ 1956 FE 15                cp      CTRLU           ; Is it control "U"?
1083+ 1958 CA 1C 19             jp      Z,KILIN         ; Yes - Get another line
1084+ 195B FE 08                cp      BKSP            ; Is it backspace?
1085+ 195D CA 11 19             jp      Z,DELCHR        ; Yes - Delete character
1086+ 1960 FE 12                cp      CTRLR           ; Is it control "R"?
1087+ 1962 C2 7F 19             jp      NZ,PUTBUF       ; No - Put in buffer
1088+ 1965 C5                   push    BC              ; Save buffer length
1089+ 1966 D5                   push    DE              ; Save DE
1090+ 1967 E5                   push    HL              ; Save buffer address
1091+ 1968 36 00                ld      (HL),$00        ; Mark end of buffer
1092+ 196A CD A9 3F             call    OUTNCR          ; Output and do CRLF
1093+ 196D 21 38 81             ld      HL,BUFFER       ; Point to buffer start
1094+ 1970 CD 74 25             call    PRS             ; Output buffer
1095+ 1973 E1                   pop     HL              ; Restore buffer address
1096+ 1974 D1                   pop     DE              ; Restore DE
1097+ 1975 C1                   pop     BC              ; Restore buffer length
1098+ 1976 C3 2B 19             jp      MORINP          ; Get another character
1099+ 1979 CD 9A 16     GMNCR:  call    EXITGM          ; exit from graphic mode
1100+ 197C C3 B0 1E             jp      PRNTCRLF        ; output CRLF
1101+ 197F
1102+ 197F FE 20        PUTBUF: cp      SPC             ; Is it a control code?
1103+ 1981 DA 2B 19             jp      C,MORINP        ; Yes - Ignore
1104+ 1984 78           PUTCTL: ld      A,B             ; Get number of bytes in buffer
1105+ 1985 FE 59                cp      $58+$01         ; Test for line overflow
1106+ 1987 3E 08                ld      A,BKSP          ; Set a bell
1107+ 1989 D2 96 19             jp      NC,OUTNBS       ; Ring bell if buffer full
1108+ 198C 79                   ld      A,C             ; Get character
1109+ 198D 71                   ld      (HL),C          ; Save in buffer
1110+ 198E 32 B3 81             ld      (LSTBIN),A      ; Save last input byte
1111+ 1991 23                   inc     HL              ; Move up buffer
1112+ 1992 04                   inc     B               ; Increment length
1113+ 1993 C3 2B 19     OUTIT:  jp      MORINP          ; Get another character
1114+ 1996
1115+ 1996 CD AD 19     OUTNBS: call    OUTC            ; Output bell and back over it
1116+ 1999 C3 93 19             jp      OUTIT           ; get more chars
1117+ 199C
1118+ 199C 7C           CPDEHL: ld      A,H             ; Get H
1119+ 199D 92                   sub     D               ; Compare with D
1120+ 199E C0                   ret     NZ              ; Different - Exit
1121+ 199F 7D                   ld      A,L             ; Get L
1122+ 19A0 93                   sub     E               ; Compare with E
1123+ 19A1 C9                   ret                     ; Return status
1124+ 19A2
1125+ 19A2 7E           CHKSYN: ld      A,(HL)          ; Check syntax of character
1126+ 19A3 E3                   ex      (SP),HL         ; Address of test byte
1127+ 19A4 BE                   cp      (HL)            ; Same as in code string?
1128+ 19A5 23                   inc     HL              ; Return address
1129+ 19A6 E3                   ex      (SP),HL         ; Put it back
1130+ 19A7 CA E3 1B             jp      Z,GETCHR        ; Yes - Get next character
1131+ 19AA C3 C0 16             jp      SNERR           ; Different - ?SN Error
1132+ 19AD
1133+ 19AD F5           OUTC:   push    AF              ; Save character
1134+ 19AE 3A A5 80             ld      A,(CTLOFG)      ; Get control "O" flag
1135+ 19B1 B7                   or      A               ; Is it set?
1136+ 19B2 C2 A9 25             jp      NZ,POPAF        ; Yes - don't output
1137+ 19B5 F1                   pop     AF              ; Restore character
1138+ 19B6 C5                   push    BC              ; Save buffer length
1139+ 19B7 F5                   push    AF              ; Save character
1140+ 19B8 FE 20                cp      SPC             ; Is it a control code?
1141+ 19BA DA D1 19             jp      C,DINPOS        ; Yes - Don't inc POS(X)
1142+ 19BD 3A A2 80             ld      A,(LWIDTH)      ; Get line width
1143+ 19C0 47                   ld      B,A             ; To B
1144+ 19C1 3A 92 81             ld      A,(CURPOS)      ; Get cursor position
1145+ 19C4 04                   inc     B               ; Width 255?
1146+ 19C5 CA CD 19             jp      Z,INCLEN        ; Yes - No width limit
1147+ 19C8 05                   dec     B               ; Restore width
1148+ 19C9 B8                   cp      B               ; At end of line?
1149+ 19CA CC B0 1E             call    Z,PRNTCRLF      ; Yes - output CRLF
1150+ 19CD 3C           INCLEN: inc     A               ; Move on one character
1151+ 19CE 32 92 81             ld      (CURPOS),A      ; Save new position
1152+ 19D1 AF           DINPOS: xor     A
1153+ 19D2 32 18 82             ld      (KBDNPT),A      ; set flag for no char from keyboard
1154+ 19D5 F1                   pop     AF              ; Restore character
1155+ 19D6 C1                   pop     BC              ; Restore buffer length
1156+ 19D7 F5                   push    AF
1157+ 19D8 CD E0 19             call    SND2VID         ; send char to video
1158+ 19DB F1                   pop     AF
1159+ 19DC CD 88 3F             call    MONOUT          ; send char to serial if enabled
1160+ 19DF C9                   ret
1161+ 19E0
1162+ 19E0              ; print char to video if cursor is on
1163+ 19E0 32 DB 81     SND2VID:ld      (CHR4VID),A     ; store A
1164+ 19E3 3A DA 81             ld      A,(PRNTVIDEO)   ; check print-on-video
1165+ 19E6 B7                   or      A               ; is it off?
1166+ 19E7 C8                   ret     Z               ; yes, so return
1167+ 19E8 F3                   di                      ; disable INTs
1168+ 19E9 CD 6E 07             call    CHAR2VID        ; cursor is on, so print char on screen
1169+ 19EC FB                   ei                      ; re-enable INTs
1170+ 19ED C9                   ret                     ; return to caller
1171+ 19EE
1172+ 19EE CD 2F 33     CLOTST: call    GETINP          ; Get input character
1173+ 19F1 FE 0F                cp      CTRLO           ; Is it control "O"?
1174+ 19F3 C0                   ret     NZ              ; No don't flip flag
1175+ 19F4 3A A5 80             ld      A,(CTLOFG)      ; Get flag
1176+ 19F7 2F                   cpl                     ; Flip it
1177+ 19F8 32 A5 80             ld      (CTLOFG),A      ; Put it back
1178+ 19FB A7                   and     A               ; is output enabled?
1179+ 19FC CC 0A 09             call    Z,CURSOR_ON     ; yes, so cursor on
1180+ 19FF AF                   xor     A               ; Null character
1181+ 1A00 C9                   ret
1182+ 1A01
1183+ 1A01              ; LIST: list the program stored into memory
1184+ 1A01 C1           LIST:   pop     BC              ; rubbish - not needed (legacy from original call of LIST)
1185+ 1A02 2B                   dec     HL              ; dec 'cos GETCHR INCs
1186+ 1A03 CD E3 1B             call    GETCHR          ; Get next character
1187+ 1A06 CA 5C 1A             jp      Z,LSTALL        ; list all if nothing follows
1188+ 1A09 FE BE                cp      ZMINUS          ; is it '-'?
1189+ 1A0B 20 20                jr      NZ,LST01        ; no, look for a line number
1190+ 1A0D 11 00 00             ld      DE,$0000        ; yes, set search from 0
1191+ 1A10 CD FD 1A             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1192+ 1A13 ED 43 DE 81          ld      (TMPBFR1),BC    ; store address of starting line
1193+ 1A17 CD A2 19             call    CHKSYN          ; skip '-'
1194+ 1A1A BE                   defb    ZMINUS
1195+ 1A1B CD B3 1C             call    ATOH            ; now, look for another number (ASCII number to DE)
1196+ 1A1E CD 03 1B             call    SRCLN           ; find a line, getting the previous if it doesn't exist
1197+ 1A21 ED 43 E0 81          ld      (TMPBFR2),BC    ; store address of ending line
1198+ 1A25 ED 4B DE 81          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1199+ 1A29 C5                   push    BC              ; store address of line for later use
1200+ 1A2A C3 94 1A             jp      LISTLP          ; go listing
1201+ 1A2D CD B3 1C     LST01:  call    ATOH            ; get a line number (ASCII number to DE)
1202+ 1A30 ED 53 E4 81  LST01H: ld      (TMPBFR4),DE    ; store ending line address for later use - N.B.: this is a hook for HELP command
1203+ 1A34 CD FD 1A             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1204+ 1A37 ED 43 DE 81          ld      (TMPBFR1),BC    ; store address of starting line
1205+ 1A3B ED 43 E0 81          ld      (TMPBFR2),BC    ; same address for ending line (we'll change it later if needed)
1206+ 1A3F 2B                   dec     HL              ; dec 'cos GETCHR INCs
1207+ 1A40 CD E3 1B             call    GETCHR          ; Get next character
1208+ 1A43 CA 4F 1A             jp      Z,LSTNOT        ; nothing follows, so ending & starting lines are the same
1209+ 1A46 FE BE                cp      ZMINUS          ; is it '-'?
1210+ 1A48 CA 74 1A             jp      Z,LST03         ; yes, read ending line
1211+ 1A4B C5           LST06:  push    BC              ; store address for later use
1212+ 1A4C C3 94 1A             jp      LISTLP          ; jump to list
1213+ 1A4F ED 5B E4 81  LSTNOT: ld      DE,(TMPBFR4)
1214+ 1A53 CD FD 1A             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1215+ 1A56 DA 4B 1A             jp      C,LST06
1216+ 1A59 C3 1A 17             jp      PRNTOK
1217+ 1A5C 11 F9 FF     LSTALL: ld      DE,65529        ; set ending line to max. allowed line number
1218+ 1A5F CD FD 1A             call    SRCHLIN         ; get address of last line
1219+ 1A62 ED 43 E0 81          ld      (TMPBFR2),BC    ; store it
1220+ 1A66 11 00 00             ld      DE,$0000        ; set start to first line in memory
1221+ 1A69 CD FD 1A             call    SRCHLIN         ; get address of first line
1222+ 1A6C ED 43 DE 81          ld      (TMPBFR1),BC    ; store it
1223+ 1A70 C5                   push    BC              ; store address of starting line for later use
1224+ 1A71 C3 94 1A             jp      LISTLP          ; start printing
1225+ 1A74 CD A2 19     LST03:  call    CHKSYN          ; skip '-'
1226+ 1A77 BE                   defb    ZMINUS
1227+ 1A78 CD B3 1C             call    ATOH            ; look for another number (return into DE)
1228+ 1A7B 7A                   ld      A,D
1229+ 1A7C B3                   or      E               ; is line=0?
1230+ 1A7D 20 09                jr      NZ,LST05        ; no, jump over
1231+ 1A7F 11 F9 FF             ld      DE,65529        ; yes set last valid line number
1232+ 1A82 CD FD 1A             call    SRCHLIN         ; get address of last line
1233+ 1A85 C3 8B 1A             jp      LST02
1234+ 1A88 CD 03 1B     LST05:  call    SRCLN           ; find a line, getting the previous if it doesn't exist
1235+ 1A8B ED 43 E0 81  LST02:  ld      (TMPBFR2),BC    ; store address of ending line
1236+ 1A8F ED 4B DE 81          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1237+ 1A93 C5                   push    BC              ; store it for later use
1238+ 1A94 E1           LISTLP: pop     HL              ; Restore address of line
1239+ 1A95 4E                   ld      C,(HL)          ; Get LSB of next line
1240+ 1A96 23                   inc     HL
1241+ 1A97 46                   ld      B,(HL)          ; Get MSB of next line
1242+ 1A98 23                   inc     HL
1243+ 1A99 78                   ld      A,B             ; BC = 0 (End of program)?
1244+ 1A9A B1                   or      C
1245+ 1A9B CA 1A 17             jp      Z,PRNTOK        ; Yes - Go to command mode
1246+ 1A9E CD 0E 1C             call    TSTBRK          ; Test for break key
1247+ 1AA1 CD 11 1B             call    TSTSPC          ; test for space
1248+ 1AA4 C5                   push    BC              ; Save address of next line
1249+ 1AA5 3A D3 81             ld      A,(SCR_CURS_X)  ; load current X pos of cursor
1250+ 1AA8 A7                   and     A               ; is it at the beginning of a new line?
1251+ 1AA9 20 0B                jr      NZ,LST08        ; No, jump over
1252+ 1AAB 3E 0D                ld      A,CR            ; yes, so just send a CR
1253+ 1AAD CD 88 3F             call    MONOUT          ; to serial if it's open
1254+ 1AB0 AF                   xor     A               ; then, set cursor
1255+ 1AB1 32 92 81             ld      (CURPOS),A      ; to position 0
1256+ 1AB4 18 03                jr      LST07           ; and continue
1257+ 1AB6 CD B0 1E     LST08:  call    PRNTCRLF        ; output CRLF
1258+ 1AB9 5E           LST07:  ld      E,(HL)          ; Get LSB of line number
1259+ 1ABA 23                   inc     HL
1260+ 1ABB 56                   ld      D,(HL)          ; Get MSB of line number
1261+ 1ABC 23                   inc     HL
1262+ 1ABD E5                   push    HL              ; Save address of line start
1263+ 1ABE EB                   ex      DE,HL           ; Line number to HL
1264+ 1ABF CD 13 30             call    PRNTHL          ; Output line number in decimal
1265+ 1AC2 3E 20                ld      A,SPC           ; Space after line number
1266+ 1AC4 E1                   pop     HL              ; Restore start of line address
1267+ 1AC5 CD AD 19     LSTLP2: call    OUTC            ; Output character in A
1268+ 1AC8 7E           LSTLP3: ld      A,(HL)          ; Get next byte in line
1269+ 1AC9 B7                   or      A               ; End of line?
1270+ 1ACA 23                   inc     HL              ; To next byte in line
1271+ 1ACB CA EF 1A             jp      Z,NXTLN         ; Yes - check next line
1272+ 1ACE F2 C5 1A             jp      P,LSTLP2        ; No token - output it
1273+ 1AD1 D6 7F                sub     ZEND-1          ; Find and output word
1274+ 1AD3 4F                   ld      C,A             ; Token offset+1 to C
1275+ 1AD4 11 42 13             ld      DE,WORDS        ; Reserved word list
1276+ 1AD7 1A           FNDTOK: ld      A,(DE)          ; Get character in list
1277+ 1AD8 13                   inc     DE              ; Move on to next
1278+ 1AD9 B7                   or      A               ; Is it start of word?
1279+ 1ADA F2 D7 1A             jp      P,FNDTOK        ; No - Keep looking for word
1280+ 1ADD 0D                   dec     C               ; Count words
1281+ 1ADE C2 D7 1A             jp      NZ,FNDTOK       ; Not there - keep looking
1282+ 1AE1 E6 7F        OUTWRD: and     %01111111       ; Strip bit 7
1283+ 1AE3 CD AD 19             call    OUTC            ; Output character
1284+ 1AE6 1A                   ld      A,(DE)          ; Get next character
1285+ 1AE7 13                   inc     DE              ; Move on to next
1286+ 1AE8 B7                   or      A               ; Is it end of word?
1287+ 1AE9 F2 E1 1A             jp      P,OUTWRD        ; No - output the rest
1288+ 1AEC C3 C8 1A             jp      LSTLP3          ; Next byte in line
1289+ 1AEF D1           NXTLN:  pop     DE              ; recover address of current line
1290+ 1AF0 2A E0 81             ld      HL,(TMPBFR2)    ; address of last line to print
1291+ 1AF3 CD AF 3F             call    CMP16           ; check if current line is over last printable line
1292+ 1AF6 DA 1A 17             jp      C,PRNTOK        ; finish - leave & print OK
1293+ 1AF9 D5                   push    DE              ; store address of current line
1294+ 1AFA C3 94 1A             jp      LISTLP          ; continue listing
1295+ 1AFD              ; look for the address of a program line
1296+ 1AFD E5           SRCHLIN:push    HL              ; store HL (this is needed because HL store the pointer to the input buffer)
1297+ 1AFE CD C6 17             call    SRCHLN          ; search for line number in DE
1298+ 1B01 E1                   pop     HL              ; retrieve HL
1299+ 1B02 C9                   ret                     ; return to caller
1300+ 1B03              ; look for the address of a program line - if the line isn't found,
1301+ 1B03              ; it look backward for the previous line
1302+ 1B03 E5           SRCLN:  push    HL              ; store HL
1303+ 1B04 CD C6 17     SRCLN1: call    SRCHLN          ; search for line in DE
1304+ 1B07 DA 0F 1B             jp      C,LVSRLN        ; found it, leave loop
1305+ 1B0A 1B                   dec     DE              ; not found, decrement number to look backward for an existing line
1306+ 1B0B 7B                   ld      A,E
1307+ 1B0C B2                   or      D               ; is line number zero?
1308+ 1B0D 20 F5                jr      NZ,SRCLN1       ; no, continue
1309+ 1B0F E1           LVSRLN: pop     HL              ; retrieve HL
1310+ 1B10 C9                   ret                     ; return to caller
1311+ 1B11
1312+ 1B11              ; during LISTing, check if PAUSE is pressed, then pause listing and
1313+ 1B11              ; wait for another pressing of PAUSE to continue or CTRL-C/BREAK to exit
1314+ 1B11 3A 1A 82     TSTSPC: ld      A,(TMPKEYBFR)   ; Get input character
1315+ 1B14 FE 20                cp      SPC             ; Is it SPACE?
1316+ 1B16 C0                   ret     NZ              ; No, return
1317+ 1B17 CD 2F 33     WTSPC:  call    GETINP          ; Yes, stop listing and wait for another space or BREAK
1318+ 1B1A FE 20                cp      SPC             ; is it SPACE?
1319+ 1B1C 20 05                jr      NZ,CNTWTSP      ; no, continue
1320+ 1B1E AF                   xor     A
1321+ 1B1F 32 1A 82             ld      (TMPKEYBFR),A   ; reset key
1322+ 1B22 C9                   ret                     ; return to caller
1323+ 1B23 FE 03        CNTWTSP:cp      CTRLC           ; is it CTRL-C/BREAK?
1324+ 1B25 20 F0                jr      NZ,WTSPC        ; no, loop
1325+ 1B27 C3 8F 12             jp      BRKRET          ; exit and output "Ok"
1326+ 1B2A
1327+ 1B2A
1328+ 1B2A 3E 64        FOR:    ld      A,$64           ; Flag "FOR" assignment
1329+ 1B2C 32 B2 81             ld      (FORFLG),A      ; Save "FOR" flag
1330+ 1B2F CD A3 1D             call    LET             ; Set up initial index
1331+ 1B32 C1                   pop     BC              ; Drop RETurn address
1332+ 1B33 E5                   push    HL              ; Save code string address
1333+ 1B34 CD 8C 1D             call    DATA            ; Get next statement address
1334+ 1B37 22 AE 81             ld      (LOOPST),HL     ; Save it for start of loop
1335+ 1B3A 21 02 00             ld      HL,$0002        ; Offset for "FOR" block
1336+ 1B3D 39                   add     HL,SP           ; Point to it
1337+ 1B3E CD 4D 16     FORSLP: call    LOKFOR          ; Look for existing "FOR" block
1338+ 1B41 D1                   pop     DE              ; Get code string address
1339+ 1B42 C2 5A 1B             jp      NZ,FORFND       ; No nesting found
1340+ 1B45 09                   add     HL,BC           ; Move into "FOR" block
1341+ 1B46 D5                   push    DE              ; Save code string address
1342+ 1B47 2B                   dec     HL
1343+ 1B48 56                   ld      D,(HL)          ; Get MSB of loop statement
1344+ 1B49 2B                   dec     HL
1345+ 1B4A 5E                   ld      E,(HL)          ; Get LSB of loop statement
1346+ 1B4B 23                   inc     HL
1347+ 1B4C 23                   inc     HL
1348+ 1B4D E5                   push    HL              ; Save block address
1349+ 1B4E 2A AE 81             ld      HL,(LOOPST)     ; Get address of loop statement
1350+ 1B51 CD 9C 19             call    CPDEHL          ; Compare the FOR loops
1351+ 1B54 E1                   pop     HL              ; Restore block address
1352+ 1B55 C2 3E 1B             jp      NZ,FORSLP       ; Different FORs - Find another
1353+ 1B58 D1                   pop     DE              ; Restore code string address
1354+ 1B59 F9                   ld      SP,HL           ; Remove all nested loops
1355+ 1B5A
1356+ 1B5A EB           FORFND: ex      DE,HL           ; Code string address to HL
1357+ 1B5B 0E 08                ld      C,$08
1358+ 1B5D CD 7D 16             call    CHKSTK          ; Check for 8 levels of stack
1359+ 1B60 E5                   push    HL              ; Save code string address
1360+ 1B61 2A AE 81             ld      HL,(LOOPST)     ; Get first statement of loop
1361+ 1B64 E3                   ex      (SP),HL         ; Save and restore code string
1362+ 1B65 E5                   push    HL              ; Re-save code string address
1363+ 1B66 2A AF 80             ld      HL,(LINEAT)     ; Get current line number
1364+ 1B69 E3                   ex      (SP),HL         ; Save and restore code string
1365+ 1B6A CD 6F 20             call    TSTNUM          ; Make sure it's a number
1366+ 1B6D CD A2 19             call    CHKSYN          ; Make sure "TO" is next
1367+ 1B70 B7                   defb    ZTO             ; "TO" token
1368+ 1B71 CD 6C 20             call    GETNUM          ; Get "TO" expression value
1369+ 1B74 E5                   push    HL              ; Save code string address
1370+ 1B75 CD C5 2E             call    BCDEFP          ; Move "TO" value to BCDE
1371+ 1B78 E1                   pop     HL              ; Restore code string address
1372+ 1B79 C5                   push    BC              ; Save "TO" value in block
1373+ 1B7A D5                   push    DE
1374+ 1B7B 01 00 81             ld      BC,$8100        ; BCDE - 1 (default STEP)
1375+ 1B7E 51                   ld      D,C             ; C=0
1376+ 1B7F 5A                   ld      E,D             ; D=0
1377+ 1B80 7E                   ld      A,(HL)          ; Get next byte in code string
1378+ 1B81 FE BC                cp      ZSTEP           ; See if "STEP" is stated
1379+ 1B83 3E 01                ld      A,$01           ; Sign of step = 1
1380+ 1B85 C2 96 1B             jp      NZ,SAVSTP       ; No STEP given - Default to 1
1381+ 1B88 CD E3 1B             call    GETCHR          ; Jump over "STEP" token
1382+ 1B8B CD 6C 20             call    GETNUM          ; Get step value
1383+ 1B8E E5                   push    HL              ; Save code string address
1384+ 1B8F CD C5 2E             call    BCDEFP          ; Move STEP to BCDE
1385+ 1B92 CD 79 2E             call    TSTSGN          ; Test sign of FPREG
1386+ 1B95 E1                   pop     HL              ; Restore code string address
1387+ 1B96 C5           SAVSTP: push    BC              ; Save the STEP value in block
1388+ 1B97 D5                   push    DE
1389+ 1B98 F5                   push    AF              ; Save sign of STEP
1390+ 1B99 33                   inc     SP              ; Don't save flags
1391+ 1B9A E5                   push    HL              ; Save code string address
1392+ 1B9B 2A B5 81             ld      HL,(BRKLIN)     ; Get address of index variable
1393+ 1B9E E3                   ex      (SP),HL         ; Save and restore code string
1394+ 1B9F 06 81        PUTFID: ld      B,ZFOR          ; "FOR" block marker
1395+ 1BA1 C5                   push    BC              ; Save it
1396+ 1BA2 33                   inc     SP              ; Don't save C
1397+ 1BA3
1398+ 1BA3 CD 0E 1C     RUNCNT: call    TSTBRK          ; Execution driver - Test break
1399+ 1BA6 22 B5 81             ld      (BRKLIN),HL     ; Save code address for break
1400+ 1BA9 7E                   ld      A,(HL)          ; Get next byte in code string
1401+ 1BAA FE 3A                cp      ':'             ; Multi statement line?
1402+ 1BAC CA C3 1B             jp      Z,EXCUTE        ; Yes - Execute it
1403+ 1BAF B7                   or      A               ; End of line?
1404+ 1BB0 C2 C0 16             jp      NZ,SNERR        ; No - Syntax error
1405+ 1BB3 23                   inc     HL              ; Point to address of next line
1406+ 1BB4 7E                   ld      A,(HL)          ; Get LSB of line pointer
1407+ 1BB5 23                   inc     HL
1408+ 1BB6 B6                   or      (HL)            ; Is it zero (End of prog)?
1409+ 1BB7 CA 35 1C             jp      Z,ENDPRG        ; Yes - Terminate execution
1410+ 1BBA 23                   inc     HL              ; Point to line number
1411+ 1BBB 5E                   ld      E,(HL)          ; Get LSB of line number
1412+ 1BBC 23                   inc     HL
1413+ 1BBD 56                   ld      D,(HL)          ; Get MSB of line number
1414+ 1BBE EB                   ex      DE,HL           ; Line number to HL
1415+ 1BBF 22 AF 80             ld      (LINEAT),HL     ; Save as current line number
1416+ 1BC2 EB                   ex      DE,HL           ; Line number back to DE
1417+ 1BC3 CD E3 1B     EXCUTE: call    GETCHR          ; Get key word
1418+ 1BC6 11 A3 1B             ld      DE,RUNCNT       ; Where to RETurn to
1419+ 1BC9 D5                   push    DE              ; Save for RETurn
1420+ 1BCA C8           IFJMP:  ret     Z               ; Go to RUNCNT if end of STMT
1421+ 1BCB
1422+ 1BCB D6 80        ONJMP:  sub     ZEND            ; Is it a token?
1423+ 1BCD DA A3 1D             jp      C,LET           ; No - try to assign it
1424+ 1BD0 FE 36                cp      ZNEW+1-ZEND     ; END to NEW ?
1425+ 1BD2 D2 C0 16             jp      NC,SNERR        ; Not a key word - ?SN Error
1426+ 1BD5 07                   rlca                    ; Double it
1427+ 1BD6 4F                   ld      C,A             ; BC = Offset into table
1428+ 1BD7 06 00                ld      B,0
1429+ 1BD9 EB                   ex      DE,HL           ; Save code string address
1430+ 1BDA 21 CF 14             ld      HL,WORDTB       ; Keyword address table
1431+ 1BDD 09                   add     HL,BC           ; Point to routine address
1432+ 1BDE 4E                   ld      C,(HL)          ; Get LSB of routine address
1433+ 1BDF 23                   inc     HL
1434+ 1BE0 46                   ld      B,(HL)          ; Get MSB of routine address
1435+ 1BE1 C5                   push    BC              ; Save routine address
1436+ 1BE2 EB                   ex      DE,HL           ; Restore code string address
1437+ 1BE3
1438+ 1BE3              ; get a char from input buffer: exit with NC if character found is
1439+ 1BE3              ; not a number; exit with Z if nothing found; char is into A
1440+ 1BE3 23           GETCHR: inc     HL              ; Point to next character
1441+ 1BE4 7E                   ld      A,(HL)          ; Get next code string byte
1442+ 1BE5 FE 3A                cp      ':'             ; Z if ':'
1443+ 1BE7 D0                   ret     NC              ; NC if > "9"
1444+ 1BE8 FE 20                cp      SPC
1445+ 1BEA CA E3 1B             jp      Z,GETCHR        ; Skip over spaces
1446+ 1BED FE 30                cp      '0'
1447+ 1BEF 3F                   ccf                     ; NC if < '0'
1448+ 1BF0 3C                   inc     A               ; Test for zero - Leave carry
1449+ 1BF1 3D                   dec     A               ; Z if Null
1450+ 1BF2 C9                   ret
1451+ 1BF3
1452+ 1BF3 EB           RESTOR: ex      DE,HL           ; Save code string address
1453+ 1BF4 2A 35 81             ld      HL,(BASTXT)     ; Point to start of program
1454+ 1BF7 CA 08 1C             jp      Z,RESTNL        ; Just RESTORE - reset pointer
1455+ 1BFA EB                   ex      DE,HL           ; Restore code string address
1456+ 1BFB CD B3 1C             call    ATOH            ; Get line number to DE
1457+ 1BFE E5                   push    HL              ; Save code string address
1458+ 1BFF CD C6 17             call    SRCHLN          ; Search for line number in DE
1459+ 1C02 60                   ld      H,B             ; HL = Address of line
1460+ 1C03 69                   ld      L,C
1461+ 1C04 D1                   pop     DE              ; Restore code string address
1462+ 1C05 D2 62 1D             jp      NC,ULERR        ; ?UL Error if not found
1463+ 1C08 2B           RESTNL: dec     HL              ; Byte before DATA statement
1464+ 1C09 22 2A 82     UPDATA: ld      (NXTDAT),HL     ; Update DATA pointer
1465+ 1C0C EB                   ex      DE,HL           ; Restore code string address
1466+ 1C0D C9                   ret
1467+ 1C0E
1468+ 1C0E
1469+ 1C0E DF           TSTBRK: rst     $18             ; Check input status
1470+ 1C0F C8                   ret     Z               ; No key, go back
1471+ 1C10 D7                   rst     $10             ; Get the key into A
1472+ 1C11 FE 1B                cp      ESC             ; Escape key?
1473+ 1C13 28 11                jr      Z,BRK           ; Yes, break
1474+ 1C15 FE 03                cp      CTRLC           ; <Ctrl-C>
1475+ 1C17 28 0D                jr      Z,BRK           ; Yes, break
1476+ 1C19 FE 13                cp      CTRLS           ; Stop scrolling?
1477+ 1C1B C0                   ret     NZ              ; Other key, ignore
1478+ 1C1C
1479+ 1C1C
1480+ 1C1C D7           STALL:  rst     $10             ; Wait for key
1481+ 1C1D FE 11                cp      CTRLQ           ; Resume scrolling?
1482+ 1C1F C8                   ret     Z               ; Release the chokehold
1483+ 1C20 FE 03                cp      CTRLC           ; Second break?
1484+ 1C22 28 07                jr      Z,STOP          ; Break during hold exits prog
1485+ 1C24 18 F6                jr      STALL           ; Loop until <Ctrl-Q> or <brk>
1486+ 1C26
1487+ 1C26 3E FF        BRK:    ld      A,$FF           ; Set BRKFLG
1488+ 1C28 32 A9 80             ld      (BRKFLG),A      ; Store it
1489+ 1C2B
1490+ 1C2B C0           STOP:   ret     NZ              ; Exit if anything else
1491+ 1C2C F6                   defb    $F6             ; Flag "STOP"
1492+ 1C2D C0           PEND:   ret     NZ              ; Exit if anything else
1493+ 1C2E 22 B5 81             ld      (BRKLIN),HL     ; Save point of break
1494+ 1C31 21                   defb    $21             ; Skip "OR 11111111B"
1495+ 1C32 F6 FF        INPBRK: or      %11111111       ; Flag "Break" wanted
1496+ 1C34 C1                   pop     BC              ; Return not needed and more
1497+ 1C35 2A AF 80     ENDPRG: ld      HL,(LINEAT)     ; Get current line number
1498+ 1C38 F5                   push    AF              ; Save STOP / END status
1499+ 1C39 7D                   ld      A,L             ; Is it direct break?
1500+ 1C3A A4                   and     H
1501+ 1C3B 3C                   inc     A               ; Line is -1 if direct break
1502+ 1C3C CA 48 1C             jp      Z,NOLIN         ; Yes - No line number
1503+ 1C3F 22 B9 81             ld      (ERRLIN),HL     ; Save line of break
1504+ 1C42 2A B5 81             ld      HL,(BRKLIN)     ; Get point of break
1505+ 1C45 22 BB 81             ld      (CONTAD),HL     ; Save point to CONTinue
1506+ 1C48 AF           NOLIN:  xor     A
1507+ 1C49 32 A5 80             ld      (CTLOFG),A      ; Enable output
1508+ 1C4C CD 9E 1E             call    STTLIN          ; Start a new line
1509+ 1C4F F1                   pop     AF              ; Restore STOP / END status
1510+ 1C50 21 43 16             ld      HL,BRKMSG       ; "Break" message
1511+ 1C53 C2 59 1C             jp      NZ,ERRINT       ; "in line" wanted?
1512+ 1C56 C3 1A 17             jp      PRNTOK          ; Go to command mode
1513+ 1C59 CD 9A 16     ERRINT: call    EXITGM          ; exit from graphics mode
1514+ 1C5C C3 F8 16             jp      ERRIN           ; print message
1515+ 1C5F
1516+ 1C5F
1517+ 1C5F 21 FF FF     CONT:   ld      HL,-1           ; reset...
1518+ 1C62 22 B1 80             ld      (HLPLN),HL      ; ...HELP line register
1519+ 1C65 2A BB 81             ld      HL,(CONTAD)     ; Get CONTinue address
1520+ 1C68 7C                   ld      A,H             ; Is it zero?
1521+ 1C69 B5                   or      L
1522+ 1C6A 1E 20                ld      E,CN            ; ?CN Error
1523+ 1C6C CA D4 16             jp      Z,ERROR         ; Yes - output "?CN Error"
1524+ 1C6F EB                   ex      DE,HL           ; Save code string address
1525+ 1C70 2A B9 81             ld      HL,(ERRLIN)     ; Get line of last break
1526+ 1C73 22 AF 80             ld      (LINEAT),HL     ; Set up current line number
1527+ 1C76 EB                   ex      DE,HL           ; Restore code string address
1528+ 1C77 C9                   ret                     ; CONTinue where left off
1529+ 1C78
1530+ 1C78 E5           ACCSUM: push    HL              ; Save address in array
1531+ 1C79 2A A6 80             ld      HL,(CHKSUM)     ; Get check sum
1532+ 1C7C 06 00                ld      B,$00           ; BC - Value of byte
1533+ 1C7E 4F                   ld      C,A
1534+ 1C7F 09                   add     HL,BC           ; Add byte to check sum
1535+ 1C80 22 A6 80             ld      (CHKSUM),HL     ; Re-save check sum
1536+ 1C83 E1                   pop     HL              ; Restore address in array
1537+ 1C84 C9                   ret
1538+ 1C85
1539+ 1C85 7E           CHKLTR: ld      A,(HL)          ; Get byte
1540+ 1C86 FE 41                cp      'A'             ; < 'a' ?
1541+ 1C88 D8                   ret     C               ; Carry set if not letter
1542+ 1C89 FE 5B                cp      'Z'+1           ; > 'z' ?
1543+ 1C8B 3F                   ccf
1544+ 1C8C C9                   ret                     ; Carry set if not letter
1545+ 1C8D
1546+ 1C8D CD E3 1B     FPSINT: call    GETCHR          ; Get next character
1547+ 1C90 CD 6C 20     POSINT: call    GETNUM          ; Get integer 0 to 32767
1548+ 1C93 CD 79 2E     DEPINT: call    TSTSGN          ; Test sign of FPREG
1549+ 1C96 FA AE 1C             jp      M,FCERR         ; Negative - ?FC Error
1550+ 1C99 3A 35 82     DEINT:  ld      A,(FPEXP)       ; Get integer value to DE
1551+ 1C9C FE 90                cp      $80+$10         ; Exponent in range (16 bits)?
1552+ 1C9E DA 21 2F             jp      C,FPINT         ; Yes - convert it
1553+ 1CA1 01 80 90             ld      BC,$9080        ; BCDE = -32768
1554+ 1CA4 11 00 00             ld      DE,$0000
1555+ 1CA7 E5                   push    HL              ; Save code string address
1556+ 1CA8 CD F4 2E             call    CMPNUM          ; Compare FPREG with BCDE
1557+ 1CAB E1                   pop     HL              ; Restore code string address
1558+ 1CAC 51                   ld      D,C             ; MSB to D
1559+ 1CAD C8                   ret     Z               ; Return if in range
1560+ 1CAE 1E 08        FCERR:  ld      E,FC            ; ?FC Error
1561+ 1CB0 C3 D4 16             jp      ERROR           ; Output error-
1562+ 1CB3
1563+ 1CB3 2B           ATOH:   dec     HL              ; ASCII number to DE binary
1564+ 1CB4 11 00 00     GETLN:  ld      DE,$0000        ; Get number to DE
1565+ 1CB7 CD E3 1B     GTLNLP: call    GETCHR          ; Get next character
1566+ 1CBA D0                   ret     NC              ; Exit if not a digit
1567+ 1CBB E5                   push    HL              ; Save code string address
1568+ 1CBC F5                   push    AF              ; Save digit
1569+ 1CBD 21 98 19             ld      HL,65529/10     ; Largest number 65529
1570+ 1CC0 CD 9C 19             call    CPDEHL          ; Number in range?
1571+ 1CC3 DA C0 16             jp      C,SNERR         ; No - ?SN Error
1572+ 1CC6 62                   ld      H,D             ; HL = Number
1573+ 1CC7 6B                   ld      L,E
1574+ 1CC8 19                   add     HL,DE           ; Times 2
1575+ 1CC9 29                   add     HL,HL           ; Times 4
1576+ 1CCA 19                   add     HL,DE           ; Times 5
1577+ 1CCB 29                   add     HL,HL           ; Times 10
1578+ 1CCC F1                   pop     AF              ; Restore digit
1579+ 1CCD D6 30                sub     '0'             ; Make it 0 to 9
1580+ 1CCF 5F                   ld      E,A             ; DE = Value of digit
1581+ 1CD0 16 00                ld      D,0
1582+ 1CD2 19                   add     HL,DE           ; Add to number
1583+ 1CD3 EB                   ex      DE,HL           ; Number to DE
1584+ 1CD4 E1                   pop     HL              ; Restore code string address
1585+ 1CD5 C3 B7 1C             jp      GTLNLP          ; Go to next character
1586+ 1CD8
1587+ 1CD8 CA F6 17     CLEAR:  jp      Z,INTVAR        ; Just "CLEAR" Keep parameters
1588+ 1CDB CD 6C 20             call    GETNUM          ; Evaluate a number
1589+ 1CDE CD 99 1C             call    DEINT           ; Get integer -32768 to 32767 into DE
1590+ 1CE1 2B                   dec     HL              ; Cancel increment
1591+ 1CE2 CD E3 1B             call    GETCHR          ; Get next character
1592+ 1CE5 E5                   push    HL              ; Save code string address
1593+ 1CE6 2A 96 81             ld      HL,(LSTRAM)     ; Get end of RAM
1594+ 1CE9 CA 01 1D             jp      Z,STORED        ; No value given - Use stored
1595+ 1CEC E1                   pop     HL              ; Restore code string address
1596+ 1CED CD A2 19             call    CHKSYN          ; Check for comma
1597+ 1CF0 2C                   defb    ','
1598+ 1CF1 D5                   push    DE              ; Save number
1599+ 1CF2 CD 6C 20             call    GETNUM          ; Evaluate a number
1600+ 1CF5 CD 99 1C             call    DEINT           ; Get integer -32768 to 32767 into DE
1601+ 1CF8 2B                   dec     HL              ; Cancel increment
1602+ 1CF9 CD E3 1B             call    GETCHR          ; Get next character
1603+ 1CFC C2 C0 16             jp      NZ,SNERR        ; ?SN Error if more on line
1604+ 1CFF E3                   ex      (SP),HL         ; Save code string address
1605+ 1D00 EB                   ex      DE,HL           ; Number to DE
1606+ 1D01 7D           STORED: ld      A,L             ; Get LSB of new RAM top
1607+ 1D02 93                   sub     E               ; Subtract LSB of string space
1608+ 1D03 5F                   ld      E,A             ; Save LSB
1609+ 1D04 7C                   ld      A,H             ; Get MSB of new RAM top
1610+ 1D05 9A                   sbc     A,D             ; Subtract MSB of string space
1611+ 1D06 57                   ld      D,A             ; Save MSB
1612+ 1D07 DA 95 16             jp      C,OMERR         ; ?OM Error if not enough mem
1613+ 1D0A E5                   push    HL              ; Save RAM top
1614+ 1D0B 2A 24 82             ld      HL,(PROGND)     ; Get program end
1615+ 1D0E 01 28 00             ld      BC,$28          ; 40 Bytes minimum working RAM
1616+ 1D11 09                   add     HL,BC           ; Get lowest address
1617+ 1D12 CD 9C 19             call    CPDEHL          ; Enough memory?
1618+ 1D15 D2 95 16             jp      NC,OMERR        ; No - ?OM Error
1619+ 1D18 EB                   ex      DE,HL           ; RAM top to HL
1620+ 1D19 22 AD 80             ld      (STRSPC),HL     ; Set new string space
1621+ 1D1C E1                   pop     HL              ; End of memory to use
1622+ 1D1D 22 96 81             ld      (LSTRAM),HL     ; Set new top of RAM
1623+ 1D20 E1                   pop     HL              ; Restore code string address
1624+ 1D21 C3 F6 17             jp      INTVAR          ; Initialise variables
1625+ 1D24
1626+ 1D24 E5           RUN:    push    HL              ; store HL
1627+ 1D25 21 FF FF             ld      HL,-1           ; reset...
1628+ 1D28 22 B1 80             ld      (HLPLN),HL      ; ...HELP line register
1629+ 1D2B E1                   pop     HL              ; retrieve HL
1630+ 1D2C CA F2 17             jp      Z,RUNFST        ; RUN from start if just RUN
1631+ 1D2F CD F6 17             call    INTVAR          ; Initialise variables
1632+ 1D32 01 A3 1B             ld      BC,RUNCNT       ; Execution driver loop
1633+ 1D35 C3 48 1D             jp      RUNLIN          ; RUN from line number
1634+ 1D38
1635+ 1D38 0E 03        GOSUB:  ld      C,$03           ; 3 Levels of stack needed
1636+ 1D3A CD 7D 16             call    CHKSTK          ; Check for 3 levels of stack
1637+ 1D3D C1                   pop     BC              ; Get return address
1638+ 1D3E E5                   push    HL              ; Save code string for RETURN
1639+ 1D3F E5                   push    HL              ; And for GOSUB routine
1640+ 1D40 2A AF 80             ld      HL,(LINEAT)     ; Get current line
1641+ 1D43 E3                   ex      (SP),HL         ; Into stack - Code string out
1642+ 1D44 3E 8C                ld      A,ZGOSUB        ; "GOSUB" token
1643+ 1D46 F5                   push    AF              ; Save token
1644+ 1D47 33                   inc     SP              ; Don't save flags
1645+ 1D48
1646+ 1D48 C5           RUNLIN: push    BC              ; Save return address
1647+ 1D49 CD B3 1C     GOTO:   call    ATOH            ; ASCII number to DE binary
1648+ 1D4C CD 8E 1D             call    REM             ; Get end of line
1649+ 1D4F E5                   push    HL              ; Save end of line
1650+ 1D50 2A AF 80             ld      HL,(LINEAT)     ; Get current line
1651+ 1D53 CD 9C 19             call    CPDEHL          ; Line after current?
1652+ 1D56 E1                   pop     HL              ; Restore end of line
1653+ 1D57 23                   inc     HL              ; Start of next line
1654+ 1D58 DC C9 17             call    C,SRCHLP        ; Line is after current line
1655+ 1D5B D4 C6 17             call    NC,SRCHLN       ; Line is before current line
1656+ 1D5E 60                   ld      H,B             ; Set up code string address
1657+ 1D5F 69                   ld      L,C
1658+ 1D60 2B                   dec     HL              ; Incremented after
1659+ 1D61 D8                   ret     C               ; Line found
1660+ 1D62 1E 0E        ULERR:  ld      E,UL            ; ?UL Error
1661+ 1D64 C3 D4 16             jp      ERROR           ; Output error message
1662+ 1D67
1663+ 1D67 C0           RETURN: ret     NZ              ; Return if not just RETURN
1664+ 1D68 16 FF                ld      D,-1            ; Flag "GOSUB" search
1665+ 1D6A CD 49 16             call    BAKSTK          ; Look "GOSUB" block
1666+ 1D6D F9                   ld      SP,HL           ; Kill all FORs in subroutine
1667+ 1D6E FE 8C                cp      ZGOSUB          ; Test for "GOSUB" token
1668+ 1D70 1E 04                ld      E,RG            ; ?RG Error
1669+ 1D72 C2 D4 16             jp      NZ,ERROR        ; Error if no "GOSUB" found
1670+ 1D75 E1                   pop     HL              ; Get RETURN line number
1671+ 1D76 22 AF 80             ld      (LINEAT),HL     ; Save as current
1672+ 1D79 23                   inc     HL              ; Was it from direct statement?
1673+ 1D7A 7C                   ld      A,H
1674+ 1D7B B5                   or      L               ; Return to line
1675+ 1D7C C2 86 1D             jp      NZ,RETLIN       ; No - Return to line
1676+ 1D7F 3A B3 81             ld      A,(LSTBIN)      ; Any INPUT in subroutine?
1677+ 1D82 B7                   or      A               ; If so buffer is corrupted
1678+ 1D83 C2 19 17             jp      NZ,POPNOK       ; Yes - Go to command mode
1679+ 1D86 21 A3 1B     RETLIN: ld      HL,RUNCNT       ; Execution driver loop
1680+ 1D89 E3                   ex      (SP),HL         ; Into stack - Code string out
1681+ 1D8A 3E                   defb    $3E             ; Skip "pop HL"
1682+ 1D8B E1           NXTDTA: pop     HL              ; Restore code string address
1683+ 1D8C
1684+ 1D8C 01 3A        DATA:   defb    $01,$3A         ; ':' End of statement (stands for LD BC,$0E3A - NOP)
1685+ 1D8E 0E 00        REM:    ld      C,$00           ; 00  End of statement
1686+ 1D90 06 00                ld      B,$00
1687+ 1D92 79           NXTSTL: ld      A,C             ; Statement and byte
1688+ 1D93 48                   ld      C,B
1689+ 1D94 47                   ld      B,A             ; Statement end byte
1690+ 1D95 7E           NXTSTT: ld      A,(HL)          ; Get byte
1691+ 1D96 B7                   or      A               ; End of line?
1692+ 1D97 C8                   ret     Z               ; Yes - Exit
1693+ 1D98 B8                   cp      B               ; End of statement?
1694+ 1D99 C8                   ret     Z               ; Yes - Exit
1695+ 1D9A 23                   inc     HL              ; Next byte
1696+ 1D9B FE 22                cp      $22             ; '"'             ; Literal string?
1697+ 1D9D CA 92 1D             jp      Z,NXTSTL        ; Yes - Look for another '"'
1698+ 1DA0 C3 95 1D             jp      NXTSTT          ; Keep looking
1699+ 1DA3
1700+ 1DA3 CD 7B 22     LET:    call    GETVAR          ; Get variable name
1701+ 1DA6 CD A2 19             call    CHKSYN          ; Make sure "=" follows
1702+ 1DA9 C8                   defb    ZEQUAL          ; "=" token
1703+ 1DAA D5                   push    DE              ; Save address of variable
1704+ 1DAB 3A 94 81             ld      A,(TYPE)        ; Get data type
1705+ 1DAE F5                   push    AF              ; Save type
1706+ 1DAF CD 7E 20             call    EVAL            ; Evaluate expression
1707+ 1DB2 F1                   pop     AF              ; Restore type
1708+ 1DB3 E3                   ex      (SP),HL         ; Save code - Get var addr
1709+ 1DB4 22 B5 81             ld      (BRKLIN),HL     ; Save address of variable
1710+ 1DB7 1F                   rra                     ; Adjust type
1711+ 1DB8 CD 71 20             call    CHKTYP          ; Check types are the same
1712+ 1DBB CA F6 1D             jp      Z,LETNUM        ; Numeric - Move value
1713+ 1DBE E5           LETSTR: push    HL              ; Save address of string var
1714+ 1DBF 2A 32 82             ld      HL,(FPREG)      ; Pointer to string entry
1715+ 1DC2 E5                   push    HL              ; Save it on stack
1716+ 1DC3 23                   inc     HL              ; Skip over length
1717+ 1DC4 23                   inc     HL
1718+ 1DC5 5E                   ld      E,(HL)          ; LSB of string address
1719+ 1DC6 23                   inc     HL
1720+ 1DC7 56                   ld      D,(HL)          ; MSB of string address
1721+ 1DC8 2A 35 81             ld      HL,(BASTXT)     ; Point to start of program
1722+ 1DCB CD 9C 19             call    CPDEHL          ; Is string before program?
1723+ 1DCE D2 E5 1D             jp      NC,CRESTR       ; Yes - Create string entry
1724+ 1DD1 2A AD 80             ld      HL,(STRSPC)     ; Point to string space
1725+ 1DD4 CD 9C 19             call    CPDEHL          ; Is string literal in program?
1726+ 1DD7 D1                   pop     DE              ; Restore address of string
1727+ 1DD8 D2 ED 1D             jp      NC,MVSTPT       ; Yes - Set up pointer
1728+ 1DDB 21 A6 81             ld      HL,TMPSTR       ; Temporary string pool
1729+ 1DDE CD 9C 19             call    CPDEHL          ; Is string in temporary pool?
1730+ 1DE1 D2 ED 1D             jp      NC,MVSTPT       ; No - Set up pointer
1731+ 1DE4 3E                   defb    $3E             ; Skip "pop DE"
1732+ 1DE5 D1           CRESTR: pop     DE              ; Restore address of string
1733+ 1DE6 CD D5 26             call    BAKTMP          ; Back to last tmp-str entry
1734+ 1DE9 EB                   ex      DE,HL           ; Address of string entry
1735+ 1DEA CD 0E 25             call    SAVSTR          ; Save string in string area
1736+ 1DED CD D5 26     MVSTPT: call    BAKTMP          ; Back to last tmp-str entry
1737+ 1DF0 E1                   pop     HL              ; Get string pointer
1738+ 1DF1 CD D4 2E             call    DETHL4          ; Move string pointer to var
1739+ 1DF4 E1                   pop     HL              ; Restore code string address
1740+ 1DF5 C9                   ret
1741+ 1DF6
1742+ 1DF6 E5           LETNUM: push    HL              ; Save address of variable
1743+ 1DF7 CD D1 2E             call    FPTHL           ; Move value to variable
1744+ 1DFA D1                   pop     DE              ; Restore address of variable
1745+ 1DFB E1                   pop     HL              ; Restore code string address
1746+ 1DFC C9                   ret
1747+ 1DFD
1748+ 1DFD CD F2 28     ON:     call    GETINT          ; Get integer 0-255
1749+ 1E00 7E                   ld      A,(HL)          ; Get "GOTO" or "GOSUB" token
1750+ 1E01 47                   ld      B,A             ; Save in B
1751+ 1E02 FE 8C                cp      ZGOSUB          ; "GOSUB" token?
1752+ 1E04 CA 0C 1E             jp      Z,ONGO          ; Yes - Find line number
1753+ 1E07 CD A2 19             call    CHKSYN          ; Make sure it's "GOTO"
1754+ 1E0A 88                   defb    ZGOTO           ; "GOTO" token
1755+ 1E0B 2B                   dec     HL              ; Cancel increment
1756+ 1E0C 4B           ONGO:   ld      C,E             ; Integer of branch value
1757+ 1E0D 0D           ONGOLP: dec     C               ; Count branches
1758+ 1E0E 78                   ld      A,B             ; Get "GOTO" or "GOSUB" token
1759+ 1E0F CA CB 1B             jp      Z,ONJMP         ; Go to that line if right one
1760+ 1E12 CD B4 1C             call    GETLN           ; Get line number to DE
1761+ 1E15 FE 2C                cp      ','             ; Another line number?
1762+ 1E17 C0                   ret     NZ              ; No - Drop through
1763+ 1E18 C3 0D 1E             jp      ONGOLP          ; Yes - loop
1764+ 1E1B
1765+ 1E1B CD 7E 20     IF:     call    EVAL            ; Evaluate expression
1766+ 1E1E 7E                   ld      A,(HL)          ; Get token
1767+ 1E1F FE 88                cp      ZGOTO           ; "GOTO" token?
1768+ 1E21 CA 29 1E             jp      Z,IFGO          ; Yes - Get line
1769+ 1E24 CD A2 19             call    CHKSYN          ; Make sure it's "THEN"
1770+ 1E27 BA                   defb    ZTHEN           ; "THEN" token
1771+ 1E28 2B                   dec     HL              ; Cancel increment
1772+ 1E29 CD 6F 20     IFGO:   call    TSTNUM          ; Make sure it's numeric
1773+ 1E2C CD 79 2E             call    TSTSGN          ; Test state of expression
1774+ 1E2F CA 3B 1E             jp      Z,IF1           ; False - Jump over
1775+ 1E32 CD E3 1B     IF0:    call    GETCHR          ; Get next character
1776+ 1E35 DA 49 1D             jp      C,GOTO          ; Number - GOTO that line
1777+ 1E38 C3 CA 1B             jp      IFJMP           ; Otherwise do statement
1778+ 1E3B 0E AE        IF1:    ld      C,ZELSE
1779+ 1E3D CD 90 1D             call    REM+2           ; check statement
1780+ 1E40 B7                   or      A               ; end of line?
1781+ 1E41 C8                   ret     Z               ; yes, leave
1782+ 1E42 FE AE                cp      ZELSE
1783+ 1E44 20 F5                jr      NZ,IF1          ; ELSE not found, continue check
1784+ 1E46 C3 32 1E             jp      IF0             ; return to IF
1785+ 1E49
1786+ 1E49
1787+ 1E49 2B           MRPRNT: dec     HL              ; dec 'cos GETCHR INCs
1788+ 1E4A CD E3 1B             call    GETCHR          ; Get next character
1789+ 1E4D CA B0 1E     PRINT:  jp      Z,PRNTCRLF      ; CRLF if just PRINT
1790+ 1E50 C8           PRNTLP: ret     Z               ; End of list - Exit
1791+ 1E51 FE B6                cp      ZTAB            ; "TAB(" token?
1792+ 1E53 CA D8 1E             jp      Z,DOTAB         ; Yes - Do TAB routine
1793+ 1E56 FE B9                cp      ZSPC            ; "SPC(" token?
1794+ 1E58 CA D8 1E             jp      Z,DOTAB         ; Yes - Do SPC routine
1795+ 1E5B E5                   push    HL              ; Save code string address
1796+ 1E5C FE 2C                cp      ','             ; Comma?
1797+ 1E5E CA BF 1E             jp      Z,DOCOM         ; Yes - Move to next zone
1798+ 1E61 FE 3B                cp      ';'             ; Semi-colon?
1799+ 1E63 CA FC 1E             jp      Z,NEXITM        ; Do semi-colon routine
1800+ 1E66 C1                   pop     BC              ; Code string address to BC
1801+ 1E67 CD 7E 20             call    EVAL            ; Evaluate expression
1802+ 1E6A E5                   push    HL              ; Save code string address
1803+ 1E6B 3A 94 81             ld      A,(TYPE)        ; Get variable type
1804+ 1E6E B7                   or      A               ; Is it a string variable?
1805+ 1E6F C2 97 1E             jp      NZ,PRNTST       ; Yes - Output string contents
1806+ 1E72 CD 1E 30             call    NUMASC          ; Convert number to text
1807+ 1E75 CD 32 25             call    CRTST           ; Create temporary string
1808+ 1E78 36 00                ld      (HL),NLLCR      ; Followed by a NULL char (was SPC, space)
1809+ 1E7A 2A 32 82             ld      HL,(FPREG)      ; Get length of output
1810+ 1E7D 34                   inc     (HL)            ; Plus 1 for the space
1811+ 1E7E 2A 32 82             ld      HL,(FPREG)      ; < Not needed >
1812+ 1E81 3A A2 80             ld      A,(LWIDTH)      ; Get width of line
1813+ 1E84 47                   ld      B,A             ; To B
1814+ 1E85 04                   inc     B               ; Width 255 (No limit)?
1815+ 1E86 CA 93 1E             jp      Z,PRNTNB        ; Yes - Output number string
1816+ 1E89 04                   inc     B               ; Adjust it
1817+ 1E8A 3A 92 81             ld      A,(CURPOS)      ; Get cursor position
1818+ 1E8D 86                   add     A,(HL)          ; Add length of string
1819+ 1E8E 3D                   dec     A               ; Adjust it
1820+ 1E8F B8                   cp      B               ; Will output fit on this line?
1821+ 1E90 D4 B0 1E             call    NC,PRNTCRLF     ; No - CRLF first
1822+ 1E93 CD 77 25     PRNTNB: call    PRS1            ; Output string at (HL)
1823+ 1E96 AF                   xor     A               ; Skip call by setting 'z' flag
1824+ 1E97 C4 77 25     PRNTST: call    NZ,PRS1         ; Output string at (HL)
1825+ 1E9A E1                   pop     HL              ; Restore code string address
1826+ 1E9B C3 49 1E             jp      MRPRNT          ; See if more to PRINT
1827+ 1E9E
1828+ 1E9E 3A 92 81     STTLIN: ld      A,(CURPOS)      ; Make sure on new line
1829+ 1EA1 B7                   or      A               ; Already at start?
1830+ 1EA2 C8                   ret     Z               ; Yes - Do nothing
1831+ 1EA3 C3 B0 1E             jp      PRNTCRLF        ; Start a new line
1832+ 1EA6
1833+ 1EA6 AF           ENDINP: xor     A
1834+ 1EA7 32 18 82             ld      (KBDNPT),A      ; char is not from keyboard
1835+ 1EAA 77                   ld      (HL),A          ; Mark end of buffer
1836+ 1EAB 21 37 81             ld      HL,BUFFER-1     ; Point to buffer
1837+ 1EAE 18 0A                jr      CNTEND
1838+ 1EB0 3E 0D        PRNTCRLF:ld     A,CR            ; Load a CR
1839+ 1EB2 CD AD 19             call    OUTC            ; Output character
1840+ 1EB5 3E 0A                ld      A,LF            ; Load a LF
1841+ 1EB7 CD AD 19             call    OUTC            ; Output character
1842+ 1EBA AF           CNTEND: xor     A               ; Set to position 0
1843+ 1EBB 32 92 81             ld      (CURPOS),A      ; Store it
1844+ 1EBE C9                   ret                     ; return to caller
1845+ 1EBF
1846+ 1EBF 3A A3 80     DOCOM:  ld      A,(COMMAN)      ; Get comma width
1847+ 1EC2 47                   ld      B,A             ; Save in B
1848+ 1EC3 3A D3 81             ld      A,(SCR_CURS_X)  ; Get current position
1849+ 1EC6 B8                   cp      B               ; Within the limit?
1850+ 1EC7 D4 B0 1E             call    NC,PRNTCRLF     ; No - output CRLF
1851+ 1ECA D2 FC 1E             jp      NC,NEXITM       ; Get next item
1852+ 1ECD D6 0A        ZONELP: sub     $0A             ; Next zone of 10 characters
1853+ 1ECF D2 CD 1E             jp      NC,ZONELP       ; Repeat if more zones
1854+ 1ED2 2F                   cpl                     ; Number of null chars to output
1855+ 1ED3 0E 00                ld      C,NLLCR         ; null char
1856+ 1ED5 C3 F2 1E             jp      ASPCS           ; Output them
1857+ 1ED8
1858+ 1ED8 F5           DOTAB:  push    AF              ; Save token
1859+ 1ED9 CD EF 28             call    FNDNUM          ; Evaluate expression
1860+ 1EDC CD A2 19             call    CHKSYN          ; Make sure ")" follows
1861+ 1EDF 29                   defb    ')'
1862+ 1EE0 2B                   dec     HL              ; Back space on to ")"
1863+ 1EE1 F1                   pop     AF              ; Restore token
1864+ 1EE2 0E 00                ld      C,NLLCR         ; for SPC we use NULL char (was SPACE)
1865+ 1EE4 D6 B9                sub     ZSPC            ; Was it "SPC(" ?
1866+ 1EE6 E5                   push    HL              ; Save code string address
1867+ 1EE7 CA ED 1E             jp      Z,DOSPC         ; Yes - Do 'E' spaces
1868+ 1EEA 3A D3 81             ld      A,(SCR_CURS_X)  ; Get current X position
1869+ 1EED 2F           DOSPC:  cpl                     ; Number of spaces to print to
1870+ 1EEE 83                   add     A,E             ; Total number to print
1871+ 1EEF D2 FC 1E             jp      NC,NEXITM       ; TAB < Current POS(X)
1872+ 1EF2 3C           ASPCS:  inc     A               ; Output A spaces
1873+ 1EF3 47                   ld      B,A             ; Save number to print
1874+ 1EF4 79           SPCLP:  ld      A,C             ; char to print
1875+ 1EF5 CD AD 19             call    OUTC            ; Output character in A
1876+ 1EF8 05                   dec     B               ; Count them
1877+ 1EF9 C2 F4 1E             jp      NZ,SPCLP        ; Repeat if more
1878+ 1EFC E1           NEXITM: pop     HL              ; Restore code string address
1879+ 1EFD CD E3 1B             call    GETCHR          ; Get next character
1880+ 1F00 C3 50 1E             jp      PRNTLP          ; More to print
1881+ 1F03
1882+ 1F03 3F 52 65 64  REDO:   defb    "?Redo from start",CR,0
1882+ 1F07 6F 20 66 72
1882+ 1F0B 6F 6D 20 73
1882+ 1F0F 74 61 72 74
1882+ 1F13 0D 00
1883+ 1F15
1884+ 1F15 3A B4 81     BADINP: ld      A,(READFG)      ; READ or INPUT?
1885+ 1F18 B7                   or      A
1886+ 1F19 C2 BA 16             jp      NZ,DATSNR       ; READ - ?SN Error
1887+ 1F1C C1                   pop     BC              ; Throw away code string addr
1888+ 1F1D 21 03 1F             ld      HL,REDO         ; "Redo from start" message
1889+ 1F20 CD 74 25             call    PRS             ; Output string
1890+ 1F23 C3 25 18             jp      DOAGN           ; Do last INPUT again
1891+ 1F26
1892+ 1F26 CD DF 24     INPUT:  call    IDTEST          ; Test for illegal direct
1893+ 1F29 7E                   ld      A,(HL)          ; Get character after "INPUT"
1894+ 1F2A FE 22                cp      $22             ; '"' ; Is there a prompt string?
1895+ 1F2C 3E 00                ld      A,$00           ; Clear A and leave flags
1896+ 1F2E 32 A5 80             ld      (CTLOFG),A      ; Enable output
1897+ 1F31 C2 40 1F             jp      NZ,NOPMPT       ; No prompt - get input
1898+ 1F34 CD 33 25             call    QTSTR           ; Get string terminated by '"'
1899+ 1F37 CD A2 19             call    CHKSYN          ; Check for ';' after prompt
1900+ 1F3A 3B                   defb    ";"
1901+ 1F3B E5                   push    HL              ; Save code string address
1902+ 1F3C CD 77 25             call    PRS1            ; Output prompt string
1903+ 1F3F 3E                   defb    $3E             ; Skip "push HL"
1904+ 1F40 E5           NOPMPT: push    HL              ; Save code string address
1905+ 1F41 CD 29 18             call    PROMPT          ; Get input with "? " prompt
1906+ 1F44 C1                   pop     BC              ; Restore code string address
1907+ 1F45 DA 32 1C             jp      C,INPBRK        ; Break pressed - Exit
1908+ 1F48 23                   inc     HL              ; Next byte
1909+ 1F49 7E                   ld      A,(HL)          ; Get it
1910+ 1F4A B7                   or      A               ; End of line?
1911+ 1F4B 2B                   dec     HL              ; Back again
1912+ 1F4C C5                   push    BC              ; Re-save code string address
1913+ 1F4D CD 1F 09             call    CURSOR_OFF      ; disable cursor
1914+ 1F50 CA 8B 1D             jp      Z,NXTDTA        ; Yes - Find next DATA stmt
1915+ 1F53 36 2C                ld      (HL),','        ; Store comma as separator
1916+ 1F55 C3 5D 1F             jp      NXTITM          ; Get next item
1917+ 1F58
1918+ 1F58 E5           READ:   push    HL              ; Save code string address
1919+ 1F59 2A 2A 82             ld      HL,(NXTDAT)     ; Next DATA statement
1920+ 1F5C F6                   defb    $F6             ; Flag "READ"
1921+ 1F5D AF           NXTITM: xor     A               ; Flag "INPUT"
1922+ 1F5E 32 B4 81             ld      (READFG),A      ; Save "READ"/"INPUT" flag
1923+ 1F61 E3                   ex      (SP),HL         ; Get code str' , Save pointer
1924+ 1F62 C3 69 1F             jp      GTVLUS          ; Get values
1925+ 1F65
1926+ 1F65 CD A2 19     NEDMOR: call    CHKSYN          ; Check for comma between items
1927+ 1F68 2C                   defb    ','
1928+ 1F69 CD 7B 22     GTVLUS: call    GETVAR          ; Get variable name
1929+ 1F6C E3                   ex      (SP),HL         ; Save code str" , Get pointer
1930+ 1F6D D5                   push    DE              ; Save variable address
1931+ 1F6E 7E                   ld      A,(HL)          ; Get next "INPUT"/"DATA" byte
1932+ 1F6F FE 2C                cp      ','             ; Comma?
1933+ 1F71 CA 91 1F             jp      Z,ANTVLU        ; Yes - Get another value
1934+ 1F74 3A B4 81             ld      A,(READFG)      ; Is it READ?
1935+ 1F77 B7                   or      A
1936+ 1F78 C2 FD 1F             jp      NZ,FDTLP        ; Yes - Find next DATA stmt
1937+ 1F7B 3E 3F                ld      A,'?'           ; More INPUT needed
1938+ 1F7D CD AD 19             call    OUTC            ; Output character
1939+ 1F80 CD 29 18             call    PROMPT          ; Get INPUT with prompt
1940+ 1F83 D1                   pop     DE              ; Variable address
1941+ 1F84 C1                   pop     BC              ; Code string address
1942+ 1F85 DA 32 1C             jp      C,INPBRK        ; Break pressed
1943+ 1F88 23                   inc     HL              ; Point to next DATA byte
1944+ 1F89 7E                   ld      A,(HL)          ; Get byte
1945+ 1F8A B7                   or      A               ; Is it zero (No input) ?
1946+ 1F8B 2B                   dec     HL              ; Back space INPUT pointer
1947+ 1F8C C5                   push    BC              ; Save code string address
1948+ 1F8D CA 8B 1D             jp      Z,NXTDTA        ; Find end of buffer
1949+ 1F90 D5                   push    DE              ; Save variable address
1950+ 1F91 3A 94 81     ANTVLU: ld      A,(TYPE)        ; Check data type
1951+ 1F94 B7                   or      A               ; Is it numeric?
1952+ 1F95 CA BB 1F             jp      Z,INPBIN        ; Yes - Convert to binary
1953+ 1F98 CD E3 1B             call    GETCHR          ; Get next character
1954+ 1F9B 57                   ld      D,A             ; Save input character
1955+ 1F9C 47                   ld      B,A             ; Again
1956+ 1F9D FE 22                cp      $22             ; '"'     ; Start of literal sting?
1957+ 1F9F CA AF 1F             jp      Z,STRENT        ; Yes - Create string entry
1958+ 1FA2 3A B4 81             ld      A,(READFG)      ; "READ" or "INPUT" ?
1959+ 1FA5 B7                   or      A
1960+ 1FA6 57                   ld      D,A             ; Save 00 if "INPUT"
1961+ 1FA7 CA AC 1F             jp      Z,ITMSEP        ; "INPUT" - End with 00
1962+ 1FAA 16 3A                ld      D,':'           ; "DATA" - End with 00 or ':'
1963+ 1FAC 06 2C        ITMSEP: ld      B,','           ; Item separator
1964+ 1FAE 2B                   dec     HL              ; Back space for DTSTR
1965+ 1FAF CD 36 25     STRENT: call    DTSTR           ; Get string terminated by D
1966+ 1FB2 EB                   ex      DE,HL           ; String address to DE
1967+ 1FB3 21 C6 1F             ld      HL,LTSTND       ; Where to go after LETSTR
1968+ 1FB6 E3                   ex      (SP),HL         ; Save HL , get input pointer
1969+ 1FB7 D5                   push    DE              ; Save address of string
1970+ 1FB8 C3 BE 1D             jp      LETSTR          ; Assign string to variable
1971+ 1FBB
1972+ 1FBB CD E3 1B     INPBIN: call    GETCHR          ; Get next character
1973+ 1FBE CD 80 2F             call    ASCTFP          ; Convert ASCII to FP number
1974+ 1FC1 E3                   ex      (SP),HL         ; Save input ptr, Get var addr
1975+ 1FC2 CD D1 2E             call    FPTHL           ; Move FPREG to variable
1976+ 1FC5 E1                   pop     HL              ; Restore input pointer
1977+ 1FC6 2B           LTSTND: dec     HL              ; dec 'cos GETCHR INCs
1978+ 1FC7 CD E3 1B             call    GETCHR          ; Get next character
1979+ 1FCA CA D2 1F             jp      Z,MORDT         ; End of line - More needed?
1980+ 1FCD FE 2C                cp      ','             ; Another value?
1981+ 1FCF C2 15 1F             jp      NZ,BADINP       ; No - Bad input
1982+ 1FD2 E3           MORDT:  ex      (SP),HL         ; Get code string address
1983+ 1FD3 2B                   dec     HL              ; dec 'cos GETCHR INCs
1984+ 1FD4 CD E3 1B             call    GETCHR          ; Get next character
1985+ 1FD7 C2 65 1F             jp      NZ,NEDMOR       ; More needed - Get it
1986+ 1FDA D1                   pop     DE              ; Restore DATA pointer
1987+ 1FDB 3A B4 81             ld      A,(READFG)      ; "READ" or "INPUT" ?
1988+ 1FDE B7                   or      A
1989+ 1FDF EB                   ex      DE,HL           ; DATA pointer to HL
1990+ 1FE0 C2 09 1C             jp      NZ,UPDATA       ; Update DATA pointer if "READ"
1991+ 1FE3 D5                   push    DE              ; Save code string address
1992+ 1FE4 B6                   or      (HL)            ; More input given?
1993+ 1FE5 21 ED 1F             ld      HL,EXTIG        ; "?Extra ignored" message
1994+ 1FE8 C4 74 25             call    NZ,PRS          ; Output string if extra given
1995+ 1FEB E1                   pop     HL              ; Restore code string address
1996+ 1FEC C9                   ret
1997+ 1FED
1998+ 1FED 3F 45 78 74  EXTIG:  defb    "?Extra ignored",CR,0
1998+ 1FF1 72 61 20 69
1998+ 1FF5 67 6E 6F 72
1998+ 1FF9 65 64 0D 00
1999+ 1FFD
2000+ 1FFD CD 8C 1D     FDTLP:  call    DATA            ; Get next statement
2001+ 2000 B7                   or      A               ; End of line?
2002+ 2001 C2 16 20             jp      NZ,FANDT        ; No - See if DATA statement
2003+ 2004 23                   inc     HL
2004+ 2005 7E                   ld      A,(HL)          ; End of program?
2005+ 2006 23                   inc     HL
2006+ 2007 B6                   or      (HL)            ; 00 00 Ends program
2007+ 2008 1E 06                ld      E,OD            ; ?OD Error
2008+ 200A CA D4 16             jp      Z,ERROR         ; Yes - Out of DATA
2009+ 200D 23                   inc     HL
2010+ 200E 5E                   ld      E,(HL)          ; LSB of line number
2011+ 200F 23                   inc     HL
2012+ 2010 56                   ld      D,(HL)          ; MSB of line number
2013+ 2011 EB                   ex      DE,HL
2014+ 2012 22 B0 81             ld      (DATLIN),HL     ; Set line of current DATA item
2015+ 2015 EB                   ex      DE,HL
2016+ 2016 CD E3 1B     FANDT:  call    GETCHR          ; Get next character
2017+ 2019 FE 83                cp      ZDATA           ; "DATA" token
2018+ 201B C2 FD 1F             jp      NZ,FDTLP        ; No "DATA" - Keep looking
2019+ 201E C3 91 1F             jp      ANTVLU          ; Found - Convert input
2020+ 2021
2021+ 2021 11 00 00     NEXT:   ld      DE,$0000        ; In case no index given
2022+ 2024 C4 7B 22     NEXT1:  call    NZ,GETVAR       ; Get index address
2023+ 2027 22 B5 81             ld      (BRKLIN),HL     ; Save code string address
2024+ 202A CD 49 16             call    BAKSTK          ; Look for "FOR" block
2025+ 202D C2 C6 16             jp      NZ,NFERR        ; No "FOR" - ?NF Error
2026+ 2030 F9                   ld      SP,HL           ; Clear nested loops
2027+ 2031 D5                   push    DE              ; Save index address
2028+ 2032 7E                   ld      A,(HL)          ; Get sign of STEP
2029+ 2033 23                   inc     HL
2030+ 2034 F5                   push    AF              ; Save sign of STEP
2031+ 2035 D5                   push    DE              ; Save index address
2032+ 2036 CD B7 2E             call    PHLTFP          ; Move index value to FPREG
2033+ 2039 E3                   ex      (SP),HL         ; Save address of TO value
2034+ 203A E5                   push    HL              ; Save address of index
2035+ 203B CD D3 2B             call    ADDPHL          ; Add STEP to index value
2036+ 203E E1                   pop     HL              ; Restore address of index
2037+ 203F CD D1 2E             call    FPTHL           ; Move value to index variable
2038+ 2042 E1                   pop     HL              ; Restore address of TO value
2039+ 2043 CD C8 2E             call    LOADFP          ; Move TO value to BCDE
2040+ 2046 E5                   push    HL              ; Save address of line of FOR
2041+ 2047 CD F4 2E             call    CMPNUM          ; Compare index with TO value
2042+ 204A E1                   pop     HL              ; Restore address of line num
2043+ 204B C1                   pop     BC              ; Address of sign of STEP
2044+ 204C 90                   sub     B               ; Compare with expected sign
2045+ 204D CD C8 2E             call    LOADFP          ; BC = Loop stmt,DE = Line num
2046+ 2050 CA 5C 20             jp      Z,KILFOR        ; Loop finished - Terminate it
2047+ 2053 EB                   ex      DE,HL           ; Loop statement line number
2048+ 2054 22 AF 80             ld      (LINEAT),HL     ; Set loop line number
2049+ 2057 69                   ld      L,C             ; Set code string to loop
2050+ 2058 60                   ld      H,B
2051+ 2059 C3 9F 1B             jp      PUTFID          ; Put back "FOR" and continue
2052+ 205C
2053+ 205C F9           KILFOR: ld      SP,HL           ; Remove "FOR" block
2054+ 205D 2A B5 81             ld      HL,(BRKLIN)     ; Code string after "NEXT"
2055+ 2060 7E                   ld      A,(HL)          ; Get next byte in code string
2056+ 2061 FE 2C                cp      ','             ; More NEXTs ?
2057+ 2063 C2 A3 1B             jp      NZ,RUNCNT       ; No - Do next statement
2058+ 2066 CD E3 1B             call    GETCHR          ; Position to index name
2059+ 2069 CD 24 20             call    NEXT1           ; Re-enter NEXT routine
2060+ 206C              ; < will not RETurn to here , Exit to RUNCNT or Loop >
2061+ 206C
2062+ 206C CD 7E 20     GETNUM: call    EVAL            ; Get a numeric expression
2063+ 206F F6           TSTNUM: defb    $F6             ; Clear carry (numeric)
2064+ 2070 37           TSTSTR: scf                     ; Set carry (string)
2065+ 2071 3A 94 81     CHKTYP: ld      A,(TYPE)        ; Check types match
2066+ 2074 8F                   adc     A,A             ; Expected + actual
2067+ 2075 B7                   or      A               ; Clear carry , set parity
2068+ 2076 E8                   ret     PE              ; Even parity - Types match
2069+ 2077 C3 D2 16             jp      TMERR           ; Different types - Error
2070+ 207A
2071+ 207A CD A2 19     OPNPAR: call    CHKSYN          ; Make sure "(" follows
2072+ 207D 28                   defb    '('
2073+ 207E 2B           EVAL:   dec     HL              ; Evaluate expression & save
2074+ 207F 16 00                ld      D,$00           ; Precedence value
2075+ 2081 D5           EVAL1:  push    DE              ; Save precedence
2076+ 2082 0E 01                ld      C,$01
2077+ 2084 CD 7D 16             call    CHKSTK          ; Check for 1 level of stack
2078+ 2087 CD F5 20             call    OPRND           ; Get next expression value
2079+ 208A 22 B7 81     EVAL2:  ld      (NXTOPR),HL     ; Save address of next operator
2080+ 208D 2A B7 81     EVAL3:  ld      HL,(NXTOPR)     ; Restore address of next opr
2081+ 2090 C1                   pop     BC              ; Precedence value and operator
2082+ 2091 78                   ld      A,B             ; Get precedence value
2083+ 2092 FE 78                cp      $78             ; "AND", "OR", or "XOR" ?
2084+ 2094 D4 6F 20             call    NC,TSTNUM       ; No - Make sure it's a number
2085+ 2097 7E                   ld      A,(HL)          ; Get next operator / function
2086+ 2098 16 00                ld      D,$00           ; Clear Last relation
2087+ 209A D6 C7        RLTLP:  sub     ZGTR            ; ">" Token
2088+ 209C DA B6 20             jp      C,FOPRND        ; + - * / ^ AND OR XOR - Test it
2089+ 209F FE 03                cp      ZLTH+1-ZGTR     ; < = >
2090+ 20A1 D2 B6 20             jp      NC,FOPRND       ; Function - Call it
2091+ 20A4 FE 01                cp      ZEQUAL-ZGTR     ; "="
2092+ 20A6 17                   rla                     ; <- Test for legal
2093+ 20A7 AA                   xor     D               ; <- combinations of < = >
2094+ 20A8 BA                   cp      D               ; <- by combining last token
2095+ 20A9 57                   ld      D,A             ; <- with current one
2096+ 20AA DA C0 16             jp      C,SNERR         ; Error if "<<' '==" or ">>"
2097+ 20AD 22 AC 81             ld      (CUROPR),HL     ; Save address of current token
2098+ 20B0 CD E3 1B             call    GETCHR          ; Get next character
2099+ 20B3 C3 9A 20             jp      RLTLP           ; Treat the two as one
2100+ 20B6
2101+ 20B6 7A           FOPRND: ld      A,D             ; < = > found ?
2102+ 20B7 B7                   or      A
2103+ 20B8 C2 F6 21             jp      NZ,TSTRED       ; Yes - Test for reduction
2104+ 20BB 7E                   ld      A,(HL)          ; Get operator token
2105+ 20BC 22 AC 81             ld      (CUROPR),HL     ; Save operator address
2106+ 20BF D6 BD                sub     ZPLUS           ; Operator or function?
2107+ 20C1 D8                   ret     C               ; Neither - Exit
2108+ 20C2 FE 0A                cp      ZOR+1-ZPLUS     ; Is it + - * / ^ AND XOR OR ?
2109+ 20C4 D0                   ret     NC              ; No - Exit
2110+ 20C5 5F                   ld      E,A             ; Coded operator
2111+ 20C6 3A 94 81             ld      A,(TYPE)        ; Get data type
2112+ 20C9 3D                   dec     A               ; FF = numeric , 00 = string
2113+ 20CA B3                   or      E               ; Combine with coded operator
2114+ 20CB 7B                   ld      A,E             ; Get coded operator
2115+ 20CC CA 6A 26             jp      Z,CONCAT        ; String concatenation
2116+ 20CF 07                   rlca                    ; Times 2
2117+ 20D0 83                   add     A,E             ; Times 3
2118+ 20D1 5F                   ld      E,A             ; To DE (D is 0)
2119+ 20D2 21 3B 15             ld      HL,PRITAB       ; Precedence table
2120+ 20D5 19                   add     HL,DE           ; To the operator concerned
2121+ 20D6 78                   ld      A,B             ; Last operator precedence
2122+ 20D7 56                   ld      D,(HL)          ; Get evaluation precedence
2123+ 20D8 BA                   cp      D               ; Compare with eval precedence
2124+ 20D9 D0                   ret     NC              ; Exit if higher precedence
2125+ 20DA 23                   inc     HL              ; Point to routine address
2126+ 20DB CD 6F 20             call    TSTNUM          ; Make sure it's a number
2127+ 20DE
2128+ 20DE C5           STKTHS: push    BC              ; Save last precedence & token
2129+ 20DF 01 8D 20             ld      BC,EVAL3        ; Where to go on prec' break
2130+ 20E2 C5                   push    BC              ; Save on stack for return
2131+ 20E3 43                   ld      B,E             ; Save operator
2132+ 20E4 4A                   ld      C,D             ; Save precedence
2133+ 20E5 CD AA 2E             call    STAKFP          ; Move value to stack
2134+ 20E8 58                   ld      E,B             ; Restore operator
2135+ 20E9 51                   ld      D,C             ; Restore precedence
2136+ 20EA 4E                   ld      C,(HL)          ; Get LSB of routine address
2137+ 20EB 23                   inc     HL
2138+ 20EC 46                   ld      B,(HL)          ; Get MSB of routine address
2139+ 20ED 23                   inc     HL
2140+ 20EE C5                   push    BC              ; Save routine address
2141+ 20EF 2A AC 81             ld      HL,(CUROPR)     ; Address of current operator
2142+ 20F2 C3 81 20             jp      EVAL1           ; Loop until prec' break
2143+ 20F5
2144+ 20F5 AF           OPRND:  xor     A               ; Get operand routine
2145+ 20F6 32 94 81             ld      (TYPE),A        ; Set numeric expected
2146+ 20F9 CD E3 1B             call    GETCHR          ; Get next character
2147+ 20FC 1E 24                ld      E,MO            ; ?MO Error
2148+ 20FE CA D4 16             jp      Z,ERROR         ; No operand - Error
2149+ 2101 DA 80 2F             jp      C,ASCTFP        ; Number - Get value
2150+ 2104 CD 85 1C             call    CHKLTR          ; See if a letter
2151+ 2107 D2 5C 21             jp      NC,CONVAR       ; Letter - Find variable
2152+ 210A FE 26                cp      '&'             ; &H = HEX, &B = BINARY
2153+ 210C 20 12                jr      NZ,NOTAMP
2154+ 210E CD E3 1B             call    GETCHR          ; Get next character
2155+ 2111 FE 48                cp      'H'             ; Hex number indicated? [function added]
2156+ 2113 CA E8 3E             jp      Z,HEXTFP        ; Convert Hex to FPREG
2157+ 2116 FE 42                cp      'B'             ; Binary number indicated? [function added]
2158+ 2118 CA 58 3F             jp      Z,BINTFP        ; Convert Bin to FPREG
2159+ 211B 1E 02                ld      E,SN            ; If neither then a ?SN Error
2160+ 211D CA D4 16             jp      Z,ERROR         ;
2161+ 2120 FE BD        NOTAMP: cp      ZPLUS           ; '+' Token ?
2162+ 2122 CA F5 20             jp      Z,OPRND         ; Yes - Look for operand
2163+ 2125 FE 2E                cp      '.'             ; '.' ?
2164+ 2127 CA 80 2F             jp      Z,ASCTFP        ; Yes - Create FP number
2165+ 212A FE BE                cp      ZMINUS          ; '-' Token ?
2166+ 212C CA 4B 21             jp      Z,MINUS         ; Yes - Do minus
2167+ 212F FE 22                cp      $22             ; '"'             ; Literal string ?
2168+ 2131 CA 33 25             jp      Z,QTSTR         ; Get string terminated by '"'
2169+ 2134 FE BB                cp      ZNOT            ; "NOT" Token ?
2170+ 2136 CA 56 22             jp      Z,EVNOT         ; Yes - Eval NOT expression
2171+ 2139 FE B8                cp      ZFN             ; "FN" Token ?
2172+ 213B CA 97 24             jp      Z,DOFN          ; Yes - Do FN routine
2173+ 213E D6 CA                sub     ZSGN            ; Is it a function?
2174+ 2140 D2 6D 21             jp      NC,FNOFST       ; Yes - Evaluate function
2175+ 2143 CD 7A 20     EVLPAR: call    OPNPAR          ; Evaluate expression in "()"
2176+ 2146 CD A2 19             call    CHKSYN          ; Make sure ")" follows
2177+ 2149 29                   defb    ')'
2178+ 214A C9                   ret
2179+ 214B
2180+ 214B 16 7D        MINUS:  ld      D,$7D           ; '-' precedence
2181+ 214D CD 81 20             call    EVAL1           ; Evaluate until prec' break
2182+ 2150 2A B7 81             ld      HL,(NXTOPR)     ; Get next operator address
2183+ 2153 E5                   push    HL              ; Save next operator address
2184+ 2154 CD A2 2E             call    INVSGN          ; Negate value
2185+ 2157 CD 6F 20     RETNUM: call    TSTNUM          ; Make sure it's a number
2186+ 215A E1                   pop     HL              ; Restore next operator address
2187+ 215B C9                   ret
2188+ 215C
2189+ 215C CD 7B 22     CONVAR: call    GETVAR          ; Get variable address to DE
2190+ 215F E5           FRMEVL: push    HL              ; Save code string address
2191+ 2160 EB                   ex      DE,HL           ; Variable address to HL
2192+ 2161 22 32 82             ld      (FPREG),HL      ; Save address of variable
2193+ 2164 3A 94 81             ld      A,(TYPE)        ; Get type
2194+ 2167 B7                   or      A               ; Numeric?
2195+ 2168 CC B7 2E             call    Z,PHLTFP        ; Yes - Move contents to FPREG
2196+ 216B E1                   pop     HL              ; Restore code string address
2197+ 216C C9                   ret
2198+ 216D
2199+ 216D 06 00        FNOFST: ld      B,$00           ; Get address of function
2200+ 216F 07                   rlca                    ; Double function offset
2201+ 2170 4F                   ld      C,A             ; BC = Offset in function table
2202+ 2171 C5                   push    BC              ; Save adjusted token value
2203+ 2172 CD E3 1B             call    GETCHR          ; Get next character
2204+ 2175 79                   ld      A,C             ; Get adjusted token value
2205+ 2176 FE 2C                cp      2*(ZPOINT-ZSGN) ; "POINT" token?
2206+ 2178 CA A6 36             jp      Z,POINT         ; Yes, do "POINT"
2207+ 217B FE 2E                cp      2*(ZINSTR-ZSGN) ; "INSTR" token?
2208+ 217D CA 46 27             jp      Z,INSTR         ; Yes, do "INSTR"
2209+ 2180 FE 3D                cp      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
2210+ 2182 DA 9E 21             jp      C,FNVAL         ; No - Do function
2211+ 2185 CD 7A 20             call    OPNPAR          ; Evaluate expression  (X,...
2212+ 2188 CD A2 19             call    CHKSYN          ; Make sure ',' follows
2213+ 218B 2C                   defb    ','
2214+ 218C CD 70 20             call    TSTSTR          ; Make sure it's a string
2215+ 218F EB                   ex      DE,HL           ; Save code string address
2216+ 2190 2A 32 82             ld      HL,(FPREG)      ; Get address of string
2217+ 2193 E3                   ex      (SP),HL         ; Save address of string
2218+ 2194 E5                   push    HL              ; Save adjusted token value
2219+ 2195 EB                   ex      DE,HL           ; Restore code string address
2220+ 2196 CD F2 28             call    GETINT          ; Get integer 0-255
2221+ 2199 EB                   ex      DE,HL           ; Save code string address
2222+ 219A E3                   ex      (SP),HL         ; Save integer,HL = adj' token
2223+ 219B C3 A6 21             jp      GOFUNC          ; Jump to string function
2224+ 219E
2225+ 219E CD 43 21     FNVAL:  call    EVLPAR          ; Evaluate expression
2226+ 21A1 E3                   ex      (SP),HL         ; HL = Adjusted token value
2227+ 21A2 11 57 21             ld      DE,RETNUM       ; Return number from function
2228+ 21A5 D5                   push    DE              ; Save on stack
2229+ 21A6 01 FE 12     GOFUNC: ld      BC,FNCTAB       ; Function routine addresses
2230+ 21A9 09                   add     HL,BC           ; Point to right address
2231+ 21AA 4E                   ld      C,(HL)          ; Get LSB of address
2232+ 21AB 23                   inc     HL              ;
2233+ 21AC 66                   ld      H,(HL)          ; Get MSB of address
2234+ 21AD 69                   ld      L,C             ; Address to HL
2235+ 21AE E9                   jp      (HL)            ; Jump to function
2236+ 21AF
2237+ 21AF 15           SGNEXP: dec     D               ; Dee to flag negative exponent
2238+ 21B0 FE BE                cp      ZMINUS          ; '-' token ?
2239+ 21B2 C8                   ret     Z               ; Yes - Return
2240+ 21B3 FE 2D                cp      '-'             ; '-' ASCII ?
2241+ 21B5 C8                   ret     Z               ; Yes - Return
2242+ 21B6 14                   inc     D               ; Inc to flag positive exponent
2243+ 21B7 FE 2B                cp      '+'             ; '+' ASCII ?
2244+ 21B9 C8                   ret     Z               ; Yes - Return
2245+ 21BA FE BD                cp      ZPLUS           ; '+' token ?
2246+ 21BC C8                   ret     Z               ; Yes - Return
2247+ 21BD 2B                   dec     HL              ; dec 'cos GETCHR INCs
2248+ 21BE C9                   ret                     ; Return "NZ"
2249+ 21BF
2250+ 21BF              ; execute OR, AND, and XOR operations
2251+ 21BF AF           PAND:   xor     A               ; for AND, Z=1
2252+ 21C0 18 07                jr      CNTLGC
2253+ 21C2 AF           POR:    xor     A               ; for OR, Z=0, S=1
2254+ 21C3 D6 01                sub     $01
2255+ 21C5 18 02                jr      CNTLGC
2256+ 21C7 AF           PXOR:   xor     A               ; for XOR, Z=0, S=0
2257+ 21C8 3C                   inc     A
2258+ 21C9 F5           CNTLGC: push    AF              ; store operand's flags
2259+ 21CA CD 6F 20             call    TSTNUM          ; Make sure it's a number
2260+ 21CD CD 99 1C             call    DEINT           ; Get integer -32768 to 32767
2261+ 21D0 F1                   pop     AF              ; retrieve operand's flags
2262+ 21D1 EB                   ex      DE,HL           ; <- Get last
2263+ 21D2 C1                   pop     BC              ; <-  value
2264+ 21D3 E3                   ex      (SP),HL         ; <-  from
2265+ 21D4 EB                   ex      DE,HL           ; <-  stack
2266+ 21D5 CD BA 2E             call    FPBCDE          ; Move last value to FPREG
2267+ 21D8 F5                   push    AF              ; store operand's flags
2268+ 21D9 CD 99 1C             call    DEINT           ; Get integer -32768 to 32767
2269+ 21DC F1                   pop     AF              ; retrieve operand's flags
2270+ 21DD C1                   pop     BC              ; Get value
2271+ 21DE 79                   ld      A,C             ; Get LSB
2272+ 21DF 21 55 24             ld      HL,ACPASS       ; Address of save AC as current
2273+ 21E2 20 05                jr      NZ,POR1         ; if X/OR, jump over
2274+ 21E4 A3           PAND1:  and     E               ; "AND" LSBs
2275+ 21E5 4F                   ld      C,A             ; Save LSB
2276+ 21E6 78                   ld      A,B             ; Get MSB
2277+ 21E7 A2                   and     D               ; "AND" MSBs
2278+ 21E8 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2279+ 21E9 F2 F1 21     POR1:   jp      P,PXOR1         ; if S=0, jump to XOR
2280+ 21EC B3                   or      E               ; "OR" LSBs
2281+ 21ED 4F                   ld      C,A             ; Save LSB
2282+ 21EE 78                   ld      A,B             ; Get MSB
2283+ 21EF B2                   or      D               ; "OR" MSBs
2284+ 21F0 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2285+ 21F1 AB           PXOR1:  xor     E               ; "XOR" LSBs
2286+ 21F2 4F                   ld      C,A             ; Save LSB
2287+ 21F3 78                   ld      A,B             ; Get MSB
2288+ 21F4 AA                   xor     D               ; "XOR" MSBs
2289+ 21F5 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2290+ 21F6
2291+ 21F6 21 08 22     TSTRED: ld      HL,CMPLOG       ; Logical compare routine
2292+ 21F9 3A 94 81             ld      A,(TYPE)        ; Get data type
2293+ 21FC 1F                   rra                     ; Carry set = string
2294+ 21FD 7A                   ld      A,D             ; Get last precedence value
2295+ 21FE 17                   rla                     ; Times 2 plus carry
2296+ 21FF 5F                   ld      E,A             ; To E
2297+ 2200 16 64                ld      D,$64           ; Relational precedence
2298+ 2202 78                   ld      A,B             ; Get current precedence
2299+ 2203 BA                   cp      D               ; Compare with last
2300+ 2204 D0                   ret     NC              ; Eval if last was rel' or log'
2301+ 2205 C3 DE 20             jp      STKTHS          ; Stack this one and get next
2302+ 2208
2303+ 2208 0A 22        CMPLOG: defw    CMPLG1          ; Compare two values / strings
2304+ 220A 79           CMPLG1: ld      A,C             ; Get data type
2305+ 220B B7                   or      A
2306+ 220C 1F                   rra
2307+ 220D C1                   pop     BC              ; Get last expression to BCDE
2308+ 220E D1                   pop     DE
2309+ 220F F5                   push    AF              ; Save status
2310+ 2210 CD 71 20             call    CHKTYP          ; Check that types match
2311+ 2213 21 4C 22             ld      HL,CMPRES       ; Result to comparison
2312+ 2216 E5                   push    HL              ; Save for RETurn
2313+ 2217 CA F4 2E             jp      Z,CMPNUM        ; Compare values if numeric
2314+ 221A AF                   xor     A               ; Compare two strings
2315+ 221B 32 94 81             ld      (TYPE),A        ; Set type to numeric
2316+ 221E D5                   push    DE              ; Save string name
2317+ 221F CD B7 26             call    GSTRCU          ; Get current string
2318+ 2222 7E                   ld      A,(HL)          ; Get length of string
2319+ 2223 23                   inc     HL
2320+ 2224 23                   inc     HL
2321+ 2225 4E                   ld      C,(HL)          ; Get LSB of address
2322+ 2226 23                   inc     HL
2323+ 2227 46                   ld      B,(HL)          ; Get MSB of address
2324+ 2228 D1                   pop     DE              ; Restore string name
2325+ 2229 C5                   push    BC              ; Save address of string
2326+ 222A F5                   push    AF              ; Save length of string
2327+ 222B CD BB 26             call    GSTRDE          ; Get second string
2328+ 222E CD C8 2E             call    LOADFP          ; Get address of second string
2329+ 2231 F1                   pop     AF              ; Restore length of string 1
2330+ 2232 57                   ld      D,A             ; Length to D
2331+ 2233 E1                   pop     HL              ; Restore address of string 1
2332+ 2234 7B           CMPSTR: ld      A,E             ; Bytes of string 2 to do
2333+ 2235 B2                   or      D               ; Bytes of string 1 to do
2334+ 2236 C8                   ret     Z               ; Exit if all bytes compared
2335+ 2237 7A                   ld      A,D             ; Get bytes of string 1 to do
2336+ 2238 D6 01                sub     $01
2337+ 223A D8                   ret     C               ; Exit if end of string 1
2338+ 223B AF                   xor     A
2339+ 223C BB                   cp      E               ; Bytes of string 2 to do
2340+ 223D 3C                   inc     A
2341+ 223E D0                   ret     NC              ; Exit if end of string 2
2342+ 223F 15                   dec     D               ; Count bytes in string 1
2343+ 2240 1D                   dec     E               ; Count bytes in string 2
2344+ 2241 0A                   ld      A,(BC)          ; Byte in string 2
2345+ 2242 BE                   cp      (HL)            ; Compare to byte in string 1
2346+ 2243 23                   inc     HL              ; Move up string 1
2347+ 2244 03                   inc     BC              ; Move up string 2
2348+ 2245 CA 34 22             jp      Z,CMPSTR        ; Same - Try next bytes
2349+ 2248 3F                   ccf                     ; Flag difference (">" or "<")
2350+ 2249 C3 84 2E             jp      FLGDIF          ; "<" gives -1 , ">" gives +1
2351+ 224C
2352+ 224C 3C           CMPRES: inc     A               ; Increment current value
2353+ 224D 8F                   adc     A,A             ; Double plus carry
2354+ 224E C1                   pop     BC              ; Get other value
2355+ 224F A0                   and     B               ; Combine them
2356+ 2250 C6 FF                add     A,-1            ; Carry set if different
2357+ 2252 9F                   sbc     A,A             ; 00 - Equal , FF - Different
2358+ 2253 C3 8B 2E             jp      FLGREL          ; Set current value & continue
2359+ 2256
2360+ 2256 16 5A        EVNOT:  ld      D,$5A           ; Precedence value for "NOT"
2361+ 2258 CD 81 20             call    EVAL1           ; Eval until precedence break
2362+ 225B CD 6F 20             call    TSTNUM          ; Make sure it's a number
2363+ 225E CD 99 1C             call    DEINT           ; Get integer -32768 - 32767
2364+ 2261 7B                   ld      A,E             ; Get LSB
2365+ 2262 2F                   cpl                     ; Invert LSB
2366+ 2263 4F                   ld      C,A             ; Save "NOT" of LSB
2367+ 2264 7A                   ld      A,D             ; Get MSB
2368+ 2265 2F                   cpl                     ; Invert MSB
2369+ 2266 CD 55 24             call    ACPASS          ; Save AC as current
2370+ 2269 C1                   pop     BC              ; Clean up stack
2371+ 226A C3 8D 20             jp      EVAL3           ; Continue evaluation
2372+ 226D
2373+ 226D 2B           DIMRET: dec     HL              ; dec 'cos GETCHR INCs
2374+ 226E CD E3 1B             call    GETCHR          ; Get next character
2375+ 2271 C8                   ret     Z               ; End of DIM statement
2376+ 2272 CD A2 19             call    CHKSYN          ; Make sure ',' follows
2377+ 2275 2C                   defb    ','
2378+ 2276 01 6D 22     DIM:    ld      BC,DIMRET       ; Return to "DIMRET"
2379+ 2279 C5                   push    BC              ; Save on stack
2380+ 227A F6                   defb    $F6             ; Flag "Create" variable
2381+ 227B AF           GETVAR: xor     A               ; Find variable address,to DE
2382+ 227C 32 93 81             ld      (LCRFLG),A      ; Set locate / create flag
2383+ 227F 46                   ld      B,(HL)          ; Get First byte of name
2384+ 2280 CD 85 1C     GTFNAM: call    CHKLTR          ; See if a letter
2385+ 2283 DA C0 16             jp      C,SNERR         ; ?SN Error if not a letter
2386+ 2286 AF                   xor     A
2387+ 2287 4F                   ld      C,A             ; Clear second byte of name
2388+ 2288 32 94 81             ld      (TYPE),A        ; Set type to numeric
2389+ 228B CD E3 1B             call    GETCHR          ; Get next character
2390+ 228E DA 97 22             jp      C,SVNAM2        ; Numeric - Save in name
2391+ 2291 CD 85 1C             call    CHKLTR          ; See if a letter
2392+ 2294 DA A4 22             jp      C,CHARTY        ; Not a letter - Check type
2393+ 2297 4F           SVNAM2: ld      C,A             ; Save second byte of name
2394+ 2298 CD E3 1B     ENDNAM: call    GETCHR          ; Get next character
2395+ 229B DA 98 22             jp      C,ENDNAM        ; Numeric - Get another
2396+ 229E CD 85 1C             call    CHKLTR          ; See if a letter
2397+ 22A1 D2 98 22             jp      NC,ENDNAM       ; Letter - Get another
2398+ 22A4 D6 24        CHARTY: sub     '$'             ; String variable?
2399+ 22A6 C2 B3 22             jp      NZ,NOTSTR       ; No - Numeric variable
2400+ 22A9 3C                   inc     A               ; A = 1 (string type)
2401+ 22AA 32 94 81             ld      (TYPE),A        ; Set type to string
2402+ 22AD 0F                   rrca                    ; A = 80H , Flag for string
2403+ 22AE 81                   add     A,C             ; 2nd byte of name has bit 7 on
2404+ 22AF 4F                   ld      C,A             ; Resave second byte on name
2405+ 22B0 CD E3 1B             call    GETCHR          ; Get next character
2406+ 22B3 3A B2 81     NOTSTR: ld      A,(FORFLG)      ; Array name needed ?
2407+ 22B6 3D                   dec     A
2408+ 22B7 CA 60 23             jp      Z,ARLDSV        ; Yes - Get array name
2409+ 22BA F2 C3 22             jp      P,NSCFOR        ; No array with "FOR" or "FN"
2410+ 22BD 7E                   ld      A,(HL)          ; Get byte again
2411+ 22BE D6 28                sub     '('             ; Subscripted variable?
2412+ 22C0 CA 38 23             jp      Z,SBSCPT        ; Yes - Sort out subscript
2413+ 22C3
2414+ 22C3 AF           NSCFOR: xor     A               ; Simple variable
2415+ 22C4 32 B2 81             ld      (FORFLG),A      ; Clear "FOR" flag
2416+ 22C7 E5                   push    HL              ; Save code string address
2417+ 22C8 50                   ld      D,B             ; DE = Variable name to find
2418+ 22C9 59                   ld      E,C
2419+ 22CA 2A 2C 82             ld      HL,(FNRGNM)     ; FN argument name
2420+ 22CD CD 9C 19             call    CPDEHL          ; Is it the FN argument?
2421+ 22D0 11 2E 82             ld      DE,FNARG        ; Point to argument value
2422+ 22D3 CA 69 2D             jp      Z,POPHRT        ; Yes - Return FN argument value
2423+ 22D6 2A 26 82             ld      HL,(VAREND)     ; End of variables
2424+ 22D9 EB                   ex      DE,HL           ; Address of end of search
2425+ 22DA 2A 24 82             ld      HL,(PROGND)     ; Start of variables address
2426+ 22DD CD 9C 19     FNDVAR: call    CPDEHL          ; End of variable list table?
2427+ 22E0 CA F6 22             jp      Z,CFEVAL        ; Yes - Called from EVAL?
2428+ 22E3 79                   ld      A,C             ; Get second byte of name
2429+ 22E4 96                   sub     (HL)            ; Compare with name in list
2430+ 22E5 23                   inc     HL              ; Move on to first byte
2431+ 22E6 C2 EB 22             jp      NZ,FNTHR        ; Different - Find another
2432+ 22E9 78                   ld      A,B             ; Get first byte of name
2433+ 22EA 96                   sub     (HL)            ; Compare with name in list
2434+ 22EB 23           FNTHR:  inc     HL              ; Move on to LSB of value
2435+ 22EC CA 2A 23             jp      Z,RETADR        ; Found - Return address
2436+ 22EF 23                   inc     HL              ; <- Skip
2437+ 22F0 23                   inc     HL              ; <- over
2438+ 22F1 23                   inc     HL              ; <- F.P.
2439+ 22F2 23                   inc     HL              ; <- value
2440+ 22F3 C3 DD 22             jp      FNDVAR          ; Keep looking
2441+ 22F6
2442+ 22F6 E1           CFEVAL: pop     HL              ; Restore code string address
2443+ 22F7 E3                   ex      (SP),HL         ; Get return address
2444+ 22F8 D5                   push    DE              ; Save address of variable
2445+ 22F9 11 5F 21             ld      DE,FRMEVL       ; Return address in EVAL
2446+ 22FC CD 9C 19             call    CPDEHL          ; Called from EVAL ?
2447+ 22FF D1                   pop     DE              ; Restore address of variable
2448+ 2300 CA 2D 23             jp      Z,RETNUL        ; Yes - Return null variable
2449+ 2303 E3                   ex      (SP),HL         ; Put back return
2450+ 2304 E5                   push    HL              ; Save code string address
2451+ 2305 C5                   push    BC              ; Save variable name
2452+ 2306 01 06 00             ld      BC,$0006        ; 2 byte name plus 4 byte data
2453+ 2309 2A 28 82             ld      HL,(ARREND)     ; End of arrays
2454+ 230C E5                   push    HL              ; Save end of arrays
2455+ 230D 09                   add     HL,BC           ; Move up 6 bytes
2456+ 230E C1                   pop     BC              ; Source address in BC
2457+ 230F E5                   push    HL              ; Save new end address
2458+ 2310 CD 6C 16             call    MOVUP           ; Move arrays up
2459+ 2313 E1                   pop     HL              ; Restore new end address
2460+ 2314 22 28 82             ld      (ARREND),HL     ; Set new end address
2461+ 2317 60                   ld      H,B             ; End of variables to HL
2462+ 2318 69                   ld      L,C
2463+ 2319 22 26 82             ld      (VAREND),HL     ; Set new end address
2464+ 231C
2465+ 231C 2B           ZEROLP: dec     HL              ; Back through to zero variable
2466+ 231D 36 00                ld      (HL),$00        ; Zero byte in variable
2467+ 231F CD 9C 19             call    CPDEHL          ; Done them all?
2468+ 2322 C2 1C 23             jp      NZ,ZEROLP       ; No - Keep on going
2469+ 2325 D1                   pop     DE              ; Get variable name
2470+ 2326 73                   ld      (HL),E          ; Store second character
2471+ 2327 23                   inc     HL
2472+ 2328 72                   ld      (HL),D          ; Store first character
2473+ 2329 23                   inc     HL
2474+ 232A EB           RETADR: ex      DE,HL           ; Address of variable in DE
2475+ 232B E1                   pop     HL              ; Restore code string address
2476+ 232C C9                   ret
2477+ 232D
2478+ 232D 32 35 82     RETNUL: ld      (FPEXP),A       ; Set result to zero
2479+ 2330 21 3D 16             ld      HL,ZERBYT       ; Also set a null string
2480+ 2333 22 32 82             ld      (FPREG),HL      ; Save for EVAL
2481+ 2336 E1                   pop     HL              ; Restore code string address
2482+ 2337 C9                   ret
2483+ 2338
2484+ 2338 E5           SBSCPT: push    HL              ; Save code string address
2485+ 2339 2A 93 81             ld      HL,(LCRFLG)     ; Locate/Create and Type
2486+ 233C E3                   ex      (SP),HL         ; Save and get code string
2487+ 233D 57                   ld      D,A             ; Zero number of dimensions
2488+ 233E D5           SCPTLP: push    DE              ; Save number of dimensions
2489+ 233F C5                   push    BC              ; Save array name
2490+ 2340 CD 8D 1C             call    FPSINT          ; Get subscript (0-32767)
2491+ 2343 C1                   pop     BC              ; Restore array name
2492+ 2344 F1                   pop     AF              ; Get number of dimensions
2493+ 2345 EB                   ex      DE,HL
2494+ 2346 E3                   ex      (SP),HL         ; Save subscript value
2495+ 2347 E5                   push    HL              ; Save LCRFLG and TYPE
2496+ 2348 EB                   ex      DE,HL
2497+ 2349 3C                   inc     A               ; Count dimensions
2498+ 234A 57                   ld      D,A             ; Save in D
2499+ 234B 7E                   ld      A,(HL)          ; Get next byte in code string
2500+ 234C FE 2C                cp      ','             ; Comma (more to come)?
2501+ 234E CA 3E 23             jp      Z,SCPTLP        ; Yes - More subscripts
2502+ 2351 CD A2 19             call    CHKSYN          ; Make sure ")" follows
2503+ 2354 29                   defb    ')'
2504+ 2355 22 B7 81             ld      (NXTOPR),HL     ; Save code string address
2505+ 2358 E1                   pop     HL              ; Get LCRFLG and TYPE
2506+ 2359 22 93 81             ld      (LCRFLG),HL     ; Restore Locate/create & type
2507+ 235C 1E 00                ld      E,$00           ; Flag not CSAVE* or CLOAD*
2508+ 235E D5                   push    DE              ; Save number of dimensions (D)
2509+ 235F 11                   defb    $11             ; Skip "push HL" and "push AF'
2510+ 2360
2511+ 2360 E5           ARLDSV: push    HL              ; Save code string address
2512+ 2361 F5                   push    AF              ; A = 00 , Flags set = Z,N
2513+ 2362 2A 26 82             ld      HL,(VAREND)     ; Start of arrays
2514+ 2365 3E                   defb    $3E             ; Skip "add HL,DE"
2515+ 2366 19           FNDARY: add     HL,DE           ; Move to next array start
2516+ 2367 EB                   ex      DE,HL
2517+ 2368 2A 28 82             ld      HL,(ARREND)     ; End of arrays
2518+ 236B EB                   ex      DE,HL           ; Current array pointer
2519+ 236C CD 9C 19             call    CPDEHL          ; End of arrays found?
2520+ 236F CA 98 23             jp      Z,CREARY        ; Yes - Create array
2521+ 2372 7E                   ld      A,(HL)          ; Get second byte of name
2522+ 2373 B9                   cp      C               ; Compare with name given
2523+ 2374 23                   inc     HL              ; Move on
2524+ 2375 C2 7A 23             jp      NZ,NXTARY       ; Different - Find next array
2525+ 2378 7E                   ld      A,(HL)          ; Get first byte of name
2526+ 2379 B8                   cp      B               ; Compare with name given
2527+ 237A 23           NXTARY: inc     HL              ; Move on
2528+ 237B 5E                   ld      E,(HL)          ; Get LSB of next array address
2529+ 237C 23                   inc     HL
2530+ 237D 56                   ld      D,(HL)          ; Get MSB of next array address
2531+ 237E 23                   inc     HL
2532+ 237F C2 66 23             jp      NZ,FNDARY       ; Not found - Keep looking
2533+ 2382 3A 93 81             ld      A,(LCRFLG)      ; Found Locate or Create it?
2534+ 2385 B7                   or      A
2535+ 2386 C2 C9 16             jp      NZ,DDERR        ; Create - ?DD Error
2536+ 2389 F1                   pop     AF              ; Locate - Get number of dim'ns
2537+ 238A 44                   ld      B,H             ; BC Points to array dim'ns
2538+ 238B 4D                   ld      C,L
2539+ 238C CA 69 2D             jp      Z,POPHRT        ; Jump if array load/save
2540+ 238F 96                   sub     (HL)            ; Same number of dimensions?
2541+ 2390 CA F6 23             jp      Z,FINDEL        ; Yes - Find element
2542+ 2393 1E 10        BSERR:  ld      E,BS            ; ?BS Error
2543+ 2395 C3 D4 16             jp      ERROR           ; Output error
2544+ 2398
2545+ 2398 11 04 00     CREARY: ld      DE,$0004        ; 4 Bytes per entry
2546+ 239B F1                   pop     AF              ; Array to save or 0 dim'ns?
2547+ 239C CA AE 1C             jp      Z,FCERR         ; Yes - ?FC Error
2548+ 239F 71                   ld      (HL),C          ; Save second byte of name
2549+ 23A0 23                   inc     HL
2550+ 23A1 70                   ld      (HL),B          ; Save first byte of name
2551+ 23A2 23                   inc     HL
2552+ 23A3 4F                   ld      C,A             ; Number of dimensions to C
2553+ 23A4 CD 7D 16             call    CHKSTK          ; Check if enough memory
2554+ 23A7 23                   inc     HL              ; Point to number of dimensions
2555+ 23A8 23                   inc     HL
2556+ 23A9 22 AC 81             ld      (CUROPR),HL     ; Save address of pointer
2557+ 23AC 71                   ld      (HL),C          ; Set number of dimensions
2558+ 23AD 23                   inc     HL
2559+ 23AE 3A 93 81             ld      A,(LCRFLG)      ; Locate of Create?
2560+ 23B1 17                   rla                     ; Carry set = Create
2561+ 23B2 79                   ld      A,C             ; Get number of dimensions
2562+ 23B3 01 0B 00     CRARLP: ld      BC,10+1         ; Default dimension size 10
2563+ 23B6 D2 BB 23             jp      NC,DEFSIZ       ; Locate - Set default size
2564+ 23B9 C1                   pop     BC              ; Get specified dimension size
2565+ 23BA 03                   inc     BC              ; Include zero element
2566+ 23BB 71           DEFSIZ: ld      (HL),C          ; Save LSB of dimension size
2567+ 23BC 23                   inc     HL
2568+ 23BD 70                   ld      (HL),B          ; Save MSB of dimension size
2569+ 23BE 23                   inc     HL
2570+ 23BF F5                   push    AF              ; Save num' of dim'ns an status
2571+ 23C0 E5                   push    HL              ; Save address of dim'n size
2572+ 23C1 CD 65 2F             call    MLDEBC          ; Multiply DE by BC to find
2573+ 23C4 EB                   ex      DE,HL           ; amount of mem needed (to DE)
2574+ 23C5 E1                   pop     HL              ; Restore address of dimension
2575+ 23C6 F1                   pop     AF              ; Restore number of dimensions
2576+ 23C7 3D                   dec     A               ; Count them
2577+ 23C8 C2 B3 23             jp      NZ,CRARLP       ; Do next dimension if more
2578+ 23CB F5                   push    AF              ; Save locate/create flag
2579+ 23CC 42                   ld      B,D             ; MSB of memory needed
2580+ 23CD 4B                   ld      C,E             ; LSB of memory needed
2581+ 23CE EB                   ex      DE,HL
2582+ 23CF 19                   add     HL,DE           ; Add bytes to array start
2583+ 23D0 DA 95 16             jp      C,OMERR         ; Too big - Error
2584+ 23D3 CD 86 16             call    ENFMEM          ; See if enough memory
2585+ 23D6 22 28 82             ld      (ARREND),HL     ; Save new end of array
2586+ 23D9
2587+ 23D9 2B           ZERARY: dec     HL              ; Back through array data
2588+ 23DA 36 00                ld      (HL),$00        ; Set array element to zero
2589+ 23DC CD 9C 19             call    CPDEHL          ; All elements zeroed?
2590+ 23DF C2 D9 23             jp      NZ,ZERARY       ; No - Keep on going
2591+ 23E2 03                   inc     BC              ; Number of bytes + 1
2592+ 23E3 57                   ld      D,A             ; A=0
2593+ 23E4 2A AC 81             ld      HL,(CUROPR)     ; Get address of array
2594+ 23E7 5E                   ld      E,(HL)          ; Number of dimensions
2595+ 23E8 EB                   ex      DE,HL           ; To HL
2596+ 23E9 29                   add     HL,HL           ; Two bytes per dimension size
2597+ 23EA 09                   add     HL,BC           ; Add number of bytes
2598+ 23EB EB                   ex      DE,HL           ; Bytes needed to DE
2599+ 23EC 2B                   dec     HL
2600+ 23ED 2B                   dec     HL
2601+ 23EE 73                   ld      (HL),E          ; Save LSB of bytes needed
2602+ 23EF 23                   inc     HL
2603+ 23F0 72                   ld      (HL),D          ; Save MSB of bytes needed
2604+ 23F1 23                   inc     HL
2605+ 23F2 F1                   pop     AF              ; Locate / Create?
2606+ 23F3 DA 1A 24             jp      C,ENDDIM        ; A is 0 , End if create
2607+ 23F6 47           FINDEL: ld      B,A             ; Find array element
2608+ 23F7 4F                   ld      C,A
2609+ 23F8 7E                   ld      A,(HL)          ; Number of dimensions
2610+ 23F9 23                   inc     HL
2611+ 23FA 16                   defb    $16             ; Skip "pop HL"
2612+ 23FB E1           FNDELP: pop     HL              ; Address of next dim' size
2613+ 23FC 5E                   ld      E,(HL)          ; Get LSB of dim'n size
2614+ 23FD 23                   inc     HL
2615+ 23FE 56                   ld      D,(HL)          ; Get MSB of dim'n size
2616+ 23FF 23                   inc     HL
2617+ 2400 E3                   ex      (SP),HL         ; Save address - Get index
2618+ 2401 F5                   push    AF              ; Save number of dim'ns
2619+ 2402 CD 9C 19             call    CPDEHL          ; Dimension too large?
2620+ 2405 D2 93 23             jp      NC,BSERR        ; Yes - ?BS Error
2621+ 2408 E5                   push    HL              ; Save index
2622+ 2409 CD 65 2F             call    MLDEBC          ; Multiply previous by size
2623+ 240C D1                   pop     DE              ; Index supplied to DE
2624+ 240D 19                   add     HL,DE           ; Add index to pointer
2625+ 240E F1                   pop     AF              ; Number of dimensions
2626+ 240F 3D                   dec     A               ; Count them
2627+ 2410 44                   ld      B,H             ; MSB of pointer
2628+ 2411 4D                   ld      C,L             ; LSB of pointer
2629+ 2412 C2 FB 23             jp      NZ,FNDELP       ; More - Keep going
2630+ 2415 29                   add     HL,HL           ; 4 Bytes per element
2631+ 2416 29                   add     HL,HL
2632+ 2417 C1                   pop     BC              ; Start of array
2633+ 2418 09                   add     HL,BC           ; Point to element
2634+ 2419 EB                   ex      DE,HL           ; Address of element to DE
2635+ 241A 2A B7 81     ENDDIM: ld      HL,(NXTOPR)     ; Got code string address
2636+ 241D C9                   ret
2637+ 241E
2638+ 241E
2639+ 241E              ; returns the value of the 32-bit system tick counter as
2640+ 241E              ; two 16-bit words
2641+ 241E CD 6F 20     TMR:    call    TSTNUM          ; Make sure it's a number
2642+ 2421 CD 99 1C             call    DEINT           ; Get integer (-32768 to 32767)
2643+ 2424 2A BD 81             ld      HL,(TMRCNT)     ; load the LSBytes of timer
2644+ 2427 7B                   ld      A,E
2645+ 2428 B2                   or      D               ; is it 0?
2646+ 2429 CA 2F 24             jp      Z,ENDTMR        ; yes, jump over
2647+ 242C 2A BF 81             ld      HL,(TMRCNT+2)   ; load the MSBytes of timer
2648+ 242F 45           ENDTMR: ld      B,L             ; move bytes...
2649+ 2430 7C                   ld      A,H             ; ...into AB
2650+ 2431 C3 56 24             jp      ABPASS          ; return word into AB
2651+ 2434
2652+ 2434
2653+ 2434              ; returns the free space for BASIC or into the string pool
2654+ 2434 2A 28 82     FRE:    ld      HL,(ARREND)     ; Start of free memory
2655+ 2437 EB                   ex      DE,HL           ; To DE
2656+ 2438 21 00 00             ld      HL,$0000        ; End of free memory
2657+ 243B 39                   add     HL,SP           ; Current stack value
2658+ 243C 3A 94 81             ld      A,(TYPE)        ; Dummy argument type
2659+ 243F B7                   or      A
2660+ 2440 CA 50 24             jp      Z,FRENUM        ; Numeric - Free variable space
2661+ 2443 CD B7 26             call    GSTRCU          ; Current string to pool
2662+ 2446 CD B7 25             call    GARBGE          ; Garbage collection
2663+ 2449 2A AD 80             ld      HL,(STRSPC)     ; Bottom of string space in use
2664+ 244C EB                   ex      DE,HL           ; To DE
2665+ 244D 2A AA 81             ld      HL,(STRBOT)     ; Bottom of string space
2666+ 2450 7D           FRENUM: ld      A,L             ; Get LSB of end
2667+ 2451 93                   sub     E               ; Subtract LSB of beginning
2668+ 2452 4F                   ld      C,A             ; Save difference if C
2669+ 2453 7C                   ld      A,H             ; Get MSB of end
2670+ 2454 9A                   sbc     A,D             ; Subtract MSB of beginning
2671+ 2455 41           ACPASS: ld      B,C             ; Return integer AC
2672+ 2456 50           ABPASS: ld      D,B             ; Return integer AB
2673+ 2457 1E 00                ld      E,$00
2674+ 2459 21 94 81             ld      HL,TYPE         ; Point to type
2675+ 245C 73                   ld      (HL),E          ; Set type to numeric
2676+ 245D 06 90                ld      B,$80+$10       ; 16 bit integer
2677+ 245F C3 90 2E             jp      RETINT          ; Return the integer
2678+ 2462
2679+ 2462              ; returns the X position of the cursor during a print
2680+ 2462 3A 92 81     POS:    ld      A,(CURPOS)      ; Get cursor position
2681+ 2465 47           PASSA:  ld      B,A             ; Put A into AB
2682+ 2466 AF                   xor     A               ; Zero A
2683+ 2467 C3 56 24             jp      ABPASS          ; Return integer AB
2684+ 246A
2685+ 246A CD ED 24     DEF:    call    CHEKFN          ; Get "FN" and name
2686+ 246D CD DF 24             call    IDTEST          ; Test for illegal direct
2687+ 2470 01 8C 1D             ld      BC,DATA         ; To get next statement
2688+ 2473 C5                   push    BC              ; Save address for RETurn
2689+ 2474 D5                   push    DE              ; Save address of function ptr
2690+ 2475 CD A2 19             call    CHKSYN          ; Make sure "(" follows
2691+ 2478 28                   defb    '('
2692+ 2479 CD 7B 22             call    GETVAR          ; Get argument variable name
2693+ 247C E5                   push    HL              ; Save code string address
2694+ 247D EB                   ex      DE,HL           ; Argument address to HL
2695+ 247E 2B                   dec     HL
2696+ 247F 56                   ld      D,(HL)          ; Get first byte of arg name
2697+ 2480 2B                   dec     HL
2698+ 2481 5E                   ld      E,(HL)          ; Get second byte of arg name
2699+ 2482 E1                   pop     HL              ; Restore code string address
2700+ 2483 CD 6F 20             call    TSTNUM          ; Make sure numeric argument
2701+ 2486 CD A2 19             call    CHKSYN          ; Make sure ")" follows
2702+ 2489 29                   defb    ')'
2703+ 248A CD A2 19             call    CHKSYN          ; Make sure "=" follows
2704+ 248D C8                   defb    ZEQUAL          ; "=" token
2705+ 248E 44                   ld      B,H             ; Code string address to BC
2706+ 248F 4D                   ld      C,L
2707+ 2490 E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2708+ 2491 71                   ld      (HL),C          ; Save LSB of FN code string
2709+ 2492 23                   inc     HL
2710+ 2493 70                   ld      (HL),B          ; Save MSB of FN code string
2711+ 2494 C3 2C 25             jp      SVSTAD          ; Save address and do function
2712+ 2497
2713+ 2497 CD ED 24     DOFN:   call    CHEKFN          ; Make sure FN follows
2714+ 249A D5                   push    DE              ; Save function pointer address
2715+ 249B CD 43 21             call    EVLPAR          ; Evaluate expression in "()"
2716+ 249E CD 6F 20             call    TSTNUM          ; Make sure numeric result
2717+ 24A1 E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2718+ 24A2 5E                   ld      E,(HL)          ; Get LSB of FN code string
2719+ 24A3 23                   inc     HL
2720+ 24A4 56                   ld      D,(HL)          ; Get MSB of FN code string
2721+ 24A5 23                   inc     HL
2722+ 24A6 7A                   ld      A,D             ; And function DEFined?
2723+ 24A7 B3                   or      E
2724+ 24A8 CA CC 16             jp      Z,UFERR         ; No - ?UF Error
2725+ 24AB 7E                   ld      A,(HL)          ; Get LSB of argument address
2726+ 24AC 23                   inc     HL
2727+ 24AD 66                   ld      H,(HL)          ; Get MSB of argument address
2728+ 24AE 6F                   ld      L,A             ; HL = Arg variable address
2729+ 24AF E5                   push    HL              ; Save it
2730+ 24B0 2A 2C 82             ld      HL,(FNRGNM)     ; Get old argument name
2731+ 24B3 E3                   ex      (SP),HL         ; Save old , Get new
2732+ 24B4 22 2C 82             ld      (FNRGNM),HL     ; Set new argument name
2733+ 24B7 2A 30 82             ld      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2734+ 24BA E5                   push    HL              ; Save it
2735+ 24BB 2A 2E 82             ld      HL,(FNARG)      ; Get MSB,EXP of old arg value
2736+ 24BE E5                   push    HL              ; Save it
2737+ 24BF 21 2E 82             ld      HL,FNARG        ; HL = Value of argument
2738+ 24C2 D5                   push    DE              ; Save FN code string address
2739+ 24C3 CD D1 2E             call    FPTHL           ; Move FPREG to argument
2740+ 24C6 E1                   pop     HL              ; Get FN code string address
2741+ 24C7 CD 6C 20             call    GETNUM          ; Get value from function
2742+ 24CA 2B                   dec     HL              ; dec 'cos GETCHR INCs
2743+ 24CB CD E3 1B             call    GETCHR          ; Get next character
2744+ 24CE C2 C0 16             jp      NZ,SNERR        ; Bad character in FN - Error
2745+ 24D1 E1                   pop     HL              ; Get MSB,EXP of old arg
2746+ 24D2 22 2E 82             ld      (FNARG),HL      ; Restore it
2747+ 24D5 E1                   pop     HL              ; Get LSB,NLSB of old arg
2748+ 24D6 22 30 82             ld      (FNARG+2),HL    ; Restore it
2749+ 24D9 E1                   pop     HL              ; Get name of old arg
2750+ 24DA 22 2C 82             ld      (FNRGNM),HL     ; Restore it
2751+ 24DD E1                   pop     HL              ; Restore code string address
2752+ 24DE C9                   ret
2753+ 24DF
2754+ 24DF E5           IDTEST: push    HL              ; Save code string address
2755+ 24E0 2A AF 80             ld      HL,(LINEAT)     ; Get current line number
2756+ 24E3 23                   inc     HL              ; -1 means direct statement
2757+ 24E4 7C                   ld      A,H
2758+ 24E5 B5                   or      L
2759+ 24E6 E1                   pop     HL              ; Restore code string address
2760+ 24E7 C0                   ret     NZ              ; Return if in program
2761+ 24E8 1E 16                ld      E,ID            ; ?ID Error
2762+ 24EA C3 D4 16             jp      ERROR
2763+ 24ED
2764+ 24ED CD A2 19     CHEKFN: call    CHKSYN          ; Make sure FN follows
2765+ 24F0 B8                   defb    ZFN             ; "FN" token
2766+ 24F1 3E 80                ld      A,$80
2767+ 24F3 32 B2 81             ld      (FORFLG),A      ; Flag FN name to find
2768+ 24F6 B6                   or      (HL)            ; FN name has bit 7 set
2769+ 24F7 47                   ld      B,A             ; in first byte of name
2770+ 24F8 CD 80 22             call    GTFNAM          ; Get FN name
2771+ 24FB C3 6F 20             jp      TSTNUM          ; Make sure numeric function
2772+ 24FE
2773+ 24FE CD 6F 20     STR:    call    TSTNUM          ; Make sure it's a number
2774+ 2501 CD 1E 30             call    NUMASC          ; Turn number into text
2775+ 2504 CD 32 25     STR1:   call    CRTST           ; Create string entry for it
2776+ 2507 CD B7 26             call    GSTRCU          ; Current string to pool
2777+ 250A 01 12 27             ld      BC,TOPOOL       ; Save in string pool
2778+ 250D C5                   push    BC              ; Save address on stack
2779+ 250E
2780+ 250E 7E           SAVSTR: ld      A,(HL)          ; Get string length
2781+ 250F 23                   inc     HL
2782+ 2510 23                   inc     HL
2783+ 2511 E5                   push    HL              ; Save pointer to string
2784+ 2512 CD 8D 25             call    TESTR           ; See if enough string space
2785+ 2515 E1                   pop     HL              ; Restore pointer to string
2786+ 2516 4E                   ld      C,(HL)          ; Get LSB of address
2787+ 2517 23                   inc     HL
2788+ 2518 46                   ld      B,(HL)          ; Get MSB of address
2789+ 2519 CD 26 25             call    CRTMST          ; Create string entry
2790+ 251C E5                   push    HL              ; Save pointer to MSB of addr
2791+ 251D 6F                   ld      L,A             ; Length of string
2792+ 251E CD AA 26             call    TOSTRA          ; Move to string area
2793+ 2521 D1                   pop     DE              ; Restore pointer to MSB
2794+ 2522 C9                   ret
2795+ 2523
2796+ 2523 CD 8D 25     MKTMST: call    TESTR           ; See if enough string space
2797+ 2526 21 A6 81     CRTMST: ld      HL,TMPSTR       ; Temporary string
2798+ 2529 E5                   push    HL              ; Save it
2799+ 252A 77                   ld      (HL),A          ; Save length of string
2800+ 252B 23                   inc     HL
2801+ 252C 23           SVSTAD: inc     HL
2802+ 252D 73                   ld      (HL),E          ; Save LSB of address
2803+ 252E 23                   inc     HL
2804+ 252F 72                   ld      (HL),D          ; Save MSB of address
2805+ 2530 E1                   pop     HL              ; Restore pointer
2806+ 2531 C9                   ret
2807+ 2532
2808+ 2532 2B           CRTST:  dec     HL              ; dec - INCed after
2809+ 2533 06 22        QTSTR:  ld      B,$22           ; '"'           ; Terminating quote
2810+ 2535 50                   ld      D,B             ; Quote to D
2811+ 2536 E5           DTSTR:  push    HL              ; Save start
2812+ 2537 0E FF                ld      C,-1            ; Set counter to -1
2813+ 2539 23           QTSTLP: inc     HL              ; Move on
2814+ 253A 7E                   ld      A,(HL)          ; Get byte
2815+ 253B 0C                   inc     C               ; Count bytes
2816+ 253C B7                   or      A               ; End of line?
2817+ 253D CA 48 25             jp      Z,CRTSTE        ; Yes - Create string entry
2818+ 2540 BA                   cp      D               ; Terminator D found?
2819+ 2541 CA 48 25             jp      Z,CRTSTE        ; Yes - Create string entry
2820+ 2544 B8                   cp      B               ; Terminator B found?
2821+ 2545 C2 39 25             jp      NZ,QTSTLP       ; No - Keep looking
2822+ 2548 FE 22        CRTSTE: cp      $22             ; '"'             ; End with '"'?
2823+ 254A CC E3 1B             call    Z,GETCHR        ; Yes - Get next character
2824+ 254D E3                   ex      (SP),HL         ; Starting quote
2825+ 254E 23                   inc     HL              ; First byte of string
2826+ 254F EB                   ex      DE,HL           ; To DE
2827+ 2550 79                   ld      A,C             ; Get length
2828+ 2551 CD 26 25             call    CRTMST          ; Create string entry
2829+ 2554 11 A6 81     TSTOPL: ld      DE,TMPSTR       ; Temporary string
2830+ 2557 2A 98 81             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2831+ 255A 22 32 82             ld      (FPREG),HL      ; Save address of string ptr
2832+ 255D 3E 01                ld      A,$01
2833+ 255F 32 94 81             ld      (TYPE),A        ; Set type to string
2834+ 2562 CD D4 2E             call    DETHL4          ; Move string to pool
2835+ 2565 CD 9C 19             call    CPDEHL          ; Out of string pool?
2836+ 2568 22 98 81             ld      (TMSTPT),HL     ; Save new pointer
2837+ 256B E1                   pop     HL              ; Restore code string address
2838+ 256C 7E                   ld      A,(HL)          ; Get next code byte
2839+ 256D C0                   ret     NZ              ; Return if pool OK
2840+ 256E 1E 1E                ld      E,ST            ; ?ST Error
2841+ 2570 C3 D4 16             jp      ERROR           ; String pool overflow
2842+ 2573
2843+ 2573 23           PRNUMS: inc     HL              ; Skip leading space
2844+ 2574 CD 32 25     PRS:    call    CRTST           ; Create string entry for it
2845+ 2577 CD B7 26     PRS1:   call    GSTRCU          ; Current string to pool
2846+ 257A CD C8 2E             call    LOADFP          ; Move string block to BCDE
2847+ 257D 1C                   inc     E               ; Length + 1
2848+ 257E 1D           PRSLP:  dec     E               ; Count characters
2849+ 257F C8                   ret     Z               ; End of string
2850+ 2580 0A                   ld      A,(BC)          ; Get byte to output
2851+ 2581 CD AD 19             call    OUTC            ; Output character in A
2852+ 2584 FE 0D                cp      CR              ; Return?
2853+ 2586 CC BA 1E             call    Z,CNTEND        ; Yes - Position cursor to 0
2854+ 2589 03                   inc     BC              ; Next byte in string
2855+ 258A C3 7E 25             jp      PRSLP           ; More characters to output
2856+ 258D
2857+ 258D B7           TESTR:  or      A               ; Test if enough room
2858+ 258E 0E                   defb    $0E             ; No garbage collection done
2859+ 258F F1           GRBDON: pop     AF              ; Garbage collection done
2860+ 2590 F5                   push    AF              ; Save status
2861+ 2591 2A AD 80             ld      HL,(STRSPC)     ; Bottom of string space in use
2862+ 2594 EB                   ex      DE,HL           ; To DE
2863+ 2595 2A AA 81             ld      HL,(STRBOT)     ; Bottom of string area
2864+ 2598 2F                   cpl                     ; Negate length (Top down)
2865+ 2599 4F                   ld      C,A             ; -Length to BC
2866+ 259A 06 FF                ld      B,-1            ; BC = -ve length of string
2867+ 259C 09                   add     HL,BC           ; Add to bottom of space in use
2868+ 259D 23                   inc     HL              ; Plus one for 2's complement
2869+ 259E CD 9C 19             call    CPDEHL          ; Below string RAM area?
2870+ 25A1 DA AB 25             jp      C,TESTOS        ; Tidy up if not done else err
2871+ 25A4 22 AA 81             ld      (STRBOT),HL     ; Save new bottom of area
2872+ 25A7 23                   inc     HL              ; Point to first byte of string
2873+ 25A8 EB                   ex      DE,HL           ; Address to DE
2874+ 25A9 F1           POPAF:  pop     AF              ; Throw away status push
2875+ 25AA C9                   ret
2876+ 25AB
2877+ 25AB F1           TESTOS: pop     AF              ; Garbage collect been done?
2878+ 25AC 1E 1A                ld      E,OS            ; ?OS Error
2879+ 25AE CA D4 16             jp      Z,ERROR         ; Yes - Not enough string space
2880+ 25B1 BF                   cp      A               ; Flag garbage collect done
2881+ 25B2 F5                   push    AF              ; Save status
2882+ 25B3 01 8F 25             ld      BC,GRBDON       ; Garbage collection done
2883+ 25B6 C5                   push    BC              ; Save for RETurn
2884+ 25B7 2A 96 81     GARBGE: ld      HL,(LSTRAM)     ; Get end of RAM pointer
2885+ 25BA 22 AA 81     GARBLP: ld      (STRBOT),HL     ; Reset string pointer
2886+ 25BD 21 00 00             ld      HL,$0000
2887+ 25C0 E5                   push    HL              ; Flag no string found
2888+ 25C1 2A AD 80             ld      HL,(STRSPC)     ; Get bottom of string space
2889+ 25C4 E5                   push    HL              ; Save bottom of string space
2890+ 25C5 21 9A 81             ld      HL,TMSTPL       ; Temporary string pool
2891+ 25C8 EB           GRBLP:  ex      DE,HL
2892+ 25C9 2A 98 81             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2893+ 25CC EB                   ex      DE,HL
2894+ 25CD CD 9C 19             call    CPDEHL          ; Temporary string pool done?
2895+ 25D0 01 C8 25             ld      BC,GRBLP        ; Loop until string pool done
2896+ 25D3 C2 1C 26             jp      NZ,STPOOL       ; No - See if in string area
2897+ 25D6 2A 24 82             ld      HL,(PROGND)     ; Start of simple variables
2898+ 25D9 EB           SMPVAR: ex      DE,HL
2899+ 25DA 2A 26 82             ld      HL,(VAREND)     ; End of simple variables
2900+ 25DD EB                   ex      DE,HL
2901+ 25DE CD 9C 19             call    CPDEHL          ; All simple strings done?
2902+ 25E1 CA EF 25             jp      Z,ARRLP         ; Yes - Do string arrays
2903+ 25E4 7E                   ld      A,(HL)          ; Get type of variable
2904+ 25E5 23                   inc     HL
2905+ 25E6 23                   inc     HL
2906+ 25E7 B7                   or      A               ; "S" flag set if string
2907+ 25E8 CD 1F 26             call    STRADD          ; See if string in string area
2908+ 25EB C3 D9 25             jp      SMPVAR          ; Loop until simple ones done
2909+ 25EE
2910+ 25EE C1           GNXARY: pop     BC              ; Scrap address of this array
2911+ 25EF EB           ARRLP:  ex      DE,HL
2912+ 25F0 2A 28 82             ld      HL,(ARREND)     ; End of string arrays
2913+ 25F3 EB                   ex      DE,HL
2914+ 25F4 CD 9C 19             call    CPDEHL          ; All string arrays done?
2915+ 25F7 CA 45 26             jp      Z,SCNEND        ; Yes - Move string if found
2916+ 25FA CD C8 2E             call    LOADFP          ; Get array name to BCDE
2917+ 25FD 7B                   ld      A,E             ; Get type of array
2918+ 25FE E5                   push    HL              ; Save address of num of dim'ns
2919+ 25FF 09                   add     HL,BC           ; Start of next array
2920+ 2600 B7                   or      A               ; Test type of array
2921+ 2601 F2 EE 25             jp      P,GNXARY        ; Numeric array - Ignore it
2922+ 2604 22 AC 81             ld      (CUROPR),HL     ; Save address of next array
2923+ 2607 E1                   pop     HL              ; Get address of num of dim'ns
2924+ 2608 4E                   ld      C,(HL)          ; BC = Number of dimensions
2925+ 2609 06 00                ld      B,$00
2926+ 260B 09                   add     HL,BC           ; Two bytes per dimension size
2927+ 260C 09                   add     HL,BC
2928+ 260D 23                   inc     HL              ; Plus one for number of dim'ns
2929+ 260E EB           GRBARY: ex      DE,HL
2930+ 260F 2A AC 81             ld      HL,(CUROPR)     ; Get address of next array
2931+ 2612 EB                   ex      DE,HL
2932+ 2613 CD 9C 19             call    CPDEHL          ; Is this array finished?
2933+ 2616 CA EF 25             jp      Z,ARRLP         ; Yes - Get next one
2934+ 2619 01 0E 26             ld      BC,GRBARY       ; Loop until array all done
2935+ 261C C5           STPOOL: push    BC              ; Save return address
2936+ 261D F6 80                or      $80             ; Flag string type
2937+ 261F 7E           STRADD: ld      A,(HL)          ; Get string length
2938+ 2620 23                   inc     HL
2939+ 2621 23                   inc     HL
2940+ 2622 5E                   ld      E,(HL)          ; Get LSB of string address
2941+ 2623 23                   inc     HL
2942+ 2624 56                   ld      D,(HL)          ; Get MSB of string address
2943+ 2625 23                   inc     HL
2944+ 2626 F0                   ret     P               ; Not a string - Return
2945+ 2627 B7                   or      A               ; Set flags on string length
2946+ 2628 C8                   ret     Z               ; Null string - Return
2947+ 2629 44                   ld      B,H             ; Save variable pointer
2948+ 262A 4D                   ld      C,L
2949+ 262B 2A AA 81             ld      HL,(STRBOT)     ; Bottom of new area
2950+ 262E CD 9C 19             call    CPDEHL          ; String been done?
2951+ 2631 60                   ld      H,B             ; Restore variable pointer
2952+ 2632 69                   ld      L,C
2953+ 2633 D8                   ret     C               ; String done - Ignore
2954+ 2634 E1                   pop     HL              ; Return address
2955+ 2635 E3                   ex      (SP),HL         ; Lowest available string area
2956+ 2636 CD 9C 19             call    CPDEHL          ; String within string area?
2957+ 2639 E3                   ex      (SP),HL         ; Lowest available string area
2958+ 263A E5                   push    HL              ; Re-save return address
2959+ 263B 60                   ld      H,B             ; Restore variable pointer
2960+ 263C 69                   ld      L,C
2961+ 263D D0                   ret     NC              ; Outside string area - Ignore
2962+ 263E C1                   pop     BC              ; Get return , Throw 2 away
2963+ 263F F1                   pop     AF              ;
2964+ 2640 F1                   pop     AF              ;
2965+ 2641 E5                   push    HL              ; Save variable pointer
2966+ 2642 D5                   push    DE              ; Save address of current
2967+ 2643 C5                   push    BC              ; Put back return address
2968+ 2644 C9                   ret                     ; Go to it
2969+ 2645
2970+ 2645 D1           SCNEND: pop     DE              ; Addresses of strings
2971+ 2646 E1                   pop     HL              ;
2972+ 2647 7D                   ld      A,L             ; HL = 0 if no more to do
2973+ 2648 B4                   or      H
2974+ 2649 C8                   ret     Z               ; No more to do - Return
2975+ 264A 2B                   dec     HL
2976+ 264B 46                   ld      B,(HL)          ; MSB of address of string
2977+ 264C 2B                   dec     HL
2978+ 264D 4E                   ld      C,(HL)          ; LSB of address of string
2979+ 264E E5                   push    HL              ; Save variable address
2980+ 264F 2B                   dec     HL
2981+ 2650 2B                   dec     HL
2982+ 2651 6E                   ld      L,(HL)          ; HL = Length of string
2983+ 2652 26 00                ld      H,$00
2984+ 2654 09                   add     HL,BC           ; Address of end of string+1
2985+ 2655 50                   ld      D,B             ; String address to DE
2986+ 2656 59                   ld      E,C
2987+ 2657 2B                   dec     HL              ; Last byte in string
2988+ 2658 44                   ld      B,H             ; Address to BC
2989+ 2659 4D                   ld      C,L
2990+ 265A 2A AA 81             ld      HL,(STRBOT)     ; Current bottom of string area
2991+ 265D CD 6F 16             call    MOVSTR          ; Move string to new address
2992+ 2660 E1                   pop     HL              ; Restore variable address
2993+ 2661 71                   ld      (HL),C          ; Save new LSB of address
2994+ 2662 23                   inc     HL
2995+ 2663 70                   ld      (HL),B          ; Save new MSB of address
2996+ 2664 69                   ld      L,C             ; Next string area+1 to HL
2997+ 2665 60                   ld      H,B
2998+ 2666 2B                   dec     HL              ; Next string area address
2999+ 2667 C3 BA 25             jp      GARBLP          ; Look for more strings
3000+ 266A
3001+ 266A C5           CONCAT: push    BC              ; Save prec' opr & code string
3002+ 266B E5                   push    HL              ;
3003+ 266C 2A 32 82             ld      HL,(FPREG)      ; Get first string
3004+ 266F E3                   ex      (SP),HL         ; Save first string
3005+ 2670 CD F5 20             call    OPRND           ; Get second string
3006+ 2673 E3                   ex      (SP),HL         ; Restore first string
3007+ 2674 CD 70 20             call    TSTSTR          ; Make sure it's a string
3008+ 2677 7E                   ld      A,(HL)          ; Get length of second string
3009+ 2678 E5                   push    HL              ; Save first string
3010+ 2679 2A 32 82             ld      HL,(FPREG)      ; Get second string
3011+ 267C E5                   push    HL              ; Save second string
3012+ 267D 86                   add     A,(HL)          ; Add length of second string
3013+ 267E 1E 1C                ld      E,LS            ; ?LS Error
3014+ 2680 DA D4 16             jp      C,ERROR         ; String too long - Error
3015+ 2683 CD 23 25             call    MKTMST          ; Make temporary string
3016+ 2686 D1                   pop     DE              ; Get second string to DE
3017+ 2687 CD BB 26             call    GSTRDE          ; Move to string pool if needed
3018+ 268A E3                   ex      (SP),HL         ; Get first string
3019+ 268B CD BA 26             call    GSTRHL          ; Move to string pool if needed
3020+ 268E E5                   push    HL              ; Save first string
3021+ 268F 2A A8 81             ld      HL,(TMPSTR+2)   ; Temporary string address
3022+ 2692 EB                   ex      DE,HL           ; To DE
3023+ 2693 CD A1 26             call    SSTSA           ; First string to string area
3024+ 2696 CD A1 26             call    SSTSA           ; Second string to string area
3025+ 2699 21 8A 20             ld      HL,EVAL2        ; Return to evaluation loop
3026+ 269C E3                   ex      (SP),HL         ; Save return,get code string
3027+ 269D E5                   push    HL              ; Save code string address
3028+ 269E C3 54 25             jp      TSTOPL          ; To temporary string to pool
3029+ 26A1
3030+ 26A1 E1           SSTSA:  pop     HL              ; Return address
3031+ 26A2 E3                   ex      (SP),HL         ; Get string block,save return
3032+ 26A3 7E                   ld      A,(HL)          ; Get length of string
3033+ 26A4 23                   inc     HL
3034+ 26A5 23                   inc     HL
3035+ 26A6 4E                   ld      C,(HL)          ; Get LSB of string address
3036+ 26A7 23                   inc     HL
3037+ 26A8 46                   ld      B,(HL)          ; Get MSB of string address
3038+ 26A9 6F                   ld      L,A             ; Length to L
3039+ 26AA 2C           TOSTRA: inc     L               ; inc - DECed after
3040+ 26AB 2D           TSALP:  dec     L               ; Count bytes moved
3041+ 26AC C8                   ret     Z               ; End of string - Return
3042+ 26AD 0A                   ld      A,(BC)          ; Get source
3043+ 26AE 12                   ld      (DE),A          ; Save destination
3044+ 26AF 03                   inc     BC              ; Next source
3045+ 26B0 13                   inc     DE              ; Next destination
3046+ 26B1 C3 AB 26             jp      TSALP           ; Loop until string moved
3047+ 26B4
3048+ 26B4 CD 70 20     GETSTR: call    TSTSTR          ; Make sure it's a string
3049+ 26B7 2A 32 82     GSTRCU: ld      HL,(FPREG)      ; Get current string
3050+ 26BA EB           GSTRHL: ex      DE,HL           ; Save DE
3051+ 26BB CD D5 26     GSTRDE: call    BAKTMP          ; Was it last tmp-str?
3052+ 26BE EB                   ex      DE,HL           ; Restore DE
3053+ 26BF C0                   ret     NZ              ; No - Return
3054+ 26C0 D5                   push    DE              ; Save string
3055+ 26C1 50                   ld      D,B             ; String block address to DE
3056+ 26C2 59                   ld      E,C
3057+ 26C3 1B                   dec     DE              ; Point to length
3058+ 26C4 4E                   ld      C,(HL)          ; Get string length
3059+ 26C5 2A AA 81             ld      HL,(STRBOT)     ; Current bottom of string area
3060+ 26C8 CD 9C 19             call    CPDEHL          ; Last one in string area?
3061+ 26CB C2 D3 26             jp      NZ,POPHL        ; No - Return
3062+ 26CE 47                   ld      B,A             ; Clear B (A=0)
3063+ 26CF 09                   add     HL,BC           ; Remove string from str' area
3064+ 26D0 22 AA 81             ld      (STRBOT),HL     ; Save new bottom of str' area
3065+ 26D3 E1           POPHL:  pop     HL              ; Restore string
3066+ 26D4 C9                   ret
3067+ 26D5
3068+ 26D5 2A 98 81     BAKTMP: ld      HL,(TMSTPT)     ; Get temporary string pool top
3069+ 26D8 2B                   dec     HL              ; Back
3070+ 26D9 46                   ld      B,(HL)          ; Get MSB of address
3071+ 26DA 2B                   dec     HL              ; Back
3072+ 26DB 4E                   ld      C,(HL)          ; Get LSB of address
3073+ 26DC 2B                   dec     HL              ; Back
3074+ 26DD 2B                   dec     HL              ; Back
3075+ 26DE CD 9C 19             call    CPDEHL          ; String last in string pool?
3076+ 26E1 C0                   ret     NZ              ; Yes - Leave it
3077+ 26E2 22 98 81             ld      (TMSTPT),HL     ; Save new string pool top
3078+ 26E5 C9                   ret
3079+ 26E6
3080+ 26E6 01 65 24     LEN:    ld      BC,PASSA        ; To return integer A
3081+ 26E9 C5                   push    BC              ; Save address
3082+ 26EA CD B4 26     GETLEN: call    GETSTR          ; Get string and its length
3083+ 26ED AF                   xor     A
3084+ 26EE 57                   ld      D,A             ; Clear D
3085+ 26EF 32 94 81             ld      (TYPE),A        ; Set type to numeric
3086+ 26F2 7E                   ld      A,(HL)          ; Get length of string
3087+ 26F3 B7                   or      A               ; Set status flags
3088+ 26F4 C9                   ret
3089+ 26F5
3090+ 26F5 01 65 24     ASC:    ld      BC,PASSA        ; To return integer A
3091+ 26F8 C5                   push    BC              ; Save address
3092+ 26F9 CD EA 26     GTFLNM: call    GETLEN          ; Get length of string
3093+ 26FC CA AE 1C             jp      Z,FCERR         ; Null string - Error
3094+ 26FF 23                   inc     HL
3095+ 2700 23                   inc     HL
3096+ 2701 5E                   ld      E,(HL)          ; Get LSB of address
3097+ 2702 23                   inc     HL
3098+ 2703 56                   ld      D,(HL)          ; Get MSB of address
3099+ 2704 1A                   ld      A,(DE)          ; Get first byte of string
3100+ 2705 C9                   ret
3101+ 2706
3102+ 2706 3E 01        CHR:    ld      A,$01           ; One character string
3103+ 2708 CD 23 25             call    MKTMST          ; Make a temporary string
3104+ 270B CD F5 28             call    MAKINT          ; Make it integer A
3105+ 270E 2A A8 81             ld      HL,(TMPSTR+2)   ; Get address of string
3106+ 2711 73                   ld      (HL),E          ; Save character
3107+ 2712 C1           TOPOOL: pop     BC              ; Clean up stack
3108+ 2713 C3 54 25             jp      TSTOPL          ; Temporary string to pool
3109+ 2716
3110+ 2716 CD A5 28     LEFT:   call    LFRGNM          ; Get number and ending ")"
3111+ 2719 AF                   xor     A               ; Start at first byte in string
3112+ 271A E3           RIGHT1: ex      (SP),HL         ; Save code string,Get string
3113+ 271B 4F                   ld      C,A             ; Starting position in string
3114+ 271C E5           MID1:   push    HL              ; Save string block address
3115+ 271D 7E                   ld      A,(HL)          ; Get length of string
3116+ 271E B8                   cp      B               ; Compare with number given
3117+ 271F DA 24 27             jp      C,ALLFOL        ; All following bytes required
3118+ 2722 78                   ld      A,B             ; Get new length
3119+ 2723 11                   defb    $11             ; Skip "ld C,0"
3120+ 2724 0E 00        ALLFOL: ld      C,$00           ; First byte of string
3121+ 2726 C5                   push    BC              ; Save position in string
3122+ 2727 CD 8D 25             call    TESTR           ; See if enough string space
3123+ 272A C1                   pop     BC              ; Get position in string
3124+ 272B E1                   pop     HL              ; Restore string block address
3125+ 272C E5                   push    HL              ; And re-save it
3126+ 272D 23                   inc     HL
3127+ 272E 23                   inc     HL
3128+ 272F 46                   ld      B,(HL)          ; Get LSB of address
3129+ 2730 23                   inc     HL
3130+ 2731 66                   ld      H,(HL)          ; Get MSB of address
3131+ 2732 68                   ld      L,B             ; HL = address of string
3132+ 2733 06 00                ld      B,$00           ; BC = starting address
3133+ 2735 09                   add     HL,BC           ; Point to that byte
3134+ 2736 44                   ld      B,H             ; BC = source string
3135+ 2737 4D                   ld      C,L
3136+ 2738 CD 26 25             call    CRTMST          ; Create a string entry
3137+ 273B 6F                   ld      L,A             ; Length of new string
3138+ 273C CD AA 26             call    TOSTRA          ; Move string to string area
3139+ 273F D1                   pop     DE              ; Clear stack
3140+ 2740 CD BB 26             call    GSTRDE          ; Move to string pool if needed
3141+ 2743 C3 54 25             jp      TSTOPL          ; Temporary string to pool
3142+ 2746
3143+ 2746
3144+ 2746              ; INSTR statement - look for a string inside another string
3145+ 2746              ; usage: INSTR(A$,B$) -> search for B$ into A$
3146+ 2746              ; return 0 if B$ is not contained into A$ or LEN(A$)<LEN(B$)
3147+ 2746              ; return 1~255 to indicate the starting position of B$ into A$
3148+ 2746              ; ex.: INSTR("HELLO","LO") returns 4
3149+ 2746              LNS1    equ     TMPBFR1
3150+ 2746              ADRS1   equ     TMPBFR2
3151+ 2746              LNS2    equ     TMPBFR3
3152+ 2746              ADRS2   equ     TMPBFR4
3153+ 2746              PT      equ     VIDEOBUFF
3154+ 2746              PT1     equ     VIDEOBUFF+2
3155+ 2746              PT2     equ     VIDEOBUFF+4
3156+ 2746              TP      equ     VIDEOBUFF+6
3157+ 2746              TF      equ     VIDEOBUFF+8
3158+ 2746 CD A2 19     INSTR:  call    CHKSYN          ; make sure "(" follows
3159+ 2749 28                   defb    '('
3160+ 274A 2B                   dec     HL              ; dec 'cause GETCHR increments
3161+ 274B CD E3 1B             call    GETCHR          ; check if something follows
3162+ 274E CA C0 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
3163+ 2751 CD 7E 20             call    EVAL            ; Evaluate expression
3164+ 2754 CD 70 20             call    TSTSTR          ; Make sure it's a string
3165+ 2757 22 E6 81             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3166+ 275A CD B7 26             call    GSTRCU          ; check that a string follows
3167+ 275D CD C8 2E             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3168+ 2760 ED 53 DE 81          ld      (LNS1),DE       ; store values into
3169+ 2764 ED 43 E0 81          ld      (ADRS1),BC      ; temp buffers
3170+ 2768 2A E6 81             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3171+ 276B CD A2 19             call    CHKSYN          ; Make sure ',' follows
3172+ 276E 2C                   defb    ','
3173+ 276F 2B                   dec     HL              ; dec 'cause GETCHR increments
3174+ 2770 CD E3 1B             call    GETCHR          ; check if something follows
3175+ 2773 CA C0 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
3176+ 2776 CD 7E 20             call    EVAL            ; Evaluate expression
3177+ 2779 CD 70 20             call    TSTSTR          ; Make sure it's a string
3178+ 277C 22 E6 81             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3179+ 277F CD B7 26             call    GSTRCU          ; check that a string follows
3180+ 2782 CD C8 2E             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3181+ 2785 ED 53 E2 81          ld      (LNS2),DE       ; store values into
3182+ 2789 ED 43 E4 81          ld      (ADRS2),BC      ; temp buffers
3183+ 278D 2A E6 81             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3184+ 2790 CD A2 19             call    CHKSYN          ; make sure ")" follows
3185+ 2793 29                   defb    ')'
3186+ 2794 E5                   push    HL              ; store current code string pointer (the point after the ")" ) ...
3187+ 2795 FD E1                pop     IY              ; ...into IY
3188+ 2797 AF                   xor     A               ; reset 10 RAM cells
3189+ 2798 06 0A                ld      B,$0A           ; (INSTR registers)
3190+ 279A 21 E6 81             ld      HL,PT           ; first cell
3191+ 279D 77           EMPTINS:ld      (HL),A          ; reset cell
3192+ 279E 23                   inc     HL              ; next cell
3193+ 279F 10 FC                djnz    EMPTINS         ; repeat
3194+ 27A1 ED 5B E2 81          ld      DE,(LNS2)       ; load len(S2) into DE
3195+ 27A5 2A DE 81             ld      HL,(LNS1)       ; load len(S1) into HL
3196+ 27A8 CD AF 3F             call    CMP16           ; check that len(S1)>=len(S2)
3197+ 27AB DA 20 28             jp      C,RZINSTR       ; if len(S2)>len(S1) then return 0
3198+ 27AE AF           RPTINST:xor     A               ; reset...
3199+ 27AF 32 EC 81             ld      (TP),A          ; ...TP...
3200+ 27B2 32 EE 81             ld      (TF),A          ; ...and TF
3201+ 27B5 ED 4B E6 81          ld      BC,(PT)         ; pointer to S1
3202+ 27B9 2A E0 81             ld      HL,(ADRS1)      ; first cell of S1
3203+ 27BC 09                   add     HL,BC           ; get current position into RAM
3204+ 27BD 7E                   ld      A,(HL)          ; load S1(PT)
3205+ 27BE 2A E4 81             ld      HL,(ADRS2)      ; pointer to first char of S2
3206+ 27C1 BE                   cp      (HL)            ; is S1(PT)=S2(0)?
3207+ 27C2 20 3A                jr      NZ,CNT1INS      ; no, continue
3208+ 27C4 3A E6 81             ld      A,(PT)          ; load current PT
3209+ 27C7 32 EC 81             ld      (TP),A          ; TP=PT
3210+ 27CA 32 E8 81             ld      (PT1),A         ; P1=PT
3211+ 27CD AF                   xor     A               ; set...
3212+ 27CE 32 EA 81             ld      (PT2),A         ; ...PT2=0
3213+ 27D1 3C                   inc     A               ;
3214+ 27D2 32 EE 81             ld      (TF),A          ; set TF=1
3215+ 27D5 ED 4B E8 81  RP2INST:ld      BC,(PT1)        ; load pointer PT1
3216+ 27D9 2A E0 81             ld      HL,(ADRS1)      ; load address of S1
3217+ 27DC 09                   add     HL,BC           ; find char of S1 pointed by PT1
3218+ 27DD 7E                   ld      A,(HL)          ; load S1(PT1)
3219+ 27DE ED 4B EA 81          ld      BC,(PT2)        ; load pointer PT2
3220+ 27E2 2A E4 81             ld      HL,(ADRS2)      ; load char of S2 pointed by PT2
3221+ 27E5 09                   add     HL,BC           ; find S2(PT2)
3222+ 27E6 BE                   cp      (HL)            ; is S1(PT1)=S2(PT2)?
3223+ 27E7 20 4C                jr      NZ,CNTZIN       ; no, exit inner loop
3224+ 27E9 21 E8 81             ld      HL,PT1
3225+ 27EC 34                   inc     (HL)            ; increment PT1
3226+ 27ED 3A EA 81             ld      A,(PT2)
3227+ 27F0 3C                   inc     A               ; increment PT2
3228+ 27F1 32 EA 81             ld      (PT2),A
3229+ 27F4 CA FE 27             jp      Z,CNT1INS       ; if PT2>255 then exit
3230+ 27F7 21 E2 81             ld      HL,LNS2         ; len(S2)
3231+ 27FA BE                   cp      (HL)            ; PT2=len(S2)?
3232+ 27FB DA D5 27             jp      C,RP2INST       ; no (PT2<len(S2) - repeat
3233+ 27FE 3A EE 81     CNT1INS:ld      A,(TF)          ; check TF
3234+ 2801 A7                   and     A               ; TF=0? (clears also Carry for next SBC)
3235+ 2802 20 1C                jr      NZ,RZINSTR      ; no, exit
3236+ 2804 2A DE 81             ld      HL,(LNS1)       ; load len(S1)
3237+ 2807 ED 4B E2 81          ld      BC,(LNS2)       ; load len(S2)
3238+ 280B ED 42                sbc     HL,BC           ; HL=len(S1)-len(S2)
3239+ 280D ED 5B E6 81          ld      DE,(PT)         ; load pointer
3240+ 2811 1C                   inc     E               ; PT=PT+1
3241+ 2812 ED 53 E6 81          ld      (PT),DE         ; store new value
3242+ 2816 EB                   ex      DE,HL           ; invert registers
3243+ 2817 CD AF 3F             call    CMP16           ; check if PT>len(S1)-len(S2)
3244+ 281A DA AE 27             jp      C,RPTINST       ; repeat if <
3245+ 281D CA AE 27             jp      Z,RPTINST       ; repeat if =
3246+ 2820 3A EE 81     RZINSTR:ld      A,(TF)          ; current value of TF
3247+ 2823 A7                   and     A               ; is it 0?
3248+ 2824 CA 2B 28             jp      Z,LVINSTR       ; yes, return 0
3249+ 2827 3A EC 81             ld      A,(TP)          ; return TP...
3250+ 282A 3C                   inc     A               ; ...incremented by 1
3251+ 282B E1           LVINSTR:pop     HL              ; drop original return point
3252+ 282C FD E5                push    IY              ; load current string address from IY into stack
3253+ 282E 11 57 21             ld      DE,RETNUM       ; Address of Return number from function...
3254+ 2831 D5                   push    DE              ; ...saved on stack
3255+ 2832 C3 65 24             jp      PASSA           ; return TP
3256+ 2835 AF           CNTZIN: xor     A               ; set...
3257+ 2836 32 EE 81             ld      (TF),A          ; TF=0
3258+ 2839 C3 FE 27             jp      CNT1INS         ; continue
3259+ 283C
3260+ 283C
3261+ 283C CD A5 28     RIGHT:  call    LFRGNM          ; Get number and ending ")"
3262+ 283F D1                   pop     DE              ; Get string length
3263+ 2840 D5                   push    DE              ; And re-save
3264+ 2841 1A                   ld      A,(DE)          ; Get length
3265+ 2842 90                   sub     B               ; Move back N bytes
3266+ 2843 C3 1A 27             jp      RIGHT1          ; Go and get sub-string
3267+ 2846
3268+ 2846 EB           MID:    ex      DE,HL           ; Get code string address
3269+ 2847 7E                   ld      A,(HL)          ; Get next byte ',' or ")"
3270+ 2848 CD AA 28             call    MIDNUM          ; Get number supplied
3271+ 284B 04                   inc     B               ; Is it character zero?
3272+ 284C 05                   dec     B
3273+ 284D CA AE 1C             jp      Z,FCERR         ; Yes - Error
3274+ 2850 C5                   push    BC              ; Save starting position
3275+ 2851 1E FF                ld      E,$FF           ; All of string
3276+ 2853 FE 29                cp      ')'             ; Any length given?
3277+ 2855 CA 5F 28             jp      Z,RSTSTR        ; No - Rest of string
3278+ 2858 CD A2 19             call    CHKSYN          ; Make sure ',' follows
3279+ 285B 2C                   defb    ','
3280+ 285C CD F2 28             call    GETINT          ; Get integer 0-255
3281+ 285F CD A2 19     RSTSTR: call    CHKSYN          ; Make sure ")" follows
3282+ 2862 29                   defb    ')'
3283+ 2863 F1                   pop     AF              ; Restore starting position
3284+ 2864 E3                   ex      (SP),HL         ; Get string,save code string
3285+ 2865 01 1C 27             ld      BC,MID1         ; Continuation of MID$ routine
3286+ 2868 C5                   push    BC              ; Save for return
3287+ 2869 3D                   dec     A               ; Starting position-1
3288+ 286A BE                   cp      (HL)            ; Compare with length
3289+ 286B 06 00                ld      B,$00           ; Zero bytes length
3290+ 286D D0                   ret     NC              ; Null string if start past end
3291+ 286E 4F                   ld      C,A             ; Save starting position-1
3292+ 286F 7E                   ld      A,(HL)          ; Get length of string
3293+ 2870 91                   sub     C               ; Subtract start
3294+ 2871 BB                   cp      E               ; Enough string for it?
3295+ 2872 47                   ld      B,A             ; Save maximum length available
3296+ 2873 D8                   ret     C               ; Truncate string if needed
3297+ 2874 43                   ld      B,E             ; Set specified length
3298+ 2875 C9                   ret                     ; Go and create string
3299+ 2876
3300+ 2876 CD EA 26     VAL:    call    GETLEN          ; Get length of string
3301+ 2879 CA 48 2C             jp      Z,RESZER        ; Result zero
3302+ 287C 5F                   ld      E,A             ; Save length
3303+ 287D 23                   inc     HL
3304+ 287E 23                   inc     HL
3305+ 287F 7E                   ld      A,(HL)          ; Get LSB of address
3306+ 2880 23                   inc     HL
3307+ 2881 66                   ld      H,(HL)          ; Get MSB of address
3308+ 2882 6F                   ld      L,A             ; HL = String address
3309+ 2883 E5                   push    HL              ; Save string address
3310+ 2884 19                   add     HL,DE
3311+ 2885 46                   ld      B,(HL)          ; Get end of string+1 byte
3312+ 2886 72                   ld      (HL),D          ; Zero it to terminate
3313+ 2887 E3                   ex      (SP),HL         ; Save string end,get start
3314+ 2888 C5                   push    BC              ; Save end+1 byte
3315+ 2889 7E                   ld      A,(HL)          ; Get starting byte
3316+ 288A FE 24                cp      '$'             ; Hex number indicated? [function added]
3317+ 288C C2 94 28             jp      NZ,VAL1
3318+ 288F CD E8 3E             call    HEXTFP          ; Convert Hex to FPREG
3319+ 2892 18 0D                jr      VAL3
3320+ 2894 FE 25        VAL1:   cp      '%'             ; Binary number indicated? [function added]
3321+ 2896 C2 9E 28             jp      NZ,VAL2
3322+ 2899 CD 58 3F             call    BINTFP          ; Convert Bin to FPREG
3323+ 289C 18 03                jr      VAL3
3324+ 289E CD 80 2F     VAL2:   call    ASCTFP          ; Convert ASCII string to FP
3325+ 28A1 C1           VAL3:   pop     BC              ; Restore end+1 byte
3326+ 28A2 E1                   pop     HL              ; Restore end+1 address
3327+ 28A3 70                   ld      (HL),B          ; Put back original byte
3328+ 28A4 C9                   ret
3329+ 28A5
3330+ 28A5 EB           LFRGNM: ex      DE,HL           ; Code string address to HL
3331+ 28A6 CD A2 19             call    CHKSYN          ; Make sure ")" follows
3332+ 28A9 29                   defb    ')'
3333+ 28AA C1           MIDNUM: pop     BC              ; Get return address
3334+ 28AB D1                   pop     DE              ; Get number supplied
3335+ 28AC C5                   push    BC              ; Re-save return address
3336+ 28AD 43                   ld      B,E             ; Number to B
3337+ 28AE C9                   ret
3338+ 28AF
3339+ 28AF CD F5 28     INP:    call    MAKINT          ; Make it integer A
3340+ 28B2 32 A0 80             ld      (INPORT),A      ; Set input port
3341+ 28B5 CD 9F 80             call    INPSUB          ; Get input from port
3342+ 28B8 C3 65 24             jp      PASSA           ; Return integer A
3343+ 28BB
3344+ 28BB CD DF 28     POUT:   call    SETIO           ; Set up port number
3345+ 28BE C3 67 80             jp      OUTSUB          ; Output data and return
3346+ 28C1
3347+ 28C1 CD DF 28     WAIT:   call    SETIO           ; Set up port number
3348+ 28C4 F5                   push    AF              ; Save AND mask
3349+ 28C5 1E 00                ld      E,$00           ; Assume zero if none given
3350+ 28C7 2B                   dec     HL              ; dec 'cos GETCHR INCs
3351+ 28C8 CD E3 1B             call    GETCHR          ; Get next character
3352+ 28CB CA D5 28             jp      Z,NOXOR         ; No XOR byte given
3353+ 28CE CD A2 19             call    CHKSYN          ; Make sure ',' follows
3354+ 28D1 2C                   defb    ','
3355+ 28D2 CD F2 28             call    GETINT          ; Get integer 0-255 to XOR with
3356+ 28D5 C1           NOXOR:  pop     BC              ; Restore AND mask
3357+ 28D6 CD 9F 80     WAITLP: call    INPSUB          ; Get input
3358+ 28D9 AB                   xor     E               ; Flip selected bits
3359+ 28DA A0                   and     B               ; Result non-zero?
3360+ 28DB CA D6 28             jp      Z,WAITLP        ; No = keep waiting
3361+ 28DE C9                   ret
3362+ 28DF
3363+ 28DF CD F2 28     SETIO:  call    GETINT          ; Get integer 0-255
3364+ 28E2 32 A0 80             ld      (INPORT),A      ; Set input port
3365+ 28E5 32 68 80             ld      (OTPORT),A      ; Set output port
3366+ 28E8 CD A2 19             call    CHKSYN          ; Make sure ',' follows
3367+ 28EB 2C                   defb    ','
3368+ 28EC C3 F2 28             jp      GETINT          ; Get integer 0-255 and return
3369+ 28EF
3370+ 28EF CD E3 1B     FNDNUM: call    GETCHR          ; Get next character
3371+ 28F2 CD 6C 20     GETINT: call    GETNUM          ; Get a number from 0 to 255
3372+ 28F5 CD 93 1C     MAKINT: call    DEPINT          ; Make sure value 0 - 255
3373+ 28F8 7A                   ld      A,D             ; Get MSB of number
3374+ 28F9 B7                   or      A               ; Zero?
3375+ 28FA C2 AE 1C             jp      NZ,FCERR        ; No - Error
3376+ 28FD 2B                   dec     HL              ; dec 'cos GETCHR INCs
3377+ 28FE CD E3 1B             call    GETCHR          ; Get next character
3378+ 2901 7B                   ld      A,E             ; Get number to A
3379+ 2902 C9                   ret
3380+ 2903
3381+ 2903
3382+ 2903              ; activate a Non-Maskable Interrupt hooked to VDP interrupt signal
3383+ 2903 CD 6C 20     NMI:    call    GETNUM          ; Get memory address
3384+ 2906 CD 99 1C             call    DEINT           ; get integer -32768 to 32767
3385+ 2909 7B                   ld      A,E             ; check if address is 0
3386+ 290A B2                   or      D
3387+ 290B 20 11                jr      NZ,NM1          ; no, so jump over
3388+ 290D F3           DISNMI: di                      ; disable INTs
3389+ 290E CD 3A 29             call    NMIDINT         ; disable VDP INT
3390+ 2911 E5                   push    HL              ; store HL
3391+ 2912 21 ED 45             ld      HL,$45ED        ; these are the op-codes for "RETN"
3392+ 2915 22 61 80             ld      (NMIUSR),HL     ; store RETN
3393+ 2918 AF                   xor     A
3394+ 2919 32 63 80             ld      (NMIUSR+2),A    ; "NOP"
3395+ 291C 18 11                jr      NMI2            ; execute the last part of code
3396+ 291E E5           NM1:    push    HL              ; store current HL
3397+ 291F EB                   ex      DE,HL           ; move address argument into HL
3398+ 2920 F3                   di                      ; disable INTs
3399+ 2921 CD 3A 29             call    NMIDINT         ; disable VDP INT, if enabled
3400+ 2924 3E C3                ld      A,$C3           ; "jp" instruction
3401+ 2926 32 61 80             ld      (NMIUSR),A      ; store it
3402+ 2929 22 62 80             ld      (NMIUSR+1),HL   ; store address
3403+ 292C CD 33 29             call    NMIEINT         ; re-enable VDP INT
3404+ 292F FB           NMI2:   ei                      ; re-enable INTS
3405+ 2930 00                   nop                     ; wait for INTs
3406+ 2931 E1                   pop    HL               ; retrieve HL
3407+ 2932 C9                   ret                     ; return to caller
3408+ 2933              ; enable VDP INT
3409+ 2933 CD 49 29     NMIEINT:call    NMIVR1          ; load default VReg #1 setting
3410+ 2936 F6 20                or      %00100000       ; enable VDP INT
3411+ 2938 18 03                jr      NMIINT          ; rest of code is shared
3412+ 293A              ; disable VDP INT
3413+ 293A CD 49 29     NMIDINT:call    NMIVR1          ; load default VReg #1 setting
3414+ 293D D5           NMIINT: push    DE              ; store DE
3415+ 293E 5F                   ld      E,A             ; move value into E
3416+ 293F 3E 01                ld      A,$01           ; VREG #1
3417+ 2941 F3                   di                      ; disable INTs
3418+ 2942 CD C7 06             call    WRITE_VREG      ; disable VDP INT
3419+ 2945 FB                   ei                      ; re-enable INTs
3420+ 2946 00                   nop                     ; wait for INTs being enabled
3421+ 2947 D1                   pop     DE              ; retrieve DE
3422+ 2948 C9                   ret                     ; return to caller
3423+ 2949
3424+ 2949              ; load VREG #1 setting for current screen mode and return it into A
3425+ 2949 E5           NMIVR1: push    HL              ; store HL
3426+ 294A D5                   push    DE              ; store DE
3427+ 294B 3A CF 81             ld      A,(SCR_MODE)    ; check screen mode
3428+ 294E 87                   add     A,A             ; multiply A by 8...
3429+ 294F 87                   add     A,A             ; ...so that reg. A can points..
3430+ 2950 87                   add     A,A             ; to the correct settings
3431+ 2951 3C                   inc     A               ; need to change VREG 1
3432+ 2952 5F                   ld      E,A             ; copy A into E
3433+ 2953 16 00                ld      D,$00           ; reset D
3434+ 2955 21 0A 0B             ld      HL,VDPMODESET   ; pointer to register #1 setting...
3435+ 2958 19                   add     HL,DE           ; ...for current screen mode
3436+ 2959 7E                   ld      A,(HL)          ; load current setting
3437+ 295A D1                   pop     DE              ; retrieve DE
3438+ 295B E1                   pop     HL              ; retrieve HL
3439+ 295C C9                   ret                     ; return to caller
3440+ 295D
3441+ 295D              ; execute a machine language routine, eventually passing a param into A
3442+ 295D CD 6C 20     SYS:    call    GETNUM          ; Get memory address
3443+ 2960 CD 99 1C             call    DEINT           ; Get integer -32768 to 32767
3444+ 2963 ED 53 E0 81          ld      (TMPBFR2),DE    ; store user routine's address
3445+ 2967 AF                   xor     A               ; reset A
3446+ 2968 32 DE 81             ld      (TMPBFR1),A     ; store into temp buffer
3447+ 296B 2B                   dec     HL              ; dec 'cos GETCHR INCs
3448+ 296C CD E3 1B             call    GETCHR          ; check next character
3449+ 296F 28 0A                jr      Z,NOSYSPR       ; jump if nothing follows
3450+ 2971 CD A2 19             call    CHKSYN          ; Make sure ',' follows
3451+ 2974 2C                   defb    ','
3452+ 2975 CD F2 28             call    GETINT          ; get byte value (0~255) if something follows
3453+ 2978 32 DE 81             ld      (TMPBFR1),A     ; store into temp buffer
3454+ 297B 3A DE 81     NOSYSPR:ld      A,(TMPBFR1)     ; recover A
3455+ 297E ED 5B E0 81          ld      DE,(TMPBFR2)    ; recover user routine's address
3456+ 2982 E5                   push    HL              ; save code string address
3457+ 2983 EB                   ex      DE,HL           ; move user routine's address into HL
3458+ 2984 11 89 29             ld      DE,SYSRET       ; set point of return after the user routine
3459+ 2987 D5                   push    DE              ; store into stack
3460+ 2988 E9                   jp      (HL)            ; call user routine
3461+ 2989 E1           SYSRET: pop     HL              ; retrieve code string address
3462+ 298A C9                   ret                     ; return to caller
3463+ 298B
3464+ 298B
3465+ 298B              ; read the contents of a byte from RAM
3466+ 298B CD 99 1C     PEEK:   call    DEINT           ; Get memory address into DE
3467+ 298E 1A                   ld      A,(DE)          ; Read value of memory cell
3468+ 298F C3 65 24             jp      PASSA           ; Return into A
3469+ 2992
3470+ 2992              ; read the contents of a byte from VRAM
3471+ 2992 CD 99 1C     VPEEK:  call    DEINT           ; Get VRAM address into DE
3472+ 2995 EB                   ex      DE,HL           ; Copy param into HL
3473+ 2996 F3                   di                      ; Disable interrupts
3474+ 2997 CD 9D 06             call    READ_VIDEO_LOC  ; Read data from VRAM at address HL
3475+ 299A FB                   ei                      ; Re-enable interrupts
3476+ 299B EB                   ex      DE,HL           ; Restore HL
3477+ 299C C3 65 24             jp      PASSA           ; Return value into A
3478+ 299F
3479+ 299F              ; recover params for POKE/VPOKE commands
3480+ 299F              ; returns address into DE and byte to be written into A
3481+ 299F CD 6C 20     PKEPRMS:call    GETNUM          ; Get memory address
3482+ 29A2 CD 99 1C             call    DEINT           ; Get integer -32768 to 32767
3483+ 29A5 ED 53 DE 81          ld      (TMPBFR1),DE    ; Store DE into a temp. buffer
3484+ 29A9 CD A2 19             call    CHKSYN          ; Make sure ',' follows
3485+ 29AC 2C                   defb    ','
3486+ 29AD CD F2 28             call    GETINT          ; Get integer 0-255
3487+ 29B0 ED 5B DE 81          ld      DE,(TMPBFR1)    ; Restore memory address
3488+ 29B4 C9                   ret                     ; Return to caller
3489+ 29B5
3490+ 29B5              ; write a byte into SRAM
3491+ 29B5 CD 9F 29     POKE:   call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3492+ 29B8 12                   ld      (DE),A          ; Load it into memory
3493+ 29B9 C9                   ret
3494+ 29BA
3495+ 29BA              ; write a byte into VRAM
3496+ 29BA CD 9F 29     VPOKE:  call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3497+ 29BD EB                   ex      DE,HL           ; Copy address into HL
3498+ 29BE F3                   di                      ; Disable interrupts
3499+ 29BF CD B2 06             call    WRITE_VIDEO_LOC ; write data into VRAM at address HL
3500+ 29C2 FB                   ei                      ; Re-enable interrupts
3501+ 29C3 EB                   ex      DE,HL           ; Restore HL
3502+ 29C4 C9                   ret                     ; Return to caller
3503+ 29C5
3504+ 29C5              ; position the cursor at a specific X,Y location onto screen
3505+ 29C5 CD F2 28     LOCATE: call    GETINT          ; get the first param into A
3506+ 29C8 E5                   push    HL              ; store HL
3507+ 29C9 21 CD 81             ld      HL,SCR_SIZE_W   ; load address of screen width
3508+ 29CC 5E                   ld      E,(HL)          ; load screen width into E
3509+ 29CD E1                   pop     HL              ; restore HL
3510+ 29CE BB                   cp      E               ; compare witdh with param
3511+ 29CF D2 AE 1C             jp      NC,FCERR        ; value over the width of the screen, exit with Illegal F.C. error
3512+ 29D2 32 DE 81             ld      (TMPBFR1),A     ; Store X into a temp. buffer
3513+ 29D5 CD A2 19             call    CHKSYN          ; Make sure ',' follows
3514+ 29D8 2C                   defb    ','
3515+ 29D9 CD F2 28             call    GETINT          ; Get the second param into A
3516+ 29DC E5                   push    HL              ; store HL
3517+ 29DD 21 CE 81             ld      HL,SCR_SIZE_H   ; load address of screen width
3518+ 29E0 5E                   ld      E,(HL)          ; load screen width into A
3519+ 29E1 E1                   pop     HL              ; restore HL
3520+ 29E2 BB                   cp      E               ; compare witdh with param
3521+ 29E3 D2 AE 1C             jp      NC,FCERR        ; value over the height of the screen, exit with Illegal F.C. error
3522+ 29E6 32 D6 81             ld      (SCR_CUR_NY),A  ; store new Y
3523+ 29E9 3A DE 81             ld      A,(TMPBFR1)     ; recover the new X
3524+ 29EC 32 D5 81             ld      (SCR_CUR_NX),A  ; store new X
3525+ 29EF E5                   push    HL              ; store HL
3526+ 29F0 F3                   di                      ; disable INTs
3527+ 29F1 CD E3 06             call    MOVCRS          ; move cursor to new location
3528+ 29F4 FB                   ei                      ; re-enable INTs
3529+ 29F5 E1                   pop     HL              ; restore HL
3530+ 29F6 C9                   ret                     ; return to caller
3531+ 29F7
3532+ 29F7              ; write a byte into one of the PSG registers
3533+ 29F7 CD F2 28     SREG:   call    GETINT          ; Get register number back into A
3534+ 29FA FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3535+ 29FC D2 AE 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3536+ 29FF 32 DE 81             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3537+ 2A02 CD A2 19             call    CHKSYN          ; Make sure ',' follows
3538+ 2A05 2C                   defb    ','
3539+ 2A06 CD F2 28             call    GETINT          ; get second value (0-255), returned into A
3540+ 2A09 5F                   ld      E,A             ; store value into E
3541+ 2A0A 3A DE 81             ld      A,(TMPBFR1)     ; recover VDP register and store into D
3542+ 2A0D F3                   di                      ; disable INTs
3543+ 2A0E 0E 40                ld      C,PSG_REG       ; output port to access PSG registers
3544+ 2A10 ED 79                out     (C),A           ; send register # to PSG
3545+ 2A12 0E 41                ld      C,PSG_DAT       ; output port to send data to PSG
3546+ 2A14 ED 59                out     (C),E           ; send byte to write into selected register
3547+ 2A16 FB                   ei                      ; re-enable INTs
3548+ 2A17 C9                   ret                     ; return to caller
3549+ 2A18
3550+ 2A18              ; VOLUME ch,vol
3551+ 2A18              ; set the volume for the audio channels
3552+ 2A18              ; "ch" is 1~3 for corresponding channel, or 0 for all; "vol" is 0~15 (0=OFF, 15=MAX)
3553+ 2A18 CD F2 28     VOLUME: call    GETINT          ; get integer 0-255 (recover channel)
3554+ 2A1B FE 04                cp      $04             ; check if it's in the range 0~3
3555+ 2A1D D2 AE 1C             jp      NC,FCERR        ; if not, exit with Illegal function call error
3556+ 2A20 32 DE 81             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3557+ 2A23 CD A2 19             call    CHKSYN          ; Make sure ',' follows
3558+ 2A26 2C                   defb    ','
3559+ 2A27 CD F2 28             call    GETINT          ; get integer 0-255 (recover channel)
3560+ 2A2A FE 10                cp      $10             ; check if it's in the range 0~15
3561+ 2A2C D2 AE 1C             jp      NC,FCERR        ; if not, exit with Illegal funcion call
3562+ 2A2F 57                   ld      D,A             ; store volume into D
3563+ 2A30 3A DE 81             ld      A,(TMPBFR1)     ; retrieve channel
3564+ 2A33 A7                   and     A               ; is it 0? (0=every channel)
3565+ 2A34 20 10                jr      NZ,VOLCH        ; no, jump over
3566+ 2A36 06 03                ld      B,$03           ; yes, set every channel
3567+ 2A38 1E 08                ld      E,$08           ; register volume of first channel
3568+ 2A3A 0E 40        RPVOLCG:ld      C,PSG_REG       ; PSG register port
3569+ 2A3C ED 59                out     (C),E           ; set register #
3570+ 2A3E 0E 41                ld      C,PSG_DAT       ; PSG data port
3571+ 2A40 ED 51                out     (C),D           ; send volume
3572+ 2A42 1C                   inc     E               ; next register
3573+ 2A43 10 F5                djnz    RPVOLCG         ; repeat for each channel
3574+ 2A45 C9                   ret                     ; return to caller
3575+ 2A46 0E 40        VOLCH:  ld      C,PSG_REG       ; PSG register port
3576+ 2A48 C6 07                add     $07             ; add 7 to A so that we have the correct register (1->8, 2->9, 3->10)
3577+ 2A4A ED 79                out     (C),A           ; set register
3578+ 2A4C 0E 41                ld      C,PSG_DAT       ; PSG data port
3579+ 2A4E ED 51                out     (C),D           ; send volume level
3580+ 2A50 C9                   ret                     ; return to caller
3581+ 2A51
3582+ 2A51              ; SOUND ch,tone,dur
3583+ 2A51              ; play a tone or noise of "tone" frequency from selected channel "ch" for duration "dur"
3584+ 2A51              ; "ch" is 1~6 (0=means sound OFF,1~3 for tone, 4~6 for noise) / "tone" is 1~4,095 (0=means no tone) /
3585+ 2A51              ; "dur" is 1~16383 h.o.s.,0.001~163s (0=means non-stop tone)
3586+ 2A51 CD F2 28     SOUND:  call    GETINT          ; get integer 0-255 (recover channel)
3587+ 2A54 A7                   and     A               ; is it zero?
3588+ 2A55 20 08                jr      NZ,CTSNDC       ; no, continue with checking of params
3589+ 2A57 E5                   push    HL              ; store HL
3590+ 2A58 F3                   di                      ; disable INTs
3591+ 2A59 CD 7C 0C             call    CLRPSGREGS      ; yes, it's zero, so reset PSG registers to shut down every sound
3592+ 2A5C FB                   ei                      ; re-enable INTs
3593+ 2A5D E1                   pop     HL              ; retrieve HL
3594+ 2A5E C9                   ret                     ; return to caller
3595+ 2A5F 32 DE 81     CTSNDC: ld      (TMPBFR1),A     ; no, continue by storing A into a temp. buffer
3596+ 2A62 FE 04                cp      $04             ; is channel >3?
3597+ 2A64 D2 E3 2A             jp      NC,NOISUP       ; Yes - check to see if it's a noise channel
3598+ 2A67 CD A2 19             call    CHKSYN          ; No, continue checking by making sure ',' follows
3599+ 2A6A 2C                   defb    ','
3600+ 2A6B CD 6C 20             call    GETNUM          ; Get tone frequency
3601+ 2A6E CD 99 1C             call    DEINT           ; Get integer -32768 to 32767
3602+ 2A71 ED 53 E0 81          ld      (TMPBFR2),DE    ; Store frequency
3603+ 2A75 CD A2 19             call    CHKSYN          ; Make sure ',' follows
3604+ 2A78 2C                   defb    ','
3605+ 2A79 CD 6C 20             call    GETNUM          ; Get duration
3606+ 2A7C CD 99 1C             call    DEINT           ; Get integer -32768 to 32767
3607+ 2A7F ED 53 E2 81          ld      (TMPBFR3),DE    ; Store duration
3608+ 2A83                                              ; CHECK CHANNEL
3609+ 2A83 3A DE 81             ld      A,(TMPBFR1)     ; recover channel
3610+ 2A86 FE 01                cp      $01             ; is channel <1?
3611+ 2A88 DA AE 1C             jp      C,FCERR         ; Yes - Illegal function call error
3612+ 2A8B                                              ; CHECK FREQUENCY
3613+ 2A8B ED 5B E0 81          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3614+ 2A8F 7A                   ld      A,D             ; move D into A and check if it is in the range 0~4095...
3615+ 2A90 FE 10                cp      $10             ; ...so D must not be greater than $0F (15)
3616+ 2A92 D2 AE 1C             jp      NC,FCERR        ; if not in the range, exit with an Illegal function call error
3617+ 2A95                                              ; CHECK DURATION
3618+ 2A95 ED 5B E2 81          ld      DE,(TMPBFR3)    ; restore duration from temp buffer
3619+ 2A99 7A                   ld      A,D             ; check if it is in the range 0~16383...
3620+ 2A9A E6 C0                and     $C0             ; ...(15th & 14th bits must not be set)
3621+ 2A9C C2 AE 1C             jp      NZ,FCERR        ; if not in the range, exit with an Illegal function call error
3622+ 2A9F                                              ;
3623+ 2A9F                                              ; SET TONE:
3624+ 2A9F                                              ; let's start by setting up the channel
3625+ 2A9F 3A DE 81             ld      A,(TMPBFR1)     ; restore channel value
3626+ 2AA2 FE 03                cp      $03             ; is it 3?
3627+ 2AA4 20 02                jr      NZ,SND1         ; no, jump over
3628+ 2AA6 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3629+ 2AA8 2F           SND1:   cpl                     ; complement of A - this is used later to set on the channel into the mixer
3630+ 2AA9 CD 30 2B             call    WRTSND          ; enable line into mixer of channel stored in A
3631+ 2AAC                                              ; SET FREQUENCY
3632+ 2AAC                                              ; we simply get frequency and subtract from 4096. The result
3633+ 2AAC                                              ; is put into register pair of the corresponding freq tone channel
3634+ 2AAC ED 5B E0 81          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3635+ 2AB0 E5                   push    HL              ; store HL (it will be used by the subroutine)
3636+ 2AB1 21 00 10             ld      HL,$1000        ; load 4096 into HL
3637+ 2AB4 A7                   and     A               ; reset C flag
3638+ 2AB5 ED 52                sbc     HL,DE           ; subtract freq from HL - now the frequency is inverted, so we will send the low as high and vice-versa
3639+ 2AB7 3A DE 81             ld      A,(TMPBFR1)     ; restore channel value
3640+ 2ABA 3D                   dec     A               ; set A into the range 0~2
3641+ 2ABB 87                   add     A,A             ; double A to find the register pair that correspond to the channel (A->0,1 / B->2,3, C->4,5)
3642+ 2ABC 0E 40                ld      C,PSG_REG       ; PSG register port
3643+ 2ABE ED 79                out     (C),A           ; select first register of the pair
3644+ 2AC0 0E 41                ld      C,PSG_DAT       ; PSG data port
3645+ 2AC2 ED 69                out     (C),L           ; send high byte
3646+ 2AC4 0E 40                ld      C,PSG_REG       ; PSG register support
3647+ 2AC6 3C                   inc     A               ; second register of the pair
3648+ 2AC7 ED 79                out     (C),A           ; select register
3649+ 2AC9 0E 41                ld      C,PSG_DAT       ; PSG data port
3650+ 2ACB ED 61                out     (C),H           ; send low byte
3651+ 2ACD ED 5B E2 81          ld      DE,(TMPBFR3)    ; recover duration
3652+ 2AD1 3A DE 81             ld      A,(TMPBFR1)     ; recover channel value
3653+ 2AD4 3D                   dec     A               ; set channel into the range 0~2
3654+ 2AD5 87                   add     A,A             ; double A to find the correct offset
3655+ 2AD6 21 12 82             ld      HL,CHASNDDTN    ; set duration into...
3656+ 2AD9 85                   add     A,L             ; ...the proper...
3657+ 2ADA 30 01                jr      NC,SNDOVR       ; (is there a rest? no, jump over
3658+ 2ADC 24                   inc     H               ; yes, increment H)
3659+ 2ADD 6F           SNDOVR: ld      L,A             ; ...register pair...
3660+ 2ADE 73                   ld      (HL),E          ; ...and store the value
3661+ 2ADF 23                   inc     HL
3662+ 2AE0 72                   ld      (HL),D
3663+ 2AE1 E1                   pop     HL              ; retrieve HL
3664+ 2AE2 C9                   ret                     ; Return to caller
3665+ 2AE3 FE 07        NOISUP: cp      $07             ; is channel in range 4 to 6 (for a noise)?
3666+ 2AE5 D2 AE 1C             jp      NC,FCERR        ; no, so ILLEGAL FUNCTION CALL
3667+ 2AE8 CD A2 19             call    CHKSYN          ; yes, continue checking by making sure ',' follows
3668+ 2AEB 2C                   defb    ','
3669+ 2AEC CD F2 28             call    GETINT          ; get integer 0-255 (frequency)
3670+ 2AEF FE 20                cp      $20             ; make sure it's in range 0~31
3671+ 2AF1 D2 AE 1C             jp      NC,FCERR        ; no, so Illegal function call
3672+ 2AF4 32 E0 81             ld      (TMPBFR2),A     ; store freq.
3673+ 2AF7 2B                   dec     HL              ; dec 'cos GETCHR INCs
3674+ 2AF8 CD E3 1B             call    GETCHR          ; check that nothing follows
3675+ 2AFB C2 C0 16             jp      NZ,SNERR        ; error if no empty line
3676+ 2AFE 3A E0 81             ld      A,(TMPBFR2)     ; retrieve freq.
3677+ 2B01 5F                   ld      E,A             ; store freq into E
3678+ 2B02 3A DE 81             ld      A,(TMPBFR1)     ; retrieve channel
3679+ 2B05 D6 03                sub     $03             ; subtract 3 to get channel in range 1~3
3680+ 2B07 FE 03                cp      $03             ; is it 3?
3681+ 2B09 20 02                jr      NZ,NOS1         ; no, jump over
3682+ 2B0B 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3683+ 2B0D 87           NOS1:   add     A,A
3684+ 2B0E 87                   add     A,A
3685+ 2B0F 87                   add     A,A             ; let's move A 3 bits to left
3686+ 2B10 47                   ld      B,A             ; store channel into B
3687+ 2B11 7B                   ld      A,E             ; check if
3688+ 2B12 A7                   and     A               ; freq is 0 (means that noise reproduction must be halted)
3689+ 2B13 F3                   di                      ; disable INts
3690+ 2B14 20 0A                jr      NZ,NOS2         ; no, so jump over
3691+ 2B16 3E 07                ld      A,$07           ; mixer register
3692+ 2B18 CD CA 0C             call    SETSNDREG       ; set mixer register
3693+ 2B1B ED 78                in      A,(C)           ; load current mixer value
3694+ 2B1D B0                   or      B               ; disable noise
3695+ 2B1E 18 19                jr      NOS3            ; continue over
3696+ 2B20 78           NOS2:   ld      A,B             ; recover channel
3697+ 2B21 2F                   cpl                     ; complement of A - this is used to set on the channel into the mixer
3698+ 2B22 CD 30 2B             call    WRTSND          ; enable line into mixer of channel stored in A
3699+ 2B25 3E 06                ld      A,$06           ; write into noise register
3700+ 2B27 CD CA 0C             call    SETSNDREG       ; set register into PSG
3701+ 2B2A 7B                   ld      A,E             ; load value for noise frequency
3702+ 2B2B CD CF 0C             call    WRTSNDREG       ; write data into register $06
3703+ 2B2E FB                   ei                      ; re-enable INTs
3704+ 2B2F C9                   ret
3705+ 2B30                      ; enable line into mixer of channel stored in A
3706+ 2B30 47           WRTSND: ld      B,A             ; move channel into B
3707+ 2B31 3E 07                ld      A,$07           ; mixer register
3708+ 2B33 CD CA 0C             call    SETSNDREG       ; set mixer register
3709+ 2B36 ED 78                in      A,(C)           ; load current value
3710+ 2B38 A0                   and     B               ; set on the channel into the mixer (remember that 0=ON)
3711+ 2B39                                              ; example: if channel is A (1), complement of 1 is 254 (11111110). So, 255 (in case
3712+ 2B39                                              ; the register is still unchanged after reset) is 11111111 and
3713+ 2B39                                              ; 11111111 AND 11111110 is equal to 11111110
3714+ 2B39                                              ; 11111001 AND 11111110 is equal to 11111000 (in case channels B & C are ON)
3715+ 2B39 47           NOS3:   ld      B,A             ; store new mixer value into B
3716+ 2B3A 3E 07                ld      A,$07           ; mixer address
3717+ 2B3C CD CA 0C             call    SETSNDREG       ; set register
3718+ 2B3F 78                   ld      A,B             ; retrieve new mixer value from B
3719+ 2B40 CD CF 0C             call    WRTSNDREG       ; send new value for the mixer
3720+ 2B43 FB                   ei                      ; re-enable INTs
3721+ 2B44 C9                   ret                     ; return to caller
3722+ 2B45
3723+ 2B45              ; write a byte into one of the VDP registers
3724+ 2B45 CD F2 28     VREG:   call    GETINT          ; Get register number back into A
3725+ 2B48 FE 08                cp      $08             ; check if value is equal or greater than 8 (VDP registers are only 8, from 0 to 7)
3726+ 2B4A D2 AE 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3727+ 2B4D 32 DE 81             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3728+ 2B50 CD A2 19             call    CHKSYN          ; Make sure ',' follows
3729+ 2B53 2C                   defb    ','
3730+ 2B54 CD F2 28             call    GETINT          ; get value (0-255)
3731+ 2B57 5F                   ld      E,A             ; store value into E
3732+ 2B58 3A DE 81             ld      A,(TMPBFR1)     ; recover VDP register and store into A
3733+ 2B5B F3                   di                      ; disable INTs
3734+ 2B5C CD C7 06             call    WRITE_VREG      ; write value into VDP register
3735+ 2B5F FB                   ei                      ; re-enable INTs
3736+ 2B60 C9                   ret                     ; return to caller
3737+ 2B61
3738+ 2B61              ; read the VDP status register and return it into A
3739+ 2B61 CD 99 1C     VSTAT:  call    DEINT           ; Get integer -32768 to 32767 (Note: we do NOT use it)
3740+ 2B64 F3                   di                      ; disable INTs
3741+ 2B65 CD D2 06             call    READ_VSTAT      ; read VDP register status
3742+ 2B68 FB                   ei                      ; re-enable INTs
3743+ 2B69 C3 65 24             jp      PASSA           ; Return integer A
3744+ 2B6C
3745+ 2B6C              ; read from PSG register and return it into A
3746+ 2B6C CD 99 1C     SSTAT:  call    DEINT           ; get integer -32768 to 32767
3747+ 2B6F 7B                   ld      A,E             ; consider LSB
3748+ 2B70 FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3749+ 2B72 D2 AE 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3750+ 2B75 F3                   di                      ; disable INts
3751+ 2B76 0E 40                ld      C,PSG_REG       ; output port to set PSG register
3752+ 2B78 ED 79                out     (C),A           ; send register to read from
3753+ 2B7A ED 78                in      A,(C)           ; read register's contents and store into A
3754+ 2B7C FB                   ei                      ; re-enable INTs
3755+ 2B7D C3 65 24             jp      PASSA           ; return A
3756+ 2B80
3757+ 2B80              ; read the temp key buffer and return the value of the current key being pressed
3758+ 2B80              ; can wait for the number of 100thds of second before to return
3759+ 2B80 CD DF 24     INKEY:  call    IDTEST          ; Test for illegal direct
3760+ 2B83 CD 99 1C             call    DEINT           ; get number param (100thds of second to wait) into DE
3761+ 2B86 C5                   push    BC              ; store BC
3762+ 2B87 3A BD 81             ld      A,(TMRCNT)      ; Load current value of system timer
3763+ 2B8A 47                   ld      B,A             ; move it into B
3764+ 2B8B 3A BD 81     CMP_A:  ld      A,(TMRCNT)      ; make a little delay of 1/100 sec...
3765+ 2B8E B8                   cp      B               ; ...to let the sniffer collect...
3766+ 2B8F 20 FA                jr      NZ,CMP_A        ; ...at least 1 char before to continue
3767+ 2B91 7A                   ld      A,D             ; check the param
3768+ 2B92 B3                   or      E               ; if DE<>0 then...
3769+ 2B93 20 05                jr      NZ,INKEY2       ; ...jump over...
3770+ 2B95 3A 1A 82             ld      A,(TMPKEYBFR)   ; ...else read the buffer and...
3771+ 2B98 18 2A                jr      ENDINK          ; ...return it
3772+ 2B9A 7A           INKEY2: ld      A,D             ; check if param>1023
3773+ 2B9B FE 04                cp      $04             ; to do this we check if MSB>3
3774+ 2B9D D2 AE 1C             jp      NC,FCERR        ; if MSB >=4 then error
3775+ 2BA0 E5                   push    HL              ; store HL
3776+ 2BA1 21 09 00             ld      HL,$0009        ; check if value
3777+ 2BA4 CD AF 3F             call    CMP16           ; is < 10
3778+ 2BA7 E1                   pop     HL              ; retrieve HL
3779+ 2BA8 DA AE 2B             jp      C,SRTINK        ; if value >= 10 then jump over
3780+ 2BAB 11 0A 00             ld      DE,$000A        ; else, use 10 (no intervals shorter than 10/100s)
3781+ 2BAE 3A BD 81     SRTINK: ld      A,(TMRCNT)      ; Load the first byte of the system timer
3782+ 2BB1 47                   ld      B,A             ; move it into B
3783+ 2BB2 3A 1A 82     CHKINK: ld      A,(TMPKEYBFR)   ; load char code from buffer
3784+ 2BB5 A7                   and     A               ; is it 0?
3785+ 2BB6 20 0C                jr      NZ,ENDINK       ; no, so we can return it
3786+ 2BB8 3A BD 81             ld      A,(TMRCNT)      ; load the first byte of the system timer
3787+ 2BBB B8                   cp      B               ; is it the same value?
3788+ 2BBC 28 F4                jr      Z,CHKINK        ; yes, so read again
3789+ 2BBE 47                   ld      B,A             ; store new value
3790+ 2BBF 1B                   dec     DE              ; no, decrement timer
3791+ 2BC0 7A                   ld      A,D             ; check if zero reached
3792+ 2BC1 B3                   or      E               ; by ORing D and E
3793+ 2BC2 20 EE                jr      NZ,CHKINK       ; if not 0, repeat
3794+ 2BC4 C1           ENDINK: pop     BC              ; restore BC
3795+ 2BC5 F5                   push    AF              ; store A
3796+ 2BC6 F3                   di                      ; disable INTs
3797+ 2BC7 AF                   xor     A               ; clear the...
3798+ 2BC8 32 1A 82             ld      (TMPKEYBFR),A   ; ...TMP KEY buffer for the next read
3799+ 2BCB FB                   ei                      ; re-enable INTs
3800+ 2BCC F1                   pop     AF              ; retrieve A
3801+ 2BCD C3 65 24     ENDINK2:jp      PASSA           ; return A as ASCII value
3802+ 2BD0
3803+ 2BD0 21 F7 30     ROUND:  ld      HL,HALF         ; Add 0.5 to FPREG
3804+ 2BD3 CD C8 2E     ADDPHL: call    LOADFP          ; Load FP at (HL) to BCDE
3805+ 2BD6 C3 E2 2B             jp      FPADD           ; Add BCDE to FPREG
3806+ 2BD9
3807+ 2BD9 CD C8 2E     SUBPHL: call    LOADFP          ; FPREG = -FPREG + number at HL
3808+ 2BDC 21                   defb    $21             ; Skip "pop BC" and "pop DE"
3809+ 2BDD C1           PSUB:   pop     BC              ; Get FP number from stack
3810+ 2BDE D1                   pop     DE
3811+ 2BDF CD A2 2E     SUBCDE: call    INVSGN          ; Negate FPREG
3812+ 2BE2 78           FPADD:  ld      A,B             ; Get FP exponent
3813+ 2BE3 B7                   or      A               ; Is number zero?
3814+ 2BE4 C8                   ret     Z               ; Yes - Nothing to add
3815+ 2BE5 3A 35 82             ld      A,(FPEXP)       ; Get FPREG exponent
3816+ 2BE8 B7                   or      A               ; Is this number zero?
3817+ 2BE9 CA BA 2E             jp      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3818+ 2BEC 90                   sub     B               ; BCDE number larger?
3819+ 2BED D2 FC 2B             jp      NC,NOSWAP       ; No - Don't swap them
3820+ 2BF0 2F                   cpl                     ; Two's complement
3821+ 2BF1 3C                   inc     A               ;  FP exponent
3822+ 2BF2 EB                   ex      DE,HL
3823+ 2BF3 CD AA 2E             call    STAKFP          ; Put FPREG on stack
3824+ 2BF6 EB                   ex      DE,HL
3825+ 2BF7 CD BA 2E             call    FPBCDE          ; Move BCDE to FPREG
3826+ 2BFA C1                   pop     BC              ; Restore number from stack
3827+ 2BFB D1                   pop     DE
3828+ 2BFC FE 19        NOSWAP: cp      24+1            ; Second number insignificant?
3829+ 2BFE D0                   ret     NC              ; Yes - First number is result
3830+ 2BFF F5                   push    AF              ; Save number of bits to scale
3831+ 2C00 CD DF 2E             call    SIGNS           ; Set MSBs & sign of result
3832+ 2C03 67                   ld      H,A             ; Save sign of result
3833+ 2C04 F1                   pop     AF              ; Restore scaling factor
3834+ 2C05 CD A7 2C             call    SCALE           ; Scale BCDE to same exponent
3835+ 2C08 B4                   or      H               ; Result to be positive?
3836+ 2C09 21 32 82             ld      HL,FPREG        ; Point to FPREG
3837+ 2C0C F2 22 2C             jp      P,MINCDE        ; No - Subtract FPREG from CDE
3838+ 2C0F CD 87 2C             call    PLUCDE          ; Add FPREG to CDE
3839+ 2C12 D2 68 2C             jp      NC,RONDUP       ; No overflow - Round it up
3840+ 2C15 23                   inc     HL              ; Point to exponent
3841+ 2C16 34                   inc     (HL)            ; Increment it
3842+ 2C17 CA CF 16             jp      Z,OVERR         ; Number overflowed - Error
3843+ 2C1A 2E 01                ld      L,$01           ; 1 bit to shift right
3844+ 2C1C CD BD 2C             call    SHRT1           ; Shift result right
3845+ 2C1F C3 68 2C             jp      RONDUP          ; Round it up
3846+ 2C22
3847+ 2C22 AF           MINCDE: xor     A               ; Clear A and carry
3848+ 2C23 90                   sub     B               ; Negate exponent
3849+ 2C24 47                   ld      B,A             ; Re-save exponent
3850+ 2C25 7E                   ld      A,(HL)          ; Get LSB of FPREG
3851+ 2C26 9B                   sbc     A, E            ; Subtract LSB of BCDE
3852+ 2C27 5F                   ld      E,A             ; Save LSB of BCDE
3853+ 2C28 23                   inc     HL
3854+ 2C29 7E                   ld      A,(HL)          ; Get NMSB of FPREG
3855+ 2C2A 9A                   sbc     A,D             ; Subtract NMSB of BCDE
3856+ 2C2B 57                   ld      D,A             ; Save NMSB of BCDE
3857+ 2C2C 23                   inc     HL
3858+ 2C2D 7E                   ld      A,(HL)          ; Get MSB of FPREG
3859+ 2C2E 99                   sbc     A,C             ; Subtract MSB of BCDE
3860+ 2C2F 4F                   ld      C,A             ; Save MSB of BCDE
3861+ 2C30 DC 93 2C     CONPOS: call    C,COMPL         ; Overflow - Make it positive
3862+ 2C33
3863+ 2C33 68           BNORM:  ld      L,B             ; L = Exponent
3864+ 2C34 63                   ld      H,E             ; H = LSB
3865+ 2C35 AF                   xor     A
3866+ 2C36 47           BNRMLP: ld      B,A             ; Save bit count
3867+ 2C37 79                   ld      A,C             ; Get MSB
3868+ 2C38 B7                   or      A               ; Is it zero?
3869+ 2C39 C2 55 2C             jp      NZ,PNORM        ; No - Do it bit at a time
3870+ 2C3C 4A                   ld      C,D             ; MSB = NMSB
3871+ 2C3D 54                   ld      D,H             ; NMSB= LSB
3872+ 2C3E 65                   ld      H,L             ; LSB = VLSB
3873+ 2C3F 6F                   ld      L,A             ; VLSB= 0
3874+ 2C40 78                   ld      A,B             ; Get exponent
3875+ 2C41 D6 08                sub     $08             ; Count 8 bits
3876+ 2C43 FE E0                cp      -24-8           ; Was number zero?
3877+ 2C45 C2 36 2C             jp      NZ,BNRMLP       ; No - Keep normalising
3878+ 2C48 AF           RESZER: xor     A               ; Result is zero
3879+ 2C49 32 35 82     SAVEXP: ld      (FPEXP),A       ; Save result as zero
3880+ 2C4C C9                   ret
3881+ 2C4D
3882+ 2C4D 05           NORMAL: dec     B               ; Count bits
3883+ 2C4E 29                   add     HL,HL           ; Shift HL left
3884+ 2C4F 7A                   ld      A,D             ; Get NMSB
3885+ 2C50 17                   rla                     ; Shift left with last bit
3886+ 2C51 57                   ld      D,A             ; Save NMSB
3887+ 2C52 79                   ld      A,C             ; Get MSB
3888+ 2C53 8F                   adc     A,A             ; Shift left with last bit
3889+ 2C54 4F                   ld      C,A             ; Save MSB
3890+ 2C55 F2 4D 2C     PNORM:  jp      P,NORMAL        ; Not done - Keep going
3891+ 2C58 78                   ld      A,B             ; Number of bits shifted
3892+ 2C59 5C                   ld      E,H             ; Save HL in EB
3893+ 2C5A 45                   ld      B,L
3894+ 2C5B B7                   or      A               ; Any shifting done?
3895+ 2C5C CA 68 2C             jp      Z,RONDUP        ; No - Round it up
3896+ 2C5F 21 35 82             ld      HL,FPEXP        ; Point to exponent
3897+ 2C62 86                   add     A,(HL)          ; Add shifted bits
3898+ 2C63 77                   ld      (HL),A          ; Re-save exponent
3899+ 2C64 D2 48 2C             jp      NC,RESZER       ; Underflow - Result is zero
3900+ 2C67 C8                   ret     Z               ; Result is zero
3901+ 2C68 78           RONDUP: ld      A,B             ; Get VLSB of number
3902+ 2C69 21 35 82     RONDB:  ld      HL,FPEXP        ; Point to exponent
3903+ 2C6C B7                   or      A               ; Any rounding?
3904+ 2C6D FC 7A 2C             call    M,FPROND        ; Yes - Round number up
3905+ 2C70 46                   ld      B,(HL)          ; B = Exponent
3906+ 2C71 23                   inc     HL
3907+ 2C72 7E                   ld      A,(HL)          ; Get sign of result
3908+ 2C73 E6 80                and     %10000000       ; Only bit 7 needed
3909+ 2C75 A9                   xor     C               ; Set correct sign
3910+ 2C76 4F                   ld      C,A             ; Save correct sign in number
3911+ 2C77 C3 BA 2E             jp      FPBCDE          ; Move BCDE to FPREG
3912+ 2C7A
3913+ 2C7A 1C           FPROND: inc     E               ; Round LSB
3914+ 2C7B C0                   ret     NZ              ; Return if ok
3915+ 2C7C 14                   inc     D               ; Round NMSB
3916+ 2C7D C0                   ret     NZ              ; Return if ok
3917+ 2C7E 0C                   inc     C               ; Round MSB
3918+ 2C7F C0                   ret     NZ              ; Return if ok
3919+ 2C80 0E 80                ld      C,$80           ; Set normal value
3920+ 2C82 34                   inc     (HL)            ; Increment exponent
3921+ 2C83 C0                   ret     NZ              ; Return if ok
3922+ 2C84 C3 CF 16             jp      OVERR           ; Overflow error
3923+ 2C87
3924+ 2C87 7E           PLUCDE: ld      A,(HL)          ; Get LSB of FPREG
3925+ 2C88 83                   add     A,E             ; Add LSB of BCDE
3926+ 2C89 5F                   ld      E,A             ; Save LSB of BCDE
3927+ 2C8A 23                   inc     HL
3928+ 2C8B 7E                   ld      A,(HL)          ; Get NMSB of FPREG
3929+ 2C8C 8A                   adc     A,D             ; Add NMSB of BCDE
3930+ 2C8D 57                   ld      D,A             ; Save NMSB of BCDE
3931+ 2C8E 23                   inc     HL
3932+ 2C8F 7E                   ld      A,(HL)          ; Get MSB of FPREG
3933+ 2C90 89                   adc     A,C             ; Add MSB of BCDE
3934+ 2C91 4F                   ld      C,A             ; Save MSB of BCDE
3935+ 2C92 C9                   ret
3936+ 2C93
3937+ 2C93 21 36 82     COMPL:  ld      HL,SGNRES       ; Sign of result
3938+ 2C96 7E                   ld      A,(HL)          ; Get sign of result
3939+ 2C97 2F                   cpl                     ; Negate it
3940+ 2C98 77                   ld      (HL),A          ; Put it back
3941+ 2C99 AF                   xor     A
3942+ 2C9A 6F                   ld      L,A             ; Set L to zero
3943+ 2C9B 90                   sub     B               ; Negate exponent,set carry
3944+ 2C9C 47                   ld      B,A             ; Re-save exponent
3945+ 2C9D 7D                   ld      A,L             ; Load zero
3946+ 2C9E 9B                   sbc     A,E             ; Negate LSB
3947+ 2C9F 5F                   ld      E,A             ; Re-save LSB
3948+ 2CA0 7D                   ld      A,L             ; Load zero
3949+ 2CA1 9A                   sbc     A,D             ; Negate NMSB
3950+ 2CA2 57                   ld      D,A             ; Re-save NMSB
3951+ 2CA3 7D                   ld      A,L             ; Load zero
3952+ 2CA4 99                   sbc     A,C             ; Negate MSB
3953+ 2CA5 4F                   ld      C,A             ; Re-save MSB
3954+ 2CA6 C9                   ret
3955+ 2CA7
3956+ 2CA7 06 00        SCALE:  ld      B,$00           ; Clear underflow
3957+ 2CA9 D6 08        SCALLP: sub     $08             ; 8 bits (a whole byte)?
3958+ 2CAB DA B6 2C             jp      C,SHRITE        ; No - Shift right A bits
3959+ 2CAE 43                   ld      B,E             ; <- Shift
3960+ 2CAF 5A                   ld      E,D             ; <- right
3961+ 2CB0 51                   ld      D,C             ; <- eight
3962+ 2CB1 0E 00                ld      C,$00           ; <- bits
3963+ 2CB3 C3 A9 2C             jp      SCALLP          ; More bits to shift
3964+ 2CB6
3965+ 2CB6 C6 09        SHRITE: add     A,8+1           ; Adjust count
3966+ 2CB8 6F                   ld      L,A             ; Save bits to shift
3967+ 2CB9 AF           SHRLP:  xor     A               ; Flag for all done
3968+ 2CBA 2D                   dec     L               ; All shifting done?
3969+ 2CBB C8                   ret     Z               ; Yes - Return
3970+ 2CBC 79                   ld      A,C             ; Get MSB
3971+ 2CBD 1F           SHRT1:  rra                     ; Shift it right
3972+ 2CBE 4F                   ld      C,A             ; Re-save
3973+ 2CBF 7A                   ld      A,D             ; Get NMSB
3974+ 2CC0 1F                   rra                     ; Shift right with last bit
3975+ 2CC1 57                   ld      D,A             ; Re-save it
3976+ 2CC2 7B                   ld      A,E             ; Get LSB
3977+ 2CC3 1F                   rra                     ; Shift right with last bit
3978+ 2CC4 5F                   ld      E,A             ; Re-save it
3979+ 2CC5 78                   ld      A,B             ; Get underflow
3980+ 2CC6 1F                   rra                     ; Shift right with last bit
3981+ 2CC7 47                   ld      B,A             ; Re-save underflow
3982+ 2CC8 C3 B9 2C             jp      SHRLP           ; More bits to do
3983+ 2CCB
3984+ 2CCB 00 00 00 81  UNITY:  defb    $00,$00,$00,$81 ; 1.00000
3985+ 2CCF
3986+ 2CCF 03           LOGTAB: defb    $03             ; Table used by LOG
3987+ 2CD0 AA 56 19 80          defb    $AA,$56,$19,$80 ; 0.59898
3988+ 2CD4 F1 22 76 80          defb    $F1,$22,$76,$80 ; 0.96147
3989+ 2CD8 45 AA 38 82          defb    $45,$AA,$38,$82 ; 2.88539
3990+ 2CDC
3991+ 2CDC CD 79 2E     LOG:    call    TSTSGN          ; Test sign of value
3992+ 2CDF B7                   or      A
3993+ 2CE0 EA AE 1C             jp      PE,FCERR        ; ?FC Error if <= zero
3994+ 2CE3 21 35 82             ld      HL,FPEXP        ; Point to exponent
3995+ 2CE6 7E                   ld      A,(HL)          ; Get exponent
3996+ 2CE7 01 35 80             ld      BC,$8035        ; BCDE = SQR(1/2)
3997+ 2CEA 11 F3 04             ld      DE,$04F3
3998+ 2CED 90                   sub     B               ; Scale value to be < 1
3999+ 2CEE F5                   push    AF              ; Save scale factor
4000+ 2CEF 70                   ld      (HL),B          ; Save new exponent
4001+ 2CF0 D5                   push    DE              ; Save SQR(1/2)
4002+ 2CF1 C5                   push    BC
4003+ 2CF2 CD E2 2B             call    FPADD           ; Add SQR(1/2) to value
4004+ 2CF5 C1                   pop     BC              ; Restore SQR(1/2)
4005+ 2CF6 D1                   pop     DE
4006+ 2CF7 04                   inc     B               ; Make it SQR(2)
4007+ 2CF8 CD CF 2D             call    DVBCDE          ; Divide by SQR(2)
4008+ 2CFB 21 CB 2C             ld      HL,UNITY        ; Point to 1.
4009+ 2CFE CD D9 2B             call    SUBPHL          ; Subtract FPREG from 1
4010+ 2D01 21 CF 2C             ld      HL,LOGTAB       ; Coefficient table
4011+ 2D04 CD C1 31             call    SUMSER          ; Evaluate sum of series
4012+ 2D07 01 80 80             ld      BC,$8080        ; BCDE = -0.5
4013+ 2D0A 11 00 00             ld      DE,$0000
4014+ 2D0D CD E2 2B             call    FPADD           ; Subtract 0.5 from FPREG
4015+ 2D10 F1                   pop     AF              ; Restore scale factor
4016+ 2D11 CD F4 2F             call    RSCALE          ; Re-scale number
4017+ 2D14 01 31 80     MULLN2: ld      BC,$8031        ; BCDE = Ln(2)
4018+ 2D17 11 18 72             ld      DE,$7218
4019+ 2D1A 21                   defb    $21             ; Skip "pop BC" and "pop DE"
4020+ 2D1B
4021+ 2D1B C1           MULT:   pop     BC              ; Get number from stack
4022+ 2D1C D1                   pop     DE
4023+ 2D1D CD 79 2E     FPMULT: call    TSTSGN          ; Test sign of FPREG
4024+ 2D20 C8                   ret     Z               ; Return zero if zero
4025+ 2D21 2E 00                ld      L,$00           ; Flag add exponents
4026+ 2D23 CD 37 2E             call    ADDEXP          ; Add exponents
4027+ 2D26 79                   ld      A,C             ; Get MSB of multiplier
4028+ 2D27 32 44 82             ld      (MULVAL),A      ; Save MSB of multiplier
4029+ 2D2A EB                   ex      DE,HL
4030+ 2D2B 22 45 82             ld      (MULVAL+1),HL   ; Save rest of multiplier
4031+ 2D2E 01 00 00             ld      BC,$0000        ; Partial product (BCDE) = zero
4032+ 2D31 50                   ld      D,B
4033+ 2D32 58                   ld      E,B
4034+ 2D33 21 33 2C             ld      HL,BNORM        ; Address of normalise
4035+ 2D36 E5                   push    HL              ; Save for return
4036+ 2D37 21 3F 2D             ld      HL,MULT8        ; Address of 8 bit multiply
4037+ 2D3A E5                   push    HL              ; Save for NMSB,MSB
4038+ 2D3B E5                   push    HL              ;
4039+ 2D3C 21 32 82             ld      HL,FPREG        ; Point to number
4040+ 2D3F 7E           MULT8:  ld      A,(HL)          ; Get LSB of number
4041+ 2D40 23                   inc     HL              ; Point to NMSB
4042+ 2D41 B7                   or      A               ; Test LSB
4043+ 2D42 CA 6B 2D             jp      Z,BYTSFT        ; Zero - shift to next byte
4044+ 2D45 E5                   push    HL              ; Save address of number
4045+ 2D46 2E 08                ld      L,$08           ; 8 bits to multiply by
4046+ 2D48 1F           MUL8LP: rra                     ; Shift LSB right
4047+ 2D49 67                   ld      H,A             ; Save LSB
4048+ 2D4A 79                   ld      A,C             ; Get MSB
4049+ 2D4B D2 59 2D             jp      NC,NOMADD       ; Bit was zero - Don't add
4050+ 2D4E E5                   push    HL              ; Save LSB and count
4051+ 2D4F 2A 45 82             ld      HL,(MULVAL+1)   ; Get LSB and NMSB
4052+ 2D52 19                   add     HL,DE           ; Add NMSB and LSB
4053+ 2D53 EB                   ex      DE,HL           ; Leave sum in DE
4054+ 2D54 E1                   pop     HL              ; Restore MSB and count
4055+ 2D55 3A 44 82             ld      A,(MULVAL)      ; Get MSB of multiplier
4056+ 2D58 89                   adc     A,C             ; Add MSB
4057+ 2D59 1F           NOMADD: rra                     ; Shift MSB right
4058+ 2D5A 4F                   ld      C,A             ; Re-save MSB
4059+ 2D5B 7A                   ld      A,D             ; Get NMSB
4060+ 2D5C 1F                   rra                     ; Shift NMSB right
4061+ 2D5D 57                   ld      D,A             ; Re-save NMSB
4062+ 2D5E 7B                   ld      A,E             ; Get LSB
4063+ 2D5F 1F                   rra                     ; Shift LSB right
4064+ 2D60 5F                   ld      E,A             ; Re-save LSB
4065+ 2D61 78                   ld      A,B             ; Get VLSB
4066+ 2D62 1F                   rra                     ; Shift VLSB right
4067+ 2D63 47                   ld      B,A             ; Re-save VLSB
4068+ 2D64 2D                   dec     L               ; Count bits multiplied
4069+ 2D65 7C                   ld      A,H             ; Get LSB of multiplier
4070+ 2D66 C2 48 2D             jp      NZ,MUL8LP       ; More - Do it
4071+ 2D69 E1           POPHRT: pop     HL              ; Restore address of number
4072+ 2D6A C9                   ret
4073+ 2D6B
4074+ 2D6B 43           BYTSFT: ld      B,E             ; Shift partial product left
4075+ 2D6C 5A                   ld      E,D
4076+ 2D6D 51                   ld      D,C
4077+ 2D6E 4F                   ld      C,A
4078+ 2D6F C9                   ret
4079+ 2D70
4080+ 2D70
4081+ 2D70              ; WORKING ââ
4082+ 2D70 C1           DINT:   pop     BC              ; Get number from stack
4083+ 2D71 D1                   pop     DE
4084+ 2D72 CD CF 2D             call    DVBCDE          ; get BCDE/FPREG and store result into FPREG
4085+ 2D75 C3 4C 2F             jp      INT             ; return INT(FPREG)
4086+ 2D78
4087+ 2D78
4088+ 2D78              ; A MODULO B - return remainder of the integer division A/B where:
4089+ 2D78              ; A is in stack; B is in FPREG
4090+ 2D78              ; math is:
4091+ 2D78              ; A=INT(A); B=INT(B); R=A-(B*INT(A/B))
4092+ 2D78 CD 4C 2F     MOD:    call    INT             ; B=INT(B)
4093+ 2D7B CD C5 2E             call    BCDEFP          ; copy B (from FPREG) into BCDE
4094+ 2D7E ED 53 E2 81          ld      (TMPBFR3),DE    ; store B into...
4095+ 2D82 ED 43 E4 81          ld      (TMPBFR4),BC    ; ...a temp buffer
4096+ 2D86 C1                   pop     BC              ; recover A...
4097+ 2D87 D1                   pop     DE              ; ...from stack
4098+ 2D88 CD BA 2E             call    FPBCDE          ; store A into FPREG
4099+ 2D8B CD 4C 2F             call    INT             ; get integer part: A=INT(A)
4100+ 2D8E CD C5 2E             call    BCDEFP          ; copy A (from FPREG) into BCDE
4101+ 2D91 ED 53 DE 81          ld      (TMPBFR1),DE    ; store A into...
4102+ 2D95 ED 43 E0 81          ld      (TMPBFR2),BC    ; ...a temp buffer
4103+ 2D99                                              ; begin calculation
4104+ 2D99 2A E2 81             ld      HL,(TMPBFR3)    ; move B...
4105+ 2D9C 22 32 82             ld      (FPREG),HL      ; ...from...
4106+ 2D9F 2A E4 81             ld      HL,(TMPBFR4)    ; ...temp buffer...
4107+ 2DA2 22 34 82             ld      (FPREG+2),HL    ; ...into FPREG
4108+ 2DA5 CD CF 2D             call    DVBCDE          ; compute A/B and store into FPREG
4109+ 2DA8 CD 4C 2F             call    INT             ; get integer part of result: now FPREG = INT(A/B)
4110+ 2DAB ED 5B E2 81          ld      DE,(TMPBFR3)    ; load B...
4111+ 2DAF ED 4B E4 81          ld      BC,(TMPBFR4)    ; ...into BCDE
4112+ 2DB3 CD 1D 2D             call    FPMULT          ; get B*INT(A/B) and store into FPREG
4113+ 2DB6 ED 5B DE 81          ld      DE,(TMPBFR1)    ; retrieve A from...
4114+ 2DBA ED 4B E0 81          ld      BC,(TMPBFR2)    ; ...temp buffer
4115+ 2DBE C3 DF 2B             jp      SUBCDE          ; return result of A-(B*INT(A/B))
4116+ 2DC1
4117+ 2DC1
4118+ 2DC1 CD AA 2E     DIV10:  call    STAKFP          ; Save FPREG on stack
4119+ 2DC4 01 20 84             ld      BC,$8420        ; BCDE = 10.
4120+ 2DC7 11 00 00             ld      DE,$0000
4121+ 2DCA CD BA 2E             call    FPBCDE          ; Move 10 to FPREG
4122+ 2DCD
4123+ 2DCD C1           DIV:    pop     BC              ; Get number from stack
4124+ 2DCE D1                   pop     DE
4125+ 2DCF CD 79 2E     DVBCDE: call    TSTSGN          ; Test sign of FPREG
4126+ 2DD2 CA C3 16             jp      Z,DZERR         ; Error if division by zero
4127+ 2DD5 2E FF                ld      L,-1            ; Flag subtract exponents
4128+ 2DD7 CD 37 2E             call    ADDEXP          ; Subtract exponents
4129+ 2DDA 34                   inc     (HL)            ; Add 2 to exponent to adjust
4130+ 2DDB 34                   inc     (HL)
4131+ 2DDC 2B                   dec     HL              ; Point to MSB
4132+ 2DDD 7E                   ld      A,(HL)          ; Get MSB of dividend
4133+ 2DDE 32 73 80             ld      (DIV3),A        ; Save for subtraction
4134+ 2DE1 2B                   dec     HL
4135+ 2DE2 7E                   ld      A,(HL)          ; Get NMSB of dividend
4136+ 2DE3 32 6F 80             ld      (DIV2),A        ; Save for subtraction
4137+ 2DE6 2B                   dec     HL
4138+ 2DE7 7E                   ld      A,(HL)          ; Get MSB of dividend
4139+ 2DE8 32 6B 80             ld      (DIV1),A        ; Save for subtraction
4140+ 2DEB 41                   ld      B,C             ; Get MSB
4141+ 2DEC EB                   ex      DE,HL           ; NMSB,LSB to HL
4142+ 2DED AF                   xor     A
4143+ 2DEE 4F                   ld      C,A             ; Clear MSB of quotient
4144+ 2DEF 57                   ld      D,A             ; Clear NMSB of quotient
4145+ 2DF0 5F                   ld      E,A             ; Clear LSB of quotient
4146+ 2DF1 32 76 80             ld      (DIV4),A        ; Clear overflow count
4147+ 2DF4 E5           DIVLP:  push    HL              ; Save divisor
4148+ 2DF5 C5                   push    BC
4149+ 2DF6 7D                   ld      A,L             ; Get LSB of number
4150+ 2DF7 CD 6A 80             call    DIVSUP          ; Subt' divisor from dividend
4151+ 2DFA DE 00                sbc     A,$00           ; Count for overflows
4152+ 2DFC 3F                   ccf
4153+ 2DFD D2 07 2E             jp      NC,RESDIV       ; Restore divisor if borrow
4154+ 2E00 32 76 80             ld      (DIV4),A        ; Re-save overflow count
4155+ 2E03 F1                   pop     AF              ; Scrap divisor
4156+ 2E04 F1                   pop     AF
4157+ 2E05 37                   scf                     ; Set carry to
4158+ 2E06 D2                   defb    $D2             ; Skip "pop BC" and "pop HL"
4159+ 2E07
4160+ 2E07 C1           RESDIV: pop     BC              ; Restore divisor
4161+ 2E08 E1                   pop     HL
4162+ 2E09 79                   ld      A,C             ; Get MSB of quotient
4163+ 2E0A 3C                   inc     A
4164+ 2E0B 3D                   dec     A
4165+ 2E0C 1F                   rra                     ; Bit 0 to bit 7
4166+ 2E0D FA 69 2C             jp      M,RONDB         ; Done - Normalise result
4167+ 2E10 17                   rla                     ; Restore carry
4168+ 2E11 7B                   ld      A,E             ; Get LSB of quotient
4169+ 2E12 17                   rla                     ; Double it
4170+ 2E13 5F                   ld      E,A             ; Put it back
4171+ 2E14 7A                   ld      A,D             ; Get NMSB of quotient
4172+ 2E15 17                   rla                     ; Double it
4173+ 2E16 57                   ld      D,A             ; Put it back
4174+ 2E17 79                   ld      A,C             ; Get MSB of quotient
4175+ 2E18 17                   rla                     ; Double it
4176+ 2E19 4F                   ld      C,A             ; Put it back
4177+ 2E1A 29                   add     HL,HL           ; Double NMSB,LSB of divisor
4178+ 2E1B 78                   ld      A,B             ; Get MSB of divisor
4179+ 2E1C 17                   rla                     ; Double it
4180+ 2E1D 47                   ld      B,A             ; Put it back
4181+ 2E1E 3A 76 80             ld      A,(DIV4)        ; Get VLSB of quotient
4182+ 2E21 17                   rla                     ; Double it
4183+ 2E22 32 76 80             ld      (DIV4),A        ; Put it back
4184+ 2E25 79                   ld      A,C             ; Get MSB of quotient
4185+ 2E26 B2                   or      D               ; Merge NMSB
4186+ 2E27 B3                   or      E               ; Merge LSB
4187+ 2E28 C2 F4 2D             jp      NZ,DIVLP        ; Not done - Keep dividing
4188+ 2E2B E5                   push    HL              ; Save divisor
4189+ 2E2C 21 35 82             ld      HL,FPEXP        ; Point to exponent
4190+ 2E2F 35                   dec     (HL)            ; Divide by 2
4191+ 2E30 E1                   pop     HL              ; Restore divisor
4192+ 2E31 C2 F4 2D             jp      NZ,DIVLP        ; Ok - Keep going
4193+ 2E34 C3 CF 16             jp      OVERR           ; Overflow error
4194+ 2E37
4195+ 2E37
4196+ 2E37 78           ADDEXP: ld      A,B             ; Get exponent of dividend
4197+ 2E38 B7                   or      A               ; Test it
4198+ 2E39 CA 5B 2E             jp      Z,OVTST3        ; Zero - Result zero
4199+ 2E3C 7D                   ld      A,L             ; Get add/subtract flag
4200+ 2E3D 21 35 82             ld      HL,FPEXP        ; Point to exponent
4201+ 2E40 AE                   xor     (HL)            ; Add or subtract it
4202+ 2E41 80                   add     A,B             ; Add the other exponent
4203+ 2E42 47                   ld      B,A             ; Save new exponent
4204+ 2E43 1F                   rra                     ; Test exponent for overflow
4205+ 2E44 A8                   xor     B
4206+ 2E45 78                   ld      A,B             ; Get exponent
4207+ 2E46 F2 5A 2E             jp      P,OVTST2        ; Positive - Test for overflow
4208+ 2E49 C6 80                add     A,$80           ; Add excess 128
4209+ 2E4B 77                   ld      (HL),A          ; Save new exponent
4210+ 2E4C CA 69 2D             jp      Z,POPHRT        ; Zero - Result zero
4211+ 2E4F CD DF 2E             call    SIGNS           ; Set MSBs and sign of result
4212+ 2E52 77                   ld      (HL),A          ; Save new exponent
4213+ 2E53 2B                   dec     HL              ; Point to MSB
4214+ 2E54 C9                   ret
4215+ 2E55
4216+ 2E55 CD 79 2E     OVTST1: call    TSTSGN          ; Test sign of FPREG
4217+ 2E58 2F                   cpl                     ; Invert sign
4218+ 2E59 E1                   pop     HL              ; Clean up stack
4219+ 2E5A B7           OVTST2: or      A               ; Test if new exponent zero
4220+ 2E5B E1           OVTST3: pop     HL              ; Clear off return address
4221+ 2E5C F2 48 2C             jp      P,RESZER        ; Result zero
4222+ 2E5F C3 CF 16             jp      OVERR           ; Overflow error
4223+ 2E62
4224+ 2E62 CD C5 2E     MLSP10: call    BCDEFP          ; Move FPREG to BCDE
4225+ 2E65 78                   ld      A,B             ; Get exponent
4226+ 2E66 B7                   or      A               ; Is it zero?
4227+ 2E67 C8                   ret     Z               ; Yes - Result is zero
4228+ 2E68 C6 02                add     A,$02           ; Multiply by 4
4229+ 2E6A DA CF 16             jp      C,OVERR         ; Overflow - ?OV Error
4230+ 2E6D 47                   ld      B,A             ; Re-save exponent
4231+ 2E6E CD E2 2B             call    FPADD           ; Add BCDE to FPREG (Times 5)
4232+ 2E71 21 35 82             ld      HL,FPEXP        ; Point to exponent
4233+ 2E74 34                   inc     (HL)            ; Double number (Times 10)
4234+ 2E75 C0                   ret     NZ              ; Ok - Return
4235+ 2E76 C3 CF 16             jp      OVERR           ; Overflow error
4236+ 2E79
4237+ 2E79 3A 35 82     TSTSGN: ld      A,(FPEXP)       ; Get sign of FPREG
4238+ 2E7C B7                   or      A
4239+ 2E7D C8                   ret     Z               ; RETurn if number is zero
4240+ 2E7E 3A 34 82             ld      A,(FPREG+2)     ; Get MSB of FPREG
4241+ 2E81 FE                   defb    0FEH            ; Test sign
4242+ 2E82 2F           RETREL: cpl                     ; Invert sign
4243+ 2E83 17                   rla                     ; Sign bit to carry
4244+ 2E84 9F           FLGDIF: sbc     A,A             ; Carry to all bits of A
4245+ 2E85 C0                   ret     NZ              ; Return -1 if negative
4246+ 2E86 3C                   inc     A               ; Bump to +1
4247+ 2E87 C9                   ret                     ; Positive - Return +1
4248+ 2E88
4249+ 2E88 CD 79 2E     SGN:    call    TSTSGN          ; Test sign of FPREG
4250+ 2E8B 06 88        FLGREL: ld      B,$80+8         ; 8 bit integer in exponent
4251+ 2E8D 11 00 00             ld      DE,0            ; Zero NMSB and LSB
4252+ 2E90 21 35 82     RETINT: ld      HL,FPEXP        ; Point to exponent
4253+ 2E93 4F                   ld      C,A             ; CDE = MSB,NMSB and LSB
4254+ 2E94 70                   ld      (HL),B          ; Save exponent
4255+ 2E95 06 00                ld      B,0             ; CDE = integer to normalise
4256+ 2E97 23                   inc     HL              ; Point to sign of result
4257+ 2E98 36 80                ld      (HL),$80        ; Set sign of result
4258+ 2E9A 17                   rla                     ; Carry = sign of integer
4259+ 2E9B C3 30 2C             jp      CONPOS          ; Set sign of result
4260+ 2E9E
4261+ 2E9E CD 79 2E     ABS_:   call    TSTSGN          ; Test sign of FPREG
4262+ 2EA1 F0                   ret     P               ; Return if positive
4263+ 2EA2 21 34 82     INVSGN: ld      HL,FPREG+2      ; Point to MSB
4264+ 2EA5 7E                   ld      A,(HL)          ; Get sign of mantissa
4265+ 2EA6 EE 80                xor     $80             ; Invert sign of mantissa
4266+ 2EA8 77                   ld      (HL),A          ; Re-save sign of mantissa
4267+ 2EA9 C9                   ret
4268+ 2EAA
4269+ 2EAA EB           STAKFP: ex      DE,HL           ; Save code string address
4270+ 2EAB 2A 32 82             ld      HL,(FPREG)      ; LSB,NLSB of FPREG
4271+ 2EAE E3                   ex      (SP),HL         ; Stack them,get return
4272+ 2EAF E5                   push    HL              ; Re-save return
4273+ 2EB0 2A 34 82             ld      HL,(FPREG+2)    ; MSB and exponent of FPREG
4274+ 2EB3 E3                   ex      (SP),HL         ; Stack them,get return
4275+ 2EB4 E5                   push    HL              ; Re-save return
4276+ 2EB5 EB                   ex      DE,HL           ; Restore code string address
4277+ 2EB6 C9                   ret
4278+ 2EB7
4279+ 2EB7              ; store F.P. number from BCDE into FPREG
4280+ 2EB7 CD C8 2E     PHLTFP: call    LOADFP          ; Number at HL to BCDE
4281+ 2EBA EB           FPBCDE: ex      DE,HL           ; Save code string address
4282+ 2EBB 22 32 82             ld      (FPREG),HL      ; Save LSB,NLSB of number
4283+ 2EBE 60                   ld      H,B             ; Exponent of number
4284+ 2EBF 69                   ld      L,C             ; MSB of number
4285+ 2EC0 22 34 82             ld      (FPREG+2),HL    ; Save MSB and exponent
4286+ 2EC3 EB                   ex      DE,HL           ; Restore code string address
4287+ 2EC4 C9                   ret
4288+ 2EC5
4289+ 2EC5              ; load F.P. number from FPREG into BCDE
4290+ 2EC5 21 32 82     BCDEFP: ld      HL,FPREG        ; Point to FPREG
4291+ 2EC8 5E           LOADFP: ld      E,(HL)          ; Get LSB of number
4292+ 2EC9 23                   inc     HL
4293+ 2ECA 56                   ld      D,(HL)          ; Get NMSB of number
4294+ 2ECB 23                   inc     HL
4295+ 2ECC 4E                   ld      C,(HL)          ; Get MSB of number
4296+ 2ECD 23                   inc     HL
4297+ 2ECE 46                   ld      B,(HL)          ; Get exponent of number
4298+ 2ECF 23           INCHL:  inc     HL              ; Used for conditional "inc HL"
4299+ 2ED0 C9                   ret
4300+ 2ED1
4301+ 2ED1 11 32 82     FPTHL:  ld      DE,FPREG        ; Point to FPREG
4302+ 2ED4 06 04        DETHL4: ld      B,$04           ; 4 bytes to move
4303+ 2ED6 1A           DETHLB: ld      A,(DE)          ; Get source
4304+ 2ED7 77                   ld      (HL),A          ; Save destination
4305+ 2ED8 13                   inc     DE              ; Next source
4306+ 2ED9 23                   inc     HL              ; Next destination
4307+ 2EDA 05                   dec     B               ; Count bytes
4308+ 2EDB C2 D6 2E             jp      NZ,DETHLB       ; Loop if more
4309+ 2EDE C9                   ret
4310+ 2EDF
4311+ 2EDF 21 34 82     SIGNS:  ld      HL,FPREG+2      ; Point to MSB of FPREG
4312+ 2EE2 7E                   ld      A,(HL)          ; Get MSB
4313+ 2EE3 07                   rlca                    ; Old sign to carry
4314+ 2EE4 37                   scf                     ; Set MSBit
4315+ 2EE5 1F                   rra                     ; Set MSBit of MSB
4316+ 2EE6 77                   ld      (HL),A          ; Save new MSB
4317+ 2EE7 3F                   ccf                     ; Complement sign
4318+ 2EE8 1F                   rra                     ; Old sign to carry
4319+ 2EE9 23                   inc     HL
4320+ 2EEA 23                   inc     HL
4321+ 2EEB 77                   ld      (HL),A          ; Set sign of result
4322+ 2EEC 79                   ld      A,C             ; Get MSB
4323+ 2EED 07                   rlca                    ; Old sign to carry
4324+ 2EEE 37                   scf                     ; Set MSBit
4325+ 2EEF 1F                   rra                     ; Set MSBit of MSB
4326+ 2EF0 4F                   ld      C,A             ; Save MSB
4327+ 2EF1 1F                   rra
4328+ 2EF2 AE                   xor     (HL)            ; New sign of result
4329+ 2EF3 C9                   ret
4330+ 2EF4
4331+ 2EF4 78           CMPNUM: ld      A,B             ; Get exponent of number
4332+ 2EF5 B7                   or      A
4333+ 2EF6 CA 79 2E             jp      Z,TSTSGN        ; Zero - Test sign of FPREG
4334+ 2EF9 21 82 2E             ld      HL,RETREL       ; Return relation routine
4335+ 2EFC E5                   push    HL              ; Save for return
4336+ 2EFD CD 79 2E             call    TSTSGN          ; Test sign of FPREG
4337+ 2F00 79                   ld      A,C             ; Get MSB of number
4338+ 2F01 C8                   ret     Z               ; FPREG zero - Number's MSB
4339+ 2F02 21 34 82             ld      HL,FPREG+2      ; MSB of FPREG
4340+ 2F05 AE                   xor     (HL)            ; Combine signs
4341+ 2F06 79                   ld      A,C             ; Get MSB of number
4342+ 2F07 F8                   ret     M               ; Exit if signs different
4343+ 2F08 CD 0E 2F             call    CMPFP           ; Compare FP numbers
4344+ 2F0B 1F                   rra                     ; Get carry to sign
4345+ 2F0C A9                   xor     C               ; Combine with MSB of number
4346+ 2F0D C9                   ret
4347+ 2F0E
4348+ 2F0E 23           CMPFP:  inc     HL              ; Point to exponent
4349+ 2F0F 78                   ld      A,B             ; Get exponent
4350+ 2F10 BE                   cp      (HL)            ; Compare exponents
4351+ 2F11 C0                   ret     NZ              ; Different
4352+ 2F12 2B                   dec     HL              ; Point to MBS
4353+ 2F13 79                   ld      A,C             ; Get MSB
4354+ 2F14 BE                   cp      (HL)            ; Compare MSBs
4355+ 2F15 C0                   ret     NZ              ; Different
4356+ 2F16 2B                   dec     HL              ; Point to NMSB
4357+ 2F17 7A                   ld      A,D             ; Get NMSB
4358+ 2F18 BE                   cp      (HL)            ; Compare NMSBs
4359+ 2F19 C0                   ret     NZ              ; Different
4360+ 2F1A 2B                   dec     HL              ; Point to LSB
4361+ 2F1B 7B                   ld      A,E             ; Get LSB
4362+ 2F1C 96                   sub     (HL)            ; Compare LSBs
4363+ 2F1D C0                   ret     NZ              ; Different
4364+ 2F1E E1                   pop     HL              ; Drop RETurn
4365+ 2F1F E1                   pop     HL              ; Drop another RETurn
4366+ 2F20 C9                   ret
4367+ 2F21
4368+ 2F21 47           FPINT:  ld      B,A             ; <- Move
4369+ 2F22 4F                   ld      C,A             ; <- exponent
4370+ 2F23 57                   ld      D,A             ; <- to all
4371+ 2F24 5F                   ld      E,A             ; <- bits
4372+ 2F25 B7                   or      A               ; Test exponent
4373+ 2F26 C8                   ret     Z               ; Zero - Return zero
4374+ 2F27 E5                   push    HL              ; Save pointer to number
4375+ 2F28 CD C5 2E             call    BCDEFP          ; Move FPREG to BCDE
4376+ 2F2B CD DF 2E             call    SIGNS           ; Set MSBs & sign of result
4377+ 2F2E AE                   xor     (HL)            ; Combine with sign of FPREG
4378+ 2F2F 67                   ld      H,A             ; Save combined signs
4379+ 2F30 FC 45 2F             call    M,DCBCDE        ; Negative - Decrement BCDE
4380+ 2F33 3E 98                ld      A,$80+24        ; 24 bits
4381+ 2F35 90                   sub     B               ; Bits to shift
4382+ 2F36 CD A7 2C             call    SCALE           ; Shift BCDE
4383+ 2F39 7C                   ld      A,H             ; Get combined sign
4384+ 2F3A 17                   rla                     ; Sign to carry
4385+ 2F3B DC 7A 2C             call    C,FPROND        ; Negative - Round number up
4386+ 2F3E 06 00                ld      B,$00           ; Zero exponent
4387+ 2F40 DC 93 2C             call    C,COMPL         ; If negative make positive
4388+ 2F43 E1                   pop     HL              ; Restore pointer to number
4389+ 2F44 C9                   ret
4390+ 2F45
4391+ 2F45 1B           DCBCDE: dec     DE              ; Decrement BCDE
4392+ 2F46 7A                   ld      A,D             ; Test LSBs
4393+ 2F47 A3                   and     E
4394+ 2F48 3C                   inc     A
4395+ 2F49 C0                   ret     NZ              ; Exit if LSBs not FFFF
4396+ 2F4A 0B                   dec     BC              ; Decrement MSBs
4397+ 2F4B C9                   ret
4398+ 2F4C
4399+ 2F4C 21 35 82     INT:    ld      HL,FPEXP        ; Point to exponent
4400+ 2F4F 7E                   ld      A,(HL)          ; Get exponent
4401+ 2F50 FE 98                cp      $80+24          ; Integer accuracy only?
4402+ 2F52 3A 32 82             ld      A,(FPREG)       ; Get LSB
4403+ 2F55 D0                   ret     NC              ; Yes - Already integer
4404+ 2F56 7E                   ld      A,(HL)          ; Get exponent
4405+ 2F57 CD 21 2F             call    FPINT           ; F.P to integer
4406+ 2F5A 36 98                ld      (HL),$80+24     ; Save 24 bit integer
4407+ 2F5C 7B                   ld      A,E             ; Get LSB of number
4408+ 2F5D F5                   push    AF              ; Save LSB
4409+ 2F5E 79                   ld      A,C             ; Get MSB of number
4410+ 2F5F 17                   rla                     ; Sign to carry
4411+ 2F60 CD 30 2C             call    CONPOS          ; Set sign of result
4412+ 2F63 F1                   pop     AF              ; Restore LSB of number
4413+ 2F64 C9                   ret
4414+ 2F65
4415+ 2F65 21 00 00     MLDEBC: ld      HL,$0000        ; Clear partial product
4416+ 2F68 78                   ld      A,B             ; Test multiplier
4417+ 2F69 B1                   or      C
4418+ 2F6A C8                   ret     Z               ; Return zero if zero
4419+ 2F6B 3E 10                ld      A,$10           ; 16 bits
4420+ 2F6D 29           MLDBLP: add     HL,HL           ; Shift P.P left
4421+ 2F6E DA 93 23             jp      C,BSERR         ; ?BS Error if overflow
4422+ 2F71 EB                   ex      DE,HL
4423+ 2F72 29                   add     HL,HL           ; Shift multiplier left
4424+ 2F73 EB                   ex      DE,HL
4425+ 2F74 D2 7B 2F             jp      NC,NOMLAD       ; Bit was zero - No add
4426+ 2F77 09                   add     HL,BC           ; Add multiplicand
4427+ 2F78 DA 93 23             jp      C,BSERR         ; ?BS Error if overflow
4428+ 2F7B 3D           NOMLAD: dec     A               ; Count bits
4429+ 2F7C C2 6D 2F             jp      NZ,MLDBLP       ; More
4430+ 2F7F C9                   ret
4431+ 2F80
4432+ 2F80 FE 2D        ASCTFP: cp      '-'             ; Negative?
4433+ 2F82 F5                   push    AF              ; Save it and flags
4434+ 2F83 CA 8C 2F             jp      Z,CNVNUM        ; Yes - Convert number
4435+ 2F86 FE 2B                cp      '+'             ; Positive?
4436+ 2F88 CA 8C 2F             jp      Z,CNVNUM        ; Yes - Convert number
4437+ 2F8B 2B                   dec     HL              ; dec 'cos GETCHR INCs
4438+ 2F8C CD 48 2C     CNVNUM: call    RESZER          ; Set result to zero
4439+ 2F8F 47                   ld      B,A             ; Digits after point counter
4440+ 2F90 57                   ld      D,A             ; Sign of exponent
4441+ 2F91 5F                   ld      E,A             ; Exponent of ten
4442+ 2F92 2F                   cpl
4443+ 2F93 4F                   ld      C,A             ; Before or after point flag
4444+ 2F94 CD E3 1B     MANLP:  call    GETCHR          ; Get next character
4445+ 2F97 DA DD 2F             jp      C,ADDIG         ; Digit - Add to number
4446+ 2F9A FE 2E                cp      '.'
4447+ 2F9C CA B8 2F             jp      Z,DPOINT        ; '.' - Flag point
4448+ 2F9F FE 45                cp      'E'
4449+ 2FA1 C2 BC 2F             jp      NZ,CONEXP       ; Not 'E' - Scale number
4450+ 2FA4 CD E3 1B             call    GETCHR          ; Get next character
4451+ 2FA7 CD AF 21             call    SGNEXP          ; Get sign of exponent
4452+ 2FAA CD E3 1B     EXPLP:  call    GETCHR          ; Get next character
4453+ 2FAD DA FF 2F             jp      C,EDIGIT        ; Digit - Add to exponent
4454+ 2FB0 14                   inc     D               ; Is sign negative?
4455+ 2FB1 C2 BC 2F             jp      NZ,CONEXP       ; No - Scale number
4456+ 2FB4 AF                   xor     A
4457+ 2FB5 93                   sub     E               ; Negate exponent
4458+ 2FB6 5F                   ld      E,A             ; And re-save it
4459+ 2FB7 0C                   inc     C               ; Flag end of number
4460+ 2FB8 0C           DPOINT: inc     C               ; Flag point passed
4461+ 2FB9 CA 94 2F             jp      Z,MANLP         ; Zero - Get another digit
4462+ 2FBC E5           CONEXP: push    HL              ; Save code string address
4463+ 2FBD 7B                   ld      A,E             ; Get exponent
4464+ 2FBE 90                   sub     B               ; Subtract digits after point
4465+ 2FBF F4 D5 2F     SCALMI: call    P,SCALPL        ; Positive - Multiply number
4466+ 2FC2 F2 CB 2F             jp      P,ENDCON        ; Positive - All done
4467+ 2FC5 F5                   push    AF              ; Save number of times to /10
4468+ 2FC6 CD C1 2D             call    DIV10           ; Divide by 10
4469+ 2FC9 F1                   pop     AF              ; Restore count
4470+ 2FCA 3C                   inc     A               ; Count divides
4471+ 2FCB
4472+ 2FCB C2 BF 2F     ENDCON: jp      NZ,SCALMI       ; More to do
4473+ 2FCE D1                   pop     DE              ; Restore code string address
4474+ 2FCF F1                   pop     AF              ; Restore sign of number
4475+ 2FD0 CC A2 2E             call    Z,INVSGN        ; Negative - Negate number
4476+ 2FD3 EB                   ex      DE,HL           ; Code string address to HL
4477+ 2FD4 C9                   ret
4478+ 2FD5
4479+ 2FD5 C8           SCALPL: ret     Z               ; Exit if no scaling needed
4480+ 2FD6 F5           MULTEN: push    AF              ; Save count
4481+ 2FD7 CD 62 2E             call    MLSP10          ; Multiply number by 10
4482+ 2FDA F1                   pop     AF              ; Restore count
4483+ 2FDB 3D                   dec     A               ; Count multiplies
4484+ 2FDC C9                   ret
4485+ 2FDD
4486+ 2FDD D5           ADDIG:  push    DE              ; Save sign of exponent
4487+ 2FDE 57                   ld      D,A             ; Save digit
4488+ 2FDF 78                   ld      A,B             ; Get digits after point
4489+ 2FE0 89                   adc     A,C             ; Add one if after point
4490+ 2FE1 47                   ld      B,A             ; Re-save counter
4491+ 2FE2 C5                   push    BC              ; Save point flags
4492+ 2FE3 E5                   push    HL              ; Save code string address
4493+ 2FE4 D5                   push    DE              ; Save digit
4494+ 2FE5 CD 62 2E             call    MLSP10          ; Multiply number by 10
4495+ 2FE8 F1                   pop     AF              ; Restore digit
4496+ 2FE9 D6 30                sub     '0'             ; Make it absolute
4497+ 2FEB CD F4 2F             call    RSCALE          ; Re-scale number
4498+ 2FEE E1                   pop     HL              ; Restore code string address
4499+ 2FEF C1                   pop     BC              ; Restore point flags
4500+ 2FF0 D1                   pop     DE              ; Restore sign of exponent
4501+ 2FF1 C3 94 2F             jp      MANLP           ; Get another digit
4502+ 2FF4
4503+ 2FF4 CD AA 2E     RSCALE: call    STAKFP          ; Put number on stack
4504+ 2FF7 CD 8B 2E             call    FLGREL          ; Digit to add to FPREG
4505+ 2FFA C1           PADD:   pop     BC              ; Restore number
4506+ 2FFB D1                   pop     DE
4507+ 2FFC C3 E2 2B             jp      FPADD           ; Add BCDE to FPREG and return
4508+ 2FFF
4509+ 2FFF 7B           EDIGIT: ld      A,E             ; Get digit
4510+ 3000 07                   rlca                    ; Times 2
4511+ 3001 07                   rlca                    ; Times 4
4512+ 3002 83                   add     A,E             ; Times 5
4513+ 3003 07                   rlca                    ; Times 10
4514+ 3004 86                   add     A,(HL)          ; Add next digit
4515+ 3005 D6 30                sub     '0'             ; Make it absolute
4516+ 3007 5F                   ld      E,A             ; Save new digit
4517+ 3008 C3 AA 2F             jp      EXPLP           ; Look for another digit
4518+ 300B
4519+ 300B E5           LINEIN: push    HL              ; Save code string address
4520+ 300C 21 39 16             ld      HL,INMSG        ; Output " in "
4521+ 300F CD 74 25             call    PRS             ; Output string at HL
4522+ 3012 E1                   pop     HL              ; Restore code string address
4523+ 3013 EB           PRNTHL: ex      DE,HL           ; Code string address to DE
4524+ 3014 AF                   xor     A
4525+ 3015 06 98                ld      B,$80+24        ; 24 bits
4526+ 3017 CD 90 2E             call    RETINT          ; Return the integer
4527+ 301A 21 73 25             ld      HL,PRNUMS       ; Print number string
4528+ 301D E5                   push    HL              ; Save for return
4529+ 301E 21 37 82     NUMASC: ld      HL,PBUFF        ; Convert number to ASCII
4530+ 3021 E5                   push    HL              ; Save for return
4531+ 3022 CD 79 2E             call    TSTSGN          ; Test sign of FPREG
4532+ 3025 36 20                ld      (HL),SPC        ; Space at start
4533+ 3027 F2 2C 30             jp      P,SPCFST        ; Positive - Space to start
4534+ 302A 36 2D                ld      (HL),'-'        ; '-' sign at start
4535+ 302C 23           SPCFST: inc     HL              ; First byte of number
4536+ 302D 36 30                ld      (HL),'0'        ; '0' if zero
4537+ 302F CA E2 30             jp      Z,JSTZER        ; Return '0' if zero
4538+ 3032 E5                   push    HL              ; Save buffer address
4539+ 3033 FC A2 2E             call    M,INVSGN        ; Negate FPREG if negative
4540+ 3036 AF                   xor     A               ; Zero A
4541+ 3037 F5                   push    AF              ; Save it
4542+ 3038 CD E8 30             call    RNGTST          ; Test number is in range
4543+ 303B 01 43 91     SIXDIG: ld      BC,$9143        ; BCDE - 99999.9
4544+ 303E 11 F8 4F             ld      DE,$4FF8
4545+ 3041 CD F4 2E             call    CMPNUM          ; Compare numbers
4546+ 3044 B7                   or      A
4547+ 3045 E2 59 30             jp      PO,INRNG        ; > 99999.9 - Sort it out
4548+ 3048 F1                   pop     AF              ; Restore count
4549+ 3049 CD D6 2F             call    MULTEN          ; Multiply by ten
4550+ 304C F5                   push    AF              ; Re-save count
4551+ 304D C3 3B 30             jp      SIXDIG          ; Test it again
4552+ 3050
4553+ 3050 CD C1 2D     GTSIXD: call    DIV10           ; Divide by 10
4554+ 3053 F1                   pop     AF              ; Get count
4555+ 3054 3C                   inc     A               ; Count divides
4556+ 3055 F5                   push    AF              ; Re-save count
4557+ 3056 CD E8 30             call    RNGTST          ; Test number is in range
4558+ 3059 CD D0 2B     INRNG:  call    ROUND           ; Add 0.5 to FPREG
4559+ 305C 3C                   inc     A
4560+ 305D CD 21 2F             call    FPINT           ; F.P to integer
4561+ 3060 CD BA 2E             call    FPBCDE          ; Move BCDE to FPREG
4562+ 3063 01 06 03             ld      BC,$0306        ; 1E+06 to 1E-03 range
4563+ 3066 F1                   pop     AF              ; Restore count
4564+ 3067 81                   add     A,C             ; 6 digits before point
4565+ 3068 3C                   inc     A               ; Add one
4566+ 3069 FA 75 30             jp      M,MAKNUM        ; Do it in 'E' form if < 1E-02
4567+ 306C FE 08                cp      6+1+1           ; More than 999999 ?
4568+ 306E D2 75 30             jp      NC,MAKNUM       ; Yes - Do it in 'E' form
4569+ 3071 3C                   inc     A               ; Adjust for exponent
4570+ 3072 47                   ld      B,A             ; Exponent of number
4571+ 3073 3E 02                ld      A,2             ; Make it zero after
4572+ 3075
4573+ 3075 3D           MAKNUM: dec     A               ; Adjust for digits to do
4574+ 3076 3D                   dec     A
4575+ 3077 E1                   pop     HL              ; Restore buffer address
4576+ 3078 F5                   push    AF              ; Save count
4577+ 3079 11 FB 30             ld      DE,POWERS       ; Powers of ten
4578+ 307C 05                   dec     B               ; Count digits before point
4579+ 307D C2 86 30             jp      NZ,DIGTXT       ; Not zero - Do number
4580+ 3080 36 2E                ld      (HL),'.'        ; Save point
4581+ 3082 23                   inc     HL              ; Move on
4582+ 3083 36 30                ld      (HL),'0'        ; Save zero
4583+ 3085 23                   inc     HL              ; Move on
4584+ 3086 05           DIGTXT: dec     B               ; Count digits before point
4585+ 3087 36 2E                ld      (HL),'.'        ; Save point in case
4586+ 3089 CC CF 2E             call    Z,INCHL         ; Last digit - move on
4587+ 308C C5                   push    BC              ; Save digits before point
4588+ 308D E5                   push    HL              ; Save buffer address
4589+ 308E D5                   push    DE              ; Save powers of ten
4590+ 308F CD C5 2E             call    BCDEFP          ; Move FPREG to BCDE
4591+ 3092 E1                   pop     HL              ; Powers of ten table
4592+ 3093 06 2F                ld      B,'0'-1         ; ASCII '0' - 1
4593+ 3095 04           TRYAGN: inc     B               ; Count subtractions
4594+ 3096 7B                   ld      A,E             ; Get LSB
4595+ 3097 96                   sub     (HL)            ; Subtract LSB
4596+ 3098 5F                   ld      E,A             ; Save LSB
4597+ 3099 23                   inc     HL
4598+ 309A 7A                   ld      A,D             ; Get NMSB
4599+ 309B 9E                   sbc     A,(HL)          ; Subtract NMSB
4600+ 309C 57                   ld      D,A             ; Save NMSB
4601+ 309D 23                   inc     HL
4602+ 309E 79                   ld      A,C             ; Get MSB
4603+ 309F 9E                   sbc     A,(HL)          ; Subtract MSB
4604+ 30A0 4F                   ld      C,A             ; Save MSB
4605+ 30A1 2B                   dec     HL              ; Point back to start
4606+ 30A2 2B                   dec     HL
4607+ 30A3 D2 95 30             jp      NC,TRYAGN       ; No overflow - Try again
4608+ 30A6 CD 87 2C             call    PLUCDE          ; Restore number
4609+ 30A9 23                   inc     HL              ; Start of next number
4610+ 30AA CD BA 2E             call    FPBCDE          ; Move BCDE to FPREG
4611+ 30AD EB                   ex      DE,HL           ; Save point in table
4612+ 30AE E1                   pop     HL              ; Restore buffer address
4613+ 30AF 70                   ld      (HL),B          ; Save digit in buffer
4614+ 30B0 23                   inc     HL              ; And move on
4615+ 30B1 C1                   pop     BC              ; Restore digit count
4616+ 30B2 0D                   dec     C               ; Count digits
4617+ 30B3 C2 86 30             jp      NZ,DIGTXT       ; More - Do them
4618+ 30B6 05                   dec     B               ; Any decimal part?
4619+ 30B7 CA C6 30             jp      Z,DOEBIT        ; No - Do 'E' bit
4620+ 30BA 2B           SUPTLZ: dec     HL              ; Move back through buffer
4621+ 30BB 7E                   ld      A,(HL)          ; Get character
4622+ 30BC FE 30                cp      '0'             ; '0' character?
4623+ 30BE CA BA 30             jp      Z,SUPTLZ        ; Yes - Look back for more
4624+ 30C1 FE 2E                cp      '.'             ; A decimal point?
4625+ 30C3 C4 CF 2E             call    NZ,INCHL        ; Move back over digit
4626+ 30C6
4627+ 30C6 F1           DOEBIT: pop     AF              ; Get 'E' flag
4628+ 30C7 CA E5 30             jp      Z,NOENED        ; No 'E' needed - End buffer
4629+ 30CA 36 45                ld      (HL),'E'        ; Put 'E' in buffer
4630+ 30CC 23                   inc     HL              ; And move on
4631+ 30CD 36 2B                ld      (HL),'+'        ; Put '+' in buffer
4632+ 30CF F2 D6 30             jp      P,OUTEXP        ; Positive - Output exponent
4633+ 30D2 36 2D                ld      (HL),'-'        ; Put '-' in buffer
4634+ 30D4 2F                   cpl                     ; Negate exponent
4635+ 30D5 3C                   inc     A
4636+ 30D6 06 2F        OUTEXP: ld      B,'0'-1         ; ASCII '0' - 1
4637+ 30D8 04           EXPTEN: inc     B               ; Count subtractions
4638+ 30D9 D6 0A                sub     $0A             ; Tens digit
4639+ 30DB D2 D8 30             jp      NC,EXPTEN       ; More to do
4640+ 30DE C6 3A                add     A,'0'+10        ; Restore and make ASCII
4641+ 30E0 23                   inc     HL              ; Move on
4642+ 30E1 70                   ld      (HL),B          ; Save MSB of exponent
4643+ 30E2 23           JSTZER: inc     HL              ;
4644+ 30E3 77                   ld      (HL),A          ; Save LSB of exponent
4645+ 30E4 23                   inc     HL
4646+ 30E5 71           NOENED: ld      (HL),C          ; Mark end of buffer
4647+ 30E6 E1                   pop     HL              ; Restore code string address
4648+ 30E7 C9                   ret
4649+ 30E8
4650+ 30E8 01 74 94     RNGTST: ld      BC,$9474        ; BCDE = 999999.
4651+ 30EB 11 F7 23             ld      DE,$23F7
4652+ 30EE CD F4 2E             call    CMPNUM          ; Compare numbers
4653+ 30F1 B7                   or      A
4654+ 30F2 E1                   pop     HL              ; Return address to HL
4655+ 30F3 E2 50 30             jp      PO,GTSIXD       ; Too big - Divide by ten
4656+ 30F6 E9                   jp      (HL)            ; Otherwise return to caller
4657+ 30F7
4658+ 30F7 00 00 00 80  HALF:   defb    $00,$00,$00,$80 ; 0.5
4659+ 30FB
4660+ 30FB A0 86 01     POWERS: defb    $A0,$86,$01  ; 100000
4661+ 30FE 10 27 00             defb    $10,$27,$00  ;  10000
4662+ 3101 E8 03 00             defb    $E8,$03,$00  ;   1000
4663+ 3104 64 00 00             defb    $64,$00,$00  ;    100
4664+ 3107 0A 00 00             defb    $0A,$00,$00  ;     10
4665+ 310A 01 00 00             defb    $01,$00,$00  ;      1
4666+ 310D
4667+ 310D 21 A2 2E     NEGAFT: ld      HL,INVSGN       ; Negate result
4668+ 3110 E3                   ex      (SP),HL         ; To be done after caller
4669+ 3111 E9                   jp      (HL)            ; Return to caller
4670+ 3112
4671+ 3112 CD AA 2E     SQR:    call    STAKFP          ; Put value on stack
4672+ 3115 21 F7 30             ld      HL,HALF         ; Set power to 1/2
4673+ 3118 CD B7 2E             call    PHLTFP          ; Move 1/2 to FPREG
4674+ 311B
4675+ 311B C1           POWER:  pop     BC              ; Get base
4676+ 311C D1                   pop     DE
4677+ 311D CD 79 2E             call    TSTSGN          ; Test sign of power
4678+ 3120 78                   ld      A,B             ; Get exponent of base
4679+ 3121 CA 60 31             jp      Z,EXP           ; Make result 1 if zero
4680+ 3124 F2 2B 31             jp      P,POWER1        ; Positive base - Ok
4681+ 3127 B7                   or      A               ; Zero to negative power?
4682+ 3128 CA C3 16             jp      Z,DZERR         ; Yes - ?/0 Error
4683+ 312B B7           POWER1: or      A               ; Base zero?
4684+ 312C CA 49 2C             jp      Z,SAVEXP        ; Yes - Return zero
4685+ 312F D5                   push    DE              ; Save base
4686+ 3130 C5                   push    BC
4687+ 3131 79                   ld      A,C             ; Get MSB of base
4688+ 3132 F6 7F                or      %01111111       ; Get sign status
4689+ 3134 CD C5 2E             call    BCDEFP          ; Move power to BCDE
4690+ 3137 F2 48 31             jp      P,POWER2        ; Positive base - Ok
4691+ 313A D5                   push    DE              ; Save power
4692+ 313B C5                   push    BC
4693+ 313C CD 4C 2F             call    INT             ; Get integer of power
4694+ 313F C1                   pop     BC              ; Restore power
4695+ 3140 D1                   pop     DE
4696+ 3141 F5                   push    AF              ; MSB of base
4697+ 3142 CD F4 2E             call    CMPNUM          ; Power an integer?
4698+ 3145 E1                   pop     HL              ; Restore MSB of base
4699+ 3146 7C                   ld      A,H             ; but don't affect flags
4700+ 3147 1F                   rra                     ; Exponent odd or even?
4701+ 3148 E1           POWER2: pop     HL              ; Restore MSB and exponent
4702+ 3149 22 34 82             ld      (FPREG+2),HL    ; Save base in FPREG
4703+ 314C E1                   pop     HL              ; LSBs of base
4704+ 314D 22 32 82             ld      (FPREG),HL      ; Save in FPREG
4705+ 3150 DC 0D 31             call    C,NEGAFT        ; Odd power - Negate result
4706+ 3153 CC A2 2E             call    Z,INVSGN        ; Negative base - Negate it
4707+ 3156 D5                   push    DE              ; Save power
4708+ 3157 C5                   push    BC
4709+ 3158 CD DC 2C             call    LOG             ; Get LOG of base
4710+ 315B C1                   pop     BC              ; Restore power
4711+ 315C D1                   pop     DE
4712+ 315D CD 1D 2D             call    FPMULT          ; Multiply LOG by power
4713+ 3160
4714+ 3160 CD AA 2E     EXP:    call    STAKFP          ; Put value on stack
4715+ 3163 01 38 81             ld      BC,$8138        ; BCDE = 1/Ln(2)
4716+ 3166 11 3B AA             ld      DE,$AA3B
4717+ 3169 CD 1D 2D             call    FPMULT          ; Multiply value by 1/LN(2)
4718+ 316C 3A 35 82             ld      A,(FPEXP)       ; Get exponent
4719+ 316F FE 88                cp      $80+8           ; Is it in range?
4720+ 3171 D2 55 2E             jp      NC,OVTST1       ; No - Test for overflow
4721+ 3174 CD 4C 2F             call    INT             ; Get INT of FPREG
4722+ 3177 C6 80                add     A,$80           ; For excess 128
4723+ 3179 C6 02                add     A,$02           ; Exponent > 126?
4724+ 317B DA 55 2E             jp      C,OVTST1        ; Yes - Test for overflow
4725+ 317E F5                   push    AF              ; Save scaling factor
4726+ 317F 21 CB 2C             ld      HL,UNITY        ; Point to 1.
4727+ 3182 CD D3 2B             call    ADDPHL          ; Add 1 to FPREG
4728+ 3185 CD 14 2D             call    MULLN2          ; Multiply by LN(2)
4729+ 3188 F1                   pop     AF              ; Restore scaling factor
4730+ 3189 C1                   pop     BC              ; Restore exponent
4731+ 318A D1                   pop     DE
4732+ 318B F5                   push    AF              ; Save scaling factor
4733+ 318C CD DF 2B             call    SUBCDE          ; Subtract exponent from FPREG
4734+ 318F CD A2 2E             call    INVSGN          ; Negate result
4735+ 3192 21 A0 31             ld      HL,EXPTAB       ; Coefficient table
4736+ 3195 CD D0 31             call    SMSER1          ; Sum the series
4737+ 3198 11 00 00             ld      DE,$0000        ; Zero LSBs
4738+ 319B C1                   pop     BC              ; Scaling factor
4739+ 319C 4A                   ld      C,D             ; Zero MSB
4740+ 319D C3 1D 2D             jp      FPMULT          ; Scale result to correct value
4741+ 31A0
4742+ 31A0 08           EXPTAB: defb    $08             ; Table used by EXP
4743+ 31A1 40 2E 94 74          defb    $40,$2E,$94,$74 ; -1/7! (-1/5040)
4744+ 31A5 70 4F 2E 77          defb    $70,$4F,$2E,$77 ;  1/6! ( 1/720)
4745+ 31A9 6E 02 88 7A          defb    $6E,$02,$88,$7A ; -1/5! (-1/120)
4746+ 31AD E6 A0 2A 7C          defb    $E6,$A0,$2A,$7C ;  1/4! ( 1/24)
4747+ 31B1 50 AA AA 7E          defb    $50,$AA,$AA,$7E ; -1/3! (-1/6)
4748+ 31B5 FF FF 7F 7F          defb    $FF,$FF,$7F,$7F ;  1/2! ( 1/2)
4749+ 31B9 00 00 80 81          defb    $00,$00,$80,$81 ; -1/1! (-1/1)
4750+ 31BD 00 00 00 81          defb    $00,$00,$00,$81 ;  1/0! ( 1/1)
4751+ 31C1
4752+ 31C1 CD AA 2E     SUMSER: call    STAKFP          ; Put FPREG on stack
4753+ 31C4 11 1B 2D             ld      DE,MULT         ; Multiply by "X"
4754+ 31C7 D5                   push    DE              ; To be done after
4755+ 31C8 E5                   push    HL              ; Save address of table
4756+ 31C9 CD C5 2E             call    BCDEFP          ; Move FPREG to BCDE
4757+ 31CC CD 1D 2D             call    FPMULT          ; Square the value
4758+ 31CF E1                   pop     HL              ; Restore address of table
4759+ 31D0 CD AA 2E     SMSER1: call    STAKFP          ; Put value on stack
4760+ 31D3 7E                   ld      A,(HL)          ; Get number of coefficients
4761+ 31D4 23                   inc     HL              ; Point to start of table
4762+ 31D5 CD B7 2E             call    PHLTFP          ; Move coefficient to FPREG
4763+ 31D8 06                   defb    06H             ; Skip "pop AF"
4764+ 31D9 F1           SUMLP:  pop     AF              ; Restore count
4765+ 31DA C1                   pop     BC              ; Restore number
4766+ 31DB D1                   pop     DE
4767+ 31DC 3D                   dec     A               ; Cont coefficients
4768+ 31DD C8                   ret     Z               ; All done
4769+ 31DE D5                   push    DE              ; Save number
4770+ 31DF C5                   push    BC
4771+ 31E0 F5                   push    AF              ; Save count
4772+ 31E1 E5                   push    HL              ; Save address in table
4773+ 31E2 CD 1D 2D             call    FPMULT          ; Multiply FPREG by BCDE
4774+ 31E5 E1                   pop     HL              ; Restore address in table
4775+ 31E6 CD C8 2E             call    LOADFP          ; Number at HL to BCDE
4776+ 31E9 E5                   push    HL              ; Save address in table
4777+ 31EA CD E2 2B             call    FPADD           ; Add coefficient to FPREG
4778+ 31ED E1                   pop     HL              ; Restore address in table
4779+ 31EE C3 D9 31             jp      SUMLP           ; More coefficients
4780+ 31F1
4781+ 31F1 CD 79 2E     RND:    call    TSTSGN          ; Test sign of FPREG
4782+ 31F4 21 7A 80             ld      HL,SEED+2       ; Random number seed
4783+ 31F7 FA 52 32             jp      M,RESEED        ; Negative - Re-seed
4784+ 31FA 21 9B 80             ld      HL,LSTRND       ; Last random number
4785+ 31FD CD B7 2E             call    PHLTFP          ; Move last RND to FPREG
4786+ 3200 21 7A 80             ld      HL,SEED+2       ; Random number seed
4787+ 3203 C8                   ret     Z               ; Return if RND(0)
4788+ 3204 86                   add     A,(HL)          ; Add (SEED)+2)
4789+ 3205 E6 07                and     %00000111       ; 0 to 7
4790+ 3207 06 00                ld      B,$00
4791+ 3209 77                   ld      (HL),A          ; Re-save seed
4792+ 320A 23                   inc     HL              ; Move to coefficient table
4793+ 320B 87                   add     A,A             ; 4 bytes
4794+ 320C 87                   add     A,A             ; per entry
4795+ 320D 4F                   ld      C,A             ; BC = Offset into table
4796+ 320E 09                   add     HL,BC           ; Point to coefficient
4797+ 320F CD C8 2E             call    LOADFP          ; Coefficient to BCDE
4798+ 3212 CD 1D 2D             call    FPMULT  ;       ; Multiply FPREG by coefficient
4799+ 3215 3A 79 80             ld      A,(SEED+1)      ; Get (SEED+1)
4800+ 3218 3C                   inc     A               ; Add 1
4801+ 3219 E6 03                and     %00000011       ; 0 to 3
4802+ 321B 06 00                ld      B,$00
4803+ 321D FE 01                cp      $01             ; Is it zero?
4804+ 321F 88                   adc     A,B             ; Yes - Make it 1
4805+ 3220 32 79 80             ld      (SEED+1),A      ; Re-save seed
4806+ 3223 21 56 32             ld      HL,RNDTAB-4     ; Addition table
4807+ 3226 87                   add     A,A             ; 4 bytes
4808+ 3227 87                   add     A,A             ; per entry
4809+ 3228 4F                   ld      C,A             ; BC = Offset into table
4810+ 3229 09                   add     HL,BC           ; Point to value
4811+ 322A CD D3 2B             call    ADDPHL          ; Add value to FPREG
4812+ 322D CD C5 2E     RND1:   call    BCDEFP          ; Move FPREG to BCDE
4813+ 3230 7B                   ld      A,E             ; Get LSB
4814+ 3231 59                   ld      E,C             ; LSB = MSB
4815+ 3232 EE 4F                xor     %01001111       ; Fiddle around
4816+ 3234 4F                   ld      C,A             ; New MSB
4817+ 3235 36 80                ld      (HL),$80        ; Set exponent
4818+ 3237 2B                   dec     HL              ; Point to MSB
4819+ 3238 46                   ld      B,(HL)          ; Get MSB
4820+ 3239 36 80                ld      (HL),$80        ; Make value -0.5
4821+ 323B 21 78 80             ld      HL,SEED         ; Random number seed
4822+ 323E 34                   inc     (HL)            ; Count seed
4823+ 323F 7E                   ld      A,(HL)          ; Get seed
4824+ 3240 D6 AB                sub     $AB             ; Do it modulo 171
4825+ 3242 C2 49 32             jp      NZ,RND2         ; Non-zero - Ok
4826+ 3245 77                   ld      (HL),A          ; Zero seed
4827+ 3246 0C                   inc     C               ; Fillde about
4828+ 3247 15                   dec     D               ; with the
4829+ 3248 1C                   inc     E               ; number
4830+ 3249 CD 33 2C     RND2:   call    BNORM           ; Normalise number
4831+ 324C 21 9B 80             ld      HL,LSTRND       ; Save random number
4832+ 324F C3 D1 2E             jp      FPTHL           ; Move FPREG to last and return
4833+ 3252
4834+ 3252 77           RESEED: ld      (HL),A          ; Re-seed random numbers
4835+ 3253 2B                   dec     HL
4836+ 3254 77                   ld      (HL),A
4837+ 3255 2B                   dec     HL
4838+ 3256 77                   ld      (HL),A
4839+ 3257 C3 2D 32             jp      RND1            ; Return RND seed
4840+ 325A
4841+ 325A 68 B1 46 68  RNDTAB: defb    $68,$B1,$46,$68 ; Table used by RND
4842+ 325E 99 E9 92 69          defb    $99,$E9,$92,$69
4843+ 3262 10 D1 75 68          defb    $10,$D1,$75,$68
4844+ 3266
4845+ 3266 21 B0 32     COS:    ld      HL,HALFPI       ; Point to PI/2
4846+ 3269 CD D3 2B             call    ADDPHL          ; Add it to PPREG
4847+ 326C CD AA 2E     SIN:    call    STAKFP          ; Put angle on stack
4848+ 326F 01 49 83             ld      BC,$8349        ; BCDE = 2 PI
4849+ 3272 11 DB 0F             ld      DE,$0FDB
4850+ 3275 CD BA 2E             call    FPBCDE          ; Move 2 PI to FPREG
4851+ 3278 C1                   pop     BC              ; Restore angle
4852+ 3279 D1                   pop     DE
4853+ 327A CD CF 2D             call    DVBCDE          ; Divide angle by 2 PI
4854+ 327D CD AA 2E             call    STAKFP          ; Put it on stack
4855+ 3280 CD 4C 2F             call    INT             ; Get INT of result
4856+ 3283 C1                   pop     BC              ; Restore number
4857+ 3284 D1                   pop     DE
4858+ 3285 CD DF 2B             call    SUBCDE          ; Make it 0 <= value < 1
4859+ 3288 21 B4 32             ld      HL,QUARTR       ; Point to 0.25
4860+ 328B CD D9 2B             call    SUBPHL          ; Subtract value from 0.25
4861+ 328E CD 79 2E             call    TSTSGN          ; Test sign of value
4862+ 3291 37                   scf                     ; Flag positive
4863+ 3292 F2 9C 32             jp      P,SIN1          ; Positive - Ok
4864+ 3295 CD D0 2B             call    ROUND           ; Add 0.5 to value
4865+ 3298 CD 79 2E             call    TSTSGN          ; Test sign of value
4866+ 329B B7                   or      A               ; Flag negative
4867+ 329C F5           SIN1:   push    AF              ; Save sign
4868+ 329D F4 A2 2E             call    P,INVSGN        ; Negate value if positive
4869+ 32A0 21 B4 32             ld      HL,QUARTR       ; Point to 0.25
4870+ 32A3 CD D3 2B             call    ADDPHL          ; Add 0.25 to value
4871+ 32A6 F1                   pop     AF              ; Restore sign
4872+ 32A7 D4 A2 2E             call    NC,INVSGN       ; Negative - Make positive
4873+ 32AA 21 B8 32             ld      HL,SINTAB       ; Coefficient table
4874+ 32AD C3 C1 31             jp      SUMSER          ; Evaluate sum of series
4875+ 32B0
4876+ 32B0 DB 0F 49 81  HALFPI: defb    $DB,$0F,$49,$81 ; 1.5708 (PI/2)
4877+ 32B4
4878+ 32B4 00 00 00 7F  QUARTR: defb    $00,$00,$00,$7F ; 0.25
4879+ 32B8
4880+ 32B8 05           SINTAB: defb    $05             ; Table used by SIN
4881+ 32B9 BA D7 1E 86          defb    $BA,$D7,$1E,$86 ; 39.711
4882+ 32BD 64 26 99 87          defb    $64,$26,$99,$87 ;-76.575
4883+ 32C1 58 34 23 87          defb    $58,$34,$23,$87 ; 81.602
4884+ 32C5 E0 5D A5 86          defb    $E0,$5D,$A5,$86 ;-41.342
4885+ 32C9 DA 0F 49 83          defb    $DA,$0F,$49,$83 ;  6.2832
4886+ 32CD
4887+ 32CD CD AA 2E     TAN:    call    STAKFP          ; Put angle on stack
4888+ 32D0 CD 6C 32             call    SIN             ; Get SIN of angle
4889+ 32D3 C1                   pop     BC              ; Restore angle
4890+ 32D4 E1                   pop     HL
4891+ 32D5 CD AA 2E             call    STAKFP          ; Save SIN of angle
4892+ 32D8 EB                   ex      DE,HL           ; BCDE = Angle
4893+ 32D9 CD BA 2E             call    FPBCDE          ; Angle to FPREG
4894+ 32DC CD 66 32             call    COS             ; Get COS of angle
4895+ 32DF C3 CD 2D             jp      DIV             ; TAN = SIN / COS
4896+ 32E2
4897+ 32E2 CD 79 2E     ATN:    call    TSTSGN          ; Test sign of value
4898+ 32E5 FC 0D 31             call    M,NEGAFT        ; Negate result after if -ve
4899+ 32E8 FC A2 2E             call    M,INVSGN        ; Negate value if -ve
4900+ 32EB 3A 35 82             ld      A,(FPEXP)       ; Get exponent
4901+ 32EE FE 81                cp      81H             ; Number less than 1?
4902+ 32F0 DA FF 32             jp      C,ATN1          ; Yes - Get arc tangnt
4903+ 32F3 01 00 81             ld      BC,$8100        ; BCDE = 1
4904+ 32F6 51                   ld      D,C
4905+ 32F7 59                   ld      E,C
4906+ 32F8 CD CF 2D             call    DVBCDE          ; Get reciprocal of number
4907+ 32FB 21 D9 2B             ld      HL,SUBPHL       ; Sub angle from PI/2
4908+ 32FE E5                   push    HL              ; Save for angle > 1
4909+ 32FF 21 09 33     ATN1:   ld      HL,ATNTAB       ; Coefficient table
4910+ 3302 CD C1 31             call    SUMSER          ; Evaluate sum of series
4911+ 3305 21 B0 32             ld      HL,HALFPI       ; PI/2 - angle in case > 1
4912+ 3308 C9                   ret                     ; Number > 1 - Sub from PI/2
4913+ 3309
4914+ 3309 09           ATNTAB: defb    $09             ; Table used by ATN
4915+ 330A 4A D7 3B 78          defb    $4A,$D7,$3B,$78 ; 1/17
4916+ 330E 02 6E 84 7B          defb    $02,$6E,$84,$7B ;-1/15
4917+ 3312 FE C1 2F 7C          defb    $FE,$C1,$2F,$7C ; 1/13
4918+ 3316 74 31 9A 7D          defb    $74,$31,$9A,$7D ;-1/11
4919+ 331A 84 3D 5A 7D          defb    $84,$3D,$5A,$7D ; 1/9
4920+ 331E C8 7F 91 7E          defb    $C8,$7F,$91,$7E ;-1/7
4921+ 3322 E4 BB 4C 7E          defb    $E4,$BB,$4C,$7E ; 1/5
4922+ 3326 6C AA AA 7F          defb    $6C,$AA,$AA,$7F ;-1/3
4923+ 332A 00 00 00 81          defb    $00,$00,$00,$81 ; 1/1
4924+ 332E
4925+ 332E
4926+ 332E C9           ARET:   ret                     ; A RETurn instruction
4927+ 332F
4928+ 332F D7           GETINP: rst     $10             ; input a character
4929+ 3330 C9                   ret
4930+ 3331
4931+ 3331 E5           CLS:    push    HL
4932+ 3332 D5                   push    DE
4933+ 3333 3A CF 81             ld      A,(SCR_MODE)    ; check screen mode
4934+ 3336 FE 02                cp      $02             ; G2 mode?
4935+ 3338 CC EB 05             call    Z,EMPTYVIDBUF   ; yes, reset video buffer
4936+ 333B D1                   pop     DE
4937+ 333C E1                   pop     HL
4938+ 333D 3E 0C                ld      A,CS            ; ASCII Clear screen
4939+ 333F CD E0 19             call    SND2VID         ; send to screen
4940+ 3342 C3 88 3F             jp      MONOUT          ; Output character
4941+ 3345
4942+ 3345 CD F2 28     WIDTH:  call    GETINT          ; Get integer 0-255
4943+ 3348 7B                   ld      A,E             ; Width to A
4944+ 3349 32 A2 80             ld      (LWIDTH),A      ; Set width
4945+ 334C C9                   ret
4946+ 334D
4947+ 334D
4948+ 334D CD 99 1C     DEEK:   call    DEINT           ; Get integer -32768 to 32767
4949+ 3350 D5                   push    DE              ; Save number
4950+ 3351 E1                   pop     HL              ; Number to HL
4951+ 3352 46           RECWRD: ld      B,(HL)          ; Get LSB of contents
4952+ 3353 23                   inc     HL
4953+ 3354 7E                   ld      A,(HL)          ; Get MSB of contents
4954+ 3355 C3 56 24             jp      ABPASS          ; Return integer AB
4955+ 3358
4956+ 3358 CD 6C 20     DOKE:   call    GETNUM          ; Get a number
4957+ 335B CD 99 1C             call    DEINT           ; Get integer -32768 to 32767
4958+ 335E D5                   push    DE              ; Save address
4959+ 335F CD A2 19             call    CHKSYN          ; Make sure ',' follows
4960+ 3362 2C                   defb    ','
4961+ 3363 CD 6C 20             call    GETNUM          ; Get a number
4962+ 3366 CD 99 1C             call    DEINT           ; Get integer -32768 to 32767
4963+ 3369 E3                   ex      (SP),HL         ; Save value,get address
4964+ 336A 73                   ld      (HL),E          ; Save LSB of value
4965+ 336B 23                   inc     HL
4966+ 336C 72                   ld      (HL),D          ; Save MSB of value
4967+ 336D E1                   pop     HL              ; Restore code string address
4968+ 336E C9                   ret
4969+ 336F
4970+ 336F              ; stop the execution of code for a certain bit of time. The pause
4971+ 336F              ; is between $0000 and $FFFF 100ths of second (0~655.5 secs)
4972+ 336F CD 6C 20     PAUSE:  call    GETNUM          ; Get a number
4973+ 3372 CD 99 1C             call    DEINT           ; Get integer -32768 to 32767
4974+ 3375 7A                   ld      A,D             ; load D into A
4975+ 3376 B3                   or      E               ; are D & E equal to $00?
4976+ 3377 C8                   ret     Z               ; if yes, then return
4977+ 3378 C5           DIR_PAU:push    BC              ; store BC
4978+ 3379 3A BD 81             ld      A,(TMRCNT)      ; Load current value of system timer
4979+ 337C 47                   ld      B,A             ; move it into B
4980+ 337D CD 0E 1C     RPTPS:  call    TSTBRK          ; Test for break key
4981+ 3380 3A BD 81             ld      A,(TMRCNT)      ; Load current value of system timer
4982+ 3383 B8                   cp      B               ; is it the same value?
4983+ 3384 28 F7                jr      Z,RPTPS         ; yes, so read again
4984+ 3386 47                   ld      B,A             ; no, so store the new value
4985+ 3387 1B                   dec     DE              ; decrement interval
4986+ 3388 7A                   ld      A,D             ; load D into A
4987+ 3389 B3                   or      E               ; check if DE is equal to 0 (if D & e are $00 then result is 0)
4988+ 338A 20 F1                jr      NZ,RPTPS        ; no, repeat
4989+ 338C C1                   pop     BC              ; yes, recover BC and continue
4990+ 338D C9                   ret
4991+ 338E
4992+ 338E              ; change the screen mode. Usage: SCREEN X[,Y][,Z]
4993+ 338E              ; where X is: 0=text mode (40x24),
4994+ 338E              ; 1=graphic mode 1 (32x24 chars); 2=graphic mode 2 (256x192 pixels);
4995+ 338E              ; 3=multicolor mode (64x48 pixels); 4=extended graphic mode 2 (32x24 chars mixed between G1 and G2)
4996+ 338E              ; Y is: 0=8x8 sprites, 1=16x16 sprites
4997+ 338E              ; Z is: 0=no sprite magnification; 1=sprite magnification x2 (8x8=>16x16, and 16x16=32x32)
4998+ 338E              ; (the latters are accepted only in graphic modes G1, G2, G3, and G4)
4999+ 338E AF           SCREEN: xor     A
5000+ 338F 32 E0 81             ld      (TMPBFR2),A     ; sprite size & magnif. byte set to 0
5001+ 3392 CD F2 28             call    GETINT          ; Get integer 0-255
5002+ 3395 FE 05                cp      $05             ; is it a valid mode (0~4)?
5003+ 3397 D2 AE 1C             jp      NC,FCERR        ; No - Illegal function call Error
5004+ 339A 32 DE 81             ld      (TMPBFR1),A     ; store graphic mode
5005+ 339D A7                   and     A               ; is it 0 (text mode)?
5006+ 339E CA BA 33             jp      Z,SCVDP         ; yes, ignore other arguments and set mode immediately
5007+ 33A1 CD F9 33     SETVDP: call    CHKSCAR         ; no, check if sprite size follows
5008+ 33A4 DA AC 33             jp      C,CKMAGN        ; no (set to 0 or missing), so jump over
5009+ 33A7 3E 02                ld      A,$02           ; no, so set sprite size
5010+ 33A9 32 E0 81             ld      (TMPBFR2),A     ; ...to 16x16
5011+ 33AC CD F9 33     CKMAGN: call    CHKSCAR         ; check if sprite magnification follows
5012+ 33AF DA BA 33             jp      C,SCVDP         ; no (set to 0 or missing), so jump over
5013+ 33B2 3A E0 81             ld      A,(TMPBFR2)     ; yes, so retrieve sprite attributes...
5014+ 33B5 F6 01                or      $01             ; ...set sprite magnification to 2x...
5015+ 33B7 32 E0 81             ld      (TMPBFR2),A     ; ...and save flags again
5016+ 33BA F3           SCVDP:  di                      ; disable INTs
5017+ 33BB D5                   push    DE              ; store DE
5018+ 33BC E5                   push    HL              ; store HL
5019+ 33BD 3A DE 81             ld      A,(TMPBFR1)     ; recover graphic mode
5020+ 33C0 5F                   ld      E,A             ; and store it into E
5021+ 33C1 3A E0 81             ld      A,(TMPBFR2)     ; recover sprite flags
5022+ 33C4 57                   ld      D,A             ; and store them into D
5023+ 33C5 D5                   push    DE              ; store D & E
5024+ 33C6 CD EF 03             call    initVDP         ; initialize VDP with mode pointed by E
5025+ 33C9 D1                   pop     DE              ; retrieve D & E
5026+ 33CA 7B                   ld      A,E             ; move graphic mode into A
5027+ 33CB 87                   add     A,A
5028+ 33CC 87                   add     A,A
5029+ 33CD 87                   add     A,A             ; multiply A times 8 to get offset of graphic mode
5030+ 33CE 5F                   ld      E,A             ; and pass it into E
5031+ 33CF D5                   push    DE              ; store sprite flags in E
5032+ 33D0 16 00                ld      D,$00           ; reset D
5033+ 33D2 21 0B 0B             ld      HL,VDPMODESET+1 ; load address of VDP settings for reg#1
5034+ 33D5 19                   add     HL,DE           ; load correct reg#1 setting
5035+ 33D6 D1                   pop     DE              ; retrieve sprite flags from E
5036+ 33D7 7E                   ld      A,(HL)          ; load reg#1 setting
5037+ 33D8 E6 FC                and     %11111100       ; reset size & magn. bits
5038+ 33DA B2                   or      D               ; set size & magn. bits
5039+ 33DB 5F                   ld      E,A             ; value into E
5040+ 33DC 3E 01                ld      A,$01           ; reg #1
5041+ 33DE CD C7 06             call    WRITE_VREG      ; send setting to reg #1
5042+ 33E1 2A AF 80             ld      HL,(LINEAT)     ; Get current line number
5043+ 33E4 23                   inc     HL              ; -1 means direct statement
5044+ 33E5 7C                   ld      A,H
5045+ 33E6 B5                   or      L
5046+ 33E7 CC 0A 09             call    Z,CURSOR_ON     ; enable cursor if not in program mode
5047+ 33EA FB                   ei                      ; re-enable interrupts
5048+ 33EB E1                   pop     HL              ; restore HL
5049+ 33EC D1                   pop     DE              ; restore DE
5050+ 33ED 3A CE 81             ld      A,(SCR_SIZE_H)  ; check the screen mode by looking at the screen height
5051+ 33F0 FE 30                cp      $30             ; is it 48 chars or 192 pixels (MC and G2 modes)?
5052+ 33F2 D0                   ret     NC              ; yes, so exit (in graphics 2 and multicolor no print-on-video)
5053+ 33F3 3E 01                ld      A,$01           ; no (we are in Text, G1 or ExG2), so activate the...
5054+ 33F5 32 DA 81             ld      (PRNTVIDEO),A   ; ...video buffer...
5055+ 33F8 C9                   ret                     ; ...and return to caller
5056+ 33F9
5057+ 33F9              ; check an additional argument for SCREEN
5058+ 33F9 2B           CHKSCAR:dec     HL              ; dec 'cos GETCHR INCs
5059+ 33FA CD E3 1B             call    GETCHR          ; Get next character
5060+ 33FD 37                   scf                     ; set carry flag
5061+ 33FE C8                   ret     Z               ; return if nothing follows with Carry=1
5062+ 33FF CD A2 19             call    CHKSYN          ; Make sure ',' follows
5063+ 3402 2C                   defb    ','
5064+ 3403 CD F2 28             call    GETINT          ; get value
5065+ 3406 1F                   rra                     ; Carry=bit #0
5066+ 3407 3F                   ccf                     ; invert Carry, so Carry=0 if arg. is 1, and Carry=1 otherwise (arg<>1)
5067+ 3408 C9                   ret                     ; return
5068+ 3409
5069+ 3409
5070+ 3409              ; change the colors of the screen - Syntax is COLOR a,b,c where:
5071+ 3409              ; a=foreground color / b=background color / c=border color
5072+ 3409              ; a,b,c must be in a range between 1 and 15 (0 is transparent and it's not supported)
5073+ 3409 CD F2 28     COLOR:  call    GETINT          ; get first value
5074+ 340C CD B2 34             call    CHKCLR1         ; check if it's in range 1~15
5075+ 340F 32 DE 81             ld      (TMPBFR1),A     ; store it
5076+ 3412 3A CF 81             ld      A,(SCR_MODE)    ; check screen mode
5077+ 3415 FE 03                cp      $03             ; is it multicolor mode?
5078+ 3417 20 0D                jr      NZ,CNTCKCL      ; no, continue
5079+ 3419 3E 0F                ld      A,$0F           ; white for...
5080+ 341B 32 DC 81             ld      (FRGNDCLR),A    ; ...foreground (even it's not used in MC)
5081+ 341E 3A DE 81             ld      A,(TMPBFR1)     ; yes, so we stop here because in MC mode we just support border color
5082+ 3421 32 E2 81             ld      (TMPBFR3),A     ; move color into temp buffer 3
5083+ 3424 18 31                jr      CLRMC           ; jump to set color
5084+ 3426 CD A2 19     CNTCKCL:call    CHKSYN          ; Make sure ',' follows
5085+ 3429 2C                   defb    ','
5086+ 342A CD F2 28             call    GETINT          ; get second value
5087+ 342D CD B2 34             call    CHKCLR1         ; check if it's in range 1~15
5088+ 3430 32 E0 81             ld      (TMPBFR2),A     ; store it
5089+ 3433 3A CF 81             ld      A,(SCR_MODE)    ; check screen mode
5090+ 3436 A7                   and     A               ; is it text mode?
5091+ 3437 28 1B                jr      Z,CLRTXT        ; yes, stop here because in text mode, background and border colors coincide
5092+ 3439 CD A2 19             call    CHKSYN          ; Make sure ',' follows
5093+ 343C 2C                   defb    ','
5094+ 343D CD F2 28             call    GETINT          ; get third value
5095+ 3440 CD B2 34             call    CHKCLR1         ; check if it's in range 1~15
5096+ 3443 32 E2 81             ld      (TMPBFR3),A     ; store it
5097+ 3446 D5                   push    DE              ; store DE
5098+ 3447 3A CF 81             ld      A,(SCR_MODE)    ; check screen mode
5099+ 344A FE 01                cp      $01             ; is it G1 mode?
5100+ 344C 28 10                jr      Z,CLRG1         ; yes, jump over
5101+ 344E FE 02                cp      $02             ; is it G2 mode?
5102+ 3450 28 15                jr      Z,CLRG2         ; yes, jump over
5103+ 3452 18 1C                jr      CLREX2          ; last case can only be ExG2
5104+ 3454 CD A5 34     CLRTXT: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5105+ 3457 32 E2 81     CLRMC:  ld      (TMPBFR3),A     ; store color settings (for MC mode, we only set border color)
5106+ 345A D5                   push    DE              ; store DE
5107+ 345B F3                   di                      ; disable INTs
5108+ 345C 18 2E                jr      SETBRCL         ; set colors and exit
5109+ 345E CD A5 34     CLRG1:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5110+ 3461 16 01                ld      D,$01           ; repeat 1 time
5111+ 3463 06 20                ld      B,$20           ; 32 bytes of colors
5112+ 3465 18 10                jr      LOADCLR         ; load colors
5113+ 3467 CD A5 34     CLRG2:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5114+ 346A 16 18                ld      D,$18           ; 18 pages of...
5115+ 346C 06 00                ld      B,$00           ; ...256 bytes each
5116+ 346E 18 07                jr      LOADCLR         ; load colors
5117+ 3470 CD A5 34     CLREX2: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5118+ 3473 16 08                ld      D,$08           ; 8 pages of...
5119+ 3475 06 00                ld      B,$00           ; ...256 bytes each
5120+ 3477 E5           LOADCLR:push    HL              ; store HL
5121+ 3478 21 00 20             ld      HL,$2000        ; color table start: $2000
5122+ 347B F3                   di                      ; disable INTs
5123+ 347C CD 7D 06             call    SETVDPADRS
5124+ 347F 0E 30                ld      C,VDP_DAT       ; VDP data mode
5125+ 3481 ED 79        RPTLDCL:out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
5126+ 3483 00                   nop
5127+ 3484 00                   nop
5128+ 3485 10 FA                djnz    RPTLDCL         ; repeat for 256 bytes (1 page)
5129+ 3487 15                   dec     D               ; did we fill up all the pages?
5130+ 3488 20 F7                jr      NZ,RPTLDCL      ; no, repeat
5131+ 348A FB                   ei
5132+ 348B E1                   pop     HL              ; retrieve HL
5133+ 348C 3A DE 81     SETBRCL:ld      A,(TMPBFR1)     ; retrieve foreground color
5134+ 348F 32 DC 81             ld      (FRGNDCLR),A    ; store it
5135+ 3492 3A E0 81             ld      A,(TMPBFR2)     ; retrieve background color
5136+ 3495 32 DD 81             ld      (BKGNDCLR),A    ; store it
5137+ 3498 3A E2 81             ld      A,(TMPBFR3)     ; recover border color
5138+ 349B 5F                   ld      E,A             ; move it into E
5139+ 349C 3E 07                ld      A,$07           ; set VDP register 7
5140+ 349E F3                   di
5141+ 349F CD C7 06             call    WRITE_VREG      ; send value to VDP: set border color
5142+ 34A2 FB                   ei                      ; re-enable INTs
5143+ 34A3 D1                   pop     DE              ; retrieve DE
5144+ 34A4 C9                   ret                     ; return to caller
5145+ 34A5
5146+ 34A5
5147+ 34A5              ; mix 2 color nibbles in 1 byte
5148+ 34A5 3A E0 81     MIXCLRS:ld      A,(TMPBFR2)     ; retrieve background color
5149+ 34A8 47                   ld      B,A             ; move it into B
5150+ 34A9 3A DE 81             ld      A,(TMPBFR1)     ; retrieve foreground color
5151+ 34AC 87                   add     A,A             ; move foreground color into the high nibble of A
5152+ 34AD 87                   add     A,A
5153+ 34AE 87                   add     A,A
5154+ 34AF 87                   add     A,A
5155+ 34B0 B0                   or      B               ; put background color into the low nibble of A
5156+ 34B1 C9                   ret                     ; return to caller
5157+ 34B2
5158+ 34B2
5159+ 34B2              ; check if the color is not 0 and into the range 1~15
5160+ 34B2 A7           CHKCLR1:and     A               ; is it 0?
5161+ 34B3 CA C0 16             jp      Z,SNERR         ; yes, raise a SN error
5162+ 34B6 FE 10        CHKCLR0:cp      $10             ; is it in range 0~15?
5163+ 34B8 D2 C0 16             jp      NC,SNERR        ; no, raise a SN error
5164+ 34BB C9                   ret                     ; param is OK, can return
5165+ 34BC
5166+ 34BC
5167+ 34BC              ; check if in graphics 2 mode
5168+ 34BC 3A CF 81     CHKG2M: ld      A,(SCR_MODE)    ; check screen mode
5169+ 34BF FE 02                cp      $02             ; actually, we can paint only in G2
5170+ 34C1 C2 C2 3A             jp      NZ,GMERR        ; no G2, print a No Graphics Mode Error
5171+ 34C4 C9                   ret                     ; return to caller
5172+ 34C5
5173+ 34C5
5174+ 34C5              ; print a text in screen 2
5175+ 34C5              ; GPRINT text,x,y[,fc[,bc]]
5176+ 34C5              ; where "text" is an expression that can be converted into a sequence of ASCII chars,
5177+ 34C5              ; x & y are the coordinates (0<=x<=31, 0<=y<=23), fc & bc are foreground and background
5178+ 34C5              ; colors (1~15), resp.
5179+ 34C5              ; (portions of code are from nippur72)
5180+ 34C5              GX      equ     TMPBFR3
5181+ 34C5              GY      equ     TMPBFR4
5182+ 34C5              TMPCLR  equ     TMPBFR2
5183+ 34C5              MIXCOL  equ     TMPBFR1
5184+ 34C5              TMPADR  equ     VIDEOBUFF
5185+ 34C5              CHRPNT  equ     VIDEOBUFF+$02
5186+ 34C5              NUMCHR  equ     VIDEOBUFF+$04
5187+ 34C5              TMPHL   equ     VIDEOBUFF+$06
5188+ 34C5 CD BC 34     GPRINT: call    CHKG2M          ; check if in graphic mode 2
5189+ 34C8 2B                   dec     HL              ; dec 'cos GETCHR INCs
5190+ 34C9 CD E3 1B             call    GETCHR          ; check if something follows
5191+ 34CC CA C0 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
5192+ 34CF 22 E6 81             ld      (VIDEOBUFF),HL  ; save current code string pointer
5193+ 34D2 CD 7E 20             call    EVAL            ; Evaluate expression
5194+ 34D5 CD 70 20             call    TSTSTR          ; Make sure it's a string
5195+ 34D8 22 EC 81             ld      (TMPHL),HL      ; store code string pointer
5196+ 34DB CD B7 26             call    GSTRCU          ; Current string to pool
5197+ 34DE CD C8 2E             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
5198+ 34E1 ED 43 E8 81          ld      (CHRPNT),BC     ; store string pointer
5199+ 34E5 ED 53 EA 81          ld      (NUMCHR),DE     ; store string lenght
5200+ 34E9 2A EC 81             ld      HL,(TMPHL)      ; store code string pointer
5201+ 34EC CD A2 19             call    CHKSYN          ; Make sure ',' follows
5202+ 34EF 2C                   defb    ','
5203+ 34F0 CD F2 28             call    GETINT          ; get X coord.
5204+ 34F3 FE 20                cp      $20             ; is it in rage 0~31?
5205+ 34F5 D2 AE 1C             jp      NC,FCERR        ; Illegal function call error
5206+ 34F8 32 E2 81             ld      (GX),A          ; store into temp. buffer
5207+ 34FB CD A2 19             call    CHKSYN          ; Make sure ',' follows
5208+ 34FE 2C                   defb    ','
5209+ 34FF CD F2 28             call    GETINT          ; get Y coord.
5210+ 3502 FE 18                cp      $18             ; is it in range 0~23?
5211+ 3504 D2 AE 1C             jp      NC,FCERR        ; Illegal function call error
5212+ 3507 32 E4 81             ld      (GY),A          ; store into temp. buffer
5213+ 350A 11 E0 81             ld      DE,TMPCLR
5214+ 350D 3A DD 81             ld      A,(BKGNDCLR)    ; load background color
5215+ 3510 12                   ld      (DE),A          ; store into temp buff
5216+ 3511 3A DC 81             ld      A,(FRGNDCLR)    ; load foreground color
5217+ 3514 1B                   dec     DE
5218+ 3515 1B                   dec     DE
5219+ 3516 12                   ld      (DE),A          ; store into temp buff
5220+ 3517 CD A3 35             call    CKCOL           ; check color
5221+ 351A CA 22 35             jp      Z,CNTGPT2       ; if anything follows, jump over
5222+ 351D 13                   inc     DE
5223+ 351E 13                   inc     DE
5224+ 351F CD A3 35             call    CKCOL           ; check background color
5225+ 3522 CD A5 34     CNTGPT2:call    MIXCLRS         ; mix foreground & background colors
5226+ 3525 32 DE 81             ld      (MIXCOL),A      ; store mixed colors
5227+ 3528 E5                   push    HL              ; store code string address
5228+ 3529 ED 4B E8 81          ld      BC,(CHRPNT)     ; retrieve string pointer
5229+ 352D ED 5B EA 81          ld      DE,(NUMCHR)     ; retrieve string lenght
5230+ 3531 1C                   inc     E               ; Length + 1
5231+ 3532 CD 37 35             call    GPNT            ; print on G2
5232+ 3535 E1                   pop     HL              ; recover HL
5233+ 3536 C9                   ret                     ; return to caller
5234+ 3537 D5           GPNT:   push    DE              ; store string lenght (E)
5235+ 3538                      ; calculate VRAM address of first char
5236+ 3538 3A E2 81             LD      A,(GX)          ; load X
5237+ 353B 6F                   ld      L,A             ;
5238+ 353C 26 00                ld      H,0             ; HL = X
5239+ 353E 29                   add     HL,HL           ;
5240+ 353F 29                   add     HL,HL           ;
5241+ 3540 29                   add     HL,HL           ; X=X*8
5242+ 3541 3A E4 81             ld      A,(GY)          ; load Y
5243+ 3544 57                   ld      D,A             ; move it into D
5244+ 3545 1E 00                ld      E,0             ; DE =Y*256
5245+ 3547 19                   add     HL,DE           ; address = X*8 + Y*256
5246+ 3548 22 E6 81             ld      (TMPADR),HL     ; store VRAM address of first VRAM cell
5247+ 354B D1                   pop     DE              ; retrieve # of chars to be printed yet (E)
5248+ 354C 1D           RPGPNT: dec     E               ; Count characters
5249+ 354D C8                   ret     Z               ; End of string - return
5250+ 354E D5                   push    DE              ; store chars counter
5251+ 354F                      ; calculate dest address in color vram
5252+ 354F 2A E6 81             ld      HL,(TMPADR)     ; recover VRAM address
5253+ 3552 11 00 20             ld      DE,$2000        ; color map address
5254+ 3555 19                   add     HL,DE           ; HL = $2000 + XY address
5255+ 3556 F3                   di                      ; disable INTs
5256+ 3557                      ; send color settings
5257+ 3557 CD 7D 06     GPNTCOL:call    SETVDPADRS      ; set VRAM address for color cell
5258+ 355A 3A DE 81             ld      A,(MIXCOL)      ; load color settings
5259+ 355D 06 08                ld      B,$08           ; repeat for 8 rows
5260+ 355F 0E 30                ld      C,VDP_DAT       ; VDP data mode
5261+ 3561 ED 79        GPNTCO1:out     (C),A           ; send data (VRAM pointer auto-increments)
5262+ 3563 00                   nop                     ; wait...
5263+ 3564 00                   nop                     ; ...a...
5264+ 3565 00                   nop                     ; ...while
5265+ 3566 10 F9                djnz    GPNTCO1         ; repeat for 8 cells
5266+ 3568                      ; calculate source address
5267+ 3568 2A E8 81             ld      HL,(CHRPNT)     ; load char pointer
5268+ 356B 7E                   ld      A,(HL)          ; get char
5269+ 356C 23                   inc     HL              ; increment char pointer
5270+ 356D 22 E8 81             ld      (CHRPNT),HL     ; store char pointer
5271+ 3570 6F                   ld      L,A             ;
5272+ 3571 26 00                ld      H,0             ; char into HL
5273+ 3573 29                   add     HL,HL           ;
5274+ 3574 29                   add     HL,HL           ;
5275+ 3575 29                   add     HL,HL           ; get offset of char into ROM (charcode * 8)
5276+ 3576 11 12 48             ld      DE,CHRST88      ; DE = start of 8x8 fonts in ROM
5277+ 3579 19                   add     HL,DE           ; HL = start of characters in ROM
5278+ 357A EB                   ex      DE,HL           ; store address into DE
5279+ 357B 2A E6 81     GPCPCHR:ld      HL,(TMPADR)     ; load VRAM address
5280+ 357E CD 7D 06             call    SETVDPADRS      ; send it to VDP
5281+ 3581 EB                   ex      DE,HL           ; restore address into HL
5282+ 3582 06 08                ld      B,$08           ; repeat for 8 rows
5283+ 3584 0E 30                ld      C,VDP_DAT       ; VDP data mode
5284+ 3586 ED A3        GPCPCH1:outi                    ; load a byte from ROM and send to VRAM
5285+ 3588 00                   nop                     ; wait...
5286+ 3589 00                   nop                     ; ...a...
5287+ 358A 00                   nop                     ; ...while
5288+ 358B 20 F9                jr      NZ,GPCPCH1      ; repeat for 8 chars
5289+ 358D FB                   ei                      ; re-enable INTs
5290+ 358E 11 08 00             ld      DE,$0008        ; 8 bytes to go to the next video ell
5291+ 3591 2A E6 81             ld      HL,(TMPADR)     ; load VRAM address
5292+ 3594 19                   add     HL,DE           ; get address of next VRAM cell
5293+ 3595 22 E6 81             ld      (TMPADR),HL     ; store new VRAM address
5294+ 3598 11 00 18             ld      DE,$1800        ; forbidden address
5295+ 359B CD AF 3F             call    CMP16           ; check if the printing has gone out of the screen
5296+ 359E D1                   pop     DE              ; retrieve number of chars to be printed
5297+ 359F D0                   ret     NC              ; if HL>=$1800 then leave
5298+ 35A0 C3 4C 35             jp      RPGPNT          ; otherwise, check if more chars to output
5299+ 35A3
5300+ 35A3 2B           CKCOL:  dec     HL              ; dec 'cos GETCHR INCs
5301+ 35A4 CD E3 1B             call    GETCHR          ; Get next character
5302+ 35A7 C8                   ret     Z               ; return if nothing follows
5303+ 35A8 CD A2 19             call    CHKSYN          ; Make sure ',' follows
5304+ 35AB 2C                   defb    ','
5305+ 35AC D5                   push    DE              ; store DE
5306+ 35AD CD F2 28             call    GETINT          ; get value
5307+ 35B0 CD B2 34             call    CHKCLR1         ; check if color is in range 1~15
5308+ 35B3 D1                   pop     DE              ; retrieve DE
5309+ 35B4 12                   ld      (DE),A          ; store color into temp buffer
5310+ 35B5 C9                   ret                     ; return to caller
5311+ 35B6
5312+ 35B6
5313+ 35B6              ; paint X,Y[,C]: in graphics mode, fills an area starting
5314+ 35B6              ; at point X,Y, using default color or, if used, with
5315+ 35B6              ; color set by C
5316+ 35B6              ; TMPBFR1       X
5317+ 35B6              ; TMPBFR2       Y
5318+ 35B6              ; TMPBFR3       COLOR
5319+ 35B6              PNT     equ     VIDEOBUFF
5320+ 35B6              SPA     equ     VIDEOBUFF+$02
5321+ 35B6              SPB     equ     VIDEOBUFF+$03
5322+ 35B6              ORGSP   equ     VIDEOBUFF+$04
5323+ 35B6 CD BC 34     PAINT:  call    CHKG2M          ; check if in graphic mode 2
5324+ 35B9 CD F2 28             call    GETINT          ; get X
5325+ 35BC 32 DE 81             ld      (TMPBFR1),A     ; store X
5326+ 35BF CD A2 19             call    CHKSYN          ; Make sure ',' follows
5327+ 35C2 2C                   defb    ','
5328+ 35C3 CD F2 28             call    GETINT          ; get Y coords,
5329+ 35C6 FE C0                cp      $C0             ; check if Y is in range 0~191
5330+ 35C8 D2 AE 1C             jp      NC,FCERR        ; no, raise an FC error
5331+ 35CB 32 E0 81             ld      (TMPBFR2),A     ; store Y
5332+ 35CE CD A9 3A             call    CLRPRM          ; check if color has been passed
5333+ 35D1 3A E2 81             ld      A,(TMPBFR3)     ; load color
5334+ 35D4 A7                   and     A               ; check if 0
5335+ 35D5 CA AE 1C             jp      Z,FCERR         ; yes, raise an error
5336+ 35D8 E5                   push    HL              ; store HL
5337+ 35D9 C5                   push    BC              ; store BC
5338+ 35DA D5                   push    DE              ; store DE
5339+ 35DB                      ; start algorithm
5340+ 35DB CD EE 36             call    PNTRTN          ; check if pixel is already set
5341+ 35DE C2 92 36             jp      NZ,EXITPA2      ; if yes, then leave PAINT
5342+ 35E1 ED 73 EA 81          ld      (ORGSP),SP      ; no, store current Stack Pointer
5343+ 35E5 21 01 00             ld      HL,$0001        ; HL=1
5344+ 35E8 22 E6 81             ld      (PNT),HL        ; set PNT
5345+ 35EB 3A DE 81             ld      A,(TMPBFR1)     ; load starting X...
5346+ 35EE 47                   ld      B,A             ; ...into B
5347+ 35EF 3A E0 81             ld      A,(TMPBFR2)     ; load starting Y...
5348+ 35F2 4F                   ld      C,A             ; ...into C
5349+ 35F3 C5                   push    BC              ; store starting X,Y into stack
5350+ 35F4                      ; main loop
5351+ 35F4 2A E6 81     NXTLOOP:ld      HL,(PNT)        ; retrieve PNT
5352+ 35F7 7C                   ld      A,H             ; check if PNT=0
5353+ 35F8 B5                   or      L
5354+ 35F9 CA 8E 36             jp      Z,EXITPAI       ; yes, no more points to process - exit
5355+ 35FC 2B                   dec     HL              ; no, so decrement PNT...
5356+ 35FD 22 E6 81             ld      (PNT),HL        ; ...and store it
5357+ 3600 C1                   pop     BC              ; retrieve pixel coordinates X,Y into BC
5358+ 3601 CD 96 36     PAINT0: call    CHECKPA         ; check if pixel is set/reset
5359+ 3604 20 09                jr      NZ,PAINT11      ; pixel is set, so jump over
5360+ 3606 78                   ld      A,B             ; pixel is reset, check if X1=0
5361+ 3607 A7                   and     A               ; (reached the limit of the screen)
5362+ 3608 CA 10 36             jp      Z,PAINT1        ; yes, jump over
5363+ 360B 05                   dec     B               ; no, decrement X1...
5364+ 360C C3 01 36             jp      PAINT0          ; ...and repeat
5365+ 360F 04           PAINT11:inc     B               ; if found a pixel on, the re-increment X1
5366+ 3610 AF           PAINT1: xor     A               ; reset A
5367+ 3611 57                   ld      D,A             ; set SA=0
5368+ 3612 5F                   ld      E,A             ; set SB=0
5369+ 3613 CD 96 36     MNPAINT:call    CHECKPA         ; check if pixel is set/reset
5370+ 3616 20 DC                jr      NZ,NXTLOOP      ; it's set, so goto next loop
5371+ 3618 78                   ld      A,B             ; copy X1
5372+ 3619 32 DE 81             ld      (TMPBFR1),A     ; into buffer
5373+ 361C 79                   ld      A,C             ; copy Y
5374+ 361D 32 E0 81             ld      (TMPBFR2),A     ; into buffer
5375+ 3620 CD 14 37             call    CNTPLOT         ; plot pixel X1,Y
5376+ 3623 7A                   ld      A,D             ; load SA into A
5377+ 3624 A7                   and     A               ; SA=0?
5378+ 3625 20 1C                jr      NZ,PAINT2       ; no, jump over
5379+ 3627 79                   ld      A,C             ; load Y
5380+ 3628 FE 01                cp      $01             ; Y>0?
5381+ 362A DA 43 36             jp      C,PAINT2        ; no, jump over
5382+ 362D 3D                   dec     A               ; yes, Y=Y-1
5383+ 362E CD 97 36             call    CHECKPY         ; check pixel X1,Y-1
5384+ 3631 20 10                jr      NZ,PAINT2       ; it's set, so jump over
5385+ 3633 0D                   dec     C               ; Y=Y-1
5386+ 3634 C5                   push    BC              ; insert pixel(X1,Y-1) into stack
5387+ 3635 0C                   inc     C               ; retrieve original Y
5388+ 3636 2A E6 81             ld      HL,(PNT)        ; load PNT
5389+ 3639 23                   inc     HL              ; increment PNT
5390+ 363A 22 E6 81             ld      (PNT),HL        ; store new PNT
5391+ 363D 3E 01                ld      A,$01           ; set SA=1 and...
5392+ 363F 57                   ld      D,A             ; ...store SA into memory
5393+ 3640 C3 56 36             jp      PAINT3          ; jump over
5394+ 3643 7A           PAINT2: ld      A,D             ; load SA into A
5395+ 3644 1F                   rra                     ; check if SA=1
5396+ 3645 30 0F                jr      NC,PAINT3       ; no, jump over
5397+ 3647 79                   ld      A,C             ; load Y
5398+ 3648 FE 01                cp      $01             ; Y>0?
5399+ 364A DA 56 36             jp      C,PAINT3        ; no, jump over
5400+ 364D 3D                   dec     A               ; Y=Y-1
5401+ 364E CD 97 36             call    CHECKPY         ; check pixel X1,Y-1
5402+ 3651 CA 56 36             jp      Z,PAINT3        ; if pixel is off, jump over
5403+ 3654 AF                   xor     A               ; pixel is on, so...
5404+ 3655 57                   ld      D,A             ; ...set SA=0
5405+ 3656 7B           PAINT3: ld      A,E             ; check if...
5406+ 3657 A7                   and     A               ; SB=0
5407+ 3658 20 1B                jr      NZ,PAINT4       ; no, jump over
5408+ 365A 79                   ld      A,C             ; load Y
5409+ 365B FE BF                cp      $BF             ; Y<191?
5410+ 365D 30 16                jr      NC,PAINT4       ; no, jump over
5411+ 365F 3C                   inc     A               ; Y=Y+1
5412+ 3660 CD 97 36             call    CHECKPY         ; check pixel X1,Y+1
5413+ 3663 20 10                jr      NZ,PAINT4       ; pixel is on, so jump over
5414+ 3665 0C                   inc     C               ; Y=Y+1
5415+ 3666 C5                   push    BC              ; insert pixel(X1,Y+1) into stack
5416+ 3667 0D                   dec     C               ; retrieve original Y
5417+ 3668 2A E6 81             ld      HL,(PNT)        ; PNT
5418+ 366B 23                   inc     HL              ; PNT=PNT+1
5419+ 366C 22 E6 81             ld      (PNT),HL        ; store PNT
5420+ 366F 3E 01                ld      A,$01           ; SB=1
5421+ 3671 5F                   ld      E,A             ; set SB
5422+ 3672 C3 87 36             jp      PAINT5          ; jump over
5423+ 3675 7B           PAINT4: ld      A,E             ; load SB
5424+ 3676 1F                   rra                     ; check if SB=1
5425+ 3677 30 0E                jr      NC,PAINT5       ; no, jump over
5426+ 3679 79                   ld      A,C             ; load Y
5427+ 367A FE BF                cp      $BF             ; Y<191?
5428+ 367C 30 09                jr      NC,PAINT5       ; no, jump over
5429+ 367E 3C                   inc     A               ; Y=Y+1
5430+ 367F CD 97 36             call    CHECKPY         ; check pixel X1,Y+1
5431+ 3682 CA 87 36             jp      Z,PAINT5        ; if pixel is off, jump over
5432+ 3685 AF                   xor     A               ; pixel is on, so...
5433+ 3686 5F                   ld      E,A             ; ...set SB=0
5434+ 3687 04           PAINT5: inc     B               ; X1=X1+1
5435+ 3688 CA F4 35             jp      Z,NXTLOOP       ; if X1>255 (X1=0) then goto next loop
5436+ 368B C3 13 36             jp      MNPAINT         ; otherwise, repeat for next X
5437+ 368E ED 7B EA 81  EXITPAI:ld      SP,(ORGSP)      ; retrieve original SP pointer
5438+ 3692 D1           EXITPA2:pop     DE              ; retrieve DE
5439+ 3693 C1                   pop     BC              ; retrieve BC
5440+ 3694 E1                   pop     HL              ; retrieve HL
5441+ 3695 C9                   ret                     ; return to caller
5442+ 3696 79           CHECKPA:ld      A,C             ; copy Y into A
5443+ 3697 32 E0 81     CHECKPY:ld      (TMPBFR2),A     ; store Y
5444+ 369A 78                   ld      A,B             ; copy X1 into A
5445+ 369B 32 DE 81             ld      (TMPBFR1),A     ; store X1
5446+ 369E C5                   push    BC              ; save X1,Y
5447+ 369F D5                   push    DE
5448+ 36A0 CD EE 36             call    PNTRTN          ; check if pixel is set/reset
5449+ 36A3 D1                   pop     DE
5450+ 36A4 C1                   pop     BC              ; retrieve X1,Y
5451+ 36A5 C9                   ret                     ; return to caller
5452+ 36A6
5453+ 36A6
5454+ 36A6              ; POINT(x,y): return if a pixel is set (returns color) or if it's reset (0)
5455+ 36A6 CD BC 34     POINT:  call    CHKG2M          ; check if in graphic mode 2
5456+ 36A9 CD A2 19             call    CHKSYN          ; make sure "(" follows
5457+ 36AC 28                   defb    '('
5458+ 36AD CD F2 28             call    GETINT          ; get X coords.
5459+ 36B0 32 DE 81             ld      (TMPBFR1),A     ; store it into a temp buffer
5460+ 36B3 CD A2 19             call    CHKSYN          ; Make sure ',' follows
5461+ 36B6 2C                   defb    ','
5462+ 36B7 CD F2 28             call    GETINT          ; get Y coords,
5463+ 36BA FE C0                cp      $C0             ; check if Y is in range 0~191
5464+ 36BC D2 AE 1C             jp      NC,FCERR        ; no, raise an FC error
5465+ 36BF 32 E0 81             ld      (TMPBFR2),A     ; store into a temp buffer
5466+ 36C2 CD A2 19             call    CHKSYN          ; make sure ")" follows
5467+ 36C5 29                   defb    ')'
5468+ 36C6 E5                   push    HL              ; store current string address - the point after the ")" - ...
5469+ 36C7 FD E1                pop     IY              ; ...into IY
5470+ 36C9 CD EE 36             call    PNTRTN          ; check if pixel is set or reset
5471+ 36CC 20 0C                jr      NZ,CTPOINT      ; it's ON, jump over
5472+ 36CE AF                   xor     A               ; no, it's OFF. make sure to reset A...
5473+ 36CF 47                   ld      B,A             ; ...and B
5474+ 36D0 E1           PNTEND: pop     HL              ; drop original return point
5475+ 36D1 FD E5                push    IY              ; load current string address from IY into stack
5476+ 36D3 11 57 21             ld      DE,RETNUM       ; Address of Return number from function...
5477+ 36D6 D5                   push    DE              ; ...saved on stack
5478+ 36D7 C3 56 24             jp      ABPASS          ; return AB
5479+ 36DA CB EC        CTPOINT:set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5480+ 36DC F3                   di
5481+ 36DD CD 9D 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5482+ 36E0 FB                   ei
5483+ 36E1 CB 3F                srl     A               ; shift A...
5484+ 36E3 CB 3F                srl     A               ; ...4 times...
5485+ 36E5 CB 3F                srl     A               ; ...to move foreground color...
5486+ 36E7 CB 3F                srl     A               ; ...into lowest nibble
5487+ 36E9 47                   ld      B,A             ; color into B
5488+ 36EA AF                   xor     A               ; reset MSB
5489+ 36EB C3 D0 36             jp      PNTEND          ; return AB
5490+ 36EE CD 61 37     PNTRTN: call    XY2HL           ; find HL address of pixel at X,Y
5491+ 36F1 57                   ld      D,A             ; store pixel index
5492+ 36F2 F3                   di                      ; disable INTs
5493+ 36F3 CD 9D 06             call    READ_VIDEO_LOC  ; read contents of VRAM cell addressed by HL
5494+ 36F6 FB                   ei                      ; re-enable INTs
5495+ 36F7 A2                   and     D               ; is the pixel ON or OFF? (will be checked later)
5496+ 36F8 C9                   ret                     ; return to caller
5497+ 36F9
5498+ 36F9
5499+ 36F9              ; PLOT X,Y[,color]
5500+ 36F9              ; plot a pixel in graphic mode 2
5501+ 36F9 CD BC 34     PLOT:   call    CHKG2M          ; check if in G2 mode
5502+ 36FC CD F2 28             call    GETINT          ; get X coords.
5503+ 36FF 32 DE 81             ld      (TMPBFR1),A     ; store it into a temp buffer
5504+ 3702 CD A2 19             call    CHKSYN          ; Make sure ',' follows
5505+ 3705 2C                   defb    ','
5506+ 3706 CD F2 28             call    GETINT          ; get Y coords,
5507+ 3709 FE C0                cp      $C0             ; check if Y is in range 0~191
5508+ 370B D2 AE 1C             jp      NC,FCERR        ; no, raise an FC error
5509+ 370E 32 E0 81             ld      (TMPBFR2),A     ; store into a temp buffer
5510+ 3711 CD A9 3A             call    CLRPRM          ; check if param "color" has been passed
5511+ 3714 E5           CNTPLOT:push    HL              ; store HL
5512+ 3715 C5                   push    BC              ; store BC
5513+ 3716 D5                   push    DE              ; store DE
5514+ 3717 CD 61 37             call    XY2HL           ; find VRAM address of byte containing pixel at X,Y & return into HL
5515+ 371A D2 55 37             jp      NC,NOGD         ; if carry is reset, there was an error -> so leave
5516+ 371D 57                   ld      D,A             ; move pixel value into D
5517+ 371E 3A E2 81             ld      A,(TMPBFR3)     ; retrieve color
5518+ 3721 A7                   and     A               ; is it 0? (background, or reset pixel)
5519+ 3722 20 11                jr      NZ,CNTPLT1      ; no, continue
5520+ 3724 F3                   di                      ; yes - so, disable INTs
5521+ 3725 CD 9D 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5522+ 3728 FB                   ei                      ; re-enable INTs
5523+ 3729 5F                   ld      E,A             ; store value of cell
5524+ 372A 7A                   ld      A,D             ; retrieve pixel
5525+ 372B 2F                   cpl                     ; revert bits
5526+ 372C A3                   and     E               ; set video pixel to off
5527+ 372D F3                   di                      ; disable INTs
5528+ 372E CD B2 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5529+ 3731 FB                   ei                      ; re-enable INTs
5530+ 3732 C3 55 37             jp      NOGD            ; leave
5531+ 3735 87           CNTPLT1:add     A,A             ; now we move low nibble
5532+ 3736 87                   add     A,A             ; in the high nibble
5533+ 3737 87                   add     A,A             ; by adding A to itself
5534+ 3738 87                   add     A,A             ; 4 times (this is a shift left 4)
5535+ 3739 5F                   ld      E,A             ; move it into E
5536+ 373A F3                   di                      ; disable INTs
5537+ 373B CD 9D 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5538+ 373E FB                   ei
5539+ 373F B2                   or      D               ; plot new pixel preserving original pattern
5540+ 3740 F3                   di
5541+ 3741 CD B2 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5542+ 3744 FB                   ei
5543+ 3745 CB EC                set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5544+ 3747 F3                   di
5545+ 3748 CD 9D 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5546+ 374B FB                   ei
5547+ 374C E6 0F                and     %00001111       ; reset high nibble (the foreground color)
5548+ 374E B3                   or      E               ; set new foreground color
5549+ 374F F3                   di
5550+ 3750 CD B2 06             call    WRITE_VIDEO_LOC ; write new color settings
5551+ 3753 FB                   ei                      ; re-enable INTs
5552+ 3754 00                   nop                     ; wait for INTs to be enabled again
5553+ 3755 D1           NOGD:   pop     DE              ; retrieve DE
5554+ 3756 C1                   pop     BC              ; retrieve BC
5555+ 3757 E1                   pop     HL              ; retrieve HL
5556+ 3758 C9                   ret                     ; return to caller
5557+ 3759 80 40 20 10  PXLSET: defb    $80,$40,$20,$10,$08,$04,$02,$01 ; pixel to be set ON
5557+ 375D 08 04 02 01
5558+ 3761                      ; where R(X/8)=> 0=80h, 1=40h, 2=20h, 3=10h, 4=08h, 5=04h, 6=02h, 7=$01
5559+ 3761
5560+ 3761
5561+ 3761              ; compute the VRAM address of the byte containing the pixel
5562+ 3761              ; being pointed by X,Y (TMPBFR1,TMPBFR1)
5563+ 3761              ; byte address is returned into HL
5564+ 3761              ; pixel is returned into A
5565+ 3761              XY2HL:  ; formula is: ADDRESS=(INT(X/8))*8 + (INT(Y/8))*256 + R(Y/8)
5566+ 3761                      ; where R(Y/8) is the remainder of (Y/8)
5567+ 3761                      ; the pixel to be set is given by R(X/8), and data is taken from the array
5568+ 3761 3A E0 81             ld      A,(TMPBFR2)     ; retrieve Y
5569+ 3764 FE C0                cp      $C0             ; Y>=192?
5570+ 3766 D0                   ret     NC              ; yes, so leave
5571+ 3767 1E 08                ld      E,$08           ; load E with divisor
5572+ 3769 57                   ld      D,A             ; and store into D (dividend)
5573+ 376A CD DE 3F             call    DIV_8_8         ; get Y/8, D is quotient=INT(Y/8), and A is remainder
5574+ 376D 4F                   ld      C,A             ; store remainder into C
5575+ 376E 42                   ld      B,D             ; B=(INT(Y/8))*256 (we simply copy quotient into B)
5576+ 376F 60 69                ld      HL,BC           ; copy BC into HL: now HL has the VRAM address of the byte being set
5577+ 3771 3A DE 81             ld      A,(TMPBFR1)     ; retrieve X
5578+ 3774 57                   ld      D,A             ; and move it into D (dividend)
5579+ 3775 CD DE 3F             call    DIV_8_8         ; get X/8, D is quotient=INT(X/8), and A is remainder
5580+ 3778 4F                   ld      C,A             ; store remainder into C
5581+ 3779 7A                   ld      A,D             ; move quotient into A
5582+ 377A 87                   add     A,A
5583+ 377B 87                   add     A,A
5584+ 377C 87                   add     A,A             ; multiply quotient by 8
5585+ 377D 5F                   ld      E,A             ; store result into E
5586+ 377E 16 00                ld      D,$00           ; reset D
5587+ 3780 19                   add     HL,DE           ; add DE to HL, getting the final VRAM address
5588+ 3781 EB                   ex      DE,HL           ; move VRAM address into DE
5589+ 3782 21 59 37             ld      HL,PXLSET       ; starting address of table for pixel to draw
5590+ 3785 06 00                ld      B,$00           ; reset B
5591+ 3787 09                   add     HL,BC           ; add C (remainder of X/8) to get address of pixel to turn on
5592+ 3788 7E                   ld      A,(HL)          ; load pixel data
5593+ 3789 EB                   ex      DE,HL           ; retrieve VRAM pattern address into HL
5594+ 378A 37                   scf                     ; set Carry for normal exit
5595+ 378B C9                   ret                     ; return to caller
5596+ 378C
5597+ 378C
5598+ 378C              ; DRAW X1,Y1,X2,Y2[,color]
5599+ 378C              ; Draw a line using Bresenham's line algorithm from X1,Y1 to X2,Y2
5600+ 378C              ; X1,Y1 can be either less than or greater than X2,Y2 (meaning that)
5601+ 378C              ; the drawing will be ever done from X1,Y2 to X2,Y2, regardless of
5602+ 378C              ; the values. If color is not specified, the foreground color set
5603+ 378C              ; with COLOR will be used
5604+ 378C              X1      equ     TMPBFR1
5605+ 378C              Y1      equ     TMPBFR2
5606+ 378C              X2      equ     VIDEOBUFF
5607+ 378C              Y2      equ     VIDEOBUFF+$02
5608+ 378C              ER      equ     VIDEOBUFF+$04
5609+ 378C              E2      equ     VIDEOBUFF+$06
5610+ 378C              SX      equ     VIDEOBUFF+$08
5611+ 378C              SY      equ     VIDEOBUFF+$0A
5612+ 378C              DX      equ     VIDEOBUFF+$0C
5613+ 378C              DY      equ     VIDEOBUFF+$0E
5614+ 378C CD BC 34     DRAW:   call    CHKG2M          ; check if in G2 mode
5615+ 378F CD 91 3A             call    CLRVDBF         ; clear VIDEOBUFF
5616+ 3792 CD F2 28             call    GETINT          ; get X1 coords.
5617+ 3795 32 DE 81             ld      (X1),A          ; store it into a temp buffer
5618+ 3798 CD A2 19             call    CHKSYN          ; Make sure ',' follows
5619+ 379B 2C                   defb    ','
5620+ 379C CD F2 28             call    GETINT          ; get Y1 coords.
5621+ 379F FE C0                cp      $C0             ; check if Y1 is in range 0~191
5622+ 37A1 D2 AE 1C             jp      NC,FCERR        ; no, raise an FC error
5623+ 37A4 32 E0 81             ld      (Y1),A          ; store into a temp buffer
5624+ 37A7 CD A2 19             call    CHKSYN          ; Make sure ',' follows
5625+ 37AA 2C                   defb    ','
5626+ 37AB CD F2 28             call    GETINT          ; get X2 coords.
5627+ 37AE 32 E6 81             ld      (X2),A          ; store it into a temp buffer
5628+ 37B1 CD A2 19             call    CHKSYN          ; Make sure ',' follows
5629+ 37B4 2C                   defb    ','
5630+ 37B5 CD F2 28             call    GETINT          ; get Y2 coords
5631+ 37B8 FE C0                cp      $C0             ; check if Y2 is in range 0~191
5632+ 37BA D2 AE 1C             jp      NC,FCERR        ; no, raise an FC error
5633+ 37BD 32 E8 81             ld      (Y2),A          ; store it into a temp buffer
5634+ 37C0 CD A9 3A             call    CLRPRM          ; check for arg. "color" and store it into TMPBFR3
5635+ 37C3 E5                   push    HL              ; store register we'll use
5636+ 37C4 D5                   push    DE
5637+ 37C5 C5                   push    BC
5638+ 37C6 ED 5B DE 81          ld      DE,(X1)         ; load X1 and
5639+ 37CA 2A E6 81             ld      HL,(X2)         ; X2
5640+ 37CD B7                   or      A               ; clear CARRY
5641+ 37CE ED 52                sbc     HL,DE           ; DX=X2-X1
5642+ 37D0 CD D4 3F             call    absHL           ; DX=ABS(DX)
5643+ 37D3 22 F2 81             ld      (DX),HL         ; store DX
5644+ 37D6 01 FF FF             ld      BC,$FFFF        ; SX=-1
5645+ 37D9 2A DE 81             ld      HL,(X1)
5646+ 37DC ED 5B E6 81          ld      DE,(X2)
5647+ 37E0 CD AF 3F             call    CMP16           ; X1<X2?
5648+ 37E3 CA EC 37             jp      Z,X1GR          ; no, X1=X2
5649+ 37E6 F2 EC 37             jp      P,X1GR          ; no, X1>X2
5650+ 37E9 01 01 00             ld      BC,$0001        ; yes, so set SX=1
5651+ 37EC ED 43 EE 81  X1GR:   ld      (SX),BC         ; store SX
5652+ 37F0 ED 5B E0 81          ld      DE,(Y1)
5653+ 37F4 2A E8 81             ld      HL,(Y2)
5654+ 37F7 B7                   or      A               ; clear Carry
5655+ 37F8 ED 52                sbc     HL,DE           ; DY=Y2-Y1
5656+ 37FA CD D4 3F             call    absHL           ; DY=ABS(DY)
5657+ 37FD 22 F4 81             ld      (DY),HL         ; store DY
5658+ 3800 01 FF FF             ld      BC,$FFFF        ; SY=-1
5659+ 3803 2A E0 81             ld      HL,(Y1)
5660+ 3806 ED 5B E8 81          ld      DE,(Y2)
5661+ 380A CD AF 3F             call    CMP16           ; is Y1<Y2?
5662+ 380D CA 16 38             jp      Z,Y1GR          ; no, Y1=Y2
5663+ 3810 F2 16 38             jp      P,Y1GR          ; no, Y1>Y2 - jump over
5664+ 3813 01 01 00             ld      BC,$0001        ; yes, so set SY=1
5665+ 3816 ED 43 F0 81  Y1GR:   ld      (SY),BC         ; store SY
5666+ 381A 2A F4 81             ld      HL,(DY)         ; ER=DY
5667+ 381D CD D7 3F             call    negHL           ; ER=-DY
5668+ 3820 22 EA 81             ld      (ER),HL         ; store ER
5669+ 3823 2A F2 81             ld      HL,(DX)
5670+ 3826 ED 5B F4 81          ld      DE,(DY)
5671+ 382A CD AF 3F             call    CMP16           ; DX>DY?
5672+ 382D CA 39 38             jp      Z,ER2           ; no, DX=DY
5673+ 3830 FA 39 38             jp      M,ER2           ; no, DX<DY
5674+ 3833 2A F2 81             ld      HL,(DX)         ; reload DX
5675+ 3836 22 EA 81             ld      (ER),HL         ; yes: DX>DY, so ER=DX
5676+ 3839 2A EA 81     ER2:    ld      HL,(ER)         ; load ER
5677+ 383C CB 2C                sra     H               ; right shift (and preserve sign)...
5678+ 383E CB 1D                rr      L               ; ...of HL, so ER=INT(ER/2)
5679+ 3840 CB 7C                bit     7,H             ; is the number negative?
5680+ 3842 CA 46 38             jp      Z,STRE2         ; no, jump over
5681+ 3845 23                   inc     HL              ; yes, add 1 'cos INT of a negative number needs to be incremented
5682+ 3846 22 EA 81     STRE2:  ld      (ER),HL         ; store ER
5683+ 3849 CD 14 37     RPTDRW: call    CNTPLOT         ; plot first pixel
5684+ 384C 2A DE 81             ld      HL,(X1)
5685+ 384F ED 5B E6 81          ld      DE,(X2)
5686+ 3853 CD AF 3F             call    CMP16           ; X1=X2?
5687+ 3856 20 0D                jr      NZ,CNTDRW       ; no, continue drawing
5688+ 3858 2A E0 81             ld      HL,(Y1)         ; yes, so check
5689+ 385B ED 5B E8 81          ld      DE,(Y2)         ; also Y
5690+ 385F CD AF 3F             call    CMP16           ; Y1=Y2?
5691+ 3862 CA BE 38             jp      Z,ENDDRAW       ; yes, finished drawing: exit
5692+ 3865 ED 5B EA 81  CNTDRW: ld      DE,(ER)
5693+ 3869 ED 53 EC 81          ld      (E2),DE         ; E2=ER
5694+ 386D 2A F2 81             ld      HL,(DX)
5695+ 3870 CD D7 3F             call    negHL           ; DX=-DX
5696+ 3873 EB                   ex      DE,HL           ; invert DE and HL => HL=E2, DE=-DX
5697+ 3874 CD AF 3F             call    CMP16           ; E2>-DX?
5698+ 3877 CA 95 38             jp      Z,DXGR          ; no, E2=-DX: jump
5699+ 387A FA 95 38             jp      M,DXGR          ; no, E2<-DX: jump
5700+ 387D 2A EA 81             ld      HL,(ER)         ; yes
5701+ 3880 ED 5B F4 81          ld      DE,(DY)
5702+ 3884 B7                   or      A               ; clear CARRY
5703+ 3885 ED 52                sbc     HL,DE           ; ER=ER-DY
5704+ 3887 22 EA 81             ld      (ER),HL
5705+ 388A 2A DE 81             ld      HL,(X1)
5706+ 388D ED 5B EE 81          ld      DE,(SX)
5707+ 3891 19                   add     HL,DE           ; X1=X1+SX (increment X1)
5708+ 3892 22 DE 81             ld      (X1),HL
5709+ 3895 2A EC 81     DXGR:   ld      HL,(E2)
5710+ 3898 ED 5B F4 81          ld      DE,(DY)
5711+ 389C CD AF 3F             call    CMP16           ; E2<DY?
5712+ 389F CA 49 38             jp      Z,RPTDRW        ; no, E2=DY: jump
5713+ 38A2 F2 49 38             jp      P,RPTDRW        ; no, E2>DY: jump
5714+ 38A5 2A EA 81             ld      HL,(ER)         ; yes
5715+ 38A8 ED 5B F2 81          ld      DE,(DX)
5716+ 38AC 19                   add     HL,DE           ; ER=ER+DX
5717+ 38AD 22 EA 81             ld      (ER),HL
5718+ 38B0 2A E0 81             ld      HL,(Y1)
5719+ 38B3 ED 5B F0 81          ld      DE,(SY)
5720+ 38B7 19                   add     HL,DE           ; Y1=Y1+SY (increment Y1)
5721+ 38B8 22 E0 81             ld      (Y1),HL
5722+ 38BB C3 49 38             jp      RPTDRW          ; repeat
5723+ 38BE C1           ENDDRAW:pop     BC              ; retrieve BC
5724+ 38BF D1                   pop     DE              ; retrieve DE
5725+ 38C0 E1                   pop     HL              ; retrieve HL
5726+ 38C1 C9                   ret                     ; return to caller
5727+ 38C2
5728+ 38C2
5729+ 38C2              ; CIRCLE X,Y,R[,C]
5730+ 38C2              ; Draw a circle using Bresenham's circle algorithm with center in X,Y
5731+ 38C2              ; and radius R, with optional color C. If color is not specified, the
5732+ 38C2              ; foreground color set with COLOR will be used
5733+ 38C2              XC      equ     VIDEOBUFF
5734+ 38C2              YC      equ     VIDEOBUFF+$02
5735+ 38C2              RADIUS  equ     VIDEOBUFF+$04
5736+ 38C2              XI      equ     VIDEOBUFF+$06
5737+ 38C2              YI      equ     VIDEOBUFF+$08
5738+ 38C2              DC      equ     VIDEOBUFF+$0A
5739+ 38C2 CD BC 34     CIRCLE: call    CHKG2M          ; check if in G2 mode
5740+ 38C5 CD 91 3A             call    CLRVDBF         ; clear VIDEOBUFF
5741+ 38C8 CD F2 28             call    GETINT          ; get X coords.
5742+ 38CB 32 E6 81             ld      (XC),A          ; store it into a temp buffer
5743+ 38CE CD A2 19             call    CHKSYN          ; Make sure ',' follows
5744+ 38D1 2C                   defb    ','
5745+ 38D2 CD F2 28             call    GETINT          ; get Y coords,
5746+ 38D5 32 E8 81             ld      (YC),A          ; store it into a temp buffer
5747+ 38D8 CD A2 19             call    CHKSYN          ; Make sure ',' follows
5748+ 38DB 2C                   defb    ','
5749+ 38DC CD F2 28             call    GETINT          ; get radius
5750+ 38DF 32 EA 81             ld      (RADIUS),A      ; store it into a temp buffer
5751+ 38E2 CD A9 3A             call    CLRPRM          ; check if param "color" has been passed
5752+ 38E5 C5                   push    BC              ; store BC
5753+ 38E6 D5                   push    DE              ; store DE
5754+ 38E7 E5                   push    HL              ; store HL
5755+ 38E8 AF                   xor     A               ; clear A,
5756+ 38E9 47                   ld      B,A             ; B,
5757+ 38EA 4F                   ld      C,A             ; C,
5758+ 38EB 57                   ld      D,A             ; D,
5759+ 38EC 67                   ld      H,A             ; and H
5760+ 38ED ED 43 EC 81          ld      (XI),BC         ; clear XI
5761+ 38F1 3A EA 81             ld      A,(RADIUS)      ; load RADIUS into A
5762+ 38F4 6F                   ld      L,A             ; HL now contains R
5763+ 38F5 22 EE 81             ld      (YI),HL         ; YI=RADIUS
5764+ 38F8 29                   add     HL,HL           ; R*2
5765+ 38F9 EB                   ex      DE,HL           ; put HL into DE
5766+ 38FA 21 03 00             ld      HL,$0003        ; now HL is 3
5767+ 38FD AF                   xor     A               ; clear Carry
5768+ 38FE ED 52                sbc     HL,DE           ; HL=>D=3-(2*R)
5769+ 3900 22 F0 81             ld      (DC),HL         ; store D
5770+ 3903 CD 62 39             call    DRWCRL          ; draw initial point
5771+ 3906 ED 5B EC 81  RPTCRL: ld      DE,(XI)         ; load XI
5772+ 390A 2A EE 81             ld      HL,(YI)         ; load YI
5773+ 390D CD AF 3F             call    CMP16           ; is YI<DI?
5774+ 3910 CA 19 39             jp      Z,RPTCL1        ; no, YI=XI
5775+ 3913 F2 19 39             jp      P,RPTCL1        ; no, YI>XI
5776+ 3916 C3 5E 39             jp      ENDCRL          ; yes, so we've finished
5777+ 3919 21 EC 81     RPTCL1: ld      HL,XI
5778+ 391C 34                   inc     (HL)            ; XI=XI+1
5779+ 391D 2A F0 81             ld      HL,(DC)         ; load D
5780+ 3920 7C                   ld      A,H
5781+ 3921 B5                   or      L               ; is D=0? Yes, jump over
5782+ 3922 CA 46 39             jp      Z,DLSZ
5783+ 3925 CB 7C                bit     7,H             ; is D<0?
5784+ 3927 20 1D                jr      NZ,DLSZ         ; yes, jump over
5785+ 3929 ED 5B EE 81          ld      DE,(YI)         ; D>0
5786+ 392D 1B                   dec     DE              ; so, YI=YI-1
5787+ 392E ED 53 EE 81          ld      (YI),DE         ; store YI
5788+ 3932 AF                   xor     A               ; clear Carry
5789+ 3933 2A EC 81             ld      HL,(XI)
5790+ 3936 ED 52                sbc     HL,DE           ; HL=XI-YI
5791+ 3938 29                   add     HL,HL
5792+ 3939 29                   add     HL,HL           ; HL=HL*4
5793+ 393A 11 0A 00             ld      DE,10
5794+ 393D 19                   add     HL,DE           ; HL=HL+10
5795+ 393E ED 5B F0 81          ld      DE,(DC)         ; load D
5796+ 3942 EB                   ex      DE,HL           ; invert DE and HL, so that HL=4*(XI-YI)+10 and DE=D
5797+ 3943 19                   add     HL,DE           ; D=D+4*(XI-YI)+10
5798+ 3944 18 0F                jr      PLTCRL          ; plot next pixel
5799+ 3946 2A EC 81     DLSZ:   ld      HL,(XI)         ; load XI
5800+ 3949 29                   add     HL,HL
5801+ 394A 29                   add     HL,HL           ; XI=XI*4
5802+ 394B 11 06 00             ld      DE,$0006
5803+ 394E 19                   add     HL,DE
5804+ 394F ED 5B F0 81          ld      DE,(DC)
5805+ 3953 EB                   ex      DE,HL           ; HL=D and DE=4*XI+6
5806+ 3954 19                   add     HL,DE           ; D=D+4*XI+6
5807+ 3955 22 F0 81     PLTCRL: ld      (DC),HL         ; store new D
5808+ 3958 CD 62 39             call    DRWCRL          ; plot pixel
5809+ 395B C3 06 39             jp      RPTCRL          ; repeat
5810+ 395E E1           ENDCRL: pop     HL
5811+ 395F D1                   pop     DE
5812+ 3960 C1                   pop     BC
5813+ 3961 C9                   ret                     ; return to caller
5814+ 3962 2A E6 81     DRWCRL: ld      HL,(XC)
5815+ 3965 ED 5B EC 81          ld      DE,(XI)
5816+ 3969 19                   add     HL,DE           ; X=XC+XI
5817+ 396A 22 DE 81             ld      (X1),HL         ; store X
5818+ 396D CD 81 3A             call    VALIDX          ; check if X is valid (0~255)
5819+ 3970 DA 84 39             jp      C,CNTCL1        ; if Carry is set, X is not valid
5820+ 3973 2A E8 81             ld      HL,(YC)
5821+ 3976 ED 5B EE 81          ld      DE,(YI)
5822+ 397A 19                   add     HL,DE           ; Y=YC+YI
5823+ 397B 22 E0 81             ld      (Y1),HL         ; store Y
5824+ 397E CD 86 3A             call    VALIDY          ; check if Y is valid (0~191)
5825+ 3981 D4 14 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5826+ 3984 AF           CNTCL1: xor     A               ; clear Carry
5827+ 3985 2A E6 81             ld      HL,(XC)
5828+ 3988 ED 5B EC 81          ld      DE,(XI)
5829+ 398C ED 52                sbc     HL,DE           ; X=XC-XI
5830+ 398E 22 DE 81             ld      (X1),HL         ; store X
5831+ 3991 CD 81 3A             call    VALIDX          ; check if X is valid (0~255)
5832+ 3994 DA A8 39             jp      C,CNTCL2        ; if Carry is set, X is not valid
5833+ 3997 2A E8 81             ld      HL,(YC)
5834+ 399A ED 5B EE 81          ld      DE,(YI)
5835+ 399E 19                   add     HL,DE           ; Y=YC+YI
5836+ 399F 22 E0 81             ld      (Y1),HL         ; store Y
5837+ 39A2 CD 86 3A             call    VALIDY          ; check if Y is valid (0~191)
5838+ 39A5 D4 14 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5839+ 39A8 2A E6 81     CNTCL2: ld      HL,(XC)
5840+ 39AB ED 5B EC 81          ld      DE,(XI)
5841+ 39AF 19                   add     HL,DE           ; X=XC+XI
5842+ 39B0 22 DE 81             ld      (X1),HL         ; store X
5843+ 39B3 CD 81 3A             call    VALIDX          ; check if X is valid (0~255)
5844+ 39B6 DA CC 39             jp      C,CNTCL3        ; if Carry is set, X is not valid
5845+ 39B9 AF                   xor     A               ; clear Carry
5846+ 39BA 2A E8 81             ld      HL,(YC)
5847+ 39BD ED 5B EE 81          ld      DE,(YI)
5848+ 39C1 ED 52                sbc     HL,DE           ; Y=YC-YI
5849+ 39C3 22 E0 81             ld      (Y1),HL         ; store Y
5850+ 39C6 CD 86 3A             call    VALIDY          ; check if Y is valid (0~191)
5851+ 39C9 D4 14 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5852+ 39CC AF           CNTCL3: xor     A               ; clear Carry
5853+ 39CD 2A E6 81             ld      HL,(XC)
5854+ 39D0 ED 5B EC 81          ld      DE,(XI)
5855+ 39D4 ED 52                sbc     HL,DE           ; X=XC-XI
5856+ 39D6 22 DE 81             ld      (X1),HL         ; store X
5857+ 39D9 CD 81 3A             call    VALIDX          ; check if X is valid (0~255)
5858+ 39DC DA F2 39             jp      C,CNTCL4        ; if Carry is set, X is not valid
5859+ 39DF AF                   xor     A               ; clear Carry
5860+ 39E0 2A E8 81             ld      HL,(YC)
5861+ 39E3 ED 5B EE 81          ld      DE,(YI)
5862+ 39E7 ED 52                sbc     HL,DE           ; Y=YC-YI
5863+ 39E9 22 E0 81             ld      (Y1),HL         ; store Y
5864+ 39EC CD 86 3A             call    VALIDY          ; check if Y is valid (0~191)
5865+ 39EF D4 14 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5866+ 39F2 2A E6 81     CNTCL4: ld      HL,(XC)
5867+ 39F5 ED 5B EE 81          ld      DE,(YI)
5868+ 39F9 19                   add     HL,DE           ; X=XC+YI
5869+ 39FA 22 DE 81             ld      (X1),HL         ; store X
5870+ 39FD CD 81 3A             call    VALIDX          ; check if X is valid (0~255)
5871+ 3A00 DA 14 3A             jp      C,CNTCL5        ; if Carry is set, X is not valid
5872+ 3A03 2A E8 81             ld      HL,(YC)
5873+ 3A06 ED 5B EC 81          ld      DE,(XI)
5874+ 3A0A 19                   add     HL,DE           ; Y=YC+XI
5875+ 3A0B 22 E0 81             ld      (Y1),HL         ; store Y
5876+ 3A0E CD 86 3A             call    VALIDY          ; check if Y is valid (0~191)
5877+ 3A11 D4 14 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5878+ 3A14 AF           CNTCL5: xor     A               ; clear Carry
5879+ 3A15 2A E6 81             ld      HL,(XC)
5880+ 3A18 ED 5B EE 81          ld      DE,(YI)
5881+ 3A1C ED 52                sbc     HL,DE           ; X=XC-YI
5882+ 3A1E 22 DE 81             ld      (X1),HL         ; store X
5883+ 3A21 CD 81 3A             call    VALIDX          ; check if X is valid (0~255)
5884+ 3A24 DA 38 3A             jp      C,CNTCL6        ; if Carry is set, X is not valid
5885+ 3A27 2A E8 81             ld      HL,(YC)
5886+ 3A2A ED 5B EC 81          ld      DE,(XI)
5887+ 3A2E 19                   add     HL,DE           ; Y=YC+XI
5888+ 3A2F 22 E0 81             ld      (Y1),HL         ; store Y
5889+ 3A32 CD 86 3A             call    VALIDY          ; check if Y is valid (0~191)
5890+ 3A35 D4 14 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5891+ 3A38 2A E6 81     CNTCL6: ld      HL,(XC)
5892+ 3A3B ED 5B EE 81          ld      DE,(YI)
5893+ 3A3F 19                   add     HL,DE           ; X=XC+YI
5894+ 3A40 22 DE 81             ld      (X1),HL         ; store X
5895+ 3A43 CD 81 3A             call    VALIDX          ; check if X is valid (0~255)
5896+ 3A46 DA 5C 3A             jp      C,CNTCL7        ; if Carry is set, X is not valid
5897+ 3A49 AF                   xor     A               ; clear Carry
5898+ 3A4A 2A E8 81             ld      HL,(YC)
5899+ 3A4D ED 5B EC 81          ld      DE,(XI)
5900+ 3A51 ED 52                sbc     HL,DE           ; Y=YC-XI
5901+ 3A53 22 E0 81             ld      (Y1),HL         ; store Y
5902+ 3A56 CD 86 3A             call    VALIDY          ; check if Y is valid (0~191)
5903+ 3A59 D4 14 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5904+ 3A5C AF           CNTCL7: xor     A               ; clear Carry
5905+ 3A5D 2A E6 81             ld      HL,(XC)
5906+ 3A60 ED 5B EE 81          ld      DE,(YI)
5907+ 3A64 ED 52                sbc     HL,DE           ; X=XC-YI
5908+ 3A66 22 DE 81             ld      (X1),HL         ; store X
5909+ 3A69 CD 81 3A             call    VALIDX          ; check if X is valid (0~255)
5910+ 3A6C D8                   ret     C               ; if Carry is set, X is not valid
5911+ 3A6D AF                   xor     A               ; clear Carry
5912+ 3A6E 2A E8 81             ld      HL,(YC)
5913+ 3A71 ED 5B EC 81          ld      DE,(XI)
5914+ 3A75 ED 52                sbc     HL,DE           ; Y=YC-XI
5915+ 3A77 22 E0 81             ld      (Y1),HL         ; store Y
5916+ 3A7A CD 86 3A             call    VALIDY          ; check if Y is valid (0~191)
5917+ 3A7D D4 14 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5918+ 3A80 C9                   ret                     ; return to caller
5919+ 3A81
5920+ 3A81              ; check if X,Y coordinates are valid: 0<=X<=255 and 0<=Y<=191
5921+ 3A81              ; input: HL (value to check), can be negative
5922+ 3A81              ; output: CARRY flag: reset => VALID  //  set => NOT VALID
5923+ 3A81              ; destroys: A
5924+ 3A81 AF           VALIDX: xor     A               ; reset A
5925+ 3A82 B4                   or      H               ; check if H is 0 (this means that X is in range 0~255 and not negative)
5926+ 3A83 C8                   ret     Z               ; yes, we can return (C is clear)
5927+ 3A84 37                   scf                     ; set Carry flag to raise error
5928+ 3A85 C9                   ret                     ; return to caller
5929+ 3A86
5930+ 3A86 AF           VALIDY: xor     A               ; reset A
5931+ 3A87 B4                   or      H               ; check if H is 0 (this means that Y is in range 0~255 and not negative)
5932+ 3A88 28 02                jr      Z,CNTVALY       ; yes, continue checking
5933+ 3A8A 37                   scf                     ; no, raise error by setting Carry flag
5934+ 3A8B C9                   ret                     ; return to caller
5935+ 3A8C 7D           CNTVALY:ld      A,L
5936+ 3A8D FE C0                cp      $C0             ; is Y<192? Carry is set if Y<192
5937+ 3A8F 3F                   ccf                     ; invert Carry, so Carry=0 means OK, Carry=1 means ERROR
5938+ 3A90 C9                   ret                     ; return to caller
5939+ 3A91
5940+ 3A91
5941+ 3A91              ; clear VIDEOBUFF before using it as temp buffer
5942+ 3A91 AF           CLRVDBF:xor     A               ; clear A
5943+ 3A92 C5                   push    BC              ; store BC
5944+ 3A93 E5                   push    HL              ; store HL
5945+ 3A94 21 DE 81             ld      HL,TMPBFR1      ; address of 1st cell
5946+ 3A97 06 06                ld      B,$06           ; 6 cells
5947+ 3A99 77           RPTCVB1:ld      (HL),A          ; clear cell
5948+ 3A9A 23                   inc     HL              ; next cell
5949+ 3A9B 10 FC                djnz    RPTCVB1         ; repeat
5950+ 3A9D 06 28                ld      B,$28           ; 40 cells
5951+ 3A9F 21 E6 81             ld      HL,VIDEOBUFF    ; address of 1st cell
5952+ 3AA2 77           RPTCVB2:ld      (HL),A          ; clear cell
5953+ 3AA3 23                   inc     HL              ; next cell
5954+ 3AA4 10 FC                djnz    RPTCVB2         ; repeat
5955+ 3AA6 E1                   pop     HL              ; retrieve HL
5956+ 3AA7 C1                   pop     BC              ; retrieve BC
5957+ 3AA8 C9                   ret                     ; return to caller
5958+ 3AA9
5959+ 3AA9
5960+ 3AA9              ; check if a color is passed as argument with PLOT, DRAW, and CIRCLE
5961+ 3AA9              ; commands. If not present, the default foreground color will be used
5962+ 3AA9 3A DC 81     CLRPRM: ld      A,(FRGNDCLR)    ; load foreground color
5963+ 3AAC 32 E2 81             ld      (TMPBFR3),A     ; store into temp buffer
5964+ 3AAF 2B                   dec     HL              ; dec 'cos GETCHR INCs
5965+ 3AB0 CD E3 1B             call    GETCHR          ; Get next character
5966+ 3AB3 C8                   ret     Z               ; return foreground color if nothing follows
5967+ 3AB4 CD A2 19             call    CHKSYN          ; Make sure ',' follows
5968+ 3AB7 2C                   defb    ','
5969+ 3AB8 CD F2 28             call    GETINT          ; get value
5970+ 3ABB CD B6 34             call    CHKCLR0         ; check if color is in range 0~15
5971+ 3ABE 32 E2 81             ld      (TMPBFR3),A     ; store color into temp buffer
5972+ 3AC1 C9                   ret                     ; return to caller
5973+ 3AC2
5974+ 3AC2
5975+ 3AC2              ; no graphics mode error: raised when a graphics command is invoked
5976+ 3AC2              ; out of graphic 2 mode.
5977+ 3AC2 1E 2A        GMERR:  ld      E,GM            ; load Graphics Mode Error flag
5978+ 3AC4 C3 D4 16             jp      ERROR           ; print error
5979+ 3AC7
5980+ 3AC7
5981+ 3AC7              ; set a serial port: params are PORT,BPS,DATA,PARITY,STOP
5982+ 3AC7              ; PORT=1/2; BPS=1,200~57,600 (see below), DATA=5/6/7/8
5983+ 3AC7              ; PARITY: 0=no parity; 1=ODD parity; 2=EVEN parity;
5984+ 3AC7              ; STOP=0/1/2/3: 0=0 bit; 1=1 bit; 2=1.5 bits; 3=2 bits
5985+ 3AC7              ; PORT 1 acts as a char device; PORT 2 acts as a block device
5986+ 3AC7              ; DATA,PARITY, and STOP are optional: if nothing follows BPS,
5987+ 3AC7              ; they are assumed to be 8,0,1 resp.
5988+ 3AC7              PRTNUM  equ     VIDEOBUFF
5989+ 3AC7              BPS     equ     VIDEOBUFF+$01
5990+ 3AC7              DATABT  equ     BPS+$02
5991+ 3AC7              PARBT   equ     DATABT+$01
5992+ 3AC7              STPBT   equ     PARBT+$01
5993+ 3AC7              SIOBFR  equ     STPBT+$01
5994+ 3AC7 CD F2 28     SERIAL: call    GETINT          ; get port #
5995+ 3ACA A7                   and     A               ; is it zero?
5996+ 3ACB CA AE 1C             jp      Z,FCERR         ; yes, error
5997+ 3ACE FE 03                cp      $03             ; is it 1 or 2?
5998+ 3AD0 D2 F0 3C             jp      NC,SCERR        ; no, error
5999+ 3AD3 32 E6 81             ld      (PRTNUM),A      ; store port number into a temp buffer
6000+ 3AD6 CD A2 19             call    CHKSYN          ; Make sure ',' follows
6001+ 3AD9 2C                   defb    ','
6002+ 3ADA 2B                   dec     HL
6003+ 3ADB CD E3 1B             call    GETCHR          ; check what's following
6004+ 3ADE CA C0 16             jp      Z,SNERR         ; error if nothing follows
6005+ 3AE1 30 05                jr      NC,SERVAR       ; it's not a number, try a variable
6006+ 3AE3 CD B3 1C             call    ATOH            ; get bps (returned into DE)
6007+ 3AE6 18 0F                jr      CHKZSER         ; jump over
6008+ 3AE8 CD 6C 20     SERVAR: call    GETNUM          ; get number
6009+ 3AEB CD 79 2E             call    TSTSGN          ; check value
6010+ 3AEE FA AE 1C             jp      M,FCERR         ; negative - illegal function call
6011+ 3AF1 3A 35 82             ld      A,(FPEXP)       ; Get integer value to DE
6012+ 3AF4 CD 21 2F             call    FPINT           ; get integer number into BCDE - drop BC 'cause isn't necessary
6013+ 3AF7 7A           CHKZSER:ld      A,D             ; bps is into DE - move MSB into A
6014+ 3AF8 B3                   or      E               ; check if bps=0
6015+ 3AF9 20 3A                jr      NZ,CNTSER       ; no, continue checking
6016+ 3AFB                      ; if baud rate is 0, then close the serial comm.
6017+ 3AFB 3A E6 81     RSTSERS:ld      A,(PRTNUM)      ; yes, so reset the channel. First, load port number
6018+ 3AFE 3D                   dec     A               ; subtract 1, so that serial channel is 0=>A and 1=>B
6019+ 3AFF C6 22                add     SIO_CA          ; find correct channel
6020+ 3B01 4F                   ld      C,A             ; store serial channel
6021+ 3B02 F3                   di                      ; disable INTs
6022+ 3B03 AF                   xor     A               ; reset A
6023+ 3B04 16 01                ld      D,$01           ; start from WR1
6024+ 3B06 06 05                ld      B,$05           ; 5 registers
6025+ 3B08 ED 51        RPTRSSR:out     (C),D           ; select register
6026+ 3B0A ED 79                out     (C),A           ; reset register
6027+ 3B0C 14                   inc     D               ; next register
6028+ 3B0D 10 F9                djnz    RPTRSSR         ; repeat
6029+ 3B0F 3E 30                ld      A,%00110000     ; write into WR0: error reset, select WR0
6030+ 3B11 ED 79                out     (C),A           ; send command to serial channel
6031+ 3B13 3E 18                ld      A,%00011000     ; write into WR0: channel reset
6032+ 3B15 ED 79                out     (C),A           ; send command to serial channel
6033+ 3B17 FB                   ei                      ; re-enable INTs
6034+ 3B18 E5                   push    HL              ; store HL
6035+ 3B19 21 20 82             ld      HL,SERIALS_EN   ; serials enabled status byte
6036+ 3B1C DB 01                in      A,(PIO_DB)      ; read status LEDs
6037+ 3B1E CB 41                bit     0,C             ; check serial port
6038+ 3B20 20 09                jr      NZ,SRPT2        ; if bit is set, jump to port 2
6039+ 3B22 CB B7                res     6,A             ; it's port 1
6040+ 3B24 CB A7                res     4,A             ; remove possible error LED
6041+ 3B26 CB 86                res     0,(HL)          ; disable port 1
6042+ 3B28 C3 31 3B             jp      SERLED          ; jump over
6043+ 3B2B CB BF        SRPT2:  res     7,A             ; it's port 2
6044+ 3B2D CB AF                res     5,A             ; remove possible error LED
6045+ 3B2F CB 8E                res     1,(HL)          ; disable port 2
6046+ 3B31 D3 01        SERLED: out     (PIO_DB),A      ; send new configuration
6047+ 3B33 E1                   pop     HL              ; retrieve HL
6048+ 3B34 C9                   ret                     ; return to caller
6049+ 3B35                      ; check if bps=1, meaning reactivate RX on serial
6050+ 3B35 7A           CNTSER: ld      A,D
6051+ 3B36 B2                   or      D               ; check if bps<>1 by first checking D=0
6052+ 3B37 20 36                jr      NZ,CNTSER2      ; if not, jump over
6053+ 3B39 7B                   ld      A,E             ; then by checking that
6054+ 3B3A FE 01                cp      $01             ; E=1
6055+ 3B3C 20 31                jr      NZ,CNTSER2      ; if not, jump over
6056+ 3B3E 3A E6 81             ld      A,(PRTNUM)      ; load port number
6057+ 3B41 57                   ld      D,A             ; store port on D
6058+ 3B42 3A 20 82             ld      A,(SERIALS_EN)  ; load address of serial status cell
6059+ 3B45 A2                   and     D               ; check status
6060+ 3B46 CA F0 3C             jp      Z,SCERR         ; port not open, raise error
6061+ 3B49 F3                   di                      ; disable INTs
6062+ 3B4A 7A                   ld      A,D             ; move port # into A
6063+ 3B4B 5F                   ld      E,A             ; and also into E
6064+ 3B4C 87                   add     A
6065+ 3B4D 87                   add     A               ; move A to left times 2
6066+ 3B4E 57                   ld      D,A             ; move value into D
6067+ 3B4F 3A 20 82             ld      A,(SERIALS_EN)  ; load serial status byte
6068+ 3B52 B2                   or      D               ; re-enable RX
6069+ 3B53 32 20 82             ld      (SERIALS_EN),A  ; store new serial status
6070+ 3B56 7B                   ld      A,E             ; recover port #
6071+ 3B57 3D                   dec     A               ; check port
6072+ 3B58 20 0A                jr      NZ,CNTRX2       ; port is #2
6073+ 3B5A CD DA 01             call    SIO_A_EI        ; re-enable RX on port 1
6074+ 3B5D DB 01                in      A,(PIO_DB)      ; load status LEDs
6075+ 3B5F CB A7                res     4,A             ; remove error LED
6076+ 3B61 C3 6B 3B             jp      RXEND           ; terminate setting
6077+ 3B64 CD E2 01     CNTRX2: call    SIO_B_EI        ; re-enable RX on port 2
6078+ 3B67 DB 01                in      A,(PIO_DB)      ; load status LEDs
6079+ 3B69 CB AF                res     5,A             ; remove error LED
6080+ 3B6B D3 01        RXEND:  out     (PIO_DB),A      ; set new status for LEDs
6081+ 3B6D FB                   ei                      ; re-enable INTs
6082+ 3B6E C9                   ret                     ; return to caller
6083+ 3B6F                      ; set serial port comm.
6084+ 3B6F D5           CNTSER2:push    DE              ; store BPS
6085+ 3B70 3A E6 81             ld      A,(PRTNUM)      ; load port number
6086+ 3B73 57                   ld      D,A             ; move port # into D
6087+ 3B74 3A 20 82             ld      A,(SERIALS_EN)  ; check if serial port is already open
6088+ 3B77 A2                   and     D               ; by ANDing A with D
6089+ 3B78 D1                   pop     DE              ; retrieve BPS
6090+ 3B79 CA 81 3B             jp      Z,CNTSER3       ; not open, continue
6091+ 3B7C 1E 2E                ld      E,SA            ; already open, so raise a "Serial Port Already Error"
6092+ 3B7E C3 D4 16             jp      ERROR           ; and leave
6093+ 3B81 E5           CNTSER3:push    HL              ; store HL
6094+ 3B82 21 00 E1             ld      HL,$E100        ; check bps. start with HL=57,600
6095+ 3B85 CD AF 3F             call    CMP16           ; is bps<=57,600?
6096+ 3B88 E1                   pop     HL              ; but first, recover HL
6097+ 3B89 DA F0 3C             jp      C,SCERR         ; no (bps>57,600) then error
6098+ 3B8C ED 53 E7 81          ld      (BPS),DE        ; store bps
6099+ 3B90 2B                   dec     HL              ; dec 'cos GETCHR INCs
6100+ 3B91 CD E3 1B             call    GETCHR          ; Get next character
6101+ 3B94 CA CC 3B             jp      Z,DEFSER        ; defaults if nothing follows
6102+ 3B97 CD A2 19             call    CHKSYN          ; Make sure ',' follows
6103+ 3B9A 2C                   defb    ','
6104+ 3B9B CD F2 28             call    GETINT          ; get data bits
6105+ 3B9E FE 05                cp      $05             ; is it <5?
6106+ 3BA0 DA F0 3C             jp      C,SCERR         ; yes, error
6107+ 3BA3 FE 09                cp      $09             ; is it >=9?
6108+ 3BA5 D2 AE 1C             jp      NC,FCERR        ; yes, error
6109+ 3BA8 32 E9 81             ld      (DATABT),A      ; store data bits
6110+ 3BAB CD A2 19             call    CHKSYN          ; Make sure ',' follows
6111+ 3BAE 2C                   defb    ','
6112+ 3BAF CD F2 28             call    GETINT          ; get parity bits
6113+ 3BB2 BF FE 03             cp      A,$03           ; check if parity is in range 0~2
6114+ 3BB5 D2 F0 3C             jp      NC,SCERR        ; no, error
6115+ 3BB8 32 EA 81             ld      (PARBT),A       ; store parity
6116+ 3BBB CD A2 19             call    CHKSYN          ; Make sure ',' follows
6117+ 3BBE 2C                   defb    ','
6118+ 3BBF CD F2 28             call    GETINT          ; get stop bits
6119+ 3BC2 FE 03                cp      $03             ; is it >=3?
6120+ 3BC4 D2 F0 3C             jp      NC,SCERR        ; yes, error
6121+ 3BC7 32 EB 81             ld      (STPBT),A       ; store stop bits
6122+ 3BCA 18 0D                jr      SETSER          ; jump to set serial
6123+ 3BCC 3E 08        DEFSER: ld      A,$08           ; 8 bits for data
6124+ 3BCE 32 E9 81             ld      (DATABT),A
6125+ 3BD1 AF                   xor     A               ; no parity bit
6126+ 3BD2 32 EA 81             ld      (PARBT),A
6127+ 3BD5 3C                   inc     A               ; 1 bit for stop
6128+ 3BD6 32 EB 81             ld      (STPBT),A
6129+ 3BD9                      ; check if bps are legal
6130+ 3BD9 E5           SETSER: push    HL              ; store HL
6131+ 3BDA D5                   push    DE              ; store DE
6132+ 3BDB DD E5                push    IX              ; store IX
6133+ 3BDD DD 21 CB 3C          ld      IX,SUP_BPS      ; allowed BPSs
6134+ 3BE1 06 0B                ld      B,$0B           ; 11 items
6135+ 3BE3 0E 00                ld      C,$00           ; reset pointer
6136+ 3BE5 2A E7 81     CKBPS:  ld      HL,(BPS)        ; load BPS
6137+ 3BE8 DD 5E 00             ld      E,(IX+0)        ; load LSB of item
6138+ 3BEB DD 56 01             ld      D,(IX+1)        ; load MSB of item
6139+ 3BEE CD AF 3F             call    CMP16           ; is it equal?
6140+ 3BF1 CA FE 3B             jp      Z,SET_PT        ; yes, found a correspondance
6141+ 3BF4 DD 23                inc     IX
6142+ 3BF6 DD 23                inc     IX              ; no, go to next entry
6143+ 3BF8 0C                   inc     C               ; increment pointer
6144+ 3BF9 10 EA                djnz    CKBPS           ; repeat for 10 entries
6145+ 3BFB C3 EC 3C             jp      SCERR1          ; if nothing found, raise an error
6146+ 3BFE              SET_PT: ;init CTC CH0: CH0 provides RX/TX clock to SIO port A
6147+ 3BFE                      ; TO0 output frequency=INPUT CLK/time constant. Time constant is set to get 16 times
6148+ 3BFE                      ; the requested baud rate. I.e., if bps is 19,200 then time constast is set to 6 because
6149+ 3BFE                      ; 1,843,200/6 = 307,200 Hz (that is 19,200 x 16)
6150+ 3BFE F3                   di                      ; disable INTs
6151+ 3BFF 06 00                ld      B,$00           ; reset B
6152+ 3C01 21 E1 3C             ld      HL,CTC_CFG      ; address of first CTC divider
6153+ 3C04 09                   add     HL,BC           ; adjust for correct CTC divider
6154+ 3C05 0E 10                ld      C,CTC_CH0       ; CTC channel 0
6155+ 3C07 3A E6 81             ld      A,(PRTNUM)      ; load port number
6156+ 3C0A 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6157+ 3C0B DA 0F 3C             jp      C,SET_CTC       ; port 1 => ch. 0, so continue
6158+ 3C0E 0C                   inc     C               ; port 2 => ch. 1, increment address port into C
6159+ 3C0F 3E 47        SET_CTC:ld      A,%01000111     ; interrupt off, counter mode, prsc=16 (doesn't matter), ext. start,
6160+ 3C11                                              ; start upon loading time constant, time constant follows, sw reset, command word
6161+ 3C11 ED 79                out     (C),A           ; configure CTC channel
6162+ 3C13 7E                   ld      A,(HL)          ; load CTC divider
6163+ 3C14 ED 79                out     (C),A           ; send divider
6164+ 3C16                      ; configure SIO
6165+ 3C16 21 56 03             ld      HL,SIO_A_SETS   ; load default settings for SIO
6166+ 3C19 11 EC 81             ld      DE,SIOBFR       ; into a temp buffer
6167+ 3C1C 01 0A 00             ld      BC,$000A        ; 10 items to copy
6168+ 3C1F ED B0                ldir                    ; copy SIO settings into TEMP buffer
6169+ 3C21 3A F1 81             ld      A,(SIOBFR+5)    ; load WR5 setting
6170+ 3C24 47                   ld      B,A             ; move it into B
6171+ 3C25 3A E9 81             ld      A,(DATABT)      ; load DATA bits
6172+ 3C28 FE 05                cp      $05             ; is it 5 bits?
6173+ 3C2A 20 06                jr      NZ,BITS6        ; no, jump over
6174+ 3C2C CB B0                res     6,B
6175+ 3C2E CB A8                res     5,B             ; set D6 & D5 to 0
6176+ 3C30 18 19                jr      SETPAR          ; jump to set parity
6177+ 3C32 FE 06        BITS6:  cp      $06             ; is it 6 bits?
6178+ 3C34 20 06                jr      NZ,BITS7        ; no, jump over
6179+ 3C36 CB F0                set     6,B
6180+ 3C38 CB A8                res     5,B             ; set D6 & D5 to 1,0
6181+ 3C3A 18 0F                jr      SETPAR          ; jump to set parity
6182+ 3C3C FE 07        BITS7:  cp      $07             ; is it 7 bits?
6183+ 3C3E 20 07                jr      NZ,BITS8        ; no, jump over
6184+ 3C40 CB B0                res     6,B
6185+ 3C42 CB E8                set     5,B             ; set D6 & D5 to 0,1
6186+ 3C44 C3 4B 3C             jp      SETPAR          ; jump to set parity
6187+ 3C47 CB F0        BITS8:  set     6,B
6188+ 3C49 CB E8                set     5,B             ; set D6 & D5 to 1,1
6189+ 3C4B 21 21 82     SETPAR: ld      HL,SERABITS     ; load address for storing data bits
6190+ 3C4E 3A E6 81             ld      A,(PRTNUM)      ; check serial port number
6191+ 3C51 3D                   dec     A               ; is it port #1?
6192+ 3C52 CA 56 3C             jp      Z,SETPAR2       ; yes, jump over
6193+ 3C55 23                   inc     HL              ; port #2, use SERBBITS instead
6194+ 3C56 78           SETPAR2:ld      A,B             ; retrieve DATA bits
6195+ 3C57 32 F1 81             ld      (SIOBFR+5),A    ; save DATA bits
6196+ 3C5A E6 60                and     %01100000       ; filter only D5&D6 bits
6197+ 3C5C 87                   add     A,A             ; shift left times 1
6198+ 3C5D 77                   ld      (HL),A          ; store for SIO_EI & SIO_DI functions
6199+ 3C5E 3A EB 81             ld      A,(STPBT)       ; load STOP bits
6200+ 3C61 87                   add     A,A
6201+ 3C62 87                   add     A,A             ; 2 left shifts
6202+ 3C63 47                   ld      B,A             ; move forming byte into B
6203+ 3C64 3A EA 81             ld      A,(PARBT)       ; load PARITY setting
6204+ 3C67 A7                   and     A               ; is it 0?
6205+ 3C68 CA 73 3C             jp      Z,STRPAR        ; yes, jump over
6206+ 3C6B CB C0                set     0,B             ; set PARITY on
6207+ 3C6D 3D                   dec     A               ; is parity ODD?
6208+ 3C6E CA 73 3C             jp      Z,STRPAR        ; yes, so jump over
6209+ 3C71 CB C8                set     1,B             ; no, it's EVEN so set the corresponding bit
6210+ 3C73 3A EF 81     STRPAR: ld      A,(SIOBFR+3)    ; load WR4 setting
6211+ 3C76 E6 F0                and     %11110000       ; reset STOP & PARITY bits
6212+ 3C78 B0                   or      B               ; set new STOP & PARITY bits
6213+ 3C79 32 EF 81             ld      (SIOBFR+3),A    ; store new value
6214+ 3C7C                      ;set up TX and RX:
6215+ 3C7C                      ; the followings are settings for channel A
6216+ 3C7C 21 EC 81             ld      HL,SIOBFR       ; settings for SIO ch. A
6217+ 3C7F 06 06                ld      B,$06           ; 6 bytes to send
6218+ 3C81 0E 22                ld      C,SIO_CA        ; I/O address of SIO ch.A
6219+ 3C83 3A E6 81             ld      A,(PRTNUM)      ; load port number
6220+ 3C86 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6221+ 3C87 DA 8B 3C             jp      C,SRLCNT        ; port 1, continue
6222+ 3C8A 0C                   inc     C               ; port 2, increment address port into C
6223+ 3C8B ED B3        SRLCNT: otir                    ; send bytes to SIO
6224+ 3C8D                      ; the following are settings for channel B (don't need to load HL since settings are contigous)
6225+ 3C8D 06 04                ld      B,$04           ; other 4 bytes to send
6226+ 3C8F 51                   ld      D,C             ; store port address into D
6227+ 3C90 0E 23                ld      C,SIO_CB        ; I/O address of SIO ch.B
6228+ 3C92 ED B3                otir                    ; send bytes to SIO
6229+ 3C94                      ; the following are settings for selected channel
6230+ 3C94 3E 01                ld      A,$01           ; write into WR0: select WR1
6231+ 3C96 4A                   ld      C,D             ; retrieve port address
6232+ 3C97 ED 79                out     (C),A
6233+ 3C99 3E 18                ld      A,%00011000     ; interrupts on every RX char; parity is no special condition;
6234+ 3C9B                                              ; buffer overrun is special condition
6235+ 3C9B ED 79                out     (C),A
6236+ 3C9D 21 20 82             ld      HL,SERIALS_EN
6237+ 3CA0 3A E6 81             ld      A,(PRTNUM)      ; retrieve serial channel
6238+ 3CA3 3D                   dec     A               ; channel A?
6239+ 3CA4 20 10                jr      NZ,ENCHB        ; no, jump over
6240+ 3CA6 CD DA 01             call    SIO_A_EI        ; enable RX on SIO channel A
6241+ 3CA9 CB C6                set     0,(HL)          ; set serial port 1 status ON
6242+ 3CAB CB D6                set     2,(HL)          ; set serial port 1 RX ON
6243+ 3CAD                      ; back to normal running
6244+ 3CAD FB                   ei                      ; re-enable INTs
6245+ 3CAE DB 01                in      A,(PIO_DB)      ; load status LEDs
6246+ 3CB0 CB F7                set     6,A             ; set status LED on
6247+ 3CB2 CB A7                res     4,A             ; set error LED off
6248+ 3CB4 18 0E                jr      EXNRM           ; leave
6249+ 3CB6 CD E2 01     ENCHB:  call    SIO_B_EI        ; enable RX on SIO channel B
6250+ 3CB9 CB CE                set     1,(HL)          ; set serial port 2 status ON
6251+ 3CBB CB DE                set     3,(HL)          ; set serial port 2 RX ON
6252+ 3CBD                      ; back to normal running
6253+ 3CBD FB                   ei                      ; re-enable INTs
6254+ 3CBE DB 01                in      A,(PIO_DB)      ; load status LEDs
6255+ 3CC0 CB FF                set     7,A             ; set status LED on
6256+ 3CC2 CB AF                res     5,A             ; set error LED off
6257+ 3CC4 D3 01        EXNRM:  out     (PIO_DB),A      ; send new configuration
6258+ 3CC6 DD E1                pop     IX              ; retrieve IX
6259+ 3CC8 D1                   pop     DE              ; retrieve DE
6260+ 3CC9 E1                   pop     HL              ; retrieve HL
6261+ 3CCA C9                   ret                     ; return to caller
6262+ 3CCB
6263+ 3CCB              ; allowed bps (Bauds per second)
6264+ 3CCB 00 E1 00 96  SUP_BPS:defw    57600,38400,28800,19200,14400,9600,4800,3600,2400,1200,600
6264+ 3CCF 80 70 00 4B
6264+ 3CD3 40 38 80 25
6264+ 3CD7 C0 12 10 0E
6264+ 3CDB 60 09 B0 04
6264+ 3CDF 58 02
6265+ 3CE1              ; corresponding CTC divider
6266+ 3CE1 02 03 04 06  CTC_CFG:defb    2,3,4,6,8,12,24,32,48,96,192
6266+ 3CE5 08 0C 18 20
6266+ 3CE9 30 60 C0
6267+ 3CEC
6268+ 3CEC
6269+ 3CEC              ; serial configuration error
6270+ 3CEC DD E1        SCERR1: pop     IX              ; retrieve IX
6271+ 3CEE D1                   pop     DE              ; retrieve DE
6272+ 3CEF E1                   pop     HL              ; retrieve HL
6273+ 3CF0 1E 2C        SCERR:  ld      E,SC            ; Serial Configuration Error
6274+ 3CF2 C3 D4 16             jp      ERROR           ; print error
6275+ 3CF5
6276+ 3CF5
6277+ 3CF5              ; serial buffer overrun
6278+ 3CF5 CD B0 1E     SOERR:  call    PRNTCRLF
6279+ 3CF8 1E 30                ld      E,SO            ; Serial Buffer Overrun
6280+ 3CFA C3 D4 16             jp      ERROR
6281+ 3CFD
6282+ 3CFD
6283+ 3CFD              ; check for direct mode
6284+ 3CFD E5           DIRMOD: push    HL              ; Save code string address
6285+ 3CFE 2A AF 80             ld      HL,(LINEAT)     ; Get current line number
6286+ 3D01 23                   inc     HL              ; -1 means direct statement
6287+ 3D02 7C                   ld      A,H
6288+ 3D03 B5                   or      L
6289+ 3D04 E1                   pop     HL              ; Restore code string address
6290+ 3D05 C2 1F 3D             jp      NZ,HLPERR       ; raise error if in indirect mode
6291+ 3D08 C9                   ret
6292+ 3D09
6293+ 3D09
6294+ 3D09              ; HELP lists the line program where an error occured
6295+ 3D09 CD FD 3C     HELP:   call    DIRMOD          ; check if in direct mode
6296+ 3D0C E5                   push    HL              ; store HL
6297+ 3D0D 2A B1 80             ld      HL,(HLPLN)      ; load HELP line
6298+ 3D10 23                   inc     HL              ; increment HL
6299+ 3D11 7C                   ld      A,H
6300+ 3D12 B5                   or      L               ; check if there is a line into the HELP reg.
6301+ 3D13 E1                   pop     HL
6302+ 3D14 CA 1F 3D             jp      Z,HLPERR        ; no line found, raise error
6303+ 3D17 ED 5B B1 80          ld      DE,(HLPLN)      ; recover line
6304+ 3D1B C1                   pop     BC              ; remove BC from stack since it's not needed anymore for LIST
6305+ 3D1C C3 30 1A             jp      LST01H          ; jump to list line
6306+ 3D1F 1E 32        HLPERR: ld      E,HP            ; HELP call error
6307+ 3D21 C3 D4 16             jp      ERROR           ; raise error
6308+ 3D24
6309+ 3D24
6310+ 3D24              ; KEY command to list/modify function keys and auto-repeat
6311+ 3D24 2B           KEY:    dec     HL              ; dec 'cos GETCHR INCs
6312+ 3D25 CD E3 1B             call    GETCHR          ; Get next character
6313+ 3D28 CA A8 3D             jp      Z,LSTKEYS       ; jump if nothing follows
6314+ 3D2B                                              ; change FN keys
6315+ 3D2B CD F2 28             call    GETINT          ; get a number
6316+ 3D2E A7                   and     A               ; is it 0?
6317+ 3D2F 20 10                jr      NZ,KEYCH        ; no, jump over
6318+ 3D31 E5           RESFN:  push    HL              ; yes - reset FN keys to defaults
6319+ 3D32 D5                   push    DE              ; store HL & DE
6320+ 3D33 21 AE 15             ld      HL,AUTORP       ; pointer to default auto-repeat delays and FN keys texts
6321+ 3D36 11 B3 80             ld      DE,KEYDEL       ; pointer to destination
6322+ 3D39 01 82 00             ld      BC,$0082        ; 130 chars to be copied (2xauto-delay, 128xFN keys)
6323+ 3D3C ED B0                ldir                    ; restore default texts
6324+ 3D3E D1                   pop     DE              ; retrieve DE
6325+ 3D3F E1                   pop     HL              ; retrieve HL
6326+ 3D40 C9                   ret                     ; return to caller
6327+ 3D41 FE 09        KEYCH:  cp      $09             ; is it >= 9?
6328+ 3D43 D2 5B 3E             jp      NC,SETREP       ; yes - jump over
6329+ 3D46 3D                   dec     A               ; FN key in range 0~7
6330+ 3D47 87                   add     A,A             ; multiply A...
6331+ 3D48 87                   add     A,A             ; ... times 4...
6332+ 3D49 87                   add     A,A             ; ... to get the correct...
6333+ 3D4A 87                   add     A,A             ; ... offset fo FN key text
6334+ 3D4B 32 DE 81             ld      (TMPBFR1),A     ; store FN key offset...
6335+ 3D4E AF                   xor     A               ; ...in a...
6336+ 3D4F 32 DF 81             ld      (TMPBFR1+1),A   ; ...16-bit register
6337+ 3D52 CD A2 19             call    CHKSYN          ; Make sure ',' follows
6338+ 3D55 2C                   defb    ','
6339+ 3D56 44 4D                ld      BC,HL           ; copy address into BC
6340+ 3D58 CD 7E 20             call    EVAL            ; Evaluate expression (in E there is the length)
6341+ 3D5B E5                   push    HL              ; store string pointer
6342+ 3D5C 3A 94 81             ld      A,(TYPE)        ; Get variable type
6343+ 3D5F B7                   or      A               ; Is it a string variable?
6344+ 3D60 CA C0 16             jp      Z,SNERR         ; no - syntax error
6345+ 3D63 CD B7 26             call    GSTRCU          ; Current string to pool
6346+ 3D66 CD C8 2E             call    LOADFP          ; Move string block data to (BC=pointer, DE=length)
6347+ 3D69 7B                   ld      A,E             ; copy length into A
6348+ 3D6A FE 11                cp      $11             ; is length > 16?
6349+ 3D6C DA 71 3D             jp      C,DECLN1        ; no, jump over
6350+ 3D6F 1E 10                ld      E,$10           ; yes, so set length to 16
6351+ 3D71 3E 10        DECLN1: ld      A,$10           ; calculate how many...
6352+ 3D73 93                   sub     E               ; ...null chars needed to fill up...
6353+ 3D74 57                   ld      D,A             ; ...the FN key text
6354+ 3D75 C5                   push    BC              ; store address of string
6355+ 3D76 ED 4B DE 81          ld      BC,(TMPBFR1)    ; load FN key offset
6356+ 3D7A 21 B5 80             ld      HL,FNKEYS       ; load address of FN keys texts
6357+ 3D7D 09                   add     HL,BC           ; get corrected address
6358+ 3D7E C1                   pop     BC              ; retrieve address of string chars
6359+ 3D7F 0A           CPKEY:  ld      A,(BC)          ; load char from string
6360+ 3D80 FE 0D                cp      CR              ; return?
6361+ 3D82 CA 8F 3D             jp      Z,CPKEY2        ; yes, store char
6362+ 3D85 FE 7B                cp      $7B             ; if char > "z" ?
6363+ 3D87 D2 C0 16             jp      NC,SNERR        ; yes - syntax error
6364+ 3D8A FE 20                cp      $20             ; is char < space?
6365+ 3D8C DA C0 16             jp      C,SNERR         ; yes - syntax error
6366+ 3D8F FE 61        CPKEY2: cp      $61             ; is it >= 'a'?
6367+ 3D91 DA 96 3D             jp      C,CPKEY3        ; no, continue
6368+ 3D94 E6 5F                and     %01011111       ; set letters to uppercase
6369+ 3D96 77           CPKEY3: ld      (HL),A          ; store char
6370+ 3D97 23                   inc     HL              ; next string char
6371+ 3D98 03                   inc     BC              ; next free cell
6372+ 3D99 1D                   dec     E               ; decrement E
6373+ 3D9A 20 E3                jr      NZ,CPKEY        ; repeat until 0
6374+ 3D9C AF                   xor     A               ; null char
6375+ 3D9D 14                   inc     D               ; +1 to decrement below
6376+ 3D9E 15           CPKEY1: dec     D               ; how many null chars to insert?
6377+ 3D9F CA A6 3D             jp      Z,CPKYEND       ; no more nulls, so exit
6378+ 3DA2 77                   ld      (HL),A          ; store it
6379+ 3DA3 23                   inc     HL              ; next cell
6380+ 3DA4 18 F8                jr      CPKEY1          ; repeat
6381+ 3DA6 E1           CPKYEND:pop     HL              ; retrieve pointer to string
6382+ 3DA7 C9                   ret                     ; return to caller
6383+ 3DA8                                              ; list FN keys
6384+ 3DA8 E5           LSTKEYS:push    HL              ; Save code string address
6385+ 3DA9 2A AF 80             ld      HL,(LINEAT)     ; Get current line number
6386+ 3DAC 23                   inc     HL              ; -1 means direct statement
6387+ 3DAD 7C                   ld      A,H
6388+ 3DAE B5                   or      L
6389+ 3DAF E1                   pop     HL              ; Restore code string address
6390+ 3DB0 C2 C0 16             jp      NZ,SNERR        ; raise error if in indirect mode
6391+ 3DB3 E5                   push    HL              ; store HL
6392+ 3DB4 D5                   push    DE              ; store DE
6393+ 3DB5 21 B5 80             ld      HL,FNKEYS       ; load starting address of FN keys text
6394+ 3DB8 0E 01                ld      C,$01           ; 8 function keys
6395+ 3DBA 06 10        PRTK4:  ld      B,$10           ; 16 chars each
6396+ 3DBC 11 7D 3E     PRTK2:  ld      DE,CHKEY1       ; message "KEY "
6397+ 3DBF CD 4C 3E             call    PRTCKEY         ; print it
6398+ 3DC2 79                   ld      A,C             ; load FN key
6399+ 3DC3 C6 30                add     $30             ; get number in ASCI code
6400+ 3DC5 CD AD 19             call    OUTC            ; print it
6401+ 3DC8 11 82 3E             ld      DE,CHKEY2       ; message ": ""
6402+ 3DCB CD 4C 3E             call    PRTCKEY         ; print it
6403+ 3DCE 3E 01                ld      A,$01           ; " opened
6404+ 3DD0 32 DE 81             ld      (TMPBFR1),A
6405+ 3DD3 7E           LDKEY:  ld      A,(HL)          ; retrieve char
6406+ 3DD4 A7                   and     A               ; is it zero?
6407+ 3DD5 CA E8 3D             jp      Z,CNTLTK        ; yes, go next char
6408+ 3DD8 CD 34 3E             call    OPNQT           ; check if quotes are opened
6409+ 3DDB FE 22                cp      $22             ; check if char is "?
6410+ 3DDD CA FD 3D             jp      Z,PRTCHR        ; yes, print "chr$("
6411+ 3DE0 FE 0D                cp      CR              ; is it a CR?
6412+ 3DE2 CA FD 3D             jp      Z,PRTCHR        ; yes, print "chr$("
6413+ 3DE5 CD AD 19     PRTK3:  call    OUTC            ; no, just print it
6414+ 3DE8 23           CNTLTK: inc     HL              ; next char
6415+ 3DE9 10 E8                djnz    LDKEY           ; continue until finished
6416+ 3DEB CD 22 3E             call    CLSQT           ; check if quotes are still open
6417+ 3DEE 3E 0D                ld      A,CR            ; go next line
6418+ 3DF0 CD AD 19             call    OUTC            ; print it
6419+ 3DF3 0C                   inc     C               ; next FN key
6420+ 3DF4 79                   ld      A,C             ; check if...
6421+ 3DF5 FE 09                cp      $09             ; finished keys?
6422+ 3DF7 DA BA 3D             jp      C,PRTK4         ; no, repeat 1 more time
6423+ 3DFA D1                   pop     DE              ; retrieve DE
6424+ 3DFB E1                   pop     HL              ; retrieve HL
6425+ 3DFC C9                   ret                     ; return to caller
6426+ 3DFD E5           PRTCHR: push    HL              ; store HL
6427+ 3DFE CD 22 3E             call    CLSQT           ; check if quotes are closed
6428+ 3E01 3E 2B                ld      A,'+'           ; '+' char
6429+ 3E03 CD AD 19             call    OUTC            ; print it
6430+ 3E06 11 85 3E             ld      DE,CHKEY3       ; address of "CHR$("
6431+ 3E09 CD 4C 3E             call    PRTCKEY         ; print it
6432+ 3E0C E1                   pop     HL              ; recover HL
6433+ 3E0D 23                   inc     HL              ; next char
6434+ 3E0E 05                   dec     B               ; increment char counter
6435+ 3E0F 11 8B 3E             ld      DE,CHKEY4       ; load address of RETURN
6436+ 3E12 7E                   ld      A,(HL)          ; load char
6437+ 3E13 FE 0D                cp      CR              ; is it a RETURN?
6438+ 3E15 20 03                jr      NZ,PTCHR1       ; no, jump over
6439+ 3E17 11 8E 3E             ld      DE,CHKEY5       ; yes, load address of "
6440+ 3E1A CD 4C 3E     PTCHR1: call    PRTCKEY         ; print it
6441+ 3E1D 3E 29                ld      A,')'           ; char )
6442+ 3E1F C3 E5 3D             jp      PRTK3           ; continue
6443+ 3E22 F5           CLSQT:  push    AF              ; store A
6444+ 3E23 3A DE 81             ld      A,(TMPBFR1)     ; quote status
6445+ 3E26 A7                   and     A               ; are they closed?
6446+ 3E27 28 09                jr      Z,CLSQT1        ; if yes, return
6447+ 3E29 3E 22                ld      A,$22           ; no, so close them
6448+ 3E2B CD AD 19             call    OUTC            ; print "
6449+ 3E2E AF                   xor     A               ; set quotes
6450+ 3E2F 32 DE 81             ld      (TMPBFR1),A     ; as closed
6451+ 3E32 F1           CLSQT1: pop     AF              ; retrieve A
6452+ 3E33 C9                   ret                     ; return to caller
6453+ 3E34 F5           OPNQT:  push    AF              ; store A
6454+ 3E35 3A DE 81             ld      A,(TMPBFR1)     ; quote status
6455+ 3E38 A7                   and     A               ; are they open?
6456+ 3E39 20 0F                jr      NZ,OPNQT1       ; if yes, return
6457+ 3E3B 3E 2B                ld      A,'+'           ; no, so add '+
6458+ 3E3D CD AD 19             call    OUTC            ; print it
6459+ 3E40 3E 22                ld      A,$22           ; and then open quotes
6460+ 3E42 CD AD 19             call    OUTC            ; print them
6461+ 3E45 3E 01                ld      A,$01           ; set quotes
6462+ 3E47 32 DE 81             ld      (TMPBFR1),A     ; as opened
6463+ 3E4A F1           OPNQT1: pop     AF              ; retrieve A
6464+ 3E4B C9                   ret                     ; return to caller
6465+ 3E4C F5           PRTCKEY:push    AF              ; store original char
6466+ 3E4D 1A           PRTK1:  ld      A,(DE)          ; load char
6467+ 3E4E A7                   and     A               ; is it 0?
6468+ 3E4F CA 59 3E             jp      Z,PRTEND        ; yes, finished printing
6469+ 3E52 CD AD 19             call    OUTC            ; no, print char
6470+ 3E55 13                   inc     DE              ; next char
6471+ 3E56 C3 4D 3E             jp      PRTK1           ; repeat
6472+ 3E59 F1           PRTEND: pop     AF              ; retrieve AF
6473+ 3E5A C9                   ret                     ; return to caller
6474+ 3E5B FE 09        SETREP: cp      $09             ; is it special key 9? (stands for auto-repeat)
6475+ 3E5D C2 C0 16             jp      NZ,SNERR        ; no, raise an error
6476+ 3E60 CD A2 19             call    CHKSYN          ; Check for comma
6477+ 3E63 2C                   defb    ','
6478+ 3E64 CD F2 28             call    GETINT          ; get a number
6479+ 3E67 32 DE 81             ld      (TMPBFR1),A     ; store it
6480+ 3E6A CD A2 19             call    CHKSYN          ; Check for comma
6481+ 3E6D 2C                   defb    ','
6482+ 3E6E CD F2 28             call    GETINT          ; get another number
6483+ 3E71 E5                   push    HL              ; store HL
6484+ 3E72 21 B4 80             ld      HL,AUTOKE       ; address of second cell for key auto-repeat
6485+ 3E75 77                   ld      (HL),A          ; store auto-repeat delay
6486+ 3E76 2B                   dec     HL              ; previous cell
6487+ 3E77 3A DE 81             ld      A,(TMPBFR1)     ; retrieve value
6488+ 3E7A 77                   ld      (HL),A          ; store delay for auto-repeat
6489+ 3E7B E1                   pop     HL              ; retrieve HL
6490+ 3E7C C9                   ret
6491+ 3E7D 4B 45 59 20  CHKEY1: defb    "KEY ",0
6491+ 3E81 00
6492+ 3E82 3A 22 00     CHKEY2: defb    ":",34,0
6493+ 3E85 63 68 72 24  CHKEY3: defb    "chr$(",0
6493+ 3E89 28 00
6494+ 3E8B 31 33 00     CHKEY4: defb    "13",0
6495+ 3E8E 33 34 00     CHKEY5: defb    "34",0
6496+ 3E91
6497+ 3E91
6498+ 3E91              ; LOAD "filename"
6499+ 3E91              ; load a BASIC program from disk
6500+ 3E91 C9           LOAD:   ret                     ; currently a stub for LOAD
6501+ 3E92
6502+ 3E92
6503+ 3E92              ; SAVE "filename"
6504+ 3E92              ; save a BASIC program on disk
6505+ 3E92 C9           SAVE:   ret                     ; currently a stub for SAVE
6506+ 3E93
6507+ 3E93
6508+ 3E93              ; FILES
6509+ 3E93              ; list files on disk
6510+ 3E93 C9           FILES:  ret                     ; currently a stub for FILES
6511+ 3E94
6512+ 3E94
6513+ 3E94              ; ERASE "filename"
6514+ 3E94              ; erase a file from disk
6515+ 3E94 C9           ERASE:  ret                     ; currently a stub for ERASE
6516+ 3E95
6517+ 3E95
6518+ 3E95              ; HEX$(nn) Convert 16 bit number to Hexadecimal string
6519+ 3E95 CD 6F 20     HEX: 	call	TSTNUM          ; Verify it's a number
6520+ 3E98 CD 99 1C             call	DEINT           ; Get integer -32768 to 32767
6521+ 3E9B C5                   push	BC              ; Save contents of BC
6522+ 3E9C 21 37 82             ld      HL,PBUFF        ; load address of PBUFF into HL
6523+ 3E9F 7A                   ld      A,D             ; Get MSB into A
6524+ 3EA0 B7                   or      A               ; OR with LSB to see if param=0
6525+ 3EA1 28 0C                jr      Z,HEX2          ; Skip output if both high digits are zero
6526+ 3EA3 CD CB 3E             call    BYT2ASC         ; Convert D to ASCII
6527+ 3EA6 78                   ld      A,B             ; cechk if B
6528+ 3EA7 FE 30                cp      '0'             ; is 0
6529+ 3EA9 28 02                jr      Z,HEX1          ; Don't store high digit if zero
6530+ 3EAB 70                   ld      (HL),B          ; Store it to PBUFF
6531+ 3EAC 23                   inc     HL              ; Next location
6532+ 3EAD 71           HEX1:   ld      (HL),C          ; Store C to PBUFF+1
6533+ 3EAE 23                   inc     HL              ; Next location
6534+ 3EAF 7B           HEX2:   ld      A,E             ; Get lower byte
6535+ 3EB0 CD CB 3E             call    BYT2ASC         ; Convert E to ASCII
6536+ 3EB3 7A                   ld      A,D
6537+ 3EB4 B7                   or      A
6538+ 3EB5 20 05                jr      NZ,HEX3         ; If upper byte was not zero then always print lower byte
6539+ 3EB7 78                   ld      A,B
6540+ 3EB8 FE 30                cp      '0'             ; If high digit of lower byte is zero then don't print
6541+ 3EBA 28 02                jr      Z,HEX4
6542+ 3EBC 70           HEX3:   ld      (HL),B          ; to PBUFF+2
6543+ 3EBD 23                   inc     HL              ; Next location
6544+ 3EBE 71           HEX4:   ld      (HL),C          ; to PBUFF+3
6545+ 3EBF 23                   inc     HL              ; PBUFF+4 to zero
6546+ 3EC0 AF                   xor     A               ; Terminating character
6547+ 3EC1 77                   ld      (HL),A          ; Store zero to terminate
6548+ 3EC2 23                   inc     HL              ; Make sure PBUFF is terminated
6549+ 3EC3 77                   ld      (HL),A          ; Store the double zero there
6550+ 3EC4 C1                   pop     BC              ; Get BC back
6551+ 3EC5 21 37 82             ld      HL,PBUFF        ; Reset to start of PBUFF
6552+ 3EC8 C3 04 25             jp      STR1            ; Convert the PBUFF to a string and return it
6553+ 3ECB 47           BYT2ASC:ld      B,A             ; Save original value
6554+ 3ECC E6 0F                and     $0F             ; Strip off upper nybble
6555+ 3ECE FE 0A                cp      $0A             ; 0-9?
6556+ 3ED0 38 02                jr      C,ADD30         ; If A-F, add 7 more
6557+ 3ED2 C6 07                add     A,$07           ; Bring value up to ASCII A-F
6558+ 3ED4 C6 30        ADD30:  add     A,$30           ; And make ASCII
6559+ 3ED6 4F                   ld      C,A             ; Save converted char to C
6560+ 3ED7 78                   ld      A,B             ; Retrieve original value
6561+ 3ED8 0F                   rrca                    ; and Rotate it right
6562+ 3ED9 0F                   rrca
6563+ 3EDA 0F                   rrca
6564+ 3EDB 0F                   rrca
6565+ 3EDC E6 0F                and     $0F             ; Mask off upper nybble
6566+ 3EDE FE 0A                cp      $0A             ; 0-9? < A hex?
6567+ 3EE0 38 02                jr      C,ADD301        ; Skip Add 7
6568+ 3EE2 C6 07                add     A,$07           ; Bring it up to ASCII A-F
6569+ 3EE4 C6 30        ADD301: add     A,$30           ; And make it full ASCII
6570+ 3EE6 47                   ld      B,A             ; Store high order byte
6571+ 3EE7 C9                   ret
6572+ 3EE8
6573+ 3EE8              ; Convert "&Hnnnn" to FPREG
6574+ 3EE8              ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
6575+ 3EE8              ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
6576+ 3EE8 EB           HEXTFP: ex      DE,HL           ; Move code string pointer to DE
6577+ 3EE9 21 00 00             ld      HL,$0000        ; Zero out the value
6578+ 3EEC CD 01 3F             call    GETHEX          ; Check the number for valid hex
6579+ 3EEF DA 21 3F             jp      C,HXERR         ; First value wasn't hex, HX error
6580+ 3EF2 18 05                jr      HEXLP1          ; Convert first character
6581+ 3EF4 CD 01 3F     HEXLP:  call    GETHEX          ; Get second and addtional characters
6582+ 3EF7 38 1F                jr      C,HEXIT         ; Exit if not a hex character
6583+ 3EF9 29           HEXLP1: add     HL,HL           ; Rotate 4 bits to the left
6584+ 3EFA 29                   add     HL,HL
6585+ 3EFB 29                   add     HL,HL
6586+ 3EFC 29                   add     HL,HL
6587+ 3EFD B5                   or      L               ; Add in D0-D3 into L
6588+ 3EFE 6F                   ld      L,A             ; Save new value
6589+ 3EFF 18 F3                jr      HEXLP           ; And continue until all hex characters are in
6590+ 3F01
6591+ 3F01 13           GETHEX: inc     DE              ; Next location
6592+ 3F02 1A                   ld      A,(DE)          ; Load character at pointer
6593+ 3F03 FE 20                cp      SPC
6594+ 3F05 CA 01 3F             jp      Z,GETHEX        ; Skip spaces
6595+ 3F08 D6 30                sub     $30             ; Get absolute value
6596+ 3F0A D8                   ret     C               ; < "0", error
6597+ 3F0B FE 0A                cp      $0A
6598+ 3F0D 38 05                jr      C,NOSUB7        ; Is already in the range 0-9
6599+ 3F0F D6 07                sub     $07             ; Reduce to A-F
6600+ 3F11 FE 0A                cp      $0A             ; Value should be $0A-$0F at this point
6601+ 3F13 D8                   ret     C               ; CY set if was :            ; < = > ? @
6602+ 3F14 FE 10        NOSUB7: cp      $10             ; > Greater than "F"?
6603+ 3F16 3F                   ccf
6604+ 3F17 C9                   ret                     ; CY set if it wasn't valid hex
6605+ 3F18
6606+ 3F18 EB           HEXIT:  ex      DE,HL           ; Value into DE, Code string into HL
6607+ 3F19 7A                   ld      A,D             ; Load DE into AC
6608+ 3F1A 4B                   ld      C,E             ; For prep to
6609+ 3F1B E5                   push    HL
6610+ 3F1C CD 55 24             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6611+ 3F1F E1                   pop     HL
6612+ 3F20 C9                   ret
6613+ 3F21
6614+ 3F21 DD 5C        HXERR:  ld      E,HX            ; ?HEX Error
6615+ 3F23 C3 D4 16             jp      ERROR
6616+ 3F26
6617+ 3F26              ; BIN$(NN) Convert integer to a 1-16 char binary string
6618+ 3F26 CD 6F 20     BIN:    call    TSTNUM          ; Verify it's a number
6619+ 3F29 CD 99 1C             call    DEINT           ; Get integer -32768 to 32767
6620+ 3F2C C5           BIN2:   push    BC              ; Save contents of BC
6621+ 3F2D 21 37 82             ld      HL,PBUFF
6622+ 3F30 06 11                ld      B,$11           ; One higher than max char count (16+1)
6623+ 3F32              ZEROSUP:                        ; Suppress leading zeros
6624+ 3F32 05                   dec     B               ; Max 16 chars
6625+ 3F33 78                   ld      A,B
6626+ 3F34 FE 01                cp      $01
6627+ 3F36 28 08                jr      Z,BITOUT        ; Always output at least one character
6628+ 3F38 CB 13                rl      E
6629+ 3F3A CB 12                rl      D
6630+ 3F3C 30 F4                jr      NC,ZEROSUP
6631+ 3F3E 18 04                jr      BITOUT2
6632+ 3F40 CB 13        BITOUT: rl      E
6633+ 3F42 CB 12                rl      D               ; Top bit now in carry
6634+ 3F44 3E 30        BITOUT2:ld      A,'0'           ; Char for '0'
6635+ 3F46 CE 00                adc     A,$00           ; If carry set then '0' --> '1'
6636+ 3F48 77                   ld      (HL),A
6637+ 3F49 23                   inc     HL
6638+ 3F4A 05                   dec     B
6639+ 3F4B 20 F3                jr      NZ,BITOUT
6640+ 3F4D AF                   xor     A               ; Terminating character
6641+ 3F4E 77                   ld      (HL),A          ; Store zero to terminate
6642+ 3F4F 23                   inc     HL              ; Make sure PBUFF is terminated
6643+ 3F50 77                   ld      (HL),A          ; Store the double zero there
6644+ 3F51 C1                   pop     BC
6645+ 3F52 21 37 82             ld      HL,PBUFF
6646+ 3F55 C3 04 25             jp      STR1
6647+ 3F58
6648+ 3F58              ; Convert "&Bnnnn" to FPREG
6649+ 3F58              ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
6650+ 3F58 EB           BINTFP: ex      DE,HL           ; Move code string pointer to DE
6651+ 3F59 21 00 00             ld      HL,$0000        ; Zero out the value
6652+ 3F5C CD 75 3F             call    CHKBIN          ; Check the number for valid bin
6653+ 3F5F DA 83 3F             jp      C,BINERR        ; First value wasn't bin, HX error
6654+ 3F62 D6 30        BINIT:  sub     '0'
6655+ 3F64 29                   add     HL,HL           ; Rotate HL left
6656+ 3F65 B5                   or      L
6657+ 3F66 6F                   ld      L,A
6658+ 3F67 CD 75 3F             call    CHKBIN          ; Get second and addtional characters
6659+ 3F6A 30 F6                jr      NC,BINIT        ; Process if a bin character
6660+ 3F6C EB                   ex      DE,HL           ; Value into DE, Code string into HL
6661+ 3F6D 7A                   ld      A,D             ; Load DE into AC
6662+ 3F6E 4B                   ld      C,E             ; For prep to
6663+ 3F6F E5                   push    HL
6664+ 3F70 CD 55 24             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6665+ 3F73 E1                   pop     HL
6666+ 3F74 C9                   ret
6667+ 3F75
6668+ 3F75              ; Char is in A, NC if char is 0 or 1
6669+ 3F75 13           CHKBIN: inc     DE
6670+ 3F76 1A                   ld      A,(DE)
6671+ 3F77 FE 20                cp      SPC
6672+ 3F79 CA 75 3F             jp      Z,CHKBIN        ; Skip spaces
6673+ 3F7C FE 30                cp      '0'             ; Set C if < '0'
6674+ 3F7E D8                   ret     C
6675+ 3F7F FE 32                cp      '2'
6676+ 3F81 3F                   ccf                     ; Set C if > '1'
6677+ 3F82 C9                   ret
6678+ 3F83
6679+ 3F83 1E 28        BINERR: ld      E,BN            ; ?BIN Error
6680+ 3F85 C3 D4 16             jp      ERROR
6681+ 3F88
6682+ 3F88
6683+ 3F88 C3 08 00     MONOUT: jp      $0008           ; output a char
6684+ 3F8B
6685+ 3F8B
6686+ 3F8B 3A 20 82     RESET:  ld      A,(SERIALS_EN)
6687+ 3F8E E6 11                and     $11             ; are serial ports open?
6688+ 3F90 C4 FB 3A             call    NZ,RSTSERS      ; yes, reset serials
6689+ 3F93 CD 0D 29             call    DISNMI          ; disable NMI vector
6690+ 3F96 F3                   di                      ; disable INTs
6691+ 3F97 C3 00 00             jp      $0000           ; Restart
6692+ 3F9A
6693+ 3F9A
6694+ 3F9A 3E 00        INITST: ld      A,$00           ; Clear break flag
6695+ 3F9C 32 A9 80             ld      (BRKFLG),A
6696+ 3F9F C3 EC 11             jp      INIT
6697+ 3FA2
6698+ 3FA2
6699+ 3FA2 F5           TSTBIT: push    AF              ; Save bit mask
6700+ 3FA3 A0                   and     B               ; Get common bits
6701+ 3FA4 C1                   pop     BC              ; Restore bit mask
6702+ 3FA5 B8                   cp      B               ; Same bit set?
6703+ 3FA6 3E 00                ld      A,$00           ; Return 0 in A
6704+ 3FA8 C9                   ret
6705+ 3FA9
6706+ 3FA9 CD AD 19     OUTNCR: call    OUTC            ; Output character in A
6707+ 3FAC C3 B0 1E             jp      PRNTCRLF        ; Output CRLF
6708+ 3FAF
# file closed: ../include/basic/basic32k-r316.asm
  73  3FAF
  74  3FAF              ; include utils
  75  3FAF                  INCLUDE "../include/utils/utils-r11.asm"
# file opened: ../include/utils/utils-r11.asm
   1+ 3FAF              ; ------------------------------------------------------------------------------
   2+ 3FAF              ; LM80C - UTILITY ROUTINES - R1.1
   3+ 3FAF              ; ------------------------------------------------------------------------------
   4+ 3FAF              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 3FAF              ; designed by Leonardo Miliani. More info at
   6+ 3FAF              ; www DOT leonardomiliani DOT com
   7+ 3FAF              ;
   8+ 3FAF              ; *ALS are routines from "Z80 Assembly Language Subroutines" by Lance
   9+ 3FAF              ; A. Leventhal and Winthrop Saville - Ed. Osborne/McGraw-Hill (1983)
  10+ 3FAF              ;
  11+ 3FAF              ; * WKT are routines from WikiTI:
  12+ 3FAF              ; http://wikiti.brandonw.net/index.php?title=WikiTI_Home
  13+ 3FAF              ;
  14+ 3FAF              ; * LAC are routines from Learn@Cemetch
  15+ 3FAF              ; https://learn.cemetech.net/index.php/Main_Page
  16+ 3FAF              ;
  17+ 3FAF              ; ------------------------------------------------------------------------------
  18+ 3FAF              ; Code Revision:
  19+ 3FAF              ; R1.0 - 20200110 - First release: 16-bit comparision/multiplication/negation
  20+ 3FAF              ; R1.1 - 20200413 - Second release: added ABS(HL)
  21+ 3FAF              ;
  22+ 3FAF              ; ------------------------------------------------------------------------------
  23+ 3FAF
  24+ 3FAF              ; compare two 16-bit registers, HL (minuend) and DE (subtrahend)
  25+ 3FAF              ; values can be both signed or unsigned words
  26+ 3FAF              ; inputs: HL, DE
  27+ 3FAF              ; destroys: A,F,HL
  28+ 3FAF              ;
  29+ 3FAF              ; returns: Z=1 if HL = DE
  30+ 3FAF              ; for UNSIGNED: C=1 if HL<DE  //  C=0 if HL>DE
  31+ 3FAF              ; for SIGNED:   S=1 (M) if HL<DE  //  S=0 (P) if HL>DE
  32+ 3FAF              ; if HL=DE: Z,P,NC  - Z=1, S=0; C=0
  33+ 3FAF              ; if HL>DE: NZ,P,NC - Z=0, S=0; C=0
  34+ 3FAF              ; if HL<DE: NZ,M,C  - Z=0, S=1; C=1
  35+ 3FAF              ; Source: ALS
  36+ 3FAF
  37+ 3FAF B7           CMP16:  or      A           ; clear CARRY
  38+ 3FB0 ED 52                sbc     HL,DE       ; subtract DE from HL
  39+ 3FB2 E0                   ret     PO          ; return if no overflow
  40+ 3FB3 7C                   ld      A,H         ; overflow - invert SIGN flag
  41+ 3FB4 1F                   rra                 ; save CARRY flag in bit 7
  42+ 3FB5 EE 40                xor     %01000000   ; complement bit 6 (SIGN bit)
  43+ 3FB7 37                   scf                 ; ensure a Non-Zero result
  44+ 3FB8 8F                   adc     A,A         ; restore CARRY, complemented SIGN
  45+ 3FB9                                          ; ZERO flag = 0 for sure
  46+ 3FB9 C9                   ret                 ; return
  47+ 3FBA
  48+ 3FBA              ; ----------------------------------------------------------------------
  49+ 3FBA
  50+ 3FBA              ; multiply 2 signed/unsigned 16-bit words and return a 16-bit
  51+ 3FBA              ; signed/unsigned product
  52+ 3FBA              ; inputs: HL (multiplicand); DE (multiplier)
  53+ 3FBA              ; destroys: A,F
  54+ 3FBA              ; returns: HL (product)
  55+ 3FBA              ; Source: ALS
  56+ 3FBA
  57+ 3FBA              ; initialize partial product, bit count
  58+ 3FBA C5           MUL16:  push    BC
  59+ 3FBB 4D                   ld      C,L         ; BC = multiplier
  60+ 3FBC 44                   ld      B,H
  61+ 3FBD 21 00 00             ld      HL,0        ; product = 0
  62+ 3FC0 3E 0F                ld      A,$0F       ; count = bit lenght - 1 (16-1)
  63+ 3FC2                      ; shift-and-add algorithm
  64+ 3FC2                      ; if MSB of multiplier is 1, add multiplicand to partial product
  65+ 3FC2                      ; shift partial product, multiplier left 1 bit
  66+ 3FC2 CB 23        MLP:    sla     E           ; shift multiplier left 1 bit
  67+ 3FC4 CB 12                rl      D
  68+ 3FC6 30 01                jr      NC,MLP1     ; jump if MSB of multiplier = 0
  69+ 3FC8 09                   add     HL,BC       ; add multiplicand to partial product
  70+ 3FC9 29           MLP1:   add     HL,HL       ; shift partial product left
  71+ 3FCA 3D                   dec     A
  72+ 3FCB 20 F5                jr      NZ,MLP      ; continue until count = 0
  73+ 3FCD                      ; add multiplicand one last time if MSB of multiplier is 1
  74+ 3FCD B2                   or      D           ; sign flag = MSB of multiplier
  75+ 3FCE F2 D2 3F             jp      P,EXMUL16   ; exit if MSB of multiplier is 0
  76+ 3FD1 09                   add     HL,BC       ; add multiplicand to product
  77+ 3FD2 C1           EXMUL16:pop     BC
  78+ 3FD3 C9                   ret
  79+ 3FD4
  80+ 3FD4              ; ----------------------------------------------------------------------
  81+ 3FD4              ; absolute value of HL (same applies to other 16-bit register pairs)
  82+ 3FD4              ; also, invert value of HL (or any other 16-bit register, just adjust the code)
  83+ 3FD4              ;
  84+ 3FD4              ; inputs: HL
  85+ 3FD4              ; destroys: A
  86+ 3FD4              ; operation: ABS(HL)
  87+ 3FD4              ; returns: HL with no sign or negated
  88+ 3FD4              ; Source: WKT
  89+ 3FD4
  90+ 3FD4 CB 7C        absHL:  bit     7,H
  91+ 3FD6 C8                   ret     Z
  92+ 3FD7 AF           negHL:  xor     A
  93+ 3FD8 95                   sub     L
  94+ 3FD9 6F                   ld      L,A
  95+ 3FDA 9F                   sbc     A,A
  96+ 3FDB 94                   sub     H
  97+ 3FDC 67                   ld      H,A
  98+ 3FDD C9                   ret
  99+ 3FDE
 100+ 3FDE              ; ------------------------------------------------------------------------------
 101+ 3FDE
 102+ 3FDE              ; 8/8 division
 103+ 3FDE              ; INPUT: D (dividend), E (divisor)
 104+ 3FDE              ; OPERATION: D/E
 105+ 3FDE              ; OUTPUT: D (quotient), A (remainder)
 106+ 3FDE AF           DIV_8_8:    xor     A
 107+ 3FDF C5                       push    BC
 108+ 3FE0 06 08                    ld      B,08h
 109+ 3FE2 CB 22        DIV_8_8LOOP:sla     D
 110+ 3FE4 17                       rla
 111+ 3FE5 BB                       cp      E
 112+ 3FE6 38 02                    jr      C,$+4
 113+ 3FE8 93                       sub     E
 114+ 3FE9 14                       inc     D
 115+ 3FEA 10 F6                    djnz    DIV_8_8LOOP
 116+ 3FEC C1                       pop     BC
 117+ 3FED C9                       ret
 118+ 3FEE
 119+ 3FEE              ; ----------------------------------------------------------------------
 120+ 3FEE              ; divide a 16-bit number by an 8-bit number
 121+ 3FEE              ; (16/8 division)
 122+ 3FEE              ;
 123+ 3FEE              ; inputs: HL (Dividend), C (divisor)
 124+ 3FEE              ; destroys: A
 125+ 3FEE              ; OPERATION: HL/C
 126+ 3FEE              ; returns: HL (quotient), A (remainder)
 127+ 3FEE              ; source: WKT
 128+ 3FEE
 129+ 3FEE AF           DIV_16_8:   xor     A
 130+ 3FEF 06 10                    ld      B,16
 131+ 3FF1 29           DIV_16_8LP: add     HL,HL
 132+ 3FF2 17                       rla
 133+ 3FF3 38 03                    jr      C,$+5
 134+ 3FF5 B9                       cp      C
 135+ 3FF6 38 02                    jr      C,$+4
 136+ 3FF8 91                       sub     C
 137+ 3FF9 2C                       inc     L
 138+ 3FFA 10 F5                    djnz    DIV_16_8LP
 139+ 3FFC C9                       ret
 140+ 3FFD
 141+ 3FFD              ; ----------------------------------------------------------------------
 142+ 3FFD              ; divide a 16-bit number by a 16-bit number
 143+ 3FFD              ; (16/16 division)
 144+ 3FFD              ;
 145+ 3FFD              ; inputs: AC (Dividend), DE (divisor)
 146+ 3FFD              ; destroys: HL,A,C
 147+ 3FFD              ; OPERATION: AC/DE
 148+ 3FFD              ; returns: AC (quotient), HL (remainder)
 149+ 3FFD              ; source: WKT
 150+ 3FFD 21 00 00     DIV_16_16:  ld      HL, 0
 151+ 4000 06 10                    ld      B, 16
 152+ 4002 CB 21        DV16_16_LP: sla     C
 153+ 4004 CB C1                    set     0,C         ; this simulates the SLL undocumented instruction
 154+ 4006 17                       rla
 155+ 4007 ED 6A                    adc     HL,HL
 156+ 4009 ED 52                    sbc     HL,DE
 157+ 400B 30 02                    jr      NC, $+4
 158+ 400D 19                       add     HL,DE
 159+ 400E 0D                       dec     C
 160+ 400F 10 F1                    djnz    DV16_16_LP
 161+ 4011 C9                       ret
# file closed: ../include/utils/utils-r11.asm
  76  4012
  77  4012              ; include the latest version of the font sets
  78  4012                  INCLUDE "../include/vdp/6x8fonts-r16.asm"
# file opened: ../include/vdp/6x8fonts-r16.asm
   1+ 4012              ; ------------------------------------------------------------------------------
   2+ 4012              ; LM80C - 6x8 CHARSET - R1.6
   3+ 4012              ; ------------------------------------------------------------------------------
   4+ 4012              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4012              ; designed by Leonardo Miliani. More info at
   6+ 4012              ; www DOT leonardomiliani DOT com
   7+ 4012              ; ------------------------------------------------------------------------------
   8+ 4012              ; Code Revision:
   9+ 4012              ; R1.0 - 20190511 - First revision: ASCII chars (from 0 to 127)
  10+ 4012              ; R1.1 - 20190521 - Expanded to 255 chars
  11+ 4012              ; R1.2 - 20191209 - Start adding graphic chars to be coherent with 8x8 fonts
  12+ 4012              ; R1.3 - 20191226 - Added extended char codes (128-255)
  13+ 4012              ; R1.4 - 20200228 - adopted more usual hexadecimal & binary prefixes
  14+ 4012              ; R1.5 - 20200524 - New style for char #252
  15+ 4012              ; R1.6 - 20200704 - Redefined chars 105, 106, and 252
  16+ 4012              ; ------------------------------------------------------------------------------
  17+ 4012              ;
  18+ 4012              ;-------------------------------------------------------------------------------
  19+ 4012              ;
  20+ 4012              ;               6 x 8    C  H  A  R  S  E  T
  21+ 4012              ;
  22+ 4012              ;-------------------------------------------------------------------------------
  23+ 4012              ;
  24+ 4012              ;       6X8 CHARS, DESIGNED FOR TEXT BUT USABLE IN GRAPHICS 1 MODE TOO
  25+ 4012              ;       UPDATE: NOW GRAPHICS 1 MODE HAS ITS OWN CHAR SET
  26+ 4012
  27+ 4012              CHRST68 equ $
  28+ 4012 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  28+ 4016 00 00 00 00
  29+ 401A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  29+ 401E 00 00 00 00
  30+ 4022 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  30+ 4026 00 00 00 00
  31+ 402A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  31+ 402E 00 00 00 00
  32+ 4032 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  32+ 4036 00 00 00 00
  33+ 403A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  33+ 403E 00 00 00 00
  34+ 4042 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  34+ 4046 00 00 00 00
  35+ 404A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  35+ 404E 00 00 00 00
  36+ 4052 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
  36+ 4056 00 00 00 00
  37+ 405A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  37+ 405E 00 00 00 00
  38+ 4062 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  38+ 4066 00 00 00 00
  39+ 406A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11
  39+ 406E 00 00 00 00
  40+ 4072 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  40+ 4076 00 00 00 00
  41+ 407A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
  41+ 407E 00 00 00 00
  42+ 4082 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
  42+ 4086 00 00 00 00
  43+ 408A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  43+ 408E 00 00 00 00
  44+ 4092 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  44+ 4096 00 00 00 00
  45+ 409A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  45+ 409E 00 00 00 00
  46+ 40A2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  46+ 40A6 00 00 00 00
  47+ 40AA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  47+ 40AE 00 00 00 00
  48+ 40B2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
  48+ 40B6 00 00 00 00
  49+ 40BA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  49+ 40BE 00 00 00 00
  50+ 40C2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
  50+ 40C6 00 00 00 00
  51+ 40CA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
  51+ 40CE 00 00 00 00
  52+ 40D2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
  52+ 40D6 00 00 00 00
  53+ 40DA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
  53+ 40DE 00 00 00 00
  54+ 40E2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
  54+ 40E6 00 00 00 00
  55+ 40EA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
  55+ 40EE 00 00 00 00
  56+ 40F2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
  56+ 40F6 00 00 00 00
  57+ 40FA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
  57+ 40FE 00 00 00 00
  58+ 4102 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
  58+ 4106 00 00 00 00
  59+ 410A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
  59+ 410E 00 00 00 00
  60+ 4112 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32: space
  60+ 4116 00 00 00 00
  61+ 411A 20 20 20 20          defb $20,$20,$20,$20,$20,$00,$20,$00 ; char 33: !
  61+ 411E 20 00 20 00
  62+ 4122 50 50 00 00          defb $50,$50,$00,$00,$00,$00,$00,$00 ; char 34: "
  62+ 4126 00 00 00 00
  63+ 412A 50 50 F8 50          defb $50,$50,$f8,$50,$f8,$50,$50,$00 ; char 35: #
  63+ 412E F8 50 50 00
  64+ 4132 20 78 A0 70          defb $20,$78,$a0,$70,$28,$f0,$20,$00 ; char 36: $
  64+ 4136 28 F0 20 00
  65+ 413A C0 C8 10 20          defb $c0,$c8,$10,$20,$40,$98,$18,$00 ; char 37: %
  65+ 413E 40 98 18 00
  66+ 4142 60 90 A0 40          defb $60,$90,$a0,$40,$a8,$90,$68,$00 ; char 38: &
  66+ 4146 A8 90 68 00
  67+ 414A 60 20 40 00          defb $60,$20,$40,$00,$00,$00,$00,$00 ; char 39: '
  67+ 414E 00 00 00 00
  68+ 4152 10 20 40 40          defb $10,$20,$40,$40,$40,$20,$10,$00 ; char 40: (
  68+ 4156 40 20 10 00
  69+ 415A 40 20 10 10          defb $40,$20,$10,$10,$10,$20,$40,$00 ; char 41: )
  69+ 415E 10 20 40 00
  70+ 4162 00 20 A8 70          defb $00,$20,$a8,$70,$a8,$20,$00,$00 ; char 42: *
  70+ 4166 A8 20 00 00
  71+ 416A 00 20 20 F8          defb $00,$20,$20,$f8,$20,$20,$00,$00 ; char 43: +
  71+ 416E 20 20 00 00
  72+ 4172 00 00 00 00          defb $00,$00,$00,$00,$60,$20,$40,$00 ; char 44: ,
  72+ 4176 60 20 40 00
  73+ 417A 00 00 00 F8          defb $00,$00,$00,$f8,$00,$00,$00,$00 ; char 45: -
  73+ 417E 00 00 00 00
  74+ 4182 00 00 00 00          defb $00,$00,$00,$00,$00,$60,$60,$00 ; char 46: .
  74+ 4186 00 60 60 00
  75+ 418A 00 08 10 20          defb $00,$08,$10,$20,$40,$80,$00,$00 ; char 47: /
  75+ 418E 40 80 00 00
  76+ 4192 70 88 98 A8          defb $70,$88,$98,$a8,$c8,$88,$70,$00 ; char 48: 0
  76+ 4196 C8 88 70 00
  77+ 419A 20 60 20 20          defb $20,$60,$20,$20,$20,$20,$70,$00 ; char 49: 1
  77+ 419E 20 20 70 00
  78+ 41A2 70 88 08 10          defb $70,$88,$08,$10,$20,$40,$f8,$00 ; char 50: 2
  78+ 41A6 20 40 F8 00
  79+ 41AA F8 10 20 10          defb $f8,$10,$20,$10,$08,$88,$70,$00 ; char 51: 3
  79+ 41AE 08 88 70 00
  80+ 41B2 10 30 50 90          defb $10,$30,$50,$90,$f8,$10,$10,$00 ; char 52: 4
  80+ 41B6 F8 10 10 00
  81+ 41BA F8 80 F0 08          defb $f8,$80,$f0,$08,$08,$88,$70,$00 ; char 53: 5
  81+ 41BE 08 88 70 00
  82+ 41C2 30 40 80 F0          defb $30,$40,$80,$f0,$88,$88,$70,$00 ; char 54: 6
  82+ 41C6 88 88 70 00
  83+ 41CA F8 08 10 20          defb $f8,$08,$10,$20,$40,$40,$40,$00 ; char 55: 7
  83+ 41CE 40 40 40 00
  84+ 41D2 70 88 88 70          defb $70,$88,$88,$70,$88,$88,$70,$00 ; char 56: 8
  84+ 41D6 88 88 70 00
  85+ 41DA 70 88 88 78          defb $70,$88,$88,$78,$08,$10,$60,$00 ; char 57: 9
  85+ 41DE 08 10 60 00
  86+ 41E2 00 30 30 00          defb $00,$30,$30,$00,$30,$30,$00,$00 ; char 58: :
  86+ 41E6 30 30 00 00
  87+ 41EA 00 30 30 00          defb $00,$30,$30,$00,$30,$10,$20,$00 ; char 59: ;
  87+ 41EE 30 10 20 00
  88+ 41F2 10 20 40 80          defb $10,$20,$40,$80,$40,$20,$10,$00 ; char 60: <
  88+ 41F6 40 20 10 00
  89+ 41FA 00 00 F8 00          defb $00,$00,$f8,$00,$f8,$00,$00,$00 ; char 61: =
  89+ 41FE F8 00 00 00
  90+ 4202 40 20 10 08          defb $40,$20,$10,$08,$10,$20,$40,$00 ; char 62: >
  90+ 4206 10 20 40 00
  91+ 420A 70 88 08 10          defb $70,$88,$08,$10,$20,$00,$20,$00 ; char 63: ?
  91+ 420E 20 00 20 00
  92+ 4212 70 88 08 68          defb $70,$88,$08,$68,$a8,$a8,$70,$00 ; char 64: @
  92+ 4216 A8 A8 70 00
  93+ 421A 70 88 88 88          defb $70,$88,$88,$88,$f8,$88,$88,$00 ; char 65: A
  93+ 421E F8 88 88 00
  94+ 4222 F0 88 88 F0          defb $f0,$88,$88,$f0,$88,$88,$f0,$00 ; char 66: B
  94+ 4226 88 88 F0 00
  95+ 422A 70 88 80 80          defb $70,$88,$80,$80,$80,$88,$70,$00 ; char 67: C
  95+ 422E 80 88 70 00
  96+ 4232 E0 90 88 88          defb $e0,$90,$88,$88,$88,$90,$e0,$00 ; char 68: D
  96+ 4236 88 90 E0 00
  97+ 423A F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$f8,$00 ; char 69: E
  97+ 423E 80 80 F8 00
  98+ 4242 F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$80,$00 ; char 70: F
  98+ 4246 80 80 80 00
  99+ 424A 70 88 80 B8          defb $70,$88,$80,$b8,$88,$88,$78,$00 ; char 71: G
  99+ 424E 88 88 78 00
 100+ 4252 88 88 88 F8          defb $88,$88,$88,$f8,$88,$88,$88,$00 ; char 72: H
 100+ 4256 88 88 88 00
 101+ 425A 70 20 20 20          defb $70,$20,$20,$20,$20,$20,$70,$00 ; char 73: I
 101+ 425E 20 20 70 00
 102+ 4262 38 10 10 10          defb $38,$10,$10,$10,$10,$90,$60,$00 ; char 74: J
 102+ 4266 10 90 60 00
 103+ 426A 88 90 A0 C0          defb $88,$90,$a0,$c0,$a0,$90,$88,$00 ; char 75: K
 103+ 426E A0 90 88 00
 104+ 4272 80 80 80 80          defb $80,$80,$80,$80,$80,$80,$f8,$00 ; char 76: L
 104+ 4276 80 80 F8 00
 105+ 427A 88 D8 A8 A8          defb $88,$d8,$a8,$a8,$88,$88,$88,$00 ; char 77: M
 105+ 427E 88 88 88 00
 106+ 4282 88 C8 A8 98          defb $88,$c8,$a8,$98,$88,$88,$88,$00 ; char 78: N
 106+ 4286 88 88 88 00
 107+ 428A 70 88 88 88          defb $70,$88,$88,$88,$88,$88,$70,$00 ; char 79: O
 107+ 428E 88 88 70 00
 108+ 4292 F0 88 88 F0          defb $f0,$88,$88,$f0,$80,$80,$80,$00 ; char 80: P
 108+ 4296 80 80 80 00
 109+ 429A 70 88 88 88          defb $70,$88,$88,$88,$a8,$90,$68,$00 ; char 81: Q
 109+ 429E A8 90 68 00
 110+ 42A2 F0 88 88 F0          defb $f0,$88,$88,$f0,$a0,$90,$88,$00 ; char 82: R
 110+ 42A6 A0 90 88 00
 111+ 42AA 78 80 80 70          defb $78,$80,$80,$70,$08,$08,$f0,$00 ; char 83: S
 111+ 42AE 08 08 F0 00
 112+ 42B2 F8 20 20 20          defb $f8,$20,$20,$20,$20,$20,$20,$00 ; char 84: T
 112+ 42B6 20 20 20 00
 113+ 42BA 88 88 88 88          defb $88,$88,$88,$88,$88,$88,$70,$00 ; char 85: U
 113+ 42BE 88 88 70 00
 114+ 42C2 88 88 88 88          defb $88,$88,$88,$88,$88,$50,$20,$00 ; char 86: V
 114+ 42C6 88 50 20 00
 115+ 42CA 88 88 88 88          defb $88,$88,$88,$88,$a8,$a8,$50,$00 ; char 87: W
 115+ 42CE A8 A8 50 00
 116+ 42D2 88 88 50 20          defb $88,$88,$50,$20,$50,$88,$88,$00 ; char 88: X
 116+ 42D6 50 88 88 00
 117+ 42DA 88 88 88 50          defb $88,$88,$88,$50,$20,$20,$20,$00 ; char 89: Y
 117+ 42DE 20 20 20 00
 118+ 42E2 F8 08 10 20          defb $f8,$08,$10,$20,$40,$80,$f8,$00 ; char 90: Z
 118+ 42E6 40 80 F8 00
 119+ 42EA 70 40 40 40          defb $70,$40,$40,$40,$40,$40,$70,$00 ; char 91: [
 119+ 42EE 40 40 70 00
 120+ 42F2 00 80 40 20          defb $00,$80,$40,$20,$10,$08,$00,$00 ; char 92: \
 120+ 42F6 10 08 00 00
 121+ 42FA 70 10 10 10          defb $70,$10,$10,$10,$10,$10,$70,$00 ; char 93: ]
 121+ 42FE 10 10 70 00
 122+ 4302 20 50 88 00          defb $20,$50,$88,$00,$00,$00,$00,$00 ; char 94: ^
 122+ 4306 00 00 00 00
 123+ 430A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$FC ; char 95: _ (underscore)
 123+ 430E 00 00 00 FC
 124+ 4312 40 20 10 00          defb $40,$20,$10,$00,$00,$00,$00,$00 ; char 96: `
 124+ 4316 00 00 00 00
 125+ 431A 00 00 70 08          defb $00,$00,$70,$08,$78,$88,$78,$00 ; char 97: a
 125+ 431E 78 88 78 00
 126+ 4322 80 80 80 B0          defb $80,$80,$80,$b0,$c8,$88,$f0,$00 ; char 98: b
 126+ 4326 C8 88 F0 00
 127+ 432A 00 00 70 80          defb $00,$00,$70,$80,$80,$88,$70,$00 ; char 99: c
 127+ 432E 80 88 70 00
 128+ 4332 08 08 08 68          defb $08,$08,$08,$68,$98,$88,$78,$00 ; char 100: d
 128+ 4336 98 88 78 00
 129+ 433A 00 00 70 88          defb $00,$00,$70,$88,$f8,$80,$70,$00 ; char 101: e
 129+ 433E F8 80 70 00
 130+ 4342 30 48 40 E0          defb $30,$48,$40,$e0,$40,$40,$40,$00 ; char 102: f
 130+ 4346 40 40 40 00
 131+ 434A 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$70,$00 ; char 103: g
 131+ 434E 78 08 70 00
 132+ 4352 80 80 B0 C8          defb $80,$80,$b0,$c8,$88,$88,$88,$00 ; char 104: h
 132+ 4356 88 88 88 00
 133+ 435A 20 00 20 20          defb $20,$00,$20,$20,$20,$20,$20,$00 ; char 105: i
 133+ 435E 20 20 20 00
 134+ 4362 08 00 18 08          defb $08,$00,$18,$08,$08,$88,$70,$00 ; char 106: j
 134+ 4366 08 88 70 00
 135+ 436A 80 80 90 A0          defb $80,$80,$90,$a0,$c0,$a0,$90,$00 ; char 107: k
 135+ 436E C0 A0 90 00
 136+ 4372 60 20 20 20          defb $60,$20,$20,$20,$20,$20,$70,$00 ; char 108: l
 136+ 4376 20 20 70 00
 137+ 437A 00 00 D0 A8          defb $00,$00,$d0,$a8,$a8,$88,$88,$00 ; char 109: m
 137+ 437E A8 88 88 00
 138+ 4382 00 00 B0 C8          defb $00,$00,$b0,$c8,$88,$88,$88,$00 ; char 110: n
 138+ 4386 88 88 88 00
 139+ 438A 00 00 70 88          defb $00,$00,$70,$88,$88,$88,$70,$00 ; char 111: o
 139+ 438E 88 88 70 00
 140+ 4392 00 00 F0 88          defb $00,$00,$f0,$88,$f0,$80,$80,$00 ; char 112: p
 140+ 4396 F0 80 80 00
 141+ 439A 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$08,$00 ; char 113: q
 141+ 439E 78 08 08 00
 142+ 43A2 00 00 B0 C8          defb $00,$00,$b0,$c8,$80,$80,$80,$00 ; char 114: r
 142+ 43A6 80 80 80 00
 143+ 43AA 00 00 70 80          defb $00,$00,$70,$80,$70,$08,$f0,$00 ; char 115: s
 143+ 43AE 70 08 F0 00
 144+ 43B2 40 40 E0 40          defb $40,$40,$e0,$40,$40,$48,$30,$00 ; char 116: t
 144+ 43B6 40 48 30 00
 145+ 43BA 00 00 88 88          defb $00,$00,$88,$88,$88,$98,$68,$00 ; char 117: u
 145+ 43BE 88 98 68 00
 146+ 43C2 00 00 88 88          defb $00,$00,$88,$88,$88,$50,$20,$00 ; char 118: v
 146+ 43C6 88 50 20 00
 147+ 43CA 00 00 88 88          defb $00,$00,$88,$88,$a8,$a8,$50,$00 ; char 119: w
 147+ 43CE A8 A8 50 00
 148+ 43D2 00 00 88 50          defb $00,$00,$88,$50,$20,$50,$88,$00 ; char 120: x
 148+ 43D6 20 50 88 00
 149+ 43DA 00 00 88 98          defb $00,$00,$88,$98,$68,$08,$70,$00 ; char 121: y
 149+ 43DE 68 08 70 00
 150+ 43E2 00 00 F8 10          defb $00,$00,$f8,$10,$20,$40,$f8,$00 ; char 122: z
 150+ 43E6 20 40 F8 00
 151+ 43EA 10 20 20 40          defb $10,$20,$20,$40,$20,$20,$10,$00 ; char 123: {
 151+ 43EE 20 20 10 00
 152+ 43F2 20 20 20 20          defb $20,$20,$20,$20,$20,$20,$20,$00 ; char 124: |
 152+ 43F6 20 20 20 00
 153+ 43FA 20 10 10 08          defb $20,$10,$10,$08,$10,$10,$20,$00 ; char 125: }
 153+ 43FE 10 10 20 00
 154+ 4402 00 28 50 00          defb $00,$28,$50,$00,$00,$00,$00,$00 ; char 126: ~
 154+ 4406 00 00 00 00
 155+ 440A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 127: (delete) - here end the standard ASCII (0-127)
 155+ 440E 00 00 00 00
 156+ 4412 78 84 CC 84          defb %01111000,%10000100,%11001100,%10000100,%10110100,%10000100,%01111000,%00000000 ; char 128 (open face)
 156+ 4416 B4 84 78 00
 157+ 441A 78 FC B4 FC          defb %01111000,%11111100,%10110100,%11111100,%10110100,%11001100,%01111000,%00000000 ; char 129 (full face)
 157+ 441E B4 CC 78 00
 158+ 4422 48 FC FC FC          defb %01001000,%11111100,%11111100,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 130 (hearts)
 158+ 4426 FC 78 30 00
 159+ 442A 00 20 70 F8          defb %00000000,%00100000,%01110000,%11111000,%11111000,%01110000,%00100000,%00000000 ; char 131 (diamonds)
 159+ 442E F8 70 20 00
 160+ 4432 70 20 A8 F8          defb %01110000,%00100000,%10101000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 132 (clubs)
 160+ 4436 A8 20 70 00
 161+ 443A 20 70 F8 F8          defb %00100000,%01110000,%11111000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 133 (spades)
 161+ 443E A8 20 70 00
 162+ 4442 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 134
 162+ 4446 FC 30 30 30
 163+ 444A 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 135
 163+ 444E 3C 30 30 30
 164+ 4452 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 136
 164+ 4456 F0 30 30 30
 165+ 445A 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00000000,%00000000,%00000000 ; char 137
 165+ 445E F0 00 00 00
 166+ 4462 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00000000,%00000000,%00000000 ; char 138
 166+ 4466 3C 00 00 00
 167+ 446A 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 139
 167+ 446E FC 00 00 00
 168+ 4472 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 140
 168+ 4476 3C 30 30 30
 169+ 447A 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 141
 169+ 447E FC 30 30 30
 170+ 4482 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 142
 170+ 4486 F0 30 30 30
 171+ 448A 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 143
 171+ 448E FC 00 00 00
 172+ 4492 30 30 30 30          defb %00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000 ; char 144
 172+ 4496 30 30 30 30
 173+ 449A 0C 1C 18 38          defb %00001100,%00011100,%00011000,%00111000,%01110000,%01100000,%11100000,%11000000 ; char 145
 173+ 449E 70 60 E0 C0
 174+ 44A2 C0 E0 60 70          defb %11000000,%11100000,%01100000,%01110000,%00111000,%00011000,%00011100,%00001100 ; char 146
 174+ 44A6 38 18 1C 0C
 175+ 44AA CC CC 78 30          defb %11001100,%11001100,%01111000,%00110000,%00110000,%01111000,%11001100,%11001100 ; char 147
 175+ 44AE 30 78 CC CC
 176+ 44B2 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 148
 176+ 44B6 20 20 20 20
 177+ 44BA 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 149
 177+ 44BE 20 20 20 20
 178+ 44C2 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 150
 178+ 44C6 20 20 20 20
 179+ 44CA 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 151
 179+ 44CE 00 00 00 00
 180+ 44D2 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00000000,%00000000,%00000000,%00000000 ; char 152
 180+ 44D6 00 00 00 00
 181+ 44DA 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 153
 181+ 44DE 00 00 00 00
 182+ 44E2 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 154
 182+ 44E6 20 20 20 20
 183+ 44EA 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 155
 183+ 44EE 20 20 20 20
 184+ 44F2 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 156
 184+ 44F6 20 20 20 20
 185+ 44FA 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 157
 185+ 44FE 00 00 00 00
 186+ 4502 20 20 20 20          defb %00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000 ; char 158
 186+ 4506 20 20 20 20
 187+ 450A 04 08 08 10          defb %00000100,%00001000,%00001000,%00010000,%00100000,%01000000,%01000000,%10000000 ; char 159
 187+ 450E 20 40 40 80
 188+ 4512 80 40 40 20          defb %10000000,%01000000,%01000000,%00100000,%00010000,%00001000,%00001000,%00000100 ; char 160
 188+ 4516 10 08 08 04
 189+ 451A 84 48 48 30          defb %10000100,%01001000,%01001000,%00110000,%00110000,%01001000,%01001000,%10000100 ; char 161
 189+ 451E 30 48 48 84
 190+ 4522 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 162
 190+ 4526 00 00 FC FC
 191+ 452A 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111100,%11111100,%11111100,%11111100 ; char 163
 191+ 452E FC FC FC FC
 192+ 4532 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 164
 192+ 4536 FC FC FC FC
 193+ 453A FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 193+ 453E 00 00 00 00
 194+ 4542 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 166
 194+ 4546 00 00 00 00
 195+ 454A FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 167
 195+ 454E FC FC 00 00
 196+ 4552 80 80 80 80          defb %10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000 ; char 168
 196+ 4556 80 80 80 80
 197+ 455A E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000 ; char 169
 197+ 455E E0 E0 E0 E0
 198+ 4562 F8 F8 F8 F8          defb %11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000 ; char 170
 198+ 4566 F8 F8 F8 F8
 199+ 456A 04 04 04 04          defb %00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100 ; char 171
 199+ 456E 04 04 04 04
 200+ 4572 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100 ; char 172
 200+ 4576 1C 1C 1C 1C
 201+ 457A 7C 7C 7C 7C          defb %01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100 ; char 173
 201+ 457E 7C 7C 7C 7C
 202+ 4582 FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 174
 202+ 4586 84 84 84 FC
 203+ 458A 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%11100000,%11100000,%11100000 ; char 175
 203+ 458E E0 E0 E0 E0
 204+ 4592 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00011100,%00011100,%00011100 ; char 176
 204+ 4596 1C 1C 1C 1C
 205+ 459A 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 177
 205+ 459E 00 00 00 00
 206+ 45A2 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 178
 206+ 45A6 00 00 00 00
 207+ 45AA E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00011100,%00011100,%00011100,%00011100 ; char 179
 207+ 45AE 1C 1C 1C 1C
 208+ 45B2 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%11100000,%11100000,%11100000,%11100000 ; char 180
 208+ 45B6 E0 E0 E0 E0
 209+ 45BA 78 78 78 78          defb %01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000 ; char 181
 209+ 45BE 78 78 78 78
 210+ 45C2 CC CC CC CC          defb %11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100 ; char 182
 210+ 45C6 CC CC CC CC
 211+ 45CA FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 183
 211+ 45CE 00 00 FC FC
 212+ 45D2 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 184
 212+ 45D6 FC FC 00 00
 213+ 45DA 30 30 CC CC          defb %00110000,%00110000,%11001100,%11001100,%00110000,%00110000,%11001100,%11001100 ; char 185
 213+ 45DE 30 30 CC CC
 214+ 45E2 54 A8 54 A8          defb %01010100,%10101000,%01010100,%10101000,%01010100,%10101000,%01010100,%10101000 ; char 186
 214+ 45E6 54 A8 54 A8
 215+ 45EA 64 30 98 CC          defb %01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100 ; char 187
 215+ 45EE 64 30 98 CC
 216+ 45F2 CC 64 30 98          defb %11001100,%01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000 ; char 188
 216+ 45F6 CC 64 30 98
 217+ 45FA 30 98 CC 64          defb %00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100,%01100100 ; char 189
 217+ 45FE 30 98 CC 64
 218+ 4602 64 CC 98 30          defb %01100100,%11001100,%10011000,%00110000,%01100100,%11001100,%10011000,%00110000 ; char 190
 218+ 4606 64 CC 98 30
 219+ 460A 20 20 F8 20          defb %00100000,%00100000,%11111000,%00100000,%00100000,%00000000,%11111000,%00000000 ; char 191 (Â±)
 219+ 460E 20 00 F8 00
 220+ 4612 C0 30 08 30          defb %11000000,%00110000,%00001000,%00110000,%11000000,%00000000,%11111000,%00000000 ; char 192 (â¥)
 220+ 4616 C0 00 F8 00
 221+ 461A 18 60 80 60          defb %00011000,%01100000,%10000000,%01100000,%00011000,%00000000,%11111000,%00000000 ; char 193 (â¤)
 221+ 461E 18 00 F8 00
 222+ 4622 3C 20 20 20          defb %00111100,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 222+ 4626 A0 60 20 00
 223+ 462A 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 223+ 462E 00 00 00 00
 224+ 4632 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 224+ 4636 70 00 00 00
 225+ 463A 00 00 54 A8          defb %00000000,%00000000,%01010100,%10101000,%00000000,%11111100,%00000000,%00000000 ; char 197
 225+ 463E 00 FC 00 00
 226+ 4642 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 226+ 4646 54 A8 00 00
 227+ 464A 00 80 C0 E0          defb %00000000,%10000000,%11000000,%11100000,%11100000,%11000000,%10000000,%00000000 ; char 199
 227+ 464E E0 C0 80 00
 228+ 4652 FC 78 30 00          defb %11111100,%01111000,%00110000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 200
 228+ 4656 00 00 00 00
 229+ 465A 00 04 0C 1C          defb %00000000,%00000100,%00001100,%00011100,%00011100,%00001100,%00000100,%00000000 ; char 201
 229+ 465E 1C 0C 04 00
 230+ 4662 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00110000,%01111000,%11111100 ; char 202
 230+ 4666 00 30 78 FC
 231+ 466A 20 70 F8 20          defb %00100000,%01110000,%11111000,%00100000,%00100000,%00100000,%00100000,%00000000 ; char 203 (up arrow)
 231+ 466E 20 20 20 00
 232+ 4672 3C 1C 1C 24          defb %00111100,%00011100,%00011100,%00100100,%01000000,%10000000,%00000000,%00000000 ; char 204 (up right arrow)
 232+ 4676 40 80 00 00
 233+ 467A 00 10 18 FC          defb %00000000,%00010000,%00011000,%11111100,%00011000,%00010000,%00000000,%00000000 ; char 205 (right arrow)
 233+ 467E 18 10 00 00
 234+ 4682 00 00 80 40          defb %00000000,%00000000,%10000000,%01000000,%00100100,%00011100,%00011100,%00111100 ; char 206 (down right arrow)
 234+ 4686 24 1C 1C 3C
 235+ 468A 00 20 20 20          defb %00000000,%00100000,%00100000,%00100000,%00100000,%11111000,%01110000,%00100000 ; char 207 (down arrow)
 235+ 468E 20 F8 70 20
 236+ 4692 00 00 04 08          defb %00000000,%00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000 ; char 208 (down left arrow)
 236+ 4696 90 E0 E0 F0
 237+ 469A 00 20 60 FC          defb %00000000,%00100000,%01100000,%11111100,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 237+ 469E 60 20 00 00
 238+ 46A2 F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 238+ 46A6 08 04 00 00
 239+ 46AA 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 239+ 46AE F0 44 38 00
 240+ 46B2 00 04 78 A8          defb %00000000,%00000100,%01111000,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 240+ 46B6 28 28 28 00
 241+ 46BA 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00100000,%00100000,%00100000 ; char 213
 241+ 46BE 1C 20 20 20
 242+ 46C2 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%00010000,%00010000,%00010000 ; char 214
 242+ 46C6 E0 10 10 10
 243+ 46CA 10 10 10 E0          defb %00010000,%00010000,%00010000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 215
 243+ 46CE 00 00 00 00
 244+ 46D2 20 20 20 1C          defb %00100000,%00100000,%00100000,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 216
 244+ 46D6 00 00 00 00
 245+ 46DA 00 00 00 1C          defb %00000000,%00000000,%00000000,%00011100,%00111100,%00110000,%00110000,%00110000 ; char 217
 245+ 46DE 3C 30 30 30
 246+ 46E2 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00110000,%00110000,%00110000 ; char 218
 246+ 46E6 F0 30 30 30
 247+ 46EA 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 247+ 46EE E0 00 00 00
 248+ 46F2 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00011100,%00000000,%00000000,%00000000 ; char 220
 248+ 46F6 1C 00 00 00
 249+ 46FA 00 30 48 48          defb %00000000,%00110000,%01001000,%01001000,%01001000,%00110000,%00000000,%00000000 ; char 221
 249+ 46FE 48 30 00 00
 250+ 4702 00 30 78 78          defb %00000000,%00110000,%01111000,%01111000,%01111000,%00110000,%00000000,%00000000 ; char 222
 250+ 4706 78 30 00 00
 251+ 470A 00 30 78 FC          defb %00000000,%00110000,%01111000,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 223
 251+ 470E FC 78 30 00
 252+ 4712 FC F8 F0 E0          defb %11111100,%11111000,%11110000,%11100000,%11100000,%11000000,%10000000,%10000000 ; char 224
 252+ 4716 E0 C0 80 80
 253+ 471A FC 7C 3C 1C          defb %11111100,%01111100,%00111100,%00011100,%00011100,%00001100,%00000100,%00000100 ; char 225
 253+ 471E 1C 0C 04 04
 254+ 4722 04 04 0C 1C          defb %00000100,%00000100,%00001100,%00011100,%00011100,%00111100,%01111100,%11111100 ; char 226
 254+ 4726 1C 3C 7C FC
 255+ 472A 80 80 C0 E0          defb %10000000,%10000000,%11000000,%11100000,%11100000,%11110000,%11111000,%11111100 ; char 227
 255+ 472E E0 F0 F8 FC
 256+ 4732 00 04 0C D8          defb %00000000,%00000100,%00001100,%11011000,%11110000,%11100000,%11000000,%00000000 ; char 228 (checkmark)
 256+ 4736 F0 E0 C0 00
 257+ 473A 00 CC 78 30          defb %00000000,%11001100,%01111000,%00110000,%01111000,%11001100,%00000000,%00000000 ; char 229 (x)
 257+ 473E 78 CC 00 00
 258+ 4742 70 88 88 88          defb %01110000,%10001000,%10001000,%10001000,%01110000,%00100000,%01110000,%00100000 ; char 230 (female)
 258+ 4746 70 20 70 20
 259+ 474A 00 1C 0C 74          defb %00000000,%00011100,%00001100,%01110100,%10010000,%10010000,%01100000,%00000000 ; char 231 (male)
 259+ 474E 90 90 60 00
 260+ 4752 F8 84 84 84          defb %11111000,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 232 (new doc)
 260+ 4756 84 84 84 FC
 261+ 475A 00 F0 FC 84          defb %00000000,%11110000,%11111100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 233 (folder)
 261+ 475E 84 84 84 FC
 262+ 4762 30 78 FC 48          defb %00110000,%01111000,%11111100,%01001000,%01001000,%01001000,%01001000,%01111000 ; char 234 (trash bin)
 262+ 4766 48 48 48 78
 263+ 476A FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%11111100,%10110100,%10110100,%11111100 ; char 235 (floppy disk)
 263+ 476E FC B4 B4 FC
 264+ 4772 00 00 D4 D8          defb %00000000,%00000000,%11010100,%11011000,%11010100,%11010100,%00000000,%00000000 ; char 236 (OK)
 264+ 4776 D4 D4 00 00
 265+ 477A 30 78 FC 78          defb %00110000,%01111000,%11111100,%01111000,%01111000,%01001000,%01001000,%01001000 ; char 237 (home)
 265+ 477E 78 48 48 48
 266+ 4782 78 84 A4 A4          defb %01111000,%10000100,%10100100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 238 (clock)
 266+ 4786 B4 84 78 00
 267+ 478A 00 00 08 F4          defb %00000000,%00000000,%00001000,%11110100,%10101000,%10000000,%00000000,%00000000 ; char 239 (key)
 267+ 478E A8 80 00 00
 268+ 4792 20 30 78 B0          defb %00100000,%00110000,%01111000,%10110000,%10100000,%10001000,%01110000,%00000000 ; char 240 (undo)
 268+ 4796 A0 88 70 00
 269+ 479A 00 FC CC B4          defb %00000000,%11111100,%11001100,%10110100,%10000100,%10000100,%11111100,%00000000 ; char 241 (letter)
 269+ 479E 84 84 FC 00
 270+ 47A2 60 90 90 F0          defb %01100000,%10010000,%10010000,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 242 (lock)
 270+ 47A6 F0 F0 F0 00
 271+ 47AA 08 14 14 F0          defb %00001000,%00010100,%00010100,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 243 (unlock)
 271+ 47AE F0 F0 F0 00
 272+ 47B2 FC FC 84 B4          defb %11111100,%11111100,%10000100,%10110100,%10010100,%10010100,%10000100,%11111100 ; char 244 (calendar)
 272+ 47B6 94 94 84 FC
 273+ 47BA 00 04 38 58          defb %00000000,%00000100,%00111000,%01011000,%01101000,%01110000,%10000000,%00000000 ; char 245 (diameter)
 273+ 47BE 68 70 80 00
 274+ 47C2 78 84 84 84          defb %01111000,%10000100,%10000100,%10000100,%01101100,%00011000,%00001000,%00000000 ; char 246 (baloon)
 274+ 47C6 6C 18 08 00
 275+ 47CA 30 28 28 28          defb %00110000,%00101000,%00101000,%00101000,%00100000,%01100000,%11100000,%01000000 ; char 247 (note)
 275+ 47CE 20 60 E0 40
 276+ 47D2 20 68 E4 E4          defb %00100000,%01101000,%11100100,%11100100,%11100100,%01101000,%00100000,%00000000 ; char 248 (audio on)
 276+ 47D6 E4 68 20 00
 277+ 47DA 20 60 E0 E0          defb %00100000,%01100000,%11100000,%11100000,%11100000,%01100000,%00100000,%00000000 ; char 249 (audio off)
 277+ 47DE E0 60 20 00
 278+ 47E2 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11110000,%10010000 ; char 250 (pointer)
 278+ 47E6 F8 FC F0 90
 279+ 47EA 78 84 B4 A4          defb %01111000,%10000100,%10110100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 251 (Â©)
 279+ 47EE B4 84 78 00
 280+ 47F2 30 48 40 E0          defb %00110000,%01001000,%01000000,%11100000,%01000000,%01001000,%10110000,%00000000 ; char 252 (Â£)
 280+ 47F6 40 48 B0 00
 281+ 47FA 78 84 F0 48          defb %01111000,%10000100,%11110000,%01001000,%01001000,%00111100,%10000100,%01111000 ; char 253 (Â§)
 281+ 47FE 48 3C 84 78
 282+ 4802 00 00 20 00          defb %00000000,%00000000,%00100000,%00000000,%11111000,%00000000,%00100000,%00000000 ; char 254 (Ã·)
 282+ 4806 F8 00 20 00
 283+ 480A FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 255 (cursor)
 283+ 480E FC FC FC FC
 284+ 4812                      ; here ends the ASCII table
 285+ 4812
# file closed: ../include/vdp/6x8fonts-r16.asm
  79  4812                  INCLUDE "../include/vdp/8x8fonts-r18.asm"
# file opened: ../include/vdp/8x8fonts-r18.asm
   1+ 4812              ; ------------------------------------------------------------------------------
   2+ 4812              ; LM80C - 8x8 CHARSET - R1.8
   3+ 4812              ; ------------------------------------------------------------------------------
   4+ 4812              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4812              ; designed by Leonardo Miliani. More info at
   6+ 4812              ; www DOT leonardomiliani DOT com
   7+ 4812              ; ------------------------------------------------------------------------------
   8+ 4812              ; Code Revision:
   9+ 4812              ; R1.0 - 20190615 - First revision: ASCII chars (from 0 to 255) - actually, they are 6x8 pixels
  10+ 4812              ; R1.1 - 20190616 - Converted to 8x8 pixels
  11+ 4812              ; R1.2 - 20191013 - Added new graphic chars and reorganized previous ones
  12+ 4812              ; R1.3 - 20191015 - More graphic chars
  13+ 4812              ; R1.4 - 20191202 - Fixed char 11/12, added new special chars
  14+ 4812              ; R1.5 - 20191210 - Changed several graphic chars
  15+ 4812              ; R1.6 - 20200125 - Removed double chars, changed with new ones
  16+ 4812              ; R1.7 - 20200228 - adopted more usual hexadecimal & binary prefixes
  17+ 4812              ; R1.8 - 20200524 - New style for char #252
  18+ 4812              ; ------------------------------------------------------------------------------
  19+ 4812              ;
  20+ 4812              ;-------------------------------------------------------------------------------
  21+ 4812              ;
  22+ 4812              ;               8 x 8    C  H  A  R  S  E  T
  23+ 4812              ;
  24+ 4812              ;-------------------------------------------------------------------------------
  25+ 4812              ;
  26+ 4812              ;       8X8 CHARS, DESIGNED FOR GRAPHICS 1 MODE
  27+ 4812
  28+ 4812              CHRST88 equ $
  29+ 4812 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  29+ 4816 00 00 00 00
  30+ 481A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  30+ 481E 00 00 00 00
  31+ 4822 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  31+ 4826 00 00 00 00
  32+ 482A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  32+ 482E 00 00 00 00
  33+ 4832 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  33+ 4836 00 00 00 00
  34+ 483A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  34+ 483E 00 00 00 00
  35+ 4842 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  35+ 4846 00 00 00 00
  36+ 484A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  36+ 484E 00 00 00 00
  37+ 4852 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 DEL key (backspace)
  37+ 4856 00 00 00 00
  38+ 485A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  38+ 485E 00 00 00 00
  39+ 4862 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  39+ 4866 00 00 00 00
  40+ 486A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 (unused)
  40+ 486E 00 00 00 00
  41+ 4872 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  41+ 4876 00 00 00 00
  42+ 487A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 RETURN key (carriage return)
  42+ 487E 00 00 00 00
  43+ 4882 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL key
  43+ 4886 00 00 00 00
  44+ 488A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  44+ 488E 00 00 00 00
  45+ 4892 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  45+ 4896 00 00 00 00
  46+ 489A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  46+ 489E 00 00 00 00
  47+ 48A2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  47+ 48A6 00 00 00 00
  48+ 48AA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  48+ 48AE 00 00 00 00
  49+ 48B2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT key
  49+ 48B6 00 00 00 00
  50+ 48BA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  50+ 48BE 00 00 00 00
  51+ 48C2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6 key
  51+ 48C6 00 00 00 00
  52+ 48CA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7 key
  52+ 48CE 00 00 00 00
  53+ 48D2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP key
  53+ 48D6 00 00 00 00
  54+ 48DA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 HOME key
  54+ 48DE 00 00 00 00
  55+ 48E2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26 INSERT key
  55+ 48E6 00 00 00 00
  56+ 48EA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 ESCAPE key
  56+ 48EE 00 00 00 00
  57+ 48F2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 CRSR LEFT key (cursor left)
  57+ 48F6 00 00 00 00
  58+ 48FA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 CRSR RIGHT key (cursor right)
  58+ 48FE 00 00 00 00
  59+ 4902 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 CRSR UP key (cursor up)
  59+ 4906 00 00 00 00
  60+ 490A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 CRSR DOWN key (cursor down)
  60+ 490E 00 00 00 00
  61+ 4912 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32 SPACE key
  61+ 4916 00 00 00 00
  62+ 491A 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00000000,%00010000,%00000000 ; char 33 - !
  62+ 491E 10 00 10 00
  63+ 4922 28 28 28 00          defb %00101000,%00101000,%00101000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 34 - "
  63+ 4926 00 00 00 00
  64+ 492A 28 28 FE 28          defb %00101000,%00101000,%11111110,%00101000,%11111110,%00101000,%00101000,%00000000 ; char 35 - #
  64+ 492E FE 28 28 00
  65+ 4932 10 3C 50 38          defb %00010000,%00111100,%01010000,%00111000,%00010100,%01111000,%00010000,%00000000 ; char 36 - $
  65+ 4936 14 78 10 00
  66+ 493A 00 62 64 08          defb %00000000,%01100010,%01100100,%00001000,%00010000,%00100110,%01000110,%00000000 ; char 37 - %
  66+ 493E 10 26 46 00
  67+ 4942 00 30 48 30          defb %00000000,%00110000,%01001000,%00110000,%01001010,%01000100,%00111010,%00000000 ; char 38 - &
  67+ 4946 4A 44 3A 00
  68+ 494A 08 10 20 00          defb %00001000,%00010000,%00100000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 39 - '
  68+ 494E 00 00 00 00
  69+ 4952 08 10 20 20          defb %00001000,%00010000,%00100000,%00100000,%00100000,%00010000,%00001000,%00000000 ; char 40 - (
  69+ 4956 20 10 08 00
  70+ 495A 20 10 08 08          defb %00100000,%00010000,%00001000,%00001000,%00001000,%00010000,%00100000,%00000000 ; char 41 - )
  70+ 495E 08 10 20 00
  71+ 4962 00 10 54 38          defb %00000000,%00010000,%01010100,%00111000,%00111000,%01010100,%00010000,%00000000 ; char 42 - *
  71+ 4966 38 54 10 00
  72+ 496A 00 10 10 7C          defb %00000000,%00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%00000000 ; char 43 - +
  72+ 496E 10 10 00 00
  73+ 4972 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00001000,%00010000 ; char 44 - ,
  73+ 4976 00 18 08 10
  74+ 497A 00 00 00 7C          defb %00000000,%00000000,%00000000,%01111100,%00000000,%00000000,%00000000,%00000000 ; char 45 - -
  74+ 497E 00 00 00 00
  75+ 4982 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00011000,%00000000 ; char 46 - .
  75+ 4986 00 18 18 00
  76+ 498A 00 02 04 08          defb %00000000,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%00000000 ; char 47 - /
  76+ 498E 10 20 40 00
  77+ 4992 38 44 4C 54          defb %00111000,%01000100,%01001100,%01010100,%01100100,%01000100,%00111000,%00000000 ; char 48 - 0
  77+ 4996 64 44 38 00
  78+ 499A 10 30 50 10          defb %00010000,%00110000,%01010000,%00010000,%00010000,%00010000,%01111100,%00000000 ; char 49 - 1
  78+ 499E 10 10 7C 00
  79+ 49A2 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 50 - 2
  79+ 49A6 10 20 7C 00
  80+ 49AA 7C 08 10 08          defb %01111100,%00001000,%00010000,%00001000,%00000100,%01000100,%00111000,%00000000 ; char 51 - 3
  80+ 49AE 04 44 38 00
  81+ 49B2 08 18 28 48          defb %00001000,%00011000,%00101000,%01001000,%01111100,%00001000,%00001000,%00000000 ; char 52 - 4
  81+ 49B6 7C 08 08 00
  82+ 49BA 7C 40 78 04          defb %01111100,%01000000,%01111000,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 53 - 5
  82+ 49BE 04 44 38 00
  83+ 49C2 38 44 40 78          defb %00111000,%01000100,%01000000,%01111000,%01000100,%01000100,%00111000,%00000000 ; char 54 - 6
  83+ 49C6 44 44 38 00
  84+ 49CA 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%00100000,%00100000,%00000000 ; char 55 - 7
  84+ 49CE 20 20 20 00
  85+ 49D2 38 44 44 38          defb %00111000,%01000100,%01000100,%00111000,%01000100,%01000100,%00111000,%00000000 ; char 56 - 8
  85+ 49D6 44 44 38 00
  86+ 49DA 38 44 44 3C          defb %00111000,%01000100,%01000100,%00111100,%00000100,%01000100,%00111000,%00000000 ; char 57 - 9
  86+ 49DE 04 44 38 00
  87+ 49E2 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00011000,%00000000,%00000000 ; char 58 - :
  87+ 49E6 18 18 00 00
  88+ 49EA 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00001000,%00010000,%00000000 ; char 59 - ;
  88+ 49EE 18 08 10 00
  89+ 49F2 04 08 10 20          defb %00000100,%00001000,%00010000,%00100000,%00010000,%00001000,%00000100,%00000000 ; char 60 - <
  89+ 49F6 10 08 04 00
  90+ 49FA 00 00 7E 00          defb %00000000,%00000000,%01111110,%00000000,%01111110,%00000000,%00000000,%00000000 ; char 61 - =
  90+ 49FE 7E 00 00 00
  91+ 4A02 20 10 08 04          defb %00100000,%00010000,%00001000,%00000100,%00001000,%00010000,%00100000,%00000000 ; char 62 - >
  91+ 4A06 08 10 20 00
  92+ 4A0A 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00000000,%00010000,%00000000 ; char 63 - ?
  92+ 4A0E 10 00 10 00
  93+ 4A12 78 84 BC AC          defb %01111000,%10000100,%10111100,%10101100,%10111000,%10000000,%10000100,%01111000 ; char 64 - @
  93+ 4A16 B8 80 84 78
  94+ 4A1A 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%00000000 ; char 65 - A
  94+ 4A1E 7C 44 44 00
  95+ 4A22 78 44 44 78          defb %01111000,%01000100,%01000100,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 66 - B
  95+ 4A26 44 44 78 00
  96+ 4A2A 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 67 - C
  96+ 4A2E 40 44 38 00
  97+ 4A32 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01000100,%01000100,%01111000,%00000000 ; char 68 - D
  97+ 4A36 44 44 78 00
  98+ 4A3A 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01111100,%00000000 ; char 69 - E
  98+ 4A3E 40 40 7C 00
  99+ 4A42 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01000000,%00000000 ; char 70 - F
  99+ 4A46 40 40 40 00
 100+ 4A4A 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01011100,%01000100,%00111000,%00000000 ; char 71 - G
 100+ 4A4E 5C 44 38 00
 101+ 4A52 44 44 44 7C          defb %01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%01000100,%00000000 ; char 72 - H
 101+ 4A56 44 44 44 00
 102+ 4A5A 38 10 10 10          defb %00111000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 73 - I
 102+ 4A5E 10 10 38 00
 103+ 4A62 3C 04 04 04          defb %00111100,%00000100,%00000100,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 74 - J
 103+ 4A66 04 44 38 00
 104+ 4A6A 44 44 48 70          defb %01000100,%01000100,%01001000,%01110000,%01001000,%01000100,%01000100,%00000000 ; char 75 - K
 104+ 4A6E 48 44 44 00
 105+ 4A72 40 40 40 40          defb %01000000,%01000000,%01000000,%01000000,%01000000,%01000000,%01111100,%00000000 ; char 76 - L
 105+ 4A76 40 40 7C 00
 106+ 4A7A 42 66 5A 42          defb %01000010,%01100110,%01011010,%01000010,%01000010,%01000010,%01000010,%00000000 ; char 77 - M
 106+ 4A7E 42 42 42 00
 107+ 4A82 44 64 54 4C          defb %01000100,%01100100,%01010100,%01001100,%01000100,%01000100,%01000100,%00000000 ; char 78 - N
 107+ 4A86 44 44 44 00
 108+ 4A8A 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 79 - O
 108+ 4A8E 44 44 38 00
 109+ 4A92 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01000000,%01000000,%00000000 ; char 80 - P
 109+ 4A96 78 40 40 00
 110+ 4A9A 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01010100,%01001000,%00110100,%00000000 ; char 81 - Q
 110+ 4A9E 54 48 34 00
 111+ 4AA2 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01001000,%01000100,%00000000 ; char 82 - R
 111+ 4AA6 78 48 44 00
 112+ 4AAA 3C 40 40 38          defb %00111100,%01000000,%01000000,%00111000,%00000100,%00000100,%01111000,%00000000 ; char 83 - S
 112+ 4AAE 04 04 78 00
 113+ 4AB2 7C 10 10 10          defb %01111100,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 84 - T
 113+ 4AB6 10 10 10 00
 114+ 4ABA 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 85 - U
 114+ 4ABE 44 44 38 00
 115+ 4AC2 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 86 - V
 115+ 4AC6 44 28 10 00
 116+ 4ACA 42 42 42 42          defb %01000010,%01000010,%01000010,%01000010,%01011010,%01011010,%00100100,%00000000 ; char 87 - W
 116+ 4ACE 5A 5A 24 00
 117+ 4AD2 44 44 28 10          defb %01000100,%01000100,%00101000,%00010000,%00101000,%01000100,%01000100,%00000000 ; char 88 - X
 117+ 4AD6 28 44 44 00
 118+ 4ADA 44 44 44 28          defb %01000100,%01000100,%01000100,%00101000,%00010000,%00010000,%00010000,%00000000 ; char 89 - Y
 118+ 4ADE 10 10 10 00
 119+ 4AE2 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%01000000,%01111100,%00000000 ; char 90 - Z
 119+ 4AE6 20 40 7C 00
 120+ 4AEA 38 20 20 20          defb %00111000,%00100000,%00100000,%00100000,%00100000,%00100000,%00111000,%00000000 ; char 91 - [
 120+ 4AEE 20 20 38 00
 121+ 4AF2 00 40 20 10          defb %00000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000000 ; char 92 - \
 121+ 4AF6 08 04 02 00
 122+ 4AFA 38 08 08 08          defb %00111000,%00001000,%00001000,%00001000,%00001000,%00001000,%00111000,%00000000 ; char 93 - ]
 122+ 4AFE 08 08 38 00
 123+ 4B02 10 28 44 00          defb %00010000,%00101000,%01000100,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 94 - ^
 123+ 4B06 00 00 00 00
 124+ 4B0A 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%01111110,%00000000 ; char 95 _ (underscore)
 124+ 4B0E 00 00 7E 00
 125+ 4B12 20 10 08 00          defb %00100000,%00010000,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 96 - `
 125+ 4B16 00 00 00 00
 126+ 4B1A 00 00 38 04          defb %00000000,%00000000,%00111000,%00000100,%00111100,%01000100,%00111100,%00000000 ; char 97 - a
 126+ 4B1E 3C 44 3C 00
 127+ 4B22 40 40 40 78          defb %01000000,%01000000,%01000000,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 98 - b
 127+ 4B26 44 44 78 00
 128+ 4B2A 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 99 - c
 128+ 4B2E 40 44 38 00
 129+ 4B32 04 04 04 3C          defb %00000100,%00000100,%00000100,%00111100,%01000100,%01000100,%00111100,%00000000 ; char 100 - d
 129+ 4B36 44 44 3C 00
 130+ 4B3A 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01111100,%01000000,%00111000,%00000000 ; char 101 - e
 130+ 4B3E 7C 40 38 00
 131+ 4B42 18 24 20 70          defb %00011000,%00100100,%00100000,%01110000,%00100000,%00100000,%00100000,%00000000 ; char 102 - f
 131+ 4B46 20 20 20 00
 132+ 4B4A 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00111000 ; char 103 - g
 132+ 4B4E 44 3C 04 38
 133+ 4B52 40 40 58 64          defb %01000000,%01000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 104 - h
 133+ 4B56 44 44 44 00
 134+ 4B5A 00 10 00 10          defb %00000000,%00010000,%00000000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 105 - i
 134+ 4B5E 10 10 10 00
 135+ 4B62 08 00 18 08          defb %00001000,%00000000,%00011000,%00001000,%00001000,%00001000,%01001000,%00110000 ; char 106 - j
 135+ 4B66 08 08 48 30
 136+ 4B6A 40 40 48 50          defb %01000000,%01000000,%01001000,%01010000,%01100000,%01010000,%01001000,%00000000 ; char 107 - k
 136+ 4B6E 60 50 48 00
 137+ 4B72 30 10 10 10          defb %00110000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 108 - l
 137+ 4B76 10 10 38 00
 138+ 4B7A 00 00 54 6A          defb %00000000,%00000000,%01010100,%01101010,%01001010,%01000010,%01000010,%00000000 ; char 109 - m
 138+ 4B7E 4A 42 42 00
 139+ 4B82 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 110 - n
 139+ 4B86 44 44 44 00
 140+ 4B8A 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 111: o
 140+ 4B8E 44 44 38 00
 141+ 4B92 00 00 78 44          defb %00000000,%00000000,%01111000,%01000100,%01000100,%01111000,%01000000,%01000000 ; char 112: p
 141+ 4B96 44 78 40 40
 142+ 4B9A 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00000100 ; char 113: q
 142+ 4B9E 44 3C 04 04
 143+ 4BA2 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000000,%01000000,%01000000,%00000000 ; char 114: r
 143+ 4BA6 40 40 40 00
 144+ 4BAA 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%00111000,%00000100,%01111000,%00000000 ; char 115: s
 144+ 4BAE 38 04 78 00
 145+ 4BB2 20 20 70 20          defb %00100000,%00100000,%01110000,%00100000,%00100000,%00100100,%00011000,%00000000 ; char 116: t
 145+ 4BB6 20 24 18 00
 146+ 4BBA 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%01001100,%00110100,%00000000 ; char 117: u
 146+ 4BBE 44 4C 34 00
 147+ 4BC2 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 118: v
 147+ 4BC6 44 28 10 00
 148+ 4BCA 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01010100,%01010100,%00101000,%00000000 ; char 119: w
 148+ 4BCE 54 54 28 00
 149+ 4BD2 00 00 44 28          defb %00000000,%00000000,%01000100,%00101000,%00010000,%00101000,%01000100,%00000000 ; char 120: x
 149+ 4BD6 10 28 44 00
 150+ 4BDA 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01001100,%00110100,%00000100,%00111000 ; char 121: y
 150+ 4BDE 4C 34 04 38
 151+ 4BE2 00 00 7C 08          defb %00000000,%00000000,%01111100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 122: z
 151+ 4BE6 10 20 7C 00
 152+ 4BEA 18 20 20 40          defb %00011000,%00100000,%00100000,%01000000,%00100000,%00100000,%00011000,%00000000 ; char 123: {
 152+ 4BEE 20 20 18 00
 153+ 4BF2 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 124: |
 153+ 4BF6 10 10 10 00
 154+ 4BFA 30 08 08 04          defb %00110000,%00001000,%00001000,%00000100,%00001000,%00001000,%00110000,%00000000 ; char 125: }
 154+ 4BFE 08 08 30 00
 155+ 4C02 20 54 08 00          defb %00100000,%01010100,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 126: ~
 155+ 4C06 00 00 00 00
 156+ 4C0A 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 127 (delete) - end the standard ASCII (0-127)
 156+ 4C0E 00 00 00 00
 157+ 4C12 3C 42 A5 81          defb %00111100,%01000010,%10100101,%10000001,%10100101,%10011001,%01000010,%00111100 ; char 128 (open face)
 157+ 4C16 A5 99 42 3C
 158+ 4C1A 3C 7E DB FF          defb %00111100,%01111110,%11011011,%11111111,%11011011,%11100111,%01111110,%00111100 ; char 129 (full face)
 158+ 4C1E DB E7 7E 3C
 159+ 4C22 6C FE FE FE          defb %01101100,%11111110,%11111110,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 130 (hearts)
 159+ 4C26 7C 38 10 00
 160+ 4C2A 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 131 (diamonds)
 160+ 4C2E 7C 38 10 00
 161+ 4C32 10 38 54 FE          defb %00010000,%00111000,%01010100,%11111110,%01010100,%00010000,%01111100,%00000000 ; char 132 (clus)
 161+ 4C36 54 10 7C 00
 162+ 4C3A 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%11010110,%00010000,%01111100,%00000000 ; char 133 (spades)
 162+ 4C3E D6 10 7C 00
 163+ 4C42 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 134
 163+ 4C46 FF 18 18 18
 164+ 4C4A 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 135
 164+ 4C4E 1F 18 18 18
 165+ 4C52 00 00 00 F8          defb %00000000,%00000000,%00000000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 136
 165+ 4C56 F8 18 18 18
 166+ 4C5A 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00000000,%00000000,%00000000 ; char 137
 166+ 4C5E F8 00 00 00
 167+ 4C62 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00000000,%00000000,%00000000 ; char 138
 167+ 4C66 1F 00 00 00
 168+ 4C6A 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 139
 168+ 4C6E FF 00 00 00
 169+ 4C72 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 140
 169+ 4C76 1F 18 18 18
 170+ 4C7A 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 141
 170+ 4C7E FF 18 18 18
 171+ 4C82 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 142
 171+ 4C86 F8 18 18 18
 172+ 4C8A 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 143
 172+ 4C8E FF 00 00 00
 173+ 4C92 18 18 18 18          defb %00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000 ; char 144
 173+ 4C96 18 18 18 18
 174+ 4C9A 03 07 0E 1C          defb %00000011,%00000111,%00001110,%00011100,%00111000,%01110000,%11100000,%11000000 ; char 145
 174+ 4C9E 38 70 E0 C0
 175+ 4CA2 C0 E0 70 38          defb %11000000,%11100000,%01110000,%00111000,%00011100,%00001110,%00000111,%00000011 ; char 146
 175+ 4CA6 1C 0E 07 03
 176+ 4CAA C3 E7 7E 3C          defb %11000011,%11100111,%01111110,%00111100,%00111100,%01111110,%11100111,%11000011 ; char 147
 176+ 4CAE 3C 7E E7 C3
 177+ 4CB2 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 148
 177+ 4CB6 10 10 10 10
 178+ 4CBA 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 149
 178+ 4CBE 10 10 10 10
 179+ 4CC2 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 150
 179+ 4CC6 10 10 10 10
 180+ 4CCA 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 151
 180+ 4CCE 00 00 00 00
 181+ 4CD2 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00000000,%00000000,%00000000,%00000000 ; char 152
 181+ 4CD6 00 00 00 00
 182+ 4CDA 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 153
 182+ 4CDE 00 00 00 00
 183+ 4CE2 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 154
 183+ 4CE6 10 10 10 10
 184+ 4CEA 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 155
 184+ 4CEE 10 10 10 10
 185+ 4CF2 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 156
 185+ 4CF6 10 10 10 10
 186+ 4CFA 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 157
 186+ 4CFE 00 00 00 00
 187+ 4D02 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000 ; char 158
 187+ 4D06 10 10 10 10
 188+ 4D0A 01 02 04 08          defb %00000001,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%10000000 ; char 159
 188+ 4D0E 10 20 40 80
 189+ 4D12 80 40 20 10          defb %10000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000001 ; char 160
 189+ 4D16 08 04 02 01
 190+ 4D1A 81 42 24 18          defb %10000001,%01000010,%00100100,%00011000,%00011000,%00100100,%01000010,%10000001 ; char 161
 190+ 4D1E 18 24 42 81
 191+ 4D22 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 162
 191+ 4D26 00 00 FF FF
 192+ 4D2A 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; char 163
 192+ 4D2E FF FF FF FF
 193+ 4D32 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 164
 193+ 4D36 FF FF FF FF
 194+ 4D3A FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 194+ 4D3E 00 00 00 00
 195+ 4D42 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 166
 195+ 4D46 00 00 00 00
 196+ 4D4A FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 167
 196+ 4D4E FF FF 00 00
 197+ 4D52 C0 C0 C0 C0          defb %11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000 ; char 168
 197+ 4D56 C0 C0 C0 C0
 198+ 4D5A F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; char 169
 198+ 4D5E F0 F0 F0 F0
 199+ 4D62 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 170
 199+ 4D66 FC FC FC FC
 200+ 4D6A 03 03 03 03          defb %00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011 ; char 171
 200+ 4D6E 03 03 03 03
 201+ 4D72 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; char 172
 201+ 4D76 0F 0F 0F 0F
 202+ 4D7A 3F 3F 3F 3F          defb %00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111 ; char 173
 202+ 4D7E 3F 3F 3F 3F
 203+ 4D82 FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 174
 203+ 4D86 81 81 81 FF
 204+ 4D8A 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; char 175
 204+ 4D8E F0 F0 F0 F0
 205+ 4D92 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; char 176
 205+ 4D96 0F 0F 0F 0F
 206+ 4D9A 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; char 177
 206+ 4D9E 00 00 00 00
 207+ 4DA2 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 178
 207+ 4DA6 00 00 00 00
 208+ 4DAA F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00001111,%00001111,%00001111,%00001111 ; char 179
 208+ 4DAE 0F 0F 0F 0F
 209+ 4DB2 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%11110000,%11110000,%11110000,%11110000 ; char 180
 209+ 4DB6 F0 F0 F0 F0
 210+ 4DBA 3C 3C 3C 3C          defb %00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100 ; char 181
 210+ 4DBE 3C 3C 3C 3C
 211+ 4DC2 C3 C3 C3 C3          defb %11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011 ; char 182
 211+ 4DC6 C3 C3 C3 C3
 212+ 4DCA FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 183
 212+ 4DCE 00 00 FF FF
 213+ 4DD2 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 184
 213+ 4DD6 FF FF 00 00
 214+ 4DDA 33 33 CC CC          defb %00110011,%00110011,%11001100,%11001100,%00110011,%00110011,%11001100,%11001100 ; char 185
 214+ 4DDE 33 33 CC CC
 215+ 4DE2 55 AA 55 AA          defb %01010101,%10101010,%01010101,%10101010,%01010101,%10101010,%01010101,%10101010 ; char 186
 215+ 4DE6 55 AA 55 AA
 216+ 4DEA 66 33 99 CC          defb %01100110,%00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100 ; char 187
 216+ 4DEE 66 33 99 CC
 217+ 4DF2 CC 99 33 66          defb %11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011,%01100110 ; char 188
 217+ 4DF6 CC 99 33 66
 218+ 4DFA 33 99 CC 66          defb %00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100,%01100110 ; char 189
 218+ 4DFE 33 99 CC 66
 219+ 4E02 66 CC 99 33          defb %01100110,%11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011 ; char 190
 219+ 4E06 66 CC 99 33
 220+ 4E0A 10 10 7C 10          defb %00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%01111100,%00000000 ; char 191 (Â±)
 220+ 4E0E 10 00 7C 00
 221+ 4E12 60 18 06 18          defb %01100000,%00011000,%00000110,%00011000,%01100000,%00000000,%01111110,%00000000 ; char 192 (â¥)
 221+ 4E16 60 00 7E 00
 222+ 4E1A 06 18 60 18          defb %00000110,%00011000,%01100000,%00011000,%00000110,%00000000,%01111110,%00000000 ; char 193 (â¤)
 222+ 4E1E 06 00 7E 00
 223+ 4E22 3E 20 20 20          defb %00111110,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 223+ 4E26 A0 60 20 00
 224+ 4E2A 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 224+ 4E2E 00 00 00 00
 225+ 4E32 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 225+ 4E36 70 00 00 00
 226+ 4E3A 00 00 2A 54          defb %00000000,%00000000,%00101010,%01010100,%00000000,%01111110,%00000000,%00000000 ; char 197
 226+ 4E3E 00 7E 00 00
 227+ 4E42 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 227+ 4E46 54 A8 00 00
 228+ 4E4A 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11100000,%11000000,%10000000,%00000000 ; char 199
 228+ 4E4E E0 C0 80 00
 229+ 4E52 FE 7C 38 10          defb %11111110,%01111100,%00111000,%00010000,%00000000,%00000000,%00000000,%00000000 ; char 200
 229+ 4E56 00 00 00 00
 230+ 4E5A 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00000111,%00000011,%00000001,%00000000 ; char 201
 230+ 4E5E 07 03 01 00
 231+ 4E62 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00010000,%00111000,%01111100,%11111110 ; char 202
 231+ 4E66 10 38 7C FE
 232+ 4E6A 10 38 7C 10          defb %00010000,%00111000,%01111100,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 203 (up arrow)
 232+ 4E6E 10 10 10 00
 233+ 4E72 1E 0E 0E 12          defb %00011110,%00001110,%00001110,%00010010,%00100000,%01000000,%00000000,%00000000 ; char 204 (up right arrow)
 233+ 4E76 20 40 00 00
 234+ 4E7A 00 08 0C FE          defb %00000000,%00001000,%00001100,%11111110,%00001100,%00001000,%00000000,%00000000 ; char 205 (right arrow)
 234+ 4E7E 0C 08 00 00
 235+ 4E82 00 40 20 12          defb %00000000,%01000000,%00100000,%00010010,%00001110,%00001110,%00011110,%00000000 ; char 206 (down right arrow)
 235+ 4E86 0E 0E 1E 00
 236+ 4E8A 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%01111100,%00111000,%00010000,%00000000 ; char 207 (down arrow)
 236+ 4E8E 7C 38 10 00
 237+ 4E92 00 04 08 90          defb %00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000,%00000000 ; char 208 (down left arrow)
 237+ 4E96 E0 E0 F0 00
 238+ 4E9A 00 20 60 FE          defb %00000000,%00100000,%01100000,%11111110,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 238+ 4E9E 60 20 00 00
 239+ 4EA2 F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 239+ 4EA6 08 04 00 00
 240+ 4EAA 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 240+ 4EAE F0 44 38 00
 241+ 4EB2 00 02 7C A8          defb %00000000,%00000010,%01111100,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 241+ 4EB6 28 28 28 00
 242+ 4EBA 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001000,%00010000,%00010000,%00010000 ; char 213
 242+ 4EBE 08 10 10 10
 243+ 4EC2 00 00 00 C0          defb %00000000,%00000000,%00000000,%11000000,%00100000,%00010000,%00010000,%00010000 ; char 214
 243+ 4EC6 20 10 10 10
 244+ 4ECA 10 10 20 C0          defb %00010000,%00010000,%00100000,%11000000,%00000000,%00000000,%00000000,%00000000 ; char 215
 244+ 4ECE 00 00 00 00
 245+ 4ED2 10 10 08 07          defb %00010000,%00010000,%00001000,%00000111,%00000000,%00000000,%00000000,%00000000 ; char 216
 245+ 4ED6 00 00 00 00
 246+ 4EDA 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001111,%00011100,%00011000,%00011000 ; char 217
 246+ 4EDE 0F 1C 18 18
 247+ 4EE2 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00111000,%00011000,%00011000 ; char 218
 247+ 4EE6 F0 38 18 18
 248+ 4EEA 18 18 38 F0          defb %00011000,%00011000,%00111000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 248+ 4EEE E0 00 00 00
 249+ 4EF2 18 18 1C 0F          defb %00011000,%00011000,%00011100,%00001111,%00000111,%00000000,%00000000,%00000000 ; char 220
 249+ 4EF6 07 00 00 00
 250+ 4EFA 00 3C 42 42          defb %00000000,%00111100,%01000010,%01000010,%01000010,%01000010,%00111100,%00000000 ; char 221
 250+ 4EFE 42 42 3C 00
 251+ 4F02 00 3C 7E 7E          defb %00000000,%00111100,%01111110,%01111110,%01111110,%01111110,%00111100,%00000000 ; char 222
 251+ 4F06 7E 7E 3C 00
 252+ 4F0A 00 18 3C 7E          defb %00000000,%00011000,%00111100,%01111110,%01111110,%00111100,%00011000,%00000000 ; char 223
 252+ 4F0E 7E 3C 18 00
 253+ 4F12 FF FE FC F8          defb %11111111,%11111110,%11111100,%11111000,%11110000,%11100000,%11000000,%10000000 ; char 224
 253+ 4F16 F0 E0 C0 80
 254+ 4F1A FF 7F 3F 1F          defb %11111111,%01111111,%00111111,%00011111,%00001111,%00000111,%00000011,%00000001 ; char 225
 254+ 4F1E 0F 07 03 01
 255+ 4F22 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00011111,%00111111,%01111111,%11111111 ; char 226
 255+ 4F26 1F 3F 7F FF
 256+ 4F2A 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11111110,%11111111 ; char 227
 256+ 4F2E F8 FC FE FF
 257+ 4F32 00 02 06 6C          defb %00000000,%00000010,%00000110,%01101100,%01111000,%01110000,%01100000,%00000000 ; char 228 (checkmark)
 257+ 4F36 78 70 60 00
 258+ 4F3A 00 66 3C 18          defb %00000000,%01100110,%00111100,%00011000,%00111100,%01100110,%00000000,%00000000 ; char 229 (x)
 258+ 4F3E 3C 66 00 00
 259+ 4F42 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%00111000,%00010000,%00111000,%00010000 ; char 230 (female)
 259+ 4F46 38 10 38 10
 260+ 4F4A 07 03 3D 44          defb %00000111,%00000011,%00111101,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 231 (male)
 260+ 4F4E 44 44 38 00
 261+ 4F52 78 44 42 42          defb %01111000,%01000100,%01000010,%01000010,%01000010,%01000010,%01000010,%01111110 ; char 232 (new doc)
 261+ 4F56 42 42 42 7E
 262+ 4F5A 00 F8 FF 81          defb %00000000,%11111000,%11111111,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 233 (folder)
 262+ 4F5E 81 81 81 FF
 263+ 4F62 10 7C FE 54          defb %00010000,%01111100,%11111110,%01010100,%01010100,%01010100,%01010100,%01111100 ; char 234 (trash bin)
 263+ 4F66 54 54 54 7C
 264+ 4F6A FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10111101,%10101101,%10101101,%11111111 ; char 235 (floppy disk)
 264+ 4F6E BD AD AD FF
 265+ 4F72 00 EA AA AC          defb %00000000,%11101010,%10101010,%10101100,%10101100,%10101010,%11101010,%00000000 ; char 236 (OK)
 265+ 4F76 AC AA EA 00
 266+ 4F7A 18 7E FF 7E          defb %00011000,%01111110,%11111111,%01111110,%01111110,%01100110,%01100110,%01100110 ; char 237 (home)
 266+ 4F7E 7E 66 66 66
 267+ 4F82 3C 42 91 91          defb %00111100,%01000010,%10010001,%10010001,%10011101,%10000001,%01000010,%00111100 ; char 238 (clock)
 267+ 4F86 9D 81 42 3C
 268+ 4F8A 00 02 05 FD          defb %00000000,%00000010,%00000101,%11111101,%10100101,%10100010,%00000000,%00000000 ; char 239 (key)
 268+ 4F8E A5 A2 00 00
 269+ 4F92 08 0C 3E 4C          defb %00001000,%00001100,%00111110,%01001100,%01001000,%01000010,%01000010,%00111100 ; char 240 (undo)
 269+ 4F96 48 42 42 3C
 270+ 4F9A 00 FF C3 A5          defb %00000000,%11111111,%11000011,%10100101,%10011001,%10000001,%11111111,%00000000 ; char 241 (letter)
 270+ 4F9E 99 81 FF 00
 271+ 4FA2 38 44 44 7C          defb %00111000,%01000100,%01000100,%01111100,%01111100,%01111100,%01111100,%00000000 ; char 242 (lock)
 271+ 4FA6 7C 7C 7C 00
 272+ 4FAA 06 09 09 F8          defb %00000110,%00001001,%00001001,%11111000,%11111000,%11111000,%11111000,%00000000 ; char 243 (unlock)
 272+ 4FAE F8 F8 F8 00
 273+ 4FB2 FF FF 81 AD          defb %11111111,%11111111,%10000001,%10101101,%10100101,%10100101,%10000001,%11111111 ; char 244 (calendar)
 273+ 4FB6 A5 A5 81 FF
 274+ 4FBA 01 1A 24 4A          defb %00000001,%00011010,%00100100,%01001010,%01010010,%00100100,%01011000,%10000000 ; char 245 (diameter)
 274+ 4FBE 52 24 58 80
 275+ 4FC2 7E 81 81 81          defb %01111110,%10000001,%10000001,%10000001,%10000001,%01110110,%00001100,%00000100 ; char 246 (baloon)
 275+ 4FC6 81 76 0C 04
 276+ 4FCA 0C 0A 0A 0A          defb %00001100,%00001010,%00001010,%00001010,%00001000,%00011000,%00111000,%00010000 ; char 247 (note)
 276+ 4FCE 08 18 38 10
 277+ 4FD2 12 31 F5 F5          defb %00010010,%00110001,%11110101,%11110101,%11110101,%11110101,%00110001,%00010010 ; char 248 (audio on)
 277+ 4FD6 F5 F5 31 12
 278+ 4FDA 10 30 F0 F0          defb %00010000,%00110000,%11110000,%11110000,%11110000,%11110000,%00110000,%00010000 ; char 249 (audio off)
 278+ 4FDE F0 F0 30 10
 279+ 4FE2 40 60 70 78          defb %01000000,%01100000,%01110000,%01111000,%01111100,%01111110,%01111000,%01001000 ; char 250 (pointer)
 279+ 4FE6 7C 7E 78 48
 280+ 4FEA 3C 42 99 A1          defb %00111100,%01000010,%10011001,%10100001,%10100001,%10011001,%01000010,%00111100 ; char 251 (Â©)
 280+ 4FEE A1 99 42 3C
 281+ 4FF2 18 24 20 78          defb %00011000,%00100100,%00100000,%01111000,%00100000,%00100010,%01011100,%00000000 ; char 252 (Â£)
 281+ 4FF6 20 22 5C 00
 282+ 4FFA 3C 42 78 24          defb %00111100,%01000010,%01111000,%00100100,%00100100,%00011110,%01000010,%00111100 ; char 253 (Â§)
 282+ 4FFE 24 1E 42 3C
 283+ 5002 00 00 10 00          defb %00000000,%00000000,%00010000,%00000000,%01111100,%00000000,%00010000,%00000000 ; char 254 (Ã·)
 283+ 5006 7C 00 10 00
 284+ 500A FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 255 (cursor)
 284+ 500E FF FF FF FF
 285+ 5012
# file closed: ../include/vdp/8x8fonts-r18.asm
  80  5012                  INCLUDE "../include/vdp/logo-fonts.asm"
# file opened: ../include/vdp/logo-fonts.asm
   1+ 5012              ; ------------------------------------------------------------------------------
   2+ 5012              ; LM80C - LOGO CHARSET - R1.1
   3+ 5012              ; ------------------------------------------------------------------------------
   4+ 5012              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 5012              ; designed by Leonardo Miliani. More info at
   6+ 5012              ; www DOT leonardomiliani DOT com
   7+ 5012              ; ------------------------------------------------------------------------------
   8+ 5012              ; Code Revision:
   9+ 5012              ; R1.0 - 20200124 - First revision: logo chars
  10+ 5012              ; R1.1 - 20200229 - Adopted usual hexadecimal & binary prefixes
  11+ 5012              ; ------------------------------------------------------------------------------
  12+ 5012
  13+ 5012              LOGOFONT:   equ $
  14+ 5012 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; 0
  14+ 5016 00 00 00 00
  15+ 501A FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; 1
  15+ 501E FF FF FF FF
  16+ 5022 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; 2
  16+ 5026 00 00 00 00
  17+ 502A 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; 3
  17+ 502E 0F 0F 0F 0F
  18+ 5032 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; 4
  18+ 5036 FF FF FF FF
  19+ 503A F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; 5
  19+ 503E F0 F0 F0 F0
  20+ 5042 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; 6
  20+ 5046 0F 0F 0F 0F
  21+ 504A 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; 7
  21+ 504E F0 F0 F0 F0
  22+ 5052 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; 8
  22+ 5056 00 00 00 00
  23+ 505A 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; 9
  23+ 505E 00 00 00 00
  24+ 5062 00 00 00 FC              defb %00000000,%00000000,%00000000,%11111100,%11111111,%00000111,%00000011,%00000000 ; 10
  24+ 5066 FF 07 03 00
  25+ 506A 00 00 00 3F              defb %00000000,%00000000,%00000000,%00111111,%11111111,%11100000,%11000000,%00000000 ; 11
  25+ 506E FF E0 C0 00
  26+ 5072 18 18 1F 19              defb %00011000,%00011000,%00011111,%00011001,%00011001,%00011111,%00011000,%00011000 ; 12
  26+ 5076 19 1F 18 18
  27+ 507A 18 18 F8 98              defb %00011000,%00011000,%11111000,%10011000,%10011000,%11111000,%00011000,%00011000 ; 13
  27+ 507E 98 F8 18 18
  28+ 5082 18 18 1C 1F              defb %00011000,%00011000,%00011100,%00011111,%00001111,%00000000,%00000000,%00000000 ; 14
  28+ 5086 0F 00 00 00
  29+ 508A 00 00 00 0F              defb %00000000,%00000000,%00000000,%00001111,%00011111,%00011100,%00011000,%00011000 ; 15
  29+ 508E 1F 1C 18 18
  30+ 5092 00 00 00 F0              defb %00000000,%00000000,%00000000,%11110000,%11111000,%00111000,%00011000,%00011000 ; 16
  30+ 5096 F8 38 18 18
  31+ 509A 18 18 38 F8              defb %00011000,%00011000,%00111000,%11111000,%11110000,%00000000,%00000000,%00000000 ; 17
  31+ 509E F0 00 00 00
  32+ 50A2 00 00 00 FF              defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; 18
  32+ 50A6 FF 00 00 00
  33+ 50AA 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%11111111,%11111111,%11111111,%11111111 ; 19
  33+ 50AE FF FF FF FF
  34+ 50B2 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11111111,%11111111,%11111111,%11111111 ; 20
  34+ 50B6 FF FF FF FF
  35+ 50BA FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11110000,%11110000,%11110000,%11110000 ; 21
  35+ 50BE F0 F0 F0 F0
  36+ 50C2 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00001111,%00001111,%00001111,%00001111 ; 22
  36+ 50C6 0F 0F 0F 0F
  37+ 50CA 00 30 78 78              defb %00000000,%00110000,%01111000,%01111000,%00110000,%00000000,%00000000,%00000000 ; 23
  37+ 50CE 30 00 00 00
  38+ 50D2
# file closed: ../include/vdp/logo-fonts.asm
  81  50D2
  82  50D2              ; include workspace equates
  83  50D2                  INCLUDE "../include/workspace/workspace-r1.0.asm"
# file opened: ../include/workspace/workspace-r1.0.asm
   1+ 50D2              ; ------------------------------------------------------------------------------
   2+ 50D2              ; LM80C 64K - WORKSPACE EQUATES - R1.0
   3+ 50D2              ; ------------------------------------------------------------------------------
   4+ 50D2              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 50D2              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 50D2              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 50D2              ; kind of warranty: you can use them at your own risk.
   8+ 50D2              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 50D2              ; maintain the copyright notices, include this advice and the note to the
  10+ 50D2              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 50D2              ; redistribuite them.
  12+ 50D2              ; https://www.leonardomiliani.com
  13+ 50D2              ;
  14+ 50D2              ; Please support me by visiting the following links:
  15+ 50D2              ; Main project page: https://www.leonardomiliani.com
  16+ 50D2              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 50D2              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 50D2              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 50D2              ; ------------------------------------------------------------------------------
  20+ 50D2
  21+ 50D2              ; set starting of RAM based on computer model
  22+ 50D2                  IFDEF LM80C64K
  23+ 50D2 ~            SERBUF_START    equ     END_OF_FW       ; RAM starts here
  24+ 50D2                  ELSE
  25+ 50D2              SERBUF_START    equ     $8000           ; RAM starts here
  26+ 50D2                  ENDIF
  27+ 50D2
  28+ 50D2              ;-------------------------------------------------------------------------------
  29+ 50D2              serInPtr        equ     SERBUF_START + SER_BUFSIZE
  30+ 50D2              serRdPtr        equ     serInPtr+2
  31+ 50D2              serBufUsed      equ     serRdPtr+2
  32+ 50D2              basicStarted    equ     serBufUsed+1
  33+ 50D2              bufWrap         equ     (SERBUF_START + SER_BUFSIZE) & $FF
  34+ 50D2              TEMPSTACK       equ     CURPOS - 3      ; top of BASIC line input buffer so is "free ram" when BASIC resets
  35+ 50D2
  36+ 50D2              ; BASIC WORK SPACE LOCATIONS
  37+ 50D2              ; THE INTERPRETER ALLOCATES THE FOLLOWING RAM CELLS
  38+ 50D2              ; TO STORE IMPORTANT VALUES USED FOR SOME SPECIFIC FUNCTIONS:
  39+ 50D2              ; THEY CAN BE VECTOR (ADDRESSES) FUNCTIONS, SYSTEM DATAS (I.E. VARIABLES)
  40+ 50D2              ; AND SO ON. THE FIRST CELLS ARE FILLED WITH VALUES STORED INTO ROM AT $(INITAB) ADDRESS
  41+ 50D2              WRKSPC          equ     basicStarted+$01; (3) BASIC Work space
  42+ 50D2              NMIUSR          equ     WRKSPC+$03      ; (3) NMI exit point routine
  43+ 50D2              USR             equ     NMIUSR+$03      ; (3) "USR (x)" jump  <-- in (USR+$01)/(USR+$02) the user can store the address of a specific machine language routine
  44+ 50D2              OUTSUB          equ     USR+$03         ; (1) "out p,n"
  45+ 50D2              OTPORT          equ     OUTSUB+$01      ; (2) Port (p)
  46+ 50D2              DIVSUP          equ     OTPORT+$02      ; (1) Division support routine
  47+ 50D2              DIV1            equ     DIVSUP+$01      ; (4) <- Values
  48+ 50D2              DIV2            equ     DIV1+$04        ; (4) <-   to
  49+ 50D2              DIV3            equ     DIV2+$04        ; (3) <-   be
  50+ 50D2              DIV4            equ     DIV3+$03        ; (2) <-inserted
  51+ 50D2              SEED            equ     DIV4+$02        ; (35) Random number seed  <-- starting address of a seed table
  52+ 50D2              LSTRND          equ     SEED+$23        ; (4) Last random number
  53+ 50D2              INPSUB          equ     LSTRND+$04      ; (1) INP A,(x) Routine
  54+ 50D2              INPORT          equ     INPSUB+$01      ; (2) PORT (x)
  55+ 50D2              LWIDTH          equ     INPORT+$02      ; (1) Terminal width
  56+ 50D2              COMMAN          equ     LWIDTH+$01      ; (1) Width for commas
  57+ 50D2              NULFLG          equ     COMMAN+$01      ; (1) Null after input byte flag
  58+ 50D2              CTLOFG          equ     NULFLG+$01      ; (1) Control "O" flag
  59+ 50D2              CHKSUM          equ     CTLOFG+$01      ; (2) Array load/save check sum
  60+ 50D2              NMIFLG          equ     CHKSUM+$02      ; (1) Flag for NMI break routine
  61+ 50D2              BRKFLG          equ     NMIFLG+$01      ; (1) Break flag
  62+ 50D2              RINPUT          equ     BRKFLG+$01      ; (3) Input reflection
  63+ 50D2              STRSPC          equ     RINPUT+$03      ; (2) Pointer to bottom (start) of string space - default is 100 bytes below the top of memory
  64+ 50D2              LINEAT          equ     STRSPC+$02      ; (2) Current line number. -1 means "direct mode", while -2 means cold start.
  65+ 50D2              HLPLN           equ     LINEAT+$02      ; (2) Current line with errors
  66+ 50D2              KEYDEL          equ     HLPLN+$02       ; (1) delay before key auto-repeat starts
  67+ 50D2              AUTOKE          equ     KEYDEL+$01      ; (1) delay for key auto-repeat
  68+ 50D2              FNKEYS          equ     AUTOKE+$01      ; (128) default text of FN keys
  69+ 50D2              BASTXT          equ     FNKEYS+$80      ; (3) Pointer to start of BASIC program in memory
  70+ 50D2              ; - - - - - - - - - - - - - - - - - - -   the above are locations pre-filled by the firmware at startup
  71+ 50D2              BUFFER          equ     BASTXT+$03      ; (5) Input buffer
  72+ 50D2              STACK           equ     BUFFER+$05      ; (85) Initial stack
  73+ 50D2              CURPOS          equ     STACK+$55       ; (1) Character position on line
  74+ 50D2              LCRFLG          equ     CURPOS+$01      ; (1) Locate/Create flag for DIM statement
  75+ 50D2              TYPE            equ     LCRFLG+$01      ; (1) Data type flag: 0=numeric, non-zero=string
  76+ 50D2              DATFLG          equ     TYPE+$01        ; (1) Literal statement flag
  77+ 50D2              LSTRAM          equ     DATFLG+$01      ; (2) Last available RAM location usable by BASIC
  78+ 50D2              TMSTPT          equ     LSTRAM+$02      ; (2) Temporary string pointer
  79+ 50D2              TMSTPL          equ     TMSTPT+$02      ; (12) Temporary string pool
  80+ 50D2              TMPSTR          equ     TMSTPL+$0C      ; (4) Temporary string
  81+ 50D2              STRBOT          equ     TMPSTR+$04      ; (2) Bottom of string space
  82+ 50D2              CUROPR          equ     STRBOT+$02      ; (2) Current operator in EVAL
  83+ 50D2              LOOPST          equ     CUROPR+$02      ; (2) First statement of loop
  84+ 50D2              DATLIN          equ     LOOPST+$02      ; (2) Line of current DATA item
  85+ 50D2              FORFLG          equ     DATLIN+$02      ; (1) "FOR" loop flag
  86+ 50D2              LSTBIN          equ     FORFLG+$01      ; (1) Last byte entered
  87+ 50D2              READFG          equ     LSTBIN+$01      ; (1) Read/Input flag
  88+ 50D2              BRKLIN          equ     READFG+$01      ; (2) Line of break
  89+ 50D2              NXTOPR          equ     BRKLIN+$02      ; (2) Next operator in EVAL
  90+ 50D2              ERRLIN          equ     NXTOPR+$02      ; (2) Line of error
  91+ 50D2              CONTAD          equ     ERRLIN+$02      ; (2) Where to CONTinue
  92+ 50D2              TMRCNT          equ     CONTAD+$02      ; (4) TMR counter for 1/100 seconds
  93+ 50D2              CTC0IV          equ     TMRCNT+$04      ; (3) CTC0 interrupt vector
  94+ 50D2              CTC1IV          equ     CTC0IV+$03      ; (3) CTC1 interrupt vector
  95+ 50D2              CTC2IV          equ     CTC1IV+$03      ; (3) CTC2 interrupt vector
  96+ 50D2              CTC3IV          equ     CTC2IV+$03      ; (3) CTC3 interrupt vector
  97+ 50D2              ; - - - - - - - - - - - - - - - - - - -   VIDEO REGISTERS - FROM HERE...
  98+ 50D2              SCR_SIZE_W      equ     CTC3IV+$03      ; (1) screen width (it can be either 40 chars or 32 chars/bytes)
  99+ 50D2              SCR_SIZE_H      equ     SCR_SIZE_W+$01  ; (1) screen height (it can be 24/48/192: 24 for text, 48 for MC, 192 for graphics)
 100+ 50D2              SCR_MODE        equ     SCR_SIZE_H+$01  ; (1) screen mode (0=text, 1=G1, 2=G2, 3=MC, 4=ExG2)
 101+ 50D2              SCR_NAM_TB      equ     SCR_MODE+$02    ; (2) video name table address
 102+ 50D2              SCR_CURS_X      equ     SCR_NAM_TB+$02  ; (1) cursor X
 103+ 50D2              SCR_CURS_Y      equ     SCR_CURS_X+$01  ; (1) cursor Y
 104+ 50D2              SCR_CUR_NX      equ     SCR_CURS_Y+$01  ; (1) new cursor X position
 105+ 50D2              SCR_CUR_NY      equ     SCR_CUR_NX+$01  ; (1) new cursor Y position
 106+ 50D2              SCR_ORG_CHR     equ     SCR_CUR_NY+$01  ; (1) original char positioned under the cursor
 107+ 50D2              CRSR_STATE      equ     SCR_ORG_CHR+$01 ; (1) state of cursor (1=on, 0=off)
 108+ 50D2              LSTCSRSTA       equ     CRSR_STATE+$01  ; (1) last cursor state
 109+ 50D2              PRNTVIDEO       equ     LSTCSRSTA+$01   ; (1) print on video buffer (1=on / 0=off) set to off on graphic only modes
 110+ 50D2              CHR4VID         equ     PRNTVIDEO+$01   ; (1) char for video buffer
 111+ 50D2              FRGNDCLR        equ     CHR4VID+$01     ; (1) foreground color as set by SCREEN or COLOR commands
 112+ 50D2              BKGNDCLR        equ     FRGNDCLR+$01    ; (1) background color as set by SCREEN or COLOR commands
 113+ 50D2              TMPBFR1         equ     BKGNDCLR+$01    ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 114+ 50D2              TMPBFR2         equ     TMPBFR1+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 115+ 50D2              TMPBFR3         equ     TMPBFR2+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 116+ 50D2              TMPBFR4         equ     TMPBFR3+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 117+ 50D2              VIDEOBUFF       equ     TMPBFR4+$02     ; (40) buffer used for video scrolling and other purposes
 118+ 50D2              VIDTMP1         equ     VIDEOBUFF+$28   ; (2) temporary video word
 119+ 50D2              VIDTMP2         equ     VIDTMP1+$02     ; (2) temporary video word
 120+ 50D2              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO VPD OUT OF THIS RANGE,
 121+ 50D2                                                      ; OTHERWISE YOU WILL HAVE TO CHECK THE POINTER IN "CLR_RAM_REG" FUNCTION
 122+ 50D2              ; - - - - - - - - - - - - - - - - - - -   SOUND & KEYBOARD REGISTERS - FROM HERE...
 123+ 50D2              CHASNDDTN       equ     VIDTMP2+$02     ; (2) sound Ch.A duration (in 1/100s)
 124+ 50D2              CHBSNDDTN       equ     CHASNDDTN+$02   ; (2) sound Ch.B duration (in 1/100s)
 125+ 50D2              CHCSNDDTN       equ     CHBSNDDTN+$02   ; (2) sound Ch.C duration (in 1/100s)
 126+ 50D2              KBDNPT          equ     CHCSNDDTN+$02   ; (1) temp cell used to flag if input comes from keyboard
 127+ 50D2              KBTMP           equ     KBDNPT+$01      ; (1) temp cell used by keyboard scanner
 128+ 50D2              TMPKEYBFR       equ     KBTMP+$01       ; (1) temp buffer for last key pressed
 129+ 50D2              LASTKEYPRSD     equ     TMPKEYBFR+$01   ; (1) last key code pressed
 130+ 50D2              STATUSKEY       equ     LASTKEYPRSD+$01 ; (1) status key, used for auto-repeat
 131+ 50D2              KEYTMR          equ     STATUSKEY+$01   ; (2) timer used for auto-repeat key
 132+ 50D2              CONTROLKEYS     equ     KEYTMR+$02      ; (1) flags for control keys (bit#0=SHIFT; bit#1=CTRL; bit#2=C=)
 133+ 50D2              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO PSG OUT OF THIS RANGE,
 134+ 50D2                                                      ; OTHERWISE YOU WILL HAVE TO CHANGE THE POINTER IN "initPSG" FUNCTION
 135+ 50D2              SERIALS_EN      equ     CONTROLKEYS+$01 ; (1) serial ports status: bit 0 for Port1 (A), bit 1 for Port2 (B): 0=OFF, 1=ON
 136+ 50D2              SERABITS        equ     SERIALS_EN+$01  ; (1) serial port A data bits
 137+ 50D2              SERBBITS        equ     SERABITS+$01    ; (1) serial port B data bits
 138+ 50D2              DOS_EN          equ     SERBBITS+$01    ; (1) DOS enable/disable (1/0)
 139+ 50D2              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 140+ 50D2                                                      ; from here there are the RAM locations that
 141+ 50D2                                                      ; are saved during SAVE
 142+ 50D2              PROGND          equ     DOS_EN+$01      ; (2) End of program
 143+ 50D2              VAREND          equ     PROGND+$02      ; (2) End of variables
 144+ 50D2              ARREND          equ     VAREND+$02      ; (2) End of arrays
 145+ 50D2              NXTDAT          equ     ARREND+$02      ; (2) Next data item
 146+ 50D2              FNRGNM          equ     NXTDAT+$02      ; (2) Name of FN argument
 147+ 50D2              FNARG           equ     FNRGNM+$02      ; (4) FN argument value
 148+ 50D2              FPREG           equ     FNARG+$04       ; (3) Floating point register
 149+ 50D2              FPEXP           equ     FPREG+$03       ; (1) Floating point exponent
 150+ 50D2              SGNRES          equ     FPEXP+$01       ; (1) Sign of result
 151+ 50D2              PBUFF           equ     SGNRES+$01      ; (13) Number print buffer
 152+ 50D2              MULVAL          equ     PBUFF+$0D       ; (3) Multiplier
 153+ 50D2              PROGST          equ     MULVAL+$03      ; (100) Start of program text area
 154+ 50D2              STLOOK          equ     PROGST+$64      ; Start of memory test
 155+ 50D2
# file closed: ../include/workspace/workspace-r1.0.asm
  84  50D2
  85  50D2              ; END OF ASSEMBLY SOURCE
  86  50D2
  87  50D2
  88  50D2              ;-------------------------------------------------------------------------------
  89  50D2
# file closed: LM80C-firmware-r3.16.asm

Value    Label
------ - -----------------------------------------------------------
0x8216   CHCSNDDTN
0x8214   CHBSNDDTN
0x80A8   NMIFLG
0x4002   DV16_16_LP
0x3FFD X DIV_16_16
0x3FF1   DIV_16_8LP
0x3FE2   DIV_8_8LOOP
0x3FD2   EXMUL16
0x3FC9   MLP1
0x3FC2   MLP
0x3FA2 X TSTBIT
0x3F62   BINIT
0x3F75   CHKBIN
0x3F44   BITOUT2
0x3F40   BITOUT
0x3F32   ZEROSUP
0x3F2C X BIN2
0x3F14   NOSUB7
0x3F18   HEXIT
0x3EF4   HEXLP
0x3EF9   HEXLP1
0x3F21   HXERR
0x3F01   GETHEX
0x3EE4   ADD301
0x3ED4   ADD30
0x3EBE   HEX4
0x3EBC   HEX3
0x3EAD   HEX1
0x3EAF   HEX2
0x3E59   PRTEND
0x3E4D   PRTK1
0x3E4A   OPNQT1
0x3E32   CLSQT1
0x3E8E   CHKEY5
0x3E1A   PTCHR1
0x3E8B   CHKEY4
0x3E22   CLSQT
0x3DE5   PRTK3
0x3DFD   PRTCHR
0x3E34   OPNQT
0x3DE8   CNTLTK
0x3DD3   LDKEY
0x3E82   CHKEY2
0x3E4C   PRTCKEY
0x3E7D   CHKEY1
0x3DBC X PRTK2
0x3DBA   PRTK4
0x3DA6   CPKYEND
0x3D9E   CPKEY1
0x3D96   CPKEY3
0x3D8F   CPKEY2
0x3D7F   CPKEY
0x3D71   DECLN1
0x3E5B   SETREP
0x3D41   KEYCH
0x3DA8   LSTKEYS
0x3D1F   HLPERR
0x3CFD   DIRMOD
0x3CC4   EXNRM
0x3CB6   ENCHB
0x3C8B   SRLCNT
0x3C73   STRPAR
0x3C56   SETPAR2
0x3C47   BITS8
0x3C3C   BITS7
0x3C4B   SETPAR
0x3C32   BITS6
0x3C0F   SET_CTC
0x3CE1   CTC_CFG
0x3CEC   SCERR1
0x3BFE   SET_PT
0x3BE5   CKBPS
0x3CCB   SUP_BPS
0x3BD9   SETSER
0x3BCC   DEFSER
0x3B81   CNTSER3
0x3B64   CNTRX2
0x3B6F   CNTSER2
0x3B31   SERLED
0x3B2B   SRPT2
0x3B08   RPTRSSR
0x3AFB   RSTSERS
0x3B35   CNTSER
0x3AF7   CHKZSER
0x3AE8   SERVAR
0x3CF0   SCERR
0x81EC   SIOBFR
0x81EB   STPBT
0x81EA   PARBT
0x81E9   DATABT
0x81E7   BPS
0x81E6   PRTNUM
0x3AA2   RPTCVB2
0x3A99   RPTCVB1
0x3A8C   CNTVALY
0x3A5C   CNTCL7
0x3A38   CNTCL6
0x3A14   CNTCL5
0x39F2   CNTCL4
0x39CC   CNTCL3
0x39A8   CNTCL2
0x3A86   VALIDY
0x3984   CNTCL1
0x3A81   VALIDX
0x3955   PLTCRL
0x3946   DLSZ
0x395E   ENDCRL
0x3919   RPTCL1
0x3906   RPTCRL
0x3962   DRWCRL
0x81F0   DC
0x81EE   YI
0x81EC   XI
0x81EA   RADIUS
0x81E8   YC
0x81E6   XC
0x3895   DXGR
0x38BE   ENDDRAW
0x3865   CNTDRW
0x3849   RPTDRW
0x3846   STRE2
0x3839   ER2
0x3FD7   negHL
0x3816   Y1GR
0x37EC   X1GR
0x3FD4   absHL
0x3A91   CLRVDBF
0x81F2   DX
0x81F0   SY
0x81EE   SX
0x81EC   E2
0x81EA   ER
0x81E8   Y2
0x81E6   X2
0x81E0   Y1
0x81DE   X1
0x3FDE   DIV_8_8
0x3759   PXLSET
0x3735   CNTPLT1
0x3755   NOGD
0x3761   XY2HL
0x36D0   PNTEND
0x36DA   CTPOINT
0x3687   PAINT5
0x3656   PAINT3
0x3697   CHECKPY
0x3643   PAINT2
0x3714   CNTPLOT
0x3613   MNPAINT
0x3610   PAINT1
0x360F   PAINT11
0x3696   CHECKPA
0x3601   PAINT0
0x368E   EXITPAI
0x35F4   NXTLOOP
0x3692   EXITPA2
0x36EE   PNTRTN
0x3AA9   CLRPRM
0x81EA   ORGSP
0x81E9 X SPB
0x81E8 X SPA
0x81E6   PNT
0x3586   GPCPCH1
0x357B X GPCPCHR
0x3561   GPNTCO1
0x3557 X GPNTCOL
0x354C   RPGPNT
0x3537   GPNT
0x3522   CNTGPT2
0x35A3   CKCOL
0x81EC   TMPHL
0x81EA   NUMCHR
0x81E8   CHRPNT
0x81E6   TMPADR
0x81DE   MIXCOL
0x81E0   TMPCLR
0x81E4   GY
0x81E2   GX
0x3AC2   GMERR
0x34BC   CHKG2M
0x34B6   CHKCLR0
0x3481   RPTLDCL
0x3477   LOADCLR
0x348C   SETBRCL
0x34A5   MIXCLRS
0x3470   CLREX2
0x3467   CLRG2
0x345E   CLRG1
0x3454   CLRTXT
0x3457   CLRMC
0x34B2   CHKCLR1
0x33AC   CKMAGN
0x33F9   CHKSCAR
0x33A1 X SETVDP
0x33BA   SCVDP
0x337D   RPTPS
0x3378 X DIR_PAU
0x3352 X RECWRD
0x332E X ARET
0x3309   ATNTAB
0x32FF   ATN1
0x32B8   SINTAB
0x329C   SIN1
0x32B4   QUARTR
0x32B0   HALFPI
0x3249   RND2
0x322D   RND1
0x325A   RNDTAB
0x809B   LSTRND
0x3252   RESEED
0x8078   SEED
0x31D9   SUMLP
0x31D0   SMSER1
0x31A0   EXPTAB
0x3148   POWER2
0x312B   POWER1
0x310D   NEGAFT
0x30D8   EXPTEN
0x30D6   OUTEXP
0x30E5   NOENED
0x30BA   SUPTLZ
0x30C6   DOEBIT
0x3095   TRYAGN
0x3086   DIGTXT
0x30FB   POWERS
0x3075   MAKNUM
0x3050   GTSIXD
0x3059   INRNG
0x303B   SIXDIG
0x30E8   RNGTST
0x30E2   JSTZER
0x302C   SPCFST
0x8237   PBUFF
0x2FD6   MULTEN
0x2FCB   ENDCON
0x2FD5   SCALPL
0x2FBF   SCALMI
0x2FFF   EDIGIT
0x2FAA   EXPLP
0x2FBC   CONEXP
0x2FB8   DPOINT
0x2FDD   ADDIG
0x2F94   MANLP
0x2F8C   CNVNUM
0x2F7B   NOMLAD
0x2F6D   MLDBLP
0x2F45   DCBCDE
0x2F0E   CMPFP
0x2ED6   DETHLB
0x2ECF   INCHL
0x2E82   RETREL
0x2E62   MLSP10
0x2E55   OVTST1
0x2E5A   OVTST2
0x2E5B   OVTST3
0x2E07   RESDIV
0x806A   DIVSUP
0x2DF4   DIVLP
0x8076   DIV4
0x806B   DIV1
0x806F   DIV2
0x8073   DIV3
0x2DC1   DIV10
0x2D59   NOMADD
0x2D48   MUL8LP
0x2D6B   BYTSFT
0x2D3F   MULT8
0x8244   MULVAL
0x2E37   ADDEXP
0x2D1D   FPMULT
0x2D14   MULLN2
0x2FF4   RSCALE
0x31C1   SUMSER
0x2DCF   DVBCDE
0x2CCF   LOGTAB
0x2CCB   UNITY
0x2CB9   SHRLP
0x2CB6   SHRITE
0x2CA9   SCALLP
0x8236   SGNRES
0x2C7A   FPROND
0x2C69   RONDB
0x2C4D   NORMAL
0x2C49   SAVEXP
0x2C55   PNORM
0x2C30   CONPOS
0x2CBD   SHRT1
0x2C68   RONDUP
0x2C87   PLUCDE
0x2C22   MINCDE
0x2CA7   SCALE
0x2EDF   SIGNS
0x2BFC   NOSWAP
0x2BDF   SUBCDE
0x2BD9   SUBPHL
0x2BE2   FPADD
0x30F7   HALF
0x2BD0   ROUND
0x2BCD X ENDINK2
0x2BB2   CHKINK
0x2BAE   SRTINK
0x2BC4   ENDINK
0x2B9A   INKEY2
0x2B8B   CMP_A
0x2B39   NOS3
0x2B20   NOS2
0x2B0D   NOS1
0x2ADD   SNDOVR
0x2B30   WRTSND
0x2AA8   SND1
0x2A3A   RPVOLCG
0x2A46   VOLCH
0x299F   PKEPRMS
0x2989   SYSRET
0x297B   NOSYSPR
0x293D   NMIINT
0x2949   NMIVR1
0x2933   NMIEINT
0x292F   NMI2
0x293A   NMIDINT
0x290D   DISNMI
0x291E   NM1
0x8068   OTPORT
0x28D6   WAITLP
0x28D5   NOXOR
0x8067   OUTSUB
0x28DF   SETIO
0x809F   INPSUB
0x80A0   INPORT
0x289E   VAL2
0x28A1   VAL3
0x2894   VAL1
0x2C48   RESZER
0x285F   RSTSTR
0x28AA   MIDNUM
0x282B   LVINSTR
0x2835   CNTZIN
0x27D5   RP2INST
0x27FE   CNT1INS
0x27AE   RPTINST
0x2820   RZINSTR
0x81F4   DY
0x279D   EMPTINS
0x81EE   TF
0x81EC   TP
0x81EA   PT2
0x81E6   PT
0x81E4   ADRS2
0x81E2   LNS2
0x81E0   ADRS1
0x81DE   LNS1
0x2724   ALLFOL
0x271C   MID1
0x3F83   BINERR
0x271A   RIGHT1
0x28A5   LFRGNM
0x28F5   MAKINT
0x26F9 X GTFLNM
0x26EA   GETLEN
0x26D3   POPHL
0x26B4   GETSTR
0x26AB   TSALP
0x26A1   SSTSA
0x26BA   GSTRHL
0x260E   GRBARY
0x2645   SCNEND
0x25EE   GNXARY
0x261F   STRADD
0x25EF   ARRLP
0x25D9   SMPVAR
0x261C   STPOOL
0x25C8   GRBLP
0x25BA   GARBLP
0x25AB   TESTOS
0x258F   GRBDON
0x257E   PRSLP
0x2573   PRNUMS
0x2554   TSTOPL
0x2548   CRTSTE
0x2539   QTSTLP
0x2523   MKTMST
0x26AA   TOSTRA
0x2526   CRTMST
0x258D   TESTR
0x2712   TOPOOL
0x2504   STR1
0x252C   SVSTAD
0x24ED   CHEKFN
0x2465   PASSA
0x2E90   RETINT
0x25B7   GARBGE
0x2450   FRENUM
0x242F   ENDTMR
0x23FB   FNDELP
0x241A   ENDDIM
0x23D9   ZERARY
0x2F65   MLDEBC
0x23BB   DEFSIZ
0x23B3   CRARLP
0x2393   BSERR
0x23F6   FINDEL
0x237A   NXTARY
0x2398   CREARY
0x2366   FNDARY
0x233E   SCPTLP
0x231C   ZEROLP
0x232D   RETNUL
0x232A   RETADR
0x22EB   FNTHR
0x22F6   CFEVAL
0x22DD   FNDVAR
0x2D69   POPHRT
0x822E   FNARG
0x2338   SBSCPT
0x22C3   NSCFOR
0x2360   ARLDSV
0x22B3   NOTSTR
0x2298   ENDNAM
0x22A4   CHARTY
0x2297   SVNAM2
0x2280   GTFNAM
0x8193   LCRFLG
0x226D   DIMRET
0x2E8B   FLGREL
0x2E84   FLGDIF
0x2234   CMPSTR
0x26BB   GSTRDE
0x26B7   GSTRCU
0x224C   CMPRES
0x220A   CMPLG1
0x2208   CMPLOG
0x21F1   PXOR1
0x21E4 X PAND1
0x21E9   POR1
0x2455   ACPASS
0x2EBA   FPBCDE
0x21C9   CNTLGC
0x21AF   SGNEXP
0x21A6   GOFUNC
0x219E   FNVAL
0x215F   FRMEVL
0x2157   RETNUM
0x2EA2   INVSGN
0x2143   EVLPAR
0x216D   FNOFST
0x2497   DOFN
0x2256   EVNOT
0x214B   MINUS
0x3F58   BINTFP
0x3EE8   HEXTFP
0x2120   NOTAMP
0x215C   CONVAR
0x2EAA   STAKFP
0x20DE   STKTHS
0x266A   CONCAT
0x21F6   TSTRED
0x81AC   CUROPR
0x20B6   FOPRND
0x209A   RLTLP
0x208D   EVAL3
0x81B7   NXTOPR
0x208A   EVAL2
0x20F5   OPRND
0x2081   EVAL1
0x207A   OPNPAR
0x2070   TSTSTR
0x205C   KILFOR
0x2EC8   LOADFP
0x2BD3   ADDPHL
0x2EB7   PHLTFP
0x2024   NEXT1
0x2016   FANDT
0x1FED   EXTIG
0x1FD2   MORDT
0x2F80   ASCTFP
0x1FC6   LTSTND
0x2536   DTSTR
0x1FAC   ITMSEP
0x1FAF   STRENT
0x1FBB   INPBIN
0x1FFD   FDTLP
0x1F91   ANTVLU
0x1F65   NEDMOR
0x1F69   GTVLUS
0x1F5D   NXTITM
0x1F40   NOPMPT
0x24DF   IDTEST
0x81B4   READFG
0x1F15   BADINP
0x1F03   REDO
0x1EF4   SPCLP
0x1EED   DOSPC
0x28EF   FNDNUM
0x1ECD   ZONELP
0x1EBA   CNTEND
0x2577   PRS1
0x2532   CRTST
0x301E   NUMASC
0x1E97   PRNTST
0x1EFC   NEXITM
0x1EBF   DOCOM
0x1ED8   DOTAB
0x1E50   PRNTLP
0x1E49   MRPRNT
0x1E32   IF0
0x1E3B   IF1
0x1E29   IFGO
0x1E0D   ONGOLP
0x1E0C   ONGO
0x28F2   GETINT
0x2ED1   FPTHL
0x2ED4   DETHL4
0x250E   SAVSTR
0x26D5   BAKTMP
0x81A6   TMPSTR
0x1DED   MVSTPT
0x1DE5   CRESTR
0x8232   FPREG
0x1DBE   LETSTR
0x1DF6   LETNUM
0x2071   CHKTYP
0x207E   EVAL
0x8194   TYPE
0x227B   GETVAR
0x1D95   NXTSTT
0x1D92   NXTSTL
0x1D8B   NXTDTA
0x1D86   RETLIN
0x1D48   RUNLIN
0x1D01   STORED
0x1CB7   GTLNLP
0x1CB4   GETLN
0x2EF4   CMPNUM
0x2F21   FPINT
0x8235   FPEXP
0x1C93   DEPINT
0x1C90 X POSINT
0x2AE3   NOISUP
0x1C8D   FPSINT
0x1C85   CHKLTR
0x80A6   CHKSUM
0x1C78 X ACCSUM
0x1C59   ERRINT
0x81B9   ERRLIN
0x1C48   NOLIN
0x1C32   INPBRK
0x80A9   BRKFLG
0x1C1C   STALL
0x1C26   BRK
0x822A   NXTDAT
0x1C09   UPDATA
0x1C08   RESTNL
0x1BCB   ONJMP
0x1BCA   IFJMP
0x1C35   ENDPRG
0x1BA3   RUNCNT
0x1B9F   PUTFID
0x2E79   TSTSGN
0x1B96   SAVSTP
0x2EC5   BCDEFP
0x206C   GETNUM
0x206F   TSTNUM
0x1B5A   FORFND
0x1B3E   FORSLP
0x81AE   LOOPST
0x1B23   CNTWTSP
0x1B17   WTSPC
0x1B0F   LVSRLN
0x1B04   SRCLN1
0x1AE1   OUTWRD
0x1AEF   NXTLN
0x1AC8   LSTLP3
0x1AC5   LSTLP2
0x1AB9   LST07
0x1AB6   LST08
0x1B11   TSTSPC
0x1C0E   TSTBRK
0x3675   PAINT4
0x1A8B   LST02
0x1A88   LST05
0x1A4B   LST06
0x1A74   LST03
0x1A4F   LSTNOT
0x1A30   LST01H
0x1A94   LISTLP
0x1B03   SRCLN
0x1AFD   SRCHLIN
0x1A2D   LST01
0x1A5C   LSTALL
0x332F   GETINP
0x3F88   MONOUT
0x19E0   SND2VID
0x19CD   INCLEN
0x8192   CURPOS
0x80A2   LWIDTH
0x19D1   DINPOS
0x25A9   POPAF
0x19A2   CHKSYN
0x1993   OUTIT
0x1996   OUTNBS
0x3FA9   OUTNCR
0x197F   PUTBUF
0x1EA6   ENDINP
0x1979   GMNCR
0x1984   PUTCTL
0x1944   PROCES
0x19EE   CLOTST
0x191C   KILIN
0x1911   DELCHR
0x192B   MORINP
0x1919   OTKLN
0x1905   ECHDEL
0x80A4   NULFLG
0x18F1   DODEL
0x18D8   NXTCHR
0x18D2   TSTREM
0x18CF   SETLIT
0x18B1   NOCHNG
0x18A8   NOSPC
0x18B9   MATCH
0x1897   NXTBYT
0x1887   GETNXT
0x1885   SEARCH
0x18BD   RETNAD
0x186C   FNDWRD
0x18E8   ENDBUF
0x18E1   CPYLIT
0x18C1   MOVDIR
0x1842   CRNCLP
0x8195   DATFLG
0x80AA   RINPUT
0x1825   DOAGN
0x822C   FNRGNM
0x81B2   FORFLG
0x81BB   CONTAD
0x8198   TMSTPT
0x819A   TMSTPL
0x8226   VAREND
0x81AA   STRBOT
0x81B5   BRKLIN
0x17F6   INTVAR
0x17C9   SRCHLP
0x8135   BASTXT
0x17BA   FNDEND
0x17AE   PTRLP
0x17F2   RUNFST
0x17A1   MOVBUF
0x17A9   SETPTR
0x1773   SFTPRG
0x8224   PROGND
0x1782   INEWLN
0x1D62   ULERR
0x176B   LINFND
0x17C6   SRCHLN
0x81B3   LSTBIN
0x1BC3   EXCUTE
0x1839   CRUNCH
0x1922   GETLIN
0x1727   GETCMD
0x1719   POPNOK
0x300B   LINEIN
0x80B1   HLPLN
0x1715   PTLN
0x16F8   ERRIN
0x19AD   OUTC
0x1E9E   STTLIN
0x80A5   CTLOFG
0x16D2   TMERR
0x16CF   OVERR
0x16CC   UFERR
0x16C9   DDERR
0x16C6   NFERR
0x16C3   DZERR
0x81B0   DATLIN
0x16BA   DATSNR
0x16B8   LDG1ND
0x16A7   LDG1
0x169A   EXITGM
0x16D4   ERROR
0x1695   OMERR
0x8228   ARREND
0x167D   CHKSTK
0x1672   MOVLP
0x166F   MOVSTR
0x1686   ENFMEM
0x166C   MOVUP
0x1663   INDFND
0x164D   LOKFOR
0x1649   BAKSTK
0x1643   BRKMSG
0x163E   OKMSG
0x163D   ZERBYT
0x1639   INMSG
0x1632   ERRMSG
0x15B0 X DEFFNKS
0x15AE   AUTORP
0x1922   TTYLIN
0x1CAE   FCERR
0x21C2   POR
0x21C7   PXOR
0x21BF   PAND
0x2C33   BNORM
0x311B   POWER
0x2D70   DINT
0x2D78   MOD
0x2DCD   DIV
0x2D1B   MULT
0x2BDD   PSUB
0x2FFA   PADD
0x153B   PRITAB
0x00E9   ZLEFT
0x00E1   ZINSTR
0x00E0   ZPOINT
0x00CA   ZSGN
0x00C9   ZLTH
0x00C8   ZEQUAL
0x00C7   ZGTR
0x00C6   ZOR
0x00C2 X ZDINT
0x00C1 X ZMOD
0x00C0 X ZDIV
0x00BF X ZTIMES
0x00BE   ZMINUS
0x00BD   ZPLUS
0x00BC   ZSTEP
0x00BB   ZNOT
0x00BA   ZTHEN
0x00B9   ZSPC
0x00B8   ZFN
0x00B7   ZTO
0x00B6   ZTAB
0x00B5   ZNEW
0x00AF   ZPRINT
0x00AE   ZELSE
0x008E   ZREM
0x008C   ZGOSUB
0x0088   ZGOTO
0x0083   ZDATA
0x0081   ZFOR
0x0080   ZEND
0x17E6   NEW
0x3E92   SAVE
0x3E91   LOAD
0x1CD8   CLEAR
0x1A01   LIST
0x1C5F   CONT
0x1E4D   PRINT
0x3F8B   RESET
0x295D   SYS
0x3345   WIDTH
0x34C5   GPRINT
0x2903   NMI
0x3D24   KEY
0x3331   CLS
0x3D09   HELP
0x3AC7   SERIAL
0x35B6   PAINT
0x38C2   CIRCLE
0x378C   DRAW
0x36F9   PLOT
0x3409   COLOR
0x336F   PAUSE
0x2A18   VOLUME
0x2A51   SOUND
0x29C5   LOCATE
0x2B45   VREG
0x29F7   SREG
0x29BA   VPOKE
0x3358   DOKE
0x29B5   POKE
0x246A   DEF
0x28C1   WAIT
0x3E94   ERASE
0x3E93   FILES
0x1DFD   ON
0x28BB   POUT
0x1C2B   STOP
0x1D8E   REM
0x1D67   RETURN
0x1D38   GOSUB
0x1BF3   RESTOR
0x1E1B   IF
0x1D24   RUN
0x1D49   GOTO
0x1DA3   LET
0x1F58   READ
0x2276   DIM
0x1F26   INPUT
0x1D8C   DATA
0x2021   NEXT
0x1B2A   FOR
0x1C2D   PEND
0x14CF   WORDTB
0x1342   WORDS
0x2846   MID
0x283C   RIGHT
0x2716   LEFT
0x3F26   BIN
0x3E95   HEX
0x2706   CHR
0x26F5   ASC
0x2876   VAL
0x24FE   STR
0x3B6B   RXEND
0x26E6   LEN
0x2746   INSTR
0x36A6   POINT
0x2B80   INKEY
0x2B6C   SSTAT
0x2B61   VSTAT
0x2992   VPEEK
0x334D   DEEK
0x298B   PEEK
0x32E2   ATN
0x32CD   TAN
0x338E   SCREEN
0x326C   SIN
0x3266   COS
0x3160   EXP
0x2CDC   LOG
0x31F1   RND
0x3112   SQR
0x2462   POS
0x28AF   INP
0x2434   FRE
0x81E8   PT1
0x8064   USR
0x2E9E   ABS_
0x2F4C   INT
0x241E   TMR
0x2E88   SGN
0x12FE   FNCTAB
0x171A   PRNTOK
0x3D31   RESFN
0x128F   BRKRET
0x813D   STACK
0x12A4   BFREE
0x3013   PRNTHL
0x129B   BLNSPC
0x17E7   CLRPTR
0x80AD   STRSPC
0x8196   LSTRAM
0x1258   NODOS
0x199C   CPDEHL
0x16C0   SNERR
0x1CB3   ATOH
0x1241   SETTOP
0x121D   MLOOP
0x82AB   STLOOK
0x122F   TSTMEM
0x1BE3   GETCHR
0x1829   PROMPT
0x2574   PRS
0x12F3   MEMMSG
0x1207   MSIZE
0x121A   MNOASK
0x2A5F   CTSNDC
0x8247   PROGST
0x8138   BUFFER
0x1EB0   PRNTCRLF
0x180C   CLREG
0x1AD7   FNDTOK
0x1632   INITBE
0x1559   INITAB
0x11EC   INIT
0x805E   WRKSPC
0x2456   ABPASS
0x1E93   PRNTNB
0x1C99   DEINT
0x11E5   CSTART
0x128C   WARMST
0x11DE   STARTB
0x1028 X ERRORS
0x11CE   HPMSG
0x1026 X HPPTR
0x11B8   SOMSG
0x119F   SAMSG
0x1022 X SAPTR
0x118A   SCMSG
0x1020 X SCPTR
0x101E X GMPRT
0x116E   BNMSG
0x101C X BNPTR
0x1163   HXMSG
0x101A X HXPTR
0x1153   MOMSG
0x1018 X MOPTR
0x3ECB   BYT2ASC
0x113D   UFMSG
0x1016 X UFPTR
0x112E   CNMSG
0x1014 X CNPTR
0x1113   STMSG
0x1012 X STPTR
0x1024 X SOPTR
0x1103   LSMSG
0x1010 X LSPTR
0x10EF   OSMSG
0x100E X OSPTR
0x10E0   TMMSG
0x100C X TMPTR
0x10D1   IDMSG
0x100A X IDPTR
0x10C0   DZMSG
0x1008 X DZPTR
0x10AB   DDMSG
0x1006 X DDPTR
0x109D   BSMSG
0x1004 X BSPTR
0x108E   ULMSG
0x3E85   CHKEY3
0x1002 X ULPTR
0x1080   OMMSG
0x1000 X OMPTR
0x1077   OVMSG
0x0FFE X OVPTR
0x1061   FCMSG
0x0FFC X FCPTR
0x1055   ODMSG
0x0FFA X ODPTR
0x1040   RGMSG
0x0FF8 X RGPTR
0x1039   SNMSG
0x0FF6 X SNPTR
0x1028   NFMSG
0x0FF4 X NFPTR
0x0FF4   ERRTBL
0x0032   HP
0x0030   SO
0x002E   SA
0x002C   SC
0x002A   GM
0x0028   BN
0x0026 X HX
0x0024   MO
0x0022   UF
0x0020   CN
0x001E   ST
0x1EF2   ASPCS
0x001C   LS
0x001A   OS
0x0018   TM
0x0016   ID
0x0014   DZ
0x0012   DD
0x0010   BS
0x000E   UL
0x000C   OM
0x000A   OV
0x0008   FC
0x0006   OD
0x0004   RG
0x0002   SN
0x0000   NF
0x007F   DEL
0x0020   SPC
0x001B   ESC
0x0015   CTRLU
0x0013   CTRLS
0x0012   CTRLR
0x0011   CTRLQ
0x000F   CTRLO
0x0007   CTRLG
0x0ECC   CNTFNK
0x0EDF   PRNTFNK
0x0ED2   PUTCHRBUF1
0x0EB8   LDFNKEYCHR
0x80B5   FNKEYS
0x80AF   LINEAT
0x12B2   SIGNON
0x0E9F X LVKBRDCHK
0x0E98   PNT2VD
0x0E8B   PUTCHRBUF
0x0E79   SNDKEYTOBFR
0x0EA0   PRNTFNKEY
0x0E71   CHKFNK
0x0EEC   FNKEYSORD
0x0E6B   CNTKBCK
0x0003   CTRLC
0x80B4   AUTOKE
0x2C36   BNRMLP
0x0E58   SENDKEY
0x0E29   SETNEWAUTO
0x0E9B   LVKBRDCHK2
0x80B3   KEYDEL
0x0E39   CHKAUTO
0x821D   KEYTMR
0x0E4B   NEWKEY
0x0F74   KBMAP_ALT
0x0FB4   KBMAP_CTRL
0x0DF0   CHKALT
0x0DF7   LOADMAP
0x0F34   KBMAP_SFT
0x0DE7   CHKCTRL
0x0EF4   KBMAP
0x0DD3   CHKLN
0x821C   STATUSKEY
0x821B   LASTKEYPRSD
0x0DBB   ENDCTRLCK
0x0DB5   TESTCTRL
0x0DD1   FINDKEY
0x0DA8   TESTALT
0x8219   KBTMP
0x0DBF   NOKEYPRSD
0x0D79   RPTKBDRD
0x0D75   CHECKKBD
0x0D67   CHECKCTRL
0x821F   CONTROLKEYS
0x0D59   CHECKALT
0x0D19   CNTCHKSND
0x0CDE   CHKSNDCH
0x0CAC   RPTWLCMBP
0x0CC2   NOBPDAT
0x0CA9   SENDSND
0x0CBA   WLCBPDAT
0x0CCF   WRTSNDREG
0x0CCA   SETSNDREG
0x0C90   SNDREGCFG
0x0C7C   CLRPSGREGS
0x0C78   EMPTSNDBFR
0x0B2A X VDPMODESETEX2
0x0B22 X VDPMODESETMC
0x0B1A X VDPMODESET2
0x2533   QTSTR
0x0B12 X VDPMODESET1
0x0B00   SENDCHRPTRNS
0x4812   CHRST88
0x0AFC   NXTCHAR
0x4012   CHRST68
0x0ADF   LDREGVLS
0x0B0A   VDPMODESET
0x0AC8   RSTVDPRAMREG
0x8212   CHASNDDTN
0x0AB9   EMPTVRM
0x0A4D X CNTNULL2
0x0A40   RPTNLLSRC2
0x3FBA   MUL16
0x0A1B   ADDNEWLINE
0x09E8   SNDCHRTOBFR
0x09CF   CNTNULL
0x09BF   RPTNLLSRC
0x0A07   PRNTRETURN
0x81E4   TMPBFR4
0x81E2   TMPBFR3
0x81E0   SRTTXT
0x81E0   TMPBFR2
0x0995   RPTEMPTYROW
0x097A   WRITEBUF
0x0951   LOADNEXTCOL
0x81E6   VIDEOBUFF
0x093F   SCROLLNXTRW
0x8210   VIDTMP2
0x820E   VIDTMP1
0x091D   EXITCURSOR_ON
0x0907   EXITCURSORDOWN
0x08E7   EXITCURSORRGHT
0x08E1   CONTCRSRGT
0x08CE   CHCKYPOS2
0x08B3   EXITCURSORUP
0x088A   CHKYPOS
0x0877   EXITCURSORLEFT
0x0874   CONTCRSLFT
0x0863   CHCKYPOS
0x0879   MVCRS2LFT
0x0830 X ENDINSRT
0x082B   NXTINST
0x3FAF   CMP16
0x081A   CHKHL
0x81E2   ENDTXT
0x0A28   ENDOFLN
0x81DE   CUR_POS
0x07F8   PUTCRSCHR
0x0926   SCROLLUP
0x07B7   SETCRSRY
0x07B8   SETCSRCOORDS
0x07CA   EXITCHAR2VID
0x078E   NXTCPCK
0x0781   RPTCPCK
0x07D7   PLACEHOLDER
0x000A   LF
0x07FC   INSERTKEY
0x001A   INSRT
0x08EA   CURSORDOWN
0x001F   CRSDN
0x08B5   CURSORRIGHT
0x001D   CRSRGT
0x089C   CURSORUP
0x001E   CRSUP
0x0850   CURSORLEFT
0x001C   CRSLFT
0x083D   BACKSPACE
0x3426   CNTCKCL
0x0008   BKSP
0x09A1   CRGRETURN
0x000C   CS
0x0019   HOME
0x0750   CHRTBL
0x3FEE   DIV_16_8
0x073F   HL2XY
0x0A4E   POS_TB_CRS_32
0x0731   CONT_POS_CURS
0x0A7E   POS_TB_CRS_40
0x81D9   LSTCSRSTA
0x06E9   MOVSHOWCRS
0x06FE   NEWCRSRCOORD
0x0713   RSTCHRCRS
0x071C   LOAD_CRSR_POS
0x06D2   READ_VSTAT
0x06C7   WRITE_VREG
0x06B2   WRITE_VIDEO_LOC
0x069D   READ_VIDEO_LOC
0x06E3   MOVCRS
0x81D5   SCR_CUR_NX
0x0000   NLLCR
0x81D6   SCR_CUR_NY
0x0693   ATHOME
0x06D9   POS_CURSOR
0x0686   CLEARVIDBUF
0x0673   RPTFLL1
0x0660   SNDCLRSET
0x065C   STARTEMPTY
0x0626   CLRG2PTNTBL
0x060B   RPTEMPTYBUF
0x0605   LDCOLSTOEMPTY
0x0645   EMPTYMC
0x0614   EMPTYG2
0x05E9   LVCKSHF
0x0D24   READKBLN
0x05DB X CHECKSHIFT
0x05CC   SNDLOGPT
0x2C93   COMPL
0x5012   LOGOFONT
0x0CA6   NOBEEP
0x0CA0   WLCMBEEP
0x0597   RPT100
0x05AD   BEEPOFF
0x05A1   SETBEEP
0x056D   DEC_D
0x8223   DOS_EN
0x81DE   TMPBFR1
0x055C   RPT104
0x05B5   LOADLOGOCHRS
0x0554   RPT103
0x0B32   LM80CLOGO
0x053E   RPT102
0x0C83   RSTPSG
0x053B   RPT101
0x05D6   CLRTABLE
0x0589   ERASECLRTBL
0x066A   SETNAMETABLE
0x0AD5   SET_GFX_MODE2
0x81D7   SCR_ORG_CHR
0x05EB   EMPTYVIDBUF
0x0476   LDCLRTBMD1
0x81DC   FRGNDCLR
0x067D   SETVDPADRS
0x0507   ENDVDPSET
0x81D1   SCR_NAM_TB
0x80A3   COMMAN
0x81CE   SCR_SIZE_H
0x81CD   SCR_SIZE_W
0x81DD   BKGNDCLR
0x81D4   SCR_CURS_Y
0x04FE   LDCLRTBEX2
0x81D3   SCR_CURS_X
0x0AE9   LOADCHARSET
0x0414 X TXTMD
0x04C4   EXG2MD
0x04A1   MCMD
0x047F   G2MD
0x043E   G1MD
0x81CF   SCR_MODE
0x0AC2   CLR_RAM_REG
0x0ACD   SET_GFX_MODE
0x0AAE   EMPTY_VRAM
0x0385   RESTMR
0x038A   CTCCONF
0x035C X SIO_B_SETS
0x0356   SIO_A_SETS
0x034B   COUNTER
0x0349   DEC_E
0x0345   LEDLIGHT
0x11DB   WARM
0x11D8   COLD
0x091F   CURSOR_OFF
0x0321   ECHO_CHAR
0x0314   CHECKWARM
0x02FD   CORW
0x090A   CURSOR_ON
0x03D2   MSGTXT2
0x0309   COLDSTART
0x805D   basicStarted
0x0396   MSGTXT1
0x81DA   PRNTVIDEO
0x3F9A   INITST
0x03EF   initVDP
0x0512   SHOW_LOGO
0x0C72   initPSG
0x0360   initCTC
0x033B   HELLOWRLD
0x818F   TEMPSTACK
0x0D39   KEYBOARD
0x0CD4   MNGSNDS
0x07D8   FLASHCURSOR
0x029C   CHKCRSR
0x0296   INCTMR3
0x81BD   TMRCNT
0x028D   CH3_TIMER
0x027F   RAWPRINT
0x026B   EXTXA
0x026E   TX_EMP
0x0266   TXA_EXIT
0x0257   CNTTXA
0x0249   RXA_EXIT
0x0238   NOTRDWRAP
0x805A   serRdPtr
0x8000   SERBUF_START
0x020B   NOTWRAP
0x0058   bufWrap
0x8058   serInPtr
0x01FF   NOTFULL
0x805C   serBufUsed
0x01E2   SIO_B_EI
0x01E8   SIO_RXEN
0x01DA   SIO_A_EI
0x01D0   SIO_RXDI
0x01B0 X B_RTS_ON
0x01B6   SIO_RTS_ON
0x01A8   A_RTS_ON
0x8222   SERBBITS
0x019C   SIO_RTS_OFF
0x8221   SERABITS
0x0180   EMPTYCHBBFR
0x01CA   SIO_B_DI
0x0196   B_RTS_OFF
0x3CF5   SOERR
0x015C   CHABFREMPTY
0x014E   EMPTYCHABFR
0x8220   SERIALS_EN
0x01C2   SIO_A_DI
0x1179   GMMSG
0x076E   CHAR2VID
0x81D8   CRSR_STATE
0x8218   KBDNPT
0x0120   CNTRXCHA
0x000D   CR
0x81DB   CHR4VID
0x0130   LVRXCHA
0x01F4   CHARINTOBFR
0x821A   TMPKEYBFR
0x018E   A_RTS_OFF
0x00EC   FMVEREND
0x00D0 X FWVER
0x8061   NMIUSR
0x81CA   CTC3IV
0x81C7   CTC2IV
0x81C4   CTC1IV
0x81C1   CTC0IV
0x027A   CKINCHAR
0x0018 X RST18
0x0223   RXA
0x0010 X RST10
0x0135   SPEC_RXA_CNDT
0x0100   RX_CHA_AVAIL
0x024D   TXA
0x0008 X RST08
0x0167   SPEC_RXB_CNDT
0x0164   RX_CHB_AVAIL
0x02B0   INIT_HW
0x0000 X RST00
0x0005   SER_EMPTYSIZE
0x0050   SER_FULLSIZE
0x0058   SER_BUFSIZE
0x0041   PSG_DAT
0x0040   PSG_REG
0x0032   VDP_SET
0x0030   VDP_DAT
0x0021   SIO_DB
0x0020   SIO_DA
0x0023   SIO_CB
0x0022   SIO_CA
0x0013   CTC_CH3
0x0012   CTC_CH2
0x0011   CTC_CH1
0x0010   CTC_CH0
0x0003   PIO_CB
0x0002 X PIO_CA
0x0001   PIO_DB
0x0000 X PIO_DA
