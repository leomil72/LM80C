                        ; --------------------------------------
                        ; zasm: assemble "LM80C-firmware-r315.asm"
                        ; date: 2020-12-30 17:56:18
                        ; --------------------------------------


                        ; ------------------------------------------------------------------------------
                        ; LM80C - FIRMWARE - R3.15
                        ; ------------------------------------------------------------------------------
                        ; The following code is intended to be used with LM80C Z80-based computer
                        ; designed by Leonardo Miliani. More info at
                        ; www DOT leonardomiliani DOT com
                        ; ------------------------------------------------------------------------------
                        ; Coding/Editing/Compiling:
                        ; Original init code for MC68B05 by Grant Searle
                        ; Original SIO/CTC/PIO init code by Mario Blunk
                        ; NASCOM BASIC originally modified by Gran Searle
                        ; Code modified and adapted for LM80C by Leonardo Miliani
                        ;
                        ; Edited with Atom Editor
                        ;
                        ; Compiled with ZASM assembler 4.2.4
                        ; https://k1.spdns.de/Develop/Projects/zasm-4.0/Distributions/
                        ; ------------------------------------------------------------------------------
                        ; Copyright notes:
                        ; Parts of the code (c) Grant Searle - free for non commercial use
                        ; Please include this advice and the note to the attribution of the original
                        ; version to Grant Searle if you intend to redistribuite it
                        ; http://searle.hostei.com/grant/index.html
                        ; eMail: home.micros01@btinternet.com
                        ;
                        ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ; Parts of the code (c) Mario Blunk
                        ; http://www.trainÂ­z.de
                        ;
                        ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                        ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                        ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                        ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                        ; the original ROM code (checksum A934H). PA
                        ;
                        ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ; The following code is intended to be used with LM80C Z80-based computer
                        ; designed by Leonardo Miliani. Code and computer schematics are released under
                        ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
                        ; kind of warranty: you can use them at your own risk.
                        ; You are free to use them for any non-commercial use: you are only asked to
                        ; maintain the copyright notices, include this advice and the note to the 
                        ; attribution of the original version to Leonardo Miliani, if you intend to
                        ; redistribuite them.
                        ; https://www.leonardomiliani.com
                        ; 
                        ; Please support me by visiting the following links:
                        ; Main project page: https://www.leonardomiliani.com
                        ; Schematics and code: https://github.com/leomil72/LM80C
                        ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
                        ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
                        ; ------------------------------------------------------------------------------
                        
                        
                        ; ------------------------------------------------------------------------------
                        ; this line instructs the assembler to prepare a file for a ROM target
                        ; meaning that blank cells will be filled up with $FF
                        #target rom
                        
                        ; this line instructs the assembler to compile taking account that code
                        ; starts at $0000 (the address reached by Z80 upon reset)
0000:                   #code BOOT, $0000
                        
                        ; ------------------------------------------------------------------------------
                        ; include the latest version of the bootloader: this sets up the address aliases
                        ; configure the hardware, checks if warm or cold startup and loads the BASIC interpreter
                        #include "../include/bootloader/bootloader-r315.asm"
                        ; ------------------------------------------------------------------------------
                        ; LM80C - BOOTLOADER - R3.15
                        ; ------------------------------------------------------------------------------
                        ; The following code is intended to be used with LM80C Z80-based computer
                        ; designed by Leonardo Miliani. Code and computer schematics are released under
                        ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
                        ; kind of warranty: you can use them at your own risk.
                        ; You are free to use them for any non-commercial use: you are only asked to
                        ; maintain the copyright notices, include this advice and the note to the 
                        ; attribution of the original version to Leonardo Miliani, if you intend to
                        ; redistribuite them.
                        ; https://www.leonardomiliani.com
                        ; 
                        ; Please support me by visiting the following links:
                        ; Main project page: https://www.leonardomiliani.com
                        ; Schematics and code: https://github.com/leomil72/LM80C
                        ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
                        ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
                        ; ------------------------------------------------------------------------------
                        
                        ; ADDRESS DECODING (bits A6/A5/A4)
                        ; 0000xxxx : PIO
                        ; 0001xxxx : CTC
                        ; 0010xxxx : SIO
                        ; 0011xxxx : VDP
                        ; 0100xxxx : PSG
                        
                        ; label defining for PIO (Parallel Input/Output)
0000:                   PIO_DA          equ %00000000
0001:                   PIO_DB          equ %00000001
0002:                   PIO_CA          equ %00000010
0003:                   PIO_CB          equ %00000011
                        
                        ; label defining for CTC (Counter Timer Circuit)
0010:                   CTC_CH0         equ %00010000
0011:                   CTC_CH1         equ %00010001
0012:                   CTC_CH2         equ %00010010
0013:                   CTC_CH3         equ %00010011
                        
                        ;label defining for SIO (Serial Input/Output)
0022:                   SIO_CA          equ %00100010
0023:                   SIO_CB          equ %00100011
0020:                   SIO_DA          equ %00100000
0021:                   SIO_DB          equ %00100001
                        
                        ;label defining for VDP (Video Display Processor)
0030:                   VDP_DAT         equ %00110000
0032:                   VDP_SET         equ %00110010
                        
                        ; label defining for PSG (Programmable Sound Generator)
0040:                   PSG_REG         equ %01000000
0041:                   PSG_DAT         equ %01000001
                        
                        ; Interrupt-driven serial I/O interface lead by the Z80 SIO to run modified
                        ; NASCOM Basic 4.7 - Full input buffering with incoming data hardware handshaking
                        ; Handshake shows full before the buffer is totally filled to allow run-on from the sender
                        
0058:                   SER_BUFSIZE     equ     $58
0050:                   SER_FULLSIZE    equ     $50
0005:                   SER_EMPTYSIZE   equ     $05
                        
8000:                   SERBUF_START    equ     $8000           ; RAM starts here
8058:                   serInPtr        equ     SERBUF_START + SER_BUFSIZE
805A:                   serRdPtr        equ     serInPtr+2
805C:                   serBufUsed      equ     serRdPtr+2
805D:                   basicStarted    equ     serBufUsed+1
0058:                   bufWrap         equ     (SERBUF_START + SER_BUFSIZE) & $FF
818D:                   TEMPSTACK       equ     CURPOS - 3      ; top of BASIC line input buffer so is "free ram" when BASIC resets
                        
                        ;------------------------------------------------------------------------------
                        ; BASE MEMORY - RESET LOCATION - $0000
                        ; the CPU jumps to 0000h after a reset
                                        org     $0000
0000: F3       [ 4]     RST00:          di                      ; be sure that INTs are disabled
0001: C35A02   [14]                     jp      INIT_HW         ; jump to system initialization
                        
                        ;------------------------------------------------------------------------------
                        ; send a character over serial
0004: FFFFFFFF                          org     $0008
0008: C3F701   [10]     RST08:          jp      TXA
                        
                        ;------------------------------------------------------------------------------
                        ; interrupt vector when SIO has a char available in its buffer
000B: FF                                org     $000C
000C: 0001                              defw    RX_CHA_AVAIL
                        
                        ;------------------------------------------------------------------------------
                        ; interrupt vector for SIO special conditions (i.e. buf overrun)
                                        org     $000E
000E: 9B01                              defw    SPEC_RX_CONDITON
                        
                        ;------------------------------------------------------------------------------
                        ; receive a character over serial
                                        org     $0010
0010: C3CD01   [10]     RST10:          jp      RXA
                        
                        ;------------------------------------------------------------------------------
                        ; check serial status
                        
0013: FFFFFFFF                          org     $0018
0017: FF                
0018: C32402   [10]     RST18:          jp      CKINCHAR
                        
                        ;------------------------------------------------------------------------------
                        ; interrupt vectors for CTC 
001B: FFFFFFFF                          org     $0040               ; for CH0 Timer - unused
001F: FF...             
0040: BF81                              defw    CTC0IV
                                        
                                        org     $0042               ; for CH1 Timer - unused
0042: C281                              defw    CTC1IV
                                        
                                        org     $0044               ; for CH2 timer - unused
0044: C581                              defw    CTC2IV
                                        
                                        org     $0046               ; for CH3 Timer - used for 100ths/s counter
0046: C881                              defw    CTC3IV
                        
                        ;------------------------------------------------------------------------------
                        ; interrupt routine for NMI
0048: FFFFFFFF                          org     $0066
004C: FF...             
0066: C36180   [20]                     jp      NMIUSR              ; jump to execute NMI service routine
                        
                        ;------------------------------------------------------------------------------
                        
0069: FFFFFFFF                          org     $0090
006D: FF...             
0090: 4C4D3830                          defb    $4C,$4D,$38,$30,$43,$20,$43,$4F
0094: 4320434F          
0098: 4C4F5200                          defb    $4C,$4F,$52,$00,$00,$00,$00,$00
009C: 00000000          
00A0: 434F4D50                          defb    $43,$4F,$4D,$50,$55,$54,$45,$52
00A4: 55544552          
00A8: 20283230                          defb    $20,$28,$32,$30,$32,$30,$29,$00
00AC: 32302900          
00B0: 44657369                          defb    $44,$65,$73,$69,$67,$6E,$65,$64
00B4: 676E6564          
00B8: 20627900                          defb    $20,$62,$79,$00,$00,$00,$00,$00
00BC: 00000000          
00C0: 4C656F6E                          defb    $4C,$65,$6F,$6E,$61,$72,$64,$6F
00C4: 6172646F          
00C8: 204D696C                          defb    $20,$4D,$69,$6C,$69,$61,$6E,$69
00CC: 69616E69          
00D0: 46572033          FWVER:          defm    'FW 3.15',$20,__date__,$20,__time__,$00
00D4: 2E313520          
00D8: 32303230          
00DC: 2D31322D          
00E0: 33302031          
00E4: 373A3536          
00E8: 3A313800          
                        ;------------------------------------------------------------------------------
                        ; interrupt driven routine to get chars from Z80 SIO
00EC: FFFFFFFF                          org     $0100
00F0: FF...             
0100: F5       [11]     RX_CHA_AVAIL:   push    AF              ; store A
0101: E5       [22]                     push    HL              ; and HL
0102: CD6501   [39]                     call    A_RTS_OFF       ; disable RTS line
0105: DB20     [50]                     in      A,(SIO_DA)      ; read char from RX buffer into A
0107: 321882   [63]                     ld      (TMPKEYBFR),A   ; store it into the temp key buffer
010A: CD3601   [80]                     call    CHARINTOBFR     ; sub-routine to put the char into the input buffer
010D: D23101   [90|90]                  jp      NC,LVRXCHA      ; if buffer is full, then leave without doing anything else
0110: 3A1882   [103]                    ld      A,(TMPKEYBFR)   ; retrieve char
0113: 32D981   [116]                    ld      (CHR4VID),A     ; write into buffer for video printing
0116: FE0D     [123]                    cp      CR              ; is it RETURN?
0118: CA2001   [133|133]                jp      Z,CNTRXCHA      ; yes, continue
011B: FE20     [140]                    cp      $20             ; is it another control char (code < 32)?
011D: DA3101   [150|150]                jp      C,LVRXCHA       ; yes, leave w/o printing it on video nor sending back to serial
0120: F5       [11]     CNTRXCHA:       push    AF              ; store char
0121: AF       [15]                     xor     A
0122: 321682   [28]                     ld      (KBDNPT),A      ; a char from serial is like a char printed by BASIC
0125: 3AD881   [41]                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
0128: FE01     [48]                     cp      $01             ; is the print on video on?
012A: CCE306   [58|65]                  call    Z,CHAR2VID      ; yes, print on screen
012D: F1       [68]                     pop     AF              ; retrieve char
012E: CDF701   [85]                     call    TXA             ; send back to serial
0131: E1       [10]     LVRXCHA:        pop     HL              ; retrieve HL
0132: F1       [20]                     pop     AF              ; and A
0133: FB       [24]                     ei                      ; re-enable interrupts
0134: ED4D     [38]                     reti                    ; and exit
                        
                        ; put a char into the input buffer, char is into A
                        ; this sub is called both from the ISR "RX_CHA_AVAIL" and when
                        ; the RETURN key is pressed on the keyboard
0136: F5       [11]     CHARINTOBFR:    push    AF              ; store it
0137: 3A5C80   [24]                     ld      A,(serBufUsed)  ; load buffer size
013A: FE58     [31]                     cp      SER_BUFSIZE     ; if buffer is not full
013C: DA4101   [41|41]                  jp      C,NOTFULL       ; then store the char
013F: F1       [51]                     pop     AF              ; else drop it
0140: C9       [61]                     ret                     ; and exit
0141: 2A5880   [16]     NOTFULL:        ld      HL,(serInPtr)   ; buffer is not full, can store the char
0144: 23       [22]                     inc     HL              ; load pointer to find first free cell
0145: 7D       [26]                     ld      A,L             ; only check low byte because buffer<256
0146: FE58     [33]                     cp      bufWrap         ; check if the pointer is at the last cell
0148: 2003     [40|45]                  jr      NZ,NOTWRAP      ; if not then continue
014A: 210080   [50]                     ld      HL,SERBUF_START ; else load the address of the first cell
014D: 225880   [16]     NOTWRAP:        ld      (serInPtr),HL   ; store the new pointer
0150: F1       [26]                     pop     AF              ; then recover the char
0151: 77       [33]                     ld      (HL),A          ; and store it in the appropriate cell
0152: 3A5C80   [46]                     ld      A,(serBufUsed)  ; load the size of the input buffer
0155: 3C       [50]                     inc     A               ; increment it
0156: 325C80   [63]                     ld      (serBufUsed),A  ; and store the new size
0159: FE50     [70]                     cp      SER_FULLSIZE    ; check if input buffer is full
015B: D8       [75|81]                  ret     C               ; exit if buffer is not full
015C: 3A1B82   [88]                     ld      A,(SERIALS_EN)  ; check if serial 1 is open
015F: 1F       [92]                     rra                     ; bit 0 into Carry: if Carry is 1 then serial 0 is open and...
0160: DC6501   [102|109]                call    C,A_RTS_OFF     ; ...stop receiving further chars
0163: AF       [106]                    xor     A               ; clear Carry to set a buffer full condition
0164: C9       [116]                    ret
                        
                        ;-------------------------------------------------------------------------------
                        ; Z80 SIO MANAGEMENT
                        ;-------------------------------------------------------------------------------
                        ; disable RTS:
                        ; by resetting RTS bit (set to 0), the RTS line is disabled (HIGH)
0165: F5       [11]     A_RTS_OFF:      push    AF              ; store A
0166: 3E05     [18]                     ld      A,%00000101     ; write into WR0: select WR5
0168: D322     [29]                     out     (SIO_CA),A
016A: 3A1C82   [42]                     ld      A,(SERABITS)    ; load data bits
016D: F628     [49]                     or      %00101000       ; TX enable; RTS disable
016F: D322     [60]                     out     (SIO_CA),A      ; send setting
0171: F1       [70]                     pop     AF              ; retrieve A
0172: C9       [80]                     ret                     ; exit
                        
                        ; enable RTS
                        ; by setting RTS bit (set to 1), the RTS line is enabled (LOW)
0173: F5       [11]     A_RTS_ON:       push    AF              ; store A
0174: 3E05     [18]                     ld      A,%00000101     ; write into WR0: select WR5
0176: D322     [29]                     out     (SIO_CA),A
0178: 3A1C82   [42]                     ld      A,(SERABITS)    ; load data bits
017B: F62A     [49]                     or      %00101010       ; TX enable; RTS enable
017D: D322     [60]                     out     (SIO_CA),A      ; send setting
017F: F1       [70]                     pop     AF              ; retrieve A
0180: C9       [80]                     ret                     ; return
                        
                        ; disable SIO RX channel A
0181: F5       [11]     SIO_A_DI:       push    AF              ; store A
0182: 3E03     [18]                     ld      A,%00000011     ; write into WR0: select WR3
0184: D322     [29]                     out     (SIO_CA),A
0186: 3A1C82   [42]                     ld      A,(SERABITS)    ; load the serial bits; RX disabled; auto enable is OFF
0189: D322     [53]                     out     (SIO_CA),A
018B: F1       [63]                     pop     AF              ; retrieve A
018C: C9       [73]                     ret                     ; return
                        
                        ; enable SIO RX channel A
018D: F5       [11]     SIO_A_EI:       push    AF              ; store A
018E: 3E03     [18]                     ld      A,%00000011     ; write into WR0: select WR3
0190: D322     [29]                     out     (SIO_CA),A      ; select register
0192: 3A1C82   [42]                     ld      A,(SERABITS)    ; load the serial data bits
0195: CBC7     [50]                     set     0,A             ; set RX enabled; auto enable is OFF
0197: D322     [61]                     out     (SIO_CA),A      ; send setting to SIO
0199: F1       [71]                     pop     AF              ; retrieve A
019A: C9       [81]                     ret
                        
                        
                        ; special SIO condition (i.e., buffer overrun)
                        ; if buffer overruns then show an error, empty the RX buffer and send
                        ; a break char
019B:                   SPEC_RX_CONDITON:
019B: F5       [11]                     push    AF
019C: E5       [22]                     push    HL
019D: CD6501   [39]                     call    A_RTS_OFF       ; disable RTS
01A0: CD8101   [56]                     call    SIO_A_DI        ; disable RX on ch. A
01A3: 3A1B82   [69]                     ld      A,(SERIALS_EN)  ; load serial status
01A6: CB97     [77]                     res     2,A             ; disable RX on port 1
01A8: 321B82   [90]                     ld      (SERIALS_EN),A  ; store new serial status 
01AB: DB01     [101]                    in      A,(PIO_DB)      ; read status LEDs
01AD: CBE7     [109]                    set     4,A             ; set 5th pin ON
01AF: D301     [120]                    out     (PIO_DB),A      ; send new setting
01B1: 3E30     [127]                    ld      A,%00110000     ; write into WR0: error reset, select WR0
01B3: D322     [138]                    out     (SIO_CA),A      ; send command to SIO
01B5: 3E03     [145]                    ld      A,CTRLC
01B7: CD3601   [162]                    call    CHARINTOBFR     ; send CTRL-C to BASIC
01BA: AF       [ 4]     EMPTYCHABFR:    xor     A
01BB: D322     [15]                     out     (SIO_CA),A      ; write to WR0, select RR0
01BD: DB22     [26]                     in      A,(SIO_CA)      ; read RR0 register
01BF: E601     [33]                     and     $01             ; check if input buffer if empty
01C1: CAC801   [43|43]                  jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then leave
01C4: DB20     [54]                     in      A,(SIO_DA)      ; read chars
01C6: 18F2     [66]                     jr      EMPTYCHABFR     ; repeat
01C8: E1       [10]     CHABFREMPTY:    pop     HL
01C9: F1       [20]                     pop     AF
01CA: FB       [24]                     ei                      ; re-enable interrupts
01CB: ED4D     [38]                     reti                    ; return from interrupt
                        
                        ;------------------------------------------------------------------------------
                        ; retrieve a char from the input buffer
01CD: 3A5C80   [13]     RXA:            ld      A,(serBufUsed)  ; load the buffer size
01D0: A7       [17]                     and     A               ; check if it's 0 (empty)
01D1: CACD01   [27|27]                  jp      Z,RXA           ; if it's empty, wait for a char
01D4: F3       [31]                     di                      ; disable interrupts
01D5: E5       [42]                     push    HL              ; store HL
01D6: 2A5A80   [58]                     ld      HL,(serRdPtr)   ; load pointer to first available char
01D9: 23       [64]                     inc     HL              ; increment it (go to the next char)
01DA: 7D       [68]                     ld      A,L             ; check if the end of the buffer has been reached
01DB: FE58     [75]                     cp      bufWrap         ; (only check low byte because buffer<256)
01DD: 2003     [82|87]                  jr      NZ,NOTRDWRAP    ; if not, jump straight
01DF: 210080   [92]                     ld      HL,SERBUF_START ; else reload the starting address of the buffer
01E2: 225A80   [16]     NOTRDWRAP:      ld      (serRdPtr),HL   ; store new pointer to the next char to read
01E5: 3A5C80   [29]                     ld      A,(serBufUsed)  ; load buffer size
01E8: 3D       [33]                     dec     A               ; decrement it
01E9: 325C80   [46]                     ld      (serBufUsed),A  ; and store the new size
01EC: FE05     [53]                     cp      SER_EMPTYSIZE   ; check if input buffer can be considered empty
01EE: 3003     [60|65]                  jr      NC,RXA_EXIT     ; if not empty yet, then exit
01F0: CD7301   [77]                     call    A_RTS_ON        ; else re-enable receiving chars
01F3: 7E       [ 7]     RXA_EXIT:       ld      A,(HL)          ; recover the char and return it into A
01F4: E1       [17]                     pop     HL              ; retrieve HL
01F5: FB       [21]                     ei                      ; re-enable interrupts
01F6: C9       [31]                     ret                     ; return
                        
                        ;------------------------------------------------------------------------------
                        ; sends a char over the serial (trick for INTs from WikiTI)
                        ; char is into A
01F7: F5       [11]     TXA:            push    AF              ; store AF
01F8: C5       [22]                     push    BC              ; store BC
01F9: 47       [26]                     ld      B,A             ; store char
01FA: ED57     [35]                     ld      A,I             ; when loading I into A, P/V is set to the value of IFF (P/V is set if INTs enabled)
01FC: EA0102   [45|45]                  jp      PE,CNTTXA       ; if set, jump over
01FF: ED57     [54]                     ld      A,I             ; if not set, test again to fix "false negative" from interrupt occurring at first test
0201: F5       [11]     CNTTXA:         push    AF              ; store current P/V flag
0202: F3       [15]                     di                      ; disable INTs
0203: 3A1B82   [28]                     ld      A,(SERIALS_EN)  ; load serial status
0206: FE05     [35]                     cp      %00000101       ; check if serial 1 is open and RX/TX is enabled 
0208: 2006     [42|47]                  jr      NZ,TXA_EXIT     ; no, jump over
020A: 78       [46]                     ld      A,B             ; retrieve char
020B: D320     [57]                     out     (SIO_DA),A      ; send char to the SIO
020D: CD1802   [74]                     call    TX_EMP          ; wait for outgoing char to be sent
0210: F1       [10]     TXA_EXIT:       pop     AF              ; retrieve P/V flag
0211: E21502   [20|20]                  jp      PO,EXTXA        ; if P is reset, INTs were disabled so we can leave right now
0214: FB       [24]                     ei                      ; INTs were enabled, so re-enable interrupts
0215: C1       [10]     EXTXA:          pop     BC              ; retrieve BC
0216: F1       [20]                     pop     AF              ; retrieve AF
0217: C9       [30]                     ret                     ; return
                        
                        ;------------------------------------------------------------------------------
                        ; wait until outgoing serial has been sent
0218: 97       [ 4]     TX_EMP:         sub     A               ; set A to 0
0219: 3C       [ 8]                     inc     A               ; set A to 1
021A: D322     [19]                     out     (SIO_CA),A      ; write to WR0, select RR1
021C: DB22     [30]                     in      A,(SIO_CA)      ; read RR1 register
021E: CB47     [38]                     bit     0,A             ; check if all chars have been sent
0220: CA1802   [48|48]                  jp      Z,TX_EMP        ; if not (bit 0 = 0) then retrieve
0223: C9       [58]                     ret                     ; else exit
                        
                        
                        ;------------------------------------------------------------------------------
                        ; check if there is some chars into the buffer
0224: 3A5C80   [13]     CKINCHAR        ld      A,(serBufUsed)  ; load char in buffer
0227: A7       [17]                     and     A               ; compare to 0
0228: C9       [27]                     ret                     ; return
                        
                        ;------------------------------------------------------------------------------
                        ; print a text from memory, and terminate when $00 is found
0229: 7E       [ 7]     RAWPRINT:       ld      A,(HL)          ; load character from memory cell pointed by HL
022A: B7       [11]                     or      A               ; is it $00 (end string)?
022B: C8       [16|22]                  ret     Z               ; Yes, then return
022C: 32D981   [29]                     ld      (CHR4VID),A     ; store char
022F: F3       [33]                     di
0230: CDE306   [50]                     call    CHAR2VID        ; and send it to screen
0233: FB       [54]                     ei
0234: 23       [60]                     inc     HL              ; and select the next one
0235: 18F2     [72]                     jr      RAWPRINT        ; repeat
                        
                        ;-------------------------------------------------
                        ; Interrupt service routine (ISR) for CH3 timer
                        ; this is used to increment the 100ths of a second counter and for cursor flashing
0237: F5       [11]     CH3_TIMER:      push    AF              ; save regs. A,
0238: C5       [22]                     push    BC              ; BC,
0239: D5       [33]                     push    DE              ; DE,
023A: E5       [44]                     push    HL              ; HL
023B: 21BB81   [54]                     ld      HL,TMRCNT       ; load starting address of the timer
023E: 0604     [61]                     ld      B,$04           ; 4 bytes to check
0240: 34       [11]     INCTMR3:        inc     (HL)            ; increment timer
0241: 2003     [18|23]                  jr      NZ,CHKCRSR      ; if not zero then exit (finished increment)
0243: 23       [24]                     inc     HL              ; if yes, there was an overflow, so increment next byte
0244: 10FA     [32|37]                  djnz    INCTMR3         ; repeat for 4 bytes
0246: CD8407   [17]     CHKCRSR:        call    FLASHCURSOR     ; call the flashing cursor routine
0249: CD3E0C   [34]                     call    MNGSNDS         ; call the tone managemenet
024C: 3ABB81   [47]                     ld      A,(TMRCNT)      ; check for keyboard management
024F: 1F       [51]                     rra                     ; bit 0 = 1 ?
0250: D4A30C   [61|68]                  call    NC,KEYBOARD     ; no, so read the keyboard inputs
0253: E1       [71]                     pop     HL              ; retrieve HL,
0254: D1       [81]                     pop     DE              ; DE,
0255: C1       [91]                     pop     BC              ; BC,
0256: F1       [101]                    pop     AF              ; and A
0257: FB       [105]                    ei                      ; re-enable interrupts
0258: ED4D     [119]                    reti                    ; exit from ISR
                        
                        ;------------------------------------------------------------------------------
                        ;------------------------------------------------------------------------------
                        ; HARDWARE INITIALISATION
                        ; first run - setup HW & SW
                        ;
025A: 218D81   [10]     INIT_HW:        ld      HL,TEMPSTACK    ; load temp stack pointer
025D: F9       [16]                     ld      SP,HL           ; set stack to temp stack pointer
025E: 210080   [26]                     ld      HL,SERBUF_START ; set beginning of input buffer
0261: 225880   [42]                     ld      (serInPtr),HL   ; for incoming chars to store into buffer
0264: 225A80   [58]                     ld      (serRdPtr),HL   ; and for chars to be read from buffer
0267: AF       [62]                     xor     A               ; reset A
0268: 325C80   [75]                     ld      (serBufUsed),A  ; actual buffer size is 0
026B: 321B82   [88]                     ld      (SERIALS_EN),A  ; set serial ports status to OFF
026E: CDE502   [105]                    call    HELLOWRLD       ; little serial blink with LEDs
0271: CD0A03   [122]                    call    initCTC         ; configure CTC, then...
0274: CDDC0B   [139]                    call    initPSG         ; ...configure PSG
0277: CDBC04   [156]                    call    SHOW_LOGO       ; show computer logo
027A: 1E01     [163]                    ld      E,$01           ; E chooses the video mode: 1:graphics 1
027C: CD9903   [180]                    call    initVDP         ; set video display
027F: AF       [184]                    xor     A
0280: ED47     [193]                    ld      I,A             ; set high byte of interrupt vectors to point to page 0
0282: ED5E     [201]                    im      2               ; interrupt mode 2
0284: FB       [205]                    ei                      ; enable interrupts
                                        ; print system messages
0285: AF       [209]                    xor     A               ; A=0 so...
0286: 321682   [222]                    ld      (KBDNPT),A      ; ...inputs don't come from keyboard
0289: 3C       [226]                    inc     A               ; A=1...
028A: 32D881   [239]                    ld      (PRNTVIDEO),A   ; ...to activate the print-on-video
028D: 214003   [249]                    ld      HL,MSGTXT1      ; sign-on message
0290: CD2902   [266]                    call    RAWPRINT        ; print message
                                        ;call    CURSOR_ON       ; enable cursor
0293: 3A5D80   [279]                    ld      A,(basicStarted); check if BASIC is already started
0296: FE59     [286]                    cp      'Y'             ; to see if this is a power-up
0298: 2019     [293|298]                jr      NZ,COLDSTART    ; if not, then do a COLD start
029A: 217C03   [303]                    ld      HL,MSGTXT2      ; message to choose kind of start
029D: CD2902   [320]                    call    RAWPRINT        ; print message
02A0: CD7508   [337]                    call    CURSOR_ON       ; enable cursor
02A3: AF       [341]                    xor     A
02A4: 32D881   [354]                    ld      (PRNTVIDEO),A   ; disable print-on-video
02A7: CDCD01   [17]     CORW:           call    RXA             ; look for a pressed key
02AA: E6DF     [24]                     and     %11011111       ; only UPPERCASE char
02AC: FE43     [31]                     cp      'C'             ; cold start?
02AE: 200E     [38|43]                  jr      NZ,CHECKWARM    ; no, let's check for warm start
02B0: CDCB02   [55]                     call    ECHO_CHAR       ; echoes the char
02B3: 3E59     [ 7]     COLDSTART:      ld      A,'Y'           ; yes, set the "BASIC started" flag
02B5: 325D80   [20]                     ld      (basicStarted),A
02B8: CD8B08   [37]                     call    CURSOR_OFF      ; disable cursor
02BB: C30D0F   [47]                     jp      COLD            ; start BASIC COLD
02BE: FE57     [ 7]     CHECKWARM:      cp      'W'
02C0: 20E5     [14|19]                  jr      NZ,CORW         ; char not recognized, wait again
02C2: CDCB02   [31]                     call    ECHO_CHAR       ; echoes the char
02C5: CD8B08   [48]                     call    CURSOR_OFF      ; disable cursor
02C8: C3100F   [58]                     jp      WARM            ; start BASIC WARM
                        
                        ;-------------------------------------------------------------------------------
02CB: 32D981   [13]     ECHO_CHAR:      ld      (CHR4VID),A     ; set char for video printing
02CE: AF       [17]                     xor     A
02CF: 321682   [30]                     ld      (KBDNPT),A      ; input is not from keyboard
02D2: F3       [34]                     di                      ; disable INTs
02D3: CDE306   [51]                     call    CHAR2VID        ; echoes back the pressed key,
02D6: 3E0D     [58]                     ld      A,CR            ; then set a CR
02D8: 32D981   [71]                     ld      (CHR4VID),A     ; set char for video printing
02DB: CDE306   [88]                     call    CHAR2VID        ; and send it to screen
02DE: FB       [92]                     ei                      ; re-enable INTs
02DF: 3E01     [99]                     ld      A,$01
02E1: 32D881   [112]                    ld      (PRNTVIDEO),A   ; re-enable video printing
02E4: C9       [122]                    ret                     ; return to caller
                                        
                        ;-------------------------------------------------------------------------------
                        ; little serial blink with LEDs
02E5: 0E09     [ 7]     HELLOWRLD:      ld      C,$09           ; 8 LEDs to be turned off + 1 more step to turn off the last LED
02E7: 3ECF     [14]                     ld      A,%11001111     ; set mode 3 (mode control)
02E9: D303     [25]                     out     (PIO_CB),A      ; for PIO port B
02EB: AF       [29]                     xor     A               ; set pins to OUTPUT
02EC: D303     [40]                     out     (PIO_CB),A      ; for port B
02EE: 3C       [44]                     inc     A               ; LSB on
02EF: D301     [11]     LEDLIGHT:       out     (PIO_DB),A      ; turn LEDs on/off for a "Supercar" sequence
02F1: 1E20     [18]                     ld      E,$20           ; little delay
02F3: 0600     [ 7]     DEC_E:          ld      B,$00           ; count to 256
02F5: 10FE     [ 8|13]  COUNTER:        djnz    COUNTER         ; decrement inner counter
02F7: 1D       [12]                     dec     E               ; decrement outer counter
02F8: 20F9     [19|24]                  jr      NZ,DEC_E        ; finish delay
02FA: CB27     [27]                     sla     A               ; shift reg.A to left 1 bit
02FC: 0D       [31]                     dec     C               ; next LED
02FD: 20F0     [38|43]                  jr      NZ,LEDLIGHT     ; all LEDs done? no, repeat
02FF: C9       [48]                     ret                     ; return to caller
                        
                        ;-------------------------------------------------------------------------------
                        ; Z80 SIO default settings for channel A
0300: 30                SIO_A_SETS:     defb    %00110000       ; write into WR0: error reset, select WR0
0301: 18                                defb    %00011000       ; write into WR0: channel reset
0302: 04                                defb    %00000100       ; write into WR0: select WR4
0303: 44                                defb    %01000100       ; write into WR4: presc. 16x, 1 stop bit, no parity
0304: 05                                defb    %00000101       ; write into WR0: select WR5
0305: E8                                defb    %11101000       ; write into WR5: DTR on, TX 8 bits, BREAK off, TX on, RTS off
0306: 01                SIO_B_SETS:     defb    %00000001       ; write into WR0: select WR1
0307: 04                                defb    %00000100       ; write into WR1: status affects interrupt vectors
0308: 02                                defb    %00000010       ; write into WR0: select WR2
0309: 00                                defb    %00000000       ; write into WR2: set interrupt vector, but bits D3/D2/D1 of this vector
                                                                ; will be affected by the channel & condition that raised the interrupt
                                                                ; (see datasheet): in our example, 0x0C for Ch.A receiving A char, 0x0E
                                                                ; for special conditions
                        ;------------------------------------------------------------------------------
                        ; Z80 CTC setting up
030A:                   initCTC:
030A: 213403   [10]                     ld      HL,CTCCONF      ; CTC configuration
030D: 11BF81   [20]                     ld      DE,CTC0IV       ; CTC interrupt vector table
0310: 010C00   [30]                     ld      BC,$000C        ; 12 bytes
0313: EDB0     [46|21]                  ldir                    ; copy data
                        ;CH0, CH1, & CH2 disabled
0315: 3E03     [53]                     ld      A,%00000011     ; interrupt off, timer mode, prescaler=16, don't care ext. TRG edge,
                                                                ; start timer on loading constant, no time constant follows, software reset, command word
0317: D310     [64]                     out     (CTC_CH0),A     ; set CH0
0319: D311     [75]                     out     (CTC_CH1),A     ; set CH1
031B: D312     [86]                     out     (CTC_CH2),A     ; set CH2
                        
                        ;init CH3
                        ;CH3 divides CPU CLK by 144*256 providing an interrupt signal at 100 Hz (1/100 sec).
                        ;f = CPU_CLK/(144*256) => 3,686,400 / ( 36,864 ) => 100Hz
031D: 3EA7     [93]                     ld      A,%10100111     ; interrupt on; timer mode; prescaler=256; don't care ext; automatic trigger;
                                                                ; time constant follows; cont. operation; command word
031F: D313     [104]                    out     (CTC_CH3),A     ; send to CH3
0321: 3E90     [111]                    ld      A,$90           ; time constant - 90$ (144d)
0323: D313     [122]                    out     (CTC_CH3),A     ; send to CH3
0325: 3E40     [129]                    ld      A,%01000000     ; D7..D3 provide the first part of the int vector (in our case, $0100), followed by
                                                                ; D2..D1, provided by the CTC (they point to the channel), D0=interrupt word
                                                                ; so int vector is 01000xx00
0327: D310     [140]                    out     (CTC_CH0),A     ; send to CTC
                                        ; reset cells of 100ths of a second counter
0329: AF       [144]                    xor     A               ; reset A
032A: 21BB81   [154]                    ld      HL,TMRCNT       ; load TMR pointer
032D: 0604     [161]                    ld      B,$04           ; 4 memory cells
032F: 77       [ 7]     RESTMR:         ld      (HL),A          ; reset n-cell of TMR
0330: 23       [13]                     inc     HL              ; next cell
0331: 10FC     [21|26]                  djnz    RESTMR          ; repeat for 4 cells
0333: C9       [31]                     ret
                        
0334: FBED4D            CTCCONF:        defb    $FB,$ED,$4D     ; CTC0 interrupt vector (ei; reti)
0337: FBED4D                            defb    $FB,$ED,$4D     ; CTC1 interrupt vector (ei; reti)
033A: FBED4D                            defb    $FB,$ED,$4D     ; CTC2 interrupt vector (ei; reti)
033D: C33702   [10]                     jp      CH3_TIMER       ; CTC3 interrupt vector (jump to execute sys-tick timer)
                        ;------------------------------------------------------------------------------
0340: 20202020          MSGTXT1:        defm    "      LM80C Color Computer",CR
0344: 20204C4D          
0348: 38304320          
034C: 436F6C6F          
0350: 7220436F          
0354: 6D707574          
0358: 65720D            
035B: 20627920                          defm    " by Leonardo Miliani * FW R3.15",CR,0
035F: 4C656F6E          
0363: 6172646F          
0367: 204D696C          
036B: 69616E69          
036F: 202A2046          
0373: 57205233          
0377: 2E31350D          
037B: 00                
037C: 0D                MSGTXT2:        defb    CR
037D: 2020203C                          defm    "   <C>old or <W>arm start? ",0
0381: 433E6F6C          
0385: 64206F72          
0389: 203C573E          
038D: 61726D20          
0391: 73746172          
0395: 743F2000          
                        
                        ; incude the latest version of the VDP module
                        #include "../include/vdp/vdp-r315.asm"
                        ; ------------------------------------------------------------------------------
                        ; LM80C - VDP ROUTINES - R3.15
                        ; ------------------------------------------------------------------------------
                        ; The following code is intended to be used with LM80C Z80-based computer
                        ; designed by Leonardo Miliani. Code and computer schematics are released under
                        ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
                        ; kind of warranty: you can use them at your own risk.
                        ; You are free to use them for any non-commercial use: you are only asked to
                        ; maintain the copyright notices, include this advice and the note to the 
                        ; attribution of the original version to Leonardo Miliani, if you intend to
                        ; redistribuite them.
                        ; https://www.leonardomiliani.com
                        ; 
                        ; Please support me by visiting the following links:
                        ; Main project page: https://www.leonardomiliani.com
                        ; Schematics and code: https://github.com/leomil72/LM80C
                        ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
                        ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
                        ; ------------------------------------------------------------------------------
                        ;
                        ;------------------------------------------------------------------------------
                        ; VDP INITIALISATION
                        ; initialize VDP for a specific graphics mode
                        ; INPUT: E -> contains the graphics mode:
                        ; 0=text; 1=graphics 1; 2=graphics 2; 3=multicolor; 4=extended graphics 2
0399: D5       [11]     initVDP:        push    DE              ; store E
039A: CD180A   [28]                     call    EMPTY_VRAM      ; reset VRAM
039D: CD370A   [45]                     call    SET_GFX_MODE    ; load register settings
03A0: CD2C0A   [62]                     call    CLR_RAM_REG     ; reset RAM registers
03A3: D1       [72]                     pop     DE              ; restore reg. E
03A4: AF       [76]                     xor     A               ; reset A
03A5: 47       [80]                     ld      B,A             ; reset B (will be used later)
03A6: 7B       [84]                     ld      A,E             ; move E into A
03A7: 32CD81   [97]                     ld      (SCR_MODE),A    ; store screen mode
03AA: FE01     [104]                    cp      $01             ; is it graphics 1 (A=1)?
03AC: CAE803   [114|114]                jp      Z,G1MD          ; yes, jump over
03AF: FE02     [121]                    cp      $02             ; is it graphics 2 (A=2)?
03B1: CA2904   [131|131]                jp      Z,G2MD          ; yes, jump over
03B4: FE03     [138]                    cp      $03             ; is it multicolor (A=3)?
03B6: CA4B04   [148|148]                jp      Z,MCMD          ; yes, jump over
03B9: FE04     [155]                    cp      $04             ; is it extended graphics 2 (A=4)?
03BB: CA6E04   [165|165]                jp      Z,EXG2MD        ; yes, jump over; otherwise, it must be $00 so we assume that it's text mode
                        
                                        ; LOAD VDP SETTINGS FOR SELECTED VIDEO MODE:
                                        ; TEXT MODE (G0)
03BE:                   TXTMD:          ; load charset
03BE: 60       [ 4]                     ld      H,B
03BF: 68       [ 8]                     ld      L,B             ; HL=first pattern cell $0000
03C0: CD530A   [25]                     call    LOADCHARSET     ; load patterns into VRAM
                                        ; set cursor & video overlay
03C3: AF       [29]                     xor     A               ; reset A
03C4: 32D181   [42]                     ld      (SCR_CURS_X),A  ; set cursor position at X=0
03C7: 32D281   [55]                     ld      (SCR_CURS_Y),A  ; and Y=0
03CA: 3E05     [62]                     ld      A,$05           ; light blue
03CC: 32DB81   [75]                     ld      (BKGNDCLR),A    ; set background/border color
03CF: 3E28     [82]                     ld      A,$28
03D1: 32CB81   [95]                     ld      (SCR_SIZE_W),A  ; screen width = 40 cols
03D4: 3E18     [102]                    ld      A,$18
03D6: 32CC81   [115]                    ld      (SCR_SIZE_H),A  ; screen height = 24 rows
03D9: 3E1E     [122]                    ld      A,$1E
03DB: 32A380   [135]                    ld      (COMMAN),A      ; width for commas (4 columns)
03DE: 110008   [145]                    ld      DE,$0800
03E1: ED53CF81 [165]                    ld      (SCR_NAM_TB),DE ; set name table address
03E5: C3B104   [175]                    jp      ENDVDPSET       ; execute the rest of the video setting
                        
                                        ; GRAPHICS 1 MODE (G1)
03E8:                   G1MD:           ; load pattern table
03E8: 68       [ 4]                     ld      L,B
03E9: 60       [ 8]                     ld      H,B             ; HL=first pattern cell $0000
03EA: CD530A   [25]                     call    LOADCHARSET     ; load patterns into VRAM
                                        ; set cursor & video overlay
03ED: AF       [29]                     xor     A               ; position cursor
03EE: 32D181   [42]                     ld      (SCR_CURS_X),A  ; at X=0
03F1: 32D281   [55]                     ld      (SCR_CURS_Y),A  ; and Y=0
03F4: 3E20     [62]                     ld      A,$20
03F6: 32CB81   [75]                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
03F9: 3E18     [82]                     ld      A,$18
03FB: 32CC81   [95]                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
03FE: 3E14     [102]                    ld      A,$14
0400: 32A380   [115]                    ld      (COMMAN),A      ; width for commas (3 columns)
0403: 110018   [125]                    ld      DE,$1800
0406: ED53CF81 [145]                    ld      (SCR_NAM_TB),DE ; set name table address
                                        ; load color table
040A: 210020   [155]                    ld      HL,$2000        ; color table start: $2000
040D: CD1406   [172]                    call    SETVDPADRS
0410: 3E01     [179]                    ld      A,$01           ; foreground color...
0412: 32DA81   [192]                    ld      (FRGNDCLR),A    ; ...set to black
0415: 3E0F     [199]                    ld      A,$0F           ; background color...
0417: 32DB81   [212]                    ld      (BKGNDCLR),A    ; ...set to white
041A: 3E1F     [219]                    ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
041C: 0620     [226]                    ld      B,$20           ; 32 bytes of colors
041E: 0E30     [233]                    ld      C,VDP_DAT       ; VDP data mode
0420: ED79     [12]     LDCLRTBMD1:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
0422: 00       [16]                     nop
0423: 00       [20]                     nop
0424: 10FA     [28|33]                  djnz    LDCLRTBMD1      ; repeat for 32 bytes
0426: C3B104   [38]                     jp      ENDVDPSET       ; execute the rest of the video setting
                        
                                        ; GRAPHICS 2 MODE (G2)
0429: AF       [ 4]     G2MD:           xor     A               ; position cursor
042A: 32D181   [17]                     ld      (SCR_CURS_X),A  ; at X=0
042D: 32D281   [30]                     ld      (SCR_CURS_Y),A  ; and Y=0
0430: 32CB81   [43]                     ld      (SCR_SIZE_W),A  ; screen width = 256 pixels (0=256)
0433: 3C       [47]                     inc     A               ; black on...
0434: 32DA81   [60]                     ld      (FRGNDCLR),A    ; ...foreground
0437: 3E0F     [67]                     ld      A,$0F           ; white on...
0439: 32DB81   [80]                     ld      (BKGNDCLR),A    ; ...background
043C: 3EC0     [87]                     ld      A,$C0
043E: 32CC81   [100]                    ld      (SCR_SIZE_H),A  ; screen height = 192 pixels
0441: 110018   [110]                    ld      DE,$1800
0444: ED53CF81 [130]                    ld      (SCR_NAM_TB),DE ; set name table address
0448: C3B104   [140]                    jp      ENDVDPSET       ; execute the rest of the video setting
                        
                                        ; MULTICOLOR MODE (G3)
044B: AF       [ 4]     MCMD:           xor     A               ; position cursor
044C: 32D181   [17]                     ld      (SCR_CURS_X),A  ; at X=0
044F: 32D281   [30]                     ld      (SCR_CURS_Y),A  ; and Y=0
0452: 3E0F     [37]                     ld      A,$0F           ; white color for...
0454: 32DB81   [50]                     ld      (BKGNDCLR),A    ; ...background and...
0457: 32DA81   [63]                     ld      (FRGNDCLR),A    ; ...foreground (even this is not used in MC)
045A: 3E40     [70]                     ld      A,$40
045C: 32CB81   [83]                     ld      (SCR_SIZE_W),A  ; screen width = 64 blocks
045F: 3E30     [90]                     ld      A,$30
0461: 32CC81   [103]                    ld      (SCR_SIZE_H),A  ; screen height = 48 blocks
0464: 110008   [113]                    ld      DE,$0800
0467: ED53CF81 [133]                    ld      (SCR_NAM_TB),DE ; set name table address
046B: C3B104   [143]                    jp      ENDVDPSET       ; execute the rest of the video setting
                        
                                        ; EXTENDED GRAPHICS 2 (G4)
046E:                   EXG2MD:         ; load pattern table
046E: 60       [ 4]                     ld      H,B
046F: 68       [ 8]                     ld      L,B             ; HL=first pattern cell $0000
0470: CD530A   [25]                     call    LOADCHARSET     ; load patterns into VRAM
                                        ; set cursor & video overlay
0473: AF       [29]                     xor     A               ; position cursor
0474: 32D181   [42]                     ld      (SCR_CURS_X),A  ; at X=0
0477: 32D281   [55]                     ld      (SCR_CURS_Y),A  ; and Y=0
047A: 3E20     [62]                     ld      A,$20
047C: 32CB81   [75]                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
047F: 3E18     [82]                     ld      A,$18
0481: 32CC81   [95]                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
0484: 3E14     [102]                    ld      A,$14
0486: 32A380   [115]                    ld      (COMMAN),A      ; width for commas (3 columns)
0489: 110038   [125]                    ld      DE,$3800
048C: ED53CF81 [145]                    ld      (SCR_NAM_TB),DE ; set name table address
                                         ; load color table
0490: 210020   [155]                    ld      HL,$2000        ; color table start: $2000
0493: CD1406   [172]                    call    SETVDPADRS
0496: 3E01     [179]                    ld      A,$01           ; foreground color is...
0498: 32DA81   [192]                    ld      (FRGNDCLR),A    ; ...set to black
049B: 3E0F     [199]                    ld      A,$0F           ; whitefor...
049D: 32DB81   [212]                    ld      (BKGNDCLR),A    ; ...background
04A0: 3E1F     [219]                    ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
04A2: 1608     [226]                    ld      D,$08           ; 8 pages of 
04A4: 0600     [233]                    ld      B,$00           ; 256 bytes of colors (total of 2,048 cells)
04A6: 0E30     [240]                    ld      C,VDP_DAT       ; VDP data mode
04A8: ED79     [12]     LDCLRTBEX2:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
04AA: 00       [16]                     nop
04AB: 00       [20]                     nop
04AC: 10FA     [28|33]                  djnz    LDCLRTBEX2      ; repeat for 256 bytes
04AE: 15       [32]                     dec     D               ; did we fill up all the cells?
04AF: 20F7     [39|44]                  jr      NZ,LDCLRTBEX2   ; no, repeat
                                        ; LAST VDP SETTINGS
04B1: CD8B08   [17]     ENDVDPSET:      call    CURSOR_OFF      ; disable cursor
04B4: CD8205   [34]                     call    EMPTYVIDBUF     ; empty video buffer
04B7: AF       [38]                     xor     A
04B8: 32D581   [51]                     ld      (SCR_ORG_CHR),A ; store byte used tochar used to empty the video buffer
04BB: C9       [61]                     ret                     ; return to caller
                        
                        
                        ; show initial logo
04BC: CD180A   [17]     SHOW_LOGO:      call    EMPTY_VRAM      ; reset VRAM
                                        ; set VDP for G2 mode
04BF: 0607     [24]                     ld      B,$07           ; set only the first 7 registers
04C1: 111000   [34]                     ld      DE,$0010        ; load settings for G2 mode
04C4: CD3F0A   [51]                     call    SET_GFX_MODE2   ; load register settings
04C7: 1601     [58]                     ld      D,$01           ; backdrop color set to black
04C9: ED51     [70]                     out     (C),D           ; send data to VDP
04CB: ED79     [82]                     out     (C),A           ; indicate the register to send data to
                                        ; set name table 
04CD: 210018   [92]                     ld      HL,$1800        ; name table address
04D0: CD0106   [109]                    call    SETNAMETABLE    ; set name table (load names into table)
04D3: CD3005   [126]                    call    ERASECLRTBL     ; erase color table (set foreground & background to black)
                                        ; set colors for logo
04D6: 210028   [136]                    ld      HL,$2800        ; 2nd page of color table
04D9: CD1406   [153]                    call    SETVDPADRS
04DC: 0605     [160]                    ld      B,5             ; 5 bands
04DE: 217D05   [170]                    ld      HL,CLRTABLE
04E1: 0E30     [177]                    ld      C,VDP_DAT
04E3: 1E08     [184]                    ld      E,$08           ; 8 pixels each pattern        
04E5: 1640     [ 7]     RPT101:         ld      D,$40           ; 64 chars each band
04E7: 7E       [14]                     ld      A,(HL)
04E8: ED79     [12]     RPT102:         out     (C),A
04EA: 00       [16]                     nop
04EB: 1D       [20]                     dec     E
04EC: 20FA     [27|32]                  jr      NZ,RPT102
04EE: 1E08     [34]                     ld      E,$08
04F0: 15       [38]                     dec     D
04F1: 20F5     [45|50]                  jr      NZ,RPT102
04F3: 23       [51]                     inc     HL
04F4: 10EF     [59|64]                  djnz    RPT101
                                        ; set pattern table
04F6: 210008   [69]                     ld      HL,$0800        ; address of first cell of 2nd area of pattern table
04F9: 119C0A   [79]                     ld      DE,LM80CLOGO    ; pointer to logo pattern
04FC: 0600     [86]                     ld      B,$00           ; 256 bytes, 8 rows
04FE: CD5C05   [17]     RPT103:         call    LOADLOGOCHRS
0501: 13       [23]                     inc     DE              ; next logo pattern
0502: 10FA     [31|36]                  djnz    RPT103
0504: 0620     [38]                     ld      B,$20           ; repeat for another 2 rows
0506: CD5C05   [17]     RPT104:         call    LOADLOGOCHRS
0509: 13       [23]                     inc     DE              ; next logo pattern
050A: 10FA     [31|36]                  djnz    RPT104
                                        ; show logo/message, play a beep and wait a while
050C: 0602     [38]                     ld      B,$02
050E: AF       [42]                     xor     A
050F: 57       [46]                     ld      D,A             ; 256 times
0510: 5F       [50]                     ld      E,A             ; x 256 times
0511: 32DC81   [63]                     ld      (TMPBFR1),A     ; sound flag set to 0
0514: 00       [ 4]     DEC_D:          nop                     ; does nothing...
0515: 00       [ 8]                     nop
0516: 00       [12]                     nop
0517: 00       [16]                     nop
0518: 00       [20]                     nop
0519: 00       [24]                     nop
051A: 1D       [28]                     dec     E               ; decrement E
051B: 20F7     [35|40]                  jr      NZ,DEC_D        ; repeat until $00
051D: 7A       [39]                     ld      A,D
051E: FE40     [46]                     cp      $40             ; ...equal to 64
0520: CC4805   [56|63]                  call    Z,SETBEEP       ; if yes, start sound
0523: 15       [60]                     dec     D
0524: 20EE     [67|72]                  jr      NZ,DEC_D        ; repeat
0526: 3ADC81   [80]                     ld      A,(TMPBFR1)
0529: FE02     [87]                     cp      $02
052B: C45405   [97|104]                 call    NZ,BEEPOFF
052E: 10E4     [105|110]                djnz    DEC_D
0530:                   ERASECLRTBL:    ; erase color table
0530: 3E11     [ 7]                     ld      A,$11           ; foreground and background set to black
0532: 160A     [14]                     ld      D,$0A           ; 10 pages
0534: 0600     [21]                     ld      B,$00           ; 256 color cells per page
0536: 210028   [31]                     ld      HL,$2800        ; first cell of 2nd color table
0539: CD1406   [48]                     call    SETVDPADRS      ; send address
053C: 0E30     [55]                     ld      C,VDP_DAT       ; VDP address for passing data
053E: ED79     [12]     RPT100:         out     (C),A           ; send data
0540: 00       [16]                     nop
0541: 00       [20]                     nop                     ; little delay
0542: 10FA     [28|33]                  djnz    RPT100          ; repeat for entire page
0544: 15       [32]                     dec     D
0545: 20F7     [39|44]                  jr      NZ,RPT100       ; repeat for all the pages ($0A00 cells)
0547: C9       [49]                     ret                     ; return to caller
                        
                        ; play a beep
0548: 3ADC81   [13]     SETBEEP:        ld      A,(TMPBFR1)     ; check the already-beeped flag?
054B: B7       [17]                     or      A               ; is it 0?
054C: C0       [22|28]                  ret     NZ              ; no, exit
054D: 3C       [26]                     inc     A               ; flag to 1
054E: 32DC81   [39]                     ld      (TMPBFR1),A     ; set sound
0551: C30A0C   [49]                     jp      WLCMBEEP        ; play a beep & return
                        
                        ; beep off
0554: 3E02     [ 7]     BEEPOFF:        ld      A,$02           ; flag for sound off
0556: 32DC81   [20]                     ld      (TMPBFR1),A     ; set flag
0559: C3100C   [30]                     jp      NOBEEP          ; stop beep and return
                        
                        
                        ; used to load the chars that will compose the logo of the splash screen
055C: 1A       [ 7]     LOADLOGOCHRS:   ld      A,(DE)          ; load a pattern char of the logo
055D: 87       [11]                     add     A,A
055E: 87       [15]                     add     A,A
055F: 87       [19]                     add     A,A             ; multiply times 8 to get the offset
0560: C5       [30]                     push    BC
0561: D5       [41]                     push    DE              ; store BC and DE
0562: E5       [52]                     push    HL              ; store VRAM address to write to
0563: 21784E   [62]                     ld      HL,LOGOFONT     ; start of logo font data
0566: 5F       [66]                     ld      E,A
0567: 1600     [73]                     ld      D,$00           ; put offset (A) into DE
0569: 19       [84]                     add     HL,DE           ; get address of pattern data
056A: EB       [88]                     ex      DE,HL           ; move address into DE
056B: E1       [98]                     pop     HL              ; retrieve VRAM address
056C: 0608     [105]                    ld      B,$08           ; 8 bytes per pattern
056E: CD1406   [122]                    call    SETVDPADRS      ; set VDP address
0571: 0E30     [129]                    ld      C,VDP_DAT
0573: 1A       [ 7]     SNDLOGPT:       ld      A,(DE)          ; load data from RAM
0574: ED79     [19]                     out     (C),A           ; and send to VRAM
0576: 13       [25]                     inc     DE              ; next byte into RAM
0577: 23       [31]                     inc     HL              ; next byte into VRAM (used in future iterations)
0578: 10F9     [39|44]                  djnz    SNDLOGPT        ; repeat 8 times
057A: D1       [49]                     pop     DE
057B: C1       [59]                     pop     BC              ; retrieve BC & DE
057C: C9       [69]                     ret                     ; return to caller
                        
057D:                   CLRTABLE:       equ $
057D: 181B1314                          defb    $18,$1B,$13,$14,$1D ; colors of background bands of the logo
0581: 1D                
                                        
                        ; empty video buffer
0582: 3ACD81   [13]     EMPTYVIDBUF:    ld      A,(SCR_MODE)    ; check screen mode
0585: FE02     [20]                     cp      $02             ; is it G2 mode?
0587: CAAB05   [30|30]                  jp      Z,EMPTYG2       ; yes, jump over
058A: FE03     [37]                     cp      $03             ; is it MC mode?
058C: CADC05   [47|47]                  jp      Z,EMPTYMC       ; yes, jump over
058F: 3ACC81   [60]                     ld      A,(SCR_SIZE_H)  ; load height of screen
0592: 47       [64]                     ld      B,A             ; move rows into B
0593: AF       [68]                     xor     A               ; filling char is $00
0594: 2ACF81   [84]                     ld      HL,(SCR_NAM_TB) ; load the name table address
0597: CD1406   [101]                    call    SETVDPADRS      ; send address to VDP
059A: 0E30     [108]                    ld      C,VDP_DAT       ; VDP address for passing data
059C: 5F       [ 4]     LDCOLSTOEMPTY:  ld      E,A             ; store filling char into E
059D: 3ACB81   [17]                     ld      A,(SCR_SIZE_W)  ; load # of cols to empty into A
05A0: 57       [21]                     ld      D,A             ; move A into D
05A1: 7B       [25]                     ld      A,E             ; recover filling char
05A2: ED79     [12]     RPTEMPTYBUF:    out     (C),A           ; write empty byte into VRAM
05A4: 00       [16]                     nop
05A5: 15       [20]                     dec     D               ; decr. D
05A6: 20FA     [27|32]                  jr      NZ,RPTEMPTYBUF  ; repeat for the # of cols
05A8: 10F2     [35|40]                  djnz    LDCOLSTOEMPTY   ; repeat for the # of rows
05AA: C9       [45]                     ret                     ; return to caller
05AB: 2ACF81   [16]     EMPTYG2:        ld      HL,(SCR_NAM_TB) ; yes, additional setup for G2 - load G2 name table address (usually $1800)
05AE: CD0106   [33]                     call    SETNAMETABLE    ; set name table
05B1: 210000   [43]                     ld      HL,$0000        ; set pattern table
05B4: CD1406   [60]                     call    SETVDPADRS      ; send address to VDP
05B7: AF       [64]                     xor     A               ; empty pattern
05B8: 1618     [71]                     ld      D,$18           ; 6144 ($1800) cell to clean, 24 pages ($18)
05BA: 47       [75]                     ld      B,A             ; 256 bytes for page
05BB: 0E30     [82]                     ld      C,VDP_DAT       ; VDP data mode
05BD: ED79     [12]     CLRG2PTNTBL:    out     (C),A           ; clear pattern
05BF: 00       [16]                     nop                     ; little delay
05C0: 00       [20]                     nop
05C1: 10FA     [28|33]                  djnz    CLRG2PTNTBL     ; repeat for 1 page
05C3: 15       [32]                     dec     D               ; next page
05C4: 20F7     [39|44]                  jr      NZ,CLRG2PTNTBL  ; repeat
05C6: 210020   [49]                     ld      HL,$2000        ; load the color table address
05C9: CD1406   [66]                     call    SETVDPADRS      ; send address to VDP
05CC: 3ADA81   [79]                     ld      A,(FRGNDCLR)    ; load foreground
05CF: 87       [83]                     add     A,A
05D0: 87       [87]                     add     A,A
05D1: 87       [91]                     add     A,A
05D2: 87       [95]                     add     A,A             ; move to high nibble
05D3: 57       [99]                     ld      D,A             ; store into D
05D4: 3ADB81   [112]                    ld      A,(BKGNDCLR)    ; load background color
05D7: B2       [116]                    or      D               ; combine with background color
05D8: 1618     [123]                    ld      D,$18           ; 6144 ($1800) cells to fill, so 24 pages ($18)
05DA: 1817     [135]                    jr      STARTEMPTY
05DC: 210008   [10]     EMPTYMC:        ld      HL,$0800        ; MC name table
05DF: CD0106   [27]                     call    SETNAMETABLE    ; set name table
05E2: 210000   [37]                     ld      HL,$0000        ; color table address
05E5: CD1406   [54]                     call    SETVDPADRS      ; send address to VDP
05E8: 3ADB81   [67]                     ld      A,(BKGNDCLR)    ; load background
05EB: 57       [71]                     ld      D,A             ; store into D
05EC: 87       [75]                     add     A,A
05ED: 87       [79]                     add     A,A
05EE: 87       [83]                     add     A,A
05EF: 87       [87]                     add     A,A             ; move to high nibble
05F0: B2       [91]                     or      D               ; set background color for high and low nibble
05F1: 1608     [98]                     ld      D,$08           ; 2048 ($0800) cells to fill, so 8 pages ($08)
05F3: 0E30     [ 7]     STARTEMPTY:     ld      C,VDP_DAT       ; VDP address for passing data
05F5: 0600     [14]                     ld      B,$00           ; 256 bytes each page ($00=256)
05F7: ED79     [12]     SNDCLRSET:      out     (C),A           ; send color setting
05F9: 00       [16]                     nop                     ; wait a while
05FA: 00       [20]                     nop
05FB: 10FA     [28|33]                  djnz    SNDCLRSET       ; repeat for 1 page
05FD: 15       [32]                     dec     D               ; have we filled all the pages?
05FE: 20F7     [39|44]                  jr      NZ,SNDCLRSET    ; no, repeat
0600: C9       [49]                     ret                     ; return to caller
                        
                        ; set name table for G2 mode (patterns from $00 to $FF for each of the 3 areas of the screen)
0601: CD1406   [17]     SETNAMETABLE:   call    SETVDPADRS      ; send address to VDP
0604: 0E30     [24]                     ld      C,VDP_DAT       ; VDP address for passing data
0606: 1603     [31]                     ld      D,$03           ; 3 pages to fill into VRAM (768 cells)
0608: AF       [35]                     xor     A               ; starting char name #0 (chars go from 0 to 255)
0609: 47       [39]                     ld      B,A             ; reset B
060A: ED79     [12]     RPTFLL1:        out     (C),A           ; send name to VRAM
060C: 00       [16]                     nop
060D: 3C       [20]                     inc     A               ; increment # of name
060E: 10FA     [28|33]                  djnz    RPTFLL1         ; repeat for 256 cells (1 page)
0610: 15       [32]                     dec     D               ; did we fill all the pages?
0611: 20F7     [39|44]                  jr      NZ,RPTFLL1      ; no, continue
0613: C9       [49]                     ret                     ; return to caller
                        
                        ; set an address into VRAM: address is in HL
0614: 0E32     [ 7]     SETVDPADRS:     ld      C,VDP_SET       ; VDP address mode
0616: CBF4     [15]                     set     6,H             ; set bit #6 of address, to write to VRAM
0618: ED69     [27]                     out     (C),L           ; send low and...
061A: ED61     [39]                     out     (C),H           ; ...high byte of the first cell
061C: C9       [49]                     ret                     ; return to caller
                        
                        ; clear the video buffer and position the cursor at 0,0
061D: CD8205   [17]     CLEARVIDBUF:    call    EMPTYVIDBUF     ; clear video buffer
0620: AF       [21]                     xor     A               ; reset A
0621: 32D181   [34]                     ld      (SCR_CURS_X),A  ; cursor X to 0
0624: 32D281   [47]                     ld      (SCR_CURS_Y),A  ; cursor Y to 0
0627: C37006   [57]                     jp      POS_CURSOR      ; position cursor & return to caller
                        
                        ; HOME: position the cursor at coords. 0,0 
062A: AF       [ 4]     ATHOME:         xor     A               ; position cursor at 0,0 by storing...
062B: 32D481   [17]                     ld      (SCR_CUR_NY),A  ; ...new Y...
062E: 32D381   [30]                     ld      (SCR_CUR_NX),A  ; ...and new X
0631: C37A06   [40]                     jp      MOVCRS          ; move cursor to new location & return to caller
                        
                        ; load the char or byte at the VRAM position set by HL
                        ; value is returned into A
0634: C5       [11]     READ_VIDEO_LOC: push    BC              ; store BC
0635: 0E32     [18]                     ld      C,VDP_SET       ; VDP setting mode
0637: 44       [22]                     ld      B,H
0638: CBB8     [30]                     res     7,B
063A: CBB0     [38]                     res     6,B
063C: ED69     [50]                     out     (C),L           ; low byte then...
063E: ED41     [62]                     out     (C),B           ; high byte
0640: 0E30     [69]                     ld      C,VDP_DAT       ; VDP data mode
0642: 00       [73]                     nop                     ; wait...
0643: 00       [77]                     nop                     ; ...a while
0644: 00       [81]                     nop
0645: ED78     [93]                     in      A,(C)           ; read byte at current VRAM location
0647: C1       [103]                    pop     BC              ; restore BC
0648: C9       [113]                    ret                     ; return to caller
                        
                        ; write a byte at the VRAM position pointed by HL
                        ; value is in A
0649: C5       [11]     WRITE_VIDEO_LOC:push    BC              ; store BC
064A: 0E32     [18]                     ld      C,VDP_SET       ; VDP setting mode
064C: 44       [22]                     ld      B,H             ; copy H into B
064D: CBB8     [30]                     res     7,B
064F: CBF0     [38]                     set     6,B             ; write to VRAM
0651: ED69     [50]                     out     (C),L           ; low byte then...
0653: ED41     [62]                     out     (C),B           ; high byte of VRAM address
0655: 0E30     [69]                     ld      C,VDP_DAT       ; VDP data mode
0657: 00       [73]                     nop                     ; wait...
0658: 00       [77]                     nop                     ; ...a while
0659: 00       [81]                     nop
065A: ED79     [93]                     out     (C),A           ; write byte into VRAM
065C: C1       [103]                    pop     BC              ; restore BC
065D: C9       [113]                    ret                     ; return to caller
                        
                        ; write a value into a specific VDP register
                        ; value is in E, register is in A
065E: C5       [11]     WRITE_VREG:     push    BC              ; store BC
065F: C680     [18]                     add     A,$80           ; set VDP to write to registers
0661: 0E32     [25]                     ld      C,VDP_SET       ; VDP setting mode
0663: ED59     [37]                     out     (C),E           ; send data to VDP
0665: ED79     [49]                     out     (C),A           ; select the destination register
0667: C1       [59]                     pop     BC              ; restore BC
0668: C9       [69]                     ret                     ; return to caller
                        
                        ; read VDP status register and return value into A
0669: C5       [11]     READ_VSTAT:     push    BC              ; store BC
066A: 0E32     [18]                     ld      C,VDP_SET       ; VDP register access
066C: ED78     [30]                     in      A,(C)           ; read status register
066E: C1       [40]                     pop     BC              ; restore BC
066F: C9       [50]                     ret                     ; return to caller
                        
                        ; position the cursor at the current coordinates, preserving underlying char
0670: CDAE06   [17]     POS_CURSOR:     call    LOAD_CRSR_POS   ; load the VRAM address of cursor into HL
0673: CD3406   [34]                     call    READ_VIDEO_LOC  ; load the current char at the cursor position (return in A)
0676: 32D581   [47]                     ld      (SCR_ORG_CHR),A ; store the current char
0679: C9       [57]                     ret
                        
                        ; move cursor to new X,Y coordinates
067A: CDA506   [17]     MOVCRS:         call    RSTCHRCRS       ; restore the char in the current cursor position
067D: CD9006   [34]                     call    NEWCRSRCOORD    ; set new cursor's coordinates
0680: CD7006   [17]     MOVSHOWCRS:     call    POS_CURSOR      ; position cursor into new location
0683: 3ADC81   [30]                     ld      A,(TMPBFR1)     ; load status of cursor flashing
0686: E620     [37]                     and     $20             ; check cursor state
0688: 32D781   [50]                     ld      (LSTCSRSTA),A   ; store the last cursor state
068B: 3EFF     [57]                     ld      A,$FF           ; set cursor visible after moved it
068D: C34906   [67]                     jp      WRITE_VIDEO_LOC ; write into video cell
                        
                        
                        ; set new cursor's coordinates:
0690: 3AD381   [13]     NEWCRSRCOORD:   ld      A,(SCR_CUR_NX)  ; load new X
0693: 32D181   [26]                     ld      (SCR_CURS_X),A  ; write new X
0696: 3AD481   [39]                     ld      A,(SCR_CUR_NY)  ; load new Y
0699: 32D281   [52]                     ld      (SCR_CURS_Y),A  ; write new Y
069C: 3EFF     [59]                     ld      A,$FF           ; delete new values
069E: 32D381   [72]                     ld      (SCR_CUR_NX),A  ; of X
06A1: 32D481   [85]                     ld      (SCR_CUR_NY),A  ; and Y
06A4: C9       [95]                     ret
                        
                        ; recover char under the cursor and prints it onto the screen
06A5: CDAE06   [17]     RSTCHRCRS:      call    LOAD_CRSR_POS   ; recover old cursor position
06A8: 3AD581   [30]                     ld      A,(SCR_ORG_CHR) ; recover old char
06AB: C34906   [40]                     jp      WRITE_VIDEO_LOC ; write char into VRAM & return
                        
                        ; retrieve cursor position from either current coordinates or next place
                        ; return address position into HL
06AE: 3AD281   [13]     LOAD_CRSR_POS:  ld      A,(SCR_CURS_Y)  ; load cursor Y
06B1: 6F       [17]                     ld      L,A             ; move it into reg.L
06B2: AF       [21]                     xor     A               ; reset A
06B3: 67       [25]                     ld      H,A             ; reset H
06B4: 47       [29]                     ld      B,A             ; reset B
06B5: 29       [40]                     add     HL,HL           ; create offset (each address is 2-bytes long so we need to double HL)
06B6: 11E809   [50]                     ld      DE,POS_TB_CRS_40; load position table address of cursor for 40 cols
06B9: 3ACB81   [63]                     ld      A,(SCR_SIZE_W)  ; load screen width
06BC: FE28     [70]                     cp      $28             ; is it 40 cols?
06BE: 2803     [77|82]                  jr      Z,CONT_POS_CURS ; yes, jump over
06C0: 11B809   [87]                     ld      DE,POS_TB_CRS_32; no, load position table address of cursor for 32 cols
06C3: 19       [11]     CONT_POS_CURS:  add     HL,DE           ; the correct starting address of the required row is now into HL
06C4: 5E23562B [37]                     ld      DE,(HL)         ; load starting address of the required row into DE
06C8: 2ACF81   [53]                     ld      HL,(SCR_NAM_TB) ; load starting address of name table
06CB: 19       [64]                     add     HL,DE           ; starting address of the current row into name table
06CC: 3AD181   [77]                     ld      A,(SCR_CURS_X)  ; load cursor X
06CF: 4F       [81]                     ld      C,A             ; transfer A into C
06D0: 09       [92]                     add     HL,BC           ; add X offset: now HL contains the address of the current cursor position
06D1: C9       [102]                    ret
                        
                        ; find X,Y coordinates of a screen address pointed in VRAM by HL
                        ; return them into L,A for X,Y
06D2: D5       [11]     HL2XY:          push    DE              ; store DE
06D3: ED5BCF81 [31]                     ld      DE,(SCR_NAM_TB) ; load starting address of name table into DE
06D7: AF       [35]                     xor     A               ; clear Carry
06D8: ED52     [50]                     sbc     HL,DE           ; find position relative to screen (from 0,0)
06DA: D1       [60]                     pop     DE
06DB: 3ACB81   [73]                     ld      A,(SCR_SIZE_W)  ; load screen width
06DE: 4F       [77]                     ld      C,A             ; move it into C
06DF: CD543E   [94]                     call    DIV_16_8        ; divide position by C: return Y into L and X into A
06E2: C9       [104]                    ret                     ; return to caller
                        
                        ;-------------------------------------------------------------------------------
                        ; send current char to video buffer
06E3: F5       [11]     CHAR2VID:       push    AF              ; store AF
06E4: C5       [22]                     push    BC              ; store BC
06E5: D5       [33]                     push    DE              ; store DE
06E6: E5       [44]                     push    HL              ; store HL
06E7: 3AD681   [57]                     ld      A,(CRSR_STATE)  ; store cursor state...
06EA: F5       [68]                     push    AF              ; into stack
06EB: CD8B08   [85]                     call    CURSOR_OFF      ; cursor off
06EE: 3AD981   [98]                     ld      A,(CHR4VID)     ; recover char
06F1: FE19     [105]                    cp      HOME            ; is it HOME char ($19)?
06F3: 2006     [112|117]                jr      NZ,CHKCS        ; no, check over
06F5: CD2A06   [129]                    call    ATHOME          ; yes, move the cursor to 0,0
06F8: C37607   [139]                    jp      EXITCHAR2VID    ; exit
06FB: FE0C     [ 7]     CHKCS:          cp      CS              ; is it the CLEAR char ($0C)?
06FD: 2005     [14|19]                  jr      NZ,CHKCR        ; no, check over
06FF: CD1D06   [31]                     call    CLEARVIDBUF     ; yes, clear video buffer and position cursor at 0,0
0702: 1872     [43]                     jr      EXITCHAR2VID    ; exit
0704: FE0D     [ 7]     CHKCR:          cp      CR              ; is it a carriage return ($0D)?
0706: 2005     [14|19]                  jr      NZ,CHKBKSP      ; no, jump over
0708: CD0D09   [31]                     call    CRGRETURN       ; yes, go to the beginning of the next line
070B: 1869     [43]                     jr      EXITCHAR2VID    ; exit
070D: FE08     [ 7]     CHKBKSP:        cp      BKSP            ; is it the backspace ($08)?
070F: 2005     [14|19]                  jr      NZ,CHKCRSLFT    ; no, jump over
0711: CDA807   [31]                     call    BACKSPACE       ; move cursor left 1 position
0714: 1860     [43]                     jr      EXITCHAR2VID    ; exit
0716: FE1C     [ 7]     CHKCRSLFT:      cp      CRSLFT          ; is it cursor left?
0718: 2005     [14|19]                  jr      NZ,CHKCRSUP     ; no, jump over
071A: CDBB07   [31]                     call    CURSORLEFT      ; move cursor left...
071D: 1857     [43]                     jr      EXITCHAR2VID    ; ...and exit
071F: FE1E     [ 7]     CHKCRSUP:       cp      CRSUP           ; is it cursor up?
0721: 2005     [14|19]                  jr      NZ,CHKCRSRGT    ; no, jump over
0723: CD0708   [31]                     call    CURSORUP        ; move cursor up...
0726: 184E     [43]                     jr      EXITCHAR2VID    ; ...and exit
0728: FE1D     [ 7]     CHKCRSRGT:      cp      CRSRGT          ; is it cursor right?
072A: 2005     [14|19]                  jr      NZ,CHKCRSDWN    ; no, jump over
072C: CD2008   [31]                     call    CURSORRIGHT     ; move cursor right...
072F: 1845     [43]                     jr      EXITCHAR2VID    ; ...and exit
0731: FE1F     [ 7]     CHKCRSDWN:      cp      CRSDN           ; is it cursor down?
0733: 2005     [14|19]                  jr      NZ,CHKLF        ; no, jump over
0735: CD5508   [31]                     call    CURSORDOWN      ; move cursor up...
0738: 183C     [43]                     jr      EXITCHAR2VID    ; ...and exit
073A: FE0A     [ 7]     CHKLF:          cp      LF              ; is it a line feed ($0A)?
073C: 2838     [14|19]                  jr      Z,EXITCHAR2VID  ; CURRENTLY WE DON'T PRINT LF, WE JUST USE CR TO SUBSTITUTE CR+LF COMBINATION
073E: CDAE06   [31]                     call    LOAD_CRSR_POS   ; recover position of cursor
0741: 3AD981   [44]                     ld      A,(CHR4VID)     ; recover char to print
0744: CD4906   [61]                     call    WRITE_VIDEO_LOC ; write A into VRAM at (HL)
0747: 3AD281   [74]                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
074A: 5F       [78]                     ld      E,A             ; store cursor Y into E
074B: 3AD181   [91]                     ld      A,(SCR_CURS_X)  ; load cursor X
074E: 3C       [95]                     inc     A               ; move 1 step to right
074F: 21CB81   [105]                    ld      HL,SCR_SIZE_W   ; cell that keeps the width of screen
0752: BE       [112]                    cp      (HL)            ; have we reached the most right position?
0753: 200F     [119|124]                jr      NZ,SETCSRCOORDS ; no, go over
0755: 1C       [123]                    inc     E               ; yes, increment cursor Y (go to next line)
0756: 7B       [127]                    ld      A,E             ; move cursor Y into A
0757: 21CC81   [137]                    ld      HL,SCR_SIZE_H   ; cell that keeps the height of screen
075A: BE       [144]                    cp      (HL)            ; have we reached the bottom of the screen?
075B: 2006     [151|156]                jr      NZ,SETCRSRY     ; no, jump over
075D: D5       [162]                    push    DE
075E: CD9208   [179]                    call    SCROLLUP        ; scroll screen up
0761: D1       [189]                    pop     DE
0762: 1D       [193]                    dec     E               ; decrement 1 row, to set cursor Y on the last line
0763: AF       [ 4]     SETCRSRY:       xor     A               ; then set cursor X to 0 (go to beginning of line)
0764: 32D181   [13]     SETCSRCOORDS:   ld      (SCR_CURS_X),A  ; store current cursor X
0767: 7B       [17]                     ld      A,E             ; recover Y
0768: 32D281   [30]                     ld      (SCR_CURS_Y),A  ; store current cursor Y
076B: CD7006   [47]                     call    POS_CURSOR      ; position cursor into new location
076E: 3ADC81   [60]                     ld      A,(TMPBFR1)     ; load status of cursor flashing
0771: E620     [67]                     and     $20             ; check cursor state
0773: 32D781   [80]                     ld      (LSTCSRSTA),A   ; store the last cursor state
0776: AF       [ 4]     EXITCHAR2VID:   xor     A               ; reset char
0777: 32D981   [17]                     ld      (CHR4VID),A     ; to be sent to screen
077A: F1       [27]                     pop     AF              ; recover cursor state
077B: A7       [31]                     and     A               ; was it off (A=0)?
077C: C47508   [41|48]                  call    NZ,CURSOR_ON    ; no, set cursor on
077F: E1       [51]                     pop     HL              ; restore HL
0780: D1       [61]                     pop     DE              ; restore DE
0781: C1       [71]                     pop     BC              ; restore BC
0782: F1       [81]                     pop     AF              ; restore AF
0783: C9       [91]                     ret                     ; return to caller
                        
                        ; flash the cursor at the current position
                        ; (this sub-routine is called by CH3 timer ISR)
0784: 3AD681   [13]     FLASHCURSOR:    ld      A,(CRSR_STATE)  ; now, check the cursor
0787: A7       [17]                     and     A               ; cursor off (A=0)?
0788: C8       [22|28]                  ret     Z               ; yes, return
0789: 3ABB81   [35]                     ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
078C: E620     [42]                     and     $20             ; check if it's time to flash the cursor (check bit #6)
078E: 21D781   [52]                     ld      HL,LSTCSRSTA    ; load address of cell that stores the last cursor state
0791: 46       [59]                     ld      B,(HL)          ; load last state
0792: B8       [63]                     cp      B               ; compare current state with last state
0793: C8       [68|74]                  ret     Z               ; same state, no change required - exit
0794: 77       [75]                     ld      (HL),A          ; save new state
0795: F5       [86]                     push    AF              ; store A (keep state for later use)
0796: CDAE06   [103]                    call    LOAD_CRSR_POS   ; load current cursor position into HL
0799: F1       [113]                    pop     AF              ; recover current state
079A: 06FF     [120]                    ld      B,$FF           ; cursor char
079C: FE20     [127]                    cp      $20             ; is the cursor on video (A == $20)?
079E: 2804     [134|139]                jr      Z,PUTCRSCHR     ; yes, jump over
07A0: 3AD581   [147]                    ld      A,(SCR_ORG_CHR) ; no, load the original char
07A3: 47       [151]                    ld      B,A             ; move char into B
07A4: 78       [ 4]     PUTCRSCHR:      ld      A,B             ; recover char from B
07A5: C34906   [14]                     jp      WRITE_VIDEO_LOC ; print cursor/char at the current position & return
                        
                        
                        ; delete the char at the left of the cursor
07A8: CDE407   [17]     BACKSPACE:      call    MVCRS2LFT       ; prepare to move cursor to left
07AB: CDA506   [34]                     call    RSTCHRCRS       ; restore char under the cursor
07AE: CD9006   [51]                     call    NEWCRSRCOORD    ; set new cursor's coordinates
07B1: CDAE06   [68]                     call    LOAD_CRSR_POS   ; find address of new video cell
07B4: AF       [72]                     xor     A               ; null char
07B5: CD4906   [89]                     call    WRITE_VIDEO_LOC ; write into video cell
07B8: C38006   [99]                     jp      MOVSHOWCRS      ; move cursor to the new location and set it ON
                        
                        
                        ; move cursor to left
07BB: F5       [11]     CURSORLEFT:     push    AF              ; store A
07BC: 3AD181   [24]                     ld      A,(SCR_CURS_X)  ; load cursor X into A
07BF: A7       [28]                     and     A               ; is it at the most left of the screen (X=0)?
07C0: 280C     [35|40]                  jr      Z,CHCKYPOS      ; yes, check Y position
07C2: 3D       [39]                     dec     A               ; no, decrement X
07C3: 32D381   [52]                     ld      (SCR_CUR_NX),A  ; store new X
07C6: 3AD281   [65]                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
07C9: 32D481   [78]                     ld      (SCR_CUR_NY),A  ; no move over Y axis
07CC: 1811     [90]                     jr      CONTCRSLFT      ; go on moving cursor
07CE: 3AD281   [13]     CHCKYPOS:       ld      A,(SCR_CURS_Y)  ; load cursor Y
07D1: A7       [17]                     and     A               ; is it at the most top of the screen (Y=0)?
07D2: 280E     [24|29]                  jr      Z,EXITCURSORLEFT; yes, exit doing nothing
07D4: 3D       [28]                     dec     A               ; no, decrement Y
07D5: 32D481   [41]                     ld      (SCR_CUR_NY),A  ; store new Y
07D8: 3ACB81   [54]                     ld      A,(SCR_SIZE_W)  ; load current screen width
07DB: 3D       [58]                     dec     A               ; cursor to the most right position (width-0)
07DC: 32D381   [71]                     ld      (SCR_CUR_NX),A  ; set new cursor X
07DF: CD7A06   [17]     CONTCRSLFT:     call    MOVCRS          ; move cursor into new position
07E2: F1       [10]     EXITCURSORLEFT: pop     AF              ; restore A
07E3: C9       [20]                     ret                     ; return to caller
                        
                        ; move cursor 1 position to the left
07E4: 3AD181   [13]     MVCRS2LFT:      ld      A,(SCR_CURS_X)  ; load cursor X into A
07E7: A7       [17]                     and     A               ; is it at the most left of the screen (X=0)?
07E8: 280B     [24|29]                  jr      Z,CHKYPOS       ; yes, check Y position
07EA: 3D       [28]                     dec     A               ; no, decrement X
07EB: 32D381   [41]                     ld      (SCR_CUR_NX),A  ; store new X
07EE: 3AD281   [54]                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
07F1: 32D481   [67]                     ld      (SCR_CUR_NY),A  ; no move over Y axis
07F4: C9       [77]                     ret                     ; go on moving cursor
07F5: 3AD281   [13]     CHKYPOS:        ld      A,(SCR_CURS_Y)  ; load cursor Y
07F8: A7       [17]                     and     A               ; is it at the most top of the screen (Y=0)?
07F9: 28E7     [24|29]                  jr      Z,EXITCURSORLEFT; yes, exit doing nothing
07FB: 3D       [28]                     dec     A               ; no, decrement Y
07FC: 32D481   [41]                     ld      (SCR_CUR_NY),A  ; store new Y
07FF: 3ACB81   [54]                     ld      A,(SCR_SIZE_W)  ; load current screen width
0802: 3D       [58]                     dec     A               ; cursor to the most right position (width-1)
0803: 32D381   [71]                     ld      (SCR_CUR_NX),A  ; set new cursor X
0806: C9       [81]                     ret                     ; return to caller
                        
                        ; move cursor up
0807: F5       [11]     CURSORUP:       push    AF              ; store A
0808: 3AD281   [24]                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
080B: A7       [28]                     and     A               ; is it at the most top of the screen (Y=0)?
080C: 2810     [35|40]                  jr      Z,EXITCURSORUP  ; yes, exit doing nothing
080E: 3D       [39]                     dec     A               ; no, decrement Y
080F: 32D481   [52]                     ld      (SCR_CUR_NY),A  ; store new Y
0812: 3AD181   [65]                     ld      A,(SCR_CURS_X)  ; load current cursor X
0815: 32D381   [78]                     ld      (SCR_CUR_NX),A  ; set new cursor X
0818: CDA506   [95]                     call    RSTCHRCRS       ; restore char under the cursor and print it
081B: CD7A06   [112]                    call    MOVCRS          ; move cursor into new position
081E: F1       [10]     EXITCURSORUP:   pop     AF              ; restore A
081F: C9       [20]                     ret                     ; return to caller
                        
                        
                        ; move cursor to right
0820: F5       [11]     CURSORRIGHT:    push    AF              ; store A
0821: C5       [22]                     push    BC              ; store B
0822: 3ACB81   [35]                     ld      A,(SCR_SIZE_W)  ; load current screen width (in text modes it's 32 or 40)
0825: 3D       [39]                     dec     A               ; decrement it (most right can only be 31 or 39)
0826: 47       [43]                     ld      B,A             ; move A into B
0827: 3AD181   [56]                     ld      A,(SCR_CURS_X)  ; load cursor X into A    
082A: B8       [60]                     cp      B               ; is cursor at the most right position on the screen?
082B: 300C     [67|72]                  jr      NC,CHCKYPOS2    ; yes, so jump to check Y position
082D: 3C       [71]                     inc     A               ; no, so increment X
082E: 32D381   [84]                     ld      (SCR_CUR_NX),A  ; store new X
0831: 3AD281   [97]                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
0834: 32D481   [110]                    ld      (SCR_CUR_NY),A  ; no move over Y axis
0837: 1813     [122]                    jr      CONTCRSRGT      ; go on moving cursor
0839: 3ACC81   [13]     CHCKYPOS2:      ld      A,(SCR_SIZE_H)  ; load screen height
083C: 3D       [17]                     dec     A               ; decrement it (last row can only be 23)
083D: 47       [21]                     ld      B,A             ; move bottom into B
083E: 3AD281   [34]                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
0841: B8       [38]                     cp      B               ; is the cursor at the bottom of the screen?
0842: 300E     [45|50]                  jr      NC,EXITCURSORRGHT; yes, exit doing nothing
0844: 3C       [49]                     inc     A               ; no, increment Y
0845: 32D481   [62]                     ld      (SCR_CUR_NY),A  ; store new Y
0848: AF       [66]                     xor     A               ; move cursor to top left
0849: 32D381   [79]                     ld      (SCR_CUR_NX),A  ; store new X
084C: CDA506   [17]     CONTCRSRGT:     call    RSTCHRCRS       ; restore char under the cursor and print it
084F: CD7A06   [34]                     call    MOVCRS          ; move cursor into new position
0852: C1       [10]     EXITCURSORRGHT: pop     BC              ; retrieve BC
0853: F1       [20]                     pop     AF              ; restore A
0854: C9       [30]                     ret                     ; return to caller
                        
                        
                        ; move cursor down
0855: F5       [11]     CURSORDOWN:     push    AF              ; store A
0856: C5       [22]                     push    BC              ; store B
0857: 3ACC81   [35]                     ld      A,(SCR_SIZE_H)  ; load current screen height (in text modes it's 24)
085A: 3D       [39]                     dec     A               ; decrement it (positions can only vary between 0 and 23)
085B: 47       [43]                     ld      B,A             ; move X into B
085C: 3AD281   [56]                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A             
085F: B8       [60]                     cp      B               ; is current cursor position < 23?
0860: 3010     [67|72]                  jr      NC,EXITCURSORDOWN; no, exit doing nothing
0862: 3C       [71]                     inc     A               ; yes, increment Y
0863: 32D481   [84]                     ld      (SCR_CUR_NY),A  ; store new Y
0866: 3AD181   [97]                     ld      A,(SCR_CURS_X)  ; load current cursor X
0869: 32D381   [110]                    ld      (SCR_CUR_NX),A  ; set new cursor X
086C: CDA506   [127]                    call    RSTCHRCRS       ; restore char under the cursor and print it
086F: CD7A06   [144]                    call    MOVCRS          ; move cursor into new position
0872: C1       [10]     EXITCURSORDOWN: pop     BC              ; retrieve BC
0873: F1       [20]                     pop     AF              ; retrieve A
0874: C9       [30]                     ret                     ; return to caller
                        
                        
                        ; set cursor on (visible on screen)
0875: F5       [11]     CURSOR_ON:      push    AF              ; store AF
0876: 3AD681   [24]                     ld      A,(CRSR_STATE)  ; load cursor state
0879: FE01     [31]                     cp      $01             ; is it on?
087B: 280C     [38|43]                  jr      Z,EXITCURSOR_ON ; yes, so nothing to do
087D: 3ACC81   [51]                     ld      A,(SCR_SIZE_H)  ; check the video mode
0880: FE30     [58]                     cp      $30             ; graphics 2 or 3 (if value>=48)?
0882: 3005     [65|70]                  jr      NC,EXITCURSOR_ON; yes, so exit (no cursor in graphics 2 or 3)
0884: 3E01     [72]                     ld      A,$01           ; cursor state ON
0886: 32D681   [85]                     ld      (CRSR_STATE),A  ; set state
0889: F1       [10]     EXITCURSOR_ON:  pop     AF              ; restore AF
088A: C9       [20]                     ret                     ; return to caller
                        
                        ; set cursor off (invisible on screen)
088B: F5       [11]     CURSOR_OFF:     push    AF              ; store AF
088C: AF       [15]                     xor     A               ; cursor state OFF
088D: 32D681   [28]                     ld      (CRSR_STATE),A  ; set state
0890: F1       [38]                     pop     AF              ; restore AF
0891: C9       [48]                     ret
                        
                        ; scroll the screen 1 row up
0892: AF       [ 4]     SCROLLUP:       xor     A
0893: 32D881   [17]                     ld      (PRNTVIDEO),A
0896: 2ACF81   [33]                     ld      HL,(SCR_NAM_TB) ; start address of the name table
0899: 220C82   [49]                     ld      (VIDTMP1),HL    ; store address of the destination row (1st row of the screen)
089C: 3ACB81   [62]                     ld      A,(SCR_SIZE_W)  ; load the screen width
089F: 5F       [66]                     ld      E,A             ; move width into E
08A0: 1600     [73]                     ld      D,$00           ; reset D
08A2: 19       [84]                     add     HL,DE           ; HL now contains the address of the source row (2nd row of the screen)
08A3: 220E82   [100]                    ld      (VIDTMP2),HL    ; store address of source row
08A6: 3ACC81   [113]                    ld      A,(SCR_SIZE_H)  ; load the screen height
08A9: 3D       [117]                    dec     A               ; decrement the # of rows: now, A contains the # of rows to be moved
08AA: 47       [121]                    ld      B,A             ; move # of rows into B
08AB: 3ACB81   [13]     SCROLLNXTRW:    ld      A,(SCR_SIZE_W)  ; (re)load the screen width
08AE: 5F       [17]                     ld      E,A             ; move width into E
08AF: 2A0E82   [33]                     ld      HL,(VIDTMP2)    ; load source address
08B2: 0E32     [40]                     ld      C,VDP_SET       ; VDP setting mode
08B4: ED69     [52]                     out     (C),L           ; low byte of source
08B6: ED61     [64]                     out     (C),H           ; high byte of source
08B8: 21E481   [74]                     ld      HL,VIDEOBUFF    ; load address of the first cell of the video buffer
08BB: 0E30     [81]                     ld      C,VDP_DAT       ; VDP data mode
08BD: ED78     [12]     LOADNEXTCOL:    in      A,(C)           ; load char
08BF: 77       [19]                     ld      (HL),A          ; store char
08C0: 23       [25]                     inc     HL              ; next cell of the buffer
08C1: 1D       [29]                     dec     E               ; count the chars to be read
08C2: 20F9     [36|41]                  jr      NZ,LOADNEXTCOL  ; repeat until we read the entire row
08C4: 3ACB81   [49]                     ld      A,(SCR_SIZE_W)  ; reload the screen width
08C7: 5F       [53]                     ld      E,A             ; move # of rows into E
08C8: 1600     [60]                     ld      D,$00           ; reset D
08CA: 2A0C82   [76]                     ld      HL,(VIDTMP1)    ; load address of destination row
08CD: E5       [87]                     push    HL              ; store HL
08CE: 2A0E82   [103]                    ld      HL,(VIDTMP2)    ; current source will be..
08D1: 220C82   [119]                    ld      (VIDTMP1),HL    ; ..new destination
08D4: 19       [130]                    add     HL,DE           ; address of new
08D5: 220E82   [146]                    ld      (VIDTMP2),HL    ; source row
08D8: E1       [156]                    pop     HL              ; restore address of current destination row
08D9: CBF4     [164]                    set     6,H             ; writing mode
08DB: 0E32     [171]                    ld      C,VDP_SET       ; VDP setting mode
08DD: ED69     [183]                    out     (C),L           ; low byte
08DF: ED61     [195]                    out     (C),H           ; high byte of address
08E1: 21E481   [205]                    ld      HL,VIDEOBUFF    ; video buffer address
08E4: 0E30     [212]                    ld      C,VDP_DAT       ; VDP data mode
08E6: 7E       [ 7]     WRITEBUF:       ld      A,(HL)          ; load char
08E7: ED79     [19]                     out     (C),A           ; send char
08E9: 23       [25]                     inc     HL              ; increment buffer index
08EA: 1D       [29]                     dec     E               ; next row
08EB: 20F9     [36|41]                  jr      NZ,WRITEBUF     ; repeat until 0
08ED: 10BC     [44|49]                  djnz    SCROLLNXTRW     ; repeat for the entire screen
08EF: 3ACB81   [57]                     ld      A,(SCR_SIZE_W)  ; reload screen width
08F2: 47       [61]                     ld      B,A             ; cells to empty into B
08F3: AF       [65]                     xor     A               ; null char
08F4: 0E32     [72]                     ld      C,VDP_SET       ; VDP set mode
08F6: 2A0C82   [88]                     ld      HL,(VIDTMP1)    ; load address of the last row
08F9: CBF4     [96]                     set     6,H             ; writing mode
08FB: ED69     [108]                    out     (C),L           ; low byte then..
08FD: ED61     [120]                    out     (C),H           ; high byte of address
08FF: 0E30     [127]                    ld      C,VDP_DAT       ; VDP data mode
0901: ED79     [12]     RPTEMPTYROW:    out     (C),A           ; empty cell
0903: 00       [16]                     nop                     ; delay
0904: 00       [20]                     nop
0905: 10FA     [28|33]                  djnz    RPTEMPTYROW     ; repeat until the last row has been cleaned
0907: 3E01     [35]                     ld      A,$01
0909: 32D881   [48]                     ld      (PRNTVIDEO),A   ; set print-on-video on
090C: C9       [58]                     ret                     ; return to caller
                        
                        ; carriage return: first, it looks for char $00 at the beginning of the line (look for the first null char),
                        ; then it starts sendind every char it finds on the screen to the terminal buffer of the BASIC interpreter
                        ; until another null char is found. Finally, move to the next line and position the cursor at the beginning
                        ; of the row (equivalent to CR+LF), then gets back control to the screen editor to let it interpret the line
81DC:                   CUR_POS         equ     TMPBFR1         ; cursor position
81DE:                   SRTTXT          equ     TMPBFR2         ; start of text line
81E0:                   ENDTXT          equ     TMPBFR3         ; end of text line
090D:                   CRGRETURN:      ; preliminary: disable cursor if on, and retrieve char under it
090D: 3AD681   [13]                     ld      A,(CRSR_STATE)  ; recover cursor state
0910: 32E281   [26]                     ld      (TMPBFR4),A     ; store status
0913: A7       [30]                     and     A               ; is cursor on?
0914: C48B08   [40|47]                  call    NZ,CURSOR_OFF   ; yes, so set cursor off
0917: CDA506   [57]                     call    RSTCHRCRS       ; restore char under it
                                        ; first, check if cursor if off, so that we just interpret return as a new line command
091A: 3A1682   [70]                     ld      A,(KBDNPT)      ; check if input from keyboad
091D: A7       [74]                     and     A               ; if 0, input is not from keyboard...
091E: CA9709   [84|84]                  jp      Z,PRNTRETURN    ; ...so just print a carriage return; otherwise, interpret the return
                                        ; first part: look for the beginning of the text line on screen
0921: CDAE06   [101]                    call    LOAD_CRSR_POS   ; load cursor position into HL
0924: 22DC81   [117]                    ld      (CUR_POS),HL    ; store it
0927: ED5BCF81 [137]                    ld      DE,(SCR_NAM_TB) ; load VRAM address of top-left cell of screen ("home")
092B: E5       [11]     RPTNLLSRC:      push    HL
092C: CD153E   [28]                     call    CMP16           ; check if at "home"
092F: E1       [38]                     pop     HL
0930: CA3B09   [48|48]                  jp      Z,CNTNULL       ; yes, exit because there is nothing before
0933: 2B       [54]                     dec     HL              ; go 1 step back
0934: CD3406   [71]                     call    READ_VIDEO_LOC  ; read char of current position
0937: A7       [75]                     and     A               ; is it $00 (null char)?
0938: 20F1     [82|87]                  jr      NZ,RPTNLLSRC    ; no, continue searching
093A: 23       [88]                     inc     HL              ; move 1 step forward to go back to the last cell with something in
                                        ; second part: look for the ending of the text on screen
093B: 22DE81   [16]     CNTNULL:        ld      (SRTTXT),HL     ; store beginning of text
093E: 3ACC81   [29]                     ld      A,(SCR_SIZE_H)
0941: 5F       [33]                     ld      E,A             ; load screen height into DE
0942: 3ACB81   [46]                     ld      A,(SCR_SIZE_W)
0945: 6F       [50]                     ld      L,A             ; load screen width into HL
0946: AF       [54]                     xor     A
0947: 67       [58]                     ld      H,A
0948: 57       [62]                     ld      D,A
0949: CD203E   [79]                     call    MUL16           ; multiply HL times DE to get the screen size
094C: ED5BCF81 [99]                     ld      DE,(SCR_NAM_TB) ; load screen name table start address into DE
0950: 19       [110]                    add     HL,DE           ; get the address...
0951: 2B       [116]                    dec     HL              ; ...of the "last" video cell
0952: EB       [120]                    ex      DE,HL           ; store address into DE
0953: 2ADC81   [136]                    ld      HL,(CUR_POS)    ; retrieve original cursor position
0956: E5       [11]     RPTNLLSRC2:     push    HL
0957: CD153E   [28]                     call    CMP16           ; check if at last position on screen (bottom right corner)
095A: E1       [38]                     pop     HL
095B: CA6509   [48|48]                  jp      Z,CNTNULL2      ; if yes, exit because these is nothing after
095E: 23       [54]                     inc     HL              ; 1 more step forward
095F: CD3406   [71]                     call    READ_VIDEO_LOC  ; read char of current position
0962: A7       [75]                     and     A               ; is it $00 (null char)?
0963: 20F1     [82|87]                  jr      NZ,RPTNLLSRC2   ; no, continue searching
0965: 22E081   [16]     CNTNULL2:       ld      (ENDTXT),HL     ; store ending of text line
0968: ED5BDE81 [36]                     ld      DE,(SRTTXT)     ; load beginning of text line
096C: A7       [40]                     and     A               ; clear Carry
096D: ED52     [55]                     sbc     HL,DE           ; how many chars?
096F: 2826     [62|67]                  jr      Z,PRNTRETURN    ; no chars found (HL-DE=0), so just print return & leave
                                        ;---    central part: send the text on the screen to the interpreter
0971: 2ADE81   [78]                     ld      HL,(SRTTXT)     ; load beginning of text line
0974: ED5BE081 [98]                     ld      DE,(ENDTXT)     ; load ending of text line
0978: CD3406   [17]     SNDCHRTOBFR:    call    READ_VIDEO_LOC  ; read char
097B: E5       [28]                     push    HL
097C: CD3601   [45]                     call    CHARINTOBFR     ; send char to buffer
097F: E1       [55]                     pop     HL
0980: 23       [61]                     inc     HL              ; go to next char
0981: E5       [72]                     push    HL              ; store HL
0982: CD153E   [89]                     call    CMP16           ; check if DE=HL (finish chars)
0985: E1       [99]                     pop     HL
0986: 20F0     [106|111]                jr      NZ,SNDCHRTOBFR  ; no, repeat
0988: 3E0D     [113]                    ld      A,CR            ; yes, so now send carriage return
098A: CD3601   [130]                    call    CHARINTOBFR     ; send to buffer
098D: 2AE081   [146]                    ld      HL,(ENDTXT)     ; recover address of last char of input text
0990: CDD206   [163]                    call    HL2XY           ; retrieve X,Y from address
0993: 7D       [167]                    ld      A,L             ; move Y into A (we don't need X anymore)
0994: 32D281   [180]                    ld      (SCR_CURS_Y),A  ; store new Y
                                        ;---    final part: go at the beginning of a new line on the screen
0997: AF       [ 4]     PRNTRETURN:     xor     A               ; move to col 0
0998: 32D181   [17]                     ld      (SCR_CURS_X),A  ; store new X
099B: 3AD281   [30]                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
099E: 3C       [34]                     inc     A               ; new row
099F: 21CC81   [44]                     ld      HL,SCR_SIZE_H   ; load address of cell that keeps screen height
09A2: BE       [51]                     cp      (HL)            ; is the cursor over the bottom of the screen?
09A3: 3806     [58|63]                  jr      C,ADDNEWLINE    ; no, jump over
09A5: 3D       [62]                     dec     A               ; yes, so come back 1 row, then...
09A6: F5       [73]                     push    AF              ; (store A)
09A7: CD9208   [90]                     call    SCROLLUP        ; ...scroll the screen before to...
09AA: F1       [100]                    pop     AF              ; (retrieve A)
09AB: 32D281   [13]     ADDNEWLINE:     ld      (SCR_CURS_Y),A  ; ...store new Y
09AE: 3AE281   [26]                     ld      A,(TMPBFR4)     ; retrieve cursor state
09B1: A7       [30]                     and     A               ; was it off (A=0)?
09B2: C47508   [40|47]                  call    NZ,CURSOR_ON    ; no, set cursor on
09B5: C37006   [50]                     jp      POS_CURSOR      ; position cursor to new location & return to caller
                        
                        ; ------------------------------------------------------------------------------
                                        ; this table contains the values of the offsets to be added to
                                        ; the starting address of the name table to find the correct
                                        ; value of the first cell of the corresponding row
                                        ; (by doing so, it's faster than doing a multipication)
                                        ; table for graphics 1 text mode: 32 cols
09B8: 00002000          POS_TB_CRS_32   defw    $0000,$0020,$0040,$0060,$0080,$00A0,$00C0,$00E0
09BC: 40006000          
09C0: 8000A000          
09C4: C000E000          
09C8: 00012001                          defw    $0100,$0120,$0140,$0160,$0180,$01A0,$01C0,$01E0
09CC: 40016001          
09D0: 8001A001          
09D4: C001E001          
09D8: 00022002                          defw    $0200,$0220,$0240,$0260,$0280,$02A0,$02C0,$02E0
09DC: 40026002          
09E0: 8002A002          
09E4: C002E002          
                                        ; table for pure text mode: 40 cols
09E8: 00002800          POS_TB_CRS_40   defw    $0000,$0028,$0050,$0078,$00A0,$00C8,$00F0,$0118
09EC: 50007800          
09F0: A000C800          
09F4: F0001801          
09F8: 40016801                          defw    $0140,$0168,$0190,$01B8,$01E0,$0208,$0230,$0258
09FC: 9001B801          
0A00: E0010802          
0A04: 30025802          
0A08: 8002A802                          defw    $0280,$02A8,$02D0,$02F8,$0320,$0348,$0370,$0398
0A0C: D002F802          
0A10: 20034803          
0A14: 70039803          
                        
                        ; ------------------------------------------------------------------------------
                        ; reset VRAM
0A18: AF       [ 4]     EMPTY_VRAM:     xor     A               ; reg.A cleared: we fill up VRAM with $00
0A19: 67       [ 8]                     ld      H,A
0A1A: 6F       [12]                     ld      L,A             ; reset HL
0A1B: CD1406   [29]                     call    SETVDPADRS      ; set address of first VRAM cell to $0000
0A1E: 0640     [36]                     ld      B,$40           ; $40 pages of RAM...
0A20: 57       [40]                     ld      D,A             ; ...each one with $100 cells (tot. $4000 bytes)
0A21: 0E30     [47]                     ld      C,VDP_DAT       ; VDP data mode
0A23: ED79     [12]     EMPTVRM:        out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
0A25: 14       [16]                     inc     D               ; next cell
0A26: 00       [20]                     nop
0A27: 20FA     [27|32]                  jr      NZ,EMPTVRM      ; repeat until page is fully cleared
0A29: 10F8     [35|40]                  djnz    EMPTVRM         ; repeat for $40 pages
0A2B: C9       [45]                     ret                     ; return to caller
                        
                        ; clear video registers in SRAM
0A2C: 21CB81   [10]     CLR_RAM_REG:    ld      HL,SCR_SIZE_W   ; address of first register
0A2F: AF       [14]                     xor     A               ; $00 to clean the registers
0A30: 0645     [21]                     ld      B,CHASNDDTN-SCR_SIZE_W; how many bytes (registers) to clean (dinamically calculated)
0A32: 77       [ 7]     RSTVDPRAMREG:   ld      (HL),A          ; reset register
0A33: 23       [13]                     inc     HL              ; next register
0A34: 10FC     [21|26]                  djnz    RSTVDPRAMREG    ; repeat
0A36: C9       [31]                     ret                     ; return to caller
                        
                        ; ------------------------------------------------------------------------------
                        ; set a specific graphics mode, passed into reg. E
0A37: 0608     [ 7]     SET_GFX_MODE:   ld      B,$08           ; 8 registers means 8 bytes..
0A39: CB23     [15]                     sla     E               ; multiply E by 8..
0A3B: CB23     [23]                     sla     E               ; so that reg. E can point..
0A3D: CB23     [31]                     sla     E               ; to the correct settings
0A3F: 1600     [ 7]     SET_GFX_MODE2:  ld      D,$00           ; reset D
0A41: 21740A   [17]                     ld      HL,VDPMODESET   ; pointer to register settings | <= here points the SHOW_LOGO sub-routine
0A44: 19       [28]                     add     HL,DE           ; add offset to get the correct set of values for the required mode
0A45: 3E80     [35]                     ld      A,$80           ; start with REG0 ($80+register number)
0A47: 0E32     [42]                     ld      C,VDP_SET       ; VDP set
0A49: 56       [ 7]     LDREGVLS:       ld      D,(HL)          ; load register's value
0A4A: ED51     [19]                     out     (C),D           ; send data to VDP
0A4C: ED79     [31]                     out     (C),A           ; indicate the register to send data to
0A4E: 3C       [35]                     inc     A               ; next register
0A4F: 23       [41]                     inc     HL              ; next value
0A50: 10F7     [49|54]                  djnz    LDREGVLS        ; repeat for 8 registers
0A52: C9       [59]                     ret
                        
                        ; ------------------------------------------------------------------------------
0A53:                   LOADCHARSET:    ; reg. A contains the video mode
                                        ; reg. HL contains address of pattern table into VRAM
0A53: 0600     [ 7]                     ld      B,$00           ; 0=256 chars to load (complete charset)
0A55: CBF4     [15]                     set     $06,H           ; add $4000 to address to indicate that we want to write into VRAM
0A57: 0E32     [22]                     ld      C,VDP_SET       ; load VDP address into C
0A59: ED69     [34]                     out     (C),L           ; send low byte of address
0A5B: ED61     [46]                     out     (C),H           ; send high byte
0A5D: 21783E   [56]                     ld      HL,CHRST68      ; starting address of 6x8 charset into ROM
0A60: A7       [60]                     and     A               ; is it text mode (A=0)?
0A61: 2803     [67|72]                  jr      Z,NXTCHAR       ; yes, so jump to load chars into VRAM
0A63: 217846   [77]                     ld      HL,CHRST88      ; no, so we change and load the 8x8 charset
0A66: 1608     [ 7]     NXTCHAR:        ld      D,$08           ; 8 bytes per pattern char
0A68: 0E30     [14]                     ld      C,VDP_DAT       ; VDP data mode
0A6A: 7E       [ 7]     SENDCHRPTRNS:   ld      A,(HL)          ; load byte to send to VDP
0A6B: ED79     [19]                     out     (C),A           ; write byte into VRAM
0A6D: 23       [25]                     inc     HL              ; inc byte pointer
0A6E: 15       [29]                     dec     D               ; 8 bytes sents (0 char)?
0A6F: 20F9     [36|41]                  jr      NZ,SENDCHRPTRNS ; no, continue
0A71: 10F3     [44|49]                  djnz    NXTCHAR         ; yes, decrement chars counter and continue for all the chars
0A73: C9       [54]                     ret                     ; return to caller
                        
                        ;------------------------------------------------------------------------------
                        ; NAME TABLE:       buffer video - contains the chars to be shown on video
                        ; PATTERN TABLE:    charset - contains the chars/tiles to be loaded into the name table
                        ; COLOR TABLE:      color settings for chars/tiles
                        
                                        ; VDP register settings for a text display
0A74: 00                VDPMODESET      defb    %00000000       ; reg.0: external video off
0A75: D0                                defb    %11010000       ; reg.1: 16K VRAM, video on, int. off, text mode (40x24)
0A76: 02                                defb    $02             ; reg.2: name table set to $0800 ($02x$400)
0A77: 00                                defb    $00             ; reg.3: not used in text mode
0A78: 00                                defb    $00             ; reg.4: pattern table set to $0000
0A79: 00                                defb    $00             ; reg.5: not used in text mode
0A7A: 00                                defb    $00             ; reg.6: not used in text mode
0A7B: F5                                defb    $f5             ; reg.7: white text on light blue background
                        
0A7C:                   VDPMODESET1     ; VDP register settings for a graphics 1 mode
0A7C: 00                                defb    %00000000       ; reg.0: ext. video off
0A7D: C0                                defb    %11000000       ; reg.1: 16K Vram; video on, int off, graphics mode 1, sprite size 8x8, sprite magn. 0
0A7E: 06                                defb    $06             ; reg.2: name table address: $1800
0A7F: 80                                defb    $80             ; reg.3: color table address: $2000
0A80: 00                                defb    $00             ; reg.4: pattern table address: $0000
0A81: 36                                defb    $36             ; reg.5: sprite attr. table address: $1B00
0A82: 07                                defb    $07             ; reg.6: sprite pattern table addr.: $3800
0A83: 05                                defb    $05             ; reg.7: backdrop color (light blue)
                        
0A84:                   VDPMODESET2     ; VDP register settings for a graphics 2 mode
0A84: 02                                defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
0A85: C0                                defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
0A86: 06                                defb    $06             ; reg.2: name table addr.: $1800
0A87: FF                                defb    $FF             ; reg.3: color table addr.: $2000
0A88: 03                                defb    $03             ; reg.4: pattern table addr.: $0000
0A89: 36                                defb    $36             ; reg.5: sprite attr. table addr.: $1B00
0A8A: 07                                defb    $07             ; reg.6: sprite pattern table addr.: $3800
0A8B: 05                                defb    $05             ; reg.7: backdrop color: light blue
                        
0A8C:                   VDPMODESETMC    ; VDP register settings for a multicolor mode
0A8C: 00                                defb    %00000000       ; reg.0: ext. video dis.
0A8D: CB                                defb    %11001011       ; reg.1: 16K VRAM, video on, INT off, multicolor mode, sprite size 8x8, sprite magn. 0
0A8E: 02                                defb    $02             ; reg.2: name table addr.: $0800
0A8F: 00                                defb    $00             ; reg.3: don't care
0A90: 00                                defb    $00             ; reg.4: pattern table addr.: $0000
0A91: 36                                defb    $36             ; reg.5: sprite attr. table addr.: $1B00
0A92: 07                                defb    $07             ; reg.6: sprite pattern table addr.: $3800
0A93: 0F                                defb    $0F             ; reg.7: backdrop color (white)
                        
0A94:                   VDPMODESETEX2   ; VDP register settings for an extended graphics 2 mode
0A94: 02                                defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
0A95: C0                                defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
0A96: 0E                                defb    $0E             ; reg.2: name table addr.: $3800
0A97: 9F                                defb    $9F             ; reg.3: color table addr.: $2000
0A98: 00                                defb    $00             ; reg.4: pattern table addr.: $0000
0A99: 76                                defb    $76             ; reg.5: sprite attr. table addr.: $3B00
0A9A: 03                                defb    $03             ; reg.6: sprite pattern table addr.: $1800
0A9B: 05                                defb    $05             ; reg.7: backdrop color: light blue
                        
0A9C:                   LM80CLOGO       ; patterns to compose the splash screen logo
0A9C: 00000000                          defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0AA0: 00...             
0ABC: 00000F0A                          defb    0,0,15,10,11,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0AC0: 0B100000          
0AC4: 00000000          
0AC8: 00...             
0ADC: 00000D17                          defb    0,0,13,23,0,12,0,0,0,1,0,0,0,20,0,0,6,5,6,21,22,7,6,21,22,7,6,1,1,7,0,0
0AE0: 000C0000          
0AE4: 00010000          
0AE8: 00140000          
0AEC: 06050615          
0AF0: 16070615          
0AF4: 16070601          
0AF8: 01070000          
0AFC: 00000D00                          defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,20,6,1,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
0B00: 000C0000          
0B04: 00010000          
0B08: 00011406          
0B0C: 01050305          
0B10: 03050305          
0B14: 03050305          
0B18: 03050000          
0B1C: 00000D00                          defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,1,1,1,5,9,20,19,8,3,5,19,5,3,5,0,0,0,0
0B20: 000C0000          
0B24: 00010000          
0B28: 00010101          
0B2C: 01050914          
0B30: 13080305          
0B34: 13050305          
0B38: 00000000          
0B3C: 00000D00                          defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,8,3,5,6,21,22,7,3,1,22,5,3,5,0,0,0,0
0B40: 000C0000          
0B44: 00010000          
0B48: 00010008          
0B4C: 03050615          
0B50: 16070301          
0B54: 16050305          
0B58: 00000000          
0B5C: 00000D00                          defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,0,3,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
0B60: 000C0000          
0B64: 00010000          
0B68: 00010000          
0B6C: 03050305          
0B70: 03050305          
0B74: 03050305          
0B78: 03050000          
0B7C: 00000D00                          defb    0,0,13,0,0,12,0,0,0,1,4,4,0,1,0,0,3,5,9,20,19,8,9,20,19,8,9,1,1,8,0,0
0B80: 000C0000          
0B84: 00010404          
0B88: 00010000          
0B8C: 03050914          
0B90: 13080914          
0B94: 13080901          
0B98: 01080000          
0B9C: 00000E12                          defb    0,0,14,18,18,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0BA0: 12110000          
0BA4: 00000000          
0BA8: 00...             
0BBC: 00000000                          defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0BC0: 00...             
                        
                        ; incude the latest version of the PSG module
                        #include "../include/psg/psg-r315.asm"
                        ; ------------------------------------------------------------------------------
                        ; LM80C - PSG ROUTINES - R3.15
                        ; ------------------------------------------------------------------------------
                        ; The following code is intended to be used with LM80C Z80-based computer
                        ; designed by Leonardo Miliani. Code and computer schematics are released under
                        ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
                        ; kind of warranty: you can use them at your own risk.
                        ; You are free to use them for any non-commercial use: you are only asked to
                        ; maintain the copyright notices, include this advice and the note to the 
                        ; attribution of the original version to Leonardo Miliani, if you intend to
                        ; redistribuite them.
                        ; https://www.leonardomiliani.com
                        ; 
                        ; Please support me by visiting the following links:
                        ; Main project page: https://www.leonardomiliani.com
                        ; Schematics and code: https://github.com/leomil72/LM80C
                        ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
                        ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
                        ; ------------------------------------------------------------------------------
                        ;
                        ; ------------------------------------------------------------------------------
                        
                        ;------------------------------------------------------------------------------
                        ; configure the PSG
0BDC: 211082   [10]     initPSG:        ld      HL,CHASNDDTN    ; starting address of sound & keyboard RAM registers
0BDF: 060B     [17]                     ld      B,SERIALS_EN-CHASNDDTN; # of PSG sound & keyboard registers
0BE1: AF       [21]                     xor     A               ; reset A
0BE2: 77       [ 7]     EMPTSNDBFR:     ld      (HL),A          ; reset RAM register
0BE3: 23       [13]                     inc     HL              ; next register
0BE4: 10FC     [21|26]                  djnz    EMPTSNDBFR      ; repeat
0BE6: 0610     [ 7]     CLRPSGREGS:     ld      B,$10           ; 16 registers to set
0BE8: 21FA0B   [17]                     ld      HL,SNDREGCFG    ; starting address of register settings
0BEB: 1600     [24]                     ld      D,$00           ; first register
0BED: 7A       [ 4]     RSTPSG:         ld      A,D             ; register value
0BEE: CD340C   [21]                     call    SETSNDREG       ; select register
0BF1: 7E       [28]                     ld      A,(HL)          ; load value
0BF2: CD390C   [45]                     call    WRTSNDREG       ; write to register
0BF5: 14       [49]                     inc     D               ; next register
0BF6: 23       [55]                     inc     HL              ; next value
0BF7: 10F4     [63|68]                  djnz    RSTPSG          ; repeat for each register
0BF9: C9       [73]                     ret                     ; return to caller
                        
0BFA: 00000000          SNDREGCFG:      defb $00,$00,$00,$00,$00,$00,$00,%10111111
0BFE: 000000BF          
0C02: 00000000                          defb $00,$00,$00,$00,$00,$00,$ff,$ff
0C06: 0000FFFF          
                                        ; reg. 7: set I/O ch.A to OUTPUT, I/O ch.B to INPUT; set noise to OFF; set audio to OFF
                        
                        
                        ; routine to play a welcome beep on channel C (tone 4010) and to shut it off
0C0A: 21240C   [10]     WLCMBEEP:       ld      HL,WLCBPDAT     ; data address
0C0D: C3130C   [20]                     jp      SENDSND
0C10: 212C0C   [10]     NOBEEP:         ld      HL,NOBPDAT      ; data address
0C13: C5       [11]     SENDSND:        push    BC
0C14: 0604     [18]                     ld      B,$04           ; 4 pairs
0C16: 7E       [ 7]     RPTWLCMBP:      ld      A,(HL)          ; read register #
0C17: CD340C   [24]                     call    SETSNDREG
0C1A: 23       [30]                     inc     HL              ; next cell
0C1B: 7E       [37]                     ld      A,(HL)          ; read value
0C1C: CD390C   [54]                     call    WRTSNDREG
0C1F: 23       [60]                     inc     HL
0C20: 10F4     [68|73]                  djnz    RPTWLCMBP       ; repeat
0C22: C1       [78]                     pop     BC
0C23: C9       [88]                     ret                     ; return to caller
                        
0C24: 077B0456          WLCBPDAT:       defb    $07,%01111011,$04,$56,$05,$00,$0A,$0F
0C28: 05000A0F          
0C2C: 04000500          NOBPDAT:        defb    $04,$00,$05,$00,$0A,$00,$07,%01111111
0C30: 0A00077F          
                        
                        
                        ; select register on PSG
0C34: 0E40     [ 7]     SETSNDREG:      ld      C,PSG_REG       ; PSG register port
0C36: ED79     [19]                     out     (C),A           ; set register
0C38: C9       [29]                     ret                     ; return to caller
                        
                        ; send data to PSG
0C39: 0E41     [ 7]     WRTSNDREG:      ld      C,PSG_DAT       ; PSG data port
0C3B: ED79     [19]                     out     (C),A           ; send data
0C3D: C9       [29]                     ret                     ; return to caller
                        
                        ; manage the sounds' duration: each time this subroutine is called, it
                        ; decrements the single sound durations (measured in ms) and eventually
                        ; shut off the audio channel whose counter has reached 0.
                        ; (this sub-routine is called by CH3 timer ISR)
0C3E: DDE5     [15]     MNGSNDS:        push    IX              ; store IX
0C40: DD211082 [29]                     ld      IX,CHASNDDTN    ; starting address of tones duration
0C44: 0603     [36]                     ld      B,$03           ; 3 channels to check
0C46: 2601     [43]                     ld      H,$01           ; mixer channels: A=>bit 1, B=>bit 2, C=>bit 3
0C48: DD5E00   [19]     CHKSNDCH:       ld      E,(IX+0)        ; load LSB into E
0C4B: DD5601   [38]                     ld      D,(IX+1)        ; load MSB into D
0C4E: 7B       [42]                     ld      A,E             ; load E into A
0C4F: B2       [46]                     or      D               ; check that DE=0
0C50: 2831     [53|58]                  jr      Z,CNTCHKSND     ; yes, jump over
0C52: 1B       [59]                     dec     DE              ; no, so decrement DE
0C53: 7B       [63]                     ld      A,E             ; reload E into A...
0C54: DD7300   [82]                     ld      (IX+0),E        ; store new...
0C57: DD7201   [101]                    ld      (IX+1),D        ; ...duration and...
0C5A: B2       [105]                    or      D               ; ...do another check to see if DE=0
0C5B: 2026     [112|117]                jr      NZ,CNTCHKSND    ; no, so jump over
                                                                ; if yes, let's shut down the corresponding channel
                                                                ; to shut down a tone we disable it into the mixer
                                                                ; then set 0 into its tone registers
0C5D: 1607     [119]                    ld      D,$07           ; mixer register
0C5F: 0E40     [126]                    ld      C,PSG_REG       ; PSG register selector port
0C61: ED51     [138]                    out     (C),D           ; set mixer register
0C63: ED78     [150]                    in      A,(C)           ; load current value
0C65: B4       [154]                    or      H               ; set off the channel into the mixer (remember that 1=OFF)
0C66: ED51     [166]                    out     (C),D           ; select mixer register
0C68: 0E41     [173]                    ld      C,PSG_DAT       ; PSG data port
0C6A: ED79     [185]                    out     (C),A           ; send new value for the mixer
0C6C: 3E03     [192]                    ld      A,$03           ; three channels
0C6E: 90       [196]                    sub     B               ; find current channel (0->A, 1->B, 2->C)
0C6F: 87       [200]                    add     A,A             ; and find first register (A=>0, B=>2, C=>4)
0C70: 0E40     [207]                    ld      C,PSG_REG       ; PSG register selector port
0C72: ED79     [219]                    out     (C),A           ; select first tone register of channel
0C74: 2E00     [226]                    ld      L,$00           ; value 0 into L
0C76: 0E41     [233]                    ld      C,PSG_DAT       ; PSG data selector port
0C78: ED69     [245]                    out     (C),L           ; write 0 into register
0C7A: 0E40     [252]                    ld      C,PSG_REG       ; PSG register selector port
0C7C: 3C       [256]                    inc     A               ; next tone register
0C7D: ED79     [268]                    out     (C),A           ; select second tone register of channel
0C7F: 0E41     [275]                    ld      C,PSG_DAT       ; PSG data selector port
0C81: ED69     [287]                    out     (C),L           ; write 0 into register
0C83: DD23     [10]     CNTCHKSND:      inc     IX              ; set for...
0C85: DD23     [20]                     inc     IX              ; ...next channel...
0C87: CB24     [28]                     sla     H               ; shift left H 1 bit
0C89: 10BD     [36|41]                  djnz    CHKSNDCH        ; repeat for 3 channels
0C8B: DDE1     [50]                     pop     IX              ; restore IX
0C8D: C9       [60]                     ret                     ; return to caller
                        
                        ; read a specific row of the keyboard matrix, set by A
                        ; return read into A
0C8E: C5       [11]     READKBLN:       push    BC              ; store BC
0C8F: 060F     [18]                     ld      B,$0F           ; reg #15
0C91: 0E40     [25]                     ld      C,PSG_REG       ; PSG register port
0C93: ED41     [37]                     out     (C),B           ; select reg #15
0C95: 0E41     [44]                     ld      C,PSG_DAT       ; PSG data port
0C97: ED79     [56]                     out     (C),A           ; activate the row
0C99: 060E     [63]                     ld      B,$0E           ; register #14 (port B)
0C9B: 0E40     [70]                     ld      C,PSG_REG       ; PSG register port
0C9D: ED41     [82]                     out     (C),B           ; select reg. 14 (port B)
0C9F: ED78     [94]                     in      A,(C)           ; read register #14
0CA1: C1       [104]                    pop     BC              ; retrieve BC
0CA2: C9       [114]                    ret
                        
                        ; read the keyboard matrix to look for a key pressure
0CA3: 0E40     [ 7]     KEYBOARD:       ld      C,PSG_REG       ; PSG register port
0CA5: 0607     [14]                     ld      B,$07           ; set register #7...
0CA7: ED41     [26]                     out     (C),B           ; ...to work with
0CA9: ED78     [38]                     in      A,(C)           ; read register #7
0CAB: CBFF     [46]                     set     7,A             ; port A set to output
0CAD: CBB7     [54]                     res     6,A             ; port B set to input
0CAF: ED41     [66]                     out     (C),B           ; set register #7
0CB1: 0E41     [73]                     ld      C,PSG_DAT       ; PSG data port
0CB3: ED79     [85]                     out     (C),A           ; set I/O ports w/o altering the rest of the mixer
                                        ; check special keys (SHIFT/ALT/CTRL)
0CB5: 3EFD     [92]                     ld      A,%11111101     ; select SHIFT row
0CB7: CD8E0C   [109]                    call    READKBLN        ; read row
0CBA: CB5F     [117]                    bit     3,A             ; test if SHIFT key is pressed (4th bit is reset)
0CBC: 2005     [124|129]                jr      NZ,CHECKALT     ; no, so go on
0CBE: 211A82   [134]                    ld      HL,CONTROLKEYS  ; control key flags
0CC1: 3601     [144]                    ld      (HL),%00000001  ; set SHIFT flag, reset CTRL & ALT flags (currently multiply control keys are NOT supported)
0CC3: 3EFE     [ 7]     CHECKALT:       ld      A,%11111110     ; select ALT row
0CC5: CD8E0C   [24]                     call    READKBLN        ; read ALT row
0CC8: CB6F     [32]                     bit     5,A             ; test if ALT key is pressed (5th bit is reset)
0CCA: 2005     [39|44]                  jr      NZ,CHECKCTRL    ; no, so go on
0CCC: 211A82   [49]                     ld      HL,CONTROLKEYS  ; control key flags
0CCF: 3604     [59]                     ld      (HL),%00000100  ; set ALT flag, reset SHIFT & CTRL flag (currently multiply control keys are NOT supported)
0CD1: 3EFE     [ 7]     CHECKCTRL:      ld      A,%11111110     ; select CTRL row
0CD3: CD8E0C   [24]                     call    READKBLN        ; read CTRL row
0CD6: CB57     [32]                     bit     2,A             ; test if CTRL key is pressed (3rd bit is reset)
0CD8: 2005     [39|44]                  jr      NZ,CHECKKBD     ; no, so make a normal reading
0CDA: 211A82   [49]                     ld      HL,CONTROLKEYS  ; control key flags
0CDD: 3602     [59]                     ld      (HL),%00000010  ; set CTRL flag, reset SHIFT & ALT flags (currently multiply control keys are NOT supported)
0CDF: 0608     [ 7]     CHECKKBD:       ld      B,$08           ; 8 lines
0CE1: 3E7F     [14]                     ld      A,%01111111     ; start from the last line of the matrix
0CE3: 160F     [ 7]     RPTKBDRD:       ld      D,$0F           ; register #15 (port B)
0CE5: 0E40     [14]                     ld      C,PSG_REG       ; PSG register port
0CE7: ED51     [26]                     out     (C),D           ; select reg. #15
0CE9: 0E41     [33]                     ld      C,PSG_DAT       ; PSG data port
0CEB: ED79     [45]                     out     (C),A           ; activate 1 line (active line is grounded, i.e. with a LOW signal)
0CED: 5F       [49]                     ld      E,A             ; save current line into E
0CEE: 160E     [56]                     ld      D,$0E           ; register #14 (port A)
0CF0: 0E40     [63]                     ld      C,PSG_REG       ; PSG register port
0CF2: ED51     [75]                     out     (C),D           ; select reg. 14 (port A)
0CF4: 00       [79]                     nop
0CF5: ED78     [91]                     in      A,(C)           ; read register #14
0CF7: FEFF     [98]                     cp      $FF             ; is there any line set to 0?
0CF9: 282E     [105|110]                jr      Z,NOKEYPRSD     ; no, go to the next row
                                        ; check control keys
0CFB: 321782   [118]                    ld      (KBTMP),A       ; yes, check if a control key was pressed. First, store current row
0CFE: 78       [122]                    ld      A,B             ; copy current row (B) into A
0CFF: FE02     [129]                    cp      $02             ; is it the row of the SHIFT?
0D01: 200F     [136|141]                jr      NZ,TESTALT      ; no, continue checking the other control keys
0D03: 3A1782   [149]                    ld      A,(KBTMP)       ; yes, retrieve current row data
0D06: CB5F     [157]                    bit     3,A             ; check SHIFT bit line
0D08: 202E     [164|169]                jr      NZ,FINDKEY      ; no SHIFT, continue checking
0D0A: CBDF     [172]                    set     3,A             ; yes, it's the SHIFT. So remove SHIFT bit
0D0C: FEFF     [179]                    cp      $FF             ; after deleting the SHIFT bit, is there any other bit selected?
0D0E: 2028     [186|191]                jr      NZ,FINDKEY      ; yes, go to check which one
0D10: 1817     [198]                    jr      NOKEYPRSD       ; no, go to next row        
0D12: FE01     [ 7]     TESTALT:        cp      $01             ; is it the line of ALT & CTRL?
0D14: 3A1782   [20]                     ld      A,(KBTMP)       ; retrieve current row data
0D17: 201F     [27|32]                  jr      NZ,FINDKEY      ; no, continue
0D19: CB6F     [35]                     bit     5,A             ; yes, check ALT bit line
0D1B: 2002     [42|47]                  jr      NZ,TESTCTRL     ; no ALT, continue checking
0D1D: CBEF     [50]                     set     5,A             ; yes, it's the ALT. So remove ALT bit
0D1F: CB57     [ 8]     TESTCTRL:       bit     2,A             ; check CTRL bit line
0D21: 2002     [15|20]                  jr      NZ,ENDCTRLCK    ; no CTRL, continue checking
0D23: CBD7     [23]                     set     2,A             ; delete CTRL bit flag
0D25: FEFF     [ 7]     ENDCTRLCK:      cp      $FF             ; after deleting the ALT & CTRL bits, is there any other bit selected?
0D27: 200F     [14|19]                  jr      NZ,FINDKEY      ; yes, go to check which one
0D29: 7B       [ 4]     NOKEYPRSD:      ld      A,E             ; no key pressed, load current output port
0D2A: 0F       [ 8]                     rrca                    ; rotate right by 1
0D2B: 10B6     [16|21]                  djnz    RPTKBDRD        ; repeat for 8 lines
0D2D: AF       [20]                     xor     A               ; if exit from here, no key has been pressed...
0D2E: 321982   [33]                     ld      (LASTKEYPRSD),A ; ...so reset the last key cell...
0D31: 321A82   [46]                     ld      (CONTROLKEYS),A ; ...reset contro key flags...
0D34: 321682   [59]                     ld      (KBDNPT),A      ; ...no input from keyboard...
0D37: C9       [69]                     ret                     ; ...and leave
0D38: 1EFF     [ 7]     FINDKEY:        ld      E,$FF           ; counter
0D3A: 1C       [ 4]     CHKLN:          inc     E               ; E goes from 0 to 7
0D3B: CB3F     [12]                     srl     A               ; is the first bit reset? (we're looking for a "0", meaning grounded line)
0D3D: 38FB     [19|24]                  jr      C,CHKLN         ; no, check next bit
0D3F: 3A1A82   [32]                     ld      A,(CONTROLKEYS) ; load control key flags
0D42: 210D0E   [42]                     ld      HL,KBMAP        ; normal keymap
0D45: FE01     [49]                     cp      $01             ; SHIFT flag?
0D47: 2005     [56|61]                  jr      NZ,CHKCTRL      ; no, jump over
0D49: 214D0E   [66]                     ld      HL,KBMAP_SFT    ; SHIFT keymap
0D4C: 1810     [78]                     jr      LOADMAP         ; and load it
0D4E: FE02     [ 7]     CHKCTRL:        cp      $02             ; CTRL flag?
0D50: 2005     [14|19]                  jr      NZ,CHKALT       ; no, jump over
0D52: 21CD0E   [24]                     ld      HL,KBMAP_CTRL   ; CTRL map
0D55: 1807     [36]                     jr      LOADMAP         ; and load it
0D57: FE04     [ 7]     CHKALT:         cp      $04             ; ALT flag?
0D59: 2003     [14|19]                  jr      NZ,LOADMAP      ; no, check over
0D5B: 218D0E   [24]                     ld      HL,KBMAP_ALT    ; ALT map
0D5E: 05       [ 4]     LOADMAP:        dec     B               ; decrement row # (rows go from 0 to 7)
0D5F: 48       [ 8]                     ld      C,B             ; move B into C and...
0D60: CB21     [16]                     sla     C               ; ...multiply it...
0D62: CB21     [24]                     sla     C               ; ...by 8 to find...
0D64: CB21     [32]                     sla     C               ; ...the current row into the matrix
0D66: 0600     [39]                     ld      B,$00           ; reset B
0D68: 09       [50]                     add     HL,BC           ; find the address of the current row
0D69: 50       [54]                     ld      D,B             ; reset D
0D6A: 19       [65]                     add     HL,DE           ; find the current column
0D6B: 3A1982   [78]                     ld      A,(LASTKEYPRSD) ; load the last key pressed
0D6E: BE       [85]                     cp      (HL)            ; is it the same key?
0D6F: 2847     [92|97]                  jr      Z,LVKBRDCHK     ; yes, so do nothing
0D71: 7E       [99]                     ld      A,(HL)          ; no, load it...
0D72: 321982   [112]                    ld      (LASTKEYPRSD),A ; ...store it...
0D75: 321882   [125]                    ld      (TMPKEYBFR),A   ; ...insert it into the INKEY buffer...
0D78: 32D981   [138]                    ld      (CHR4VID),A     ; ...and store char for video
0D7B: FE03     [145]                    cp      CTRLC           ; is it RUN/STOP?
0D7D: 2005     [152|157]                jr      NZ,CNTKBCK      ; no, jump over
0D7F: CD3601   [169]                    call    CHARINTOBFR     ; yes, send directly to buffer and...
0D82: 1830     [181]                    jr      LVKBRDCHK2      ; ...leave
0D84: 010008   [10]     CNTKBCK:        ld      BC,$0800        ; 8 FN keys (B), FN key number (C)
0D87: 21050E   [20]                     ld      HL,FNKEYSORD    ; FN keys codes
0D8A: BE       [ 7]     CHKFNK:         cp      (HL)            ; is it an FN key?
0D8B: CAB90D   [17|17]                  jp      Z,PRNTFNKEY     ; yes, jump over
0D8E: 0C       [21]                     inc     C               ; next FN key
0D8F: 23       [27]                     inc     HL              ; next FN key code
0D90: 10F8     [35|40]                  djnz    CHKFNK          ; continue for 8 FN keys
0D92: 3E01     [ 7]     SNDKEYTOBFR:    ld      A,$01           ; normal key - set input flag
0D94: 321682   [20]                     ld      (KBDNPT),A      ; to keyboard
0D97: 3AD881   [33]                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
0D9A: B7       [37]                     or      A               ; is the print-on-video disabled?
0D9B: CAA40D   [47|47]                  jp      Z,PUTCHRBUF     ; yes, so send char to input buffer
0D9E: 3AD681   [60]                     ld      A,(CRSR_STATE)  ; check cursor state
0DA1: B7       [64]                     or      A               ; is it 0 (cursor OFF)?
0DA2: 200D     [71|76]                  jr      NZ,PNT2VD       ; no, print on screen
0DA4: AF       [ 4]     PUTCHRBUF:      xor     A
0DA5: 321682   [17]                     ld      (KBDNPT),A      ; if send to input buffer, set RETURN as from BASIC
0DA8: 3A1882   [30]                     ld      A,(TMPKEYBFR)   ; retrieve char
0DAB: CD3601   [47]                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
0DAE: C3B40D   [57]                     jp      LVKBRDCHK2      ; ...and leave
0DB1: CDE306   [17]     PNT2VD:         call    CHAR2VID        ; send char to video
0DB4: AF       [ 4]     LVKBRDCHK2:     xor     A
0DB5: 321A82   [17]                     ld      (CONTROLKEYS),A ; reset control key flags
0DB8: C9       [10]     LVKBRDCHK:      ret                     ; return to caller: the current key code is into TMPKEYBFR    
                                        ; manage FN keys          
0DB9: 57       [ 4]     PRNTFNKEY:      ld      D,A             ; copy A into D
0DBA: 2AAF80   [20]                     ld      HL,(LINEAT)     ; Get current line number
0DBD: 23       [26]                     inc     HL              ; -1 means direct statement
0DBE: 7C       [30]                     ld      A,H
0DBF: B5       [34]                     or      L
0DC0: 7A       [38]                     ld      A,D             ; retrieve char
0DC1: 20CF     [45|50]                  jr      NZ,SNDKEYTOBFR  ; indirect mode - just send FN key code to buffer
0DC3: 79       [49]                     ld      A,C             ; direct mode, so print text - first, get FN key number
0DC4: 87       [53]                     add     A,A
0DC5: 87       [57]                     add     A,A
0DC6: 87       [61]                     add     A,A
0DC7: 87       [65]                     add     A,A             ; FN key number * 16
0DC8: 4F       [69]                     ld      C,A             ; move it into C
0DC9: 0600     [76]                     ld      B,$00           ; reset B, to get offset
0DCB: 21B380   [86]                     ld      HL,FNKEYS       ; load address of FN keys texts
0DCE: 09       [97]                     add     HL,BC           ; get correct text address
0DCF: 0610     [104]                    ld      B,$10           ; 16 chars
0DD1: 7E       [ 7]     LDFNKEYCHR:     ld      A,(HL)          ; load char
0DD2: A7       [11]                     and     A               ; null char?
0DD3: CAB40D   [21|21]                  jp      Z,LVKBRDCHK2    ; yes, so leave
0DD6: 57       [25]                     ld      D,A             ; pass char into D
0DD7: 3AD881   [38]                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
0DDA: B7       [42]                     or      A               ; is the print-on-video disabled?
0DDB: CAEB0D   [52|52]                  jp      Z,PUTCHRBUF1    ; yes, so send char to input buffer
0DDE: 3AD681   [65]                     ld      A,(CRSR_STATE)  ; check cursor state
0DE1: B7       [69]                     or      A               ; is it 0 (cursor OFF)?
0DE2: C4F80D   [79|86]                  call    NZ,PRNTFNK      ; no, print on screen
0DE5: 23       [ 6]     CNTFNK:         inc     HL              ; next char
0DE6: 10E9     [14|19]                  djnz    LDFNKEYCHR      ; repeat for max. 16 chars
0DE8: C3B40D   [24]                     jp      LVKBRDCHK2      ; leave
0DEB: AF       [ 4]     PUTCHRBUF1:     xor     A               ; if send to input buffer,... 
0DEC: 321682   [17]                     ld      (KBDNPT),A      ; ...set input as from BASIC
0DEF: 7A       [21]                     ld      A,D             ; retrieve char
0DF0: E5       [32]                     push    HL              ; store HL
0DF1: CD3601   [49]                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
0DF4: E1       [59]                     pop     HL              ; retrieve HL
0DF5: C3E50D   [69]                     jp      CNTFNK          ; repeat
0DF8: 7A       [ 4]     PRNTFNK:        ld      A,D             ; recover char
0DF9: 32D981   [17]                     ld      (CHR4VID),A     ; store char for printing
0DFC: 3E01     [24]                     ld      A,$01           ; normal key - set input flag
0DFE: 321682   [37]                     ld      (KBDNPT),A      ; to keyboard
0E01: CDE306   [54]                     call    CHAR2VID        ; print on screen
0E04: C9       [64]                     ret                     ; return to caller
                        
                        
                        ;-----------------------------------------------------------------------
0E05: 01020405          FNKEYSORD:      defb 1,2,4,5,6,22,23,24                 ; order of FN Keys
0E09: 06161718          
                        ;-----------------------------------------------------------------------
                        ; key codes
0E0D: 31190E03          KBMAP:          defb '1',25,14,3,' ',16,'q','2'         ; 25=HOME  14=CTRL  3=RUN/STOP 16=C=
0E11: 20107132          
0E15: 33776114                          defb '3','w','a',20,'z','s','e','4'     ; 20=SHIFT
0E19: 7A736534          
0E1D: 35726478                          defb '5','r','d','x','c','f','t','6'
0E21: 63667436          
0E25: 37796776                          defb '7','y','g','v','b','h','u','8'
0E29: 62687538          
0E2D: 39696A6E                          defb '9','i','j','n','m','k','o','0'
0E31: 6D6B6F30          
0E35: 1F706C2C                          defb 31,'p','l',',','.',':','-',30      ; 31=CURSOR DOWN  30=CURSOR UP
0E39: 2E3A2D1E          
0E3D: 1C2A3B2F                          defb 28,'*',';','/',27,'=','+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
0E41: 1B3D2B1D          
0E45: 080DFC40                          defb 8,13,252,'@',1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
0E49: 01020418          
                        
                        ; shifted codes - not all the keys have the shifted version
0E4D: 210C0E03          KBMAP_SFT:      defb '!',12,14,3,' ',16,'Q',34          ; 12=CLEAR  14=CTRL  3=RUN/STOP 16=C=   34="
0E51: 20105122          
0E55: 23574114                          defb '#','W','A',20,'Z','S','E','$'     ; 20=SHIFT
0E59: 5A534524          
0E5D: 25524458                          defb '%','R','D','X','C','F','T','&'
0E61: 43465426          
0E65: 27594756                          defb 39,'Y','G','V','B','H','U','('     ; 39='
0E69: 42485528          
0E6D: 29494A4E                          defb ')','I','J','N','M','K','O',94     ; 94=^
0E71: 4D4B4F5E          
0E75: 1F504C3C                          defb 31,'P','L','<','>','[','_',30      ; 31=CURSOR DOWN  30=CURSOR UP
0E79: 3E5B5F1E          
0E7D: 1C2A5D3F                          defb 28,'*',']','?',27,198,'+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
0E81: 1BC62B1D          
0E85: 080DD340                          defb 8,13,211,'@',5,6,22,23             ; 211=â¬  5=F4  6=F5  22=F6  23=F7
0E89: 05061617          
                        
                        ; ALT (C=) codes - not all the keys have the alt-ed version
0E8D: 310C0E03          KBMAP_ALT:      defb '1',12,14,3,' ',16,222,196         ; 12=CLEAR  14=CTRL  3=RUN/STOP  16=C=  34="
0E91: 2010DEC4          
0E95: 33DD8514                          defb '3',221,133,20,131,130,165,'4'     ; 20=SHIFT
0E99: 8382A534          
0E9D: 35A2A684                          defb '5',162,166,132,157,163,168,'6'
0EA1: 9DA3A836          
0EA5: 37ABA9A1                          defb '7',171,169,161,158,172,213,'8'    ;
0EA9: 9EACD538          
0EAD: 39D6D89F                          defb '9',214,216,159,160,215,135,195    ;
0EB1: A0D787C3          
0EB5: 1F888AC1                          defb 31,136,138,193,192,123,144,30      ; 31=CURSOR DOWN  123={  30=CURSOR UP
0EB9: C07B901E          
0EBD: 1C8F7DFE                          defb 28,143,125,254,27,209,148,29       ; 28=CURSOR LEFT  125=}  27=ESCAPE  29=CURSOR RIGHT
0EC1: 1BD1941D          
0EC5: 080DE089                          defb 8,13,224,137,5,6,22,23             ; 8=DEL(backspace)  13=RETURN  252=Â£  5=F4  6=F5  22=F6  23=F7
0EC9: 05061617          
                        
                        ; CTRL codes - not all the keys have the control-ed version
0ECD: 31190E03          KBMAP_CTRL:     defb '1',25,14,3,' ',16,154,'2'         ; 25=HOME  14=CTRL  3=RUN/STOP  16=C=
0ED1: 20109A32          
0ED5: 339C9514                          defb '3',156,149,20,152,150,153,'4'     ; 20=SHIFT
0ED9: 98969934          
0EDD: 359BB097                          defb '5',155,176,151,177,175,165,'6'
0EE1: B1AFA536          
0EE5: 37A6A8B2                          defb '7',166,168,178,179,169,167,'8'
0EE9: B3A9A738          
0EED: 39B8AAAC                          defb '9',184,170,172,171,181,164,'0'
0EF1: ABB5A430          
0EF5: 1FA3AD2C                          defb 31,163,173,',','.',':',186,30      ; 31=CURSOR DOWN  30=CURSOR UP
0EF9: 2E3ABA1E          
0EFD: 1CE13B2F                          defb 28,225,';','/',27,212,185,29       ; 28=CURSOR LEFT  27=ESCAPE  212=Ï  29=CURSOR RIGHT
0F01: 1BD4B91D          
0F05: 080DBDA2                          defb 8,13,189,162,1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
0F09: 01020418          
                        
                        ; include the latest version of the NASCOM BASIC interpreter
                        #include "../include/basic/basic32k-r315.asm"
                        ; ------------------------------------------------------------------------------
                        ; LM80C BASIC - R3.15
                        ; ------------------------------------------------------------------------------
                        ; The following code is intended to be used with LM80C Z80-based computer
                        ; designed by Leonardo Miliani. Code and computer schematics are released under
                        ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
                        ; kind of warranty: you can use them at your own risk.
                        ; You are free to use them for any non-commercial use: you are only asked to
                        ; maintain the copyright notices, include this advice and the note to the 
                        ; attribution of the original version to Leonardo Miliani, if you intend to
                        ; redistribuite them.
                        ; https://www.leonardomiliani.com
                        ; 
                        ; Please support me by visiting the following links:
                        ; Main project page: https://www.leonardomiliani.com
                        ; Schematics and code: https://github.com/leomil72/LM80C
                        ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
                        ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
                        ; ------------------------------------------------------------------------------
                        ; NASCOM BASIC versions:
                        ; 4.7  - original version by NASCOM
                        ; 4.7b - modified version by Grant Searle (additional commands & functions)
                        ; 4.8  - modified by Leonardo Miliani (new commands/functions)
                        
                        
                        ;------------------------------------------------------------------------------
                        ;  B A S I C
                        ;------------------------------------------------------------------------------
                        
                        ; GENERAL EQUATES
                        
0000:                   NLLCR           equ     $00             ; null char (used as space/empty char in video prints)
0003:                   CTRLC           equ     $03             ; Control "C"
0007:                   CTRLG           equ     $07             ; Control "G"
0008:                   BKSP            equ     $08             ; Back space
000A:                   LF              equ     $0A             ; Line feed
000C:                   CS              equ     $0C             ; Clear screen
000D:                   CR              equ     $0D             ; Carriage return
000F:                   CTRLO           equ     $0F             ; Control "O"
0011:                   CTRLQ           equ     $11             ; Control "Q"
0012:                   CTRLR           equ     $12             ; Control "R"
0013:                   CTRLS           equ     $13             ; Control "S"
0015:                   CTRLU           equ     $15             ; Control "U"
0019:                   HOME            equ     $19             ; Home (cursor at 0,0)
001B:                   ESC             equ     $1B             ; Escape
0020:                   SPC             equ     $20             ; Space
007F:                   DEL             equ     $7F             ; Delete
                        ; cursor ASCII codes
001C:                   CRSLFT          equ     $1C             ; cursor left
001D:                   CRSRGT          equ     $1D             ; cursor right
001E:                   CRSUP           equ     $1E             ; cursor up
001F:                   CRSDN           equ     $1F             ; cursor down
                        
                        
                        ; BASIC WORK SPACE LOCATIONS
                        ; BY STARTING FROM $805E THE INTERPRETER ALLOCATES THE FOLLOWING RAM CELLS
                        ; TO STORE IMPORTANT VALUES USED FOR SOME SPECIFIC FUNCTIONS:
                        ; THEY CAN BE VECTOR (ADDRESSES) FUNCTIONS, SYSTEM DATAS (I.E. VARIABLES)
                        ; AND SO ON. THE FIRST CELLS ARE FILLED WITH VALUES STORED INTO ROM AT $(INITAB) ADDRESS
805E:                   WRKSPC          equ     basicStarted+$01; (3) BASIC Work space
8061:                   NMIUSR          equ     WRKSPC+$03      ; (3) NMI exit point routine
8064:                   USR             equ     NMIUSR+$03      ; (3) "USR (x)" jump  <-- in (USR+$01)/(USR+$02) the user can store the address of a specific machine language routine
8067:                   OUTSUB          equ     USR+$03         ; (1) "out p,n"
8068:                   OTPORT          equ     OUTSUB+$01      ; (2) Port (p)
806A:                   DIVSUP          equ     OTPORT+$02      ; (1) Division support routine
806B:                   DIV1            equ     DIVSUP+$01      ; (4) <- Values
806F:                   DIV2            equ     DIV1+$04        ; (4) <-   to
8073:                   DIV3            equ     DIV2+$04        ; (3) <-   be
8076:                   DIV4            equ     DIV3+$03        ; (2) <-inserted
8078:                   SEED            equ     DIV4+$02        ; (35) Random number seed  <-- starting address of a seed table
809B:                   LSTRND          equ     SEED+$23        ; (4) Last random number
809F:                   INPSUB          equ     LSTRND+$04      ; (1) INP A,(x) Routine
80A0:                   INPORT          equ     INPSUB+$01      ; (2) PORT (x)
80A2:                   LWIDTH          equ     INPORT+$02      ; (1) Terminal width
80A3:                   COMMAN          equ     LWIDTH+$01      ; (1) Width for commas
80A4:                   NULFLG          equ     COMMAN+$01      ; (1) Null after input byte flag
80A5:                   CTLOFG          equ     NULFLG+$01      ; (1) Control "O" flag
80A6:                   CHKSUM          equ     CTLOFG+$01      ; (2) Array load/save check sum
80A8:                   NMIFLG          equ     CHKSUM+$02      ; (1) Flag for NMI break routine
80A9:                   BRKFLG          equ     NMIFLG+$01      ; (1) Break flag
80AA:                   RINPUT          equ     BRKFLG+$01      ; (3) Input reflection
80AD:                   STRSPC          equ     RINPUT+$03      ; (2) Pointer to bottom (start) of string space - default is 100 bytes below the top of memory
80AF:                   LINEAT          equ     STRSPC+$02      ; (2) Current line number. -1 means "direct mode", while -2 means cold start.
80B1:                   HLPLN           equ     LINEAT+$02      ; (2) Current line with errors
80B3:                   FNKEYS          equ     HLPLN+$02       ; (128) default text of FN keys
8133:                   BASTXT          equ     FNKEYS+$80      ; (3) Pointer to start of BASIC program in memory
                        ; - - - - - - - - - - - - - - - - - - -   the above are locations pre-filled by the firmware at startup
8136:                   BUFFER          equ     BASTXT+$03      ; (5) Input buffer
813B:                   STACK           equ     BUFFER+$05      ; (85) Initial stack
8190:                   CURPOS          equ     STACK+$55       ; (1) Character position on line
8191:                   LCRFLG          equ     CURPOS+$01      ; (1) Locate/Create flag for DIM statement
8192:                   TYPE            equ     LCRFLG+$01      ; (1) Data type flag: 0=numeric, non-zero=string
8193:                   DATFLG          equ     TYPE+$01        ; (1) Literal statement flag
8194:                   LSTRAM          equ     DATFLG+$01      ; (2) Last available RAM location usable by BASIC
8196:                   TMSTPT          equ     LSTRAM+$02      ; (2) Temporary string pointer
8198:                   TMSTPL          equ     TMSTPT+$02      ; (12) Temporary string pool
81A4:                   TMPSTR          equ     TMSTPL+$0C      ; (4) Temporary string
81A8:                   STRBOT          equ     TMPSTR+$04      ; (2) Bottom of string space
81AA:                   CUROPR          equ     STRBOT+$02      ; (2) Current operator in EVAL
81AC:                   LOOPST          equ     CUROPR+$02      ; (2) First statement of loop
81AE:                   DATLIN          equ     LOOPST+$02      ; (2) Line of current DATA item
81B0:                   FORFLG          equ     DATLIN+$02      ; (1) "FOR" loop flag
81B1:                   LSTBIN          equ     FORFLG+$01      ; (1) Last byte entered
81B2:                   READFG          equ     LSTBIN+$01      ; (1) Read/Input flag
81B3:                   BRKLIN          equ     READFG+$01      ; (2) Line of break
81B5:                   NXTOPR          equ     BRKLIN+$02      ; (2) Next operator in EVAL
81B7:                   ERRLIN          equ     NXTOPR+$02      ; (2) Line of error
81B9:                   CONTAD          equ     ERRLIN+$02      ; (2) Where to CONTinue
81BB:                   TMRCNT          equ     CONTAD+$02      ; (4) TMR counter for 1/100 seconds
81BF:                   CTC0IV          equ     TMRCNT+$04      ; (3) CTC0 interrupt vector
81C2:                   CTC1IV          equ     CTC0IV+$03      ; (3) CTC1 interrupt vector
81C5:                   CTC2IV          equ     CTC1IV+$03      ; (3) CTC2 interrupt vector
81C8:                   CTC3IV          equ     CTC2IV+$03      ; (3) CTC3 interrupt vector
                        ; - - - - - - - - - - - - - - - - - - -   VIDEO REGISTERS - FROM HERE...
81CB:                   SCR_SIZE_W      equ     CTC3IV+$03      ; (1) screen width (it can be either 40 chars or 32 chars/bytes)
81CC:                   SCR_SIZE_H      equ     SCR_SIZE_W+$01  ; (1) screen height (it can be 24/48/192: 24 for text, 48 for MC, 192 for graphics)
81CD:                   SCR_MODE        equ     SCR_SIZE_H+$01  ; (1) screen mode (0=text, 1=G1, 2=G2, 3=MC, 4=ExG2)
81CF:                   SCR_NAM_TB      equ     SCR_MODE+$02    ; (2) video name table address
81D1:                   SCR_CURS_X      equ     SCR_NAM_TB+$02  ; (1) cursor X
81D2:                   SCR_CURS_Y      equ     SCR_CURS_X+$01  ; (1) cursor Y
81D3:                   SCR_CUR_NX      equ     SCR_CURS_Y+$01  ; (1) new cursor X position
81D4:                   SCR_CUR_NY      equ     SCR_CUR_NX+$01  ; (1) new cursor Y position
81D5:                   SCR_ORG_CHR     equ     SCR_CUR_NY+$01  ; (1) original char positioned under the cursor
81D6:                   CRSR_STATE      equ     SCR_ORG_CHR+$01 ; (1) state of cursor (1=on, 0=off)
81D7:                   LSTCSRSTA       equ     CRSR_STATE+$01  ; (1) last cursor state
81D8:                   PRNTVIDEO       equ     LSTCSRSTA+$01   ; (1) print on video buffer (1=on / 0=off) set to off on graphic only modes
81D9:                   CHR4VID         equ     PRNTVIDEO+$01   ; (1) char for video buffer
81DA:                   FRGNDCLR        equ     CHR4VID+$01     ; (1) foreground color as set by SCREEN or COLOR commands
81DB:                   BKGNDCLR        equ     FRGNDCLR+$01    ; (1) background color as set by SCREEN or COLOR commands
81DC:                   TMPBFR1         equ     BKGNDCLR+$01    ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
81DE:                   TMPBFR2         equ     TMPBFR1+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
81E0:                   TMPBFR3         equ     TMPBFR2+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
81E2:                   TMPBFR4         equ     TMPBFR3+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
81E4:                   VIDEOBUFF       equ     TMPBFR4+$02     ; (40) buffer used for video scrolling and other purposes
820C:                   VIDTMP1         equ     VIDEOBUFF+$28   ; (2) temporary video word
820E:                   VIDTMP2         equ     VIDTMP1+$02     ; (2) temporary video word
                        ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO VPD OUT OF THIS RANGE,
                                                                ; OTHERWISE YOU WILL HAVE TO CHECK THE POINTER IN "CLR_RAM_REG" FUNCTION
                        ; - - - - - - - - - - - - - - - - - - -   SOUND & KEYBOARD REGISTERS - FROM HERE...
8210:                   CHASNDDTN       equ     VIDTMP2+$02     ; (2) sound Ch.A duration (in 1/100s)
8212:                   CHBSNDDTN       equ     CHASNDDTN+$02   ; (2) sound Ch.B duration (in 1/100s)
8214:                   CHCSNDDTN       equ     CHBSNDDTN+$02   ; (2) sound Ch.C duration (in 1/100s)
8216:                   KBDNPT          equ     CHCSNDDTN+$02   ; (1) temp cell used to flag if input comes from keyboard
8217:                   KBTMP           equ     KBDNPT+$01      ; (1) temp cell used by keyboard scanner
8218:                   TMPKEYBFR       equ     KBTMP+$01       ; (1) temp buffer for last key pressed
8219:                   LASTKEYPRSD     equ     TMPKEYBFR+$01   ; (1) last key code pressed
821A:                   CONTROLKEYS     equ     LASTKEYPRSD+$01 ; (1) flags for control keys (bit#0=SHIFT; bit#1=CTRL; bit#2=C=)
                        ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO PSG OUT OF THIS RANGE,
                                                                ; OTHERWISE YOU WILL HAVE TO CHANGE THE POINTER IN "initPSG" FUNCTION
821B:                   SERIALS_EN      equ     CONTROLKEYS+$01 ; (1) serial ports status: bit 0 for Port1 (A), bit 1 for Port2 (B): 0=OFF, 1=ON
821C:                   SERABITS        equ     SERIALS_EN+$01  ; (1) serial port A data bits
821D:                   SERBBITS        equ     SERABITS+$01    ; (1) serial port B data bits
                        ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                ; from here there are the RAM locations that
                                                                ; are saved during SAVE
821E:                   PROGND          equ     SERBBITS+$01    ; (2) End of program
8220:                   VAREND          equ     PROGND+$02      ; (2) End of variables
8222:                   ARREND          equ     VAREND+$02      ; (2) End of arrays
8224:                   NXTDAT          equ     ARREND+$02      ; (2) Next data item
8226:                   FNRGNM          equ     NXTDAT+$02      ; (2) Name of FN argument
8228:                   FNARG           equ     FNRGNM+$02      ; (4) FN argument value
822C:                   FPREG           equ     FNARG+$04       ; (3) Floating point register
822F:                   FPEXP           equ     FPREG+$03       ; (1) Floating point exponent
8230:                   SGNRES          equ     FPEXP+$01       ; (1) Sign of result
8231:                   PBUFF           equ     SGNRES+$01      ; (13) Number print buffer
823E:                   MULVAL          equ     PBUFF+$0D       ; (3) Multiplier
8241:                   PROGST          equ     MULVAL+$03      ; (100) Start of program text area
82A5:                   STLOOK          equ     PROGST+$64      ; Start of memory test
                        
                        ; BASIC ERROR CODE VALUES
                        ; These values act as an offset to point to the error message into the error table
                        ; must be incremented by 2 because they point to a word address jump
0000:                   NF              equ     $00             ; NEXT without FOR
0002:                   SN              equ     $02             ; Syntax error
0004:                   RG              equ     $04             ; RETURN without GOSUB
0006:                   OD              equ     $06             ; Out of DATA
0008:                   FC              equ     $08             ; Function call error
000A:                   OV              equ     $0A             ; Overflow
000C:                   OM              equ     $0C             ; Out of memory
000E:                   UL              equ     $0E             ; Undefined line number
0010:                   BS              equ     $10             ; Bad subscript
0012:                   DD              equ     $12             ; Re-Dimensioned array
0014:                   DZ              equ     $14             ; Division by zero (/0)
0016:                   ID              equ     $16             ; Illegal direct
0018:                   TM              equ     $18             ; Type mis-match
001A:                   OS              equ     $1A             ; Out of string space
001C:                   LS              equ     $1C             ; String too long
001E:                   ST              equ     $1E             ; String formula too complex
0020:                   CN              equ     $20             ; Can't continue
0022:                   UF              equ     $22             ; Undefined FN function
0024:                   MO              equ     $24             ; Missing operand
0026:                   HX              equ     $26             ; HEX error
0028:                   BN              equ     $28             ; BIN error
002A:                   GM              equ     $2A             ; No Graphics Mode
002C:                   SC              equ     $2C             ; Serial configuration
002E:                   SA              equ     $2E             ; Serial port already open
0030:                   HP              equ     $30             ; HELP call
                        
0F0D: C3130F   [10]     COLD:   jp      STARTB          ; Jump for cold start
0F10: C3B70F   [10]     WARM:   jp      WARMST          ; Jump for warm start
                        
0F13: C31A0F   [10]     STARTB: jp      CSTART          ; Jump to initialise
0F16: 6D1B                      defw    DEINT           ; Get integer -32768 to 32767
0F18: 2423                      defw    ABPASS          ; Return integer in AB
0F1A: 215E80   [10]     CSTART: ld      HL,WRKSPC       ; Start of workspace RAM
0F1D: F9       [16]             ld      SP,HL           ; Set up a temporary stack
0F1E: C3003E   [26]             jp      INITST          ; Go to initialise
                        
0F21: 214D14   [10]     INIT:   ld      HL,INITAB       ; Initialise workspace
0F24: 01DA00   [20]             ld      BC,INITBE-INITAB+3; Bytes to copy
0F27: 115E80   [30]             ld      DE,WRKSPC       ; Into workspace RAM
0F2A: EDB0     [46|21]          ldir                    ; Copy data
0F2C: EB       [50]             ex      DE,HL           ; Copy DE into HL
0F2D: F9       [56]             ld      SP,HL           ; Temporary stack
0F2E: CDFE16   [73]             call    CLREG           ; Clear registers and stack
0F31: CD7E1D   [90]             call    PRNTCRLF        ; Output CRLF
0F34: 328F81   [103]            ld      (BUFFER+88+1),A ; Mark end of buffer
0F37: 324182   [116]            ld      (PROGST),A      ; Initialise program area
0F3A: 1813     [128]            jr      MNOASK          ; usually, don't ask for memory top (only when there are errors)
0F3C: 211B10   [10]     MSIZE:  ld      HL,MEMMSG       ; Point to message
0F3F: CD4224   [27]             call    PRS             ; Output "Memory size"
0F42: CD1B17   [44]             call    PROMPT          ; Get input with '?'
0F45: CD7508   [61]             call    CURSOR_ON       ; enable cursor
0F48: CDB71A   [78]             call    GETCHR          ; Get next character
0F4B: B7       [82]             or      A               ; Set flags
0F4C: C2640F   [92|92]          jp      NZ,TSTMEM       ; If number - Test if RAM there
0F4F: 21A582   [10]     MNOASK: ld      HL,STLOOK       ; Point to start of RAM
0F52: 23       [ 6]     MLOOP:  inc     HL              ; Next byte
0F53: 7C       [10]             ld      A,H             ; Above address FFFF ?
0F54: B5       [14]             or      L
0F55: CA760F   [24|24]          jp      Z,SETTOP        ; Yes - 64K RAM
0F58: 7E       [31]             ld      A,(HL)          ; Get contents
0F59: 47       [35]             ld      B,A             ; Save it
0F5A: 2F       [39]             cpl                     ; Flip all bits
0F5B: 77       [46]             ld      (HL),A          ; Put it back
0F5C: BE       [53]             cp      (HL)            ; RAM there if same
0F5D: 70       [60]             ld      (HL),B          ; Restore old contents
0F5E: CA520F   [70|70]          jp      Z,MLOOP         ; If RAM - test next byte
0F61: C3760F   [80]             jp      SETTOP          ; Top of RAM found
                        
0F64: CD871B   [17]     TSTMEM: call    ATOH            ; Get high memory into DE
0F67: B7       [21]             or      A               ; Set flags on last byte
0F68: C2B215   [31|31]          jp      NZ,SNERR        ; ?SN Error if bad character
0F6B: EB       [35]             ex      DE,HL           ; Address into HL
0F6C: 2B       [41]             dec     HL              ; Back one byte
0F6D: 3ED9     [48]             ld      A,%11011001     ; Test byte
0F6F: 46       [55]             ld      B,(HL)          ; Get old contents
0F70: 77       [62]             ld      (HL),A          ; Load test byte
0F71: BE       [69]             cp      (HL)            ; RAM there if same
0F72: 70       [76]             ld      (HL),B          ; Restore old contents
0F73: C23C0F   [86|86]          jp      NZ,MSIZE        ; Ask again if no RAM
                        
0F76: CD8B08   [17]     SETTOP: call    CURSOR_OFF      ; disable cursor
0F79: 2B       [23]             dec     HL              ; Back one byte
0F7A: 11A482   [33]             ld      DE,STLOOK-1     ; See if enough RAM
0F7D: CD8E18   [50]             call    CPDEHL          ; Compare DE with HL
0F80: DA3C0F   [60|60]          jp      C,MSIZE         ; Ask again if not enough RAM
0F83: 119CFF   [70]             ld      DE,0-100        ; 100 Bytes string space
0F86: 229481   [86]             ld      (LSTRAM),HL     ; Save last available RAM
0F89: 19       [97]             add     HL,DE           ; Allocate string space
0F8A: 22AD80   [113]            ld      (STRSPC),HL     ; Save string space
0F8D: CDD916   [130]            call    CLRPTR          ; Clear program area
0F90: 2AAD80   [146]            ld      HL,(STRSPC)     ; Get end of memory
0F93: 11EFFF   [156]            ld      DE,0-17         ; Offset for free bytes
0F96: 19       [167]            add     HL,DE           ; Adjust HL
0F97: 114182   [177]            ld      DE,PROGST       ; Start of program text
0F9A: 7D       [181]            ld      A,L             ; Get LSB
0F9B: 93       [185]            sub     E               ; Adjust it
0F9C: 6F       [189]            ld      L,A             ; Re-save
0F9D: 7C       [193]            ld      A,H             ; Get MSB
0F9E: 9A       [197]            sbc     A,D             ; Adjust it
0F9F: 67       [201]            ld      H,A             ; Re-save
0FA0: E5       [212]            push    HL              ; Save bytes free
0FA1: 21DA0F   [222]            ld      HL,SIGNON       ; Sign-on message
0FA4: CD4224   [239]            call    PRS             ; Output string
0FA7: 21C30F   [249]            ld      HL,BLNSPC       ; Empty space
0FAA: CD4224   [266]            call    PRS             ; Output string
0FAD: E1       [276]            pop     HL              ; Get bytes free back
0FAE: CDE22E   [293]            call    PRNTHL          ; Output amount of free memory
0FB1: 21CC0F   [303]            ld      HL,BFREE        ; " Bytes free" message
0FB4: CD4224   [320]            call    PRS             ; Output string
                        
0FB7: 313B81   [10]     WARMST: ld      SP,STACK        ; Temporary stack
0FBA: CDFE16   [17]     BRKRET: call    CLREG           ; Clear registers and stack
0FBD: CD7508   [34]             call    CURSOR_ON       ; enable cursor
0FC0: C30C16   [44]             jp      PRNTOK          ; Go to get command line
                        
0FC3: 20202020          BLNSPC: defb    "        ",0    ; 8 empty cells to align the "XXXX Bytes free" message
0FC7: 20202020          
0FCB: 00                
0FCC: 20427974          BFREE:  defb    " Bytes free",CR,CR,0
0FD0: 65732066          
0FD4: 7265650D          
0FD8: 0D00              
                        
0FDA: 4C4D3830          SIGNON: defb    "LM80C BASIC 3.15 ",251,"2020 L.Miliani"
0FDE: 43204241          
0FE2: 53494320          
0FE6: 332E3135          
0FEA: 20FB3230          
0FEE: 3230204C          
0FF2: 2E4D696C          
0FF6: 69616E69          
0FFA: 205A3830                  defb    " Z80 BASIC 4.7  ",251,"1978 Microsoft",CR,0
0FFE: 20424153          
1002: 49432034          
1006: 2E372020          
100A: FB313937          
100E: 38204D69          
1012: 63726F73          
1016: 6F66740D          
101A: 00                
                        
101B: 4D656D6F          MEMMSG: defb    "Memory top",0
101F: 72792074          
1023: 6F7000            
                        
                        ; The following list reports all the functions supported by the interpreter.
                        ; To add a custom function, the user must first insert the reserved word here,
                        ; then into the list of the reserved words below, and finally must increment the
                        ; ZSGN token value and all the following ones after ZSGN by 1 for every added
                        ; function.
                        
                        ; FUNCTION ADDRESS TABLE (this is a sort of offset table)
                        ; this list must be coherent with the tokens' functions list. This means that every
                        ; entry here must have the corresponding entry in the tokens list.
1026: 572D              FNCTAB: defw    SGN
1028: EC22                      defw    TMR         ; added by Leonardo Miliani
102A: 1B2E                      defw    INT
102C: 6D2D                      defw    ABS
102E: 6480                      defw    USR
1030: 0223                      defw    FRE
1032: 7D27                      defw    INP
1034: 3023                      defw    POS
1036: E12F                      defw    SQR
1038: C030                      defw    RND
103A: AB2B                      defw    LOG
103C: 2F30                      defw    EXP
103E: 3531                      defw    COS
1040: 3B31                      defw    SIN
1042: 9C31                      defw    TAN
1044: B131                      defw    ATN
1046: 5928                      defw    PEEK
1048: 1C32                      defw    DEEK
104A: 6028                      defw    VPEEK       ; added by Leonardo Miliani
104C: 302A                      defw    VSTAT       ; added by Leonardo Miliani
104E: 3B2A                      defw    SSTAT       ; added by Leonardo Miliani
1050: 4F2A                      defw    INKEY       ; added by Leonardo Miliani
1052: 7535                      defw    POINT       ; added by Leonardo Miliani
1054: 1426                      defw    INSTR       ; added by Leonardo Miliani
1056: B425                      defw    LEN
1058: CC23                      defw    STR
105A: 4427                      defw    VAL
105C: C325                      defw    ASC
105E: D425                      defw    CHR
1060: FB3C                      defw    HEX         ; added by Grant Searle
1062: 8C3D                      defw    BIN         ; added by Grant Searle
1064: E425                      defw    LEFT
1066: 0A27                      defw    RIGHT
1068: 1427                      defw    MID
                        
                        ; RESERVED WORD LIST
                        ; Here are all the reserved words used by the interpreter
                        ; To add custom functions/commands, the user must insert the keyword
                        ; in this list, following the schematic
106A: C54E44            WORDS:  defb    'E'+$80,"ND"            ; from here the list contains the COMMANDS
106D: C64F52                    defb    'F'+$80,"OR"
1070: CE455854                  defb    'N'+$80,"EXT"
1074: C4415441                  defb    'D'+$80,"ATA"
1078: C94E5055                  defb    'I'+$80,"NPUT"
107C: 54                
107D: C4494D                    defb    'D'+$80,"IM"
1080: D2454144                  defb    'R'+$80,"EAD"
1084: CC4554                    defb    'L'+$80,"ET"
1087: C74F544F                  defb    'G'+$80,"OTO"
108B: D2554E                    defb    'R'+$80,"UN"
108E: C946                      defb    'I'+$80,"F"
1090: D2455354                  defb    'R'+$80,"ESTORE"
1094: 4F5245            
1097: C74F5355                  defb    'G'+$80,"OSUB"
109B: 42                
109C: D2455455                  defb    'R'+$80,"ETURN"
10A0: 524E              
10A2: D2454D                    defb    'R'+$80,"EM"            ; original REM
10A5: D3544F50                  defb    'S'+$80,"TOP"
10A9: CF5554                    defb    'O'+$80,"UT"
10AC: CF4E                      defb    'O'+$80,"N"
10AE: C6494C45                  defb    'F'+$80,"ILES"
10B2: 53                
10B3: C5524153                  defb    'E'+$80,"RASE"          ; added by Leonardo Miliani
10B7: 45                
10B8: D7414954                  defb    'W'+$80,"AIT"
10BC: C44546                    defb    'D'+$80,"EF"
10BF: D04F4B45                  defb    'P'+$80,"OKE"
10C3: C44F4B45                  defb    'D'+$80,"OKE"
10C7: D6504F4B                  defb    'V'+$80,"POKE"          ; added by Leonardo Miliani
10CB: 45                
10CC: D3524547                  defb    'S'+$80,"REG"           ; added by Leonardo Miliani
10D0: D6524547                  defb    'V'+$80,"REG"           ; added by Leonardo Miliani
10D4: D3435245                  defb    'S'+$80,"CREEN"         ; changed by Leonardo Miliani
10D8: 454E              
10DA: CC4F4341                  defb    'L'+$80,"OCATE"         ; added by Leonardo Miliani
10DE: 5445              
10E0: D34F554E                  defb    'S'+$80,"OUND"          ; added by Leonardo Miliani
10E4: 44                
10E5: D64F4C55                  defb    'V'+$80,"OLUME"         ; added by Leonardo Miliani
10E9: 4D45              
10EB: D0415553                  defb    'P'+$80,"AUSE"          ; added by Leonardo Miliani
10EF: 45                
10F0: C34F4C4F                  defb    'C'+$80,"OLOR"          ; added by Leonardo Miliani
10F4: 52                
10F5: D04C4F54                  defb    'P'+$80,"LOT"           ; added by Leonardo Miliani
10F9: C4524157                  defb    'D'+$80,"RAW"           ; added by Leonardo Miliani
10FD: C3495243                  defb    'C'+$80,"IRCLE"         ; added by Leonardo Miliani
1101: 4C45              
1103: D041494E                  defb    'P'+$80,"AINT"          ; added by Leonardo Miliani
1107: 54                
1108: D3455249                  defb    'S'+$80,"ERIAL"         ; added by Leonardo Miliani
110C: 414C              
110E: C8454C50                  defb    'H'+$80,"ELP"           ; changed by Leonardo Miliani - was LINES
1112: C34C53                    defb    'C'+$80,"LS"            ; restored command
1115: CB4559                    defb    'K'+$80,"EY"            ; added by Leonardo Miliani
1118: CE4D49                    defb    'N'+$80,"MI"            ; added by Leonardo Miliani
111B: C7505249                  defb    'G'+$80,"PRINT"         ; added by Leonardo Miliani
111F: 4E54              
1121: D7494454                  defb    'W'+$80,"IDTH"
1125: 48                
1126: D35953                    defb    'S'+$80,"YS"            ; added by Leonardo Miliani
1129: D2455345                  defb    'R'+$80,"ESET"          ; changed by Leonardo Miliani
112D: 54                
112E: C54C5345                  defb    'E'+$80,"LSE"           ; added by Leonardo Miliani
1132: D052494E                  defb    'P'+$80,"RINT"
1136: 54                
1137: C34F4E54                  defb    'C'+$80,"ONT"
113B: CC495354                  defb    'L'+$80,"IST"
113F: C34C4541                  defb    'C'+$80,"LEAR"
1143: 52                
1144: CC4F4144                  defb    'L'+$80,"OAD"
1148: D3415645                  defb    'S'+$80,"AVE"
114C: CE4557                    defb    'N'+$80,"EW"
114F: D4414228                  defb    'T'+$80,"AB("
1153: D44F                      defb    'T'+$80,"O"
1155: C64E                      defb    'F'+$80,"N"
1157: D3504328                  defb    'S'+$80,"PC("
115B: D448454E                  defb    'T'+$80,"HEN"
115F: CE4F54                    defb    'N'+$80,"OT"
1162: D3544550                  defb    'S'+$80,"TEP"
                                ; from here: operators
1166: AB                        defb    '+'+$80
1167: AD                        defb    '-'+$80
1168: AA                        defb    '*'+$80
1169: AF                        defb    '/'+$80
116A: A5                        defb    '%'+$80
116B: A3                        defb    '#'+$80
116C: DE                        defb    '^'+$80
116D: C14E44                    defb    'A'+$80,"ND"
1170: D84F52                    defb    'X'+$80,"OR"
1173: CF52                      defb    'O'+$80,"R"
1175: BE                        defb    '>'+$80
1176: BD                        defb    '='+$80
1177: BC                        defb    '<'+$80
                        
                                ; from here there are the tokens' FUNCTIONS list
                                ; this list must be coherent with the functions list above
1178: D3474E                    defb    'S'+$80,"GN"
117B: D44D52                    defb    'T'+$80,"MR"            ; added by Leonardo Miliani
117E: C94E54                    defb    'I'+$80,"NT"
1181: C14253                    defb    'A'+$80,"BS"
1184: D55352                    defb    'U'+$80,"SR"
1187: C65245                    defb    'F'+$80,"RE"
118A: C94E50                    defb    'I'+$80,"NP"
118D: D04F53                    defb    'P'+$80,"OS"
1190: D35152                    defb    'S'+$80,"QR"
1193: D24E44                    defb    'R'+$80,"ND"
1196: CC4F47                    defb    'L'+$80,"OG"
1199: C55850                    defb    'E'+$80,"XP"
119C: C34F53                    defb    'C'+$80,"OS"
119F: D3494E                    defb    'S'+$80,"IN"
11A2: D4414E                    defb    'T'+$80,"AN"
11A5: C1544E                    defb    'A'+$80,"TN"
11A8: D045454B                  defb    'P'+$80,"EEK"
11AC: C445454B                  defb    'D'+$80,"EEK"
11B0: D6504545                  defb    'V'+$80,"PEEK"          ; added by Leonardo Miliani
11B4: 4B                
11B5: D6535441                  defb    'V'+$80,"STAT"          ; added by Leonardo Miliani
11B9: 54                
11BA: D3535441                  defb    'S'+$80,"STAT"          ; added by Leonardo Miliani
11BE: 54                
11BF: C94E4B45                  defb    'I'+$80,"NKEY"          ; added by Leonardo Miliani
11C3: 59                
11C4: D04F494E                  defb    'P'+$80,"OINT"          ; added by Leonardo Miliani
11C8: 54                
11C9: C94E5354                  defb    'I'+$80,"NSTR"          ; added by Leonardo Miliani
11CD: 52                
11CE: CC454E                    defb    'L'+$80,"EN"
11D1: D3545224                  defb    'S'+$80,"TR$"
11D5: D6414C                    defb    'V'+$80,"AL"
11D8: C15343                    defb    'A'+$80,"SC"
11DB: C3485224                  defb    'C'+$80,"HR$"
11DF: C8455824                  defb    'H'+$80,"EX$"           ; added by Grant Searle
11E3: C2494E24                  defb    'B'+$80,"IN$"           ; added by Grant Searle
11E7: CC454654                  defb    'L'+$80,"EFT$"
11EB: 24                
11EC: D2494748                  defb    'R'+$80,"IGHT$"
11F0: 5424              
11F2: CD494424                  defb    'M'+$80,"ID$"
11F6: 80                        defb    $80                     ; End-of-list marker
                        
                        ; KEYWORD ADDRESS TABLE
                        ; this list must be coherent with the commands'
                        ; tokens list above
11F7: 011B              WORDTB: defw    PEND
11F9: FE19                      defw    FOR
11FB: EF1E                      defw    NEXT
11FD: 5A1C                      defw    DATA
11FF: F41D                      defw    INPUT
1201: 4421                      defw    DIM
1203: 261E                      defw    READ
1205: 711C                      defw    LET
1207: 171C                      defw    GOTO
1209: F21B                      defw    RUN
120B: E91C                      defw    IF
120D: C71A                      defw    RESTOR
120F: 061C                      defw    GOSUB
1211: 351C                      defw    RETURN
1213: 5C1C                      defw    REM         ; original REM
1215: FF1A                      defw    STOP
1217: 8927                      defw    POUT
1219: CB1C                      defw    ON
121B: F93C                      defw    FILES       ; changed by Leonardo Miliani - was NULL
121D: FA3C                      defw    ERASE       ; added by Leonardo Miliani
121F: 8F27                      defw    WAIT
1221: 3823                      defw    DEF
1223: 8328                      defw    POKE
1225: 2732                      defw    DOKE
1227: 8828                      defw    VPOKE       ; added by Leonardo Miliani
1229: C528                      defw    SREG        ; added by Leonardo Miliani
122B: 142A                      defw    VREG        ; added by Leonardo Miliani
122D: 5D32                      defw    SCREEN      ; new behaviour: now it sets up a graphics mode (Leonardo Miliani)
122F: 9328                      defw    LOCATE      ; added by Leonardo Miliani
1231: 1F29                      defw    SOUND       ; added by Leonardo Miliani
1233: E628                      defw    VOLUME      ; added by Leonardo Miliani
1235: 3E32                      defw    PAUSE       ; added by Leonardo Miliani
1237: D832                      defw    COLOR       ; added by Leonardo Miliani
1239: C835                      defw    PLOT        ; added by Leonardo Miliani
123B: 5B36                      defw    DRAW        ; added by Leonardo Miliani
123D: 9137                      defw    CIRCLE      ; added by Leonardo Miliani
123F: 8534                      defw    PAINT       ; added by Leonardo Miliani
1241: 9639                      defw    SERIAL      ; added by Leonardo Miliani
1243: 913B                      defw    HELP        ; changed by Leonardo Miliani - was LINES
1245: 0032                      defw    CLS
1247: AC3B                      defw    KEY         ; added by Leonardo Miliani
1249: D127                      defw    NMI         ; added by Leonardo Miliani
124B: 9433                      defw    GPRINT      ; added by Leonardo Miliani
124D: 1432                      defw    WIDTH
124F: 2B28                      defw    SYS         ; added by Leonardo Miliani
1251: F13D                      defw    RESET       ; new behaviour: now it resets the system
1253: 5E1C                      defw    REM+2       ; ELSE: added by Leonardo Miliani
1255: 1B1D                      defw    PRINT
1257: 331B                      defw    CONT
1259: F318                      defw    LIST
125B: AC1B                      defw    CLEAR
125D: F73C                      defw    LOAD        ; re-implemented by Leonardo Miliani (was CLOAD)
125F: F83C                      defw    SAVE        ; re-implemented by Leonardo Miliani (was CSAVE)
1261: D816                      defw    NEW
                        
                        ; RESERVED WORD TOKEN VALUES
                        ; if you add a function or command you must increment by 1
                        ; the values below. Pay attention that you must increment only the
                        ; values AFTER the position where you entered the function/command word
                        ; in the "Reserver word list" above. I.E.: VPOKE has been added between
                        ; DOKE and SCREEN, and since REM is the reserved work listed below
                        ; that is before the point where VPOKE has been entered, every entry
                        ; after REM has been incremented.
                        ; Another example: when TMR has been added, since it's a function, every
                        ; entry after & included ZSGN must be checked (read below)
                        
0080:                   ZEND    equ     $80             ; END        <-- from here, there are the commands
0081:                   ZFOR    equ     $81             ; FOR
0083:                   ZDATA   equ     $83             ; DATA
0088:                   ZGOTO   equ     $88             ; GOTO
008C:                   ZGOSUB  equ     $8C             ; GOSUB
008E:                   ZREM    equ     $8E             ; REM
00AE:                   ZELSE   equ     $AE             ; ELSE
00AF:                   ZPRINT  equ     $AF             ; PRINT
00B5:                   ZNEW    equ     $B5             ; NEW
                        
00B6:                   ZTAB    equ     $B6             ; TAB
00B7:                   ZTO     equ     $B7             ; TO
00B8:                   ZFN     equ     $B8             ; FN
00B9:                   ZSPC    equ     $B9             ; SPC
00BA:                   ZTHEN   equ     $BA             ; THEN
00BB:                   ZNOT    equ     $BB             ; NOT
00BC:                   ZSTEP   equ     $BC             ; STEP
                        
00BD:                   ZPLUS   equ     $BD             ; +         <-- from here, there are the math operators
00BE:                   ZMINUS  equ     $BE             ; -
00BF:                   ZTIMES  equ     $BF             ; *
00C0:                   ZDIV    equ     $C0             ; /
00C1:                   ZMOD    equ     $C1             ; %
00C2:                   ZDINT   equ     $C2             ; #
00C6:                   ZOR     equ     $C6             ; OR
00C7:                   ZGTR    equ     $C7             ; >
00C8:                   ZEQUAL  equ     $C8             ; M
00C9:                   ZLTH    equ     $C9             ; <
                        
00CA:                   ZSGN    equ     $CA             ; SGN       <-- from here, there are the functions
00E0:                   ZPOINT  equ     $E0             ; ZPOINT    <-- if the user enters a custom function, between
                                                        ;               SGN and POINT, he/she must increment this pointer by 1
00E1:                   ZINSTR  equ     $E1             ; ZINSTR    <-- same here
00E9:                   ZLEFT   equ     $E9             ; LEFT$     <-- if the user enters a custom function anywhere,
                                                        ;               he/she must increment this pointer by 1
                        
                        ; ARITHMETIC PRECEDENCE TABLE
                        ; in the formulas below, <last> is a number stored into the stack that must be retrieved
                        ; with POP BC, POP DE; FPREG is a f.p. number store into the RAM register FPREG
1263: 79                PRITAB: defb    $79             ; Precedence value
1264: C92E                      defw    PADD            ; FPREG = <last> + FPREG
                        
1266: 79                        defb    $79             ; Precedence value
1267: AC2A                      defw    PSUB            ; FPREG = <last> - FPREG
                        
1269: 7C                        defb    $7C             ; Precedence value
126A: EA2B                      defw    MULT            ; PPREG = <last> * FPREG
                        
126C: 7C                        defb    $7C             ; Precedence value
126D: 9C2C                      defw    DIV             ; FPREG = <last> / FPREG
                        
126F: 7C                        defb    $7C             ; Precedence value
1270: 472C                      defw    MOD             ; FPREG = INT(<last>)-(INT(FPREG)*INT(<last>/FPREG))
                        
1272: 7C                        defb    $7C             ; precedence value
1273: 3F2C                      defw    DINT            ; FPREG = INT(<last> / FPREG )
                        
1275: 7F                        defb    $7F             ; Precedence value
1276: EA2F                      defw    POWER           ; FPREG = <last> ^ FPREG
                        
1278: 50                        defb    $50             ; Precedence value
1279: 8D20                      defw    PAND            ; FPREG = <last> AND FPREG
                        
127B: 4A                        defb    $4A             ; Precedence value
127C: 9520                      defw    PXOR            ; FPREG = <last> XOR FPREG
                        
127E: 46                        defb    $46             ; Precedence value
127F: 9020                      defw    POR             ; FPREG = <last> OR FPREG
                        
                        ; BASIC ERROR CODE LIST
                        
1281:                   ERRORS  equ $
1281: 4E455854          NFMSG:  defb    "NEXT Without FOR",0
1285: 20576974          
1289: 686F7574          
128D: 20464F52          
1291: 00                
1292: 53796E74          SNMSG:  defb    "Syntax",0
1296: 617800            
1299: 52455455          RGMSG:  defb    "RETURN without GOSUB",0
129D: 524E2077          
12A1: 6974686F          
12A5: 75742047          
12A9: 4F535542          
12AD: 00                
12AE: 4F757420          ODMSG:  defb    "Out of DATA",0
12B2: 6F662044          
12B6: 41544100          
12BA: 496C6C65          FCMSG:  defb    "Illegal Function Call",0
12BE: 67616C20          
12C2: 46756E63          
12C6: 74696F6E          
12CA: 2043616C          
12CE: 6C00              
12D0: 4F766572          OVMSG:  defb    "Overflow",0
12D4: 666C6F77          
12D8: 00                
12D9: 4F757420          OMMSG:  defb    "Out of Memory",0
12DD: 6F66204D          
12E1: 656D6F72          
12E5: 7900              
12E7: 556E6465          ULMSG:  defb    "Undefined Line",0
12EB: 66696E65          
12EF: 64204C69          
12F3: 6E6500            
12F6: 42616420          BSMSG:  defb    "Bad Subscript",0
12FA: 53756273          
12FE: 63726970          
1302: 7400              
1304: 52652D44          DDMSG:  defb    "Re-Dimensioned Array",0
1308: 696D656E          
130C: 73696F6E          
1310: 65642041          
1314: 72726179          
1318: 00                
1319: 44697669          DZMSG:  defb    "Division by Zero",0
131D: 73696F6E          
1321: 20627920          
1325: 5A65726F          
1329: 00                
132A: 496C6C65          IDMSG:  defb    "Illegal Direct",0
132E: 67616C20          
1332: 44697265          
1336: 637400            
1339: 54797065          TMMSG:  defb    "Type Mis-match",0
133D: 204D6973          
1341: 2D6D6174          
1345: 636800            
1348: 4F757420          OSMSG:  defb    "Out of String Space",0
134C: 6F662053          
1350: 7472696E          
1354: 67205370          
1358: 61636500          
135C: 53747269          LSMSG:  defb    "String Too Long",0
1360: 6E672054          
1364: 6F6F204C          
1368: 6F6E6700          
136C: 53747269          STMSG:  defb    "String Formula Too Complex",0
1370: 6E672046          
1374: 6F726D75          
1378: 6C612054          
137C: 6F6F2043          
1380: 6F6D706C          
1384: 657800            
1387: 43616E27          CNMSG:  defb    "Can't Continue",0
138B: 7420436F          
138F: 6E74696E          
1393: 756500            
1396: 556E6465          UFMSG:  defb    "Undefined FN Function",0
139A: 66696E65          
139E: 6420464E          
13A2: 2046756E          
13A6: 6374696F          
13AA: 6E00              
13AC: 4D697373          MOMSG:  defb    "Missing Operand",0
13B0: 696E6720          
13B4: 4F706572          
13B8: 616E6400          
13BC: 48455820          HXMSG:  defb    "HEX Format",0
13C0: 466F726D          
13C4: 617400            
13C7: 42494E20          BNMSG:  defb    "BIN Format",0
13CB: 466F726D          
13CF: 617400            
13D2: 4E6F2047          GMMSG:  defb    "No Graphics Mode",0
13D6: 72617068          
13DA: 69637320          
13DE: 4D6F6465          
13E2: 00                
13E3: 53657269          SCMSG:  defb    "Serial Configuration",0
13E7: 616C2043          
13EB: 6F6E6669          
13EF: 67757261          
13F3: 74696F6E          
13F7: 00                
13F8: 53657269          SAMSG:  defb    "Serial Port Already Open",0
13FC: 616C2050          
1400: 6F727420          
1404: 416C7265          
1408: 61647920          
140C: 4F70656E          
1410: 00                
1411: 48454C50          HPMSG:  defb    "HELP Call",0
1415: 2043616C          
1419: 6C00              
                        
141B:                   ERRTBL  equ $
141B: 8112              NFPTR   defw    NFMSG
141D: 9212              SNPTR   defw    SNMSG
141F: 9912              RGPTR   defw    RGMSG
1421: AE12              ODPTR   defw    ODMSG
1423: BA12              FCPTR   defw    FCMSG
1425: D012              OVPTR   defw    OVMSG
1427: D912              OMPTR   defw    OMMSG
1429: E712              ULPTR   defw    ULMSG
142B: F612              BSPTR   defw    BSMSG
142D: 0413              DDPTR   defw    DDMSG
142F: 1913              DZPTR   defw    DZMSG
1431: 2A13              IDPTR   defw    IDMSG
1433: 3913              TMPTR   defw    TMMSG
1435: 4813              OSPTR   defw    OSMSG
1437: 5C13              LSPTR   defw    LSMSG
1439: 6C13              STPTR   defw    STMSG
143B: 8713              CNPTR   defw    CNMSG
143D: 9613              UFPTR   defw    UFMSG
143F: AC13              MOPTR   defw    MOMSG
1441: BC13              HXPTR   defw    HXMSG
1443: C713              BNPTR   defw    BNMSG
1445: D213              GMPRT   defw    GMMSG
1447: E313              SCPTR   defw    SCMSG
1449: F813              SAPTR   defw    SAMSG
144B: 1114              HPPTR   defw    HPMSG
                        
                        ; INITIALISATION TABLE -------------------------------------------------------
                        ; these values are copied into RAM at startup
144D: C3B70F   [10]     INITAB: jp      WARMST          ; Warm start jump
1450: ED4500                    defb    $ED,$45,$00     ; RETN + NOP for default NMI service routine
1453: C3821B   [20]             jp      FCERR           ; "USR (X)" jump (Set to Error)
1456: D300     [31]             out     (0),A           ; "out p,n" skeleton
1458: C9       [41]             ret
1459: D600     [48]             sub     $00             ; Division support routine
145B: 6F       [52]             ld      L,A
145C: 7C       [56]             ld      A,H
145D: DE00     [63]             sbc     A,$00
145F: 67       [67]             ld      H,A
1460: 78       [71]             ld      A,B
1461: DE00     [78]             sbc     A,$00
1463: 47       [82]             ld      B,A
1464: 3E00     [89]             ld      A,$00
1466: C9       [99]             ret
1467: 000000                    defb    $00,$00,$00     ; Random number seed table used by RND
146A: 354ACA99                  defb    $35,$4A,$CA,$99 ;-2.65145E+07
146E: 391C7698                  defb    $39,$1C,$76,$98 ; 1.61291E+07
1472: 2295B398                  defb    $22,$95,$B3,$98 ;-1.17691E+07
1476: 0ADD4798                  defb    $0A,$DD,$47,$98 ; 1.30983E+07
147A: 53D19999                  defb    $53,$D1,$99,$99 ;-2-01612E+07
147E: 0A1A9F98                  defb    $0A,$1A,$9F,$98 ;-1.04269E+07
1482: 65BCCD98                  defb    $65,$BC,$CD,$98 ;-1.34831E+07
1486: D6773E98                  defb    $D6,$77,$3E,$98 ; 1.24825E+07
148A: 52C74F80                  defb    $52,$C7,$4F,$80 ; Last random number
148E: DB00     [110]            in      A,($00)         ; INP (x) skeleton
1490: C9       [120]            ret
1491: FF                        defb    $FF             ; Terminal width (255 = no auto CRLF)
1492: 14                        defb    $14             ; Width for commas (at reset, 3 columns, for G1 mode)
1493: 00                        defb    $00             ; No nulls after input bytes
1494: 00                        defb    $00             ; Output enabled (^O off)
1495: 0000                      defw    $00             ; Array load/save check sum
1497: 00                        defb    $00             ; Break not by NMI
1498: 00                        defb    $00             ; Break flag
1499: C31418   [130]            jp      TTYLIN          ; Input reflection (set to TTY)
149C: A582                      defw    STLOOK          ; Temp string space
149E: FEFF                      defw    -2              ; Current line number (cold)
14A0: FFFF                      defw    -1              ; Current line with errors (no errors)
14A2: 4C495354          DEFFNKS:defm    "LIST",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 1
14A6: 0D000000          
14AA: 00000000          
14AE: 00000000          
14B2: 52554E0D                  defm    "RUN",13,0,0,0,0,0,0,0,0,0,0,0,0    ; KEY 2
14B6: 00000000          
14BA: 00...             
14C2: 53435245                  defm    "SCREEN1",13,0,0,0,0,0,0,0,0        ; KEY 3
14C6: 454E310D          
14CA: 00000000          
14CE: 00000000          
14D2: 434F4C4F                  defm    "COLOR1,15,5",13,0,0,0,0            ; KEY 4
14D6: 52312C31          
14DA: 352C350D          
14DE: 00000000          
14E2: 53455249                  defm    "SERIAL1,38400",13,0,0              ; KEY 5
14E6: 414C312C          
14EA: 33383430          
14EE: 300D0000          
14F2: 53435245                  defm    "SCREEN2",13,0,0,0,0,0,0,0,0        ; KEY 6
14F6: 454E320D          
14FA: 00000000          
14FE: 00000000          
1502: 434F4E54                  defm    "CONT",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 7
1506: 0D000000          
150A: 00000000          
150E: 00000000          
1512: 48454C50                  defm    "HELP",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 8 (HELP KEY)
1516: 0D000000          
151A: 00000000          
151E: 00000000          
1522: 4282                      defw    PROGST+1        ; Start of program text
1524:                   INITBE:
                        
                        ; END OF INITIALISATION TABLE ---------------------------------------------------
                        
1524: 20457272          ERRMSG: defb    " Error",0
1528: 6F7200            
152B: 20696E20          INMSG:  defb    " in ",0
152F: 00                
152F:                   ZERBYT  equ     $-1             ; A zero byte
1530: 4F6B0D00          OKMSG:  defb    "Ok",CR,0,0
1534: 00                
1535: 42726561          BRKMSG: defb    "Break",0
1539: 6B00              
                        
153B: 210400   [10]     BAKSTK: ld      HL,$04          ; Look for "FOR" block with
153E: 39       [21]             add     HL,SP           ; same index as specified
153F: 7E       [ 7]     LOKFOR: ld      A,(HL)          ; Get block ID
1540: 23       [13]             inc     HL              ; Point to index address
1541: FE81     [20]             cp      ZFOR            ; Is it a "FOR" token
1543: C0       [25|31]          ret     NZ              ; No - exit
1544: 4E       [32]             ld      C,(HL)          ; BC = Address of "FOR" index
1545: 23       [38]             inc     HL
1546: 46       [45]             ld      B,(HL)
1547: 23       [51]             inc     HL              ; Point to sign of STEP
1548: E5       [62]             push    HL              ; Save pointer to sign
1549: 69       [66]             ld      L,C             ; HL = address of "FOR" index
154A: 60       [70]             ld      H,B
154B: 7A       [74]             ld      A,D             ; See if an index was specified
154C: B3       [78]             or      E               ; DE = 0 if no index specified
154D: EB       [82]             ex      DE,HL           ; Specified index into HL
154E: CA5515   [92|92]          jp      Z,INDFND        ; Skip if no index given
1551: EB       [96]             ex      DE,HL           ; Index back into DE
1552: CD8E18   [113]            call    CPDEHL          ; Compare index with one given
1555: 010D00   [10]     INDFND: ld      BC,16-3         ; Offset to next block
1558: E1       [20]             pop     HL              ; Restore pointer to sign
1559: C8       [25|31]          ret     Z               ; Return if block found
155A: 09       [36]             add     HL,BC           ; Point to next block
155B: C33F15   [46]             jp      LOKFOR          ; Keep on looking
                        
155E: CD7815   [17]     MOVUP:  call    ENFMEM          ; See if enough memory
1561: C5       [11]     MOVSTR: push    BC              ; Save end of source
1562: E3       [30]             ex      (SP),HL         ; Swap source and dest" end
1563: C1       [40]             pop     BC              ; Get end of destination
1564: CD8E18   [17]     MOVLP:  call    CPDEHL          ; See if list moved
1567: 7E       [24]             ld      A,(HL)          ; Get byte
1568: 02       [31]             ld      (BC),A          ; Move it
1569: C8       [36|42]          ret     Z               ; Exit if all done
156A: 0B       [42]             dec     BC              ; Next byte to move to
156B: 2B       [48]             dec     HL              ; Next byte to move
156C: C36415   [58]             jp      MOVLP           ; Loop until all bytes moved
                        
156F: E5       [11]     CHKSTK: push    HL              ; Save code string address
1570: 2A2282   [27]             ld      HL,(ARREND)     ; Lowest free memory
1573: 0600     [34]             ld      B,$00           ; BC = Number of levels to test
1575: 09       [45]             add     HL,BC           ; 2 Bytes for each level
1576: 09       [56]             add     HL,BC
1577: 3E                        defb    $3E             ; Skip "push HL"
1578: E5       [11]     ENFMEM: push    HL              ; Save code string address
1579: 3ED0     [18]             ld      A,$D0           ; LOW -48 ; 48 Bytes minimum RAM
157B: 95       [22]             sub     L
157C: 6F       [26]             ld      L,A
157D: 3EFF     [33]             ld      A,$FF           ; HIGH (-48) ; 48 Bytes minimum RAM
157F: 9C       [37]             sbc     A,H
1580: DA8715   [47|47]          jp      C,OMERR         ; Not enough - ?OM Error
1583: 67       [51]             ld      H,A
1584: 39       [62]             add     HL,SP           ; Test if stack is overflowed
1585: E1       [72]             pop     HL              ; Restore code string address
1586: D8       [77|83]          ret     C               ; Return if enough memory
1587: 1E0C     [ 7]     OMERR:  ld      E,OM            ; ?OM Error
1589: C3C615   [17]             jp      ERROR
                        
                        
                        ; if in graphics mode, return to text (called by "NOLIN" and "ERROR")
158C: F5       [11]     EXITGM: push    AF              ; store AF
158D: 3ACD81   [24]             ld      A,(SCR_MODE)    ; check screen mode
1590: FE02     [31]             cp      $02             ; G2?
1592: CA9915   [41|41]          jp      Z,LDG1          ; yes, back to G1
1595: FE03     [48]             cp      $03             ; G3?
1597: 2011     [55|60]          jr      NZ,LDG1ND       ; no, so return
1599: E5       [11]     LDG1:   push    HL              ; store HL
159A: D5       [22]             push    DE              ; store DE
159B: 110100   [32]             ld      DE,$0001        ; sprites set to defaults, G1 mode
159E: F3       [36]             di                      ; disable INTs
159F: CD9903   [53]             call    initVDP         ; initialize VDP with mode pointed by E
15A2: FB       [57]             ei                      ; re-enable INTs
15A3: 3E01     [64]             ld      A,$01           ; activate the...
15A5: 32D881   [77]             ld      (PRNTVIDEO),A   ; ...video buffer...
15A8: D1       [87]             pop     DE              ; retrieve DE
15A9: E1       [97]             pop     HL              ; retrieve HL
15AA: F1       [10]     LDG1ND: pop     AF              ; retrieve AF
15AB: C9       [20]             ret                     ; return to caller
                        
                        
15AC: 2AAE81   [16]     DATSNR: ld      HL,(DATLIN)     ; Get line of current DATA item
15AF: 22AF80   [32]             ld      (LINEAT),HL     ; Save as current line
15B2: 1E02     [ 7]     SNERR:  ld      E,SN            ; ?SN Error
15B4: 01                        defb    $01             ; Skip "ld E,DZ"
15B5: 1E14     [ 7]     DZERR:  ld      E,DZ            ; ?/0 Error
15B7: 01                        defb    $01             ; Skip "ld E,NF"
15B8: 1E00     [ 7]     NFERR:  ld      E,NF            ; ?NF Error
15BA: 01                        defb    $01             ; Skip "ld E,DD"
15BB: 1E12     [ 7]     DDERR:  ld      E,DD            ; ?DD Error
15BD: 01                        defb    $01             ; Skip "ld E,UF"
15BE: 1E22     [ 7]     UFERR:  ld      E,UF            ; ?UF Error
15C0: 01                        defb    $01             ; Skip "ld E,OV
15C1: 1E0A     [ 7]     OVERR:  ld      E,OV            ; ?OV Error
15C3: 01                        defb    $01             ; Skip "ld E,TM"
15C4: 1E18     [ 7]     TMERR:  ld      E,TM            ; ?TM Error
                        
15C6: CDFE16   [17]     ERROR:  call    CLREG           ; Clear registers and stack
15C9: CD8C15   [34]             call    EXITGM          ; exit from graphic modes
15CC: 32A580   [47]             ld      (CTLOFG),A      ; Enable output (A is 0)
15CF: CD7508   [64]             call    CURSOR_ON       ; enable cursor
15D2: CD6C1D   [81]             call    STTLIN          ; Start new line
15D5: 211B14   [91]             ld      HL,ERRTBL       ; Point to error codes
15D8: 57       [95]             ld      D,A             ; D = 0 (A is 0)
15D9: 3E3F     [102]            ld      A,'?'
15DB: CD9F18   [119]            call    OUTC            ; Output '?'
15DE: 19       [130]            add     HL,DE           ; Offset to correct error code
15DF: 5E       [137]            ld      E,(HL)          ; load pointer to error message
15E0: 23       [143]            inc     HL              ; by loading LSB,
15E1: 56       [150]            ld      D,(HL)          ; then MSB
15E2: 626B     [158]            ld      HL,DE           ; load pointer to HL
15E4: CD4224   [175]            call    PRS             ; Output error message
15E7: 212415   [185]            ld      HL,ERRMSG       ; "Error" message
15EA: CD4224   [17]     ERRIN:  call    PRS             ; Output message
15ED: 2AAF80   [33]             ld      HL,(LINEAT)     ; Get line of error
15F0: 11FEFF   [43]             ld      DE,-2           ; Cold start error if -2
15F3: CD8E18   [60]             call    CPDEHL          ; See if cold start error
15F6: CA1A0F   [70|70]          jp      Z,CSTART        ; Cold start error - Restart
15F9: 7C       [74]             ld      A,H             ; Was it a direct error?
15FA: A5       [78]             and     L               ; Line = -1 if direct error
15FB: 3C       [82]             inc     A
15FC: CA0716   [92|92]          jp      Z,PTLN          ; Yes, jump over
15FF: E5       [103]            push    HL              ; indirect mode - store HL
1600: 2AAF80   [119]            ld      HL,(LINEAT)     ; copy current line number
1603: 22B180   [135]            ld      (HLPLN),HL      ; save in HELP line register
1606: E1       [145]            pop     HL              ; retrieve HL
1607: C4DA2E   [10|17]  PTLN:   call    NZ,LINEIN       ; No - output line of error
                        
160A: 3E                        defb    $3E             ; Skip "pop BC"
160B: C1       [10]     POPNOK: pop     BC              ; Drop address in input buffer
                        
                        ; run into direct mode: print OK and get command
160C: AF       [ 4]     PRNTOK: xor     A               ; Output "Ok" and get command
160D: 32A580   [17]             ld      (CTLOFG),A      ; Enable output
1610: CD6C1D   [34]             call    STTLIN          ; Start new line
1613: 213015   [44]             ld      HL,OKMSG        ; "Ok" message
1616: CD4224   [61]             call    PRS             ; Output "Ok"
1619: CD7508   [17]     GETCMD: call    CURSOR_ON       ; enable cursor
161C: 21FFFF   [27]             ld      HL,-1           ; Flag direct mode
161F: 22AF80   [43]             ld      (LINEAT),HL     ; Save as current line
1622: CD1418   [60]             call    GETLIN          ; Get an input line
1625: DA1916   [70|70]          jp      C,GETCMD        ; Get line again if break
1628: CDB71A   [87]             call    GETCHR          ; Get first character
162B: 17       [91]             rla                     ; 8th bit is copied into carry and original carry is copied into bit 0)
162C: DAB215   [101|101]        jp      C,SNERR         ; if char >=128 (8th bit set) then raise an error
162F: 1F       [105]            rra                     ; recover original char and Carry
1630: 3C       [109]            inc     A               ; Test if end of line
1631: 3D       [113]            dec     A               ; Without affecting Carry
1632: CA1916   [123|123]        jp      Z,GETCMD        ; Nothing entered - Get another
1635: F5       [134]            push    AF              ; Save Carry status
1636: CD8B08   [151]            call    CURSOR_OFF      ; cursor disabled
1639: CD871B   [168]            call    ATOH            ; Get line number into DE
163C: D5       [179]            push    DE              ; Save line number
163D: CD2B17   [196]            call    CRUNCH          ; Tokenise rest of line
1640: 47       [200]            ld      B,A             ; Length of tokenised line
1641: D1       [210]            pop     DE              ; Restore line number
1642: F1       [220]            pop     AF              ; Restore Carry
1643: D2971A   [230|230]        jp      NC,EXCUTE       ; No line number - Direct mode
1646: D5       [241]            push    DE              ; Save line number
1647: C5       [252]            push    BC              ; Save length of tokenised line
1648: AF       [256]            xor     A
1649: 32B181   [269]            ld      (LSTBIN),A      ; Clear last byte input
164C: CDB71A   [286]            call    GETCHR          ; Get next character
164F: B7       [290]            or      A               ; Set flags
1650: F5       [301]            push    AF              ; And save them
1651: CDB816   [318]            call    SRCHLN          ; Search for line number in DE
1654: DA5D16   [328|328]        jp      C,LINFND        ; Jump if line found
1657: F1       [338]            pop     AF              ; Get status
1658: F5       [349]            push    AF              ; And re-save
1659: CA301C   [359|359]        jp      Z,ULERR         ; Nothing after number - Error
165C: B7       [363]            or      A               ; Clear Carry
165D: C5       [11]     LINFND: push    BC              ; Save address of line in prog
165E: D27416   [21|21]          jp      NC,INEWLN       ; Line not found - Insert new
1661: EB       [25]             ex      DE,HL           ; Next line address in DE
1662: 2A1E82   [41]             ld      HL,(PROGND)     ; End of program
1665: 1A       [ 7]     SFTPRG: ld      A,(DE)          ; Shift rest of program down
1666: 02       [14]             ld      (BC),A
1667: 03       [20]             inc     BC              ; Next destination
1668: 13       [26]             inc     DE              ; Next source
1669: CD8E18   [43]             call    CPDEHL          ; All done?
166C: C26516   [53|53]          jp      NZ,SFTPRG       ; More to do
166F: 60       [57]             ld      H,B             ; HL - New end of program
1670: 69       [61]             ld      L,C
1671: 221E82   [77]             ld      (PROGND),HL     ; Update end of program
                        
1674: D1       [10]     INEWLN: pop     DE              ; Get address of line,
1675: F1       [20]             pop     AF              ; Get status
1676: CA9B16   [30|30]          jp      Z,SETPTR        ; No text - Set up pointers
1679: 2A1E82   [46]             ld      HL,(PROGND)     ; Get end of program
167C: E3       [65]             ex      (SP),HL         ; Get length of input line
167D: C1       [75]             pop     BC              ; End of program to BC
167E: 09       [86]             add     HL,BC           ; Find new end
167F: E5       [97]             push    HL              ; Save new end
1680: CD5E15   [114]            call    MOVUP           ; Make space for line
1683: E1       [124]            pop     HL              ; Restore new end
1684: 221E82   [140]            ld      (PROGND),HL     ; Update end of program pointer
1687: EB       [144]            ex      DE,HL           ; Get line to move up in HL
1688: 74       [151]            ld      (HL),H          ; Save MSB
1689: D1       [161]            pop     DE              ; Get new line number
168A: 23       [167]            inc     HL              ; Skip pointer
168B: 23       [173]            inc     HL
168C: 73       [180]            ld      (HL),E          ; Save LSB of line number
168D: 23       [186]            inc     HL
168E: 72       [193]            ld      (HL),D          ; Save MSB of line number
168F: 23       [199]            inc     HL              ; To first byte in line
1690: 113681   [209]            ld      DE,BUFFER       ; Copy buffer to program
1693: 1A       [ 7]     MOVBUF: ld      A,(DE)          ; Get source
1694: 77       [14]             ld      (HL),A          ; Save destinations
1695: 23       [20]             inc     HL              ; Next source
1696: 13       [26]             inc     DE              ; Next destination
1697: B7       [30]             or      A               ; Done?
1698: C29316   [40|40]          jp      NZ,MOVBUF       ; No - Repeat
169B: CDE416   [17]     SETPTR: call    RUNFST          ; Set line pointers
169E: 23       [23]             inc     HL              ; To LSB of pointer
169F: EB       [27]             ex      DE,HL           ; Address to DE
16A0: 62       [ 4]     PTRLP:  ld      H,D             ; Address to HL
16A1: 6B       [ 8]             ld      L,E
16A2: 7E       [15]             ld      A,(HL)          ; Get LSB of pointer
16A3: 23       [21]             inc     HL              ; To MSB of pointer
16A4: B6       [28]             or      (HL)            ; Compare with MSB pointer
16A5: CA1916   [38|38]          jp      Z,GETCMD        ; Get command line if end
16A8: 23       [44]             inc     HL              ; To LSB of line number
16A9: 23       [50]             inc     HL              ; Skip line number
16AA: 23       [56]             inc     HL              ; Point to first byte in line
16AB: AF       [60]             xor     A               ; Looking for 00 byte
16AC: BE       [ 7]     FNDEND: cp      (HL)            ; Found end of line?
16AD: 23       [13]             inc     HL              ; Move to next byte
16AE: C2AC16   [23|23]          jp      NZ,FNDEND       ; No - Keep looking
16B1: EB       [27]             ex      DE,HL           ; Next line address to HL
16B2: 73       [34]             ld      (HL),E          ; Save LSB of pointer
16B3: 23       [40]             inc     HL
16B4: 72       [47]             ld      (HL),D          ; Save MSB of pointer
16B5: C3A016   [57]             jp      PTRLP           ; Do next line
                        
16B8: 2A3381   [16]     SRCHLN: ld      HL,(BASTXT)     ; Start of program text
16BB: 44       [ 4]     SRCHLP: ld      B,H             ; BC = Address to look at
16BC: 4D       [ 8]             ld      C,L
16BD: 7E       [15]             ld      A,(HL)          ; Get address of next line
16BE: 23       [21]             inc     HL
16BF: B6       [28]             or      (HL)            ; End of program found?
16C0: 2B       [34]             dec     HL
16C1: C8       [39|45]          ret     Z               ; Yes - Line not found
16C2: 23       [45]             inc     HL
16C3: 23       [51]             inc     HL
16C4: 7E       [58]             ld      A,(HL)          ; Get LSB of line number
16C5: 23       [64]             inc     HL
16C6: 66       [71]             ld      H,(HL)          ; Get MSB of line number
16C7: 6F       [75]             ld      L,A
16C8: CD8E18   [92]             call    CPDEHL          ; Compare with line in DE
16CB: 60       [96]             ld      H,B             ; HL = Start of this line
16CC: 69       [100]            ld      L,C
16CD: 7E       [107]            ld      A,(HL)          ; Get LSB of next line address
16CE: 23       [113]            inc     HL
16CF: 66       [120]            ld      H,(HL)          ; Get MSB of next line address
16D0: 6F       [124]            ld      L,A             ; Next line to HL
16D1: 3F       [128]            ccf
16D2: C8       [133|139]        ret     Z               ; Lines found - Exit
16D3: 3F       [137]            ccf
16D4: D0       [142|148]        ret     NC              ; Line not found,at line after
16D5: C3BB16   [152]            jp      SRCHLP          ; Keep looking
                        
16D8: C0       [ 5|11]  NEW:    ret     NZ              ; Return if any more on line
16D9: 2A3381   [16]     CLRPTR: ld      HL,(BASTXT)     ; Point to start of program
16DC: AF       [20]             xor     A               ; Set program area to empty
16DD: 77       [27]             ld      (HL),A          ; Save LSB = 00
16DE: 23       [33]             inc     HL
16DF: 77       [40]             ld      (HL),A          ; Save MSB = 00
16E0: 23       [46]             inc     HL
16E1: 221E82   [62]             ld      (PROGND),HL     ; Set program end
                        
16E4: 2A3381   [16]     RUNFST: ld      HL,(BASTXT)     ; Clear all variables
16E7: 2B       [22]             dec     HL
                        
16E8: 22B381   [16]     INTVAR: ld      (BRKLIN),HL     ; Initialise RUN variables
16EB: 2A9481   [32]             ld      HL,(LSTRAM)     ; Get end of RAM
16EE: 22A881   [48]             ld      (STRBOT),HL     ; Clear string space
16F1: AF       [52]             xor     A
16F2: CDC71A   [69]             call    RESTOR          ; Reset DATA pointers
16F5: 2A1E82   [85]             ld      HL,(PROGND)     ; Get end of program
16F8: 222082   [101]            ld      (VAREND),HL     ; Clear variables
16FB: 222282   [117]            ld      (ARREND),HL     ; Clear arrays
                        
16FE: C1       [10]     CLREG:  pop     BC              ; Save return address
16FF: 2AAD80   [26]             ld      HL,(STRSPC)     ; Get end of working RAM
1702: F9       [32]             ld      SP,HL           ; Set stack
1703: 219881   [42]             ld      HL,TMSTPL       ; Temporary string pool
1706: 229681   [58]             ld      (TMSTPT),HL     ; Reset temporary string ptr
1709: AF       [62]             xor     A               ; A = 00
170A: 6F       [66]             ld      L,A             ; HL = 0000
170B: 67       [70]             ld      H,A
170C: 22B981   [86]             ld      (CONTAD),HL     ; No CONTinue
170F: 32B081   [99]             ld      (FORFLG),A      ; Clear FOR flag
1712: 222682   [115]            ld      (FNRGNM),HL     ; Clear FN argument
1715: E5       [126]            push    HL              ; HL = 0000
1716: C5       [137]            push    BC              ; Put back return
1717: 2AB381   [16]     DOAGN:  ld      HL,(BRKLIN)     ; Get address of code to RUN
171A: C9       [26]             ret                     ; Return to execution driver
                        
171B: 3E3F     [ 7]     PROMPT: ld      A,'?'           ; '?'
171D: CD9F18   [24]             call    OUTC            ; Output character
1720: 3E00     [31]             ld      A,NLLCR         ; null char
1722: CD9F18   [48]             call    OUTC            ; Output character
1725: CD7508   [65]             call    CURSOR_ON       ; enable cursor
1728: C3AA80   [75]             jp      RINPUT          ; Get input line
                        
172B: AF       [ 4]     CRUNCH: xor     A               ; Tokenise line @ HL to BUFFER
172C: 329381   [17]             ld      (DATFLG),A      ; Reset literal flag
172F: 0E05     [24]             ld      C,2+3           ; 2 byte number and 3 nulls
1731: 113681   [34]             ld      DE,BUFFER       ; Start of input buffer
1734: 7E       [ 7]     CRNCLP: ld      A,(HL)          ; Get byte
1735: FE20     [14]             cp      SPC             ; Is it a space?
1737: CAB317   [24|24]          jp      Z,MOVDIR        ; Yes - Copy direct
173A: 47       [28]             ld      B,A             ; Save character
173B: FE22     [35]             cp      $22             ; '"'             ; Is it a quote?
173D: CAD317   [45|45]          jp      Z,CPYLIT        ; Yes - Copy literal string
1740: B7       [49]             or      A               ; Is it end of buffer?
1741: CADA17   [59|59]          jp      Z,ENDBUF        ; Yes - End buffer
1744: 3A9381   [72]             ld      A,(DATFLG)      ; Get data type
1747: B7       [76]             or      A               ; Literal?
1748: 7E       [83]             ld      A,(HL)          ; Get byte to copy
1749: C2B317   [93|93]          jp      NZ,MOVDIR       ; Literal - Copy direct
174C: FE3F     [100]            cp      '?'             ; Is it '?' short for PRINT
174E: 3EAF     [107]            ld      A,ZPRINT        ; "PRINT" token
1750: CAB317   [117|117]        jp      Z,MOVDIR        ; Yes - replace it
1753: 7E       [124]            ld      A,(HL)          ; Get byte again
1754: FE30     [131]            cp      '0'             ; Is it less than '0'
1756: DA5E17   [141|141]        jp      C,FNDWRD        ; Yes - Look for reserved words
1759: FE3C     [148]            cp      $3C  ;60; ";"+1       ; Is it "0123456789:;" ?
175B: DAB317   [158|158]        jp      C,MOVDIR        ; Yes - copy it direct
175E: D5       [11]     FNDWRD: push    DE              ; Look for reserved words
175F: 116910   [21]             ld      DE,WORDS-1      ; Point to table
1762: C5       [32]             push    BC              ; Save count
1763: 01AF17   [42]             ld      BC,RETNAD       ; Where to return to
1766: C5       [53]             push    BC              ; Save return address
1767: 067F     [60]             ld      B,ZEND-1        ; First token value -1
1769: 7E       [67]             ld      A,(HL)          ; Get byte
176A: FE61     [74]             cp      'a'             ; Less than 'a' ?
176C: DA7717   [84|84]          jp      C,SEARCH        ; Yes - search for words
176F: FE7B     [91]             cp      'z'+1           ; Greater than 'z' ?
1771: D27717   [101|101]        jp      NC,SEARCH       ; Yes - search for words
1774: E65F     [108]            and     %01011111       ; Force upper case
1776: 77       [115]            ld      (HL),A          ; Replace byte
1777: 4E       [ 7]     SEARCH: ld      C,(HL)          ; Search for a word
1778: EB       [11]             ex      DE,HL
1779: 23       [ 6]     GETNXT: inc     HL              ; Get next reserved word
177A: B6       [13]             or      (HL)            ; Start of word?
177B: F27917   [23|23]          jp      P,GETNXT        ; No - move on
177E: 04       [27]             inc     B               ; Increment token value
177F: 7E       [34]             ld      A,(HL)          ; Get byte from table
1780: E67F     [41]             and     %01111111       ; Strip bit 7
1782: C8       [46|52]          ret     Z               ; Return if end of list
1783: B9       [50]             cp      C               ; Same character as in buffer?
1784: C27917   [60|60]          jp      NZ,GETNXT       ; No - get next word
1787: EB       [64]             ex      DE,HL
1788: E5       [75]             push    HL              ; Save start of word
                        
1789: 13       [ 6]     NXTBYT: inc     DE              ; Look through rest of word
178A: 1A       [13]             ld      A,(DE)          ; Get byte from table
178B: B7       [17]             or      A               ; End of word ?
178C: FAAB17   [27|27]          jp      M,MATCH         ; Yes - Match found
178F: 4F       [31]             ld      C,A             ; Save it
1790: 78       [35]             ld      A,B             ; Get token value
1791: FE88     [42]             cp      ZGOTO           ; Is it "GOTO" token ?
1793: C29A17   [52|52]          jp      NZ,NOSPC        ; No - Don't allow spaces
1796: CDB71A   [69]             call    GETCHR          ; Get next character
1799: 2B       [75]             dec     HL              ; Cancel increment from GETCHR
179A: 23       [ 6]     NOSPC:  inc     HL              ; Next byte
179B: 7E       [13]             ld      A,(HL)          ; Get byte
179C: FE61     [20]             cp      'a'             ; Less than 'a' ?
179E: DAA317   [30|30]          jp      C,NOCHNG        ; Yes - don't change
17A1: E65F     [37]             and     %01011111       ; Make upper case
17A3: B9       [ 4]     NOCHNG: cp      C               ; Same as in buffer ?
17A4: CA8917   [14|14]          jp      Z,NXTBYT        ; Yes - keep testing
17A7: E1       [24]             pop     HL              ; Get back start of word
17A8: C37717   [34]             jp      SEARCH          ; Look at next word
                        
17AB: 48       [ 4]     MATCH:  ld      C,B             ; Word found - Save token value
17AC: F1       [14]             pop     AF              ; Throw away return
17AD: EB       [18]             ex      DE,HL
17AE: C9       [28]             ret                     ; Return to "RETNAD"
17AF: EB       [ 4]     RETNAD: ex      DE,HL           ; Get address in string
17B0: 79       [ 8]             ld      A,C             ; Get token value
17B1: C1       [18]             pop     BC              ; Restore buffer length
17B2: D1       [28]             pop     DE              ; Get destination address
17B3: 23       [ 6]     MOVDIR: inc     HL              ; Next source in buffer
17B4: 12       [13]             ld      (DE),A          ; Put byte in buffer
17B5: 13       [19]             inc     DE              ; Move up buffer
17B6: 0C       [23]             inc     C               ; Increment length of buffer
17B7: D63A     [30]             sub     ':'             ; End of statement?
17B9: CAC117   [40|40]          jp      Z,SETLIT        ; Jump if multi-statement line
17BC: FE49     [47]             cp      ZDATA-$3A       ; Is it DATA statement ?
17BE: C2C417   [57|57]          jp      NZ,TSTREM       ; No - see if REM
17C1: 329381   [13]     SETLIT: ld      (DATFLG),A      ; Set literal flag
17C4: D654     [ 7]     TSTREM: sub     ZREM-$3A        ; Is it REM?
17C6: C23417   [17|17]          jp      NZ,CRNCLP       ; No - Leave flag
17C9: 47       [21]             ld      B,A             ; Copy rest of buffer
17CA: 7E       [ 7]     NXTCHR: ld      A,(HL)          ; Get byte
17CB: B7       [11]             or      A               ; End of line ?
17CC: CADA17   [21|21]          jp      Z,ENDBUF        ; Yes - Terminate buffer
17CF: B8       [25]             cp      B               ; End of statement ?
17D0: CAB317   [35|35]          jp      Z,MOVDIR        ; Yes - Get next one
17D3: 23       [ 6]     CPYLIT: inc     HL              ; Move up source string
17D4: 12       [13]             ld      (DE),A          ; Save in destination
17D5: 0C       [17]             inc     C               ; Increment length
17D6: 13       [23]             inc     DE              ; Move up destination
17D7: C3CA17   [33]             jp      NXTCHR          ; Repeat
                        
17DA: 213581   [10]     ENDBUF: ld      HL,BUFFER-1     ; Point to start of buffer
17DD: 12       [17]             ld      (DE),A          ; Mark end of buffer (A = 00)
17DE: 13       [23]             inc     DE
17DF: 12       [30]             ld      (DE),A          ; A = 00
17E0: 13       [36]             inc     DE
17E1: 12       [43]             ld      (DE),A          ; A = 00
17E2: C9       [53]             ret
                        
17E3: 3AA480   [13]     DODEL:  ld      A,(NULFLG)      ; Get null flag status
17E6: B7       [17]             or      A               ; Is it zero?
17E7: 3E00     [24]             ld      A,$00           ; Zero A - Leave flags
17E9: 32A480   [37]             ld      (NULFLG),A      ; Zero null flag
17EC: C2F717   [47|47]          jp      NZ,ECHDEL       ; Set - Echo it
17EF: 05       [51]             dec     B               ; Decrement length
17F0: CA1418   [61|61]          jp      Z,GETLIN        ; Get line again if empty
17F3: CD9F18   [78]             call    OUTC            ; Output null character
17F6: 3E                        defb    $3E             ; Skip "dec B"
17F7: 05       [ 4]     ECHDEL: dec     B               ; Count bytes in buffer
17F8: 2B       [10]             dec     HL              ; Back space buffer
17F9: CA0B18   [20|20]          jp      Z,OTKLN         ; No buffer - Try again
17FC: 7E       [27]             ld      A,(HL)          ; Get deleted byte
17FD: CD9F18   [44]             call    OUTC            ; Echo it
1800: C31D18   [54]             jp      MORINP          ; Get more input
                        
1803: 05       [ 4]     DELCHR: dec     B               ; Count bytes in buffer
1804: 2B       [10]             dec     HL              ; Back space buffer
1805: CD9F18   [27]             call    OUTC            ; Output character in A
1808: C21D18   [37|37]          jp      NZ,MORINP       ; Not end - Get more
180B: CD9F18   [17]     OTKLN:  call    OUTC            ; Output character in A
180E: CD7E1D   [17]     KILIN:  call    PRNTCRLF        ; Output CRLF
1811: C31418   [27]             jp      TTYLIN          ; Get line again
                        
1814:                   GETLIN:
1814: 213681   [10]     TTYLIN: ld      HL,BUFFER       ; Get a line by character
1817: 0601     [17]             ld      B,$01           ; Set buffer as empty
1819: AF       [21]             xor     A
181A: 32A480   [34]             ld      (NULFLG),A      ; Clear null flag
181D: CDE018   [17]     MORINP: call    CLOTST          ; Get character and test ^O
1820: 4F       [21]             ld      C,A             ; Save character in C
1821: FE7F     [28]             cp      DEL             ; Delete character?
1823: CAE317   [38|38]          jp      Z,DODEL         ; Yes - Process it
1826: 3AA480   [51]             ld      A,(NULFLG)      ; Get null flag
1829: B7       [55]             or      A               ; Test null flag status
182A: CA3618   [65|65]          jp      Z,PROCES        ; Reset - Process character
182D: 3E00     [72]             ld      A,$00           ; Set a null
182F: CD9F18   [89]             call    OUTC            ; Output null
1832: AF       [93]             xor     A               ; Clear A
1833: 32A480   [106]            ld      (NULFLG),A      ; Reset null flag
1836: 79       [ 4]     PROCES: ld      A,C             ; Get character
1837: FE07     [11]             cp      CTRLG           ; Bell?
1839: CA7618   [21|21]          jp      Z,PUTCTL        ; Yes - Save it
183C: FE03     [28]             cp      CTRLC           ; Is it control "C"?
183E: CC6B18   [38|45]          call    Z,GMNCR         ; Yes - exit from graphic mode & Output CRLF
1841: 37       [42]             scf                     ; Flag break
1842: C8       [47|53]          ret     Z               ; Return if control "C"
1843: FE0D     [54]             cp      CR              ; Is it enter?
1845: CA741D   [64|64]          jp      Z,ENDINP        ; Yes - Terminate input
1848: FE15     [71]             cp      CTRLU           ; Is it control "U"?
184A: CA0E18   [81|81]          jp      Z,KILIN         ; Yes - Get another line
184D: FE08     [88]             cp      BKSP            ; Is it backspace?
184F: CA0318   [98|98]          jp      Z,DELCHR        ; Yes - Delete character
1852: FE12     [105]            cp      CTRLR           ; Is it control "R"?
1854: C27118   [115|115]        jp      NZ,PUTBUF       ; No - Put in buffer
1857: C5       [126]            push    BC              ; Save buffer length
1858: D5       [137]            push    DE              ; Save DE
1859: E5       [148]            push    HL              ; Save buffer address
185A: 3600     [158]            ld      (HL),$00        ; Mark end of buffer
185C: CD0F3E   [175]            call    OUTNCR          ; Output and do CRLF
185F: 213681   [185]            ld      HL,BUFFER       ; Point to buffer start
1862: CD4224   [202]            call    PRS             ; Output buffer
1865: E1       [212]            pop     HL              ; Restore buffer address
1866: D1       [222]            pop     DE              ; Restore DE
1867: C1       [232]            pop     BC              ; Restore buffer length
1868: C31D18   [242]            jp      MORINP          ; Get another character
186B: CD8C15   [17]     GMNCR:  call    EXITGM          ; exit from graphic mode
186E: C37E1D   [27]             jp      PRNTCRLF        ; output CRLF
                        
1871: FE20     [ 7]     PUTBUF: cp      SPC             ; Is it a control code?
1873: DA1D18   [17|17]          jp      C,MORINP        ; Yes - Ignore
1876: 78       [ 4]     PUTCTL: ld      A,B             ; Get number of bytes in buffer
1877: FE59     [11]             cp      $58+$01         ; Test for line overflow
1879: 3E08     [18]             ld      A,BKSP          ; Set a bell
187B: D28818   [28|28]          jp      NC,OUTNBS       ; Ring bell if buffer full
187E: 79       [32]             ld      A,C             ; Get character
187F: 71       [39]             ld      (HL),C          ; Save in buffer
1880: 32B181   [52]             ld      (LSTBIN),A      ; Save last input byte
1883: 23       [58]             inc     HL              ; Move up buffer
1884: 04       [62]             inc     B               ; Increment length
1885: C31D18   [10]     OUTIT:  jp      MORINP          ; Get another character
                        
1888: CD9F18   [17]     OUTNBS: call    OUTC            ; Output bell and back over it
                                ;ld      A,BKSP          ; send back space
                                ;call    OUTC            ;
188B: C38518   [27]             jp      OUTIT           ; get more chars
                        
188E: 7C       [ 4]     CPDEHL: ld      A,H             ; Get H
188F: 92       [ 8]             sub     D               ; Compare with D
1890: C0       [13|19]          ret     NZ              ; Different - Exit
1891: 7D       [17]             ld      A,L             ; Get L
1892: 93       [21]             sub     E               ; Compare with E
1893: C9       [31]             ret                     ; Return status
                        
1894: 7E       [ 7]     CHKSYN: ld      A,(HL)          ; Check syntax of character
1895: E3       [26]             ex      (SP),HL         ; Address of test byte
1896: BE       [33]             cp      (HL)            ; Same as in code string?
1897: 23       [39]             inc     HL              ; Return address
1898: E3       [58]             ex      (SP),HL         ; Put it back
1899: CAB71A   [68|68]          jp      Z,GETCHR        ; Yes - Get next character
189C: C3B215   [78]             jp      SNERR           ; Different - ?SN Error
                        
189F: F5       [11]     OUTC:   push    AF              ; Save character
18A0: 3AA580   [24]             ld      A,(CTLOFG)      ; Get control "O" flag
18A3: B7       [28]             or      A               ; Is it set?
18A4: C27724   [38|38]          jp      NZ,POPAF        ; Yes - don't output
18A7: F1       [48]             pop     AF              ; Restore character
18A8: C5       [59]             push    BC              ; Save buffer length
18A9: F5       [70]             push    AF              ; Save character
18AA: FE20     [77]             cp      SPC             ; Is it a control code?
18AC: DAC318   [87|87]          jp      C,DINPOS        ; Yes - Don't inc POS(X)
18AF: 3AA280   [100]            ld      A,(LWIDTH)      ; Get line width
18B2: 47       [104]            ld      B,A             ; To B
18B3: 3A9081   [117]            ld      A,(CURPOS)      ; Get cursor position
18B6: 04       [121]            inc     B               ; Width 255?
18B7: CABF18   [131|131]        jp      Z,INCLEN        ; Yes - No width limit
18BA: 05       [135]            dec     B               ; Restore width
18BB: B8       [139]            cp      B               ; At end of line?
18BC: CC7E1D   [149|156]        call    Z,PRNTCRLF      ; Yes - output CRLF
18BF: 3C       [ 4]     INCLEN: inc     A               ; Move on one character
18C0: 329081   [17]             ld      (CURPOS),A      ; Save new position
18C3: AF       [ 4]     DINPOS: xor     A
18C4: 321682   [17]             ld      (KBDNPT),A      ; set flag for no char from keyboard
18C7: F1       [27]             pop     AF              ; Restore character
18C8: C1       [37]             pop     BC              ; Restore buffer length
18C9: F5       [48]             push    AF
18CA: CDD218   [65]             call    SND2VID         ; send char to video
18CD: F1       [75]             pop     AF
18CE: CDEE3D   [92]             call    MONOUT          ; send char to serial if enabled
18D1: C9       [102]            ret
                        
                        ; print char to video if cursor is on
18D2: 32D981   [13]     SND2VID:ld      (CHR4VID),A     ; store A
18D5: 3AD881   [26]             ld      A,(PRNTVIDEO)   ; check print-on-video
18D8: B7       [30]             or      A               ; is it off?
18D9: C8       [35|41]          ret     Z               ; yes, so return
18DA: F3       [39]             di                      ; disable INTs
18DB: CDE306   [56]             call    CHAR2VID        ; cursor is on, so print char on screen
18DE: FB       [60]             ei                      ; re-enable INTs
18DF: C9       [70]             ret                     ; return to caller
                        
18E0: CDFE31   [17]     CLOTST: call    GETINP          ; Get input character
18E3: FE0F     [24]             cp      CTRLO           ; Is it control "O"?
18E5: C0       [29|35]          ret     NZ              ; No don't flip flag
18E6: 3AA580   [42]             ld      A,(CTLOFG)      ; Get flag
18E9: 2F       [46]             cpl                     ; Flip it
18EA: 32A580   [59]             ld      (CTLOFG),A      ; Put it back
18ED: A7       [63]             and     A               ; is output enabled?
18EE: CC7508   [73|80]          call    Z,CURSOR_ON     ; yes, so cursor on
18F1: AF       [77]             xor     A               ; Null character
18F2: C9       [87]             ret
                        
                        ; LIST: list the program stored into memory
18F3: C1       [10]     LIST:   pop     BC              ; rubbish - not needed (legacy from original call of LIST)
18F4: 2B       [16]             dec     HL              ; dec 'cos GETCHR INCs
18F5: CDB71A   [33]             call    GETCHR          ; Get next character
18F8: CA4419   [43|43]          jp      Z,LSTALL        ; list all if nothing follows
18FB: FEBE     [50]             cp      ZMINUS          ; is it '-'?
18FD: 2020     [57|62]          jr      NZ,LST01        ; no, look for a line number
18FF: 110000   [67]             ld      DE,$0000        ; yes, set search from 0
1902: CDDF19   [84]             call    SRCHLIN         ; find address of line number
1905: ED43DC81 [104]            ld      (TMPBFR1),BC    ; store address of starting line
1909: CD9418   [121]            call    CHKSYN          ; skip '-'
190C: BE                        defb    ZMINUS
190D: CD871B   [138]            call    ATOH            ; now, look for another number (ASCII number to DE)
1910: CDDF19   [155]            call    SRCHLIN         ; find address of line number
1913: ED43DE81 [175]            ld      (TMPBFR2),BC    ; store address of ending line
1917: ED4BDC81 [195]            ld      BC,(TMPBFR1)    ; retrieve address of starting line
191B: C5       [206]            push    BC              ; store address of line for later use
191C: C37619   [216]            jp      LISTLP          ; go listing
191F: CD871B   [17]     LST01:  call    ATOH            ; get a line number (ASCII number to DE)
1922: CDDF19   [17]     LST01H: call    SRCHLIN         ; find address of line number
1925: ED43DC81 [37]             ld      (TMPBFR1),BC    ; store address of starting line
1929: ED43DE81 [57]             ld      (TMPBFR2),BC    ; same address for ending line (we'll change later if needed)
192D: 2B       [63]             dec     HL              ; dec 'cos GETCHR INCs
192E: CDB71A   [80]             call    GETCHR          ; Get next character
1931: CA4019   [90|90]          jp      Z,LST06         ; nothing follows, so ending & starting lines are the same
1934: FEBE     [97]             cp      ZMINUS          ; is it '-'?
1936: CA5C19   [107|107]        jp      Z,LST03         ; yes, read ending line
1939: CDDF19   [17]     LST04:  call    SRCHLIN         ; find address of line number
193C: ED43DE81 [37]             ld      (TMPBFR2),BC    ; set address of ending line
1940: C5       [11]     LST06:  push    BC              ; store address for later use
1941: C37619   [21]             jp      LISTLP          ; jump to list
1944: 11F9FF   [10]     LSTALL  ld      DE,65529        ; set ending line to max. allowed line number
1947: CDDF19   [27]             call    SRCHLIN         ; get address of last line
194A: ED43DE81 [47]             ld      (TMPBFR2),BC    ; store it
194E: 110000   [57]             ld      DE,$0000        ; set start to first line in memory
1951: CDDF19   [74]             call    SRCHLIN         ; get address of first line
1954: ED43DC81 [94]             ld      (TMPBFR1),BC    ; store it
1958: C5       [105]            push    BC              ; store address of starting line for later use
1959: C37619   [115]            jp      LISTLP          ; start printing
195C: CD9418   [17]     LST03:  call    CHKSYN          ; skip '-'
195F: BE                        defb    ZMINUS
1960: CD871B   [34]             call    ATOH            ; look for another number (return into DE)
1963: 7A       [38]             ld      A,D
1964: B3       [42]             or      E               ; is line=0?
1965: 2003     [49|54]          jr      NZ,LST05        ; no, jump over
1967: 11F9FF   [59]             ld      DE,65529        ; yes set last valid line number
196A: CDDF19   [17]     LST05:  call    SRCHLIN         ; find address of line number
196D: ED43DE81 [37]             ld      (TMPBFR2),BC    ; store address of ending line
1971: ED4BDC81 [57]             ld      BC,(TMPBFR1)    ; retrieve address of starting line
1975: C5       [68]             push    BC              ; store it for later use
1976: E1       [10]     LISTLP: pop     HL              ; Restore address of line
1977: 4E       [17]             ld      C,(HL)          ; Get LSB of next line
1978: 23       [23]             inc     HL
1979: 46       [30]             ld      B,(HL)          ; Get MSB of next line
197A: 23       [36]             inc     HL
197B: 78       [40]             ld      A,B             ; BC = 0 (End of program)?
197C: B1       [44]             or      C
197D: CA0C16   [54|54]          jp      Z,PRNTOK        ; Yes - Go to command mode
1980: CDE21A   [71]             call    TSTBRK          ; Test for break key
1983: CDE519   [88]             call    TSTSPC          ; test for space
1986: C5       [99]             push    BC              ; Save address of next line
1987: 3AD181   [112]            ld      A,(SCR_CURS_X)  ; load current X pos of cursor
198A: A7       [116]            and     A               ; is it at the beginning of a new line?
198B: 200B     [123|128]        jr      NZ,LST08        ; No, jump over
198D: 3E0D     [130]            ld      A,CR            ; yes, so just send a CR
198F: CDEE3D   [147]            call    MONOUT          ; to serial if it's open
1992: AF       [151]            xor     A               ; then, set cursor
1993: 329081   [164]            ld      (CURPOS),A      ; to position 0
1996: 1803     [176]            jr      LST07           ; and continue
1998: CD7E1D   [17]     LST08:  call    PRNTCRLF        ; output CRLF
199B: 5E       [ 7]     LST07:  ld      E,(HL)          ; Get LSB of line number
199C: 23       [13]             inc     HL
199D: 56       [20]             ld      D,(HL)          ; Get MSB of line number
199E: 23       [26]             inc     HL
199F: E5       [37]             push    HL              ; Save address of line start
19A0: EB       [41]             ex      DE,HL           ; Line number to HL
19A1: CDE22E   [58]             call    PRNTHL          ; Output line number in decimal
19A4: 3E20     [65]             ld      A,SPC           ; Space after line number
19A6: E1       [75]             pop     HL              ; Restore start of line address
19A7: CD9F18   [17]     LSTLP2: call    OUTC            ; Output character in A
19AA: 7E       [ 7]     LSTLP3: ld      A,(HL)          ; Get next byte in line
19AB: B7       [11]             or      A               ; End of line?
19AC: 23       [17]             inc     HL              ; To next byte in line
19AD: CAD119   [27|27]          jp      Z,NXTLN         ; Yes - check next line
19B0: F2A719   [37|37]          jp      P,LSTLP2        ; No token - output it
19B3: D67F     [44]             sub     ZEND-1          ; Find and output word
19B5: 4F       [48]             ld      C,A             ; Token offset+1 to C
19B6: 116A10   [58]             ld      DE,WORDS        ; Reserved word list
19B9: 1A       [ 7]     FNDTOK: ld      A,(DE)          ; Get character in list
19BA: 13       [13]             inc     DE              ; Move on to next
19BB: B7       [17]             or      A               ; Is it start of word?
19BC: F2B919   [27|27]          jp      P,FNDTOK        ; No - Keep looking for word
19BF: 0D       [31]             dec     C               ; Count words
19C0: C2B919   [41|41]          jp      NZ,FNDTOK       ; Not there - keep looking
19C3: E67F     [ 7]     OUTWRD: and     %01111111       ; Strip bit 7
19C5: CD9F18   [24]             call    OUTC            ; Output character
19C8: 1A       [31]             ld      A,(DE)          ; Get next character
19C9: 13       [37]             inc     DE              ; Move on to next
19CA: B7       [41]             or      A               ; Is it end of word?
19CB: F2C319   [51|51]          jp      P,OUTWRD        ; No - output the rest
19CE: C3AA19   [61]             jp      LSTLP3          ; Next byte in line
19D1: D1       [10]     NXTLN:  pop     DE              ; recover address of current line
19D2: 2ADE81   [26]             ld      HL,(TMPBFR2)    ; address of last line to print
19D5: CD153E   [43]             call    CMP16           ; check if current line is over last printable line
19D8: DA0C16   [53|53]          jp      C,PRNTOK        ; finish - leave & print OK
19DB: D5       [64]             push    DE              ; store address of current line
19DC: C37619   [74]             jp      LISTLP          ; continue listing
19DF: E5       [11]     SRCHLIN:push    HL              ; store HL (this is needed because HL store the pointer to the input buffer)
19E0: CDB816   [28]             call    SRCHLN          ; search for line number in DE
19E3: E1       [38]             pop     HL              ; retrieve HL
19E4: C9       [48]             ret                     ; return to caller
                        
                        ; during LISTing, check if PAUSE is pressed, then pause listing and
                        ; wait for another pressing of PAUSE to continue or CTRL-C/BREAK to exit
19E5: 3A1882   [13]     TSTSPC: ld      A,(TMPKEYBFR)   ; Get input character
19E8: FE20     [20]             cp      SPC             ; Is it SPACE?
19EA: C0       [25|31]          ret     NZ              ; No, return
19EB: CDFE31   [17]     WTSPC   call    GETINP          ; Yes, stop listing and wait for another space or BREAK
19EE: FE20     [24]             cp      SPC             ; is it SPACE?
19F0: 2005     [31|36]          jr      NZ,CNTWTSP      ; no, continue
19F2: AF       [35]             xor     A
19F3: 321882   [48]             ld      (TMPKEYBFR),A   ; reset key
19F6: C9       [58]             ret                     ; return to caller
19F7: FE03     [ 7]     CNTWTSP:cp      CTRLC           ; is it CTRL-C/BREAK?
19F9: 20F0     [14|19]          jr      NZ,WTSPC        ; no, loop
19FB: C3BA0F   [24]             jp      BRKRET          ; exit and output "Ok"
                        
                        
19FE: 3E64     [ 7]     FOR:    ld      A,$64           ; Flag "FOR" assignment
1A00: 32B081   [20]             ld      (FORFLG),A      ; Save "FOR" flag
1A03: CD711C   [37]             call    LET             ; Set up initial index
1A06: C1       [47]             pop     BC              ; Drop RETurn address
1A07: E5       [58]             push    HL              ; Save code string address
1A08: CD5A1C   [75]             call    DATA            ; Get next statement address
1A0B: 22AC81   [91]             ld      (LOOPST),HL     ; Save it for start of loop
1A0E: 210200   [101]            ld      HL,$0002        ; Offset for "FOR" block
1A11: 39       [112]            add     HL,SP           ; Point to it
1A12: CD3F15   [17]     FORSLP: call    LOKFOR          ; Look for existing "FOR" block
1A15: D1       [27]             pop     DE              ; Get code string address
1A16: C22E1A   [37|37]          jp      NZ,FORFND       ; No nesting found
1A19: 09       [48]             add     HL,BC           ; Move into "FOR" block
1A1A: D5       [59]             push    DE              ; Save code string address
1A1B: 2B       [65]             dec     HL
1A1C: 56       [72]             ld      D,(HL)          ; Get MSB of loop statement
1A1D: 2B       [78]             dec     HL
1A1E: 5E       [85]             ld      E,(HL)          ; Get LSB of loop statement
1A1F: 23       [91]             inc     HL
1A20: 23       [97]             inc     HL
1A21: E5       [108]            push    HL              ; Save block address
1A22: 2AAC81   [124]            ld      HL,(LOOPST)     ; Get address of loop statement
1A25: CD8E18   [141]            call    CPDEHL          ; Compare the FOR loops
1A28: E1       [151]            pop     HL              ; Restore block address
1A29: C2121A   [161|161]        jp      NZ,FORSLP       ; Different FORs - Find another
1A2C: D1       [171]            pop     DE              ; Restore code string address
1A2D: F9       [177]            ld      SP,HL           ; Remove all nested loops
                        
1A2E: EB       [ 4]     FORFND: ex      DE,HL           ; Code string address to HL
1A2F: 0E08     [11]             ld      C,$08
1A31: CD6F15   [28]             call    CHKSTK          ; Check for 8 levels of stack
1A34: E5       [39]             push    HL              ; Save code string address
1A35: 2AAC81   [55]             ld      HL,(LOOPST)     ; Get first statement of loop
1A38: E3       [74]             ex      (SP),HL         ; Save and restore code string
1A39: E5       [85]             push    HL              ; Re-save code string address
1A3A: 2AAF80   [101]            ld      HL,(LINEAT)     ; Get current line number
1A3D: E3       [120]            ex      (SP),HL         ; Save and restore code string
1A3E: CD3D1F   [137]            call    TSTNUM          ; Make sure it's a number
1A41: CD9418   [154]            call    CHKSYN          ; Make sure "TO" is next
1A44: B7                        defb    ZTO             ; "TO" token
1A45: CD3A1F   [171]            call    GETNUM          ; Get "TO" expression value
1A48: E5       [182]            push    HL              ; Save code string address
1A49: CD942D   [199]            call    BCDEFP          ; Move "TO" value to BCDE
1A4C: E1       [209]            pop     HL              ; Restore code string address
1A4D: C5       [220]            push    BC              ; Save "TO" value in block
1A4E: D5       [231]            push    DE
1A4F: 010081   [241]            ld      BC,$8100        ; BCDE - 1 (default STEP)
1A52: 51       [245]            ld      D,C             ; C=0
1A53: 5A       [249]            ld      E,D             ; D=0
1A54: 7E       [256]            ld      A,(HL)          ; Get next byte in code string
1A55: FEBC     [263]            cp      ZSTEP           ; See if "STEP" is stated
1A57: 3E01     [270]            ld      A,$01           ; Sign of step = 1
1A59: C26A1A   [280|280]        jp      NZ,SAVSTP       ; No STEP given - Default to 1
1A5C: CDB71A   [297]            call    GETCHR          ; Jump over "STEP" token
1A5F: CD3A1F   [314]            call    GETNUM          ; Get step value
1A62: E5       [325]            push    HL              ; Save code string address
1A63: CD942D   [342]            call    BCDEFP          ; Move STEP to BCDE
1A66: CD482D   [359]            call    TSTSGN          ; Test sign of FPREG
1A69: E1       [369]            pop     HL              ; Restore code string address
1A6A: C5       [11]     SAVSTP: push    BC              ; Save the STEP value in block
1A6B: D5       [22]             push    DE
1A6C: F5       [33]             push    AF              ; Save sign of STEP
1A6D: 33       [39]             inc     SP              ; Don't save flags
1A6E: E5       [50]             push    HL              ; Save code string address
1A6F: 2AB381   [66]             ld      HL,(BRKLIN)     ; Get address of index variable
1A72: E3       [85]             ex      (SP),HL         ; Save and restore code string
1A73: 0681     [ 7]     PUTFID: ld      B,ZFOR          ; "FOR" block marker
1A75: C5       [18]             push    BC              ; Save it
1A76: 33       [24]             inc     SP              ; Don't save C
                        
1A77: CDE21A   [17]     RUNCNT: call    TSTBRK          ; Execution driver - Test break
1A7A: 22B381   [33]             ld      (BRKLIN),HL     ; Save code address for break
1A7D: 7E       [40]             ld      A,(HL)          ; Get next byte in code string
1A7E: FE3A     [47]             cp      ':'             ; Multi statement line?
1A80: CA971A   [57|57]          jp      Z,EXCUTE        ; Yes - Execute it
1A83: B7       [61]             or      A               ; End of line?
1A84: C2B215   [71|71]          jp      NZ,SNERR        ; No - Syntax error
1A87: 23       [77]             inc     HL              ; Point to address of next line
1A88: 7E       [84]             ld      A,(HL)          ; Get LSB of line pointer
1A89: 23       [90]             inc     HL
1A8A: B6       [97]             or      (HL)            ; Is it zero (End of prog)?
1A8B: CA091B   [107|107]        jp      Z,ENDPRG        ; Yes - Terminate execution
1A8E: 23       [113]            inc     HL              ; Point to line number
1A8F: 5E       [120]            ld      E,(HL)          ; Get LSB of line number
1A90: 23       [126]            inc     HL
1A91: 56       [133]            ld      D,(HL)          ; Get MSB of line number
1A92: EB       [137]            ex      DE,HL           ; Line number to HL
1A93: 22AF80   [153]            ld      (LINEAT),HL     ; Save as current line number
1A96: EB       [157]            ex      DE,HL           ; Line number back to DE
1A97: CDB71A   [17]     EXCUTE: call    GETCHR          ; Get key word
1A9A: 11771A   [27]             ld      DE,RUNCNT       ; Where to RETurn to
1A9D: D5       [38]             push    DE              ; Save for RETurn
1A9E: C8       [ 5|11]  IFJMP:  ret     Z               ; Go to RUNCNT if end of STMT
                        
1A9F: D680     [ 7]     ONJMP:  sub     ZEND            ; Is it a token?
1AA1: DA711C   [17|17]          jp      C,LET           ; No - try to assign it
1AA4: FE36     [24]             cp      ZNEW+1-ZEND     ; END to NEW ?
1AA6: D2B215   [34|34]          jp      NC,SNERR        ; Not a key word - ?SN Error
1AA9: 07       [38]             rlca                    ; Double it
1AAA: 4F       [42]             ld      C,A             ; BC = Offset into table
1AAB: 0600     [49]             ld      B,0
1AAD: EB       [53]             ex      DE,HL           ; Save code string address
1AAE: 21F711   [63]             ld      HL,WORDTB       ; Keyword address table
1AB1: 09       [74]             add     HL,BC           ; Point to routine address
1AB2: 4E       [81]             ld      C,(HL)          ; Get LSB of routine address
1AB3: 23       [87]             inc     HL
1AB4: 46       [94]             ld      B,(HL)          ; Get MSB of routine address
1AB5: C5       [105]            push    BC              ; Save routine address
1AB6: EB       [109]            ex      DE,HL           ; Restore code string address
                        
                        ; get a char from input buffer: exit with NC if character found is
                        ; not a number; exit with Z if nothing found; char is into A
1AB7: 23       [ 6]     GETCHR: inc     HL              ; Point to next character
1AB8: 7E       [13]             ld      A,(HL)          ; Get next code string byte
1AB9: FE3A     [20]             cp      ':'             ; Z if ':'
1ABB: D0       [25|31]          ret     NC              ; NC if > "9"
1ABC: FE20     [32]             cp      SPC
1ABE: CAB71A   [42|42]          jp      Z,GETCHR        ; Skip over spaces
1AC1: FE30     [49]             cp      '0'
1AC3: 3F       [53]             ccf                     ; NC if < '0'
1AC4: 3C       [57]             inc     A               ; Test for zero - Leave carry
1AC5: 3D       [61]             dec     A               ; Z if Null
1AC6: C9       [71]             ret
                        
1AC7: EB       [ 4]     RESTOR: ex      DE,HL           ; Save code string address
1AC8: 2A3381   [20]             ld      HL,(BASTXT)     ; Point to start of program
1ACB: CADC1A   [30|30]          jp      Z,RESTNL        ; Just RESTORE - reset pointer
1ACE: EB       [34]             ex      DE,HL           ; Restore code string address
1ACF: CD871B   [51]             call    ATOH            ; Get line number to DE
1AD2: E5       [62]             push    HL              ; Save code string address
1AD3: CDB816   [79]             call    SRCHLN          ; Search for line number in DE
1AD6: 60       [83]             ld      H,B             ; HL = Address of line
1AD7: 69       [87]             ld      L,C
1AD8: D1       [97]             pop     DE              ; Restore code string address
1AD9: D2301C   [107|107]        jp      NC,ULERR        ; ?UL Error if not found
1ADC: 2B       [ 6]     RESTNL: dec     HL              ; Byte before DATA statement
1ADD: 222482   [16]     UPDATA: ld      (NXTDAT),HL     ; Update DATA pointer
1AE0: EB       [20]             ex      DE,HL           ; Restore code string address
1AE1: C9       [30]             ret
                        
                        
1AE2: DF       [11]     TSTBRK: rst     $18             ; Check input status
1AE3: C8       [16|22]          ret     Z               ; No key, go back
1AE4: D7       [27]             rst     $10             ; Get the key into A
1AE5: FE1B     [34]             cp      ESC             ; Escape key?
1AE7: 2811     [41|46]          jr      Z,BRK           ; Yes, break
1AE9: FE03     [48]             cp      CTRLC           ; <Ctrl-C>
1AEB: 280D     [55|60]          jr      Z,BRK           ; Yes, break
1AED: FE13     [62]             cp      CTRLS           ; Stop scrolling?
1AEF: C0       [67|73]          ret     NZ              ; Other key, ignore
                        
                        
1AF0: D7       [11]     STALL:  rst     $10             ; Wait for key
1AF1: FE11     [18]             cp      CTRLQ           ; Resume scrolling?
1AF3: C8       [23|29]          ret     Z               ; Release the chokehold
1AF4: FE03     [30]             cp      CTRLC           ; Second break?
1AF6: 2807     [37|42]          jr      Z,STOP          ; Break during hold exits prog
1AF8: 18F6     [49]             jr      STALL           ; Loop until <Ctrl-Q> or <brk>
                        
1AFA: 3EFF     [ 7]     BRK:    ld      A,$FF           ; Set BRKFLG
1AFC: 32A980   [20]             ld      (BRKFLG),A      ; Store it
                        
1AFF: C0       [ 5|11]  STOP:   ret     NZ              ; Exit if anything else
1B00: F6                        defb    $F6             ; Flag "STOP"
1B01: C0       [ 5|11]  PEND:   ret     NZ              ; Exit if anything else
1B02: 22B381   [21]             ld      (BRKLIN),HL     ; Save point of break
1B05: 21                        defb    $21             ; Skip "OR 11111111B"
1B06: F6FF     [ 7]     INPBRK: or      %11111111       ; Flag "Break" wanted
1B08: C1       [17]             pop     BC              ; Return not needed and more
1B09: 2AAF80   [16]     ENDPRG: ld      HL,(LINEAT)     ; Get current line number
1B0C: F5       [27]             push    AF              ; Save STOP / END status
1B0D: 7D       [31]             ld      A,L             ; Is it direct break?
1B0E: A4       [35]             and     H
1B0F: 3C       [39]             inc     A               ; Line is -1 if direct break
1B10: CA1C1B   [49|49]          jp      Z,NOLIN         ; Yes - No line number
1B13: 22B781   [65]             ld      (ERRLIN),HL     ; Save line of break
1B16: 2AB381   [81]             ld      HL,(BRKLIN)     ; Get point of break
1B19: 22B981   [97]             ld      (CONTAD),HL     ; Save point to CONTinue
1B1C: AF       [ 4]     NOLIN:  xor     A
1B1D: 32A580   [17]             ld      (CTLOFG),A      ; Enable output
1B20: CD6C1D   [34]             call    STTLIN          ; Start a new line
1B23: F1       [44]             pop     AF              ; Restore STOP / END status
1B24: 213515   [54]             ld      HL,BRKMSG       ; "Break" message
1B27: C22D1B   [64|64]          jp      NZ,ERRINT       ; "in line" wanted?
1B2A: C30C16   [74]             jp      PRNTOK          ; Go to command mode
1B2D: CD8C15   [17]     ERRINT: call    EXITGM          ; exit from graphics mode
1B30: C3EA15   [27]             jp      ERRIN           ; print message
                        
                        
1B33: 21FFFF   [10]     CONT:   ld      HL,-1           ; reset...
1B36: 22B180   [26]             ld      (HLPLN),HL      ; ...HELP line register
1B39: 2AB981   [42]             ld      HL,(CONTAD)     ; Get CONTinue address
1B3C: 7C       [46]             ld      A,H             ; Is it zero?
1B3D: B5       [50]             or      L
1B3E: 1E20     [57]             ld      E,CN            ; ?CN Error
1B40: CAC615   [67|67]          jp      Z,ERROR         ; Yes - output "?CN Error"
1B43: EB       [71]             ex      DE,HL           ; Save code string address
1B44: 2AB781   [87]             ld      HL,(ERRLIN)     ; Get line of last break
1B47: 22AF80   [103]            ld      (LINEAT),HL     ; Set up current line number
1B4A: EB       [107]            ex      DE,HL           ; Restore code string address
1B4B: C9       [117]            ret                     ; CONTinue where left off
                        
1B4C: E5       [11]     ACCSUM: push    HL              ; Save address in array
1B4D: 2AA680   [27]             ld      HL,(CHKSUM)     ; Get check sum
1B50: 0600     [34]             ld      B,$00           ; BC - Value of byte
1B52: 4F       [38]             ld      C,A
1B53: 09       [49]             add     HL,BC           ; Add byte to check sum
1B54: 22A680   [65]             ld      (CHKSUM),HL     ; Re-save check sum
1B57: E1       [75]             pop     HL              ; Restore address in array
1B58: C9       [85]             ret
                        
1B59: 7E       [ 7]     CHKLTR: ld      A,(HL)          ; Get byte
1B5A: FE41     [14]             cp      'A'             ; < 'a' ?
1B5C: D8       [19|25]          ret     C               ; Carry set if not letter
1B5D: FE5B     [26]             cp      'Z'+1           ; > 'z' ?
1B5F: 3F       [30]             ccf
1B60: C9       [40]             ret                     ; Carry set if not letter
                        
1B61: CDB71A   [17]     FPSINT: call    GETCHR          ; Get next character
1B64: CD3A1F   [17]     POSINT: call    GETNUM          ; Get integer 0 to 32767
1B67: CD482D   [17]     DEPINT: call    TSTSGN          ; Test sign of FPREG
1B6A: FA821B   [27|27]          jp      M,FCERR         ; Negative - ?FC Error
1B6D: 3A2F82   [13]     DEINT:  ld      A,(FPEXP)       ; Get integer value to DE
1B70: FE90     [20]             cp      $80+$10         ; Exponent in range (16 bits)?
1B72: DAF02D   [30|30]          jp      C,FPINT         ; Yes - convert it
1B75: 018090   [40]             ld      BC,$9080        ; BCDE = -32768
1B78: 110000   [50]             ld      DE,$0000
1B7B: E5       [61]             push    HL              ; Save code string address
1B7C: CDC32D   [78]             call    CMPNUM          ; Compare FPREG with BCDE
1B7F: E1       [88]             pop     HL              ; Restore code string address
1B80: 51       [92]             ld      D,C             ; MSB to D
1B81: C8       [97|103]         ret     Z               ; Return if in range
1B82: 1E08     [ 7]     FCERR:  ld      E,FC            ; ?FC Error
1B84: C3C615   [17]             jp      ERROR           ; Output error-
                        
1B87: 2B       [ 6]     ATOH:   dec     HL              ; ASCII number to DE binary
1B88: 110000   [10]     GETLN:  ld      DE,$0000        ; Get number to DE
1B8B: CDB71A   [17]     GTLNLP: call    GETCHR          ; Get next character
1B8E: D0       [22|28]          ret     NC              ; Exit if not a digit
1B8F: E5       [33]             push    HL              ; Save code string address
1B90: F5       [44]             push    AF              ; Save digit
1B91: 219819   [54]             ld      HL,65529/10     ; Largest number 65529
1B94: CD8E18   [71]             call    CPDEHL          ; Number in range?
1B97: DAB215   [81|81]          jp      C,SNERR         ; No - ?SN Error
1B9A: 62       [85]             ld      H,D             ; HL = Number
1B9B: 6B       [89]             ld      L,E
1B9C: 19       [100]            add     HL,DE           ; Times 2
1B9D: 29       [111]            add     HL,HL           ; Times 4
1B9E: 19       [122]            add     HL,DE           ; Times 5
1B9F: 29       [133]            add     HL,HL           ; Times 10
1BA0: F1       [143]            pop     AF              ; Restore digit
1BA1: D630     [150]            sub     '0'             ; Make it 0 to 9
1BA3: 5F       [154]            ld      E,A             ; DE = Value of digit
1BA4: 1600     [161]            ld      D,0
1BA6: 19       [172]            add     HL,DE           ; Add to number
1BA7: EB       [176]            ex      DE,HL           ; Number to DE
1BA8: E1       [186]            pop     HL              ; Restore code string address
1BA9: C38B1B   [196]            jp      GTLNLP          ; Go to next character
                        
1BAC: CAE816   [10|10]  CLEAR:  jp      Z,INTVAR        ; Just "CLEAR" Keep parameters
1BAF: CD641B   [27]             call    POSINT          ; Get integer 0 to 32767 to DE
1BB2: 2B       [33]             dec     HL              ; Cancel increment
1BB3: CDB71A   [50]             call    GETCHR          ; Get next character
1BB6: E5       [61]             push    HL              ; Save code string address
1BB7: 2A9481   [77]             ld      HL,(LSTRAM)     ; Get end of RAM
1BBA: CACF1B   [87|87]          jp      Z,STORED        ; No value given - Use stored
1BBD: E1       [97]             pop     HL              ; Restore code string address
1BBE: CD9418   [114]            call    CHKSYN          ; Check for comma
1BC1: 2C                        defb    ','
1BC2: D5       [125]            push    DE              ; Save number
1BC3: CD641B   [142]            call    POSINT          ; Get integer 0 to 32767
1BC6: 2B       [148]            dec     HL              ; Cancel increment
1BC7: CDB71A   [165]            call    GETCHR          ; Get next character
1BCA: C2B215   [175|175]        jp      NZ,SNERR        ; ?SN Error if more on line
1BCD: E3       [194]            ex      (SP),HL         ; Save code string address
1BCE: EB       [198]            ex      DE,HL           ; Number to DE
1BCF: 7D       [ 4]     STORED: ld      A,L             ; Get LSB of new RAM top
1BD0: 93       [ 8]             sub     E               ; Subtract LSB of string space
1BD1: 5F       [12]             ld      E,A             ; Save LSB
1BD2: 7C       [16]             ld      A,H             ; Get MSB of new RAM top
1BD3: 9A       [20]             sbc     A,D             ; Subtract MSB of string space
1BD4: 57       [24]             ld      D,A             ; Save MSB
1BD5: DA8715   [34|34]          jp      C,OMERR         ; ?OM Error if not enough mem
1BD8: E5       [45]             push    HL              ; Save RAM top
1BD9: 2A1E82   [61]             ld      HL,(PROGND)     ; Get program end
1BDC: 012800   [71]             ld      BC,$28          ; 40 Bytes minimum working RAM
1BDF: 09       [82]             add     HL,BC           ; Get lowest address
1BE0: CD8E18   [99]             call    CPDEHL          ; Enough memory?
1BE3: D28715   [109|109]        jp      NC,OMERR        ; No - ?OM Error
1BE6: EB       [113]            ex      DE,HL           ; RAM top to HL
1BE7: 22AD80   [129]            ld      (STRSPC),HL     ; Set new string space
1BEA: E1       [139]            pop     HL              ; End of memory to use
1BEB: 229481   [155]            ld      (LSTRAM),HL     ; Set new top of RAM
1BEE: E1       [165]            pop     HL              ; Restore code string address
1BEF: C3E816   [175]            jp      INTVAR          ; Initialise variables
                        
1BF2: E5       [11]     RUN:    push    HL              ; store HL
1BF3: 21FFFF   [21]             ld      HL,-1           ; reset...
1BF6: 22B180   [37]             ld      (HLPLN),HL      ; ...HELP line register
1BF9: E1       [47]             pop     HL              ; retrieve HL
1BFA: CAE416   [57|57]          jp      Z,RUNFST        ; RUN from start if just RUN
1BFD: CDE816   [74]             call    INTVAR          ; Initialise variables
1C00: 01771A   [84]             ld      BC,RUNCNT       ; Execution driver loop
1C03: C3161C   [94]             jp      RUNLIN          ; RUN from line number
                        
1C06: 0E03     [ 7]     GOSUB:  ld      C,$03           ; 3 Levels of stack needed
1C08: CD6F15   [24]             call    CHKSTK          ; Check for 3 levels of stack
1C0B: C1       [34]             pop     BC              ; Get return address
1C0C: E5       [45]             push    HL              ; Save code string for RETURN
1C0D: E5       [56]             push    HL              ; And for GOSUB routine
1C0E: 2AAF80   [72]             ld      HL,(LINEAT)     ; Get current line
1C11: E3       [91]             ex      (SP),HL         ; Into stack - Code string out
1C12: 3E8C     [98]             ld      A,ZGOSUB        ; "GOSUB" token
1C14: F5       [109]            push    AF              ; Save token
1C15: 33       [115]            inc     SP              ; Don't save flags
                        
1C16: C5       [11]     RUNLIN: push    BC              ; Save return address
1C17: CD871B   [17]     GOTO:   call    ATOH            ; ASCII number to DE binary
1C1A: CD5C1C   [34]             call    REM             ; Get end of line
1C1D: E5       [45]             push    HL              ; Save end of line
1C1E: 2AAF80   [61]             ld      HL,(LINEAT)     ; Get current line
1C21: CD8E18   [78]             call    CPDEHL          ; Line after current?
1C24: E1       [88]             pop     HL              ; Restore end of line
1C25: 23       [94]             inc     HL              ; Start of next line
1C26: DCBB16   [104|111]        call    C,SRCHLP        ; Line is after current line
1C29: D4B816   [114|121]        call    NC,SRCHLN       ; Line is before current line
1C2C: 60       [118]            ld      H,B             ; Set up code string address
1C2D: 69       [122]            ld      L,C
1C2E: 2B       [128]            dec     HL              ; Incremented after
1C2F: D8       [133|139]        ret     C               ; Line found
1C30: 1E0E     [ 7]     ULERR:  ld      E,UL            ; ?UL Error
1C32: C3C615   [17]             jp      ERROR           ; Output error message
                        
1C35: C0       [ 5|11]  RETURN: ret     NZ              ; Return if not just RETURN
1C36: 16FF     [12]             ld      D,-1            ; Flag "GOSUB" search
1C38: CD3B15   [29]             call    BAKSTK          ; Look "GOSUB" block
1C3B: F9       [35]             ld      SP,HL           ; Kill all FORs in subroutine
1C3C: FE8C     [42]             cp      ZGOSUB          ; Test for "GOSUB" token
1C3E: 1E04     [49]             ld      E,RG            ; ?RG Error
1C40: C2C615   [59|59]          jp      NZ,ERROR        ; Error if no "GOSUB" found
1C43: E1       [69]             pop     HL              ; Get RETURN line number
1C44: 22AF80   [85]             ld      (LINEAT),HL     ; Save as current
1C47: 23       [91]             inc     HL              ; Was it from direct statement?
1C48: 7C       [95]             ld      A,H
1C49: B5       [99]             or      L               ; Return to line
1C4A: C2541C   [109|109]        jp      NZ,RETLIN       ; No - Return to line
1C4D: 3AB181   [122]            ld      A,(LSTBIN)      ; Any INPUT in subroutine?
1C50: B7       [126]            or      A               ; If so buffer is corrupted
1C51: C20B16   [136|136]        jp      NZ,POPNOK       ; Yes - Go to command mode
1C54: 21771A   [10]     RETLIN: ld      HL,RUNCNT       ; Execution driver loop
1C57: E3       [29]             ex      (SP),HL         ; Into stack - Code string out
1C58: 3E                        defb    $3E             ; Skip "pop HL"
1C59: E1       [10]     NXTDTA: pop     HL              ; Restore code string address
                        
1C5A: 013A              DATA:   defb    $01,$3A         ; ':' End of statement (stands for LD BC,$0E3A - NOP)
1C5C: 0E00     [ 7]     REM:    ld      C,$00           ; 00  End of statement
1C5E: 0600     [14]             ld      B,$00
1C60: 79       [ 4]     NXTSTL: ld      A,C             ; Statement and byte
1C61: 48       [ 8]             ld      C,B
1C62: 47       [12]             ld      B,A             ; Statement end byte
1C63: 7E       [ 7]     NXTSTT: ld      A,(HL)          ; Get byte
1C64: B7       [11]             or      A               ; End of line?
1C65: C8       [16|22]          ret     Z               ; Yes - Exit
1C66: B8       [20]             cp      B               ; End of statement?
1C67: C8       [25|31]          ret     Z               ; Yes - Exit
1C68: 23       [31]             inc     HL              ; Next byte
1C69: FE22     [38]             cp      $22             ; '"'             ; Literal string?
1C6B: CA601C   [48|48]          jp      Z,NXTSTL        ; Yes - Look for another '"'
1C6E: C3631C   [58]             jp      NXTSTT          ; Keep looking
                        
1C71: CD4921   [17]     LET:    call    GETVAR          ; Get variable name
1C74: CD9418   [34]             call    CHKSYN          ; Make sure "=" follows
1C77: C8                        defb    ZEQUAL          ; "=" token
1C78: D5       [45]             push    DE              ; Save address of variable
1C79: 3A9281   [58]             ld      A,(TYPE)        ; Get data type
1C7C: F5       [69]             push    AF              ; Save type
1C7D: CD4C1F   [86]             call    EVAL            ; Evaluate expression
1C80: F1       [96]             pop     AF              ; Restore type
1C81: E3       [115]            ex      (SP),HL         ; Save code - Get var addr
1C82: 22B381   [131]            ld      (BRKLIN),HL     ; Save address of variable
1C85: 1F       [135]            rra                     ; Adjust type
1C86: CD3F1F   [152]            call    CHKTYP          ; Check types are the same
1C89: CAC41C   [162|162]        jp      Z,LETNUM        ; Numeric - Move value
1C8C: E5       [11]     LETSTR: push    HL              ; Save address of string var
1C8D: 2A2C82   [27]             ld      HL,(FPREG)      ; Pointer to string entry
1C90: E5       [38]             push    HL              ; Save it on stack
1C91: 23       [44]             inc     HL              ; Skip over length
1C92: 23       [50]             inc     HL
1C93: 5E       [57]             ld      E,(HL)          ; LSB of string address
1C94: 23       [63]             inc     HL
1C95: 56       [70]             ld      D,(HL)          ; MSB of string address
1C96: 2A3381   [86]             ld      HL,(BASTXT)     ; Point to start of program
1C99: CD8E18   [103]            call    CPDEHL          ; Is string before program?
1C9C: D2B31C   [113|113]        jp      NC,CRESTR       ; Yes - Create string entry
1C9F: 2AAD80   [129]            ld      HL,(STRSPC)     ; Point to string space
1CA2: CD8E18   [146]            call    CPDEHL          ; Is string literal in program?
1CA5: D1       [156]            pop     DE              ; Restore address of string
1CA6: D2BB1C   [166|166]        jp      NC,MVSTPT       ; Yes - Set up pointer
1CA9: 21A481   [176]            ld      HL,TMPSTR       ; Temporary string pool
1CAC: CD8E18   [193]            call    CPDEHL          ; Is string in temporary pool?
1CAF: D2BB1C   [203|203]        jp      NC,MVSTPT       ; No - Set up pointer
1CB2: 3E                        defb    $3E             ; Skip "pop DE"
1CB3: D1       [10]     CRESTR: pop     DE              ; Restore address of string
1CB4: CDA325   [27]             call    BAKTMP          ; Back to last tmp-str entry
1CB7: EB       [31]             ex      DE,HL           ; Address of string entry
1CB8: CDDC23   [48]             call    SAVSTR          ; Save string in string area
1CBB: CDA325   [17]     MVSTPT: call    BAKTMP          ; Back to last tmp-str entry
1CBE: E1       [27]             pop     HL              ; Get string pointer
1CBF: CDA32D   [44]             call    DETHL4          ; Move string pointer to var
1CC2: E1       [54]             pop     HL              ; Restore code string address
1CC3: C9       [64]             ret
                        
1CC4: E5       [11]     LETNUM: push    HL              ; Save address of variable
1CC5: CDA02D   [28]             call    FPTHL           ; Move value to variable
1CC8: D1       [38]             pop     DE              ; Restore address of variable
1CC9: E1       [48]             pop     HL              ; Restore code string address
1CCA: C9       [58]             ret
                        
1CCB: CDC027   [17]     ON:     call    GETINT          ; Get integer 0-255
1CCE: 7E       [24]             ld      A,(HL)          ; Get "GOTO" or "GOSUB" token
1CCF: 47       [28]             ld      B,A             ; Save in B
1CD0: FE8C     [35]             cp      ZGOSUB          ; "GOSUB" token?
1CD2: CADA1C   [45|45]          jp      Z,ONGO          ; Yes - Find line number
1CD5: CD9418   [62]             call    CHKSYN          ; Make sure it's "GOTO"
1CD8: 88                        defb    ZGOTO           ; "GOTO" token
1CD9: 2B       [68]             dec     HL              ; Cancel increment
1CDA: 4B       [ 4]     ONGO:   ld      C,E             ; Integer of branch value
1CDB: 0D       [ 4]     ONGOLP: dec     C               ; Count branches
1CDC: 78       [ 8]             ld      A,B             ; Get "GOTO" or "GOSUB" token
1CDD: CA9F1A   [18|18]          jp      Z,ONJMP         ; Go to that line if right one
1CE0: CD881B   [35]             call    GETLN           ; Get line number to DE
1CE3: FE2C     [42]             cp      ','             ; Another line number?
1CE5: C0       [47|53]          ret     NZ              ; No - Drop through
1CE6: C3DB1C   [57]             jp      ONGOLP          ; Yes - loop
                        
1CE9: CD4C1F   [17]     IF:     call    EVAL            ; Evaluate expression
1CEC: 7E       [24]             ld      A,(HL)          ; Get token
1CED: FE88     [31]             cp      ZGOTO           ; "GOTO" token?
1CEF: CAF71C   [41|41]          jp      Z,IFGO          ; Yes - Get line
1CF2: CD9418   [58]             call    CHKSYN          ; Make sure it's "THEN"
1CF5: BA                        defb    ZTHEN           ; "THEN" token
1CF6: 2B       [64]             dec     HL              ; Cancel increment
1CF7: CD3D1F   [17]     IFGO:   call    TSTNUM          ; Make sure it's numeric
1CFA: CD482D   [34]             call    TSTSGN          ; Test state of expression
1CFD: CA091D   [44|44]          jp      Z,IF1           ; False - Jump over
1D00: CDB71A   [17]     IF0:    call    GETCHR          ; Get next character
1D03: DA171C   [27|27]          jp      C,GOTO          ; Number - GOTO that line
1D06: C39E1A   [37]             jp      IFJMP           ; Otherwise do statement
1D09: 0EAE     [ 7]     IF1:    ld      C,ZELSE
1D0B: CD5E1C   [24]             call    REM+2           ; check statement
1D0E: B7       [28]             or      A               ; end of line?
1D0F: C8       [33|39]          ret     Z               ; yes, leave
1D10: FEAE     [40]             cp      ZELSE
1D12: 20F5     [47|52]          jr      NZ,IF1          ; ELSE not found, continue check
1D14: C3001D   [57]             jp      IF0             ; return to IF
                        
                        
1D17: 2B       [ 6]     MRPRNT: dec     HL              ; dec 'cos GETCHR INCs
1D18: CDB71A   [23]             call    GETCHR          ; Get next character
1D1B: CA7E1D   [10|10]  PRINT:  jp      Z,PRNTCRLF      ; CRLF if just PRINT
1D1E: C8       [ 5|11]  PRNTLP: ret     Z               ; End of list - Exit
1D1F: FEB6     [12]             cp      ZTAB            ; "TAB(" token?
1D21: CAA61D   [22|22]          jp      Z,DOTAB         ; Yes - Do TAB routine
1D24: FEB9     [29]             cp      ZSPC            ; "SPC(" token?
1D26: CAA61D   [39|39]          jp      Z,DOTAB         ; Yes - Do SPC routine
1D29: E5       [50]             push    HL              ; Save code string address
1D2A: FE2C     [57]             cp      ','             ; Comma?
1D2C: CA8D1D   [67|67]          jp      Z,DOCOM         ; Yes - Move to next zone
1D2F: FE3B     [74]             cp      ';'             ; Semi-colon?
1D31: CACA1D   [84|84]          jp      Z,NEXITM        ; Do semi-colon routine
1D34: C1       [94]             pop     BC              ; Code string address to BC
1D35: CD4C1F   [111]            call    EVAL            ; Evaluate expression
1D38: E5       [122]            push    HL              ; Save code string address
1D39: 3A9281   [135]            ld      A,(TYPE)        ; Get variable type
1D3C: B7       [139]            or      A               ; Is it a string variable?
1D3D: C2651D   [149|149]        jp      NZ,PRNTST       ; Yes - Output string contents
1D40: CDED2E   [166]            call    NUMASC          ; Convert number to text
1D43: CD0024   [183]            call    CRTST           ; Create temporary string
1D46: 3600     [193]            ld      (HL),NLLCR      ; Followed by a NULL char (was SPC, space)
1D48: 2A2C82   [209]            ld      HL,(FPREG)      ; Get length of output
1D4B: 34       [220]            inc     (HL)            ; Plus 1 for the space
1D4C: 2A2C82   [236]            ld      HL,(FPREG)      ; < Not needed >
1D4F: 3AA280   [249]            ld      A,(LWIDTH)      ; Get width of line
1D52: 47       [253]            ld      B,A             ; To B
1D53: 04       [257]            inc     B               ; Width 255 (No limit)?
1D54: CA611D   [267|267]        jp      Z,PRNTNB        ; Yes - Output number string
1D57: 04       [271]            inc     B               ; Adjust it
1D58: 3A9081   [284]            ld      A,(CURPOS)      ; Get cursor position
1D5B: 86       [291]            add     A,(HL)          ; Add length of string
1D5C: 3D       [295]            dec     A               ; Adjust it
1D5D: B8       [299]            cp      B               ; Will output fit on this line?
1D5E: D47E1D   [309|316]        call    NC,PRNTCRLF     ; No - CRLF first
1D61: CD4524   [17]     PRNTNB: call    PRS1            ; Output string at (HL)
1D64: AF       [21]             xor     A               ; Skip call by setting 'z' flag
1D65: C44524   [10|17]  PRNTST: call    NZ,PRS1         ; Output string at (HL)
1D68: E1       [20]             pop     HL              ; Restore code string address
1D69: C3171D   [30]             jp      MRPRNT          ; See if more to PRINT
                        
1D6C: 3A9081   [13]     STTLIN: ld      A,(CURPOS)      ; Make sure on new line
1D6F: B7       [17]             or      A               ; Already at start?
1D70: C8       [22|28]          ret     Z               ; Yes - Do nothing
1D71: C37E1D   [32]             jp      PRNTCRLF        ; Start a new line
                        
1D74: AF       [ 4]     ENDINP: xor     A
1D75: 321682   [17]             ld      (KBDNPT),A      ; char is not from keyboard
1D78: 77       [24]             ld      (HL),A          ; Mark end of buffer
1D79: 213581   [34]             ld      HL,BUFFER-1     ; Point to buffer
1D7C: 180A     [46]             jr      CNTEND
1D7E: 3E0D     [ 7]     PRNTCRLF:ld     A,CR            ; Load a CR
1D80: CD9F18   [24]             call    OUTC            ; Output character
1D83: 3E0A     [31]             ld      A,LF            ; Load a LF
1D85: CD9F18   [48]             call    OUTC            ; Output character
1D88: AF       [ 4]     CNTEND: xor     A               ; Set to position 0
1D89: 329081   [17]             ld      (CURPOS),A      ; Store it
1D8C: C9       [27]             ret                     ; return to caller
                        
1D8D: 3AA380   [13]     DOCOM:  ld      A,(COMMAN)      ; Get comma width
1D90: 47       [17]             ld      B,A             ; Save in B
1D91: 3AD181   [30]             ld      A,(SCR_CURS_X)  ; Get current position
1D94: B8       [34]             cp      B               ; Within the limit?
1D95: D47E1D   [44|51]          call    NC,PRNTCRLF     ; No - output CRLF
1D98: D2CA1D   [54|54]          jp      NC,NEXITM       ; Get next item
1D9B: D60A     [ 7]     ZONELP: sub     $0A             ; Next zone of 10 characters
1D9D: D29B1D   [17|17]          jp      NC,ZONELP       ; Repeat if more zones
1DA0: 2F       [21]             cpl                     ; Number of null chars to output
1DA1: 0E00     [28]             ld      C,NLLCR         ; null char
1DA3: C3C01D   [38]             jp      ASPCS           ; Output them
                        
1DA6: F5       [11]     DOTAB:  push    AF              ; Save token
1DA7: CDBD27   [28]             call    FNDNUM          ; Evaluate expression
1DAA: CD9418   [45]             call    CHKSYN          ; Make sure ")" follows
1DAD: 29                        defb    ')'
1DAE: 2B       [51]             dec     HL              ; Back space on to ")"
1DAF: F1       [61]             pop     AF              ; Restore token
1DB0: 0E00     [68]             ld      C,NLLCR         ; for SPC we use NULL char (was SPACE)
1DB2: D6B9     [75]             sub     ZSPC            ; Was it "SPC(" ?
1DB4: E5       [86]             push    HL              ; Save code string address
1DB5: CABB1D   [96|96]          jp      Z,DOSPC         ; Yes - Do 'E' spaces
1DB8: 3AD181   [109]            ld      A,(SCR_CURS_X)  ; Get current X position
1DBB: 2F       [ 4]     DOSPC:  cpl                     ; Number of spaces to print to
1DBC: 83       [ 8]             add     A,E             ; Total number to print
1DBD: D2CA1D   [18|18]          jp      NC,NEXITM       ; TAB < Current POS(X)
1DC0: 3C       [ 4]     ASPCS:  inc     A               ; Output A spaces
1DC1: 47       [ 8]             ld      B,A             ; Save number to print
1DC2: 79       [ 4]     SPCLP:  ld      A,C             ; char to print
1DC3: CD9F18   [21]             call    OUTC            ; Output character in A
1DC6: 05       [25]             dec     B               ; Count them
1DC7: C2C21D   [35|35]          jp      NZ,SPCLP        ; Repeat if more
1DCA: E1       [10]     NEXITM: pop     HL              ; Restore code string address
1DCB: CDB71A   [27]             call    GETCHR          ; Get next character
1DCE: C31E1D   [37]             jp      PRNTLP          ; More to print
                        
1DD1: 3F526564          REDO:   defb    "?Redo from start",CR,0
1DD5: 6F206672          
1DD9: 6F6D2073          
1DDD: 74617274          
1DE1: 0D00              
                        
1DE3: 3AB281   [13]     BADINP: ld      A,(READFG)      ; READ or INPUT?
1DE6: B7       [17]             or      A
1DE7: C2AC15   [27|27]          jp      NZ,DATSNR       ; READ - ?SN Error
1DEA: C1       [37]             pop     BC              ; Throw away code string addr
1DEB: 21D11D   [47]             ld      HL,REDO         ; "Redo from start" message
1DEE: CD4224   [64]             call    PRS             ; Output string
1DF1: C31717   [74]             jp      DOAGN           ; Do last INPUT again
                        
1DF4: CDAD23   [17]     INPUT:  call    IDTEST          ; Test for illegal direct
1DF7: 7E       [24]             ld      A,(HL)          ; Get character after "INPUT"
1DF8: FE22     [31]             cp      $22             ; '"' ; Is there a prompt string?
1DFA: 3E00     [38]             ld      A,$00           ; Clear A and leave flags
1DFC: 32A580   [51]             ld      (CTLOFG),A      ; Enable output
1DFF: C20E1E   [61|61]          jp      NZ,NOPMPT       ; No prompt - get input
1E02: CD0124   [78]             call    QTSTR           ; Get string terminated by '"'
1E05: CD9418   [95]             call    CHKSYN          ; Check for ';' after prompt
1E08: 3B                        defb    ";"
1E09: E5       [106]            push    HL              ; Save code string address
1E0A: CD4524   [123]            call    PRS1            ; Output prompt string
1E0D: 3E                        defb    $3E             ; Skip "push HL"
1E0E: E5       [11]     NOPMPT: push    HL              ; Save code string address
1E0F: CD1B17   [28]             call    PROMPT          ; Get input with "? " prompt
1E12: C1       [38]             pop     BC              ; Restore code string address
1E13: DA061B   [48|48]          jp      C,INPBRK        ; Break pressed - Exit
1E16: 23       [54]             inc     HL              ; Next byte
1E17: 7E       [61]             ld      A,(HL)          ; Get it
1E18: B7       [65]             or      A               ; End of line?
1E19: 2B       [71]             dec     HL              ; Back again
1E1A: C5       [82]             push    BC              ; Re-save code string address
1E1B: CD8B08   [99]             call    CURSOR_OFF      ; disable cursor
1E1E: CA591C   [109|109]        jp      Z,NXTDTA        ; Yes - Find next DATA stmt
1E21: 362C     [119]            ld      (HL),','        ; Store comma as separator
1E23: C32B1E   [129]            jp      NXTITM          ; Get next item
                        
1E26: E5       [11]     READ:   push    HL              ; Save code string address
1E27: 2A2482   [27]             ld      HL,(NXTDAT)     ; Next DATA statement
1E2A: F6                        defb    $F6             ; Flag "READ"
1E2B: AF       [ 4]     NXTITM: xor     A               ; Flag "INPUT"
1E2C: 32B281   [17]             ld      (READFG),A      ; Save "READ"/"INPUT" flag
1E2F: E3       [36]             ex      (SP),HL         ; Get code str' , Save pointer
1E30: C3371E   [46]             jp      GTVLUS          ; Get values
                        
1E33: CD9418   [17]     NEDMOR: call    CHKSYN          ; Check for comma between items
1E36: 2C                        defb    ','
1E37: CD4921   [17]     GTVLUS: call    GETVAR          ; Get variable name
1E3A: E3       [36]             ex      (SP),HL         ; Save code str" , Get pointer
1E3B: D5       [47]             push    DE              ; Save variable address
1E3C: 7E       [54]             ld      A,(HL)          ; Get next "INPUT"/"DATA" byte
1E3D: FE2C     [61]             cp      ','             ; Comma?
1E3F: CA5F1E   [71|71]          jp      Z,ANTVLU        ; Yes - Get another value
1E42: 3AB281   [84]             ld      A,(READFG)      ; Is it READ?
1E45: B7       [88]             or      A
1E46: C2CB1E   [98|98]          jp      NZ,FDTLP        ; Yes - Find next DATA stmt
1E49: 3E3F     [105]            ld      A,'?'           ; More INPUT needed
1E4B: CD9F18   [122]            call    OUTC            ; Output character
1E4E: CD1B17   [139]            call    PROMPT          ; Get INPUT with prompt
1E51: D1       [149]            pop     DE              ; Variable address
1E52: C1       [159]            pop     BC              ; Code string address
1E53: DA061B   [169|169]        jp      C,INPBRK        ; Break pressed
1E56: 23       [175]            inc     HL              ; Point to next DATA byte
1E57: 7E       [182]            ld      A,(HL)          ; Get byte
1E58: B7       [186]            or      A               ; Is it zero (No input) ?
1E59: 2B       [192]            dec     HL              ; Back space INPUT pointer
1E5A: C5       [203]            push    BC              ; Save code string address
1E5B: CA591C   [213|213]        jp      Z,NXTDTA        ; Find end of buffer
1E5E: D5       [224]            push    DE              ; Save variable address
1E5F: 3A9281   [13]     ANTVLU: ld      A,(TYPE)        ; Check data type
1E62: B7       [17]             or      A               ; Is it numeric?
1E63: CA891E   [27|27]          jp      Z,INPBIN        ; Yes - Convert to binary
1E66: CDB71A   [44]             call    GETCHR          ; Get next character
1E69: 57       [48]             ld      D,A             ; Save input character
1E6A: 47       [52]             ld      B,A             ; Again
1E6B: FE22     [59]             cp      $22             ; '"'     ; Start of literal sting?
1E6D: CA7D1E   [69|69]          jp      Z,STRENT        ; Yes - Create string entry
1E70: 3AB281   [82]             ld      A,(READFG)      ; "READ" or "INPUT" ?
1E73: B7       [86]             or      A
1E74: 57       [90]             ld      D,A             ; Save 00 if "INPUT"
1E75: CA7A1E   [100|100]        jp      Z,ITMSEP        ; "INPUT" - End with 00
1E78: 163A     [107]            ld      D,':'           ; "DATA" - End with 00 or ':'
1E7A: 062C     [ 7]     ITMSEP: ld      B,','           ; Item separator
1E7C: 2B       [13]             dec     HL              ; Back space for DTSTR
1E7D: CD0424   [17]     STRENT: call    DTSTR           ; Get string terminated by D
1E80: EB       [21]             ex      DE,HL           ; String address to DE
1E81: 21941E   [31]             ld      HL,LTSTND       ; Where to go after LETSTR
1E84: E3       [50]             ex      (SP),HL         ; Save HL , get input pointer
1E85: D5       [61]             push    DE              ; Save address of string
1E86: C38C1C   [71]             jp      LETSTR          ; Assign string to variable
                        
1E89: CDB71A   [17]     INPBIN: call    GETCHR          ; Get next character
1E8C: CD4F2E   [34]             call    ASCTFP          ; Convert ASCII to FP number
1E8F: E3       [53]             ex      (SP),HL         ; Save input ptr, Get var addr
1E90: CDA02D   [70]             call    FPTHL           ; Move FPREG to variable
1E93: E1       [80]             pop     HL              ; Restore input pointer
1E94: 2B       [ 6]     LTSTND: dec     HL              ; dec 'cos GETCHR INCs
1E95: CDB71A   [23]             call    GETCHR          ; Get next character
1E98: CAA01E   [33|33]          jp      Z,MORDT         ; End of line - More needed?
1E9B: FE2C     [40]             cp      ','             ; Another value?
1E9D: C2E31D   [50|50]          jp      NZ,BADINP       ; No - Bad input
1EA0: E3       [19]     MORDT:  ex      (SP),HL         ; Get code string address
1EA1: 2B       [25]             dec     HL              ; dec 'cos GETCHR INCs
1EA2: CDB71A   [42]             call    GETCHR          ; Get next character
1EA5: C2331E   [52|52]          jp      NZ,NEDMOR       ; More needed - Get it
1EA8: D1       [62]             pop     DE              ; Restore DATA pointer
1EA9: 3AB281   [75]             ld      A,(READFG)      ; "READ" or "INPUT" ?
1EAC: B7       [79]             or      A
1EAD: EB       [83]             ex      DE,HL           ; DATA pointer to HL
1EAE: C2DD1A   [93|93]          jp      NZ,UPDATA       ; Update DATA pointer if "READ"
1EB1: D5       [104]            push    DE              ; Save code string address
1EB2: B6       [111]            or      (HL)            ; More input given?
1EB3: 21BB1E   [121]            ld      HL,EXTIG        ; "?Extra ignored" message
1EB6: C44224   [131|138]        call    NZ,PRS          ; Output string if extra given
1EB9: E1       [141]            pop     HL              ; Restore code string address
1EBA: C9       [151]            ret
                        
1EBB: 3F457874          EXTIG:  defb    "?Extra ignored",CR,0
1EBF: 72612069          
1EC3: 676E6F72          
1EC7: 65640D00          
                        
1ECB: CD5A1C   [17]     FDTLP:  call    DATA            ; Get next statement
1ECE: B7       [21]             or      A               ; End of line?
1ECF: C2E41E   [31|31]          jp      NZ,FANDT        ; No - See if DATA statement
1ED2: 23       [37]             inc     HL
1ED3: 7E       [44]             ld      A,(HL)          ; End of program?
1ED4: 23       [50]             inc     HL
1ED5: B6       [57]             or      (HL)            ; 00 00 Ends program
1ED6: 1E06     [64]             ld      E,OD            ; ?OD Error
1ED8: CAC615   [74|74]          jp      Z,ERROR         ; Yes - Out of DATA
1EDB: 23       [80]             inc     HL
1EDC: 5E       [87]             ld      E,(HL)          ; LSB of line number
1EDD: 23       [93]             inc     HL
1EDE: 56       [100]            ld      D,(HL)          ; MSB of line number
1EDF: EB       [104]            ex      DE,HL
1EE0: 22AE81   [120]            ld      (DATLIN),HL     ; Set line of current DATA item
1EE3: EB       [124]            ex      DE,HL
1EE4: CDB71A   [17]     FANDT:  call    GETCHR          ; Get next character
1EE7: FE83     [24]             cp      ZDATA           ; "DATA" token
1EE9: C2CB1E   [34|34]          jp      NZ,FDTLP        ; No "DATA" - Keep looking
1EEC: C35F1E   [44]             jp      ANTVLU          ; Found - Convert input
                        
1EEF: 110000   [10]     NEXT:   ld      DE,$0000        ; In case no index given
1EF2: C44921   [10|17]  NEXT1:  call    NZ,GETVAR       ; Get index address
1EF5: 22B381   [26]             ld      (BRKLIN),HL     ; Save code string address
1EF8: CD3B15   [43]             call    BAKSTK          ; Look for "FOR" block
1EFB: C2B815   [53|53]          jp      NZ,NFERR        ; No "FOR" - ?NF Error
1EFE: F9       [59]             ld      SP,HL           ; Clear nested loops
1EFF: D5       [70]             push    DE              ; Save index address
1F00: 7E       [77]             ld      A,(HL)          ; Get sign of STEP
1F01: 23       [83]             inc     HL
1F02: F5       [94]             push    AF              ; Save sign of STEP
1F03: D5       [105]            push    DE              ; Save index address
1F04: CD862D   [122]            call    PHLTFP          ; Move index value to FPREG
1F07: E3       [141]            ex      (SP),HL         ; Save address of TO value
1F08: E5       [152]            push    HL              ; Save address of index
1F09: CDA22A   [169]            call    ADDPHL          ; Add STEP to index value
1F0C: E1       [179]            pop     HL              ; Restore address of index
1F0D: CDA02D   [196]            call    FPTHL           ; Move value to index variable
1F10: E1       [206]            pop     HL              ; Restore address of TO value
1F11: CD972D   [223]            call    LOADFP          ; Move TO value to BCDE
1F14: E5       [234]            push    HL              ; Save address of line of FOR
1F15: CDC32D   [251]            call    CMPNUM          ; Compare index with TO value
1F18: E1       [261]            pop     HL              ; Restore address of line num
1F19: C1       [271]            pop     BC              ; Address of sign of STEP
1F1A: 90       [275]            sub     B               ; Compare with expected sign
1F1B: CD972D   [292]            call    LOADFP          ; BC = Loop stmt,DE = Line num
1F1E: CA2A1F   [302|302]        jp      Z,KILFOR        ; Loop finished - Terminate it
1F21: EB       [306]            ex      DE,HL           ; Loop statement line number
1F22: 22AF80   [322]            ld      (LINEAT),HL     ; Set loop line number
1F25: 69       [326]            ld      L,C             ; Set code string to loop
1F26: 60       [330]            ld      H,B
1F27: C3731A   [340]            jp      PUTFID          ; Put back "FOR" and continue
                        
1F2A: F9       [ 6]     KILFOR: ld      SP,HL           ; Remove "FOR" block
1F2B: 2AB381   [22]             ld      HL,(BRKLIN)     ; Code string after "NEXT"
1F2E: 7E       [29]             ld      A,(HL)          ; Get next byte in code string
1F2F: FE2C     [36]             cp      ','             ; More NEXTs ?
1F31: C2771A   [46|46]          jp      NZ,RUNCNT       ; No - Do next statement
1F34: CDB71A   [63]             call    GETCHR          ; Position to index name
1F37: CDF21E   [80]             call    NEXT1           ; Re-enter NEXT routine
                        ; < will not RETurn to here , Exit to RUNCNT or Loop >
                        
1F3A: CD4C1F   [17]     GETNUM: call    EVAL            ; Get a numeric expression
1F3D: F6                TSTNUM: defb    $F6             ; Clear carry (numeric)
1F3E: 37       [ 4]     TSTSTR: scf                     ; Set carry (string)
1F3F: 3A9281   [13]     CHKTYP: ld      A,(TYPE)        ; Check types match
1F42: 8F       [17]             adc     A,A             ; Expected + actual
1F43: B7       [21]             or      A               ; Clear carry , set parity
1F44: E8       [26|32]          ret     PE              ; Even parity - Types match
1F45: C3C415   [36]             jp      TMERR           ; Different types - Error
                        
1F48: CD9418   [17]     OPNPAR: call    CHKSYN          ; Make sure "(" follows
1F4B: 28                        defb    '('
1F4C: 2B       [ 6]     EVAL:   dec     HL              ; Evaluate expression & save
1F4D: 1600     [13]             ld      D,$00           ; Precedence value
1F4F: D5       [11]     EVAL1:  push    DE              ; Save precedence
1F50: 0E01     [18]             ld      C,$01
1F52: CD6F15   [35]             call    CHKSTK          ; Check for 1 level of stack
1F55: CDC31F   [52]             call    OPRND           ; Get next expression value
1F58: 22B581   [16]     EVAL2:  ld      (NXTOPR),HL     ; Save address of next operator
1F5B: 2AB581   [16]     EVAL3:  ld      HL,(NXTOPR)     ; Restore address of next opr
1F5E: C1       [26]             pop     BC              ; Precedence value and operator
1F5F: 78       [30]             ld      A,B             ; Get precedence value
1F60: FE78     [37]             cp      $78             ; "AND", "OR", or "XOR" ?
1F62: D43D1F   [47|54]          call    NC,TSTNUM       ; No - Make sure it's a number
1F65: 7E       [54]             ld      A,(HL)          ; Get next operator / function
1F66: 1600     [61]             ld      D,$00           ; Clear Last relation
1F68: D6C7     [ 7]     RLTLP:  sub     ZGTR            ; ">" Token
1F6A: DA841F   [17|17]          jp      C,FOPRND        ; + - * / ^ AND OR XOR - Test it
1F6D: FE03     [24]             cp      ZLTH+1-ZGTR     ; < = >
1F6F: D2841F   [34|34]          jp      NC,FOPRND       ; Function - Call it
1F72: FE01     [41]             cp      ZEQUAL-ZGTR     ; "="
1F74: 17       [45]             rla                     ; <- Test for legal
1F75: AA       [49]             xor     D               ; <- combinations of < = >
1F76: BA       [53]             cp      D               ; <- by combining last token
1F77: 57       [57]             ld      D,A             ; <- with current one
1F78: DAB215   [67|67]          jp      C,SNERR         ; Error if "<<' '==" or ">>"
1F7B: 22AA81   [83]             ld      (CUROPR),HL     ; Save address of current token
1F7E: CDB71A   [100]            call    GETCHR          ; Get next character
1F81: C3681F   [110]            jp      RLTLP           ; Treat the two as one
                        
1F84: 7A       [ 4]     FOPRND: ld      A,D             ; < = > found ?
1F85: B7       [ 8]             or      A
1F86: C2C420   [18|18]          jp      NZ,TSTRED       ; Yes - Test for reduction
1F89: 7E       [25]             ld      A,(HL)          ; Get operator token
1F8A: 22AA81   [41]             ld      (CUROPR),HL     ; Save operator address
1F8D: D6BD     [48]             sub     ZPLUS           ; Operator or function?
1F8F: D8       [53|59]          ret     C               ; Neither - Exit
1F90: FE0A     [60]             cp      ZOR+1-ZPLUS     ; Is it + - * / ^ AND XOR OR ?
1F92: D0       [65|71]          ret     NC              ; No - Exit
1F93: 5F       [69]             ld      E,A             ; Coded operator
1F94: 3A9281   [82]             ld      A,(TYPE)        ; Get data type
1F97: 3D       [86]             dec     A               ; FF = numeric , 00 = string
1F98: B3       [90]             or      E               ; Combine with coded operator
1F99: 7B       [94]             ld      A,E             ; Get coded operator
1F9A: CA3825   [104|104]        jp      Z,CONCAT        ; String concatenation
1F9D: 07       [108]            rlca                    ; Times 2
1F9E: 83       [112]            add     A,E             ; Times 3
1F9F: 5F       [116]            ld      E,A             ; To DE (D is 0)
1FA0: 216312   [126]            ld      HL,PRITAB       ; Precedence table
1FA3: 19       [137]            add     HL,DE           ; To the operator concerned
1FA4: 78       [141]            ld      A,B             ; Last operator precedence
1FA5: 56       [148]            ld      D,(HL)          ; Get evaluation precedence
1FA6: BA       [152]            cp      D               ; Compare with eval precedence
1FA7: D0       [157|163]        ret     NC              ; Exit if higher precedence
1FA8: 23       [163]            inc     HL              ; Point to routine address
1FA9: CD3D1F   [180]            call    TSTNUM          ; Make sure it's a number
                        
1FAC: C5       [11]     STKTHS: push    BC              ; Save last precedence & token
1FAD: 015B1F   [21]             ld      BC,EVAL3        ; Where to go on prec' break
1FB0: C5       [32]             push    BC              ; Save on stack for return
1FB1: 43       [36]             ld      B,E             ; Save operator
1FB2: 4A       [40]             ld      C,D             ; Save precedence
1FB3: CD792D   [57]             call    STAKFP          ; Move value to stack
1FB6: 58       [61]             ld      E,B             ; Restore operator
1FB7: 51       [65]             ld      D,C             ; Restore precedence
1FB8: 4E       [72]             ld      C,(HL)          ; Get LSB of routine address
1FB9: 23       [78]             inc     HL
1FBA: 46       [85]             ld      B,(HL)          ; Get MSB of routine address
1FBB: 23       [91]             inc     HL
1FBC: C5       [102]            push    BC              ; Save routine address
1FBD: 2AAA81   [118]            ld      HL,(CUROPR)     ; Address of current operator
1FC0: C34F1F   [128]            jp      EVAL1           ; Loop until prec' break
                        
1FC3: AF       [ 4]     OPRND:  xor     A               ; Get operand routine
1FC4: 329281   [17]             ld      (TYPE),A        ; Set numeric expected
1FC7: CDB71A   [34]             call    GETCHR          ; Get next character
1FCA: 1E24     [41]             ld      E,MO            ; ?MO Error
1FCC: CAC615   [51|51]          jp      Z,ERROR         ; No operand - Error
1FCF: DA4F2E   [61|61]          jp      C,ASCTFP        ; Number - Get value
1FD2: CD591B   [78]             call    CHKLTR          ; See if a letter
1FD5: D22A20   [88|88]          jp      NC,CONVAR       ; Letter - Find variable
1FD8: FE26     [95]             cp      '&'             ; &H = HEX, &B = BINARY
1FDA: 2012     [102|107]        jr      NZ,NOTAMP
1FDC: CDB71A   [119]            call    GETCHR          ; Get next character
1FDF: FE48     [126]            cp      'H'             ; Hex number indicated? [function added]
1FE1: CA4E3D   [136|136]        jp      Z,HEXTFP        ; Convert Hex to FPREG
1FE4: FE42     [143]            cp      'B'             ; Binary number indicated? [function added]
1FE6: CABE3D   [153|153]        jp      Z,BINTFP        ; Convert Bin to FPREG
1FE9: 1E02     [160]            ld      E,SN            ; If neither then a ?SN Error
1FEB: CAC615   [170|170]        jp      Z,ERROR         ;
1FEE: FEBD     [ 7]     NOTAMP: cp      ZPLUS           ; '+' Token ?
1FF0: CAC31F   [17|17]          jp      Z,OPRND         ; Yes - Look for operand
1FF3: FE2E     [24]             cp      '.'             ; '.' ?
1FF5: CA4F2E   [34|34]          jp      Z,ASCTFP        ; Yes - Create FP number
1FF8: FEBE     [41]             cp      ZMINUS          ; '-' Token ?
1FFA: CA1920   [51|51]          jp      Z,MINUS         ; Yes - Do minus
1FFD: FE22     [58]             cp      $22             ; '"'             ; Literal string ?
1FFF: CA0124   [68|68]          jp      Z,QTSTR         ; Get string terminated by '"'
2002: FEBB     [75]             cp      ZNOT            ; "NOT" Token ?
2004: CA2421   [85|85]          jp      Z,EVNOT         ; Yes - Eval NOT expression
2007: FEB8     [92]             cp      ZFN             ; "FN" Token ?
2009: CA6523   [102|102]        jp      Z,DOFN          ; Yes - Do FN routine
200C: D6CA     [109]            sub     ZSGN            ; Is it a function?
200E: D23B20   [119|119]        jp      NC,FNOFST       ; Yes - Evaluate function
2011: CD481F   [17]     EVLPAR: call    OPNPAR          ; Evaluate expression in "()"
2014: CD9418   [34]             call    CHKSYN          ; Make sure ")" follows
2017: 29                        defb    ')'
2018: C9       [44]             ret
                        
2019: 167D     [ 7]     MINUS:  ld      D,$7D           ; '-' precedence
201B: CD4F1F   [24]             call    EVAL1           ; Evaluate until prec' break
201E: 2AB581   [40]             ld      HL,(NXTOPR)     ; Get next operator address
2021: E5       [51]             push    HL              ; Save next operator address
2022: CD712D   [68]             call    INVSGN          ; Negate value
2025: CD3D1F   [17]     RETNUM: call    TSTNUM          ; Make sure it's a number
2028: E1       [27]             pop     HL              ; Restore next operator address
2029: C9       [37]             ret
                        
202A: CD4921   [17]     CONVAR: call    GETVAR          ; Get variable address to DE
202D: E5       [11]     FRMEVL: push    HL              ; Save code string address
202E: EB       [15]             ex      DE,HL           ; Variable address to HL
202F: 222C82   [31]             ld      (FPREG),HL      ; Save address of variable
2032: 3A9281   [44]             ld      A,(TYPE)        ; Get type
2035: B7       [48]             or      A               ; Numeric?
2036: CC862D   [58|65]          call    Z,PHLTFP        ; Yes - Move contents to FPREG
2039: E1       [68]             pop     HL              ; Restore code string address
203A: C9       [78]             ret
                        
203B: 0600     [ 7]     FNOFST: ld      B,$00           ; Get address of function
203D: 07       [11]             rlca                    ; Double function offset
203E: 4F       [15]             ld      C,A             ; BC = Offset in function table
203F: C5       [26]             push    BC              ; Save adjusted token value
2040: CDB71A   [43]             call    GETCHR          ; Get next character
2043: 79       [47]             ld      A,C             ; Get adjusted token value
2044: FE2C     [54]             cp      2*(ZPOINT-ZSGN) ; "POINT" token?
2046: CA7535   [64|64]          jp      Z,POINT         ; Yes, do "POINT"
2049: FE2E     [71]             cp      2*(ZINSTR-ZSGN) ; "INSTR" token?
204B: CA1426   [81|81]          jp      Z,INSTR         ; Yes, do "INSTR"
204E: FE3D     [88]             cp      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
2050: DA6C20   [98|98]          jp      C,FNVAL         ; No - Do function
2053: CD481F   [115]            call    OPNPAR          ; Evaluate expression  (X,...
2056: CD9418   [132]            call    CHKSYN          ; Make sure ',' follows
2059: 2C                        defb    ','
205A: CD3E1F   [149]            call    TSTSTR          ; Make sure it's a string
205D: EB       [153]            ex      DE,HL           ; Save code string address
205E: 2A2C82   [169]            ld      HL,(FPREG)      ; Get address of string
2061: E3       [188]            ex      (SP),HL         ; Save address of string
2062: E5       [199]            push    HL              ; Save adjusted token value
2063: EB       [203]            ex      DE,HL           ; Restore code string address
2064: CDC027   [220]            call    GETINT          ; Get integer 0-255
2067: EB       [224]            ex      DE,HL           ; Save code string address
2068: E3       [243]            ex      (SP),HL         ; Save integer,HL = adj' token
2069: C37420   [253]            jp      GOFUNC          ; Jump to string function
                        
206C: CD1120   [17]     FNVAL:  call    EVLPAR          ; Evaluate expression
206F: E3       [36]             ex      (SP),HL         ; HL = Adjusted token value
2070: 112520   [46]             ld      DE,RETNUM       ; Return number from function
2073: D5       [57]             push    DE              ; Save on stack
2074: 012610   [10]     GOFUNC: ld      BC,FNCTAB       ; Function routine addresses
2077: 09       [21]             add     HL,BC           ; Point to right address
2078: 4E       [28]             ld      C,(HL)          ; Get LSB of address
2079: 23       [34]             inc     HL              ;
207A: 66       [41]             ld      H,(HL)          ; Get MSB of address
207B: 69       [45]             ld      L,C             ; Address to HL
207C: E9       [49]             jp      (HL)            ; Jump to function
                        
207D: 15       [ 4]     SGNEXP: dec     D               ; Dee to flag negative exponent
207E: FEBE     [11]             cp      ZMINUS          ; '-' token ?
2080: C8       [16|22]          ret     Z               ; Yes - Return
2081: FE2D     [23]             cp      '-'             ; '-' ASCII ?
2083: C8       [28|34]          ret     Z               ; Yes - Return
2084: 14       [32]             inc     D               ; Inc to flag positive exponent
2085: FE2B     [39]             cp      '+'             ; '+' ASCII ?
2087: C8       [44|50]          ret     Z               ; Yes - Return
2088: FEBD     [51]             cp      ZPLUS           ; '+' token ?
208A: C8       [56|62]          ret     Z               ; Yes - Return
208B: 2B       [62]             dec     HL              ; dec 'cos GETCHR INCs
208C: C9       [72]             ret                     ; Return "NZ"
                        
                        ; execute OR, AND, and XOR operations
208D: AF       [ 4]     PAND:   xor     A               ; for AND, Z=1
208E: 1807     [16]             jr      CNTLGC          
2090: AF       [ 4]     POR     xor     A               ; for OR, Z=0, S=1
2091: D601     [11]             sub     $01
2093: 1802     [23]             jr      CNTLGC
2095: AF       [ 4]     PXOR:   xor     A               ; for XOR, Z=0, S=0
2096: 3C       [ 8]             inc     A
2097: F5       [11]     CNTLGC: push    AF              ; store operand's flags
2098: CD3D1F   [28]             call    TSTNUM          ; Make sure it's a number
209B: CD6D1B   [45]             call    DEINT           ; Get integer -32768 to 32767
209E: F1       [55]             pop     AF              ; retrieve operand's flags
209F: EB       [59]             ex      DE,HL           ; <- Get last
20A0: C1       [69]             pop     BC              ; <-  value
20A1: E3       [88]             ex      (SP),HL         ; <-  from
20A2: EB       [92]             ex      DE,HL           ; <-  stack
20A3: CD892D   [109]            call    FPBCDE          ; Move last value to FPREG
20A6: F5       [120]            push    AF              ; store operand's flags
20A7: CD6D1B   [137]            call    DEINT           ; Get integer -32768 to 32767
20AA: F1       [147]            pop     AF              ; retrieve operand's flags
20AB: C1       [157]            pop     BC              ; Get value
20AC: 79       [161]            ld      A,C             ; Get LSB
20AD: 212323   [171]            ld      HL,ACPASS       ; Address of save AC as current
20B0: 2005     [178|183]        jr      NZ,POR1         ; if X/OR, jump over
20B2: A3       [ 4]     PAND1:  and     E               ; "AND" LSBs
20B3: 4F       [ 8]             ld      C,A             ; Save LSB
20B4: 78       [12]             ld      A,B             ; Get MSB
20B5: A2       [16]             and     D               ; "AND" MSBs
20B6: E9       [20]             jp      (HL)            ; Save AC as current (ACPASS)
20B7: F2BF20   [10|10]  POR1:   jp      P,PXOR1         ; if S=0, jump to XOR
20BA: B3       [14]             or      E               ; "OR" LSBs
20BB: 4F       [18]             ld      C,A             ; Save LSB
20BC: 78       [22]             ld      A,B             ; Get MSB
20BD: B2       [26]             or      D               ; "OR" MSBs
20BE: E9       [30]             jp      (HL)            ; Save AC as current (ACPASS)
20BF: AB       [ 4]     PXOR1:  xor     E               ; "XOR" LSBs
20C0: 4F       [ 8]             ld      C,A             ; Save LSB
20C1: 78       [12]             ld      A,B             ; Get MSB
20C2: AA       [16]             xor     D               ; "XOR" MSBs
20C3: E9       [20]             jp      (HL)            ; Save AC as current (ACPASS) 
                        
20C4: 21D620   [10]     TSTRED: ld      HL,CMPLOG       ; Logical compare routine
20C7: 3A9281   [23]             ld      A,(TYPE)        ; Get data type
20CA: 1F       [27]             rra                     ; Carry set = string
20CB: 7A       [31]             ld      A,D             ; Get last precedence value
20CC: 17       [35]             rla                     ; Times 2 plus carry
20CD: 5F       [39]             ld      E,A             ; To E
20CE: 1664     [46]             ld      D,$64           ; Relational precedence
20D0: 78       [50]             ld      A,B             ; Get current precedence
20D1: BA       [54]             cp      D               ; Compare with last
20D2: D0       [59|65]          ret     NC              ; Eval if last was rel' or log'
20D3: C3AC1F   [69]             jp      STKTHS          ; Stack this one and get next
                        
20D6: D820              CMPLOG: defw    CMPLG1          ; Compare two values / strings
20D8: 79       [ 4]     CMPLG1: ld      A,C             ; Get data type
20D9: B7       [ 8]             or      A
20DA: 1F       [12]             rra
20DB: C1       [22]             pop     BC              ; Get last expression to BCDE
20DC: D1       [32]             pop     DE
20DD: F5       [43]             push    AF              ; Save status
20DE: CD3F1F   [60]             call    CHKTYP          ; Check that types match
20E1: 211A21   [70]             ld      HL,CMPRES       ; Result to comparison
20E4: E5       [81]             push    HL              ; Save for RETurn
20E5: CAC32D   [91|91]          jp      Z,CMPNUM        ; Compare values if numeric
20E8: AF       [95]             xor     A               ; Compare two strings
20E9: 329281   [108]            ld      (TYPE),A        ; Set type to numeric
20EC: D5       [119]            push    DE              ; Save string name
20ED: CD8525   [136]            call    GSTRCU          ; Get current string
20F0: 7E       [143]            ld      A,(HL)          ; Get length of string
20F1: 23       [149]            inc     HL
20F2: 23       [155]            inc     HL
20F3: 4E       [162]            ld      C,(HL)          ; Get LSB of address
20F4: 23       [168]            inc     HL
20F5: 46       [175]            ld      B,(HL)          ; Get MSB of address
20F6: D1       [185]            pop     DE              ; Restore string name
20F7: C5       [196]            push    BC              ; Save address of string
20F8: F5       [207]            push    AF              ; Save length of string
20F9: CD8925   [224]            call    GSTRDE          ; Get second string
20FC: CD972D   [241]            call    LOADFP          ; Get address of second string
20FF: F1       [251]            pop     AF              ; Restore length of string 1
2100: 57       [255]            ld      D,A             ; Length to D
2101: E1       [265]            pop     HL              ; Restore address of string 1
2102: 7B       [ 4]     CMPSTR: ld      A,E             ; Bytes of string 2 to do
2103: B2       [ 8]             or      D               ; Bytes of string 1 to do
2104: C8       [13|19]          ret     Z               ; Exit if all bytes compared
2105: 7A       [17]             ld      A,D             ; Get bytes of string 1 to do
2106: D601     [24]             sub     $01
2108: D8       [29|35]          ret     C               ; Exit if end of string 1
2109: AF       [33]             xor     A
210A: BB       [37]             cp      E               ; Bytes of string 2 to do
210B: 3C       [41]             inc     A
210C: D0       [46|52]          ret     NC              ; Exit if end of string 2
210D: 15       [50]             dec     D               ; Count bytes in string 1
210E: 1D       [54]             dec     E               ; Count bytes in string 2
210F: 0A       [61]             ld      A,(BC)          ; Byte in string 2
2110: BE       [68]             cp      (HL)            ; Compare to byte in string 1
2111: 23       [74]             inc     HL              ; Move up string 1
2112: 03       [80]             inc     BC              ; Move up string 2
2113: CA0221   [90|90]          jp      Z,CMPSTR        ; Same - Try next bytes
2116: 3F       [94]             ccf                     ; Flag difference (">" or "<")
2117: C3532D   [104]            jp      FLGDIF          ; "<" gives -1 , ">" gives +1
                        
211A: 3C       [ 4]     CMPRES: inc     A               ; Increment current value
211B: 8F       [ 8]             adc     A,A             ; Double plus carry
211C: C1       [18]             pop     BC              ; Get other value
211D: A0       [22]             and     B               ; Combine them
211E: C6FF     [29]             add     A,-1            ; Carry set if different
2120: 9F       [33]             sbc     A,A             ; 00 - Equal , FF - Different
2121: C35A2D   [43]             jp      FLGREL          ; Set current value & continue
                        
2124: 165A     [ 7]     EVNOT:  ld      D,$5A           ; Precedence value for "NOT"
2126: CD4F1F   [24]             call    EVAL1           ; Eval until precedence break
2129: CD3D1F   [41]             call    TSTNUM          ; Make sure it's a number
212C: CD6D1B   [58]             call    DEINT           ; Get integer -32768 - 32767
212F: 7B       [62]             ld      A,E             ; Get LSB
2130: 2F       [66]             cpl                     ; Invert LSB
2131: 4F       [70]             ld      C,A             ; Save "NOT" of LSB
2132: 7A       [74]             ld      A,D             ; Get MSB
2133: 2F       [78]             cpl                     ; Invert MSB
2134: CD2323   [95]             call    ACPASS          ; Save AC as current
2137: C1       [105]            pop     BC              ; Clean up stack
2138: C35B1F   [115]            jp      EVAL3           ; Continue evaluation
                        
213B: 2B       [ 6]     DIMRET: dec     HL              ; dec 'cos GETCHR INCs
213C: CDB71A   [23]             call    GETCHR          ; Get next character
213F: C8       [28|34]          ret     Z               ; End of DIM statement
2140: CD9418   [45]             call    CHKSYN          ; Make sure ',' follows
2143: 2C                        defb    ','
2144: 013B21   [10]     DIM:    ld      BC,DIMRET       ; Return to "DIMRET"
2147: C5       [21]             push    BC              ; Save on stack
2148: F6                        defb    $F6             ; Flag "Create" variable
2149: AF       [ 4]     GETVAR: xor     A               ; Find variable address,to DE
214A: 329181   [17]             ld      (LCRFLG),A      ; Set locate / create flag
214D: 46       [24]             ld      B,(HL)          ; Get First byte of name
214E: CD591B   [17]     GTFNAM: call    CHKLTR          ; See if a letter
2151: DAB215   [27|27]          jp      C,SNERR         ; ?SN Error if not a letter
2154: AF       [31]             xor     A
2155: 4F       [35]             ld      C,A             ; Clear second byte of name
2156: 329281   [48]             ld      (TYPE),A        ; Set type to numeric
2159: CDB71A   [65]             call    GETCHR          ; Get next character
215C: DA6521   [75|75]          jp      C,SVNAM2        ; Numeric - Save in name
215F: CD591B   [92]             call    CHKLTR          ; See if a letter
2162: DA7221   [102|102]        jp      C,CHARTY        ; Not a letter - Check type
2165: 4F       [ 4]     SVNAM2: ld      C,A             ; Save second byte of name
2166: CDB71A   [17]     ENDNAM: call    GETCHR          ; Get next character
2169: DA6621   [27|27]          jp      C,ENDNAM        ; Numeric - Get another
216C: CD591B   [44]             call    CHKLTR          ; See if a letter
216F: D26621   [54|54]          jp      NC,ENDNAM       ; Letter - Get another
2172: D624     [ 7]     CHARTY: sub     '$'             ; String variable?
2174: C28121   [17|17]          jp      NZ,NOTSTR       ; No - Numeric variable
2177: 3C       [21]             inc     A               ; A = 1 (string type)
2178: 329281   [34]             ld      (TYPE),A        ; Set type to string
217B: 0F       [38]             rrca                    ; A = 80H , Flag for string
217C: 81       [42]             add     A,C             ; 2nd byte of name has bit 7 on
217D: 4F       [46]             ld      C,A             ; Resave second byte on name
217E: CDB71A   [63]             call    GETCHR          ; Get next character
2181: 3AB081   [13]     NOTSTR: ld      A,(FORFLG)      ; Array name needed ?
2184: 3D       [17]             dec     A
2185: CA2E22   [27|27]          jp      Z,ARLDSV        ; Yes - Get array name
2188: F29121   [37|37]          jp      P,NSCFOR        ; No array with "FOR" or "FN"
218B: 7E       [44]             ld      A,(HL)          ; Get byte again
218C: D628     [51]             sub     '('             ; Subscripted variable?
218E: CA0622   [61|61]          jp      Z,SBSCPT        ; Yes - Sort out subscript
                        
2191: AF       [ 4]     NSCFOR: xor     A               ; Simple variable
2192: 32B081   [17]             ld      (FORFLG),A      ; Clear "FOR" flag
2195: E5       [28]             push    HL              ; Save code string address
2196: 50       [32]             ld      D,B             ; DE = Variable name to find
2197: 59       [36]             ld      E,C
2198: 2A2682   [52]             ld      HL,(FNRGNM)     ; FN argument name
219B: CD8E18   [69]             call    CPDEHL          ; Is it the FN argument?
219E: 112882   [79]             ld      DE,FNARG        ; Point to argument value
21A1: CA382C   [89|89]          jp      Z,POPHRT        ; Yes - Return FN argument value
21A4: 2A2082   [105]            ld      HL,(VAREND)     ; End of variables
21A7: EB       [109]            ex      DE,HL           ; Address of end of search
21A8: 2A1E82   [125]            ld      HL,(PROGND)     ; Start of variables address
21AB: CD8E18   [17]     FNDVAR: call    CPDEHL          ; End of variable list table?
21AE: CAC421   [27|27]          jp      Z,CFEVAL        ; Yes - Called from EVAL?
21B1: 79       [31]             ld      A,C             ; Get second byte of name
21B2: 96       [38]             sub     (HL)            ; Compare with name in list
21B3: 23       [44]             inc     HL              ; Move on to first byte
21B4: C2B921   [54|54]          jp      NZ,FNTHR        ; Different - Find another
21B7: 78       [58]             ld      A,B             ; Get first byte of name
21B8: 96       [65]             sub     (HL)            ; Compare with name in list
21B9: 23       [ 6]     FNTHR:  inc     HL              ; Move on to LSB of value
21BA: CAF821   [16|16]          jp      Z,RETADR        ; Found - Return address
21BD: 23       [22]             inc     HL              ; <- Skip
21BE: 23       [28]             inc     HL              ; <- over
21BF: 23       [34]             inc     HL              ; <- F.P.
21C0: 23       [40]             inc     HL              ; <- value
21C1: C3AB21   [50]             jp      FNDVAR          ; Keep looking
                        
21C4: E1       [10]     CFEVAL: pop     HL              ; Restore code string address
21C5: E3       [29]             ex      (SP),HL         ; Get return address
21C6: D5       [40]             push    DE              ; Save address of variable
21C7: 112D20   [50]             ld      DE,FRMEVL       ; Return address in EVAL
21CA: CD8E18   [67]             call    CPDEHL          ; Called from EVAL ?
21CD: D1       [77]             pop     DE              ; Restore address of variable
21CE: CAFB21   [87|87]          jp      Z,RETNUL        ; Yes - Return null variable
21D1: E3       [106]            ex      (SP),HL         ; Put back return
21D2: E5       [117]            push    HL              ; Save code string address
21D3: C5       [128]            push    BC              ; Save variable name
21D4: 010600   [138]            ld      BC,$0006        ; 2 byte name plus 4 byte data
21D7: 2A2282   [154]            ld      HL,(ARREND)     ; End of arrays
21DA: E5       [165]            push    HL              ; Save end of arrays
21DB: 09       [176]            add     HL,BC           ; Move up 6 bytes
21DC: C1       [186]            pop     BC              ; Source address in BC
21DD: E5       [197]            push    HL              ; Save new end address
21DE: CD5E15   [214]            call    MOVUP           ; Move arrays up
21E1: E1       [224]            pop     HL              ; Restore new end address
21E2: 222282   [240]            ld      (ARREND),HL     ; Set new end address
21E5: 60       [244]            ld      H,B             ; End of variables to HL
21E6: 69       [248]            ld      L,C
21E7: 222082   [264]            ld      (VAREND),HL     ; Set new end address
                        
21EA: 2B       [ 6]     ZEROLP: dec     HL              ; Back through to zero variable
21EB: 3600     [16]             ld      (HL),$00        ; Zero byte in variable
21ED: CD8E18   [33]             call    CPDEHL          ; Done them all?
21F0: C2EA21   [43|43]          jp      NZ,ZEROLP       ; No - Keep on going
21F3: D1       [53]             pop     DE              ; Get variable name
21F4: 73       [60]             ld      (HL),E          ; Store second character
21F5: 23       [66]             inc     HL
21F6: 72       [73]             ld      (HL),D          ; Store first character
21F7: 23       [79]             inc     HL
21F8: EB       [ 4]     RETADR: ex      DE,HL           ; Address of variable in DE
21F9: E1       [14]             pop     HL              ; Restore code string address
21FA: C9       [24]             ret
                        
21FB: 322F82   [13]     RETNUL: ld      (FPEXP),A       ; Set result to zero
21FE: 212F15   [23]             ld      HL,ZERBYT       ; Also set a null string
2201: 222C82   [39]             ld      (FPREG),HL      ; Save for EVAL
2204: E1       [49]             pop     HL              ; Restore code string address
2205: C9       [59]             ret
                        
2206: E5       [11]     SBSCPT: push    HL              ; Save code string address
2207: 2A9181   [27]             ld      HL,(LCRFLG)     ; Locate/Create and Type
220A: E3       [46]             ex      (SP),HL         ; Save and get code string
220B: 57       [50]             ld      D,A             ; Zero number of dimensions
220C: D5       [11]     SCPTLP: push    DE              ; Save number of dimensions
220D: C5       [22]             push    BC              ; Save array name
220E: CD611B   [39]             call    FPSINT          ; Get subscript (0-32767)
2211: C1       [49]             pop     BC              ; Restore array name
2212: F1       [59]             pop     AF              ; Get number of dimensions
2213: EB       [63]             ex      DE,HL
2214: E3       [82]             ex      (SP),HL         ; Save subscript value
2215: E5       [93]             push    HL              ; Save LCRFLG and TYPE
2216: EB       [97]             ex      DE,HL
2217: 3C       [101]            inc     A               ; Count dimensions
2218: 57       [105]            ld      D,A             ; Save in D
2219: 7E       [112]            ld      A,(HL)          ; Get next byte in code string
221A: FE2C     [119]            cp      ','             ; Comma (more to come)?
221C: CA0C22   [129|129]        jp      Z,SCPTLP        ; Yes - More subscripts
221F: CD9418   [146]            call    CHKSYN          ; Make sure ")" follows
2222: 29                        defb    ')'
2223: 22B581   [162]            ld      (NXTOPR),HL     ; Save code string address
2226: E1       [172]            pop     HL              ; Get LCRFLG and TYPE
2227: 229181   [188]            ld      (LCRFLG),HL     ; Restore Locate/create & type
222A: 1E00     [195]            ld      E,$00           ; Flag not CSAVE* or CLOAD*
222C: D5       [206]            push    DE              ; Save number of dimensions (D)
222D: 11                        defb    $11             ; Skip "push HL" and "push AF'
                        
222E: E5       [11]     ARLDSV: push    HL              ; Save code string address
222F: F5       [22]             push    AF              ; A = 00 , Flags set = Z,N
2230: 2A2082   [38]             ld      HL,(VAREND)     ; Start of arrays
2233: 3E                        defb    $3E             ; Skip "add HL,DE"
2234: 19       [11]     FNDARY: add     HL,DE           ; Move to next array start
2235: EB       [15]             ex      DE,HL
2236: 2A2282   [31]             ld      HL,(ARREND)     ; End of arrays
2239: EB       [35]             ex      DE,HL           ; Current array pointer
223A: CD8E18   [52]             call    CPDEHL          ; End of arrays found?
223D: CA6622   [62|62]          jp      Z,CREARY        ; Yes - Create array
2240: 7E       [69]             ld      A,(HL)          ; Get second byte of name
2241: B9       [73]             cp      C               ; Compare with name given
2242: 23       [79]             inc     HL              ; Move on
2243: C24822   [89|89]          jp      NZ,NXTARY       ; Different - Find next array
2246: 7E       [96]             ld      A,(HL)          ; Get first byte of name
2247: B8       [100]            cp      B               ; Compare with name given
2248: 23       [ 6]     NXTARY: inc     HL              ; Move on
2249: 5E       [13]             ld      E,(HL)          ; Get LSB of next array address
224A: 23       [19]             inc     HL
224B: 56       [26]             ld      D,(HL)          ; Get MSB of next array address
224C: 23       [32]             inc     HL
224D: C23422   [42|42]          jp      NZ,FNDARY       ; Not found - Keep looking
2250: 3A9181   [55]             ld      A,(LCRFLG)      ; Found Locate or Create it?
2253: B7       [59]             or      A
2254: C2BB15   [69|69]          jp      NZ,DDERR        ; Create - ?DD Error
2257: F1       [79]             pop     AF              ; Locate - Get number of dim'ns
2258: 44       [83]             ld      B,H             ; BC Points to array dim'ns
2259: 4D       [87]             ld      C,L
225A: CA382C   [97|97]          jp      Z,POPHRT        ; Jump if array load/save
225D: 96       [104]            sub     (HL)            ; Same number of dimensions?
225E: CAC422   [114|114]        jp      Z,FINDEL        ; Yes - Find element
2261: 1E10     [ 7]     BSERR:  ld      E,BS            ; ?BS Error
2263: C3C615   [17]             jp      ERROR           ; Output error
                        
2266: 110400   [10]     CREARY: ld      DE,$0004        ; 4 Bytes per entry
2269: F1       [20]             pop     AF              ; Array to save or 0 dim'ns?
226A: CA821B   [30|30]          jp      Z,FCERR         ; Yes - ?FC Error
226D: 71       [37]             ld      (HL),C          ; Save second byte of name
226E: 23       [43]             inc     HL
226F: 70       [50]             ld      (HL),B          ; Save first byte of name
2270: 23       [56]             inc     HL
2271: 4F       [60]             ld      C,A             ; Number of dimensions to C
2272: CD6F15   [77]             call    CHKSTK          ; Check if enough memory
2275: 23       [83]             inc     HL              ; Point to number of dimensions
2276: 23       [89]             inc     HL
2277: 22AA81   [105]            ld      (CUROPR),HL     ; Save address of pointer
227A: 71       [112]            ld      (HL),C          ; Set number of dimensions
227B: 23       [118]            inc     HL
227C: 3A9181   [131]            ld      A,(LCRFLG)      ; Locate of Create?
227F: 17       [135]            rla                     ; Carry set = Create
2280: 79       [139]            ld      A,C             ; Get number of dimensions
2281: 010B00   [10]     CRARLP: ld      BC,10+1         ; Default dimension size 10
2284: D28922   [20|20]          jp      NC,DEFSIZ       ; Locate - Set default size
2287: C1       [30]             pop     BC              ; Get specified dimension size
2288: 03       [36]             inc     BC              ; Include zero element
2289: 71       [ 7]     DEFSIZ: ld      (HL),C          ; Save LSB of dimension size
228A: 23       [13]             inc     HL
228B: 70       [20]             ld      (HL),B          ; Save MSB of dimension size
228C: 23       [26]             inc     HL
228D: F5       [37]             push    AF              ; Save num' of dim'ns an status
228E: E5       [48]             push    HL              ; Save address of dim'n size
228F: CD342E   [65]             call    MLDEBC          ; Multiply DE by BC to find
2292: EB       [69]             ex      DE,HL           ; amount of mem needed (to DE)
2293: E1       [79]             pop     HL              ; Restore address of dimension
2294: F1       [89]             pop     AF              ; Restore number of dimensions
2295: 3D       [93]             dec     A               ; Count them
2296: C28122   [103|103]        jp      NZ,CRARLP       ; Do next dimension if more
2299: F5       [114]            push    AF              ; Save locate/create flag
229A: 42       [118]            ld      B,D             ; MSB of memory needed
229B: 4B       [122]            ld      C,E             ; LSB of memory needed
229C: EB       [126]            ex      DE,HL
229D: 19       [137]            add     HL,DE           ; Add bytes to array start
229E: DA8715   [147|147]        jp      C,OMERR         ; Too big - Error
22A1: CD7815   [164]            call    ENFMEM          ; See if enough memory
22A4: 222282   [180]            ld      (ARREND),HL     ; Save new end of array
                        
22A7: 2B       [ 6]     ZERARY: dec     HL              ; Back through array data
22A8: 3600     [16]             ld      (HL),$00        ; Set array element to zero
22AA: CD8E18   [33]             call    CPDEHL          ; All elements zeroed?
22AD: C2A722   [43|43]          jp      NZ,ZERARY       ; No - Keep on going
22B0: 03       [49]             inc     BC              ; Number of bytes + 1
22B1: 57       [53]             ld      D,A             ; A=0
22B2: 2AAA81   [69]             ld      HL,(CUROPR)     ; Get address of array
22B5: 5E       [76]             ld      E,(HL)          ; Number of dimensions
22B6: EB       [80]             ex      DE,HL           ; To HL
22B7: 29       [91]             add     HL,HL           ; Two bytes per dimension size
22B8: 09       [102]            add     HL,BC           ; Add number of bytes
22B9: EB       [106]            ex      DE,HL           ; Bytes needed to DE
22BA: 2B       [112]            dec     HL
22BB: 2B       [118]            dec     HL
22BC: 73       [125]            ld      (HL),E          ; Save LSB of bytes needed
22BD: 23       [131]            inc     HL
22BE: 72       [138]            ld      (HL),D          ; Save MSB of bytes needed
22BF: 23       [144]            inc     HL
22C0: F1       [154]            pop     AF              ; Locate / Create?
22C1: DAE822   [164|164]        jp      C,ENDDIM        ; A is 0 , End if create
22C4: 47       [ 4]     FINDEL: ld      B,A             ; Find array element
22C5: 4F       [ 8]             ld      C,A
22C6: 7E       [15]             ld      A,(HL)          ; Number of dimensions
22C7: 23       [21]             inc     HL
22C8: 16                        defb    $16             ; Skip "pop HL"
22C9: E1       [10]     FNDELP: pop     HL              ; Address of next dim' size
22CA: 5E       [17]             ld      E,(HL)          ; Get LSB of dim'n size
22CB: 23       [23]             inc     HL
22CC: 56       [30]             ld      D,(HL)          ; Get MSB of dim'n size
22CD: 23       [36]             inc     HL
22CE: E3       [55]             ex      (SP),HL         ; Save address - Get index
22CF: F5       [66]             push    AF              ; Save number of dim'ns
22D0: CD8E18   [83]             call    CPDEHL          ; Dimension too large?
22D3: D26122   [93|93]          jp      NC,BSERR        ; Yes - ?BS Error
22D6: E5       [104]            push    HL              ; Save index
22D7: CD342E   [121]            call    MLDEBC          ; Multiply previous by size
22DA: D1       [131]            pop     DE              ; Index supplied to DE
22DB: 19       [142]            add     HL,DE           ; Add index to pointer
22DC: F1       [152]            pop     AF              ; Number of dimensions
22DD: 3D       [156]            dec     A               ; Count them
22DE: 44       [160]            ld      B,H             ; MSB of pointer
22DF: 4D       [164]            ld      C,L             ; LSB of pointer
22E0: C2C922   [174|174]        jp      NZ,FNDELP       ; More - Keep going
22E3: 29       [185]            add     HL,HL           ; 4 Bytes per element
22E4: 29       [196]            add     HL,HL
22E5: C1       [206]            pop     BC              ; Start of array
22E6: 09       [217]            add     HL,BC           ; Point to element
22E7: EB       [221]            ex      DE,HL           ; Address of element to DE
22E8: 2AB581   [16]     ENDDIM: ld      HL,(NXTOPR)     ; Got code string address
22EB: C9       [26]             ret
                        
                        
                        ; returns the value of the 32-bit system tick counter as
                        ; two 16-bit words
22EC: CD3D1F   [17]     TMR:    call    TSTNUM          ; Make sure it's a number
22EF: CD6D1B   [34]             call    DEINT           ; Get integer (-32768 to 32767)
22F2: 2ABB81   [50]             ld      HL,(TMRCNT)     ; load the LSBytes of timer
22F5: 7B       [54]             ld      A,E
22F6: B2       [58]             or      D               ; is it 0?
22F7: CAFD22   [68|68]          jp      Z,ENDTMR        ; yes, jump over
22FA: 2ABD81   [84]             ld      HL,(TMRCNT+2)   ; load the MSBytes of timer
22FD: 45       [ 4]     ENDTMR: ld      B,L             ; move bytes...
22FE: 7C       [ 8]             ld      A,H             ; ...into AB
22FF: C32423   [18]             jp      ABPASS          ; return word into AB
                        
                        
                        ; returns the free space for BASIC or into the string pool
2302: 2A2282   [16]     FRE:    ld      HL,(ARREND)     ; Start of free memory
2305: EB       [20]             ex      DE,HL           ; To DE
2306: 210000   [30]             ld      HL,$0000        ; End of free memory
2309: 39       [41]             add     HL,SP           ; Current stack value
230A: 3A9281   [54]             ld      A,(TYPE)        ; Dummy argument type
230D: B7       [58]             or      A
230E: CA1E23   [68|68]          jp      Z,FRENUM        ; Numeric - Free variable space
2311: CD8525   [85]             call    GSTRCU          ; Current string to pool
2314: CD8524   [102]            call    GARBGE          ; Garbage collection
2317: 2AAD80   [118]            ld      HL,(STRSPC)     ; Bottom of string space in use
231A: EB       [122]            ex      DE,HL           ; To DE
231B: 2AA881   [138]            ld      HL,(STRBOT)     ; Bottom of string space
231E: 7D       [ 4]     FRENUM: ld      A,L             ; Get LSB of end
231F: 93       [ 8]             sub     E               ; Subtract LSB of beginning
2320: 4F       [12]             ld      C,A             ; Save difference if C
2321: 7C       [16]             ld      A,H             ; Get MSB of end
2322: 9A       [20]             sbc     A,D             ; Subtract MSB of beginning
2323: 41       [ 4]     ACPASS: ld      B,C             ; Return integer AC
2324: 50       [ 4]     ABPASS: ld      D,B             ; Return integer AB
2325: 1E00     [11]             ld      E,$00
2327: 219281   [21]             ld      HL,TYPE         ; Point to type
232A: 73       [28]             ld      (HL),E          ; Set type to numeric
232B: 0690     [35]             ld      B,$80+$10       ; 16 bit integer
232D: C35F2D   [45]             jp      RETINT          ; Return the integer
                        
                        ; returns the X position of the cursor during a print
2330: 3A9081   [13]     POS:    ld      A,(CURPOS)      ; Get cursor position
2333: 47       [ 4]     PASSA:  ld      B,A             ; Put A into AB
2334: AF       [ 8]             xor     A               ; Zero A
2335: C32423   [18]             jp      ABPASS          ; Return integer AB
                        
2338: CDBB23   [17]     DEF:    call    CHEKFN          ; Get "FN" and name
233B: CDAD23   [34]             call    IDTEST          ; Test for illegal direct
233E: 015A1C   [44]             ld      BC,DATA         ; To get next statement
2341: C5       [55]             push    BC              ; Save address for RETurn
2342: D5       [66]             push    DE              ; Save address of function ptr
2343: CD9418   [83]             call    CHKSYN          ; Make sure "(" follows
2346: 28                        defb    '('
2347: CD4921   [100]            call    GETVAR          ; Get argument variable name
234A: E5       [111]            push    HL              ; Save code string address
234B: EB       [115]            ex      DE,HL           ; Argument address to HL
234C: 2B       [121]            dec     HL
234D: 56       [128]            ld      D,(HL)          ; Get first byte of arg name
234E: 2B       [134]            dec     HL
234F: 5E       [141]            ld      E,(HL)          ; Get second byte of arg name
2350: E1       [151]            pop     HL              ; Restore code string address
2351: CD3D1F   [168]            call    TSTNUM          ; Make sure numeric argument
2354: CD9418   [185]            call    CHKSYN          ; Make sure ")" follows
2357: 29                        defb    ')'
2358: CD9418   [202]            call    CHKSYN          ; Make sure "=" follows
235B: C8                        defb    ZEQUAL          ; "=" token
235C: 44       [206]            ld      B,H             ; Code string address to BC
235D: 4D       [210]            ld      C,L
235E: E3       [229]            ex      (SP),HL         ; Save code str , Get FN ptr
235F: 71       [236]            ld      (HL),C          ; Save LSB of FN code string
2360: 23       [242]            inc     HL
2361: 70       [249]            ld      (HL),B          ; Save MSB of FN code string
2362: C3FA23   [259]            jp      SVSTAD          ; Save address and do function
                        
2365: CDBB23   [17]     DOFN:   call    CHEKFN          ; Make sure FN follows
2368: D5       [28]             push    DE              ; Save function pointer address
2369: CD1120   [45]             call    EVLPAR          ; Evaluate expression in "()"
236C: CD3D1F   [62]             call    TSTNUM          ; Make sure numeric result
236F: E3       [81]             ex      (SP),HL         ; Save code str , Get FN ptr
2370: 5E       [88]             ld      E,(HL)          ; Get LSB of FN code string
2371: 23       [94]             inc     HL
2372: 56       [101]            ld      D,(HL)          ; Get MSB of FN code string
2373: 23       [107]            inc     HL
2374: 7A       [111]            ld      A,D             ; And function DEFined?
2375: B3       [115]            or      E
2376: CABE15   [125|125]        jp      Z,UFERR         ; No - ?UF Error
2379: 7E       [132]            ld      A,(HL)          ; Get LSB of argument address
237A: 23       [138]            inc     HL
237B: 66       [145]            ld      H,(HL)          ; Get MSB of argument address
237C: 6F       [149]            ld      L,A             ; HL = Arg variable address
237D: E5       [160]            push    HL              ; Save it
237E: 2A2682   [176]            ld      HL,(FNRGNM)     ; Get old argument name
2381: E3       [195]            ex      (SP),HL         ; Save old , Get new
2382: 222682   [211]            ld      (FNRGNM),HL     ; Set new argument name
2385: 2A2A82   [227]            ld      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2388: E5       [238]            push    HL              ; Save it
2389: 2A2882   [254]            ld      HL,(FNARG)      ; Get MSB,EXP of old arg value
238C: E5       [265]            push    HL              ; Save it
238D: 212882   [275]            ld      HL,FNARG        ; HL = Value of argument
2390: D5       [286]            push    DE              ; Save FN code string address
2391: CDA02D   [303]            call    FPTHL           ; Move FPREG to argument
2394: E1       [313]            pop     HL              ; Get FN code string address
2395: CD3A1F   [330]            call    GETNUM          ; Get value from function
2398: 2B       [336]            dec     HL              ; dec 'cos GETCHR INCs
2399: CDB71A   [353]            call    GETCHR          ; Get next character
239C: C2B215   [363|363]        jp      NZ,SNERR        ; Bad character in FN - Error
239F: E1       [373]            pop     HL              ; Get MSB,EXP of old arg
23A0: 222882   [389]            ld      (FNARG),HL      ; Restore it
23A3: E1       [399]            pop     HL              ; Get LSB,NLSB of old arg
23A4: 222A82   [415]            ld      (FNARG+2),HL    ; Restore it
23A7: E1       [425]            pop     HL              ; Get name of old arg
23A8: 222682   [441]            ld      (FNRGNM),HL     ; Restore it
23AB: E1       [451]            pop     HL              ; Restore code string address
23AC: C9       [461]            ret
                        
23AD: E5       [11]     IDTEST: push    HL              ; Save code string address
23AE: 2AAF80   [27]             ld      HL,(LINEAT)     ; Get current line number
23B1: 23       [33]             inc     HL              ; -1 means direct statement
23B2: 7C       [37]             ld      A,H
23B3: B5       [41]             or      L
23B4: E1       [51]             pop     HL              ; Restore code string address
23B5: C0       [56|62]          ret     NZ              ; Return if in program
23B6: 1E16     [63]             ld      E,ID            ; ?ID Error
23B8: C3C615   [73]             jp      ERROR
                        
23BB: CD9418   [17]     CHEKFN: call    CHKSYN          ; Make sure FN follows
23BE: B8                        defb    ZFN             ; "FN" token
23BF: 3E80     [24]             ld      A,$80
23C1: 32B081   [37]             ld      (FORFLG),A      ; Flag FN name to find
23C4: B6       [44]             or      (HL)            ; FN name has bit 7 set
23C5: 47       [48]             ld      B,A             ; in first byte of name
23C6: CD4E21   [65]             call    GTFNAM          ; Get FN name
23C9: C33D1F   [75]             jp      TSTNUM          ; Make sure numeric function
                        
23CC: CD3D1F   [17]     STR:    call    TSTNUM          ; Make sure it's a number
23CF: CDED2E   [34]             call    NUMASC          ; Turn number into text
23D2: CD0024   [17]     STR1:   call    CRTST           ; Create string entry for it
23D5: CD8525   [34]             call    GSTRCU          ; Current string to pool
23D8: 01E025   [44]             ld      BC,TOPOOL       ; Save in string pool
23DB: C5       [55]             push    BC              ; Save address on stack
                        
23DC: 7E       [ 7]     SAVSTR: ld      A,(HL)          ; Get string length
23DD: 23       [13]             inc     HL
23DE: 23       [19]             inc     HL
23DF: E5       [30]             push    HL              ; Save pointer to string
23E0: CD5B24   [47]             call    TESTR           ; See if enough string space
23E3: E1       [57]             pop     HL              ; Restore pointer to string
23E4: 4E       [64]             ld      C,(HL)          ; Get LSB of address
23E5: 23       [70]             inc     HL
23E6: 46       [77]             ld      B,(HL)          ; Get MSB of address
23E7: CDF423   [94]             call    CRTMST          ; Create string entry
23EA: E5       [105]            push    HL              ; Save pointer to MSB of addr
23EB: 6F       [109]            ld      L,A             ; Length of string
23EC: CD7825   [126]            call    TOSTRA          ; Move to string area
23EF: D1       [136]            pop     DE              ; Restore pointer to MSB
23F0: C9       [146]            ret
                        
23F1: CD5B24   [17]     MKTMST: call    TESTR           ; See if enough string space
23F4: 21A481   [10]     CRTMST: ld      HL,TMPSTR       ; Temporary string
23F7: E5       [21]             push    HL              ; Save it
23F8: 77       [28]             ld      (HL),A          ; Save length of string
23F9: 23       [34]             inc     HL
23FA: 23       [ 6]     SVSTAD: inc     HL
23FB: 73       [13]             ld      (HL),E          ; Save LSB of address
23FC: 23       [19]             inc     HL
23FD: 72       [26]             ld      (HL),D          ; Save MSB of address
23FE: E1       [36]             pop     HL              ; Restore pointer
23FF: C9       [46]             ret
                        
2400: 2B       [ 6]     CRTST:  dec     HL              ; dec - INCed after
2401: 0622     [ 7]     QTSTR:  ld      B,$22           ; '"'           ; Terminating quote
2403: 50       [11]             ld      D,B             ; Quote to D
2404: E5       [11]     DTSTR:  push    HL              ; Save start
2405: 0EFF     [18]             ld      C,-1            ; Set counter to -1
2407: 23       [ 6]     QTSTLP: inc     HL              ; Move on
2408: 7E       [13]             ld      A,(HL)          ; Get byte
2409: 0C       [17]             inc     C               ; Count bytes
240A: B7       [21]             or      A               ; End of line?
240B: CA1624   [31|31]          jp      Z,CRTSTE        ; Yes - Create string entry
240E: BA       [35]             cp      D               ; Terminator D found?
240F: CA1624   [45|45]          jp      Z,CRTSTE        ; Yes - Create string entry
2412: B8       [49]             cp      B               ; Terminator B found?
2413: C20724   [59|59]          jp      NZ,QTSTLP       ; No - Keep looking
2416: FE22     [ 7]     CRTSTE: cp      $22             ; '"'             ; End with '"'?
2418: CCB71A   [17|24]          call    Z,GETCHR        ; Yes - Get next character
241B: E3       [36]             ex      (SP),HL         ; Starting quote
241C: 23       [42]             inc     HL              ; First byte of string
241D: EB       [46]             ex      DE,HL           ; To DE
241E: 79       [50]             ld      A,C             ; Get length
241F: CDF423   [67]             call    CRTMST          ; Create string entry
2422: 11A481   [10]     TSTOPL: ld      DE,TMPSTR       ; Temporary string
2425: 2A9681   [26]             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2428: 222C82   [42]             ld      (FPREG),HL      ; Save address of string ptr
242B: 3E01     [49]             ld      A,$01
242D: 329281   [62]             ld      (TYPE),A        ; Set type to string
2430: CDA32D   [79]             call    DETHL4          ; Move string to pool
2433: CD8E18   [96]             call    CPDEHL          ; Out of string pool?
2436: 229681   [112]            ld      (TMSTPT),HL     ; Save new pointer
2439: E1       [122]            pop     HL              ; Restore code string address
243A: 7E       [129]            ld      A,(HL)          ; Get next code byte
243B: C0       [134|140]        ret     NZ              ; Return if pool OK
243C: 1E1E     [141]            ld      E,ST            ; ?ST Error
243E: C3C615   [151]            jp      ERROR           ; String pool overflow
                        
2441: 23       [ 6]     PRNUMS: inc     HL              ; Skip leading space
2442: CD0024   [17]     PRS:    call    CRTST           ; Create string entry for it
2445: CD8525   [17]     PRS1:   call    GSTRCU          ; Current string to pool
2448: CD972D   [34]             call    LOADFP          ; Move string block to BCDE
244B: 1C       [38]             inc     E               ; Length + 1
244C: 1D       [ 4]     PRSLP:  dec     E               ; Count characters
244D: C8       [ 9|15]          ret     Z               ; End of string
244E: 0A       [16]             ld      A,(BC)          ; Get byte to output
244F: CD9F18   [33]             call    OUTC            ; Output character in A
2452: FE0D     [40]             cp      CR              ; Return?
2454: CC881D   [50|57]          call    Z,CNTEND        ; Yes - Position cursor to 0
2457: 03       [56]             inc     BC              ; Next byte in string
2458: C34C24   [66]             jp      PRSLP           ; More characters to output
                        
245B: B7       [ 4]     TESTR:  or      A               ; Test if enough room
245C: 0E                        defb    $0E             ; No garbage collection done
245D: F1       [10]     GRBDON: pop     AF              ; Garbage collection done
245E: F5       [21]             push    AF              ; Save status
245F: 2AAD80   [37]             ld      HL,(STRSPC)     ; Bottom of string space in use
2462: EB       [41]             ex      DE,HL           ; To DE
2463: 2AA881   [57]             ld      HL,(STRBOT)     ; Bottom of string area
2466: 2F       [61]             cpl                     ; Negate length (Top down)
2467: 4F       [65]             ld      C,A             ; -Length to BC
2468: 06FF     [72]             ld      B,-1            ; BC = -ve length of string
246A: 09       [83]             add     HL,BC           ; Add to bottom of space in use
246B: 23       [89]             inc     HL              ; Plus one for 2's complement
246C: CD8E18   [106]            call    CPDEHL          ; Below string RAM area?
246F: DA7924   [116|116]        jp      C,TESTOS        ; Tidy up if not done else err
2472: 22A881   [132]            ld      (STRBOT),HL     ; Save new bottom of area
2475: 23       [138]            inc     HL              ; Point to first byte of string
2476: EB       [142]            ex      DE,HL           ; Address to DE
2477: F1       [10]     POPAF:  pop     AF              ; Throw away status push
2478: C9       [20]             ret
                        
2479: F1       [10]     TESTOS: pop     AF              ; Garbage collect been done?
247A: 1E1A     [17]             ld      E,OS            ; ?OS Error
247C: CAC615   [27|27]          jp      Z,ERROR         ; Yes - Not enough string space
247F: BF       [31]             cp      A               ; Flag garbage collect done
2480: F5       [42]             push    AF              ; Save status
2481: 015D24   [52]             ld      BC,GRBDON       ; Garbage collection done
2484: C5       [63]             push    BC              ; Save for RETurn
2485: 2A9481   [16]     GARBGE: ld      HL,(LSTRAM)     ; Get end of RAM pointer
2488: 22A881   [16]     GARBLP: ld      (STRBOT),HL     ; Reset string pointer
248B: 210000   [26]             ld      HL,$0000
248E: E5       [37]             push    HL              ; Flag no string found
248F: 2AAD80   [53]             ld      HL,(STRSPC)     ; Get bottom of string space
2492: E5       [64]             push    HL              ; Save bottom of string space
2493: 219881   [74]             ld      HL,TMSTPL       ; Temporary string pool
2496: EB       [ 4]     GRBLP:  ex      DE,HL
2497: 2A9681   [20]             ld      HL,(TMSTPT)     ; Temporary string pool pointer
249A: EB       [24]             ex      DE,HL
249B: CD8E18   [41]             call    CPDEHL          ; Temporary string pool done?
249E: 019624   [51]             ld      BC,GRBLP        ; Loop until string pool done
24A1: C2EA24   [61|61]          jp      NZ,STPOOL       ; No - See if in string area
24A4: 2A1E82   [77]             ld      HL,(PROGND)     ; Start of simple variables
24A7: EB       [ 4]     SMPVAR: ex      DE,HL
24A8: 2A2082   [20]             ld      HL,(VAREND)     ; End of simple variables
24AB: EB       [24]             ex      DE,HL
24AC: CD8E18   [41]             call    CPDEHL          ; All simple strings done?
24AF: CABD24   [51|51]          jp      Z,ARRLP         ; Yes - Do string arrays
24B2: 7E       [58]             ld      A,(HL)          ; Get type of variable
24B3: 23       [64]             inc     HL
24B4: 23       [70]             inc     HL
24B5: B7       [74]             or      A               ; "S" flag set if string
24B6: CDED24   [91]             call    STRADD          ; See if string in string area
24B9: C3A724   [101]            jp      SMPVAR          ; Loop until simple ones done
                        
24BC: C1       [10]     GNXARY: pop     BC              ; Scrap address of this array
24BD: EB       [ 4]     ARRLP:  ex      DE,HL
24BE: 2A2282   [20]             ld      HL,(ARREND)     ; End of string arrays
24C1: EB       [24]             ex      DE,HL
24C2: CD8E18   [41]             call    CPDEHL          ; All string arrays done?
24C5: CA1325   [51|51]          jp      Z,SCNEND        ; Yes - Move string if found
24C8: CD972D   [68]             call    LOADFP          ; Get array name to BCDE
24CB: 7B       [72]             ld      A,E             ; Get type of array
24CC: E5       [83]             push    HL              ; Save address of num of dim'ns
24CD: 09       [94]             add     HL,BC           ; Start of next array
24CE: B7       [98]             or      A               ; Test type of array
24CF: F2BC24   [108|108]        jp      P,GNXARY        ; Numeric array - Ignore it
24D2: 22AA81   [124]            ld      (CUROPR),HL     ; Save address of next array
24D5: E1       [134]            pop     HL              ; Get address of num of dim'ns
24D6: 4E       [141]            ld      C,(HL)          ; BC = Number of dimensions
24D7: 0600     [148]            ld      B,$00
24D9: 09       [159]            add     HL,BC           ; Two bytes per dimension size
24DA: 09       [170]            add     HL,BC
24DB: 23       [176]            inc     HL              ; Plus one for number of dim'ns
24DC: EB       [ 4]     GRBARY: ex      DE,HL
24DD: 2AAA81   [20]             ld      HL,(CUROPR)     ; Get address of next array
24E0: EB       [24]             ex      DE,HL
24E1: CD8E18   [41]             call    CPDEHL          ; Is this array finished?
24E4: CABD24   [51|51]          jp      Z,ARRLP         ; Yes - Get next one
24E7: 01DC24   [61]             ld      BC,GRBARY       ; Loop until array all done
24EA: C5       [11]     STPOOL: push    BC              ; Save return address
24EB: F680     [18]             or      $80             ; Flag string type
24ED: 7E       [ 7]     STRADD: ld      A,(HL)          ; Get string length
24EE: 23       [13]             inc     HL
24EF: 23       [19]             inc     HL
24F0: 5E       [26]             ld      E,(HL)          ; Get LSB of string address
24F1: 23       [32]             inc     HL
24F2: 56       [39]             ld      D,(HL)          ; Get MSB of string address
24F3: 23       [45]             inc     HL
24F4: F0       [50|56]          ret     P               ; Not a string - Return
24F5: B7       [54]             or      A               ; Set flags on string length
24F6: C8       [59|65]          ret     Z               ; Null string - Return
24F7: 44       [63]             ld      B,H             ; Save variable pointer
24F8: 4D       [67]             ld      C,L
24F9: 2AA881   [83]             ld      HL,(STRBOT)     ; Bottom of new area
24FC: CD8E18   [100]            call    CPDEHL          ; String been done?
24FF: 60       [104]            ld      H,B             ; Restore variable pointer
2500: 69       [108]            ld      L,C
2501: D8       [113|119]        ret     C               ; String done - Ignore
2502: E1       [123]            pop     HL              ; Return address
2503: E3       [142]            ex      (SP),HL         ; Lowest available string area
2504: CD8E18   [159]            call    CPDEHL          ; String within string area?
2507: E3       [178]            ex      (SP),HL         ; Lowest available string area
2508: E5       [189]            push    HL              ; Re-save return address
2509: 60       [193]            ld      H,B             ; Restore variable pointer
250A: 69       [197]            ld      L,C
250B: D0       [202|208]        ret     NC              ; Outside string area - Ignore
250C: C1       [212]            pop     BC              ; Get return , Throw 2 away
250D: F1       [222]            pop     AF              ;
250E: F1       [232]            pop     AF              ;
250F: E5       [243]            push    HL              ; Save variable pointer
2510: D5       [254]            push    DE              ; Save address of current
2511: C5       [265]            push    BC              ; Put back return address
2512: C9       [275]            ret                     ; Go to it
                        
2513: D1       [10]     SCNEND: pop     DE              ; Addresses of strings
2514: E1       [20]             pop     HL              ;
2515: 7D       [24]             ld      A,L             ; HL = 0 if no more to do
2516: B4       [28]             or      H
2517: C8       [33|39]          ret     Z               ; No more to do - Return
2518: 2B       [39]             dec     HL
2519: 46       [46]             ld      B,(HL)          ; MSB of address of string
251A: 2B       [52]             dec     HL
251B: 4E       [59]             ld      C,(HL)          ; LSB of address of string
251C: E5       [70]             push    HL              ; Save variable address
251D: 2B       [76]             dec     HL
251E: 2B       [82]             dec     HL
251F: 6E       [89]             ld      L,(HL)          ; HL = Length of string
2520: 2600     [96]             ld      H,$00
2522: 09       [107]            add     HL,BC           ; Address of end of string+1
2523: 50       [111]            ld      D,B             ; String address to DE
2524: 59       [115]            ld      E,C
2525: 2B       [121]            dec     HL              ; Last byte in string
2526: 44       [125]            ld      B,H             ; Address to BC
2527: 4D       [129]            ld      C,L
2528: 2AA881   [145]            ld      HL,(STRBOT)     ; Current bottom of string area
252B: CD6115   [162]            call    MOVSTR          ; Move string to new address
252E: E1       [172]            pop     HL              ; Restore variable address
252F: 71       [179]            ld      (HL),C          ; Save new LSB of address
2530: 23       [185]            inc     HL
2531: 70       [192]            ld      (HL),B          ; Save new MSB of address
2532: 69       [196]            ld      L,C             ; Next string area+1 to HL
2533: 60       [200]            ld      H,B
2534: 2B       [206]            dec     HL              ; Next string area address
2535: C38824   [216]            jp      GARBLP          ; Look for more strings
                        
2538: C5       [11]     CONCAT: push    BC              ; Save prec' opr & code string
2539: E5       [22]             push    HL              ;
253A: 2A2C82   [38]             ld      HL,(FPREG)      ; Get first string
253D: E3       [57]             ex      (SP),HL         ; Save first string
253E: CDC31F   [74]             call    OPRND           ; Get second string
2541: E3       [93]             ex      (SP),HL         ; Restore first string
2542: CD3E1F   [110]            call    TSTSTR          ; Make sure it's a string
2545: 7E       [117]            ld      A,(HL)          ; Get length of second string
2546: E5       [128]            push    HL              ; Save first string
2547: 2A2C82   [144]            ld      HL,(FPREG)      ; Get second string
254A: E5       [155]            push    HL              ; Save second string
254B: 86       [162]            add     A,(HL)          ; Add length of second string
254C: 1E1C     [169]            ld      E,LS            ; ?LS Error
254E: DAC615   [179|179]        jp      C,ERROR         ; String too long - Error
2551: CDF123   [196]            call    MKTMST          ; Make temporary string
2554: D1       [206]            pop     DE              ; Get second string to DE
2555: CD8925   [223]            call    GSTRDE          ; Move to string pool if needed
2558: E3       [242]            ex      (SP),HL         ; Get first string
2559: CD8825   [259]            call    GSTRHL          ; Move to string pool if needed
255C: E5       [270]            push    HL              ; Save first string
255D: 2AA681   [286]            ld      HL,(TMPSTR+2)   ; Temporary string address
2560: EB       [290]            ex      DE,HL           ; To DE
2561: CD6F25   [307]            call    SSTSA           ; First string to string area
2564: CD6F25   [324]            call    SSTSA           ; Second string to string area
2567: 21581F   [334]            ld      HL,EVAL2        ; Return to evaluation loop
256A: E3       [353]            ex      (SP),HL         ; Save return,get code string
256B: E5       [364]            push    HL              ; Save code string address
256C: C32224   [374]            jp      TSTOPL          ; To temporary string to pool
                        
256F: E1       [10]     SSTSA:  pop     HL              ; Return address
2570: E3       [29]             ex      (SP),HL         ; Get string block,save return
2571: 7E       [36]             ld      A,(HL)          ; Get length of string
2572: 23       [42]             inc     HL
2573: 23       [48]             inc     HL
2574: 4E       [55]             ld      C,(HL)          ; Get LSB of string address
2575: 23       [61]             inc     HL
2576: 46       [68]             ld      B,(HL)          ; Get MSB of string address
2577: 6F       [72]             ld      L,A             ; Length to L
2578: 2C       [ 4]     TOSTRA: inc     L               ; inc - DECed after
2579: 2D       [ 4]     TSALP:  dec     L               ; Count bytes moved
257A: C8       [ 9|15]          ret     Z               ; End of string - Return
257B: 0A       [16]             ld      A,(BC)          ; Get source
257C: 12       [23]             ld      (DE),A          ; Save destination
257D: 03       [29]             inc     BC              ; Next source
257E: 13       [35]             inc     DE              ; Next destination
257F: C37925   [45]             jp      TSALP           ; Loop until string moved
                        
2582: CD3E1F   [17]     GETSTR: call    TSTSTR          ; Make sure it's a string
2585: 2A2C82   [16]     GSTRCU: ld      HL,(FPREG)      ; Get current string
2588: EB       [ 4]     GSTRHL: ex      DE,HL           ; Save DE
2589: CDA325   [17]     GSTRDE: call    BAKTMP          ; Was it last tmp-str?
258C: EB       [21]             ex      DE,HL           ; Restore DE
258D: C0       [26|32]          ret     NZ              ; No - Return
258E: D5       [37]             push    DE              ; Save string
258F: 50       [41]             ld      D,B             ; String block address to DE
2590: 59       [45]             ld      E,C
2591: 1B       [51]             dec     DE              ; Point to length
2592: 4E       [58]             ld      C,(HL)          ; Get string length
2593: 2AA881   [74]             ld      HL,(STRBOT)     ; Current bottom of string area
2596: CD8E18   [91]             call    CPDEHL          ; Last one in string area?
2599: C2A125   [101|101]        jp      NZ,POPHL        ; No - Return
259C: 47       [105]            ld      B,A             ; Clear B (A=0)
259D: 09       [116]            add     HL,BC           ; Remove string from str' area
259E: 22A881   [132]            ld      (STRBOT),HL     ; Save new bottom of str' area
25A1: E1       [10]     POPHL:  pop     HL              ; Restore string
25A2: C9       [20]             ret
                        
25A3: 2A9681   [16]     BAKTMP: ld      HL,(TMSTPT)     ; Get temporary string pool top
25A6: 2B       [22]             dec     HL              ; Back
25A7: 46       [29]             ld      B,(HL)          ; Get MSB of address
25A8: 2B       [35]             dec     HL              ; Back
25A9: 4E       [42]             ld      C,(HL)          ; Get LSB of address
25AA: 2B       [48]             dec     HL              ; Back
25AB: 2B       [54]             dec     HL              ; Back
25AC: CD8E18   [71]             call    CPDEHL          ; String last in string pool?
25AF: C0       [76|82]          ret     NZ              ; Yes - Leave it
25B0: 229681   [92]             ld      (TMSTPT),HL     ; Save new string pool top
25B3: C9       [102]            ret
                        
25B4: 013323   [10]     LEN:    ld      BC,PASSA        ; To return integer A
25B7: C5       [21]             push    BC              ; Save address
25B8: CD8225   [17]     GETLEN: call    GETSTR          ; Get string and its length
25BB: AF       [21]             xor     A
25BC: 57       [25]             ld      D,A             ; Clear D
25BD: 329281   [38]             ld      (TYPE),A        ; Set type to numeric
25C0: 7E       [45]             ld      A,(HL)          ; Get length of string
25C1: B7       [49]             or      A               ; Set status flags
25C2: C9       [59]             ret
                        
25C3: 013323   [10]     ASC:    ld      BC,PASSA        ; To return integer A
25C6: C5       [21]             push    BC              ; Save address
25C7: CDB825   [17]     GTFLNM: call    GETLEN          ; Get length of string
25CA: CA821B   [27|27]          jp      Z,FCERR         ; Null string - Error
25CD: 23       [33]             inc     HL
25CE: 23       [39]             inc     HL
25CF: 5E       [46]             ld      E,(HL)          ; Get LSB of address
25D0: 23       [52]             inc     HL
25D1: 56       [59]             ld      D,(HL)          ; Get MSB of address
25D2: 1A       [66]             ld      A,(DE)          ; Get first byte of string
25D3: C9       [76]             ret
                        
25D4: 3E01     [ 7]     CHR:    ld      A,$01           ; One character string
25D6: CDF123   [24]             call    MKTMST          ; Make a temporary string
25D9: CDC327   [41]             call    MAKINT          ; Make it integer A
25DC: 2AA681   [57]             ld      HL,(TMPSTR+2)   ; Get address of string
25DF: 73       [64]             ld      (HL),E          ; Save character
25E0: C1       [10]     TOPOOL: pop     BC              ; Clean up stack
25E1: C32224   [20]             jp      TSTOPL          ; Temporary string to pool
                        
25E4: CD7327   [17]     LEFT:   call    LFRGNM          ; Get number and ending ")"
25E7: AF       [21]             xor     A               ; Start at first byte in string
25E8: E3       [19]     RIGHT1: ex      (SP),HL         ; Save code string,Get string
25E9: 4F       [23]             ld      C,A             ; Starting position in string
25EA: E5       [11]     MID1:   push    HL              ; Save string block address
25EB: 7E       [18]             ld      A,(HL)          ; Get length of string
25EC: B8       [22]             cp      B               ; Compare with number given
25ED: DAF225   [32|32]          jp      C,ALLFOL        ; All following bytes required
25F0: 78       [36]             ld      A,B             ; Get new length
25F1: 11                        defb    $11             ; Skip "ld C,0"
25F2: 0E00     [ 7]     ALLFOL: ld      C,$00           ; First byte of string
25F4: C5       [18]             push    BC              ; Save position in string
25F5: CD5B24   [35]             call    TESTR           ; See if enough string space
25F8: C1       [45]             pop     BC              ; Get position in string
25F9: E1       [55]             pop     HL              ; Restore string block address
25FA: E5       [66]             push    HL              ; And re-save it
25FB: 23       [72]             inc     HL
25FC: 23       [78]             inc     HL
25FD: 46       [85]             ld      B,(HL)          ; Get LSB of address
25FE: 23       [91]             inc     HL
25FF: 66       [98]             ld      H,(HL)          ; Get MSB of address
2600: 68       [102]            ld      L,B             ; HL = address of string
2601: 0600     [109]            ld      B,$00           ; BC = starting address
2603: 09       [120]            add     HL,BC           ; Point to that byte
2604: 44       [124]            ld      B,H             ; BC = source string
2605: 4D       [128]            ld      C,L
2606: CDF423   [145]            call    CRTMST          ; Create a string entry
2609: 6F       [149]            ld      L,A             ; Length of new string
260A: CD7825   [166]            call    TOSTRA          ; Move string to string area
260D: D1       [176]            pop     DE              ; Clear stack
260E: CD8925   [193]            call    GSTRDE          ; Move to string pool if needed
2611: C32224   [203]            jp      TSTOPL          ; Temporary string to pool
                        
                        
                        ; INSTR statement - look for a string inside another string
                        ; usage: INSTR(A$,B$) -> search for B$ into A$
                        ; return 0 if B$ is not contained into A$ or LEN(A$)<LEN(B$)
                        ; return 1~255 to indicate the starting position of B$ into A$
                        ; ex.: INSTR("HELLO","LO") returns 4
81DC:                   LNS1    equ     TMPBFR1
81DE:                   ADRS1   equ     TMPBFR2
81E0:                   LNS2    equ     TMPBFR3
81E2:                   ADRS2   equ     TMPBFR4
81E4:                   PT      equ     VIDEOBUFF
81E6:                   PT1     equ     VIDEOBUFF+2
81E8:                   PT2     equ     VIDEOBUFF+4
81EA:                   TP      equ     VIDEOBUFF+6
81EC:                   TF      equ     VIDEOBUFF+8
2614: CD9418   [17]     INSTR:  call    CHKSYN          ; make sure "(" follows
2617: 28                        defb    '('
2618: 2B       [23]             dec     HL              ; dec 'cause GETCHR increments
2619: CDB71A   [40]             call    GETCHR          ; check if something follows
261C: CAB215   [50|50]          jp      Z,SNERR         ; if nothing else, raise a syntax error
261F: CD4C1F   [67]             call    EVAL            ; Evaluate expression
2622: CD3E1F   [84]             call    TSTSTR          ; Make sure it's a string
2625: 22E481   [100]            ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
2628: CD8525   [117]            call    GSTRCU          ; check that a string follows
262B: CD972D   [134]            call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
262E: ED53DC81 [154]            ld      (LNS1),DE       ; store values into
2632: ED43DE81 [174]            ld      (ADRS1),BC      ; temp buffers
2636: 2AE481   [190]            ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
2639: CD9418   [207]            call    CHKSYN          ; Make sure ',' follows
263C: 2C                        defb    ','
263D: 2B       [213]            dec     HL              ; dec 'cause GETCHR increments
263E: CDB71A   [230]            call    GETCHR          ; check if something follows
2641: CAB215   [240|240]        jp      Z,SNERR         ; if nothing else, raise a syntax error
2644: CD4C1F   [257]            call    EVAL            ; Evaluate expression
2647: CD3E1F   [274]            call    TSTSTR          ; Make sure it's a string
264A: 22E481   [290]            ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
264D: CD8525   [307]            call    GSTRCU          ; check that a string follows
2650: CD972D   [324]            call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
2653: ED53E081 [344]            ld      (LNS2),DE       ; store values into
2657: ED43E281 [364]            ld      (ADRS2),BC      ; temp buffers
265B: 2AE481   [380]            ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
265E: CD9418   [397]            call    CHKSYN          ; make sure ")" follows
2661: 29                        defb    ')'
2662: E5       [408]            push    HL              ; store current code string pointer (the point after the ")" ) ...
2663: FDE1     [422]            pop     IY              ; ...into IY
2665: AF       [426]            xor     A               ; reset 10 RAM cells
2666: 060A     [433]            ld      B,$0A           ; (INSTR registers)
2668: 21E481   [443]            ld      HL,PT           ; first cell
266B: 77       [ 7]     EMPTINS:ld      (HL),A          ; reset cell
266C: 23       [13]             inc     HL              ; next cell
266D: 10FC     [21|26]          djnz    EMPTINS         ; repeat
266F: ED5BE081 [41]             ld      DE,(LNS2)       ; load len(S2) into DE
2673: 2ADC81   [57]             ld      HL,(LNS1)       ; load len(S1) into HL
2676: CD153E   [74]             call    CMP16           ; check that len(S1)>=len(S2)
2679: DAEE26   [84|84]          jp      C,RZINSTR       ; if len(S2)>len(S1) then return 0
267C: AF       [ 4]     RPTINST:xor     A               ; reset...
267D: 32EA81   [17]             ld      (TP),A          ; ...TP...
2680: 32EC81   [30]             ld      (TF),A          ; ...and TF
2683: ED4BE481 [50]             ld      BC,(PT)         ; pointer to S1
2687: 2ADE81   [66]             ld      HL,(ADRS1)      ; first cell of S1
268A: 09       [77]             add     HL,BC           ; get current position into RAM
268B: 7E       [84]             ld      A,(HL)          ; load S1(PT)
268C: 2AE281   [100]            ld      HL,(ADRS2)      ; pointer to first char of S2
268F: BE       [107]            cp      (HL)            ; is S1(PT)=S2(0)?
2690: 203A     [114|119]        jr      NZ,CNT1INS      ; no, continue
2692: 3AE481   [127]            ld      A,(PT)          ; load current PT
2695: 32EA81   [140]            ld      (TP),A          ; TP=PT
2698: 32E681   [153]            ld      (PT1),A         ; P1=PT
269B: AF       [157]            xor     A               ; set...
269C: 32E881   [170]            ld      (PT2),A         ; ...PT2=0
269F: 3C       [174]            inc     A               ;
26A0: 32EC81   [187]            ld      (TF),A          ; set TF=1
26A3: ED4BE681 [20]     RP2INST:ld      BC,(PT1)        ; load pointer PT1
26A7: 2ADE81   [36]             ld      HL,(ADRS1)      ; load address of S1
26AA: 09       [47]             add     HL,BC           ; find char of S1 pointed by PT1
26AB: 7E       [54]             ld      A,(HL)          ; load S1(PT1)
26AC: ED4BE881 [74]             ld      BC,(PT2)        ; load pointer PT2
26B0: 2AE281   [90]             ld      HL,(ADRS2)      ; load char of S2 pointed by PT2
26B3: 09       [101]            add     HL,BC           ; find S2(PT2)
26B4: BE       [108]            cp      (HL)            ; is S1(PT1)=S2(PT2)?
26B5: 204C     [115|120]        jr      NZ,CNTZIN       ; no, exit inner loop
26B7: 21E681   [125]            ld      HL,PT1
26BA: 34       [136]            inc     (HL)            ; increment PT1
26BB: 3AE881   [149]            ld      A,(PT2)
26BE: 3C       [153]            inc     A               ; increment PT2
26BF: 32E881   [166]            ld      (PT2),A
26C2: CACC26   [176|176]        jp      Z,CNT1INS       ; if PT2>255 then exit
26C5: 21E081   [186]            ld      HL,LNS2         ; len(S2)
26C8: BE       [193]            cp      (HL)            ; PT2=len(S2)?
26C9: DAA326   [203|203]        jp      C,RP2INST       ; no (PT2<len(S2) - repeat
26CC: 3AEC81   [13]     CNT1INS:ld      A,(TF)          ; check TF
26CF: A7       [17]             and     A               ; TF=0? (clears also Carry for next SBC)
26D0: 201C     [24|29]          jr      NZ,RZINSTR      ; no, exit
26D2: 2ADC81   [40]             ld      HL,(LNS1)       ; load len(S1)
26D5: ED4BE081 [60]             ld      BC,(LNS2)       ; load len(S2)
26D9: ED42     [75]             sbc     HL,BC           ; HL=len(S1)-len(S2)
26DB: ED5BE481 [95]             ld      DE,(PT)         ; load pointer
26DF: 1C       [99]             inc     E               ; PT=PT+1
26E0: ED53E481 [119]            ld      (PT),DE         ; store new value
26E4: EB       [123]            ex      DE,HL           ; invert registers
26E5: CD153E   [140]            call    CMP16           ; check if PT>len(S1)-len(S2)
26E8: DA7C26   [150|150]        jp      C,RPTINST       ; repeat if <
26EB: CA7C26   [160|160]        jp      Z,RPTINST       ; repeat if =
26EE: 3AEC81   [13]     RZINSTR:ld      A,(TF)          ; current value of TF
26F1: A7       [17]             and     A               ; is it 0?
26F2: CAF926   [27|27]          jp      Z,LVINSTR       ; yes, return 0
26F5: 3AEA81   [40]             ld      A,(TP)          ; return TP...
26F8: 3C       [44]             inc     A               ; ...incremented by 1
26F9: E1       [10]     LVINSTR:pop     HL              ; drop original return point
26FA: FDE5     [25]             push    IY              ; load current string address from IY into stack
26FC: 112520   [35]             ld      DE,RETNUM       ; Address of Return number from function...
26FF: D5       [46]             push    DE              ; ...saved on stack
2700: C33323   [56]             jp      PASSA           ; return TP
2703: AF       [ 4]     CNTZIN: xor     A               ; set...
2704: 32EC81   [17]             ld      (TF),A          ; TF=0
2707: C3CC26   [27]             jp      CNT1INS         ; continue
                        
                        
270A: CD7327   [17]     RIGHT:  call    LFRGNM          ; Get number and ending ")"
270D: D1       [27]             pop     DE              ; Get string length
270E: D5       [38]             push    DE              ; And re-save
270F: 1A       [45]             ld      A,(DE)          ; Get length
2710: 90       [49]             sub     B               ; Move back N bytes
2711: C3E825   [59]             jp      RIGHT1          ; Go and get sub-string
                        
2714: EB       [ 4]     MID:    ex      DE,HL           ; Get code string address
2715: 7E       [11]             ld      A,(HL)          ; Get next byte ',' or ")"
2716: CD7827   [28]             call    MIDNUM          ; Get number supplied
2719: 04       [32]             inc     B               ; Is it character zero?
271A: 05       [36]             dec     B
271B: CA821B   [46|46]          jp      Z,FCERR         ; Yes - Error
271E: C5       [57]             push    BC              ; Save starting position
271F: 1EFF     [64]             ld      E,$FF           ; All of string
2721: FE29     [71]             cp      ')'             ; Any length given?
2723: CA2D27   [81|81]          jp      Z,RSTSTR        ; No - Rest of string
2726: CD9418   [98]             call    CHKSYN          ; Make sure ',' follows
2729: 2C                        defb    ','
272A: CDC027   [115]            call    GETINT          ; Get integer 0-255
272D: CD9418   [17]     RSTSTR: call    CHKSYN          ; Make sure ")" follows
2730: 29                        defb    ')'
2731: F1       [27]             pop     AF              ; Restore starting position
2732: E3       [46]             ex      (SP),HL         ; Get string,save code string
2733: 01EA25   [56]             ld      BC,MID1         ; Continuation of MID$ routine
2736: C5       [67]             push    BC              ; Save for return
2737: 3D       [71]             dec     A               ; Starting position-1
2738: BE       [78]             cp      (HL)            ; Compare with length
2739: 0600     [85]             ld      B,$00           ; Zero bytes length
273B: D0       [90|96]          ret     NC              ; Null string if start past end
273C: 4F       [94]             ld      C,A             ; Save starting position-1
273D: 7E       [101]            ld      A,(HL)          ; Get length of string
273E: 91       [105]            sub     C               ; Subtract start
273F: BB       [109]            cp      E               ; Enough string for it?
2740: 47       [113]            ld      B,A             ; Save maximum length available
2741: D8       [118|124]        ret     C               ; Truncate string if needed
2742: 43       [122]            ld      B,E             ; Set specified length
2743: C9       [132]            ret                     ; Go and create string
                        
2744: CDB825   [17]     VAL:    call    GETLEN          ; Get length of string
2747: CA172B   [27|27]          jp      Z,RESZER        ; Result zero
274A: 5F       [31]             ld      E,A             ; Save length
274B: 23       [37]             inc     HL
274C: 23       [43]             inc     HL
274D: 7E       [50]             ld      A,(HL)          ; Get LSB of address
274E: 23       [56]             inc     HL
274F: 66       [63]             ld      H,(HL)          ; Get MSB of address
2750: 6F       [67]             ld      L,A             ; HL = String address
2751: E5       [78]             push    HL              ; Save string address
2752: 19       [89]             add     HL,DE
2753: 46       [96]             ld      B,(HL)          ; Get end of string+1 byte
2754: 72       [103]            ld      (HL),D          ; Zero it to terminate
2755: E3       [122]            ex      (SP),HL         ; Save string end,get start
2756: C5       [133]            push    BC              ; Save end+1 byte
2757: 7E       [140]            ld      A,(HL)          ; Get starting byte
2758: FE24     [147]            cp      '$'             ; Hex number indicated? [function added]
275A: C26227   [157|157]        jp      NZ,VAL1
275D: CD4E3D   [174]            call    HEXTFP          ; Convert Hex to FPREG
2760: 180D     [186]            jr      VAL3
2762: FE25     [ 7]     VAL1:   cp      '%'             ; Binary number indicated? [function added]
2764: C26C27   [17|17]          jp      NZ,VAL2
2767: CDBE3D   [34]             call    BINTFP          ; Convert Bin to FPREG
276A: 1803     [46]             jr      VAL3
276C: CD4F2E   [17]     VAL2:   call    ASCTFP          ; Convert ASCII string to FP
276F: C1       [10]     VAL3:   pop     BC              ; Restore end+1 byte
2770: E1       [20]             pop     HL              ; Restore end+1 address
2771: 70       [27]             ld      (HL),B          ; Put back original byte
2772: C9       [37]             ret
                        
2773: EB       [ 4]     LFRGNM: ex      DE,HL           ; Code string address to HL
2774: CD9418   [21]             call    CHKSYN          ; Make sure ")" follows
2777: 29                        defb    ')'
2778: C1       [10]     MIDNUM: pop     BC              ; Get return address
2779: D1       [20]             pop     DE              ; Get number supplied
277A: C5       [31]             push    BC              ; Re-save return address
277B: 43       [35]             ld      B,E             ; Number to B
277C: C9       [45]             ret
                        
277D: CDC327   [17]     INP:    call    MAKINT          ; Make it integer A
2780: 32A080   [30]             ld      (INPORT),A      ; Set input port
2783: CD9F80   [47]             call    INPSUB          ; Get input from port
2786: C33323   [57]             jp      PASSA           ; Return integer A
                        
2789: CDAD27   [17]     POUT:   call    SETIO           ; Set up port number
278C: C36780   [27]             jp      OUTSUB          ; Output data and return
                        
278F: CDAD27   [17]     WAIT:   call    SETIO           ; Set up port number
2792: F5       [28]             push    AF              ; Save AND mask
2793: 1E00     [35]             ld      E,$00           ; Assume zero if none given
2795: 2B       [41]             dec     HL              ; dec 'cos GETCHR INCs
2796: CDB71A   [58]             call    GETCHR          ; Get next character
2799: CAA327   [68|68]          jp      Z,NOXOR         ; No XOR byte given
279C: CD9418   [85]             call    CHKSYN          ; Make sure ',' follows
279F: 2C                        defb    ','
27A0: CDC027   [102]            call    GETINT          ; Get integer 0-255 to XOR with
27A3: C1       [10]     NOXOR:  pop     BC              ; Restore AND mask
27A4: CD9F80   [17]     WAITLP: call    INPSUB          ; Get input
27A7: AB       [21]             xor     E               ; Flip selected bits
27A8: A0       [25]             and     B               ; Result non-zero?
27A9: CAA427   [35|35]          jp      Z,WAITLP        ; No = keep waiting
27AC: C9       [45]             ret
                        
27AD: CDC027   [17]     SETIO:  call    GETINT          ; Get integer 0-255
27B0: 32A080   [30]             ld      (INPORT),A      ; Set input port
27B3: 326880   [43]             ld      (OTPORT),A      ; Set output port
27B6: CD9418   [60]             call    CHKSYN          ; Make sure ',' follows
27B9: 2C                        defb    ','
27BA: C3C027   [70]             jp      GETINT          ; Get integer 0-255 and return
                        
27BD: CDB71A   [17]     FNDNUM: call    GETCHR          ; Get next character
27C0: CD3A1F   [17]     GETINT: call    GETNUM          ; Get a number from 0 to 255
27C3: CD671B   [17]     MAKINT: call    DEPINT          ; Make sure value 0 - 255
27C6: 7A       [21]             ld      A,D             ; Get MSB of number
27C7: B7       [25]             or      A               ; Zero?
27C8: C2821B   [35|35]          jp      NZ,FCERR        ; No - Error
27CB: 2B       [41]             dec     HL              ; dec 'cos GETCHR INCs
27CC: CDB71A   [58]             call    GETCHR          ; Get next character
27CF: 7B       [62]             ld      A,E             ; Get number to A
27D0: C9       [72]             ret
                        
                        
                        ; activate a Non-Maskable Interrupt hooked to VDP interrupt signal
27D1: CD3A1F   [17]     NMI:    call    GETNUM          ; Get memory address
27D4: CD6D1B   [34]             call    DEINT           ; get integer -32768 to 32767
27D7: 7B       [38]             ld      A,E             ; check if address is 0
27D8: B2       [42]             or      D
27D9: 2011     [49|54]          jr      NZ,NM1          ; no, so jump over
27DB: F3       [ 4]     DISNMI: di                      ; disable INTs
27DC: CD0828   [21]             call    NMIDINT         ; disable VDP INT
27DF: E5       [32]             push    HL              ; store HL
27E0: 21ED45   [42]             ld      HL,$45ED        ; these are the op-codes for "RETN"
27E3: 226180   [58]             ld      (NMIUSR),HL     ; store RETN
27E6: AF       [62]             xor     A
27E7: 326380   [75]             ld      (NMIUSR+2),A    ; "NOP"
27EA: 1811     [87]             jr      NMI2            ; execute the last part of code
27EC: E5       [11]     NM1:    push    HL              ; store current HL
27ED: EB       [15]             ex      DE,HL           ; move address argument into HL
27EE: F3       [19]             di                      ; disable INTs
27EF: CD0828   [36]             call    NMIDINT         ; disable VDP INT, if enabled
27F2: 3EC3     [43]             ld      A,$C3           ; "jp" instruction
27F4: 326180   [56]             ld      (NMIUSR),A      ; store it
27F7: 226280   [72]             ld      (NMIUSR+1),HL   ; store address
27FA: CD0128   [89]             call    NMIEINT         ; re-enable VDP INT
27FD: FB       [ 4]     NMI2:   ei                      ; re-enable INTS
27FE: 00       [ 8]             nop                     ; wait for INTs
27FF: E1       [18]             pop    HL               ; retrieve HL
2800: C9       [28]             ret                     ; return to caller
                        ; enable VDP INT
2801: CD1728   [17]     NMIEINT:call    NMIVR1          ; load default VReg #1 setting
2804: F620     [24]             or      %00100000       ; enable VDP INT
2806: 1803     [36]             jr      NMIINT          ; rest of code is shared
                        ; disable VDP INT
2808: CD1728   [17]     NMIDINT:call    NMIVR1          ; load default VReg #1 setting
280B: D5       [11]     NMIINT: push    DE              ; store DE
280C: 5F       [15]             ld      E,A             ; move value into E
280D: 3E01     [22]             ld      A,$01           ; VREG #1
280F: F3       [26]             di                      ; disable INTs
2810: CD5E06   [43]             call    WRITE_VREG      ; disable VDP INT
2813: FB       [47]             ei                      ; re-enable INTs
2814: 00       [51]             nop                     ; wait for INTs being enabled
2815: D1       [61]             pop     DE              ; retrieve DE
2816: C9       [71]             ret                     ; return to caller
                        
                        ; load VREG #1 setting for current screen mode and return it into A
2817: E5       [11]     NMIVR1: push    HL              ; store HL
2818: D5       [22]             push    DE              ; store DE
2819: 3ACD81   [35]             ld      A,(SCR_MODE)    ; check screen mode
281C: 87       [39]             add     A,A             ; multiply A by 8...
281D: 87       [43]             add     A,A             ; ...so that reg. A can points..
281E: 87       [47]             add     A,A             ; to the correct settings
281F: 3C       [51]             inc     A               ; need to change VREG 1
2820: 5F       [55]             ld      E,A             ; copy A into E
2821: 1600     [62]             ld      D,$00           ; reset D
2823: 21740A   [72]             ld      HL,VDPMODESET   ; pointer to register #1 setting...
2826: 19       [83]             add     HL,DE           ; ...for current screen mode
2827: 7E       [90]             ld      A,(HL)          ; load current setting
2828: D1       [100]            pop     DE              ; retrieve DE
2829: E1       [110]            pop     HL              ; retrieve HL
282A: C9       [120]            ret                     ; return to caller
                        
                        ; execute a machine language routine, eventually passing a param into A
282B: CD3A1F   [17]     SYS:    call    GETNUM          ; Get memory address
282E: CD6D1B   [34]             call    DEINT           ; Get integer -32768 to 32767
2831: ED53DE81 [54]             ld      (TMPBFR2),DE    ; store user routine's address
2835: AF       [58]             xor     A               ; reset A
2836: 32DC81   [71]             ld      (TMPBFR1),A     ; store into temp buffer
2839: 2B       [77]             dec     HL              ; dec 'cos GETCHR INCs
283A: CDB71A   [94]             call    GETCHR          ; check next character
283D: 280A     [101|106]        jr      Z,NOSYSPR       ; jump if nothing follows
283F: CD9418   [118]            call    CHKSYN          ; Make sure ',' follows
2842: 2C                        defb    ','
2843: CDC027   [135]            call    GETINT          ; get byte value (0~255) if something follows
2846: 32DC81   [148]            ld      (TMPBFR1),A     ; store into temp buffer
2849: 3ADC81   [13]     NOSYSPR:ld      A,(TMPBFR1)     ; recover A
284C: ED5BDE81 [33]             ld      DE,(TMPBFR2)    ; recover user routine's address
2850: E5       [44]             push    HL              ; save code string address
2851: EB       [48]             ex      DE,HL           ; move user routine's address into HL
2852: 115728   [58]             ld      DE,SYSRET       ; set point of return after the user routine
2855: D5       [69]             push    DE              ; store into stack
2856: E9       [73]             jp      (HL)            ; call user routine
2857: E1       [10]     SYSRET: pop     HL              ; retrieve code string address
2858: C9       [20]             ret                     ; return to caller
                        
                        
                        ; read the contents of a byte from RAM
2859: CD6D1B   [17]     PEEK:   call    DEINT           ; Get memory address into DE
285C: 1A       [24]             ld      A,(DE)          ; Read value of memory cell
285D: C33323   [34]             jp      PASSA           ; Return into A
                        
                        ; read the contents of a byte from VRAM
2860: CD6D1B   [17]     VPEEK:  call    DEINT           ; Get VRAM address into DE
2863: EB       [21]             ex      DE,HL           ; Copy param into HL
2864: F3       [25]             di                      ; Disable interrupts
2865: CD3406   [42]             call    READ_VIDEO_LOC  ; Read data from VRAM at address HL
2868: FB       [46]             ei                      ; Re-enable interrupts
2869: EB       [50]             ex      DE,HL           ; Restore HL
286A: C33323   [60]             jp      PASSA           ; Return value into A
                        
                        ; recover params for POKE/VPOKE commands
                        ; returns address into DE and byte to be written into A
286D: CD3A1F   [17]     PKEPRMS:call    GETNUM          ; Get memory address
2870: CD6D1B   [34]             call    DEINT           ; Get integer -32768 to 32767
2873: ED53DC81 [54]             ld      (TMPBFR1),DE    ; Store DE into a temp. buffer
2877: CD9418   [71]             call    CHKSYN          ; Make sure ',' follows
287A: 2C                        defb    ','
287B: CDC027   [88]             call    GETINT          ; Get integer 0-255
287E: ED5BDC81 [108]            ld      DE,(TMPBFR1)    ; Restore memory address
2882: C9       [118]            ret                     ; Return to caller
                        
                        ; write a byte into SRAM
2883: CD6D28   [17]     POKE:   call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
2886: 12       [24]             ld      (DE),A          ; Load it into memory
2887: C9       [34]             ret
                        
                        ; write a byte into VRAM
2888: CD6D28   [17]     VPOKE:  call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
288B: EB       [21]             ex      DE,HL           ; Copy address into HL
288C: F3       [25]             di                      ; Disable interrupts
288D: CD4906   [42]             call    WRITE_VIDEO_LOC ; write data into VRAM at address HL
2890: FB       [46]             ei                      ; Re-enable interrupts
2891: EB       [50]             ex      DE,HL           ; Restore HL
2892: C9       [60]             ret                     ; Return to caller
                        
                        ; position the cursor at a specific X,Y location onto screen
2893: CDC027   [17]     LOCATE: call    GETINT          ; get the first param into A
2896: E5       [28]             push    HL              ; store HL
2897: 21CB81   [38]             ld      HL,SCR_SIZE_W   ; load address of screen width
289A: 5E       [45]             ld      E,(HL)          ; load screen width into E
289B: E1       [55]             pop     HL              ; restore HL
289C: BB       [59]             cp      E               ; compare witdh with param
289D: D2821B   [69|69]          jp      NC,FCERR        ; value over the width of the screen, exit with Illegal F.C. error
28A0: 32DC81   [82]             ld      (TMPBFR1),A     ; Store X into a temp. buffer
28A3: CD9418   [99]             call    CHKSYN          ; Make sure ',' follows
28A6: 2C                        defb    ','
28A7: CDC027   [116]            call    GETINT          ; Get the second param into A
28AA: E5       [127]            push    HL              ; store HL
28AB: 21CC81   [137]            ld      HL,SCR_SIZE_H   ; load address of screen width
28AE: 5E       [144]            ld      E,(HL)          ; load screen width into A
28AF: E1       [154]            pop     HL              ; restore HL
28B0: BB       [158]            cp      E               ; compare witdh with param
28B1: D2821B   [168|168]        jp      NC,FCERR        ; value over the height of the screen, exit with Illegal F.C. error
28B4: 32D481   [181]            ld      (SCR_CUR_NY),A  ; store new Y
28B7: 3ADC81   [194]            ld      A,(TMPBFR1)     ; recover the new X
28BA: 32D381   [207]            ld      (SCR_CUR_NX),A  ; store new X
28BD: E5       [218]            push    HL              ; store HL
28BE: F3       [222]            di                      ; disable INTs
28BF: CD7A06   [239]            call    MOVCRS          ; move cursor to new location
28C2: FB       [243]            ei                      ; re-enable INTs
28C3: E1       [253]            pop     HL              ; restore HL
28C4: C9       [263]            ret                     ; return to caller
                        
                        ; write a byte into one of the PSG registers
28C5: CDC027   [17]     SREG:   call    GETINT          ; Get register number back into A
28C8: FE10     [24]             cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
28CA: D2821B   [34|34]          jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
28CD: 32DC81   [47]             ld      (TMPBFR1),A     ; Store A into a temp. buffer
28D0: CD9418   [64]             call    CHKSYN          ; Make sure ',' follows
28D3: 2C                        defb    ','
28D4: CDC027   [81]             call    GETINT          ; get second value (0-255), returned into A
28D7: 5F       [85]             ld      E,A             ; store value into E
28D8: 3ADC81   [98]             ld      A,(TMPBFR1)     ; recover VDP register and store into D
28DB: F3       [102]            di                      ; disable INTs
28DC: 0E40     [109]            ld      C,PSG_REG       ; output port to access PSG registers
28DE: ED79     [121]            out     (C),A           ; send register # to PSG
28E0: 0E41     [128]            ld      C,PSG_DAT       ; output port to send data to PSG
28E2: ED59     [140]            out     (C),E           ; send byte to write into selected register
28E4: FB       [144]            ei                      ; re-enable INTs
28E5: C9       [154]            ret                     ; return to caller
                        
                        ; VOLUME ch,vol
                        ; set the volume for the audio channels
                        ; "ch" is 1~3 for corresponding channel, or 0 for all; "vol" is 0~15 (0=OFF, 15=MAX)
28E6: CDC027   [17]     VOLUME: call    GETINT          ; get integer 0-255 (recover channel)
28E9: FE04     [24]             cp      $04             ; check if it's in the range 0~3
28EB: D2821B   [34|34]          jp      NC,FCERR        ; if not, exit with Illegal function call error
28EE: 32DC81   [47]             ld      (TMPBFR1),A     ; Store A into a temp. buffer
28F1: CD9418   [64]             call    CHKSYN          ; Make sure ',' follows
28F4: 2C                        defb    ','
28F5: CDC027   [81]             call    GETINT          ; get integer 0-255 (recover channel)
28F8: FE10     [88]             cp      $10             ; check if it's in the range 0~15
28FA: D2821B   [98|98]          jp      NC,FCERR        ; if not, exit with Illegal funcion call
28FD: 57       [102]            ld      D,A             ; store volume into D
28FE: 3ADC81   [115]            ld      A,(TMPBFR1)     ; retrieve channel
2901: A7       [119]            and     A               ; is it 0? (0=every channel)
2902: 2010     [126|131]        jr      NZ,VOLCH        ; no, jump over
2904: 0603     [133]            ld      B,$03           ; yes, set every channel
2906: 1E08     [140]            ld      E,$08           ; register volume of first channel
2908: 0E40     [ 7]     RPVOLCG:ld      C,PSG_REG       ; PSG register port
290A: ED59     [19]             out     (C),E           ; set register #
290C: 0E41     [26]             ld      C,PSG_DAT       ; PSG data port
290E: ED51     [38]             out     (C),D           ; send volume
2910: 1C       [42]             inc     E               ; next register
2911: 10F5     [50|55]          djnz    RPVOLCG         ; repeat for each channel
2913: C9       [60]             ret                     ; return to caller
2914: 0E40     [ 7]     VOLCH:  ld      C,PSG_REG       ; PSG register port
2916: C607     [14]             add     $07             ; add 7 to A so that we have the correct register (1->8, 2->9, 3->10)
2918: ED79     [26]             out     (C),A           ; set register
291A: 0E41     [33]             ld      C,PSG_DAT       ; PSG data port
291C: ED51     [45]             out     (C),D           ; send volume level
291E: C9       [55]             ret                     ; return to caller
                        
                        ; SOUND ch,tone,dur
                        ; play a tone or noise of "tone" frequency from selected channel "ch" for duration "dur"
                        ; "ch" is 1~6 (0=means sound OFF,1~3 for tone, 4~6 for noise) / "tone" is 1~4,095 (0=means no tone) /
                        ; "dur" is 1~16383 h.o.s.,0.001~163s (0=means non-stop tone)
291F: CDC027   [17]     SOUND:  call    GETINT          ; get integer 0-255 (recover channel)
2922: A7       [21]             and     A               ; is it zero?
2923: 2008     [28|33]          jr      NZ,CTSNDC       ; no, continue with checking of params
2925: E5       [39]             push    HL              ; store HL
2926: F3       [43]             di                      ; disable INTs
2927: CDE60B   [60]             call    CLRPSGREGS      ; yes, it's zero, so reset PSG registers to shut down every sound
292A: FB       [64]             ei                      ; re-enable INTs
292B: E1       [74]             pop     HL              ; retrieve HL
292C: C9       [84]             ret                     ; return to caller
292D: 32DC81   [13]     CTSNDC: ld      (TMPBFR1),A     ; no, continue by storing A into a temp. buffer
2930: FE04     [20]             cp      $04             ; is channel >3?
2932: D2B229   [30|30]          jp      NC,NOISUP       ; Yes - check to see if it's a noise channel
2935: CD9418   [47]             call    CHKSYN          ; No, continue checking by making sure ',' follows
2938: 2C                        defb    ','
2939: CD3A1F   [64]             call    GETNUM          ; Get tone frequency
293C: CD6D1B   [81]             call    DEINT           ; Get integer -32768 to 32767
293F: ED53DE81 [101]            ld      (TMPBFR2),DE    ; Store frequency
2943: CD9418   [118]            call    CHKSYN          ; Make sure ',' follows
2946: 2C                        defb    ','
2947: CD3A1F   [135]            call    GETNUM          ; Get duration
294A: CD6D1B   [152]            call    DEINT           ; Get integer -32768 to 32767
294D: ED53E081 [172]            ld      (TMPBFR3),DE    ; Store duration
                                                        ; CHECK CHANNEL
2951: 3ADC81   [185]            ld      A,(TMPBFR1)     ; recover channel
2954: FE01     [192]            cp      $01             ; is channel <1?
2956: DA821B   [202|202]        jp      C,FCERR         ; Yes - Illegal function call error
                                                        ; CHECK FREQUENCY
2959: ED5BDE81 [222]            ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
295D: 7A       [226]            ld      A,D             ; move D into A and check if it is in the range 0~4095...
295E: FE10     [233]            cp      $10             ; ...so D must not be greater than $0F (15)
2960: D2821B   [243|243]        jp      NC,FCERR        ; if not in the range, exit with an Illegal function call error
                                                        ; CHECK DURATION
2963: ED5BE081 [263]            ld      DE,(TMPBFR3)    ; restore duration from temp buffer
2967: 7A       [267]            ld      A,D             ; check if it is in the range 0~16383...
2968: E6C0     [274]            and     $C0             ; ...(15th & 14th bits must not be set)
296A: C2821B   [284|284]        jp      NZ,FCERR        ; if not in the range, exit with an Illegal function call error
                                                        ;
                                                        ; SET TONE:
                                                        ; let's start by setting up the channel
296D: 3ADC81   [297]            ld      A,(TMPBFR1)     ; restore channel value
2970: FE03     [304]            cp      $03             ; is it 3?
2972: 2002     [311|316]        jr      NZ,SND1         ; no, jump over
2974: 3E04     [318]            ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
2976: 2F       [ 4]     SND1:   cpl                     ; complement of A - this is used later to set on the channel into the mixer
2977: CDFF29   [21]             call    WRTSND          ; enable line into mixer of channel stored in A
                                                        ; SET FREQUENCY
                                                        ; we simply get frequency and subtract from 4096. The result
                                                        ; is put into register pair of the corresponding freq tone channel
297A: ED5BDE81 [41]             ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
297E: E5       [52]             push    HL              ; store HL (it will be used by the subroutine)
297F: 210010   [62]             ld      HL,$1000        ; load 4096 into HL
2982: A7       [66]             and     A               ; reset C flag
2983: ED52     [81]             sbc     HL,DE           ; subtract freq from HL - now the frequency is inverted, so we will send the low as high and vice-versa
2985: 3ADC81   [94]             ld      A,(TMPBFR1)     ; restore channel value
2988: 3D       [98]             dec     A               ; set A into the range 0~2
2989: 87       [102]            add     A,A             ; double A to find the register pair that correspond to the channel (A->0,1 / B->2,3, C->4,5)
298A: 0E40     [109]            ld      C,PSG_REG       ; PSG register port
298C: ED79     [121]            out     (C),A           ; select first register of the pair
298E: 0E41     [128]            ld      C,PSG_DAT       ; PSG data port
2990: ED69     [140]            out     (C),L           ; send high byte
2992: 0E40     [147]            ld      C,PSG_REG       ; PSG register support
2994: 3C       [151]            inc     A               ; second register of the pair
2995: ED79     [163]            out     (C),A           ; select register
2997: 0E41     [170]            ld      C,PSG_DAT       ; PSG data port
2999: ED61     [182]            out     (C),H           ; send low byte
299B: ED5BE081 [202]            ld      DE,(TMPBFR3)    ; recover duration
299F: 3ADC81   [215]            ld      A,(TMPBFR1)     ; recover channel value
29A2: 3D       [219]            dec     A               ; set channel into the range 0~2
29A3: 87       [223]            add     A,A             ; double A to find the correct offset
29A4: 211082   [233]            ld      HL,CHASNDDTN    ; set duration into...
29A7: 85       [237]            add     A,L             ; ...the proper...
29A8: 3001     [244|249]        jr      NC,SNDOVR       ; (is there a rest? no, jump over
29AA: 24       [248]            inc     H               ; yes, increment H)
29AB: 6F       [ 4]     SNDOVR: ld      L,A             ; ...register pair...
29AC: 7323722B [30]             ld      (HL),DE         ; ...and store the value
29B0: E1       [40]             pop     HL              ; retrieve HL
29B1: C9       [50]             ret                     ; Return to caller
29B2: FE07     [ 7]     NOISUP: cp      $07             ; is channel in range 4 to 6 (for a noise)?
29B4: D2821B   [17|17]          jp      NC,FCERR        ; no, so ILLEGAL FUNCTION CALL
29B7: CD9418   [34]             call    CHKSYN          ; yes, continue checking by making sure ',' follows
29BA: 2C                        defb    ','
29BB: CDC027   [51]             call    GETINT          ; get integer 0-255 (frequency)
29BE: FE20     [58]             cp      $20             ; make sure it's in range 0~31
29C0: D2821B   [68|68]          jp      NC,FCERR        ; no, so Illegal function call
29C3: 32DE81   [81]             ld      (TMPBFR2),A     ; store freq.
29C6: 2B       [87]             dec     HL              ; dec 'cos GETCHR INCs
29C7: CDB71A   [104]            call    GETCHR          ; check that nothing follows
29CA: C2B215   [114|114]        jp      NZ,SNERR        ; error if no empty line
29CD: 3ADE81   [127]            ld      A,(TMPBFR2)     ; retrieve freq.
29D0: 5F       [131]            ld      E,A             ; store freq into E
29D1: 3ADC81   [144]            ld      A,(TMPBFR1)     ; retrieve channel
29D4: D603     [151]            sub     $03             ; subtract 3 to get channel in range 1~3
29D6: FE03     [158]            cp      $03             ; is it 3?
29D8: 2002     [165|170]        jr      NZ,NOS1         ; no, jump over
29DA: 3E04     [172]            ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
29DC: 87       [ 4]     NOS1:   add     A,A
29DD: 87       [ 8]             add     A,A
29DE: 87       [12]             add     A,A             ; let's move A 3 bits to left
29DF: 47       [16]             ld      B,A             ; store channel into B
29E0: 7B       [20]             ld      A,E             ; check if
29E1: A7       [24]             and     A               ; freq is 0 (means that noise reproduction must be halted)
29E2: F3       [28]             di                      ; disable INts
29E3: 200A     [35|40]          jr      NZ,NOS2         ; no, so jump over
29E5: 3E07     [42]             ld      A,$07           ; mixer register
29E7: CD340C   [59]             call    SETSNDREG       ; set mixer register
29EA: ED78     [71]             in      A,(C)           ; load current mixer value
29EC: B0       [75]             or      B               ; disable noise
29ED: 1819     [87]             jr      NOS3            ; continue over
29EF: 78       [ 4]     NOS2:   ld      A,B             ; recover channel
29F0: 2F       [ 8]             cpl                     ; complement of A - this is used to set on the channel into the mixer
29F1: CDFF29   [25]             call    WRTSND          ; enable line into mixer of channel stored in A
29F4: 3E06     [32]             ld      A,$06           ; write into noise register
29F6: CD340C   [49]             call    SETSNDREG       ; set register into PSG
29F9: 7B       [53]             ld      A,E             ; load value for noise frequency
29FA: CD390C   [70]             call    WRTSNDREG       ; write data into register $06
29FD: FB       [74]             ei                      ; re-enable INTs
29FE: C9       [84]             ret
                                ; enable line into mixer of channel stored in A
29FF: 47       [ 4]     WRTSND: ld      B,A             ; move channel into B
2A00: 3E07     [11]             ld      A,$07           ; mixer register
2A02: CD340C   [28]             call    SETSNDREG       ; set mixer register
2A05: ED78     [40]             in      A,(C)           ; load current value
2A07: A0       [44]             and     B               ; set on the channel into the mixer (remember that 0=ON)
                                                        ; example: if channel is A (1), complement of 1 is 254 (11111110). So, 255 (in case
                                                        ; the register is still unchanged after reset) is 11111111 and
                                                        ; 11111111 AND 11111110 is equal to 11111110
                                                        ; 11111001 AND 11111110 is equal to 11111000 (in case channels B & C are ON)
2A08: 47       [ 4]     NOS3:   ld      B,A             ; store new mixer value into B
2A09: 3E07     [11]             ld      A,$07           ; mixer address
2A0B: CD340C   [28]             call    SETSNDREG       ; set register
2A0E: 78       [32]             ld      A,B             ; retrieve new mixer value from B
2A0F: CD390C   [49]             call    WRTSNDREG       ; send new value for the mixer
2A12: FB       [53]             ei                      ; re-enable INTs
2A13: C9       [63]             ret                     ; return to caller
                        
                        ; write a byte into one of the VDP registers
2A14: CDC027   [17]     VREG:   call    GETINT          ; Get register number back into A
2A17: FE08     [24]             cp      $08             ; check if value is equal or greater than 8 (VDP registers are only 8, from 0 to 7)
2A19: D2821B   [34|34]          jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
2A1C: 32DC81   [47]             ld      (TMPBFR1),A     ; Store A into a temp. buffer
2A1F: CD9418   [64]             call    CHKSYN          ; Make sure ',' follows
2A22: 2C                        defb    ','
2A23: CDC027   [81]             call    GETINT          ; get value (0-255)
2A26: 5F       [85]             ld      E,A             ; store value into E
2A27: 3ADC81   [98]             ld      A,(TMPBFR1)     ; recover VDP register and store into A
2A2A: F3       [102]            di                      ; disable INTs
2A2B: CD5E06   [119]            call    WRITE_VREG      ; write value into VDP register
2A2E: FB       [123]            ei                      ; re-enable INTs
2A2F: C9       [133]            ret                     ; return to caller
                        
                        ; read the VDP status register and return it into A
2A30: CD6D1B   [17]     VSTAT:  call    DEINT           ; Get integer -32768 to 32767 (Note: we do NOT use it)
2A33: F3       [21]             di                      ; disable INTs
2A34: CD6906   [38]             call    READ_VSTAT      ; read VDP register status
2A37: FB       [42]             ei                      ; re-enable INTs
2A38: C33323   [52]             jp      PASSA           ; Return integer A
                        
                        ; read from PSG register and return it into A
2A3B: CD6D1B   [17]     SSTAT:  call    DEINT           ; get integer -32768 to 32767
2A3E: 7B       [21]             ld      A,E             ; consider LSB
2A3F: FE10     [28]             cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
2A41: D2821B   [38|38]          jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
2A44: F3       [42]             di                      ; disable INts
2A45: 0E40     [49]             ld      C,PSG_REG       ; output port to set PSG register
2A47: ED79     [61]             out     (C),A           ; send register to read from
2A49: ED78     [73]             in      A,(C)           ; read register's contents and store into A
2A4B: FB       [77]             ei                      ; re-enable INTs
2A4C: C33323   [87]             jp      PASSA           ; return A
                        
                        ; read the temp key buffer and return the value of the current key being pressed
                        ; can wait for the number of 100thds of second before to return
2A4F: CDAD23   [17]     INKEY:  call    IDTEST          ; Test for illegal direct
2A52: CD6D1B   [34]             call    DEINT           ; get number param (100thds of second to wait) into DE
2A55: C5       [45]             push    BC              ; store BC
2A56: 3ABB81   [58]             ld      A,(TMRCNT)      ; Load current value of system timer
2A59: 47       [62]             ld      B,A             ; move it into B
2A5A: 3ABB81   [13]     CMP_A:  ld      A,(TMRCNT)      ; make a little delay of 1/100 sec...
2A5D: B8       [17]             cp      B               ; ...to let the sniffer collect...
2A5E: 20FA     [24|29]          jr      NZ,CMP_A        ; ...at least 1 char before to continue
2A60: 7A       [28]             ld      A,D             ; check the param
2A61: B3       [32]             or      E               ; if DE<>0 then...
2A62: 2005     [39|44]          jr      NZ,INKEY2       ; ...jump over...
2A64: 3A1882   [52]             ld      A,(TMPKEYBFR)   ; ...else read the buffer and...
2A67: 182A     [64]             jr      ENDINK          ; ...return it
2A69: 7A       [ 4]     INKEY2: ld      A,D             ; check if param>1023
2A6A: FE04     [11]             cp      $04             ; to do this we check if MSB>3
2A6C: D2821B   [21|21]          jp      NC,FCERR        ; if MSB >=4 then error
2A6F: E5       [32]             push    HL              ; store HL
2A70: 210900   [42]             ld      HL,$0009        ; check if value
2A73: CD153E   [59]             call    CMP16           ; is < 10
2A76: E1       [69]             pop     HL              ; retrieve HL
2A77: DA7D2A   [79|79]          jp      C,SRTINK        ; if value >= 10 then jump over
2A7A: 110A00   [89]             ld      DE,$000A        ; else, use 10 (no intervals shorter than 10/100s)
2A7D: 3ABB81   [13]     SRTINK: ld      A,(TMRCNT)      ; Load the first byte of the system timer
2A80: 47       [17]             ld      B,A             ; move it into B
2A81: 3A1882   [13]     CHKINK: ld      A,(TMPKEYBFR)   ; load char code from buffer
2A84: A7       [17]             and     A               ; is it 0?
2A85: 200C     [24|29]          jr      NZ,ENDINK       ; no, so we can return it
2A87: 3ABB81   [37]             ld      A,(TMRCNT)      ; load the first byte of the system timer
2A8A: B8       [41]             cp      B               ; is it the same value?
2A8B: 28F4     [48|53]          jr      Z,CHKINK        ; yes, so read again
2A8D: 47       [52]             ld      B,A             ; store new value
2A8E: 1B       [58]             dec     DE              ; no, decrement timer
2A8F: 7A       [62]             ld      A,D             ; check if zero reached
2A90: B3       [66]             or      E               ; by ORing D and E
2A91: 20EE     [73|78]          jr      NZ,CHKINK       ; if not 0, repeat
2A93: C1       [10]     ENDINK: pop     BC              ; restore BC
2A94: F5       [21]             push    AF              ; store A
2A95: F3       [25]             di                      ; disable INTs
2A96: AF       [29]             xor     A               ; clear the...
2A97: 321882   [42]             ld      (TMPKEYBFR),A   ; ...TMP KEY buffer for the next read
2A9A: FB       [46]             ei                      ; re-enable INTs
2A9B: F1       [56]             pop     AF              ; retrieve A
2A9C: C33323   [10]     ENDINK2:jp      PASSA           ; return A as ASCII value
                        
2A9F: 21C62F   [10]     ROUND:  ld      HL,HALF         ; Add 0.5 to FPREG
2AA2: CD972D   [17]     ADDPHL: call    LOADFP          ; Load FP at (HL) to BCDE
2AA5: C3B12A   [27]             jp      FPADD           ; Add BCDE to FPREG
                        
2AA8: CD972D   [17]     SUBPHL: call    LOADFP          ; FPREG = -FPREG + number at HL
2AAB: 21                        defb    $21             ; Skip "pop BC" and "pop DE"
2AAC: C1       [10]     PSUB:   pop     BC              ; Get FP number from stack
2AAD: D1       [20]             pop     DE
2AAE: CD712D   [17]     SUBCDE: call    INVSGN          ; Negate FPREG
2AB1: 78       [ 4]     FPADD:  ld      A,B             ; Get FP exponent
2AB2: B7       [ 8]             or      A               ; Is number zero?
2AB3: C8       [13|19]          ret     Z               ; Yes - Nothing to add
2AB4: 3A2F82   [26]             ld      A,(FPEXP)       ; Get FPREG exponent
2AB7: B7       [30]             or      A               ; Is this number zero?
2AB8: CA892D   [40|40]          jp      Z,FPBCDE        ; Yes - Move BCDE to FPREG
2ABB: 90       [44]             sub     B               ; BCDE number larger?
2ABC: D2CB2A   [54|54]          jp      NC,NOSWAP       ; No - Don't swap them
2ABF: 2F       [58]             cpl                     ; Two's complement
2AC0: 3C       [62]             inc     A               ;  FP exponent
2AC1: EB       [66]             ex      DE,HL
2AC2: CD792D   [83]             call    STAKFP          ; Put FPREG on stack
2AC5: EB       [87]             ex      DE,HL
2AC6: CD892D   [104]            call    FPBCDE          ; Move BCDE to FPREG
2AC9: C1       [114]            pop     BC              ; Restore number from stack
2ACA: D1       [124]            pop     DE
2ACB: FE19     [ 7]     NOSWAP: cp      24+1            ; Second number insignificant?
2ACD: D0       [12|18]          ret     NC              ; Yes - First number is result
2ACE: F5       [23]             push    AF              ; Save number of bits to scale
2ACF: CDAE2D   [40]             call    SIGNS           ; Set MSBs & sign of result
2AD2: 67       [44]             ld      H,A             ; Save sign of result
2AD3: F1       [54]             pop     AF              ; Restore scaling factor
2AD4: CD762B   [71]             call    SCALE           ; Scale BCDE to same exponent
2AD7: B4       [75]             or      H               ; Result to be positive?
2AD8: 212C82   [85]             ld      HL,FPREG        ; Point to FPREG
2ADB: F2F12A   [95|95]          jp      P,MINCDE        ; No - Subtract FPREG from CDE
2ADE: CD562B   [112]            call    PLUCDE          ; Add FPREG to CDE
2AE1: D2372B   [122|122]        jp      NC,RONDUP       ; No overflow - Round it up
2AE4: 23       [128]            inc     HL              ; Point to exponent
2AE5: 34       [139]            inc     (HL)            ; Increment it
2AE6: CAC115   [149|149]        jp      Z,OVERR         ; Number overflowed - Error
2AE9: 2E01     [156]            ld      L,$01           ; 1 bit to shift right
2AEB: CD8C2B   [173]            call    SHRT1           ; Shift result right
2AEE: C3372B   [183]            jp      RONDUP          ; Round it up
                        
2AF1: AF       [ 4]     MINCDE: xor     A               ; Clear A and carry
2AF2: 90       [ 8]             sub     B               ; Negate exponent
2AF3: 47       [12]             ld      B,A             ; Re-save exponent
2AF4: 7E       [19]             ld      A,(HL)          ; Get LSB of FPREG
2AF5: 9B       [23]             sbc     A, E            ; Subtract LSB of BCDE
2AF6: 5F       [27]             ld      E,A             ; Save LSB of BCDE
2AF7: 23       [33]             inc     HL
2AF8: 7E       [40]             ld      A,(HL)          ; Get NMSB of FPREG
2AF9: 9A       [44]             sbc     A,D             ; Subtract NMSB of BCDE
2AFA: 57       [48]             ld      D,A             ; Save NMSB of BCDE
2AFB: 23       [54]             inc     HL
2AFC: 7E       [61]             ld      A,(HL)          ; Get MSB of FPREG
2AFD: 99       [65]             sbc     A,C             ; Subtract MSB of BCDE
2AFE: 4F       [69]             ld      C,A             ; Save MSB of BCDE
2AFF: DC622B   [10|17]  CONPOS: call    C,COMPL         ; Overflow - Make it positive
                        
2B02: 68       [ 4]     BNORM:  ld      L,B             ; L = Exponent
2B03: 63       [ 8]             ld      H,E             ; H = LSB
2B04: AF       [12]             xor     A
2B05: 47       [ 4]     BNRMLP: ld      B,A             ; Save bit count
2B06: 79       [ 8]             ld      A,C             ; Get MSB
2B07: B7       [12]             or      A               ; Is it zero?
2B08: C2242B   [22|22]          jp      NZ,PNORM        ; No - Do it bit at a time
2B0B: 4A       [26]             ld      C,D             ; MSB = NMSB
2B0C: 54       [30]             ld      D,H             ; NMSB= LSB
2B0D: 65       [34]             ld      H,L             ; LSB = VLSB
2B0E: 6F       [38]             ld      L,A             ; VLSB= 0
2B0F: 78       [42]             ld      A,B             ; Get exponent
2B10: D608     [49]             sub     $08             ; Count 8 bits
2B12: FEE0     [56]             cp      -24-8           ; Was number zero?
2B14: C2052B   [66|66]          jp      NZ,BNRMLP       ; No - Keep normalising
2B17: AF       [ 4]     RESZER: xor     A               ; Result is zero
2B18: 322F82   [13]     SAVEXP: ld      (FPEXP),A       ; Save result as zero
2B1B: C9       [23]             ret
                        
2B1C: 05       [ 4]     NORMAL: dec     B               ; Count bits
2B1D: 29       [15]             add     HL,HL           ; Shift HL left
2B1E: 7A       [19]             ld      A,D             ; Get NMSB
2B1F: 17       [23]             rla                     ; Shift left with last bit
2B20: 57       [27]             ld      D,A             ; Save NMSB
2B21: 79       [31]             ld      A,C             ; Get MSB
2B22: 8F       [35]             adc     A,A             ; Shift left with last bit
2B23: 4F       [39]             ld      C,A             ; Save MSB
2B24: F21C2B   [10|10]  PNORM:  jp      P,NORMAL        ; Not done - Keep going
2B27: 78       [14]             ld      A,B             ; Number of bits shifted
2B28: 5C       [18]             ld      E,H             ; Save HL in EB
2B29: 45       [22]             ld      B,L
2B2A: B7       [26]             or      A               ; Any shifting done?
2B2B: CA372B   [36|36]          jp      Z,RONDUP        ; No - Round it up
2B2E: 212F82   [46]             ld      HL,FPEXP        ; Point to exponent
2B31: 86       [53]             add     A,(HL)          ; Add shifted bits
2B32: 77       [60]             ld      (HL),A          ; Re-save exponent
2B33: D2172B   [70|70]          jp      NC,RESZER       ; Underflow - Result is zero
2B36: C8       [75|81]          ret     Z               ; Result is zero
2B37: 78       [ 4]     RONDUP: ld      A,B             ; Get VLSB of number
2B38: 212F82   [10]     RONDB:  ld      HL,FPEXP        ; Point to exponent
2B3B: B7       [14]             or      A               ; Any rounding?
2B3C: FC492B   [24|31]          call    M,FPROND        ; Yes - Round number up
2B3F: 46       [31]             ld      B,(HL)          ; B = Exponent
2B40: 23       [37]             inc     HL
2B41: 7E       [44]             ld      A,(HL)          ; Get sign of result
2B42: E680     [51]             and     %10000000       ; Only bit 7 needed
2B44: A9       [55]             xor     C               ; Set correct sign
2B45: 4F       [59]             ld      C,A             ; Save correct sign in number
2B46: C3892D   [69]             jp      FPBCDE          ; Move BCDE to FPREG
                        
2B49: 1C       [ 4]     FPROND: inc     E               ; Round LSB
2B4A: C0       [ 9|15]          ret     NZ              ; Return if ok
2B4B: 14       [13]             inc     D               ; Round NMSB
2B4C: C0       [18|24]          ret     NZ              ; Return if ok
2B4D: 0C       [22]             inc     C               ; Round MSB
2B4E: C0       [27|33]          ret     NZ              ; Return if ok
2B4F: 0E80     [34]             ld      C,$80           ; Set normal value
2B51: 34       [45]             inc     (HL)            ; Increment exponent
2B52: C0       [50|56]          ret     NZ              ; Return if ok
2B53: C3C115   [60]             jp      OVERR           ; Overflow error
                        
2B56: 7E       [ 7]     PLUCDE: ld      A,(HL)          ; Get LSB of FPREG
2B57: 83       [11]             add     A,E             ; Add LSB of BCDE
2B58: 5F       [15]             ld      E,A             ; Save LSB of BCDE
2B59: 23       [21]             inc     HL
2B5A: 7E       [28]             ld      A,(HL)          ; Get NMSB of FPREG
2B5B: 8A       [32]             adc     A,D             ; Add NMSB of BCDE
2B5C: 57       [36]             ld      D,A             ; Save NMSB of BCDE
2B5D: 23       [42]             inc     HL
2B5E: 7E       [49]             ld      A,(HL)          ; Get MSB of FPREG
2B5F: 89       [53]             adc     A,C             ; Add MSB of BCDE
2B60: 4F       [57]             ld      C,A             ; Save MSB of BCDE
2B61: C9       [67]             ret
                        
2B62: 213082   [10]     COMPL:  ld      HL,SGNRES       ; Sign of result
2B65: 7E       [17]             ld      A,(HL)          ; Get sign of result
2B66: 2F       [21]             cpl                     ; Negate it
2B67: 77       [28]             ld      (HL),A          ; Put it back
2B68: AF       [32]             xor     A
2B69: 6F       [36]             ld      L,A             ; Set L to zero
2B6A: 90       [40]             sub     B               ; Negate exponent,set carry
2B6B: 47       [44]             ld      B,A             ; Re-save exponent
2B6C: 7D       [48]             ld      A,L             ; Load zero
2B6D: 9B       [52]             sbc     A,E             ; Negate LSB
2B6E: 5F       [56]             ld      E,A             ; Re-save LSB
2B6F: 7D       [60]             ld      A,L             ; Load zero
2B70: 9A       [64]             sbc     A,D             ; Negate NMSB
2B71: 57       [68]             ld      D,A             ; Re-save NMSB
2B72: 7D       [72]             ld      A,L             ; Load zero
2B73: 99       [76]             sbc     A,C             ; Negate MSB
2B74: 4F       [80]             ld      C,A             ; Re-save MSB
2B75: C9       [90]             ret
                        
2B76: 0600     [ 7]     SCALE:  ld      B,$00           ; Clear underflow
2B78: D608     [ 7]     SCALLP: sub     $08             ; 8 bits (a whole byte)?
2B7A: DA852B   [17|17]          jp      C,SHRITE        ; No - Shift right A bits
2B7D: 43       [21]             ld      B,E             ; <- Shift
2B7E: 5A       [25]             ld      E,D             ; <- right
2B7F: 51       [29]             ld      D,C             ; <- eight
2B80: 0E00     [36]             ld      C,$00           ; <- bits
2B82: C3782B   [46]             jp      SCALLP          ; More bits to shift
                        
2B85: C609     [ 7]     SHRITE: add     A,8+1           ; Adjust count
2B87: 6F       [11]             ld      L,A             ; Save bits to shift
2B88: AF       [ 4]     SHRLP:  xor     A               ; Flag for all done
2B89: 2D       [ 8]             dec     L               ; All shifting done?
2B8A: C8       [13|19]          ret     Z               ; Yes - Return
2B8B: 79       [17]             ld      A,C             ; Get MSB
2B8C: 1F       [ 4]     SHRT1:  rra                     ; Shift it right
2B8D: 4F       [ 8]             ld      C,A             ; Re-save
2B8E: 7A       [12]             ld      A,D             ; Get NMSB
2B8F: 1F       [16]             rra                     ; Shift right with last bit
2B90: 57       [20]             ld      D,A             ; Re-save it
2B91: 7B       [24]             ld      A,E             ; Get LSB
2B92: 1F       [28]             rra                     ; Shift right with last bit
2B93: 5F       [32]             ld      E,A             ; Re-save it
2B94: 78       [36]             ld      A,B             ; Get underflow
2B95: 1F       [40]             rra                     ; Shift right with last bit
2B96: 47       [44]             ld      B,A             ; Re-save underflow
2B97: C3882B   [54]             jp      SHRLP           ; More bits to do
                        
2B9A: 00000081          UNITY:  defb    $00,$00,$00,$81 ; 1.00000
                        
2B9E: 03                LOGTAB: defb    $03             ; Table used by LOG
2B9F: AA561980                  defb    $AA,$56,$19,$80 ; 0.59898
2BA3: F1227680                  defb    $F1,$22,$76,$80 ; 0.96147
2BA7: 45AA3882                  defb    $45,$AA,$38,$82 ; 2.88539
                        
2BAB: CD482D   [17]     LOG:    call    TSTSGN          ; Test sign of value
2BAE: B7       [21]             or      A
2BAF: EA821B   [31|31]          jp      PE,FCERR        ; ?FC Error if <= zero
2BB2: 212F82   [41]             ld      HL,FPEXP        ; Point to exponent
2BB5: 7E       [48]             ld      A,(HL)          ; Get exponent
2BB6: 013580   [58]             ld      BC,$8035        ; BCDE = SQR(1/2)
2BB9: 11F304   [68]             ld      DE,$04F3
2BBC: 90       [72]             sub     B               ; Scale value to be < 1
2BBD: F5       [83]             push    AF              ; Save scale factor
2BBE: 70       [90]             ld      (HL),B          ; Save new exponent
2BBF: D5       [101]            push    DE              ; Save SQR(1/2)
2BC0: C5       [112]            push    BC
2BC1: CDB12A   [129]            call    FPADD           ; Add SQR(1/2) to value
2BC4: C1       [139]            pop     BC              ; Restore SQR(1/2)
2BC5: D1       [149]            pop     DE
2BC6: 04       [153]            inc     B               ; Make it SQR(2)
2BC7: CD9E2C   [170]            call    DVBCDE          ; Divide by SQR(2)
2BCA: 219A2B   [180]            ld      HL,UNITY        ; Point to 1.
2BCD: CDA82A   [197]            call    SUBPHL          ; Subtract FPREG from 1
2BD0: 219E2B   [207]            ld      HL,LOGTAB       ; Coefficient table
2BD3: CD9030   [224]            call    SUMSER          ; Evaluate sum of series
2BD6: 018080   [234]            ld      BC,$8080        ; BCDE = -0.5
2BD9: 110000   [244]            ld      DE,$0000
2BDC: CDB12A   [261]            call    FPADD           ; Subtract 0.5 from FPREG
2BDF: F1       [271]            pop     AF              ; Restore scale factor
2BE0: CDC32E   [288]            call    RSCALE          ; Re-scale number
2BE3: 013180   [10]     MULLN2: ld      BC,$8031        ; BCDE = Ln(2)
2BE6: 111872   [20]             ld      DE,$7218
2BE9: 21                        defb    $21             ; Skip "pop BC" and "pop DE"
                        
2BEA: C1       [10]     MULT:   pop     BC              ; Get number from stack
2BEB: D1       [20]             pop     DE
2BEC: CD482D   [17]     FPMULT: call    TSTSGN          ; Test sign of FPREG
2BEF: C8       [22|28]          ret     Z               ; Return zero if zero
2BF0: 2E00     [29]             ld      L,$00           ; Flag add exponents
2BF2: CD062D   [46]             call    ADDEXP          ; Add exponents
2BF5: 79       [50]             ld      A,C             ; Get MSB of multiplier
2BF6: 323E82   [63]             ld      (MULVAL),A      ; Save MSB of multiplier
2BF9: EB       [67]             ex      DE,HL
2BFA: 223F82   [83]             ld      (MULVAL+1),HL   ; Save rest of multiplier
2BFD: 010000   [93]             ld      BC,$0000        ; Partial product (BCDE) = zero
2C00: 50       [97]             ld      D,B
2C01: 58       [101]            ld      E,B
2C02: 21022B   [111]            ld      HL,BNORM        ; Address of normalise
2C05: E5       [122]            push    HL              ; Save for return
2C06: 210E2C   [132]            ld      HL,MULT8        ; Address of 8 bit multiply
2C09: E5       [143]            push    HL              ; Save for NMSB,MSB
2C0A: E5       [154]            push    HL              ;
2C0B: 212C82   [164]            ld      HL,FPREG        ; Point to number
2C0E: 7E       [ 7]     MULT8:  ld      A,(HL)          ; Get LSB of number
2C0F: 23       [13]             inc     HL              ; Point to NMSB
2C10: B7       [17]             or      A               ; Test LSB
2C11: CA3A2C   [27|27]          jp      Z,BYTSFT        ; Zero - shift to next byte
2C14: E5       [38]             push    HL              ; Save address of number
2C15: 2E08     [45]             ld      L,$08           ; 8 bits to multiply by
2C17: 1F       [ 4]     MUL8LP: rra                     ; Shift LSB right
2C18: 67       [ 8]             ld      H,A             ; Save LSB
2C19: 79       [12]             ld      A,C             ; Get MSB
2C1A: D2282C   [22|22]          jp      NC,NOMADD       ; Bit was zero - Don't add
2C1D: E5       [33]             push    HL              ; Save LSB and count
2C1E: 2A3F82   [49]             ld      HL,(MULVAL+1)   ; Get LSB and NMSB
2C21: 19       [60]             add     HL,DE           ; Add NMSB and LSB
2C22: EB       [64]             ex      DE,HL           ; Leave sum in DE
2C23: E1       [74]             pop     HL              ; Restore MSB and count
2C24: 3A3E82   [87]             ld      A,(MULVAL)      ; Get MSB of multiplier
2C27: 89       [91]             adc     A,C             ; Add MSB
2C28: 1F       [ 4]     NOMADD: rra                     ; Shift MSB right
2C29: 4F       [ 8]             ld      C,A             ; Re-save MSB
2C2A: 7A       [12]             ld      A,D             ; Get NMSB
2C2B: 1F       [16]             rra                     ; Shift NMSB right
2C2C: 57       [20]             ld      D,A             ; Re-save NMSB
2C2D: 7B       [24]             ld      A,E             ; Get LSB
2C2E: 1F       [28]             rra                     ; Shift LSB right
2C2F: 5F       [32]             ld      E,A             ; Re-save LSB
2C30: 78       [36]             ld      A,B             ; Get VLSB
2C31: 1F       [40]             rra                     ; Shift VLSB right
2C32: 47       [44]             ld      B,A             ; Re-save VLSB
2C33: 2D       [48]             dec     L               ; Count bits multiplied
2C34: 7C       [52]             ld      A,H             ; Get LSB of multiplier
2C35: C2172C   [62|62]          jp      NZ,MUL8LP       ; More - Do it
2C38: E1       [10]     POPHRT: pop     HL              ; Restore address of number
2C39: C9       [20]             ret
                        
2C3A: 43       [ 4]     BYTSFT: ld      B,E             ; Shift partial product left
2C3B: 5A       [ 8]             ld      E,D
2C3C: 51       [12]             ld      D,C
2C3D: 4F       [16]             ld      C,A
2C3E: C9       [26]             ret
                        
                        
                        ; WORKING ââ
2C3F: C1       [10]     DINT:   pop     BC              ; Get number from stack
2C40: D1       [20]             pop     DE
2C41: CD9E2C   [37]             call    DVBCDE          ; get BCDE/FPREG and store result into FPREG
2C44: C31B2E   [47]             jp      INT             ; return INT(FPREG)
                        
                        
                        ; A MODULO B - return remainder of the integer division A/B where:
                        ; A is in stack; B is in FPREG
                        ; math is:
                        ; A=INT(A); B=INT(B); R=A-(B*INT(A/B))
2C47: CD1B2E   [17]     MOD:    call    INT             ; B=INT(B)
2C4A: CD942D   [34]             call    BCDEFP          ; copy B (from FPREG) into BCDE
2C4D: ED53E081 [54]             ld      (TMPBFR3),DE    ; store B into...
2C51: ED43E281 [74]             ld      (TMPBFR4),BC    ; ...a temp buffer
2C55: C1       [84]             pop     BC              ; recover A...
2C56: D1       [94]             pop     DE              ; ...from stack
2C57: CD892D   [111]            call    FPBCDE          ; store A into FPREG
2C5A: CD1B2E   [128]            call    INT             ; get integer part: A=INT(A)
2C5D: CD942D   [145]            call    BCDEFP          ; copy A (from FPREG) into BCDE
2C60: ED53DC81 [165]            ld      (TMPBFR1),DE    ; store A into...
2C64: ED43DE81 [185]            ld      (TMPBFR2),BC    ; ...a temp buffer
                                                        ; begin calculation
2C68: 2AE081   [201]            ld      HL,(TMPBFR3)    ; move B...
2C6B: 222C82   [217]            ld      (FPREG),HL      ; ...from...
2C6E: 2AE281   [233]            ld      HL,(TMPBFR4)    ; ...temp buffer...
2C71: 222E82   [249]            ld      (FPREG+2),HL    ; ...into FPREG
2C74: CD9E2C   [266]            call    DVBCDE          ; compute A/B and store into FPREG
2C77: CD1B2E   [283]            call    INT             ; get integer part of result: now FPREG = INT(A/B)
2C7A: ED5BE081 [303]            ld      DE,(TMPBFR3)    ; load B...
2C7E: ED4BE281 [323]            ld      BC,(TMPBFR4)    ; ...into BCDE
2C82: CDEC2B   [340]            call    FPMULT          ; get B*INT(A/B) and store into FPREG
2C85: ED5BDC81 [360]            ld      DE,(TMPBFR1)    ; retrieve A from...
2C89: ED4BDE81 [380]            ld      BC,(TMPBFR2)    ; ...temp buffer
2C8D: C3AE2A   [390]            jp      SUBCDE          ; return result of A-(B*INT(A/B))
                        
                        
2C90: CD792D   [17]     DIV10:  call    STAKFP          ; Save FPREG on stack
2C93: 012084   [27]             ld      BC,$8420        ; BCDE = 10.
2C96: 110000   [37]             ld      DE,$0000
2C99: CD892D   [54]             call    FPBCDE          ; Move 10 to FPREG
                        
2C9C: C1       [10]     DIV:    pop     BC              ; Get number from stack
2C9D: D1       [20]             pop     DE
2C9E: CD482D   [17]     DVBCDE: call    TSTSGN          ; Test sign of FPREG
2CA1: CAB515   [27|27]          jp      Z,DZERR         ; Error if division by zero
2CA4: 2EFF     [34]             ld      L,-1            ; Flag subtract exponents
2CA6: CD062D   [51]             call    ADDEXP          ; Subtract exponents
2CA9: 34       [62]             inc     (HL)            ; Add 2 to exponent to adjust
2CAA: 34       [73]             inc     (HL)
2CAB: 2B       [79]             dec     HL              ; Point to MSB
2CAC: 7E       [86]             ld      A,(HL)          ; Get MSB of dividend
2CAD: 327380   [99]             ld      (DIV3),A        ; Save for subtraction
2CB0: 2B       [105]            dec     HL
2CB1: 7E       [112]            ld      A,(HL)          ; Get NMSB of dividend
2CB2: 326F80   [125]            ld      (DIV2),A        ; Save for subtraction
2CB5: 2B       [131]            dec     HL
2CB6: 7E       [138]            ld      A,(HL)          ; Get MSB of dividend
2CB7: 326B80   [151]            ld      (DIV1),A        ; Save for subtraction
2CBA: 41       [155]            ld      B,C             ; Get MSB
2CBB: EB       [159]            ex      DE,HL           ; NMSB,LSB to HL
2CBC: AF       [163]            xor     A
2CBD: 4F       [167]            ld      C,A             ; Clear MSB of quotient
2CBE: 57       [171]            ld      D,A             ; Clear NMSB of quotient
2CBF: 5F       [175]            ld      E,A             ; Clear LSB of quotient
2CC0: 327680   [188]            ld      (DIV4),A        ; Clear overflow count
2CC3: E5       [11]     DIVLP:  push    HL              ; Save divisor
2CC4: C5       [22]             push    BC
2CC5: 7D       [26]             ld      A,L             ; Get LSB of number
2CC6: CD6A80   [43]             call    DIVSUP          ; Subt' divisor from dividend
2CC9: DE00     [50]             sbc     A,$00           ; Count for overflows
2CCB: 3F       [54]             ccf
2CCC: D2D62C   [64|64]          jp      NC,RESDIV       ; Restore divisor if borrow
2CCF: 327680   [77]             ld      (DIV4),A        ; Re-save overflow count
2CD2: F1       [87]             pop     AF              ; Scrap divisor
2CD3: F1       [97]             pop     AF
2CD4: 37       [101]            scf                     ; Set carry to
2CD5: D2                        defb    $D2             ; Skip "pop BC" and "pop HL"
                        
2CD6: C1       [10]     RESDIV: pop     BC              ; Restore divisor
2CD7: E1       [20]             pop     HL
2CD8: 79       [24]             ld      A,C             ; Get MSB of quotient
2CD9: 3C       [28]             inc     A
2CDA: 3D       [32]             dec     A
2CDB: 1F       [36]             rra                     ; Bit 0 to bit 7
2CDC: FA382B   [46|46]          jp      M,RONDB         ; Done - Normalise result
2CDF: 17       [50]             rla                     ; Restore carry
2CE0: 7B       [54]             ld      A,E             ; Get LSB of quotient
2CE1: 17       [58]             rla                     ; Double it
2CE2: 5F       [62]             ld      E,A             ; Put it back
2CE3: 7A       [66]             ld      A,D             ; Get NMSB of quotient
2CE4: 17       [70]             rla                     ; Double it
2CE5: 57       [74]             ld      D,A             ; Put it back
2CE6: 79       [78]             ld      A,C             ; Get MSB of quotient
2CE7: 17       [82]             rla                     ; Double it
2CE8: 4F       [86]             ld      C,A             ; Put it back
2CE9: 29       [97]             add     HL,HL           ; Double NMSB,LSB of divisor
2CEA: 78       [101]            ld      A,B             ; Get MSB of divisor
2CEB: 17       [105]            rla                     ; Double it
2CEC: 47       [109]            ld      B,A             ; Put it back
2CED: 3A7680   [122]            ld      A,(DIV4)        ; Get VLSB of quotient
2CF0: 17       [126]            rla                     ; Double it
2CF1: 327680   [139]            ld      (DIV4),A        ; Put it back
2CF4: 79       [143]            ld      A,C             ; Get MSB of quotient
2CF5: B2       [147]            or      D               ; Merge NMSB
2CF6: B3       [151]            or      E               ; Merge LSB
2CF7: C2C32C   [161|161]        jp      NZ,DIVLP        ; Not done - Keep dividing
2CFA: E5       [172]            push    HL              ; Save divisor
2CFB: 212F82   [182]            ld      HL,FPEXP        ; Point to exponent
2CFE: 35       [193]            dec     (HL)            ; Divide by 2
2CFF: E1       [203]            pop     HL              ; Restore divisor
2D00: C2C32C   [213|213]        jp      NZ,DIVLP        ; Ok - Keep going
2D03: C3C115   [223]            jp      OVERR           ; Overflow error
                        
                        
2D06: 78       [ 4]     ADDEXP: ld      A,B             ; Get exponent of dividend
2D07: B7       [ 8]             or      A               ; Test it
2D08: CA2A2D   [18|18]          jp      Z,OVTST3        ; Zero - Result zero
2D0B: 7D       [22]             ld      A,L             ; Get add/subtract flag
2D0C: 212F82   [32]             ld      HL,FPEXP        ; Point to exponent
2D0F: AE       [39]             xor     (HL)            ; Add or subtract it
2D10: 80       [43]             add     A,B             ; Add the other exponent
2D11: 47       [47]             ld      B,A             ; Save new exponent
2D12: 1F       [51]             rra                     ; Test exponent for overflow
2D13: A8       [55]             xor     B
2D14: 78       [59]             ld      A,B             ; Get exponent
2D15: F2292D   [69|69]          jp      P,OVTST2        ; Positive - Test for overflow
2D18: C680     [76]             add     A,$80           ; Add excess 128
2D1A: 77       [83]             ld      (HL),A          ; Save new exponent
2D1B: CA382C   [93|93]          jp      Z,POPHRT        ; Zero - Result zero
2D1E: CDAE2D   [110]            call    SIGNS           ; Set MSBs and sign of result
2D21: 77       [117]            ld      (HL),A          ; Save new exponent
2D22: 2B       [123]            dec     HL              ; Point to MSB
2D23: C9       [133]            ret
                        
2D24: CD482D   [17]     OVTST1: call    TSTSGN          ; Test sign of FPREG
2D27: 2F       [21]             cpl                     ; Invert sign
2D28: E1       [31]             pop     HL              ; Clean up stack
2D29: B7       [ 4]     OVTST2: or      A               ; Test if new exponent zero
2D2A: E1       [10]     OVTST3: pop     HL              ; Clear off return address
2D2B: F2172B   [20|20]          jp      P,RESZER        ; Result zero
2D2E: C3C115   [30]             jp      OVERR           ; Overflow error
                        
2D31: CD942D   [17]     MLSP10: call    BCDEFP          ; Move FPREG to BCDE
2D34: 78       [21]             ld      A,B             ; Get exponent
2D35: B7       [25]             or      A               ; Is it zero?
2D36: C8       [30|36]          ret     Z               ; Yes - Result is zero
2D37: C602     [37]             add     A,$02           ; Multiply by 4
2D39: DAC115   [47|47]          jp      C,OVERR         ; Overflow - ?OV Error
2D3C: 47       [51]             ld      B,A             ; Re-save exponent
2D3D: CDB12A   [68]             call    FPADD           ; Add BCDE to FPREG (Times 5)
2D40: 212F82   [78]             ld      HL,FPEXP        ; Point to exponent
2D43: 34       [89]             inc     (HL)            ; Double number (Times 10)
2D44: C0       [94|100]         ret     NZ              ; Ok - Return
2D45: C3C115   [104]            jp      OVERR           ; Overflow error
                        
2D48: 3A2F82   [13]     TSTSGN: ld      A,(FPEXP)       ; Get sign of FPREG
2D4B: B7       [17]             or      A
2D4C: C8       [22|28]          ret     Z               ; RETurn if number is zero
2D4D: 3A2E82   [35]             ld      A,(FPREG+2)     ; Get MSB of FPREG
2D50: FE                        defb    0FEH            ; Test sign
2D51: 2F       [ 4]     RETREL: cpl                     ; Invert sign
2D52: 17       [ 8]             rla                     ; Sign bit to carry
2D53: 9F       [ 4]     FLGDIF: sbc     A,A             ; Carry to all bits of A
2D54: C0       [ 9|15]          ret     NZ              ; Return -1 if negative
2D55: 3C       [13]             inc     A               ; Bump to +1
2D56: C9       [23]             ret                     ; Positive - Return +1
                        
2D57: CD482D   [17]     SGN:    call    TSTSGN          ; Test sign of FPREG
2D5A: 0688     [ 7]     FLGREL: ld      B,$80+8         ; 8 bit integer in exponent
2D5C: 110000   [17]             ld      DE,0            ; Zero NMSB and LSB
2D5F: 212F82   [10]     RETINT: ld      HL,FPEXP        ; Point to exponent
2D62: 4F       [14]             ld      C,A             ; CDE = MSB,NMSB and LSB
2D63: 70       [21]             ld      (HL),B          ; Save exponent
2D64: 0600     [28]             ld      B,0             ; CDE = integer to normalise
2D66: 23       [34]             inc     HL              ; Point to sign of result
2D67: 3680     [44]             ld      (HL),$80        ; Set sign of result
2D69: 17       [48]             rla                     ; Carry = sign of integer
2D6A: C3FF2A   [58]             jp      CONPOS          ; Set sign of result
                        
2D6D: CD482D   [17]     ABS:    call    TSTSGN          ; Test sign of FPREG
2D70: F0       [22|28]          ret     P               ; Return if positive
2D71: 212E82   [10]     INVSGN: ld      HL,FPREG+2      ; Point to MSB
2D74: 7E       [17]             ld      A,(HL)          ; Get sign of mantissa
2D75: EE80     [24]             xor     $80             ; Invert sign of mantissa
2D77: 77       [31]             ld      (HL),A          ; Re-save sign of mantissa
2D78: C9       [41]             ret
                        
2D79: EB       [ 4]     STAKFP: ex      DE,HL           ; Save code string address
2D7A: 2A2C82   [20]             ld      HL,(FPREG)      ; LSB,NLSB of FPREG
2D7D: E3       [39]             ex      (SP),HL         ; Stack them,get return
2D7E: E5       [50]             push    HL              ; Re-save return
2D7F: 2A2E82   [66]             ld      HL,(FPREG+2)    ; MSB and exponent of FPREG
2D82: E3       [85]             ex      (SP),HL         ; Stack them,get return
2D83: E5       [96]             push    HL              ; Re-save return
2D84: EB       [100]            ex      DE,HL           ; Restore code string address
2D85: C9       [110]            ret
                        
                        ; store F.P. number from BCDE into FPREG
2D86: CD972D   [17]     PHLTFP: call    LOADFP          ; Number at HL to BCDE
2D89: EB       [ 4]     FPBCDE: ex      DE,HL           ; Save code string address
2D8A: 222C82   [20]             ld      (FPREG),HL      ; Save LSB,NLSB of number
2D8D: 60       [24]             ld      H,B             ; Exponent of number
2D8E: 69       [28]             ld      L,C             ; MSB of number
2D8F: 222E82   [44]             ld      (FPREG+2),HL    ; Save MSB and exponent
2D92: EB       [48]             ex      DE,HL           ; Restore code string address
2D93: C9       [58]             ret
                        
                        ; load F.P. number from FPREG into BCDE
2D94: 212C82   [10]     BCDEFP: ld      HL,FPREG        ; Point to FPREG
2D97: 5E       [ 7]     LOADFP: ld      E,(HL)          ; Get LSB of number
2D98: 23       [13]             inc     HL
2D99: 56       [20]             ld      D,(HL)          ; Get NMSB of number
2D9A: 23       [26]             inc     HL
2D9B: 4E       [33]             ld      C,(HL)          ; Get MSB of number
2D9C: 23       [39]             inc     HL
2D9D: 46       [46]             ld      B,(HL)          ; Get exponent of number
2D9E: 23       [ 6]     INCHL:  inc     HL              ; Used for conditional "inc HL"
2D9F: C9       [16]             ret
                        
2DA0: 112C82   [10]     FPTHL:  ld      DE,FPREG        ; Point to FPREG
2DA3: 0604     [ 7]     DETHL4: ld      B,$04           ; 4 bytes to move
2DA5: 1A       [ 7]     DETHLB: ld      A,(DE)          ; Get source
2DA6: 77       [14]             ld      (HL),A          ; Save destination
2DA7: 13       [20]             inc     DE              ; Next source
2DA8: 23       [26]             inc     HL              ; Next destination
2DA9: 05       [30]             dec     B               ; Count bytes
2DAA: C2A52D   [40|40]          jp      NZ,DETHLB       ; Loop if more
2DAD: C9       [50]             ret
                        
2DAE: 212E82   [10]     SIGNS:  ld      HL,FPREG+2      ; Point to MSB of FPREG
2DB1: 7E       [17]             ld      A,(HL)          ; Get MSB
2DB2: 07       [21]             rlca                    ; Old sign to carry
2DB3: 37       [25]             scf                     ; Set MSBit
2DB4: 1F       [29]             rra                     ; Set MSBit of MSB
2DB5: 77       [36]             ld      (HL),A          ; Save new MSB
2DB6: 3F       [40]             ccf                     ; Complement sign
2DB7: 1F       [44]             rra                     ; Old sign to carry
2DB8: 23       [50]             inc     HL
2DB9: 23       [56]             inc     HL
2DBA: 77       [63]             ld      (HL),A          ; Set sign of result
2DBB: 79       [67]             ld      A,C             ; Get MSB
2DBC: 07       [71]             rlca                    ; Old sign to carry
2DBD: 37       [75]             scf                     ; Set MSBit
2DBE: 1F       [79]             rra                     ; Set MSBit of MSB
2DBF: 4F       [83]             ld      C,A             ; Save MSB
2DC0: 1F       [87]             rra
2DC1: AE       [94]             xor     (HL)            ; New sign of result
2DC2: C9       [104]            ret
                        
2DC3: 78       [ 4]     CMPNUM: ld      A,B             ; Get exponent of number
2DC4: B7       [ 8]             or      A
2DC5: CA482D   [18|18]          jp      Z,TSTSGN        ; Zero - Test sign of FPREG
2DC8: 21512D   [28]             ld      HL,RETREL       ; Return relation routine
2DCB: E5       [39]             push    HL              ; Save for return
2DCC: CD482D   [56]             call    TSTSGN          ; Test sign of FPREG
2DCF: 79       [60]             ld      A,C             ; Get MSB of number
2DD0: C8       [65|71]          ret     Z               ; FPREG zero - Number's MSB
2DD1: 212E82   [75]             ld      HL,FPREG+2      ; MSB of FPREG
2DD4: AE       [82]             xor     (HL)            ; Combine signs
2DD5: 79       [86]             ld      A,C             ; Get MSB of number
2DD6: F8       [91|97]          ret     M               ; Exit if signs different
2DD7: CDDD2D   [108]            call    CMPFP           ; Compare FP numbers
2DDA: 1F       [112]            rra                     ; Get carry to sign
2DDB: A9       [116]            xor     C               ; Combine with MSB of number
2DDC: C9       [126]            ret
                        
2DDD: 23       [ 6]     CMPFP:  inc     HL              ; Point to exponent
2DDE: 78       [10]             ld      A,B             ; Get exponent
2DDF: BE       [17]             cp      (HL)            ; Compare exponents
2DE0: C0       [22|28]          ret     NZ              ; Different
2DE1: 2B       [28]             dec     HL              ; Point to MBS
2DE2: 79       [32]             ld      A,C             ; Get MSB
2DE3: BE       [39]             cp      (HL)            ; Compare MSBs
2DE4: C0       [44|50]          ret     NZ              ; Different
2DE5: 2B       [50]             dec     HL              ; Point to NMSB
2DE6: 7A       [54]             ld      A,D             ; Get NMSB
2DE7: BE       [61]             cp      (HL)            ; Compare NMSBs
2DE8: C0       [66|72]          ret     NZ              ; Different
2DE9: 2B       [72]             dec     HL              ; Point to LSB
2DEA: 7B       [76]             ld      A,E             ; Get LSB
2DEB: 96       [83]             sub     (HL)            ; Compare LSBs
2DEC: C0       [88|94]          ret     NZ              ; Different
2DED: E1       [98]             pop     HL              ; Drop RETurn
2DEE: E1       [108]            pop     HL              ; Drop another RETurn
2DEF: C9       [118]            ret
                        
2DF0: 47       [ 4]     FPINT:  ld      B,A             ; <- Move
2DF1: 4F       [ 8]             ld      C,A             ; <- exponent
2DF2: 57       [12]             ld      D,A             ; <- to all
2DF3: 5F       [16]             ld      E,A             ; <- bits
2DF4: B7       [20]             or      A               ; Test exponent
2DF5: C8       [25|31]          ret     Z               ; Zero - Return zero
2DF6: E5       [36]             push    HL              ; Save pointer to number
2DF7: CD942D   [53]             call    BCDEFP          ; Move FPREG to BCDE
2DFA: CDAE2D   [70]             call    SIGNS           ; Set MSBs & sign of result
2DFD: AE       [77]             xor     (HL)            ; Combine with sign of FPREG
2DFE: 67       [81]             ld      H,A             ; Save combined signs
2DFF: FC142E   [91|98]          call    M,DCBCDE        ; Negative - Decrement BCDE
2E02: 3E98     [98]             ld      A,$80+24        ; 24 bits
2E04: 90       [102]            sub     B               ; Bits to shift
2E05: CD762B   [119]            call    SCALE           ; Shift BCDE
2E08: 7C       [123]            ld      A,H             ; Get combined sign
2E09: 17       [127]            rla                     ; Sign to carry
2E0A: DC492B   [137|144]        call    C,FPROND        ; Negative - Round number up
2E0D: 0600     [144]            ld      B,$00           ; Zero exponent
2E0F: DC622B   [154|161]        call    C,COMPL         ; If negative make positive
2E12: E1       [164]            pop     HL              ; Restore pointer to number
2E13: C9       [174]            ret
                        
2E14: 1B       [ 6]     DCBCDE: dec     DE              ; Decrement BCDE
2E15: 7A       [10]             ld      A,D             ; Test LSBs
2E16: A3       [14]             and     E
2E17: 3C       [18]             inc     A
2E18: C0       [23|29]          ret     NZ              ; Exit if LSBs not FFFF
2E19: 0B       [29]             dec     BC              ; Decrement MSBs
2E1A: C9       [39]             ret
                        
2E1B: 212F82   [10]     INT:    ld      HL,FPEXP        ; Point to exponent
2E1E: 7E       [17]             ld      A,(HL)          ; Get exponent
2E1F: FE98     [24]             cp      $80+24          ; Integer accuracy only?
2E21: 3A2C82   [37]             ld      A,(FPREG)       ; Get LSB
2E24: D0       [42|48]          ret     NC              ; Yes - Already integer
2E25: 7E       [49]             ld      A,(HL)          ; Get exponent
2E26: CDF02D   [66]             call    FPINT           ; F.P to integer
2E29: 3698     [76]             ld      (HL),$80+24     ; Save 24 bit integer
2E2B: 7B       [80]             ld      A,E             ; Get LSB of number
2E2C: F5       [91]             push    AF              ; Save LSB
2E2D: 79       [95]             ld      A,C             ; Get MSB of number
2E2E: 17       [99]             rla                     ; Sign to carry
2E2F: CDFF2A   [116]            call    CONPOS          ; Set sign of result
2E32: F1       [126]            pop     AF              ; Restore LSB of number
2E33: C9       [136]            ret
                        
2E34: 210000   [10]     MLDEBC: ld      HL,$0000        ; Clear partial product
2E37: 78       [14]             ld      A,B             ; Test multiplier
2E38: B1       [18]             or      C
2E39: C8       [23|29]          ret     Z               ; Return zero if zero
2E3A: 3E10     [30]             ld      A,$10           ; 16 bits
2E3C: 29       [11]     MLDBLP: add     HL,HL           ; Shift P.P left
2E3D: DA6122   [21|21]          jp      C,BSERR         ; ?BS Error if overflow
2E40: EB       [25]             ex      DE,HL
2E41: 29       [36]             add     HL,HL           ; Shift multiplier left
2E42: EB       [40]             ex      DE,HL
2E43: D24A2E   [50|50]          jp      NC,NOMLAD       ; Bit was zero - No add
2E46: 09       [61]             add     HL,BC           ; Add multiplicand
2E47: DA6122   [71|71]          jp      C,BSERR         ; ?BS Error if overflow
2E4A: 3D       [ 4]     NOMLAD: dec     A               ; Count bits
2E4B: C23C2E   [14|14]          jp      NZ,MLDBLP       ; More
2E4E: C9       [24]             ret
                        
2E4F: FE2D     [ 7]     ASCTFP: cp      '-'             ; Negative?
2E51: F5       [18]             push    AF              ; Save it and flags
2E52: CA5B2E   [28|28]          jp      Z,CNVNUM        ; Yes - Convert number
2E55: FE2B     [35]             cp      '+'             ; Positive?
2E57: CA5B2E   [45|45]          jp      Z,CNVNUM        ; Yes - Convert number
2E5A: 2B       [51]             dec     HL              ; dec 'cos GETCHR INCs
2E5B: CD172B   [17]     CNVNUM: call    RESZER          ; Set result to zero
2E5E: 47       [21]             ld      B,A             ; Digits after point counter
2E5F: 57       [25]             ld      D,A             ; Sign of exponent
2E60: 5F       [29]             ld      E,A             ; Exponent of ten
2E61: 2F       [33]             cpl
2E62: 4F       [37]             ld      C,A             ; Before or after point flag
2E63: CDB71A   [17]     MANLP:  call    GETCHR          ; Get next character
2E66: DAAC2E   [27|27]          jp      C,ADDIG         ; Digit - Add to number
2E69: FE2E     [34]             cp      '.'
2E6B: CA872E   [44|44]          jp      Z,DPOINT        ; '.' - Flag point
2E6E: FE45     [51]             cp      'E'
2E70: C28B2E   [61|61]          jp      NZ,CONEXP       ; Not 'E' - Scale number
2E73: CDB71A   [78]             call    GETCHR          ; Get next character
2E76: CD7D20   [95]             call    SGNEXP          ; Get sign of exponent
2E79: CDB71A   [17]     EXPLP:  call    GETCHR          ; Get next character
2E7C: DACE2E   [27|27]          jp      C,EDIGIT        ; Digit - Add to exponent
2E7F: 14       [31]             inc     D               ; Is sign negative?
2E80: C28B2E   [41|41]          jp      NZ,CONEXP       ; No - Scale number
2E83: AF       [45]             xor     A
2E84: 93       [49]             sub     E               ; Negate exponent
2E85: 5F       [53]             ld      E,A             ; And re-save it
2E86: 0C       [57]             inc     C               ; Flag end of number
2E87: 0C       [ 4]     DPOINT: inc     C               ; Flag point passed
2E88: CA632E   [14|14]          jp      Z,MANLP         ; Zero - Get another digit
2E8B: E5       [11]     CONEXP: push    HL              ; Save code string address
2E8C: 7B       [15]             ld      A,E             ; Get exponent
2E8D: 90       [19]             sub     B               ; Subtract digits after point
2E8E: F4A42E   [10|17]  SCALMI: call    P,SCALPL        ; Positive - Multiply number
2E91: F29A2E   [20|20]          jp      P,ENDCON        ; Positive - All done
2E94: F5       [31]             push    AF              ; Save number of times to /10
2E95: CD902C   [48]             call    DIV10           ; Divide by 10
2E98: F1       [58]             pop     AF              ; Restore count
2E99: 3C       [62]             inc     A               ; Count divides
                        
2E9A: C28E2E   [10|10]  ENDCON: jp      NZ,SCALMI       ; More to do
2E9D: D1       [20]             pop     DE              ; Restore code string address
2E9E: F1       [30]             pop     AF              ; Restore sign of number
2E9F: CC712D   [40|47]          call    Z,INVSGN        ; Negative - Negate number
2EA2: EB       [44]             ex      DE,HL           ; Code string address to HL
2EA3: C9       [54]             ret
                        
2EA4: C8       [ 5|11]  SCALPL: ret     Z               ; Exit if no scaling needed
2EA5: F5       [11]     MULTEN: push    AF              ; Save count
2EA6: CD312D   [28]             call    MLSP10          ; Multiply number by 10
2EA9: F1       [38]             pop     AF              ; Restore count
2EAA: 3D       [42]             dec     A               ; Count multiplies
2EAB: C9       [52]             ret
                        
2EAC: D5       [11]     ADDIG:  push    DE              ; Save sign of exponent
2EAD: 57       [15]             ld      D,A             ; Save digit
2EAE: 78       [19]             ld      A,B             ; Get digits after point
2EAF: 89       [23]             adc     A,C             ; Add one if after point
2EB0: 47       [27]             ld      B,A             ; Re-save counter
2EB1: C5       [38]             push    BC              ; Save point flags
2EB2: E5       [49]             push    HL              ; Save code string address
2EB3: D5       [60]             push    DE              ; Save digit
2EB4: CD312D   [77]             call    MLSP10          ; Multiply number by 10
2EB7: F1       [87]             pop     AF              ; Restore digit
2EB8: D630     [94]             sub     '0'             ; Make it absolute
2EBA: CDC32E   [111]            call    RSCALE          ; Re-scale number
2EBD: E1       [121]            pop     HL              ; Restore code string address
2EBE: C1       [131]            pop     BC              ; Restore point flags
2EBF: D1       [141]            pop     DE              ; Restore sign of exponent
2EC0: C3632E   [151]            jp      MANLP           ; Get another digit
                        
2EC3: CD792D   [17]     RSCALE: call    STAKFP          ; Put number on stack
2EC6: CD5A2D   [34]             call    FLGREL          ; Digit to add to FPREG
2EC9: C1       [10]     PADD:   pop     BC              ; Restore number
2ECA: D1       [20]             pop     DE
2ECB: C3B12A   [30]             jp      FPADD           ; Add BCDE to FPREG and return
                        
2ECE: 7B       [ 4]     EDIGIT: ld      A,E             ; Get digit
2ECF: 07       [ 8]             rlca                    ; Times 2
2ED0: 07       [12]             rlca                    ; Times 4
2ED1: 83       [16]             add     A,E             ; Times 5
2ED2: 07       [20]             rlca                    ; Times 10
2ED3: 86       [27]             add     A,(HL)          ; Add next digit
2ED4: D630     [34]             sub     '0'             ; Make it absolute
2ED6: 5F       [38]             ld      E,A             ; Save new digit
2ED7: C3792E   [48]             jp      EXPLP           ; Look for another digit
                        
2EDA: E5       [11]     LINEIN: push    HL              ; Save code string address
2EDB: 212B15   [21]             ld      HL,INMSG        ; Output " in "
2EDE: CD4224   [38]             call    PRS             ; Output string at HL
2EE1: E1       [48]             pop     HL              ; Restore code string address
2EE2: EB       [ 4]     PRNTHL: ex      DE,HL           ; Code string address to DE
2EE3: AF       [ 8]             xor     A
2EE4: 0698     [15]             ld      B,$80+24        ; 24 bits
2EE6: CD5F2D   [32]             call    RETINT          ; Return the integer
2EE9: 214124   [42]             ld      HL,PRNUMS       ; Print number string
2EEC: E5       [53]             push    HL              ; Save for return
2EED: 213182   [10]     NUMASC: ld      HL,PBUFF        ; Convert number to ASCII
2EF0: E5       [21]             push    HL              ; Save for return
2EF1: CD482D   [38]             call    TSTSGN          ; Test sign of FPREG
2EF4: 3620     [48]             ld      (HL),SPC        ; Space at start
2EF6: F2FB2E   [58|58]          jp      P,SPCFST        ; Positive - Space to start
2EF9: 362D     [68]             ld      (HL),'-'        ; '-' sign at start
2EFB: 23       [ 6]     SPCFST: inc     HL              ; First byte of number
2EFC: 3630     [16]             ld      (HL),'0'        ; '0' if zero
2EFE: CAB12F   [26|26]          jp      Z,JSTZER        ; Return '0' if zero
2F01: E5       [37]             push    HL              ; Save buffer address
2F02: FC712D   [47|54]          call    M,INVSGN        ; Negate FPREG if negative
2F05: AF       [51]             xor     A               ; Zero A
2F06: F5       [62]             push    AF              ; Save it
2F07: CDB72F   [79]             call    RNGTST          ; Test number is in range
2F0A: 014391   [10]     SIXDIG: ld      BC,$9143        ; BCDE - 99999.9
2F0D: 11F84F   [20]             ld      DE,$4FF8
2F10: CDC32D   [37]             call    CMPNUM          ; Compare numbers
2F13: B7       [41]             or      A
2F14: E2282F   [51|51]          jp      PO,INRNG        ; > 99999.9 - Sort it out
2F17: F1       [61]             pop     AF              ; Restore count
2F18: CDA52E   [78]             call    MULTEN          ; Multiply by ten
2F1B: F5       [89]             push    AF              ; Re-save count
2F1C: C30A2F   [99]             jp      SIXDIG          ; Test it again
                        
2F1F: CD902C   [17]     GTSIXD: call    DIV10           ; Divide by 10
2F22: F1       [27]             pop     AF              ; Get count
2F23: 3C       [31]             inc     A               ; Count divides
2F24: F5       [42]             push    AF              ; Re-save count
2F25: CDB72F   [59]             call    RNGTST          ; Test number is in range
2F28: CD9F2A   [17]     INRNG:  call    ROUND           ; Add 0.5 to FPREG
2F2B: 3C       [21]             inc     A
2F2C: CDF02D   [38]             call    FPINT           ; F.P to integer
2F2F: CD892D   [55]             call    FPBCDE          ; Move BCDE to FPREG
2F32: 010603   [65]             ld      BC,$0306        ; 1E+06 to 1E-03 range
2F35: F1       [75]             pop     AF              ; Restore count
2F36: 81       [79]             add     A,C             ; 6 digits before point
2F37: 3C       [83]             inc     A               ; Add one
2F38: FA442F   [93|93]          jp      M,MAKNUM        ; Do it in 'E' form if < 1E-02
2F3B: FE08     [100]            cp      6+1+1           ; More than 999999 ?
2F3D: D2442F   [110|110]        jp      NC,MAKNUM       ; Yes - Do it in 'E' form
2F40: 3C       [114]            inc     A               ; Adjust for exponent
2F41: 47       [118]            ld      B,A             ; Exponent of number
2F42: 3E02     [125]            ld      A,2             ; Make it zero after
                        
2F44: 3D       [ 4]     MAKNUM: dec     A               ; Adjust for digits to do
2F45: 3D       [ 8]             dec     A
2F46: E1       [18]             pop     HL              ; Restore buffer address
2F47: F5       [29]             push    AF              ; Save count
2F48: 11CA2F   [39]             ld      DE,POWERS       ; Powers of ten
2F4B: 05       [43]             dec     B               ; Count digits before point
2F4C: C2552F   [53|53]          jp      NZ,DIGTXT       ; Not zero - Do number
2F4F: 362E     [63]             ld      (HL),'.'        ; Save point
2F51: 23       [69]             inc     HL              ; Move on
2F52: 3630     [79]             ld      (HL),'0'        ; Save zero
2F54: 23       [85]             inc     HL              ; Move on
2F55: 05       [ 4]     DIGTXT: dec     B               ; Count digits before point
2F56: 362E     [14]             ld      (HL),'.'        ; Save point in case
2F58: CC9E2D   [24|31]          call    Z,INCHL         ; Last digit - move on
2F5B: C5       [35]             push    BC              ; Save digits before point
2F5C: E5       [46]             push    HL              ; Save buffer address
2F5D: D5       [57]             push    DE              ; Save powers of ten
2F5E: CD942D   [74]             call    BCDEFP          ; Move FPREG to BCDE
2F61: E1       [84]             pop     HL              ; Powers of ten table
2F62: 062F     [91]             ld      B,'0'-1         ; ASCII '0' - 1
2F64: 04       [ 4]     TRYAGN: inc     B               ; Count subtractions
2F65: 7B       [ 8]             ld      A,E             ; Get LSB
2F66: 96       [15]             sub     (HL)            ; Subtract LSB
2F67: 5F       [19]             ld      E,A             ; Save LSB
2F68: 23       [25]             inc     HL
2F69: 7A       [29]             ld      A,D             ; Get NMSB
2F6A: 9E       [36]             sbc     A,(HL)          ; Subtract NMSB
2F6B: 57       [40]             ld      D,A             ; Save NMSB
2F6C: 23       [46]             inc     HL
2F6D: 79       [50]             ld      A,C             ; Get MSB
2F6E: 9E       [57]             sbc     A,(HL)          ; Subtract MSB
2F6F: 4F       [61]             ld      C,A             ; Save MSB
2F70: 2B       [67]             dec     HL              ; Point back to start
2F71: 2B       [73]             dec     HL
2F72: D2642F   [83|83]          jp      NC,TRYAGN       ; No overflow - Try again
2F75: CD562B   [100]            call    PLUCDE          ; Restore number
2F78: 23       [106]            inc     HL              ; Start of next number
2F79: CD892D   [123]            call    FPBCDE          ; Move BCDE to FPREG
2F7C: EB       [127]            ex      DE,HL           ; Save point in table
2F7D: E1       [137]            pop     HL              ; Restore buffer address
2F7E: 70       [144]            ld      (HL),B          ; Save digit in buffer
2F7F: 23       [150]            inc     HL              ; And move on
2F80: C1       [160]            pop     BC              ; Restore digit count
2F81: 0D       [164]            dec     C               ; Count digits
2F82: C2552F   [174|174]        jp      NZ,DIGTXT       ; More - Do them
2F85: 05       [178]            dec     B               ; Any decimal part?
2F86: CA952F   [188|188]        jp      Z,DOEBIT        ; No - Do 'E' bit
2F89: 2B       [ 6]     SUPTLZ: dec     HL              ; Move back through buffer
2F8A: 7E       [13]             ld      A,(HL)          ; Get character
2F8B: FE30     [20]             cp      '0'             ; '0' character?
2F8D: CA892F   [30|30]          jp      Z,SUPTLZ        ; Yes - Look back for more
2F90: FE2E     [37]             cp      '.'             ; A decimal point?
2F92: C49E2D   [47|54]          call    NZ,INCHL        ; Move back over digit
                        
2F95: F1       [10]     DOEBIT: pop     AF              ; Get 'E' flag
2F96: CAB42F   [20|20]          jp      Z,NOENED        ; No 'E' needed - End buffer
2F99: 3645     [30]             ld      (HL),'E'        ; Put 'E' in buffer
2F9B: 23       [36]             inc     HL              ; And move on
2F9C: 362B     [46]             ld      (HL),'+'        ; Put '+' in buffer
2F9E: F2A52F   [56|56]          jp      P,OUTEXP        ; Positive - Output exponent
2FA1: 362D     [66]             ld      (HL),'-'        ; Put '-' in buffer
2FA3: 2F       [70]             cpl                     ; Negate exponent
2FA4: 3C       [74]             inc     A
2FA5: 062F     [ 7]     OUTEXP: ld      B,'0'-1         ; ASCII '0' - 1
2FA7: 04       [ 4]     EXPTEN: inc     B               ; Count subtractions
2FA8: D60A     [11]             sub     $0A             ; Tens digit
2FAA: D2A72F   [21|21]          jp      NC,EXPTEN       ; More to do
2FAD: C63A     [28]             add     A,'0'+10        ; Restore and make ASCII
2FAF: 23       [34]             inc     HL              ; Move on
2FB0: 70       [41]             ld      (HL),B          ; Save MSB of exponent
2FB1: 23       [ 6]     JSTZER: inc     HL              ;
2FB2: 77       [13]             ld      (HL),A          ; Save LSB of exponent
2FB3: 23       [19]             inc     HL
2FB4: 71       [ 7]     NOENED: ld      (HL),C          ; Mark end of buffer
2FB5: E1       [17]             pop     HL              ; Restore code string address
2FB6: C9       [27]             ret
                        
2FB7: 017494   [10]     RNGTST: ld      BC,$9474        ; BCDE = 999999.
2FBA: 11F723   [20]             ld      DE,$23F7
2FBD: CDC32D   [37]             call    CMPNUM          ; Compare numbers
2FC0: B7       [41]             or      A
2FC1: E1       [51]             pop     HL              ; Return address to HL
2FC2: E21F2F   [61|61]          jp      PO,GTSIXD       ; Too big - Divide by ten
2FC5: E9       [65]             jp      (HL)            ; Otherwise return to caller
                        
2FC6: 00000080          HALF:   defb    $00,$00,$00,$80 ; 0.5
                        
2FCA: A08601            POWERS: defb    $A0,$86,$01  ; 100000
2FCD: 102700                    defb    $10,$27,$00  ;  10000
2FD0: E80300                    defb    $E8,$03,$00  ;   1000
2FD3: 640000                    defb    $64,$00,$00  ;    100
2FD6: 0A0000                    defb    $0A,$00,$00  ;     10
2FD9: 010000                    defb    $01,$00,$00  ;      1
                        
2FDC: 21712D   [10]     NEGAFT: ld      HL,INVSGN       ; Negate result
2FDF: E3       [29]             ex      (SP),HL         ; To be done after caller
2FE0: E9       [33]             jp      (HL)            ; Return to caller
                        
2FE1: CD792D   [17]     SQR:    call    STAKFP          ; Put value on stack
2FE4: 21C62F   [27]             ld      HL,HALF         ; Set power to 1/2
2FE7: CD862D   [44]             call    PHLTFP          ; Move 1/2 to FPREG
                        
2FEA: C1       [10]     POWER:  pop     BC              ; Get base
2FEB: D1       [20]             pop     DE
2FEC: CD482D   [37]             call    TSTSGN          ; Test sign of power
2FEF: 78       [41]             ld      A,B             ; Get exponent of base
2FF0: CA2F30   [51|51]          jp      Z,EXP           ; Make result 1 if zero
2FF3: F2FA2F   [61|61]          jp      P,POWER1        ; Positive base - Ok
2FF6: B7       [65]             or      A               ; Zero to negative power?
2FF7: CAB515   [75|75]          jp      Z,DZERR         ; Yes - ?/0 Error
2FFA: B7       [ 4]     POWER1: or      A               ; Base zero?
2FFB: CA182B   [14|14]          jp      Z,SAVEXP        ; Yes - Return zero
2FFE: D5       [25]             push    DE              ; Save base
2FFF: C5       [36]             push    BC
3000: 79       [40]             ld      A,C             ; Get MSB of base
3001: F67F     [47]             or      %01111111       ; Get sign status
3003: CD942D   [64]             call    BCDEFP          ; Move power to BCDE
3006: F21730   [74|74]          jp      P,POWER2        ; Positive base - Ok
3009: D5       [85]             push    DE              ; Save power
300A: C5       [96]             push    BC
300B: CD1B2E   [113]            call    INT             ; Get integer of power
300E: C1       [123]            pop     BC              ; Restore power
300F: D1       [133]            pop     DE
3010: F5       [144]            push    AF              ; MSB of base
3011: CDC32D   [161]            call    CMPNUM          ; Power an integer?
3014: E1       [171]            pop     HL              ; Restore MSB of base
3015: 7C       [175]            ld      A,H             ; but don't affect flags
3016: 1F       [179]            rra                     ; Exponent odd or even?
3017: E1       [10]     POWER2: pop     HL              ; Restore MSB and exponent
3018: 222E82   [26]             ld      (FPREG+2),HL    ; Save base in FPREG
301B: E1       [36]             pop     HL              ; LSBs of base
301C: 222C82   [52]             ld      (FPREG),HL      ; Save in FPREG
301F: DCDC2F   [62|69]          call    C,NEGAFT        ; Odd power - Negate result
3022: CC712D   [72|79]          call    Z,INVSGN        ; Negative base - Negate it
3025: D5       [83]             push    DE              ; Save power
3026: C5       [94]             push    BC
3027: CDAB2B   [111]            call    LOG             ; Get LOG of base
302A: C1       [121]            pop     BC              ; Restore power
302B: D1       [131]            pop     DE
302C: CDEC2B   [148]            call    FPMULT          ; Multiply LOG by power
                        
302F: CD792D   [17]     EXP:    call    STAKFP          ; Put value on stack
3032: 013881   [27]             ld      BC,$8138        ; BCDE = 1/Ln(2)
3035: 113BAA   [37]             ld      DE,$AA3B
3038: CDEC2B   [54]             call    FPMULT          ; Multiply value by 1/LN(2)
303B: 3A2F82   [67]             ld      A,(FPEXP)       ; Get exponent
303E: FE88     [74]             cp      $80+8           ; Is it in range?
3040: D2242D   [84|84]          jp      NC,OVTST1       ; No - Test for overflow
3043: CD1B2E   [101]            call    INT             ; Get INT of FPREG
3046: C680     [108]            add     A,$80           ; For excess 128
3048: C602     [115]            add     A,$02           ; Exponent > 126?
304A: DA242D   [125|125]        jp      C,OVTST1        ; Yes - Test for overflow
304D: F5       [136]            push    AF              ; Save scaling factor
304E: 219A2B   [146]            ld      HL,UNITY        ; Point to 1.
3051: CDA22A   [163]            call    ADDPHL          ; Add 1 to FPREG
3054: CDE32B   [180]            call    MULLN2          ; Multiply by LN(2)
3057: F1       [190]            pop     AF              ; Restore scaling factor
3058: C1       [200]            pop     BC              ; Restore exponent
3059: D1       [210]            pop     DE
305A: F5       [221]            push    AF              ; Save scaling factor
305B: CDAE2A   [238]            call    SUBCDE          ; Subtract exponent from FPREG
305E: CD712D   [255]            call    INVSGN          ; Negate result
3061: 216F30   [265]            ld      HL,EXPTAB       ; Coefficient table
3064: CD9F30   [282]            call    SMSER1          ; Sum the series
3067: 110000   [292]            ld      DE,$0000        ; Zero LSBs
306A: C1       [302]            pop     BC              ; Scaling factor
306B: 4A       [306]            ld      C,D             ; Zero MSB
306C: C3EC2B   [316]            jp      FPMULT          ; Scale result to correct value
                        
306F: 08                EXPTAB: defb    $08             ; Table used by EXP
3070: 402E9474                  defb    $40,$2E,$94,$74 ; -1/7! (-1/5040)
3074: 704F2E77                  defb    $70,$4F,$2E,$77 ;  1/6! ( 1/720)
3078: 6E02887A                  defb    $6E,$02,$88,$7A ; -1/5! (-1/120)
307C: E6A02A7C                  defb    $E6,$A0,$2A,$7C ;  1/4! ( 1/24)
3080: 50AAAA7E                  defb    $50,$AA,$AA,$7E ; -1/3! (-1/6)
3084: FFFF7F7F                  defb    $FF,$FF,$7F,$7F ;  1/2! ( 1/2)
3088: 00008081                  defb    $00,$00,$80,$81 ; -1/1! (-1/1)
308C: 00000081                  defb    $00,$00,$00,$81 ;  1/0! ( 1/1)
                        
3090: CD792D   [17]     SUMSER: call    STAKFP          ; Put FPREG on stack
3093: 11EA2B   [27]             ld      DE,MULT         ; Multiply by "X"
3096: D5       [38]             push    DE              ; To be done after
3097: E5       [49]             push    HL              ; Save address of table
3098: CD942D   [66]             call    BCDEFP          ; Move FPREG to BCDE
309B: CDEC2B   [83]             call    FPMULT          ; Square the value
309E: E1       [93]             pop     HL              ; Restore address of table
309F: CD792D   [17]     SMSER1: call    STAKFP          ; Put value on stack
30A2: 7E       [24]             ld      A,(HL)          ; Get number of coefficients
30A3: 23       [30]             inc     HL              ; Point to start of table
30A4: CD862D   [47]             call    PHLTFP          ; Move coefficient to FPREG
30A7: 06                        defb    06H             ; Skip "pop AF"
30A8: F1       [10]     SUMLP:  pop     AF              ; Restore count
30A9: C1       [20]             pop     BC              ; Restore number
30AA: D1       [30]             pop     DE
30AB: 3D       [34]             dec     A               ; Cont coefficients
30AC: C8       [39|45]          ret     Z               ; All done
30AD: D5       [50]             push    DE              ; Save number
30AE: C5       [61]             push    BC
30AF: F5       [72]             push    AF              ; Save count
30B0: E5       [83]             push    HL              ; Save address in table
30B1: CDEC2B   [100]            call    FPMULT          ; Multiply FPREG by BCDE
30B4: E1       [110]            pop     HL              ; Restore address in table
30B5: CD972D   [127]            call    LOADFP          ; Number at HL to BCDE
30B8: E5       [138]            push    HL              ; Save address in table
30B9: CDB12A   [155]            call    FPADD           ; Add coefficient to FPREG
30BC: E1       [165]            pop     HL              ; Restore address in table
30BD: C3A830   [175]            jp      SUMLP           ; More coefficients
                        
30C0: CD482D   [17]     RND:    call    TSTSGN          ; Test sign of FPREG
30C3: 217A80   [27]             ld      HL,SEED+2       ; Random number seed
30C6: FA2131   [37|37]          jp      M,RESEED        ; Negative - Re-seed
30C9: 219B80   [47]             ld      HL,LSTRND       ; Last random number
30CC: CD862D   [64]             call    PHLTFP          ; Move last RND to FPREG
30CF: 217A80   [74]             ld      HL,SEED+2       ; Random number seed
30D2: C8       [79|85]          ret     Z               ; Return if RND(0)
30D3: 86       [86]             add     A,(HL)          ; Add (SEED)+2)
30D4: E607     [93]             and     %00000111       ; 0 to 7
30D6: 0600     [100]            ld      B,$00
30D8: 77       [107]            ld      (HL),A          ; Re-save seed
30D9: 23       [113]            inc     HL              ; Move to coefficient table
30DA: 87       [117]            add     A,A             ; 4 bytes
30DB: 87       [121]            add     A,A             ; per entry
30DC: 4F       [125]            ld      C,A             ; BC = Offset into table
30DD: 09       [136]            add     HL,BC           ; Point to coefficient
30DE: CD972D   [153]            call    LOADFP          ; Coefficient to BCDE
30E1: CDEC2B   [170]            call    FPMULT  ;       ; Multiply FPREG by coefficient
30E4: 3A7980   [183]            ld      A,(SEED+1)      ; Get (SEED+1)
30E7: 3C       [187]            inc     A               ; Add 1
30E8: E603     [194]            and     %00000011       ; 0 to 3
30EA: 0600     [201]            ld      B,$00
30EC: FE01     [208]            cp      $01             ; Is it zero?
30EE: 88       [212]            adc     A,B             ; Yes - Make it 1
30EF: 327980   [225]            ld      (SEED+1),A      ; Re-save seed
30F2: 212531   [235]            ld      HL,RNDTAB-4     ; Addition table
30F5: 87       [239]            add     A,A             ; 4 bytes
30F6: 87       [243]            add     A,A             ; per entry
30F7: 4F       [247]            ld      C,A             ; BC = Offset into table
30F8: 09       [258]            add     HL,BC           ; Point to value
30F9: CDA22A   [275]            call    ADDPHL          ; Add value to FPREG
30FC: CD942D   [17]     RND1:   call    BCDEFP          ; Move FPREG to BCDE
30FF: 7B       [21]             ld      A,E             ; Get LSB
3100: 59       [25]             ld      E,C             ; LSB = MSB
3101: EE4F     [32]             xor     %01001111       ; Fiddle around
3103: 4F       [36]             ld      C,A             ; New MSB
3104: 3680     [46]             ld      (HL),$80        ; Set exponent
3106: 2B       [52]             dec     HL              ; Point to MSB
3107: 46       [59]             ld      B,(HL)          ; Get MSB
3108: 3680     [69]             ld      (HL),$80        ; Make value -0.5
310A: 217880   [79]             ld      HL,SEED         ; Random number seed
310D: 34       [90]             inc     (HL)            ; Count seed
310E: 7E       [97]             ld      A,(HL)          ; Get seed
310F: D6AB     [104]            sub     $AB             ; Do it modulo 171
3111: C21831   [114|114]        jp      NZ,RND2         ; Non-zero - Ok
3114: 77       [121]            ld      (HL),A          ; Zero seed
3115: 0C       [125]            inc     C               ; Fillde about
3116: 15       [129]            dec     D               ; with the
3117: 1C       [133]            inc     E               ; number
3118: CD022B   [17]     RND2:   call    BNORM           ; Normalise number
311B: 219B80   [27]             ld      HL,LSTRND       ; Save random number
311E: C3A02D   [37]             jp      FPTHL           ; Move FPREG to last and return
                        
3121: 77       [ 7]     RESEED: ld      (HL),A          ; Re-seed random numbers
3122: 2B       [13]             dec     HL
3123: 77       [20]             ld      (HL),A
3124: 2B       [26]             dec     HL
3125: 77       [33]             ld      (HL),A
3126: C3FC30   [43]             jp      RND1            ; Return RND seed
                        
3129: 68B14668          RNDTAB: defb    $68,$B1,$46,$68 ; Table used by RND
312D: 99E99269                  defb    $99,$E9,$92,$69
3131: 10D17568                  defb    $10,$D1,$75,$68
                        
3135: 217F31   [10]     COS:    ld      HL,HALFPI       ; Point to PI/2
3138: CDA22A   [27]             call    ADDPHL          ; Add it to PPREG
313B: CD792D   [17]     SIN:    call    STAKFP          ; Put angle on stack
313E: 014983   [27]             ld      BC,$8349        ; BCDE = 2 PI
3141: 11DB0F   [37]             ld      DE,$0FDB
3144: CD892D   [54]             call    FPBCDE          ; Move 2 PI to FPREG
3147: C1       [64]             pop     BC              ; Restore angle
3148: D1       [74]             pop     DE
3149: CD9E2C   [91]             call    DVBCDE          ; Divide angle by 2 PI
314C: CD792D   [108]            call    STAKFP          ; Put it on stack
314F: CD1B2E   [125]            call    INT             ; Get INT of result
3152: C1       [135]            pop     BC              ; Restore number
3153: D1       [145]            pop     DE
3154: CDAE2A   [162]            call    SUBCDE          ; Make it 0 <= value < 1
3157: 218331   [172]            ld      HL,QUARTR       ; Point to 0.25
315A: CDA82A   [189]            call    SUBPHL          ; Subtract value from 0.25
315D: CD482D   [206]            call    TSTSGN          ; Test sign of value
3160: 37       [210]            scf                     ; Flag positive
3161: F26B31   [220|220]        jp      P,SIN1          ; Positive - Ok
3164: CD9F2A   [237]            call    ROUND           ; Add 0.5 to value
3167: CD482D   [254]            call    TSTSGN          ; Test sign of value
316A: B7       [258]            or      A               ; Flag negative
316B: F5       [11]     SIN1:   push    AF              ; Save sign
316C: F4712D   [21|28]          call    P,INVSGN        ; Negate value if positive
316F: 218331   [31]             ld      HL,QUARTR       ; Point to 0.25
3172: CDA22A   [48]             call    ADDPHL          ; Add 0.25 to value
3175: F1       [58]             pop     AF              ; Restore sign
3176: D4712D   [68|75]          call    NC,INVSGN       ; Negative - Make positive
3179: 218731   [78]             ld      HL,SINTAB       ; Coefficient table
317C: C39030   [88]             jp      SUMSER          ; Evaluate sum of series
                        
317F: DB0F4981          HALFPI: defb    $DB,$0F,$49,$81 ; 1.5708 (PI/2)
                        
3183: 0000007F          QUARTR: defb    $00,$00,$00,$7F ; 0.25
                        
3187: 05                SINTAB: defb    $05             ; Table used by SIN
3188: BAD71E86                  defb    $BA,$D7,$1E,$86 ; 39.711
318C: 64269987                  defb    $64,$26,$99,$87 ;-76.575
3190: 58342387                  defb    $58,$34,$23,$87 ; 81.602
3194: E05DA586                  defb    $E0,$5D,$A5,$86 ;-41.342
3198: DA0F4983                  defb    $DA,$0F,$49,$83 ;  6.2832
                        
319C: CD792D   [17]     TAN:    call    STAKFP          ; Put angle on stack
319F: CD3B31   [34]             call    SIN             ; Get SIN of angle
31A2: C1       [44]             pop     BC              ; Restore angle
31A3: E1       [54]             pop     HL
31A4: CD792D   [71]             call    STAKFP          ; Save SIN of angle
31A7: EB       [75]             ex      DE,HL           ; BCDE = Angle
31A8: CD892D   [92]             call    FPBCDE          ; Angle to FPREG
31AB: CD3531   [109]            call    COS             ; Get COS of angle
31AE: C39C2C   [119]            jp      DIV             ; TAN = SIN / COS
                        
31B1: CD482D   [17]     ATN:    call    TSTSGN          ; Test sign of value
31B4: FCDC2F   [27|34]          call    M,NEGAFT        ; Negate result after if -ve
31B7: FC712D   [37|44]          call    M,INVSGN        ; Negate value if -ve
31BA: 3A2F82   [50]             ld      A,(FPEXP)       ; Get exponent
31BD: FE81     [57]             cp      81H             ; Number less than 1?
31BF: DACE31   [67|67]          jp      C,ATN1          ; Yes - Get arc tangnt
31C2: 010081   [77]             ld      BC,$8100        ; BCDE = 1
31C5: 51       [81]             ld      D,C
31C6: 59       [85]             ld      E,C
31C7: CD9E2C   [102]            call    DVBCDE          ; Get reciprocal of number
31CA: 21A82A   [112]            ld      HL,SUBPHL       ; Sub angle from PI/2
31CD: E5       [123]            push    HL              ; Save for angle > 1
31CE: 21D831   [10]     ATN1:   ld      HL,ATNTAB       ; Coefficient table
31D1: CD9030   [27]             call    SUMSER          ; Evaluate sum of series
31D4: 217F31   [37]             ld      HL,HALFPI       ; PI/2 - angle in case > 1
31D7: C9       [47]             ret                     ; Number > 1 - Sub from PI/2
                        
31D8: 09                ATNTAB: defb    $09             ; Table used by ATN
31D9: 4AD73B78                  defb    $4A,$D7,$3B,$78 ; 1/17
31DD: 026E847B                  defb    $02,$6E,$84,$7B ;-1/15
31E1: FEC12F7C                  defb    $FE,$C1,$2F,$7C ; 1/13
31E5: 74319A7D                  defb    $74,$31,$9A,$7D ;-1/11
31E9: 843D5A7D                  defb    $84,$3D,$5A,$7D ; 1/9
31ED: C87F917E                  defb    $C8,$7F,$91,$7E ;-1/7
31F1: E4BB4C7E                  defb    $E4,$BB,$4C,$7E ; 1/5
31F5: 6CAAAA7F                  defb    $6C,$AA,$AA,$7F ;-1/3
31F9: 00000081                  defb    $00,$00,$00,$81 ; 1/1
                        
                        
31FD: C9       [10]     ARET:   ret                     ; A RETurn instruction
                        
31FE: D7       [11]     GETINP: rst     $10             ; input a character
31FF: C9       [21]             ret
                        
3200: E5       [11]     CLS:    push    HL
3201: D5       [22]             push    DE
3202: 3ACD81   [35]             ld      A,(SCR_MODE)    ; check screen mode
3205: FE02     [42]             cp      $02             ; G2 mode?
3207: CC8205   [52|59]          call    Z,EMPTYVIDBUF   ; yes, reset video buffer
320A: D1       [62]             pop     DE
320B: E1       [72]             pop     HL
320C: 3E0C     [79]             ld      A,CS            ; ASCII Clear screen
320E: CDD218   [96]             call    SND2VID         ; send to screen
3211: C3EE3D   [106]            jp      MONOUT          ; Output character
                        
3214: CDC027   [17]     WIDTH:  call    GETINT          ; Get integer 0-255
3217: 7B       [21]             ld      A,E             ; Width to A
3218: 32A280   [34]             ld      (LWIDTH),A      ; Set width
321B: C9       [44]             ret
                        
                        
321C: CD6D1B   [17]     DEEK:   call    DEINT           ; Get integer -32768 to 32767
321F: D5       [28]             push    DE              ; Save number
3220: E1       [38]             pop     HL              ; Number to HL
3221: 46       [ 7]     RECWRD: ld      B,(HL)          ; Get LSB of contents
3222: 23       [13]             inc     HL
3223: 7E       [20]             ld      A,(HL)          ; Get MSB of contents
3224: C32423   [30]             jp      ABPASS          ; Return integer AB
                        
3227: CD3A1F   [17]     DOKE:   call    GETNUM          ; Get a number
322A: CD6D1B   [34]             call    DEINT           ; Get integer -32768 to 32767
322D: D5       [45]             push    DE              ; Save address
322E: CD9418   [62]             call    CHKSYN          ; Make sure ',' follows
3231: 2C                        defb    ','
3232: CD3A1F   [79]             call    GETNUM          ; Get a number
3235: CD6D1B   [96]             call    DEINT           ; Get integer -32768 to 32767
3238: E3       [115]            ex      (SP),HL         ; Save value,get address
3239: 73       [122]            ld      (HL),E          ; Save LSB of value
323A: 23       [128]            inc     HL
323B: 72       [135]            ld      (HL),D          ; Save MSB of value
323C: E1       [145]            pop     HL              ; Restore code string address
323D: C9       [155]            ret
                        
                        ; stop the execution of code for a certain bit of time. The pause
                        ; is between $0000 and $FFFF 100ths of second (0~655.5 secs)
323E: CD3A1F   [17]     PAUSE:  call    GETNUM          ; Get a number
3241: CD6D1B   [34]             call    DEINT           ; Get integer -32768 to 32767
3244: 7A       [38]             ld      A,D             ; load D into A
3245: B3       [42]             or      E               ; are D & E equal to $00?
3246: C8       [47|53]          ret     Z               ; if yes, then return
3247: C5       [11]     DIR_PAU:push    BC              ; store BC
3248: 3ABB81   [24]             ld      A,(TMRCNT)      ; Load current value of system timer
324B: 47       [28]             ld      B,A             ; move it into B
324C: CDE21A   [17]     RPTPS:  call    TSTBRK          ; Test for break key
324F: 3ABB81   [30]             ld      A,(TMRCNT)      ; Load current value of system timer
3252: B8       [34]             cp      B               ; is it the same value?
3253: 28F7     [41|46]          jr      Z,RPTPS         ; yes, so read again
3255: 47       [45]             ld      B,A             ; no, so store the new value
3256: 1B       [51]             dec     DE              ; decrement interval
3257: 7A       [55]             ld      A,D             ; load D into A
3258: B3       [59]             or      E               ; check if DE is equal to 0 (if D & e are $00 then result is 0)
3259: 20F1     [66|71]          jr      NZ,RPTPS        ; no, repeat
325B: C1       [76]             pop     BC              ; yes, recover BC and continue
325C: C9       [86]             ret
                        
                        ; change the screen mode. Usage: SCREEN X[,Y][,Z]
                        ; where X is: 0=text mode (40x24),
                        ; 1=graphic mode 1 (32x24 chars); 2=graphic mode 2 (256x192 pixels);
                        ; 3=multicolor mode (64x48 pixels); 4=extended graphic mode 2 (32x24 chars mixed between G1 and G2)
                        ; Y is: 0=8x8 sprites, 1=16x16 sprites
                        ; Z is: 0=no sprite magnification; 1=sprite magnification x2 (8x8=>16x16, and 16x16=32x32)
                        ; (the latters are accepted only in graphic modes G1, G2, G3, and G4)
325D: AF       [ 4]     SCREEN: xor     A
325E: 32DE81   [17]             ld      (TMPBFR2),A     ; sprite size & magnif. byte set to 0
3261: CDC027   [34]             call    GETINT          ; Get integer 0-255
3264: FE05     [41]             cp      $05             ; is it a valid mode (0~4)?
3266: D2821B   [51|51]          jp      NC,FCERR        ; No - Illegal function call Error
3269: 32DC81   [64]             ld      (TMPBFR1),A     ; store graphic mode
326C: A7       [68]             and     A               ; is it 0 (text mode)?
326D: CA8932   [78|78]          jp      Z,SCVDP         ; yes, ignore other arguments and set mode immediately
3270: CDC832   [17]     SETVDP: call    CHKSCAR         ; no, check if sprite size follows
3273: DA7B32   [27|27]          jp      C,CKMAGN        ; no (set to 0 or missing), so jump over
3276: 3E02     [34]             ld      A,$02           ; no, so set sprite size
3278: 32DE81   [47]             ld      (TMPBFR2),A     ; ...to 16x16
327B: CDC832   [17]     CKMAGN: call    CHKSCAR         ; check if sprite magnification follows
327E: DA8932   [27|27]          jp      C,SCVDP         ; no (set to 0 or missing), so jump over
3281: 3ADE81   [40]             ld      A,(TMPBFR2)     ; yes, so retrieve sprite attributes...
3284: F601     [47]             or      $01             ; ...set sprite magnification to 2x...
3286: 32DE81   [60]             ld      (TMPBFR2),A     ; ...and save flags again
3289: F3       [ 4]     SCVDP:  di                      ; disable INTs
328A: D5       [15]             push    DE              ; store DE
328B: E5       [26]             push    HL              ; store HL
328C: 3ADC81   [39]             ld      A,(TMPBFR1)     ; recover graphic mode
328F: 5F       [43]             ld      E,A             ; and store it into E
3290: 3ADE81   [56]             ld      A,(TMPBFR2)     ; recover sprite flags
3293: 57       [60]             ld      D,A             ; and store them into D
3294: D5       [71]             push    DE              ; store D & E
3295: CD9903   [88]             call    initVDP         ; initialize VDP with mode pointed by E
3298: D1       [98]             pop     DE              ; retrieve D & E
3299: 7B       [102]            ld      A,E             ; move graphic mode into A
329A: 87       [106]            add     A,A
329B: 87       [110]            add     A,A
329C: 87       [114]            add     A,A             ; multiply A times 8 to get offset of graphic mode
329D: 5F       [118]            ld      E,A             ; and pass it into E
329E: D5       [129]            push    DE              ; store sprite flags in E
329F: 1600     [136]            ld      D,$00           ; reset D
32A1: 21750A   [146]            ld      HL,VDPMODESET+1 ; load address of VDP settings for reg#1
32A4: 19       [157]            add     HL,DE           ; load correct reg#1 setting
32A5: D1       [167]            pop     DE              ; retrieve sprite flags from E
32A6: 7E       [174]            ld      A,(HL)          ; load reg#1 setting
32A7: E6FC     [181]            and     %11111100       ; reset size & magn. bits
32A9: B2       [185]            or      D               ; set size & magn. bits
32AA: 5F       [189]            ld      E,A             ; value into E
32AB: 3E01     [196]            ld      A,$01           ; reg #1
32AD: CD5E06   [213]            call    WRITE_VREG      ; send setting to reg #1
32B0: 2AAF80   [229]            ld      HL,(LINEAT)     ; Get current line number
32B3: 23       [235]            inc     HL              ; -1 means direct statement
32B4: 7C       [239]            ld      A,H
32B5: B5       [243]            or      L
32B6: CC7508   [253|260]        call    Z,CURSOR_ON     ; enable cursor if not in program mode
32B9: FB       [257]            ei                      ; re-enable interrupts
32BA: E1       [267]            pop     HL              ; restore HL
32BB: D1       [277]            pop     DE              ; restore DE
32BC: 3ACC81   [290]            ld      A,(SCR_SIZE_H)  ; check the screen mode by looking at the screen height
32BF: FE30     [297]            cp      $30             ; is it 48 chars or 192 pixels (MC and G2 modes)?
32C1: D0       [302|308]        ret     NC              ; yes, so exit (in graphics 2 and multicolor no print-on-video)
32C2: 3E01     [309]            ld      A,$01           ; no (we are in Text, G1 or ExG2), so activate the...
32C4: 32D881   [322]            ld      (PRNTVIDEO),A   ; ...video buffer...
32C7: C9       [332]            ret                     ; ...and return to caller
                        
                        ; check an additional argument for SCREEN
32C8: 2B       [ 6]     CHKSCAR:dec     HL              ; dec 'cos GETCHR INCs
32C9: CDB71A   [23]             call    GETCHR          ; Get next character
32CC: 37       [27]             scf                     ; set carry flag
32CD: C8       [32|38]          ret     Z               ; return if nothing follows with Carry=1
32CE: CD9418   [49]             call    CHKSYN          ; Make sure ',' follows
32D1: 2C                        defb    ','
32D2: CDC027   [66]             call    GETINT          ; get value
32D5: 1F       [70]             rra                     ; Carry=bit #0
32D6: 3F       [74]             ccf                     ; invert Carry, so Carry=0 if arg. is 1, and Carry=1 otherwise (arg<>1)
32D7: C9       [84]             ret                     ; return
                        
                        
                        ; change the colors of the screen - Syntax is COLOR a,b,c where:
                        ; a=foreground color / b=background color / c=border color
                        ; a,b,c must be in a range between 1 and 15 (0 is transparent and it's not supported)
32D8: CDC027   [17]     COLOR:  call    GETINT          ; get first value
32DB: CD8133   [34]             call    CHKCLR1         ; check if it's in range 1~15
32DE: 32DC81   [47]             ld      (TMPBFR1),A     ; store it
32E1: 3ACD81   [60]             ld      A,(SCR_MODE)    ; check screen mode
32E4: FE03     [67]             cp      $03             ; is it multicolor mode?
32E6: 200D     [74|79]          jr      NZ,CNTCKCL      ; no, continue
32E8: 3E0F     [81]             ld      A,$0F           ; white for...
32EA: 32DA81   [94]             ld      (FRGNDCLR),A    ; ...foreground (even it's not used in MC)
32ED: 3ADC81   [107]            ld      A,(TMPBFR1)     ; yes, so we stop here because in MC mode we just support border color
32F0: 32E081   [120]            ld      (TMPBFR3),A     ; move color into temp buffer 3
32F3: 1831     [132]            jr      CLRMC           ; jump to set color
32F5: CD9418   [17]     CNTCKCL:call    CHKSYN          ; Make sure ',' follows
32F8: 2C                        defb    ','
32F9: CDC027   [34]             call    GETINT          ; get second value
32FC: CD8133   [51]             call    CHKCLR1         ; check if it's in range 1~15
32FF: 32DE81   [64]             ld      (TMPBFR2),A     ; store it
3302: 3ACD81   [77]             ld      A,(SCR_MODE)    ; check screen mode
3305: A7       [81]             and     A               ; is it text mode?
3306: 281B     [88|93]          jr      Z,CLRTXT        ; yes, stop here because in text mode, background and border colors coincide
3308: CD9418   [105]            call    CHKSYN          ; Make sure ',' follows
330B: 2C                        defb    ','
330C: CDC027   [122]            call    GETINT          ; get third value
330F: CD8133   [139]            call    CHKCLR1         ; check if it's in range 1~15
3312: 32E081   [152]            ld      (TMPBFR3),A     ; store it
3315: D5       [163]            push    DE              ; store DE
3316: 3ACD81   [176]            ld      A,(SCR_MODE)    ; check screen mode
3319: FE01     [183]            cp      $01             ; is it G1 mode?
331B: 2810     [190|195]        jr      Z,CLRG1         ; yes, jump over
331D: FE02     [197]            cp      $02             ; is it G2 mode?
331F: 2815     [204|209]        jr      Z,CLRG2         ; yes, jump over
3321: 181C     [216]            jr      CLREX2          ; last case can only be ExG2
3323: CD7433   [17]     CLRTXT: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
3326: 32E081   [13]     CLRMC:  ld      (TMPBFR3),A     ; store color settings (for MC mode, we only set border color)
3329: D5       [24]             push    DE              ; store DE
332A: F3       [28]             di                      ; disable INTs
332B: 182E     [40]             jr      SETBRCL         ; set colors and exit
332D: CD7433   [17]     CLRG1:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
3330: 1601     [24]             ld      D,$01           ; repeat 1 time
3332: 0620     [31]             ld      B,$20           ; 32 bytes of colors
3334: 1810     [43]             jr      LOADCLR         ; load colors
3336: CD7433   [17]     CLRG2:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
3339: 1618     [24]             ld      D,$18           ; 18 pages of...
333B: 0600     [31]             ld      B,$00           ; ...256 bytes each
333D: 1807     [43]             jr      LOADCLR         ; load colors
333F: CD7433   [17]     CLREX2: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
3342: 1608     [24]             ld      D,$08           ; 8 pages of...
3344: 0600     [31]             ld      B,$00           ; ...256 bytes each
3346: E5       [11]     LOADCLR:push    HL              ; store HL
3347: 210020   [21]             ld      HL,$2000        ; color table start: $2000
334A: F3       [25]             di                      ; disable INTs
334B: CD1406   [42]             call    SETVDPADRS
334E: 0E30     [49]             ld      C,VDP_DAT       ; VDP data mode
3350: ED79     [12]     RPTLDCL:out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
3352: 00       [16]             nop
3353: 00       [20]             nop
3354: 10FA     [28|33]          djnz    RPTLDCL         ; repeat for 256 bytes (1 page)
3356: 15       [32]             dec     D               ; did we fill up all the pages?
3357: 20F7     [39|44]          jr      NZ,RPTLDCL      ; no, repeat
3359: FB       [43]             ei
335A: E1       [53]             pop     HL              ; retrieve HL
335B: 3ADC81   [13]     SETBRCL:ld      A,(TMPBFR1)     ; retrieve foreground color
335E: 32DA81   [26]             ld      (FRGNDCLR),A    ; store it
3361: 3ADE81   [39]             ld      A,(TMPBFR2)     ; retrieve background color
3364: 32DB81   [52]             ld      (BKGNDCLR),A    ; store it
3367: 3AE081   [65]             ld      A,(TMPBFR3)     ; recover border color
336A: 5F       [69]             ld      E,A             ; move it into E
336B: 3E07     [76]             ld      A,$07           ; set VDP register 7
336D: F3       [80]             di
336E: CD5E06   [97]             call    WRITE_VREG      ; send value to VDP: set border color
3371: FB       [101]            ei                      ; re-enable INTs
3372: D1       [111]            pop     DE              ; retrieve DE
3373: C9       [121]            ret                     ; return to caller
                        
                        
                        ; mix 2 color nibbles in 1 byte
3374: 3ADE81   [13]     MIXCLRS:ld      A,(TMPBFR2)     ; retrieve background color
3377: 47       [17]             ld      B,A             ; move it into B
3378: 3ADC81   [30]             ld      A,(TMPBFR1)     ; retrieve foreground color
337B: 87       [34]             add     A,A             ; move foreground color into the high nibble of A
337C: 87       [38]             add     A,A
337D: 87       [42]             add     A,A
337E: 87       [46]             add     A,A
337F: B0       [50]             or      B               ; put background color into the low nibble of A
3380: C9       [60]             ret                     ; return to caller
                        
                        
                        ; check if the color is not 0 and into the range 1~15
3381: A7       [ 4]     CHKCLR1:and     A               ; is it 0?
3382: CAB215   [14|14]          jp      Z,SNERR         ; yes, raise a SN error
3385: FE10     [ 7]     CHKCLR0:cp      $10             ; is it in range 0~15?
3387: D2B215   [17|17]          jp      NC,SNERR        ; no, raise a SN error
338A: C9       [27]             ret                     ; param is OK, can return
                        
                        
                        ; check if in graphics 2 mode
338B: 3ACD81   [13]     CHKG2M: ld      A,(SCR_MODE)    ; check screen mode
338E: FE02     [20]             cp      $02             ; actually, we can paint only in G2
3390: C29139   [30|30]          jp      NZ,GMERR        ; no G2, print a No Graphics Mode Error
3393: C9       [40]             ret                     ; return to caller
                        
                        
                        ; print a text in screen 2
                        ; GPRINT text,x,y[,fc[,bc]]
                        ; where "text" is an expression that can be converted into a sequence of ASCII chars,
                        ; x & y are the coordinates (0<=x<=31, 0<=y<=23), fc & bc are foreground and background
                        ; colors (1~15), resp.
                        ; (portions of code are from nippur72)
81E0:                   GX      equ     TMPBFR3
81E2:                   GY      equ     TMPBFR4
81DE:                   TMPCLR  equ     TMPBFR2
81DC:                   MIXCOL  equ     TMPBFR1
81E4:                   TMPADR  equ     VIDEOBUFF
81E6:                   CHRPNT  equ     VIDEOBUFF+$02
81E8:                   NUMCHR  equ     VIDEOBUFF+$04
81EA:                   TMPHL   equ     VIDEOBUFF+$06
3394: CD8B33   [17]     GPRINT: call    CHKG2M          ; check if in graphic mode 2
3397: 2B       [23]             dec     HL              ; dec 'cos GETCHR INCs
3398: CDB71A   [40]             call    GETCHR          ; check if something follows
339B: CAB215   [50|50]          jp      Z,SNERR         ; if nothing else, raise a syntax error
339E: 22E481   [66]             ld      (VIDEOBUFF),HL  ; save current code string pointer
33A1: CD4C1F   [83]             call    EVAL            ; Evaluate expression
33A4: CD3E1F   [100]            call    TSTSTR          ; Make sure it's a string
33A7: 22EA81   [116]            ld      (TMPHL),HL      ; store code string pointer
33AA: CD8525   [133]            call    GSTRCU          ; Current string to pool
33AD: CD972D   [150]            call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
33B0: ED43E681 [170]            ld      (CHRPNT),BC     ; store string pointer
33B4: ED53E881 [190]            ld      (NUMCHR),DE     ; store string lenght
33B8: 2AEA81   [206]            ld      HL,(TMPHL)      ; store code string pointer
33BB: CD9418   [223]            call    CHKSYN          ; Make sure ',' follows
33BE: 2C                        defb    ','
33BF: CDC027   [240]            call    GETINT          ; get X coord.
33C2: FE20     [247]            cp      $20             ; is it in rage 0~31?
33C4: D2821B   [257|257]        jp      NC,FCERR        ; Illegal function call error
33C7: 32E081   [270]            ld      (GX),A          ; store into temp. buffer
33CA: CD9418   [287]            call    CHKSYN          ; Make sure ',' follows
33CD: 2C                        defb    ','
33CE: CDC027   [304]            call    GETINT          ; get Y coord.
33D1: FE18     [311]            cp      $18             ; is it in range 0~23?
33D3: D2821B   [321|321]        jp      NC,FCERR        ; Illegal function call error
33D6: 32E281   [334]            ld      (GY),A          ; store into temp. buffer
33D9: 11DE81   [344]            ld      DE,TMPCLR
33DC: 3ADB81   [357]            ld      A,(BKGNDCLR)    ; load background color
33DF: 12       [364]            ld      (DE),A          ; store into temp buff
33E0: 3ADA81   [377]            ld      A,(FRGNDCLR)    ; load foreground color
33E3: 1B       [383]            dec     DE
33E4: 1B       [389]            dec     DE
33E5: 12       [396]            ld      (DE),A          ; store into temp buff
33E6: CD7234   [413]            call    CKCOL           ; check color
33E9: CAF133   [423|423]        jp      Z,CNTGPT2       ; if anything follows, jump over
33EC: 13       [429]            inc     DE
33ED: 13       [435]            inc     DE
33EE: CD7234   [452]            call    CKCOL           ; check background color
33F1: CD7433   [17]     CNTGPT2:call    MIXCLRS         ; mix foreground & background colors
33F4: 32DC81   [30]             ld      (MIXCOL),A      ; store mixed colors
33F7: E5       [41]             push    HL              ; store code string address
33F8: ED4BE681 [61]             ld      BC,(CHRPNT)     ; retrieve string pointer
33FC: ED5BE881 [81]             ld      DE,(NUMCHR)     ; retrieve string lenght
3400: 1C       [85]             inc     E               ; Length + 1
3401: CD0634   [102]            call    GPNT            ; print on G2
3404: E1       [112]            pop     HL              ; recover HL
3405: C9       [122]            ret                     ; return to caller
3406: D5       [11]     GPNT:   push    DE              ; store string lenght (E)
                                ; calculate VRAM address of first char
3407: 3AE081   [24]             LD      A,(GX)          ; load X
340A: 6F       [28]             ld      L,A             ;
340B: 2600     [35]             ld      H,0             ; HL = X
340D: 29       [46]             add     HL,HL           ;
340E: 29       [57]             add     HL,HL           ;
340F: 29       [68]             add     HL,HL           ; X=X*8
3410: 3AE281   [81]             ld      A,(GY)          ; load Y
3413: 57       [85]             ld      D,A             ; move it into D
3414: 1E00     [92]             ld      E,0             ; DE =Y*256
3416: 19       [103]            add     HL,DE           ; address = X*8 + Y*256
3417: 22E481   [119]            ld      (TMPADR),HL     ; store VRAM address of first VRAM cell
341A: D1       [129]            pop     DE              ; retrieve # of chars to be printed yet (E)
341B: 1D       [ 4]     RPGPNT: dec     E               ; Count characters
341C: C8       [ 9|15]          ret     Z               ; End of string - return
341D: D5       [20]             push    DE              ; store chars counter
                                ; calculate dest address in color vram
341E: 2AE481   [36]             ld      HL,(TMPADR)     ; recover VRAM address 
3421: 110020   [46]             ld      DE,$2000        ; color map address
3424: 19       [57]             add     HL,DE           ; HL = $2000 + XY address
3425: F3       [61]             di                      ; disable INTs
                                ; send color settings
3426: CD1406   [17]     GPNTCOL:call    SETVDPADRS      ; set VRAM address for color cell
3429: 3ADC81   [30]             ld      A,(MIXCOL)      ; load color settings
342C: 0608     [37]             ld      B,$08           ; repeat for 8 rows
342E: 0E30     [44]             ld      C,VDP_DAT       ; VDP data mode
3430: ED79     [12]     GPNTCO1:out     (C),A           ; send data (VRAM pointer auto-increments)
3432: 00       [16]             nop                     ; wait...
3433: 00       [20]             nop                     ; ...a...
3434: 00       [24]             nop                     ; ...while
3435: 10F9     [32|37]          djnz    GPNTCO1         ; repeat for 8 cells
                                ; calculate source address
3437: 2AE681   [48]             ld      HL,(CHRPNT)     ; load char pointer
343A: 7E       [55]             ld      A,(HL)          ; get char
343B: 23       [61]             inc     HL              ; increment char pointer
343C: 22E681   [77]             ld      (CHRPNT),HL     ; store char pointer
343F: 6F       [81]             ld      L,A             ;
3440: 2600     [88]             ld      H,0             ; char into HL
3442: 29       [99]             add     HL,HL           ;
3443: 29       [110]            add     HL,HL           ;
3444: 29       [121]            add     HL,HL           ; get offset of char into ROM (charcode * 8)
3445: 117846   [131]            ld      DE,CHRST88      ; DE = start of 8x8 fonts in ROM
3448: 19       [142]            add     HL,DE           ; HL = start of characters in ROM
3449: EB       [146]            ex      DE,HL           ; store address into DE
344A: 2AE481   [16]     GPCPCHR:ld      HL,(TMPADR)     ; load VRAM address
344D: CD1406   [33]             call    SETVDPADRS      ; send it to VDP
3450: EB       [37]             ex      DE,HL           ; restore address into HL
3451: 0608     [44]             ld      B,$08           ; repeat for 8 rows
3453: 0E30     [51]             ld      C,VDP_DAT       ; VDP data mode
3455: EDA3     [16]     GPCPCH1:outi                    ; load a byte from ROM and send to VRAM
3457: 00       [20]             nop                     ; wait...
3458: 00       [24]             nop                     ; ...a...
3459: 00       [28]             nop                     ; ...while
345A: 20F9     [35|40]          jr      NZ,GPCPCH1      ; repeat for 8 chars
345C: FB       [39]             ei                      ; re-enable INTs
345D: 110800   [49]             ld      DE,$0008        ; 8 bytes to go to the next video ell
3460: 2AE481   [65]             ld      HL,(TMPADR)     ; load VRAM address
3463: 19       [76]             add     HL,DE           ; get address of next VRAM cell
3464: 22E481   [92]             ld      (TMPADR),HL     ; store new VRAM address
3467: 110018   [102]            ld      DE,$1800        ; forbidden address
346A: CD153E   [119]            call    CMP16           ; check if the printing has gone out of the screen
346D: D1       [129]            pop     DE              ; retrieve number of chars to be printed
346E: D0       [134|140]        ret     NC              ; if HL>=$1800 then leave
346F: C31B34   [144]            jp      RPGPNT          ; otherwise, check if more chars to output
                                
3472: 2B       [ 6]     CKCOL:  dec     HL              ; dec 'cos GETCHR INCs
3473: CDB71A   [23]             call    GETCHR          ; Get next character
3476: C8       [28|34]          ret     Z               ; return if nothing follows
3477: CD9418   [45]             call    CHKSYN          ; Make sure ',' follows
347A: 2C                        defb    ','
347B: D5       [56]             push    DE              ; store DE
347C: CDC027   [73]             call    GETINT          ; get value
347F: CD8133   [90]             call    CHKCLR1         ; check if color is in range 1~15
3482: D1       [100]            pop     DE              ; retrieve DE
3483: 12       [107]            ld      (DE),A          ; store color into temp buffer
3484: C9       [117]            ret                     ; return to caller
                                
                        
                        ; paint X,Y[,C]: in graphics mode, fills an area starting
                        ; at point X,Y, using default color or, if used, with
                        ; color set by C
                        ; TMPBFR1       X
                        ; TMPBFR2       Y
                        ; TMPBFR3       COLOR
81E4:                   PNT     equ     VIDEOBUFF
81E6:                   SPA     equ     VIDEOBUFF+$02
81E7:                   SPB     equ     VIDEOBUFF+$03
81E8:                   ORGSP   equ     VIDEOBUFF+$04
3485: CD8B33   [17]     PAINT:  call    CHKG2M          ; check if in graphic mode 2
3488: CDC027   [34]             call    GETINT          ; get X
348B: 32DC81   [47]             ld      (TMPBFR1),A     ; store X
348E: CD9418   [64]             call    CHKSYN          ; Make sure ',' follows
3491: 2C                        defb    ','
3492: CDC027   [81]             call    GETINT          ; get Y coords,
3495: FEC0     [88]             cp      $C0             ; check if Y is in range 0~191
3497: D2821B   [98|98]          jp      NC,FCERR        ; no, raise an FC error
349A: 32DE81   [111]            ld      (TMPBFR2),A     ; store Y
349D: CD7839   [128]            call    CLRPRM          ; check if color has been passed
34A0: 3AE081   [141]            ld      A,(TMPBFR3)     ; load color
34A3: A7       [145]            and     A               ; check if 0
34A4: CA821B   [155|155]        jp      Z,FCERR         ; yes, raise an error
34A7: E5       [166]            push    HL              ; store HL
34A8: C5       [177]            push    BC              ; store BC
34A9: D5       [188]            push    DE              ; store DE
                                ; start algorithm
34AA: CDBD35   [205]            call    PNTRTN          ; check if pixel is already set
34AD: C26135   [215|215]        jp      NZ,EXITPA2      ; if yes, then leave PAINT
34B0: ED73E881 [235]            ld      (ORGSP),SP      ; no, store current Stack Pointer
34B4: 210100   [245]            ld      HL,$0001        ; HL=1
34B7: 22E481   [261]            ld      (PNT),HL        ; set PNT
34BA: 3ADC81   [274]            ld      A,(TMPBFR1)     ; load starting X...
34BD: 47       [278]            ld      B,A             ; ...into B
34BE: 3ADE81   [291]            ld      A,(TMPBFR2)     ; load starting Y...
34C1: 4F       [295]            ld      C,A             ; ...into C
34C2: C5       [306]            push    BC              ; store starting X,Y into stack
                                ; main loop
34C3: 2AE481   [16]     NXTLOOP:ld      HL,(PNT)        ; retrieve PNT
34C6: 7C       [20]             ld      A,H             ; check if PNT=0
34C7: B5       [24]             or      L
34C8: CA5D35   [34|34]          jp      Z,EXITPAI       ; yes, no more points to process - exit
34CB: 2B       [40]             dec     HL              ; no, so decrement PNT...
34CC: 22E481   [56]             ld      (PNT),HL        ; ...and store it
34CF: C1       [66]             pop     BC              ; retrieve pixel coordinates X,Y into BC
34D0: CD6535   [17]     PAINT0: call    CHECKPA         ; check if pixel is set/reset
34D3: 2009     [24|29]          jr      NZ,PAINT11      ; pixel is set, so jump over
34D5: 78       [28]             ld      A,B             ; pixel is reset, check if X1=0
34D6: A7       [32]             and     A               ; (reached the limit of the screen)
34D7: CADF34   [42|42]          jp      Z,PAINT1        ; yes, jump over
34DA: 05       [46]             dec     B               ; no, decrement X1...
34DB: C3D034   [56]             jp      PAINT0          ; ...and repeat
34DE: 04       [ 4]     PAINT11:inc     B               ; if found a pixel on, the re-increment X1
34DF: AF       [ 4]     PAINT1: xor     A               ; reset A
34E0: 57       [ 8]             ld      D,A             ; set SA=0
34E1: 5F       [12]             ld      E,A             ; set SB=0
34E2: CD6535   [17]     MNPAINT:call    CHECKPA         ; check if pixel is set/reset
34E5: 20DC     [24|29]          jr      NZ,NXTLOOP      ; it's set, so goto next loop
34E7: 78       [28]             ld      A,B             ; copy X1
34E8: 32DC81   [41]             ld      (TMPBFR1),A     ; into buffer
34EB: 79       [45]             ld      A,C             ; copy Y
34EC: 32DE81   [58]             ld      (TMPBFR2),A     ; into buffer
34EF: CDE335   [75]             call    CNTPLOT         ; plot pixel X1,Y
34F2: 7A       [79]             ld      A,D             ; load SA into A
34F3: A7       [83]             and     A               ; SA=0?
34F4: 201C     [90|95]          jr      NZ,PAINT2       ; no, jump over
34F6: 79       [94]             ld      A,C             ; load Y
34F7: FE01     [101]            cp      $01             ; Y>0?
34F9: DA1235   [111|111]        jp      C,PAINT2        ; no, jump over
34FC: 3D       [115]            dec     A               ; yes, Y=Y-1
34FD: CD6635   [132]            call    CHECKPY         ; check pixel X1,Y-1
3500: 2010     [139|144]        jr      NZ,PAINT2       ; it's set, so jump over
3502: 0D       [143]            dec     C               ; Y=Y-1
3503: C5       [154]            push    BC              ; insert pixel(X1,Y-1) into stack
3504: 0C       [158]            inc     C               ; retrieve original Y
3505: 2AE481   [174]            ld      HL,(PNT)        ; load PNT
3508: 23       [180]            inc     HL              ; increment PNT
3509: 22E481   [196]            ld      (PNT),HL        ; store new PNT
350C: 3E01     [203]            ld      A,$01           ; set SA=1 and...
350E: 57       [207]            ld      D,A             ; ...store SA into memory
350F: C32535   [217]            jp      PAINT3          ; jump over
3512: 7A       [ 4]     PAINT2: ld      A,D             ; load SA into A
3513: 1F       [ 8]             rra                     ; check if SA=1
3514: 300F     [15|20]          jr      NC,PAINT3       ; no, jump over
3516: 79       [19]             ld      A,C             ; load Y
3517: FE01     [26]             cp      $01             ; Y>0?
3519: DA2535   [36|36]          jp      C,PAINT3        ; no, jump over
351C: 3D       [40]             dec     A               ; Y=Y-1
351D: CD6635   [57]             call    CHECKPY         ; check pixel X1,Y-1
3520: CA2535   [67|67]          jp      Z,PAINT3        ; if pixel is off, jump over
3523: AF       [71]             xor     A               ; pixel is on, so...
3524: 57       [75]             ld      D,A             ; ...set SA=0
3525: 7B       [ 4]     PAINT3: ld      A,E             ; check if...
3526: A7       [ 8]             and     A               ; SB=0
3527: 201B     [15|20]          jr      NZ,PAINT4       ; no, jump over
3529: 79       [19]             ld      A,C             ; load Y
352A: FEBF     [26]             cp      $BF             ; Y<191?
352C: 3016     [33|38]          jr      NC,PAINT4       ; no, jump over
352E: 3C       [37]             inc     A               ; Y=Y+1
352F: CD6635   [54]             call    CHECKPY         ; check pixel X1,Y+1
3532: 2010     [61|66]          jr      NZ,PAINT4       ; pixel is on, so jump over
3534: 0C       [65]             inc     C               ; Y=Y+1
3535: C5       [76]             push    BC              ; insert pixel(X1,Y+1) into stack
3536: 0D       [80]             dec     C               ; retrieve original Y
3537: 2AE481   [96]             ld      HL,(PNT)        ; PNT
353A: 23       [102]            inc     HL              ; PNT=PNT+1
353B: 22E481   [118]            ld      (PNT),HL        ; store PNT
353E: 3E01     [125]            ld      A,$01           ; SB=1
3540: 5F       [129]            ld      E,A             ; set SB
3541: C35635   [139]            jp      PAINT5          ; jump over
3544: 7B       [ 4]     PAINT4: ld      A,E             ; load SB
3545: 1F       [ 8]             rra                     ; check if SB=1
3546: 300E     [15|20]          jr      NC,PAINT5       ; no, jump over
3548: 79       [19]             ld      A,C             ; load Y
3549: FEBF     [26]             cp      $BF             ; Y<191?
354B: 3009     [33|38]          jr      NC,PAINT5       ; no, jump over
354D: 3C       [37]             inc     A               ; Y=Y+1
354E: CD6635   [54]             call    CHECKPY         ; check pixel X1,Y+1
3551: CA5635   [64|64]          jp      Z,PAINT5        ; if pixel is off, jump over
3554: AF       [68]             xor     A               ; pixel is on, so...
3555: 5F       [72]             ld      E,A             ; ...set SB=0
3556: 04       [ 4]     PAINT5: inc     B               ; X1=X1+1
3557: CAC334   [14|14]          jp      Z,NXTLOOP       ; if X1>255 (X1=0) then goto next loop
355A: C3E234   [24]             jp      MNPAINT         ; otherwise, repeat for next X
355D: ED7BE881 [20]     EXITPAI:ld      SP,(ORGSP)      ; retrieve original SP pointer
3561: D1       [10]     EXITPA2:pop     DE              ; retrieve DE
3562: C1       [20]             pop     BC              ; retrieve BC
3563: E1       [30]             pop     HL              ; retrieve HL
3564: C9       [40]             ret                     ; return to caller
3565: 79       [ 4]     CHECKPA:ld      A,C             ; copy Y into A
3566: 32DE81   [13]     CHECKPY:ld      (TMPBFR2),A     ; store Y
3569: 78       [17]             ld      A,B             ; copy X1 into A
356A: 32DC81   [30]             ld      (TMPBFR1),A     ; store X1
356D: C5       [41]             push    BC              ; save X1,Y
356E: D5       [52]             push    DE
356F: CDBD35   [69]             call    PNTRTN          ; check if pixel is set/reset
3572: D1       [79]             pop     DE
3573: C1       [89]             pop     BC              ; retrieve X1,Y
3574: C9       [99]             ret                     ; return to caller
                        
                        
                        ; POINT(x,y): return if a pixel is set (returns color) or if it's reset (0)
3575: CD8B33   [17]     POINT:  call    CHKG2M          ; check if in graphic mode 2
3578: CD9418   [34]             call    CHKSYN          ; make sure "(" follows
357B: 28                        defb    '('
357C: CDC027   [51]             call    GETINT          ; get X coords.
357F: 32DC81   [64]             ld      (TMPBFR1),A     ; store it into a temp buffer
3582: CD9418   [81]             call    CHKSYN          ; Make sure ',' follows
3585: 2C                        defb    ','
3586: CDC027   [98]             call    GETINT          ; get Y coords,
3589: FEC0     [105]            cp      $C0             ; check if Y is in range 0~191
358B: D2821B   [115|115]        jp      NC,FCERR        ; no, raise an FC error
358E: 32DE81   [128]            ld      (TMPBFR2),A     ; store into a temp buffer
3591: CD9418   [145]            call    CHKSYN          ; make sure ")" follows
3594: 29                        defb    ')'
3595: E5       [156]            push    HL              ; store current string address - the point after the ")" - ...
3596: FDE1     [170]            pop     IY              ; ...into IY
3598: CDBD35   [187]            call    PNTRTN          ; check if pixel is set or reset
359B: 200C     [194|199]        jr      NZ,CTPOINT      ; it's ON, jump over
359D: AF       [198]            xor     A               ; no, it's OFF. make sure to reset A...
359E: 47       [202]            ld      B,A             ; ...and B
359F: E1       [10]     PNTEND: pop     HL              ; drop original return point
35A0: FDE5     [25]             push    IY              ; load current string address from IY into stack
35A2: 112520   [35]             ld      DE,RETNUM       ; Address of Return number from function...
35A5: D5       [46]             push    DE              ; ...saved on stack
35A6: C32423   [56]             jp      ABPASS          ; return AB
35A9: CBEC     [ 8]     CTPOINT:set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
35AB: F3       [12]             di
35AC: CD3406   [29]             call    READ_VIDEO_LOC  ; load original colors of pixel
35AF: FB       [33]             ei
35B0: CB3F     [41]             srl     A               ; shift A...
35B2: CB3F     [49]             srl     A               ; ...4 times...
35B4: CB3F     [57]             srl     A               ; ...to move foreground color...
35B6: CB3F     [65]             srl     A               ; ...into lowest nibble
35B8: 47       [69]             ld      B,A             ; color into B
35B9: AF       [73]             xor     A               ; reset MSB
35BA: C39F35   [83]             jp      PNTEND          ; return AB
35BD: CD3036   [17]     PNTRTN: call    XY2HL           ; find HL address of pixel at X,Y
35C0: 57       [21]             ld      D,A             ; store pixel index
35C1: F3       [25]             di                      ; disable INTs
35C2: CD3406   [42]             call    READ_VIDEO_LOC  ; read contents of VRAM cell addressed by HL
35C5: FB       [46]             ei                      ; re-enable INTs
35C6: A2       [50]             and     D               ; is the pixel ON or OFF? (will be checked later)
35C7: C9       [60]             ret                     ; return to caller
                        
                        
                        ; PLOT X,Y[,color]
                        ; plot a pixel in graphic mode 2
35C8: CD8B33   [17]     PLOT:   call    CHKG2M          ; check if in G2 mode
35CB: CDC027   [34]             call    GETINT          ; get X coords.
35CE: 32DC81   [47]             ld      (TMPBFR1),A     ; store it into a temp buffer
35D1: CD9418   [64]             call    CHKSYN          ; Make sure ',' follows
35D4: 2C                        defb    ','
35D5: CDC027   [81]             call    GETINT          ; get Y coords,
35D8: FEC0     [88]             cp      $C0             ; check if Y is in range 0~191
35DA: D2821B   [98|98]          jp      NC,FCERR        ; no, raise an FC error
35DD: 32DE81   [111]            ld      (TMPBFR2),A     ; store into a temp buffer
35E0: CD7839   [128]            call    CLRPRM          ; check if param "color" has been passed
35E3: E5       [11]     CNTPLOT:push    HL              ; store HL
35E4: C5       [22]             push    BC              ; store BC
35E5: D5       [33]             push    DE              ; store DE
35E6: CD3036   [50]             call    XY2HL           ; find VRAM address of byte containing pixel at X,Y & return into HL
35E9: D22436   [60|60]          jp      NC,NOGD         ; if carry is reset, there was an error -> so leave
35EC: 57       [64]             ld      D,A             ; move pixel value into D
35ED: 3AE081   [77]             ld      A,(TMPBFR3)     ; retrieve color
35F0: A7       [81]             and     A               ; is it 0? (background, or reset pixel)
35F1: 2011     [88|93]          jr      NZ,CNTPLT1      ; no, continue
35F3: F3       [92]             di                      ; yes - so, disable INTs
35F4: CD3406   [109]            call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
35F7: FB       [113]            ei                      ; re-enable INTs
35F8: 5F       [117]            ld      E,A             ; store value of cell
35F9: 7A       [121]            ld      A,D             ; retrieve pixel
35FA: 2F       [125]            cpl                     ; revert bits
35FB: A3       [129]            and     E               ; set video pixel to off
35FC: F3       [133]            di                      ; disable INTs
35FD: CD4906   [150]            call    WRITE_VIDEO_LOC ; write new value into VRAM cell
3600: FB       [154]            ei                      ; re-enable INTs
3601: C32436   [164]            jp      NOGD            ; leave
3604: 87       [ 4]     CNTPLT1:add     A,A             ; now we move low nibble
3605: 87       [ 8]             add     A,A             ; in the high nibble
3606: 87       [12]             add     A,A             ; by adding A to itself
3607: 87       [16]             add     A,A             ; 4 times (this is a shift left 4)
3608: 5F       [20]             ld      E,A             ; move it into E
3609: F3       [24]             di                      ; disable INTs
360A: CD3406   [41]             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
360D: FB       [45]             ei
360E: B2       [49]             or      D               ; plot new pixel preserving original pattern
360F: F3       [53]             di
3610: CD4906   [70]             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
3613: FB       [74]             ei
3614: CBEC     [82]             set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
3616: F3       [86]             di
3617: CD3406   [103]            call    READ_VIDEO_LOC  ; load original colors of pixel
361A: FB       [107]            ei
361B: E60F     [114]            and     %00001111       ; reset high nibble (the foreground color)
361D: B3       [118]            or      E               ; set new foreground color
361E: F3       [122]            di
361F: CD4906   [139]            call    WRITE_VIDEO_LOC ; write new color settings
3622: FB       [143]            ei                      ; re-enable INTs
3623: 00       [147]            nop                     ; wait for INTs to be enabled again
3624: D1       [10]     NOGD:   pop     DE              ; retrieve DE
3625: C1       [20]             pop     BC              ; retrieve BC
3626: E1       [30]             pop     HL              ; retrieve HL
3627: C9       [40]             ret                     ; return to caller
3628: 80402010          PXLSET: defb    $80,$40,$20,$10,$08,$04,$02,$01 ; pixel to be set ON
362C: 08040201          
                                ; where R(X/8)=> 0=80h, 1=40h, 2=20h, 3=10h, 4=08h, 5=04h, 6=02h, 7=$01
                        
                        
                        ; compute the VRAM address of the byte containing the pixel
                        ; being pointed by X,Y (TMPBFR1,TMPBFR1)
                        ; byte address is returned into HL
                        ; pixel is returned into A
3630:                   XY2HL:  ; formula is: ADDRESS=(INT(X/8))*8 + (INT(Y/8))*256 + R(Y/8)
                                ; where R(Y/8) is the remainder of (Y/8)
                                ; the pixel to be set is given by R(X/8), and data is taken from the array
3630: 3ADE81   [13]             ld      A,(TMPBFR2)     ; retrieve Y
3633: FEC0     [20]             cp      $C0             ; Y>=192?
3635: D0       [25|31]          ret     NC              ; yes, so leave
3636: 1E08     [32]             ld      E,$08           ; load E with divisor
3638: 57       [36]             ld      D,A             ; and store into D (dividend)
3639: CD443E   [53]             call    DIV_8_8         ; get Y/8, D is quotient=INT(Y/8), and A is remainder
363C: 4F       [57]             ld      C,A             ; store remainder into C
363D: 42       [61]             ld      B,D             ; B=(INT(Y/8))*256 (we simply copy quotient into B)
363E: 6069     [69]             ld      HL,BC           ; copy BC into HL: now HL has the VRAM address of the byte being set
3640: 3ADC81   [82]             ld      A,(TMPBFR1)     ; retrieve X
3643: 57       [86]             ld      D,A             ; and move it into D (dividend)
3644: CD443E   [103]            call    DIV_8_8         ; get X/8, D is quotient=INT(X/8), and A is remainder
3647: 4F       [107]            ld      C,A             ; store remainder into C
3648: 7A       [111]            ld      A,D             ; move quotient into A
3649: 87       [115]            add     A,A
364A: 87       [119]            add     A,A
364B: 87       [123]            add     A,A             ; multiply quotient by 8
364C: 5F       [127]            ld      E,A             ; store result into E
364D: 1600     [134]            ld      D,$00           ; reset D
364F: 19       [145]            add     HL,DE           ; add DE to HL, getting the final VRAM address
3650: EB       [149]            ex      DE,HL           ; move VRAM address into DE
3651: 212836   [159]            ld      HL,PXLSET       ; starting address of table for pixel to draw
3654: 0600     [166]            ld      B,$00           ; reset B
3656: 09       [177]            add     HL,BC           ; add C (remainder of X/8) to get address of pixel to turn on
3657: 7E       [184]            ld      A,(HL)          ; load pixel data
3658: EB       [188]            ex      DE,HL           ; retrieve VRAM pattern address into HL
3659: 37       [192]            scf                     ; set Carry for normal exit
365A: C9       [202]            ret                     ; return to caller
                        
                        
                        ; DRAW X1,Y1,X2,Y2[,color]
                        ; Draw a line using Bresenham's line algorithm from X1,Y1 to X2,Y2
                        ; X1,Y1 can be either less than or greater than X2,Y2 (meaning that)
                        ; the drawing will be ever done from X1,Y2 to X2,Y2, regardless of
                        ; the values. If color is not specified, the foreground color set
                        ; with COLOR will be used 
81DC:                   X1      equ     TMPBFR1
81DE:                   Y1      equ     TMPBFR2
81E4:                   X2      equ     VIDEOBUFF
81E6:                   Y2      equ     VIDEOBUFF+$02
81E8:                   ER      equ     VIDEOBUFF+$04
81EA:                   E2      equ     VIDEOBUFF+$06
81EC:                   SX      equ     VIDEOBUFF+$08
81EE:                   SY      equ     VIDEOBUFF+$0A
81F0:                   DX      equ     VIDEOBUFF+$0C
81F2:                   DY      equ     VIDEOBUFF+$0E
365B: CD8B33   [17]     DRAW:   call    CHKG2M          ; check if in G2 mode
365E: CD6039   [34]             call    CLRVDBF         ; clear VIDEOBUFF
3661: CDC027   [51]             call    GETINT          ; get X1 coords.
3664: 32DC81   [64]             ld      (X1),A          ; store it into a temp buffer
3667: CD9418   [81]             call    CHKSYN          ; Make sure ',' follows
366A: 2C                        defb    ','
366B: CDC027   [98]             call    GETINT          ; get Y1 coords.
366E: FEC0     [105]            cp      $C0             ; check if Y1 is in range 0~191
3670: D2821B   [115|115]        jp      NC,FCERR        ; no, raise an FC error
3673: 32DE81   [128]            ld      (Y1),A          ; store into a temp buffer
3676: CD9418   [145]            call    CHKSYN          ; Make sure ',' follows
3679: 2C                        defb    ','
367A: CDC027   [162]            call    GETINT          ; get X2 coords.
367D: 32E481   [175]            ld      (X2),A          ; store it into a temp buffer
3680: CD9418   [192]            call    CHKSYN          ; Make sure ',' follows
3683: 2C                        defb    ','
3684: CDC027   [209]            call    GETINT          ; get Y2 coords
3687: FEC0     [216]            cp      $C0             ; check if Y2 is in range 0~191
3689: D2821B   [226|226]        jp      NC,FCERR        ; no, raise an FC error
368C: 32E681   [239]            ld      (Y2),A          ; store it into a temp buffer
368F: CD7839   [256]            call    CLRPRM          ; check for arg. "color" and store it into TMPBFR3
3692: E5       [267]            push    HL              ; store register we'll use
3693: D5       [278]            push    DE              
3694: C5       [289]            push    BC
3695: ED5BDC81 [309]            ld      DE,(X1)         ; load X1 and
3699: 2AE481   [325]            ld      HL,(X2)         ; X2
369C: B7       [329]            or      A               ; clear CARRY
369D: ED52     [344]            sbc     HL,DE           ; DX=X2-X1
369F: CD3A3E   [361]            call    absHL           ; DX=ABS(DX)
36A2: 22F081   [377]            ld      (DX),HL         ; store DX
36A5: 01FFFF   [387]            ld      BC,$FFFF        ; SX=-1
36A8: 2ADC81   [403]            ld      HL,(X1)
36AB: ED5BE481 [423]            ld      DE,(X2)
36AF: CD153E   [440]            call    CMP16           ; X1<X2?
36B2: CABB36   [450|450]        jp      Z,X1GR          ; no, X1=X2
36B5: F2BB36   [460|460]        jp      P,X1GR          ; no, X1>X2
36B8: 010100   [470]            ld      BC,$0001        ; yes, so set SX=1
36BB: ED43EC81 [20]     X1GR:   ld      (SX),BC         ; store SX
36BF: ED5BDE81 [40]             ld      DE,(Y1)
36C3: 2AE681   [56]             ld      HL,(Y2)
36C6: B7       [60]             or      A               ; clear Carry
36C7: ED52     [75]             sbc     HL,DE           ; DY=Y2-Y1
36C9: CD3A3E   [92]             call    absHL           ; DY=ABS(DY)
36CC: 22F281   [108]            ld      (DY),HL         ; store DY
36CF: 01FFFF   [118]            ld      BC,$FFFF        ; SY=-1
36D2: 2ADE81   [134]            ld      HL,(Y1)
36D5: ED5BE681 [154]            ld      DE,(Y2)
36D9: CD153E   [171]            call    CMP16           ; is Y1<Y2?
36DC: CAE536   [181|181]        jp      Z,Y1GR          ; no, Y1=Y2
36DF: F2E536   [191|191]        jp      P,Y1GR          ; no, Y1>Y2 - jump over
36E2: 010100   [201]            ld      BC,$0001        ; yes, so set SY=1
36E5: ED43EE81 [20]     Y1GR:   ld      (SY),BC         ; store SY
36E9: 2AF281   [36]             ld      HL,(DY)         ; ER=DY
36EC: CD3D3E   [53]             call    negHL           ; ER=-DY
36EF: 22E881   [69]             ld      (ER),HL         ; store ER
36F2: 2AF081   [85]             ld      HL,(DX)
36F5: ED5BF281 [105]            ld      DE,(DY)
36F9: CD153E   [122]            call    CMP16           ; DX>DY?
36FC: CA0837   [132|132]        jp      Z,ER2           ; no, DX=DY
36FF: FA0837   [142|142]        jp      M,ER2           ; no, DX<DY
3702: 2AF081   [158]            ld      HL,(DX)         ; reload DX
3705: 22E881   [174]            ld      (ER),HL         ; yes: DX>DY, so ER=DX
3708: 2AE881   [16]     ER2:    ld      HL,(ER)         ; load ER
370B: CB2C     [24]             sra     H               ; right shift (and preserve sign)...
370D: CB1D     [32]             rr      L               ; ...of HL, so ER=INT(ER/2)
370F: CB7C     [40]             bit     7,H             ; is the number negative?
3711: CA1537   [50|50]          jp      Z,STRE2         ; no, jump over
3714: 23       [56]             inc     HL              ; yes, add 1 'cos INT of a negative number needs to be incremented
3715: 22E881   [16]     STRE2:  ld      (ER),HL         ; store ER
3718: CDE335   [17]     RPTDRW: call    CNTPLOT         ; plot first pixel
371B: 2ADC81   [33]             ld      HL,(X1)
371E: ED5BE481 [53]             ld      DE,(X2)
3722: CD153E   [70]             call    CMP16           ; X1=X2?
3725: 200D     [77|82]          jr      NZ,CNTDRW       ; no, continue drawing
3727: 2ADE81   [93]             ld      HL,(Y1)         ; yes, so check
372A: ED5BE681 [113]            ld      DE,(Y2)         ; also Y
372E: CD153E   [130]            call    CMP16           ; Y1=Y2?
3731: CA8D37   [140|140]        jp      Z,ENDDRAW       ; yes, finished drawing: exit
3734: ED5BE881 [20]     CNTDRW: ld      DE,(ER)
3738: ED53EA81 [40]             ld      (E2),DE         ; E2=ER
373C: 2AF081   [56]             ld      HL,(DX)
373F: CD3D3E   [73]             call    negHL           ; DX=-DX
3742: EB       [77]             ex      DE,HL           ; invert DE and HL => HL=E2, DE=-DX
3743: CD153E   [94]             call    CMP16           ; E2>-DX?
3746: CA6437   [104|104]        jp      Z,DXGR          ; no, E2=-DX: jump
3749: FA6437   [114|114]        jp      M,DXGR          ; no, E2<-DX: jump
374C: 2AE881   [130]            ld      HL,(ER)         ; yes
374F: ED5BF281 [150]            ld      DE,(DY)
3753: B7       [154]            or      A               ; clear CARRY
3754: ED52     [169]            sbc     HL,DE           ; ER=ER-DY
3756: 22E881   [185]            ld      (ER),HL
3759: 2ADC81   [201]            ld      HL,(X1)
375C: ED5BEC81 [221]            ld      DE,(SX)
3760: 19       [232]            add     HL,DE           ; X1=X1+SX (increment X1)
3761: 22DC81   [248]            ld      (X1),HL
3764: 2AEA81   [16]     DXGR:   ld      HL,(E2)
3767: ED5BF281 [36]             ld      DE,(DY)
376B: CD153E   [53]             call    CMP16           ; E2<DY?
376E: CA1837   [63|63]          jp      Z,RPTDRW        ; no, E2=DY: jump
3771: F21837   [73|73]          jp      P,RPTDRW        ; no, E2>DY: jump
3774: 2AE881   [89]             ld      HL,(ER)         ; yes
3777: ED5BF081 [109]            ld      DE,(DX)
377B: 19       [120]            add     HL,DE           ; ER=ER+DX
377C: 22E881   [136]            ld      (ER),HL
377F: 2ADE81   [152]            ld      HL,(Y1)
3782: ED5BEE81 [172]            ld      DE,(SY)
3786: 19       [183]            add     HL,DE           ; Y1=Y1+SY (increment Y1)
3787: 22DE81   [199]            ld      (Y1),HL
378A: C31837   [209]            jp      RPTDRW          ; repeat
378D: C1       [10]     ENDDRAW:pop     BC              ; retrieve BC
378E: D1       [20]             pop     DE              ; retrieve DE
378F: E1       [30]             pop     HL              ; retrieve HL
3790: C9       [40]             ret                     ; return to caller
                        
                        
                        ; CIRCLE X,Y,R[,C]
                        ; Draw a circle using Bresenham's circle algorithm with center in X,Y
                        ; and radius R, with optional color C. If color is not specified, the
                        ; foreground color set with COLOR will be used 
81E4:                   XC      equ     VIDEOBUFF
81E6:                   YC      equ     VIDEOBUFF+$02
81E8:                   RADIUS  equ     VIDEOBUFF+$04
81EA:                   XI      equ     VIDEOBUFF+$06
81EC:                   YI      equ     VIDEOBUFF+$08
81EE:                   DC      equ     VIDEOBUFF+$0A
3791: CD8B33   [17]     CIRCLE: call    CHKG2M          ; check if in G2 mode
3794: CD6039   [34]             call    CLRVDBF         ; clear VIDEOBUFF
3797: CDC027   [51]             call    GETINT          ; get X coords.
379A: 32E481   [64]             ld      (XC),A          ; store it into a temp buffer
379D: CD9418   [81]             call    CHKSYN          ; Make sure ',' follows
37A0: 2C                        defb    ','
37A1: CDC027   [98]             call    GETINT          ; get Y coords,
37A4: 32E681   [111]            ld      (YC),A          ; store it into a temp buffer
37A7: CD9418   [128]            call    CHKSYN          ; Make sure ',' follows
37AA: 2C                        defb    ','
37AB: CDC027   [145]            call    GETINT          ; get radius
37AE: 32E881   [158]            ld      (RADIUS),A      ; store it into a temp buffer
37B1: CD7839   [175]            call    CLRPRM          ; check if param "color" has been passed
37B4: C5       [186]            push    BC              ; store BC
37B5: D5       [197]            push    DE              ; store DE
37B6: E5       [208]            push    HL              ; store HL
37B7: AF       [212]            xor     A               ; clear A,
37B8: 47       [216]            ld      B,A             ; B,
37B9: 4F       [220]            ld      C,A             ; C,
37BA: 57       [224]            ld      D,A             ; D,
37BB: 67       [228]            ld      H,A             ; and H
37BC: ED43EA81 [248]            ld      (XI),BC         ; clear XI
37C0: 3AE881   [261]            ld      A,(RADIUS)      ; load RADIUS into A
37C3: 6F       [265]            ld      L,A             ; HL now contains R
37C4: 22EC81   [281]            ld      (YI),HL         ; YI=RADIUS
37C7: 29       [292]            add     HL,HL           ; R*2
37C8: EB       [296]            ex      DE,HL           ; put HL into DE
37C9: 210300   [306]            ld      HL,$0003        ; now HL is 3
37CC: AF       [310]            xor     A               ; clear Carry
37CD: ED52     [325]            sbc     HL,DE           ; HL=>D=3-(2*R)
37CF: 22EE81   [341]            ld      (DC),HL         ; store D
37D2: CD3138   [358]            call    DRWCRL          ; draw initial point
37D5: ED5BEA81 [20]     RPTCRL: ld      DE,(XI)         ; load XI
37D9: 2AEC81   [36]             ld      HL,(YI)         ; load YI
37DC: CD153E   [53]             call    CMP16           ; is YI<DI?
37DF: CAE837   [63|63]          jp      Z,RPTCL1        ; no, YI=XI
37E2: F2E837   [73|73]          jp      P,RPTCL1        ; no, YI>XI
37E5: C32D38   [83]             jp      ENDCRL          ; yes, so we've finished
37E8: 21EA81   [10]     RPTCL1: ld      HL,XI
37EB: 34       [21]             inc     (HL)            ; XI=XI+1
37EC: 2AEE81   [37]             ld      HL,(DC)         ; load D
37EF: 7C       [41]             ld      A,H
37F0: B5       [45]             or      L               ; is D=0? Yes, jump over
37F1: CA1538   [55|55]          jp      Z,DLSZ
37F4: CB7C     [63]             bit     7,H             ; is D<0?
37F6: 201D     [70|75]          jr      NZ,DLSZ         ; yes, jump over
37F8: ED5BEC81 [90]             ld      DE,(YI)         ; D>0
37FC: 1B       [96]             dec     DE              ; so, YI=YI-1
37FD: ED53EC81 [116]            ld      (YI),DE         ; store YI
3801: AF       [120]            xor     A               ; clear Carry
3802: 2AEA81   [136]            ld      HL,(XI)
3805: ED52     [151]            sbc     HL,DE           ; HL=XI-YI
3807: 29       [162]            add     HL,HL
3808: 29       [173]            add     HL,HL           ; HL=HL*4
3809: 110A00   [183]            ld      DE,10
380C: 19       [194]            add     HL,DE           ; HL=HL+10
380D: ED5BEE81 [214]            ld      DE,(DC)         ; load D
3811: EB       [218]            ex      DE,HL           ; invert DE and HL, so that HL=4*(XI-YI)+10 and DE=D
3812: 19       [229]            add     HL,DE           ; D=D+4*(XI-YI)+10
3813: 180F     [241]            jr      PLTCRL          ; plot next pixel
3815: 2AEA81   [16]     DLSZ:   ld      HL,(XI)         ; load XI
3818: 29       [27]             add     HL,HL
3819: 29       [38]             add     HL,HL           ; XI=XI*4
381A: 110600   [48]             ld      DE,$0006
381D: 19       [59]             add     HL,DE
381E: ED5BEE81 [79]             ld      DE,(DC)
3822: EB       [83]             ex      DE,HL           ; HL=D and DE=4*XI+6
3823: 19       [94]             add     HL,DE           ; D=D+4*XI+6
3824: 22EE81   [16]     PLTCRL: ld      (DC),HL         ; store new D
3827: CD3138   [33]             call    DRWCRL          ; plot pixel
382A: C3D537   [43]             jp      RPTCRL          ; repeat
382D: E1       [10]     ENDCRL: pop     HL
382E: D1       [20]             pop     DE
382F: C1       [30]             pop     BC
3830: C9       [40]             ret                     ; return to caller
3831: 2AE481   [16]     DRWCRL: ld      HL,(XC)
3834: ED5BEA81 [36]             ld      DE,(XI)
3838: 19       [47]             add     HL,DE           ; X=XC+XI
3839: 22DC81   [63]             ld      (X1),HL         ; store X
383C: CD5039   [80]             call    VALIDX          ; check if X is valid (0~255)
383F: DA5338   [90|90]          jp      C,CNTCL1        ; if Carry is set, X is not valid
3842: 2AE681   [106]            ld      HL,(YC)
3845: ED5BEC81 [126]            ld      DE,(YI)
3849: 19       [137]            add     HL,DE           ; Y=YC+YI
384A: 22DE81   [153]            ld      (Y1),HL         ; store Y
384D: CD5539   [170]            call    VALIDY          ; check if Y is valid (0~191)
3850: D4E335   [180|187]        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
3853: AF       [ 4]     CNTCL1: xor     A               ; clear Carry
3854: 2AE481   [20]             ld      HL,(XC)
3857: ED5BEA81 [40]             ld      DE,(XI)
385B: ED52     [55]             sbc     HL,DE           ; X=XC-XI
385D: 22DC81   [71]             ld      (X1),HL         ; store X
3860: CD5039   [88]             call    VALIDX          ; check if X is valid (0~255)
3863: DA7738   [98|98]          jp      C,CNTCL2        ; if Carry is set, X is not valid
3866: 2AE681   [114]            ld      HL,(YC)
3869: ED5BEC81 [134]            ld      DE,(YI)
386D: 19       [145]            add     HL,DE           ; Y=YC+YI
386E: 22DE81   [161]            ld      (Y1),HL         ; store Y
3871: CD5539   [178]            call    VALIDY          ; check if Y is valid (0~191)
3874: D4E335   [188|195]        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
3877: 2AE481   [16]     CNTCL2: ld      HL,(XC)
387A: ED5BEA81 [36]             ld      DE,(XI)
387E: 19       [47]             add     HL,DE           ; X=XC+XI
387F: 22DC81   [63]             ld      (X1),HL         ; store X
3882: CD5039   [80]             call    VALIDX          ; check if X is valid (0~255)
3885: DA9B38   [90|90]          jp      C,CNTCL3        ; if Carry is set, X is not valid
3888: AF       [94]             xor     A               ; clear Carry
3889: 2AE681   [110]            ld      HL,(YC)
388C: ED5BEC81 [130]            ld      DE,(YI)
3890: ED52     [145]            sbc     HL,DE           ; Y=YC-YI
3892: 22DE81   [161]            ld      (Y1),HL         ; store Y
3895: CD5539   [178]            call    VALIDY          ; check if Y is valid (0~191)
3898: D4E335   [188|195]        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
389B: AF       [ 4]     CNTCL3: xor     A               ; clear Carry
389C: 2AE481   [20]             ld      HL,(XC)
389F: ED5BEA81 [40]             ld      DE,(XI)
38A3: ED52     [55]             sbc     HL,DE           ; X=XC-XI
38A5: 22DC81   [71]             ld      (X1),HL         ; store X
38A8: CD5039   [88]             call    VALIDX          ; check if X is valid (0~255)
38AB: DAC138   [98|98]          jp      C,CNTCL4        ; if Carry is set, X is not valid
38AE: AF       [102]            xor     A               ; clear Carry
38AF: 2AE681   [118]            ld      HL,(YC)
38B2: ED5BEC81 [138]            ld      DE,(YI)
38B6: ED52     [153]            sbc     HL,DE           ; Y=YC-YI
38B8: 22DE81   [169]            ld      (Y1),HL         ; store Y
38BB: CD5539   [186]            call    VALIDY          ; check if Y is valid (0~191)
38BE: D4E335   [196|203]        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
38C1: 2AE481   [16]     CNTCL4: ld      HL,(XC)
38C4: ED5BEC81 [36]             ld      DE,(YI)
38C8: 19       [47]             add     HL,DE           ; X=XC+YI
38C9: 22DC81   [63]             ld      (X1),HL         ; store X
38CC: CD5039   [80]             call    VALIDX          ; check if X is valid (0~255)
38CF: DAE338   [90|90]          jp      C,CNTCL5        ; if Carry is set, X is not valid
38D2: 2AE681   [106]            ld      HL,(YC)
38D5: ED5BEA81 [126]            ld      DE,(XI)
38D9: 19       [137]            add     HL,DE           ; Y=YC+XI
38DA: 22DE81   [153]            ld      (Y1),HL         ; store Y
38DD: CD5539   [170]            call    VALIDY          ; check if Y is valid (0~191)
38E0: D4E335   [180|187]        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
38E3: AF       [ 4]     CNTCL5: xor     A               ; clear Carry
38E4: 2AE481   [20]             ld      HL,(XC)
38E7: ED5BEC81 [40]             ld      DE,(YI)
38EB: ED52     [55]             sbc     HL,DE           ; X=XC-YI
38ED: 22DC81   [71]             ld      (X1),HL         ; store X
38F0: CD5039   [88]             call    VALIDX          ; check if X is valid (0~255)
38F3: DA0739   [98|98]          jp      C,CNTCL6        ; if Carry is set, X is not valid
38F6: 2AE681   [114]            ld      HL,(YC)
38F9: ED5BEA81 [134]            ld      DE,(XI)
38FD: 19       [145]            add     HL,DE           ; Y=YC+XI
38FE: 22DE81   [161]            ld      (Y1),HL         ; store Y
3901: CD5539   [178]            call    VALIDY          ; check if Y is valid (0~191)
3904: D4E335   [188|195]        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
3907: 2AE481   [16]     CNTCL6: ld      HL,(XC)
390A: ED5BEC81 [36]             ld      DE,(YI)
390E: 19       [47]             add     HL,DE           ; X=XC+YI
390F: 22DC81   [63]             ld      (X1),HL         ; store X
3912: CD5039   [80]             call    VALIDX          ; check if X is valid (0~255)
3915: DA2B39   [90|90]          jp      C,CNTCL7        ; if Carry is set, X is not valid
3918: AF       [94]             xor     A               ; clear Carry
3919: 2AE681   [110]            ld      HL,(YC)
391C: ED5BEA81 [130]            ld      DE,(XI)
3920: ED52     [145]            sbc     HL,DE           ; Y=YC-XI
3922: 22DE81   [161]            ld      (Y1),HL         ; store Y
3925: CD5539   [178]            call    VALIDY          ; check if Y is valid (0~191)
3928: D4E335   [188|195]        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
392B: AF       [ 4]     CNTCL7: xor     A               ; clear Carry
392C: 2AE481   [20]             ld      HL,(XC)
392F: ED5BEC81 [40]             ld      DE,(YI)
3933: ED52     [55]             sbc     HL,DE           ; X=XC-YI
3935: 22DC81   [71]             ld      (X1),HL         ; store X
3938: CD5039   [88]             call    VALIDX          ; check if X is valid (0~255)
393B: D8       [93|99]          ret     C               ; if Carry is set, X is not valid
393C: AF       [97]             xor     A               ; clear Carry
393D: 2AE681   [113]            ld      HL,(YC)
3940: ED5BEA81 [133]            ld      DE,(XI)
3944: ED52     [148]            sbc     HL,DE           ; Y=YC-XI
3946: 22DE81   [164]            ld      (Y1),HL         ; store Y
3949: CD5539   [181]            call    VALIDY          ; check if Y is valid (0~191)
394C: D4E335   [191|198]        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
394F: C9       [201]            ret                     ; return to caller
                        
                        ; check if X,Y coordinates are valid: 0<=X<=255 and 0<=Y<=191
                        ; input: HL (value to check), can be negative
                        ; output: CARRY flag: reset => VALID  //  set => NOT VALID
                        ; destroys: A
3950: AF       [ 4]     VALIDX: xor     A               ; reset A
3951: B4       [ 8]             or      H               ; check if H is 0 (this means that X is in range 0~255 and not negative)
3952: C8       [13|19]          ret     Z               ; yes, we can return (C is clear)
3953: 37       [17]             scf                     ; set Carry flag to raise error
3954: C9       [27]             ret                     ; return to caller
                        
3955: AF       [ 4]     VALIDY: xor     A               ; reset A
3956: B4       [ 8]             or      H               ; check if H is 0 (this means that Y is in range 0~255 and not negative)
3957: 2802     [15|20]          jr      Z,CNTVALY       ; yes, continue checking
3959: 37       [19]             scf                     ; no, raise error by setting Carry flag
395A: C9       [29]             ret                     ; return to caller
395B: 7D       [ 4]     CNTVALY:ld      A,L
395C: FEC0     [11]             cp      $C0             ; is Y<192? Carry is set if Y<192
395E: 3F       [15]             ccf                     ; invert Carry, so Carry=0 means OK, Carry=1 means ERROR
395F: C9       [25]             ret                     ; return to caller
                        
                        
                        ; clear VIDEOBUFF before using it as temp buffer
3960: AF       [ 4]     CLRVDBF:xor     A               ; clear A
3961: C5       [15]             push    BC              ; store BC
3962: E5       [26]             push    HL              ; store HL
3963: 21DC81   [36]             ld      HL,TMPBFR1      ; address of 1st cell
3966: 0606     [43]             ld      B,$06           ; 6 cells
3968: 77       [ 7]     RPTCVB1:ld      (HL),A          ; clear cell
3969: 23       [13]             inc     HL              ; next cell
396A: 10FC     [21|26]          djnz    RPTCVB1         ; repeat
396C: 0628     [28]             ld      B,$28           ; 40 cells
396E: 21E481   [38]             ld      HL,VIDEOBUFF    ; address of 1st cell
3971: 77       [ 7]     RPTCVB2:ld      (HL),A          ; clear cell
3972: 23       [13]             inc     HL              ; next cell
3973: 10FC     [21|26]          djnz    RPTCVB2         ; repeat
3975: E1       [31]             pop     HL              ; retrieve HL
3976: C1       [41]             pop     BC              ; retrieve BC
3977: C9       [51]             ret                     ; return to caller
                        
                        
                        ; check if a color is passed as argument with PLOT, DRAW, and CIRCLE
                        ; commands. If not present, the default foreground color will be used
3978: 3ADA81   [13]     CLRPRM: ld      A,(FRGNDCLR)    ; load foreground color
397B: 32E081   [26]             ld      (TMPBFR3),A     ; store into temp buffer
397E: 2B       [32]             dec     HL              ; dec 'cos GETCHR INCs
397F: CDB71A   [49]             call    GETCHR          ; Get next character
3982: C8       [54|60]          ret     Z               ; return foreground color if nothing follows
3983: CD9418   [71]             call    CHKSYN          ; Make sure ',' follows
3986: 2C                        defb    ','
3987: CDC027   [88]             call    GETINT          ; get value
398A: CD8533   [105]            call    CHKCLR0         ; check if color is in range 0~15
398D: 32E081   [118]            ld      (TMPBFR3),A     ; store color into temp buffer
3990: C9       [128]            ret                     ; return to caller
                        
                        
                        ; no graphics mode error: raised when a graphics command is invoked
                        ; out of graphic 2 mode.
3991: 1E2A     [ 7]     GMERR:  ld      E,GM            ; load Graphics Mode Error flag
3993: C3C615   [17]             jp      ERROR           ; print error
                        
                        
                        ; set a serial port: params are PORT,BPS,DATA,PARITY,STOP
                        ; PORT=1/2; BPS=1,200~57,600 (see below), DATA=5/6/7/8
                        ; PARITY: 0=no parity; 1=ODD parity; 2=EVEN parity;
                        ; STOP=0/1/2/3: 0=0 bit; 1=1 bit; 2=1.5 bits; 3=2 bits
                        ; PORT 1 acts as a char device; PORT 2 acts as a block device
                        ; DATA,PARITY, and STOP are optional: if nothing follows BPS,
                        ; they are assumed to be 8,0,1 resp.
81E4:                   PRTNUM  equ     VIDEOBUFF
81E5:                   BPS     equ     VIDEOBUFF+$01
81E7:                   DATABT  equ     BPS+$02
81E8:                   PARBT   equ     DATABT+$01
81E9:                   STPBT   equ     PARBT+$01
81EA:                   SIOBFR  equ     STPBT+$01
3996: CDC027   [17]     SERIAL: call    GETINT          ; get port #
3999: A7       [21]             and     A               ; is it zero?
399A: CA821B   [31|31]          jp      Z,FCERR         ; yes, error
399D: FE03     [38]             cp      $03             ; is it 1 or 2?
399F: D2803B   [48|48]          jp      NC,SCERR        ; no, error
39A2: 32E481   [61]             ld      (PRTNUM),A      ; store port number into a temp buffer
39A5: CD9418   [78]             call    CHKSYN          ; Make sure ',' follows
39A8: 2C                        defb    ','
39A9: CD871B   [95]             call    ATOH            ; get bps (returned into DE)
39AC: 7A       [99]             ld      A,D             ; move MSB into A
39AD: B3       [103]            or      E               ; LSB OR MSB, to check if bps=0
39AE: 203A     [110|115]        jr      NZ,CNTSER       ; no, continue checking
                                ; if baud rate is 0, then close the serial comm.
39B0: 3AE481   [13]     RSTSERS:ld      A,(PRTNUM)      ; yes, so reset the channel. First, load port number
39B3: 3D       [17]             dec     A               ; subtract 1, so that serial channel is 0=>A and 1=>B
39B4: C622     [24]             add     SIO_CA          ; find correct channel
39B6: 4F       [28]             ld      C,A             ; store serial channel
39B7: F3       [32]             di                      ; disable INTs
39B8: AF       [36]             xor     A               ; reset A
39B9: 1601     [43]             ld      D,$01           ; start from WR1
39BB: 0605     [50]             ld      B,$05           ; 5 registers
39BD: ED51     [12]     RPTRSSR:out     (C),D           ; select register
39BF: ED79     [24]             out     (C),A           ; reset register
39C1: 14       [28]             inc     D               ; next register
39C2: 10F9     [36|41]          djnz    RPTRSSR         ; repeat
39C4: 3E30     [43]             ld      A,%00110000     ; write into WR0: error reset, select WR0
39C6: ED79     [55]             out     (C),A           ; send command to serial channel
39C8: 3E18     [62]             ld      A,%00011000     ; write into WR0: channel reset
39CA: ED79     [74]             out     (C),A           ; send command to serial channel
39CC: FB       [78]             ei                      ; re-enable INTs
39CD: E5       [89]             push    HL              ; store HL
39CE: 211B82   [99]             ld      HL,SERIALS_EN   ; serials enabled status byte
39D1: DB01     [110]            in      A,(PIO_DB)      ; read status LEDs
39D3: CB41     [118]            bit     0,C             ; check serial port
39D5: 2009     [125|130]        jr      NZ,SRPT2        ; if bit is set, jump to port 2
39D7: CBB7     [133]            res     6,A             ; it's port 1
39D9: CBA7     [141]            res     4,A             ; remove possible error LED
39DB: CB86     [156]            res     0,(HL)          ; disable port 1
39DD: C3E639   [166]            jp      SERLED          ; jump over
39E0: CBBF     [ 8]     SRPT2:  res     7,A             ; it's port 2
39E2: CBAF     [16]             res     5,A             ; remove possible error LED
39E4: CB8E     [31]             res     1,(HL)          ; disable port 2
39E6: D301     [11]     SERLED: out     (PIO_DB),A      ; send new configuration
39E8: E1       [21]             pop     HL              ; retrieve HL
39E9: C9       [31]             ret                     ; return to caller
                                ; check if bps=1, meaning reactivate RX on serial
39EA: 7A       [ 4]     CNTSER: ld      A,D
39EB: B2       [ 8]             or      D               ; check if bps<>1 by first checking D=0
39EC: 203B     [15|20]          jr      NZ,CNTSER2      ; if not, jump over
39EE: 7B       [19]             ld      A,E             ; then by checking that
39EF: FE01     [26]             cp      $01             ; E=1
39F1: 2036     [33|38]          jr      NZ,CNTSER2      ; if not, jump over
39F3: 3AE481   [46]             ld      A,(PRTNUM)      ; load port number
39F6: FE01     [53]             cp      $01             ; is it port 1? (currently do NOT support on port 2)
39F8: C2803B   [63|63]          jp      NZ,SCERR        ; no, raise error and exit 
39FB: 57       [67]             ld      D,A             ; store port on D
39FC: 3A1B82   [80]             ld      A,(SERIALS_EN)  ; load address of serial status cell
39FF: A2       [84]             and     D               ; check status
3A00: CA803B   [94|94]          jp      Z,SCERR         ; port not open, raise error
3A03: F3       [98]             di                      ; disable INTs
3A04: 7A       [102]            ld      A,D             ; move port # into A
3A05: 5F       [106]            ld      E,A             ; store original A into E
3A06: 87       [110]            add     A
3A07: 87       [114]            add     A               ; move A to left times 2
3A08: 57       [118]            ld      D,A             ; move value into D
3A09: 3A1B82   [131]            ld      A,(SERIALS_EN)  ; load serial status byte
3A0C: B2       [135]            or      D               ; re-enable RX
3A0D: 321B82   [148]            ld      (SERIALS_EN),A  ; store new serial status
3A10: 7B       [152]            ld      A,E             ; recover port #
3A11: 3D       [156]            dec     A               ; check port
3A12: 200A     [163|168]        jr      NZ,CNTRX2       ; port is #2
3A14: CD8D01   [180]            call    SIO_A_EI        ; re-enable RX on port 1
3A17: DB01     [191]            in      A,(PIO_DB)      ; load status LEDs
3A19: CBA7     [199]            res     4,A             ; remove error LED
3A1B: C3253A   [209]            jp      RXEND           ; terminate setting
3A1E: CD8D01   [17]     CNTRX2: call    SIO_A_EI        ; re-enable RX on port 2 -> CURRENTLY only port 1 is supported
3A21: DB01     [28]             in      A,(PIO_DB)      ; load status LEDs
3A23: CBAF     [36]             res     5,A             ; remove error LED
3A25: D301     [11]     RXEND:  out     (PIO_DB),A      ; set new status for LEDs
3A27: FB       [15]             ei                      ; re-enable INTs
3A28: C9       [25]             ret                     ; return to caller
                                ; set serial port comm.
3A29: D5       [11]     CNTSER2:push    DE              ; store BPS
3A2A: 3AE481   [24]             ld      A,(PRTNUM)      ; load port number
3A2D: 57       [28]             ld      D,A             ; move port # into D
3A2E: 3A1B82   [41]             ld      A,(SERIALS_EN)  ; check if serial port is already open
3A31: A2       [45]             and     D               ; by ANDing A with D
3A32: D1       [55]             pop     DE              ; retrieve BPS
3A33: CA3B3A   [65|65]          jp      Z,CNTSER3       ; not open, continue
3A36: 1E2E     [72]             ld      E,SA            ; already open, so raise a "Serial Port Already Error"
3A38: C3C615   [82]             jp      ERROR           ; and leave
3A3B: E5       [11]     CNTSER3:push    HL              ; store HL   
3A3C: 2100E1   [21]             ld      HL,$E100        ; check bps. start with HL=57,600
3A3F: CD153E   [38]             call    CMP16           ; is bps<=57,600?
3A42: E1       [48]             pop     HL              ; but first, recover HL
3A43: DA803B   [58|58]          jp      C,SCERR         ; no (bps>57,600) then error
3A46: ED53E581 [78]             ld      (BPS),DE        ; store bps
3A4A: 2B       [84]             dec     HL              ; dec 'cos GETCHR INCs
3A4B: CDB71A   [101]            call    GETCHR          ; Get next character
3A4E: CA853A   [111|111]        jp      Z,DEFSER        ; defaults if nothing follows
3A51: CD9418   [128]            call    CHKSYN          ; Make sure ',' follows
3A54: 2C                        defb    ','
3A55: CDC027   [145]            call    GETINT          ; get data bits
3A58: FE05     [152]            cp      $05             ; is it <5?
3A5A: DA803B   [162|162]        jp      C,SCERR         ; yes, error
3A5D: FE09     [169]            cp      $09             ; is it >=9?
3A5F: D2821B   [179|179]        jp      NC,FCERR        ; no, error
3A62: 32E781   [192]            ld      (DATABT),A      ; store data bits
3A65: CD9418   [209]            call    CHKSYN          ; Make sure ',' follows
3A68: 2C                        defb    ','
3A69: CDC027   [226]            call    GETINT          ; get parity bits
3A6C: FE03     [233]            cp      A,$03           ; check if parity is in range 0~2
3A6E: D2803B   [243|243]        jp      NC,SCERR        ; no, error
3A71: 32E881   [256]            ld      (PARBT),A       ; store parity
3A74: CD9418   [273]            call    CHKSYN          ; Make sure ',' follows
3A77: 2C                        defb    ','
3A78: CDC027   [290]            call    GETINT          ; get stop bits
3A7B: FE03     [297]            cp      $03             ; is it >=3?
3A7D: D2803B   [307|307]        jp      NC,SCERR        ; yes, error
3A80: 32E981   [320]            ld      (STPBT),A       ; store stop bits
3A83: 180D     [332]            jr      SETSER          ; jump to set serial
3A85: 3E08     [ 7]     DEFSER: ld      A,$08           ; 8 bits for data
3A87: 32E781   [20]             ld      (DATABT),A
3A8A: AF       [24]             xor     A               ; no parity bit
3A8B: 32E881   [37]             ld      (PARBT),A
3A8E: 3C       [41]             inc     A               ; 1 bit for stop
3A8F: 32E981   [54]             ld      (STPBT),A
                                ; check if bps are legal
3A92: E5       [11]     SETSER: push    HL              ; store HL 
3A93: D5       [22]             push    DE              ; store DE
3A94: DDE5     [37]             push    IX              ; store IX
3A96: DD215B3B [51]             ld      IX,SUP_BPS      ; allowed BPSs
3A9A: 060B     [58]             ld      B,$0B           ; 11 items
3A9C: 0E00     [65]             ld      C,$00           ; reset pointer
3A9E: 2AE581   [16]     CKBPS:  ld      HL,(BPS)        ; load BPS
3AA1: DD5E00   [35]             ld      E,(IX+0)        ; load LSB of item
3AA4: DD5601   [54]             ld      D,(IX+1)        ; load MSB of item
3AA7: CD153E   [71]             call    CMP16           ; is it equal?
3AAA: CAB73A   [81|81]          jp      Z,FNDBPS        ; yes, found correspondance
3AAD: DD23     [91]             inc     IX
3AAF: DD23     [101]            inc     IX              ; no, go to next entry
3AB1: 0C       [105]            inc     C               ; increment pointer
3AB2: 10EA     [113|118]        djnz    CKBPS           ; repeat for 10 entries
3AB4: C37C3B   [123]            jp      SCERR1          ; if nothing found, raise an error
3AB7: 3AE481   [13]     FNDBPS: ld      A,(PRTNUM)      ; check serial port
3ABA: 3D       [17]             dec     A               ; is it port 1?
3ABB: CAC13A   [27|27]          jp      Z,SET_P1        ; yes, set port 1
3ABE: C37C3B   [37]             jp      SCERR1          ; at the moment, only port 1 can be configured
3AC1:                   SET_P1: ;init CTC CH0: CH0 provides RX/TX clock to SIO port A
                                ; TO0 output frequency=INPUT CLK/time constant. Time constant is set to get 16 times
                                ; the requested baud rate. I.e., if bps is 19,200 then time constast is set to 6 because
                                ; 1,843,200/6 = 307,200 Hz (that is 19,200 x 16)
3AC1: F3       [ 4]             di                      ; disable INTs
3AC2: 0600     [11]             ld      B,$00           ; reset B
3AC4: 21713B   [21]             ld      HL,CTC_CFG      ; address of first CTC divider
3AC7: 09       [32]             add     HL,BC           ; adjust for correct CTC divider
3AC8: 3E47     [39]             ld      A,%01000111     ; interrupt off, counter mode, prsc=16 (doesn't matter), ext. start,
                                                        ; start upon loading time constant, time constant follows, sw reset, command word
3ACA: D310     [50]             out     (CTC_CH0),A     ; configure CTC channel 0
3ACC: 7E       [57]             ld      A,(HL)          ; load CTC divider
3ACD: D310     [68]             out     (CTC_CH0),A     ; send divider
                                ; configure SIO
3ACF: 210003   [78]             ld      HL,SIO_A_SETS   ; load default settings for SIO
3AD2: 11EA81   [88]             ld      DE,SIOBFR       ; into a temp buffer
3AD5: 010A00   [98]             ld      BC,$000A        ; 10 items to copy
3AD8: EDB0     [114|21]         ldir                    ; copy SIO settings into TEMP buffer
3ADA: 3AEF81   [127]            ld      A,(SIOBFR+5)    ; load WR5 setting
3ADD: 47       [131]            ld      B,A             ; move it into B
3ADE: 3AE781   [144]            ld      A,(DATABT)      ; load DATA bits
3AE1: FE05     [151]            cp      $05             ; is it 5 bits?
3AE3: 2006     [158|163]        jr      NZ,BITS6        ; no, jump over
3AE5: CBB0     [166]            res     6,B
3AE7: CBA8     [174]            res     5,B             ; set D6 & D5 to 0
3AE9: 1819     [186]            jr      SETPAR          ; jump to set parity
3AEB: FE06     [ 7]     BITS6:  cp      $06             ; is it 6 bits?
3AED: 2006     [14|19]          jr      NZ,BITS7        ; no, jump over
3AEF: CBF0     [22]             set     6,B
3AF1: CBA8     [30]             res     5,B             ; set D6 & D5 to 1,0
3AF3: 180F     [42]             jr      SETPAR          ; jump to set parity
3AF5: FE07     [ 7]     BITS7:  cp      $07             ; is it 7 bits?
3AF7: 2007     [14|19]          jr      NZ,BITS8        ; no, jump over
3AF9: CBB0     [22]             res     6,B
3AFB: CBE8     [30]             set     5,B             ; set D6 & D5 to 0,1
3AFD: C3043B   [40]             jp      SETPAR          ; jump to set parity
3B00: CBF0     [ 8]     BITS8:  set     6,B
3B02: CBE8     [16]             set     5,B             ; set D6 & D5 to 1,1
3B04: 78       [ 4]     SETPAR: ld      A,B
3B05: 32EF81   [17]             ld      (SIOBFR+5),A    ; save DATA bits
3B08: E660     [24]             and     %01100000       ; filter only D5&D6 bits
3B0A: 87       [28]             add     A,A             ; shift left times 1
3B0B: 321C82   [41]             ld      (SERABITS),A    ; store for SIO_A_EI & SIO_A_DI functions
3B0E: 3AE981   [54]             ld      A,(STPBT)       ; load STOP bits
3B11: 87       [58]             add     A,A
3B12: 87       [62]             add     A,A             ; 2 left shifts
3B13: 47       [66]             ld      B,A             ; move forming byte into B
3B14: 3AE881   [79]             ld      A,(PARBT)       ; load PARITY setting
3B17: A7       [83]             and     A               ; is it 0?
3B18: CA233B   [93|93]          jp      Z,STRPAR        ; yes, jump over
3B1B: CBC0     [101]            set     0,B             ; set PARITY on
3B1D: 3D       [105]            dec     A               ; is parity ODD?
3B1E: CA233B   [115|115]        jp      Z,STRPAR        ; yes, so jump over
3B21: CBC8     [123]            set     1,B             ; no, it's EVEN so set the corresponding bit
3B23: 3AED81   [13]     STRPAR: ld      A,(SIOBFR+3)    ; load WR4 setting
3B26: E6F0     [20]             and     %11110000       ; reset STOP & PARITY bits
3B28: B0       [24]             or      B               ; set new STOP & PARITY bits
3B29: 32ED81   [37]             ld      (SIOBFR+3),A    ; store new value
                                ;set up TX and RX:
                                ; the followings are settings for channel A
3B2C: 21EA81   [47]             ld      HL,SIOBFR       ; settings for SIO ch. A
3B2F: 0606     [54]             ld      B,$06           ; 6 bytes to send
3B31: 0E22     [61]             ld      C,SIO_CA        ; I/O address of SIO ch.A
3B33: EDB3     [77|21]          otir                    ; send bytes to SIO
                                ; the following are settings for channel B (don't need to load HL since settings are contigous)
3B35: 0604     [84]             ld      B,$04           ; other 4 bytes to send
3B37: 0E23     [91]             ld      C,SIO_CB        ; I/O address of SIO ch.B
3B39: EDB3     [107|21]         otir                    ; send bytes to SIO
                                ; the following are settings for channel A
3B3B: 3E01     [114]            ld      A,$01           ; write into WR0: select WR1
3B3D: D322     [125]            out     (SIO_CA),A
3B3F: 3E18     [132]            ld      A,%00011000     ; interrupts on every RX char; parity is no special condition;
                                                        ; buffer overrun is special condition
3B41: D322     [143]            out     (SIO_CA),A
3B43: CD8D01   [160]            call    SIO_A_EI        ; enable RX on SIO channel A
3B46: 211B82   [10]     EXITSER:ld      HL,SERIALS_EN
3B49: CBC6     [25]             set     0,(HL)          ; set serial port 1 status ON
3B4B: CBD6     [40]             set     2,(HL)          ; set serial port 1 RX ON
                                ; back to normal running
3B4D: FB       [44]             ei                      ; re-enable INTs
3B4E: DB01     [55]             in      A,(PIO_DB)      ; load status LEDs
3B50: CBF7     [63]             set     6,A             ; set status LED on
3B52: CBA7     [71]             res     4,A             ; set error LED off
3B54: D301     [82]             out     (PIO_DB),A      ; send new configuration
3B56: DDE1     [96]             pop     IX              ; retrieve IX
3B58: D1       [106]            pop     DE              ; retrieve DE
3B59: E1       [116]            pop     HL              ; retrieve HL
3B5A: C9       [126]            ret                     ; return to caller
                        
                        ; allowed bps (Bauds per second)
3B5B: 00E10096          SUP_BPS:defw    57600,38400,28800,19200,14400,9600,4800,3600,2400,1200,600
3B5F: 8070004B          
3B63: 40388025          
3B67: C012100E          
3B6B: 6009B004          
3B6F: 5802              
                        ; corresponding CTC divider
3B71: 02030406          CTC_CFG:defb    2,3,4,6,8,12,24,32,48,96,192
3B75: 080C1820          
3B79: 3060C0            
                        
                        ; serial configuration error
3B7C: DDE1     [14]     SCERR1: pop     IX              ; retrieve IX
3B7E: D1       [24]             pop     DE              ; retrieve DE
3B7F: E1       [34]             pop     HL              ; retrieve HL
3B80: 1E2C     [ 7]     SCERR:  ld      E,SC            ; Serial Configuration Error
3B82: C3C615   [17]             jp      ERROR           ; print error
                        
                        ; check for direct mode
3B85: E5       [11]     DIRMOD: push    HL              ; Save code string address
3B86: 2AAF80   [27]             ld      HL,(LINEAT)     ; Get current line number
3B89: 23       [33]             inc     HL              ; -1 means direct statement
3B8A: 7C       [37]             ld      A,H
3B8B: B5       [41]             or      L
3B8C: E1       [51]             pop     HL              ; Restore code string address
3B8D: C2A73B   [61|61]          jp      NZ,HLPERR       ; raise error if in indirect mode
3B90: C9       [71]             ret
                        
                        
                        ; HELP lists the line program where an error was found
3B91: CD853B   [17]     HELP:   call    DIRMOD          ; check if in direct mode
3B94: E5       [28]             push    HL              ; store HL
3B95: 2AB180   [44]             ld      HL,(HLPLN)      ; load HELP line
3B98: 23       [50]             inc     HL              ; increment HL
3B99: 7C       [54]             ld      A,H
3B9A: B5       [58]             or      L               ; check if there is a line into the HELP reg.
3B9B: E1       [68]             pop     HL
3B9C: CAA73B   [78|78]          jp      Z,HLPERR        ; no line found, raise error
3B9F: ED5BB180 [98]             ld      DE,(HLPLN)      ; recover line
3BA3: C1       [108]            pop     BC              ; remove BC from stack since it's not needed anymore for LIST
3BA4: C32219   [118]            jp      LST01H          ; jump to list line
3BA7: 1E30     [ 7]     HLPERR: ld      E,HP            ; HELP call error
3BA9: C3C615   [17]             jp      ERROR           ; raise error
                        
                        
                        ; KEY command to list/modify function keys
3BAC: 2B       [ 6]     KEY:    dec     HL              ; dec 'cos GETCHR INCs
3BAD: CDB71A   [23]             call    GETCHR          ; Get next character
3BB0: CA303C   [33|33]          jp      Z,LSTKEYS       ; jump if nothing follows
                                                        ; change FN keys
3BB3: CDC027   [50]             call    GETINT          ; get a number
3BB6: A7       [54]             and     A               ; is it 0?
3BB7: 2010     [61|66]          jr      NZ,KEYCH        ; no, jump over         
3BB9: E5       [72]             push    HL              ; yes - reset FN keys to defaults
3BBA: D5       [83]             push    DE              ; store HL & DE
3BBB: 21A214   [93]             ld      HL,DEFFNKS      ; pointer to default FN keys texts
3BBE: 11B380   [103]            ld      DE,FNKEYS       ; pointer to destination
3BC1: 018000   [113]            ld      BC,$0080        ; 128 chars to be copied
3BC4: EDB0     [129|21]         ldir                    ; restore default texts
3BC6: D1       [139]            pop     DE              ; retrieve DE
3BC7: E1       [149]            pop     HL              ; retrieve HL
3BC8: C9       [159]            ret                     ; return to caller
3BC9: FE09     [ 7]     KEYCH:  cp      $09             ; is it >= 9?
3BCB: D2B215   [17|17]          jp      NC,SNERR        ; yes - syntax error
3BCE: 3D       [21]             dec     A               ; FN key in range 0~7
3BCF: 87       [25]             add     A,A             ; multiply A...
3BD0: 87       [29]             add     A,A             ; ... times 4...
3BD1: 87       [33]             add     A,A             ; ... to get the correct...
3BD2: 87       [37]             add     A,A             ; ... offset fo FN key text
3BD3: 32DC81   [50]             ld      (TMPBFR1),A     ; store FN key offset...
3BD6: AF       [54]             xor     A               ; ...in a...
3BD7: 32DD81   [67]             ld      (TMPBFR1+1),A   ; ...16-bit register
3BDA: CD9418   [84]             call    CHKSYN          ; Make sure ',' follows
3BDD: 2C                        defb    ','
3BDE: 444D     [92]             ld      BC,HL           ; copy address into BC
3BE0: CD4C1F   [109]            call    EVAL            ; Evaluate expression (in E there is the length)
3BE3: E5       [120]            push    HL              ; store string pointer
3BE4: 3A9281   [133]            ld      A,(TYPE)        ; Get variable type
3BE7: B7       [137]            or      A               ; Is it a string variable?
3BE8: CAB215   [147|147]        jp      Z,SNERR         ; no - syntax error
3BEB: CD8525   [164]            call    GSTRCU          ; Current string to pool
3BEE: CD972D   [181]            call    LOADFP          ; Move string block data to (BC=pointer, DE=length)
3BF1: 7B       [185]            ld      A,E             ; copy length into A
3BF2: FE11     [192]            cp      $11             ; is length > 16?
3BF4: DAF93B   [202|202]        jp      C,DECLN1        ; no, jump over
3BF7: 1E10     [209]            ld      E,$10           ; yes, so set length to 16
3BF9: 3E10     [ 7]     DECLN1: ld      A,$10           ; calculate how many...
3BFB: 93       [11]             sub     E               ; ...null chars needed to fill up...
3BFC: 57       [15]             ld      D,A             ; ...the FN key text
3BFD: C5       [26]             push    BC              ; store address of string 
3BFE: ED4BDC81 [46]             ld      BC,(TMPBFR1)    ; load FN key offset
3C02: 21B380   [56]             ld      HL,FNKEYS       ; load address of FN keys texts
3C05: 09       [67]             add     HL,BC           ; get corrected address
3C06: C1       [77]             pop     BC              ; retrieve address of string chars
3C07: 0A       [ 7]     CPKEY:  ld      A,(BC)          ; load char from string
3C08: FE0D     [14]             cp      CR              ; return?
3C0A: CA173C   [24|24]          jp      Z,CPKEY2        ; yes, store char
3C0D: FE7B     [31]             cp      $7B             ; if char > "z" ?
3C0F: D2B215   [41|41]          jp      NC,SNERR        ; yes - syntax error
3C12: FE20     [48]             cp      $20             ; is char < space?
3C14: DAB215   [58|58]          jp      C,SNERR         ; yes - syntax error
3C17: FE61     [ 7]     CPKEY2: cp      $61             ; is it >= 'a'?
3C19: DA1E3C   [17|17]          jp      C,CPKEY3        ; no, continue
3C1C: E65F     [24]             and     %01011111       ; set letters to uppercase
3C1E: 77       [ 7]     CPKEY3: ld      (HL),A          ; store char
3C1F: 23       [13]             inc     HL              ; next string char
3C20: 03       [19]             inc     BC              ; next free cell
3C21: 1D       [23]             dec     E               ; decrement E
3C22: 20E3     [30|35]          jr      NZ,CPKEY        ; repeat until 0
3C24: AF       [34]             xor     A               ; null char
3C25: 14       [38]             inc     D               ; +1 to decrement below
3C26: 15       [ 4]     CPKEY1: dec     D               ; how many null chars to insert?
3C27: CA2E3C   [14|14]          jp      Z,CPKYEND       ; no more nulls, so exit
3C2A: 77       [21]             ld      (HL),A          ; store it
3C2B: 23       [27]             inc     HL              ; next cell
3C2C: 18F8     [39]             jr      CPKEY1          ; repeat
3C2E: E1       [10]     CPKYEND:pop     HL              ; retrieve pointer to string
3C2F: C9       [20]             ret                     ; return to caller
                                                        ; list FN keys
3C30: E5       [11]     LSTKEYS:push    HL              ; Save code string address
3C31: 2AAF80   [27]             ld      HL,(LINEAT)     ; Get current line number
3C34: 23       [33]             inc     HL              ; -1 means direct statement
3C35: 7C       [37]             ld      A,H
3C36: B5       [41]             or      L
3C37: E1       [51]             pop     HL              ; Restore code string address
3C38: C2B215   [61|61]          jp      NZ,SNERR        ; raise error if in indirect mode
3C3B: E5       [72]             push    HL              ; store HL
3C3C: D5       [83]             push    DE              ; store DE
3C3D: 21B380   [93]             ld      HL,FNKEYS       ; load starting address of FN keys text
3C40: 0E01     [100]            ld      C,$01           ; 8 function keys
3C42: 0610     [ 7]     PRTK4:  ld      B,$10           ; 16 chars each
3C44: 11E33C   [10]     PRTK2:  ld      DE,CHKEY1       ; message "KEY "
3C47: CDD43C   [27]             call    PRTCKEY         ; print it
3C4A: 79       [31]             ld      A,C             ; load FN key
3C4B: C630     [38]             add     $30             ; get number in ASCI code
3C4D: CD9F18   [55]             call    OUTC            ; print it
3C50: 11E83C   [65]             ld      DE,CHKEY2       ; message ": ""
3C53: CDD43C   [82]             call    PRTCKEY         ; print it
3C56: 3E01     [89]             ld      A,$01           ; " opened
3C58: 32DC81   [102]            ld      (TMPBFR1),A
3C5B: 7E       [ 7]     LDKEY:  ld      A,(HL)          ; retrieve char
3C5C: A7       [11]             and     A               ; is it zero?
3C5D: CA703C   [21|21]          jp      Z,CNTLTK        ; yes, go next char
3C60: CDBC3C   [38]             call    OPNQT           ; check if quotes are opened
3C63: FE22     [45]             cp      $22             ; check if char is "?
3C65: CA853C   [55|55]          jp      Z,PRTCHR        ; yes, print "chr$("
3C68: FE0D     [62]             cp      CR              ; is it a CR?
3C6A: CA853C   [72|72]          jp      Z,PRTCHR        ; yes, print "chr$("
3C6D: CD9F18   [17]     PRTK3:  call    OUTC            ; no, just print it
3C70: 23       [ 6]     CNTLTK: inc     HL              ; next char
3C71: 10E8     [14|19]          djnz    LDKEY           ; continue until finished
3C73: CDAA3C   [31]             call    CLSQT           ; check if quotes are still open
3C76: 3E0D     [38]             ld      A,CR            ; go next line
3C78: CD9F18   [55]             call    OUTC            ; print it
3C7B: 0C       [59]             inc     C               ; next FN key
3C7C: 79       [63]             ld      A,C             ; check if...
3C7D: FE09     [70]             cp      $09             ; finished keys?
3C7F: DA423C   [80|80]          jp      C,PRTK4         ; no, repeat 1 more time
3C82: D1       [90]             pop     DE              ; retrieve DE
3C83: E1       [100]            pop     HL              ; retrieve HL
3C84: C9       [110]            ret                     ; return to caller
                        
3C85: E5       [11]     PRTCHR: push    HL              ; store HL
3C86: CDAA3C   [28]             call    CLSQT           ; check if quotes are closed
3C89: 3E2B     [35]             ld      A,'+'           ; '+' char
3C8B: CD9F18   [52]             call    OUTC            ; print it
3C8E: 11EB3C   [62]             ld      DE,CHKEY3       ; address of "CHR$("
3C91: CDD43C   [79]             call    PRTCKEY         ; print it
3C94: E1       [89]             pop     HL              ; recover HL
3C95: 23       [95]             inc     HL              ; next char
3C96: 05       [99]             dec     B               ; increment char counter
3C97: 11F13C   [109]            ld      DE,CHKEY4       ; load address of RETURN
3C9A: 7E       [116]            ld      A,(HL)          ; load char
3C9B: FE0D     [123]            cp      CR              ; is it a RETURN?
3C9D: 2003     [130|135]        jr      NZ,PTCHR1       ; no, jump over
3C9F: 11F43C   [140]            ld      DE,CHKEY5       ; yes, load address of "
3CA2: CDD43C   [17]     PTCHR1: call    PRTCKEY         ; print it
3CA5: 3E29     [24]             ld      A,')'           ; char )
3CA7: C36D3C   [34]             jp      PRTK3           ; continue
                        
3CAA: F5       [11]     CLSQT:  push    AF              ; store A
3CAB: 3ADC81   [24]             ld      A,(TMPBFR1)     ; quote status
3CAE: A7       [28]             and     A               ; are they closed?
3CAF: 2809     [35|40]          jr      Z,CLSQT1        ; if yes, return
3CB1: 3E22     [42]             ld      A,$22           ; no, so close them
3CB3: CD9F18   [59]             call    OUTC            ; print "
3CB6: AF       [63]             xor     A               ; set quotes
3CB7: 32DC81   [76]             ld      (TMPBFR1),A     ; as closed
3CBA: F1       [10]     CLSQT1: pop     AF              ; retrieve A
3CBB: C9       [20]             ret                     ; return to caller
                        
3CBC: F5       [11]     OPNQT:  push    AF              ; store A
3CBD: 3ADC81   [24]             ld      A,(TMPBFR1)     ; quote status
3CC0: A7       [28]             and     A               ; are they open?
3CC1: 200F     [35|40]          jr      NZ,OPNQT1       ; if yes, return
3CC3: 3E2B     [42]             ld      A,'+'           ; no, so add '+
3CC5: CD9F18   [59]             call    OUTC            ; print it
3CC8: 3E22     [66]             ld      A,$22           ; and then open quotes
3CCA: CD9F18   [83]             call    OUTC            ; print them
3CCD: 3E01     [90]             ld      A,$01           ; set quotes
3CCF: 32DC81   [103]            ld      (TMPBFR1),A     ; as opened
3CD2: F1       [10]     OPNQT1: pop     AF              ; retrieve A
3CD3: C9       [20]             ret                     ; return to caller
                        
3CD4: F5       [11]     PRTCKEY:push    AF              ; store original char
3CD5: 1A       [ 7]     PRTK1:  ld      A,(DE)          ; load char
3CD6: A7       [11]             and     A               ; is it 0?
3CD7: CAE13C   [21|21]          jp      Z,PRTEND        ; yes, finished printing
3CDA: CD9F18   [38]             call    OUTC            ; no, print char
3CDD: 13       [44]             inc     DE              ; next char
3CDE: C3D53C   [54]             jp      PRTK1           ; repeat
3CE1: F1       [10]     PRTEND: pop     AF              ; retrieve AF
3CE2: C9       [20]             ret                     ; return to caller
                        
3CE3: 4B455920          CHKEY1: defb    "KEY ",0
3CE7: 00                
3CE8: 3A2200            CHKEY2: defb    ":",34,0
3CEB: 63687224          CHKEY3: defb    "chr$(",0
3CEF: 2800              
3CF1: 313300            CHKEY4: defb    "13",0
3CF4: 333400            CHKEY5: defb    "34",0
                        
                        
                        ; LOAD "filename"
3CF7: C9       [10]     LOAD:   ret                     ; currently a stub for LOAD
                        
                        
                        ; SAVE "filename"
3CF8: C9       [10]     SAVE:   ret                     ; currently a stub for SAVE
                        
                        
                        ; FILES
3CF9: C9       [10]     FILES:  ret                     ; currently a stub for FILES
                        
                        
                        ; ERASE "filename"
3CFA: C9       [10]     ERASE:  ret                     ; currently a stub for ERASE
                        
                        
                        ; HEX$(nn) Convert 16 bit number to Hexadecimal string
3CFB: CD3D1F   [17]     HEX: 	call	TSTNUM          ; Verify it's a number
3CFE: CD6D1B   [34]             call	DEINT           ; Get integer -32768 to 32767
3D01: C5       [45]             push	BC              ; Save contents of BC
3D02: 213182   [55]             ld      HL,PBUFF        ; load address of PBUFF into HL
3D05: 7A       [59]             ld      A,D             ; Get MSB into A
3D06: B7       [63]             or      A               ; OR with LSB to see if param=0
3D07: 280C     [70|75]          jr      Z,HEX2          ; Skip output if both high digits are zero
3D09: CD313D   [87]             call    BYT2ASC         ; Convert D to ASCII
3D0C: 78       [91]             ld      A,B             ; cechk if B
3D0D: FE30     [98]             cp      '0'             ; is 0
3D0F: 2802     [105|110]        jr      Z,HEX1          ; Don't store high digit if zero
3D11: 70       [112]            ld      (HL),B          ; Store it to PBUFF
3D12: 23       [118]            inc     HL              ; Next location
3D13: 71       [ 7]     HEX1:   ld      (HL),C          ; Store C to PBUFF+1
3D14: 23       [13]             inc     HL              ; Next location
3D15: 7B       [ 4]     HEX2:   ld      A,E             ; Get lower byte
3D16: CD313D   [21]             call    BYT2ASC         ; Convert E to ASCII
3D19: 7A       [25]             ld      A,D
3D1A: B7       [29]             or      A
3D1B: 2005     [36|41]          jr      NZ,HEX3         ; If upper byte was not zero then always print lower byte
3D1D: 78       [40]             ld      A,B
3D1E: FE30     [47]             cp      '0'             ; If high digit of lower byte is zero then don't print
3D20: 2802     [54|59]          jr      Z,HEX4
3D22: 70       [ 7]     HEX3:   ld      (HL),B          ; to PBUFF+2
3D23: 23       [13]             inc     HL              ; Next location
3D24: 71       [ 7]     HEX4:   ld      (HL),C          ; to PBUFF+3
3D25: 23       [13]             inc     HL              ; PBUFF+4 to zero
3D26: AF       [17]             xor     A               ; Terminating character
3D27: 77       [24]             ld      (HL),A          ; Store zero to terminate
3D28: 23       [30]             inc     HL              ; Make sure PBUFF is terminated
3D29: 77       [37]             ld      (HL),A          ; Store the double zero there
3D2A: C1       [47]             pop     BC              ; Get BC back
3D2B: 213182   [57]             ld      HL,PBUFF        ; Reset to start of PBUFF
3D2E: C3D223   [67]             jp      STR1            ; Convert the PBUFF to a string and return it
3D31: 47       [ 4]     BYT2ASC	ld      B,A             ; Save original value
3D32: E60F     [11]             and     $0F             ; Strip off upper nybble
3D34: FE0A     [18]             cp      $0A             ; 0-9?
3D36: 3802     [25|30]          jr      C,ADD30         ; If A-F, add 7 more
3D38: C607     [32]             add     A,$07           ; Bring value up to ASCII A-F
3D3A: C630     [ 7]     ADD30	add     A,$30           ; And make ASCII
3D3C: 4F       [11]             ld      C,A             ; Save converted char to C
3D3D: 78       [15]             ld      A,B             ; Retrieve original value
3D3E: 0F       [19]             rrca                    ; and Rotate it right
3D3F: 0F       [23]             rrca
3D40: 0F       [27]             rrca
3D41: 0F       [31]             rrca
3D42: E60F     [38]             and     $0F             ; Mask off upper nybble
3D44: FE0A     [45]             cp      $0A             ; 0-9? < A hex?
3D46: 3802     [52|57]          jr      C,ADD301        ; Skip Add 7
3D48: C607     [59]             add     A,$07           ; Bring it up to ASCII A-F
3D4A: C630     [ 7]     ADD301	add     A,$30           ; And make it full ASCII
3D4C: 47       [11]             ld      B,A             ; Store high order byte
3D4D: C9       [21]             ret
                        
                        ; Convert "&Hnnnn" to FPREG
                        ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
                        ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
3D4E: EB       [ 4]     HEXTFP  ex      DE,HL           ; Move code string pointer to DE
3D4F: 210000   [14]             ld      HL,$0000        ; Zero out the value
3D52: CD673D   [31]             call    GETHEX          ; Check the number for valid hex
3D55: DA873D   [41|41]          jp      C,HXERR         ; First value wasn't hex, HX error
3D58: 1805     [53]             jr      HEXLP1          ; Convert first character
3D5A: CD673D   [17]     HEXLP   call    GETHEX          ; Get second and addtional characters
3D5D: 381F     [24|29]          jr      C,HEXIT         ; Exit if not a hex character
3D5F: 29       [11]     HEXLP1  add     HL,HL           ; Rotate 4 bits to the left
3D60: 29       [22]             add     HL,HL
3D61: 29       [33]             add     HL,HL
3D62: 29       [44]             add     HL,HL
3D63: B5       [48]             or      L               ; Add in D0-D3 into L
3D64: 6F       [52]             ld      L,A             ; Save new value
3D65: 18F3     [64]             jr      HEXLP           ; And continue until all hex characters are in
                        
3D67: 13       [ 6]     GETHEX  inc     DE              ; Next location
3D68: 1A       [13]             ld      A,(DE)          ; Load character at pointer
3D69: FE20     [20]             cp      SPC
3D6B: CA673D   [30|30]          jp      Z,GETHEX        ; Skip spaces
3D6E: D630     [37]             sub     $30             ; Get absolute value
3D70: D8       [42|48]          ret     C               ; < "0", error
3D71: FE0A     [49]             cp      $0A
3D73: 3805     [56|61]          jr      C,NOSUB7        ; Is already in the range 0-9
3D75: D607     [63]             sub     $07             ; Reduce to A-F
3D77: FE0A     [70]             cp      $0A             ; Value should be $0A-$0F at this point
3D79: D8       [75|81]          ret     C               ; CY set if was :            ; < = > ? @
3D7A: FE10     [ 7]     NOSUB7  cp      $10             ; > Greater than "F"?
3D7C: 3F       [11]             ccf
3D7D: C9       [21]             ret                     ; CY set if it wasn't valid hex
                        
3D7E: EB       [ 4]     HEXIT   ex      DE,HL           ; Value into DE, Code string into HL
3D7F: 7A       [ 8]             ld      A,D             ; Load DE into AC
3D80: 4B       [12]             ld      C,E             ; For prep to
3D81: E5       [23]             push    HL
3D82: CD2323   [40]             call    ACPASS          ; ACPASS to set AC as integer into FPREG
3D85: E1       [50]             pop     HL
3D86: C9       [60]             ret
                        
3D87: 1E26     [ 7]     HXERR:  ld      E,HX            ; ?HEX Error
3D89: C3C615   [17]             jp      ERROR
                        
                        ; BIN$(NN) Convert integer to a 1-16 char binary string
3D8C: CD3D1F   [17]     BIN:    call    TSTNUM          ; Verify it's a number
3D8F: CD6D1B   [34]             call    DEINT           ; Get integer -32768 to 32767
3D92: C5       [11]     BIN2:   push    BC              ; Save contents of BC
3D93: 213182   [21]             ld      HL,PBUFF
3D96: 0611     [28]             ld      B,$11           ; One higher than max char count (16+1)
3D98:                   ZEROSUP:                        ; Suppress leading zeros
3D98: 05       [ 4]             dec     B               ; Max 16 chars
3D99: 78       [ 8]             ld      A,B
3D9A: FE01     [15]             cp      $01
3D9C: 2808     [22|27]          jr      Z,BITOUT        ; Always output at least one character
3D9E: CB13     [30]             rl      E
3DA0: CB12     [38]             rl      D
3DA2: 30F4     [45|50]          jr      NC,ZEROSUP
3DA4: 1804     [57]             jr      BITOUT2
3DA6: CB13     [ 8]     BITOUT: rl      E
3DA8: CB12     [16]             rl      D               ; Top bit now in carry
3DAA: 3E30     [ 7]     BITOUT2:ld      A,'0'           ; Char for '0'
3DAC: CE00     [14]             adc     A,$00           ; If carry set then '0' --> '1'
3DAE: 77       [21]             ld      (HL),A
3DAF: 23       [27]             inc     HL
3DB0: 05       [31]             dec     B
3DB1: 20F3     [38|43]          jr      NZ,BITOUT
3DB3: AF       [42]             xor     A               ; Terminating character
3DB4: 77       [49]             ld      (HL),A          ; Store zero to terminate
3DB5: 23       [55]             inc     HL              ; Make sure PBUFF is terminated
3DB6: 77       [62]             ld      (HL),A          ; Store the double zero there
3DB7: C1       [72]             pop     BC
3DB8: 213182   [82]             ld      HL,PBUFF
3DBB: C3D223   [92]             jp      STR1
                        
                        ; Convert "&Bnnnn" to FPREG
                        ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
3DBE: EB       [ 4]     BINTFP: ex      DE,HL           ; Move code string pointer to DE
3DBF: 210000   [14]             ld      HL,$0000        ; Zero out the value
3DC2: CDDB3D   [31]             call    CHKBIN          ; Check the number for valid bin
3DC5: DAE93D   [41|41]          jp      C,BINERR        ; First value wasn't bin, HX error
3DC8: D630     [ 7]     BINIT:  sub     '0'
3DCA: 29       [18]             add     HL,HL           ; Rotate HL left
3DCB: B5       [22]             or      L
3DCC: 6F       [26]             ld      L,A
3DCD: CDDB3D   [43]             call    CHKBIN          ; Get second and addtional characters
3DD0: 30F6     [50|55]          jr      NC,BINIT        ; Process if a bin character
3DD2: EB       [54]             ex      DE,HL           ; Value into DE, Code string into HL
3DD3: 7A       [58]             ld      A,D             ; Load DE into AC
3DD4: 4B       [62]             ld      C,E             ; For prep to
3DD5: E5       [73]             push    HL
3DD6: CD2323   [90]             call    ACPASS          ; ACPASS to set AC as integer into FPREG
3DD9: E1       [100]            pop     HL
3DDA: C9       [110]            ret
                        
                        ; Char is in A, NC if char is 0 or 1
3DDB: 13       [ 6]     CHKBIN: inc     DE
3DDC: 1A       [13]             ld      A,(DE)
3DDD: FE20     [20]             cp      SPC
3DDF: CADB3D   [30|30]          jp      Z,CHKBIN        ; Skip spaces
3DE2: FE30     [37]             cp      '0'             ; Set C if < '0'
3DE4: D8       [42|48]          ret     C
3DE5: FE32     [49]             cp      '2'
3DE7: 3F       [53]             ccf                     ; Set C if > '1'
3DE8: C9       [63]             ret
                        
3DE9: 1E28     [ 7]     BINERR: ld      E,BN            ; ?BIN Error
3DEB: C3C615   [17]             jp      ERROR
                        
                        
3DEE: C30800   [10]     MONOUT: jp      $0008           ; output a char
                        
                        
3DF1: 3A1B82   [13]     RESET:  ld      A,(SERIALS_EN)
3DF4: E611     [20]             and     $11             ; are serial ports open?
3DF6: C4B039   [30|37]          call    NZ,RSTSERS      ; yes, reset serials
3DF9: CDDB27   [47]             call    DISNMI          ; disable NMI vector
3DFC: F3       [51]             di                      ; disable INTs
3DFD: C30000   [61]             jp      $0000           ; Restart
                        
                        
3E00: 3E00     [ 7]     INITST: ld      A,$00           ; Clear break flag
3E02: 32A980   [20]             ld      (BRKFLG),A
3E05: C3210F   [30]             jp      INIT
                        
                        
3E08: F5       [11]     TSTBIT: push    AF              ; Save bit mask
3E09: A0       [15]             and     B               ; Get common bits
3E0A: C1       [25]             pop     BC              ; Restore bit mask
3E0B: B8       [29]             cp      B               ; Same bit set?
3E0C: 3E00     [36]             ld      A,$00           ; Return 0 in A
3E0E: C9       [46]             ret
                        
3E0F: CD9F18   [17]     OUTNCR: call    OUTC            ; Output character in A
3E12: C37E1D   [27]             jp      PRNTCRLF        ; Output CRLF
                        
                        ; include utils
                        #include "../include/utils/utils-r11.asm"
                        ; ------------------------------------------------------------------------------
                        ; LM80C - UTILITY ROUTINES - R1.1
                        ; ------------------------------------------------------------------------------
                        ; The following code is intended to be used with LM80C Z80-based computer
                        ; designed by Leonardo Miliani. More info at
                        ; www DOT leonardomiliani DOT com
                        ;
                        ; *ALS are routines from "Z80 Assembly Language Subroutines" by Lance
                        ; A. Leventhal and Winthrop Saville - Ed. Osborne/McGraw-Hill (1983)
                        ;
                        ; * WKT are routines from WikiTI:
                        ; http://wikiti.brandonw.net/index.php?title=WikiTI_Home
                        ;
                        ; * LAC are routines from Learn@Cemetch
                        ; https://learn.cemetech.net/index.php/Main_Page
                        ;
                        ; ------------------------------------------------------------------------------
                        ; Code Revision:
                        ; R1.0 - 20200110 - First release: 16-bit comparision/multiplication/negation
                        ; R1.1 - 20200413 - Second release: added ABS(HL) 
                        ;
                        ; ------------------------------------------------------------------------------
                        
                        ; compare two 16-bit registers, HL (minuend) and DE (subtrahend)
                        ; values can be both signed or unsigned words
                        ; inputs: HL, DE
                        ; destroys: A,F,HL
                        ;
                        ; returns: Z=1 if HL = DE
                        ; for UNSIGNED: C=1 if HL<DE  //  C=0 if HL>DE
                        ; for SIGNED:   S=1 (M) if HL<DE  //  S=0 (P) if HL>DE
                        ; if HL=DE: Z,P,NC  - Z=1, S=0; C=0
                        ; if HL>DE: NZ,P,NC - Z=0, S=0; C=0
                        ; if HL<DE: NZ,M,C  - Z=0, S=1; C=1
                        ; Source: ALS
                        
3E15: B7       [ 4]     CMP16:  or      A           ; clear CARRY
3E16: ED52     [19]             sbc     HL,DE       ; subtract DE from HL
3E18: E0       [24|30]          ret     PO          ; return if no overflow
3E19: 7C       [28]             ld      A,H         ; overflow - invert SIGN flag
3E1A: 1F       [32]             rra                 ; save CARRY flag in bit 7
3E1B: EE40     [39]             xor     %01000000   ; complement bit 6 (SIGN bit)
3E1D: 37       [43]             scf                 ; ensure a Non-Zero result
3E1E: 8F       [47]             adc     A,A         ; restore CARRY, complemented SIGN
                                                    ; ZERO flag = 0 for sure
3E1F: C9       [57]             ret                 ; return
                        
                        ; ----------------------------------------------------------------------
                        
                        ; multiply 2 signed/unsigned 16-bit words and return a 16-bit
                        ; signed/unsigned product
                        ; inputs: HL (multiplicand); DE (multiplier)
                        ; destroys: A,F
                        ; returns: HL (product)
                        ; Source: ALS
                        
                        ; initialize partial product, bit count
3E20: C5       [11]     MUL16:  push    BC
3E21: 4D       [15]             ld      C,L         ; BC = multiplier
3E22: 44       [19]             ld      B,H
3E23: 210000   [29]             ld      HL,0        ; product = 0
3E26: 3E0F     [36]             ld      A,$0F       ; count = bit lenght - 1 (16-1)
                                ; shift-and-add algorithm
                                ; if MSB of multiplier is 1, add multiplicand to partial product
                                ; shift partial product, multiplier left 1 bit
3E28: CB23     [ 8]     MLP:    sla     E           ; shift multiplier left 1 bit
3E2A: CB12     [16]             rl      D
3E2C: 3001     [23|28]          jr      NC,MLP1     ; jump if MSB of multiplier = 0
3E2E: 09       [34]             add     HL,BC       ; add multiplicand to partial product
3E2F: 29       [11]     MLP1:   add     HL,HL       ; shift partial product left
3E30: 3D       [15]             dec     A
3E31: 20F5     [22|27]          jr      NZ,MLP      ; continue until count = 0
                                ; add multiplicand one last time if MSB of multiplier is 1
3E33: B2       [26]             or      D           ; sign flag = MSB of multiplier
3E34: F2383E   [36|36]          jp      P,EXMUL16   ; exit if MSB of multiplier is 0
3E37: 09       [47]             add     HL,BC       ; add multiplicand to product
3E38: C1       [10]     EXMUL16:pop     BC
3E39: C9       [20]             ret
                        
                        ; ----------------------------------------------------------------------
                        ; absolute value of HL (same applies to other 16-bit register pairs)
                        ; also, invert value of HL (or any other 16-bit register, just adjust the code)
                        ;
                        ; inputs: HL
                        ; destroys: A
                        ; operation: ABS(HL)
                        ; returns: HL with no sign or negated
                        ; Source: WKT
                        
3E3A: CB7C     [ 8]     absHL:  bit     7,H
3E3C: C8       [13|19]          ret     Z
3E3D: AF       [ 4]     negHL:  xor     A
3E3E: 95       [ 8]             sub     L
3E3F: 6F       [12]             ld      L,A
3E40: 9F       [16]             sbc     A,A
3E41: 94       [20]             sub     H
3E42: 67       [24]             ld      H,A
3E43: C9       [34]             ret
                        
                        ; ------------------------------------------------------------------------------
                        
                        ; 8/8 division
                        ; INPUT: D (dividend), E (divisor)
                        ; OPERATION: D/E
                        ; OUTPUT: D (quotient), A (remainder)
3E44: AF       [ 4]     DIV_8_8:    xor     A
3E45: C5       [15]                 push    BC
3E46: 0608     [22]                 ld      B,08h
3E48: CB22     [ 8]     DIV_8_8LOOP:sla     D
3E4A: 17       [12]                 rla
3E4B: BB       [16]                 cp      E
3E4C: 3802     [23|28]              jr      C,$+4
3E4E: 93       [27]                 sub     E
3E4F: 14       [31]                 inc     D
3E50: 10F6     [39|44]              djnz    DIV_8_8LOOP
3E52: C1       [49]                 pop     BC
3E53: C9       [59]                 ret
                        
                        ; ----------------------------------------------------------------------
                        ; divide a 16-bit number by an 8-bit number
                        ; (16/8 division)
                        ;
                        ; inputs: HL (Dividend), C (divisor)
                        ; destroys: A
                        ; OPERATION: HL/C
                        ; returns: HL (quotient), A (remainder)
                        ; source: WKT
                        
3E54: AF       [ 4]     DIV_16_8:   xor     A
3E55: 0610     [11]                 ld      B,16
3E57: 29       [11]     DIV_16_8LP: add     HL,HL
3E58: 17       [15]                 rla
3E59: 3803     [22|27]              jr      C,$+5
3E5B: B9       [26]                 cp      C
3E5C: 3802     [33|38]              jr      C,$+4
3E5E: 91       [37]                 sub     C
3E5F: 2C       [41]                 inc     L
3E60: 10F5     [49|54]              djnz    DIV_16_8LP
3E62: C9       [59]                 ret
                                
                        ; ----------------------------------------------------------------------
                        ; divide a 16-bit number by a 16-bit number
                        ; (16/16 division)
                        ;
                        ; inputs: AC (Dividend), DE (divisor)
                        ; destroys: HL,A,C
                        ; OPERATION: AC/DE
                        ; returns: AC (quotient), HL (remainder)
                        ; source: WKT
3E63: 210000   [10]     DIV_16_16:  ld      HL, 0
3E66: 0610     [17]                 ld      B, 16
3E68: CB21     [ 8]     DV16_16_LP: sla     C
3E6A: CBC1     [16]                 set     0,C         ; this simulates the SLL undocumented instruction
3E6C: 17       [20]                 rla
3E6D: ED6A     [35]                 adc     HL,HL
3E6F: ED52     [50]                 sbc     HL,DE
3E71: 3002     [57|62]              jr      NC, $+4
3E73: 19       [68]                 add     HL,DE
3E74: 0D       [72]                 dec     C
3E75: 10F1     [80|85]              djnz    DV16_16_LP
3E77: C9       [90]                 ret
                        
                        ; include the latest version of the font sets
                        #include "../include/vdp/6x8fonts-r16.asm"
                        ; ------------------------------------------------------------------------------
                        ; LM80C - 6x8 CHARSET - R1.6
                        ; ------------------------------------------------------------------------------
                        ; The following code is intended to be used with LM80C Z80-based computer
                        ; designed by Leonardo Miliani. More info at
                        ; www DOT leonardomiliani DOT com
                        ; ------------------------------------------------------------------------------
                        ; Code Revision:
                        ; R1.0 - 20190511 - First revision: ASCII chars (from 0 to 127)
                        ; R1.1 - 20190521 - Expanded to 255 chars
                        ; R1.2 - 20191209 - Start adding graphic chars to be coherent with 8x8 fonts
                        ; R1.3 - 20191226 - Added extended char codes (128-255)
                        ; R1.4 - 20200228 - adopted more usual hexadecimal & binary prefixes
                        ; R1.5 - 20200524 - New style for char #252
                        ; R1.6 - 20200704 - Redefined chars 105, 106, and 252
                        ; ------------------------------------------------------------------------------
                        ;
                        ;-------------------------------------------------------------------------------
                        ;
                        ;               6 x 8    C  H  A  R  S  E  T
                        ;
                        ;-------------------------------------------------------------------------------
                        ;
                        ;       6X8 CHARS, DESIGNED FOR TEXT BUT USABLE IN GRAPHICS 1 MODE TOO
                        ;       UPDATE: NOW GRAPHICS 1 MODE HAS ITS OWN CHAR SET
                        
3E78:                   CHRST68 equ $
3E78: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
3E7C: 00000000          
3E80: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
3E84: 00000000          
3E88: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
3E8C: 00000000          
3E90: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
3E94: 00000000          
3E98: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
3E9C: 00000000          
3EA0: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
3EA4: 00000000          
3EA8: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
3EAC: 00000000          
3EB0: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
3EB4: 00000000          
3EB8: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
3EBC: 00000000          
3EC0: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
3EC4: 00000000          
3EC8: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
3ECC: 00000000          
3ED0: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 
3ED4: 00000000          
3ED8: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
3EDC: 00000000          
3EE0: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
3EE4: 00000000          
3EE8: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
3EEC: 00000000          
3EF0: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
3EF4: 00000000          
3EF8: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
3EFC: 00000000          
3F00: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
3F04: 00000000          
3F08: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
3F0C: 00000000          
3F10: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
3F14: 00000000          
3F18: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
3F1C: 00000000          
3F20: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
3F24: 00000000          
3F28: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
3F2C: 00000000          
3F30: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
3F34: 00000000          
3F38: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
3F3C: 00000000          
3F40: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
3F44: 00000000          
3F48: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
3F4C: 00000000          
3F50: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
3F54: 00000000          
3F58: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
3F5C: 00000000          
3F60: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
3F64: 00000000          
3F68: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
3F6C: 00000000          
3F70: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
3F74: 00000000          
3F78: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32: space
3F7C: 00000000          
3F80: 20202020                  defb $20,$20,$20,$20,$20,$00,$20,$00 ; char 33: !
3F84: 20002000          
3F88: 50500000                  defb $50,$50,$00,$00,$00,$00,$00,$00 ; char 34: "
3F8C: 00000000          
3F90: 5050F850                  defb $50,$50,$f8,$50,$f8,$50,$50,$00 ; char 35: #
3F94: F8505000          
3F98: 2078A070                  defb $20,$78,$a0,$70,$28,$f0,$20,$00 ; char 36: $
3F9C: 28F02000          
3FA0: C0C81020                  defb $c0,$c8,$10,$20,$40,$98,$18,$00 ; char 37: %
3FA4: 40981800          
3FA8: 6090A040                  defb $60,$90,$a0,$40,$a8,$90,$68,$00 ; char 38: &
3FAC: A8906800          
3FB0: 60204000                  defb $60,$20,$40,$00,$00,$00,$00,$00 ; char 39: '
3FB4: 00000000          
3FB8: 10204040                  defb $10,$20,$40,$40,$40,$20,$10,$00 ; char 40: (
3FBC: 40201000          
3FC0: 40201010                  defb $40,$20,$10,$10,$10,$20,$40,$00 ; char 41: )
3FC4: 10204000          
3FC8: 0020A870                  defb $00,$20,$a8,$70,$a8,$20,$00,$00 ; char 42: *
3FCC: A8200000          
3FD0: 002020F8                  defb $00,$20,$20,$f8,$20,$20,$00,$00 ; char 43: +
3FD4: 20200000          
3FD8: 00000000                  defb $00,$00,$00,$00,$60,$20,$40,$00 ; char 44: ,
3FDC: 60204000          
3FE0: 000000F8                  defb $00,$00,$00,$f8,$00,$00,$00,$00 ; char 45: -
3FE4: 00000000          
3FE8: 00000000                  defb $00,$00,$00,$00,$00,$60,$60,$00 ; char 46: .
3FEC: 00606000          
3FF0: 00081020                  defb $00,$08,$10,$20,$40,$80,$00,$00 ; char 47: /
3FF4: 40800000          
3FF8: 708898A8                  defb $70,$88,$98,$a8,$c8,$88,$70,$00 ; char 48: 0
3FFC: C8887000          
4000: 20602020                  defb $20,$60,$20,$20,$20,$20,$70,$00 ; char 49: 1
4004: 20207000          
4008: 70880810                  defb $70,$88,$08,$10,$20,$40,$f8,$00 ; char 50: 2
400C: 2040F800          
4010: F8102010                  defb $f8,$10,$20,$10,$08,$88,$70,$00 ; char 51: 3
4014: 08887000          
4018: 10305090                  defb $10,$30,$50,$90,$f8,$10,$10,$00 ; char 52: 4
401C: F8101000          
4020: F880F008                  defb $f8,$80,$f0,$08,$08,$88,$70,$00 ; char 53: 5
4024: 08887000          
4028: 304080F0                  defb $30,$40,$80,$f0,$88,$88,$70,$00 ; char 54: 6
402C: 88887000          
4030: F8081020                  defb $f8,$08,$10,$20,$40,$40,$40,$00 ; char 55: 7
4034: 40404000          
4038: 70888870                  defb $70,$88,$88,$70,$88,$88,$70,$00 ; char 56: 8
403C: 88887000          
4040: 70888878                  defb $70,$88,$88,$78,$08,$10,$60,$00 ; char 57: 9
4044: 08106000          
4048: 00303000                  defb $00,$30,$30,$00,$30,$30,$00,$00 ; char 58: :
404C: 30300000          
4050: 00303000                  defb $00,$30,$30,$00,$30,$10,$20,$00 ; char 59: ;
4054: 30102000          
4058: 10204080                  defb $10,$20,$40,$80,$40,$20,$10,$00 ; char 60: <
405C: 40201000          
4060: 0000F800                  defb $00,$00,$f8,$00,$f8,$00,$00,$00 ; char 61: =
4064: F8000000          
4068: 40201008                  defb $40,$20,$10,$08,$10,$20,$40,$00 ; char 62: >
406C: 10204000          
4070: 70880810                  defb $70,$88,$08,$10,$20,$00,$20,$00 ; char 63: ?
4074: 20002000          
4078: 70880868                  defb $70,$88,$08,$68,$a8,$a8,$70,$00 ; char 64: @
407C: A8A87000          
4080: 70888888                  defb $70,$88,$88,$88,$f8,$88,$88,$00 ; char 65: A
4084: F8888800          
4088: F08888F0                  defb $f0,$88,$88,$f0,$88,$88,$f0,$00 ; char 66: B
408C: 8888F000          
4090: 70888080                  defb $70,$88,$80,$80,$80,$88,$70,$00 ; char 67: C
4094: 80887000          
4098: E0908888                  defb $e0,$90,$88,$88,$88,$90,$e0,$00 ; char 68: D
409C: 8890E000          
40A0: F88080F0                  defb $f8,$80,$80,$f0,$80,$80,$f8,$00 ; char 69: E
40A4: 8080F800          
40A8: F88080F0                  defb $f8,$80,$80,$f0,$80,$80,$80,$00 ; char 70: F
40AC: 80808000          
40B0: 708880B8                  defb $70,$88,$80,$b8,$88,$88,$78,$00 ; char 71: G
40B4: 88887800          
40B8: 888888F8                  defb $88,$88,$88,$f8,$88,$88,$88,$00 ; char 72: H
40BC: 88888800          
40C0: 70202020                  defb $70,$20,$20,$20,$20,$20,$70,$00 ; char 73: I
40C4: 20207000          
40C8: 38101010                  defb $38,$10,$10,$10,$10,$90,$60,$00 ; char 74: J
40CC: 10906000          
40D0: 8890A0C0                  defb $88,$90,$a0,$c0,$a0,$90,$88,$00 ; char 75: K
40D4: A0908800          
40D8: 80808080                  defb $80,$80,$80,$80,$80,$80,$f8,$00 ; char 76: L
40DC: 8080F800          
40E0: 88D8A8A8                  defb $88,$d8,$a8,$a8,$88,$88,$88,$00 ; char 77: M
40E4: 88888800          
40E8: 88C8A898                  defb $88,$c8,$a8,$98,$88,$88,$88,$00 ; char 78: N
40EC: 88888800          
40F0: 70888888                  defb $70,$88,$88,$88,$88,$88,$70,$00 ; char 79: O
40F4: 88887000          
40F8: F08888F0                  defb $f0,$88,$88,$f0,$80,$80,$80,$00 ; char 80: P
40FC: 80808000          
4100: 70888888                  defb $70,$88,$88,$88,$a8,$90,$68,$00 ; char 81: Q
4104: A8906800          
4108: F08888F0                  defb $f0,$88,$88,$f0,$a0,$90,$88,$00 ; char 82: R
410C: A0908800          
4110: 78808070                  defb $78,$80,$80,$70,$08,$08,$f0,$00 ; char 83: S
4114: 0808F000          
4118: F8202020                  defb $f8,$20,$20,$20,$20,$20,$20,$00 ; char 84: T
411C: 20202000          
4120: 88888888                  defb $88,$88,$88,$88,$88,$88,$70,$00 ; char 85: U
4124: 88887000          
4128: 88888888                  defb $88,$88,$88,$88,$88,$50,$20,$00 ; char 86: V
412C: 88502000          
4130: 88888888                  defb $88,$88,$88,$88,$a8,$a8,$50,$00 ; char 87: W
4134: A8A85000          
4138: 88885020                  defb $88,$88,$50,$20,$50,$88,$88,$00 ; char 88: X
413C: 50888800          
4140: 88888850                  defb $88,$88,$88,$50,$20,$20,$20,$00 ; char 89: Y
4144: 20202000          
4148: F8081020                  defb $f8,$08,$10,$20,$40,$80,$f8,$00 ; char 90: Z
414C: 4080F800          
4150: 70404040                  defb $70,$40,$40,$40,$40,$40,$70,$00 ; char 91: [
4154: 40407000          
4158: 00804020                  defb $00,$80,$40,$20,$10,$08,$00,$00 ; char 92: \
415C: 10080000          
4160: 70101010                  defb $70,$10,$10,$10,$10,$10,$70,$00 ; char 93: ]
4164: 10107000          
4168: 20508800                  defb $20,$50,$88,$00,$00,$00,$00,$00 ; char 94: ^
416C: 00000000          
4170: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$FC ; char 95: _ (underscore)
4174: 000000FC          
4178: 40201000                  defb $40,$20,$10,$00,$00,$00,$00,$00 ; char 96: `
417C: 00000000          
4180: 00007008                  defb $00,$00,$70,$08,$78,$88,$78,$00 ; char 97: a
4184: 78887800          
4188: 808080B0                  defb $80,$80,$80,$b0,$c8,$88,$f0,$00 ; char 98: b
418C: C888F000          
4190: 00007080                  defb $00,$00,$70,$80,$80,$88,$70,$00 ; char 99: c
4194: 80887000          
4198: 08080868                  defb $08,$08,$08,$68,$98,$88,$78,$00 ; char 100: d
419C: 98887800          
41A0: 00007088                  defb $00,$00,$70,$88,$f8,$80,$70,$00 ; char 101: e
41A4: F8807000          
41A8: 304840E0                  defb $30,$48,$40,$e0,$40,$40,$40,$00 ; char 102: f
41AC: 40404000          
41B0: 00007888                  defb $00,$00,$78,$88,$78,$08,$70,$00 ; char 103: g
41B4: 78087000          
41B8: 8080B0C8                  defb $80,$80,$b0,$c8,$88,$88,$88,$00 ; char 104: h
41BC: 88888800          
41C0: 20002020                  defb $20,$00,$20,$20,$20,$20,$20,$00 ; char 105: i
41C4: 20202000          
41C8: 08001808                  defb $08,$00,$18,$08,$08,$88,$70,$00 ; char 106: j
41CC: 08887000          
41D0: 808090A0                  defb $80,$80,$90,$a0,$c0,$a0,$90,$00 ; char 107: k
41D4: C0A09000          
41D8: 60202020                  defb $60,$20,$20,$20,$20,$20,$70,$00 ; char 108: l
41DC: 20207000          
41E0: 0000D0A8                  defb $00,$00,$d0,$a8,$a8,$88,$88,$00 ; char 109: m
41E4: A8888800          
41E8: 0000B0C8                  defb $00,$00,$b0,$c8,$88,$88,$88,$00 ; char 110: n
41EC: 88888800          
41F0: 00007088                  defb $00,$00,$70,$88,$88,$88,$70,$00 ; char 111: o
41F4: 88887000          
41F8: 0000F088                  defb $00,$00,$f0,$88,$f0,$80,$80,$00 ; char 112: p
41FC: F0808000          
4200: 00007888                  defb $00,$00,$78,$88,$78,$08,$08,$00 ; char 113: q
4204: 78080800          
4208: 0000B0C8                  defb $00,$00,$b0,$c8,$80,$80,$80,$00 ; char 114: r
420C: 80808000          
4210: 00007080                  defb $00,$00,$70,$80,$70,$08,$f0,$00 ; char 115: s
4214: 7008F000          
4218: 4040E040                  defb $40,$40,$e0,$40,$40,$48,$30,$00 ; char 116: t
421C: 40483000          
4220: 00008888                  defb $00,$00,$88,$88,$88,$98,$68,$00 ; char 117: u
4224: 88986800          
4228: 00008888                  defb $00,$00,$88,$88,$88,$50,$20,$00 ; char 118: v
422C: 88502000          
4230: 00008888                  defb $00,$00,$88,$88,$a8,$a8,$50,$00 ; char 119: w
4234: A8A85000          
4238: 00008850                  defb $00,$00,$88,$50,$20,$50,$88,$00 ; char 120: x
423C: 20508800          
4240: 00008898                  defb $00,$00,$88,$98,$68,$08,$70,$00 ; char 121: y
4244: 68087000          
4248: 0000F810                  defb $00,$00,$f8,$10,$20,$40,$f8,$00 ; char 122: z
424C: 2040F800          
4250: 10202040                  defb $10,$20,$20,$40,$20,$20,$10,$00 ; char 123: {
4254: 20201000          
4258: 20202020                  defb $20,$20,$20,$20,$20,$20,$20,$00 ; char 124: |
425C: 20202000          
4260: 20101008                  defb $20,$10,$10,$08,$10,$10,$20,$00 ; char 125: }
4264: 10102000          
4268: 00285000                  defb $00,$28,$50,$00,$00,$00,$00,$00 ; char 126: ~
426C: 00000000          
4270: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 127: (delete) - here end the standard ASCII (0-127)
4274: 00000000          
4278: 7884CC84                  defb %01111000,%10000100,%11001100,%10000100,%10110100,%10000100,%01111000,%00000000 ; char 128 (open face)
427C: B4847800          
4280: 78FCB4FC                  defb %01111000,%11111100,%10110100,%11111100,%10110100,%11001100,%01111000,%00000000 ; char 129 (full face)
4284: B4CC7800          
4288: 48FCFCFC                  defb %01001000,%11111100,%11111100,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 130 (hearts)
428C: FC783000          
4290: 002070F8                  defb %00000000,%00100000,%01110000,%11111000,%11111000,%01110000,%00100000,%00000000 ; char 131 (diamonds)
4294: F8702000          
4298: 7020A8F8                  defb %01110000,%00100000,%10101000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 132 (clubs)
429C: A8207000          
42A0: 2070F8F8                  defb %00100000,%01110000,%11111000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 133 (spades)
42A4: A8207000          
42A8: 303030FC                  defb %00110000,%00110000,%00110000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 134 
42AC: FC303030          
42B0: 0000003C                  defb %00000000,%00000000,%00000000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 135 
42B4: 3C303030          
42B8: 000000F0                  defb %00000000,%00000000,%00000000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 136 
42BC: F0303030          
42C0: 303030F0                  defb %00110000,%00110000,%00110000,%11110000,%11110000,%00000000,%00000000,%00000000 ; char 137 
42C4: F0000000          
42C8: 3030303C                  defb %00110000,%00110000,%00110000,%00111100,%00111100,%00000000,%00000000,%00000000 ; char 138 
42CC: 3C000000          
42D0: 303030FC                  defb %00110000,%00110000,%00110000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 139 
42D4: FC000000          
42D8: 3030303C                  defb %00110000,%00110000,%00110000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 140 
42DC: 3C303030          
42E0: 000000FC                  defb %00000000,%00000000,%00000000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 141 
42E4: FC303030          
42E8: 303030F0                  defb %00110000,%00110000,%00110000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 142 
42EC: F0303030          
42F0: 000000FC                  defb %00000000,%00000000,%00000000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 143 
42F4: FC000000          
42F8: 30303030                  defb %00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000 ; char 144 
42FC: 30303030          
4300: 0C1C1838                  defb %00001100,%00011100,%00011000,%00111000,%01110000,%01100000,%11100000,%11000000 ; char 145 
4304: 7060E0C0          
4308: C0E06070                  defb %11000000,%11100000,%01100000,%01110000,%00111000,%00011000,%00011100,%00001100 ; char 146 
430C: 38181C0C          
4310: CCCC7830                  defb %11001100,%11001100,%01111000,%00110000,%00110000,%01111000,%11001100,%11001100 ; char 147 
4314: 3078CCCC          
4318: 202020FC                  defb %00100000,%00100000,%00100000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 148 
431C: 20202020          
4320: 0000003C                  defb %00000000,%00000000,%00000000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 149 
4324: 20202020          
4328: 000000E0                  defb %00000000,%00000000,%00000000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 150 
432C: 20202020          
4330: 202020E0                  defb %00100000,%00100000,%00100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 151 
4334: 00000000          
4338: 2020203C                  defb %00100000,%00100000,%00100000,%00111100,%00000000,%00000000,%00000000,%00000000 ; char 152 
433C: 00000000          
4340: 202020FC                  defb %00100000,%00100000,%00100000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 153 
4344: 00000000          
4348: 2020203C                  defb %00100000,%00100000,%00100000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 154 
434C: 20202020          
4350: 000000FC                  defb %00000000,%00000000,%00000000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 155 
4354: 20202020          
4358: 202020E0                  defb %00100000,%00100000,%00100000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 156 
435C: 20202020          
4360: 000000FC                  defb %00000000,%00000000,%00000000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 157 
4364: 00000000          
4368: 20202020                  defb %00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000 ; char 158 
436C: 20202020          
4370: 04080810                  defb %00000100,%00001000,%00001000,%00010000,%00100000,%01000000,%01000000,%10000000 ; char 159 
4374: 20404080          
4378: 80404020                  defb %10000000,%01000000,%01000000,%00100000,%00010000,%00001000,%00001000,%00000100 ; char 160 
437C: 10080804          
4380: 84484830                  defb %10000100,%01001000,%01001000,%00110000,%00110000,%01001000,%01001000,%10000100 ; char 161 
4384: 30484884          
4388: 00000000                  defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 162 
438C: 0000FCFC          
4390: 00000000                  defb %00000000,%00000000,%00000000,%00000000,%11111100,%11111100,%11111100,%11111100 ; char 163 
4394: FCFCFCFC          
4398: 0000FCFC                  defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 164 
439C: FCFCFCFC          
43A0: FCFC0000                  defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165 
43A4: 00000000          
43A8: FCFCFCFC                  defb %11111100,%11111100,%11111100,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 166 
43AC: 00000000          
43B0: FCFCFCFC                  defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 167 
43B4: FCFC0000          
43B8: 80808080                  defb %10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000 ; char 168 
43BC: 80808080          
43C0: E0E0E0E0                  defb %11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000 ; char 169 
43C4: E0E0E0E0          
43C8: F8F8F8F8                  defb %11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000 ; char 170 
43CC: F8F8F8F8          
43D0: 04040404                  defb %00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100 ; char 171 
43D4: 04040404          
43D8: 1C1C1C1C                  defb %00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100 ; char 172 
43DC: 1C1C1C1C          
43E0: 7C7C7C7C                  defb %01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100 ; char 173 
43E4: 7C7C7C7C          
43E8: FC848484                  defb %11111100,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 174 
43EC: 848484FC          
43F0: 00000000                  defb %00000000,%00000000,%00000000,%00000000,%11100000,%11100000,%11100000,%11100000 ; char 175 
43F4: E0E0E0E0          
43F8: 00000000                  defb %00000000,%00000000,%00000000,%00000000,%00011100,%00011100,%00011100,%00011100 ; char 176 
43FC: 1C1C1C1C          
4400: 1C1C1C1C                  defb %00011100,%00011100,%00011100,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 177 
4404: 00000000          
4408: E0E0E0E0                  defb %11100000,%11100000,%11100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 178 
440C: 00000000          
4410: E0E0E0E0                  defb %11100000,%11100000,%11100000,%11100000,%00011100,%00011100,%00011100,%00011100 ; char 179 
4414: 1C1C1C1C          
4418: 1C1C1C1C                  defb %00011100,%00011100,%00011100,%00011100,%11100000,%11100000,%11100000,%11100000 ; char 180 
441C: E0E0E0E0          
4420: 78787878                  defb %01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000 ; char 181 
4424: 78787878          
4428: CCCCCCCC                  defb %11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100 ; char 182 
442C: CCCCCCCC          
4430: FCFC0000                  defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 183 
4434: 0000FCFC          
4438: 0000FCFC                  defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 184 
443C: FCFC0000          
4440: 3030CCCC                  defb %00110000,%00110000,%11001100,%11001100,%00110000,%00110000,%11001100,%11001100 ; char 185 
4444: 3030CCCC          
4448: 54A854A8                  defb %01010100,%10101000,%01010100,%10101000,%01010100,%10101000,%01010100,%10101000 ; char 186 
444C: 54A854A8          
4450: 643098CC                  defb %01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100 ; char 187 
4454: 643098CC          
4458: CC643098                  defb %11001100,%01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000 ; char 188 
445C: CC643098          
4460: 3098CC64                  defb %00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100,%01100100 ; char 189 
4464: 3098CC64          
4468: 64CC9830                  defb %01100100,%11001100,%10011000,%00110000,%01100100,%11001100,%10011000,%00110000 ; char 190 
446C: 64CC9830          
4470: 2020F820                  defb %00100000,%00100000,%11111000,%00100000,%00100000,%00000000,%11111000,%00000000 ; char 191 (Â±)
4474: 2000F800          
4478: C0300830                  defb %11000000,%00110000,%00001000,%00110000,%11000000,%00000000,%11111000,%00000000 ; char 192 (â¥)
447C: C000F800          
4480: 18608060                  defb %00011000,%01100000,%10000000,%01100000,%00011000,%00000000,%11111000,%00000000 ; char 193 (â¤)
4484: 1800F800          
4488: 3C202020                  defb %00111100,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
448C: A0602000          
4490: 30484830                  defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
4494: 00000000          
4498: 60103040                  defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
449C: 70000000          
44A0: 000054A8                  defb %00000000,%00000000,%01010100,%10101000,%00000000,%11111100,%00000000,%00000000 ; char 197
44A4: 00FC0000          
44A8: 0054A800                  defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
44AC: 54A80000          
44B0: 0080C0E0                  defb %00000000,%10000000,%11000000,%11100000,%11100000,%11000000,%10000000,%00000000 ; char 199
44B4: E0C08000          
44B8: FC783000                  defb %11111100,%01111000,%00110000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 200
44BC: 00000000          
44C0: 00040C1C                  defb %00000000,%00000100,%00001100,%00011100,%00011100,%00001100,%00000100,%00000000 ; char 201
44C4: 1C0C0400          
44C8: 00000000                  defb %00000000,%00000000,%00000000,%00000000,%00000000,%00110000,%01111000,%11111100 ; char 202 
44CC: 003078FC          
44D0: 2070F820                  defb %00100000,%01110000,%11111000,%00100000,%00100000,%00100000,%00100000,%00000000 ; char 203 (up arrow)
44D4: 20202000          
44D8: 3C1C1C24                  defb %00111100,%00011100,%00011100,%00100100,%01000000,%10000000,%00000000,%00000000 ; char 204 (up right arrow)
44DC: 40800000          
44E0: 001018FC                  defb %00000000,%00010000,%00011000,%11111100,%00011000,%00010000,%00000000,%00000000 ; char 205 (right arrow)
44E4: 18100000          
44E8: 00008040                  defb %00000000,%00000000,%10000000,%01000000,%00100100,%00011100,%00011100,%00111100 ; char 206 (down right arrow)
44EC: 241C1C3C          
44F0: 00202020                  defb %00000000,%00100000,%00100000,%00100000,%00100000,%11111000,%01110000,%00100000 ; char 207 (down arrow)
44F4: 20F87020          
44F8: 00000408                  defb %00000000,%00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000 ; char 208 (down left arrow)
44FC: 90E0E0F0          
4500: 002060FC                  defb %00000000,%00100000,%01100000,%11111100,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
4504: 60200000          
4508: F0E0E090                  defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
450C: 08040000          
4510: 3844F040                  defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
4514: F0443800          
4518: 000478A8                  defb %00000000,%00000100,%01111000,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
451C: 28282800          
4520: 00000000                  defb %00000000,%00000000,%00000000,%00000000,%00011100,%00100000,%00100000,%00100000 ; char 213
4524: 1C202020          
4528: 00000000                  defb %00000000,%00000000,%00000000,%00000000,%11100000,%00010000,%00010000,%00010000 ; char 214
452C: E0101010          
4530: 101010E0                  defb %00010000,%00010000,%00010000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 215
4534: 00000000          
4538: 2020201C                  defb %00100000,%00100000,%00100000,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 216
453C: 00000000          
4540: 0000001C                  defb %00000000,%00000000,%00000000,%00011100,%00111100,%00110000,%00110000,%00110000 ; char 217
4544: 3C303030          
4548: 000000E0                  defb %00000000,%00000000,%00000000,%11100000,%11110000,%00110000,%00110000,%00110000 ; char 218
454C: F0303030          
4550: 303030F0                  defb %00110000,%00110000,%00110000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
4554: E0000000          
4558: 3030303C                  defb %00110000,%00110000,%00110000,%00111100,%00011100,%00000000,%00000000,%00000000 ; char 220
455C: 1C000000          
4560: 00304848                  defb %00000000,%00110000,%01001000,%01001000,%01001000,%00110000,%00000000,%00000000 ; char 221
4564: 48300000          
4568: 00307878                  defb %00000000,%00110000,%01111000,%01111000,%01111000,%00110000,%00000000,%00000000 ; char 222
456C: 78300000          
4570: 003078FC                  defb %00000000,%00110000,%01111000,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 223
4574: FC783000          
4578: FCF8F0E0                  defb %11111100,%11111000,%11110000,%11100000,%11100000,%11000000,%10000000,%10000000 ; char 224
457C: E0C08080          
4580: FC7C3C1C                  defb %11111100,%01111100,%00111100,%00011100,%00011100,%00001100,%00000100,%00000100 ; char 225
4584: 1C0C0404          
4588: 04040C1C                  defb %00000100,%00000100,%00001100,%00011100,%00011100,%00111100,%01111100,%11111100 ; char 226
458C: 1C3C7CFC          
4590: 8080C0E0                  defb %10000000,%10000000,%11000000,%11100000,%11100000,%11110000,%11111000,%11111100 ; char 227
4594: E0F0F8FC          
4598: 00040CD8                  defb %00000000,%00000100,%00001100,%11011000,%11110000,%11100000,%11000000,%00000000 ; char 228 (checkmark)
459C: F0E0C000          
45A0: 00CC7830                  defb %00000000,%11001100,%01111000,%00110000,%01111000,%11001100,%00000000,%00000000 ; char 229 (x)
45A4: 78CC0000          
45A8: 70888888                  defb %01110000,%10001000,%10001000,%10001000,%01110000,%00100000,%01110000,%00100000 ; char 230 (female)
45AC: 70207020          
45B0: 001C0C74                  defb %00000000,%00011100,%00001100,%01110100,%10010000,%10010000,%01100000,%00000000 ; char 231 (male)
45B4: 90906000          
45B8: F8848484                  defb %11111000,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 232 (new doc)
45BC: 848484FC          
45C0: 00F0FC84                  defb %00000000,%11110000,%11111100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 233 (folder)
45C4: 848484FC          
45C8: 3078FC48                  defb %00110000,%01111000,%11111100,%01001000,%01001000,%01001000,%01001000,%01111000 ; char 234 (trash bin)
45CC: 48484878          
45D0: FC848484                  defb %11111100,%10000100,%10000100,%10000100,%11111100,%10110100,%10110100,%11111100 ; char 235 (floppy disk)
45D4: FCB4B4FC          
45D8: 0000D4D8                  defb %00000000,%00000000,%11010100,%11011000,%11010100,%11010100,%00000000,%00000000 ; char 236 (OK)
45DC: D4D40000          
45E0: 3078FC78                  defb %00110000,%01111000,%11111100,%01111000,%01111000,%01001000,%01001000,%01001000 ; char 237 (home)
45E4: 78484848          
45E8: 7884A4A4                  defb %01111000,%10000100,%10100100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 238 (clock)
45EC: B4847800          
45F0: 000008F4                  defb %00000000,%00000000,%00001000,%11110100,%10101000,%10000000,%00000000,%00000000 ; char 239 (key)
45F4: A8800000          
45F8: 203078B0                  defb %00100000,%00110000,%01111000,%10110000,%10100000,%10001000,%01110000,%00000000 ; char 240 (undo)
45FC: A0887000          
4600: 00FCCCB4                  defb %00000000,%11111100,%11001100,%10110100,%10000100,%10000100,%11111100,%00000000 ; char 241 (letter)
4604: 8484FC00          
4608: 609090F0                  defb %01100000,%10010000,%10010000,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 242 (lock)
460C: F0F0F000          
4610: 081414F0                  defb %00001000,%00010100,%00010100,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 243 (unlock)
4614: F0F0F000          
4618: FCFC84B4                  defb %11111100,%11111100,%10000100,%10110100,%10010100,%10010100,%10000100,%11111100 ; char 244 (calendar)
461C: 949484FC          
4620: 00043858                  defb %00000000,%00000100,%00111000,%01011000,%01101000,%01110000,%10000000,%00000000 ; char 245 (diameter)
4624: 68708000          
4628: 78848484                  defb %01111000,%10000100,%10000100,%10000100,%01101100,%00011000,%00001000,%00000000 ; char 246 (baloon)
462C: 6C180800          
4630: 30282828                  defb %00110000,%00101000,%00101000,%00101000,%00100000,%01100000,%11100000,%01000000 ; char 247 (note)
4634: 2060E040          
4638: 2068E4E4                  defb %00100000,%01101000,%11100100,%11100100,%11100100,%01101000,%00100000,%00000000 ; char 248 (audio on)
463C: E4682000          
4640: 2060E0E0                  defb %00100000,%01100000,%11100000,%11100000,%11100000,%01100000,%00100000,%00000000 ; char 249 (audio off)
4644: E0602000          
4648: 80C0E0F0                  defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11110000,%10010000 ; char 250 (pointer)
464C: F8FCF090          
4650: 7884B4A4                  defb %01111000,%10000100,%10110100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 251 (Â©)
4654: B4847800          
4658: 304840E0                  defb %00110000,%01001000,%01000000,%11100000,%01000000,%01001000,%10110000,%00000000 ; char 252 (Â£)
465C: 4048B000          
4660: 7884F048                  defb %01111000,%10000100,%11110000,%01001000,%01001000,%00111100,%10000100,%01111000 ; char 253 (Â§)
4664: 483C8478          
4668: 00002000                  defb %00000000,%00000000,%00100000,%00000000,%11111000,%00000000,%00100000,%00000000 ; char 254 (Ã·)
466C: F8002000          
4670: FCFCFCFC                  defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 255 (cursor)
4674: FCFCFCFC          
                                ; here ends the ASCII table
                        #include "../include/vdp/8x8fonts-r18.asm"
                        ; ------------------------------------------------------------------------------
                        ; LM80C - 8x8 CHARSET - R1.8
                        ; ------------------------------------------------------------------------------
                        ; The following code is intended to be used with LM80C Z80-based computer
                        ; designed by Leonardo Miliani. More info at
                        ; www DOT leonardomiliani DOT com
                        ; ------------------------------------------------------------------------------
                        ; Code Revision:
                        ; R1.0 - 20190615 - First revision: ASCII chars (from 0 to 255) - actually, they are 6x8 pixels
                        ; R1.1 - 20190616 - Converted to 8x8 pixels
                        ; R1.2 - 20191013 - Added new graphic chars and reorganized previous ones
                        ; R1.3 - 20191015 - More graphic chars
                        ; R1.4 - 20191202 - Fixed char 11/12, added new special chars
                        ; R1.5 - 20191210 - Changed several graphic chars
                        ; R1.6 - 20200125 - Removed double chars, changed with new ones
                        ; R1.7 - 20200228 - adopted more usual hexadecimal & binary prefixes
                        ; R1.8 - 20200524 - New style for char #252
                        ; ------------------------------------------------------------------------------
                        ;
                        ;-------------------------------------------------------------------------------
                        ;
                        ;               8 x 8    C  H  A  R  S  E  T
                        ;
                        ;-------------------------------------------------------------------------------
                        ;
                        ;       8X8 CHARS, DESIGNED FOR GRAPHICS 1 MODE
                        
4678:                   CHRST88 equ $
4678: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
467C: 00000000          
4680: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
4684: 00000000          
4688: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
468C: 00000000          
4690: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
4694: 00000000          
4698: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
469C: 00000000          
46A0: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
46A4: 00000000          
46A8: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
46AC: 00000000          
46B0: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
46B4: 00000000          
46B8: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
46BC: 00000000          
46C0: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
46C4: 00000000          
46C8: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
46CC: 00000000          
46D0: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 
46D4: 00000000          
46D8: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
46DC: 00000000          
46E0: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
46E4: 00000000          
46E8: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
46EC: 00000000          
46F0: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
46F4: 00000000          
46F8: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
46FC: 00000000          
4700: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
4704: 00000000          
4708: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
470C: 00000000          
4710: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
4714: 00000000          
4718: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
471C: 00000000          
4720: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
4724: 00000000          
4728: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
472C: 00000000          
4730: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
4734: 00000000          
4738: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
473C: 00000000          
4740: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
4744: 00000000          
4748: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
474C: 00000000          
4750: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
4754: 00000000          
4758: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
475C: 00000000          
4760: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
4764: 00000000          
4768: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
476C: 00000000          
4770: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
4774: 00000000          
4778: 00000000                  defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32 - space
477C: 00000000          
4780: 10101010                  defb %00010000,%00010000,%00010000,%00010000,%00010000,%00000000,%00010000,%00000000 ; char 33 - !
4784: 10001000          
4788: 28282800                  defb %00101000,%00101000,%00101000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 34 - "
478C: 00000000          
4790: 2828FE28                  defb %00101000,%00101000,%11111110,%00101000,%11111110,%00101000,%00101000,%00000000 ; char 35 - #
4794: FE282800          
4798: 103C5038                  defb %00010000,%00111100,%01010000,%00111000,%00010100,%01111000,%00010000,%00000000 ; char 36 - $
479C: 14781000          
47A0: 00626408                  defb %00000000,%01100010,%01100100,%00001000,%00010000,%00100110,%01000110,%00000000 ; char 37 - %
47A4: 10264600          
47A8: 00304830                  defb %00000000,%00110000,%01001000,%00110000,%01001010,%01000100,%00111010,%00000000 ; char 38 - &
47AC: 4A443A00          
47B0: 08102000                  defb %00001000,%00010000,%00100000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 39 - '
47B4: 00000000          
47B8: 08102020                  defb %00001000,%00010000,%00100000,%00100000,%00100000,%00010000,%00001000,%00000000 ; char 40 - (
47BC: 20100800          
47C0: 20100808                  defb %00100000,%00010000,%00001000,%00001000,%00001000,%00010000,%00100000,%00000000 ; char 41 - )
47C4: 08102000          
47C8: 00105438                  defb %00000000,%00010000,%01010100,%00111000,%00111000,%01010100,%00010000,%00000000 ; char 42 - *
47CC: 38541000          
47D0: 0010107C                  defb %00000000,%00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%00000000 ; char 43 - +
47D4: 10100000          
47D8: 00000000                  defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00001000,%00010000 ; char 44 - ,
47DC: 00180810          
47E0: 0000007C                  defb %00000000,%00000000,%00000000,%01111100,%00000000,%00000000,%00000000,%00000000 ; char 45 - -
47E4: 00000000          
47E8: 00000000                  defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00011000,%00000000 ; char 46 - .
47EC: 00181800          
47F0: 00020408                  defb %00000000,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%00000000 ; char 47 - /
47F4: 10204000          
47F8: 38444C54                  defb %00111000,%01000100,%01001100,%01010100,%01100100,%01000100,%00111000,%00000000 ; char 48 - 0
47FC: 64443800          
4800: 10305010                  defb %00010000,%00110000,%01010000,%00010000,%00010000,%00010000,%01111100,%00000000 ; char 49 - 1
4804: 10107C00          
4808: 38440408                  defb %00111000,%01000100,%00000100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 50 - 2
480C: 10207C00          
4810: 7C081008                  defb %01111100,%00001000,%00010000,%00001000,%00000100,%01000100,%00111000,%00000000 ; char 51 - 3
4814: 04443800          
4818: 08182848                  defb %00001000,%00011000,%00101000,%01001000,%01111100,%00001000,%00001000,%00000000 ; char 52 - 4
481C: 7C080800          
4820: 7C407804                  defb %01111100,%01000000,%01111000,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 53 - 5
4824: 04443800          
4828: 38444078                  defb %00111000,%01000100,%01000000,%01111000,%01000100,%01000100,%00111000,%00000000 ; char 54 - 6
482C: 44443800          
4830: 7C040810                  defb %01111100,%00000100,%00001000,%00010000,%00100000,%00100000,%00100000,%00000000 ; char 55 - 7
4834: 20202000          
4838: 38444438                  defb %00111000,%01000100,%01000100,%00111000,%01000100,%01000100,%00111000,%00000000 ; char 56 - 8
483C: 44443800          
4840: 3844443C                  defb %00111000,%01000100,%01000100,%00111100,%00000100,%01000100,%00111000,%00000000 ; char 57 - 9
4844: 04443800          
4848: 00181800                  defb %00000000,%00011000,%00011000,%00000000,%00011000,%00011000,%00000000,%00000000 ; char 58 - :
484C: 18180000          
4850: 00181800                  defb %00000000,%00011000,%00011000,%00000000,%00011000,%00001000,%00010000,%00000000 ; char 59 - ;
4854: 18081000          
4858: 04081020                  defb %00000100,%00001000,%00010000,%00100000,%00010000,%00001000,%00000100,%00000000 ; char 60 - <
485C: 10080400          
4860: 00007E00                  defb %00000000,%00000000,%01111110,%00000000,%01111110,%00000000,%00000000,%00000000 ; char 61 - =
4864: 7E000000          
4868: 20100804                  defb %00100000,%00010000,%00001000,%00000100,%00001000,%00010000,%00100000,%00000000 ; char 62 - >
486C: 08102000          
4870: 38440408                  defb %00111000,%01000100,%00000100,%00001000,%00010000,%00000000,%00010000,%00000000 ; char 63 - ?
4874: 10001000          
4878: 7884BCAC                  defb %01111000,%10000100,%10111100,%10101100,%10111000,%10000000,%10000100,%01111000 ; char 64 - @
487C: B8808478          
4880: 38444444                  defb %00111000,%01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%00000000 ; char 65 - A
4884: 7C444400          
4888: 78444478                  defb %01111000,%01000100,%01000100,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 66 - B
488C: 44447800          
4890: 38444040                  defb %00111000,%01000100,%01000000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 67 - C
4894: 40443800          
4898: 78444444                  defb %01111000,%01000100,%01000100,%01000100,%01000100,%01000100,%01111000,%00000000 ; char 68 - D
489C: 44447800          
48A0: 7C404070                  defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01111100,%00000000 ; char 69 - E
48A4: 40407C00          
48A8: 7C404070                  defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01000000,%00000000 ; char 70 - F
48AC: 40404000          
48B0: 38444040                  defb %00111000,%01000100,%01000000,%01000000,%01011100,%01000100,%00111000,%00000000 ; char 71 - G
48B4: 5C443800          
48B8: 4444447C                  defb %01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%01000100,%00000000 ; char 72 - H
48BC: 44444400          
48C0: 38101010                  defb %00111000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 73 - I
48C4: 10103800          
48C8: 3C040404                  defb %00111100,%00000100,%00000100,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 74 - J
48CC: 04443800          
48D0: 44444870                  defb %01000100,%01000100,%01001000,%01110000,%01001000,%01000100,%01000100,%00000000 ; char 75 - K
48D4: 48444400          
48D8: 40404040                  defb %01000000,%01000000,%01000000,%01000000,%01000000,%01000000,%01111100,%00000000 ; char 76 - L
48DC: 40407C00          
48E0: 42665A42                  defb %01000010,%01100110,%01011010,%01000010,%01000010,%01000010,%01000010,%00000000 ; char 77 - M
48E4: 42424200          
48E8: 4464544C                  defb %01000100,%01100100,%01010100,%01001100,%01000100,%01000100,%01000100,%00000000 ; char 78 - N
48EC: 44444400          
48F0: 38444444                  defb %00111000,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 79 - O
48F4: 44443800          
48F8: 78444444                  defb %01111000,%01000100,%01000100,%01000100,%01111000,%01000000,%01000000,%00000000 ; char 80 - P
48FC: 78404000          
4900: 38444444                  defb %00111000,%01000100,%01000100,%01000100,%01010100,%01001000,%00110100,%00000000 ; char 81 - Q
4904: 54483400          
4908: 78444444                  defb %01111000,%01000100,%01000100,%01000100,%01111000,%01001000,%01000100,%00000000 ; char 82 - R
490C: 78484400          
4910: 3C404038                  defb %00111100,%01000000,%01000000,%00111000,%00000100,%00000100,%01111000,%00000000 ; char 83 - S
4914: 04047800          
4918: 7C101010                  defb %01111100,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 84 - T
491C: 10101000          
4920: 44444444                  defb %01000100,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 85 - U
4924: 44443800          
4928: 44444444                  defb %01000100,%01000100,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 86 - V
492C: 44281000          
4930: 42424242                  defb %01000010,%01000010,%01000010,%01000010,%01011010,%01011010,%00100100,%00000000 ; char 87 - W
4934: 5A5A2400          
4938: 44442810                  defb %01000100,%01000100,%00101000,%00010000,%00101000,%01000100,%01000100,%00000000 ; char 88 - X
493C: 28444400          
4940: 44444428                  defb %01000100,%01000100,%01000100,%00101000,%00010000,%00010000,%00010000,%00000000 ; char 89 - Y
4944: 10101000          
4948: 7C040810                  defb %01111100,%00000100,%00001000,%00010000,%00100000,%01000000,%01111100,%00000000 ; char 90 - Z
494C: 20407C00          
4950: 38202020                  defb %00111000,%00100000,%00100000,%00100000,%00100000,%00100000,%00111000,%00000000 ; char 91 - [
4954: 20203800          
4958: 00402010                  defb %00000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000000 ; char 92 - \
495C: 08040200          
4960: 38080808                  defb %00111000,%00001000,%00001000,%00001000,%00001000,%00001000,%00111000,%00000000 ; char 93 - ]
4964: 08083800          
4968: 10284400                  defb %00010000,%00101000,%01000100,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 94 - ^
496C: 00000000          
4970: 00000000                  defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%01111110,%00000000 ; char 95 _ (underscore)
4974: 00007E00          
4978: 20100800                  defb %00100000,%00010000,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 96 - `
497C: 00000000          
4980: 00003804                  defb %00000000,%00000000,%00111000,%00000100,%00111100,%01000100,%00111100,%00000000 ; char 97 - a
4984: 3C443C00          
4988: 40404078                  defb %01000000,%01000000,%01000000,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 98 - b
498C: 44447800          
4990: 00003840                  defb %00000000,%00000000,%00111000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 99 - c
4994: 40443800          
4998: 0404043C                  defb %00000100,%00000100,%00000100,%00111100,%01000100,%01000100,%00111100,%00000000 ; char 100 - d
499C: 44443C00          
49A0: 00003844                  defb %00000000,%00000000,%00111000,%01000100,%01111100,%01000000,%00111000,%00000000 ; char 101 - e
49A4: 7C403800          
49A8: 18242070                  defb %00011000,%00100100,%00100000,%01110000,%00100000,%00100000,%00100000,%00000000 ; char 102 - f
49AC: 20202000          
49B0: 00003C44                  defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00111000 ; char 103 - g
49B4: 443C0438          
49B8: 40405864                  defb %01000000,%01000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 104 - h
49BC: 44444400          
49C0: 00100010                  defb %00000000,%00010000,%00000000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 105 - i
49C4: 10101000          
49C8: 08001808                  defb %00001000,%00000000,%00011000,%00001000,%00001000,%00001000,%01001000,%00110000 ; char 106 - j
49CC: 08084830          
49D0: 40404850                  defb %01000000,%01000000,%01001000,%01010000,%01100000,%01010000,%01001000,%00000000 ; char 107 - k
49D4: 60504800          
49D8: 30101010                  defb %00110000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 108 - l
49DC: 10103800          
49E0: 0000546A                  defb %00000000,%00000000,%01010100,%01101010,%01001010,%01000010,%01000010,%00000000 ; char 109 - m
49E4: 4A424200          
49E8: 00005864                  defb %00000000,%00000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 110 - n
49EC: 44444400          
49F0: 00003844                  defb %00000000,%00000000,%00111000,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 111: o
49F4: 44443800          
49F8: 00007844                  defb %00000000,%00000000,%01111000,%01000100,%01000100,%01111000,%01000000,%01000000 ; char 112: p
49FC: 44784040          
4A00: 00003C44                  defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00000100 ; char 113: q
4A04: 443C0404          
4A08: 00005864                  defb %00000000,%00000000,%01011000,%01100100,%01000000,%01000000,%01000000,%00000000 ; char 114: r
4A0C: 40404000          
4A10: 00003840                  defb %00000000,%00000000,%00111000,%01000000,%00111000,%00000100,%01111000,%00000000 ; char 115: s
4A14: 38047800          
4A18: 20207020                  defb %00100000,%00100000,%01110000,%00100000,%00100000,%00100100,%00011000,%00000000 ; char 116: t
4A1C: 20241800          
4A20: 00004444                  defb %00000000,%00000000,%01000100,%01000100,%01000100,%01001100,%00110100,%00000000 ; char 117: u
4A24: 444C3400          
4A28: 00004444                  defb %00000000,%00000000,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 118: v
4A2C: 44281000          
4A30: 00004444                  defb %00000000,%00000000,%01000100,%01000100,%01010100,%01010100,%00101000,%00000000 ; char 119: w
4A34: 54542800          
4A38: 00004428                  defb %00000000,%00000000,%01000100,%00101000,%00010000,%00101000,%01000100,%00000000 ; char 120: x
4A3C: 10284400          
4A40: 00004444                  defb %00000000,%00000000,%01000100,%01000100,%01001100,%00110100,%00000100,%00111000 ; char 121: y
4A44: 4C340438          
4A48: 00007C08                  defb %00000000,%00000000,%01111100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 122: z
4A4C: 10207C00          
4A50: 18202040                  defb %00011000,%00100000,%00100000,%01000000,%00100000,%00100000,%00011000,%00000000 ; char 123: {
4A54: 20201800          
4A58: 10101010                  defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 124: |
4A5C: 10101000          
4A60: 30080804                  defb %00110000,%00001000,%00001000,%00000100,%00001000,%00001000,%00110000,%00000000 ; char 125: }
4A64: 08083000          
4A68: 20540800                  defb %00100000,%01010100,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 126: ~
4A6C: 00000000          
4A70: 00000000                  defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 127 (delete) - end the standard ASCII (0-127)
4A74: 00000000          
4A78: 3C42A581                  defb %00111100,%01000010,%10100101,%10000001,%10100101,%10011001,%01000010,%00111100 ; char 128 (open face)
4A7C: A599423C          
4A80: 3C7EDBFF                  defb %00111100,%01111110,%11011011,%11111111,%11011011,%11100111,%01111110,%00111100 ; char 129 (full face)
4A84: DBE77E3C          
4A88: 6CFEFEFE                  defb %01101100,%11111110,%11111110,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 130 (hearts)
4A8C: 7C381000          
4A90: 10387CFE                  defb %00010000,%00111000,%01111100,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 131 (diamonds)
4A94: 7C381000          
4A98: 103854FE                  defb %00010000,%00111000,%01010100,%11111110,%01010100,%00010000,%01111100,%00000000 ; char 132 (clus)
4A9C: 54107C00          
4AA0: 10387CFE                  defb %00010000,%00111000,%01111100,%11111110,%11010110,%00010000,%01111100,%00000000 ; char 133 (spades)
4AA4: D6107C00          
4AA8: 181818FF                  defb %00011000,%00011000,%00011000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 134
4AAC: FF181818          
4AB0: 0000001F                  defb %00000000,%00000000,%00000000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 135
4AB4: 1F181818          
4AB8: 000000F8                  defb %00000000,%00000000,%00000000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 136
4ABC: F8181818          
4AC0: 181818F8                  defb %00011000,%00011000,%00011000,%11111000,%11111000,%00000000,%00000000,%00000000 ; char 137
4AC4: F8000000          
4AC8: 1818181F                  defb %00011000,%00011000,%00011000,%00011111,%00011111,%00000000,%00000000,%00000000 ; char 138
4ACC: 1F000000          
4AD0: 181818FF                  defb %00011000,%00011000,%00011000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 139
4AD4: FF000000          
4AD8: 1818181F                  defb %00011000,%00011000,%00011000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 140
4ADC: 1F181818          
4AE0: 000000FF                  defb %00000000,%00000000,%00000000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 141
4AE4: FF181818          
4AE8: 181818F8                  defb %00011000,%00011000,%00011000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 142
4AEC: F8181818          
4AF0: 000000FF                  defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 143
4AF4: FF000000          
4AF8: 18181818                  defb %00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000 ; char 144
4AFC: 18181818          
4B00: 03070E1C                  defb %00000011,%00000111,%00001110,%00011100,%00111000,%01110000,%11100000,%11000000 ; char 145
4B04: 3870E0C0          
4B08: C0E07038                  defb %11000000,%11100000,%01110000,%00111000,%00011100,%00001110,%00000111,%00000011 ; char 146
4B0C: 1C0E0703          
4B10: C3E77E3C                  defb %11000011,%11100111,%01111110,%00111100,%00111100,%01111110,%11100111,%11000011 ; char 147
4B14: 3C7EE7C3          
4B18: 101010FF                  defb %00010000,%00010000,%00010000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 148
4B1C: 10101010          
4B20: 0000001F                  defb %00000000,%00000000,%00000000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 149
4B24: 10101010          
4B28: 000000F0                  defb %00000000,%00000000,%00000000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 150
4B2C: 10101010          
4B30: 101010F0                  defb %00010000,%00010000,%00010000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 151
4B34: 00000000          
4B38: 1010101F                  defb %00010000,%00010000,%00010000,%00011111,%00000000,%00000000,%00000000,%00000000 ; char 152
4B3C: 00000000          
4B40: 101010FF                  defb %00010000,%00010000,%00010000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 153
4B44: 00000000          
4B48: 1010101F                  defb %00010000,%00010000,%00010000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 154
4B4C: 10101010          
4B50: 000000FF                  defb %00000000,%00000000,%00000000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 155
4B54: 10101010          
4B58: 101010F0                  defb %00010000,%00010000,%00010000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 156
4B5C: 10101010          
4B60: 000000FF                  defb %00000000,%00000000,%00000000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 157
4B64: 00000000          
4B68: 10101010                  defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000 ; char 158
4B6C: 10101010          
4B70: 01020408                  defb %00000001,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%10000000 ; char 159
4B74: 10204080          
4B78: 80402010                  defb %10000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000001 ; char 160
4B7C: 08040201          
4B80: 81422418                  defb %10000001,%01000010,%00100100,%00011000,%00011000,%00100100,%01000010,%10000001 ; char 161
4B84: 18244281          
4B88: 00000000                  defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 162
4B8C: 0000FFFF          
4B90: 00000000                  defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; char 163
4B94: FFFFFFFF          
4B98: 0000FFFF                  defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 164
4B9C: FFFFFFFF          
4BA0: FFFF0000                  defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
4BA4: 00000000          
4BA8: FFFFFFFF                  defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 166
4BAC: 00000000          
4BB0: FFFFFFFF                  defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 167
4BB4: FFFF0000          
4BB8: C0C0C0C0                  defb %11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000 ; char 168
4BBC: C0C0C0C0          
4BC0: F0F0F0F0                  defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; char 169
4BC4: F0F0F0F0          
4BC8: FCFCFCFC                  defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 170
4BCC: FCFCFCFC          
4BD0: 03030303                  defb %00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011 ; char 171
4BD4: 03030303          
4BD8: 0F0F0F0F                  defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; char 172
4BDC: 0F0F0F0F          
4BE0: 3F3F3F3F                  defb %00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111 ; char 173
4BE4: 3F3F3F3F          
4BE8: FF818181                  defb %11111111,%10000001,%10000001,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 174
4BEC: 818181FF          
4BF0: 00000000                  defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; char 175
4BF4: F0F0F0F0          
4BF8: 00000000                  defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; char 176
4BFC: 0F0F0F0F          
4C00: 0F0F0F0F                  defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; char 177
4C04: 00000000          
4C08: F0F0F0F0                  defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 178
4C0C: 00000000          
4C10: F0F0F0F0                  defb %11110000,%11110000,%11110000,%11110000,%00001111,%00001111,%00001111,%00001111 ; char 179
4C14: 0F0F0F0F          
4C18: 0F0F0F0F                  defb %00001111,%00001111,%00001111,%00001111,%11110000,%11110000,%11110000,%11110000 ; char 180
4C1C: F0F0F0F0          
4C20: 3C3C3C3C                  defb %00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100 ; char 181
4C24: 3C3C3C3C          
4C28: C3C3C3C3                  defb %11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011 ; char 182
4C2C: C3C3C3C3          
4C30: FFFF0000                  defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 183
4C34: 0000FFFF          
4C38: 0000FFFF                  defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 184
4C3C: FFFF0000          
4C40: 3333CCCC                  defb %00110011,%00110011,%11001100,%11001100,%00110011,%00110011,%11001100,%11001100 ; char 185
4C44: 3333CCCC          
4C48: 55AA55AA                  defb %01010101,%10101010,%01010101,%10101010,%01010101,%10101010,%01010101,%10101010 ; char 186
4C4C: 55AA55AA          
4C50: 663399CC                  defb %01100110,%00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100 ; char 187
4C54: 663399CC          
4C58: CC993366                  defb %11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011,%01100110 ; char 188
4C5C: CC993366          
4C60: 3399CC66                  defb %00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100,%01100110 ; char 189
4C64: 3399CC66          
4C68: 66CC9933                  defb %01100110,%11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011 ; char 190
4C6C: 66CC9933          
4C70: 10107C10                  defb %00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%01111100,%00000000 ; char 191 (Â±)
4C74: 10007C00          
4C78: 60180618                  defb %01100000,%00011000,%00000110,%00011000,%01100000,%00000000,%01111110,%00000000 ; char 192 (â¥)
4C7C: 60007E00          
4C80: 06186018                  defb %00000110,%00011000,%01100000,%00011000,%00000110,%00000000,%01111110,%00000000 ; char 193 (â¤)
4C84: 06007E00          
4C88: 3E202020                  defb %00111110,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
4C8C: A0602000          
4C90: 30484830                  defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
4C94: 00000000          
4C98: 60103040                  defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
4C9C: 70000000          
4CA0: 00002A54                  defb %00000000,%00000000,%00101010,%01010100,%00000000,%01111110,%00000000,%00000000 ; char 197 
4CA4: 007E0000          
4CA8: 0054A800                  defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
4CAC: 54A80000          
4CB0: 80C0E0F0                  defb %10000000,%11000000,%11100000,%11110000,%11100000,%11000000,%10000000,%00000000 ; char 199
4CB4: E0C08000          
4CB8: FE7C3810                  defb %11111110,%01111100,%00111000,%00010000,%00000000,%00000000,%00000000,%00000000 ; char 200
4CBC: 00000000          
4CC0: 0103070F                  defb %00000001,%00000011,%00000111,%00001111,%00000111,%00000011,%00000001,%00000000 ; char 201
4CC4: 07030100          
4CC8: 00000000                  defb %00000000,%00000000,%00000000,%00000000,%00010000,%00111000,%01111100,%11111110 ; char 202
4CCC: 10387CFE          
4CD0: 10387C10                  defb %00010000,%00111000,%01111100,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 203 (up arrow)
4CD4: 10101000          
4CD8: 1E0E0E12                  defb %00011110,%00001110,%00001110,%00010010,%00100000,%01000000,%00000000,%00000000 ; char 204 (up right arrow)
4CDC: 20400000          
4CE0: 00080CFE                  defb %00000000,%00001000,%00001100,%11111110,%00001100,%00001000,%00000000,%00000000 ; char 205 (right arrow)
4CE4: 0C080000          
4CE8: 00402012                  defb %00000000,%01000000,%00100000,%00010010,%00001110,%00001110,%00011110,%00000000 ; char 206 (down right arrow)
4CEC: 0E0E1E00          
4CF0: 10101010                  defb %00010000,%00010000,%00010000,%00010000,%01111100,%00111000,%00010000,%00000000 ; char 207 (down arrow)
4CF4: 7C381000          
4CF8: 00040890                  defb %00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000,%00000000 ; char 208 (down left arrow)
4CFC: E0E0F000          
4D00: 002060FE                  defb %00000000,%00100000,%01100000,%11111110,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
4D04: 60200000          
4D08: F0E0E090                  defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
4D0C: 08040000          
4D10: 3844F040                  defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
4D14: F0443800          
4D18: 00027CA8                  defb %00000000,%00000010,%01111100,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
4D1C: 28282800          
4D20: 00000007                  defb %00000000,%00000000,%00000000,%00000111,%00001000,%00010000,%00010000,%00010000 ; char 213
4D24: 08101010          
4D28: 000000C0                  defb %00000000,%00000000,%00000000,%11000000,%00100000,%00010000,%00010000,%00010000 ; char 214
4D2C: 20101010          
4D30: 101020C0                  defb %00010000,%00010000,%00100000,%11000000,%00000000,%00000000,%00000000,%00000000 ; char 215
4D34: 00000000          
4D38: 10100807                  defb %00010000,%00010000,%00001000,%00000111,%00000000,%00000000,%00000000,%00000000 ; char 216
4D3C: 00000000          
4D40: 00000007                  defb %00000000,%00000000,%00000000,%00000111,%00001111,%00011100,%00011000,%00011000 ; char 217
4D44: 0F1C1818          
4D48: 000000E0                  defb %00000000,%00000000,%00000000,%11100000,%11110000,%00111000,%00011000,%00011000 ; char 218
4D4C: F0381818          
4D50: 181838F0                  defb %00011000,%00011000,%00111000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
4D54: E0000000          
4D58: 18181C0F                  defb %00011000,%00011000,%00011100,%00001111,%00000111,%00000000,%00000000,%00000000 ; char 220
4D5C: 07000000          
4D60: 003C4242                  defb %00000000,%00111100,%01000010,%01000010,%01000010,%01000010,%00111100,%00000000 ; char 221
4D64: 42423C00          
4D68: 003C7E7E                  defb %00000000,%00111100,%01111110,%01111110,%01111110,%01111110,%00111100,%00000000 ; char 222
4D6C: 7E7E3C00          
4D70: 00183C7E                  defb %00000000,%00011000,%00111100,%01111110,%01111110,%00111100,%00011000,%00000000 ; char 223
4D74: 7E3C1800          
4D78: FFFEFCF8                  defb %11111111,%11111110,%11111100,%11111000,%11110000,%11100000,%11000000,%10000000 ; char 224
4D7C: F0E0C080          
4D80: FF7F3F1F                  defb %11111111,%01111111,%00111111,%00011111,%00001111,%00000111,%00000011,%00000001 ; char 225
4D84: 0F070301          
4D88: 0103070F                  defb %00000001,%00000011,%00000111,%00001111,%00011111,%00111111,%01111111,%11111111 ; char 226
4D8C: 1F3F7FFF          
4D90: 80C0E0F0                  defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11111110,%11111111 ; char 227
4D94: F8FCFEFF          
4D98: 0002066C                  defb %00000000,%00000010,%00000110,%01101100,%01111000,%01110000,%01100000,%00000000 ; char 228 (checkmark)
4D9C: 78706000          
4DA0: 00663C18                  defb %00000000,%01100110,%00111100,%00011000,%00111100,%01100110,%00000000,%00000000 ; char 229 (x)
4DA4: 3C660000          
4DA8: 38444444                  defb %00111000,%01000100,%01000100,%01000100,%00111000,%00010000,%00111000,%00010000 ; char 230 (female)
4DAC: 38103810          
4DB0: 07033D44                  defb %00000111,%00000011,%00111101,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 231 (male)
4DB4: 44443800          
4DB8: 78444242                  defb %01111000,%01000100,%01000010,%01000010,%01000010,%01000010,%01000010,%01111110 ; char 232 (new doc)
4DBC: 4242427E          
4DC0: 00F8FF81                  defb %00000000,%11111000,%11111111,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 233 (folder)
4DC4: 818181FF          
4DC8: 107CFE54                  defb %00010000,%01111100,%11111110,%01010100,%01010100,%01010100,%01010100,%01111100 ; char 234 (trash bin)
4DCC: 5454547C          
4DD0: FF818181                  defb %11111111,%10000001,%10000001,%10000001,%10111101,%10101101,%10101101,%11111111 ; char 235 (floppy disk)
4DD4: BDADADFF          
4DD8: 00EAAAAC                  defb %00000000,%11101010,%10101010,%10101100,%10101100,%10101010,%11101010,%00000000 ; char 236 (OK)
4DDC: ACAAEA00          
4DE0: 187EFF7E                  defb %00011000,%01111110,%11111111,%01111110,%01111110,%01100110,%01100110,%01100110 ; char 237 (home)
4DE4: 7E666666          
4DE8: 3C429191                  defb %00111100,%01000010,%10010001,%10010001,%10011101,%10000001,%01000010,%00111100 ; char 238 (clock)
4DEC: 9D81423C          
4DF0: 000205FD                  defb %00000000,%00000010,%00000101,%11111101,%10100101,%10100010,%00000000,%00000000 ; char 239 (key)
4DF4: A5A20000          
4DF8: 080C3E4C                  defb %00001000,%00001100,%00111110,%01001100,%01001000,%01000010,%01000010,%00111100 ; char 240 (undo)
4DFC: 4842423C          
4E00: 00FFC3A5                  defb %00000000,%11111111,%11000011,%10100101,%10011001,%10000001,%11111111,%00000000 ; char 241 (letter)
4E04: 9981FF00          
4E08: 3844447C                  defb %00111000,%01000100,%01000100,%01111100,%01111100,%01111100,%01111100,%00000000 ; char 242 (lock)
4E0C: 7C7C7C00          
4E10: 060909F8                  defb %00000110,%00001001,%00001001,%11111000,%11111000,%11111000,%11111000,%00000000 ; char 243 (unlock)
4E14: F8F8F800          
4E18: FFFF81AD                  defb %11111111,%11111111,%10000001,%10101101,%10100101,%10100101,%10000001,%11111111 ; char 244 (calendar)
4E1C: A5A581FF          
4E20: 011A244A                  defb %00000001,%00011010,%00100100,%01001010,%01010010,%00100100,%01011000,%10000000 ; char 245 (diameter)
4E24: 52245880          
4E28: 7E818181                  defb %01111110,%10000001,%10000001,%10000001,%10000001,%01110110,%00001100,%00000100 ; char 246 (baloon)
4E2C: 81760C04          
4E30: 0C0A0A0A                  defb %00001100,%00001010,%00001010,%00001010,%00001000,%00011000,%00111000,%00010000 ; char 247 (note)
4E34: 08183810          
4E38: 1231F5F5                  defb %00010010,%00110001,%11110101,%11110101,%11110101,%11110101,%00110001,%00010010 ; char 248 (audio on)
4E3C: F5F53112          
4E40: 1030F0F0                  defb %00010000,%00110000,%11110000,%11110000,%11110000,%11110000,%00110000,%00010000 ; char 249 (audio off)
4E44: F0F03010          
4E48: 40607078                  defb %01000000,%01100000,%01110000,%01111000,%01111100,%01111110,%01111000,%01001000 ; char 250 (pointer)
4E4C: 7C7E7848          
4E50: 3C4299A1                  defb %00111100,%01000010,%10011001,%10100001,%10100001,%10011001,%01000010,%00111100 ; char 251 (Â©)
4E54: A199423C          
4E58: 18242078                  defb %00011000,%00100100,%00100000,%01111000,%00100000,%00100010,%01011100,%00000000 ; char 252 (Â£)
4E5C: 20225C00          
4E60: 3C427824                  defb %00111100,%01000010,%01111000,%00100100,%00100100,%00011110,%01000010,%00111100 ; char 253 (Â§)
4E64: 241E423C          
4E68: 00001000                  defb %00000000,%00000000,%00010000,%00000000,%01111100,%00000000,%00010000,%00000000 ; char 254 (Ã·)
4E6C: 7C001000          
4E70: FFFFFFFF                  defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 255 (cursor)
4E74: FFFFFFFF          
                        
                        #include "../include/vdp/logo-fonts.asm"
                        ; ------------------------------------------------------------------------------
                        ; LM80C - LOGO CHARSET - R1.1
                        ; ------------------------------------------------------------------------------
                        ; The following code is intended to be used with LM80C Z80-based computer
                        ; designed by Leonardo Miliani. More info at
                        ; www DOT leonardomiliani DOT com
                        ; ------------------------------------------------------------------------------
                        ; Code Revision:
                        ; R1.0 - 20200124 - First revision: logo chars
                        ; R1.1 - 20200229 - Adopted usual hexadecimal & binary prefixes
                        ; ------------------------------------------------------------------------------
                        
4E78:                   LOGOFONT:   equ $
4E78: 00000000                      defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; 0
4E7C: 00000000          
4E80: FFFFFFFF                      defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; 1
4E84: FFFFFFFF          
4E88: FFFFFFFF                      defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; 2
4E8C: 00000000          
4E90: 0F0F0F0F                      defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; 3
4E94: 0F0F0F0F          
4E98: 00000000                      defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; 4
4E9C: FFFFFFFF          
4EA0: F0F0F0F0                      defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; 5
4EA4: F0F0F0F0          
4EA8: 00000000                      defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; 6
4EAC: 0F0F0F0F          
4EB0: 00000000                      defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; 7
4EB4: F0F0F0F0          
4EB8: F0F0F0F0                      defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; 8
4EBC: 00000000          
4EC0: 0F0F0F0F                      defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; 9
4EC4: 00000000          
4EC8: 000000FC                      defb %00000000,%00000000,%00000000,%11111100,%11111111,%00000111,%00000011,%00000000 ; 10
4ECC: FF070300          
4ED0: 0000003F                      defb %00000000,%00000000,%00000000,%00111111,%11111111,%11100000,%11000000,%00000000 ; 11
4ED4: FFE0C000          
4ED8: 18181F19                      defb %00011000,%00011000,%00011111,%00011001,%00011001,%00011111,%00011000,%00011000 ; 12
4EDC: 191F1818          
4EE0: 1818F898                      defb %00011000,%00011000,%11111000,%10011000,%10011000,%11111000,%00011000,%00011000 ; 13
4EE4: 98F81818          
4EE8: 18181C1F                      defb %00011000,%00011000,%00011100,%00011111,%00001111,%00000000,%00000000,%00000000 ; 14
4EEC: 0F000000          
4EF0: 0000000F                      defb %00000000,%00000000,%00000000,%00001111,%00011111,%00011100,%00011000,%00011000 ; 15
4EF4: 1F1C1818          
4EF8: 000000F0                      defb %00000000,%00000000,%00000000,%11110000,%11111000,%00111000,%00011000,%00011000 ; 16
4EFC: F8381818          
4F00: 181838F8                      defb %00011000,%00011000,%00111000,%11111000,%11110000,%00000000,%00000000,%00000000 ; 17
4F04: F0000000          
4F08: 000000FF                      defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; 18
4F0C: FF000000          
4F10: 0F0F0F0F                      defb %00001111,%00001111,%00001111,%00001111,%11111111,%11111111,%11111111,%11111111 ; 19
4F14: FFFFFFFF          
4F18: F0F0F0F0                      defb %11110000,%11110000,%11110000,%11110000,%11111111,%11111111,%11111111,%11111111 ; 20
4F1C: FFFFFFFF          
4F20: FFFFFFFF                      defb %11111111,%11111111,%11111111,%11111111,%11110000,%11110000,%11110000,%11110000 ; 21
4F24: F0F0F0F0          
4F28: FFFFFFFF                      defb %11111111,%11111111,%11111111,%11111111,%00001111,%00001111,%00001111,%00001111 ; 22
4F2C: 0F0F0F0F          
4F30: 00307878                      defb %00000000,%00110000,%01111000,%01111000,%00110000,%00000000,%00000000,%00000000 ; 23
4F34: 30000000          
                                    
                        
                        ; END OF ASSEMBLY SOURCE
                        #end
                        
                        ;-------------------------------------------------------------------------------


; +++ segments +++

#CODE BOOT     = $0000 =     0,  size = $4F38 = 20280

; +++ global symbols +++

ABPASS           = $2324 =  8996  BOOT    basic32k-r315.asm:2746
ABS              = $2D6D = 11629  BOOT    basic32k-r315.asm:4333
ACCSUM           = $1B4C =  6988  BOOT    basic32k-r315.asm:1606 (unused)
ACPASS           = $2323 =  8995  BOOT    basic32k-r315.asm:2745
ADD30            = $3D3A = 15674  BOOT    basic32k-r315.asm:6574
ADD301           = $3D4A = 15690  BOOT    basic32k-r315.asm:6585
ADDEXP           = $2D06 = 11526  BOOT    basic32k-r315.asm:4268
ADDIG            = $2EAC = 11948  BOOT    basic32k-r315.asm:4558
ADDNEWLINE       = $09AB =  2475  BOOT    vdp-r315.asm:911
ADDPHL           = $2AA2 = 10914  BOOT    basic32k-r315.asm:3876
ADRS1            = $81DE = 33246  BOOT    basic32k-r315.asm:3224
ADRS2            = $81E2 = 33250  BOOT    basic32k-r315.asm:3226
ALLFOL           = $25F2 =  9714  BOOT    basic32k-r315.asm:3194
ANTVLU           = $1E5F =  7775  BOOT    basic32k-r315.asm:2024
ARET             = $31FD = 12797  BOOT    basic32k-r315.asm:4998 (unused)
ARLDSV           = $222E =  8750  BOOT    basic32k-r315.asm:2585
ARREND           = $8222 = 33314  BOOT    basic32k-r315.asm:158
ARRLP            = $24BD =  9405  BOOT    basic32k-r315.asm:2985
ASC              = $25C3 =  9667  BOOT    basic32k-r315.asm:3164
ASCTFP           = $2E4F = 11855  BOOT    basic32k-r315.asm:4504
ASPCS            = $1DC0 =  7616  BOOT    basic32k-r315.asm:1946
ATHOME           = $062A =  1578  BOOT    vdp-r315.asm:393
ATN              = $31B1 = 12721  BOOT    basic32k-r315.asm:4969
ATN1             = $31CE = 12750  BOOT    basic32k-r315.asm:4981
ATNTAB           = $31D8 = 12760  BOOT    basic32k-r315.asm:4986
ATOH             = $1B87 =  7047  BOOT    basic32k-r315.asm:1639
A_RTS_OFF        = $0165 =   357  BOOT    bootloader-r315.asm:197
A_RTS_ON         = $0173 =   371  BOOT    bootloader-r315.asm:208
BACKSPACE        = $07A8 =  1960  BOOT    vdp-r315.asm:622
BADINP           = $1DE3 =  7651  BOOT    basic32k-r315.asm:1958
BAKSTK           = $153B =  5435  BOOT    basic32k-r315.asm:711
BAKTMP           = $25A3 =  9635  BOOT    basic32k-r315.asm:3142
BASTXT           = $8133 = 33075  BOOT    basic32k-r315.asm:86
BCDEFP           = $2D94 = 11668  BOOT    basic32k-r315.asm:4362
BEEPOFF          = $0554 =  1364  BOOT    vdp-r315.asm:260
BFREE            = $0FCC =  4044  BOOT    basic32k-r315.asm:289
BIN              = $3D8C = 15756  BOOT    basic32k-r315.asm:6634
BIN2             = $3D92 = 15762  BOOT    basic32k-r315.asm:6636 (unused)
BINERR           = $3DE9 = 15849  BOOT    basic32k-r315.asm:6695
BINIT            = $3DC8 = 15816  BOOT    basic32k-r315.asm:6670
BINTFP           = $3DBE = 15806  BOOT    basic32k-r315.asm:6666
BITOUT           = $3DA6 = 15782  BOOT    basic32k-r315.asm:6648
BITOUT2          = $3DAA = 15786  BOOT    basic32k-r315.asm:6650
BITS6            = $3AEB = 15083  BOOT    basic32k-r315.asm:6240
BITS7            = $3AF5 = 15093  BOOT    basic32k-r315.asm:6245
BITS8            = $3B00 = 15104  BOOT    basic32k-r315.asm:6250
BKGNDCLR         = $81DB = 33243  BOOT    basic32k-r315.asm:129
BKSP             = $0008 =     8  BOOT    basic32k-r315.asm:35
BLNSPC           = $0FC3 =  4035  BOOT    basic32k-r315.asm:288
BN               = $0028 =    40  BOOT    basic32k-r315.asm:193
BNMSG            = $13C7 =  5063  BOOT    basic32k-r315.asm:619
BNORM            = $2B02 = 11010  BOOT    basic32k-r315.asm:3935
BNPTR            = $1443 =  5187  BOOT    basic32k-r315.asm:646 (unused)
BNRMLP           = $2B05 = 11013  BOOT    basic32k-r315.asm:3938
BOOT             = $0000 =     0  BOOT    :63 (unused)
BOOT_end         = $4F38 = 20280  BOOT    :63 (unused)
BOOT_size        = $4F38 = 20280  BOOT    :63 (unused)
BPS              = $81E5 = 33253  BOOT    basic32k-r315.asm:6061
BRK              = $1AFA =  6906  BOOT    basic32k-r315.asm:1563
BRKFLG           = $80A9 = 32937  BOOT    basic32k-r315.asm:80
BRKLIN           = $81B3 = 33203  BOOT    basic32k-r315.asm:105
BRKMSG           = $1535 =  5429  BOOT    basic32k-r315.asm:709
BRKRET           = $0FBA =  4026  BOOT    basic32k-r315.asm:284
BS               = $0010 =    16  BOOT    basic32k-r315.asm:181
BSERR            = $2261 =  8801  BOOT    basic32k-r315.asm:2616
BSMSG            = $12F6 =  4854  BOOT    basic32k-r315.asm:607
BSPTR            = $142B =  5163  BOOT    basic32k-r315.asm:634 (unused)
BUFFER           = $8136 = 33078  BOOT    basic32k-r315.asm:88
BYT2ASC          = $3D31 = 15665  BOOT    basic32k-r315.asm:6569
BYTSFT           = $2C3A = 11322  BOOT    basic32k-r315.asm:4146
CFEVAL           = $21C4 =  8644  BOOT    basic32k-r315.asm:2516
CH3_TIMER        = $0237 =   567  BOOT    bootloader-r315.asm:348
CHABFREMPTY      = $01C8 =   456  BOOT    bootloader-r315.asm:262
CHAR2VID         = $06E3 =  1763  BOOT    vdp-r315.asm:517
CHARINTOBFR      = $0136 =   310  BOOT    bootloader-r315.asm:166
CHARTY           = $2172 =  8562  BOOT    basic32k-r315.asm:2472
CHASNDDTN        = $8210 = 33296  BOOT    basic32k-r315.asm:140
CHBSNDDTN        = $8212 = 33298  BOOT    basic32k-r315.asm:141
CHCKYPOS         = $07CE =  1998  BOOT    vdp-r315.asm:641
CHCKYPOS2        = $0839 =  2105  BOOT    vdp-r315.asm:701
CHCSNDDTN        = $8214 = 33300  BOOT    basic32k-r315.asm:142
CHECKALT         = $0CC3 =  3267  BOOT    psg-r315.asm:160
CHECKCTRL        = $0CD1 =  3281  BOOT    psg-r315.asm:166
CHECKKBD         = $0CDF =  3295  BOOT    psg-r315.asm:172
CHECKPA          = $3565 = 13669  BOOT    basic32k-r315.asm:5514
CHECKPY          = $3566 = 13670  BOOT    basic32k-r315.asm:5515
CHECKWARM        = $02BE =   702  BOOT    bootloader-r315.asm:418
CHEKFN           = $23BB =  9147  BOOT    basic32k-r315.asm:2838
CHKALT           = $0D57 =  3415  BOOT    psg-r315.asm:232
CHKBIN           = $3DDB = 15835  BOOT    basic32k-r315.asm:6685
CHKBKSP          = $070D =  1805  BOOT    vdp-r315.asm:537
CHKCLR0          = $3385 = 13189  BOOT    basic32k-r315.asm:5234
CHKCLR1          = $3381 = 13185  BOOT    basic32k-r315.asm:5232
CHKCR            = $0704 =  1796  BOOT    vdp-r315.asm:533
CHKCRSDWN        = $0731 =  1841  BOOT    vdp-r315.asm:553
CHKCRSLFT        = $0716 =  1814  BOOT    vdp-r315.asm:541
CHKCRSR          = $0246 =   582  BOOT    bootloader-r315.asm:358
CHKCRSRGT        = $0728 =  1832  BOOT    vdp-r315.asm:549
CHKCRSUP         = $071F =  1823  BOOT    vdp-r315.asm:545
CHKCS            = $06FB =  1787  BOOT    vdp-r315.asm:529
CHKCTRL          = $0D4E =  3406  BOOT    psg-r315.asm:228
CHKEY1           = $3CE3 = 15587  BOOT    basic32k-r315.asm:6511
CHKEY2           = $3CE8 = 15592  BOOT    basic32k-r315.asm:6512
CHKEY3           = $3CEB = 15595  BOOT    basic32k-r315.asm:6513
CHKEY4           = $3CF1 = 15601  BOOT    basic32k-r315.asm:6514
CHKEY5           = $3CF4 = 15604  BOOT    basic32k-r315.asm:6515
CHKFNK           = $0D8A =  3466  BOOT    psg-r315.asm:257
CHKG2M           = $338B = 13195  BOOT    basic32k-r315.asm:5240
CHKINK           = $2A81 = 10881  BOOT    basic32k-r315.asm:3855
CHKLF            = $073A =  1850  BOOT    vdp-r315.asm:557
CHKLN            = $0D3A =  3386  BOOT    psg-r315.asm:219
CHKLTR           = $1B59 =  7001  BOOT    basic32k-r315.asm:1615
CHKSCAR          = $32C8 = 13000  BOOT    basic32k-r315.asm:5130
CHKSNDCH         = $0C48 =  3144  BOOT    psg-r315.asm:86
CHKSTK           = $156F =  5487  BOOT    basic32k-r315.asm:748
CHKSUM           = $80A6 = 32934  BOOT    basic32k-r315.asm:78
CHKSYN           = $1894 =  6292  BOOT    basic32k-r315.asm:1218
CHKTYP           = $1F3F =  7999  BOOT    basic32k-r315.asm:2139
CHKYPOS          = $07F5 =  2037  BOOT    vdp-r315.asm:662
CHR              = $25D4 =  9684  BOOT    basic32k-r315.asm:3176
CHR4VID          = $81D9 = 33241  BOOT    basic32k-r315.asm:127
CHRPNT           = $81E6 = 33254  BOOT    basic32k-r315.asm:5257
CHRST68          = $3E78 = 15992  BOOT    6x8fonts-r16.asm:27
CHRST88          = $4678 = 18040  BOOT    8x8fonts-r18.asm:28
CIRCLE           = $3791 = 14225  BOOT    basic32k-r315.asm:5811
CKBPS            = $3A9E = 15006  BOOT    basic32k-r315.asm:6200
CKCOL            = $3472 = 13426  BOOT    basic32k-r315.asm:5372
CKINCHAR         = $0224 =   548  BOOT    bootloader-r315.asm:329
CKMAGN           = $327B = 12923  BOOT    basic32k-r315.asm:5083
CLEAR            = $1BAC =  7084  BOOT    basic32k-r315.asm:1663
CLEARVIDBUF      = $061D =  1565  BOOT    vdp-r315.asm:386
CLOTST           = $18E0 =  6368  BOOT    basic32k-r315.asm:1265
CLREG            = $16FE =  5886  BOOT    basic32k-r315.asm:991
CLREX2           = $333F = 13119  BOOT    basic32k-r315.asm:5189
CLRG1            = $332D = 13101  BOOT    basic32k-r315.asm:5181
CLRG2            = $3336 = 13110  BOOT    basic32k-r315.asm:5185
CLRG2PTNTBL      = $05BD =  1469  BOOT    vdp-r315.asm:324
CLRMC            = $3326 = 13094  BOOT    basic32k-r315.asm:5177
CLRPRM           = $3978 = 14712  BOOT    basic32k-r315.asm:6034
CLRPSGREGS       = $0BE6 =  3046  BOOT    psg-r315.asm:31
CLRPTR           = $16D9 =  5849  BOOT    basic32k-r315.asm:971
CLRTABLE         = $057D =  1405  BOOT    vdp-r315.asm:291
CLRTXT           = $3323 = 13091  BOOT    basic32k-r315.asm:5176
CLRVDBF          = $3960 = 14688  BOOT    basic32k-r315.asm:6014
CLR_RAM_REG      = $0A2C =  2604  BOOT    vdp-r315.asm:948
CLS              = $3200 = 12800  BOOT    basic32k-r315.asm:5003
CLSQT            = $3CAA = 15530  BOOT    basic32k-r315.asm:6477
CLSQT1           = $3CBA = 15546  BOOT    basic32k-r315.asm:6485
CMP16            = $3E15 = 15893  BOOT    utils-r11.asm:37
CMPFP            = $2DDD = 11741  BOOT    basic32k-r315.asm:4420
CMPLG1           = $20D8 =  8408  BOOT    basic32k-r315.asm:2378
CMPLOG           = $20D6 =  8406  BOOT    basic32k-r315.asm:2377
CMPNUM           = $2DC3 = 11715  BOOT    basic32k-r315.asm:4403
CMPRES           = $211A =  8474  BOOT    basic32k-r315.asm:2426
CMPSTR           = $2102 =  8450  BOOT    basic32k-r315.asm:2406
CMP_A            = $2A5A = 10842  BOOT    basic32k-r315.asm:3836
CN               = $0020 =    32  BOOT    basic32k-r315.asm:189
CNMSG            = $1387 =  4999  BOOT    basic32k-r315.asm:615
CNPTR            = $143B =  5179  BOOT    basic32k-r315.asm:642 (unused)
CNT1INS          = $26CC =  9932  BOOT    basic32k-r315.asm:3307
CNTCHKSND        = $0C83 =  3203  BOOT    psg-r315.asm:121
CNTCKCL          = $32F5 = 13045  BOOT    basic32k-r315.asm:5156
CNTCL1           = $3853 = 14419  BOOT    basic32k-r315.asm:5898
CNTCL2           = $3877 = 14455  BOOT    basic32k-r315.asm:5911
CNTCL3           = $389B = 14491  BOOT    basic32k-r315.asm:5924
CNTCL4           = $38C1 = 14529  BOOT    basic32k-r315.asm:5938
CNTCL5           = $38E3 = 14563  BOOT    basic32k-r315.asm:5950
CNTCL6           = $3907 = 14599  BOOT    basic32k-r315.asm:5963
CNTCL7           = $392B = 14635  BOOT    basic32k-r315.asm:5976
CNTDRW           = $3734 = 14132  BOOT    basic32k-r315.asm:5764
CNTEND           = $1D88 =  7560  BOOT    basic32k-r315.asm:1916
CNTFNK           = $0DE5 =  3557  BOOT    psg-r315.asm:307
CNTGPT2          = $33F1 = 13297  BOOT    basic32k-r315.asm:5297
CNTKBCK          = $0D84 =  3460  BOOT    psg-r315.asm:255
CNTLGC           = $2097 =  8343  BOOT    basic32k-r315.asm:2332
CNTLTK           = $3C70 = 15472  BOOT    basic32k-r315.asm:6446
CNTNULL          = $093B =  2363  BOOT    vdp-r315.asm:854
CNTNULL2         = $0965 =  2405  BOOT    vdp-r315.asm:876
CNTPLOT          = $35E3 = 13795  BOOT    basic32k-r315.asm:5583
CNTPLT1          = $3604 = 13828  BOOT    basic32k-r315.asm:5603
CNTRX2           = $3A1E = 14878  BOOT    basic32k-r315.asm:6141
CNTRXCHA         = $0120 =   288  BOOT    bootloader-r315.asm:150
CNTSER           = $39EA = 14826  BOOT    basic32k-r315.asm:6112
CNTSER2          = $3A29 = 14889  BOOT    basic32k-r315.asm:6148
CNTSER3          = $3A3B = 14907  BOOT    basic32k-r315.asm:6157
CNTTXA           = $0201 =   513  BOOT    bootloader-r315.asm:301
CNTVALY          = $395B = 14683  BOOT    basic32k-r315.asm:6007
CNTWTSP          = $19F7 =  6647  BOOT    basic32k-r315.asm:1399
CNTZIN           = $2703 =  9987  BOOT    basic32k-r315.asm:3330
CNVNUM           = $2E5B = 11867  BOOT    basic32k-r315.asm:4510
COLD             = $0F0D =  3853  BOOT    basic32k-r315.asm:199
COLDSTART        = $02B3 =   691  BOOT    bootloader-r315.asm:414
COLOR            = $32D8 = 13016  BOOT    basic32k-r315.asm:5145
COMMAN           = $80A3 = 32931  BOOT    basic32k-r315.asm:75
COMPL            = $2B62 = 11106  BOOT    basic32k-r315.asm:4009
CONCAT           = $2538 =  9528  BOOT    basic32k-r315.asm:3075
CONEXP           = $2E8B = 11915  BOOT    basic32k-r315.asm:4534
CONPOS           = $2AFF = 11007  BOOT    basic32k-r315.asm:3933
CONT             = $1B33 =  6963  BOOT    basic32k-r315.asm:1593
CONTAD           = $81B9 = 33209  BOOT    basic32k-r315.asm:108
CONTCRSLFT       = $07DF =  2015  BOOT    vdp-r315.asm:649
CONTCRSRGT       = $084C =  2124  BOOT    vdp-r315.asm:711
CONTROLKEYS      = $821A = 33306  BOOT    basic32k-r315.asm:147
CONT_POS_CURS    = $06C3 =  1731  BOOT    vdp-r315.asm:494
CONVAR           = $202A =  8234  BOOT    basic32k-r315.asm:2263
CORW             = $02A7 =   679  BOOT    bootloader-r315.asm:409
COS              = $3135 = 12597  BOOT    basic32k-r315.asm:4917
COUNTER          = $02F5 =   757  BOOT    bootloader-r315.asm:449
CPDEHL           = $188E =  6286  BOOT    basic32k-r315.asm:1211
CPKEY            = $3C07 = 15367  BOOT    basic32k-r315.asm:6391
CPKEY1           = $3C26 = 15398  BOOT    basic32k-r315.asm:6408
CPKEY2           = $3C17 = 15383  BOOT    basic32k-r315.asm:6398
CPKEY3           = $3C1E = 15390  BOOT    basic32k-r315.asm:6401
CPKYEND          = $3C2E = 15406  BOOT    basic32k-r315.asm:6413
CPYLIT           = $17D3 =  6099  BOOT    basic32k-r315.asm:1110
CR               = $000D =    13  BOOT    basic32k-r315.asm:38
CRARLP           = $2281 =  8833  BOOT    basic32k-r315.asm:2636
CREARY           = $2266 =  8806  BOOT    basic32k-r315.asm:2619
CRESTR           = $1CB3 =  7347  BOOT    basic32k-r315.asm:1806
CRGRETURN        = $090D =  2317  BOOT    vdp-r315.asm:830
CRNCLP           = $1734 =  5940  BOOT    basic32k-r315.asm:1018
CRSDN            = $001F =    31  BOOT    basic32k-r315.asm:52
CRSLFT           = $001C =    28  BOOT    basic32k-r315.asm:49
CRSRGT           = $001D =    29  BOOT    basic32k-r315.asm:50
CRSR_STATE       = $81D6 = 33238  BOOT    basic32k-r315.asm:124
CRSUP            = $001E =    30  BOOT    basic32k-r315.asm:51
CRTMST           = $23F4 =  9204  BOOT    basic32k-r315.asm:2871
CRTST            = $2400 =  9216  BOOT    basic32k-r315.asm:2882
CRTSTE           = $2416 =  9238  BOOT    basic32k-r315.asm:2896
CRUNCH           = $172B =  5931  BOOT    basic32k-r315.asm:1014
CS               = $000C =    12  BOOT    basic32k-r315.asm:37
CSTART           = $0F1A =  3866  BOOT    basic32k-r315.asm:205
CTC0IV           = $81BF = 33215  BOOT    basic32k-r315.asm:110
CTC1IV           = $81C2 = 33218  BOOT    basic32k-r315.asm:111
CTC2IV           = $81C5 = 33221  BOOT    basic32k-r315.asm:112
CTC3IV           = $81C8 = 33224  BOOT    basic32k-r315.asm:113
CTCCONF          = $0334 =   820  BOOT    bootloader-r315.asm:507
CTC_CFG          = $3B71 = 15217  BOOT    basic32k-r315.asm:6306
CTC_CH0          = $0010 =    16  BOOT    bootloader-r315.asm:35
CTC_CH1          = $0011 =    17  BOOT    bootloader-r315.asm:36
CTC_CH2          = $0012 =    18  BOOT    bootloader-r315.asm:37
CTC_CH3          = $0013 =    19  BOOT    bootloader-r315.asm:38
CTLOFG           = $80A5 = 32933  BOOT    basic32k-r315.asm:77
CTPOINT          = $35A9 = 13737  BOOT    basic32k-r315.asm:5551
CTRLC            = $0003 =     3  BOOT    basic32k-r315.asm:33
CTRLG            = $0007 =     7  BOOT    basic32k-r315.asm:34
CTRLO            = $000F =    15  BOOT    basic32k-r315.asm:39
CTRLQ            = $0011 =    17  BOOT    basic32k-r315.asm:40
CTRLR            = $0012 =    18  BOOT    basic32k-r315.asm:41
CTRLS            = $0013 =    19  BOOT    basic32k-r315.asm:42
CTRLU            = $0015 =    21  BOOT    basic32k-r315.asm:43
CTSNDC           = $292D = 10541  BOOT    basic32k-r315.asm:3669
CUROPR           = $81AA = 33194  BOOT    basic32k-r315.asm:99
CURPOS           = $8190 = 33168  BOOT    basic32k-r315.asm:90
CURSORDOWN       = $0855 =  2133  BOOT    vdp-r315.asm:719
CURSORLEFT       = $07BB =  1979  BOOT    vdp-r315.asm:632
CURSORRIGHT      = $0820 =  2080  BOOT    vdp-r315.asm:688
CURSORUP         = $0807 =  2055  BOOT    vdp-r315.asm:673
CURSOR_OFF       = $088B =  2187  BOOT    vdp-r315.asm:752
CURSOR_ON        = $0875 =  2165  BOOT    vdp-r315.asm:739
CUR_POS          = $81DC = 33244  BOOT    vdp-r315.asm:827
DATA             = $1C5A =  7258  BOOT    basic32k-r315.asm:1758
DATABT           = $81E7 = 33255  BOOT    basic32k-r315.asm:6062
DATFLG           = $8193 = 33171  BOOT    basic32k-r315.asm:93
DATLIN           = $81AE = 33198  BOOT    basic32k-r315.asm:101
DATSNR           = $15AC =  5548  BOOT    basic32k-r315.asm:790
DC               = $81EE = 33262  BOOT    basic32k-r315.asm:5810
DCBCDE           = $2E14 = 11796  BOOT    basic32k-r315.asm:4463
DD               = $0012 =    18  BOOT    basic32k-r315.asm:182
DDERR            = $15BB =  5563  BOOT    basic32k-r315.asm:798
DDMSG            = $1304 =  4868  BOOT    basic32k-r315.asm:608
DDPTR            = $142D =  5165  BOOT    basic32k-r315.asm:635 (unused)
DECLN1           = $3BF9 = 15353  BOOT    basic32k-r315.asm:6383
DEC_D            = $0514 =  1300  BOOT    vdp-r315.asm:219
DEC_E            = $02F3 =   755  BOOT    bootloader-r315.asm:448
DEEK             = $321C = 12828  BOOT    basic32k-r315.asm:5020
DEF              = $2338 =  9016  BOOT    basic32k-r315.asm:2759
DEFFNKS          = $14A2 =  5282  BOOT    basic32k-r315.asm:692
DEFSER           = $3A85 = 14981  BOOT    basic32k-r315.asm:6187
DEFSIZ           = $2289 =  8841  BOOT    basic32k-r315.asm:2640
DEINT            = $1B6D =  7021  BOOT    basic32k-r315.asm:1626
DEL              = $007F =   127  BOOT    basic32k-r315.asm:47
DELCHR           = $1803 =  6147  BOOT    basic32k-r315.asm:1140
DEPINT           = $1B67 =  7015  BOOT    basic32k-r315.asm:1624
DETHL4           = $2DA3 = 11683  BOOT    basic32k-r315.asm:4374
DETHLB           = $2DA5 = 11685  BOOT    basic32k-r315.asm:4375
DIGTXT           = $2F55 = 12117  BOOT    basic32k-r315.asm:4656
DIM              = $2144 =  8516  BOOT    basic32k-r315.asm:2452
DIMRET           = $213B =  8507  BOOT    basic32k-r315.asm:2447
DINPOS           = $18C3 =  6339  BOOT    basic32k-r315.asm:1245
DINT             = $2C3F = 11327  BOOT    basic32k-r315.asm:4154
DIRMOD           = $3B85 = 15237  BOOT    basic32k-r315.asm:6316
DIR_PAU          = $3247 = 12871  BOOT    basic32k-r315.asm:5049 (unused)
DISNMI           = $27DB = 10203  BOOT    basic32k-r315.asm:3462
DIV              = $2C9C = 11420  BOOT    basic32k-r315.asm:4195
DIV1             = $806B = 32875  BOOT    basic32k-r315.asm:66
DIV10            = $2C90 = 11408  BOOT    basic32k-r315.asm:4190
DIV2             = $806F = 32879  BOOT    basic32k-r315.asm:67
DIV3             = $8073 = 32883  BOOT    basic32k-r315.asm:68
DIV4             = $8076 = 32886  BOOT    basic32k-r315.asm:69
DIVLP            = $2CC3 = 11459  BOOT    basic32k-r315.asm:4219
DIVSUP           = $806A = 32874  BOOT    basic32k-r315.asm:65
DIV_16_16        = $3E63 = 15971  BOOT    utils-r11.asm:150 (unused)
DIV_16_8         = $3E54 = 15956  BOOT    utils-r11.asm:129
DIV_16_8LP       = $3E57 = 15959  BOOT    utils-r11.asm:131
DIV_8_8          = $3E44 = 15940  BOOT    utils-r11.asm:106
DIV_8_8LOOP      = $3E48 = 15944  BOOT    utils-r11.asm:109
DLSZ             = $3815 = 14357  BOOT    basic32k-r315.asm:5871
DOAGN            = $1717 =  5911  BOOT    basic32k-r315.asm:1004
DOCOM            = $1D8D =  7565  BOOT    basic32k-r315.asm:1920
DODEL            = $17E3 =  6115  BOOT    basic32k-r315.asm:1124
DOEBIT           = $2F95 = 12181  BOOT    basic32k-r315.asm:4699
DOFN             = $2365 =  9061  BOOT    basic32k-r315.asm:2787
DOKE             = $3227 = 12839  BOOT    basic32k-r315.asm:5028
DOSPC            = $1DBB =  7611  BOOT    basic32k-r315.asm:1943
DOTAB            = $1DA6 =  7590  BOOT    basic32k-r315.asm:1932
DPOINT           = $2E87 = 11911  BOOT    basic32k-r315.asm:4532
DRAW             = $365B = 13915  BOOT    basic32k-r315.asm:5686
DRWCRL           = $3831 = 14385  BOOT    basic32k-r315.asm:5886
DTSTR            = $2404 =  9220  BOOT    basic32k-r315.asm:2885
DV16_16_LP       = $3E68 = 15976  BOOT    utils-r11.asm:152
DVBCDE           = $2C9E = 11422  BOOT    basic32k-r315.asm:4197
DX               = $81F0 = 33264  BOOT    basic32k-r315.asm:5684
DXGR             = $3764 = 14180  BOOT    basic32k-r315.asm:5781
DY               = $81F2 = 33266  BOOT    basic32k-r315.asm:5685
DZ               = $0014 =    20  BOOT    basic32k-r315.asm:183
DZERR            = $15B5 =  5557  BOOT    basic32k-r315.asm:794
DZMSG            = $1319 =  4889  BOOT    basic32k-r315.asm:609
DZPTR            = $142F =  5167  BOOT    basic32k-r315.asm:636 (unused)
E2               = $81EA = 33258  BOOT    basic32k-r315.asm:5681
ECHDEL           = $17F7 =  6135  BOOT    basic32k-r315.asm:1133
ECHO_CHAR        = $02CB =   715  BOOT    bootloader-r315.asm:425
EDIGIT           = $2ECE = 11982  BOOT    basic32k-r315.asm:4581
EMPTINS          = $266B =  9835  BOOT    basic32k-r315.asm:3265
EMPTSNDBFR       = $0BE2 =  3042  BOOT    psg-r315.asm:28
EMPTVRM          = $0A23 =  2595  BOOT    vdp-r315.asm:940
EMPTYCHABFR      = $01BA =   442  BOOT    bootloader-r315.asm:255
EMPTYG2          = $05AB =  1451  BOOT    vdp-r315.asm:316
EMPTYMC          = $05DC =  1500  BOOT    vdp-r315.asm:342
EMPTYVIDBUF      = $0582 =  1410  BOOT    vdp-r315.asm:295
EMPTY_VRAM       = $0A18 =  2584  BOOT    vdp-r315.asm:933
ENDBUF           = $17DA =  6106  BOOT    basic32k-r315.asm:1116
ENDCON           = $2E9A = 11930  BOOT    basic32k-r315.asm:4544
ENDCRL           = $382D = 14381  BOOT    basic32k-r315.asm:5882
ENDCTRLCK        = $0D25 =  3365  BOOT    psg-r315.asm:208
ENDDIM           = $22E8 =  8936  BOOT    basic32k-r315.asm:2709
ENDDRAW          = $378D = 14221  BOOT    basic32k-r315.asm:5795
ENDINK           = $2A93 = 10899  BOOT    basic32k-r315.asm:3866
ENDINK2          = $2A9C = 10908  BOOT    basic32k-r315.asm:3873 (unused)
ENDINP           = $1D74 =  7540  BOOT    basic32k-r315.asm:1907
ENDNAM           = $2166 =  8550  BOOT    basic32k-r315.asm:2468
ENDPRG           = $1B09 =  6921  BOOT    basic32k-r315.asm:1573
ENDTMR           = $22FD =  8957  BOOT    basic32k-r315.asm:2722
ENDTXT           = $81E0 = 33248  BOOT    vdp-r315.asm:829
ENDVDPSET        = $04B1 =  1201  BOOT    vdp-r315.asm:164
ENFMEM           = $1578 =  5496  BOOT    basic32k-r315.asm:754
ER               = $81E8 = 33256  BOOT    basic32k-r315.asm:5680
ER2              = $3708 = 14088  BOOT    basic32k-r315.asm:5748
ERASE            = $3CFA = 15610  BOOT    basic32k-r315.asm:6531
ERASECLRTBL      = $0530 =  1328  BOOT    vdp-r315.asm:236
ERRIN            = $15EA =  5610  BOOT    basic32k-r315.asm:822
ERRINT           = $1B2D =  6957  BOOT    basic32k-r315.asm:1589
ERRLIN           = $81B7 = 33207  BOOT    basic32k-r315.asm:107
ERRMSG           = $1524 =  5412  BOOT    basic32k-r315.asm:705
ERROR            = $15C6 =  5574  BOOT    basic32k-r315.asm:806
ERRORS           = $1281 =  4737  BOOT    basic32k-r315.asm:598 (unused)
ERRTBL           = $141B =  5147  BOOT    basic32k-r315.asm:625
ESC              = $001B =    27  BOOT    basic32k-r315.asm:45
EVAL             = $1F4C =  8012  BOOT    basic32k-r315.asm:2147
EVAL1            = $1F4F =  8015  BOOT    basic32k-r315.asm:2149
EVAL2            = $1F58 =  8024  BOOT    basic32k-r315.asm:2153
EVAL3            = $1F5B =  8027  BOOT    basic32k-r315.asm:2154
EVLPAR           = $2011 =  8209  BOOT    basic32k-r315.asm:2249
EVNOT            = $2124 =  8484  BOOT    basic32k-r315.asm:2434
EXCUTE           = $1A97 =  6807  BOOT    basic32k-r315.asm:1493
EXG2MD           = $046E =  1134  BOOT    vdp-r315.asm:130
EXITCHAR2VID     = $0776 =  1910  BOOT    vdp-r315.asm:586
EXITCURSORDOWN   = $0872 =  2162  BOOT    vdp-r315.asm:733
EXITCURSORLEFT   = $07E2 =  2018  BOOT    vdp-r315.asm:650
EXITCURSORRGHT   = $0852 =  2130  BOOT    vdp-r315.asm:713
EXITCURSORUP     = $081E =  2078  BOOT    vdp-r315.asm:683
EXITCURSOR_ON    = $0889 =  2185  BOOT    vdp-r315.asm:748
EXITGM           = $158C =  5516  BOOT    basic32k-r315.asm:770
EXITPA2          = $3561 = 13665  BOOT    basic32k-r315.asm:5510
EXITPAI          = $355D = 13661  BOOT    basic32k-r315.asm:5509
EXITSER          = $3B46 = 15174  BOOT    basic32k-r315.asm:6289 (unused)
EXMUL16          = $3E38 = 15928  BOOT    utils-r11.asm:77
EXP              = $302F = 12335  BOOT    basic32k-r315.asm:4786
EXPLP            = $2E79 = 11897  BOOT    basic32k-r315.asm:4524
EXPTAB           = $306F = 12399  BOOT    basic32k-r315.asm:4814
EXPTEN           = $2FA7 = 12199  BOOT    basic32k-r315.asm:4709
EXTIG            = $1EBB =  7867  BOOT    basic32k-r315.asm:2072
EXTXA            = $0215 =   533  BOOT    bootloader-r315.asm:312
FANDT            = $1EE4 =  7908  BOOT    basic32k-r315.asm:2090
FC               = $0008 =     8  BOOT    basic32k-r315.asm:177
FCERR            = $1B82 =  7042  BOOT    basic32k-r315.asm:1636
FCMSG            = $12BA =  4794  BOOT    basic32k-r315.asm:603
FCPTR            = $1423 =  5155  BOOT    basic32k-r315.asm:630 (unused)
FDTLP            = $1ECB =  7883  BOOT    basic32k-r315.asm:2074
FILES            = $3CF9 = 15609  BOOT    basic32k-r315.asm:6527
FINDEL           = $22C4 =  8900  BOOT    basic32k-r315.asm:2681
FINDKEY          = $0D38 =  3384  BOOT    psg-r315.asm:218
FLASHCURSOR      = $0784 =  1924  BOOT    vdp-r315.asm:599
FLGDIF           = $2D53 = 11603  BOOT    basic32k-r315.asm:4316
FLGREL           = $2D5A = 11610  BOOT    basic32k-r315.asm:4322
FNARG            = $8228 = 33320  BOOT    basic32k-r315.asm:161
FNCTAB           = $1026 =  4134  BOOT    basic32k-r315.asm:305
FNDARY           = $2234 =  8756  BOOT    basic32k-r315.asm:2589
FNDBPS           = $3AB7 = 15031  BOOT    basic32k-r315.asm:6210
FNDELP           = $22C9 =  8905  BOOT    basic32k-r315.asm:2686
FNDEND           = $16AC =  5804  BOOT    basic32k-r315.asm:934
FNDNUM           = $27BD = 10173  BOOT    basic32k-r315.asm:3444
FNDTOK           = $19B9 =  6585  BOOT    basic32k-r315.asm:1364
FNDVAR           = $21AB =  8619  BOOT    basic32k-r315.asm:2500
FNDWRD           = $175E =  5982  BOOT    basic32k-r315.asm:1038
FNKEYS           = $80B3 = 32947  BOOT    basic32k-r315.asm:85
FNKEYSORD        = $0E05 =  3589  BOOT    psg-r315.asm:326
FNOFST           = $203B =  8251  BOOT    basic32k-r315.asm:2273
FNRGNM           = $8226 = 33318  BOOT    basic32k-r315.asm:160
FNTHR            = $21B9 =  8633  BOOT    basic32k-r315.asm:2508
FNVAL            = $206C =  8300  BOOT    basic32k-r315.asm:2299
FOPRND           = $1F84 =  8068  BOOT    basic32k-r315.asm:2175
FOR              = $19FE =  6654  BOOT    basic32k-r315.asm:1404
FORFLG           = $81B0 = 33200  BOOT    basic32k-r315.asm:102
FORFND           = $1A2E =  6702  BOOT    basic32k-r315.asm:1432
FORSLP           = $1A12 =  6674  BOOT    basic32k-r315.asm:1413
FPADD            = $2AB1 = 10929  BOOT    basic32k-r315.asm:3884
FPBCDE           = $2D89 = 11657  BOOT    basic32k-r315.asm:4353
FPEXP            = $822F = 33327  BOOT    basic32k-r315.asm:163
FPINT            = $2DF0 = 11760  BOOT    basic32k-r315.asm:4440
FPMULT           = $2BEC = 11244  BOOT    basic32k-r315.asm:4095
FPREG            = $822C = 33324  BOOT    basic32k-r315.asm:162
FPROND           = $2B49 = 11081  BOOT    basic32k-r315.asm:3985
FPSINT           = $1B61 =  7009  BOOT    basic32k-r315.asm:1622
FPTHL            = $2DA0 = 11680  BOOT    basic32k-r315.asm:4373
FRE              = $2302 =  8962  BOOT    basic32k-r315.asm:2728
FRENUM           = $231E =  8990  BOOT    basic32k-r315.asm:2740
FRGNDCLR         = $81DA = 33242  BOOT    basic32k-r315.asm:128
FRMEVL           = $202D =  8237  BOOT    basic32k-r315.asm:2264
FWVER            = $00D0 =   208  BOOT    bootloader-r315.asm:133 (unused)
G1MD             = $03E8 =  1000  BOOT    vdp-r315.asm:67
G2MD             = $0429 =  1065  BOOT    vdp-r315.asm:100
GARBGE           = $2485 =  9349  BOOT    basic32k-r315.asm:2958
GARBLP           = $2488 =  9352  BOOT    basic32k-r315.asm:2959
GETCHR           = $1AB7 =  6839  BOOT    basic32k-r315.asm:1516
GETCMD           = $1619 =  5657  BOOT    basic32k-r315.asm:846
GETHEX           = $3D67 = 15719  BOOT    basic32k-r315.asm:6607
GETINP           = $31FE = 12798  BOOT    basic32k-r315.asm:5000
GETINT           = $27C0 = 10176  BOOT    basic32k-r315.asm:3445
GETLEN           = $25B8 =  9656  BOOT    basic32k-r315.asm:3156
GETLIN           = $1814 =  6164  BOOT    basic32k-r315.asm:1148
GETLN            = $1B88 =  7048  BOOT    basic32k-r315.asm:1640
GETNUM           = $1F3A =  7994  BOOT    basic32k-r315.asm:2136
GETNXT           = $1779 =  6009  BOOT    basic32k-r315.asm:1053
GETSTR           = $2582 =  9602  BOOT    basic32k-r315.asm:3122
GETVAR           = $2149 =  8521  BOOT    basic32k-r315.asm:2455
GM               = $002A =    42  BOOT    basic32k-r315.asm:194
GMERR            = $3991 = 14737  BOOT    basic32k-r315.asm:6049
GMMSG            = $13D2 =  5074  BOOT    basic32k-r315.asm:620
GMNCR            = $186B =  6251  BOOT    basic32k-r315.asm:1190
GMPRT            = $1445 =  5189  BOOT    basic32k-r315.asm:647 (unused)
GNXARY           = $24BC =  9404  BOOT    basic32k-r315.asm:2984
GOFUNC           = $2074 =  8308  BOOT    basic32k-r315.asm:2303
GOSUB            = $1C06 =  7174  BOOT    basic32k-r315.asm:1709
GOTO             = $1C17 =  7191  BOOT    basic32k-r315.asm:1721
GPCPCH1          = $3455 = 13397  BOOT    basic32k-r315.asm:5356
GPCPCHR          = $344A = 13386  BOOT    basic32k-r315.asm:5351 (unused)
GPNT             = $3406 = 13318  BOOT    basic32k-r315.asm:5306
GPNTCO1          = $3430 = 13360  BOOT    basic32k-r315.asm:5333
GPNTCOL          = $3426 = 13350  BOOT    basic32k-r315.asm:5329 (unused)
GPRINT           = $3394 = 13204  BOOT    basic32k-r315.asm:5260
GRBARY           = $24DC =  9436  BOOT    basic32k-r315.asm:3003
GRBDON           = $245D =  9309  BOOT    basic32k-r315.asm:2933
GRBLP            = $2496 =  9366  BOOT    basic32k-r315.asm:2965
GSTRCU           = $2585 =  9605  BOOT    basic32k-r315.asm:3123
GSTRDE           = $2589 =  9609  BOOT    basic32k-r315.asm:3125
GSTRHL           = $2588 =  9608  BOOT    basic32k-r315.asm:3124
GTFLNM           = $25C7 =  9671  BOOT    basic32k-r315.asm:3166 (unused)
GTFNAM           = $214E =  8526  BOOT    basic32k-r315.asm:2458
GTLNLP           = $1B8B =  7051  BOOT    basic32k-r315.asm:1641
GTSIXD           = $2F1F = 12063  BOOT    basic32k-r315.asm:4625
GTVLUS           = $1E37 =  7735  BOOT    basic32k-r315.asm:2002
GX               = $81E0 = 33248  BOOT    basic32k-r315.asm:5252
GY               = $81E2 = 33250  BOOT    basic32k-r315.asm:5253
HALF             = $2FC6 = 12230  BOOT    basic32k-r315.asm:4730
HALFPI           = $317F = 12671  BOOT    basic32k-r315.asm:4948
HELLOWRLD        = $02E5 =   741  BOOT    bootloader-r315.asm:440
HELP             = $3B91 = 15249  BOOT    basic32k-r315.asm:6327
HEX              = $3CFB = 15611  BOOT    basic32k-r315.asm:6535
HEX1             = $3D13 = 15635  BOOT    basic32k-r315.asm:6548
HEX2             = $3D15 = 15637  BOOT    basic32k-r315.asm:6550
HEX3             = $3D22 = 15650  BOOT    basic32k-r315.asm:6558
HEX4             = $3D24 = 15652  BOOT    basic32k-r315.asm:6560
HEXIT            = $3D7E = 15742  BOOT    basic32k-r315.asm:6622
HEXLP            = $3D5A = 15706  BOOT    basic32k-r315.asm:6597
HEXLP1           = $3D5F = 15711  BOOT    basic32k-r315.asm:6599
HEXTFP           = $3D4E = 15694  BOOT    basic32k-r315.asm:6592
HL2XY            = $06D2 =  1746  BOOT    vdp-r315.asm:505
HLPERR           = $3BA7 = 15271  BOOT    basic32k-r315.asm:6338
HLPLN            = $80B1 = 32945  BOOT    basic32k-r315.asm:84
HOME             = $0019 =    25  BOOT    basic32k-r315.asm:44
HP               = $0030 =    48  BOOT    basic32k-r315.asm:197
HPMSG            = $1411 =  5137  BOOT    basic32k-r315.asm:623
HPPTR            = $144B =  5195  BOOT    basic32k-r315.asm:650 (unused)
HX               = $0026 =    38  BOOT    basic32k-r315.asm:192
HXERR            = $3D87 = 15751  BOOT    basic32k-r315.asm:6630
HXMSG            = $13BC =  5052  BOOT    basic32k-r315.asm:618
HXPTR            = $1441 =  5185  BOOT    basic32k-r315.asm:645 (unused)
ID               = $0016 =    22  BOOT    basic32k-r315.asm:184
IDMSG            = $132A =  4906  BOOT    basic32k-r315.asm:610
IDPTR            = $1431 =  5169  BOOT    basic32k-r315.asm:637 (unused)
IDTEST           = $23AD =  9133  BOOT    basic32k-r315.asm:2828
IF               = $1CE9 =  7401  BOOT    basic32k-r315.asm:1839
IF0              = $1D00 =  7424  BOOT    basic32k-r315.asm:1849
IF1              = $1D09 =  7433  BOOT    basic32k-r315.asm:1852
IFGO             = $1CF7 =  7415  BOOT    basic32k-r315.asm:1846
IFJMP            = $1A9E =  6814  BOOT    basic32k-r315.asm:1496
INCHL            = $2D9E = 11678  BOOT    basic32k-r315.asm:4370
INCLEN           = $18BF =  6335  BOOT    basic32k-r315.asm:1243
INCTMR3          = $0240 =   576  BOOT    bootloader-r315.asm:354
INDFND           = $1555 =  5461  BOOT    basic32k-r315.asm:730
INEWLN           = $1674 =  5748  BOOT    basic32k-r315.asm:894
INIT             = $0F21 =  3873  BOOT    basic32k-r315.asm:209
INITAB           = $144D =  5197  BOOT    basic32k-r315.asm:654
INITBE           = $1524 =  5412  BOOT    basic32k-r315.asm:701
INITST           = $3E00 = 15872  BOOT    basic32k-r315.asm:6710
INIT_HW          = $025A =   602  BOOT    bootloader-r315.asm:375
INKEY            = $2A4F = 10831  BOOT    basic32k-r315.asm:3831
INKEY2           = $2A69 = 10857  BOOT    basic32k-r315.asm:3844
INMSG            = $152B =  5419  BOOT    basic32k-r315.asm:706
INP              = $277D = 10109  BOOT    basic32k-r315.asm:3413
INPBIN           = $1E89 =  7817  BOOT    basic32k-r315.asm:2046
INPBRK           = $1B06 =  6918  BOOT    basic32k-r315.asm:1571
INPORT           = $80A0 = 32928  BOOT    basic32k-r315.asm:73
INPSUB           = $809F = 32927  BOOT    basic32k-r315.asm:72
INPUT            = $1DF4 =  7668  BOOT    basic32k-r315.asm:1966
INRNG            = $2F28 = 12072  BOOT    basic32k-r315.asm:4630
INSTR            = $2614 =  9748  BOOT    basic32k-r315.asm:3232
INT              = $2E1B = 11803  BOOT    basic32k-r315.asm:4471
INTVAR           = $16E8 =  5864  BOOT    basic32k-r315.asm:982
INVSGN           = $2D71 = 11633  BOOT    basic32k-r315.asm:4335
ITMSEP           = $1E7A =  7802  BOOT    basic32k-r315.asm:2037
JSTZER           = $2FB1 = 12209  BOOT    basic32k-r315.asm:4715
KBDNPT           = $8216 = 33302  BOOT    basic32k-r315.asm:143
KBMAP            = $0E0D =  3597  BOOT    psg-r315.asm:329
KBMAP_ALT        = $0E8D =  3725  BOOT    psg-r315.asm:349
KBMAP_CTRL       = $0ECD =  3789  BOOT    psg-r315.asm:359
KBMAP_SFT        = $0E4D =  3661  BOOT    psg-r315.asm:339
KBTMP            = $8217 = 33303  BOOT    basic32k-r315.asm:144
KEY              = $3BAC = 15276  BOOT    basic32k-r315.asm:6343
KEYBOARD         = $0CA3 =  3235  BOOT    psg-r315.asm:144
KEYCH            = $3BC9 = 15305  BOOT    basic32k-r315.asm:6359
KILFOR           = $1F2A =  7978  BOOT    basic32k-r315.asm:2127
KILIN            = $180E =  6158  BOOT    basic32k-r315.asm:1145
LASTKEYPRSD      = $8219 = 33305  BOOT    basic32k-r315.asm:146
LCRFLG           = $8191 = 33169  BOOT    basic32k-r315.asm:91
LDCLRTBEX2       = $04A8 =  1192  BOOT    vdp-r315.asm:157
LDCLRTBMD1       = $0420 =  1056  BOOT    vdp-r315.asm:93
LDCOLSTOEMPTY    = $059C =  1436  BOOT    vdp-r315.asm:306
LDFNKEYCHR       = $0DD1 =  3537  BOOT    psg-r315.asm:297
LDG1             = $1599 =  5529  BOOT    basic32k-r315.asm:776
LDG1ND           = $15AA =  5546  BOOT    basic32k-r315.asm:786
LDKEY            = $3C5B = 15451  BOOT    basic32k-r315.asm:6437
LDREGVLS         = $0A49 =  2633  BOOT    vdp-r315.asm:967
LEDLIGHT         = $02EF =   751  BOOT    bootloader-r315.asm:446
LEFT             = $25E4 =  9700  BOOT    basic32k-r315.asm:3184
LEN              = $25B4 =  9652  BOOT    basic32k-r315.asm:3154
LET              = $1C71 =  7281  BOOT    basic32k-r315.asm:1774
LETNUM           = $1CC4 =  7364  BOOT    basic32k-r315.asm:1816
LETSTR           = $1C8C =  7308  BOOT    basic32k-r315.asm:1787
LF               = $000A =    10  BOOT    basic32k-r315.asm:36
LFRGNM           = $2773 = 10099  BOOT    basic32k-r315.asm:3404
LINEAT           = $80AF = 32943  BOOT    basic32k-r315.asm:83
LINEIN           = $2EDA = 11994  BOOT    basic32k-r315.asm:4591
LINFND           = $165D =  5725  BOOT    basic32k-r315.asm:880
LIST             = $18F3 =  6387  BOOT    basic32k-r315.asm:1277
LISTLP           = $1976 =  6518  BOOT    basic32k-r315.asm:1326
LM80CLOGO        = $0A9C =  2716  BOOT    vdp-r315.asm:1052
LNS1             = $81DC = 33244  BOOT    basic32k-r315.asm:3223
LNS2             = $81E0 = 33248  BOOT    basic32k-r315.asm:3225
LOAD             = $3CF7 = 15607  BOOT    basic32k-r315.asm:6519
LOADCHARSET      = $0A53 =  2643  BOOT    vdp-r315.asm:976
LOADCLR          = $3346 = 13126  BOOT    basic32k-r315.asm:5192
LOADFP           = $2D97 = 11671  BOOT    basic32k-r315.asm:4363
LOADLOGOCHRS     = $055C =  1372  BOOT    vdp-r315.asm:266
LOADMAP          = $0D5E =  3422  BOOT    psg-r315.asm:235
LOADNEXTCOL      = $08BD =  2237  BOOT    vdp-r315.asm:779
LOAD_CRSR_POS    = $06AE =  1710  BOOT    vdp-r315.asm:483
LOCATE           = $2893 = 10387  BOOT    basic32k-r315.asm:3579
LOG              = $2BAB = 11179  BOOT    basic32k-r315.asm:4063
LOGOFONT         = $4E78 = 20088  BOOT    logo-fonts.asm:13
LOGTAB           = $2B9E = 11166  BOOT    basic32k-r315.asm:4058
LOKFOR           = $153F =  5439  BOOT    basic32k-r315.asm:713
LOOPST           = $81AC = 33196  BOOT    basic32k-r315.asm:100
LS               = $001C =    28  BOOT    basic32k-r315.asm:187
LSMSG            = $135C =  4956  BOOT    basic32k-r315.asm:613
LSPTR            = $1437 =  5175  BOOT    basic32k-r315.asm:640 (unused)
LST01            = $191F =  6431  BOOT    basic32k-r315.asm:1294
LST01H           = $1922 =  6434  BOOT    basic32k-r315.asm:1295
LST03            = $195C =  6492  BOOT    basic32k-r315.asm:1315
LST04            = $1939 =  6457  BOOT    basic32k-r315.asm:1303 (unused)
LST05            = $196A =  6506  BOOT    basic32k-r315.asm:1322
LST06            = $1940 =  6464  BOOT    basic32k-r315.asm:1305
LST07            = $199B =  6555  BOOT    basic32k-r315.asm:1346
LST08            = $1998 =  6552  BOOT    basic32k-r315.asm:1345
LSTALL           = $1944 =  6468  BOOT    basic32k-r315.asm:1307
LSTBIN           = $81B1 = 33201  BOOT    basic32k-r315.asm:103
LSTCSRSTA        = $81D7 = 33239  BOOT    basic32k-r315.asm:125
LSTKEYS          = $3C30 = 15408  BOOT    basic32k-r315.asm:6416
LSTLP2           = $19A7 =  6567  BOOT    basic32k-r315.asm:1355
LSTLP3           = $19AA =  6570  BOOT    basic32k-r315.asm:1356
LSTRAM           = $8194 = 33172  BOOT    basic32k-r315.asm:94
LSTRND           = $809B = 32923  BOOT    basic32k-r315.asm:71
LTSTND           = $1E94 =  7828  BOOT    basic32k-r315.asm:2051
LVINSTR          = $26F9 =  9977  BOOT    basic32k-r315.asm:3325
LVKBRDCHK        = $0DB8 =  3512  BOOT    psg-r315.asm:278
LVKBRDCHK2       = $0DB4 =  3508  BOOT    psg-r315.asm:276
LVRXCHA          = $0131 =   305  BOOT    bootloader-r315.asm:158
LWIDTH           = $80A2 = 32930  BOOT    basic32k-r315.asm:74
MAKINT           = $27C3 = 10179  BOOT    basic32k-r315.asm:3446
MAKNUM           = $2F44 = 12100  BOOT    basic32k-r315.asm:4645
MANLP            = $2E63 = 11875  BOOT    basic32k-r315.asm:4516
MATCH            = $17AB =  6059  BOOT    basic32k-r315.asm:1085
MCMD             = $044B =  1099  BOOT    vdp-r315.asm:115
MEMMSG           = $101B =  4123  BOOT    basic32k-r315.asm:294
MID              = $2714 = 10004  BOOT    basic32k-r315.asm:3342
MID1             = $25EA =  9706  BOOT    basic32k-r315.asm:3188
MIDNUM           = $2778 = 10104  BOOT    basic32k-r315.asm:3407
MINCDE           = $2AF1 = 10993  BOOT    basic32k-r315.asm:3919
MINUS            = $2019 =  8217  BOOT    basic32k-r315.asm:2254
MIXCLRS          = $3374 = 13172  BOOT    basic32k-r315.asm:5220
MIXCOL           = $81DC = 33244  BOOT    basic32k-r315.asm:5255
MKTMST           = $23F1 =  9201  BOOT    basic32k-r315.asm:2870
MLDBLP           = $2E3C = 11836  BOOT    basic32k-r315.asm:4492
MLDEBC           = $2E34 = 11828  BOOT    basic32k-r315.asm:4487
MLOOP            = $0F52 =  3922  BOOT    basic32k-r315.asm:228
MLP              = $3E28 = 15912  BOOT    utils-r11.asm:66
MLP1             = $3E2F = 15919  BOOT    utils-r11.asm:70
MLSP10           = $2D31 = 11569  BOOT    basic32k-r315.asm:4296
MNGSNDS          = $0C3E =  3134  BOOT    psg-r315.asm:82
MNOASK           = $0F4F =  3919  BOOT    basic32k-r315.asm:227
MNPAINT          = $34E2 = 13538  BOOT    basic32k-r315.asm:5441
MO               = $0024 =    36  BOOT    basic32k-r315.asm:191
MOD              = $2C47 = 11335  BOOT    basic32k-r315.asm:4164
MOMSG            = $13AC =  5036  BOOT    basic32k-r315.asm:617
MONOUT           = $3DEE = 15854  BOOT    basic32k-r315.asm:6699
MOPTR            = $143F =  5183  BOOT    basic32k-r315.asm:644 (unused)
MORDT            = $1EA0 =  7840  BOOT    basic32k-r315.asm:2056
MORINP           = $181D =  6173  BOOT    basic32k-r315.asm:1153
MOVBUF           = $1693 =  5779  BOOT    basic32k-r315.asm:915
MOVCRS           = $067A =  1658  BOOT    vdp-r315.asm:456
MOVDIR           = $17B3 =  6067  BOOT    basic32k-r315.asm:1093
MOVLP            = $1564 =  5476  BOOT    basic32k-r315.asm:740
MOVSHOWCRS       = $0680 =  1664  BOOT    vdp-r315.asm:458
MOVSTR           = $1561 =  5473  BOOT    basic32k-r315.asm:737
MOVUP            = $155E =  5470  BOOT    basic32k-r315.asm:736
MRPRNT           = $1D17 =  7447  BOOT    basic32k-r315.asm:1861
MSGTXT1          = $0340 =   832  BOOT    bootloader-r315.asm:512
MSGTXT2          = $037C =   892  BOOT    bootloader-r315.asm:514
MSIZE            = $0F3C =  3900  BOOT    basic32k-r315.asm:220
MUL16            = $3E20 = 15904  BOOT    utils-r11.asm:58
MUL8LP           = $2C17 = 11287  BOOT    basic32k-r315.asm:4118
MULLN2           = $2BE3 = 11235  BOOT    basic32k-r315.asm:4089
MULT             = $2BEA = 11242  BOOT    basic32k-r315.asm:4093
MULT8            = $2C0E = 11278  BOOT    basic32k-r315.asm:4112
MULTEN           = $2EA5 = 11941  BOOT    basic32k-r315.asm:4552
MULVAL           = $823E = 33342  BOOT    basic32k-r315.asm:166
MVCRS2LFT        = $07E4 =  2020  BOOT    vdp-r315.asm:654
MVSTPT           = $1CBB =  7355  BOOT    basic32k-r315.asm:1810
NEDMOR           = $1E33 =  7731  BOOT    basic32k-r315.asm:2000
NEGAFT           = $2FDC = 12252  BOOT    basic32k-r315.asm:4739
NEW              = $16D8 =  5848  BOOT    basic32k-r315.asm:970
NEWCRSRCOORD     = $0690 =  1680  BOOT    vdp-r315.asm:467
NEXITM           = $1DCA =  7626  BOOT    basic32k-r315.asm:1952
NEXT             = $1EEF =  7919  BOOT    basic32k-r315.asm:2095
NEXT1            = $1EF2 =  7922  BOOT    basic32k-r315.asm:2096
NF               = $0000 =     0  BOOT    basic32k-r315.asm:173
NFERR            = $15B8 =  5560  BOOT    basic32k-r315.asm:796
NFMSG            = $1281 =  4737  BOOT    basic32k-r315.asm:599
NFPTR            = $141B =  5147  BOOT    basic32k-r315.asm:626 (unused)
NLLCR            = $0000 =     0  BOOT    basic32k-r315.asm:32
NM1              = $27EC = 10220  BOOT    basic32k-r315.asm:3470
NMI              = $27D1 = 10193  BOOT    basic32k-r315.asm:3457
NMI2             = $27FD = 10237  BOOT    basic32k-r315.asm:3478
NMIDINT          = $2808 = 10248  BOOT    basic32k-r315.asm:3487
NMIEINT          = $2801 = 10241  BOOT    basic32k-r315.asm:3483
NMIFLG           = $80A8 = 32936  BOOT    basic32k-r315.asm:79
NMIINT           = $280B = 10251  BOOT    basic32k-r315.asm:3488
NMIUSR           = $8061 = 32865  BOOT    basic32k-r315.asm:61
NMIVR1           = $2817 = 10263  BOOT    basic32k-r315.asm:3499
NOBEEP           = $0C10 =  3088  BOOT    psg-r315.asm:51
NOBPDAT          = $0C2C =  3116  BOOT    psg-r315.asm:65
NOCHNG           = $17A3 =  6051  BOOT    basic32k-r315.asm:1080
NOENED           = $2FB4 = 12212  BOOT    basic32k-r315.asm:4718
NOGD             = $3624 = 13860  BOOT    basic32k-r315.asm:5625
NOISUP           = $29B2 = 10674  BOOT    basic32k-r315.asm:3737
NOKEYPRSD        = $0D29 =  3369  BOOT    psg-r315.asm:210
NOLIN            = $1B1C =  6940  BOOT    basic32k-r315.asm:1582
NOMADD           = $2C28 = 11304  BOOT    basic32k-r315.asm:4129
NOMLAD           = $2E4A = 11850  BOOT    basic32k-r315.asm:4500
NOPMPT           = $1E0E =  7694  BOOT    basic32k-r315.asm:1978
NORMAL           = $2B1C = 11036  BOOT    basic32k-r315.asm:3954
NOS1             = $29DC = 10716  BOOT    basic32k-r315.asm:3755
NOS2             = $29EF = 10735  BOOT    basic32k-r315.asm:3768
NOS3             = $2A08 = 10760  BOOT    basic32k-r315.asm:3787
NOSPC            = $179A =  6042  BOOT    basic32k-r315.asm:1075
NOSUB7           = $3D7A = 15738  BOOT    basic32k-r315.asm:6618
NOSWAP           = $2ACB = 10955  BOOT    basic32k-r315.asm:3900
NOSYSPR          = $2849 = 10313  BOOT    basic32k-r315.asm:3528
NOTAMP           = $1FEE =  8174  BOOT    basic32k-r315.asm:2235
NOTFULL          = $0141 =   321  BOOT    bootloader-r315.asm:172
NOTRDWRAP        = $01E2 =   482  BOOT    bootloader-r315.asm:280
NOTSTR           = $2181 =  8577  BOOT    basic32k-r315.asm:2480
NOTWRAP          = $014D =   333  BOOT    bootloader-r315.asm:178
NOXOR            = $27A3 = 10147  BOOT    basic32k-r315.asm:3430
NSCFOR           = $2191 =  8593  BOOT    basic32k-r315.asm:2488
NULFLG           = $80A4 = 32932  BOOT    basic32k-r315.asm:76
NUMASC           = $2EED = 12013  BOOT    basic32k-r315.asm:4601
NUMCHR           = $81E8 = 33256  BOOT    basic32k-r315.asm:5258
NXTARY           = $2248 =  8776  BOOT    basic32k-r315.asm:2601
NXTBYT           = $1789 =  6025  BOOT    basic32k-r315.asm:1065
NXTCHAR          = $0A66 =  2662  BOOT    vdp-r315.asm:987
NXTCHR           = $17CA =  6090  BOOT    basic32k-r315.asm:1105
NXTDAT           = $8224 = 33316  BOOT    basic32k-r315.asm:159
NXTDTA           = $1C59 =  7257  BOOT    basic32k-r315.asm:1756
NXTITM           = $1E2B =  7723  BOOT    basic32k-r315.asm:1995
NXTLN            = $19D1 =  6609  BOOT    basic32k-r315.asm:1377
NXTLOOP          = $34C3 = 13507  BOOT    basic32k-r315.asm:5423
NXTOPR           = $81B5 = 33205  BOOT    basic32k-r315.asm:106
NXTSTL           = $1C60 =  7264  BOOT    basic32k-r315.asm:1761
NXTSTT           = $1C63 =  7267  BOOT    basic32k-r315.asm:1764
OD               = $0006 =     6  BOOT    basic32k-r315.asm:176
ODMSG            = $12AE =  4782  BOOT    basic32k-r315.asm:602
ODPTR            = $1421 =  5153  BOOT    basic32k-r315.asm:629 (unused)
OKMSG            = $1530 =  5424  BOOT    basic32k-r315.asm:708
OM               = $000C =    12  BOOT    basic32k-r315.asm:179
OMERR            = $1587 =  5511  BOOT    basic32k-r315.asm:765
OMMSG            = $12D9 =  4825  BOOT    basic32k-r315.asm:605
OMPTR            = $1427 =  5159  BOOT    basic32k-r315.asm:632 (unused)
ON               = $1CCB =  7371  BOOT    basic32k-r315.asm:1822
ONGO             = $1CDA =  7386  BOOT    basic32k-r315.asm:1830
ONGOLP           = $1CDB =  7387  BOOT    basic32k-r315.asm:1831
ONJMP            = $1A9F =  6815  BOOT    basic32k-r315.asm:1498
OPNPAR           = $1F48 =  8008  BOOT    basic32k-r315.asm:2145
OPNQT            = $3CBC = 15548  BOOT    basic32k-r315.asm:6488
OPNQT1           = $3CD2 = 15570  BOOT    basic32k-r315.asm:6498
OPRND            = $1FC3 =  8131  BOOT    basic32k-r315.asm:2218
ORGSP            = $81E8 = 33256  BOOT    basic32k-r315.asm:5394
OS               = $001A =    26  BOOT    basic32k-r315.asm:186
OSMSG            = $1348 =  4936  BOOT    basic32k-r315.asm:612
OSPTR            = $1435 =  5173  BOOT    basic32k-r315.asm:639 (unused)
OTKLN            = $180B =  6155  BOOT    basic32k-r315.asm:1144
OTPORT           = $8068 = 32872  BOOT    basic32k-r315.asm:64
OUTC             = $189F =  6303  BOOT    basic32k-r315.asm:1226
OUTEXP           = $2FA5 = 12197  BOOT    basic32k-r315.asm:4708
OUTIT            = $1885 =  6277  BOOT    basic32k-r315.asm:1204
OUTNBS           = $1888 =  6280  BOOT    basic32k-r315.asm:1206
OUTNCR           = $3E0F = 15887  BOOT    basic32k-r315.asm:6722
OUTSUB           = $8067 = 32871  BOOT    basic32k-r315.asm:63
OUTWRD           = $19C3 =  6595  BOOT    basic32k-r315.asm:1370
OV               = $000A =    10  BOOT    basic32k-r315.asm:178
OVERR            = $15C1 =  5569  BOOT    basic32k-r315.asm:802
OVMSG            = $12D0 =  4816  BOOT    basic32k-r315.asm:604
OVPTR            = $1425 =  5157  BOOT    basic32k-r315.asm:631 (unused)
OVTST1           = $2D24 = 11556  BOOT    basic32k-r315.asm:4288
OVTST2           = $2D29 = 11561  BOOT    basic32k-r315.asm:4291
OVTST3           = $2D2A = 11562  BOOT    basic32k-r315.asm:4292
PADD             = $2EC9 = 11977  BOOT    basic32k-r315.asm:4577
PAINT            = $3485 = 13445  BOOT    basic32k-r315.asm:5395
PAINT0           = $34D0 = 13520  BOOT    basic32k-r315.asm:5430
PAINT1           = $34DF = 13535  BOOT    basic32k-r315.asm:5438
PAINT11          = $34DE = 13534  BOOT    basic32k-r315.asm:5437
PAINT2           = $3512 = 13586  BOOT    basic32k-r315.asm:5466
PAINT3           = $3525 = 13605  BOOT    basic32k-r315.asm:5477
PAINT4           = $3544 = 13636  BOOT    basic32k-r315.asm:5495
PAINT5           = $3556 = 13654  BOOT    basic32k-r315.asm:5506
PAND             = $208D =  8333  BOOT    basic32k-r315.asm:2325
PAND1            = $20B2 =  8370  BOOT    basic32k-r315.asm:2348 (unused)
PARBT            = $81E8 = 33256  BOOT    basic32k-r315.asm:6063
PASSA            = $2333 =  9011  BOOT    basic32k-r315.asm:2755
PAUSE            = $323E = 12862  BOOT    basic32k-r315.asm:5044
PBUFF            = $8231 = 33329  BOOT    basic32k-r315.asm:165
PEEK             = $2859 = 10329  BOOT    basic32k-r315.asm:3540
PEND             = $1B01 =  6913  BOOT    basic32k-r315.asm:1568
PHLTFP           = $2D86 = 11654  BOOT    basic32k-r315.asm:4352
PIO_CA           = $0002 =     2  BOOT    bootloader-r315.asm:31 (unused)
PIO_CB           = $0003 =     3  BOOT    bootloader-r315.asm:32
PIO_DA           = $0000 =     0  BOOT    bootloader-r315.asm:29 (unused)
PIO_DB           = $0001 =     1  BOOT    bootloader-r315.asm:30
PKEPRMS          = $286D = 10349  BOOT    basic32k-r315.asm:3555
PLOT             = $35C8 = 13768  BOOT    basic32k-r315.asm:5573
PLTCRL           = $3824 = 14372  BOOT    basic32k-r315.asm:5879
PLUCDE           = $2B56 = 11094  BOOT    basic32k-r315.asm:3996
PNORM            = $2B24 = 11044  BOOT    basic32k-r315.asm:3962
PNT              = $81E4 = 33252  BOOT    basic32k-r315.asm:5391
PNT2VD           = $0DB1 =  3505  BOOT    psg-r315.asm:275
PNTEND           = $359F = 13727  BOOT    basic32k-r315.asm:5546
PNTRTN           = $35BD = 13757  BOOT    basic32k-r315.asm:5562
POINT            = $3575 = 13685  BOOT    basic32k-r315.asm:5527
POKE             = $2883 = 10371  BOOT    basic32k-r315.asm:3565
POPAF            = $2477 =  9335  BOOT    basic32k-r315.asm:2948
POPHL            = $25A1 =  9633  BOOT    basic32k-r315.asm:3139
POPHRT           = $2C38 = 11320  BOOT    basic32k-r315.asm:4143
POPNOK           = $160B =  5643  BOOT    basic32k-r315.asm:838
POR              = $2090 =  8336  BOOT    basic32k-r315.asm:2327
POR1             = $20B7 =  8375  BOOT    basic32k-r315.asm:2353
POS              = $2330 =  9008  BOOT    basic32k-r315.asm:2754
POSINT           = $1B64 =  7012  BOOT    basic32k-r315.asm:1623
POS_CURSOR       = $0670 =  1648  BOOT    vdp-r315.asm:450
POS_TB_CRS_32    = $09B8 =  2488  BOOT    vdp-r315.asm:923
POS_TB_CRS_40    = $09E8 =  2536  BOOT    vdp-r315.asm:927
POUT             = $2789 = 10121  BOOT    basic32k-r315.asm:3418
POWER            = $2FEA = 12266  BOOT    basic32k-r315.asm:4747
POWER1           = $2FFA = 12282  BOOT    basic32k-r315.asm:4755
POWER2           = $3017 = 12311  BOOT    basic32k-r315.asm:4773
POWERS           = $2FCA = 12234  BOOT    basic32k-r315.asm:4732
PRINT            = $1D1B =  7451  BOOT    basic32k-r315.asm:1863
PRITAB           = $1263 =  4707  BOOT    basic32k-r315.asm:566
PRNTCRLF         = $1D7E =  7550  BOOT    basic32k-r315.asm:1912
PRNTFNK          = $0DF8 =  3576  BOOT    psg-r315.asm:317
PRNTFNKEY        = $0DB9 =  3513  BOOT    psg-r315.asm:280
PRNTHL           = $2EE2 = 12002  BOOT    basic32k-r315.asm:4595
PRNTLP           = $1D1E =  7454  BOOT    basic32k-r315.asm:1864
PRNTNB           = $1D61 =  7521  BOOT    basic32k-r315.asm:1896
PRNTOK           = $160C =  5644  BOOT    basic32k-r315.asm:841
PRNTRETURN       = $0997 =  2455  BOOT    vdp-r315.asm:900
PRNTST           = $1D65 =  7525  BOOT    basic32k-r315.asm:1898
PRNTVIDEO        = $81D8 = 33240  BOOT    basic32k-r315.asm:126
PRNUMS           = $2441 =  9281  BOOT    basic32k-r315.asm:2917
PROCES           = $1836 =  6198  BOOT    basic32k-r315.asm:1164
PROGND           = $821E = 33310  BOOT    basic32k-r315.asm:156
PROGST           = $8241 = 33345  BOOT    basic32k-r315.asm:167
PROMPT           = $171B =  5915  BOOT    basic32k-r315.asm:1007
PRS              = $2442 =  9282  BOOT    basic32k-r315.asm:2918
PRS1             = $2445 =  9285  BOOT    basic32k-r315.asm:2919
PRSLP            = $244C =  9292  BOOT    basic32k-r315.asm:2922
PRTCHR           = $3C85 = 15493  BOOT    basic32k-r315.asm:6459
PRTCKEY          = $3CD4 = 15572  BOOT    basic32k-r315.asm:6501
PRTEND           = $3CE1 = 15585  BOOT    basic32k-r315.asm:6508
PRTK1            = $3CD5 = 15573  BOOT    basic32k-r315.asm:6502
PRTK2            = $3C44 = 15428  BOOT    basic32k-r315.asm:6428 (unused)
PRTK3            = $3C6D = 15469  BOOT    basic32k-r315.asm:6445
PRTK4            = $3C42 = 15426  BOOT    basic32k-r315.asm:6427
PRTNUM           = $81E4 = 33252  BOOT    basic32k-r315.asm:6060
PSG_DAT          = $0041 =    65  BOOT    bootloader-r315.asm:52
PSG_REG          = $0040 =    64  BOOT    bootloader-r315.asm:51
PSUB             = $2AAC = 10924  BOOT    basic32k-r315.asm:3881
PT               = $81E4 = 33252  BOOT    basic32k-r315.asm:3227
PT1              = $81E6 = 33254  BOOT    basic32k-r315.asm:3228
PT2              = $81E8 = 33256  BOOT    basic32k-r315.asm:3229
PTCHR1           = $3CA2 = 15522  BOOT    basic32k-r315.asm:6473
PTLN             = $1607 =  5639  BOOT    basic32k-r315.asm:835
PTRLP            = $16A0 =  5792  BOOT    basic32k-r315.asm:924
PUTBUF           = $1871 =  6257  BOOT    basic32k-r315.asm:1193
PUTCHRBUF        = $0DA4 =  3492  BOOT    psg-r315.asm:270
PUTCHRBUF1       = $0DEB =  3563  BOOT    psg-r315.asm:310
PUTCRSCHR        = $07A4 =  1956  BOOT    vdp-r315.asm:617
PUTCTL           = $1876 =  6262  BOOT    basic32k-r315.asm:1195
PUTFID           = $1A73 =  6771  BOOT    basic32k-r315.asm:1470
PXLSET           = $3628 = 13864  BOOT    basic32k-r315.asm:5629
PXOR             = $2095 =  8341  BOOT    basic32k-r315.asm:2330
PXOR1            = $20BF =  8383  BOOT    basic32k-r315.asm:2359
QTSTLP           = $2407 =  9223  BOOT    basic32k-r315.asm:2887
QTSTR            = $2401 =  9217  BOOT    basic32k-r315.asm:2883
QUARTR           = $3183 = 12675  BOOT    basic32k-r315.asm:4950
RADIUS           = $81E8 = 33256  BOOT    basic32k-r315.asm:5807
RAWPRINT         = $0229 =   553  BOOT    bootloader-r315.asm:335
READ             = $1E26 =  7718  BOOT    basic32k-r315.asm:1992
READFG           = $81B2 = 33202  BOOT    basic32k-r315.asm:104
READKBLN         = $0C8E =  3214  BOOT    psg-r315.asm:130
READ_VIDEO_LOC   = $0634 =  1588  BOOT    vdp-r315.asm:400
READ_VSTAT       = $0669 =  1641  BOOT    vdp-r315.asm:443
RECWRD           = $3221 = 12833  BOOT    basic32k-r315.asm:5023 (unused)
REDO             = $1DD1 =  7633  BOOT    basic32k-r315.asm:1956
REM              = $1C5C =  7260  BOOT    basic32k-r315.asm:1759
RESDIV           = $2CD6 = 11478  BOOT    basic32k-r315.asm:4232
RESEED           = $3121 = 12577  BOOT    basic32k-r315.asm:4906
RESET            = $3DF1 = 15857  BOOT    basic32k-r315.asm:6702
RESTMR           = $032F =   815  BOOT    bootloader-r315.asm:502
RESTNL           = $1ADC =  6876  BOOT    basic32k-r315.asm:1539
RESTOR           = $1AC7 =  6855  BOOT    basic32k-r315.asm:1528
RESZER           = $2B17 = 11031  BOOT    basic32k-r315.asm:3950
RETADR           = $21F8 =  8696  BOOT    basic32k-r315.asm:2548
RETINT           = $2D5F = 11615  BOOT    basic32k-r315.asm:4324
RETLIN           = $1C54 =  7252  BOOT    basic32k-r315.asm:1753
RETNAD           = $17AF =  6063  BOOT    basic32k-r315.asm:1089
RETNUL           = $21FB =  8699  BOOT    basic32k-r315.asm:2552
RETNUM           = $2025 =  8229  BOOT    basic32k-r315.asm:2259
RETREL           = $2D51 = 11601  BOOT    basic32k-r315.asm:4314
RETURN           = $1C35 =  7221  BOOT    basic32k-r315.asm:1737
RG               = $0004 =     4  BOOT    basic32k-r315.asm:175
RGMSG            = $1299 =  4761  BOOT    basic32k-r315.asm:601
RGPTR            = $141F =  5151  BOOT    basic32k-r315.asm:628 (unused)
RIGHT            = $270A =  9994  BOOT    basic32k-r315.asm:3335
RIGHT1           = $25E8 =  9704  BOOT    basic32k-r315.asm:3186
RINPUT           = $80AA = 32938  BOOT    basic32k-r315.asm:81
RLTLP            = $1F68 =  8040  BOOT    basic32k-r315.asm:2161
RND              = $30C0 = 12480  BOOT    basic32k-r315.asm:4853
RND1             = $30FC = 12540  BOOT    basic32k-r315.asm:4884
RND2             = $3118 = 12568  BOOT    basic32k-r315.asm:4902
RNDTAB           = $3129 = 12585  BOOT    basic32k-r315.asm:4913
RNGTST           = $2FB7 = 12215  BOOT    basic32k-r315.asm:4722
RONDB            = $2B38 = 11064  BOOT    basic32k-r315.asm:3974
RONDUP           = $2B37 = 11063  BOOT    basic32k-r315.asm:3973
ROUND            = $2A9F = 10911  BOOT    basic32k-r315.asm:3875
RP2INST          = $26A3 =  9891  BOOT    basic32k-r315.asm:3289
RPGPNT           = $341B = 13339  BOOT    basic32k-r315.asm:5320
RPT100           = $053E =  1342  BOOT    vdp-r315.asm:243
RPT101           = $04E5 =  1253  BOOT    vdp-r315.asm:191
RPT102           = $04E8 =  1256  BOOT    vdp-r315.asm:193
RPT103           = $04FE =  1278  BOOT    vdp-r315.asm:206
RPT104           = $0506 =  1286  BOOT    vdp-r315.asm:210
RPTCL1           = $37E8 = 14312  BOOT    basic32k-r315.asm:5849
RPTCRL           = $37D5 = 14293  BOOT    basic32k-r315.asm:5843
RPTCVB1          = $3968 = 14696  BOOT    basic32k-r315.asm:6019
RPTCVB2          = $3971 = 14705  BOOT    basic32k-r315.asm:6024
RPTDRW           = $3718 = 14104  BOOT    basic32k-r315.asm:5755
RPTEMPTYBUF      = $05A2 =  1442  BOOT    vdp-r315.asm:310
RPTEMPTYROW      = $0901 =  2305  BOOT    vdp-r315.asm:815
RPTFLL1          = $060A =  1546  BOOT    vdp-r315.asm:370
RPTINST          = $267C =  9852  BOOT    basic32k-r315.asm:3272
RPTKBDRD         = $0CE3 =  3299  BOOT    psg-r315.asm:174
RPTLDCL          = $3350 = 13136  BOOT    basic32k-r315.asm:5197
RPTNLLSRC        = $092B =  2347  BOOT    vdp-r315.asm:844
RPTNLLSRC2       = $0956 =  2390  BOOT    vdp-r315.asm:868
RPTPS            = $324C = 12876  BOOT    basic32k-r315.asm:5052
RPTRSSR          = $39BD = 14781  BOOT    basic32k-r315.asm:6087
RPTWLCMBP        = $0C16 =  3094  BOOT    psg-r315.asm:54
RPVOLCG          = $2908 = 10504  BOOT    basic32k-r315.asm:3642
RSCALE           = $2EC3 = 11971  BOOT    basic32k-r315.asm:4575
RST00            = $0000 =     0  BOOT    bootloader-r315.asm:74 (unused)
RST08            = $0008 =     8  BOOT    bootloader-r315.asm:80 (unused)
RST10            = $0010 =    16  BOOT    bootloader-r315.asm:95 (unused)
RST18            = $0018 =    24  BOOT    bootloader-r315.asm:101 (unused)
RSTCHRCRS        = $06A5 =  1701  BOOT    vdp-r315.asm:477
RSTPSG           = $0BED =  3053  BOOT    psg-r315.asm:34
RSTSERS          = $39B0 = 14768  BOOT    basic32k-r315.asm:6079
RSTSTR           = $272D = 10029  BOOT    basic32k-r315.asm:3355
RSTVDPRAMREG     = $0A32 =  2610  BOOT    vdp-r315.asm:951
RUN              = $1BF2 =  7154  BOOT    basic32k-r315.asm:1700
RUNCNT           = $1A77 =  6775  BOOT    basic32k-r315.asm:1474
RUNFST           = $16E4 =  5860  BOOT    basic32k-r315.asm:979
RUNLIN           = $1C16 =  7190  BOOT    basic32k-r315.asm:1720
RXA              = $01CD =   461  BOOT    bootloader-r315.asm:269
RXA_EXIT         = $01F3 =   499  BOOT    bootloader-r315.asm:287
RXEND            = $3A25 = 14885  BOOT    basic32k-r315.asm:6144
RX_CHA_AVAIL     = $0100 =   256  BOOT    bootloader-r315.asm:137
RZINSTR          = $26EE =  9966  BOOT    basic32k-r315.asm:3320
SA               = $002E =    46  BOOT    basic32k-r315.asm:196
SAMSG            = $13F8 =  5112  BOOT    basic32k-r315.asm:622
SAPTR            = $1449 =  5193  BOOT    basic32k-r315.asm:649 (unused)
SAVE             = $3CF8 = 15608  BOOT    basic32k-r315.asm:6523
SAVEXP           = $2B18 = 11032  BOOT    basic32k-r315.asm:3951
SAVSTP           = $1A6A =  6762  BOOT    basic32k-r315.asm:1463
SAVSTR           = $23DC =  9180  BOOT    basic32k-r315.asm:2854
SBSCPT           = $2206 =  8710  BOOT    basic32k-r315.asm:2558
SC               = $002C =    44  BOOT    basic32k-r315.asm:195
SCALE            = $2B76 = 11126  BOOT    basic32k-r315.asm:4028
SCALLP           = $2B78 = 11128  BOOT    basic32k-r315.asm:4029
SCALMI           = $2E8E = 11918  BOOT    basic32k-r315.asm:4537
SCALPL           = $2EA4 = 11940  BOOT    basic32k-r315.asm:4551
SCERR            = $3B80 = 15232  BOOT    basic32k-r315.asm:6312
SCERR1           = $3B7C = 15228  BOOT    basic32k-r315.asm:6309
SCMSG            = $13E3 =  5091  BOOT    basic32k-r315.asm:621
SCNEND           = $2513 =  9491  BOOT    basic32k-r315.asm:3044
SCPTLP           = $220C =  8716  BOOT    basic32k-r315.asm:2562
SCPTR            = $1447 =  5191  BOOT    basic32k-r315.asm:648 (unused)
SCREEN           = $325D = 12893  BOOT    basic32k-r315.asm:5071
SCROLLNXTRW      = $08AB =  2219  BOOT    vdp-r315.asm:771
SCROLLUP         = $0892 =  2194  BOOT    vdp-r315.asm:759
SCR_CURS_X       = $81D1 = 33233  BOOT    basic32k-r315.asm:119
SCR_CURS_Y       = $81D2 = 33234  BOOT    basic32k-r315.asm:120
SCR_CUR_NX       = $81D3 = 33235  BOOT    basic32k-r315.asm:121
SCR_CUR_NY       = $81D4 = 33236  BOOT    basic32k-r315.asm:122
SCR_MODE         = $81CD = 33229  BOOT    basic32k-r315.asm:117
SCR_NAM_TB       = $81CF = 33231  BOOT    basic32k-r315.asm:118
SCR_ORG_CHR      = $81D5 = 33237  BOOT    basic32k-r315.asm:123
SCR_SIZE_H       = $81CC = 33228  BOOT    basic32k-r315.asm:116
SCR_SIZE_W       = $81CB = 33227  BOOT    basic32k-r315.asm:115
SCVDP            = $3289 = 12937  BOOT    basic32k-r315.asm:5088
SEARCH           = $1777 =  6007  BOOT    basic32k-r315.asm:1051
SEED             = $8078 = 32888  BOOT    basic32k-r315.asm:70
SENDCHRPTRNS     = $0A6A =  2666  BOOT    vdp-r315.asm:989
SENDSND          = $0C13 =  3091  BOOT    psg-r315.asm:52
SERABITS         = $821C = 33308  BOOT    basic32k-r315.asm:151
SERBBITS         = $821D = 33309  BOOT    basic32k-r315.asm:152
SERBUF_START     = $8000 = 32768  BOOT    bootloader-r315.asm:62
SERIAL           = $3996 = 14742  BOOT    basic32k-r315.asm:6066
SERIALS_EN       = $821B = 33307  BOOT    basic32k-r315.asm:150
SERLED           = $39E6 = 14822  BOOT    basic32k-r315.asm:6108
SER_BUFSIZE      = $0058 =    88  BOOT    bootloader-r315.asm:58
SER_EMPTYSIZE    = $0005 =     5  BOOT    bootloader-r315.asm:60
SER_FULLSIZE     = $0050 =    80  BOOT    bootloader-r315.asm:59
SETBEEP          = $0548 =  1352  BOOT    vdp-r315.asm:252
SETBRCL          = $335B = 13147  BOOT    basic32k-r315.asm:5205
SETCRSRY         = $0763 =  1891  BOOT    vdp-r315.asm:578
SETCSRCOORDS     = $0764 =  1892  BOOT    vdp-r315.asm:579
SETIO            = $27AD = 10157  BOOT    basic32k-r315.asm:3437
SETLIT           = $17C1 =  6081  BOOT    basic32k-r315.asm:1101
SETNAMETABLE     = $0601 =  1537  BOOT    vdp-r315.asm:365
SETPAR           = $3B04 = 15108  BOOT    basic32k-r315.asm:6252
SETPTR           = $169B =  5787  BOOT    basic32k-r315.asm:921
SETSER           = $3A92 = 14994  BOOT    basic32k-r315.asm:6194
SETSNDREG        = $0C34 =  3124  BOOT    psg-r315.asm:69
SETTOP           = $0F76 =  3958  BOOT    basic32k-r315.asm:253
SETVDP           = $3270 = 12912  BOOT    basic32k-r315.asm:5079 (unused)
SETVDPADRS       = $0614 =  1556  BOOT    vdp-r315.asm:379
SET_GFX_MODE     = $0A37 =  2615  BOOT    vdp-r315.asm:958
SET_GFX_MODE2    = $0A3F =  2623  BOOT    vdp-r315.asm:962
SET_P1           = $3AC1 = 15041  BOOT    basic32k-r315.asm:6214
SFTPRG           = $1665 =  5733  BOOT    basic32k-r315.asm:884
SGN              = $2D57 = 11607  BOOT    basic32k-r315.asm:4321
SGNEXP           = $207D =  8317  BOOT    basic32k-r315.asm:2311
SGNRES           = $8230 = 33328  BOOT    basic32k-r315.asm:164
SHOW_LOGO        = $04BC =  1212  BOOT    vdp-r315.asm:172
SHRITE           = $2B85 = 11141  BOOT    basic32k-r315.asm:4037
SHRLP            = $2B88 = 11144  BOOT    basic32k-r315.asm:4039
SHRT1            = $2B8C = 11148  BOOT    basic32k-r315.asm:4043
SIGNON           = $0FDA =  4058  BOOT    basic32k-r315.asm:291
SIGNS            = $2DAE = 11694  BOOT    basic32k-r315.asm:4383
SIN              = $313B = 12603  BOOT    basic32k-r315.asm:4919
SIN1             = $316B = 12651  BOOT    basic32k-r315.asm:4939
SINTAB           = $3187 = 12679  BOOT    basic32k-r315.asm:4952
SIOBFR           = $81EA = 33258  BOOT    basic32k-r315.asm:6065
SIO_A_DI         = $0181 =   385  BOOT    bootloader-r315.asm:218
SIO_A_EI         = $018D =   397  BOOT    bootloader-r315.asm:227
SIO_A_SETS       = $0300 =   768  BOOT    bootloader-r315.asm:459
SIO_B_SETS       = $0306 =   774  BOOT    bootloader-r315.asm:465 (unused)
SIO_CA           = $0022 =    34  BOOT    bootloader-r315.asm:41
SIO_CB           = $0023 =    35  BOOT    bootloader-r315.asm:42
SIO_DA           = $0020 =    32  BOOT    bootloader-r315.asm:43
SIO_DB           = $0021 =    33  BOOT    bootloader-r315.asm:44 (unused)
SIXDIG           = $2F0A = 12042  BOOT    basic32k-r315.asm:4615
SMPVAR           = $24A7 =  9383  BOOT    basic32k-r315.asm:2972
SMSER1           = $309F = 12447  BOOT    basic32k-r315.asm:4831
SN               = $0002 =     2  BOOT    basic32k-r315.asm:174
SND1             = $2976 = 10614  BOOT    basic32k-r315.asm:3703
SND2VID          = $18D2 =  6354  BOOT    basic32k-r315.asm:1256
SNDCHRTOBFR      = $0978 =  2424  BOOT    vdp-r315.asm:884
SNDCLRSET        = $05F7 =  1527  BOOT    vdp-r315.asm:356
SNDKEYTOBFR      = $0D92 =  3474  BOOT    psg-r315.asm:262
SNDLOGPT         = $0573 =  1395  BOOT    vdp-r315.asm:282
SNDOVR           = $29AB = 10667  BOOT    basic32k-r315.asm:3733
SNDREGCFG        = $0BFA =  3066  BOOT    psg-r315.asm:43
SNERR            = $15B2 =  5554  BOOT    basic32k-r315.asm:792
SNMSG            = $1292 =  4754  BOOT    basic32k-r315.asm:600
SNPTR            = $141D =  5149  BOOT    basic32k-r315.asm:627 (unused)
SOUND            = $291F = 10527  BOOT    basic32k-r315.asm:3660
SPA              = $81E6 = 33254  BOOT    basic32k-r315.asm:5392 (unused)
SPB              = $81E7 = 33255  BOOT    basic32k-r315.asm:5393 (unused)
SPC              = $0020 =    32  BOOT    basic32k-r315.asm:46
SPCFST           = $2EFB = 12027  BOOT    basic32k-r315.asm:4607
SPCLP            = $1DC2 =  7618  BOOT    basic32k-r315.asm:1948
SPEC_RX_CONDITON = $019B =   411  BOOT    bootloader-r315.asm:240
SQR              = $2FE1 = 12257  BOOT    basic32k-r315.asm:4743
SRCHLIN          = $19DF =  6623  BOOT    basic32k-r315.asm:1383
SRCHLN           = $16B8 =  5816  BOOT    basic32k-r315.asm:943
SRCHLP           = $16BB =  5819  BOOT    basic32k-r315.asm:944
SREG             = $28C5 = 10437  BOOT    basic32k-r315.asm:3607
SRPT2            = $39E0 = 14816  BOOT    basic32k-r315.asm:6105
SRTINK           = $2A7D = 10877  BOOT    basic32k-r315.asm:3853
SRTTXT           = $81DE = 33246  BOOT    vdp-r315.asm:828
SSTAT            = $2A3B = 10811  BOOT    basic32k-r315.asm:3818
SSTSA            = $256F =  9583  BOOT    basic32k-r315.asm:3104
ST               = $001E =    30  BOOT    basic32k-r315.asm:188
STACK            = $813B = 33083  BOOT    basic32k-r315.asm:89
STAKFP           = $2D79 = 11641  BOOT    basic32k-r315.asm:4341
STALL            = $1AF0 =  6896  BOOT    basic32k-r315.asm:1556
STARTB           = $0F13 =  3859  BOOT    basic32k-r315.asm:202
STARTEMPTY       = $05F3 =  1523  BOOT    vdp-r315.asm:354
STKTHS           = $1FAC =  8108  BOOT    basic32k-r315.asm:2202
STLOOK           = $82A5 = 33445  BOOT    basic32k-r315.asm:168
STMSG            = $136C =  4972  BOOT    basic32k-r315.asm:614
STOP             = $1AFF =  6911  BOOT    basic32k-r315.asm:1566
STORED           = $1BCF =  7119  BOOT    basic32k-r315.asm:1680
STPBT            = $81E9 = 33257  BOOT    basic32k-r315.asm:6064
STPOOL           = $24EA =  9450  BOOT    basic32k-r315.asm:3009
STPTR            = $1439 =  5177  BOOT    basic32k-r315.asm:641 (unused)
STR              = $23CC =  9164  BOOT    basic32k-r315.asm:2847
STR1             = $23D2 =  9170  BOOT    basic32k-r315.asm:2849
STRADD           = $24ED =  9453  BOOT    basic32k-r315.asm:3011
STRBOT           = $81A8 = 33192  BOOT    basic32k-r315.asm:98
STRE2            = $3715 = 14101  BOOT    basic32k-r315.asm:5754
STRENT           = $1E7D =  7805  BOOT    basic32k-r315.asm:2039
STRPAR           = $3B23 = 15139  BOOT    basic32k-r315.asm:6268
STRSPC           = $80AD = 32941  BOOT    basic32k-r315.asm:82
STTLIN           = $1D6C =  7532  BOOT    basic32k-r315.asm:1902
SUBCDE           = $2AAE = 10926  BOOT    basic32k-r315.asm:3883
SUBPHL           = $2AA8 = 10920  BOOT    basic32k-r315.asm:3879
SUMLP            = $30A8 = 12456  BOOT    basic32k-r315.asm:4836
SUMSER           = $3090 = 12432  BOOT    basic32k-r315.asm:4824
SUPTLZ           = $2F89 = 12169  BOOT    basic32k-r315.asm:4692
SUP_BPS          = $3B5B = 15195  BOOT    basic32k-r315.asm:6304
SVNAM2           = $2165 =  8549  BOOT    basic32k-r315.asm:2467
SVSTAD           = $23FA =  9210  BOOT    basic32k-r315.asm:2875
SX               = $81EC = 33260  BOOT    basic32k-r315.asm:5682
SY               = $81EE = 33262  BOOT    basic32k-r315.asm:5683
SYS              = $282B = 10283  BOOT    basic32k-r315.asm:3516
SYSRET           = $2857 = 10327  BOOT    basic32k-r315.asm:3535
TAN              = $319C = 12700  BOOT    basic32k-r315.asm:4959
TEMPSTACK        = $818D = 33165  BOOT    bootloader-r315.asm:68
TESTALT          = $0D12 =  3346  BOOT    psg-r315.asm:199
TESTCTRL         = $0D1F =  3359  BOOT    psg-r315.asm:205
TESTOS           = $2479 =  9337  BOOT    basic32k-r315.asm:2951
TESTR            = $245B =  9307  BOOT    basic32k-r315.asm:2931
TF               = $81EC = 33260  BOOT    basic32k-r315.asm:3231
TM               = $0018 =    24  BOOT    basic32k-r315.asm:185
TMERR            = $15C4 =  5572  BOOT    basic32k-r315.asm:804
TMMSG            = $1339 =  4921  BOOT    basic32k-r315.asm:611
TMPADR           = $81E4 = 33252  BOOT    basic32k-r315.asm:5256
TMPBFR1          = $81DC = 33244  BOOT    basic32k-r315.asm:130
TMPBFR2          = $81DE = 33246  BOOT    basic32k-r315.asm:131
TMPBFR3          = $81E0 = 33248  BOOT    basic32k-r315.asm:132
TMPBFR4          = $81E2 = 33250  BOOT    basic32k-r315.asm:133
TMPCLR           = $81DE = 33246  BOOT    basic32k-r315.asm:5254
TMPHL            = $81EA = 33258  BOOT    basic32k-r315.asm:5259
TMPKEYBFR        = $8218 = 33304  BOOT    basic32k-r315.asm:145
TMPSTR           = $81A4 = 33188  BOOT    basic32k-r315.asm:97
TMPTR            = $1433 =  5171  BOOT    basic32k-r315.asm:638 (unused)
TMR              = $22EC =  8940  BOOT    basic32k-r315.asm:2715
TMRCNT           = $81BB = 33211  BOOT    basic32k-r315.asm:109
TMSTPL           = $8198 = 33176  BOOT    basic32k-r315.asm:96
TMSTPT           = $8196 = 33174  BOOT    basic32k-r315.asm:95
TOPOOL           = $25E0 =  9696  BOOT    basic32k-r315.asm:3181
TOSTRA           = $2578 =  9592  BOOT    basic32k-r315.asm:3113
TP               = $81EA = 33258  BOOT    basic32k-r315.asm:3230
TRYAGN           = $2F64 = 12132  BOOT    basic32k-r315.asm:4665
TSALP            = $2579 =  9593  BOOT    basic32k-r315.asm:3114
TSTBIT           = $3E08 = 15880  BOOT    basic32k-r315.asm:6715 (unused)
TSTBRK           = $1AE2 =  6882  BOOT    basic32k-r315.asm:1545
TSTMEM           = $0F64 =  3940  BOOT    basic32k-r315.asm:241
TSTNUM           = $1F3D =  7997  BOOT    basic32k-r315.asm:2137
TSTOPL           = $2422 =  9250  BOOT    basic32k-r315.asm:2903
TSTRED           = $20C4 =  8388  BOOT    basic32k-r315.asm:2365
TSTREM           = $17C4 =  6084  BOOT    basic32k-r315.asm:1102
TSTSGN           = $2D48 = 11592  BOOT    basic32k-r315.asm:4309
TSTSPC           = $19E5 =  6629  BOOT    basic32k-r315.asm:1390
TSTSTR           = $1F3E =  7998  BOOT    basic32k-r315.asm:2138
TTYLIN           = $1814 =  6164  BOOT    basic32k-r315.asm:1149
TXA              = $01F7 =   503  BOOT    bootloader-r315.asm:295
TXA_EXIT         = $0210 =   528  BOOT    bootloader-r315.asm:309
TXTMD            = $03BE =   958  BOOT    vdp-r315.asm:46 (unused)
TX_EMP           = $0218 =   536  BOOT    bootloader-r315.asm:318
TYPE             = $8192 = 33170  BOOT    basic32k-r315.asm:92
UF               = $0022 =    34  BOOT    basic32k-r315.asm:190
UFERR            = $15BE =  5566  BOOT    basic32k-r315.asm:800
UFMSG            = $1396 =  5014  BOOT    basic32k-r315.asm:616
UFPTR            = $143D =  5181  BOOT    basic32k-r315.asm:643 (unused)
UL               = $000E =    14  BOOT    basic32k-r315.asm:180
ULERR            = $1C30 =  7216  BOOT    basic32k-r315.asm:1734
ULMSG            = $12E7 =  4839  BOOT    basic32k-r315.asm:606
ULPTR            = $1429 =  5161  BOOT    basic32k-r315.asm:633 (unused)
UNITY            = $2B9A = 11162  BOOT    basic32k-r315.asm:4056
UPDATA           = $1ADD =  6877  BOOT    basic32k-r315.asm:1540
USR              = $8064 = 32868  BOOT    basic32k-r315.asm:62
VAL              = $2744 = 10052  BOOT    basic32k-r315.asm:3374
VAL1             = $2762 = 10082  BOOT    basic32k-r315.asm:3394
VAL2             = $276C = 10092  BOOT    basic32k-r315.asm:3398
VAL3             = $276F = 10095  BOOT    basic32k-r315.asm:3399
VALIDX           = $3950 = 14672  BOOT    basic32k-r315.asm:5996
VALIDY           = $3955 = 14677  BOOT    basic32k-r315.asm:6002
VAREND           = $8220 = 33312  BOOT    basic32k-r315.asm:157
VDPMODESET       = $0A74 =  2676  BOOT    vdp-r315.asm:1003
VDPMODESET1      = $0A7C =  2684  BOOT    vdp-r315.asm:1012 (unused)
VDPMODESET2      = $0A84 =  2692  BOOT    vdp-r315.asm:1022 (unused)
VDPMODESETEX2    = $0A94 =  2708  BOOT    vdp-r315.asm:1042 (unused)
VDPMODESETMC     = $0A8C =  2700  BOOT    vdp-r315.asm:1032 (unused)
VDP_DAT          = $0030 =    48  BOOT    bootloader-r315.asm:47
VDP_SET          = $0032 =    50  BOOT    bootloader-r315.asm:48
VIDEOBUFF        = $81E4 = 33252  BOOT    basic32k-r315.asm:134
VIDTMP1          = $820C = 33292  BOOT    basic32k-r315.asm:135
VIDTMP2          = $820E = 33294  BOOT    basic32k-r315.asm:136
VOLCH            = $2914 = 10516  BOOT    basic32k-r315.asm:3649
VOLUME           = $28E6 = 10470  BOOT    basic32k-r315.asm:3627
VPEEK            = $2860 = 10336  BOOT    basic32k-r315.asm:3545
VPOKE            = $2888 = 10376  BOOT    basic32k-r315.asm:3570
VREG             = $2A14 = 10772  BOOT    basic32k-r315.asm:3796
VSTAT            = $2A30 = 10800  BOOT    basic32k-r315.asm:3811
WAIT             = $278F = 10127  BOOT    basic32k-r315.asm:3421
WAITLP           = $27A4 = 10148  BOOT    basic32k-r315.asm:3431
WARM             = $0F10 =  3856  BOOT    basic32k-r315.asm:200
WARMST           = $0FB7 =  4023  BOOT    basic32k-r315.asm:283
WIDTH            = $3214 = 12820  BOOT    basic32k-r315.asm:5014
WLCBPDAT         = $0C24 =  3108  BOOT    psg-r315.asm:64
WLCMBEEP         = $0C0A =  3082  BOOT    psg-r315.asm:49
WORDS            = $106A =  4202  BOOT    basic32k-r315.asm:344
WORDTB           = $11F7 =  4599  BOOT    basic32k-r315.asm:461
WRITEBUF         = $08E6 =  2278  BOOT    vdp-r315.asm:800
WRITE_VIDEO_LOC  = $0649 =  1609  BOOT    vdp-r315.asm:417
WRITE_VREG       = $065E =  1630  BOOT    vdp-r315.asm:434
WRKSPC           = $805E = 32862  BOOT    basic32k-r315.asm:60
WRTSND           = $29FF = 10751  BOOT    basic32k-r315.asm:3778
WRTSNDREG        = $0C39 =  3129  BOOT    psg-r315.asm:74
WTSPC            = $19EB =  6635  BOOT    basic32k-r315.asm:1393
X1               = $81DC = 33244  BOOT    basic32k-r315.asm:5676
X1GR             = $36BB = 14011  BOOT    basic32k-r315.asm:5723
X2               = $81E4 = 33252  BOOT    basic32k-r315.asm:5678
XC               = $81E4 = 33252  BOOT    basic32k-r315.asm:5805
XI               = $81EA = 33258  BOOT    basic32k-r315.asm:5808
XY2HL            = $3630 = 13872  BOOT    basic32k-r315.asm:5637
Y1               = $81DE = 33246  BOOT    basic32k-r315.asm:5677
Y1GR             = $36E5 = 14053  BOOT    basic32k-r315.asm:5737
Y2               = $81E6 = 33254  BOOT    basic32k-r315.asm:5679
YC               = $81E6 = 33254  BOOT    basic32k-r315.asm:5806
YI               = $81EC = 33260  BOOT    basic32k-r315.asm:5809
ZDATA            = $0083 =   131  BOOT    basic32k-r315.asm:529
ZDINT            = $00C2 =   194  BOOT    basic32k-r315.asm:550 (unused)
ZDIV             = $00C0 =   192  BOOT    basic32k-r315.asm:548 (unused)
ZELSE            = $00AE =   174  BOOT    basic32k-r315.asm:533
ZEND             = $0080 =   128  BOOT    basic32k-r315.asm:527
ZEQUAL           = $00C8 =   200  BOOT    basic32k-r315.asm:553
ZERARY           = $22A7 =  8871  BOOT    basic32k-r315.asm:2661
ZERBYT           = $152F =  5423  BOOT    basic32k-r315.asm:707
ZEROLP           = $21EA =  8682  BOOT    basic32k-r315.asm:2539
ZEROSUP          = $3D98 = 15768  BOOT    basic32k-r315.asm:6639
ZFN              = $00B8 =   184  BOOT    basic32k-r315.asm:539
ZFOR             = $0081 =   129  BOOT    basic32k-r315.asm:528
ZGOSUB           = $008C =   140  BOOT    basic32k-r315.asm:531
ZGOTO            = $0088 =   136  BOOT    basic32k-r315.asm:530
ZGTR             = $00C7 =   199  BOOT    basic32k-r315.asm:552
ZINSTR           = $00E1 =   225  BOOT    basic32k-r315.asm:559
ZLEFT            = $00E9 =   233  BOOT    basic32k-r315.asm:560
ZLTH             = $00C9 =   201  BOOT    basic32k-r315.asm:554
ZMINUS           = $00BE =   190  BOOT    basic32k-r315.asm:546
ZMOD             = $00C1 =   193  BOOT    basic32k-r315.asm:549 (unused)
ZNEW             = $00B5 =   181  BOOT    basic32k-r315.asm:535
ZNOT             = $00BB =   187  BOOT    basic32k-r315.asm:542
ZONELP           = $1D9B =  7579  BOOT    basic32k-r315.asm:1926
ZOR              = $00C6 =   198  BOOT    basic32k-r315.asm:551
ZPLUS            = $00BD =   189  BOOT    basic32k-r315.asm:545
ZPOINT           = $00E0 =   224  BOOT    basic32k-r315.asm:557
ZPRINT           = $00AF =   175  BOOT    basic32k-r315.asm:534
ZREM             = $008E =   142  BOOT    basic32k-r315.asm:532
ZSGN             = $00CA =   202  BOOT    basic32k-r315.asm:556
ZSPC             = $00B9 =   185  BOOT    basic32k-r315.asm:540
ZSTEP            = $00BC =   188  BOOT    basic32k-r315.asm:543
ZTAB             = $00B6 =   182  BOOT    basic32k-r315.asm:537
ZTHEN            = $00BA =   186  BOOT    basic32k-r315.asm:541
ZTIMES           = $00BF =   191  BOOT    basic32k-r315.asm:547 (unused)
ZTO              = $00B7 =   183  BOOT    basic32k-r315.asm:538
_z80_            = $0001 =     1          :1 (unused)
absHL            = $3E3A = 15930  BOOT    utils-r11.asm:90
basicStarted     = $805D = 32861  BOOT    bootloader-r315.asm:66
bufWrap          = $0058 =    88  BOOT    bootloader-r315.asm:67
initCTC          = $030A =   778  BOOT    bootloader-r315.asm:474
initPSG          = $0BDC =  3036  BOOT    psg-r315.asm:25
initVDP          = $0399 =   921  BOOT    vdp-r315.asm:26
negHL            = $3E3D = 15933  BOOT    utils-r11.asm:92
serBufUsed       = $805C = 32860  BOOT    bootloader-r315.asm:65
serInPtr         = $8058 = 32856  BOOT    bootloader-r315.asm:63
serRdPtr         = $805A = 32858  BOOT    bootloader-r315.asm:64


total time: 2.0176 sec.
no errors
