# file opened: LM80C_64K-firmware-r1.03.asm
   1  0000              ; ------------------------------------------------------------------------------
   2  0000              ; LM80C 64K - FIRMWARE - R1.02
   3  0000              ; ------------------------------------------------------------------------------
   4  0000              ; The following code is intended to be used with LM80C Z80-based computer
   5  0000              ; designed by Leonardo Miliani. More info at
   6  0000              ; www DOT leonardomiliani DOT com
   7  0000              ; ------------------------------------------------------------------------------
   8  0000              ; Coding/Editing/Compiling:
   9  0000              ; Original init code for MC68B05 by Grant Searle
  10  0000              ; Original SIO/CTC/PIO init code by Mario Blunk
  11  0000              ; NASCOM BASIC originally modified by Gran Searle
  12  0000              ; Code modified and adapted for LM80C by Leonardo Miliani
  13  0000              ;
  14  0000              ; Edited with Visual Studio Code
  15  0000              ;
  16  0000              ; Compiled with SjASMPlus assembler 1.18.0
  17  0000              ; https://github.com/z00m128/sjasmplus
  18  0000              ; ------------------------------------------------------------------------------
  19  0000              ; Copyright notes:
  20  0000              ; Parts of the code (c) Grant Searle - free for non commercial use
  21  0000              ; Please include this advice and the note to the attribution of the original
  22  0000              ; version to Grant Searle if you intend to redistribuite it
  23  0000              ; http://searle.hostei.com/grant/index.html
  24  0000              ; eMail: home.micros01@btinternet.com
  25  0000              ;
  26  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  27  0000              ; Parts of the code (c) Mario Blunk
  28  0000              ; http://www.trainÂ­z.de
  29  0000              ;
  30  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  31  0000              ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  32  0000              ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  33  0000              ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  34  0000              ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  35  0000              ; the original ROM code (checksum A934H). PA
  36  0000              ;
  37  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  38  0000              ; The following code is intended to be used with LM80C Z80-based computer
  39  0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
  40  0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
  41  0000              ; kind of warranty: you can use them at your own risk.
  42  0000              ; You are free to use them for any non-commercial use: you are only asked to
  43  0000              ; maintain the copyright notices, include this advice and the note to the
  44  0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  45  0000              ; redistribuite them.
  46  0000              ; https://www.leonardomiliani.com
  47  0000              ;
  48  0000              ; Please support me by visiting the following links:
  49  0000              ; Main project page: https://www.leonardomiliani.com
  50  0000              ; Schematics and code: https://github.com/leomil72/LM80C
  51  0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  52  0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  53  0000              ; ------------------------------------------------------------------------------
  54  0000              ; set name for binary output file
  55  0000                  OUTPUT "LM80C-64K-firmware-r1.03.bin"
  56  0000
  57  0000              ; set computer model
  58  0000                  DEFINE LM80C64K
  59  0000
  60  0000              ; set firmware version
  61  0000                  DEFINE VERSION "1.03"
  62  0000
  63  0000              ; define shorter VDP_DAT load instruction
  64  0000                  DEFINE LD_VDP_DAT dec     C
  65  0000
  66  0000              ; ------------------------------------------------------------------------------
  67  0000              ; include the latest version of the bootloader: this sets up the address aliases
  68  0000              ; configure the hardware, checks if warm or cold startup and loads the BASIC interpreter
  69  0000                  INCLUDE "../include/bootloader/bootloader-1.04.asm"
# file opened: ../include/bootloader/bootloader-1.04.asm
   1+ 0000              ; ------------------------------------------------------------------------------
   2+ 0000              ; LM80C - BOOTLOADER - 1.04
   3+ 0000              ; ------------------------------------------------------------------------------
   4+ 0000              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0000              ; kind of warranty: you can use them at your own risk.
   8+ 0000              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0000              ; maintain the copyright notices, include this advice and the note to the
  10+ 0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0000              ; redistribuite them.
  12+ 0000              ; https://www.leonardomiliani.com
  13+ 0000              ;
  14+ 0000              ; Please support me by visiting the following links:
  15+ 0000              ; Main project page: https://www.leonardomiliani.com
  16+ 0000              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0000              ; ------------------------------------------------------------------------------
  20+ 0000
  21+ 0000              ; ADDRESS DECODING (bits A6/A5/A4)
  22+ 0000              ; 0000xxxx : PIO
  23+ 0000              ; 0001xxxx : CTC
  24+ 0000              ; 0010xxxx : SIO
  25+ 0000              ; 0011xxxx : VDP
  26+ 0000              ; 0100xxxx : PSG
  27+ 0000              ; 0101xxxx : C.F.
  28+ 0000
  29+ 0000
  30+ 0000              ; ------------------------------------------------------------------------------
  31+ 0000              ;               EQUATES
  32+ 0000              ; ------------------------------------------------------------------------------
  33+ 0000              ; label defining for PIO (Parallel Input/Output)
  34+ 0000              PIO_DA          equ %00000000
  35+ 0000              PIO_DB          equ %00000001
  36+ 0000              PIO_CA          equ %00000010
  37+ 0000              PIO_CB          equ %00000011
  38+ 0000
  39+ 0000              ; label defining for CTC (Counter Timer Circuit)
  40+ 0000              CTC_CH0         equ %00010000
  41+ 0000              CTC_CH1         equ %00010001
  42+ 0000              CTC_CH2         equ %00010010
  43+ 0000              CTC_CH3         equ %00010011
  44+ 0000
  45+ 0000              ;label defining for SIO (Serial Input/Output)
  46+ 0000              SIO_CA          equ %00100010
  47+ 0000              SIO_CB          equ %00100011
  48+ 0000              SIO_DA          equ %00100000
  49+ 0000              SIO_DB          equ %00100001
  50+ 0000
  51+ 0000              ;label defining for VDP (Video Display Processor)
  52+ 0000              VDP_DAT         equ %00110000
  53+ 0000              VDP_SET         equ %00110001
  54+ 0000
  55+ 0000              ; label defining for PSG (Programmable Sound Generator)
  56+ 0000              PSG_REG         equ %01000000
  57+ 0000              PSG_DAT         equ %01000001
  58+ 0000
  59+ 0000              ; Interrupt-driven serial I/O interface lead by the Z80 SIO to run modified
  60+ 0000              ; NASCOM Basic 4.7 - Full input buffering with incoming data hardware handshaking
  61+ 0000              ; Handshake shows full before the buffer is totally filled to allow run-on from the sender
  62+ 0000              SER_BUFSIZE     equ     $58
  63+ 0000              SER_FULLSIZE    equ     $50
  64+ 0000              SER_EMPTYSIZE   equ     $05
  65+ 0000
  66+ 0000
  67+ 0000              ;------------------------------------------------------------------------------
  68+ 0000              ;                                F I R M W A R E
  69+ 0000              ;------------------------------------------------------------------------------
  70+ 0000              ; BASE MEMORY - RESET LOCATION ($0000) -> the CPU jumps to $0000 after a reset
  71+ 0000                              org     $0000
  72+ 0000 F3           RST00:          di                      ; be sure that INTs are disabled
  73+ 0001                  IFDEF LM80C64K
  74+ 0001 C3 C0 50                     jp      ROM2RAM         ; jump to ROM/RAM switcher
  75+ 0004                  ELSE
  76+ 0004 ~                            jp      INIT_HW         ; jump to system initialization
  77+ 0004                  ENDIF
  78+ 0004
  79+ 0004              ;------------------------------------------------------------------------------
  80+ 0004              ; interrupt vector when SIO ch.B has a char available in its buffer
  81+ 0004                              ;$0004
  82+ 0004 64 01                        defw    RX_CHB_AVAIL
  83+ 0006
  84+ 0006              ;------------------------------------------------------------------------------
  85+ 0006              ; interrupt vector for SIO ch.B special conditions (i.e. buf overrun)
  86+ 0006                              ;$0006
  87+ 0006 67 01                        defw    SPEC_RXB_CNDT
  88+ 0008
  89+ 0008              ;------------------------------------------------------------------------------
  90+ 0008              ; send a character over serial ch. A
  91+ 0008                              ;$0008
  92+ 0008 C3 4D 02     RST08:          jp      TXA
  93+ 000B FF                           BLOCK   1,$FF   ; filler
  94+ 000C
  95+ 000C              ;------------------------------------------------------------------------------
  96+ 000C              ; interrupt vector when SIO ch.A has a char available in its buffer
  97+ 000C                              ;$000C
  98+ 000C 00 01                        defw    RX_CHA_AVAIL
  99+ 000E
 100+ 000E              ;------------------------------------------------------------------------------
 101+ 000E              ; interrupt vector for SIO ch.A special conditions (i.e. buf overrun)
 102+ 000E                              ;$000E
 103+ 000E 35 01                        defw    SPEC_RXA_CNDT
 104+ 0010
 105+ 0010              ;------------------------------------------------------------------------------
 106+ 0010              ; receive a character over serial ch. A
 107+ 0010                              ;$0010
 108+ 0010 C3 23 02     RST10:          jp      RXA
 109+ 0013 FF FF FF...                  BLOCK   5,$FF   ; filler
 110+ 0018              ;------------------------------------------------------------------------------
 111+ 0018              ; check serial status
 112+ 0018
 113+ 0018                              ;$0018
 114+ 0018 C3 7A 02     RST18:          jp      CKINCHAR
 115+ 001B FF FF FF...                  BLOCK   $25,$FF ; filler
 116+ 0040              ;------------------------------------------------------------------------------
 117+ 0040              ; interrupt vectors for CTC
 118+ 0040                              ;$0040               ; for CH0 Timer - used in BASIC by serial 1 for bps
 119+ 0040 B0 52                        defw    CTC0IV
 120+ 0042                              ;$0042               ; for CH1 Timer - used in BASIC by serial 2 for bps
 121+ 0042 B3 52                        defw    CTC1IV
 122+ 0044                              ;$0044               ; for CH2 timer - unused
 123+ 0044 B6 52                        defw    CTC2IV
 124+ 0046                              ;$0046               ; for CH3 Timer - used by FW for 100ths/s counter
 125+ 0046 B9 52                        defw    CTC3IV
 126+ 0048 FF FF FF...                  BLOCK   $1E,$FF ; filler
 127+ 0066              ;------------------------------------------------------------------------------
 128+ 0066              ; interrupt routine for NMI
 129+ 0066                              ;$0066
 130+ 0066 C3 50 51                     jp      NMIUSR              ; jump to execute NMI service routine
 131+ 0069 FF FF FF...                  BLOCK   $27,$FF ; filler
 132+ 0090              ;------------------------------------------------------------------------------
 133+ 0090              ; store compilation date&time into FW
 134+ 0090                  LUA
 135+ 0090 ~                    sj.insert_define("TIME", '"' .. os.date("%d-%m-%Y %H:%M:%S") .. '"')
 136+ 0090              	ENDLUA
 137+ 0090                              ;$0090
 138+ 0090                  IFDEF LM80C
 139+ 0090 ~                            defb    $4C,$4D,$38,$30,$43,$20,$43,$4F
 140+ 0090 ~                            defb    $4C,$4F,$52,$00,$00,$00,$00,$00
 141+ 0090                  ELSE
 142+ 0090 4C 4D 38 30                  defb    $4C,$4D,$38,$30,$43,$20,$36,$34
 142+ 0094 43 20 36 34
 143+ 0098 4B 20 43 4F                  defb    $4B,$20,$43,$4F,$4C,$4F,$52,$00
 143+ 009C 4C 4F 52 00
 144+ 00A0                  ENDIF
 145+ 00A0 43 4F 4D 50                  defb    $43,$4F,$4D,$50,$55,$54,$45,$52
 145+ 00A4 55 54 45 52
 146+ 00A8 20 28 32 30                  defb    $20,$28,$32,$30,$32,$30,$29,$00
 146+ 00AC 32 30 29 00
 147+ 00B0 44 65 73 69                  defb    $44,$65,$73,$69,$67,$6E,$65,$64
 147+ 00B4 67 6E 65 64
 148+ 00B8 20 62 79 00                  defb    $20,$62,$79,$00,$00,$00,$00,$00
 148+ 00BC 00 00 00 00
 149+ 00C0 4C 65 6F 6E                  defb    $4C,$65,$6F,$6E,$61,$72,$64,$6F
 149+ 00C4 61 72 64 6F
 150+ 00C8 20 4D 69 6C                  defb    $20,$4D,$69,$6C,$69,$61,$6E,$69
 150+ 00CC 69 61 6E 69
 151+ 00D0 46 57 20 31  FWVER:          defm    "FW ","1.03",$20,"03-01-2021 18:49:32",$00
 151+ 00D4 2E 30 33 20
 151+ 00D8 30 33 2D 30
 151+ 00DC 31 2D 32 30
 151+ 00E0 32 31 20 31
 151+ 00E4 38 3A 34 39
 151+ 00E8 3A 33 32 00
bootloader-1.04.asm(152): warning: Label has different value in pass 3: previous value 218 not equal 236
 152+ 00EC              FMVEREND:       equ     $
 153+ 00EC FF FF FF...                  BLOCK   $100-FMVEREND,$FF   ; filler
 154+ 0100              ;------------------------------------------------------------------------------
 155+ 0100
 156+ 0100              ;-------------------------------------------------------------------------------
 157+ 0100              ;               Z80 SIO CH. A MANAGEMENT
 158+ 0100              ;-------------------------------------------------------------------------------
 159+ 0100
 160+ 0100              ;-------------------------------------------------------------------------------
 161+ 0100              ; interrupt driven routine to get chars from Z80 SIO ch.A
 162+ 0100              ; this is the only channel that can print received chars onto the screen
 163+ 0100                              ;$0100
 164+ 0100 F5           RX_CHA_AVAIL:   push    AF              ; store A
 165+ 0101 E5                           push    HL              ; and HL
 166+ 0102 CD 8E 01                     call    A_RTS_OFF       ; disable RTS line
 167+ 0105 DB 20                        in      A,(SIO_DA)      ; read char from RX buffer into A
 168+ 0107 32 09 53                     ld      (TMPKEYBFR),A   ; store it into the temp key buffer
 169+ 010A CD F4 01                     call    CHARINTOBFR     ; sub-routine to put the char into the input buffer
 170+ 010D D2 30 01                     jp      NC,LVRXCHA      ; if buffer is full, then leave without doing anything else
 171+ 0110 3A 09 53                     ld      A,(TMPKEYBFR)   ; retrieve char
 172+ 0113 32 CA 52                     ld      (CHR4VID),A     ; write into buffer for video printing
 173+ 0116 FE 0D                        cp      CR              ; is it RETURN?
 174+ 0118 CA 20 01                     jp      Z,CNTRXCHA      ; yes, continue
 175+ 011B FE 20                        cp      $20             ; is it another control char (code < 32)?
 176+ 011D DA 30 01                     jp      C,LVRXCHA       ; yes, leave w/o printing it on video nor sending back to serial
 177+ 0120 F5           CNTRXCHA:       push    AF              ; store char
 178+ 0121 AF                           xor     A
 179+ 0122 32 07 53                     ld      (KBDNPT),A      ; a char from serial is like a char printed by BASIC
 180+ 0125 3A C7 52                     ld      A,(CRSR_STATE)  ; check cursor state
 181+ 0128 B7                           or      A               ; is it on?
 182+ 0129 C4 4E 07                     call    NZ,CHAR2VID     ; yes, print on screen
 183+ 012C F1                           pop     AF              ; retrieve char
 184+ 012D CD 4D 02                     call    TXA             ; send back to serial
 185+ 0130 E1           LVRXCHA:        pop     HL              ; retrieve HL
 186+ 0131 F1                           pop     AF              ; and A
 187+ 0132 FB                           ei                      ; re-enable interrupts
 188+ 0133 ED 4D                        reti                    ; and exit
 189+ 0135
 190+ 0135              ;-------------------------------------------------------------------------------
 191+ 0135              ; special SIO ch.A condition (i.e., buffer overrun)
 192+ 0135              ; if buffer overruns then show an error, empty the RX buffer and send
 193+ 0135              ; a break char
 194+ 0135 F5           SPEC_RXA_CNDT:  push    AF              ; store AF
 195+ 0136 CD 8E 01                     call    A_RTS_OFF       ; disable RTS
 196+ 0139 CD C2 01                     call    SIO_A_DI        ; disable RX on ch. A
 197+ 013C 3A 0F 53                     ld      A,(SERIALS_EN)  ; load serial status
 198+ 013F CB 97                        res     2,A             ; disable RX on port 1
 199+ 0141 32 0F 53                     ld      (SERIALS_EN),A  ; store new serial status
 200+ 0144 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 201+ 0146 CB E7                        set     4,A             ; set 5th pin ON
 202+ 0148 D3 01                        out     (PIO_DB),A      ; send new setting
 203+ 014A 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 204+ 014C D3 22                        out     (SIO_CA),A      ; send command to SIO
 205+ 014E AF           EMPTYCHABFR:    xor     A
 206+ 014F D3 22                        out     (SIO_CA),A      ; write to WR0, select RR0
 207+ 0151 DB 22                        in      A,(SIO_CA)      ; read RR0 register
 208+ 0153 E6 01                        and     $01             ; check if input buffer if empty
 209+ 0155 CA 5C 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then leave
 210+ 0158 DB 20                        in      A,(SIO_DA)      ; read chars
 211+ 015A 18 F2                        jr      EMPTYCHABFR     ; repeat
 212+ 015C F1           CHABFREMPTY:    pop     AF              ; retrieve AF
 213+ 015D 21 CE 3C                     ld      HL,SOERR        ; return point set to Serial Buffer Overrun routine
 214+ 0160 E3                           ex      (SP),HL         ; store onto stack
 215+ 0161 FB                           ei                      ; re-enable interrupts
 216+ 0162 ED 4D                        reti                    ; return from interrupt and execute code at SOERR
 217+ 0164
 218+ 0164              ;-------------------------------------------------------------------------------
 219+ 0164              ;               Z80 SIO CH. A MANAGEMENT
 220+ 0164              ;-------------------------------------------------------------------------------
 221+ 0164
 222+ 0164              ;-------------------------------------------------------------------------------
 223+ 0164              ; interrupt driven routine to get chars from Z80 SIO ch.B
 224+ 0164 FB           RX_CHB_AVAIL:   ei
 225+ 0165 ED 4D                        reti
 226+ 0167
 227+ 0167              ;-------------------------------------------------------------------------------
 228+ 0167              ; special SIO ch.A condition (i.e., buffer overrun)
 229+ 0167              ; if buffer overruns then show an error, empty the RX buffer and send
 230+ 0167              ; a break char
 231+ 0167 F5           SPEC_RXB_CNDT:  push    AF              ; store A
 232+ 0168 CD 96 01                     call    B_RTS_OFF       ; disable RTS
 233+ 016B CD CA 01                     call    SIO_B_DI        ; disable RX on ch.B
 234+ 016E 3A 0F 53                     ld      A,(SERIALS_EN)  ; load serial status
 235+ 0171 CB 9F                        res     3,A             ; disable RX on port 2
 236+ 0173 32 0F 53                     ld      (SERIALS_EN),A  ; store new serial status
 237+ 0176 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 238+ 0178 CB EF                        set     5,A             ; set 5th pin ON
 239+ 017A D3 01                        out     (PIO_DB),A      ; send new setting
 240+ 017C 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 241+ 017E D3 23                        out     (SIO_CB),A      ; send command to SIO
 242+ 0180 AF           EMPTYCHBBFR:    xor     A
 243+ 0181 D3 23                        out     (SIO_CB),A      ; write to WR0, select RR0
 244+ 0183 DB 23                        in      A,(SIO_CB)      ; read RR0 register
 245+ 0185 E6 01                        and     $01             ; check if input buffer if empty
 246+ 0187 CA 5C 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then jump to run "exit" code
 247+ 018A DB 21                        in      A,(SIO_DB)      ; read chars
 248+ 018C 18 F2                        jr      EMPTYCHBBFR     ; repeat
 249+ 018E
 250+ 018E
 251+ 018E              ;-------------------------------------------------------------------------------
 252+ 018E              ;               Z80 SIO MANAGEMENT
 253+ 018E              ;-------------------------------------------------------------------------------
 254+ 018E              ; disable RTS:
 255+ 018E              ; by resetting RTS bit (set to 0), the RTS line is disabled (HIGH)
 256+ 018E C5           A_RTS_OFF:      push    BC              ; store BC
 257+ 018F 0E 22                        ld      C,SIO_CA        ; select channel A
 258+ 0191 3A 10 53                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 259+ 0194 18 06                        jr      SIO_RTS_OFF
 260+ 0196 C5           B_RTS_OFF:      push    BC              ; store BC
 261+ 0197 0E 23                        ld      C,SIO_CB        ; select channel B
 262+ 0199 3A 11 53                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 263+ 019C 47           SIO_RTS_OFF:    ld      B,A             ; store data bits
 264+ 019D 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 265+ 019F ED 79                        out     (C),A
 266+ 01A1 78                           ld      A,B             ; retrieve data bits
 267+ 01A2 F6 28                        or      %00101000       ; TX enable; RTS disable
 268+ 01A4 ED 79                        out     (C),A           ; send setting
 269+ 01A6 C1                           pop     BC              ; retrieve BC
 270+ 01A7 C9                           ret                     ; exit
 271+ 01A8
 272+ 01A8              ;-------------------------------------------------------------------------------
 273+ 01A8              ; enable RTS
 274+ 01A8              ; by setting RTS bit (set to 1), the RTS line is enabled (LOW)
 275+ 01A8 C5           A_RTS_ON:       push    BC              ; store BC
 276+ 01A9 0E 22                        ld      C,SIO_CA        ; select channel A
 277+ 01AB 3A 10 53                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 278+ 01AE 18 06                        jr      SIO_RTS_ON
 279+ 01B0 C5           B_RTS_ON:       push    BC              ; store BC
 280+ 01B1 0E 23                        ld      C,SIO_CB        ; select channel B
 281+ 01B3 3A 11 53                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 282+ 01B6 47           SIO_RTS_ON:     ld      B,A             ; store data bits
 283+ 01B7 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 284+ 01B9 ED 79                        out     (C),A
 285+ 01BB 78                           ld      A,B             ; retrieve data bits
 286+ 01BC F6 2A                        or      %00101010       ; TX enable; RTS enable
 287+ 01BE ED 79                        out     (C),A           ; send setting
 288+ 01C0 C1                           pop     BC              ; retrieve BC
 289+ 01C1 C9                           ret                     ; return
 290+ 01C2
 291+ 01C2              ;-------------------------------------------------------------------------------
 292+ 01C2              ; disable SIO RX channel
 293+ 01C2 C5           SIO_A_DI:       push    BC              ; store BC
 294+ 01C3 0E 22                        ld      C,SIO_CA        ; SIO channel A
 295+ 01C5 3A 10 53                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 296+ 01C8 18 06                        jr      SIO_RXDI        ; jump to disable RX
 297+ 01CA C5           SIO_B_DI:       push    BC              ; store BC
 298+ 01CB 0E 23                        ld      C,SIO_CB        ; SIO channel B
 299+ 01CD 3A 11 53                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 300+ 01D0 47           SIO_RXDI:       ld      B,A             ; store data bits
 301+ 01D1 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 302+ 01D3 ED 79                        out     (C),A
 303+ 01D5 78                           ld      A,B             ; retrieve data bits; RX disabled; auto enable is OFF
 304+ 01D6 ED 79                        out     (C),A
 305+ 01D8 C1                           pop     BC              ; retrieve BC
 306+ 01D9 C9                           ret                     ; return
 307+ 01DA
 308+ 01DA              ;-------------------------------------------------------------------------------
 309+ 01DA              ; enable SIO RX channel
 310+ 01DA C5           SIO_A_EI:       push    BC              ; store BC
 311+ 01DB 0E 22                        ld      C,SIO_CA
 312+ 01DD 3A 10 53                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 313+ 01E0 18 06                        jr      SIO_RXEN
 314+ 01E2 C5           SIO_B_EI:       push    BC              ; store BC
 315+ 01E3 0E 23                        ld      C,SIO_CB
 316+ 01E5 3A 11 53                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 317+ 01E8 47           SIO_RXEN:       ld      B,A             ; store data bits
 318+ 01E9 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 319+ 01EB ED 79                        out     (C),A           ; select register
 320+ 01ED 78                           ld      A,B             ; retrieve data bits
 321+ 01EE CB C7                        set     0,A             ; set RX enabled; auto enable is OFF
 322+ 01F0 ED 79                        out     (C),A           ; send settings to SIO
 323+ 01F2 C1                           pop     BC              ; retrieve BC
 324+ 01F3 C9                           ret
 325+ 01F4
 326+ 01F4              ;------------------------------------------------------------------------------
 327+ 01F4              ; put a char into the input buffer, char is into A
 328+ 01F4              ; this sub is called both from the ISR "RX_CHA_AVAIL" and when
 329+ 01F4              ; the RETURN key is pressed on the keyboard
 330+ 01F4 F5           CHARINTOBFR:    push    AF              ; store it
 331+ 01F5 3A 4B 51                     ld      A,(serBufUsed)  ; load buffer size
 332+ 01F8 FE 58                        cp      SER_BUFSIZE     ; if buffer is not full
 333+ 01FA DA FF 01                     jp      C,NOTFULL       ; then store the char
 334+ 01FD F1                           pop     AF              ; else drop it
 335+ 01FE C9                           ret                     ; and exit
 336+ 01FF 2A 47 51     NOTFULL:        ld      HL,(serInPtr)   ; buffer is not full, can store the char
 337+ 0202 23                           inc     HL              ; load pointer to find first free cell
 338+ 0203 7D                           ld      A,L             ; only check low byte because buffer<256
 339+ 0204 FE 47                        cp      bufWrap         ; check if the pointer is at the last cell
 340+ 0206 20 03                        jr      NZ,NOTWRAP      ; if not then continue
 341+ 0208 21 EF 50                     ld      HL,SERBUF_START ; else load the address of the first cell
 342+ 020B 22 47 51     NOTWRAP:        ld      (serInPtr),HL   ; store the new pointer
 343+ 020E F1                           pop     AF              ; then recover the char
 344+ 020F 77                           ld      (HL),A          ; and store it in the appropriate cell
 345+ 0210 3A 4B 51                     ld      A,(serBufUsed)  ; load the size of the input buffer
 346+ 0213 3C                           inc     A               ; increment it
 347+ 0214 32 4B 51                     ld      (serBufUsed),A  ; and store the new size
 348+ 0217 FE 50                        cp      SER_FULLSIZE    ; check if input buffer is full
 349+ 0219 D8                           ret     C               ; exit if buffer is not full
 350+ 021A 3A 0F 53                     ld      A,(SERIALS_EN)  ; check if serial 1 is open
 351+ 021D 1F                           rra                     ; bit 0 into Carry: if Carry is 1 then serial 0 is open and...
 352+ 021E DC 8E 01                     call    C,A_RTS_OFF     ; ...stop receiving further chars
 353+ 0221 AF                           xor     A               ; clear Carry to set a buffer full condition
 354+ 0222 C9                           ret
 355+ 0223
 356+ 0223
 357+ 0223              ;-------------------------------------------------------------------------------
 358+ 0223              ; retrieve a char from the input buffer
 359+ 0223 3A 4B 51     RXA:            ld      A,(serBufUsed)  ; load the buffer size
 360+ 0226 A7                           and     A               ; check if it's 0 (empty)
 361+ 0227 CA 23 02                     jp      Z,RXA           ; if it's empty, wait for a char
 362+ 022A F3                           di                      ; disable interrupts
 363+ 022B E5                           push    HL              ; store HL
 364+ 022C 2A 49 51                     ld      HL,(serRdPtr)   ; load pointer to first available char
 365+ 022F 23                           inc     HL              ; increment it (go to the next char)
 366+ 0230 7D                           ld      A,L             ; check if the end of the buffer has been reached
 367+ 0231 FE 47                        cp      bufWrap         ; (only check low byte because buffer<256)
 368+ 0233 20 03                        jr      NZ,NOTRDWRAP    ; if not, jump straight
 369+ 0235 21 EF 50                     ld      HL,SERBUF_START ; else reload the starting address of the buffer
 370+ 0238 22 49 51     NOTRDWRAP:      ld      (serRdPtr),HL   ; store new pointer to the next char to read
 371+ 023B 3A 4B 51                     ld      A,(serBufUsed)  ; load buffer size
 372+ 023E 3D                           dec     A               ; decrement it
 373+ 023F 32 4B 51                     ld      (serBufUsed),A  ; and store the new size
 374+ 0242 FE 05                        cp      SER_EMPTYSIZE   ; check if input buffer can be considered empty
 375+ 0244 30 03                        jr      NC,RXA_EXIT     ; if not empty yet, then exit
 376+ 0246 CD A8 01                     call    A_RTS_ON        ; else re-enable receiving chars
 377+ 0249 7E           RXA_EXIT:       ld      A,(HL)          ; recover the char and return it into A
 378+ 024A E1                           pop     HL              ; retrieve HL
 379+ 024B FB                           ei                      ; re-enable interrupts
 380+ 024C C9                           ret                     ; return
 381+ 024D
 382+ 024D              ;------------------------------------------------------------------------------
 383+ 024D              ; sends a char over the serial (trick for INTs from WikiTI)
 384+ 024D              ; char is into A
 385+ 024D F5           TXA:            push    AF              ; store AF
 386+ 024E C5                           push    BC              ; store BC
 387+ 024F 47                           ld      B,A             ; store char
 388+ 0250 ED 57                        ld      A,I             ; when loading I into A, P/V is set to the value of IFF (P/V is set if INTs enabled)
 389+ 0252 EA 57 02                     jp      PE,CNTTXA       ; if set, jump over
 390+ 0255 ED 57                        ld      A,I             ; if not set, test again to fix "false negative" from interrupt occurring at first test
 391+ 0257 F5           CNTTXA:         push    AF              ; store current P/V flag
 392+ 0258 F3                           di                      ; disable INTs
 393+ 0259 3A 0F 53                     ld      A,(SERIALS_EN)  ; load serial status
 394+ 025C FE 05                        cp      %00000101       ; check if serial 1 is open and RX/TX is enabled
 395+ 025E 20 06                        jr      NZ,TXA_EXIT     ; no, jump over
 396+ 0260 78                           ld      A,B             ; retrieve char
 397+ 0261 D3 20                        out     (SIO_DA),A      ; send char to the SIO
 398+ 0263 CD 6E 02                     call    TX_EMP          ; wait for outgoing char to be sent
 399+ 0266 F1           TXA_EXIT:       pop     AF              ; retrieve P/V flag
 400+ 0267 E2 6B 02                     jp      PO,EXTXA        ; if P is reset, INTs were disabled so we can leave right now
 401+ 026A FB                           ei                      ; INTs were enabled, so re-enable interrupts
 402+ 026B C1           EXTXA:          pop     BC              ; retrieve BC
 403+ 026C F1                           pop     AF              ; retrieve AF
 404+ 026D C9                           ret                     ; return
 405+ 026E
 406+ 026E              ;------------------------------------------------------------------------------
 407+ 026E              ; wait until outgoing serial has been sent
 408+ 026E 97           TX_EMP:         sub     A               ; set A to 0
 409+ 026F 3C                           inc     A               ; set A to 1
 410+ 0270 D3 22                        out     (SIO_CA),A      ; write to WR0, select RR1
 411+ 0272 DB 22                        in      A,(SIO_CA)      ; read RR1 register
 412+ 0274 CB 47                        bit     0,A             ; check if all chars have been sent
 413+ 0276 CA 6E 02                     jp      Z,TX_EMP        ; if not (bit 0 = 0) then retrieve
 414+ 0279 C9                           ret                     ; else exit
 415+ 027A
 416+ 027A
 417+ 027A              ;------------------------------------------------------------------------------
 418+ 027A              ; check if there is some chars into the buffer
 419+ 027A 3A 4B 51     CKINCHAR:       ld      A,(serBufUsed)  ; load char in buffer
 420+ 027D A7                           and     A               ; compare to 0
 421+ 027E C9                           ret                     ; return
 422+ 027F
 423+ 027F              ;------------------------------------------------------------------------------
 424+ 027F              ; print a text from memory, and terminate when $00 is found
 425+ 027F 7E           RAWPRINT:       ld      A,(HL)          ; load character from memory cell pointed by HL
 426+ 0280 B7                           or      A               ; is it $00 (end string)?
 427+ 0281 C8                           ret     Z               ; Yes, then return
 428+ 0282 32 CA 52                     ld      (CHR4VID),A     ; store char
 429+ 0285 F3                           di
 430+ 0286 CD 4E 07                     call    CHAR2VID        ; and send it to screen
 431+ 0289 FB                           ei
 432+ 028A 23                           inc     HL              ; and select the next one
 433+ 028B 18 F2                        jr      RAWPRINT        ; repeat
 434+ 028D
 435+ 028D              ;-------------------------------------------------
 436+ 028D              ; Interrupt service routine (ISR) for CH3 timer
 437+ 028D              ; this is used to increment the 100ths of a second counter and for cursor flashing
 438+ 028D F5           CH3_TIMER:      push    AF              ; save regs. A,
 439+ 028E C5                           push    BC              ; BC,
 440+ 028F D5                           push    DE              ; DE,
 441+ 0290 E5                           push    HL              ; HL
 442+ 0291 21 AC 52                     ld      HL,TMRCNT       ; load starting address of the timer
 443+ 0294 06 04                        ld      B,$04           ; 4 bytes to check
 444+ 0296 34           INCTMR3:        inc     (HL)            ; increment timer
 445+ 0297 20 03                        jr      NZ,CHKCRSR      ; if not zero then exit (finished increment)
 446+ 0299 23                           inc     HL              ; if yes, there was an overflow, so increment next byte
 447+ 029A 10 FA                        djnz    INCTMR3         ; repeat for 4 bytes
 448+ 029C CD B8 07     CHKCRSR:        call    FLASHCURSOR     ; call the flashing cursor routine
 449+ 029F CD AF 0C                     call    MNGSNDS         ; call the tone managemenet
 450+ 02A2 3A AC 52                     ld      A,(TMRCNT)      ; check for keyboard management
 451+ 02A5 1F                           rra                     ; bit 0 = 1 ?
 452+ 02A6 D4 14 0D                     call    NC,KEYBOARD     ; no, so read the keyboard inputs
 453+ 02A9 E1                           pop     HL              ; retrieve HL,
 454+ 02AA D1                           pop     DE              ; DE,
 455+ 02AB C1                           pop     BC              ; BC,
 456+ 02AC F1                           pop     AF              ; and A
 457+ 02AD FB                           ei                      ; re-enable interrupts
 458+ 02AE ED 4D                        reti                    ; exit from ISR
 459+ 02B0
 460+ 02B0              ;------------------------------------------------------------------------------
 461+ 02B0              ;               HARDWARE INITIALISATION
 462+ 02B0              ;------------------------------------------------------------------------------
 463+ 02B0              ; first run - setup HW & SW
 464+ 02B0              ; (on LN80C 64K runs from RAM)
 465+ 02B0 21 7E 52     INIT_HW:        ld      HL,TEMPSTACK    ; load temp stack pointer
 466+ 02B3 F9           INIT_HW2:       ld      SP,HL           ; set stack to temp stack pointer
 467+ 02B4 21 EF 50                     ld      HL,SERBUF_START ; set beginning of input buffer
 468+ 02B7 22 47 51                     ld      (serInPtr),HL   ; for incoming chars to store into buffer
 469+ 02BA 22 49 51                     ld      (serRdPtr),HL   ; and for chars to be read from buffer
 470+ 02BD AF                           xor     A               ; reset A
 471+ 02BE 32 4B 51                     ld      (serBufUsed),A  ; actual buffer size is 0
 472+ 02C1 32 0F 53                     ld      (SERIALS_EN),A  ; set serial ports status to OFF
 473+ 02C4                  IFDEF LM80C
 474+ 02C4 ~                            call    HELLOWRLD       ; little serial blink with LEDs
 475+ 02C4                  ENDIF
 476+ 02C4 CD 42 03                     call    initCTC         ; configure CTC, then...
 477+ 02C7 CD 4D 0C                     call    initPSG         ; ...configure PSG
 478+ 02CA CD F4 04                     call    SHOW_LOGO       ; show computer logo
 479+ 02CD 1E 01                        ld      E,$01           ; E chooses the video mode (graphics 1)
 480+ 02CF CD D3 03                     call    initVDP         ; set video display
 481+ 02D2 AF                           xor     A
 482+ 02D3 ED 47                        ld      I,A             ; set high byte of interrupt vectors to point to page 0
 483+ 02D5 ED 5E                        im      2               ; interrupt mode 2
 484+ 02D7 FB                           ei                      ; enable interrupts
 485+ 02D8                              ; print system messages
 486+ 02D8 AF                           xor     A               ; A=0 so...
 487+ 02D9 32 07 53                     ld      (KBDNPT),A      ; ...inputs don't come from keyboard
 488+ 02DC 3C                           inc     A               ; A=1...
 489+ 02DD 32 C9 52                     ld      (PRNTVIDEO),A   ; ...to activate the print-on-video
 490+ 02E0 21 78 03                     ld      HL,MSGTXT1      ; sign-on message
 491+ 02E3 CD 7F 02                     call    RAWPRINT        ; print message
 492+ 02E6 3A 4C 51                     ld      A,(basicStarted); check if BASIC is already started
 493+ 02E9 FE 59                        cp      'Y'             ; to see if this is a power-up
 494+ 02EB 20 19                        jr      NZ,COLDSTART    ; if not, then do a COLD start
 495+ 02ED 21 B6 03                     ld      HL,MSGTXT2      ; message to choose kind of start
 496+ 02F0 CD 7F 02                     call    RAWPRINT        ; print message
 497+ 02F3 CD EA 08                     call    CURSOR_ON       ; enable cursor
 498+ 02F6 AF                           xor     A
 499+ 02F7 32 C9 52                     ld      (PRNTVIDEO),A   ; disable print-on-video
 500+ 02FA CD 23 02     CORW:           call    RXA             ; look for a pressed key
 501+ 02FD E6 DF                        and     %11011111       ; only UPPERCASE char
 502+ 02FF FE 43                        cp      'C'             ; cold start?
 503+ 0301 20 0E                        jr      NZ,CHECKWARM    ; no, let's check for warm start
 504+ 0303 CD 1E 03                     call    ECHO_CHAR       ; echoes the char
 505+ 0306 3E 59        COLDSTART:      ld      A,'Y'           ; yes, set the "BASIC started" flag
 506+ 0308 32 4C 51                     ld      (basicStarted),A
 507+ 030B CD FF 08                     call    CURSOR_OFF      ; disable cursor
 508+ 030E C3 B3 11                     jp      COLD            ; start BASIC COLD
 509+ 0311 FE 57        CHECKWARM:      cp      'W'
 510+ 0313 20 E5                        jr      NZ,CORW         ; char not recognized, wait again
 511+ 0315 CD 1E 03                     call    ECHO_CHAR       ; echoes the char
 512+ 0318 CD FF 08                     call    CURSOR_OFF      ; disable cursor
 513+ 031B C3 B6 11                     jp      WARM            ; start BASIC WARM
 514+ 031E
 515+ 031E              ;-------------------------------------------------------------------------------
 516+ 031E              ; send back char received through ch. A
 517+ 031E 32 CA 52     ECHO_CHAR:      ld      (CHR4VID),A     ; set char for video printing
 518+ 0321 AF                           xor     A
 519+ 0322 32 07 53                     ld      (KBDNPT),A      ; input is not from keyboard
 520+ 0325 F3                           di                      ; disable INTs
 521+ 0326 CD 4E 07                     call    CHAR2VID        ; echoes back the pressed key,
 522+ 0329 3E 0D                        ld      A,CR            ; then set a CR
 523+ 032B 32 CA 52                     ld      (CHR4VID),A     ; set char for video printing
 524+ 032E CD 4E 07                     call    CHAR2VID        ; and send it to screen
 525+ 0331 FB                           ei                      ; re-enable INTs
 526+ 0332 3E 01                        ld      A,$01
 527+ 0334 32 C9 52                     ld      (PRNTVIDEO),A   ; re-enable video printing
 528+ 0337 C9                           ret                     ; return to caller
 529+ 0338
 530+ 0338                  IFDEF LM80C
 531+ 0338 ~            ;-------------------------------------------------------------------------------
 532+ 0338 ~            ; little serial blink with LEDs
 533+ 0338 ~            HELLOWRLD:      ld      C,$09           ; 8 LEDs to be turned off + 1 more step to turn off the last LED
 534+ 0338 ~                            ld      A,%11001111     ; set mode 3 (mode control)
 535+ 0338 ~                            out     (PIO_CB),A      ; for PIO port B
 536+ 0338 ~                            xor     A               ; set pins to OUTPUT
 537+ 0338 ~                            out     (PIO_CB),A      ; for port B
 538+ 0338 ~                            inc     A               ; LSB on
 539+ 0338 ~            LEDLIGHT:       out     (PIO_DB),A      ; turn LEDs on/off for a "Supercar" sequence
 540+ 0338 ~                            ld      E,$20           ; little delay
 541+ 0338 ~            DEC_E:          ld      B,$00           ; count to 256
 542+ 0338 ~            COUNTER:        djnz    COUNTER         ; decrement inner counter
 543+ 0338 ~                            dec     E               ; decrement outer counter
 544+ 0338 ~                            jr      NZ,DEC_E        ; finish delay
 545+ 0338 ~                            sla     A               ; shift reg.A to left 1 bit
 546+ 0338 ~                            dec     C               ; next LED
 547+ 0338 ~                            jr      NZ,LEDLIGHT     ; all LEDs done? no, repeat
 548+ 0338 ~                            ret                     ; return to caller
 549+ 0338                  ENDIF
 550+ 0338              ;-------------------------------------------------------------------------------
 551+ 0338              ; Z80 SIO default settings for serial channels
 552+ 0338 30           SIO_A_SETS:     defb    %00110000       ; write into WR0: error reset, select WR0
 553+ 0339 18                           defb    %00011000       ; write into WR0: channel reset
 554+ 033A 04                           defb    %00000100       ; write into WR0: select WR4
 555+ 033B 44                           defb    %01000100       ; write into WR4: presc. 16x, 1 stop bit, no parity
 556+ 033C 05                           defb    %00000101       ; write into WR0: select WR5
 557+ 033D E8                           defb    %11101000       ; write into WR5: DTR on, TX 8 bits, BREAK off, TX on, RTS off
 558+ 033E 01           SIO_B_SETS:     defb    %00000001       ; write into WR0: select WR1
 559+ 033F 04                           defb    %00000100       ; write into WR1: status affects interrupt vectors
 560+ 0340 02                           defb    %00000010       ; write into WR0: select WR2
 561+ 0341 00                           defb    %00000000       ; write into WR2: set interrupt vector, but bits D3/D2/D1 of this vector
 562+ 0342                                                      ; will be affected by the channel & condition that raised the interrupt
 563+ 0342                                                      ; (see datasheet): in our example, 0x0C for Ch.A receiving A char, 0x0E
 564+ 0342                                                      ; for special conditions
 565+ 0342              ;------------------------------------------------------------------------------
 566+ 0342              ;               Z80 CTC SETTING UP
 567+ 0342              ;------------------------------------------------------------------------------
 568+ 0342              initCTC:
 569+ 0342 21 6C 03                     ld      HL,CTCCONF      ; CTC configuration
 570+ 0345 11 B0 52                     ld      DE,CTC0IV       ; CTC interrupt vector table
 571+ 0348 01 0C 00                     ld      BC,$000C        ; 12 bytes
 572+ 034B ED B0                        ldir                    ; copy data
 573+ 034D              ;CH0, CH1, & CH2 disabled
 574+ 034D 3E 03                        ld      A,%00000011     ; interrupt off, timer mode, prescaler=16, don't care ext. TRG edge,
 575+ 034F                                                      ; start timer on loading constant, no time constant follows, software reset, command word
 576+ 034F D3 10                        out     (CTC_CH0),A     ; set CH0
 577+ 0351 D3 11                        out     (CTC_CH1),A     ; set CH1
 578+ 0353 D3 12                        out     (CTC_CH2),A     ; set CH2
 579+ 0355              ;init CH3
 580+ 0355              ;CH3 divides CPU CLK by 144*256 providing an interrupt signal at 100 Hz (1/100 sec).
 581+ 0355              ;f = CPU_CLK/(144*256) => 3,686,400 / ( 36,864 ) => 100Hz
 582+ 0355 3E A7                        ld      A,%10100111     ; interrupt on; timer mode; prescaler=256; don't care ext; automatic trigger;
 583+ 0357                                                      ; time constant follows; cont. operation; command word
 584+ 0357 D3 13                        out     (CTC_CH3),A     ; send to CH3
 585+ 0359 3E 90                        ld      A,$90           ; time constant - 90$ (144d)
 586+ 035B D3 13                        out     (CTC_CH3),A     ; send to CH3
 587+ 035D 3E 40                        ld      A,%01000000     ; D7..D3 provide the first part of the int vector (in our case, $0100), followed by
 588+ 035F                                                      ; D2..D1, provided by the CTC (they point to the channel), D0=interrupt word
 589+ 035F                                                      ; so int vector is 01000xx00
 590+ 035F D3 10                        out     (CTC_CH0),A     ; send to CTC
 591+ 0361                              ; reset cells of 100ths of a second counter
 592+ 0361 AF                           xor     A               ; reset A
 593+ 0362 21 AC 52                     ld      HL,TMRCNT       ; load TMR pointer
 594+ 0365 06 04                        ld      B,$04           ; 4 memory cells
 595+ 0367 77           RESTMR:         ld      (HL),A          ; reset n-cell of TMR
 596+ 0368 23                           inc     HL              ; next cell
 597+ 0369 10 FC                        djnz    RESTMR          ; repeat for 4 cells
 598+ 036B C9                           ret
 599+ 036C
 600+ 036C
 601+ 036C              ;------------------------------------------------------------------------------
 602+ 036C              ; jump table for CHx interrupts
 603+ 036C FB ED 4D     CTCCONF:        defb    $FB,$ED,$4D     ; CTC0 interrupt vector (ei; reti)
 604+ 036F FB ED 4D                     defb    $FB,$ED,$4D     ; CTC1 interrupt vector (ei; reti)
 605+ 0372 FB ED 4D                     defb    $FB,$ED,$4D     ; CTC2 interrupt vector (ei; reti)
 606+ 0375 C3 8D 02                     jp      CH3_TIMER       ; CTC3 interrupt vector (jump to execute sys-tick timer)
 607+ 0378
 608+ 0378
 609+ 0378              ;------------------------------------------------------------------------------
 610+ 0378              ; welcome messages
 611+ 0378              MSGTXT1:
 612+ 0378                  IFDEF LM80C64K
 613+ 0378 20 20 20 20                  defm    "    LM80C 64K Color Computer",CR
 613+ 037C 4C 4D 38 30
 613+ 0380 43 20 36 34
 613+ 0384 4B 20 43 6F
 613+ 0388 6C 6F 72 20
 613+ 038C 43 6F 6D 70
 613+ 0390 75 74 65 72
 613+ 0394 0D
 614+ 0395                  ELSE
 615+ 0395 ~                            defm    "      LM80C Color Computer",CR
 616+ 0395                  ENDIF
 617+ 0395 20 62 79 20                  defm    " by Leonardo Miliani * FW R","1.03",CR,0
 617+ 0399 4C 65 6F 6E
 617+ 039D 61 72 64 6F
 617+ 03A1 20 4D 69 6C
 617+ 03A5 69 61 6E 69
 617+ 03A9 20 2A 20 46
 617+ 03AD 57 20 52 31
 617+ 03B1 2E 30 33 0D
 617+ 03B5 00
 618+ 03B6 0D           MSGTXT2:        defb    CR
 619+ 03B7 20 20 20 3C                  defm    "   <C>old or <W>arm start? ",0
 619+ 03BB 43 3E 6F 6C
 619+ 03BF 64 20 6F 72
 619+ 03C3 20 3C 57 3E
 619+ 03C7 61 72 6D 20
 619+ 03CB 73 74 61 72
 619+ 03CF 74 3F 20 00
 620+ 03D3
# file closed: ../include/bootloader/bootloader-1.04.asm
  70  03D3
  71  03D3              ; incude the latest version of the VDP module
  72  03D3                  INCLUDE "../include/vdp/vdp-1.2.asm"
# file opened: ../include/vdp/vdp-1.2.asm
   1+ 03D3              ; ------------------------------------------------------------------------------
   2+ 03D3              ; LM80C - VDP ROUTINES - 1.2
   3+ 03D3              ; ------------------------------------------------------------------------------
   4+ 03D3              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 03D3              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 03D3              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 03D3              ; kind of warranty: you can use them at your own risk.
   8+ 03D3              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 03D3              ; maintain the copyright notices, include this advice and the note to the
  10+ 03D3              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 03D3              ; redistribuite them.
  12+ 03D3              ; https://www.leonardomiliani.com
  13+ 03D3              ;
  14+ 03D3              ; Please support me by visiting the following links:
  15+ 03D3              ; Main project page: https://www.leonardomiliani.com
  16+ 03D3              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 03D3              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 03D3              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 03D3              ; ------------------------------------------------------------------------------
  20+ 03D3              ;
  21+ 03D3              ;------------------------------------------------------------------------------
  22+ 03D3              ; VDP INITIALISATION
  23+ 03D3              ; initialize VDP for a specific graphics mode
  24+ 03D3              ; INPUT: E -> contains the graphics mode:
  25+ 03D3              ; 0=text; 1=graphics 1; 2=graphics 2; 3=multicolor; 4=extended graphics 2
  26+ 03D3 D5           initVDP:        push    DE              ; store E
  27+ 03D4 CD 8B 0A                     call    EMPTY_VRAM      ; reset VRAM
  28+ 03D7 CD A9 0A                     call    SET_GFX_MODE    ; load register settings
  29+ 03DA CD 9E 0A                     call    CLR_RAM_REG     ; reset RAM registers
  30+ 03DD D1                           pop     DE              ; restore reg. E
  31+ 03DE AF                           xor     A               ; reset A
  32+ 03DF 47                           ld      B,A             ; reset B (will be used later)
  33+ 03E0 7B                           ld      A,E             ; move E into A
  34+ 03E1 32 BE 52                     ld      (SCR_MODE),A    ; store screen mode
  35+ 03E4 FE 01                        cp      $01             ; is it graphics 1 (A=1)?
  36+ 03E6 CA 22 04                     jp      Z,G1MD          ; yes, jump over
  37+ 03E9 FE 02                        cp      $02             ; is it graphics 2 (A=2)?
  38+ 03EB CA 62 04                     jp      Z,G2MD          ; yes, jump over
  39+ 03EE FE 03                        cp      $03             ; is it multicolor (A=3)?
  40+ 03F0 CA 84 04                     jp      Z,MCMD          ; yes, jump over
  41+ 03F3 FE 04                        cp      $04             ; is it extended graphics 2 (A=4)?
  42+ 03F5 CA A7 04                     jp      Z,EXG2MD        ; yes, jump over
  43+ 03F8                              ; otherwise, it must be $00 so we assume that it's text mode
  44+ 03F8
  45+ 03F8              ; LOAD VDP SETTINGS FOR SELECTED VIDEO MODE:
  46+ 03F8
  47+ 03F8                              ; TEXT MODE (G0)
  48+ 03F8                              ; load charset
  49+ 03F8 60           TXTMD:          ld      H,B
  50+ 03F9 68                           ld      L,B             ; HL=first pattern cell $0000
  51+ 03FA CD C5 0A                     call    LOADCHARSET     ; load patterns into VRAM
  52+ 03FD                              ; set cursor & video overlay
  53+ 03FD AF                           xor     A               ; reset A
  54+ 03FE 32 C2 52                     ld      (SCR_CURS_X),A  ; set cursor position at X=0
  55+ 0401 32 C3 52                     ld      (SCR_CURS_Y),A  ; and Y=0
  56+ 0404 3E 05                        ld      A,$05           ; light blue
  57+ 0406 32 CC 52                     ld      (BKGNDCLR),A    ; set background/border color
  58+ 0409 3E 28                        ld      A,$28
  59+ 040B 32 BC 52                     ld      (SCR_SIZE_W),A  ; screen width = 40 cols
  60+ 040E 3E 18                        ld      A,$18
  61+ 0410 32 BD 52                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  62+ 0413 3E 1E                        ld      A,$1E
  63+ 0415 32 92 51                     ld      (COMMAN),A      ; width for commas (4 columns)
  64+ 0418 11 00 08                     ld      DE,$0800
  65+ 041B ED 53 C0 52                  ld      (SCR_NAM_TB),DE ; set name table address
  66+ 041F C3 E9 04                     jp      ENDVDPSET       ; execute the rest of the video setting
  67+ 0422
  68+ 0422                              ; GRAPHICS 1 MODE (G1)
  69+ 0422                              ; load pattern table
  70+ 0422 68           G1MD:           ld      L,B
  71+ 0423 60                           ld      H,B             ; HL=first pattern cell $0000
  72+ 0424 CD C5 0A                     call    LOADCHARSET     ; load patterns into VRAM
  73+ 0427                              ; set cursor & video overlay
  74+ 0427 AF                           xor     A               ; position cursor
  75+ 0428 32 C2 52                     ld      (SCR_CURS_X),A  ; at X=0
  76+ 042B 32 C3 52                     ld      (SCR_CURS_Y),A  ; and Y=0
  77+ 042E 3E 20                        ld      A,$20
  78+ 0430 32 BC 52                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
  79+ 0433 3E 18                        ld      A,$18
  80+ 0435 32 BD 52                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  81+ 0438 3E 14                        ld      A,$14
  82+ 043A 32 92 51                     ld      (COMMAN),A      ; width for commas (3 columns)
  83+ 043D 11 00 18                     ld      DE,$1800
  84+ 0440 ED 53 C0 52                  ld      (SCR_NAM_TB),DE ; set name table address
  85+ 0444                              ; load color table
  86+ 0444 21 00 20                     ld      HL,$2000        ; color table start: $2000
  87+ 0447 CD 5D 06                     call    SETVDPADRS
  88+ 044A 3E 01                        ld      A,$01           ; foreground color...
  89+ 044C 32 CB 52                     ld      (FRGNDCLR),A    ; ...set to black
  90+ 044F 3E 0F                        ld      A,$0F           ; background color...
  91+ 0451 32 CC 52                     ld      (BKGNDCLR),A    ; ...set to white
  92+ 0454 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
  93+ 0456 06 20                        ld      B,$20           ; 32 bytes of colors
  94+ 0458 0D                           dec     C              ; VDP data mode
  95+ 0459 ED 79        LDCLRTBMD1:     out     (C),A           ; after the first byte, the VDP autoincrements VRAM pointer
  96+ 045B 00                           nop
  97+ 045C 00                           nop
  98+ 045D 10 FA                        djnz    LDCLRTBMD1      ; repeat for 32 bytes
  99+ 045F C3 E9 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 100+ 0462
 101+ 0462                              ; GRAPHICS 2 MODE (G2)
 102+ 0462 AF           G2MD:           xor     A               ; position cursor
 103+ 0463 32 C2 52                     ld      (SCR_CURS_X),A  ; at X=0
 104+ 0466 32 C3 52                     ld      (SCR_CURS_Y),A  ; and Y=0
 105+ 0469 32 BC 52                     ld      (SCR_SIZE_W),A  ; screen width = 256 pixels (0=256)
 106+ 046C 3C                           inc     A               ; black on...
 107+ 046D 32 CB 52                     ld      (FRGNDCLR),A    ; ...foreground
 108+ 0470 3E 0F                        ld      A,$0F           ; white on...
 109+ 0472 32 CC 52                     ld      (BKGNDCLR),A    ; ...background
 110+ 0475 3E C0                        ld      A,$C0
 111+ 0477 32 BD 52                     ld      (SCR_SIZE_H),A  ; screen height = 192 pixels
 112+ 047A 11 00 18                     ld      DE,$1800
 113+ 047D ED 53 C0 52                  ld      (SCR_NAM_TB),DE ; set name table address
 114+ 0481 C3 E9 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 115+ 0484
 116+ 0484                              ; MULTICOLOR MODE (G3)
 117+ 0484 AF           MCMD:           xor     A               ; position cursor
 118+ 0485 32 C2 52                     ld      (SCR_CURS_X),A  ; at X=0
 119+ 0488 32 C3 52                     ld      (SCR_CURS_Y),A  ; and Y=0
 120+ 048B 3E 0F                        ld      A,$0F           ; white color for...
 121+ 048D 32 CC 52                     ld      (BKGNDCLR),A    ; ...background and...
 122+ 0490 32 CB 52                     ld      (FRGNDCLR),A    ; ...foreground (even this is not used in MC)
 123+ 0493 3E 40                        ld      A,$40
 124+ 0495 32 BC 52                     ld      (SCR_SIZE_W),A  ; screen width = 64 blocks
 125+ 0498 3E 30                        ld      A,$30
 126+ 049A 32 BD 52                     ld      (SCR_SIZE_H),A  ; screen height = 48 blocks
 127+ 049D 11 00 08                     ld      DE,$0800
 128+ 04A0 ED 53 C0 52                  ld      (SCR_NAM_TB),DE ; set name table address
 129+ 04A4 C3 E9 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 130+ 04A7
 131+ 04A7                              ; EXTENDED GRAPHICS 2 (G4)
 132+ 04A7              EXG2MD:         ; load pattern table
 133+ 04A7 60                           ld      H,B
 134+ 04A8 68                           ld      L,B             ; HL=first pattern cell $0000
 135+ 04A9 CD C5 0A                     call    LOADCHARSET     ; load patterns into VRAM
 136+ 04AC                              ; set cursor & video overlay
 137+ 04AC AF                           xor     A               ; position cursor
 138+ 04AD 32 C2 52                     ld      (SCR_CURS_X),A  ; at X=0
 139+ 04B0 32 C3 52                     ld      (SCR_CURS_Y),A  ; and Y=0
 140+ 04B3 3E 20                        ld      A,$20
 141+ 04B5 32 BC 52                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
 142+ 04B8 3E 18                        ld      A,$18
 143+ 04BA 32 BD 52                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
 144+ 04BD 3E 14                        ld      A,$14
 145+ 04BF 32 92 51                     ld      (COMMAN),A      ; width for commas (3 columns)
 146+ 04C2 11 00 38                     ld      DE,$3800
 147+ 04C5 ED 53 C0 52                  ld      (SCR_NAM_TB),DE ; set name table address
 148+ 04C9                               ; load color table
 149+ 04C9 21 00 20                     ld      HL,$2000        ; color table start: $2000
 150+ 04CC CD 5D 06                     call    SETVDPADRS
 151+ 04CF 3E 01                        ld      A,$01           ; foreground color is...
 152+ 04D1 32 CB 52                     ld      (FRGNDCLR),A    ; ...set to black
 153+ 04D4 3E 0F                        ld      A,$0F           ; whitefor...
 154+ 04D6 32 CC 52                     ld      (BKGNDCLR),A    ; ...background
 155+ 04D9 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
 156+ 04DB 16 08                        ld      D,$08           ; 8 pages of
 157+ 04DD 06 00                        ld      B,$00           ; 256 bytes of colors (total of 2,048 cells)
 158+ 04DF 0D                           dec     C              ; VDP data mode
 159+ 04E0 ED 79        LDCLRTBEX2:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
 160+ 04E2 00                           nop
 161+ 04E3 00                           nop
 162+ 04E4 10 FA                        djnz    LDCLRTBEX2      ; repeat for 256 bytes
 163+ 04E6 15                           dec     D               ; did we fill up all the cells?
 164+ 04E7 20 F7                        jr      NZ,LDCLRTBEX2   ; no, repeat
 165+ 04E9                              ; LAST VDP SETTINGS
 166+ 04E9 CD FF 08     ENDVDPSET:      call    CURSOR_OFF      ; disable cursor
 167+ 04EC CD CE 05                     call    EMPTYVIDBUF     ; empty video buffer
 168+ 04EF AF                           xor     A
 169+ 04F0 32 C6 52                     ld      (SCR_ORG_CHR),A ; store byte used tochar used to empty the video buffer
 170+ 04F3 C9                           ret                     ; return to caller
 171+ 04F4
 172+ 04F4
 173+ 04F4              ; show initial logo
 174+ 04F4 CD 8B 0A     SHOW_LOGO:      call    EMPTY_VRAM      ; reset VRAM
 175+ 04F7                              ; set VDP for G2 mode
 176+ 04F7 06 07                        ld      B,$07           ; set only the first 7 registers
 177+ 04F9 11 10 00                     ld      DE,$0010        ; load settings for G2 mode
 178+ 04FC CD B1 0A                     call    SET_GFX_MODE2   ; load register settings
 179+ 04FF 16 01                        ld      D,$01           ; backdrop color set to black
 180+ 0501 ED 51                        out     (C),D           ; send data to VDP
 181+ 0503 ED 79                        out     (C),A           ; indicate the register to send data to
 182+ 0505                              ; set name table
 183+ 0505 21 00 18                     ld      HL,$1800        ; name table address
 184+ 0508 CD 4B 06                     call    SETNAMETABLE    ; set name table (load names into table)
 185+ 050B CD 6E 05                     call    ERASECLRTBL     ; erase color table (set foreground & background to black)
 186+ 050E                              ; set colors for logo
 187+ 050E 21 00 28                     ld      HL,$2800        ; 2nd page of color table
 188+ 0511 CD 5D 06                     call    SETVDPADRS
 189+ 0514 06 05                        ld      B,$05           ; 5 bands
 190+ 0516 21 B9 05                     ld      HL,CLRTABLE
 191+ 0519 0D                           dec     C              ; set VDP_DAT
 192+ 051A 1E 08                        ld      E,$08           ; 8 pixels each pattern
 193+ 051C 16 40        RPT101:         ld      D,$40           ; 64 chars each band
 194+ 051E 7E                           ld      A,(HL)          ; load data
 195+ 051F ED 79        RPT102:         out     (C),A           ; send it to VRAM
 196+ 0521 00                           nop                     ; little delay
 197+ 0522 1D                           dec     E               ; decrement counter
 198+ 0523 20 FA                        jr      NZ,RPT102       ; repeat until zero
 199+ 0525 1E 08                        ld      E,$08           ; 8 pixels each pattern
 200+ 0527 15                           dec     D               ; decrement char band counter
 201+ 0528 20 F5                        jr      NZ,RPT102       ; repeat until zero
 202+ 052A 23                           inc     HL              ; next pattern
 203+ 052B 10 EF                        djnz    RPT101          ; repeat until covered every band
 204+ 052D                              ; set pattern table
 205+ 052D 21 00 08                     ld      HL,$0800        ; address of first cell of 2nd area of pattern table
 206+ 0530 11 0D 0B                     ld      DE,LM80CLOGO    ; pointer to logo pattern
 207+ 0533 06 00                        ld      B,$00           ; 256 bytes, 8 rows
 208+ 0535 CD 99 05     RPT103:         call    LOADLOGOCHRS
 209+ 0538 13                           inc     DE              ; next logo pattern
 210+ 0539 10 FA                        djnz    RPT103
 211+ 053B 06 20                        ld      B,$20           ; repeat for another 2 rows
 212+ 053D CD 99 05     RPT104:         call    LOADLOGOCHRS
 213+ 0540 13                           inc     DE              ; next logo pattern
 214+ 0541 10 FA                        djnz    RPT104
 215+ 0543                              ; show logo/message, play a beep, check for SHIFT pressure (to disable DOS), and wait a while
 216+ 0543 06 02                        ld      B,$02           ; two times
 217+ 0545 AF                           xor     A               ; reset A
 218+ 0546 57                           ld      D,A             ; 256 times
 219+ 0547 5F                           ld      E,A             ; x 256 times
 220+ 0548 32 CD 52                     ld      (TMPBFR1),A     ; sound flag set to 0
 221+ 054B                  IFDEF LM80C64K
 222+ 054B 3C                           inc     A               ; A=1
 223+ 054C                  ENDIF
 224+ 054C 32 12 53                     ld      (DOS_EN),A      ; DOS enabled
 225+ 054F 00           DEC_D:          nop                     ; does nothing...
 226+ 0550 00                           nop
 227+ 0551 00                           nop
 228+ 0552 00                           nop
 229+ 0553 00                           nop
 230+ 0554 00                           nop                     ; ...until here
 231+ 0555 1D                           dec     E               ; decrement E
 232+ 0556 20 F7                        jr      NZ,DEC_D        ; repeat until $00
 233+ 0558 7A                           ld      A,D
 234+ 0559 FE 40                        cp      $40             ; ...equal to 64
 235+ 055B CC 85 05                     call    Z,SETBEEP       ; if yes, start sound
 236+ 055E 15                           dec     D
 237+ 055F 20 EE                        jr      NZ,DEC_D        ; repeat
 238+ 0561 3A CD 52                     ld      A,(TMPBFR1)     ; sound state
 239+ 0564 FE 02                        cp      $02             ; check if sound is to be set off
 240+ 0566 C4 91 05                     call    NZ,BEEPOFF      ; yes
 241+ 0569                  IFDEF LM80C64K
 242+ 0569 CD BE 05                     call    CHKSPCK         ; check if special key (CTRL) has been pressed on keyboard
 243+ 056C                  ENDIF
 244+ 056C 10 E1                        djnz    DEC_D           ; repeat
 245+ 056E              ERASECLRTBL:    ; erase color table
 246+ 056E 3E 11                        ld      A,$11           ; foreground and background set to black
 247+ 0570 16 0A                        ld      D,$0A           ; 10 pages
 248+ 0572 06 00                        ld      B,$00           ; 256 color cells per page
 249+ 0574 21 00 28                     ld      HL,$2800        ; first cell of 2nd color table
 250+ 0577 CD 5D 06                     call    SETVDPADRS      ; send address
 251+ 057A 0D                           dec     C              ; VDP address for passing data
 252+ 057B ED 79        RPT100:         out     (C),A           ; send data
 253+ 057D 00                           nop
 254+ 057E 00                           nop                     ; little delay
 255+ 057F 10 FA                        djnz    RPT100          ; repeat for entire page
 256+ 0581 15                           dec     D
 257+ 0582 20 F7                        jr      NZ,RPT100       ; repeat for all the pages ($0A00 cells)
 258+ 0584 C9                           ret                     ; return to caller
 259+ 0585
 260+ 0585              ; play a beep
 261+ 0585 3A CD 52     SETBEEP:        ld      A,(TMPBFR1)     ; check the already-beeped flag
 262+ 0588 B7                           or      A               ; is it 0?
 263+ 0589 C0                           ret     NZ              ; no, exit
 264+ 058A 3C                           inc     A               ; flag to 1
 265+ 058B 32 CD 52                     ld      (TMPBFR1),A     ; set sound
 266+ 058E C3 7B 0C                     jp      WLCMBEEP        ; play a beep & return
 267+ 0591
 268+ 0591              ; beep off
 269+ 0591 3E 02        BEEPOFF:        ld      A,$02           ; flag for sound off
 270+ 0593 32 CD 52                     ld      (TMPBFR1),A     ; set flag
 271+ 0596 C3 81 0C                     jp      NOBEEP          ; stop beep and return
 272+ 0599
 273+ 0599
 274+ 0599              ; used to load the chars that will compose the logo of the splash screen
 275+ 0599 1A           LOADLOGOCHRS:   ld      A,(DE)          ; load a pattern char of the logo
 276+ 059A 87                           add     A,A
 277+ 059B 87                           add     A,A
 278+ 059C 87                           add     A,A             ; multiply times 8 to get the offset
 279+ 059D C5                           push    BC
 280+ 059E D5                           push    DE              ; store BC and DE
 281+ 059F E5                           push    HL              ; store VRAM address to write to
 282+ 05A0 21 EB 4F                     ld      HL,LOGOFONT     ; start of logo font data
 283+ 05A3 5F                           ld      E,A
 284+ 05A4 16 00                        ld      D,$00           ; put offset (A) into DE
 285+ 05A6 19                           add     HL,DE           ; get address of pattern data
 286+ 05A7 EB                           ex      DE,HL           ; move address into DE
 287+ 05A8 E1                           pop     HL              ; retrieve VRAM address
 288+ 05A9 06 08                        ld      B,$08           ; 8 bytes per pattern
 289+ 05AB CD 5D 06                     call    SETVDPADRS      ; set VDP address
 290+ 05AE 0D                           dec     C              ; VDP_DAT
 291+ 05AF 1A           SNDLOGPT:       ld      A,(DE)          ; load data from RAM
 292+ 05B0 ED 79                        out     (C),A           ; and send to VRAM
 293+ 05B2 13                           inc     DE              ; next byte into RAM
 294+ 05B3 23                           inc     HL              ; next byte into VRAM (used in future iterations)
 295+ 05B4 10 F9                        djnz    SNDLOGPT        ; repeat 8 times
 296+ 05B6 D1                           pop     DE
 297+ 05B7 C1                           pop     BC              ; retrieve BC & DE
 298+ 05B8 C9                           ret                     ; return to caller
 299+ 05B9              CLRTABLE:       equ $
 300+ 05B9 18 1B 13 14                  defb    $18,$1B,$13,$14,$1D ; colors of background bands of the logo
 300+ 05BD 1D
 301+ 05BE
 302+ 05BE
 303+ 05BE              ; while showing the logo, check if special key (CTRL) is being pressed
 304+ 05BE              ; if yes, then disable DOS functions recovering RAM
 305+ 05BE F5           CHKSPCK:        push    AF
 306+ 05BF 3E FE                        ld      A,%11111110     ; select CTRL row
 307+ 05C1 CD FF 0C                     call    READKBLN        ; read row
 308+ 05C4 CB 57                        bit     2,A             ; test if CTRL key is pressed
 309+ 05C6 20 04                        jr      NZ,LVCKSPLK     ; no, leave
 310+ 05C8 AF                           xor     A               ; yes, so...
 311+ 05C9 32 12 53                     ld      (DOS_EN),A      ; ...disable DOS
 312+ 05CC F1           LVCKSPLK:       pop     AF
 313+ 05CD C9                           ret
 314+ 05CE
 315+ 05CE
 316+ 05CE              ; empty video buffer
 317+ 05CE 3A BE 52     EMPTYVIDBUF:    ld      A,(SCR_MODE)    ; check screen mode
 318+ 05D1 FE 02                        cp      $02             ; is it G2 mode?
 319+ 05D3 CA F6 05                     jp      Z,EMPTYG2       ; yes, jump over
 320+ 05D6 FE 03                        cp      $03             ; is it MC mode?
 321+ 05D8 CA 26 06                     jp      Z,EMPTYMC       ; yes, jump over
 322+ 05DB 3A BD 52                     ld      A,(SCR_SIZE_H)  ; load height of screen
 323+ 05DE 47                           ld      B,A             ; move rows into B
 324+ 05DF AF                           xor     A               ; filling char is $00
 325+ 05E0 2A C0 52                     ld      HL,(SCR_NAM_TB) ; load the name table address
 326+ 05E3 CD 5D 06                     call    SETVDPADRS      ; send address to VDP
 327+ 05E6 0D                           dec     C              ; VDP address for passing data
 328+ 05E7 5F           LDCOLSTOEMPTY:  ld      E,A             ; store filling char into E
 329+ 05E8 3A BC 52                     ld      A,(SCR_SIZE_W)  ; load # of cols to empty into A
 330+ 05EB 57                           ld      D,A             ; move A into D
 331+ 05EC 7B                           ld      A,E             ; recover filling char
 332+ 05ED ED 79        RPTEMPTYBUF:    out     (C),A           ; write empty byte into VRAM
 333+ 05EF 00                           nop
 334+ 05F0 15                           dec     D               ; decr. D
 335+ 05F1 20 FA                        jr      NZ,RPTEMPTYBUF  ; repeat for the # of cols
 336+ 05F3 10 F2                        djnz    LDCOLSTOEMPTY   ; repeat for the # of rows
 337+ 05F5 C9                           ret                     ; return to caller
 338+ 05F6 2A C0 52     EMPTYG2:        ld      HL,(SCR_NAM_TB) ; yes, additional setup for G2 - load G2 name table address (usually $1800)
 339+ 05F9 CD 4B 06                     call    SETNAMETABLE    ; set name table
 340+ 05FC 21 00 00                     ld      HL,$0000        ; set pattern table
 341+ 05FF CD 5D 06                     call    SETVDPADRS      ; send address to VDP
 342+ 0602 AF                           xor     A               ; empty pattern
 343+ 0603 16 18                        ld      D,$18           ; 6144 ($1800) cell to clean, 24 pages ($18)
 344+ 0605 47                           ld      B,A             ; 256 bytes for page
 345+ 0606 0D                           dec     C              ; VDP data mode
 346+ 0607 ED 79        CLRG2PTNTBL:    out     (C),A           ; clear pattern
 347+ 0609 00                           nop                     ; little delay
 348+ 060A 00                           nop
 349+ 060B 10 FA                        djnz    CLRG2PTNTBL     ; repeat for 1 page
 350+ 060D 15                           dec     D               ; next page
 351+ 060E 20 F7                        jr      NZ,CLRG2PTNTBL  ; repeat
 352+ 0610 21 00 20                     ld      HL,$2000        ; load the color table address
 353+ 0613 CD 5D 06                     call    SETVDPADRS      ; send address to VDP
 354+ 0616 3A CB 52                     ld      A,(FRGNDCLR)    ; load foreground
 355+ 0619 87                           add     A,A
 356+ 061A 87                           add     A,A
 357+ 061B 87                           add     A,A
 358+ 061C 87                           add     A,A             ; move to high nibble
 359+ 061D 57                           ld      D,A             ; store into D
 360+ 061E 3A CC 52                     ld      A,(BKGNDCLR)    ; load background color
 361+ 0621 B2                           or      D               ; combine with background color
 362+ 0622 16 18                        ld      D,$18           ; 6144 ($1800) cells to fill, so 24 pages ($18)
 363+ 0624 18 17                        jr      STARTEMPTY
 364+ 0626 21 00 08     EMPTYMC:        ld      HL,$0800        ; MC name table
 365+ 0629 CD 4B 06                     call    SETNAMETABLE    ; set name table
 366+ 062C 21 00 00                     ld      HL,$0000        ; color table address
 367+ 062F CD 5D 06                     call    SETVDPADRS      ; send address to VDP
 368+ 0632 3A CC 52                     ld      A,(BKGNDCLR)    ; load background
 369+ 0635 57                           ld      D,A             ; store into D
 370+ 0636 87                           add     A,A
 371+ 0637 87                           add     A,A
 372+ 0638 87                           add     A,A
 373+ 0639 87                           add     A,A             ; move to high nibble
 374+ 063A B2                           or      D               ; set background color for high and low nibble
 375+ 063B 16 08                        ld      D,$08           ; 2048 ($0800) cells to fill, so 8 pages ($08)
 376+ 063D 0E 30        STARTEMPTY:     ld      C,VDP_DAT       ; VDP address for passing data
 377+ 063F 06 00                        ld      B,$00           ; 256 bytes each page ($00=256)
 378+ 0641 ED 79        SNDCLRSET:      out     (C),A           ; send color setting
 379+ 0643 00                           nop                     ; wait a while
 380+ 0644 00                           nop
 381+ 0645 10 FA                        djnz    SNDCLRSET       ; repeat for 1 page
 382+ 0647 15                           dec     D               ; have we filled all the pages?
 383+ 0648 20 F7                        jr      NZ,SNDCLRSET    ; no, repeat
 384+ 064A C9                           ret                     ; return to caller
 385+ 064B
 386+ 064B              ; set name table for G2 mode (patterns from $00 to $FF for each of the 3 areas of the screen)
 387+ 064B CD 5D 06     SETNAMETABLE:   call    SETVDPADRS      ; send address to VDP
 388+ 064E 0D                           dec     C              ; VDP address for passing data
 389+ 064F 16 03                        ld      D,$03           ; 3 pages to fill into VRAM (768 cells)
 390+ 0651 AF                           xor     A               ; starting char name #0 (chars go from 0 to 255)
 391+ 0652 47                           ld      B,A             ; reset B
 392+ 0653 ED 79        RPTFLL1:        out     (C),A           ; send name to VRAM
 393+ 0655 00                           nop
 394+ 0656 3C                           inc     A               ; increment # of name
 395+ 0657 10 FA                        djnz    RPTFLL1         ; repeat for 256 cells (1 page)
 396+ 0659 15                           dec     D               ; did we fill all the pages?
 397+ 065A 20 F7                        jr      NZ,RPTFLL1      ; no, continue
 398+ 065C C9                           ret                     ; return to caller
 399+ 065D
 400+ 065D              ; set an address into VRAM: address is in HL - HL is changed after it
 401+ 065D 0E 31        SETVDPADRS:     ld      C,VDP_SET       ; VDP address mode
 402+ 065F CB F4                        set     6,H             ; set bit #6 of address, to write to VRAM
 403+ 0661 ED 69                        out     (C),L           ; send low and...
 404+ 0663 ED 61                        out     (C),H           ; ...high byte of the first cell
 405+ 0665 C9                           ret                     ; return to caller
 406+ 0666
 407+ 0666              ; clear the video buffer and position the cursor at 0,0
 408+ 0666 CD CE 05     CLEARVIDBUF:    call    EMPTYVIDBUF     ; clear video buffer
 409+ 0669 AF                           xor     A               ; reset A
 410+ 066A 32 C2 52                     ld      (SCR_CURS_X),A  ; cursor X to 0
 411+ 066D 32 C3 52                     ld      (SCR_CURS_Y),A  ; cursor Y to 0
 412+ 0670 C3 B9 06                     jp      POS_CURSOR      ; position cursor & return to caller
 413+ 0673
 414+ 0673              ; HOME: position the cursor at coords. 0,0
 415+ 0673 AF           ATHOME:         xor     A               ; position cursor at 0,0 by storing...
 416+ 0674 32 C5 52                     ld      (SCR_CUR_NY),A  ; ...new Y...
 417+ 0677 32 C4 52                     ld      (SCR_CUR_NX),A  ; ...and new X
 418+ 067A C3 C3 06                     jp      MOVCRS          ; move cursor to new location & return to caller
 419+ 067D
 420+ 067D              ; load the char or byte at the VRAM position set by HL
 421+ 067D              ; value is returned into A
 422+ 067D C5           READ_VIDEO_LOC: push    BC              ; store BC
 423+ 067E 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 424+ 0680 44                           ld      B,H
 425+ 0681 CB B8                        res     7,B
 426+ 0683 CB B0                        res     6,B
 427+ 0685 ED 69                        out     (C),L           ; low byte then...
 428+ 0687 ED 41                        out     (C),B           ; high byte
 429+ 0689 0D                           dec     C              ; VDP data mode
 430+ 068A 00                           nop                     ; wait...
 431+ 068B 00                           nop                     ; ...a while
 432+ 068C 00                           nop
 433+ 068D                  IFDEF LM80C64K
 434+ 068D 00                           nop
 435+ 068E                  ENDIF
 436+ 068E ED 78                        in      A,(C)           ; read byte at current VRAM location
 437+ 0690 C1                           pop     BC              ; restore BC
 438+ 0691 C9                           ret                     ; return to caller
 439+ 0692
 440+ 0692              ; write a byte at the VRAM position pointed by HL
 441+ 0692              ; value is in A
 442+ 0692 C5           WRITE_VIDEO_LOC:push    BC              ; store BC
 443+ 0693 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 444+ 0695 44                           ld      B,H             ; copy H into B
 445+ 0696 CB B8                        res     7,B
 446+ 0698 CB F0                        set     6,B             ; write to VRAM
 447+ 069A ED 69                        out     (C),L           ; low byte then...
 448+ 069C ED 41                        out     (C),B           ; high byte of VRAM address
 449+ 069E 0D                           dec     C              ; VDP data mode
 450+ 069F 00                           nop                     ; wait...
 451+ 06A0 00                           nop                     ; ...a while
 452+ 06A1 00                           nop
 453+ 06A2                  IFDEF LM80C64K
 454+ 06A2 00                           nop
 455+ 06A3                  ENDIF
 456+ 06A3 ED 79                        out     (C),A           ; write byte into VRAM
 457+ 06A5 C1                           pop     BC              ; restore BC
 458+ 06A6 C9                           ret                     ; return to caller
 459+ 06A7
 460+ 06A7              ; write a value into a specific VDP register
 461+ 06A7              ; value is in E, register is in A
 462+ 06A7 C5           WRITE_VREG:     push    BC              ; store BC
 463+ 06A8 C6 80                        add     A,$80           ; set VDP to write to registers
 464+ 06AA 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 465+ 06AC ED 59                        out     (C),E           ; send data to VDP
 466+ 06AE ED 79                        out     (C),A           ; select the destination register
 467+ 06B0 C1                           pop     BC              ; restore BC
 468+ 06B1 C9                           ret                     ; return to caller
 469+ 06B2
 470+ 06B2              ; read VDP status register and return value into A
 471+ 06B2 C5           READ_VSTAT:     push    BC              ; store BC
 472+ 06B3 0E 31                        ld      C,VDP_SET       ; VDP register access
 473+ 06B5 ED 78                        in      A,(C)           ; read status register
 474+ 06B7 C1                           pop     BC              ; restore BC
 475+ 06B8 C9                           ret                     ; return to caller
 476+ 06B9
 477+ 06B9              ; position the cursor at the current coordinates, preserving underlying char
 478+ 06B9 CD FC 06     POS_CURSOR:     call    LOAD_CRSR_POS   ; load the VRAM address of cursor into HL
 479+ 06BC CD 7D 06                     call    READ_VIDEO_LOC  ; load the current char at the cursor position (return in A)
 480+ 06BF 32 C6 52                     ld      (SCR_ORG_CHR),A ; store the current char
 481+ 06C2 C9                           ret
 482+ 06C3
 483+ 06C3              ; move cursor to new X,Y coordinates
 484+ 06C3 CD F3 06     MOVCRS:         call    RSTCHRCRS       ; restore the char in the current cursor position
 485+ 06C6 CD DE 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 486+ 06C9 CD B9 06     MOVSHOWCRS:     call    POS_CURSOR      ; position cursor into new location
 487+ 06CC 3A C7 52                     ld      A,(CRSR_STATE)  ; load status of cursor
 488+ 06CF A7                           and     A               ; is cursor off?
 489+ 06D0 C8                           ret     Z               ; yes, return
 490+ 06D1 3A AC 52                     ld      A,(TMRCNT)      ; load timer
 491+ 06D4 E6 20                        and     $20             ; check status of cursor flashing
 492+ 06D6 32 C8 52                     ld      (LSTCSRSTA),A   ; store the last cursor state
 493+ 06D9 3E FF                        ld      A,$FF           ; BTW, set cursor visible after moved it
 494+ 06DB C3 92 06                     jp      WRITE_VIDEO_LOC ; write into video cell
 495+ 06DE
 496+ 06DE
 497+ 06DE              ; set new cursor's coordinates:
 498+ 06DE 3A C4 52     NEWCRSRCOORD:   ld      A,(SCR_CUR_NX)  ; load new X
 499+ 06E1 32 C2 52                     ld      (SCR_CURS_X),A  ; write new X
 500+ 06E4 3A C5 52                     ld      A,(SCR_CUR_NY)  ; load new Y
 501+ 06E7 32 C3 52                     ld      (SCR_CURS_Y),A  ; write new Y
 502+ 06EA 3E FF                        ld      A,$FF           ; delete new values
 503+ 06EC 32 C4 52                     ld      (SCR_CUR_NX),A  ; of X
 504+ 06EF 32 C5 52                     ld      (SCR_CUR_NY),A  ; and Y
 505+ 06F2 C9                           ret
 506+ 06F3
 507+ 06F3              ; recover char under the cursor and prints it onto the screen
 508+ 06F3 CD FC 06     RSTCHRCRS:      call    LOAD_CRSR_POS   ; recover old cursor position
 509+ 06F6 3A C6 52                     ld      A,(SCR_ORG_CHR) ; recover old char
 510+ 06F9 C3 92 06                     jp      WRITE_VIDEO_LOC ; write char into VRAM & return
 511+ 06FC
 512+ 06FC              ; retrieve cursor position from either current coordinates or next place
 513+ 06FC              ; return address position into HL
 514+ 06FC 3A C3 52     LOAD_CRSR_POS:  ld      A,(SCR_CURS_Y)  ; load cursor Y
 515+ 06FF 6F                           ld      L,A             ; move it into reg.L
 516+ 0700 AF                           xor     A               ; reset A
 517+ 0701 67                           ld      H,A             ; reset H
 518+ 0702 47                           ld      B,A             ; reset B
 519+ 0703 29                           add     HL,HL           ; create offset (each address is 2-bytes long so we need to double HL)
 520+ 0704 11 5B 0A                     ld      DE,POS_TB_CRS_40; load position table address of cursor for 40 cols
 521+ 0707 3A BC 52                     ld      A,(SCR_SIZE_W)  ; load screen width
 522+ 070A FE 28                        cp      $28             ; is it 40 cols?
 523+ 070C 28 03                        jr      Z,CONT_POS_CURS ; yes, jump over
 524+ 070E 11 2B 0A                     ld      DE,POS_TB_CRS_32; no, load position table address of cursor for 32 cols
 525+ 0711 19           CONT_POS_CURS:  add     HL,DE           ; the correct starting address of the required row is now into HL
 526+ 0712 5E                           ld      E,(HL)          ; load starting address of the required row into DE
 527+ 0713 23                           inc     HL
 528+ 0714 56                           ld      D,(HL)
 529+ 0715 2A C0 52                     ld      HL,(SCR_NAM_TB) ; load starting address of name table
 530+ 0718 19                           add     HL,DE           ; starting address of the current row into name table
 531+ 0719 3A C2 52                     ld      A,(SCR_CURS_X)  ; load cursor X
 532+ 071C 4F                           ld      C,A             ; transfer A into C
 533+ 071D 09                           add     HL,BC           ; add X offset: now HL contains the address of the current cursor position
 534+ 071E C9                           ret
 535+ 071F
 536+ 071F              ; find X,Y coordinates of a screen address pointed in VRAM by HL
 537+ 071F              ; return them into L,A for X,Y
 538+ 071F D5           HL2XY:          push    DE              ; store DE
 539+ 0720 ED 5B C0 52                  ld      DE,(SCR_NAM_TB) ; load starting address of name table into DE
 540+ 0724 AF                           xor     A               ; clear Carry
 541+ 0725 ED 52                        sbc     HL,DE           ; find position relative to screen (from 0,0)
 542+ 0727 D1                           pop     DE
 543+ 0728 3A BC 52                     ld      A,(SCR_SIZE_W)  ; load screen width
 544+ 072B 4F                           ld      C,A             ; move it into C
 545+ 072C CD C7 3F                     call    DIV_16_8        ; divide position by C: return Y into L and X into A
 546+ 072F C9                           ret                     ; return to caller
 547+ 0730
 548+ 0730              ;-------------------------------------------------------------------------------
 549+ 0730              ; char table for jumps
 550+ 0730 19           CHRTBL:         defb    HOME
 551+ 0731 73 06                        defw    ATHOME          ; move the cursor to 0,0
 552+ 0733
 553+ 0733 0C                           defb    CS
 554+ 0734 66 06                        defw    CLEARVIDBUF     ; clear video buffer and position cursor at 0,0
 555+ 0736
 556+ 0736 0D                           defb    CR
 557+ 0737 7E 09                        defw    CRGRETURN       ; go to the beginning of the next line
 558+ 0739
 559+ 0739 08                           defb    BKSP
 560+ 073A 1D 08                        defw    BACKSPACE       ; move cursor left 1 position
 561+ 073C
 562+ 073C 1C                           defb    CRSLFT
 563+ 073D 30 08                        defw    CURSORLEFT      ; move cursor left
 564+ 073F
 565+ 073F 1E                           defb    CRSUP
 566+ 0740 7C 08                        defw    CURSORUP        ; move cursor up
 567+ 0742
 568+ 0742 1D                           defb    CRSRGT
 569+ 0743 95 08                        defw    CURSORRIGHT     ; move cursor right
 570+ 0745
 571+ 0745 1F                           defb    CRSDN
 572+ 0746 CA 08                        defw    CURSORDOWN      ; move cursor up
 573+ 0748
 574+ 0748 1A                           defb    INSRT
 575+ 0749 DC 07                        defw    INSERTKEY       ; insert a space
 576+ 074B
 577+ 074B 0A                           defb    LF
 578+ 074C B7 07                        defw    PLACEHOLDER     ; CURRENTLY WE DON'T PRINT LINE FEED
 579+ 074E
 580+ 074E              ; send current char to video buffer
 581+ 074E F5           CHAR2VID:       push    AF              ; store AF
 582+ 074F C5                           push    BC              ; store BC
 583+ 0750 D5                           push    DE              ; store DE
 584+ 0751 E5                           push    HL              ; store HL
 585+ 0752 3A C7 52                     ld      A,(CRSR_STATE)  ; store cursor state...
 586+ 0755 F5                           push    AF              ; into stack
 587+ 0756 CD FF 08                     call    CURSOR_OFF      ; cursor off
 588+ 0759 3A CA 52                     ld      A,(CHR4VID)     ; recover char
 589+ 075C 06 0A                        ld      B,$0A           ; 10 chars to check
 590+ 075E 21 30 07                     ld      HL,CHRTBL       ; address of key table
 591+ 0761 BE           RPTCPCK:        cp      (HL)            ; compare with char
 592+ 0762 23                           inc     HL              ; beginning of sub-routine address
 593+ 0763 20 09                        jr      NZ,NXTCPCK      ; different, go to next char
 594+ 0765 5E                           ld      E,(HL)          ; load addres into DE
 595+ 0766 23                           inc     HL
 596+ 0767 56                           ld      D,(HL)
 597+ 0768 EB                           ex      DE,HL           ; move user routine's address into HL
 598+ 0769 11 AA 07                     ld      DE,EXITCHAR2VID ; set point of return after the user routine
 599+ 076C D5                           push    DE              ; store into stack
 600+ 076D E9                           jp      (HL)            ; call user routine - then, the CPU will return (jump) to EXITCHAR2VID
 601+ 076E 23           NXTCPCK:        inc     HL              ; jump over 2 cells...
 602+ 076F 23                           inc     HL              ; ...to the next char code
 603+ 0770 10 EF                        djnz    RPTCPCK         ; repeat
 604+ 0772                              ; it'a not a special char, just print it
 605+ 0772 CD FC 06                     call    LOAD_CRSR_POS   ; recover position of cursor
 606+ 0775 3A CA 52                     ld      A,(CHR4VID)     ; recover char to print
 607+ 0778 CD 92 06                     call    WRITE_VIDEO_LOC ; write A into VRAM at (HL)
 608+ 077B 3A C3 52                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 609+ 077E 5F                           ld      E,A             ; store cursor Y into E
 610+ 077F 3A C2 52                     ld      A,(SCR_CURS_X)  ; load cursor X
 611+ 0782 3C                           inc     A               ; move 1 step to right
 612+ 0783 21 BC 52                     ld      HL,SCR_SIZE_W   ; cell that keeps the width of screen
 613+ 0786 BE                           cp      (HL)            ; have we reached the most right position?
 614+ 0787 20 0F                        jr      NZ,SETCSRCOORDS ; no, go over
 615+ 0789 1C                           inc     E               ; yes, increment cursor Y (go to next line)
 616+ 078A 7B                           ld      A,E             ; move cursor Y into A
 617+ 078B 21 BD 52                     ld      HL,SCR_SIZE_H   ; cell that keeps the height of screen
 618+ 078E BE                           cp      (HL)            ; have we reached the bottom of the screen?
 619+ 078F 20 06                        jr      NZ,SETCRSRY     ; no, jump over
 620+ 0791 D5                           push    DE
 621+ 0792 CD 06 09                     call    SCROLLUP        ; scroll screen up
 622+ 0795 D1                           pop     DE
 623+ 0796 1D                           dec     E               ; decrement 1 row, to set cursor Y on the last line
 624+ 0797 AF           SETCRSRY:       xor     A               ; then set cursor X to 0 (go to beginning of line)
 625+ 0798 32 C2 52     SETCSRCOORDS:   ld      (SCR_CURS_X),A  ; store current cursor X
 626+ 079B 7B                           ld      A,E             ; recover Y
 627+ 079C 32 C3 52                     ld      (SCR_CURS_Y),A  ; store current cursor Y
 628+ 079F CD B9 06                     call    POS_CURSOR      ; position cursor into new location
 629+ 07A2 3A AC 52                     ld      A,(TMRCNT)      ; load status of cursor flashing
 630+ 07A5 E6 20                        and     $20             ; check cursor state
 631+ 07A7 32 C8 52                     ld      (LSTCSRSTA),A   ; store the last cursor state
 632+ 07AA AF           EXITCHAR2VID:   xor     A               ; reset char
 633+ 07AB 32 CA 52                     ld      (CHR4VID),A     ; to be sent to screen
 634+ 07AE F1                           pop     AF              ; recover cursor state
 635+ 07AF A7                           and     A               ; was it off (A=0)?
 636+ 07B0 C4 EA 08                     call    NZ,CURSOR_ON    ; no, set cursor on
 637+ 07B3 E1                           pop     HL              ; restore HL
 638+ 07B4 D1                           pop     DE              ; restore DE
 639+ 07B5 C1                           pop     BC              ; restore BC
 640+ 07B6 F1                           pop     AF              ; restore AF
 641+ 07B7 C9           PLACEHOLDER:    ret                     ; return to caller
 642+ 07B8
 643+ 07B8              ; flash the cursor at the current position
 644+ 07B8              ; (this sub-routine is called by CH3 timer ISR)
 645+ 07B8 3A C7 52     FLASHCURSOR:    ld      A,(CRSR_STATE)  ; now, check the cursor
 646+ 07BB A7                           and     A               ; cursor off (A=0)?
 647+ 07BC C8                           ret     Z               ; yes, return
 648+ 07BD 3A AC 52                     ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
 649+ 07C0 E6 20                        and     $20             ; check if it's time to flash the cursor (check bit #6)
 650+ 07C2 21 C8 52                     ld      HL,LSTCSRSTA    ; load address of cell that stores the last cursor state
 651+ 07C5 46                           ld      B,(HL)          ; load last state
 652+ 07C6 B8                           cp      B               ; compare current state with last state
 653+ 07C7 C8                           ret     Z               ; same state, no change required - exit
 654+ 07C8 77                           ld      (HL),A          ; save new state
 655+ 07C9 F5                           push    AF              ; store A (keep state for later use)
 656+ 07CA CD FC 06                     call    LOAD_CRSR_POS   ; load current cursor position into HL
 657+ 07CD F1                           pop     AF              ; recover current state
 658+ 07CE 06 FF                        ld      B,$FF           ; cursor char
 659+ 07D0 FE 20                        cp      $20             ; is the cursor on video (A == $20)?
 660+ 07D2 28 04                        jr      Z,PUTCRSCHR     ; yes, jump over
 661+ 07D4 3A C6 52                     ld      A,(SCR_ORG_CHR) ; no, load the original char
 662+ 07D7 47                           ld      B,A             ; move char into B
 663+ 07D8 78           PUTCRSCHR:      ld      A,B             ; recover char from B
 664+ 07D9 C3 92 06                     jp      WRITE_VIDEO_LOC ; print cursor/char at the current position & return
 665+ 07DC
 666+ 07DC
 667+ 07DC              ; insert an empty space at the current position of the cursor, moving the following text
 668+ 07DC              ; 1 cell straight
 669+ 07DC CD F3 06     INSERTKEY:      call    RSTCHRCRS       ; restore char under the cursor
 670+ 07DF CD FC 06                     call    LOAD_CRSR_POS   ; retrieve address of cursor cell
 671+ 07E2 22 CD 52                     ld      (CUR_POS),HL    ; store it
 672+ 07E5 CD 05 0A                     call    ENDOFLN         ; find address of first free cell after the end of the text from the current cursor position - address into HL -
 673+ 07E8                                                      ; DE is the address of the bottom right cell of the screen
 674+ 07E8 22 D1 52                     ld      (ENDTXT),HL     ; store it
 675+ 07EB ED 4B CD 52                  ld      BC,(CUR_POS)    ; load starting address
 676+ 07EF AF                           xor     A
 677+ 07F0 ED 42                        sbc     HL,BC           ; how many positions to move?
 678+ 07F2 CA C9 06                     jp      Z,MOVSHOWCRS    ; none - leave and re-place cursor
 679+ 07F5 44 4D                        ld      BC,HL           ; number of chars to scroll into BC
 680+ 07F7 2A D1 52                     ld      HL,(ENDTXT)     ; load address of the end of text
 681+ 07FA 2B           CHKHL:          dec     HL              ; decrement to find the address of the char to move
 682+ 07FB E5                           push    HL
 683+ 07FC CD 88 3F                     call    CMP16           ; is it the last cell (bottom right) of screen?
 684+ 07FF E1                           pop     HL
 685+ 0800 D2 0B 08                     jp      NC,NXTINST      ; yes, so jump over - nothing to do
 686+ 0803 CD 7D 06                     call    READ_VIDEO_LOC  ; no, so read current char
 687+ 0806 23                           inc     HL              ; next cell
 688+ 0807 CD 92 06                     call    WRITE_VIDEO_LOC ; write into new position
 689+ 080A 2B                           dec     HL              ; decrement to old position
 690+ 080B 0B           NXTINST:        dec     BC              ; decrement number of chars to move
 691+ 080C 79                           ld      A,C
 692+ 080D B0                           or      B               ; finished?
 693+ 080E 20 EA                        jr      NZ,CHKHL        ; no, repeat
 694+ 0810 AF           ENDINSRT:       xor     A
 695+ 0811 2A CD 52                     ld      HL,(CUR_POS)
 696+ 0814 32 C6 52                     ld      (SCR_ORG_CHR),A ; reset original char under the cursor
 697+ 0817 CD 92 06                     call    WRITE_VIDEO_LOC ; empty current video location
 698+ 081A C3 C9 06                     jp      MOVSHOWCRS      ; re-place cursor
 699+ 081D
 700+ 081D              ; delete the char at the left of the cursor
 701+ 081D CD 59 08     BACKSPACE:      call    MVCRS2LFT       ; prepare to move cursor to left
 702+ 0820 CD F3 06                     call    RSTCHRCRS       ; restore char under the cursor
 703+ 0823 CD DE 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 704+ 0826 CD FC 06                     call    LOAD_CRSR_POS   ; find address of new video cell
 705+ 0829 AF                           xor     A               ; null char
 706+ 082A CD 92 06                     call    WRITE_VIDEO_LOC ; write into video cell
 707+ 082D C3 C9 06                     jp      MOVSHOWCRS      ; move cursor to the new location and set it ON
 708+ 0830
 709+ 0830
 710+ 0830              ; move cursor to left
 711+ 0830 F5           CURSORLEFT:     push    AF              ; store A
 712+ 0831 3A C2 52                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 713+ 0834 A7                           and     A               ; is it at the most left of the screen (X=0)?
 714+ 0835 28 0C                        jr      Z,CHCKYPOS      ; yes, check Y position
 715+ 0837 3D                           dec     A               ; no, decrement X
 716+ 0838 32 C4 52                     ld      (SCR_CUR_NX),A  ; store new X
 717+ 083B 3A C3 52                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 718+ 083E 32 C5 52                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 719+ 0841 18 11                        jr      CONTCRSLFT      ; go on moving cursor
 720+ 0843 3A C3 52     CHCKYPOS:       ld      A,(SCR_CURS_Y)  ; load cursor Y
 721+ 0846 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 722+ 0847 28 0E                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 723+ 0849 3D                           dec     A               ; no, decrement Y
 724+ 084A 32 C5 52                     ld      (SCR_CUR_NY),A  ; store new Y
 725+ 084D 3A BC 52                     ld      A,(SCR_SIZE_W)  ; load current screen width
 726+ 0850 3D                           dec     A               ; cursor to the most right position (width-0)
 727+ 0851 32 C4 52                     ld      (SCR_CUR_NX),A  ; set new cursor X
 728+ 0854 CD C3 06     CONTCRSLFT:     call    MOVCRS          ; move cursor into new position
 729+ 0857 F1           EXITCURSORLEFT: pop     AF              ; restore A
 730+ 0858 C9                           ret                     ; return to caller
 731+ 0859
 732+ 0859              ; move cursor 1 position to the left
 733+ 0859 3A C2 52     MVCRS2LFT:      ld      A,(SCR_CURS_X)  ; load cursor X into A
 734+ 085C A7                           and     A               ; is it at the most left of the screen (X=0)?
 735+ 085D 28 0B                        jr      Z,CHKYPOS       ; yes, check Y position
 736+ 085F 3D                           dec     A               ; no, decrement X
 737+ 0860 32 C4 52                     ld      (SCR_CUR_NX),A  ; store new X
 738+ 0863 3A C3 52                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 739+ 0866 32 C5 52                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 740+ 0869 C9                           ret                     ; go on moving cursor
 741+ 086A 3A C3 52     CHKYPOS:        ld      A,(SCR_CURS_Y)  ; load cursor Y
 742+ 086D A7                           and     A               ; is it at the most top of the screen (Y=0)?
 743+ 086E 28 E7                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 744+ 0870 3D                           dec     A               ; no, decrement Y
 745+ 0871 32 C5 52                     ld      (SCR_CUR_NY),A  ; store new Y
 746+ 0874 3A BC 52                     ld      A,(SCR_SIZE_W)  ; load current screen width
 747+ 0877 3D                           dec     A               ; cursor to the most right position (width-1)
 748+ 0878 32 C4 52                     ld      (SCR_CUR_NX),A  ; set new cursor X
 749+ 087B C9                           ret                     ; return to caller
 750+ 087C
 751+ 087C              ; move cursor up
 752+ 087C F5           CURSORUP:       push    AF              ; store A
 753+ 087D 3A C3 52                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 754+ 0880 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 755+ 0881 28 10                        jr      Z,EXITCURSORUP  ; yes, exit doing nothing
 756+ 0883 3D                           dec     A               ; no, decrement Y
 757+ 0884 32 C5 52                     ld      (SCR_CUR_NY),A  ; store new Y
 758+ 0887 3A C2 52                     ld      A,(SCR_CURS_X)  ; load current cursor X
 759+ 088A 32 C4 52                     ld      (SCR_CUR_NX),A  ; set new cursor X
 760+ 088D CD F3 06                     call    RSTCHRCRS       ; restore char under the cursor and print it
 761+ 0890 CD C3 06                     call    MOVCRS          ; move cursor into new position
 762+ 0893 F1           EXITCURSORUP:   pop     AF              ; restore A
 763+ 0894 C9                           ret                     ; return to caller
 764+ 0895
 765+ 0895
 766+ 0895              ; move cursor to right
 767+ 0895 F5           CURSORRIGHT:    push    AF              ; store A
 768+ 0896 C5                           push    BC              ; store B
 769+ 0897 3A BC 52                     ld      A,(SCR_SIZE_W)  ; load current screen width (in text modes it's 32 or 40)
 770+ 089A 3D                           dec     A               ; decrement it (most right can only be 31 or 39)
 771+ 089B 47                           ld      B,A             ; move A into B
 772+ 089C 3A C2 52                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 773+ 089F B8                           cp      B               ; is cursor at the most right position on the screen?
 774+ 08A0 30 0C                        jr      NC,CHCKYPOS2    ; yes, so jump to check Y position
 775+ 08A2 3C                           inc     A               ; no, so increment X
 776+ 08A3 32 C4 52                     ld      (SCR_CUR_NX),A  ; store new X
 777+ 08A6 3A C3 52                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 778+ 08A9 32 C5 52                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 779+ 08AC 18 13                        jr      CONTCRSRGT      ; go on moving cursor
 780+ 08AE 3A BD 52     CHCKYPOS2:      ld      A,(SCR_SIZE_H)  ; load screen height
 781+ 08B1 3D                           dec     A               ; decrement it (last row can only be 23)
 782+ 08B2 47                           ld      B,A             ; move bottom into B
 783+ 08B3 3A C3 52                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 784+ 08B6 B8                           cp      B               ; is the cursor at the bottom of the screen?
 785+ 08B7 30 0E                        jr      NC,EXITCURSORRGHT; yes, exit doing nothing
 786+ 08B9 3C                           inc     A               ; no, increment Y
 787+ 08BA 32 C5 52                     ld      (SCR_CUR_NY),A  ; store new Y
 788+ 08BD AF                           xor     A               ; move cursor to top left
 789+ 08BE 32 C4 52                     ld      (SCR_CUR_NX),A  ; store new X
 790+ 08C1 CD F3 06     CONTCRSRGT:     call    RSTCHRCRS       ; restore char under the cursor and print it
 791+ 08C4 CD C3 06                     call    MOVCRS          ; move cursor into new position
 792+ 08C7 C1           EXITCURSORRGHT: pop     BC              ; retrieve BC
 793+ 08C8 F1                           pop     AF              ; restore A
 794+ 08C9 C9                           ret                     ; return to caller
 795+ 08CA
 796+ 08CA
 797+ 08CA              ; move cursor down
 798+ 08CA F5           CURSORDOWN:     push    AF              ; store A
 799+ 08CB C5                           push    BC              ; store B
 800+ 08CC 3A BD 52                     ld      A,(SCR_SIZE_H)  ; load current screen height (in text modes it's 24)
 801+ 08CF 3D                           dec     A               ; decrement it (positions can only vary between 0 and 23)
 802+ 08D0 47                           ld      B,A             ; move X into B
 803+ 08D1 3A C3 52                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 804+ 08D4 B8                           cp      B               ; is current cursor position < 23?
 805+ 08D5 30 10                        jr      NC,EXITCURSORDOWN; no, exit doing nothing
 806+ 08D7 3C                           inc     A               ; yes, increment Y
 807+ 08D8 32 C5 52                     ld      (SCR_CUR_NY),A  ; store new Y
 808+ 08DB 3A C2 52                     ld      A,(SCR_CURS_X)  ; load current cursor X
 809+ 08DE 32 C4 52                     ld      (SCR_CUR_NX),A  ; set new cursor X
 810+ 08E1 CD F3 06                     call    RSTCHRCRS       ; restore char under the cursor and print it
 811+ 08E4 CD C3 06                     call    MOVCRS          ; move cursor into new position
 812+ 08E7 C1           EXITCURSORDOWN: pop     BC              ; retrieve BC
 813+ 08E8 F1                           pop     AF              ; retrieve A
 814+ 08E9 C9                           ret                     ; return to caller
 815+ 08EA
 816+ 08EA
 817+ 08EA              ; set cursor on (visible on screen)
 818+ 08EA F5           CURSOR_ON:      push    AF              ; store AF
 819+ 08EB 3A C7 52                     ld      A,(CRSR_STATE)  ; load cursor state
 820+ 08EE B7                           or      A               ; is it on?
 821+ 08EF 20 0C                        jr      NZ,EXITCURSOR_ON; yes, so nothing to do
 822+ 08F1 3A BD 52                     ld      A,(SCR_SIZE_H)  ; check the video mode
 823+ 08F4 FE 30                        cp      $30             ; graphics 2 or 3 (if value>=48)?
 824+ 08F6 30 05                        jr      NC,EXITCURSOR_ON; yes, so exit (no cursor in graphics 2 or 3)
 825+ 08F8 3E 01                        ld      A,$01           ; cursor state ON
 826+ 08FA 32 C7 52                     ld      (CRSR_STATE),A  ; set state
 827+ 08FD F1           EXITCURSOR_ON:  pop     AF              ; restore AF
 828+ 08FE C9                           ret                     ; return to caller
 829+ 08FF
 830+ 08FF              ; set cursor off (invisible on screen)
 831+ 08FF F5           CURSOR_OFF:     push    AF              ; store AF
 832+ 0900 AF                           xor     A               ; cursor state OFF
 833+ 0901 32 C7 52                     ld      (CRSR_STATE),A  ; set state
 834+ 0904 F1                           pop     AF              ; restore AF
 835+ 0905 C9                           ret
 836+ 0906
 837+ 0906              ; scroll the screen 1 row up
 838+ 0906 AF           SCROLLUP:       xor     A
 839+ 0907 32 C9 52                     ld      (PRNTVIDEO),A
 840+ 090A 2A C0 52                     ld      HL,(SCR_NAM_TB) ; start address of the name table
 841+ 090D 22 FD 52                     ld      (VIDTMP1),HL    ; store address of the destination row (1st row of the screen)
 842+ 0910 3A BC 52                     ld      A,(SCR_SIZE_W)  ; load the screen width
 843+ 0913 5F                           ld      E,A             ; move width into E
 844+ 0914 16 00                        ld      D,$00           ; reset D
 845+ 0916 19                           add     HL,DE           ; HL now contains the address of the source row (2nd row of the screen)
 846+ 0917 22 FF 52                     ld      (VIDTMP2),HL    ; store address of source row
 847+ 091A 3A BD 52                     ld      A,(SCR_SIZE_H)  ; load the screen height
 848+ 091D 3D                           dec     A               ; decrement the # of rows: now, A contains the # of rows to be moved
 849+ 091E 47                           ld      B,A             ; move # of rows into B
 850+ 091F 3A BC 52     SCROLLNXTRW:    ld      A,(SCR_SIZE_W)  ; (re)load the screen width
 851+ 0922 5F                           ld      E,A             ; move width into E
 852+ 0923 2A FF 52                     ld      HL,(VIDTMP2)    ; load source address
 853+ 0926 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 854+ 0928 ED 69                        out     (C),L           ; low byte of source
 855+ 092A ED 61                        out     (C),H           ; high byte of source
 856+ 092C 21 D5 52                     ld      HL,VIDEOBUFF    ; load address of the first cell of the video buffer
 857+ 092F 0D                           dec     C              ; VDP data mode
 858+ 0930 ED 78        LOADNEXTCOL:    in      A,(C)           ; load char
 859+ 0932 77                           ld      (HL),A          ; store char
 860+ 0933 23                           inc     HL              ; next cell of the buffer
 861+ 0934 1D                           dec     E               ; count the chars to be read
 862+ 0935 20 F9                        jr      NZ,LOADNEXTCOL  ; repeat until we read the entire row
 863+ 0937 3A BC 52                     ld      A,(SCR_SIZE_W)  ; reload the screen width
 864+ 093A 5F                           ld      E,A             ; move # of rows into E
 865+ 093B 16 00                        ld      D,$00           ; reset D
 866+ 093D 2A FD 52                     ld      HL,(VIDTMP1)    ; load address of destination row
 867+ 0940 E5                           push    HL              ; store HL
 868+ 0941 2A FF 52                     ld      HL,(VIDTMP2)    ; current source will be..
 869+ 0944 22 FD 52                     ld      (VIDTMP1),HL    ; ..new destination
 870+ 0947 19                           add     HL,DE           ; address of new
 871+ 0948 22 FF 52                     ld      (VIDTMP2),HL    ; source row
 872+ 094B E1                           pop     HL              ; restore address of current destination row
 873+ 094C CB F4                        set     6,H             ; writing mode
 874+ 094E 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 875+ 0950 ED 69                        out     (C),L           ; low byte
 876+ 0952 ED 61                        out     (C),H           ; high byte of address
 877+ 0954 21 D5 52                     ld      HL,VIDEOBUFF    ; video buffer address
 878+ 0957 0D                           dec     C              ; VDP data mode
 879+ 0958 7E           WRITEBUF:       ld      A,(HL)          ; load char
 880+ 0959 ED 79                        out     (C),A           ; send char
 881+ 095B 23                           inc     HL              ; increment buffer index
 882+ 095C 1D                           dec     E               ; next row
 883+ 095D 20 F9                        jr      NZ,WRITEBUF     ; repeat until 0
 884+ 095F 10 BE                        djnz    SCROLLNXTRW     ; repeat for the entire screen
 885+ 0961 3A BC 52                     ld      A,(SCR_SIZE_W)  ; reload screen width
 886+ 0964 47                           ld      B,A             ; cells to empty into B
 887+ 0965 AF                           xor     A               ; null char
 888+ 0966 0E 31                        ld      C,VDP_SET       ; VDP set mode
 889+ 0968 2A FD 52                     ld      HL,(VIDTMP1)    ; load address of the last row
 890+ 096B CB F4                        set     6,H             ; writing mode
 891+ 096D ED 69                        out     (C),L           ; low byte then..
 892+ 096F ED 61                        out     (C),H           ; high byte of address
 893+ 0971 0D                           dec     C              ; VDP data mode
 894+ 0972 ED 79        RPTEMPTYROW:    out     (C),A           ; empty cell
 895+ 0974 00                           nop                     ; delay
 896+ 0975 00                           nop
 897+ 0976 10 FA                        djnz    RPTEMPTYROW     ; repeat until the last row has been cleaned
 898+ 0978 3E 01                        ld      A,$01
 899+ 097A 32 C9 52                     ld      (PRNTVIDEO),A   ; set print-on-video on
 900+ 097D C9                           ret                     ; return to caller
 901+ 097E
 902+ 097E              ; carriage return: first, it looks for char $00 at the beginning of the line (look for the first null char),
 903+ 097E              ; then it starts sendind every char it finds on the screen to the terminal buffer of the BASIC interpreter
 904+ 097E              ; until another null char is found. Finally, move to the next line and position the cursor at the beginning
 905+ 097E              ; of the row (equivalent to CR+LF), then gets back control to the screen editor to let it interpret the line
 906+ 097E              CUR_POS         equ     TMPBFR1         ; cursor position
 907+ 097E              SRTTXT          equ     TMPBFR2         ; start of text line
 908+ 097E              ENDTXT          equ     TMPBFR3         ; end of text line
 909+ 097E              CRGRETURN:      ; preliminary: disable cursor if on, and retrieve char under it
 910+ 097E 3A C7 52                     ld      A,(CRSR_STATE)  ; recover cursor state
 911+ 0981 32 D3 52                     ld      (TMPBFR4),A     ; store status
 912+ 0984 A7                           and     A               ; is cursor on?
 913+ 0985 C4 FF 08                     call    NZ,CURSOR_OFF   ; yes, so set cursor off
 914+ 0988 CD F3 06                     call    RSTCHRCRS       ; restore char under it
 915+ 098B                              ; first, check if cursor if off, so that we just interpret return as a new line command
 916+ 098B 3A 07 53                     ld      A,(KBDNPT)      ; check if input from keyboad
 917+ 098E A7                           and     A               ; if 0, input is not from keyboard...
 918+ 098F CA E4 09                     jp      Z,PRNTRETURN    ; ...so just print a carriage return; otherwise, interpret the return
 919+ 0992                              ; first part: look for the beginning of the text line on screen
 920+ 0992 CD FC 06                     call    LOAD_CRSR_POS   ; load cursor position into HL
 921+ 0995 22 CD 52                     ld      (CUR_POS),HL    ; store it
 922+ 0998 ED 5B C0 52                  ld      DE,(SCR_NAM_TB) ; load VRAM address of top-left cell of screen ("home")
 923+ 099C E5           RPTNLLSRC:      push    HL
 924+ 099D CD 88 3F                     call    CMP16           ; check if at "home"
 925+ 09A0 E1                           pop     HL
 926+ 09A1 CA AC 09                     jp      Z,CNTNULL       ; yes, exit because there is nothing before
 927+ 09A4 2B                           dec     HL              ; go 1 step back
 928+ 09A5 CD 7D 06                     call    READ_VIDEO_LOC  ; read char of current position
 929+ 09A8 A7                           and     A               ; is it $00 (null char)?
 930+ 09A9 20 F1                        jr      NZ,RPTNLLSRC    ; no, continue searching
 931+ 09AB 23                           inc     HL              ; move 1 step forward to go back to the last cell with something in
 932+ 09AC                              ; second part: look for the ending of the text on screen
 933+ 09AC 22 CF 52     CNTNULL:        ld      (SRTTXT),HL     ; store beginning of text
 934+ 09AF CD 05 0A                     call    ENDOFLN         ; find end of text line looking at the end of chars after the cursor position
 935+ 09B2 22 D1 52                     ld      (ENDTXT),HL     ; store ending of text line
 936+ 09B5 ED 5B CF 52                  ld      DE,(SRTTXT)     ; load beginning of text line
 937+ 09B9 A7                           and     A               ; clear Carry
 938+ 09BA ED 52                        sbc     HL,DE           ; how many chars?
 939+ 09BC 28 26                        jr      Z,PRNTRETURN    ; no chars found (HL-DE=0), so just print return & leave
 940+ 09BE                              ;---    central part: send the text on the screen to the interpreter
 941+ 09BE 2A CF 52                     ld      HL,(SRTTXT)     ; load beginning of text line
 942+ 09C1 ED 5B D1 52                  ld      DE,(ENDTXT)     ; load ending of text line
 943+ 09C5 CD 7D 06     SNDCHRTOBFR:    call    READ_VIDEO_LOC  ; read char
 944+ 09C8 E5                           push    HL
 945+ 09C9 CD F4 01                     call    CHARINTOBFR     ; send char to buffer
 946+ 09CC E1                           pop     HL
 947+ 09CD 23                           inc     HL              ; go to next char
 948+ 09CE E5                           push    HL              ; store HL
 949+ 09CF CD 88 3F                     call    CMP16           ; check if DE=HL (finish chars)
 950+ 09D2 E1                           pop     HL
 951+ 09D3 20 F0                        jr      NZ,SNDCHRTOBFR  ; no, repeat
 952+ 09D5 3E 0D                        ld      A,CR            ; yes, so now send carriage return
 953+ 09D7 CD F4 01                     call    CHARINTOBFR     ; send to buffer
 954+ 09DA 2A D1 52                     ld      HL,(ENDTXT)     ; recover address of last char of input text
 955+ 09DD CD 1F 07                     call    HL2XY           ; retrieve X,Y from address
 956+ 09E0 7D                           ld      A,L             ; move Y into A (we don't need X anymore)
 957+ 09E1 32 C3 52                     ld      (SCR_CURS_Y),A  ; store new Y
 958+ 09E4                              ;---    final part: go at the beginning of a new line on the screen
 959+ 09E4 AF           PRNTRETURN:     xor     A               ; move to col 0
 960+ 09E5 32 C2 52                     ld      (SCR_CURS_X),A  ; store new X
 961+ 09E8 3A C3 52                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 962+ 09EB 3C                           inc     A               ; new row
 963+ 09EC 21 BD 52                     ld      HL,SCR_SIZE_H   ; load address of cell that keeps screen height
 964+ 09EF BE                           cp      (HL)            ; is the cursor over the bottom of the screen?
 965+ 09F0 38 06                        jr      C,ADDNEWLINE    ; no, jump over
 966+ 09F2 3D                           dec     A               ; yes, so come back 1 row, then...
 967+ 09F3 F5                           push    AF              ; (store A)
 968+ 09F4 CD 06 09                     call    SCROLLUP        ; ...scroll the screen before to...
 969+ 09F7 F1                           pop     AF              ; (retrieve A)
 970+ 09F8 32 C3 52     ADDNEWLINE:     ld      (SCR_CURS_Y),A  ; ...store new Y
 971+ 09FB 3A D3 52                     ld      A,(TMPBFR4)     ; retrieve cursor state
 972+ 09FE A7                           and     A               ; was it off (A=0)?
 973+ 09FF C4 EA 08                     call    NZ,CURSOR_ON    ; no, set cursor on
 974+ 0A02 C3 B9 06                     jp      POS_CURSOR      ; position cursor to new location & return to caller
 975+ 0A05
 976+ 0A05              ; find end of text line
 977+ 0A05              ; destroys A, DE, and HL - store address of last char of text line into HL,
 978+ 0A05              ; while DE contains the address of the bottom right cell of the screen
 979+ 0A05 3A BD 52     ENDOFLN:        ld      A,(SCR_SIZE_H)
 980+ 0A08 5F                           ld      E,A             ; load screen height into DE
 981+ 0A09 3A BC 52                     ld      A,(SCR_SIZE_W)
 982+ 0A0C 6F                           ld      L,A             ; load screen width into HL
 983+ 0A0D AF                           xor     A
 984+ 0A0E 67                           ld      H,A
 985+ 0A0F 57                           ld      D,A
 986+ 0A10 CD 93 3F                     call    MUL16           ; multiply HL times DE to get the screen size
 987+ 0A13 ED 5B C0 52                  ld      DE,(SCR_NAM_TB) ; load screen name table start address into DE
 988+ 0A17 19                           add     HL,DE           ; get the address...
 989+ 0A18 2B                           dec     HL              ; ...of the "last" video cell
 990+ 0A19 EB                           ex      DE,HL           ; store address into DE
 991+ 0A1A 2A CD 52                     ld      HL,(CUR_POS)    ; retrieve original cursor position
 992+ 0A1D E5           RPTNLLSRC2:     push    HL
 993+ 0A1E CD 88 3F                     call    CMP16           ; check if at last position on screen (bottom right corner)
 994+ 0A21 E1                           pop     HL
 995+ 0A22 C8                           ret     Z               ; if yes, exit because these is nothing after
 996+ 0A23 23                           inc     HL              ; 1 more step forward
 997+ 0A24 CD 7D 06                     call    READ_VIDEO_LOC  ; read char of current position
 998+ 0A27 A7                           and     A               ; is it $00 (null char)?
 999+ 0A28 20 F3                        jr      NZ,RPTNLLSRC2   ; no, continue searching
1000+ 0A2A C9           CNTNULL2:       ret                     ; yes: found end of text, return to caller
1001+ 0A2B
1002+ 0A2B
1003+ 0A2B              ; ------------------------------------------------------------------------------
1004+ 0A2B                              ; this table contains the values of the offsets to be added to
1005+ 0A2B                              ; the starting address of the name table to find the correct
1006+ 0A2B                              ; value of the first cell of the corresponding row
1007+ 0A2B                              ; (by doing so, it's faster than doing a multipication)
1008+ 0A2B                              ; table for graphics 1 text mode: 32 cols
1009+ 0A2B 00 00 20 00  POS_TB_CRS_32:  defw    $0000,$0020,$0040,$0060,$0080,$00A0,$00C0,$00E0
1009+ 0A2F 40 00 60 00
1009+ 0A33 80 00 A0 00
1009+ 0A37 C0 00 E0 00
1010+ 0A3B 00 01 20 01                  defw    $0100,$0120,$0140,$0160,$0180,$01A0,$01C0,$01E0
1010+ 0A3F 40 01 60 01
1010+ 0A43 80 01 A0 01
1010+ 0A47 C0 01 E0 01
1011+ 0A4B 00 02 20 02                  defw    $0200,$0220,$0240,$0260,$0280,$02A0,$02C0,$02E0
1011+ 0A4F 40 02 60 02
1011+ 0A53 80 02 A0 02
1011+ 0A57 C0 02 E0 02
1012+ 0A5B                              ; table for pure text mode: 40 cols
1013+ 0A5B 00 00 28 00  POS_TB_CRS_40:  defw    $0000,$0028,$0050,$0078,$00A0,$00C8,$00F0,$0118
1013+ 0A5F 50 00 78 00
1013+ 0A63 A0 00 C8 00
1013+ 0A67 F0 00 18 01
1014+ 0A6B 40 01 68 01                  defw    $0140,$0168,$0190,$01B8,$01E0,$0208,$0230,$0258
1014+ 0A6F 90 01 B8 01
1014+ 0A73 E0 01 08 02
1014+ 0A77 30 02 58 02
1015+ 0A7B 80 02 A8 02                  defw    $0280,$02A8,$02D0,$02F8,$0320,$0348,$0370,$0398
1015+ 0A7F D0 02 F8 02
1015+ 0A83 20 03 48 03
1015+ 0A87 70 03 98 03
1016+ 0A8B
1017+ 0A8B              ; ------------------------------------------------------------------------------
1018+ 0A8B              ; reset VRAM
1019+ 0A8B AF           EMPTY_VRAM:     xor     A               ; reg.A cleared: we fill up VRAM with $00
1020+ 0A8C 67                           ld      H,A
1021+ 0A8D 6F                           ld      L,A             ; reset HL
1022+ 0A8E CD 5D 06                     call    SETVDPADRS      ; set address of first VRAM cell to $0000
1023+ 0A91 06 40                        ld      B,$40           ; $40 pages of RAM...
1024+ 0A93 57                           ld      D,A             ; ...each one with $100 cells (tot. $4000 bytes)
1025+ 0A94 0D                           dec     C              ; VDP data mode
1026+ 0A95 ED 79        EMPTVRM:        out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
1027+ 0A97 14                           inc     D               ; next cell
1028+ 0A98 00                           nop
1029+ 0A99 20 FA                        jr      NZ,EMPTVRM      ; repeat until page is fully cleared
1030+ 0A9B 10 F8                        djnz    EMPTVRM         ; repeat for $40 pages
1031+ 0A9D C9                           ret                     ; return to caller
1032+ 0A9E
1033+ 0A9E              ; clear video registers in SRAM
1034+ 0A9E 21 BC 52     CLR_RAM_REG:    ld      HL,SCR_SIZE_W   ; address of first register
1035+ 0AA1 AF                           xor     A               ; $00 to clean the registers
1036+ 0AA2 06 45                        ld      B,CHASNDDTN-SCR_SIZE_W; how many bytes (registers) to clean (dinamically calculated)
1037+ 0AA4 77           RSTVDPRAMREG:   ld      (HL),A          ; reset register
1038+ 0AA5 23                           inc     HL              ; next register
1039+ 0AA6 10 FC                        djnz    RSTVDPRAMREG    ; repeat
1040+ 0AA8 C9                           ret                     ; return to caller
1041+ 0AA9
1042+ 0AA9              ; ------------------------------------------------------------------------------
1043+ 0AA9              ; set a specific graphics mode, passed into reg. E
1044+ 0AA9 06 08        SET_GFX_MODE:   ld      B,$08           ; 8 registers means 8 bytes..
1045+ 0AAB CB 23                        sla     E               ; multiply E by 8..
1046+ 0AAD CB 23                        sla     E               ; so that reg. E can point..
1047+ 0AAF CB 23                        sla     E               ; to the correct settings
1048+ 0AB1 16 00        SET_GFX_MODE2:  ld      D,$00           ; reset D
1049+ 0AB3 21 E5 0A                     ld      HL,VDPMODESET   ; pointer to register settings | <= here points the SHOW_LOGO sub-routine
1050+ 0AB6 19                           add     HL,DE           ; add offset to get the correct set of values for the required mode
1051+ 0AB7 3E 80                        ld      A,$80           ; start with REG0 ($80+register number)
1052+ 0AB9 0E 31                        ld      C,VDP_SET       ; VDP set
1053+ 0ABB 56           LDREGVLS:       ld      D,(HL)          ; load register's value
1054+ 0ABC ED 51                        out     (C),D           ; send data to VDP
1055+ 0ABE ED 79                        out     (C),A           ; indicate the register to send data to
1056+ 0AC0 3C                           inc     A               ; next register
1057+ 0AC1 23                           inc     HL              ; next value
1058+ 0AC2 10 F7                        djnz    LDREGVLS        ; repeat for 8 registers
1059+ 0AC4 C9                           ret
1060+ 0AC5
1061+ 0AC5              ; ------------------------------------------------------------------------------
1062+ 0AC5              LOADCHARSET:    ; reg. A contains the video mode
1063+ 0AC5                              ; reg. HL contains address of pattern table into VRAM
1064+ 0AC5 06 00                        ld      B,$00           ; 0=256 chars to load (complete charset)
1065+ 0AC7 CB F4                        set     $06,H           ; add $4000 to address to indicate that we want to write into VRAM
1066+ 0AC9 0E 31                        ld      C,VDP_SET       ; load VDP address into C
1067+ 0ACB ED 69                        out     (C),L           ; send low byte of address
1068+ 0ACD ED 61                        out     (C),H           ; send high byte
1069+ 0ACF 0D                           dec     C              ; VDP data mode
1070+ 0AD0 21 EB 3F                     ld      HL,CHRST68      ; starting address of 6x8 charset into ROM
1071+ 0AD3 A7                           and     A               ; is it text mode (A=0)?
1072+ 0AD4 28 03                        jr      Z,NXTCHAR       ; yes, so jump to load chars into VRAM
1073+ 0AD6 21 EB 47                     ld      HL,CHRST88      ; no, so we change and load the 8x8 charset
1074+ 0AD9 16 08        NXTCHAR:        ld      D,$08           ; 8 bytes per pattern char
1075+ 0ADB 7E           SENDCHRPTRNS:   ld      A,(HL)          ; load byte to send to VDP
1076+ 0ADC ED 79                        out     (C),A           ; write byte into VRAM
1077+ 0ADE 23                           inc     HL              ; inc byte pointer
1078+ 0ADF 15                           dec     D               ; 8 bytes sents (0 char)?
1079+ 0AE0 20 F9                        jr      NZ,SENDCHRPTRNS ; no, continue
1080+ 0AE2 10 F5                        djnz    NXTCHAR         ; yes, decrement chars counter and continue for all the chars
1081+ 0AE4 C9                           ret                     ; return to caller
1082+ 0AE5
1083+ 0AE5              ;------------------------------------------------------------------------------
1084+ 0AE5              ; NAME TABLE:       buffer video - contains the chars to be shown on video
1085+ 0AE5              ; PATTERN TABLE:    charset - contains the chars/tiles to be loaded into the name table
1086+ 0AE5              ; COLOR TABLE:      color settings for chars/tiles
1087+ 0AE5
1088+ 0AE5                              ; VDP register settings for a text display
1089+ 0AE5 00           VDPMODESET:     defb    %00000000       ; reg.0: external video off
1090+ 0AE6 D0                           defb    %11010000       ; reg.1: 16K VRAM, video on, int. off, text mode (40x24)
1091+ 0AE7 02                           defb    $02             ; reg.2: name table set to $0800 ($02x$400)
1092+ 0AE8 00                           defb    $00             ; reg.3: not used in text mode
1093+ 0AE9 00                           defb    $00             ; reg.4: pattern table set to $0000
1094+ 0AEA 00                           defb    $00             ; reg.5: not used in text mode
1095+ 0AEB 00                           defb    $00             ; reg.6: not used in text mode
1096+ 0AEC F5                           defb    $f5             ; reg.7: white text on light blue background
1097+ 0AED
1098+ 0AED              VDPMODESET1:    ; VDP register settings for a graphics 1 mode
1099+ 0AED 00                           defb    %00000000       ; reg.0: ext. video off
1100+ 0AEE C0                           defb    %11000000       ; reg.1: 16K Vram; video on, int off, graphics mode 1, sprite size 8x8, sprite magn. 0
1101+ 0AEF 06                           defb    $06             ; reg.2: name table address: $1800
1102+ 0AF0 80                           defb    $80             ; reg.3: color table address: $2000
1103+ 0AF1 00                           defb    $00             ; reg.4: pattern table address: $0000
1104+ 0AF2 36                           defb    $36             ; reg.5: sprite attr. table address: $1B00
1105+ 0AF3 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1106+ 0AF4 05                           defb    $05             ; reg.7: backdrop color (light blue)
1107+ 0AF5
1108+ 0AF5              VDPMODESET2:    ; VDP register settings for a graphics 2 mode
1109+ 0AF5 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1110+ 0AF6 C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1111+ 0AF7 06                           defb    $06             ; reg.2: name table addr.: $1800
1112+ 0AF8 FF                           defb    $FF             ; reg.3: color table addr.: $2000
1113+ 0AF9 03                           defb    $03             ; reg.4: pattern table addr.: $0000
1114+ 0AFA 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1115+ 0AFB 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1116+ 0AFC 05                           defb    $05             ; reg.7: backdrop color: light blue
1117+ 0AFD
1118+ 0AFD              VDPMODESETMC:   ; VDP register settings for a multicolor mode
1119+ 0AFD 00                           defb    %00000000       ; reg.0: ext. video dis.
1120+ 0AFE CB                           defb    %11001011       ; reg.1: 16K VRAM, video on, INT off, multicolor mode, sprite size 8x8, sprite magn. 0
1121+ 0AFF 02                           defb    $02             ; reg.2: name table addr.: $0800
1122+ 0B00 00                           defb    $00             ; reg.3: don't care
1123+ 0B01 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1124+ 0B02 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1125+ 0B03 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1126+ 0B04 0F                           defb    $0F             ; reg.7: backdrop color (white)
1127+ 0B05
1128+ 0B05              VDPMODESETEX2:  ; VDP register settings for an extended graphics 2 mode
1129+ 0B05 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1130+ 0B06 C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1131+ 0B07 0E                           defb    $0E             ; reg.2: name table addr.: $3800
1132+ 0B08 9F                           defb    $9F             ; reg.3: color table addr.: $2000
1133+ 0B09 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1134+ 0B0A 76                           defb    $76             ; reg.5: sprite attr. table addr.: $3B00
1135+ 0B0B 03                           defb    $03             ; reg.6: sprite pattern table addr.: $1800
1136+ 0B0C 05                           defb    $05             ; reg.7: backdrop color: light blue
1137+ 0B0D
1138+ 0B0D              LM80CLOGO:      ; patterns to compose the splash screen logo
1139+ 0B0D                              ; 1st band
1140+ 0B0D 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1140+ 0B11 00 00 00 00
1140+ 0B15 00 00 00 00
1140+ 0B19 00 00 00 00
1140+ 0B1D 00 00 00 00
1140+ 0B21 00 00 00 00
1140+ 0B25 00 00 00 00
1140+ 0B29 00 00 00 00
1141+ 0B2D 00 00 0F 0A                  defb    0,0,15,10,11,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1141+ 0B31 0B 10 00 00
1141+ 0B35 00 00 00 00
1141+ 0B39 00 00 00 00
1141+ 0B3D 00 00 00 00
1141+ 0B41 00 00 00 00
1141+ 0B45 00 00 00 00
1141+ 0B49 00 00 00 00
1142+ 0B4D                              ; 2nd band
1143+ 0B4D 00 00 0D 17                  defb    0,0,13,23,0,12,0,0,0,1,0,0,0,20,0,0,6,5,6,21,22,7,6,21,22,7,6,1,1,7,0,0
1143+ 0B51 00 0C 00 00
1143+ 0B55 00 01 00 00
1143+ 0B59 00 14 00 00
1143+ 0B5D 06 05 06 15
1143+ 0B61 16 07 06 15
1143+ 0B65 16 07 06 01
1143+ 0B69 01 07 00 00
1144+ 0B6D 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,20,6,1,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1144+ 0B71 00 0C 00 00
1144+ 0B75 00 01 00 00
1144+ 0B79 00 01 14 06
1144+ 0B7D 01 05 03 05
1144+ 0B81 03 05 03 05
1144+ 0B85 03 05 03 05
1144+ 0B89 03 05 00 00
1145+ 0B8D                              ; 3rd band
1146+ 0B8D 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,1,1,1,5,9,20,19,8,3,5,19,5,3,5,0,0,0,0
1146+ 0B91 00 0C 00 00
1146+ 0B95 00 01 00 00
1146+ 0B99 00 01 01 01
1146+ 0B9D 01 05 09 14
1146+ 0BA1 13 08 03 05
1146+ 0BA5 13 05 03 05
1146+ 0BA9 00 00 00 00
1147+ 0BAD 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,8,3,5,6,21,22,7,3,1,22,5,3,5,0,0,0,0
1147+ 0BB1 00 0C 00 00
1147+ 0BB5 00 01 00 00
1147+ 0BB9 00 01 00 08
1147+ 0BBD 03 05 06 15
1147+ 0BC1 16 07 03 01
1147+ 0BC5 16 05 03 05
1147+ 0BC9 00 00 00 00
1148+ 0BCD                              ; 4th band
1149+ 0BCD 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,0,3,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1149+ 0BD1 00 0C 00 00
1149+ 0BD5 00 01 00 00
1149+ 0BD9 00 01 00 00
1149+ 0BDD 03 05 03 05
1149+ 0BE1 03 05 03 05
1149+ 0BE5 03 05 03 05
1149+ 0BE9 03 05 00 00
1150+ 0BED 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,4,4,0,1,0,0,3,5,9,20,19,8,9,20,19,8,9,1,1,8,0,0
1150+ 0BF1 00 0C 00 00
1150+ 0BF5 00 01 04 04
1150+ 0BF9 00 01 00 00
1150+ 0BFD 03 05 09 14
1150+ 0C01 13 08 09 14
1150+ 0C05 13 08 09 01
1150+ 0C09 01 08 00 00
1151+ 0C0D                              ; 5th band
1152+ 0C0D 00 00 0E 12                  defb    0,0,14,18,18,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1152+ 0C11 12 11 00 00
1152+ 0C15 00 00 00 00
1152+ 0C19 00 00 00 00
1152+ 0C1D 00 00 00 00
1152+ 0C21 00 00 00 00
1152+ 0C25 00 00 00 00
1152+ 0C29 00 00 00 00
1153+ 0C2D 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1153+ 0C31 00 00 00 00
1153+ 0C35 00 00 00 00
1153+ 0C39 00 00 00 00
1153+ 0C3D 00 00 00 00
1153+ 0C41 00 00 00 00
1153+ 0C45 00 00 00 00
1153+ 0C49 00 00 00 00
# file closed: ../include/vdp/vdp-1.2.asm
  73  0C4D
  74  0C4D              ; incude the latest version of the PSG module
  75  0C4D                  INCLUDE "../include/psg/psg-1.1.asm"
# file opened: ../include/psg/psg-1.1.asm
   1+ 0C4D              ; ------------------------------------------------------------------------------
   2+ 0C4D              ; LM80C - PSG ROUTINES - 1.1
   3+ 0C4D              ; ------------------------------------------------------------------------------
   4+ 0C4D              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0C4D              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0C4D              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0C4D              ; kind of warranty: you can use them at your own risk.
   8+ 0C4D              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0C4D              ; maintain the copyright notices, include this advice and the note to the
  10+ 0C4D              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0C4D              ; redistribuite them.
  12+ 0C4D              ; https://www.leonardomiliani.com
  13+ 0C4D              ;
  14+ 0C4D              ; Please support me by visiting the following links:
  15+ 0C4D              ; Main project page: https://www.leonardomiliani.com
  16+ 0C4D              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0C4D              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0C4D              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0C4D              ; ------------------------------------------------------------------------------
  20+ 0C4D              ;
  21+ 0C4D              ; ------------------------------------------------------------------------------
  22+ 0C4D
  23+ 0C4D              ;------------------------------------------------------------------------------
  24+ 0C4D
  25+ 0C4D              ; configure the PSG
  26+ 0C4D 21 01 53     initPSG:        ld      HL,CHASNDDTN    ; starting address of sound & keyboard RAM registers
  27+ 0C50 06 0E                        ld      B,SERIALS_EN-CHASNDDTN; # of PSG sound & keyboard registers
  28+ 0C52 AF                           xor     A               ; reset A
  29+ 0C53 77           EMPTSNDBFR:     ld      (HL),A          ; reset RAM register
  30+ 0C54 23                           inc     HL              ; next register
  31+ 0C55 10 FC                        djnz    EMPTSNDBFR      ; repeat
  32+ 0C57 06 10        CLRPSGREGS:     ld      B,$10           ; 16 registers to set
  33+ 0C59 21 6B 0C                     ld      HL,SNDREGCFG    ; starting address of register settings
  34+ 0C5C 16 00                        ld      D,$00           ; first register
  35+ 0C5E 7A           RSTPSG:         ld      A,D             ; register value
  36+ 0C5F CD A5 0C                     call    SETSNDREG       ; select register
  37+ 0C62 7E                           ld      A,(HL)          ; load value
  38+ 0C63 CD AA 0C                     call    WRTSNDREG       ; write to register
  39+ 0C66 14                           inc     D               ; next register
  40+ 0C67 23                           inc     HL              ; next value
  41+ 0C68 10 F4                        djnz    RSTPSG          ; repeat for each register
  42+ 0C6A C9                           ret                     ; return to caller
  43+ 0C6B
  44+ 0C6B 00 00 00 00  SNDREGCFG:      defb $00,$00,$00,$00,$00,$00,$00,%10111111
  44+ 0C6F 00 00 00 BF
  45+ 0C73 00 00 00 00                  defb $00,$00,$00,$00,$00,$00,$ff,$ff
  45+ 0C77 00 00 FF FF
  46+ 0C7B                              ; reg. 7: set I/O ch.A to OUTPUT, I/O ch.B to INPUT; set noise to OFF; set audio to OFF
  47+ 0C7B
  48+ 0C7B
  49+ 0C7B              ; routine to play a welcome beep on channel C (tone 4010) and to shut it off
  50+ 0C7B 21 95 0C     WLCMBEEP:       ld      HL,WLCBPDAT     ; data address
  51+ 0C7E C3 84 0C                     jp      SENDSND
  52+ 0C81 21 9D 0C     NOBEEP:         ld      HL,NOBPDAT      ; data address
  53+ 0C84 C5           SENDSND:        push    BC
  54+ 0C85 06 04                        ld      B,$04           ; 4 pairs
  55+ 0C87 7E           RPTWLCMBP:      ld      A,(HL)          ; read register #
  56+ 0C88 CD A5 0C                     call    SETSNDREG
  57+ 0C8B 23                           inc     HL              ; next cell
  58+ 0C8C 7E                           ld      A,(HL)          ; read value
  59+ 0C8D CD AA 0C                     call    WRTSNDREG
  60+ 0C90 23                           inc     HL
  61+ 0C91 10 F4                        djnz    RPTWLCMBP       ; repeat
  62+ 0C93 C1                           pop     BC
  63+ 0C94 C9                           ret                     ; return to caller
  64+ 0C95
  65+ 0C95 07 BB 04 56  WLCBPDAT:       defb    $07,%10111011,$04,$56,$05,$00,$0A,$0F
  65+ 0C99 05 00 0A 0F
  66+ 0C9D 04 00 05 00  NOBPDAT:        defb    $04,$00,$05,$00,$0A,$00,$07,%10111111
  66+ 0CA1 0A 00 07 BF
  67+ 0CA5
  68+ 0CA5
  69+ 0CA5              ; select register on PSG
  70+ 0CA5 0E 40        SETSNDREG:      ld      C,PSG_REG       ; PSG register port
  71+ 0CA7 ED 79                        out     (C),A           ; set register
  72+ 0CA9 C9                           ret                     ; return to caller
  73+ 0CAA
  74+ 0CAA              ; send data to PSG
  75+ 0CAA 0E 41        WRTSNDREG:      ld      C,PSG_DAT       ; PSG data port
  76+ 0CAC ED 79                        out     (C),A           ; send data
  77+ 0CAE C9                           ret                     ; return to caller
  78+ 0CAF
  79+ 0CAF              ; manage the sounds' duration: each time this subroutine is called, it
  80+ 0CAF              ; decrements the single sound durations (measured in ms) and eventually
  81+ 0CAF              ; shut off the audio channel whose counter has reached 0.
  82+ 0CAF              ; (this sub-routine is called by CH3 timer ISR)
  83+ 0CAF DD E5        MNGSNDS:        push    IX              ; store IX
  84+ 0CB1 DD 21 01 53                  ld      IX,CHASNDDTN    ; starting address of tones duration
  85+ 0CB5 06 03                        ld      B,$03           ; 3 channels to check
  86+ 0CB7 26 01                        ld      H,$01           ; mixer channels: A=>bit 1, B=>bit 2, C=>bit 3
  87+ 0CB9 DD 5E 00     CHKSNDCH:       ld      E,(IX+0)        ; load LSB into E
  88+ 0CBC DD 56 01                     ld      D,(IX+1)        ; load MSB into D
  89+ 0CBF 7B                           ld      A,E             ; load E into A
  90+ 0CC0 B2                           or      D               ; check that DE=0
  91+ 0CC1 28 31                        jr      Z,CNTCHKSND     ; yes, jump over
  92+ 0CC3 1B                           dec     DE              ; no, so decrement DE
  93+ 0CC4 7B                           ld      A,E             ; reload E into A...
  94+ 0CC5 DD 73 00                     ld      (IX+0),E        ; store new...
  95+ 0CC8 DD 72 01                     ld      (IX+1),D        ; ...duration and...
  96+ 0CCB B2                           or      D               ; ...do another check to see if DE=0
  97+ 0CCC 20 26                        jr      NZ,CNTCHKSND    ; no, so jump over
  98+ 0CCE                                                      ; if yes, let's shut down the corresponding channel
  99+ 0CCE                                                      ; to shut down a tone we disable it into the mixer
 100+ 0CCE                                                      ; then set 0 into its tone registers
 101+ 0CCE 16 07                        ld      D,$07           ; mixer register
 102+ 0CD0 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 103+ 0CD2 ED 51                        out     (C),D           ; set mixer register
 104+ 0CD4 ED 78                        in      A,(C)           ; load current value
 105+ 0CD6 B4                           or      H               ; set off the channel into the mixer (remember that 1=OFF)
 106+ 0CD7 ED 51                        out     (C),D           ; select mixer register
 107+ 0CD9 0E 41                        ld      C,PSG_DAT       ; PSG data port
 108+ 0CDB ED 79                        out     (C),A           ; send new value for the mixer
 109+ 0CDD 3E 03                        ld      A,$03           ; three channels
 110+ 0CDF 90                           sub     B               ; find current channel (0->A, 1->B, 2->C)
 111+ 0CE0 87                           add     A,A             ; and find first register (A=>0, B=>2, C=>4)
 112+ 0CE1 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 113+ 0CE3 ED 79                        out     (C),A           ; select first tone register of channel
 114+ 0CE5 2E 00                        ld      L,$00           ; value 0 into L
 115+ 0CE7 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 116+ 0CE9 ED 69                        out     (C),L           ; write 0 into register
 117+ 0CEB 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 118+ 0CED 3C                           inc     A               ; next tone register
 119+ 0CEE ED 79                        out     (C),A           ; select second tone register of channel
 120+ 0CF0 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 121+ 0CF2 ED 69                        out     (C),L           ; write 0 into register
 122+ 0CF4 DD 23        CNTCHKSND:      inc     IX              ; set for...
 123+ 0CF6 DD 23                        inc     IX              ; ...next channel...
 124+ 0CF8 CB 24                        sla     H               ; shift left H 1 bit
 125+ 0CFA 10 BD                        djnz    CHKSNDCH        ; repeat for 3 channels
 126+ 0CFC DD E1                        pop     IX              ; restore IX
 127+ 0CFE C9                           ret                     ; return to caller
 128+ 0CFF
 129+ 0CFF              ; read a specific row of the keyboard matrix, set by A
 130+ 0CFF              ; return read into A
 131+ 0CFF C5           READKBLN:       push    BC              ; store BC
 132+ 0D00 06 0F                        ld      B,$0F           ; reg #15
 133+ 0D02 0E 40                        ld      C,PSG_REG       ; PSG register port
 134+ 0D04 ED 41                        out     (C),B           ; select reg #15
 135+ 0D06 0E 41                        ld      C,PSG_DAT       ; PSG data port
 136+ 0D08 ED 79                        out     (C),A           ; activate the row
 137+ 0D0A 06 0E                        ld      B,$0E           ; register #14 (port B)
 138+ 0D0C 0E 40                        ld      C,PSG_REG       ; PSG register port
 139+ 0D0E ED 41                        out     (C),B           ; select reg. 14 (port B)
 140+ 0D10 ED 78                        in      A,(C)           ; read register #14
 141+ 0D12 C1                           pop     BC              ; retrieve BC
 142+ 0D13 C9                           ret
 143+ 0D14
 144+ 0D14              ; read the keyboard matrix to look for a key pressure
 145+ 0D14 0E 40        KEYBOARD:       ld      C,PSG_REG       ; PSG register port
 146+ 0D16 06 07                        ld      B,$07           ; set register #7...
 147+ 0D18 ED 41                        out     (C),B           ; ...to work with
 148+ 0D1A ED 78                        in      A,(C)           ; read register #7
 149+ 0D1C CB FF                        set     7,A             ; port A set to output
 150+ 0D1E CB B7                        res     6,A             ; port B set to input
 151+ 0D20 ED 41                        out     (C),B           ; set register #7
 152+ 0D22 0E 41                        ld      C,PSG_DAT       ; PSG data port
 153+ 0D24 ED 79                        out     (C),A           ; set I/O ports w/o altering the rest of the mixer
 154+ 0D26                              ; check special keys (SHIFT/ALT/CTRL)
 155+ 0D26 3E FD                        ld      A,%11111101     ; select SHIFT row
 156+ 0D28 CD FF 0C                     call    READKBLN        ; read row
 157+ 0D2B CB 5F                        bit     3,A             ; test if SHIFT key is pressed (4th bit is reset)
 158+ 0D2D 20 05                        jr      NZ,CHECKALT     ; no, so go on
 159+ 0D2F 21 0E 53                     ld      HL,CONTROLKEYS  ; control key flags
 160+ 0D32 36 01                        ld      (HL),%00000001  ; set SHIFT flag, reset CTRL & ALT flags (currently multiply control keys are NOT supported)
 161+ 0D34 3E FE        CHECKALT:       ld      A,%11111110     ; select ALT row
 162+ 0D36 CD FF 0C                     call    READKBLN        ; read ALT row
 163+ 0D39 CB 6F                        bit     5,A             ; test if ALT key is pressed (5th bit is reset)
 164+ 0D3B 20 05                        jr      NZ,CHECKCTRL    ; no, so go on
 165+ 0D3D 21 0E 53                     ld      HL,CONTROLKEYS  ; control key flags
 166+ 0D40 36 04                        ld      (HL),%00000100  ; set ALT flag, reset SHIFT & CTRL flag (currently multiply control keys are NOT supported)
 167+ 0D42 3E FE        CHECKCTRL:      ld      A,%11111110     ; select CTRL row
 168+ 0D44 CD FF 0C                     call    READKBLN        ; read CTRL row
 169+ 0D47 CB 57                        bit     2,A             ; test if CTRL key is pressed (3rd bit is reset)
 170+ 0D49 20 05                        jr      NZ,CHECKKBD     ; no, so make a normal reading
 171+ 0D4B 21 0E 53                     ld      HL,CONTROLKEYS  ; control key flags
 172+ 0D4E 36 02                        ld      (HL),%00000010  ; set CTRL flag, reset SHIFT & ALT flags (currently multiply control keys are NOT supported)
 173+ 0D50 06 08        CHECKKBD:       ld      B,$08           ; 8 lines
 174+ 0D52 3E 7F                        ld      A,%01111111     ; start from the last line of the matrix
 175+ 0D54 16 0F        RPTKBDRD:       ld      D,$0F           ; register #15 (port B)
 176+ 0D56 0E 40                        ld      C,PSG_REG       ; PSG register port
 177+ 0D58 ED 51                        out     (C),D           ; select reg. #15
 178+ 0D5A 0E 41                        ld      C,PSG_DAT       ; PSG data port
 179+ 0D5C ED 79                        out     (C),A           ; activate 1 line (active line is grounded, i.e. with a LOW signal)
 180+ 0D5E 5F                           ld      E,A             ; save current line into E
 181+ 0D5F 16 0E                        ld      D,$0E           ; register #14 (port A)
 182+ 0D61 0E 40                        ld      C,PSG_REG       ; PSG register port
 183+ 0D63 ED 51                        out     (C),D           ; select reg. 14 (port A)
 184+ 0D65 00                           nop
 185+ 0D66 ED 78                        in      A,(C)           ; read register #14
 186+ 0D68 FE FF                        cp      $FF             ; is there any line set to 0?
 187+ 0D6A 28 2E                        jr      Z,NOKEYPRSD     ; no, go to the next row
 188+ 0D6C                              ; check control keys
 189+ 0D6C 32 08 53                     ld      (KBTMP),A       ; yes, check if a control key was pressed. First, store current row
 190+ 0D6F 78                           ld      A,B             ; copy current row (B) into A
 191+ 0D70 FE 02                        cp      $02             ; is it the row of the SHIFT?
 192+ 0D72 20 0F                        jr      NZ,TESTALT      ; no, continue checking the other control keys
 193+ 0D74 3A 08 53                     ld      A,(KBTMP)       ; yes, retrieve current row data
 194+ 0D77 CB 5F                        bit     3,A             ; check SHIFT bit line
 195+ 0D79 20 31                        jr      NZ,FINDKEY      ; no SHIFT, continue checking
 196+ 0D7B CB DF                        set     3,A             ; yes, it's the SHIFT. So remove SHIFT bit
 197+ 0D7D FE FF                        cp      $FF             ; after deleting the SHIFT bit, is there any other bit selected?
 198+ 0D7F 20 2B                        jr      NZ,FINDKEY      ; yes, go to check which one
 199+ 0D81 18 17                        jr      NOKEYPRSD       ; no, go to next row
 200+ 0D83 FE 01        TESTALT:        cp      $01             ; is it the line of ALT & CTRL?
 201+ 0D85 3A 08 53                     ld      A,(KBTMP)       ; retrieve current row data
 202+ 0D88 20 22                        jr      NZ,FINDKEY      ; no, continue
 203+ 0D8A CB 6F                        bit     5,A             ; yes, check ALT bit line
 204+ 0D8C 20 02                        jr      NZ,TESTCTRL     ; no ALT, continue checking
 205+ 0D8E CB EF                        set     5,A             ; yes, it's the ALT. So remove ALT bit
 206+ 0D90 CB 57        TESTCTRL:       bit     2,A             ; check CTRL bit line
 207+ 0D92 20 02                        jr      NZ,ENDCTRLCK    ; no CTRL, continue checking
 208+ 0D94 CB D7                        set     2,A             ; delete CTRL bit flag
 209+ 0D96 FE FF        ENDCTRLCK:      cp      $FF             ; after deleting the ALT & CTRL bits, is there any other bit selected?
 210+ 0D98 20 12                        jr      NZ,FINDKEY      ; yes, go to check which one
 211+ 0D9A 7B           NOKEYPRSD:      ld      A,E             ; no key pressed, load current output port
 212+ 0D9B 0F                           rrca                    ; rotate right by 1
 213+ 0D9C 10 B6                        djnz    RPTKBDRD        ; repeat for 8 lines
 214+ 0D9E AF                           xor     A               ; if exit from here, no key has been pressed...
 215+ 0D9F 32 0A 53                     ld      (LASTKEYPRSD),A ; ...so reset the last key cell...
 216+ 0DA2 32 0E 53                     ld      (CONTROLKEYS),A ; ...reset contro key flags...
 217+ 0DA5 32 07 53                     ld      (KBDNPT),A      ; ...no input from keyboard...
 218+ 0DA8 32 0B 53                     ld      (STATUSKEY),A   ; ...no auto-repeat...
 219+ 0DAB C9                           ret                     ; ...and leave
 220+ 0DAC 1E FF        FINDKEY:        ld      E,$FF           ; counter
 221+ 0DAE 1C           CHKLN:          inc     E               ; E goes from 0 to 7
 222+ 0DAF CB 3F                        srl     A               ; is the first bit reset? (we're looking for a "0", meaning grounded line)
 223+ 0DB1 38 FB                        jr      C,CHKLN         ; no, check next bit
 224+ 0DB3 3A 0E 53                     ld      A,(CONTROLKEYS) ; load control key flags
 225+ 0DB6 21 CF 0E                     ld      HL,KBMAP        ; normal keymap
 226+ 0DB9 FE 01                        cp      $01             ; SHIFT flag?
 227+ 0DBB 20 05                        jr      NZ,CHKCTRL      ; no, jump over
 228+ 0DBD 21 0F 0F                     ld      HL,KBMAP_SFT    ; SHIFT keymap
 229+ 0DC0 18 10                        jr      LOADMAP         ; and load it
 230+ 0DC2 FE 02        CHKCTRL:        cp      $02             ; CTRL flag?
 231+ 0DC4 20 05                        jr      NZ,CHKALT       ; no, jump over
 232+ 0DC6 21 8F 0F                     ld      HL,KBMAP_CTRL   ; CTRL map
 233+ 0DC9 18 07                        jr      LOADMAP         ; and load it
 234+ 0DCB FE 04        CHKALT:         cp      $04             ; ALT flag?
 235+ 0DCD 20 03                        jr      NZ,LOADMAP      ; no, check over
 236+ 0DCF 21 4F 0F                     ld      HL,KBMAP_ALT    ; ALT map
 237+ 0DD2 05           LOADMAP:        dec     B               ; decrement row # (rows go from 0 to 7)
 238+ 0DD3 48                           ld      C,B             ; move B into C and...
 239+ 0DD4 CB 21                        sla     C               ; ...multiply it...
 240+ 0DD6 CB 21                        sla     C               ; ...by 8 to find...
 241+ 0DD8 CB 21                        sla     C               ; ...the current row into the matrix
 242+ 0DDA 06 00                        ld      B,$00           ; reset B
 243+ 0DDC 09                           add     HL,BC           ; find the address of the current row
 244+ 0DDD 50                           ld      D,B             ; reset D
 245+ 0DDE 19                           add     HL,DE           ; find the current column - now (HL) stores the pressed key
 246+ 0DDF 3A 0A 53                     ld      A,(LASTKEYPRSD) ; load the last key pressed
 247+ 0DE2 BE                           cp      (HL)            ; is it the same key?
 248+ 0DE3 20 41                        jr      NZ,NEWKEY       ; no, it's a new key
 249+ 0DE5 44 4D                        ld      BC,HL           ; store address of current keycode
 250+ 0DE7 2A AC 52                     ld      HL,(TMRCNT)     ; load current system timer
 251+ 0DEA ED 5B 0C 53                  ld      DE,(KEYTMR)     ; load auto-repeat timer
 252+ 0DEE 3A 0B 53                     ld      A,(STATUSKEY)   ; yes, load current status of auto-repeat
 253+ 0DF1 FE 01                        cp      $01             ; is it initial pressure?
 254+ 0DF3 20 1F                        jr      NZ,CHKAUTO      ; no, jump over
 255+ 0DF5 AF                           xor     A               ; clear Carry
 256+ 0DF6 ED 52                        sbc     HL,DE           ; startint time - actual time
 257+ 0DF8 16 00                        ld      D,$00           ; 64 ths/s > 640 ms
 258+ 0DFA 3A A2 51                     ld      A,(KEYDEL)
 259+ 0DFD 5F                           ld      E,A
 260+ 0DFE CD 88 3F                     call    CMP16           ; time elapsed is >= $40?
 261+ 0E01 DA 76 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 262+ 0E04 3E 02        SETNEWAUTO:     ld      A,$02           ; yes set status to...
 263+ 0E06 32 0B 53                     ld      (STATUSKEY),A   ; ...auto-repeat
 264+ 0E09 2A AC 52                     ld      HL,(TMRCNT)     ; load system timer
 265+ 0E0C 22 0C 53                     ld      (KEYTMR),HL     ; store starting time
 266+ 0E0F 60 69                        ld      HL,BC           ; retrieve address of current keycode
 267+ 0E11 C3 33 0E                     jp      SENDKEY         ; send key
 268+ 0E14 AF           CHKAUTO:        xor     A               ; clear Carry
 269+ 0E15 ED 52                        sbc     HL,DE           ; computer interval between initial pressure of key and current time
 270+ 0E17 16 00                        ld      D,$00
 271+ 0E19 3A A3 51                     ld      A,(AUTOKE)
 272+ 0E1C 5F                           ld      E,A             ; auto-repeat delay into DE
 273+ 0E1D CD 88 3F                     call    CMP16           ; check if interval is greater than delay
 274+ 0E20 DA 76 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 275+ 0E23 C3 04 0E                     jp      SETNEWAUTO      ; set new loop and send key
 276+ 0E26 AF           NEWKEY:         xor     A               ; set initial state...
 277+ 0E27 3C                           inc     A               ; ...for auto-repeat...
 278+ 0E28 32 0B 53                     ld      (STATUSKEY),A   ; ...1=pressure init
 279+ 0E2B ED 4B AC 52                  ld      BC,(TMRCNT)     ; load current system timer
 280+ 0E2F ED 43 0C 53                  ld      (KEYTMR),BC     ; set starting time
 281+ 0E33 7E           SENDKEY:        ld      A,(HL)          ; then, load key...
 282+ 0E34 32 0A 53                     ld      (LASTKEYPRSD),A ; ...store it...
 283+ 0E37 32 09 53                     ld      (TMPKEYBFR),A   ; ...insert it into the INKEY buffer...
 284+ 0E3A 32 CA 52                     ld      (CHR4VID),A     ; ...and store char for video
 285+ 0E3D FE 03                        cp      CTRLC           ; is it RUN/STOP?
 286+ 0E3F 20 05                        jr      NZ,CNTKBCK      ; no, jump over
 287+ 0E41 CD F4 01                     call    CHARINTOBFR     ; yes, send directly to buffer and...
 288+ 0E44 18 30                        jr      LVKBRDCHK2      ; ...leave
 289+ 0E46 01 00 08     CNTKBCK:        ld      BC,$0800        ; 8 FN keys (B), FN key number (C)
 290+ 0E49 21 C7 0E                     ld      HL,FNKEYSORD    ; FN keys codes
 291+ 0E4C BE           CHKFNK:         cp      (HL)            ; is it an FN key?
 292+ 0E4D CA 7B 0E                     jp      Z,PRNTFNKEY     ; yes, jump over
 293+ 0E50 0C                           inc     C               ; next FN key
 294+ 0E51 23                           inc     HL              ; next FN key code
 295+ 0E52 10 F8                        djnz    CHKFNK          ; continue for 8 FN keys
 296+ 0E54 3E 01        SNDKEYTOBFR:    ld      A,$01           ; normal key - set input flag
 297+ 0E56 32 07 53                     ld      (KBDNPT),A      ; to keyboard
 298+ 0E59 3A C9 52                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 299+ 0E5C B7                           or      A               ; is the print-on-video disabled?
 300+ 0E5D CA 66 0E                     jp      Z,PUTCHRBUF     ; yes, so send char to input buffer
 301+ 0E60 3A C7 52                     ld      A,(CRSR_STATE)  ; check cursor state
 302+ 0E63 B7                           or      A               ; is it 0 (cursor OFF)?
 303+ 0E64 20 0D                        jr      NZ,PNT2VD       ; no, print on screen
 304+ 0E66 AF           PUTCHRBUF:      xor     A
 305+ 0E67 32 07 53                     ld      (KBDNPT),A      ; if send to input buffer, set RETURN as from BASIC
 306+ 0E6A 3A 09 53                     ld      A,(TMPKEYBFR)   ; retrieve char
 307+ 0E6D CD F4 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 308+ 0E70 C3 76 0E                     jp      LVKBRDCHK2      ; ...and leave
 309+ 0E73 CD 4E 07     PNT2VD:         call    CHAR2VID        ; send char to video
 310+ 0E76 AF           LVKBRDCHK2:     xor     A
 311+ 0E77 32 0E 53                     ld      (CONTROLKEYS),A ; reset control key flags
 312+ 0E7A C9           LVKBRDCHK:      ret                     ; return to caller: the current key code is into TMPKEYBFR
 313+ 0E7B                              ; manage FN keys
 314+ 0E7B 57           PRNTFNKEY:      ld      D,A             ; copy A into D
 315+ 0E7C 2A 9E 51                     ld      HL,(LINEAT)     ; Get current line number
 316+ 0E7F 23                           inc     HL              ; -1 means direct statement
 317+ 0E80 7C                           ld      A,H
 318+ 0E81 B5                           or      L
 319+ 0E82 7A                           ld      A,D             ; retrieve char
 320+ 0E83 20 CF                        jr      NZ,SNDKEYTOBFR  ; indirect mode - just send FN key code to buffer
 321+ 0E85 79                           ld      A,C             ; direct mode, so print text - first, get FN key number
 322+ 0E86 87                           add     A,A
 323+ 0E87 87                           add     A,A
 324+ 0E88 87                           add     A,A
 325+ 0E89 87                           add     A,A             ; FN key number * 16
 326+ 0E8A 4F                           ld      C,A             ; move it into C
 327+ 0E8B 06 00                        ld      B,$00           ; reset B, to get offset
 328+ 0E8D 21 A4 51                     ld      HL,FNKEYS       ; load address of FN keys texts
 329+ 0E90 09                           add     HL,BC           ; get correct text address
 330+ 0E91 06 10                        ld      B,$10           ; 16 chars
 331+ 0E93 7E           LDFNKEYCHR:     ld      A,(HL)          ; load char
 332+ 0E94 A7                           and     A               ; null char?
 333+ 0E95 CA 76 0E                     jp      Z,LVKBRDCHK2    ; yes, so leave
 334+ 0E98 57                           ld      D,A             ; pass char into D
 335+ 0E99 3A C9 52                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 336+ 0E9C B7                           or      A               ; is the print-on-video disabled?
 337+ 0E9D CA AD 0E                     jp      Z,PUTCHRBUF1    ; yes, so send char to input buffer
 338+ 0EA0 3A C7 52                     ld      A,(CRSR_STATE)  ; check cursor state
 339+ 0EA3 B7                           or      A               ; is it 0 (cursor OFF)?
 340+ 0EA4 C4 BA 0E                     call    NZ,PRNTFNK      ; no, print on screen
 341+ 0EA7 23           CNTFNK:         inc     HL              ; next char
 342+ 0EA8 10 E9                        djnz    LDFNKEYCHR      ; repeat for max. 16 chars
 343+ 0EAA C3 76 0E                     jp      LVKBRDCHK2      ; leave
 344+ 0EAD AF           PUTCHRBUF1:     xor     A               ; if send to input buffer,...
 345+ 0EAE 32 07 53                     ld      (KBDNPT),A      ; ...set input as from BASIC
 346+ 0EB1 7A                           ld      A,D             ; retrieve char
 347+ 0EB2 E5                           push    HL              ; store HL
 348+ 0EB3 CD F4 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 349+ 0EB6 E1                           pop     HL              ; retrieve HL
 350+ 0EB7 C3 A7 0E                     jp      CNTFNK          ; repeat
 351+ 0EBA 7A           PRNTFNK:        ld      A,D             ; recover char
 352+ 0EBB 32 CA 52                     ld      (CHR4VID),A     ; store char for printing
 353+ 0EBE 3E 01                        ld      A,$01           ; normal key - set input flag
 354+ 0EC0 32 07 53                     ld      (KBDNPT),A      ; to keyboard
 355+ 0EC3 CD 4E 07                     call    CHAR2VID        ; print on screen
 356+ 0EC6 C9                           ret                     ; return to caller
 357+ 0EC7
 358+ 0EC7
 359+ 0EC7              ;-----------------------------------------------------------------------
 360+ 0EC7 01 02 04 05  FNKEYSORD:      defb 1,2,4,5,6,22,23,24                 ; order of FN Keys
 360+ 0ECB 06 16 17 18
 361+ 0ECF              ;-----------------------------------------------------------------------
 362+ 0ECF              ; key codes
 363+ 0ECF 31 19 0E 03  KBMAP:          defb '1',25,14,3,' ',16,'q','2'         ; 25=HOME  14=CTRL  3=RUN/STOP 16=C=
 363+ 0ED3 20 10 71 32
 364+ 0ED7 33 77 61 14                  defb '3','w','a',20,'z','s','e','4'     ; 20=SHIFT
 364+ 0EDB 7A 73 65 34
 365+ 0EDF 35 72 64 78                  defb '5','r','d','x','c','f','t','6'
 365+ 0EE3 63 66 74 36
 366+ 0EE7 37 79 67 76                  defb '7','y','g','v','b','h','u','8'
 366+ 0EEB 62 68 75 38
 367+ 0EEF 39 69 6A 6E                  defb '9','i','j','n','m','k','o','0'
 367+ 0EF3 6D 6B 6F 30
 368+ 0EF7 1F 70 6C 2C                  defb 31,'p','l',',','.',':','-',30      ; 31=CURSOR DOWN  30=CURSOR UP
 368+ 0EFB 2E 3A 2D 1E
 369+ 0EFF 1C 2A 3B 2F                  defb 28,'*',';','/',27,'=','+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 369+ 0F03 1B 3D 2B 1D
 370+ 0F07 08 0D FC 40                  defb 8,13,252,'@',1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 370+ 0F0B 01 02 04 18
 371+ 0F0F
 372+ 0F0F              ; shifted codes - not all the keys have the shifted version
 373+ 0F0F 21 0C 0E 03  KBMAP_SFT:      defb '!',12,14,3,' ',16,'Q',34          ; 12=CLEAR  14=CTRL  3=RUN/STOP 16=C=   34="
 373+ 0F13 20 10 51 22
 374+ 0F17 23 57 41 14                  defb '#','W','A',20,'Z','S','E','$'     ; 20=SHIFT
 374+ 0F1B 5A 53 45 24
 375+ 0F1F 25 52 44 58                  defb '%','R','D','X','C','F','T','&'
 375+ 0F23 43 46 54 26
 376+ 0F27 27 59 47 56                  defb 39,'Y','G','V','B','H','U','('     ; 39='
 376+ 0F2B 42 48 55 28
 377+ 0F2F 29 49 4A 4E                  defb ')','I','J','N','M','K','O',94     ; 94=^
 377+ 0F33 4D 4B 4F 5E
 378+ 0F37 1F 50 4C 3C                  defb 31,'P','L','<','>','[','_',30      ; 31=CURSOR DOWN  30=CURSOR UP
 378+ 0F3B 3E 5B 5F 1E
 379+ 0F3F 1C 2A 5D 3F                  defb 28,'*',']','?',27,198,'+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 379+ 0F43 1B C6 2B 1D
 380+ 0F47 1A 0D D3 40                  defb 26,13,211,'@',5,6,22,23            ; 26=INSERT, 211=â¬  5=F4  6=F5  22=F6  23=F7
 380+ 0F4B 05 06 16 17
 381+ 0F4F
 382+ 0F4F              ; ALT (C=) codes - not all the keys have the alt-ed version
 383+ 0F4F 31 0C 0E 03  KBMAP_ALT:      defb '1',12,14,3,' ',16,222,196         ; 12=CLEAR  14=CTRL  3=RUN/STOP  16=C=  34="
 383+ 0F53 20 10 DE C4
 384+ 0F57 33 DD 85 14                  defb '3',221,133,20,131,130,165,'4'     ; 20=SHIFT
 384+ 0F5B 83 82 A5 34
 385+ 0F5F 35 A2 A6 84                  defb '5',162,166,132,157,163,168,'6'
 385+ 0F63 9D A3 A8 36
 386+ 0F67 37 AB A9 A1                  defb '7',171,169,161,158,172,213,'8'    ;
 386+ 0F6B 9E AC D5 38
 387+ 0F6F 39 D6 D8 9F                  defb '9',214,216,159,160,215,135,195    ;
 387+ 0F73 A0 D7 87 C3
 388+ 0F77 1F 88 8A C1                  defb 31,136,138,193,192,123,144,30      ; 31=CURSOR DOWN  123={  30=CURSOR UP
 388+ 0F7B C0 7B 90 1E
 389+ 0F7F 1C 8F 7D FE                  defb 28,143,125,254,27,209,148,29       ; 28=CURSOR LEFT  125=}  27=ESCAPE  29=CURSOR RIGHT
 389+ 0F83 1B D1 94 1D
 390+ 0F87 08 0D E0 89                  defb 8,13,224,137,5,6,22,23             ; 8=DEL(backspace)  13=RETURN  252=Â£  5=F4  6=F5  22=F6  23=F7
 390+ 0F8B 05 06 16 17
 391+ 0F8F
 392+ 0F8F              ; CTRL codes - not all the keys have the control-ed version
 393+ 0F8F 31 19 0E 03  KBMAP_CTRL:     defb '1',25,14,3,' ',16,154,'2'         ; 25=HOME  14=CTRL  3=RUN/STOP  16=C=
 393+ 0F93 20 10 9A 32
 394+ 0F97 33 9C 95 14                  defb '3',156,149,20,152,150,153,'4'     ; 20=SHIFT
 394+ 0F9B 98 96 99 34
 395+ 0F9F 35 9B B0 97                  defb '5',155,176,151,177,175,165,'6'
 395+ 0FA3 B1 AF A5 36
 396+ 0FA7 37 A6 A8 B2                  defb '7',166,168,178,179,169,167,'8'
 396+ 0FAB B3 A9 A7 38
 397+ 0FAF 39 B8 AA AC                  defb '9',184,170,172,171,181,164,'0'
 397+ 0FB3 AB B5 A4 30
 398+ 0FB7 1F A3 AD 2C                  defb 31,163,173,',','.',':',186,30      ; 31=CURSOR DOWN  30=CURSOR UP
 398+ 0FBB 2E 3A BA 1E
 399+ 0FBF 1C E1 3B 2F                  defb 28,225,';','/',27,212,185,29       ; 28=CURSOR LEFT  27=ESCAPE  212=Ï  29=CURSOR RIGHT
 399+ 0FC3 1B D4 B9 1D
 400+ 0FC7 08 0D BD A2                  defb 8,13,189,162,1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 400+ 0FCB 01 02 04 18
# file closed: ../include/psg/psg-1.1.asm
  76  0FCF
  77  0FCF              ; include the latest version of the LM80C 64K BASIC interpreter
  78  0FCF                  INCLUDE "../include/basic/basic-1.03.asm"
# file opened: ../include/basic/basic-1.03.asm
   1+ 0FCF              ; ------------------------------------------------------------------------------
   2+ 0FCF              ; LM80C BASIC (32K/64K) - R3.17
   3+ 0FCF              ; ------------------------------------------------------------------------------
   4+ 0FCF              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0FCF              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0FCF              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0FCF              ; kind of warranty: you can use them at your own risk.
   8+ 0FCF              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0FCF              ; maintain the copyright notices, include this advice and the note to the
  10+ 0FCF              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0FCF              ; redistribuite them.
  12+ 0FCF              ; https://www.leonardomiliani.com
  13+ 0FCF              ;
  14+ 0FCF              ; Please support me by visiting the following links:
  15+ 0FCF              ; Main project page: https://www.leonardomiliani.com
  16+ 0FCF              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0FCF              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0FCF              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0FCF              ; ------------------------------------------------------------------------------
  20+ 0FCF              ; LM80C BASIC 64K - originally based on the following NASCOM BASIC versions:
  21+ 0FCF              ; 4.7  - original version by NASCOM/MICROSOFT
  22+ 0FCF              ; 4.7b - modified version by Grant Searle (additional commands & functions)
  23+ 0FCF
  24+ 0FCF
  25+ 0FCF              ;------------------------------------------------------------------------------
  26+ 0FCF              ;  L M 8 0 C   B A S I C
  27+ 0FCF              ;------------------------------------------------------------------------------
  28+ 0FCF
  29+ 0FCF              ; GENERAL EQUATES
  30+ 0FCF
  31+ 0FCF              NLLCR           equ     $00             ; null char (used as space/empty char in video prints)
  32+ 0FCF              CTRLC           equ     $03             ; Control "C"
  33+ 0FCF              CTRLG           equ     $07             ; Control "G"
  34+ 0FCF              BKSP            equ     $08             ; Back space
  35+ 0FCF              LF              equ     $0A             ; Line feed
  36+ 0FCF              CS              equ     $0C             ; Clear screen
  37+ 0FCF              CR              equ     $0D             ; Carriage return
  38+ 0FCF              CTRLO           equ     $0F             ; Control "O"
  39+ 0FCF              CTRLQ           equ     $11             ; Control "Q"
  40+ 0FCF              CTRLR           equ     $12             ; Control "R"
  41+ 0FCF              CTRLS           equ     $13             ; Control "S"
  42+ 0FCF              CTRLU           equ     $15             ; Control "U"
  43+ 0FCF              HOME            equ     $19             ; Home (cursor at 0,0)
  44+ 0FCF              ESC             equ     $1B             ; Escape
  45+ 0FCF              SPC             equ     $20             ; Space
  46+ 0FCF              DEL             equ     $7F             ; Delete
  47+ 0FCF              INSRT           equ     $1A             ; Insert Key
  48+ 0FCF              ; cursor ASCII codes
  49+ 0FCF              CRSLFT          equ     $1C             ; cursor left
  50+ 0FCF              CRSRGT          equ     $1D             ; cursor right
  51+ 0FCF              CRSUP           equ     $1E             ; cursor up
  52+ 0FCF              CRSDN           equ     $1F             ; cursor down
  53+ 0FCF
  54+ 0FCF
  55+ 0FCF              ;-------------------------------------------------------------------------
  56+ 0FCF              ; BASIC ERROR MESSAGES
  57+ 0FCF              ; the interpreter looks for a single-byte code in the following list,
  58+ 0FCF              ; then loads the corresponding memory pointer in "ERRTBL" table to
  59+ 0FCF              ; find where to retrieve the message text in "ERRORS"
  60+ 0FCF
  61+ 0FCF              ; BASIC ERROR CODE VALUES
  62+ 0FCF              ; These values act as an offset to point to the error message into the error table
  63+ 0FCF              ; must be incremented by 2 because they point to a word address jump
  64+ 0FCF              NF              equ     $00     ; NEXT without FOR
  65+ 0FCF              SN              equ     $02     ; Syntax error
  66+ 0FCF              RG              equ     $04     ; RETURN without GOSUB
  67+ 0FCF              OD              equ     $06     ; Out of DATA
  68+ 0FCF              FC              equ     $08     ; Function call error
  69+ 0FCF              OV              equ     $0A     ; Overflow
  70+ 0FCF              OM              equ     $0C     ; Out of memory
  71+ 0FCF              UL              equ     $0E     ; Undefined line number
  72+ 0FCF              BS              equ     $10     ; Bad subscript
  73+ 0FCF              DD              equ     $12     ; Re-Dimensioned array
  74+ 0FCF              DZ              equ     $14     ; Division by zero (/0)
  75+ 0FCF              ID              equ     $16     ; Illegal direct
  76+ 0FCF              TM              equ     $18     ; Type mis-match
  77+ 0FCF              OS              equ     $1A     ; Out of string space
  78+ 0FCF              LS              equ     $1C     ; String too long
  79+ 0FCF              ST              equ     $1E     ; String formula too complex
  80+ 0FCF              CN              equ     $20     ; Can't continue
  81+ 0FCF              UF              equ     $22     ; Undefined FN function
  82+ 0FCF              MO              equ     $24     ; Missing operand
  83+ 0FCF              HX              equ     $26     ; HEX error
  84+ 0FCF              BN              equ     $28     ; BIN error
  85+ 0FCF              GM              equ     $2A     ; No Graphics Mode
  86+ 0FCF              SC              equ     $2C     ; Serial configuration
  87+ 0FCF              SA              equ     $2E     ; Serial port already open
  88+ 0FCF              SO              equ     $30     ; Serial buffer overrun
  89+ 0FCF              HP              equ     $32     ; HELP call
  90+ 0FCF
  91+ 0FCF              ; BASIC ERROR POINTER TABLE
  92+ 0FCF              ERRTBL: equ $
  93+ 0FCF 03 10        NFPTR:  defw    NFMSG
  94+ 0FD1 14 10        SNPTR:  defw    SNMSG
  95+ 0FD3 1B 10        RGPTR:  defw    RGMSG
  96+ 0FD5 30 10        ODPTR:  defw    ODMSG
  97+ 0FD7 3C 10        FCPTR:  defw    FCMSG
  98+ 0FD9 52 10        OVPTR:  defw    OVMSG
  99+ 0FDB 5B 10        OMPTR:  defw    OMMSG
 100+ 0FDD 69 10        ULPTR:  defw    ULMSG
 101+ 0FDF 78 10        BSPTR:  defw    BSMSG
 102+ 0FE1 86 10        DDPTR:  defw    DDMSG
 103+ 0FE3 9B 10        DZPTR:  defw    DZMSG
 104+ 0FE5 AC 10        IDPTR:  defw    IDMSG
 105+ 0FE7 BB 10        TMPTR:  defw    TMMSG
 106+ 0FE9 CA 10        OSPTR:  defw    OSMSG
 107+ 0FEB DE 10        LSPTR:  defw    LSMSG
 108+ 0FED EE 10        STPTR:  defw    STMSG
 109+ 0FEF 09 11        CNPTR:  defw    CNMSG
 110+ 0FF1 18 11        UFPTR:  defw    UFMSG
 111+ 0FF3 2E 11        MOPTR:  defw    MOMSG
 112+ 0FF5 3E 11        HXPTR:  defw    HXMSG
 113+ 0FF7 49 11        BNPTR:  defw    BNMSG
 114+ 0FF9 54 11        GMPRT:  defw    GMMSG
 115+ 0FFB 65 11        SCPTR:  defw    SCMSG
 116+ 0FFD 7A 11        SAPTR:  defw    SAMSG
 117+ 0FFF 93 11        SOPTR:  defw    SOMSG
 118+ 1001 A9 11        HPPTR:  defw    HPMSG
 119+ 1003
 120+ 1003              ; BASIC ERROR MESSAGE LIST
 121+ 1003              ERRORS  equ $
 122+ 1003 4E 45 58 54  NFMSG:  defb    "NEXT Without FOR",0
 122+ 1007 20 57 69 74
 122+ 100B 68 6F 75 74
 122+ 100F 20 46 4F 52
 122+ 1013 00
 123+ 1014 53 79 6E 74  SNMSG:  defb    "Syntax",0
 123+ 1018 61 78 00
 124+ 101B 52 45 54 55  RGMSG:  defb    "RETURN without GOSUB",0
 124+ 101F 52 4E 20 77
 124+ 1023 69 74 68 6F
 124+ 1027 75 74 20 47
 124+ 102B 4F 53 55 42
 124+ 102F 00
 125+ 1030 4F 75 74 20  ODMSG:  defb    "Out of DATA",0
 125+ 1034 6F 66 20 44
 125+ 1038 41 54 41 00
 126+ 103C 49 6C 6C 65  FCMSG:  defb    "Illegal Function Call",0
 126+ 1040 67 61 6C 20
 126+ 1044 46 75 6E 63
 126+ 1048 74 69 6F 6E
 126+ 104C 20 43 61 6C
 126+ 1050 6C 00
 127+ 1052 4F 76 65 72  OVMSG:  defb    "Overflow",0
 127+ 1056 66 6C 6F 77
 127+ 105A 00
 128+ 105B 4F 75 74 20  OMMSG:  defb    "Out of Memory",0
 128+ 105F 6F 66 20 4D
 128+ 1063 65 6D 6F 72
 128+ 1067 79 00
 129+ 1069 55 6E 64 65  ULMSG:  defb    "Undefined Line",0
 129+ 106D 66 69 6E 65
 129+ 1071 64 20 4C 69
 129+ 1075 6E 65 00
 130+ 1078 42 61 64 20  BSMSG:  defb    "Bad Subscript",0
 130+ 107C 53 75 62 73
 130+ 1080 63 72 69 70
 130+ 1084 74 00
 131+ 1086 52 65 2D 44  DDMSG:  defb    "Re-Dimensioned Array",0
 131+ 108A 69 6D 65 6E
 131+ 108E 73 69 6F 6E
 131+ 1092 65 64 20 41
 131+ 1096 72 72 61 79
 131+ 109A 00
 132+ 109B 44 69 76 69  DZMSG:  defb    "Division by Zero",0
 132+ 109F 73 69 6F 6E
 132+ 10A3 20 62 79 20
 132+ 10A7 5A 65 72 6F
 132+ 10AB 00
 133+ 10AC 49 6C 6C 65  IDMSG:  defb    "Illegal Direct",0
 133+ 10B0 67 61 6C 20
 133+ 10B4 44 69 72 65
 133+ 10B8 63 74 00
 134+ 10BB 54 79 70 65  TMMSG:  defb    "Type Mis-match",0
 134+ 10BF 20 4D 69 73
 134+ 10C3 2D 6D 61 74
 134+ 10C7 63 68 00
 135+ 10CA 4F 75 74 20  OSMSG:  defb    "Out of String Space",0
 135+ 10CE 6F 66 20 53
 135+ 10D2 74 72 69 6E
 135+ 10D6 67 20 53 70
 135+ 10DA 61 63 65 00
 136+ 10DE 53 74 72 69  LSMSG:  defb    "String Too Long",0
 136+ 10E2 6E 67 20 54
 136+ 10E6 6F 6F 20 4C
 136+ 10EA 6F 6E 67 00
 137+ 10EE 53 74 72 69  STMSG:  defb    "String Formula Too Complex",0
 137+ 10F2 6E 67 20 46
 137+ 10F6 6F 72 6D 75
 137+ 10FA 6C 61 20 54
 137+ 10FE 6F 6F 20 43
 137+ 1102 6F 6D 70 6C
 137+ 1106 65 78 00
 138+ 1109 43 61 6E 27  CNMSG:  defb    "Can't Continue",0
 138+ 110D 74 20 43 6F
 138+ 1111 6E 74 69 6E
 138+ 1115 75 65 00
 139+ 1118 55 6E 64 65  UFMSG:  defb    "Undefined FN Function",0
 139+ 111C 66 69 6E 65
 139+ 1120 64 20 46 4E
 139+ 1124 20 46 75 6E
 139+ 1128 63 74 69 6F
 139+ 112C 6E 00
 140+ 112E 4D 69 73 73  MOMSG:  defb    "Missing Operand",0
 140+ 1132 69 6E 67 20
 140+ 1136 4F 70 65 72
 140+ 113A 61 6E 64 00
 141+ 113E 48 45 58 20  HXMSG:  defb    "HEX Format",0
 141+ 1142 46 6F 72 6D
 141+ 1146 61 74 00
 142+ 1149 42 49 4E 20  BNMSG:  defb    "BIN Format",0
 142+ 114D 46 6F 72 6D
 142+ 1151 61 74 00
 143+ 1154 4E 6F 20 47  GMMSG:  defb    "No Graphics Mode",0
 143+ 1158 72 61 70 68
 143+ 115C 69 63 73 20
 143+ 1160 4D 6F 64 65
 143+ 1164 00
 144+ 1165 53 65 72 69  SCMSG:  defb    "Serial Configuration",0
 144+ 1169 61 6C 20 43
 144+ 116D 6F 6E 66 69
 144+ 1171 67 75 72 61
 144+ 1175 74 69 6F 6E
 144+ 1179 00
 145+ 117A 53 65 72 69  SAMSG:  defb    "Serial Port Already Open",0
 145+ 117E 61 6C 20 50
 145+ 1182 6F 72 74 20
 145+ 1186 41 6C 72 65
 145+ 118A 61 64 79 20
 145+ 118E 4F 70 65 6E
 145+ 1192 00
 146+ 1193 53 65 72 69  SOMSG:  defb    "Serial Buffer Overrun",0
 146+ 1197 61 6C 20 42
 146+ 119B 75 66 66 65
 146+ 119F 72 20 4F 76
 146+ 11A3 65 72 72 75
 146+ 11A7 6E 00
 147+ 11A9 48 45 4C 50  HPMSG:  defb    "HELP Call",0
 147+ 11AD 20 43 61 6C
 147+ 11B1 6C 00
 148+ 11B3
 149+ 11B3
 150+ 11B3              ;-----------------------------------------------------------------------------
 151+ 11B3              ; STARTING POINTS FOR BASIC BOOT
 152+ 11B3              ; COLD: reset every memory pointer, acting as a power-up boot
 153+ 11B3              ; WARM: preserve program in memory, keeping every current pointer
 154+ 11B3
 155+ 11B3 C3 B9 11     COLD:   jp      STARTB          ; Jump for cold start
 156+ 11B6 C3 67 12     WARM:   jp      WARMST          ; Jump for warm start
 157+ 11B9
 158+ 11B9 C3 C0 11     STARTB: jp      CSTART          ; Jump to initialise
 159+ 11BC 74 1C                defw    DEINT           ; Get integer -32768 to 32767
 160+ 11BE 31 24                defw    ABPASS          ; Return integer in AB
 161+ 11C0 21 4D 51     CSTART: ld      HL,WRKSPC       ; Start of workspace RAM
 162+ 11C3 F9                   ld      SP,HL           ; Set up a temporary stack
 163+ 11C4 C3 73 3F             jp      INITST          ; Go to initialise
 164+ 11C7
 165+ 11C7 21 34 15     INIT:   ld      HL,INITAB       ; Initialise workspace
 166+ 11CA 01 DC 00             ld      BC,INITBE-INITAB+3; Bytes to copy
 167+ 11CD 11 4D 51             ld      DE,WRKSPC       ; Into workspace RAM
 168+ 11D0 ED B0                ldir                    ; Copy data
 169+ 11D2 EB                   ex      DE,HL           ; Copy DE into HL
 170+ 11D3 F9                   ld      SP,HL           ; Temporary stack
 171+ 11D4 CD E7 17             call    CLREG           ; Clear registers and stack
 172+ 11D7 CD 8B 1E             call    PRNTCRLF        ; Output CRLF
 173+ 11DA 32 80 52             ld      (BUFFER+88+1),A ; Mark end of buffer
 174+ 11DD 32 36 53             ld      (PROGST),A      ; Initialise program area
 175+ 11E0 18 13                jr      MNOASK          ; usually, don't ask for memory top (only when there are errors)
 176+ 11E2 21 CE 12     MSIZE:  ld      HL,MEMMSG       ; Point to message
 177+ 11E5 CD 4F 25             call    PRS             ; Output "Memory size"
 178+ 11E8 CD 04 18             call    PROMPT          ; Get input with '?'
 179+ 11EB CD EA 08             call    CURSOR_ON       ; enable cursor
 180+ 11EE CD BE 1B             call    GETCHR          ; Get next character
 181+ 11F1 B7                   or      A               ; Set flags
 182+ 11F2 C2 0A 12             jp      NZ,TSTMEM       ; If number - Test if RAM there
 183+ 11F5 21 9A 53     MNOASK: ld      HL,STLOOK       ; Point to start of RAM
 184+ 11F8 23           MLOOP:  inc     HL              ; Next byte
 185+ 11F9 7C                   ld      A,H             ; Above address FFFF ?
 186+ 11FA B5                   or      L
 187+ 11FB CA 1C 12             jp      Z,SETTOP        ; Yes - 64K RAM
 188+ 11FE 7E                   ld      A,(HL)          ; Get contents
 189+ 11FF 47                   ld      B,A             ; Save it
 190+ 1200 2F                   cpl                     ; Flip all bits
 191+ 1201 77                   ld      (HL),A          ; Put it back
 192+ 1202 BE                   cp      (HL)            ; RAM there if same
 193+ 1203 70                   ld      (HL),B          ; Restore old contents
 194+ 1204 CA F8 11             jp      Z,MLOOP         ; If RAM - test next byte
 195+ 1207 C3 1C 12             jp      SETTOP          ; Top of RAM found
 196+ 120A
 197+ 120A CD 8E 1C     TSTMEM: call    ATOH            ; Get high memory into DE
 198+ 120D B7                   or      A               ; Set flags on last byte
 199+ 120E C2 9B 16             jp      NZ,SNERR        ; ?SN Error if bad character
 200+ 1211 EB                   ex      DE,HL           ; Address into HL
 201+ 1212 2B                   dec     HL              ; Back one byte
 202+ 1213 3E D9                ld      A,%11011001     ; Test byte
 203+ 1215 46                   ld      B,(HL)          ; Get old contents
 204+ 1216 77                   ld      (HL),A          ; Load test byte
 205+ 1217 BE                   cp      (HL)            ; RAM there if same
 206+ 1218 70                   ld      (HL),B          ; Restore old contents
 207+ 1219 C2 E2 11             jp      NZ,MSIZE        ; Ask again if no RAM
 208+ 121C
 209+ 121C CD FF 08     SETTOP: call    CURSOR_OFF      ; disable cursor
 210+ 121F 2B                   dec     HL              ; Back one byte
 211+ 1220 11 99 53             ld      DE,STLOOK-1     ; See if enough RAM
 212+ 1223 CD 77 19             call    CPDEHL          ; Compare DE with HL
 213+ 1226 DA E2 11             jp      C,MSIZE         ; Ask again if not enough RAM
 214+ 1229 3A 12 53             ld      A,(DOS_EN)      ; read if the user enabled/disabled DOS while booting
 215+ 122C 1F                   rra                     ; is DOS disabled?
 216+ 122D 30 04                jr      NC,NODOS        ; yes, so jump over
 217+ 122F 11 00 FE             ld      DE,0-512        ; no, so reserve 512 bytes on top of RAM...
 218+ 1232 19                   add     HL,DE           ; ...for I/O buffer
 219+ 1233 11 9C FF     NODOS:  ld      DE,0-100        ; 100 Bytes string space
 220+ 1236 22 85 52             ld      (LSTRAM),HL     ; Save last available RAM
 221+ 1239 19                   add     HL,DE           ; Allocate string space
 222+ 123A 22 9C 51             ld      (STRSPC),HL     ; Save string space
 223+ 123D CD C2 17             call    CLRPTR          ; Clear program area
 224+ 1240 2A 9C 51             ld      HL,(STRSPC)     ; Get end of memory
 225+ 1243 11 EF FF             ld      DE,0-17         ; Offset for free bytes
 226+ 1246 19                   add     HL,DE           ; Adjust HL
 227+ 1247 11 36 53             ld      DE,PROGST       ; Start of program text
 228+ 124A 7D                   ld      A,L             ; Get LSB
 229+ 124B 93                   sub     E               ; Adjust it
 230+ 124C 6F                   ld      L,A             ; Re-save
 231+ 124D 7C                   ld      A,H             ; Get MSB
 232+ 124E 9A                   sbc     A,D             ; Adjust it
 233+ 124F 67                   ld      H,A             ; Re-save
 234+ 1250 E5                   push    HL              ; Save bytes free
 235+ 1251 21 8D 12             ld      HL,SIGNON       ; Sign-on message
 236+ 1254 CD 4F 25             call    PRS             ; Output string
 237+ 1257 21 76 12             ld      HL,BLNSPC       ; Empty space
 238+ 125A CD 4F 25             call    PRS             ; Output string
 239+ 125D E1                   pop     HL              ; Get bytes free back
 240+ 125E CD EE 2F             call    PRNTHL          ; Output amount of free memory
 241+ 1261 21 7F 12             ld      HL,BFREE        ; " Bytes free" message
 242+ 1264 CD 4F 25             call    PRS             ; Output string
 243+ 1267
 244+ 1267 31 2C 52     WARMST: ld      SP,STACK        ; Temporary stack
 245+ 126A CD E7 17     BRKRET: call    CLREG           ; Clear registers and stack
 246+ 126D CD 0A 3D             call    RESFN           ; reset FN keys and auto-repeat
 247+ 1270 CD EA 08             call    CURSOR_ON       ; enable cursor
 248+ 1273 C3 F5 16             jp      PRNTOK          ; Go to get command line
 249+ 1276
 250+ 1276 20 20 20 20  BLNSPC: defb    "        ",0    ; 8 empty cells to align the "XXXX Bytes free" message
 250+ 127A 20 20 20 20
 250+ 127E 00
 251+ 127F 20 42 79 74  BFREE:  defb    " Bytes free",CR,CR,0
 251+ 1283 65 73 20 66
 251+ 1287 72 65 65 0D
 251+ 128B 0D 00
 252+ 128D
 253+ 128D 4C 4D 38 30  SIGNON: defb    "LM80C BASIC 3.17 ",251,"2021 L.Miliani"
 253+ 1291 43 20 42 41
 253+ 1295 53 49 43 20
 253+ 1299 33 2E 31 37
 253+ 129D 20 FB 32 30
 253+ 12A1 32 31 20 4C
 253+ 12A5 2E 4D 69 6C
 253+ 12A9 69 61 6E 69
 254+ 12AD 20 5A 38 30          defb    " Z80 BASIC 4.7  ",251,"1978 Microsoft",CR,0
 254+ 12B1 20 42 41 53
 254+ 12B5 49 43 20 34
 254+ 12B9 2E 37 20 20
 254+ 12BD FB 31 39 37
 254+ 12C1 38 20 4D 69
 254+ 12C5 63 72 6F 73
 254+ 12C9 6F 66 74 0D
 254+ 12CD 00
 255+ 12CE
 256+ 12CE 4D 65 6D 6F  MEMMSG: defb    "Memory top",0
 256+ 12D2 72 79 20 74
 256+ 12D6 6F 70 00
 257+ 12D9
 258+ 12D9              ; The following list reports all the functions supported by the interpreter.
 259+ 12D9              ; To add a custom function, the user must first insert the reserved word here,
 260+ 12D9              ; then into the list of the reserved words below, and finally must increment the
 261+ 12D9              ; ZSGN token value and all the following ones after ZSGN by 1 for every added
 262+ 12D9              ; function.
 263+ 12D9
 264+ 12D9              ; FUNCTION ADDRESS TABLE (this is a sort of offset table)
 265+ 12D9              ; this list must be coherent with the tokens' functions list. This means that every
 266+ 12D9              ; entry here must have the corresponding entry in the tokens list.
 267+ 12D9 63 2E        FNCTAB: defw    SGN
 268+ 12DB F9 23                defw    TMR         ; added by Leonardo Miliani
 269+ 12DD 27 2F                defw    INT
 270+ 12DF 79 2E                defw    ABS_        ; _ necessary for assembler warning
 271+ 12E1 53 51                defw    USR
 272+ 12E3 0F 24                defw    FRE
 273+ 12E5 8A 28                defw    INP
 274+ 12E7 3D 24                defw    POS
 275+ 12E9 ED 30                defw    SQR
 276+ 12EB CC 31                defw    RND
 277+ 12ED B7 2C                defw    LOG
 278+ 12EF 3B 31                defw    EXP
 279+ 12F1 41 32                defw    COS
 280+ 12F3 47 32                defw    SIN
 281+ 12F5 A8 32                defw    TAN
 282+ 12F7 BD 32                defw    ATN
 283+ 12F9 66 29                defw    PEEK
 284+ 12FB 28 33                defw    DEEK
 285+ 12FD 6D 29                defw    VPEEK       ; added by Leonardo Miliani
 286+ 12FF 3C 2B                defw    VSTAT       ; added by Leonardo Miliani
 287+ 1301 47 2B                defw    SSTAT       ; added by Leonardo Miliani
 288+ 1303 5B 2B                defw    INKEY       ; added by Leonardo Miliani
 289+ 1305 7F 36                defw    POINT       ; added by Leonardo Miliani
 290+ 1307 21 27                defw    INSTR       ; added by Leonardo Miliani
 291+ 1309 C1 26                defw    LEN
 292+ 130B D9 24                defw    STR
 293+ 130D 51 28                defw    VAL
 294+ 130F D0 26                defw    ASC
 295+ 1311 E1 26                defw    CHR
 296+ 1313 6E 3E                defw    HEX         ; added by Grant Searle
 297+ 1315 FF 3E                defw    BIN         ; added by Grant Searle
 298+ 1317 F1 26                defw    LEFT
 299+ 1319 17 28                defw    RIGHT
 300+ 131B 21 28                defw    MID
 301+ 131D
 302+ 131D              ; RESERVED WORD LIST
 303+ 131D              ; Here are all the reserved words used by the interpreter
 304+ 131D              ; To add custom functions/commands, the user must insert the keyword
 305+ 131D              ; in this list, following the schematic
 306+ 131D C5 4E 44     WORDS:  defb    'E'+$80,"ND"            ; from here the list contains the COMMANDS
 307+ 1320 C6 4F 52             defb    'F'+$80,"OR"
 308+ 1323 CE 45 58 54          defb    'N'+$80,"EXT"
 309+ 1327 C4 41 54 41          defb    'D'+$80,"ATA"
 310+ 132B C9 4E 50 55          defb    'I'+$80,"NPUT"
 310+ 132F 54
 311+ 1330 C4 49 4D             defb    'D'+$80,"IM"
 312+ 1333 D2 45 41 44          defb    'R'+$80,"EAD"
 313+ 1337 CC 45 54             defb    'L'+$80,"ET"
 314+ 133A C7 4F 54 4F          defb    'G'+$80,"OTO"
 315+ 133E D2 55 4E             defb    'R'+$80,"UN"
 316+ 1341 C9 46                defb    'I'+$80,"F"
 317+ 1343 D2 45 53 54          defb    'R'+$80,"ESTORE"
 317+ 1347 4F 52 45
 318+ 134A C7 4F 53 55          defb    'G'+$80,"OSUB"
 318+ 134E 42
 319+ 134F D2 45 54 55          defb    'R'+$80,"ETURN"
 319+ 1353 52 4E
 320+ 1355 D2 45 4D             defb    'R'+$80,"EM"            ; original REM
 321+ 1358 D3 54 4F 50          defb    'S'+$80,"TOP"
 322+ 135C CF 55 54             defb    'O'+$80,"UT"
 323+ 135F CF 4E                defb    'O'+$80,"N"
 324+ 1361 C6 49 4C 45          defb    'F'+$80,"ILES"
 324+ 1365 53
 325+ 1366 C5 52 41 53          defb    'E'+$80,"RASE"          ; added by Leonardo Miliani
 325+ 136A 45
 326+ 136B D7 41 49 54          defb    'W'+$80,"AIT"
 327+ 136F C4 45 46             defb    'D'+$80,"EF"
 328+ 1372 D0 4F 4B 45          defb    'P'+$80,"OKE"
 329+ 1376 C4 4F 4B 45          defb    'D'+$80,"OKE"
 330+ 137A D6 50 4F 4B          defb    'V'+$80,"POKE"          ; added by Leonardo Miliani
 330+ 137E 45
 331+ 137F D3 52 45 47          defb    'S'+$80,"REG"           ; added by Leonardo Miliani
 332+ 1383 D6 52 45 47          defb    'V'+$80,"REG"           ; added by Leonardo Miliani
 333+ 1387 D3 43 52 45          defb    'S'+$80,"CREEN"         ; changed by Leonardo Miliani
 333+ 138B 45 4E
 334+ 138D CC 4F 43 41          defb    'L'+$80,"OCATE"         ; added by Leonardo Miliani
 334+ 1391 54 45
 335+ 1393 D3 4F 55 4E          defb    'S'+$80,"OUND"          ; added by Leonardo Miliani
 335+ 1397 44
 336+ 1398 D6 4F 4C 55          defb    'V'+$80,"OLUME"         ; added by Leonardo Miliani
 336+ 139C 4D 45
 337+ 139E D0 41 55 53          defb    'P'+$80,"AUSE"          ; added by Leonardo Miliani
 337+ 13A2 45
 338+ 13A3 C3 4F 4C 4F          defb    'C'+$80,"OLOR"          ; added by Leonardo Miliani
 338+ 13A7 52
 339+ 13A8 D0 4C 4F 54          defb    'P'+$80,"LOT"           ; added by Leonardo Miliani
 340+ 13AC C4 52 41 57          defb    'D'+$80,"RAW"           ; added by Leonardo Miliani
 341+ 13B0 C3 49 52 43          defb    'C'+$80,"IRCLE"         ; added by Leonardo Miliani
 341+ 13B4 4C 45
 342+ 13B6 D0 41 49 4E          defb    'P'+$80,"AINT"          ; added by Leonardo Miliani
 342+ 13BA 54
 343+ 13BB D3 45 52 49          defb    'S'+$80,"ERIAL"         ; added by Leonardo Miliani
 343+ 13BF 41 4C
 344+ 13C1 C8 45 4C 50          defb    'H'+$80,"ELP"           ; changed by Leonardo Miliani - was LINES
 345+ 13C5 C3 4C 53             defb    'C'+$80,"LS"            ; restored command
 346+ 13C8 CB 45 59             defb    'K'+$80,"EY"            ; added by Leonardo Miliani
 347+ 13CB CE 4D 49             defb    'N'+$80,"MI"            ; added by Leonardo Miliani
 348+ 13CE C7 50 52 49          defb    'G'+$80,"PRINT"         ; added by Leonardo Miliani
 348+ 13D2 4E 54
 349+ 13D4 D7 49 44 54          defb    'W'+$80,"IDTH"
 349+ 13D8 48
 350+ 13D9 D3 59 53             defb    'S'+$80,"YS"            ; added by Leonardo Miliani
 351+ 13DC D2 45 53 45          defb    'R'+$80,"ESET"          ; changed by Leonardo Miliani
 351+ 13E0 54
 352+ 13E1 C5 4C 53 45          defb    'E'+$80,"LSE"           ; added by Leonardo Miliani
 353+ 13E5 D0 52 49 4E          defb    'P'+$80,"RINT"
 353+ 13E9 54
 354+ 13EA C3 4F 4E 54          defb    'C'+$80,"ONT"
 355+ 13EE CC 49 53 54          defb    'L'+$80,"IST"
 356+ 13F2 C3 4C 45 41          defb    'C'+$80,"LEAR"
 356+ 13F6 52
 357+ 13F7 CC 4F 41 44          defb    'L'+$80,"OAD"
 358+ 13FB D3 41 56 45          defb    'S'+$80,"AVE"
 359+ 13FF CE 45 57             defb    'N'+$80,"EW"
 360+ 1402 D4 41 42 28          defb    'T'+$80,"AB("
 361+ 1406 D4 4F                defb    'T'+$80,"O"
 362+ 1408 C6 4E                defb    'F'+$80,"N"
 363+ 140A D3 50 43 28          defb    'S'+$80,"PC("
 364+ 140E D4 48 45 4E          defb    'T'+$80,"HEN"
 365+ 1412 CE 4F 54             defb    'N'+$80,"OT"
 366+ 1415 D3 54 45 50          defb    'S'+$80,"TEP"
 367+ 1419                      ; from here: operators
 368+ 1419 AB                   defb    '+'+$80
 369+ 141A AD                   defb    '-'+$80
 370+ 141B AA                   defb    '*'+$80
 371+ 141C AF                   defb    '/'+$80
 372+ 141D A5                   defb    '%'+$80
 373+ 141E A3                   defb    '#'+$80
 374+ 141F DE                   defb    '^'+$80
 375+ 1420 C1 4E 44             defb    'A'+$80,"ND"
 376+ 1423 D8 4F 52             defb    'X'+$80,"OR"
 377+ 1426 CF 52                defb    'O'+$80,"R"
 378+ 1428 BE                   defb    '>'+$80
 379+ 1429 BD                   defb    '='+$80
 380+ 142A BC                   defb    '<'+$80
 381+ 142B
 382+ 142B                      ; from here there are the tokens' FUNCTIONS list
 383+ 142B                      ; this list must be coherent with the functions list above
 384+ 142B D3 47 4E             defb    'S'+$80,"GN"
 385+ 142E D4 4D 52             defb    'T'+$80,"MR"            ; added by Leonardo Miliani
 386+ 1431 C9 4E 54             defb    'I'+$80,"NT"
 387+ 1434 C1 42 53             defb    'A'+$80,"BS"
 388+ 1437 D5 53 52             defb    'U'+$80,"SR"
 389+ 143A C6 52 45             defb    'F'+$80,"RE"
 390+ 143D C9 4E 50             defb    'I'+$80,"NP"
 391+ 1440 D0 4F 53             defb    'P'+$80,"OS"
 392+ 1443 D3 51 52             defb    'S'+$80,"QR"
 393+ 1446 D2 4E 44             defb    'R'+$80,"ND"
 394+ 1449 CC 4F 47             defb    'L'+$80,"OG"
 395+ 144C C5 58 50             defb    'E'+$80,"XP"
 396+ 144F C3 4F 53             defb    'C'+$80,"OS"
 397+ 1452 D3 49 4E             defb    'S'+$80,"IN"
 398+ 1455 D4 41 4E             defb    'T'+$80,"AN"
 399+ 1458 C1 54 4E             defb    'A'+$80,"TN"
 400+ 145B D0 45 45 4B          defb    'P'+$80,"EEK"
 401+ 145F C4 45 45 4B          defb    'D'+$80,"EEK"
 402+ 1463 D6 50 45 45          defb    'V'+$80,"PEEK"          ; added by Leonardo Miliani
 402+ 1467 4B
 403+ 1468 D6 53 54 41          defb    'V'+$80,"STAT"          ; added by Leonardo Miliani
 403+ 146C 54
 404+ 146D D3 53 54 41          defb    'S'+$80,"STAT"          ; added by Leonardo Miliani
 404+ 1471 54
 405+ 1472 C9 4E 4B 45          defb    'I'+$80,"NKEY"          ; added by Leonardo Miliani
 405+ 1476 59
 406+ 1477 D0 4F 49 4E          defb    'P'+$80,"OINT"          ; added by Leonardo Miliani
 406+ 147B 54
 407+ 147C C9 4E 53 54          defb    'I'+$80,"NSTR"          ; added by Leonardo Miliani
 407+ 1480 52
 408+ 1481 CC 45 4E             defb    'L'+$80,"EN"
 409+ 1484 D3 54 52 24          defb    'S'+$80,"TR$"
 410+ 1488 D6 41 4C             defb    'V'+$80,"AL"
 411+ 148B C1 53 43             defb    'A'+$80,"SC"
 412+ 148E C3 48 52 24          defb    'C'+$80,"HR$"
 413+ 1492 C8 45 58 24          defb    'H'+$80,"EX$"           ; added by Grant Searle
 414+ 1496 C2 49 4E 24          defb    'B'+$80,"IN$"           ; added by Grant Searle
 415+ 149A CC 45 46 54          defb    'L'+$80,"EFT$"
 415+ 149E 24
 416+ 149F D2 49 47 48          defb    'R'+$80,"IGHT$"
 416+ 14A3 54 24
 417+ 14A5 CD 49 44 24          defb    'M'+$80,"ID$"
 418+ 14A9 80                   defb    $80                     ; End-of-list marker
 419+ 14AA
 420+ 14AA              ; KEYWORD ADDRESS TABLE
 421+ 14AA              ; this list must be coherent with the commands'
 422+ 14AA              ; tokens list above
 423+ 14AA 08 1C        WORDTB: defw    PEND
 424+ 14AC 05 1B                defw    FOR
 425+ 14AE FC 1F                defw    NEXT
 426+ 14B0 67 1D                defw    DATA
 427+ 14B2 01 1F                defw    INPUT
 428+ 14B4 51 22                defw    DIM
 429+ 14B6 33 1F                defw    READ
 430+ 14B8 7E 1D                defw    LET
 431+ 14BA 24 1D                defw    GOTO
 432+ 14BC FF 1C                defw    RUN
 433+ 14BE F6 1D                defw    IF
 434+ 14C0 CE 1B                defw    RESTOR
 435+ 14C2 13 1D                defw    GOSUB
 436+ 14C4 42 1D                defw    RETURN
 437+ 14C6 69 1D                defw    REM         ; original REM
 438+ 14C8 06 1C                defw    STOP
 439+ 14CA 96 28                defw    POUT
 440+ 14CC D8 1D                defw    ON
 441+ 14CE 6C 3E                defw    FILES       ; changed by Leonardo Miliani - was NULL
 442+ 14D0 6D 3E                defw    ERASE       ; added by Leonardo Miliani
 443+ 14D2 9C 28                defw    WAIT
 444+ 14D4 45 24                defw    DEF
 445+ 14D6 90 29                defw    POKE
 446+ 14D8 33 33                defw    DOKE
 447+ 14DA 95 29                defw    VPOKE       ; added by Leonardo Miliani
 448+ 14DC D2 29                defw    SREG        ; added by Leonardo Miliani
 449+ 14DE 20 2B                defw    VREG        ; added by Leonardo Miliani
 450+ 14E0 69 33                defw    SCREEN      ; new behaviour: now it sets up a graphics mode (Leonardo Miliani)
 451+ 14E2 A0 29                defw    LOCATE      ; added by Leonardo Miliani
 452+ 14E4 2C 2A                defw    SOUND       ; added by Leonardo Miliani
 453+ 14E6 F3 29                defw    VOLUME      ; added by Leonardo Miliani
 454+ 14E8 4A 33                defw    PAUSE       ; added by Leonardo Miliani
 455+ 14EA E4 33                defw    COLOR       ; added by Leonardo Miliani
 456+ 14EC D2 36                defw    PLOT        ; added by Leonardo Miliani
 457+ 14EE 65 37                defw    DRAW        ; added by Leonardo Miliani
 458+ 14F0 9B 38                defw    CIRCLE      ; added by Leonardo Miliani
 459+ 14F2 8F 35                defw    PAINT       ; added by Leonardo Miliani
 460+ 14F4 A0 3A                defw    SERIAL      ; added by Leonardo Miliani
 461+ 14F6 E2 3C                defw    HELP        ; changed by Leonardo Miliani - was LINES
 462+ 14F8 0C 33                defw    CLS
 463+ 14FA FD 3C                defw    KEY         ; added by Leonardo Miliani
 464+ 14FC DE 28                defw    NMI         ; added by Leonardo Miliani
 465+ 14FE A0 34                defw    GPRINT      ; added by Leonardo Miliani
 466+ 1500 20 33                defw    WIDTH
 467+ 1502 38 29                defw    SYS         ; added by Leonardo Miliani
 468+ 1504 64 3F                defw    RESET       ; new behaviour: now it resets the system
 469+ 1506 6B 1D                defw    REM+2       ; ELSE: added by Leonardo Miliani
 470+ 1508 28 1E                defw    PRINT
 471+ 150A 3A 1C                defw    CONT
 472+ 150C DC 19                defw    LIST
 473+ 150E B3 1C                defw    CLEAR
 474+ 1510 6A 3E                defw    LOAD        ; re-implemented by Leonardo Miliani (was CLOAD)
 475+ 1512 6B 3E                defw    SAVE        ; re-implemented by Leonardo Miliani (was CSAVE)
 476+ 1514 C1 17                defw    NEW
 477+ 1516
 478+ 1516              ; RESERVED WORD TOKEN VALUES
 479+ 1516              ; if you add a function or command you must increment by 1
 480+ 1516              ; the values below. Pay attention that you must increment only the
 481+ 1516              ; values AFTER the position where you entered the function/command word
 482+ 1516              ; in the "Reserver word list" above. I.E.: VPOKE has been added between
 483+ 1516              ; DOKE and SCREEN, and since REM is the reserved work listed below
 484+ 1516              ; that is before the point where VPOKE has been entered, every entry
 485+ 1516              ; after REM has been incremented.
 486+ 1516              ; Another example: when TMR has been added, since it's a function, every
 487+ 1516              ; entry after & included ZSGN must be checked (read below)
 488+ 1516
 489+ 1516              ZEND    equ     $80             ; END        <-- from here, there are the commands
 490+ 1516              ZFOR    equ     $81             ; FOR
 491+ 1516              ZDATA   equ     $83             ; DATA
 492+ 1516              ZGOTO   equ     $88             ; GOTO
 493+ 1516              ZGOSUB  equ     $8C             ; GOSUB
 494+ 1516              ZREM    equ     $8E             ; REM
 495+ 1516              ZELSE   equ     $AE             ; ELSE
 496+ 1516              ZPRINT  equ     $AF             ; PRINT
 497+ 1516              ZNEW    equ     $B5             ; NEW
 498+ 1516
 499+ 1516              ZTAB    equ     $B6             ; TAB
 500+ 1516              ZTO     equ     $B7             ; TO
 501+ 1516              ZFN     equ     $B8             ; FN
 502+ 1516              ZSPC    equ     $B9             ; SPC
 503+ 1516              ZTHEN   equ     $BA             ; THEN
 504+ 1516              ZNOT    equ     $BB             ; NOT
 505+ 1516              ZSTEP   equ     $BC             ; STEP
 506+ 1516
 507+ 1516              ZPLUS   equ     $BD             ; +         <-- from here, there are the math operators
 508+ 1516              ZMINUS  equ     $BE             ; -
 509+ 1516              ZTIMES  equ     $BF             ; *
 510+ 1516              ZDIV    equ     $C0             ; /
 511+ 1516              ZMOD    equ     $C1             ; %
 512+ 1516              ZDINT   equ     $C2             ; #
 513+ 1516              ZOR     equ     $C6             ; OR
 514+ 1516              ZGTR    equ     $C7             ; >
 515+ 1516              ZEQUAL  equ     $C8             ; M
 516+ 1516              ZLTH    equ     $C9             ; <
 517+ 1516
 518+ 1516              ZSGN    equ     $CA             ; SGN       <-- from here, there are the functions
 519+ 1516              ZPOINT  equ     $E0             ; ZPOINT    <-- if the user enters a custom function, between
 520+ 1516                                              ;               SGN and POINT, he/she must increment this pointer by 1
 521+ 1516              ZINSTR  equ     $E1             ; ZINSTR    <-- same here
 522+ 1516              ZLEFT   equ     $E9             ; LEFT$     <-- if the user enters a custom function anywhere,
 523+ 1516                                              ;               he/she must increment this pointer by 1
 524+ 1516
 525+ 1516              ; ARITHMETIC PRECEDENCE TABLE
 526+ 1516              ; in the formulas below, <last> is a number stored into the stack that must be retrieved
 527+ 1516              ; with POP BC, POP DE; FPREG is a f.p. number store into the RAM register FPREG
 528+ 1516 79           PRITAB: defb    $79             ; Precedence value
 529+ 1517 D5 2F                defw    PADD            ; FPREG = <last> + FPREG
 530+ 1519
 531+ 1519 79                   defb    $79             ; Precedence value
 532+ 151A B8 2B                defw    PSUB            ; FPREG = <last> - FPREG
 533+ 151C
 534+ 151C 7C                   defb    $7C             ; Precedence value
 535+ 151D F6 2C                defw    MULT            ; PPREG = <last> * FPREG
 536+ 151F
 537+ 151F 7C                   defb    $7C             ; Precedence value
 538+ 1520 A8 2D                defw    DIV             ; FPREG = <last> / FPREG
 539+ 1522
 540+ 1522 7C                   defb    $7C             ; Precedence value
 541+ 1523 53 2D                defw    MOD             ; FPREG = INT(<last>)-(INT(FPREG)*INT(<last>/FPREG))
 542+ 1525
 543+ 1525 7C                   defb    $7C             ; precedence value
 544+ 1526 4B 2D                defw    DINT            ; FPREG = INT(<last> / FPREG )
 545+ 1528
 546+ 1528 7F                   defb    $7F             ; Precedence value
 547+ 1529 F6 30                defw    POWER           ; FPREG = <last> ^ FPREG
 548+ 152B
 549+ 152B 50                   defb    $50             ; Precedence value
 550+ 152C 9A 21                defw    PAND            ; FPREG = <last> AND FPREG
 551+ 152E
 552+ 152E 4A                   defb    $4A             ; Precedence value
 553+ 152F A2 21                defw    PXOR            ; FPREG = <last> XOR FPREG
 554+ 1531
 555+ 1531 46                   defb    $46             ; Precedence value
 556+ 1532 9D 21                defw    POR             ; FPREG = <last> OR FPREG
 557+ 1534
 558+ 1534
 559+ 1534              ; INITIALISATION TABLE -------------------------------------------------------
 560+ 1534              ; these values are copied into RAM at startup
 561+ 1534 C3 67 12     INITAB: jp      WARMST          ; Warm start jump
 562+ 1537 ED 45 00             defb    $ED,$45,$00     ; RETN + NOP for default NMI service routine
 563+ 153A C3 89 1C             jp      FCERR           ; "USR (X)" jump (Set to Error)
 564+ 153D D3 00                out     (0),A           ; "out p,n" skeleton
 565+ 153F C9                   ret
 566+ 1540 D6 00                sub     $00             ; Division support routine
 567+ 1542 6F                   ld      L,A
 568+ 1543 7C                   ld      A,H
 569+ 1544 DE 00                sbc     A,$00
 570+ 1546 67                   ld      H,A
 571+ 1547 78                   ld      A,B
 572+ 1548 DE 00                sbc     A,$00
 573+ 154A 47                   ld      B,A
 574+ 154B 3E 00                ld      A,$00
 575+ 154D C9                   ret
 576+ 154E 00 00 00             defb    $00,$00,$00     ; Random number seed table used by RND
 577+ 1551 35 4A CA 99          defb    $35,$4A,$CA,$99 ;-2.65145E+07
 578+ 1555 39 1C 76 98          defb    $39,$1C,$76,$98 ; 1.61291E+07
 579+ 1559 22 95 B3 98          defb    $22,$95,$B3,$98 ;-1.17691E+07
 580+ 155D 0A DD 47 98          defb    $0A,$DD,$47,$98 ; 1.30983E+07
 581+ 1561 53 D1 99 99          defb    $53,$D1,$99,$99 ;-2-01612E+07
 582+ 1565 0A 1A 9F 98          defb    $0A,$1A,$9F,$98 ;-1.04269E+07
 583+ 1569 65 BC CD 98          defb    $65,$BC,$CD,$98 ;-1.34831E+07
 584+ 156D D6 77 3E 98          defb    $D6,$77,$3E,$98 ; 1.24825E+07
 585+ 1571 52 C7 4F 80          defb    $52,$C7,$4F,$80 ; Last random number
 586+ 1575 DB 00                in      A,($00)         ; INP (x) skeleton
 587+ 1577 C9                   ret
 588+ 1578 FF                   defb    $FF             ; Terminal width (255 = no auto CRLF)
 589+ 1579 14                   defb    $14             ; Width for commas (at reset, 3 columns, for G1 mode)
 590+ 157A 00                   defb    $00             ; No nulls after input bytes
 591+ 157B 00                   defb    $00             ; Output enabled (^O off)
 592+ 157C 00 00                defw    $00             ; Array load/save check sum
 593+ 157E 00                   defb    $00             ; Break not by NMI
 594+ 157F 00                   defb    $00             ; Break flag
 595+ 1580 C3 FD 18             jp      TTYLIN          ; Input reflection (set to TTY)
 596+ 1583 9A 53                defw    STLOOK          ; Temp string space
 597+ 1585 FE FF                defw    -2              ; Current line number (cold)
 598+ 1587 FF FF                defw    -1              ; Current line with errors (no errors)
 599+ 1589 40           AUTORP: defb    $40             ; delay for key auto-repeat start
 600+ 158A 08                   defb    $08             ; auto-repeat delay
 601+ 158B 4C 49 53 54  DEFFNKS:defm    "LIST",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 1
 601+ 158F 0D 00 00 00
 601+ 1593 00 00 00 00
 601+ 1597 00 00 00 00
 602+ 159B 52 55 4E 0D          defm    "RUN",13,0,0,0,0,0,0,0,0,0,0,0,0    ; KEY 2
 602+ 159F 00 00 00 00
 602+ 15A3 00 00 00 00
 602+ 15A7 00 00 00 00
 603+ 15AB 53 43 52 45          defm    "SCREEN1",13,0,0,0,0,0,0,0,0        ; KEY 3
 603+ 15AF 45 4E 31 0D
 603+ 15B3 00 00 00 00
 603+ 15B7 00 00 00 00
 604+ 15BB 43 4F 4C 4F          defm    "COLOR1,15,5",13,0,0,0,0            ; KEY 4
 604+ 15BF 52 31 2C 31
 604+ 15C3 35 2C 35 0D
 604+ 15C7 00 00 00 00
 605+ 15CB 53 45 52 49          defm    "SERIAL1,38400",13,0,0              ; KEY 5
 605+ 15CF 41 4C 31 2C
 605+ 15D3 33 38 34 30
 605+ 15D7 30 0D 00 00
 606+ 15DB 53 43 52 45          defm    "SCREEN2",13,0,0,0,0,0,0,0,0        ; KEY 6
 606+ 15DF 45 4E 32 0D
 606+ 15E3 00 00 00 00
 606+ 15E7 00 00 00 00
 607+ 15EB 43 4F 4E 54          defm    "CONT",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 7
 607+ 15EF 0D 00 00 00
 607+ 15F3 00 00 00 00
 607+ 15F7 00 00 00 00
 608+ 15FB 48 45 4C 50          defm    "HELP",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 8 (HELP KEY)
 608+ 15FF 0D 00 00 00
 608+ 1603 00 00 00 00
 608+ 1607 00 00 00 00
 609+ 160B 37 53                defw    PROGST+1        ; Start of program text
 610+ 160D              INITBE:
 611+ 160D
 612+ 160D              ; END OF INITIALISATION TABLE ---------------------------------------------------
 613+ 160D
 614+ 160D 20 45 72 72  ERRMSG: defb    " Error",0
 614+ 1611 6F 72 00
 615+ 1614 20 69 6E 20  INMSG:  defb    " in ",0
 615+ 1618 00
 616+ 1619              ZERBYT  equ     $-1             ; A zero byte
 617+ 1619 4F 6B 0D 00  OKMSG:  defb    "Ok",CR,0,0
 617+ 161D 00
 618+ 161E 42 72 65 61  BRKMSG: defb    "Break",0
 618+ 1622 6B 00
 619+ 1624
 620+ 1624 21 04 00     BAKSTK: ld      HL,$04          ; Look for "FOR" block with
 621+ 1627 39                   add     HL,SP           ; same index as specified
 622+ 1628 7E           LOKFOR: ld      A,(HL)          ; Get block ID
 623+ 1629 23                   inc     HL              ; Point to index address
 624+ 162A FE 81                cp      ZFOR            ; Is it a "FOR" token
 625+ 162C C0                   ret     NZ              ; No - exit
 626+ 162D 4E                   ld      C,(HL)          ; BC = Address of "FOR" index
 627+ 162E 23                   inc     HL
 628+ 162F 46                   ld      B,(HL)
 629+ 1630 23                   inc     HL              ; Point to sign of STEP
 630+ 1631 E5                   push    HL              ; Save pointer to sign
 631+ 1632 69                   ld      L,C             ; HL = address of "FOR" index
 632+ 1633 60                   ld      H,B
 633+ 1634 7A                   ld      A,D             ; See if an index was specified
 634+ 1635 B3                   or      E               ; DE = 0 if no index specified
 635+ 1636 EB                   ex      DE,HL           ; Specified index into HL
 636+ 1637 CA 3E 16             jp      Z,INDFND        ; Skip if no index given
 637+ 163A EB                   ex      DE,HL           ; Index back into DE
 638+ 163B CD 77 19             call    CPDEHL          ; Compare index with one given
 639+ 163E 01 0D 00     INDFND: ld      BC,16-3         ; Offset to next block
 640+ 1641 E1                   pop     HL              ; Restore pointer to sign
 641+ 1642 C8                   ret     Z               ; Return if block found
 642+ 1643 09                   add     HL,BC           ; Point to next block
 643+ 1644 C3 28 16             jp      LOKFOR          ; Keep on looking
 644+ 1647
 645+ 1647 CD 61 16     MOVUP:  call    ENFMEM          ; See if enough memory
 646+ 164A C5           MOVSTR: push    BC              ; Save end of source
 647+ 164B E3                   ex      (SP),HL         ; Swap source and dest" end
 648+ 164C C1                   pop     BC              ; Get end of destination
 649+ 164D CD 77 19     MOVLP:  call    CPDEHL          ; See if list moved
 650+ 1650 7E                   ld      A,(HL)          ; Get byte
 651+ 1651 02                   ld      (BC),A          ; Move it
 652+ 1652 C8                   ret     Z               ; Exit if all done
 653+ 1653 0B                   dec     BC              ; Next byte to move to
 654+ 1654 2B                   dec     HL              ; Next byte to move
 655+ 1655 C3 4D 16             jp      MOVLP           ; Loop until all bytes moved
 656+ 1658
 657+ 1658 E5           CHKSTK: push    HL              ; Save code string address
 658+ 1659 2A 17 53             ld      HL,(ARREND)     ; Lowest free memory
 659+ 165C 06 00                ld      B,$00           ; BC = Number of levels to test
 660+ 165E 09                   add     HL,BC           ; 2 Bytes for each level
 661+ 165F 09                   add     HL,BC
 662+ 1660 3E                   defb    $3E             ; Skip "push HL"
 663+ 1661 E5           ENFMEM: push    HL              ; Save code string address
 664+ 1662 3E D0                ld      A,$D0           ; LOW -48 ; 48 Bytes minimum RAM
 665+ 1664 95                   sub     L
 666+ 1665 6F                   ld      L,A
 667+ 1666 3E FF                ld      A,$FF           ; HIGH (-48) ; 48 Bytes minimum RAM
 668+ 1668 9C                   sbc     A,H
 669+ 1669 DA 70 16             jp      C,OMERR         ; Not enough - ?OM Error
 670+ 166C 67                   ld      H,A
 671+ 166D 39                   add     HL,SP           ; Test if stack is overflowed
 672+ 166E E1                   pop     HL              ; Restore code string address
 673+ 166F D8                   ret     C               ; Return if enough memory
 674+ 1670 1E 0C        OMERR:  ld      E,OM            ; ?OM Error
 675+ 1672 C3 AF 16             jp      ERROR
 676+ 1675
 677+ 1675
 678+ 1675              ; if in graphics mode, return to text (called by "NOLIN" and "ERROR")
 679+ 1675 F5           EXITGM: push    AF              ; store AF
 680+ 1676 3A BE 52             ld      A,(SCR_MODE)    ; check screen mode
 681+ 1679 FE 02                cp      $02             ; G2?
 682+ 167B CA 82 16             jp      Z,LDG1          ; yes, back to G1
 683+ 167E FE 03                cp      $03             ; G3?
 684+ 1680 20 11                jr      NZ,LDG1ND       ; no, so return
 685+ 1682 E5           LDG1:   push    HL              ; store HL
 686+ 1683 D5                   push    DE              ; store DE
 687+ 1684 11 01 00             ld      DE,$0001        ; sprites set to defaults, G1 mode
 688+ 1687 F3                   di                      ; disable INTs
 689+ 1688 CD D3 03             call    initVDP         ; initialize VDP with mode pointed by E
 690+ 168B FB                   ei                      ; re-enable INTs
 691+ 168C 3E 01                ld      A,$01           ; activate the...
 692+ 168E 32 C9 52             ld      (PRNTVIDEO),A   ; ...video buffer...
 693+ 1691 D1                   pop     DE              ; retrieve DE
 694+ 1692 E1                   pop     HL              ; retrieve HL
 695+ 1693 F1           LDG1ND: pop     AF              ; retrieve AF
 696+ 1694 C9                   ret                     ; return to caller
 697+ 1695
 698+ 1695
 699+ 1695 2A 9F 52     DATSNR: ld      HL,(DATLIN)     ; Get line of current DATA item
 700+ 1698 22 9E 51             ld      (LINEAT),HL     ; Save as current line
 701+ 169B 1E 02        SNERR:  ld      E,SN            ; ?SN Error
 702+ 169D 01                   defb    $01             ; Skip "ld E,DZ"
 703+ 169E 1E 14        DZERR:  ld      E,DZ            ; ?/0 Error
 704+ 16A0 01                   defb    $01             ; Skip "ld E,NF"
 705+ 16A1 1E 00        NFERR:  ld      E,NF            ; ?NF Error
 706+ 16A3 01                   defb    $01             ; Skip "ld E,DD"
 707+ 16A4 1E 12        DDERR:  ld      E,DD            ; ?DD Error
 708+ 16A6 01                   defb    $01             ; Skip "ld E,UF"
 709+ 16A7 1E 22        UFERR:  ld      E,UF            ; ?UF Error
 710+ 16A9 01                   defb    $01             ; Skip "ld E,OV
 711+ 16AA 1E 0A        OVERR:  ld      E,OV            ; ?OV Error
 712+ 16AC 01                   defb    $01             ; Skip "ld E,TM"
 713+ 16AD 1E 18        TMERR:  ld      E,TM            ; ?TM Error
 714+ 16AF
 715+ 16AF CD E7 17     ERROR:  call    CLREG           ; Clear registers and stack
 716+ 16B2 CD 75 16             call    EXITGM          ; exit from graphic modes
 717+ 16B5 32 94 51             ld      (CTLOFG),A      ; Enable output (A is 0)
 718+ 16B8 CD EA 08             call    CURSOR_ON       ; enable cursor
 719+ 16BB CD 79 1E             call    STTLIN          ; Start new line
 720+ 16BE 21 CF 0F             ld      HL,ERRTBL       ; Point to error codes
 721+ 16C1 57                   ld      D,A             ; D = 0 (A is 0)
 722+ 16C2 3E 3F                ld      A,'?'
 723+ 16C4 CD 88 19             call    OUTC            ; Output '?'
 724+ 16C7 19                   add     HL,DE           ; Offset to correct error code
 725+ 16C8 5E                   ld      E,(HL)          ; load pointer to error message
 726+ 16C9 23                   inc     HL              ; by loading LSB,
 727+ 16CA 56                   ld      D,(HL)          ; then MSB
 728+ 16CB 62 6B                ld      HL,DE           ; load pointer to HL
 729+ 16CD CD 4F 25             call    PRS             ; Output error message
 730+ 16D0 21 0D 16             ld      HL,ERRMSG       ; "Error" message
 731+ 16D3 CD 4F 25     ERRIN:  call    PRS             ; Output message
 732+ 16D6 2A 9E 51             ld      HL,(LINEAT)     ; Get line of error
 733+ 16D9 11 FE FF             ld      DE,-2           ; Cold start error if -2
 734+ 16DC CD 77 19             call    CPDEHL          ; See if cold start error
 735+ 16DF CA C0 11             jp      Z,CSTART        ; Cold start error - Restart
 736+ 16E2 7C                   ld      A,H             ; Was it a direct error?
 737+ 16E3 A5                   and     L               ; Line = -1 if direct error
 738+ 16E4 3C                   inc     A
 739+ 16E5 CA F0 16             jp      Z,PTLN          ; Yes, jump over
 740+ 16E8 E5                   push    HL              ; indirect mode - store HL
 741+ 16E9 2A 9E 51             ld      HL,(LINEAT)     ; copy current line number
 742+ 16EC 22 A0 51             ld      (HLPLN),HL      ; save in HELP line register
 743+ 16EF E1                   pop     HL              ; retrieve HL
 744+ 16F0 C4 E6 2F     PTLN:   call    NZ,LINEIN       ; No - output line of error
 745+ 16F3
 746+ 16F3 3E                   defb    $3E             ; Skip "pop BC"
 747+ 16F4 C1           POPNOK: pop     BC              ; Drop address in input buffer
 748+ 16F5
 749+ 16F5              ; run into direct mode: print OK and get command
 750+ 16F5 AF           PRNTOK: xor     A               ; Output "Ok" and get command
 751+ 16F6 32 94 51             ld      (CTLOFG),A      ; Enable output
 752+ 16F9 CD 79 1E             call    STTLIN          ; Start new line
 753+ 16FC 21 19 16             ld      HL,OKMSG        ; "Ok" message
 754+ 16FF CD 4F 25             call    PRS             ; Output "Ok"
 755+ 1702 CD EA 08     GETCMD: call    CURSOR_ON       ; enable cursor
 756+ 1705 21 FF FF             ld      HL,-1           ; Flag direct mode
 757+ 1708 22 9E 51             ld      (LINEAT),HL     ; Save as current line
 758+ 170B CD FD 18             call    GETLIN          ; Get an input line
 759+ 170E DA 02 17             jp      C,GETCMD        ; Get line again if break
 760+ 1711 CD BE 1B             call    GETCHR          ; Get first character
 761+ 1714 17                   rla                     ; 8th bit is copied into carry and original carry is copied into bit 0)
 762+ 1715 DA 9B 16             jp      C,SNERR         ; if char >=128 (8th bit set) then raise an error
 763+ 1718 1F                   rra                     ; recover original char and Carry
 764+ 1719 3C                   inc     A               ; Test if end of line
 765+ 171A 3D                   dec     A               ; Without affecting Carry
 766+ 171B CA 02 17             jp      Z,GETCMD        ; Nothing entered - Get another
 767+ 171E F5                   push    AF              ; Save Carry status
 768+ 171F CD FF 08             call    CURSOR_OFF      ; cursor disabled
 769+ 1722 CD 8E 1C             call    ATOH            ; Get line number into DE
 770+ 1725 D5                   push    DE              ; Save line number
 771+ 1726 CD 14 18             call    CRUNCH          ; Tokenise rest of line
 772+ 1729 47                   ld      B,A             ; Length of tokenised line
 773+ 172A D1                   pop     DE              ; Restore line number
 774+ 172B F1                   pop     AF              ; Restore Carry
 775+ 172C D2 9E 1B             jp      NC,EXCUTE       ; No line number - Direct mode
 776+ 172F D5                   push    DE              ; Save line number
 777+ 1730 C5                   push    BC              ; Save length of tokenised line
 778+ 1731 AF                   xor     A
 779+ 1732 32 A2 52             ld      (LSTBIN),A      ; Clear last byte input
 780+ 1735 CD BE 1B             call    GETCHR          ; Get next character
 781+ 1738 B7                   or      A               ; Set flags
 782+ 1739 F5                   push    AF              ; And save them
 783+ 173A CD A1 17             call    SRCHLN          ; Search for line number in DE
 784+ 173D DA 46 17             jp      C,LINFND        ; Jump if line found
 785+ 1740 F1                   pop     AF              ; Get status
 786+ 1741 F5                   push    AF              ; And re-save
 787+ 1742 CA 3D 1D             jp      Z,ULERR         ; Nothing after number - Error
 788+ 1745 B7                   or      A               ; Clear Carry
 789+ 1746 C5           LINFND: push    BC              ; Save address of line in prog
 790+ 1747 D2 5D 17             jp      NC,INEWLN       ; Line not found - Insert new
 791+ 174A EB                   ex      DE,HL           ; Next line address in DE
 792+ 174B 2A 13 53             ld      HL,(PROGND)     ; End of program
 793+ 174E 1A           SFTPRG: ld      A,(DE)          ; Shift rest of program down
 794+ 174F 02                   ld      (BC),A
 795+ 1750 03                   inc     BC              ; Next destination
 796+ 1751 13                   inc     DE              ; Next source
 797+ 1752 CD 77 19             call    CPDEHL          ; All done?
 798+ 1755 C2 4E 17             jp      NZ,SFTPRG       ; More to do
 799+ 1758 60                   ld      H,B             ; HL - New end of program
 800+ 1759 69                   ld      L,C
 801+ 175A 22 13 53             ld      (PROGND),HL     ; Update end of program
 802+ 175D
 803+ 175D D1           INEWLN: pop     DE              ; Get address of line,
 804+ 175E F1                   pop     AF              ; Get status
 805+ 175F CA 84 17             jp      Z,SETPTR        ; No text - Set up pointers
 806+ 1762 2A 13 53             ld      HL,(PROGND)     ; Get end of program
 807+ 1765 E3                   ex      (SP),HL         ; Get length of input line
 808+ 1766 C1                   pop     BC              ; End of program to BC
 809+ 1767 09                   add     HL,BC           ; Find new end
 810+ 1768 E5                   push    HL              ; Save new end
 811+ 1769 CD 47 16             call    MOVUP           ; Make space for line
 812+ 176C E1                   pop     HL              ; Restore new end
 813+ 176D 22 13 53             ld      (PROGND),HL     ; Update end of program pointer
 814+ 1770 EB                   ex      DE,HL           ; Get line to move up in HL
 815+ 1771 74                   ld      (HL),H          ; Save MSB
 816+ 1772 D1                   pop     DE              ; Get new line number
 817+ 1773 23                   inc     HL              ; Skip pointer
 818+ 1774 23                   inc     HL
 819+ 1775 73                   ld      (HL),E          ; Save LSB of line number
 820+ 1776 23                   inc     HL
 821+ 1777 72                   ld      (HL),D          ; Save MSB of line number
 822+ 1778 23                   inc     HL              ; To first byte in line
 823+ 1779 11 27 52             ld      DE,BUFFER       ; Copy buffer to program
 824+ 177C 1A           MOVBUF: ld      A,(DE)          ; Get source
 825+ 177D 77                   ld      (HL),A          ; Save destinations
 826+ 177E 23                   inc     HL              ; Next source
 827+ 177F 13                   inc     DE              ; Next destination
 828+ 1780 B7                   or      A               ; Done?
 829+ 1781 C2 7C 17             jp      NZ,MOVBUF       ; No - Repeat
 830+ 1784 CD CD 17     SETPTR: call    RUNFST          ; Set line pointers
 831+ 1787 23                   inc     HL              ; To LSB of pointer
 832+ 1788 EB                   ex      DE,HL           ; Address to DE
 833+ 1789 62           PTRLP:  ld      H,D             ; Address to HL
 834+ 178A 6B                   ld      L,E
 835+ 178B 7E                   ld      A,(HL)          ; Get LSB of pointer
 836+ 178C 23                   inc     HL              ; To MSB of pointer
 837+ 178D B6                   or      (HL)            ; Compare with MSB pointer
 838+ 178E CA 02 17             jp      Z,GETCMD        ; Get command line if end
 839+ 1791 23                   inc     HL              ; To LSB of line number
 840+ 1792 23                   inc     HL              ; Skip line number
 841+ 1793 23                   inc     HL              ; Point to first byte in line
 842+ 1794 AF                   xor     A               ; Looking for 00 byte
 843+ 1795 BE           FNDEND: cp      (HL)            ; Found end of line?
 844+ 1796 23                   inc     HL              ; Move to next byte
 845+ 1797 C2 95 17             jp      NZ,FNDEND       ; No - Keep looking
 846+ 179A EB                   ex      DE,HL           ; Next line address to HL
 847+ 179B 73                   ld      (HL),E          ; Save LSB of pointer
 848+ 179C 23                   inc     HL
 849+ 179D 72                   ld      (HL),D          ; Save MSB of pointer
 850+ 179E C3 89 17             jp      PTRLP           ; Do next line
 851+ 17A1
 852+ 17A1 2A 24 52     SRCHLN: ld      HL,(BASTXT)     ; Start of program text
 853+ 17A4 44           SRCHLP: ld      B,H             ; BC = Address to look at
 854+ 17A5 4D                   ld      C,L
 855+ 17A6 7E                   ld      A,(HL)          ; Get address of next line
 856+ 17A7 23                   inc     HL
 857+ 17A8 B6                   or      (HL)            ; End of program found?
 858+ 17A9 2B                   dec     HL
 859+ 17AA C8                   ret     Z               ; Yes - Line not found
 860+ 17AB 23                   inc     HL
 861+ 17AC 23                   inc     HL
 862+ 17AD 7E                   ld      A,(HL)          ; Get LSB of line number
 863+ 17AE 23                   inc     HL
 864+ 17AF 66                   ld      H,(HL)          ; Get MSB of line number
 865+ 17B0 6F                   ld      L,A
 866+ 17B1 CD 77 19             call    CPDEHL          ; Compare with line in DE
 867+ 17B4 60                   ld      H,B             ; HL = Start of this line
 868+ 17B5 69                   ld      L,C
 869+ 17B6 7E                   ld      A,(HL)          ; Get LSB of next line address
 870+ 17B7 23                   inc     HL
 871+ 17B8 66                   ld      H,(HL)          ; Get MSB of next line address
 872+ 17B9 6F                   ld      L,A             ; Next line to HL
 873+ 17BA 3F                   ccf
 874+ 17BB C8                   ret     Z               ; Lines found - Exit
 875+ 17BC 3F                   ccf
 876+ 17BD D0                   ret     NC              ; Line not found,at line after
 877+ 17BE C3 A4 17             jp      SRCHLP          ; Keep looking
 878+ 17C1
 879+ 17C1 C0           NEW:    ret     NZ              ; Return if any more on line
 880+ 17C2 2A 24 52     CLRPTR: ld      HL,(BASTXT)     ; Point to start of program
 881+ 17C5 AF                   xor     A               ; Set program area to empty
 882+ 17C6 77                   ld      (HL),A          ; Save LSB = 00
 883+ 17C7 23                   inc     HL
 884+ 17C8 77                   ld      (HL),A          ; Save MSB = 00
 885+ 17C9 23                   inc     HL
 886+ 17CA 22 13 53             ld      (PROGND),HL     ; Set program end
 887+ 17CD
 888+ 17CD 2A 24 52     RUNFST: ld      HL,(BASTXT)     ; Clear all variables
 889+ 17D0 2B                   dec     HL
 890+ 17D1
 891+ 17D1 22 A4 52     INTVAR: ld      (BRKLIN),HL     ; Initialise RUN variables
 892+ 17D4 2A 85 52             ld      HL,(LSTRAM)     ; Get end of RAM
 893+ 17D7 22 99 52             ld      (STRBOT),HL     ; Clear string space
 894+ 17DA AF                   xor     A
 895+ 17DB CD CE 1B             call    RESTOR          ; Reset DATA pointers
 896+ 17DE 2A 13 53             ld      HL,(PROGND)     ; Get end of program
 897+ 17E1 22 15 53             ld      (VAREND),HL     ; Clear variables
 898+ 17E4 22 17 53             ld      (ARREND),HL     ; Clear arrays
 899+ 17E7
 900+ 17E7 C1           CLREG:  pop     BC              ; Save return address
 901+ 17E8 2A 9C 51             ld      HL,(STRSPC)     ; Get end of working RAM
 902+ 17EB F9                   ld      SP,HL           ; Set stack
 903+ 17EC 21 89 52             ld      HL,TMSTPL       ; Temporary string pool
 904+ 17EF 22 87 52             ld      (TMSTPT),HL     ; Reset temporary string ptr
 905+ 17F2 AF                   xor     A               ; A = 00
 906+ 17F3 6F                   ld      L,A             ; HL = 0000
 907+ 17F4 67                   ld      H,A
 908+ 17F5 22 AA 52             ld      (CONTAD),HL     ; No CONTinue
 909+ 17F8 32 A1 52             ld      (FORFLG),A      ; Clear FOR flag
 910+ 17FB 22 1B 53             ld      (FNRGNM),HL     ; Clear FN argument
 911+ 17FE E5                   push    HL              ; HL = 0000
 912+ 17FF C5                   push    BC              ; Put back return
 913+ 1800 2A A4 52     DOAGN:  ld      HL,(BRKLIN)     ; Get address of code to RUN
 914+ 1803 C9                   ret                     ; Return to execution driver
 915+ 1804
 916+ 1804 3E 3F        PROMPT: ld      A,'?'           ; '?'
 917+ 1806 CD 88 19             call    OUTC            ; Output character
 918+ 1809 3E 00                ld      A,NLLCR         ; null char
 919+ 180B CD 88 19             call    OUTC            ; Output character
 920+ 180E CD EA 08             call    CURSOR_ON       ; enable cursor
 921+ 1811 C3 99 51             jp      RINPUT          ; Get input line
 922+ 1814
 923+ 1814 AF           CRUNCH: xor     A               ; Tokenise line @ HL to BUFFER
 924+ 1815 32 84 52             ld      (DATFLG),A      ; Reset literal flag
 925+ 1818 0E 05                ld      C,2+3           ; 2 byte number and 3 nulls
 926+ 181A 11 27 52             ld      DE,BUFFER       ; Start of input buffer
 927+ 181D 7E           CRNCLP: ld      A,(HL)          ; Get byte
 928+ 181E FE 20                cp      SPC             ; Is it a space?
 929+ 1820 CA 9C 18             jp      Z,MOVDIR        ; Yes - Copy direct
 930+ 1823 47                   ld      B,A             ; Save character
 931+ 1824 FE 22                cp      $22             ; '"'             ; Is it a quote?
 932+ 1826 CA BC 18             jp      Z,CPYLIT        ; Yes - Copy literal string
 933+ 1829 B7                   or      A               ; Is it end of buffer?
 934+ 182A CA C3 18             jp      Z,ENDBUF        ; Yes - End buffer
 935+ 182D 3A 84 52             ld      A,(DATFLG)      ; Get data type
 936+ 1830 B7                   or      A               ; Literal?
 937+ 1831 7E                   ld      A,(HL)          ; Get byte to copy
 938+ 1832 C2 9C 18             jp      NZ,MOVDIR       ; Literal - Copy direct
 939+ 1835 FE 3F                cp      '?'             ; Is it '?' short for PRINT
 940+ 1837 3E AF                ld      A,ZPRINT        ; "PRINT" token
 941+ 1839 CA 9C 18             jp      Z,MOVDIR        ; Yes - replace it
 942+ 183C 7E                   ld      A,(HL)          ; Get byte again
 943+ 183D FE 30                cp      '0'             ; Is it less than '0'
 944+ 183F DA 47 18             jp      C,FNDWRD        ; Yes - Look for reserved words
 945+ 1842 FE 3C                cp      $3C  ;60; ";"+1       ; Is it "0123456789:;" ?
 946+ 1844 DA 9C 18             jp      C,MOVDIR        ; Yes - copy it direct
 947+ 1847 D5           FNDWRD: push    DE              ; Look for reserved words
 948+ 1848 11 1C 13             ld      DE,WORDS-1      ; Point to table
 949+ 184B C5                   push    BC              ; Save count
 950+ 184C 01 98 18             ld      BC,RETNAD       ; Where to return to
 951+ 184F C5                   push    BC              ; Save return address
 952+ 1850 06 7F                ld      B,ZEND-1        ; First token value -1
 953+ 1852 7E                   ld      A,(HL)          ; Get byte
 954+ 1853 FE 61                cp      'a'             ; Less than 'a' ?
 955+ 1855 DA 60 18             jp      C,SEARCH        ; Yes - search for words
 956+ 1858 FE 7B                cp      'z'+1           ; Greater than 'z' ?
 957+ 185A D2 60 18             jp      NC,SEARCH       ; Yes - search for words
 958+ 185D E6 5F                and     %01011111       ; Force upper case
 959+ 185F 77                   ld      (HL),A          ; Replace byte
 960+ 1860 4E           SEARCH: ld      C,(HL)          ; Search for a word
 961+ 1861 EB                   ex      DE,HL
 962+ 1862 23           GETNXT: inc     HL              ; Get next reserved word
 963+ 1863 B6                   or      (HL)            ; Start of word?
 964+ 1864 F2 62 18             jp      P,GETNXT        ; No - move on
 965+ 1867 04                   inc     B               ; Increment token value
 966+ 1868 7E                   ld      A,(HL)          ; Get byte from table
 967+ 1869 E6 7F                and     %01111111       ; Strip bit 7
 968+ 186B C8                   ret     Z               ; Return if end of list
 969+ 186C B9                   cp      C               ; Same character as in buffer?
 970+ 186D C2 62 18             jp      NZ,GETNXT       ; No - get next word
 971+ 1870 EB                   ex      DE,HL
 972+ 1871 E5                   push    HL              ; Save start of word
 973+ 1872
 974+ 1872 13           NXTBYT: inc     DE              ; Look through rest of word
 975+ 1873 1A                   ld      A,(DE)          ; Get byte from table
 976+ 1874 B7                   or      A               ; End of word ?
 977+ 1875 FA 94 18             jp      M,MATCH         ; Yes - Match found
 978+ 1878 4F                   ld      C,A             ; Save it
 979+ 1879 78                   ld      A,B             ; Get token value
 980+ 187A FE 88                cp      ZGOTO           ; Is it "GOTO" token ?
 981+ 187C C2 83 18             jp      NZ,NOSPC        ; No - Don't allow spaces
 982+ 187F CD BE 1B             call    GETCHR          ; Get next character
 983+ 1882 2B                   dec     HL              ; Cancel increment from GETCHR
 984+ 1883 23           NOSPC:  inc     HL              ; Next byte
 985+ 1884 7E                   ld      A,(HL)          ; Get byte
 986+ 1885 FE 61                cp      'a'             ; Less than 'a' ?
 987+ 1887 DA 8C 18             jp      C,NOCHNG        ; Yes - don't change
 988+ 188A E6 5F                and     %01011111       ; Make upper case
 989+ 188C B9           NOCHNG: cp      C               ; Same as in buffer ?
 990+ 188D CA 72 18             jp      Z,NXTBYT        ; Yes - keep testing
 991+ 1890 E1                   pop     HL              ; Get back start of word
 992+ 1891 C3 60 18             jp      SEARCH          ; Look at next word
 993+ 1894
 994+ 1894 48           MATCH:  ld      C,B             ; Word found - Save token value
 995+ 1895 F1                   pop     AF              ; Throw away return
 996+ 1896 EB                   ex      DE,HL
 997+ 1897 C9                   ret                     ; Return to "RETNAD"
 998+ 1898 EB           RETNAD: ex      DE,HL           ; Get address in string
 999+ 1899 79                   ld      A,C             ; Get token value
1000+ 189A C1                   pop     BC              ; Restore buffer length
1001+ 189B D1                   pop     DE              ; Get destination address
1002+ 189C 23           MOVDIR: inc     HL              ; Next source in buffer
1003+ 189D 12                   ld      (DE),A          ; Put byte in buffer
1004+ 189E 13                   inc     DE              ; Move up buffer
1005+ 189F 0C                   inc     C               ; Increment length of buffer
1006+ 18A0 D6 3A                sub     ':'             ; End of statement?
1007+ 18A2 CA AA 18             jp      Z,SETLIT        ; Jump if multi-statement line
1008+ 18A5 FE 49                cp      ZDATA-$3A       ; Is it DATA statement ?
1009+ 18A7 C2 AD 18             jp      NZ,TSTREM       ; No - see if REM
1010+ 18AA 32 84 52     SETLIT: ld      (DATFLG),A      ; Set literal flag
1011+ 18AD D6 54        TSTREM: sub     ZREM-$3A        ; Is it REM?
1012+ 18AF C2 1D 18             jp      NZ,CRNCLP       ; No - Leave flag
1013+ 18B2 47                   ld      B,A             ; Copy rest of buffer
1014+ 18B3 7E           NXTCHR: ld      A,(HL)          ; Get byte
1015+ 18B4 B7                   or      A               ; End of line ?
1016+ 18B5 CA C3 18             jp      Z,ENDBUF        ; Yes - Terminate buffer
1017+ 18B8 B8                   cp      B               ; End of statement ?
1018+ 18B9 CA 9C 18             jp      Z,MOVDIR        ; Yes - Get next one
1019+ 18BC 23           CPYLIT: inc     HL              ; Move up source string
1020+ 18BD 12                   ld      (DE),A          ; Save in destination
1021+ 18BE 0C                   inc     C               ; Increment length
1022+ 18BF 13                   inc     DE              ; Move up destination
1023+ 18C0 C3 B3 18             jp      NXTCHR          ; Repeat
1024+ 18C3
1025+ 18C3 21 26 52     ENDBUF: ld      HL,BUFFER-1     ; Point to start of buffer
1026+ 18C6 12                   ld      (DE),A          ; Mark end of buffer (A = 00)
1027+ 18C7 13                   inc     DE
1028+ 18C8 12                   ld      (DE),A          ; A = 00
1029+ 18C9 13                   inc     DE
1030+ 18CA 12                   ld      (DE),A          ; A = 00
1031+ 18CB C9                   ret
1032+ 18CC
1033+ 18CC 3A 93 51     DODEL:  ld      A,(NULFLG)      ; Get null flag status
1034+ 18CF B7                   or      A               ; Is it zero?
1035+ 18D0 3E 00                ld      A,$00           ; Zero A - Leave flags
1036+ 18D2 32 93 51             ld      (NULFLG),A      ; Zero null flag
1037+ 18D5 C2 E0 18             jp      NZ,ECHDEL       ; Set - Echo it
1038+ 18D8 05                   dec     B               ; Decrement length
1039+ 18D9 CA FD 18             jp      Z,GETLIN        ; Get line again if empty
1040+ 18DC CD 88 19             call    OUTC            ; Output null character
1041+ 18DF 3E                   defb    $3E             ; Skip "dec B"
1042+ 18E0 05           ECHDEL: dec     B               ; Count bytes in buffer
1043+ 18E1 2B                   dec     HL              ; Back space buffer
1044+ 18E2 CA F4 18             jp      Z,OTKLN         ; No buffer - Try again
1045+ 18E5 7E                   ld      A,(HL)          ; Get deleted byte
1046+ 18E6 CD 88 19             call    OUTC            ; Echo it
1047+ 18E9 C3 06 19             jp      MORINP          ; Get more input
1048+ 18EC
1049+ 18EC 05           DELCHR: dec     B               ; Count bytes in buffer
1050+ 18ED 2B                   dec     HL              ; Back space buffer
1051+ 18EE CD 88 19             call    OUTC            ; Output character in A
1052+ 18F1 C2 06 19             jp      NZ,MORINP       ; Not end - Get more
1053+ 18F4 CD 88 19     OTKLN:  call    OUTC            ; Output character in A
1054+ 18F7 CD 8B 1E     KILIN:  call    PRNTCRLF        ; Output CRLF
1055+ 18FA C3 FD 18             jp      TTYLIN          ; Get line again
1056+ 18FD
1057+ 18FD              GETLIN:
1058+ 18FD 21 27 52     TTYLIN: ld      HL,BUFFER       ; Get a line by character
1059+ 1900 06 01                ld      B,$01           ; Set buffer as empty
1060+ 1902 AF                   xor     A
1061+ 1903 32 93 51             ld      (NULFLG),A      ; Clear null flag
1062+ 1906 CD C9 19     MORINP: call    CLOTST          ; Get character and test ^O
1063+ 1909 4F                   ld      C,A             ; Save character in C
1064+ 190A FE 7F                cp      DEL             ; Delete character?
1065+ 190C CA CC 18             jp      Z,DODEL         ; Yes - Process it
1066+ 190F 3A 93 51             ld      A,(NULFLG)      ; Get null flag
1067+ 1912 B7                   or      A               ; Test null flag status
1068+ 1913 CA 1F 19             jp      Z,PROCES        ; Reset - Process character
1069+ 1916 3E 00                ld      A,$00           ; Set a null
1070+ 1918 CD 88 19             call    OUTC            ; Output null
1071+ 191B AF                   xor     A               ; Clear A
1072+ 191C 32 93 51             ld      (NULFLG),A      ; Reset null flag
1073+ 191F 79           PROCES: ld      A,C             ; Get character
1074+ 1920 FE 07                cp      CTRLG           ; Bell?
1075+ 1922 CA 5F 19             jp      Z,PUTCTL        ; Yes - Save it
1076+ 1925 FE 03                cp      CTRLC           ; Is it control "C"?
1077+ 1927 CC 54 19             call    Z,GMNCR         ; Yes - exit from graphic mode & Output CRLF
1078+ 192A 37                   scf                     ; Flag break
1079+ 192B C8                   ret     Z               ; Return if control "C"
1080+ 192C FE 0D                cp      CR              ; Is it enter?
1081+ 192E CA 81 1E             jp      Z,ENDINP        ; Yes - Terminate input
1082+ 1931 FE 15                cp      CTRLU           ; Is it control "U"?
1083+ 1933 CA F7 18             jp      Z,KILIN         ; Yes - Get another line
1084+ 1936 FE 08                cp      BKSP            ; Is it backspace?
1085+ 1938 CA EC 18             jp      Z,DELCHR        ; Yes - Delete character
1086+ 193B FE 12                cp      CTRLR           ; Is it control "R"?
1087+ 193D C2 5A 19             jp      NZ,PUTBUF       ; No - Put in buffer
1088+ 1940 C5                   push    BC              ; Save buffer length
1089+ 1941 D5                   push    DE              ; Save DE
1090+ 1942 E5                   push    HL              ; Save buffer address
1091+ 1943 36 00                ld      (HL),$00        ; Mark end of buffer
1092+ 1945 CD 82 3F             call    OUTNCR          ; Output and do CRLF
1093+ 1948 21 27 52             ld      HL,BUFFER       ; Point to buffer start
1094+ 194B CD 4F 25             call    PRS             ; Output buffer
1095+ 194E E1                   pop     HL              ; Restore buffer address
1096+ 194F D1                   pop     DE              ; Restore DE
1097+ 1950 C1                   pop     BC              ; Restore buffer length
1098+ 1951 C3 06 19             jp      MORINP          ; Get another character
1099+ 1954 CD 75 16     GMNCR:  call    EXITGM          ; exit from graphic mode
1100+ 1957 C3 8B 1E             jp      PRNTCRLF        ; output CRLF
1101+ 195A
1102+ 195A FE 20        PUTBUF: cp      SPC             ; Is it a control code?
1103+ 195C DA 06 19             jp      C,MORINP        ; Yes - Ignore
1104+ 195F 78           PUTCTL: ld      A,B             ; Get number of bytes in buffer
1105+ 1960 FE 59                cp      $58+$01         ; Test for line overflow
1106+ 1962 3E 08                ld      A,BKSP          ; Set a bell
1107+ 1964 D2 71 19             jp      NC,OUTNBS       ; Ring bell if buffer full
1108+ 1967 79                   ld      A,C             ; Get character
1109+ 1968 71                   ld      (HL),C          ; Save in buffer
1110+ 1969 32 A2 52             ld      (LSTBIN),A      ; Save last input byte
1111+ 196C 23                   inc     HL              ; Move up buffer
1112+ 196D 04                   inc     B               ; Increment length
1113+ 196E C3 06 19     OUTIT:  jp      MORINP          ; Get another character
1114+ 1971
1115+ 1971 CD 88 19     OUTNBS: call    OUTC            ; Output bell and back over it
1116+ 1974 C3 6E 19             jp      OUTIT           ; get more chars
1117+ 1977
1118+ 1977 7C           CPDEHL: ld      A,H             ; Get H
1119+ 1978 92                   sub     D               ; Compare with D
1120+ 1979 C0                   ret     NZ              ; Different - Exit
1121+ 197A 7D                   ld      A,L             ; Get L
1122+ 197B 93                   sub     E               ; Compare with E
1123+ 197C C9                   ret                     ; Return status
1124+ 197D
1125+ 197D 7E           CHKSYN: ld      A,(HL)          ; Check syntax of character
1126+ 197E E3                   ex      (SP),HL         ; Address of test byte
1127+ 197F BE                   cp      (HL)            ; Same as in code string?
1128+ 1980 23                   inc     HL              ; Return address
1129+ 1981 E3                   ex      (SP),HL         ; Put it back
1130+ 1982 CA BE 1B             jp      Z,GETCHR        ; Yes - Get next character
1131+ 1985 C3 9B 16             jp      SNERR           ; Different - ?SN Error
1132+ 1988
1133+ 1988 F5           OUTC:   push    AF              ; Save character
1134+ 1989 3A 94 51             ld      A,(CTLOFG)      ; Get control "O" flag
1135+ 198C B7                   or      A               ; Is it set?
1136+ 198D C2 84 25             jp      NZ,POPAF        ; Yes - don't output
1137+ 1990 F1                   pop     AF              ; Restore character
1138+ 1991 C5                   push    BC              ; Save buffer length
1139+ 1992 F5                   push    AF              ; Save character
1140+ 1993 FE 20                cp      SPC             ; Is it a control code?
1141+ 1995 DA AC 19             jp      C,DINPOS        ; Yes - Don't inc POS(X)
1142+ 1998 3A 91 51             ld      A,(LWIDTH)      ; Get line width
1143+ 199B 47                   ld      B,A             ; To B
1144+ 199C 3A 81 52             ld      A,(CURPOS)      ; Get cursor position
1145+ 199F 04                   inc     B               ; Width 255?
1146+ 19A0 CA A8 19             jp      Z,INCLEN        ; Yes - No width limit
1147+ 19A3 05                   dec     B               ; Restore width
1148+ 19A4 B8                   cp      B               ; At end of line?
1149+ 19A5 CC 8B 1E             call    Z,PRNTCRLF      ; Yes - output CRLF
1150+ 19A8 3C           INCLEN: inc     A               ; Move on one character
1151+ 19A9 32 81 52             ld      (CURPOS),A      ; Save new position
1152+ 19AC AF           DINPOS: xor     A
1153+ 19AD 32 07 53             ld      (KBDNPT),A      ; set flag for no char from keyboard
1154+ 19B0 F1                   pop     AF              ; Restore character
1155+ 19B1 C1                   pop     BC              ; Restore buffer length
1156+ 19B2 F5                   push    AF
1157+ 19B3 CD BB 19             call    SND2VID         ; send char to video
1158+ 19B6 F1                   pop     AF
1159+ 19B7 CD 61 3F             call    MONOUT          ; send char to serial if enabled
1160+ 19BA C9                   ret
1161+ 19BB
1162+ 19BB              ; print char to video if cursor is on
1163+ 19BB 32 CA 52     SND2VID:ld      (CHR4VID),A     ; store A
1164+ 19BE 3A C9 52             ld      A,(PRNTVIDEO)   ; check print-on-video
1165+ 19C1 B7                   or      A               ; is it off?
1166+ 19C2 C8                   ret     Z               ; yes, so return
1167+ 19C3 F3                   di                      ; disable INTs
1168+ 19C4 CD 4E 07             call    CHAR2VID        ; cursor is on, so print char on screen
1169+ 19C7 FB                   ei                      ; re-enable INTs
1170+ 19C8 C9                   ret                     ; return to caller
1171+ 19C9
1172+ 19C9 CD 0A 33     CLOTST: call    GETINP          ; Get input character
1173+ 19CC FE 0F                cp      CTRLO           ; Is it control "O"?
1174+ 19CE C0                   ret     NZ              ; No don't flip flag
1175+ 19CF 3A 94 51             ld      A,(CTLOFG)      ; Get flag
1176+ 19D2 2F                   cpl                     ; Flip it
1177+ 19D3 32 94 51             ld      (CTLOFG),A      ; Put it back
1178+ 19D6 A7                   and     A               ; is output enabled?
1179+ 19D7 CC EA 08             call    Z,CURSOR_ON     ; yes, so cursor on
1180+ 19DA AF                   xor     A               ; Null character
1181+ 19DB C9                   ret
1182+ 19DC
1183+ 19DC              ; LIST: list the program stored into memory
1184+ 19DC C1           LIST:   pop     BC              ; rubbish - not needed (legacy from original call of LIST)
1185+ 19DD 2B                   dec     HL              ; dec 'cos GETCHR INCs
1186+ 19DE CD BE 1B             call    GETCHR          ; Get next character
1187+ 19E1 CA 37 1A             jp      Z,LSTALL        ; list all if nothing follows
1188+ 19E4 FE BE                cp      ZMINUS          ; is it '-'?
1189+ 19E6 20 20                jr      NZ,LST01        ; no, look for a line number
1190+ 19E8 11 00 00             ld      DE,$0000        ; yes, set search from 0
1191+ 19EB CD D8 1A             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1192+ 19EE ED 43 CD 52          ld      (TMPBFR1),BC    ; store address of starting line
1193+ 19F2 CD 7D 19             call    CHKSYN          ; skip '-'
1194+ 19F5 BE                   defb    ZMINUS
1195+ 19F6 CD 8E 1C             call    ATOH            ; now, look for another number (ASCII number to DE)
1196+ 19F9 CD DE 1A             call    SRCLN           ; find a line, getting the previous if it doesn't exist
1197+ 19FC ED 43 CF 52          ld      (TMPBFR2),BC    ; store address of ending line
1198+ 1A00 ED 4B CD 52          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1199+ 1A04 C5                   push    BC              ; store address of line for later use
1200+ 1A05 C3 6F 1A             jp      LISTLP          ; go listing
1201+ 1A08 CD 8E 1C     LST01:  call    ATOH            ; get a line number (ASCII number to DE)
1202+ 1A0B ED 53 D3 52  LST01H: ld      (TMPBFR4),DE    ; store ending line address for later use - N.B.: this is a hook for HELP command
1203+ 1A0F CD D8 1A             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1204+ 1A12 ED 43 CD 52          ld      (TMPBFR1),BC    ; store address of starting line
1205+ 1A16 ED 43 CF 52          ld      (TMPBFR2),BC    ; same address for ending line (we'll change it later if needed)
1206+ 1A1A 2B                   dec     HL              ; dec 'cos GETCHR INCs
1207+ 1A1B CD BE 1B             call    GETCHR          ; Get next character
1208+ 1A1E CA 2A 1A             jp      Z,LSTNOT        ; nothing follows, so ending & starting lines are the same
1209+ 1A21 FE BE                cp      ZMINUS          ; is it '-'?
1210+ 1A23 CA 4F 1A             jp      Z,LST03         ; yes, read ending line
1211+ 1A26 C5           LST06:  push    BC              ; store address for later use
1212+ 1A27 C3 6F 1A             jp      LISTLP          ; jump to list
1213+ 1A2A ED 5B D3 52  LSTNOT: ld      DE,(TMPBFR4)
1214+ 1A2E CD D8 1A             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1215+ 1A31 DA 26 1A             jp      C,LST06
1216+ 1A34 C3 F5 16             jp      PRNTOK
1217+ 1A37 11 F9 FF     LSTALL: ld      DE,65529        ; set ending line to max. allowed line number
1218+ 1A3A CD D8 1A             call    SRCHLIN         ; get address of last line
1219+ 1A3D ED 43 CF 52          ld      (TMPBFR2),BC    ; store it
1220+ 1A41 11 00 00             ld      DE,$0000        ; set start to first line in memory
1221+ 1A44 CD D8 1A             call    SRCHLIN         ; get address of first line
1222+ 1A47 ED 43 CD 52          ld      (TMPBFR1),BC    ; store it
1223+ 1A4B C5                   push    BC              ; store address of starting line for later use
1224+ 1A4C C3 6F 1A             jp      LISTLP          ; start printing
1225+ 1A4F CD 7D 19     LST03:  call    CHKSYN          ; skip '-'
1226+ 1A52 BE                   defb    ZMINUS
1227+ 1A53 CD 8E 1C             call    ATOH            ; look for another number (return into DE)
1228+ 1A56 7A                   ld      A,D
1229+ 1A57 B3                   or      E               ; is line=0?
1230+ 1A58 20 09                jr      NZ,LST05        ; no, jump over
1231+ 1A5A 11 F9 FF             ld      DE,65529        ; yes set last valid line number
1232+ 1A5D CD D8 1A             call    SRCHLIN         ; get address of last line
1233+ 1A60 C3 66 1A             jp      LST02
1234+ 1A63 CD DE 1A     LST05:  call    SRCLN           ; find a line, getting the previous if it doesn't exist
1235+ 1A66 ED 43 CF 52  LST02:  ld      (TMPBFR2),BC    ; store address of ending line
1236+ 1A6A ED 4B CD 52          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1237+ 1A6E C5                   push    BC              ; store it for later use
1238+ 1A6F E1           LISTLP: pop     HL              ; Restore address of line
1239+ 1A70 4E                   ld      C,(HL)          ; Get LSB of next line
1240+ 1A71 23                   inc     HL
1241+ 1A72 46                   ld      B,(HL)          ; Get MSB of next line
1242+ 1A73 23                   inc     HL
1243+ 1A74 78                   ld      A,B             ; BC = 0 (End of program)?
1244+ 1A75 B1                   or      C
1245+ 1A76 CA F5 16             jp      Z,PRNTOK        ; Yes - Go to command mode
1246+ 1A79 CD E9 1B             call    TSTBRK          ; Test for break key
1247+ 1A7C CD EC 1A             call    TSTSPC          ; test for space
1248+ 1A7F C5                   push    BC              ; Save address of next line
1249+ 1A80 3A C2 52             ld      A,(SCR_CURS_X)  ; load current X pos of cursor
1250+ 1A83 A7                   and     A               ; is it at the beginning of a new line?
1251+ 1A84 20 0B                jr      NZ,LST08        ; No, jump over
1252+ 1A86 3E 0D                ld      A,CR            ; yes, so just send a CR
1253+ 1A88 CD 61 3F             call    MONOUT          ; to serial if it's open
1254+ 1A8B AF                   xor     A               ; then, set cursor
1255+ 1A8C 32 81 52             ld      (CURPOS),A      ; to position 0
1256+ 1A8F 18 03                jr      LST07           ; and continue
1257+ 1A91 CD 8B 1E     LST08:  call    PRNTCRLF        ; output CRLF
1258+ 1A94 5E           LST07:  ld      E,(HL)          ; Get LSB of line number
1259+ 1A95 23                   inc     HL
1260+ 1A96 56                   ld      D,(HL)          ; Get MSB of line number
1261+ 1A97 23                   inc     HL
1262+ 1A98 E5                   push    HL              ; Save address of line start
1263+ 1A99 EB                   ex      DE,HL           ; Line number to HL
1264+ 1A9A CD EE 2F             call    PRNTHL          ; Output line number in decimal
1265+ 1A9D 3E 20                ld      A,SPC           ; Space after line number
1266+ 1A9F E1                   pop     HL              ; Restore start of line address
1267+ 1AA0 CD 88 19     LSTLP2: call    OUTC            ; Output character in A
1268+ 1AA3 7E           LSTLP3: ld      A,(HL)          ; Get next byte in line
1269+ 1AA4 B7                   or      A               ; End of line?
1270+ 1AA5 23                   inc     HL              ; To next byte in line
1271+ 1AA6 CA CA 1A             jp      Z,NXTLN         ; Yes - check next line
1272+ 1AA9 F2 A0 1A             jp      P,LSTLP2        ; No token - output it
1273+ 1AAC D6 7F                sub     ZEND-1          ; Find and output word
1274+ 1AAE 4F                   ld      C,A             ; Token offset+1 to C
1275+ 1AAF 11 1D 13             ld      DE,WORDS        ; Reserved word list
1276+ 1AB2 1A           FNDTOK: ld      A,(DE)          ; Get character in list
1277+ 1AB3 13                   inc     DE              ; Move on to next
1278+ 1AB4 B7                   or      A               ; Is it start of word?
1279+ 1AB5 F2 B2 1A             jp      P,FNDTOK        ; No - Keep looking for word
1280+ 1AB8 0D                   dec     C               ; Count words
1281+ 1AB9 C2 B2 1A             jp      NZ,FNDTOK       ; Not there - keep looking
1282+ 1ABC E6 7F        OUTWRD: and     %01111111       ; Strip bit 7
1283+ 1ABE CD 88 19             call    OUTC            ; Output character
1284+ 1AC1 1A                   ld      A,(DE)          ; Get next character
1285+ 1AC2 13                   inc     DE              ; Move on to next
1286+ 1AC3 B7                   or      A               ; Is it end of word?
1287+ 1AC4 F2 BC 1A             jp      P,OUTWRD        ; No - output the rest
1288+ 1AC7 C3 A3 1A             jp      LSTLP3          ; Next byte in line
1289+ 1ACA D1           NXTLN:  pop     DE              ; recover address of current line
1290+ 1ACB 2A CF 52             ld      HL,(TMPBFR2)    ; address of last line to print
1291+ 1ACE CD 88 3F             call    CMP16           ; check if current line is over last printable line
1292+ 1AD1 DA F5 16             jp      C,PRNTOK        ; finish - leave & print OK
1293+ 1AD4 D5                   push    DE              ; store address of current line
1294+ 1AD5 C3 6F 1A             jp      LISTLP          ; continue listing
1295+ 1AD8              ; look for the address of a program line
1296+ 1AD8 E5           SRCHLIN:push    HL              ; store HL (this is needed because HL store the pointer to the input buffer)
1297+ 1AD9 CD A1 17             call    SRCHLN          ; search for line number in DE
1298+ 1ADC E1                   pop     HL              ; retrieve HL
1299+ 1ADD C9                   ret                     ; return to caller
1300+ 1ADE              ; look for the address of a program line - if the line isn't found,
1301+ 1ADE              ; it look backward for the previous line
1302+ 1ADE E5           SRCLN:  push    HL              ; store HL
1303+ 1ADF CD A1 17     SRCLN1: call    SRCHLN          ; search for line in DE
1304+ 1AE2 DA EA 1A             jp      C,LVSRLN        ; found it, leave loop
1305+ 1AE5 1B                   dec     DE              ; not found, decrement number to look backward for an existing line
1306+ 1AE6 7B                   ld      A,E
1307+ 1AE7 B2                   or      D               ; is line number zero?
1308+ 1AE8 20 F5                jr      NZ,SRCLN1       ; no, continue
1309+ 1AEA E1           LVSRLN: pop     HL              ; retrieve HL
1310+ 1AEB C9                   ret                     ; return to caller
1311+ 1AEC
1312+ 1AEC              ; during LISTing, check if PAUSE is pressed, then pause listing and
1313+ 1AEC              ; wait for another pressing of PAUSE to continue or CTRL-C/BREAK to exit
1314+ 1AEC 3A 09 53     TSTSPC: ld      A,(TMPKEYBFR)   ; Get input character
1315+ 1AEF FE 20                cp      SPC             ; Is it SPACE?
1316+ 1AF1 C0                   ret     NZ              ; No, return
1317+ 1AF2 CD 0A 33     WTSPC:  call    GETINP          ; Yes, stop listing and wait for another space or BREAK
1318+ 1AF5 FE 20                cp      SPC             ; is it SPACE?
1319+ 1AF7 20 05                jr      NZ,CNTWTSP      ; no, continue
1320+ 1AF9 AF                   xor     A
1321+ 1AFA 32 09 53             ld      (TMPKEYBFR),A   ; reset key
1322+ 1AFD C9                   ret                     ; return to caller
1323+ 1AFE FE 03        CNTWTSP:cp      CTRLC           ; is it CTRL-C/BREAK?
1324+ 1B00 20 F0                jr      NZ,WTSPC        ; no, loop
1325+ 1B02 C3 6A 12             jp      BRKRET          ; exit and output "Ok"
1326+ 1B05
1327+ 1B05
1328+ 1B05 3E 64        FOR:    ld      A,$64           ; Flag "FOR" assignment
1329+ 1B07 32 A1 52             ld      (FORFLG),A      ; Save "FOR" flag
1330+ 1B0A CD 7E 1D             call    LET             ; Set up initial index
1331+ 1B0D C1                   pop     BC              ; Drop RETurn address
1332+ 1B0E E5                   push    HL              ; Save code string address
1333+ 1B0F CD 67 1D             call    DATA            ; Get next statement address
1334+ 1B12 22 9D 52             ld      (LOOPST),HL     ; Save it for start of loop
1335+ 1B15 21 02 00             ld      HL,$0002        ; Offset for "FOR" block
1336+ 1B18 39                   add     HL,SP           ; Point to it
1337+ 1B19 CD 28 16     FORSLP: call    LOKFOR          ; Look for existing "FOR" block
1338+ 1B1C D1                   pop     DE              ; Get code string address
1339+ 1B1D C2 35 1B             jp      NZ,FORFND       ; No nesting found
1340+ 1B20 09                   add     HL,BC           ; Move into "FOR" block
1341+ 1B21 D5                   push    DE              ; Save code string address
1342+ 1B22 2B                   dec     HL
1343+ 1B23 56                   ld      D,(HL)          ; Get MSB of loop statement
1344+ 1B24 2B                   dec     HL
1345+ 1B25 5E                   ld      E,(HL)          ; Get LSB of loop statement
1346+ 1B26 23                   inc     HL
1347+ 1B27 23                   inc     HL
1348+ 1B28 E5                   push    HL              ; Save block address
1349+ 1B29 2A 9D 52             ld      HL,(LOOPST)     ; Get address of loop statement
1350+ 1B2C CD 77 19             call    CPDEHL          ; Compare the FOR loops
1351+ 1B2F E1                   pop     HL              ; Restore block address
1352+ 1B30 C2 19 1B             jp      NZ,FORSLP       ; Different FORs - Find another
1353+ 1B33 D1                   pop     DE              ; Restore code string address
1354+ 1B34 F9                   ld      SP,HL           ; Remove all nested loops
1355+ 1B35
1356+ 1B35 EB           FORFND: ex      DE,HL           ; Code string address to HL
1357+ 1B36 0E 08                ld      C,$08
1358+ 1B38 CD 58 16             call    CHKSTK          ; Check for 8 levels of stack
1359+ 1B3B E5                   push    HL              ; Save code string address
1360+ 1B3C 2A 9D 52             ld      HL,(LOOPST)     ; Get first statement of loop
1361+ 1B3F E3                   ex      (SP),HL         ; Save and restore code string
1362+ 1B40 E5                   push    HL              ; Re-save code string address
1363+ 1B41 2A 9E 51             ld      HL,(LINEAT)     ; Get current line number
1364+ 1B44 E3                   ex      (SP),HL         ; Save and restore code string
1365+ 1B45 CD 4A 20             call    TSTNUM          ; Make sure it's a number
1366+ 1B48 CD 7D 19             call    CHKSYN          ; Make sure "TO" is next
1367+ 1B4B B7                   defb    ZTO             ; "TO" token
1368+ 1B4C CD 47 20             call    GETNUM          ; Get "TO" expression value
1369+ 1B4F E5                   push    HL              ; Save code string address
1370+ 1B50 CD A0 2E             call    BCDEFP          ; Move "TO" value to BCDE
1371+ 1B53 E1                   pop     HL              ; Restore code string address
1372+ 1B54 C5                   push    BC              ; Save "TO" value in block
1373+ 1B55 D5                   push    DE
1374+ 1B56 01 00 81             ld      BC,$8100        ; BCDE - 1 (default STEP)
1375+ 1B59 51                   ld      D,C             ; C=0
1376+ 1B5A 5A                   ld      E,D             ; D=0
1377+ 1B5B 7E                   ld      A,(HL)          ; Get next byte in code string
1378+ 1B5C FE BC                cp      ZSTEP           ; See if "STEP" is stated
1379+ 1B5E 3E 01                ld      A,$01           ; Sign of step = 1
1380+ 1B60 C2 71 1B             jp      NZ,SAVSTP       ; No STEP given - Default to 1
1381+ 1B63 CD BE 1B             call    GETCHR          ; Jump over "STEP" token
1382+ 1B66 CD 47 20             call    GETNUM          ; Get step value
1383+ 1B69 E5                   push    HL              ; Save code string address
1384+ 1B6A CD A0 2E             call    BCDEFP          ; Move STEP to BCDE
1385+ 1B6D CD 54 2E             call    TSTSGN          ; Test sign of FPREG
1386+ 1B70 E1                   pop     HL              ; Restore code string address
1387+ 1B71 C5           SAVSTP: push    BC              ; Save the STEP value in block
1388+ 1B72 D5                   push    DE
1389+ 1B73 F5                   push    AF              ; Save sign of STEP
1390+ 1B74 33                   inc     SP              ; Don't save flags
1391+ 1B75 E5                   push    HL              ; Save code string address
1392+ 1B76 2A A4 52             ld      HL,(BRKLIN)     ; Get address of index variable
1393+ 1B79 E3                   ex      (SP),HL         ; Save and restore code string
1394+ 1B7A 06 81        PUTFID: ld      B,ZFOR          ; "FOR" block marker
1395+ 1B7C C5                   push    BC              ; Save it
1396+ 1B7D 33                   inc     SP              ; Don't save C
1397+ 1B7E
1398+ 1B7E CD E9 1B     RUNCNT: call    TSTBRK          ; Execution driver - Test break
1399+ 1B81 22 A4 52             ld      (BRKLIN),HL     ; Save code address for break
1400+ 1B84 7E                   ld      A,(HL)          ; Get next byte in code string
1401+ 1B85 FE 3A                cp      ':'             ; Multi statement line?
1402+ 1B87 CA 9E 1B             jp      Z,EXCUTE        ; Yes - Execute it
1403+ 1B8A B7                   or      A               ; End of line?
1404+ 1B8B C2 9B 16             jp      NZ,SNERR        ; No - Syntax error
1405+ 1B8E 23                   inc     HL              ; Point to address of next line
1406+ 1B8F 7E                   ld      A,(HL)          ; Get LSB of line pointer
1407+ 1B90 23                   inc     HL
1408+ 1B91 B6                   or      (HL)            ; Is it zero (End of prog)?
1409+ 1B92 CA 10 1C             jp      Z,ENDPRG        ; Yes - Terminate execution
1410+ 1B95 23                   inc     HL              ; Point to line number
1411+ 1B96 5E                   ld      E,(HL)          ; Get LSB of line number
1412+ 1B97 23                   inc     HL
1413+ 1B98 56                   ld      D,(HL)          ; Get MSB of line number
1414+ 1B99 EB                   ex      DE,HL           ; Line number to HL
1415+ 1B9A 22 9E 51             ld      (LINEAT),HL     ; Save as current line number
1416+ 1B9D EB                   ex      DE,HL           ; Line number back to DE
1417+ 1B9E CD BE 1B     EXCUTE: call    GETCHR          ; Get key word
1418+ 1BA1 11 7E 1B             ld      DE,RUNCNT       ; Where to RETurn to
1419+ 1BA4 D5                   push    DE              ; Save for RETurn
1420+ 1BA5 C8           IFJMP:  ret     Z               ; Go to RUNCNT if end of STMT
1421+ 1BA6
1422+ 1BA6 D6 80        ONJMP:  sub     ZEND            ; Is it a token?
1423+ 1BA8 DA 7E 1D             jp      C,LET           ; No - try to assign it
1424+ 1BAB FE 36                cp      ZNEW+1-ZEND     ; END to NEW ?
1425+ 1BAD D2 9B 16             jp      NC,SNERR        ; Not a key word - ?SN Error
1426+ 1BB0 07                   rlca                    ; Double it
1427+ 1BB1 4F                   ld      C,A             ; BC = Offset into table
1428+ 1BB2 06 00                ld      B,0
1429+ 1BB4 EB                   ex      DE,HL           ; Save code string address
1430+ 1BB5 21 AA 14             ld      HL,WORDTB       ; Keyword address table
1431+ 1BB8 09                   add     HL,BC           ; Point to routine address
1432+ 1BB9 4E                   ld      C,(HL)          ; Get LSB of routine address
1433+ 1BBA 23                   inc     HL
1434+ 1BBB 46                   ld      B,(HL)          ; Get MSB of routine address
1435+ 1BBC C5                   push    BC              ; Save routine address
1436+ 1BBD EB                   ex      DE,HL           ; Restore code string address
1437+ 1BBE
1438+ 1BBE              ; get a char from input buffer: exit with NC if character found is
1439+ 1BBE              ; not a number; exit with Z if nothing found; char is into A
1440+ 1BBE 23           GETCHR: inc     HL              ; Point to next character
1441+ 1BBF 7E                   ld      A,(HL)          ; Get next code string byte
1442+ 1BC0 FE 3A                cp      ':'             ; Z if ':'
1443+ 1BC2 D0                   ret     NC              ; NC if > "9"
1444+ 1BC3 FE 20                cp      SPC
1445+ 1BC5 CA BE 1B             jp      Z,GETCHR        ; Skip over spaces
1446+ 1BC8 FE 30                cp      '0'
1447+ 1BCA 3F                   ccf                     ; NC if < '0'
1448+ 1BCB 3C                   inc     A               ; Test for zero - Leave carry
1449+ 1BCC 3D                   dec     A               ; Z if Null
1450+ 1BCD C9                   ret
1451+ 1BCE
1452+ 1BCE EB           RESTOR: ex      DE,HL           ; Save code string address
1453+ 1BCF 2A 24 52             ld      HL,(BASTXT)     ; Point to start of program
1454+ 1BD2 CA E3 1B             jp      Z,RESTNL        ; Just RESTORE - reset pointer
1455+ 1BD5 EB                   ex      DE,HL           ; Restore code string address
1456+ 1BD6 CD 8E 1C             call    ATOH            ; Get line number to DE
1457+ 1BD9 E5                   push    HL              ; Save code string address
1458+ 1BDA CD A1 17             call    SRCHLN          ; Search for line number in DE
1459+ 1BDD 60                   ld      H,B             ; HL = Address of line
1460+ 1BDE 69                   ld      L,C
1461+ 1BDF D1                   pop     DE              ; Restore code string address
1462+ 1BE0 D2 3D 1D             jp      NC,ULERR        ; ?UL Error if not found
1463+ 1BE3 2B           RESTNL: dec     HL              ; Byte before DATA statement
1464+ 1BE4 22 19 53     UPDATA: ld      (NXTDAT),HL     ; Update DATA pointer
1465+ 1BE7 EB                   ex      DE,HL           ; Restore code string address
1466+ 1BE8 C9                   ret
1467+ 1BE9
1468+ 1BE9
1469+ 1BE9              ; check if CTRL-C is into input buffer
1470+ 1BE9 DF           TSTBRK: rst     $18             ; Check input status
1471+ 1BEA C8                   ret     Z               ; No key, go back
1472+ 1BEB D7                   rst     $10             ; Get the key into A
1473+ 1BEC FE 1B                cp      ESC             ; Escape key?
1474+ 1BEE 28 11                jr      Z,BRK           ; Yes, break
1475+ 1BF0 FE 03                cp      CTRLC           ; <Ctrl-C>
1476+ 1BF2 28 0D                jr      Z,BRK           ; Yes, break
1477+ 1BF4 FE 13                cp      CTRLS           ; Stop scrolling?
1478+ 1BF6 C0                   ret     NZ              ; Other key, ignore
1479+ 1BF7
1480+ 1BF7
1481+ 1BF7              ; wait for a key while listing
1482+ 1BF7 D7           STALL:  rst     $10             ; Wait for key
1483+ 1BF8 FE 11                cp      CTRLQ           ; Resume scrolling?
1484+ 1BFA C8                   ret     Z               ; Release the chokehold
1485+ 1BFB FE 03                cp      CTRLC           ; Second break?
1486+ 1BFD 28 07                jr      Z,STOP          ; Break during hold exits prog
1487+ 1BFF 18 F6                jr      STALL           ; Loop until <Ctrl-Q> or <brk>
1488+ 1C01
1489+ 1C01 3E FF        BRK:    ld      A,$FF           ; Set BRKFLG
1490+ 1C03 32 98 51             ld      (BRKFLG),A      ; Store it
1491+ 1C06
1492+ 1C06 C0           STOP:   ret     NZ              ; Exit if anything else
1493+ 1C07 F6                   defb    $F6             ; Flag "STOP"
1494+ 1C08 C0           PEND:   ret     NZ              ; Exit if anything else
1495+ 1C09 22 A4 52             ld      (BRKLIN),HL     ; Save point of break
1496+ 1C0C 21                   defb    $21             ; Skip "OR 11111111B"
1497+ 1C0D F6 FF        INPBRK: or      %11111111       ; Flag "Break" wanted
1498+ 1C0F C1                   pop     BC              ; Return not needed and more
1499+ 1C10 2A 9E 51     ENDPRG: ld      HL,(LINEAT)     ; Get current line number
1500+ 1C13 F5                   push    AF              ; Save STOP / END status
1501+ 1C14 7D                   ld      A,L             ; Is it direct break?
1502+ 1C15 A4                   and     H
1503+ 1C16 3C                   inc     A               ; Line is -1 if direct break
1504+ 1C17 CA 23 1C             jp      Z,NOLIN         ; Yes - No line number
1505+ 1C1A 22 A8 52             ld      (ERRLIN),HL     ; Save line of break
1506+ 1C1D 2A A4 52             ld      HL,(BRKLIN)     ; Get point of break
1507+ 1C20 22 AA 52             ld      (CONTAD),HL     ; Save point to CONTinue
1508+ 1C23 AF           NOLIN:  xor     A
1509+ 1C24 32 94 51             ld      (CTLOFG),A      ; Enable output
1510+ 1C27 CD 79 1E             call    STTLIN          ; Start a new line
1511+ 1C2A F1                   pop     AF              ; Restore STOP / END status
1512+ 1C2B 21 1E 16             ld      HL,BRKMSG       ; "Break" message
1513+ 1C2E C2 34 1C             jp      NZ,ERRINT       ; "in line" wanted?
1514+ 1C31 C3 F5 16             jp      PRNTOK          ; Go to command mode
1515+ 1C34 CD 75 16     ERRINT: call    EXITGM          ; exit from graphics mode
1516+ 1C37 C3 D3 16             jp      ERRIN           ; print message
1517+ 1C3A
1518+ 1C3A
1519+ 1C3A              ; CONTinue after a break/error
1520+ 1C3A 21 FF FF     CONT:   ld      HL,-1           ; reset...
1521+ 1C3D 22 A0 51             ld      (HLPLN),HL      ; ...HELP line register
1522+ 1C40 2A AA 52             ld      HL,(CONTAD)     ; Get CONTinue address
1523+ 1C43 7C                   ld      A,H             ; Is it zero?
1524+ 1C44 B5                   or      L
1525+ 1C45 1E 20                ld      E,CN            ; ?CN Error
1526+ 1C47 CA AF 16             jp      Z,ERROR         ; Yes - output "?CN Error"
1527+ 1C4A EB                   ex      DE,HL           ; Save code string address
1528+ 1C4B 2A A8 52             ld      HL,(ERRLIN)     ; Get line of last break
1529+ 1C4E 22 9E 51             ld      (LINEAT),HL     ; Set up current line number
1530+ 1C51 EB                   ex      DE,HL           ; Restore code string address
1531+ 1C52 C9                   ret                     ; CONTinue where left off
1532+ 1C53
1533+ 1C53 E5           ACCSUM: push    HL              ; Save address in array
1534+ 1C54 2A 95 51             ld      HL,(CHKSUM)     ; Get check sum
1535+ 1C57 06 00                ld      B,$00           ; BC - Value of byte
1536+ 1C59 4F                   ld      C,A
1537+ 1C5A 09                   add     HL,BC           ; Add byte to check sum
1538+ 1C5B 22 95 51             ld      (CHKSUM),HL     ; Re-save check sum
1539+ 1C5E E1                   pop     HL              ; Restore address in array
1540+ 1C5F C9                   ret
1541+ 1C60
1542+ 1C60 7E           CHKLTR: ld      A,(HL)          ; Get byte
1543+ 1C61 FE 41                cp      'A'             ; < 'a' ?
1544+ 1C63 D8                   ret     C               ; Carry set if not letter
1545+ 1C64 FE 5B                cp      'Z'+1           ; > 'z' ?
1546+ 1C66 3F                   ccf
1547+ 1C67 C9                   ret                     ; Carry set if not letter
1548+ 1C68
1549+ 1C68 CD BE 1B     FPSINT: call    GETCHR          ; Get next character
1550+ 1C6B CD 47 20     POSINT: call    GETNUM          ; Get integer 0 to 32767
1551+ 1C6E CD 54 2E     DEPINT: call    TSTSGN          ; Test sign of FPREG
1552+ 1C71 FA 89 1C             jp      M,FCERR         ; Negative - ?FC Error
1553+ 1C74 3A 24 53     DEINT:  ld      A,(FPEXP)       ; Get integer value to DE
1554+ 1C77 FE 90                cp      $80+$10         ; Exponent in range (16 bits)?
1555+ 1C79 DA FC 2E             jp      C,FPINT         ; Yes - convert it
1556+ 1C7C 01 80 90             ld      BC,$9080        ; BCDE = -32768
1557+ 1C7F 11 00 00             ld      DE,$0000
1558+ 1C82 E5                   push    HL              ; Save code string address
1559+ 1C83 CD CF 2E             call    CMPNUM          ; Compare FPREG with BCDE
1560+ 1C86 E1                   pop     HL              ; Restore code string address
1561+ 1C87 51                   ld      D,C             ; MSB to D
1562+ 1C88 C8                   ret     Z               ; Return if in range
1563+ 1C89 1E 08        FCERR:  ld      E,FC            ; ?FC Error
1564+ 1C8B C3 AF 16             jp      ERROR           ; Output error-
1565+ 1C8E
1566+ 1C8E
1567+ 1C8E              ; convert a number in ASCII chars into an integer into DE
1568+ 1C8E 2B           ATOH:   dec     HL              ; ASCII number to DE binary
1569+ 1C8F 11 00 00     GETLN:  ld      DE,$0000        ; Get number to DE
1570+ 1C92 CD BE 1B     GTLNLP: call    GETCHR          ; Get next character
1571+ 1C95 D0                   ret     NC              ; Exit if not a digit
1572+ 1C96 E5                   push    HL              ; Save code string address
1573+ 1C97 F5                   push    AF              ; Save digit
1574+ 1C98 21 98 19             ld      HL,65529/10     ; Largest number 65529
1575+ 1C9B CD 77 19             call    CPDEHL          ; Number in range?
1576+ 1C9E DA 9B 16             jp      C,SNERR         ; No - ?SN Error
1577+ 1CA1 62                   ld      H,D             ; HL = Number
1578+ 1CA2 6B                   ld      L,E
1579+ 1CA3 19                   add     HL,DE           ; Times 2
1580+ 1CA4 29                   add     HL,HL           ; Times 4
1581+ 1CA5 19                   add     HL,DE           ; Times 5
1582+ 1CA6 29                   add     HL,HL           ; Times 10
1583+ 1CA7 F1                   pop     AF              ; Restore digit
1584+ 1CA8 D6 30                sub     '0'             ; Make it 0 to 9
1585+ 1CAA 5F                   ld      E,A             ; DE = Value of digit
1586+ 1CAB 16 00                ld      D,0
1587+ 1CAD 19                   add     HL,DE           ; Add to number
1588+ 1CAE EB                   ex      DE,HL           ; Number to DE
1589+ 1CAF E1                   pop     HL              ; Restore code string address
1590+ 1CB0 C3 92 1C             jp      GTLNLP          ; Go to next character
1591+ 1CB3
1592+ 1CB3 CA D1 17     CLEAR:  jp      Z,INTVAR        ; Just "CLEAR" Keep parameters
1593+ 1CB6 CD 47 20             call    GETNUM          ; Evaluate a number
1594+ 1CB9 CD 74 1C             call    DEINT           ; Get integer -32768 to 32767 into DE
1595+ 1CBC 2B                   dec     HL              ; Cancel increment
1596+ 1CBD CD BE 1B             call    GETCHR          ; Get next character
1597+ 1CC0 E5                   push    HL              ; Save code string address
1598+ 1CC1 2A 85 52             ld      HL,(LSTRAM)     ; Get end of RAM
1599+ 1CC4 CA DC 1C             jp      Z,STORED        ; No value given - Use stored
1600+ 1CC7 E1                   pop     HL              ; Restore code string address
1601+ 1CC8 CD 7D 19             call    CHKSYN          ; Check for comma
1602+ 1CCB 2C                   defb    ','
1603+ 1CCC D5                   push    DE              ; Save number
1604+ 1CCD CD 47 20             call    GETNUM          ; Evaluate a number
1605+ 1CD0 CD 74 1C             call    DEINT           ; Get integer -32768 to 32767 into DE
1606+ 1CD3 2B                   dec     HL              ; Cancel increment
1607+ 1CD4 CD BE 1B             call    GETCHR          ; Get next character
1608+ 1CD7 C2 9B 16             jp      NZ,SNERR        ; ?SN Error if more on line
1609+ 1CDA E3                   ex      (SP),HL         ; Save code string address
1610+ 1CDB EB                   ex      DE,HL           ; Number to DE
1611+ 1CDC 7D           STORED: ld      A,L             ; Get LSB of new RAM top
1612+ 1CDD 93                   sub     E               ; Subtract LSB of string space
1613+ 1CDE 5F                   ld      E,A             ; Save LSB
1614+ 1CDF 7C                   ld      A,H             ; Get MSB of new RAM top
1615+ 1CE0 9A                   sbc     A,D             ; Subtract MSB of string space
1616+ 1CE1 57                   ld      D,A             ; Save MSB
1617+ 1CE2 DA 70 16             jp      C,OMERR         ; ?OM Error if not enough mem
1618+ 1CE5 E5                   push    HL              ; Save RAM top
1619+ 1CE6 2A 13 53             ld      HL,(PROGND)     ; Get program end
1620+ 1CE9 01 28 00             ld      BC,$28          ; 40 Bytes minimum working RAM
1621+ 1CEC 09                   add     HL,BC           ; Get lowest address
1622+ 1CED CD 77 19             call    CPDEHL          ; Enough memory?
1623+ 1CF0 D2 70 16             jp      NC,OMERR        ; No - ?OM Error
1624+ 1CF3 EB                   ex      DE,HL           ; RAM top to HL
1625+ 1CF4 22 9C 51             ld      (STRSPC),HL     ; Set new string space
1626+ 1CF7 E1                   pop     HL              ; End of memory to use
1627+ 1CF8 22 85 52             ld      (LSTRAM),HL     ; Set new top of RAM
1628+ 1CFB E1                   pop     HL              ; Restore code string address
1629+ 1CFC C3 D1 17             jp      INTVAR          ; Initialise variables
1630+ 1CFF
1631+ 1CFF E5           RUN:    push    HL              ; store HL
1632+ 1D00 21 FF FF             ld      HL,-1           ; reset...
1633+ 1D03 22 A0 51             ld      (HLPLN),HL      ; ...HELP line register
1634+ 1D06 E1                   pop     HL              ; retrieve HL
1635+ 1D07 CA CD 17             jp      Z,RUNFST        ; RUN from start if just RUN
1636+ 1D0A CD D1 17             call    INTVAR          ; Initialise variables
1637+ 1D0D 01 7E 1B             ld      BC,RUNCNT       ; Execution driver loop
1638+ 1D10 C3 23 1D             jp      RUNLIN          ; RUN from line number
1639+ 1D13
1640+ 1D13 0E 03        GOSUB:  ld      C,$03           ; 3 Levels of stack needed
1641+ 1D15 CD 58 16             call    CHKSTK          ; Check for 3 levels of stack
1642+ 1D18 C1                   pop     BC              ; Get return address
1643+ 1D19 E5                   push    HL              ; Save code string for RETURN
1644+ 1D1A E5                   push    HL              ; And for GOSUB routine
1645+ 1D1B 2A 9E 51             ld      HL,(LINEAT)     ; Get current line
1646+ 1D1E E3                   ex      (SP),HL         ; Into stack - Code string out
1647+ 1D1F 3E 8C                ld      A,ZGOSUB        ; "GOSUB" token
1648+ 1D21 F5                   push    AF              ; Save token
1649+ 1D22 33                   inc     SP              ; Don't save flags
1650+ 1D23
1651+ 1D23 C5           RUNLIN: push    BC              ; Save return address
1652+ 1D24 CD 8E 1C     GOTO:   call    ATOH            ; ASCII number to DE binary
1653+ 1D27 CD 69 1D             call    REM             ; Get end of line
1654+ 1D2A E5                   push    HL              ; Save end of line
1655+ 1D2B 2A 9E 51             ld      HL,(LINEAT)     ; Get current line
1656+ 1D2E CD 77 19             call    CPDEHL          ; Line after current?
1657+ 1D31 E1                   pop     HL              ; Restore end of line
1658+ 1D32 23                   inc     HL              ; Start of next line
1659+ 1D33 DC A4 17             call    C,SRCHLP        ; Line is after current line
1660+ 1D36 D4 A1 17             call    NC,SRCHLN       ; Line is before current line
1661+ 1D39 60                   ld      H,B             ; Set up code string address
1662+ 1D3A 69                   ld      L,C
1663+ 1D3B 2B                   dec     HL              ; Incremented after
1664+ 1D3C D8                   ret     C               ; Line found
1665+ 1D3D 1E 0E        ULERR:  ld      E,UL            ; ?UL Error
1666+ 1D3F C3 AF 16             jp      ERROR           ; Output error message
1667+ 1D42
1668+ 1D42 C0           RETURN: ret     NZ              ; Return if not just RETURN
1669+ 1D43 16 FF                ld      D,-1            ; Flag "GOSUB" search
1670+ 1D45 CD 24 16             call    BAKSTK          ; Look "GOSUB" block
1671+ 1D48 F9                   ld      SP,HL           ; Kill all FORs in subroutine
1672+ 1D49 FE 8C                cp      ZGOSUB          ; Test for "GOSUB" token
1673+ 1D4B 1E 04                ld      E,RG            ; ?RG Error
1674+ 1D4D C2 AF 16             jp      NZ,ERROR        ; Error if no "GOSUB" found
1675+ 1D50 E1                   pop     HL              ; Get RETURN line number
1676+ 1D51 22 9E 51             ld      (LINEAT),HL     ; Save as current
1677+ 1D54 23                   inc     HL              ; Was it from direct statement?
1678+ 1D55 7C                   ld      A,H
1679+ 1D56 B5                   or      L               ; Return to line
1680+ 1D57 C2 61 1D             jp      NZ,RETLIN       ; No - Return to line
1681+ 1D5A 3A A2 52             ld      A,(LSTBIN)      ; Any INPUT in subroutine?
1682+ 1D5D B7                   or      A               ; If so buffer is corrupted
1683+ 1D5E C2 F4 16             jp      NZ,POPNOK       ; Yes - Go to command mode
1684+ 1D61 21 7E 1B     RETLIN: ld      HL,RUNCNT       ; Execution driver loop
1685+ 1D64 E3                   ex      (SP),HL         ; Into stack - Code string out
1686+ 1D65 3E                   defb    $3E             ; Skip "pop HL"
1687+ 1D66 E1           NXTDTA: pop     HL              ; Restore code string address
1688+ 1D67
1689+ 1D67 01 3A        DATA:   defb    $01,$3A         ; ':' End of statement (stands for LD BC,$0E3A - NOP)
1690+ 1D69 0E 00        REM:    ld      C,$00           ; 00  End of statement
1691+ 1D6B 06 00                ld      B,$00
1692+ 1D6D 79           NXTSTL: ld      A,C             ; Statement and byte
1693+ 1D6E 48                   ld      C,B
1694+ 1D6F 47                   ld      B,A             ; Statement end byte
1695+ 1D70 7E           NXTSTT: ld      A,(HL)          ; Get byte
1696+ 1D71 B7                   or      A               ; End of line?
1697+ 1D72 C8                   ret     Z               ; Yes - Exit
1698+ 1D73 B8                   cp      B               ; End of statement?
1699+ 1D74 C8                   ret     Z               ; Yes - Exit
1700+ 1D75 23                   inc     HL              ; Next byte
1701+ 1D76 FE 22                cp      $22             ; '"'             ; Literal string?
1702+ 1D78 CA 6D 1D             jp      Z,NXTSTL        ; Yes - Look for another '"'
1703+ 1D7B C3 70 1D             jp      NXTSTT          ; Keep looking
1704+ 1D7E
1705+ 1D7E CD 56 22     LET:    call    GETVAR          ; Get variable name
1706+ 1D81 CD 7D 19             call    CHKSYN          ; Make sure "=" follows
1707+ 1D84 C8                   defb    ZEQUAL          ; "=" token
1708+ 1D85 D5                   push    DE              ; Save address of variable
1709+ 1D86 3A 83 52             ld      A,(TYPE)        ; Get data type
1710+ 1D89 F5                   push    AF              ; Save type
1711+ 1D8A CD 59 20             call    EVAL            ; Evaluate expression
1712+ 1D8D F1                   pop     AF              ; Restore type
1713+ 1D8E E3                   ex      (SP),HL         ; Save code - Get var addr
1714+ 1D8F 22 A4 52             ld      (BRKLIN),HL     ; Save address of variable
1715+ 1D92 1F                   rra                     ; Adjust type
1716+ 1D93 CD 4C 20             call    CHKTYP          ; Check types are the same
1717+ 1D96 CA D1 1D             jp      Z,LETNUM        ; Numeric - Move value
1718+ 1D99 E5           LETSTR: push    HL              ; Save address of string var
1719+ 1D9A 2A 21 53             ld      HL,(FPREG)      ; Pointer to string entry
1720+ 1D9D E5                   push    HL              ; Save it on stack
1721+ 1D9E 23                   inc     HL              ; Skip over length
1722+ 1D9F 23                   inc     HL
1723+ 1DA0 5E                   ld      E,(HL)          ; LSB of string address
1724+ 1DA1 23                   inc     HL
1725+ 1DA2 56                   ld      D,(HL)          ; MSB of string address
1726+ 1DA3 2A 24 52             ld      HL,(BASTXT)     ; Point to start of program
1727+ 1DA6 CD 77 19             call    CPDEHL          ; Is string before program?
1728+ 1DA9 D2 C0 1D             jp      NC,CRESTR       ; Yes - Create string entry
1729+ 1DAC 2A 9C 51             ld      HL,(STRSPC)     ; Point to string space
1730+ 1DAF CD 77 19             call    CPDEHL          ; Is string literal in program?
1731+ 1DB2 D1                   pop     DE              ; Restore address of string
1732+ 1DB3 D2 C8 1D             jp      NC,MVSTPT       ; Yes - Set up pointer
1733+ 1DB6 21 95 52             ld      HL,TMPSTR       ; Temporary string pool
1734+ 1DB9 CD 77 19             call    CPDEHL          ; Is string in temporary pool?
1735+ 1DBC D2 C8 1D             jp      NC,MVSTPT       ; No - Set up pointer
1736+ 1DBF 3E                   defb    $3E             ; Skip "pop DE"
1737+ 1DC0 D1           CRESTR: pop     DE              ; Restore address of string
1738+ 1DC1 CD B0 26             call    BAKTMP          ; Back to last tmp-str entry
1739+ 1DC4 EB                   ex      DE,HL           ; Address of string entry
1740+ 1DC5 CD E9 24             call    SAVSTR          ; Save string in string area
1741+ 1DC8 CD B0 26     MVSTPT: call    BAKTMP          ; Back to last tmp-str entry
1742+ 1DCB E1                   pop     HL              ; Get string pointer
1743+ 1DCC CD AF 2E             call    DETHL4          ; Move string pointer to var
1744+ 1DCF E1                   pop     HL              ; Restore code string address
1745+ 1DD0 C9                   ret
1746+ 1DD1
1747+ 1DD1 E5           LETNUM: push    HL              ; Save address of variable
1748+ 1DD2 CD AC 2E             call    FPTHL           ; Move value to variable
1749+ 1DD5 D1                   pop     DE              ; Restore address of variable
1750+ 1DD6 E1                   pop     HL              ; Restore code string address
1751+ 1DD7 C9                   ret
1752+ 1DD8
1753+ 1DD8 CD CD 28     ON:     call    GETINT          ; Get integer 0-255
1754+ 1DDB 7E                   ld      A,(HL)          ; Get "GOTO" or "GOSUB" token
1755+ 1DDC 47                   ld      B,A             ; Save in B
1756+ 1DDD FE 8C                cp      ZGOSUB          ; "GOSUB" token?
1757+ 1DDF CA E7 1D             jp      Z,ONGO          ; Yes - Find line number
1758+ 1DE2 CD 7D 19             call    CHKSYN          ; Make sure it's "GOTO"
1759+ 1DE5 88                   defb    ZGOTO           ; "GOTO" token
1760+ 1DE6 2B                   dec     HL              ; Cancel increment
1761+ 1DE7 4B           ONGO:   ld      C,E             ; Integer of branch value
1762+ 1DE8 0D           ONGOLP: dec     C               ; Count branches
1763+ 1DE9 78                   ld      A,B             ; Get "GOTO" or "GOSUB" token
1764+ 1DEA CA A6 1B             jp      Z,ONJMP         ; Go to that line if right one
1765+ 1DED CD 8F 1C             call    GETLN           ; Get line number to DE
1766+ 1DF0 FE 2C                cp      ','             ; Another line number?
1767+ 1DF2 C0                   ret     NZ              ; No - Drop through
1768+ 1DF3 C3 E8 1D             jp      ONGOLP          ; Yes - loop
1769+ 1DF6
1770+ 1DF6 CD 59 20     IF:     call    EVAL            ; Evaluate expression
1771+ 1DF9 7E                   ld      A,(HL)          ; Get token
1772+ 1DFA FE 88                cp      ZGOTO           ; "GOTO" token?
1773+ 1DFC CA 04 1E             jp      Z,IFGO          ; Yes - Get line
1774+ 1DFF CD 7D 19             call    CHKSYN          ; Make sure it's "THEN"
1775+ 1E02 BA                   defb    ZTHEN           ; "THEN" token
1776+ 1E03 2B                   dec     HL              ; Cancel increment
1777+ 1E04 CD 4A 20     IFGO:   call    TSTNUM          ; Make sure it's numeric
1778+ 1E07 CD 54 2E             call    TSTSGN          ; Test state of expression
1779+ 1E0A CA 16 1E             jp      Z,IF1           ; False - Jump over
1780+ 1E0D CD BE 1B     IF0:    call    GETCHR          ; Get next character
1781+ 1E10 DA 24 1D             jp      C,GOTO          ; Number - GOTO that line
1782+ 1E13 C3 A5 1B             jp      IFJMP           ; Otherwise do statement
1783+ 1E16 0E AE        IF1:    ld      C,ZELSE
1784+ 1E18 CD 6B 1D             call    REM+2           ; check statement
1785+ 1E1B B7                   or      A               ; end of line?
1786+ 1E1C C8                   ret     Z               ; yes, leave
1787+ 1E1D FE AE                cp      ZELSE
1788+ 1E1F 20 F5                jr      NZ,IF1          ; ELSE not found, continue check
1789+ 1E21 C3 0D 1E             jp      IF0             ; return to IF
1790+ 1E24
1791+ 1E24
1792+ 1E24 2B           MRPRNT: dec     HL              ; dec 'cos GETCHR INCs
1793+ 1E25 CD BE 1B             call    GETCHR          ; Get next character
1794+ 1E28 CA 8B 1E     PRINT:  jp      Z,PRNTCRLF      ; CRLF if just PRINT
1795+ 1E2B C8           PRNTLP: ret     Z               ; End of list - Exit
1796+ 1E2C FE B6                cp      ZTAB            ; "TAB(" token?
1797+ 1E2E CA B3 1E             jp      Z,DOTAB         ; Yes - Do TAB routine
1798+ 1E31 FE B9                cp      ZSPC            ; "SPC(" token?
1799+ 1E33 CA B3 1E             jp      Z,DOTAB         ; Yes - Do SPC routine
1800+ 1E36 E5                   push    HL              ; Save code string address
1801+ 1E37 FE 2C                cp      ','             ; Comma?
1802+ 1E39 CA 9A 1E             jp      Z,DOCOM         ; Yes - Move to next zone
1803+ 1E3C FE 3B                cp      ';'             ; Semi-colon?
1804+ 1E3E CA D7 1E             jp      Z,NEXITM        ; Do semi-colon routine
1805+ 1E41 C1                   pop     BC              ; Code string address to BC
1806+ 1E42 CD 59 20             call    EVAL            ; Evaluate expression
1807+ 1E45 E5                   push    HL              ; Save code string address
1808+ 1E46 3A 83 52             ld      A,(TYPE)        ; Get variable type
1809+ 1E49 B7                   or      A               ; Is it a string variable?
1810+ 1E4A C2 72 1E             jp      NZ,PRNTST       ; Yes - Output string contents
1811+ 1E4D CD F9 2F             call    NUMASC          ; Convert number to text
1812+ 1E50 CD 0D 25             call    CRTST           ; Create temporary string
1813+ 1E53 36 00                ld      (HL),NLLCR      ; Followed by a NULL char (was SPC, space)
1814+ 1E55 2A 21 53             ld      HL,(FPREG)      ; Get length of output
1815+ 1E58 34                   inc     (HL)            ; Plus 1 for the space
1816+ 1E59 2A 21 53             ld      HL,(FPREG)      ; < Not needed >
1817+ 1E5C 3A 91 51             ld      A,(LWIDTH)      ; Get width of line
1818+ 1E5F 47                   ld      B,A             ; To B
1819+ 1E60 04                   inc     B               ; Width 255 (No limit)?
1820+ 1E61 CA 6E 1E             jp      Z,PRNTNB        ; Yes - Output number string
1821+ 1E64 04                   inc     B               ; Adjust it
1822+ 1E65 3A 81 52             ld      A,(CURPOS)      ; Get cursor position
1823+ 1E68 86                   add     A,(HL)          ; Add length of string
1824+ 1E69 3D                   dec     A               ; Adjust it
1825+ 1E6A B8                   cp      B               ; Will output fit on this line?
1826+ 1E6B D4 8B 1E             call    NC,PRNTCRLF     ; No - CRLF first
1827+ 1E6E CD 52 25     PRNTNB: call    PRS1            ; Output string at (HL)
1828+ 1E71 AF                   xor     A               ; Skip call by setting 'z' flag
1829+ 1E72 C4 52 25     PRNTST: call    NZ,PRS1         ; Output string at (HL)
1830+ 1E75 E1                   pop     HL              ; Restore code string address
1831+ 1E76 C3 24 1E             jp      MRPRNT          ; See if more to PRINT
1832+ 1E79
1833+ 1E79 3A 81 52     STTLIN: ld      A,(CURPOS)      ; Make sure on new line
1834+ 1E7C B7                   or      A               ; Already at start?
1835+ 1E7D C8                   ret     Z               ; Yes - Do nothing
1836+ 1E7E C3 8B 1E             jp      PRNTCRLF        ; Start a new line
1837+ 1E81
1838+ 1E81 AF           ENDINP: xor     A
1839+ 1E82 32 07 53             ld      (KBDNPT),A      ; char is not from keyboard
1840+ 1E85 77                   ld      (HL),A          ; Mark end of buffer
1841+ 1E86 21 26 52             ld      HL,BUFFER-1     ; Point to buffer
1842+ 1E89 18 0A                jr      CNTEND
1843+ 1E8B 3E 0D        PRNTCRLF:ld     A,CR            ; Load a CR
1844+ 1E8D CD 88 19             call    OUTC            ; Output character
1845+ 1E90 3E 0A                ld      A,LF            ; Load a LF
1846+ 1E92 CD 88 19             call    OUTC            ; Output character
1847+ 1E95 AF           CNTEND: xor     A               ; Set to position 0
1848+ 1E96 32 81 52             ld      (CURPOS),A      ; Store it
1849+ 1E99 C9                   ret                     ; return to caller
1850+ 1E9A
1851+ 1E9A 3A 92 51     DOCOM:  ld      A,(COMMAN)      ; Get comma width
1852+ 1E9D 47                   ld      B,A             ; Save in B
1853+ 1E9E 3A C2 52             ld      A,(SCR_CURS_X)  ; Get current position
1854+ 1EA1 B8                   cp      B               ; Within the limit?
1855+ 1EA2 D4 8B 1E             call    NC,PRNTCRLF     ; No - output CRLF
1856+ 1EA5 D2 D7 1E             jp      NC,NEXITM       ; Get next item
1857+ 1EA8 D6 0A        ZONELP: sub     $0A             ; Next zone of 10 characters
1858+ 1EAA D2 A8 1E             jp      NC,ZONELP       ; Repeat if more zones
1859+ 1EAD 2F                   cpl                     ; Number of null chars to output
1860+ 1EAE 0E 00                ld      C,NLLCR         ; null char
1861+ 1EB0 C3 CD 1E             jp      ASPCS           ; Output them
1862+ 1EB3
1863+ 1EB3 F5           DOTAB:  push    AF              ; Save token
1864+ 1EB4 CD CA 28             call    FNDNUM          ; Evaluate expression
1865+ 1EB7 CD 7D 19             call    CHKSYN          ; Make sure ")" follows
1866+ 1EBA 29                   defb    ')'
1867+ 1EBB 2B                   dec     HL              ; Back space on to ")"
1868+ 1EBC F1                   pop     AF              ; Restore token
1869+ 1EBD 0E 00                ld      C,NLLCR         ; for SPC we use NULL char (was SPACE)
1870+ 1EBF D6 B9                sub     ZSPC            ; Was it "SPC(" ?
1871+ 1EC1 E5                   push    HL              ; Save code string address
1872+ 1EC2 CA C8 1E             jp      Z,DOSPC         ; Yes - Do 'E' spaces
1873+ 1EC5 3A C2 52             ld      A,(SCR_CURS_X)  ; Get current X position
1874+ 1EC8 2F           DOSPC:  cpl                     ; Number of spaces to print to
1875+ 1EC9 83                   add     A,E             ; Total number to print
1876+ 1ECA D2 D7 1E             jp      NC,NEXITM       ; TAB < Current POS(X)
1877+ 1ECD 3C           ASPCS:  inc     A               ; Output A spaces
1878+ 1ECE 47                   ld      B,A             ; Save number to print
1879+ 1ECF 79           SPCLP:  ld      A,C             ; char to print
1880+ 1ED0 CD 88 19             call    OUTC            ; Output character in A
1881+ 1ED3 05                   dec     B               ; Count them
1882+ 1ED4 C2 CF 1E             jp      NZ,SPCLP        ; Repeat if more
1883+ 1ED7 E1           NEXITM: pop     HL              ; Restore code string address
1884+ 1ED8 CD BE 1B             call    GETCHR          ; Get next character
1885+ 1EDB C3 2B 1E             jp      PRNTLP          ; More to print
1886+ 1EDE
1887+ 1EDE 3F 52 65 64  REDO:   defb    "?Redo from start",CR,0
1887+ 1EE2 6F 20 66 72
1887+ 1EE6 6F 6D 20 73
1887+ 1EEA 74 61 72 74
1887+ 1EEE 0D 00
1888+ 1EF0
1889+ 1EF0 3A A3 52     BADINP: ld      A,(READFG)      ; READ or INPUT?
1890+ 1EF3 B7                   or      A
1891+ 1EF4 C2 95 16             jp      NZ,DATSNR       ; READ - ?SN Error
1892+ 1EF7 C1                   pop     BC              ; Throw away code string addr
1893+ 1EF8 21 DE 1E             ld      HL,REDO         ; "Redo from start" message
1894+ 1EFB CD 4F 25             call    PRS             ; Output string
1895+ 1EFE C3 00 18             jp      DOAGN           ; Do last INPUT again
1896+ 1F01
1897+ 1F01 CD BA 24     INPUT:  call    IDTEST          ; Test for illegal direct
1898+ 1F04 7E                   ld      A,(HL)          ; Get character after "INPUT"
1899+ 1F05 FE 22                cp      $22             ; '"' ; Is there a prompt string?
1900+ 1F07 3E 00                ld      A,$00           ; Clear A and leave flags
1901+ 1F09 32 94 51             ld      (CTLOFG),A      ; Enable output
1902+ 1F0C C2 1B 1F             jp      NZ,NOPMPT       ; No prompt - get input
1903+ 1F0F CD 0E 25             call    QTSTR           ; Get string terminated by '"'
1904+ 1F12 CD 7D 19             call    CHKSYN          ; Check for ';' after prompt
1905+ 1F15 3B                   defb    ";"
1906+ 1F16 E5                   push    HL              ; Save code string address
1907+ 1F17 CD 52 25             call    PRS1            ; Output prompt string
1908+ 1F1A 3E                   defb    $3E             ; Skip "push HL"
1909+ 1F1B E5           NOPMPT: push    HL              ; Save code string address
1910+ 1F1C CD 04 18             call    PROMPT          ; Get input with "? " prompt
1911+ 1F1F C1                   pop     BC              ; Restore code string address
1912+ 1F20 DA 0D 1C             jp      C,INPBRK        ; Break pressed - Exit
1913+ 1F23 23                   inc     HL              ; Next byte
1914+ 1F24 7E                   ld      A,(HL)          ; Get it
1915+ 1F25 B7                   or      A               ; End of line?
1916+ 1F26 2B                   dec     HL              ; Back again
1917+ 1F27 C5                   push    BC              ; Re-save code string address
1918+ 1F28 CD FF 08             call    CURSOR_OFF      ; disable cursor
1919+ 1F2B CA 66 1D             jp      Z,NXTDTA        ; Yes - Find next DATA stmt
1920+ 1F2E 36 2C                ld      (HL),','        ; Store comma as separator
1921+ 1F30 C3 38 1F             jp      NXTITM          ; Get next item
1922+ 1F33
1923+ 1F33 E5           READ:   push    HL              ; Save code string address
1924+ 1F34 2A 19 53             ld      HL,(NXTDAT)     ; Next DATA statement
1925+ 1F37 F6                   defb    $F6             ; Flag "READ"
1926+ 1F38 AF           NXTITM: xor     A               ; Flag "INPUT"
1927+ 1F39 32 A3 52             ld      (READFG),A      ; Save "READ"/"INPUT" flag
1928+ 1F3C E3                   ex      (SP),HL         ; Get code str' , Save pointer
1929+ 1F3D C3 44 1F             jp      GTVLUS          ; Get values
1930+ 1F40
1931+ 1F40 CD 7D 19     NEDMOR: call    CHKSYN          ; Check for comma between items
1932+ 1F43 2C                   defb    ','
1933+ 1F44 CD 56 22     GTVLUS: call    GETVAR          ; Get variable name
1934+ 1F47 E3                   ex      (SP),HL         ; Save code str" , Get pointer
1935+ 1F48 D5                   push    DE              ; Save variable address
1936+ 1F49 7E                   ld      A,(HL)          ; Get next "INPUT"/"DATA" byte
1937+ 1F4A FE 2C                cp      ','             ; Comma?
1938+ 1F4C CA 6C 1F             jp      Z,ANTVLU        ; Yes - Get another value
1939+ 1F4F 3A A3 52             ld      A,(READFG)      ; Is it READ?
1940+ 1F52 B7                   or      A
1941+ 1F53 C2 D8 1F             jp      NZ,FDTLP        ; Yes - Find next DATA stmt
1942+ 1F56 3E 3F                ld      A,'?'           ; More INPUT needed
1943+ 1F58 CD 88 19             call    OUTC            ; Output character
1944+ 1F5B CD 04 18             call    PROMPT          ; Get INPUT with prompt
1945+ 1F5E D1                   pop     DE              ; Variable address
1946+ 1F5F C1                   pop     BC              ; Code string address
1947+ 1F60 DA 0D 1C             jp      C,INPBRK        ; Break pressed
1948+ 1F63 23                   inc     HL              ; Point to next DATA byte
1949+ 1F64 7E                   ld      A,(HL)          ; Get byte
1950+ 1F65 B7                   or      A               ; Is it zero (No input) ?
1951+ 1F66 2B                   dec     HL              ; Back space INPUT pointer
1952+ 1F67 C5                   push    BC              ; Save code string address
1953+ 1F68 CA 66 1D             jp      Z,NXTDTA        ; Find end of buffer
1954+ 1F6B D5                   push    DE              ; Save variable address
1955+ 1F6C 3A 83 52     ANTVLU: ld      A,(TYPE)        ; Check data type
1956+ 1F6F B7                   or      A               ; Is it numeric?
1957+ 1F70 CA 96 1F             jp      Z,INPBIN        ; Yes - Convert to binary
1958+ 1F73 CD BE 1B             call    GETCHR          ; Get next character
1959+ 1F76 57                   ld      D,A             ; Save input character
1960+ 1F77 47                   ld      B,A             ; Again
1961+ 1F78 FE 22                cp      $22             ; '"'     ; Start of literal sting?
1962+ 1F7A CA 8A 1F             jp      Z,STRENT        ; Yes - Create string entry
1963+ 1F7D 3A A3 52             ld      A,(READFG)      ; "READ" or "INPUT" ?
1964+ 1F80 B7                   or      A
1965+ 1F81 57                   ld      D,A             ; Save 00 if "INPUT"
1966+ 1F82 CA 87 1F             jp      Z,ITMSEP        ; "INPUT" - End with 00
1967+ 1F85 16 3A                ld      D,':'           ; "DATA" - End with 00 or ':'
1968+ 1F87 06 2C        ITMSEP: ld      B,','           ; Item separator
1969+ 1F89 2B                   dec     HL              ; Back space for DTSTR
1970+ 1F8A CD 11 25     STRENT: call    DTSTR           ; Get string terminated by D
1971+ 1F8D EB                   ex      DE,HL           ; String address to DE
1972+ 1F8E 21 A1 1F             ld      HL,LTSTND       ; Where to go after LETSTR
1973+ 1F91 E3                   ex      (SP),HL         ; Save HL , get input pointer
1974+ 1F92 D5                   push    DE              ; Save address of string
1975+ 1F93 C3 99 1D             jp      LETSTR          ; Assign string to variable
1976+ 1F96
1977+ 1F96 CD BE 1B     INPBIN: call    GETCHR          ; Get next character
1978+ 1F99 CD 5B 2F             call    ASCTFP          ; Convert ASCII to FP number
1979+ 1F9C E3                   ex      (SP),HL         ; Save input ptr, Get var addr
1980+ 1F9D CD AC 2E             call    FPTHL           ; Move FPREG to variable
1981+ 1FA0 E1                   pop     HL              ; Restore input pointer
1982+ 1FA1 2B           LTSTND: dec     HL              ; dec 'cos GETCHR INCs
1983+ 1FA2 CD BE 1B             call    GETCHR          ; Get next character
1984+ 1FA5 CA AD 1F             jp      Z,MORDT         ; End of line - More needed?
1985+ 1FA8 FE 2C                cp      ','             ; Another value?
1986+ 1FAA C2 F0 1E             jp      NZ,BADINP       ; No - Bad input
1987+ 1FAD E3           MORDT:  ex      (SP),HL         ; Get code string address
1988+ 1FAE 2B                   dec     HL              ; dec 'cos GETCHR INCs
1989+ 1FAF CD BE 1B             call    GETCHR          ; Get next character
1990+ 1FB2 C2 40 1F             jp      NZ,NEDMOR       ; More needed - Get it
1991+ 1FB5 D1                   pop     DE              ; Restore DATA pointer
1992+ 1FB6 3A A3 52             ld      A,(READFG)      ; "READ" or "INPUT" ?
1993+ 1FB9 B7                   or      A
1994+ 1FBA EB                   ex      DE,HL           ; DATA pointer to HL
1995+ 1FBB C2 E4 1B             jp      NZ,UPDATA       ; Update DATA pointer if "READ"
1996+ 1FBE D5                   push    DE              ; Save code string address
1997+ 1FBF B6                   or      (HL)            ; More input given?
1998+ 1FC0 21 C8 1F             ld      HL,EXTIG        ; "?Extra ignored" message
1999+ 1FC3 C4 4F 25             call    NZ,PRS          ; Output string if extra given
2000+ 1FC6 E1                   pop     HL              ; Restore code string address
2001+ 1FC7 C9                   ret
2002+ 1FC8
2003+ 1FC8 3F 45 78 74  EXTIG:  defb    "?Extra ignored",CR,0
2003+ 1FCC 72 61 20 69
2003+ 1FD0 67 6E 6F 72
2003+ 1FD4 65 64 0D 00
2004+ 1FD8
2005+ 1FD8 CD 67 1D     FDTLP:  call    DATA            ; Get next statement
2006+ 1FDB B7                   or      A               ; End of line?
2007+ 1FDC C2 F1 1F             jp      NZ,FANDT        ; No - See if DATA statement
2008+ 1FDF 23                   inc     HL
2009+ 1FE0 7E                   ld      A,(HL)          ; End of program?
2010+ 1FE1 23                   inc     HL
2011+ 1FE2 B6                   or      (HL)            ; 00 00 Ends program
2012+ 1FE3 1E 06                ld      E,OD            ; ?OD Error
2013+ 1FE5 CA AF 16             jp      Z,ERROR         ; Yes - Out of DATA
2014+ 1FE8 23                   inc     HL
2015+ 1FE9 5E                   ld      E,(HL)          ; LSB of line number
2016+ 1FEA 23                   inc     HL
2017+ 1FEB 56                   ld      D,(HL)          ; MSB of line number
2018+ 1FEC EB                   ex      DE,HL
2019+ 1FED 22 9F 52             ld      (DATLIN),HL     ; Set line of current DATA item
2020+ 1FF0 EB                   ex      DE,HL
2021+ 1FF1 CD BE 1B     FANDT:  call    GETCHR          ; Get next character
2022+ 1FF4 FE 83                cp      ZDATA           ; "DATA" token
2023+ 1FF6 C2 D8 1F             jp      NZ,FDTLP        ; No "DATA" - Keep looking
2024+ 1FF9 C3 6C 1F             jp      ANTVLU          ; Found - Convert input
2025+ 1FFC
2026+ 1FFC 11 00 00     NEXT:   ld      DE,$0000        ; In case no index given
2027+ 1FFF C4 56 22     NEXT1:  call    NZ,GETVAR       ; Get index address
2028+ 2002 22 A4 52             ld      (BRKLIN),HL     ; Save code string address
2029+ 2005 CD 24 16             call    BAKSTK          ; Look for "FOR" block
2030+ 2008 C2 A1 16             jp      NZ,NFERR        ; No "FOR" - ?NF Error
2031+ 200B F9                   ld      SP,HL           ; Clear nested loops
2032+ 200C D5                   push    DE              ; Save index address
2033+ 200D 7E                   ld      A,(HL)          ; Get sign of STEP
2034+ 200E 23                   inc     HL
2035+ 200F F5                   push    AF              ; Save sign of STEP
2036+ 2010 D5                   push    DE              ; Save index address
2037+ 2011 CD 92 2E             call    PHLTFP          ; Move index value to FPREG
2038+ 2014 E3                   ex      (SP),HL         ; Save address of TO value
2039+ 2015 E5                   push    HL              ; Save address of index
2040+ 2016 CD AE 2B             call    ADDPHL          ; Add STEP to index value
2041+ 2019 E1                   pop     HL              ; Restore address of index
2042+ 201A CD AC 2E             call    FPTHL           ; Move value to index variable
2043+ 201D E1                   pop     HL              ; Restore address of TO value
2044+ 201E CD A3 2E             call    LOADFP          ; Move TO value to BCDE
2045+ 2021 E5                   push    HL              ; Save address of line of FOR
2046+ 2022 CD CF 2E             call    CMPNUM          ; Compare index with TO value
2047+ 2025 E1                   pop     HL              ; Restore address of line num
2048+ 2026 C1                   pop     BC              ; Address of sign of STEP
2049+ 2027 90                   sub     B               ; Compare with expected sign
2050+ 2028 CD A3 2E             call    LOADFP          ; BC = Loop stmt,DE = Line num
2051+ 202B CA 37 20             jp      Z,KILFOR        ; Loop finished - Terminate it
2052+ 202E EB                   ex      DE,HL           ; Loop statement line number
2053+ 202F 22 9E 51             ld      (LINEAT),HL     ; Set loop line number
2054+ 2032 69                   ld      L,C             ; Set code string to loop
2055+ 2033 60                   ld      H,B
2056+ 2034 C3 7A 1B             jp      PUTFID          ; Put back "FOR" and continue
2057+ 2037
2058+ 2037 F9           KILFOR: ld      SP,HL           ; Remove "FOR" block
2059+ 2038 2A A4 52             ld      HL,(BRKLIN)     ; Code string after "NEXT"
2060+ 203B 7E                   ld      A,(HL)          ; Get next byte in code string
2061+ 203C FE 2C                cp      ','             ; More NEXTs ?
2062+ 203E C2 7E 1B             jp      NZ,RUNCNT       ; No - Do next statement
2063+ 2041 CD BE 1B             call    GETCHR          ; Position to index name
2064+ 2044 CD FF 1F             call    NEXT1           ; Re-enter NEXT routine
2065+ 2047              ; < will not RETurn to here , Exit to RUNCNT or Loop >
2066+ 2047
2067+ 2047 CD 59 20     GETNUM: call    EVAL            ; Get a numeric expression
2068+ 204A F6           TSTNUM: defb    $F6             ; Clear carry (numeric)
2069+ 204B 37           TSTSTR: scf                     ; Set carry (string)
2070+ 204C 3A 83 52     CHKTYP: ld      A,(TYPE)        ; Check types match
2071+ 204F 8F                   adc     A,A             ; Expected + actual
2072+ 2050 B7                   or      A               ; Clear carry , set parity
2073+ 2051 E8                   ret     PE              ; Even parity - Types match
2074+ 2052 C3 AD 16             jp      TMERR           ; Different types - Error
2075+ 2055
2076+ 2055 CD 7D 19     OPNPAR: call    CHKSYN          ; Make sure "(" follows
2077+ 2058 28                   defb    '('
2078+ 2059 2B           EVAL:   dec     HL              ; Evaluate expression & save
2079+ 205A 16 00                ld      D,$00           ; Precedence value
2080+ 205C D5           EVAL1:  push    DE              ; Save precedence
2081+ 205D 0E 01                ld      C,$01
2082+ 205F CD 58 16             call    CHKSTK          ; Check for 1 level of stack
2083+ 2062 CD D0 20             call    OPRND           ; Get next expression value
2084+ 2065 22 A6 52     EVAL2:  ld      (NXTOPR),HL     ; Save address of next operator
2085+ 2068 2A A6 52     EVAL3:  ld      HL,(NXTOPR)     ; Restore address of next opr
2086+ 206B C1                   pop     BC              ; Precedence value and operator
2087+ 206C 78                   ld      A,B             ; Get precedence value
2088+ 206D FE 78                cp      $78             ; "AND", "OR", or "XOR" ?
2089+ 206F D4 4A 20             call    NC,TSTNUM       ; No - Make sure it's a number
2090+ 2072 7E                   ld      A,(HL)          ; Get next operator / function
2091+ 2073 16 00                ld      D,$00           ; Clear Last relation
2092+ 2075 D6 C7        RLTLP:  sub     ZGTR            ; ">" Token
2093+ 2077 DA 91 20             jp      C,FOPRND        ; + - * / ^ AND OR XOR - Test it
2094+ 207A FE 03                cp      ZLTH+1-ZGTR     ; < = >
2095+ 207C D2 91 20             jp      NC,FOPRND       ; Function - Call it
2096+ 207F FE 01                cp      ZEQUAL-ZGTR     ; "="
2097+ 2081 17                   rla                     ; <- Test for legal
2098+ 2082 AA                   xor     D               ; <- combinations of < = >
2099+ 2083 BA                   cp      D               ; <- by combining last token
2100+ 2084 57                   ld      D,A             ; <- with current one
2101+ 2085 DA 9B 16             jp      C,SNERR         ; Error if "<<' '==" or ">>"
2102+ 2088 22 9B 52             ld      (CUROPR),HL     ; Save address of current token
2103+ 208B CD BE 1B             call    GETCHR          ; Get next character
2104+ 208E C3 75 20             jp      RLTLP           ; Treat the two as one
2105+ 2091
2106+ 2091 7A           FOPRND: ld      A,D             ; < = > found ?
2107+ 2092 B7                   or      A
2108+ 2093 C2 D1 21             jp      NZ,TSTRED       ; Yes - Test for reduction
2109+ 2096 7E                   ld      A,(HL)          ; Get operator token
2110+ 2097 22 9B 52             ld      (CUROPR),HL     ; Save operator address
2111+ 209A D6 BD                sub     ZPLUS           ; Operator or function?
2112+ 209C D8                   ret     C               ; Neither - Exit
2113+ 209D FE 0A                cp      ZOR+1-ZPLUS     ; Is it + - * / ^ AND XOR OR ?
2114+ 209F D0                   ret     NC              ; No - Exit
2115+ 20A0 5F                   ld      E,A             ; Coded operator
2116+ 20A1 3A 83 52             ld      A,(TYPE)        ; Get data type
2117+ 20A4 3D                   dec     A               ; FF = numeric , 00 = string
2118+ 20A5 B3                   or      E               ; Combine with coded operator
2119+ 20A6 7B                   ld      A,E             ; Get coded operator
2120+ 20A7 CA 45 26             jp      Z,CONCAT        ; String concatenation
2121+ 20AA 07                   rlca                    ; Times 2
2122+ 20AB 83                   add     A,E             ; Times 3
2123+ 20AC 5F                   ld      E,A             ; To DE (D is 0)
2124+ 20AD 21 16 15             ld      HL,PRITAB       ; Precedence table
2125+ 20B0 19                   add     HL,DE           ; To the operator concerned
2126+ 20B1 78                   ld      A,B             ; Last operator precedence
2127+ 20B2 56                   ld      D,(HL)          ; Get evaluation precedence
2128+ 20B3 BA                   cp      D               ; Compare with eval precedence
2129+ 20B4 D0                   ret     NC              ; Exit if higher precedence
2130+ 20B5 23                   inc     HL              ; Point to routine address
2131+ 20B6 CD 4A 20             call    TSTNUM          ; Make sure it's a number
2132+ 20B9
2133+ 20B9 C5           STKTHS: push    BC              ; Save last precedence & token
2134+ 20BA 01 68 20             ld      BC,EVAL3        ; Where to go on prec' break
2135+ 20BD C5                   push    BC              ; Save on stack for return
2136+ 20BE 43                   ld      B,E             ; Save operator
2137+ 20BF 4A                   ld      C,D             ; Save precedence
2138+ 20C0 CD 85 2E             call    STAKFP          ; Move value to stack
2139+ 20C3 58                   ld      E,B             ; Restore operator
2140+ 20C4 51                   ld      D,C             ; Restore precedence
2141+ 20C5 4E                   ld      C,(HL)          ; Get LSB of routine address
2142+ 20C6 23                   inc     HL
2143+ 20C7 46                   ld      B,(HL)          ; Get MSB of routine address
2144+ 20C8 23                   inc     HL
2145+ 20C9 C5                   push    BC              ; Save routine address
2146+ 20CA 2A 9B 52             ld      HL,(CUROPR)     ; Address of current operator
2147+ 20CD C3 5C 20             jp      EVAL1           ; Loop until prec' break
2148+ 20D0
2149+ 20D0 AF           OPRND:  xor     A               ; Get operand routine
2150+ 20D1 32 83 52             ld      (TYPE),A        ; Set numeric expected
2151+ 20D4 CD BE 1B             call    GETCHR          ; Get next character
2152+ 20D7 1E 24                ld      E,MO            ; ?MO Error
2153+ 20D9 CA AF 16             jp      Z,ERROR         ; No operand - Error
2154+ 20DC DA 5B 2F             jp      C,ASCTFP        ; Number - Get value
2155+ 20DF CD 60 1C             call    CHKLTR          ; See if a letter
2156+ 20E2 D2 37 21             jp      NC,CONVAR       ; Letter - Find variable
2157+ 20E5 FE 26                cp      '&'             ; &H = HEX, &B = BINARY
2158+ 20E7 20 12                jr      NZ,NOTAMP
2159+ 20E9 CD BE 1B             call    GETCHR          ; Get next character
2160+ 20EC FE 48                cp      'H'             ; Hex number indicated? [function added]
2161+ 20EE CA C1 3E             jp      Z,HEXTFP        ; Convert Hex to FPREG
2162+ 20F1 FE 42                cp      'B'             ; Binary number indicated? [function added]
2163+ 20F3 CA 31 3F             jp      Z,BINTFP        ; Convert Bin to FPREG
2164+ 20F6 1E 02                ld      E,SN            ; If neither then a ?SN Error
2165+ 20F8 CA AF 16             jp      Z,ERROR         ;
2166+ 20FB FE BD        NOTAMP: cp      ZPLUS           ; '+' Token ?
2167+ 20FD CA D0 20             jp      Z,OPRND         ; Yes - Look for operand
2168+ 2100 FE 2E                cp      '.'             ; '.' ?
2169+ 2102 CA 5B 2F             jp      Z,ASCTFP        ; Yes - Create FP number
2170+ 2105 FE BE                cp      ZMINUS          ; '-' Token ?
2171+ 2107 CA 26 21             jp      Z,MINUS         ; Yes - Do minus
2172+ 210A FE 22                cp      $22             ; '"'             ; Literal string ?
2173+ 210C CA 0E 25             jp      Z,QTSTR         ; Get string terminated by '"'
2174+ 210F FE BB                cp      ZNOT            ; "NOT" Token ?
2175+ 2111 CA 31 22             jp      Z,EVNOT         ; Yes - Eval NOT expression
2176+ 2114 FE B8                cp      ZFN             ; "FN" Token ?
2177+ 2116 CA 72 24             jp      Z,DOFN          ; Yes - Do FN routine
2178+ 2119 D6 CA                sub     ZSGN            ; Is it a function?
2179+ 211B D2 48 21             jp      NC,FNOFST       ; Yes - Evaluate function
2180+ 211E CD 55 20     EVLPAR: call    OPNPAR          ; Evaluate expression in "()"
2181+ 2121 CD 7D 19             call    CHKSYN          ; Make sure ")" follows
2182+ 2124 29                   defb    ')'
2183+ 2125 C9                   ret
2184+ 2126
2185+ 2126 16 7D        MINUS:  ld      D,$7D           ; '-' precedence
2186+ 2128 CD 5C 20             call    EVAL1           ; Evaluate until prec' break
2187+ 212B 2A A6 52             ld      HL,(NXTOPR)     ; Get next operator address
2188+ 212E E5                   push    HL              ; Save next operator address
2189+ 212F CD 7D 2E             call    INVSGN          ; Negate value
2190+ 2132 CD 4A 20     RETNUM: call    TSTNUM          ; Make sure it's a number
2191+ 2135 E1                   pop     HL              ; Restore next operator address
2192+ 2136 C9                   ret
2193+ 2137
2194+ 2137 CD 56 22     CONVAR: call    GETVAR          ; Get variable address to DE
2195+ 213A E5           FRMEVL: push    HL              ; Save code string address
2196+ 213B EB                   ex      DE,HL           ; Variable address to HL
2197+ 213C 22 21 53             ld      (FPREG),HL      ; Save address of variable
2198+ 213F 3A 83 52             ld      A,(TYPE)        ; Get type
2199+ 2142 B7                   or      A               ; Numeric?
2200+ 2143 CC 92 2E             call    Z,PHLTFP        ; Yes - Move contents to FPREG
2201+ 2146 E1                   pop     HL              ; Restore code string address
2202+ 2147 C9                   ret
2203+ 2148
2204+ 2148 06 00        FNOFST: ld      B,$00           ; Get address of function
2205+ 214A 07                   rlca                    ; Double function offset
2206+ 214B 4F                   ld      C,A             ; BC = Offset in function table
2207+ 214C C5                   push    BC              ; Save adjusted token value
2208+ 214D CD BE 1B             call    GETCHR          ; Get next character
2209+ 2150 79                   ld      A,C             ; Get adjusted token value
2210+ 2151 FE 2C                cp      2*(ZPOINT-ZSGN) ; "POINT" token?
2211+ 2153 CA 7F 36             jp      Z,POINT         ; Yes, do "POINT"
2212+ 2156 FE 2E                cp      2*(ZINSTR-ZSGN) ; "INSTR" token?
2213+ 2158 CA 21 27             jp      Z,INSTR         ; Yes, do "INSTR"
2214+ 215B FE 3D                cp      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
2215+ 215D DA 79 21             jp      C,FNVAL         ; No - Do function
2216+ 2160 CD 55 20             call    OPNPAR          ; Evaluate expression  (X,...
2217+ 2163 CD 7D 19             call    CHKSYN          ; Make sure ',' follows
2218+ 2166 2C                   defb    ','
2219+ 2167 CD 4B 20             call    TSTSTR          ; Make sure it's a string
2220+ 216A EB                   ex      DE,HL           ; Save code string address
2221+ 216B 2A 21 53             ld      HL,(FPREG)      ; Get address of string
2222+ 216E E3                   ex      (SP),HL         ; Save address of string
2223+ 216F E5                   push    HL              ; Save adjusted token value
2224+ 2170 EB                   ex      DE,HL           ; Restore code string address
2225+ 2171 CD CD 28             call    GETINT          ; Get integer 0-255
2226+ 2174 EB                   ex      DE,HL           ; Save code string address
2227+ 2175 E3                   ex      (SP),HL         ; Save integer,HL = adj' token
2228+ 2176 C3 81 21             jp      GOFUNC          ; Jump to string function
2229+ 2179
2230+ 2179 CD 1E 21     FNVAL:  call    EVLPAR          ; Evaluate expression
2231+ 217C E3                   ex      (SP),HL         ; HL = Adjusted token value
2232+ 217D 11 32 21             ld      DE,RETNUM       ; Return number from function
2233+ 2180 D5                   push    DE              ; Save on stack
2234+ 2181 01 D9 12     GOFUNC: ld      BC,FNCTAB       ; Function routine addresses
2235+ 2184 09                   add     HL,BC           ; Point to right address
2236+ 2185 4E                   ld      C,(HL)          ; Get LSB of address
2237+ 2186 23                   inc     HL              ;
2238+ 2187 66                   ld      H,(HL)          ; Get MSB of address
2239+ 2188 69                   ld      L,C             ; Address to HL
2240+ 2189 E9                   jp      (HL)            ; Jump to function
2241+ 218A
2242+ 218A 15           SGNEXP: dec     D               ; Dee to flag negative exponent
2243+ 218B FE BE                cp      ZMINUS          ; '-' token ?
2244+ 218D C8                   ret     Z               ; Yes - Return
2245+ 218E FE 2D                cp      '-'             ; '-' ASCII ?
2246+ 2190 C8                   ret     Z               ; Yes - Return
2247+ 2191 14                   inc     D               ; Inc to flag positive exponent
2248+ 2192 FE 2B                cp      '+'             ; '+' ASCII ?
2249+ 2194 C8                   ret     Z               ; Yes - Return
2250+ 2195 FE BD                cp      ZPLUS           ; '+' token ?
2251+ 2197 C8                   ret     Z               ; Yes - Return
2252+ 2198 2B                   dec     HL              ; dec 'cos GETCHR INCs
2253+ 2199 C9                   ret                     ; Return "NZ"
2254+ 219A
2255+ 219A              ; execute OR, AND, and XOR operations
2256+ 219A AF           PAND:   xor     A               ; for AND, Z=1
2257+ 219B 18 07                jr      CNTLGC
2258+ 219D AF           POR:    xor     A               ; for OR, Z=0, S=1
2259+ 219E D6 01                sub     $01
2260+ 21A0 18 02                jr      CNTLGC
2261+ 21A2 AF           PXOR:   xor     A               ; for XOR, Z=0, S=0
2262+ 21A3 3C                   inc     A
2263+ 21A4 F5           CNTLGC: push    AF              ; store operand's flags
2264+ 21A5 CD 4A 20             call    TSTNUM          ; Make sure it's a number
2265+ 21A8 CD 74 1C             call    DEINT           ; Get integer -32768 to 32767
2266+ 21AB F1                   pop     AF              ; retrieve operand's flags
2267+ 21AC EB                   ex      DE,HL           ; <- Get last
2268+ 21AD C1                   pop     BC              ; <-  value
2269+ 21AE E3                   ex      (SP),HL         ; <-  from
2270+ 21AF EB                   ex      DE,HL           ; <-  stack
2271+ 21B0 CD 95 2E             call    FPBCDE          ; Move last value to FPREG
2272+ 21B3 F5                   push    AF              ; store operand's flags
2273+ 21B4 CD 74 1C             call    DEINT           ; Get integer -32768 to 32767
2274+ 21B7 F1                   pop     AF              ; retrieve operand's flags
2275+ 21B8 C1                   pop     BC              ; Get value
2276+ 21B9 79                   ld      A,C             ; Get LSB
2277+ 21BA 21 30 24             ld      HL,ACPASS       ; Address of save AC as current
2278+ 21BD 20 05                jr      NZ,POR1         ; if X/OR, jump over
2279+ 21BF A3           PAND1:  and     E               ; "AND" LSBs
2280+ 21C0 4F                   ld      C,A             ; Save LSB
2281+ 21C1 78                   ld      A,B             ; Get MSB
2282+ 21C2 A2                   and     D               ; "AND" MSBs
2283+ 21C3 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2284+ 21C4 F2 CC 21     POR1:   jp      P,PXOR1         ; if S=0, jump to XOR
2285+ 21C7 B3                   or      E               ; "OR" LSBs
2286+ 21C8 4F                   ld      C,A             ; Save LSB
2287+ 21C9 78                   ld      A,B             ; Get MSB
2288+ 21CA B2                   or      D               ; "OR" MSBs
2289+ 21CB E9                   jp      (HL)            ; Save AC as current (ACPASS)
2290+ 21CC AB           PXOR1:  xor     E               ; "XOR" LSBs
2291+ 21CD 4F                   ld      C,A             ; Save LSB
2292+ 21CE 78                   ld      A,B             ; Get MSB
2293+ 21CF AA                   xor     D               ; "XOR" MSBs
2294+ 21D0 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2295+ 21D1
2296+ 21D1 21 E3 21     TSTRED: ld      HL,CMPLOG       ; Logical compare routine
2297+ 21D4 3A 83 52             ld      A,(TYPE)        ; Get data type
2298+ 21D7 1F                   rra                     ; Carry set = string
2299+ 21D8 7A                   ld      A,D             ; Get last precedence value
2300+ 21D9 17                   rla                     ; Times 2 plus carry
2301+ 21DA 5F                   ld      E,A             ; To E
2302+ 21DB 16 64                ld      D,$64           ; Relational precedence
2303+ 21DD 78                   ld      A,B             ; Get current precedence
2304+ 21DE BA                   cp      D               ; Compare with last
2305+ 21DF D0                   ret     NC              ; Eval if last was rel' or log'
2306+ 21E0 C3 B9 20             jp      STKTHS          ; Stack this one and get next
2307+ 21E3
2308+ 21E3 E5 21        CMPLOG: defw    CMPLG1          ; Compare two values / strings
2309+ 21E5 79           CMPLG1: ld      A,C             ; Get data type
2310+ 21E6 B7                   or      A
2311+ 21E7 1F                   rra
2312+ 21E8 C1                   pop     BC              ; Get last expression to BCDE
2313+ 21E9 D1                   pop     DE
2314+ 21EA F5                   push    AF              ; Save status
2315+ 21EB CD 4C 20             call    CHKTYP          ; Check that types match
2316+ 21EE 21 27 22             ld      HL,CMPRES       ; Result to comparison
2317+ 21F1 E5                   push    HL              ; Save for RETurn
2318+ 21F2 CA CF 2E             jp      Z,CMPNUM        ; Compare values if numeric
2319+ 21F5 AF                   xor     A               ; Compare two strings
2320+ 21F6 32 83 52             ld      (TYPE),A        ; Set type to numeric
2321+ 21F9 D5                   push    DE              ; Save string name
2322+ 21FA CD 92 26             call    GSTRCU          ; Get current string
2323+ 21FD 7E                   ld      A,(HL)          ; Get length of string
2324+ 21FE 23                   inc     HL
2325+ 21FF 23                   inc     HL
2326+ 2200 4E                   ld      C,(HL)          ; Get LSB of address
2327+ 2201 23                   inc     HL
2328+ 2202 46                   ld      B,(HL)          ; Get MSB of address
2329+ 2203 D1                   pop     DE              ; Restore string name
2330+ 2204 C5                   push    BC              ; Save address of string
2331+ 2205 F5                   push    AF              ; Save length of string
2332+ 2206 CD 96 26             call    GSTRDE          ; Get second string
2333+ 2209 CD A3 2E             call    LOADFP          ; Get address of second string
2334+ 220C F1                   pop     AF              ; Restore length of string 1
2335+ 220D 57                   ld      D,A             ; Length to D
2336+ 220E E1                   pop     HL              ; Restore address of string 1
2337+ 220F 7B           CMPSTR: ld      A,E             ; Bytes of string 2 to do
2338+ 2210 B2                   or      D               ; Bytes of string 1 to do
2339+ 2211 C8                   ret     Z               ; Exit if all bytes compared
2340+ 2212 7A                   ld      A,D             ; Get bytes of string 1 to do
2341+ 2213 D6 01                sub     $01
2342+ 2215 D8                   ret     C               ; Exit if end of string 1
2343+ 2216 AF                   xor     A
2344+ 2217 BB                   cp      E               ; Bytes of string 2 to do
2345+ 2218 3C                   inc     A
2346+ 2219 D0                   ret     NC              ; Exit if end of string 2
2347+ 221A 15                   dec     D               ; Count bytes in string 1
2348+ 221B 1D                   dec     E               ; Count bytes in string 2
2349+ 221C 0A                   ld      A,(BC)          ; Byte in string 2
2350+ 221D BE                   cp      (HL)            ; Compare to byte in string 1
2351+ 221E 23                   inc     HL              ; Move up string 1
2352+ 221F 03                   inc     BC              ; Move up string 2
2353+ 2220 CA 0F 22             jp      Z,CMPSTR        ; Same - Try next bytes
2354+ 2223 3F                   ccf                     ; Flag difference (">" or "<")
2355+ 2224 C3 5F 2E             jp      FLGDIF          ; "<" gives -1 , ">" gives +1
2356+ 2227
2357+ 2227 3C           CMPRES: inc     A               ; Increment current value
2358+ 2228 8F                   adc     A,A             ; Double plus carry
2359+ 2229 C1                   pop     BC              ; Get other value
2360+ 222A A0                   and     B               ; Combine them
2361+ 222B C6 FF                add     A,-1            ; Carry set if different
2362+ 222D 9F                   sbc     A,A             ; 00 - Equal , FF - Different
2363+ 222E C3 66 2E             jp      FLGREL          ; Set current value & continue
2364+ 2231
2365+ 2231 16 5A        EVNOT:  ld      D,$5A           ; Precedence value for "NOT"
2366+ 2233 CD 5C 20             call    EVAL1           ; Eval until precedence break
2367+ 2236 CD 4A 20             call    TSTNUM          ; Make sure it's a number
2368+ 2239 CD 74 1C             call    DEINT           ; Get integer -32768 - 32767
2369+ 223C 7B                   ld      A,E             ; Get LSB
2370+ 223D 2F                   cpl                     ; Invert LSB
2371+ 223E 4F                   ld      C,A             ; Save "NOT" of LSB
2372+ 223F 7A                   ld      A,D             ; Get MSB
2373+ 2240 2F                   cpl                     ; Invert MSB
2374+ 2241 CD 30 24             call    ACPASS          ; Save AC as current
2375+ 2244 C1                   pop     BC              ; Clean up stack
2376+ 2245 C3 68 20             jp      EVAL3           ; Continue evaluation
2377+ 2248
2378+ 2248 2B           DIMRET: dec     HL              ; dec 'cos GETCHR INCs
2379+ 2249 CD BE 1B             call    GETCHR          ; Get next character
2380+ 224C C8                   ret     Z               ; End of DIM statement
2381+ 224D CD 7D 19             call    CHKSYN          ; Make sure ',' follows
2382+ 2250 2C                   defb    ','
2383+ 2251 01 48 22     DIM:    ld      BC,DIMRET       ; Return to "DIMRET"
2384+ 2254 C5                   push    BC              ; Save on stack
2385+ 2255 F6                   defb    $F6             ; Flag "Create" variable
2386+ 2256 AF           GETVAR: xor     A               ; Find variable address,to DE
2387+ 2257 32 82 52             ld      (LCRFLG),A      ; Set locate / create flag
2388+ 225A 46                   ld      B,(HL)          ; Get First byte of name
2389+ 225B CD 60 1C     GTFNAM: call    CHKLTR          ; See if a letter
2390+ 225E DA 9B 16             jp      C,SNERR         ; ?SN Error if not a letter
2391+ 2261 AF                   xor     A
2392+ 2262 4F                   ld      C,A             ; Clear second byte of name
2393+ 2263 32 83 52             ld      (TYPE),A        ; Set type to numeric
2394+ 2266 CD BE 1B             call    GETCHR          ; Get next character
2395+ 2269 DA 72 22             jp      C,SVNAM2        ; Numeric - Save in name
2396+ 226C CD 60 1C             call    CHKLTR          ; See if a letter
2397+ 226F DA 7F 22             jp      C,CHARTY        ; Not a letter - Check type
2398+ 2272 4F           SVNAM2: ld      C,A             ; Save second byte of name
2399+ 2273 CD BE 1B     ENDNAM: call    GETCHR          ; Get next character
2400+ 2276 DA 73 22             jp      C,ENDNAM        ; Numeric - Get another
2401+ 2279 CD 60 1C             call    CHKLTR          ; See if a letter
2402+ 227C D2 73 22             jp      NC,ENDNAM       ; Letter - Get another
2403+ 227F D6 24        CHARTY: sub     '$'             ; String variable?
2404+ 2281 C2 8E 22             jp      NZ,NOTSTR       ; No - Numeric variable
2405+ 2284 3C                   inc     A               ; A = 1 (string type)
2406+ 2285 32 83 52             ld      (TYPE),A        ; Set type to string
2407+ 2288 0F                   rrca                    ; A = 80H , Flag for string
2408+ 2289 81                   add     A,C             ; 2nd byte of name has bit 7 on
2409+ 228A 4F                   ld      C,A             ; Resave second byte on name
2410+ 228B CD BE 1B             call    GETCHR          ; Get next character
2411+ 228E 3A A1 52     NOTSTR: ld      A,(FORFLG)      ; Array name needed ?
2412+ 2291 3D                   dec     A
2413+ 2292 CA 3B 23             jp      Z,ARLDSV        ; Yes - Get array name
2414+ 2295 F2 9E 22             jp      P,NSCFOR        ; No array with "FOR" or "FN"
2415+ 2298 7E                   ld      A,(HL)          ; Get byte again
2416+ 2299 D6 28                sub     '('             ; Subscripted variable?
2417+ 229B CA 13 23             jp      Z,SBSCPT        ; Yes - Sort out subscript
2418+ 229E
2419+ 229E AF           NSCFOR: xor     A               ; Simple variable
2420+ 229F 32 A1 52             ld      (FORFLG),A      ; Clear "FOR" flag
2421+ 22A2 E5                   push    HL              ; Save code string address
2422+ 22A3 50                   ld      D,B             ; DE = Variable name to find
2423+ 22A4 59                   ld      E,C
2424+ 22A5 2A 1B 53             ld      HL,(FNRGNM)     ; FN argument name
2425+ 22A8 CD 77 19             call    CPDEHL          ; Is it the FN argument?
2426+ 22AB 11 1D 53             ld      DE,FNARG        ; Point to argument value
2427+ 22AE CA 44 2D             jp      Z,POPHRT        ; Yes - Return FN argument value
2428+ 22B1 2A 15 53             ld      HL,(VAREND)     ; End of variables
2429+ 22B4 EB                   ex      DE,HL           ; Address of end of search
2430+ 22B5 2A 13 53             ld      HL,(PROGND)     ; Start of variables address
2431+ 22B8 CD 77 19     FNDVAR: call    CPDEHL          ; End of variable list table?
2432+ 22BB CA D1 22             jp      Z,CFEVAL        ; Yes - Called from EVAL?
2433+ 22BE 79                   ld      A,C             ; Get second byte of name
2434+ 22BF 96                   sub     (HL)            ; Compare with name in list
2435+ 22C0 23                   inc     HL              ; Move on to first byte
2436+ 22C1 C2 C6 22             jp      NZ,FNTHR        ; Different - Find another
2437+ 22C4 78                   ld      A,B             ; Get first byte of name
2438+ 22C5 96                   sub     (HL)            ; Compare with name in list
2439+ 22C6 23           FNTHR:  inc     HL              ; Move on to LSB of value
2440+ 22C7 CA 05 23             jp      Z,RETADR        ; Found - Return address
2441+ 22CA 23                   inc     HL              ; <- Skip
2442+ 22CB 23                   inc     HL              ; <- over
2443+ 22CC 23                   inc     HL              ; <- F.P.
2444+ 22CD 23                   inc     HL              ; <- value
2445+ 22CE C3 B8 22             jp      FNDVAR          ; Keep looking
2446+ 22D1
2447+ 22D1 E1           CFEVAL: pop     HL              ; Restore code string address
2448+ 22D2 E3                   ex      (SP),HL         ; Get return address
2449+ 22D3 D5                   push    DE              ; Save address of variable
2450+ 22D4 11 3A 21             ld      DE,FRMEVL       ; Return address in EVAL
2451+ 22D7 CD 77 19             call    CPDEHL          ; Called from EVAL ?
2452+ 22DA D1                   pop     DE              ; Restore address of variable
2453+ 22DB CA 08 23             jp      Z,RETNUL        ; Yes - Return null variable
2454+ 22DE E3                   ex      (SP),HL         ; Put back return
2455+ 22DF E5                   push    HL              ; Save code string address
2456+ 22E0 C5                   push    BC              ; Save variable name
2457+ 22E1 01 06 00             ld      BC,$0006        ; 2 byte name plus 4 byte data
2458+ 22E4 2A 17 53             ld      HL,(ARREND)     ; End of arrays
2459+ 22E7 E5                   push    HL              ; Save end of arrays
2460+ 22E8 09                   add     HL,BC           ; Move up 6 bytes
2461+ 22E9 C1                   pop     BC              ; Source address in BC
2462+ 22EA E5                   push    HL              ; Save new end address
2463+ 22EB CD 47 16             call    MOVUP           ; Move arrays up
2464+ 22EE E1                   pop     HL              ; Restore new end address
2465+ 22EF 22 17 53             ld      (ARREND),HL     ; Set new end address
2466+ 22F2 60                   ld      H,B             ; End of variables to HL
2467+ 22F3 69                   ld      L,C
2468+ 22F4 22 15 53             ld      (VAREND),HL     ; Set new end address
2469+ 22F7
2470+ 22F7 2B           ZEROLP: dec     HL              ; Back through to zero variable
2471+ 22F8 36 00                ld      (HL),$00        ; Zero byte in variable
2472+ 22FA CD 77 19             call    CPDEHL          ; Done them all?
2473+ 22FD C2 F7 22             jp      NZ,ZEROLP       ; No - Keep on going
2474+ 2300 D1                   pop     DE              ; Get variable name
2475+ 2301 73                   ld      (HL),E          ; Store second character
2476+ 2302 23                   inc     HL
2477+ 2303 72                   ld      (HL),D          ; Store first character
2478+ 2304 23                   inc     HL
2479+ 2305 EB           RETADR: ex      DE,HL           ; Address of variable in DE
2480+ 2306 E1                   pop     HL              ; Restore code string address
2481+ 2307 C9                   ret
2482+ 2308
2483+ 2308 32 24 53     RETNUL: ld      (FPEXP),A       ; Set result to zero
2484+ 230B 21 18 16             ld      HL,ZERBYT       ; Also set a null string
2485+ 230E 22 21 53             ld      (FPREG),HL      ; Save for EVAL
2486+ 2311 E1                   pop     HL              ; Restore code string address
2487+ 2312 C9                   ret
2488+ 2313
2489+ 2313 E5           SBSCPT: push    HL              ; Save code string address
2490+ 2314 2A 82 52             ld      HL,(LCRFLG)     ; Locate/Create and Type
2491+ 2317 E3                   ex      (SP),HL         ; Save and get code string
2492+ 2318 57                   ld      D,A             ; Zero number of dimensions
2493+ 2319 D5           SCPTLP: push    DE              ; Save number of dimensions
2494+ 231A C5                   push    BC              ; Save array name
2495+ 231B CD 68 1C             call    FPSINT          ; Get subscript (0-32767)
2496+ 231E C1                   pop     BC              ; Restore array name
2497+ 231F F1                   pop     AF              ; Get number of dimensions
2498+ 2320 EB                   ex      DE,HL
2499+ 2321 E3                   ex      (SP),HL         ; Save subscript value
2500+ 2322 E5                   push    HL              ; Save LCRFLG and TYPE
2501+ 2323 EB                   ex      DE,HL
2502+ 2324 3C                   inc     A               ; Count dimensions
2503+ 2325 57                   ld      D,A             ; Save in D
2504+ 2326 7E                   ld      A,(HL)          ; Get next byte in code string
2505+ 2327 FE 2C                cp      ','             ; Comma (more to come)?
2506+ 2329 CA 19 23             jp      Z,SCPTLP        ; Yes - More subscripts
2507+ 232C CD 7D 19             call    CHKSYN          ; Make sure ")" follows
2508+ 232F 29                   defb    ')'
2509+ 2330 22 A6 52             ld      (NXTOPR),HL     ; Save code string address
2510+ 2333 E1                   pop     HL              ; Get LCRFLG and TYPE
2511+ 2334 22 82 52             ld      (LCRFLG),HL     ; Restore Locate/create & type
2512+ 2337 1E 00                ld      E,$00           ; Flag not CSAVE* or CLOAD*
2513+ 2339 D5                   push    DE              ; Save number of dimensions (D)
2514+ 233A 11                   defb    $11             ; Skip "push HL" and "push AF'
2515+ 233B
2516+ 233B E5           ARLDSV: push    HL              ; Save code string address
2517+ 233C F5                   push    AF              ; A = 00 , Flags set = Z,N
2518+ 233D 2A 15 53             ld      HL,(VAREND)     ; Start of arrays
2519+ 2340 3E                   defb    $3E             ; Skip "add HL,DE"
2520+ 2341 19           FNDARY: add     HL,DE           ; Move to next array start
2521+ 2342 EB                   ex      DE,HL
2522+ 2343 2A 17 53             ld      HL,(ARREND)     ; End of arrays
2523+ 2346 EB                   ex      DE,HL           ; Current array pointer
2524+ 2347 CD 77 19             call    CPDEHL          ; End of arrays found?
2525+ 234A CA 73 23             jp      Z,CREARY        ; Yes - Create array
2526+ 234D 7E                   ld      A,(HL)          ; Get second byte of name
2527+ 234E B9                   cp      C               ; Compare with name given
2528+ 234F 23                   inc     HL              ; Move on
2529+ 2350 C2 55 23             jp      NZ,NXTARY       ; Different - Find next array
2530+ 2353 7E                   ld      A,(HL)          ; Get first byte of name
2531+ 2354 B8                   cp      B               ; Compare with name given
2532+ 2355 23           NXTARY: inc     HL              ; Move on
2533+ 2356 5E                   ld      E,(HL)          ; Get LSB of next array address
2534+ 2357 23                   inc     HL
2535+ 2358 56                   ld      D,(HL)          ; Get MSB of next array address
2536+ 2359 23                   inc     HL
2537+ 235A C2 41 23             jp      NZ,FNDARY       ; Not found - Keep looking
2538+ 235D 3A 82 52             ld      A,(LCRFLG)      ; Found Locate or Create it?
2539+ 2360 B7                   or      A
2540+ 2361 C2 A4 16             jp      NZ,DDERR        ; Create - ?DD Error
2541+ 2364 F1                   pop     AF              ; Locate - Get number of dim'ns
2542+ 2365 44                   ld      B,H             ; BC Points to array dim'ns
2543+ 2366 4D                   ld      C,L
2544+ 2367 CA 44 2D             jp      Z,POPHRT        ; Jump if array load/save
2545+ 236A 96                   sub     (HL)            ; Same number of dimensions?
2546+ 236B CA D1 23             jp      Z,FINDEL        ; Yes - Find element
2547+ 236E 1E 10        BSERR:  ld      E,BS            ; ?BS Error
2548+ 2370 C3 AF 16             jp      ERROR           ; Output error
2549+ 2373
2550+ 2373 11 04 00     CREARY: ld      DE,$0004        ; 4 Bytes per entry
2551+ 2376 F1                   pop     AF              ; Array to save or 0 dim'ns?
2552+ 2377 CA 89 1C             jp      Z,FCERR         ; Yes - ?FC Error
2553+ 237A 71                   ld      (HL),C          ; Save second byte of name
2554+ 237B 23                   inc     HL
2555+ 237C 70                   ld      (HL),B          ; Save first byte of name
2556+ 237D 23                   inc     HL
2557+ 237E 4F                   ld      C,A             ; Number of dimensions to C
2558+ 237F CD 58 16             call    CHKSTK          ; Check if enough memory
2559+ 2382 23                   inc     HL              ; Point to number of dimensions
2560+ 2383 23                   inc     HL
2561+ 2384 22 9B 52             ld      (CUROPR),HL     ; Save address of pointer
2562+ 2387 71                   ld      (HL),C          ; Set number of dimensions
2563+ 2388 23                   inc     HL
2564+ 2389 3A 82 52             ld      A,(LCRFLG)      ; Locate of Create?
2565+ 238C 17                   rla                     ; Carry set = Create
2566+ 238D 79                   ld      A,C             ; Get number of dimensions
2567+ 238E 01 0B 00     CRARLP: ld      BC,10+1         ; Default dimension size 10
2568+ 2391 D2 96 23             jp      NC,DEFSIZ       ; Locate - Set default size
2569+ 2394 C1                   pop     BC              ; Get specified dimension size
2570+ 2395 03                   inc     BC              ; Include zero element
2571+ 2396 71           DEFSIZ: ld      (HL),C          ; Save LSB of dimension size
2572+ 2397 23                   inc     HL
2573+ 2398 70                   ld      (HL),B          ; Save MSB of dimension size
2574+ 2399 23                   inc     HL
2575+ 239A F5                   push    AF              ; Save num' of dim'ns an status
2576+ 239B E5                   push    HL              ; Save address of dim'n size
2577+ 239C CD 40 2F             call    MLDEBC          ; Multiply DE by BC to find
2578+ 239F EB                   ex      DE,HL           ; amount of mem needed (to DE)
2579+ 23A0 E1                   pop     HL              ; Restore address of dimension
2580+ 23A1 F1                   pop     AF              ; Restore number of dimensions
2581+ 23A2 3D                   dec     A               ; Count them
2582+ 23A3 C2 8E 23             jp      NZ,CRARLP       ; Do next dimension if more
2583+ 23A6 F5                   push    AF              ; Save locate/create flag
2584+ 23A7 42                   ld      B,D             ; MSB of memory needed
2585+ 23A8 4B                   ld      C,E             ; LSB of memory needed
2586+ 23A9 EB                   ex      DE,HL
2587+ 23AA 19                   add     HL,DE           ; Add bytes to array start
2588+ 23AB DA 70 16             jp      C,OMERR         ; Too big - Error
2589+ 23AE CD 61 16             call    ENFMEM          ; See if enough memory
2590+ 23B1 22 17 53             ld      (ARREND),HL     ; Save new end of array
2591+ 23B4
2592+ 23B4 2B           ZERARY: dec     HL              ; Back through array data
2593+ 23B5 36 00                ld      (HL),$00        ; Set array element to zero
2594+ 23B7 CD 77 19             call    CPDEHL          ; All elements zeroed?
2595+ 23BA C2 B4 23             jp      NZ,ZERARY       ; No - Keep on going
2596+ 23BD 03                   inc     BC              ; Number of bytes + 1
2597+ 23BE 57                   ld      D,A             ; A=0
2598+ 23BF 2A 9B 52             ld      HL,(CUROPR)     ; Get address of array
2599+ 23C2 5E                   ld      E,(HL)          ; Number of dimensions
2600+ 23C3 EB                   ex      DE,HL           ; To HL
2601+ 23C4 29                   add     HL,HL           ; Two bytes per dimension size
2602+ 23C5 09                   add     HL,BC           ; Add number of bytes
2603+ 23C6 EB                   ex      DE,HL           ; Bytes needed to DE
2604+ 23C7 2B                   dec     HL
2605+ 23C8 2B                   dec     HL
2606+ 23C9 73                   ld      (HL),E          ; Save LSB of bytes needed
2607+ 23CA 23                   inc     HL
2608+ 23CB 72                   ld      (HL),D          ; Save MSB of bytes needed
2609+ 23CC 23                   inc     HL
2610+ 23CD F1                   pop     AF              ; Locate / Create?
2611+ 23CE DA F5 23             jp      C,ENDDIM        ; A is 0 , End if create
2612+ 23D1 47           FINDEL: ld      B,A             ; Find array element
2613+ 23D2 4F                   ld      C,A
2614+ 23D3 7E                   ld      A,(HL)          ; Number of dimensions
2615+ 23D4 23                   inc     HL
2616+ 23D5 16                   defb    $16             ; Skip "pop HL"
2617+ 23D6 E1           FNDELP: pop     HL              ; Address of next dim' size
2618+ 23D7 5E                   ld      E,(HL)          ; Get LSB of dim'n size
2619+ 23D8 23                   inc     HL
2620+ 23D9 56                   ld      D,(HL)          ; Get MSB of dim'n size
2621+ 23DA 23                   inc     HL
2622+ 23DB E3                   ex      (SP),HL         ; Save address - Get index
2623+ 23DC F5                   push    AF              ; Save number of dim'ns
2624+ 23DD CD 77 19             call    CPDEHL          ; Dimension too large?
2625+ 23E0 D2 6E 23             jp      NC,BSERR        ; Yes - ?BS Error
2626+ 23E3 E5                   push    HL              ; Save index
2627+ 23E4 CD 40 2F             call    MLDEBC          ; Multiply previous by size
2628+ 23E7 D1                   pop     DE              ; Index supplied to DE
2629+ 23E8 19                   add     HL,DE           ; Add index to pointer
2630+ 23E9 F1                   pop     AF              ; Number of dimensions
2631+ 23EA 3D                   dec     A               ; Count them
2632+ 23EB 44                   ld      B,H             ; MSB of pointer
2633+ 23EC 4D                   ld      C,L             ; LSB of pointer
2634+ 23ED C2 D6 23             jp      NZ,FNDELP       ; More - Keep going
2635+ 23F0 29                   add     HL,HL           ; 4 Bytes per element
2636+ 23F1 29                   add     HL,HL
2637+ 23F2 C1                   pop     BC              ; Start of array
2638+ 23F3 09                   add     HL,BC           ; Point to element
2639+ 23F4 EB                   ex      DE,HL           ; Address of element to DE
2640+ 23F5 2A A6 52     ENDDIM: ld      HL,(NXTOPR)     ; Got code string address
2641+ 23F8 C9                   ret
2642+ 23F9
2643+ 23F9
2644+ 23F9              ; returns the value of the 32-bit system tick counter as
2645+ 23F9              ; two 16-bit words
2646+ 23F9 CD 4A 20     TMR:    call    TSTNUM          ; Make sure it's a number
2647+ 23FC CD 74 1C             call    DEINT           ; Get integer (-32768 to 32767)
2648+ 23FF 2A AC 52             ld      HL,(TMRCNT)     ; load the LSBytes of timer
2649+ 2402 7B                   ld      A,E
2650+ 2403 B2                   or      D               ; is it 0?
2651+ 2404 CA 0A 24             jp      Z,ENDTMR        ; yes, jump over
2652+ 2407 2A AE 52             ld      HL,(TMRCNT+2)   ; load the MSBytes of timer
2653+ 240A 45           ENDTMR: ld      B,L             ; move bytes...
2654+ 240B 7C                   ld      A,H             ; ...into AB
2655+ 240C C3 31 24             jp      ABPASS          ; return word into AB
2656+ 240F
2657+ 240F
2658+ 240F              ; returns the free space for BASIC or into the string pool
2659+ 240F 2A 17 53     FRE:    ld      HL,(ARREND)     ; Start of free memory
2660+ 2412 EB                   ex      DE,HL           ; To DE
2661+ 2413 21 00 00             ld      HL,$0000        ; End of free memory
2662+ 2416 39                   add     HL,SP           ; Current stack value
2663+ 2417 3A 83 52             ld      A,(TYPE)        ; Dummy argument type
2664+ 241A B7                   or      A
2665+ 241B CA 2B 24             jp      Z,FRENUM        ; Numeric - Free variable space
2666+ 241E CD 92 26             call    GSTRCU          ; Current string to pool
2667+ 2421 CD 92 25             call    GARBGE          ; Garbage collection
2668+ 2424 2A 9C 51             ld      HL,(STRSPC)     ; Bottom of string space in use
2669+ 2427 EB                   ex      DE,HL           ; To DE
2670+ 2428 2A 99 52             ld      HL,(STRBOT)     ; Bottom of string space
2671+ 242B 7D           FRENUM: ld      A,L             ; Get LSB of end
2672+ 242C 93                   sub     E               ; Subtract LSB of beginning
2673+ 242D 4F                   ld      C,A             ; Save difference if C
2674+ 242E 7C                   ld      A,H             ; Get MSB of end
2675+ 242F 9A                   sbc     A,D             ; Subtract MSB of beginning
2676+ 2430 41           ACPASS: ld      B,C             ; Return integer AC
2677+ 2431 50           ABPASS: ld      D,B             ; Return integer AB
2678+ 2432 1E 00                ld      E,$00
2679+ 2434 21 83 52             ld      HL,TYPE         ; Point to type
2680+ 2437 73                   ld      (HL),E          ; Set type to numeric
2681+ 2438 06 90                ld      B,$80+$10       ; 16 bit integer
2682+ 243A C3 6B 2E             jp      RETINT          ; Return the integer
2683+ 243D
2684+ 243D              ; returns the X position of the cursor during a print
2685+ 243D 3A 81 52     POS:    ld      A,(CURPOS)      ; Get cursor position
2686+ 2440 47           PASSA:  ld      B,A             ; Put A into AB
2687+ 2441 AF                   xor     A               ; Zero A
2688+ 2442 C3 31 24             jp      ABPASS          ; Return integer AB
2689+ 2445
2690+ 2445 CD C8 24     DEF:    call    CHEKFN          ; Get "FN" and name
2691+ 2448 CD BA 24             call    IDTEST          ; Test for illegal direct
2692+ 244B 01 67 1D             ld      BC,DATA         ; To get next statement
2693+ 244E C5                   push    BC              ; Save address for RETurn
2694+ 244F D5                   push    DE              ; Save address of function ptr
2695+ 2450 CD 7D 19             call    CHKSYN          ; Make sure "(" follows
2696+ 2453 28                   defb    '('
2697+ 2454 CD 56 22             call    GETVAR          ; Get argument variable name
2698+ 2457 E5                   push    HL              ; Save code string address
2699+ 2458 EB                   ex      DE,HL           ; Argument address to HL
2700+ 2459 2B                   dec     HL
2701+ 245A 56                   ld      D,(HL)          ; Get first byte of arg name
2702+ 245B 2B                   dec     HL
2703+ 245C 5E                   ld      E,(HL)          ; Get second byte of arg name
2704+ 245D E1                   pop     HL              ; Restore code string address
2705+ 245E CD 4A 20             call    TSTNUM          ; Make sure numeric argument
2706+ 2461 CD 7D 19             call    CHKSYN          ; Make sure ")" follows
2707+ 2464 29                   defb    ')'
2708+ 2465 CD 7D 19             call    CHKSYN          ; Make sure "=" follows
2709+ 2468 C8                   defb    ZEQUAL          ; "=" token
2710+ 2469 44                   ld      B,H             ; Code string address to BC
2711+ 246A 4D                   ld      C,L
2712+ 246B E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2713+ 246C 71                   ld      (HL),C          ; Save LSB of FN code string
2714+ 246D 23                   inc     HL
2715+ 246E 70                   ld      (HL),B          ; Save MSB of FN code string
2716+ 246F C3 07 25             jp      SVSTAD          ; Save address and do function
2717+ 2472
2718+ 2472 CD C8 24     DOFN:   call    CHEKFN          ; Make sure FN follows
2719+ 2475 D5                   push    DE              ; Save function pointer address
2720+ 2476 CD 1E 21             call    EVLPAR          ; Evaluate expression in "()"
2721+ 2479 CD 4A 20             call    TSTNUM          ; Make sure numeric result
2722+ 247C E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2723+ 247D 5E                   ld      E,(HL)          ; Get LSB of FN code string
2724+ 247E 23                   inc     HL
2725+ 247F 56                   ld      D,(HL)          ; Get MSB of FN code string
2726+ 2480 23                   inc     HL
2727+ 2481 7A                   ld      A,D             ; And function DEFined?
2728+ 2482 B3                   or      E
2729+ 2483 CA A7 16             jp      Z,UFERR         ; No - ?UF Error
2730+ 2486 7E                   ld      A,(HL)          ; Get LSB of argument address
2731+ 2487 23                   inc     HL
2732+ 2488 66                   ld      H,(HL)          ; Get MSB of argument address
2733+ 2489 6F                   ld      L,A             ; HL = Arg variable address
2734+ 248A E5                   push    HL              ; Save it
2735+ 248B 2A 1B 53             ld      HL,(FNRGNM)     ; Get old argument name
2736+ 248E E3                   ex      (SP),HL         ; Save old , Get new
2737+ 248F 22 1B 53             ld      (FNRGNM),HL     ; Set new argument name
2738+ 2492 2A 1F 53             ld      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2739+ 2495 E5                   push    HL              ; Save it
2740+ 2496 2A 1D 53             ld      HL,(FNARG)      ; Get MSB,EXP of old arg value
2741+ 2499 E5                   push    HL              ; Save it
2742+ 249A 21 1D 53             ld      HL,FNARG        ; HL = Value of argument
2743+ 249D D5                   push    DE              ; Save FN code string address
2744+ 249E CD AC 2E             call    FPTHL           ; Move FPREG to argument
2745+ 24A1 E1                   pop     HL              ; Get FN code string address
2746+ 24A2 CD 47 20             call    GETNUM          ; Get value from function
2747+ 24A5 2B                   dec     HL              ; dec 'cos GETCHR INCs
2748+ 24A6 CD BE 1B             call    GETCHR          ; Get next character
2749+ 24A9 C2 9B 16             jp      NZ,SNERR        ; Bad character in FN - Error
2750+ 24AC E1                   pop     HL              ; Get MSB,EXP of old arg
2751+ 24AD 22 1D 53             ld      (FNARG),HL      ; Restore it
2752+ 24B0 E1                   pop     HL              ; Get LSB,NLSB of old arg
2753+ 24B1 22 1F 53             ld      (FNARG+2),HL    ; Restore it
2754+ 24B4 E1                   pop     HL              ; Get name of old arg
2755+ 24B5 22 1B 53             ld      (FNRGNM),HL     ; Restore it
2756+ 24B8 E1                   pop     HL              ; Restore code string address
2757+ 24B9 C9                   ret
2758+ 24BA
2759+ 24BA E5           IDTEST: push    HL              ; Save code string address
2760+ 24BB 2A 9E 51             ld      HL,(LINEAT)     ; Get current line number
2761+ 24BE 23                   inc     HL              ; -1 means direct statement
2762+ 24BF 7C                   ld      A,H
2763+ 24C0 B5                   or      L
2764+ 24C1 E1                   pop     HL              ; Restore code string address
2765+ 24C2 C0                   ret     NZ              ; Return if in program
2766+ 24C3 1E 16                ld      E,ID            ; ?ID Error
2767+ 24C5 C3 AF 16             jp      ERROR
2768+ 24C8
2769+ 24C8 CD 7D 19     CHEKFN: call    CHKSYN          ; Make sure FN follows
2770+ 24CB B8                   defb    ZFN             ; "FN" token
2771+ 24CC 3E 80                ld      A,$80
2772+ 24CE 32 A1 52             ld      (FORFLG),A      ; Flag FN name to find
2773+ 24D1 B6                   or      (HL)            ; FN name has bit 7 set
2774+ 24D2 47                   ld      B,A             ; in first byte of name
2775+ 24D3 CD 5B 22             call    GTFNAM          ; Get FN name
2776+ 24D6 C3 4A 20             jp      TSTNUM          ; Make sure numeric function
2777+ 24D9
2778+ 24D9 CD 4A 20     STR:    call    TSTNUM          ; Make sure it's a number
2779+ 24DC CD F9 2F             call    NUMASC          ; Turn number into text
2780+ 24DF CD 0D 25     STR1:   call    CRTST           ; Create string entry for it
2781+ 24E2 CD 92 26             call    GSTRCU          ; Current string to pool
2782+ 24E5 01 ED 26             ld      BC,TOPOOL       ; Save in string pool
2783+ 24E8 C5                   push    BC              ; Save address on stack
2784+ 24E9
2785+ 24E9 7E           SAVSTR: ld      A,(HL)          ; Get string length
2786+ 24EA 23                   inc     HL
2787+ 24EB 23                   inc     HL
2788+ 24EC E5                   push    HL              ; Save pointer to string
2789+ 24ED CD 68 25             call    TESTR           ; See if enough string space
2790+ 24F0 E1                   pop     HL              ; Restore pointer to string
2791+ 24F1 4E                   ld      C,(HL)          ; Get LSB of address
2792+ 24F2 23                   inc     HL
2793+ 24F3 46                   ld      B,(HL)          ; Get MSB of address
2794+ 24F4 CD 01 25             call    CRTMST          ; Create string entry
2795+ 24F7 E5                   push    HL              ; Save pointer to MSB of addr
2796+ 24F8 6F                   ld      L,A             ; Length of string
2797+ 24F9 CD 85 26             call    TOSTRA          ; Move to string area
2798+ 24FC D1                   pop     DE              ; Restore pointer to MSB
2799+ 24FD C9                   ret
2800+ 24FE
2801+ 24FE CD 68 25     MKTMST: call    TESTR           ; See if enough string space
2802+ 2501 21 95 52     CRTMST: ld      HL,TMPSTR       ; Temporary string
2803+ 2504 E5                   push    HL              ; Save it
2804+ 2505 77                   ld      (HL),A          ; Save length of string
2805+ 2506 23                   inc     HL
2806+ 2507 23           SVSTAD: inc     HL
2807+ 2508 73                   ld      (HL),E          ; Save LSB of address
2808+ 2509 23                   inc     HL
2809+ 250A 72                   ld      (HL),D          ; Save MSB of address
2810+ 250B E1                   pop     HL              ; Restore pointer
2811+ 250C C9                   ret
2812+ 250D
2813+ 250D 2B           CRTST:  dec     HL              ; dec - INCed after
2814+ 250E 06 22        QTSTR:  ld      B,$22           ; '"'           ; Terminating quote
2815+ 2510 50                   ld      D,B             ; Quote to D
2816+ 2511 E5           DTSTR:  push    HL              ; Save start
2817+ 2512 0E FF                ld      C,-1            ; Set counter to -1
2818+ 2514 23           QTSTLP: inc     HL              ; Move on
2819+ 2515 7E                   ld      A,(HL)          ; Get byte
2820+ 2516 0C                   inc     C               ; Count bytes
2821+ 2517 B7                   or      A               ; End of line?
2822+ 2518 CA 23 25             jp      Z,CRTSTE        ; Yes - Create string entry
2823+ 251B BA                   cp      D               ; Terminator D found?
2824+ 251C CA 23 25             jp      Z,CRTSTE        ; Yes - Create string entry
2825+ 251F B8                   cp      B               ; Terminator B found?
2826+ 2520 C2 14 25             jp      NZ,QTSTLP       ; No - Keep looking
2827+ 2523 FE 22        CRTSTE: cp      $22             ; '"'             ; End with '"'?
2828+ 2525 CC BE 1B             call    Z,GETCHR        ; Yes - Get next character
2829+ 2528 E3                   ex      (SP),HL         ; Starting quote
2830+ 2529 23                   inc     HL              ; First byte of string
2831+ 252A EB                   ex      DE,HL           ; To DE
2832+ 252B 79                   ld      A,C             ; Get length
2833+ 252C CD 01 25             call    CRTMST          ; Create string entry
2834+ 252F 11 95 52     TSTOPL: ld      DE,TMPSTR       ; Temporary string
2835+ 2532 2A 87 52             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2836+ 2535 22 21 53             ld      (FPREG),HL      ; Save address of string ptr
2837+ 2538 3E 01                ld      A,$01
2838+ 253A 32 83 52             ld      (TYPE),A        ; Set type to string
2839+ 253D CD AF 2E             call    DETHL4          ; Move string to pool
2840+ 2540 CD 77 19             call    CPDEHL          ; Out of string pool?
2841+ 2543 22 87 52             ld      (TMSTPT),HL     ; Save new pointer
2842+ 2546 E1                   pop     HL              ; Restore code string address
2843+ 2547 7E                   ld      A,(HL)          ; Get next code byte
2844+ 2548 C0                   ret     NZ              ; Return if pool OK
2845+ 2549 1E 1E                ld      E,ST            ; ?ST Error
2846+ 254B C3 AF 16             jp      ERROR           ; String pool overflow
2847+ 254E
2848+ 254E 23           PRNUMS: inc     HL              ; Skip leading space
2849+ 254F CD 0D 25     PRS:    call    CRTST           ; Create string entry for it
2850+ 2552 CD 92 26     PRS1:   call    GSTRCU          ; Current string to pool
2851+ 2555 CD A3 2E             call    LOADFP          ; Move string block to BCDE
2852+ 2558 1C                   inc     E               ; Length + 1
2853+ 2559 1D           PRSLP:  dec     E               ; Count characters
2854+ 255A C8                   ret     Z               ; End of string
2855+ 255B 0A                   ld      A,(BC)          ; Get byte to output
2856+ 255C CD 88 19             call    OUTC            ; Output character in A
2857+ 255F FE 0D                cp      CR              ; Return?
2858+ 2561 CC 95 1E             call    Z,CNTEND        ; Yes - Position cursor to 0
2859+ 2564 03                   inc     BC              ; Next byte in string
2860+ 2565 C3 59 25             jp      PRSLP           ; More characters to output
2861+ 2568
2862+ 2568 B7           TESTR:  or      A               ; Test if enough room
2863+ 2569 0E                   defb    $0E             ; No garbage collection done
2864+ 256A F1           GRBDON: pop     AF              ; Garbage collection done
2865+ 256B F5                   push    AF              ; Save status
2866+ 256C 2A 9C 51             ld      HL,(STRSPC)     ; Bottom of string space in use
2867+ 256F EB                   ex      DE,HL           ; To DE
2868+ 2570 2A 99 52             ld      HL,(STRBOT)     ; Bottom of string area
2869+ 2573 2F                   cpl                     ; Negate length (Top down)
2870+ 2574 4F                   ld      C,A             ; -Length to BC
2871+ 2575 06 FF                ld      B,-1            ; BC = -ve length of string
2872+ 2577 09                   add     HL,BC           ; Add to bottom of space in use
2873+ 2578 23                   inc     HL              ; Plus one for 2's complement
2874+ 2579 CD 77 19             call    CPDEHL          ; Below string RAM area?
2875+ 257C DA 86 25             jp      C,TESTOS        ; Tidy up if not done else err
2876+ 257F 22 99 52             ld      (STRBOT),HL     ; Save new bottom of area
2877+ 2582 23                   inc     HL              ; Point to first byte of string
2878+ 2583 EB                   ex      DE,HL           ; Address to DE
2879+ 2584 F1           POPAF:  pop     AF              ; Throw away status push
2880+ 2585 C9                   ret
2881+ 2586
2882+ 2586 F1           TESTOS: pop     AF              ; Garbage collect been done?
2883+ 2587 1E 1A                ld      E,OS            ; ?OS Error
2884+ 2589 CA AF 16             jp      Z,ERROR         ; Yes - Not enough string space
2885+ 258C BF                   cp      A               ; Flag garbage collect done
2886+ 258D F5                   push    AF              ; Save status
2887+ 258E 01 6A 25             ld      BC,GRBDON       ; Garbage collection done
2888+ 2591 C5                   push    BC              ; Save for RETurn
2889+ 2592 2A 85 52     GARBGE: ld      HL,(LSTRAM)     ; Get end of RAM pointer
2890+ 2595 22 99 52     GARBLP: ld      (STRBOT),HL     ; Reset string pointer
2891+ 2598 21 00 00             ld      HL,$0000
2892+ 259B E5                   push    HL              ; Flag no string found
2893+ 259C 2A 9C 51             ld      HL,(STRSPC)     ; Get bottom of string space
2894+ 259F E5                   push    HL              ; Save bottom of string space
2895+ 25A0 21 89 52             ld      HL,TMSTPL       ; Temporary string pool
2896+ 25A3 EB           GRBLP:  ex      DE,HL
2897+ 25A4 2A 87 52             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2898+ 25A7 EB                   ex      DE,HL
2899+ 25A8 CD 77 19             call    CPDEHL          ; Temporary string pool done?
2900+ 25AB 01 A3 25             ld      BC,GRBLP        ; Loop until string pool done
2901+ 25AE C2 F7 25             jp      NZ,STPOOL       ; No - See if in string area
2902+ 25B1 2A 13 53             ld      HL,(PROGND)     ; Start of simple variables
2903+ 25B4 EB           SMPVAR: ex      DE,HL
2904+ 25B5 2A 15 53             ld      HL,(VAREND)     ; End of simple variables
2905+ 25B8 EB                   ex      DE,HL
2906+ 25B9 CD 77 19             call    CPDEHL          ; All simple strings done?
2907+ 25BC CA CA 25             jp      Z,ARRLP         ; Yes - Do string arrays
2908+ 25BF 7E                   ld      A,(HL)          ; Get type of variable
2909+ 25C0 23                   inc     HL
2910+ 25C1 23                   inc     HL
2911+ 25C2 B7                   or      A               ; "S" flag set if string
2912+ 25C3 CD FA 25             call    STRADD          ; See if string in string area
2913+ 25C6 C3 B4 25             jp      SMPVAR          ; Loop until simple ones done
2914+ 25C9
2915+ 25C9 C1           GNXARY: pop     BC              ; Scrap address of this array
2916+ 25CA EB           ARRLP:  ex      DE,HL
2917+ 25CB 2A 17 53             ld      HL,(ARREND)     ; End of string arrays
2918+ 25CE EB                   ex      DE,HL
2919+ 25CF CD 77 19             call    CPDEHL          ; All string arrays done?
2920+ 25D2 CA 20 26             jp      Z,SCNEND        ; Yes - Move string if found
2921+ 25D5 CD A3 2E             call    LOADFP          ; Get array name to BCDE
2922+ 25D8 7B                   ld      A,E             ; Get type of array
2923+ 25D9 E5                   push    HL              ; Save address of num of dim'ns
2924+ 25DA 09                   add     HL,BC           ; Start of next array
2925+ 25DB B7                   or      A               ; Test type of array
2926+ 25DC F2 C9 25             jp      P,GNXARY        ; Numeric array - Ignore it
2927+ 25DF 22 9B 52             ld      (CUROPR),HL     ; Save address of next array
2928+ 25E2 E1                   pop     HL              ; Get address of num of dim'ns
2929+ 25E3 4E                   ld      C,(HL)          ; BC = Number of dimensions
2930+ 25E4 06 00                ld      B,$00
2931+ 25E6 09                   add     HL,BC           ; Two bytes per dimension size
2932+ 25E7 09                   add     HL,BC
2933+ 25E8 23                   inc     HL              ; Plus one for number of dim'ns
2934+ 25E9 EB           GRBARY: ex      DE,HL
2935+ 25EA 2A 9B 52             ld      HL,(CUROPR)     ; Get address of next array
2936+ 25ED EB                   ex      DE,HL
2937+ 25EE CD 77 19             call    CPDEHL          ; Is this array finished?
2938+ 25F1 CA CA 25             jp      Z,ARRLP         ; Yes - Get next one
2939+ 25F4 01 E9 25             ld      BC,GRBARY       ; Loop until array all done
2940+ 25F7 C5           STPOOL: push    BC              ; Save return address
2941+ 25F8 F6 80                or      $80             ; Flag string type
2942+ 25FA 7E           STRADD: ld      A,(HL)          ; Get string length
2943+ 25FB 23                   inc     HL
2944+ 25FC 23                   inc     HL
2945+ 25FD 5E                   ld      E,(HL)          ; Get LSB of string address
2946+ 25FE 23                   inc     HL
2947+ 25FF 56                   ld      D,(HL)          ; Get MSB of string address
2948+ 2600 23                   inc     HL
2949+ 2601 F0                   ret     P               ; Not a string - Return
2950+ 2602 B7                   or      A               ; Set flags on string length
2951+ 2603 C8                   ret     Z               ; Null string - Return
2952+ 2604 44                   ld      B,H             ; Save variable pointer
2953+ 2605 4D                   ld      C,L
2954+ 2606 2A 99 52             ld      HL,(STRBOT)     ; Bottom of new area
2955+ 2609 CD 77 19             call    CPDEHL          ; String been done?
2956+ 260C 60                   ld      H,B             ; Restore variable pointer
2957+ 260D 69                   ld      L,C
2958+ 260E D8                   ret     C               ; String done - Ignore
2959+ 260F E1                   pop     HL              ; Return address
2960+ 2610 E3                   ex      (SP),HL         ; Lowest available string area
2961+ 2611 CD 77 19             call    CPDEHL          ; String within string area?
2962+ 2614 E3                   ex      (SP),HL         ; Lowest available string area
2963+ 2615 E5                   push    HL              ; Re-save return address
2964+ 2616 60                   ld      H,B             ; Restore variable pointer
2965+ 2617 69                   ld      L,C
2966+ 2618 D0                   ret     NC              ; Outside string area - Ignore
2967+ 2619 C1                   pop     BC              ; Get return , Throw 2 away
2968+ 261A F1                   pop     AF              ;
2969+ 261B F1                   pop     AF              ;
2970+ 261C E5                   push    HL              ; Save variable pointer
2971+ 261D D5                   push    DE              ; Save address of current
2972+ 261E C5                   push    BC              ; Put back return address
2973+ 261F C9                   ret                     ; Go to it
2974+ 2620
2975+ 2620 D1           SCNEND: pop     DE              ; Addresses of strings
2976+ 2621 E1                   pop     HL              ;
2977+ 2622 7D                   ld      A,L             ; HL = 0 if no more to do
2978+ 2623 B4                   or      H
2979+ 2624 C8                   ret     Z               ; No more to do - Return
2980+ 2625 2B                   dec     HL
2981+ 2626 46                   ld      B,(HL)          ; MSB of address of string
2982+ 2627 2B                   dec     HL
2983+ 2628 4E                   ld      C,(HL)          ; LSB of address of string
2984+ 2629 E5                   push    HL              ; Save variable address
2985+ 262A 2B                   dec     HL
2986+ 262B 2B                   dec     HL
2987+ 262C 6E                   ld      L,(HL)          ; HL = Length of string
2988+ 262D 26 00                ld      H,$00
2989+ 262F 09                   add     HL,BC           ; Address of end of string+1
2990+ 2630 50                   ld      D,B             ; String address to DE
2991+ 2631 59                   ld      E,C
2992+ 2632 2B                   dec     HL              ; Last byte in string
2993+ 2633 44                   ld      B,H             ; Address to BC
2994+ 2634 4D                   ld      C,L
2995+ 2635 2A 99 52             ld      HL,(STRBOT)     ; Current bottom of string area
2996+ 2638 CD 4A 16             call    MOVSTR          ; Move string to new address
2997+ 263B E1                   pop     HL              ; Restore variable address
2998+ 263C 71                   ld      (HL),C          ; Save new LSB of address
2999+ 263D 23                   inc     HL
3000+ 263E 70                   ld      (HL),B          ; Save new MSB of address
3001+ 263F 69                   ld      L,C             ; Next string area+1 to HL
3002+ 2640 60                   ld      H,B
3003+ 2641 2B                   dec     HL              ; Next string area address
3004+ 2642 C3 95 25             jp      GARBLP          ; Look for more strings
3005+ 2645
3006+ 2645 C5           CONCAT: push    BC              ; Save prec' opr & code string
3007+ 2646 E5                   push    HL              ;
3008+ 2647 2A 21 53             ld      HL,(FPREG)      ; Get first string
3009+ 264A E3                   ex      (SP),HL         ; Save first string
3010+ 264B CD D0 20             call    OPRND           ; Get second string
3011+ 264E E3                   ex      (SP),HL         ; Restore first string
3012+ 264F CD 4B 20             call    TSTSTR          ; Make sure it's a string
3013+ 2652 7E                   ld      A,(HL)          ; Get length of second string
3014+ 2653 E5                   push    HL              ; Save first string
3015+ 2654 2A 21 53             ld      HL,(FPREG)      ; Get second string
3016+ 2657 E5                   push    HL              ; Save second string
3017+ 2658 86                   add     A,(HL)          ; Add length of second string
3018+ 2659 1E 1C                ld      E,LS            ; ?LS Error
3019+ 265B DA AF 16             jp      C,ERROR         ; String too long - Error
3020+ 265E CD FE 24             call    MKTMST          ; Make temporary string
3021+ 2661 D1                   pop     DE              ; Get second string to DE
3022+ 2662 CD 96 26             call    GSTRDE          ; Move to string pool if needed
3023+ 2665 E3                   ex      (SP),HL         ; Get first string
3024+ 2666 CD 95 26             call    GSTRHL          ; Move to string pool if needed
3025+ 2669 E5                   push    HL              ; Save first string
3026+ 266A 2A 97 52             ld      HL,(TMPSTR+2)   ; Temporary string address
3027+ 266D EB                   ex      DE,HL           ; To DE
3028+ 266E CD 7C 26             call    SSTSA           ; First string to string area
3029+ 2671 CD 7C 26             call    SSTSA           ; Second string to string area
3030+ 2674 21 65 20             ld      HL,EVAL2        ; Return to evaluation loop
3031+ 2677 E3                   ex      (SP),HL         ; Save return,get code string
3032+ 2678 E5                   push    HL              ; Save code string address
3033+ 2679 C3 2F 25             jp      TSTOPL          ; To temporary string to pool
3034+ 267C
3035+ 267C E1           SSTSA:  pop     HL              ; Return address
3036+ 267D E3                   ex      (SP),HL         ; Get string block,save return
3037+ 267E 7E                   ld      A,(HL)          ; Get length of string
3038+ 267F 23                   inc     HL
3039+ 2680 23                   inc     HL
3040+ 2681 4E                   ld      C,(HL)          ; Get LSB of string address
3041+ 2682 23                   inc     HL
3042+ 2683 46                   ld      B,(HL)          ; Get MSB of string address
3043+ 2684 6F                   ld      L,A             ; Length to L
3044+ 2685 2C           TOSTRA: inc     L               ; inc - DECed after
3045+ 2686 2D           TSALP:  dec     L               ; Count bytes moved
3046+ 2687 C8                   ret     Z               ; End of string - Return
3047+ 2688 0A                   ld      A,(BC)          ; Get source
3048+ 2689 12                   ld      (DE),A          ; Save destination
3049+ 268A 03                   inc     BC              ; Next source
3050+ 268B 13                   inc     DE              ; Next destination
3051+ 268C C3 86 26             jp      TSALP           ; Loop until string moved
3052+ 268F
3053+ 268F CD 4B 20     GETSTR: call    TSTSTR          ; Make sure it's a string
3054+ 2692 2A 21 53     GSTRCU: ld      HL,(FPREG)      ; Get current string
3055+ 2695 EB           GSTRHL: ex      DE,HL           ; Save DE
3056+ 2696 CD B0 26     GSTRDE: call    BAKTMP          ; Was it last tmp-str?
3057+ 2699 EB                   ex      DE,HL           ; Restore DE
3058+ 269A C0                   ret     NZ              ; No - Return
3059+ 269B D5                   push    DE              ; Save string
3060+ 269C 50                   ld      D,B             ; String block address to DE
3061+ 269D 59                   ld      E,C
3062+ 269E 1B                   dec     DE              ; Point to length
3063+ 269F 4E                   ld      C,(HL)          ; Get string length
3064+ 26A0 2A 99 52             ld      HL,(STRBOT)     ; Current bottom of string area
3065+ 26A3 CD 77 19             call    CPDEHL          ; Last one in string area?
3066+ 26A6 C2 AE 26             jp      NZ,POPHL        ; No - Return
3067+ 26A9 47                   ld      B,A             ; Clear B (A=0)
3068+ 26AA 09                   add     HL,BC           ; Remove string from str' area
3069+ 26AB 22 99 52             ld      (STRBOT),HL     ; Save new bottom of str' area
3070+ 26AE E1           POPHL:  pop     HL              ; Restore string
3071+ 26AF C9                   ret
3072+ 26B0
3073+ 26B0 2A 87 52     BAKTMP: ld      HL,(TMSTPT)     ; Get temporary string pool top
3074+ 26B3 2B                   dec     HL              ; Back
3075+ 26B4 46                   ld      B,(HL)          ; Get MSB of address
3076+ 26B5 2B                   dec     HL              ; Back
3077+ 26B6 4E                   ld      C,(HL)          ; Get LSB of address
3078+ 26B7 2B                   dec     HL              ; Back
3079+ 26B8 2B                   dec     HL              ; Back
3080+ 26B9 CD 77 19             call    CPDEHL          ; String last in string pool?
3081+ 26BC C0                   ret     NZ              ; Yes - Leave it
3082+ 26BD 22 87 52             ld      (TMSTPT),HL     ; Save new string pool top
3083+ 26C0 C9                   ret
3084+ 26C1
3085+ 26C1 01 40 24     LEN:    ld      BC,PASSA        ; To return integer A
3086+ 26C4 C5                   push    BC              ; Save address
3087+ 26C5 CD 8F 26     GETLEN: call    GETSTR          ; Get string and its length
3088+ 26C8 AF                   xor     A
3089+ 26C9 57                   ld      D,A             ; Clear D
3090+ 26CA 32 83 52             ld      (TYPE),A        ; Set type to numeric
3091+ 26CD 7E                   ld      A,(HL)          ; Get length of string
3092+ 26CE B7                   or      A               ; Set status flags
3093+ 26CF C9                   ret
3094+ 26D0
3095+ 26D0 01 40 24     ASC:    ld      BC,PASSA        ; To return integer A
3096+ 26D3 C5                   push    BC              ; Save address
3097+ 26D4 CD C5 26     GTFLNM: call    GETLEN          ; Get length of string
3098+ 26D7 CA 89 1C             jp      Z,FCERR         ; Null string - Error
3099+ 26DA 23                   inc     HL
3100+ 26DB 23                   inc     HL
3101+ 26DC 5E                   ld      E,(HL)          ; Get LSB of address
3102+ 26DD 23                   inc     HL
3103+ 26DE 56                   ld      D,(HL)          ; Get MSB of address
3104+ 26DF 1A                   ld      A,(DE)          ; Get first byte of string
3105+ 26E0 C9                   ret
3106+ 26E1
3107+ 26E1 3E 01        CHR:    ld      A,$01           ; One character string
3108+ 26E3 CD FE 24             call    MKTMST          ; Make a temporary string
3109+ 26E6 CD D0 28             call    MAKINT          ; Make it integer A
3110+ 26E9 2A 97 52             ld      HL,(TMPSTR+2)   ; Get address of string
3111+ 26EC 73                   ld      (HL),E          ; Save character
3112+ 26ED C1           TOPOOL: pop     BC              ; Clean up stack
3113+ 26EE C3 2F 25             jp      TSTOPL          ; Temporary string to pool
3114+ 26F1
3115+ 26F1 CD 80 28     LEFT:   call    LFRGNM          ; Get number and ending ")"
3116+ 26F4 AF                   xor     A               ; Start at first byte in string
3117+ 26F5 E3           RIGHT1: ex      (SP),HL         ; Save code string,Get string
3118+ 26F6 4F                   ld      C,A             ; Starting position in string
3119+ 26F7 E5           MID1:   push    HL              ; Save string block address
3120+ 26F8 7E                   ld      A,(HL)          ; Get length of string
3121+ 26F9 B8                   cp      B               ; Compare with number given
3122+ 26FA DA FF 26             jp      C,ALLFOL        ; All following bytes required
3123+ 26FD 78                   ld      A,B             ; Get new length
3124+ 26FE 11                   defb    $11             ; Skip "ld C,0"
3125+ 26FF 0E 00        ALLFOL: ld      C,$00           ; First byte of string
3126+ 2701 C5                   push    BC              ; Save position in string
3127+ 2702 CD 68 25             call    TESTR           ; See if enough string space
3128+ 2705 C1                   pop     BC              ; Get position in string
3129+ 2706 E1                   pop     HL              ; Restore string block address
3130+ 2707 E5                   push    HL              ; And re-save it
3131+ 2708 23                   inc     HL
3132+ 2709 23                   inc     HL
3133+ 270A 46                   ld      B,(HL)          ; Get LSB of address
3134+ 270B 23                   inc     HL
3135+ 270C 66                   ld      H,(HL)          ; Get MSB of address
3136+ 270D 68                   ld      L,B             ; HL = address of string
3137+ 270E 06 00                ld      B,$00           ; BC = starting address
3138+ 2710 09                   add     HL,BC           ; Point to that byte
3139+ 2711 44                   ld      B,H             ; BC = source string
3140+ 2712 4D                   ld      C,L
3141+ 2713 CD 01 25             call    CRTMST          ; Create a string entry
3142+ 2716 6F                   ld      L,A             ; Length of new string
3143+ 2717 CD 85 26             call    TOSTRA          ; Move string to string area
3144+ 271A D1                   pop     DE              ; Clear stack
3145+ 271B CD 96 26             call    GSTRDE          ; Move to string pool if needed
3146+ 271E C3 2F 25             jp      TSTOPL          ; Temporary string to pool
3147+ 2721
3148+ 2721
3149+ 2721              ; INSTR statement - look for a string inside another string
3150+ 2721              ; usage: INSTR(A$,B$) -> search for B$ into A$
3151+ 2721              ; return 0 if B$ is not found into A$, or LEN(A$)<LEN(B$)
3152+ 2721              ; return 1~255 to indicate the starting position of B$ into A$
3153+ 2721              ; ex.: INSTR("HELLO","LO") returns 4 - INSTR("HOME","PC") returns 0
3154+ 2721              LNS1    equ     TMPBFR1
3155+ 2721              ADRS1   equ     TMPBFR2
3156+ 2721              LNS2    equ     TMPBFR3
3157+ 2721              ADRS2   equ     TMPBFR4
3158+ 2721              PT      equ     VIDEOBUFF
3159+ 2721              PT1     equ     VIDEOBUFF+2
3160+ 2721              PT2     equ     VIDEOBUFF+4
3161+ 2721              TP      equ     VIDEOBUFF+6
3162+ 2721              TF      equ     VIDEOBUFF+8
3163+ 2721 CD 7D 19     INSTR:  call    CHKSYN          ; make sure "(" follows
3164+ 2724 28                   defb    '('
3165+ 2725 2B                   dec     HL              ; dec 'cause GETCHR increments
3166+ 2726 CD BE 1B             call    GETCHR          ; check if something follows
3167+ 2729 CA 9B 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
3168+ 272C CD 59 20             call    EVAL            ; Evaluate expression
3169+ 272F CD 4B 20             call    TSTSTR          ; Make sure it's a string
3170+ 2732 22 D5 52             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3171+ 2735 CD 92 26             call    GSTRCU          ; check that a string follows
3172+ 2738 CD A3 2E             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3173+ 273B ED 53 CD 52          ld      (LNS1),DE       ; store values into
3174+ 273F ED 43 CF 52          ld      (ADRS1),BC      ; temp buffers
3175+ 2743 2A D5 52             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3176+ 2746 CD 7D 19             call    CHKSYN          ; Make sure ',' follows
3177+ 2749 2C                   defb    ','
3178+ 274A 2B                   dec     HL              ; dec 'cause GETCHR increments
3179+ 274B CD BE 1B             call    GETCHR          ; check if something follows
3180+ 274E CA 9B 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
3181+ 2751 CD 59 20             call    EVAL            ; Evaluate expression
3182+ 2754 CD 4B 20             call    TSTSTR          ; Make sure it's a string
3183+ 2757 22 D5 52             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3184+ 275A CD 92 26             call    GSTRCU          ; check that a string follows
3185+ 275D CD A3 2E             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3186+ 2760 ED 53 D1 52          ld      (LNS2),DE       ; store values into
3187+ 2764 ED 43 D3 52          ld      (ADRS2),BC      ; temp buffers
3188+ 2768 2A D5 52             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3189+ 276B CD 7D 19             call    CHKSYN          ; make sure ")" follows
3190+ 276E 29                   defb    ')'
3191+ 276F E5                   push    HL              ; store current code string pointer (the point after the ")" ) ...
3192+ 2770 FD E1                pop     IY              ; ...into IY
3193+ 2772 AF                   xor     A               ; reset 10 RAM cells
3194+ 2773 06 0A                ld      B,$0A           ; (INSTR registers)
3195+ 2775 21 D5 52             ld      HL,PT           ; first cell
3196+ 2778 77           EMPTINS:ld      (HL),A          ; reset cell
3197+ 2779 23                   inc     HL              ; next cell
3198+ 277A 10 FC                djnz    EMPTINS         ; repeat
3199+ 277C ED 5B D1 52          ld      DE,(LNS2)       ; load len(S2) into DE
3200+ 2780 2A CD 52             ld      HL,(LNS1)       ; load len(S1) into HL
3201+ 2783 CD 88 3F             call    CMP16           ; check that len(S1)>=len(S2)
3202+ 2786 DA FB 27             jp      C,RZINSTR       ; if len(S2)>len(S1) then return 0
3203+ 2789 AF           RPTINST:xor     A               ; reset...
3204+ 278A 32 DB 52             ld      (TP),A          ; ...TP...
3205+ 278D 32 DD 52             ld      (TF),A          ; ...and TF
3206+ 2790 ED 4B D5 52          ld      BC,(PT)         ; pointer to S1
3207+ 2794 2A CF 52             ld      HL,(ADRS1)      ; first cell of S1
3208+ 2797 09                   add     HL,BC           ; get current position into RAM
3209+ 2798 7E                   ld      A,(HL)          ; load S1(PT)
3210+ 2799 2A D3 52             ld      HL,(ADRS2)      ; pointer to first char of S2
3211+ 279C BE                   cp      (HL)            ; is S1(PT)=S2(0)?
3212+ 279D 20 3A                jr      NZ,CNT1INS      ; no, continue
3213+ 279F 3A D5 52             ld      A,(PT)          ; load current PT
3214+ 27A2 32 DB 52             ld      (TP),A          ; TP=PT
3215+ 27A5 32 D7 52             ld      (PT1),A         ; P1=PT
3216+ 27A8 AF                   xor     A               ; set...
3217+ 27A9 32 D9 52             ld      (PT2),A         ; ...PT2=0
3218+ 27AC 3C                   inc     A               ;
3219+ 27AD 32 DD 52             ld      (TF),A          ; set TF=1
3220+ 27B0 ED 4B D7 52  RP2INST:ld      BC,(PT1)        ; load pointer PT1
3221+ 27B4 2A CF 52             ld      HL,(ADRS1)      ; load address of S1
3222+ 27B7 09                   add     HL,BC           ; find char of S1 pointed by PT1
3223+ 27B8 7E                   ld      A,(HL)          ; load S1(PT1)
3224+ 27B9 ED 4B D9 52          ld      BC,(PT2)        ; load pointer PT2
3225+ 27BD 2A D3 52             ld      HL,(ADRS2)      ; load char of S2 pointed by PT2
3226+ 27C0 09                   add     HL,BC           ; find S2(PT2)
3227+ 27C1 BE                   cp      (HL)            ; is S1(PT1)=S2(PT2)?
3228+ 27C2 20 4C                jr      NZ,CNTZIN       ; no, exit inner loop
3229+ 27C4 21 D7 52             ld      HL,PT1
3230+ 27C7 34                   inc     (HL)            ; increment PT1
3231+ 27C8 3A D9 52             ld      A,(PT2)
3232+ 27CB 3C                   inc     A               ; increment PT2
3233+ 27CC 32 D9 52             ld      (PT2),A
3234+ 27CF CA D9 27             jp      Z,CNT1INS       ; if PT2>255 then exit
3235+ 27D2 21 D1 52             ld      HL,LNS2         ; len(S2)
3236+ 27D5 BE                   cp      (HL)            ; PT2=len(S2)?
3237+ 27D6 DA B0 27             jp      C,RP2INST       ; no (PT2<len(S2) - repeat
3238+ 27D9 3A DD 52     CNT1INS:ld      A,(TF)          ; check TF
3239+ 27DC A7                   and     A               ; TF=0? (clears also Carry for next SBC)
3240+ 27DD 20 1C                jr      NZ,RZINSTR      ; no, exit
3241+ 27DF 2A CD 52             ld      HL,(LNS1)       ; load len(S1)
3242+ 27E2 ED 4B D1 52          ld      BC,(LNS2)       ; load len(S2)
3243+ 27E6 ED 42                sbc     HL,BC           ; HL=len(S1)-len(S2)
3244+ 27E8 ED 5B D5 52          ld      DE,(PT)         ; load pointer
3245+ 27EC 1C                   inc     E               ; PT=PT+1
3246+ 27ED ED 53 D5 52          ld      (PT),DE         ; store new value
3247+ 27F1 EB                   ex      DE,HL           ; invert registers
3248+ 27F2 CD 88 3F             call    CMP16           ; check if PT>len(S1)-len(S2)
3249+ 27F5 DA 89 27             jp      C,RPTINST       ; repeat if <
3250+ 27F8 CA 89 27             jp      Z,RPTINST       ; repeat if =
3251+ 27FB 3A DD 52     RZINSTR:ld      A,(TF)          ; current value of TF
3252+ 27FE A7                   and     A               ; is it 0?
3253+ 27FF CA 06 28             jp      Z,LVINSTR       ; yes, return 0
3254+ 2802 3A DB 52             ld      A,(TP)          ; return TP...
3255+ 2805 3C                   inc     A               ; ...incremented by 1
3256+ 2806 E1           LVINSTR:pop     HL              ; drop original return point
3257+ 2807 FD E5                push    IY              ; load current string address from IY into stack
3258+ 2809 11 32 21             ld      DE,RETNUM       ; Address of Return number from function...
3259+ 280C D5                   push    DE              ; ...saved on stack
3260+ 280D C3 40 24             jp      PASSA           ; return TP
3261+ 2810 AF           CNTZIN: xor     A               ; set...
3262+ 2811 32 DD 52             ld      (TF),A          ; TF=0
3263+ 2814 C3 D9 27             jp      CNT1INS         ; continue
3264+ 2817
3265+ 2817
3266+ 2817              ; returns the right portion of a string
3267+ 2817 CD 80 28     RIGHT:  call    LFRGNM          ; Get number and ending ")"
3268+ 281A D1                   pop     DE              ; Get string length
3269+ 281B D5                   push    DE              ; And re-save
3270+ 281C 1A                   ld      A,(DE)          ; Get length
3271+ 281D 90                   sub     B               ; Move back N bytes
3272+ 281E C3 F5 26             jp      RIGHT1          ; Go and get sub-string
3273+ 2821
3274+ 2821              ; returns a piece of a string
3275+ 2821 EB           MID:    ex      DE,HL           ; Get code string address
3276+ 2822 7E                   ld      A,(HL)          ; Get next byte ',' or ")"
3277+ 2823 CD 85 28             call    MIDNUM          ; Get number supplied
3278+ 2826 04                   inc     B               ; Is it character zero?
3279+ 2827 05                   dec     B
3280+ 2828 CA 89 1C             jp      Z,FCERR         ; Yes - Error
3281+ 282B C5                   push    BC              ; Save starting position
3282+ 282C 1E FF                ld      E,$FF           ; All of string
3283+ 282E FE 29                cp      ')'             ; Any length given?
3284+ 2830 CA 3A 28             jp      Z,RSTSTR        ; No - Rest of string
3285+ 2833 CD 7D 19             call    CHKSYN          ; Make sure ',' follows
3286+ 2836 2C                   defb    ','
3287+ 2837 CD CD 28             call    GETINT          ; Get integer 0-255
3288+ 283A CD 7D 19     RSTSTR: call    CHKSYN          ; Make sure ")" follows
3289+ 283D 29                   defb    ')'
3290+ 283E F1                   pop     AF              ; Restore starting position
3291+ 283F E3                   ex      (SP),HL         ; Get string,save code string
3292+ 2840 01 F7 26             ld      BC,MID1         ; Continuation of MID$ routine
3293+ 2843 C5                   push    BC              ; Save for return
3294+ 2844 3D                   dec     A               ; Starting position-1
3295+ 2845 BE                   cp      (HL)            ; Compare with length
3296+ 2846 06 00                ld      B,$00           ; Zero bytes length
3297+ 2848 D0                   ret     NC              ; Null string if start past end
3298+ 2849 4F                   ld      C,A             ; Save starting position-1
3299+ 284A 7E                   ld      A,(HL)          ; Get length of string
3300+ 284B 91                   sub     C               ; Subtract start
3301+ 284C BB                   cp      E               ; Enough string for it?
3302+ 284D 47                   ld      B,A             ; Save maximum length available
3303+ 284E D8                   ret     C               ; Truncate string if needed
3304+ 284F 43                   ld      B,E             ; Set specified length
3305+ 2850 C9                   ret                     ; Go and create string
3306+ 2851
3307+ 2851
3308+ 2851              ; return the value of a numeric string
3309+ 2851 CD C5 26     VAL:    call    GETLEN          ; Get length of string
3310+ 2854 CA 23 2C             jp      Z,RESZER        ; Result zero
3311+ 2857 5F                   ld      E,A             ; Save length
3312+ 2858 23                   inc     HL
3313+ 2859 23                   inc     HL
3314+ 285A 7E                   ld      A,(HL)          ; Get LSB of address
3315+ 285B 23                   inc     HL
3316+ 285C 66                   ld      H,(HL)          ; Get MSB of address
3317+ 285D 6F                   ld      L,A             ; HL = String address
3318+ 285E E5                   push    HL              ; Save string address
3319+ 285F 19                   add     HL,DE
3320+ 2860 46                   ld      B,(HL)          ; Get end of string+1 byte
3321+ 2861 72                   ld      (HL),D          ; Zero it to terminate
3322+ 2862 E3                   ex      (SP),HL         ; Save string end,get start
3323+ 2863 C5                   push    BC              ; Save end+1 byte
3324+ 2864 7E                   ld      A,(HL)          ; Get starting byte
3325+ 2865 FE 24                cp      '$'             ; Hex number indicated? [function added]
3326+ 2867 C2 6F 28             jp      NZ,VAL1
3327+ 286A CD C1 3E             call    HEXTFP          ; Convert Hex to FPREG
3328+ 286D 18 0D                jr      VAL3
3329+ 286F FE 25        VAL1:   cp      '%'             ; Binary number indicated? [function added]
3330+ 2871 C2 79 28             jp      NZ,VAL2
3331+ 2874 CD 31 3F             call    BINTFP          ; Convert Bin to FPREG
3332+ 2877 18 03                jr      VAL3
3333+ 2879 CD 5B 2F     VAL2:   call    ASCTFP          ; Convert ASCII string to FP
3334+ 287C C1           VAL3:   pop     BC              ; Restore end+1 byte
3335+ 287D E1                   pop     HL              ; Restore end+1 address
3336+ 287E 70                   ld      (HL),B          ; Put back original byte
3337+ 287F C9                   ret
3338+ 2880
3339+ 2880 EB           LFRGNM: ex      DE,HL           ; Code string address to HL
3340+ 2881 CD 7D 19             call    CHKSYN          ; Make sure ")" follows
3341+ 2884 29                   defb    ')'
3342+ 2885 C1           MIDNUM: pop     BC              ; Get return address
3343+ 2886 D1                   pop     DE              ; Get number supplied
3344+ 2887 C5                   push    BC              ; Re-save return address
3345+ 2888 43                   ld      B,E             ; Number to B
3346+ 2889 C9                   ret
3347+ 288A
3348+ 288A CD D0 28     INP:    call    MAKINT          ; Make it integer A
3349+ 288D 32 8F 51             ld      (INPORT),A      ; Set input port
3350+ 2890 CD 8E 51             call    INPSUB          ; Get input from port
3351+ 2893 C3 40 24             jp      PASSA           ; Return integer A
3352+ 2896
3353+ 2896 CD BA 28     POUT:   call    SETIO           ; Set up port number
3354+ 2899 C3 56 51             jp      OUTSUB          ; Output data and return
3355+ 289C
3356+ 289C CD BA 28     WAIT:   call    SETIO           ; Set up port number
3357+ 289F F5                   push    AF              ; Save AND mask
3358+ 28A0 1E 00                ld      E,$00           ; Assume zero if none given
3359+ 28A2 2B                   dec     HL              ; dec 'cos GETCHR INCs
3360+ 28A3 CD BE 1B             call    GETCHR          ; Get next character
3361+ 28A6 CA B0 28             jp      Z,NOXOR         ; No XOR byte given
3362+ 28A9 CD 7D 19             call    CHKSYN          ; Make sure ',' follows
3363+ 28AC 2C                   defb    ','
3364+ 28AD CD CD 28             call    GETINT          ; Get integer 0-255 to XOR with
3365+ 28B0 C1           NOXOR:  pop     BC              ; Restore AND mask
3366+ 28B1 CD 8E 51     WAITLP: call    INPSUB          ; Get input
3367+ 28B4 AB                   xor     E               ; Flip selected bits
3368+ 28B5 A0                   and     B               ; Result non-zero?
3369+ 28B6 CA B1 28             jp      Z,WAITLP        ; No = keep waiting
3370+ 28B9 C9                   ret
3371+ 28BA
3372+ 28BA CD CD 28     SETIO:  call    GETINT          ; Get integer 0-255
3373+ 28BD 32 8F 51             ld      (INPORT),A      ; Set input port
3374+ 28C0 32 57 51             ld      (OTPORT),A      ; Set output port
3375+ 28C3 CD 7D 19             call    CHKSYN          ; Make sure ',' follows
3376+ 28C6 2C                   defb    ','
3377+ 28C7 C3 CD 28             jp      GETINT          ; Get integer 0-255 and return
3378+ 28CA
3379+ 28CA CD BE 1B     FNDNUM: call    GETCHR          ; Get next character
3380+ 28CD CD 47 20     GETINT: call    GETNUM          ; Get a number from 0 to 255
3381+ 28D0 CD 6E 1C     MAKINT: call    DEPINT          ; Make sure value 0 - 255
3382+ 28D3 7A                   ld      A,D             ; Get MSB of number
3383+ 28D4 B7                   or      A               ; Zero?
3384+ 28D5 C2 89 1C             jp      NZ,FCERR        ; No - Error
3385+ 28D8 2B                   dec     HL              ; dec 'cos GETCHR INCs
3386+ 28D9 CD BE 1B             call    GETCHR          ; Get next character
3387+ 28DC 7B                   ld      A,E             ; Get number to A
3388+ 28DD C9                   ret
3389+ 28DE
3390+ 28DE
3391+ 28DE              ; activate a Non-Maskable Interrupt hooked to VDP interrupt signal
3392+ 28DE              ; address must point to an ISR routine that terminates with EI/RETN instructions
3393+ 28DE CD 47 20     NMI:    call    GETNUM          ; Get memory address
3394+ 28E1 CD 74 1C             call    DEINT           ; get integer -32768 to 32767
3395+ 28E4 7B                   ld      A,E             ; check if address is 0
3396+ 28E5 B2                   or      D
3397+ 28E6 20 11                jr      NZ,NM1          ; no, so jump over
3398+ 28E8 F3           DISNMI: di                      ; disable INTs
3399+ 28E9 CD 15 29             call    NMIDINT         ; disable VDP INT
3400+ 28EC E5                   push    HL              ; store HL
3401+ 28ED 21 ED 45             ld      HL,$45ED        ; these are the op-codes for "RETN"
3402+ 28F0 22 50 51             ld      (NMIUSR),HL     ; store RETN
3403+ 28F3 AF                   xor     A
3404+ 28F4 32 52 51             ld      (NMIUSR+2),A    ; "NOP"
3405+ 28F7 18 11                jr      NMI2            ; execute the last part of code
3406+ 28F9 E5           NM1:    push    HL              ; store current HL
3407+ 28FA EB                   ex      DE,HL           ; move address argument into HL
3408+ 28FB F3                   di                      ; disable INTs
3409+ 28FC CD 15 29             call    NMIDINT         ; disable VDP INT, if enabled
3410+ 28FF 3E C3                ld      A,$C3           ; "jp" instruction
3411+ 2901 32 50 51             ld      (NMIUSR),A      ; store it
3412+ 2904 22 51 51             ld      (NMIUSR+1),HL   ; store address
3413+ 2907 CD 0E 29             call    NMIEINT         ; re-enable VDP INT
3414+ 290A FB           NMI2:   ei                      ; re-enable INTS
3415+ 290B 00                   nop                     ; wait for INTs
3416+ 290C E1                   pop    HL               ; retrieve HL
3417+ 290D C9                   ret                     ; return to caller
3418+ 290E              ; enable VDP INT
3419+ 290E CD 24 29     NMIEINT:call    NMIVR1          ; load default VReg #1 setting
3420+ 2911 F6 20                or      %00100000       ; enable VDP INT
3421+ 2913 18 03                jr      NMIINT          ; rest of code is shared
3422+ 2915              ; disable VDP INT
3423+ 2915 CD 24 29     NMIDINT:call    NMIVR1          ; load default VReg #1 setting
3424+ 2918 D5           NMIINT: push    DE              ; store DE
3425+ 2919 5F                   ld      E,A             ; move value into E
3426+ 291A 3E 01                ld      A,$01           ; VREG #1
3427+ 291C F3                   di                      ; disable INTs
3428+ 291D CD A7 06             call    WRITE_VREG      ; disable VDP INT
3429+ 2920 FB                   ei                      ; re-enable INTs
3430+ 2921 00                   nop                     ; wait for INTs being enabled
3431+ 2922 D1                   pop     DE              ; retrieve DE
3432+ 2923 C9                   ret                     ; return to caller
3433+ 2924
3434+ 2924              ; load VREG #1 setting for current screen mode and return it into A
3435+ 2924 E5           NMIVR1: push    HL              ; store HL
3436+ 2925 D5                   push    DE              ; store DE
3437+ 2926 3A BE 52             ld      A,(SCR_MODE)    ; check screen mode
3438+ 2929 87                   add     A,A             ; multiply A by 8...
3439+ 292A 87                   add     A,A             ; ...so that reg. A can points..
3440+ 292B 87                   add     A,A             ; to the correct settings
3441+ 292C 3C                   inc     A               ; need to change VREG 1
3442+ 292D 5F                   ld      E,A             ; copy A into E
3443+ 292E 16 00                ld      D,$00           ; reset D
3444+ 2930 21 E5 0A             ld      HL,VDPMODESET   ; pointer to register #1 setting...
3445+ 2933 19                   add     HL,DE           ; ...for current screen mode
3446+ 2934 7E                   ld      A,(HL)          ; load current setting
3447+ 2935 D1                   pop     DE              ; retrieve DE
3448+ 2936 E1                   pop     HL              ; retrieve HL
3449+ 2937 C9                   ret                     ; return to caller
3450+ 2938
3451+ 2938              ; execute a machine language routine, eventually passing a param into A
3452+ 2938 CD 47 20     SYS:    call    GETNUM          ; Get memory address
3453+ 293B CD 74 1C             call    DEINT           ; Get integer -32768 to 32767
3454+ 293E ED 53 CF 52          ld      (TMPBFR2),DE    ; store user routine's address
3455+ 2942 AF                   xor     A               ; reset A
3456+ 2943 32 CD 52             ld      (TMPBFR1),A     ; store into temp buffer
3457+ 2946 2B                   dec     HL              ; dec 'cos GETCHR INCs
3458+ 2947 CD BE 1B             call    GETCHR          ; check next character
3459+ 294A 28 0A                jr      Z,NOSYSPR       ; jump if nothing follows
3460+ 294C CD 7D 19             call    CHKSYN          ; Make sure ',' follows
3461+ 294F 2C                   defb    ','
3462+ 2950 CD CD 28             call    GETINT          ; get byte value (0~255) if something follows
3463+ 2953 32 CD 52             ld      (TMPBFR1),A     ; store into temp buffer
3464+ 2956 3A CD 52     NOSYSPR:ld      A,(TMPBFR1)     ; recover A
3465+ 2959 ED 5B CF 52          ld      DE,(TMPBFR2)    ; recover user routine's address
3466+ 295D E5                   push    HL              ; save code string address
3467+ 295E EB                   ex      DE,HL           ; move user routine's address into HL
3468+ 295F 11 64 29             ld      DE,SYSRET       ; set point of return after the user routine
3469+ 2962 D5                   push    DE              ; store into stack
3470+ 2963 E9                   jp      (HL)            ; call user routine
3471+ 2964 E1           SYSRET: pop     HL              ; retrieve code string address
3472+ 2965 C9                   ret                     ; return to caller
3473+ 2966
3474+ 2966
3475+ 2966              ; read the contents of a RAM location
3476+ 2966 CD 74 1C     PEEK:   call    DEINT           ; Get memory address into DE
3477+ 2969 1A                   ld      A,(DE)          ; Read value of memory cell
3478+ 296A C3 40 24             jp      PASSA           ; Return into A
3479+ 296D
3480+ 296D              ; read the contents of a VRAM location
3481+ 296D CD 74 1C     VPEEK:  call    DEINT           ; Get VRAM address into DE
3482+ 2970 EB                   ex      DE,HL           ; Copy param into HL
3483+ 2971 F3                   di                      ; Disable interrupts
3484+ 2972 CD 7D 06             call    READ_VIDEO_LOC  ; Read data from VRAM at address HL
3485+ 2975 FB                   ei                      ; Re-enable interrupts
3486+ 2976 EB                   ex      DE,HL           ; Restore HL
3487+ 2977 C3 40 24             jp      PASSA           ; Return value into A
3488+ 297A
3489+ 297A              ; recover params for POKE/VPOKE commands
3490+ 297A              ; returns address into DE and byte to be written into A
3491+ 297A CD 47 20     PKEPRMS:call    GETNUM          ; Get memory address
3492+ 297D CD 74 1C             call    DEINT           ; Get integer -32768 to 32767
3493+ 2980 ED 53 CD 52          ld      (TMPBFR1),DE    ; Store DE into a temp. buffer
3494+ 2984 CD 7D 19             call    CHKSYN          ; Make sure ',' follows
3495+ 2987 2C                   defb    ','
3496+ 2988 CD CD 28             call    GETINT          ; Get integer 0-255
3497+ 298B ED 5B CD 52          ld      DE,(TMPBFR1)    ; Restore memory address
3498+ 298F C9                   ret                     ; Return to caller
3499+ 2990
3500+ 2990              ; write a byte into a RAM location
3501+ 2990 CD 7A 29     POKE:   call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3502+ 2993 12                   ld      (DE),A          ; Load it into memory
3503+ 2994 C9                   ret
3504+ 2995
3505+ 2995              ; write a byte into a VRAM location
3506+ 2995 CD 7A 29     VPOKE:  call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3507+ 2998 EB                   ex      DE,HL           ; Copy address into HL
3508+ 2999 F3                   di                      ; Disable interrupts
3509+ 299A CD 92 06             call    WRITE_VIDEO_LOC ; write data into VRAM at address HL
3510+ 299D FB                   ei                      ; Re-enable interrupts
3511+ 299E EB                   ex      DE,HL           ; Restore HL
3512+ 299F C9                   ret                     ; Return to caller
3513+ 29A0
3514+ 29A0              ; position the cursor at a specific X,Y location onto screen
3515+ 29A0 CD CD 28     LOCATE: call    GETINT          ; get the first param into A
3516+ 29A3 E5                   push    HL              ; store HL
3517+ 29A4 21 BC 52             ld      HL,SCR_SIZE_W   ; load address of screen width
3518+ 29A7 5E                   ld      E,(HL)          ; load screen width into E
3519+ 29A8 E1                   pop     HL              ; restore HL
3520+ 29A9 BB                   cp      E               ; compare witdh with param
3521+ 29AA D2 89 1C             jp      NC,FCERR        ; value over the width of the screen, exit with Illegal F.C. error
3522+ 29AD 32 CD 52             ld      (TMPBFR1),A     ; Store X into a temp. buffer
3523+ 29B0 CD 7D 19             call    CHKSYN          ; Make sure ',' follows
3524+ 29B3 2C                   defb    ','
3525+ 29B4 CD CD 28             call    GETINT          ; Get the second param into A
3526+ 29B7 E5                   push    HL              ; store HL
3527+ 29B8 21 BD 52             ld      HL,SCR_SIZE_H   ; load address of screen width
3528+ 29BB 5E                   ld      E,(HL)          ; load screen width into A
3529+ 29BC E1                   pop     HL              ; restore HL
3530+ 29BD BB                   cp      E               ; compare witdh with param
3531+ 29BE D2 89 1C             jp      NC,FCERR        ; value over the height of the screen, exit with Illegal F.C. error
3532+ 29C1 32 C5 52             ld      (SCR_CUR_NY),A  ; store new Y
3533+ 29C4 3A CD 52             ld      A,(TMPBFR1)     ; recover the new X
3534+ 29C7 32 C4 52             ld      (SCR_CUR_NX),A  ; store new X
3535+ 29CA E5                   push    HL              ; store HL
3536+ 29CB F3                   di                      ; disable INTs
3537+ 29CC CD C3 06             call    MOVCRS          ; move cursor to new location
3538+ 29CF FB                   ei                      ; re-enable INTs
3539+ 29D0 E1                   pop     HL              ; restore HL
3540+ 29D1 C9                   ret                     ; return to caller
3541+ 29D2
3542+ 29D2              ; write a byte into one of the PSG registers
3543+ 29D2 CD CD 28     SREG:   call    GETINT          ; Get register number back into A
3544+ 29D5 FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3545+ 29D7 D2 89 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3546+ 29DA 32 CD 52             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3547+ 29DD CD 7D 19             call    CHKSYN          ; Make sure ',' follows
3548+ 29E0 2C                   defb    ','
3549+ 29E1 CD CD 28             call    GETINT          ; get second value (0-255), returned into A
3550+ 29E4 5F                   ld      E,A             ; store value into E
3551+ 29E5 3A CD 52             ld      A,(TMPBFR1)     ; recover VDP register and store into D
3552+ 29E8 F3                   di                      ; disable INTs
3553+ 29E9 0E 40                ld      C,PSG_REG       ; output port to access PSG registers
3554+ 29EB ED 79                out     (C),A           ; send register # to PSG
3555+ 29ED 0E 41                ld      C,PSG_DAT       ; output port to send data to PSG
3556+ 29EF ED 59                out     (C),E           ; send byte to write into selected register
3557+ 29F1 FB                   ei                      ; re-enable INTs
3558+ 29F2 C9                   ret                     ; return to caller
3559+ 29F3
3560+ 29F3              ; VOLUME ch,vol
3561+ 29F3              ; set the volume for the audio channels
3562+ 29F3              ; "ch" is 1~3 for corresponding channel, or 0 for all; "vol" is 0~15 (0=OFF, 15=MAX)
3563+ 29F3 CD CD 28     VOLUME: call    GETINT          ; get integer 0-255 (recover channel)
3564+ 29F6 FE 04                cp      $04             ; check if it's in the range 0~3
3565+ 29F8 D2 89 1C             jp      NC,FCERR        ; if not, exit with Illegal function call error
3566+ 29FB 32 CD 52             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3567+ 29FE CD 7D 19             call    CHKSYN          ; Make sure ',' follows
3568+ 2A01 2C                   defb    ','
3569+ 2A02 CD CD 28             call    GETINT          ; get integer 0-255 (recover channel)
3570+ 2A05 FE 10                cp      $10             ; check if it's in the range 0~15
3571+ 2A07 D2 89 1C             jp      NC,FCERR        ; if not, exit with Illegal funcion call
3572+ 2A0A 57                   ld      D,A             ; store volume into D
3573+ 2A0B 3A CD 52             ld      A,(TMPBFR1)     ; retrieve channel
3574+ 2A0E A7                   and     A               ; is it 0? (0=every channel)
3575+ 2A0F 20 10                jr      NZ,VOLCH        ; no, jump over
3576+ 2A11 06 03                ld      B,$03           ; yes, set every channel
3577+ 2A13 1E 08                ld      E,$08           ; register volume of first channel
3578+ 2A15 0E 40        RPVOLCG:ld      C,PSG_REG       ; PSG register port
3579+ 2A17 ED 59                out     (C),E           ; set register #
3580+ 2A19 0E 41                ld      C,PSG_DAT       ; PSG data port
3581+ 2A1B ED 51                out     (C),D           ; send volume
3582+ 2A1D 1C                   inc     E               ; next register
3583+ 2A1E 10 F5                djnz    RPVOLCG         ; repeat for each channel
3584+ 2A20 C9                   ret                     ; return to caller
3585+ 2A21 0E 40        VOLCH:  ld      C,PSG_REG       ; PSG register port
3586+ 2A23 C6 07                add     $07             ; add 7 to A so that we have the correct register (1->8, 2->9, 3->10)
3587+ 2A25 ED 79                out     (C),A           ; set register
3588+ 2A27 0E 41                ld      C,PSG_DAT       ; PSG data port
3589+ 2A29 ED 51                out     (C),D           ; send volume level
3590+ 2A2B C9                   ret                     ; return to caller
3591+ 2A2C
3592+ 2A2C              ; SOUND ch,tone,dur
3593+ 2A2C              ; play a tone or noise of "tone" frequency from selected channel "ch" for duration "dur"
3594+ 2A2C              ; "ch" is 1~6 (0=means sound OFF,1~3 for tone, 4~6 for noise) / "tone" is 1~4,095 (0=means no tone) /
3595+ 2A2C              ; "dur" is 1~16383 h.o.s.,0.001~163s (0=means non-stop tone)
3596+ 2A2C CD CD 28     SOUND:  call    GETINT          ; get integer 0-255 (recover channel)
3597+ 2A2F A7                   and     A               ; is it zero?
3598+ 2A30 20 08                jr      NZ,CTSNDC       ; no, continue with checking of params
3599+ 2A32 E5                   push    HL              ; store HL
3600+ 2A33 F3                   di                      ; disable INTs
3601+ 2A34 CD 57 0C             call    CLRPSGREGS      ; yes, it's zero, so reset PSG registers to shut down every sound
3602+ 2A37 FB                   ei                      ; re-enable INTs
3603+ 2A38 E1                   pop     HL              ; retrieve HL
3604+ 2A39 C9                   ret                     ; return to caller
3605+ 2A3A 32 CD 52     CTSNDC: ld      (TMPBFR1),A     ; no, continue by storing A into a temp. buffer
3606+ 2A3D FE 04                cp      $04             ; is channel >3?
3607+ 2A3F D2 BE 2A             jp      NC,NOISUP       ; Yes - check to see if it's a noise channel
3608+ 2A42 CD 7D 19             call    CHKSYN          ; No, continue checking by making sure ',' follows
3609+ 2A45 2C                   defb    ','
3610+ 2A46 CD 47 20             call    GETNUM          ; Get tone frequency
3611+ 2A49 CD 74 1C             call    DEINT           ; Get integer -32768 to 32767
3612+ 2A4C ED 53 CF 52          ld      (TMPBFR2),DE    ; Store frequency
3613+ 2A50 CD 7D 19             call    CHKSYN          ; Make sure ',' follows
3614+ 2A53 2C                   defb    ','
3615+ 2A54 CD 47 20             call    GETNUM          ; Get duration
3616+ 2A57 CD 74 1C             call    DEINT           ; Get integer -32768 to 32767
3617+ 2A5A ED 53 D1 52          ld      (TMPBFR3),DE    ; Store duration
3618+ 2A5E                                              ; CHECK CHANNEL
3619+ 2A5E 3A CD 52             ld      A,(TMPBFR1)     ; recover channel
3620+ 2A61 FE 01                cp      $01             ; is channel <1?
3621+ 2A63 DA 89 1C             jp      C,FCERR         ; Yes - Illegal function call error
3622+ 2A66                                              ; CHECK FREQUENCY
3623+ 2A66 ED 5B CF 52          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3624+ 2A6A 7A                   ld      A,D             ; move D into A and check if it is in the range 0~4095...
3625+ 2A6B FE 10                cp      $10             ; ...so D must not be greater than $0F (15)
3626+ 2A6D D2 89 1C             jp      NC,FCERR        ; if not in the range, exit with an Illegal function call error
3627+ 2A70                                              ; CHECK DURATION
3628+ 2A70 ED 5B D1 52          ld      DE,(TMPBFR3)    ; restore duration from temp buffer
3629+ 2A74 7A                   ld      A,D             ; check if it is in the range 0~16383...
3630+ 2A75 E6 C0                and     $C0             ; ...(15th & 14th bits must not be set)
3631+ 2A77 C2 89 1C             jp      NZ,FCERR        ; if not in the range, exit with an Illegal function call error
3632+ 2A7A                                              ;
3633+ 2A7A                                              ; SET TONE:
3634+ 2A7A                                              ; let's start by setting up the channel
3635+ 2A7A 3A CD 52             ld      A,(TMPBFR1)     ; restore channel value
3636+ 2A7D FE 03                cp      $03             ; is it 3?
3637+ 2A7F 20 02                jr      NZ,SND1         ; no, jump over
3638+ 2A81 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3639+ 2A83 2F           SND1:   cpl                     ; complement of A - this is used later to set on the channel into the mixer
3640+ 2A84 CD 0B 2B             call    WRTSND          ; enable line into mixer of channel stored in A
3641+ 2A87                                              ; SET FREQUENCY
3642+ 2A87                                              ; we simply get frequency and subtract from 4096. The result
3643+ 2A87                                              ; is put into register pair of the corresponding freq tone channel
3644+ 2A87 ED 5B CF 52          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3645+ 2A8B E5                   push    HL              ; store HL (it will be used by the subroutine)
3646+ 2A8C 21 00 10             ld      HL,$1000        ; load 4096 into HL
3647+ 2A8F A7                   and     A               ; reset C flag
3648+ 2A90 ED 52                sbc     HL,DE           ; subtract freq from HL - now the frequency is inverted, so we will send the low as high and vice-versa
3649+ 2A92 3A CD 52             ld      A,(TMPBFR1)     ; restore channel value
3650+ 2A95 3D                   dec     A               ; set A into the range 0~2
3651+ 2A96 87                   add     A,A             ; double A to find the register pair that correspond to the channel (A->0,1 / B->2,3, C->4,5)
3652+ 2A97 0E 40                ld      C,PSG_REG       ; PSG register port
3653+ 2A99 ED 79                out     (C),A           ; select first register of the pair
3654+ 2A9B 0E 41                ld      C,PSG_DAT       ; PSG data port
3655+ 2A9D ED 69                out     (C),L           ; send high byte
3656+ 2A9F 0E 40                ld      C,PSG_REG       ; PSG register support
3657+ 2AA1 3C                   inc     A               ; second register of the pair
3658+ 2AA2 ED 79                out     (C),A           ; select register
3659+ 2AA4 0E 41                ld      C,PSG_DAT       ; PSG data port
3660+ 2AA6 ED 61                out     (C),H           ; send low byte
3661+ 2AA8 ED 5B D1 52          ld      DE,(TMPBFR3)    ; recover duration
3662+ 2AAC 3A CD 52             ld      A,(TMPBFR1)     ; recover channel value
3663+ 2AAF 3D                   dec     A               ; set channel into the range 0~2
3664+ 2AB0 87                   add     A,A             ; double A to find the correct offset
3665+ 2AB1 21 01 53             ld      HL,CHASNDDTN    ; set duration into...
3666+ 2AB4 85                   add     A,L             ; ...the proper...
3667+ 2AB5 30 01                jr      NC,SNDOVR       ; (is there a rest? no, jump over
3668+ 2AB7 24                   inc     H               ; yes, increment H)
3669+ 2AB8 6F           SNDOVR: ld      L,A             ; ...register pair...
3670+ 2AB9 73                   ld      (HL),E          ; ...and store the value
3671+ 2ABA 23                   inc     HL
3672+ 2ABB 72                   ld      (HL),D
3673+ 2ABC E1                   pop     HL              ; retrieve HL
3674+ 2ABD C9                   ret                     ; Return to caller
3675+ 2ABE FE 07        NOISUP: cp      $07             ; is channel in range 4 to 6 (for a noise)?
3676+ 2AC0 D2 89 1C             jp      NC,FCERR        ; no, so ILLEGAL FUNCTION CALL
3677+ 2AC3 CD 7D 19             call    CHKSYN          ; yes, continue checking by making sure ',' follows
3678+ 2AC6 2C                   defb    ','
3679+ 2AC7 CD CD 28             call    GETINT          ; get integer 0-255 (frequency)
3680+ 2ACA FE 20                cp      $20             ; make sure it's in range 0~31
3681+ 2ACC D2 89 1C             jp      NC,FCERR        ; no, so Illegal function call
3682+ 2ACF 32 CF 52             ld      (TMPBFR2),A     ; store freq.
3683+ 2AD2 2B                   dec     HL              ; dec 'cos GETCHR INCs
3684+ 2AD3 CD BE 1B             call    GETCHR          ; check that nothing follows
3685+ 2AD6 C2 9B 16             jp      NZ,SNERR        ; error if no empty line
3686+ 2AD9 3A CF 52             ld      A,(TMPBFR2)     ; retrieve freq.
3687+ 2ADC 5F                   ld      E,A             ; store freq into E
3688+ 2ADD 3A CD 52             ld      A,(TMPBFR1)     ; retrieve channel
3689+ 2AE0 D6 03                sub     $03             ; subtract 3 to get channel in range 1~3
3690+ 2AE2 FE 03                cp      $03             ; is it 3?
3691+ 2AE4 20 02                jr      NZ,NOS1         ; no, jump over
3692+ 2AE6 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3693+ 2AE8 87           NOS1:   add     A,A
3694+ 2AE9 87                   add     A,A
3695+ 2AEA 87                   add     A,A             ; let's move A 3 bits to left
3696+ 2AEB 47                   ld      B,A             ; store channel into B
3697+ 2AEC 7B                   ld      A,E             ; check if
3698+ 2AED A7                   and     A               ; freq is 0 (means that noise reproduction must be halted)
3699+ 2AEE F3                   di                      ; disable INts
3700+ 2AEF 20 0A                jr      NZ,NOS2         ; no, so jump over
3701+ 2AF1 3E 07                ld      A,$07           ; mixer register
3702+ 2AF3 CD A5 0C             call    SETSNDREG       ; set mixer register
3703+ 2AF6 ED 78                in      A,(C)           ; load current mixer value
3704+ 2AF8 B0                   or      B               ; disable noise
3705+ 2AF9 18 19                jr      NOS3            ; continue over
3706+ 2AFB 78           NOS2:   ld      A,B             ; recover channel
3707+ 2AFC 2F                   cpl                     ; complement of A - this is used to set on the channel into the mixer
3708+ 2AFD CD 0B 2B             call    WRTSND          ; enable line into mixer of channel stored in A
3709+ 2B00 3E 06                ld      A,$06           ; write into noise register
3710+ 2B02 CD A5 0C             call    SETSNDREG       ; set register into PSG
3711+ 2B05 7B                   ld      A,E             ; load value for noise frequency
3712+ 2B06 CD AA 0C             call    WRTSNDREG       ; write data into register $06
3713+ 2B09 FB                   ei                      ; re-enable INTs
3714+ 2B0A C9                   ret
3715+ 2B0B                      ; enable line into mixer of channel stored in A
3716+ 2B0B 47           WRTSND: ld      B,A             ; move channel into B
3717+ 2B0C 3E 07                ld      A,$07           ; mixer register
3718+ 2B0E CD A5 0C             call    SETSNDREG       ; set mixer register
3719+ 2B11 ED 78                in      A,(C)           ; load current value
3720+ 2B13 A0                   and     B               ; set on the channel into the mixer (remember that 0=ON)
3721+ 2B14                                              ; example: if channel is A (1), complement of 1 is 254 (11111110). So, 255 (in case
3722+ 2B14                                              ; the register is still unchanged after reset) is 11111111 and
3723+ 2B14                                              ; 11111111 AND 11111110 is equal to 11111110
3724+ 2B14                                              ; 11111001 AND 11111110 is equal to 11111000 (in case channels B & C are ON)
3725+ 2B14 47           NOS3:   ld      B,A             ; store new mixer value into B
3726+ 2B15 3E 07                ld      A,$07           ; mixer address
3727+ 2B17 CD A5 0C             call    SETSNDREG       ; set register
3728+ 2B1A 78                   ld      A,B             ; retrieve new mixer value from B
3729+ 2B1B CD AA 0C             call    WRTSNDREG       ; send new value for the mixer
3730+ 2B1E FB                   ei                      ; re-enable INTs
3731+ 2B1F C9                   ret                     ; return to caller
3732+ 2B20
3733+ 2B20              ; write a byte into one of the VDP registers
3734+ 2B20 CD CD 28     VREG:   call    GETINT          ; Get register number back into A
3735+ 2B23 FE 08                cp      $08             ; check if value is equal or greater than 8 (VDP registers are only 8, from 0 to 7)
3736+ 2B25 D2 89 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3737+ 2B28 32 CD 52             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3738+ 2B2B CD 7D 19             call    CHKSYN          ; Make sure ',' follows
3739+ 2B2E 2C                   defb    ','
3740+ 2B2F CD CD 28             call    GETINT          ; get value (0-255)
3741+ 2B32 5F                   ld      E,A             ; store value into E
3742+ 2B33 3A CD 52             ld      A,(TMPBFR1)     ; recover VDP register and store into A
3743+ 2B36 F3                   di                      ; disable INTs
3744+ 2B37 CD A7 06             call    WRITE_VREG      ; write value into VDP register
3745+ 2B3A FB                   ei                      ; re-enable INTs
3746+ 2B3B C9                   ret                     ; return to caller
3747+ 2B3C
3748+ 2B3C              ; read the VDP status register and return it into A
3749+ 2B3C CD 74 1C     VSTAT:  call    DEINT           ; Get integer -32768 to 32767 (Note: we do NOT use it)
3750+ 2B3F F3                   di                      ; disable INTs
3751+ 2B40 CD B2 06             call    READ_VSTAT      ; read VDP register status
3752+ 2B43 FB                   ei                      ; re-enable INTs
3753+ 2B44 C3 40 24             jp      PASSA           ; Return integer A
3754+ 2B47
3755+ 2B47              ; read from PSG register and return it into A
3756+ 2B47 CD 74 1C     SSTAT:  call    DEINT           ; get integer -32768 to 32767
3757+ 2B4A 7B                   ld      A,E             ; consider LSB
3758+ 2B4B FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3759+ 2B4D D2 89 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3760+ 2B50 F3                   di                      ; disable INts
3761+ 2B51 0E 40                ld      C,PSG_REG       ; output port to set PSG register
3762+ 2B53 ED 79                out     (C),A           ; send register to read from
3763+ 2B55 ED 78                in      A,(C)           ; read register's contents and store into A
3764+ 2B57 FB                   ei                      ; re-enable INTs
3765+ 2B58 C3 40 24             jp      PASSA           ; return A
3766+ 2B5B
3767+ 2B5B              ; read the temp key buffer and return the value of the current key being pressed
3768+ 2B5B              ; can wait for the number of 100thds of second before to return
3769+ 2B5B CD BA 24     INKEY:  call    IDTEST          ; Test for illegal direct
3770+ 2B5E CD 74 1C             call    DEINT           ; get number param (100thds of second to wait) into DE
3771+ 2B61 C5                   push    BC              ; store BC
3772+ 2B62 3A AC 52             ld      A,(TMRCNT)      ; Load current value of system timer
3773+ 2B65 47                   ld      B,A             ; move it into B
3774+ 2B66 3A AC 52     CMP_A:  ld      A,(TMRCNT)      ; make a little delay of 1/100 sec...
3775+ 2B69 B8                   cp      B               ; ...to let the sniffer collect...
3776+ 2B6A 20 FA                jr      NZ,CMP_A        ; ...at least 1 char before to continue
3777+ 2B6C 7A                   ld      A,D             ; check the param
3778+ 2B6D B3                   or      E               ; if DE<>0 then...
3779+ 2B6E 20 05                jr      NZ,INKEY2       ; ...jump over...
3780+ 2B70 3A 09 53             ld      A,(TMPKEYBFR)   ; ...else read the buffer and...
3781+ 2B73 18 2A                jr      ENDINK          ; ...return it
3782+ 2B75 7A           INKEY2: ld      A,D             ; check if param>1023
3783+ 2B76 FE 04                cp      $04             ; to do this we check if MSB>3
3784+ 2B78 D2 89 1C             jp      NC,FCERR        ; if MSB >=4 then error
3785+ 2B7B E5                   push    HL              ; store HL
3786+ 2B7C 21 09 00             ld      HL,$0009        ; check if value
3787+ 2B7F CD 88 3F             call    CMP16           ; is < 10
3788+ 2B82 E1                   pop     HL              ; retrieve HL
3789+ 2B83 DA 89 2B             jp      C,SRTINK        ; if value >= 10 then jump over
3790+ 2B86 11 0A 00             ld      DE,$000A        ; else, use 10 (no intervals shorter than 10/100s)
3791+ 2B89 3A AC 52     SRTINK: ld      A,(TMRCNT)      ; Load the first byte of the system timer
3792+ 2B8C 47                   ld      B,A             ; move it into B
3793+ 2B8D 3A 09 53     CHKINK: ld      A,(TMPKEYBFR)   ; load char code from buffer
3794+ 2B90 A7                   and     A               ; is it 0?
3795+ 2B91 20 0C                jr      NZ,ENDINK       ; no, so we can return it
3796+ 2B93 3A AC 52             ld      A,(TMRCNT)      ; load the first byte of the system timer
3797+ 2B96 B8                   cp      B               ; is it the same value?
3798+ 2B97 28 F4                jr      Z,CHKINK        ; yes, so read again
3799+ 2B99 47                   ld      B,A             ; store new value
3800+ 2B9A 1B                   dec     DE              ; no, decrement timer
3801+ 2B9B 7A                   ld      A,D             ; check if zero reached
3802+ 2B9C B3                   or      E               ; by ORing D and E
3803+ 2B9D 20 EE                jr      NZ,CHKINK       ; if not 0, repeat
3804+ 2B9F C1           ENDINK: pop     BC              ; restore BC
3805+ 2BA0 F5                   push    AF              ; store A
3806+ 2BA1 F3                   di                      ; disable INTs
3807+ 2BA2 AF                   xor     A               ; clear the...
3808+ 2BA3 32 09 53             ld      (TMPKEYBFR),A   ; ...TMP KEY buffer for the next read
3809+ 2BA6 FB                   ei                      ; re-enable INTs
3810+ 2BA7 F1                   pop     AF              ; retrieve A
3811+ 2BA8 C3 40 24     ENDINK2:jp      PASSA           ; return A as ASCII value
3812+ 2BAB
3813+ 2BAB
3814+ 2BAB 21 D2 30     ROUND:  ld      HL,HALF         ; Add 0.5 to FPREG
3815+ 2BAE CD A3 2E     ADDPHL: call    LOADFP          ; Load FP at (HL) to BCDE
3816+ 2BB1 C3 BD 2B             jp      FPADD           ; Add BCDE to FPREG
3817+ 2BB4
3818+ 2BB4
3819+ 2BB4 CD A3 2E     SUBPHL: call    LOADFP          ; FPREG = -FPREG + number at HL
3820+ 2BB7 21                   defb    $21             ; Skip "pop BC" and "pop DE"
3821+ 2BB8 C1           PSUB:   pop     BC              ; Get FP number from stack
3822+ 2BB9 D1                   pop     DE
3823+ 2BBA CD 7D 2E     SUBCDE: call    INVSGN          ; Negate FPREG
3824+ 2BBD 78           FPADD:  ld      A,B             ; Get FP exponent
3825+ 2BBE B7                   or      A               ; Is number zero?
3826+ 2BBF C8                   ret     Z               ; Yes - Nothing to add
3827+ 2BC0 3A 24 53             ld      A,(FPEXP)       ; Get FPREG exponent
3828+ 2BC3 B7                   or      A               ; Is this number zero?
3829+ 2BC4 CA 95 2E             jp      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3830+ 2BC7 90                   sub     B               ; BCDE number larger?
3831+ 2BC8 D2 D7 2B             jp      NC,NOSWAP       ; No - Don't swap them
3832+ 2BCB 2F                   cpl                     ; Two's complement
3833+ 2BCC 3C                   inc     A               ;  FP exponent
3834+ 2BCD EB                   ex      DE,HL
3835+ 2BCE CD 85 2E             call    STAKFP          ; Put FPREG on stack
3836+ 2BD1 EB                   ex      DE,HL
3837+ 2BD2 CD 95 2E             call    FPBCDE          ; Move BCDE to FPREG
3838+ 2BD5 C1                   pop     BC              ; Restore number from stack
3839+ 2BD6 D1                   pop     DE
3840+ 2BD7 FE 19        NOSWAP: cp      24+1            ; Second number insignificant?
3841+ 2BD9 D0                   ret     NC              ; Yes - First number is result
3842+ 2BDA F5                   push    AF              ; Save number of bits to scale
3843+ 2BDB CD BA 2E             call    SIGNS           ; Set MSBs & sign of result
3844+ 2BDE 67                   ld      H,A             ; Save sign of result
3845+ 2BDF F1                   pop     AF              ; Restore scaling factor
3846+ 2BE0 CD 82 2C             call    SCALE           ; Scale BCDE to same exponent
3847+ 2BE3 B4                   or      H               ; Result to be positive?
3848+ 2BE4 21 21 53             ld      HL,FPREG        ; Point to FPREG
3849+ 2BE7 F2 FD 2B             jp      P,MINCDE        ; No - Subtract FPREG from CDE
3850+ 2BEA CD 62 2C             call    PLUCDE          ; Add FPREG to CDE
3851+ 2BED D2 43 2C             jp      NC,RONDUP       ; No overflow - Round it up
3852+ 2BF0 23                   inc     HL              ; Point to exponent
3853+ 2BF1 34                   inc     (HL)            ; Increment it
3854+ 2BF2 CA AA 16             jp      Z,OVERR         ; Number overflowed - Error
3855+ 2BF5 2E 01                ld      L,$01           ; 1 bit to shift right
3856+ 2BF7 CD 98 2C             call    SHRT1           ; Shift result right
3857+ 2BFA C3 43 2C             jp      RONDUP          ; Round it up
3858+ 2BFD
3859+ 2BFD AF           MINCDE: xor     A               ; Clear A and carry
3860+ 2BFE 90                   sub     B               ; Negate exponent
3861+ 2BFF 47                   ld      B,A             ; Re-save exponent
3862+ 2C00 7E                   ld      A,(HL)          ; Get LSB of FPREG
3863+ 2C01 9B                   sbc     A, E            ; Subtract LSB of BCDE
3864+ 2C02 5F                   ld      E,A             ; Save LSB of BCDE
3865+ 2C03 23                   inc     HL
3866+ 2C04 7E                   ld      A,(HL)          ; Get NMSB of FPREG
3867+ 2C05 9A                   sbc     A,D             ; Subtract NMSB of BCDE
3868+ 2C06 57                   ld      D,A             ; Save NMSB of BCDE
3869+ 2C07 23                   inc     HL
3870+ 2C08 7E                   ld      A,(HL)          ; Get MSB of FPREG
3871+ 2C09 99                   sbc     A,C             ; Subtract MSB of BCDE
3872+ 2C0A 4F                   ld      C,A             ; Save MSB of BCDE
3873+ 2C0B DC 6E 2C     CONPOS: call    C,COMPL         ; Overflow - Make it positive
3874+ 2C0E
3875+ 2C0E 68           BNORM:  ld      L,B             ; L = Exponent
3876+ 2C0F 63                   ld      H,E             ; H = LSB
3877+ 2C10 AF                   xor     A
3878+ 2C11 47           BNRMLP: ld      B,A             ; Save bit count
3879+ 2C12 79                   ld      A,C             ; Get MSB
3880+ 2C13 B7                   or      A               ; Is it zero?
3881+ 2C14 C2 30 2C             jp      NZ,PNORM        ; No - Do it bit at a time
3882+ 2C17 4A                   ld      C,D             ; MSB = NMSB
3883+ 2C18 54                   ld      D,H             ; NMSB= LSB
3884+ 2C19 65                   ld      H,L             ; LSB = VLSB
3885+ 2C1A 6F                   ld      L,A             ; VLSB= 0
3886+ 2C1B 78                   ld      A,B             ; Get exponent
3887+ 2C1C D6 08                sub     $08             ; Count 8 bits
3888+ 2C1E FE E0                cp      -24-8           ; Was number zero?
3889+ 2C20 C2 11 2C             jp      NZ,BNRMLP       ; No - Keep normalising
3890+ 2C23 AF           RESZER: xor     A               ; Result is zero
3891+ 2C24 32 24 53     SAVEXP: ld      (FPEXP),A       ; Save result as zero
3892+ 2C27 C9                   ret
3893+ 2C28
3894+ 2C28 05           NORMAL: dec     B               ; Count bits
3895+ 2C29 29                   add     HL,HL           ; Shift HL left
3896+ 2C2A 7A                   ld      A,D             ; Get NMSB
3897+ 2C2B 17                   rla                     ; Shift left with last bit
3898+ 2C2C 57                   ld      D,A             ; Save NMSB
3899+ 2C2D 79                   ld      A,C             ; Get MSB
3900+ 2C2E 8F                   adc     A,A             ; Shift left with last bit
3901+ 2C2F 4F                   ld      C,A             ; Save MSB
3902+ 2C30 F2 28 2C     PNORM:  jp      P,NORMAL        ; Not done - Keep going
3903+ 2C33 78                   ld      A,B             ; Number of bits shifted
3904+ 2C34 5C                   ld      E,H             ; Save HL in EB
3905+ 2C35 45                   ld      B,L
3906+ 2C36 B7                   or      A               ; Any shifting done?
3907+ 2C37 CA 43 2C             jp      Z,RONDUP        ; No - Round it up
3908+ 2C3A 21 24 53             ld      HL,FPEXP        ; Point to exponent
3909+ 2C3D 86                   add     A,(HL)          ; Add shifted bits
3910+ 2C3E 77                   ld      (HL),A          ; Re-save exponent
3911+ 2C3F D2 23 2C             jp      NC,RESZER       ; Underflow - Result is zero
3912+ 2C42 C8                   ret     Z               ; Result is zero
3913+ 2C43 78           RONDUP: ld      A,B             ; Get VLSB of number
3914+ 2C44 21 24 53     RONDB:  ld      HL,FPEXP        ; Point to exponent
3915+ 2C47 B7                   or      A               ; Any rounding?
3916+ 2C48 FC 55 2C             call    M,FPROND        ; Yes - Round number up
3917+ 2C4B 46                   ld      B,(HL)          ; B = Exponent
3918+ 2C4C 23                   inc     HL
3919+ 2C4D 7E                   ld      A,(HL)          ; Get sign of result
3920+ 2C4E E6 80                and     %10000000       ; Only bit 7 needed
3921+ 2C50 A9                   xor     C               ; Set correct sign
3922+ 2C51 4F                   ld      C,A             ; Save correct sign in number
3923+ 2C52 C3 95 2E             jp      FPBCDE          ; Move BCDE to FPREG
3924+ 2C55
3925+ 2C55 1C           FPROND: inc     E               ; Round LSB
3926+ 2C56 C0                   ret     NZ              ; Return if ok
3927+ 2C57 14                   inc     D               ; Round NMSB
3928+ 2C58 C0                   ret     NZ              ; Return if ok
3929+ 2C59 0C                   inc     C               ; Round MSB
3930+ 2C5A C0                   ret     NZ              ; Return if ok
3931+ 2C5B 0E 80                ld      C,$80           ; Set normal value
3932+ 2C5D 34                   inc     (HL)            ; Increment exponent
3933+ 2C5E C0                   ret     NZ              ; Return if ok
3934+ 2C5F C3 AA 16             jp      OVERR           ; Overflow error
3935+ 2C62
3936+ 2C62 7E           PLUCDE: ld      A,(HL)          ; Get LSB of FPREG
3937+ 2C63 83                   add     A,E             ; Add LSB of BCDE
3938+ 2C64 5F                   ld      E,A             ; Save LSB of BCDE
3939+ 2C65 23                   inc     HL
3940+ 2C66 7E                   ld      A,(HL)          ; Get NMSB of FPREG
3941+ 2C67 8A                   adc     A,D             ; Add NMSB of BCDE
3942+ 2C68 57                   ld      D,A             ; Save NMSB of BCDE
3943+ 2C69 23                   inc     HL
3944+ 2C6A 7E                   ld      A,(HL)          ; Get MSB of FPREG
3945+ 2C6B 89                   adc     A,C             ; Add MSB of BCDE
3946+ 2C6C 4F                   ld      C,A             ; Save MSB of BCDE
3947+ 2C6D C9                   ret
3948+ 2C6E
3949+ 2C6E 21 25 53     COMPL:  ld      HL,SGNRES       ; Sign of result
3950+ 2C71 7E                   ld      A,(HL)          ; Get sign of result
3951+ 2C72 2F                   cpl                     ; Negate it
3952+ 2C73 77                   ld      (HL),A          ; Put it back
3953+ 2C74 AF                   xor     A
3954+ 2C75 6F                   ld      L,A             ; Set L to zero
3955+ 2C76 90                   sub     B               ; Negate exponent,set carry
3956+ 2C77 47                   ld      B,A             ; Re-save exponent
3957+ 2C78 7D                   ld      A,L             ; Load zero
3958+ 2C79 9B                   sbc     A,E             ; Negate LSB
3959+ 2C7A 5F                   ld      E,A             ; Re-save LSB
3960+ 2C7B 7D                   ld      A,L             ; Load zero
3961+ 2C7C 9A                   sbc     A,D             ; Negate NMSB
3962+ 2C7D 57                   ld      D,A             ; Re-save NMSB
3963+ 2C7E 7D                   ld      A,L             ; Load zero
3964+ 2C7F 99                   sbc     A,C             ; Negate MSB
3965+ 2C80 4F                   ld      C,A             ; Re-save MSB
3966+ 2C81 C9                   ret
3967+ 2C82
3968+ 2C82 06 00        SCALE:  ld      B,$00           ; Clear underflow
3969+ 2C84 D6 08        SCALLP: sub     $08             ; 8 bits (a whole byte)?
3970+ 2C86 DA 91 2C             jp      C,SHRITE        ; No - Shift right A bits
3971+ 2C89 43                   ld      B,E             ; <- Shift
3972+ 2C8A 5A                   ld      E,D             ; <- right
3973+ 2C8B 51                   ld      D,C             ; <- eight
3974+ 2C8C 0E 00                ld      C,$00           ; <- bits
3975+ 2C8E C3 84 2C             jp      SCALLP          ; More bits to shift
3976+ 2C91
3977+ 2C91 C6 09        SHRITE: add     A,8+1           ; Adjust count
3978+ 2C93 6F                   ld      L,A             ; Save bits to shift
3979+ 2C94 AF           SHRLP:  xor     A               ; Flag for all done
3980+ 2C95 2D                   dec     L               ; All shifting done?
3981+ 2C96 C8                   ret     Z               ; Yes - Return
3982+ 2C97 79                   ld      A,C             ; Get MSB
3983+ 2C98 1F           SHRT1:  rra                     ; Shift it right
3984+ 2C99 4F                   ld      C,A             ; Re-save
3985+ 2C9A 7A                   ld      A,D             ; Get NMSB
3986+ 2C9B 1F                   rra                     ; Shift right with last bit
3987+ 2C9C 57                   ld      D,A             ; Re-save it
3988+ 2C9D 7B                   ld      A,E             ; Get LSB
3989+ 2C9E 1F                   rra                     ; Shift right with last bit
3990+ 2C9F 5F                   ld      E,A             ; Re-save it
3991+ 2CA0 78                   ld      A,B             ; Get underflow
3992+ 2CA1 1F                   rra                     ; Shift right with last bit
3993+ 2CA2 47                   ld      B,A             ; Re-save underflow
3994+ 2CA3 C3 94 2C             jp      SHRLP           ; More bits to do
3995+ 2CA6
3996+ 2CA6 00 00 00 81  UNITY:  defb    $00,$00,$00,$81 ; 1.00000
3997+ 2CAA
3998+ 2CAA 03           LOGTAB: defb    $03             ; Table used by LOG
3999+ 2CAB AA 56 19 80          defb    $AA,$56,$19,$80 ; 0.59898
4000+ 2CAF F1 22 76 80          defb    $F1,$22,$76,$80 ; 0.96147
4001+ 2CB3 45 AA 38 82          defb    $45,$AA,$38,$82 ; 2.88539
4002+ 2CB7
4003+ 2CB7 CD 54 2E     LOG:    call    TSTSGN          ; Test sign of value
4004+ 2CBA B7                   or      A
4005+ 2CBB EA 89 1C             jp      PE,FCERR        ; ?FC Error if <= zero
4006+ 2CBE 21 24 53             ld      HL,FPEXP        ; Point to exponent
4007+ 2CC1 7E                   ld      A,(HL)          ; Get exponent
4008+ 2CC2 01 35 80             ld      BC,$8035        ; BCDE = SQR(1/2)
4009+ 2CC5 11 F3 04             ld      DE,$04F3
4010+ 2CC8 90                   sub     B               ; Scale value to be < 1
4011+ 2CC9 F5                   push    AF              ; Save scale factor
4012+ 2CCA 70                   ld      (HL),B          ; Save new exponent
4013+ 2CCB D5                   push    DE              ; Save SQR(1/2)
4014+ 2CCC C5                   push    BC
4015+ 2CCD CD BD 2B             call    FPADD           ; Add SQR(1/2) to value
4016+ 2CD0 C1                   pop     BC              ; Restore SQR(1/2)
4017+ 2CD1 D1                   pop     DE
4018+ 2CD2 04                   inc     B               ; Make it SQR(2)
4019+ 2CD3 CD AA 2D             call    DVBCDE          ; Divide by SQR(2)
4020+ 2CD6 21 A6 2C             ld      HL,UNITY        ; Point to 1.
4021+ 2CD9 CD B4 2B             call    SUBPHL          ; Subtract FPREG from 1
4022+ 2CDC 21 AA 2C             ld      HL,LOGTAB       ; Coefficient table
4023+ 2CDF CD 9C 31             call    SUMSER          ; Evaluate sum of series
4024+ 2CE2 01 80 80             ld      BC,$8080        ; BCDE = -0.5
4025+ 2CE5 11 00 00             ld      DE,$0000
4026+ 2CE8 CD BD 2B             call    FPADD           ; Subtract 0.5 from FPREG
4027+ 2CEB F1                   pop     AF              ; Restore scale factor
4028+ 2CEC CD CF 2F             call    RSCALE          ; Re-scale number
4029+ 2CEF 01 31 80     MULLN2: ld      BC,$8031        ; BCDE = Ln(2)
4030+ 2CF2 11 18 72             ld      DE,$7218
4031+ 2CF5 21                   defb    $21             ; Skip "pop BC" and "pop DE"
4032+ 2CF6
4033+ 2CF6 C1           MULT:   pop     BC              ; Get number from stack
4034+ 2CF7 D1                   pop     DE
4035+ 2CF8 CD 54 2E     FPMULT: call    TSTSGN          ; Test sign of FPREG
4036+ 2CFB C8                   ret     Z               ; Return zero if zero
4037+ 2CFC 2E 00                ld      L,$00           ; Flag add exponents
4038+ 2CFE CD 12 2E             call    ADDEXP          ; Add exponents
4039+ 2D01 79                   ld      A,C             ; Get MSB of multiplier
4040+ 2D02 32 33 53             ld      (MULVAL),A      ; Save MSB of multiplier
4041+ 2D05 EB                   ex      DE,HL
4042+ 2D06 22 34 53             ld      (MULVAL+1),HL   ; Save rest of multiplier
4043+ 2D09 01 00 00             ld      BC,$0000        ; Partial product (BCDE) = zero
4044+ 2D0C 50                   ld      D,B
4045+ 2D0D 58                   ld      E,B
4046+ 2D0E 21 0E 2C             ld      HL,BNORM        ; Address of normalise
4047+ 2D11 E5                   push    HL              ; Save for return
4048+ 2D12 21 1A 2D             ld      HL,MULT8        ; Address of 8 bit multiply
4049+ 2D15 E5                   push    HL              ; Save for NMSB,MSB
4050+ 2D16 E5                   push    HL              ;
4051+ 2D17 21 21 53             ld      HL,FPREG        ; Point to number
4052+ 2D1A 7E           MULT8:  ld      A,(HL)          ; Get LSB of number
4053+ 2D1B 23                   inc     HL              ; Point to NMSB
4054+ 2D1C B7                   or      A               ; Test LSB
4055+ 2D1D CA 46 2D             jp      Z,BYTSFT        ; Zero - shift to next byte
4056+ 2D20 E5                   push    HL              ; Save address of number
4057+ 2D21 2E 08                ld      L,$08           ; 8 bits to multiply by
4058+ 2D23 1F           MUL8LP: rra                     ; Shift LSB right
4059+ 2D24 67                   ld      H,A             ; Save LSB
4060+ 2D25 79                   ld      A,C             ; Get MSB
4061+ 2D26 D2 34 2D             jp      NC,NOMADD       ; Bit was zero - Don't add
4062+ 2D29 E5                   push    HL              ; Save LSB and count
4063+ 2D2A 2A 34 53             ld      HL,(MULVAL+1)   ; Get LSB and NMSB
4064+ 2D2D 19                   add     HL,DE           ; Add NMSB and LSB
4065+ 2D2E EB                   ex      DE,HL           ; Leave sum in DE
4066+ 2D2F E1                   pop     HL              ; Restore MSB and count
4067+ 2D30 3A 33 53             ld      A,(MULVAL)      ; Get MSB of multiplier
4068+ 2D33 89                   adc     A,C             ; Add MSB
4069+ 2D34 1F           NOMADD: rra                     ; Shift MSB right
4070+ 2D35 4F                   ld      C,A             ; Re-save MSB
4071+ 2D36 7A                   ld      A,D             ; Get NMSB
4072+ 2D37 1F                   rra                     ; Shift NMSB right
4073+ 2D38 57                   ld      D,A             ; Re-save NMSB
4074+ 2D39 7B                   ld      A,E             ; Get LSB
4075+ 2D3A 1F                   rra                     ; Shift LSB right
4076+ 2D3B 5F                   ld      E,A             ; Re-save LSB
4077+ 2D3C 78                   ld      A,B             ; Get VLSB
4078+ 2D3D 1F                   rra                     ; Shift VLSB right
4079+ 2D3E 47                   ld      B,A             ; Re-save VLSB
4080+ 2D3F 2D                   dec     L               ; Count bits multiplied
4081+ 2D40 7C                   ld      A,H             ; Get LSB of multiplier
4082+ 2D41 C2 23 2D             jp      NZ,MUL8LP       ; More - Do it
4083+ 2D44 E1           POPHRT: pop     HL              ; Restore address of number
4084+ 2D45 C9                   ret
4085+ 2D46
4086+ 2D46 43           BYTSFT: ld      B,E             ; Shift partial product left
4087+ 2D47 5A                   ld      E,D
4088+ 2D48 51                   ld      D,C
4089+ 2D49 4F                   ld      C,A
4090+ 2D4A C9                   ret
4091+ 2D4B
4092+ 2D4B
4093+ 2D4B              ; WORKING ââ
4094+ 2D4B C1           DINT:   pop     BC              ; Get number from stack
4095+ 2D4C D1                   pop     DE
4096+ 2D4D CD AA 2D             call    DVBCDE          ; get BCDE/FPREG and store result into FPREG
4097+ 2D50 C3 27 2F             jp      INT             ; return INT(FPREG)
4098+ 2D53
4099+ 2D53
4100+ 2D53              ; A MODULO B - return remainder of the integer division A/B where:
4101+ 2D53              ; A is in stack; B is in FPREG
4102+ 2D53              ; math is:
4103+ 2D53              ; A=INT(A); B=INT(B); R=A-(B*INT(A/B))
4104+ 2D53 CD 27 2F     MOD:    call    INT             ; B=INT(B)
4105+ 2D56 CD A0 2E             call    BCDEFP          ; copy B (from FPREG) into BCDE
4106+ 2D59 ED 53 D1 52          ld      (TMPBFR3),DE    ; store B into...
4107+ 2D5D ED 43 D3 52          ld      (TMPBFR4),BC    ; ...a temp buffer
4108+ 2D61 C1                   pop     BC              ; recover A...
4109+ 2D62 D1                   pop     DE              ; ...from stack
4110+ 2D63 CD 95 2E             call    FPBCDE          ; store A into FPREG
4111+ 2D66 CD 27 2F             call    INT             ; get integer part: A=INT(A)
4112+ 2D69 CD A0 2E             call    BCDEFP          ; copy A (from FPREG) into BCDE
4113+ 2D6C ED 53 CD 52          ld      (TMPBFR1),DE    ; store A into...
4114+ 2D70 ED 43 CF 52          ld      (TMPBFR2),BC    ; ...a temp buffer
4115+ 2D74                                              ; begin calculation
4116+ 2D74 2A D1 52             ld      HL,(TMPBFR3)    ; move B...
4117+ 2D77 22 21 53             ld      (FPREG),HL      ; ...from...
4118+ 2D7A 2A D3 52             ld      HL,(TMPBFR4)    ; ...temp buffer...
4119+ 2D7D 22 23 53             ld      (FPREG+2),HL    ; ...into FPREG
4120+ 2D80 CD AA 2D             call    DVBCDE          ; compute A/B and store into FPREG
4121+ 2D83 CD 27 2F             call    INT             ; get integer part of result: now FPREG = INT(A/B)
4122+ 2D86 ED 5B D1 52          ld      DE,(TMPBFR3)    ; load B...
4123+ 2D8A ED 4B D3 52          ld      BC,(TMPBFR4)    ; ...into BCDE
4124+ 2D8E CD F8 2C             call    FPMULT          ; get B*INT(A/B) and store into FPREG
4125+ 2D91 ED 5B CD 52          ld      DE,(TMPBFR1)    ; retrieve A from...
4126+ 2D95 ED 4B CF 52          ld      BC,(TMPBFR2)    ; ...temp buffer
4127+ 2D99 C3 BA 2B             jp      SUBCDE          ; return result of A-(B*INT(A/B))
4128+ 2D9C
4129+ 2D9C
4130+ 2D9C CD 85 2E     DIV10:  call    STAKFP          ; Save FPREG on stack
4131+ 2D9F 01 20 84             ld      BC,$8420        ; BCDE = 10.
4132+ 2DA2 11 00 00             ld      DE,$0000
4133+ 2DA5 CD 95 2E             call    FPBCDE          ; Move 10 to FPREG
4134+ 2DA8
4135+ 2DA8 C1           DIV:    pop     BC              ; Get number from stack
4136+ 2DA9 D1                   pop     DE
4137+ 2DAA CD 54 2E     DVBCDE: call    TSTSGN          ; Test sign of FPREG
4138+ 2DAD CA 9E 16             jp      Z,DZERR         ; Error if division by zero
4139+ 2DB0 2E FF                ld      L,-1            ; Flag subtract exponents
4140+ 2DB2 CD 12 2E             call    ADDEXP          ; Subtract exponents
4141+ 2DB5 34                   inc     (HL)            ; Add 2 to exponent to adjust
4142+ 2DB6 34                   inc     (HL)
4143+ 2DB7 2B                   dec     HL              ; Point to MSB
4144+ 2DB8 7E                   ld      A,(HL)          ; Get MSB of dividend
4145+ 2DB9 32 62 51             ld      (DIV3),A        ; Save for subtraction
4146+ 2DBC 2B                   dec     HL
4147+ 2DBD 7E                   ld      A,(HL)          ; Get NMSB of dividend
4148+ 2DBE 32 5E 51             ld      (DIV2),A        ; Save for subtraction
4149+ 2DC1 2B                   dec     HL
4150+ 2DC2 7E                   ld      A,(HL)          ; Get MSB of dividend
4151+ 2DC3 32 5A 51             ld      (DIV1),A        ; Save for subtraction
4152+ 2DC6 41                   ld      B,C             ; Get MSB
4153+ 2DC7 EB                   ex      DE,HL           ; NMSB,LSB to HL
4154+ 2DC8 AF                   xor     A
4155+ 2DC9 4F                   ld      C,A             ; Clear MSB of quotient
4156+ 2DCA 57                   ld      D,A             ; Clear NMSB of quotient
4157+ 2DCB 5F                   ld      E,A             ; Clear LSB of quotient
4158+ 2DCC 32 65 51             ld      (DIV4),A        ; Clear overflow count
4159+ 2DCF E5           DIVLP:  push    HL              ; Save divisor
4160+ 2DD0 C5                   push    BC
4161+ 2DD1 7D                   ld      A,L             ; Get LSB of number
4162+ 2DD2 CD 59 51             call    DIVSUP          ; Subt' divisor from dividend
4163+ 2DD5 DE 00                sbc     A,$00           ; Count for overflows
4164+ 2DD7 3F                   ccf
4165+ 2DD8 D2 E2 2D             jp      NC,RESDIV       ; Restore divisor if borrow
4166+ 2DDB 32 65 51             ld      (DIV4),A        ; Re-save overflow count
4167+ 2DDE F1                   pop     AF              ; Scrap divisor
4168+ 2DDF F1                   pop     AF
4169+ 2DE0 37                   scf                     ; Set carry to
4170+ 2DE1 D2                   defb    $D2             ; Skip "pop BC" and "pop HL"
4171+ 2DE2
4172+ 2DE2 C1           RESDIV: pop     BC              ; Restore divisor
4173+ 2DE3 E1                   pop     HL
4174+ 2DE4 79                   ld      A,C             ; Get MSB of quotient
4175+ 2DE5 3C                   inc     A
4176+ 2DE6 3D                   dec     A
4177+ 2DE7 1F                   rra                     ; Bit 0 to bit 7
4178+ 2DE8 FA 44 2C             jp      M,RONDB         ; Done - Normalise result
4179+ 2DEB 17                   rla                     ; Restore carry
4180+ 2DEC 7B                   ld      A,E             ; Get LSB of quotient
4181+ 2DED 17                   rla                     ; Double it
4182+ 2DEE 5F                   ld      E,A             ; Put it back
4183+ 2DEF 7A                   ld      A,D             ; Get NMSB of quotient
4184+ 2DF0 17                   rla                     ; Double it
4185+ 2DF1 57                   ld      D,A             ; Put it back
4186+ 2DF2 79                   ld      A,C             ; Get MSB of quotient
4187+ 2DF3 17                   rla                     ; Double it
4188+ 2DF4 4F                   ld      C,A             ; Put it back
4189+ 2DF5 29                   add     HL,HL           ; Double NMSB,LSB of divisor
4190+ 2DF6 78                   ld      A,B             ; Get MSB of divisor
4191+ 2DF7 17                   rla                     ; Double it
4192+ 2DF8 47                   ld      B,A             ; Put it back
4193+ 2DF9 3A 65 51             ld      A,(DIV4)        ; Get VLSB of quotient
4194+ 2DFC 17                   rla                     ; Double it
4195+ 2DFD 32 65 51             ld      (DIV4),A        ; Put it back
4196+ 2E00 79                   ld      A,C             ; Get MSB of quotient
4197+ 2E01 B2                   or      D               ; Merge NMSB
4198+ 2E02 B3                   or      E               ; Merge LSB
4199+ 2E03 C2 CF 2D             jp      NZ,DIVLP        ; Not done - Keep dividing
4200+ 2E06 E5                   push    HL              ; Save divisor
4201+ 2E07 21 24 53             ld      HL,FPEXP        ; Point to exponent
4202+ 2E0A 35                   dec     (HL)            ; Divide by 2
4203+ 2E0B E1                   pop     HL              ; Restore divisor
4204+ 2E0C C2 CF 2D             jp      NZ,DIVLP        ; Ok - Keep going
4205+ 2E0F C3 AA 16             jp      OVERR           ; Overflow error
4206+ 2E12
4207+ 2E12
4208+ 2E12 78           ADDEXP: ld      A,B             ; Get exponent of dividend
4209+ 2E13 B7                   or      A               ; Test it
4210+ 2E14 CA 36 2E             jp      Z,OVTST3        ; Zero - Result zero
4211+ 2E17 7D                   ld      A,L             ; Get add/subtract flag
4212+ 2E18 21 24 53             ld      HL,FPEXP        ; Point to exponent
4213+ 2E1B AE                   xor     (HL)            ; Add or subtract it
4214+ 2E1C 80                   add     A,B             ; Add the other exponent
4215+ 2E1D 47                   ld      B,A             ; Save new exponent
4216+ 2E1E 1F                   rra                     ; Test exponent for overflow
4217+ 2E1F A8                   xor     B
4218+ 2E20 78                   ld      A,B             ; Get exponent
4219+ 2E21 F2 35 2E             jp      P,OVTST2        ; Positive - Test for overflow
4220+ 2E24 C6 80                add     A,$80           ; Add excess 128
4221+ 2E26 77                   ld      (HL),A          ; Save new exponent
4222+ 2E27 CA 44 2D             jp      Z,POPHRT        ; Zero - Result zero
4223+ 2E2A CD BA 2E             call    SIGNS           ; Set MSBs and sign of result
4224+ 2E2D 77                   ld      (HL),A          ; Save new exponent
4225+ 2E2E 2B                   dec     HL              ; Point to MSB
4226+ 2E2F C9                   ret
4227+ 2E30
4228+ 2E30 CD 54 2E     OVTST1: call    TSTSGN          ; Test sign of FPREG
4229+ 2E33 2F                   cpl                     ; Invert sign
4230+ 2E34 E1                   pop     HL              ; Clean up stack
4231+ 2E35 B7           OVTST2: or      A               ; Test if new exponent zero
4232+ 2E36 E1           OVTST3: pop     HL              ; Clear off return address
4233+ 2E37 F2 23 2C             jp      P,RESZER        ; Result zero
4234+ 2E3A C3 AA 16             jp      OVERR           ; Overflow error
4235+ 2E3D
4236+ 2E3D CD A0 2E     MLSP10: call    BCDEFP          ; Move FPREG to BCDE
4237+ 2E40 78                   ld      A,B             ; Get exponent
4238+ 2E41 B7                   or      A               ; Is it zero?
4239+ 2E42 C8                   ret     Z               ; Yes - Result is zero
4240+ 2E43 C6 02                add     A,$02           ; Multiply by 4
4241+ 2E45 DA AA 16             jp      C,OVERR         ; Overflow - ?OV Error
4242+ 2E48 47                   ld      B,A             ; Re-save exponent
4243+ 2E49 CD BD 2B             call    FPADD           ; Add BCDE to FPREG (Times 5)
4244+ 2E4C 21 24 53             ld      HL,FPEXP        ; Point to exponent
4245+ 2E4F 34                   inc     (HL)            ; Double number (Times 10)
4246+ 2E50 C0                   ret     NZ              ; Ok - Return
4247+ 2E51 C3 AA 16             jp      OVERR           ; Overflow error
4248+ 2E54
4249+ 2E54 3A 24 53     TSTSGN: ld      A,(FPEXP)       ; Get sign of FPREG
4250+ 2E57 B7                   or      A
4251+ 2E58 C8                   ret     Z               ; RETurn if number is zero
4252+ 2E59 3A 23 53             ld      A,(FPREG+2)     ; Get MSB of FPREG
4253+ 2E5C FE                   defb    0FEH            ; Test sign
4254+ 2E5D 2F           RETREL: cpl                     ; Invert sign
4255+ 2E5E 17                   rla                     ; Sign bit to carry
4256+ 2E5F 9F           FLGDIF: sbc     A,A             ; Carry to all bits of A
4257+ 2E60 C0                   ret     NZ              ; Return -1 if negative
4258+ 2E61 3C                   inc     A               ; Bump to +1
4259+ 2E62 C9                   ret                     ; Positive - Return +1
4260+ 2E63
4261+ 2E63 CD 54 2E     SGN:    call    TSTSGN          ; Test sign of FPREG
4262+ 2E66 06 88        FLGREL: ld      B,$80+8         ; 8 bit integer in exponent
4263+ 2E68 11 00 00             ld      DE,0            ; Zero NMSB and LSB
4264+ 2E6B 21 24 53     RETINT: ld      HL,FPEXP        ; Point to exponent
4265+ 2E6E 4F                   ld      C,A             ; CDE = MSB,NMSB and LSB
4266+ 2E6F 70                   ld      (HL),B          ; Save exponent
4267+ 2E70 06 00                ld      B,0             ; CDE = integer to normalise
4268+ 2E72 23                   inc     HL              ; Point to sign of result
4269+ 2E73 36 80                ld      (HL),$80        ; Set sign of result
4270+ 2E75 17                   rla                     ; Carry = sign of integer
4271+ 2E76 C3 0B 2C             jp      CONPOS          ; Set sign of result
4272+ 2E79
4273+ 2E79 CD 54 2E     ABS_:   call    TSTSGN          ; Test sign of FPREG
4274+ 2E7C F0                   ret     P               ; Return if positive
4275+ 2E7D 21 23 53     INVSGN: ld      HL,FPREG+2      ; Point to MSB
4276+ 2E80 7E                   ld      A,(HL)          ; Get sign of mantissa
4277+ 2E81 EE 80                xor     $80             ; Invert sign of mantissa
4278+ 2E83 77                   ld      (HL),A          ; Re-save sign of mantissa
4279+ 2E84 C9                   ret
4280+ 2E85
4281+ 2E85 EB           STAKFP: ex      DE,HL           ; Save code string address
4282+ 2E86 2A 21 53             ld      HL,(FPREG)      ; LSB,NLSB of FPREG
4283+ 2E89 E3                   ex      (SP),HL         ; Stack them,get return
4284+ 2E8A E5                   push    HL              ; Re-save return
4285+ 2E8B 2A 23 53             ld      HL,(FPREG+2)    ; MSB and exponent of FPREG
4286+ 2E8E E3                   ex      (SP),HL         ; Stack them,get return
4287+ 2E8F E5                   push    HL              ; Re-save return
4288+ 2E90 EB                   ex      DE,HL           ; Restore code string address
4289+ 2E91 C9                   ret
4290+ 2E92
4291+ 2E92              ; store F.P. number from BCDE into (FPREG)
4292+ 2E92 CD A3 2E     PHLTFP: call    LOADFP          ; Number at HL to BCDE
4293+ 2E95 EB           FPBCDE: ex      DE,HL           ; Save code string address
4294+ 2E96 22 21 53             ld      (FPREG),HL      ; Save LSB,NLSB of number
4295+ 2E99 60                   ld      H,B             ; Exponent of number
4296+ 2E9A 69                   ld      L,C             ; MSB of number
4297+ 2E9B 22 23 53             ld      (FPREG+2),HL    ; Save MSB and exponent
4298+ 2E9E EB                   ex      DE,HL           ; Restore code string address
4299+ 2E9F C9                   ret
4300+ 2EA0
4301+ 2EA0              ; load F.P. number from (FPREG) into BCDE
4302+ 2EA0 21 21 53     BCDEFP: ld      HL,FPREG        ; Point to FPREG
4303+ 2EA3 5E           LOADFP: ld      E,(HL)          ; Get LSB of number
4304+ 2EA4 23                   inc     HL
4305+ 2EA5 56                   ld      D,(HL)          ; Get NMSB of number
4306+ 2EA6 23                   inc     HL
4307+ 2EA7 4E                   ld      C,(HL)          ; Get MSB of number
4308+ 2EA8 23                   inc     HL
4309+ 2EA9 46                   ld      B,(HL)          ; Get exponent of number
4310+ 2EAA 23           INCHL:  inc     HL              ; Used for conditional "inc HL"
4311+ 2EAB C9                   ret
4312+ 2EAC
4313+ 2EAC              ; move floating point from (FPREG) into (HL)
4314+ 2EAC 11 21 53     FPTHL:  ld      DE,FPREG        ; Point to FPREG
4315+ 2EAF 06 04        DETHL4: ld      B,$04           ; 4 bytes to move
4316+ 2EB1 1A           DETHLB: ld      A,(DE)          ; Get source
4317+ 2EB2 77                   ld      (HL),A          ; Save destination
4318+ 2EB3 13                   inc     DE              ; Next source
4319+ 2EB4 23                   inc     HL              ; Next destination
4320+ 2EB5 05                   dec     B               ; Count bytes
4321+ 2EB6 C2 B1 2E             jp      NZ,DETHLB       ; Loop if more
4322+ 2EB9 C9                   ret
4323+ 2EBA
4324+ 2EBA 21 23 53     SIGNS:  ld      HL,FPREG+2      ; Point to MSB of FPREG
4325+ 2EBD 7E                   ld      A,(HL)          ; Get MSB
4326+ 2EBE 07                   rlca                    ; Old sign to carry
4327+ 2EBF 37                   scf                     ; Set MSBit
4328+ 2EC0 1F                   rra                     ; Set MSBit of MSB
4329+ 2EC1 77                   ld      (HL),A          ; Save new MSB
4330+ 2EC2 3F                   ccf                     ; Complement sign
4331+ 2EC3 1F                   rra                     ; Old sign to carry
4332+ 2EC4 23                   inc     HL
4333+ 2EC5 23                   inc     HL
4334+ 2EC6 77                   ld      (HL),A          ; Set sign of result
4335+ 2EC7 79                   ld      A,C             ; Get MSB
4336+ 2EC8 07                   rlca                    ; Old sign to carry
4337+ 2EC9 37                   scf                     ; Set MSBit
4338+ 2ECA 1F                   rra                     ; Set MSBit of MSB
4339+ 2ECB 4F                   ld      C,A             ; Save MSB
4340+ 2ECC 1F                   rra
4341+ 2ECD AE                   xor     (HL)            ; New sign of result
4342+ 2ECE C9                   ret
4343+ 2ECF
4344+ 2ECF 78           CMPNUM: ld      A,B             ; Get exponent of number
4345+ 2ED0 B7                   or      A
4346+ 2ED1 CA 54 2E             jp      Z,TSTSGN        ; Zero - Test sign of FPREG
4347+ 2ED4 21 5D 2E             ld      HL,RETREL       ; Return relation routine
4348+ 2ED7 E5                   push    HL              ; Save for return
4349+ 2ED8 CD 54 2E             call    TSTSGN          ; Test sign of FPREG
4350+ 2EDB 79                   ld      A,C             ; Get MSB of number
4351+ 2EDC C8                   ret     Z               ; FPREG zero - Number's MSB
4352+ 2EDD 21 23 53             ld      HL,FPREG+2      ; MSB of FPREG
4353+ 2EE0 AE                   xor     (HL)            ; Combine signs
4354+ 2EE1 79                   ld      A,C             ; Get MSB of number
4355+ 2EE2 F8                   ret     M               ; Exit if signs different
4356+ 2EE3 CD E9 2E             call    CMPFP           ; Compare FP numbers
4357+ 2EE6 1F                   rra                     ; Get carry to sign
4358+ 2EE7 A9                   xor     C               ; Combine with MSB of number
4359+ 2EE8 C9                   ret
4360+ 2EE9
4361+ 2EE9 23           CMPFP:  inc     HL              ; Point to exponent
4362+ 2EEA 78                   ld      A,B             ; Get exponent
4363+ 2EEB BE                   cp      (HL)            ; Compare exponents
4364+ 2EEC C0                   ret     NZ              ; Different
4365+ 2EED 2B                   dec     HL              ; Point to MBS
4366+ 2EEE 79                   ld      A,C             ; Get MSB
4367+ 2EEF BE                   cp      (HL)            ; Compare MSBs
4368+ 2EF0 C0                   ret     NZ              ; Different
4369+ 2EF1 2B                   dec     HL              ; Point to NMSB
4370+ 2EF2 7A                   ld      A,D             ; Get NMSB
4371+ 2EF3 BE                   cp      (HL)            ; Compare NMSBs
4372+ 2EF4 C0                   ret     NZ              ; Different
4373+ 2EF5 2B                   dec     HL              ; Point to LSB
4374+ 2EF6 7B                   ld      A,E             ; Get LSB
4375+ 2EF7 96                   sub     (HL)            ; Compare LSBs
4376+ 2EF8 C0                   ret     NZ              ; Different
4377+ 2EF9 E1                   pop     HL              ; Drop RETurn
4378+ 2EFA E1                   pop     HL              ; Drop another RETurn
4379+ 2EFB C9                   ret
4380+ 2EFC
4381+ 2EFC 47           FPINT:  ld      B,A             ; <- Move
4382+ 2EFD 4F                   ld      C,A             ; <- exponent
4383+ 2EFE 57                   ld      D,A             ; <- to all
4384+ 2EFF 5F                   ld      E,A             ; <- bits
4385+ 2F00 B7                   or      A               ; Test exponent
4386+ 2F01 C8                   ret     Z               ; Zero - Return zero
4387+ 2F02 E5                   push    HL              ; Save pointer to number
4388+ 2F03 CD A0 2E             call    BCDEFP          ; Move FPREG to BCDE
4389+ 2F06 CD BA 2E             call    SIGNS           ; Set MSBs & sign of result
4390+ 2F09 AE                   xor     (HL)            ; Combine with sign of FPREG
4391+ 2F0A 67                   ld      H,A             ; Save combined signs
4392+ 2F0B FC 20 2F             call    M,DCBCDE        ; Negative - Decrement BCDE
4393+ 2F0E 3E 98                ld      A,$80+24        ; 24 bits
4394+ 2F10 90                   sub     B               ; Bits to shift
4395+ 2F11 CD 82 2C             call    SCALE           ; Shift BCDE
4396+ 2F14 7C                   ld      A,H             ; Get combined sign
4397+ 2F15 17                   rla                     ; Sign to carry
4398+ 2F16 DC 55 2C             call    C,FPROND        ; Negative - Round number up
4399+ 2F19 06 00                ld      B,$00           ; Zero exponent
4400+ 2F1B DC 6E 2C             call    C,COMPL         ; If negative make positive
4401+ 2F1E E1                   pop     HL              ; Restore pointer to number
4402+ 2F1F C9                   ret
4403+ 2F20
4404+ 2F20 1B           DCBCDE: dec     DE              ; Decrement BCDE
4405+ 2F21 7A                   ld      A,D             ; Test LSBs
4406+ 2F22 A3                   and     E
4407+ 2F23 3C                   inc     A
4408+ 2F24 C0                   ret     NZ              ; Exit if LSBs not FFFF
4409+ 2F25 0B                   dec     BC              ; Decrement MSBs
4410+ 2F26 C9                   ret
4411+ 2F27
4412+ 2F27 21 24 53     INT:    ld      HL,FPEXP        ; Point to exponent
4413+ 2F2A 7E                   ld      A,(HL)          ; Get exponent
4414+ 2F2B FE 98                cp      $80+24          ; Integer accuracy only?
4415+ 2F2D 3A 21 53             ld      A,(FPREG)       ; Get LSB
4416+ 2F30 D0                   ret     NC              ; Yes - Already integer
4417+ 2F31 7E                   ld      A,(HL)          ; Get exponent
4418+ 2F32 CD FC 2E             call    FPINT           ; F.P to integer
4419+ 2F35 36 98                ld      (HL),$80+24     ; Save 24 bit integer
4420+ 2F37 7B                   ld      A,E             ; Get LSB of number
4421+ 2F38 F5                   push    AF              ; Save LSB
4422+ 2F39 79                   ld      A,C             ; Get MSB of number
4423+ 2F3A 17                   rla                     ; Sign to carry
4424+ 2F3B CD 0B 2C             call    CONPOS          ; Set sign of result
4425+ 2F3E F1                   pop     AF              ; Restore LSB of number
4426+ 2F3F C9                   ret
4427+ 2F40
4428+ 2F40 21 00 00     MLDEBC: ld      HL,$0000        ; Clear partial product
4429+ 2F43 78                   ld      A,B             ; Test multiplier
4430+ 2F44 B1                   or      C
4431+ 2F45 C8                   ret     Z               ; Return zero if zero
4432+ 2F46 3E 10                ld      A,$10           ; 16 bits
4433+ 2F48 29           MLDBLP: add     HL,HL           ; Shift P.P left
4434+ 2F49 DA 6E 23             jp      C,BSERR         ; ?BS Error if overflow
4435+ 2F4C EB                   ex      DE,HL
4436+ 2F4D 29                   add     HL,HL           ; Shift multiplier left
4437+ 2F4E EB                   ex      DE,HL
4438+ 2F4F D2 56 2F             jp      NC,NOMLAD       ; Bit was zero - No add
4439+ 2F52 09                   add     HL,BC           ; Add multiplicand
4440+ 2F53 DA 6E 23             jp      C,BSERR         ; ?BS Error if overflow
4441+ 2F56 3D           NOMLAD: dec     A               ; Count bits
4442+ 2F57 C2 48 2F             jp      NZ,MLDBLP       ; More
4443+ 2F5A C9                   ret
4444+ 2F5B
4445+ 2F5B FE 2D        ASCTFP: cp      '-'             ; Negative?
4446+ 2F5D F5                   push    AF              ; Save it and flags
4447+ 2F5E CA 67 2F             jp      Z,CNVNUM        ; Yes - Convert number
4448+ 2F61 FE 2B                cp      '+'             ; Positive?
4449+ 2F63 CA 67 2F             jp      Z,CNVNUM        ; Yes - Convert number
4450+ 2F66 2B                   dec     HL              ; dec 'cos GETCHR INCs
4451+ 2F67 CD 23 2C     CNVNUM: call    RESZER          ; Set result to zero
4452+ 2F6A 47                   ld      B,A             ; Digits after point counter
4453+ 2F6B 57                   ld      D,A             ; Sign of exponent
4454+ 2F6C 5F                   ld      E,A             ; Exponent of ten
4455+ 2F6D 2F                   cpl
4456+ 2F6E 4F                   ld      C,A             ; Before or after point flag
4457+ 2F6F CD BE 1B     MANLP:  call    GETCHR          ; Get next character
4458+ 2F72 DA B8 2F             jp      C,ADDIG         ; Digit - Add to number
4459+ 2F75 FE 2E                cp      '.'
4460+ 2F77 CA 93 2F             jp      Z,DPOINT        ; '.' - Flag point
4461+ 2F7A FE 45                cp      'E'
4462+ 2F7C C2 97 2F             jp      NZ,CONEXP       ; Not 'E' - Scale number
4463+ 2F7F CD BE 1B             call    GETCHR          ; Get next character
4464+ 2F82 CD 8A 21             call    SGNEXP          ; Get sign of exponent
4465+ 2F85 CD BE 1B     EXPLP:  call    GETCHR          ; Get next character
4466+ 2F88 DA DA 2F             jp      C,EDIGIT        ; Digit - Add to exponent
4467+ 2F8B 14                   inc     D               ; Is sign negative?
4468+ 2F8C C2 97 2F             jp      NZ,CONEXP       ; No - Scale number
4469+ 2F8F AF                   xor     A
4470+ 2F90 93                   sub     E               ; Negate exponent
4471+ 2F91 5F                   ld      E,A             ; And re-save it
4472+ 2F92 0C                   inc     C               ; Flag end of number
4473+ 2F93 0C           DPOINT: inc     C               ; Flag point passed
4474+ 2F94 CA 6F 2F             jp      Z,MANLP         ; Zero - Get another digit
4475+ 2F97 E5           CONEXP: push    HL              ; Save code string address
4476+ 2F98 7B                   ld      A,E             ; Get exponent
4477+ 2F99 90                   sub     B               ; Subtract digits after point
4478+ 2F9A F4 B0 2F     SCALMI: call    P,SCALPL        ; Positive - Multiply number
4479+ 2F9D F2 A6 2F             jp      P,ENDCON        ; Positive - All done
4480+ 2FA0 F5                   push    AF              ; Save number of times to /10
4481+ 2FA1 CD 9C 2D             call    DIV10           ; Divide by 10
4482+ 2FA4 F1                   pop     AF              ; Restore count
4483+ 2FA5 3C                   inc     A               ; Count divides
4484+ 2FA6
4485+ 2FA6 C2 9A 2F     ENDCON: jp      NZ,SCALMI       ; More to do
4486+ 2FA9 D1                   pop     DE              ; Restore code string address
4487+ 2FAA F1                   pop     AF              ; Restore sign of number
4488+ 2FAB CC 7D 2E             call    Z,INVSGN        ; Negative - Negate number
4489+ 2FAE EB                   ex      DE,HL           ; Code string address to HL
4490+ 2FAF C9                   ret
4491+ 2FB0
4492+ 2FB0 C8           SCALPL: ret     Z               ; Exit if no scaling needed
4493+ 2FB1 F5           MULTEN: push    AF              ; Save count
4494+ 2FB2 CD 3D 2E             call    MLSP10          ; Multiply number by 10
4495+ 2FB5 F1                   pop     AF              ; Restore count
4496+ 2FB6 3D                   dec     A               ; Count multiplies
4497+ 2FB7 C9                   ret
4498+ 2FB8
4499+ 2FB8 D5           ADDIG:  push    DE              ; Save sign of exponent
4500+ 2FB9 57                   ld      D,A             ; Save digit
4501+ 2FBA 78                   ld      A,B             ; Get digits after point
4502+ 2FBB 89                   adc     A,C             ; Add one if after point
4503+ 2FBC 47                   ld      B,A             ; Re-save counter
4504+ 2FBD C5                   push    BC              ; Save point flags
4505+ 2FBE E5                   push    HL              ; Save code string address
4506+ 2FBF D5                   push    DE              ; Save digit
4507+ 2FC0 CD 3D 2E             call    MLSP10          ; Multiply number by 10
4508+ 2FC3 F1                   pop     AF              ; Restore digit
4509+ 2FC4 D6 30                sub     '0'             ; Make it absolute
4510+ 2FC6 CD CF 2F             call    RSCALE          ; Re-scale number
4511+ 2FC9 E1                   pop     HL              ; Restore code string address
4512+ 2FCA C1                   pop     BC              ; Restore point flags
4513+ 2FCB D1                   pop     DE              ; Restore sign of exponent
4514+ 2FCC C3 6F 2F             jp      MANLP           ; Get another digit
4515+ 2FCF
4516+ 2FCF CD 85 2E     RSCALE: call    STAKFP          ; Put number on stack
4517+ 2FD2 CD 66 2E             call    FLGREL          ; Digit to add to FPREG
4518+ 2FD5 C1           PADD:   pop     BC              ; Restore number
4519+ 2FD6 D1                   pop     DE
4520+ 2FD7 C3 BD 2B             jp      FPADD           ; Add BCDE to FPREG and return
4521+ 2FDA
4522+ 2FDA 7B           EDIGIT: ld      A,E             ; Get digit
4523+ 2FDB 07                   rlca                    ; Times 2
4524+ 2FDC 07                   rlca                    ; Times 4
4525+ 2FDD 83                   add     A,E             ; Times 5
4526+ 2FDE 07                   rlca                    ; Times 10
4527+ 2FDF 86                   add     A,(HL)          ; Add next digit
4528+ 2FE0 D6 30                sub     '0'             ; Make it absolute
4529+ 2FE2 5F                   ld      E,A             ; Save new digit
4530+ 2FE3 C3 85 2F             jp      EXPLP           ; Look for another digit
4531+ 2FE6
4532+ 2FE6 E5           LINEIN: push    HL              ; Save code string address
4533+ 2FE7 21 14 16             ld      HL,INMSG        ; Output " in "
4534+ 2FEA CD 4F 25             call    PRS             ; Output string at HL
4535+ 2FED E1                   pop     HL              ; Restore code string address
4536+ 2FEE EB           PRNTHL: ex      DE,HL           ; Code string address to DE
4537+ 2FEF AF                   xor     A
4538+ 2FF0 06 98                ld      B,$80+24        ; 24 bits
4539+ 2FF2 CD 6B 2E             call    RETINT          ; Return the integer
4540+ 2FF5 21 4E 25             ld      HL,PRNUMS       ; Print number string
4541+ 2FF8 E5                   push    HL              ; Save for return
4542+ 2FF9 21 26 53     NUMASC: ld      HL,PBUFF        ; Convert number to ASCII
4543+ 2FFC E5                   push    HL              ; Save for return
4544+ 2FFD CD 54 2E             call    TSTSGN          ; Test sign of FPREG
4545+ 3000 36 20                ld      (HL),SPC        ; Space at start
4546+ 3002 F2 07 30             jp      P,SPCFST        ; Positive - Space to start
4547+ 3005 36 2D                ld      (HL),'-'        ; '-' sign at start
4548+ 3007 23           SPCFST: inc     HL              ; First byte of number
4549+ 3008 36 30                ld      (HL),'0'        ; '0' if zero
4550+ 300A CA BD 30             jp      Z,JSTZER        ; Return '0' if zero
4551+ 300D E5                   push    HL              ; Save buffer address
4552+ 300E FC 7D 2E             call    M,INVSGN        ; Negate FPREG if negative
4553+ 3011 AF                   xor     A               ; Zero A
4554+ 3012 F5                   push    AF              ; Save it
4555+ 3013 CD C3 30             call    RNGTST          ; Test number is in range
4556+ 3016 01 43 91     SIXDIG: ld      BC,$9143        ; BCDE - 99999.9
4557+ 3019 11 F8 4F             ld      DE,$4FF8
4558+ 301C CD CF 2E             call    CMPNUM          ; Compare numbers
4559+ 301F B7                   or      A
4560+ 3020 E2 34 30             jp      PO,INRNG        ; > 99999.9 - Sort it out
4561+ 3023 F1                   pop     AF              ; Restore count
4562+ 3024 CD B1 2F             call    MULTEN          ; Multiply by ten
4563+ 3027 F5                   push    AF              ; Re-save count
4564+ 3028 C3 16 30             jp      SIXDIG          ; Test it again
4565+ 302B
4566+ 302B CD 9C 2D     GTSIXD: call    DIV10           ; Divide by 10
4567+ 302E F1                   pop     AF              ; Get count
4568+ 302F 3C                   inc     A               ; Count divides
4569+ 3030 F5                   push    AF              ; Re-save count
4570+ 3031 CD C3 30             call    RNGTST          ; Test number is in range
4571+ 3034 CD AB 2B     INRNG:  call    ROUND           ; Add 0.5 to FPREG
4572+ 3037 3C                   inc     A
4573+ 3038 CD FC 2E             call    FPINT           ; F.P to integer
4574+ 303B CD 95 2E             call    FPBCDE          ; Move BCDE to FPREG
4575+ 303E 01 06 03             ld      BC,$0306        ; 1E+06 to 1E-03 range
4576+ 3041 F1                   pop     AF              ; Restore count
4577+ 3042 81                   add     A,C             ; 6 digits before point
4578+ 3043 3C                   inc     A               ; Add one
4579+ 3044 FA 50 30             jp      M,MAKNUM        ; Do it in 'E' form if < 1E-02
4580+ 3047 FE 08                cp      6+1+1           ; More than 999999 ?
4581+ 3049 D2 50 30             jp      NC,MAKNUM       ; Yes - Do it in 'E' form
4582+ 304C 3C                   inc     A               ; Adjust for exponent
4583+ 304D 47                   ld      B,A             ; Exponent of number
4584+ 304E 3E 02                ld      A,2             ; Make it zero after
4585+ 3050
4586+ 3050 3D           MAKNUM: dec     A               ; Adjust for digits to do
4587+ 3051 3D                   dec     A
4588+ 3052 E1                   pop     HL              ; Restore buffer address
4589+ 3053 F5                   push    AF              ; Save count
4590+ 3054 11 D6 30             ld      DE,POWERS       ; Powers of ten
4591+ 3057 05                   dec     B               ; Count digits before point
4592+ 3058 C2 61 30             jp      NZ,DIGTXT       ; Not zero - Do number
4593+ 305B 36 2E                ld      (HL),'.'        ; Save point
4594+ 305D 23                   inc     HL              ; Move on
4595+ 305E 36 30                ld      (HL),'0'        ; Save zero
4596+ 3060 23                   inc     HL              ; Move on
4597+ 3061 05           DIGTXT: dec     B               ; Count digits before point
4598+ 3062 36 2E                ld      (HL),'.'        ; Save point in case
4599+ 3064 CC AA 2E             call    Z,INCHL         ; Last digit - move on
4600+ 3067 C5                   push    BC              ; Save digits before point
4601+ 3068 E5                   push    HL              ; Save buffer address
4602+ 3069 D5                   push    DE              ; Save powers of ten
4603+ 306A CD A0 2E             call    BCDEFP          ; Move FPREG to BCDE
4604+ 306D E1                   pop     HL              ; Powers of ten table
4605+ 306E 06 2F                ld      B,'0'-1         ; ASCII '0' - 1
4606+ 3070 04           TRYAGN: inc     B               ; Count subtractions
4607+ 3071 7B                   ld      A,E             ; Get LSB
4608+ 3072 96                   sub     (HL)            ; Subtract LSB
4609+ 3073 5F                   ld      E,A             ; Save LSB
4610+ 3074 23                   inc     HL
4611+ 3075 7A                   ld      A,D             ; Get NMSB
4612+ 3076 9E                   sbc     A,(HL)          ; Subtract NMSB
4613+ 3077 57                   ld      D,A             ; Save NMSB
4614+ 3078 23                   inc     HL
4615+ 3079 79                   ld      A,C             ; Get MSB
4616+ 307A 9E                   sbc     A,(HL)          ; Subtract MSB
4617+ 307B 4F                   ld      C,A             ; Save MSB
4618+ 307C 2B                   dec     HL              ; Point back to start
4619+ 307D 2B                   dec     HL
4620+ 307E D2 70 30             jp      NC,TRYAGN       ; No overflow - Try again
4621+ 3081 CD 62 2C             call    PLUCDE          ; Restore number
4622+ 3084 23                   inc     HL              ; Start of next number
4623+ 3085 CD 95 2E             call    FPBCDE          ; Move BCDE to FPREG
4624+ 3088 EB                   ex      DE,HL           ; Save point in table
4625+ 3089 E1                   pop     HL              ; Restore buffer address
4626+ 308A 70                   ld      (HL),B          ; Save digit in buffer
4627+ 308B 23                   inc     HL              ; And move on
4628+ 308C C1                   pop     BC              ; Restore digit count
4629+ 308D 0D                   dec     C               ; Count digits
4630+ 308E C2 61 30             jp      NZ,DIGTXT       ; More - Do them
4631+ 3091 05                   dec     B               ; Any decimal part?
4632+ 3092 CA A1 30             jp      Z,DOEBIT        ; No - Do 'E' bit
4633+ 3095 2B           SUPTLZ: dec     HL              ; Move back through buffer
4634+ 3096 7E                   ld      A,(HL)          ; Get character
4635+ 3097 FE 30                cp      '0'             ; '0' character?
4636+ 3099 CA 95 30             jp      Z,SUPTLZ        ; Yes - Look back for more
4637+ 309C FE 2E                cp      '.'             ; A decimal point?
4638+ 309E C4 AA 2E             call    NZ,INCHL        ; Move back over digit
4639+ 30A1
4640+ 30A1 F1           DOEBIT: pop     AF              ; Get 'E' flag
4641+ 30A2 CA C0 30             jp      Z,NOENED        ; No 'E' needed - End buffer
4642+ 30A5 36 45                ld      (HL),'E'        ; Put 'E' in buffer
4643+ 30A7 23                   inc     HL              ; And move on
4644+ 30A8 36 2B                ld      (HL),'+'        ; Put '+' in buffer
4645+ 30AA F2 B1 30             jp      P,OUTEXP        ; Positive - Output exponent
4646+ 30AD 36 2D                ld      (HL),'-'        ; Put '-' in buffer
4647+ 30AF 2F                   cpl                     ; Negate exponent
4648+ 30B0 3C                   inc     A
4649+ 30B1 06 2F        OUTEXP: ld      B,'0'-1         ; ASCII '0' - 1
4650+ 30B3 04           EXPTEN: inc     B               ; Count subtractions
4651+ 30B4 D6 0A                sub     $0A             ; Tens digit
4652+ 30B6 D2 B3 30             jp      NC,EXPTEN       ; More to do
4653+ 30B9 C6 3A                add     A,'0'+10        ; Restore and make ASCII
4654+ 30BB 23                   inc     HL              ; Move on
4655+ 30BC 70                   ld      (HL),B          ; Save MSB of exponent
4656+ 30BD 23           JSTZER: inc     HL              ;
4657+ 30BE 77                   ld      (HL),A          ; Save LSB of exponent
4658+ 30BF 23                   inc     HL
4659+ 30C0 71           NOENED: ld      (HL),C          ; Mark end of buffer
4660+ 30C1 E1                   pop     HL              ; Restore code string address
4661+ 30C2 C9                   ret
4662+ 30C3
4663+ 30C3 01 74 94     RNGTST: ld      BC,$9474        ; BCDE = 999999.
4664+ 30C6 11 F7 23             ld      DE,$23F7
4665+ 30C9 CD CF 2E             call    CMPNUM          ; Compare numbers
4666+ 30CC B7                   or      A
4667+ 30CD E1                   pop     HL              ; Return address to HL
4668+ 30CE E2 2B 30             jp      PO,GTSIXD       ; Too big - Divide by ten
4669+ 30D1 E9                   jp      (HL)            ; Otherwise return to caller
4670+ 30D2
4671+ 30D2 00 00 00 80  HALF:   defb    $00,$00,$00,$80 ; 0.5
4672+ 30D6
4673+ 30D6 A0 86 01     POWERS: defb    $A0,$86,$01  ; 100000
4674+ 30D9 10 27 00             defb    $10,$27,$00  ;  10000
4675+ 30DC E8 03 00             defb    $E8,$03,$00  ;   1000
4676+ 30DF 64 00 00             defb    $64,$00,$00  ;    100
4677+ 30E2 0A 00 00             defb    $0A,$00,$00  ;     10
4678+ 30E5 01 00 00             defb    $01,$00,$00  ;      1
4679+ 30E8
4680+ 30E8 21 7D 2E     NEGAFT: ld      HL,INVSGN       ; Negate result
4681+ 30EB E3                   ex      (SP),HL         ; To be done after caller
4682+ 30EC E9                   jp      (HL)            ; Return to caller
4683+ 30ED
4684+ 30ED CD 85 2E     SQR:    call    STAKFP          ; Put value on stack
4685+ 30F0 21 D2 30             ld      HL,HALF         ; Set power to 1/2
4686+ 30F3 CD 92 2E             call    PHLTFP          ; Move 1/2 to FPREG
4687+ 30F6
4688+ 30F6 C1           POWER:  pop     BC              ; Get base
4689+ 30F7 D1                   pop     DE
4690+ 30F8 CD 54 2E             call    TSTSGN          ; Test sign of power
4691+ 30FB 78                   ld      A,B             ; Get exponent of base
4692+ 30FC CA 3B 31             jp      Z,EXP           ; Make result 1 if zero
4693+ 30FF F2 06 31             jp      P,POWER1        ; Positive base - Ok
4694+ 3102 B7                   or      A               ; Zero to negative power?
4695+ 3103 CA 9E 16             jp      Z,DZERR         ; Yes - ?/0 Error
4696+ 3106 B7           POWER1: or      A               ; Base zero?
4697+ 3107 CA 24 2C             jp      Z,SAVEXP        ; Yes - Return zero
4698+ 310A D5                   push    DE              ; Save base
4699+ 310B C5                   push    BC
4700+ 310C 79                   ld      A,C             ; Get MSB of base
4701+ 310D F6 7F                or      %01111111       ; Get sign status
4702+ 310F CD A0 2E             call    BCDEFP          ; Move power to BCDE
4703+ 3112 F2 23 31             jp      P,POWER2        ; Positive base - Ok
4704+ 3115 D5                   push    DE              ; Save power
4705+ 3116 C5                   push    BC
4706+ 3117 CD 27 2F             call    INT             ; Get integer of power
4707+ 311A C1                   pop     BC              ; Restore power
4708+ 311B D1                   pop     DE
4709+ 311C F5                   push    AF              ; MSB of base
4710+ 311D CD CF 2E             call    CMPNUM          ; Power an integer?
4711+ 3120 E1                   pop     HL              ; Restore MSB of base
4712+ 3121 7C                   ld      A,H             ; but don't affect flags
4713+ 3122 1F                   rra                     ; Exponent odd or even?
4714+ 3123 E1           POWER2: pop     HL              ; Restore MSB and exponent
4715+ 3124 22 23 53             ld      (FPREG+2),HL    ; Save base in FPREG
4716+ 3127 E1                   pop     HL              ; LSBs of base
4717+ 3128 22 21 53             ld      (FPREG),HL      ; Save in FPREG
4718+ 312B DC E8 30             call    C,NEGAFT        ; Odd power - Negate result
4719+ 312E CC 7D 2E             call    Z,INVSGN        ; Negative base - Negate it
4720+ 3131 D5                   push    DE              ; Save power
4721+ 3132 C5                   push    BC
4722+ 3133 CD B7 2C             call    LOG             ; Get LOG of base
4723+ 3136 C1                   pop     BC              ; Restore power
4724+ 3137 D1                   pop     DE
4725+ 3138 CD F8 2C             call    FPMULT          ; Multiply LOG by power
4726+ 313B
4727+ 313B CD 85 2E     EXP:    call    STAKFP          ; Put value on stack
4728+ 313E 01 38 81             ld      BC,$8138        ; BCDE = 1/Ln(2)
4729+ 3141 11 3B AA             ld      DE,$AA3B
4730+ 3144 CD F8 2C             call    FPMULT          ; Multiply value by 1/LN(2)
4731+ 3147 3A 24 53             ld      A,(FPEXP)       ; Get exponent
4732+ 314A FE 88                cp      $80+8           ; Is it in range?
4733+ 314C D2 30 2E             jp      NC,OVTST1       ; No - Test for overflow
4734+ 314F CD 27 2F             call    INT             ; Get INT of FPREG
4735+ 3152 C6 80                add     A,$80           ; For excess 128
4736+ 3154 C6 02                add     A,$02           ; Exponent > 126?
4737+ 3156 DA 30 2E             jp      C,OVTST1        ; Yes - Test for overflow
4738+ 3159 F5                   push    AF              ; Save scaling factor
4739+ 315A 21 A6 2C             ld      HL,UNITY        ; Point to 1.
4740+ 315D CD AE 2B             call    ADDPHL          ; Add 1 to FPREG
4741+ 3160 CD EF 2C             call    MULLN2          ; Multiply by LN(2)
4742+ 3163 F1                   pop     AF              ; Restore scaling factor
4743+ 3164 C1                   pop     BC              ; Restore exponent
4744+ 3165 D1                   pop     DE
4745+ 3166 F5                   push    AF              ; Save scaling factor
4746+ 3167 CD BA 2B             call    SUBCDE          ; Subtract exponent from FPREG
4747+ 316A CD 7D 2E             call    INVSGN          ; Negate result
4748+ 316D 21 7B 31             ld      HL,EXPTAB       ; Coefficient table
4749+ 3170 CD AB 31             call    SMSER1          ; Sum the series
4750+ 3173 11 00 00             ld      DE,$0000        ; Zero LSBs
4751+ 3176 C1                   pop     BC              ; Scaling factor
4752+ 3177 4A                   ld      C,D             ; Zero MSB
4753+ 3178 C3 F8 2C             jp      FPMULT          ; Scale result to correct value
4754+ 317B
4755+ 317B 08           EXPTAB: defb    $08             ; Table used by EXP
4756+ 317C 40 2E 94 74          defb    $40,$2E,$94,$74 ; -1/7! (-1/5040)
4757+ 3180 70 4F 2E 77          defb    $70,$4F,$2E,$77 ;  1/6! ( 1/720)
4758+ 3184 6E 02 88 7A          defb    $6E,$02,$88,$7A ; -1/5! (-1/120)
4759+ 3188 E6 A0 2A 7C          defb    $E6,$A0,$2A,$7C ;  1/4! ( 1/24)
4760+ 318C 50 AA AA 7E          defb    $50,$AA,$AA,$7E ; -1/3! (-1/6)
4761+ 3190 FF FF 7F 7F          defb    $FF,$FF,$7F,$7F ;  1/2! ( 1/2)
4762+ 3194 00 00 80 81          defb    $00,$00,$80,$81 ; -1/1! (-1/1)
4763+ 3198 00 00 00 81          defb    $00,$00,$00,$81 ;  1/0! ( 1/1)
4764+ 319C
4765+ 319C CD 85 2E     SUMSER: call    STAKFP          ; Put FPREG on stack
4766+ 319F 11 F6 2C             ld      DE,MULT         ; Multiply by "X"
4767+ 31A2 D5                   push    DE              ; To be done after
4768+ 31A3 E5                   push    HL              ; Save address of table
4769+ 31A4 CD A0 2E             call    BCDEFP          ; Move FPREG to BCDE
4770+ 31A7 CD F8 2C             call    FPMULT          ; Square the value
4771+ 31AA E1                   pop     HL              ; Restore address of table
4772+ 31AB CD 85 2E     SMSER1: call    STAKFP          ; Put value on stack
4773+ 31AE 7E                   ld      A,(HL)          ; Get number of coefficients
4774+ 31AF 23                   inc     HL              ; Point to start of table
4775+ 31B0 CD 92 2E             call    PHLTFP          ; Move coefficient to FPREG
4776+ 31B3 06                   defb    06H             ; Skip "pop AF"
4777+ 31B4 F1           SUMLP:  pop     AF              ; Restore count
4778+ 31B5 C1                   pop     BC              ; Restore number
4779+ 31B6 D1                   pop     DE
4780+ 31B7 3D                   dec     A               ; Cont coefficients
4781+ 31B8 C8                   ret     Z               ; All done
4782+ 31B9 D5                   push    DE              ; Save number
4783+ 31BA C5                   push    BC
4784+ 31BB F5                   push    AF              ; Save count
4785+ 31BC E5                   push    HL              ; Save address in table
4786+ 31BD CD F8 2C             call    FPMULT          ; Multiply FPREG by BCDE
4787+ 31C0 E1                   pop     HL              ; Restore address in table
4788+ 31C1 CD A3 2E             call    LOADFP          ; Number at HL to BCDE
4789+ 31C4 E5                   push    HL              ; Save address in table
4790+ 31C5 CD BD 2B             call    FPADD           ; Add coefficient to FPREG
4791+ 31C8 E1                   pop     HL              ; Restore address in table
4792+ 31C9 C3 B4 31             jp      SUMLP           ; More coefficients
4793+ 31CC
4794+ 31CC
4795+ 31CC              ; random number generator
4796+ 31CC              ; a negative argument is used as a seed for the RNG
4797+ 31CC              ; 0 is used to repeat the last random number
4798+ 31CC              ; a positive argument generates a new random number
4799+ 31CC CD 54 2E     RND:    call    TSTSGN          ; Test sign of FPREG
4800+ 31CF 21 69 51             ld      HL,SEED+2       ; Random number seed
4801+ 31D2 FA 2D 32             jp      M,RESEED        ; Negative - Re-seed
4802+ 31D5 21 8A 51             ld      HL,LSTRND       ; Last random number
4803+ 31D8 CD 92 2E             call    PHLTFP          ; Move last RND to FPREG
4804+ 31DB 21 69 51             ld      HL,SEED+2       ; Random number seed
4805+ 31DE C8                   ret     Z               ; Return if RND(0)
4806+ 31DF 86                   add     A,(HL)          ; Add (SEED)+2)
4807+ 31E0 E6 07                and     %00000111       ; 0 to 7
4808+ 31E2 06 00                ld      B,$00
4809+ 31E4 77                   ld      (HL),A          ; Re-save seed
4810+ 31E5 23                   inc     HL              ; Move to coefficient table
4811+ 31E6 87                   add     A,A             ; 4 bytes
4812+ 31E7 87                   add     A,A             ; per entry
4813+ 31E8 4F                   ld      C,A             ; BC = Offset into table
4814+ 31E9 09                   add     HL,BC           ; Point to coefficient
4815+ 31EA CD A3 2E             call    LOADFP          ; Coefficient to BCDE
4816+ 31ED CD F8 2C             call    FPMULT  ;       ; Multiply FPREG by coefficient
4817+ 31F0 3A 68 51             ld      A,(SEED+1)      ; Get (SEED+1)
4818+ 31F3 3C                   inc     A               ; Add 1
4819+ 31F4 E6 03                and     %00000011       ; 0 to 3
4820+ 31F6 06 00                ld      B,$00
4821+ 31F8 FE 01                cp      $01             ; Is it zero?
4822+ 31FA 88                   adc     A,B             ; Yes - Make it 1
4823+ 31FB 32 68 51             ld      (SEED+1),A      ; Re-save seed
4824+ 31FE 21 31 32             ld      HL,RNDTAB-4     ; Addition table
4825+ 3201 87                   add     A,A             ; 4 bytes
4826+ 3202 87                   add     A,A             ; per entry
4827+ 3203 4F                   ld      C,A             ; BC = Offset into table
4828+ 3204 09                   add     HL,BC           ; Point to value
4829+ 3205 CD AE 2B             call    ADDPHL          ; Add value to FPREG
4830+ 3208 CD A0 2E     RND1:   call    BCDEFP          ; Move FPREG to BCDE
4831+ 320B 7B                   ld      A,E             ; Get LSB
4832+ 320C 59                   ld      E,C             ; LSB = MSB
4833+ 320D EE 4F                xor     %01001111       ; Fiddle around
4834+ 320F 4F                   ld      C,A             ; New MSB
4835+ 3210 36 80                ld      (HL),$80        ; Set exponent
4836+ 3212 2B                   dec     HL              ; Point to MSB
4837+ 3213 46                   ld      B,(HL)          ; Get MSB
4838+ 3214 36 80                ld      (HL),$80        ; Make value -0.5
4839+ 3216 21 67 51             ld      HL,SEED         ; Random number seed
4840+ 3219 34                   inc     (HL)            ; Count seed
4841+ 321A 7E                   ld      A,(HL)          ; Get seed
4842+ 321B D6 AB                sub     $AB             ; Do it modulo 171
4843+ 321D C2 24 32             jp      NZ,RND2         ; Non-zero - Ok
4844+ 3220 77                   ld      (HL),A          ; Zero seed
4845+ 3221 0C                   inc     C               ; Fillde about
4846+ 3222 15                   dec     D               ; with the
4847+ 3223 1C                   inc     E               ; number
4848+ 3224 CD 0E 2C     RND2:   call    BNORM           ; Normalise number
4849+ 3227 21 8A 51             ld      HL,LSTRND       ; Save random number
4850+ 322A C3 AC 2E             jp      FPTHL           ; Move FPREG to last and return
4851+ 322D
4852+ 322D 77           RESEED: ld      (HL),A          ; Re-seed random numbers
4853+ 322E 2B                   dec     HL
4854+ 322F 77                   ld      (HL),A
4855+ 3230 2B                   dec     HL
4856+ 3231 77                   ld      (HL),A
4857+ 3232 C3 08 32             jp      RND1            ; Return RND seed
4858+ 3235
4859+ 3235 68 B1 46 68  RNDTAB: defb    $68,$B1,$46,$68 ; Table used by RND
4860+ 3239 99 E9 92 69          defb    $99,$E9,$92,$69
4861+ 323D 10 D1 75 68          defb    $10,$D1,$75,$68
4862+ 3241
4863+ 3241              ; COS and SIN functions
4864+ 3241 21 8B 32     COS:    ld      HL,HALFPI       ; Point to PI/2
4865+ 3244 CD AE 2B             call    ADDPHL          ; Add it to PPREG
4866+ 3247 CD 85 2E     SIN:    call    STAKFP          ; Put angle on stack
4867+ 324A 01 49 83             ld      BC,$8349        ; BCDE = 2 PI
4868+ 324D 11 DB 0F             ld      DE,$0FDB
4869+ 3250 CD 95 2E             call    FPBCDE          ; Move 2 PI to FPREG
4870+ 3253 C1                   pop     BC              ; Restore angle
4871+ 3254 D1                   pop     DE
4872+ 3255 CD AA 2D             call    DVBCDE          ; Divide angle by 2 PI
4873+ 3258 CD 85 2E             call    STAKFP          ; Put it on stack
4874+ 325B CD 27 2F             call    INT             ; Get INT of result
4875+ 325E C1                   pop     BC              ; Restore number
4876+ 325F D1                   pop     DE
4877+ 3260 CD BA 2B             call    SUBCDE          ; Make it 0 <= value < 1
4878+ 3263 21 8F 32             ld      HL,QUARTR       ; Point to 0.25
4879+ 3266 CD B4 2B             call    SUBPHL          ; Subtract value from 0.25
4880+ 3269 CD 54 2E             call    TSTSGN          ; Test sign of value
4881+ 326C 37                   scf                     ; Flag positive
4882+ 326D F2 77 32             jp      P,SIN1          ; Positive - Ok
4883+ 3270 CD AB 2B             call    ROUND           ; Add 0.5 to value
4884+ 3273 CD 54 2E             call    TSTSGN          ; Test sign of value
4885+ 3276 B7                   or      A               ; Flag negative
4886+ 3277 F5           SIN1:   push    AF              ; Save sign
4887+ 3278 F4 7D 2E             call    P,INVSGN        ; Negate value if positive
4888+ 327B 21 8F 32             ld      HL,QUARTR       ; Point to 0.25
4889+ 327E CD AE 2B             call    ADDPHL          ; Add 0.25 to value
4890+ 3281 F1                   pop     AF              ; Restore sign
4891+ 3282 D4 7D 2E             call    NC,INVSGN       ; Negative - Make positive
4892+ 3285 21 93 32             ld      HL,SINTAB       ; Coefficient table
4893+ 3288 C3 9C 31             jp      SUMSER          ; Evaluate sum of series
4894+ 328B
4895+ 328B DB 0F 49 81  HALFPI: defb    $DB,$0F,$49,$81 ; 1.5708 (PI/2)
4896+ 328F
4897+ 328F 00 00 00 7F  QUARTR: defb    $00,$00,$00,$7F ; 0.25
4898+ 3293
4899+ 3293 05           SINTAB: defb    $05             ; Table used by SIN
4900+ 3294 BA D7 1E 86          defb    $BA,$D7,$1E,$86 ; 39.711
4901+ 3298 64 26 99 87          defb    $64,$26,$99,$87 ;-76.575
4902+ 329C 58 34 23 87          defb    $58,$34,$23,$87 ; 81.602
4903+ 32A0 E0 5D A5 86          defb    $E0,$5D,$A5,$86 ;-41.342
4904+ 32A4 DA 0F 49 83          defb    $DA,$0F,$49,$83 ;  6.2832
4905+ 32A8
4906+ 32A8 CD 85 2E     TAN:    call    STAKFP          ; Put angle on stack
4907+ 32AB CD 47 32             call    SIN             ; Get SIN of angle
4908+ 32AE C1                   pop     BC              ; Restore angle
4909+ 32AF E1                   pop     HL
4910+ 32B0 CD 85 2E             call    STAKFP          ; Save SIN of angle
4911+ 32B3 EB                   ex      DE,HL           ; BCDE = Angle
4912+ 32B4 CD 95 2E             call    FPBCDE          ; Angle to FPREG
4913+ 32B7 CD 41 32             call    COS             ; Get COS of angle
4914+ 32BA C3 A8 2D             jp      DIV             ; TAN = SIN / COS
4915+ 32BD
4916+ 32BD CD 54 2E     ATN:    call    TSTSGN          ; Test sign of value
4917+ 32C0 FC E8 30             call    M,NEGAFT        ; Negate result after if -ve
4918+ 32C3 FC 7D 2E             call    M,INVSGN        ; Negate value if -ve
4919+ 32C6 3A 24 53             ld      A,(FPEXP)       ; Get exponent
4920+ 32C9 FE 81                cp      81H             ; Number less than 1?
4921+ 32CB DA DA 32             jp      C,ATN1          ; Yes - Get arc tangnt
4922+ 32CE 01 00 81             ld      BC,$8100        ; BCDE = 1
4923+ 32D1 51                   ld      D,C
4924+ 32D2 59                   ld      E,C
4925+ 32D3 CD AA 2D             call    DVBCDE          ; Get reciprocal of number
4926+ 32D6 21 B4 2B             ld      HL,SUBPHL       ; Sub angle from PI/2
4927+ 32D9 E5                   push    HL              ; Save for angle > 1
4928+ 32DA 21 E4 32     ATN1:   ld      HL,ATNTAB       ; Coefficient table
4929+ 32DD CD 9C 31             call    SUMSER          ; Evaluate sum of series
4930+ 32E0 21 8B 32             ld      HL,HALFPI       ; PI/2 - angle in case > 1
4931+ 32E3 C9                   ret                     ; Number > 1 - Sub from PI/2
4932+ 32E4
4933+ 32E4 09           ATNTAB: defb    $09             ; Table used by ATN
4934+ 32E5 4A D7 3B 78          defb    $4A,$D7,$3B,$78 ; 1/17
4935+ 32E9 02 6E 84 7B          defb    $02,$6E,$84,$7B ;-1/15
4936+ 32ED FE C1 2F 7C          defb    $FE,$C1,$2F,$7C ; 1/13
4937+ 32F1 74 31 9A 7D          defb    $74,$31,$9A,$7D ;-1/11
4938+ 32F5 84 3D 5A 7D          defb    $84,$3D,$5A,$7D ; 1/9
4939+ 32F9 C8 7F 91 7E          defb    $C8,$7F,$91,$7E ;-1/7
4940+ 32FD E4 BB 4C 7E          defb    $E4,$BB,$4C,$7E ; 1/5
4941+ 3301 6C AA AA 7F          defb    $6C,$AA,$AA,$7F ;-1/3
4942+ 3305 00 00 00 81          defb    $00,$00,$00,$81 ; 1/1
4943+ 3309
4944+ 3309
4945+ 3309 C9           ARET:   ret                     ; A RETurn instruction
4946+ 330A
4947+ 330A D7           GETINP: rst     $10             ; input a character
4948+ 330B C9                   ret
4949+ 330C
4950+ 330C E5           CLS:    push    HL
4951+ 330D D5                   push    DE
4952+ 330E 3A BE 52             ld      A,(SCR_MODE)    ; check screen mode
4953+ 3311 FE 02                cp      $02             ; G2 mode?
4954+ 3313 CC CE 05             call    Z,EMPTYVIDBUF   ; yes, reset video buffer
4955+ 3316 D1                   pop     DE
4956+ 3317 E1                   pop     HL
4957+ 3318 3E 0C                ld      A,CS            ; ASCII Clear screen
4958+ 331A CD BB 19             call    SND2VID         ; send to screen
4959+ 331D C3 61 3F             jp      MONOUT          ; Output character
4960+ 3320
4961+ 3320 CD CD 28     WIDTH:  call    GETINT          ; Get integer 0-255
4962+ 3323 7B                   ld      A,E             ; Width to A
4963+ 3324 32 91 51             ld      (LWIDTH),A      ; Set width
4964+ 3327 C9                   ret
4965+ 3328
4966+ 3328
4967+ 3328              ; read a word (2 bytes) from a couple of RAM locations, in little-endian format
4968+ 3328              ; i.e., the first location is the LSB, while the second one is the MSB
4969+ 3328 CD 74 1C     DEEK:   call    DEINT           ; Get integer -32768 to 32767
4970+ 332B D5                   push    DE              ; Save number
4971+ 332C E1                   pop     HL              ; Number to HL
4972+ 332D 46           RECWRD: ld      B,(HL)          ; Get LSB of contents
4973+ 332E 23                   inc     HL
4974+ 332F 7E                   ld      A,(HL)          ; Get MSB of contents
4975+ 3330 C3 31 24             jp      ABPASS          ; Return integer AB
4976+ 3333
4977+ 3333              ; write a word (2 bytes) into a couple of RAM locations, in little-endian format
4978+ 3333              ; i.e., the LSB will go into the first location, while the MSB into the second one
4979+ 3333 CD 47 20     DOKE:   call    GETNUM          ; Get a number
4980+ 3336 CD 74 1C             call    DEINT           ; Get integer -32768 to 32767
4981+ 3339 D5                   push    DE              ; Save address
4982+ 333A CD 7D 19             call    CHKSYN          ; Make sure ',' follows
4983+ 333D 2C                   defb    ','
4984+ 333E CD 47 20             call    GETNUM          ; Get a number
4985+ 3341 CD 74 1C             call    DEINT           ; Get integer -32768 to 32767
4986+ 3344 E3                   ex      (SP),HL         ; Save value,get address
4987+ 3345 73                   ld      (HL),E          ; Save LSB of value
4988+ 3346 23                   inc     HL
4989+ 3347 72                   ld      (HL),D          ; Save MSB of value
4990+ 3348 E1                   pop     HL              ; Restore code string address
4991+ 3349 C9                   ret
4992+ 334A
4993+ 334A              ; stop the execution of code for a certain bit of time. The pause
4994+ 334A              ; is between $0000 and $FFFF 100ths of a second (0~655.5 secs)
4995+ 334A CD 47 20     PAUSE:  call    GETNUM          ; Get a number
4996+ 334D CD 74 1C             call    DEINT           ; Get integer -32768 to 32767
4997+ 3350 7A                   ld      A,D             ; load D into A
4998+ 3351 B3                   or      E               ; are D & E equal to $00?
4999+ 3352 C8                   ret     Z               ; if yes, then return
5000+ 3353 C5           DIR_PAU:push    BC              ; store BC
5001+ 3354 3A AC 52             ld      A,(TMRCNT)      ; Load current value of system timer
5002+ 3357 47                   ld      B,A             ; move it into B
5003+ 3358 CD E9 1B     RPTPS:  call    TSTBRK          ; Test for break key
5004+ 335B 3A AC 52             ld      A,(TMRCNT)      ; Load current value of system timer
5005+ 335E B8                   cp      B               ; is it the same value?
5006+ 335F 28 F7                jr      Z,RPTPS         ; yes, so read again
5007+ 3361 47                   ld      B,A             ; no, so store the new value
5008+ 3362 1B                   dec     DE              ; decrement interval
5009+ 3363 7A                   ld      A,D             ; load D into A
5010+ 3364 B3                   or      E               ; check if DE is equal to 0 (if D & e are $00 then result is 0)
5011+ 3365 20 F1                jr      NZ,RPTPS        ; no, repeat
5012+ 3367 C1                   pop     BC              ; yes, recover BC and continue
5013+ 3368 C9                   ret
5014+ 3369
5015+ 3369              ; change the screen mode and set some graphic features. Usage: SCREEN X[,Y][,Z]
5016+ 3369              ; where X is graphic mode:
5017+ 3369              ; 0=text mode (40x24), 1=graphic mode 1 (32x24 chars); 2=graphic mode 2 (256x192 pixels);
5018+ 3369              ; 3=multicolor mode (64x48 pixels); 4=extended graphic mode 2 (32x24 chars mixed between G1 and G2)
5019+ 3369              ; Y is: 0=8x8 sprites, 1=16x16 sprites
5020+ 3369              ; Z is: 0=no sprite magnification; 1=sprite magnification x2 (8x8=>16x16, and 16x16=32x32)
5021+ 3369              ; (the latters are accepted only in graphic modes G1, G2, G3, and G4)
5022+ 3369 AF           SCREEN: xor     A
5023+ 336A 32 CF 52             ld      (TMPBFR2),A     ; sprite size & magnif. byte set to 0
5024+ 336D CD CD 28             call    GETINT          ; Get integer 0-255
5025+ 3370 FE 05                cp      $05             ; is it a valid mode (0~4)?
5026+ 3372 D2 89 1C             jp      NC,FCERR        ; No - Illegal function call Error
5027+ 3375 32 CD 52             ld      (TMPBFR1),A     ; store graphic mode
5028+ 3378 A7                   and     A               ; is it 0 (text mode)?
5029+ 3379 CA 95 33             jp      Z,SCVDP         ; yes, ignore other arguments and set mode immediately
5030+ 337C CD D4 33     SETVDP: call    CHKSCAR         ; no, check if sprite size follows
5031+ 337F DA 87 33             jp      C,CKMAGN        ; no (set to 0 or missing), so jump over
5032+ 3382 3E 02                ld      A,$02           ; no, so set sprite size
5033+ 3384 32 CF 52             ld      (TMPBFR2),A     ; ...to 16x16
5034+ 3387 CD D4 33     CKMAGN: call    CHKSCAR         ; check if sprite magnification follows
5035+ 338A DA 95 33             jp      C,SCVDP         ; no (set to 0 or missing), so jump over
5036+ 338D 3A CF 52             ld      A,(TMPBFR2)     ; yes, so retrieve sprite attributes...
5037+ 3390 F6 01                or      $01             ; ...set sprite magnification to 2x...
5038+ 3392 32 CF 52             ld      (TMPBFR2),A     ; ...and save flags again
5039+ 3395 F3           SCVDP:  di                      ; disable INTs
5040+ 3396 D5                   push    DE              ; store DE
5041+ 3397 E5                   push    HL              ; store HL
5042+ 3398 3A CD 52             ld      A,(TMPBFR1)     ; recover graphic mode
5043+ 339B 5F                   ld      E,A             ; and store it into E
5044+ 339C 3A CF 52             ld      A,(TMPBFR2)     ; recover sprite flags
5045+ 339F 57                   ld      D,A             ; and store them into D
5046+ 33A0 D5                   push    DE              ; store D & E
5047+ 33A1 CD D3 03             call    initVDP         ; initialize VDP with mode pointed by E
5048+ 33A4 D1                   pop     DE              ; retrieve D & E
5049+ 33A5 7B                   ld      A,E             ; move graphic mode into A
5050+ 33A6 87                   add     A,A
5051+ 33A7 87                   add     A,A
5052+ 33A8 87                   add     A,A             ; multiply A times 8 to get offset of graphic mode
5053+ 33A9 5F                   ld      E,A             ; and pass it into E
5054+ 33AA D5                   push    DE              ; store sprite flags in E
5055+ 33AB 16 00                ld      D,$00           ; reset D
5056+ 33AD 21 E6 0A             ld      HL,VDPMODESET+1 ; load address of VDP settings for reg#1
5057+ 33B0 19                   add     HL,DE           ; load correct reg#1 setting
5058+ 33B1 D1                   pop     DE              ; retrieve sprite flags from E
5059+ 33B2 7E                   ld      A,(HL)          ; load reg#1 setting
5060+ 33B3 E6 FC                and     %11111100       ; reset size & magn. bits
5061+ 33B5 B2                   or      D               ; set size & magn. bits
5062+ 33B6 5F                   ld      E,A             ; value into E
5063+ 33B7 3E 01                ld      A,$01           ; reg #1
5064+ 33B9 CD A7 06             call    WRITE_VREG      ; send setting to reg #1
5065+ 33BC 2A 9E 51             ld      HL,(LINEAT)     ; Get current line number
5066+ 33BF 23                   inc     HL              ; -1 means direct statement
5067+ 33C0 7C                   ld      A,H
5068+ 33C1 B5                   or      L
5069+ 33C2 CC EA 08             call    Z,CURSOR_ON     ; enable cursor if not in program mode
5070+ 33C5 FB                   ei                      ; re-enable interrupts
5071+ 33C6 E1                   pop     HL              ; restore HL
5072+ 33C7 D1                   pop     DE              ; restore DE
5073+ 33C8 3A BD 52             ld      A,(SCR_SIZE_H)  ; check the screen mode by looking at the screen height
5074+ 33CB FE 30                cp      $30             ; is it 48 chars or 192 pixels (MC and G2 modes)?
5075+ 33CD D0                   ret     NC              ; yes, so exit (in graphics 2 and multicolor no print-on-video)
5076+ 33CE 3E 01                ld      A,$01           ; no (we are in Text, G1 or ExG2), so activate the...
5077+ 33D0 32 C9 52             ld      (PRNTVIDEO),A   ; ...video buffer...
5078+ 33D3 C9                   ret                     ; ...and return to caller
5079+ 33D4
5080+ 33D4              ; check an additional argument for SCREEN - There are 2 ways of working:
5081+ 33D4              ; to check if something follows: Carry is 1 is no argument follows, 0 otherwise
5082+ 33D4              ; to check the value of the following argument: 0 is argument is 1, 1 is argument is <> 1
5083+ 33D4 2B           CHKSCAR:dec     HL              ; dec 'cos GETCHR INCs
5084+ 33D5 CD BE 1B             call    GETCHR          ; Get next character
5085+ 33D8 37                   scf                     ; set carry flag
5086+ 33D9 C8                   ret     Z               ; return if nothing follows with Carry=1
5087+ 33DA CD 7D 19             call    CHKSYN          ; Make sure ',' follows
5088+ 33DD 2C                   defb    ','
5089+ 33DE CD CD 28             call    GETINT          ; get value
5090+ 33E1 1F                   rra                     ; Carry=bit #0
5091+ 33E2 3F                   ccf                     ; invert Carry, so Carry=0 if arg. is 1, and Carry=1 otherwise (arg<>1)
5092+ 33E3 C9                   ret                     ; return
5093+ 33E4
5094+ 33E4
5095+ 33E4              ; change the colors of the screen - Syntax is COLOR a,b,c where:
5096+ 33E4              ; a=foreground color / b=background color / c=border color
5097+ 33E4              ; a,b,c must be in a range between 1 and 15 (0 is transparent and it's not supported)
5098+ 33E4              ; the number of arguments is based on the current screen mode
5099+ 33E4 CD CD 28     COLOR:  call    GETINT          ; get first value
5100+ 33E7 CD 8D 34             call    CHKCLR1         ; check if it's in range 1~15
5101+ 33EA 32 CD 52             ld      (TMPBFR1),A     ; store it
5102+ 33ED 3A BE 52             ld      A,(SCR_MODE)    ; check screen mode
5103+ 33F0 FE 03                cp      $03             ; is it multicolor mode?
5104+ 33F2 20 0D                jr      NZ,CNTCKCL      ; no, continue
5105+ 33F4 3E 0F                ld      A,$0F           ; white for...
5106+ 33F6 32 CB 52             ld      (FRGNDCLR),A    ; ...foreground (even it's not used in MC)
5107+ 33F9 3A CD 52             ld      A,(TMPBFR1)     ; yes, so we stop here because in MC mode we just support border color
5108+ 33FC 32 D1 52             ld      (TMPBFR3),A     ; move color into temp buffer 3
5109+ 33FF 18 31                jr      CLRMC           ; jump to set color
5110+ 3401 CD 7D 19     CNTCKCL:call    CHKSYN          ; Make sure ',' follows
5111+ 3404 2C                   defb    ','
5112+ 3405 CD CD 28             call    GETINT          ; get second value
5113+ 3408 CD 8D 34             call    CHKCLR1         ; check if it's in range 1~15
5114+ 340B 32 CF 52             ld      (TMPBFR2),A     ; store it
5115+ 340E 3A BE 52             ld      A,(SCR_MODE)    ; check screen mode
5116+ 3411 A7                   and     A               ; is it text mode?
5117+ 3412 28 1B                jr      Z,CLRTXT        ; yes, stop here because in text mode, background and border colors coincide
5118+ 3414 CD 7D 19             call    CHKSYN          ; Make sure ',' follows
5119+ 3417 2C                   defb    ','
5120+ 3418 CD CD 28             call    GETINT          ; get third value
5121+ 341B CD 8D 34             call    CHKCLR1         ; check if it's in range 1~15
5122+ 341E 32 D1 52             ld      (TMPBFR3),A     ; store it
5123+ 3421 D5                   push    DE              ; store DE
5124+ 3422 3A BE 52             ld      A,(SCR_MODE)    ; check screen mode
5125+ 3425 FE 01                cp      $01             ; is it G1 mode?
5126+ 3427 28 10                jr      Z,CLRG1         ; yes, jump over
5127+ 3429 FE 02                cp      $02             ; is it G2 mode?
5128+ 342B 28 15                jr      Z,CLRG2         ; yes, jump over
5129+ 342D 18 1C                jr      CLREX2          ; last case can only be ExG2
5130+ 342F CD 80 34     CLRTXT: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5131+ 3432 32 D1 52     CLRMC:  ld      (TMPBFR3),A     ; store color settings (for MC mode, we only set border color)
5132+ 3435 D5                   push    DE              ; store DE
5133+ 3436 F3                   di                      ; disable INTs
5134+ 3437 18 2E                jr      SETBRCL         ; set colors and exit
5135+ 3439 CD 80 34     CLRG1:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5136+ 343C 16 01                ld      D,$01           ; repeat 1 time
5137+ 343E 06 20                ld      B,$20           ; 32 bytes of colors
5138+ 3440 18 10                jr      LOADCLR         ; load colors
5139+ 3442 CD 80 34     CLRG2:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5140+ 3445 16 18                ld      D,$18           ; 18 pages of...
5141+ 3447 06 00                ld      B,$00           ; ...256 bytes each
5142+ 3449 18 07                jr      LOADCLR         ; load colors
5143+ 344B CD 80 34     CLREX2: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5144+ 344E 16 08                ld      D,$08           ; 8 pages of...
5145+ 3450 06 00                ld      B,$00           ; ...256 bytes each
5146+ 3452 E5           LOADCLR:push    HL              ; store HL
5147+ 3453 21 00 20             ld      HL,$2000        ; color table start: $2000
5148+ 3456 F3                   di                      ; disable INTs
5149+ 3457 CD 5D 06             call    SETVDPADRS
5150+ 345A 0E 30                ld      C,VDP_DAT       ; VDP data mode
5151+ 345C ED 79        RPTLDCL:out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
5152+ 345E 00                   nop
5153+ 345F 00                   nop
5154+ 3460 10 FA                djnz    RPTLDCL         ; repeat for 256 bytes (1 page)
5155+ 3462 15                   dec     D               ; did we fill up all the pages?
5156+ 3463 20 F7                jr      NZ,RPTLDCL      ; no, repeat
5157+ 3465 FB                   ei
5158+ 3466 E1                   pop     HL              ; retrieve HL
5159+ 3467 3A CD 52     SETBRCL:ld      A,(TMPBFR1)     ; retrieve foreground color
5160+ 346A 32 CB 52             ld      (FRGNDCLR),A    ; store it
5161+ 346D 3A CF 52             ld      A,(TMPBFR2)     ; retrieve background color
5162+ 3470 32 CC 52             ld      (BKGNDCLR),A    ; store it
5163+ 3473 3A D1 52             ld      A,(TMPBFR3)     ; recover border color
5164+ 3476 5F                   ld      E,A             ; move it into E
5165+ 3477 3E 07                ld      A,$07           ; set VDP register 7
5166+ 3479 F3                   di
5167+ 347A CD A7 06             call    WRITE_VREG      ; send value to VDP: set border color
5168+ 347D FB                   ei                      ; re-enable INTs
5169+ 347E D1                   pop     DE              ; retrieve DE
5170+ 347F C9                   ret                     ; return to caller
5171+ 3480
5172+ 3480
5173+ 3480              ; mix 2 color nibbles in 1 byte
5174+ 3480 3A CF 52     MIXCLRS:ld      A,(TMPBFR2)     ; retrieve background color
5175+ 3483 47                   ld      B,A             ; move it into B
5176+ 3484 3A CD 52             ld      A,(TMPBFR1)     ; retrieve foreground color
5177+ 3487 87                   add     A,A             ; move foreground color into the high nibble of A
5178+ 3488 87                   add     A,A
5179+ 3489 87                   add     A,A
5180+ 348A 87                   add     A,A
5181+ 348B B0                   or      B               ; put background color into the low nibble of A
5182+ 348C C9                   ret                     ; return to caller
5183+ 348D
5184+ 348D
5185+ 348D              ; check if the color is not 0 and into the range 1~15
5186+ 348D A7           CHKCLR1:and     A               ; is it 0?
5187+ 348E CA 9B 16             jp      Z,SNERR         ; yes, raise a SN error
5188+ 3491 FE 10        CHKCLR0:cp      $10             ; is it in range 0~15?
5189+ 3493 D2 9B 16             jp      NC,SNERR        ; no, raise a SN error
5190+ 3496 C9                   ret                     ; param is OK, can return
5191+ 3497
5192+ 3497
5193+ 3497              ; check if in graphics 2 mode
5194+ 3497 3A BE 52     CHKG2M: ld      A,(SCR_MODE)    ; check screen mode
5195+ 349A FE 02                cp      $02             ; actually, we can paint only in G2
5196+ 349C C2 9B 3A             jp      NZ,GMERR        ; no G2, print a No Graphics Mode Error
5197+ 349F C9                   ret                     ; return to caller
5198+ 34A0
5199+ 34A0
5200+ 34A0              ; print a text in screen 2
5201+ 34A0              ; GPRINT text,x,y[,fc[,bc]]
5202+ 34A0              ; where "text" is an expression that can be converted into a sequence of ASCII chars,
5203+ 34A0              ; x & y are the coordinates (0<=x<=31, 0<=y<=23), fc & bc are foreground and background
5204+ 34A0              ; colors (1~15), resp.
5205+ 34A0              ; (portions of code are from nippur72)
5206+ 34A0              GX      equ     TMPBFR3
5207+ 34A0              GY      equ     TMPBFR4
5208+ 34A0              TMPCLR  equ     TMPBFR2
5209+ 34A0              MIXCOL  equ     TMPBFR1
5210+ 34A0              TMPADR  equ     VIDEOBUFF
5211+ 34A0              CHRPNT  equ     VIDEOBUFF+$02
5212+ 34A0              NUMCHR  equ     VIDEOBUFF+$04
5213+ 34A0              TMPHL   equ     VIDEOBUFF+$06
5214+ 34A0 CD 97 34     GPRINT: call    CHKG2M          ; check if in graphic mode 2
5215+ 34A3 2B                   dec     HL              ; dec 'cos GETCHR INCs
5216+ 34A4 CD BE 1B             call    GETCHR          ; check if something follows
5217+ 34A7 CA 9B 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
5218+ 34AA 22 D5 52             ld      (VIDEOBUFF),HL  ; save current code string pointer
5219+ 34AD CD 59 20             call    EVAL            ; Evaluate expression
5220+ 34B0 CD 4B 20             call    TSTSTR          ; Make sure it's a string
5221+ 34B3 22 DB 52             ld      (TMPHL),HL      ; store code string pointer
5222+ 34B6 CD 92 26             call    GSTRCU          ; Current string to pool
5223+ 34B9 CD A3 2E             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
5224+ 34BC ED 43 D7 52          ld      (CHRPNT),BC     ; store string pointer
5225+ 34C0 ED 53 D9 52          ld      (NUMCHR),DE     ; store string lenght
5226+ 34C4 2A DB 52             ld      HL,(TMPHL)      ; store code string pointer
5227+ 34C7 CD 7D 19             call    CHKSYN          ; Make sure ',' follows
5228+ 34CA 2C                   defb    ','
5229+ 34CB CD CD 28             call    GETINT          ; get X coord.
5230+ 34CE FE 20                cp      $20             ; is it in rage 0~31?
5231+ 34D0 D2 89 1C             jp      NC,FCERR        ; Illegal function call error
5232+ 34D3 32 D1 52             ld      (GX),A          ; store into temp. buffer
5233+ 34D6 CD 7D 19             call    CHKSYN          ; Make sure ',' follows
5234+ 34D9 2C                   defb    ','
5235+ 34DA CD CD 28             call    GETINT          ; get Y coord.
5236+ 34DD FE 18                cp      $18             ; is it in range 0~23?
5237+ 34DF D2 89 1C             jp      NC,FCERR        ; Illegal function call error
5238+ 34E2 32 D3 52             ld      (GY),A          ; store into temp. buffer
5239+ 34E5 11 CF 52             ld      DE,TMPCLR
5240+ 34E8 3A CC 52             ld      A,(BKGNDCLR)    ; load background color
5241+ 34EB 12                   ld      (DE),A          ; store into temp buff
5242+ 34EC 3A CB 52             ld      A,(FRGNDCLR)    ; load foreground color
5243+ 34EF 1B                   dec     DE
5244+ 34F0 1B                   dec     DE
5245+ 34F1 12                   ld      (DE),A          ; store into temp buff
5246+ 34F2 CD 7C 35             call    CKCOL           ; check color
5247+ 34F5 CA FD 34             jp      Z,CNTGPT2       ; if anything follows, jump over
5248+ 34F8 13                   inc     DE
5249+ 34F9 13                   inc     DE
5250+ 34FA CD 7C 35             call    CKCOL           ; check background color
5251+ 34FD CD 80 34     CNTGPT2:call    MIXCLRS         ; mix foreground & background colors
5252+ 3500 32 CD 52             ld      (MIXCOL),A      ; store mixed colors
5253+ 3503 E5                   push    HL              ; store code string address
5254+ 3504 ED 4B D7 52          ld      BC,(CHRPNT)     ; retrieve string pointer
5255+ 3508 ED 5B D9 52          ld      DE,(NUMCHR)     ; retrieve string lenght
5256+ 350C 1C                   inc     E               ; Length + 1
5257+ 350D CD 12 35             call    GPNT            ; print on G2
5258+ 3510 E1                   pop     HL              ; recover HL
5259+ 3511 C9                   ret                     ; return to caller
5260+ 3512 D5           GPNT:   push    DE              ; store string lenght (E)
5261+ 3513                      ; calculate VRAM address of first char
5262+ 3513 3A D1 52             LD      A,(GX)          ; load X
5263+ 3516 6F                   ld      L,A             ;
5264+ 3517 26 00                ld      H,0             ; HL = X
5265+ 3519 29                   add     HL,HL           ;
5266+ 351A 29                   add     HL,HL           ;
5267+ 351B 29                   add     HL,HL           ; X=X*8
5268+ 351C 3A D3 52             ld      A,(GY)          ; load Y
5269+ 351F 57                   ld      D,A             ; move it into D
5270+ 3520 1E 00                ld      E,0             ; DE =Y*256
5271+ 3522 19                   add     HL,DE           ; address = X*8 + Y*256
5272+ 3523 22 D5 52             ld      (TMPADR),HL     ; store VRAM address of first VRAM cell
5273+ 3526 D1                   pop     DE              ; retrieve # of chars to be printed yet (E)
5274+ 3527 1D           RPGPNT: dec     E               ; Count characters
5275+ 3528 C8                   ret     Z               ; End of string - return
5276+ 3529 D5                   push    DE              ; store chars counter
5277+ 352A                      ; calculate dest address in color vram
5278+ 352A 2A D5 52             ld      HL,(TMPADR)     ; recover VRAM address
5279+ 352D 11 00 20             ld      DE,$2000        ; color map address
5280+ 3530 19                   add     HL,DE           ; HL = $2000 + XY address
5281+ 3531 F3                   di                      ; disable INTs
5282+ 3532                      ; send color settings
5283+ 3532 CD 5D 06     GPNTCOL:call    SETVDPADRS      ; set VRAM address for color cell
5284+ 3535 3A CD 52             ld      A,(MIXCOL)      ; load color settings
5285+ 3538 06 08                ld      B,$08           ; repeat for 8 rows
5286+ 353A 0D                   dec     C              ; VDP data mode
5287+ 353B ED 79        GPNTCO1:out     (C),A           ; send data (VRAM pointer auto-increments)
5288+ 353D 00                   nop                     ; wait...
5289+ 353E 00                   nop                     ; ...a...
5290+ 353F 00                   nop                     ; ...while
5291+ 3540 10 F9                djnz    GPNTCO1         ; repeat for 8 cells
5292+ 3542                      ; calculate source address
5293+ 3542 2A D7 52             ld      HL,(CHRPNT)     ; load char pointer
5294+ 3545 7E                   ld      A,(HL)          ; get char
5295+ 3546 23                   inc     HL              ; increment char pointer
5296+ 3547 22 D7 52             ld      (CHRPNT),HL     ; store char pointer
5297+ 354A 6F                   ld      L,A             ;
5298+ 354B 26 00                ld      H,$00           ; char into HL
5299+ 354D 29                   add     HL,HL           ;
5300+ 354E 29                   add     HL,HL           ;
5301+ 354F 29                   add     HL,HL           ; get offset of char into ROM (charcode * 8)
5302+ 3550 11 EB 47             ld      DE,CHRST88      ; DE = start of 8x8 fonts in ROM
5303+ 3553 19                   add     HL,DE           ; HL = start of characters in ROM
5304+ 3554 EB                   ex      DE,HL           ; store address into DE
5305+ 3555 2A D5 52     GPCPCHR:ld      HL,(TMPADR)     ; load VRAM address
5306+ 3558 CD 5D 06             call    SETVDPADRS      ; send it to VDP
5307+ 355B EB                   ex      DE,HL           ; restore address into HL
5308+ 355C 06 08                ld      B,$08           ; repeat for 8 rows
5309+ 355E 0D                   dec     C              ; VDP data mode
5310+ 355F ED A3        GPCPCH1:outi                    ; load a byte from ROM and send to VRAM
5311+ 3561 00                   nop                     ; wait...
5312+ 3562 00                   nop                     ; ...a...
5313+ 3563 00                   nop                     ; ...while
5314+ 3564 20 F9                jr      NZ,GPCPCH1      ; repeat for 8 chars
5315+ 3566 FB                   ei                      ; re-enable INTs
5316+ 3567 11 08 00             ld      DE,$0008        ; 8 bytes to go to the next video cell
5317+ 356A 2A D5 52             ld      HL,(TMPADR)     ; load VRAM address
5318+ 356D 19                   add     HL,DE           ; get address of next VRAM cell
5319+ 356E 22 D5 52             ld      (TMPADR),HL     ; store new VRAM address
5320+ 3571 11 00 18             ld      DE,$1800        ; forbidden address
5321+ 3574 CD 88 3F             call    CMP16           ; check if the printing has gone out of the screen
5322+ 3577 D1                   pop     DE              ; retrieve number of chars to be printed
5323+ 3578 D0                   ret     NC              ; if HL>=$1800 then leave
5324+ 3579 C3 27 35             jp      RPGPNT          ; otherwise, check if more chars to output
5325+ 357C
5326+ 357C              ; used by GPRINT to get a color argument (if present)
5327+ 357C 2B           CKCOL:  dec     HL              ; dec 'cos GETCHR INCs
5328+ 357D CD BE 1B             call    GETCHR          ; Get next character
5329+ 3580 C8                   ret     Z               ; return if nothing follows
5330+ 3581 CD 7D 19             call    CHKSYN          ; Make sure ',' follows
5331+ 3584 2C                   defb    ','
5332+ 3585 D5                   push    DE              ; store DE
5333+ 3586 CD CD 28             call    GETINT          ; get value
5334+ 3589 CD 8D 34             call    CHKCLR1         ; check if color is in range 1~15
5335+ 358C D1                   pop     DE              ; retrieve DE
5336+ 358D 12                   ld      (DE),A          ; store color into temp buffer
5337+ 358E C9                   ret                     ; return to caller
5338+ 358F
5339+ 358F
5340+ 358F              ; paint X,Y[,C]: in graphics mode, fills an area starting
5341+ 358F              ; at point X,Y, using default color or, if used, with
5342+ 358F              ; color set by C
5343+ 358F              ; TMPBFR1       X
5344+ 358F              ; TMPBFR2       Y
5345+ 358F              ; TMPBFR3       COLOR
5346+ 358F              PNT     equ     VIDEOBUFF
5347+ 358F              SPA     equ     VIDEOBUFF+$02
5348+ 358F              SPB     equ     VIDEOBUFF+$03
5349+ 358F              ORGSP   equ     VIDEOBUFF+$04
5350+ 358F CD 97 34     PAINT:  call    CHKG2M          ; check if in graphic mode 2
5351+ 3592 CD CD 28             call    GETINT          ; get X
5352+ 3595 32 CD 52             ld      (TMPBFR1),A     ; store X
5353+ 3598 CD 7D 19             call    CHKSYN          ; Make sure ',' follows
5354+ 359B 2C                   defb    ','
5355+ 359C CD CD 28             call    GETINT          ; get Y coords,
5356+ 359F FE C0                cp      $C0             ; check if Y is in range 0~191
5357+ 35A1 D2 89 1C             jp      NC,FCERR        ; no, raise an FC error
5358+ 35A4 32 CF 52             ld      (TMPBFR2),A     ; store Y
5359+ 35A7 CD 82 3A             call    CLRPRM          ; check if color has been passed
5360+ 35AA 3A D1 52             ld      A,(TMPBFR3)     ; load color
5361+ 35AD A7                   and     A               ; check if 0
5362+ 35AE CA 89 1C             jp      Z,FCERR         ; yes, raise an error
5363+ 35B1 E5                   push    HL              ; store HL
5364+ 35B2 C5                   push    BC              ; store BC
5365+ 35B3 D5                   push    DE              ; store DE
5366+ 35B4                      ; start algorithm
5367+ 35B4 CD C7 36             call    PNTRTN          ; check if pixel is already set
5368+ 35B7 C2 6B 36             jp      NZ,EXITPA2      ; if yes, then leave PAINT
5369+ 35BA ED 73 D9 52          ld      (ORGSP),SP      ; no, store current Stack Pointer
5370+ 35BE 21 01 00             ld      HL,$0001        ; HL=1
5371+ 35C1 22 D5 52             ld      (PNT),HL        ; set PNT
5372+ 35C4 3A CD 52             ld      A,(TMPBFR1)     ; load starting X...
5373+ 35C7 47                   ld      B,A             ; ...into B
5374+ 35C8 3A CF 52             ld      A,(TMPBFR2)     ; load starting Y...
5375+ 35CB 4F                   ld      C,A             ; ...into C
5376+ 35CC C5                   push    BC              ; store starting X,Y into stack
5377+ 35CD                      ; main loop
5378+ 35CD 2A D5 52     NXTLOOP:ld      HL,(PNT)        ; retrieve PNT
5379+ 35D0 7C                   ld      A,H             ; check if PNT=0
5380+ 35D1 B5                   or      L
5381+ 35D2 CA 67 36             jp      Z,EXITPAI       ; yes, no more points to process - exit
5382+ 35D5 2B                   dec     HL              ; no, so decrement PNT...
5383+ 35D6 22 D5 52             ld      (PNT),HL        ; ...and store it
5384+ 35D9 C1                   pop     BC              ; retrieve pixel coordinates X,Y into BC
5385+ 35DA CD 6F 36     PAINT0: call    CHECKPA         ; check if pixel is set/reset
5386+ 35DD 20 09                jr      NZ,PAINT11      ; pixel is set, so jump over
5387+ 35DF 78                   ld      A,B             ; pixel is reset, check if X1=0
5388+ 35E0 A7                   and     A               ; (reached the limit of the screen)
5389+ 35E1 CA E9 35             jp      Z,PAINT1        ; yes, jump over
5390+ 35E4 05                   dec     B               ; no, decrement X1...
5391+ 35E5 C3 DA 35             jp      PAINT0          ; ...and repeat
5392+ 35E8 04           PAINT11:inc     B               ; if found a pixel on, the re-increment X1
5393+ 35E9 AF           PAINT1: xor     A               ; reset A
5394+ 35EA 57                   ld      D,A             ; set SA=0
5395+ 35EB 5F                   ld      E,A             ; set SB=0
5396+ 35EC CD 6F 36     MNPAINT:call    CHECKPA         ; check if pixel is set/reset
5397+ 35EF 20 DC                jr      NZ,NXTLOOP      ; it's set, so goto next loop
5398+ 35F1 78                   ld      A,B             ; copy X1
5399+ 35F2 32 CD 52             ld      (TMPBFR1),A     ; into buffer
5400+ 35F5 79                   ld      A,C             ; copy Y
5401+ 35F6 32 CF 52             ld      (TMPBFR2),A     ; into buffer
5402+ 35F9 CD ED 36             call    CNTPLOT         ; plot pixel X1,Y
5403+ 35FC 7A                   ld      A,D             ; load SA into A
5404+ 35FD A7                   and     A               ; SA=0?
5405+ 35FE 20 1C                jr      NZ,PAINT2       ; no, jump over
5406+ 3600 79                   ld      A,C             ; load Y
5407+ 3601 FE 01                cp      $01             ; Y>0?
5408+ 3603 DA 1C 36             jp      C,PAINT2        ; no, jump over
5409+ 3606 3D                   dec     A               ; yes, Y=Y-1
5410+ 3607 CD 70 36             call    CHECKPY         ; check pixel X1,Y-1
5411+ 360A 20 10                jr      NZ,PAINT2       ; it's set, so jump over
5412+ 360C 0D                   dec     C               ; Y=Y-1
5413+ 360D C5                   push    BC              ; insert pixel(X1,Y-1) into stack
5414+ 360E 0C                   inc     C               ; retrieve original Y
5415+ 360F 2A D5 52             ld      HL,(PNT)        ; load PNT
5416+ 3612 23                   inc     HL              ; increment PNT
5417+ 3613 22 D5 52             ld      (PNT),HL        ; store new PNT
5418+ 3616 3E 01                ld      A,$01           ; set SA=1 and...
5419+ 3618 57                   ld      D,A             ; ...store SA into memory
5420+ 3619 C3 2F 36             jp      PAINT3          ; jump over
5421+ 361C 7A           PAINT2: ld      A,D             ; load SA into A
5422+ 361D 1F                   rra                     ; check if SA=1
5423+ 361E 30 0F                jr      NC,PAINT3       ; no, jump over
5424+ 3620 79                   ld      A,C             ; load Y
5425+ 3621 FE 01                cp      $01             ; Y>0?
5426+ 3623 DA 2F 36             jp      C,PAINT3        ; no, jump over
5427+ 3626 3D                   dec     A               ; Y=Y-1
5428+ 3627 CD 70 36             call    CHECKPY         ; check pixel X1,Y-1
5429+ 362A CA 2F 36             jp      Z,PAINT3        ; if pixel is off, jump over
5430+ 362D AF                   xor     A               ; pixel is on, so...
5431+ 362E 57                   ld      D,A             ; ...set SA=0
5432+ 362F 7B           PAINT3: ld      A,E             ; check if...
5433+ 3630 A7                   and     A               ; SB=0
5434+ 3631 20 1B                jr      NZ,PAINT4       ; no, jump over
5435+ 3633 79                   ld      A,C             ; load Y
5436+ 3634 FE BF                cp      $BF             ; Y<191?
5437+ 3636 30 16                jr      NC,PAINT4       ; no, jump over
5438+ 3638 3C                   inc     A               ; Y=Y+1
5439+ 3639 CD 70 36             call    CHECKPY         ; check pixel X1,Y+1
5440+ 363C 20 10                jr      NZ,PAINT4       ; pixel is on, so jump over
5441+ 363E 0C                   inc     C               ; Y=Y+1
5442+ 363F C5                   push    BC              ; insert pixel(X1,Y+1) into stack
5443+ 3640 0D                   dec     C               ; retrieve original Y
5444+ 3641 2A D5 52             ld      HL,(PNT)        ; PNT
5445+ 3644 23                   inc     HL              ; PNT=PNT+1
5446+ 3645 22 D5 52             ld      (PNT),HL        ; store PNT
5447+ 3648 3E 01                ld      A,$01           ; SB=1
5448+ 364A 5F                   ld      E,A             ; set SB
5449+ 364B C3 60 36             jp      PAINT5          ; jump over
5450+ 364E 7B           PAINT4: ld      A,E             ; load SB
5451+ 364F 1F                   rra                     ; check if SB=1
5452+ 3650 30 0E                jr      NC,PAINT5       ; no, jump over
5453+ 3652 79                   ld      A,C             ; load Y
5454+ 3653 FE BF                cp      $BF             ; Y<191?
5455+ 3655 30 09                jr      NC,PAINT5       ; no, jump over
5456+ 3657 3C                   inc     A               ; Y=Y+1
5457+ 3658 CD 70 36             call    CHECKPY         ; check pixel X1,Y+1
5458+ 365B CA 60 36             jp      Z,PAINT5        ; if pixel is off, jump over
5459+ 365E AF                   xor     A               ; pixel is on, so...
5460+ 365F 5F                   ld      E,A             ; ...set SB=0
5461+ 3660 04           PAINT5: inc     B               ; X1=X1+1
5462+ 3661 CA CD 35             jp      Z,NXTLOOP       ; if X1>255 (X1=0) then goto next loop
5463+ 3664 C3 EC 35             jp      MNPAINT         ; otherwise, repeat for next X
5464+ 3667 ED 7B D9 52  EXITPAI:ld      SP,(ORGSP)      ; retrieve original SP pointer
5465+ 366B D1           EXITPA2:pop     DE              ; retrieve DE
5466+ 366C C1                   pop     BC              ; retrieve BC
5467+ 366D E1                   pop     HL              ; retrieve HL
5468+ 366E C9                   ret                     ; return to caller
5469+ 366F 79           CHECKPA:ld      A,C             ; copy Y into A
5470+ 3670 32 CF 52     CHECKPY:ld      (TMPBFR2),A     ; store Y
5471+ 3673 78                   ld      A,B             ; copy X1 into A
5472+ 3674 32 CD 52             ld      (TMPBFR1),A     ; store X1
5473+ 3677 C5                   push    BC              ; save X1,Y
5474+ 3678 D5                   push    DE
5475+ 3679 CD C7 36             call    PNTRTN          ; check if pixel is set/reset
5476+ 367C D1                   pop     DE
5477+ 367D C1                   pop     BC              ; retrieve X1,Y
5478+ 367E C9                   ret                     ; return to caller
5479+ 367F
5480+ 367F
5481+ 367F              ; POINT(x,y): return if a pixel is set (returns color) or if it's reset (0)
5482+ 367F CD 97 34     POINT:  call    CHKG2M          ; check if in graphic mode 2
5483+ 3682 CD 7D 19             call    CHKSYN          ; make sure "(" follows
5484+ 3685 28                   defb    '('
5485+ 3686 CD CD 28             call    GETINT          ; get X coords.
5486+ 3689 32 CD 52             ld      (TMPBFR1),A     ; store it into a temp buffer
5487+ 368C CD 7D 19             call    CHKSYN          ; Make sure ',' follows
5488+ 368F 2C                   defb    ','
5489+ 3690 CD CD 28             call    GETINT          ; get Y coords,
5490+ 3693 FE C0                cp      $C0             ; check if Y is in range 0~191
5491+ 3695 D2 89 1C             jp      NC,FCERR        ; no, raise an FC error
5492+ 3698 32 CF 52             ld      (TMPBFR2),A     ; store into a temp buffer
5493+ 369B CD 7D 19             call    CHKSYN          ; make sure ")" follows
5494+ 369E 29                   defb    ')'
5495+ 369F E5                   push    HL              ; store current string address - the point after the ")" - ...
5496+ 36A0 FD E1                pop     IY              ; ...into IY
5497+ 36A2 CD C7 36             call    PNTRTN          ; check if pixel is set or reset
5498+ 36A5 20 0C                jr      NZ,CTPOINT      ; it's ON, jump over
5499+ 36A7 AF                   xor     A               ; no, it's OFF. make sure to reset A...
5500+ 36A8 47                   ld      B,A             ; ...and B
5501+ 36A9 E1           PNTEND: pop     HL              ; drop original return point
5502+ 36AA FD E5                push    IY              ; load current string address from IY into stack
5503+ 36AC 11 32 21             ld      DE,RETNUM       ; Address of Return number from function...
5504+ 36AF D5                   push    DE              ; ...saved on stack
5505+ 36B0 C3 31 24             jp      ABPASS          ; return AB
5506+ 36B3 CB EC        CTPOINT:set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5507+ 36B5 F3                   di
5508+ 36B6 CD 7D 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5509+ 36B9 FB                   ei
5510+ 36BA CB 3F                srl     A               ; shift A...
5511+ 36BC CB 3F                srl     A               ; ...4 times...
5512+ 36BE CB 3F                srl     A               ; ...to move foreground color...
5513+ 36C0 CB 3F                srl     A               ; ...into lowest nibble
5514+ 36C2 47                   ld      B,A             ; color into B
5515+ 36C3 AF                   xor     A               ; reset MSB
5516+ 36C4 C3 A9 36             jp      PNTEND          ; return AB
5517+ 36C7 CD 3A 37     PNTRTN: call    XY2HL           ; find HL address of pixel at X,Y
5518+ 36CA 57                   ld      D,A             ; store pixel index
5519+ 36CB F3                   di                      ; disable INTs
5520+ 36CC CD 7D 06             call    READ_VIDEO_LOC  ; read contents of VRAM cell addressed by HL
5521+ 36CF FB                   ei                      ; re-enable INTs
5522+ 36D0 A2                   and     D               ; is the pixel ON or OFF? (will be checked later)
5523+ 36D1 C9                   ret                     ; return to caller
5524+ 36D2
5525+ 36D2
5526+ 36D2              ; PLOT X,Y[,color]
5527+ 36D2              ; plot a pixel in graphic mode 2
5528+ 36D2 CD 97 34     PLOT:   call    CHKG2M          ; check if in G2 mode
5529+ 36D5 CD CD 28             call    GETINT          ; get X coords.
5530+ 36D8 32 CD 52             ld      (TMPBFR1),A     ; store it into a temp buffer
5531+ 36DB CD 7D 19             call    CHKSYN          ; Make sure ',' follows
5532+ 36DE 2C                   defb    ','
5533+ 36DF CD CD 28             call    GETINT          ; get Y coords,
5534+ 36E2 FE C0                cp      $C0             ; check if Y is in range 0~191
5535+ 36E4 D2 89 1C             jp      NC,FCERR        ; no, raise an FC error
5536+ 36E7 32 CF 52             ld      (TMPBFR2),A     ; store into a temp buffer
5537+ 36EA CD 82 3A             call    CLRPRM          ; check if param "color" has been passed
5538+ 36ED E5           CNTPLOT:push    HL              ; store HL
5539+ 36EE C5                   push    BC              ; store BC
5540+ 36EF D5                   push    DE              ; store DE
5541+ 36F0 CD 3A 37             call    XY2HL           ; find VRAM address of byte containing pixel at X,Y & return into HL
5542+ 36F3 D2 2E 37             jp      NC,NOGD         ; if carry is reset, there was an error -> so leave
5543+ 36F6 57                   ld      D,A             ; move pixel value into D
5544+ 36F7 3A D1 52             ld      A,(TMPBFR3)     ; retrieve color
5545+ 36FA A7                   and     A               ; is it 0? (background, or reset pixel)
5546+ 36FB 20 11                jr      NZ,CNTPLT1      ; no, continue
5547+ 36FD F3                   di                      ; yes - so, disable INTs
5548+ 36FE CD 7D 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5549+ 3701 FB                   ei                      ; re-enable INTs
5550+ 3702 5F                   ld      E,A             ; store value of cell
5551+ 3703 7A                   ld      A,D             ; retrieve pixel
5552+ 3704 2F                   cpl                     ; revert bits
5553+ 3705 A3                   and     E               ; set video pixel to off
5554+ 3706 F3                   di                      ; disable INTs
5555+ 3707 CD 92 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5556+ 370A FB                   ei                      ; re-enable INTs
5557+ 370B C3 2E 37             jp      NOGD            ; leave
5558+ 370E 87           CNTPLT1:add     A,A             ; now we move low nibble
5559+ 370F 87                   add     A,A             ; in the high nibble
5560+ 3710 87                   add     A,A             ; by adding A to itself
5561+ 3711 87                   add     A,A             ; 4 times (this is a shift left 4)
5562+ 3712 5F                   ld      E,A             ; move it into E
5563+ 3713 F3                   di                      ; disable INTs
5564+ 3714 CD 7D 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5565+ 3717 FB                   ei
5566+ 3718 B2                   or      D               ; merge new pixel preserving original pattern
5567+ 3719 F3                   di
5568+ 371A CD 92 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5569+ 371D FB                   ei
5570+ 371E CB EC                set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5571+ 3720 F3                   di
5572+ 3721 CD 7D 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5573+ 3724 FB                   ei
5574+ 3725 E6 0F                and     %00001111       ; reset high nibble (the foreground color)
5575+ 3727 B3                   or      E               ; set new foreground color
5576+ 3728 F3                   di
5577+ 3729 CD 92 06             call    WRITE_VIDEO_LOC ; write new color settings
5578+ 372C FB                   ei                      ; re-enable INTs
5579+ 372D 00                   nop                     ; wait for INTs to be enabled again
5580+ 372E D1           NOGD:   pop     DE              ; retrieve DE
5581+ 372F C1                   pop     BC              ; retrieve BC
5582+ 3730 E1                   pop     HL              ; retrieve HL
5583+ 3731 C9                   ret                     ; return to caller
5584+ 3732 80 40 20 10  PXLSET: defb    $80,$40,$20,$10,$08,$04,$02,$01 ; pixel to be set ON
5584+ 3736 08 04 02 01
5585+ 373A                      ; where R(X/8)=> 0=80h, 1=40h, 2=20h, 3=10h, 4=08h, 5=04h, 6=02h, 7=$01
5586+ 373A
5587+ 373A
5588+ 373A              ; compute the VRAM address of the byte containing the pixel
5589+ 373A              ; being pointed by X,Y (TMPBFR1,TMPBFR1)
5590+ 373A              ; byte address is returned into HL
5591+ 373A              ; pixel is returned into A
5592+ 373A              XY2HL:  ; formula is: ADDRESS=(INT(X/8))*8 + (INT(Y/8))*256 + R(Y/8)
5593+ 373A                      ; where R(Y/8) is the remainder of (Y/8)
5594+ 373A                      ; the pixel to be set is given by R(X/8), and data is taken from the array
5595+ 373A 3A CF 52             ld      A,(TMPBFR2)     ; retrieve Y
5596+ 373D FE C0                cp      $C0             ; Y>=192?
5597+ 373F D0                   ret     NC              ; yes, so leave
5598+ 3740 1E 08                ld      E,$08           ; load E with divisor
5599+ 3742 57                   ld      D,A             ; and store into D (dividend)
5600+ 3743 CD B7 3F             call    DIV_8_8         ; get Y/8, D is quotient=INT(Y/8), and A is remainder
5601+ 3746 4F                   ld      C,A             ; store remainder into C
5602+ 3747 42                   ld      B,D             ; B=(INT(Y/8))*256 (we simply copy quotient into B)
5603+ 3748 60 69                ld      HL,BC           ; copy BC into HL: now HL has the VRAM address of the byte being set
5604+ 374A 3A CD 52             ld      A,(TMPBFR1)     ; retrieve X
5605+ 374D 57                   ld      D,A             ; and move it into D (dividend)
5606+ 374E CD B7 3F             call    DIV_8_8         ; get X/8, D is quotient=INT(X/8), and A is remainder
5607+ 3751 4F                   ld      C,A             ; store remainder into C
5608+ 3752 7A                   ld      A,D             ; move quotient into A
5609+ 3753 87                   add     A,A             ; multiply quotient by 8
5610+ 3754 87                   add     A,A
5611+ 3755 87                   add     A,A
5612+ 3756 5F                   ld      E,A             ; store result into E
5613+ 3757 16 00                ld      D,$00           ; reset D
5614+ 3759 19                   add     HL,DE           ; add DE to HL, getting the final VRAM address
5615+ 375A EB                   ex      DE,HL           ; move VRAM address into DE
5616+ 375B 21 32 37             ld      HL,PXLSET       ; starting address of table for pixel to draw
5617+ 375E 06 00                ld      B,$00           ; reset B
5618+ 3760 09                   add     HL,BC           ; add C (remainder of X/8) to get address of pixel to turn on
5619+ 3761 7E                   ld      A,(HL)          ; load pixel data
5620+ 3762 EB                   ex      DE,HL           ; retrieve VRAM pattern address into HL
5621+ 3763 37                   scf                     ; set Carry for normal exit
5622+ 3764 C9                   ret                     ; return to caller
5623+ 3765
5624+ 3765
5625+ 3765              ; DRAW X1,Y1,X2,Y2[,color]
5626+ 3765              ; Draw a line using Bresenham's line algorithm from X1,Y1 to X2,Y2
5627+ 3765              ; X1,Y1 can be either less than or greater than X2,Y2 (meaning that)
5628+ 3765              ; the drawing will be ever done from X1,Y2 to X2,Y2, regardless of
5629+ 3765              ; the values. If color is not specified, the foreground color set
5630+ 3765              ; with COLOR will be used
5631+ 3765              X1      equ     TMPBFR1
5632+ 3765              Y1      equ     TMPBFR2
5633+ 3765              X2      equ     VIDEOBUFF
5634+ 3765              Y2      equ     VIDEOBUFF+$02
5635+ 3765              ER      equ     VIDEOBUFF+$04
5636+ 3765              E2      equ     VIDEOBUFF+$06
5637+ 3765              SX      equ     VIDEOBUFF+$08
5638+ 3765              SY      equ     VIDEOBUFF+$0A
5639+ 3765              DX      equ     VIDEOBUFF+$0C
5640+ 3765              DY      equ     VIDEOBUFF+$0E
5641+ 3765 CD 97 34     DRAW:   call    CHKG2M          ; check if in G2 mode
5642+ 3768 CD 6A 3A             call    CLRVDBF         ; clear VIDEOBUFF
5643+ 376B CD CD 28             call    GETINT          ; get X1 coords.
5644+ 376E 32 CD 52             ld      (X1),A          ; store it into a temp buffer
5645+ 3771 CD 7D 19             call    CHKSYN          ; Make sure ',' follows
5646+ 3774 2C                   defb    ','
5647+ 3775 CD CD 28             call    GETINT          ; get Y1 coords.
5648+ 3778 FE C0                cp      $C0             ; check if Y1 is in range 0~191
5649+ 377A D2 89 1C             jp      NC,FCERR        ; no, raise an FC error
5650+ 377D 32 CF 52             ld      (Y1),A          ; store into a temp buffer
5651+ 3780 CD 7D 19             call    CHKSYN          ; Make sure ',' follows
5652+ 3783 2C                   defb    ','
5653+ 3784 CD CD 28             call    GETINT          ; get X2 coords.
5654+ 3787 32 D5 52             ld      (X2),A          ; store it into a temp buffer
5655+ 378A CD 7D 19             call    CHKSYN          ; Make sure ',' follows
5656+ 378D 2C                   defb    ','
5657+ 378E CD CD 28             call    GETINT          ; get Y2 coords
5658+ 3791 FE C0                cp      $C0             ; check if Y2 is in range 0~191
5659+ 3793 D2 89 1C             jp      NC,FCERR        ; no, raise an FC error
5660+ 3796 32 D7 52             ld      (Y2),A          ; store it into a temp buffer
5661+ 3799 CD 82 3A             call    CLRPRM          ; check for arg. "color" and store it into TMPBFR3
5662+ 379C E5                   push    HL              ; store register we'll use
5663+ 379D D5                   push    DE
5664+ 379E C5                   push    BC
5665+ 379F ED 5B CD 52          ld      DE,(X1)         ; load X1 and
5666+ 37A3 2A D5 52             ld      HL,(X2)         ; X2
5667+ 37A6 B7                   or      A               ; clear CARRY
5668+ 37A7 ED 52                sbc     HL,DE           ; DX=X2-X1
5669+ 37A9 CD AD 3F             call    absHL           ; DX=ABS(DX)
5670+ 37AC 22 E1 52             ld      (DX),HL         ; store DX
5671+ 37AF 01 FF FF             ld      BC,$FFFF        ; SX=-1
5672+ 37B2 2A CD 52             ld      HL,(X1)
5673+ 37B5 ED 5B D5 52          ld      DE,(X2)
5674+ 37B9 CD 88 3F             call    CMP16           ; X1<X2?
5675+ 37BC CA C5 37             jp      Z,X1GR          ; no, X1=X2
5676+ 37BF F2 C5 37             jp      P,X1GR          ; no, X1>X2
5677+ 37C2 01 01 00             ld      BC,$0001        ; yes, so set SX=1
5678+ 37C5 ED 43 DD 52  X1GR:   ld      (SX),BC         ; store SX
5679+ 37C9 ED 5B CF 52          ld      DE,(Y1)
5680+ 37CD 2A D7 52             ld      HL,(Y2)
5681+ 37D0 B7                   or      A               ; clear Carry
5682+ 37D1 ED 52                sbc     HL,DE           ; DY=Y2-Y1
5683+ 37D3 CD AD 3F             call    absHL           ; DY=ABS(DY)
5684+ 37D6 22 E3 52             ld      (DY),HL         ; store DY
5685+ 37D9 01 FF FF             ld      BC,$FFFF        ; SY=-1
5686+ 37DC 2A CF 52             ld      HL,(Y1)
5687+ 37DF ED 5B D7 52          ld      DE,(Y2)
5688+ 37E3 CD 88 3F             call    CMP16           ; is Y1<Y2?
5689+ 37E6 CA EF 37             jp      Z,Y1GR          ; no, Y1=Y2
5690+ 37E9 F2 EF 37             jp      P,Y1GR          ; no, Y1>Y2 - jump over
5691+ 37EC 01 01 00             ld      BC,$0001        ; yes, so set SY=1
5692+ 37EF ED 43 DF 52  Y1GR:   ld      (SY),BC         ; store SY
5693+ 37F3 2A E3 52             ld      HL,(DY)         ; ER=DY
5694+ 37F6 CD B0 3F             call    negHL           ; ER=-DY
5695+ 37F9 22 D9 52             ld      (ER),HL         ; store ER
5696+ 37FC 2A E1 52             ld      HL,(DX)
5697+ 37FF ED 5B E3 52          ld      DE,(DY)
5698+ 3803 CD 88 3F             call    CMP16           ; DX>DY?
5699+ 3806 CA 12 38             jp      Z,ER2           ; no, DX=DY
5700+ 3809 FA 12 38             jp      M,ER2           ; no, DX<DY
5701+ 380C 2A E1 52             ld      HL,(DX)         ; reload DX
5702+ 380F 22 D9 52             ld      (ER),HL         ; yes: DX>DY, so ER=DX
5703+ 3812 2A D9 52     ER2:    ld      HL,(ER)         ; load ER
5704+ 3815 CB 2C                sra     H               ; right shift (and preserve sign)...
5705+ 3817 CB 1D                rr      L               ; ...of HL, so ER=INT(ER/2)
5706+ 3819 CB 7C                bit     7,H             ; is the number negative?
5707+ 381B CA 1F 38             jp      Z,STRE2         ; no, jump over
5708+ 381E 23                   inc     HL              ; yes, add 1 'cos INT of a negative number needs to be incremented
5709+ 381F 22 D9 52     STRE2:  ld      (ER),HL         ; store ER
5710+ 3822 CD ED 36     RPTDRW: call    CNTPLOT         ; plot first pixel
5711+ 3825 2A CD 52             ld      HL,(X1)
5712+ 3828 ED 5B D5 52          ld      DE,(X2)
5713+ 382C CD 88 3F             call    CMP16           ; X1=X2?
5714+ 382F 20 0D                jr      NZ,CNTDRW       ; no, continue drawing
5715+ 3831 2A CF 52             ld      HL,(Y1)         ; yes, so check
5716+ 3834 ED 5B D7 52          ld      DE,(Y2)         ; also Y
5717+ 3838 CD 88 3F             call    CMP16           ; Y1=Y2?
5718+ 383B CA 97 38             jp      Z,ENDDRAW       ; yes, finished drawing: exit
5719+ 383E ED 5B D9 52  CNTDRW: ld      DE,(ER)
5720+ 3842 ED 53 DB 52          ld      (E2),DE         ; E2=ER
5721+ 3846 2A E1 52             ld      HL,(DX)
5722+ 3849 CD B0 3F             call    negHL           ; DX=-DX
5723+ 384C EB                   ex      DE,HL           ; invert DE and HL => HL=E2, DE=-DX
5724+ 384D CD 88 3F             call    CMP16           ; E2>-DX?
5725+ 3850 CA 6E 38             jp      Z,DXGR          ; no, E2=-DX: jump
5726+ 3853 FA 6E 38             jp      M,DXGR          ; no, E2<-DX: jump
5727+ 3856 2A D9 52             ld      HL,(ER)         ; yes
5728+ 3859 ED 5B E3 52          ld      DE,(DY)
5729+ 385D B7                   or      A               ; clear CARRY
5730+ 385E ED 52                sbc     HL,DE           ; ER=ER-DY
5731+ 3860 22 D9 52             ld      (ER),HL
5732+ 3863 2A CD 52             ld      HL,(X1)
5733+ 3866 ED 5B DD 52          ld      DE,(SX)
5734+ 386A 19                   add     HL,DE           ; X1=X1+SX (increment X1)
5735+ 386B 22 CD 52             ld      (X1),HL
5736+ 386E 2A DB 52     DXGR:   ld      HL,(E2)
5737+ 3871 ED 5B E3 52          ld      DE,(DY)
5738+ 3875 CD 88 3F             call    CMP16           ; E2<DY?
5739+ 3878 CA 22 38             jp      Z,RPTDRW        ; no, E2=DY: jump
5740+ 387B F2 22 38             jp      P,RPTDRW        ; no, E2>DY: jump
5741+ 387E 2A D9 52             ld      HL,(ER)         ; yes
5742+ 3881 ED 5B E1 52          ld      DE,(DX)
5743+ 3885 19                   add     HL,DE           ; ER=ER+DX
5744+ 3886 22 D9 52             ld      (ER),HL
5745+ 3889 2A CF 52             ld      HL,(Y1)
5746+ 388C ED 5B DF 52          ld      DE,(SY)
5747+ 3890 19                   add     HL,DE           ; Y1=Y1+SY (increment Y1)
5748+ 3891 22 CF 52             ld      (Y1),HL
5749+ 3894 C3 22 38             jp      RPTDRW          ; repeat
5750+ 3897 C1           ENDDRAW:pop     BC              ; retrieve BC
5751+ 3898 D1                   pop     DE              ; retrieve DE
5752+ 3899 E1                   pop     HL              ; retrieve HL
5753+ 389A C9                   ret                     ; return to caller
5754+ 389B
5755+ 389B
5756+ 389B              ; CIRCLE X,Y,R[,C]
5757+ 389B              ; Draw a circle using Bresenham's circle algorithm with center in X,Y
5758+ 389B              ; and radius R, with optional color C. If color is not specified, the
5759+ 389B              ; foreground color set with COLOR will be used
5760+ 389B              XC      equ     VIDEOBUFF
5761+ 389B              YC      equ     VIDEOBUFF+$02
5762+ 389B              RADIUS  equ     VIDEOBUFF+$04
5763+ 389B              XI      equ     VIDEOBUFF+$06
5764+ 389B              YI      equ     VIDEOBUFF+$08
5765+ 389B              DC      equ     VIDEOBUFF+$0A
5766+ 389B CD 97 34     CIRCLE: call    CHKG2M          ; check if in G2 mode
5767+ 389E CD 6A 3A             call    CLRVDBF         ; clear VIDEOBUFF
5768+ 38A1 CD CD 28             call    GETINT          ; get X coords.
5769+ 38A4 32 D5 52             ld      (XC),A          ; store it into a temp buffer
5770+ 38A7 CD 7D 19             call    CHKSYN          ; Make sure ',' follows
5771+ 38AA 2C                   defb    ','
5772+ 38AB CD CD 28             call    GETINT          ; get Y coords,
5773+ 38AE 32 D7 52             ld      (YC),A          ; store it into a temp buffer
5774+ 38B1 CD 7D 19             call    CHKSYN          ; Make sure ',' follows
5775+ 38B4 2C                   defb    ','
5776+ 38B5 CD CD 28             call    GETINT          ; get radius
5777+ 38B8 32 D9 52             ld      (RADIUS),A      ; store it into a temp buffer
5778+ 38BB CD 82 3A             call    CLRPRM          ; check if param "color" has been passed
5779+ 38BE C5                   push    BC              ; store BC
5780+ 38BF D5                   push    DE              ; store DE
5781+ 38C0 E5                   push    HL              ; store HL
5782+ 38C1 AF                   xor     A               ; clear A,
5783+ 38C2 47                   ld      B,A             ; B,
5784+ 38C3 4F                   ld      C,A             ; C,
5785+ 38C4 57                   ld      D,A             ; D,
5786+ 38C5 67                   ld      H,A             ; and H
5787+ 38C6 ED 43 DB 52          ld      (XI),BC         ; clear XI
5788+ 38CA 3A D9 52             ld      A,(RADIUS)      ; load RADIUS into A
5789+ 38CD 6F                   ld      L,A             ; HL now contains R
5790+ 38CE 22 DD 52             ld      (YI),HL         ; YI=RADIUS
5791+ 38D1 29                   add     HL,HL           ; R*2
5792+ 38D2 EB                   ex      DE,HL           ; put HL into DE
5793+ 38D3 21 03 00             ld      HL,$0003        ; HL = 3
5794+ 38D6 AF                   xor     A               ; clear Carry
5795+ 38D7 ED 52                sbc     HL,DE           ; D=3-(2*R) => HL
5796+ 38D9 22 DF 52             ld      (DC),HL         ; store D
5797+ 38DC CD 3B 39             call    DRWCRL          ; draw initial point
5798+ 38DF ED 5B DB 52  RPTCRL: ld      DE,(XI)         ; load XI
5799+ 38E3 2A DD 52             ld      HL,(YI)         ; load YI
5800+ 38E6 CD 88 3F             call    CMP16           ; is YI<DI?
5801+ 38E9 CA F2 38             jp      Z,RPTCL1        ; no, YI=XI
5802+ 38EC F2 F2 38             jp      P,RPTCL1        ; no, YI>XI
5803+ 38EF C3 37 39             jp      ENDCRL          ; yes, so we've finished
5804+ 38F2 21 DB 52     RPTCL1: ld      HL,XI
5805+ 38F5 34                   inc     (HL)            ; XI=XI+1
5806+ 38F6 2A DF 52             ld      HL,(DC)         ; load D
5807+ 38F9 7C                   ld      A,H
5808+ 38FA B5                   or      L               ; is D=0? Yes, jump over
5809+ 38FB CA 1F 39             jp      Z,DLSZ
5810+ 38FE CB 7C                bit     7,H             ; is D<0?
5811+ 3900 20 1D                jr      NZ,DLSZ         ; yes, jump over
5812+ 3902 ED 5B DD 52          ld      DE,(YI)         ; D>0
5813+ 3906 1B                   dec     DE              ; so, YI=YI-1
5814+ 3907 ED 53 DD 52          ld      (YI),DE         ; store YI
5815+ 390B AF                   xor     A               ; clear Carry
5816+ 390C 2A DB 52             ld      HL,(XI)
5817+ 390F ED 52                sbc     HL,DE           ; HL=XI-YI
5818+ 3911 29                   add     HL,HL
5819+ 3912 29                   add     HL,HL           ; HL=HL*4
5820+ 3913 11 0A 00             ld      DE,10
5821+ 3916 19                   add     HL,DE           ; HL=HL+10
5822+ 3917 ED 5B DF 52          ld      DE,(DC)         ; load D
5823+ 391B EB                   ex      DE,HL           ; invert DE and HL, so that HL=4*(XI-YI)+10 and DE=D
5824+ 391C 19                   add     HL,DE           ; D=D+4*(XI-YI)+10
5825+ 391D 18 0F                jr      PLTCRL          ; plot next pixel
5826+ 391F 2A DB 52     DLSZ:   ld      HL,(XI)         ; load XI
5827+ 3922 29                   add     HL,HL
5828+ 3923 29                   add     HL,HL           ; XI=XI*4
5829+ 3924 11 06 00             ld      DE,$0006
5830+ 3927 19                   add     HL,DE
5831+ 3928 ED 5B DF 52          ld      DE,(DC)
5832+ 392C EB                   ex      DE,HL           ; HL=D and DE=4*XI+6
5833+ 392D 19                   add     HL,DE           ; D=D+4*XI+6
5834+ 392E 22 DF 52     PLTCRL: ld      (DC),HL         ; store new D
5835+ 3931 CD 3B 39             call    DRWCRL          ; plot pixel
5836+ 3934 C3 DF 38             jp      RPTCRL          ; repeat
5837+ 3937 E1           ENDCRL: pop     HL
5838+ 3938 D1                   pop     DE
5839+ 3939 C1                   pop     BC
5840+ 393A C9                   ret                     ; return to caller
5841+ 393B 2A D5 52     DRWCRL: ld      HL,(XC)
5842+ 393E ED 5B DB 52          ld      DE,(XI)
5843+ 3942 19                   add     HL,DE           ; X=XC+XI
5844+ 3943 22 CD 52             ld      (X1),HL         ; store X
5845+ 3946 CD 5A 3A             call    VALIDX          ; check if X is valid (0~255)
5846+ 3949 DA 5D 39             jp      C,CNTCL1        ; if Carry is set, X is not valid
5847+ 394C 2A D7 52             ld      HL,(YC)
5848+ 394F ED 5B DD 52          ld      DE,(YI)
5849+ 3953 19                   add     HL,DE           ; Y=YC+YI
5850+ 3954 22 CF 52             ld      (Y1),HL         ; store Y
5851+ 3957 CD 5F 3A             call    VALIDY          ; check if Y is valid (0~191)
5852+ 395A D4 ED 36             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5853+ 395D AF           CNTCL1: xor     A               ; clear Carry
5854+ 395E 2A D5 52             ld      HL,(XC)
5855+ 3961 ED 5B DB 52          ld      DE,(XI)
5856+ 3965 ED 52                sbc     HL,DE           ; X=XC-XI
5857+ 3967 22 CD 52             ld      (X1),HL         ; store X
5858+ 396A CD 5A 3A             call    VALIDX          ; check if X is valid (0~255)
5859+ 396D DA 81 39             jp      C,CNTCL2        ; if Carry is set, X is not valid
5860+ 3970 2A D7 52             ld      HL,(YC)
5861+ 3973 ED 5B DD 52          ld      DE,(YI)
5862+ 3977 19                   add     HL,DE           ; Y=YC+YI
5863+ 3978 22 CF 52             ld      (Y1),HL         ; store Y
5864+ 397B CD 5F 3A             call    VALIDY          ; check if Y is valid (0~191)
5865+ 397E D4 ED 36             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5866+ 3981 2A D5 52     CNTCL2: ld      HL,(XC)
5867+ 3984 ED 5B DB 52          ld      DE,(XI)
5868+ 3988 19                   add     HL,DE           ; X=XC+XI
5869+ 3989 22 CD 52             ld      (X1),HL         ; store X
5870+ 398C CD 5A 3A             call    VALIDX          ; check if X is valid (0~255)
5871+ 398F DA A5 39             jp      C,CNTCL3        ; if Carry is set, X is not valid
5872+ 3992 AF                   xor     A               ; clear Carry
5873+ 3993 2A D7 52             ld      HL,(YC)
5874+ 3996 ED 5B DD 52          ld      DE,(YI)
5875+ 399A ED 52                sbc     HL,DE           ; Y=YC-YI
5876+ 399C 22 CF 52             ld      (Y1),HL         ; store Y
5877+ 399F CD 5F 3A             call    VALIDY          ; check if Y is valid (0~191)
5878+ 39A2 D4 ED 36             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5879+ 39A5 AF           CNTCL3: xor     A               ; clear Carry
5880+ 39A6 2A D5 52             ld      HL,(XC)
5881+ 39A9 ED 5B DB 52          ld      DE,(XI)
5882+ 39AD ED 52                sbc     HL,DE           ; X=XC-XI
5883+ 39AF 22 CD 52             ld      (X1),HL         ; store X
5884+ 39B2 CD 5A 3A             call    VALIDX          ; check if X is valid (0~255)
5885+ 39B5 DA CB 39             jp      C,CNTCL4        ; if Carry is set, X is not valid
5886+ 39B8 AF                   xor     A               ; clear Carry
5887+ 39B9 2A D7 52             ld      HL,(YC)
5888+ 39BC ED 5B DD 52          ld      DE,(YI)
5889+ 39C0 ED 52                sbc     HL,DE           ; Y=YC-YI
5890+ 39C2 22 CF 52             ld      (Y1),HL         ; store Y
5891+ 39C5 CD 5F 3A             call    VALIDY          ; check if Y is valid (0~191)
5892+ 39C8 D4 ED 36             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5893+ 39CB 2A D5 52     CNTCL4: ld      HL,(XC)
5894+ 39CE ED 5B DD 52          ld      DE,(YI)
5895+ 39D2 19                   add     HL,DE           ; X=XC+YI
5896+ 39D3 22 CD 52             ld      (X1),HL         ; store X
5897+ 39D6 CD 5A 3A             call    VALIDX          ; check if X is valid (0~255)
5898+ 39D9 DA ED 39             jp      C,CNTCL5        ; if Carry is set, X is not valid
5899+ 39DC 2A D7 52             ld      HL,(YC)
5900+ 39DF ED 5B DB 52          ld      DE,(XI)
5901+ 39E3 19                   add     HL,DE           ; Y=YC+XI
5902+ 39E4 22 CF 52             ld      (Y1),HL         ; store Y
5903+ 39E7 CD 5F 3A             call    VALIDY          ; check if Y is valid (0~191)
5904+ 39EA D4 ED 36             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5905+ 39ED AF           CNTCL5: xor     A               ; clear Carry
5906+ 39EE 2A D5 52             ld      HL,(XC)
5907+ 39F1 ED 5B DD 52          ld      DE,(YI)
5908+ 39F5 ED 52                sbc     HL,DE           ; X=XC-YI
5909+ 39F7 22 CD 52             ld      (X1),HL         ; store X
5910+ 39FA CD 5A 3A             call    VALIDX          ; check if X is valid (0~255)
5911+ 39FD DA 11 3A             jp      C,CNTCL6        ; if Carry is set, X is not valid
5912+ 3A00 2A D7 52             ld      HL,(YC)
5913+ 3A03 ED 5B DB 52          ld      DE,(XI)
5914+ 3A07 19                   add     HL,DE           ; Y=YC+XI
5915+ 3A08 22 CF 52             ld      (Y1),HL         ; store Y
5916+ 3A0B CD 5F 3A             call    VALIDY          ; check if Y is valid (0~191)
5917+ 3A0E D4 ED 36             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5918+ 3A11 2A D5 52     CNTCL6: ld      HL,(XC)
5919+ 3A14 ED 5B DD 52          ld      DE,(YI)
5920+ 3A18 19                   add     HL,DE           ; X=XC+YI
5921+ 3A19 22 CD 52             ld      (X1),HL         ; store X
5922+ 3A1C CD 5A 3A             call    VALIDX          ; check if X is valid (0~255)
5923+ 3A1F DA 35 3A             jp      C,CNTCL7        ; if Carry is set, X is not valid
5924+ 3A22 AF                   xor     A               ; clear Carry
5925+ 3A23 2A D7 52             ld      HL,(YC)
5926+ 3A26 ED 5B DB 52          ld      DE,(XI)
5927+ 3A2A ED 52                sbc     HL,DE           ; Y=YC-XI
5928+ 3A2C 22 CF 52             ld      (Y1),HL         ; store Y
5929+ 3A2F CD 5F 3A             call    VALIDY          ; check if Y is valid (0~191)
5930+ 3A32 D4 ED 36             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5931+ 3A35 AF           CNTCL7: xor     A               ; clear Carry
5932+ 3A36 2A D5 52             ld      HL,(XC)
5933+ 3A39 ED 5B DD 52          ld      DE,(YI)
5934+ 3A3D ED 52                sbc     HL,DE           ; X=XC-YI
5935+ 3A3F 22 CD 52             ld      (X1),HL         ; store X
5936+ 3A42 CD 5A 3A             call    VALIDX          ; check if X is valid (0~255)
5937+ 3A45 D8                   ret     C               ; if Carry is set, X is not valid
5938+ 3A46 AF                   xor     A               ; clear Carry
5939+ 3A47 2A D7 52             ld      HL,(YC)
5940+ 3A4A ED 5B DB 52          ld      DE,(XI)
5941+ 3A4E ED 52                sbc     HL,DE           ; Y=YC-XI
5942+ 3A50 22 CF 52             ld      (Y1),HL         ; store Y
5943+ 3A53 CD 5F 3A             call    VALIDY          ; check if Y is valid (0~191)
5944+ 3A56 D4 ED 36             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5945+ 3A59 C9                   ret                     ; return to caller
5946+ 3A5A
5947+ 3A5A              ; check if X,Y coordinates are valid: 0<=X<=255 and 0<=Y<=191
5948+ 3A5A              ; input: HL (value to check), can be negative
5949+ 3A5A              ; output: CARRY flag: reset => VALID  //  set => NOT VALID
5950+ 3A5A              ; destroys: A
5951+ 3A5A AF           VALIDX: xor     A               ; reset A
5952+ 3A5B B4                   or      H               ; check if H is 0 (this means that X is in range 0~255 and not negative)
5953+ 3A5C C8                   ret     Z               ; yes, we can return (C is clear)
5954+ 3A5D 37                   scf                     ; set Carry flag to raise error
5955+ 3A5E C9                   ret                     ; return to caller
5956+ 3A5F
5957+ 3A5F AF           VALIDY: xor     A               ; reset A
5958+ 3A60 B4                   or      H               ; check if H is 0 (this means that Y is in range 0~255 and not negative)
5959+ 3A61 28 02                jr      Z,CNTVALY       ; yes, continue checking
5960+ 3A63 37                   scf                     ; no, raise error by setting Carry flag
5961+ 3A64 C9                   ret                     ; return to caller
5962+ 3A65 7D           CNTVALY:ld      A,L
5963+ 3A66 FE C0                cp      $C0             ; is Y<192? Carry is set if Y<192
5964+ 3A68 3F                   ccf                     ; invert Carry, so Carry=0 means OK, Carry=1 means ERROR
5965+ 3A69 C9                   ret                     ; return to caller
5966+ 3A6A
5967+ 3A6A
5968+ 3A6A              ; clear VIDEOBUFF before using it as temp buffer
5969+ 3A6A AF           CLRVDBF:xor     A               ; clear A
5970+ 3A6B C5                   push    BC              ; store BC
5971+ 3A6C E5                   push    HL              ; store HL
5972+ 3A6D 21 CD 52             ld      HL,TMPBFR1      ; address of 1st cell
5973+ 3A70 06 06                ld      B,$06           ; 6 cells
5974+ 3A72 77           RPTCVB1:ld      (HL),A          ; clear cell
5975+ 3A73 23                   inc     HL              ; next cell
5976+ 3A74 10 FC                djnz    RPTCVB1         ; repeat
5977+ 3A76 06 28                ld      B,$28           ; 40 cells
5978+ 3A78 21 D5 52             ld      HL,VIDEOBUFF    ; address of 1st cell
5979+ 3A7B 77           RPTCVB2:ld      (HL),A          ; clear cell
5980+ 3A7C 23                   inc     HL              ; next cell
5981+ 3A7D 10 FC                djnz    RPTCVB2         ; repeat
5982+ 3A7F E1                   pop     HL              ; retrieve HL
5983+ 3A80 C1                   pop     BC              ; retrieve BC
5984+ 3A81 C9                   ret                     ; return to caller
5985+ 3A82
5986+ 3A82
5987+ 3A82              ; check if a color is passed as argument with PLOT, DRAW, and CIRCLE
5988+ 3A82              ; commands. If not present, the default foreground color will be used
5989+ 3A82 3A CB 52     CLRPRM: ld      A,(FRGNDCLR)    ; load foreground color
5990+ 3A85 32 D1 52             ld      (TMPBFR3),A     ; store into temp buffer
5991+ 3A88 2B                   dec     HL              ; dec 'cos GETCHR INCs
5992+ 3A89 CD BE 1B             call    GETCHR          ; Get next character
5993+ 3A8C C8                   ret     Z               ; return foreground color if nothing follows
5994+ 3A8D CD 7D 19             call    CHKSYN          ; Make sure ',' follows
5995+ 3A90 2C                   defb    ','
5996+ 3A91 CD CD 28             call    GETINT          ; get value
5997+ 3A94 CD 91 34             call    CHKCLR0         ; check if color is in range 0~15
5998+ 3A97 32 D1 52             ld      (TMPBFR3),A     ; store color into temp buffer
5999+ 3A9A C9                   ret                     ; return to caller
6000+ 3A9B
6001+ 3A9B
6002+ 3A9B              ; no graphics mode error: raised when a graphics command is invoked
6003+ 3A9B              ; out of graphic 2 mode.
6004+ 3A9B 1E 2A        GMERR:  ld      E,GM            ; load Graphics Mode Error flag
6005+ 3A9D C3 AF 16             jp      ERROR           ; print error
6006+ 3AA0
6007+ 3AA0
6008+ 3AA0              ; set a serial port: params are PORT,BPS,DATA,PARITY,STOP
6009+ 3AA0              ; PORT=1/2; BPS=1,200~57,600 (see below), DATA=5/6/7/8
6010+ 3AA0              ; PARITY: 0=no parity; 1=ODD parity; 2=EVEN parity;
6011+ 3AA0              ; STOP=0/1/2/3: 0=0 bit; 1=1 bit; 2=1.5 bits; 3=2 bits
6012+ 3AA0              ; PORT 1 acts as a char device; PORT 2 acts as a block device
6013+ 3AA0              ; DATA,PARITY, and STOP are optional: if nothing follows BPS,
6014+ 3AA0              ; they are assumed to be 8,0,1 resp.
6015+ 3AA0              PRTNUM  equ     VIDEOBUFF
6016+ 3AA0              BPS     equ     VIDEOBUFF+$01
6017+ 3AA0              DATABT  equ     BPS+$02
6018+ 3AA0              PARBT   equ     DATABT+$01
6019+ 3AA0              STPBT   equ     PARBT+$01
6020+ 3AA0              SIOBFR  equ     STPBT+$01
6021+ 3AA0 CD CD 28     SERIAL: call    GETINT          ; get port #
6022+ 3AA3 A7                   and     A               ; is it zero?
6023+ 3AA4 CA 89 1C             jp      Z,FCERR         ; yes, error
6024+ 3AA7 FE 03                cp      $03             ; is it 1 or 2?
6025+ 3AA9 D2 C9 3C             jp      NC,SCERR        ; no, error
6026+ 3AAC 32 D5 52             ld      (PRTNUM),A      ; store port number into a temp buffer
6027+ 3AAF CD 7D 19             call    CHKSYN          ; Make sure ',' follows
6028+ 3AB2 2C                   defb    ','
6029+ 3AB3 2B                   dec     HL
6030+ 3AB4 CD BE 1B             call    GETCHR          ; check what's following
6031+ 3AB7 CA 9B 16             jp      Z,SNERR         ; error if nothing follows
6032+ 3ABA 30 05                jr      NC,SERVAR       ; it's not a number, try a variable
6033+ 3ABC CD 8E 1C             call    ATOH            ; get bps (returned into DE)
6034+ 3ABF 18 0F                jr      CHKZSER         ; jump over
6035+ 3AC1 CD 47 20     SERVAR: call    GETNUM          ; get number
6036+ 3AC4 CD 54 2E             call    TSTSGN          ; check value
6037+ 3AC7 FA 89 1C             jp      M,FCERR         ; negative - illegal function call
6038+ 3ACA 3A 24 53             ld      A,(FPEXP)       ; Get integer value to DE
6039+ 3ACD CD FC 2E             call    FPINT           ; get integer number into BCDE - drop BC 'cause isn't necessary
6040+ 3AD0 7A           CHKZSER:ld      A,D             ; bps is into DE - move MSB into A
6041+ 3AD1 B3                   or      E               ; check if bps=0
6042+ 3AD2 20 3A                jr      NZ,CNTSER       ; no, continue checking
6043+ 3AD4                      ; if baud rate is 0, then close the serial comm.
6044+ 3AD4 3A D5 52     RSTSERS:ld      A,(PRTNUM)      ; yes, so reset the channel. First, load port number
6045+ 3AD7 3D                   dec     A               ; subtract 1, so that serial channel is 0=>A and 1=>B
6046+ 3AD8 C6 22                add     SIO_CA          ; find correct channel
6047+ 3ADA 4F                   ld      C,A             ; store serial channel
6048+ 3ADB F3                   di                      ; disable INTs
6049+ 3ADC AF                   xor     A               ; reset A
6050+ 3ADD 16 01                ld      D,$01           ; start from WR1
6051+ 3ADF 06 05                ld      B,$05           ; 5 registers
6052+ 3AE1 ED 51        RPTRSSR:out     (C),D           ; select register
6053+ 3AE3 ED 79                out     (C),A           ; reset register
6054+ 3AE5 14                   inc     D               ; next register
6055+ 3AE6 10 F9                djnz    RPTRSSR         ; repeat
6056+ 3AE8 3E 30                ld      A,%00110000     ; write into WR0: error reset, select WR0
6057+ 3AEA ED 79                out     (C),A           ; send command to serial channel
6058+ 3AEC 3E 18                ld      A,%00011000     ; write into WR0: channel reset
6059+ 3AEE ED 79                out     (C),A           ; send command to serial channel
6060+ 3AF0 FB                   ei                      ; re-enable INTs
6061+ 3AF1 E5                   push    HL              ; store HL
6062+ 3AF2 21 0F 53             ld      HL,SERIALS_EN   ; serials enabled status byte
6063+ 3AF5 DB 01                in      A,(PIO_DB)      ; read status LEDs
6064+ 3AF7 CB 41                bit     0,C             ; check serial port
6065+ 3AF9 20 09                jr      NZ,SRPT2        ; if bit is set, jump to port 2
6066+ 3AFB CB B7                res     6,A             ; it's port 1
6067+ 3AFD CB A7                res     4,A             ; remove possible error LED
6068+ 3AFF CB 86                res     0,(HL)          ; disable port 1
6069+ 3B01 C3 0A 3B             jp      SERLED          ; jump over
6070+ 3B04 CB BF        SRPT2:  res     7,A             ; it's port 2
6071+ 3B06 CB AF                res     5,A             ; remove possible error LED
6072+ 3B08 CB 8E                res     1,(HL)          ; disable port 2
6073+ 3B0A D3 01        SERLED: out     (PIO_DB),A      ; send new configuration
6074+ 3B0C E1                   pop     HL              ; retrieve HL
6075+ 3B0D C9                   ret                     ; return to caller
6076+ 3B0E                      ; check if bps=1, meaning reactivate RX on serial
6077+ 3B0E 7A           CNTSER: ld      A,D
6078+ 3B0F B2                   or      D               ; check if bps<>1 by first checking D=0
6079+ 3B10 20 36                jr      NZ,CNTSER2      ; if not, jump over
6080+ 3B12 7B                   ld      A,E             ; then by checking that
6081+ 3B13 FE 01                cp      $01             ; E=1
6082+ 3B15 20 31                jr      NZ,CNTSER2      ; if not, jump over
6083+ 3B17 3A D5 52             ld      A,(PRTNUM)      ; load port number
6084+ 3B1A 57                   ld      D,A             ; store port on D
6085+ 3B1B 3A 0F 53             ld      A,(SERIALS_EN)  ; load address of serial status cell
6086+ 3B1E A2                   and     D               ; check status
6087+ 3B1F CA C9 3C             jp      Z,SCERR         ; port not open, raise error
6088+ 3B22 F3                   di                      ; disable INTs
6089+ 3B23 7A                   ld      A,D             ; move port # into A
6090+ 3B24 5F                   ld      E,A             ; and also into E
6091+ 3B25 87                   add     A
6092+ 3B26 87                   add     A               ; move A to left times 2
6093+ 3B27 57                   ld      D,A             ; move value into D
6094+ 3B28 3A 0F 53             ld      A,(SERIALS_EN)  ; load serial status byte
6095+ 3B2B B2                   or      D               ; re-enable RX
6096+ 3B2C 32 0F 53             ld      (SERIALS_EN),A  ; store new serial status
6097+ 3B2F 7B                   ld      A,E             ; recover port #
6098+ 3B30 3D                   dec     A               ; check port
6099+ 3B31 20 0A                jr      NZ,CNTRX2       ; port is #2
6100+ 3B33 CD DA 01             call    SIO_A_EI        ; re-enable RX on port 1
6101+ 3B36 DB 01                in      A,(PIO_DB)      ; load status LEDs
6102+ 3B38 CB A7                res     4,A             ; remove error LED
6103+ 3B3A C3 44 3B             jp      RXEND           ; terminate setting
6104+ 3B3D CD E2 01     CNTRX2: call    SIO_B_EI        ; re-enable RX on port 2
6105+ 3B40 DB 01                in      A,(PIO_DB)      ; load status LEDs
6106+ 3B42 CB AF                res     5,A             ; remove error LED
6107+ 3B44 D3 01        RXEND:  out     (PIO_DB),A      ; set new status for LEDs
6108+ 3B46 FB                   ei                      ; re-enable INTs
6109+ 3B47 C9                   ret                     ; return to caller
6110+ 3B48                      ; set serial port comm.
6111+ 3B48 D5           CNTSER2:push    DE              ; store BPS
6112+ 3B49 3A D5 52             ld      A,(PRTNUM)      ; load port number
6113+ 3B4C 57                   ld      D,A             ; move port # into D
6114+ 3B4D 3A 0F 53             ld      A,(SERIALS_EN)  ; check if serial port is already open
6115+ 3B50 A2                   and     D               ; by ANDing A with D
6116+ 3B51 D1                   pop     DE              ; retrieve BPS
6117+ 3B52 CA 5A 3B             jp      Z,CNTSER3       ; not open, continue
6118+ 3B55 1E 2E                ld      E,SA            ; already open, so raise a "Serial Port Already Error"
6119+ 3B57 C3 AF 16             jp      ERROR           ; and leave
6120+ 3B5A E5           CNTSER3:push    HL              ; store HL
6121+ 3B5B 21 00 E1             ld      HL,$E100        ; check bps. start with HL=57,600
6122+ 3B5E CD 88 3F             call    CMP16           ; is bps<=57,600?
6123+ 3B61 E1                   pop     HL              ; but first, recover HL
6124+ 3B62 DA C9 3C             jp      C,SCERR         ; no (bps>57,600) then error
6125+ 3B65 ED 53 D6 52          ld      (BPS),DE        ; store bps
6126+ 3B69 2B                   dec     HL              ; dec 'cos GETCHR INCs
6127+ 3B6A CD BE 1B             call    GETCHR          ; Get next character
6128+ 3B6D CA A5 3B             jp      Z,DEFSER        ; defaults if nothing follows
6129+ 3B70 CD 7D 19             call    CHKSYN          ; Make sure ',' follows
6130+ 3B73 2C                   defb    ','
6131+ 3B74 CD CD 28             call    GETINT          ; get data bits
6132+ 3B77 FE 05                cp      $05             ; is it <5?
6133+ 3B79 DA C9 3C             jp      C,SCERR         ; yes, error
6134+ 3B7C FE 09                cp      $09             ; is it >=9?
6135+ 3B7E D2 89 1C             jp      NC,FCERR        ; yes, error
6136+ 3B81 32 D8 52             ld      (DATABT),A      ; store data bits
6137+ 3B84 CD 7D 19             call    CHKSYN          ; Make sure ',' follows
6138+ 3B87 2C                   defb    ','
6139+ 3B88 CD CD 28             call    GETINT          ; get parity bits
6140+ 3B8B BF FE 03             cp      A,$03           ; check if parity is in range 0~2
6141+ 3B8E D2 C9 3C             jp      NC,SCERR        ; no, error
6142+ 3B91 32 D9 52             ld      (PARBT),A       ; store parity
6143+ 3B94 CD 7D 19             call    CHKSYN          ; Make sure ',' follows
6144+ 3B97 2C                   defb    ','
6145+ 3B98 CD CD 28             call    GETINT          ; get stop bits
6146+ 3B9B FE 03                cp      $03             ; is it >=3?
6147+ 3B9D D2 C9 3C             jp      NC,SCERR        ; yes, error
6148+ 3BA0 32 DA 52             ld      (STPBT),A       ; store stop bits
6149+ 3BA3 18 0D                jr      SETSER          ; jump to set serial
6150+ 3BA5 3E 08        DEFSER: ld      A,$08           ; 8 bits for data
6151+ 3BA7 32 D8 52             ld      (DATABT),A
6152+ 3BAA AF                   xor     A               ; no parity bit
6153+ 3BAB 32 D9 52             ld      (PARBT),A
6154+ 3BAE 3C                   inc     A               ; 1 bit for stop
6155+ 3BAF 32 DA 52             ld      (STPBT),A
6156+ 3BB2                      ; check if bps are legal
6157+ 3BB2 E5           SETSER: push    HL              ; store HL
6158+ 3BB3 D5                   push    DE              ; store DE
6159+ 3BB4 DD E5                push    IX              ; store IX
6160+ 3BB6 DD 21 A4 3C          ld      IX,SUP_BPS      ; allowed BPSs
6161+ 3BBA 06 0B                ld      B,$0B           ; 11 items
6162+ 3BBC 0E 00                ld      C,$00           ; reset pointer
6163+ 3BBE 2A D6 52     CKBPS:  ld      HL,(BPS)        ; load BPS
6164+ 3BC1 DD 5E 00             ld      E,(IX+0)        ; load LSB of item
6165+ 3BC4 DD 56 01             ld      D,(IX+1)        ; load MSB of item
6166+ 3BC7 CD 88 3F             call    CMP16           ; is it equal?
6167+ 3BCA CA D7 3B             jp      Z,SET_PT        ; yes, found a correspondance
6168+ 3BCD DD 23                inc     IX
6169+ 3BCF DD 23                inc     IX              ; no, go to next entry
6170+ 3BD1 0C                   inc     C               ; increment pointer
6171+ 3BD2 10 EA                djnz    CKBPS           ; repeat for 10 entries
6172+ 3BD4 C3 C5 3C             jp      SCERR1          ; if nothing found, raise an error
6173+ 3BD7              SET_PT: ;init CTC CH0: CH0 provides RX/TX clock to SIO port A
6174+ 3BD7                      ; TO0 output frequency=INPUT CLK/time constant. Time constant is set to get 16 times
6175+ 3BD7                      ; the requested baud rate. I.e., if bps is 19,200 then time constast is set to 6 because
6176+ 3BD7                      ; 1,843,200/6 = 307,200 Hz (that is 19,200 x 16)
6177+ 3BD7 F3                   di                      ; disable INTs
6178+ 3BD8 06 00                ld      B,$00           ; reset B
6179+ 3BDA 21 BA 3C             ld      HL,CTC_CFG      ; address of first CTC divider
6180+ 3BDD 09                   add     HL,BC           ; adjust for correct CTC divider
6181+ 3BDE 0E 10                ld      C,CTC_CH0       ; CTC channel 0
6182+ 3BE0 3A D5 52             ld      A,(PRTNUM)      ; load port number
6183+ 3BE3 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6184+ 3BE4 DA E8 3B             jp      C,SET_CTC       ; port 1 => ch. 0, so continue
6185+ 3BE7 0C                   inc     C               ; port 2 => ch. 1, increment address port into C
6186+ 3BE8 3E 47        SET_CTC:ld      A,%01000111     ; interrupt off, counter mode, prsc=16 (doesn't matter), ext. start,
6187+ 3BEA                                              ; start upon loading time constant, time constant follows, sw reset, command word
6188+ 3BEA ED 79                out     (C),A           ; configure CTC channel
6189+ 3BEC 7E                   ld      A,(HL)          ; load CTC divider
6190+ 3BED ED 79                out     (C),A           ; send divider
6191+ 3BEF                      ; configure SIO
6192+ 3BEF 21 38 03             ld      HL,SIO_A_SETS   ; load default settings for SIO
6193+ 3BF2 11 DB 52             ld      DE,SIOBFR       ; into a temp buffer
6194+ 3BF5 01 0A 00             ld      BC,$000A        ; 10 items to copy
6195+ 3BF8 ED B0                ldir                    ; copy SIO settings into TEMP buffer
6196+ 3BFA 3A E0 52             ld      A,(SIOBFR+5)    ; load WR5 setting
6197+ 3BFD 47                   ld      B,A             ; move it into B
6198+ 3BFE 3A D8 52             ld      A,(DATABT)      ; load DATA bits
6199+ 3C01 FE 05                cp      $05             ; is it 5 bits?
6200+ 3C03 20 06                jr      NZ,BITS6        ; no, jump over
6201+ 3C05 CB B0                res     6,B
6202+ 3C07 CB A8                res     5,B             ; set D6 & D5 to 0
6203+ 3C09 18 19                jr      SETPAR          ; jump to set parity
6204+ 3C0B FE 06        BITS6:  cp      $06             ; is it 6 bits?
6205+ 3C0D 20 06                jr      NZ,BITS7        ; no, jump over
6206+ 3C0F CB F0                set     6,B
6207+ 3C11 CB A8                res     5,B             ; set D6 & D5 to 1,0
6208+ 3C13 18 0F                jr      SETPAR          ; jump to set parity
6209+ 3C15 FE 07        BITS7:  cp      $07             ; is it 7 bits?
6210+ 3C17 20 07                jr      NZ,BITS8        ; no, jump over
6211+ 3C19 CB B0                res     6,B
6212+ 3C1B CB E8                set     5,B             ; set D6 & D5 to 0,1
6213+ 3C1D C3 24 3C             jp      SETPAR          ; jump to set parity
6214+ 3C20 CB F0        BITS8:  set     6,B
6215+ 3C22 CB E8                set     5,B             ; set D6 & D5 to 1,1
6216+ 3C24 21 10 53     SETPAR: ld      HL,SERABITS     ; load address for storing data bits
6217+ 3C27 3A D5 52             ld      A,(PRTNUM)      ; check serial port number
6218+ 3C2A 3D                   dec     A               ; is it port #1?
6219+ 3C2B CA 2F 3C             jp      Z,SETPAR2       ; yes, jump over
6220+ 3C2E 23                   inc     HL              ; port #2, use SERBBITS instead
6221+ 3C2F 78           SETPAR2:ld      A,B             ; retrieve DATA bits
6222+ 3C30 32 E0 52             ld      (SIOBFR+5),A    ; save DATA bits
6223+ 3C33 E6 60                and     %01100000       ; filter only D5&D6 bits
6224+ 3C35 87                   add     A,A             ; shift left times 1
6225+ 3C36 77                   ld      (HL),A          ; store for SIO_EI & SIO_DI functions
6226+ 3C37 3A DA 52             ld      A,(STPBT)       ; load STOP bits
6227+ 3C3A 87                   add     A,A
6228+ 3C3B 87                   add     A,A             ; 2 left shifts
6229+ 3C3C 47                   ld      B,A             ; move forming byte into B
6230+ 3C3D 3A D9 52             ld      A,(PARBT)       ; load PARITY setting
6231+ 3C40 A7                   and     A               ; is it 0?
6232+ 3C41 CA 4C 3C             jp      Z,STRPAR        ; yes, jump over
6233+ 3C44 CB C0                set     0,B             ; set PARITY on
6234+ 3C46 3D                   dec     A               ; is parity ODD?
6235+ 3C47 CA 4C 3C             jp      Z,STRPAR        ; yes, so jump over
6236+ 3C4A CB C8                set     1,B             ; no, it's EVEN so set the corresponding bit
6237+ 3C4C 3A DE 52     STRPAR: ld      A,(SIOBFR+3)    ; load WR4 setting
6238+ 3C4F E6 F0                and     %11110000       ; reset STOP & PARITY bits
6239+ 3C51 B0                   or      B               ; set new STOP & PARITY bits
6240+ 3C52 32 DE 52             ld      (SIOBFR+3),A    ; store new value
6241+ 3C55                      ;set up TX and RX:
6242+ 3C55                      ; the followings are settings for channel A
6243+ 3C55 21 DB 52             ld      HL,SIOBFR       ; settings for SIO ch. A
6244+ 3C58 06 06                ld      B,$06           ; 6 bytes to send
6245+ 3C5A 0E 22                ld      C,SIO_CA        ; I/O address of SIO ch.A
6246+ 3C5C 3A D5 52             ld      A,(PRTNUM)      ; load port number
6247+ 3C5F 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6248+ 3C60 DA 64 3C             jp      C,SRLCNT        ; port 1, continue
6249+ 3C63 0C                   inc     C               ; port 2, increment address port into C
6250+ 3C64 ED B3        SRLCNT: otir                    ; send bytes to SIO
6251+ 3C66                      ; the following are settings for channel B (don't need to load HL since settings are contigous)
6252+ 3C66 06 04                ld      B,$04           ; other 4 bytes to send
6253+ 3C68 51                   ld      D,C             ; store port address into D
6254+ 3C69 0E 23                ld      C,SIO_CB        ; I/O address of SIO ch.B
6255+ 3C6B ED B3                otir                    ; send bytes to SIO
6256+ 3C6D                      ; the following are settings for selected channel
6257+ 3C6D 3E 01                ld      A,$01           ; write into WR0: select WR1
6258+ 3C6F 4A                   ld      C,D             ; retrieve port address
6259+ 3C70 ED 79                out     (C),A
6260+ 3C72 3E 18                ld      A,%00011000     ; interrupts on every RX char; parity is no special condition;
6261+ 3C74                                              ; buffer overrun is special condition
6262+ 3C74 ED 79                out     (C),A
6263+ 3C76 21 0F 53             ld      HL,SERIALS_EN
6264+ 3C79 3A D5 52             ld      A,(PRTNUM)      ; retrieve serial channel
6265+ 3C7C 3D                   dec     A               ; channel A?
6266+ 3C7D 20 10                jr      NZ,ENCHB        ; no, jump over
6267+ 3C7F CD DA 01             call    SIO_A_EI        ; enable RX on SIO channel A
6268+ 3C82 CB C6                set     0,(HL)          ; set serial port 1 status ON
6269+ 3C84 CB D6                set     2,(HL)          ; set serial port 1 RX ON
6270+ 3C86                      ; back to normal running
6271+ 3C86 FB                   ei                      ; re-enable INTs
6272+ 3C87 DB 01                in      A,(PIO_DB)      ; load status LEDs
6273+ 3C89 CB F7                set     6,A             ; set status LED on
6274+ 3C8B CB A7                res     4,A             ; set error LED off
6275+ 3C8D 18 0E                jr      EXNRM           ; leave
6276+ 3C8F CD E2 01     ENCHB:  call    SIO_B_EI        ; enable RX on SIO channel B
6277+ 3C92 CB CE                set     1,(HL)          ; set serial port 2 status ON
6278+ 3C94 CB DE                set     3,(HL)          ; set serial port 2 RX ON
6279+ 3C96                      ; back to normal running
6280+ 3C96 FB                   ei                      ; re-enable INTs
6281+ 3C97 DB 01                in      A,(PIO_DB)      ; load status LEDs
6282+ 3C99 CB FF                set     7,A             ; set status LED on
6283+ 3C9B CB AF                res     5,A             ; set error LED off
6284+ 3C9D D3 01        EXNRM:  out     (PIO_DB),A      ; send new configuration
6285+ 3C9F DD E1                pop     IX              ; retrieve IX
6286+ 3CA1 D1                   pop     DE              ; retrieve DE
6287+ 3CA2 E1                   pop     HL              ; retrieve HL
6288+ 3CA3 C9                   ret                     ; return to caller
6289+ 3CA4
6290+ 3CA4              ; allowed bps (Bauds per second)
6291+ 3CA4 00 E1 00 96  SUP_BPS:defw    57600,38400,28800,19200,14400,9600,4800,3600,2400,1200,600
6291+ 3CA8 80 70 00 4B
6291+ 3CAC 40 38 80 25
6291+ 3CB0 C0 12 10 0E
6291+ 3CB4 60 09 B0 04
6291+ 3CB8 58 02
6292+ 3CBA              ; corresponding CTC divider
6293+ 3CBA 02 03 04 06  CTC_CFG:defb    2,3,4,6,8,12,24,32,48,96,192
6293+ 3CBE 08 0C 18 20
6293+ 3CC2 30 60 C0
6294+ 3CC5
6295+ 3CC5
6296+ 3CC5              ; serial configuration error
6297+ 3CC5 DD E1        SCERR1: pop     IX              ; retrieve IX
6298+ 3CC7 D1                   pop     DE              ; retrieve DE
6299+ 3CC8 E1                   pop     HL              ; retrieve HL
6300+ 3CC9 1E 2C        SCERR:  ld      E,SC            ; Serial Configuration Error
6301+ 3CCB C3 AF 16             jp      ERROR           ; print error
6302+ 3CCE
6303+ 3CCE
6304+ 3CCE              ; serial buffer overrun
6305+ 3CCE CD 8B 1E     SOERR:  call    PRNTCRLF
6306+ 3CD1 1E 30                ld      E,SO            ; Serial Buffer Overrun
6307+ 3CD3 C3 AF 16             jp      ERROR
6308+ 3CD6
6309+ 3CD6
6310+ 3CD6              ; check for direct mode
6311+ 3CD6 E5           DIRMOD: push    HL              ; Save code string address
6312+ 3CD7 2A 9E 51             ld      HL,(LINEAT)     ; Get current line number
6313+ 3CDA 23                   inc     HL              ; -1 means direct statement
6314+ 3CDB 7C                   ld      A,H
6315+ 3CDC B5                   or      L
6316+ 3CDD E1                   pop     HL              ; Restore code string address
6317+ 3CDE C2 F8 3C             jp      NZ,HLPERR       ; raise error if in indirect mode
6318+ 3CE1 C9                   ret
6319+ 3CE2
6320+ 3CE2
6321+ 3CE2              ; HELP lists the line program where an error occured
6322+ 3CE2 CD D6 3C     HELP:   call    DIRMOD          ; check if in direct mode
6323+ 3CE5 E5                   push    HL              ; store HL
6324+ 3CE6 2A A0 51             ld      HL,(HLPLN)      ; load HELP line
6325+ 3CE9 23                   inc     HL              ; increment HL
6326+ 3CEA 7C                   ld      A,H
6327+ 3CEB B5                   or      L               ; check if there is a line into the HELP reg.
6328+ 3CEC E1                   pop     HL
6329+ 3CED CA F8 3C             jp      Z,HLPERR        ; no line found, raise error
6330+ 3CF0 ED 5B A0 51          ld      DE,(HLPLN)      ; recover line
6331+ 3CF4 C1                   pop     BC              ; remove BC from stack since it's not needed anymore for LIST
6332+ 3CF5 C3 0B 1A             jp      LST01H          ; jump to list line
6333+ 3CF8 1E 32        HLPERR: ld      E,HP            ; HELP call error
6334+ 3CFA C3 AF 16             jp      ERROR           ; raise error
6335+ 3CFD
6336+ 3CFD
6337+ 3CFD              ; KEY command to list/modify function keys and auto-repeat
6338+ 3CFD 2B           KEY:    dec     HL              ; dec 'cos GETCHR INCs
6339+ 3CFE CD BE 1B             call    GETCHR          ; Get next character
6340+ 3D01 CA 81 3D             jp      Z,LSTKEYS       ; jump if nothing follows
6341+ 3D04                      ; change FN keys
6342+ 3D04 CD CD 28             call    GETINT          ; get a number
6343+ 3D07 A7                   and     A               ; is it 0?
6344+ 3D08 20 10                jr      NZ,KEYCH        ; no, jump over
6345+ 3D0A E5           RESFN:  push    HL              ; yes - reset FN keys to defaults
6346+ 3D0B D5                   push    DE              ; store HL & DE
6347+ 3D0C 21 89 15             ld      HL,AUTORP       ; pointer to default auto-repeat delays and FN keys texts
6348+ 3D0F 11 A2 51             ld      DE,KEYDEL       ; pointer to destination
6349+ 3D12 01 82 00             ld      BC,$0082        ; 130 chars to be copied (2xauto-delay, 128xFN keys)
6350+ 3D15 ED B0                ldir                    ; restore default texts
6351+ 3D17 D1                   pop     DE              ; retrieve DE
6352+ 3D18 E1                   pop     HL              ; retrieve HL
6353+ 3D19 C9                   ret                     ; return to caller
6354+ 3D1A FE 09        KEYCH:  cp      $09             ; is it >= 9?
6355+ 3D1C D2 34 3E             jp      NC,SETREP       ; yes - jump over
6356+ 3D1F 3D                   dec     A               ; FN key in range 0~7
6357+ 3D20 87                   add     A,A             ; multiply A...
6358+ 3D21 87                   add     A,A             ; ... times 4...
6359+ 3D22 87                   add     A,A             ; ... to get the correct...
6360+ 3D23 87                   add     A,A             ; ... offset fo FN key text
6361+ 3D24 32 CD 52             ld      (TMPBFR1),A     ; store FN key offset...
6362+ 3D27 AF                   xor     A               ; ...in a...
6363+ 3D28 32 CE 52             ld      (TMPBFR1+1),A   ; ...16-bit register
6364+ 3D2B CD 7D 19             call    CHKSYN          ; Make sure ',' follows
6365+ 3D2E 2C                   defb    ','
6366+ 3D2F 44 4D                ld      BC,HL           ; copy address into BC
6367+ 3D31 CD 59 20             call    EVAL            ; Evaluate expression (in E there is the length)
6368+ 3D34 E5                   push    HL              ; store string pointer
6369+ 3D35 3A 83 52             ld      A,(TYPE)        ; Get variable type
6370+ 3D38 B7                   or      A               ; Is it a string variable?
6371+ 3D39 CA 9B 16             jp      Z,SNERR         ; no - syntax error
6372+ 3D3C CD 92 26             call    GSTRCU          ; Current string to pool
6373+ 3D3F CD A3 2E             call    LOADFP          ; Move string block data to (BC=pointer, DE=length)
6374+ 3D42 7B                   ld      A,E             ; copy length into A
6375+ 3D43 FE 11                cp      $11             ; is length > 16?
6376+ 3D45 DA 4A 3D             jp      C,DECLN1        ; no, jump over
6377+ 3D48 1E 10                ld      E,$10           ; yes, so set length to 16
6378+ 3D4A 3E 10        DECLN1: ld      A,$10           ; calculate how many...
6379+ 3D4C 93                   sub     E               ; ...null chars needed to fill up...
6380+ 3D4D 57                   ld      D,A             ; ...the FN key text
6381+ 3D4E C5                   push    BC              ; store address of string
6382+ 3D4F ED 4B CD 52          ld      BC,(TMPBFR1)    ; load FN key offset
6383+ 3D53 21 A4 51             ld      HL,FNKEYS       ; load address of FN keys texts
6384+ 3D56 09                   add     HL,BC           ; get corrected address
6385+ 3D57 C1                   pop     BC              ; retrieve address of string chars
6386+ 3D58 0A           CPKEY:  ld      A,(BC)          ; load char from string
6387+ 3D59 FE 0D                cp      CR              ; return?
6388+ 3D5B CA 68 3D             jp      Z,CPKEY2        ; yes, store char
6389+ 3D5E FE 7B                cp      $7B             ; if char > "z" ?
6390+ 3D60 D2 9B 16             jp      NC,SNERR        ; yes - syntax error
6391+ 3D63 FE 20                cp      $20             ; is char < space?
6392+ 3D65 DA 9B 16             jp      C,SNERR         ; yes - syntax error
6393+ 3D68 FE 61        CPKEY2: cp      $61             ; is it >= 'a'?
6394+ 3D6A DA 6F 3D             jp      C,CPKEY3        ; no, continue
6395+ 3D6D E6 5F                and     %01011111       ; set letters to uppercase
6396+ 3D6F 77           CPKEY3: ld      (HL),A          ; store char
6397+ 3D70 23                   inc     HL              ; next string char
6398+ 3D71 03                   inc     BC              ; next free cell
6399+ 3D72 1D                   dec     E               ; decrement E
6400+ 3D73 20 E3                jr      NZ,CPKEY        ; repeat until 0
6401+ 3D75 AF                   xor     A               ; null char
6402+ 3D76 14                   inc     D               ; +1 to decrement below
6403+ 3D77 15           CPKEY1: dec     D               ; how many null chars to insert?
6404+ 3D78 CA 7F 3D             jp      Z,CPKYEND       ; no more nulls, so exit
6405+ 3D7B 77                   ld      (HL),A          ; store it
6406+ 3D7C 23                   inc     HL              ; next cell
6407+ 3D7D 18 F8                jr      CPKEY1          ; repeat
6408+ 3D7F E1           CPKYEND:pop     HL              ; retrieve pointer to string
6409+ 3D80 C9                   ret                     ; return to caller
6410+ 3D81                                              ; list FN keys
6411+ 3D81 E5           LSTKEYS:push    HL              ; Save code string address
6412+ 3D82 2A 9E 51             ld      HL,(LINEAT)     ; Get current line number
6413+ 3D85 23                   inc     HL              ; -1 means direct statement
6414+ 3D86 7C                   ld      A,H
6415+ 3D87 B5                   or      L
6416+ 3D88 E1                   pop     HL              ; Restore code string address
6417+ 3D89 C2 9B 16             jp      NZ,SNERR        ; raise error if in indirect mode
6418+ 3D8C E5                   push    HL              ; store HL
6419+ 3D8D D5                   push    DE              ; store DE
6420+ 3D8E 21 A4 51             ld      HL,FNKEYS       ; load starting address of FN keys text
6421+ 3D91 0E 01                ld      C,$01           ; 8 function keys
6422+ 3D93 06 10        PRTK4:  ld      B,$10           ; 16 chars each
6423+ 3D95 11 56 3E     PRTK2:  ld      DE,CHKEY1       ; message "KEY "
6424+ 3D98 CD 25 3E             call    PRTCKEY         ; print it
6425+ 3D9B 79                   ld      A,C             ; load FN key
6426+ 3D9C C6 30                add     $30             ; get number in ASCI code
6427+ 3D9E CD 88 19             call    OUTC            ; print it
6428+ 3DA1 11 5B 3E             ld      DE,CHKEY2       ; message ": ""
6429+ 3DA4 CD 25 3E             call    PRTCKEY         ; print it
6430+ 3DA7 3E 01                ld      A,$01           ; " opened
6431+ 3DA9 32 CD 52             ld      (TMPBFR1),A
6432+ 3DAC 7E           LDKEY:  ld      A,(HL)          ; retrieve char
6433+ 3DAD A7                   and     A               ; is it zero?
6434+ 3DAE CA C1 3D             jp      Z,CNTLTK        ; yes, go next char
6435+ 3DB1 CD 0D 3E             call    OPNQT           ; check if quotes are opened
6436+ 3DB4 FE 22                cp      $22             ; check if char is "?
6437+ 3DB6 CA D6 3D             jp      Z,PRTCHR        ; yes, print "chr$("
6438+ 3DB9 FE 0D                cp      CR              ; is it a CR?
6439+ 3DBB CA D6 3D             jp      Z,PRTCHR        ; yes, print "chr$("
6440+ 3DBE CD 88 19     PRTK3:  call    OUTC            ; no, just print it
6441+ 3DC1 23           CNTLTK: inc     HL              ; next char
6442+ 3DC2 10 E8                djnz    LDKEY           ; continue until finished
6443+ 3DC4 CD FB 3D             call    CLSQT           ; check if quotes are still open
6444+ 3DC7 3E 0D                ld      A,CR            ; go next line
6445+ 3DC9 CD 88 19             call    OUTC            ; print it
6446+ 3DCC 0C                   inc     C               ; next FN key
6447+ 3DCD 79                   ld      A,C             ; check if...
6448+ 3DCE FE 09                cp      $09             ; finished keys?
6449+ 3DD0 DA 93 3D             jp      C,PRTK4         ; no, repeat 1 more time
6450+ 3DD3 D1                   pop     DE              ; retrieve DE
6451+ 3DD4 E1                   pop     HL              ; retrieve HL
6452+ 3DD5 C9                   ret                     ; return to caller
6453+ 3DD6 E5           PRTCHR: push    HL              ; store HL
6454+ 3DD7 CD FB 3D             call    CLSQT           ; check if quotes are closed
6455+ 3DDA 3E 2B                ld      A,'+'           ; '+' char
6456+ 3DDC CD 88 19             call    OUTC            ; print it
6457+ 3DDF 11 5E 3E             ld      DE,CHKEY3       ; address of "CHR$("
6458+ 3DE2 CD 25 3E             call    PRTCKEY         ; print it
6459+ 3DE5 E1                   pop     HL              ; recover HL
6460+ 3DE6 23                   inc     HL              ; next char
6461+ 3DE7 05                   dec     B               ; increment char counter
6462+ 3DE8 11 64 3E             ld      DE,CHKEY4       ; load address of RETURN
6463+ 3DEB 7E                   ld      A,(HL)          ; load char
6464+ 3DEC FE 0D                cp      CR              ; is it a RETURN?
6465+ 3DEE 20 03                jr      NZ,PTCHR1       ; no, jump over
6466+ 3DF0 11 67 3E             ld      DE,CHKEY5       ; yes, load address of "
6467+ 3DF3 CD 25 3E     PTCHR1: call    PRTCKEY         ; print it
6468+ 3DF6 3E 29                ld      A,')'           ; char )
6469+ 3DF8 C3 BE 3D             jp      PRTK3           ; continue
6470+ 3DFB F5           CLSQT:  push    AF              ; store A
6471+ 3DFC 3A CD 52             ld      A,(TMPBFR1)     ; quote status
6472+ 3DFF A7                   and     A               ; are they closed?
6473+ 3E00 28 09                jr      Z,CLSQT1        ; if yes, return
6474+ 3E02 3E 22                ld      A,$22           ; no, so close them
6475+ 3E04 CD 88 19             call    OUTC            ; print "
6476+ 3E07 AF                   xor     A               ; set quotes
6477+ 3E08 32 CD 52             ld      (TMPBFR1),A     ; as closed
6478+ 3E0B F1           CLSQT1: pop     AF              ; retrieve A
6479+ 3E0C C9                   ret                     ; return to caller
6480+ 3E0D F5           OPNQT:  push    AF              ; store A
6481+ 3E0E 3A CD 52             ld      A,(TMPBFR1)     ; quote status
6482+ 3E11 A7                   and     A               ; are they open?
6483+ 3E12 20 0F                jr      NZ,OPNQT1       ; if yes, return
6484+ 3E14 3E 2B                ld      A,'+'           ; no, so add '+
6485+ 3E16 CD 88 19             call    OUTC            ; print it
6486+ 3E19 3E 22                ld      A,$22           ; and then open quotes
6487+ 3E1B CD 88 19             call    OUTC            ; print them
6488+ 3E1E 3E 01                ld      A,$01           ; set quotes
6489+ 3E20 32 CD 52             ld      (TMPBFR1),A     ; as opened
6490+ 3E23 F1           OPNQT1: pop     AF              ; retrieve A
6491+ 3E24 C9                   ret                     ; return to caller
6492+ 3E25 F5           PRTCKEY:push    AF              ; store original char
6493+ 3E26 1A           PRTK1:  ld      A,(DE)          ; load char
6494+ 3E27 A7                   and     A               ; is it 0?
6495+ 3E28 CA 32 3E             jp      Z,PRTEND        ; yes, finished printing
6496+ 3E2B CD 88 19             call    OUTC            ; no, print char
6497+ 3E2E 13                   inc     DE              ; next char
6498+ 3E2F C3 26 3E             jp      PRTK1           ; repeat
6499+ 3E32 F1           PRTEND: pop     AF              ; retrieve AF
6500+ 3E33 C9                   ret                     ; return to caller
6501+ 3E34 FE 09        SETREP: cp      $09             ; is it special key 9? (stands for auto-repeat)
6502+ 3E36 C2 9B 16             jp      NZ,SNERR        ; no, raise an error
6503+ 3E39 CD 7D 19             call    CHKSYN          ; Check for comma
6504+ 3E3C 2C                   defb    ','
6505+ 3E3D CD CD 28             call    GETINT          ; get a number
6506+ 3E40 32 CD 52             ld      (TMPBFR1),A     ; store it
6507+ 3E43 CD 7D 19             call    CHKSYN          ; Check for comma
6508+ 3E46 2C                   defb    ','
6509+ 3E47 CD CD 28             call    GETINT          ; get another number
6510+ 3E4A E5                   push    HL              ; store HL
6511+ 3E4B 21 A3 51             ld      HL,AUTOKE       ; address of second cell for key auto-repeat
6512+ 3E4E 77                   ld      (HL),A          ; store auto-repeat delay
6513+ 3E4F 2B                   dec     HL              ; previous cell
6514+ 3E50 3A CD 52             ld      A,(TMPBFR1)     ; retrieve value
6515+ 3E53 77                   ld      (HL),A          ; store delay for auto-repeat
6516+ 3E54 E1                   pop     HL              ; retrieve HL
6517+ 3E55 C9                   ret
6518+ 3E56 4B 45 59 20  CHKEY1: defb    "KEY ",0
6518+ 3E5A 00
6519+ 3E5B 3A 22 00     CHKEY2: defb    ":",34,0
6520+ 3E5E 63 68 72 24  CHKEY3: defb    "chr$(",0
6520+ 3E62 28 00
6521+ 3E64 31 33 00     CHKEY4: defb    "13",0
6522+ 3E67 33 34 00     CHKEY5: defb    "34",0
6523+ 3E6A
6524+ 3E6A
6525+ 3E6A              ; LOAD "filename"
6526+ 3E6A              ; load a BASIC program from disk
6527+ 3E6A C9           LOAD:   ret                     ; currently a stub for LOAD
6528+ 3E6B
6529+ 3E6B
6530+ 3E6B              ; SAVE "filename"
6531+ 3E6B              ; save a BASIC program on disk
6532+ 3E6B C9           SAVE:   ret                     ; currently a stub for SAVE
6533+ 3E6C
6534+ 3E6C
6535+ 3E6C              ; FILES
6536+ 3E6C              ; list files on disk
6537+ 3E6C C9           FILES:  ret                     ; currently a stub for FILES
6538+ 3E6D
6539+ 3E6D
6540+ 3E6D              ; ERASE "filename"
6541+ 3E6D              ; erase a file from disk
6542+ 3E6D C9           ERASE:  ret                     ; currently a stub for ERASE
6543+ 3E6E
6544+ 3E6E
6545+ 3E6E              ; HEX$(nn) Convert 16 bit number to Hexadecimal string
6546+ 3E6E CD 4A 20     HEX: 	call	TSTNUM          ; Verify it's a number
6547+ 3E71 CD 74 1C             call	DEINT           ; Get integer -32768 to 32767
6548+ 3E74 C5                   push	BC              ; Save contents of BC
6549+ 3E75 21 26 53             ld      HL,PBUFF        ; load address of PBUFF into HL
6550+ 3E78 7A                   ld      A,D             ; Get MSB into A
6551+ 3E79 B7                   or      A               ; OR with LSB to see if param=0
6552+ 3E7A 28 0C                jr      Z,HEX2          ; Skip output if both high digits are zero
6553+ 3E7C CD A4 3E             call    BYT2ASC         ; Convert D to ASCII
6554+ 3E7F 78                   ld      A,B             ; cechk if B
6555+ 3E80 FE 30                cp      '0'             ; is 0
6556+ 3E82 28 02                jr      Z,HEX1          ; Don't store high digit if zero
6557+ 3E84 70                   ld      (HL),B          ; Store it to PBUFF
6558+ 3E85 23                   inc     HL              ; Next location
6559+ 3E86 71           HEX1:   ld      (HL),C          ; Store C to PBUFF+1
6560+ 3E87 23                   inc     HL              ; Next location
6561+ 3E88 7B           HEX2:   ld      A,E             ; Get lower byte
6562+ 3E89 CD A4 3E             call    BYT2ASC         ; Convert E to ASCII
6563+ 3E8C 7A                   ld      A,D
6564+ 3E8D B7                   or      A
6565+ 3E8E 20 05                jr      NZ,HEX3         ; If upper byte was not zero then always print lower byte
6566+ 3E90 78                   ld      A,B
6567+ 3E91 FE 30                cp      '0'             ; If high digit of lower byte is zero then don't print
6568+ 3E93 28 02                jr      Z,HEX4
6569+ 3E95 70           HEX3:   ld      (HL),B          ; to PBUFF+2
6570+ 3E96 23                   inc     HL              ; Next location
6571+ 3E97 71           HEX4:   ld      (HL),C          ; to PBUFF+3
6572+ 3E98 23                   inc     HL              ; PBUFF+4 to zero
6573+ 3E99 AF                   xor     A               ; Terminating character
6574+ 3E9A 77                   ld      (HL),A          ; Store zero to terminate
6575+ 3E9B 23                   inc     HL              ; Make sure PBUFF is terminated
6576+ 3E9C 77                   ld      (HL),A          ; Store the double zero there
6577+ 3E9D C1                   pop     BC              ; Get BC back
6578+ 3E9E 21 26 53             ld      HL,PBUFF        ; Reset to start of PBUFF
6579+ 3EA1 C3 DF 24             jp      STR1            ; Convert the PBUFF to a string and return it
6580+ 3EA4 47           BYT2ASC:ld      B,A             ; Save original value
6581+ 3EA5 E6 0F                and     $0F             ; Strip off upper nybble
6582+ 3EA7 FE 0A                cp      $0A             ; 0-9?
6583+ 3EA9 38 02                jr      C,ADD30         ; If A-F, add 7 more
6584+ 3EAB C6 07                add     A,$07           ; Bring value up to ASCII A-F
6585+ 3EAD C6 30        ADD30:  add     A,$30           ; And make ASCII
6586+ 3EAF 4F                   ld      C,A             ; Save converted char to C
6587+ 3EB0 78                   ld      A,B             ; Retrieve original value
6588+ 3EB1 0F                   rrca                    ; and Rotate it right
6589+ 3EB2 0F                   rrca
6590+ 3EB3 0F                   rrca
6591+ 3EB4 0F                   rrca
6592+ 3EB5 E6 0F                and     $0F             ; Mask off upper nybble
6593+ 3EB7 FE 0A                cp      $0A             ; 0-9? < A hex?
6594+ 3EB9 38 02                jr      C,ADD301        ; Skip Add 7
6595+ 3EBB C6 07                add     A,$07           ; Bring it up to ASCII A-F
6596+ 3EBD C6 30        ADD301: add     A,$30           ; And make it full ASCII
6597+ 3EBF 47                   ld      B,A             ; Store high order byte
6598+ 3EC0 C9                   ret
6599+ 3EC1
6600+ 3EC1              ; Convert "&Hnnnn" to FPREG
6601+ 3EC1              ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
6602+ 3EC1              ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
6603+ 3EC1 EB           HEXTFP: ex      DE,HL           ; Move code string pointer to DE
6604+ 3EC2 21 00 00             ld      HL,$0000        ; Zero out the value
6605+ 3EC5 CD DA 3E             call    GETHEX          ; Check the number for valid hex
6606+ 3EC8 DA FA 3E             jp      C,HXERR         ; First value wasn't hex, HX error
6607+ 3ECB 18 05                jr      HEXLP1          ; Convert first character
6608+ 3ECD CD DA 3E     HEXLP:  call    GETHEX          ; Get second and addtional characters
6609+ 3ED0 38 1F                jr      C,HEXIT         ; Exit if not a hex character
6610+ 3ED2 29           HEXLP1: add     HL,HL           ; Rotate 4 bits to the left
6611+ 3ED3 29                   add     HL,HL
6612+ 3ED4 29                   add     HL,HL
6613+ 3ED5 29                   add     HL,HL
6614+ 3ED6 B5                   or      L               ; Add in D0-D3 into L
6615+ 3ED7 6F                   ld      L,A             ; Save new value
6616+ 3ED8 18 F3                jr      HEXLP           ; And continue until all hex characters are in
6617+ 3EDA
6618+ 3EDA 13           GETHEX: inc     DE              ; Next location
6619+ 3EDB 1A                   ld      A,(DE)          ; Load character at pointer
6620+ 3EDC FE 20                cp      SPC
6621+ 3EDE CA DA 3E             jp      Z,GETHEX        ; Skip spaces
6622+ 3EE1 D6 30                sub     $30             ; Get absolute value
6623+ 3EE3 D8                   ret     C               ; < "0", error
6624+ 3EE4 FE 0A                cp      $0A
6625+ 3EE6 38 05                jr      C,NOSUB7        ; Is already in the range 0-9
6626+ 3EE8 D6 07                sub     $07             ; Reduce to A-F
6627+ 3EEA FE 0A                cp      $0A             ; Value should be $0A-$0F at this point
6628+ 3EEC D8                   ret     C               ; CY set if was :            ; < = > ? @
6629+ 3EED FE 10        NOSUB7: cp      $10             ; > Greater than "F"?
6630+ 3EEF 3F                   ccf
6631+ 3EF0 C9                   ret                     ; CY set if it wasn't valid hex
6632+ 3EF1
6633+ 3EF1 EB           HEXIT:  ex      DE,HL           ; Value into DE, Code string into HL
6634+ 3EF2 7A                   ld      A,D             ; Load DE into AC
6635+ 3EF3 4B                   ld      C,E             ; For prep to
6636+ 3EF4 E5                   push    HL
6637+ 3EF5 CD 30 24             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6638+ 3EF8 E1                   pop     HL
6639+ 3EF9 C9                   ret
6640+ 3EFA
6641+ 3EFA DD 5C        HXERR:  ld      E,HX            ; ?HEX Error
6642+ 3EFC C3 AF 16             jp      ERROR
6643+ 3EFF
6644+ 3EFF              ; BIN$(NN) Convert integer to a 1-16 char binary string
6645+ 3EFF CD 4A 20     BIN:    call    TSTNUM          ; Verify it's a number
6646+ 3F02 CD 74 1C             call    DEINT           ; Get integer -32768 to 32767
6647+ 3F05 C5           BIN2:   push    BC              ; Save contents of BC
6648+ 3F06 21 26 53             ld      HL,PBUFF
6649+ 3F09 06 11                ld      B,$11           ; One higher than max char count (16+1)
6650+ 3F0B              ZEROSUP:                        ; Suppress leading zeros
6651+ 3F0B 05                   dec     B               ; Max 16 chars
6652+ 3F0C 78                   ld      A,B
6653+ 3F0D FE 01                cp      $01
6654+ 3F0F 28 08                jr      Z,BITOUT        ; Always output at least one character
6655+ 3F11 CB 13                rl      E
6656+ 3F13 CB 12                rl      D
6657+ 3F15 30 F4                jr      NC,ZEROSUP
6658+ 3F17 18 04                jr      BITOUT2
6659+ 3F19 CB 13        BITOUT: rl      E
6660+ 3F1B CB 12                rl      D               ; Top bit now in carry
6661+ 3F1D 3E 30        BITOUT2:ld      A,'0'           ; Char for '0'
6662+ 3F1F CE 00                adc     A,$00           ; If carry set then '0' --> '1'
6663+ 3F21 77                   ld      (HL),A
6664+ 3F22 23                   inc     HL
6665+ 3F23 05                   dec     B
6666+ 3F24 20 F3                jr      NZ,BITOUT
6667+ 3F26 AF                   xor     A               ; Terminating character
6668+ 3F27 77                   ld      (HL),A          ; Store zero to terminate
6669+ 3F28 23                   inc     HL              ; Make sure PBUFF is terminated
6670+ 3F29 77                   ld      (HL),A          ; Store the double zero there
6671+ 3F2A C1                   pop     BC
6672+ 3F2B 21 26 53             ld      HL,PBUFF
6673+ 3F2E C3 DF 24             jp      STR1
6674+ 3F31
6675+ 3F31              ; Convert "&Bnnnn" to FPREG
6676+ 3F31              ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
6677+ 3F31 EB           BINTFP: ex      DE,HL           ; Move code string pointer to DE
6678+ 3F32 21 00 00             ld      HL,$0000        ; Zero out the value
6679+ 3F35 CD 4E 3F             call    CHKBIN          ; Check the number for valid bin
6680+ 3F38 DA 5C 3F             jp      C,BINERR        ; First value wasn't bin, HX error
6681+ 3F3B D6 30        BINIT:  sub     '0'
6682+ 3F3D 29                   add     HL,HL           ; Rotate HL left
6683+ 3F3E B5                   or      L
6684+ 3F3F 6F                   ld      L,A
6685+ 3F40 CD 4E 3F             call    CHKBIN          ; Get second and addtional characters
6686+ 3F43 30 F6                jr      NC,BINIT        ; Process if a bin character
6687+ 3F45 EB                   ex      DE,HL           ; Value into DE, Code string into HL
6688+ 3F46 7A                   ld      A,D             ; Load DE into AC
6689+ 3F47 4B                   ld      C,E             ; For prep to
6690+ 3F48 E5                   push    HL
6691+ 3F49 CD 30 24             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6692+ 3F4C E1                   pop     HL
6693+ 3F4D C9                   ret
6694+ 3F4E
6695+ 3F4E              ; Char is in A, NC if char is 0 or 1
6696+ 3F4E 13           CHKBIN: inc     DE
6697+ 3F4F 1A                   ld      A,(DE)
6698+ 3F50 FE 20                cp      SPC
6699+ 3F52 CA 4E 3F             jp      Z,CHKBIN        ; Skip spaces
6700+ 3F55 FE 30                cp      '0'             ; Set C if < '0'
6701+ 3F57 D8                   ret     C
6702+ 3F58 FE 32                cp      '2'
6703+ 3F5A 3F                   ccf                     ; Set C if > '1'
6704+ 3F5B C9                   ret
6705+ 3F5C
6706+ 3F5C 1E 28        BINERR: ld      E,BN            ; ?BIN Error
6707+ 3F5E C3 AF 16             jp      ERROR
6708+ 3F61
6709+ 3F61
6710+ 3F61 C3 08 00     MONOUT: jp      $0008           ; output a char
6711+ 3F64
6712+ 3F64
6713+ 3F64 3A 0F 53     RESET:  ld      A,(SERIALS_EN)
6714+ 3F67 E6 11                and     $11             ; are serial ports open?
6715+ 3F69 C4 D4 3A             call    NZ,RSTSERS      ; yes, reset serials
6716+ 3F6C CD E8 28             call    DISNMI          ; disable NMI vector
6717+ 3F6F F3                   di                      ; disable INTs
6718+ 3F70                  IFDEF LM80C64K
6719+ 3F70 C3 C0 50             jp      ROM2RAM         ; Restart
6720+ 3F73                  ELSE
6721+ 3F73 ~                    jp      $0000           ; Restart
6722+ 3F73                  ENDIF
6723+ 3F73
6724+ 3F73
6725+ 3F73 3E 00        INITST: ld      A,$00           ; Clear break flag
6726+ 3F75 32 98 51             ld      (BRKFLG),A
6727+ 3F78 C3 C7 11             jp      INIT
6728+ 3F7B
6729+ 3F7B
6730+ 3F7B F5           TSTBIT: push    AF              ; Save bit mask
6731+ 3F7C A0                   and     B               ; Get common bits
6732+ 3F7D C1                   pop     BC              ; Restore bit mask
6733+ 3F7E B8                   cp      B               ; Same bit set?
6734+ 3F7F 3E 00                ld      A,$00           ; Return 0 in A
6735+ 3F81 C9                   ret
6736+ 3F82
6737+ 3F82 CD 88 19     OUTNCR: call    OUTC            ; Output character in A
6738+ 3F85 C3 8B 1E             jp      PRNTCRLF        ; Output CRLF
6739+ 3F88
# file closed: ../include/basic/basic-1.03.asm
  79  3F88
  80  3F88              ; include utils
  81  3F88                  INCLUDE "../include/utils/utils-r11.asm"
# file opened: ../include/utils/utils-r11.asm
   1+ 3F88              ; ------------------------------------------------------------------------------
   2+ 3F88              ; LM80C - UTILITY ROUTINES - R1.1
   3+ 3F88              ; ------------------------------------------------------------------------------
   4+ 3F88              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 3F88              ; designed by Leonardo Miliani. More info at
   6+ 3F88              ; www DOT leonardomiliani DOT com
   7+ 3F88              ;
   8+ 3F88              ; *ALS are routines from "Z80 Assembly Language Subroutines" by Lance
   9+ 3F88              ; A. Leventhal and Winthrop Saville - Ed. Osborne/McGraw-Hill (1983)
  10+ 3F88              ;
  11+ 3F88              ; * WKT are routines from WikiTI:
  12+ 3F88              ; http://wikiti.brandonw.net/index.php?title=WikiTI_Home
  13+ 3F88              ;
  14+ 3F88              ; * LAC are routines from Learn@Cemetch
  15+ 3F88              ; https://learn.cemetech.net/index.php/Main_Page
  16+ 3F88              ;
  17+ 3F88              ; ------------------------------------------------------------------------------
  18+ 3F88              ; Code Revision:
  19+ 3F88              ; R1.0 - 20200110 - First release: 16-bit comparision/multiplication/negation
  20+ 3F88              ; R1.1 - 20200413 - Second release: added ABS(HL)
  21+ 3F88              ;
  22+ 3F88              ; ------------------------------------------------------------------------------
  23+ 3F88
  24+ 3F88              ; compare two 16-bit registers, HL (minuend) and DE (subtrahend)
  25+ 3F88              ; values can be both signed or unsigned words
  26+ 3F88              ; inputs: HL, DE
  27+ 3F88              ; destroys: A,F,HL
  28+ 3F88              ;
  29+ 3F88              ; returns: Z=1 if HL = DE
  30+ 3F88              ; for UNSIGNED: C=1 if HL<DE  //  C=0 if HL>DE
  31+ 3F88              ; for SIGNED:   S=1 (M) if HL<DE  //  S=0 (P) if HL>DE
  32+ 3F88              ; if HL=DE: Z,P,NC  - Z=1, S=0; C=0
  33+ 3F88              ; if HL>DE: NZ,P,NC - Z=0, S=0; C=0
  34+ 3F88              ; if HL<DE: NZ,M,C  - Z=0, S=1; C=1
  35+ 3F88              ; Source: ALS
  36+ 3F88
  37+ 3F88 B7           CMP16:  or      A           ; clear CARRY
  38+ 3F89 ED 52                sbc     HL,DE       ; subtract DE from HL
  39+ 3F8B E0                   ret     PO          ; return if no overflow
  40+ 3F8C 7C                   ld      A,H         ; overflow - invert SIGN flag
  41+ 3F8D 1F                   rra                 ; save CARRY flag in bit 7
  42+ 3F8E EE 40                xor     %01000000   ; complement bit 6 (SIGN bit)
  43+ 3F90 37                   scf                 ; ensure a Non-Zero result
  44+ 3F91 8F                   adc     A,A         ; restore CARRY, complemented SIGN
  45+ 3F92                                          ; ZERO flag = 0 for sure
  46+ 3F92 C9                   ret                 ; return
  47+ 3F93
  48+ 3F93              ; ----------------------------------------------------------------------
  49+ 3F93
  50+ 3F93              ; multiply 2 signed/unsigned 16-bit words and return a 16-bit
  51+ 3F93              ; signed/unsigned product
  52+ 3F93              ; inputs: HL (multiplicand); DE (multiplier)
  53+ 3F93              ; destroys: A,F
  54+ 3F93              ; returns: HL (product)
  55+ 3F93              ; Source: ALS
  56+ 3F93
  57+ 3F93              ; initialize partial product, bit count
  58+ 3F93 C5           MUL16:  push    BC
  59+ 3F94 4D                   ld      C,L         ; BC = multiplier
  60+ 3F95 44                   ld      B,H
  61+ 3F96 21 00 00             ld      HL,0        ; product = 0
  62+ 3F99 3E 0F                ld      A,$0F       ; count = bit lenght - 1 (16-1)
  63+ 3F9B                      ; shift-and-add algorithm
  64+ 3F9B                      ; if MSB of multiplier is 1, add multiplicand to partial product
  65+ 3F9B                      ; shift partial product, multiplier left 1 bit
  66+ 3F9B CB 23        MLP:    sla     E           ; shift multiplier left 1 bit
  67+ 3F9D CB 12                rl      D
  68+ 3F9F 30 01                jr      NC,MLP1     ; jump if MSB of multiplier = 0
  69+ 3FA1 09                   add     HL,BC       ; add multiplicand to partial product
  70+ 3FA2 29           MLP1:   add     HL,HL       ; shift partial product left
  71+ 3FA3 3D                   dec     A
  72+ 3FA4 20 F5                jr      NZ,MLP      ; continue until count = 0
  73+ 3FA6                      ; add multiplicand one last time if MSB of multiplier is 1
  74+ 3FA6 B2                   or      D           ; sign flag = MSB of multiplier
  75+ 3FA7 F2 AB 3F             jp      P,EXMUL16   ; exit if MSB of multiplier is 0
  76+ 3FAA 09                   add     HL,BC       ; add multiplicand to product
  77+ 3FAB C1           EXMUL16:pop     BC
  78+ 3FAC C9                   ret
  79+ 3FAD
  80+ 3FAD              ; ----------------------------------------------------------------------
  81+ 3FAD              ; absolute value of HL (same applies to other 16-bit register pairs)
  82+ 3FAD              ; also, invert value of HL (or any other 16-bit register, just adjust the code)
  83+ 3FAD              ;
  84+ 3FAD              ; inputs: HL
  85+ 3FAD              ; destroys: A
  86+ 3FAD              ; operation: ABS(HL)
  87+ 3FAD              ; returns: HL with no sign or negated
  88+ 3FAD              ; Source: WKT
  89+ 3FAD
  90+ 3FAD CB 7C        absHL:  bit     7,H
  91+ 3FAF C8                   ret     Z
  92+ 3FB0 AF           negHL:  xor     A
  93+ 3FB1 95                   sub     L
  94+ 3FB2 6F                   ld      L,A
  95+ 3FB3 9F                   sbc     A,A
  96+ 3FB4 94                   sub     H
  97+ 3FB5 67                   ld      H,A
  98+ 3FB6 C9                   ret
  99+ 3FB7
 100+ 3FB7              ; ------------------------------------------------------------------------------
 101+ 3FB7
 102+ 3FB7              ; 8/8 division
 103+ 3FB7              ; INPUT: D (dividend), E (divisor)
 104+ 3FB7              ; OPERATION: D/E
 105+ 3FB7              ; OUTPUT: D (quotient), A (remainder)
 106+ 3FB7 AF           DIV_8_8:    xor     A
 107+ 3FB8 C5                       push    BC
 108+ 3FB9 06 08                    ld      B,08h
 109+ 3FBB CB 22        DIV_8_8LOOP:sla     D
 110+ 3FBD 17                       rla
 111+ 3FBE BB                       cp      E
 112+ 3FBF 38 02                    jr      C,$+4
 113+ 3FC1 93                       sub     E
 114+ 3FC2 14                       inc     D
 115+ 3FC3 10 F6                    djnz    DIV_8_8LOOP
 116+ 3FC5 C1                       pop     BC
 117+ 3FC6 C9                       ret
 118+ 3FC7
 119+ 3FC7              ; ----------------------------------------------------------------------
 120+ 3FC7              ; divide a 16-bit number by an 8-bit number
 121+ 3FC7              ; (16/8 division)
 122+ 3FC7              ;
 123+ 3FC7              ; inputs: HL (Dividend), C (divisor)
 124+ 3FC7              ; destroys: A
 125+ 3FC7              ; OPERATION: HL/C
 126+ 3FC7              ; returns: HL (quotient), A (remainder)
 127+ 3FC7              ; source: WKT
 128+ 3FC7
 129+ 3FC7 AF           DIV_16_8:   xor     A
 130+ 3FC8 06 10                    ld      B,16
 131+ 3FCA 29           DIV_16_8LP: add     HL,HL
 132+ 3FCB 17                       rla
 133+ 3FCC 38 03                    jr      C,$+5
 134+ 3FCE B9                       cp      C
 135+ 3FCF 38 02                    jr      C,$+4
 136+ 3FD1 91                       sub     C
 137+ 3FD2 2C                       inc     L
 138+ 3FD3 10 F5                    djnz    DIV_16_8LP
 139+ 3FD5 C9                       ret
 140+ 3FD6
 141+ 3FD6              ; ----------------------------------------------------------------------
 142+ 3FD6              ; divide a 16-bit number by a 16-bit number
 143+ 3FD6              ; (16/16 division)
 144+ 3FD6              ;
 145+ 3FD6              ; inputs: AC (Dividend), DE (divisor)
 146+ 3FD6              ; destroys: HL,A,C
 147+ 3FD6              ; OPERATION: AC/DE
 148+ 3FD6              ; returns: AC (quotient), HL (remainder)
 149+ 3FD6              ; source: WKT
 150+ 3FD6 21 00 00     DIV_16_16:  ld      HL, 0
 151+ 3FD9 06 10                    ld      B, 16
 152+ 3FDB CB 21        DV16_16_LP: sla     C
 153+ 3FDD CB C1                    set     0,C         ; this simulates the SLL undocumented instruction
 154+ 3FDF 17                       rla
 155+ 3FE0 ED 6A                    adc     HL,HL
 156+ 3FE2 ED 52                    sbc     HL,DE
 157+ 3FE4 30 02                    jr      NC, $+4
 158+ 3FE6 19                       add     HL,DE
 159+ 3FE7 0D                       dec     C
 160+ 3FE8 10 F1                    djnz    DV16_16_LP
 161+ 3FEA C9                       ret
# file closed: ../include/utils/utils-r11.asm
  82  3FEB
  83  3FEB              ; include the latest version of the font sets
  84  3FEB                  INCLUDE "../include/vdp/6x8fonts-r16.asm"
# file opened: ../include/vdp/6x8fonts-r16.asm
   1+ 3FEB              ; ------------------------------------------------------------------------------
   2+ 3FEB              ; LM80C - 6x8 CHARSET - R1.6
   3+ 3FEB              ; ------------------------------------------------------------------------------
   4+ 3FEB              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 3FEB              ; designed by Leonardo Miliani. More info at
   6+ 3FEB              ; www DOT leonardomiliani DOT com
   7+ 3FEB              ; ------------------------------------------------------------------------------
   8+ 3FEB              ; Code Revision:
   9+ 3FEB              ; R1.0 - 20190511 - First revision: ASCII chars (from 0 to 127)
  10+ 3FEB              ; R1.1 - 20190521 - Expanded to 255 chars
  11+ 3FEB              ; R1.2 - 20191209 - Start adding graphic chars to be coherent with 8x8 fonts
  12+ 3FEB              ; R1.3 - 20191226 - Added extended char codes (128-255)
  13+ 3FEB              ; R1.4 - 20200228 - adopted more usual hexadecimal & binary prefixes
  14+ 3FEB              ; R1.5 - 20200524 - New style for char #252
  15+ 3FEB              ; R1.6 - 20200704 - Redefined chars 105, 106, and 252
  16+ 3FEB              ; ------------------------------------------------------------------------------
  17+ 3FEB              ;
  18+ 3FEB              ;-------------------------------------------------------------------------------
  19+ 3FEB              ;
  20+ 3FEB              ;               6 x 8    C  H  A  R  S  E  T
  21+ 3FEB              ;
  22+ 3FEB              ;-------------------------------------------------------------------------------
  23+ 3FEB              ;
  24+ 3FEB              ;       6X8 CHARS, DESIGNED FOR TEXT BUT USABLE IN GRAPHICS 1 MODE TOO
  25+ 3FEB              ;       UPDATE: NOW GRAPHICS 1 MODE HAS ITS OWN CHAR SET
  26+ 3FEB
  27+ 3FEB              CHRST68 equ $
  28+ 3FEB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  28+ 3FEF 00 00 00 00
  29+ 3FF3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  29+ 3FF7 00 00 00 00
  30+ 3FFB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  30+ 3FFF 00 00 00 00
  31+ 4003 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  31+ 4007 00 00 00 00
  32+ 400B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  32+ 400F 00 00 00 00
  33+ 4013 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  33+ 4017 00 00 00 00
  34+ 401B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  34+ 401F 00 00 00 00
  35+ 4023 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  35+ 4027 00 00 00 00
  36+ 402B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
  36+ 402F 00 00 00 00
  37+ 4033 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  37+ 4037 00 00 00 00
  38+ 403B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  38+ 403F 00 00 00 00
  39+ 4043 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11
  39+ 4047 00 00 00 00
  40+ 404B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  40+ 404F 00 00 00 00
  41+ 4053 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
  41+ 4057 00 00 00 00
  42+ 405B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
  42+ 405F 00 00 00 00
  43+ 4063 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  43+ 4067 00 00 00 00
  44+ 406B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  44+ 406F 00 00 00 00
  45+ 4073 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  45+ 4077 00 00 00 00
  46+ 407B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  46+ 407F 00 00 00 00
  47+ 4083 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  47+ 4087 00 00 00 00
  48+ 408B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
  48+ 408F 00 00 00 00
  49+ 4093 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  49+ 4097 00 00 00 00
  50+ 409B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
  50+ 409F 00 00 00 00
  51+ 40A3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
  51+ 40A7 00 00 00 00
  52+ 40AB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
  52+ 40AF 00 00 00 00
  53+ 40B3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
  53+ 40B7 00 00 00 00
  54+ 40BB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
  54+ 40BF 00 00 00 00
  55+ 40C3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
  55+ 40C7 00 00 00 00
  56+ 40CB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
  56+ 40CF 00 00 00 00
  57+ 40D3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
  57+ 40D7 00 00 00 00
  58+ 40DB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
  58+ 40DF 00 00 00 00
  59+ 40E3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
  59+ 40E7 00 00 00 00
  60+ 40EB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32: space
  60+ 40EF 00 00 00 00
  61+ 40F3 20 20 20 20          defb $20,$20,$20,$20,$20,$00,$20,$00 ; char 33: !
  61+ 40F7 20 00 20 00
  62+ 40FB 50 50 00 00          defb $50,$50,$00,$00,$00,$00,$00,$00 ; char 34: "
  62+ 40FF 00 00 00 00
  63+ 4103 50 50 F8 50          defb $50,$50,$f8,$50,$f8,$50,$50,$00 ; char 35: #
  63+ 4107 F8 50 50 00
  64+ 410B 20 78 A0 70          defb $20,$78,$a0,$70,$28,$f0,$20,$00 ; char 36: $
  64+ 410F 28 F0 20 00
  65+ 4113 C0 C8 10 20          defb $c0,$c8,$10,$20,$40,$98,$18,$00 ; char 37: %
  65+ 4117 40 98 18 00
  66+ 411B 60 90 A0 40          defb $60,$90,$a0,$40,$a8,$90,$68,$00 ; char 38: &
  66+ 411F A8 90 68 00
  67+ 4123 60 20 40 00          defb $60,$20,$40,$00,$00,$00,$00,$00 ; char 39: '
  67+ 4127 00 00 00 00
  68+ 412B 10 20 40 40          defb $10,$20,$40,$40,$40,$20,$10,$00 ; char 40: (
  68+ 412F 40 20 10 00
  69+ 4133 40 20 10 10          defb $40,$20,$10,$10,$10,$20,$40,$00 ; char 41: )
  69+ 4137 10 20 40 00
  70+ 413B 00 20 A8 70          defb $00,$20,$a8,$70,$a8,$20,$00,$00 ; char 42: *
  70+ 413F A8 20 00 00
  71+ 4143 00 20 20 F8          defb $00,$20,$20,$f8,$20,$20,$00,$00 ; char 43: +
  71+ 4147 20 20 00 00
  72+ 414B 00 00 00 00          defb $00,$00,$00,$00,$60,$20,$40,$00 ; char 44: ,
  72+ 414F 60 20 40 00
  73+ 4153 00 00 00 F8          defb $00,$00,$00,$f8,$00,$00,$00,$00 ; char 45: -
  73+ 4157 00 00 00 00
  74+ 415B 00 00 00 00          defb $00,$00,$00,$00,$00,$60,$60,$00 ; char 46: .
  74+ 415F 00 60 60 00
  75+ 4163 00 08 10 20          defb $00,$08,$10,$20,$40,$80,$00,$00 ; char 47: /
  75+ 4167 40 80 00 00
  76+ 416B 70 88 98 A8          defb $70,$88,$98,$a8,$c8,$88,$70,$00 ; char 48: 0
  76+ 416F C8 88 70 00
  77+ 4173 20 60 20 20          defb $20,$60,$20,$20,$20,$20,$70,$00 ; char 49: 1
  77+ 4177 20 20 70 00
  78+ 417B 70 88 08 10          defb $70,$88,$08,$10,$20,$40,$f8,$00 ; char 50: 2
  78+ 417F 20 40 F8 00
  79+ 4183 F8 10 20 10          defb $f8,$10,$20,$10,$08,$88,$70,$00 ; char 51: 3
  79+ 4187 08 88 70 00
  80+ 418B 10 30 50 90          defb $10,$30,$50,$90,$f8,$10,$10,$00 ; char 52: 4
  80+ 418F F8 10 10 00
  81+ 4193 F8 80 F0 08          defb $f8,$80,$f0,$08,$08,$88,$70,$00 ; char 53: 5
  81+ 4197 08 88 70 00
  82+ 419B 30 40 80 F0          defb $30,$40,$80,$f0,$88,$88,$70,$00 ; char 54: 6
  82+ 419F 88 88 70 00
  83+ 41A3 F8 08 10 20          defb $f8,$08,$10,$20,$40,$40,$40,$00 ; char 55: 7
  83+ 41A7 40 40 40 00
  84+ 41AB 70 88 88 70          defb $70,$88,$88,$70,$88,$88,$70,$00 ; char 56: 8
  84+ 41AF 88 88 70 00
  85+ 41B3 70 88 88 78          defb $70,$88,$88,$78,$08,$10,$60,$00 ; char 57: 9
  85+ 41B7 08 10 60 00
  86+ 41BB 00 30 30 00          defb $00,$30,$30,$00,$30,$30,$00,$00 ; char 58: :
  86+ 41BF 30 30 00 00
  87+ 41C3 00 30 30 00          defb $00,$30,$30,$00,$30,$10,$20,$00 ; char 59: ;
  87+ 41C7 30 10 20 00
  88+ 41CB 10 20 40 80          defb $10,$20,$40,$80,$40,$20,$10,$00 ; char 60: <
  88+ 41CF 40 20 10 00
  89+ 41D3 00 00 F8 00          defb $00,$00,$f8,$00,$f8,$00,$00,$00 ; char 61: =
  89+ 41D7 F8 00 00 00
  90+ 41DB 40 20 10 08          defb $40,$20,$10,$08,$10,$20,$40,$00 ; char 62: >
  90+ 41DF 10 20 40 00
  91+ 41E3 70 88 08 10          defb $70,$88,$08,$10,$20,$00,$20,$00 ; char 63: ?
  91+ 41E7 20 00 20 00
  92+ 41EB 70 88 08 68          defb $70,$88,$08,$68,$a8,$a8,$70,$00 ; char 64: @
  92+ 41EF A8 A8 70 00
  93+ 41F3 70 88 88 88          defb $70,$88,$88,$88,$f8,$88,$88,$00 ; char 65: A
  93+ 41F7 F8 88 88 00
  94+ 41FB F0 88 88 F0          defb $f0,$88,$88,$f0,$88,$88,$f0,$00 ; char 66: B
  94+ 41FF 88 88 F0 00
  95+ 4203 70 88 80 80          defb $70,$88,$80,$80,$80,$88,$70,$00 ; char 67: C
  95+ 4207 80 88 70 00
  96+ 420B E0 90 88 88          defb $e0,$90,$88,$88,$88,$90,$e0,$00 ; char 68: D
  96+ 420F 88 90 E0 00
  97+ 4213 F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$f8,$00 ; char 69: E
  97+ 4217 80 80 F8 00
  98+ 421B F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$80,$00 ; char 70: F
  98+ 421F 80 80 80 00
  99+ 4223 70 88 80 B8          defb $70,$88,$80,$b8,$88,$88,$78,$00 ; char 71: G
  99+ 4227 88 88 78 00
 100+ 422B 88 88 88 F8          defb $88,$88,$88,$f8,$88,$88,$88,$00 ; char 72: H
 100+ 422F 88 88 88 00
 101+ 4233 70 20 20 20          defb $70,$20,$20,$20,$20,$20,$70,$00 ; char 73: I
 101+ 4237 20 20 70 00
 102+ 423B 38 10 10 10          defb $38,$10,$10,$10,$10,$90,$60,$00 ; char 74: J
 102+ 423F 10 90 60 00
 103+ 4243 88 90 A0 C0          defb $88,$90,$a0,$c0,$a0,$90,$88,$00 ; char 75: K
 103+ 4247 A0 90 88 00
 104+ 424B 80 80 80 80          defb $80,$80,$80,$80,$80,$80,$f8,$00 ; char 76: L
 104+ 424F 80 80 F8 00
 105+ 4253 88 D8 A8 A8          defb $88,$d8,$a8,$a8,$88,$88,$88,$00 ; char 77: M
 105+ 4257 88 88 88 00
 106+ 425B 88 C8 A8 98          defb $88,$c8,$a8,$98,$88,$88,$88,$00 ; char 78: N
 106+ 425F 88 88 88 00
 107+ 4263 70 88 88 88          defb $70,$88,$88,$88,$88,$88,$70,$00 ; char 79: O
 107+ 4267 88 88 70 00
 108+ 426B F0 88 88 F0          defb $f0,$88,$88,$f0,$80,$80,$80,$00 ; char 80: P
 108+ 426F 80 80 80 00
 109+ 4273 70 88 88 88          defb $70,$88,$88,$88,$a8,$90,$68,$00 ; char 81: Q
 109+ 4277 A8 90 68 00
 110+ 427B F0 88 88 F0          defb $f0,$88,$88,$f0,$a0,$90,$88,$00 ; char 82: R
 110+ 427F A0 90 88 00
 111+ 4283 78 80 80 70          defb $78,$80,$80,$70,$08,$08,$f0,$00 ; char 83: S
 111+ 4287 08 08 F0 00
 112+ 428B F8 20 20 20          defb $f8,$20,$20,$20,$20,$20,$20,$00 ; char 84: T
 112+ 428F 20 20 20 00
 113+ 4293 88 88 88 88          defb $88,$88,$88,$88,$88,$88,$70,$00 ; char 85: U
 113+ 4297 88 88 70 00
 114+ 429B 88 88 88 88          defb $88,$88,$88,$88,$88,$50,$20,$00 ; char 86: V
 114+ 429F 88 50 20 00
 115+ 42A3 88 88 88 88          defb $88,$88,$88,$88,$a8,$a8,$50,$00 ; char 87: W
 115+ 42A7 A8 A8 50 00
 116+ 42AB 88 88 50 20          defb $88,$88,$50,$20,$50,$88,$88,$00 ; char 88: X
 116+ 42AF 50 88 88 00
 117+ 42B3 88 88 88 50          defb $88,$88,$88,$50,$20,$20,$20,$00 ; char 89: Y
 117+ 42B7 20 20 20 00
 118+ 42BB F8 08 10 20          defb $f8,$08,$10,$20,$40,$80,$f8,$00 ; char 90: Z
 118+ 42BF 40 80 F8 00
 119+ 42C3 70 40 40 40          defb $70,$40,$40,$40,$40,$40,$70,$00 ; char 91: [
 119+ 42C7 40 40 70 00
 120+ 42CB 00 80 40 20          defb $00,$80,$40,$20,$10,$08,$00,$00 ; char 92: \
 120+ 42CF 10 08 00 00
 121+ 42D3 70 10 10 10          defb $70,$10,$10,$10,$10,$10,$70,$00 ; char 93: ]
 121+ 42D7 10 10 70 00
 122+ 42DB 20 50 88 00          defb $20,$50,$88,$00,$00,$00,$00,$00 ; char 94: ^
 122+ 42DF 00 00 00 00
 123+ 42E3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$FC ; char 95: _ (underscore)
 123+ 42E7 00 00 00 FC
 124+ 42EB 40 20 10 00          defb $40,$20,$10,$00,$00,$00,$00,$00 ; char 96: `
 124+ 42EF 00 00 00 00
 125+ 42F3 00 00 70 08          defb $00,$00,$70,$08,$78,$88,$78,$00 ; char 97: a
 125+ 42F7 78 88 78 00
 126+ 42FB 80 80 80 B0          defb $80,$80,$80,$b0,$c8,$88,$f0,$00 ; char 98: b
 126+ 42FF C8 88 F0 00
 127+ 4303 00 00 70 80          defb $00,$00,$70,$80,$80,$88,$70,$00 ; char 99: c
 127+ 4307 80 88 70 00
 128+ 430B 08 08 08 68          defb $08,$08,$08,$68,$98,$88,$78,$00 ; char 100: d
 128+ 430F 98 88 78 00
 129+ 4313 00 00 70 88          defb $00,$00,$70,$88,$f8,$80,$70,$00 ; char 101: e
 129+ 4317 F8 80 70 00
 130+ 431B 30 48 40 E0          defb $30,$48,$40,$e0,$40,$40,$40,$00 ; char 102: f
 130+ 431F 40 40 40 00
 131+ 4323 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$70,$00 ; char 103: g
 131+ 4327 78 08 70 00
 132+ 432B 80 80 B0 C8          defb $80,$80,$b0,$c8,$88,$88,$88,$00 ; char 104: h
 132+ 432F 88 88 88 00
 133+ 4333 20 00 20 20          defb $20,$00,$20,$20,$20,$20,$20,$00 ; char 105: i
 133+ 4337 20 20 20 00
 134+ 433B 08 00 18 08          defb $08,$00,$18,$08,$08,$88,$70,$00 ; char 106: j
 134+ 433F 08 88 70 00
 135+ 4343 80 80 90 A0          defb $80,$80,$90,$a0,$c0,$a0,$90,$00 ; char 107: k
 135+ 4347 C0 A0 90 00
 136+ 434B 60 20 20 20          defb $60,$20,$20,$20,$20,$20,$70,$00 ; char 108: l
 136+ 434F 20 20 70 00
 137+ 4353 00 00 D0 A8          defb $00,$00,$d0,$a8,$a8,$88,$88,$00 ; char 109: m
 137+ 4357 A8 88 88 00
 138+ 435B 00 00 B0 C8          defb $00,$00,$b0,$c8,$88,$88,$88,$00 ; char 110: n
 138+ 435F 88 88 88 00
 139+ 4363 00 00 70 88          defb $00,$00,$70,$88,$88,$88,$70,$00 ; char 111: o
 139+ 4367 88 88 70 00
 140+ 436B 00 00 F0 88          defb $00,$00,$f0,$88,$f0,$80,$80,$00 ; char 112: p
 140+ 436F F0 80 80 00
 141+ 4373 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$08,$00 ; char 113: q
 141+ 4377 78 08 08 00
 142+ 437B 00 00 B0 C8          defb $00,$00,$b0,$c8,$80,$80,$80,$00 ; char 114: r
 142+ 437F 80 80 80 00
 143+ 4383 00 00 70 80          defb $00,$00,$70,$80,$70,$08,$f0,$00 ; char 115: s
 143+ 4387 70 08 F0 00
 144+ 438B 40 40 E0 40          defb $40,$40,$e0,$40,$40,$48,$30,$00 ; char 116: t
 144+ 438F 40 48 30 00
 145+ 4393 00 00 88 88          defb $00,$00,$88,$88,$88,$98,$68,$00 ; char 117: u
 145+ 4397 88 98 68 00
 146+ 439B 00 00 88 88          defb $00,$00,$88,$88,$88,$50,$20,$00 ; char 118: v
 146+ 439F 88 50 20 00
 147+ 43A3 00 00 88 88          defb $00,$00,$88,$88,$a8,$a8,$50,$00 ; char 119: w
 147+ 43A7 A8 A8 50 00
 148+ 43AB 00 00 88 50          defb $00,$00,$88,$50,$20,$50,$88,$00 ; char 120: x
 148+ 43AF 20 50 88 00
 149+ 43B3 00 00 88 98          defb $00,$00,$88,$98,$68,$08,$70,$00 ; char 121: y
 149+ 43B7 68 08 70 00
 150+ 43BB 00 00 F8 10          defb $00,$00,$f8,$10,$20,$40,$f8,$00 ; char 122: z
 150+ 43BF 20 40 F8 00
 151+ 43C3 10 20 20 40          defb $10,$20,$20,$40,$20,$20,$10,$00 ; char 123: {
 151+ 43C7 20 20 10 00
 152+ 43CB 20 20 20 20          defb $20,$20,$20,$20,$20,$20,$20,$00 ; char 124: |
 152+ 43CF 20 20 20 00
 153+ 43D3 20 10 10 08          defb $20,$10,$10,$08,$10,$10,$20,$00 ; char 125: }
 153+ 43D7 10 10 20 00
 154+ 43DB 00 28 50 00          defb $00,$28,$50,$00,$00,$00,$00,$00 ; char 126: ~
 154+ 43DF 00 00 00 00
 155+ 43E3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 127: (delete) - here end the standard ASCII (0-127)
 155+ 43E7 00 00 00 00
 156+ 43EB 78 84 CC 84          defb %01111000,%10000100,%11001100,%10000100,%10110100,%10000100,%01111000,%00000000 ; char 128 (open face)
 156+ 43EF B4 84 78 00
 157+ 43F3 78 FC B4 FC          defb %01111000,%11111100,%10110100,%11111100,%10110100,%11001100,%01111000,%00000000 ; char 129 (full face)
 157+ 43F7 B4 CC 78 00
 158+ 43FB 48 FC FC FC          defb %01001000,%11111100,%11111100,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 130 (hearts)
 158+ 43FF FC 78 30 00
 159+ 4403 00 20 70 F8          defb %00000000,%00100000,%01110000,%11111000,%11111000,%01110000,%00100000,%00000000 ; char 131 (diamonds)
 159+ 4407 F8 70 20 00
 160+ 440B 70 20 A8 F8          defb %01110000,%00100000,%10101000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 132 (clubs)
 160+ 440F A8 20 70 00
 161+ 4413 20 70 F8 F8          defb %00100000,%01110000,%11111000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 133 (spades)
 161+ 4417 A8 20 70 00
 162+ 441B 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 134
 162+ 441F FC 30 30 30
 163+ 4423 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 135
 163+ 4427 3C 30 30 30
 164+ 442B 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 136
 164+ 442F F0 30 30 30
 165+ 4433 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00000000,%00000000,%00000000 ; char 137
 165+ 4437 F0 00 00 00
 166+ 443B 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00000000,%00000000,%00000000 ; char 138
 166+ 443F 3C 00 00 00
 167+ 4443 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 139
 167+ 4447 FC 00 00 00
 168+ 444B 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 140
 168+ 444F 3C 30 30 30
 169+ 4453 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 141
 169+ 4457 FC 30 30 30
 170+ 445B 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 142
 170+ 445F F0 30 30 30
 171+ 4463 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 143
 171+ 4467 FC 00 00 00
 172+ 446B 30 30 30 30          defb %00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000 ; char 144
 172+ 446F 30 30 30 30
 173+ 4473 0C 1C 18 38          defb %00001100,%00011100,%00011000,%00111000,%01110000,%01100000,%11100000,%11000000 ; char 145
 173+ 4477 70 60 E0 C0
 174+ 447B C0 E0 60 70          defb %11000000,%11100000,%01100000,%01110000,%00111000,%00011000,%00011100,%00001100 ; char 146
 174+ 447F 38 18 1C 0C
 175+ 4483 CC CC 78 30          defb %11001100,%11001100,%01111000,%00110000,%00110000,%01111000,%11001100,%11001100 ; char 147
 175+ 4487 30 78 CC CC
 176+ 448B 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 148
 176+ 448F 20 20 20 20
 177+ 4493 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 149
 177+ 4497 20 20 20 20
 178+ 449B 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 150
 178+ 449F 20 20 20 20
 179+ 44A3 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 151
 179+ 44A7 00 00 00 00
 180+ 44AB 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00000000,%00000000,%00000000,%00000000 ; char 152
 180+ 44AF 00 00 00 00
 181+ 44B3 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 153
 181+ 44B7 00 00 00 00
 182+ 44BB 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 154
 182+ 44BF 20 20 20 20
 183+ 44C3 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 155
 183+ 44C7 20 20 20 20
 184+ 44CB 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 156
 184+ 44CF 20 20 20 20
 185+ 44D3 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 157
 185+ 44D7 00 00 00 00
 186+ 44DB 20 20 20 20          defb %00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000 ; char 158
 186+ 44DF 20 20 20 20
 187+ 44E3 04 08 08 10          defb %00000100,%00001000,%00001000,%00010000,%00100000,%01000000,%01000000,%10000000 ; char 159
 187+ 44E7 20 40 40 80
 188+ 44EB 80 40 40 20          defb %10000000,%01000000,%01000000,%00100000,%00010000,%00001000,%00001000,%00000100 ; char 160
 188+ 44EF 10 08 08 04
 189+ 44F3 84 48 48 30          defb %10000100,%01001000,%01001000,%00110000,%00110000,%01001000,%01001000,%10000100 ; char 161
 189+ 44F7 30 48 48 84
 190+ 44FB 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 162
 190+ 44FF 00 00 FC FC
 191+ 4503 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111100,%11111100,%11111100,%11111100 ; char 163
 191+ 4507 FC FC FC FC
 192+ 450B 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 164
 192+ 450F FC FC FC FC
 193+ 4513 FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 193+ 4517 00 00 00 00
 194+ 451B FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 166
 194+ 451F 00 00 00 00
 195+ 4523 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 167
 195+ 4527 FC FC 00 00
 196+ 452B 80 80 80 80          defb %10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000 ; char 168
 196+ 452F 80 80 80 80
 197+ 4533 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000 ; char 169
 197+ 4537 E0 E0 E0 E0
 198+ 453B F8 F8 F8 F8          defb %11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000 ; char 170
 198+ 453F F8 F8 F8 F8
 199+ 4543 04 04 04 04          defb %00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100 ; char 171
 199+ 4547 04 04 04 04
 200+ 454B 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100 ; char 172
 200+ 454F 1C 1C 1C 1C
 201+ 4553 7C 7C 7C 7C          defb %01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100 ; char 173
 201+ 4557 7C 7C 7C 7C
 202+ 455B FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 174
 202+ 455F 84 84 84 FC
 203+ 4563 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%11100000,%11100000,%11100000 ; char 175
 203+ 4567 E0 E0 E0 E0
 204+ 456B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00011100,%00011100,%00011100 ; char 176
 204+ 456F 1C 1C 1C 1C
 205+ 4573 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 177
 205+ 4577 00 00 00 00
 206+ 457B E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 178
 206+ 457F 00 00 00 00
 207+ 4583 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00011100,%00011100,%00011100,%00011100 ; char 179
 207+ 4587 1C 1C 1C 1C
 208+ 458B 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%11100000,%11100000,%11100000,%11100000 ; char 180
 208+ 458F E0 E0 E0 E0
 209+ 4593 78 78 78 78          defb %01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000 ; char 181
 209+ 4597 78 78 78 78
 210+ 459B CC CC CC CC          defb %11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100 ; char 182
 210+ 459F CC CC CC CC
 211+ 45A3 FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 183
 211+ 45A7 00 00 FC FC
 212+ 45AB 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 184
 212+ 45AF FC FC 00 00
 213+ 45B3 30 30 CC CC          defb %00110000,%00110000,%11001100,%11001100,%00110000,%00110000,%11001100,%11001100 ; char 185
 213+ 45B7 30 30 CC CC
 214+ 45BB 54 A8 54 A8          defb %01010100,%10101000,%01010100,%10101000,%01010100,%10101000,%01010100,%10101000 ; char 186
 214+ 45BF 54 A8 54 A8
 215+ 45C3 64 30 98 CC          defb %01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100 ; char 187
 215+ 45C7 64 30 98 CC
 216+ 45CB CC 64 30 98          defb %11001100,%01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000 ; char 188
 216+ 45CF CC 64 30 98
 217+ 45D3 30 98 CC 64          defb %00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100,%01100100 ; char 189
 217+ 45D7 30 98 CC 64
 218+ 45DB 64 CC 98 30          defb %01100100,%11001100,%10011000,%00110000,%01100100,%11001100,%10011000,%00110000 ; char 190
 218+ 45DF 64 CC 98 30
 219+ 45E3 20 20 F8 20          defb %00100000,%00100000,%11111000,%00100000,%00100000,%00000000,%11111000,%00000000 ; char 191 (Â±)
 219+ 45E7 20 00 F8 00
 220+ 45EB C0 30 08 30          defb %11000000,%00110000,%00001000,%00110000,%11000000,%00000000,%11111000,%00000000 ; char 192 (â¥)
 220+ 45EF C0 00 F8 00
 221+ 45F3 18 60 80 60          defb %00011000,%01100000,%10000000,%01100000,%00011000,%00000000,%11111000,%00000000 ; char 193 (â¤)
 221+ 45F7 18 00 F8 00
 222+ 45FB 3C 20 20 20          defb %00111100,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 222+ 45FF A0 60 20 00
 223+ 4603 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 223+ 4607 00 00 00 00
 224+ 460B 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 224+ 460F 70 00 00 00
 225+ 4613 00 00 54 A8          defb %00000000,%00000000,%01010100,%10101000,%00000000,%11111100,%00000000,%00000000 ; char 197
 225+ 4617 00 FC 00 00
 226+ 461B 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 226+ 461F 54 A8 00 00
 227+ 4623 00 80 C0 E0          defb %00000000,%10000000,%11000000,%11100000,%11100000,%11000000,%10000000,%00000000 ; char 199
 227+ 4627 E0 C0 80 00
 228+ 462B FC 78 30 00          defb %11111100,%01111000,%00110000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 200
 228+ 462F 00 00 00 00
 229+ 4633 00 04 0C 1C          defb %00000000,%00000100,%00001100,%00011100,%00011100,%00001100,%00000100,%00000000 ; char 201
 229+ 4637 1C 0C 04 00
 230+ 463B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00110000,%01111000,%11111100 ; char 202
 230+ 463F 00 30 78 FC
 231+ 4643 20 70 F8 20          defb %00100000,%01110000,%11111000,%00100000,%00100000,%00100000,%00100000,%00000000 ; char 203 (up arrow)
 231+ 4647 20 20 20 00
 232+ 464B 3C 1C 1C 24          defb %00111100,%00011100,%00011100,%00100100,%01000000,%10000000,%00000000,%00000000 ; char 204 (up right arrow)
 232+ 464F 40 80 00 00
 233+ 4653 00 10 18 FC          defb %00000000,%00010000,%00011000,%11111100,%00011000,%00010000,%00000000,%00000000 ; char 205 (right arrow)
 233+ 4657 18 10 00 00
 234+ 465B 00 00 80 40          defb %00000000,%00000000,%10000000,%01000000,%00100100,%00011100,%00011100,%00111100 ; char 206 (down right arrow)
 234+ 465F 24 1C 1C 3C
 235+ 4663 00 20 20 20          defb %00000000,%00100000,%00100000,%00100000,%00100000,%11111000,%01110000,%00100000 ; char 207 (down arrow)
 235+ 4667 20 F8 70 20
 236+ 466B 00 00 04 08          defb %00000000,%00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000 ; char 208 (down left arrow)
 236+ 466F 90 E0 E0 F0
 237+ 4673 00 20 60 FC          defb %00000000,%00100000,%01100000,%11111100,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 237+ 4677 60 20 00 00
 238+ 467B F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 238+ 467F 08 04 00 00
 239+ 4683 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 239+ 4687 F0 44 38 00
 240+ 468B 00 04 78 A8          defb %00000000,%00000100,%01111000,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 240+ 468F 28 28 28 00
 241+ 4693 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00100000,%00100000,%00100000 ; char 213
 241+ 4697 1C 20 20 20
 242+ 469B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%00010000,%00010000,%00010000 ; char 214
 242+ 469F E0 10 10 10
 243+ 46A3 10 10 10 E0          defb %00010000,%00010000,%00010000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 215
 243+ 46A7 00 00 00 00
 244+ 46AB 20 20 20 1C          defb %00100000,%00100000,%00100000,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 216
 244+ 46AF 00 00 00 00
 245+ 46B3 00 00 00 1C          defb %00000000,%00000000,%00000000,%00011100,%00111100,%00110000,%00110000,%00110000 ; char 217
 245+ 46B7 3C 30 30 30
 246+ 46BB 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00110000,%00110000,%00110000 ; char 218
 246+ 46BF F0 30 30 30
 247+ 46C3 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 247+ 46C7 E0 00 00 00
 248+ 46CB 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00011100,%00000000,%00000000,%00000000 ; char 220
 248+ 46CF 1C 00 00 00
 249+ 46D3 00 30 48 48          defb %00000000,%00110000,%01001000,%01001000,%01001000,%00110000,%00000000,%00000000 ; char 221
 249+ 46D7 48 30 00 00
 250+ 46DB 00 30 78 78          defb %00000000,%00110000,%01111000,%01111000,%01111000,%00110000,%00000000,%00000000 ; char 222
 250+ 46DF 78 30 00 00
 251+ 46E3 00 30 78 FC          defb %00000000,%00110000,%01111000,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 223
 251+ 46E7 FC 78 30 00
 252+ 46EB FC F8 F0 E0          defb %11111100,%11111000,%11110000,%11100000,%11100000,%11000000,%10000000,%10000000 ; char 224
 252+ 46EF E0 C0 80 80
 253+ 46F3 FC 7C 3C 1C          defb %11111100,%01111100,%00111100,%00011100,%00011100,%00001100,%00000100,%00000100 ; char 225
 253+ 46F7 1C 0C 04 04
 254+ 46FB 04 04 0C 1C          defb %00000100,%00000100,%00001100,%00011100,%00011100,%00111100,%01111100,%11111100 ; char 226
 254+ 46FF 1C 3C 7C FC
 255+ 4703 80 80 C0 E0          defb %10000000,%10000000,%11000000,%11100000,%11100000,%11110000,%11111000,%11111100 ; char 227
 255+ 4707 E0 F0 F8 FC
 256+ 470B 00 04 0C D8          defb %00000000,%00000100,%00001100,%11011000,%11110000,%11100000,%11000000,%00000000 ; char 228 (checkmark)
 256+ 470F F0 E0 C0 00
 257+ 4713 00 CC 78 30          defb %00000000,%11001100,%01111000,%00110000,%01111000,%11001100,%00000000,%00000000 ; char 229 (x)
 257+ 4717 78 CC 00 00
 258+ 471B 70 88 88 88          defb %01110000,%10001000,%10001000,%10001000,%01110000,%00100000,%01110000,%00100000 ; char 230 (female)
 258+ 471F 70 20 70 20
 259+ 4723 00 1C 0C 74          defb %00000000,%00011100,%00001100,%01110100,%10010000,%10010000,%01100000,%00000000 ; char 231 (male)
 259+ 4727 90 90 60 00
 260+ 472B F8 84 84 84          defb %11111000,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 232 (new doc)
 260+ 472F 84 84 84 FC
 261+ 4733 00 F0 FC 84          defb %00000000,%11110000,%11111100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 233 (folder)
 261+ 4737 84 84 84 FC
 262+ 473B 30 78 FC 48          defb %00110000,%01111000,%11111100,%01001000,%01001000,%01001000,%01001000,%01111000 ; char 234 (trash bin)
 262+ 473F 48 48 48 78
 263+ 4743 FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%11111100,%10110100,%10110100,%11111100 ; char 235 (floppy disk)
 263+ 4747 FC B4 B4 FC
 264+ 474B 00 00 D4 D8          defb %00000000,%00000000,%11010100,%11011000,%11010100,%11010100,%00000000,%00000000 ; char 236 (OK)
 264+ 474F D4 D4 00 00
 265+ 4753 30 78 FC 78          defb %00110000,%01111000,%11111100,%01111000,%01111000,%01001000,%01001000,%01001000 ; char 237 (home)
 265+ 4757 78 48 48 48
 266+ 475B 78 84 A4 A4          defb %01111000,%10000100,%10100100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 238 (clock)
 266+ 475F B4 84 78 00
 267+ 4763 00 00 08 F4          defb %00000000,%00000000,%00001000,%11110100,%10101000,%10000000,%00000000,%00000000 ; char 239 (key)
 267+ 4767 A8 80 00 00
 268+ 476B 20 30 78 B0          defb %00100000,%00110000,%01111000,%10110000,%10100000,%10001000,%01110000,%00000000 ; char 240 (undo)
 268+ 476F A0 88 70 00
 269+ 4773 00 FC CC B4          defb %00000000,%11111100,%11001100,%10110100,%10000100,%10000100,%11111100,%00000000 ; char 241 (letter)
 269+ 4777 84 84 FC 00
 270+ 477B 60 90 90 F0          defb %01100000,%10010000,%10010000,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 242 (lock)
 270+ 477F F0 F0 F0 00
 271+ 4783 08 14 14 F0          defb %00001000,%00010100,%00010100,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 243 (unlock)
 271+ 4787 F0 F0 F0 00
 272+ 478B FC FC 84 B4          defb %11111100,%11111100,%10000100,%10110100,%10010100,%10010100,%10000100,%11111100 ; char 244 (calendar)
 272+ 478F 94 94 84 FC
 273+ 4793 00 04 38 58          defb %00000000,%00000100,%00111000,%01011000,%01101000,%01110000,%10000000,%00000000 ; char 245 (diameter)
 273+ 4797 68 70 80 00
 274+ 479B 78 84 84 84          defb %01111000,%10000100,%10000100,%10000100,%01101100,%00011000,%00001000,%00000000 ; char 246 (baloon)
 274+ 479F 6C 18 08 00
 275+ 47A3 30 28 28 28          defb %00110000,%00101000,%00101000,%00101000,%00100000,%01100000,%11100000,%01000000 ; char 247 (note)
 275+ 47A7 20 60 E0 40
 276+ 47AB 20 68 E4 E4          defb %00100000,%01101000,%11100100,%11100100,%11100100,%01101000,%00100000,%00000000 ; char 248 (audio on)
 276+ 47AF E4 68 20 00
 277+ 47B3 20 60 E0 E0          defb %00100000,%01100000,%11100000,%11100000,%11100000,%01100000,%00100000,%00000000 ; char 249 (audio off)
 277+ 47B7 E0 60 20 00
 278+ 47BB 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11110000,%10010000 ; char 250 (pointer)
 278+ 47BF F8 FC F0 90
 279+ 47C3 78 84 B4 A4          defb %01111000,%10000100,%10110100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 251 (Â©)
 279+ 47C7 B4 84 78 00
 280+ 47CB 30 48 40 E0          defb %00110000,%01001000,%01000000,%11100000,%01000000,%01001000,%10110000,%00000000 ; char 252 (Â£)
 280+ 47CF 40 48 B0 00
 281+ 47D3 78 84 F0 48          defb %01111000,%10000100,%11110000,%01001000,%01001000,%00111100,%10000100,%01111000 ; char 253 (Â§)
 281+ 47D7 48 3C 84 78
 282+ 47DB 00 00 20 00          defb %00000000,%00000000,%00100000,%00000000,%11111000,%00000000,%00100000,%00000000 ; char 254 (Ã·)
 282+ 47DF F8 00 20 00
 283+ 47E3 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 255 (cursor)
 283+ 47E7 FC FC FC FC
 284+ 47EB                      ; here ends the ASCII table
 285+ 47EB
# file closed: ../include/vdp/6x8fonts-r16.asm
  85  47EB                  INCLUDE "../include/vdp/8x8fonts-r18.asm"
# file opened: ../include/vdp/8x8fonts-r18.asm
   1+ 47EB              ; ------------------------------------------------------------------------------
   2+ 47EB              ; LM80C - 8x8 CHARSET - R1.8
   3+ 47EB              ; ------------------------------------------------------------------------------
   4+ 47EB              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 47EB              ; designed by Leonardo Miliani. More info at
   6+ 47EB              ; www DOT leonardomiliani DOT com
   7+ 47EB              ; ------------------------------------------------------------------------------
   8+ 47EB              ; Code Revision:
   9+ 47EB              ; R1.0 - 20190615 - First revision: ASCII chars (from 0 to 255) - actually, they are 6x8 pixels
  10+ 47EB              ; R1.1 - 20190616 - Converted to 8x8 pixels
  11+ 47EB              ; R1.2 - 20191013 - Added new graphic chars and reorganized previous ones
  12+ 47EB              ; R1.3 - 20191015 - More graphic chars
  13+ 47EB              ; R1.4 - 20191202 - Fixed char 11/12, added new special chars
  14+ 47EB              ; R1.5 - 20191210 - Changed several graphic chars
  15+ 47EB              ; R1.6 - 20200125 - Removed double chars, changed with new ones
  16+ 47EB              ; R1.7 - 20200228 - adopted more usual hexadecimal & binary prefixes
  17+ 47EB              ; R1.8 - 20200524 - New style for char #252
  18+ 47EB              ; ------------------------------------------------------------------------------
  19+ 47EB              ;
  20+ 47EB              ;-------------------------------------------------------------------------------
  21+ 47EB              ;
  22+ 47EB              ;               8 x 8    C  H  A  R  S  E  T
  23+ 47EB              ;
  24+ 47EB              ;-------------------------------------------------------------------------------
  25+ 47EB              ;
  26+ 47EB              ;       8X8 CHARS, DESIGNED FOR GRAPHICS 1 MODE
  27+ 47EB
  28+ 47EB              CHRST88 equ $
  29+ 47EB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  29+ 47EF 00 00 00 00
  30+ 47F3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  30+ 47F7 00 00 00 00
  31+ 47FB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  31+ 47FF 00 00 00 00
  32+ 4803 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  32+ 4807 00 00 00 00
  33+ 480B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  33+ 480F 00 00 00 00
  34+ 4813 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  34+ 4817 00 00 00 00
  35+ 481B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  35+ 481F 00 00 00 00
  36+ 4823 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  36+ 4827 00 00 00 00
  37+ 482B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 DEL key (backspace)
  37+ 482F 00 00 00 00
  38+ 4833 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  38+ 4837 00 00 00 00
  39+ 483B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  39+ 483F 00 00 00 00
  40+ 4843 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 (unused)
  40+ 4847 00 00 00 00
  41+ 484B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  41+ 484F 00 00 00 00
  42+ 4853 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 RETURN key (carriage return)
  42+ 4857 00 00 00 00
  43+ 485B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL key
  43+ 485F 00 00 00 00
  44+ 4863 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  44+ 4867 00 00 00 00
  45+ 486B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  45+ 486F 00 00 00 00
  46+ 4873 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  46+ 4877 00 00 00 00
  47+ 487B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  47+ 487F 00 00 00 00
  48+ 4883 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  48+ 4887 00 00 00 00
  49+ 488B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT key
  49+ 488F 00 00 00 00
  50+ 4893 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  50+ 4897 00 00 00 00
  51+ 489B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6 key
  51+ 489F 00 00 00 00
  52+ 48A3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7 key
  52+ 48A7 00 00 00 00
  53+ 48AB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP key
  53+ 48AF 00 00 00 00
  54+ 48B3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 HOME key
  54+ 48B7 00 00 00 00
  55+ 48BB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26 INSERT key
  55+ 48BF 00 00 00 00
  56+ 48C3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 ESCAPE key
  56+ 48C7 00 00 00 00
  57+ 48CB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 CRSR LEFT key (cursor left)
  57+ 48CF 00 00 00 00
  58+ 48D3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 CRSR RIGHT key (cursor right)
  58+ 48D7 00 00 00 00
  59+ 48DB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 CRSR UP key (cursor up)
  59+ 48DF 00 00 00 00
  60+ 48E3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 CRSR DOWN key (cursor down)
  60+ 48E7 00 00 00 00
  61+ 48EB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32 SPACE key
  61+ 48EF 00 00 00 00
  62+ 48F3 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00000000,%00010000,%00000000 ; char 33 - !
  62+ 48F7 10 00 10 00
  63+ 48FB 28 28 28 00          defb %00101000,%00101000,%00101000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 34 - "
  63+ 48FF 00 00 00 00
  64+ 4903 28 28 FE 28          defb %00101000,%00101000,%11111110,%00101000,%11111110,%00101000,%00101000,%00000000 ; char 35 - #
  64+ 4907 FE 28 28 00
  65+ 490B 10 3C 50 38          defb %00010000,%00111100,%01010000,%00111000,%00010100,%01111000,%00010000,%00000000 ; char 36 - $
  65+ 490F 14 78 10 00
  66+ 4913 00 62 64 08          defb %00000000,%01100010,%01100100,%00001000,%00010000,%00100110,%01000110,%00000000 ; char 37 - %
  66+ 4917 10 26 46 00
  67+ 491B 00 30 48 30          defb %00000000,%00110000,%01001000,%00110000,%01001010,%01000100,%00111010,%00000000 ; char 38 - &
  67+ 491F 4A 44 3A 00
  68+ 4923 08 10 20 00          defb %00001000,%00010000,%00100000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 39 - '
  68+ 4927 00 00 00 00
  69+ 492B 08 10 20 20          defb %00001000,%00010000,%00100000,%00100000,%00100000,%00010000,%00001000,%00000000 ; char 40 - (
  69+ 492F 20 10 08 00
  70+ 4933 20 10 08 08          defb %00100000,%00010000,%00001000,%00001000,%00001000,%00010000,%00100000,%00000000 ; char 41 - )
  70+ 4937 08 10 20 00
  71+ 493B 00 10 54 38          defb %00000000,%00010000,%01010100,%00111000,%00111000,%01010100,%00010000,%00000000 ; char 42 - *
  71+ 493F 38 54 10 00
  72+ 4943 00 10 10 7C          defb %00000000,%00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%00000000 ; char 43 - +
  72+ 4947 10 10 00 00
  73+ 494B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00001000,%00010000 ; char 44 - ,
  73+ 494F 00 18 08 10
  74+ 4953 00 00 00 7C          defb %00000000,%00000000,%00000000,%01111100,%00000000,%00000000,%00000000,%00000000 ; char 45 - -
  74+ 4957 00 00 00 00
  75+ 495B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00011000,%00000000 ; char 46 - .
  75+ 495F 00 18 18 00
  76+ 4963 00 02 04 08          defb %00000000,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%00000000 ; char 47 - /
  76+ 4967 10 20 40 00
  77+ 496B 38 44 4C 54          defb %00111000,%01000100,%01001100,%01010100,%01100100,%01000100,%00111000,%00000000 ; char 48 - 0
  77+ 496F 64 44 38 00
  78+ 4973 10 30 50 10          defb %00010000,%00110000,%01010000,%00010000,%00010000,%00010000,%01111100,%00000000 ; char 49 - 1
  78+ 4977 10 10 7C 00
  79+ 497B 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 50 - 2
  79+ 497F 10 20 7C 00
  80+ 4983 7C 08 10 08          defb %01111100,%00001000,%00010000,%00001000,%00000100,%01000100,%00111000,%00000000 ; char 51 - 3
  80+ 4987 04 44 38 00
  81+ 498B 08 18 28 48          defb %00001000,%00011000,%00101000,%01001000,%01111100,%00001000,%00001000,%00000000 ; char 52 - 4
  81+ 498F 7C 08 08 00
  82+ 4993 7C 40 78 04          defb %01111100,%01000000,%01111000,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 53 - 5
  82+ 4997 04 44 38 00
  83+ 499B 38 44 40 78          defb %00111000,%01000100,%01000000,%01111000,%01000100,%01000100,%00111000,%00000000 ; char 54 - 6
  83+ 499F 44 44 38 00
  84+ 49A3 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%00100000,%00100000,%00000000 ; char 55 - 7
  84+ 49A7 20 20 20 00
  85+ 49AB 38 44 44 38          defb %00111000,%01000100,%01000100,%00111000,%01000100,%01000100,%00111000,%00000000 ; char 56 - 8
  85+ 49AF 44 44 38 00
  86+ 49B3 38 44 44 3C          defb %00111000,%01000100,%01000100,%00111100,%00000100,%01000100,%00111000,%00000000 ; char 57 - 9
  86+ 49B7 04 44 38 00
  87+ 49BB 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00011000,%00000000,%00000000 ; char 58 - :
  87+ 49BF 18 18 00 00
  88+ 49C3 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00001000,%00010000,%00000000 ; char 59 - ;
  88+ 49C7 18 08 10 00
  89+ 49CB 04 08 10 20          defb %00000100,%00001000,%00010000,%00100000,%00010000,%00001000,%00000100,%00000000 ; char 60 - <
  89+ 49CF 10 08 04 00
  90+ 49D3 00 00 7E 00          defb %00000000,%00000000,%01111110,%00000000,%01111110,%00000000,%00000000,%00000000 ; char 61 - =
  90+ 49D7 7E 00 00 00
  91+ 49DB 20 10 08 04          defb %00100000,%00010000,%00001000,%00000100,%00001000,%00010000,%00100000,%00000000 ; char 62 - >
  91+ 49DF 08 10 20 00
  92+ 49E3 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00000000,%00010000,%00000000 ; char 63 - ?
  92+ 49E7 10 00 10 00
  93+ 49EB 78 84 BC AC          defb %01111000,%10000100,%10111100,%10101100,%10111000,%10000000,%10000100,%01111000 ; char 64 - @
  93+ 49EF B8 80 84 78
  94+ 49F3 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%00000000 ; char 65 - A
  94+ 49F7 7C 44 44 00
  95+ 49FB 78 44 44 78          defb %01111000,%01000100,%01000100,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 66 - B
  95+ 49FF 44 44 78 00
  96+ 4A03 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 67 - C
  96+ 4A07 40 44 38 00
  97+ 4A0B 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01000100,%01000100,%01111000,%00000000 ; char 68 - D
  97+ 4A0F 44 44 78 00
  98+ 4A13 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01111100,%00000000 ; char 69 - E
  98+ 4A17 40 40 7C 00
  99+ 4A1B 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01000000,%00000000 ; char 70 - F
  99+ 4A1F 40 40 40 00
 100+ 4A23 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01011100,%01000100,%00111000,%00000000 ; char 71 - G
 100+ 4A27 5C 44 38 00
 101+ 4A2B 44 44 44 7C          defb %01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%01000100,%00000000 ; char 72 - H
 101+ 4A2F 44 44 44 00
 102+ 4A33 38 10 10 10          defb %00111000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 73 - I
 102+ 4A37 10 10 38 00
 103+ 4A3B 3C 04 04 04          defb %00111100,%00000100,%00000100,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 74 - J
 103+ 4A3F 04 44 38 00
 104+ 4A43 44 44 48 70          defb %01000100,%01000100,%01001000,%01110000,%01001000,%01000100,%01000100,%00000000 ; char 75 - K
 104+ 4A47 48 44 44 00
 105+ 4A4B 40 40 40 40          defb %01000000,%01000000,%01000000,%01000000,%01000000,%01000000,%01111100,%00000000 ; char 76 - L
 105+ 4A4F 40 40 7C 00
 106+ 4A53 42 66 5A 42          defb %01000010,%01100110,%01011010,%01000010,%01000010,%01000010,%01000010,%00000000 ; char 77 - M
 106+ 4A57 42 42 42 00
 107+ 4A5B 44 64 54 4C          defb %01000100,%01100100,%01010100,%01001100,%01000100,%01000100,%01000100,%00000000 ; char 78 - N
 107+ 4A5F 44 44 44 00
 108+ 4A63 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 79 - O
 108+ 4A67 44 44 38 00
 109+ 4A6B 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01000000,%01000000,%00000000 ; char 80 - P
 109+ 4A6F 78 40 40 00
 110+ 4A73 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01010100,%01001000,%00110100,%00000000 ; char 81 - Q
 110+ 4A77 54 48 34 00
 111+ 4A7B 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01001000,%01000100,%00000000 ; char 82 - R
 111+ 4A7F 78 48 44 00
 112+ 4A83 3C 40 40 38          defb %00111100,%01000000,%01000000,%00111000,%00000100,%00000100,%01111000,%00000000 ; char 83 - S
 112+ 4A87 04 04 78 00
 113+ 4A8B 7C 10 10 10          defb %01111100,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 84 - T
 113+ 4A8F 10 10 10 00
 114+ 4A93 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 85 - U
 114+ 4A97 44 44 38 00
 115+ 4A9B 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 86 - V
 115+ 4A9F 44 28 10 00
 116+ 4AA3 42 42 42 42          defb %01000010,%01000010,%01000010,%01000010,%01011010,%01011010,%00100100,%00000000 ; char 87 - W
 116+ 4AA7 5A 5A 24 00
 117+ 4AAB 44 44 28 10          defb %01000100,%01000100,%00101000,%00010000,%00101000,%01000100,%01000100,%00000000 ; char 88 - X
 117+ 4AAF 28 44 44 00
 118+ 4AB3 44 44 44 28          defb %01000100,%01000100,%01000100,%00101000,%00010000,%00010000,%00010000,%00000000 ; char 89 - Y
 118+ 4AB7 10 10 10 00
 119+ 4ABB 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%01000000,%01111100,%00000000 ; char 90 - Z
 119+ 4ABF 20 40 7C 00
 120+ 4AC3 38 20 20 20          defb %00111000,%00100000,%00100000,%00100000,%00100000,%00100000,%00111000,%00000000 ; char 91 - [
 120+ 4AC7 20 20 38 00
 121+ 4ACB 00 40 20 10          defb %00000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000000 ; char 92 - \
 121+ 4ACF 08 04 02 00
 122+ 4AD3 38 08 08 08          defb %00111000,%00001000,%00001000,%00001000,%00001000,%00001000,%00111000,%00000000 ; char 93 - ]
 122+ 4AD7 08 08 38 00
 123+ 4ADB 10 28 44 00          defb %00010000,%00101000,%01000100,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 94 - ^
 123+ 4ADF 00 00 00 00
 124+ 4AE3 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%01111110,%00000000 ; char 95 _ (underscore)
 124+ 4AE7 00 00 7E 00
 125+ 4AEB 20 10 08 00          defb %00100000,%00010000,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 96 - `
 125+ 4AEF 00 00 00 00
 126+ 4AF3 00 00 38 04          defb %00000000,%00000000,%00111000,%00000100,%00111100,%01000100,%00111100,%00000000 ; char 97 - a
 126+ 4AF7 3C 44 3C 00
 127+ 4AFB 40 40 40 78          defb %01000000,%01000000,%01000000,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 98 - b
 127+ 4AFF 44 44 78 00
 128+ 4B03 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 99 - c
 128+ 4B07 40 44 38 00
 129+ 4B0B 04 04 04 3C          defb %00000100,%00000100,%00000100,%00111100,%01000100,%01000100,%00111100,%00000000 ; char 100 - d
 129+ 4B0F 44 44 3C 00
 130+ 4B13 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01111100,%01000000,%00111000,%00000000 ; char 101 - e
 130+ 4B17 7C 40 38 00
 131+ 4B1B 18 24 20 70          defb %00011000,%00100100,%00100000,%01110000,%00100000,%00100000,%00100000,%00000000 ; char 102 - f
 131+ 4B1F 20 20 20 00
 132+ 4B23 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00111000 ; char 103 - g
 132+ 4B27 44 3C 04 38
 133+ 4B2B 40 40 58 64          defb %01000000,%01000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 104 - h
 133+ 4B2F 44 44 44 00
 134+ 4B33 00 10 00 10          defb %00000000,%00010000,%00000000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 105 - i
 134+ 4B37 10 10 10 00
 135+ 4B3B 08 00 18 08          defb %00001000,%00000000,%00011000,%00001000,%00001000,%00001000,%01001000,%00110000 ; char 106 - j
 135+ 4B3F 08 08 48 30
 136+ 4B43 40 40 48 50          defb %01000000,%01000000,%01001000,%01010000,%01100000,%01010000,%01001000,%00000000 ; char 107 - k
 136+ 4B47 60 50 48 00
 137+ 4B4B 30 10 10 10          defb %00110000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 108 - l
 137+ 4B4F 10 10 38 00
 138+ 4B53 00 00 54 6A          defb %00000000,%00000000,%01010100,%01101010,%01001010,%01000010,%01000010,%00000000 ; char 109 - m
 138+ 4B57 4A 42 42 00
 139+ 4B5B 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 110 - n
 139+ 4B5F 44 44 44 00
 140+ 4B63 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 111: o
 140+ 4B67 44 44 38 00
 141+ 4B6B 00 00 78 44          defb %00000000,%00000000,%01111000,%01000100,%01000100,%01111000,%01000000,%01000000 ; char 112: p
 141+ 4B6F 44 78 40 40
 142+ 4B73 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00000100 ; char 113: q
 142+ 4B77 44 3C 04 04
 143+ 4B7B 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000000,%01000000,%01000000,%00000000 ; char 114: r
 143+ 4B7F 40 40 40 00
 144+ 4B83 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%00111000,%00000100,%01111000,%00000000 ; char 115: s
 144+ 4B87 38 04 78 00
 145+ 4B8B 20 20 70 20          defb %00100000,%00100000,%01110000,%00100000,%00100000,%00100100,%00011000,%00000000 ; char 116: t
 145+ 4B8F 20 24 18 00
 146+ 4B93 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%01001100,%00110100,%00000000 ; char 117: u
 146+ 4B97 44 4C 34 00
 147+ 4B9B 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 118: v
 147+ 4B9F 44 28 10 00
 148+ 4BA3 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01010100,%01010100,%00101000,%00000000 ; char 119: w
 148+ 4BA7 54 54 28 00
 149+ 4BAB 00 00 44 28          defb %00000000,%00000000,%01000100,%00101000,%00010000,%00101000,%01000100,%00000000 ; char 120: x
 149+ 4BAF 10 28 44 00
 150+ 4BB3 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01001100,%00110100,%00000100,%00111000 ; char 121: y
 150+ 4BB7 4C 34 04 38
 151+ 4BBB 00 00 7C 08          defb %00000000,%00000000,%01111100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 122: z
 151+ 4BBF 10 20 7C 00
 152+ 4BC3 18 20 20 40          defb %00011000,%00100000,%00100000,%01000000,%00100000,%00100000,%00011000,%00000000 ; char 123: {
 152+ 4BC7 20 20 18 00
 153+ 4BCB 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 124: |
 153+ 4BCF 10 10 10 00
 154+ 4BD3 30 08 08 04          defb %00110000,%00001000,%00001000,%00000100,%00001000,%00001000,%00110000,%00000000 ; char 125: }
 154+ 4BD7 08 08 30 00
 155+ 4BDB 20 54 08 00          defb %00100000,%01010100,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 126: ~
 155+ 4BDF 00 00 00 00
 156+ 4BE3 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 127 (delete) - end the standard ASCII (0-127)
 156+ 4BE7 00 00 00 00
 157+ 4BEB 3C 42 A5 81          defb %00111100,%01000010,%10100101,%10000001,%10100101,%10011001,%01000010,%00111100 ; char 128 (open face)
 157+ 4BEF A5 99 42 3C
 158+ 4BF3 3C 7E DB FF          defb %00111100,%01111110,%11011011,%11111111,%11011011,%11100111,%01111110,%00111100 ; char 129 (full face)
 158+ 4BF7 DB E7 7E 3C
 159+ 4BFB 6C FE FE FE          defb %01101100,%11111110,%11111110,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 130 (hearts)
 159+ 4BFF 7C 38 10 00
 160+ 4C03 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 131 (diamonds)
 160+ 4C07 7C 38 10 00
 161+ 4C0B 10 38 54 FE          defb %00010000,%00111000,%01010100,%11111110,%01010100,%00010000,%01111100,%00000000 ; char 132 (clus)
 161+ 4C0F 54 10 7C 00
 162+ 4C13 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%11010110,%00010000,%01111100,%00000000 ; char 133 (spades)
 162+ 4C17 D6 10 7C 00
 163+ 4C1B 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 134
 163+ 4C1F FF 18 18 18
 164+ 4C23 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 135
 164+ 4C27 1F 18 18 18
 165+ 4C2B 00 00 00 F8          defb %00000000,%00000000,%00000000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 136
 165+ 4C2F F8 18 18 18
 166+ 4C33 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00000000,%00000000,%00000000 ; char 137
 166+ 4C37 F8 00 00 00
 167+ 4C3B 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00000000,%00000000,%00000000 ; char 138
 167+ 4C3F 1F 00 00 00
 168+ 4C43 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 139
 168+ 4C47 FF 00 00 00
 169+ 4C4B 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 140
 169+ 4C4F 1F 18 18 18
 170+ 4C53 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 141
 170+ 4C57 FF 18 18 18
 171+ 4C5B 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 142
 171+ 4C5F F8 18 18 18
 172+ 4C63 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 143
 172+ 4C67 FF 00 00 00
 173+ 4C6B 18 18 18 18          defb %00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000 ; char 144
 173+ 4C6F 18 18 18 18
 174+ 4C73 03 07 0E 1C          defb %00000011,%00000111,%00001110,%00011100,%00111000,%01110000,%11100000,%11000000 ; char 145
 174+ 4C77 38 70 E0 C0
 175+ 4C7B C0 E0 70 38          defb %11000000,%11100000,%01110000,%00111000,%00011100,%00001110,%00000111,%00000011 ; char 146
 175+ 4C7F 1C 0E 07 03
 176+ 4C83 C3 E7 7E 3C          defb %11000011,%11100111,%01111110,%00111100,%00111100,%01111110,%11100111,%11000011 ; char 147
 176+ 4C87 3C 7E E7 C3
 177+ 4C8B 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 148
 177+ 4C8F 10 10 10 10
 178+ 4C93 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 149
 178+ 4C97 10 10 10 10
 179+ 4C9B 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 150
 179+ 4C9F 10 10 10 10
 180+ 4CA3 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 151
 180+ 4CA7 00 00 00 00
 181+ 4CAB 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00000000,%00000000,%00000000,%00000000 ; char 152
 181+ 4CAF 00 00 00 00
 182+ 4CB3 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 153
 182+ 4CB7 00 00 00 00
 183+ 4CBB 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 154
 183+ 4CBF 10 10 10 10
 184+ 4CC3 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 155
 184+ 4CC7 10 10 10 10
 185+ 4CCB 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 156
 185+ 4CCF 10 10 10 10
 186+ 4CD3 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 157
 186+ 4CD7 00 00 00 00
 187+ 4CDB 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000 ; char 158
 187+ 4CDF 10 10 10 10
 188+ 4CE3 01 02 04 08          defb %00000001,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%10000000 ; char 159
 188+ 4CE7 10 20 40 80
 189+ 4CEB 80 40 20 10          defb %10000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000001 ; char 160
 189+ 4CEF 08 04 02 01
 190+ 4CF3 81 42 24 18          defb %10000001,%01000010,%00100100,%00011000,%00011000,%00100100,%01000010,%10000001 ; char 161
 190+ 4CF7 18 24 42 81
 191+ 4CFB 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 162
 191+ 4CFF 00 00 FF FF
 192+ 4D03 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; char 163
 192+ 4D07 FF FF FF FF
 193+ 4D0B 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 164
 193+ 4D0F FF FF FF FF
 194+ 4D13 FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 194+ 4D17 00 00 00 00
 195+ 4D1B FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 166
 195+ 4D1F 00 00 00 00
 196+ 4D23 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 167
 196+ 4D27 FF FF 00 00
 197+ 4D2B C0 C0 C0 C0          defb %11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000 ; char 168
 197+ 4D2F C0 C0 C0 C0
 198+ 4D33 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; char 169
 198+ 4D37 F0 F0 F0 F0
 199+ 4D3B FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 170
 199+ 4D3F FC FC FC FC
 200+ 4D43 03 03 03 03          defb %00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011 ; char 171
 200+ 4D47 03 03 03 03
 201+ 4D4B 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; char 172
 201+ 4D4F 0F 0F 0F 0F
 202+ 4D53 3F 3F 3F 3F          defb %00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111 ; char 173
 202+ 4D57 3F 3F 3F 3F
 203+ 4D5B FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 174
 203+ 4D5F 81 81 81 FF
 204+ 4D63 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; char 175
 204+ 4D67 F0 F0 F0 F0
 205+ 4D6B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; char 176
 205+ 4D6F 0F 0F 0F 0F
 206+ 4D73 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; char 177
 206+ 4D77 00 00 00 00
 207+ 4D7B F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 178
 207+ 4D7F 00 00 00 00
 208+ 4D83 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00001111,%00001111,%00001111,%00001111 ; char 179
 208+ 4D87 0F 0F 0F 0F
 209+ 4D8B 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%11110000,%11110000,%11110000,%11110000 ; char 180
 209+ 4D8F F0 F0 F0 F0
 210+ 4D93 3C 3C 3C 3C          defb %00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100 ; char 181
 210+ 4D97 3C 3C 3C 3C
 211+ 4D9B C3 C3 C3 C3          defb %11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011 ; char 182
 211+ 4D9F C3 C3 C3 C3
 212+ 4DA3 FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 183
 212+ 4DA7 00 00 FF FF
 213+ 4DAB 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 184
 213+ 4DAF FF FF 00 00
 214+ 4DB3 33 33 CC CC          defb %00110011,%00110011,%11001100,%11001100,%00110011,%00110011,%11001100,%11001100 ; char 185
 214+ 4DB7 33 33 CC CC
 215+ 4DBB 55 AA 55 AA          defb %01010101,%10101010,%01010101,%10101010,%01010101,%10101010,%01010101,%10101010 ; char 186
 215+ 4DBF 55 AA 55 AA
 216+ 4DC3 66 33 99 CC          defb %01100110,%00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100 ; char 187
 216+ 4DC7 66 33 99 CC
 217+ 4DCB CC 99 33 66          defb %11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011,%01100110 ; char 188
 217+ 4DCF CC 99 33 66
 218+ 4DD3 33 99 CC 66          defb %00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100,%01100110 ; char 189
 218+ 4DD7 33 99 CC 66
 219+ 4DDB 66 CC 99 33          defb %01100110,%11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011 ; char 190
 219+ 4DDF 66 CC 99 33
 220+ 4DE3 10 10 7C 10          defb %00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%01111100,%00000000 ; char 191 (Â±)
 220+ 4DE7 10 00 7C 00
 221+ 4DEB 60 18 06 18          defb %01100000,%00011000,%00000110,%00011000,%01100000,%00000000,%01111110,%00000000 ; char 192 (â¥)
 221+ 4DEF 60 00 7E 00
 222+ 4DF3 06 18 60 18          defb %00000110,%00011000,%01100000,%00011000,%00000110,%00000000,%01111110,%00000000 ; char 193 (â¤)
 222+ 4DF7 06 00 7E 00
 223+ 4DFB 3E 20 20 20          defb %00111110,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 223+ 4DFF A0 60 20 00
 224+ 4E03 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 224+ 4E07 00 00 00 00
 225+ 4E0B 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 225+ 4E0F 70 00 00 00
 226+ 4E13 00 00 2A 54          defb %00000000,%00000000,%00101010,%01010100,%00000000,%01111110,%00000000,%00000000 ; char 197
 226+ 4E17 00 7E 00 00
 227+ 4E1B 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 227+ 4E1F 54 A8 00 00
 228+ 4E23 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11100000,%11000000,%10000000,%00000000 ; char 199
 228+ 4E27 E0 C0 80 00
 229+ 4E2B FE 7C 38 10          defb %11111110,%01111100,%00111000,%00010000,%00000000,%00000000,%00000000,%00000000 ; char 200
 229+ 4E2F 00 00 00 00
 230+ 4E33 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00000111,%00000011,%00000001,%00000000 ; char 201
 230+ 4E37 07 03 01 00
 231+ 4E3B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00010000,%00111000,%01111100,%11111110 ; char 202
 231+ 4E3F 10 38 7C FE
 232+ 4E43 10 38 7C 10          defb %00010000,%00111000,%01111100,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 203 (up arrow)
 232+ 4E47 10 10 10 00
 233+ 4E4B 1E 0E 0E 12          defb %00011110,%00001110,%00001110,%00010010,%00100000,%01000000,%00000000,%00000000 ; char 204 (up right arrow)
 233+ 4E4F 20 40 00 00
 234+ 4E53 00 08 0C FE          defb %00000000,%00001000,%00001100,%11111110,%00001100,%00001000,%00000000,%00000000 ; char 205 (right arrow)
 234+ 4E57 0C 08 00 00
 235+ 4E5B 00 40 20 12          defb %00000000,%01000000,%00100000,%00010010,%00001110,%00001110,%00011110,%00000000 ; char 206 (down right arrow)
 235+ 4E5F 0E 0E 1E 00
 236+ 4E63 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%01111100,%00111000,%00010000,%00000000 ; char 207 (down arrow)
 236+ 4E67 7C 38 10 00
 237+ 4E6B 00 04 08 90          defb %00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000,%00000000 ; char 208 (down left arrow)
 237+ 4E6F E0 E0 F0 00
 238+ 4E73 00 20 60 FE          defb %00000000,%00100000,%01100000,%11111110,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 238+ 4E77 60 20 00 00
 239+ 4E7B F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 239+ 4E7F 08 04 00 00
 240+ 4E83 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 240+ 4E87 F0 44 38 00
 241+ 4E8B 00 02 7C A8          defb %00000000,%00000010,%01111100,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 241+ 4E8F 28 28 28 00
 242+ 4E93 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001000,%00010000,%00010000,%00010000 ; char 213
 242+ 4E97 08 10 10 10
 243+ 4E9B 00 00 00 C0          defb %00000000,%00000000,%00000000,%11000000,%00100000,%00010000,%00010000,%00010000 ; char 214
 243+ 4E9F 20 10 10 10
 244+ 4EA3 10 10 20 C0          defb %00010000,%00010000,%00100000,%11000000,%00000000,%00000000,%00000000,%00000000 ; char 215
 244+ 4EA7 00 00 00 00
 245+ 4EAB 10 10 08 07          defb %00010000,%00010000,%00001000,%00000111,%00000000,%00000000,%00000000,%00000000 ; char 216
 245+ 4EAF 00 00 00 00
 246+ 4EB3 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001111,%00011100,%00011000,%00011000 ; char 217
 246+ 4EB7 0F 1C 18 18
 247+ 4EBB 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00111000,%00011000,%00011000 ; char 218
 247+ 4EBF F0 38 18 18
 248+ 4EC3 18 18 38 F0          defb %00011000,%00011000,%00111000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 248+ 4EC7 E0 00 00 00
 249+ 4ECB 18 18 1C 0F          defb %00011000,%00011000,%00011100,%00001111,%00000111,%00000000,%00000000,%00000000 ; char 220
 249+ 4ECF 07 00 00 00
 250+ 4ED3 00 3C 42 42          defb %00000000,%00111100,%01000010,%01000010,%01000010,%01000010,%00111100,%00000000 ; char 221
 250+ 4ED7 42 42 3C 00
 251+ 4EDB 00 3C 7E 7E          defb %00000000,%00111100,%01111110,%01111110,%01111110,%01111110,%00111100,%00000000 ; char 222
 251+ 4EDF 7E 7E 3C 00
 252+ 4EE3 00 18 3C 7E          defb %00000000,%00011000,%00111100,%01111110,%01111110,%00111100,%00011000,%00000000 ; char 223
 252+ 4EE7 7E 3C 18 00
 253+ 4EEB FF FE FC F8          defb %11111111,%11111110,%11111100,%11111000,%11110000,%11100000,%11000000,%10000000 ; char 224
 253+ 4EEF F0 E0 C0 80
 254+ 4EF3 FF 7F 3F 1F          defb %11111111,%01111111,%00111111,%00011111,%00001111,%00000111,%00000011,%00000001 ; char 225
 254+ 4EF7 0F 07 03 01
 255+ 4EFB 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00011111,%00111111,%01111111,%11111111 ; char 226
 255+ 4EFF 1F 3F 7F FF
 256+ 4F03 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11111110,%11111111 ; char 227
 256+ 4F07 F8 FC FE FF
 257+ 4F0B 00 02 06 6C          defb %00000000,%00000010,%00000110,%01101100,%01111000,%01110000,%01100000,%00000000 ; char 228 (checkmark)
 257+ 4F0F 78 70 60 00
 258+ 4F13 00 66 3C 18          defb %00000000,%01100110,%00111100,%00011000,%00111100,%01100110,%00000000,%00000000 ; char 229 (x)
 258+ 4F17 3C 66 00 00
 259+ 4F1B 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%00111000,%00010000,%00111000,%00010000 ; char 230 (female)
 259+ 4F1F 38 10 38 10
 260+ 4F23 07 03 3D 44          defb %00000111,%00000011,%00111101,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 231 (male)
 260+ 4F27 44 44 38 00
 261+ 4F2B 78 44 42 42          defb %01111000,%01000100,%01000010,%01000010,%01000010,%01000010,%01000010,%01111110 ; char 232 (new doc)
 261+ 4F2F 42 42 42 7E
 262+ 4F33 00 F8 FF 81          defb %00000000,%11111000,%11111111,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 233 (folder)
 262+ 4F37 81 81 81 FF
 263+ 4F3B 10 7C FE 54          defb %00010000,%01111100,%11111110,%01010100,%01010100,%01010100,%01010100,%01111100 ; char 234 (trash bin)
 263+ 4F3F 54 54 54 7C
 264+ 4F43 FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10111101,%10101101,%10101101,%11111111 ; char 235 (floppy disk)
 264+ 4F47 BD AD AD FF
 265+ 4F4B 00 EA AA AC          defb %00000000,%11101010,%10101010,%10101100,%10101100,%10101010,%11101010,%00000000 ; char 236 (OK)
 265+ 4F4F AC AA EA 00
 266+ 4F53 18 7E FF 7E          defb %00011000,%01111110,%11111111,%01111110,%01111110,%01100110,%01100110,%01100110 ; char 237 (home)
 266+ 4F57 7E 66 66 66
 267+ 4F5B 3C 42 91 91          defb %00111100,%01000010,%10010001,%10010001,%10011101,%10000001,%01000010,%00111100 ; char 238 (clock)
 267+ 4F5F 9D 81 42 3C
 268+ 4F63 00 02 05 FD          defb %00000000,%00000010,%00000101,%11111101,%10100101,%10100010,%00000000,%00000000 ; char 239 (key)
 268+ 4F67 A5 A2 00 00
 269+ 4F6B 08 0C 3E 4C          defb %00001000,%00001100,%00111110,%01001100,%01001000,%01000010,%01000010,%00111100 ; char 240 (undo)
 269+ 4F6F 48 42 42 3C
 270+ 4F73 00 FF C3 A5          defb %00000000,%11111111,%11000011,%10100101,%10011001,%10000001,%11111111,%00000000 ; char 241 (letter)
 270+ 4F77 99 81 FF 00
 271+ 4F7B 38 44 44 7C          defb %00111000,%01000100,%01000100,%01111100,%01111100,%01111100,%01111100,%00000000 ; char 242 (lock)
 271+ 4F7F 7C 7C 7C 00
 272+ 4F83 06 09 09 F8          defb %00000110,%00001001,%00001001,%11111000,%11111000,%11111000,%11111000,%00000000 ; char 243 (unlock)
 272+ 4F87 F8 F8 F8 00
 273+ 4F8B FF FF 81 AD          defb %11111111,%11111111,%10000001,%10101101,%10100101,%10100101,%10000001,%11111111 ; char 244 (calendar)
 273+ 4F8F A5 A5 81 FF
 274+ 4F93 01 1A 24 4A          defb %00000001,%00011010,%00100100,%01001010,%01010010,%00100100,%01011000,%10000000 ; char 245 (diameter)
 274+ 4F97 52 24 58 80
 275+ 4F9B 7E 81 81 81          defb %01111110,%10000001,%10000001,%10000001,%10000001,%01110110,%00001100,%00000100 ; char 246 (baloon)
 275+ 4F9F 81 76 0C 04
 276+ 4FA3 0C 0A 0A 0A          defb %00001100,%00001010,%00001010,%00001010,%00001000,%00011000,%00111000,%00010000 ; char 247 (note)
 276+ 4FA7 08 18 38 10
 277+ 4FAB 12 31 F5 F5          defb %00010010,%00110001,%11110101,%11110101,%11110101,%11110101,%00110001,%00010010 ; char 248 (audio on)
 277+ 4FAF F5 F5 31 12
 278+ 4FB3 10 30 F0 F0          defb %00010000,%00110000,%11110000,%11110000,%11110000,%11110000,%00110000,%00010000 ; char 249 (audio off)
 278+ 4FB7 F0 F0 30 10
 279+ 4FBB 40 60 70 78          defb %01000000,%01100000,%01110000,%01111000,%01111100,%01111110,%01111000,%01001000 ; char 250 (pointer)
 279+ 4FBF 7C 7E 78 48
 280+ 4FC3 3C 42 99 A1          defb %00111100,%01000010,%10011001,%10100001,%10100001,%10011001,%01000010,%00111100 ; char 251 (Â©)
 280+ 4FC7 A1 99 42 3C
 281+ 4FCB 18 24 20 78          defb %00011000,%00100100,%00100000,%01111000,%00100000,%00100010,%01011100,%00000000 ; char 252 (Â£)
 281+ 4FCF 20 22 5C 00
 282+ 4FD3 3C 42 78 24          defb %00111100,%01000010,%01111000,%00100100,%00100100,%00011110,%01000010,%00111100 ; char 253 (Â§)
 282+ 4FD7 24 1E 42 3C
 283+ 4FDB 00 00 10 00          defb %00000000,%00000000,%00010000,%00000000,%01111100,%00000000,%00010000,%00000000 ; char 254 (Ã·)
 283+ 4FDF 7C 00 10 00
 284+ 4FE3 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 255 (cursor)
 284+ 4FE7 FF FF FF FF
 285+ 4FEB
# file closed: ../include/vdp/8x8fonts-r18.asm
  86  4FEB                  INCLUDE "../include/vdp/logo-fonts.asm"
# file opened: ../include/vdp/logo-fonts.asm
   1+ 4FEB              ; ------------------------------------------------------------------------------
   2+ 4FEB              ; LM80C - LOGO CHARSET - R1.1
   3+ 4FEB              ; ------------------------------------------------------------------------------
   4+ 4FEB              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4FEB              ; designed by Leonardo Miliani. More info at
   6+ 4FEB              ; www DOT leonardomiliani DOT com
   7+ 4FEB              ; ------------------------------------------------------------------------------
   8+ 4FEB              ; Code Revision:
   9+ 4FEB              ; R1.0 - 20200124 - First revision: logo chars
  10+ 4FEB              ; R1.1 - 20200229 - Adopted usual hexadecimal & binary prefixes
  11+ 4FEB              ; ------------------------------------------------------------------------------
  12+ 4FEB
  13+ 4FEB              LOGOFONT:   equ $
  14+ 4FEB 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; 0
  14+ 4FEF 00 00 00 00
  15+ 4FF3 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; 1
  15+ 4FF7 FF FF FF FF
  16+ 4FFB FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; 2
  16+ 4FFF 00 00 00 00
  17+ 5003 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; 3
  17+ 5007 0F 0F 0F 0F
  18+ 500B 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; 4
  18+ 500F FF FF FF FF
  19+ 5013 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; 5
  19+ 5017 F0 F0 F0 F0
  20+ 501B 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; 6
  20+ 501F 0F 0F 0F 0F
  21+ 5023 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; 7
  21+ 5027 F0 F0 F0 F0
  22+ 502B F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; 8
  22+ 502F 00 00 00 00
  23+ 5033 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; 9
  23+ 5037 00 00 00 00
  24+ 503B 00 00 00 FC              defb %00000000,%00000000,%00000000,%11111100,%11111111,%00000111,%00000011,%00000000 ; 10
  24+ 503F FF 07 03 00
  25+ 5043 00 00 00 3F              defb %00000000,%00000000,%00000000,%00111111,%11111111,%11100000,%11000000,%00000000 ; 11
  25+ 5047 FF E0 C0 00
  26+ 504B 18 18 1F 19              defb %00011000,%00011000,%00011111,%00011001,%00011001,%00011111,%00011000,%00011000 ; 12
  26+ 504F 19 1F 18 18
  27+ 5053 18 18 F8 98              defb %00011000,%00011000,%11111000,%10011000,%10011000,%11111000,%00011000,%00011000 ; 13
  27+ 5057 98 F8 18 18
  28+ 505B 18 18 1C 1F              defb %00011000,%00011000,%00011100,%00011111,%00001111,%00000000,%00000000,%00000000 ; 14
  28+ 505F 0F 00 00 00
  29+ 5063 00 00 00 0F              defb %00000000,%00000000,%00000000,%00001111,%00011111,%00011100,%00011000,%00011000 ; 15
  29+ 5067 1F 1C 18 18
  30+ 506B 00 00 00 F0              defb %00000000,%00000000,%00000000,%11110000,%11111000,%00111000,%00011000,%00011000 ; 16
  30+ 506F F8 38 18 18
  31+ 5073 18 18 38 F8              defb %00011000,%00011000,%00111000,%11111000,%11110000,%00000000,%00000000,%00000000 ; 17
  31+ 5077 F0 00 00 00
  32+ 507B 00 00 00 FF              defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; 18
  32+ 507F FF 00 00 00
  33+ 5083 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%11111111,%11111111,%11111111,%11111111 ; 19
  33+ 5087 FF FF FF FF
  34+ 508B F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11111111,%11111111,%11111111,%11111111 ; 20
  34+ 508F FF FF FF FF
  35+ 5093 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11110000,%11110000,%11110000,%11110000 ; 21
  35+ 5097 F0 F0 F0 F0
  36+ 509B FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00001111,%00001111,%00001111,%00001111 ; 22
  36+ 509F 0F 0F 0F 0F
  37+ 50A3 00 30 78 78              defb %00000000,%00110000,%01111000,%01111000,%00110000,%00000000,%00000000,%00000000 ; 23
  37+ 50A7 30 00 00 00
  38+ 50AB
# file closed: ../include/vdp/logo-fonts.asm
  87  50AB
  88  50AB              ; include ROM/RAM switcher
  89  50AB                  INCLUDE "../include/switcher/switcher-r11.asm"
# file opened: ../include/switcher/switcher-r11.asm
   1+ 50AB              ; ------------------------------------------------------------------------------
   2+ 50AB              ; LM80C - ROM/RAM SWITCHER - R1.1
   3+ 50AB              ; ------------------------------------------------------------------------------
   4+ 50AB              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 50AB              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 50AB              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 50AB              ; kind of warranty: you can use them at your own risk.
   8+ 50AB              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 50AB              ; maintain the copyright notices, include this advice and the note to the
  10+ 50AB              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 50AB              ; redistribuite them.
  12+ 50AB              ; https://www.leonardomiliani.com
  13+ 50AB              ;
  14+ 50AB              ; Please support me by visiting the following links:
  15+ 50AB              ; Main project page: https://www.leonardomiliani.com
  16+ 50AB              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 50AB              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 50AB              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 50AB              ; ------------------------------------------------------------------------------
  20+ 50AB              ; Code Revision:
  21+ 50AB              ; R1.0   - 20200718 - First version
  22+ 50AB              ; R1.1   - 20200827 - PIO settings now are part of the file
  23+ 50AB              ;-------------------------------------------------------------------------------
  24+ 50AB
  25+ 50AB              TMP_FW_LOC:     equ     $8000           ; address from where to make a temporary copy of the FW
  26+ 50AB              ;-------------------------------------------------------------------------------
  27+ 50AB              ; THIS CODE WILL BE EXECUTED FROM RAM
  28+ 50AB 3E FC        RAMRUN:         ld      A,%11111100     ; set ROM off and RAM on..
  29+ 50AD D3 01                        out     (PIO_DB),A      ; ...by setting bit #0 to 0 (and leave VRAM bank #0)
  30+ 50AF 01 EF 50                     ld      BC,END_OF_FW    ; let's copy back FW into low RAM - bytes to copy
  31+ 50B2 21 00 80                     ld      HL,TMP_FW_LOC   ; source address
  32+ 50B5 11 00 00                     ld      DE,$0000        ; dest. address
  33+ 50B8 ED B0                        ldir                    ; copy!
  34+ 50BA AF                           xor     A
  35+ 50BB D3 01                        out     (PIO_DB),A      ; all LEDs off - finished copying
  36+ 50BD C3 B0 02                     jp      INIT_HW         ; return control to old init (now into RAM)
  37+ 50C0
  38+ 50C0              ;-------------------------------------------------------------------------------
  39+ 50C0              ; copy the whole contents of ROM into RAM then disable the first memory
  40+ 50C0 3A 4C 51     ROM2RAM:        ld      A,(basicStarted); check if BASIC is already started
  41+ 50C3 FE 59                        cp      'Y'             ; to see if this is a power-up
  42+ 50C5 20 0F                        jr      NZ,CNTCP2RAM    ; no, continue copy to RAM
  43+ 50C7                              ; WARNING: Do **NOT** change the following "out()" sequence, ABSOLUTELY!
  44+ 50C7 3E CF                        ld      A,%11001111     ; set mode 3 ("control mode")
  45+ 50C9 D3 03                        out     (PIO_CB),A      ; for PIO port B
  46+ 50CB AF                           xor     A               ; set LEDs off, RAM on, VRAM on bank #0
  47+ 50CC D3 01                        out     (PIO_DB),A      ; send settings to PIO register
  48+ 50CE D3 03                        out     (PIO_CB),A      ; set pins following register's status
  49+ 50D0 21 7E 52                     ld      HL,TEMPSTACK    ; temporary stack
  50+ 50D3 C3 B3 02                     jp      INIT_HW2        ; jump to re-init HW
  51+ 50D6
  52+ 50D6                              ; WARNING: Do **NOT** change the following "out()" sequence, ABSOLUTELY!
  53+ 50D6 3E CF        CNTCP2RAM:      ld      A,%11001111     ; set mode 3 (mode control)
  54+ 50D8 D3 03                        out     (PIO_CB),A      ; for PIO port B
  55+ 50DA 3E FD                        ld      A,%11111101     ; set pin #0 as HIGH to enable ROM
  56+ 50DC D3 01                        out     (PIO_DB),A      ; store the value into the internal register
  57+ 50DE AF                           xor     A               ; set pins to OUTPUT
  58+ 50DF D3 03                        out     (PIO_CB),A      ; for port B, activating the RAM
  59+ 50E1 01 EF 50                     ld      BC,END_OF_FW    ; copy FW from ROM to high RAM
  60+ 50E4 21 00 00                     ld      HL,$0000        ; source address
  61+ 50E7 11 00 80                     ld      DE,TMP_FW_LOC   ; dest. address
  62+ 50EA ED B0                        ldir                    ; copy!
  63+ 50EC C3 AB D0                     jp      RAMRUN+TMP_FW_LOC; jump to execute code into RAM
  64+ 50EF
  65+ 50EF              ;-------------------------------------------------------------------------------
  66+ 50EF              END_OF_FW:      equ     $   ; this is the last cell of the firmware
# file closed: ../include/switcher/switcher-r11.asm
  90  50EF
  91  50EF              ; include workspace equates
  92  50EF                  INCLUDE "../include/workspace/workspace-r1.0.asm"
# file opened: ../include/workspace/workspace-r1.0.asm
   1+ 50EF              ; ------------------------------------------------------------------------------
   2+ 50EF              ; LM80C 64K - WORKSPACE EQUATES - R1.0
   3+ 50EF              ; ------------------------------------------------------------------------------
   4+ 50EF              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 50EF              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 50EF              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 50EF              ; kind of warranty: you can use them at your own risk.
   8+ 50EF              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 50EF              ; maintain the copyright notices, include this advice and the note to the
  10+ 50EF              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 50EF              ; redistribuite them.
  12+ 50EF              ; https://www.leonardomiliani.com
  13+ 50EF              ;
  14+ 50EF              ; Please support me by visiting the following links:
  15+ 50EF              ; Main project page: https://www.leonardomiliani.com
  16+ 50EF              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 50EF              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 50EF              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 50EF              ; ------------------------------------------------------------------------------
  20+ 50EF
  21+ 50EF              ; set starting of RAM based on computer model
  22+ 50EF                  IFDEF LM80C64K
  23+ 50EF              SERBUF_START    equ     END_OF_FW       ; RAM starts here
  24+ 50EF                  ELSE
  25+ 50EF ~            SERBUF_START    equ     $8000           ; RAM starts here
  26+ 50EF                  ENDIF
  27+ 50EF
  28+ 50EF              ;-------------------------------------------------------------------------------
  29+ 50EF              serInPtr        equ     SERBUF_START + SER_BUFSIZE
  30+ 50EF              serRdPtr        equ     serInPtr+2
  31+ 50EF              serBufUsed      equ     serRdPtr+2
  32+ 50EF              basicStarted    equ     serBufUsed+1
  33+ 50EF              bufWrap         equ     (SERBUF_START + SER_BUFSIZE) & $FF
  34+ 50EF              TEMPSTACK       equ     CURPOS - 3      ; top of BASIC line input buffer so is "free ram" when BASIC resets
  35+ 50EF
  36+ 50EF              ; BASIC WORK SPACE LOCATIONS
  37+ 50EF              ; THE INTERPRETER ALLOCATES THE FOLLOWING RAM CELLS
  38+ 50EF              ; TO STORE IMPORTANT VALUES USED FOR SOME SPECIFIC FUNCTIONS:
  39+ 50EF              ; THEY CAN BE VECTOR (ADDRESSES) FUNCTIONS, SYSTEM DATAS (I.E. VARIABLES)
  40+ 50EF              ; AND SO ON. THE FIRST CELLS ARE FILLED WITH VALUES STORED INTO ROM AT $(INITAB) ADDRESS
  41+ 50EF              WRKSPC          equ     basicStarted+$01; (3) BASIC Work space
  42+ 50EF              NMIUSR          equ     WRKSPC+$03      ; (3) NMI exit point routine
  43+ 50EF              USR             equ     NMIUSR+$03      ; (3) "USR (x)" jump  <-- in (USR+$01)/(USR+$02) the user can store the address of a specific machine language routine
  44+ 50EF              OUTSUB          equ     USR+$03         ; (1) "out p,n"
  45+ 50EF              OTPORT          equ     OUTSUB+$01      ; (2) Port (p)
  46+ 50EF              DIVSUP          equ     OTPORT+$02      ; (1) Division support routine
  47+ 50EF              DIV1            equ     DIVSUP+$01      ; (4) <- Values
  48+ 50EF              DIV2            equ     DIV1+$04        ; (4) <-   to
  49+ 50EF              DIV3            equ     DIV2+$04        ; (3) <-   be
  50+ 50EF              DIV4            equ     DIV3+$03        ; (2) <-inserted
  51+ 50EF              SEED            equ     DIV4+$02        ; (35) Random number seed  <-- starting address of a seed table
  52+ 50EF              LSTRND          equ     SEED+$23        ; (4) Last random number
  53+ 50EF              INPSUB          equ     LSTRND+$04      ; (1) INP A,(x) Routine
  54+ 50EF              INPORT          equ     INPSUB+$01      ; (2) PORT (x)
  55+ 50EF              LWIDTH          equ     INPORT+$02      ; (1) Terminal width
  56+ 50EF              COMMAN          equ     LWIDTH+$01      ; (1) Width for commas
  57+ 50EF              NULFLG          equ     COMMAN+$01      ; (1) Null after input byte flag
  58+ 50EF              CTLOFG          equ     NULFLG+$01      ; (1) Control "O" flag
  59+ 50EF              CHKSUM          equ     CTLOFG+$01      ; (2) Array load/save check sum
  60+ 50EF              NMIFLG          equ     CHKSUM+$02      ; (1) Flag for NMI break routine
  61+ 50EF              BRKFLG          equ     NMIFLG+$01      ; (1) Break flag
  62+ 50EF              RINPUT          equ     BRKFLG+$01      ; (3) Input reflection
  63+ 50EF              STRSPC          equ     RINPUT+$03      ; (2) Pointer to bottom (start) of string space - default is 100 bytes below the top of memory
  64+ 50EF              LINEAT          equ     STRSPC+$02      ; (2) Current line number. -1 means "direct mode", while -2 means cold start.
  65+ 50EF              HLPLN           equ     LINEAT+$02      ; (2) Current line with errors
  66+ 50EF              KEYDEL          equ     HLPLN+$02       ; (1) delay before key auto-repeat starts
  67+ 50EF              AUTOKE          equ     KEYDEL+$01      ; (1) delay for key auto-repeat
  68+ 50EF              FNKEYS          equ     AUTOKE+$01      ; (128) default text of FN keys
  69+ 50EF              BASTXT          equ     FNKEYS+$80      ; (3) Pointer to start of BASIC program in memory
  70+ 50EF              ; - - - - - - - - - - - - - - - - - - -   the above are locations pre-filled by the firmware at startup
  71+ 50EF              BUFFER          equ     BASTXT+$03      ; (5) Input buffer
  72+ 50EF              STACK           equ     BUFFER+$05      ; (85) Initial stack
  73+ 50EF              CURPOS          equ     STACK+$55       ; (1) Character position on line
  74+ 50EF              LCRFLG          equ     CURPOS+$01      ; (1) Locate/Create flag for DIM statement
  75+ 50EF              TYPE            equ     LCRFLG+$01      ; (1) Data type flag: 0=numeric, non-zero=string
  76+ 50EF              DATFLG          equ     TYPE+$01        ; (1) Literal statement flag
  77+ 50EF              LSTRAM          equ     DATFLG+$01      ; (2) Last available RAM location usable by BASIC
  78+ 50EF              TMSTPT          equ     LSTRAM+$02      ; (2) Temporary string pointer
  79+ 50EF              TMSTPL          equ     TMSTPT+$02      ; (12) Temporary string pool
  80+ 50EF              TMPSTR          equ     TMSTPL+$0C      ; (4) Temporary string
  81+ 50EF              STRBOT          equ     TMPSTR+$04      ; (2) Bottom of string space
  82+ 50EF              CUROPR          equ     STRBOT+$02      ; (2) Current operator in EVAL
  83+ 50EF              LOOPST          equ     CUROPR+$02      ; (2) First statement of loop
  84+ 50EF              DATLIN          equ     LOOPST+$02      ; (2) Line of current DATA item
  85+ 50EF              FORFLG          equ     DATLIN+$02      ; (1) "FOR" loop flag
  86+ 50EF              LSTBIN          equ     FORFLG+$01      ; (1) Last byte entered
  87+ 50EF              READFG          equ     LSTBIN+$01      ; (1) Read/Input flag
  88+ 50EF              BRKLIN          equ     READFG+$01      ; (2) Line of break
  89+ 50EF              NXTOPR          equ     BRKLIN+$02      ; (2) Next operator in EVAL
  90+ 50EF              ERRLIN          equ     NXTOPR+$02      ; (2) Line of error
  91+ 50EF              CONTAD          equ     ERRLIN+$02      ; (2) Where to CONTinue
  92+ 50EF              TMRCNT          equ     CONTAD+$02      ; (4) TMR counter for 1/100 seconds
  93+ 50EF              CTC0IV          equ     TMRCNT+$04      ; (3) CTC0 interrupt vector
  94+ 50EF              CTC1IV          equ     CTC0IV+$03      ; (3) CTC1 interrupt vector
  95+ 50EF              CTC2IV          equ     CTC1IV+$03      ; (3) CTC2 interrupt vector
  96+ 50EF              CTC3IV          equ     CTC2IV+$03      ; (3) CTC3 interrupt vector
  97+ 50EF              ; - - - - - - - - - - - - - - - - - - -   VIDEO REGISTERS - FROM HERE...
  98+ 50EF              SCR_SIZE_W      equ     CTC3IV+$03      ; (1) screen width (it can be either 40 chars or 32 chars/bytes)
  99+ 50EF              SCR_SIZE_H      equ     SCR_SIZE_W+$01  ; (1) screen height (it can be 24/48/192: 24 for text, 48 for MC, 192 for graphics)
 100+ 50EF              SCR_MODE        equ     SCR_SIZE_H+$01  ; (1) screen mode (0=text, 1=G1, 2=G2, 3=MC, 4=ExG2)
 101+ 50EF              SCR_NAM_TB      equ     SCR_MODE+$02    ; (2) video name table address
 102+ 50EF              SCR_CURS_X      equ     SCR_NAM_TB+$02  ; (1) cursor X
 103+ 50EF              SCR_CURS_Y      equ     SCR_CURS_X+$01  ; (1) cursor Y
 104+ 50EF              SCR_CUR_NX      equ     SCR_CURS_Y+$01  ; (1) new cursor X position
 105+ 50EF              SCR_CUR_NY      equ     SCR_CUR_NX+$01  ; (1) new cursor Y position
 106+ 50EF              SCR_ORG_CHR     equ     SCR_CUR_NY+$01  ; (1) original char positioned under the cursor
 107+ 50EF              CRSR_STATE      equ     SCR_ORG_CHR+$01 ; (1) state of cursor (1=on, 0=off)
 108+ 50EF              LSTCSRSTA       equ     CRSR_STATE+$01  ; (1) last cursor state
 109+ 50EF              PRNTVIDEO       equ     LSTCSRSTA+$01   ; (1) print on video buffer (1=on / 0=off) set to off on graphic only modes
 110+ 50EF              CHR4VID         equ     PRNTVIDEO+$01   ; (1) char for video buffer
 111+ 50EF              FRGNDCLR        equ     CHR4VID+$01     ; (1) foreground color as set by SCREEN or COLOR commands
 112+ 50EF              BKGNDCLR        equ     FRGNDCLR+$01    ; (1) background color as set by SCREEN or COLOR commands
 113+ 50EF              TMPBFR1         equ     BKGNDCLR+$01    ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 114+ 50EF              TMPBFR2         equ     TMPBFR1+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 115+ 50EF              TMPBFR3         equ     TMPBFR2+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 116+ 50EF              TMPBFR4         equ     TMPBFR3+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 117+ 50EF              VIDEOBUFF       equ     TMPBFR4+$02     ; (40) buffer used for video scrolling and other purposes
 118+ 50EF              VIDTMP1         equ     VIDEOBUFF+$28   ; (2) temporary video word
 119+ 50EF              VIDTMP2         equ     VIDTMP1+$02     ; (2) temporary video word
 120+ 50EF              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO VPD OUT OF THIS RANGE,
 121+ 50EF                                                      ; OTHERWISE YOU WILL HAVE TO CHECK THE POINTER IN "CLR_RAM_REG" FUNCTION
 122+ 50EF              ; - - - - - - - - - - - - - - - - - - -   SOUND & KEYBOARD REGISTERS - FROM HERE...
 123+ 50EF              CHASNDDTN       equ     VIDTMP2+$02     ; (2) sound Ch.A duration (in 1/100s)
 124+ 50EF              CHBSNDDTN       equ     CHASNDDTN+$02   ; (2) sound Ch.B duration (in 1/100s)
 125+ 50EF              CHCSNDDTN       equ     CHBSNDDTN+$02   ; (2) sound Ch.C duration (in 1/100s)
 126+ 50EF              KBDNPT          equ     CHCSNDDTN+$02   ; (1) temp cell used to flag if input comes from keyboard
 127+ 50EF              KBTMP           equ     KBDNPT+$01      ; (1) temp cell used by keyboard scanner
 128+ 50EF              TMPKEYBFR       equ     KBTMP+$01       ; (1) temp buffer for last key pressed
 129+ 50EF              LASTKEYPRSD     equ     TMPKEYBFR+$01   ; (1) last key code pressed
 130+ 50EF              STATUSKEY       equ     LASTKEYPRSD+$01 ; (1) status key, used for auto-repeat
 131+ 50EF              KEYTMR          equ     STATUSKEY+$01   ; (2) timer used for auto-repeat key
 132+ 50EF              CONTROLKEYS     equ     KEYTMR+$02      ; (1) flags for control keys (bit#0=SHIFT; bit#1=CTRL; bit#2=C=)
 133+ 50EF              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO PSG OUT OF THIS RANGE,
 134+ 50EF                                                      ; OTHERWISE YOU WILL HAVE TO CHANGE THE POINTER IN "initPSG" FUNCTION
 135+ 50EF              SERIALS_EN      equ     CONTROLKEYS+$01 ; (1) serial ports status: bit 0 for Port1 (A), bit 1 for Port2 (B): 0=OFF, 1=ON
 136+ 50EF              SERABITS        equ     SERIALS_EN+$01  ; (1) serial port A data bits
 137+ 50EF              SERBBITS        equ     SERABITS+$01    ; (1) serial port B data bits
 138+ 50EF              DOS_EN          equ     SERBBITS+$01    ; (1) DOS enable/disable (1/0)
 139+ 50EF              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 140+ 50EF                                                      ; from here there are the RAM locations that
 141+ 50EF                                                      ; are saved during SAVE
 142+ 50EF              PROGND          equ     DOS_EN+$01      ; (2) End of program
 143+ 50EF              VAREND          equ     PROGND+$02      ; (2) End of variables
 144+ 50EF              ARREND          equ     VAREND+$02      ; (2) End of arrays
 145+ 50EF              NXTDAT          equ     ARREND+$02      ; (2) Next data item
 146+ 50EF              FNRGNM          equ     NXTDAT+$02      ; (2) Name of FN argument
 147+ 50EF              FNARG           equ     FNRGNM+$02      ; (4) FN argument value
 148+ 50EF              FPREG           equ     FNARG+$04       ; (3) Floating point register
 149+ 50EF              FPEXP           equ     FPREG+$03       ; (1) Floating point exponent
 150+ 50EF              SGNRES          equ     FPEXP+$01       ; (1) Sign of result
 151+ 50EF              PBUFF           equ     SGNRES+$01      ; (13) Number print buffer
 152+ 50EF              MULVAL          equ     PBUFF+$0D       ; (3) Multiplier
 153+ 50EF              PROGST          equ     MULVAL+$03      ; (100) Start of program text area
 154+ 50EF              STLOOK          equ     PROGST+$64      ; Start of memory test
 155+ 50EF
# file closed: ../include/workspace/workspace-r1.0.asm
  93  50EF
  94  50EF              ; END OF ASSEMBLY SOURCE
  95  50EF              ;-------------------------------------------------------------------------------
  96  50EF
# file closed: LM80C_64K-firmware-r1.03.asm

Value    Label
------ - -----------------------------------------------------------
0x5305   CHCSNDDTN
0x5303   CHBSNDDTN
0x5197   NMIFLG
0x50D6   CNTCP2RAM
0x50EF   END_OF_FW
0x50AB   RAMRUN
0x8000   TMP_FW_LOC
0x3FDB   DV16_16_LP
0x3FD6 X DIV_16_16
0x3FCA   DIV_16_8LP
0x3FBB   DIV_8_8LOOP
0x3FAB   EXMUL16
0x3FA2   MLP1
0x3F9B   MLP
0x3F7B X TSTBIT
0x3F3B   BINIT
0x3F4E   CHKBIN
0x3F1D   BITOUT2
0x3F19   BITOUT
0x3F0B   ZEROSUP
0x3F05 X BIN2
0x3EED   NOSUB7
0x3EF1   HEXIT
0x3ECD   HEXLP
0x3ED2   HEXLP1
0x3EFA   HXERR
0x3EDA   GETHEX
0x3EBD   ADD301
0x3EAD   ADD30
0x3E97   HEX4
0x3E95   HEX3
0x3E86   HEX1
0x3E88   HEX2
0x3E32   PRTEND
0x3E26   PRTK1
0x3E23   OPNQT1
0x3E0B   CLSQT1
0x3E67   CHKEY5
0x3DF3   PTCHR1
0x3E64   CHKEY4
0x3DFB   CLSQT
0x3DBE   PRTK3
0x3DD6   PRTCHR
0x3E0D   OPNQT
0x3DC1   CNTLTK
0x3DAC   LDKEY
0x3E5B   CHKEY2
0x3E25   PRTCKEY
0x3E56   CHKEY1
0x3D95 X PRTK2
0x3D93   PRTK4
0x3D7F   CPKYEND
0x3D77   CPKEY1
0x3D6F   CPKEY3
0x3D68   CPKEY2
0x3D58   CPKEY
0x3D4A   DECLN1
0x3E34   SETREP
0x3D1A   KEYCH
0x3D81   LSTKEYS
0x3CF8   HLPERR
0x3CD6   DIRMOD
0x3C9D   EXNRM
0x3C8F   ENCHB
0x3C64   SRLCNT
0x3C4C   STRPAR
0x3C2F   SETPAR2
0x3C20   BITS8
0x3C15   BITS7
0x3C24   SETPAR
0x3C0B   BITS6
0x3BE8   SET_CTC
0x3CBA   CTC_CFG
0x3CC5   SCERR1
0x3BD7   SET_PT
0x3BBE   CKBPS
0x3CA4   SUP_BPS
0x3BB2   SETSER
0x3BA5   DEFSER
0x3B5A   CNTSER3
0x3B3D   CNTRX2
0x3B48   CNTSER2
0x3B0A   SERLED
0x3B04   SRPT2
0x3AE1   RPTRSSR
0x3AD4   RSTSERS
0x3B0E   CNTSER
0x3AD0   CHKZSER
0x3AC1   SERVAR
0x3CC9   SCERR
0x52DB   SIOBFR
0x52DA   STPBT
0x52D9   PARBT
0x52D8   DATABT
0x52D6   BPS
0x52D5   PRTNUM
0x3A7B   RPTCVB2
0x3A72   RPTCVB1
0x3A65   CNTVALY
0x3A35   CNTCL7
0x3A11   CNTCL6
0x39ED   CNTCL5
0x39CB   CNTCL4
0x39A5   CNTCL3
0x3981   CNTCL2
0x3A5F   VALIDY
0x395D   CNTCL1
0x3A5A   VALIDX
0x392E   PLTCRL
0x391F   DLSZ
0x3937   ENDCRL
0x38F2   RPTCL1
0x38DF   RPTCRL
0x393B   DRWCRL
0x52DF   DC
0x52DD   YI
0x52DB   XI
0x52D9   RADIUS
0x52D7   YC
0x52D5   XC
0x386E   DXGR
0x3897   ENDDRAW
0x383E   CNTDRW
0x3822   RPTDRW
0x381F   STRE2
0x3812   ER2
0x3FB0   negHL
0x37EF   Y1GR
0x37C5   X1GR
0x3FAD   absHL
0x3A6A   CLRVDBF
0x52E1   DX
0x52DF   SY
0x52DD   SX
0x52DB   E2
0x52D9   ER
0x52D7   Y2
0x52D5   X2
0x52CF   Y1
0x52CD   X1
0x3FB7   DIV_8_8
0x3732   PXLSET
0x370E   CNTPLT1
0x372E   NOGD
0x373A   XY2HL
0x36A9   PNTEND
0x36B3   CTPOINT
0x3660   PAINT5
0x362F   PAINT3
0x3670   CHECKPY
0x361C   PAINT2
0x36ED   CNTPLOT
0x35EC   MNPAINT
0x35E9   PAINT1
0x35E8   PAINT11
0x366F   CHECKPA
0x35DA   PAINT0
0x3667   EXITPAI
0x35CD   NXTLOOP
0x366B   EXITPA2
0x36C7   PNTRTN
0x3A82   CLRPRM
0x52D9   ORGSP
0x52D8 X SPB
0x52D7 X SPA
0x52D5   PNT
0x355F   GPCPCH1
0x3555 X GPCPCHR
0x353B   GPNTCO1
0x3532 X GPNTCOL
0x3527   RPGPNT
0x3512   GPNT
0x34FD   CNTGPT2
0x357C   CKCOL
0x52DB   TMPHL
0x52D9   NUMCHR
0x52D7   CHRPNT
0x52D5   TMPADR
0x52CD   MIXCOL
0x52CF   TMPCLR
0x52D3   GY
0x52D1   GX
0x3A9B   GMERR
0x3497   CHKG2M
0x3491   CHKCLR0
0x345C   RPTLDCL
0x3452   LOADCLR
0x3467   SETBRCL
0x3480   MIXCLRS
0x344B   CLREX2
0x3442   CLRG2
0x3439   CLRG1
0x342F   CLRTXT
0x3432   CLRMC
0x348D   CHKCLR1
0x3387   CKMAGN
0x33D4   CHKSCAR
0x337C X SETVDP
0x3395   SCVDP
0x3358   RPTPS
0x3353 X DIR_PAU
0x332D X RECWRD
0x3309 X ARET
0x32E4   ATNTAB
0x32DA   ATN1
0x3293   SINTAB
0x3277   SIN1
0x328F   QUARTR
0x328B   HALFPI
0x3224   RND2
0x3208   RND1
0x3235   RNDTAB
0x518A   LSTRND
0x322D   RESEED
0x5167   SEED
0x31B4   SUMLP
0x31AB   SMSER1
0x317B   EXPTAB
0x3123   POWER2
0x3106   POWER1
0x30E8   NEGAFT
0x30B3   EXPTEN
0x30B1   OUTEXP
0x30C0   NOENED
0x3095   SUPTLZ
0x30A1   DOEBIT
0x3070   TRYAGN
0x3061   DIGTXT
0x30D6   POWERS
0x3050   MAKNUM
0x302B   GTSIXD
0x3034   INRNG
0x3016   SIXDIG
0x30C3   RNGTST
0x30BD   JSTZER
0x3007   SPCFST
0x5326   PBUFF
0x2FB1   MULTEN
0x2FA6   ENDCON
0x2FB0   SCALPL
0x2F9A   SCALMI
0x2FDA   EDIGIT
0x2F85   EXPLP
0x2F97   CONEXP
0x2F93   DPOINT
0x2FB8   ADDIG
0x2F6F   MANLP
0x2F67   CNVNUM
0x2F56   NOMLAD
0x2F48   MLDBLP
0x2F20   DCBCDE
0x2EE9   CMPFP
0x2EB1   DETHLB
0x2EAA   INCHL
0x2E5D   RETREL
0x2E3D   MLSP10
0x2E30   OVTST1
0x2E35   OVTST2
0x2E36   OVTST3
0x2DE2   RESDIV
0x5159   DIVSUP
0x2DCF   DIVLP
0x5165   DIV4
0x515A   DIV1
0x515E   DIV2
0x5162   DIV3
0x2D9C   DIV10
0x2D34   NOMADD
0x2D23   MUL8LP
0x2D46   BYTSFT
0x2D1A   MULT8
0x5333   MULVAL
0x2E12   ADDEXP
0x2CF8   FPMULT
0x2CEF   MULLN2
0x2FCF   RSCALE
0x319C   SUMSER
0x2DAA   DVBCDE
0x2CAA   LOGTAB
0x2CA6   UNITY
0x2C94   SHRLP
0x2C91   SHRITE
0x2C84   SCALLP
0x5325   SGNRES
0x2C55   FPROND
0x2C44   RONDB
0x2C28   NORMAL
0x2C24   SAVEXP
0x2C30   PNORM
0x2C0B   CONPOS
0x2C98   SHRT1
0x2C43   RONDUP
0x2C62   PLUCDE
0x2BFD   MINCDE
0x2C82   SCALE
0x2EBA   SIGNS
0x2BD7   NOSWAP
0x2BBA   SUBCDE
0x2BB4   SUBPHL
0x2BBD   FPADD
0x30D2   HALF
0x2BAB   ROUND
0x2BA8 X ENDINK2
0x2B8D   CHKINK
0x2B89   SRTINK
0x2B9F   ENDINK
0x2B75   INKEY2
0x2B66   CMP_A
0x2B14   NOS3
0x2AFB   NOS2
0x2AE8   NOS1
0x2AB8   SNDOVR
0x2B0B   WRTSND
0x2A83   SND1
0x2A15   RPVOLCG
0x2A21   VOLCH
0x297A   PKEPRMS
0x2964   SYSRET
0x2956   NOSYSPR
0x2918   NMIINT
0x2924   NMIVR1
0x290E   NMIEINT
0x290A   NMI2
0x2915   NMIDINT
0x28E8   DISNMI
0x28F9   NM1
0x5157   OTPORT
0x28B1   WAITLP
0x28B0   NOXOR
0x5156   OUTSUB
0x28BA   SETIO
0x518E   INPSUB
0x518F   INPORT
0x2879   VAL2
0x287C   VAL3
0x286F   VAL1
0x2C23   RESZER
0x283A   RSTSTR
0x2885   MIDNUM
0x2806   LVINSTR
0x2810   CNTZIN
0x27B0   RP2INST
0x27D9   CNT1INS
0x2789   RPTINST
0x27FB   RZINSTR
0x52E3   DY
0x2778   EMPTINS
0x52DD   TF
0x52DB   TP
0x52D9   PT2
0x52D5   PT
0x52D3   ADRS2
0x52D1   LNS2
0x52CF   ADRS1
0x52CD   LNS1
0x26FF   ALLFOL
0x26F7   MID1
0x3F5C   BINERR
0x26F5   RIGHT1
0x2880   LFRGNM
0x28D0   MAKINT
0x26D4 X GTFLNM
0x26C5   GETLEN
0x26AE   POPHL
0x268F   GETSTR
0x2686   TSALP
0x267C   SSTSA
0x2695   GSTRHL
0x25E9   GRBARY
0x2620   SCNEND
0x25C9   GNXARY
0x25FA   STRADD
0x25CA   ARRLP
0x25B4   SMPVAR
0x25F7   STPOOL
0x25A3   GRBLP
0x2595   GARBLP
0x2586   TESTOS
0x256A   GRBDON
0x2559   PRSLP
0x254E   PRNUMS
0x252F   TSTOPL
0x2523   CRTSTE
0x2514   QTSTLP
0x24FE   MKTMST
0x2685   TOSTRA
0x2501   CRTMST
0x2568   TESTR
0x26ED   TOPOOL
0x24DF   STR1
0x2507   SVSTAD
0x24C8   CHEKFN
0x2440   PASSA
0x2E6B   RETINT
0x2592   GARBGE
0x242B   FRENUM
0x240A   ENDTMR
0x23D6   FNDELP
0x23F5   ENDDIM
0x23B4   ZERARY
0x2F40   MLDEBC
0x2396   DEFSIZ
0x238E   CRARLP
0x236E   BSERR
0x23D1   FINDEL
0x2355   NXTARY
0x2373   CREARY
0x2341   FNDARY
0x2319   SCPTLP
0x22F7   ZEROLP
0x2308   RETNUL
0x2305   RETADR
0x22C6   FNTHR
0x22D1   CFEVAL
0x22B8   FNDVAR
0x2D44   POPHRT
0x531D   FNARG
0x2313   SBSCPT
0x229E   NSCFOR
0x233B   ARLDSV
0x228E   NOTSTR
0x2273   ENDNAM
0x227F   CHARTY
0x2272   SVNAM2
0x225B   GTFNAM
0x5282   LCRFLG
0x2248   DIMRET
0x2E66   FLGREL
0x2E5F   FLGDIF
0x220F   CMPSTR
0x2696   GSTRDE
0x2692   GSTRCU
0x2227   CMPRES
0x21E5   CMPLG1
0x21E3   CMPLOG
0x21CC   PXOR1
0x21BF X PAND1
0x21C4   POR1
0x2430   ACPASS
0x2E95   FPBCDE
0x21A4   CNTLGC
0x218A   SGNEXP
0x2181   GOFUNC
0x2179   FNVAL
0x213A   FRMEVL
0x2132   RETNUM
0x2E7D   INVSGN
0x211E   EVLPAR
0x2148   FNOFST
0x2472   DOFN
0x2231   EVNOT
0x2126   MINUS
0x3F31   BINTFP
0x3EC1   HEXTFP
0x20FB   NOTAMP
0x2137   CONVAR
0x2E85   STAKFP
0x20B9   STKTHS
0x2645   CONCAT
0x21D1   TSTRED
0x529B   CUROPR
0x2091   FOPRND
0x2075   RLTLP
0x2068   EVAL3
0x52A6   NXTOPR
0x2065   EVAL2
0x20D0   OPRND
0x205C   EVAL1
0x2055   OPNPAR
0x204B   TSTSTR
0x2037   KILFOR
0x2EA3   LOADFP
0x2BAE   ADDPHL
0x2E92   PHLTFP
0x1FFF   NEXT1
0x1FF1   FANDT
0x1FC8   EXTIG
0x1FAD   MORDT
0x2F5B   ASCTFP
0x1FA1   LTSTND
0x2511   DTSTR
0x1F87   ITMSEP
0x1F8A   STRENT
0x1F96   INPBIN
0x1FD8   FDTLP
0x1F6C   ANTVLU
0x1F40   NEDMOR
0x1F44   GTVLUS
0x1F38   NXTITM
0x1F1B   NOPMPT
0x24BA   IDTEST
0x52A3   READFG
0x1EF0   BADINP
0x1EDE   REDO
0x1ECF   SPCLP
0x1EC8   DOSPC
0x28CA   FNDNUM
0x1EA8   ZONELP
0x1E95   CNTEND
0x2552   PRS1
0x250D   CRTST
0x2FF9   NUMASC
0x1E72   PRNTST
0x1ED7   NEXITM
0x1E9A   DOCOM
0x1EB3   DOTAB
0x1E2B   PRNTLP
0x1E24   MRPRNT
0x1E0D   IF0
0x1E16   IF1
0x1E04   IFGO
0x1DE8   ONGOLP
0x1DE7   ONGO
0x28CD   GETINT
0x2EAC   FPTHL
0x2EAF   DETHL4
0x24E9   SAVSTR
0x26B0   BAKTMP
0x5295   TMPSTR
0x1DC8   MVSTPT
0x1DC0   CRESTR
0x5321   FPREG
0x1D99   LETSTR
0x1DD1   LETNUM
0x204C   CHKTYP
0x2059   EVAL
0x5283   TYPE
0x2256   GETVAR
0x1D70   NXTSTT
0x1D6D   NXTSTL
0x1D66   NXTDTA
0x1D61   RETLIN
0x1D23   RUNLIN
0x1CDC   STORED
0x1C92   GTLNLP
0x1C8F   GETLN
0x2ECF   CMPNUM
0x2EFC   FPINT
0x5324   FPEXP
0x1C6E   DEPINT
0x1C6B X POSINT
0x2ABE   NOISUP
0x1C68   FPSINT
0x1C60   CHKLTR
0x5195   CHKSUM
0x1C53 X ACCSUM
0x1C34   ERRINT
0x52A8   ERRLIN
0x1C23   NOLIN
0x1C0D   INPBRK
0x5198   BRKFLG
0x1BF7   STALL
0x1C01   BRK
0x5319   NXTDAT
0x1BE4   UPDATA
0x1BE3   RESTNL
0x1BA6   ONJMP
0x1BA5   IFJMP
0x1C10   ENDPRG
0x1B7E   RUNCNT
0x1B7A   PUTFID
0x2E54   TSTSGN
0x1B71   SAVSTP
0x2EA0   BCDEFP
0x2047   GETNUM
0x204A   TSTNUM
0x1B35   FORFND
0x1B19   FORSLP
0x529D   LOOPST
0x1AFE   CNTWTSP
0x1AF2   WTSPC
0x1AEA   LVSRLN
0x1ADF   SRCLN1
0x1ABC   OUTWRD
0x1ACA   NXTLN
0x1AA3   LSTLP3
0x1AA0   LSTLP2
0x1A94   LST07
0x1A91   LST08
0x1AEC   TSTSPC
0x1BE9   TSTBRK
0x364E   PAINT4
0x1A66   LST02
0x1A63   LST05
0x1A26   LST06
0x1A4F   LST03
0x1A2A   LSTNOT
0x1A0B   LST01H
0x1A6F   LISTLP
0x1ADE   SRCLN
0x1AD8   SRCHLIN
0x1A08   LST01
0x1A37   LSTALL
0x330A   GETINP
0x3F61   MONOUT
0x19BB   SND2VID
0x19A8   INCLEN
0x5281   CURPOS
0x5191   LWIDTH
0x19AC   DINPOS
0x2584   POPAF
0x197D   CHKSYN
0x196E   OUTIT
0x1971   OUTNBS
0x3F82   OUTNCR
0x195A   PUTBUF
0x1E81   ENDINP
0x1954   GMNCR
0x195F   PUTCTL
0x191F   PROCES
0x19C9   CLOTST
0x18F7   KILIN
0x18EC   DELCHR
0x1906   MORINP
0x18F4   OTKLN
0x18E0   ECHDEL
0x5193   NULFLG
0x18CC   DODEL
0x18B3   NXTCHR
0x18AD   TSTREM
0x18AA   SETLIT
0x188C   NOCHNG
0x1883   NOSPC
0x1894   MATCH
0x1872   NXTBYT
0x1862   GETNXT
0x1860   SEARCH
0x1898   RETNAD
0x1847   FNDWRD
0x18C3   ENDBUF
0x18BC   CPYLIT
0x189C   MOVDIR
0x181D   CRNCLP
0x5284   DATFLG
0x5199   RINPUT
0x1800   DOAGN
0x531B   FNRGNM
0x52A1   FORFLG
0x52AA   CONTAD
0x5287   TMSTPT
0x5289   TMSTPL
0x5315   VAREND
0x5299   STRBOT
0x52A4   BRKLIN
0x17D1   INTVAR
0x17A4   SRCHLP
0x5224   BASTXT
0x1795   FNDEND
0x1789   PTRLP
0x17CD   RUNFST
0x177C   MOVBUF
0x1784   SETPTR
0x174E   SFTPRG
0x5313   PROGND
0x175D   INEWLN
0x1D3D   ULERR
0x1746   LINFND
0x17A1   SRCHLN
0x52A2   LSTBIN
0x1B9E   EXCUTE
0x1814   CRUNCH
0x18FD   GETLIN
0x1702   GETCMD
0x16F4   POPNOK
0x2FE6   LINEIN
0x51A0   HLPLN
0x16F0   PTLN
0x16D3   ERRIN
0x1988   OUTC
0x1E79   STTLIN
0x5194   CTLOFG
0x16AD   TMERR
0x16AA   OVERR
0x16A7   UFERR
0x16A4   DDERR
0x16A1   NFERR
0x169E   DZERR
0x529F   DATLIN
0x1695   DATSNR
0x1693   LDG1ND
0x1682   LDG1
0x1675   EXITGM
0x16AF   ERROR
0x1670   OMERR
0x5317   ARREND
0x1658   CHKSTK
0x164D   MOVLP
0x164A   MOVSTR
0x1661   ENFMEM
0x1647   MOVUP
0x163E   INDFND
0x1628   LOKFOR
0x1624   BAKSTK
0x161E   BRKMSG
0x1619   OKMSG
0x1618   ZERBYT
0x1614   INMSG
0x160D   ERRMSG
0x158B X DEFFNKS
0x1589   AUTORP
0x18FD   TTYLIN
0x1C89   FCERR
0x219D   POR
0x21A2   PXOR
0x219A   PAND
0x2C0E   BNORM
0x30F6   POWER
0x2D4B   DINT
0x2D53   MOD
0x2DA8   DIV
0x2CF6   MULT
0x2BB8   PSUB
0x2FD5   PADD
0x1516   PRITAB
0x00E9   ZLEFT
0x00E1   ZINSTR
0x00E0   ZPOINT
0x00CA   ZSGN
0x00C9   ZLTH
0x00C8   ZEQUAL
0x00C7   ZGTR
0x00C6   ZOR
0x00C2 X ZDINT
0x00C1 X ZMOD
0x00C0 X ZDIV
0x00BF X ZTIMES
0x00BE   ZMINUS
0x00BD   ZPLUS
0x00BC   ZSTEP
0x00BB   ZNOT
0x00BA   ZTHEN
0x00B9   ZSPC
0x00B8   ZFN
0x00B7   ZTO
0x00B6   ZTAB
0x00B5   ZNEW
0x00AF   ZPRINT
0x00AE   ZELSE
0x008E   ZREM
0x008C   ZGOSUB
0x0088   ZGOTO
0x0083   ZDATA
0x0081   ZFOR
0x0080   ZEND
0x17C1   NEW
0x3E6B   SAVE
0x3E6A   LOAD
0x1CB3   CLEAR
0x19DC   LIST
0x1C3A   CONT
0x1E28   PRINT
0x3F64   RESET
0x2938   SYS
0x3320   WIDTH
0x34A0   GPRINT
0x28DE   NMI
0x3CFD   KEY
0x330C   CLS
0x3CE2   HELP
0x3AA0   SERIAL
0x358F   PAINT
0x389B   CIRCLE
0x3765   DRAW
0x36D2   PLOT
0x33E4   COLOR
0x334A   PAUSE
0x29F3   VOLUME
0x2A2C   SOUND
0x29A0   LOCATE
0x2B20   VREG
0x29D2   SREG
0x2995   VPOKE
0x3333   DOKE
0x2990   POKE
0x2445   DEF
0x289C   WAIT
0x3E6D   ERASE
0x3E6C   FILES
0x1DD8   ON
0x2896   POUT
0x1C06   STOP
0x1D69   REM
0x1D42   RETURN
0x1D13   GOSUB
0x1BCE   RESTOR
0x1DF6   IF
0x1CFF   RUN
0x1D24   GOTO
0x1D7E   LET
0x1F33   READ
0x2251   DIM
0x1F01   INPUT
0x1D67   DATA
0x1FFC   NEXT
0x1B05   FOR
0x1C08   PEND
0x14AA   WORDTB
0x131D   WORDS
0x2821   MID
0x2817   RIGHT
0x26F1   LEFT
0x3EFF   BIN
0x3E6E   HEX
0x26E1   CHR
0x26D0   ASC
0x2851   VAL
0x24D9   STR
0x3B44   RXEND
0x26C1   LEN
0x2721   INSTR
0x367F   POINT
0x2B5B   INKEY
0x2B47   SSTAT
0x2B3C   VSTAT
0x296D   VPEEK
0x3328   DEEK
0x2966   PEEK
0x32BD   ATN
0x32A8   TAN
0x3369   SCREEN
0x3247   SIN
0x3241   COS
0x313B   EXP
0x2CB7   LOG
0x31CC   RND
0x30ED   SQR
0x243D   POS
0x288A   INP
0x240F   FRE
0x52D7   PT1
0x5153   USR
0x2E79   ABS_
0x2F27   INT
0x23F9   TMR
0x2E63   SGN
0x12D9   FNCTAB
0x16F5   PRNTOK
0x3D0A   RESFN
0x126A   BRKRET
0x522C   STACK
0x127F   BFREE
0x2FEE   PRNTHL
0x1276   BLNSPC
0x17C2   CLRPTR
0x519C   STRSPC
0x5285   LSTRAM
0x1233   NODOS
0x1977   CPDEHL
0x169B   SNERR
0x1C8E   ATOH
0x121C   SETTOP
0x11F8   MLOOP
0x539A   STLOOK
0x120A   TSTMEM
0x1BBE   GETCHR
0x1804   PROMPT
0x254F   PRS
0x12CE   MEMMSG
0x11E2   MSIZE
0x11F5   MNOASK
0x2A3A   CTSNDC
0x5336   PROGST
0x5227   BUFFER
0x1E8B   PRNTCRLF
0x17E7   CLREG
0x1AB2   FNDTOK
0x160D   INITBE
0x1534   INITAB
0x11C7   INIT
0x514D   WRKSPC
0x2431   ABPASS
0x1E6E   PRNTNB
0x1C74   DEINT
0x11C0   CSTART
0x1267   WARMST
0x11B9   STARTB
0x1003 X ERRORS
0x11A9   HPMSG
0x1001 X HPPTR
0x1193   SOMSG
0x117A   SAMSG
0x0FFD X SAPTR
0x1165   SCMSG
0x0FFB X SCPTR
0x0FF9 X GMPRT
0x1149   BNMSG
0x0FF7 X BNPTR
0x113E   HXMSG
0x0FF5 X HXPTR
0x112E   MOMSG
0x0FF3 X MOPTR
0x3EA4   BYT2ASC
0x1118   UFMSG
0x0FF1 X UFPTR
0x1109   CNMSG
0x0FEF X CNPTR
0x10EE   STMSG
0x0FED X STPTR
0x0FFF X SOPTR
0x10DE   LSMSG
0x0FEB X LSPTR
0x10CA   OSMSG
0x0FE9 X OSPTR
0x10BB   TMMSG
0x0FE7 X TMPTR
0x10AC   IDMSG
0x0FE5 X IDPTR
0x109B   DZMSG
0x0FE3 X DZPTR
0x1086   DDMSG
0x0FE1 X DDPTR
0x1078   BSMSG
0x0FDF X BSPTR
0x1069   ULMSG
0x3E5E   CHKEY3
0x0FDD X ULPTR
0x105B   OMMSG
0x0FDB X OMPTR
0x1052   OVMSG
0x0FD9 X OVPTR
0x103C   FCMSG
0x0FD7 X FCPTR
0x1030   ODMSG
0x0FD5 X ODPTR
0x101B   RGMSG
0x0FD3 X RGPTR
0x1014   SNMSG
0x0FD1 X SNPTR
0x1003   NFMSG
0x0FCF X NFPTR
0x0FCF   ERRTBL
0x0032   HP
0x0030   SO
0x002E   SA
0x002C   SC
0x002A   GM
0x0028   BN
0x0026 X HX
0x0024   MO
0x0022   UF
0x0020   CN
0x001E   ST
0x1ECD   ASPCS
0x001C   LS
0x001A   OS
0x0018   TM
0x0016   ID
0x0014   DZ
0x0012   DD
0x0010   BS
0x000E   UL
0x000C   OM
0x000A   OV
0x0008   FC
0x0006   OD
0x0004   RG
0x0002   SN
0x0000   NF
0x007F   DEL
0x0020   SPC
0x001B   ESC
0x0015   CTRLU
0x0013   CTRLS
0x0012   CTRLR
0x0011   CTRLQ
0x000F   CTRLO
0x0007   CTRLG
0x0EA7   CNTFNK
0x0EBA   PRNTFNK
0x0EAD   PUTCHRBUF1
0x0E93   LDFNKEYCHR
0x51A4   FNKEYS
0x519E   LINEAT
0x128D   SIGNON
0x0E7A X LVKBRDCHK
0x0E73   PNT2VD
0x0E66   PUTCHRBUF
0x0E54   SNDKEYTOBFR
0x0E7B   PRNTFNKEY
0x0E4C   CHKFNK
0x0EC7   FNKEYSORD
0x0E46   CNTKBCK
0x0003   CTRLC
0x51A3   AUTOKE
0x2C11   BNRMLP
0x0E33   SENDKEY
0x0E04   SETNEWAUTO
0x0E76   LVKBRDCHK2
0x51A2   KEYDEL
0x0E14   CHKAUTO
0x530C   KEYTMR
0x0E26   NEWKEY
0x0F4F   KBMAP_ALT
0x0F8F   KBMAP_CTRL
0x0DCB   CHKALT
0x0DD2   LOADMAP
0x0F0F   KBMAP_SFT
0x0DC2   CHKCTRL
0x0ECF   KBMAP
0x0DAE   CHKLN
0x530B   STATUSKEY
0x530A   LASTKEYPRSD
0x0D96   ENDCTRLCK
0x0D90   TESTCTRL
0x0DAC   FINDKEY
0x0D83   TESTALT
0x5308   KBTMP
0x0D9A   NOKEYPRSD
0x0D54   RPTKBDRD
0x0D50   CHECKKBD
0x0D42   CHECKCTRL
0x530E   CONTROLKEYS
0x0D34   CHECKALT
0x0CF4   CNTCHKSND
0x0CB9   CHKSNDCH
0x0C87   RPTWLCMBP
0x0C9D   NOBPDAT
0x0C84   SENDSND
0x0C95   WLCBPDAT
0x0CAA   WRTSNDREG
0x0CA5   SETSNDREG
0x0C6B   SNDREGCFG
0x0C57   CLRPSGREGS
0x0C53   EMPTSNDBFR
0x0B05 X VDPMODESETEX2
0x0AFD X VDPMODESETMC
0x0AF5 X VDPMODESET2
0x250E   QTSTR
0x0AED X VDPMODESET1
0x0ADB   SENDCHRPTRNS
0x47EB   CHRST88
0x0AD9   NXTCHAR
0x3FEB   CHRST68
0x0ABB   LDREGVLS
0x0AE5   VDPMODESET
0x0AA4   RSTVDPRAMREG
0x5301   CHASNDDTN
0x0A95   EMPTVRM
0x0A2A X CNTNULL2
0x0A1D   RPTNLLSRC2
0x3F93   MUL16
0x09F8   ADDNEWLINE
0x09C5   SNDCHRTOBFR
0x09AC   CNTNULL
0x099C   RPTNLLSRC
0x09E4   PRNTRETURN
0x52D3   TMPBFR4
0x52D1   TMPBFR3
0x52CF   SRTTXT
0x52CF   TMPBFR2
0x0972   RPTEMPTYROW
0x0958   WRITEBUF
0x0930   LOADNEXTCOL
0x52D5   VIDEOBUFF
0x091F   SCROLLNXTRW
0x52FF   VIDTMP2
0x52FD   VIDTMP1
0x08FD   EXITCURSOR_ON
0x08E7   EXITCURSORDOWN
0x08C7   EXITCURSORRGHT
0x08C1   CONTCRSRGT
0x08AE   CHCKYPOS2
0x0893   EXITCURSORUP
0x086A   CHKYPOS
0x0857   EXITCURSORLEFT
0x0854   CONTCRSLFT
0x0843   CHCKYPOS
0x0859   MVCRS2LFT
0x0810 X ENDINSRT
0x080B   NXTINST
0x3F88   CMP16
0x07FA   CHKHL
0x52D1   ENDTXT
0x0A05   ENDOFLN
0x52CD   CUR_POS
0x07D8   PUTCRSCHR
0x0906   SCROLLUP
0x0797   SETCRSRY
0x0798   SETCSRCOORDS
0x07AA   EXITCHAR2VID
0x076E   NXTCPCK
0x0761   RPTCPCK
0x07B7   PLACEHOLDER
0x000A   LF
0x07DC   INSERTKEY
0x001A   INSRT
0x08CA   CURSORDOWN
0x001F   CRSDN
0x0895   CURSORRIGHT
0x001D   CRSRGT
0x087C   CURSORUP
0x001E   CRSUP
0x0830   CURSORLEFT
0x001C   CRSLFT
0x081D   BACKSPACE
0x3401   CNTCKCL
0x0008   BKSP
0x097E   CRGRETURN
0x000C   CS
0x0019   HOME
0x0730   CHRTBL
0x3FC7   DIV_16_8
0x071F   HL2XY
0x0A2B   POS_TB_CRS_32
0x0711   CONT_POS_CURS
0x0A5B   POS_TB_CRS_40
0x52C8   LSTCSRSTA
0x06C9   MOVSHOWCRS
0x06DE   NEWCRSRCOORD
0x06F3   RSTCHRCRS
0x06FC   LOAD_CRSR_POS
0x06B2   READ_VSTAT
0x06A7   WRITE_VREG
0x0692   WRITE_VIDEO_LOC
0x067D   READ_VIDEO_LOC
0x06C3   MOVCRS
0x52C4   SCR_CUR_NX
0x0000   NLLCR
0x52C5   SCR_CUR_NY
0x0673   ATHOME
0x06B9   POS_CURSOR
0x0666   CLEARVIDBUF
0x0653   RPTFLL1
0x0641   SNDCLRSET
0x063D   STARTEMPTY
0x0607   CLRG2PTNTBL
0x05ED   RPTEMPTYBUF
0x05E7   LDCOLSTOEMPTY
0x0626   EMPTYMC
0x05F6   EMPTYG2
0x05CC   LVCKSPLK
0x0CFF   READKBLN
0x05AF   SNDLOGPT
0x2C6E   COMPL
0x4FEB   LOGOFONT
0x0C81   NOBEEP
0x0C7B   WLCMBEEP
0x057B   RPT100
0x05BE   CHKSPCK
0x0591   BEEPOFF
0x0585   SETBEEP
0x054F   DEC_D
0x5312   DOS_EN
0x52CD   TMPBFR1
0x053D   RPT104
0x0599   LOADLOGOCHRS
0x0535   RPT103
0x0B0D   LM80CLOGO
0x051F   RPT102
0x0C5E   RSTPSG
0x051C   RPT101
0x05B9   CLRTABLE
0x056E   ERASECLRTBL
0x064B   SETNAMETABLE
0x0AB1   SET_GFX_MODE2
0x52C6   SCR_ORG_CHR
0x05CE   EMPTYVIDBUF
0x0459   LDCLRTBMD1
0x52CB   FRGNDCLR
0x065D   SETVDPADRS
0x04E9   ENDVDPSET
0x52C0   SCR_NAM_TB
0x5192   COMMAN
0x52BD   SCR_SIZE_H
0x52BC   SCR_SIZE_W
0x52CC   BKGNDCLR
0x52C3   SCR_CURS_Y
0x04E0   LDCLRTBEX2
0x52C2   SCR_CURS_X
0x0AC5   LOADCHARSET
0x03F8 X TXTMD
0x04A7   EXG2MD
0x0484   MCMD
0x0462   G2MD
0x0422   G1MD
0x52BE   SCR_MODE
0x0A9E   CLR_RAM_REG
0x0AA9   SET_GFX_MODE
0x0A8B   EMPTY_VRAM
0x0367   RESTMR
0x036C   CTCCONF
0x033E X SIO_B_SETS
0x0338   SIO_A_SETS
0x11B6   WARM
0x11B3   COLD
0x08FF   CURSOR_OFF
0x031E   ECHO_CHAR
0x0311   CHECKWARM
0x02FA   CORW
0x08EA   CURSOR_ON
0x03B6   MSGTXT2
0x0306   COLDSTART
0x514C   basicStarted
0x0378   MSGTXT1
0x52C9   PRNTVIDEO
0x3F73   INITST
0x03D3   initVDP
0x04F4   SHOW_LOGO
0x0C4D   initPSG
0x0342   initCTC
0x02B3   INIT_HW2
0x527E   TEMPSTACK
0x02B0   INIT_HW
0x0D14   KEYBOARD
0x0CAF   MNGSNDS
0x07B8   FLASHCURSOR
0x029C   CHKCRSR
0x0296   INCTMR3
0x52AC   TMRCNT
0x028D   CH3_TIMER
0x027F   RAWPRINT
0x026B   EXTXA
0x026E   TX_EMP
0x0266   TXA_EXIT
0x0257   CNTTXA
0x0249   RXA_EXIT
0x0238   NOTRDWRAP
0x5149   serRdPtr
0x50EF   SERBUF_START
0x020B   NOTWRAP
0x0047   bufWrap
0x5147   serInPtr
0x01FF   NOTFULL
0x514B   serBufUsed
0x01E2   SIO_B_EI
0x01E8   SIO_RXEN
0x01DA   SIO_A_EI
0x01D0   SIO_RXDI
0x01B0 X B_RTS_ON
0x01B6   SIO_RTS_ON
0x01A8   A_RTS_ON
0x5311   SERBBITS
0x019C   SIO_RTS_OFF
0x5310   SERABITS
0x0180   EMPTYCHBBFR
0x01CA   SIO_B_DI
0x0196   B_RTS_OFF
0x3CCE   SOERR
0x015C   CHABFREMPTY
0x014E   EMPTYCHABFR
0x530F   SERIALS_EN
0x01C2   SIO_A_DI
0x1154   GMMSG
0x074E   CHAR2VID
0x52C7   CRSR_STATE
0x5307   KBDNPT
0x0120   CNTRXCHA
0x000D   CR
0x52CA   CHR4VID
0x0130   LVRXCHA
0x01F4   CHARINTOBFR
0x5309   TMPKEYBFR
0x018E   A_RTS_OFF
0x00EC   FMVEREND
0x00D0 X FWVER
0x5150   NMIUSR
0x52B9   CTC3IV
0x52B6   CTC2IV
0x52B3   CTC1IV
0x52B0   CTC0IV
0x027A   CKINCHAR
0x0018 X RST18
0x0223   RXA
0x0010 X RST10
0x0135   SPEC_RXA_CNDT
0x0100   RX_CHA_AVAIL
0x024D   TXA
0x0008 X RST08
0x0167   SPEC_RXB_CNDT
0x0164   RX_CHB_AVAIL
0x50C0   ROM2RAM
0x0000 X RST00
0x0005   SER_EMPTYSIZE
0x0050   SER_FULLSIZE
0x0058   SER_BUFSIZE
0x0041   PSG_DAT
0x0040   PSG_REG
0x0031   VDP_SET
0x0030   VDP_DAT
0x0021   SIO_DB
0x0020   SIO_DA
0x0023   SIO_CB
0x0022   SIO_CA
0x0013   CTC_CH3
0x0012   CTC_CH2
0x0011   CTC_CH1
0x0010   CTC_CH0
0x0003   PIO_CB
0x0002 X PIO_CA
0x0001   PIO_DB
0x0000 X PIO_DA
