# file opened: LM80C_64K-firmware-r1.15.asm
   1  0000              ; ------------------------------------------------------------------------------
   2  0000              ; LM80C 64K - FIRMWARE - R1.15
   3  0000              ; ------------------------------------------------------------------------------
   4  0000              ; The following code is intended to be used with LM80C Z80-based computer
   5  0000              ; designed by Leonardo Miliani. More info at
   6  0000              ; www DOT leonardomiliani DOT com
   7  0000              ; ------------------------------------------------------------------------------
   8  0000              ; Coding/Editing/Compiling:
   9  0000              ; Original init code for MC68B05 by Grant Searle
  10  0000              ; Original SIO/CTC/PIO init code by Mario Blunk
  11  0000              ; NASCOM BASIC originally modified by Gran Searle
  12  0000              ; Code modified and adapted for LM80C by Leonardo Miliani
  13  0000              ;
  14  0000              ; Edited with Visual Studio Code
  15  0000              ;
  16  0000              ; Compiled with SjASMPlus assembler 1.18.2
  17  0000              ; https://github.com/z00m128/sjasmplus
  18  0000              ; ------------------------------------------------------------------------------
  19  0000              ; Copyright notes:
  20  0000              ; Parts of the code (c) Grant Searle - free for non commercial use
  21  0000              ; Please include this advice and the note to the attribution of the original
  22  0000              ; version to Grant Searle if you intend to redistribuite it
  23  0000              ; http://searle.hostei.com/grant/index.html
  24  0000              ; eMail: home.micros01@btinternet.com
  25  0000              ;
  26  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  27  0000              ; Parts of the code (c) Mario Blunk
  28  0000              ; http://www.trainÂ­z.de
  29  0000              ;
  30  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  31  0000              ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  32  0000              ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  33  0000              ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  34  0000              ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  35  0000              ; the original ROM code (checksum A934H). PA
  36  0000              ;
  37  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  38  0000              ; The following code is intended to be used with LM80C Z80-based computer
  39  0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
  40  0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
  41  0000              ; kind of warranty: you can use them at your own risk.
  42  0000              ; You are free to use them for any non-commercial use: you are only asked to
  43  0000              ; maintain the copyright notices, include this advice and the note to the
  44  0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  45  0000              ; redistribuite them.
  46  0000              ; https://www.leonardomiliani.com
  47  0000              ;
  48  0000              ; Please support me by visiting the following links:
  49  0000              ; Main project page: https://www.leonardomiliani.com
  50  0000              ; Schematics and code: https://github.com/leomil72/LM80C
  51  0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  52  0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  53  0000              ; ------------------------------------------------------------------------------
  54  0000              ; set name for binary output file
  55  0000                  OUTPUT "LM80C-64K-firmware-r1.15.bin"
  56  0000
  57  0000              ; set firmware version
  58  0000                  DEFINE VERSION "1.15"
  59  0000
  60  0000              ; set DOS version
  61  0000                  DEFINE  DOS_VER "1.04"
  62  0000
  63  0000              ; ------------------------------------------------------------------------------
  64  0000              ; include the latest version of the bootloader: this sets up the address aliases,
  65  0000              ; configure the hardware, checks if warm or cold startup and loads the BASIC interpreter
  66  0000                  INCLUDE "../include/bootloader/bootloader-1.07.asm"
# file opened: ../include/bootloader/bootloader-1.07.asm
   1+ 0000              ; ------------------------------------------------------------------------------
   2+ 0000              ; LM80C - BOOTLOADER - 1.07
   3+ 0000              ; ------------------------------------------------------------------------------
   4+ 0000              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0000              ; kind of warranty: you can use them at your own risk.
   8+ 0000              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0000              ; maintain the copyright notices, include this advice and the note to the
  10+ 0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0000              ; redistribuite them.
  12+ 0000              ; https://www.leonardomiliani.com
  13+ 0000              ;
  14+ 0000              ; Please support me by visiting the following links:
  15+ 0000              ; Main project page: https://www.leonardomiliani.com
  16+ 0000              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0000              ; ------------------------------------------------------------------------------
  20+ 0000
  21+ 0000              ; ADDRESS DECODING (bits A6/A5/A4)
  22+ 0000              ; 0000xxxx : PIO
  23+ 0000              ; 0001xxxx : CTC
  24+ 0000              ; 0010xxxx : SIO
  25+ 0000              ; 0011xxxx : VDP
  26+ 0000              ; 0100xxxx : PSG
  27+ 0000              ; 0101xxxx : C.F.
  28+ 0000
  29+ 0000
  30+ 0000              ; ------------------------------------------------------------------------------
  31+ 0000              ;               EQUATES
  32+ 0000              ; ------------------------------------------------------------------------------
  33+ 0000              ; label defining for PIO (Parallel Input/Output)
  34+ 0000              PIO_DA          equ %00000000
  35+ 0000              PIO_DB          equ %00000001
  36+ 0000              PIO_CA          equ %00000010
  37+ 0000              PIO_CB          equ %00000011
  38+ 0000
  39+ 0000              ; label defining for CTC (Counter Timer Circuit)
  40+ 0000              CTC_CH0         equ %00010000
  41+ 0000              CTC_CH1         equ %00010001
  42+ 0000              CTC_CH2         equ %00010010
  43+ 0000              CTC_CH3         equ %00010011
  44+ 0000
  45+ 0000              ;label defining for SIO (Serial Input/Output)
  46+ 0000              SIO_CA          equ %00100010
  47+ 0000              SIO_CB          equ %00100011
  48+ 0000              SIO_DA          equ %00100000
  49+ 0000              SIO_DB          equ %00100001
  50+ 0000
  51+ 0000              ;label defining for VDP (Video Display Processor)
  52+ 0000              VDP_DAT         equ %00110000
  53+ 0000              VDP_SET         equ %00110001
  54+ 0000
  55+ 0000              ; label defining for PSG (Programmable Sound Generator)
  56+ 0000              PSG_REG         equ %01000000
  57+ 0000              PSG_DAT         equ %01000001
  58+ 0000
  59+ 0000              ; Interrupt-driven serial I/O interface lead by the Z80 SIO to run modified
  60+ 0000              ; NASCOM Basic 4.7 - Full input buffering with incoming data hardware handshaking
  61+ 0000              ; Handshake shows full before the buffer is totally filled to allow run-on from the sender
  62+ 0000              SER_BUFSIZE     equ     $58
  63+ 0000              SER_FULLSIZE    equ     $50
  64+ 0000              SER_EMPTYSIZE   equ     $05
  65+ 0000
  66+ 0000
  67+ 0000              ;------------------------------------------------------------------------------
  68+ 0000              ;                                F I R M W A R E
  69+ 0000              ;------------------------------------------------------------------------------
  70+ 0000              ; BASE MEMORY - RESET LOCATION ($0000) -> the CPU jumps to $0000 after a reset
  71+ 0000                              org     $0000
  72+ 0000 F3           RST00:          di                      ; be sure that INTs are disabled
  73+ 0001 C3 04 53                     jp      ROM2RAM         ; jump to ROM/RAM switcher
  74+ 0004
  75+ 0004              ;------------------------------------------------------------------------------
  76+ 0004              ; interrupt vector when SIO ch.B has a char available in its buffer
  77+ 0004                              ;$0004
  78+ 0004 65 01                        defw    RX_CHB_AVAIL
  79+ 0006
  80+ 0006              ;------------------------------------------------------------------------------
  81+ 0006              ; interrupt vector for SIO ch.B special conditions (i.e. buf overrun)
  82+ 0006                              ;$0006
  83+ 0006 68 01                        defw    SPEC_RXB_CNDT
  84+ 0008
  85+ 0008              ;------------------------------------------------------------------------------
  86+ 0008              ; send a character over serial ch. A
  87+ 0008                              ;$0008
  88+ 0008 C3 59 02     RST08:          jp      TXA
  89+ 000B FF                           BLOCK   1,$FF   ; filler
  90+ 000C
  91+ 000C              ;------------------------------------------------------------------------------
  92+ 000C              ; interrupt vector when SIO ch.A has a char available in its buffer
  93+ 000C                              ;$000C
  94+ 000C 00 01                        defw    RX_CHA_AVAIL
  95+ 000E
  96+ 000E              ;------------------------------------------------------------------------------
  97+ 000E              ; interrupt vector for SIO ch.A special conditions (i.e. buf overrun)
  98+ 000E                              ;$000E
  99+ 000E 36 01                        defw    SPEC_RXA_CNDT
 100+ 0010
 101+ 0010              ;------------------------------------------------------------------------------
 102+ 0010              ; receive a character over serial ch. A
 103+ 0010                              ;$0010
 104+ 0010 C3 2A 02     RST10:          jp      RXA
 105+ 0013 FF FF FF...                  BLOCK   5,$FF   ; filler
 106+ 0018              ;------------------------------------------------------------------------------
 107+ 0018              ; check buffer state
 108+ 0018
 109+ 0018                              ;$0018
 110+ 0018 C3 78 02     RST18:          jp      CKINCHAR
 111+ 001B FF FF FF...                  BLOCK   $25,$FF ; filler
 112+ 0040              ;------------------------------------------------------------------------------
 113+ 0040              ; interrupt vectors for CTC
 114+ 0040                              ;$0040               ; for CH0 Timer - used in BASIC by serial 1 for bps
 115+ 0040 24 55                        defw    CTC0IV
 116+ 0042                              ;$0042               ; for CH1 Timer - used in BASIC by serial 2 for bps
 117+ 0042 27 55                        defw    CTC1IV
 118+ 0044                              ;$0044               ; for CH2 timer - unused
 119+ 0044 2A 55                        defw    CTC2IV
 120+ 0046                              ;$0046               ; for CH3 Timer - used by FW for 100ths/s counter
 121+ 0046 2D 55                        defw    CTC3IV
 122+ 0048 FF FF FF...                  BLOCK   $1E,$FF ; filler
 123+ 0066              ;------------------------------------------------------------------------------
 124+ 0066              ; interrupt routine for NMI
 125+ 0066                              ;$0066
 126+ 0066 C3 9F 53                     jp      NMIUSR              ; jump to execute NMI service routine
 127+ 0069 FF FF FF...                  BLOCK   $27,$FF ; filler
 128+ 0090              ;------------------------------------------------------------------------------
 129+ 0090
 130+ 0090                              ;$0090
 131+ 0090 4C 4D 38 30                  defb    $4C,$4D,$38,$30,$43,$20,$36,$34
 131+ 0094 43 20 36 34
 132+ 0098 4B 20 43 4F                  defb    $4B,$20,$43,$4F,$4C,$4F,$52,$00
 132+ 009C 4C 4F 52 00
 133+ 00A0 43 4F 4D 50                  defb    $43,$4F,$4D,$50,$55,$54,$45,$52
 133+ 00A4 55 54 45 52
 134+ 00A8 20 28 32 30                  defb    $20,$28,$32,$30,$32,$31,$29,$00
 134+ 00AC 32 31 29 00
 135+ 00B0 44 65 73 69                  defb    $44,$65,$73,$69,$67,$6E,$65,$64
 135+ 00B4 67 6E 65 64
 136+ 00B8 20 62 79 00                  defb    $20,$62,$79,$00,$00,$00,$00,$00
 136+ 00BC 00 00 00 00
 137+ 00C0 4C 65 6F 6E                  defb    $4C,$65,$6F,$6E,$61,$72,$64,$6F
 137+ 00C4 61 72 64 6F
 138+ 00C8 20 4D 69 6C                  defb    $20,$4D,$69,$6C,$69,$61,$6E,$69
 138+ 00CC 69 61 6E 69
 139+ 00D0 46 57 20 31  FWVER:          defm    "FW ","1.15",$20,"2021-03-19",$20,"13:08:13",$00
 139+ 00D4 2E 31 35 20
 139+ 00D8 32 30 32 31
 139+ 00DC 2D 30 33 2D
 139+ 00E0 31 39 20 31
 139+ 00E4 33 3A 30 38
 139+ 00E8 3A 31 33 00
 140+ 00EC              FMVEREND:       equ     $
 141+ 00EC FF FF FF...                  BLOCK   $100-FMVEREND,$FF   ; filler
 142+ 0100              ;------------------------------------------------------------------------------
 143+ 0100
 144+ 0100              ;-------------------------------------------------------------------------------
 145+ 0100              ;               Z80 SIO CH. A MANAGEMENT
 146+ 0100              ;-------------------------------------------------------------------------------
 147+ 0100
 148+ 0100              ;-------------------------------------------------------------------------------
 149+ 0100              ; interrupt driven routine to get chars from Z80 SIO ch.A
 150+ 0100              ; this is the only serial channel that can print received chars onto the screen
 151+ 0100                              ;$0100
 152+ 0100 F5           RX_CHA_AVAIL:   push    AF              ; store A
 153+ 0101 E5                           push    HL              ; and HL
 154+ 0102 CD 8F 01                     call    A_RTS_OFF       ; disable RTS line
 155+ 0105 DB 20                        in      A,(SIO_DA)      ; read char from RX buffer into A
 156+ 0107 32 7C 55                     ld      (TMPKEYBFR),A   ; store it into the temp key buffer
 157+ 010A CD FD 01                     call    CHARINTOBFR     ; sub-routine to put the char into the input buffer
 158+ 010D D2 31 01                     jp      NC,LVRXCHA      ; if buffer is full, then leave without doing anything else
 159+ 0110 3A 7C 55                     ld      A,(TMPKEYBFR)   ; retrieve char
 160+ 0113 32 3D 55                     ld      (CHR4VID),A     ; write into buffer for video printing
 161+ 0116 FE 0D                        cp      CR              ; is it RETURN?
 162+ 0118 CA 20 01                     jp      Z,CNTRXCHA      ; yes, continue
 163+ 011B FE 20                        cp      $20             ; is it another control char (code < 32)?
 164+ 011D DA 31 01                     jp      C,LVRXCHA       ; yes, leave w/o printing it on video nor sending back to serial
 165+ 0120 F5           CNTRXCHA:       push    AF              ; store char
 166+ 0121 AF                           xor     A
 167+ 0122 32 7A 55                     ld      (KBDNPT),A      ; a char from serial is like a char printed by BASIC
 168+ 0125 3A 3C 55                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 169+ 0128 FE 01                        cp      $01             ; is the print on video on?
 170+ 012A CC 5A 07                     call    Z,CHAR2VID      ; yes, print on screen
 171+ 012D F1                           pop     AF              ; retrieve char
 172+ 012E CD 59 02                     call    TXA             ; send back to serial
 173+ 0131 E1           LVRXCHA:        pop     HL              ; retrieve HL
 174+ 0132 F1                           pop     AF              ; and A
 175+ 0133 FB                           ei                      ; re-enable interrupts
 176+ 0134 ED 4D                        reti                    ; and exit
 177+ 0136
 178+ 0136              ;-------------------------------------------------------------------------------
 179+ 0136              ; special SIO ch.A condition (i.e., buffer overrun)
 180+ 0136              ; if buffer overruns then show an error, empty the RX buffer and send
 181+ 0136              ; a break char
 182+ 0136 F5           SPEC_RXA_CNDT:  push    AF              ; store AF
 183+ 0137 CD 8F 01                     call    A_RTS_OFF       ; disable RTS
 184+ 013A CD CB 01                     call    SIO_A_DI        ; disable RX on ch. A
 185+ 013D 3A 82 55                     ld      A,(SERIALS_EN)  ; load serial status
 186+ 0140 CB 97                        res     2,A             ; disable RX on port 1
 187+ 0142 32 82 55                     ld      (SERIALS_EN),A  ; store new serial status
 188+ 0145 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 189+ 0147 CB E7                        set     4,A             ; set 5th pin ON
 190+ 0149 D3 01                        out     (PIO_DB),A      ; send new setting
 191+ 014B 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 192+ 014D D3 22                        out     (SIO_CA),A      ; send command to SIO
 193+ 014F AF           EMPTYCHABFR:    xor     A
 194+ 0150 D3 22                        out     (SIO_CA),A      ; write to WR0, select RR0
 195+ 0152 DB 22                        in      A,(SIO_CA)      ; read RR0 register
 196+ 0154 E6 01                        and     $01             ; check if input buffer if empty
 197+ 0156 CA 5D 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then leave
 198+ 0159 DB 20                        in      A,(SIO_DA)      ; read chars
 199+ 015B 18 F2                        jr      EMPTYCHABFR     ; repeat
 200+ 015D F1           CHABFREMPTY:    pop     AF              ; retrieve AF
 201+ 015E 21 3C 3E                     ld      HL,SOERR        ; return point set to Serial Buffer Overrun routine
 202+ 0161 E3                           ex      (SP),HL         ; store onto stack
 203+ 0162 FB                           ei                      ; re-enable interrupts
 204+ 0163 ED 4D                        reti                    ; return from interrupt and execute code at SOERR
 205+ 0165
 206+ 0165              ;-------------------------------------------------------------------------------
 207+ 0165              ;               Z80 SIO CH. A MANAGEMENT
 208+ 0165              ;-------------------------------------------------------------------------------
 209+ 0165
 210+ 0165              ;-------------------------------------------------------------------------------
 211+ 0165              ; interrupt driven routine to get chars from Z80 SIO ch.B
 212+ 0165 FB           RX_CHB_AVAIL:   ei
 213+ 0166 ED 4D                        reti
 214+ 0168
 215+ 0168              ;-------------------------------------------------------------------------------
 216+ 0168              ; special SIO ch.A condition (i.e., buffer overrun)
 217+ 0168              ; if buffer overruns then show an error, empty the RX buffer and send
 218+ 0168              ; a break char
 219+ 0168 F5           SPEC_RXB_CNDT:  push    AF              ; store A
 220+ 0169 CD 97 01                     call    B_RTS_OFF       ; disable RTS
 221+ 016C CD D3 01                     call    SIO_B_DI        ; disable RX on ch.B
 222+ 016F 3A 82 55                     ld      A,(SERIALS_EN)  ; load serial status
 223+ 0172 CB 9F                        res     3,A             ; disable RX on port 2
 224+ 0174 32 82 55                     ld      (SERIALS_EN),A  ; store new serial status
 225+ 0177 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 226+ 0179 CB EF                        set     5,A             ; set 5th pin ON
 227+ 017B D3 01                        out     (PIO_DB),A      ; send new setting
 228+ 017D 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 229+ 017F D3 23                        out     (SIO_CB),A      ; send command to SIO
 230+ 0181 AF           EMPTYCHBBFR:    xor     A
 231+ 0182 D3 23                        out     (SIO_CB),A      ; write to WR0, select RR0
 232+ 0184 DB 23                        in      A,(SIO_CB)      ; read RR0 register
 233+ 0186 E6 01                        and     $01             ; check if input buffer if empty
 234+ 0188 CA 5D 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then jump to run "exit" code
 235+ 018B DB 21                        in      A,(SIO_DB)      ; read chars
 236+ 018D 18 F2                        jr      EMPTYCHBBFR     ; repeat
 237+ 018F
 238+ 018F
 239+ 018F              ;-------------------------------------------------------------------------------
 240+ 018F              ;               Z80 SIO MANAGEMENT
 241+ 018F              ;-------------------------------------------------------------------------------
 242+ 018F              ; disable RTS:
 243+ 018F              ; by resetting RTS bit (set to 0), the RTS line is disabled (HIGH)
 244+ 018F C5           A_RTS_OFF:      push    BC              ; store BC
 245+ 0190 0E 22                        ld      C,SIO_CA        ; select channel A
 246+ 0192 3A 83 55                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 247+ 0195 18 06                        jr      SIO_RTS_OFF
 248+ 0197 C5           B_RTS_OFF:      push    BC              ; store BC
 249+ 0198 0E 23                        ld      C,SIO_CB        ; select channel B
 250+ 019A 3A 84 55                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 251+ 019D CB 3F        SIO_RTS_OFF:    srl     A               ; position data bits in bits #5&6
 252+ 019F E6 60                        and     %01100000       ; get only bits #5&6
 253+ 01A1 47                           ld      B,A             ; store data bits
 254+ 01A2 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 255+ 01A4 ED 79                        out     (C),A
 256+ 01A6 3E 88                        ld      A,%10001000     ; enable DTR (b7) and TX (b4), disable RTS (b1)
 257+ 01A8 B0                           or      B               ; set data bits
 258+ 01A9 ED 79                        out     (C),A           ; send setting
 259+ 01AB C1                           pop     BC              ; retrieve BC
 260+ 01AC C9                           ret                     ; exit
 261+ 01AD
 262+ 01AD              ;-------------------------------------------------------------------------------
 263+ 01AD              ; enable RTS
 264+ 01AD              ; by setting RTS bit (set to 1), the RTS line is enabled (LOW)
 265+ 01AD C5           A_RTS_ON:       push    BC              ; store BC
 266+ 01AE 0E 22                        ld      C,SIO_CA        ; select channel A
 267+ 01B0 3A 83 55                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 268+ 01B3 18 06                        jr      SIO_RTS_ON
 269+ 01B5 C5           B_RTS_ON:       push    BC              ; store BC
 270+ 01B6 0E 23                        ld      C,SIO_CB        ; select channel B
 271+ 01B8 3A 84 55                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 272+ 01BB CB 3F        SIO_RTS_ON:     srl     A               ; position data bits in bits #5&6
 273+ 01BD E6 60                        and     %01100000       ; get only bits #5&6
 274+ 01BF 47                           ld      B,A             ; store data bits
 275+ 01C0 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 276+ 01C2 ED 79                        out     (C),A
 277+ 01C4 3E 8A                        ld      A,%10001010     ; enable DTR (b7), TX (b4), and RTS (b1)
 278+ 01C6 B0                           or      B               ; set data bits
 279+ 01C7 ED 79                        out     (C),A           ; send setting
 280+ 01C9 C1                           pop     BC              ; retrieve BC
 281+ 01CA C9                           ret                     ; return
 282+ 01CB
 283+ 01CB              ;-------------------------------------------------------------------------------
 284+ 01CB              ; disable SIO RX channel
 285+ 01CB C5           SIO_A_DI:       push    BC              ; store BC
 286+ 01CC 0E 22                        ld      C,SIO_CA        ; SIO channel A
 287+ 01CE 3A 83 55                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 288+ 01D1 18 06                        jr      SIO_RXDI        ; jump to disable RX
 289+ 01D3 C5           SIO_B_DI:       push    BC              ; store BC
 290+ 01D4 0E 23                        ld      C,SIO_CB        ; SIO channel B
 291+ 01D6 3A 84 55                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 292+ 01D9 47           SIO_RXDI:       ld      B,A             ; store data bits
 293+ 01DA 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 294+ 01DC ED 79                        out     (C),A
 295+ 01DE 78                           ld      A,B             ; retrieve data bits; RX disabled; auto enable is OFF
 296+ 01DF ED 79                        out     (C),A
 297+ 01E1 C1                           pop     BC              ; retrieve BC
 298+ 01E2 C9                           ret                     ; return
 299+ 01E3
 300+ 01E3              ;-------------------------------------------------------------------------------
 301+ 01E3              ; enable SIO RX channel
 302+ 01E3 C5           SIO_A_EI:       push    BC              ; store BC
 303+ 01E4 0E 22                        ld      C,SIO_CA
 304+ 01E6 3A 83 55                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 305+ 01E9 18 06                        jr      SIO_RXEN
 306+ 01EB C5           SIO_B_EI:       push    BC              ; store BC
 307+ 01EC 0E 23                        ld      C,SIO_CB
 308+ 01EE 3A 84 55                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 309+ 01F1 47           SIO_RXEN:       ld      B,A             ; store data bits
 310+ 01F2 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 311+ 01F4 ED 79                        out     (C),A           ; select register
 312+ 01F6 78                           ld      A,B             ; retrieve data bits
 313+ 01F7 CB C7                        set     0,A             ; set RX enabled; auto enable is OFF
 314+ 01F9 ED 79                        out     (C),A           ; send settings to SIO
 315+ 01FB C1                           pop     BC              ; retrieve BC
 316+ 01FC C9                           ret
 317+ 01FD
 318+ 01FD              ;------------------------------------------------------------------------------
 319+ 01FD              ; put a char into the input buffer, char is into A
 320+ 01FD              ; this sub is called both from the ISR "RX_CHA_AVAIL" and when
 321+ 01FD              ; the RETURN key is pressed on the keyboard
 322+ 01FD F5           CHARINTOBFR:    push    AF              ; store it
 323+ 01FE 3A 9A 53                     ld      A,(serBufUsed)  ; load buffer size
 324+ 0201 FE 58                        cp      SER_BUFSIZE     ; if buffer is not full
 325+ 0203 DA 08 02                     jp      C,NOTFULL       ; then store the char
 326+ 0206 F1                           pop     AF              ; else drop it
 327+ 0207 C9                           ret                     ; and exit
 328+ 0208 2A 96 53     NOTFULL:        ld      HL,(serInPtr)   ; buffer is not full, can store the char
 329+ 020B 23                           inc     HL              ; load pointer to find first free cell
 330+ 020C 7D                           ld      A,L             ; only check low byte because buffer<256
 331+ 020D FE 96                        cp      bufWrap         ; check if the pointer is at the last cell
 332+ 020F 20 03                        jr      NZ,NOTWRAP      ; if not then continue
 333+ 0211 21 3E 53                     ld      HL,SERBUF_START ; else load the address of the first cell
 334+ 0214 22 96 53     NOTWRAP:        ld      (serInPtr),HL   ; store the new pointer
 335+ 0217 F1                           pop     AF              ; then retrieve the char...
 336+ 0218 77                           ld      (HL),A          ; ...and store it in the appropriate cell
 337+ 0219 21 9A 53                     ld      HL,serBufUsed   ; size of the input buffer
 338+ 021C 34                           inc     (HL)            ; increment it
 339+ 021D 3E 50                        ld      A,SER_FULLSIZE  ; input buffer capacity
 340+ 021F BE                           cp      (HL)            ; check if input buffer is full
 341+ 0220 D8                           ret     C               ; exit if buffer is not full
 342+ 0221 3A 82 55                     ld      A,(SERIALS_EN)  ; check if serial 1 is open
 343+ 0224 1F                           rra                     ; bit 0 into Carry: if Carry is 1 then serial 0 is open and...
 344+ 0225 DC 8F 01                     call    C,A_RTS_OFF     ; ...receiving further chars must be stopped
 345+ 0228 37                           scf                     ; set Carry flag, because  we must inform that the char has been added before to disable RTS
 346+ 0229 C9                           ret
 347+ 022A
 348+ 022A
 349+ 022A              ;-------------------------------------------------------------------------------
 350+ 022A              ; retrieve a char from the input buffer
 351+ 022A 3A 9A 53     RXA:            ld      A,(serBufUsed)  ; load the buffer size
 352+ 022D A7                           and     A               ; check if it's 0 (empty)
 353+ 022E CA 2A 02                     jp      Z,RXA           ; if it's empty, wait for a char
 354+ 0231 F3                           di                      ; disable interrupts
 355+ 0232 E5                           push    HL              ; store HL
 356+ 0233 2A 98 53                     ld      HL,(serRdPtr)   ; load pointer to first available char
 357+ 0236 23                           inc     HL              ; increment it (go to the next char)
 358+ 0237 7D                           ld      A,L             ; check if the end of the buffer has been reached
 359+ 0238 FE 96                        cp      bufWrap         ; (only check low byte because buffer<256)
 360+ 023A 20 03                        jr      NZ,NOTRDWRAP    ; if not, jump straight
 361+ 023C 21 3E 53                     ld      HL,SERBUF_START ; else reload the starting address of the buffer
 362+ 023F 22 98 53     NOTRDWRAP:      ld      (serRdPtr),HL   ; store new pointer to the next char to read
 363+ 0242 3A 9A 53                     ld      A,(serBufUsed)  ; load buffer size
 364+ 0245 3D                           dec     A               ; decrement it
 365+ 0246 32 9A 53                     ld      (serBufUsed),A  ; and store the new size
 366+ 0249 FE 05                        cp      SER_EMPTYSIZE   ; check if input buffer can be considered empty
 367+ 024B 30 08                        jr      NC,RXA_EXIT     ; if not empty yet, then exit
 368+ 024D 3A 82 55                     ld      A,(SERIALS_EN)  ; load serial state
 369+ 0250 EE 05                        xor     %00000101       ; check if serial 1 is open and RX enabled
 370+ 0252 CC AD 01                     call    Z,A_RTS_ON      ; yes, set RTS on
 371+ 0255 7E           RXA_EXIT:       ld      A,(HL)          ; recover the char and return it into A
 372+ 0256 E1                           pop     HL              ; retrieve HL
 373+ 0257 FB                           ei                      ; re-enable interrupts
 374+ 0258 C9                           ret                     ; return
 375+ 0259
 376+ 0259              ;------------------------------------------------------------------------------
 377+ 0259              ; sends a char over the serial - char is into A
 378+ 0259 F5           TXA:            push    AF              ; store AF
 379+ 025A C5                           push    BC              ; store BC
 380+ 025B 47                           ld      B,A             ; store char
 381+ 025C 3A 82 55                     ld      A,(SERIALS_EN)  ; load serial status
 382+ 025F EE 05                        xor     %00000101       ; check if serial 1 is open and RX is enabled
 383+ 0261 20 06                        jr      NZ,TXA_EXIT     ; no, jump over
 384+ 0263 78                           ld      A,B             ; retrieve char
 385+ 0264 D3 20                        out     (SIO_DA),A      ; send char to the SIO
 386+ 0266 CD 6C 02                     call    TX_EMP          ; wait for outgoing char to be sent
 387+ 0269 C1           TXA_EXIT:       pop     BC              ; retrieve BC
 388+ 026A F1                           pop     AF              ; retrieve AF
 389+ 026B C9                           ret                     ; return
 390+ 026C
 391+ 026C              ;------------------------------------------------------------------------------
 392+ 026C              ; wait until outgoing serial has been sent
 393+ 026C 97           TX_EMP:         sub     A               ; set A to 0
 394+ 026D 3C                           inc     A               ; set A to 1
 395+ 026E D3 22                        out     (SIO_CA),A      ; write to WR0, select RR1
 396+ 0270 DB 22                        in      A,(SIO_CA)      ; read RR1 register
 397+ 0272 CB 47                        bit     0,A             ; check if all chars have been sent
 398+ 0274 CA 6C 02                     jp      Z,TX_EMP        ; if not (bit 0 = 0) then retrieve
 399+ 0277 C9                           ret                     ; else exit
 400+ 0278
 401+ 0278
 402+ 0278              ;------------------------------------------------------------------------------
 403+ 0278              ; check if there is some chars into the buffer
 404+ 0278 3A 9A 53     CKINCHAR:       ld      A,(serBufUsed)  ; load buffer size
 405+ 027B A7                           and     A               ; compare to 0
 406+ 027C C9                           ret                     ; return
 407+ 027D
 408+ 027D              ;------------------------------------------------------------------------------
 409+ 027D              ; print a text from memory, and terminate when $00 is found
 410+ 027D 7E           RAWPRINT:       ld      A,(HL)          ; load character from memory cell pointed by HL
 411+ 027E B7                           or      A               ; is it $00 (end string)?
 412+ 027F C8                           ret     Z               ; Yes, then return
 413+ 0280 32 3D 55                     ld      (CHR4VID),A     ; store char
 414+ 0283 F3                           di
 415+ 0284 CD 5A 07                     call    CHAR2VID        ; and send it to screen
 416+ 0287 FB                           ei
 417+ 0288 23                           inc     HL              ; and select the next one
 418+ 0289 18 F2                        jr      RAWPRINT        ; repeat
 419+ 028B
 420+ 028B              ;-------------------------------------------------
 421+ 028B              ; Interrupt service routine (ISR) for CH3 timer
 422+ 028B              ; this is used to increment the 100ths of a second counter and for cursor flashing
 423+ 028B F5           CH3_TIMER:      push    AF              ; save regs. A,
 424+ 028C C5                           push    BC              ; BC,
 425+ 028D D5                           push    DE              ; DE,
 426+ 028E E5                           push    HL              ; HL
 427+ 028F 21 20 55                     ld      HL,TMRCNT       ; load starting address of the timer
 428+ 0292 06 04                        ld      B,$04           ; 4 bytes to check
 429+ 0294 34           INCTMR3:        inc     (HL)            ; increment timer
 430+ 0295 20 03                        jr      NZ,CHKCRSR      ; if not zero then exit (finished increment)
 431+ 0297 23                           inc     HL              ; if yes, there was an overflow, so increment next byte
 432+ 0298 10 FA                        djnz    INCTMR3         ; repeat for 4 bytes
 433+ 029A CD C4 07     CHKCRSR:        call    FLASHCURSOR     ; call the flashing cursor routine
 434+ 029D CD EC 0C                     call    MNGSNDS         ; call the tone managemenet
 435+ 02A0 3A 20 55                     ld      A,(TMRCNT)      ; check for keyboard management
 436+ 02A3 1F                           rra                     ; bit 0 = 1 ?
 437+ 02A4 D4 51 0D                     call    NC,KEYBOARD     ; no, so read the keyboard inputs
 438+ 02A7 E1                           pop     HL              ; retrieve HL,
 439+ 02A8 D1                           pop     DE              ; DE,
 440+ 02A9 C1                           pop     BC              ; BC,
 441+ 02AA F1                           pop     AF              ; and A
 442+ 02AB FB                           ei                      ; re-enable interrupts
 443+ 02AC ED 4D                        reti                    ; exit from ISR
 444+ 02AE
 445+ 02AE              ;------------------------------------------------------------------------------
 446+ 02AE              ;               HARDWARE INITIALISATION
 447+ 02AE              ;------------------------------------------------------------------------------
 448+ 02AE              ; first run - setup HW & SW
 449+ 02AE              ; (on LN80C 64K runs from RAM)
 450+ 02AE 21 CD 54     INIT_HW:        ld      HL,TEMPSTACK    ; load temp stack pointer
 451+ 02B1 F9           INIT_HW2:       ld      SP,HL           ; set stack to temp stack pointer
 452+ 02B2 21 3E 53                     ld      HL,SERBUF_START ; set beginning of input buffer
 453+ 02B5 22 96 53                     ld      (serInPtr),HL   ; for incoming chars to store into buffer
 454+ 02B8 22 98 53                     ld      (serRdPtr),HL   ; and for chars to be read from buffer
 455+ 02BB AF                           xor     A               ; reset A
 456+ 02BC 32 9A 53                     ld      (serBufUsed),A  ; actual buffer size is 0
 457+ 02BF 32 82 55                     ld      (SERIALS_EN),A  ; set serial ports status to OFF
 458+ 02C2 CD 40 03                     call    initCTC         ; configure CTC, then...
 459+ 02C5 CD 8A 0C                     call    initPSG         ; ...configure PSG
 460+ 02C8 CD F2 04                     call    SHOW_LOGO       ; show computer logo
 461+ 02CB 1E 01                        ld      E,$01           ; E chooses the video mode (graphics 1)
 462+ 02CD CD D1 03                     call    initVDP         ; set video display
 463+ 02D0 AF                           xor     A
 464+ 02D1 ED 47                        ld      I,A             ; set high byte of interrupt vectors to point to page 0
 465+ 02D3 ED 5E                        im      2               ; interrupt mode 2
 466+ 02D5 FB                           ei                      ; enable interrupts
 467+ 02D6                              ; print system messages
 468+ 02D6 AF                           xor     A               ; A=0 so...
 469+ 02D7 32 7A 55                     ld      (KBDNPT),A      ; ...inputs don't come from keyboard
 470+ 02DA 3C                           inc     A               ; A=1...
 471+ 02DB 32 3C 55                     ld      (PRNTVIDEO),A   ; ...to activate the print-on-video
 472+ 02DE 21 76 03                     ld      HL,MSGTXT1      ; sign-on message
 473+ 02E1 CD 7D 02                     call    RAWPRINT        ; print message
 474+ 02E4 3A 9B 53                     ld      A,(basicStarted); check if BASIC is already started
 475+ 02E7 FE 59                        cp      'Y'             ; to see if this is a power-up
 476+ 02E9 20 19                        jr      NZ,COLDSTART    ; if not, then do a COLD start
 477+ 02EB 21 B4 03                     ld      HL,MSGTXT2      ; message to choose kind of start
 478+ 02EE CD 7D 02                     call    RAWPRINT        ; print message
 479+ 02F1 CD 26 09                     call    CURSOR_ON       ; enable cursor
 480+ 02F4 AF                           xor     A
 481+ 02F5 32 3C 55                     ld      (PRNTVIDEO),A   ; disable print-on-video
 482+ 02F8 CD 2A 02     CORW:           call    RXA             ; look for a pressed key
 483+ 02FB E6 DF                        and     %11011111       ; only UPPERCASE char
 484+ 02FD FE 43                        cp      'C'             ; cold start?
 485+ 02FF 20 0E                        jr      NZ,CHECKWARM    ; no, let's check for warm start
 486+ 0301 CD 1C 03                     call    ECHO_CHAR       ; echoes the char
 487+ 0304 3E 59        COLDSTART:      ld      A,'Y'           ; yes, set the "BASIC started" flag
 488+ 0306 32 9B 53                     ld      (basicStarted),A
 489+ 0309 CD 3B 09                     call    CURSOR_OFF      ; disable cursor
 490+ 030C C3 9F 12                     jp      COLD            ; start BASIC COLD
 491+ 030F FE 57        CHECKWARM:      cp      'W'
 492+ 0311 20 E5                        jr      NZ,CORW         ; char not recognized, wait again
 493+ 0313 CD 1C 03                     call    ECHO_CHAR       ; echoes the char
 494+ 0316 CD 3B 09                     call    CURSOR_OFF      ; disable cursor
 495+ 0319 C3 A2 12                     jp      WARM            ; start BASIC WARM
 496+ 031C
 497+ 031C              ;-------------------------------------------------------------------------------
 498+ 031C              ; send back char received through ch. A
 499+ 031C 32 3D 55     ECHO_CHAR:      ld      (CHR4VID),A     ; set char for video printing
 500+ 031F AF                           xor     A
 501+ 0320 32 7A 55                     ld      (KBDNPT),A      ; input is not from keyboard
 502+ 0323 F3                           di                      ; disable INTs
 503+ 0324 CD 5A 07                     call    CHAR2VID        ; echoes back the pressed key,
 504+ 0327 3E 0D                        ld      A,CR            ; then set a CR
 505+ 0329 32 3D 55                     ld      (CHR4VID),A     ; set char for video printing
 506+ 032C CD 5A 07                     call    CHAR2VID        ; and send it to screen
 507+ 032F FB                           ei                      ; re-enable INTs
 508+ 0330 3E 01                        ld      A,$01
 509+ 0332 32 3C 55                     ld      (PRNTVIDEO),A   ; re-enable video printing
 510+ 0335 C9                           ret                     ; return to caller
 511+ 0336
 512+ 0336
 513+ 0336              ;-------------------------------------------------------------------------------
 514+ 0336              ; Z80 SIO default settings for serial channels
 515+ 0336 30           SIO_A_SETS:     defb    %00110000       ; write into WR0: error reset, select WR0
 516+ 0337 18                           defb    %00011000       ; write into WR0: channel reset
 517+ 0338 04                           defb    %00000100       ; write into WR0: select WR4
 518+ 0339 44                           defb    %01000100       ; write into WR4: presc. 16x, 1 stop bit, no parity
 519+ 033A 05                           defb    %00000101       ; write into WR0: select WR5
 520+ 033B E8                           defb    %11101000       ; write into WR5: DTR on, TX 8 bits, BREAK off, TX on, RTS off
 521+ 033C 01           SIO_B_SETS:     defb    %00000001       ; write into WR0: select WR1
 522+ 033D 04                           defb    %00000100       ; write into WR1: status affects interrupt vectors
 523+ 033E 02                           defb    %00000010       ; write into WR0: select WR2
 524+ 033F 00                           defb    %00000000       ; write into WR2: set interrupt vector, but bits D3/D2/D1 of this vector
 525+ 0340                                                      ; will be affected by the channel & condition that raised the interrupt
 526+ 0340                                                      ; (see datasheet): in our example, 0x0C for Ch.A receiving A char, 0x0E
 527+ 0340                                                      ; for special conditions
 528+ 0340              ;------------------------------------------------------------------------------
 529+ 0340              ;               Z80 CTC SETTING UP
 530+ 0340              ;------------------------------------------------------------------------------
 531+ 0340              initCTC:
 532+ 0340 21 6A 03                     ld      HL,CTCCONF      ; CTC configuration
 533+ 0343 11 24 55                     ld      DE,CTC0IV       ; CTC interrupt vector table
 534+ 0346 01 0C 00                     ld      BC,$000C        ; 12 bytes
 535+ 0349 ED B0                        ldir                    ; copy data
 536+ 034B              ;CH0, CH1, & CH2 disabled
 537+ 034B 3E 03                        ld      A,%00000011     ; interrupt off, timer mode, prescaler=16, don't care ext. TRG edge,
 538+ 034D                                                      ; start timer on loading constant, no time constant follows, software reset, command word
 539+ 034D D3 10                        out     (CTC_CH0),A     ; set CH0
 540+ 034F D3 11                        out     (CTC_CH1),A     ; set CH1
 541+ 0351 D3 12                        out     (CTC_CH2),A     ; set CH2
 542+ 0353              ;init CH3
 543+ 0353              ;CH3 divides CPU CLK by 144*256 providing an interrupt signal at 100 Hz (1/100 sec).
 544+ 0353              ;f = CPU_CLK/(144*256) => 3,686,400 / ( 36,864 ) => 100Hz
 545+ 0353 3E A7                        ld      A,%10100111     ; interrupt on; timer mode; prescaler=256; don't care ext; automatic trigger;
 546+ 0355                                                      ; time constant follows; cont. operation; command word
 547+ 0355 D3 13                        out     (CTC_CH3),A     ; send to CH3
 548+ 0357 3E 90                        ld      A,$90           ; time constant - 90$ (144d)
 549+ 0359 D3 13                        out     (CTC_CH3),A     ; send to CH3
 550+ 035B 3E 40                        ld      A,%01000000     ; D7..D3 provide the first part of the int vector (in our case, $0100), followed by
 551+ 035D                                                      ; D2..D1, provided by the CTC (they point to the channel), D0=interrupt word
 552+ 035D                                                      ; so int vector is 01000xx00
 553+ 035D D3 10                        out     (CTC_CH0),A     ; send to CTC
 554+ 035F                              ; reset cells of 100ths of a second counter
 555+ 035F AF                           xor     A               ; reset A
 556+ 0360 21 20 55                     ld      HL,TMRCNT       ; load TMR pointer
 557+ 0363 06 04                        ld      B,$04           ; 4 memory cells
 558+ 0365 77           RESTMR:         ld      (HL),A          ; reset n-cell of TMR
 559+ 0366 23                           inc     HL              ; next cell
 560+ 0367 10 FC                        djnz    RESTMR          ; repeat for 4 cells
 561+ 0369 C9                           ret
 562+ 036A
 563+ 036A
 564+ 036A              ;------------------------------------------------------------------------------
 565+ 036A              ; jump table for CHx interrupts
 566+ 036A FB ED 4D     CTCCONF:        defb    $FB,$ED,$4D     ; CTC0 interrupt vector (ei; reti)
 567+ 036D FB ED 4D                     defb    $FB,$ED,$4D     ; CTC1 interrupt vector (ei; reti)
 568+ 0370 FB ED 4D                     defb    $FB,$ED,$4D     ; CTC2 interrupt vector (ei; reti)
 569+ 0373 C3 8B 02                     jp      CH3_TIMER       ; CTC3 interrupt vector (jump to execute sys-tick timer)
 570+ 0376
 571+ 0376
 572+ 0376              ;------------------------------------------------------------------------------
 573+ 0376              ; welcome messages
 574+ 0376              MSGTXT1:
 575+ 0376 20 20 20 20                  defm    "    LM80C 64K Color Computer",CR
 575+ 037A 4C 4D 38 30
 575+ 037E 43 20 36 34
 575+ 0382 4B 20 43 6F
 575+ 0386 6C 6F 72 20
 575+ 038A 43 6F 6D 70
 575+ 038E 75 74 65 72
 575+ 0392 0D
 576+ 0393 20 62 79 20                  defm    " by Leonardo Miliani * FW R","1.15",CR,0
 576+ 0397 4C 65 6F 6E
 576+ 039B 61 72 64 6F
 576+ 039F 20 4D 69 6C
 576+ 03A3 69 61 6E 69
 576+ 03A7 20 2A 20 46
 576+ 03AB 57 20 52 31
 576+ 03AF 2E 31 35 0D
 576+ 03B3 00
 577+ 03B4 0D           MSGTXT2:        defb    CR
 578+ 03B5 20 20 20 3C                  defm    "   <C>old or <W>arm start? ",0
 578+ 03B9 43 3E 6F 6C
 578+ 03BD 64 20 6F 72
 578+ 03C1 20 3C 57 3E
 578+ 03C5 61 72 6D 20
 578+ 03C9 73 74 61 72
 578+ 03CD 74 3F 20 00
 579+ 03D1
# file closed: ../include/bootloader/bootloader-1.07.asm
  67  03D1
  68  03D1              ; incude the latest version of the VDP module
  69  03D1                  INCLUDE "../include/vdp/vdp-1.06.asm"
# file opened: ../include/vdp/vdp-1.06.asm
   1+ 03D1              ; ------------------------------------------------------------------------------
   2+ 03D1              ; LM80C - VDP ROUTINES - 1.06
   3+ 03D1              ; ------------------------------------------------------------------------------
   4+ 03D1              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 03D1              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 03D1              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 03D1              ; kind of warranty: you can use them at your own risk.
   8+ 03D1              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 03D1              ; maintain the copyright notices, include this advice and the note to the
  10+ 03D1              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 03D1              ; redistribuite them.
  12+ 03D1              ; https://www.leonardomiliani.com
  13+ 03D1              ;
  14+ 03D1              ; Please support me by visiting the following links:
  15+ 03D1              ; Main project page: https://www.leonardomiliani.com
  16+ 03D1              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 03D1              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 03D1              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 03D1              ; ------------------------------------------------------------------------------
  20+ 03D1              ;
  21+ 03D1              ;------------------------------------------------------------------------------
  22+ 03D1              ; VDP INITIALISATION
  23+ 03D1              ; initialize VDP for a specific graphics mode
  24+ 03D1              ; INPUT: E -> contains the graphics mode:
  25+ 03D1              ; 0=text; 1=graphics 1; 2=graphics 2; 3=multicolor; 4=extended graphics 2
  26+ 03D1 D5           initVDP:        push    DE              ; store E
  27+ 03D2 CD C8 0A                     call    EMPTY_VRAM      ; reset VRAM
  28+ 03D5 CD E6 0A                     call    SET_GFX_MODE    ; load register settings
  29+ 03D8 CD DB 0A                     call    CLR_RAM_REG     ; reset RAM registers
  30+ 03DB D1                           pop     DE              ; restore reg. E
  31+ 03DC AF                           xor     A               ; reset A
  32+ 03DD 47                           ld      B,A             ; reset B (will be used later)
  33+ 03DE 7B                           ld      A,E             ; move E into A
  34+ 03DF 32 32 55                     ld      (SCR_MODE),A    ; store screen mode
  35+ 03E2 FE 01                        cp      $01             ; is it graphics 1 (A=1)?
  36+ 03E4 CA 20 04                     jp      Z,G1MD          ; yes, jump over
  37+ 03E7 FE 02                        cp      $02             ; is it graphics 2 (A=2)?
  38+ 03E9 CA 60 04                     jp      Z,G2MD          ; yes, jump over
  39+ 03EC FE 03                        cp      $03             ; is it multicolor (A=3)?
  40+ 03EE CA 82 04                     jp      Z,MCMD          ; yes, jump over
  41+ 03F1 FE 04                        cp      $04             ; is it extended graphics 2 (A=4)?
  42+ 03F3 CA A5 04                     jp      Z,EXG2MD        ; yes, jump over
  43+ 03F6                              ; otherwise, it must be $00 so we assume that it's text mode
  44+ 03F6
  45+ 03F6              ; LOAD VDP SETTINGS FOR SELECTED VIDEO MODE:
  46+ 03F6
  47+ 03F6                              ; TEXT MODE (G0)
  48+ 03F6                              ; load charset
  49+ 03F6 60           TXTMD:          ld      H,B
  50+ 03F7 68                           ld      L,B             ; HL=first pattern cell $0000
  51+ 03F8 CD 02 0B                     call    LOADCHARSET     ; load patterns into VRAM
  52+ 03FB                              ; set cursor & video overlay
  53+ 03FB AF                           xor     A               ; reset A
  54+ 03FC 32 35 55                     ld      (SCR_CURS_X),A  ; set cursor position at X=0
  55+ 03FF 32 36 55                     ld      (SCR_CURS_Y),A  ; and Y=0
  56+ 0402 3E 05                        ld      A,$05           ; light blue
  57+ 0404 32 3F 55                     ld      (BKGNDCLR),A    ; set background/border color
  58+ 0407 3E 28                        ld      A,$28
  59+ 0409 32 30 55                     ld      (SCR_SIZE_W),A  ; screen width = 40 cols
  60+ 040C 3E 18                        ld      A,$18
  61+ 040E 32 31 55                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  62+ 0411 3E 1E                        ld      A,$1E
  63+ 0413 32 E1 53                     ld      (COMMAN),A      ; width for commas (4 columns)
  64+ 0416 11 00 08                     ld      DE,$0800
  65+ 0419 ED 53 33 55                  ld      (SCR_NAM_TB),DE ; set name table address
  66+ 041D C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
  67+ 0420
  68+ 0420                              ; GRAPHICS 1 MODE (G1)
  69+ 0420                              ; load pattern table
  70+ 0420 68           G1MD:           ld      L,B
  71+ 0421 60                           ld      H,B             ; HL=first pattern cell $0000
  72+ 0422 CD 02 0B                     call    LOADCHARSET     ; load patterns into VRAM
  73+ 0425                              ; set cursor & video overlay
  74+ 0425 AF                           xor     A               ; position cursor
  75+ 0426 32 35 55                     ld      (SCR_CURS_X),A  ; at X=0
  76+ 0429 32 36 55                     ld      (SCR_CURS_Y),A  ; and Y=0
  77+ 042C 3E 20                        ld      A,$20
  78+ 042E 32 30 55                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
  79+ 0431 3E 18                        ld      A,$18
  80+ 0433 32 31 55                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  81+ 0436 3E 14                        ld      A,$14
  82+ 0438 32 E1 53                     ld      (COMMAN),A      ; width for commas (3 columns)
  83+ 043B 11 00 18                     ld      DE,$1800
  84+ 043E ED 53 33 55                  ld      (SCR_NAM_TB),DE ; set name table address
  85+ 0442                              ; load color table
  86+ 0442 21 00 20                     ld      HL,$2000        ; color table start: $2000
  87+ 0445 CD 69 06                     call    SETVDPADRS
  88+ 0448 3E 01                        ld      A,$01           ; foreground color...
  89+ 044A 32 3E 55                     ld      (FRGNDCLR),A    ; ...set to black
  90+ 044D 3E 0F                        ld      A,$0F           ; background color...
  91+ 044F 32 3F 55                     ld      (BKGNDCLR),A    ; ...set to white
  92+ 0452 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
  93+ 0454 06 20                        ld      B,$20           ; 32 bytes of colors
  94+ 0456 0D                           dec     C               ; VDP data mode
  95+ 0457 ED 79        LDCLRTBMD1:     out     (C),A           ; after the first byte, the VDP autoincrements VRAM pointer
  96+ 0459 00                           nop
  97+ 045A 00                           nop
  98+ 045B 10 FA                        djnz    LDCLRTBMD1      ; repeat for 32 bytes
  99+ 045D C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 100+ 0460
 101+ 0460                              ; GRAPHICS 2 MODE (G2)
 102+ 0460 AF           G2MD:           xor     A               ; position cursor
 103+ 0461 32 35 55                     ld      (SCR_CURS_X),A  ; at X=0
 104+ 0464 32 36 55                     ld      (SCR_CURS_Y),A  ; and Y=0
 105+ 0467 32 30 55                     ld      (SCR_SIZE_W),A  ; screen width = 256 pixels (0=256)
 106+ 046A 3C                           inc     A               ; black on...
 107+ 046B 32 3E 55                     ld      (FRGNDCLR),A    ; ...foreground
 108+ 046E 3E 0F                        ld      A,$0F           ; white on...
 109+ 0470 32 3F 55                     ld      (BKGNDCLR),A    ; ...background
 110+ 0473 3E C0                        ld      A,$C0
 111+ 0475 32 31 55                     ld      (SCR_SIZE_H),A  ; screen height = 192 pixels
 112+ 0478 11 00 18                     ld      DE,$1800
 113+ 047B ED 53 33 55                  ld      (SCR_NAM_TB),DE ; set name table address
 114+ 047F C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 115+ 0482
 116+ 0482                              ; MULTICOLOR MODE (G3)
 117+ 0482 AF           MCMD:           xor     A               ; position cursor
 118+ 0483 32 35 55                     ld      (SCR_CURS_X),A  ; at X=0
 119+ 0486 32 36 55                     ld      (SCR_CURS_Y),A  ; and Y=0
 120+ 0489 3E 0F                        ld      A,$0F           ; white color for...
 121+ 048B 32 3F 55                     ld      (BKGNDCLR),A    ; ...background and...
 122+ 048E 32 3E 55                     ld      (FRGNDCLR),A    ; ...foreground (even this is not used in MC)
 123+ 0491 3E 40                        ld      A,$40
 124+ 0493 32 30 55                     ld      (SCR_SIZE_W),A  ; screen width = 64 blocks
 125+ 0496 3E 30                        ld      A,$30
 126+ 0498 32 31 55                     ld      (SCR_SIZE_H),A  ; screen height = 48 blocks
 127+ 049B 11 00 08                     ld      DE,$0800
 128+ 049E ED 53 33 55                  ld      (SCR_NAM_TB),DE ; set name table address
 129+ 04A2 C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 130+ 04A5
 131+ 04A5                              ; EXTENDED GRAPHICS 2 (G4)
 132+ 04A5              EXG2MD:         ; load pattern table
 133+ 04A5 60                           ld      H,B
 134+ 04A6 68                           ld      L,B             ; HL=first pattern cell $0000
 135+ 04A7 CD 02 0B                     call    LOADCHARSET     ; load patterns into VRAM
 136+ 04AA                              ; set cursor & video overlay
 137+ 04AA AF                           xor     A               ; position cursor
 138+ 04AB 32 35 55                     ld      (SCR_CURS_X),A  ; at X=0
 139+ 04AE 32 36 55                     ld      (SCR_CURS_Y),A  ; and Y=0
 140+ 04B1 3E 20                        ld      A,$20
 141+ 04B3 32 30 55                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
 142+ 04B6 3E 18                        ld      A,$18
 143+ 04B8 32 31 55                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
 144+ 04BB 3E 14                        ld      A,$14
 145+ 04BD 32 E1 53                     ld      (COMMAN),A      ; width for commas (3 columns)
 146+ 04C0 11 00 38                     ld      DE,$3800
 147+ 04C3 ED 53 33 55                  ld      (SCR_NAM_TB),DE ; set name table address
 148+ 04C7                               ; load color table
 149+ 04C7 21 00 20                     ld      HL,$2000        ; color table start: $2000
 150+ 04CA CD 69 06                     call    SETVDPADRS
 151+ 04CD 3E 01                        ld      A,$01           ; foreground color is...
 152+ 04CF 32 3E 55                     ld      (FRGNDCLR),A    ; ...set to black
 153+ 04D2 3E 0F                        ld      A,$0F           ; whitefor...
 154+ 04D4 32 3F 55                     ld      (BKGNDCLR),A    ; ...background
 155+ 04D7 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
 156+ 04D9 16 08                        ld      D,$08           ; 8 pages of
 157+ 04DB 06 00                        ld      B,$00           ; 256 bytes of colors (total of 2,048 cells)
 158+ 04DD 0D                           dec     C               ; VDP data mode
 159+ 04DE ED 79        LDCLRTBEX2:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
 160+ 04E0 00                           nop
 161+ 04E1 00                           nop
 162+ 04E2 10 FA                        djnz    LDCLRTBEX2      ; repeat for 256 bytes
 163+ 04E4 15                           dec     D               ; did we fill up all the cells?
 164+ 04E5 20 F7                        jr      NZ,LDCLRTBEX2   ; no, repeat
 165+ 04E7                              ; LAST VDP SETTINGS
 166+ 04E7 CD 3B 09     ENDVDPSET:      call    CURSOR_OFF      ; disable cursor
 167+ 04EA CD DB 05                     call    EMPTYVIDBUF     ; empty video buffer
 168+ 04ED AF                           xor     A
 169+ 04EE 32 39 55                     ld      (SCR_ORG_CHR),A ; store byte used tochar used to empty the video buffer
 170+ 04F1 C9                           ret                     ; return to caller
 171+ 04F2
 172+ 04F2
 173+ 04F2              ; show initial logo
 174+ 04F2 CD C8 0A     SHOW_LOGO:      call    EMPTY_VRAM      ; reset VRAM
 175+ 04F5                              ; set VDP for G2 mode
 176+ 04F5 06 07                        ld      B,$07           ; set only the first 7 registers
 177+ 04F7 11 10 00                     ld      DE,$0010        ; load settings for G2 mode
 178+ 04FA CD EE 0A                     call    SET_GFX_MODE2   ; load register settings
 179+ 04FD 16 01                        ld      D,$01           ; backdrop color set to black
 180+ 04FF ED 51                        out     (C),D           ; send data to VDP
 181+ 0501 ED 79                        out     (C),A           ; indicate the register to send data to
 182+ 0503                              ; set name table
 183+ 0503 21 00 18                     ld      HL,$1800        ; name table address
 184+ 0506 CD 57 06                     call    SETNAMETABLE    ; set name table (load names into table)
 185+ 0509 CD 6C 05                     call    ERASECLRTBL     ; erase color table (set foreground & background to black)
 186+ 050C                              ; set colors for logo
 187+ 050C 21 00 28                     ld      HL,$2800        ; 2nd page of color table
 188+ 050F CD 69 06                     call    SETVDPADRS
 189+ 0512 06 05                        ld      B,$05           ; 5 bands
 190+ 0514 21 B7 05                     ld      HL,CLRTABLE
 191+ 0517 0D                           dec     C               ; set VDP_DAT
 192+ 0518 1E 08                        ld      E,$08           ; 8 pixels each pattern
 193+ 051A 16 40        RPT101:         ld      D,$40           ; 64 chars each band
 194+ 051C 7E                           ld      A,(HL)          ; load data
 195+ 051D ED 79        RPT102:         out     (C),A           ; send it to VRAM
 196+ 051F 00                           nop                     ; little delay
 197+ 0520 1D                           dec     E               ; decrement counter
 198+ 0521 20 FA                        jr      NZ,RPT102       ; repeat until zero
 199+ 0523 1E 08                        ld      E,$08           ; 8 pixels each pattern
 200+ 0525 15                           dec     D               ; decrement char band counter
 201+ 0526 20 F5                        jr      NZ,RPT102       ; repeat until zero
 202+ 0528 23                           inc     HL              ; next pattern
 203+ 0529 10 EF                        djnz    RPT101          ; repeat until covered every band
 204+ 052B                              ; set pattern table
 205+ 052B 21 00 08                     ld      HL,$0800        ; address of first cell of 2nd area of pattern table
 206+ 052E 11 4A 0B                     ld      DE,LM80CLOGO    ; pointer to logo pattern
 207+ 0531 06 00                        ld      B,$00           ; 256 bytes, 8 rows
 208+ 0533 CD 97 05     RPT103:         call    LOADLOGOCHRS
 209+ 0536 13                           inc     DE              ; next logo pattern
 210+ 0537 10 FA                        djnz    RPT103
 211+ 0539 06 20                        ld      B,$20           ; repeat for another 2 rows
 212+ 053B CD 97 05     RPT104:         call    LOADLOGOCHRS
 213+ 053E 13                           inc     DE              ; next logo pattern
 214+ 053F 10 FA                        djnz    RPT104
 215+ 0541                              ; show logo/message, play a beep, check for CTRL pressing (to disable DOS), and wait a while
 216+ 0541 06 02                        ld      B,$02           ; two times
 217+ 0543 AF                           xor     A               ; reset A
 218+ 0544 57                           ld      D,A             ; 256 times
 219+ 0545 5F                           ld      E,A             ; x 256 times
 220+ 0546 32 40 55                     ld      (TMPBFR1),A     ; sound flag set to 0
 221+ 0549 3C                           inc     A               ; by default, I/O DOS buffer is enabled
 222+ 054A 32 85 55                     ld      (DOS_EN),A      ; DOS enabled
 223+ 054D 00           DEC_D:          nop                     ; does nothing...
 224+ 054E 00                           nop
 225+ 054F 00                           nop
 226+ 0550 00                           nop
 227+ 0551 00                           nop
 228+ 0552 00                           nop                     ; ...until here
 229+ 0553 1D                           dec     E               ; decrement E
 230+ 0554 20 F7                        jr      NZ,DEC_D        ; repeat until $00
 231+ 0556 7A                           ld      A,D
 232+ 0557 FE 40                        cp      $40             ; ...equal to 64
 233+ 0559 CC 83 05                     call    Z,SETBEEP       ; if yes, start sound
 234+ 055C 15                           dec     D
 235+ 055D 20 EE                        jr      NZ,DEC_D        ; repeat
 236+ 055F 3A 40 55                     ld      A,(TMPBFR1)     ; sound state
 237+ 0562 FE 02                        cp      $02             ; check if sound is to be set off
 238+ 0564 C4 8F 05                     call    NZ,BEEPOFF      ; yes
 239+ 0567 CD BC 05                     call    CHKSPCK         ; check if special key (CTRL) has been pressed on keyboard
 240+ 056A                                                      ; on LM80C 64K, you can disabled the I/O DOS buffer
 241+ 056A 10 E1                        djnz    DEC_D           ; repeat
 242+ 056C              ERASECLRTBL:    ; erase color table
 243+ 056C 3E 11                        ld      A,$11           ; foreground and background set to black
 244+ 056E 16 0A                        ld      D,$0A           ; 10 pages
 245+ 0570 06 00                        ld      B,$00           ; 256 color cells per page
 246+ 0572 21 00 28                     ld      HL,$2800        ; first cell of 2nd color table
 247+ 0575 CD 69 06                     call    SETVDPADRS      ; send address
 248+ 0578 0D                           dec     C               ; VDP address for passing data
 249+ 0579 ED 79        RPT100:         out     (C),A           ; send data
 250+ 057B 00                           nop
 251+ 057C 00                           nop                     ; little delay
 252+ 057D 10 FA                        djnz    RPT100          ; repeat for entire page
 253+ 057F 15                           dec     D
 254+ 0580 20 F7                        jr      NZ,RPT100       ; repeat for all the pages ($0A00 cells)
 255+ 0582 C9                           ret                     ; return to caller
 256+ 0583
 257+ 0583              ; play a beep
 258+ 0583 3A 40 55     SETBEEP:        ld      A,(TMPBFR1)     ; check the already-beeped flag
 259+ 0586 B7                           or      A               ; is it 0?
 260+ 0587 C0                           ret     NZ              ; no, exit
 261+ 0588 3C                           inc     A               ; flag to 1
 262+ 0589 32 40 55                     ld      (TMPBFR1),A     ; set sound
 263+ 058C C3 B8 0C                     jp      WLCMBEEP        ; play a beep & return
 264+ 058F
 265+ 058F              ; beep off
 266+ 058F 3E 02        BEEPOFF:        ld      A,$02           ; flag for sound off
 267+ 0591 32 40 55                     ld      (TMPBFR1),A     ; set flag
 268+ 0594 C3 BE 0C                     jp      NOBEEP          ; stop beep and return
 269+ 0597
 270+ 0597
 271+ 0597              ; used to load the chars that will compose the logo of the splash screen
 272+ 0597 1A           LOADLOGOCHRS:   ld      A,(DE)          ; load a pattern char of the logo
 273+ 0598 87                           add     A,A
 274+ 0599 87                           add     A,A
 275+ 059A 87                           add     A,A             ; multiply times 8 to get the offset
 276+ 059B C5                           push    BC
 277+ 059C D5                           push    DE              ; store BC and DE
 278+ 059D E5                           push    HL              ; store VRAM address to write to
 279+ 059E 21 2F 52                     ld      HL,LOGOFONT     ; start of logo font data
 280+ 05A1 5F                           ld      E,A
 281+ 05A2 16 00                        ld      D,$00           ; put offset (A) into DE
 282+ 05A4 19                           add     HL,DE           ; get address of pattern data
 283+ 05A5 EB                           ex      DE,HL           ; move address into DE
 284+ 05A6 E1                           pop     HL              ; retrieve VRAM address
 285+ 05A7 06 08                        ld      B,$08           ; 8 bytes per pattern
 286+ 05A9 CD 69 06                     call    SETVDPADRS      ; set VDP address
 287+ 05AC 0D                           dec     C               ; VDP_DAT
 288+ 05AD 1A           SNDLOGPT:       ld      A,(DE)          ; load data from RAM
 289+ 05AE ED 79                        out     (C),A           ; and send to VRAM
 290+ 05B0 13                           inc     DE              ; next byte into RAM
 291+ 05B1 23                           inc     HL              ; next byte into VRAM (used in future iterations)
 292+ 05B2 10 F9                        djnz    SNDLOGPT        ; repeat 8 times
 293+ 05B4 D1                           pop     DE
 294+ 05B5 C1                           pop     BC              ; retrieve BC & DE
 295+ 05B6 C9                           ret                     ; return to caller
 296+ 05B7              CLRTABLE:       equ $
 297+ 05B7 18 1B 13 14                  defb    $18,$1B,$13,$14,$1D ; colors of background bands of the logo
 297+ 05BB 1D
 298+ 05BC
 299+ 05BC
 300+ 05BC              ; while showing the logo, check if special key (CTRL) is being pressed
 301+ 05BC              ; if yes, then disable DOS functions recovering RAM
 302+ 05BC F5           CHKSPCK:        push    AF
 303+ 05BD 3E FE                        ld      A,%11111110     ; select CTRL row
 304+ 05BF CD 3C 0D                     call    READKBLN        ; read row
 305+ 05C2 CB 5F                        bit     3,A             ; test for RUN/STOP
 306+ 05C4 CA D4 05                     jp      Z,DOCOLDRESET   ; yes, do a cold reset
 307+ 05C7 CB 57                        bit     2,A             ; test if CTRL key is pressed
 308+ 05C9 20 07                        jr      NZ,LVCKSPLK     ; no, leave
 309+ 05CB AF                           xor     A               ; yes, so...
 310+ 05CC 32 85 55                     ld      (DOS_EN),A      ; ...disable DOS
 311+ 05CF 32 9B 53                     ld      (basicStarted),A; reset BASIC warm start
 312+ 05D2 F1           LVCKSPLK:       pop     AF
 313+ 05D3 C9                           ret
 314+ 05D4 AF           DOCOLDRESET:    xor     A               ; reset A
 315+ 05D5 32 9B 53                     ld      (basicStarted),A; reset BASIC warm start
 316+ 05D8 C3 00 00                     jp      $0000           ; restart
 317+ 05DB
 318+ 05DB
 319+ 05DB              ; empty video buffer
 320+ 05DB 3A 32 55     EMPTYVIDBUF:    ld      A,(SCR_MODE)    ; check screen mode
 321+ 05DE FE 02                        cp      $02             ; is it G2 mode?
 322+ 05E0 CA 03 06                     jp      Z,EMPTYG2       ; yes, jump over
 323+ 05E3 FE 03                        cp      $03             ; is it MC mode?
 324+ 05E5 CA 33 06                     jp      Z,EMPTYMC       ; yes, jump over
 325+ 05E8 3A 31 55                     ld      A,(SCR_SIZE_H)  ; load height of screen
 326+ 05EB 47                           ld      B,A             ; move rows into B
 327+ 05EC AF                           xor     A               ; filling char is $00
 328+ 05ED 2A 33 55                     ld      HL,(SCR_NAM_TB) ; load the name table address
 329+ 05F0 CD 69 06                     call    SETVDPADRS      ; send address to VDP
 330+ 05F3 0D                           dec     C               ; VDP address for passing data
 331+ 05F4 5F           LDCOLSTOEMPTY:  ld      E,A             ; store filling char into E
 332+ 05F5 3A 30 55                     ld      A,(SCR_SIZE_W)  ; load # of cols to empty into A
 333+ 05F8 57                           ld      D,A             ; move A into D
 334+ 05F9 7B                           ld      A,E             ; recover filling char
 335+ 05FA ED 79        RPTEMPTYBUF:    out     (C),A           ; write empty byte into VRAM
 336+ 05FC 00                           nop
 337+ 05FD 15                           dec     D               ; decr. D
 338+ 05FE 20 FA                        jr      NZ,RPTEMPTYBUF  ; repeat for the # of cols
 339+ 0600 10 F2                        djnz    LDCOLSTOEMPTY   ; repeat for the # of rows
 340+ 0602 C9                           ret                     ; return to caller
 341+ 0603 2A 33 55     EMPTYG2:        ld      HL,(SCR_NAM_TB) ; yes, additional setup for G2 - load G2 name table address (usually $1800)
 342+ 0606 CD 57 06                     call    SETNAMETABLE    ; set name table
 343+ 0609 21 00 00                     ld      HL,$0000        ; set pattern table
 344+ 060C CD 69 06                     call    SETVDPADRS      ; send address to VDP
 345+ 060F AF                           xor     A               ; empty pattern
 346+ 0610 16 18                        ld      D,$18           ; 6144 ($1800) cell to clean, 24 pages ($18)
 347+ 0612 47                           ld      B,A             ; 256 bytes for page
 348+ 0613 0D                           dec     C               ; VDP data mode
 349+ 0614 ED 79        CLRG2PTNTBL:    out     (C),A           ; clear pattern
 350+ 0616 00                           nop                     ; little delay
 351+ 0617 00                           nop
 352+ 0618 10 FA                        djnz    CLRG2PTNTBL     ; repeat for 1 page
 353+ 061A 15                           dec     D               ; next page
 354+ 061B 20 F7                        jr      NZ,CLRG2PTNTBL  ; repeat
 355+ 061D 21 00 20                     ld      HL,$2000        ; load the color table address
 356+ 0620 CD 69 06                     call    SETVDPADRS      ; send address to VDP
 357+ 0623 3A 3E 55                     ld      A,(FRGNDCLR)    ; load foreground
 358+ 0626 87                           add     A,A
 359+ 0627 87                           add     A,A
 360+ 0628 87                           add     A,A
 361+ 0629 87                           add     A,A             ; move to high nibble
 362+ 062A 57                           ld      D,A             ; store into D
 363+ 062B 3A 3F 55                     ld      A,(BKGNDCLR)    ; load background color
 364+ 062E B2                           or      D               ; combine with background color
 365+ 062F 16 18                        ld      D,$18           ; 6144 ($1800) cells to fill, so 24 pages ($18)
 366+ 0631 18 17                        jr      STARTEMPTY
 367+ 0633 21 00 08     EMPTYMC:        ld      HL,$0800        ; MC name table
 368+ 0636 CD 57 06                     call    SETNAMETABLE    ; set name table
 369+ 0639 21 00 00                     ld      HL,$0000        ; color table address
 370+ 063C CD 69 06                     call    SETVDPADRS      ; send address to VDP
 371+ 063F 3A 3F 55                     ld      A,(BKGNDCLR)    ; load background
 372+ 0642 57                           ld      D,A             ; store into D
 373+ 0643 87                           add     A,A
 374+ 0644 87                           add     A,A
 375+ 0645 87                           add     A,A
 376+ 0646 87                           add     A,A             ; move to high nibble
 377+ 0647 B2                           or      D               ; set background color for high and low nibble
 378+ 0648 16 08                        ld      D,$08           ; 2048 ($0800) cells to fill, so 8 pages ($08)
 379+ 064A 0D           STARTEMPTY:     dec     C               ; VDP address for passing data
 380+ 064B 06 00                        ld      B,$00           ; 256 bytes each page ($00=256)
 381+ 064D ED 79        SNDCLRSET:      out     (C),A           ; send color setting
 382+ 064F 00                           nop                     ; wait a while
 383+ 0650 00                           nop
 384+ 0651 10 FA                        djnz    SNDCLRSET       ; repeat for 1 page
 385+ 0653 15                           dec     D               ; have we filled all the pages?
 386+ 0654 20 F7                        jr      NZ,SNDCLRSET    ; no, repeat
 387+ 0656 C9                           ret                     ; return to caller
 388+ 0657
 389+ 0657              ; set name table for G2 mode (patterns from $00 to $FF for each of the 3 areas of the screen)
 390+ 0657 CD 69 06     SETNAMETABLE:   call    SETVDPADRS      ; send address to VDP
 391+ 065A 0D                           dec     C               ; VDP address for passing data
 392+ 065B 16 03                        ld      D,$03           ; 3 pages to fill into VRAM (768 cells)
 393+ 065D AF                           xor     A               ; starting char name #0 (chars go from 0 to 255)
 394+ 065E 47                           ld      B,A             ; reset B
 395+ 065F ED 79        RPTFLL1:        out     (C),A           ; send name to VRAM
 396+ 0661 00                           nop
 397+ 0662 3C                           inc     A               ; increment # of name
 398+ 0663 10 FA                        djnz    RPTFLL1         ; repeat for 256 cells (1 page)
 399+ 0665 15                           dec     D               ; did we fill all the pages?
 400+ 0666 20 F7                        jr      NZ,RPTFLL1      ; no, continue
 401+ 0668 C9                           ret                     ; return to caller
 402+ 0669
 403+ 0669              ; set an address into VRAM: address is in HL - HL is changed after it
 404+ 0669 0E 31        SETVDPADRS:     ld      C,VDP_SET       ; VDP address mode
 405+ 066B CB F4                        set     6,H             ; set bit #6 of address, to write to VRAM
 406+ 066D ED 69                        out     (C),L           ; send low and...
 407+ 066F ED 61                        out     (C),H           ; ...high byte of the first cell
 408+ 0671 C9                           ret                     ; return to caller
 409+ 0672
 410+ 0672              ; clear the video buffer and position the cursor at 0,0
 411+ 0672 CD DB 05     CLEARVIDBUF:    call    EMPTYVIDBUF     ; clear video buffer
 412+ 0675 AF                           xor     A               ; reset A
 413+ 0676 32 35 55                     ld      (SCR_CURS_X),A  ; cursor X to 0
 414+ 0679 32 36 55                     ld      (SCR_CURS_Y),A  ; cursor Y to 0
 415+ 067C C3 C5 06                     jp      POS_CURSOR      ; position cursor & return to caller
 416+ 067F
 417+ 067F              ; HOME: position the cursor at coords. 0,0
 418+ 067F AF           ATHOME:         xor     A               ; position cursor at 0,0 by storing...
 419+ 0680 32 38 55                     ld      (SCR_CUR_NY),A  ; ...new Y...
 420+ 0683 32 37 55                     ld      (SCR_CUR_NX),A  ; ...and new X
 421+ 0686 C3 CF 06                     jp      MOVCRS          ; move cursor to new location & return to caller
 422+ 0689
 423+ 0689              ; load the char or byte at the VRAM position set by HL
 424+ 0689              ; value is returned into A
 425+ 0689 C5           READ_VIDEO_LOC: push    BC              ; store BC
 426+ 068A 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 427+ 068C 44                           ld      B,H
 428+ 068D CB B8                        res     7,B
 429+ 068F CB B0                        res     6,B
 430+ 0691 ED 69                        out     (C),L           ; low byte then...
 431+ 0693 ED 41                        out     (C),B           ; high byte
 432+ 0695 0D                           dec     C               ; VDP data mode
 433+ 0696 00                           nop                     ; added to compensate shorter instruction
 434+ 0697 00                           nop                     ; wait...
 435+ 0698 00                           nop                     ; ...a while
 436+ 0699 00                           nop
 437+ 069A ED 78                        in      A,(C)           ; read byte at current VRAM location
 438+ 069C C1                           pop     BC              ; restore BC
 439+ 069D C9                           ret                     ; return to caller
 440+ 069E
 441+ 069E              ; write a byte at the VRAM position pointed by HL
 442+ 069E              ; value is in A
 443+ 069E C5           WRITE_VIDEO_LOC:push    BC              ; store BC
 444+ 069F 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 445+ 06A1 44                           ld      B,H             ; copy H into B
 446+ 06A2 CB B8                        res     7,B
 447+ 06A4 CB F0                        set     6,B             ; write to VRAM
 448+ 06A6 ED 69                        out     (C),L           ; low byte then...
 449+ 06A8 ED 41                        out     (C),B           ; high byte of VRAM address
 450+ 06AA 0D                           dec     C               ; VDP data mode
 451+ 06AB 00                           nop                     ; added to compensate shorter instruction
 452+ 06AC 00                           nop                     ; wait...
 453+ 06AD 00                           nop                     ; ...a while
 454+ 06AE 00                           nop
 455+ 06AF ED 79                        out     (C),A           ; write byte into VRAM
 456+ 06B1 C1                           pop     BC              ; restore BC
 457+ 06B2 C9                           ret                     ; return to caller
 458+ 06B3
 459+ 06B3              ; write a value into a specific VDP register
 460+ 06B3              ; value is in E, register is in A
 461+ 06B3 C5           WRITE_VREG:     push    BC              ; store BC
 462+ 06B4 C6 80                        add     A,$80           ; set VDP to write to registers
 463+ 06B6 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 464+ 06B8 ED 59                        out     (C),E           ; send data to VDP
 465+ 06BA ED 79                        out     (C),A           ; select the destination register
 466+ 06BC C1                           pop     BC              ; restore BC
 467+ 06BD C9                           ret                     ; return to caller
 468+ 06BE
 469+ 06BE              ; read VDP status register and return value into A
 470+ 06BE C5           READ_VSTAT:     push    BC              ; store BC
 471+ 06BF 0E 31                        ld      C,VDP_SET       ; VDP register access
 472+ 06C1 ED 78                        in      A,(C)           ; read status register
 473+ 06C3 C1                           pop     BC              ; restore BC
 474+ 06C4 C9                           ret                     ; return to caller
 475+ 06C5
 476+ 06C5              ; position the cursor at the current coordinates, preserving underlying char
 477+ 06C5 CD 08 07     POS_CURSOR:     call    LOAD_CRSR_POS   ; load the VRAM address of cursor into HL
 478+ 06C8 CD 89 06                     call    READ_VIDEO_LOC  ; load the current char at the cursor position (return in A)
 479+ 06CB 32 39 55                     ld      (SCR_ORG_CHR),A ; store the current char
 480+ 06CE C9                           ret
 481+ 06CF
 482+ 06CF              ; move cursor to new X,Y coordinates
 483+ 06CF CD FF 06     MOVCRS:         call    RSTCHRCRS       ; restore the char in the current cursor position
 484+ 06D2 CD EA 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 485+ 06D5 CD C5 06     MOVSHOWCRS:     call    POS_CURSOR      ; position cursor into new location
 486+ 06D8 3A 3A 55                     ld      A,(CRSR_STATE)  ; load status of cursor
 487+ 06DB A7                           and     A               ; is cursor off?
 488+ 06DC C8                           ret     Z               ; yes, return
 489+ 06DD 3A 3B 55                     ld      A,(LSTCSRSTA)   ; it's visible, so...
 490+ 06E0 F6 20                        or      $20             ; ...set cursor on
 491+ 06E2 32 3B 55                     ld      (LSTCSRSTA),A   ; store the last cursor state
 492+ 06E5 3E FF                        ld      A,$FF           ; BTW, set cursor visible after moved it
 493+ 06E7 C3 9E 06                     jp      WRITE_VIDEO_LOC ; write into video cell
 494+ 06EA
 495+ 06EA
 496+ 06EA              ; set new cursor's coordinates
 497+ 06EA 3A 37 55     NEWCRSRCOORD:   ld      A,(SCR_CUR_NX)  ; load new X
 498+ 06ED 32 35 55                     ld      (SCR_CURS_X),A  ; write new X
 499+ 06F0 3A 38 55                     ld      A,(SCR_CUR_NY)  ; load new Y
 500+ 06F3 32 36 55                     ld      (SCR_CURS_Y),A  ; write new Y
 501+ 06F6 3E FF                        ld      A,$FF           ; delete new values
 502+ 06F8 32 37 55                     ld      (SCR_CUR_NX),A  ; of X
 503+ 06FB 32 38 55                     ld      (SCR_CUR_NY),A  ; and Y
 504+ 06FE C9                           ret
 505+ 06FF
 506+ 06FF              ; recover char under the cursor and prints it onto the screen
 507+ 06FF CD 08 07     RSTCHRCRS:      call    LOAD_CRSR_POS   ; recover old cursor position
 508+ 0702 3A 39 55                     ld      A,(SCR_ORG_CHR) ; recover old char
 509+ 0705 C3 9E 06                     jp      WRITE_VIDEO_LOC ; write char into VRAM & return
 510+ 0708
 511+ 0708              ; retrieve cursor position from either current coordinates or next place
 512+ 0708              ; return address position into HL
 513+ 0708 3A 36 55     LOAD_CRSR_POS:  ld      A,(SCR_CURS_Y)  ; load cursor Y
 514+ 070B 6F                           ld      L,A             ; move it into reg.L
 515+ 070C AF                           xor     A               ; reset A
 516+ 070D 67                           ld      H,A             ; reset H
 517+ 070E 47                           ld      B,A             ; reset B
 518+ 070F 29                           add     HL,HL           ; create offset (each address is 2-bytes long so we need to double HL)
 519+ 0710 11 98 0A                     ld      DE,POS_TB_CRS_40; load position table address of cursor for 40 cols
 520+ 0713 3A 30 55                     ld      A,(SCR_SIZE_W)  ; load screen width
 521+ 0716 FE 28                        cp      $28             ; is it 40 cols?
 522+ 0718 28 03                        jr      Z,CONT_POS_CURS ; yes, jump over
 523+ 071A 11 68 0A                     ld      DE,POS_TB_CRS_32; no, load position table address of cursor for 32 cols
 524+ 071D 19           CONT_POS_CURS:  add     HL,DE           ; the correct starting address of the required row is now into HL
 525+ 071E 5E                           ld      E,(HL)          ; load starting address of the required row into DE
 526+ 071F 23                           inc     HL
 527+ 0720 56                           ld      D,(HL)
 528+ 0721 2A 33 55                     ld      HL,(SCR_NAM_TB) ; load starting address of name table
 529+ 0724 19                           add     HL,DE           ; starting address of the current row into name table
 530+ 0725 3A 35 55                     ld      A,(SCR_CURS_X)  ; load cursor X
 531+ 0728 4F                           ld      C,A             ; transfer A into C
 532+ 0729 09                           add     HL,BC           ; add X offset: now HL contains the address of the current cursor position
 533+ 072A C9                           ret
 534+ 072B
 535+ 072B              ; find X,Y coordinates of a screen address pointed in VRAM by HL
 536+ 072B              ; return them into L,A for X,Y
 537+ 072B D5           HL2XY:          push    DE              ; store DE
 538+ 072C ED 5B 33 55                  ld      DE,(SCR_NAM_TB) ; load starting address of name table into DE
 539+ 0730 AF                           xor     A               ; clear Carry
 540+ 0731 ED 52                        sbc     HL,DE           ; find position relative to screen (from 0,0)
 541+ 0733 D1                           pop     DE
 542+ 0734 3A 30 55                     ld      A,(SCR_SIZE_W)  ; load screen width
 543+ 0737 4F                           ld      C,A             ; move it into C
 544+ 0738 CD 54 41                     call    DIV_16_8        ; divide position by C: return Y into L and X into A
 545+ 073B C9                           ret                     ; return to caller
 546+ 073C
 547+ 073C              ;-------------------------------------------------------------------------------
 548+ 073C              ; char table for jumps
 549+ 073C 19           CHRTBL:         defb    HOME
 550+ 073D 7F 06                        defw    ATHOME          ; move the cursor to 0,0
 551+ 073F
 552+ 073F 0C                           defb    CS
 553+ 0740 72 06                        defw    CLEARVIDBUF     ; clear video buffer and position cursor at 0,0
 554+ 0742
 555+ 0742 0D                           defb    CR
 556+ 0743 BB 09                        defw    CRGRETURN       ; go to the beginning of the next line
 557+ 0745
 558+ 0745 08                           defb    BKSP
 559+ 0746 29 08                        defw    BACKSPACE       ; move cursor left 1 position
 560+ 0748
 561+ 0748 1C                           defb    CRSLFT
 562+ 0749 6C 08                        defw    CURSORLEFT      ; move cursor left
 563+ 074B
 564+ 074B 1E                           defb    CRSUP
 565+ 074C B8 08                        defw    CURSORUP        ; move cursor up
 566+ 074E
 567+ 074E 1D                           defb    CRSRGT
 568+ 074F D1 08                        defw    CURSORRIGHT     ; move cursor right
 569+ 0751
 570+ 0751 1F                           defb    CRSDN
 571+ 0752 06 09                        defw    CURSORDOWN      ; move cursor up
 572+ 0754
 573+ 0754 1A                           defb    INSRT
 574+ 0755 E7 07                        defw    INSERTKEY       ; insert a space
 575+ 0757
 576+ 0757 0A                           defb    LF
 577+ 0758 C3 07                        defw    PLACEHOLDER     ; CURRENTLY WE DON'T PRINT LINE FEED
 578+ 075A
 579+ 075A              ; send current char to video buffer
 580+ 075A F5           CHAR2VID:       push    AF              ; store AF
 581+ 075B C5                           push    BC              ; store BC
 582+ 075C D5                           push    DE              ; store DE
 583+ 075D E5                           push    HL              ; store HL
 584+ 075E 3A 3A 55                     ld      A,(CRSR_STATE)  ; store cursor state...
 585+ 0761 F5                           push    AF              ; into stack
 586+ 0762 CD 3B 09                     call    CURSOR_OFF      ; cursor off
 587+ 0765 3A 3D 55                     ld      A,(CHR4VID)     ; recover char
 588+ 0768 06 0A                        ld      B,$0A           ; 10 chars to check
 589+ 076A 21 3C 07                     ld      HL,CHRTBL       ; address of key table
 590+ 076D BE           RPTCPCK:        cp      (HL)            ; compare with char
 591+ 076E 23                           inc     HL              ; beginning of sub-routine address
 592+ 076F 20 09                        jr      NZ,NXTCPCK      ; different, go to next char
 593+ 0771 5E                           ld      E,(HL)          ; load addres into DE
 594+ 0772 23                           inc     HL
 595+ 0773 56                           ld      D,(HL)
 596+ 0774 EB                           ex      DE,HL           ; move user routine's address into HL
 597+ 0775 11 B6 07                     ld      DE,EXITCHAR2VID ; set point of return after the user routine
 598+ 0778 D5                           push    DE              ; store into stack
 599+ 0779 E9                           jp      (HL)            ; call user routine - then, the CPU will return (jump) to EXITCHAR2VID
 600+ 077A 23           NXTCPCK:        inc     HL              ; jump over 2 cells...
 601+ 077B 23                           inc     HL              ; ...to the next char code
 602+ 077C 10 EF                        djnz    RPTCPCK         ; repeat
 603+ 077E                              ; it'a not a special char, just print it
 604+ 077E CD 08 07                     call    LOAD_CRSR_POS   ; recover position of cursor
 605+ 0781 3A 3D 55                     ld      A,(CHR4VID)     ; recover char to print
 606+ 0784 CD 9E 06                     call    WRITE_VIDEO_LOC ; write A into VRAM at (HL)
 607+ 0787 3A 36 55                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 608+ 078A 5F                           ld      E,A             ; store cursor Y into E
 609+ 078B 3A 35 55                     ld      A,(SCR_CURS_X)  ; load cursor X
 610+ 078E 3C                           inc     A               ; move 1 step to right
 611+ 078F 21 30 55                     ld      HL,SCR_SIZE_W   ; cell that keeps the width of screen
 612+ 0792 BE                           cp      (HL)            ; have we reached the most right position?
 613+ 0793 20 0F                        jr      NZ,SETCSRCOORDS ; no, go over
 614+ 0795 1C                           inc     E               ; yes, increment cursor Y (go to next line)
 615+ 0796 7B                           ld      A,E             ; move cursor Y into A
 616+ 0797 21 31 55                     ld      HL,SCR_SIZE_H   ; cell that keeps the height of screen
 617+ 079A BE                           cp      (HL)            ; have we reached the bottom of the screen?
 618+ 079B 20 06                        jr      NZ,SETCRSRY     ; no, jump over
 619+ 079D D5                           push    DE
 620+ 079E CD 42 09                     call    SCROLLUP        ; scroll screen up
 621+ 07A1 D1                           pop     DE
 622+ 07A2 1D                           dec     E               ; decrement 1 row, to set cursor Y on the last line
 623+ 07A3 AF           SETCRSRY:       xor     A               ; then set cursor X to 0 (go to beginning of line)
 624+ 07A4 32 35 55     SETCSRCOORDS:   ld      (SCR_CURS_X),A  ; store current cursor X
 625+ 07A7 7B                           ld      A,E             ; recover Y
 626+ 07A8 32 36 55                     ld      (SCR_CURS_Y),A  ; store current cursor Y
 627+ 07AB CD C5 06                     call    POS_CURSOR      ; position cursor into new location
 628+ 07AE 3A 20 55                     ld      A,(TMRCNT)      ; load status of cursor flashing
 629+ 07B1 E6 20                        and     $20             ; check cursor state
 630+ 07B3 32 3B 55                     ld      (LSTCSRSTA),A   ; store the last cursor state
 631+ 07B6 AF           EXITCHAR2VID:   xor     A               ; reset char
 632+ 07B7 32 3D 55                     ld      (CHR4VID),A     ; to be sent to screen
 633+ 07BA F1                           pop     AF              ; recover cursor state
 634+ 07BB A7                           and     A               ; was it off (A=0)?
 635+ 07BC C4 26 09                     call    NZ,CURSOR_ON    ; no, set cursor on
 636+ 07BF E1                           pop     HL              ; restore HL
 637+ 07C0 D1                           pop     DE              ; restore DE
 638+ 07C1 C1                           pop     BC              ; restore BC
 639+ 07C2 F1                           pop     AF              ; restore AF
 640+ 07C3 C9           PLACEHOLDER:    ret                     ; return to caller
 641+ 07C4
 642+ 07C4              ; flash the cursor at the current position
 643+ 07C4              ; (this sub-routine is called by CH3 timer ISR)
 644+ 07C4 3A 3A 55     FLASHCURSOR:    ld      A,(CRSR_STATE)  ; now, check the cursor
 645+ 07C7 A7                           and     A               ; cursor off (A=0)?
 646+ 07C8 C8                           ret     Z               ; yes, return
 647+ 07C9 3A 20 55                     ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
 648+ 07CC E6 20                        and     $20             ; check if it's time to flash the cursor (check bit #6)
 649+ 07CE 21 3B 55                     ld      HL,LSTCSRSTA    ; load address of cell that stores the last cursor state
 650+ 07D1 BE                           cp      (HL)            ; compare current state with last state
 651+ 07D2 C8                           ret     Z               ; same state, no change required - exit
 652+ 07D3 77                           ld      (HL),A          ; save new state
 653+ 07D4 F5                           push    AF              ; store A (keep state for later use)
 654+ 07D5 CD 08 07                     call    LOAD_CRSR_POS   ; load current cursor position into HL
 655+ 07D8 F1                           pop     AF              ; recover current state
 656+ 07D9 06 FF                        ld      B,$FF           ; cursor char
 657+ 07DB FE 20                        cp      $20             ; is the cursor on video (A == $20)?
 658+ 07DD 28 04                        jr      Z,PUTCRSCHR     ; yes, jump over
 659+ 07DF 3A 39 55                     ld      A,(SCR_ORG_CHR) ; no, load the original char
 660+ 07E2 47                           ld      B,A             ; move char into B
 661+ 07E3 78           PUTCRSCHR:      ld      A,B             ; recover char from B
 662+ 07E4 C3 9E 06                     jp      WRITE_VIDEO_LOC ; print cursor/char at the current position & return
 663+ 07E7
 664+ 07E7
 665+ 07E7              ; insert an empty space at the current position of the cursor, moving the following text
 666+ 07E7              ; 1 cell straight
 667+ 07E7 CD FF 06     INSERTKEY:      call    RSTCHRCRS       ; restore char under the cursor
 668+ 07EA CD 08 07                     call    LOAD_CRSR_POS   ; retrieve address of cursor cell
 669+ 07ED 22 40 55                     ld      (CUR_POS),HL    ; store it
 670+ 07F0 CD 42 0A                     call    ENDOFLN         ; find address of first free cell after the end of the text from the current cursor position - address into HL -
 671+ 07F3                                                      ; DE is the address of the bottom right cell of the screen
 672+ 07F3 22 44 55                     ld      (ENDTXT),HL     ; store it
 673+ 07F6 ED 4B 40 55                  ld      BC,(CUR_POS)    ; load starting address
 674+ 07FA AF                           xor     A
 675+ 07FB ED 42                        sbc     HL,BC           ; how many positions to move?
 676+ 07FD CA D5 06                     jp      Z,MOVSHOWCRS    ; none - leave and re-place cursor
 677+ 0800 44 4D                        ld      BC,HL           ; number of chars to scroll into BC
 678+ 0802 2A 44 55                     ld      HL,(ENDTXT)     ; load address of the end of text
 679+ 0805 2B           CHKHL:          dec     HL              ; decrement to find the address of the char to move
 680+ 0806 E5                           push    HL
 681+ 0807 CD F9 40                     call    CMP16           ; is it the last cell (bottom right) of screen?
 682+ 080A E1                           pop     HL
 683+ 080B D2 16 08                     jp      NC,NXTINST      ; yes, so jump over - nothing to do
 684+ 080E CD 89 06                     call    READ_VIDEO_LOC  ; no, so read current char
 685+ 0811 23                           inc     HL              ; next cell
 686+ 0812 CD 9E 06                     call    WRITE_VIDEO_LOC ; write into new position
 687+ 0815 2B                           dec     HL              ; decrement to old position
 688+ 0816 0B           NXTINST:        dec     BC              ; decrement number of chars to move
 689+ 0817 79                           ld      A,C
 690+ 0818 B0                           or      B               ; finished?
 691+ 0819 20 EA                        jr      NZ,CHKHL        ; no, repeat
 692+ 081B 3E 20        ENDINSRT:       ld      A,SPC           ; load SPACE character
 693+ 081D 2A 40 55                     ld      HL,(CUR_POS)    ; get cursor position
 694+ 0820 32 39 55                     ld      (SCR_ORG_CHR),A ; reset original char under the cursor
 695+ 0823 CD 9E 06                     call    WRITE_VIDEO_LOC ; empty current video location
 696+ 0826 C3 D5 06                     jp      MOVSHOWCRS      ; re-place cursor
 697+ 0829
 698+ 0829              ; delete the char at the left of the cursor
 699+ 0829 CD FF 06     BACKSPACE:      call    RSTCHRCRS       ; restore char
 700+ 082C 2A 33 55                     ld      HL,(SCR_NAM_TB) ; address of origin of screen (location 0,0)
 701+ 082F 44 4D                        ld      BC,HL           ; store into BC
 702+ 0831 CD 08 07                     call    LOAD_CRSR_POS   ; load address of current cursor pos.
 703+ 0834 54 5D                        ld      DE,HL           ; copy into DE
 704+ 0836 AF                           xor     A               ; reset Carry
 705+ 0837 ED 42                        sbc     HL,BC           ; check how many chars between
 706+ 0839 CA 63 08                     jp      Z,LVBKSP        ; none, so we are at the top left corner
 707+ 083C ED 53 40 55                  ld      (CUR_POS),DE    ; store current cursor position
 708+ 0840 CD 42 0A                     call    ENDOFLN         ; check end of text
 709+ 0843 ED 5B 40 55                  ld      DE,(CUR_POS)    ; retrieve cursor position
 710+ 0847 AF                           xor     A               ; reset Carry
 711+ 0848 ED 52                        sbc     HL,DE           ; check if none follows
 712+ 084A CA 63 08                     jp      Z,LVBKSP        ; no chars follow, so simply move the cursor
 713+ 084D 44 4D                        ld      BC,HL           ; save numbers of chars to move
 714+ 084F EB                           ex      DE,HL           ; copy starting position into HL
 715+ 0850 CD 89 06     MVBKSP:         call    READ_VIDEO_LOC  ; read char
 716+ 0853 2B                           dec     HL              ; 1 position to left
 717+ 0854 CD 9E 06                     call    WRITE_VIDEO_LOC ; write char
 718+ 0857 23                           inc     HL              ; goto next char to copy (2 steps to right)
 719+ 0858 23                           inc     HL
 720+ 0859 0B                           dec     BC              ; decrement # of chars
 721+ 085A 79                           ld      A,C
 722+ 085B B0                           or      B               ; 0 chars?
 723+ 085C 20 F2                        jr      NZ,MVBKSP       ; not finished, continue
 724+ 085E 2B                           dec     HL
 725+ 085F AF                           xor     A
 726+ 0860 CD 9E 06                     call    WRITE_VIDEO_LOC ; reset last char
 727+ 0863 CD 95 08     LVBKSP:         call    MVCRS2LFT       ; move cursor to new position
 728+ 0866 CD EA 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 729+ 0869 C3 D5 06                     jp      MOVSHOWCRS      ; move cursor to the new location and set it ON
 730+ 086C
 731+ 086C
 732+ 086C              ; move cursor to left
 733+ 086C F5           CURSORLEFT:     push    AF              ; store A
 734+ 086D 3A 35 55                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 735+ 0870 A7                           and     A               ; is it at the most left of the screen (X=0)?
 736+ 0871 28 0C                        jr      Z,CHCKYPOS      ; yes, check Y position
 737+ 0873 3D                           dec     A               ; no, decrement X
 738+ 0874 32 37 55                     ld      (SCR_CUR_NX),A  ; store new X
 739+ 0877 3A 36 55                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 740+ 087A 32 38 55                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 741+ 087D 18 11                        jr      CONTCRSLFT      ; go on moving cursor
 742+ 087F 3A 36 55     CHCKYPOS:       ld      A,(SCR_CURS_Y)  ; load cursor Y
 743+ 0882 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 744+ 0883 28 0E                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 745+ 0885 3D                           dec     A               ; no, decrement Y
 746+ 0886 32 38 55                     ld      (SCR_CUR_NY),A  ; store new Y
 747+ 0889 3A 30 55                     ld      A,(SCR_SIZE_W)  ; load current screen width
 748+ 088C 3D                           dec     A               ; cursor to the most right position (width-0)
 749+ 088D 32 37 55                     ld      (SCR_CUR_NX),A  ; set new cursor X
 750+ 0890 CD CF 06     CONTCRSLFT:     call    MOVCRS          ; move cursor into new position
 751+ 0893 F1           EXITCURSORLEFT: pop     AF              ; restore A
 752+ 0894 C9                           ret                     ; return to caller
 753+ 0895
 754+ 0895              ; move cursor 1 position to the left
 755+ 0895 3A 35 55     MVCRS2LFT:      ld      A,(SCR_CURS_X)  ; load cursor X into A
 756+ 0898 A7                           and     A               ; is it at the most left of the screen (X=0)?
 757+ 0899 28 0B                        jr      Z,CHKYPOS       ; yes, check Y position
 758+ 089B 3D                           dec     A               ; no, decrement X
 759+ 089C 32 37 55                     ld      (SCR_CUR_NX),A  ; store new X
 760+ 089F 3A 36 55                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 761+ 08A2 32 38 55                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 762+ 08A5 C9                           ret                     ; go on moving cursor
 763+ 08A6 3A 36 55     CHKYPOS:        ld      A,(SCR_CURS_Y)  ; load cursor Y
 764+ 08A9 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 765+ 08AA 28 E7                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 766+ 08AC 3D                           dec     A               ; no, decrement Y
 767+ 08AD 32 38 55                     ld      (SCR_CUR_NY),A  ; store new Y
 768+ 08B0 3A 30 55                     ld      A,(SCR_SIZE_W)  ; load current screen width
 769+ 08B3 3D                           dec     A               ; cursor to the most right position (width-1)
 770+ 08B4 32 37 55                     ld      (SCR_CUR_NX),A  ; set new cursor X
 771+ 08B7 C9                           ret                     ; return to caller
 772+ 08B8
 773+ 08B8              ; move cursor up
 774+ 08B8 F5           CURSORUP:       push    AF              ; store A
 775+ 08B9 3A 36 55                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 776+ 08BC A7                           and     A               ; is it at the most top of the screen (Y=0)?
 777+ 08BD 28 10                        jr      Z,EXITCURSORUP  ; yes, exit doing nothing
 778+ 08BF 3D                           dec     A               ; no, decrement Y
 779+ 08C0 32 38 55                     ld      (SCR_CUR_NY),A  ; store new Y
 780+ 08C3 3A 35 55                     ld      A,(SCR_CURS_X)  ; load current cursor X
 781+ 08C6 32 37 55                     ld      (SCR_CUR_NX),A  ; set new cursor X
 782+ 08C9 CD FF 06                     call    RSTCHRCRS       ; restore char under the cursor and print it
 783+ 08CC CD CF 06                     call    MOVCRS          ; move cursor into new position
 784+ 08CF F1           EXITCURSORUP:   pop     AF              ; restore A
 785+ 08D0 C9                           ret                     ; return to caller
 786+ 08D1
 787+ 08D1
 788+ 08D1              ; move cursor to right
 789+ 08D1 F5           CURSORRIGHT:    push    AF              ; store A
 790+ 08D2 C5                           push    BC              ; store B
 791+ 08D3 3A 30 55                     ld      A,(SCR_SIZE_W)  ; load current screen width (in text modes it's 32 or 40)
 792+ 08D6 3D                           dec     A               ; decrement it (most right can only be 31 or 39)
 793+ 08D7 47                           ld      B,A             ; move A into B
 794+ 08D8 3A 35 55                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 795+ 08DB B8                           cp      B               ; is cursor at the most right position on the screen?
 796+ 08DC 30 0C                        jr      NC,CHCKYPOS2    ; yes, so jump to check Y position
 797+ 08DE 3C                           inc     A               ; no, so increment X
 798+ 08DF 32 37 55                     ld      (SCR_CUR_NX),A  ; store new X
 799+ 08E2 3A 36 55                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 800+ 08E5 32 38 55                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 801+ 08E8 18 13                        jr      CONTCRSRGT      ; go on moving cursor
 802+ 08EA 3A 31 55     CHCKYPOS2:      ld      A,(SCR_SIZE_H)  ; load screen height
 803+ 08ED 3D                           dec     A               ; decrement it (last row can only be 23)
 804+ 08EE 47                           ld      B,A             ; move bottom into B
 805+ 08EF 3A 36 55                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 806+ 08F2 B8                           cp      B               ; is the cursor at the bottom of the screen?
 807+ 08F3 30 0E                        jr      NC,EXITCURSORRGHT; yes, exit doing nothing
 808+ 08F5 3C                           inc     A               ; no, increment Y
 809+ 08F6 32 38 55                     ld      (SCR_CUR_NY),A  ; store new Y
 810+ 08F9 AF                           xor     A               ; move cursor to top left
 811+ 08FA 32 37 55                     ld      (SCR_CUR_NX),A  ; store new X
 812+ 08FD CD FF 06     CONTCRSRGT:     call    RSTCHRCRS       ; restore char under the cursor and print it
 813+ 0900 CD CF 06                     call    MOVCRS          ; move cursor into new position
 814+ 0903 C1           EXITCURSORRGHT: pop     BC              ; retrieve BC
 815+ 0904 F1                           pop     AF              ; restore A
 816+ 0905 C9                           ret                     ; return to caller
 817+ 0906
 818+ 0906
 819+ 0906              ; move cursor down
 820+ 0906 F5           CURSORDOWN:     push    AF              ; store A
 821+ 0907 C5                           push    BC              ; store B
 822+ 0908 3A 31 55                     ld      A,(SCR_SIZE_H)  ; load current screen height (in text modes it's 24)
 823+ 090B 3D                           dec     A               ; decrement it (positions can only vary between 0 and 23)
 824+ 090C 47                           ld      B,A             ; move X into B
 825+ 090D 3A 36 55                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 826+ 0910 B8                           cp      B               ; is current cursor position < 23?
 827+ 0911 30 10                        jr      NC,EXITCURSORDOWN; no, exit doing nothing
 828+ 0913 3C                           inc     A               ; yes, increment Y
 829+ 0914 32 38 55                     ld      (SCR_CUR_NY),A  ; store new Y
 830+ 0917 3A 35 55                     ld      A,(SCR_CURS_X)  ; load current cursor X
 831+ 091A 32 37 55                     ld      (SCR_CUR_NX),A  ; set new cursor X
 832+ 091D CD FF 06                     call    RSTCHRCRS       ; restore char under the cursor and print it
 833+ 0920 CD CF 06                     call    MOVCRS          ; move cursor into new position
 834+ 0923 C1           EXITCURSORDOWN: pop     BC              ; retrieve BC
 835+ 0924 F1                           pop     AF              ; retrieve A
 836+ 0925 C9                           ret                     ; return to caller
 837+ 0926
 838+ 0926
 839+ 0926              ; set cursor on (visible on screen)
 840+ 0926 F5           CURSOR_ON:      push    AF              ; store AF
 841+ 0927 3A 3A 55                     ld      A,(CRSR_STATE)  ; load cursor state
 842+ 092A B7                           or      A               ; is it on?
 843+ 092B 20 0C                        jr      NZ,EXITCURSOR_ON; yes, so nothing to do
 844+ 092D 3A 31 55                     ld      A,(SCR_SIZE_H)  ; check the video mode
 845+ 0930 FE 30                        cp      $30             ; graphics 2 or 3 (if value>=48)?
 846+ 0932 30 05                        jr      NC,EXITCURSOR_ON; yes, so exit (no cursor in graphics 2 or 3)
 847+ 0934 3E 01                        ld      A,$01           ; cursor state ON
 848+ 0936 32 3A 55                     ld      (CRSR_STATE),A  ; set state
 849+ 0939 F1           EXITCURSOR_ON:  pop     AF              ; restore AF
 850+ 093A C9                           ret                     ; return to caller
 851+ 093B
 852+ 093B              ; set cursor off (invisible on screen)
 853+ 093B F5           CURSOR_OFF:     push    AF              ; store AF
 854+ 093C AF                           xor     A               ; cursor state OFF
 855+ 093D 32 3A 55                     ld      (CRSR_STATE),A  ; set state
 856+ 0940 F1                           pop     AF              ; restore AF
 857+ 0941 C9                           ret
 858+ 0942
 859+ 0942              ; scroll the screen 1 row up
 860+ 0942 AF           SCROLLUP:       xor     A               ; reset A
 861+ 0943 57                           ld      D,A             ; reset D
 862+ 0944 32 3C 55                     ld      (PRNTVIDEO),A   ; no print on screen while scrolling
 863+ 0947 2A 33 55                     ld      HL,(SCR_NAM_TB) ; start address of the name table
 864+ 094A 22 70 55                     ld      (VIDTMP1),HL    ; store address of the destination row (1st row of the screen)
 865+ 094D 3A 30 55                     ld      A,(SCR_SIZE_W)  ; load the screen width
 866+ 0950 5F                           ld      E,A             ; move width into E
 867+ 0951 19                           add     HL,DE           ; HL now contains the address of the source row (2nd row of the screen)
 868+ 0952 22 72 55                     ld      (VIDTMP2),HL    ; store address of source row
 869+ 0955 3A 31 55                     ld      A,(SCR_SIZE_H)  ; load the screen height
 870+ 0958 3D                           dec     A               ; decrement the # of rows: now, A contains the # of rows to be moved
 871+ 0959 47                           ld      B,A             ; move # of rows into B
 872+ 095A 3A 30 55     SCROLLNXTRW:    ld      A,(SCR_SIZE_W)  ; (re)load the screen width
 873+ 095D 5F                           ld      E,A             ; move width into E
 874+ 095E 2A 72 55                     ld      HL,(VIDTMP2)    ; load source address
 875+ 0961 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 876+ 0963 ED 69                        out     (C),L           ; low byte of source
 877+ 0965 ED 61                        out     (C),H           ; high byte of source
 878+ 0967 21 48 55                     ld      HL,VIDEOBUFF    ; load address of the first cell of the video buffer
 879+ 096A 0D                           dec     C               ; VDP data mode
 880+ 096B 00                           nop                     ; added to compensate shorter instruction
 881+ 096C ED 78        LOADNEXTCOL:    in      A,(C)           ; load char
 882+ 096E 77                           ld      (HL),A          ; store char
 883+ 096F 23                           inc     HL              ; next cell of the buffer
 884+ 0970 1D                           dec     E               ; count the chars to be read
 885+ 0971 20 F9                        jr      NZ,LOADNEXTCOL  ; repeat until we read the entire row
 886+ 0973 3A 30 55                     ld      A,(SCR_SIZE_W)  ; reload the screen width
 887+ 0976 5F                           ld      E,A             ; move # of rows into E
 888+ 0977 16 00                        ld      D,$00           ; reset D
 889+ 0979 2A 70 55                     ld      HL,(VIDTMP1)    ; load address of destination row
 890+ 097C E5                           push    HL              ; store HL
 891+ 097D 2A 72 55                     ld      HL,(VIDTMP2)    ; current source will be..
 892+ 0980 22 70 55                     ld      (VIDTMP1),HL    ; ..new destination
 893+ 0983 19                           add     HL,DE           ; address of new
 894+ 0984 22 72 55                     ld      (VIDTMP2),HL    ; source row
 895+ 0987 E1                           pop     HL              ; restore address of current destination row
 896+ 0988 CB F4                        set     6,H             ; writing mode
 897+ 098A 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 898+ 098C ED 69                        out     (C),L           ; low byte
 899+ 098E ED 61                        out     (C),H           ; high byte of address
 900+ 0990 21 48 55                     ld      HL,VIDEOBUFF    ; video buffer address
 901+ 0993 0D                           dec     C               ; VDP data mode
 902+ 0994 7E           WRITEBUF:       ld      A,(HL)          ; load char
 903+ 0995 ED 79                        out     (C),A           ; send char
 904+ 0997 23                           inc     HL              ; increment buffer index
 905+ 0998 1D                           dec     E               ; next row
 906+ 0999 20 F9                        jr      NZ,WRITEBUF     ; repeat until 0
 907+ 099B 10 BD                        djnz    SCROLLNXTRW     ; repeat for the entire screen
 908+ 099D 3A 30 55                     ld      A,(SCR_SIZE_W)  ; reload screen width
 909+ 09A0 47                           ld      B,A             ; cells to empty into B
 910+ 09A1 AF                           xor     A               ; null char
 911+ 09A2 0E 31                        ld      C,VDP_SET       ; VDP set mode
 912+ 09A4 2A 70 55                     ld      HL,(VIDTMP1)    ; load address of the last row
 913+ 09A7 CB F4                        set     6,H             ; writing mode
 914+ 09A9 ED 69                        out     (C),L           ; low byte then..
 915+ 09AB ED 61                        out     (C),H           ; high byte of address
 916+ 09AD 0D                           dec     C               ; VDP data mode
 917+ 09AE 00                           nop                     ; delay
 918+ 09AF ED 79        RPTEMPTYROW:    out     (C),A           ; empty cell
 919+ 09B1 00                           nop                     ; delay
 920+ 09B2 00                           nop
 921+ 09B3 10 FA                        djnz    RPTEMPTYROW     ; repeat until the last row has been cleaned
 922+ 09B5 3E 01                        ld      A,$01
 923+ 09B7 32 3C 55                     ld      (PRNTVIDEO),A   ; set print-on-video on
 924+ 09BA C9                           ret                     ; return to caller
 925+ 09BB
 926+ 09BB              ; carriage return: first, it looks for char $00 at the beginning of the line (look for the first null char),
 927+ 09BB              ; then it starts sendind every char it finds on the screen to the terminal buffer of the BASIC interpreter
 928+ 09BB              ; until another null char is found. Finally, move to the next line and position the cursor at the beginning
 929+ 09BB              ; of the row (equivalent to CR+LF), then gets back control to the screen editor to let it interpret the line
 930+ 09BB              CUR_POS         equ     TMPBFR1         ; cursor position
 931+ 09BB              SRTTXT          equ     TMPBFR2         ; start of text line
 932+ 09BB              ENDTXT          equ     TMPBFR3         ; end of text line
 933+ 09BB              CRGRETURN:      ; preliminary: disable cursor if on, and retrieve char under it
 934+ 09BB 3A 3A 55                     ld      A,(CRSR_STATE)  ; recover cursor state
 935+ 09BE 32 46 55                     ld      (TMPBFR4),A     ; store status
 936+ 09C1 A7                           and     A               ; is cursor on?
 937+ 09C2 C4 3B 09                     call    NZ,CURSOR_OFF   ; yes, so set cursor off
 938+ 09C5 CD FF 06                     call    RSTCHRCRS       ; restore char under it
 939+ 09C8                              ; first, check if cursor if off, so that we just interpret return as a new line command
 940+ 09C8 3A 7A 55                     ld      A,(KBDNPT)      ; check if input from keyboad
 941+ 09CB A7                           and     A               ; if 0, input is not from keyboard...
 942+ 09CC CA 21 0A                     jp      Z,PRNTRETURN    ; ...so just print a carriage return; otherwise, interpret the return
 943+ 09CF                              ; first part: look for the beginning of the text line on screen
 944+ 09CF CD 08 07                     call    LOAD_CRSR_POS   ; load cursor position into HL
 945+ 09D2 22 40 55                     ld      (CUR_POS),HL    ; store it
 946+ 09D5 ED 5B 33 55                  ld      DE,(SCR_NAM_TB) ; load VRAM address of top-left cell of screen ("home")
 947+ 09D9 E5           RPTNLLSRC:      push    HL
 948+ 09DA CD F9 40                     call    CMP16           ; check if at "home"
 949+ 09DD E1                           pop     HL
 950+ 09DE CA E9 09                     jp      Z,CNTNULL       ; yes, exit because there is nothing before
 951+ 09E1 2B                           dec     HL              ; go 1 step back
 952+ 09E2 CD 89 06                     call    READ_VIDEO_LOC  ; read char of current position
 953+ 09E5 A7                           and     A               ; is it $00 (null char)?
 954+ 09E6 20 F1                        jr      NZ,RPTNLLSRC    ; no, continue searching
 955+ 09E8 23                           inc     HL              ; move 1 step forward to go back to the last cell with something in
 956+ 09E9                              ; second part: look for the ending of the text on screen
 957+ 09E9 22 42 55     CNTNULL:        ld      (SRTTXT),HL     ; store beginning of text
 958+ 09EC CD 42 0A                     call    ENDOFLN         ; find end of text line looking at the end of chars after the cursor position
 959+ 09EF 22 44 55                     ld      (ENDTXT),HL     ; store ending of text line
 960+ 09F2 ED 5B 42 55                  ld      DE,(SRTTXT)     ; load beginning of text line
 961+ 09F6 A7                           and     A               ; clear Carry
 962+ 09F7 ED 52                        sbc     HL,DE           ; how many chars?
 963+ 09F9 28 26                        jr      Z,PRNTRETURN    ; no chars found (HL-DE=0), so just print return & leave
 964+ 09FB                              ;---    central part: send the text on the screen to the interpreter
 965+ 09FB 2A 42 55                     ld      HL,(SRTTXT)     ; load beginning of text line
 966+ 09FE ED 5B 44 55                  ld      DE,(ENDTXT)     ; load ending of text line
 967+ 0A02 CD 89 06     SNDCHRTOBFR:    call    READ_VIDEO_LOC  ; read char
 968+ 0A05 E5                           push    HL
 969+ 0A06 CD FD 01                     call    CHARINTOBFR     ; send char to buffer
 970+ 0A09 E1                           pop     HL
 971+ 0A0A 23                           inc     HL              ; go to next char
 972+ 0A0B E5                           push    HL              ; store HL
 973+ 0A0C CD F9 40                     call    CMP16           ; check if DE=HL (finish chars)
 974+ 0A0F E1                           pop     HL
 975+ 0A10 20 F0                        jr      NZ,SNDCHRTOBFR  ; no, repeat
 976+ 0A12 3E 0D                        ld      A,CR            ; yes, so now send carriage return
 977+ 0A14 CD FD 01                     call    CHARINTOBFR     ; send to buffer
 978+ 0A17 2A 44 55                     ld      HL,(ENDTXT)     ; recover address of last char of input text
 979+ 0A1A CD 2B 07                     call    HL2XY           ; retrieve X,Y from address
 980+ 0A1D 7D                           ld      A,L             ; move Y into A (we don't need X anymore)
 981+ 0A1E 32 36 55                     ld      (SCR_CURS_Y),A  ; store new Y
 982+ 0A21                              ;---    final part: go at the beginning of a new line on the screen
 983+ 0A21 AF           PRNTRETURN:     xor     A               ; move to col 0
 984+ 0A22 32 35 55                     ld      (SCR_CURS_X),A  ; store new X
 985+ 0A25 3A 36 55                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 986+ 0A28 3C                           inc     A               ; new row
 987+ 0A29 21 31 55                     ld      HL,SCR_SIZE_H   ; load address of cell that keeps screen height
 988+ 0A2C BE                           cp      (HL)            ; is the cursor over the bottom of the screen?
 989+ 0A2D 38 06                        jr      C,ADDNEWLINE    ; no, jump over
 990+ 0A2F 3D                           dec     A               ; yes, so come back 1 row, then...
 991+ 0A30 F5                           push    AF              ; (store A)
 992+ 0A31 CD 42 09                     call    SCROLLUP        ; ...scroll the screen before to...
 993+ 0A34 F1                           pop     AF              ; (retrieve A)
 994+ 0A35 32 36 55     ADDNEWLINE:     ld      (SCR_CURS_Y),A  ; ...store new Y
 995+ 0A38 3A 46 55                     ld      A,(TMPBFR4)     ; retrieve cursor state
 996+ 0A3B A7                           and     A               ; was it off (A=0)?
 997+ 0A3C C4 26 09                     call    NZ,CURSOR_ON    ; no, set cursor on
 998+ 0A3F C3 C5 06                     jp      POS_CURSOR      ; position cursor to new location & return to caller
 999+ 0A42
1000+ 0A42              ; find end of text line
1001+ 0A42              ; destroys A, DE, and HL - store address of last char of text line into HL,
1002+ 0A42              ; while DE contains the address of the bottom right cell of the screen
1003+ 0A42 3A 31 55     ENDOFLN:        ld      A,(SCR_SIZE_H)
1004+ 0A45 5F                           ld      E,A             ; load screen height into DE
1005+ 0A46 3A 30 55                     ld      A,(SCR_SIZE_W)
1006+ 0A49 6F                           ld      L,A             ; load screen width into HL
1007+ 0A4A AF                           xor     A
1008+ 0A4B 67                           ld      H,A
1009+ 0A4C 57                           ld      D,A
1010+ 0A4D CD 04 41                     call    MUL16           ; multiply HL times DE to get the screen size
1011+ 0A50 ED 5B 33 55                  ld      DE,(SCR_NAM_TB) ; load screen name table start address into DE
1012+ 0A54 19                           add     HL,DE           ; get the address...
1013+ 0A55 2B                           dec     HL              ; ...of the "last" video cell
1014+ 0A56 EB                           ex      DE,HL           ; store address into DE
1015+ 0A57 2A 40 55                     ld      HL,(CUR_POS)    ; retrieve original cursor position
1016+ 0A5A E5           RPTNLLSRC2:     push    HL
1017+ 0A5B CD F9 40                     call    CMP16           ; check if at last position on screen (bottom right corner)
1018+ 0A5E E1                           pop     HL
1019+ 0A5F C8                           ret     Z               ; if yes, exit because these is nothing after
1020+ 0A60 23                           inc     HL              ; 1 more step forward
1021+ 0A61 CD 89 06                     call    READ_VIDEO_LOC  ; read char of current position
1022+ 0A64 A7                           and     A               ; is it $00 (null char)?
1023+ 0A65 20 F3                        jr      NZ,RPTNLLSRC2   ; no, continue searching
1024+ 0A67 C9           CNTNULL2:       ret                     ; yes: found end of text, return to caller
1025+ 0A68
1026+ 0A68
1027+ 0A68              ; ------------------------------------------------------------------------------
1028+ 0A68                              ; this table contains the values of the offsets to be added to
1029+ 0A68                              ; the starting address of the name table to find the correct
1030+ 0A68                              ; value of the first cell of the corresponding row
1031+ 0A68                              ; (by doing so, it's faster than doing a multipication)
1032+ 0A68                              ; table for graphics 1 text mode: 32 cols
1033+ 0A68 00 00 20 00  POS_TB_CRS_32:  defw    $0000,$0020,$0040,$0060,$0080,$00A0,$00C0,$00E0
1033+ 0A6C 40 00 60 00
1033+ 0A70 80 00 A0 00
1033+ 0A74 C0 00 E0 00
1034+ 0A78 00 01 20 01                  defw    $0100,$0120,$0140,$0160,$0180,$01A0,$01C0,$01E0
1034+ 0A7C 40 01 60 01
1034+ 0A80 80 01 A0 01
1034+ 0A84 C0 01 E0 01
1035+ 0A88 00 02 20 02                  defw    $0200,$0220,$0240,$0260,$0280,$02A0,$02C0,$02E0
1035+ 0A8C 40 02 60 02
1035+ 0A90 80 02 A0 02
1035+ 0A94 C0 02 E0 02
1036+ 0A98                              ; table for pure text mode: 40 cols
1037+ 0A98 00 00 28 00  POS_TB_CRS_40:  defw    $0000,$0028,$0050,$0078,$00A0,$00C8,$00F0,$0118
1037+ 0A9C 50 00 78 00
1037+ 0AA0 A0 00 C8 00
1037+ 0AA4 F0 00 18 01
1038+ 0AA8 40 01 68 01                  defw    $0140,$0168,$0190,$01B8,$01E0,$0208,$0230,$0258
1038+ 0AAC 90 01 B8 01
1038+ 0AB0 E0 01 08 02
1038+ 0AB4 30 02 58 02
1039+ 0AB8 80 02 A8 02                  defw    $0280,$02A8,$02D0,$02F8,$0320,$0348,$0370,$0398
1039+ 0ABC D0 02 F8 02
1039+ 0AC0 20 03 48 03
1039+ 0AC4 70 03 98 03
1040+ 0AC8
1041+ 0AC8              ; ------------------------------------------------------------------------------
1042+ 0AC8              ; reset VRAM
1043+ 0AC8 AF           EMPTY_VRAM:     xor     A               ; reg.A cleared: we fill up VRAM with $00
1044+ 0AC9 67                           ld      H,A
1045+ 0ACA 6F                           ld      L,A             ; reset HL
1046+ 0ACB CD 69 06                     call    SETVDPADRS      ; set address of first VRAM cell to $0000
1047+ 0ACE 06 40                        ld      B,$40           ; $40 pages of RAM...
1048+ 0AD0 57                           ld      D,A             ; ...each one with $100 cells (tot. $4000 bytes)
1049+ 0AD1 0D                           dec     C               ; VDP data mode
1050+ 0AD2 ED 79        EMPTVRM:        out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
1051+ 0AD4 14                           inc     D               ; next cell
1052+ 0AD5 00                           nop
1053+ 0AD6 20 FA                        jr      NZ,EMPTVRM      ; repeat until page is fully cleared
1054+ 0AD8 10 F8                        djnz    EMPTVRM         ; repeat for $40 pages
1055+ 0ADA C9                           ret                     ; return to caller
1056+ 0ADB
1057+ 0ADB              ; clear video registers in SRAM
1058+ 0ADB 21 30 55     CLR_RAM_REG:    ld      HL,SCR_SIZE_W   ; address of first register
1059+ 0ADE AF                           xor     A               ; $00 to clean the registers
1060+ 0ADF 06 44                        ld      B,CHASNDDTN-SCR_SIZE_W; how many bytes (registers) to clean (dinamically calculated)
1061+ 0AE1 77           RSTVDPRAMREG:   ld      (HL),A          ; reset register
1062+ 0AE2 23                           inc     HL              ; next register
1063+ 0AE3 10 FC                        djnz    RSTVDPRAMREG    ; repeat
1064+ 0AE5 C9                           ret                     ; return to caller
1065+ 0AE6
1066+ 0AE6              ; ------------------------------------------------------------------------------
1067+ 0AE6              ; set a specific graphics mode, passed into reg. E
1068+ 0AE6 06 08        SET_GFX_MODE:   ld      B,$08           ; 8 registers means 8 bytes..
1069+ 0AE8 CB 23                        sla     E               ; multiply E by 8..
1070+ 0AEA CB 23                        sla     E               ; so that reg. E can point..
1071+ 0AEC CB 23                        sla     E               ; to the correct settings
1072+ 0AEE 16 00        SET_GFX_MODE2:  ld      D,$00           ; reset D
1073+ 0AF0 21 22 0B                     ld      HL,VDPMODESET   ; pointer to register settings | <= here points the SHOW_LOGO sub-routine
1074+ 0AF3 19                           add     HL,DE           ; add offset to get the correct set of values for the required mode
1075+ 0AF4 3E 80                        ld      A,$80           ; start with REG0 ($80+register number)
1076+ 0AF6 0E 31                        ld      C,VDP_SET       ; VDP set
1077+ 0AF8 56           LDREGVLS:       ld      D,(HL)          ; load register's value
1078+ 0AF9 ED 51                        out     (C),D           ; send data to VDP
1079+ 0AFB ED 79                        out     (C),A           ; indicate the register to send data to
1080+ 0AFD 3C                           inc     A               ; next register
1081+ 0AFE 23                           inc     HL              ; next value
1082+ 0AFF 10 F7                        djnz    LDREGVLS        ; repeat for 8 registers
1083+ 0B01 C9                           ret
1084+ 0B02
1085+ 0B02              ; ------------------------------------------------------------------------------
1086+ 0B02              LOADCHARSET:    ; reg. A contains the video mode
1087+ 0B02                              ; reg. HL contains address of pattern table into VRAM
1088+ 0B02 06 00                        ld      B,$00           ; 0=256 chars to load (complete charset)
1089+ 0B04 CB F4                        set     $06,H           ; add $4000 to address to indicate that we want to write into VRAM
1090+ 0B06 0E 31                        ld      C,VDP_SET       ; load VDP address into C
1091+ 0B08 ED 69                        out     (C),L           ; send low byte of address
1092+ 0B0A ED 61                        out     (C),H           ; send high byte
1093+ 0B0C 0D                           dec     C               ; VDP data mode
1094+ 0B0D 21 2F 42                     ld      HL,CHRST68      ; starting address of 6x8 charset into ROM
1095+ 0B10 A7                           and     A               ; is it text mode (A=0)?
1096+ 0B11 28 03                        jr      Z,NXTCHAR       ; yes, so jump to load chars into VRAM
1097+ 0B13 21 2F 4A                     ld      HL,CHRST88      ; no, so we change and load the 8x8 charset
1098+ 0B16 16 08        NXTCHAR:        ld      D,$08           ; 8 bytes per pattern char
1099+ 0B18 7E           SENDCHRPTRNS:   ld      A,(HL)          ; load byte to send to VDP
1100+ 0B19 ED 79                        out     (C),A           ; write byte into VRAM
1101+ 0B1B 23                           inc     HL              ; inc byte pointer
1102+ 0B1C 15                           dec     D               ; 8 bytes sents (0 char)?
1103+ 0B1D 20 F9                        jr      NZ,SENDCHRPTRNS ; no, continue
1104+ 0B1F 10 F5                        djnz    NXTCHAR         ; yes, decrement chars counter and continue for all the chars
1105+ 0B21 C9                           ret                     ; return to caller
1106+ 0B22
1107+ 0B22              ;------------------------------------------------------------------------------
1108+ 0B22              ; NAME TABLE:       buffer video - contains the chars to be shown on video
1109+ 0B22              ; PATTERN TABLE:    charset - contains the chars/tiles to be loaded into the name table
1110+ 0B22              ; COLOR TABLE:      color settings for chars/tiles
1111+ 0B22
1112+ 0B22                              ; VDP register settings for a text display
1113+ 0B22 00           VDPMODESET:     defb    %00000000       ; reg.0: external video off
1114+ 0B23 D0                           defb    %11010000       ; reg.1: 16K VRAM, video on, int. off, text mode (40x24)
1115+ 0B24 02                           defb    $02             ; reg.2: name table set to $0800 ($02x$400)
1116+ 0B25 00                           defb    $00             ; reg.3: not used in text mode
1117+ 0B26 00                           defb    $00             ; reg.4: pattern table set to $0000
1118+ 0B27 00                           defb    $00             ; reg.5: not used in text mode
1119+ 0B28 00                           defb    $00             ; reg.6: not used in text mode
1120+ 0B29 F5                           defb    $f5             ; reg.7: white text on light blue background
1121+ 0B2A
1122+ 0B2A              VDPMODESET1:    ; VDP register settings for a graphics 1 mode
1123+ 0B2A 00                           defb    %00000000       ; reg.0: ext. video off
1124+ 0B2B C0                           defb    %11000000       ; reg.1: 16K Vram; video on, int off, graphics mode 1, sprite size 8x8, sprite magn. 0
1125+ 0B2C 06                           defb    $06             ; reg.2: name table address: $1800
1126+ 0B2D 80                           defb    $80             ; reg.3: color table address: $2000
1127+ 0B2E 00                           defb    $00             ; reg.4: pattern table address: $0000
1128+ 0B2F 36                           defb    $36             ; reg.5: sprite attr. table address: $1B00
1129+ 0B30 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1130+ 0B31 05                           defb    $05             ; reg.7: backdrop color (light blue)
1131+ 0B32
1132+ 0B32              VDPMODESET2:    ; VDP register settings for a graphics 2 mode
1133+ 0B32 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1134+ 0B33 C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1135+ 0B34 06                           defb    $06             ; reg.2: name table addr.: $1800
1136+ 0B35 FF                           defb    $FF             ; reg.3: color table addr.: $2000
1137+ 0B36 03                           defb    $03             ; reg.4: pattern table addr.: $0000
1138+ 0B37 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1139+ 0B38 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1140+ 0B39 05                           defb    $05             ; reg.7: backdrop color: light blue
1141+ 0B3A
1142+ 0B3A              VDPMODESETMC:   ; VDP register settings for a multicolor mode
1143+ 0B3A 00                           defb    %00000000       ; reg.0: ext. video dis.
1144+ 0B3B CB                           defb    %11001011       ; reg.1: 16K VRAM, video on, INT off, multicolor mode, sprite size 8x8, sprite magn. 0
1145+ 0B3C 02                           defb    $02             ; reg.2: name table addr.: $0800
1146+ 0B3D 00                           defb    $00             ; reg.3: don't care
1147+ 0B3E 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1148+ 0B3F 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1149+ 0B40 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1150+ 0B41 0F                           defb    $0F             ; reg.7: backdrop color (white)
1151+ 0B42
1152+ 0B42              VDPMODESETEX2:  ; VDP register settings for an extended graphics 2 mode
1153+ 0B42 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1154+ 0B43 C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1155+ 0B44 0E                           defb    $0E             ; reg.2: name table addr.: $3800
1156+ 0B45 9F                           defb    $9F             ; reg.3: color table addr.: $2000
1157+ 0B46 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1158+ 0B47 76                           defb    $76             ; reg.5: sprite attr. table addr.: $3B00
1159+ 0B48 03                           defb    $03             ; reg.6: sprite pattern table addr.: $1800
1160+ 0B49 05                           defb    $05             ; reg.7: backdrop color: light blue
1161+ 0B4A
1162+ 0B4A              LM80CLOGO:      ; patterns to compose the splash screen logo
1163+ 0B4A                              ; 1st band
1164+ 0B4A 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1164+ 0B4E 00 00 00 00
1164+ 0B52 00 00 00 00
1164+ 0B56 00 00 00 00
1164+ 0B5A 00 00 00 00
1164+ 0B5E 00 00 00 00
1164+ 0B62 00 00 00 00
1164+ 0B66 00 00 00 00
1165+ 0B6A 00 00 0F 0A                  defb    0,0,15,10,11,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1165+ 0B6E 0B 10 00 00
1165+ 0B72 00 00 00 00
1165+ 0B76 00 00 00 00
1165+ 0B7A 00 00 00 00
1165+ 0B7E 00 00 00 00
1165+ 0B82 00 00 00 00
1165+ 0B86 00 00 00 00
1166+ 0B8A                              ; 2nd band
1167+ 0B8A 00 00 0D 17                  defb    0,0,13,23,0,12,0,0,0,1,0,0,0,20,0,0,6,5,6,21,22,7,6,21,22,7,6,1,1,7,0,0
1167+ 0B8E 00 0C 00 00
1167+ 0B92 00 01 00 00
1167+ 0B96 00 14 00 00
1167+ 0B9A 06 05 06 15
1167+ 0B9E 16 07 06 15
1167+ 0BA2 16 07 06 01
1167+ 0BA6 01 07 00 00
1168+ 0BAA 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,20,6,1,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1168+ 0BAE 00 0C 00 00
1168+ 0BB2 00 01 00 00
1168+ 0BB6 00 01 14 06
1168+ 0BBA 01 05 03 05
1168+ 0BBE 03 05 03 05
1168+ 0BC2 03 05 03 05
1168+ 0BC6 03 05 00 00
1169+ 0BCA                              ; 3rd band
1170+ 0BCA 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,1,1,1,5,9,20,19,8,3,5,19,5,3,5,0,0,0,0
1170+ 0BCE 00 0C 00 00
1170+ 0BD2 00 01 00 00
1170+ 0BD6 00 01 01 01
1170+ 0BDA 01 05 09 14
1170+ 0BDE 13 08 03 05
1170+ 0BE2 13 05 03 05
1170+ 0BE6 00 00 00 00
1171+ 0BEA 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,8,3,5,6,21,22,7,3,1,22,5,3,5,0,0,0,0
1171+ 0BEE 00 0C 00 00
1171+ 0BF2 00 01 00 00
1171+ 0BF6 00 01 00 08
1171+ 0BFA 03 05 06 15
1171+ 0BFE 16 07 03 01
1171+ 0C02 16 05 03 05
1171+ 0C06 00 00 00 00
1172+ 0C0A                              ; 4th band
1173+ 0C0A 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,0,3,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1173+ 0C0E 00 0C 00 00
1173+ 0C12 00 01 00 00
1173+ 0C16 00 01 00 00
1173+ 0C1A 03 05 03 05
1173+ 0C1E 03 05 03 05
1173+ 0C22 03 05 03 05
1173+ 0C26 03 05 00 00
1174+ 0C2A 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,4,4,0,1,0,0,3,5,9,20,19,8,9,20,19,8,9,1,1,8,0,0
1174+ 0C2E 00 0C 00 00
1174+ 0C32 00 01 04 04
1174+ 0C36 00 01 00 00
1174+ 0C3A 03 05 09 14
1174+ 0C3E 13 08 09 14
1174+ 0C42 13 08 09 01
1174+ 0C46 01 08 00 00
1175+ 0C4A                              ; 5th band
1176+ 0C4A 00 00 0E 12                  defb    0,0,14,18,18,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1176+ 0C4E 12 11 00 00
1176+ 0C52 00 00 00 00
1176+ 0C56 00 00 00 00
1176+ 0C5A 00 00 00 00
1176+ 0C5E 00 00 00 00
1176+ 0C62 00 00 00 00
1176+ 0C66 00 00 00 00
1177+ 0C6A 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1177+ 0C6E 00 00 00 00
1177+ 0C72 00 00 00 00
1177+ 0C76 00 00 00 00
1177+ 0C7A 00 00 00 00
1177+ 0C7E 00 00 00 00
1177+ 0C82 00 00 00 00
1177+ 0C86 00 00 00 00
# file closed: ../include/vdp/vdp-1.06.asm
  70  0C8A
  71  0C8A              ; incude the latest version of the PSG module
  72  0C8A                  INCLUDE "../include/psg/psg-1.1.asm"
# file opened: ../include/psg/psg-1.1.asm
   1+ 0C8A              ; ------------------------------------------------------------------------------
   2+ 0C8A              ; LM80C - PSG ROUTINES - 1.1
   3+ 0C8A              ; ------------------------------------------------------------------------------
   4+ 0C8A              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0C8A              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0C8A              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0C8A              ; kind of warranty: you can use them at your own risk.
   8+ 0C8A              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0C8A              ; maintain the copyright notices, include this advice and the note to the
  10+ 0C8A              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0C8A              ; redistribuite them.
  12+ 0C8A              ; https://www.leonardomiliani.com
  13+ 0C8A              ;
  14+ 0C8A              ; Please support me by visiting the following links:
  15+ 0C8A              ; Main project page: https://www.leonardomiliani.com
  16+ 0C8A              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0C8A              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0C8A              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0C8A              ; ------------------------------------------------------------------------------
  20+ 0C8A              ;
  21+ 0C8A              ; ------------------------------------------------------------------------------
  22+ 0C8A
  23+ 0C8A              ;------------------------------------------------------------------------------
  24+ 0C8A
  25+ 0C8A              ; configure the PSG
  26+ 0C8A 21 74 55     initPSG:        ld      HL,CHASNDDTN    ; starting address of sound & keyboard RAM registers
  27+ 0C8D 06 0E                        ld      B,SERIALS_EN-CHASNDDTN; # of PSG sound & keyboard registers
  28+ 0C8F AF                           xor     A               ; reset A
  29+ 0C90 77           EMPTSNDBFR:     ld      (HL),A          ; reset RAM register
  30+ 0C91 23                           inc     HL              ; next register
  31+ 0C92 10 FC                        djnz    EMPTSNDBFR      ; repeat
  32+ 0C94 06 10        CLRPSGREGS:     ld      B,$10           ; 16 registers to set
  33+ 0C96 21 A8 0C                     ld      HL,SNDREGCFG    ; starting address of register settings
  34+ 0C99 16 00                        ld      D,$00           ; first register
  35+ 0C9B 7A           RSTPSG:         ld      A,D             ; register value
  36+ 0C9C CD E2 0C                     call    SETSNDREG       ; select register
  37+ 0C9F 7E                           ld      A,(HL)          ; load value
  38+ 0CA0 CD E7 0C                     call    WRTSNDREG       ; write to register
  39+ 0CA3 14                           inc     D               ; next register
  40+ 0CA4 23                           inc     HL              ; next value
  41+ 0CA5 10 F4                        djnz    RSTPSG          ; repeat for each register
  42+ 0CA7 C9                           ret                     ; return to caller
  43+ 0CA8
  44+ 0CA8 00 00 00 00  SNDREGCFG:      defb $00,$00,$00,$00,$00,$00,$00,%10111111
  44+ 0CAC 00 00 00 BF
  45+ 0CB0 00 00 00 00                  defb $00,$00,$00,$00,$00,$00,$ff,$ff
  45+ 0CB4 00 00 FF FF
  46+ 0CB8                              ; reg. 7: set I/O ch.A to OUTPUT, I/O ch.B to INPUT; set noise to OFF; set audio to OFF
  47+ 0CB8
  48+ 0CB8
  49+ 0CB8              ; routine to play a welcome beep on channel C (tone 4010) and to shut it off
  50+ 0CB8 21 D2 0C     WLCMBEEP:       ld      HL,WLCBPDAT     ; data address
  51+ 0CBB C3 C1 0C                     jp      SENDSND
  52+ 0CBE 21 DA 0C     NOBEEP:         ld      HL,NOBPDAT      ; data address
  53+ 0CC1 C5           SENDSND:        push    BC
  54+ 0CC2 06 04                        ld      B,$04           ; 4 pairs
  55+ 0CC4 7E           RPTWLCMBP:      ld      A,(HL)          ; read register #
  56+ 0CC5 CD E2 0C                     call    SETSNDREG
  57+ 0CC8 23                           inc     HL              ; next cell
  58+ 0CC9 7E                           ld      A,(HL)          ; read value
  59+ 0CCA CD E7 0C                     call    WRTSNDREG
  60+ 0CCD 23                           inc     HL
  61+ 0CCE 10 F4                        djnz    RPTWLCMBP       ; repeat
  62+ 0CD0 C1                           pop     BC
  63+ 0CD1 C9                           ret                     ; return to caller
  64+ 0CD2
  65+ 0CD2 07 BB 04 56  WLCBPDAT:       defb    $07,%10111011,$04,$56,$05,$00,$0A,$0F
  65+ 0CD6 05 00 0A 0F
  66+ 0CDA 04 00 05 00  NOBPDAT:        defb    $04,$00,$05,$00,$0A,$00,$07,%10111111
  66+ 0CDE 0A 00 07 BF
  67+ 0CE2
  68+ 0CE2
  69+ 0CE2              ; select register on PSG
  70+ 0CE2 0E 40        SETSNDREG:      ld      C,PSG_REG       ; PSG register port
  71+ 0CE4 ED 79                        out     (C),A           ; set register
  72+ 0CE6 C9                           ret                     ; return to caller
  73+ 0CE7
  74+ 0CE7              ; send data to PSG
  75+ 0CE7 0E 41        WRTSNDREG:      ld      C,PSG_DAT       ; PSG data port
  76+ 0CE9 ED 79                        out     (C),A           ; send data
  77+ 0CEB C9                           ret                     ; return to caller
  78+ 0CEC
  79+ 0CEC              ; manage the sounds' duration: each time this subroutine is called, it
  80+ 0CEC              ; decrements the single sound durations (measured in ms) and eventually
  81+ 0CEC              ; shut off the audio channel whose counter has reached 0.
  82+ 0CEC              ; (this sub-routine is called by CH3 timer ISR)
  83+ 0CEC DD E5        MNGSNDS:        push    IX              ; store IX
  84+ 0CEE DD 21 74 55                  ld      IX,CHASNDDTN    ; starting address of tones duration
  85+ 0CF2 06 03                        ld      B,$03           ; 3 channels to check
  86+ 0CF4 26 01                        ld      H,$01           ; mixer channels: A=>bit 1, B=>bit 2, C=>bit 3
  87+ 0CF6 DD 5E 00     CHKSNDCH:       ld      E,(IX+0)        ; load LSB into E
  88+ 0CF9 DD 56 01                     ld      D,(IX+1)        ; load MSB into D
  89+ 0CFC 7B                           ld      A,E             ; load E into A
  90+ 0CFD B2                           or      D               ; check that DE=0
  91+ 0CFE 28 31                        jr      Z,CNTCHKSND     ; yes, jump over
  92+ 0D00 1B                           dec     DE              ; no, so decrement DE
  93+ 0D01 7B                           ld      A,E             ; reload E into A...
  94+ 0D02 DD 73 00                     ld      (IX+0),E        ; store new...
  95+ 0D05 DD 72 01                     ld      (IX+1),D        ; ...duration and...
  96+ 0D08 B2                           or      D               ; ...do another check to see if DE=0
  97+ 0D09 20 26                        jr      NZ,CNTCHKSND    ; no, so jump over
  98+ 0D0B                                                      ; if yes, let's shut down the corresponding channel
  99+ 0D0B                                                      ; to shut down a tone we disable it into the mixer
 100+ 0D0B                                                      ; then set 0 into its tone registers
 101+ 0D0B 16 07                        ld      D,$07           ; mixer register
 102+ 0D0D 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 103+ 0D0F ED 51                        out     (C),D           ; set mixer register
 104+ 0D11 ED 78                        in      A,(C)           ; load current value
 105+ 0D13 B4                           or      H               ; set off the channel into the mixer (remember that 1=OFF)
 106+ 0D14 ED 51                        out     (C),D           ; select mixer register
 107+ 0D16 0E 41                        ld      C,PSG_DAT       ; PSG data port
 108+ 0D18 ED 79                        out     (C),A           ; send new value for the mixer
 109+ 0D1A 3E 03                        ld      A,$03           ; three channels
 110+ 0D1C 90                           sub     B               ; find current channel (0->A, 1->B, 2->C)
 111+ 0D1D 87                           add     A,A             ; and find first register (A=>0, B=>2, C=>4)
 112+ 0D1E 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 113+ 0D20 ED 79                        out     (C),A           ; select first tone register of channel
 114+ 0D22 2E 00                        ld      L,$00           ; value 0 into L
 115+ 0D24 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 116+ 0D26 ED 69                        out     (C),L           ; write 0 into register
 117+ 0D28 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 118+ 0D2A 3C                           inc     A               ; next tone register
 119+ 0D2B ED 79                        out     (C),A           ; select second tone register of channel
 120+ 0D2D 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 121+ 0D2F ED 69                        out     (C),L           ; write 0 into register
 122+ 0D31 DD 23        CNTCHKSND:      inc     IX              ; set for...
 123+ 0D33 DD 23                        inc     IX              ; ...next channel...
 124+ 0D35 CB 24                        sla     H               ; shift left H 1 bit
 125+ 0D37 10 BD                        djnz    CHKSNDCH        ; repeat for 3 channels
 126+ 0D39 DD E1                        pop     IX              ; restore IX
 127+ 0D3B C9                           ret                     ; return to caller
 128+ 0D3C
 129+ 0D3C              ; read a specific row of the keyboard matrix, set by A
 130+ 0D3C              ; return read into A
 131+ 0D3C C5           READKBLN:       push    BC              ; store BC
 132+ 0D3D 06 0F                        ld      B,$0F           ; reg #15
 133+ 0D3F 0E 40                        ld      C,PSG_REG       ; PSG register port
 134+ 0D41 ED 41                        out     (C),B           ; select reg #15
 135+ 0D43 0E 41                        ld      C,PSG_DAT       ; PSG data port
 136+ 0D45 ED 79                        out     (C),A           ; activate the row
 137+ 0D47 06 0E                        ld      B,$0E           ; register #14 (port B)
 138+ 0D49 0E 40                        ld      C,PSG_REG       ; PSG register port
 139+ 0D4B ED 41                        out     (C),B           ; select reg. 14 (port B)
 140+ 0D4D ED 78                        in      A,(C)           ; read register #14
 141+ 0D4F C1                           pop     BC              ; retrieve BC
 142+ 0D50 C9                           ret
 143+ 0D51
 144+ 0D51              ; read the keyboard matrix to look for a key pressure
 145+ 0D51 0E 40        KEYBOARD:       ld      C,PSG_REG       ; PSG register port
 146+ 0D53 06 07                        ld      B,$07           ; set register #7...
 147+ 0D55 ED 41                        out     (C),B           ; ...to work with
 148+ 0D57 ED 78                        in      A,(C)           ; read register #7
 149+ 0D59 CB FF                        set     7,A             ; port A set to output
 150+ 0D5B CB B7                        res     6,A             ; port B set to input
 151+ 0D5D ED 41                        out     (C),B           ; set register #7
 152+ 0D5F 0E 41                        ld      C,PSG_DAT       ; PSG data port
 153+ 0D61 ED 79                        out     (C),A           ; set I/O ports w/o altering the rest of the mixer
 154+ 0D63                              ; check special keys (SHIFT/ALT/CTRL)
 155+ 0D63 3E FD                        ld      A,%11111101     ; select SHIFT row
 156+ 0D65 CD 3C 0D                     call    READKBLN        ; read row
 157+ 0D68 CB 5F                        bit     3,A             ; test if SHIFT key is pressed (4th bit is reset)
 158+ 0D6A 20 05                        jr      NZ,CHECKALT     ; no, so go on
 159+ 0D6C 21 81 55                     ld      HL,CONTROLKEYS  ; control key flags
 160+ 0D6F 36 01                        ld      (HL),%00000001  ; set SHIFT flag, reset CTRL & ALT flags (currently multiply control keys are NOT supported)
 161+ 0D71 3E FE        CHECKALT:       ld      A,%11111110     ; select ALT row
 162+ 0D73 CD 3C 0D                     call    READKBLN        ; read ALT row
 163+ 0D76 CB 6F                        bit     5,A             ; test if ALT key is pressed (5th bit is reset)
 164+ 0D78 20 05                        jr      NZ,CHECKCTRL    ; no, so go on
 165+ 0D7A 21 81 55                     ld      HL,CONTROLKEYS  ; control key flags
 166+ 0D7D 36 04                        ld      (HL),%00000100  ; set ALT flag, reset SHIFT & CTRL flag (currently multiply control keys are NOT supported)
 167+ 0D7F 3E FE        CHECKCTRL:      ld      A,%11111110     ; select CTRL row
 168+ 0D81 CD 3C 0D                     call    READKBLN        ; read CTRL row
 169+ 0D84 CB 57                        bit     2,A             ; test if CTRL key is pressed (3rd bit is reset)
 170+ 0D86 20 05                        jr      NZ,CHECKKBD     ; no, so make a normal reading
 171+ 0D88 21 81 55                     ld      HL,CONTROLKEYS  ; control key flags
 172+ 0D8B 36 02                        ld      (HL),%00000010  ; set CTRL flag, reset SHIFT & ALT flags (currently multiply control keys are NOT supported)
 173+ 0D8D 06 08        CHECKKBD:       ld      B,$08           ; 8 lines
 174+ 0D8F 3E 7F                        ld      A,%01111111     ; start from the last line of the matrix
 175+ 0D91 16 0F        RPTKBDRD:       ld      D,$0F           ; register #15 (port B)
 176+ 0D93 0E 40                        ld      C,PSG_REG       ; PSG register port
 177+ 0D95 ED 51                        out     (C),D           ; select reg. #15
 178+ 0D97 0E 41                        ld      C,PSG_DAT       ; PSG data port
 179+ 0D99 ED 79                        out     (C),A           ; activate 1 line (active line is grounded, i.e. with a LOW signal)
 180+ 0D9B 5F                           ld      E,A             ; save current line into E
 181+ 0D9C 16 0E                        ld      D,$0E           ; register #14 (port A)
 182+ 0D9E 0E 40                        ld      C,PSG_REG       ; PSG register port
 183+ 0DA0 ED 51                        out     (C),D           ; select reg. 14 (port A)
 184+ 0DA2 00                           nop
 185+ 0DA3 ED 78                        in      A,(C)           ; read register #14
 186+ 0DA5 FE FF                        cp      $FF             ; is there any line set to 0?
 187+ 0DA7 28 2E                        jr      Z,NOKEYPRSD     ; no, go to the next row
 188+ 0DA9                              ; check control keys
 189+ 0DA9 32 7B 55                     ld      (KBTMP),A       ; yes, check if a control key was pressed. First, store current row
 190+ 0DAC 78                           ld      A,B             ; copy current row (B) into A
 191+ 0DAD FE 02                        cp      $02             ; is it the row of the SHIFT?
 192+ 0DAF 20 0F                        jr      NZ,TESTALT      ; no, continue checking the other control keys
 193+ 0DB1 3A 7B 55                     ld      A,(KBTMP)       ; yes, retrieve current row data
 194+ 0DB4 CB 5F                        bit     3,A             ; check SHIFT bit line
 195+ 0DB6 20 31                        jr      NZ,FINDKEY      ; no SHIFT, continue checking
 196+ 0DB8 CB DF                        set     3,A             ; yes, it's the SHIFT. So remove SHIFT bit
 197+ 0DBA FE FF                        cp      $FF             ; after deleting the SHIFT bit, is there any other bit selected?
 198+ 0DBC 20 2B                        jr      NZ,FINDKEY      ; yes, go to check which one
 199+ 0DBE 18 17                        jr      NOKEYPRSD       ; no, go to next row
 200+ 0DC0 FE 01        TESTALT:        cp      $01             ; is it the line of ALT & CTRL?
 201+ 0DC2 3A 7B 55                     ld      A,(KBTMP)       ; retrieve current row data
 202+ 0DC5 20 22                        jr      NZ,FINDKEY      ; no, continue
 203+ 0DC7 CB 6F                        bit     5,A             ; yes, check ALT bit line
 204+ 0DC9 20 02                        jr      NZ,TESTCTRL     ; no ALT, continue checking
 205+ 0DCB CB EF                        set     5,A             ; yes, it's the ALT. So remove ALT bit
 206+ 0DCD CB 57        TESTCTRL:       bit     2,A             ; check CTRL bit line
 207+ 0DCF 20 02                        jr      NZ,ENDCTRLCK    ; no CTRL, continue checking
 208+ 0DD1 CB D7                        set     2,A             ; delete CTRL bit flag
 209+ 0DD3 FE FF        ENDCTRLCK:      cp      $FF             ; after deleting the ALT & CTRL bits, is there any other bit selected?
 210+ 0DD5 20 12                        jr      NZ,FINDKEY      ; yes, go to check which one
 211+ 0DD7 7B           NOKEYPRSD:      ld      A,E             ; no key pressed, load current output port
 212+ 0DD8 0F                           rrca                    ; rotate right by 1
 213+ 0DD9 10 B6                        djnz    RPTKBDRD        ; repeat for 8 lines
 214+ 0DDB AF                           xor     A               ; if exit from here, no key has been pressed...
 215+ 0DDC 32 7D 55                     ld      (LASTKEYPRSD),A ; ...so reset the last key cell...
 216+ 0DDF 32 81 55                     ld      (CONTROLKEYS),A ; ...reset contro key flags...
 217+ 0DE2 32 7A 55                     ld      (KBDNPT),A      ; ...no input from keyboard...
 218+ 0DE5 32 7E 55                     ld      (STATUSKEY),A   ; ...no auto-repeat...
 219+ 0DE8 C9                           ret                     ; ...and leave
 220+ 0DE9 1E FF        FINDKEY:        ld      E,$FF           ; counter
 221+ 0DEB 1C           CHKLN:          inc     E               ; E goes from 0 to 7
 222+ 0DEC CB 3F                        srl     A               ; is the first bit reset? (we're looking for a "0", meaning grounded line)
 223+ 0DEE 38 FB                        jr      C,CHKLN         ; no, check next bit
 224+ 0DF0 3A 81 55                     ld      A,(CONTROLKEYS) ; load control key flags
 225+ 0DF3 21 0C 0F                     ld      HL,KBMAP        ; normal keymap
 226+ 0DF6 FE 01                        cp      $01             ; SHIFT flag?
 227+ 0DF8 20 05                        jr      NZ,CHKCTRL      ; no, jump over
 228+ 0DFA 21 4C 0F                     ld      HL,KBMAP_SFT    ; SHIFT keymap
 229+ 0DFD 18 10                        jr      LOADMAP         ; and load it
 230+ 0DFF FE 02        CHKCTRL:        cp      $02             ; CTRL flag?
 231+ 0E01 20 05                        jr      NZ,CHKALT       ; no, jump over
 232+ 0E03 21 CC 0F                     ld      HL,KBMAP_CTRL   ; CTRL map
 233+ 0E06 18 07                        jr      LOADMAP         ; and load it
 234+ 0E08 FE 04        CHKALT:         cp      $04             ; ALT flag?
 235+ 0E0A 20 03                        jr      NZ,LOADMAP      ; no, check over
 236+ 0E0C 21 8C 0F                     ld      HL,KBMAP_ALT    ; ALT map
 237+ 0E0F 05           LOADMAP:        dec     B               ; decrement row # (rows go from 0 to 7)
 238+ 0E10 48                           ld      C,B             ; move B into C and...
 239+ 0E11 CB 21                        sla     C               ; ...multiply it...
 240+ 0E13 CB 21                        sla     C               ; ...by 8 to find...
 241+ 0E15 CB 21                        sla     C               ; ...the current row into the matrix
 242+ 0E17 06 00                        ld      B,$00           ; reset B
 243+ 0E19 09                           add     HL,BC           ; find the address of the current row
 244+ 0E1A 50                           ld      D,B             ; reset D
 245+ 0E1B 19                           add     HL,DE           ; find the current column - now (HL) stores the pressed key
 246+ 0E1C 3A 7D 55                     ld      A,(LASTKEYPRSD) ; load the last key pressed
 247+ 0E1F BE                           cp      (HL)            ; is it the same key?
 248+ 0E20 20 41                        jr      NZ,NEWKEY       ; no, it's a new key
 249+ 0E22 44 4D                        ld      BC,HL           ; store address of current keycode
 250+ 0E24 2A 20 55                     ld      HL,(TMRCNT)     ; load current system timer
 251+ 0E27 ED 5B 7F 55                  ld      DE,(KEYTMR)     ; load auto-repeat timer
 252+ 0E2B 3A 7E 55                     ld      A,(STATUSKEY)   ; yes, load current status of auto-repeat
 253+ 0E2E FE 01                        cp      $01             ; is it initial pressure?
 254+ 0E30 20 1F                        jr      NZ,CHKAUTO      ; no, jump over
 255+ 0E32 AF                           xor     A               ; clear Carry
 256+ 0E33 ED 52                        sbc     HL,DE           ; startint time - actual time
 257+ 0E35 16 00                        ld      D,$00           ; 64 ths/s > 640 ms
 258+ 0E37 3A F1 53                     ld      A,(KEYDEL)
 259+ 0E3A 5F                           ld      E,A
 260+ 0E3B CD F9 40                     call    CMP16           ; time elapsed is >= $40?
 261+ 0E3E DA B3 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 262+ 0E41 3E 02        SETNEWAUTO:     ld      A,$02           ; yes set status to...
 263+ 0E43 32 7E 55                     ld      (STATUSKEY),A   ; ...auto-repeat
 264+ 0E46 2A 20 55                     ld      HL,(TMRCNT)     ; load system timer
 265+ 0E49 22 7F 55                     ld      (KEYTMR),HL     ; store starting time
 266+ 0E4C 60 69                        ld      HL,BC           ; retrieve address of current keycode
 267+ 0E4E C3 70 0E                     jp      SENDKEY         ; send key
 268+ 0E51 AF           CHKAUTO:        xor     A               ; clear Carry
 269+ 0E52 ED 52                        sbc     HL,DE           ; computer interval between initial pressure of key and current time
 270+ 0E54 16 00                        ld      D,$00
 271+ 0E56 3A F2 53                     ld      A,(AUTOKE)
 272+ 0E59 5F                           ld      E,A             ; auto-repeat delay into DE
 273+ 0E5A CD F9 40                     call    CMP16           ; check if interval is greater than delay
 274+ 0E5D DA B3 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 275+ 0E60 C3 41 0E                     jp      SETNEWAUTO      ; set new loop and send key
 276+ 0E63 AF           NEWKEY:         xor     A               ; set initial state...
 277+ 0E64 3C                           inc     A               ; ...for auto-repeat...
 278+ 0E65 32 7E 55                     ld      (STATUSKEY),A   ; ...1=pressure init
 279+ 0E68 ED 4B 20 55                  ld      BC,(TMRCNT)     ; load current system timer
 280+ 0E6C ED 43 7F 55                  ld      (KEYTMR),BC     ; set starting time
 281+ 0E70 7E           SENDKEY:        ld      A,(HL)          ; then, load key...
 282+ 0E71 32 7D 55                     ld      (LASTKEYPRSD),A ; ...store it...
 283+ 0E74 32 7C 55                     ld      (TMPKEYBFR),A   ; ...insert it into the INKEY buffer...
 284+ 0E77 32 3D 55                     ld      (CHR4VID),A     ; ...and store char for video
 285+ 0E7A FE 03                        cp      CTRLC           ; is it RUN/STOP?
 286+ 0E7C 20 05                        jr      NZ,CNTKBCK      ; no, jump over
 287+ 0E7E CD FD 01                     call    CHARINTOBFR     ; yes, send directly to buffer and...
 288+ 0E81 18 30                        jr      LVKBRDCHK2      ; ...leave
 289+ 0E83 01 00 08     CNTKBCK:        ld      BC,$0800        ; 8 FN keys (B), FN key number (C)
 290+ 0E86 21 04 0F                     ld      HL,FNKEYSORD    ; FN keys codes
 291+ 0E89 BE           CHKFNK:         cp      (HL)            ; is it an FN key?
 292+ 0E8A CA B8 0E                     jp      Z,PRNTFNKEY     ; yes, jump over
 293+ 0E8D 0C                           inc     C               ; next FN key
 294+ 0E8E 23                           inc     HL              ; next FN key code
 295+ 0E8F 10 F8                        djnz    CHKFNK          ; continue for 8 FN keys
 296+ 0E91 3E 01        SNDKEYTOBFR:    ld      A,$01           ; normal key - set input flag
 297+ 0E93 32 7A 55                     ld      (KBDNPT),A      ; to keyboard
 298+ 0E96 3A 3C 55                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 299+ 0E99 B7                           or      A               ; is the print-on-video disabled?
 300+ 0E9A CA A3 0E                     jp      Z,PUTCHRBUF     ; yes, so send char to input buffer
 301+ 0E9D 3A 3A 55                     ld      A,(CRSR_STATE)  ; check cursor state
 302+ 0EA0 B7                           or      A               ; is it 0 (cursor OFF)?
 303+ 0EA1 20 0D                        jr      NZ,PNT2VD       ; no, print on screen
 304+ 0EA3 AF           PUTCHRBUF:      xor     A
 305+ 0EA4 32 7A 55                     ld      (KBDNPT),A      ; if send to input buffer, set RETURN as from BASIC
 306+ 0EA7 3A 7C 55                     ld      A,(TMPKEYBFR)   ; retrieve char
 307+ 0EAA CD FD 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 308+ 0EAD C3 B3 0E                     jp      LVKBRDCHK2      ; ...and leave
 309+ 0EB0 CD 5A 07     PNT2VD:         call    CHAR2VID        ; send char to video
 310+ 0EB3 AF           LVKBRDCHK2:     xor     A
 311+ 0EB4 32 81 55                     ld      (CONTROLKEYS),A ; reset control key flags
 312+ 0EB7 C9           LVKBRDCHK:      ret                     ; return to caller: the current key code is into TMPKEYBFR
 313+ 0EB8                              ; manage FN keys
 314+ 0EB8 57           PRNTFNKEY:      ld      D,A             ; copy A into D
 315+ 0EB9 2A ED 53                     ld      HL,(LINEAT)     ; Get current line number
 316+ 0EBC 23                           inc     HL              ; -1 means direct statement
 317+ 0EBD 7C                           ld      A,H
 318+ 0EBE B5                           or      L
 319+ 0EBF 7A                           ld      A,D             ; retrieve char
 320+ 0EC0 20 CF                        jr      NZ,SNDKEYTOBFR  ; indirect mode - just send FN key code to buffer
 321+ 0EC2 79                           ld      A,C             ; direct mode, so print text - first, get FN key number
 322+ 0EC3 87                           add     A,A
 323+ 0EC4 87                           add     A,A
 324+ 0EC5 87                           add     A,A
 325+ 0EC6 87                           add     A,A             ; FN key number * 16
 326+ 0EC7 4F                           ld      C,A             ; move it into C
 327+ 0EC8 06 00                        ld      B,$00           ; reset B, to get offset
 328+ 0ECA 21 F3 53                     ld      HL,FNKEYS       ; load address of FN keys texts
 329+ 0ECD 09                           add     HL,BC           ; get correct text address
 330+ 0ECE 06 10                        ld      B,$10           ; 16 chars
 331+ 0ED0 7E           LDFNKEYCHR:     ld      A,(HL)          ; load char
 332+ 0ED1 A7                           and     A               ; null char?
 333+ 0ED2 CA B3 0E                     jp      Z,LVKBRDCHK2    ; yes, so leave
 334+ 0ED5 57                           ld      D,A             ; pass char into D
 335+ 0ED6 3A 3C 55                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 336+ 0ED9 B7                           or      A               ; is the print-on-video disabled?
 337+ 0EDA CA EA 0E                     jp      Z,PUTCHRBUF1    ; yes, so send char to input buffer
 338+ 0EDD 3A 3A 55                     ld      A,(CRSR_STATE)  ; check cursor state
 339+ 0EE0 B7                           or      A               ; is it 0 (cursor OFF)?
 340+ 0EE1 C4 F7 0E                     call    NZ,PRNTFNK      ; no, print on screen
 341+ 0EE4 23           CNTFNK:         inc     HL              ; next char
 342+ 0EE5 10 E9                        djnz    LDFNKEYCHR      ; repeat for max. 16 chars
 343+ 0EE7 C3 B3 0E                     jp      LVKBRDCHK2      ; leave
 344+ 0EEA AF           PUTCHRBUF1:     xor     A               ; if send to input buffer,...
 345+ 0EEB 32 7A 55                     ld      (KBDNPT),A      ; ...set input as from BASIC
 346+ 0EEE 7A                           ld      A,D             ; retrieve char
 347+ 0EEF E5                           push    HL              ; store HL
 348+ 0EF0 CD FD 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 349+ 0EF3 E1                           pop     HL              ; retrieve HL
 350+ 0EF4 C3 E4 0E                     jp      CNTFNK          ; repeat
 351+ 0EF7 7A           PRNTFNK:        ld      A,D             ; recover char
 352+ 0EF8 32 3D 55                     ld      (CHR4VID),A     ; store char for printing
 353+ 0EFB 3E 01                        ld      A,$01           ; normal key - set input flag
 354+ 0EFD 32 7A 55                     ld      (KBDNPT),A      ; to keyboard
 355+ 0F00 CD 5A 07                     call    CHAR2VID        ; print on screen
 356+ 0F03 C9                           ret                     ; return to caller
 357+ 0F04
 358+ 0F04
 359+ 0F04              ;-----------------------------------------------------------------------
 360+ 0F04 01 02 04 05  FNKEYSORD:      defb 1,2,4,5,6,22,23,24                 ; order of FN Keys
 360+ 0F08 06 16 17 18
 361+ 0F0C              ;-----------------------------------------------------------------------
 362+ 0F0C              ; key codes
 363+ 0F0C 31 19 0E 03  KBMAP:          defb '1',25,14,3,' ',16,'q','2'         ; 25=HOME  14=CTRL  3=RUN/STOP 16=C=
 363+ 0F10 20 10 71 32
 364+ 0F14 33 77 61 14                  defb '3','w','a',20,'z','s','e','4'     ; 20=SHIFT
 364+ 0F18 7A 73 65 34
 365+ 0F1C 35 72 64 78                  defb '5','r','d','x','c','f','t','6'
 365+ 0F20 63 66 74 36
 366+ 0F24 37 79 67 76                  defb '7','y','g','v','b','h','u','8'
 366+ 0F28 62 68 75 38
 367+ 0F2C 39 69 6A 6E                  defb '9','i','j','n','m','k','o','0'
 367+ 0F30 6D 6B 6F 30
 368+ 0F34 1F 70 6C 2C                  defb 31,'p','l',',','.',':','-',30      ; 31=CURSOR DOWN  30=CURSOR UP
 368+ 0F38 2E 3A 2D 1E
 369+ 0F3C 1C 2A 3B 2F                  defb 28,'*',';','/',27,'=','+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 369+ 0F40 1B 3D 2B 1D
 370+ 0F44 08 0D FC 40                  defb 8,13,252,'@',1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 370+ 0F48 01 02 04 18
 371+ 0F4C
 372+ 0F4C              ; shifted codes - not all the keys have the shifted version
 373+ 0F4C 21 0C 0E 03  KBMAP_SFT:      defb '!',12,14,3,' ',16,'Q',34          ; 12=CLEAR  14=CTRL  3=RUN/STOP 16=C=   34="
 373+ 0F50 20 10 51 22
 374+ 0F54 23 57 41 14                  defb '#','W','A',20,'Z','S','E','$'     ; 20=SHIFT
 374+ 0F58 5A 53 45 24
 375+ 0F5C 25 52 44 58                  defb '%','R','D','X','C','F','T','&'
 375+ 0F60 43 46 54 26
 376+ 0F64 27 59 47 56                  defb 39,'Y','G','V','B','H','U','('     ; 39='
 376+ 0F68 42 48 55 28
 377+ 0F6C 29 49 4A 4E                  defb ')','I','J','N','M','K','O',94     ; 94=^
 377+ 0F70 4D 4B 4F 5E
 378+ 0F74 1F 50 4C 3C                  defb 31,'P','L','<','>','[','_',30      ; 31=CURSOR DOWN  30=CURSOR UP
 378+ 0F78 3E 5B 5F 1E
 379+ 0F7C 1C 2A 5D 3F                  defb 28,'*',']','?',27,198,'+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 379+ 0F80 1B C6 2B 1D
 380+ 0F84 1A 0D D3 40                  defb 26,13,211,'@',5,6,22,23            ; 26=INSERT, 211=â¬  5=F4  6=F5  22=F6  23=F7
 380+ 0F88 05 06 16 17
 381+ 0F8C
 382+ 0F8C              ; ALT (C=) codes - not all the keys have the alt-ed version
 383+ 0F8C 31 0C 0E 03  KBMAP_ALT:      defb '1',12,14,3,' ',16,222,196         ; 12=CLEAR  14=CTRL  3=RUN/STOP  16=C=  34="
 383+ 0F90 20 10 DE C4
 384+ 0F94 33 DD 85 14                  defb '3',221,133,20,131,130,165,'4'     ; 20=SHIFT
 384+ 0F98 83 82 A5 34
 385+ 0F9C 35 A2 A6 84                  defb '5',162,166,132,157,163,168,'6'
 385+ 0FA0 9D A3 A8 36
 386+ 0FA4 37 AB A9 A1                  defb '7',171,169,161,158,172,213,'8'    ;
 386+ 0FA8 9E AC D5 38
 387+ 0FAC 39 D6 D8 9F                  defb '9',214,216,159,160,215,135,195    ;
 387+ 0FB0 A0 D7 87 C3
 388+ 0FB4 1F 88 8A C1                  defb 31,136,138,193,192,123,144,30      ; 31=CURSOR DOWN  123={  30=CURSOR UP
 388+ 0FB8 C0 7B 90 1E
 389+ 0FBC 1C 8F 7D FE                  defb 28,143,125,254,27,209,148,29       ; 28=CURSOR LEFT  125=}  27=ESCAPE  29=CURSOR RIGHT
 389+ 0FC0 1B D1 94 1D
 390+ 0FC4 08 0D E0 89                  defb 8,13,224,137,5,6,22,23             ; 8=DEL(backspace)  13=RETURN  252=Â£  5=F4  6=F5  22=F6  23=F7
 390+ 0FC8 05 06 16 17
 391+ 0FCC
 392+ 0FCC              ; CTRL codes - not all the keys have the control-ed version
 393+ 0FCC 31 19 0E 03  KBMAP_CTRL:     defb '1',25,14,3,' ',16,154,'2'         ; 25=HOME  14=CTRL  3=RUN/STOP  16=C=
 393+ 0FD0 20 10 9A 32
 394+ 0FD4 33 9C 95 14                  defb '3',156,149,20,152,150,153,'4'     ; 20=SHIFT
 394+ 0FD8 98 96 99 34
 395+ 0FDC 35 9B B0 97                  defb '5',155,176,151,177,175,165,'6'
 395+ 0FE0 B1 AF A5 36
 396+ 0FE4 37 A6 A8 B2                  defb '7',166,168,178,179,169,167,'8'
 396+ 0FE8 B3 A9 A7 38
 397+ 0FEC 39 B8 AA AC                  defb '9',184,170,172,171,181,164,'0'
 397+ 0FF0 AB B5 A4 30
 398+ 0FF4 1F A3 AD 2C                  defb 31,163,173,',','.',':',186,30      ; 31=CURSOR DOWN  30=CURSOR UP
 398+ 0FF8 2E 3A BA 1E
 399+ 0FFC 1C E1 3B 2F                  defb 28,225,';','/',27,212,185,29       ; 28=CURSOR LEFT  27=ESCAPE  212=Ï  29=CURSOR RIGHT
 399+ 1000 1B D4 B9 1D
 400+ 1004 08 0D BD A2                  defb 8,13,189,162,1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 400+ 1008 01 02 04 18
# file closed: ../include/psg/psg-1.1.asm
  73  100C
  74  100C              ; include the latest version of the LM80C 64K BASIC interpreter
  75  100C                  INCLUDE "../include/basic/basic-1.10.asm"
# file opened: ../include/basic/basic-1.10.asm
   1+ 100C              ; ------------------------------------------------------------------------------
   2+ 100C              ; LM80C BASIC (32K/64K) - R3.24
   3+ 100C              ; ------------------------------------------------------------------------------
   4+ 100C              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 100C              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 100C              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 100C              ; kind of warranty: you can use them at your own risk.
   8+ 100C              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 100C              ; maintain the copyright notices, include this advice and the note to the
  10+ 100C              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 100C              ; redistribuite them.
  12+ 100C              ; https://www.leonardomiliani.com
  13+ 100C              ;
  14+ 100C              ; Please support me by visiting the following links:
  15+ 100C              ; Main project page: https://www.leonardomiliani.com
  16+ 100C              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 100C              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 100C              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 100C              ; ------------------------------------------------------------------------------
  20+ 100C              ; LM80C BASIC 64K - originally based on the following NASCOM BASIC versions:
  21+ 100C              ; 4.7  - original version by NASCOM/MICROSOFT
  22+ 100C              ; 4.7b - modified version by Grant Searle (additional commands & functions)
  23+ 100C
  24+ 100C
  25+ 100C              ;------------------------------------------------------------------------------
  26+ 100C              ;  L M 8 0 C   B A S I C
  27+ 100C              ;------------------------------------------------------------------------------
  28+ 100C
  29+ 100C              ; GENERAL EQUATES
  30+ 100C
  31+ 100C              NLLCR           equ     $00             ; null char (used as space/empty char in video prints)
  32+ 100C              CTRLC           equ     $03             ; Control "C"
  33+ 100C              CTRLG           equ     $07             ; Control "G"
  34+ 100C              BKSP            equ     $08             ; Back space
  35+ 100C              LF              equ     $0A             ; Line feed
  36+ 100C              CS              equ     $0C             ; Clear screen
  37+ 100C              CR              equ     $0D             ; Carriage return
  38+ 100C              CTRLO           equ     $0F             ; Control "O"
  39+ 100C              CTRLQ           equ     $11             ; Control "Q"
  40+ 100C              CTRLR           equ     $12             ; Control "R"
  41+ 100C              CTRLS           equ     $13             ; Control "S"
  42+ 100C              CTRLU           equ     $15             ; Control "U"
  43+ 100C              HOME            equ     $19             ; Home (cursor at 0,0)
  44+ 100C              ESC             equ     $1B             ; Escape
  45+ 100C              SPC             equ     $20             ; Space
  46+ 100C              DEL             equ     $7F             ; Delete
  47+ 100C              INSRT           equ     $1A             ; Insert Key
  48+ 100C              ; cursor ASCII codes
  49+ 100C              CRSLFT          equ     $1C             ; cursor left
  50+ 100C              CRSRGT          equ     $1D             ; cursor right
  51+ 100C              CRSUP           equ     $1E             ; cursor up
  52+ 100C              CRSDN           equ     $1F             ; cursor down
  53+ 100C
  54+ 100C
  55+ 100C              ;-------------------------------------------------------------------------
  56+ 100C              ; BASIC ERROR MESSAGES
  57+ 100C              ; the interpreter looks for a single-byte code in the following list,
  58+ 100C              ; then loads the corresponding memory pointer in "ERRTBL" table to
  59+ 100C              ; find where to retrieve the message text in "ERRORS"
  60+ 100C
  61+ 100C              ; BASIC ERROR CODE VALUES
  62+ 100C              ; These values act as an offset to point to the error message into the error table
  63+ 100C              ; must be incremented by 2 because they point to a word address jump
  64+ 100C              NF      equ     $00     ; NEXT without FOR
  65+ 100C              SN      equ     $02     ; Syntax error
  66+ 100C              RG      equ     $04     ; RETURN without GOSUB
  67+ 100C              OD      equ     $06     ; Out of DATA
  68+ 100C              FC      equ     $08     ; Function call error
  69+ 100C              OV      equ     $0A     ; Overflow
  70+ 100C              OM      equ     $0C     ; Out of memory
  71+ 100C              UL      equ     $0E     ; Undefined line number
  72+ 100C              BS      equ     $10     ; Bad subscript
  73+ 100C              DD      equ     $12     ; Re-Dimensioned array
  74+ 100C              DZ      equ     $14     ; Division by zero (/0)
  75+ 100C              ID      equ     $16     ; Illegal direct
  76+ 100C              TM      equ     $18     ; Type mis-match
  77+ 100C              OS      equ     $1A     ; Out of string space
  78+ 100C              LS      equ     $1C     ; String too long
  79+ 100C              ST      equ     $1E     ; String formula too complex
  80+ 100C              CN      equ     $20     ; Can't continue
  81+ 100C              UF      equ     $22     ; Undefined FN function
  82+ 100C              MO      equ     $24     ; Missing operand
  83+ 100C              HX      equ     $26     ; HEX error
  84+ 100C              BN      equ     $28     ; BIN error
  85+ 100C              GM      equ     $2A     ; No Graphics Mode
  86+ 100C              SC      equ     $2C     ; Serial configuration
  87+ 100C              SA      equ     $2E     ; Serial port already open
  88+ 100C              SO      equ     $30     ; Serial buffer overrun
  89+ 100C              HP      equ     $32     ; HELP call
  90+ 100C              IM      equ     $34     ; Illegal indirect
  91+ 100C              NR      equ     $36     ; Device not ready
  92+ 100C              D0      equ     $38     ; DOS not enabled
  93+ 100C              D1      equ     $3A     ; Disk/File name error
  94+ 100C              D2      equ     $3C     ; Disk geometry error
  95+ 100C              D3      equ     $3E     ; Save error
  96+ 100C              D4      equ     $40     ; Load error
  97+ 100C              D5      equ     $42     ; Disk full error
  98+ 100C              D6      equ     $44     ; Duplicate file name error
  99+ 100C              D7      equ     $46     ; DOS version error
 100+ 100C              D8      equ     $48     ; File not found error
 101+ 100C
 102+ 100C
 103+ 100C              ; BASIC ERROR POINTER TABLE
 104+ 100C              ERRTBL: equ $
 105+ 100C 56 10        NFPTR:  defw    NFMSG
 106+ 100E 67 10        SNPTR:  defw    SNMSG
 107+ 1010 6E 10        RGPTR:  defw    RGMSG
 108+ 1012 83 10        ODPTR:  defw    ODMSG
 109+ 1014 8F 10        FCPTR:  defw    FCMSG
 110+ 1016 A5 10        OVPTR:  defw    OVMSG
 111+ 1018 AE 10        OMPTR:  defw    OMMSG
 112+ 101A BC 10        ULPTR:  defw    ULMSG
 113+ 101C CB 10        BSPTR:  defw    BSMSG
 114+ 101E D9 10        DDPTR:  defw    DDMSG
 115+ 1020 EE 10        DZPTR:  defw    DZMSG
 116+ 1022 FF 10        IDPTR:  defw    IDMSG
 117+ 1024 13 11        TMPTR:  defw    TMMSG
 118+ 1026 22 11        OSPTR:  defw    OSMSG
 119+ 1028 36 11        LSPTR:  defw    LSMSG
 120+ 102A 46 11        STPTR:  defw    STMSG
 121+ 102C 61 11        CNPTR:  defw    CNMSG
 122+ 102E 70 11        UFPTR:  defw    UFMSG
 123+ 1030 86 11        MOPTR:  defw    MOMSG
 124+ 1032 96 11        HXPTR:  defw    HXMSG
 125+ 1034 A1 11        BNPTR:  defw    BNMSG
 126+ 1036 AC 11        GMPRT:  defw    GMMSG
 127+ 1038 BD 11        SCPTR:  defw    SCMSG
 128+ 103A D2 11        SAPTR:  defw    SAMSG
 129+ 103C EB 11        SOPTR:  defw    SOMSG
 130+ 103E 01 12        HPPTR:  defw    HPMSG
 131+ 1040 0B 12        IMPRT:  defw    IMMSG
 132+ 1042 21 12        NRPRT:  defw    NRMSG
 133+ 1044 32 12        D0PTR:  defw    D0MSG
 134+ 1046 42 12        D1PRT:  defw    D1MSG
 135+ 1048 4E 12        D2PRT:  defw    D2MSG
 136+ 104A 5C 12        D3PRT:  defw    D3MSG
 137+ 104C 61 12        D4PTR:  defw    D4MSG
 138+ 104E 66 12        D5PTR:  defw    D5MSG
 139+ 1050 70 12        D6PTR:  defw    D6MSG
 140+ 1052 84 12        D7PRT:  defw    D7MSG
 141+ 1054 90 12        D8PTR:  defw    D8MSG
 142+ 1056
 143+ 1056
 144+ 1056              ; BASIC ERROR MESSAGE LIST
 145+ 1056              ERRORS  equ $
 146+ 1056 4E 45 58 54  NFMSG:  defb    "NEXT Without FOR",0
 146+ 105A 20 57 69 74
 146+ 105E 68 6F 75 74
 146+ 1062 20 46 4F 52
 146+ 1066 00
 147+ 1067 53 79 6E 74  SNMSG:  defb    "Syntax",0
 147+ 106B 61 78 00
 148+ 106E 52 45 54 55  RGMSG:  defb    "RETURN without GOSUB",0
 148+ 1072 52 4E 20 77
 148+ 1076 69 74 68 6F
 148+ 107A 75 74 20 47
 148+ 107E 4F 53 55 42
 148+ 1082 00
 149+ 1083 4F 75 74 20  ODMSG:  defb    "Out of DATA",0
 149+ 1087 6F 66 20 44
 149+ 108B 41 54 41 00
 150+ 108F 49 6C 6C 65  FCMSG:  defb    "Illegal Function Call",0
 150+ 1093 67 61 6C 20
 150+ 1097 46 75 6E 63
 150+ 109B 74 69 6F 6E
 150+ 109F 20 43 61 6C
 150+ 10A3 6C 00
 151+ 10A5 4F 76 65 72  OVMSG:  defb    "Overflow",0
 151+ 10A9 66 6C 6F 77
 151+ 10AD 00
 152+ 10AE 4F 75 74 20  OMMSG:  defb    "Out of Memory",0
 152+ 10B2 6F 66 20 4D
 152+ 10B6 65 6D 6F 72
 152+ 10BA 79 00
 153+ 10BC 55 6E 64 65  ULMSG:  defb    "Undefined Line",0
 153+ 10C0 66 69 6E 65
 153+ 10C4 64 20 4C 69
 153+ 10C8 6E 65 00
 154+ 10CB 42 61 64 20  BSMSG:  defb    "Bad Subscript",0
 154+ 10CF 53 75 62 73
 154+ 10D3 63 72 69 70
 154+ 10D7 74 00
 155+ 10D9 52 65 2D 44  DDMSG:  defb    "Re-Dimensioned Array",0
 155+ 10DD 69 6D 65 6E
 155+ 10E1 73 69 6F 6E
 155+ 10E5 65 64 20 41
 155+ 10E9 72 72 61 79
 155+ 10ED 00
 156+ 10EE 44 69 76 69  DZMSG:  defb    "Division by Zero",0
 156+ 10F2 73 69 6F 6E
 156+ 10F6 20 62 79 20
 156+ 10FA 5A 65 72 6F
 156+ 10FE 00
 157+ 10FF 49 6C 6C 65  IDMSG:  defb    "Illegal Direct Mode",0
 157+ 1103 67 61 6C 20
 157+ 1107 44 69 72 65
 157+ 110B 63 74 20 4D
 157+ 110F 6F 64 65 00
 158+ 1113 54 79 70 65  TMMSG:  defb    "Type Mis-match",0
 158+ 1117 20 4D 69 73
 158+ 111B 2D 6D 61 74
 158+ 111F 63 68 00
 159+ 1122 4F 75 74 20  OSMSG:  defb    "Out of String Space",0
 159+ 1126 6F 66 20 53
 159+ 112A 74 72 69 6E
 159+ 112E 67 20 53 70
 159+ 1132 61 63 65 00
 160+ 1136 53 74 72 69  LSMSG:  defb    "String Too Long",0
 160+ 113A 6E 67 20 54
 160+ 113E 6F 6F 20 4C
 160+ 1142 6F 6E 67 00
 161+ 1146 53 74 72 69  STMSG:  defb    "String Formula Too Complex",0
 161+ 114A 6E 67 20 46
 161+ 114E 6F 72 6D 75
 161+ 1152 6C 61 20 54
 161+ 1156 6F 6F 20 43
 161+ 115A 6F 6D 70 6C
 161+ 115E 65 78 00
 162+ 1161 43 61 6E 27  CNMSG:  defb    "Can't Continue",0
 162+ 1165 74 20 43 6F
 162+ 1169 6E 74 69 6E
 162+ 116D 75 65 00
 163+ 1170 55 6E 64 65  UFMSG:  defb    "Undefined FN Function",0
 163+ 1174 66 69 6E 65
 163+ 1178 64 20 46 4E
 163+ 117C 20 46 75 6E
 163+ 1180 63 74 69 6F
 163+ 1184 6E 00
 164+ 1186 4D 69 73 73  MOMSG:  defb    "Missing Operand",0
 164+ 118A 69 6E 67 20
 164+ 118E 4F 70 65 72
 164+ 1192 61 6E 64 00
 165+ 1196 48 45 58 20  HXMSG:  defb    "HEX Format",0
 165+ 119A 46 6F 72 6D
 165+ 119E 61 74 00
 166+ 11A1 42 49 4E 20  BNMSG:  defb    "BIN Format",0
 166+ 11A5 46 6F 72 6D
 166+ 11A9 61 74 00
 167+ 11AC 4E 6F 20 47  GMMSG:  defb    "No Graphics Mode",0
 167+ 11B0 72 61 70 68
 167+ 11B4 69 63 73 20
 167+ 11B8 4D 6F 64 65
 167+ 11BC 00
 168+ 11BD 53 65 72 69  SCMSG:  defb    "Serial Configuration",0
 168+ 11C1 61 6C 20 43
 168+ 11C5 6F 6E 66 69
 168+ 11C9 67 75 72 61
 168+ 11CD 74 69 6F 6E
 168+ 11D1 00
 169+ 11D2 53 65 72 69  SAMSG:  defb    "Serial Port Already Open",0
 169+ 11D6 61 6C 20 50
 169+ 11DA 6F 72 74 20
 169+ 11DE 41 6C 72 65
 169+ 11E2 61 64 79 20
 169+ 11E6 4F 70 65 6E
 169+ 11EA 00
 170+ 11EB 53 65 72 69  SOMSG:  defb    "Serial Buffer Overrun",0
 170+ 11EF 61 6C 20 42
 170+ 11F3 75 66 66 65
 170+ 11F7 72 20 4F 76
 170+ 11FB 65 72 72 75
 170+ 11FF 6E 00
 171+ 1201 48 45 4C 50  HPMSG:  defb    "HELP Call",0
 171+ 1205 20 43 61 6C
 171+ 1209 6C 00
 172+ 120B 49 6C 6C 65  IMMSG:  defb    "Illegal Indirect Mode",0
 172+ 120F 67 61 6C 20
 172+ 1213 49 6E 64 69
 172+ 1217 72 65 63 74
 172+ 121B 20 4D 6F 64
 172+ 121F 65 00
 173+ 1221 44 65 76 69  NRMSG:  defb    "Device Not Ready",0
 173+ 1225 63 65 20 4E
 173+ 1229 6F 74 20 52
 173+ 122D 65 61 64 79
 173+ 1231 00
 174+ 1232 44 4F 53 20  D0MSG:  defb    "DOS Not Enabled",0
 174+ 1236 4E 6F 74 20
 174+ 123A 45 6E 61 62
 174+ 123E 6C 65 64 00
 175+ 1242 4E 61 6D 65  D1MSG:  defb    "Name String",0
 175+ 1246 20 53 74 72
 175+ 124A 69 6E 67 00
 176+ 124E 44 69 73 6B  D2MSG:  defb    "Disk Geometry",0
 176+ 1252 20 47 65 6F
 176+ 1256 6D 65 74 72
 176+ 125A 79 00
 177+ 125C 53 61 76 65  D3MSG:  defb    "Save",0
 177+ 1260 00
 178+ 1261 4C 6F 61 64  D4MSG:  defb    "Load",0
 178+ 1265 00
 179+ 1266 44 69 73 6B  D5MSG:  defb    "Disk Full",0
 179+ 126A 20 46 75 6C
 179+ 126E 6C 00
 180+ 1270 44 75 70 6C  D6MSG:  defb    "Duplicate File Name",0
 180+ 1274 69 63 61 74
 180+ 1278 65 20 46 69
 180+ 127C 6C 65 20 4E
 180+ 1280 61 6D 65 00
 181+ 1284 44 4F 53 20  D7MSG:  defb    "DOS Version",0
 181+ 1288 56 65 72 73
 181+ 128C 69 6F 6E 00
 182+ 1290 46 69 6C 65  D8MSG:  defb    "File Not Found",0
 182+ 1294 20 4E 6F 74
 182+ 1298 20 46 6F 75
 182+ 129C 6E 64 00
 183+ 129F
 184+ 129F
 185+ 129F              ;-----------------------------------------------------------------------------
 186+ 129F              ; STARTING POINTS FOR BASIC BOOT
 187+ 129F              ; COLD: reset every memory pointer, acting as a power-up boot
 188+ 129F              ; WARM: preserve program in memory, keeping every current pointer
 189+ 129F
 190+ 129F C3 A5 12     COLD:   jp      STARTB          ; Jump for cold start
 191+ 12A2 C3 7B 13     WARM:   jp      WARMST          ; Jump for warm start
 192+ 12A5
 193+ 12A5 C3 AC 12     STARTB: jp      CSTART          ; Jump to initialise
 194+ 12A8 D1 1D                defw    DEINT           ; Get integer -32768 to 32767
 195+ 12AA 96 25                defw    ABPASS          ; Return integer in AB
 196+ 12AC 21 9C 53     CSTART: ld      HL,WRKSPC       ; Start of workspace RAM
 197+ 12AF F9                   ld      SP,HL           ; Set up a temporary stack
 198+ 12B0 C3 E4 40             jp      INITST          ; Go to initialise
 199+ 12B3
 200+ 12B3 21 6B 16     SYSINIT:ld      HL,INITAB       ; Initialise workspace
 201+ 12B6 01 DC 00             ld      BC,INITBE-INITAB+3; Bytes to copy
 202+ 12B9 11 9C 53             ld      DE,WRKSPC       ; Into workspace RAM
 203+ 12BC ED B0                ldir                    ; Copy data
 204+ 12BE EB                   ex      DE,HL           ; Copy DE into HL
 205+ 12BF F9                   ld      SP,HL           ; Temporary stack
 206+ 12C0 CD 34 19             call    CLREG           ; Clear registers and stack
 207+ 12C3 CD E8 1F             call    PRNTCRLF        ; Output CRLF
 208+ 12C6 32 CF 54             ld      (BUFFER+88+1),A ; Mark end of buffer
 209+ 12C9 32 A9 55             ld      (PROGST),A      ; Initialise program area
 210+ 12CC 18 13                jr      MNOASK          ; usually, don't ask for memory top (only when there are errors)
 211+ 12CE 21 FF 13     MSIZE:  ld      HL,MEMMSG       ; Point to message
 212+ 12D1 CD B4 26             call    PRS             ; Output "Memory size"
 213+ 12D4 CD 51 19             call    PROMPT          ; Get input with '?'
 214+ 12D7 CD 26 09             call    CURSOR_ON       ; enable cursor
 215+ 12DA CD 1B 1D             call    GETCHR          ; Get next character
 216+ 12DD B7                   or      A               ; Set flags
 217+ 12DE C2 F6 12             jp      NZ,TSTMEM       ; If number - Test if RAM there
 218+ 12E1 21 0D 56     MNOASK: ld      HL,STLOOK       ; Point to start of RAM
 219+ 12E4 23           MLOOP:  inc     HL              ; Next byte
 220+ 12E5 7C                   ld      A,H             ; Above address FFFF ?
 221+ 12E6 B5                   or      L
 222+ 12E7 CA 08 13             jp      Z,SETTOP        ; Yes - 64K RAM
 223+ 12EA 7E                   ld      A,(HL)          ; Get contents
 224+ 12EB 47                   ld      B,A             ; Save it
 225+ 12EC 2F                   cpl                     ; Flip all bits
 226+ 12ED 77                   ld      (HL),A          ; Put it back
 227+ 12EE BE                   cp      (HL)            ; RAM there if same
 228+ 12EF 70                   ld      (HL),B          ; Restore old contents
 229+ 12F0 CA E4 12             jp      Z,MLOOP         ; If RAM - test next byte
 230+ 12F3 C3 08 13             jp      SETTOP          ; Top of RAM found
 231+ 12F6
 232+ 12F6 CD EB 1D     TSTMEM: call    ATOH            ; Get high memory into DE
 233+ 12F9 B7                   or      A               ; Set flags on last byte
 234+ 12FA C2 D2 17             jp      NZ,SNERR        ; ?SN Error if bad character
 235+ 12FD EB                   ex      DE,HL           ; Address into HL
 236+ 12FE 2B                   dec     HL              ; Back one byte
 237+ 12FF 3E D9                ld      A,%11011001     ; Test byte
 238+ 1301 46                   ld      B,(HL)          ; Get old contents
 239+ 1302 77                   ld      (HL),A          ; Load test byte
 240+ 1303 BE                   cp      (HL)            ; RAM there if same
 241+ 1304 70                   ld      (HL),B          ; Restore old contents
 242+ 1305 C2 CE 12             jp      NZ,MSIZE        ; Ask again if no RAM
 243+ 1308
 244+ 1308 CD 3B 09     SETTOP: call    CURSOR_OFF      ; disable cursor
 245+ 130B 2B                   dec     HL              ; Back one byte
 246+ 130C 11 0C 56             ld      DE,STLOOK-1     ; See if enough RAM
 247+ 130F CD CC 1A             call    CPDEHL          ; Compare DE with HL
 248+ 1312 DA CE 12             jp      C,MSIZE         ; Ask again if not enough RAM
 249+ 1315 3A 85 55             ld      A,(DOS_EN)      ; read if the user enabled/disabled DOS while booting
 250+ 1318 1F                   rra                     ; is DOS enabled?
 251+ 1319 38 1C                jr      C,SETDSR        ; yes, so jump over
 252+ 131B DD 21 F2 FF          ld      IX,JPDISK+1     ; point to 1st address of DOS jump table
 253+ 131F 06 05                ld      B,$05           ; 5 entries
 254+ 1321 11 C6 1E             ld      DE,REM          ; address of REM routine
 255+ 1324 DD 73 00     CPDSTB: ld      (IX),E
 256+ 1327 DD 23                inc     IX
 257+ 1329 DD 72 00             ld      (IX),D
 258+ 132C DD 23                inc     IX
 259+ 132E DD 23                inc     IX
 260+ 1330 10 F2                djnz    CPDSTB
 261+ 1332 11 F0 FF             ld      DE,0-$0010
 262+ 1335 18 03                jr      SETNOD
 263+ 1337 11 00 F1     SETDSR: ld      DE,0-$0F00      ; no, so reserve RAM occupied by DOS & I/O buffers
 264+ 133A 19           SETNOD: add     HL,DE
 265+ 133B 22 D4 54     SETTRAM:ld      (LSTRAM),HL     ; Save last available RAM
 266+ 133E 11 9C FF             ld      DE,0-100        ; now, reserve 100 bytes for string space
 267+ 1341 19                   add     HL,DE           ; Allocate string space
 268+ 1342 22 EB 53             ld      (STRSPC),HL     ; Save string space
 269+ 1345 CD 0F 19             call    CLRPTR          ; Clear program area
 270+ 1348 2A EB 53             ld      HL,(STRSPC)     ; Get end of memory
 271+ 134B 11 EF FF             ld      DE,0-17         ; Offset for free bytes
 272+ 134E 19                   add     HL,DE           ; Adjust HL
 273+ 134F 11 A9 55             ld      DE,PROGST       ; Start of program text
 274+ 1352 7D                   ld      A,L             ; Get LSB
 275+ 1353 93                   sub     E               ; Adjust it
 276+ 1354 6F                   ld      L,A             ; Re-save
 277+ 1355 7C                   ld      A,H             ; Get MSB
 278+ 1356 9A                   sbc     A,D             ; Adjust it
 279+ 1357 67                   ld      H,A             ; Re-save
 280+ 1358 E5                   push    HL              ; Save bytes free
 281+ 1359 21 A1 13             ld      HL,SIGNON       ; Sign-on message
 282+ 135C CD B4 26             call    PRS             ; Output string
 283+ 135F 3A 85 55             ld      A,(DOS_EN)      ; check if DOS is enabled
 284+ 1362 B7                   or      A
 285+ 1363 28 06                jr      Z,SETTP1        ; no DOS, jump over
 286+ 1365 21 E2 13             ld      HL,DOSMSG       ; DOS message
 287+ 1368 CD B4 26             call    PRS
 288+ 136B 21 8A 13     SETTP1: ld      HL,BLNSPC       ; Empty space
 289+ 136E CD B4 26             call    PRS             ; Output string
 290+ 1371 E1                   pop     HL              ; Get bytes free back
 291+ 1372 CD 53 31             call    PRNTHL          ; Output amount of free memory
 292+ 1375 21 93 13             ld      HL,BFREE        ; " Bytes free" message
 293+ 1378 CD B4 26             call    PRS             ; Output string
 294+ 137B
 295+ 137B 31 7B 54     WARMST: ld      SP,STACK        ; Temporary stack
 296+ 137E CD 34 19     BRKRET: call    CLREG           ; Clear registers and stack
 297+ 1381 CD 78 3E             call    RESFN           ; reset FN keys and auto-repeat
 298+ 1384 CD 26 09             call    CURSOR_ON       ; enable cursor
 299+ 1387 C3 32 18             jp      PRNTOK          ; Go to get command line
 300+ 138A
 301+ 138A 20 20 20 20  BLNSPC: defb    "        ",0    ; 8 empty cells to align the "XXXX Bytes free" message
 301+ 138E 20 20 20 20
 301+ 1392 00
 302+ 1393 20 42 79 74  BFREE:  defb    " Bytes free",CR,CR,0
 302+ 1397 65 73 20 66
 302+ 139B 72 65 65 0D
 302+ 139F 0D 00
 303+ 13A1
 304+ 13A1 4C 4D 38 30  SIGNON: defb    "LM80C BASIC 3.24 ",251,"2021 L.Miliani"
 304+ 13A5 43 20 42 41
 304+ 13A9 53 49 43 20
 304+ 13AD 33 2E 32 34
 304+ 13B1 20 FB 32 30
 304+ 13B5 32 31 20 4C
 304+ 13B9 2E 4D 69 6C
 304+ 13BD 69 61 6E 69
 305+ 13C1 20 5A 38 30          defb    " Z80 BASIC 4.7  ",251,"1978 Microsoft",CR,0
 305+ 13C5 20 42 41 53
 305+ 13C9 49 43 20 34
 305+ 13CD 2E 37 20 20
 305+ 13D1 FB 31 39 37
 305+ 13D5 38 20 4D 69
 305+ 13D9 63 72 6F 73
 305+ 13DD 6F 66 74 0D
 305+ 13E1 00
 306+ 13E2 20 20 20 20  DOSMSG: defb    "     LM80C DOS ","1.04","  Loaded",CR,0
 306+ 13E6 20 4C 4D 38
 306+ 13EA 30 43 20 44
 306+ 13EE 4F 53 20 31
 306+ 13F2 2E 30 34 20
 306+ 13F6 20 4C 6F 61
 306+ 13FA 64 65 64 0D
 306+ 13FE 00
 307+ 13FF
 308+ 13FF 4D 65 6D 6F  MEMMSG: defb    "Memory top",0
 308+ 1403 72 79 20 74
 308+ 1407 6F 70 00
 309+ 140A
 310+ 140A              ; The following list reports all the functions supported by the interpreter.
 311+ 140A              ; To add a custom function, the user must first insert the reserved word here,
 312+ 140A              ; then into the list of the reserved words below, and finally must increment the
 313+ 140A              ; ZSGN token value and all the following ones after ZSGN by 1 for every added
 314+ 140A              ; function.
 315+ 140A
 316+ 140A              ; FUNCTION ADDRESS TABLE (this is a sort of offset table)
 317+ 140A              ; this list must be coherent with the tokens' functions list. This means that every
 318+ 140A              ; entry here must have the corresponding entry in the tokens list.
 319+ 140A C8 2F        FNCTAB: defw    SGN
 320+ 140C 5E 25                defw    TMR         ; added by Leonardo Miliani
 321+ 140E 8C 30                defw    INT
 322+ 1410 DE 2F                defw    ABS_        ; '_' necessary to avoid assembler warnings
 323+ 1412 A2 53                defw    USR
 324+ 1414 74 25                defw    FRE
 325+ 1416 EF 29                defw    INP
 326+ 1418 A2 25                defw    POS
 327+ 141A 52 32                defw    SQR
 328+ 141C 31 33                defw    RND
 329+ 141E 1C 2E                defw    LOG
 330+ 1420 A0 32                defw    EXP
 331+ 1422 A6 33                defw    COS
 332+ 1424 AC 33                defw    SIN
 333+ 1426 0D 34                defw    TAN
 334+ 1428 22 34                defw    ATN
 335+ 142A CB 2A                defw    PEEK
 336+ 142C 8D 34                defw    DEEK
 337+ 142E D2 2A                defw    VPEEK       ; added by Leonardo Miliani
 338+ 1430 A1 2C                defw    VSTAT       ; added by Leonardo Miliani
 339+ 1432 AC 2C                defw    SSTAT       ; added by Leonardo Miliani
 340+ 1434 C0 2C                defw    INKEY       ; added by Leonardo Miliani
 341+ 1436 E4 37                defw    POINT       ; added by Leonardo Miliani
 342+ 1438 86 28                defw    INSTR       ; added by Leonardo Miliani
 343+ 143A 26 28                defw    LEN
 344+ 143C 3E 26                defw    STR
 345+ 143E B6 29                defw    VAL
 346+ 1440 35 28                defw    ASC
 347+ 1442 46 28                defw    CHR
 348+ 1444 D8 3F                defw    HEX         ; added by Grant Searle
 349+ 1446 69 40                defw    BIN         ; added by Grant Searle
 350+ 1448 56 28                defw    LEFT
 351+ 144A 7C 29                defw    RIGHT
 352+ 144C 86 29                defw    MID
 353+ 144E
 354+ 144E              ; RESERVED WORD LIST
 355+ 144E              ; Here are all the reserved words used by the interpreter
 356+ 144E              ; To add custom functions/commands, the user must insert the keyword
 357+ 144E              ; in this list, following the schematic
 358+ 144E C5 4E 44     WORDS:  defb    'E'+$80,"ND"            ; from here the list contains the COMMANDS
 359+ 1451 C6 4F 52             defb    'F'+$80,"OR"
 360+ 1454 CE 45 58 54          defb    'N'+$80,"EXT"
 361+ 1458 C4 41 54 41          defb    'D'+$80,"ATA"
 362+ 145C C9 4E 50 55          defb    'I'+$80,"NPUT"
 362+ 1460 54
 363+ 1461 C4 49 4D             defb    'D'+$80,"IM"
 364+ 1464 D2 45 41 44          defb    'R'+$80,"EAD"
 365+ 1468 CC 45 54             defb    'L'+$80,"ET"
 366+ 146B C7 4F 54 4F          defb    'G'+$80,"OTO"
 367+ 146F D2 55 4E             defb    'R'+$80,"UN"
 368+ 1472 C9 46                defb    'I'+$80,"F"
 369+ 1474 D2 45 53 54          defb    'R'+$80,"ESTORE"
 369+ 1478 4F 52 45
 370+ 147B C7 4F 53 55          defb    'G'+$80,"OSUB"
 370+ 147F 42
 371+ 1480 D2 45 54 55          defb    'R'+$80,"ETURN"
 371+ 1484 52 4E
 372+ 1486 D2 45 4D             defb    'R'+$80,"EM"            ; original REM
 373+ 1489 D3 54 4F 50          defb    'S'+$80,"TOP"
 374+ 148D CF 55 54             defb    'O'+$80,"UT"
 375+ 1490 CF 4E                defb    'O'+$80,"N"
 376+ 1492 C6 49 4C 45          defb    'F'+$80,"ILES"          ; added by Leonardo Miliani
 376+ 1496 53
 377+ 1497 C5 52 41 53          defb    'E'+$80,"RASE"          ; added by Leonardo Miliani
 377+ 149B 45
 378+ 149C C4 49 53 4B          defb    'D'+$80,"ISK"           ; added by Leonardo Miliani
 379+ 14A0 D7 41 49 54          defb    'W'+$80,"AIT"
 380+ 14A4 C4 45 46             defb    'D'+$80,"EF"
 381+ 14A7 D0 4F 4B 45          defb    'P'+$80,"OKE"
 382+ 14AB C4 4F 4B 45          defb    'D'+$80,"OKE"
 383+ 14AF D6 50 4F 4B          defb    'V'+$80,"POKE"          ; added by Leonardo Miliani
 383+ 14B3 45
 384+ 14B4 D3 52 45 47          defb    'S'+$80,"REG"           ; added by Leonardo Miliani
 385+ 14B8 D6 52 45 47          defb    'V'+$80,"REG"           ; added by Leonardo Miliani
 386+ 14BC D3 43 52 45          defb    'S'+$80,"CREEN"         ; changed by Leonardo Miliani
 386+ 14C0 45 4E
 387+ 14C2 CC 4F 43 41          defb    'L'+$80,"OCATE"         ; added by Leonardo Miliani
 387+ 14C6 54 45
 388+ 14C8 D3 4F 55 4E          defb    'S'+$80,"OUND"          ; added by Leonardo Miliani
 388+ 14CC 44
 389+ 14CD D6 4F 4C 55          defb    'V'+$80,"OLUME"         ; added by Leonardo Miliani
 389+ 14D1 4D 45
 390+ 14D3 D0 41 55 53          defb    'P'+$80,"AUSE"          ; added by Leonardo Miliani
 390+ 14D7 45
 391+ 14D8 C3 4F 4C 4F          defb    'C'+$80,"OLOR"          ; added by Leonardo Miliani
 391+ 14DC 52
 392+ 14DD D0 4C 4F 54          defb    'P'+$80,"LOT"           ; added by Leonardo Miliani
 393+ 14E1 C4 52 41 57          defb    'D'+$80,"RAW"           ; added by Leonardo Miliani
 394+ 14E5 C3 49 52 43          defb    'C'+$80,"IRCLE"         ; added by Leonardo Miliani
 394+ 14E9 4C 45
 395+ 14EB D0 41 49 4E          defb    'P'+$80,"AINT"          ; added by Leonardo Miliani
 395+ 14EF 54
 396+ 14F0 D3 45 52 49          defb    'S'+$80,"ERIAL"         ; added by Leonardo Miliani
 396+ 14F4 41 4C
 397+ 14F6 C8 45 4C 50          defb    'H'+$80,"ELP"           ; changed by Leonardo Miliani - was LINES
 398+ 14FA C3 4C 53             defb    'C'+$80,"LS"            ; restored command
 399+ 14FD CB 45 59             defb    'K'+$80,"EY"            ; added by Leonardo Miliani
 400+ 1500 CE 4D 49             defb    'N'+$80,"MI"            ; added by Leonardo Miliani
 401+ 1503 C7 50 52 49          defb    'G'+$80,"PRINT"         ; added by Leonardo Miliani
 401+ 1507 4E 54
 402+ 1509 D7 49 44 54          defb    'W'+$80,"IDTH"
 402+ 150D 48
 403+ 150E D3 59 53             defb    'S'+$80,"YS"            ; added by Leonardo Miliani
 404+ 1511 D2 45 53 45          defb    'R'+$80,"ESET"          ; changed by Leonardo Miliani
 404+ 1515 54
 405+ 1516 C5 4C 53 45          defb    'E'+$80,"LSE"           ; added by Leonardo Miliani
 406+ 151A D0 52 49 4E          defb    'P'+$80,"RINT"
 406+ 151E 54
 407+ 151F C3 4F 4E 54          defb    'C'+$80,"ONT"
 408+ 1523 CC 49 53 54          defb    'L'+$80,"IST"
 409+ 1527 C3 4C 45 41          defb    'C'+$80,"LEAR"
 409+ 152B 52
 410+ 152C CC 4F 41 44          defb    'L'+$80,"OAD"
 411+ 1530 D3 41 56 45          defb    'S'+$80,"AVE"
 412+ 1534 CE 45 57             defb    'N'+$80,"EW"
 413+ 1537 D4 41 42 28          defb    'T'+$80,"AB("
 414+ 153B D4 4F                defb    'T'+$80,"O"
 415+ 153D C6 4E                defb    'F'+$80,"N"
 416+ 153F D3 50 43 28          defb    'S'+$80,"PC("
 417+ 1543 D4 48 45 4E          defb    'T'+$80,"HEN"
 418+ 1547 CE 4F 54             defb    'N'+$80,"OT"
 419+ 154A D3 54 45 50          defb    'S'+$80,"TEP"
 420+ 154E                      ; from here: operators
 421+ 154E AB                   defb    '+'+$80
 422+ 154F AD                   defb    '-'+$80
 423+ 1550 AA                   defb    '*'+$80
 424+ 1551 AF                   defb    '/'+$80
 425+ 1552 A5                   defb    '%'+$80
 426+ 1553 A3                   defb    '#'+$80
 427+ 1554 DE                   defb    '^'+$80
 428+ 1555 C1 4E 44             defb    'A'+$80,"ND"
 429+ 1558 D8 4F 52             defb    'X'+$80,"OR"
 430+ 155B CF 52                defb    'O'+$80,"R"
 431+ 155D BE                   defb    '>'+$80
 432+ 155E BD                   defb    '='+$80
 433+ 155F BC                   defb    '<'+$80
 434+ 1560
 435+ 1560                      ; from here there are the tokens' FUNCTIONS list
 436+ 1560                      ; this list must be coherent with the functions list above
 437+ 1560 D3 47 4E             defb    'S'+$80,"GN"
 438+ 1563 D4 4D 52             defb    'T'+$80,"MR"            ; added by Leonardo Miliani
 439+ 1566 C9 4E 54             defb    'I'+$80,"NT"
 440+ 1569 C1 42 53             defb    'A'+$80,"BS"
 441+ 156C D5 53 52             defb    'U'+$80,"SR"
 442+ 156F C6 52 45             defb    'F'+$80,"RE"
 443+ 1572 C9 4E 50             defb    'I'+$80,"NP"
 444+ 1575 D0 4F 53             defb    'P'+$80,"OS"
 445+ 1578 D3 51 52             defb    'S'+$80,"QR"
 446+ 157B D2 4E 44             defb    'R'+$80,"ND"
 447+ 157E CC 4F 47             defb    'L'+$80,"OG"
 448+ 1581 C5 58 50             defb    'E'+$80,"XP"
 449+ 1584 C3 4F 53             defb    'C'+$80,"OS"
 450+ 1587 D3 49 4E             defb    'S'+$80,"IN"
 451+ 158A D4 41 4E             defb    'T'+$80,"AN"
 452+ 158D C1 54 4E             defb    'A'+$80,"TN"
 453+ 1590 D0 45 45 4B          defb    'P'+$80,"EEK"
 454+ 1594 C4 45 45 4B          defb    'D'+$80,"EEK"
 455+ 1598 D6 50 45 45          defb    'V'+$80,"PEEK"          ; added by Leonardo Miliani
 455+ 159C 4B
 456+ 159D D6 53 54 41          defb    'V'+$80,"STAT"          ; added by Leonardo Miliani
 456+ 15A1 54
 457+ 15A2 D3 53 54 41          defb    'S'+$80,"STAT"          ; added by Leonardo Miliani
 457+ 15A6 54
 458+ 15A7 C9 4E 4B 45          defb    'I'+$80,"NKEY"          ; added by Leonardo Miliani
 458+ 15AB 59
 459+ 15AC D0 4F 49 4E          defb    'P'+$80,"OINT"          ; added by Leonardo Miliani
 459+ 15B0 54
 460+ 15B1 C9 4E 53 54          defb    'I'+$80,"NSTR"          ; added by Leonardo Miliani
 460+ 15B5 52
 461+ 15B6 CC 45 4E             defb    'L'+$80,"EN"
 462+ 15B9 D3 54 52 24          defb    'S'+$80,"TR$"
 463+ 15BD D6 41 4C             defb    'V'+$80,"AL"
 464+ 15C0 C1 53 43             defb    'A'+$80,"SC"
 465+ 15C3 C3 48 52 24          defb    'C'+$80,"HR$"
 466+ 15C7 C8 45 58 24          defb    'H'+$80,"EX$"           ; added by Grant Searle
 467+ 15CB C2 49 4E 24          defb    'B'+$80,"IN$"           ; added by Grant Searle
 468+ 15CF CC 45 46 54          defb    'L'+$80,"EFT$"
 468+ 15D3 24
 469+ 15D4 D2 49 47 48          defb    'R'+$80,"IGHT$"
 469+ 15D8 54 24
 470+ 15DA CD 49 44 24          defb    'M'+$80,"ID$"
 471+ 15DE 80                   defb    $80                     ; End-of-list marker
 472+ 15DF
 473+ 15DF              ; KEYWORD ADDRESS TABLE
 474+ 15DF              ; this list must be coherent with the commands'
 475+ 15DF              ; tokens list above
 476+ 15DF 65 1D        WORDTB: defw    PEND
 477+ 15E1 62 1C                defw    FOR
 478+ 15E3 61 21                defw    NEXT
 479+ 15E5 C4 1E                defw    DATA
 480+ 15E7 5E 20                defw    INPUT
 481+ 15E9 B6 23                defw    DIM
 482+ 15EB 98 20                defw    READ
 483+ 15ED DB 1E                defw    LET
 484+ 15EF 81 1E                defw    GOTO
 485+ 15F1 5C 1E                defw    RUN
 486+ 15F3 53 1F                defw    IF
 487+ 15F5 2B 1D                defw    RESTOR
 488+ 15F7 70 1E                defw    GOSUB
 489+ 15F9 9F 1E                defw    RETURN
 490+ 15FB C6 1E                defw    REM         ; original REM
 491+ 15FD 63 1D                defw    STOP
 492+ 15FF FB 29                defw    POUT
 493+ 1601 35 1F                defw    ON
 494+ 1603 FD FF                defw    JPFILS       ; changed by Leonardo Miliani - was NULL
 495+ 1605 F4 FF                defw    JPERAS       ; added by Leonardo Miliani
 496+ 1607 F1 FF                defw    JPDISK        ; added by Leonardo Miliani
 497+ 1609 01 2A                defw    WAIT
 498+ 160B AA 25                defw    DEF
 499+ 160D F5 2A                defw    POKE
 500+ 160F 98 34                defw    DOKE
 501+ 1611 FA 2A                defw    VPOKE       ; added by Leonardo Miliani
 502+ 1613 37 2B                defw    SREG        ; added by Leonardo Miliani
 503+ 1615 85 2C                defw    VREG        ; added by Leonardo Miliani
 504+ 1617 CE 34                defw    SCREEN      ; new behaviour: now it sets up a graphics mode (Leonardo Miliani)
 505+ 1619 05 2B                defw    LOCATE      ; added by Leonardo Miliani
 506+ 161B 91 2B                defw    SOUND       ; added by Leonardo Miliani
 507+ 161D 58 2B                defw    VOLUME      ; added by Leonardo Miliani
 508+ 161F AF 34                defw    PAUSE       ; added by Leonardo Miliani
 509+ 1621 49 35                defw    COLOR       ; added by Leonardo Miliani
 510+ 1623 37 38                defw    PLOT        ; added by Leonardo Miliani
 511+ 1625 CA 38                defw    DRAW        ; added by Leonardo Miliani
 512+ 1627 03 3A                defw    CIRCLE      ; added by Leonardo Miliani
 513+ 1629 F4 36                defw    PAINT       ; added by Leonardo Miliani
 514+ 162B 0E 3C                defw    SERIAL      ; added by Leonardo Miliani
 515+ 162D 4D 3E                defw    HELP        ; changed by Leonardo Miliani - was LINES
 516+ 162F 71 34                defw    CLS
 517+ 1631 6B 3E                defw    KEY         ; added by Leonardo Miliani
 518+ 1633 43 2A                defw    NMI         ; added by Leonardo Miliani
 519+ 1635 04 36                defw    GPRINT      ; added by Leonardo Miliani
 520+ 1637 85 34                defw    WIDTH
 521+ 1639 9D 2A                defw    SYS         ; added by Leonardo Miliani
 522+ 163B CE 40                defw    RESET       ; new behaviour: now it resets the system
 523+ 163D C8 1E                defw    REM+2       ; ELSE: added by Leonardo Miliani
 524+ 163F 85 1F                defw    PRINT
 525+ 1641 97 1D                defw    CONT
 526+ 1643 39 1B                defw    LIST
 527+ 1645 10 1E                defw    CLEAR
 528+ 1647 F7 FF                defw    JPLOAD      ; re-implemented by Leonardo Miliani (was CLOAD)
 529+ 1649 FA FF                defw    JPSAVE      ; re-implemented by Leonardo Miliani (was CSAVE)
 530+ 164B 0E 19                defw    NEW
 531+ 164D
 532+ 164D              ; RESERVED WORD TOKEN VALUES
 533+ 164D              ; if you add a function or command you must increment by 1
 534+ 164D              ; the values below. Pay attention that you must increment only the
 535+ 164D              ; values AFTER the position where you entered the function/command word
 536+ 164D              ; in the "Reserver word list" above. I.E.: VPOKE has been added between
 537+ 164D              ; DOKE and SCREEN, and since REM is the reserved work listed below
 538+ 164D              ; that is before the point where VPOKE has been entered, every entry
 539+ 164D              ; after REM has been incremented.
 540+ 164D              ; Another example: when TMR has been added, since it's a function, every
 541+ 164D              ; entry after & included ZSGN must be checked (read below)
 542+ 164D
 543+ 164D              ZEND    equ     $80             ; END        <-- from here, there are the commands
 544+ 164D              ZFOR    equ     $81             ; FOR
 545+ 164D              ZDATA   equ     $83             ; DATA
 546+ 164D              ZGOTO   equ     $88             ; GOTO
 547+ 164D              ZGOSUB  equ     $8C             ; GOSUB
 548+ 164D              ZREM    equ     $8E             ; REM
 549+ 164D              ZELSE   equ     $AF             ; ELSE
 550+ 164D              ZPRINT  equ     $B0             ; PRINT
 551+ 164D              ZNEW    equ     $B6             ; NEW
 552+ 164D
 553+ 164D              ZTAB    equ     $B7             ; TAB
 554+ 164D              ZTO     equ     $B8             ; TO
 555+ 164D              ZFN     equ     $B9             ; FN
 556+ 164D              ZSPC    equ     $BA             ; SPC
 557+ 164D              ZTHEN   equ     $BB             ; THEN
 558+ 164D              ZNOT    equ     $BC             ; NOT
 559+ 164D              ZSTEP   equ     $BD             ; STEP
 560+ 164D
 561+ 164D              ZPLUS   equ     $BE             ; +         <-- from here, there are the math operators
 562+ 164D              ZMINUS  equ     $BF             ; -
 563+ 164D              ZTIMES  equ     $C0             ; *
 564+ 164D              ZDIV    equ     $C1             ; /
 565+ 164D              ZMOD    equ     $C2             ; %
 566+ 164D              ZDINT   equ     $C3             ; #
 567+ 164D              ZOR     equ     $C7             ; OR
 568+ 164D              ZGTR    equ     $C8             ; >
 569+ 164D              ZEQUAL  equ     $C9             ; M
 570+ 164D              ZLTH    equ     $CA             ; <
 571+ 164D
 572+ 164D              ZSGN    equ     $CB             ; SGN       <-- from here, there are the functions
 573+ 164D              ZPOINT  equ     $E1             ; ZPOINT    <-- if the user enters a custom function, between
 574+ 164D                                              ;               SGN and POINT, he/she must increment this pointer by 1
 575+ 164D              ZINSTR  equ     $E2             ; ZINSTR    <-- same here
 576+ 164D              ZLEFT   equ     $EA             ; LEFT$     <-- if the user enters a custom function anywhere,
 577+ 164D                                              ;               he/she must increment this pointer by 1
 578+ 164D
 579+ 164D              ; ARITHMETIC PRECEDENCE TABLE
 580+ 164D              ; in the formulas below, <last> is a number stored into the stack that must be retrieved
 581+ 164D              ; with POP BC, POP DE; FPREG is a f.p. number store into the RAM register FPREG
 582+ 164D 79           PRITAB: defb    $79             ; Precedence value
 583+ 164E 3A 31                defw    PADD            ; FPREG = <last> + FPREG
 584+ 1650
 585+ 1650 79                   defb    $79             ; Precedence value
 586+ 1651 1D 2D                defw    PSUB            ; FPREG = <last> - FPREG
 587+ 1653
 588+ 1653 7C                   defb    $7C             ; Precedence value
 589+ 1654 5B 2E                defw    MULT            ; PPREG = <last> * FPREG
 590+ 1656
 591+ 1656 7C                   defb    $7C             ; Precedence value
 592+ 1657 0D 2F                defw    DIV             ; FPREG = <last> / FPREG
 593+ 1659
 594+ 1659 7C                   defb    $7C             ; Precedence value
 595+ 165A B8 2E                defw    MOD             ; FPREG = INT(<last>)-(INT(FPREG)*INT(<last>/FPREG))
 596+ 165C
 597+ 165C 7C                   defb    $7C             ; precedence value
 598+ 165D B0 2E                defw    DINT            ; FPREG = INT(<last> / FPREG )
 599+ 165F
 600+ 165F 7F                   defb    $7F             ; Precedence value
 601+ 1660 5B 32                defw    POWER           ; FPREG = <last> ^ FPREG
 602+ 1662
 603+ 1662 50                   defb    $50             ; Precedence value
 604+ 1663 FF 22                defw    PAND            ; FPREG = <last> AND FPREG
 605+ 1665
 606+ 1665 4A                   defb    $4A             ; Precedence value
 607+ 1666 07 23                defw    PXOR            ; FPREG = <last> XOR FPREG
 608+ 1668
 609+ 1668 46                   defb    $46             ; Precedence value
 610+ 1669 02 23                defw    POR             ; FPREG = <last> OR FPREG
 611+ 166B
 612+ 166B
 613+ 166B              ; INITIALISATION TABLE -------------------------------------------------------
 614+ 166B              ; these values are copied into RAM at startup
 615+ 166B C3 7B 13     INITAB: jp      WARMST          ; Warm start jump
 616+ 166E ED 45 00             defb    $ED,$45,$00     ; RETN + NOP for default NMI service routine
 617+ 1671 C3 E6 1D             jp      FCERR           ; "USR (X)" jump (Set to Error)
 618+ 1674 D3 00                out     (0),A           ; "out p,n" skeleton
 619+ 1676 C9                   ret
 620+ 1677 D6 00                sub     $00             ; Division support routine
 621+ 1679 6F                   ld      L,A
 622+ 167A 7C                   ld      A,H
 623+ 167B DE 00                sbc     A,$00
 624+ 167D 67                   ld      H,A
 625+ 167E 78                   ld      A,B
 626+ 167F DE 00                sbc     A,$00
 627+ 1681 47                   ld      B,A
 628+ 1682 3E 00                ld      A,$00
 629+ 1684 C9                   ret
 630+ 1685 00 00 00             defb    $00,$00,$00     ; Random number seed table used by RND
 631+ 1688 35 4A CA 99          defb    $35,$4A,$CA,$99 ;-2.65145E+07
 632+ 168C 39 1C 76 98          defb    $39,$1C,$76,$98 ; 1.61291E+07
 633+ 1690 22 95 B3 98          defb    $22,$95,$B3,$98 ;-1.17691E+07
 634+ 1694 0A DD 47 98          defb    $0A,$DD,$47,$98 ; 1.30983E+07
 635+ 1698 53 D1 99 99          defb    $53,$D1,$99,$99 ;-2-01612E+07
 636+ 169C 0A 1A 9F 98          defb    $0A,$1A,$9F,$98 ;-1.04269E+07
 637+ 16A0 65 BC CD 98          defb    $65,$BC,$CD,$98 ;-1.34831E+07
 638+ 16A4 D6 77 3E 98          defb    $D6,$77,$3E,$98 ; 1.24825E+07
 639+ 16A8 52 C7 4F 80          defb    $52,$C7,$4F,$80 ; Last random number
 640+ 16AC DB 00                in      A,($00)         ; INP (x) skeleton
 641+ 16AE C9                   ret
 642+ 16AF FF                   defb    $FF             ; Terminal width (255 = no auto CRLF)
 643+ 16B0 14                   defb    $14             ; Width for commas (at reset, 3 columns, for G1 mode)
 644+ 16B1 00                   defb    $00             ; No nulls after input bytes
 645+ 16B2 00                   defb    $00             ; Output enabled (^O off)
 646+ 16B3 00 00                defw    $00             ; Array load/save check sum
 647+ 16B5 00                   defb    $00             ; Break not by NMI
 648+ 16B6 00                   defb    $00             ; Break flag
 649+ 16B7 C3 52 1A             jp      TTYLIN          ; Input reflection (set to TTY)
 650+ 16BA 0D 56                defw    STLOOK          ; Temp string space
 651+ 16BC FE FF                defw    -2              ; Current line number (cold)
 652+ 16BE FF FF                defw    -1              ; Current line with errors (no errors)
 653+ 16C0 40           AUTORP: defb    $40             ; delay for key auto-repeat start
 654+ 16C1 08                   defb    $08             ; auto-repeat delay
 655+ 16C2 4C 49 53 54  DEFFNKS:defm    "LIST",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 1
 655+ 16C6 0D 00 00 00
 655+ 16CA 00 00 00 00
 655+ 16CE 00 00 00 00
 656+ 16D2 52 55 4E 0D          defm    "RUN",13,0,0,0,0,0,0,0,0,0,0,0,0    ; KEY 2
 656+ 16D6 00 00 00 00
 656+ 16DA 00 00 00 00
 656+ 16DE 00 00 00 00
 657+ 16E2 53 43 52 45          defm    "SCREEN1",13,0,0,0,0,0,0,0,0        ; KEY 3
 657+ 16E6 45 4E 31 0D
 657+ 16EA 00 00 00 00
 657+ 16EE 00 00 00 00
 658+ 16F2 43 4F 4C 4F          defm    "COLOR1,15,5",13,0,0,0,0            ; KEY 4
 658+ 16F6 52 31 2C 31
 658+ 16FA 35 2C 35 0D
 658+ 16FE 00 00 00 00
 659+ 1702 53 45 52 49          defm    "SERIAL1,38400",13,0,0              ; KEY 5
 659+ 1706 41 4C 31 2C
 659+ 170A 33 38 34 30
 659+ 170E 30 0D 00 00
 660+ 1712 53 43 52 45          defm    "SCREEN2",13,0,0,0,0,0,0,0,0        ; KEY 6
 660+ 1716 45 4E 32 0D
 660+ 171A 00 00 00 00
 660+ 171E 00 00 00 00
 661+ 1722 43 4F 4E 54          defm    "CONT",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 7
 661+ 1726 0D 00 00 00
 661+ 172A 00 00 00 00
 661+ 172E 00 00 00 00
 662+ 1732 48 45 4C 50          defm    "HELP",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 8 (HELP KEY)
 662+ 1736 0D 00 00 00
 662+ 173A 00 00 00 00
 662+ 173E 00 00 00 00
 663+ 1742 AA 55                defw    PROGST+1        ; Start of program text
 664+ 1744              INITBE:
 665+ 1744
 666+ 1744              ; END OF INITIALISATION TABLE ---------------------------------------------------
 667+ 1744
 668+ 1744 20 45 72 72  ERRMSG: defb    " Error",0
 668+ 1748 6F 72 00
 669+ 174B 20 69 6E 20  INMSG:  defb    " in ",0
 669+ 174F 00
 670+ 1750              ZERBYT  equ     $-1             ; A zero byte
 671+ 1750 4F 6B 0D 00  OKMSG:  defb    "Ok",CR,0,0
 671+ 1754 00
 672+ 1755 42 72 65 61  BRKMSG: defb    "Break",0
 672+ 1759 6B 00
 673+ 175B
 674+ 175B 21 04 00     BAKSTK: ld      HL,$04          ; Look for "FOR" block with
 675+ 175E 39                   add     HL,SP           ; same index as specified
 676+ 175F 7E           LOKFOR: ld      A,(HL)          ; Get block ID
 677+ 1760 23                   inc     HL              ; Point to index address
 678+ 1761 FE 81                cp      ZFOR            ; Is it a "FOR" token
 679+ 1763 C0                   ret     NZ              ; No - exit
 680+ 1764 4E                   ld      C,(HL)          ; BC = Address of "FOR" index
 681+ 1765 23                   inc     HL
 682+ 1766 46                   ld      B,(HL)
 683+ 1767 23                   inc     HL              ; Point to sign of STEP
 684+ 1768 E5                   push    HL              ; Save pointer to sign
 685+ 1769 69                   ld      L,C             ; HL = address of "FOR" index
 686+ 176A 60                   ld      H,B
 687+ 176B 7A                   ld      A,D             ; See if an index was specified
 688+ 176C B3                   or      E               ; DE = 0 if no index specified
 689+ 176D EB                   ex      DE,HL           ; Specified index into HL
 690+ 176E CA 75 17             jp      Z,INDFND        ; Skip if no index given
 691+ 1771 EB                   ex      DE,HL           ; Index back into DE
 692+ 1772 CD CC 1A             call    CPDEHL          ; Compare index with one given
 693+ 1775 01 0D 00     INDFND: ld      BC,16-3         ; Offset to next block
 694+ 1778 E1                   pop     HL              ; Restore pointer to sign
 695+ 1779 C8                   ret     Z               ; Return if block found
 696+ 177A 09                   add     HL,BC           ; Point to next block
 697+ 177B C3 5F 17             jp      LOKFOR          ; Keep on looking
 698+ 177E
 699+ 177E CD 98 17     MOVUP:  call    ENFMEM          ; See if enough memory
 700+ 1781 C5           MOVSTR: push    BC              ; Save end of source
 701+ 1782 E3                   ex      (SP),HL         ; Swap source and dest" end
 702+ 1783 C1                   pop     BC              ; Get end of destination
 703+ 1784 CD CC 1A     MOVLP:  call    CPDEHL          ; See if list moved
 704+ 1787 7E                   ld      A,(HL)          ; Get byte
 705+ 1788 02                   ld      (BC),A          ; Move it
 706+ 1789 C8                   ret     Z               ; Exit if all done
 707+ 178A 0B                   dec     BC              ; Next byte to move to
 708+ 178B 2B                   dec     HL              ; Next byte to move
 709+ 178C C3 84 17             jp      MOVLP           ; Loop until all bytes moved
 710+ 178F
 711+ 178F E5           CHKSTK: push    HL              ; Save code string address
 712+ 1790 2A 8A 55             ld      HL,(ARREND)     ; Lowest free memory
 713+ 1793 06 00                ld      B,$00           ; BC = Number of levels to test
 714+ 1795 09                   add     HL,BC           ; 2 Bytes for each level
 715+ 1796 09                   add     HL,BC
 716+ 1797 3E                   defb    $3E             ; Skip "push HL"
 717+ 1798 E5           ENFMEM: push    HL              ; Save code string address
 718+ 1799 3E D0                ld      A,$D0           ; LOW -48 ; 48 Bytes minimum RAM
 719+ 179B 95                   sub     L
 720+ 179C 6F                   ld      L,A
 721+ 179D 3E FF                ld      A,$FF           ; HIGH (-48) ; 48 Bytes minimum RAM
 722+ 179F 9C                   sbc     A,H
 723+ 17A0 DA A7 17             jp      C,OMERR         ; Not enough - ?OM Error
 724+ 17A3 67                   ld      H,A
 725+ 17A4 39                   add     HL,SP           ; Test if stack is overflowed
 726+ 17A5 E1                   pop     HL              ; Restore code string address
 727+ 17A6 D8                   ret     C               ; Return if enough memory
 728+ 17A7 1E 0C        OMERR:  ld      E,OM            ; ?OM Error
 729+ 17A9 C3 EC 17             jp      ERROR
 730+ 17AC
 731+ 17AC
 732+ 17AC              ; if in graphics mode, return to text (called by "NOLIN" and "ERROR")
 733+ 17AC F5           EXITGM: push    AF              ; store AF
 734+ 17AD 3A 32 55             ld      A,(SCR_MODE)    ; check screen mode
 735+ 17B0 FE 02                cp      $02             ; G2?
 736+ 17B2 CA B9 17             jp      Z,LDG1          ; yes, back to G1
 737+ 17B5 FE 03                cp      $03             ; G3?
 738+ 17B7 20 11                jr      NZ,LDG1ND       ; no, so return
 739+ 17B9 E5           LDG1:   push    HL              ; store HL
 740+ 17BA D5                   push    DE              ; store DE
 741+ 17BB 11 01 00             ld      DE,$0001        ; sprites set to defaults, G1 mode
 742+ 17BE F3                   di                      ; disable INTs
 743+ 17BF CD D1 03             call    initVDP         ; initialize VDP with mode pointed by E
 744+ 17C2 FB                   ei                      ; re-enable INTs
 745+ 17C3 3E 01                ld      A,$01           ; activate the...
 746+ 17C5 32 3C 55             ld      (PRNTVIDEO),A   ; ...video buffer...
 747+ 17C8 D1                   pop     DE              ; retrieve DE
 748+ 17C9 E1                   pop     HL              ; retrieve HL
 749+ 17CA F1           LDG1ND: pop     AF              ; retrieve AF
 750+ 17CB C9                   ret                     ; return to caller
 751+ 17CC
 752+ 17CC
 753+ 17CC 2A 13 55     DATSNR: ld      HL,(DATLIN)     ; Get line of current DATA item
 754+ 17CF 22 ED 53             ld      (LINEAT),HL     ; Save as current line
 755+ 17D2 1E 02        SNERR:  ld      E,SN            ; ?SN Error
 756+ 17D4 01                   defb    $01             ; Skip "ld E,DZ"
 757+ 17D5 1E 14        DZERR:  ld      E,DZ            ; ?/0 Error
 758+ 17D7 01                   defb    $01             ; Skip "ld E,NF"
 759+ 17D8 1E 00        NFERR:  ld      E,NF            ; ?NF Error
 760+ 17DA 01                   defb    $01             ; Skip "ld E,DD"
 761+ 17DB 1E 12        DDERR:  ld      E,DD            ; ?DD Error
 762+ 17DD 01                   defb    $01             ; Skip "ld E,UF"
 763+ 17DE 1E 22        UFERR:  ld      E,UF            ; ?UF Error
 764+ 17E0 01                   defb    $01             ; Skip "ld E,OV
 765+ 17E1 1E 0A        OVERR:  ld      E,OV            ; ?OV Error
 766+ 17E3 01                   defb    $01             ; Skip "ld E,TM"
 767+ 17E4 1E 18        TMERR:  ld      E,TM            ; ?TM Error
 768+ 17E6 01                   defb    $01             ; Skip next statement
 769+ 17E7 1E 34        IMERR:  ld      E,IM            ; ?Illegal indirect mode error
 770+ 17E9 01                   defb    $01             ; Skip next statement
 771+ 17EA 1E 36        NRERR:  ld      E,NR            ; ?Device not ready error
 772+ 17EC
 773+ 17EC CD 34 19     ERROR:  call    CLREG           ; Clear registers and stack
 774+ 17EF CD AC 17             call    EXITGM          ; exit from graphic modes
 775+ 17F2 32 E3 53             ld      (CTLOFG),A      ; Enable output (A is 0)
 776+ 17F5 CD 26 09             call    CURSOR_ON       ; enable cursor
 777+ 17F8 CD D6 1F             call    STTLIN          ; Start new line
 778+ 17FB 21 0C 10             ld      HL,ERRTBL       ; Point to error codes
 779+ 17FE 57                   ld      D,A             ; D = 0 (A is 0)
 780+ 17FF 3E 3F                ld      A,'?'
 781+ 1801 CD DD 1A             call    OUTC            ; Output '?'
 782+ 1804 19                   add     HL,DE           ; Offset to correct error code
 783+ 1805 5E                   ld      E,(HL)          ; load pointer to error message
 784+ 1806 23                   inc     HL              ; by loading LSB,
 785+ 1807 56                   ld      D,(HL)          ; then MSB
 786+ 1808 62 6B                ld      HL,DE           ; load pointer to HL
 787+ 180A CD B4 26             call    PRS             ; Output error message
 788+ 180D 21 44 17             ld      HL,ERRMSG       ; "Error" message
 789+ 1810 CD B4 26     ERRIN:  call    PRS             ; Output message
 790+ 1813 2A ED 53             ld      HL,(LINEAT)     ; Get line of error
 791+ 1816 11 FE FF             ld      DE,-2           ; Cold start error if -2
 792+ 1819 CD CC 1A             call    CPDEHL          ; See if cold start error
 793+ 181C CA AC 12             jp      Z,CSTART        ; Cold start error - Restart
 794+ 181F 7C                   ld      A,H             ; Was it a direct error?
 795+ 1820 A5                   and     L               ; Line = -1 if direct error
 796+ 1821 3C                   inc     A
 797+ 1822 CA 2D 18             jp      Z,PTLN          ; Yes, jump over
 798+ 1825 E5                   push    HL              ; indirect mode - store HL
 799+ 1826 2A ED 53             ld      HL,(LINEAT)     ; copy current line number
 800+ 1829 22 EF 53             ld      (HLPLN),HL      ; save in HELP line register
 801+ 182C E1                   pop     HL              ; retrieve HL
 802+ 182D C4 4B 31     PTLN:   call    NZ,LINEIN       ; No - output line of error
 803+ 1830
 804+ 1830 3E                   defb    $3E             ; Skip "pop BC"
 805+ 1831 C1           POPNOK: pop     BC              ; Drop address in input buffer
 806+ 1832
 807+ 1832              ; run into direct mode: print OK and get command
 808+ 1832 AF           PRNTOK: xor     A               ; Output "Ok" and get command
 809+ 1833 32 E3 53             ld      (CTLOFG),A      ; Enable output
 810+ 1836 CD D6 1F             call    STTLIN          ; Start new line
 811+ 1839 21 50 17             ld      HL,OKMSG        ; "Ok" message
 812+ 183C CD B4 26             call    PRS             ; Output "Ok"
 813+ 183F CD 26 09     GETCMD: call    CURSOR_ON       ; enable cursor
 814+ 1842 3A 82 55             ld      A,(SERIALS_EN)  ; load serial state
 815+ 1845 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
 816+ 1847 CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
 817+ 184A 21 FF FF             ld      HL,-1           ; Flag direct mode
 818+ 184D 22 ED 53             ld      (LINEAT),HL     ; Save as current line
 819+ 1850 CD 52 1A             call    GETLIN          ; Get an input line
 820+ 1853 DA 3F 18             jp      C,GETCMD        ; Get line again if break
 821+ 1856 CD 1B 1D             call    GETCHR          ; Get first character
 822+ 1859 17                   rla                     ; 8th bit is copied into carry and original carry is copied into bit 0)
 823+ 185A DA D2 17             jp      C,SNERR         ; if char >=128 (8th bit set) then raise an error
 824+ 185D 1F                   rra                     ; recover original char and Carry
 825+ 185E 3C                   inc     A               ; Test if end of line
 826+ 185F 3D                   dec     A               ; Without affecting Carry
 827+ 1860 CA 3F 18             jp      Z,GETCMD        ; Nothing entered - Get another
 828+ 1863 F5                   push    AF              ; Save Carry status
 829+ 1864 3A 82 55             ld      A,(SERIALS_EN)  ; load serial state
 830+ 1867 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
 831+ 1869 CC 8F 01             call    Z,A_RTS_OFF      ; yes, set RTS on
 832+ 186C CD 3B 09             call    CURSOR_OFF      ; cursor disabled
 833+ 186F CD EB 1D             call    ATOH            ; Get line number into DE
 834+ 1872 D5                   push    DE              ; Save line number
 835+ 1873 CD 69 19             call    CRUNCH          ; Tokenise rest of line
 836+ 1876 47                   ld      B,A             ; Length of tokenised line
 837+ 1877 D1                   pop     DE              ; Restore line number
 838+ 1878 F1                   pop     AF              ; Restore Carry
 839+ 1879 D2 FB 1C             jp      NC,EXCUTE       ; No line number - Direct mode
 840+ 187C D5                   push    DE              ; Save line number
 841+ 187D C5                   push    BC              ; Save length of tokenised line
 842+ 187E AF                   xor     A
 843+ 187F 32 16 55             ld      (LSTBIN),A      ; Clear last byte input
 844+ 1882 CD 1B 1D             call    GETCHR          ; Get next character
 845+ 1885 B7                   or      A               ; Set flags
 846+ 1886 F5                   push    AF              ; And save them
 847+ 1887 CD EE 18             call    SRCHLN          ; Search for line number in DE
 848+ 188A DA 93 18             jp      C,LINFND        ; Jump if line found
 849+ 188D F1                   pop     AF              ; Get status
 850+ 188E F5                   push    AF              ; And re-save
 851+ 188F CA 9A 1E             jp      Z,ULERR         ; Nothing after number - Error
 852+ 1892 B7                   or      A               ; Clear Carry
 853+ 1893 C5           LINFND: push    BC              ; Save address of line in prog
 854+ 1894 D2 AA 18             jp      NC,INEWLN       ; Line not found - Insert new
 855+ 1897 EB                   ex      DE,HL           ; Next line address in DE
 856+ 1898 2A 86 55             ld      HL,(PROGND)     ; End of program
 857+ 189B 1A           SFTPRG: ld      A,(DE)          ; Shift rest of program down
 858+ 189C 02                   ld      (BC),A
 859+ 189D 03                   inc     BC              ; Next destination
 860+ 189E 13                   inc     DE              ; Next source
 861+ 189F CD CC 1A             call    CPDEHL          ; All done?
 862+ 18A2 C2 9B 18             jp      NZ,SFTPRG       ; More to do
 863+ 18A5 60                   ld      H,B             ; HL - New end of program
 864+ 18A6 69                   ld      L,C
 865+ 18A7 22 86 55             ld      (PROGND),HL     ; Update end of program
 866+ 18AA
 867+ 18AA D1           INEWLN: pop     DE              ; Get address of line,
 868+ 18AB F1                   pop     AF              ; Get status
 869+ 18AC CA D1 18             jp      Z,SETPTR        ; No text - Set up pointers
 870+ 18AF 2A 86 55             ld      HL,(PROGND)     ; Get end of program
 871+ 18B2 E3                   ex      (SP),HL         ; Get length of input line
 872+ 18B3 C1                   pop     BC              ; End of program to BC
 873+ 18B4 09                   add     HL,BC           ; Find new end
 874+ 18B5 E5                   push    HL              ; Save new end
 875+ 18B6 CD 7E 17             call    MOVUP           ; Make space for line
 876+ 18B9 E1                   pop     HL              ; Restore new end
 877+ 18BA 22 86 55             ld      (PROGND),HL     ; Update end of program pointer
 878+ 18BD EB                   ex      DE,HL           ; Get line to move up in HL
 879+ 18BE 74                   ld      (HL),H          ; Save MSB
 880+ 18BF D1                   pop     DE              ; Get new line number
 881+ 18C0 23                   inc     HL              ; Skip pointer
 882+ 18C1 23                   inc     HL
 883+ 18C2 73                   ld      (HL),E          ; Save LSB of line number
 884+ 18C3 23                   inc     HL
 885+ 18C4 72                   ld      (HL),D          ; Save MSB of line number
 886+ 18C5 23                   inc     HL              ; To first byte in line
 887+ 18C6 11 76 54             ld      DE,BUFFER       ; Copy buffer to program
 888+ 18C9 1A           MOVBUF: ld      A,(DE)          ; Get source
 889+ 18CA 77                   ld      (HL),A          ; Save destinations
 890+ 18CB 23                   inc     HL              ; Next source
 891+ 18CC 13                   inc     DE              ; Next destination
 892+ 18CD B7                   or      A               ; Done?
 893+ 18CE C2 C9 18             jp      NZ,MOVBUF       ; No - Repeat
 894+ 18D1 CD 1A 19     SETPTR: call    RUNFST          ; Set line pointers
 895+ 18D4 23                   inc     HL              ; To LSB of pointer
 896+ 18D5 EB                   ex      DE,HL           ; Address to DE
 897+ 18D6 62           PTRLP:  ld      H,D             ; Address to HL
 898+ 18D7 6B                   ld      L,E
 899+ 18D8 7E                   ld      A,(HL)          ; Get LSB of pointer
 900+ 18D9 23                   inc     HL              ; To MSB of pointer
 901+ 18DA B6                   or      (HL)            ; Compare with MSB pointer
 902+ 18DB CA 3F 18             jp      Z,GETCMD        ; Get command line if end
 903+ 18DE 23                   inc     HL              ; To LSB of line number
 904+ 18DF 23                   inc     HL              ; Skip line number
 905+ 18E0 23                   inc     HL              ; Point to first byte in line
 906+ 18E1 AF                   xor     A               ; Looking for 00 byte
 907+ 18E2 BE           FNDEND: cp      (HL)            ; Found end of line?
 908+ 18E3 23                   inc     HL              ; Move to next byte
 909+ 18E4 C2 E2 18             jp      NZ,FNDEND       ; No - Keep looking
 910+ 18E7 EB                   ex      DE,HL           ; Next line address to HL
 911+ 18E8 73                   ld      (HL),E          ; Save LSB of pointer
 912+ 18E9 23                   inc     HL
 913+ 18EA 72                   ld      (HL),D          ; Save MSB of pointer
 914+ 18EB C3 D6 18             jp      PTRLP           ; Do next line
 915+ 18EE
 916+ 18EE 2A 73 54     SRCHLN: ld      HL,(BASTXT)     ; Start of program text
 917+ 18F1 44           SRCHLP: ld      B,H             ; BC = Address to look at
 918+ 18F2 4D                   ld      C,L
 919+ 18F3 7E                   ld      A,(HL)          ; Get address of next line
 920+ 18F4 23                   inc     HL
 921+ 18F5 B6                   or      (HL)            ; End of program found?
 922+ 18F6 2B                   dec     HL
 923+ 18F7 C8                   ret     Z               ; Yes - Line not found
 924+ 18F8 23                   inc     HL
 925+ 18F9 23                   inc     HL
 926+ 18FA 7E                   ld      A,(HL)          ; Get LSB of line number
 927+ 18FB 23                   inc     HL
 928+ 18FC 66                   ld      H,(HL)          ; Get MSB of line number
 929+ 18FD 6F                   ld      L,A
 930+ 18FE CD CC 1A             call    CPDEHL          ; Compare with line in DE
 931+ 1901 60                   ld      H,B             ; HL = Start of this line
 932+ 1902 69                   ld      L,C
 933+ 1903 7E                   ld      A,(HL)          ; Get LSB of next line address
 934+ 1904 23                   inc     HL
 935+ 1905 66                   ld      H,(HL)          ; Get MSB of next line address
 936+ 1906 6F                   ld      L,A             ; Next line to HL
 937+ 1907 3F                   ccf
 938+ 1908 C8                   ret     Z               ; Lines found - Exit
 939+ 1909 3F                   ccf
 940+ 190A D0                   ret     NC              ; Line not found,at line after
 941+ 190B C3 F1 18             jp      SRCHLP          ; Keep looking
 942+ 190E
 943+ 190E C0           NEW:    ret     NZ              ; Return if any more on line
 944+ 190F 2A 73 54     CLRPTR: ld      HL,(BASTXT)     ; Point to start of program
 945+ 1912 AF                   xor     A               ; Set program area to empty
 946+ 1913 77                   ld      (HL),A          ; Save LSB = 00
 947+ 1914 23                   inc     HL
 948+ 1915 77                   ld      (HL),A          ; Save MSB = 00
 949+ 1916 23                   inc     HL
 950+ 1917 22 86 55             ld      (PROGND),HL     ; Set program end
 951+ 191A
 952+ 191A 2A 73 54     RUNFST: ld      HL,(BASTXT)     ; Clear all variables
 953+ 191D 2B                   dec     HL
 954+ 191E
 955+ 191E 22 18 55     INTVAR: ld      (BRKLIN),HL     ; Initialise RUN variables
 956+ 1921 2A D4 54             ld      HL,(LSTRAM)     ; Get end of RAM
 957+ 1924 22 0D 55             ld      (STRBOT),HL     ; Clear string space
 958+ 1927 AF                   xor     A
 959+ 1928 CD 2B 1D             call    RESTOR          ; Reset DATA pointers
 960+ 192B 2A 86 55             ld      HL,(PROGND)     ; Get end of program
 961+ 192E 22 88 55             ld      (VAREND),HL     ; Clear variables
 962+ 1931 22 8A 55             ld      (ARREND),HL     ; Clear arrays
 963+ 1934
 964+ 1934 C1           CLREG:  pop     BC              ; Save return address
 965+ 1935 2A EB 53             ld      HL,(STRSPC)     ; Get end of working RAM
 966+ 1938 F9                   ld      SP,HL           ; Set stack
 967+ 1939 21 FD 54             ld      HL,TMSTPL       ; Temporary string pool
 968+ 193C 22 FB 54             ld      (TMSTPT),HL     ; Reset temporary string ptr
 969+ 193F AF                   xor     A               ; A = 00
 970+ 1940 6F                   ld      L,A             ; HL = 0000
 971+ 1941 67                   ld      H,A
 972+ 1942 22 1E 55             ld      (CONTAD),HL     ; No CONTinue
 973+ 1945 32 15 55             ld      (FORFLG),A      ; Clear FOR flag
 974+ 1948 22 8E 55             ld      (FNRGNM),HL     ; Clear FN argument
 975+ 194B E5                   push    HL              ; HL = 0000
 976+ 194C C5                   push    BC              ; Put back return
 977+ 194D 2A 18 55     DOAGN:  ld      HL,(BRKLIN)     ; Get address of code to RUN
 978+ 1950 C9                   ret                     ; Return to execution driver
 979+ 1951
 980+ 1951 3E 3F        PROMPT: ld      A,'?'           ; '?'
 981+ 1953 CD DD 1A             call    OUTC            ; Output character
 982+ 1956 3E 00                ld      A,NLLCR         ; null char
 983+ 1958 CD DD 1A             call    OUTC            ; Output character
 984+ 195B CD 26 09             call    CURSOR_ON       ; enable cursor
 985+ 195E 3A 82 55             ld      A,(SERIALS_EN)  ; load serial state
 986+ 1961 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
 987+ 1963 CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
 988+ 1966 C3 E8 53             jp      RINPUT          ; Get input line
 989+ 1969
 990+ 1969 AF           CRUNCH: xor     A               ; Tokenise line @ HL to BUFFER
 991+ 196A 32 D3 54             ld      (DATFLG),A      ; Reset literal flag
 992+ 196D 0E 05                ld      C,2+3           ; 2 byte number and 3 nulls
 993+ 196F 11 76 54             ld      DE,BUFFER       ; Start of input buffer
 994+ 1972 7E           CRNCLP: ld      A,(HL)          ; Get byte
 995+ 1973 FE 20                cp      SPC             ; Is it a space?
 996+ 1975 CA F1 19             jp      Z,MOVDIR        ; Yes - Copy direct
 997+ 1978 47                   ld      B,A             ; Save character
 998+ 1979 FE 22                cp      $22             ; '"'             ; Is it a quote?
 999+ 197B CA 11 1A             jp      Z,CPYLIT        ; Yes - Copy literal string
1000+ 197E B7                   or      A               ; Is it end of buffer?
1001+ 197F CA 18 1A             jp      Z,ENDBUF        ; Yes - End buffer
1002+ 1982 3A D3 54             ld      A,(DATFLG)      ; Get data type
1003+ 1985 B7                   or      A               ; Literal?
1004+ 1986 7E                   ld      A,(HL)          ; Get byte to copy
1005+ 1987 C2 F1 19             jp      NZ,MOVDIR       ; Literal - Copy direct
1006+ 198A FE 3F                cp      '?'             ; Is it '?' short for PRINT
1007+ 198C 3E B0                ld      A,ZPRINT        ; "PRINT" token
1008+ 198E CA F1 19             jp      Z,MOVDIR        ; Yes - replace it
1009+ 1991 7E                   ld      A,(HL)          ; Get byte again
1010+ 1992 FE 30                cp      '0'             ; Is it less than '0'
1011+ 1994 DA 9C 19             jp      C,FNDWRD        ; Yes - Look for reserved words
1012+ 1997 FE 3C                cp      $3C  ;60; ";"+1       ; Is it "0123456789:;" ?
1013+ 1999 DA F1 19             jp      C,MOVDIR        ; Yes - copy it direct
1014+ 199C D5           FNDWRD: push    DE              ; Look for reserved words
1015+ 199D 11 4D 14             ld      DE,WORDS-1      ; Point to table
1016+ 19A0 C5                   push    BC              ; Save count
1017+ 19A1 01 ED 19             ld      BC,RETNAD       ; Where to return to
1018+ 19A4 C5                   push    BC              ; Save return address
1019+ 19A5 06 7F                ld      B,ZEND-1        ; First token value -1
1020+ 19A7 7E                   ld      A,(HL)          ; Get byte
1021+ 19A8 FE 61                cp      'a'             ; Less than 'a' ?
1022+ 19AA DA B5 19             jp      C,SEARCH        ; Yes - search for words
1023+ 19AD FE 7B                cp      'z'+1           ; Greater than 'z' ?
1024+ 19AF D2 B5 19             jp      NC,SEARCH       ; Yes - search for words
1025+ 19B2 E6 5F                and     %01011111       ; Force upper case
1026+ 19B4 77                   ld      (HL),A          ; Replace byte
1027+ 19B5 4E           SEARCH: ld      C,(HL)          ; Search for a word
1028+ 19B6 EB                   ex      DE,HL
1029+ 19B7 23           GETNXT: inc     HL              ; Get next reserved word
1030+ 19B8 B6                   or      (HL)            ; Start of word?
1031+ 19B9 F2 B7 19             jp      P,GETNXT        ; No - move on
1032+ 19BC 04                   inc     B               ; Increment token value
1033+ 19BD 7E                   ld      A,(HL)          ; Get byte from table
1034+ 19BE E6 7F                and     %01111111       ; Strip bit 7
1035+ 19C0 C8                   ret     Z               ; Return if end of list
1036+ 19C1 B9                   cp      C               ; Same character as in buffer?
1037+ 19C2 C2 B7 19             jp      NZ,GETNXT       ; No - get next word
1038+ 19C5 EB                   ex      DE,HL
1039+ 19C6 E5                   push    HL              ; Save start of word
1040+ 19C7
1041+ 19C7 13           NXTBYT: inc     DE              ; Look through rest of word
1042+ 19C8 1A                   ld      A,(DE)          ; Get byte from table
1043+ 19C9 B7                   or      A               ; End of word ?
1044+ 19CA FA E9 19             jp      M,MATCH         ; Yes - Match found
1045+ 19CD 4F                   ld      C,A             ; Save it
1046+ 19CE 78                   ld      A,B             ; Get token value
1047+ 19CF FE 88                cp      ZGOTO           ; Is it "GOTO" token ?
1048+ 19D1 C2 D8 19             jp      NZ,NOSPC        ; No - Don't allow spaces
1049+ 19D4 CD 1B 1D             call    GETCHR          ; Get next character
1050+ 19D7 2B                   dec     HL              ; Cancel increment from GETCHR
1051+ 19D8 23           NOSPC:  inc     HL              ; Next byte
1052+ 19D9 7E                   ld      A,(HL)          ; Get byte
1053+ 19DA FE 61                cp      'a'             ; Less than 'a' ?
1054+ 19DC DA E1 19             jp      C,NOCHNG        ; Yes - don't change
1055+ 19DF E6 5F                and     %01011111       ; Make upper case
1056+ 19E1 B9           NOCHNG: cp      C               ; Same as in buffer ?
1057+ 19E2 CA C7 19             jp      Z,NXTBYT        ; Yes - keep testing
1058+ 19E5 E1                   pop     HL              ; Get back start of word
1059+ 19E6 C3 B5 19             jp      SEARCH          ; Look at next word
1060+ 19E9
1061+ 19E9 48           MATCH:  ld      C,B             ; Word found - Save token value
1062+ 19EA F1                   pop     AF              ; Throw away return
1063+ 19EB EB                   ex      DE,HL
1064+ 19EC C9                   ret                     ; Return to "RETNAD"
1065+ 19ED EB           RETNAD: ex      DE,HL           ; Get address in string
1066+ 19EE 79                   ld      A,C             ; Get token value
1067+ 19EF C1                   pop     BC              ; Restore buffer length
1068+ 19F0 D1                   pop     DE              ; Get destination address
1069+ 19F1 23           MOVDIR: inc     HL              ; Next source in buffer
1070+ 19F2 12                   ld      (DE),A          ; Put byte in buffer
1071+ 19F3 13                   inc     DE              ; Move up buffer
1072+ 19F4 0C                   inc     C               ; Increment length of buffer
1073+ 19F5 D6 3A                sub     ':'             ; End of statement?
1074+ 19F7 CA FF 19             jp      Z,SETLIT        ; Jump if multi-statement line
1075+ 19FA FE 49                cp      ZDATA-$3A       ; Is it DATA statement ?
1076+ 19FC C2 02 1A             jp      NZ,TSTREM       ; No - see if REM
1077+ 19FF 32 D3 54     SETLIT: ld      (DATFLG),A      ; Set literal flag
1078+ 1A02 D6 54        TSTREM: sub     ZREM-$3A        ; Is it REM?
1079+ 1A04 C2 72 19             jp      NZ,CRNCLP       ; No - Leave flag
1080+ 1A07 47                   ld      B,A             ; Copy rest of buffer
1081+ 1A08 7E           NXTCHR: ld      A,(HL)          ; Get byte
1082+ 1A09 B7                   or      A               ; End of line ?
1083+ 1A0A CA 18 1A             jp      Z,ENDBUF        ; Yes - Terminate buffer
1084+ 1A0D B8                   cp      B               ; End of statement ?
1085+ 1A0E CA F1 19             jp      Z,MOVDIR        ; Yes - Get next one
1086+ 1A11 23           CPYLIT: inc     HL              ; Move up source string
1087+ 1A12 12                   ld      (DE),A          ; Save in destination
1088+ 1A13 0C                   inc     C               ; Increment length
1089+ 1A14 13                   inc     DE              ; Move up destination
1090+ 1A15 C3 08 1A             jp      NXTCHR          ; Repeat
1091+ 1A18
1092+ 1A18 21 75 54     ENDBUF: ld      HL,BUFFER-1     ; Point to start of buffer
1093+ 1A1B 12                   ld      (DE),A          ; Mark end of buffer (A = 00)
1094+ 1A1C 13                   inc     DE
1095+ 1A1D 12                   ld      (DE),A          ; A = 00
1096+ 1A1E 13                   inc     DE
1097+ 1A1F 12                   ld      (DE),A          ; A = 00
1098+ 1A20 C9                   ret
1099+ 1A21
1100+ 1A21 3A E2 53     DODEL:  ld      A,(NULFLG)      ; Get null flag status
1101+ 1A24 B7                   or      A               ; Is it zero?
1102+ 1A25 3E 00                ld      A,$00           ; Zero A - Leave flags
1103+ 1A27 32 E2 53             ld      (NULFLG),A      ; Zero null flag
1104+ 1A2A C2 35 1A             jp      NZ,ECHDEL       ; Set - Echo it
1105+ 1A2D 05                   dec     B               ; Decrement length
1106+ 1A2E CA 52 1A             jp      Z,GETLIN        ; Get line again if empty
1107+ 1A31 CD DD 1A             call    OUTC            ; Output null character
1108+ 1A34 3E                   defb    $3E             ; Skip "dec B"
1109+ 1A35 05           ECHDEL: dec     B               ; Count bytes in buffer
1110+ 1A36 2B                   dec     HL              ; Back space buffer
1111+ 1A37 CA 49 1A             jp      Z,OTKLN         ; No buffer - Try again
1112+ 1A3A 7E                   ld      A,(HL)          ; Get deleted byte
1113+ 1A3B CD DD 1A             call    OUTC            ; Echo it
1114+ 1A3E C3 5B 1A             jp      MORINP          ; Get more input
1115+ 1A41
1116+ 1A41 05           DELCHR: dec     B               ; Count bytes in buffer
1117+ 1A42 2B                   dec     HL              ; Back space buffer
1118+ 1A43 CD DD 1A             call    OUTC            ; Output character in A
1119+ 1A46 C2 5B 1A             jp      NZ,MORINP       ; Not end - Get more
1120+ 1A49 CD DD 1A     OTKLN:  call    OUTC            ; Output character in A
1121+ 1A4C CD E8 1F     KILIN:  call    PRNTCRLF        ; Output CRLF
1122+ 1A4F C3 52 1A             jp      TTYLIN          ; Get line again
1123+ 1A52
1124+ 1A52              GETLIN:
1125+ 1A52 21 76 54     TTYLIN: ld      HL,BUFFER       ; Get a line by character
1126+ 1A55 06 01                ld      B,$01           ; Set buffer as empty
1127+ 1A57 AF                   xor     A
1128+ 1A58 32 E2 53             ld      (NULFLG),A      ; Clear null flag
1129+ 1A5B CD 1E 1B     MORINP: call    CLOTST          ; Get character and test ^O
1130+ 1A5E 4F                   ld      C,A             ; Save character in C
1131+ 1A5F FE 7F                cp      DEL             ; Delete character?
1132+ 1A61 CA 21 1A             jp      Z,DODEL         ; Yes - Process it
1133+ 1A64 3A E2 53             ld      A,(NULFLG)      ; Get null flag
1134+ 1A67 B7                   or      A               ; Test null flag status
1135+ 1A68 CA 74 1A             jp      Z,PROCES        ; Reset - Process character
1136+ 1A6B 3E 00                ld      A,$00           ; Set a null
1137+ 1A6D CD DD 1A             call    OUTC            ; Output null
1138+ 1A70 AF                   xor     A               ; Clear A
1139+ 1A71 32 E2 53             ld      (NULFLG),A      ; Reset null flag
1140+ 1A74 79           PROCES: ld      A,C             ; Get character
1141+ 1A75 FE 07                cp      CTRLG           ; Bell?
1142+ 1A77 CA B4 1A             jp      Z,PUTCTL        ; Yes - Save it
1143+ 1A7A FE 03                cp      CTRLC           ; Is it control "C"?
1144+ 1A7C CC A9 1A             call    Z,GMNCR         ; Yes - exit from graphic mode & Output CRLF
1145+ 1A7F 37                   scf                     ; Flag break
1146+ 1A80 C8                   ret     Z               ; Return if control "C"
1147+ 1A81 FE 0D                cp      CR              ; Is it enter?
1148+ 1A83 CA DE 1F             jp      Z,ENDINP        ; Yes - Terminate input
1149+ 1A86 FE 15                cp      CTRLU           ; Is it control "U"?
1150+ 1A88 CA 4C 1A             jp      Z,KILIN         ; Yes - Get another line
1151+ 1A8B FE 08                cp      BKSP            ; Is it backspace?
1152+ 1A8D CA 41 1A             jp      Z,DELCHR        ; Yes - Delete character
1153+ 1A90 FE 12                cp      CTRLR           ; Is it control "R"?
1154+ 1A92 C2 AF 1A             jp      NZ,PUTBUF       ; No - Put in buffer
1155+ 1A95 C5                   push    BC              ; Save buffer length
1156+ 1A96 D5                   push    DE              ; Save DE
1157+ 1A97 E5                   push    HL              ; Save buffer address
1158+ 1A98 36 00                ld      (HL),$00        ; Mark end of buffer
1159+ 1A9A CD F3 40             call    OUTNCR          ; Output and do CRLF
1160+ 1A9D 21 76 54             ld      HL,BUFFER       ; Point to buffer start
1161+ 1AA0 CD B4 26             call    PRS             ; Output buffer
1162+ 1AA3 E1                   pop     HL              ; Restore buffer address
1163+ 1AA4 D1                   pop     DE              ; Restore DE
1164+ 1AA5 C1                   pop     BC              ; Restore buffer length
1165+ 1AA6 C3 5B 1A             jp      MORINP          ; Get another character
1166+ 1AA9 CD AC 17     GMNCR:  call    EXITGM          ; exit from graphic mode
1167+ 1AAC C3 E8 1F             jp      PRNTCRLF        ; output CRLF
1168+ 1AAF
1169+ 1AAF FE 20        PUTBUF: cp      SPC             ; Is it a control code?
1170+ 1AB1 DA 5B 1A             jp      C,MORINP        ; Yes - Ignore
1171+ 1AB4 78           PUTCTL: ld      A,B             ; Get number of bytes in buffer
1172+ 1AB5 FE 59                cp      $58+$01         ; Test for line overflow
1173+ 1AB7 3E 08                ld      A,BKSP          ; Set a bell
1174+ 1AB9 D2 C6 1A             jp      NC,OUTNBS       ; Ring bell if buffer full
1175+ 1ABC 79                   ld      A,C             ; Get character
1176+ 1ABD 71                   ld      (HL),C          ; Save in buffer
1177+ 1ABE 32 16 55             ld      (LSTBIN),A      ; Save last input byte
1178+ 1AC1 23                   inc     HL              ; Move up buffer
1179+ 1AC2 04                   inc     B               ; Increment length
1180+ 1AC3 C3 5B 1A     OUTIT:  jp      MORINP          ; Get another character
1181+ 1AC6
1182+ 1AC6 CD DD 1A     OUTNBS: call    OUTC            ; Output bell and back over it
1183+ 1AC9 C3 C3 1A             jp      OUTIT           ; get more chars
1184+ 1ACC
1185+ 1ACC 7C           CPDEHL: ld      A,H             ; Get H
1186+ 1ACD 92                   sub     D               ; Compare with D
1187+ 1ACE C0                   ret     NZ              ; Different - Exit
1188+ 1ACF 7D                   ld      A,L             ; Get L
1189+ 1AD0 93                   sub     E               ; Compare with E
1190+ 1AD1 C9                   ret                     ; Return status
1191+ 1AD2
1192+ 1AD2 7E           CHKSYN: ld      A,(HL)          ; Check syntax of character
1193+ 1AD3 E3                   ex      (SP),HL         ; Address of test byte
1194+ 1AD4 BE                   cp      (HL)            ; Same as in code string?
1195+ 1AD5 23                   inc     HL              ; Return address
1196+ 1AD6 E3                   ex      (SP),HL         ; Put it back
1197+ 1AD7 CA 1B 1D             jp      Z,GETCHR        ; Yes - Get next character
1198+ 1ADA C3 D2 17             jp      SNERR           ; Different - ?SN Error
1199+ 1ADD
1200+ 1ADD F5           OUTC:   push    AF              ; Save character
1201+ 1ADE 3A E3 53             ld      A,(CTLOFG)      ; Get control "O" flag
1202+ 1AE1 B7                   or      A               ; Is it set?
1203+ 1AE2 C2 E9 26             jp      NZ,POPAF        ; Yes - don't output
1204+ 1AE5 F1                   pop     AF              ; Restore character
1205+ 1AE6 C5                   push    BC              ; Save buffer length
1206+ 1AE7 F5                   push    AF              ; Save character
1207+ 1AE8 FE 20                cp      SPC             ; Is it a control code?
1208+ 1AEA DA 01 1B             jp      C,DINPOS        ; Yes - Don't inc POS(X)
1209+ 1AED 3A E0 53             ld      A,(LWIDTH)      ; Get line width
1210+ 1AF0 47                   ld      B,A             ; To B
1211+ 1AF1 3A D0 54             ld      A,(CURPOS)      ; Get cursor position
1212+ 1AF4 04                   inc     B               ; Width 255?
1213+ 1AF5 CA FD 1A             jp      Z,INCLEN        ; Yes - No width limit
1214+ 1AF8 05                   dec     B               ; Restore width
1215+ 1AF9 B8                   cp      B               ; At end of line?
1216+ 1AFA CC E8 1F             call    Z,PRNTCRLF      ; Yes - output CRLF
1217+ 1AFD 3C           INCLEN: inc     A               ; Move on one character
1218+ 1AFE 32 D0 54             ld      (CURPOS),A      ; Save new position
1219+ 1B01 AF           DINPOS: xor     A
1220+ 1B02 32 7A 55             ld      (KBDNPT),A      ; set flag for no char from keyboard
1221+ 1B05 F1                   pop     AF              ; Restore character
1222+ 1B06 C1                   pop     BC              ; Restore buffer length
1223+ 1B07 F5                   push    AF
1224+ 1B08 CD 10 1B             call    SND2VID         ; send char to video
1225+ 1B0B F1                   pop     AF
1226+ 1B0C CD CB 40             call    MONOUT          ; send char to serial if enabled
1227+ 1B0F C9                   ret
1228+ 1B10
1229+ 1B10              ; print char to video if cursor is on
1230+ 1B10 32 3D 55     SND2VID:ld      (CHR4VID),A     ; store A
1231+ 1B13 3A 3C 55             ld      A,(PRNTVIDEO)   ; check print-on-video
1232+ 1B16 B7                   or      A               ; is it off?
1233+ 1B17 C8                   ret     Z               ; yes, so return
1234+ 1B18 F3                   di                      ; disable INTs
1235+ 1B19 CD 5A 07             call    CHAR2VID        ; cursor is on, so print char on screen
1236+ 1B1C FB                   ei                      ; re-enable INTs
1237+ 1B1D C9                   ret                     ; return to caller
1238+ 1B1E
1239+ 1B1E CD 6F 34     CLOTST: call    GETINP          ; Get input character
1240+ 1B21 FE 0F                cp      CTRLO           ; Is it control "O"?
1241+ 1B23 C0                   ret     NZ              ; No don't flip flag
1242+ 1B24 3A E3 53             ld      A,(CTLOFG)      ; Get flag
1243+ 1B27 2F                   cpl                     ; Flip it
1244+ 1B28 32 E3 53             ld      (CTLOFG),A      ; Put it back
1245+ 1B2B A7                   and     A               ; is output enabled?
1246+ 1B2C CC 26 09             call    Z,CURSOR_ON     ; yes, so cursor on
1247+ 1B2F 3A 82 55             ld      A,(SERIALS_EN)  ; load serial state
1248+ 1B32 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
1249+ 1B34 CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
1250+ 1B37 AF                   xor     A               ; Null character
1251+ 1B38 C9                   ret
1252+ 1B39
1253+ 1B39              ; LIST: list the program stored into memory
1254+ 1B39 C1           LIST:   pop     BC              ; rubbish - not needed (legacy from original call of LIST)
1255+ 1B3A 2B                   dec     HL              ; dec 'cos GETCHR INCs
1256+ 1B3B CD 1B 1D             call    GETCHR          ; Get next character
1257+ 1B3E CA 94 1B             jp      Z,LSTALL        ; list all if nothing follows
1258+ 1B41 FE BF                cp      ZMINUS          ; is it '-'?
1259+ 1B43 20 20                jr      NZ,LST01        ; no, look for a line number
1260+ 1B45 11 00 00             ld      DE,$0000        ; yes, set search from 0
1261+ 1B48 CD 35 1C             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1262+ 1B4B ED 43 40 55          ld      (TMPBFR1),BC    ; store address of starting line
1263+ 1B4F CD D2 1A             call    CHKSYN          ; skip '-'
1264+ 1B52 BF                   defb    ZMINUS
1265+ 1B53 CD EB 1D             call    ATOH            ; now, look for another number (ASCII number to DE)
1266+ 1B56 CD 3B 1C             call    SRCLN           ; find a line, getting the previous if it doesn't exist
1267+ 1B59 ED 43 42 55          ld      (TMPBFR2),BC    ; store address of ending line
1268+ 1B5D ED 4B 40 55          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1269+ 1B61 C5                   push    BC              ; store address of line for later use
1270+ 1B62 C3 CC 1B             jp      LISTLP          ; go listing
1271+ 1B65 CD EB 1D     LST01:  call    ATOH            ; get a line number (ASCII number to DE)
1272+ 1B68 ED 53 46 55  LST01H: ld      (TMPBFR4),DE    ; store ending line address for later use - N.B.: this is a hook for HELP command
1273+ 1B6C CD 35 1C             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1274+ 1B6F ED 43 40 55          ld      (TMPBFR1),BC    ; store address of starting line
1275+ 1B73 ED 43 42 55          ld      (TMPBFR2),BC    ; same address for ending line (we'll change it later if needed)
1276+ 1B77 2B                   dec     HL              ; dec 'cos GETCHR INCs
1277+ 1B78 CD 1B 1D             call    GETCHR          ; Get next character
1278+ 1B7B CA 87 1B             jp      Z,LSTNOT        ; nothing follows, so ending & starting lines are the same
1279+ 1B7E FE BF                cp      ZMINUS          ; is it '-'?
1280+ 1B80 CA AC 1B             jp      Z,LST03         ; yes, read ending line
1281+ 1B83 C5           LST06:  push    BC              ; store address for later use
1282+ 1B84 C3 CC 1B             jp      LISTLP          ; jump to list
1283+ 1B87 ED 5B 46 55  LSTNOT: ld      DE,(TMPBFR4)
1284+ 1B8B CD 35 1C             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1285+ 1B8E DA 83 1B             jp      C,LST06
1286+ 1B91 C3 32 18             jp      PRNTOK
1287+ 1B94 11 F9 FF     LSTALL: ld      DE,65529        ; set ending line to max. allowed line number
1288+ 1B97 CD 35 1C             call    SRCHLIN         ; get address of last line
1289+ 1B9A ED 43 42 55          ld      (TMPBFR2),BC    ; store it
1290+ 1B9E 11 00 00             ld      DE,$0000        ; set start to first line in memory
1291+ 1BA1 CD 35 1C             call    SRCHLIN         ; get address of first line
1292+ 1BA4 ED 43 40 55          ld      (TMPBFR1),BC    ; store it
1293+ 1BA8 C5                   push    BC              ; store address of starting line for later use
1294+ 1BA9 C3 CC 1B             jp      LISTLP          ; start printing
1295+ 1BAC CD D2 1A     LST03:  call    CHKSYN          ; skip '-'
1296+ 1BAF BF                   defb    ZMINUS
1297+ 1BB0 CD EB 1D             call    ATOH            ; look for another number (return into DE)
1298+ 1BB3 7A                   ld      A,D
1299+ 1BB4 B3                   or      E               ; is line=0?
1300+ 1BB5 20 09                jr      NZ,LST05        ; no, jump over
1301+ 1BB7 11 F9 FF             ld      DE,65529        ; yes set last valid line number
1302+ 1BBA CD 35 1C             call    SRCHLIN         ; get address of last line
1303+ 1BBD C3 C3 1B             jp      LST02
1304+ 1BC0 CD 3B 1C     LST05:  call    SRCLN           ; find a line, getting the previous if it doesn't exist
1305+ 1BC3 ED 43 42 55  LST02:  ld      (TMPBFR2),BC    ; store address of ending line
1306+ 1BC7 ED 4B 40 55          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1307+ 1BCB C5                   push    BC              ; store it for later use
1308+ 1BCC E1           LISTLP: pop     HL              ; Restore address of line
1309+ 1BCD 4E                   ld      C,(HL)          ; Get LSB of next line
1310+ 1BCE 23                   inc     HL
1311+ 1BCF 46                   ld      B,(HL)          ; Get MSB of next line
1312+ 1BD0 23                   inc     HL
1313+ 1BD1 78                   ld      A,B             ; BC = 0 (End of program)?
1314+ 1BD2 B1                   or      C
1315+ 1BD3 CA 32 18             jp      Z,PRNTOK        ; Yes - Go to command mode
1316+ 1BD6 CD 46 1D             call    TSTBRK          ; Test for break key
1317+ 1BD9 CD 49 1C             call    TSTSPC          ; test for space
1318+ 1BDC C5                   push    BC              ; Save address of next line
1319+ 1BDD 3A 35 55             ld      A,(SCR_CURS_X)  ; load current X pos of cursor
1320+ 1BE0 A7                   and     A               ; is it at the beginning of a new line?
1321+ 1BE1 20 0B                jr      NZ,LST08        ; No, jump over
1322+ 1BE3 3E 0D                ld      A,CR            ; yes, so just send a CR
1323+ 1BE5 CD CB 40             call    MONOUT          ; to serial if it's open
1324+ 1BE8 AF                   xor     A               ; then, set cursor
1325+ 1BE9 32 D0 54             ld      (CURPOS),A      ; to position 0
1326+ 1BEC 18 03                jr      LST07           ; and continue
1327+ 1BEE CD E8 1F     LST08:  call    PRNTCRLF        ; output CRLF
1328+ 1BF1 5E           LST07:  ld      E,(HL)          ; Get LSB of line number
1329+ 1BF2 23                   inc     HL
1330+ 1BF3 56                   ld      D,(HL)          ; Get MSB of line number
1331+ 1BF4 23                   inc     HL
1332+ 1BF5 E5                   push    HL              ; Save address of line start
1333+ 1BF6 EB                   ex      DE,HL           ; Line number to HL
1334+ 1BF7 CD 53 31             call    PRNTHL          ; Output line number in decimal
1335+ 1BFA 3E 20                ld      A,SPC           ; Space after line number
1336+ 1BFC E1                   pop     HL              ; Restore start of line address
1337+ 1BFD CD DD 1A     LSTLP2: call    OUTC            ; Output character in A
1338+ 1C00 7E           LSTLP3: ld      A,(HL)          ; Get next byte in line
1339+ 1C01 B7                   or      A               ; End of line?
1340+ 1C02 23                   inc     HL              ; To next byte in line
1341+ 1C03 CA 27 1C             jp      Z,NXTLN         ; Yes - check next line
1342+ 1C06 F2 FD 1B             jp      P,LSTLP2        ; No token - output it
1343+ 1C09 D6 7F                sub     ZEND-1          ; Find and output word
1344+ 1C0B 4F                   ld      C,A             ; Token offset+1 to C
1345+ 1C0C 11 4E 14             ld      DE,WORDS        ; Reserved word list
1346+ 1C0F 1A           FNDTOK: ld      A,(DE)          ; Get character in list
1347+ 1C10 13                   inc     DE              ; Move on to next
1348+ 1C11 B7                   or      A               ; Is it start of word?
1349+ 1C12 F2 0F 1C             jp      P,FNDTOK        ; No - Keep looking for word
1350+ 1C15 0D                   dec     C               ; Count words
1351+ 1C16 C2 0F 1C             jp      NZ,FNDTOK       ; Not there - keep looking
1352+ 1C19 E6 7F        OUTWRD: and     %01111111       ; Strip bit 7
1353+ 1C1B CD DD 1A             call    OUTC            ; Output character
1354+ 1C1E 1A                   ld      A,(DE)          ; Get next character
1355+ 1C1F 13                   inc     DE              ; Move on to next
1356+ 1C20 B7                   or      A               ; Is it end of word?
1357+ 1C21 F2 19 1C             jp      P,OUTWRD        ; No - output the rest
1358+ 1C24 C3 00 1C             jp      LSTLP3          ; Next byte in line
1359+ 1C27 D1           NXTLN:  pop     DE              ; recover address of current line
1360+ 1C28 2A 42 55             ld      HL,(TMPBFR2)    ; address of last line to print
1361+ 1C2B CD F9 40             call    CMP16           ; check if current line is over last printable line
1362+ 1C2E DA 32 18             jp      C,PRNTOK        ; finish - leave & print OK
1363+ 1C31 D5                   push    DE              ; store address of current line
1364+ 1C32 C3 CC 1B             jp      LISTLP          ; continue listing
1365+ 1C35              ; look for the address of a program line
1366+ 1C35 E5           SRCHLIN:push    HL              ; store HL (this is needed because HL store the pointer to the input buffer)
1367+ 1C36 CD EE 18             call    SRCHLN          ; search for line number in DE
1368+ 1C39 E1                   pop     HL              ; retrieve HL
1369+ 1C3A C9                   ret                     ; return to caller
1370+ 1C3B              ; look for the address of a program line - if the line isn't found,
1371+ 1C3B              ; it look backward for the previous line
1372+ 1C3B E5           SRCLN:  push    HL              ; store HL
1373+ 1C3C CD EE 18     SRCLN1: call    SRCHLN          ; search for line in DE
1374+ 1C3F DA 47 1C             jp      C,LVSRLN        ; found it, leave loop
1375+ 1C42 1B                   dec     DE              ; not found, decrement number to look backward for an existing line
1376+ 1C43 7B                   ld      A,E
1377+ 1C44 B2                   or      D               ; is line number zero?
1378+ 1C45 20 F5                jr      NZ,SRCLN1       ; no, continue
1379+ 1C47 E1           LVSRLN: pop     HL              ; retrieve HL
1380+ 1C48 C9                   ret                     ; return to caller
1381+ 1C49
1382+ 1C49              ; during LISTing, check if PAUSE is pressed, then pause listing and
1383+ 1C49              ; wait for another pressing of PAUSE to continue or CTRL-C/BREAK to exit
1384+ 1C49 3A 7C 55     TSTSPC: ld      A,(TMPKEYBFR)   ; Get input character
1385+ 1C4C FE 20                cp      SPC             ; Is it SPACE?
1386+ 1C4E C0                   ret     NZ              ; No, return
1387+ 1C4F CD 6F 34     WTSPC:  call    GETINP          ; Yes, stop listing and wait for another space or BREAK
1388+ 1C52 FE 20                cp      SPC             ; is it SPACE?
1389+ 1C54 20 05                jr      NZ,CNTWTSP      ; no, continue
1390+ 1C56 AF                   xor     A
1391+ 1C57 32 7C 55             ld      (TMPKEYBFR),A   ; reset key
1392+ 1C5A C9                   ret                     ; return to caller
1393+ 1C5B FE 03        CNTWTSP:cp      CTRLC           ; is it CTRL-C/BREAK?
1394+ 1C5D 20 F0                jr      NZ,WTSPC        ; no, loop
1395+ 1C5F C3 7E 13             jp      BRKRET          ; exit and output "Ok"
1396+ 1C62
1397+ 1C62
1398+ 1C62 3E 64        FOR:    ld      A,$64           ; Flag "FOR" assignment
1399+ 1C64 32 15 55             ld      (FORFLG),A      ; Save "FOR" flag
1400+ 1C67 CD DB 1E             call    LET             ; Set up initial index
1401+ 1C6A C1                   pop     BC              ; Drop RETurn address
1402+ 1C6B E5                   push    HL              ; Save code string address
1403+ 1C6C CD C4 1E             call    DATA            ; Get next statement address
1404+ 1C6F 22 11 55             ld      (LOOPST),HL     ; Save it for start of loop
1405+ 1C72 21 02 00             ld      HL,$0002        ; Offset for "FOR" block
1406+ 1C75 39                   add     HL,SP           ; Point to it
1407+ 1C76 CD 5F 17     FORSLP: call    LOKFOR          ; Look for existing "FOR" block
1408+ 1C79 D1                   pop     DE              ; Get code string address
1409+ 1C7A C2 92 1C             jp      NZ,FORFND       ; No nesting found
1410+ 1C7D 09                   add     HL,BC           ; Move into "FOR" block
1411+ 1C7E D5                   push    DE              ; Save code string address
1412+ 1C7F 2B                   dec     HL
1413+ 1C80 56                   ld      D,(HL)          ; Get MSB of loop statement
1414+ 1C81 2B                   dec     HL
1415+ 1C82 5E                   ld      E,(HL)          ; Get LSB of loop statement
1416+ 1C83 23                   inc     HL
1417+ 1C84 23                   inc     HL
1418+ 1C85 E5                   push    HL              ; Save block address
1419+ 1C86 2A 11 55             ld      HL,(LOOPST)     ; Get address of loop statement
1420+ 1C89 CD CC 1A             call    CPDEHL          ; Compare the FOR loops
1421+ 1C8C E1                   pop     HL              ; Restore block address
1422+ 1C8D C2 76 1C             jp      NZ,FORSLP       ; Different FORs - Find another
1423+ 1C90 D1                   pop     DE              ; Restore code string address
1424+ 1C91 F9                   ld      SP,HL           ; Remove all nested loops
1425+ 1C92
1426+ 1C92 EB           FORFND: ex      DE,HL           ; Code string address to HL
1427+ 1C93 0E 08                ld      C,$08
1428+ 1C95 CD 8F 17             call    CHKSTK          ; Check for 8 levels of stack
1429+ 1C98 E5                   push    HL              ; Save code string address
1430+ 1C99 2A 11 55             ld      HL,(LOOPST)     ; Get first statement of loop
1431+ 1C9C E3                   ex      (SP),HL         ; Save and restore code string
1432+ 1C9D E5                   push    HL              ; Re-save code string address
1433+ 1C9E 2A ED 53             ld      HL,(LINEAT)     ; Get current line number
1434+ 1CA1 E3                   ex      (SP),HL         ; Save and restore code string
1435+ 1CA2 CD AF 21             call    TSTNUM          ; Make sure it's a number
1436+ 1CA5 CD D2 1A             call    CHKSYN          ; Make sure "TO" is next
1437+ 1CA8 B8                   defb    ZTO             ; "TO" token
1438+ 1CA9 CD AC 21             call    GETNUM          ; Get "TO" expression value
1439+ 1CAC E5                   push    HL              ; Save code string address
1440+ 1CAD CD 05 30             call    BCDEFP          ; Move "TO" value to BCDE
1441+ 1CB0 E1                   pop     HL              ; Restore code string address
1442+ 1CB1 C5                   push    BC              ; Save "TO" value in block
1443+ 1CB2 D5                   push    DE
1444+ 1CB3 01 00 81             ld      BC,$8100        ; BCDE - 1 (default STEP)
1445+ 1CB6 51                   ld      D,C             ; C=0
1446+ 1CB7 5A                   ld      E,D             ; D=0
1447+ 1CB8 7E                   ld      A,(HL)          ; Get next byte in code string
1448+ 1CB9 FE BD                cp      ZSTEP           ; See if "STEP" is stated
1449+ 1CBB 3E 01                ld      A,$01           ; Sign of step = 1
1450+ 1CBD C2 CE 1C             jp      NZ,SAVSTP       ; No STEP given - Default to 1
1451+ 1CC0 CD 1B 1D             call    GETCHR          ; Jump over "STEP" token
1452+ 1CC3 CD AC 21             call    GETNUM          ; Get step value
1453+ 1CC6 E5                   push    HL              ; Save code string address
1454+ 1CC7 CD 05 30             call    BCDEFP          ; Move STEP to BCDE
1455+ 1CCA CD B9 2F             call    TSTSGN          ; Test sign of FPREG
1456+ 1CCD E1                   pop     HL              ; Restore code string address
1457+ 1CCE C5           SAVSTP: push    BC              ; Save the STEP value in block
1458+ 1CCF D5                   push    DE
1459+ 1CD0 F5                   push    AF              ; Save sign of STEP
1460+ 1CD1 33                   inc     SP              ; Don't save flags
1461+ 1CD2 E5                   push    HL              ; Save code string address
1462+ 1CD3 2A 18 55             ld      HL,(BRKLIN)     ; Get address of index variable
1463+ 1CD6 E3                   ex      (SP),HL         ; Save and restore code string
1464+ 1CD7 06 81        PUTFID: ld      B,ZFOR          ; "FOR" block marker
1465+ 1CD9 C5                   push    BC              ; Save it
1466+ 1CDA 33                   inc     SP              ; Don't save C
1467+ 1CDB
1468+ 1CDB CD 46 1D     RUNCNT: call    TSTBRK          ; Execution driver - Test break
1469+ 1CDE 22 18 55             ld      (BRKLIN),HL     ; Save code address for break
1470+ 1CE1 7E                   ld      A,(HL)          ; Get next byte in code string
1471+ 1CE2 FE 3A                cp      ':'             ; Multi statement line?
1472+ 1CE4 CA FB 1C             jp      Z,EXCUTE        ; Yes - Execute it
1473+ 1CE7 B7                   or      A               ; End of line?
1474+ 1CE8 C2 D2 17             jp      NZ,SNERR        ; No - Syntax error
1475+ 1CEB 23                   inc     HL              ; Point to address of next line
1476+ 1CEC 7E                   ld      A,(HL)          ; Get LSB of line pointer
1477+ 1CED 23                   inc     HL
1478+ 1CEE B6                   or      (HL)            ; Is it zero (End of prog)?
1479+ 1CEF CA 6D 1D             jp      Z,ENDPRG        ; Yes - Terminate execution
1480+ 1CF2 23                   inc     HL              ; Point to line number
1481+ 1CF3 5E                   ld      E,(HL)          ; Get LSB of line number
1482+ 1CF4 23                   inc     HL
1483+ 1CF5 56                   ld      D,(HL)          ; Get MSB of line number
1484+ 1CF6 EB                   ex      DE,HL           ; Line number to HL
1485+ 1CF7 22 ED 53             ld      (LINEAT),HL     ; Save as current line number
1486+ 1CFA EB                   ex      DE,HL           ; Line number back to DE
1487+ 1CFB CD 1B 1D     EXCUTE: call    GETCHR          ; Get key word
1488+ 1CFE 11 DB 1C             ld      DE,RUNCNT       ; Where to RETurn to
1489+ 1D01 D5                   push    DE              ; Save for RETurn
1490+ 1D02 C8           IFJMP:  ret     Z               ; Go to RUNCNT if end of STMT
1491+ 1D03
1492+ 1D03 D6 80        ONJMP:  sub     ZEND            ; Is it a token?
1493+ 1D05 DA DB 1E             jp      C,LET           ; No - try to assign it
1494+ 1D08 FE 37                cp      ZNEW+1-ZEND     ; END to NEW ?
1495+ 1D0A D2 D2 17             jp      NC,SNERR        ; Not a key word - ?SN Error
1496+ 1D0D 07                   rlca                    ; Double it
1497+ 1D0E 4F                   ld      C,A             ; BC = Offset into table
1498+ 1D0F 06 00                ld      B,0
1499+ 1D11 EB                   ex      DE,HL           ; Save code string address
1500+ 1D12 21 DF 15             ld      HL,WORDTB       ; Keyword address table
1501+ 1D15 09                   add     HL,BC           ; Point to routine address
1502+ 1D16 4E                   ld      C,(HL)          ; Get LSB of routine address
1503+ 1D17 23                   inc     HL
1504+ 1D18 46                   ld      B,(HL)          ; Get MSB of routine address
1505+ 1D19 C5                   push    BC              ; Save routine address
1506+ 1D1A EB                   ex      DE,HL           ; Restore code string address
1507+ 1D1B
1508+ 1D1B              ; get a char from input buffer: exit with NC if character found is
1509+ 1D1B              ; not a number; exit with Z if nothing found; char is into A
1510+ 1D1B 23           GETCHR: inc     HL              ; Point to next character
1511+ 1D1C 7E                   ld      A,(HL)          ; Get next code string byte
1512+ 1D1D FE 3A                cp      ':'             ; Z if ':'
1513+ 1D1F D0                   ret     NC              ; NC if > "9"
1514+ 1D20 FE 20                cp      SPC
1515+ 1D22 CA 1B 1D             jp      Z,GETCHR        ; Skip over spaces
1516+ 1D25 FE 30                cp      '0'
1517+ 1D27 3F                   ccf                     ; NC if < '0'
1518+ 1D28 3C                   inc     A               ; Test for zero - Leave carry
1519+ 1D29 3D                   dec     A               ; Z if Null
1520+ 1D2A C9                   ret
1521+ 1D2B
1522+ 1D2B EB           RESTOR: ex      DE,HL           ; Save code string address
1523+ 1D2C 2A 73 54             ld      HL,(BASTXT)     ; Point to start of program
1524+ 1D2F CA 40 1D             jp      Z,RESTNL        ; Just RESTORE - reset pointer
1525+ 1D32 EB                   ex      DE,HL           ; Restore code string address
1526+ 1D33 CD EB 1D             call    ATOH            ; Get line number to DE
1527+ 1D36 E5                   push    HL              ; Save code string address
1528+ 1D37 CD EE 18             call    SRCHLN          ; Search for line number in DE
1529+ 1D3A 60                   ld      H,B             ; HL = Address of line
1530+ 1D3B 69                   ld      L,C
1531+ 1D3C D1                   pop     DE              ; Restore code string address
1532+ 1D3D D2 9A 1E             jp      NC,ULERR        ; ?UL Error if not found
1533+ 1D40 2B           RESTNL: dec     HL              ; Byte before DATA statement
1534+ 1D41 22 8C 55     UPDATA: ld      (NXTDAT),HL     ; Update DATA pointer
1535+ 1D44 EB                   ex      DE,HL           ; Restore code string address
1536+ 1D45 C9                   ret
1537+ 1D46
1538+ 1D46
1539+ 1D46              ; check if CTRL-C is into input buffer
1540+ 1D46 DF           TSTBRK: rst     $18             ; Check input status
1541+ 1D47 C8                   ret     Z               ; No key, go back
1542+ 1D48 D7                   rst     $10             ; Get the key into A
1543+ 1D49 FE 1B                cp      ESC             ; Escape key?
1544+ 1D4B 28 11                jr      Z,BRK           ; Yes, break
1545+ 1D4D FE 03                cp      CTRLC           ; <Ctrl-C>
1546+ 1D4F 28 0D                jr      Z,BRK           ; Yes, break
1547+ 1D51 FE 13                cp      CTRLS           ; Stop scrolling?
1548+ 1D53 C0                   ret     NZ              ; Other key, ignore
1549+ 1D54
1550+ 1D54
1551+ 1D54              ; wait for a key while listing
1552+ 1D54 D7           STALL:  rst     $10             ; Wait for key
1553+ 1D55 FE 11                cp      CTRLQ           ; Resume scrolling?
1554+ 1D57 C8                   ret     Z               ; Release the chokehold
1555+ 1D58 FE 03                cp      CTRLC           ; Second break?
1556+ 1D5A 28 07                jr      Z,STOP          ; Break during hold exits prog
1557+ 1D5C 18 F6                jr      STALL           ; Loop until <Ctrl-Q> or <brk>
1558+ 1D5E
1559+ 1D5E 3E FF        BRK:    ld      A,$FF           ; Set BRKFLG
1560+ 1D60 32 E7 53             ld      (BRKFLG),A      ; Store it
1561+ 1D63
1562+ 1D63 C0           STOP:   ret     NZ              ; Exit if anything else
1563+ 1D64 F6                   defb    $F6             ; Flag "STOP"
1564+ 1D65 C0           PEND:   ret     NZ              ; Exit if anything else
1565+ 1D66 22 18 55             ld      (BRKLIN),HL     ; Save point of break
1566+ 1D69 21                   defb    $21             ; Skip "OR 11111111B"
1567+ 1D6A F6 FF        INPBRK: or      %11111111       ; Flag "Break" wanted
1568+ 1D6C C1                   pop     BC              ; Return not needed and more
1569+ 1D6D 2A ED 53     ENDPRG: ld      HL,(LINEAT)     ; Get current line number
1570+ 1D70 F5                   push    AF              ; Save STOP / END status
1571+ 1D71 7D                   ld      A,L             ; Is it direct break?
1572+ 1D72 A4                   and     H
1573+ 1D73 3C                   inc     A               ; Line is -1 if direct break
1574+ 1D74 CA 80 1D             jp      Z,NOLIN         ; Yes - No line number
1575+ 1D77 22 1C 55             ld      (ERRLIN),HL     ; Save line of break
1576+ 1D7A 2A 18 55             ld      HL,(BRKLIN)     ; Get point of break
1577+ 1D7D 22 1E 55             ld      (CONTAD),HL     ; Save point to CONTinue
1578+ 1D80 AF           NOLIN:  xor     A
1579+ 1D81 32 E3 53             ld      (CTLOFG),A      ; Enable output
1580+ 1D84 CD D6 1F             call    STTLIN          ; Start a new line
1581+ 1D87 F1                   pop     AF              ; Restore STOP / END status
1582+ 1D88 21 55 17             ld      HL,BRKMSG       ; "Break" message
1583+ 1D8B C2 91 1D             jp      NZ,ERRINT       ; "in line" wanted?
1584+ 1D8E C3 32 18             jp      PRNTOK          ; Go to command mode
1585+ 1D91 CD AC 17     ERRINT: call    EXITGM          ; exit from graphics mode
1586+ 1D94 C3 10 18             jp      ERRIN           ; print message
1587+ 1D97
1588+ 1D97
1589+ 1D97              ; CONTinue after a break/error
1590+ 1D97 21 FF FF     CONT:   ld      HL,-1           ; reset...
1591+ 1D9A 22 EF 53             ld      (HLPLN),HL      ; ...HELP line register
1592+ 1D9D 2A 1E 55             ld      HL,(CONTAD)     ; Get CONTinue address
1593+ 1DA0 7C                   ld      A,H             ; Is it zero?
1594+ 1DA1 B5                   or      L
1595+ 1DA2 1E 20                ld      E,CN            ; ?CN Error
1596+ 1DA4 CA EC 17             jp      Z,ERROR         ; Yes - output "?CN Error"
1597+ 1DA7 EB                   ex      DE,HL           ; Save code string address
1598+ 1DA8 2A 1C 55             ld      HL,(ERRLIN)     ; Get line of last break
1599+ 1DAB 22 ED 53             ld      (LINEAT),HL     ; Set up current line number
1600+ 1DAE EB                   ex      DE,HL           ; Restore code string address
1601+ 1DAF C9                   ret                     ; CONTinue where left off
1602+ 1DB0
1603+ 1DB0 E5           ACCSUM: push    HL              ; Save address in array
1604+ 1DB1 2A E4 53             ld      HL,(CHKSUM)     ; Get check sum
1605+ 1DB4 06 00                ld      B,$00           ; BC - Value of byte
1606+ 1DB6 4F                   ld      C,A
1607+ 1DB7 09                   add     HL,BC           ; Add byte to check sum
1608+ 1DB8 22 E4 53             ld      (CHKSUM),HL     ; Re-save check sum
1609+ 1DBB E1                   pop     HL              ; Restore address in array
1610+ 1DBC C9                   ret
1611+ 1DBD
1612+ 1DBD 7E           CHKLTR: ld      A,(HL)          ; Get byte
1613+ 1DBE FE 41                cp      'A'             ; < 'a' ?
1614+ 1DC0 D8                   ret     C               ; Carry set if not letter
1615+ 1DC1 FE 5B                cp      'Z'+1           ; > 'z' ?
1616+ 1DC3 3F                   ccf
1617+ 1DC4 C9                   ret                     ; Carry set if not letter
1618+ 1DC5
1619+ 1DC5 CD 1B 1D     FPSINT: call    GETCHR          ; Get next character
1620+ 1DC8 CD AC 21     POSINT: call    GETNUM          ; Get integer 0 to 32767
1621+ 1DCB CD B9 2F     DEPINT: call    TSTSGN          ; Test sign of FPREG
1622+ 1DCE FA E6 1D             jp      M,FCERR         ; Negative - ?FC Error
1623+ 1DD1 3A 97 55     DEINT:  ld      A,(FPEXP)       ; Get integer value to DE
1624+ 1DD4 FE 90                cp      $80+$10         ; Exponent in range (16 bits)?
1625+ 1DD6 DA 61 30             jp      C,FPINT         ; Yes - convert it
1626+ 1DD9 01 80 90             ld      BC,$9080        ; BCDE = -32768
1627+ 1DDC 11 00 00             ld      DE,$0000
1628+ 1DDF E5                   push    HL              ; Save code string address
1629+ 1DE0 CD 34 30             call    CMPNUM          ; Compare FPREG with BCDE
1630+ 1DE3 E1                   pop     HL              ; Restore code string address
1631+ 1DE4 51                   ld      D,C             ; MSB to D
1632+ 1DE5 C8                   ret     Z               ; Return if in range
1633+ 1DE6 1E 08        FCERR:  ld      E,FC            ; ?FC Error
1634+ 1DE8 C3 EC 17             jp      ERROR           ; Output error-
1635+ 1DEB
1636+ 1DEB
1637+ 1DEB              ; convert a number in ASCII chars into an integer and store it into DE
1638+ 1DEB 2B           ATOH:   dec     HL              ; ASCII number to DE binary
1639+ 1DEC 11 00 00     GETLN:  ld      DE,$0000        ; Get number to DE
1640+ 1DEF CD 1B 1D     GTLNLP: call    GETCHR          ; Get next character
1641+ 1DF2 D0                   ret     NC              ; Exit if not a digit
1642+ 1DF3 E5                   push    HL              ; Save code string address
1643+ 1DF4 F5                   push    AF              ; Save digit
1644+ 1DF5 21 98 19             ld      HL,65529/10     ; Largest number 65529
1645+ 1DF8 CD CC 1A             call    CPDEHL          ; Number in range?
1646+ 1DFB DA D2 17             jp      C,SNERR         ; No - ?SN Error
1647+ 1DFE 62                   ld      H,D             ; HL = Number
1648+ 1DFF 6B                   ld      L,E
1649+ 1E00 19                   add     HL,DE           ; Times 2
1650+ 1E01 29                   add     HL,HL           ; Times 4
1651+ 1E02 19                   add     HL,DE           ; Times 5
1652+ 1E03 29                   add     HL,HL           ; Times 10
1653+ 1E04 F1                   pop     AF              ; Restore digit
1654+ 1E05 D6 30                sub     '0'             ; Make it 0 to 9
1655+ 1E07 5F                   ld      E,A             ; DE = Value of digit
1656+ 1E08 16 00                ld      D,0
1657+ 1E0A 19                   add     HL,DE           ; Add to number
1658+ 1E0B EB                   ex      DE,HL           ; Number to DE
1659+ 1E0C E1                   pop     HL              ; Restore code string address
1660+ 1E0D C3 EF 1D             jp      GTLNLP          ; Go to next character
1661+ 1E10
1662+ 1E10 CA 1E 19     CLEAR:  jp      Z,INTVAR        ; Just "CLEAR" Keep parameters
1663+ 1E13 CD AC 21             call    GETNUM          ; Evaluate a number
1664+ 1E16 CD D1 1D             call    DEINT           ; Get integer -32768 to 32767 into DE
1665+ 1E19 2B                   dec     HL              ; Cancel increment
1666+ 1E1A CD 1B 1D             call    GETCHR          ; Get next character
1667+ 1E1D E5                   push    HL              ; Save code string address
1668+ 1E1E 2A D4 54             ld      HL,(LSTRAM)     ; Get end of RAM
1669+ 1E21 CA 39 1E             jp      Z,STORED        ; No value given - Use stored
1670+ 1E24 E1                   pop     HL              ; Restore code string address
1671+ 1E25 CD D2 1A             call    CHKSYN          ; Check for comma
1672+ 1E28 2C                   defb    ','
1673+ 1E29 D5                   push    DE              ; Save number
1674+ 1E2A CD AC 21             call    GETNUM          ; Evaluate a number
1675+ 1E2D CD D1 1D             call    DEINT           ; Get integer -32768 to 32767 into DE
1676+ 1E30 2B                   dec     HL              ; Cancel increment
1677+ 1E31 CD 1B 1D             call    GETCHR          ; Get next character
1678+ 1E34 C2 D2 17             jp      NZ,SNERR        ; ?SN Error if more on line
1679+ 1E37 E3                   ex      (SP),HL         ; Save code string address
1680+ 1E38 EB                   ex      DE,HL           ; Number to DE
1681+ 1E39 7D           STORED: ld      A,L             ; Get LSB of new RAM top
1682+ 1E3A 93                   sub     E               ; Subtract LSB of string space
1683+ 1E3B 5F                   ld      E,A             ; Save LSB
1684+ 1E3C 7C                   ld      A,H             ; Get MSB of new RAM top
1685+ 1E3D 9A                   sbc     A,D             ; Subtract MSB of string space
1686+ 1E3E 57                   ld      D,A             ; Save MSB
1687+ 1E3F DA A7 17             jp      C,OMERR         ; ?OM Error if not enough mem
1688+ 1E42 E5                   push    HL              ; Save RAM top
1689+ 1E43 2A 86 55             ld      HL,(PROGND)     ; Get program end
1690+ 1E46 01 28 00             ld      BC,$28          ; 40 Bytes minimum working RAM
1691+ 1E49 09                   add     HL,BC           ; Get lowest address
1692+ 1E4A CD CC 1A             call    CPDEHL          ; Enough memory?
1693+ 1E4D D2 A7 17             jp      NC,OMERR        ; No - ?OM Error
1694+ 1E50 EB                   ex      DE,HL           ; RAM top to HL
1695+ 1E51 22 EB 53             ld      (STRSPC),HL     ; Set new string space
1696+ 1E54 E1                   pop     HL              ; End of memory to use
1697+ 1E55 22 D4 54             ld      (LSTRAM),HL     ; Set new top of RAM
1698+ 1E58 E1                   pop     HL              ; Restore code string address
1699+ 1E59 C3 1E 19             jp      INTVAR          ; Initialise variables
1700+ 1E5C
1701+ 1E5C E5           RUN:    push    HL              ; store HL
1702+ 1E5D 21 FF FF             ld      HL,-1           ; reset...
1703+ 1E60 22 EF 53             ld      (HLPLN),HL      ; ...HELP line register
1704+ 1E63 E1                   pop     HL              ; retrieve HL
1705+ 1E64 CA 1A 19             jp      Z,RUNFST        ; RUN from start if just RUN
1706+ 1E67 CD 1E 19             call    INTVAR          ; Initialise variables
1707+ 1E6A 01 DB 1C             ld      BC,RUNCNT       ; Execution driver loop
1708+ 1E6D C3 80 1E             jp      RUNLIN          ; RUN from line number
1709+ 1E70
1710+ 1E70 0E 03        GOSUB:  ld      C,$03           ; 3 Levels of stack needed
1711+ 1E72 CD 8F 17             call    CHKSTK          ; Check for 3 levels of stack
1712+ 1E75 C1                   pop     BC              ; Get return address
1713+ 1E76 E5                   push    HL              ; Save code string for RETURN
1714+ 1E77 E5                   push    HL              ; And for GOSUB routine
1715+ 1E78 2A ED 53             ld      HL,(LINEAT)     ; Get current line
1716+ 1E7B E3                   ex      (SP),HL         ; Into stack - Code string out
1717+ 1E7C 3E 8C                ld      A,ZGOSUB        ; "GOSUB" token
1718+ 1E7E F5                   push    AF              ; Save token
1719+ 1E7F 33                   inc     SP              ; Don't save flags
1720+ 1E80
1721+ 1E80 C5           RUNLIN: push    BC              ; Save return address
1722+ 1E81 CD EB 1D     GOTO:   call    ATOH            ; ASCII number to DE binary
1723+ 1E84 CD C6 1E             call    REM             ; Get end of line
1724+ 1E87 E5                   push    HL              ; Save end of line
1725+ 1E88 2A ED 53             ld      HL,(LINEAT)     ; Get current line
1726+ 1E8B CD CC 1A             call    CPDEHL          ; Line after current?
1727+ 1E8E E1                   pop     HL              ; Restore end of line
1728+ 1E8F 23                   inc     HL              ; Start of next line
1729+ 1E90 DC F1 18             call    C,SRCHLP        ; Line is after current line
1730+ 1E93 D4 EE 18             call    NC,SRCHLN       ; Line is before current line
1731+ 1E96 60                   ld      H,B             ; Set up code string address
1732+ 1E97 69                   ld      L,C
1733+ 1E98 2B                   dec     HL              ; Incremented after
1734+ 1E99 D8                   ret     C               ; Line found
1735+ 1E9A 1E 0E        ULERR:  ld      E,UL            ; ?UL Error
1736+ 1E9C C3 EC 17             jp      ERROR           ; Output error message
1737+ 1E9F
1738+ 1E9F C0           RETURN: ret     NZ              ; Return if not just RETURN
1739+ 1EA0 16 FF                ld      D,-1            ; Flag "GOSUB" search
1740+ 1EA2 CD 5B 17             call    BAKSTK          ; Look "GOSUB" block
1741+ 1EA5 F9                   ld      SP,HL           ; Kill all FORs in subroutine
1742+ 1EA6 FE 8C                cp      ZGOSUB          ; Test for "GOSUB" token
1743+ 1EA8 1E 04                ld      E,RG            ; ?RG Error
1744+ 1EAA C2 EC 17             jp      NZ,ERROR        ; Error if no "GOSUB" found
1745+ 1EAD E1                   pop     HL              ; Get RETURN line number
1746+ 1EAE 22 ED 53             ld      (LINEAT),HL     ; Save as current
1747+ 1EB1 23                   inc     HL              ; Was it from direct statement?
1748+ 1EB2 7C                   ld      A,H
1749+ 1EB3 B5                   or      L               ; Return to line
1750+ 1EB4 C2 BE 1E             jp      NZ,RETLIN       ; No - Return to line
1751+ 1EB7 3A 16 55             ld      A,(LSTBIN)      ; Any INPUT in subroutine?
1752+ 1EBA B7                   or      A               ; If so buffer is corrupted
1753+ 1EBB C2 31 18             jp      NZ,POPNOK       ; Yes - Go to command mode
1754+ 1EBE 21 DB 1C     RETLIN: ld      HL,RUNCNT       ; Execution driver loop
1755+ 1EC1 E3                   ex      (SP),HL         ; Into stack - Code string out
1756+ 1EC2 3E                   defb    $3E             ; Skip "pop HL"
1757+ 1EC3 E1           NXTDTA: pop     HL              ; Restore code string address
1758+ 1EC4
1759+ 1EC4 01 3A        DATA:   defb    $01,$3A         ; ':' End of statement (stands for LD BC,$0E3A - NOP)
1760+ 1EC6 0E 00        REM:    ld      C,$00           ; 00  End of statement
1761+ 1EC8 06 00                ld      B,$00
1762+ 1ECA 79           NXTSTL: ld      A,C             ; Statement and byte
1763+ 1ECB 48                   ld      C,B
1764+ 1ECC 47                   ld      B,A             ; Statement end byte
1765+ 1ECD 7E           NXTSTT: ld      A,(HL)          ; Get byte
1766+ 1ECE B7                   or      A               ; End of line?
1767+ 1ECF C8                   ret     Z               ; Yes - Exit
1768+ 1ED0 B8                   cp      B               ; End of statement?
1769+ 1ED1 C8                   ret     Z               ; Yes - Exit
1770+ 1ED2 23                   inc     HL              ; Next byte
1771+ 1ED3 FE 22                cp      $22             ; '"'             ; Literal string?
1772+ 1ED5 CA CA 1E             jp      Z,NXTSTL        ; Yes - Look for another '"'
1773+ 1ED8 C3 CD 1E             jp      NXTSTT          ; Keep looking
1774+ 1EDB
1775+ 1EDB CD BB 23     LET:    call    GETVAR          ; Get variable name
1776+ 1EDE CD D2 1A             call    CHKSYN          ; Make sure "=" follows
1777+ 1EE1 C9                   defb    ZEQUAL          ; "=" token
1778+ 1EE2 D5                   push    DE              ; Save address of variable
1779+ 1EE3 3A D2 54             ld      A,(TYPE)        ; Get data type
1780+ 1EE6 F5                   push    AF              ; Save type
1781+ 1EE7 CD BE 21             call    EVAL            ; Evaluate expression
1782+ 1EEA F1                   pop     AF              ; Restore type
1783+ 1EEB E3                   ex      (SP),HL         ; Save code - Get var addr
1784+ 1EEC 22 18 55             ld      (BRKLIN),HL     ; Save address of variable
1785+ 1EEF 1F                   rra                     ; Adjust type
1786+ 1EF0 CD B1 21             call    CHKTYP          ; Check types are the same
1787+ 1EF3 CA 2E 1F             jp      Z,LETNUM        ; Numeric - Move value
1788+ 1EF6 E5           LETSTR: push    HL              ; Save address of string var
1789+ 1EF7 2A 94 55             ld      HL,(FPREG)      ; Pointer to string entry
1790+ 1EFA E5                   push    HL              ; Save it on stack
1791+ 1EFB 23                   inc     HL              ; Skip over length
1792+ 1EFC 23                   inc     HL
1793+ 1EFD 5E                   ld      E,(HL)          ; LSB of string address
1794+ 1EFE 23                   inc     HL
1795+ 1EFF 56                   ld      D,(HL)          ; MSB of string address
1796+ 1F00 2A 73 54             ld      HL,(BASTXT)     ; Point to start of program
1797+ 1F03 CD CC 1A             call    CPDEHL          ; Is string before program?
1798+ 1F06 D2 1D 1F             jp      NC,CRESTR       ; Yes - Create string entry
1799+ 1F09 2A EB 53             ld      HL,(STRSPC)     ; Point to string space
1800+ 1F0C CD CC 1A             call    CPDEHL          ; Is string literal in program?
1801+ 1F0F D1                   pop     DE              ; Restore address of string
1802+ 1F10 D2 25 1F             jp      NC,MVSTPT       ; Yes - Set up pointer
1803+ 1F13 21 09 55             ld      HL,TMPSTR       ; Temporary string pool
1804+ 1F16 CD CC 1A             call    CPDEHL          ; Is string in temporary pool?
1805+ 1F19 D2 25 1F             jp      NC,MVSTPT       ; No - Set up pointer
1806+ 1F1C 3E                   defb    $3E             ; Skip "pop DE"
1807+ 1F1D D1           CRESTR: pop     DE              ; Restore address of string
1808+ 1F1E CD 15 28             call    BAKTMP          ; Back to last tmp-str entry
1809+ 1F21 EB                   ex      DE,HL           ; Address of string entry
1810+ 1F22 CD 4E 26             call    SAVSTR          ; Save string in string area
1811+ 1F25 CD 15 28     MVSTPT: call    BAKTMP          ; Back to last tmp-str entry
1812+ 1F28 E1                   pop     HL              ; Get string pointer
1813+ 1F29 CD 14 30             call    DETHL4          ; Move string pointer to var
1814+ 1F2C E1                   pop     HL              ; Restore code string address
1815+ 1F2D C9                   ret
1816+ 1F2E
1817+ 1F2E E5           LETNUM: push    HL              ; Save address of variable
1818+ 1F2F CD 11 30             call    FPTHL           ; Move value to variable
1819+ 1F32 D1                   pop     DE              ; Restore address of variable
1820+ 1F33 E1                   pop     HL              ; Restore code string address
1821+ 1F34 C9                   ret
1822+ 1F35
1823+ 1F35 CD 32 2A     ON:     call    GETINT          ; Get integer 0-255
1824+ 1F38 7E                   ld      A,(HL)          ; Get "GOTO" or "GOSUB" token
1825+ 1F39 47                   ld      B,A             ; Save in B
1826+ 1F3A FE 8C                cp      ZGOSUB          ; "GOSUB" token?
1827+ 1F3C CA 44 1F             jp      Z,ONGO          ; Yes - Find line number
1828+ 1F3F CD D2 1A             call    CHKSYN          ; Make sure it's "GOTO"
1829+ 1F42 88                   defb    ZGOTO           ; "GOTO" token
1830+ 1F43 2B                   dec     HL              ; Cancel increment
1831+ 1F44 4B           ONGO:   ld      C,E             ; Integer of branch value
1832+ 1F45 0D           ONGOLP: dec     C               ; Count branches
1833+ 1F46 78                   ld      A,B             ; Get "GOTO" or "GOSUB" token
1834+ 1F47 CA 03 1D             jp      Z,ONJMP         ; Go to that line if right one
1835+ 1F4A CD EC 1D             call    GETLN           ; Get line number to DE
1836+ 1F4D FE 2C                cp      ','             ; Another line number?
1837+ 1F4F C0                   ret     NZ              ; No - Drop through
1838+ 1F50 C3 45 1F             jp      ONGOLP          ; Yes - loop
1839+ 1F53
1840+ 1F53 CD BE 21     IF:     call    EVAL            ; Evaluate expression
1841+ 1F56 7E                   ld      A,(HL)          ; Get token
1842+ 1F57 FE 88                cp      ZGOTO           ; "GOTO" token?
1843+ 1F59 CA 61 1F             jp      Z,IFGO          ; Yes - Get line
1844+ 1F5C CD D2 1A             call    CHKSYN          ; Make sure it's "THEN"
1845+ 1F5F BB                   defb    ZTHEN           ; "THEN" token
1846+ 1F60 2B                   dec     HL              ; Cancel increment
1847+ 1F61 CD AF 21     IFGO:   call    TSTNUM          ; Make sure it's numeric
1848+ 1F64 CD B9 2F             call    TSTSGN          ; Test state of expression
1849+ 1F67 CA 73 1F             jp      Z,IF1           ; False - Jump over
1850+ 1F6A CD 1B 1D     IF0:    call    GETCHR          ; Get next character
1851+ 1F6D DA 81 1E             jp      C,GOTO          ; Number - GOTO that line
1852+ 1F70 C3 02 1D             jp      IFJMP           ; Otherwise do statement
1853+ 1F73 0E AF        IF1:    ld      C,ZELSE
1854+ 1F75 CD C8 1E             call    REM+2           ; check statement
1855+ 1F78 B7                   or      A               ; end of line?
1856+ 1F79 C8                   ret     Z               ; yes, leave
1857+ 1F7A FE AF                cp      ZELSE
1858+ 1F7C 20 F5                jr      NZ,IF1          ; ELSE not found, continue check
1859+ 1F7E C3 6A 1F             jp      IF0             ; return to IF
1860+ 1F81
1861+ 1F81
1862+ 1F81 2B           MRPRNT: dec     HL              ; dec 'cos GETCHR INCs
1863+ 1F82 CD 1B 1D             call    GETCHR          ; Get next character
1864+ 1F85 CA E8 1F     PRINT:  jp      Z,PRNTCRLF      ; CRLF if just PRINT
1865+ 1F88 C8           PRNTLP: ret     Z               ; End of list - Exit
1866+ 1F89 FE B7                cp      ZTAB            ; "TAB(" token?
1867+ 1F8B CA 10 20             jp      Z,DOTAB         ; Yes - Do TAB routine
1868+ 1F8E FE BA                cp      ZSPC            ; "SPC(" token?
1869+ 1F90 CA 10 20             jp      Z,DOTAB         ; Yes - Do SPC routine
1870+ 1F93 E5                   push    HL              ; Save code string address
1871+ 1F94 FE 2C                cp      ','             ; Comma?
1872+ 1F96 CA F7 1F             jp      Z,DOCOM         ; Yes - Move to next zone
1873+ 1F99 FE 3B                cp      ';'             ; Semi-colon?
1874+ 1F9B CA 34 20             jp      Z,NEXITM        ; Do semi-colon routine
1875+ 1F9E C1                   pop     BC              ; Code string address to BC
1876+ 1F9F CD BE 21             call    EVAL            ; Evaluate expression
1877+ 1FA2 E5                   push    HL              ; Save code string address
1878+ 1FA3 3A D2 54             ld      A,(TYPE)        ; Get variable type
1879+ 1FA6 B7                   or      A               ; Is it a string variable?
1880+ 1FA7 C2 CF 1F             jp      NZ,PRNTST       ; Yes - Output string contents
1881+ 1FAA CD 5E 31             call    NUMASC          ; Convert number to text
1882+ 1FAD CD 72 26             call    CRTST           ; Create temporary string
1883+ 1FB0 36 00                ld      (HL),NLLCR      ; Followed by a NULL char (was SPC, space)
1884+ 1FB2 2A 94 55             ld      HL,(FPREG)      ; Get length of output
1885+ 1FB5 34                   inc     (HL)            ; Plus 1 for the space
1886+ 1FB6 2A 94 55             ld      HL,(FPREG)      ; < Not needed >
1887+ 1FB9 3A E0 53             ld      A,(LWIDTH)      ; Get width of line
1888+ 1FBC 47                   ld      B,A             ; To B
1889+ 1FBD 04                   inc     B               ; Width 255 (No limit)?
1890+ 1FBE CA CB 1F             jp      Z,PRNTNB        ; Yes - Output number string
1891+ 1FC1 04                   inc     B               ; Adjust it
1892+ 1FC2 3A D0 54             ld      A,(CURPOS)      ; Get cursor position
1893+ 1FC5 86                   add     A,(HL)          ; Add length of string
1894+ 1FC6 3D                   dec     A               ; Adjust it
1895+ 1FC7 B8                   cp      B               ; Will output fit on this line?
1896+ 1FC8 D4 E8 1F             call    NC,PRNTCRLF     ; No - CRLF first
1897+ 1FCB CD B7 26     PRNTNB: call    PRS1            ; Output string at (HL)
1898+ 1FCE AF                   xor     A               ; Skip call by setting 'z' flag
1899+ 1FCF C4 B7 26     PRNTST: call    NZ,PRS1         ; Output string at (HL)
1900+ 1FD2 E1                   pop     HL              ; Restore code string address
1901+ 1FD3 C3 81 1F             jp      MRPRNT          ; See if more to PRINT
1902+ 1FD6
1903+ 1FD6 3A D0 54     STTLIN: ld      A,(CURPOS)      ; Make sure on new line
1904+ 1FD9 B7                   or      A               ; Already at start?
1905+ 1FDA C8                   ret     Z               ; Yes - Do nothing
1906+ 1FDB C3 E8 1F             jp      PRNTCRLF        ; Start a new line
1907+ 1FDE
1908+ 1FDE AF           ENDINP: xor     A
1909+ 1FDF 32 7A 55             ld      (KBDNPT),A      ; char is not from keyboard
1910+ 1FE2 77                   ld      (HL),A          ; Mark end of buffer
1911+ 1FE3 21 75 54             ld      HL,BUFFER-1     ; Point to buffer
1912+ 1FE6 18 0A                jr      CNTEND
1913+ 1FE8 3E 0D        PRNTCRLF:ld     A,CR            ; Load a CR
1914+ 1FEA CD DD 1A             call    OUTC            ; Output character
1915+ 1FED 3E 0A                ld      A,LF            ; Load a LF
1916+ 1FEF CD DD 1A             call    OUTC            ; Output character
1917+ 1FF2 AF           CNTEND: xor     A               ; Set to position 0
1918+ 1FF3 32 D0 54             ld      (CURPOS),A      ; Store it
1919+ 1FF6 C9                   ret                     ; return to caller
1920+ 1FF7
1921+ 1FF7 3A E1 53     DOCOM:  ld      A,(COMMAN)      ; Get comma width
1922+ 1FFA 47                   ld      B,A             ; Save in B
1923+ 1FFB 3A 35 55             ld      A,(SCR_CURS_X)  ; Get current position
1924+ 1FFE B8                   cp      B               ; Within the limit?
1925+ 1FFF D4 E8 1F             call    NC,PRNTCRLF     ; No - output CRLF
1926+ 2002 D2 34 20             jp      NC,NEXITM       ; Get next item
1927+ 2005 D6 0A        ZONELP: sub     $0A             ; Next zone of 10 characters
1928+ 2007 D2 05 20             jp      NC,ZONELP       ; Repeat if more zones
1929+ 200A 2F                   cpl                     ; Number of null chars to output
1930+ 200B 0E 00                ld      C,NLLCR         ; null char
1931+ 200D C3 2A 20             jp      ASPCS           ; Output them
1932+ 2010
1933+ 2010 F5           DOTAB:  push    AF              ; Save token
1934+ 2011 CD 2F 2A             call    FNDNUM          ; Evaluate expression
1935+ 2014 CD D2 1A             call    CHKSYN          ; Make sure ")" follows
1936+ 2017 29                   defb    ')'
1937+ 2018 2B                   dec     HL              ; Back space on to ")"
1938+ 2019 F1                   pop     AF              ; Restore token
1939+ 201A 0E 00                ld      C,NLLCR         ; for SPC we use NULL char (was SPACE)
1940+ 201C D6 BA                sub     ZSPC            ; Was it "SPC(" ?
1941+ 201E E5                   push    HL              ; Save code string address
1942+ 201F CA 25 20             jp      Z,DOSPC         ; Yes - Do 'E' spaces
1943+ 2022 3A 35 55             ld      A,(SCR_CURS_X)  ; Get current X position
1944+ 2025 2F           DOSPC:  cpl                     ; Number of spaces to print to
1945+ 2026 83                   add     A,E             ; Total number to print
1946+ 2027 D2 34 20             jp      NC,NEXITM       ; TAB < Current POS(X)
1947+ 202A 3C           ASPCS:  inc     A               ; Output A spaces
1948+ 202B 47                   ld      B,A             ; Save number to print
1949+ 202C 79           SPCLP:  ld      A,C             ; char to print
1950+ 202D CD DD 1A             call    OUTC            ; Output character in A
1951+ 2030 05                   dec     B               ; Count them
1952+ 2031 C2 2C 20             jp      NZ,SPCLP        ; Repeat if more
1953+ 2034 E1           NEXITM: pop     HL              ; Restore code string address
1954+ 2035 CD 1B 1D             call    GETCHR          ; Get next character
1955+ 2038 C3 88 1F             jp      PRNTLP          ; More to print
1956+ 203B
1957+ 203B 3F 52 65 64  REDO:   defb    "?Redo from start",CR,0
1957+ 203F 6F 20 66 72
1957+ 2043 6F 6D 20 73
1957+ 2047 74 61 72 74
1957+ 204B 0D 00
1958+ 204D
1959+ 204D 3A 17 55     BADINP: ld      A,(READFG)      ; READ or INPUT?
1960+ 2050 B7                   or      A
1961+ 2051 C2 CC 17             jp      NZ,DATSNR       ; READ - ?SN Error
1962+ 2054 C1                   pop     BC              ; Throw away code string addr
1963+ 2055 21 3B 20             ld      HL,REDO         ; "Redo from start" message
1964+ 2058 CD B4 26             call    PRS             ; Output string
1965+ 205B C3 4D 19             jp      DOAGN           ; Do last INPUT again
1966+ 205E
1967+ 205E CD 1F 26     INPUT:  call    IDTEST          ; Test for illegal direct
1968+ 2061 7E                   ld      A,(HL)          ; Get character after "INPUT"
1969+ 2062 FE 22                cp      $22             ; '"' ; Is there a prompt string?
1970+ 2064 3E 00                ld      A,$00           ; Clear A and leave flags
1971+ 2066 32 E3 53             ld      (CTLOFG),A      ; Enable output
1972+ 2069 C2 78 20             jp      NZ,NOPMPT       ; No prompt - get input
1973+ 206C CD 73 26             call    QTSTR           ; Get string terminated by '"'
1974+ 206F CD D2 1A             call    CHKSYN          ; Check for ';' after prompt
1975+ 2072 3B                   defb    ";"
1976+ 2073 E5                   push    HL              ; Save code string address
1977+ 2074 CD B7 26             call    PRS1            ; Output prompt string
1978+ 2077 3E                   defb    $3E             ; Skip "push HL"
1979+ 2078 E5           NOPMPT: push    HL              ; Save code string address
1980+ 2079 CD 51 19             call    PROMPT          ; Get input with "? " prompt
1981+ 207C C1                   pop     BC              ; Restore code string address
1982+ 207D DA 6A 1D             jp      C,INPBRK        ; Break pressed - Exit
1983+ 2080 23                   inc     HL              ; Next byte
1984+ 2081 7E                   ld      A,(HL)          ; Get it
1985+ 2082 B7                   or      A               ; End of line?
1986+ 2083 2B                   dec     HL              ; Back again
1987+ 2084 C5                   push    BC              ; Re-save code string address
1988+ 2085 3A 82 55             ld      A,(SERIALS_EN)  ; load serial state
1989+ 2088 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
1990+ 208A CC 8F 01             call    Z,A_RTS_OFF      ; yes, set RTS on
1991+ 208D CD 3B 09             call    CURSOR_OFF      ; disable cursor
1992+ 2090 CA C3 1E             jp      Z,NXTDTA        ; Yes - Find next DATA stmt
1993+ 2093 36 2C                ld      (HL),','        ; Store comma as separator
1994+ 2095 C3 9D 20             jp      NXTITM          ; Get next item
1995+ 2098
1996+ 2098 E5           READ:   push    HL              ; Save code string address
1997+ 2099 2A 8C 55             ld      HL,(NXTDAT)     ; Next DATA statement
1998+ 209C F6                   defb    $F6             ; Flag "READ"
1999+ 209D AF           NXTITM: xor     A               ; Flag "INPUT"
2000+ 209E 32 17 55             ld      (READFG),A      ; Save "READ"/"INPUT" flag
2001+ 20A1 E3                   ex      (SP),HL         ; Get code str' , Save pointer
2002+ 20A2 C3 A9 20             jp      GTVLUS          ; Get values
2003+ 20A5
2004+ 20A5 CD D2 1A     NEDMOR: call    CHKSYN          ; Check for comma between items
2005+ 20A8 2C                   defb    ','
2006+ 20A9 CD BB 23     GTVLUS: call    GETVAR          ; Get variable name
2007+ 20AC E3                   ex      (SP),HL         ; Save code str" , Get pointer
2008+ 20AD D5                   push    DE              ; Save variable address
2009+ 20AE 7E                   ld      A,(HL)          ; Get next "INPUT"/"DATA" byte
2010+ 20AF FE 2C                cp      ','             ; Comma?
2011+ 20B1 CA D1 20             jp      Z,ANTVLU        ; Yes - Get another value
2012+ 20B4 3A 17 55             ld      A,(READFG)      ; Is it READ?
2013+ 20B7 B7                   or      A
2014+ 20B8 C2 3D 21             jp      NZ,FDTLP        ; Yes - Find next DATA stmt
2015+ 20BB 3E 3F                ld      A,'?'           ; More INPUT needed
2016+ 20BD CD DD 1A             call    OUTC            ; Output character
2017+ 20C0 CD 51 19             call    PROMPT          ; Get INPUT with prompt
2018+ 20C3 D1                   pop     DE              ; Variable address
2019+ 20C4 C1                   pop     BC              ; Code string address
2020+ 20C5 DA 6A 1D             jp      C,INPBRK        ; Break pressed
2021+ 20C8 23                   inc     HL              ; Point to next DATA byte
2022+ 20C9 7E                   ld      A,(HL)          ; Get byte
2023+ 20CA B7                   or      A               ; Is it zero (No input) ?
2024+ 20CB 2B                   dec     HL              ; Back space INPUT pointer
2025+ 20CC C5                   push    BC              ; Save code string address
2026+ 20CD CA C3 1E             jp      Z,NXTDTA        ; Find end of buffer
2027+ 20D0 D5                   push    DE              ; Save variable address
2028+ 20D1 3A D2 54     ANTVLU: ld      A,(TYPE)        ; Check data type
2029+ 20D4 B7                   or      A               ; Is it numeric?
2030+ 20D5 CA FB 20             jp      Z,INPBIN        ; Yes - Convert to binary
2031+ 20D8 CD 1B 1D             call    GETCHR          ; Get next character
2032+ 20DB 57                   ld      D,A             ; Save input character
2033+ 20DC 47                   ld      B,A             ; Again
2034+ 20DD FE 22                cp      $22             ; '"'     ; Start of literal sting?
2035+ 20DF CA EF 20             jp      Z,STRENT        ; Yes - Create string entry
2036+ 20E2 3A 17 55             ld      A,(READFG)      ; "READ" or "INPUT" ?
2037+ 20E5 B7                   or      A
2038+ 20E6 57                   ld      D,A             ; Save 00 if "INPUT"
2039+ 20E7 CA EC 20             jp      Z,ITMSEP        ; "INPUT" - End with 00
2040+ 20EA 16 3A                ld      D,':'           ; "DATA" - End with 00 or ':'
2041+ 20EC 06 2C        ITMSEP: ld      B,','           ; Item separator
2042+ 20EE 2B                   dec     HL              ; Back space for DTSTR
2043+ 20EF CD 76 26     STRENT: call    DTSTR           ; Get string terminated by D
2044+ 20F2 EB                   ex      DE,HL           ; String address to DE
2045+ 20F3 21 06 21             ld      HL,LTSTND       ; Where to go after LETSTR
2046+ 20F6 E3                   ex      (SP),HL         ; Save HL , get input pointer
2047+ 20F7 D5                   push    DE              ; Save address of string
2048+ 20F8 C3 F6 1E             jp      LETSTR          ; Assign string to variable
2049+ 20FB
2050+ 20FB CD 1B 1D     INPBIN: call    GETCHR          ; Get next character
2051+ 20FE CD C0 30             call    ASCTFP          ; Convert ASCII to FP number
2052+ 2101 E3                   ex      (SP),HL         ; Save input ptr, Get var addr
2053+ 2102 CD 11 30             call    FPTHL           ; Move FPREG to variable
2054+ 2105 E1                   pop     HL              ; Restore input pointer
2055+ 2106 2B           LTSTND: dec     HL              ; dec 'cos GETCHR INCs
2056+ 2107 CD 1B 1D             call    GETCHR          ; Get next character
2057+ 210A CA 12 21             jp      Z,MORDT         ; End of line - More needed?
2058+ 210D FE 2C                cp      ','             ; Another value?
2059+ 210F C2 4D 20             jp      NZ,BADINP       ; No - Bad input
2060+ 2112 E3           MORDT:  ex      (SP),HL         ; Get code string address
2061+ 2113 2B                   dec     HL              ; dec 'cos GETCHR INCs
2062+ 2114 CD 1B 1D             call    GETCHR          ; Get next character
2063+ 2117 C2 A5 20             jp      NZ,NEDMOR       ; More needed - Get it
2064+ 211A D1                   pop     DE              ; Restore DATA pointer
2065+ 211B 3A 17 55             ld      A,(READFG)      ; "READ" or "INPUT" ?
2066+ 211E B7                   or      A
2067+ 211F EB                   ex      DE,HL           ; DATA pointer to HL
2068+ 2120 C2 41 1D             jp      NZ,UPDATA       ; Update DATA pointer if "READ"
2069+ 2123 D5                   push    DE              ; Save code string address
2070+ 2124 B6                   or      (HL)            ; More input given?
2071+ 2125 21 2D 21             ld      HL,EXTIG        ; "?Extra ignored" message
2072+ 2128 C4 B4 26             call    NZ,PRS          ; Output string if extra given
2073+ 212B E1                   pop     HL              ; Restore code string address
2074+ 212C C9                   ret
2075+ 212D
2076+ 212D 3F 45 78 74  EXTIG:  defb    "?Extra ignored",CR,0
2076+ 2131 72 61 20 69
2076+ 2135 67 6E 6F 72
2076+ 2139 65 64 0D 00
2077+ 213D
2078+ 213D CD C4 1E     FDTLP:  call    DATA            ; Get next statement
2079+ 2140 B7                   or      A               ; End of line?
2080+ 2141 C2 56 21             jp      NZ,FANDT        ; No - See if DATA statement
2081+ 2144 23                   inc     HL
2082+ 2145 7E                   ld      A,(HL)          ; End of program?
2083+ 2146 23                   inc     HL
2084+ 2147 B6                   or      (HL)            ; 00 00 Ends program
2085+ 2148 1E 06                ld      E,OD            ; ?OD Error
2086+ 214A CA EC 17             jp      Z,ERROR         ; Yes - Out of DATA
2087+ 214D 23                   inc     HL
2088+ 214E 5E                   ld      E,(HL)          ; LSB of line number
2089+ 214F 23                   inc     HL
2090+ 2150 56                   ld      D,(HL)          ; MSB of line number
2091+ 2151 EB                   ex      DE,HL
2092+ 2152 22 13 55             ld      (DATLIN),HL     ; Set line of current DATA item
2093+ 2155 EB                   ex      DE,HL
2094+ 2156 CD 1B 1D     FANDT:  call    GETCHR          ; Get next character
2095+ 2159 FE 83                cp      ZDATA           ; "DATA" token
2096+ 215B C2 3D 21             jp      NZ,FDTLP        ; No "DATA" - Keep looking
2097+ 215E C3 D1 20             jp      ANTVLU          ; Found - Convert input
2098+ 2161
2099+ 2161 11 00 00     NEXT:   ld      DE,$0000        ; In case no index given
2100+ 2164 C4 BB 23     NEXT1:  call    NZ,GETVAR       ; Get index address
2101+ 2167 22 18 55             ld      (BRKLIN),HL     ; Save code string address
2102+ 216A CD 5B 17             call    BAKSTK          ; Look for "FOR" block
2103+ 216D C2 D8 17             jp      NZ,NFERR        ; No "FOR" - ?NF Error
2104+ 2170 F9                   ld      SP,HL           ; Clear nested loops
2105+ 2171 D5                   push    DE              ; Save index address
2106+ 2172 7E                   ld      A,(HL)          ; Get sign of STEP
2107+ 2173 23                   inc     HL
2108+ 2174 F5                   push    AF              ; Save sign of STEP
2109+ 2175 D5                   push    DE              ; Save index address
2110+ 2176 CD F7 2F             call    PHLTFP          ; Move index value to FPREG
2111+ 2179 E3                   ex      (SP),HL         ; Save address of TO value
2112+ 217A E5                   push    HL              ; Save address of index
2113+ 217B CD 13 2D             call    ADDPHL          ; Add STEP to index value
2114+ 217E E1                   pop     HL              ; Restore address of index
2115+ 217F CD 11 30             call    FPTHL           ; Move value to index variable
2116+ 2182 E1                   pop     HL              ; Restore address of TO value
2117+ 2183 CD 08 30             call    LOADFP          ; Move TO value to BCDE
2118+ 2186 E5                   push    HL              ; Save address of line of FOR
2119+ 2187 CD 34 30             call    CMPNUM          ; Compare index with TO value
2120+ 218A E1                   pop     HL              ; Restore address of line num
2121+ 218B C1                   pop     BC              ; Address of sign of STEP
2122+ 218C 90                   sub     B               ; Compare with expected sign
2123+ 218D CD 08 30             call    LOADFP          ; BC = Loop stmt,DE = Line num
2124+ 2190 CA 9C 21             jp      Z,KILFOR        ; Loop finished - Terminate it
2125+ 2193 EB                   ex      DE,HL           ; Loop statement line number
2126+ 2194 22 ED 53             ld      (LINEAT),HL     ; Set loop line number
2127+ 2197 69                   ld      L,C             ; Set code string to loop
2128+ 2198 60                   ld      H,B
2129+ 2199 C3 D7 1C             jp      PUTFID          ; Put back "FOR" and continue
2130+ 219C
2131+ 219C F9           KILFOR: ld      SP,HL           ; Remove "FOR" block
2132+ 219D 2A 18 55             ld      HL,(BRKLIN)     ; Code string after "NEXT"
2133+ 21A0 7E                   ld      A,(HL)          ; Get next byte in code string
2134+ 21A1 FE 2C                cp      ','             ; More NEXTs ?
2135+ 21A3 C2 DB 1C             jp      NZ,RUNCNT       ; No - Do next statement
2136+ 21A6 CD 1B 1D             call    GETCHR          ; Position to index name
2137+ 21A9 CD 64 21             call    NEXT1           ; Re-enter NEXT routine
2138+ 21AC              ; < will not RETurn to here , Exit to RUNCNT or Loop >
2139+ 21AC
2140+ 21AC CD BE 21     GETNUM: call    EVAL            ; Get a numeric expression
2141+ 21AF F6           TSTNUM: defb    $F6             ; Clear carry (numeric)
2142+ 21B0 37           TSTSTR: scf                     ; Set carry (string)
2143+ 21B1 3A D2 54     CHKTYP: ld      A,(TYPE)        ; Check types match
2144+ 21B4 8F                   adc     A,A             ; Expected + actual
2145+ 21B5 B7                   or      A               ; Clear carry , set parity
2146+ 21B6 E8                   ret     PE              ; Even parity - Types match
2147+ 21B7 C3 E4 17             jp      TMERR           ; Different types - Error
2148+ 21BA
2149+ 21BA CD D2 1A     OPNPAR: call    CHKSYN          ; Make sure "(" follows
2150+ 21BD 28                   defb    '('
2151+ 21BE 2B           EVAL:   dec     HL              ; Evaluate expression & save
2152+ 21BF 16 00                ld      D,$00           ; Precedence value
2153+ 21C1 D5           EVAL1:  push    DE              ; Save precedence
2154+ 21C2 0E 01                ld      C,$01
2155+ 21C4 CD 8F 17             call    CHKSTK          ; Check for 1 level of stack
2156+ 21C7 CD 35 22             call    OPRND           ; Get next expression value
2157+ 21CA 22 1A 55     EVAL2:  ld      (NXTOPR),HL     ; Save address of next operator
2158+ 21CD 2A 1A 55     EVAL3:  ld      HL,(NXTOPR)     ; Restore address of next opr
2159+ 21D0 C1                   pop     BC              ; Precedence value and operator
2160+ 21D1 78                   ld      A,B             ; Get precedence value
2161+ 21D2 FE 78                cp      $78             ; "AND", "OR", or "XOR" ?
2162+ 21D4 D4 AF 21             call    NC,TSTNUM       ; No - Make sure it's a number
2163+ 21D7 7E                   ld      A,(HL)          ; Get next operator / function
2164+ 21D8 16 00                ld      D,$00           ; Clear Last relation
2165+ 21DA D6 C8        RLTLP:  sub     ZGTR            ; ">" Token
2166+ 21DC DA F6 21             jp      C,FOPRND        ; + - * / ^ AND OR XOR - Test it
2167+ 21DF FE 03                cp      ZLTH+1-ZGTR     ; < = >
2168+ 21E1 D2 F6 21             jp      NC,FOPRND       ; Function - Call it
2169+ 21E4 FE 01                cp      ZEQUAL-ZGTR     ; "="
2170+ 21E6 17                   rla                     ; <- Test for legal
2171+ 21E7 AA                   xor     D               ; <- combinations of < = >
2172+ 21E8 BA                   cp      D               ; <- by combining last token
2173+ 21E9 57                   ld      D,A             ; <- with current one
2174+ 21EA DA D2 17             jp      C,SNERR         ; Error if "<<' '==" or ">>"
2175+ 21ED 22 0F 55             ld      (CUROPR),HL     ; Save address of current token
2176+ 21F0 CD 1B 1D             call    GETCHR          ; Get next character
2177+ 21F3 C3 DA 21             jp      RLTLP           ; Treat the two as one
2178+ 21F6
2179+ 21F6 7A           FOPRND: ld      A,D             ; < = > found ?
2180+ 21F7 B7                   or      A
2181+ 21F8 C2 36 23             jp      NZ,TSTRED       ; Yes - Test for reduction
2182+ 21FB 7E                   ld      A,(HL)          ; Get operator token
2183+ 21FC 22 0F 55             ld      (CUROPR),HL     ; Save operator address
2184+ 21FF D6 BE                sub     ZPLUS           ; Operator or function?
2185+ 2201 D8                   ret     C               ; Neither - Exit
2186+ 2202 FE 0A                cp      ZOR+1-ZPLUS     ; Is it + - * / ^ AND XOR OR ?
2187+ 2204 D0                   ret     NC              ; No - Exit
2188+ 2205 5F                   ld      E,A             ; Coded operator
2189+ 2206 3A D2 54             ld      A,(TYPE)        ; Get data type
2190+ 2209 3D                   dec     A               ; FF = numeric , 00 = string
2191+ 220A B3                   or      E               ; Combine with coded operator
2192+ 220B 7B                   ld      A,E             ; Get coded operator
2193+ 220C CA AA 27             jp      Z,CONCAT        ; String concatenation
2194+ 220F 07                   rlca                    ; Times 2
2195+ 2210 83                   add     A,E             ; Times 3
2196+ 2211 5F                   ld      E,A             ; To DE (D is 0)
2197+ 2212 21 4D 16             ld      HL,PRITAB       ; Precedence table
2198+ 2215 19                   add     HL,DE           ; To the operator concerned
2199+ 2216 78                   ld      A,B             ; Last operator precedence
2200+ 2217 56                   ld      D,(HL)          ; Get evaluation precedence
2201+ 2218 BA                   cp      D               ; Compare with eval precedence
2202+ 2219 D0                   ret     NC              ; Exit if higher precedence
2203+ 221A 23                   inc     HL              ; Point to routine address
2204+ 221B CD AF 21             call    TSTNUM          ; Make sure it's a number
2205+ 221E
2206+ 221E C5           STKTHS: push    BC              ; Save last precedence & token
2207+ 221F 01 CD 21             ld      BC,EVAL3        ; Where to go on prec' break
2208+ 2222 C5                   push    BC              ; Save on stack for return
2209+ 2223 43                   ld      B,E             ; Save operator
2210+ 2224 4A                   ld      C,D             ; Save precedence
2211+ 2225 CD EA 2F             call    STAKFP          ; Move value to stack
2212+ 2228 58                   ld      E,B             ; Restore operator
2213+ 2229 51                   ld      D,C             ; Restore precedence
2214+ 222A 4E                   ld      C,(HL)          ; Get LSB of routine address
2215+ 222B 23                   inc     HL
2216+ 222C 46                   ld      B,(HL)          ; Get MSB of routine address
2217+ 222D 23                   inc     HL
2218+ 222E C5                   push    BC              ; Save routine address
2219+ 222F 2A 0F 55             ld      HL,(CUROPR)     ; Address of current operator
2220+ 2232 C3 C1 21             jp      EVAL1           ; Loop until prec' break
2221+ 2235
2222+ 2235 AF           OPRND:  xor     A               ; Get operand routine
2223+ 2236 32 D2 54             ld      (TYPE),A        ; Set numeric expected
2224+ 2239 CD 1B 1D             call    GETCHR          ; Get next character
2225+ 223C 1E 24                ld      E,MO            ; ?MO Error
2226+ 223E CA EC 17             jp      Z,ERROR         ; No operand - Error
2227+ 2241 DA C0 30             jp      C,ASCTFP        ; Number - Get value
2228+ 2244 CD BD 1D             call    CHKLTR          ; See if a letter
2229+ 2247 D2 9C 22             jp      NC,CONVAR       ; Letter - Find variable
2230+ 224A FE 26                cp      '&'             ; &H = HEX, &B = BINARY
2231+ 224C 20 12                jr      NZ,NOTAMP
2232+ 224E CD 1B 1D             call    GETCHR          ; Get next character
2233+ 2251 FE 48                cp      'H'             ; Hex number indicated? [function added]
2234+ 2253 CA 2B 40             jp      Z,HEXTFP        ; Convert Hex to FPREG
2235+ 2256 FE 42                cp      'B'             ; Binary number indicated? [function added]
2236+ 2258 CA 9B 40             jp      Z,BINTFP        ; Convert Bin to FPREG
2237+ 225B 1E 02                ld      E,SN            ; If neither then a ?SN Error
2238+ 225D CA EC 17             jp      Z,ERROR         ;
2239+ 2260 FE BE        NOTAMP: cp      ZPLUS           ; '+' Token ?
2240+ 2262 CA 35 22             jp      Z,OPRND         ; Yes - Look for operand
2241+ 2265 FE 2E                cp      '.'             ; '.' ?
2242+ 2267 CA C0 30             jp      Z,ASCTFP        ; Yes - Create FP number
2243+ 226A FE BF                cp      ZMINUS          ; '-' Token ?
2244+ 226C CA 8B 22             jp      Z,MINUS         ; Yes - Do minus
2245+ 226F FE 22                cp      $22             ; '"'             ; Literal string ?
2246+ 2271 CA 73 26             jp      Z,QTSTR         ; Get string terminated by '"'
2247+ 2274 FE BC                cp      ZNOT            ; "NOT" Token ?
2248+ 2276 CA 96 23             jp      Z,EVNOT         ; Yes - Eval NOT expression
2249+ 2279 FE B9                cp      ZFN             ; "FN" Token ?
2250+ 227B CA D7 25             jp      Z,DOFN          ; Yes - Do FN routine
2251+ 227E D6 CB                sub     ZSGN            ; Is it a function?
2252+ 2280 D2 AD 22             jp      NC,FNOFST       ; Yes - Evaluate function
2253+ 2283 CD BA 21     EVLPAR: call    OPNPAR          ; Evaluate expression in "()"
2254+ 2286 CD D2 1A             call    CHKSYN          ; Make sure ")" follows
2255+ 2289 29                   defb    ')'
2256+ 228A C9                   ret
2257+ 228B
2258+ 228B 16 7D        MINUS:  ld      D,$7D           ; '-' precedence
2259+ 228D CD C1 21             call    EVAL1           ; Evaluate until prec' break
2260+ 2290 2A 1A 55             ld      HL,(NXTOPR)     ; Get next operator address
2261+ 2293 E5                   push    HL              ; Save next operator address
2262+ 2294 CD E2 2F             call    INVSGN          ; Negate value
2263+ 2297 CD AF 21     RETNUM: call    TSTNUM          ; Make sure it's a number
2264+ 229A E1                   pop     HL              ; Restore next operator address
2265+ 229B C9                   ret
2266+ 229C
2267+ 229C CD BB 23     CONVAR: call    GETVAR          ; Get variable address to DE
2268+ 229F E5           FRMEVL: push    HL              ; Save code string address
2269+ 22A0 EB                   ex      DE,HL           ; Variable address to HL
2270+ 22A1 22 94 55             ld      (FPREG),HL      ; Save address of variable
2271+ 22A4 3A D2 54             ld      A,(TYPE)        ; Get type
2272+ 22A7 B7                   or      A               ; Numeric?
2273+ 22A8 CC F7 2F             call    Z,PHLTFP        ; Yes - Move contents to FPREG
2274+ 22AB E1                   pop     HL              ; Restore code string address
2275+ 22AC C9                   ret
2276+ 22AD
2277+ 22AD 06 00        FNOFST: ld      B,$00           ; Get address of function
2278+ 22AF 07                   rlca                    ; Double function offset
2279+ 22B0 4F                   ld      C,A             ; BC = Offset in function table
2280+ 22B1 C5                   push    BC              ; Save adjusted token value
2281+ 22B2 CD 1B 1D             call    GETCHR          ; Get next character
2282+ 22B5 79                   ld      A,C             ; Get adjusted token value
2283+ 22B6 FE 2C                cp      2*(ZPOINT-ZSGN) ; "POINT" token?
2284+ 22B8 CA E4 37             jp      Z,POINT         ; Yes, do "POINT"
2285+ 22BB FE 2E                cp      2*(ZINSTR-ZSGN) ; "INSTR" token?
2286+ 22BD CA 86 28             jp      Z,INSTR         ; Yes, do "INSTR"
2287+ 22C0 FE 3D                cp      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
2288+ 22C2 DA DE 22             jp      C,FNVAL         ; No - Do function
2289+ 22C5 CD BA 21             call    OPNPAR          ; Evaluate expression  (X,...
2290+ 22C8 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
2291+ 22CB 2C                   defb    ','
2292+ 22CC CD B0 21             call    TSTSTR          ; Make sure it's a string
2293+ 22CF EB                   ex      DE,HL           ; Save code string address
2294+ 22D0 2A 94 55             ld      HL,(FPREG)      ; Get address of string
2295+ 22D3 E3                   ex      (SP),HL         ; Save address of string
2296+ 22D4 E5                   push    HL              ; Save adjusted token value
2297+ 22D5 EB                   ex      DE,HL           ; Restore code string address
2298+ 22D6 CD 32 2A             call    GETINT          ; Get integer 0-255
2299+ 22D9 EB                   ex      DE,HL           ; Save code string address
2300+ 22DA E3                   ex      (SP),HL         ; Save integer,HL = adj' token
2301+ 22DB C3 E6 22             jp      GOFUNC          ; Jump to string function
2302+ 22DE
2303+ 22DE CD 83 22     FNVAL:  call    EVLPAR          ; Evaluate expression
2304+ 22E1 E3                   ex      (SP),HL         ; HL = Adjusted token value
2305+ 22E2 11 97 22             ld      DE,RETNUM       ; Return number from function
2306+ 22E5 D5                   push    DE              ; Save on stack
2307+ 22E6 01 0A 14     GOFUNC: ld      BC,FNCTAB       ; Function routine addresses
2308+ 22E9 09                   add     HL,BC           ; Point to right address
2309+ 22EA 4E                   ld      C,(HL)          ; Get LSB of address
2310+ 22EB 23                   inc     HL              ;
2311+ 22EC 66                   ld      H,(HL)          ; Get MSB of address
2312+ 22ED 69                   ld      L,C             ; Address to HL
2313+ 22EE E9                   jp      (HL)            ; Jump to function
2314+ 22EF
2315+ 22EF 15           SGNEXP: dec     D               ; Dee to flag negative exponent
2316+ 22F0 FE BF                cp      ZMINUS          ; '-' token ?
2317+ 22F2 C8                   ret     Z               ; Yes - Return
2318+ 22F3 FE 2D                cp      '-'             ; '-' ASCII ?
2319+ 22F5 C8                   ret     Z               ; Yes - Return
2320+ 22F6 14                   inc     D               ; Inc to flag positive exponent
2321+ 22F7 FE 2B                cp      '+'             ; '+' ASCII ?
2322+ 22F9 C8                   ret     Z               ; Yes - Return
2323+ 22FA FE BE                cp      ZPLUS           ; '+' token ?
2324+ 22FC C8                   ret     Z               ; Yes - Return
2325+ 22FD 2B                   dec     HL              ; dec 'cos GETCHR INCs
2326+ 22FE C9                   ret                     ; Return "NZ"
2327+ 22FF
2328+ 22FF              ; execute OR, AND, and XOR operations
2329+ 22FF AF           PAND:   xor     A               ; for AND, Z=1
2330+ 2300 18 07                jr      CNTLGC
2331+ 2302 AF           POR:    xor     A               ; for OR, Z=0, S=1
2332+ 2303 D6 01                sub     $01
2333+ 2305 18 02                jr      CNTLGC
2334+ 2307 AF           PXOR:   xor     A               ; for XOR, Z=0, S=0
2335+ 2308 3C                   inc     A
2336+ 2309 F5           CNTLGC: push    AF              ; store operand's flags
2337+ 230A CD AF 21             call    TSTNUM          ; Make sure it's a number
2338+ 230D CD D1 1D             call    DEINT           ; Get integer -32768 to 32767
2339+ 2310 F1                   pop     AF              ; retrieve operand's flags
2340+ 2311 EB                   ex      DE,HL           ; <- Get last
2341+ 2312 C1                   pop     BC              ; <-  value
2342+ 2313 E3                   ex      (SP),HL         ; <-  from
2343+ 2314 EB                   ex      DE,HL           ; <-  stack
2344+ 2315 CD FA 2F             call    FPBCDE          ; Move last value to FPREG
2345+ 2318 F5                   push    AF              ; store operand's flags
2346+ 2319 CD D1 1D             call    DEINT           ; Get integer -32768 to 32767
2347+ 231C F1                   pop     AF              ; retrieve operand's flags
2348+ 231D C1                   pop     BC              ; Get value
2349+ 231E 79                   ld      A,C             ; Get LSB
2350+ 231F 21 95 25             ld      HL,ACPASS       ; Address of save AC as current
2351+ 2322 20 05                jr      NZ,POR1         ; if X/OR, jump over
2352+ 2324 A3           PAND1:  and     E               ; "AND" LSBs
2353+ 2325 4F                   ld      C,A             ; Save LSB
2354+ 2326 78                   ld      A,B             ; Get MSB
2355+ 2327 A2                   and     D               ; "AND" MSBs
2356+ 2328 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2357+ 2329 F2 31 23     POR1:   jp      P,PXOR1         ; if S=0, jump to XOR
2358+ 232C B3                   or      E               ; "OR" LSBs
2359+ 232D 4F                   ld      C,A             ; Save LSB
2360+ 232E 78                   ld      A,B             ; Get MSB
2361+ 232F B2                   or      D               ; "OR" MSBs
2362+ 2330 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2363+ 2331 AB           PXOR1:  xor     E               ; "XOR" LSBs
2364+ 2332 4F                   ld      C,A             ; Save LSB
2365+ 2333 78                   ld      A,B             ; Get MSB
2366+ 2334 AA                   xor     D               ; "XOR" MSBs
2367+ 2335 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2368+ 2336
2369+ 2336 21 48 23     TSTRED: ld      HL,CMPLOG       ; Logical compare routine
2370+ 2339 3A D2 54             ld      A,(TYPE)        ; Get data type
2371+ 233C 1F                   rra                     ; Carry set = string
2372+ 233D 7A                   ld      A,D             ; Get last precedence value
2373+ 233E 17                   rla                     ; Times 2 plus carry
2374+ 233F 5F                   ld      E,A             ; To E
2375+ 2340 16 64                ld      D,$64           ; Relational precedence
2376+ 2342 78                   ld      A,B             ; Get current precedence
2377+ 2343 BA                   cp      D               ; Compare with last
2378+ 2344 D0                   ret     NC              ; Eval if last was rel' or log'
2379+ 2345 C3 1E 22             jp      STKTHS          ; Stack this one and get next
2380+ 2348
2381+ 2348 4A 23        CMPLOG: defw    CMPLG1          ; Compare two values / strings
2382+ 234A 79           CMPLG1: ld      A,C             ; Get data type
2383+ 234B B7                   or      A
2384+ 234C 1F                   rra
2385+ 234D C1                   pop     BC              ; Get last expression to BCDE
2386+ 234E D1                   pop     DE
2387+ 234F F5                   push    AF              ; Save status
2388+ 2350 CD B1 21             call    CHKTYP          ; Check that types match
2389+ 2353 21 8C 23             ld      HL,CMPRES       ; Result to comparison
2390+ 2356 E5                   push    HL              ; Save for RETurn
2391+ 2357 CA 34 30             jp      Z,CMPNUM        ; Compare values if numeric
2392+ 235A AF                   xor     A               ; Compare two strings
2393+ 235B 32 D2 54             ld      (TYPE),A        ; Set type to numeric
2394+ 235E D5                   push    DE              ; Save string name
2395+ 235F CD F7 27             call    GSTRCU          ; Get current string
2396+ 2362 7E                   ld      A,(HL)          ; Get length of string
2397+ 2363 23                   inc     HL
2398+ 2364 23                   inc     HL
2399+ 2365 4E                   ld      C,(HL)          ; Get LSB of address
2400+ 2366 23                   inc     HL
2401+ 2367 46                   ld      B,(HL)          ; Get MSB of address
2402+ 2368 D1                   pop     DE              ; Restore string name
2403+ 2369 C5                   push    BC              ; Save address of string
2404+ 236A F5                   push    AF              ; Save length of string
2405+ 236B CD FB 27             call    GSTRDE          ; Get second string
2406+ 236E CD 08 30             call    LOADFP          ; Get address of second string
2407+ 2371 F1                   pop     AF              ; Restore length of string 1
2408+ 2372 57                   ld      D,A             ; Length to D
2409+ 2373 E1                   pop     HL              ; Restore address of string 1
2410+ 2374 7B           CMPSTR: ld      A,E             ; Bytes of string 2 to do
2411+ 2375 B2                   or      D               ; Bytes of string 1 to do
2412+ 2376 C8                   ret     Z               ; Exit if all bytes compared
2413+ 2377 7A                   ld      A,D             ; Get bytes of string 1 to do
2414+ 2378 D6 01                sub     $01
2415+ 237A D8                   ret     C               ; Exit if end of string 1
2416+ 237B AF                   xor     A
2417+ 237C BB                   cp      E               ; Bytes of string 2 to do
2418+ 237D 3C                   inc     A
2419+ 237E D0                   ret     NC              ; Exit if end of string 2
2420+ 237F 15                   dec     D               ; Count bytes in string 1
2421+ 2380 1D                   dec     E               ; Count bytes in string 2
2422+ 2381 0A                   ld      A,(BC)          ; Byte in string 2
2423+ 2382 BE                   cp      (HL)            ; Compare to byte in string 1
2424+ 2383 23                   inc     HL              ; Move up string 1
2425+ 2384 03                   inc     BC              ; Move up string 2
2426+ 2385 CA 74 23             jp      Z,CMPSTR        ; Same - Try next bytes
2427+ 2388 3F                   ccf                     ; Flag difference (">" or "<")
2428+ 2389 C3 C4 2F             jp      FLGDIF          ; "<" gives -1 , ">" gives +1
2429+ 238C
2430+ 238C 3C           CMPRES: inc     A               ; Increment current value
2431+ 238D 8F                   adc     A,A             ; Double plus carry
2432+ 238E C1                   pop     BC              ; Get other value
2433+ 238F A0                   and     B               ; Combine them
2434+ 2390 C6 FF                add     A,-1            ; Carry set if different
2435+ 2392 9F                   sbc     A,A             ; 00 - Equal , FF - Different
2436+ 2393 C3 CB 2F             jp      FLGREL          ; Set current value & continue
2437+ 2396
2438+ 2396 16 5A        EVNOT:  ld      D,$5A           ; Precedence value for "NOT"
2439+ 2398 CD C1 21             call    EVAL1           ; Eval until precedence break
2440+ 239B CD AF 21             call    TSTNUM          ; Make sure it's a number
2441+ 239E CD D1 1D             call    DEINT           ; Get integer -32768 - 32767
2442+ 23A1 7B                   ld      A,E             ; Get LSB
2443+ 23A2 2F                   cpl                     ; Invert LSB
2444+ 23A3 4F                   ld      C,A             ; Save "NOT" of LSB
2445+ 23A4 7A                   ld      A,D             ; Get MSB
2446+ 23A5 2F                   cpl                     ; Invert MSB
2447+ 23A6 CD 95 25             call    ACPASS          ; Save AC as current
2448+ 23A9 C1                   pop     BC              ; Clean up stack
2449+ 23AA C3 CD 21             jp      EVAL3           ; Continue evaluation
2450+ 23AD
2451+ 23AD 2B           DIMRET: dec     HL              ; dec 'cos GETCHR INCs
2452+ 23AE CD 1B 1D             call    GETCHR          ; Get next character
2453+ 23B1 C8                   ret     Z               ; End of DIM statement
2454+ 23B2 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
2455+ 23B5 2C                   defb    ','
2456+ 23B6 01 AD 23     DIM:    ld      BC,DIMRET       ; Return to "DIMRET"
2457+ 23B9 C5                   push    BC              ; Save on stack
2458+ 23BA F6                   defb    $F6             ; Flag "Create" variable
2459+ 23BB AF           GETVAR: xor     A               ; Find variable address,to DE
2460+ 23BC 32 D1 54             ld      (LCRFLG),A      ; Set locate / create flag
2461+ 23BF 46                   ld      B,(HL)          ; Get First byte of name
2462+ 23C0 CD BD 1D     GTFNAM: call    CHKLTR          ; See if a letter
2463+ 23C3 DA D2 17             jp      C,SNERR         ; ?SN Error if not a letter
2464+ 23C6 AF                   xor     A
2465+ 23C7 4F                   ld      C,A             ; Clear second byte of name
2466+ 23C8 32 D2 54             ld      (TYPE),A        ; Set type to numeric
2467+ 23CB CD 1B 1D             call    GETCHR          ; Get next character
2468+ 23CE DA D7 23             jp      C,SVNAM2        ; Numeric - Save in name
2469+ 23D1 CD BD 1D             call    CHKLTR          ; See if a letter
2470+ 23D4 DA E4 23             jp      C,CHARTY        ; Not a letter - Check type
2471+ 23D7 4F           SVNAM2: ld      C,A             ; Save second byte of name
2472+ 23D8 CD 1B 1D     ENDNAM: call    GETCHR          ; Get next character
2473+ 23DB DA D8 23             jp      C,ENDNAM        ; Numeric - Get another
2474+ 23DE CD BD 1D             call    CHKLTR          ; See if a letter
2475+ 23E1 D2 D8 23             jp      NC,ENDNAM       ; Letter - Get another
2476+ 23E4 D6 24        CHARTY: sub     '$'             ; String variable?
2477+ 23E6 C2 F3 23             jp      NZ,NOTSTR       ; No - Numeric variable
2478+ 23E9 3C                   inc     A               ; A = 1 (string type)
2479+ 23EA 32 D2 54             ld      (TYPE),A        ; Set type to string
2480+ 23ED 0F                   rrca                    ; A = 80H , Flag for string
2481+ 23EE 81                   add     A,C             ; 2nd byte of name has bit 7 on
2482+ 23EF 4F                   ld      C,A             ; Resave second byte on name
2483+ 23F0 CD 1B 1D             call    GETCHR          ; Get next character
2484+ 23F3 3A 15 55     NOTSTR: ld      A,(FORFLG)      ; Array name needed ?
2485+ 23F6 3D                   dec     A
2486+ 23F7 CA A0 24             jp      Z,ARLDSV        ; Yes - Get array name
2487+ 23FA F2 03 24             jp      P,NSCFOR        ; No array with "FOR" or "FN"
2488+ 23FD 7E                   ld      A,(HL)          ; Get byte again
2489+ 23FE D6 28                sub     '('             ; Subscripted variable?
2490+ 2400 CA 78 24             jp      Z,SBSCPT        ; Yes - Sort out subscript
2491+ 2403
2492+ 2403 AF           NSCFOR: xor     A               ; Simple variable
2493+ 2404 32 15 55             ld      (FORFLG),A      ; Clear "FOR" flag
2494+ 2407 E5                   push    HL              ; Save code string address
2495+ 2408 50                   ld      D,B             ; DE = Variable name to find
2496+ 2409 59                   ld      E,C
2497+ 240A 2A 8E 55             ld      HL,(FNRGNM)     ; FN argument name
2498+ 240D CD CC 1A             call    CPDEHL          ; Is it the FN argument?
2499+ 2410 11 90 55             ld      DE,FNARG        ; Point to argument value
2500+ 2413 CA A9 2E             jp      Z,POPHRT        ; Yes - Return FN argument value
2501+ 2416 2A 88 55             ld      HL,(VAREND)     ; End of variables
2502+ 2419 EB                   ex      DE,HL           ; Address of end of search
2503+ 241A 2A 86 55             ld      HL,(PROGND)     ; Start of variables address
2504+ 241D CD CC 1A     FNDVAR: call    CPDEHL          ; End of variable list table?
2505+ 2420 CA 36 24             jp      Z,CFEVAL        ; Yes - Called from EVAL?
2506+ 2423 79                   ld      A,C             ; Get second byte of name
2507+ 2424 96                   sub     (HL)            ; Compare with name in list
2508+ 2425 23                   inc     HL              ; Move on to first byte
2509+ 2426 C2 2B 24             jp      NZ,FNTHR        ; Different - Find another
2510+ 2429 78                   ld      A,B             ; Get first byte of name
2511+ 242A 96                   sub     (HL)            ; Compare with name in list
2512+ 242B 23           FNTHR:  inc     HL              ; Move on to LSB of value
2513+ 242C CA 6A 24             jp      Z,RETADR        ; Found - Return address
2514+ 242F 23                   inc     HL              ; <- Skip
2515+ 2430 23                   inc     HL              ; <- over
2516+ 2431 23                   inc     HL              ; <- F.P.
2517+ 2432 23                   inc     HL              ; <- value
2518+ 2433 C3 1D 24             jp      FNDVAR          ; Keep looking
2519+ 2436
2520+ 2436 E1           CFEVAL: pop     HL              ; Restore code string address
2521+ 2437 E3                   ex      (SP),HL         ; Get return address
2522+ 2438 D5                   push    DE              ; Save address of variable
2523+ 2439 11 9F 22             ld      DE,FRMEVL       ; Return address in EVAL
2524+ 243C CD CC 1A             call    CPDEHL          ; Called from EVAL ?
2525+ 243F D1                   pop     DE              ; Restore address of variable
2526+ 2440 CA 6D 24             jp      Z,RETNUL        ; Yes - Return null variable
2527+ 2443 E3                   ex      (SP),HL         ; Put back return
2528+ 2444 E5                   push    HL              ; Save code string address
2529+ 2445 C5                   push    BC              ; Save variable name
2530+ 2446 01 06 00             ld      BC,$0006        ; 2 byte name plus 4 byte data
2531+ 2449 2A 8A 55             ld      HL,(ARREND)     ; End of arrays
2532+ 244C E5                   push    HL              ; Save end of arrays
2533+ 244D 09                   add     HL,BC           ; Move up 6 bytes
2534+ 244E C1                   pop     BC              ; Source address in BC
2535+ 244F E5                   push    HL              ; Save new end address
2536+ 2450 CD 7E 17             call    MOVUP           ; Move arrays up
2537+ 2453 E1                   pop     HL              ; Restore new end address
2538+ 2454 22 8A 55             ld      (ARREND),HL     ; Set new end address
2539+ 2457 60                   ld      H,B             ; End of variables to HL
2540+ 2458 69                   ld      L,C
2541+ 2459 22 88 55             ld      (VAREND),HL     ; Set new end address
2542+ 245C
2543+ 245C 2B           ZEROLP: dec     HL              ; Back through to zero variable
2544+ 245D 36 00                ld      (HL),$00        ; Zero byte in variable
2545+ 245F CD CC 1A             call    CPDEHL          ; Done them all?
2546+ 2462 C2 5C 24             jp      NZ,ZEROLP       ; No - Keep on going
2547+ 2465 D1                   pop     DE              ; Get variable name
2548+ 2466 73                   ld      (HL),E          ; Store second character
2549+ 2467 23                   inc     HL
2550+ 2468 72                   ld      (HL),D          ; Store first character
2551+ 2469 23                   inc     HL
2552+ 246A EB           RETADR: ex      DE,HL           ; Address of variable in DE
2553+ 246B E1                   pop     HL              ; Restore code string address
2554+ 246C C9                   ret
2555+ 246D
2556+ 246D 32 97 55     RETNUL: ld      (FPEXP),A       ; Set result to zero
2557+ 2470 21 4F 17             ld      HL,ZERBYT       ; Also set a null string
2558+ 2473 22 94 55             ld      (FPREG),HL      ; Save for EVAL
2559+ 2476 E1                   pop     HL              ; Restore code string address
2560+ 2477 C9                   ret
2561+ 2478
2562+ 2478 E5           SBSCPT: push    HL              ; Save code string address
2563+ 2479 2A D1 54             ld      HL,(LCRFLG)     ; Locate/Create and Type
2564+ 247C E3                   ex      (SP),HL         ; Save and get code string
2565+ 247D 57                   ld      D,A             ; Zero number of dimensions
2566+ 247E D5           SCPTLP: push    DE              ; Save number of dimensions
2567+ 247F C5                   push    BC              ; Save array name
2568+ 2480 CD C5 1D             call    FPSINT          ; Get subscript (0-32767)
2569+ 2483 C1                   pop     BC              ; Restore array name
2570+ 2484 F1                   pop     AF              ; Get number of dimensions
2571+ 2485 EB                   ex      DE,HL
2572+ 2486 E3                   ex      (SP),HL         ; Save subscript value
2573+ 2487 E5                   push    HL              ; Save LCRFLG and TYPE
2574+ 2488 EB                   ex      DE,HL
2575+ 2489 3C                   inc     A               ; Count dimensions
2576+ 248A 57                   ld      D,A             ; Save in D
2577+ 248B 7E                   ld      A,(HL)          ; Get next byte in code string
2578+ 248C FE 2C                cp      ','             ; Comma (more to come)?
2579+ 248E CA 7E 24             jp      Z,SCPTLP        ; Yes - More subscripts
2580+ 2491 CD D2 1A             call    CHKSYN          ; Make sure ")" follows
2581+ 2494 29                   defb    ')'
2582+ 2495 22 1A 55             ld      (NXTOPR),HL     ; Save code string address
2583+ 2498 E1                   pop     HL              ; Get LCRFLG and TYPE
2584+ 2499 22 D1 54             ld      (LCRFLG),HL     ; Restore Locate/create & type
2585+ 249C 1E 00                ld      E,$00           ; Flag not CSAVE* or CLOAD*
2586+ 249E D5                   push    DE              ; Save number of dimensions (D)
2587+ 249F 11                   defb    $11             ; Skip "push HL" and "push AF'
2588+ 24A0
2589+ 24A0 E5           ARLDSV: push    HL              ; Save code string address
2590+ 24A1 F5                   push    AF              ; A = 00 , Flags set = Z,N
2591+ 24A2 2A 88 55             ld      HL,(VAREND)     ; Start of arrays
2592+ 24A5 3E                   defb    $3E             ; Skip "add HL,DE"
2593+ 24A6 19           FNDARY: add     HL,DE           ; Move to next array start
2594+ 24A7 EB                   ex      DE,HL
2595+ 24A8 2A 8A 55             ld      HL,(ARREND)     ; End of arrays
2596+ 24AB EB                   ex      DE,HL           ; Current array pointer
2597+ 24AC CD CC 1A             call    CPDEHL          ; End of arrays found?
2598+ 24AF CA D8 24             jp      Z,CREARY        ; Yes - Create array
2599+ 24B2 7E                   ld      A,(HL)          ; Get second byte of name
2600+ 24B3 B9                   cp      C               ; Compare with name given
2601+ 24B4 23                   inc     HL              ; Move on
2602+ 24B5 C2 BA 24             jp      NZ,NXTARY       ; Different - Find next array
2603+ 24B8 7E                   ld      A,(HL)          ; Get first byte of name
2604+ 24B9 B8                   cp      B               ; Compare with name given
2605+ 24BA 23           NXTARY: inc     HL              ; Move on
2606+ 24BB 5E                   ld      E,(HL)          ; Get LSB of next array address
2607+ 24BC 23                   inc     HL
2608+ 24BD 56                   ld      D,(HL)          ; Get MSB of next array address
2609+ 24BE 23                   inc     HL
2610+ 24BF C2 A6 24             jp      NZ,FNDARY       ; Not found - Keep looking
2611+ 24C2 3A D1 54             ld      A,(LCRFLG)      ; Found Locate or Create it?
2612+ 24C5 B7                   or      A
2613+ 24C6 C2 DB 17             jp      NZ,DDERR        ; Create - ?DD Error
2614+ 24C9 F1                   pop     AF              ; Locate - Get number of dim'ns
2615+ 24CA 44                   ld      B,H             ; BC Points to array dim'ns
2616+ 24CB 4D                   ld      C,L
2617+ 24CC CA A9 2E             jp      Z,POPHRT        ; Jump if array load/save
2618+ 24CF 96                   sub     (HL)            ; Same number of dimensions?
2619+ 24D0 CA 36 25             jp      Z,FINDEL        ; Yes - Find element
2620+ 24D3 1E 10        BSERR:  ld      E,BS            ; ?BS Error
2621+ 24D5 C3 EC 17             jp      ERROR           ; Output error
2622+ 24D8
2623+ 24D8 11 04 00     CREARY: ld      DE,$0004        ; 4 Bytes per entry
2624+ 24DB F1                   pop     AF              ; Array to save or 0 dim'ns?
2625+ 24DC CA E6 1D             jp      Z,FCERR         ; Yes - ?FC Error
2626+ 24DF 71                   ld      (HL),C          ; Save second byte of name
2627+ 24E0 23                   inc     HL
2628+ 24E1 70                   ld      (HL),B          ; Save first byte of name
2629+ 24E2 23                   inc     HL
2630+ 24E3 4F                   ld      C,A             ; Number of dimensions to C
2631+ 24E4 CD 8F 17             call    CHKSTK          ; Check if enough memory
2632+ 24E7 23                   inc     HL              ; Point to number of dimensions
2633+ 24E8 23                   inc     HL
2634+ 24E9 22 0F 55             ld      (CUROPR),HL     ; Save address of pointer
2635+ 24EC 71                   ld      (HL),C          ; Set number of dimensions
2636+ 24ED 23                   inc     HL
2637+ 24EE 3A D1 54             ld      A,(LCRFLG)      ; Locate of Create?
2638+ 24F1 17                   rla                     ; Carry set = Create
2639+ 24F2 79                   ld      A,C             ; Get number of dimensions
2640+ 24F3 01 0B 00     CRARLP: ld      BC,10+1         ; Default dimension size 10
2641+ 24F6 D2 FB 24             jp      NC,DEFSIZ       ; Locate - Set default size
2642+ 24F9 C1                   pop     BC              ; Get specified dimension size
2643+ 24FA 03                   inc     BC              ; Include zero element
2644+ 24FB 71           DEFSIZ: ld      (HL),C          ; Save LSB of dimension size
2645+ 24FC 23                   inc     HL
2646+ 24FD 70                   ld      (HL),B          ; Save MSB of dimension size
2647+ 24FE 23                   inc     HL
2648+ 24FF F5                   push    AF              ; Save num' of dim'ns an status
2649+ 2500 E5                   push    HL              ; Save address of dim'n size
2650+ 2501 CD A5 30             call    MLDEBC          ; Multiply DE by BC to find
2651+ 2504 EB                   ex      DE,HL           ; amount of mem needed (to DE)
2652+ 2505 E1                   pop     HL              ; Restore address of dimension
2653+ 2506 F1                   pop     AF              ; Restore number of dimensions
2654+ 2507 3D                   dec     A               ; Count them
2655+ 2508 C2 F3 24             jp      NZ,CRARLP       ; Do next dimension if more
2656+ 250B F5                   push    AF              ; Save locate/create flag
2657+ 250C 42                   ld      B,D             ; MSB of memory needed
2658+ 250D 4B                   ld      C,E             ; LSB of memory needed
2659+ 250E EB                   ex      DE,HL
2660+ 250F 19                   add     HL,DE           ; Add bytes to array start
2661+ 2510 DA A7 17             jp      C,OMERR         ; Too big - Error
2662+ 2513 CD 98 17             call    ENFMEM          ; See if enough memory
2663+ 2516 22 8A 55             ld      (ARREND),HL     ; Save new end of array
2664+ 2519
2665+ 2519 2B           ZERARY: dec     HL              ; Back through array data
2666+ 251A 36 00                ld      (HL),$00        ; Set array element to zero
2667+ 251C CD CC 1A             call    CPDEHL          ; All elements zeroed?
2668+ 251F C2 19 25             jp      NZ,ZERARY       ; No - Keep on going
2669+ 2522 03                   inc     BC              ; Number of bytes + 1
2670+ 2523 57                   ld      D,A             ; A=0
2671+ 2524 2A 0F 55             ld      HL,(CUROPR)     ; Get address of array
2672+ 2527 5E                   ld      E,(HL)          ; Number of dimensions
2673+ 2528 EB                   ex      DE,HL           ; To HL
2674+ 2529 29                   add     HL,HL           ; Two bytes per dimension size
2675+ 252A 09                   add     HL,BC           ; Add number of bytes
2676+ 252B EB                   ex      DE,HL           ; Bytes needed to DE
2677+ 252C 2B                   dec     HL
2678+ 252D 2B                   dec     HL
2679+ 252E 73                   ld      (HL),E          ; Save LSB of bytes needed
2680+ 252F 23                   inc     HL
2681+ 2530 72                   ld      (HL),D          ; Save MSB of bytes needed
2682+ 2531 23                   inc     HL
2683+ 2532 F1                   pop     AF              ; Locate / Create?
2684+ 2533 DA 5A 25             jp      C,ENDDIM        ; A is 0 , End if create
2685+ 2536 47           FINDEL: ld      B,A             ; Find array element
2686+ 2537 4F                   ld      C,A
2687+ 2538 7E                   ld      A,(HL)          ; Number of dimensions
2688+ 2539 23                   inc     HL
2689+ 253A 16                   defb    $16             ; Skip "pop HL"
2690+ 253B E1           FNDELP: pop     HL              ; Address of next dim' size
2691+ 253C 5E                   ld      E,(HL)          ; Get LSB of dim'n size
2692+ 253D 23                   inc     HL
2693+ 253E 56                   ld      D,(HL)          ; Get MSB of dim'n size
2694+ 253F 23                   inc     HL
2695+ 2540 E3                   ex      (SP),HL         ; Save address - Get index
2696+ 2541 F5                   push    AF              ; Save number of dim'ns
2697+ 2542 CD CC 1A             call    CPDEHL          ; Dimension too large?
2698+ 2545 D2 D3 24             jp      NC,BSERR        ; Yes - ?BS Error
2699+ 2548 E5                   push    HL              ; Save index
2700+ 2549 CD A5 30             call    MLDEBC          ; Multiply previous by size
2701+ 254C D1                   pop     DE              ; Index supplied to DE
2702+ 254D 19                   add     HL,DE           ; Add index to pointer
2703+ 254E F1                   pop     AF              ; Number of dimensions
2704+ 254F 3D                   dec     A               ; Count them
2705+ 2550 44                   ld      B,H             ; MSB of pointer
2706+ 2551 4D                   ld      C,L             ; LSB of pointer
2707+ 2552 C2 3B 25             jp      NZ,FNDELP       ; More - Keep going
2708+ 2555 29                   add     HL,HL           ; 4 Bytes per element
2709+ 2556 29                   add     HL,HL
2710+ 2557 C1                   pop     BC              ; Start of array
2711+ 2558 09                   add     HL,BC           ; Point to element
2712+ 2559 EB                   ex      DE,HL           ; Address of element to DE
2713+ 255A 2A 1A 55     ENDDIM: ld      HL,(NXTOPR)     ; Got code string address
2714+ 255D C9                   ret
2715+ 255E
2716+ 255E
2717+ 255E              ; returns the value of the 32-bit system tick counter as
2718+ 255E              ; two 16-bit words
2719+ 255E CD AF 21     TMR:    call    TSTNUM          ; Make sure it's a number
2720+ 2561 CD D1 1D             call    DEINT           ; Get integer (-32768 to 32767)
2721+ 2564 2A 20 55             ld      HL,(TMRCNT)     ; load the LSBytes of timer
2722+ 2567 7B                   ld      A,E
2723+ 2568 B2                   or      D               ; is it 0?
2724+ 2569 CA 6F 25             jp      Z,ENDTMR        ; yes, jump over
2725+ 256C 2A 22 55             ld      HL,(TMRCNT+2)   ; load the MSBytes of timer
2726+ 256F 45           ENDTMR: ld      B,L             ; move bytes...
2727+ 2570 7C                   ld      A,H             ; ...into AB
2728+ 2571 C3 96 25             jp      ABPASS          ; return word into AB
2729+ 2574
2730+ 2574
2731+ 2574              ; returns the free space for BASIC or into the string pool
2732+ 2574 2A 8A 55     FRE:    ld      HL,(ARREND)     ; Start of free memory
2733+ 2577 EB                   ex      DE,HL           ; To DE
2734+ 2578 21 00 00             ld      HL,$0000        ; End of free memory
2735+ 257B 39                   add     HL,SP           ; Current stack value
2736+ 257C 3A D2 54             ld      A,(TYPE)        ; Dummy argument type
2737+ 257F B7                   or      A
2738+ 2580 CA 90 25             jp      Z,FRENUM        ; Numeric - Free variable space
2739+ 2583 CD F7 27             call    GSTRCU          ; Current string to pool
2740+ 2586 CD F7 26             call    GARBGE          ; Garbage collection
2741+ 2589 2A EB 53             ld      HL,(STRSPC)     ; Bottom of string space in use
2742+ 258C EB                   ex      DE,HL           ; To DE
2743+ 258D 2A 0D 55             ld      HL,(STRBOT)     ; Bottom of string space
2744+ 2590 7D           FRENUM: ld      A,L             ; Get LSB of end
2745+ 2591 93                   sub     E               ; Subtract LSB of beginning
2746+ 2592 4F                   ld      C,A             ; Save difference if C
2747+ 2593 7C                   ld      A,H             ; Get MSB of end
2748+ 2594 9A                   sbc     A,D             ; Subtract MSB of beginning
2749+ 2595 41           ACPASS: ld      B,C             ; Return integer AC
2750+ 2596 50           ABPASS: ld      D,B             ; Return integer AB
2751+ 2597 1E 00                ld      E,$00
2752+ 2599 21 D2 54             ld      HL,TYPE         ; Point to type
2753+ 259C 73                   ld      (HL),E          ; Set type to numeric
2754+ 259D 06 90                ld      B,$80+$10       ; 16 bit integer
2755+ 259F C3 D0 2F             jp      RETINT          ; Return the integer
2756+ 25A2
2757+ 25A2              ; returns the X position of the cursor during a print
2758+ 25A2 3A D0 54     POS:    ld      A,(CURPOS)      ; Get cursor position
2759+ 25A5              ; return the value in A as a number
2760+ 25A5 47           PASSA:  ld      B,A             ; Put A into AB
2761+ 25A6 AF                   xor     A               ; Zero A
2762+ 25A7 C3 96 25             jp      ABPASS          ; Return integer AB
2763+ 25AA
2764+ 25AA CD 2D 26     DEF:    call    CHEKFN          ; Get "FN" and name
2765+ 25AD CD 1F 26             call    IDTEST          ; Test for illegal direct
2766+ 25B0 01 C4 1E             ld      BC,DATA         ; To get next statement
2767+ 25B3 C5                   push    BC              ; Save address for RETurn
2768+ 25B4 D5                   push    DE              ; Save address of function ptr
2769+ 25B5 CD D2 1A             call    CHKSYN          ; Make sure "(" follows
2770+ 25B8 28                   defb    '('
2771+ 25B9 CD BB 23             call    GETVAR          ; Get argument variable name
2772+ 25BC E5                   push    HL              ; Save code string address
2773+ 25BD EB                   ex      DE,HL           ; Argument address to HL
2774+ 25BE 2B                   dec     HL
2775+ 25BF 56                   ld      D,(HL)          ; Get first byte of arg name
2776+ 25C0 2B                   dec     HL
2777+ 25C1 5E                   ld      E,(HL)          ; Get second byte of arg name
2778+ 25C2 E1                   pop     HL              ; Restore code string address
2779+ 25C3 CD AF 21             call    TSTNUM          ; Make sure numeric argument
2780+ 25C6 CD D2 1A             call    CHKSYN          ; Make sure ")" follows
2781+ 25C9 29                   defb    ')'
2782+ 25CA CD D2 1A             call    CHKSYN          ; Make sure "=" follows
2783+ 25CD C9                   defb    ZEQUAL          ; "=" token
2784+ 25CE 44                   ld      B,H             ; Code string address to BC
2785+ 25CF 4D                   ld      C,L
2786+ 25D0 E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2787+ 25D1 71                   ld      (HL),C          ; Save LSB of FN code string
2788+ 25D2 23                   inc     HL
2789+ 25D3 70                   ld      (HL),B          ; Save MSB of FN code string
2790+ 25D4 C3 6C 26             jp      SVSTAD          ; Save address and do function
2791+ 25D7
2792+ 25D7 CD 2D 26     DOFN:   call    CHEKFN          ; Make sure FN follows
2793+ 25DA D5                   push    DE              ; Save function pointer address
2794+ 25DB CD 83 22             call    EVLPAR          ; Evaluate expression in "()"
2795+ 25DE CD AF 21             call    TSTNUM          ; Make sure numeric result
2796+ 25E1 E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2797+ 25E2 5E                   ld      E,(HL)          ; Get LSB of FN code string
2798+ 25E3 23                   inc     HL
2799+ 25E4 56                   ld      D,(HL)          ; Get MSB of FN code string
2800+ 25E5 23                   inc     HL
2801+ 25E6 7A                   ld      A,D             ; And function DEFined?
2802+ 25E7 B3                   or      E
2803+ 25E8 CA DE 17             jp      Z,UFERR         ; No - ?UF Error
2804+ 25EB 7E                   ld      A,(HL)          ; Get LSB of argument address
2805+ 25EC 23                   inc     HL
2806+ 25ED 66                   ld      H,(HL)          ; Get MSB of argument address
2807+ 25EE 6F                   ld      L,A             ; HL = Arg variable address
2808+ 25EF E5                   push    HL              ; Save it
2809+ 25F0 2A 8E 55             ld      HL,(FNRGNM)     ; Get old argument name
2810+ 25F3 E3                   ex      (SP),HL         ; Save old , Get new
2811+ 25F4 22 8E 55             ld      (FNRGNM),HL     ; Set new argument name
2812+ 25F7 2A 92 55             ld      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2813+ 25FA E5                   push    HL              ; Save it
2814+ 25FB 2A 90 55             ld      HL,(FNARG)      ; Get MSB,EXP of old arg value
2815+ 25FE E5                   push    HL              ; Save it
2816+ 25FF 21 90 55             ld      HL,FNARG        ; HL = Value of argument
2817+ 2602 D5                   push    DE              ; Save FN code string address
2818+ 2603 CD 11 30             call    FPTHL           ; Move FPREG to argument
2819+ 2606 E1                   pop     HL              ; Get FN code string address
2820+ 2607 CD AC 21             call    GETNUM          ; Get value from function
2821+ 260A 2B                   dec     HL              ; dec 'cos GETCHR INCs
2822+ 260B CD 1B 1D             call    GETCHR          ; Get next character
2823+ 260E C2 D2 17             jp      NZ,SNERR        ; Bad character in FN - Error
2824+ 2611 E1                   pop     HL              ; Get MSB,EXP of old arg
2825+ 2612 22 90 55             ld      (FNARG),HL      ; Restore it
2826+ 2615 E1                   pop     HL              ; Get LSB,NLSB of old arg
2827+ 2616 22 92 55             ld      (FNARG+2),HL    ; Restore it
2828+ 2619 E1                   pop     HL              ; Get name of old arg
2829+ 261A 22 8E 55             ld      (FNRGNM),HL     ; Restore it
2830+ 261D E1                   pop     HL              ; Restore code string address
2831+ 261E C9                   ret
2832+ 261F
2833+ 261F E5           IDTEST: push    HL              ; Save code string address
2834+ 2620 2A ED 53             ld      HL,(LINEAT)     ; Get current line number
2835+ 2623 23                   inc     HL              ; -1 means direct statement
2836+ 2624 7C                   ld      A,H
2837+ 2625 B5                   or      L
2838+ 2626 E1                   pop     HL              ; Restore code string address
2839+ 2627 C0                   ret     NZ              ; Return if in program
2840+ 2628 1E 16                ld      E,ID            ; ?ID Error
2841+ 262A C3 EC 17             jp      ERROR
2842+ 262D
2843+ 262D CD D2 1A     CHEKFN: call    CHKSYN          ; Make sure FN follows
2844+ 2630 B9                   defb    ZFN             ; "FN" token
2845+ 2631 3E 80                ld      A,$80
2846+ 2633 32 15 55             ld      (FORFLG),A      ; Flag FN name to find
2847+ 2636 B6                   or      (HL)            ; FN name has bit 7 set
2848+ 2637 47                   ld      B,A             ; in first byte of name
2849+ 2638 CD C0 23             call    GTFNAM          ; Get FN name
2850+ 263B C3 AF 21             jp      TSTNUM          ; Make sure numeric function
2851+ 263E
2852+ 263E CD AF 21     STR:    call    TSTNUM          ; Make sure it's a number
2853+ 2641 CD 5E 31             call    NUMASC          ; Turn number into text
2854+ 2644 CD 72 26     STR1:   call    CRTST           ; Create string entry for it
2855+ 2647 CD F7 27             call    GSTRCU          ; Current string to pool
2856+ 264A 01 52 28             ld      BC,TOPOOL       ; Save in string pool
2857+ 264D C5                   push    BC              ; Save address on stack
2858+ 264E
2859+ 264E 7E           SAVSTR: ld      A,(HL)          ; Get string length
2860+ 264F 23                   inc     HL
2861+ 2650 23                   inc     HL
2862+ 2651 E5                   push    HL              ; Save pointer to string
2863+ 2652 CD CD 26             call    TESTR           ; See if enough string space
2864+ 2655 E1                   pop     HL              ; Restore pointer to string
2865+ 2656 4E                   ld      C,(HL)          ; Get LSB of address
2866+ 2657 23                   inc     HL
2867+ 2658 46                   ld      B,(HL)          ; Get MSB of address
2868+ 2659 CD 66 26             call    CRTMST          ; Create string entry
2869+ 265C E5                   push    HL              ; Save pointer to MSB of addr
2870+ 265D 6F                   ld      L,A             ; Length of string
2871+ 265E CD EA 27             call    TOSTRA          ; Move to string area
2872+ 2661 D1                   pop     DE              ; Restore pointer to MSB
2873+ 2662 C9                   ret
2874+ 2663
2875+ 2663 CD CD 26     MKTMST: call    TESTR           ; See if enough string space
2876+ 2666 21 09 55     CRTMST: ld      HL,TMPSTR       ; Temporary string
2877+ 2669 E5                   push    HL              ; Save it
2878+ 266A 77                   ld      (HL),A          ; Save length of string
2879+ 266B 23                   inc     HL
2880+ 266C 23           SVSTAD: inc     HL
2881+ 266D 73                   ld      (HL),E          ; Save LSB of address
2882+ 266E 23                   inc     HL
2883+ 266F 72                   ld      (HL),D          ; Save MSB of address
2884+ 2670 E1                   pop     HL              ; Restore pointer
2885+ 2671 C9                   ret
2886+ 2672
2887+ 2672 2B           CRTST:  dec     HL              ; dec - INCed after
2888+ 2673 06 22        QTSTR:  ld      B,$22           ; '"'           ; Terminating quote
2889+ 2675 50                   ld      D,B             ; Quote to D
2890+ 2676 E5           DTSTR:  push    HL              ; Save start
2891+ 2677 0E FF                ld      C,-1            ; Set counter to -1
2892+ 2679 23           QTSTLP: inc     HL              ; Move on
2893+ 267A 7E                   ld      A,(HL)          ; Get byte
2894+ 267B 0C                   inc     C               ; Count bytes
2895+ 267C B7                   or      A               ; End of line?
2896+ 267D CA 88 26             jp      Z,CRTSTE        ; Yes - Create string entry
2897+ 2680 BA                   cp      D               ; Terminator D found?
2898+ 2681 CA 88 26             jp      Z,CRTSTE        ; Yes - Create string entry
2899+ 2684 B8                   cp      B               ; Terminator B found?
2900+ 2685 C2 79 26             jp      NZ,QTSTLP       ; No - Keep looking
2901+ 2688 FE 22        CRTSTE: cp      $22             ; '"'             ; End with '"'?
2902+ 268A CC 1B 1D             call    Z,GETCHR        ; Yes - Get next character
2903+ 268D E3                   ex      (SP),HL         ; Starting quote
2904+ 268E 23                   inc     HL              ; First byte of string
2905+ 268F EB                   ex      DE,HL           ; To DE
2906+ 2690 79                   ld      A,C             ; Get length
2907+ 2691 CD 66 26             call    CRTMST          ; Create string entry
2908+ 2694 11 09 55     TSTOPL: ld      DE,TMPSTR       ; Temporary string
2909+ 2697 2A FB 54             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2910+ 269A 22 94 55             ld      (FPREG),HL      ; Save address of string ptr
2911+ 269D 3E 01                ld      A,$01
2912+ 269F 32 D2 54             ld      (TYPE),A        ; Set type to string
2913+ 26A2 CD 14 30             call    DETHL4          ; Move string to pool
2914+ 26A5 CD CC 1A             call    CPDEHL          ; Out of string pool?
2915+ 26A8 22 FB 54             ld      (TMSTPT),HL     ; Save new pointer
2916+ 26AB E1                   pop     HL              ; Restore code string address
2917+ 26AC 7E                   ld      A,(HL)          ; Get next code byte
2918+ 26AD C0                   ret     NZ              ; Return if pool OK
2919+ 26AE 1E 1E                ld      E,ST            ; ?ST Error
2920+ 26B0 C3 EC 17             jp      ERROR           ; String pool overflow
2921+ 26B3
2922+ 26B3 23           PRNUMS: inc     HL              ; Skip leading space
2923+ 26B4 CD 72 26     PRS:    call    CRTST           ; Create string entry for it
2924+ 26B7 CD F7 27     PRS1:   call    GSTRCU          ; Current string to pool
2925+ 26BA CD 08 30             call    LOADFP          ; Move string block to BCDE
2926+ 26BD 1C                   inc     E               ; Length + 1
2927+ 26BE 1D           PRSLP:  dec     E               ; Count characters
2928+ 26BF C8                   ret     Z               ; End of string
2929+ 26C0 0A                   ld      A,(BC)          ; Get byte to output
2930+ 26C1 CD DD 1A             call    OUTC            ; Output character in A
2931+ 26C4 FE 0D                cp      CR              ; Return?
2932+ 26C6 CC F2 1F             call    Z,CNTEND        ; Yes - Position cursor to 0
2933+ 26C9 03                   inc     BC              ; Next byte in string
2934+ 26CA C3 BE 26             jp      PRSLP           ; More characters to output
2935+ 26CD
2936+ 26CD B7           TESTR:  or      A               ; Test if enough room
2937+ 26CE 0E                   defb    $0E             ; No garbage collection done
2938+ 26CF F1           GRBDON: pop     AF              ; Garbage collection done
2939+ 26D0 F5                   push    AF              ; Save status
2940+ 26D1 2A EB 53             ld      HL,(STRSPC)     ; Bottom of string space in use
2941+ 26D4 EB                   ex      DE,HL           ; To DE
2942+ 26D5 2A 0D 55             ld      HL,(STRBOT)     ; Bottom of string area
2943+ 26D8 2F                   cpl                     ; Negate length (Top down)
2944+ 26D9 4F                   ld      C,A             ; -Length to BC
2945+ 26DA 06 FF                ld      B,-1            ; BC = -ve length of string
2946+ 26DC 09                   add     HL,BC           ; Add to bottom of space in use
2947+ 26DD 23                   inc     HL              ; Plus one for 2's complement
2948+ 26DE CD CC 1A             call    CPDEHL          ; Below string RAM area?
2949+ 26E1 DA EB 26             jp      C,TESTOS        ; Tidy up if not done else err
2950+ 26E4 22 0D 55             ld      (STRBOT),HL     ; Save new bottom of area
2951+ 26E7 23                   inc     HL              ; Point to first byte of string
2952+ 26E8 EB                   ex      DE,HL           ; Address to DE
2953+ 26E9 F1           POPAF:  pop     AF              ; Throw away status push
2954+ 26EA C9                   ret
2955+ 26EB
2956+ 26EB F1           TESTOS: pop     AF              ; Garbage collect been done?
2957+ 26EC 1E 1A                ld      E,OS            ; ?OS Error
2958+ 26EE CA EC 17             jp      Z,ERROR         ; Yes - Not enough string space
2959+ 26F1 BF                   cp      A               ; Flag garbage collect done
2960+ 26F2 F5                   push    AF              ; Save status
2961+ 26F3 01 CF 26             ld      BC,GRBDON       ; Garbage collection done
2962+ 26F6 C5                   push    BC              ; Save for RETurn
2963+ 26F7 2A D4 54     GARBGE: ld      HL,(LSTRAM)     ; Get end of RAM pointer
2964+ 26FA 22 0D 55     GARBLP: ld      (STRBOT),HL     ; Reset string pointer
2965+ 26FD 21 00 00             ld      HL,$0000
2966+ 2700 E5                   push    HL              ; Flag no string found
2967+ 2701 2A EB 53             ld      HL,(STRSPC)     ; Get bottom of string space
2968+ 2704 E5                   push    HL              ; Save bottom of string space
2969+ 2705 21 FD 54             ld      HL,TMSTPL       ; Temporary string pool
2970+ 2708 EB           GRBLP:  ex      DE,HL
2971+ 2709 2A FB 54             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2972+ 270C EB                   ex      DE,HL
2973+ 270D CD CC 1A             call    CPDEHL          ; Temporary string pool done?
2974+ 2710 01 08 27             ld      BC,GRBLP        ; Loop until string pool done
2975+ 2713 C2 5C 27             jp      NZ,STPOOL       ; No - See if in string area
2976+ 2716 2A 86 55             ld      HL,(PROGND)     ; Start of simple variables
2977+ 2719 EB           SMPVAR: ex      DE,HL
2978+ 271A 2A 88 55             ld      HL,(VAREND)     ; End of simple variables
2979+ 271D EB                   ex      DE,HL
2980+ 271E CD CC 1A             call    CPDEHL          ; All simple strings done?
2981+ 2721 CA 2F 27             jp      Z,ARRLP         ; Yes - Do string arrays
2982+ 2724 7E                   ld      A,(HL)          ; Get type of variable
2983+ 2725 23                   inc     HL
2984+ 2726 23                   inc     HL
2985+ 2727 B7                   or      A               ; "S" flag set if string
2986+ 2728 CD 5F 27             call    STRADD          ; See if string in string area
2987+ 272B C3 19 27             jp      SMPVAR          ; Loop until simple ones done
2988+ 272E
2989+ 272E C1           GNXARY: pop     BC              ; Scrap address of this array
2990+ 272F EB           ARRLP:  ex      DE,HL
2991+ 2730 2A 8A 55             ld      HL,(ARREND)     ; End of string arrays
2992+ 2733 EB                   ex      DE,HL
2993+ 2734 CD CC 1A             call    CPDEHL          ; All string arrays done?
2994+ 2737 CA 85 27             jp      Z,SCNEND        ; Yes - Move string if found
2995+ 273A CD 08 30             call    LOADFP          ; Get array name to BCDE
2996+ 273D 7B                   ld      A,E             ; Get type of array
2997+ 273E E5                   push    HL              ; Save address of num of dim'ns
2998+ 273F 09                   add     HL,BC           ; Start of next array
2999+ 2740 B7                   or      A               ; Test type of array
3000+ 2741 F2 2E 27             jp      P,GNXARY        ; Numeric array - Ignore it
3001+ 2744 22 0F 55             ld      (CUROPR),HL     ; Save address of next array
3002+ 2747 E1                   pop     HL              ; Get address of num of dim'ns
3003+ 2748 4E                   ld      C,(HL)          ; BC = Number of dimensions
3004+ 2749 06 00                ld      B,$00
3005+ 274B 09                   add     HL,BC           ; Two bytes per dimension size
3006+ 274C 09                   add     HL,BC
3007+ 274D 23                   inc     HL              ; Plus one for number of dim'ns
3008+ 274E EB           GRBARY: ex      DE,HL
3009+ 274F 2A 0F 55             ld      HL,(CUROPR)     ; Get address of next array
3010+ 2752 EB                   ex      DE,HL
3011+ 2753 CD CC 1A             call    CPDEHL          ; Is this array finished?
3012+ 2756 CA 2F 27             jp      Z,ARRLP         ; Yes - Get next one
3013+ 2759 01 4E 27             ld      BC,GRBARY       ; Loop until array all done
3014+ 275C C5           STPOOL: push    BC              ; Save return address
3015+ 275D F6 80                or      $80             ; Flag string type
3016+ 275F 7E           STRADD: ld      A,(HL)          ; Get string length
3017+ 2760 23                   inc     HL
3018+ 2761 23                   inc     HL
3019+ 2762 5E                   ld      E,(HL)          ; Get LSB of string address
3020+ 2763 23                   inc     HL
3021+ 2764 56                   ld      D,(HL)          ; Get MSB of string address
3022+ 2765 23                   inc     HL
3023+ 2766 F0                   ret     P               ; Not a string - Return
3024+ 2767 B7                   or      A               ; Set flags on string length
3025+ 2768 C8                   ret     Z               ; Null string - Return
3026+ 2769 44                   ld      B,H             ; Save variable pointer
3027+ 276A 4D                   ld      C,L
3028+ 276B 2A 0D 55             ld      HL,(STRBOT)     ; Bottom of new area
3029+ 276E CD CC 1A             call    CPDEHL          ; String been done?
3030+ 2771 60                   ld      H,B             ; Restore variable pointer
3031+ 2772 69                   ld      L,C
3032+ 2773 D8                   ret     C               ; String done - Ignore
3033+ 2774 E1                   pop     HL              ; Return address
3034+ 2775 E3                   ex      (SP),HL         ; Lowest available string area
3035+ 2776 CD CC 1A             call    CPDEHL          ; String within string area?
3036+ 2779 E3                   ex      (SP),HL         ; Lowest available string area
3037+ 277A E5                   push    HL              ; Re-save return address
3038+ 277B 60                   ld      H,B             ; Restore variable pointer
3039+ 277C 69                   ld      L,C
3040+ 277D D0                   ret     NC              ; Outside string area - Ignore
3041+ 277E C1                   pop     BC              ; Get return , Throw 2 away
3042+ 277F F1                   pop     AF              ;
3043+ 2780 F1                   pop     AF              ;
3044+ 2781 E5                   push    HL              ; Save variable pointer
3045+ 2782 D5                   push    DE              ; Save address of current
3046+ 2783 C5                   push    BC              ; Put back return address
3047+ 2784 C9                   ret                     ; Go to it
3048+ 2785
3049+ 2785 D1           SCNEND: pop     DE              ; Addresses of strings
3050+ 2786 E1                   pop     HL              ;
3051+ 2787 7D                   ld      A,L             ; HL = 0 if no more to do
3052+ 2788 B4                   or      H
3053+ 2789 C8                   ret     Z               ; No more to do - Return
3054+ 278A 2B                   dec     HL
3055+ 278B 46                   ld      B,(HL)          ; MSB of address of string
3056+ 278C 2B                   dec     HL
3057+ 278D 4E                   ld      C,(HL)          ; LSB of address of string
3058+ 278E E5                   push    HL              ; Save variable address
3059+ 278F 2B                   dec     HL
3060+ 2790 2B                   dec     HL
3061+ 2791 6E                   ld      L,(HL)          ; HL = Length of string
3062+ 2792 26 00                ld      H,$00
3063+ 2794 09                   add     HL,BC           ; Address of end of string+1
3064+ 2795 50                   ld      D,B             ; String address to DE
3065+ 2796 59                   ld      E,C
3066+ 2797 2B                   dec     HL              ; Last byte in string
3067+ 2798 44                   ld      B,H             ; Address to BC
3068+ 2799 4D                   ld      C,L
3069+ 279A 2A 0D 55             ld      HL,(STRBOT)     ; Current bottom of string area
3070+ 279D CD 81 17             call    MOVSTR          ; Move string to new address
3071+ 27A0 E1                   pop     HL              ; Restore variable address
3072+ 27A1 71                   ld      (HL),C          ; Save new LSB of address
3073+ 27A2 23                   inc     HL
3074+ 27A3 70                   ld      (HL),B          ; Save new MSB of address
3075+ 27A4 69                   ld      L,C             ; Next string area+1 to HL
3076+ 27A5 60                   ld      H,B
3077+ 27A6 2B                   dec     HL              ; Next string area address
3078+ 27A7 C3 FA 26             jp      GARBLP          ; Look for more strings
3079+ 27AA
3080+ 27AA C5           CONCAT: push    BC              ; Save prec' opr & code string
3081+ 27AB E5                   push    HL              ;
3082+ 27AC 2A 94 55             ld      HL,(FPREG)      ; Get first string
3083+ 27AF E3                   ex      (SP),HL         ; Save first string
3084+ 27B0 CD 35 22             call    OPRND           ; Get second string
3085+ 27B3 E3                   ex      (SP),HL         ; Restore first string
3086+ 27B4 CD B0 21             call    TSTSTR          ; Make sure it's a string
3087+ 27B7 7E                   ld      A,(HL)          ; Get length of second string
3088+ 27B8 E5                   push    HL              ; Save first string
3089+ 27B9 2A 94 55             ld      HL,(FPREG)      ; Get second string
3090+ 27BC E5                   push    HL              ; Save second string
3091+ 27BD 86                   add     A,(HL)          ; Add length of second string
3092+ 27BE 1E 1C                ld      E,LS            ; ?LS Error
3093+ 27C0 DA EC 17             jp      C,ERROR         ; String too long - Error
3094+ 27C3 CD 63 26             call    MKTMST          ; Make temporary string
3095+ 27C6 D1                   pop     DE              ; Get second string to DE
3096+ 27C7 CD FB 27             call    GSTRDE          ; Move to string pool if needed
3097+ 27CA E3                   ex      (SP),HL         ; Get first string
3098+ 27CB CD FA 27             call    GSTRHL          ; Move to string pool if needed
3099+ 27CE E5                   push    HL              ; Save first string
3100+ 27CF 2A 0B 55             ld      HL,(TMPSTR+2)   ; Temporary string address
3101+ 27D2 EB                   ex      DE,HL           ; To DE
3102+ 27D3 CD E1 27             call    SSTSA           ; First string to string area
3103+ 27D6 CD E1 27             call    SSTSA           ; Second string to string area
3104+ 27D9 21 CA 21             ld      HL,EVAL2        ; Return to evaluation loop
3105+ 27DC E3                   ex      (SP),HL         ; Save return,get code string
3106+ 27DD E5                   push    HL              ; Save code string address
3107+ 27DE C3 94 26             jp      TSTOPL          ; To temporary string to pool
3108+ 27E1
3109+ 27E1 E1           SSTSA:  pop     HL              ; Return address
3110+ 27E2 E3                   ex      (SP),HL         ; Get string block,save return
3111+ 27E3 7E                   ld      A,(HL)          ; Get length of string
3112+ 27E4 23                   inc     HL
3113+ 27E5 23                   inc     HL
3114+ 27E6 4E                   ld      C,(HL)          ; Get LSB of string address
3115+ 27E7 23                   inc     HL
3116+ 27E8 46                   ld      B,(HL)          ; Get MSB of string address
3117+ 27E9 6F                   ld      L,A             ; Length to L
3118+ 27EA 2C           TOSTRA: inc     L               ; inc - DECed after
3119+ 27EB 2D           TSALP:  dec     L               ; Count bytes moved
3120+ 27EC C8                   ret     Z               ; End of string - Return
3121+ 27ED 0A                   ld      A,(BC)          ; Get source
3122+ 27EE 12                   ld      (DE),A          ; Save destination
3123+ 27EF 03                   inc     BC              ; Next source
3124+ 27F0 13                   inc     DE              ; Next destination
3125+ 27F1 C3 EB 27             jp      TSALP           ; Loop until string moved
3126+ 27F4
3127+ 27F4 CD B0 21     GETSTR: call    TSTSTR          ; Make sure it's a string
3128+ 27F7 2A 94 55     GSTRCU: ld      HL,(FPREG)      ; Get current string
3129+ 27FA EB           GSTRHL: ex      DE,HL           ; Save DE
3130+ 27FB CD 15 28     GSTRDE: call    BAKTMP          ; Was it last tmp-str?
3131+ 27FE EB                   ex      DE,HL           ; Restore DE
3132+ 27FF C0                   ret     NZ              ; No - Return
3133+ 2800 D5                   push    DE              ; Save string
3134+ 2801 50                   ld      D,B             ; String block address to DE
3135+ 2802 59                   ld      E,C
3136+ 2803 1B                   dec     DE              ; Point to length
3137+ 2804 4E                   ld      C,(HL)          ; Get string length
3138+ 2805 2A 0D 55             ld      HL,(STRBOT)     ; Current bottom of string area
3139+ 2808 CD CC 1A             call    CPDEHL          ; Last one in string area?
3140+ 280B C2 13 28             jp      NZ,POPHL        ; No - Return
3141+ 280E 47                   ld      B,A             ; Clear B (A=0)
3142+ 280F 09                   add     HL,BC           ; Remove string from str' area
3143+ 2810 22 0D 55             ld      (STRBOT),HL     ; Save new bottom of str' area
3144+ 2813 E1           POPHL:  pop     HL              ; Restore string
3145+ 2814 C9                   ret
3146+ 2815
3147+ 2815 2A FB 54     BAKTMP: ld      HL,(TMSTPT)     ; Get temporary string pool top
3148+ 2818 2B                   dec     HL              ; Back
3149+ 2819 46                   ld      B,(HL)          ; Get MSB of address
3150+ 281A 2B                   dec     HL              ; Back
3151+ 281B 4E                   ld      C,(HL)          ; Get LSB of address
3152+ 281C 2B                   dec     HL              ; Back
3153+ 281D 2B                   dec     HL              ; Back
3154+ 281E CD CC 1A             call    CPDEHL          ; String last in string pool?
3155+ 2821 C0                   ret     NZ              ; Yes - Leave it
3156+ 2822 22 FB 54             ld      (TMSTPT),HL     ; Save new string pool top
3157+ 2825 C9                   ret
3158+ 2826
3159+ 2826 01 A5 25     LEN:    ld      BC,PASSA        ; To return integer A
3160+ 2829 C5                   push    BC              ; Save address
3161+ 282A CD F4 27     GETLEN: call    GETSTR          ; Get string and its length
3162+ 282D AF                   xor     A
3163+ 282E 57                   ld      D,A             ; Clear D
3164+ 282F 32 D2 54             ld      (TYPE),A        ; Set type to numeric
3165+ 2832 7E                   ld      A,(HL)          ; Get length of string
3166+ 2833 B7                   or      A               ; Set status flags
3167+ 2834 C9                   ret
3168+ 2835
3169+ 2835 01 A5 25     ASC:    ld      BC,PASSA        ; To return integer A
3170+ 2838 C5                   push    BC              ; Save address
3171+ 2839 CD 2A 28     GTFLNM: call    GETLEN          ; Get length of string
3172+ 283C CA E6 1D             jp      Z,FCERR         ; Null string - Error
3173+ 283F 23                   inc     HL
3174+ 2840 23                   inc     HL
3175+ 2841 5E                   ld      E,(HL)          ; Get LSB of address
3176+ 2842 23                   inc     HL
3177+ 2843 56                   ld      D,(HL)          ; Get MSB of address
3178+ 2844 1A                   ld      A,(DE)          ; Get first byte of string
3179+ 2845 C9                   ret
3180+ 2846
3181+ 2846 3E 01        CHR:    ld      A,$01           ; One character string
3182+ 2848 CD 63 26             call    MKTMST          ; Make a temporary string
3183+ 284B CD 35 2A             call    MAKINT          ; Make it integer A
3184+ 284E 2A 0B 55             ld      HL,(TMPSTR+2)   ; Get address of string
3185+ 2851 73                   ld      (HL),E          ; Save character
3186+ 2852 C1           TOPOOL: pop     BC              ; Clean up stack
3187+ 2853 C3 94 26             jp      TSTOPL          ; Temporary string to pool
3188+ 2856
3189+ 2856 CD E5 29     LEFT:   call    LFRGNM          ; Get number and ending ")"
3190+ 2859 AF                   xor     A               ; Start at first byte in string
3191+ 285A E3           RIGHT1: ex      (SP),HL         ; Save code string,Get string
3192+ 285B 4F                   ld      C,A             ; Starting position in string
3193+ 285C E5           MID1:   push    HL              ; Save string block address
3194+ 285D 7E                   ld      A,(HL)          ; Get length of string
3195+ 285E B8                   cp      B               ; Compare with number given
3196+ 285F DA 64 28             jp      C,ALLFOL        ; All following bytes required
3197+ 2862 78                   ld      A,B             ; Get new length
3198+ 2863 11                   defb    $11             ; Skip "ld C,0"
3199+ 2864 0E 00        ALLFOL: ld      C,$00           ; First byte of string
3200+ 2866 C5                   push    BC              ; Save position in string
3201+ 2867 CD CD 26             call    TESTR           ; See if enough string space
3202+ 286A C1                   pop     BC              ; Get position in string
3203+ 286B E1                   pop     HL              ; Restore string block address
3204+ 286C E5                   push    HL              ; And re-save it
3205+ 286D 23                   inc     HL
3206+ 286E 23                   inc     HL
3207+ 286F 46                   ld      B,(HL)          ; Get LSB of address
3208+ 2870 23                   inc     HL
3209+ 2871 66                   ld      H,(HL)          ; Get MSB of address
3210+ 2872 68                   ld      L,B             ; HL = address of string
3211+ 2873 06 00                ld      B,$00           ; BC = starting address
3212+ 2875 09                   add     HL,BC           ; Point to that byte
3213+ 2876 44                   ld      B,H             ; BC = source string
3214+ 2877 4D                   ld      C,L
3215+ 2878 CD 66 26             call    CRTMST          ; Create a string entry
3216+ 287B 6F                   ld      L,A             ; Length of new string
3217+ 287C CD EA 27             call    TOSTRA          ; Move string to string area
3218+ 287F D1                   pop     DE              ; Clear stack
3219+ 2880 CD FB 27             call    GSTRDE          ; Move to string pool if needed
3220+ 2883 C3 94 26             jp      TSTOPL          ; Temporary string to pool
3221+ 2886
3222+ 2886
3223+ 2886              ; INSTR statement - look for a string inside another string
3224+ 2886              ; usage: INSTR(A$,B$) -> search for B$ into A$
3225+ 2886              ; return 0 if B$ is not found into A$, or LEN(A$)<LEN(B$)
3226+ 2886              ; return 1~255 to indicate the starting position of B$ into A$
3227+ 2886              ; ex.: INSTR("HELLO","LO") returns 4 - INSTR("HOME","PC") returns 0
3228+ 2886              LNS1    equ     TMPBFR1
3229+ 2886              ADRS1   equ     TMPBFR2
3230+ 2886              LNS2    equ     TMPBFR3
3231+ 2886              ADRS2   equ     TMPBFR4
3232+ 2886              PT      equ     VIDEOBUFF
3233+ 2886              PT1     equ     VIDEOBUFF+2
3234+ 2886              PT2     equ     VIDEOBUFF+4
3235+ 2886              TP      equ     VIDEOBUFF+6
3236+ 2886              TF      equ     VIDEOBUFF+8
3237+ 2886 CD D2 1A     INSTR:  call    CHKSYN          ; make sure "(" follows
3238+ 2889 28                   defb    '('
3239+ 288A 2B                   dec     HL              ; dec 'cause GETCHR increments
3240+ 288B CD 1B 1D             call    GETCHR          ; check if something follows
3241+ 288E CA D2 17             jp      Z,SNERR         ; if nothing else, raise a syntax error
3242+ 2891 CD BE 21             call    EVAL            ; Evaluate expression
3243+ 2894 CD B0 21             call    TSTSTR          ; Make sure it's a string
3244+ 2897 22 48 55             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3245+ 289A CD F7 27             call    GSTRCU          ; check that a string follows
3246+ 289D CD 08 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3247+ 28A0 ED 53 40 55          ld      (LNS1),DE       ; store values into
3248+ 28A4 ED 43 42 55          ld      (ADRS1),BC      ; temp buffers
3249+ 28A8 2A 48 55             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3250+ 28AB CD D2 1A             call    CHKSYN          ; Make sure ',' follows
3251+ 28AE 2C                   defb    ','
3252+ 28AF 2B                   dec     HL              ; dec 'cause GETCHR increments
3253+ 28B0 CD 1B 1D             call    GETCHR          ; check if something follows
3254+ 28B3 CA D2 17             jp      Z,SNERR         ; if nothing else, raise a syntax error
3255+ 28B6 CD BE 21             call    EVAL            ; Evaluate expression
3256+ 28B9 CD B0 21             call    TSTSTR          ; Make sure it's a string
3257+ 28BC 22 48 55             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3258+ 28BF CD F7 27             call    GSTRCU          ; check that a string follows
3259+ 28C2 CD 08 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3260+ 28C5 ED 53 44 55          ld      (LNS2),DE       ; store values into
3261+ 28C9 ED 43 46 55          ld      (ADRS2),BC      ; temp buffers
3262+ 28CD 2A 48 55             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3263+ 28D0 CD D2 1A             call    CHKSYN          ; make sure ")" follows
3264+ 28D3 29                   defb    ')'
3265+ 28D4 E5                   push    HL              ; store current code string pointer (the point after the ")" ) ...
3266+ 28D5 FD E1                pop     IY              ; ...into IY
3267+ 28D7 AF                   xor     A               ; reset 10 RAM cells
3268+ 28D8 06 0A                ld      B,$0A           ; (INSTR registers)
3269+ 28DA 21 48 55             ld      HL,PT           ; first cell
3270+ 28DD 77           EMPTINS:ld      (HL),A          ; reset cell
3271+ 28DE 23                   inc     HL              ; next cell
3272+ 28DF 10 FC                djnz    EMPTINS         ; repeat
3273+ 28E1 ED 5B 44 55          ld      DE,(LNS2)       ; load len(S2) into DE
3274+ 28E5 2A 40 55             ld      HL,(LNS1)       ; load len(S1) into HL
3275+ 28E8 CD F9 40             call    CMP16           ; check that len(S1)>=len(S2)
3276+ 28EB DA 60 29             jp      C,RZINSTR       ; if len(S2)>len(S1) then return 0
3277+ 28EE AF           RPTINST:xor     A               ; reset...
3278+ 28EF 32 4E 55             ld      (TP),A          ; ...TP...
3279+ 28F2 32 50 55             ld      (TF),A          ; ...and TF
3280+ 28F5 ED 4B 48 55          ld      BC,(PT)         ; pointer to S1
3281+ 28F9 2A 42 55             ld      HL,(ADRS1)      ; first cell of S1
3282+ 28FC 09                   add     HL,BC           ; get current position into RAM
3283+ 28FD 7E                   ld      A,(HL)          ; load S1(PT)
3284+ 28FE 2A 46 55             ld      HL,(ADRS2)      ; pointer to first char of S2
3285+ 2901 BE                   cp      (HL)            ; is S1(PT)=S2(0)?
3286+ 2902 20 3A                jr      NZ,CNT1INS      ; no, continue
3287+ 2904 3A 48 55             ld      A,(PT)          ; load current PT
3288+ 2907 32 4E 55             ld      (TP),A          ; TP=PT
3289+ 290A 32 4A 55             ld      (PT1),A         ; P1=PT
3290+ 290D AF                   xor     A               ; set...
3291+ 290E 32 4C 55             ld      (PT2),A         ; ...PT2=0
3292+ 2911 3C                   inc     A               ;
3293+ 2912 32 50 55             ld      (TF),A          ; set TF=1
3294+ 2915 ED 4B 4A 55  RP2INST:ld      BC,(PT1)        ; load pointer PT1
3295+ 2919 2A 42 55             ld      HL,(ADRS1)      ; load address of S1
3296+ 291C 09                   add     HL,BC           ; find char of S1 pointed by PT1
3297+ 291D 7E                   ld      A,(HL)          ; load S1(PT1)
3298+ 291E ED 4B 4C 55          ld      BC,(PT2)        ; load pointer PT2
3299+ 2922 2A 46 55             ld      HL,(ADRS2)      ; load char of S2 pointed by PT2
3300+ 2925 09                   add     HL,BC           ; find S2(PT2)
3301+ 2926 BE                   cp      (HL)            ; is S1(PT1)=S2(PT2)?
3302+ 2927 20 4C                jr      NZ,CNTZIN       ; no, exit inner loop
3303+ 2929 21 4A 55             ld      HL,PT1
3304+ 292C 34                   inc     (HL)            ; increment PT1
3305+ 292D 3A 4C 55             ld      A,(PT2)
3306+ 2930 3C                   inc     A               ; increment PT2
3307+ 2931 32 4C 55             ld      (PT2),A
3308+ 2934 CA 3E 29             jp      Z,CNT1INS       ; if PT2>255 then exit
3309+ 2937 21 44 55             ld      HL,LNS2         ; len(S2)
3310+ 293A BE                   cp      (HL)            ; PT2=len(S2)?
3311+ 293B DA 15 29             jp      C,RP2INST       ; no (PT2<len(S2) - repeat
3312+ 293E 3A 50 55     CNT1INS:ld      A,(TF)          ; check TF
3313+ 2941 A7                   and     A               ; TF=0? (clears also Carry for next SBC)
3314+ 2942 20 1C                jr      NZ,RZINSTR      ; no, exit
3315+ 2944 2A 40 55             ld      HL,(LNS1)       ; load len(S1)
3316+ 2947 ED 4B 44 55          ld      BC,(LNS2)       ; load len(S2)
3317+ 294B ED 42                sbc     HL,BC           ; HL=len(S1)-len(S2)
3318+ 294D ED 5B 48 55          ld      DE,(PT)         ; load pointer
3319+ 2951 1C                   inc     E               ; PT=PT+1
3320+ 2952 ED 53 48 55          ld      (PT),DE         ; store new value
3321+ 2956 EB                   ex      DE,HL           ; invert registers
3322+ 2957 CD F9 40             call    CMP16           ; check if PT>len(S1)-len(S2)
3323+ 295A DA EE 28             jp      C,RPTINST       ; repeat if <
3324+ 295D CA EE 28             jp      Z,RPTINST       ; repeat if =
3325+ 2960 3A 50 55     RZINSTR:ld      A,(TF)          ; current value of TF
3326+ 2963 A7                   and     A               ; is it 0?
3327+ 2964 CA 6B 29             jp      Z,LVINSTR       ; yes, return 0
3328+ 2967 3A 4E 55             ld      A,(TP)          ; return TP...
3329+ 296A 3C                   inc     A               ; ...incremented by 1
3330+ 296B E1           LVINSTR:pop     HL              ; drop original return point
3331+ 296C FD E5                push    IY              ; load current string address from IY into stack
3332+ 296E 11 97 22             ld      DE,RETNUM       ; Address of Return number from function...
3333+ 2971 D5                   push    DE              ; ...saved on stack
3334+ 2972 C3 A5 25             jp      PASSA           ; return TP
3335+ 2975 AF           CNTZIN: xor     A               ; set...
3336+ 2976 32 50 55             ld      (TF),A          ; TF=0
3337+ 2979 C3 3E 29             jp      CNT1INS         ; continue
3338+ 297C
3339+ 297C
3340+ 297C              ; returns the right portion of a string
3341+ 297C CD E5 29     RIGHT:  call    LFRGNM          ; Get number and ending ")"
3342+ 297F D1                   pop     DE              ; Get string length
3343+ 2980 D5                   push    DE              ; And re-save
3344+ 2981 1A                   ld      A,(DE)          ; Get length
3345+ 2982 90                   sub     B               ; Move back N bytes
3346+ 2983 C3 5A 28             jp      RIGHT1          ; Go and get sub-string
3347+ 2986
3348+ 2986              ; returns a piece of a string
3349+ 2986 EB           MID:    ex      DE,HL           ; Get code string address
3350+ 2987 7E                   ld      A,(HL)          ; Get next byte ',' or ")"
3351+ 2988 CD EA 29             call    MIDNUM          ; Get number supplied
3352+ 298B 04                   inc     B               ; Is it character zero?
3353+ 298C 05                   dec     B
3354+ 298D CA E6 1D             jp      Z,FCERR         ; Yes - Error
3355+ 2990 C5                   push    BC              ; Save starting position
3356+ 2991 1E FF                ld      E,$FF           ; All of string
3357+ 2993 FE 29                cp      ')'             ; Any length given?
3358+ 2995 CA 9F 29             jp      Z,RSTSTR        ; No - Rest of string
3359+ 2998 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
3360+ 299B 2C                   defb    ','
3361+ 299C CD 32 2A             call    GETINT          ; Get integer 0-255
3362+ 299F CD D2 1A     RSTSTR: call    CHKSYN          ; Make sure ")" follows
3363+ 29A2 29                   defb    ')'
3364+ 29A3 F1                   pop     AF              ; Restore starting position
3365+ 29A4 E3                   ex      (SP),HL         ; Get string,save code string
3366+ 29A5 01 5C 28             ld      BC,MID1         ; Continuation of MID$ routine
3367+ 29A8 C5                   push    BC              ; Save for return
3368+ 29A9 3D                   dec     A               ; Starting position-1
3369+ 29AA BE                   cp      (HL)            ; Compare with length
3370+ 29AB 06 00                ld      B,$00           ; Zero bytes length
3371+ 29AD D0                   ret     NC              ; Null string if start past end
3372+ 29AE 4F                   ld      C,A             ; Save starting position-1
3373+ 29AF 7E                   ld      A,(HL)          ; Get length of string
3374+ 29B0 91                   sub     C               ; Subtract start
3375+ 29B1 BB                   cp      E               ; Enough string for it?
3376+ 29B2 47                   ld      B,A             ; Save maximum length available
3377+ 29B3 D8                   ret     C               ; Truncate string if needed
3378+ 29B4 43                   ld      B,E             ; Set specified length
3379+ 29B5 C9                   ret                     ; Go and create string
3380+ 29B6
3381+ 29B6
3382+ 29B6              ; return the value of a numeric string
3383+ 29B6 CD 2A 28     VAL:    call    GETLEN          ; Get length of string
3384+ 29B9 CA 88 2D             jp      Z,RESZER        ; Result zero
3385+ 29BC 5F                   ld      E,A             ; Save length
3386+ 29BD 23                   inc     HL
3387+ 29BE 23                   inc     HL
3388+ 29BF 7E                   ld      A,(HL)          ; Get LSB of address
3389+ 29C0 23                   inc     HL
3390+ 29C1 66                   ld      H,(HL)          ; Get MSB of address
3391+ 29C2 6F                   ld      L,A             ; HL = String address
3392+ 29C3 E5                   push    HL              ; Save string address
3393+ 29C4 19                   add     HL,DE
3394+ 29C5 46                   ld      B,(HL)          ; Get end of string+1 byte
3395+ 29C6 72                   ld      (HL),D          ; Zero it to terminate
3396+ 29C7 E3                   ex      (SP),HL         ; Save string end,get start
3397+ 29C8 C5                   push    BC              ; Save end+1 byte
3398+ 29C9 7E                   ld      A,(HL)          ; Get starting byte
3399+ 29CA FE 24                cp      '$'             ; Hex number indicated? [function added]
3400+ 29CC C2 D4 29             jp      NZ,VAL1
3401+ 29CF CD 2B 40             call    HEXTFP          ; Convert Hex to FPREG
3402+ 29D2 18 0D                jr      VAL3
3403+ 29D4 FE 25        VAL1:   cp      '%'             ; Binary number indicated? [function added]
3404+ 29D6 C2 DE 29             jp      NZ,VAL2
3405+ 29D9 CD 9B 40             call    BINTFP          ; Convert Bin to FPREG
3406+ 29DC 18 03                jr      VAL3
3407+ 29DE CD C0 30     VAL2:   call    ASCTFP          ; Convert ASCII string to FP
3408+ 29E1 C1           VAL3:   pop     BC              ; Restore end+1 byte
3409+ 29E2 E1                   pop     HL              ; Restore end+1 address
3410+ 29E3 70                   ld      (HL),B          ; Put back original byte
3411+ 29E4 C9                   ret
3412+ 29E5
3413+ 29E5 EB           LFRGNM: ex      DE,HL           ; Code string address to HL
3414+ 29E6 CD D2 1A             call    CHKSYN          ; Make sure ")" follows
3415+ 29E9 29                   defb    ')'
3416+ 29EA C1           MIDNUM: pop     BC              ; Get return address
3417+ 29EB D1                   pop     DE              ; Get number supplied
3418+ 29EC C5                   push    BC              ; Re-save return address
3419+ 29ED 43                   ld      B,E             ; Number to B
3420+ 29EE C9                   ret
3421+ 29EF
3422+ 29EF CD 35 2A     INP:    call    MAKINT          ; Make it integer A
3423+ 29F2 32 DE 53             ld      (INPORT),A      ; Set input port
3424+ 29F5 CD DD 53             call    INPSUB          ; Get input from port
3425+ 29F8 C3 A5 25             jp      PASSA           ; Return integer A
3426+ 29FB
3427+ 29FB CD 1F 2A     POUT:   call    SETIO           ; Set up port number
3428+ 29FE C3 A5 53             jp      OUTSUB          ; Output data and return
3429+ 2A01
3430+ 2A01 CD 1F 2A     WAIT:   call    SETIO           ; Set up port number
3431+ 2A04 F5                   push    AF              ; Save AND mask
3432+ 2A05 1E 00                ld      E,$00           ; Assume zero if none given
3433+ 2A07 2B                   dec     HL              ; dec 'cos GETCHR INCs
3434+ 2A08 CD 1B 1D             call    GETCHR          ; Get next character
3435+ 2A0B CA 15 2A             jp      Z,NOXOR         ; No XOR byte given
3436+ 2A0E CD D2 1A             call    CHKSYN          ; Make sure ',' follows
3437+ 2A11 2C                   defb    ','
3438+ 2A12 CD 32 2A             call    GETINT          ; Get integer 0-255 to XOR with
3439+ 2A15 C1           NOXOR:  pop     BC              ; Restore AND mask
3440+ 2A16 CD DD 53     WAITLP: call    INPSUB          ; Get input
3441+ 2A19 AB                   xor     E               ; Flip selected bits
3442+ 2A1A A0                   and     B               ; Result non-zero?
3443+ 2A1B CA 16 2A             jp      Z,WAITLP        ; No = keep waiting
3444+ 2A1E C9                   ret
3445+ 2A1F
3446+ 2A1F CD 32 2A     SETIO:  call    GETINT          ; Get integer 0-255
3447+ 2A22 32 DE 53             ld      (INPORT),A      ; Set input port
3448+ 2A25 32 A6 53             ld      (OTPORT),A      ; Set output port
3449+ 2A28 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
3450+ 2A2B 2C                   defb    ','
3451+ 2A2C C3 32 2A             jp      GETINT          ; Get integer 0-255 and return
3452+ 2A2F
3453+ 2A2F CD 1B 1D     FNDNUM: call    GETCHR          ; Get next character
3454+ 2A32 CD AC 21     GETINT: call    GETNUM          ; Get a number from 0 to 255
3455+ 2A35 CD CB 1D     MAKINT: call    DEPINT          ; Make sure value 0 - 255
3456+ 2A38 7A                   ld      A,D             ; Get MSB of number
3457+ 2A39 B7                   or      A               ; Zero?
3458+ 2A3A C2 E6 1D             jp      NZ,FCERR        ; No - Error
3459+ 2A3D 2B                   dec     HL              ; dec 'cos GETCHR INCs
3460+ 2A3E CD 1B 1D             call    GETCHR          ; Get next character
3461+ 2A41 7B                   ld      A,E             ; Get number to A
3462+ 2A42 C9                   ret
3463+ 2A43
3464+ 2A43
3465+ 2A43              ; activate a Non-Maskable Interrupt hooked to VDP interrupt signal
3466+ 2A43              ; address must point to an ISR routine that terminates with EI/RETN instructions
3467+ 2A43 CD AC 21     NMI:    call    GETNUM          ; Get memory address
3468+ 2A46 CD D1 1D             call    DEINT           ; get integer -32768 to 32767
3469+ 2A49 7B                   ld      A,E             ; check if address is 0
3470+ 2A4A B2                   or      D
3471+ 2A4B 20 11                jr      NZ,NM1          ; no, so jump over
3472+ 2A4D F3           DISNMI: di                      ; disable INTs
3473+ 2A4E CD 7A 2A             call    NMIDINT         ; disable VDP INT
3474+ 2A51 E5                   push    HL              ; store HL
3475+ 2A52 21 ED 45             ld      HL,$45ED        ; these are the op-codes for "RETN"
3476+ 2A55 22 9F 53             ld      (NMIUSR),HL     ; store RETN
3477+ 2A58 AF                   xor     A
3478+ 2A59 32 A1 53             ld      (NMIUSR+2),A    ; "NOP"
3479+ 2A5C 18 11                jr      NMI2            ; execute the last part of code
3480+ 2A5E E5           NM1:    push    HL              ; store current HL
3481+ 2A5F EB                   ex      DE,HL           ; move address argument into HL
3482+ 2A60 F3                   di                      ; disable INTs
3483+ 2A61 CD 7A 2A             call    NMIDINT         ; disable VDP INT, if enabled
3484+ 2A64 3E C3                ld      A,$C3           ; "jp" instruction
3485+ 2A66 32 9F 53             ld      (NMIUSR),A      ; store it
3486+ 2A69 22 A0 53             ld      (NMIUSR+1),HL   ; store address
3487+ 2A6C CD 73 2A             call    NMIEINT         ; re-enable VDP INT
3488+ 2A6F FB           NMI2:   ei                      ; re-enable INTS
3489+ 2A70 00                   nop                     ; wait for INTs
3490+ 2A71 E1                   pop    HL               ; retrieve HL
3491+ 2A72 C9                   ret                     ; return to caller
3492+ 2A73              ; enable VDP INT
3493+ 2A73 CD 89 2A     NMIEINT:call    NMIVR1          ; load default VReg #1 setting
3494+ 2A76 F6 20                or      %00100000       ; enable VDP INT
3495+ 2A78 18 03                jr      NMIINT          ; rest of code is shared
3496+ 2A7A              ; disable VDP INT
3497+ 2A7A CD 89 2A     NMIDINT:call    NMIVR1          ; load default VReg #1 setting
3498+ 2A7D D5           NMIINT: push    DE              ; store DE
3499+ 2A7E 5F                   ld      E,A             ; move value into E
3500+ 2A7F 3E 01                ld      A,$01           ; VREG #1
3501+ 2A81 F3                   di                      ; disable INTs
3502+ 2A82 CD B3 06             call    WRITE_VREG      ; disable VDP INT
3503+ 2A85 FB                   ei                      ; re-enable INTs
3504+ 2A86 00                   nop                     ; wait for INTs being enabled
3505+ 2A87 D1                   pop     DE              ; retrieve DE
3506+ 2A88 C9                   ret                     ; return to caller
3507+ 2A89
3508+ 2A89              ; load VREG #1 setting for current screen mode and return it into A
3509+ 2A89 E5           NMIVR1: push    HL              ; store HL
3510+ 2A8A D5                   push    DE              ; store DE
3511+ 2A8B 3A 32 55             ld      A,(SCR_MODE)    ; check screen mode
3512+ 2A8E 87                   add     A,A             ; multiply A by 8...
3513+ 2A8F 87                   add     A,A             ; ...so that reg. A can points..
3514+ 2A90 87                   add     A,A             ; to the correct settings
3515+ 2A91 3C                   inc     A               ; need to change VREG 1
3516+ 2A92 5F                   ld      E,A             ; copy A into E
3517+ 2A93 16 00                ld      D,$00           ; reset D
3518+ 2A95 21 22 0B             ld      HL,VDPMODESET   ; pointer to register #1 setting...
3519+ 2A98 19                   add     HL,DE           ; ...for current screen mode
3520+ 2A99 7E                   ld      A,(HL)          ; load current setting
3521+ 2A9A D1                   pop     DE              ; retrieve DE
3522+ 2A9B E1                   pop     HL              ; retrieve HL
3523+ 2A9C C9                   ret                     ; return to caller
3524+ 2A9D
3525+ 2A9D              ; execute a machine language routine, eventually passing a param into A
3526+ 2A9D CD AC 21     SYS:    call    GETNUM          ; Get memory address
3527+ 2AA0 CD D1 1D             call    DEINT           ; Get integer -32768 to 32767
3528+ 2AA3 ED 53 42 55          ld      (TMPBFR2),DE    ; store user routine's address
3529+ 2AA7 AF                   xor     A               ; reset A
3530+ 2AA8 32 40 55             ld      (TMPBFR1),A     ; store into temp buffer
3531+ 2AAB 2B                   dec     HL              ; dec 'cos GETCHR INCs
3532+ 2AAC CD 1B 1D             call    GETCHR          ; check next character
3533+ 2AAF 28 0A                jr      Z,NOSYSPR       ; jump if nothing follows
3534+ 2AB1 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
3535+ 2AB4 2C                   defb    ','
3536+ 2AB5 CD 32 2A             call    GETINT          ; get byte value (0~255) if something follows
3537+ 2AB8 32 40 55             ld      (TMPBFR1),A     ; store into temp buffer
3538+ 2ABB 3A 40 55     NOSYSPR:ld      A,(TMPBFR1)     ; recover A
3539+ 2ABE ED 5B 42 55          ld      DE,(TMPBFR2)    ; recover user routine's address
3540+ 2AC2 E5                   push    HL              ; save code string address
3541+ 2AC3 EB                   ex      DE,HL           ; move user routine's address into HL
3542+ 2AC4 11 C9 2A             ld      DE,SYSRET       ; set point of return after the user routine
3543+ 2AC7 D5                   push    DE              ; store into stack
3544+ 2AC8 E9                   jp      (HL)            ; call user routine
3545+ 2AC9 E1           SYSRET: pop     HL              ; retrieve code string address
3546+ 2ACA C9                   ret                     ; return to caller
3547+ 2ACB
3548+ 2ACB
3549+ 2ACB              ; read the contents of a RAM location
3550+ 2ACB CD D1 1D     PEEK:   call    DEINT           ; Get memory address into DE
3551+ 2ACE 1A                   ld      A,(DE)          ; Read value of memory cell
3552+ 2ACF C3 A5 25             jp      PASSA           ; Return into A
3553+ 2AD2
3554+ 2AD2              ; read the contents of a VRAM location
3555+ 2AD2 CD D1 1D     VPEEK:  call    DEINT           ; Get VRAM address into DE
3556+ 2AD5 EB                   ex      DE,HL           ; Copy param into HL
3557+ 2AD6 F3                   di                      ; Disable interrupts
3558+ 2AD7 CD 89 06             call    READ_VIDEO_LOC  ; Read data from VRAM at address HL
3559+ 2ADA FB                   ei                      ; Re-enable interrupts
3560+ 2ADB EB                   ex      DE,HL           ; Restore HL
3561+ 2ADC C3 A5 25             jp      PASSA           ; Return value into A
3562+ 2ADF
3563+ 2ADF              ; recover params for POKE/VPOKE commands
3564+ 2ADF              ; returns address into DE and byte to be written into A
3565+ 2ADF CD AC 21     PKEPRMS:call    GETNUM          ; Get memory address
3566+ 2AE2 CD D1 1D             call    DEINT           ; Get integer -32768 to 32767
3567+ 2AE5 ED 53 40 55          ld      (TMPBFR1),DE    ; Store DE into a temp. buffer
3568+ 2AE9 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
3569+ 2AEC 2C                   defb    ','
3570+ 2AED CD 32 2A             call    GETINT          ; Get integer 0-255
3571+ 2AF0 ED 5B 40 55          ld      DE,(TMPBFR1)    ; Restore memory address
3572+ 2AF4 C9                   ret                     ; Return to caller
3573+ 2AF5
3574+ 2AF5              ; write a byte into a RAM location
3575+ 2AF5 CD DF 2A     POKE:   call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3576+ 2AF8 12                   ld      (DE),A          ; Load it into memory
3577+ 2AF9 C9                   ret
3578+ 2AFA
3579+ 2AFA              ; write a byte into a VRAM location
3580+ 2AFA CD DF 2A     VPOKE:  call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3581+ 2AFD EB                   ex      DE,HL           ; Copy address into HL
3582+ 2AFE F3                   di                      ; Disable interrupts
3583+ 2AFF CD 9E 06             call    WRITE_VIDEO_LOC ; write data into VRAM at address HL
3584+ 2B02 FB                   ei                      ; Re-enable interrupts
3585+ 2B03 EB                   ex      DE,HL           ; Restore HL
3586+ 2B04 C9                   ret                     ; Return to caller
3587+ 2B05
3588+ 2B05              ; position the cursor at a specific X,Y location onto screen
3589+ 2B05 CD 32 2A     LOCATE: call    GETINT          ; get the first param into A
3590+ 2B08 E5                   push    HL              ; store HL
3591+ 2B09 21 30 55             ld      HL,SCR_SIZE_W   ; load address of screen width
3592+ 2B0C 5E                   ld      E,(HL)          ; load screen width into E
3593+ 2B0D E1                   pop     HL              ; restore HL
3594+ 2B0E BB                   cp      E               ; compare witdh with param
3595+ 2B0F D2 E6 1D             jp      NC,FCERR        ; value over the width of the screen, exit with Illegal F.C. error
3596+ 2B12 32 40 55             ld      (TMPBFR1),A     ; Store X into a temp. buffer
3597+ 2B15 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
3598+ 2B18 2C                   defb    ','
3599+ 2B19 CD 32 2A             call    GETINT          ; Get the second param into A
3600+ 2B1C E5                   push    HL              ; store HL
3601+ 2B1D 21 31 55             ld      HL,SCR_SIZE_H   ; load address of screen width
3602+ 2B20 5E                   ld      E,(HL)          ; load screen width into A
3603+ 2B21 E1                   pop     HL              ; restore HL
3604+ 2B22 BB                   cp      E               ; compare witdh with param
3605+ 2B23 D2 E6 1D             jp      NC,FCERR        ; value over the height of the screen, exit with Illegal F.C. error
3606+ 2B26 32 38 55             ld      (SCR_CUR_NY),A  ; store new Y
3607+ 2B29 3A 40 55             ld      A,(TMPBFR1)     ; recover the new X
3608+ 2B2C 32 37 55             ld      (SCR_CUR_NX),A  ; store new X
3609+ 2B2F E5                   push    HL              ; store HL
3610+ 2B30 F3                   di                      ; disable INTs
3611+ 2B31 CD CF 06             call    MOVCRS          ; move cursor to new location
3612+ 2B34 FB                   ei                      ; re-enable INTs
3613+ 2B35 E1                   pop     HL              ; restore HL
3614+ 2B36 C9                   ret                     ; return to caller
3615+ 2B37
3616+ 2B37              ; write a byte into one of the PSG registers
3617+ 2B37 CD 32 2A     SREG:   call    GETINT          ; Get register number back into A
3618+ 2B3A FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3619+ 2B3C D2 E6 1D             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3620+ 2B3F 32 40 55             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3621+ 2B42 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
3622+ 2B45 2C                   defb    ','
3623+ 2B46 CD 32 2A             call    GETINT          ; get second value (0-255), returned into A
3624+ 2B49 5F                   ld      E,A             ; store value into E
3625+ 2B4A 3A 40 55             ld      A,(TMPBFR1)     ; recover VDP register and store into D
3626+ 2B4D F3                   di                      ; disable INTs
3627+ 2B4E 0E 40                ld      C,PSG_REG       ; output port to access PSG registers
3628+ 2B50 ED 79                out     (C),A           ; send register # to PSG
3629+ 2B52 0E 41                ld      C,PSG_DAT       ; output port to send data to PSG
3630+ 2B54 ED 59                out     (C),E           ; send byte to write into selected register
3631+ 2B56 FB                   ei                      ; re-enable INTs
3632+ 2B57 C9                   ret                     ; return to caller
3633+ 2B58
3634+ 2B58              ; VOLUME ch,vol
3635+ 2B58              ; set the volume for the audio channels
3636+ 2B58              ; "ch" is 1~3 for corresponding channel, or 0 for all; "vol" is 0~15 (0=OFF, 15=MAX)
3637+ 2B58 CD 32 2A     VOLUME: call    GETINT          ; get integer 0-255 (recover channel)
3638+ 2B5B FE 04                cp      $04             ; check if it's in the range 0~3
3639+ 2B5D D2 E6 1D             jp      NC,FCERR        ; if not, exit with Illegal function call error
3640+ 2B60 32 40 55             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3641+ 2B63 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
3642+ 2B66 2C                   defb    ','
3643+ 2B67 CD 32 2A             call    GETINT          ; get integer 0-255 (recover channel)
3644+ 2B6A FE 10                cp      $10             ; check if it's in the range 0~15
3645+ 2B6C D2 E6 1D             jp      NC,FCERR        ; if not, exit with Illegal funcion call
3646+ 2B6F 57                   ld      D,A             ; store volume into D
3647+ 2B70 3A 40 55             ld      A,(TMPBFR1)     ; retrieve channel
3648+ 2B73 A7                   and     A               ; is it 0? (0=every channel)
3649+ 2B74 20 10                jr      NZ,VOLCH        ; no, jump over
3650+ 2B76 06 03                ld      B,$03           ; yes, set every channel
3651+ 2B78 1E 08                ld      E,$08           ; register volume of first channel
3652+ 2B7A 0E 40        RPVOLCG:ld      C,PSG_REG       ; PSG register port
3653+ 2B7C ED 59                out     (C),E           ; set register #
3654+ 2B7E 0E 41                ld      C,PSG_DAT       ; PSG data port
3655+ 2B80 ED 51                out     (C),D           ; send volume
3656+ 2B82 1C                   inc     E               ; next register
3657+ 2B83 10 F5                djnz    RPVOLCG         ; repeat for each channel
3658+ 2B85 C9                   ret                     ; return to caller
3659+ 2B86 0E 40        VOLCH:  ld      C,PSG_REG       ; PSG register port
3660+ 2B88 C6 07                add     $07             ; add 7 to A so that we have the correct register (1->8, 2->9, 3->10)
3661+ 2B8A ED 79                out     (C),A           ; set register
3662+ 2B8C 0E 41                ld      C,PSG_DAT       ; PSG data port
3663+ 2B8E ED 51                out     (C),D           ; send volume level
3664+ 2B90 C9                   ret                     ; return to caller
3665+ 2B91
3666+ 2B91              ; SOUND ch,tone,dur
3667+ 2B91              ; play a tone or noise of "tone" frequency from selected channel "ch" for duration "dur"
3668+ 2B91              ; "ch" is 1~6 (0=means sound OFF,1~3 for tone, 4~6 for noise) / "tone" is 1~4,095 (0=means no tone) /
3669+ 2B91              ; "dur" is 1~16383 h.o.s.,0.001~163s (0=means non-stop tone)
3670+ 2B91 CD 32 2A     SOUND:  call    GETINT          ; get integer 0-255 (recover channel)
3671+ 2B94 A7                   and     A               ; is it zero?
3672+ 2B95 20 08                jr      NZ,CTSNDC       ; no, continue with checking of params
3673+ 2B97 E5                   push    HL              ; store HL
3674+ 2B98 F3                   di                      ; disable INTs
3675+ 2B99 CD 94 0C             call    CLRPSGREGS      ; yes, it's zero, so reset PSG registers to shut down every sound
3676+ 2B9C FB                   ei                      ; re-enable INTs
3677+ 2B9D E1                   pop     HL              ; retrieve HL
3678+ 2B9E C9                   ret                     ; return to caller
3679+ 2B9F 32 40 55     CTSNDC: ld      (TMPBFR1),A     ; no, continue by storing A into a temp. buffer
3680+ 2BA2 FE 04                cp      $04             ; is channel >3?
3681+ 2BA4 D2 23 2C             jp      NC,NOISUP       ; Yes - check to see if it's a noise channel
3682+ 2BA7 CD D2 1A             call    CHKSYN          ; No, continue checking by making sure ',' follows
3683+ 2BAA 2C                   defb    ','
3684+ 2BAB CD AC 21             call    GETNUM          ; Get tone frequency
3685+ 2BAE CD D1 1D             call    DEINT           ; Get integer -32768 to 32767
3686+ 2BB1 ED 53 42 55          ld      (TMPBFR2),DE    ; Store frequency
3687+ 2BB5 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
3688+ 2BB8 2C                   defb    ','
3689+ 2BB9 CD AC 21             call    GETNUM          ; Get duration
3690+ 2BBC CD D1 1D             call    DEINT           ; Get integer -32768 to 32767
3691+ 2BBF ED 53 44 55          ld      (TMPBFR3),DE    ; Store duration
3692+ 2BC3                                              ; CHECK CHANNEL
3693+ 2BC3 3A 40 55             ld      A,(TMPBFR1)     ; recover channel
3694+ 2BC6 FE 01                cp      $01             ; is channel <1?
3695+ 2BC8 DA E6 1D             jp      C,FCERR         ; Yes - Illegal function call error
3696+ 2BCB                                              ; CHECK FREQUENCY
3697+ 2BCB ED 5B 42 55          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3698+ 2BCF 7A                   ld      A,D             ; move D into A and check if it is in the range 0~4095...
3699+ 2BD0 FE 10                cp      $10             ; ...so D must not be greater than $0F (15)
3700+ 2BD2 D2 E6 1D             jp      NC,FCERR        ; if not in the range, exit with an Illegal function call error
3701+ 2BD5                                              ; CHECK DURATION
3702+ 2BD5 ED 5B 44 55          ld      DE,(TMPBFR3)    ; restore duration from temp buffer
3703+ 2BD9 7A                   ld      A,D             ; check if it is in the range 0~16383...
3704+ 2BDA E6 C0                and     $C0             ; ...(15th & 14th bits must not be set)
3705+ 2BDC C2 E6 1D             jp      NZ,FCERR        ; if not in the range, exit with an Illegal function call error
3706+ 2BDF                                              ;
3707+ 2BDF                                              ; SET TONE:
3708+ 2BDF                                              ; let's start by setting up the channel
3709+ 2BDF 3A 40 55             ld      A,(TMPBFR1)     ; restore channel value
3710+ 2BE2 FE 03                cp      $03             ; is it 3?
3711+ 2BE4 20 02                jr      NZ,SND1         ; no, jump over
3712+ 2BE6 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3713+ 2BE8 2F           SND1:   cpl                     ; complement of A - this is used later to set on the channel into the mixer
3714+ 2BE9 CD 70 2C             call    WRTSND          ; enable line into mixer of channel stored in A
3715+ 2BEC                                              ; SET FREQUENCY
3716+ 2BEC                                              ; we simply get frequency and subtract from 4096. The result
3717+ 2BEC                                              ; is put into register pair of the corresponding freq tone channel
3718+ 2BEC ED 5B 42 55          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3719+ 2BF0 E5                   push    HL              ; store HL (it will be used by the subroutine)
3720+ 2BF1 21 00 10             ld      HL,$1000        ; load 4096 into HL
3721+ 2BF4 A7                   and     A               ; reset C flag
3722+ 2BF5 ED 52                sbc     HL,DE           ; subtract freq from HL - now the frequency is inverted, so we will send the low as high and vice-versa
3723+ 2BF7 3A 40 55             ld      A,(TMPBFR1)     ; restore channel value
3724+ 2BFA 3D                   dec     A               ; set A into the range 0~2
3725+ 2BFB 87                   add     A,A             ; double A to find the register pair that correspond to the channel (A->0,1 / B->2,3, C->4,5)
3726+ 2BFC 0E 40                ld      C,PSG_REG       ; PSG register port
3727+ 2BFE ED 79                out     (C),A           ; select first register of the pair
3728+ 2C00 0E 41                ld      C,PSG_DAT       ; PSG data port
3729+ 2C02 ED 69                out     (C),L           ; send high byte
3730+ 2C04 0E 40                ld      C,PSG_REG       ; PSG register support
3731+ 2C06 3C                   inc     A               ; second register of the pair
3732+ 2C07 ED 79                out     (C),A           ; select register
3733+ 2C09 0E 41                ld      C,PSG_DAT       ; PSG data port
3734+ 2C0B ED 61                out     (C),H           ; send low byte
3735+ 2C0D ED 5B 44 55          ld      DE,(TMPBFR3)    ; recover duration
3736+ 2C11 3A 40 55             ld      A,(TMPBFR1)     ; recover channel value
3737+ 2C14 3D                   dec     A               ; set channel into the range 0~2
3738+ 2C15 87                   add     A,A             ; double A to find the correct offset
3739+ 2C16 21 74 55             ld      HL,CHASNDDTN    ; set duration into...
3740+ 2C19 85                   add     A,L             ; ...the proper...
3741+ 2C1A 30 01                jr      NC,SNDOVR       ; (is there a rest? no, jump over
3742+ 2C1C 24                   inc     H               ; yes, increment H)
3743+ 2C1D 6F           SNDOVR: ld      L,A             ; ...register pair...
3744+ 2C1E 73                   ld      (HL),E          ; ...and store the value
3745+ 2C1F 23                   inc     HL
3746+ 2C20 72                   ld      (HL),D
3747+ 2C21 E1                   pop     HL              ; retrieve HL
3748+ 2C22 C9                   ret                     ; Return to caller
3749+ 2C23 FE 07        NOISUP: cp      $07             ; is channel in range 4 to 6 (for a noise)?
3750+ 2C25 D2 E6 1D             jp      NC,FCERR        ; no, so ILLEGAL FUNCTION CALL
3751+ 2C28 CD D2 1A             call    CHKSYN          ; yes, continue checking by making sure ',' follows
3752+ 2C2B 2C                   defb    ','
3753+ 2C2C CD 32 2A             call    GETINT          ; get integer 0-255 (frequency)
3754+ 2C2F FE 20                cp      $20             ; make sure it's in range 0~31
3755+ 2C31 D2 E6 1D             jp      NC,FCERR        ; no, so Illegal function call
3756+ 2C34 32 42 55             ld      (TMPBFR2),A     ; store freq.
3757+ 2C37 2B                   dec     HL              ; dec 'cos GETCHR INCs
3758+ 2C38 CD 1B 1D             call    GETCHR          ; check that nothing follows
3759+ 2C3B C2 D2 17             jp      NZ,SNERR        ; error if no empty line
3760+ 2C3E 3A 42 55             ld      A,(TMPBFR2)     ; retrieve freq.
3761+ 2C41 5F                   ld      E,A             ; store freq into E
3762+ 2C42 3A 40 55             ld      A,(TMPBFR1)     ; retrieve channel
3763+ 2C45 D6 03                sub     $03             ; subtract 3 to get channel in range 1~3
3764+ 2C47 FE 03                cp      $03             ; is it 3?
3765+ 2C49 20 02                jr      NZ,NOS1         ; no, jump over
3766+ 2C4B 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3767+ 2C4D 87           NOS1:   add     A,A
3768+ 2C4E 87                   add     A,A
3769+ 2C4F 87                   add     A,A             ; let's move A 3 bits to left
3770+ 2C50 47                   ld      B,A             ; store channel into B
3771+ 2C51 7B                   ld      A,E             ; check if
3772+ 2C52 A7                   and     A               ; freq is 0 (means that noise reproduction must be halted)
3773+ 2C53 F3                   di                      ; disable INts
3774+ 2C54 20 0A                jr      NZ,NOS2         ; no, so jump over
3775+ 2C56 3E 07                ld      A,$07           ; mixer register
3776+ 2C58 CD E2 0C             call    SETSNDREG       ; set mixer register
3777+ 2C5B ED 78                in      A,(C)           ; load current mixer value
3778+ 2C5D B0                   or      B               ; disable noise
3779+ 2C5E 18 19                jr      NOS3            ; continue over
3780+ 2C60 78           NOS2:   ld      A,B             ; recover channel
3781+ 2C61 2F                   cpl                     ; complement of A - this is used to set on the channel into the mixer
3782+ 2C62 CD 70 2C             call    WRTSND          ; enable line into mixer of channel stored in A
3783+ 2C65 3E 06                ld      A,$06           ; write into noise register
3784+ 2C67 CD E2 0C             call    SETSNDREG       ; set register into PSG
3785+ 2C6A 7B                   ld      A,E             ; load value for noise frequency
3786+ 2C6B CD E7 0C             call    WRTSNDREG       ; write data into register $06
3787+ 2C6E FB                   ei                      ; re-enable INTs
3788+ 2C6F C9                   ret
3789+ 2C70                      ; enable line into mixer of channel stored in A
3790+ 2C70 47           WRTSND: ld      B,A             ; move channel into B
3791+ 2C71 3E 07                ld      A,$07           ; mixer register
3792+ 2C73 CD E2 0C             call    SETSNDREG       ; set mixer register
3793+ 2C76 ED 78                in      A,(C)           ; load current value
3794+ 2C78 A0                   and     B               ; set on the channel into the mixer (remember that 0=ON)
3795+ 2C79                                              ; example: if channel is A (1), complement of 1 is 254 (11111110). So, 255 (in case
3796+ 2C79                                              ; the register is still unchanged after reset) is 11111111 and
3797+ 2C79                                              ; 11111111 AND 11111110 is equal to 11111110
3798+ 2C79                                              ; 11111001 AND 11111110 is equal to 11111000 (in case channels B & C are ON)
3799+ 2C79 47           NOS3:   ld      B,A             ; store new mixer value into B
3800+ 2C7A 3E 07                ld      A,$07           ; mixer address
3801+ 2C7C CD E2 0C             call    SETSNDREG       ; set register
3802+ 2C7F 78                   ld      A,B             ; retrieve new mixer value from B
3803+ 2C80 CD E7 0C             call    WRTSNDREG       ; send new value for the mixer
3804+ 2C83 FB                   ei                      ; re-enable INTs
3805+ 2C84 C9                   ret                     ; return to caller
3806+ 2C85
3807+ 2C85              ; write a byte into one of the VDP registers
3808+ 2C85 CD 32 2A     VREG:   call    GETINT          ; Get register number back into A
3809+ 2C88 FE 08                cp      $08             ; check if value is equal or greater than 8 (VDP registers are only 8, from 0 to 7)
3810+ 2C8A D2 E6 1D             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3811+ 2C8D 32 40 55             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3812+ 2C90 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
3813+ 2C93 2C                   defb    ','
3814+ 2C94 CD 32 2A             call    GETINT          ; get value (0-255)
3815+ 2C97 5F                   ld      E,A             ; store value into E
3816+ 2C98 3A 40 55             ld      A,(TMPBFR1)     ; recover VDP register and store into A
3817+ 2C9B F3                   di                      ; disable INTs
3818+ 2C9C CD B3 06             call    WRITE_VREG      ; write value into VDP register
3819+ 2C9F FB                   ei                      ; re-enable INTs
3820+ 2CA0 C9                   ret                     ; return to caller
3821+ 2CA1
3822+ 2CA1              ; read the VDP status register and return it into A
3823+ 2CA1 CD D1 1D     VSTAT:  call    DEINT           ; Get integer -32768 to 32767 (Note: we do NOT use it)
3824+ 2CA4 F3                   di                      ; disable INTs
3825+ 2CA5 CD BE 06             call    READ_VSTAT      ; read VDP register status
3826+ 2CA8 FB                   ei                      ; re-enable INTs
3827+ 2CA9 C3 A5 25             jp      PASSA           ; Return integer A
3828+ 2CAC
3829+ 2CAC              ; read from PSG register and return it into A
3830+ 2CAC CD D1 1D     SSTAT:  call    DEINT           ; get integer -32768 to 32767
3831+ 2CAF 7B                   ld      A,E             ; consider LSB
3832+ 2CB0 FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3833+ 2CB2 D2 E6 1D             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3834+ 2CB5 F3                   di                      ; disable INts
3835+ 2CB6 0E 40                ld      C,PSG_REG       ; output port to set PSG register
3836+ 2CB8 ED 79                out     (C),A           ; send register to read from
3837+ 2CBA ED 78                in      A,(C)           ; read register's contents and store into A
3838+ 2CBC FB                   ei                      ; re-enable INTs
3839+ 2CBD C3 A5 25             jp      PASSA           ; return A
3840+ 2CC0
3841+ 2CC0              ; read the temp key buffer and return the value of the current key being pressed
3842+ 2CC0              ; can wait for the number of 100thds of second before to return
3843+ 2CC0 CD 1F 26     INKEY:  call    IDTEST          ; Test for illegal direct
3844+ 2CC3 CD D1 1D             call    DEINT           ; get number param (100thds of second to wait) into DE
3845+ 2CC6 C5                   push    BC              ; store BC
3846+ 2CC7 3A 20 55             ld      A,(TMRCNT)      ; Load current value of system timer
3847+ 2CCA 47                   ld      B,A             ; move it into B
3848+ 2CCB 3A 20 55     CMP_A:  ld      A,(TMRCNT)      ; make a little delay of 1/100 sec...
3849+ 2CCE B8                   cp      B               ; ...to let the sniffer collect...
3850+ 2CCF 20 FA                jr      NZ,CMP_A        ; ...at least 1 char before to continue
3851+ 2CD1 7A                   ld      A,D             ; check the param
3852+ 2CD2 B3                   or      E               ; if DE<>0 then...
3853+ 2CD3 20 05                jr      NZ,INKEY2       ; ...jump over...
3854+ 2CD5 3A 7C 55             ld      A,(TMPKEYBFR)   ; ...else read the buffer and...
3855+ 2CD8 18 2A                jr      ENDINK          ; ...return it
3856+ 2CDA 7A           INKEY2: ld      A,D             ; check if param>1023
3857+ 2CDB FE 04                cp      $04             ; to do this we check if MSB>3
3858+ 2CDD D2 E6 1D             jp      NC,FCERR        ; if MSB >=4 then error
3859+ 2CE0 E5                   push    HL              ; store HL
3860+ 2CE1 21 09 00             ld      HL,$0009        ; check if value
3861+ 2CE4 CD F9 40             call    CMP16           ; is < 10
3862+ 2CE7 E1                   pop     HL              ; retrieve HL
3863+ 2CE8 DA EE 2C             jp      C,SRTINK        ; if value >= 10 then jump over
3864+ 2CEB 11 0A 00             ld      DE,$000A        ; else, use 10 (no intervals shorter than 10/100s)
3865+ 2CEE 3A 20 55     SRTINK: ld      A,(TMRCNT)      ; Load the first byte of the system timer
3866+ 2CF1 47                   ld      B,A             ; move it into B
3867+ 2CF2 3A 7C 55     CHKINK: ld      A,(TMPKEYBFR)   ; load char code from buffer
3868+ 2CF5 A7                   and     A               ; is it 0?
3869+ 2CF6 20 0C                jr      NZ,ENDINK       ; no, so we can return it
3870+ 2CF8 3A 20 55             ld      A,(TMRCNT)      ; load the first byte of the system timer
3871+ 2CFB B8                   cp      B               ; is it the same value?
3872+ 2CFC 28 F4                jr      Z,CHKINK        ; yes, so read again
3873+ 2CFE 47                   ld      B,A             ; store new value
3874+ 2CFF 1B                   dec     DE              ; no, decrement timer
3875+ 2D00 7A                   ld      A,D             ; check if zero reached
3876+ 2D01 B3                   or      E               ; by ORing D and E
3877+ 2D02 20 EE                jr      NZ,CHKINK       ; if not 0, repeat
3878+ 2D04 C1           ENDINK: pop     BC              ; restore BC
3879+ 2D05 F5                   push    AF              ; store A
3880+ 2D06 F3                   di                      ; disable INTs
3881+ 2D07 AF                   xor     A               ; clear the...
3882+ 2D08 32 7C 55             ld      (TMPKEYBFR),A   ; ...TMP KEY buffer for the next read
3883+ 2D0B FB                   ei                      ; re-enable INTs
3884+ 2D0C F1                   pop     AF              ; retrieve A
3885+ 2D0D C3 A5 25     ENDINK2:jp      PASSA           ; return A as ASCII value
3886+ 2D10
3887+ 2D10
3888+ 2D10 21 37 32     ROUND:  ld      HL,HALF         ; Add 0.5 to FPREG
3889+ 2D13 CD 08 30     ADDPHL: call    LOADFP          ; Load FP at (HL) to BCDE
3890+ 2D16 C3 22 2D             jp      FPADD           ; Add BCDE to FPREG
3891+ 2D19
3892+ 2D19
3893+ 2D19 CD 08 30     SUBPHL: call    LOADFP          ; FPREG = -FPREG + number at HL
3894+ 2D1C 21                   defb    $21             ; Skip "pop BC" and "pop DE"
3895+ 2D1D C1           PSUB:   pop     BC              ; Get FP number from stack
3896+ 2D1E D1                   pop     DE
3897+ 2D1F CD E2 2F     SUBCDE: call    INVSGN          ; Negate FPREG
3898+ 2D22 78           FPADD:  ld      A,B             ; Get FP exponent
3899+ 2D23 B7                   or      A               ; Is number zero?
3900+ 2D24 C8                   ret     Z               ; Yes - Nothing to add
3901+ 2D25 3A 97 55             ld      A,(FPEXP)       ; Get FPREG exponent
3902+ 2D28 B7                   or      A               ; Is this number zero?
3903+ 2D29 CA FA 2F             jp      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3904+ 2D2C 90                   sub     B               ; BCDE number larger?
3905+ 2D2D D2 3C 2D             jp      NC,NOSWAP       ; No - Don't swap them
3906+ 2D30 2F                   cpl                     ; Two's complement
3907+ 2D31 3C                   inc     A               ;  FP exponent
3908+ 2D32 EB                   ex      DE,HL
3909+ 2D33 CD EA 2F             call    STAKFP          ; Put FPREG on stack
3910+ 2D36 EB                   ex      DE,HL
3911+ 2D37 CD FA 2F             call    FPBCDE          ; Move BCDE to FPREG
3912+ 2D3A C1                   pop     BC              ; Restore number from stack
3913+ 2D3B D1                   pop     DE
3914+ 2D3C FE 19        NOSWAP: cp      24+1            ; Second number insignificant?
3915+ 2D3E D0                   ret     NC              ; Yes - First number is result
3916+ 2D3F F5                   push    AF              ; Save number of bits to scale
3917+ 2D40 CD 1F 30             call    SIGNS           ; Set MSBs & sign of result
3918+ 2D43 67                   ld      H,A             ; Save sign of result
3919+ 2D44 F1                   pop     AF              ; Restore scaling factor
3920+ 2D45 CD E7 2D             call    SCALE           ; Scale BCDE to same exponent
3921+ 2D48 B4                   or      H               ; Result to be positive?
3922+ 2D49 21 94 55             ld      HL,FPREG        ; Point to FPREG
3923+ 2D4C F2 62 2D             jp      P,MINCDE        ; No - Subtract FPREG from CDE
3924+ 2D4F CD C7 2D             call    PLUCDE          ; Add FPREG to CDE
3925+ 2D52 D2 A8 2D             jp      NC,RONDUP       ; No overflow - Round it up
3926+ 2D55 23                   inc     HL              ; Point to exponent
3927+ 2D56 34                   inc     (HL)            ; Increment it
3928+ 2D57 CA E1 17             jp      Z,OVERR         ; Number overflowed - Error
3929+ 2D5A 2E 01                ld      L,$01           ; 1 bit to shift right
3930+ 2D5C CD FD 2D             call    SHRT1           ; Shift result right
3931+ 2D5F C3 A8 2D             jp      RONDUP          ; Round it up
3932+ 2D62
3933+ 2D62 AF           MINCDE: xor     A               ; Clear A and carry
3934+ 2D63 90                   sub     B               ; Negate exponent
3935+ 2D64 47                   ld      B,A             ; Re-save exponent
3936+ 2D65 7E                   ld      A,(HL)          ; Get LSB of FPREG
3937+ 2D66 9B                   sbc     A, E            ; Subtract LSB of BCDE
3938+ 2D67 5F                   ld      E,A             ; Save LSB of BCDE
3939+ 2D68 23                   inc     HL
3940+ 2D69 7E                   ld      A,(HL)          ; Get NMSB of FPREG
3941+ 2D6A 9A                   sbc     A,D             ; Subtract NMSB of BCDE
3942+ 2D6B 57                   ld      D,A             ; Save NMSB of BCDE
3943+ 2D6C 23                   inc     HL
3944+ 2D6D 7E                   ld      A,(HL)          ; Get MSB of FPREG
3945+ 2D6E 99                   sbc     A,C             ; Subtract MSB of BCDE
3946+ 2D6F 4F                   ld      C,A             ; Save MSB of BCDE
3947+ 2D70 DC D3 2D     CONPOS: call    C,COMPL         ; Overflow - Make it positive
3948+ 2D73
3949+ 2D73 68           BNORM:  ld      L,B             ; L = Exponent
3950+ 2D74 63                   ld      H,E             ; H = LSB
3951+ 2D75 AF                   xor     A
3952+ 2D76 47           BNRMLP: ld      B,A             ; Save bit count
3953+ 2D77 79                   ld      A,C             ; Get MSB
3954+ 2D78 B7                   or      A               ; Is it zero?
3955+ 2D79 C2 95 2D             jp      NZ,PNORM        ; No - Do it bit at a time
3956+ 2D7C 4A                   ld      C,D             ; MSB = NMSB
3957+ 2D7D 54                   ld      D,H             ; NMSB= LSB
3958+ 2D7E 65                   ld      H,L             ; LSB = VLSB
3959+ 2D7F 6F                   ld      L,A             ; VLSB= 0
3960+ 2D80 78                   ld      A,B             ; Get exponent
3961+ 2D81 D6 08                sub     $08             ; Count 8 bits
3962+ 2D83 FE E0                cp      -24-8           ; Was number zero?
3963+ 2D85 C2 76 2D             jp      NZ,BNRMLP       ; No - Keep normalising
3964+ 2D88 AF           RESZER: xor     A               ; Result is zero
3965+ 2D89 32 97 55     SAVEXP: ld      (FPEXP),A       ; Save result as zero
3966+ 2D8C C9                   ret
3967+ 2D8D
3968+ 2D8D 05           NORMAL: dec     B               ; Count bits
3969+ 2D8E 29                   add     HL,HL           ; Shift HL left
3970+ 2D8F 7A                   ld      A,D             ; Get NMSB
3971+ 2D90 17                   rla                     ; Shift left with last bit
3972+ 2D91 57                   ld      D,A             ; Save NMSB
3973+ 2D92 79                   ld      A,C             ; Get MSB
3974+ 2D93 8F                   adc     A,A             ; Shift left with last bit
3975+ 2D94 4F                   ld      C,A             ; Save MSB
3976+ 2D95 F2 8D 2D     PNORM:  jp      P,NORMAL        ; Not done - Keep going
3977+ 2D98 78                   ld      A,B             ; Number of bits shifted
3978+ 2D99 5C                   ld      E,H             ; Save HL in EB
3979+ 2D9A 45                   ld      B,L
3980+ 2D9B B7                   or      A               ; Any shifting done?
3981+ 2D9C CA A8 2D             jp      Z,RONDUP        ; No - Round it up
3982+ 2D9F 21 97 55             ld      HL,FPEXP        ; Point to exponent
3983+ 2DA2 86                   add     A,(HL)          ; Add shifted bits
3984+ 2DA3 77                   ld      (HL),A          ; Re-save exponent
3985+ 2DA4 D2 88 2D             jp      NC,RESZER       ; Underflow - Result is zero
3986+ 2DA7 C8                   ret     Z               ; Result is zero
3987+ 2DA8 78           RONDUP: ld      A,B             ; Get VLSB of number
3988+ 2DA9 21 97 55     RONDB:  ld      HL,FPEXP        ; Point to exponent
3989+ 2DAC B7                   or      A               ; Any rounding?
3990+ 2DAD FC BA 2D             call    M,FPROND        ; Yes - Round number up
3991+ 2DB0 46                   ld      B,(HL)          ; B = Exponent
3992+ 2DB1 23                   inc     HL
3993+ 2DB2 7E                   ld      A,(HL)          ; Get sign of result
3994+ 2DB3 E6 80                and     %10000000       ; Only bit 7 needed
3995+ 2DB5 A9                   xor     C               ; Set correct sign
3996+ 2DB6 4F                   ld      C,A             ; Save correct sign in number
3997+ 2DB7 C3 FA 2F             jp      FPBCDE          ; Move BCDE to FPREG
3998+ 2DBA
3999+ 2DBA 1C           FPROND: inc     E               ; Round LSB
4000+ 2DBB C0                   ret     NZ              ; Return if ok
4001+ 2DBC 14                   inc     D               ; Round NMSB
4002+ 2DBD C0                   ret     NZ              ; Return if ok
4003+ 2DBE 0C                   inc     C               ; Round MSB
4004+ 2DBF C0                   ret     NZ              ; Return if ok
4005+ 2DC0 0E 80                ld      C,$80           ; Set normal value
4006+ 2DC2 34                   inc     (HL)            ; Increment exponent
4007+ 2DC3 C0                   ret     NZ              ; Return if ok
4008+ 2DC4 C3 E1 17             jp      OVERR           ; Overflow error
4009+ 2DC7
4010+ 2DC7 7E           PLUCDE: ld      A,(HL)          ; Get LSB of FPREG
4011+ 2DC8 83                   add     A,E             ; Add LSB of BCDE
4012+ 2DC9 5F                   ld      E,A             ; Save LSB of BCDE
4013+ 2DCA 23                   inc     HL
4014+ 2DCB 7E                   ld      A,(HL)          ; Get NMSB of FPREG
4015+ 2DCC 8A                   adc     A,D             ; Add NMSB of BCDE
4016+ 2DCD 57                   ld      D,A             ; Save NMSB of BCDE
4017+ 2DCE 23                   inc     HL
4018+ 2DCF 7E                   ld      A,(HL)          ; Get MSB of FPREG
4019+ 2DD0 89                   adc     A,C             ; Add MSB of BCDE
4020+ 2DD1 4F                   ld      C,A             ; Save MSB of BCDE
4021+ 2DD2 C9                   ret
4022+ 2DD3
4023+ 2DD3 21 98 55     COMPL:  ld      HL,SGNRES       ; Sign of result
4024+ 2DD6 7E                   ld      A,(HL)          ; Get sign of result
4025+ 2DD7 2F                   cpl                     ; Negate it
4026+ 2DD8 77                   ld      (HL),A          ; Put it back
4027+ 2DD9 AF                   xor     A
4028+ 2DDA 6F                   ld      L,A             ; Set L to zero
4029+ 2DDB 90                   sub     B               ; Negate exponent,set carry
4030+ 2DDC 47                   ld      B,A             ; Re-save exponent
4031+ 2DDD 7D                   ld      A,L             ; Load zero
4032+ 2DDE 9B                   sbc     A,E             ; Negate LSB
4033+ 2DDF 5F                   ld      E,A             ; Re-save LSB
4034+ 2DE0 7D                   ld      A,L             ; Load zero
4035+ 2DE1 9A                   sbc     A,D             ; Negate NMSB
4036+ 2DE2 57                   ld      D,A             ; Re-save NMSB
4037+ 2DE3 7D                   ld      A,L             ; Load zero
4038+ 2DE4 99                   sbc     A,C             ; Negate MSB
4039+ 2DE5 4F                   ld      C,A             ; Re-save MSB
4040+ 2DE6 C9                   ret
4041+ 2DE7
4042+ 2DE7 06 00        SCALE:  ld      B,$00           ; Clear underflow
4043+ 2DE9 D6 08        SCALLP: sub     $08             ; 8 bits (a whole byte)?
4044+ 2DEB DA F6 2D             jp      C,SHRITE        ; No - Shift right A bits
4045+ 2DEE 43                   ld      B,E             ; <- Shift
4046+ 2DEF 5A                   ld      E,D             ; <- right
4047+ 2DF0 51                   ld      D,C             ; <- eight
4048+ 2DF1 0E 00                ld      C,$00           ; <- bits
4049+ 2DF3 C3 E9 2D             jp      SCALLP          ; More bits to shift
4050+ 2DF6
4051+ 2DF6 C6 09        SHRITE: add     A,8+1           ; Adjust count
4052+ 2DF8 6F                   ld      L,A             ; Save bits to shift
4053+ 2DF9 AF           SHRLP:  xor     A               ; Flag for all done
4054+ 2DFA 2D                   dec     L               ; All shifting done?
4055+ 2DFB C8                   ret     Z               ; Yes - Return
4056+ 2DFC 79                   ld      A,C             ; Get MSB
4057+ 2DFD 1F           SHRT1:  rra                     ; Shift it right
4058+ 2DFE 4F                   ld      C,A             ; Re-save
4059+ 2DFF 7A                   ld      A,D             ; Get NMSB
4060+ 2E00 1F                   rra                     ; Shift right with last bit
4061+ 2E01 57                   ld      D,A             ; Re-save it
4062+ 2E02 7B                   ld      A,E             ; Get LSB
4063+ 2E03 1F                   rra                     ; Shift right with last bit
4064+ 2E04 5F                   ld      E,A             ; Re-save it
4065+ 2E05 78                   ld      A,B             ; Get underflow
4066+ 2E06 1F                   rra                     ; Shift right with last bit
4067+ 2E07 47                   ld      B,A             ; Re-save underflow
4068+ 2E08 C3 F9 2D             jp      SHRLP           ; More bits to do
4069+ 2E0B
4070+ 2E0B 00 00 00 81  UNITY:  defb    $00,$00,$00,$81 ; 1.00000
4071+ 2E0F
4072+ 2E0F 03           LOGTAB: defb    $03             ; Table used by LOG
4073+ 2E10 AA 56 19 80          defb    $AA,$56,$19,$80 ; 0.59898
4074+ 2E14 F1 22 76 80          defb    $F1,$22,$76,$80 ; 0.96147
4075+ 2E18 45 AA 38 82          defb    $45,$AA,$38,$82 ; 2.88539
4076+ 2E1C
4077+ 2E1C CD B9 2F     LOG:    call    TSTSGN          ; Test sign of value
4078+ 2E1F B7                   or      A
4079+ 2E20 EA E6 1D             jp      PE,FCERR        ; ?FC Error if <= zero
4080+ 2E23 21 97 55             ld      HL,FPEXP        ; Point to exponent
4081+ 2E26 7E                   ld      A,(HL)          ; Get exponent
4082+ 2E27 01 35 80             ld      BC,$8035        ; BCDE = SQR(1/2)
4083+ 2E2A 11 F3 04             ld      DE,$04F3
4084+ 2E2D 90                   sub     B               ; Scale value to be < 1
4085+ 2E2E F5                   push    AF              ; Save scale factor
4086+ 2E2F 70                   ld      (HL),B          ; Save new exponent
4087+ 2E30 D5                   push    DE              ; Save SQR(1/2)
4088+ 2E31 C5                   push    BC
4089+ 2E32 CD 22 2D             call    FPADD           ; Add SQR(1/2) to value
4090+ 2E35 C1                   pop     BC              ; Restore SQR(1/2)
4091+ 2E36 D1                   pop     DE
4092+ 2E37 04                   inc     B               ; Make it SQR(2)
4093+ 2E38 CD 0F 2F             call    DVBCDE          ; Divide by SQR(2)
4094+ 2E3B 21 0B 2E             ld      HL,UNITY        ; Point to 1.
4095+ 2E3E CD 19 2D             call    SUBPHL          ; Subtract FPREG from 1
4096+ 2E41 21 0F 2E             ld      HL,LOGTAB       ; Coefficient table
4097+ 2E44 CD 01 33             call    SUMSER          ; Evaluate sum of series
4098+ 2E47 01 80 80             ld      BC,$8080        ; BCDE = -0.5
4099+ 2E4A 11 00 00             ld      DE,$0000
4100+ 2E4D CD 22 2D             call    FPADD           ; Subtract 0.5 from FPREG
4101+ 2E50 F1                   pop     AF              ; Restore scale factor
4102+ 2E51 CD 34 31             call    RSCALE          ; Re-scale number
4103+ 2E54 01 31 80     MULLN2: ld      BC,$8031        ; BCDE = Ln(2)
4104+ 2E57 11 18 72             ld      DE,$7218
4105+ 2E5A 21                   defb    $21             ; Skip "pop BC" and "pop DE"
4106+ 2E5B
4107+ 2E5B C1           MULT:   pop     BC              ; Get number from stack
4108+ 2E5C D1                   pop     DE
4109+ 2E5D CD B9 2F     FPMULT: call    TSTSGN          ; Test sign of FPREG
4110+ 2E60 C8                   ret     Z               ; Return zero if zero
4111+ 2E61 2E 00                ld      L,$00           ; Flag add exponents
4112+ 2E63 CD 77 2F             call    ADDEXP          ; Add exponents
4113+ 2E66 79                   ld      A,C             ; Get MSB of multiplier
4114+ 2E67 32 A6 55             ld      (MULVAL),A      ; Save MSB of multiplier
4115+ 2E6A EB                   ex      DE,HL
4116+ 2E6B 22 A7 55             ld      (MULVAL+1),HL   ; Save rest of multiplier
4117+ 2E6E 01 00 00             ld      BC,$0000        ; Partial product (BCDE) = zero
4118+ 2E71 50                   ld      D,B
4119+ 2E72 58                   ld      E,B
4120+ 2E73 21 73 2D             ld      HL,BNORM        ; Address of normalise
4121+ 2E76 E5                   push    HL              ; Save for return
4122+ 2E77 21 7F 2E             ld      HL,MULT8        ; Address of 8 bit multiply
4123+ 2E7A E5                   push    HL              ; Save for NMSB,MSB
4124+ 2E7B E5                   push    HL              ;
4125+ 2E7C 21 94 55             ld      HL,FPREG        ; Point to number
4126+ 2E7F 7E           MULT8:  ld      A,(HL)          ; Get LSB of number
4127+ 2E80 23                   inc     HL              ; Point to NMSB
4128+ 2E81 B7                   or      A               ; Test LSB
4129+ 2E82 CA AB 2E             jp      Z,BYTSFT        ; Zero - shift to next byte
4130+ 2E85 E5                   push    HL              ; Save address of number
4131+ 2E86 2E 08                ld      L,$08           ; 8 bits to multiply by
4132+ 2E88 1F           MUL8LP: rra                     ; Shift LSB right
4133+ 2E89 67                   ld      H,A             ; Save LSB
4134+ 2E8A 79                   ld      A,C             ; Get MSB
4135+ 2E8B D2 99 2E             jp      NC,NOMADD       ; Bit was zero - Don't add
4136+ 2E8E E5                   push    HL              ; Save LSB and count
4137+ 2E8F 2A A7 55             ld      HL,(MULVAL+1)   ; Get LSB and NMSB
4138+ 2E92 19                   add     HL,DE           ; Add NMSB and LSB
4139+ 2E93 EB                   ex      DE,HL           ; Leave sum in DE
4140+ 2E94 E1                   pop     HL              ; Restore MSB and count
4141+ 2E95 3A A6 55             ld      A,(MULVAL)      ; Get MSB of multiplier
4142+ 2E98 89                   adc     A,C             ; Add MSB
4143+ 2E99 1F           NOMADD: rra                     ; Shift MSB right
4144+ 2E9A 4F                   ld      C,A             ; Re-save MSB
4145+ 2E9B 7A                   ld      A,D             ; Get NMSB
4146+ 2E9C 1F                   rra                     ; Shift NMSB right
4147+ 2E9D 57                   ld      D,A             ; Re-save NMSB
4148+ 2E9E 7B                   ld      A,E             ; Get LSB
4149+ 2E9F 1F                   rra                     ; Shift LSB right
4150+ 2EA0 5F                   ld      E,A             ; Re-save LSB
4151+ 2EA1 78                   ld      A,B             ; Get VLSB
4152+ 2EA2 1F                   rra                     ; Shift VLSB right
4153+ 2EA3 47                   ld      B,A             ; Re-save VLSB
4154+ 2EA4 2D                   dec     L               ; Count bits multiplied
4155+ 2EA5 7C                   ld      A,H             ; Get LSB of multiplier
4156+ 2EA6 C2 88 2E             jp      NZ,MUL8LP       ; More - Do it
4157+ 2EA9 E1           POPHRT: pop     HL              ; Restore address of number
4158+ 2EAA C9                   ret
4159+ 2EAB
4160+ 2EAB 43           BYTSFT: ld      B,E             ; Shift partial product left
4161+ 2EAC 5A                   ld      E,D
4162+ 2EAD 51                   ld      D,C
4163+ 2EAE 4F                   ld      C,A
4164+ 2EAF C9                   ret
4165+ 2EB0
4166+ 2EB0
4167+ 2EB0              ; WORKING ââ
4168+ 2EB0 C1           DINT:   pop     BC              ; Get number from stack
4169+ 2EB1 D1                   pop     DE
4170+ 2EB2 CD 0F 2F             call    DVBCDE          ; get BCDE/FPREG and store result into FPREG
4171+ 2EB5 C3 8C 30             jp      INT             ; return INT(FPREG)
4172+ 2EB8
4173+ 2EB8
4174+ 2EB8              ; A MODULO B - return remainder of the integer division A/B where:
4175+ 2EB8              ; A is in stack; B is in FPREG
4176+ 2EB8              ; math is:
4177+ 2EB8              ; A=INT(A); B=INT(B); R=A-(B*INT(A/B))
4178+ 2EB8 CD 8C 30     MOD:    call    INT             ; B=INT(B)
4179+ 2EBB CD 05 30             call    BCDEFP          ; copy B (from FPREG) into BCDE
4180+ 2EBE ED 53 44 55          ld      (TMPBFR3),DE    ; store B into...
4181+ 2EC2 ED 43 46 55          ld      (TMPBFR4),BC    ; ...a temp buffer
4182+ 2EC6 C1                   pop     BC              ; recover A...
4183+ 2EC7 D1                   pop     DE              ; ...from stack
4184+ 2EC8 CD FA 2F             call    FPBCDE          ; store A into FPREG
4185+ 2ECB CD 8C 30             call    INT             ; get integer part: A=INT(A)
4186+ 2ECE CD 05 30             call    BCDEFP          ; copy A (from FPREG) into BCDE
4187+ 2ED1 ED 53 40 55          ld      (TMPBFR1),DE    ; store A into...
4188+ 2ED5 ED 43 42 55          ld      (TMPBFR2),BC    ; ...a temp buffer
4189+ 2ED9                                              ; begin calculation
4190+ 2ED9 2A 44 55             ld      HL,(TMPBFR3)    ; move B...
4191+ 2EDC 22 94 55             ld      (FPREG),HL      ; ...from...
4192+ 2EDF 2A 46 55             ld      HL,(TMPBFR4)    ; ...temp buffer...
4193+ 2EE2 22 96 55             ld      (FPREG+2),HL    ; ...into FPREG
4194+ 2EE5 CD 0F 2F             call    DVBCDE          ; compute A/B and store into FPREG
4195+ 2EE8 CD 8C 30             call    INT             ; get integer part of result: now FPREG = INT(A/B)
4196+ 2EEB ED 5B 44 55          ld      DE,(TMPBFR3)    ; load B...
4197+ 2EEF ED 4B 46 55          ld      BC,(TMPBFR4)    ; ...into BCDE
4198+ 2EF3 CD 5D 2E             call    FPMULT          ; get B*INT(A/B) and store into FPREG
4199+ 2EF6 ED 5B 40 55          ld      DE,(TMPBFR1)    ; retrieve A from...
4200+ 2EFA ED 4B 42 55          ld      BC,(TMPBFR2)    ; ...temp buffer
4201+ 2EFE C3 1F 2D             jp      SUBCDE          ; return result of A-(B*INT(A/B))
4202+ 2F01
4203+ 2F01
4204+ 2F01 CD EA 2F     DIV10:  call    STAKFP          ; Save FPREG on stack
4205+ 2F04 01 20 84             ld      BC,$8420        ; BCDE = 10.
4206+ 2F07 11 00 00             ld      DE,$0000
4207+ 2F0A CD FA 2F             call    FPBCDE          ; Move 10 to FPREG
4208+ 2F0D
4209+ 2F0D C1           DIV:    pop     BC              ; Get number from stack
4210+ 2F0E D1                   pop     DE
4211+ 2F0F CD B9 2F     DVBCDE: call    TSTSGN          ; Test sign of FPREG
4212+ 2F12 CA D5 17             jp      Z,DZERR         ; Error if division by zero
4213+ 2F15 2E FF                ld      L,-1            ; Flag subtract exponents
4214+ 2F17 CD 77 2F             call    ADDEXP          ; Subtract exponents
4215+ 2F1A 34                   inc     (HL)            ; Add 2 to exponent to adjust
4216+ 2F1B 34                   inc     (HL)
4217+ 2F1C 2B                   dec     HL              ; Point to MSB
4218+ 2F1D 7E                   ld      A,(HL)          ; Get MSB of dividend
4219+ 2F1E 32 B1 53             ld      (DIV3),A        ; Save for subtraction
4220+ 2F21 2B                   dec     HL
4221+ 2F22 7E                   ld      A,(HL)          ; Get NMSB of dividend
4222+ 2F23 32 AD 53             ld      (DIV2),A        ; Save for subtraction
4223+ 2F26 2B                   dec     HL
4224+ 2F27 7E                   ld      A,(HL)          ; Get MSB of dividend
4225+ 2F28 32 A9 53             ld      (DIV1),A        ; Save for subtraction
4226+ 2F2B 41                   ld      B,C             ; Get MSB
4227+ 2F2C EB                   ex      DE,HL           ; NMSB,LSB to HL
4228+ 2F2D AF                   xor     A
4229+ 2F2E 4F                   ld      C,A             ; Clear MSB of quotient
4230+ 2F2F 57                   ld      D,A             ; Clear NMSB of quotient
4231+ 2F30 5F                   ld      E,A             ; Clear LSB of quotient
4232+ 2F31 32 B4 53             ld      (DIV4),A        ; Clear overflow count
4233+ 2F34 E5           DIVLP:  push    HL              ; Save divisor
4234+ 2F35 C5                   push    BC
4235+ 2F36 7D                   ld      A,L             ; Get LSB of number
4236+ 2F37 CD A8 53             call    DIVSUP          ; Subt' divisor from dividend
4237+ 2F3A DE 00                sbc     A,$00           ; Count for overflows
4238+ 2F3C 3F                   ccf
4239+ 2F3D D2 47 2F             jp      NC,RESDIV       ; Restore divisor if borrow
4240+ 2F40 32 B4 53             ld      (DIV4),A        ; Re-save overflow count
4241+ 2F43 F1                   pop     AF              ; Scrap divisor
4242+ 2F44 F1                   pop     AF
4243+ 2F45 37                   scf                     ; Set carry to
4244+ 2F46 D2                   defb    $D2             ; Skip "pop BC" and "pop HL"
4245+ 2F47
4246+ 2F47 C1           RESDIV: pop     BC              ; Restore divisor
4247+ 2F48 E1                   pop     HL
4248+ 2F49 79                   ld      A,C             ; Get MSB of quotient
4249+ 2F4A 3C                   inc     A
4250+ 2F4B 3D                   dec     A
4251+ 2F4C 1F                   rra                     ; Bit 0 to bit 7
4252+ 2F4D FA A9 2D             jp      M,RONDB         ; Done - Normalise result
4253+ 2F50 17                   rla                     ; Restore carry
4254+ 2F51 7B                   ld      A,E             ; Get LSB of quotient
4255+ 2F52 17                   rla                     ; Double it
4256+ 2F53 5F                   ld      E,A             ; Put it back
4257+ 2F54 7A                   ld      A,D             ; Get NMSB of quotient
4258+ 2F55 17                   rla                     ; Double it
4259+ 2F56 57                   ld      D,A             ; Put it back
4260+ 2F57 79                   ld      A,C             ; Get MSB of quotient
4261+ 2F58 17                   rla                     ; Double it
4262+ 2F59 4F                   ld      C,A             ; Put it back
4263+ 2F5A 29                   add     HL,HL           ; Double NMSB,LSB of divisor
4264+ 2F5B 78                   ld      A,B             ; Get MSB of divisor
4265+ 2F5C 17                   rla                     ; Double it
4266+ 2F5D 47                   ld      B,A             ; Put it back
4267+ 2F5E 3A B4 53             ld      A,(DIV4)        ; Get VLSB of quotient
4268+ 2F61 17                   rla                     ; Double it
4269+ 2F62 32 B4 53             ld      (DIV4),A        ; Put it back
4270+ 2F65 79                   ld      A,C             ; Get MSB of quotient
4271+ 2F66 B2                   or      D               ; Merge NMSB
4272+ 2F67 B3                   or      E               ; Merge LSB
4273+ 2F68 C2 34 2F             jp      NZ,DIVLP        ; Not done - Keep dividing
4274+ 2F6B E5                   push    HL              ; Save divisor
4275+ 2F6C 21 97 55             ld      HL,FPEXP        ; Point to exponent
4276+ 2F6F 35                   dec     (HL)            ; Divide by 2
4277+ 2F70 E1                   pop     HL              ; Restore divisor
4278+ 2F71 C2 34 2F             jp      NZ,DIVLP        ; Ok - Keep going
4279+ 2F74 C3 E1 17             jp      OVERR           ; Overflow error
4280+ 2F77
4281+ 2F77
4282+ 2F77 78           ADDEXP: ld      A,B             ; Get exponent of dividend
4283+ 2F78 B7                   or      A               ; Test it
4284+ 2F79 CA 9B 2F             jp      Z,OVTST3        ; Zero - Result zero
4285+ 2F7C 7D                   ld      A,L             ; Get add/subtract flag
4286+ 2F7D 21 97 55             ld      HL,FPEXP        ; Point to exponent
4287+ 2F80 AE                   xor     (HL)            ; Add or subtract it
4288+ 2F81 80                   add     A,B             ; Add the other exponent
4289+ 2F82 47                   ld      B,A             ; Save new exponent
4290+ 2F83 1F                   rra                     ; Test exponent for overflow
4291+ 2F84 A8                   xor     B
4292+ 2F85 78                   ld      A,B             ; Get exponent
4293+ 2F86 F2 9A 2F             jp      P,OVTST2        ; Positive - Test for overflow
4294+ 2F89 C6 80                add     A,$80           ; Add excess 128
4295+ 2F8B 77                   ld      (HL),A          ; Save new exponent
4296+ 2F8C CA A9 2E             jp      Z,POPHRT        ; Zero - Result zero
4297+ 2F8F CD 1F 30             call    SIGNS           ; Set MSBs and sign of result
4298+ 2F92 77                   ld      (HL),A          ; Save new exponent
4299+ 2F93 2B                   dec     HL              ; Point to MSB
4300+ 2F94 C9                   ret
4301+ 2F95
4302+ 2F95 CD B9 2F     OVTST1: call    TSTSGN          ; Test sign of FPREG
4303+ 2F98 2F                   cpl                     ; Invert sign
4304+ 2F99 E1                   pop     HL              ; Clean up stack
4305+ 2F9A B7           OVTST2: or      A               ; Test if new exponent zero
4306+ 2F9B E1           OVTST3: pop     HL              ; Clear off return address
4307+ 2F9C F2 88 2D             jp      P,RESZER        ; Result zero
4308+ 2F9F C3 E1 17             jp      OVERR           ; Overflow error
4309+ 2FA2
4310+ 2FA2 CD 05 30     MLSP10: call    BCDEFP          ; Move FPREG to BCDE
4311+ 2FA5 78                   ld      A,B             ; Get exponent
4312+ 2FA6 B7                   or      A               ; Is it zero?
4313+ 2FA7 C8                   ret     Z               ; Yes - Result is zero
4314+ 2FA8 C6 02                add     A,$02           ; Multiply by 4
4315+ 2FAA DA E1 17             jp      C,OVERR         ; Overflow - ?OV Error
4316+ 2FAD 47                   ld      B,A             ; Re-save exponent
4317+ 2FAE CD 22 2D             call    FPADD           ; Add BCDE to FPREG (Times 5)
4318+ 2FB1 21 97 55             ld      HL,FPEXP        ; Point to exponent
4319+ 2FB4 34                   inc     (HL)            ; Double number (Times 10)
4320+ 2FB5 C0                   ret     NZ              ; Ok - Return
4321+ 2FB6 C3 E1 17             jp      OVERR           ; Overflow error
4322+ 2FB9
4323+ 2FB9 3A 97 55     TSTSGN: ld      A,(FPEXP)       ; Get sign of FPREG
4324+ 2FBC B7                   or      A
4325+ 2FBD C8                   ret     Z               ; RETurn if number is zero
4326+ 2FBE 3A 96 55             ld      A,(FPREG+2)     ; Get MSB of FPREG
4327+ 2FC1 FE                   defb    0FEH            ; Test sign
4328+ 2FC2 2F           RETREL: cpl                     ; Invert sign
4329+ 2FC3 17                   rla                     ; Sign bit to carry
4330+ 2FC4 9F           FLGDIF: sbc     A,A             ; Carry to all bits of A
4331+ 2FC5 C0                   ret     NZ              ; Return -1 if negative
4332+ 2FC6 3C                   inc     A               ; Bump to +1
4333+ 2FC7 C9                   ret                     ; Positive - Return +1
4334+ 2FC8
4335+ 2FC8 CD B9 2F     SGN:    call    TSTSGN          ; Test sign of FPREG
4336+ 2FCB 06 88        FLGREL: ld      B,$80+8         ; 8 bit integer in exponent
4337+ 2FCD 11 00 00             ld      DE,0            ; Zero NMSB and LSB
4338+ 2FD0 21 97 55     RETINT: ld      HL,FPEXP        ; Point to exponent
4339+ 2FD3 4F                   ld      C,A             ; CDE = MSB,NMSB and LSB
4340+ 2FD4 70                   ld      (HL),B          ; Save exponent
4341+ 2FD5 06 00                ld      B,0             ; CDE = integer to normalise
4342+ 2FD7 23                   inc     HL              ; Point to sign of result
4343+ 2FD8 36 80                ld      (HL),$80        ; Set sign of result
4344+ 2FDA 17                   rla                     ; Carry = sign of integer
4345+ 2FDB C3 70 2D             jp      CONPOS          ; Set sign of result
4346+ 2FDE
4347+ 2FDE CD B9 2F     ABS_:   call    TSTSGN          ; Test sign of FPREG
4348+ 2FE1 F0                   ret     P               ; Return if positive
4349+ 2FE2 21 96 55     INVSGN: ld      HL,FPREG+2      ; Point to MSB
4350+ 2FE5 7E                   ld      A,(HL)          ; Get sign of mantissa
4351+ 2FE6 EE 80                xor     $80             ; Invert sign of mantissa
4352+ 2FE8 77                   ld      (HL),A          ; Re-save sign of mantissa
4353+ 2FE9 C9                   ret
4354+ 2FEA
4355+ 2FEA EB           STAKFP: ex      DE,HL           ; Save code string address
4356+ 2FEB 2A 94 55             ld      HL,(FPREG)      ; LSB,NLSB of FPREG
4357+ 2FEE E3                   ex      (SP),HL         ; Stack them,get return
4358+ 2FEF E5                   push    HL              ; Re-save return
4359+ 2FF0 2A 96 55             ld      HL,(FPREG+2)    ; MSB and exponent of FPREG
4360+ 2FF3 E3                   ex      (SP),HL         ; Stack them,get return
4361+ 2FF4 E5                   push    HL              ; Re-save return
4362+ 2FF5 EB                   ex      DE,HL           ; Restore code string address
4363+ 2FF6 C9                   ret
4364+ 2FF7
4365+ 2FF7              ; store F.P. number from BCDE into (FPREG)
4366+ 2FF7 CD 08 30     PHLTFP: call    LOADFP          ; Number at HL to BCDE
4367+ 2FFA EB           FPBCDE: ex      DE,HL           ; Save code string address
4368+ 2FFB 22 94 55             ld      (FPREG),HL      ; Save LSB,NLSB of number
4369+ 2FFE 60                   ld      H,B             ; Exponent of number
4370+ 2FFF 69                   ld      L,C             ; MSB of number
4371+ 3000 22 96 55             ld      (FPREG+2),HL    ; Save MSB and exponent
4372+ 3003 EB                   ex      DE,HL           ; Restore code string address
4373+ 3004 C9                   ret
4374+ 3005
4375+ 3005              ; load F.P. number from (FPREG) into BCDE
4376+ 3005 21 94 55     BCDEFP: ld      HL,FPREG        ; Point to FPREG
4377+ 3008 5E           LOADFP: ld      E,(HL)          ; Get LSB of number
4378+ 3009 23                   inc     HL
4379+ 300A 56                   ld      D,(HL)          ; Get NMSB of number
4380+ 300B 23                   inc     HL
4381+ 300C 4E                   ld      C,(HL)          ; Get MSB of number
4382+ 300D 23                   inc     HL
4383+ 300E 46                   ld      B,(HL)          ; Get exponent of number
4384+ 300F 23           INCHL:  inc     HL              ; Used for conditional "inc HL"
4385+ 3010 C9                   ret
4386+ 3011
4387+ 3011              ; move floating point from (FPREG) into (HL)
4388+ 3011 11 94 55     FPTHL:  ld      DE,FPREG        ; Point to FPREG
4389+ 3014 06 04        DETHL4: ld      B,$04           ; 4 bytes to move
4390+ 3016 1A           DETHLB: ld      A,(DE)          ; Get source
4391+ 3017 77                   ld      (HL),A          ; Save destination
4392+ 3018 13                   inc     DE              ; Next source
4393+ 3019 23                   inc     HL              ; Next destination
4394+ 301A 05                   dec     B               ; Count bytes
4395+ 301B C2 16 30             jp      NZ,DETHLB       ; Loop if more
4396+ 301E C9                   ret
4397+ 301F
4398+ 301F 21 96 55     SIGNS:  ld      HL,FPREG+2      ; Point to MSB of FPREG
4399+ 3022 7E                   ld      A,(HL)          ; Get MSB
4400+ 3023 07                   rlca                    ; Old sign to carry
4401+ 3024 37                   scf                     ; Set MSBit
4402+ 3025 1F                   rra                     ; Set MSBit of MSB
4403+ 3026 77                   ld      (HL),A          ; Save new MSB
4404+ 3027 3F                   ccf                     ; Complement sign
4405+ 3028 1F                   rra                     ; Old sign to carry
4406+ 3029 23                   inc     HL
4407+ 302A 23                   inc     HL
4408+ 302B 77                   ld      (HL),A          ; Set sign of result
4409+ 302C 79                   ld      A,C             ; Get MSB
4410+ 302D 07                   rlca                    ; Old sign to carry
4411+ 302E 37                   scf                     ; Set MSBit
4412+ 302F 1F                   rra                     ; Set MSBit of MSB
4413+ 3030 4F                   ld      C,A             ; Save MSB
4414+ 3031 1F                   rra
4415+ 3032 AE                   xor     (HL)            ; New sign of result
4416+ 3033 C9                   ret
4417+ 3034
4418+ 3034 78           CMPNUM: ld      A,B             ; Get exponent of number
4419+ 3035 B7                   or      A
4420+ 3036 CA B9 2F             jp      Z,TSTSGN        ; Zero - Test sign of FPREG
4421+ 3039 21 C2 2F             ld      HL,RETREL       ; Return relation routine
4422+ 303C E5                   push    HL              ; Save for return
4423+ 303D CD B9 2F             call    TSTSGN          ; Test sign of FPREG
4424+ 3040 79                   ld      A,C             ; Get MSB of number
4425+ 3041 C8                   ret     Z               ; FPREG zero - Number's MSB
4426+ 3042 21 96 55             ld      HL,FPREG+2      ; MSB of FPREG
4427+ 3045 AE                   xor     (HL)            ; Combine signs
4428+ 3046 79                   ld      A,C             ; Get MSB of number
4429+ 3047 F8                   ret     M               ; Exit if signs different
4430+ 3048 CD 4E 30             call    CMPFP           ; Compare FP numbers
4431+ 304B 1F                   rra                     ; Get carry to sign
4432+ 304C A9                   xor     C               ; Combine with MSB of number
4433+ 304D C9                   ret
4434+ 304E
4435+ 304E 23           CMPFP:  inc     HL              ; Point to exponent
4436+ 304F 78                   ld      A,B             ; Get exponent
4437+ 3050 BE                   cp      (HL)            ; Compare exponents
4438+ 3051 C0                   ret     NZ              ; Different
4439+ 3052 2B                   dec     HL              ; Point to MBS
4440+ 3053 79                   ld      A,C             ; Get MSB
4441+ 3054 BE                   cp      (HL)            ; Compare MSBs
4442+ 3055 C0                   ret     NZ              ; Different
4443+ 3056 2B                   dec     HL              ; Point to NMSB
4444+ 3057 7A                   ld      A,D             ; Get NMSB
4445+ 3058 BE                   cp      (HL)            ; Compare NMSBs
4446+ 3059 C0                   ret     NZ              ; Different
4447+ 305A 2B                   dec     HL              ; Point to LSB
4448+ 305B 7B                   ld      A,E             ; Get LSB
4449+ 305C 96                   sub     (HL)            ; Compare LSBs
4450+ 305D C0                   ret     NZ              ; Different
4451+ 305E E1                   pop     HL              ; Drop RETurn
4452+ 305F E1                   pop     HL              ; Drop another RETurn
4453+ 3060 C9                   ret
4454+ 3061
4455+ 3061 47           FPINT:  ld      B,A             ; <- Move
4456+ 3062 4F                   ld      C,A             ; <- exponent
4457+ 3063 57                   ld      D,A             ; <- to all
4458+ 3064 5F                   ld      E,A             ; <- bits
4459+ 3065 B7                   or      A               ; Test exponent
4460+ 3066 C8                   ret     Z               ; Zero - Return zero
4461+ 3067 E5                   push    HL              ; Save pointer to number
4462+ 3068 CD 05 30             call    BCDEFP          ; Move FPREG to BCDE
4463+ 306B CD 1F 30             call    SIGNS           ; Set MSBs & sign of result
4464+ 306E AE                   xor     (HL)            ; Combine with sign of FPREG
4465+ 306F 67                   ld      H,A             ; Save combined signs
4466+ 3070 FC 85 30             call    M,DCBCDE        ; Negative - Decrement BCDE
4467+ 3073 3E 98                ld      A,$80+24        ; 24 bits
4468+ 3075 90                   sub     B               ; Bits to shift
4469+ 3076 CD E7 2D             call    SCALE           ; Shift BCDE
4470+ 3079 7C                   ld      A,H             ; Get combined sign
4471+ 307A 17                   rla                     ; Sign to carry
4472+ 307B DC BA 2D             call    C,FPROND        ; Negative - Round number up
4473+ 307E 06 00                ld      B,$00           ; Zero exponent
4474+ 3080 DC D3 2D             call    C,COMPL         ; If negative make positive
4475+ 3083 E1                   pop     HL              ; Restore pointer to number
4476+ 3084 C9                   ret
4477+ 3085
4478+ 3085 1B           DCBCDE: dec     DE              ; Decrement BCDE
4479+ 3086 7A                   ld      A,D             ; Test LSBs
4480+ 3087 A3                   and     E
4481+ 3088 3C                   inc     A
4482+ 3089 C0                   ret     NZ              ; Exit if LSBs not FFFF
4483+ 308A 0B                   dec     BC              ; Decrement MSBs
4484+ 308B C9                   ret
4485+ 308C
4486+ 308C 21 97 55     INT:    ld      HL,FPEXP        ; Point to exponent
4487+ 308F 7E                   ld      A,(HL)          ; Get exponent
4488+ 3090 FE 98                cp      $80+24          ; Integer accuracy only?
4489+ 3092 3A 94 55             ld      A,(FPREG)       ; Get LSB
4490+ 3095 D0                   ret     NC              ; Yes - Already integer
4491+ 3096 7E                   ld      A,(HL)          ; Get exponent
4492+ 3097 CD 61 30             call    FPINT           ; F.P to integer
4493+ 309A 36 98                ld      (HL),$80+24     ; Save 24 bit integer
4494+ 309C 7B                   ld      A,E             ; Get LSB of number
4495+ 309D F5                   push    AF              ; Save LSB
4496+ 309E 79                   ld      A,C             ; Get MSB of number
4497+ 309F 17                   rla                     ; Sign to carry
4498+ 30A0 CD 70 2D             call    CONPOS          ; Set sign of result
4499+ 30A3 F1                   pop     AF              ; Restore LSB of number
4500+ 30A4 C9                   ret
4501+ 30A5
4502+ 30A5 21 00 00     MLDEBC: ld      HL,$0000        ; Clear partial product
4503+ 30A8 78                   ld      A,B             ; Test multiplier
4504+ 30A9 B1                   or      C
4505+ 30AA C8                   ret     Z               ; Return zero if zero
4506+ 30AB 3E 10                ld      A,$10           ; 16 bits
4507+ 30AD 29           MLDBLP: add     HL,HL           ; Shift P.P left
4508+ 30AE DA D3 24             jp      C,BSERR         ; ?BS Error if overflow
4509+ 30B1 EB                   ex      DE,HL
4510+ 30B2 29                   add     HL,HL           ; Shift multiplier left
4511+ 30B3 EB                   ex      DE,HL
4512+ 30B4 D2 BB 30             jp      NC,NOMLAD       ; Bit was zero - No add
4513+ 30B7 09                   add     HL,BC           ; Add multiplicand
4514+ 30B8 DA D3 24             jp      C,BSERR         ; ?BS Error if overflow
4515+ 30BB 3D           NOMLAD: dec     A               ; Count bits
4516+ 30BC C2 AD 30             jp      NZ,MLDBLP       ; More
4517+ 30BF C9                   ret
4518+ 30C0
4519+ 30C0 FE 2D        ASCTFP: cp      '-'             ; Negative?
4520+ 30C2 F5                   push    AF              ; Save it and flags
4521+ 30C3 CA CC 30             jp      Z,CNVNUM        ; Yes - Convert number
4522+ 30C6 FE 2B                cp      '+'             ; Positive?
4523+ 30C8 CA CC 30             jp      Z,CNVNUM        ; Yes - Convert number
4524+ 30CB 2B                   dec     HL              ; dec 'cos GETCHR INCs
4525+ 30CC CD 88 2D     CNVNUM: call    RESZER          ; Set result to zero
4526+ 30CF 47                   ld      B,A             ; Digits after point counter
4527+ 30D0 57                   ld      D,A             ; Sign of exponent
4528+ 30D1 5F                   ld      E,A             ; Exponent of ten
4529+ 30D2 2F                   cpl
4530+ 30D3 4F                   ld      C,A             ; Before or after point flag
4531+ 30D4 CD 1B 1D     MANLP:  call    GETCHR          ; Get next character
4532+ 30D7 DA 1D 31             jp      C,ADDIG         ; Digit - Add to number
4533+ 30DA FE 2E                cp      '.'
4534+ 30DC CA F8 30             jp      Z,DPOINT        ; '.' - Flag point
4535+ 30DF FE 45                cp      'E'
4536+ 30E1 C2 FC 30             jp      NZ,CONEXP       ; Not 'E' - Scale number
4537+ 30E4 CD 1B 1D             call    GETCHR          ; Get next character
4538+ 30E7 CD EF 22             call    SGNEXP          ; Get sign of exponent
4539+ 30EA CD 1B 1D     EXPLP:  call    GETCHR          ; Get next character
4540+ 30ED DA 3F 31             jp      C,EDIGIT        ; Digit - Add to exponent
4541+ 30F0 14                   inc     D               ; Is sign negative?
4542+ 30F1 C2 FC 30             jp      NZ,CONEXP       ; No - Scale number
4543+ 30F4 AF                   xor     A
4544+ 30F5 93                   sub     E               ; Negate exponent
4545+ 30F6 5F                   ld      E,A             ; And re-save it
4546+ 30F7 0C                   inc     C               ; Flag end of number
4547+ 30F8 0C           DPOINT: inc     C               ; Flag point passed
4548+ 30F9 CA D4 30             jp      Z,MANLP         ; Zero - Get another digit
4549+ 30FC E5           CONEXP: push    HL              ; Save code string address
4550+ 30FD 7B                   ld      A,E             ; Get exponent
4551+ 30FE 90                   sub     B               ; Subtract digits after point
4552+ 30FF F4 15 31     SCALMI: call    P,SCALPL        ; Positive - Multiply number
4553+ 3102 F2 0B 31             jp      P,ENDCON        ; Positive - All done
4554+ 3105 F5                   push    AF              ; Save number of times to /10
4555+ 3106 CD 01 2F             call    DIV10           ; Divide by 10
4556+ 3109 F1                   pop     AF              ; Restore count
4557+ 310A 3C                   inc     A               ; Count divides
4558+ 310B
4559+ 310B C2 FF 30     ENDCON: jp      NZ,SCALMI       ; More to do
4560+ 310E D1                   pop     DE              ; Restore code string address
4561+ 310F F1                   pop     AF              ; Restore sign of number
4562+ 3110 CC E2 2F             call    Z,INVSGN        ; Negative - Negate number
4563+ 3113 EB                   ex      DE,HL           ; Code string address to HL
4564+ 3114 C9                   ret
4565+ 3115
4566+ 3115 C8           SCALPL: ret     Z               ; Exit if no scaling needed
4567+ 3116 F5           MULTEN: push    AF              ; Save count
4568+ 3117 CD A2 2F             call    MLSP10          ; Multiply number by 10
4569+ 311A F1                   pop     AF              ; Restore count
4570+ 311B 3D                   dec     A               ; Count multiplies
4571+ 311C C9                   ret
4572+ 311D
4573+ 311D D5           ADDIG:  push    DE              ; Save sign of exponent
4574+ 311E 57                   ld      D,A             ; Save digit
4575+ 311F 78                   ld      A,B             ; Get digits after point
4576+ 3120 89                   adc     A,C             ; Add one if after point
4577+ 3121 47                   ld      B,A             ; Re-save counter
4578+ 3122 C5                   push    BC              ; Save point flags
4579+ 3123 E5                   push    HL              ; Save code string address
4580+ 3124 D5                   push    DE              ; Save digit
4581+ 3125 CD A2 2F             call    MLSP10          ; Multiply number by 10
4582+ 3128 F1                   pop     AF              ; Restore digit
4583+ 3129 D6 30                sub     '0'             ; Make it absolute
4584+ 312B CD 34 31             call    RSCALE          ; Re-scale number
4585+ 312E E1                   pop     HL              ; Restore code string address
4586+ 312F C1                   pop     BC              ; Restore point flags
4587+ 3130 D1                   pop     DE              ; Restore sign of exponent
4588+ 3131 C3 D4 30             jp      MANLP           ; Get another digit
4589+ 3134
4590+ 3134 CD EA 2F     RSCALE: call    STAKFP          ; Put number on stack
4591+ 3137 CD CB 2F             call    FLGREL          ; Digit to add to FPREG
4592+ 313A C1           PADD:   pop     BC              ; Restore number
4593+ 313B D1                   pop     DE
4594+ 313C C3 22 2D             jp      FPADD           ; Add BCDE to FPREG and return
4595+ 313F
4596+ 313F 7B           EDIGIT: ld      A,E             ; Get digit
4597+ 3140 07                   rlca                    ; Times 2
4598+ 3141 07                   rlca                    ; Times 4
4599+ 3142 83                   add     A,E             ; Times 5
4600+ 3143 07                   rlca                    ; Times 10
4601+ 3144 86                   add     A,(HL)          ; Add next digit
4602+ 3145 D6 30                sub     '0'             ; Make it absolute
4603+ 3147 5F                   ld      E,A             ; Save new digit
4604+ 3148 C3 EA 30             jp      EXPLP           ; Look for another digit
4605+ 314B
4606+ 314B E5           LINEIN: push    HL              ; Save code string address
4607+ 314C 21 4B 17             ld      HL,INMSG        ; Output " in "
4608+ 314F CD B4 26             call    PRS             ; Output string at HL
4609+ 3152 E1                   pop     HL              ; Restore code string address
4610+ 3153 EB           PRNTHL: ex      DE,HL           ; Code string address to DE
4611+ 3154 AF                   xor     A
4612+ 3155 06 98                ld      B,$80+24        ; 24 bits
4613+ 3157 CD D0 2F             call    RETINT          ; Return the integer
4614+ 315A 21 B3 26             ld      HL,PRNUMS       ; Print number string
4615+ 315D E5                   push    HL              ; Save for return
4616+ 315E              ; conmvert FP number into ASCII chars
4617+ 315E 21 99 55     NUMASC: ld      HL,PBUFF        ; Convert number to ASCII
4618+ 3161 E5                   push    HL              ; Save for return
4619+ 3162 CD B9 2F             call    TSTSGN          ; Test sign of FPREG
4620+ 3165 36 20                ld      (HL),SPC        ; Space at start
4621+ 3167 F2 6C 31             jp      P,SPCFST        ; Positive - Space to start
4622+ 316A 36 2D                ld      (HL),'-'        ; '-' sign at start
4623+ 316C 23           SPCFST: inc     HL              ; First byte of number
4624+ 316D 36 30                ld      (HL),'0'        ; '0' if zero
4625+ 316F CA 22 32             jp      Z,JSTZER        ; Return '0' if zero
4626+ 3172 E5                   push    HL              ; Save buffer address
4627+ 3173 FC E2 2F             call    M,INVSGN        ; Negate FPREG if negative
4628+ 3176 AF                   xor     A               ; Zero A
4629+ 3177 F5                   push    AF              ; Save it
4630+ 3178 CD 28 32             call    RNGTST          ; Test number is in range
4631+ 317B 01 43 91     SIXDIG: ld      BC,$9143        ; BCDE - 99999.9
4632+ 317E 11 F8 4F             ld      DE,$4FF8
4633+ 3181 CD 34 30             call    CMPNUM          ; Compare numbers
4634+ 3184 B7                   or      A
4635+ 3185 E2 99 31             jp      PO,INRNG        ; > 99999.9 - Sort it out
4636+ 3188 F1                   pop     AF              ; Restore count
4637+ 3189 CD 16 31             call    MULTEN          ; Multiply by ten
4638+ 318C F5                   push    AF              ; Re-save count
4639+ 318D C3 7B 31             jp      SIXDIG          ; Test it again
4640+ 3190
4641+ 3190 CD 01 2F     GTSIXD: call    DIV10           ; Divide by 10
4642+ 3193 F1                   pop     AF              ; Get count
4643+ 3194 3C                   inc     A               ; Count divides
4644+ 3195 F5                   push    AF              ; Re-save count
4645+ 3196 CD 28 32             call    RNGTST          ; Test number is in range
4646+ 3199 CD 10 2D     INRNG:  call    ROUND           ; Add 0.5 to FPREG
4647+ 319C 3C                   inc     A
4648+ 319D CD 61 30             call    FPINT           ; F.P to integer
4649+ 31A0 CD FA 2F             call    FPBCDE          ; Move BCDE to FPREG
4650+ 31A3 01 06 03             ld      BC,$0306        ; 1E+06 to 1E-03 range
4651+ 31A6 F1                   pop     AF              ; Restore count
4652+ 31A7 81                   add     A,C             ; 6 digits before point
4653+ 31A8 3C                   inc     A               ; Add one
4654+ 31A9 FA B5 31             jp      M,MAKNUM        ; Do it in 'E' form if < 1E-02
4655+ 31AC FE 08                cp      6+1+1           ; More than 999999 ?
4656+ 31AE D2 B5 31             jp      NC,MAKNUM       ; Yes - Do it in 'E' form
4657+ 31B1 3C                   inc     A               ; Adjust for exponent
4658+ 31B2 47                   ld      B,A             ; Exponent of number
4659+ 31B3 3E 02                ld      A,2             ; Make it zero after
4660+ 31B5
4661+ 31B5 3D           MAKNUM: dec     A               ; Adjust for digits to do
4662+ 31B6 3D                   dec     A
4663+ 31B7 E1                   pop     HL              ; Restore buffer address
4664+ 31B8 F5                   push    AF              ; Save count
4665+ 31B9 11 3B 32             ld      DE,POWERS       ; Powers of ten
4666+ 31BC 05                   dec     B               ; Count digits before point
4667+ 31BD C2 C6 31             jp      NZ,DIGTXT       ; Not zero - Do number
4668+ 31C0 36 2E                ld      (HL),'.'        ; Save point
4669+ 31C2 23                   inc     HL              ; Move on
4670+ 31C3 36 30                ld      (HL),'0'        ; Save zero
4671+ 31C5 23                   inc     HL              ; Move on
4672+ 31C6 05           DIGTXT: dec     B               ; Count digits before point
4673+ 31C7 36 2E                ld      (HL),'.'        ; Save point in case
4674+ 31C9 CC 0F 30             call    Z,INCHL         ; Last digit - move on
4675+ 31CC C5                   push    BC              ; Save digits before point
4676+ 31CD E5                   push    HL              ; Save buffer address
4677+ 31CE D5                   push    DE              ; Save powers of ten
4678+ 31CF CD 05 30             call    BCDEFP          ; Move FPREG to BCDE
4679+ 31D2 E1                   pop     HL              ; Powers of ten table
4680+ 31D3 06 2F                ld      B,'0'-1         ; ASCII '0' - 1
4681+ 31D5 04           TRYAGN: inc     B               ; Count subtractions
4682+ 31D6 7B                   ld      A,E             ; Get LSB
4683+ 31D7 96                   sub     (HL)            ; Subtract LSB
4684+ 31D8 5F                   ld      E,A             ; Save LSB
4685+ 31D9 23                   inc     HL
4686+ 31DA 7A                   ld      A,D             ; Get NMSB
4687+ 31DB 9E                   sbc     A,(HL)          ; Subtract NMSB
4688+ 31DC 57                   ld      D,A             ; Save NMSB
4689+ 31DD 23                   inc     HL
4690+ 31DE 79                   ld      A,C             ; Get MSB
4691+ 31DF 9E                   sbc     A,(HL)          ; Subtract MSB
4692+ 31E0 4F                   ld      C,A             ; Save MSB
4693+ 31E1 2B                   dec     HL              ; Point back to start
4694+ 31E2 2B                   dec     HL
4695+ 31E3 D2 D5 31             jp      NC,TRYAGN       ; No overflow - Try again
4696+ 31E6 CD C7 2D             call    PLUCDE          ; Restore number
4697+ 31E9 23                   inc     HL              ; Start of next number
4698+ 31EA CD FA 2F             call    FPBCDE          ; Move BCDE to FPREG
4699+ 31ED EB                   ex      DE,HL           ; Save point in table
4700+ 31EE E1                   pop     HL              ; Restore buffer address
4701+ 31EF 70                   ld      (HL),B          ; Save digit in buffer
4702+ 31F0 23                   inc     HL              ; And move on
4703+ 31F1 C1                   pop     BC              ; Restore digit count
4704+ 31F2 0D                   dec     C               ; Count digits
4705+ 31F3 C2 C6 31             jp      NZ,DIGTXT       ; More - Do them
4706+ 31F6 05                   dec     B               ; Any decimal part?
4707+ 31F7 CA 06 32             jp      Z,DOEBIT        ; No - Do 'E' bit
4708+ 31FA 2B           SUPTLZ: dec     HL              ; Move back through buffer
4709+ 31FB 7E                   ld      A,(HL)          ; Get character
4710+ 31FC FE 30                cp      '0'             ; '0' character?
4711+ 31FE CA FA 31             jp      Z,SUPTLZ        ; Yes - Look back for more
4712+ 3201 FE 2E                cp      '.'             ; A decimal point?
4713+ 3203 C4 0F 30             call    NZ,INCHL        ; Move back over digit
4714+ 3206
4715+ 3206 F1           DOEBIT: pop     AF              ; Get 'E' flag
4716+ 3207 CA 25 32             jp      Z,NOENED        ; No 'E' needed - End buffer
4717+ 320A 36 45                ld      (HL),'E'        ; Put 'E' in buffer
4718+ 320C 23                   inc     HL              ; And move on
4719+ 320D 36 2B                ld      (HL),'+'        ; Put '+' in buffer
4720+ 320F F2 16 32             jp      P,OUTEXP        ; Positive - Output exponent
4721+ 3212 36 2D                ld      (HL),'-'        ; Put '-' in buffer
4722+ 3214 2F                   cpl                     ; Negate exponent
4723+ 3215 3C                   inc     A
4724+ 3216 06 2F        OUTEXP: ld      B,'0'-1         ; ASCII '0' - 1
4725+ 3218 04           EXPTEN: inc     B               ; Count subtractions
4726+ 3219 D6 0A                sub     $0A             ; Tens digit
4727+ 321B D2 18 32             jp      NC,EXPTEN       ; More to do
4728+ 321E C6 3A                add     A,'0'+10        ; Restore and make ASCII
4729+ 3220 23                   inc     HL              ; Move on
4730+ 3221 70                   ld      (HL),B          ; Save MSB of exponent
4731+ 3222 23           JSTZER: inc     HL              ;
4732+ 3223 77                   ld      (HL),A          ; Save LSB of exponent
4733+ 3224 23                   inc     HL
4734+ 3225 71           NOENED: ld      (HL),C          ; Mark end of buffer
4735+ 3226 E1                   pop     HL              ; Restore code string address
4736+ 3227 C9                   ret
4737+ 3228
4738+ 3228 01 74 94     RNGTST: ld      BC,$9474        ; BCDE = 999999.
4739+ 322B 11 F7 23             ld      DE,$23F7
4740+ 322E CD 34 30             call    CMPNUM          ; Compare numbers
4741+ 3231 B7                   or      A
4742+ 3232 E1                   pop     HL              ; Return address to HL
4743+ 3233 E2 90 31             jp      PO,GTSIXD       ; Too big - Divide by ten
4744+ 3236 E9                   jp      (HL)            ; Otherwise return to caller
4745+ 3237
4746+ 3237 00 00 00 80  HALF:   defb    $00,$00,$00,$80 ; 0.5
4747+ 323B
4748+ 323B A0 86 01     POWERS: defb    $A0,$86,$01  ; 100000
4749+ 323E 10 27 00             defb    $10,$27,$00  ;  10000
4750+ 3241 E8 03 00             defb    $E8,$03,$00  ;   1000
4751+ 3244 64 00 00             defb    $64,$00,$00  ;    100
4752+ 3247 0A 00 00             defb    $0A,$00,$00  ;     10
4753+ 324A 01 00 00             defb    $01,$00,$00  ;      1
4754+ 324D
4755+ 324D 21 E2 2F     NEGAFT: ld      HL,INVSGN       ; Negate result
4756+ 3250 E3                   ex      (SP),HL         ; To be done after caller
4757+ 3251 E9                   jp      (HL)            ; Return to caller
4758+ 3252
4759+ 3252 CD EA 2F     SQR:    call    STAKFP          ; Put value on stack
4760+ 3255 21 37 32             ld      HL,HALF         ; Set power to 1/2
4761+ 3258 CD F7 2F             call    PHLTFP          ; Move 1/2 to FPREG
4762+ 325B
4763+ 325B C1           POWER:  pop     BC              ; Get base
4764+ 325C D1                   pop     DE
4765+ 325D CD B9 2F             call    TSTSGN          ; Test sign of power
4766+ 3260 78                   ld      A,B             ; Get exponent of base
4767+ 3261 CA A0 32             jp      Z,EXP           ; Make result 1 if zero
4768+ 3264 F2 6B 32             jp      P,POWER1        ; Positive base - Ok
4769+ 3267 B7                   or      A               ; Zero to negative power?
4770+ 3268 CA D5 17             jp      Z,DZERR         ; Yes - ?/0 Error
4771+ 326B B7           POWER1: or      A               ; Base zero?
4772+ 326C CA 89 2D             jp      Z,SAVEXP        ; Yes - Return zero
4773+ 326F D5                   push    DE              ; Save base
4774+ 3270 C5                   push    BC
4775+ 3271 79                   ld      A,C             ; Get MSB of base
4776+ 3272 F6 7F                or      %01111111       ; Get sign status
4777+ 3274 CD 05 30             call    BCDEFP          ; Move power to BCDE
4778+ 3277 F2 88 32             jp      P,POWER2        ; Positive base - Ok
4779+ 327A D5                   push    DE              ; Save power
4780+ 327B C5                   push    BC
4781+ 327C CD 8C 30             call    INT             ; Get integer of power
4782+ 327F C1                   pop     BC              ; Restore power
4783+ 3280 D1                   pop     DE
4784+ 3281 F5                   push    AF              ; MSB of base
4785+ 3282 CD 34 30             call    CMPNUM          ; Power an integer?
4786+ 3285 E1                   pop     HL              ; Restore MSB of base
4787+ 3286 7C                   ld      A,H             ; but don't affect flags
4788+ 3287 1F                   rra                     ; Exponent odd or even?
4789+ 3288 E1           POWER2: pop     HL              ; Restore MSB and exponent
4790+ 3289 22 96 55             ld      (FPREG+2),HL    ; Save base in FPREG
4791+ 328C E1                   pop     HL              ; LSBs of base
4792+ 328D 22 94 55             ld      (FPREG),HL      ; Save in FPREG
4793+ 3290 DC 4D 32             call    C,NEGAFT        ; Odd power - Negate result
4794+ 3293 CC E2 2F             call    Z,INVSGN        ; Negative base - Negate it
4795+ 3296 D5                   push    DE              ; Save power
4796+ 3297 C5                   push    BC
4797+ 3298 CD 1C 2E             call    LOG             ; Get LOG of base
4798+ 329B C1                   pop     BC              ; Restore power
4799+ 329C D1                   pop     DE
4800+ 329D CD 5D 2E             call    FPMULT          ; Multiply LOG by power
4801+ 32A0
4802+ 32A0 CD EA 2F     EXP:    call    STAKFP          ; Put value on stack
4803+ 32A3 01 38 81             ld      BC,$8138        ; BCDE = 1/Ln(2)
4804+ 32A6 11 3B AA             ld      DE,$AA3B
4805+ 32A9 CD 5D 2E             call    FPMULT          ; Multiply value by 1/LN(2)
4806+ 32AC 3A 97 55             ld      A,(FPEXP)       ; Get exponent
4807+ 32AF FE 88                cp      $80+8           ; Is it in range?
4808+ 32B1 D2 95 2F             jp      NC,OVTST1       ; No - Test for overflow
4809+ 32B4 CD 8C 30             call    INT             ; Get INT of FPREG
4810+ 32B7 C6 80                add     A,$80           ; For excess 128
4811+ 32B9 C6 02                add     A,$02           ; Exponent > 126?
4812+ 32BB DA 95 2F             jp      C,OVTST1        ; Yes - Test for overflow
4813+ 32BE F5                   push    AF              ; Save scaling factor
4814+ 32BF 21 0B 2E             ld      HL,UNITY        ; Point to 1.
4815+ 32C2 CD 13 2D             call    ADDPHL          ; Add 1 to FPREG
4816+ 32C5 CD 54 2E             call    MULLN2          ; Multiply by LN(2)
4817+ 32C8 F1                   pop     AF              ; Restore scaling factor
4818+ 32C9 C1                   pop     BC              ; Restore exponent
4819+ 32CA D1                   pop     DE
4820+ 32CB F5                   push    AF              ; Save scaling factor
4821+ 32CC CD 1F 2D             call    SUBCDE          ; Subtract exponent from FPREG
4822+ 32CF CD E2 2F             call    INVSGN          ; Negate result
4823+ 32D2 21 E0 32             ld      HL,EXPTAB       ; Coefficient table
4824+ 32D5 CD 10 33             call    SMSER1          ; Sum the series
4825+ 32D8 11 00 00             ld      DE,$0000        ; Zero LSBs
4826+ 32DB C1                   pop     BC              ; Scaling factor
4827+ 32DC 4A                   ld      C,D             ; Zero MSB
4828+ 32DD C3 5D 2E             jp      FPMULT          ; Scale result to correct value
4829+ 32E0
4830+ 32E0 08           EXPTAB: defb    $08             ; Table used by EXP
4831+ 32E1 40 2E 94 74          defb    $40,$2E,$94,$74 ; -1/7! (-1/5040)
4832+ 32E5 70 4F 2E 77          defb    $70,$4F,$2E,$77 ;  1/6! ( 1/720)
4833+ 32E9 6E 02 88 7A          defb    $6E,$02,$88,$7A ; -1/5! (-1/120)
4834+ 32ED E6 A0 2A 7C          defb    $E6,$A0,$2A,$7C ;  1/4! ( 1/24)
4835+ 32F1 50 AA AA 7E          defb    $50,$AA,$AA,$7E ; -1/3! (-1/6)
4836+ 32F5 FF FF 7F 7F          defb    $FF,$FF,$7F,$7F ;  1/2! ( 1/2)
4837+ 32F9 00 00 80 81          defb    $00,$00,$80,$81 ; -1/1! (-1/1)
4838+ 32FD 00 00 00 81          defb    $00,$00,$00,$81 ;  1/0! ( 1/1)
4839+ 3301
4840+ 3301 CD EA 2F     SUMSER: call    STAKFP          ; Put FPREG on stack
4841+ 3304 11 5B 2E             ld      DE,MULT         ; Multiply by "X"
4842+ 3307 D5                   push    DE              ; To be done after
4843+ 3308 E5                   push    HL              ; Save address of table
4844+ 3309 CD 05 30             call    BCDEFP          ; Move FPREG to BCDE
4845+ 330C CD 5D 2E             call    FPMULT          ; Square the value
4846+ 330F E1                   pop     HL              ; Restore address of table
4847+ 3310 CD EA 2F     SMSER1: call    STAKFP          ; Put value on stack
4848+ 3313 7E                   ld      A,(HL)          ; Get number of coefficients
4849+ 3314 23                   inc     HL              ; Point to start of table
4850+ 3315 CD F7 2F             call    PHLTFP          ; Move coefficient to FPREG
4851+ 3318 06                   defb    06H             ; Skip "pop AF"
4852+ 3319 F1           SUMLP:  pop     AF              ; Restore count
4853+ 331A C1                   pop     BC              ; Restore number
4854+ 331B D1                   pop     DE
4855+ 331C 3D                   dec     A               ; Cont coefficients
4856+ 331D C8                   ret     Z               ; All done
4857+ 331E D5                   push    DE              ; Save number
4858+ 331F C5                   push    BC
4859+ 3320 F5                   push    AF              ; Save count
4860+ 3321 E5                   push    HL              ; Save address in table
4861+ 3322 CD 5D 2E             call    FPMULT          ; Multiply FPREG by BCDE
4862+ 3325 E1                   pop     HL              ; Restore address in table
4863+ 3326 CD 08 30             call    LOADFP          ; Number at HL to BCDE
4864+ 3329 E5                   push    HL              ; Save address in table
4865+ 332A CD 22 2D             call    FPADD           ; Add coefficient to FPREG
4866+ 332D E1                   pop     HL              ; Restore address in table
4867+ 332E C3 19 33             jp      SUMLP           ; More coefficients
4868+ 3331
4869+ 3331
4870+ 3331              ; random number generator
4871+ 3331              ; a negative argument is used as a seed for the RNG
4872+ 3331              ; 0 is used to repeat the last random number
4873+ 3331              ; a positive argument generates a new random number
4874+ 3331 CD B9 2F     RND:    call    TSTSGN          ; Test sign of FPREG
4875+ 3334 21 B8 53             ld      HL,SEED+2       ; Random number seed
4876+ 3337 FA 92 33             jp      M,RESEED        ; Negative - Re-seed
4877+ 333A 21 D9 53             ld      HL,LSTRND       ; Last random number
4878+ 333D CD F7 2F             call    PHLTFP          ; Move last RND to FPREG
4879+ 3340 21 B8 53             ld      HL,SEED+2       ; Random number seed
4880+ 3343 C8                   ret     Z               ; Return if RND(0)
4881+ 3344 86                   add     A,(HL)          ; Add (SEED+2)
4882+ 3345 E6 07                and     %00000111       ; 0 to 7
4883+ 3347 06 00                ld      B,$00
4884+ 3349 77                   ld      (HL),A          ; Re-save seed
4885+ 334A 23                   inc     HL              ; Move to coefficient table
4886+ 334B 87                   add     A,A             ; 4 bytes
4887+ 334C 87                   add     A,A             ; per entry
4888+ 334D 4F                   ld      C,A             ; BC = Offset into table
4889+ 334E 09                   add     HL,BC           ; Point to coefficient
4890+ 334F CD 08 30             call    LOADFP          ; Coefficient to BCDE
4891+ 3352 CD 5D 2E             call    FPMULT          ; Multiply FPREG by coefficient
4892+ 3355 3A B7 53             ld      A,(SEED+1)      ; Get (SEED+1)
4893+ 3358 3C                   inc     A               ; Add 1
4894+ 3359 E6 03                and     %00000011       ; 0 to 3
4895+ 335B 06 00                ld      B,$00
4896+ 335D FE 01                cp      $01             ; Is it zero?
4897+ 335F 88                   adc     A,B             ; Yes - Make it 1
4898+ 3360 32 B7 53             ld      (SEED+1),A      ; Re-save seed
4899+ 3363 21 96 33             ld      HL,RNDTAB-4     ; Addition table
4900+ 3366 87                   add     A,A             ; 4 bytes
4901+ 3367 87                   add     A,A             ; per entry
4902+ 3368 4F                   ld      C,A             ; BC = Offset into table
4903+ 3369 09                   add     HL,BC           ; Point to value
4904+ 336A CD 13 2D             call    ADDPHL          ; Add value to FPREG
4905+ 336D CD 05 30     RND1:   call    BCDEFP          ; Move FPREG to BCDE
4906+ 3370 7B                   ld      A,E             ; Get LSB
4907+ 3371 59                   ld      E,C             ; LSB = MSB
4908+ 3372 EE 4F                xor     %01001111       ; Fiddle around
4909+ 3374 4F                   ld      C,A             ; New MSB
4910+ 3375 36 80                ld      (HL),$80        ; Set exponent
4911+ 3377 2B                   dec     HL              ; Point to MSB
4912+ 3378 46                   ld      B,(HL)          ; Get MSB
4913+ 3379 36 80                ld      (HL),$80        ; Make value -0.5
4914+ 337B 21 B6 53             ld      HL,SEED         ; Random number seed
4915+ 337E 34                   inc     (HL)            ; Count seed
4916+ 337F 7E                   ld      A,(HL)          ; Get seed
4917+ 3380 D6 AB                sub     $AB             ; Do it modulo 171
4918+ 3382 C2 89 33             jp      NZ,RND2         ; Non-zero - Ok
4919+ 3385 77                   ld      (HL),A          ; Zero seed
4920+ 3386 0C                   inc     C               ; Fillde about
4921+ 3387 15                   dec     D               ; with the
4922+ 3388 1C                   inc     E               ; number
4923+ 3389 CD 73 2D     RND2:   call    BNORM           ; Normalise number
4924+ 338C 21 D9 53             ld      HL,LSTRND       ; Save random number
4925+ 338F C3 11 30             jp      FPTHL           ; Move FPREG to last and return
4926+ 3392
4927+ 3392 77           RESEED: ld      (HL),A          ; Re-seed random numbers
4928+ 3393 2B                   dec     HL
4929+ 3394 77                   ld      (HL),A
4930+ 3395 2B                   dec     HL
4931+ 3396 77                   ld      (HL),A
4932+ 3397 C3 6D 33             jp      RND1            ; Return RND seed
4933+ 339A
4934+ 339A 68 B1 46 68  RNDTAB: defb    $68,$B1,$46,$68 ; Table used by RND
4935+ 339E 99 E9 92 69          defb    $99,$E9,$92,$69
4936+ 33A2 10 D1 75 68          defb    $10,$D1,$75,$68
4937+ 33A6
4938+ 33A6              ; COS and SIN functions
4939+ 33A6 21 F0 33     COS:    ld      HL,HALFPI       ; Point to PI/2
4940+ 33A9 CD 13 2D             call    ADDPHL          ; Add it to PPREG
4941+ 33AC CD EA 2F     SIN:    call    STAKFP          ; Put angle on stack
4942+ 33AF 01 49 83             ld      BC,$8349        ; BCDE = 2 PI
4943+ 33B2 11 DB 0F             ld      DE,$0FDB
4944+ 33B5 CD FA 2F             call    FPBCDE          ; Move 2 PI to FPREG
4945+ 33B8 C1                   pop     BC              ; Restore angle
4946+ 33B9 D1                   pop     DE
4947+ 33BA CD 0F 2F             call    DVBCDE          ; Divide angle by 2 PI
4948+ 33BD CD EA 2F             call    STAKFP          ; Put it on stack
4949+ 33C0 CD 8C 30             call    INT             ; Get INT of result
4950+ 33C3 C1                   pop     BC              ; Restore number
4951+ 33C4 D1                   pop     DE
4952+ 33C5 CD 1F 2D             call    SUBCDE          ; Make it 0 <= value < 1
4953+ 33C8 21 F4 33             ld      HL,QUARTR       ; Point to 0.25
4954+ 33CB CD 19 2D             call    SUBPHL          ; Subtract value from 0.25
4955+ 33CE CD B9 2F             call    TSTSGN          ; Test sign of value
4956+ 33D1 37                   scf                     ; Flag positive
4957+ 33D2 F2 DC 33             jp      P,SIN1          ; Positive - Ok
4958+ 33D5 CD 10 2D             call    ROUND           ; Add 0.5 to value
4959+ 33D8 CD B9 2F             call    TSTSGN          ; Test sign of value
4960+ 33DB B7                   or      A               ; Flag negative
4961+ 33DC F5           SIN1:   push    AF              ; Save sign
4962+ 33DD F4 E2 2F             call    P,INVSGN        ; Negate value if positive
4963+ 33E0 21 F4 33             ld      HL,QUARTR       ; Point to 0.25
4964+ 33E3 CD 13 2D             call    ADDPHL          ; Add 0.25 to value
4965+ 33E6 F1                   pop     AF              ; Restore sign
4966+ 33E7 D4 E2 2F             call    NC,INVSGN       ; Negative - Make positive
4967+ 33EA 21 F8 33             ld      HL,SINTAB       ; Coefficient table
4968+ 33ED C3 01 33             jp      SUMSER          ; Evaluate sum of series
4969+ 33F0
4970+ 33F0 DB 0F 49 81  HALFPI: defb    $DB,$0F,$49,$81 ; 1.5708 (PI/2)
4971+ 33F4
4972+ 33F4 00 00 00 7F  QUARTR: defb    $00,$00,$00,$7F ; 0.25
4973+ 33F8
4974+ 33F8 05           SINTAB: defb    $05             ; Table used by SIN
4975+ 33F9 BA D7 1E 86          defb    $BA,$D7,$1E,$86 ; 39.711
4976+ 33FD 64 26 99 87          defb    $64,$26,$99,$87 ;-76.575
4977+ 3401 58 34 23 87          defb    $58,$34,$23,$87 ; 81.602
4978+ 3405 E0 5D A5 86          defb    $E0,$5D,$A5,$86 ;-41.342
4979+ 3409 DA 0F 49 83          defb    $DA,$0F,$49,$83 ;  6.2832
4980+ 340D
4981+ 340D CD EA 2F     TAN:    call    STAKFP          ; Put angle on stack
4982+ 3410 CD AC 33             call    SIN             ; Get SIN of angle
4983+ 3413 C1                   pop     BC              ; Restore angle
4984+ 3414 E1                   pop     HL
4985+ 3415 CD EA 2F             call    STAKFP          ; Save SIN of angle
4986+ 3418 EB                   ex      DE,HL           ; BCDE = Angle
4987+ 3419 CD FA 2F             call    FPBCDE          ; Angle to FPREG
4988+ 341C CD A6 33             call    COS             ; Get COS of angle
4989+ 341F C3 0D 2F             jp      DIV             ; TAN = SIN / COS
4990+ 3422
4991+ 3422 CD B9 2F     ATN:    call    TSTSGN          ; Test sign of value
4992+ 3425 FC 4D 32             call    M,NEGAFT        ; Negate result after if -ve
4993+ 3428 FC E2 2F             call    M,INVSGN        ; Negate value if -ve
4994+ 342B 3A 97 55             ld      A,(FPEXP)       ; Get exponent
4995+ 342E FE 81                cp      81H             ; Number less than 1?
4996+ 3430 DA 3F 34             jp      C,ATN1          ; Yes - Get arc tangnt
4997+ 3433 01 00 81             ld      BC,$8100        ; BCDE = 1
4998+ 3436 51                   ld      D,C
4999+ 3437 59                   ld      E,C
5000+ 3438 CD 0F 2F             call    DVBCDE          ; Get reciprocal of number
5001+ 343B 21 19 2D             ld      HL,SUBPHL       ; Sub angle from PI/2
5002+ 343E E5                   push    HL              ; Save for angle > 1
5003+ 343F 21 49 34     ATN1:   ld      HL,ATNTAB       ; Coefficient table
5004+ 3442 CD 01 33             call    SUMSER          ; Evaluate sum of series
5005+ 3445 21 F0 33             ld      HL,HALFPI       ; PI/2 - angle in case > 1
5006+ 3448 C9                   ret                     ; Number > 1 - Sub from PI/2
5007+ 3449
5008+ 3449 09           ATNTAB: defb    $09             ; Table used by ATN
5009+ 344A 4A D7 3B 78          defb    $4A,$D7,$3B,$78 ; 1/17
5010+ 344E 02 6E 84 7B          defb    $02,$6E,$84,$7B ;-1/15
5011+ 3452 FE C1 2F 7C          defb    $FE,$C1,$2F,$7C ; 1/13
5012+ 3456 74 31 9A 7D          defb    $74,$31,$9A,$7D ;-1/11
5013+ 345A 84 3D 5A 7D          defb    $84,$3D,$5A,$7D ; 1/9
5014+ 345E C8 7F 91 7E          defb    $C8,$7F,$91,$7E ;-1/7
5015+ 3462 E4 BB 4C 7E          defb    $E4,$BB,$4C,$7E ; 1/5
5016+ 3466 6C AA AA 7F          defb    $6C,$AA,$AA,$7F ;-1/3
5017+ 346A 00 00 00 81          defb    $00,$00,$00,$81 ; 1/1
5018+ 346E
5019+ 346E
5020+ 346E C9           ARET:   ret                     ; A RETurn instruction
5021+ 346F
5022+ 346F D7           GETINP: rst     $10             ; input a character
5023+ 3470 C9                   ret
5024+ 3471
5025+ 3471 E5           CLS:    push    HL
5026+ 3472 D5                   push    DE
5027+ 3473 3A 32 55             ld      A,(SCR_MODE)    ; check screen mode
5028+ 3476 FE 02                cp      $02             ; G2 mode?
5029+ 3478 CC DB 05             call    Z,EMPTYVIDBUF   ; yes, reset video buffer
5030+ 347B D1                   pop     DE
5031+ 347C E1                   pop     HL
5032+ 347D 3E 0C                ld      A,CS            ; ASCII Clear screen
5033+ 347F CD 10 1B             call    SND2VID         ; send to screen
5034+ 3482 C3 CB 40             jp      MONOUT          ; Output character
5035+ 3485
5036+ 3485 CD 32 2A     WIDTH:  call    GETINT          ; Get integer 0-255
5037+ 3488 7B                   ld      A,E             ; Width to A
5038+ 3489 32 E0 53             ld      (LWIDTH),A      ; Set width
5039+ 348C C9                   ret
5040+ 348D
5041+ 348D
5042+ 348D              ; read a word (2 bytes) from a couple of RAM locations, in little-endian format
5043+ 348D              ; i.e., the first location is the LSB, while the second one is the MSB
5044+ 348D CD D1 1D     DEEK:   call    DEINT           ; Get integer -32768 to 32767
5045+ 3490 D5                   push    DE              ; Save number
5046+ 3491 E1                   pop     HL              ; Number to HL
5047+ 3492 46           RECWRD: ld      B,(HL)          ; Get LSB of contents
5048+ 3493 23                   inc     HL
5049+ 3494 7E                   ld      A,(HL)          ; Get MSB of contents
5050+ 3495 C3 96 25             jp      ABPASS          ; Return integer AB
5051+ 3498
5052+ 3498              ; write a word (2 bytes) into a couple of RAM locations, in little-endian format
5053+ 3498              ; i.e., the LSB will go into the first location, while the MSB into the second one
5054+ 3498 CD AC 21     DOKE:   call    GETNUM          ; Get a number
5055+ 349B CD D1 1D             call    DEINT           ; Get integer -32768 to 32767
5056+ 349E D5                   push    DE              ; Save address
5057+ 349F CD D2 1A             call    CHKSYN          ; Make sure ',' follows
5058+ 34A2 2C                   defb    ','
5059+ 34A3 CD AC 21             call    GETNUM          ; Get a number
5060+ 34A6 CD D1 1D             call    DEINT           ; Get integer -32768 to 32767
5061+ 34A9 E3                   ex      (SP),HL         ; Save value,get address
5062+ 34AA 73                   ld      (HL),E          ; Save LSB of value
5063+ 34AB 23                   inc     HL
5064+ 34AC 72                   ld      (HL),D          ; Save MSB of value
5065+ 34AD E1                   pop     HL              ; Restore code string address
5066+ 34AE C9                   ret
5067+ 34AF
5068+ 34AF              ; stop the execution of code for a certain bit of time. The pause
5069+ 34AF              ; is between $0000 and $FFFF 100ths of a second (0~655.5 secs)
5070+ 34AF CD AC 21     PAUSE:  call    GETNUM          ; Get a number
5071+ 34B2 CD D1 1D             call    DEINT           ; Get integer -32768 to 32767
5072+ 34B5 7A                   ld      A,D             ; load D into A
5073+ 34B6 B3                   or      E               ; are D & E equal to $00?
5074+ 34B7 C8                   ret     Z               ; if yes, then return
5075+ 34B8 C5           DIR_PAU:push    BC              ; store BC
5076+ 34B9 3A 20 55             ld      A,(TMRCNT)      ; Load current value of system timer
5077+ 34BC 47                   ld      B,A             ; move it into B
5078+ 34BD CD 46 1D     RPTPS:  call    TSTBRK          ; Test for break key
5079+ 34C0 3A 20 55             ld      A,(TMRCNT)      ; Load current value of system timer
5080+ 34C3 B8                   cp      B               ; is it the same value?
5081+ 34C4 28 F7                jr      Z,RPTPS         ; yes, so read again
5082+ 34C6 47                   ld      B,A             ; no, so store the new value
5083+ 34C7 1B                   dec     DE              ; decrement interval
5084+ 34C8 7A                   ld      A,D             ; load D into A
5085+ 34C9 B3                   or      E               ; check if DE is equal to 0 (if D & e are $00 then result is 0)
5086+ 34CA 20 F1                jr      NZ,RPTPS        ; no, repeat
5087+ 34CC C1                   pop     BC              ; yes, recover BC and continue
5088+ 34CD C9                   ret
5089+ 34CE
5090+ 34CE              ; change the screen mode and set some graphic features. Usage: SCREEN X[,Y][,Z]
5091+ 34CE              ; where X is graphic mode:
5092+ 34CE              ; 0=text mode (40x24), 1=graphic mode 1 (32x24 chars); 2=graphic mode 2 (256x192 pixels);
5093+ 34CE              ; 3=multicolor mode (64x48 pixels); 4=extended graphic mode 2 (32x24 chars mixed between G1 and G2)
5094+ 34CE              ; Y is: 0=8x8 sprites, 1=16x16 sprites
5095+ 34CE              ; Z is: 0=no sprite magnification; 1=sprite magnification x2 (8x8=>16x16, and 16x16=32x32)
5096+ 34CE              ; (the latters are accepted only in graphic modes G1, G2, G3, and G4)
5097+ 34CE AF           SCREEN: xor     A
5098+ 34CF 32 42 55             ld      (TMPBFR2),A     ; sprite size & magnif. byte set to 0
5099+ 34D2 CD 32 2A             call    GETINT          ; Get integer 0-255
5100+ 34D5 FE 05                cp      $05             ; is it a valid mode (0~4)?
5101+ 34D7 D2 E6 1D             jp      NC,FCERR        ; No - Illegal function call Error
5102+ 34DA 32 40 55             ld      (TMPBFR1),A     ; store graphic mode
5103+ 34DD A7                   and     A               ; is it 0 (text mode)?
5104+ 34DE CA FA 34             jp      Z,SCVDP         ; yes, ignore other arguments and set mode immediately
5105+ 34E1 CD 39 35     SETVDP: call    CHKSCAR         ; no, check if sprite size follows
5106+ 34E4 DA EC 34             jp      C,CKMAGN        ; no (set to 0 or missing), so jump over
5107+ 34E7 3E 02                ld      A,$02           ; no, so set sprite size
5108+ 34E9 32 42 55             ld      (TMPBFR2),A     ; ...to 16x16
5109+ 34EC CD 39 35     CKMAGN: call    CHKSCAR         ; check if sprite magnification follows
5110+ 34EF DA FA 34             jp      C,SCVDP         ; no (set to 0 or missing), so jump over
5111+ 34F2 3A 42 55             ld      A,(TMPBFR2)     ; yes, so retrieve sprite attributes...
5112+ 34F5 F6 01                or      $01             ; ...set sprite magnification to 2x...
5113+ 34F7 32 42 55             ld      (TMPBFR2),A     ; ...and save flags again
5114+ 34FA F3           SCVDP:  di                      ; disable INTs
5115+ 34FB D5                   push    DE              ; store DE
5116+ 34FC E5                   push    HL              ; store HL
5117+ 34FD 3A 40 55             ld      A,(TMPBFR1)     ; recover graphic mode
5118+ 3500 5F                   ld      E,A             ; and store it into E
5119+ 3501 3A 42 55             ld      A,(TMPBFR2)     ; recover sprite flags
5120+ 3504 57                   ld      D,A             ; and store them into D
5121+ 3505 D5                   push    DE              ; store D & E
5122+ 3506 CD D1 03             call    initVDP         ; initialize VDP with mode pointed by E
5123+ 3509 D1                   pop     DE              ; retrieve D & E
5124+ 350A 7B                   ld      A,E             ; move graphic mode into A
5125+ 350B 87                   add     A,A
5126+ 350C 87                   add     A,A
5127+ 350D 87                   add     A,A             ; multiply A times 8 to get offset of graphic mode
5128+ 350E 5F                   ld      E,A             ; and pass it into E
5129+ 350F D5                   push    DE              ; store sprite flags in E
5130+ 3510 16 00                ld      D,$00           ; reset D
5131+ 3512 21 23 0B             ld      HL,VDPMODESET+1 ; load address of VDP settings for reg#1
5132+ 3515 19                   add     HL,DE           ; load correct reg#1 setting
5133+ 3516 D1                   pop     DE              ; retrieve sprite flags from E
5134+ 3517 7E                   ld      A,(HL)          ; load reg#1 setting
5135+ 3518 E6 FC                and     %11111100       ; reset size & magn. bits
5136+ 351A B2                   or      D               ; set size & magn. bits
5137+ 351B 5F                   ld      E,A             ; value into E
5138+ 351C 3E 01                ld      A,$01           ; reg #1
5139+ 351E CD B3 06             call    WRITE_VREG      ; send setting to reg #1
5140+ 3521 2A ED 53             ld      HL,(LINEAT)     ; Get current line number
5141+ 3524 23                   inc     HL              ; -1 means direct statement
5142+ 3525 7C                   ld      A,H
5143+ 3526 B5                   or      L
5144+ 3527 CC 26 09             call    Z,CURSOR_ON     ; enable cursor if not in program mode
5145+ 352A FB                   ei                      ; re-enable interrupts
5146+ 352B E1                   pop     HL              ; restore HL
5147+ 352C D1                   pop     DE              ; restore DE
5148+ 352D 3A 31 55             ld      A,(SCR_SIZE_H)  ; check the screen mode by looking at the screen height
5149+ 3530 FE 30                cp      $30             ; is it 48 chars or 192 pixels (MC and G2 modes)?
5150+ 3532 D0                   ret     NC              ; yes, so exit (in graphics 2 and multicolor no print-on-video)
5151+ 3533 3E 01                ld      A,$01           ; no (we are in Text, G1 or ExG2), so activate the...
5152+ 3535 32 3C 55             ld      (PRNTVIDEO),A   ; ...video buffer...
5153+ 3538 C9                   ret                     ; ...and return to caller
5154+ 3539
5155+ 3539              ; check an additional argument for SCREEN - There are 2 ways of working:
5156+ 3539              ; to check if something follows: Carry is 1 is no argument follows, 0 otherwise
5157+ 3539              ; to check the value of the following argument: 0 is argument is 1, 1 is argument is <> 1
5158+ 3539 2B           CHKSCAR:dec     HL              ; dec 'cos GETCHR INCs
5159+ 353A CD 1B 1D             call    GETCHR          ; Get next character
5160+ 353D 37                   scf                     ; set carry flag
5161+ 353E C8                   ret     Z               ; return if nothing follows with Carry=1
5162+ 353F CD D2 1A             call    CHKSYN          ; Make sure ',' follows
5163+ 3542 2C                   defb    ','
5164+ 3543 CD 32 2A             call    GETINT          ; get value
5165+ 3546 1F                   rra                     ; Carry=bit #0
5166+ 3547 3F                   ccf                     ; invert Carry, so Carry=0 if arg. is 1, and Carry=1 otherwise (arg<>1)
5167+ 3548 C9                   ret                     ; return
5168+ 3549
5169+ 3549
5170+ 3549              ; change the colors of the screen - Syntax is COLOR a,b,c where:
5171+ 3549              ; a=foreground color / b=background color / c=border color
5172+ 3549              ; a,b,c must be in a range between 1 and 15 (0 is transparent and it's not supported)
5173+ 3549              ; the number of arguments is based on the current screen mode
5174+ 3549 CD 32 2A     COLOR:  call    GETINT          ; get first value
5175+ 354C CD F1 35             call    CHKCLR1         ; check if it's in range 1~15
5176+ 354F 32 40 55             ld      (TMPBFR1),A     ; store it
5177+ 3552 3A 32 55             ld      A,(SCR_MODE)    ; check screen mode
5178+ 3555 FE 03                cp      $03             ; is it multicolor mode?
5179+ 3557 20 0D                jr      NZ,CNTCKCL      ; no, continue
5180+ 3559 3E 0F                ld      A,$0F           ; white for...
5181+ 355B 32 3E 55             ld      (FRGNDCLR),A    ; ...foreground (even it's not used in MC)
5182+ 355E 3A 40 55             ld      A,(TMPBFR1)     ; yes, so we stop here because in MC mode we just support border color
5183+ 3561 32 44 55             ld      (TMPBFR3),A     ; move color into temp buffer 3
5184+ 3564 18 31                jr      CLRMC           ; jump to set color
5185+ 3566 CD D2 1A     CNTCKCL:call    CHKSYN          ; Make sure ',' follows
5186+ 3569 2C                   defb    ','
5187+ 356A CD 32 2A             call    GETINT          ; get second value
5188+ 356D CD F1 35             call    CHKCLR1         ; check if it's in range 1~15
5189+ 3570 32 42 55             ld      (TMPBFR2),A     ; store it
5190+ 3573 3A 32 55             ld      A,(SCR_MODE)    ; check screen mode
5191+ 3576 A7                   and     A               ; is it text mode?
5192+ 3577 28 1B                jr      Z,CLRTXT        ; yes, stop here because in text mode, background and border colors coincide
5193+ 3579 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
5194+ 357C 2C                   defb    ','
5195+ 357D CD 32 2A             call    GETINT          ; get third value
5196+ 3580 CD F1 35             call    CHKCLR1         ; check if it's in range 1~15
5197+ 3583 32 44 55             ld      (TMPBFR3),A     ; store it
5198+ 3586 D5                   push    DE              ; store DE
5199+ 3587 3A 32 55             ld      A,(SCR_MODE)    ; check screen mode
5200+ 358A FE 01                cp      $01             ; is it G1 mode?
5201+ 358C 28 10                jr      Z,CLRG1         ; yes, jump over
5202+ 358E FE 02                cp      $02             ; is it G2 mode?
5203+ 3590 28 15                jr      Z,CLRG2         ; yes, jump over
5204+ 3592 18 1C                jr      CLREX2          ; last case can only be ExG2
5205+ 3594 CD E4 35     CLRTXT: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5206+ 3597 32 44 55     CLRMC:  ld      (TMPBFR3),A     ; store color settings (for MC mode, we only set border color)
5207+ 359A D5                   push    DE              ; store DE
5208+ 359B F3                   di                      ; disable INTs
5209+ 359C 18 2D                jr      SETBRCL         ; set colors and exit
5210+ 359E CD E4 35     CLRG1:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5211+ 35A1 16 01                ld      D,$01           ; repeat 1 time
5212+ 35A3 06 20                ld      B,$20           ; 32 bytes of colors
5213+ 35A5 18 10                jr      LOADCLR         ; load colors
5214+ 35A7 CD E4 35     CLRG2:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5215+ 35AA 16 18                ld      D,$18           ; 18 pages of...
5216+ 35AC 06 00                ld      B,$00           ; ...256 bytes each
5217+ 35AE 18 07                jr      LOADCLR         ; load colors
5218+ 35B0 CD E4 35     CLREX2: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5219+ 35B3 16 08                ld      D,$08           ; 8 pages of...
5220+ 35B5 06 00                ld      B,$00           ; ...256 bytes each
5221+ 35B7 E5           LOADCLR:push    HL              ; store HL
5222+ 35B8 21 00 20             ld      HL,$2000        ; color table start: $2000
5223+ 35BB F3                   di                      ; disable INTs
5224+ 35BC CD 69 06             call    SETVDPADRS
5225+ 35BF 0D                   dec     C               ; VDP data mode
5226+ 35C0 ED 79        RPTLDCL:out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
5227+ 35C2 00                   nop
5228+ 35C3 00                   nop
5229+ 35C4 10 FA                djnz    RPTLDCL         ; repeat for 256 bytes (1 page)
5230+ 35C6 15                   dec     D               ; did we fill up all the pages?
5231+ 35C7 20 F7                jr      NZ,RPTLDCL      ; no, repeat
5232+ 35C9 FB                   ei
5233+ 35CA E1                   pop     HL              ; retrieve HL
5234+ 35CB 3A 40 55     SETBRCL:ld      A,(TMPBFR1)     ; retrieve foreground color
5235+ 35CE 32 3E 55             ld      (FRGNDCLR),A    ; store it
5236+ 35D1 3A 42 55             ld      A,(TMPBFR2)     ; retrieve background color
5237+ 35D4 32 3F 55             ld      (BKGNDCLR),A    ; store it
5238+ 35D7 3A 44 55             ld      A,(TMPBFR3)     ; recover border color
5239+ 35DA 5F                   ld      E,A             ; move it into E
5240+ 35DB 3E 07                ld      A,$07           ; set VDP register 7
5241+ 35DD F3                   di
5242+ 35DE CD B3 06             call    WRITE_VREG      ; send value to VDP: set border color
5243+ 35E1 FB                   ei                      ; re-enable INTs
5244+ 35E2 D1                   pop     DE              ; retrieve DE
5245+ 35E3 C9                   ret                     ; return to caller
5246+ 35E4
5247+ 35E4
5248+ 35E4              ; mix 2 color nibbles in 1 byte
5249+ 35E4 3A 42 55     MIXCLRS:ld      A,(TMPBFR2)     ; retrieve background color
5250+ 35E7 47                   ld      B,A             ; move it into B
5251+ 35E8 3A 40 55             ld      A,(TMPBFR1)     ; retrieve foreground color
5252+ 35EB 87                   add     A,A             ; move foreground color into the high nibble of A
5253+ 35EC 87                   add     A,A
5254+ 35ED 87                   add     A,A
5255+ 35EE 87                   add     A,A
5256+ 35EF B0                   or      B               ; put background color into the low nibble of A
5257+ 35F0 C9                   ret                     ; return to caller
5258+ 35F1
5259+ 35F1
5260+ 35F1              ; check if the color is not 0 and into the range 1~15
5261+ 35F1 A7           CHKCLR1:and     A               ; is it 0?
5262+ 35F2 CA D2 17             jp      Z,SNERR         ; yes, raise a SN error
5263+ 35F5 FE 10        CHKCLR0:cp      $10             ; is it in range 0~15?
5264+ 35F7 D2 D2 17             jp      NC,SNERR        ; no, raise a SN error
5265+ 35FA C9                   ret                     ; param is OK, can return
5266+ 35FB
5267+ 35FB
5268+ 35FB              ; check if in graphics 2 mode
5269+ 35FB 3A 32 55     CHKG2M: ld      A,(SCR_MODE)    ; check screen mode
5270+ 35FE FE 02                cp      $02             ; actually, we can paint only in G2
5271+ 3600 C2 09 3C             jp      NZ,GMERR        ; no G2, print a No Graphics Mode Error
5272+ 3603 C9                   ret                     ; return to caller
5273+ 3604
5274+ 3604
5275+ 3604              ; print a text in screen 2
5276+ 3604              ; GPRINT text,x,y[,fc[,bc]]
5277+ 3604              ; where "text" is an expression that can be converted into a sequence of ASCII chars,
5278+ 3604              ; x & y are the coordinates (0<=x<=31, 0<=y<=23), fc & bc are foreground and background
5279+ 3604              ; colors (1~15), resp.
5280+ 3604              ; (portions of code are from nippur72)
5281+ 3604              GX      equ     TMPBFR3
5282+ 3604              GY      equ     TMPBFR4
5283+ 3604              TMPCLR  equ     TMPBFR2
5284+ 3604              MIXCOL  equ     TMPBFR1
5285+ 3604              TMPADR  equ     VIDEOBUFF
5286+ 3604              CHRPNT  equ     VIDEOBUFF+$02
5287+ 3604              NUMCHR  equ     VIDEOBUFF+$04
5288+ 3604              TMPHL   equ     VIDEOBUFF+$06
5289+ 3604 CD FB 35     GPRINT: call    CHKG2M          ; check if in graphic mode 2
5290+ 3607 2B                   dec     HL              ; dec 'cos GETCHR INCs
5291+ 3608 CD 1B 1D             call    GETCHR          ; check if something follows
5292+ 360B CA D2 17             jp      Z,SNERR         ; if nothing else, raise a syntax error
5293+ 360E 22 48 55             ld      (TMPADR),HL     ; save current code string pointer
5294+ 3611 CD BE 21             call    EVAL            ; Evaluate expression
5295+ 3614 CD B0 21             call    TSTSTR          ; Make sure it's a string
5296+ 3617 22 4E 55             ld      (TMPHL),HL      ; store code string pointer
5297+ 361A CD F7 27             call    GSTRCU          ; Current string to pool
5298+ 361D CD 08 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
5299+ 3620 ED 43 4A 55          ld      (CHRPNT),BC     ; store string pointer
5300+ 3624 ED 53 4C 55          ld      (NUMCHR),DE     ; store string lenght
5301+ 3628 2A 4E 55             ld      HL,(TMPHL)      ; restore code string pointer
5302+ 362B CD D2 1A             call    CHKSYN          ; Make sure ',' follows
5303+ 362E 2C                   defb    ','
5304+ 362F CD 32 2A             call    GETINT          ; get X coord.
5305+ 3632 FE 20                cp      $20             ; is it in rage 0~31?
5306+ 3634 D2 E6 1D             jp      NC,FCERR        ; Illegal function call error
5307+ 3637 32 44 55             ld      (GX),A          ; store into temp. buffer
5308+ 363A CD D2 1A             call    CHKSYN          ; Make sure ',' follows
5309+ 363D 2C                   defb    ','
5310+ 363E CD 32 2A             call    GETINT          ; get Y coord.
5311+ 3641 FE 18                cp      $18             ; is it in range 0~23?
5312+ 3643 D2 E6 1D             jp      NC,FCERR        ; Illegal function call error
5313+ 3646 32 46 55             ld      (GY),A          ; store into temp. buffer
5314+ 3649 11 42 55             ld      DE,TMPCLR
5315+ 364C 3A 3F 55             ld      A,(BKGNDCLR)    ; load background color
5316+ 364F 12                   ld      (DE),A          ; store into temp buff
5317+ 3650 3A 3E 55             ld      A,(FRGNDCLR)    ; load foreground color
5318+ 3653 1B                   dec     DE
5319+ 3654 1B                   dec     DE
5320+ 3655 12                   ld      (DE),A          ; store into temp buff
5321+ 3656 CD E1 36             call    CKCOL           ; check color
5322+ 3659 CA 61 36             jp      Z,CNTGPT2       ; if anything follows, jump over
5323+ 365C 13                   inc     DE
5324+ 365D 13                   inc     DE
5325+ 365E CD E1 36             call    CKCOL           ; check background color
5326+ 3661 CD E4 35     CNTGPT2:call    MIXCLRS         ; mix foreground & background colors
5327+ 3664 32 40 55             ld      (MIXCOL),A      ; store mixed colors
5328+ 3667 E5                   push    HL              ; store code string address
5329+ 3668 ED 4B 4A 55          ld      BC,(CHRPNT)     ; retrieve string pointer
5330+ 366C ED 5B 4C 55          ld      DE,(NUMCHR)     ; retrieve string lenght
5331+ 3670 1C                   inc     E               ; Length + 1
5332+ 3671 CD 76 36             call    GPNT            ; print on G2
5333+ 3674 E1                   pop     HL              ; recover HL
5334+ 3675 C9                   ret                     ; return to caller
5335+ 3676 D5           GPNT:   push    DE              ; store string lenght (E)
5336+ 3677                      ; calculate VRAM address of first char
5337+ 3677 3A 44 55             LD      A,(GX)          ; load X
5338+ 367A 6F                   ld      L,A             ;
5339+ 367B 26 00                ld      H,0             ; HL = X
5340+ 367D 29                   add     HL,HL           ;
5341+ 367E 29                   add     HL,HL           ;
5342+ 367F 29                   add     HL,HL           ; X=X*8
5343+ 3680 3A 46 55             ld      A,(GY)          ; load Y
5344+ 3683 57                   ld      D,A             ; move it into D
5345+ 3684 1E 00                ld      E,0             ; DE =Y*256
5346+ 3686 19                   add     HL,DE           ; address = X*8 + Y*256
5347+ 3687 22 48 55             ld      (TMPADR),HL     ; store VRAM address of first VRAM cell
5348+ 368A D1                   pop     DE              ; retrieve # of chars to be printed yet (E)
5349+ 368B 1D           RPGPNT: dec     E               ; Count characters
5350+ 368C C8                   ret     Z               ; End of string - return
5351+ 368D D5                   push    DE              ; store chars counter
5352+ 368E                      ; calculate dest address in color vram
5353+ 368E 2A 48 55             ld      HL,(TMPADR)     ; recover VRAM address
5354+ 3691 11 00 20             ld      DE,$2000        ; color map address
5355+ 3694 19                   add     HL,DE           ; HL = $2000 + XY address
5356+ 3695 F3                   di                      ; disable INTs
5357+ 3696                      ; send color settings
5358+ 3696 CD 69 06     GPNTCOL:call    SETVDPADRS      ; set VRAM address for color cell
5359+ 3699 3A 40 55             ld      A,(MIXCOL)      ; load color settings
5360+ 369C 06 08                ld      B,$08           ; repeat for 8 rows
5361+ 369E 0E 30                ld      C,VDP_DAT       ; VDP data mode
5362+ 36A0 ED 79        GPNTCO1:out     (C),A           ; send data (VRAM pointer auto-increments)
5363+ 36A2 00                   nop                     ; wait...
5364+ 36A3 00                   nop                     ; ...a...
5365+ 36A4 00                   nop                     ; ...while
5366+ 36A5 10 F9                djnz    GPNTCO1         ; repeat for 8 cells
5367+ 36A7                      ; calculate source address
5368+ 36A7 2A 4A 55             ld      HL,(CHRPNT)     ; load char pointer
5369+ 36AA 7E                   ld      A,(HL)          ; get char
5370+ 36AB 23                   inc     HL              ; increment char pointer
5371+ 36AC 22 4A 55             ld      (CHRPNT),HL     ; store char pointer
5372+ 36AF 6F                   ld      L,A             ;
5373+ 36B0 26 00                ld      H,$00           ; char into HL
5374+ 36B2 29                   add     HL,HL           ;
5375+ 36B3 29                   add     HL,HL           ;
5376+ 36B4 29                   add     HL,HL           ; get offset of char into ROM (charcode * 8)
5377+ 36B5 11 2F 4A             ld      DE,CHRST88      ; DE = start of 8x8 fonts in ROM
5378+ 36B8 19                   add     HL,DE           ; HL = start of characters in ROM
5379+ 36B9 EB                   ex      DE,HL           ; store address into DE
5380+ 36BA 2A 48 55     GPCPCHR:ld      HL,(TMPADR)     ; load VRAM address
5381+ 36BD CD 69 06             call    SETVDPADRS      ; send it to VDP
5382+ 36C0 EB                   ex      DE,HL           ; restore address into HL
5383+ 36C1 06 08                ld      B,$08           ; repeat for 8 rows
5384+ 36C3 0D                   dec     C               ; VDP data mode
5385+ 36C4 ED A3        GPCPCH1:outi                    ; load a byte from ROM and send to VRAM
5386+ 36C6 00                   nop                     ; wait...
5387+ 36C7 00                   nop                     ; ...a...
5388+ 36C8 00                   nop                     ; ...while
5389+ 36C9 20 F9                jr      NZ,GPCPCH1      ; repeat for 8 chars
5390+ 36CB FB                   ei                      ; re-enable INTs
5391+ 36CC 11 08 00             ld      DE,$0008        ; 8 bytes to go to the next video cell
5392+ 36CF 2A 48 55             ld      HL,(TMPADR)     ; load VRAM address
5393+ 36D2 19                   add     HL,DE           ; get address of next VRAM cell
5394+ 36D3 22 48 55             ld      (TMPADR),HL     ; store new VRAM address
5395+ 36D6 11 00 18             ld      DE,$1800        ; forbidden address
5396+ 36D9 CD F9 40             call    CMP16           ; check if the printing has gone out of the screen
5397+ 36DC D1                   pop     DE              ; retrieve number of chars to be printed
5398+ 36DD D0                   ret     NC              ; if HL>=$1800 then leave
5399+ 36DE C3 8B 36             jp      RPGPNT          ; otherwise, check if more chars to output
5400+ 36E1
5401+ 36E1              ; used by GPRINT to get a color argument (if present)
5402+ 36E1 2B           CKCOL:  dec     HL              ; dec 'cos GETCHR INCs
5403+ 36E2 CD 1B 1D             call    GETCHR          ; Get next character
5404+ 36E5 C8                   ret     Z               ; return if nothing follows
5405+ 36E6 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
5406+ 36E9 2C                   defb    ','
5407+ 36EA D5                   push    DE              ; store DE
5408+ 36EB CD 32 2A             call    GETINT          ; get value
5409+ 36EE CD F1 35             call    CHKCLR1         ; check if color is in range 1~15
5410+ 36F1 D1                   pop     DE              ; retrieve DE
5411+ 36F2 12                   ld      (DE),A          ; store color into temp buffer
5412+ 36F3 C9                   ret                     ; return to caller
5413+ 36F4
5414+ 36F4
5415+ 36F4              ; paint X,Y[,C]: in graphics mode, fills an area starting
5416+ 36F4              ; at point X,Y, using default color or, if used, with
5417+ 36F4              ; color set by C
5418+ 36F4              ; TMPBFR1       X
5419+ 36F4              ; TMPBFR2       Y
5420+ 36F4              ; TMPBFR3       COLOR
5421+ 36F4              PNT     equ     VIDEOBUFF
5422+ 36F4              SPA     equ     VIDEOBUFF+$02
5423+ 36F4              SPB     equ     VIDEOBUFF+$03
5424+ 36F4              ORGSP   equ     VIDEOBUFF+$04
5425+ 36F4 CD FB 35     PAINT:  call    CHKG2M          ; check if in graphic mode 2
5426+ 36F7 CD 32 2A             call    GETINT          ; get X
5427+ 36FA 32 40 55             ld      (TMPBFR1),A     ; store X
5428+ 36FD CD D2 1A             call    CHKSYN          ; Make sure ',' follows
5429+ 3700 2C                   defb    ','
5430+ 3701 CD 32 2A             call    GETINT          ; get Y coords,
5431+ 3704 FE C0                cp      $C0             ; check if Y is in range 0~191
5432+ 3706 D2 E6 1D             jp      NC,FCERR        ; no, raise an FC error
5433+ 3709 32 42 55             ld      (TMPBFR2),A     ; store Y
5434+ 370C CD F0 3B             call    CLRPRM          ; check if color has been passed
5435+ 370F 3A 44 55             ld      A,(TMPBFR3)     ; load color
5436+ 3712 A7                   and     A               ; check if 0
5437+ 3713 CA E6 1D             jp      Z,FCERR         ; yes, raise an error
5438+ 3716 E5                   push    HL              ; store HL
5439+ 3717 C5                   push    BC              ; store BC
5440+ 3718 D5                   push    DE              ; store DE
5441+ 3719                      ; start algorithm
5442+ 3719 CD 2C 38             call    PNTRTN          ; check if pixel is already set
5443+ 371C C2 D0 37             jp      NZ,EXITPA2      ; if yes, then leave PAINT
5444+ 371F ED 73 4C 55          ld      (ORGSP),SP      ; no, store current Stack Pointer
5445+ 3723 21 01 00             ld      HL,$0001        ; HL=1
5446+ 3726 22 48 55             ld      (PNT),HL        ; set PNT
5447+ 3729 3A 40 55             ld      A,(TMPBFR1)     ; load starting X...
5448+ 372C 47                   ld      B,A             ; ...into B
5449+ 372D 3A 42 55             ld      A,(TMPBFR2)     ; load starting Y...
5450+ 3730 4F                   ld      C,A             ; ...into C
5451+ 3731 C5                   push    BC              ; store starting X,Y into stack
5452+ 3732                      ; main loop
5453+ 3732 2A 48 55     NXTLOOP:ld      HL,(PNT)        ; retrieve PNT
5454+ 3735 7C                   ld      A,H             ; check if PNT=0
5455+ 3736 B5                   or      L
5456+ 3737 CA CC 37             jp      Z,EXITPAI       ; yes, no more points to process - exit
5457+ 373A 2B                   dec     HL              ; no, so decrement PNT...
5458+ 373B 22 48 55             ld      (PNT),HL        ; ...and store it
5459+ 373E C1                   pop     BC              ; retrieve pixel coordinates X,Y into BC
5460+ 373F CD D4 37     PAINT0: call    CHECKPA         ; check if pixel is set/reset
5461+ 3742 20 09                jr      NZ,PAINT11      ; pixel is set, so jump over
5462+ 3744 78                   ld      A,B             ; pixel is reset, check if X1=0
5463+ 3745 A7                   and     A               ; (reached the limit of the screen)
5464+ 3746 CA 4E 37             jp      Z,PAINT1        ; yes, jump over
5465+ 3749 05                   dec     B               ; no, decrement X1...
5466+ 374A C3 3F 37             jp      PAINT0          ; ...and repeat
5467+ 374D 04           PAINT11:inc     B               ; if found a pixel on, the re-increment X1
5468+ 374E AF           PAINT1: xor     A               ; reset A
5469+ 374F 57                   ld      D,A             ; set SA=0
5470+ 3750 5F                   ld      E,A             ; set SB=0
5471+ 3751 CD D4 37     MNPAINT:call    CHECKPA         ; check if pixel is set/reset
5472+ 3754 20 DC                jr      NZ,NXTLOOP      ; it's set, so goto next loop
5473+ 3756 78                   ld      A,B             ; copy X1
5474+ 3757 32 40 55             ld      (TMPBFR1),A     ; into buffer
5475+ 375A 79                   ld      A,C             ; copy Y
5476+ 375B 32 42 55             ld      (TMPBFR2),A     ; into buffer
5477+ 375E CD 52 38             call    CNTPLOT         ; plot pixel X1,Y
5478+ 3761 7A                   ld      A,D             ; load SA into A
5479+ 3762 A7                   and     A               ; SA=0?
5480+ 3763 20 1C                jr      NZ,PAINT2       ; no, jump over
5481+ 3765 79                   ld      A,C             ; load Y
5482+ 3766 FE 01                cp      $01             ; Y>0?
5483+ 3768 DA 81 37             jp      C,PAINT2        ; no, jump over
5484+ 376B 3D                   dec     A               ; yes, Y=Y-1
5485+ 376C CD D5 37             call    CHECKPY         ; check pixel X1,Y-1
5486+ 376F 20 10                jr      NZ,PAINT2       ; it's set, so jump over
5487+ 3771 0D                   dec     C               ; Y=Y-1
5488+ 3772 C5                   push    BC              ; insert pixel(X1,Y-1) into stack
5489+ 3773 0C                   inc     C               ; retrieve original Y
5490+ 3774 2A 48 55             ld      HL,(PNT)        ; load PNT
5491+ 3777 23                   inc     HL              ; increment PNT
5492+ 3778 22 48 55             ld      (PNT),HL        ; store new PNT
5493+ 377B 3E 01                ld      A,$01           ; set SA=1 and...
5494+ 377D 57                   ld      D,A             ; ...store SA into memory
5495+ 377E C3 94 37             jp      PAINT3          ; jump over
5496+ 3781 7A           PAINT2: ld      A,D             ; load SA into A
5497+ 3782 1F                   rra                     ; check if SA=1
5498+ 3783 30 0F                jr      NC,PAINT3       ; no, jump over
5499+ 3785 79                   ld      A,C             ; load Y
5500+ 3786 FE 01                cp      $01             ; Y>0?
5501+ 3788 DA 94 37             jp      C,PAINT3        ; no, jump over
5502+ 378B 3D                   dec     A               ; Y=Y-1
5503+ 378C CD D5 37             call    CHECKPY         ; check pixel X1,Y-1
5504+ 378F CA 94 37             jp      Z,PAINT3        ; if pixel is off, jump over
5505+ 3792 AF                   xor     A               ; pixel is on, so...
5506+ 3793 57                   ld      D,A             ; ...set SA=0
5507+ 3794 7B           PAINT3: ld      A,E             ; check if...
5508+ 3795 A7                   and     A               ; SB=0
5509+ 3796 20 1B                jr      NZ,PAINT4       ; no, jump over
5510+ 3798 79                   ld      A,C             ; load Y
5511+ 3799 FE BF                cp      $BF             ; Y<191?
5512+ 379B 30 16                jr      NC,PAINT4       ; no, jump over
5513+ 379D 3C                   inc     A               ; Y=Y+1
5514+ 379E CD D5 37             call    CHECKPY         ; check pixel X1,Y+1
5515+ 37A1 20 10                jr      NZ,PAINT4       ; pixel is on, so jump over
5516+ 37A3 0C                   inc     C               ; Y=Y+1
5517+ 37A4 C5                   push    BC              ; insert pixel(X1,Y+1) into stack
5518+ 37A5 0D                   dec     C               ; retrieve original Y
5519+ 37A6 2A 48 55             ld      HL,(PNT)        ; PNT
5520+ 37A9 23                   inc     HL              ; PNT=PNT+1
5521+ 37AA 22 48 55             ld      (PNT),HL        ; store PNT
5522+ 37AD 3E 01                ld      A,$01           ; SB=1
5523+ 37AF 5F                   ld      E,A             ; set SB
5524+ 37B0 C3 C5 37             jp      PAINT5          ; jump over
5525+ 37B3 7B           PAINT4: ld      A,E             ; load SB
5526+ 37B4 1F                   rra                     ; check if SB=1
5527+ 37B5 30 0E                jr      NC,PAINT5       ; no, jump over
5528+ 37B7 79                   ld      A,C             ; load Y
5529+ 37B8 FE BF                cp      $BF             ; Y<191?
5530+ 37BA 30 09                jr      NC,PAINT5       ; no, jump over
5531+ 37BC 3C                   inc     A               ; Y=Y+1
5532+ 37BD CD D5 37             call    CHECKPY         ; check pixel X1,Y+1
5533+ 37C0 CA C5 37             jp      Z,PAINT5        ; if pixel is off, jump over
5534+ 37C3 AF                   xor     A               ; pixel is on, so...
5535+ 37C4 5F                   ld      E,A             ; ...set SB=0
5536+ 37C5 04           PAINT5: inc     B               ; X1=X1+1
5537+ 37C6 CA 32 37             jp      Z,NXTLOOP       ; if X1>255 (X1=0) then goto next loop
5538+ 37C9 C3 51 37             jp      MNPAINT         ; otherwise, repeat for next X
5539+ 37CC ED 7B 4C 55  EXITPAI:ld      SP,(ORGSP)      ; retrieve original SP pointer
5540+ 37D0 D1           EXITPA2:pop     DE              ; retrieve DE
5541+ 37D1 C1                   pop     BC              ; retrieve BC
5542+ 37D2 E1                   pop     HL              ; retrieve HL
5543+ 37D3 C9                   ret                     ; return to caller
5544+ 37D4 79           CHECKPA:ld      A,C             ; copy Y into A
5545+ 37D5 32 42 55     CHECKPY:ld      (TMPBFR2),A     ; store Y
5546+ 37D8 78                   ld      A,B             ; copy X1 into A
5547+ 37D9 32 40 55             ld      (TMPBFR1),A     ; store X1
5548+ 37DC C5                   push    BC              ; save X1,Y
5549+ 37DD D5                   push    DE
5550+ 37DE CD 2C 38             call    PNTRTN          ; check if pixel is set/reset
5551+ 37E1 D1                   pop     DE
5552+ 37E2 C1                   pop     BC              ; retrieve X1,Y
5553+ 37E3 C9                   ret                     ; return to caller
5554+ 37E4
5555+ 37E4
5556+ 37E4              ; POINT(x,y): return if a pixel is set (returns color) or if it's reset (0)
5557+ 37E4 CD FB 35     POINT:  call    CHKG2M          ; check if in graphic mode 2
5558+ 37E7 CD D2 1A             call    CHKSYN          ; make sure "(" follows
5559+ 37EA 28                   defb    '('
5560+ 37EB CD 32 2A             call    GETINT          ; get X coords.
5561+ 37EE 32 40 55             ld      (TMPBFR1),A     ; store it into a temp buffer
5562+ 37F1 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
5563+ 37F4 2C                   defb    ','
5564+ 37F5 CD 32 2A             call    GETINT          ; get Y coords,
5565+ 37F8 FE C0                cp      $C0             ; check if Y is in range 0~191
5566+ 37FA D2 E6 1D             jp      NC,FCERR        ; no, raise an FC error
5567+ 37FD 32 42 55             ld      (TMPBFR2),A     ; store into a temp buffer
5568+ 3800 CD D2 1A             call    CHKSYN          ; make sure ")" follows
5569+ 3803 29                   defb    ')'
5570+ 3804 E5                   push    HL              ; store current string address - the point after the ")" - ...
5571+ 3805 FD E1                pop     IY              ; ...into IY
5572+ 3807 CD 2C 38             call    PNTRTN          ; check if pixel is set or reset
5573+ 380A 20 0C                jr      NZ,CTPOINT      ; it's ON, jump over
5574+ 380C AF                   xor     A               ; no, it's OFF. make sure to reset A...
5575+ 380D 47                   ld      B,A             ; ...and B
5576+ 380E E1           PNTEND: pop     HL              ; drop original return point
5577+ 380F FD E5                push    IY              ; load current string address from IY into stack
5578+ 3811 11 97 22             ld      DE,RETNUM       ; Address of Return number from function...
5579+ 3814 D5                   push    DE              ; ...saved on stack
5580+ 3815 C3 96 25             jp      ABPASS          ; return AB
5581+ 3818 CB EC        CTPOINT:set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5582+ 381A F3                   di
5583+ 381B CD 89 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5584+ 381E FB                   ei
5585+ 381F CB 3F                srl     A               ; shift A...
5586+ 3821 CB 3F                srl     A               ; ...4 times...
5587+ 3823 CB 3F                srl     A               ; ...to move foreground color...
5588+ 3825 CB 3F                srl     A               ; ...into lowest nibble
5589+ 3827 47                   ld      B,A             ; color into B
5590+ 3828 AF                   xor     A               ; reset MSB
5591+ 3829 C3 0E 38             jp      PNTEND          ; return AB
5592+ 382C CD 9F 38     PNTRTN: call    XY2HL           ; find HL address of pixel at X,Y
5593+ 382F 57                   ld      D,A             ; store pixel index
5594+ 3830 F3                   di                      ; disable INTs
5595+ 3831 CD 89 06             call    READ_VIDEO_LOC  ; read contents of VRAM cell addressed by HL
5596+ 3834 FB                   ei                      ; re-enable INTs
5597+ 3835 A2                   and     D               ; is the pixel ON or OFF? (will be checked later)
5598+ 3836 C9                   ret                     ; return to caller
5599+ 3837
5600+ 3837
5601+ 3837              ; PLOT X,Y[,color]
5602+ 3837              ; plot a pixel in graphic mode 2
5603+ 3837 CD FB 35     PLOT:   call    CHKG2M          ; check if in G2 mode
5604+ 383A CD 32 2A             call    GETINT          ; get X coords.
5605+ 383D 32 40 55             ld      (TMPBFR1),A     ; store it into a temp buffer
5606+ 3840 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
5607+ 3843 2C                   defb    ','
5608+ 3844 CD 32 2A             call    GETINT          ; get Y coords,
5609+ 3847 FE C0                cp      $C0             ; check if Y is in range 0~191
5610+ 3849 D2 E6 1D             jp      NC,FCERR        ; no, raise an FC error
5611+ 384C 32 42 55             ld      (TMPBFR2),A     ; store into a temp buffer
5612+ 384F CD F0 3B             call    CLRPRM          ; check if param "color" has been passed
5613+ 3852 E5           CNTPLOT:push    HL              ; store HL
5614+ 3853 C5                   push    BC              ; store BC
5615+ 3854 D5                   push    DE              ; store DE
5616+ 3855 CD 9F 38             call    XY2HL           ; find VRAM address of byte containing pixel at X,Y & return into HL
5617+ 3858 D2 93 38             jp      NC,NOGD         ; if carry is reset, there was an error -> so leave
5618+ 385B 57                   ld      D,A             ; move pixel value into D
5619+ 385C 3A 44 55             ld      A,(TMPBFR3)     ; retrieve color
5620+ 385F A7                   and     A               ; is it 0? (background, or reset pixel)
5621+ 3860 20 11                jr      NZ,CNTPLT1      ; no, continue
5622+ 3862 F3                   di                      ; yes - so, disable INTs
5623+ 3863 CD 89 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5624+ 3866 FB                   ei                      ; re-enable INTs
5625+ 3867 5F                   ld      E,A             ; store value of cell
5626+ 3868 7A                   ld      A,D             ; retrieve pixel
5627+ 3869 2F                   cpl                     ; revert bits
5628+ 386A A3                   and     E               ; set video pixel to off
5629+ 386B F3                   di                      ; disable INTs
5630+ 386C CD 9E 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5631+ 386F FB                   ei                      ; re-enable INTs
5632+ 3870 C3 93 38             jp      NOGD            ; leave
5633+ 3873 87           CNTPLT1:add     A,A             ; now we move low nibble
5634+ 3874 87                   add     A,A             ; in the high nibble
5635+ 3875 87                   add     A,A             ; by adding A to itself
5636+ 3876 87                   add     A,A             ; 4 times (this is a shift left 4)
5637+ 3877 5F                   ld      E,A             ; move it into E
5638+ 3878 F3                   di                      ; disable INTs
5639+ 3879 CD 89 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5640+ 387C FB                   ei
5641+ 387D B2                   or      D               ; merge new pixel preserving original pattern
5642+ 387E F3                   di
5643+ 387F CD 9E 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5644+ 3882 FB                   ei
5645+ 3883 CB EC                set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5646+ 3885 F3                   di
5647+ 3886 CD 89 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5648+ 3889 FB                   ei
5649+ 388A E6 0F                and     %00001111       ; reset high nibble (the foreground color)
5650+ 388C B3                   or      E               ; set new foreground color
5651+ 388D F3                   di
5652+ 388E CD 9E 06             call    WRITE_VIDEO_LOC ; write new color settings
5653+ 3891 FB                   ei                      ; re-enable INTs
5654+ 3892 00                   nop                     ; wait for INTs to be enabled again
5655+ 3893 D1           NOGD:   pop     DE              ; retrieve DE
5656+ 3894 C1                   pop     BC              ; retrieve BC
5657+ 3895 E1                   pop     HL              ; retrieve HL
5658+ 3896 C9                   ret                     ; return to caller
5659+ 3897 80 40 20 10  PXLSET: defb    $80,$40,$20,$10,$08,$04,$02,$01 ; pixel to be set ON
5659+ 389B 08 04 02 01
5660+ 389F                      ; where R(X/8)=> 0=80h, 1=40h, 2=20h, 3=10h, 4=08h, 5=04h, 6=02h, 7=$01
5661+ 389F
5662+ 389F
5663+ 389F              ; compute the VRAM address of the byte containing the pixel
5664+ 389F              ; being pointed by X,Y (TMPBFR1,TMPBFR2)
5665+ 389F              ; byte address is returned into HL
5666+ 389F              ; pixel is returned into A
5667+ 389F              XY2HL:  ; formula is: ADDRESS=(INT(X/8))*8 + (INT(Y/8))*256 + R(Y/8)
5668+ 389F                      ; where R(Y/8) is the remainder of (Y/8)
5669+ 389F                      ; the pixel to be set is given by R(X/8), and data is taken from the array
5670+ 389F 3A 42 55             ld      A,(TMPBFR2)     ; retrieve Y
5671+ 38A2 FE C0                cp      $C0             ; Y>=192?
5672+ 38A4 D0                   ret     NC              ; yes, so leave
5673+ 38A5 1E 08                ld      E,$08           ; load E with divisor
5674+ 38A7 57                   ld      D,A             ; and store into D (dividend)
5675+ 38A8 CD 44 41             call    DIV_8_8         ; get Y/8, D is quotient=INT(Y/8), and A is remainder
5676+ 38AB 4F                   ld      C,A             ; store remainder into C
5677+ 38AC 42                   ld      B,D             ; B=(INT(Y/8))*256 (we simply copy quotient into B)
5678+ 38AD 60 69                ld      HL,BC           ; copy BC into HL: now HL has the VRAM address of the byte being set
5679+ 38AF 3A 40 55             ld      A,(TMPBFR1)     ; retrieve X
5680+ 38B2 57                   ld      D,A             ; and move it into D (dividend)
5681+ 38B3 CD 44 41             call    DIV_8_8         ; get X/8, D is quotient=INT(X/8), and A is remainder
5682+ 38B6 4F                   ld      C,A             ; store remainder into C
5683+ 38B7 7A                   ld      A,D             ; move quotient into A
5684+ 38B8 87                   add     A,A             ; multiply quotient by 8
5685+ 38B9 87                   add     A,A
5686+ 38BA 87                   add     A,A
5687+ 38BB 5F                   ld      E,A             ; store result into E
5688+ 38BC 16 00                ld      D,$00           ; reset D
5689+ 38BE 19                   add     HL,DE           ; add DE to HL, getting the final VRAM address
5690+ 38BF EB                   ex      DE,HL           ; move VRAM address into DE
5691+ 38C0 21 97 38             ld      HL,PXLSET       ; starting address of table for pixel to draw
5692+ 38C3 06 00                ld      B,$00           ; reset B
5693+ 38C5 09                   add     HL,BC           ; add C (remainder of X/8) to get address of pixel to turn on
5694+ 38C6 7E                   ld      A,(HL)          ; load pixel data
5695+ 38C7 EB                   ex      DE,HL           ; retrieve VRAM pattern address into HL
5696+ 38C8 37                   scf                     ; set Carry for normal exit
5697+ 38C9 C9                   ret                     ; return to caller
5698+ 38CA
5699+ 38CA
5700+ 38CA              ; DRAW X1,Y1,X2,Y2[,color]
5701+ 38CA              ; Draw a line using Bresenham's line algorithm from X1,Y1 to X2,Y2
5702+ 38CA              ; X1,Y1 can be either less than or greater than X2,Y2 (meaning that)
5703+ 38CA              ; the drawing will be ever done from X1,Y2 to X2,Y2, regardless of
5704+ 38CA              ; the values. If color is not specified, the foreground color set
5705+ 38CA              ; with COLOR will be used
5706+ 38CA              X1      equ     TMPBFR1
5707+ 38CA              Y1      equ     TMPBFR2
5708+ 38CA              X2      equ     VIDEOBUFF
5709+ 38CA              Y2      equ     VIDEOBUFF+$02
5710+ 38CA              ER      equ     VIDEOBUFF+$04
5711+ 38CA              E2      equ     VIDEOBUFF+$06
5712+ 38CA              SX      equ     VIDEOBUFF+$08
5713+ 38CA              SY      equ     VIDEOBUFF+$0A
5714+ 38CA              DX      equ     VIDEOBUFF+$0C
5715+ 38CA              DY      equ     VIDEOBUFF+$0E
5716+ 38CA CD FB 35     DRAW:   call    CHKG2M          ; check if in G2 mode
5717+ 38CD CD D2 3B             call    CLRTMBF         ; clear TMPBFRx
5718+ 38D0 CD E1 3B             call    CLRVDBF         ; clear VIDEOBUFF
5719+ 38D3 CD 32 2A             call    GETINT          ; get X1 coords.
5720+ 38D6 32 40 55             ld      (X1),A          ; store it into a temp buffer
5721+ 38D9 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
5722+ 38DC 2C                   defb    ','
5723+ 38DD CD 32 2A             call    GETINT          ; get Y1 coords.
5724+ 38E0 FE C0                cp      $C0             ; check if Y1 is in range 0~191
5725+ 38E2 D2 E6 1D             jp      NC,FCERR        ; no, raise an FC error
5726+ 38E5 32 42 55             ld      (Y1),A          ; store into a temp buffer
5727+ 38E8 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
5728+ 38EB 2C                   defb    ','
5729+ 38EC CD 32 2A             call    GETINT          ; get X2 coords.
5730+ 38EF 32 48 55             ld      (X2),A          ; store it into a temp buffer
5731+ 38F2 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
5732+ 38F5 2C                   defb    ','
5733+ 38F6 CD 32 2A             call    GETINT          ; get Y2 coords
5734+ 38F9 FE C0                cp      $C0             ; check if Y2 is in range 0~191
5735+ 38FB D2 E6 1D             jp      NC,FCERR        ; no, raise an FC error
5736+ 38FE 32 4A 55             ld      (Y2),A          ; store it into a temp buffer
5737+ 3901 CD F0 3B             call    CLRPRM          ; check for arg. "color" and store it into TMPBFR3
5738+ 3904 E5                   push    HL              ; store register we'll use
5739+ 3905 D5                   push    DE
5740+ 3906 C5                   push    BC
5741+ 3907 ED 5B 40 55          ld      DE,(X1)         ; load X1 and
5742+ 390B 2A 48 55             ld      HL,(X2)         ; X2
5743+ 390E B7                   or      A               ; clear CARRY
5744+ 390F ED 52                sbc     HL,DE           ; DX=X2-X1
5745+ 3911 CD 3A 41             call    absHL           ; DX=ABS(DX)
5746+ 3914 22 54 55             ld      (DX),HL         ; store DX
5747+ 3917 01 FF FF             ld      BC,$FFFF        ; SX=-1
5748+ 391A 2A 40 55             ld      HL,(X1)
5749+ 391D ED 5B 48 55          ld      DE,(X2)
5750+ 3921 CD F9 40             call    CMP16           ; X1<X2?
5751+ 3924 CA 2D 39             jp      Z,X1GR          ; no, X1=X2
5752+ 3927 F2 2D 39             jp      P,X1GR          ; no, X1>X2
5753+ 392A 01 01 00             ld      BC,$0001        ; yes, so set SX=1
5754+ 392D ED 43 50 55  X1GR:   ld      (SX),BC         ; store SX
5755+ 3931 ED 5B 42 55          ld      DE,(Y1)
5756+ 3935 2A 4A 55             ld      HL,(Y2)
5757+ 3938 B7                   or      A               ; clear Carry
5758+ 3939 ED 52                sbc     HL,DE           ; DY=Y2-Y1
5759+ 393B CD 3A 41             call    absHL           ; DY=ABS(DY)
5760+ 393E 22 56 55             ld      (DY),HL         ; store DY
5761+ 3941 01 FF FF             ld      BC,$FFFF        ; SY=-1
5762+ 3944 2A 42 55             ld      HL,(Y1)
5763+ 3947 ED 5B 4A 55          ld      DE,(Y2)
5764+ 394B CD F9 40             call    CMP16           ; is Y1<Y2?
5765+ 394E CA 57 39             jp      Z,Y1GR          ; no, Y1=Y2
5766+ 3951 F2 57 39             jp      P,Y1GR          ; no, Y1>Y2 - jump over
5767+ 3954 01 01 00             ld      BC,$0001        ; yes, so set SY=1
5768+ 3957 ED 43 52 55  Y1GR:   ld      (SY),BC         ; store SY
5769+ 395B 2A 56 55             ld      HL,(DY)         ; ER=DY
5770+ 395E CD 3D 41             call    negHL           ; ER=-DY
5771+ 3961 22 4C 55             ld      (ER),HL         ; store ER
5772+ 3964 2A 54 55             ld      HL,(DX)
5773+ 3967 ED 5B 56 55          ld      DE,(DY)
5774+ 396B CD F9 40             call    CMP16           ; DX>DY?
5775+ 396E CA 7A 39             jp      Z,ER2           ; no, DX=DY
5776+ 3971 FA 7A 39             jp      M,ER2           ; no, DX<DY
5777+ 3974 2A 54 55             ld      HL,(DX)         ; reload DX
5778+ 3977 22 4C 55             ld      (ER),HL         ; yes: DX>DY, so ER=DX
5779+ 397A 2A 4C 55     ER2:    ld      HL,(ER)         ; load ER
5780+ 397D CB 2C                sra     H               ; right shift (and preserve sign)...
5781+ 397F CB 1D                rr      L               ; ...of HL, so ER=INT(ER/2)
5782+ 3981 CB 7C                bit     7,H             ; is the number negative?
5783+ 3983 CA 87 39             jp      Z,STRE2         ; no, jump over
5784+ 3986 23                   inc     HL              ; yes, add 1 'cos INT of a negative number needs to be incremented
5785+ 3987 22 4C 55     STRE2:  ld      (ER),HL         ; store ER
5786+ 398A CD 52 38     RPTDRW: call    CNTPLOT         ; plot first pixel
5787+ 398D 2A 40 55             ld      HL,(X1)
5788+ 3990 ED 5B 48 55          ld      DE,(X2)
5789+ 3994 CD F9 40             call    CMP16           ; X1=X2?
5790+ 3997 20 0D                jr      NZ,CNTDRW       ; no, continue drawing
5791+ 3999 2A 42 55             ld      HL,(Y1)         ; yes, so check
5792+ 399C ED 5B 4A 55          ld      DE,(Y2)         ; also Y
5793+ 39A0 CD F9 40             call    CMP16           ; Y1=Y2?
5794+ 39A3 CA FF 39             jp      Z,ENDDRAW       ; yes, finished drawing: exit
5795+ 39A6 ED 5B 4C 55  CNTDRW: ld      DE,(ER)
5796+ 39AA ED 53 4E 55          ld      (E2),DE         ; E2=ER
5797+ 39AE 2A 54 55             ld      HL,(DX)
5798+ 39B1 CD 3D 41             call    negHL           ; DX=-DX
5799+ 39B4 EB                   ex      DE,HL           ; invert DE and HL => HL=E2, DE=-DX
5800+ 39B5 CD F9 40             call    CMP16           ; E2>-DX?
5801+ 39B8 CA D6 39             jp      Z,DXGR          ; no, E2=-DX: jump
5802+ 39BB FA D6 39             jp      M,DXGR          ; no, E2<-DX: jump
5803+ 39BE 2A 4C 55             ld      HL,(ER)         ; yes
5804+ 39C1 ED 5B 56 55          ld      DE,(DY)
5805+ 39C5 B7                   or      A               ; clear CARRY
5806+ 39C6 ED 52                sbc     HL,DE           ; ER=ER-DY
5807+ 39C8 22 4C 55             ld      (ER),HL
5808+ 39CB 2A 40 55             ld      HL,(X1)
5809+ 39CE ED 5B 50 55          ld      DE,(SX)
5810+ 39D2 19                   add     HL,DE           ; X1=X1+SX (increment X1)
5811+ 39D3 22 40 55             ld      (X1),HL
5812+ 39D6 2A 4E 55     DXGR:   ld      HL,(E2)
5813+ 39D9 ED 5B 56 55          ld      DE,(DY)
5814+ 39DD CD F9 40             call    CMP16           ; E2<DY?
5815+ 39E0 CA 8A 39             jp      Z,RPTDRW        ; no, E2=DY: jump
5816+ 39E3 F2 8A 39             jp      P,RPTDRW        ; no, E2>DY: jump
5817+ 39E6 2A 4C 55             ld      HL,(ER)         ; yes
5818+ 39E9 ED 5B 54 55          ld      DE,(DX)
5819+ 39ED 19                   add     HL,DE           ; ER=ER+DX
5820+ 39EE 22 4C 55             ld      (ER),HL
5821+ 39F1 2A 42 55             ld      HL,(Y1)
5822+ 39F4 ED 5B 52 55          ld      DE,(SY)
5823+ 39F8 19                   add     HL,DE           ; Y1=Y1+SY (increment Y1)
5824+ 39F9 22 42 55             ld      (Y1),HL
5825+ 39FC C3 8A 39             jp      RPTDRW          ; repeat
5826+ 39FF C1           ENDDRAW:pop     BC              ; retrieve BC
5827+ 3A00 D1                   pop     DE              ; retrieve DE
5828+ 3A01 E1                   pop     HL              ; retrieve HL
5829+ 3A02 C9                   ret                     ; return to caller
5830+ 3A03
5831+ 3A03
5832+ 3A03              ; CIRCLE X,Y,R[,C]
5833+ 3A03              ; Draw a circle using Bresenham's circle algorithm with center in X,Y
5834+ 3A03              ; and radius R, with optional color C. If color is not specified, the
5835+ 3A03              ; foreground color set with COLOR will be used
5836+ 3A03              XC      equ     VIDEOBUFF
5837+ 3A03              YC      equ     VIDEOBUFF+$02
5838+ 3A03              RADIUS  equ     VIDEOBUFF+$04
5839+ 3A03              XI      equ     VIDEOBUFF+$06
5840+ 3A03              YI      equ     VIDEOBUFF+$08
5841+ 3A03              DC      equ     VIDEOBUFF+$0A
5842+ 3A03 CD FB 35     CIRCLE: call    CHKG2M          ; check if in G2 mode
5843+ 3A06 CD E1 3B             call    CLRVDBF         ; clear VIDEOBUFF
5844+ 3A09 CD 32 2A             call    GETINT          ; get X coords.
5845+ 3A0C 32 48 55             ld      (XC),A          ; store it into a temp buffer
5846+ 3A0F CD D2 1A             call    CHKSYN          ; Make sure ',' follows
5847+ 3A12 2C                   defb    ','
5848+ 3A13 CD 32 2A             call    GETINT          ; get Y coords,
5849+ 3A16 32 4A 55             ld      (YC),A          ; store it into a temp buffer
5850+ 3A19 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
5851+ 3A1C 2C                   defb    ','
5852+ 3A1D CD 32 2A             call    GETINT          ; get radius
5853+ 3A20 32 4C 55             ld      (RADIUS),A      ; store it into a temp buffer
5854+ 3A23 CD F0 3B             call    CLRPRM          ; check if param "color" has been passed
5855+ 3A26 C5                   push    BC              ; store BC
5856+ 3A27 D5                   push    DE              ; store DE
5857+ 3A28 E5                   push    HL              ; store HL
5858+ 3A29 AF                   xor     A               ; clear A,
5859+ 3A2A 47                   ld      B,A             ; B,
5860+ 3A2B 4F                   ld      C,A             ; C,
5861+ 3A2C 57                   ld      D,A             ; D,
5862+ 3A2D 67                   ld      H,A             ; and H
5863+ 3A2E ED 43 4E 55          ld      (XI),BC         ; clear XI
5864+ 3A32 3A 4C 55             ld      A,(RADIUS)      ; load RADIUS into A
5865+ 3A35 6F                   ld      L,A             ; HL now contains R
5866+ 3A36 22 50 55             ld      (YI),HL         ; YI=RADIUS
5867+ 3A39 29                   add     HL,HL           ; R*2
5868+ 3A3A EB                   ex      DE,HL           ; put HL into DE
5869+ 3A3B 21 03 00             ld      HL,$0003        ; HL = 3
5870+ 3A3E AF                   xor     A               ; clear Carry
5871+ 3A3F ED 52                sbc     HL,DE           ; D=3-(2*R) => HL
5872+ 3A41 22 52 55             ld      (DC),HL         ; store D
5873+ 3A44 CD A3 3A             call    DRWCRL          ; draw initial point
5874+ 3A47 ED 5B 4E 55  RPTCRL: ld      DE,(XI)         ; load XI
5875+ 3A4B 2A 50 55             ld      HL,(YI)         ; load YI
5876+ 3A4E CD F9 40             call    CMP16           ; is YI<DI?
5877+ 3A51 CA 5A 3A             jp      Z,RPTCL1        ; no, YI=XI
5878+ 3A54 F2 5A 3A             jp      P,RPTCL1        ; no, YI>XI
5879+ 3A57 C3 9F 3A             jp      ENDCRL          ; yes, so we've finished
5880+ 3A5A 21 4E 55     RPTCL1: ld      HL,XI
5881+ 3A5D 34                   inc     (HL)            ; XI=XI+1
5882+ 3A5E 2A 52 55             ld      HL,(DC)         ; load D
5883+ 3A61 7C                   ld      A,H
5884+ 3A62 B5                   or      L               ; is D=0? Yes, jump over
5885+ 3A63 CA 87 3A             jp      Z,DLSZ
5886+ 3A66 CB 7C                bit     7,H             ; is D<0?
5887+ 3A68 20 1D                jr      NZ,DLSZ         ; yes, jump over
5888+ 3A6A ED 5B 50 55          ld      DE,(YI)         ; D>0
5889+ 3A6E 1B                   dec     DE              ; so, YI=YI-1
5890+ 3A6F ED 53 50 55          ld      (YI),DE         ; store YI
5891+ 3A73 AF                   xor     A               ; clear Carry
5892+ 3A74 2A 4E 55             ld      HL,(XI)
5893+ 3A77 ED 52                sbc     HL,DE           ; HL=XI-YI
5894+ 3A79 29                   add     HL,HL
5895+ 3A7A 29                   add     HL,HL           ; HL=HL*4
5896+ 3A7B 11 0A 00             ld      DE,10
5897+ 3A7E 19                   add     HL,DE           ; HL=HL+10
5898+ 3A7F ED 5B 52 55          ld      DE,(DC)         ; load D
5899+ 3A83 EB                   ex      DE,HL           ; invert DE and HL, so that HL=4*(XI-YI)+10 and DE=D
5900+ 3A84 19                   add     HL,DE           ; D=D+4*(XI-YI)+10
5901+ 3A85 18 0F                jr      PLTCRL          ; plot next pixel
5902+ 3A87 2A 4E 55     DLSZ:   ld      HL,(XI)         ; load XI
5903+ 3A8A 29                   add     HL,HL
5904+ 3A8B 29                   add     HL,HL           ; XI=XI*4
5905+ 3A8C 11 06 00             ld      DE,$0006
5906+ 3A8F 19                   add     HL,DE
5907+ 3A90 ED 5B 52 55          ld      DE,(DC)
5908+ 3A94 EB                   ex      DE,HL           ; HL=D and DE=4*XI+6
5909+ 3A95 19                   add     HL,DE           ; D=D+4*XI+6
5910+ 3A96 22 52 55     PLTCRL: ld      (DC),HL         ; store new D
5911+ 3A99 CD A3 3A             call    DRWCRL          ; plot pixel
5912+ 3A9C C3 47 3A             jp      RPTCRL          ; repeat
5913+ 3A9F E1           ENDCRL: pop     HL
5914+ 3AA0 D1                   pop     DE
5915+ 3AA1 C1                   pop     BC
5916+ 3AA2 C9                   ret                     ; return to caller
5917+ 3AA3 2A 48 55     DRWCRL: ld      HL,(XC)
5918+ 3AA6 ED 5B 4E 55          ld      DE,(XI)
5919+ 3AAA 19                   add     HL,DE           ; X=XC+XI
5920+ 3AAB 22 40 55             ld      (X1),HL         ; store X
5921+ 3AAE CD C2 3B             call    VALIDX          ; check if X is valid (0~255)
5922+ 3AB1 DA C5 3A             jp      C,CNTCL1        ; if Carry is set, X is not valid
5923+ 3AB4 2A 4A 55             ld      HL,(YC)
5924+ 3AB7 ED 5B 50 55          ld      DE,(YI)
5925+ 3ABB 19                   add     HL,DE           ; Y=YC+YI
5926+ 3ABC 22 42 55             ld      (Y1),HL         ; store Y
5927+ 3ABF CD C7 3B             call    VALIDY          ; check if Y is valid (0~191)
5928+ 3AC2 D4 52 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5929+ 3AC5 AF           CNTCL1: xor     A               ; clear Carry
5930+ 3AC6 2A 48 55             ld      HL,(XC)
5931+ 3AC9 ED 5B 4E 55          ld      DE,(XI)
5932+ 3ACD ED 52                sbc     HL,DE           ; X=XC-XI
5933+ 3ACF 22 40 55             ld      (X1),HL         ; store X
5934+ 3AD2 CD C2 3B             call    VALIDX          ; check if X is valid (0~255)
5935+ 3AD5 DA E9 3A             jp      C,CNTCL2        ; if Carry is set, X is not valid
5936+ 3AD8 2A 4A 55             ld      HL,(YC)
5937+ 3ADB ED 5B 50 55          ld      DE,(YI)
5938+ 3ADF 19                   add     HL,DE           ; Y=YC+YI
5939+ 3AE0 22 42 55             ld      (Y1),HL         ; store Y
5940+ 3AE3 CD C7 3B             call    VALIDY          ; check if Y is valid (0~191)
5941+ 3AE6 D4 52 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5942+ 3AE9 2A 48 55     CNTCL2: ld      HL,(XC)
5943+ 3AEC ED 5B 4E 55          ld      DE,(XI)
5944+ 3AF0 19                   add     HL,DE           ; X=XC+XI
5945+ 3AF1 22 40 55             ld      (X1),HL         ; store X
5946+ 3AF4 CD C2 3B             call    VALIDX          ; check if X is valid (0~255)
5947+ 3AF7 DA 0D 3B             jp      C,CNTCL3        ; if Carry is set, X is not valid
5948+ 3AFA AF                   xor     A               ; clear Carry
5949+ 3AFB 2A 4A 55             ld      HL,(YC)
5950+ 3AFE ED 5B 50 55          ld      DE,(YI)
5951+ 3B02 ED 52                sbc     HL,DE           ; Y=YC-YI
5952+ 3B04 22 42 55             ld      (Y1),HL         ; store Y
5953+ 3B07 CD C7 3B             call    VALIDY          ; check if Y is valid (0~191)
5954+ 3B0A D4 52 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5955+ 3B0D AF           CNTCL3: xor     A               ; clear Carry
5956+ 3B0E 2A 48 55             ld      HL,(XC)
5957+ 3B11 ED 5B 4E 55          ld      DE,(XI)
5958+ 3B15 ED 52                sbc     HL,DE           ; X=XC-XI
5959+ 3B17 22 40 55             ld      (X1),HL         ; store X
5960+ 3B1A CD C2 3B             call    VALIDX          ; check if X is valid (0~255)
5961+ 3B1D DA 33 3B             jp      C,CNTCL4        ; if Carry is set, X is not valid
5962+ 3B20 AF                   xor     A               ; clear Carry
5963+ 3B21 2A 4A 55             ld      HL,(YC)
5964+ 3B24 ED 5B 50 55          ld      DE,(YI)
5965+ 3B28 ED 52                sbc     HL,DE           ; Y=YC-YI
5966+ 3B2A 22 42 55             ld      (Y1),HL         ; store Y
5967+ 3B2D CD C7 3B             call    VALIDY          ; check if Y is valid (0~191)
5968+ 3B30 D4 52 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5969+ 3B33 2A 48 55     CNTCL4: ld      HL,(XC)
5970+ 3B36 ED 5B 50 55          ld      DE,(YI)
5971+ 3B3A 19                   add     HL,DE           ; X=XC+YI
5972+ 3B3B 22 40 55             ld      (X1),HL         ; store X
5973+ 3B3E CD C2 3B             call    VALIDX          ; check if X is valid (0~255)
5974+ 3B41 DA 55 3B             jp      C,CNTCL5        ; if Carry is set, X is not valid
5975+ 3B44 2A 4A 55             ld      HL,(YC)
5976+ 3B47 ED 5B 4E 55          ld      DE,(XI)
5977+ 3B4B 19                   add     HL,DE           ; Y=YC+XI
5978+ 3B4C 22 42 55             ld      (Y1),HL         ; store Y
5979+ 3B4F CD C7 3B             call    VALIDY          ; check if Y is valid (0~191)
5980+ 3B52 D4 52 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5981+ 3B55 AF           CNTCL5: xor     A               ; clear Carry
5982+ 3B56 2A 48 55             ld      HL,(XC)
5983+ 3B59 ED 5B 50 55          ld      DE,(YI)
5984+ 3B5D ED 52                sbc     HL,DE           ; X=XC-YI
5985+ 3B5F 22 40 55             ld      (X1),HL         ; store X
5986+ 3B62 CD C2 3B             call    VALIDX          ; check if X is valid (0~255)
5987+ 3B65 DA 79 3B             jp      C,CNTCL6        ; if Carry is set, X is not valid
5988+ 3B68 2A 4A 55             ld      HL,(YC)
5989+ 3B6B ED 5B 4E 55          ld      DE,(XI)
5990+ 3B6F 19                   add     HL,DE           ; Y=YC+XI
5991+ 3B70 22 42 55             ld      (Y1),HL         ; store Y
5992+ 3B73 CD C7 3B             call    VALIDY          ; check if Y is valid (0~191)
5993+ 3B76 D4 52 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5994+ 3B79 2A 48 55     CNTCL6: ld      HL,(XC)
5995+ 3B7C ED 5B 50 55          ld      DE,(YI)
5996+ 3B80 19                   add     HL,DE           ; X=XC+YI
5997+ 3B81 22 40 55             ld      (X1),HL         ; store X
5998+ 3B84 CD C2 3B             call    VALIDX          ; check if X is valid (0~255)
5999+ 3B87 DA 9D 3B             jp      C,CNTCL7        ; if Carry is set, X is not valid
6000+ 3B8A AF                   xor     A               ; clear Carry
6001+ 3B8B 2A 4A 55             ld      HL,(YC)
6002+ 3B8E ED 5B 4E 55          ld      DE,(XI)
6003+ 3B92 ED 52                sbc     HL,DE           ; Y=YC-XI
6004+ 3B94 22 42 55             ld      (Y1),HL         ; store Y
6005+ 3B97 CD C7 3B             call    VALIDY          ; check if Y is valid (0~191)
6006+ 3B9A D4 52 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
6007+ 3B9D AF           CNTCL7: xor     A               ; clear Carry
6008+ 3B9E 2A 48 55             ld      HL,(XC)
6009+ 3BA1 ED 5B 50 55          ld      DE,(YI)
6010+ 3BA5 ED 52                sbc     HL,DE           ; X=XC-YI
6011+ 3BA7 22 40 55             ld      (X1),HL         ; store X
6012+ 3BAA CD C2 3B             call    VALIDX          ; check if X is valid (0~255)
6013+ 3BAD D8                   ret     C               ; if Carry is set, X is not valid
6014+ 3BAE AF                   xor     A               ; clear Carry
6015+ 3BAF 2A 4A 55             ld      HL,(YC)
6016+ 3BB2 ED 5B 4E 55          ld      DE,(XI)
6017+ 3BB6 ED 52                sbc     HL,DE           ; Y=YC-XI
6018+ 3BB8 22 42 55             ld      (Y1),HL         ; store Y
6019+ 3BBB CD C7 3B             call    VALIDY          ; check if Y is valid (0~191)
6020+ 3BBE D4 52 38             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
6021+ 3BC1 C9                   ret                     ; return to caller
6022+ 3BC2
6023+ 3BC2              ; check if X,Y coordinates are valid: 0<=X<=255 and 0<=Y<=191
6024+ 3BC2              ; input: HL (value to check), can be negative
6025+ 3BC2              ; output: CARRY flag: reset => VALID  //  set => NOT VALID
6026+ 3BC2              ; destroys: A
6027+ 3BC2 AF           VALIDX: xor     A               ; reset A
6028+ 3BC3 B4                   or      H               ; check if H is 0 (this means that X is in range 0~255 and not negative)
6029+ 3BC4 C8                   ret     Z               ; yes, we can return (C is clear)
6030+ 3BC5 37                   scf                     ; set Carry flag to raise error
6031+ 3BC6 C9                   ret                     ; return to caller
6032+ 3BC7
6033+ 3BC7 AF           VALIDY: xor     A               ; reset A
6034+ 3BC8 B4                   or      H               ; check if H is 0 (this means that Y is in range 0~255 and not negative)
6035+ 3BC9 28 02                jr      Z,CNTVALY       ; yes, continue checking
6036+ 3BCB 37                   scf                     ; no, raise error by setting Carry flag
6037+ 3BCC C9                   ret                     ; return to caller
6038+ 3BCD 7D           CNTVALY:ld      A,L
6039+ 3BCE FE C0                cp      $C0             ; is Y<192? Carry is set if Y<192
6040+ 3BD0 3F                   ccf                     ; invert Carry, so Carry=0 means OK, Carry=1 means ERROR
6041+ 3BD1 C9                   ret                     ; return to caller
6042+ 3BD2
6043+ 3BD2
6044+ 3BD2
6045+ 3BD2              ; cleat TMPBFR1-4 buffers before using them
6046+ 3BD2 AF           CLRTMBF:xor     A               ; reset A
6047+ 3BD3 E5                   push    HL              ; store HL
6048+ 3BD4 C5                   push    BC              ; store BC
6049+ 3BD5 21 40 55             ld      HL,TMPBFR1      ; address of 1st location
6050+ 3BD8 06 08                ld      B,$08           ; 8 locations
6051+ 3BDA 77           RPCLTMB:ld      (HL),A          ; clear byte
6052+ 3BDB 23                   inc     HL              ; next location
6053+ 3BDC 10 FC                djnz    RPCLTMB         ; repeat
6054+ 3BDE C1                   pop     BC              ; retrieve BC
6055+ 3BDF E1                   pop     HL              ; retrieve HL
6056+ 3BE0 C9                   ret                     ; return to caller
6057+ 3BE1
6058+ 3BE1
6059+ 3BE1              ; clear VIDEOBUFF before using it as temp buffer
6060+ 3BE1 AF           CLRVDBF:xor     A               ; clear A
6061+ 3BE2 C5                   push    BC              ; store BC
6062+ 3BE3 E5                   push    HL              ; store HL
6063+ 3BE4 06 28                ld      B,$28           ; 40 cells
6064+ 3BE6 21 48 55             ld      HL,VIDEOBUFF    ; address of 1st cell
6065+ 3BE9 77           RPTCVBF:ld      (HL),A          ; clear cell
6066+ 3BEA 23                   inc     HL              ; next cell
6067+ 3BEB 10 FC                djnz    RPTCVBF         ; repeat
6068+ 3BED E1                   pop     HL              ; retrieve HL
6069+ 3BEE C1                   pop     BC              ; retrieve BC
6070+ 3BEF C9                   ret                     ; return to caller
6071+ 3BF0
6072+ 3BF0
6073+ 3BF0              ; check if a color is passed as argument with PLOT, DRAW, and CIRCLE
6074+ 3BF0              ; commands. If not present, the default foreground color will be used
6075+ 3BF0 3A 3E 55     CLRPRM: ld      A,(FRGNDCLR)    ; load foreground color
6076+ 3BF3 32 44 55             ld      (TMPBFR3),A     ; store into temp buffer
6077+ 3BF6 2B                   dec     HL              ; dec 'cos GETCHR INCs
6078+ 3BF7 CD 1B 1D             call    GETCHR          ; Get next character
6079+ 3BFA C8                   ret     Z               ; return foreground color if nothing follows
6080+ 3BFB CD D2 1A             call    CHKSYN          ; Make sure ',' follows
6081+ 3BFE 2C                   defb    ','
6082+ 3BFF CD 32 2A             call    GETINT          ; get value
6083+ 3C02 CD F5 35             call    CHKCLR0         ; check if color is in range 0~15
6084+ 3C05 32 44 55             ld      (TMPBFR3),A     ; store color into temp buffer
6085+ 3C08 C9                   ret                     ; return to caller
6086+ 3C09
6087+ 3C09
6088+ 3C09              ; no graphics mode error: raised when a graphics command is invoked
6089+ 3C09              ; out of graphic 2 mode.
6090+ 3C09 1E 2A        GMERR:  ld      E,GM            ; load Graphics Mode Error flag
6091+ 3C0B C3 EC 17             jp      ERROR           ; print error
6092+ 3C0E
6093+ 3C0E
6094+ 3C0E              ; set a serial port: params are PORT,BPS,DATA,PARITY,STOP
6095+ 3C0E              ; PORT=1/2; BPS=1,200~57,600 (see below), DATA=5/6/7/8
6096+ 3C0E              ; PARITY: 0=no parity; 1=ODD parity; 2=EVEN parity;
6097+ 3C0E              ; STOP=0/1/2/3: 0=0 bit; 1=1 bit; 2=1.5 bits; 3=2 bits
6098+ 3C0E              ; PORT 1 acts as a char device; PORT 2 acts as a block device
6099+ 3C0E              ; DATA,PARITY, and STOP are optional: if nothing follows BPS,
6100+ 3C0E              ; they are assumed to be 8,0,1 resp.
6101+ 3C0E              PRTNUM  equ     VIDEOBUFF
6102+ 3C0E              BPS     equ     PRTNUM+$01
6103+ 3C0E              DATABT  equ     BPS+$02
6104+ 3C0E              PARBT   equ     DATABT+$01
6105+ 3C0E              STPBT   equ     PARBT+$01
6106+ 3C0E              SIOBFR  equ     STPBT+$01
6107+ 3C0E CD 32 2A     SERIAL: call    GETINT          ; get port #
6108+ 3C11 A7                   and     A               ; is it zero?
6109+ 3C12 CA E6 1D             jp      Z,FCERR         ; yes, error
6110+ 3C15 FE 03                cp      $03             ; is it 1 or 2?
6111+ 3C17 D2 37 3E             jp      NC,SCERR        ; no, error
6112+ 3C1A 32 48 55             ld      (PRTNUM),A      ; store port number into a temp buffer
6113+ 3C1D CD D2 1A             call    CHKSYN          ; Make sure ',' follows
6114+ 3C20 2C                   defb    ','
6115+ 3C21 2B                   dec     HL
6116+ 3C22 CD 1B 1D             call    GETCHR          ; check what's following
6117+ 3C25 CA D2 17             jp      Z,SNERR         ; error if nothing follows
6118+ 3C28 30 05                jr      NC,SERVAR       ; it's not a number, try a variable
6119+ 3C2A CD EB 1D             call    ATOH            ; get bps (returned into DE)
6120+ 3C2D 18 0F                jr      CHKZSER         ; jump over
6121+ 3C2F CD AC 21     SERVAR: call    GETNUM          ; get number
6122+ 3C32 CD B9 2F             call    TSTSGN          ; check value
6123+ 3C35 FA E6 1D             jp      M,FCERR         ; negative - illegal function call
6124+ 3C38 3A 97 55             ld      A,(FPEXP)       ; Get integer value to DE
6125+ 3C3B CD 61 30             call    FPINT           ; get integer number into BCDE - drop BC 'cause isn't necessary
6126+ 3C3E 7A           CHKZSER:ld      A,D             ; bps is into DE - move MSB into A
6127+ 3C3F B3                   or      E               ; check if bps=0
6128+ 3C40 20 3A                jr      NZ,CNTSER       ; no, continue checking
6129+ 3C42                      ; if baud rate is 0, then close the serial comm.
6130+ 3C42 3A 48 55     RSTSERS:ld      A,(PRTNUM)      ; yes, so reset the channel. First, load port number
6131+ 3C45 3D                   dec     A               ; subtract 1, so that serial channel is 0=>A and 1=>B
6132+ 3C46 C6 22                add     SIO_CA          ; find correct channel
6133+ 3C48 4F                   ld      C,A             ; store serial channel
6134+ 3C49 F3                   di                      ; disable INTs
6135+ 3C4A AF                   xor     A               ; reset A
6136+ 3C4B 16 01                ld      D,$01           ; start from WR1
6137+ 3C4D 06 05                ld      B,$05           ; 5 registers
6138+ 3C4F ED 51        RPTRSSR:out     (C),D           ; select register
6139+ 3C51 ED 79                out     (C),A           ; reset register
6140+ 3C53 14                   inc     D               ; next register
6141+ 3C54 10 F9                djnz    RPTRSSR         ; repeat
6142+ 3C56 3E 30                ld      A,%00110000     ; write into WR0: error reset, select WR0
6143+ 3C58 ED 79                out     (C),A           ; send command to serial channel
6144+ 3C5A 3E 18                ld      A,%00011000     ; write into WR0: channel reset
6145+ 3C5C ED 79                out     (C),A           ; send command to serial channel
6146+ 3C5E FB                   ei                      ; re-enable INTs
6147+ 3C5F E5                   push    HL              ; store HL
6148+ 3C60 21 82 55             ld      HL,SERIALS_EN   ; serials enabled status byte
6149+ 3C63 DB 01                in      A,(PIO_DB)      ; read status LEDs
6150+ 3C65 CB 41                bit     0,C             ; check serial port
6151+ 3C67 20 09                jr      NZ,SRPT2        ; if bit is set, jump to port 2
6152+ 3C69 CB B7                res     6,A             ; it's port 1
6153+ 3C6B CB A7                res     4,A             ; remove possible error LED
6154+ 3C6D CB 86                res     0,(HL)          ; disable port 1
6155+ 3C6F C3 78 3C             jp      SERLED          ; jump over
6156+ 3C72 CB BF        SRPT2:  res     7,A             ; it's port 2
6157+ 3C74 CB AF                res     5,A             ; remove possible error LED
6158+ 3C76 CB 8E                res     1,(HL)          ; disable port 2
6159+ 3C78 D3 01        SERLED: out     (PIO_DB),A      ; send new configuration
6160+ 3C7A E1                   pop     HL              ; retrieve HL
6161+ 3C7B C9                   ret                     ; return to caller
6162+ 3C7C                      ; check if bps=1, meaning reactivate RX on serial
6163+ 3C7C 7A           CNTSER: ld      A,D
6164+ 3C7D B2                   or      D               ; check if bps<>1 by first checking D=0
6165+ 3C7E 20 36                jr      NZ,CNTSER2      ; if not, jump over
6166+ 3C80 7B                   ld      A,E             ; then by checking that
6167+ 3C81 FE 01                cp      $01             ; E=1
6168+ 3C83 20 31                jr      NZ,CNTSER2      ; if not, jump over
6169+ 3C85 3A 48 55             ld      A,(PRTNUM)      ; load port number
6170+ 3C88 57                   ld      D,A             ; store port on D
6171+ 3C89 3A 82 55             ld      A,(SERIALS_EN)  ; load address of serial status cell
6172+ 3C8C A2                   and     D               ; check status
6173+ 3C8D CA 37 3E             jp      Z,SCERR         ; port not open, raise error
6174+ 3C90 F3                   di                      ; disable INTs
6175+ 3C91 7A                   ld      A,D             ; move port # into A
6176+ 3C92 5F                   ld      E,A             ; and also into E
6177+ 3C93 87                   add     A
6178+ 3C94 87                   add     A               ; move A to left times 2
6179+ 3C95 57                   ld      D,A             ; move value into D
6180+ 3C96 3A 82 55             ld      A,(SERIALS_EN)  ; load serial status byte
6181+ 3C99 B2                   or      D               ; re-enable RX
6182+ 3C9A 32 82 55             ld      (SERIALS_EN),A  ; store new serial status
6183+ 3C9D 7B                   ld      A,E             ; recover port #
6184+ 3C9E 3D                   dec     A               ; check port
6185+ 3C9F 20 0A                jr      NZ,CNTRX2       ; port is #2
6186+ 3CA1 CD E3 01             call    SIO_A_EI        ; re-enable RX on port 1
6187+ 3CA4 DB 01                in      A,(PIO_DB)      ; load status LEDs
6188+ 3CA6 CB A7                res     4,A             ; remove error LED
6189+ 3CA8 C3 B2 3C             jp      RXEND           ; terminate setting
6190+ 3CAB CD EB 01     CNTRX2: call    SIO_B_EI        ; re-enable RX on port 2
6191+ 3CAE DB 01                in      A,(PIO_DB)      ; load status LEDs
6192+ 3CB0 CB AF                res     5,A             ; remove error LED
6193+ 3CB2 D3 01        RXEND:  out     (PIO_DB),A      ; set new status for LEDs
6194+ 3CB4 FB                   ei                      ; re-enable INTs
6195+ 3CB5 C9                   ret                     ; return to caller
6196+ 3CB6                      ; set serial port comm.
6197+ 3CB6 D5           CNTSER2:push    DE              ; store BPS
6198+ 3CB7 3A 48 55             ld      A,(PRTNUM)      ; load port number
6199+ 3CBA 57                   ld      D,A             ; move port # into D
6200+ 3CBB 3A 82 55             ld      A,(SERIALS_EN)  ; check if serial port is already open
6201+ 3CBE A2                   and     D               ; by ANDing A with D
6202+ 3CBF D1                   pop     DE              ; retrieve BPS
6203+ 3CC0 CA C8 3C             jp      Z,CNTSER3       ; not open, continue
6204+ 3CC3 1E 2E                ld      E,SA            ; already open, so raise a "Serial Port Already Error"
6205+ 3CC5 C3 EC 17             jp      ERROR           ; and leave
6206+ 3CC8 E5           CNTSER3:push    HL              ; store HL
6207+ 3CC9 21 00 E1             ld      HL,$E100        ; check bps. start with HL=57,600
6208+ 3CCC CD F9 40             call    CMP16           ; is bps<=57,600?
6209+ 3CCF E1                   pop     HL              ; but first, recover HL
6210+ 3CD0 DA 37 3E             jp      C,SCERR         ; no (bps>57,600) then error
6211+ 3CD3 ED 53 49 55          ld      (BPS),DE        ; store bps
6212+ 3CD7 2B                   dec     HL              ; dec 'cos GETCHR INCs
6213+ 3CD8 CD 1B 1D             call    GETCHR          ; Get next character
6214+ 3CDB CA 13 3D             jp      Z,DEFSER        ; defaults if nothing follows
6215+ 3CDE CD D2 1A             call    CHKSYN          ; Make sure ',' follows
6216+ 3CE1 2C                   defb    ','
6217+ 3CE2 CD 32 2A             call    GETINT          ; get data bits
6218+ 3CE5 FE 05                cp      $05             ; is it <5?
6219+ 3CE7 DA 37 3E             jp      C,SCERR         ; yes, error
6220+ 3CEA FE 09                cp      $09             ; is it >=9?
6221+ 3CEC D2 E6 1D             jp      NC,FCERR        ; yes, error
6222+ 3CEF 32 4B 55             ld      (DATABT),A      ; store data bits
6223+ 3CF2 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
6224+ 3CF5 2C                   defb    ','
6225+ 3CF6 CD 32 2A             call    GETINT          ; get parity bits
6226+ 3CF9 BF FE 03             cp      A,$03           ; check if parity is in range 0~2
6227+ 3CFC D2 37 3E             jp      NC,SCERR        ; no, error
6228+ 3CFF 32 4C 55             ld      (PARBT),A       ; store parity
6229+ 3D02 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
6230+ 3D05 2C                   defb    ','
6231+ 3D06 CD 32 2A             call    GETINT          ; get stop bits
6232+ 3D09 FE 03                cp      $03             ; is it >=3?
6233+ 3D0B D2 37 3E             jp      NC,SCERR        ; yes, error
6234+ 3D0E 32 4D 55             ld      (STPBT),A       ; store stop bits
6235+ 3D11 18 0D                jr      SETSER          ; jump to set serial
6236+ 3D13 3E 08        DEFSER: ld      A,$08           ; 8 bits for data
6237+ 3D15 32 4B 55             ld      (DATABT),A
6238+ 3D18 AF                   xor     A               ; no parity bit
6239+ 3D19 32 4C 55             ld      (PARBT),A
6240+ 3D1C 3C                   inc     A               ; 1 bit for stop
6241+ 3D1D 32 4D 55             ld      (STPBT),A
6242+ 3D20                      ; check if bps are legal
6243+ 3D20 E5           SETSER: push    HL              ; store HL
6244+ 3D21 D5                   push    DE              ; store DE
6245+ 3D22 DD E5                push    IX              ; store IX
6246+ 3D24 DD 21 12 3E          ld      IX,SUP_BPS      ; allowed BPSs
6247+ 3D28 06 0B                ld      B,$0B           ; 11 items
6248+ 3D2A 0E 00                ld      C,$00           ; reset pointer
6249+ 3D2C 2A 49 55     CKBPS:  ld      HL,(BPS)        ; load BPS
6250+ 3D2F DD 5E 00             ld      E,(IX+0)        ; load LSB of item
6251+ 3D32 DD 56 01             ld      D,(IX+1)        ; load MSB of item
6252+ 3D35 CD F9 40             call    CMP16           ; is it equal?
6253+ 3D38 CA 45 3D             jp      Z,SET_PT        ; yes, found a correspondance
6254+ 3D3B DD 23                inc     IX
6255+ 3D3D DD 23                inc     IX              ; no, go to next entry
6256+ 3D3F 0C                   inc     C               ; increment pointer
6257+ 3D40 10 EA                djnz    CKBPS           ; repeat for 10 entries
6258+ 3D42 C3 33 3E             jp      SCERR1          ; if nothing found, raise an error
6259+ 3D45              SET_PT: ;init CTC CH0: CH0 provides RX/TX clock to SIO port A
6260+ 3D45                      ; TO0 output frequency=INPUT CLK/time constant. Time constant is set to get 16 times
6261+ 3D45                      ; the requested baud rate. I.e., if bps is 19,200 then time constast is set to 6 because
6262+ 3D45                      ; 1,843,200/6 = 307,200 Hz (that is 19,200 x 16)
6263+ 3D45 F3                   di                      ; disable INTs
6264+ 3D46 06 00                ld      B,$00           ; reset B
6265+ 3D48 21 28 3E             ld      HL,CTC_CFG      ; address of first CTC divider
6266+ 3D4B 09                   add     HL,BC           ; adjust for correct CTC divider
6267+ 3D4C 0E 10                ld      C,CTC_CH0       ; CTC channel 0
6268+ 3D4E 3A 48 55             ld      A,(PRTNUM)      ; load port number
6269+ 3D51 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6270+ 3D52 DA 56 3D             jp      C,SET_CTC       ; port 1 => ch. 0, so continue
6271+ 3D55 0C                   inc     C               ; port 2 => ch. 1, increment address port into C
6272+ 3D56 3E 47        SET_CTC:ld      A,%01000111     ; interrupt off, counter mode, prsc=16 (doesn't matter), ext. start,
6273+ 3D58                                              ; start upon loading time constant, time constant follows, sw reset, command word
6274+ 3D58 ED 79                out     (C),A           ; configure CTC channel
6275+ 3D5A 7E                   ld      A,(HL)          ; load CTC divider
6276+ 3D5B ED 79                out     (C),A           ; send divider
6277+ 3D5D                      ; configure SIO
6278+ 3D5D 21 36 03             ld      HL,SIO_A_SETS   ; load default settings for SIO
6279+ 3D60 11 4E 55             ld      DE,SIOBFR       ; into a temp buffer
6280+ 3D63 01 0A 00             ld      BC,$000A        ; 10 items to copy
6281+ 3D66 ED B0                ldir                    ; copy SIO settings into TEMP buffer
6282+ 3D68 3A 53 55             ld      A,(SIOBFR+5)    ; load WR5 setting
6283+ 3D6B 47                   ld      B,A             ; move it into B
6284+ 3D6C 3A 4B 55             ld      A,(DATABT)      ; load DATA bits
6285+ 3D6F FE 05                cp      $05             ; is it 5 bits?
6286+ 3D71 20 06                jr      NZ,BITS6        ; no, jump over
6287+ 3D73 CB B0                res     6,B
6288+ 3D75 CB A8                res     5,B             ; set D6 & D5 to 0
6289+ 3D77 18 19                jr      SETPAR          ; jump to set parity
6290+ 3D79 FE 06        BITS6:  cp      $06             ; is it 6 bits?
6291+ 3D7B 20 06                jr      NZ,BITS7        ; no, jump over
6292+ 3D7D CB F0                set     6,B
6293+ 3D7F CB A8                res     5,B             ; set D6 & D5 to 1,0
6294+ 3D81 18 0F                jr      SETPAR          ; jump to set parity
6295+ 3D83 FE 07        BITS7:  cp      $07             ; is it 7 bits?
6296+ 3D85 20 07                jr      NZ,BITS8        ; no, jump over
6297+ 3D87 CB B0                res     6,B
6298+ 3D89 CB E8                set     5,B             ; set D6 & D5 to 0,1
6299+ 3D8B C3 92 3D             jp      SETPAR          ; jump to set parity
6300+ 3D8E CB F0        BITS8:  set     6,B
6301+ 3D90 CB E8                set     5,B             ; set D6 & D5 to 1,1
6302+ 3D92 21 83 55     SETPAR: ld      HL,SERABITS     ; load address for storing data bits
6303+ 3D95 3A 48 55             ld      A,(PRTNUM)      ; check serial port number
6304+ 3D98 3D                   dec     A               ; is it port #1?
6305+ 3D99 CA 9D 3D             jp      Z,SETPAR2       ; yes, jump over
6306+ 3D9C 23                   inc     HL              ; port #2, use SERBBITS instead
6307+ 3D9D 78           SETPAR2:ld      A,B             ; retrieve DATA bits
6308+ 3D9E 32 53 55             ld      (SIOBFR+5),A    ; save DATA bits
6309+ 3DA1 E6 60                and     %01100000       ; filter only D5&D6 bits
6310+ 3DA3 87                   add     A,A             ; shift left times 1
6311+ 3DA4 77                   ld      (HL),A          ; store for SIO_EI & SIO_DI functions
6312+ 3DA5 3A 4D 55             ld      A,(STPBT)       ; load STOP bits
6313+ 3DA8 87                   add     A,A
6314+ 3DA9 87                   add     A,A             ; 2 left shifts
6315+ 3DAA 47                   ld      B,A             ; move forming byte into B
6316+ 3DAB 3A 4C 55             ld      A,(PARBT)       ; load PARITY setting
6317+ 3DAE A7                   and     A               ; is it 0?
6318+ 3DAF CA BA 3D             jp      Z,STRPAR        ; yes, jump over
6319+ 3DB2 CB C0                set     0,B             ; set PARITY on
6320+ 3DB4 3D                   dec     A               ; is parity ODD?
6321+ 3DB5 CA BA 3D             jp      Z,STRPAR        ; yes, so jump over
6322+ 3DB8 CB C8                set     1,B             ; no, it's EVEN so set the corresponding bit
6323+ 3DBA 3A 51 55     STRPAR: ld      A,(SIOBFR+3)    ; load WR4 setting
6324+ 3DBD E6 F0                and     %11110000       ; reset STOP & PARITY bits
6325+ 3DBF B0                   or      B               ; set new STOP & PARITY bits
6326+ 3DC0 32 51 55             ld      (SIOBFR+3),A    ; store new value
6327+ 3DC3                      ;set up TX and RX:
6328+ 3DC3                      ; the followings are settings for channel A
6329+ 3DC3 21 4E 55             ld      HL,SIOBFR       ; settings for SIO ch. A
6330+ 3DC6 06 06                ld      B,$06           ; 6 bytes to send
6331+ 3DC8 0E 22                ld      C,SIO_CA        ; I/O address of SIO ch.A
6332+ 3DCA 3A 48 55             ld      A,(PRTNUM)      ; load port number
6333+ 3DCD 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6334+ 3DCE DA D2 3D             jp      C,SRLCNT        ; port 1, continue
6335+ 3DD1 0C                   inc     C               ; port 2, increment address port into C
6336+ 3DD2 ED B3        SRLCNT: otir                    ; send bytes to SIO
6337+ 3DD4                      ; the following are settings for channel B (don't need to load HL since settings are contigous)
6338+ 3DD4 06 04                ld      B,$04           ; other 4 bytes to send
6339+ 3DD6 51                   ld      D,C             ; store port address into D
6340+ 3DD7 0E 23                ld      C,SIO_CB        ; I/O address of SIO ch.B
6341+ 3DD9 ED B3                otir                    ; send bytes to SIO
6342+ 3DDB                      ; the following are settings for selected channel
6343+ 3DDB 3E 01                ld      A,$01           ; write into WR0: select WR1
6344+ 3DDD 4A                   ld      C,D             ; retrieve port address
6345+ 3DDE ED 79                out     (C),A
6346+ 3DE0 3E 18                ld      A,%00011000     ; interrupts on every RX char; parity is no special condition;
6347+ 3DE2                                              ; buffer overrun is special condition
6348+ 3DE2 ED 79                out     (C),A
6349+ 3DE4 21 82 55             ld      HL,SERIALS_EN
6350+ 3DE7 3A 48 55             ld      A,(PRTNUM)      ; retrieve serial channel
6351+ 3DEA 3D                   dec     A               ; channel A?
6352+ 3DEB 20 10                jr      NZ,ENCHB        ; no, jump over
6353+ 3DED CD E3 01             call    SIO_A_EI        ; enable RX on SIO channel A
6354+ 3DF0 CB C6                set     0,(HL)          ; set serial port 1 status ON
6355+ 3DF2 CB D6                set     2,(HL)          ; set serial port 1 RX ON
6356+ 3DF4                      ; back to normal running
6357+ 3DF4 FB                   ei                      ; re-enable INTs
6358+ 3DF5 DB 01                in      A,(PIO_DB)      ; load status LEDs
6359+ 3DF7 CB F7                set     6,A             ; set status LED on
6360+ 3DF9 CB A7                res     4,A             ; set error LED off
6361+ 3DFB 18 0E                jr      EXNRM           ; leave
6362+ 3DFD CD EB 01     ENCHB:  call    SIO_B_EI        ; enable RX on SIO channel B
6363+ 3E00 CB CE                set     1,(HL)          ; set serial port 2 status ON
6364+ 3E02 CB DE                set     3,(HL)          ; set serial port 2 RX ON
6365+ 3E04                      ; back to normal running
6366+ 3E04 FB                   ei                      ; re-enable INTs
6367+ 3E05 DB 01                in      A,(PIO_DB)      ; load status LEDs
6368+ 3E07 CB FF                set     7,A             ; set status LED on
6369+ 3E09 CB AF                res     5,A             ; set error LED off
6370+ 3E0B D3 01        EXNRM:  out     (PIO_DB),A      ; send new configuration
6371+ 3E0D DD E1                pop     IX              ; retrieve IX
6372+ 3E0F D1                   pop     DE              ; retrieve DE
6373+ 3E10 E1                   pop     HL              ; retrieve HL
6374+ 3E11 C9                   ret                     ; return to caller
6375+ 3E12
6376+ 3E12              ; allowed bps (Bauds per second)
6377+ 3E12 00 E1 00 96  SUP_BPS:defw    57600,38400,28800,19200,14400,9600,4800,3600,2400,1200,600
6377+ 3E16 80 70 00 4B
6377+ 3E1A 40 38 80 25
6377+ 3E1E C0 12 10 0E
6377+ 3E22 60 09 B0 04
6377+ 3E26 58 02
6378+ 3E28              ; corresponding CTC divider
6379+ 3E28 02 03 04 06  CTC_CFG:defb    2,3,4,6,8,12,24,32,48,96,192
6379+ 3E2C 08 0C 18 20
6379+ 3E30 30 60 C0
6380+ 3E33
6381+ 3E33
6382+ 3E33              ; serial configuration error
6383+ 3E33 DD E1        SCERR1: pop     IX              ; retrieve IX
6384+ 3E35 D1                   pop     DE              ; retrieve DE
6385+ 3E36 E1                   pop     HL              ; retrieve HL
6386+ 3E37 1E 2C        SCERR:  ld      E,SC            ; Serial Configuration Error
6387+ 3E39 C3 EC 17             jp      ERROR           ; print error
6388+ 3E3C
6389+ 3E3C
6390+ 3E3C              ; serial buffer overrun
6391+ 3E3C CD E8 1F     SOERR:  call    PRNTCRLF
6392+ 3E3F 1E 30                ld      E,SO            ; Serial Buffer Overrun
6393+ 3E41 C3 EC 17             jp      ERROR
6394+ 3E44
6395+ 3E44
6396+ 3E44              ; check for direct mode:
6397+ 3E44              ; Z is set if in direct mode, reset otherwise
6398+ 3E44 E5           DIRMOD: push    HL              ; Save code string address
6399+ 3E45 2A ED 53             ld      HL,(LINEAT)     ; Get current line number
6400+ 3E48 23                   inc     HL              ; -1 means direct statement
6401+ 3E49 7C                   ld      A,H
6402+ 3E4A B5                   or      L
6403+ 3E4B E1                   pop     HL              ; Restore code string address
6404+ 3E4C C9                   ret
6405+ 3E4D
6406+ 3E4D
6407+ 3E4D              ; HELP lists the line program where an error occured
6408+ 3E4D CD 44 3E     HELP:   call    DIRMOD          ; check if in direct mode
6409+ 3E50 C2 66 3E             jp      NZ,HLPERR       ; raise error if in indirect mode
6410+ 3E53 E5                   push    HL              ; store HL
6411+ 3E54 2A EF 53             ld      HL,(HLPLN)      ; load HELP line
6412+ 3E57 23                   inc     HL              ; increment HL
6413+ 3E58 7C                   ld      A,H
6414+ 3E59 B5                   or      L               ; check if there is a line into the HELP reg.
6415+ 3E5A E1                   pop     HL
6416+ 3E5B CA 66 3E             jp      Z,HLPERR        ; no line found, raise error
6417+ 3E5E ED 5B EF 53          ld      DE,(HLPLN)      ; recover line
6418+ 3E62 C1                   pop     BC              ; remove BC from stack since it's not needed anymore for LIST
6419+ 3E63 C3 68 1B             jp      LST01H          ; jump to list line
6420+ 3E66 1E 32        HLPERR: ld      E,HP            ; HELP call error
6421+ 3E68 C3 EC 17             jp      ERROR           ; raise error
6422+ 3E6B
6423+ 3E6B
6424+ 3E6B              ; KEY command to list/modify function keys and auto-repeat
6425+ 3E6B 2B           KEY:    dec     HL              ; dec 'cos GETCHR INCs
6426+ 3E6C CD 1B 1D             call    GETCHR          ; Get next character
6427+ 3E6F CA EF 3E             jp      Z,LSTKEYS       ; jump if nothing follows
6428+ 3E72                      ; change FN keys
6429+ 3E72 CD 32 2A             call    GETINT          ; get a number
6430+ 3E75 A7                   and     A               ; is it 0?
6431+ 3E76 20 10                jr      NZ,KEYCH        ; no, jump over
6432+ 3E78 E5           RESFN:  push    HL              ; yes - reset FN keys to defaults
6433+ 3E79 D5                   push    DE              ; store HL & DE
6434+ 3E7A 21 C0 16             ld      HL,AUTORP       ; pointer to default auto-repeat delays and FN keys texts
6435+ 3E7D 11 F1 53             ld      DE,KEYDEL       ; pointer to destination
6436+ 3E80 01 82 00             ld      BC,$0082        ; 130 chars to be copied (2xauto-delay, 128xFN keys)
6437+ 3E83 ED B0                ldir                    ; restore default texts
6438+ 3E85 D1                   pop     DE              ; retrieve DE
6439+ 3E86 E1                   pop     HL              ; retrieve HL
6440+ 3E87 C9                   ret                     ; return to caller
6441+ 3E88 FE 09        KEYCH:  cp      $09             ; is it >= 9?
6442+ 3E8A D2 A2 3F             jp      NC,SETREP       ; yes - jump over
6443+ 3E8D 3D                   dec     A               ; FN key in range 0~7
6444+ 3E8E 87                   add     A,A             ; multiply A...
6445+ 3E8F 87                   add     A,A             ; ... times 4...
6446+ 3E90 87                   add     A,A             ; ... to get the correct...
6447+ 3E91 87                   add     A,A             ; ... offset fo FN key text
6448+ 3E92 32 40 55             ld      (TMPBFR1),A     ; store FN key offset...
6449+ 3E95 AF                   xor     A               ; ...in a...
6450+ 3E96 32 41 55             ld      (TMPBFR1+1),A   ; ...16-bit register
6451+ 3E99 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
6452+ 3E9C 2C                   defb    ','
6453+ 3E9D 44 4D                ld      BC,HL           ; copy address into BC
6454+ 3E9F CD BE 21             call    EVAL            ; Evaluate expression (in E there is the length)
6455+ 3EA2 E5                   push    HL              ; store string pointer
6456+ 3EA3 3A D2 54             ld      A,(TYPE)        ; Get variable type
6457+ 3EA6 B7                   or      A               ; Is it a string variable?
6458+ 3EA7 CA D2 17             jp      Z,SNERR         ; no - syntax error
6459+ 3EAA CD F7 27             call    GSTRCU          ; Current string to pool
6460+ 3EAD CD 08 30             call    LOADFP          ; Move string block data to (BC=pointer, DE=length)
6461+ 3EB0 7B                   ld      A,E             ; copy length into A
6462+ 3EB1 FE 11                cp      $11             ; is length > 16?
6463+ 3EB3 DA B8 3E             jp      C,DECLN1        ; no, jump over
6464+ 3EB6 1E 10                ld      E,$10           ; yes, so set length to 16
6465+ 3EB8 3E 10        DECLN1: ld      A,$10           ; calculate how many...
6466+ 3EBA 93                   sub     E               ; ...null chars needed to fill up...
6467+ 3EBB 57                   ld      D,A             ; ...the FN key text
6468+ 3EBC C5                   push    BC              ; store address of string
6469+ 3EBD ED 4B 40 55          ld      BC,(TMPBFR1)    ; load FN key offset
6470+ 3EC1 21 F3 53             ld      HL,FNKEYS       ; load address of FN keys texts
6471+ 3EC4 09                   add     HL,BC           ; get corrected address
6472+ 3EC5 C1                   pop     BC              ; retrieve address of string chars
6473+ 3EC6 0A           CPKEY:  ld      A,(BC)          ; load char from string
6474+ 3EC7 FE 0D                cp      CR              ; return?
6475+ 3EC9 CA D6 3E             jp      Z,CPKEY2        ; yes, store char
6476+ 3ECC FE 7B                cp      $7B             ; if char > "z" ?
6477+ 3ECE D2 D2 17             jp      NC,SNERR        ; yes - syntax error
6478+ 3ED1 FE 20                cp      $20             ; is char < space?
6479+ 3ED3 DA D2 17             jp      C,SNERR         ; yes - syntax error
6480+ 3ED6 FE 61        CPKEY2: cp      $61             ; is it >= 'a'?
6481+ 3ED8 DA DD 3E             jp      C,CPKEY3        ; no, continue
6482+ 3EDB E6 5F                and     %01011111       ; set letters to uppercase
6483+ 3EDD 77           CPKEY3: ld      (HL),A          ; store char
6484+ 3EDE 23                   inc     HL              ; next string char
6485+ 3EDF 03                   inc     BC              ; next free cell
6486+ 3EE0 1D                   dec     E               ; decrement E
6487+ 3EE1 20 E3                jr      NZ,CPKEY        ; repeat until 0
6488+ 3EE3 AF                   xor     A               ; null char
6489+ 3EE4 14                   inc     D               ; +1 to decrement below
6490+ 3EE5 15           CPKEY1: dec     D               ; how many null chars to insert?
6491+ 3EE6 CA ED 3E             jp      Z,CPKYEND       ; no more nulls, so exit
6492+ 3EE9 77                   ld      (HL),A          ; store it
6493+ 3EEA 23                   inc     HL              ; next cell
6494+ 3EEB 18 F8                jr      CPKEY1          ; repeat
6495+ 3EED E1           CPKYEND:pop     HL              ; retrieve pointer to string
6496+ 3EEE C9                   ret                     ; return to caller
6497+ 3EEF                                              ; list FN keys
6498+ 3EEF E5           LSTKEYS:push    HL              ; Save code string address
6499+ 3EF0 2A ED 53             ld      HL,(LINEAT)     ; Get current line number
6500+ 3EF3 23                   inc     HL              ; -1 means direct statement
6501+ 3EF4 7C                   ld      A,H
6502+ 3EF5 B5                   or      L
6503+ 3EF6 E1                   pop     HL              ; Restore code string address
6504+ 3EF7 C2 D2 17             jp      NZ,SNERR        ; raise error if in indirect mode
6505+ 3EFA E5                   push    HL              ; store HL
6506+ 3EFB D5                   push    DE              ; store DE
6507+ 3EFC 21 F3 53             ld      HL,FNKEYS       ; load starting address of FN keys text
6508+ 3EFF 0E 01                ld      C,$01           ; 8 function keys
6509+ 3F01 06 10        PRTK4:  ld      B,$10           ; 16 chars each
6510+ 3F03 11 C4 3F     PRTK2:  ld      DE,CHKEY1       ; message "KEY "
6511+ 3F06 CD 93 3F             call    PRTCKEY         ; print it
6512+ 3F09 79                   ld      A,C             ; load FN key
6513+ 3F0A C6 30                add     $30             ; get number in ASCI code
6514+ 3F0C CD DD 1A             call    OUTC            ; print it
6515+ 3F0F 11 C9 3F             ld      DE,CHKEY2       ; message ": ""
6516+ 3F12 CD 93 3F             call    PRTCKEY         ; print it
6517+ 3F15 3E 01                ld      A,$01           ; " opened
6518+ 3F17 32 40 55             ld      (TMPBFR1),A
6519+ 3F1A 7E           LDKEY:  ld      A,(HL)          ; retrieve char
6520+ 3F1B A7                   and     A               ; is it zero?
6521+ 3F1C CA 2F 3F             jp      Z,CNTLTK        ; yes, go next char
6522+ 3F1F CD 7B 3F             call    OPNQT           ; check if quotes are opened
6523+ 3F22 FE 22                cp      $22             ; check if char is "?
6524+ 3F24 CA 44 3F             jp      Z,PRTCHR        ; yes, print "chr$("
6525+ 3F27 FE 0D                cp      CR              ; is it a CR?
6526+ 3F29 CA 44 3F             jp      Z,PRTCHR        ; yes, print "chr$("
6527+ 3F2C CD DD 1A     PRTK3:  call    OUTC            ; no, just print it
6528+ 3F2F 23           CNTLTK: inc     HL              ; next char
6529+ 3F30 10 E8                djnz    LDKEY           ; continue until finished
6530+ 3F32 CD 69 3F             call    CLSQT           ; check if quotes are still open
6531+ 3F35 3E 0D                ld      A,CR            ; go next line
6532+ 3F37 CD DD 1A             call    OUTC            ; print it
6533+ 3F3A 0C                   inc     C               ; next FN key
6534+ 3F3B 79                   ld      A,C             ; check if...
6535+ 3F3C FE 09                cp      $09             ; finished keys?
6536+ 3F3E DA 01 3F             jp      C,PRTK4         ; no, repeat 1 more time
6537+ 3F41 D1                   pop     DE              ; retrieve DE
6538+ 3F42 E1                   pop     HL              ; retrieve HL
6539+ 3F43 C9                   ret                     ; return to caller
6540+ 3F44 E5           PRTCHR: push    HL              ; store HL
6541+ 3F45 CD 69 3F             call    CLSQT           ; check if quotes are closed
6542+ 3F48 3E 2B                ld      A,'+'           ; '+' char
6543+ 3F4A CD DD 1A             call    OUTC            ; print it
6544+ 3F4D 11 CC 3F             ld      DE,CHKEY3       ; address of "CHR$("
6545+ 3F50 CD 93 3F             call    PRTCKEY         ; print it
6546+ 3F53 E1                   pop     HL              ; recover HL
6547+ 3F54 23                   inc     HL              ; next char
6548+ 3F55 05                   dec     B               ; increment char counter
6549+ 3F56 11 D2 3F             ld      DE,CHKEY4       ; load address of RETURN
6550+ 3F59 7E                   ld      A,(HL)          ; load char
6551+ 3F5A FE 0D                cp      CR              ; is it a RETURN?
6552+ 3F5C 20 03                jr      NZ,PTCHR1       ; no, jump over
6553+ 3F5E 11 D5 3F             ld      DE,CHKEY5       ; yes, load address of "
6554+ 3F61 CD 93 3F     PTCHR1: call    PRTCKEY         ; print it
6555+ 3F64 3E 29                ld      A,')'           ; char )
6556+ 3F66 C3 2C 3F             jp      PRTK3           ; continue
6557+ 3F69 F5           CLSQT:  push    AF              ; store A
6558+ 3F6A 3A 40 55             ld      A,(TMPBFR1)     ; quote status
6559+ 3F6D A7                   and     A               ; are they closed?
6560+ 3F6E 28 09                jr      Z,CLSQT1        ; if yes, return
6561+ 3F70 3E 22                ld      A,$22           ; no, so close them
6562+ 3F72 CD DD 1A             call    OUTC            ; print "
6563+ 3F75 AF                   xor     A               ; set quotes
6564+ 3F76 32 40 55             ld      (TMPBFR1),A     ; as closed
6565+ 3F79 F1           CLSQT1: pop     AF              ; retrieve A
6566+ 3F7A C9                   ret                     ; return to caller
6567+ 3F7B F5           OPNQT:  push    AF              ; store A
6568+ 3F7C 3A 40 55             ld      A,(TMPBFR1)     ; quote status
6569+ 3F7F A7                   and     A               ; are they open?
6570+ 3F80 20 0F                jr      NZ,OPNQT1       ; if yes, return
6571+ 3F82 3E 2B                ld      A,'+'           ; no, so add '+
6572+ 3F84 CD DD 1A             call    OUTC            ; print it
6573+ 3F87 3E 22                ld      A,$22           ; and then open quotes
6574+ 3F89 CD DD 1A             call    OUTC            ; print them
6575+ 3F8C 3E 01                ld      A,$01           ; set quotes
6576+ 3F8E 32 40 55             ld      (TMPBFR1),A     ; as opened
6577+ 3F91 F1           OPNQT1: pop     AF              ; retrieve A
6578+ 3F92 C9                   ret                     ; return to caller
6579+ 3F93 F5           PRTCKEY:push    AF              ; store original char
6580+ 3F94 1A           PRTK1:  ld      A,(DE)          ; load char
6581+ 3F95 A7                   and     A               ; is it 0?
6582+ 3F96 CA A0 3F             jp      Z,PRTEND        ; yes, finished printing
6583+ 3F99 CD DD 1A             call    OUTC            ; no, print char
6584+ 3F9C 13                   inc     DE              ; next char
6585+ 3F9D C3 94 3F             jp      PRTK1           ; repeat
6586+ 3FA0 F1           PRTEND: pop     AF              ; retrieve AF
6587+ 3FA1 C9                   ret                     ; return to caller
6588+ 3FA2 FE 09        SETREP: cp      $09             ; is it special key 9? (stands for auto-repeat)
6589+ 3FA4 C2 D2 17             jp      NZ,SNERR        ; no, raise an error
6590+ 3FA7 CD D2 1A             call    CHKSYN          ; Check for comma
6591+ 3FAA 2C                   defb    ','
6592+ 3FAB CD 32 2A             call    GETINT          ; get a number
6593+ 3FAE 32 40 55             ld      (TMPBFR1),A     ; store it
6594+ 3FB1 CD D2 1A             call    CHKSYN          ; Check for comma
6595+ 3FB4 2C                   defb    ','
6596+ 3FB5 CD 32 2A             call    GETINT          ; get another number
6597+ 3FB8 E5                   push    HL              ; store HL
6598+ 3FB9 21 F2 53             ld      HL,AUTOKE       ; address of second cell for key auto-repeat
6599+ 3FBC 77                   ld      (HL),A          ; store auto-repeat delay
6600+ 3FBD 2B                   dec     HL              ; previous cell
6601+ 3FBE 3A 40 55             ld      A,(TMPBFR1)     ; retrieve value
6602+ 3FC1 77                   ld      (HL),A          ; store delay for auto-repeat
6603+ 3FC2 E1                   pop     HL              ; retrieve HL
6604+ 3FC3 C9                   ret
6605+ 3FC4 4B 45 59 20  CHKEY1: defb    "KEY ",0
6605+ 3FC8 00
6606+ 3FC9 3A 22 00     CHKEY2: defb    ":",34,0
6607+ 3FCC 63 68 72 24  CHKEY3: defb    "chr$(",0
6607+ 3FD0 28 00
6608+ 3FD2 31 33 00     CHKEY4: defb    "13",0
6609+ 3FD5 33 34 00     CHKEY5: defb    "34",0
6610+ 3FD8
6611+ 3FD8
6612+ 3FD8              ; HEX$(nn) Convert 16 bit number to Hexadecimal string
6613+ 3FD8 CD AF 21     HEX: 	call	TSTNUM          ; Verify it's a number
6614+ 3FDB CD D1 1D             call	DEINT           ; Get integer -32768 to 32767
6615+ 3FDE C5                   push	BC              ; Save contents of BC
6616+ 3FDF 21 99 55             ld      HL,PBUFF        ; load address of PBUFF into HL
6617+ 3FE2 7A                   ld      A,D             ; Get MSB into A
6618+ 3FE3 B7                   or      A               ; OR with LSB to see if param=0
6619+ 3FE4 28 0C                jr      Z,HEX2          ; Skip output if both high digits are zero
6620+ 3FE6 CD 0E 40             call    BYT2ASC         ; Convert D to ASCII
6621+ 3FE9 78                   ld      A,B             ; cechk if B
6622+ 3FEA FE 30                cp      '0'             ; is 0
6623+ 3FEC 28 02                jr      Z,HEX1          ; Don't store high digit if zero
6624+ 3FEE 70                   ld      (HL),B          ; Store it to PBUFF
6625+ 3FEF 23                   inc     HL              ; Next location
6626+ 3FF0 71           HEX1:   ld      (HL),C          ; Store C to PBUFF+1
6627+ 3FF1 23                   inc     HL              ; Next location
6628+ 3FF2 7B           HEX2:   ld      A,E             ; Get lower byte
6629+ 3FF3 CD 0E 40             call    BYT2ASC         ; Convert E to ASCII
6630+ 3FF6 7A                   ld      A,D
6631+ 3FF7 B7                   or      A
6632+ 3FF8 20 05                jr      NZ,HEX3         ; If upper byte was not zero then always print lower byte
6633+ 3FFA 78                   ld      A,B
6634+ 3FFB FE 30                cp      '0'             ; If high digit of lower byte is zero then don't print
6635+ 3FFD 28 02                jr      Z,HEX4
6636+ 3FFF 70           HEX3:   ld      (HL),B          ; to PBUFF+2
6637+ 4000 23                   inc     HL              ; Next location
6638+ 4001 71           HEX4:   ld      (HL),C          ; to PBUFF+3
6639+ 4002 23                   inc     HL              ; PBUFF+4 to zero
6640+ 4003 AF                   xor     A               ; Terminating character
6641+ 4004 77                   ld      (HL),A          ; Store zero to terminate
6642+ 4005 23                   inc     HL              ; Make sure PBUFF is terminated
6643+ 4006 77                   ld      (HL),A          ; Store the double zero there
6644+ 4007 C1                   pop     BC              ; Get BC back
6645+ 4008 21 99 55             ld      HL,PBUFF        ; Reset to start of PBUFF
6646+ 400B C3 44 26             jp      STR1            ; Convert the PBUFF to a string and return it
6647+ 400E 47           BYT2ASC:ld      B,A             ; Save original value
6648+ 400F E6 0F                and     $0F             ; Strip off upper nybble
6649+ 4011 FE 0A                cp      $0A             ; 0-9?
6650+ 4013 38 02                jr      C,ADD30         ; If A-F, add 7 more
6651+ 4015 C6 07                add     A,$07           ; Bring value up to ASCII A-F
6652+ 4017 C6 30        ADD30:  add     A,$30           ; And make ASCII
6653+ 4019 4F                   ld      C,A             ; Save converted char to C
6654+ 401A 78                   ld      A,B             ; Retrieve original value
6655+ 401B 0F                   rrca                    ; and Rotate it right
6656+ 401C 0F                   rrca
6657+ 401D 0F                   rrca
6658+ 401E 0F                   rrca
6659+ 401F E6 0F                and     $0F             ; Mask off upper nybble
6660+ 4021 FE 0A                cp      $0A             ; 0-9? < A hex?
6661+ 4023 38 02                jr      C,ADD301        ; Skip Add 7
6662+ 4025 C6 07                add     A,$07           ; Bring it up to ASCII A-F
6663+ 4027 C6 30        ADD301: add     A,$30           ; And make it full ASCII
6664+ 4029 47                   ld      B,A             ; Store high order byte
6665+ 402A C9                   ret
6666+ 402B
6667+ 402B              ; Convert "&Hnnnn" to FPREG
6668+ 402B              ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
6669+ 402B              ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
6670+ 402B EB           HEXTFP: ex      DE,HL           ; Move code string pointer to DE
6671+ 402C 21 00 00             ld      HL,$0000        ; Zero out the value
6672+ 402F CD 44 40             call    GETHEX          ; Check the number for valid hex
6673+ 4032 DA 64 40             jp      C,HXERR         ; First value wasn't hex, HX error
6674+ 4035 18 05                jr      HEXLP1          ; Convert first character
6675+ 4037 CD 44 40     HEXLP:  call    GETHEX          ; Get second and addtional characters
6676+ 403A 38 1F                jr      C,HEXIT         ; Exit if not a hex character
6677+ 403C 29           HEXLP1: add     HL,HL           ; Rotate 4 bits to the left
6678+ 403D 29                   add     HL,HL
6679+ 403E 29                   add     HL,HL
6680+ 403F 29                   add     HL,HL
6681+ 4040 B5                   or      L               ; Add in D0-D3 into L
6682+ 4041 6F                   ld      L,A             ; Save new value
6683+ 4042 18 F3                jr      HEXLP           ; And continue until all hex characters are in
6684+ 4044
6685+ 4044 13           GETHEX: inc     DE              ; Next location
6686+ 4045 1A                   ld      A,(DE)          ; Load character at pointer
6687+ 4046 FE 20                cp      SPC
6688+ 4048 CA 44 40             jp      Z,GETHEX        ; Skip spaces
6689+ 404B D6 30                sub     $30             ; Get absolute value
6690+ 404D D8                   ret     C               ; < "0", error
6691+ 404E FE 0A                cp      $0A
6692+ 4050 38 05                jr      C,NOSUB7        ; Is already in the range 0-9
6693+ 4052 D6 07                sub     $07             ; Reduce to A-F
6694+ 4054 FE 0A                cp      $0A             ; Value should be $0A-$0F at this point
6695+ 4056 D8                   ret     C               ; CY set if was :            ; < = > ? @
6696+ 4057 FE 10        NOSUB7: cp      $10             ; > Greater than "F"?
6697+ 4059 3F                   ccf
6698+ 405A C9                   ret                     ; CY set if it wasn't valid hex
6699+ 405B
6700+ 405B EB           HEXIT:  ex      DE,HL           ; Value into DE, Code string into HL
6701+ 405C 7A                   ld      A,D             ; Load DE into AC
6702+ 405D 4B                   ld      C,E             ; For prep to
6703+ 405E E5                   push    HL
6704+ 405F CD 95 25             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6705+ 4062 E1                   pop     HL
6706+ 4063 C9                   ret
6707+ 4064
6708+ 4064 DD 5C        HXERR:  ld      E,HX            ; ?HEX Error
6709+ 4066 C3 EC 17             jp      ERROR
6710+ 4069
6711+ 4069              ; BIN$(NN) Convert integer to a 1-16 char binary string
6712+ 4069 CD AF 21     BIN:    call    TSTNUM          ; Verify it's a number
6713+ 406C CD D1 1D             call    DEINT           ; Get integer -32768 to 32767
6714+ 406F C5           BIN2:   push    BC              ; Save contents of BC
6715+ 4070 21 99 55             ld      HL,PBUFF
6716+ 4073 06 11                ld      B,$11           ; One higher than max char count (16+1)
6717+ 4075              ZEROSUP:                        ; Suppress leading zeros
6718+ 4075 05                   dec     B               ; Max 16 chars
6719+ 4076 78                   ld      A,B
6720+ 4077 FE 01                cp      $01
6721+ 4079 28 08                jr      Z,BITOUT        ; Always output at least one character
6722+ 407B CB 13                rl      E
6723+ 407D CB 12                rl      D
6724+ 407F 30 F4                jr      NC,ZEROSUP
6725+ 4081 18 04                jr      BITOUT2
6726+ 4083 CB 13        BITOUT: rl      E
6727+ 4085 CB 12                rl      D               ; Top bit now in carry
6728+ 4087 3E 30        BITOUT2:ld      A,'0'           ; Char for '0'
6729+ 4089 CE 00                adc     A,$00           ; If carry set then '0' --> '1'
6730+ 408B 77                   ld      (HL),A
6731+ 408C 23                   inc     HL
6732+ 408D 05                   dec     B
6733+ 408E 20 F3                jr      NZ,BITOUT
6734+ 4090 AF                   xor     A               ; Terminating character
6735+ 4091 77                   ld      (HL),A          ; Store zero to terminate
6736+ 4092 23                   inc     HL              ; Make sure PBUFF is terminated
6737+ 4093 77                   ld      (HL),A          ; Store the double zero there
6738+ 4094 C1                   pop     BC
6739+ 4095 21 99 55             ld      HL,PBUFF
6740+ 4098 C3 44 26             jp      STR1
6741+ 409B
6742+ 409B              ; Convert "&Bnnnn" to FPREG
6743+ 409B              ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
6744+ 409B EB           BINTFP: ex      DE,HL           ; Move code string pointer to DE
6745+ 409C 21 00 00             ld      HL,$0000        ; Zero out the value
6746+ 409F CD B8 40             call    CHKBIN          ; Check the number for valid bin
6747+ 40A2 DA C6 40             jp      C,BINERR        ; First value wasn't bin, HX error
6748+ 40A5 D6 30        BINIT:  sub     '0'
6749+ 40A7 29                   add     HL,HL           ; Rotate HL left
6750+ 40A8 B5                   or      L
6751+ 40A9 6F                   ld      L,A
6752+ 40AA CD B8 40             call    CHKBIN          ; Get second and addtional characters
6753+ 40AD 30 F6                jr      NC,BINIT        ; Process if a bin character
6754+ 40AF EB                   ex      DE,HL           ; Value into DE, Code string into HL
6755+ 40B0 7A                   ld      A,D             ; Load DE into AC
6756+ 40B1 4B                   ld      C,E             ; For prep to
6757+ 40B2 E5                   push    HL
6758+ 40B3 CD 95 25             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6759+ 40B6 E1                   pop     HL
6760+ 40B7 C9                   ret
6761+ 40B8
6762+ 40B8              ; Char is in A, NC if char is 0 or 1
6763+ 40B8 13           CHKBIN: inc     DE
6764+ 40B9 1A                   ld      A,(DE)
6765+ 40BA FE 20                cp      SPC
6766+ 40BC CA B8 40             jp      Z,CHKBIN        ; Skip spaces
6767+ 40BF FE 30                cp      '0'             ; Set C if < '0'
6768+ 40C1 D8                   ret     C
6769+ 40C2 FE 32                cp      '2'
6770+ 40C4 3F                   ccf                     ; Set C if > '1'
6771+ 40C5 C9                   ret
6772+ 40C6
6773+ 40C6 1E 28        BINERR: ld      E,BN            ; ?BIN Error
6774+ 40C8 C3 EC 17             jp      ERROR
6775+ 40CB
6776+ 40CB
6777+ 40CB C3 08 00     MONOUT: jp      $0008           ; output a char
6778+ 40CE
6779+ 40CE
6780+ 40CE CD 4D 2A     RESET:  call    DISNMI          ; disable NMI vector
6781+ 40D1 3A 82 55             ld      A,(SERIALS_EN)  ; load status of serial lines
6782+ 40D4 E6 11                and     $11             ; are serial ports open?
6783+ 40D6 C4 42 3C             call    NZ,RSTSERS      ; yes, reset serials
6784+ 40D9 3A 85 55             ld      A,(DOS_EN)      ; is DOS enabled
6785+ 40DC A7                   and     A               ; if enabled, A<>0
6786+ 40DD C4 74 FD             call    NZ,CF_STANDBY   ; put CF into standby mode
6787+ 40E0 F3                   di                      ; disable INTs
6788+ 40E1 C3 04 53             jp      ROM2RAM         ; Restart
6789+ 40E4
6790+ 40E4
6791+ 40E4 3E 00        INITST: ld      A,$00           ; Clear break flag
6792+ 40E6 32 E7 53             ld      (BRKFLG),A
6793+ 40E9 C3 B3 12             jp      SYSINIT
6794+ 40EC
6795+ 40EC
6796+ 40EC F5           TSTBIT: push    AF              ; Save bit mask
6797+ 40ED A0                   and     B               ; Get common bits
6798+ 40EE C1                   pop     BC              ; Restore bit mask
6799+ 40EF B8                   cp      B               ; Same bit set?
6800+ 40F0 3E 00                ld      A,$00           ; Return 0 in A
6801+ 40F2 C9                   ret
6802+ 40F3
6803+ 40F3 CD DD 1A     OUTNCR: call    OUTC            ; Output character in A
6804+ 40F6 C3 E8 1F             jp      PRNTCRLF        ; Output CRLF
6805+ 40F9
# file closed: ../include/basic/basic-1.10.asm
  76  40F9
  77  40F9              ; include utils
  78  40F9                  INCLUDE "../include/utils/utils-r1.2.asm"
# file opened: ../include/utils/utils-r1.2.asm
   1+ 40F9              ; ------------------------------------------------------------------------------
   2+ 40F9              ; LM80C - UTILITY ROUTINES - R1.2
   3+ 40F9              ; ------------------------------------------------------------------------------
   4+ 40F9              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 40F9              ; designed by Leonardo Miliani. More info at
   6+ 40F9              ; www DOT leonardomiliani DOT com
   7+ 40F9              ;
   8+ 40F9              ; *ALS are routines from "Z80 Assembly Language Subroutines" by Lance
   9+ 40F9              ; A. Leventhal and Winthrop Saville - Ed. Osborne/McGraw-Hill (1983)
  10+ 40F9              ;
  11+ 40F9              ; * WKT are routines from WikiTI:
  12+ 40F9              ; http://wikiti.brandonw.net/index.php?title=WikiTI_Home
  13+ 40F9              ;
  14+ 40F9              ; * LAC are routines from Learn@Cemetch
  15+ 40F9              ; https://learn.cemetech.net/index.php/Main_Page
  16+ 40F9              ;
  17+ 40F9              ; ------------------------------------------------------------------------------
  18+ 40F9              ; Code Revision:
  19+ 40F9              ; R1.0 - 20200110 - First release: 16-bit comparision/multiplication/negation
  20+ 40F9              ; R1.1 - 20200413 - Second release: added ABS(HL)
  21+ 40F9              ; R1.2 - 20200131 - Added 32/16 bit multiplication/division and converter to
  22+ 40F9              ;                   transform a 32-bit value into ASCII representation
  23+ 40F9              ;
  24+ 40F9              ; ------------------------------------------------------------------------------
  25+ 40F9
  26+ 40F9              ; compare two 16-bit registers, HL (minuend) and DE (subtrahend)
  27+ 40F9              ; values can be both signed or unsigned words
  28+ 40F9              ; inputs: HL, DE
  29+ 40F9              ; destroys: A,F,HL
  30+ 40F9              ;
  31+ 40F9              ; returns: Z=1 if HL = DE
  32+ 40F9              ; for UNSIGNED: C=1 if HL<DE  //  C=0 if HL>DE
  33+ 40F9              ; for SIGNED:   S=1 (M) if HL<DE  //  S=0 (P) if HL>DE
  34+ 40F9              ; if HL=DE: Z,P,NC  - Z=1, S=0; C=0
  35+ 40F9              ; if HL>DE: NZ,P,NC - Z=0, S=0; C=0
  36+ 40F9              ; if HL<DE: NZ,M,C  - Z=0, S=1; C=1
  37+ 40F9              ; Source: ALS
  38+ 40F9
  39+ 40F9 B7           CMP16:  or      A           ; clear CARRY
  40+ 40FA ED 52                sbc     HL,DE       ; subtract DE from HL
  41+ 40FC E0                   ret     PO          ; return if no overflow
  42+ 40FD 7C                   ld      A,H         ; overflow - invert SIGN flag
  43+ 40FE 1F                   rra                 ; save CARRY flag in bit 7
  44+ 40FF EE 40                xor     %01000000   ; complement bit 6 (SIGN bit)
  45+ 4101 37                   scf                 ; ensure a Non-Zero result
  46+ 4102 8F                   adc     A,A         ; restore CARRY, complemented SIGN
  47+ 4103                                          ; ZERO flag = 0 for sure
  48+ 4103 C9                   ret                 ; return
  49+ 4104
  50+ 4104              ; ----------------------------------------------------------------------
  51+ 4104
  52+ 4104              ; multiply 2 signed/unsigned 16-bit words and return a 16-bit
  53+ 4104              ; signed/unsigned product
  54+ 4104              ; inputs: HL (multiplicand); DE (multiplier)
  55+ 4104              ; destroys: A,F
  56+ 4104              ; returns: HL (product)
  57+ 4104              ; Source: ALS
  58+ 4104
  59+ 4104              ; initialize partial product, bit count
  60+ 4104 C5           MUL16:  push    BC
  61+ 4105 4D                   ld      C,L         ; BC = multiplier
  62+ 4106 44                   ld      B,H
  63+ 4107 21 00 00             ld      HL,0        ; product = 0
  64+ 410A 3E 0F                ld      A,$0F       ; count = bit lenght - 1 (16-1)
  65+ 410C                      ; shift-and-add algorithm
  66+ 410C                      ; if MSB of multiplier is 1, add multiplicand to partial product
  67+ 410C                      ; shift partial product, multiplier left 1 bit
  68+ 410C CB 23        MLP:    sla     E           ; shift multiplier left 1 bit
  69+ 410E CB 12                rl      D
  70+ 4110 30 01                jr      NC,MLP1     ; jump if MSB of multiplier = 0
  71+ 4112 09                   add     HL,BC       ; add multiplicand to partial product
  72+ 4113 29           MLP1:   add     HL,HL       ; shift partial product left
  73+ 4114 3D                   dec     A
  74+ 4115 20 F5                jr      NZ,MLP      ; continue until count = 0
  75+ 4117                      ; add multiplicand one last time if MSB of multiplier is 1
  76+ 4117 B2                   or      D           ; sign flag = MSB of multiplier
  77+ 4118 F2 1C 41             jp      P,EXMUL16   ; exit if MSB of multiplier is 0
  78+ 411B 09                   add     HL,BC       ; add multiplicand to product
  79+ 411C C1           EXMUL16:pop     BC
  80+ 411D C9                   ret
  81+ 411E
  82+ 411E
  83+ 411E              ; ----------------------------------------------------------------------
  84+ 411E
  85+ 411E              ; multiply 2 unsigned 16-bit words and return a 32-bit unsigned product
  86+ 411E              ; inputs: BC (multiplicand); DE (multiplier)
  87+ 411E              ; destroys: A,F
  88+ 411E              ; operation: BC * DE
  89+ 411E              ; returns: DEHL (product)
  90+ 411E              ; Source: WKT
  91+ 411E
  92+ 411E 21 00 00     MUL_U32:ld      HL,$0000        ; reset HL
  93+ 4121 CB 23                sla     E		; optimised 1st iteration
  94+ 4123 CB 12                rl      D
  95+ 4125 30 02                jr      NC,MU32_1       ; if no Carry then jump over
  96+ 4127 60                   ld      H,B
  97+ 4128 69                   ld      L,C
  98+ 4129 3E 0F        MU32_1: ld      A,$0F
  99+ 412B 29           MUL_32L:add     HL,HL           ; main loop
 100+ 412C CB 13                rl      E
 101+ 412E CB 12                rl      D
 102+ 4130 30 04                jr      NC,MU32_2
 103+ 4132 09                   add     HL,BC
 104+ 4133 30 01                jr      NC,MU32_2
 105+ 4135 13                   inc     DE
 106+ 4136 3D           MU32_2: dec     A
 107+ 4137 20 F2                jr      NZ,MUL_32L
 108+ 4139 C9                   ret
 109+ 413A
 110+ 413A              ; ----------------------------------------------------------------------
 111+ 413A              ; absolute value of HL (same applies to other 16-bit register pairs)
 112+ 413A              ; also, invert value of HL (or any other 16-bit register, just adjust the code)
 113+ 413A              ;
 114+ 413A              ; inputs: HL
 115+ 413A              ; destroys: A
 116+ 413A              ; operation: ABS(HL)
 117+ 413A              ; returns: HL with no sign or negated
 118+ 413A              ; Source: WKT
 119+ 413A
 120+ 413A CB 7C        absHL:  bit     7,H
 121+ 413C C8                   ret     Z
 122+ 413D AF           negHL:  xor     A
 123+ 413E 95                   sub     L
 124+ 413F 6F                   ld      L,A
 125+ 4140 9F                   sbc     A,A
 126+ 4141 94                   sub     H
 127+ 4142 67                   ld      H,A
 128+ 4143 C9                   ret
 129+ 4144
 130+ 4144              ; ------------------------------------------------------------------------------
 131+ 4144
 132+ 4144              ; 8/8 division
 133+ 4144              ; INPUT: D (dividend), E (divisor)
 134+ 4144              ; OPERATION: D/E
 135+ 4144              ; OUTPUT: D (quotient), A (remainder)
 136+ 4144 AF           DIV_8_8:    xor     A
 137+ 4145 C5                       push    BC
 138+ 4146 06 08                    ld      B,08h
 139+ 4148 CB 22        DIV_8_8LOOP:sla     D
 140+ 414A 17                       rla
 141+ 414B BB                       cp      E
 142+ 414C 38 02                    jr      C,$+4
 143+ 414E 93                       sub     E
 144+ 414F 14                       inc     D
 145+ 4150 10 F6                    djnz    DIV_8_8LOOP
 146+ 4152 C1                       pop     BC
 147+ 4153 C9                       ret
 148+ 4154
 149+ 4154              ; ----------------------------------------------------------------------
 150+ 4154              ; divide a 16-bit number by an 8-bit number
 151+ 4154              ; (16/8 division)
 152+ 4154              ;
 153+ 4154              ; inputs: HL (Dividend), C (divisor)
 154+ 4154              ; destroys: A, B
 155+ 4154              ; OPERATION: HL/C
 156+ 4154              ; returns: HL (quotient), A (remainder)
 157+ 4154              ; source: WKT
 158+ 4154
 159+ 4154 AF           DIV_16_8:   xor     A
 160+ 4155 06 10                    ld      B,16
 161+ 4157 29           DIV_16_8LP: add     HL,HL
 162+ 4158 17                       rla
 163+ 4159 38 03                    jr      C,$+5
 164+ 415B B9                       cp      C
 165+ 415C 38 02                    jr      C,$+4
 166+ 415E 91                       sub     C
 167+ 415F 2C                       inc     L
 168+ 4160 10 F5                    djnz    DIV_16_8LP
 169+ 4162 C9                       ret
 170+ 4163
 171+ 4163              ; ----------------------------------------------------------------------
 172+ 4163              ; divide a 16-bit number by a 16-bit number
 173+ 4163              ; (16/16 division)
 174+ 4163              ;
 175+ 4163              ; inputs: AC (Dividend), DE (divisor)
 176+ 4163              ; destroys: HL,A,C
 177+ 4163              ; OPERATION: AC/DE
 178+ 4163              ; returns: AC (quotient), HL (remainder)
 179+ 4163              ; source: WKT
 180+ 4163 21 00 00     DIV_16_16:  ld      HL, 0
 181+ 4166 06 10                    ld      B, 16
 182+ 4168 CB 21        DV16_16_LP: sla     C
 183+ 416A CB C1                    set     0,C         ; this simulates the SLL undocumented instruction
 184+ 416C 17                       rla
 185+ 416D ED 6A                    adc     HL,HL
 186+ 416F ED 52                    sbc     HL,DE
 187+ 4171 30 02                    jr      NC, $+4
 188+ 4173 19                       add     HL,DE
 189+ 4174 0D                       dec     C
 190+ 4175 10 F1                    djnz    DV16_16_LP
 191+ 4177 C9                       ret
 192+ 4178
 193+ 4178
 194+ 4178              ; ----------------------------------------------------------------------
 195+ 4178              ; divide a 32-bit number by a 16 bit-number
 196+ 4178              ; (32/16 division)
 197+ 4178              ;
 198+ 4178              ; inputs: ACIX (Dividend), DE (divisor)
 199+ 4178              ; destroys: HL,IX,BC
 200+ 4178              ; OPERATION: ACIX/DE
 201+ 4178              ; returns: ACIX (quotient), HL (remainder)
 202+ 4178              ; source: WKT
 203+ 4178
 204+ 4178 21 00 00     DIV_32_16:  ld      HL,0
 205+ 417B 06 20                    ld      B,32
 206+ 417D DD 29        DIV_32_16LP:add     IX,IX
 207+ 417F CB 11                    rl      C
 208+ 4181 17                       rla
 209+ 4182 ED 6A                    adc     HL,HL
 210+ 4184 38 08                    jr      C,DIV_32_16OF
 211+ 4186 ED 52                    sbc     HL,DE
 212+ 4188 30 07                    jr      NC,DIV_32_16SB
 213+ 418A 19                       add     HL,DE
 214+ 418B 10 F0                    djnz    DIV_32_16LP
 215+ 418D C9                       ret
 216+ 418E B7           DIV_32_16OF:or      A                   ; overflow
 217+ 418F ED 52                    sbc     HL,DE
 218+ 4191 DD 23        DIV_32_16SB:inc     IX                  ; set bit
 219+ 4193 10 E8                    djnz    DIV_32_16LP
 220+ 4195 C9                       ret
 221+ 4196
 222+ 4196
 223+ 4196              ; ----------------------------------------------------------------------
 224+ 4196              ; convert a 32-bit number in ASCII string (terminated by '0')
 225+ 4196              ;
 226+ 4196              ; inputs: DEIX (Value), IY (dest. address in memory)
 227+ 4196              ; destroys: AF, BC, DE, HL, IX
 228+ 4196              ; outputs: IY (last char in dest. string)
 229+ 4196              ; source: MSX Forum
 230+ 4196
 231+ 4196 01 00 00 00  CLCN32T:    defw    1,0,10,0,100,0,1000,0,10000,0
 231+ 419A 0A 00 00 00
 231+ 419E 64 00 00 00
 231+ 41A2 E8 03 00 00
 231+ 41A6 10 27 00 00
 232+ 41AA A0 86 01 00              defw    $86A0,$1,$4240,$F,$9680,$98,$E100,$5F5,$CA00,$3B9A
 232+ 41AE 40 42 0F 00
 232+ 41B2 80 96 98 00
 232+ 41B6 00 E1 F5 05
 232+ 41BA 00 CA 9A 3B
 233+ 41BE 00 00 00 00  CLCN32Z:    defs    4
 234+ 41C2
 235+ 41C2 DD 22 BE 41  CLCN32:     ld      (CLCN32Z),IX
 236+ 41C6 ED 53 C0 41              ld      (CLCN32Z+$02),DE
 237+ 41CA DD 21 BA 41              ld      IX,CLCN32T+$24
 238+ 41CE 06 09                    ld      B,$09
 239+ 41D0 0E 00                    ld      C,$00
 240+ 41D2 3E 30        CLCN321:    ld      A,"0"
 241+ 41D4 B7                       or      A
 242+ 41D5 DD 5E 00     CLCN322:    ld      E,(IX+$00)
 243+ 41D8 DD 56 01                 ld      D,(IX+$01)
 244+ 41DB 2A BE 41                 ld      HL,(CLCN32Z)
 245+ 41DE ED 52                    sbc     HL,DE
 246+ 41E0 22 BE 41                 ld      (CLCN32Z),HL
 247+ 41E3 DD 5E 02                 ld      E,(IX+$02)
 248+ 41E6 DD 56 03                 ld      D,(IX+$03)
 249+ 41E9 2A C0 41                 ld      HL,(CLCN32Z+$02)
 250+ 41EC ED 52                    sbc     HL,DE
 251+ 41EE 22 C0 41                 ld      (CLCN32Z+$02),HL
 252+ 41F1 38 04                    jr      C,CLCN325
 253+ 41F3 0C                       inc     C
 254+ 41F4 3C                       inc     A
 255+ 41F5 18 DE                    jr      CLCN322
 256+ 41F7 DD 5E 00     CLCN325:    ld      E,(IX+$00)
 257+ 41FA DD 56 01                 ld      D,(IX+$01)
 258+ 41FD 2A BE 41                 ld      HL,(CLCN32Z)
 259+ 4200 19                       add     HL,DE
 260+ 4201 22 BE 41                 ld      (CLCN32Z),HL
 261+ 4204 DD 5E 02                 ld      E,(IX+$02)
 262+ 4207 DD 56 03                 ld      D,(IX+$03)
 263+ 420A 2A C0 41                 ld      HL,(CLCN32Z+$02)
 264+ 420D ED 5A                    adc     HL,DE
 265+ 420F 22 C0 41                 ld      (CLCN32Z+$02),HL
 266+ 4212 11 FC FF                 ld      DE,-4
 267+ 4215 DD 19                    add     IX,DE
 268+ 4217 0C                       inc     C
 269+ 4218 0D                       dec     C
 270+ 4219 28 05                    jr      Z,CLCN323
 271+ 421B FD 77 00                 ld      (IY+$00),A
 272+ 421E FD 23                    inc     IY
 273+ 4220 10 B0        CLCN323:    djnz    CLCN321
 274+ 4222 3A BE 41                 ld      A,(CLCN32Z)
 275+ 4225 C6 30                    add     "0"
 276+ 4227 FD 77 00                 ld      (IY+$00),A
 277+ 422A FD 36 01 00              ld      (IY+$01),0
 278+ 422E C9                       ret
# file closed: ../include/utils/utils-r1.2.asm
  79  422F
  80  422F              ; include the latest version of the font sets
  81  422F                  INCLUDE "../include/vdp/6x8fonts-r16.asm"
# file opened: ../include/vdp/6x8fonts-r16.asm
   1+ 422F              ; ------------------------------------------------------------------------------
   2+ 422F              ; LM80C - 6x8 CHARSET - R1.6
   3+ 422F              ; ------------------------------------------------------------------------------
   4+ 422F              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 422F              ; designed by Leonardo Miliani. More info at
   6+ 422F              ; www DOT leonardomiliani DOT com
   7+ 422F              ; ------------------------------------------------------------------------------
   8+ 422F              ; Code Revision:
   9+ 422F              ; R1.0 - 20190511 - First revision: ASCII chars (from 0 to 127)
  10+ 422F              ; R1.1 - 20190521 - Expanded to 255 chars
  11+ 422F              ; R1.2 - 20191209 - Start adding graphic chars to be coherent with 8x8 fonts
  12+ 422F              ; R1.3 - 20191226 - Added extended char codes (128-255)
  13+ 422F              ; R1.4 - 20200228 - adopted more usual hexadecimal & binary prefixes
  14+ 422F              ; R1.5 - 20200524 - New style for char #252
  15+ 422F              ; R1.6 - 20200704 - Redefined chars 105, 106, and 252
  16+ 422F              ; ------------------------------------------------------------------------------
  17+ 422F              ;
  18+ 422F              ;-------------------------------------------------------------------------------
  19+ 422F              ;
  20+ 422F              ;               6 x 8    C  H  A  R  S  E  T
  21+ 422F              ;
  22+ 422F              ;-------------------------------------------------------------------------------
  23+ 422F              ;
  24+ 422F              ;       6X8 CHARS, DESIGNED FOR TEXT BUT USABLE IN GRAPHICS 1 MODE TOO
  25+ 422F              ;       UPDATE: NOW GRAPHICS 1 MODE HAS ITS OWN CHAR SET
  26+ 422F
  27+ 422F              CHRST68 equ $
  28+ 422F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  28+ 4233 00 00 00 00
  29+ 4237 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  29+ 423B 00 00 00 00
  30+ 423F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  30+ 4243 00 00 00 00
  31+ 4247 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  31+ 424B 00 00 00 00
  32+ 424F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  32+ 4253 00 00 00 00
  33+ 4257 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  33+ 425B 00 00 00 00
  34+ 425F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  34+ 4263 00 00 00 00
  35+ 4267 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  35+ 426B 00 00 00 00
  36+ 426F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
  36+ 4273 00 00 00 00
  37+ 4277 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  37+ 427B 00 00 00 00
  38+ 427F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  38+ 4283 00 00 00 00
  39+ 4287 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11
  39+ 428B 00 00 00 00
  40+ 428F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  40+ 4293 00 00 00 00
  41+ 4297 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
  41+ 429B 00 00 00 00
  42+ 429F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
  42+ 42A3 00 00 00 00
  43+ 42A7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  43+ 42AB 00 00 00 00
  44+ 42AF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  44+ 42B3 00 00 00 00
  45+ 42B7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  45+ 42BB 00 00 00 00
  46+ 42BF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  46+ 42C3 00 00 00 00
  47+ 42C7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  47+ 42CB 00 00 00 00
  48+ 42CF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
  48+ 42D3 00 00 00 00
  49+ 42D7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  49+ 42DB 00 00 00 00
  50+ 42DF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
  50+ 42E3 00 00 00 00
  51+ 42E7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
  51+ 42EB 00 00 00 00
  52+ 42EF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
  52+ 42F3 00 00 00 00
  53+ 42F7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
  53+ 42FB 00 00 00 00
  54+ 42FF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
  54+ 4303 00 00 00 00
  55+ 4307 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
  55+ 430B 00 00 00 00
  56+ 430F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
  56+ 4313 00 00 00 00
  57+ 4317 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
  57+ 431B 00 00 00 00
  58+ 431F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
  58+ 4323 00 00 00 00
  59+ 4327 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
  59+ 432B 00 00 00 00
  60+ 432F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32: space
  60+ 4333 00 00 00 00
  61+ 4337 20 20 20 20          defb $20,$20,$20,$20,$20,$00,$20,$00 ; char 33: !
  61+ 433B 20 00 20 00
  62+ 433F 50 50 00 00          defb $50,$50,$00,$00,$00,$00,$00,$00 ; char 34: "
  62+ 4343 00 00 00 00
  63+ 4347 50 50 F8 50          defb $50,$50,$f8,$50,$f8,$50,$50,$00 ; char 35: #
  63+ 434B F8 50 50 00
  64+ 434F 20 78 A0 70          defb $20,$78,$a0,$70,$28,$f0,$20,$00 ; char 36: $
  64+ 4353 28 F0 20 00
  65+ 4357 C0 C8 10 20          defb $c0,$c8,$10,$20,$40,$98,$18,$00 ; char 37: %
  65+ 435B 40 98 18 00
  66+ 435F 60 90 A0 40          defb $60,$90,$a0,$40,$a8,$90,$68,$00 ; char 38: &
  66+ 4363 A8 90 68 00
  67+ 4367 60 20 40 00          defb $60,$20,$40,$00,$00,$00,$00,$00 ; char 39: '
  67+ 436B 00 00 00 00
  68+ 436F 10 20 40 40          defb $10,$20,$40,$40,$40,$20,$10,$00 ; char 40: (
  68+ 4373 40 20 10 00
  69+ 4377 40 20 10 10          defb $40,$20,$10,$10,$10,$20,$40,$00 ; char 41: )
  69+ 437B 10 20 40 00
  70+ 437F 00 20 A8 70          defb $00,$20,$a8,$70,$a8,$20,$00,$00 ; char 42: *
  70+ 4383 A8 20 00 00
  71+ 4387 00 20 20 F8          defb $00,$20,$20,$f8,$20,$20,$00,$00 ; char 43: +
  71+ 438B 20 20 00 00
  72+ 438F 00 00 00 00          defb $00,$00,$00,$00,$60,$20,$40,$00 ; char 44: ,
  72+ 4393 60 20 40 00
  73+ 4397 00 00 00 F8          defb $00,$00,$00,$f8,$00,$00,$00,$00 ; char 45: -
  73+ 439B 00 00 00 00
  74+ 439F 00 00 00 00          defb $00,$00,$00,$00,$00,$60,$60,$00 ; char 46: .
  74+ 43A3 00 60 60 00
  75+ 43A7 00 08 10 20          defb $00,$08,$10,$20,$40,$80,$00,$00 ; char 47: /
  75+ 43AB 40 80 00 00
  76+ 43AF 70 88 98 A8          defb $70,$88,$98,$a8,$c8,$88,$70,$00 ; char 48: 0
  76+ 43B3 C8 88 70 00
  77+ 43B7 20 60 20 20          defb $20,$60,$20,$20,$20,$20,$70,$00 ; char 49: 1
  77+ 43BB 20 20 70 00
  78+ 43BF 70 88 08 10          defb $70,$88,$08,$10,$20,$40,$f8,$00 ; char 50: 2
  78+ 43C3 20 40 F8 00
  79+ 43C7 F8 10 20 10          defb $f8,$10,$20,$10,$08,$88,$70,$00 ; char 51: 3
  79+ 43CB 08 88 70 00
  80+ 43CF 10 30 50 90          defb $10,$30,$50,$90,$f8,$10,$10,$00 ; char 52: 4
  80+ 43D3 F8 10 10 00
  81+ 43D7 F8 80 F0 08          defb $f8,$80,$f0,$08,$08,$88,$70,$00 ; char 53: 5
  81+ 43DB 08 88 70 00
  82+ 43DF 30 40 80 F0          defb $30,$40,$80,$f0,$88,$88,$70,$00 ; char 54: 6
  82+ 43E3 88 88 70 00
  83+ 43E7 F8 08 10 20          defb $f8,$08,$10,$20,$40,$40,$40,$00 ; char 55: 7
  83+ 43EB 40 40 40 00
  84+ 43EF 70 88 88 70          defb $70,$88,$88,$70,$88,$88,$70,$00 ; char 56: 8
  84+ 43F3 88 88 70 00
  85+ 43F7 70 88 88 78          defb $70,$88,$88,$78,$08,$10,$60,$00 ; char 57: 9
  85+ 43FB 08 10 60 00
  86+ 43FF 00 30 30 00          defb $00,$30,$30,$00,$30,$30,$00,$00 ; char 58: :
  86+ 4403 30 30 00 00
  87+ 4407 00 30 30 00          defb $00,$30,$30,$00,$30,$10,$20,$00 ; char 59: ;
  87+ 440B 30 10 20 00
  88+ 440F 10 20 40 80          defb $10,$20,$40,$80,$40,$20,$10,$00 ; char 60: <
  88+ 4413 40 20 10 00
  89+ 4417 00 00 F8 00          defb $00,$00,$f8,$00,$f8,$00,$00,$00 ; char 61: =
  89+ 441B F8 00 00 00
  90+ 441F 40 20 10 08          defb $40,$20,$10,$08,$10,$20,$40,$00 ; char 62: >
  90+ 4423 10 20 40 00
  91+ 4427 70 88 08 10          defb $70,$88,$08,$10,$20,$00,$20,$00 ; char 63: ?
  91+ 442B 20 00 20 00
  92+ 442F 70 88 08 68          defb $70,$88,$08,$68,$a8,$a8,$70,$00 ; char 64: @
  92+ 4433 A8 A8 70 00
  93+ 4437 70 88 88 88          defb $70,$88,$88,$88,$f8,$88,$88,$00 ; char 65: A
  93+ 443B F8 88 88 00
  94+ 443F F0 88 88 F0          defb $f0,$88,$88,$f0,$88,$88,$f0,$00 ; char 66: B
  94+ 4443 88 88 F0 00
  95+ 4447 70 88 80 80          defb $70,$88,$80,$80,$80,$88,$70,$00 ; char 67: C
  95+ 444B 80 88 70 00
  96+ 444F E0 90 88 88          defb $e0,$90,$88,$88,$88,$90,$e0,$00 ; char 68: D
  96+ 4453 88 90 E0 00
  97+ 4457 F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$f8,$00 ; char 69: E
  97+ 445B 80 80 F8 00
  98+ 445F F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$80,$00 ; char 70: F
  98+ 4463 80 80 80 00
  99+ 4467 70 88 80 B8          defb $70,$88,$80,$b8,$88,$88,$78,$00 ; char 71: G
  99+ 446B 88 88 78 00
 100+ 446F 88 88 88 F8          defb $88,$88,$88,$f8,$88,$88,$88,$00 ; char 72: H
 100+ 4473 88 88 88 00
 101+ 4477 70 20 20 20          defb $70,$20,$20,$20,$20,$20,$70,$00 ; char 73: I
 101+ 447B 20 20 70 00
 102+ 447F 38 10 10 10          defb $38,$10,$10,$10,$10,$90,$60,$00 ; char 74: J
 102+ 4483 10 90 60 00
 103+ 4487 88 90 A0 C0          defb $88,$90,$a0,$c0,$a0,$90,$88,$00 ; char 75: K
 103+ 448B A0 90 88 00
 104+ 448F 80 80 80 80          defb $80,$80,$80,$80,$80,$80,$f8,$00 ; char 76: L
 104+ 4493 80 80 F8 00
 105+ 4497 88 D8 A8 A8          defb $88,$d8,$a8,$a8,$88,$88,$88,$00 ; char 77: M
 105+ 449B 88 88 88 00
 106+ 449F 88 C8 A8 98          defb $88,$c8,$a8,$98,$88,$88,$88,$00 ; char 78: N
 106+ 44A3 88 88 88 00
 107+ 44A7 70 88 88 88          defb $70,$88,$88,$88,$88,$88,$70,$00 ; char 79: O
 107+ 44AB 88 88 70 00
 108+ 44AF F0 88 88 F0          defb $f0,$88,$88,$f0,$80,$80,$80,$00 ; char 80: P
 108+ 44B3 80 80 80 00
 109+ 44B7 70 88 88 88          defb $70,$88,$88,$88,$a8,$90,$68,$00 ; char 81: Q
 109+ 44BB A8 90 68 00
 110+ 44BF F0 88 88 F0          defb $f0,$88,$88,$f0,$a0,$90,$88,$00 ; char 82: R
 110+ 44C3 A0 90 88 00
 111+ 44C7 78 80 80 70          defb $78,$80,$80,$70,$08,$08,$f0,$00 ; char 83: S
 111+ 44CB 08 08 F0 00
 112+ 44CF F8 20 20 20          defb $f8,$20,$20,$20,$20,$20,$20,$00 ; char 84: T
 112+ 44D3 20 20 20 00
 113+ 44D7 88 88 88 88          defb $88,$88,$88,$88,$88,$88,$70,$00 ; char 85: U
 113+ 44DB 88 88 70 00
 114+ 44DF 88 88 88 88          defb $88,$88,$88,$88,$88,$50,$20,$00 ; char 86: V
 114+ 44E3 88 50 20 00
 115+ 44E7 88 88 88 88          defb $88,$88,$88,$88,$a8,$a8,$50,$00 ; char 87: W
 115+ 44EB A8 A8 50 00
 116+ 44EF 88 88 50 20          defb $88,$88,$50,$20,$50,$88,$88,$00 ; char 88: X
 116+ 44F3 50 88 88 00
 117+ 44F7 88 88 88 50          defb $88,$88,$88,$50,$20,$20,$20,$00 ; char 89: Y
 117+ 44FB 20 20 20 00
 118+ 44FF F8 08 10 20          defb $f8,$08,$10,$20,$40,$80,$f8,$00 ; char 90: Z
 118+ 4503 40 80 F8 00
 119+ 4507 70 40 40 40          defb $70,$40,$40,$40,$40,$40,$70,$00 ; char 91: [
 119+ 450B 40 40 70 00
 120+ 450F 00 80 40 20          defb $00,$80,$40,$20,$10,$08,$00,$00 ; char 92: \
 120+ 4513 10 08 00 00
 121+ 4517 70 10 10 10          defb $70,$10,$10,$10,$10,$10,$70,$00 ; char 93: ]
 121+ 451B 10 10 70 00
 122+ 451F 20 50 88 00          defb $20,$50,$88,$00,$00,$00,$00,$00 ; char 94: ^
 122+ 4523 00 00 00 00
 123+ 4527 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$FC ; char 95: _ (underscore)
 123+ 452B 00 00 00 FC
 124+ 452F 40 20 10 00          defb $40,$20,$10,$00,$00,$00,$00,$00 ; char 96: `
 124+ 4533 00 00 00 00
 125+ 4537 00 00 70 08          defb $00,$00,$70,$08,$78,$88,$78,$00 ; char 97: a
 125+ 453B 78 88 78 00
 126+ 453F 80 80 80 B0          defb $80,$80,$80,$b0,$c8,$88,$f0,$00 ; char 98: b
 126+ 4543 C8 88 F0 00
 127+ 4547 00 00 70 80          defb $00,$00,$70,$80,$80,$88,$70,$00 ; char 99: c
 127+ 454B 80 88 70 00
 128+ 454F 08 08 08 68          defb $08,$08,$08,$68,$98,$88,$78,$00 ; char 100: d
 128+ 4553 98 88 78 00
 129+ 4557 00 00 70 88          defb $00,$00,$70,$88,$f8,$80,$70,$00 ; char 101: e
 129+ 455B F8 80 70 00
 130+ 455F 30 48 40 E0          defb $30,$48,$40,$e0,$40,$40,$40,$00 ; char 102: f
 130+ 4563 40 40 40 00
 131+ 4567 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$70,$00 ; char 103: g
 131+ 456B 78 08 70 00
 132+ 456F 80 80 B0 C8          defb $80,$80,$b0,$c8,$88,$88,$88,$00 ; char 104: h
 132+ 4573 88 88 88 00
 133+ 4577 20 00 20 20          defb $20,$00,$20,$20,$20,$20,$20,$00 ; char 105: i
 133+ 457B 20 20 20 00
 134+ 457F 08 00 18 08          defb $08,$00,$18,$08,$08,$88,$70,$00 ; char 106: j
 134+ 4583 08 88 70 00
 135+ 4587 80 80 90 A0          defb $80,$80,$90,$a0,$c0,$a0,$90,$00 ; char 107: k
 135+ 458B C0 A0 90 00
 136+ 458F 60 20 20 20          defb $60,$20,$20,$20,$20,$20,$70,$00 ; char 108: l
 136+ 4593 20 20 70 00
 137+ 4597 00 00 D0 A8          defb $00,$00,$d0,$a8,$a8,$88,$88,$00 ; char 109: m
 137+ 459B A8 88 88 00
 138+ 459F 00 00 B0 C8          defb $00,$00,$b0,$c8,$88,$88,$88,$00 ; char 110: n
 138+ 45A3 88 88 88 00
 139+ 45A7 00 00 70 88          defb $00,$00,$70,$88,$88,$88,$70,$00 ; char 111: o
 139+ 45AB 88 88 70 00
 140+ 45AF 00 00 F0 88          defb $00,$00,$f0,$88,$f0,$80,$80,$00 ; char 112: p
 140+ 45B3 F0 80 80 00
 141+ 45B7 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$08,$00 ; char 113: q
 141+ 45BB 78 08 08 00
 142+ 45BF 00 00 B0 C8          defb $00,$00,$b0,$c8,$80,$80,$80,$00 ; char 114: r
 142+ 45C3 80 80 80 00
 143+ 45C7 00 00 70 80          defb $00,$00,$70,$80,$70,$08,$f0,$00 ; char 115: s
 143+ 45CB 70 08 F0 00
 144+ 45CF 40 40 E0 40          defb $40,$40,$e0,$40,$40,$48,$30,$00 ; char 116: t
 144+ 45D3 40 48 30 00
 145+ 45D7 00 00 88 88          defb $00,$00,$88,$88,$88,$98,$68,$00 ; char 117: u
 145+ 45DB 88 98 68 00
 146+ 45DF 00 00 88 88          defb $00,$00,$88,$88,$88,$50,$20,$00 ; char 118: v
 146+ 45E3 88 50 20 00
 147+ 45E7 00 00 88 88          defb $00,$00,$88,$88,$a8,$a8,$50,$00 ; char 119: w
 147+ 45EB A8 A8 50 00
 148+ 45EF 00 00 88 50          defb $00,$00,$88,$50,$20,$50,$88,$00 ; char 120: x
 148+ 45F3 20 50 88 00
 149+ 45F7 00 00 88 98          defb $00,$00,$88,$98,$68,$08,$70,$00 ; char 121: y
 149+ 45FB 68 08 70 00
 150+ 45FF 00 00 F8 10          defb $00,$00,$f8,$10,$20,$40,$f8,$00 ; char 122: z
 150+ 4603 20 40 F8 00
 151+ 4607 10 20 20 40          defb $10,$20,$20,$40,$20,$20,$10,$00 ; char 123: {
 151+ 460B 20 20 10 00
 152+ 460F 20 20 20 20          defb $20,$20,$20,$20,$20,$20,$20,$00 ; char 124: |
 152+ 4613 20 20 20 00
 153+ 4617 20 10 10 08          defb $20,$10,$10,$08,$10,$10,$20,$00 ; char 125: }
 153+ 461B 10 10 20 00
 154+ 461F 00 28 50 00          defb $00,$28,$50,$00,$00,$00,$00,$00 ; char 126: ~
 154+ 4623 00 00 00 00
 155+ 4627 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 127: (delete) - here end the standard ASCII (0-127)
 155+ 462B 00 00 00 00
 156+ 462F 78 84 CC 84          defb %01111000,%10000100,%11001100,%10000100,%10110100,%10000100,%01111000,%00000000 ; char 128 (open face)
 156+ 4633 B4 84 78 00
 157+ 4637 78 FC B4 FC          defb %01111000,%11111100,%10110100,%11111100,%10110100,%11001100,%01111000,%00000000 ; char 129 (full face)
 157+ 463B B4 CC 78 00
 158+ 463F 48 FC FC FC          defb %01001000,%11111100,%11111100,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 130 (hearts)
 158+ 4643 FC 78 30 00
 159+ 4647 00 20 70 F8          defb %00000000,%00100000,%01110000,%11111000,%11111000,%01110000,%00100000,%00000000 ; char 131 (diamonds)
 159+ 464B F8 70 20 00
 160+ 464F 70 20 A8 F8          defb %01110000,%00100000,%10101000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 132 (clubs)
 160+ 4653 A8 20 70 00
 161+ 4657 20 70 F8 F8          defb %00100000,%01110000,%11111000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 133 (spades)
 161+ 465B A8 20 70 00
 162+ 465F 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 134
 162+ 4663 FC 30 30 30
 163+ 4667 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 135
 163+ 466B 3C 30 30 30
 164+ 466F 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 136
 164+ 4673 F0 30 30 30
 165+ 4677 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00000000,%00000000,%00000000 ; char 137
 165+ 467B F0 00 00 00
 166+ 467F 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00000000,%00000000,%00000000 ; char 138
 166+ 4683 3C 00 00 00
 167+ 4687 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 139
 167+ 468B FC 00 00 00
 168+ 468F 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 140
 168+ 4693 3C 30 30 30
 169+ 4697 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 141
 169+ 469B FC 30 30 30
 170+ 469F 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 142
 170+ 46A3 F0 30 30 30
 171+ 46A7 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 143
 171+ 46AB FC 00 00 00
 172+ 46AF 30 30 30 30          defb %00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000 ; char 144
 172+ 46B3 30 30 30 30
 173+ 46B7 0C 1C 18 38          defb %00001100,%00011100,%00011000,%00111000,%01110000,%01100000,%11100000,%11000000 ; char 145
 173+ 46BB 70 60 E0 C0
 174+ 46BF C0 E0 60 70          defb %11000000,%11100000,%01100000,%01110000,%00111000,%00011000,%00011100,%00001100 ; char 146
 174+ 46C3 38 18 1C 0C
 175+ 46C7 CC CC 78 30          defb %11001100,%11001100,%01111000,%00110000,%00110000,%01111000,%11001100,%11001100 ; char 147
 175+ 46CB 30 78 CC CC
 176+ 46CF 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 148
 176+ 46D3 20 20 20 20
 177+ 46D7 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 149
 177+ 46DB 20 20 20 20
 178+ 46DF 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 150
 178+ 46E3 20 20 20 20
 179+ 46E7 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 151
 179+ 46EB 00 00 00 00
 180+ 46EF 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00000000,%00000000,%00000000,%00000000 ; char 152
 180+ 46F3 00 00 00 00
 181+ 46F7 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 153
 181+ 46FB 00 00 00 00
 182+ 46FF 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 154
 182+ 4703 20 20 20 20
 183+ 4707 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 155
 183+ 470B 20 20 20 20
 184+ 470F 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 156
 184+ 4713 20 20 20 20
 185+ 4717 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 157
 185+ 471B 00 00 00 00
 186+ 471F 20 20 20 20          defb %00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000 ; char 158
 186+ 4723 20 20 20 20
 187+ 4727 04 08 08 10          defb %00000100,%00001000,%00001000,%00010000,%00100000,%01000000,%01000000,%10000000 ; char 159
 187+ 472B 20 40 40 80
 188+ 472F 80 40 40 20          defb %10000000,%01000000,%01000000,%00100000,%00010000,%00001000,%00001000,%00000100 ; char 160
 188+ 4733 10 08 08 04
 189+ 4737 84 48 48 30          defb %10000100,%01001000,%01001000,%00110000,%00110000,%01001000,%01001000,%10000100 ; char 161
 189+ 473B 30 48 48 84
 190+ 473F 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 162
 190+ 4743 00 00 FC FC
 191+ 4747 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111100,%11111100,%11111100,%11111100 ; char 163
 191+ 474B FC FC FC FC
 192+ 474F 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 164
 192+ 4753 FC FC FC FC
 193+ 4757 FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 193+ 475B 00 00 00 00
 194+ 475F FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 166
 194+ 4763 00 00 00 00
 195+ 4767 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 167
 195+ 476B FC FC 00 00
 196+ 476F 80 80 80 80          defb %10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000 ; char 168
 196+ 4773 80 80 80 80
 197+ 4777 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000 ; char 169
 197+ 477B E0 E0 E0 E0
 198+ 477F F8 F8 F8 F8          defb %11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000 ; char 170
 198+ 4783 F8 F8 F8 F8
 199+ 4787 04 04 04 04          defb %00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100 ; char 171
 199+ 478B 04 04 04 04
 200+ 478F 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100 ; char 172
 200+ 4793 1C 1C 1C 1C
 201+ 4797 7C 7C 7C 7C          defb %01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100 ; char 173
 201+ 479B 7C 7C 7C 7C
 202+ 479F FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 174
 202+ 47A3 84 84 84 FC
 203+ 47A7 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%11100000,%11100000,%11100000 ; char 175
 203+ 47AB E0 E0 E0 E0
 204+ 47AF 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00011100,%00011100,%00011100 ; char 176
 204+ 47B3 1C 1C 1C 1C
 205+ 47B7 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 177
 205+ 47BB 00 00 00 00
 206+ 47BF E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 178
 206+ 47C3 00 00 00 00
 207+ 47C7 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00011100,%00011100,%00011100,%00011100 ; char 179
 207+ 47CB 1C 1C 1C 1C
 208+ 47CF 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%11100000,%11100000,%11100000,%11100000 ; char 180
 208+ 47D3 E0 E0 E0 E0
 209+ 47D7 78 78 78 78          defb %01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000 ; char 181
 209+ 47DB 78 78 78 78
 210+ 47DF CC CC CC CC          defb %11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100 ; char 182
 210+ 47E3 CC CC CC CC
 211+ 47E7 FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 183
 211+ 47EB 00 00 FC FC
 212+ 47EF 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 184
 212+ 47F3 FC FC 00 00
 213+ 47F7 30 30 CC CC          defb %00110000,%00110000,%11001100,%11001100,%00110000,%00110000,%11001100,%11001100 ; char 185
 213+ 47FB 30 30 CC CC
 214+ 47FF 54 A8 54 A8          defb %01010100,%10101000,%01010100,%10101000,%01010100,%10101000,%01010100,%10101000 ; char 186
 214+ 4803 54 A8 54 A8
 215+ 4807 64 30 98 CC          defb %01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100 ; char 187
 215+ 480B 64 30 98 CC
 216+ 480F CC 64 30 98          defb %11001100,%01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000 ; char 188
 216+ 4813 CC 64 30 98
 217+ 4817 30 98 CC 64          defb %00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100,%01100100 ; char 189
 217+ 481B 30 98 CC 64
 218+ 481F 64 CC 98 30          defb %01100100,%11001100,%10011000,%00110000,%01100100,%11001100,%10011000,%00110000 ; char 190
 218+ 4823 64 CC 98 30
 219+ 4827 20 20 F8 20          defb %00100000,%00100000,%11111000,%00100000,%00100000,%00000000,%11111000,%00000000 ; char 191 (Â±)
 219+ 482B 20 00 F8 00
 220+ 482F C0 30 08 30          defb %11000000,%00110000,%00001000,%00110000,%11000000,%00000000,%11111000,%00000000 ; char 192 (â¥)
 220+ 4833 C0 00 F8 00
 221+ 4837 18 60 80 60          defb %00011000,%01100000,%10000000,%01100000,%00011000,%00000000,%11111000,%00000000 ; char 193 (â¤)
 221+ 483B 18 00 F8 00
 222+ 483F 3C 20 20 20          defb %00111100,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 222+ 4843 A0 60 20 00
 223+ 4847 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 223+ 484B 00 00 00 00
 224+ 484F 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 224+ 4853 70 00 00 00
 225+ 4857 00 00 54 A8          defb %00000000,%00000000,%01010100,%10101000,%00000000,%11111100,%00000000,%00000000 ; char 197
 225+ 485B 00 FC 00 00
 226+ 485F 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 226+ 4863 54 A8 00 00
 227+ 4867 00 80 C0 E0          defb %00000000,%10000000,%11000000,%11100000,%11100000,%11000000,%10000000,%00000000 ; char 199
 227+ 486B E0 C0 80 00
 228+ 486F FC 78 30 00          defb %11111100,%01111000,%00110000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 200
 228+ 4873 00 00 00 00
 229+ 4877 00 04 0C 1C          defb %00000000,%00000100,%00001100,%00011100,%00011100,%00001100,%00000100,%00000000 ; char 201
 229+ 487B 1C 0C 04 00
 230+ 487F 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00110000,%01111000,%11111100 ; char 202
 230+ 4883 00 30 78 FC
 231+ 4887 20 70 F8 20          defb %00100000,%01110000,%11111000,%00100000,%00100000,%00100000,%00100000,%00000000 ; char 203 (up arrow)
 231+ 488B 20 20 20 00
 232+ 488F 3C 1C 1C 24          defb %00111100,%00011100,%00011100,%00100100,%01000000,%10000000,%00000000,%00000000 ; char 204 (up right arrow)
 232+ 4893 40 80 00 00
 233+ 4897 00 10 18 FC          defb %00000000,%00010000,%00011000,%11111100,%00011000,%00010000,%00000000,%00000000 ; char 205 (right arrow)
 233+ 489B 18 10 00 00
 234+ 489F 00 00 80 40          defb %00000000,%00000000,%10000000,%01000000,%00100100,%00011100,%00011100,%00111100 ; char 206 (down right arrow)
 234+ 48A3 24 1C 1C 3C
 235+ 48A7 00 20 20 20          defb %00000000,%00100000,%00100000,%00100000,%00100000,%11111000,%01110000,%00100000 ; char 207 (down arrow)
 235+ 48AB 20 F8 70 20
 236+ 48AF 00 00 04 08          defb %00000000,%00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000 ; char 208 (down left arrow)
 236+ 48B3 90 E0 E0 F0
 237+ 48B7 00 20 60 FC          defb %00000000,%00100000,%01100000,%11111100,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 237+ 48BB 60 20 00 00
 238+ 48BF F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 238+ 48C3 08 04 00 00
 239+ 48C7 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 239+ 48CB F0 44 38 00
 240+ 48CF 00 04 78 A8          defb %00000000,%00000100,%01111000,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 240+ 48D3 28 28 28 00
 241+ 48D7 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00100000,%00100000,%00100000 ; char 213
 241+ 48DB 1C 20 20 20
 242+ 48DF 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%00010000,%00010000,%00010000 ; char 214
 242+ 48E3 E0 10 10 10
 243+ 48E7 10 10 10 E0          defb %00010000,%00010000,%00010000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 215
 243+ 48EB 00 00 00 00
 244+ 48EF 20 20 20 1C          defb %00100000,%00100000,%00100000,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 216
 244+ 48F3 00 00 00 00
 245+ 48F7 00 00 00 1C          defb %00000000,%00000000,%00000000,%00011100,%00111100,%00110000,%00110000,%00110000 ; char 217
 245+ 48FB 3C 30 30 30
 246+ 48FF 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00110000,%00110000,%00110000 ; char 218
 246+ 4903 F0 30 30 30
 247+ 4907 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 247+ 490B E0 00 00 00
 248+ 490F 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00011100,%00000000,%00000000,%00000000 ; char 220
 248+ 4913 1C 00 00 00
 249+ 4917 00 30 48 48          defb %00000000,%00110000,%01001000,%01001000,%01001000,%00110000,%00000000,%00000000 ; char 221
 249+ 491B 48 30 00 00
 250+ 491F 00 30 78 78          defb %00000000,%00110000,%01111000,%01111000,%01111000,%00110000,%00000000,%00000000 ; char 222
 250+ 4923 78 30 00 00
 251+ 4927 00 30 78 FC          defb %00000000,%00110000,%01111000,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 223
 251+ 492B FC 78 30 00
 252+ 492F FC F8 F0 E0          defb %11111100,%11111000,%11110000,%11100000,%11100000,%11000000,%10000000,%10000000 ; char 224
 252+ 4933 E0 C0 80 80
 253+ 4937 FC 7C 3C 1C          defb %11111100,%01111100,%00111100,%00011100,%00011100,%00001100,%00000100,%00000100 ; char 225
 253+ 493B 1C 0C 04 04
 254+ 493F 04 04 0C 1C          defb %00000100,%00000100,%00001100,%00011100,%00011100,%00111100,%01111100,%11111100 ; char 226
 254+ 4943 1C 3C 7C FC
 255+ 4947 80 80 C0 E0          defb %10000000,%10000000,%11000000,%11100000,%11100000,%11110000,%11111000,%11111100 ; char 227
 255+ 494B E0 F0 F8 FC
 256+ 494F 00 04 0C D8          defb %00000000,%00000100,%00001100,%11011000,%11110000,%11100000,%11000000,%00000000 ; char 228 (checkmark)
 256+ 4953 F0 E0 C0 00
 257+ 4957 00 CC 78 30          defb %00000000,%11001100,%01111000,%00110000,%01111000,%11001100,%00000000,%00000000 ; char 229 (x)
 257+ 495B 78 CC 00 00
 258+ 495F 70 88 88 88          defb %01110000,%10001000,%10001000,%10001000,%01110000,%00100000,%01110000,%00100000 ; char 230 (female)
 258+ 4963 70 20 70 20
 259+ 4967 00 1C 0C 74          defb %00000000,%00011100,%00001100,%01110100,%10010000,%10010000,%01100000,%00000000 ; char 231 (male)
 259+ 496B 90 90 60 00
 260+ 496F F8 84 84 84          defb %11111000,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 232 (new doc)
 260+ 4973 84 84 84 FC
 261+ 4977 00 F0 FC 84          defb %00000000,%11110000,%11111100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 233 (folder)
 261+ 497B 84 84 84 FC
 262+ 497F 30 78 FC 48          defb %00110000,%01111000,%11111100,%01001000,%01001000,%01001000,%01001000,%01111000 ; char 234 (trash bin)
 262+ 4983 48 48 48 78
 263+ 4987 FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%11111100,%10110100,%10110100,%11111100 ; char 235 (floppy disk)
 263+ 498B FC B4 B4 FC
 264+ 498F 00 00 D4 D8          defb %00000000,%00000000,%11010100,%11011000,%11010100,%11010100,%00000000,%00000000 ; char 236 (OK)
 264+ 4993 D4 D4 00 00
 265+ 4997 30 78 FC 78          defb %00110000,%01111000,%11111100,%01111000,%01111000,%01001000,%01001000,%01001000 ; char 237 (home)
 265+ 499B 78 48 48 48
 266+ 499F 78 84 A4 A4          defb %01111000,%10000100,%10100100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 238 (clock)
 266+ 49A3 B4 84 78 00
 267+ 49A7 00 00 08 F4          defb %00000000,%00000000,%00001000,%11110100,%10101000,%10000000,%00000000,%00000000 ; char 239 (key)
 267+ 49AB A8 80 00 00
 268+ 49AF 20 30 78 B0          defb %00100000,%00110000,%01111000,%10110000,%10100000,%10001000,%01110000,%00000000 ; char 240 (undo)
 268+ 49B3 A0 88 70 00
 269+ 49B7 00 FC CC B4          defb %00000000,%11111100,%11001100,%10110100,%10000100,%10000100,%11111100,%00000000 ; char 241 (letter)
 269+ 49BB 84 84 FC 00
 270+ 49BF 60 90 90 F0          defb %01100000,%10010000,%10010000,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 242 (lock)
 270+ 49C3 F0 F0 F0 00
 271+ 49C7 08 14 14 F0          defb %00001000,%00010100,%00010100,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 243 (unlock)
 271+ 49CB F0 F0 F0 00
 272+ 49CF FC FC 84 B4          defb %11111100,%11111100,%10000100,%10110100,%10010100,%10010100,%10000100,%11111100 ; char 244 (calendar)
 272+ 49D3 94 94 84 FC
 273+ 49D7 00 04 38 58          defb %00000000,%00000100,%00111000,%01011000,%01101000,%01110000,%10000000,%00000000 ; char 245 (diameter)
 273+ 49DB 68 70 80 00
 274+ 49DF 78 84 84 84          defb %01111000,%10000100,%10000100,%10000100,%01101100,%00011000,%00001000,%00000000 ; char 246 (baloon)
 274+ 49E3 6C 18 08 00
 275+ 49E7 30 28 28 28          defb %00110000,%00101000,%00101000,%00101000,%00100000,%01100000,%11100000,%01000000 ; char 247 (note)
 275+ 49EB 20 60 E0 40
 276+ 49EF 20 68 E4 E4          defb %00100000,%01101000,%11100100,%11100100,%11100100,%01101000,%00100000,%00000000 ; char 248 (audio on)
 276+ 49F3 E4 68 20 00
 277+ 49F7 20 60 E0 E0          defb %00100000,%01100000,%11100000,%11100000,%11100000,%01100000,%00100000,%00000000 ; char 249 (audio off)
 277+ 49FB E0 60 20 00
 278+ 49FF 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11110000,%10010000 ; char 250 (pointer)
 278+ 4A03 F8 FC F0 90
 279+ 4A07 78 84 B4 A4          defb %01111000,%10000100,%10110100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 251 (Â©)
 279+ 4A0B B4 84 78 00
 280+ 4A0F 30 48 40 E0          defb %00110000,%01001000,%01000000,%11100000,%01000000,%01001000,%10110000,%00000000 ; char 252 (Â£)
 280+ 4A13 40 48 B0 00
 281+ 4A17 78 84 F0 48          defb %01111000,%10000100,%11110000,%01001000,%01001000,%00111100,%10000100,%01111000 ; char 253 (Â§)
 281+ 4A1B 48 3C 84 78
 282+ 4A1F 00 00 20 00          defb %00000000,%00000000,%00100000,%00000000,%11111000,%00000000,%00100000,%00000000 ; char 254 (Ã·)
 282+ 4A23 F8 00 20 00
 283+ 4A27 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 255 (cursor)
 283+ 4A2B FC FC FC FC
 284+ 4A2F                      ; here ends the ASCII table
 285+ 4A2F
# file closed: ../include/vdp/6x8fonts-r16.asm
  82  4A2F                  INCLUDE "../include/vdp/8x8fonts-r18.asm"
# file opened: ../include/vdp/8x8fonts-r18.asm
   1+ 4A2F              ; ------------------------------------------------------------------------------
   2+ 4A2F              ; LM80C - 8x8 CHARSET - R1.8
   3+ 4A2F              ; ------------------------------------------------------------------------------
   4+ 4A2F              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4A2F              ; designed by Leonardo Miliani. More info at
   6+ 4A2F              ; www DOT leonardomiliani DOT com
   7+ 4A2F              ; ------------------------------------------------------------------------------
   8+ 4A2F              ; Code Revision:
   9+ 4A2F              ; R1.0 - 20190615 - First revision: ASCII chars (from 0 to 255) - actually, they are 6x8 pixels
  10+ 4A2F              ; R1.1 - 20190616 - Converted to 8x8 pixels
  11+ 4A2F              ; R1.2 - 20191013 - Added new graphic chars and reorganized previous ones
  12+ 4A2F              ; R1.3 - 20191015 - More graphic chars
  13+ 4A2F              ; R1.4 - 20191202 - Fixed char 11/12, added new special chars
  14+ 4A2F              ; R1.5 - 20191210 - Changed several graphic chars
  15+ 4A2F              ; R1.6 - 20200125 - Removed double chars, changed with new ones
  16+ 4A2F              ; R1.7 - 20200228 - adopted more usual hexadecimal & binary prefixes
  17+ 4A2F              ; R1.8 - 20200524 - New style for char #252
  18+ 4A2F              ; ------------------------------------------------------------------------------
  19+ 4A2F              ;
  20+ 4A2F              ;-------------------------------------------------------------------------------
  21+ 4A2F              ;
  22+ 4A2F              ;               8 x 8    C  H  A  R  S  E  T
  23+ 4A2F              ;
  24+ 4A2F              ;-------------------------------------------------------------------------------
  25+ 4A2F              ;
  26+ 4A2F              ;       8X8 CHARS, DESIGNED FOR GRAPHICS 1 MODE
  27+ 4A2F
  28+ 4A2F              CHRST88 equ $
  29+ 4A2F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  29+ 4A33 00 00 00 00
  30+ 4A37 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  30+ 4A3B 00 00 00 00
  31+ 4A3F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  31+ 4A43 00 00 00 00
  32+ 4A47 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  32+ 4A4B 00 00 00 00
  33+ 4A4F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  33+ 4A53 00 00 00 00
  34+ 4A57 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  34+ 4A5B 00 00 00 00
  35+ 4A5F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  35+ 4A63 00 00 00 00
  36+ 4A67 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  36+ 4A6B 00 00 00 00
  37+ 4A6F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 DEL key (backspace)
  37+ 4A73 00 00 00 00
  38+ 4A77 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  38+ 4A7B 00 00 00 00
  39+ 4A7F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  39+ 4A83 00 00 00 00
  40+ 4A87 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 (unused)
  40+ 4A8B 00 00 00 00
  41+ 4A8F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  41+ 4A93 00 00 00 00
  42+ 4A97 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 RETURN key (carriage return)
  42+ 4A9B 00 00 00 00
  43+ 4A9F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL key
  43+ 4AA3 00 00 00 00
  44+ 4AA7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  44+ 4AAB 00 00 00 00
  45+ 4AAF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  45+ 4AB3 00 00 00 00
  46+ 4AB7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  46+ 4ABB 00 00 00 00
  47+ 4ABF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  47+ 4AC3 00 00 00 00
  48+ 4AC7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  48+ 4ACB 00 00 00 00
  49+ 4ACF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT key
  49+ 4AD3 00 00 00 00
  50+ 4AD7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  50+ 4ADB 00 00 00 00
  51+ 4ADF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6 key
  51+ 4AE3 00 00 00 00
  52+ 4AE7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7 key
  52+ 4AEB 00 00 00 00
  53+ 4AEF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP key
  53+ 4AF3 00 00 00 00
  54+ 4AF7 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 HOME key
  54+ 4AFB 00 00 00 00
  55+ 4AFF 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26 INSERT key
  55+ 4B03 00 00 00 00
  56+ 4B07 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 ESCAPE key
  56+ 4B0B 00 00 00 00
  57+ 4B0F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 CRSR LEFT key (cursor left)
  57+ 4B13 00 00 00 00
  58+ 4B17 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 CRSR RIGHT key (cursor right)
  58+ 4B1B 00 00 00 00
  59+ 4B1F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 CRSR UP key (cursor up)
  59+ 4B23 00 00 00 00
  60+ 4B27 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 CRSR DOWN key (cursor down)
  60+ 4B2B 00 00 00 00
  61+ 4B2F 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32 SPACE key
  61+ 4B33 00 00 00 00
  62+ 4B37 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00000000,%00010000,%00000000 ; char 33 - !
  62+ 4B3B 10 00 10 00
  63+ 4B3F 28 28 28 00          defb %00101000,%00101000,%00101000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 34 - "
  63+ 4B43 00 00 00 00
  64+ 4B47 28 28 FE 28          defb %00101000,%00101000,%11111110,%00101000,%11111110,%00101000,%00101000,%00000000 ; char 35 - #
  64+ 4B4B FE 28 28 00
  65+ 4B4F 10 3C 50 38          defb %00010000,%00111100,%01010000,%00111000,%00010100,%01111000,%00010000,%00000000 ; char 36 - $
  65+ 4B53 14 78 10 00
  66+ 4B57 00 62 64 08          defb %00000000,%01100010,%01100100,%00001000,%00010000,%00100110,%01000110,%00000000 ; char 37 - %
  66+ 4B5B 10 26 46 00
  67+ 4B5F 00 30 48 30          defb %00000000,%00110000,%01001000,%00110000,%01001010,%01000100,%00111010,%00000000 ; char 38 - &
  67+ 4B63 4A 44 3A 00
  68+ 4B67 08 10 20 00          defb %00001000,%00010000,%00100000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 39 - '
  68+ 4B6B 00 00 00 00
  69+ 4B6F 08 10 20 20          defb %00001000,%00010000,%00100000,%00100000,%00100000,%00010000,%00001000,%00000000 ; char 40 - (
  69+ 4B73 20 10 08 00
  70+ 4B77 20 10 08 08          defb %00100000,%00010000,%00001000,%00001000,%00001000,%00010000,%00100000,%00000000 ; char 41 - )
  70+ 4B7B 08 10 20 00
  71+ 4B7F 00 10 54 38          defb %00000000,%00010000,%01010100,%00111000,%00111000,%01010100,%00010000,%00000000 ; char 42 - *
  71+ 4B83 38 54 10 00
  72+ 4B87 00 10 10 7C          defb %00000000,%00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%00000000 ; char 43 - +
  72+ 4B8B 10 10 00 00
  73+ 4B8F 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00001000,%00010000 ; char 44 - ,
  73+ 4B93 00 18 08 10
  74+ 4B97 00 00 00 7C          defb %00000000,%00000000,%00000000,%01111100,%00000000,%00000000,%00000000,%00000000 ; char 45 - -
  74+ 4B9B 00 00 00 00
  75+ 4B9F 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00011000,%00000000 ; char 46 - .
  75+ 4BA3 00 18 18 00
  76+ 4BA7 00 02 04 08          defb %00000000,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%00000000 ; char 47 - /
  76+ 4BAB 10 20 40 00
  77+ 4BAF 38 44 4C 54          defb %00111000,%01000100,%01001100,%01010100,%01100100,%01000100,%00111000,%00000000 ; char 48 - 0
  77+ 4BB3 64 44 38 00
  78+ 4BB7 10 30 50 10          defb %00010000,%00110000,%01010000,%00010000,%00010000,%00010000,%01111100,%00000000 ; char 49 - 1
  78+ 4BBB 10 10 7C 00
  79+ 4BBF 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 50 - 2
  79+ 4BC3 10 20 7C 00
  80+ 4BC7 7C 08 10 08          defb %01111100,%00001000,%00010000,%00001000,%00000100,%01000100,%00111000,%00000000 ; char 51 - 3
  80+ 4BCB 04 44 38 00
  81+ 4BCF 08 18 28 48          defb %00001000,%00011000,%00101000,%01001000,%01111100,%00001000,%00001000,%00000000 ; char 52 - 4
  81+ 4BD3 7C 08 08 00
  82+ 4BD7 7C 40 78 04          defb %01111100,%01000000,%01111000,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 53 - 5
  82+ 4BDB 04 44 38 00
  83+ 4BDF 38 44 40 78          defb %00111000,%01000100,%01000000,%01111000,%01000100,%01000100,%00111000,%00000000 ; char 54 - 6
  83+ 4BE3 44 44 38 00
  84+ 4BE7 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%00100000,%00100000,%00000000 ; char 55 - 7
  84+ 4BEB 20 20 20 00
  85+ 4BEF 38 44 44 38          defb %00111000,%01000100,%01000100,%00111000,%01000100,%01000100,%00111000,%00000000 ; char 56 - 8
  85+ 4BF3 44 44 38 00
  86+ 4BF7 38 44 44 3C          defb %00111000,%01000100,%01000100,%00111100,%00000100,%01000100,%00111000,%00000000 ; char 57 - 9
  86+ 4BFB 04 44 38 00
  87+ 4BFF 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00011000,%00000000,%00000000 ; char 58 - :
  87+ 4C03 18 18 00 00
  88+ 4C07 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00001000,%00010000,%00000000 ; char 59 - ;
  88+ 4C0B 18 08 10 00
  89+ 4C0F 04 08 10 20          defb %00000100,%00001000,%00010000,%00100000,%00010000,%00001000,%00000100,%00000000 ; char 60 - <
  89+ 4C13 10 08 04 00
  90+ 4C17 00 00 7E 00          defb %00000000,%00000000,%01111110,%00000000,%01111110,%00000000,%00000000,%00000000 ; char 61 - =
  90+ 4C1B 7E 00 00 00
  91+ 4C1F 20 10 08 04          defb %00100000,%00010000,%00001000,%00000100,%00001000,%00010000,%00100000,%00000000 ; char 62 - >
  91+ 4C23 08 10 20 00
  92+ 4C27 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00000000,%00010000,%00000000 ; char 63 - ?
  92+ 4C2B 10 00 10 00
  93+ 4C2F 78 84 BC AC          defb %01111000,%10000100,%10111100,%10101100,%10111000,%10000000,%10000100,%01111000 ; char 64 - @
  93+ 4C33 B8 80 84 78
  94+ 4C37 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%00000000 ; char 65 - A
  94+ 4C3B 7C 44 44 00
  95+ 4C3F 78 44 44 78          defb %01111000,%01000100,%01000100,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 66 - B
  95+ 4C43 44 44 78 00
  96+ 4C47 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 67 - C
  96+ 4C4B 40 44 38 00
  97+ 4C4F 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01000100,%01000100,%01111000,%00000000 ; char 68 - D
  97+ 4C53 44 44 78 00
  98+ 4C57 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01111100,%00000000 ; char 69 - E
  98+ 4C5B 40 40 7C 00
  99+ 4C5F 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01000000,%00000000 ; char 70 - F
  99+ 4C63 40 40 40 00
 100+ 4C67 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01011100,%01000100,%00111000,%00000000 ; char 71 - G
 100+ 4C6B 5C 44 38 00
 101+ 4C6F 44 44 44 7C          defb %01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%01000100,%00000000 ; char 72 - H
 101+ 4C73 44 44 44 00
 102+ 4C77 38 10 10 10          defb %00111000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 73 - I
 102+ 4C7B 10 10 38 00
 103+ 4C7F 3C 04 04 04          defb %00111100,%00000100,%00000100,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 74 - J
 103+ 4C83 04 44 38 00
 104+ 4C87 44 44 48 70          defb %01000100,%01000100,%01001000,%01110000,%01001000,%01000100,%01000100,%00000000 ; char 75 - K
 104+ 4C8B 48 44 44 00
 105+ 4C8F 40 40 40 40          defb %01000000,%01000000,%01000000,%01000000,%01000000,%01000000,%01111100,%00000000 ; char 76 - L
 105+ 4C93 40 40 7C 00
 106+ 4C97 42 66 5A 42          defb %01000010,%01100110,%01011010,%01000010,%01000010,%01000010,%01000010,%00000000 ; char 77 - M
 106+ 4C9B 42 42 42 00
 107+ 4C9F 44 64 54 4C          defb %01000100,%01100100,%01010100,%01001100,%01000100,%01000100,%01000100,%00000000 ; char 78 - N
 107+ 4CA3 44 44 44 00
 108+ 4CA7 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 79 - O
 108+ 4CAB 44 44 38 00
 109+ 4CAF 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01000000,%01000000,%00000000 ; char 80 - P
 109+ 4CB3 78 40 40 00
 110+ 4CB7 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01010100,%01001000,%00110100,%00000000 ; char 81 - Q
 110+ 4CBB 54 48 34 00
 111+ 4CBF 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01001000,%01000100,%00000000 ; char 82 - R
 111+ 4CC3 78 48 44 00
 112+ 4CC7 3C 40 40 38          defb %00111100,%01000000,%01000000,%00111000,%00000100,%00000100,%01111000,%00000000 ; char 83 - S
 112+ 4CCB 04 04 78 00
 113+ 4CCF 7C 10 10 10          defb %01111100,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 84 - T
 113+ 4CD3 10 10 10 00
 114+ 4CD7 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 85 - U
 114+ 4CDB 44 44 38 00
 115+ 4CDF 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 86 - V
 115+ 4CE3 44 28 10 00
 116+ 4CE7 42 42 42 42          defb %01000010,%01000010,%01000010,%01000010,%01011010,%01011010,%00100100,%00000000 ; char 87 - W
 116+ 4CEB 5A 5A 24 00
 117+ 4CEF 44 44 28 10          defb %01000100,%01000100,%00101000,%00010000,%00101000,%01000100,%01000100,%00000000 ; char 88 - X
 117+ 4CF3 28 44 44 00
 118+ 4CF7 44 44 44 28          defb %01000100,%01000100,%01000100,%00101000,%00010000,%00010000,%00010000,%00000000 ; char 89 - Y
 118+ 4CFB 10 10 10 00
 119+ 4CFF 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%01000000,%01111100,%00000000 ; char 90 - Z
 119+ 4D03 20 40 7C 00
 120+ 4D07 38 20 20 20          defb %00111000,%00100000,%00100000,%00100000,%00100000,%00100000,%00111000,%00000000 ; char 91 - [
 120+ 4D0B 20 20 38 00
 121+ 4D0F 00 40 20 10          defb %00000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000000 ; char 92 - \
 121+ 4D13 08 04 02 00
 122+ 4D17 38 08 08 08          defb %00111000,%00001000,%00001000,%00001000,%00001000,%00001000,%00111000,%00000000 ; char 93 - ]
 122+ 4D1B 08 08 38 00
 123+ 4D1F 10 28 44 00          defb %00010000,%00101000,%01000100,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 94 - ^
 123+ 4D23 00 00 00 00
 124+ 4D27 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%01111110,%00000000 ; char 95 _ (underscore)
 124+ 4D2B 00 00 7E 00
 125+ 4D2F 20 10 08 00          defb %00100000,%00010000,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 96 - `
 125+ 4D33 00 00 00 00
 126+ 4D37 00 00 38 04          defb %00000000,%00000000,%00111000,%00000100,%00111100,%01000100,%00111100,%00000000 ; char 97 - a
 126+ 4D3B 3C 44 3C 00
 127+ 4D3F 40 40 40 78          defb %01000000,%01000000,%01000000,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 98 - b
 127+ 4D43 44 44 78 00
 128+ 4D47 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 99 - c
 128+ 4D4B 40 44 38 00
 129+ 4D4F 04 04 04 3C          defb %00000100,%00000100,%00000100,%00111100,%01000100,%01000100,%00111100,%00000000 ; char 100 - d
 129+ 4D53 44 44 3C 00
 130+ 4D57 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01111100,%01000000,%00111000,%00000000 ; char 101 - e
 130+ 4D5B 7C 40 38 00
 131+ 4D5F 18 24 20 70          defb %00011000,%00100100,%00100000,%01110000,%00100000,%00100000,%00100000,%00000000 ; char 102 - f
 131+ 4D63 20 20 20 00
 132+ 4D67 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00111000 ; char 103 - g
 132+ 4D6B 44 3C 04 38
 133+ 4D6F 40 40 58 64          defb %01000000,%01000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 104 - h
 133+ 4D73 44 44 44 00
 134+ 4D77 00 10 00 10          defb %00000000,%00010000,%00000000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 105 - i
 134+ 4D7B 10 10 10 00
 135+ 4D7F 08 00 18 08          defb %00001000,%00000000,%00011000,%00001000,%00001000,%00001000,%01001000,%00110000 ; char 106 - j
 135+ 4D83 08 08 48 30
 136+ 4D87 40 40 48 50          defb %01000000,%01000000,%01001000,%01010000,%01100000,%01010000,%01001000,%00000000 ; char 107 - k
 136+ 4D8B 60 50 48 00
 137+ 4D8F 30 10 10 10          defb %00110000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 108 - l
 137+ 4D93 10 10 38 00
 138+ 4D97 00 00 54 6A          defb %00000000,%00000000,%01010100,%01101010,%01001010,%01000010,%01000010,%00000000 ; char 109 - m
 138+ 4D9B 4A 42 42 00
 139+ 4D9F 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 110 - n
 139+ 4DA3 44 44 44 00
 140+ 4DA7 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 111: o
 140+ 4DAB 44 44 38 00
 141+ 4DAF 00 00 78 44          defb %00000000,%00000000,%01111000,%01000100,%01000100,%01111000,%01000000,%01000000 ; char 112: p
 141+ 4DB3 44 78 40 40
 142+ 4DB7 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00000100 ; char 113: q
 142+ 4DBB 44 3C 04 04
 143+ 4DBF 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000000,%01000000,%01000000,%00000000 ; char 114: r
 143+ 4DC3 40 40 40 00
 144+ 4DC7 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%00111000,%00000100,%01111000,%00000000 ; char 115: s
 144+ 4DCB 38 04 78 00
 145+ 4DCF 20 20 70 20          defb %00100000,%00100000,%01110000,%00100000,%00100000,%00100100,%00011000,%00000000 ; char 116: t
 145+ 4DD3 20 24 18 00
 146+ 4DD7 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%01001100,%00110100,%00000000 ; char 117: u
 146+ 4DDB 44 4C 34 00
 147+ 4DDF 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 118: v
 147+ 4DE3 44 28 10 00
 148+ 4DE7 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01010100,%01010100,%00101000,%00000000 ; char 119: w
 148+ 4DEB 54 54 28 00
 149+ 4DEF 00 00 44 28          defb %00000000,%00000000,%01000100,%00101000,%00010000,%00101000,%01000100,%00000000 ; char 120: x
 149+ 4DF3 10 28 44 00
 150+ 4DF7 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01001100,%00110100,%00000100,%00111000 ; char 121: y
 150+ 4DFB 4C 34 04 38
 151+ 4DFF 00 00 7C 08          defb %00000000,%00000000,%01111100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 122: z
 151+ 4E03 10 20 7C 00
 152+ 4E07 18 20 20 40          defb %00011000,%00100000,%00100000,%01000000,%00100000,%00100000,%00011000,%00000000 ; char 123: {
 152+ 4E0B 20 20 18 00
 153+ 4E0F 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 124: |
 153+ 4E13 10 10 10 00
 154+ 4E17 30 08 08 04          defb %00110000,%00001000,%00001000,%00000100,%00001000,%00001000,%00110000,%00000000 ; char 125: }
 154+ 4E1B 08 08 30 00
 155+ 4E1F 20 54 08 00          defb %00100000,%01010100,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 126: ~
 155+ 4E23 00 00 00 00
 156+ 4E27 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 127 (delete) - end the standard ASCII (0-127)
 156+ 4E2B 00 00 00 00
 157+ 4E2F 3C 42 A5 81          defb %00111100,%01000010,%10100101,%10000001,%10100101,%10011001,%01000010,%00111100 ; char 128 (open face)
 157+ 4E33 A5 99 42 3C
 158+ 4E37 3C 7E DB FF          defb %00111100,%01111110,%11011011,%11111111,%11011011,%11100111,%01111110,%00111100 ; char 129 (full face)
 158+ 4E3B DB E7 7E 3C
 159+ 4E3F 6C FE FE FE          defb %01101100,%11111110,%11111110,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 130 (hearts)
 159+ 4E43 7C 38 10 00
 160+ 4E47 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 131 (diamonds)
 160+ 4E4B 7C 38 10 00
 161+ 4E4F 10 38 54 FE          defb %00010000,%00111000,%01010100,%11111110,%01010100,%00010000,%01111100,%00000000 ; char 132 (clus)
 161+ 4E53 54 10 7C 00
 162+ 4E57 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%11010110,%00010000,%01111100,%00000000 ; char 133 (spades)
 162+ 4E5B D6 10 7C 00
 163+ 4E5F 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 134
 163+ 4E63 FF 18 18 18
 164+ 4E67 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 135
 164+ 4E6B 1F 18 18 18
 165+ 4E6F 00 00 00 F8          defb %00000000,%00000000,%00000000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 136
 165+ 4E73 F8 18 18 18
 166+ 4E77 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00000000,%00000000,%00000000 ; char 137
 166+ 4E7B F8 00 00 00
 167+ 4E7F 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00000000,%00000000,%00000000 ; char 138
 167+ 4E83 1F 00 00 00
 168+ 4E87 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 139
 168+ 4E8B FF 00 00 00
 169+ 4E8F 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 140
 169+ 4E93 1F 18 18 18
 170+ 4E97 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 141
 170+ 4E9B FF 18 18 18
 171+ 4E9F 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 142
 171+ 4EA3 F8 18 18 18
 172+ 4EA7 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 143
 172+ 4EAB FF 00 00 00
 173+ 4EAF 18 18 18 18          defb %00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000 ; char 144
 173+ 4EB3 18 18 18 18
 174+ 4EB7 03 07 0E 1C          defb %00000011,%00000111,%00001110,%00011100,%00111000,%01110000,%11100000,%11000000 ; char 145
 174+ 4EBB 38 70 E0 C0
 175+ 4EBF C0 E0 70 38          defb %11000000,%11100000,%01110000,%00111000,%00011100,%00001110,%00000111,%00000011 ; char 146
 175+ 4EC3 1C 0E 07 03
 176+ 4EC7 C3 E7 7E 3C          defb %11000011,%11100111,%01111110,%00111100,%00111100,%01111110,%11100111,%11000011 ; char 147
 176+ 4ECB 3C 7E E7 C3
 177+ 4ECF 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 148
 177+ 4ED3 10 10 10 10
 178+ 4ED7 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 149
 178+ 4EDB 10 10 10 10
 179+ 4EDF 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 150
 179+ 4EE3 10 10 10 10
 180+ 4EE7 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 151
 180+ 4EEB 00 00 00 00
 181+ 4EEF 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00000000,%00000000,%00000000,%00000000 ; char 152
 181+ 4EF3 00 00 00 00
 182+ 4EF7 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 153
 182+ 4EFB 00 00 00 00
 183+ 4EFF 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 154
 183+ 4F03 10 10 10 10
 184+ 4F07 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 155
 184+ 4F0B 10 10 10 10
 185+ 4F0F 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 156
 185+ 4F13 10 10 10 10
 186+ 4F17 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 157
 186+ 4F1B 00 00 00 00
 187+ 4F1F 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000 ; char 158
 187+ 4F23 10 10 10 10
 188+ 4F27 01 02 04 08          defb %00000001,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%10000000 ; char 159
 188+ 4F2B 10 20 40 80
 189+ 4F2F 80 40 20 10          defb %10000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000001 ; char 160
 189+ 4F33 08 04 02 01
 190+ 4F37 81 42 24 18          defb %10000001,%01000010,%00100100,%00011000,%00011000,%00100100,%01000010,%10000001 ; char 161
 190+ 4F3B 18 24 42 81
 191+ 4F3F 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 162
 191+ 4F43 00 00 FF FF
 192+ 4F47 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; char 163
 192+ 4F4B FF FF FF FF
 193+ 4F4F 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 164
 193+ 4F53 FF FF FF FF
 194+ 4F57 FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 194+ 4F5B 00 00 00 00
 195+ 4F5F FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 166
 195+ 4F63 00 00 00 00
 196+ 4F67 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 167
 196+ 4F6B FF FF 00 00
 197+ 4F6F C0 C0 C0 C0          defb %11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000 ; char 168
 197+ 4F73 C0 C0 C0 C0
 198+ 4F77 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; char 169
 198+ 4F7B F0 F0 F0 F0
 199+ 4F7F FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 170
 199+ 4F83 FC FC FC FC
 200+ 4F87 03 03 03 03          defb %00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011 ; char 171
 200+ 4F8B 03 03 03 03
 201+ 4F8F 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; char 172
 201+ 4F93 0F 0F 0F 0F
 202+ 4F97 3F 3F 3F 3F          defb %00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111 ; char 173
 202+ 4F9B 3F 3F 3F 3F
 203+ 4F9F FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 174
 203+ 4FA3 81 81 81 FF
 204+ 4FA7 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; char 175
 204+ 4FAB F0 F0 F0 F0
 205+ 4FAF 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; char 176
 205+ 4FB3 0F 0F 0F 0F
 206+ 4FB7 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; char 177
 206+ 4FBB 00 00 00 00
 207+ 4FBF F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 178
 207+ 4FC3 00 00 00 00
 208+ 4FC7 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00001111,%00001111,%00001111,%00001111 ; char 179
 208+ 4FCB 0F 0F 0F 0F
 209+ 4FCF 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%11110000,%11110000,%11110000,%11110000 ; char 180
 209+ 4FD3 F0 F0 F0 F0
 210+ 4FD7 3C 3C 3C 3C          defb %00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100 ; char 181
 210+ 4FDB 3C 3C 3C 3C
 211+ 4FDF C3 C3 C3 C3          defb %11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011 ; char 182
 211+ 4FE3 C3 C3 C3 C3
 212+ 4FE7 FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 183
 212+ 4FEB 00 00 FF FF
 213+ 4FEF 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 184
 213+ 4FF3 FF FF 00 00
 214+ 4FF7 33 33 CC CC          defb %00110011,%00110011,%11001100,%11001100,%00110011,%00110011,%11001100,%11001100 ; char 185
 214+ 4FFB 33 33 CC CC
 215+ 4FFF 55 AA 55 AA          defb %01010101,%10101010,%01010101,%10101010,%01010101,%10101010,%01010101,%10101010 ; char 186
 215+ 5003 55 AA 55 AA
 216+ 5007 66 33 99 CC          defb %01100110,%00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100 ; char 187
 216+ 500B 66 33 99 CC
 217+ 500F CC 99 33 66          defb %11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011,%01100110 ; char 188
 217+ 5013 CC 99 33 66
 218+ 5017 33 99 CC 66          defb %00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100,%01100110 ; char 189
 218+ 501B 33 99 CC 66
 219+ 501F 66 CC 99 33          defb %01100110,%11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011 ; char 190
 219+ 5023 66 CC 99 33
 220+ 5027 10 10 7C 10          defb %00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%01111100,%00000000 ; char 191 (Â±)
 220+ 502B 10 00 7C 00
 221+ 502F 60 18 06 18          defb %01100000,%00011000,%00000110,%00011000,%01100000,%00000000,%01111110,%00000000 ; char 192 (â¥)
 221+ 5033 60 00 7E 00
 222+ 5037 06 18 60 18          defb %00000110,%00011000,%01100000,%00011000,%00000110,%00000000,%01111110,%00000000 ; char 193 (â¤)
 222+ 503B 06 00 7E 00
 223+ 503F 3E 20 20 20          defb %00111110,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 223+ 5043 A0 60 20 00
 224+ 5047 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 224+ 504B 00 00 00 00
 225+ 504F 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 225+ 5053 70 00 00 00
 226+ 5057 00 00 2A 54          defb %00000000,%00000000,%00101010,%01010100,%00000000,%01111110,%00000000,%00000000 ; char 197
 226+ 505B 00 7E 00 00
 227+ 505F 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 227+ 5063 54 A8 00 00
 228+ 5067 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11100000,%11000000,%10000000,%00000000 ; char 199
 228+ 506B E0 C0 80 00
 229+ 506F FE 7C 38 10          defb %11111110,%01111100,%00111000,%00010000,%00000000,%00000000,%00000000,%00000000 ; char 200
 229+ 5073 00 00 00 00
 230+ 5077 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00000111,%00000011,%00000001,%00000000 ; char 201
 230+ 507B 07 03 01 00
 231+ 507F 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00010000,%00111000,%01111100,%11111110 ; char 202
 231+ 5083 10 38 7C FE
 232+ 5087 10 38 7C 10          defb %00010000,%00111000,%01111100,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 203 (up arrow)
 232+ 508B 10 10 10 00
 233+ 508F 1E 0E 0E 12          defb %00011110,%00001110,%00001110,%00010010,%00100000,%01000000,%00000000,%00000000 ; char 204 (up right arrow)
 233+ 5093 20 40 00 00
 234+ 5097 00 08 0C FE          defb %00000000,%00001000,%00001100,%11111110,%00001100,%00001000,%00000000,%00000000 ; char 205 (right arrow)
 234+ 509B 0C 08 00 00
 235+ 509F 00 40 20 12          defb %00000000,%01000000,%00100000,%00010010,%00001110,%00001110,%00011110,%00000000 ; char 206 (down right arrow)
 235+ 50A3 0E 0E 1E 00
 236+ 50A7 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%01111100,%00111000,%00010000,%00000000 ; char 207 (down arrow)
 236+ 50AB 7C 38 10 00
 237+ 50AF 00 04 08 90          defb %00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000,%00000000 ; char 208 (down left arrow)
 237+ 50B3 E0 E0 F0 00
 238+ 50B7 00 20 60 FE          defb %00000000,%00100000,%01100000,%11111110,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 238+ 50BB 60 20 00 00
 239+ 50BF F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 239+ 50C3 08 04 00 00
 240+ 50C7 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 240+ 50CB F0 44 38 00
 241+ 50CF 00 02 7C A8          defb %00000000,%00000010,%01111100,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 241+ 50D3 28 28 28 00
 242+ 50D7 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001000,%00010000,%00010000,%00010000 ; char 213
 242+ 50DB 08 10 10 10
 243+ 50DF 00 00 00 C0          defb %00000000,%00000000,%00000000,%11000000,%00100000,%00010000,%00010000,%00010000 ; char 214
 243+ 50E3 20 10 10 10
 244+ 50E7 10 10 20 C0          defb %00010000,%00010000,%00100000,%11000000,%00000000,%00000000,%00000000,%00000000 ; char 215
 244+ 50EB 00 00 00 00
 245+ 50EF 10 10 08 07          defb %00010000,%00010000,%00001000,%00000111,%00000000,%00000000,%00000000,%00000000 ; char 216
 245+ 50F3 00 00 00 00
 246+ 50F7 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001111,%00011100,%00011000,%00011000 ; char 217
 246+ 50FB 0F 1C 18 18
 247+ 50FF 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00111000,%00011000,%00011000 ; char 218
 247+ 5103 F0 38 18 18
 248+ 5107 18 18 38 F0          defb %00011000,%00011000,%00111000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 248+ 510B E0 00 00 00
 249+ 510F 18 18 1C 0F          defb %00011000,%00011000,%00011100,%00001111,%00000111,%00000000,%00000000,%00000000 ; char 220
 249+ 5113 07 00 00 00
 250+ 5117 00 3C 42 42          defb %00000000,%00111100,%01000010,%01000010,%01000010,%01000010,%00111100,%00000000 ; char 221
 250+ 511B 42 42 3C 00
 251+ 511F 00 3C 7E 7E          defb %00000000,%00111100,%01111110,%01111110,%01111110,%01111110,%00111100,%00000000 ; char 222
 251+ 5123 7E 7E 3C 00
 252+ 5127 00 18 3C 7E          defb %00000000,%00011000,%00111100,%01111110,%01111110,%00111100,%00011000,%00000000 ; char 223
 252+ 512B 7E 3C 18 00
 253+ 512F FF FE FC F8          defb %11111111,%11111110,%11111100,%11111000,%11110000,%11100000,%11000000,%10000000 ; char 224
 253+ 5133 F0 E0 C0 80
 254+ 5137 FF 7F 3F 1F          defb %11111111,%01111111,%00111111,%00011111,%00001111,%00000111,%00000011,%00000001 ; char 225
 254+ 513B 0F 07 03 01
 255+ 513F 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00011111,%00111111,%01111111,%11111111 ; char 226
 255+ 5143 1F 3F 7F FF
 256+ 5147 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11111110,%11111111 ; char 227
 256+ 514B F8 FC FE FF
 257+ 514F 00 02 06 6C          defb %00000000,%00000010,%00000110,%01101100,%01111000,%01110000,%01100000,%00000000 ; char 228 (checkmark)
 257+ 5153 78 70 60 00
 258+ 5157 00 66 3C 18          defb %00000000,%01100110,%00111100,%00011000,%00111100,%01100110,%00000000,%00000000 ; char 229 (x)
 258+ 515B 3C 66 00 00
 259+ 515F 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%00111000,%00010000,%00111000,%00010000 ; char 230 (female)
 259+ 5163 38 10 38 10
 260+ 5167 07 03 3D 44          defb %00000111,%00000011,%00111101,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 231 (male)
 260+ 516B 44 44 38 00
 261+ 516F 78 44 42 42          defb %01111000,%01000100,%01000010,%01000010,%01000010,%01000010,%01000010,%01111110 ; char 232 (new doc)
 261+ 5173 42 42 42 7E
 262+ 5177 00 F8 FF 81          defb %00000000,%11111000,%11111111,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 233 (folder)
 262+ 517B 81 81 81 FF
 263+ 517F 10 7C FE 54          defb %00010000,%01111100,%11111110,%01010100,%01010100,%01010100,%01010100,%01111100 ; char 234 (trash bin)
 263+ 5183 54 54 54 7C
 264+ 5187 FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10111101,%10101101,%10101101,%11111111 ; char 235 (floppy disk)
 264+ 518B BD AD AD FF
 265+ 518F 00 EA AA AC          defb %00000000,%11101010,%10101010,%10101100,%10101100,%10101010,%11101010,%00000000 ; char 236 (OK)
 265+ 5193 AC AA EA 00
 266+ 5197 18 7E FF 7E          defb %00011000,%01111110,%11111111,%01111110,%01111110,%01100110,%01100110,%01100110 ; char 237 (home)
 266+ 519B 7E 66 66 66
 267+ 519F 3C 42 91 91          defb %00111100,%01000010,%10010001,%10010001,%10011101,%10000001,%01000010,%00111100 ; char 238 (clock)
 267+ 51A3 9D 81 42 3C
 268+ 51A7 00 02 05 FD          defb %00000000,%00000010,%00000101,%11111101,%10100101,%10100010,%00000000,%00000000 ; char 239 (key)
 268+ 51AB A5 A2 00 00
 269+ 51AF 08 0C 3E 4C          defb %00001000,%00001100,%00111110,%01001100,%01001000,%01000010,%01000010,%00111100 ; char 240 (undo)
 269+ 51B3 48 42 42 3C
 270+ 51B7 00 FF C3 A5          defb %00000000,%11111111,%11000011,%10100101,%10011001,%10000001,%11111111,%00000000 ; char 241 (letter)
 270+ 51BB 99 81 FF 00
 271+ 51BF 38 44 44 7C          defb %00111000,%01000100,%01000100,%01111100,%01111100,%01111100,%01111100,%00000000 ; char 242 (lock)
 271+ 51C3 7C 7C 7C 00
 272+ 51C7 06 09 09 F8          defb %00000110,%00001001,%00001001,%11111000,%11111000,%11111000,%11111000,%00000000 ; char 243 (unlock)
 272+ 51CB F8 F8 F8 00
 273+ 51CF FF FF 81 AD          defb %11111111,%11111111,%10000001,%10101101,%10100101,%10100101,%10000001,%11111111 ; char 244 (calendar)
 273+ 51D3 A5 A5 81 FF
 274+ 51D7 01 1A 24 4A          defb %00000001,%00011010,%00100100,%01001010,%01010010,%00100100,%01011000,%10000000 ; char 245 (diameter)
 274+ 51DB 52 24 58 80
 275+ 51DF 7E 81 81 81          defb %01111110,%10000001,%10000001,%10000001,%10000001,%01110110,%00001100,%00000100 ; char 246 (baloon)
 275+ 51E3 81 76 0C 04
 276+ 51E7 0C 0A 0A 0A          defb %00001100,%00001010,%00001010,%00001010,%00001000,%00011000,%00111000,%00010000 ; char 247 (note)
 276+ 51EB 08 18 38 10
 277+ 51EF 12 31 F5 F5          defb %00010010,%00110001,%11110101,%11110101,%11110101,%11110101,%00110001,%00010010 ; char 248 (audio on)
 277+ 51F3 F5 F5 31 12
 278+ 51F7 10 30 F0 F0          defb %00010000,%00110000,%11110000,%11110000,%11110000,%11110000,%00110000,%00010000 ; char 249 (audio off)
 278+ 51FB F0 F0 30 10
 279+ 51FF 40 60 70 78          defb %01000000,%01100000,%01110000,%01111000,%01111100,%01111110,%01111000,%01001000 ; char 250 (pointer)
 279+ 5203 7C 7E 78 48
 280+ 5207 3C 42 99 A1          defb %00111100,%01000010,%10011001,%10100001,%10100001,%10011001,%01000010,%00111100 ; char 251 (Â©)
 280+ 520B A1 99 42 3C
 281+ 520F 18 24 20 78          defb %00011000,%00100100,%00100000,%01111000,%00100000,%00100010,%01011100,%00000000 ; char 252 (Â£)
 281+ 5213 20 22 5C 00
 282+ 5217 3C 42 78 24          defb %00111100,%01000010,%01111000,%00100100,%00100100,%00011110,%01000010,%00111100 ; char 253 (Â§)
 282+ 521B 24 1E 42 3C
 283+ 521F 00 00 10 00          defb %00000000,%00000000,%00010000,%00000000,%01111100,%00000000,%00010000,%00000000 ; char 254 (Ã·)
 283+ 5223 7C 00 10 00
 284+ 5227 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 255 (cursor)
 284+ 522B FF FF FF FF
 285+ 522F
# file closed: ../include/vdp/8x8fonts-r18.asm
  83  522F                  INCLUDE "../include/vdp/logo-fonts.asm"
# file opened: ../include/vdp/logo-fonts.asm
   1+ 522F              ; ------------------------------------------------------------------------------
   2+ 522F              ; LM80C - LOGO CHARSET - R1.1
   3+ 522F              ; ------------------------------------------------------------------------------
   4+ 522F              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 522F              ; designed by Leonardo Miliani. More info at
   6+ 522F              ; www DOT leonardomiliani DOT com
   7+ 522F              ; ------------------------------------------------------------------------------
   8+ 522F              ; Code Revision:
   9+ 522F              ; R1.0 - 20200124 - First revision: logo chars
  10+ 522F              ; R1.1 - 20200229 - Adopted usual hexadecimal & binary prefixes
  11+ 522F              ; ------------------------------------------------------------------------------
  12+ 522F
  13+ 522F              LOGOFONT:   equ $
  14+ 522F 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; 0
  14+ 5233 00 00 00 00
  15+ 5237 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; 1
  15+ 523B FF FF FF FF
  16+ 523F FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; 2
  16+ 5243 00 00 00 00
  17+ 5247 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; 3
  17+ 524B 0F 0F 0F 0F
  18+ 524F 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; 4
  18+ 5253 FF FF FF FF
  19+ 5257 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; 5
  19+ 525B F0 F0 F0 F0
  20+ 525F 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; 6
  20+ 5263 0F 0F 0F 0F
  21+ 5267 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; 7
  21+ 526B F0 F0 F0 F0
  22+ 526F F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; 8
  22+ 5273 00 00 00 00
  23+ 5277 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; 9
  23+ 527B 00 00 00 00
  24+ 527F 00 00 00 FC              defb %00000000,%00000000,%00000000,%11111100,%11111111,%00000111,%00000011,%00000000 ; 10
  24+ 5283 FF 07 03 00
  25+ 5287 00 00 00 3F              defb %00000000,%00000000,%00000000,%00111111,%11111111,%11100000,%11000000,%00000000 ; 11
  25+ 528B FF E0 C0 00
  26+ 528F 18 18 1F 19              defb %00011000,%00011000,%00011111,%00011001,%00011001,%00011111,%00011000,%00011000 ; 12
  26+ 5293 19 1F 18 18
  27+ 5297 18 18 F8 98              defb %00011000,%00011000,%11111000,%10011000,%10011000,%11111000,%00011000,%00011000 ; 13
  27+ 529B 98 F8 18 18
  28+ 529F 18 18 1C 1F              defb %00011000,%00011000,%00011100,%00011111,%00001111,%00000000,%00000000,%00000000 ; 14
  28+ 52A3 0F 00 00 00
  29+ 52A7 00 00 00 0F              defb %00000000,%00000000,%00000000,%00001111,%00011111,%00011100,%00011000,%00011000 ; 15
  29+ 52AB 1F 1C 18 18
  30+ 52AF 00 00 00 F0              defb %00000000,%00000000,%00000000,%11110000,%11111000,%00111000,%00011000,%00011000 ; 16
  30+ 52B3 F8 38 18 18
  31+ 52B7 18 18 38 F8              defb %00011000,%00011000,%00111000,%11111000,%11110000,%00000000,%00000000,%00000000 ; 17
  31+ 52BB F0 00 00 00
  32+ 52BF 00 00 00 FF              defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; 18
  32+ 52C3 FF 00 00 00
  33+ 52C7 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%11111111,%11111111,%11111111,%11111111 ; 19
  33+ 52CB FF FF FF FF
  34+ 52CF F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11111111,%11111111,%11111111,%11111111 ; 20
  34+ 52D3 FF FF FF FF
  35+ 52D7 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11110000,%11110000,%11110000,%11110000 ; 21
  35+ 52DB F0 F0 F0 F0
  36+ 52DF FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00001111,%00001111,%00001111,%00001111 ; 22
  36+ 52E3 0F 0F 0F 0F
  37+ 52E7 00 30 78 78              defb %00000000,%00110000,%01111000,%01111000,%00110000,%00000000,%00000000,%00000000 ; 23
  37+ 52EB 30 00 00 00
  38+ 52EF
# file closed: ../include/vdp/logo-fonts.asm
  84  52EF
  85  52EF              ; include ROM/RAM switcher
  86  52EF                  INCLUDE "../include/switcher/switcher-r1.02.asm"
# file opened: ../include/switcher/switcher-r1.02.asm
   1+ 52EF              ; ------------------------------------------------------------------------------
   2+ 52EF              ; LM80C - ROM/RAM SWITCHER - R1.02
   3+ 52EF              ; ------------------------------------------------------------------------------
   4+ 52EF              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 52EF              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 52EF              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 52EF              ; kind of warranty: you can use them at your own risk.
   8+ 52EF              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 52EF              ; maintain the copyright notices, include this advice and the note to the
  10+ 52EF              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 52EF              ; redistribuite them.
  12+ 52EF              ; https://www.leonardomiliani.com
  13+ 52EF              ;
  14+ 52EF              ; Please support me by visiting the following links:
  15+ 52EF              ; Main project page: https://www.leonardomiliani.com
  16+ 52EF              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 52EF              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 52EF              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 52EF              ; ------------------------------------------------------------------------------
  20+ 52EF              ; Code Revision:
  21+ 52EF              ; R1.0   - 20200718 - First version
  22+ 52EF              ; R1.1   - 20200827 - PIO settings now are part of the file
  23+ 52EF              ; R1.02  - 20210319 - support for LM80C DOS and its repositioning into high-RAM
  24+ 52EF              ;-------------------------------------------------------------------------------
  25+ 52EF
  26+ 52EF              TMP_FW_LOC:     equ     $8000           ; address from where to make a temporary copy of the FW
  27+ 52EF              ;-------------------------------------------------------------------------------
  28+ 52EF              ; THIS CODE WILL BE EXECUTED FROM RAM
  29+ 52EF 3E FC        RAMRUN:         ld      A,%11111100     ; set ROM off and RAM on..
  30+ 52F1 D3 01                        out     (PIO_DB),A      ; ...by setting bit #0 to 0 (and leave VRAM bank #0)
  31+ 52F3 01 3E 53                     ld      BC,END_OF_FW    ; let's copy back FW into low RAM - bytes to copy
  32+ 52F6 21 00 80                     ld      HL,TMP_FW_LOC   ; source address
  33+ 52F9 11 00 00                     ld      DE,$0000        ; dest. address
  34+ 52FC ED B0                        ldir                    ; copy!
  35+ 52FE AF                           xor     A
  36+ 52FF D3 01                        out     (PIO_DB),A      ; all LEDs off - finished copying
  37+ 5301 C3 AE 02                     jp      INIT_HW         ; return control to old init (now into RAM)
  38+ 5304
  39+ 5304              ;-------------------------------------------------------------------------------
  40+ 5304              ; copy the whole contents of ROM into RAM then disable the first memory
  41+ 5304 3A 9B 53     ROM2RAM:        ld      A,(basicStarted); check if BASIC is already started
  42+ 5307 FE 59                        cp      'Y'             ; to see if this is a power-up
  43+ 5309 20 0F                        jr      NZ,CNTCP2RAM    ; no, continue copy to RAM
  44+ 530B                              ; WARNING: Do **NOT** change the following "out()" sequence, ABSOLUTELY!
  45+ 530B 3E CF                        ld      A,%11001111     ; set mode 3 ("control mode")
  46+ 530D D3 03                        out     (PIO_CB),A      ; for PIO port B
  47+ 530F AF                           xor     A               ; set LEDs off, RAM on, VRAM on bank #0
  48+ 5310 D3 01                        out     (PIO_DB),A      ; send settings to PIO register
  49+ 5312 D3 03                        out     (PIO_CB),A      ; set pins following register's status
  50+ 5314 21 CD 54                     ld      HL,TEMPSTACK    ; temporary stack
  51+ 5317 C3 B1 02                     jp      INIT_HW2        ; jump to re-init HW
  52+ 531A
  53+ 531A                              ; WARNING: Do **NOT** change the following "out()" sequence, ABSOLUTELY!
  54+ 531A 3E CF        CNTCP2RAM:      ld      A,%11001111     ; set mode 3 (mode control)
  55+ 531C D3 03                        out     (PIO_CB),A      ; for PIO port B
  56+ 531E 3E FD                        ld      A,%11111101     ; set pin #0 as HIGH to enable ROM
  57+ 5320 D3 01                        out     (PIO_DB),A      ; store the value into the internal register
  58+ 5322 AF                           xor     A               ; set pins to OUTPUT
  59+ 5323 D3 03                        out     (PIO_CB),A      ; for port B, activating the RAM
  60+ 5325                              ; copy DOS
  61+ 5325 01 80 0E                     ld      BC,$FFFF-DOSSTART+1 ; bytes to copy
  62+ 5328 21 3E 53                     ld      HL,END_OF_FW    ; load DOS from its original location and...
  63+ 532B 11 80 F1                     ld      DE,DOSSTART     ; ...store it into its portion of memory
  64+ 532E ED B0                        ldir                    ; copy!
  65+ 5330                              ; copy BASIC
  66+ 5330 01 3E 53                     ld      BC,END_OF_FW    ; copy FW from ROM to high RAM
  67+ 5333 21 00 00                     ld      HL,$0000        ; source address
  68+ 5336 11 00 80                     ld      DE,TMP_FW_LOC   ; dest. address
  69+ 5339 ED B0                        ldir                    ; copy!
  70+ 533B C3 EF D2                     jp      RAMRUN+TMP_FW_LOC; jump to execute code into RAM
  71+ 533E
  72+ 533E              ;-------------------------------------------------------------------------------
  73+ 533E              END_OF_FW:      equ     $   ; this is the last cell of the firmware
# file closed: ../include/switcher/switcher-r1.02.asm
  87  533E
  88  533E              ; include workspace equates
  89  533E                  INCLUDE "../include/workspace/workspace-r1.02.asm"
# file opened: ../include/workspace/workspace-r1.02.asm
   1+ 533E              ; ------------------------------------------------------------------------------
   2+ 533E              ; LM80C 64K - WORKSPACE EQUATES - R1.02
   3+ 533E              ; ------------------------------------------------------------------------------
   4+ 533E              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 533E              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 533E              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 533E              ; kind of warranty: you can use them at your own risk.
   8+ 533E              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 533E              ; maintain the copyright notices, include this advice and the note to the
  10+ 533E              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 533E              ; redistribuite them.
  12+ 533E              ; https://www.leonardomiliani.com
  13+ 533E              ;
  14+ 533E              ; Please support me by visiting the following links:
  15+ 533E              ; Main project page: https://www.leonardomiliani.com
  16+ 533E              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 533E              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 533E              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 533E              ; ------------------------------------------------------------------------------
  20+ 533E
  21+ 533E              ; set starting of RAM based on computer model
  22+ 533E              SERBUF_START    equ     END_OF_FW       ; RAM starts here
  23+ 533E
  24+ 533E              ;-------------------------------------------------------------------------------
  25+ 533E              serInPtr        equ     SERBUF_START + SER_BUFSIZE
  26+ 533E              serRdPtr        equ     serInPtr+2
  27+ 533E              serBufUsed      equ     serRdPtr+2
  28+ 533E              basicStarted    equ     serBufUsed+1
  29+ 533E              bufWrap         equ     (SERBUF_START + SER_BUFSIZE) & $FF
  30+ 533E              TEMPSTACK       equ     CURPOS - 3      ; top of BASIC line input buffer so is "free ram" when BASIC resets
  31+ 533E
  32+ 533E              ; BASIC WORK SPACE LOCATIONS
  33+ 533E              ; THE INTERPRETER ALLOCATES THE FOLLOWING RAM CELLS
  34+ 533E              ; TO STORE IMPORTANT VALUES USED FOR SOME SPECIFIC FUNCTIONS:
  35+ 533E              ; THEY CAN BE VECTOR (ADDRESSES) FUNCTIONS, SYSTEM DATAS (I.E. VARIABLES)
  36+ 533E              ; AND SO ON. THE FIRST CELLS ARE FILLED WITH VALUES STORED INTO ROM AT $(INITAB) ADDRESS
  37+ 533E              WRKSPC          equ     basicStarted+$01; (3) BASIC Work space
  38+ 533E              NMIUSR          equ     WRKSPC+$03      ; (3) NMI exit point routine
  39+ 533E              USR             equ     NMIUSR+$03      ; (3) "USR (x)" jump  <-- in (USR+$01)/(USR+$02) the user can store the address of a specific machine language routine
  40+ 533E              OUTSUB          equ     USR+$03         ; (1) "out p,n"
  41+ 533E              OTPORT          equ     OUTSUB+$01      ; (2) Port (p)
  42+ 533E              DIVSUP          equ     OTPORT+$02      ; (1) Division support routine
  43+ 533E              DIV1            equ     DIVSUP+$01      ; (4) <- Values
  44+ 533E              DIV2            equ     DIV1+$04        ; (4) <-   to
  45+ 533E              DIV3            equ     DIV2+$04        ; (3) <-   be
  46+ 533E              DIV4            equ     DIV3+$03        ; (2) <-inserted
  47+ 533E              SEED            equ     DIV4+$02        ; (35) Random number seed  <-- starting address of a seed table
  48+ 533E              LSTRND          equ     SEED+$23        ; (4) Last random number
  49+ 533E              INPSUB          equ     LSTRND+$04      ; (1) INP A,(x) Routine
  50+ 533E              INPORT          equ     INPSUB+$01      ; (2) PORT (x)
  51+ 533E              LWIDTH          equ     INPORT+$02      ; (1) Terminal width
  52+ 533E              COMMAN          equ     LWIDTH+$01      ; (1) Width for commas
  53+ 533E              NULFLG          equ     COMMAN+$01      ; (1) Null after input byte flag
  54+ 533E              CTLOFG          equ     NULFLG+$01      ; (1) Control "O" flag
  55+ 533E              CHKSUM          equ     CTLOFG+$01      ; (2) Array load/save check sum
  56+ 533E              NMIFLG          equ     CHKSUM+$02      ; (1) Flag for NMI break routine
  57+ 533E              BRKFLG          equ     NMIFLG+$01      ; (1) Break flag
  58+ 533E              RINPUT          equ     BRKFLG+$01      ; (3) Input reflection
  59+ 533E              STRSPC          equ     RINPUT+$03      ; (2) Pointer to bottom (start) of string space - default is 100 bytes below the top of memory
  60+ 533E              LINEAT          equ     STRSPC+$02      ; (2) Current line number. -1 means "direct mode", while -2 means cold start.
  61+ 533E              HLPLN           equ     LINEAT+$02      ; (2) Current line with errors
  62+ 533E              KEYDEL          equ     HLPLN+$02       ; (1) delay before key auto-repeat starts
  63+ 533E              AUTOKE          equ     KEYDEL+$01      ; (1) delay for key auto-repeat
  64+ 533E              FNKEYS          equ     AUTOKE+$01      ; (128) default text of FN keys
  65+ 533E              BASTXT          equ     FNKEYS+$80      ; (3) Pointer to start of BASIC program in memory
  66+ 533E              ; - - - - - - - - - - - - - - - - - - -   the above are locations pre-filled by the firmware at startup
  67+ 533E              BUFFER          equ     BASTXT+$03      ; (5) Input buffer
  68+ 533E              STACK           equ     BUFFER+$05      ; (85) Initial stack
  69+ 533E              CURPOS          equ     STACK+$55       ; (1) Character position on line
  70+ 533E              LCRFLG          equ     CURPOS+$01      ; (1) Locate/Create flag for DIM statement
  71+ 533E              TYPE            equ     LCRFLG+$01      ; (1) Data type flag: 0=numeric, non-zero=string
  72+ 533E              DATFLG          equ     TYPE+$01        ; (1) Literal statement flag
  73+ 533E              LSTRAM          equ     DATFLG+$01      ; (2) Last available RAM location for BASIC
  74+ 533E              DOSER           equ     LSTRAM+$02      ; (1) Error from DOS
  75+ 533E              TMPDBF          equ     DOSER+$01       ; (36) Secondary buffer for DOS
  76+ 533E              TMSTPT          equ     TMPDBF+$24      ; (2) Temporary string pointer
  77+ 533E              TMSTPL          equ     TMSTPT+$02      ; (12) Temporary string pool
  78+ 533E              TMPSTR          equ     TMSTPL+$0C      ; (4) Temporary string
  79+ 533E              STRBOT          equ     TMPSTR+$04      ; (2) Bottom of string space
  80+ 533E              CUROPR          equ     STRBOT+$02      ; (2) Current operator in EVAL
  81+ 533E              LOOPST          equ     CUROPR+$02      ; (2) First statement of loop
  82+ 533E              DATLIN          equ     LOOPST+$02      ; (2) Line of current DATA item
  83+ 533E              FORFLG          equ     DATLIN+$02      ; (1) "FOR" loop flag
  84+ 533E              LSTBIN          equ     FORFLG+$01      ; (1) Last byte entered
  85+ 533E              READFG          equ     LSTBIN+$01      ; (1) Read/Input flag
  86+ 533E              BRKLIN          equ     READFG+$01      ; (2) Line of break
  87+ 533E              NXTOPR          equ     BRKLIN+$02      ; (2) Next operator in EVAL
  88+ 533E              ERRLIN          equ     NXTOPR+$02      ; (2) Line of error
  89+ 533E              CONTAD          equ     ERRLIN+$02      ; (2) Where to CONTinue
  90+ 533E              TMRCNT          equ     CONTAD+$02      ; (4) TMR counter for 1/100 seconds
  91+ 533E              CTC0IV          equ     TMRCNT+$04      ; (3) CTC0 interrupt vector
  92+ 533E              CTC1IV          equ     CTC0IV+$03      ; (3) CTC1 interrupt vector
  93+ 533E              CTC2IV          equ     CTC1IV+$03      ; (3) CTC2 interrupt vector
  94+ 533E              CTC3IV          equ     CTC2IV+$03      ; (3) CTC3 interrupt vector
  95+ 533E              ; - - - - - - - - - - - - - - - - - - -   VIDEO REGISTERS - FROM HERE...
  96+ 533E              SCR_SIZE_W      equ     CTC3IV+$03      ; (1) screen width (it can be either 40 chars or 32 chars/bytes)
  97+ 533E              SCR_SIZE_H      equ     SCR_SIZE_W+$01  ; (1) screen height (it can be 24/48/192: 24 for text, 48 for MC, 192 for graphics)
  98+ 533E              SCR_MODE        equ     SCR_SIZE_H+$01  ; (1) screen mode (0=text, 1=G1, 2=G2, 3=MC, 4=ExG2)
  99+ 533E              SCR_NAM_TB      equ     SCR_MODE+$01    ; (2) video name table address
 100+ 533E              SCR_CURS_X      equ     SCR_NAM_TB+$02  ; (1) cursor X
 101+ 533E              SCR_CURS_Y      equ     SCR_CURS_X+$01  ; (1) cursor Y
 102+ 533E              SCR_CUR_NX      equ     SCR_CURS_Y+$01  ; (1) new cursor X position
 103+ 533E              SCR_CUR_NY      equ     SCR_CUR_NX+$01  ; (1) new cursor Y position
 104+ 533E              SCR_ORG_CHR     equ     SCR_CUR_NY+$01  ; (1) original char positioned under the cursor
 105+ 533E              CRSR_STATE      equ     SCR_ORG_CHR+$01 ; (1) state of cursor (1=on, 0=off)
 106+ 533E              LSTCSRSTA       equ     CRSR_STATE+$01  ; (1) last cursor state
 107+ 533E              PRNTVIDEO       equ     LSTCSRSTA+$01   ; (1) print on video buffer (1=on / 0=off) set to off on graphic only modes
 108+ 533E              CHR4VID         equ     PRNTVIDEO+$01   ; (1) char for video buffer
 109+ 533E              FRGNDCLR        equ     CHR4VID+$01     ; (1) foreground color as set by SCREEN or COLOR commands
 110+ 533E              BKGNDCLR        equ     FRGNDCLR+$01    ; (1) background color as set by SCREEN or COLOR commands
 111+ 533E              TMPBFR1         equ     BKGNDCLR+$01    ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 112+ 533E              TMPBFR2         equ     TMPBFR1+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 113+ 533E              TMPBFR3         equ     TMPBFR2+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 114+ 533E              TMPBFR4         equ     TMPBFR3+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 115+ 533E              VIDEOBUFF       equ     TMPBFR4+$02     ; (40) buffer used for video scrolling and other purposes
 116+ 533E              VIDTMP1         equ     VIDEOBUFF+$28   ; (2) temporary video word
 117+ 533E              VIDTMP2         equ     VIDTMP1+$02     ; (2) temporary video word
 118+ 533E              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO VPD OUT OF THIS RANGE,
 119+ 533E                                                      ; OTHERWISE YOU WILL HAVE TO CHECK THE POINTER IN "CLR_RAM_REG" FUNCTION
 120+ 533E              ; - - - - - - - - - - - - - - - - - - -   SOUND & KEYBOARD REGISTERS - FROM HERE...
 121+ 533E              CHASNDDTN       equ     VIDTMP2+$02     ; (2) sound Ch.A duration (in 1/100s)
 122+ 533E              CHBSNDDTN       equ     CHASNDDTN+$02   ; (2) sound Ch.B duration (in 1/100s)
 123+ 533E              CHCSNDDTN       equ     CHBSNDDTN+$02   ; (2) sound Ch.C duration (in 1/100s)
 124+ 533E              KBDNPT          equ     CHCSNDDTN+$02   ; (1) temp cell used to flag if input comes from keyboard
 125+ 533E              KBTMP           equ     KBDNPT+$01      ; (1) temp cell used by keyboard scanner
 126+ 533E              TMPKEYBFR       equ     KBTMP+$01       ; (1) temp buffer for last key pressed
 127+ 533E              LASTKEYPRSD     equ     TMPKEYBFR+$01   ; (1) last key code pressed
 128+ 533E              STATUSKEY       equ     LASTKEYPRSD+$01 ; (1) status key, used for auto-repeat
 129+ 533E              KEYTMR          equ     STATUSKEY+$01   ; (2) timer used for auto-repeat key
 130+ 533E              CONTROLKEYS     equ     KEYTMR+$02      ; (1) flags for control keys (bit#0=SHIFT; bit#1=CTRL; bit#2=C=)
 131+ 533E              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO PSG OUT OF THIS RANGE,
 132+ 533E                                                      ; OTHERWISE YOU WILL HAVE TO CHANGE THE POINTER IN "initPSG" FUNCTION
 133+ 533E              SERIALS_EN      equ     CONTROLKEYS+$01 ; (1) serial ports status: bit 0 for Port1 (A), bit 1 for Port2 (B): 0=OFF, 1=ON
 134+ 533E              SERABITS        equ     SERIALS_EN+$01  ; (1) serial port A data bits
 135+ 533E              SERBBITS        equ     SERABITS+$01    ; (1) serial port B data bits
 136+ 533E              DOS_EN          equ     SERBBITS+$01    ; (1) DOS enable/disable (1/0)
 137+ 533E              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 138+ 533E                                                      ; from here there are the RAM locations that
 139+ 533E                                                      ; are saved during SAVE
 140+ 533E              PROGND          equ     DOS_EN+$01      ; (2) End of program
 141+ 533E              VAREND          equ     PROGND+$02      ; (2) End of variables
 142+ 533E              ARREND          equ     VAREND+$02      ; (2) End of arrays
 143+ 533E              NXTDAT          equ     ARREND+$02      ; (2) Next data item
 144+ 533E              FNRGNM          equ     NXTDAT+$02      ; (2) Name of FN argument
 145+ 533E              FNARG           equ     FNRGNM+$02      ; (4) FN argument value
 146+ 533E              FPREG           equ     FNARG+$04       ; (3) Floating point register
 147+ 533E              FPEXP           equ     FPREG+$03       ; (1) Floating point exponent
 148+ 533E              SGNRES          equ     FPEXP+$01       ; (1) Sign of result
 149+ 533E              PBUFF           equ     SGNRES+$01      ; (13) Number print buffer
 150+ 533E              MULVAL          equ     PBUFF+$0D       ; (3) Multiplier
 151+ 533E              PROGST          equ     MULVAL+$03      ; (100) Start of program text area
 152+ 533E              STLOOK          equ     PROGST+$64      ; Start of memory test
 153+ 533E
# file closed: ../include/workspace/workspace-r1.02.asm
  90  533E
  91  533E              ; include the latest versions of the CF & DOS modules
  92  533E              ; do NOT move these files from this position and
  93  533E              ; do NOT alter their order!
  94  533E                  INCLUDE "../include/dos/dos-1.04.asm"
# file opened: ../include/dos/dos-1.04.asm
   1+ 533E              ; ------------------------------------------------------------------------------
   2+ 533E              ; LM80C 64K - DOS ROUTINES - R1.04
   3+ 533E              ; ------------------------------------------------------------------------------
   4+ 533E              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 533E              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 533E              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 533E              ; kind of warranty: you can use them at your own risk.
   8+ 533E              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 533E              ; maintain the copyright notices, include this advice and the note to the
  10+ 533E              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 533E              ; redistribuite them.
  12+ 533E              ; https://www.leonardomiliani.com
  13+ 533E              ;
  14+ 533E              ; Please support me by visiting the following links:
  15+ 533E              ; Main project page: https://www.leonardomiliani.com
  16+ 533E              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 533E              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 533E              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 533E              ; ------------------------------------------------------------------------------
  20+ 533E              ;
  21+ 533E              ; ------------------------------------------------------------------------------
  22+ 533E              ; Code Revision:
  23+ 533E              ; R1.0  - 20210306 - first release
  24+ 533E              ; R1.01 - 20210309 - code cleaning & optimization - new behaviour for ERASE (full erase everything)
  25+ 533E              ; R1.02 - 20210310 - code optimization - new UNDELETE feature for DISK statement
  26+ 533E              ; R1.03 - 2021xxxx - code size enhancements
  27+ 533E              ; R1.04 - 20210319 - code re-organization and new positioning into RAM
  28+ 533E              ;
  29+ 533E              ;------------------------------------------------------------------------------
  30+ 533E
  31+ 533E
  32+ 533E                          org     $F180
  33+ F180
  34+ F180              DOSSTART:   equ     $
  35+ F180 4C 4D 38 30  DSKHDR      defb    "LM80C DOS",$00,"1.04",$00     ; disk header
  35+ F184 43 20 44 4F
  35+ F188 53 00 31 2E
  35+ F18C 30 34 00
  36+ F18F 00 01        DSKDIRADR:  defb    $00,$01                         ; 1st sector of directory ($0001)
  37+ F191
  38+ F191              DIR_STRT:   equ     TMPDBF          ; (2) start of directory
  39+ F191              DAT_STRT:   equ     DIR_STRT+$02    ; (2) start of DATA area
  40+ F191              DIR_SCT:    equ     DAT_STRT+$02    ; (2) sector of first free entry in the directory
  41+ F191              NTR_NBR:    equ     DIR_SCT+$02     ; (2) number of free entry
  42+ F191              BYT_SIZ:    equ     NTR_NBR+$02     ; (2) file size in bytes
  43+ F191              SCT_SIZ:    equ     BYT_SIZ+$02     ; (1) file size in sectors
  44+ F191              MSW_SCT:    equ     SCT_SIZ+$01     ; (2) MSW sector of file
  45+ F191              LSW_SCT:    equ     MSW_SCT+$02     ; (2) LSW sector of file
  46+ F191              RAM_PTR:    equ     LSW_SCT+$02     ; (2) pointer to RAM
  47+ F191              TPBF1:      equ     RAM_PTR+$02     ; (2) temp. word
  48+ F191              TPBF2:      equ     TPBF1+$02       ; (2) temp. word
  49+ F191              TPBF3:      equ     TPBF2+$02       ; (2) temp. word
  50+ F191              TPBF4:      equ     TPBF3+$02       ; (2) temp. word
  51+ F191              SRTMEM:     equ     TPBF4+$02       ; (2) temp. word
  52+ F191              ENDMEM:     equ     SRTMEM+$02      ; (2) temp. word
  53+ F191
  54+ F191
  55+ F191
  56+ F191              ; check if DOS is enabled
  57+ F191 3A 85 55     CHKDOS: ld      A,(DOS_EN)      ; load DOS state
  58+ F194 A7                   and     A               ; check if 0 (NOT enabled)
  59+ F195 C0                   ret     NZ              ; return if enabled
  60+ F196 1E 38                ld      E,D0            ; DOS not enabled error
  61+ F198 C3 EC 17             jp      ERROR           ; raise error
  62+ F19B
  63+ F19B
  64+ F19B              ; LOAD "filename"[,1]  <- load a BASIC program from disk
  65+ F19B              ; LOAD x,y,w,z         <- load a sector from disc, LBA address equals to ((((z*256)+w)*256)+y)*256)+x
  66+ F19B CD 91 F1     LOAD:   call    CHKDOS          ; check if DOS is enabled
  67+ F19E CD F1 F1             call    LDSVPT          ; check if in direct mode and what's following
  68+ F1A1 CA BF F1             jp      Z,LOADST        ; number - load a single sector
  69+ F1A4 CD 44 3E             call    DIRMOD          ; a file can be loaded ONLY in direct mode
  70+ F1A7 C2 E7 17             jp      NZ,IMERR        ; raise error if in indirect mode
  71+ F1AA CD EA F4             call    CHKFN1          ; string - evaluate file name
  72+ F1AD CD 2A F3             call    CHK1AR          ; check for ",1" argument
  73+ F1B0 22 40 55             ld      (TMPBFR1),HL    ; store HL
  74+ F1B3 21 E0 F1             ld      HL,TXTLDG       ; loading message
  75+ F1B6 CD B4 26             call    PRS             ; print
  76+ F1B9 CD 9F F9             call    LODFILE         ; load file into memory
  77+ F1BC C3 D4 F1             jp      LDEND           ; retrieve registers and leave
  78+ F1BF 2A 40 55     LOADST: ld      HL,(TMPBFR1)    ; retrieve HL
  79+ F1C2 CD 06 F2             call    GET4AR          ; get 4 arguments
  80+ F1C5 22 40 55             ld      (TMPBFR1),HL    ; store HL
  81+ F1C8 CD 3E FD             call    CF_SETSTR       ; set sector
  82+ F1CB CD 80 FD             call    CF_RD_SEC       ; read sector
  83+ F1CE 38 0B                jr      C,LDERR
  84+ F1D0 CD 74 FD             call    CF_STANDBY      ; put CF in standby mode
  85+ F1D3 AF                   xor     A               ; clear Carry
  86+ F1D4 2A 40 55     LDEND:  ld      HL,(TMPBFR1)    ; retrieve HL
  87+ F1D7 DA 23 F3             jp      C,DOS_ERR       ; jump if DOS error
  88+ F1DA C9                   ret                     ; return to caller
  89+ F1DB 1E 40        LDERR:  ld      E,D4            ; load error
  90+ F1DD C3 EC 17             jp      ERROR
  91+ F1E0 4C 6F 61 64  TXTLDG: defb    "Loading file... ",0
  91+ F1E4 69 6E 67 20
  91+ F1E8 66 69 6C 65
  91+ F1EC 2E 2E 2E 20
  91+ F1F0 00
  92+ F1F1
  93+ F1F1
  94+ F1F1              ; common code for LOAD/SAVE to check the type of operation required
  95+ F1F1              ; (load/save a file or a single sector)
  96+ F1F1              ; returns Z if argument is a number, NZ if it's a string
  97+ F1F1 CD 91 F1     LDSVPT: call    CHKDOS          ; check if DOS is enabled
  98+ F1F4 2B                   dec     HL              ; dec 'cos GETCHR INCs
  99+ F1F5 CD 1B 1D             call    GETCHR          ; check if something follows
 100+ F1F8 CA D2 17             jp      Z,SNERR         ; if anything else, raise a syntax error
 101+ F1FB 22 40 55             ld      (TMPBFR1),HL    ; save current code string pointer
 102+ F1FE CD BE 21             call    EVAL            ; Evaluate expression
 103+ F201 3A D2 54             ld      A,(TYPE)        ; Get variable type
 104+ F204 B7                   or      A               ; Is it a string variable?
 105+ F205 C9                   ret                     ; return to caller
 106+ F206
 107+ F206
 108+ F206              ; shared code between LOAD and SAVE
 109+ F206              ; get 4 arguments after the command LOAD or SAVE
 110+ F206              ; and load them into appropriate registers
 111+ F206 2A 40 55     GET4AR: ld      HL,(TMPBFR1)    ; retrieve string code pointer
 112+ F209 CD 32 2A             call    GETINT          ; get 1st pointer
 113+ F20C 32 D7 54             ld      (TMPDBF),A      ; store it into a temp buffer
 114+ F20F CD D2 1A             call    CHKSYN          ; Make sure ',' follows
 115+ F212 2C                   defb    ','
 116+ F213 CD 32 2A             call    GETINT          ; get 2nd pointer
 117+ F216 32 D8 54             ld      (TMPDBF+1),A    ; store it into a temp buffer
 118+ F219 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
 119+ F21C 2C                   defb    ','
 120+ F21D CD 32 2A             call    GETINT          ; get 3rd pointer
 121+ F220 32 D9 54             ld      (TMPDBF+2),A    ; store it into a temp buffer
 122+ F223 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
 123+ F226 2C                   defb    ','
 124+ F227 CD 32 2A             call    GETINT          ; get 4th pointer
 125+ F22A 57                   ld      D,A             ; store it
 126+ F22B 3A D7 54             ld      A,(TMPDBF)      ; retrieve 1st pointer
 127+ F22E 4F                   ld      C,A
 128+ F22F 3A D8 54             ld      A,(TMPDBF+1)    ; retrieve 2nd pointer
 129+ F232 47                   ld      B,A
 130+ F233 3A D9 54             ld      A,(TMPDBF+2)    ; retrieve 3rd pointer
 131+ F236 5F                   ld      E,A
 132+ F237 CD FC FC             call    CF_INIT         ; init CF card
 133+ F23A DA EA 17             jp      C,NRERR         ; error if device not available/ready
 134+ F23D C9                   ret                     ; return to caller
 135+ F23E
 136+ F23E
 137+ F23E              ; save a file onto the disk
 138+ F23E              ; syntax: save "filename" to save a BASIC program
 139+ F23E              ; save x,y,z to save IO buffer into x-y-z sector
 140+ F23E              ; save "filename",start,end to save a portion of memory
 141+ F23E CD 91 F1     SAVE:   call    CHKDOS          ; check if DOS is enabled
 142+ F241 2B                   dec     HL              ; dec 'cos GETCHR INCs
 143+ F242 CD 1B 1D             call    GETCHR          ; check if something follows
 144+ F245 CA D2 17             jp      Z,SNERR         ; if nothing else, raise a syntax error
 145+ F248 22 40 55             ld      (TMPBFR1),HL    ; save current code string pointer
 146+ F24B CD BE 21             call    EVAL            ; Evaluate expression
 147+ F24E 3A D2 54             ld      A,(TYPE)        ; Get variable type
 148+ F251 B7                   or      A               ; Is it a string variable?
 149+ F252 CA B0 F2             jp      Z,SAVESCT       ; no - save a single sector
 150+ F255 CD EA F4             call    CHKFN1          ; yes, load string name
 151+ F258 ED 53 46 55          ld      (TMPBFR4),DE    ; store lenght into another buffer
 152+ F25C ED 43 F0 54          ld      (TPBF4+2),BC    ; store address into another buffer
 153+ F260 3E 80                ld      A,$80           ; set BAS as file type
 154+ F262 32 EE 54             ld      (TPBF4),A
 155+ F265 2B                   dec     HL              ; dec 'cos GETCHR INCs
 156+ F266 CD 1B 1D             call    GETCHR          ; check if something follows
 157+ F269 28 30                jr      Z,SAVE1         ; no, jump over
 158+ F26B CD D2 1A             call    CHKSYN          ; yes - Make sure ',' follows
 159+ F26E 2C                   defb    ','
 160+ F26F 22 D7 54             ld      (TMPDBF),HL     ; store code string pointer
 161+ F272 CD BE 21             call    EVAL            ; check expression
 162+ F275 2A D7 54             ld      HL,(TMPDBF)     ; point back to the beginning of epression
 163+ F278 3A D2 54             ld      A,(TYPE)        ; check result type
 164+ F27B B7                   or      A               ; is it another string?
 165+ F27C 20 4B                jr      NZ,RENFIL       ; yes, jump to rename file
 166+ F27E CD AC 21             call    GETNUM          ; no, this is the memory address for a BIN file
 167+ F281 CD D1 1D             call    DEINT           ; Get integer -32768 to 32767
 168+ F284 ED 53 F0 54          ld      (SRTMEM),DE     ; Store DE into a temp. buffer
 169+ F288 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
 170+ F28B 2C                   defb    ','
 171+ F28C CD AC 21             call    GETNUM          ; Get memory address
 172+ F28F CD D1 1D             call    DEINT           ; Get integer -32768 to 32767
 173+ F292 ED 53 F2 54          ld      (ENDMEM),DE     ; Store DE into a temp. buffer
 174+ F296 3E 81                ld      A,$81           ; set BIN for file type
 175+ F298 32 EE 54             ld      (TPBF4),A
 176+ F29B CD 44 3E     SAVE1:  call    DIRMOD          ; can be executed ONLY in direct mode
 177+ F29E C2 E7 17             jp      NZ,IMERR        ; raise error if in indirect mode
 178+ F2A1 22 40 55             ld      (TMPBFR1),HL    ; store code string pointer
 179+ F2A4 21 FC F2             ld      HL,TXTSVG       ; loading message
 180+ F2A7 CD B4 26             call    PRS             ; print
 181+ F2AA CD DF F7             call    SAVFILE         ; load file into memory
 182+ F2AD C3 C2 F2             jp      SVEND           ; retrieve registers and leave
 183+ F2B0                      ;save a single sector
 184+ F2B0 2A D7 54     SAVESCT:ld      HL,(TMPDBF)     ; retrieve string code pointer
 185+ F2B3 CD 06 F2             call    GET4AR          ; get 4 arguments
 186+ F2B6 22 40 55             ld      (TMPBFR1),HL    ; store code string pointer
 187+ F2B9 CD A7 FD             call    CF_WR_SEC       ; read sector
 188+ F2BC 38 39                jr      C,SVERR
 189+ F2BE CD 74 FD             call    CF_STANDBY      ; put CF in standby mode
 190+ F2C1 AF                   xor     A               ; clear Carry
 191+ F2C2 2A 40 55     SVEND:  ld      HL,(TMPBFR1)    ; retrieve code string pointer
 192+ F2C5 DA 23 F3             jp      C,DOS_ERR       ; jump if DOS error
 193+ F2C8 C9                   ret                     ; return to caller
 194+ F2C9 CD F7 27     RENFIL: call    GSTRCU          ; check that a string follows
 195+ F2CC CD 08 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
 196+ F2CF ED 53 DF 54          ld      (BYT_SIZ),DE    ; store values into
 197+ F2D3 ED 43 E6 54          ld      (RAM_PTR),BC    ; temp buffers
 198+ F2D7 E5                   push    HL              ; store code string pointer
 199+ F2D8 21 E6 F2             ld      HL,TXTRNM       ; point to "renaming file"
 200+ F2DB CD B4 26             call    PRS             ; print string
 201+ F2DE CD 0B F9             call    CHNGNAM         ; rename file
 202+ F2E1 E1                   pop     HL              ; retrieve code string pointer
 203+ F2E2 DA 23 F3             jp      C,DOS_ERR       ; any error?
 204+ F2E5 C9                   ret                     ; return to caller
 205+ F2E6 52 65 6E 61  TXTRNM: defb    "Renaming file...",0
 205+ F2EA 6D 69 6E 67
 205+ F2EE 20 66 69 6C
 205+ F2F2 65 2E 2E 2E
 205+ F2F6 00
 206+ F2F7 1E 3E        SVERR:  ld      E,D3            ; save error
 207+ F2F9 C3 EC 17             jp      ERROR
 208+ F2FC 53 61 76 69  TXTSVG: defb    "Saving file... ",0
 208+ F300 6E 67 20 66
 208+ F304 69 6C 65 2E
 208+ F308 2E 2E 20 00
 209+ F30C
 210+ F30C
 211+ F30C              ; FILES
 212+ F30C              ; list files on disk
 213+ F30C CD 91 F1     FILES:  call    CHKDOS          ; check if DOS is enabled
 214+ F30F CD DB FC             call    CLRIOBF         ; clear I/O buffer
 215+ F312 CD FC FC             call    CF_INIT         ; init CF card
 216+ F315 DA 23 F3             jp      C,DOS_ERR       ; error if device not available/ready
 217+ F318 E5                   push    HL              ; store code string pointer
 218+ F319 16 01                ld      D,$01           ; print disk details and file list
 219+ F31B CD B5 F6             call    LST_FILES       ; list files
 220+ F31E E1                   pop     HL              ; retrieve code string pointer
 221+ F31F DA 23 F3             jp      C,DOS_ERR       ; any error?
 222+ F322 C9                   ret                     ; return to caller
 223+ F323
 224+ F323
 225+ F323              ; raise a DOS error
 226+ F323 3A D6 54     DOS_ERR:ld      A,(DOSER)       ; load error code
 227+ F326 5F                   ld      E,A             ; copy into E
 228+ F327 C3 EC 17             jp      ERROR           ; goto error routine
 229+ F32A
 230+ F32A
 231+ F32A              ; check for ",1" argument
 232+ F32A              ; check if 1 is passed as argument after LOAD and ERASE
 233+ F32A AF           CHK1AR: xor     A               ; reset A
 234+ F32B 32 EE 54             ld      (TPBF4),A       ; default setting
 235+ F32E                                              ; (load=store file in RAM using current BASIC pointers
 236+ F32E                                              ; (erase=quick delete)
 237+ F32E 2B                   dec     HL              ; dec 'cause GETCHR increments
 238+ F32F CD 1B 1D             call    GETCHR          ; check if something follows
 239+ F332 C8                   ret     Z               ; if nothing follows, return
 240+ F333 CD D2 1A             call    CHKSYN          ; Make sure ',' follows
 241+ F336 2C                   defb    ','
 242+ F337 CD 32 2A             call    GETINT          ; get a value
 243+ F33A 3D                   dec     A               ; decrement it
 244+ F33B C2 D2 17             jp      NZ,SNERR        ; not '1' - raise an error
 245+ F33E 3C                   inc     A               ; A=1
 246+ F33F 32 EE 54             ld      (TPBF4),A       ; load=store file in RAM using address in file
 247+ F342                                              ; erase=full delete
 248+ F342 C9                   ret                     ; return to caller
 249+ F343
 250+ F343
 251+ F343              ; ERASE "filename"
 252+ F343              ; erase a file from disk
 253+ F343 CD 91 F1     ERASE:  call    CHKDOS          ; check if DOS is enabled
 254+ F346 CD E0 F4             call    CHKFLNM         ; check for a disk name
 255+ F349 CD 2A F3             call    CHK1AR          ; check for ",1" argument
 256+ F34C E5                   push    HL              ; store code string pointer
 257+ F34D 21 70 F3             ld      HL,ERSTX        ; Point to message
 258+ F350 CD B4 26             call    PRS             ; print message for init confirmation
 259+ F353 E1                   pop     HL              ; retrieve HL
 260+ F354 CD BB F4             call    CNFREQ          ; ask for confirmation
 261+ F357 38 33                jr      C,ABRTDS        ; if Carry set then abort
 262+ F359 CD FC FC             call    CF_INIT         ; init CF card
 263+ F35C DA 23 F3             jp      C,DOS_ERR       ; error if device not available/ready
 264+ F35F E5                   push    HL              ; store code string pointer
 265+ F360 CD 49 FA             call    FIL_ERASE       ; deleted file
 266+ F363 E1                   pop     HL              ; retrieve code string pointer
 267+ F364 DA 23 F3             jp      C,DOS_ERR       ; leave if error
 268+ F367 E5                   push    HL              ; store HL
 269+ F368 21 7E F3             ld      HL,ERASED       ; point to message of file deleted
 270+ F36B CD B4 26             call    PRS             ; print it
 271+ F36E E1                   pop     HL              ; retrieve HL
 272+ F36F C9                   ret                     ; return to caller
 273+ F370 44 65 6C 65  ERSTX:  defb    "Delete file? ",0
 273+ F374 74 65 20 66
 273+ F378 69 6C 65 3F
 273+ F37C 20 00
 274+ F37E 46 69 6C 65  ERASED: defb    "File deleted",CR,0
 274+ F382 20 64 65 6C
 274+ F386 65 74 65 64
 274+ F38A 0D 00
 275+ F38C
 276+ F38C
 277+ F38C              ; disk operation aborted
 278+ F38C 3E 01        ABRTDS: ld      A,$01           ; re-enable...
 279+ F38E 32 3C 55             ld      (PRNTVIDEO),A   ; ...print-on-video
 280+ F391 E5                   push    HL              ; store code string pointer
 281+ F392 21 9A F3             ld      HL,ABRTXT       ; Point to message
 282+ F395 CD B4 26             call    PRS             ; print message for leaving init procedure
 283+ F398 E1                   pop     HL              ; retrieve code string pointer
 284+ F399 C9                   ret                     ; return to caller
 285+ F39A 0D 41 62 6F  ABRTXT: defb    CR,"Aborted",0
 285+ F39E 72 74 65 64
 285+ F3A2 00
 286+ F3A3
 287+ F3A3
 288+ F3A3               ; DISK command -------
 289+ F3A3              ; execute several operations on a disk:
 290+ F3A3              ; "F": format/rewrite Master Sector
 291+ F3A3              ; "R": rename disk
 292+ F3A3              ; syntax: DISK "arg1"[,arg2][,1]
 293+ F3A3              TPHL:   equ     TMPDBF          ; temp. buffer for code string pointer
 294+ F3A3 CD 44 3E     DISK:   call    DIRMOD          ; can be executed ONLY in direct mode
 295+ F3A6 C2 E7 17             jp      NZ,IMERR        ; raise error if in indirect mode
 296+ F3A9 CD 91 F1             call    CHKDOS          ; check if DOS is enabled
 297+ F3AC                      ; check first argument
 298+ F3AC 2B                   dec     HL              ; dec 'cause GETCHR increments
 299+ F3AD CD 1B 1D             call    GETCHR          ; check if something follows
 300+ F3B0 CA D2 17             jp      Z,SNERR         ; if nothing else, raise a syntax error
 301+ F3B3 CD BE 21             call    EVAL            ; Evaluate expression
 302+ F3B6 CD B0 21             call    TSTSTR          ; Make sure it's a string
 303+ F3B9 22 D7 54             ld      (TPHL),HL       ; store code string pointer into a temp buffer
 304+ F3BC CD F7 27             call    GSTRCU          ; check that a string follows
 305+ F3BF CD 08 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
 306+ F3C2 7B                   ld      A,E
 307+ F3C3 3D                   dec     A               ; lenght must be = 1
 308+ F3C4 2A D7 54             ld      HL,(TPHL)       ; retrieve code string pointer
 309+ F3C7 C2 D2 17             jp      NZ,SNERR
 310+ F3CA AF                   xor     A
 311+ F3CB 32 EE 54             ld      (TPBF4),A       ; set default to full format
 312+ F3CE 0A                   ld      A,(BC)          ; load command
 313+ F3CF E6 5F                and     %01011111       ; Force upper case
 314+ F3D1 FE 46                cp      'F'             ; format command?
 315+ F3D3 CA ED F3             jp      Z,DSKFRM        ; yes
 316+ F3D6 FE 57                cp      'W'             ; rewrite master sector?
 317+ F3D8 CA E8 F3             jp      Z,RWMSSC        ; yes
 318+ F3DB FE 52                cp      'R'             ; rename command?
 319+ F3DD CA 89 F4             jp      Z,DSKRNM        ; yes
 320+ F3E0 FE 55                cp      'U'             ; undelete command?
 321+ F3E2 CA 7C F4             jp      Z,DSKUND        ; yes
 322+ F3E5 C3 D2 17             jp      SNERR           ; nothing more - raise a syntax error
 323+ F3E8
 324+ F3E8
 325+ F3E8              ; Format disk or rewrite Master sector
 326+ F3E8              ; syntax: DISK "F/W","disk name"
 327+ F3E8              ; "F" -> format disk, "W" -> rewrite master sector
 328+ F3E8              ; "disk name" is the name -> max 16 chars, allowed chars: "A" to "Z", "0" to "9","-", SPACE
 329+ F3E8              ; Format: set up a fresh new file system, re-writing the Master sector and
 330+ F3E8              ; initializing the directory
 331+ F3E8              ; Master Sector rewriting: re-initialize the Master Sector, writing a new disk name and
 332+ F3E8              ; re-calculating disk geometry
 333+ F3E8              DKNMPT: equ     TMPBFR2         ; store the pointer to the disk name string
 334+ F3E8              DKLNPT: equ     TMPBFR3         ; store the pointer to the lenght of disk name string
 335+ F3E8 3E 01        RWMSSC  ld      A,$01           ; set rewriting of master sector
 336+ F3EA 32 EE 54             ld      (TPBF4),A
 337+ F3ED CD D2 1A     DSKFRM: call    CHKSYN          ; Make sure ',' follows
 338+ F3F0 2C                   defb    ','
 339+ F3F1 CD E0 F4             call    CHKFLNM         ; check for file name
 340+ F3F4 11 37 F4             ld      DE,MSTTXT       ; format message
 341+ F3F7 3A EE 54             ld      A,(TPBF4)       ; check for type of operation
 342+ F3FA B7                   or      A               ; A=0 (full format)?
 343+ F3FB 20 03                jr      NZ,CFINIT       ; no, jump over
 344+ F3FD 11 4F F4             ld      DE,FRMTXT       ; rewrite Master Sector
 345+ F400 E5           CFINIT: push    HL              ; store code string pointer
 346+ F401 62                   ld      H,D             ; Point to message
 347+ F402 6B                   ld      L,E
 348+ F403 CD B4 26             call    PRS             ; print message for confirmation
 349+ F406 E1                   pop     HL              ; retrieve HL
 350+ F407 CD BB F4             call    CNFREQ          ; ask for confirmation
 351+ F40A DA 8C F3             jp      C,ABRTDS        ; if Carry set then abort
 352+ F40D CD FC FC     INITDSK:call    CF_INIT         ; init CF card
 353+ F410 DA 23 F3             jp      C,DOS_ERR       ; error if device not available/ready
 354+ F413 E5                   push    HL              ; store code string pointer
 355+ F414 CD 07 F5             call    DSK_INIT        ; init disk
 356+ F417 E1                   pop     HL              ; retrieve code string pointer
 357+ F418 DA 23 F3             jp      C,DOS_ERR       ; if Carry set, raise error
 358+ F41B E5           INITFN: push    HL              ; store code string pointer
 359+ F41C 3A 40 55             ld      A,(TMPBFR1)
 360+ F41F B7                   or      A               ; full formatting?
 361+ F420 20 0D                jr      NZ,MSPTOK       ; no
 362+ F422 21 67 F4             ld      HL,OPRCMP       ; yes, Point to message
 363+ F425 CD B4 26             call    PRS             ; print message for init confirmation
 364+ F428 16 00                ld      D,$00           ; print only disk details, no file list
 365+ F42A CD B5 F6             call    LST_FILES       ; print details of disk and list files
 366+ F42D E1                   pop     HL              ; retrieve code string pointer
 367+ F42E C9                   ret                     ; return to caller
 368+ F42F 21 67 F4     MSPTOK: ld      HL,OPRCMP       ; format OK message
 369+ F432 CD B4 26             call    PRS             ; print message for init confirmation
 370+ F435 E1                   pop     HL              ; retrieve code string pointer
 371+ F436 C9                   ret                     ; return to caller
 372+ F437 52 65 77 72  MSTTXT: defb    "Rewrite Master Sector? ",0
 372+ F43B 69 74 65 20
 372+ F43F 4D 61 73 74
 372+ F443 65 72 20 53
 372+ F447 65 63 74 6F
 372+ F44B 72 3F 20 00
 373+ F44F 57 41 52 4E  FRMTXT: defb    "WARNING!! Format disk? ",0
 373+ F453 49 4E 47 21
 373+ F457 21 20 46 6F
 373+ F45B 72 6D 61 74
 373+ F45F 20 64 69 73
 373+ F463 6B 3F 20 00
 374+ F467 4F 70 65 72  OPRCMP: defb    "Operation completed",CR,0
 374+ F46B 61 74 69 6F
 374+ F46F 6E 20 63 6F
 374+ F473 6D 70 6C 65
 374+ F477 74 65 64 0D
 374+ F47B 00
 375+ F47C
 376+ F47C
 377+ F47C              ; undelete files
 378+ F47C              ; look for files marked as "deleted" and undelete them
 379+ F47C 2B           DSKUND: dec     HL              ; dec 'cause GETCHR increments
 380+ F47D CD 1B 1D             call    GETCHR          ; check if something follows
 381+ F480 C2 D2 17             jp      NZ,SNERR        ; if something else, raise a syntax error
 382+ F483 E5                   push    HL              ; store code string pointer
 383+ F484 CD 05 FB             call    DSKUNDFL        ; undelete files
 384+ F487 E1                   pop     HL              ; retrieve code string pointer
 385+ F488 C9                   ret                     ; return to caller
 386+ F489
 387+ F489
 388+ F489              ; disk rename
 389+ F489              ; change the name of the disk w/o altering anything else
 390+ F489 CD D2 1A     DSKRNM: call    CHKSYN          ; Make sure ',' follows
 391+ F48C 2C                   defb    ','
 392+ F48D CD E0 F4             call    CHKFLNM         ; check for file name
 393+ F490 E5                   push    HL              ; store code string pointer
 394+ F491 21 AD F4             ld      HL,RNDKTX       ; Point to message
 395+ F494 CD B4 26             call    PRS             ; print message for confirmation
 396+ F497 E1                   pop     HL              ; retrieve HL
 397+ F498 CD BB F4             call    CNFREQ          ; ask for confirmation
 398+ F49B DA 8C F3             jp      C,ABRTDS        ; if Carry set then abort
 399+ F49E CD FC FC             call    CF_INIT         ; init CF card
 400+ F4A1 DA 23 F3             jp      C,DOS_ERR       ; error if device not available/ready
 401+ F4A4 E5                   push    HL              ; store code string pointer
 402+ F4A5 CD 39 F6             call    DSK_RNM         ; init disk
 403+ F4A8 E1                   pop     HL              ; retrieve code string pointer
 404+ F4A9 DA 23 F3             jp      C,DOS_ERR       ; DOS error
 405+ F4AC C9                   ret
 406+ F4AD 52 65 6E 61  RNDKTX: defb    "Rename disk? ",0
 406+ F4B1 6D 65 20 64
 406+ F4B5 69 73 6B 3F
 406+ F4B9 20 00
 407+ F4BB
 408+ F4BB
 409+ F4BB              ; confirmation required by the user ('y' or 'Y' DO confirm, otherwise DON'T)
 410+ F4BB CD 26 09     CNFREQ: call    CURSOR_ON       ; enable cursor
 411+ F4BE AF                   xor     A
 412+ F4BF 32 3C 55             ld      (PRNTVIDEO),A   ; disable print-on-video
 413+ F4C2 CD 2A 02             call    RXA             ; look for a pressed key
 414+ F4C5 FE 03                cp      CTRLC           ; is it RUN STOP?
 415+ F4C7 28 15                jr      Z,CNFRQN        ; yes, abort operation
 416+ F4C9 E6 DF                and     %11011111       ; only UPPERCASE char
 417+ F4CB FE 59                cp      'Y'             ; 'Y'?
 418+ F4CD 20 0F                jr      NZ,CNFRQN       ; no, abort operation
 419+ F4CF 08                   ex      AF,AF'
 420+ F4D0 3E 01                ld      A,$01           ; re-enable...
 421+ F4D2 32 3C 55             ld      (PRNTVIDEO),A   ; ...print-on-video
 422+ F4D5 08                   ex      AF,AF'
 423+ F4D6 CD 1C 03             call    ECHO_CHAR       ; yes, echoes the char
 424+ F4D9 CD 3B 09             call    CURSOR_OFF      ; disable cursor
 425+ F4DC AF                   xor     A               ; reset Carry flag
 426+ F4DD C9                   ret                     ; return to caller
 427+ F4DE 37           CNFRQN: scf                     ; set Carry flag
 428+ F4DF C9                   ret                     ; return to caller
 429+ F4E0
 430+ F4E0
 431+ F4E0              ; check that a disk/file name follows
 432+ F4E0 2B           CHKFLNM:dec     HL              ; dec 'cause GETCHR increments
 433+ F4E1 CD 1B 1D             call    GETCHR          ; check if something follows
 434+ F4E4 CA D2 17             jp      Z,SNERR         ; if nothing else, raise a syntax error
 435+ F4E7 CD BE 21             call    EVAL            ; Evaluate expression
 436+ F4EA CD B0 21     CHKFN1: call    TSTSTR          ; Make sure it's a string
 437+ F4ED 22 D9 54             ld      (TMPDBF+2),HL   ; store code string pointer into a temp buffer
 438+ F4F0 CD F7 27             call    GSTRCU          ; get current string into pool
 439+ F4F3 CD 08 30             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
 440+ F4F6 7B                   ld      A,E             ; check if lenght = 0
 441+ F4F7 A7                   and     A               ; null string?
 442+ F4F8 CA D2 17             jp      Z,SNERR         ; yes, syntax error
 443+ F4FB ED 53 44 55          ld      (DKLNPT),DE     ; no, store lenght
 444+ F4FF ED 43 42 55          ld      (DKNMPT),BC     ; store address of temp string
 445+ F503 2A D9 54             ld      HL,(TMPDBF+2)   ; retrieve code string pointer
 446+ F506 C9                   ret                     ; return to caller
 447+ F507
 448+ F507
 449+ F507              ; *****************************************************************************
 450+ F507              ; D I S K    I N I T
 451+ F507              ; Functions: format a disk creating a fresh new file system on disk or
 452+ F507              ;            rewrite only the Master Sector
 453+ F507              ; *****************************************************************************
 454+ F507 3A EE 54     DSK_INIT:   ld      A,(TPBF4)       ; load type of formatting
 455+ F50A 32 40 55                 ld      (TMPBFR1),A     ; save onto another location for later use
 456+ F50D CD DB FC                 call    CLRIOBF         ; clear I/O buffer
 457+ F510 CD F0 FC                 call    CLRDOSBF        ; clear DOS buffer
 458+ F513 3E E0                    ld 	    A,$E0           ; select CF as master, driver 0, LBA mode (bits #5-7=111)
 459+ F515 D3 56                    out     (CF_LBA3),A     ; send configuration
 460+ F517 3E EC                    ld      A,$EC           ; select "drive ID" command
 461+ F519 D3 57                    out     (CF_CMD),A      ; send command
 462+ F51B CD 31 FD                 call	CF_DAT_RDY      ; wait until data is ready to be read
 463+ F51E CD 93 FD                 call	CF_RD_CMD       ; read data and store into I/O buffer
 464+ F521 11 D0 FD                 ld      DE,DOSBFR       ; address of default conf. buffer
 465+ F524 21 F0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
 466+ F527 01 0E 00                 ld      BC,$000E        ; position of current disk size in sectors
 467+ F52A 09                       add     HL,BC           ; set into HL
 468+ F52B 0E 04                    ld      C,$04           ; 4 bytes to copy
 469+ F52D ED B0                    ldir                    ; copy (DE is auto-incremented)
 470+ F52F 21 F0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
 471+ F532 01 02 00                 ld      BC,$0002        ; 2 bytes to copy and also address of number of cylinders
 472+ F535 09                       add     HL,BC           ; get position of data
 473+ F536 ED B0                    ldir                    ; copy (DE is auto-incremented)
 474+ F538 21 F0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
 475+ F53B 01 0C 00                 ld      BC,$000C        ; address of number of sectors per cylinder
 476+ F53E 09                       add     HL,BC           ; get position of data
 477+ F53F 0E 02                    ld      C,$02           ; 2 bytes to copy
 478+ F541 ED B0                    ldir                    ; copy (DE is auto-incremented)
 479+ F543 21 F0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
 480+ F546 01 06 00                 ld      BC,$0006        ; address of number of heads
 481+ F549 09                       add     HL,BC           ; get position of data
 482+ F54A 0E 02                    ld      C,$02           ; 2 bytes to copy
 483+ F54C ED B0                    ldir                    ; copy (DE is auto-incremented)
 484+ F54E                          ; now we calculate the # of files allowed (1 file = 1 block = 64K)
 485+ F54E ED 53 EE 54              ld      (TPBF4),DE      ; store current pointer to temp. default conf. buffer
 486+ F552 21 D0 FD                 ld      HL,DOSBFR       ; load number of sectors
 487+ F555 4E                       ld      C,(HL)          ; MSW into AC
 488+ F556 23                       inc     HL
 489+ F557 7E                       ld      A,(HL)
 490+ F558 23                       inc     HL
 491+ F559 5E                       ld      E,(HL)          ; LSW into DE
 492+ F55A 23                       inc     HL
 493+ F55B 56                       ld      D,(HL)
 494+ F55C D5                       push    DE              ; move DE into IX
 495+ F55D DD E1                    pop     IX
 496+ F55F 11 80 00                 ld      DE,$0080        ; 128 sectors per block
 497+ F562 CD 78 41                 call    DIV_32_16       ; execute ACIX/DE; result is into ACIX, remainder into HL
 498+ F565 47                       ld      B,A             ; now result is into BCIX
 499+ F566 B1                       or      C               ; BC=$0000?
 500+ F567 28 05                    jr      Z,DOS_FTC       ; yes, but.....
 501+ F569 11 FF FF                 ld      DE,$FFFF        ; ... no more than $FFFF files, so set limit
 502+ F56C 18 0E                    jr      DOS_FT1         ; jump over
 503+ F56E DD E5        DOS_FTC:    push    IX              ; move IX into DE
 504+ F570 D1                       pop     DE              ; now result is into BCDE
 505+ F571 7C                       ld      A,H             ; remainder = zero?
 506+ F572 B5                       or      L
 507+ F573 CA 7C F5                 jp      Z,DOS_FT1       ; yes, jump over
 508+ F576 13                       inc     DE              ; no, increment DE
 509+ F577 7A                       ld      A,D             ; check if DE is zero
 510+ F578 B3                       or      E
 511+ F579 20 01                    jr      NZ,DOS_FT1      ; no, jump over
 512+ F57B 1B           DOS_FT0:    dec     DE              ; yes, so set files to limit of $FFFF
 513+ F57C 2A EE 54     DOS_FT1:    ld      HL,(TPBF4)      ; retrieve current pointer to temp. def. conf. buffer
 514+ F57F CD 6E FC                 call    DE2HL           ; store # of entries
 515+ F582 D5                       push    DE              ; store entries
 516+ F583 EB                       ex      DE,HL           ; copy current pointer into DE
 517+ F584 21 8F F1                 ld      HL,DSKDIRADR    ; address of directory start
 518+ F587 01 02 00                 ld      BC,$0002        ; 2 bytes to copy
 519+ F58A ED B0                    ldir                    ; copy into buffer
 520+ F58C                          ; now we calculate the starting sector of data area
 521+ F58C E1                       pop     HL              ; entries into HL
 522+ F58D 0E 10                    ld      C,$10           ; 16 entries per sector
 523+ F58F CD 54 41                 call    DIV_16_8        ; calculare how many sectors for dir (HL/C)
 524+ F592 B7                       or      A               ; remainder = 0?
 525+ F593 28 01                    jr      Z,DOS_FT2       ; yes, jump over
 526+ F595 23                       inc     HL              ; increment sectors
 527+ F596 E5           DOS_FT2:    push    HL              ; store size of directory
 528+ F597 FD E1                    pop     IY              ; into IY
 529+ F599 23                       inc     HL              ; data area is 1 sector bigger than directory's size
 530+ F59A EB                       ex      DE,HL           ; restore pointer into HL, and move sectors into DE
 531+ F59B 73                       ld      (HL),E          ; store starting of
 532+ F59C 23                       inc     HL              ; data area
 533+ F59D 72                       ld      (HL),D          ; into buffer
 534+ F59E                          ; now clean again the I/O buffer and copy the configuration into I/O buffer
 535+ F59E CD DB FC                 call    CLRIOBF         ; clear I/O buffer
 536+ F5A1 21 80 F1                 ld      HL,DSKHDR       ; address of disk header string
 537+ F5A4 11 F0 FD                 ld      DE,IOBUFF       ; address of I/O buffer
 538+ F5A7 01 0F 00                 ld      BC,$000F        ; 15 chars
 539+ F5AA ED B0                    ldir                    ; copy header into buffer
 540+ F5AC 21 D0 FD                 ld      HL,DOSBFR       ; first part of configuration
 541+ F5AF 01 10 00                 ld      BC,$0010        ; composed by 16 chars
 542+ F5B2 ED B0                    ldir                    ; copy (DE is auto-incremented)
 543+ F5B4 AF                       xor     A               ; A=$0
 544+ F5B5 12                       ld      (DE),A          ; marker at $1F
 545+ F5B6 13                       inc     DE
 546+ F5B7 CD 46 FC                 call    CHKNMVAL        ; copy disk name into buffer
 547+ F5BA DA 79 F6                 jp      C,D1ERR         ; disk name error
 548+ F5BD CD CE FB     DOS_FT5:    call    RND_ID          ; generate a semi-random disk ID
 549+ F5C0 21 F0 FD                 ld      HL,IOBUFF       ; get starting address of I/O buffer
 550+ F5C3 54                       ld      D,H             ; copy into DE...
 551+ F5C4 5D                       ld      E,L             ; ...for later use
 552+ F5C5 01 FE 01                 ld      BC,$01FE        ; get address of last 2 bytes...
 553+ F5C8 09                       add     HL,BC           ; ...of the I/O buffer
 554+ F5C9 3E 38                    ld      A,'8'           ; write marker "80"
 555+ F5CB 77                       ld      (HL),A          ; ...
 556+ F5CC 23                       inc     HL              ; ...
 557+ F5CD 3E 30                    ld      A,'0'           ; ...
 558+ F5CF 77                       ld      (HL),A          ; ...into last 2 locations
 559+ F5D0 EB                       ex      DE,HL           ; copy beginning of I/O buffer from DE into HL
 560+ F5D1 AF                       xor     A               ; reset A - set sector # to $00000000
 561+ F5D2 47                       ld      B,A             ; LBA0=0
 562+ F5D3 4F                       ld      C,A             ; LBA1=0
 563+ F5D4 57                       ld      D,A             ; LBA2=0
 564+ F5D5 5F                       ld      E,A             ; LBA3=0
 565+ F5D6 CD A7 FD                 call    CF_WR_SEC       ; write sector to CF
 566+ F5D9 DA 5C F6                 jp      C,D2ERR
 567+ F5DC                          ; check if only re-writing of Master Sector was need
 568+ F5DC 3A 40 55                 ld      A,(TMPBFR1)     ; retrieve type of formatting
 569+ F5DF 3D                       dec     A               ; A=1?
 570+ F5E0 C8                       ret     Z               ; yes, finished job
 571+ F5E1                          ; erase directory -----------------------------
 572+ F5E1                          ; create a progress bar
 573+ F5E1 3E 0D                    ld      A,CR            ; no, full format - go to new line
 574+ F5E3 CD DD 1A                 call    OUTC
 575+ F5E6 FD E5                    push    IY              ; copy directory's size...
 576+ F5E8 E1                       pop     HL              ; ...into HL
 577+ F5E9 01 18 00                 ld      BC,$0018        ; 24 steps
 578+ F5EC CD 54 41                 call    DIV_16_8        ; calculate HL/24 (remainder is ignored, here)
 579+ F5EF E5                       push    HL              ; store result...
 580+ F5F0 DD E1                    pop     IX              ; ...into IX...
 581+ F5F2 EB                       ex      DE,HL           ; ...and into DE
 582+ F5F3 3E 2D                    ld      A,'-'           ; print a progress bar
 583+ F5F5 CD 31 F6                 call    DOS_FT7         ; print it
 584+ F5F8 3E 1C                    ld      A,CRSLFT        ; CURSOR left
 585+ F5FA CD 31 F6                 call    DOS_FT7         ; come back to beginning of line
 586+ F5FD FD E5                    push    IY              ; copy directory's size
 587+ F5FF E1                       pop     HL              ; into HL
 588+ F600 01 01 00                 ld      BC,$0001        ; first sector of directory
 589+ F603 CD DB FC                 call    CLRIOBF         ; clear I/O buffer
 590+ F606 D5           DOS_FTA:    push    DE              ; store counter
 591+ F607 11 00 00                 ld      DE,$0000        ; reset MSW of sector pointer
 592+ F60A CD A7 FD                 call    CF_WR_SEC       ; write sector to CF
 593+ F60D DA 2D F6                 jp      C,DOS_FT10      ; error occured
 594+ F610 03                       inc     BC              ; next sector
 595+ F611 2B                       dec     HL              ; decrement HL
 596+ F612 D1                       pop     DE              ; retrieve counter
 597+ F613 1B                       dec     DE              ; decrement counter
 598+ F614 7B                       ld      A,E
 599+ F615 B2                       or      D               ; check if counter is zero
 600+ F616 20 08                    jr      NZ,DOS_FT9      ; no, jump over
 601+ F618 3E 2A                    ld      A,'*'           ; yes, print char
 602+ F61A CD DD 1A                 call    OUTC
 603+ F61D DD E5                    push    IX              ; re-set counter
 604+ F61F D1                       pop     DE
 605+ F620 7C           DOS_FT9:    ld      A,H             ; check if...
 606+ F621 B5                       or      L               ; ...HL = 0
 607+ F622 20 E2                    jr      NZ,DOS_FTA      ; if not, repeat
 608+ F624 3E 0D                    ld      A,CR            ; return
 609+ F626 CD DD 1A                 call    OUTC            ; next line
 610+ F629 CD 74 FD                 call    CF_STANDBY      ; set CF into stand-by mode
 611+ F62C C9                       ret
 612+ F62D D1           DOS_FT10:   pop     DE
 613+ F62E C3 5C F6                 jp      D2ERR           ; disk geometry error
 614+ F631
 615+ F631              ; print a char 24 times
 616+ F631 06 18        DOS_FT7:    ld      B,$18           ; 24 times
 617+ F633 CD DD 1A     DOS_FT8:    call    OUTC            ; print char
 618+ F636 10 FB                    djnz    DOS_FT8         ; repeat
 619+ F638 C9                       ret                     ; return to caller
 620+ F639
 621+ F639
 622+ F639              ; *****************************************************************************
 623+ F639              ; D I S K    R E N A M E
 624+ F639              ;******************************************************************************
 625+ F639 CD DB FC     DSK_RNM:    call    CLRIOBF         ; clear I/O buffer
 626+ F63C CD F0 FC                 call    CLRDOSBF        ; clear DOS buff.
 627+ F63F CD C2 FB                 call    LDMSCT          ; load Master Sector
 628+ F642 21 F0 FD                 ld      HL,IOBUFF       ; point to start of I/O buffer
 629+ F645 01 20 00                 ld      BC,$0020        ; offset for disk name
 630+ F648 09                       add     HL,BC           ; get pointer
 631+ F649 EB                       ex      DE,HL           ; copy pointer into DE
 632+ F64A CD 46 FC                 call    CHKNMVAL        ; copy disk name into buffer
 633+ F64D DA 79 F6                 jp      C,D1ERR         ; disk name error
 634+ F650 11 00 00                 ld      DE,$0000        ; reset MSW sector
 635+ F653 42                       ld      B,D             ; reset LSW sector
 636+ F654 4A                       ld      C,D
 637+ F655 CD A7 FD                 call    CF_WR_SEC       ; write sector
 638+ F658 DA BB FA                 jp      C,WRT_ERR       ; error?
 639+ F65B C9                       ret                     ; no, return to caller
 640+ F65C
 641+ F65C
 642+ F65C              ; *****************************************************************************
 643+ F65C              ; DOS ERRORS
 644+ F65C              ; *****************************************************************************
 645+ F65C 3E 3C        D2ERR:      ld      A,D2            ; disk geometry error
 646+ F65E 18 1B                    jr      RET_ERR
 647+ F660 3E 42        DSKFULL:    ld      A,D5            ; disk full error
 648+ F662 18 17                    jr      RET_ERR
 649+ F664 3E 44        DUPLERR:    ld      A,D6            ; duplicate file name
 650+ F666 18 13                    jr      RET_ERR
 651+ F668 3E 3A        NAMERR:     ld      A,D1            ; file name error
 652+ F66A 18 0F                    jr      RET_ERR
 653+ F66C 3E 48        FLNTFND:    ld      A,D8            ; file not found
 654+ F66E 18 0B                    jr      RET_ERR
 655+ F670 3E 40        LODERR:     ld      A,D4            ; generic load error
 656+ F672 18 07                    jr      RET_ERR
 657+ F674 3E 46        DOSVERSERR: ld      A,D7            ; DOS version error
 658+ F676 C3 7B F6                 jp      RET_ERR
 659+ F679 3E 3A        D1ERR:      ld      A,D1            ; name string error
 660+ F67B 32 D6 54     RET_ERR:    ld      (DOSER),A       ; store DOS error
 661+ F67E CD 74 FD                 call    CF_STANDBY      ; set CF into stand-by
 662+ F681 37                       scf                     ; set Carry for error
 663+ F682 C9                       ret                     ; return to caller
 664+ F683
 665+ F683              ; *****************************************************************************
 666+ F683              ; L I S T    F I L E S
 667+ F683              ; Function: print details of disk and list files
 668+ F683              ; Input: D: $00=only disk details; $01=file list, too
 669+ F683              ; *****************************************************************************
 670+ F683 44 69 73 6B  DSKNMTX:    defb    "Disk name: ",0
 670+ F687 20 6E 61 6D
 670+ F68B 65 3A 20 00
 671+ F68F 0D 53 65 63  TLSCTTX:    defb    CR,"Sectors: ",0
 671+ F693 74 6F 72 73
 671+ F697 3A 20 00
 672+ F69A 0D 41 6C 6C  ALFLSTXT:   defb    CR,"Allowed files: ",0
 672+ F69E 6F 77 65 64
 672+ F6A2 20 66 69 6C
 672+ F6A6 65 73 3A 20
 672+ F6AA 00
 673+ F6AB 20 66 69 6C  TLFLSTX:    defb    " file(s)",CR,0
 673+ F6AF 65 28 73 29
 673+ F6B3 0D 00
 674+ F6B5 CD 0E FC     LST_FILES:  call    CHKDSKVAL       ; check DOS version & load disk details
 675+ F6B8 DA 74 F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
 676+ F6BB D5                       push    DE              ; store D
 677+ F6BC CD C2 FB                 call    LDMSCT          ; load Master Sector
 678+ F6BF 21 83 F6                 ld      HL,DSKNMTX      ; pointer to "Disk name" message
 679+ F6C2 CD B4 26                 call    PRS             ; print it
 680+ F6C5 21 F0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
 681+ F6C8 11 20 00                 ld      DE,$0020        ; position of disk name
 682+ F6CB 19                       add     HL,DE           ; get address
 683+ F6CC 06 10                    ld      B,$10           ; 16 chars
 684+ F6CE 7E           INPR1:      ld      A,(HL)          ; load char
 685+ F6CF CD DD 1A                 call    OUTC            ; print it
 686+ F6D2 23                       inc     HL
 687+ F6D3 10 F9                    djnz    INPR1           ; repeat
 688+ F6D5 3E 0D                    ld      A,CR
 689+ F6D7 CD DD 1A                 call    OUTC            ; carriage return
 690+ F6DA DD 21 00 00              ld      IX,$0000        ; reset file counter (for use in formatting)
 691+ F6DE D1                       pop     DE              ; retrieve D
 692+ F6DF 7A                       ld      A,D
 693+ F6E0 B7                       or      A               ; is D=0?
 694+ F6E1 CA 8C F7                 jp      Z,PNTSTATS      ; yes, jump over
 695+ F6E4                          ; print list of files
 696+ F6E4 21 F0 FD                 ld      HL,IOBUFF       ; start of I/O buffer
 697+ F6E7 11 0F 00                 ld      DE,$000F        ; point to details of disk
 698+ F6EA 19                       add     HL,DE           ; find address
 699+ F6EB 11 D0 FD                 ld      DE,DOSBFR       ; store into DOS buffer
 700+ F6EE 01 20 00                 ld      BC,$0020        ; 32 bytes
 701+ F6F1 ED B0                    ldir                    ; copy
 702+ F6F3 CD B3 FB                 call    LDENTRIES       ; load entries
 703+ F6F6 FD 2A DD 54              ld      IY,(NTR_NBR)    ; load max entries
 704+ F6FA D9                       exx
 705+ F6FB 01 00 00                 ld      BC,$0000        ; reset file counter
 706+ F6FE D9                       exx
 707+ F6FF CD 7A FB                 call    SETPTEN         ; point to 1st sector of dir
 708+ F702 CD 82 FB     LSTFILES1:  call    PT2FSEN         ; point to 1st entry of a dir's sect
 709+ F705 CD 8D FB     LSTFILES2:  call    CKCREN          ; check current entry
 710+ F708 28 5C                    jr      Z,LSTFILES6     ; if empty or deleted, ignore it
 711+ F70A C5                       push    BC              ; this is a valid entry - so, store BC (LSW of sect)
 712+ F70B FD E5                    push    IY              ; store IY (entries counter)
 713+ F70D E5                       push    HL              ; store HL (sect entry counter)
 714+ F70E D5                       push    DE              ; store DE (MSW of sector)
 715+ F70F DD E5                    push    IX              ; store IX (pointer to first byte of entry)
 716+ F711 06 10                    ld      B,$10           ; 16 chars to read and print
 717+ F713 DD 7E 00     LSTFILES3:  ld      A,(IX)          ; load char from name
 718+ F716 CD DD 1A                 call    OUTC            ; print char
 719+ F719 DD 23                    inc     IX              ; next char
 720+ F71B 10 F6                    djnz    LSTFILES3       ; repeat
 721+ F71D 3E 20                    ld      A,SPC
 722+ F71F CD DD 1A                 call    OUTC            ; print space
 723+ F722 DD 7E 00                 ld      A,(IX)          ; file type
 724+ F725 D6 80                    sub     $80             ; types start from $80
 725+ F727 B7                       or      A               ; BAS type ($00)?
 726+ F728 20 05                    jr      NZ,LSTFILES20   ; no, jump over
 727+ F72A 21 D0 F7                 ld      HL,FILETP       ; print "BAS"
 728+ F72D 18 0B                    jr      LSTFILESPR
 729+ F72F 3D           LSTFILES20: dec     A               ; BIN type ($01)?
 730+ F730 20 05                    jr      NZ,LSTFILES21   ; no, jump over
 731+ F732 21 D5 F7                 ld      HL,FILETP+5     ; print "BIN"
 732+ F735 18 03                    jr      LSTFILESPR
 733+ F737 21 DA F7     LSTFILES21: ld      HL,FILETP+10    ; print "???"
 734+ F73A CD B4 26     LSTFILESPR: call    PRS
 735+ F73D 01 08 00                 ld      BC,$0008
 736+ F740 DD 09                    add     IX,BC           ; point to file size in bytes
 737+ F742 DD 4E 00                 ld      C,(IX)          ; load size in BC, first LSW
 738+ F745 DD 23                    inc     IX
 739+ F747 DD 46 00                 ld      B,(IX)          ; then MSW
 740+ F74A C5                       push    BC              ; copy...
 741+ F74B DD E1                    pop     IX              ; ...into IX
 742+ F74D 11 00 00                 ld      DE,$0000        ; reset DE
 743+ F750 FD E5                    push    IY
 744+ F752 CD 81 FC                 call    PRN16ASCIX      ; print size in bytes (DEIX)
 745+ F755 FD E1                    pop     IY
 746+ F757 3E 0D                    ld      A,CR
 747+ F759 CD DD 1A                 call    OUTC            ; print carriage return
 748+ F75C D9                       exx                     ; set shadow registers
 749+ F75D 03                       inc     BC              ; increment file counter
 750+ F75E D9                       exx                     ; restore main registers
 751+ F75F DD E1                    pop     IX              ; retrieve IX
 752+ F761 D1                       pop     DE              ; retrieve DE
 753+ F762 E1                       pop     HL              ; retrieve HL
 754+ F763 FD E1                    pop     IY              ; retrieve IY
 755+ F765 C1                       pop     BC              ; retrieve BC
 756+ F766 CD 46 1D     LSTFILES6:  call    TSTBRK          ; Test for break key
 757+ F769 CD 49 1C                 call    TSTSPC          ; test for space
 758+ F76C CD 95 FB                 call    GTNXTEN         ; other entries in this sector?
 759+ F76F 20 94                    jr      NZ,LSTFILES2    ; yes, continue check
 760+ F771 CD A1 FB     LSTFILES5:  call    CKLSTEN         ; go to next sector
 761+ F774 D2 02 F7                 jp      NC,LSTFILES1    ; more entries? repeat
 762+ F777 D9                       exx                     ; set shadow registers
 763+ F778 C5                       push    BC              ; store file counter
 764+ F779 D9                       exx                     ; restore main registers
 765+ F77A DD E1                    pop     IX              ; retrieve file counter
 766+ F77C DD E5                    push    IX              ; store it again
 767+ F77E 11 00 00                 ld      DE,$0000        ; reset DE
 768+ F781 CD 81 FC                 call    PRN16ASCIX      ; print number of files from DEIX
 769+ F784 21 AB F6                 ld      HL,TLFLSTX
 770+ F787 CD B4 26                 call    PRS             ; print "file(s)"
 771+ F78A DD E1                    pop     IX
 772+ F78C 21 8F F6     PNTSTATS:   ld      HL,TLSCTTX      ; Point to message "Tot. sectors"
 773+ F78F CD B4 26                 call    PRS             ; print message
 774+ F792 21 D0 FD                 ld      HL,DOSBFR       ; reload address of I/O buffer and point to disk size
 775+ F795 DD E5                    push    IX
 776+ F797 CD 78 FC                 call    PRN32ASCII      ; print size
 777+ F79A 3E 2F                    ld      A,'/'
 778+ F79C CD DD 1A                 call    OUTC            ; print a "/""
 779+ F79F D1                       pop     DE              ; copy number of entries into DE
 780+ F7A0 01 80 00                 ld      BC,$0080        ; 128 sectors per entry block
 781+ F7A3 CD 1E 41                 call    MUL_U32         ; multiply BC times DE: returns DEHL
 782+ F7A6 ED 53 E8 54              ld      (TPBF1),DE      ; store results
 783+ F7AA 22 EA 54                 ld      (TPBF2),HL
 784+ F7AD 21 E8 54                 ld      HL,TPBF1        ; print results
 785+ F7B0 CD 78 FC                 call    PRN32ASCII
 786+ F7B3 21 9A F6                 ld      HL,ALFLSTXT     ; Point to message "Allowed files"
 787+ F7B6 CD B4 26                 call    PRS             ; print message
 788+ F7B9 21 D0 FD                 ld      HL,DOSBFR       ; reload address of I/O buffer
 789+ F7BC 01 0A 00                 ld      BC,$000A        ; address of allowed files
 790+ F7BF 09                       add     HL,BC           ; find pointer
 791+ F7C0 11 00 00                 ld      DE,$0000        ; MSW set to $0000
 792+ F7C3 CD 7B FC                 call    PRN16ASCII      ; print max files
 793+ F7C6 3E 0D                    ld      A,CR
 794+ F7C8 CD DD 1A                 call    OUTC            ; print a carriage return
 795+ F7CB CD 74 FD     EXITFLS:    call    CF_STANDBY      ; put CF into standby
 796+ F7CE AF                       xor     A               ; clear Carry flag
 797+ F7CF C9                       ret                     ; return to caller
 798+ F7D0 42 41 53 20  FILETP:     defb    "BAS ",0        ; BASIC type
 798+ F7D4 00
 799+ F7D5 42 49 4E 20              defb    "BIN ",0        ; BINARY type
 799+ F7D9 00
 800+ F7DA 3F 3F 3F 20              defb    "??? ",0        ; unkown
 800+ F7DE 00
 801+ F7DF
 802+ F7DF
 803+ F7DF              ; *****************************************************************************
 804+ F7DF              ; S A V E    F I L E
 805+ F7DF              ; save current BASIC program onto a file
 806+ F7DF              ; *****************************************************************************
 807+ F7DF CD 6D F9     SAVFILE:    call    CHKFLEXT        ; file already exists?
 808+ F7E2 DA 64 F6                 jp      C,DUPLERR       ; name is present - error
 809+ F7E5 CD 52 FB                 call    FNDFRENTR       ; find a free entry in the directory
 810+ F7E8 DA 60 F6                 jp      C,DSKFULL       ; no entry, disk full error
 811+ F7EB 3A EE 54                 ld      A,(TPBF4)       ; check what to save
 812+ F7EE FE 80                    cp      $80             ; BASIC program?
 813+ F7F0 C2 FF F7                 jp      NZ,SAVFL3       ; no, jump over
 814+ F7F3                          ; BASIC area to save starts at PROGND and ends at (PROGND)
 815+ F7F3 2A 86 55                 ld      HL,(PROGND)     ; load end of BASIC program <- WARNING: pay attention to (PROGND) and PROGND
 816+ F7F6 11 86 55                 ld      DE,PROGND       ; start of RAM to be saved  <- WARNING: pay attention to (PROGND) and PROGND
 817+ F7F9 ED 53 F0 54              ld      (SRTMEM),DE     ; copy DE
 818+ F7FD 18 08                    jr      SAVFL1
 819+ F7FF 2A F2 54     SAVFL3:     ld      HL,(ENDMEM)     ; save a portion of memory: HL <= end of portion
 820+ F802 23                       inc     HL              ; we always need 1 more byte to store the portion of memory
 821+ F803 ED 5B F0 54              ld      DE,(SRTMEM)     ; DE <= start of portion
 822+ F807                          ; compute how many sectors/blocks are needed to save file
 823+ F807 AF           SAVFL1:     xor     A               ; reset Carry
 824+ F808 ED 52                    sbc     HL,DE           ; get how many bytes to save
 825+ F80A 22 DF 54                 ld      (BYT_SIZ),HL    ; store into memory
 826+ F80D 11 00 02                 ld      DE,$0200        ; 512 bytes per sector
 827+ F810 7C                       ld      A,H             ; move lenght...
 828+ F811 4D                       ld      C,L             ; ...into AC
 829+ F812 CD 63 41                 call    DIV_16_16       ; lenght/512 = nbr. of sectors: quotient in AC but A will be discarded
 830+ F815 7C                       ld      A,H             ; check if...
 831+ F816 B5                       or      L               ; ...remainder (HL) is 0
 832+ F817 28 01                    jr      Z,SAVFL6        ; yes, jump over
 833+ F819 03                       inc     BC              ; no, so we need another sector
 834+ F81A 79           SAVFL6:     ld      A,C
 835+ F81B 32 E1 54                 ld      (SCT_SIZ),A     ; store into memory
 836+ F81E              SAVFL7:     ; start saving on disk
 837+ F81E 11 00 00                 ld      DE,$0000        ; directory is always from sector 0000-0001
 838+ F821 ED 4B DB 54              ld      BC,(DIR_SCT)    ; load sector of dir where to save file entry
 839+ F825 CD 3E FD                 call    CF_SETSTR       ; set sector to read
 840+ F828 CD 80 FD                 call    CF_RD_SEC       ; read sector
 841+ F82B 3A DD 54                 ld      A,(NTR_NBR)     ; load entry number (ignoring MSB)
 842+ F82E E6 0F                    and     %00001111       ; be sure to get only low nibble
 843+ F830 87                       add     A,A             ; multiply...
 844+ F831 87                       add     A,A             ; ...times 16 by...
 845+ F832 87                       add     A,A             ; ...adding...
 846+ F833 87                       add     A,A             ; ...4 times
 847+ F834 CB 27                    sla     A               ; left shift to multiply times 32 - Carry is set if results is > 255
 848+ F836 5F                       ld      E,A             ; copy into C
 849+ F837 CB 12                    rl      D               ; if Carry, then increment D (D was 0, see above)
 850+ F839                          ; set name
 851+ F839 21 F0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
 852+ F83C 19                       add     HL,DE           ; add offset to get address of entry
 853+ F83D 11 D0 FD                 ld      DE,DOSBFR       ; pointer to file name
 854+ F840 01 10 00                 ld      BC,$0010        ; 16 chars
 855+ F843 EB                       ex      DE,HL           ; move source into HL and destination into DE
 856+ F844 ED B0                    ldir                    ; copy file name
 857+ F846 EB                       ex      DE,HL           ; move current buffer pointer into HL
 858+ F847 3A EE 54                 ld      A,(TPBF4)       ; load the type of file
 859+ F84A 77                       ld      (HL),A          ; store it
 860+ F84B 23                       inc     HL
 861+ F84C AF                       xor     A               ; file attributes - AT THE MOMENT, NO ATTRIBUTES
 862+ F84D 77                       ld      (HL),A
 863+ F84E 23                       inc     HL
 864+ F84F ED 5B DD 54              ld      DE,(NTR_NBR)    ; reload entry number
 865+ F853 CD 6E FC                 call    DE2HL           ; store entry into buffer
 866+ F856 E5                       push    HL              ; store pointer
 867+ F857 01 80 00                 ld      BC,$0080        ; 128 sectors per entry block
 868+ F85A CD 1E 41                 call    MUL_U32         ; multiply BC times DE: returns DEHL
 869+ F85D ED 4B D9 54              ld      BC,(DAT_STRT)   ; load start of data
 870+ F861 09                       add     HL,BC           ; add sector of data area
 871+ F862 30 01                    jr      NC,SAVFL9       ; overflow?
 872+ F864 13                       inc     DE              ; yes, increment DE
 873+ F865 ED 53 E2 54  SAVFL9:     ld      (MSW_SCT),DE    ; store MSW of sector
 874+ F869 22 E4 54                 ld      (LSW_SCT),HL    ; store LSW of sector
 875+ F86C E1                       pop     HL              ; retrieve pointer
 876+ F86D CD 6E FC                 call    DE2HL           ; also copy MSW of sector into entry
 877+ F870 ED 5B E4 54              ld      DE,(LSW_SCT)    ; retrieve LSW
 878+ F874 CD 6E FC                 call    DE2HL           ; also copy LSW of sector into entry
 879+ F877 ED 5B DF 54              ld      DE,(BYT_SIZ)    ; retrieve file size in bytes
 880+ F87B CD 6E FC                 call    DE2HL           ; copy file size into buffer
 881+ F87E 3A E1 54                 ld      A,(SCT_SIZ)     ; retrieve file size in sectors
 882+ F881 77                       ld      (HL),A          ; copy into buffer
 883+ F882 23                       inc     HL              ; next location
 884+ F883 ED 5B F0 54              ld      DE,(SRTMEM)     ; start of address of file in RAM
 885+ F887 CD 6E FC                 call    DE2HL           ; copy into buffer
 886+ F88A 06 03                    ld      B,$03           ; remaining chars...
 887+ F88C AF                       xor     A               ; ...set to $00
 888+ F88D 77           SAVFL2:     ld      (HL),A          ; reset byte
 889+ F88E 23                       inc     HL              ; next cell
 890+ F88F 10 FC                    djnz    SAVFL2          ; repeat
 891+ F891                          ; save entry into directory
 892+ F891 11 00 00                 ld      DE,$0000        ; block 0
 893+ F894 ED 4B DB 54              ld      BC,(DIR_SCT)    ; load sector of dir where to save file entry
 894+ F898 CD A7 FD                 call    CF_WR_SEC       ; write new entry into directory
 895+ F89B DA 5C F6                 jp      C,D2ERR         ; error occured
 896+ F89E CD DB FC                 call    CLRIOBF         ; clear I/O buffer
 897+ F8A1                          ; start saving RAM
 898+ F8A1 ED 5B F0 54              ld      DE,(SRTMEM)     ; load start of RAM
 899+ F8A5 ED 53 E6 54              ld      (RAM_PTR),DE    ; store
 900+ F8A9 CD DB FC     SAVFL10:    call    CLRIOBF         ; clear I/O buffer
 901+ F8AC 2A DF 54                 ld      HL,(BYT_SIZ)    ; load bytes left to be copied
 902+ F8AF 11 00 02                 ld      DE,$0200        ; are they < 512?
 903+ F8B2 CD F9 40                 call    CMP16
 904+ F8B5 30 04                    jr      NC,SAVFL4       ; no, jump over
 905+ F8B7 ED 5B DF 54              ld      DE,(BYT_SIZ)    ; yes, so load remaining bytes
 906+ F8BB 4B           SAVFL4:     ld      C,E             ; bytes to copy
 907+ F8BC 42                       ld      B,D             ; into BC
 908+ F8BD 2A E6 54                 ld      HL,(RAM_PTR)    ; load pointer to RAM to be saved
 909+ F8C0 11 F0 FD                 ld      DE,IOBUFF       ; load start of I/O buffer
 910+ F8C3 ED B0                    ldir                    ; copy data
 911+ F8C5 ED 5B E2 54              ld      DE,(MSW_SCT)    ; load MSW of sector
 912+ F8C9 ED 4B E4 54              ld      BC,(LSW_SCT)    ; load LSW of sector
 913+ F8CD CD A7 FD                 call    CF_WR_SEC       ; write sector
 914+ F8D0 DA BB FA                 jp      C,WRT_ERR       ; error?
 915+ F8D3 21 E1 54                 ld      HL,SCT_SIZ      ; sector counter
 916+ F8D6 35                       dec     (HL)            ; copied all the sectors?
 917+ F8D7 CA 06 F9                 jp      Z,SAVFLEXT      ; yes, exit
 918+ F8DA 2A E6 54     SAVFL11:    ld      HL,(RAM_PTR)    ; pointer to RAM
 919+ F8DD 11 00 02                 ld      DE,$0200        ; block of 512 bytes copied
 920+ F8E0 19                       add     HL,DE           ; calculate next starting address
 921+ F8E1 22 E6 54                 ld      (RAM_PTR),HL    ; store next block
 922+ F8E4 AF                       xor     A               ; reset Carry
 923+ F8E5 2A DF 54                 ld      HL,(BYT_SIZ)    ; load left bytes
 924+ F8E8 ED 52                    sbc     HL,DE           ; subtract copied bytes
 925+ F8EA 22 DF 54                 ld      (BYT_SIZ),HL    ; store left bytes
 926+ F8ED ED 4B E4 54              ld      BC,(LSW_SCT)    ; load LSW of sector
 927+ F8F1 03                       inc     BC              ; next sector
 928+ F8F2 78                       ld      A,B             ; BC=$0000?
 929+ F8F3 B1                       or      C
 930+ F8F4 20 09                    jr      NZ,SAVFL12      ; no, jump over
 931+ F8F6 ED 5B E2 54              ld      DE,(MSW_SCT)    ; load MSW of sector
 932+ F8FA 13                       inc     DE              ; increment DE
 933+ F8FB ED 53 E2 54              ld      (MSW_SCT),DE    ; store new MSW of sector
 934+ F8FF ED 43 E4 54  SAVFL12:    ld      (LSW_SCT),BC    ; store new LSW of sector
 935+ F903 C3 A9 F8                 jp      SAVFL10         ; repeat
 936+ F906 CD 74 FD     SAVFLEXT:   call    CF_STANDBY      ; set CF into stand-by mode
 937+ F909 AF                       xor     A               ; clear Carry flag
 938+ F90A C9                       ret                     ; return to caller
 939+ F90B
 940+ F90B
 941+ F90B              ; *****************************************************************************
 942+ F90B              ; C H A N G E    F I L E N A M E
 943+ F90B              ; change name to a file
 944+ F90B              ; *****************************************************************************
 945+ F90B ED 5B DF 54  CHNGNAM:    ld      DE,(BYT_SIZ)    ; load lenght
 946+ F90F ED 53 44 55              ld      (DKLNPT),DE     ; store it
 947+ F913 ED 5B E6 54              ld      DE,(RAM_PTR)    ; load address
 948+ F917 ED 53 42 55              ld      (DKNMPT),DE     ; store it
 949+ F91B CD 6D F9                 call    CHKFLEXT        ; destination file already exists?
 950+ F91E DA 64 F6                 jp      C,DUPLERR       ; file name already exists
 951+ F921 CD DB FC                 call    CLRIOBF         ; clear I/O buffer
 952+ F924 ED 5B 46 55              ld      DE,(TMPBFR4)    ; load lenght
 953+ F928 ED 53 44 55              ld      (DKLNPT),DE     ; store it
 954+ F92C ED 5B F0 54              ld      DE,(TPBF4+2)    ; load address
 955+ F930 ED 53 42 55              ld      (DKNMPT),DE     ; store it
 956+ F934 CD 8A F9                 call    LK4FILE         ; look for file
 957+ F937 D2 6C F6                 jp      NC,FLNTFND      ; file not found error
 958+ F93A ED 5B DF 54              ld      DE,(BYT_SIZ)    ; load lenght
 959+ F93E ED 53 44 55              ld      (DKLNPT),DE     ; store it
 960+ F942 ED 5B E6 54              ld      DE,(RAM_PTR)    ; load address
 961+ F946 ED 53 42 55              ld      (DKNMPT),DE     ; store it
 962+ F94A CD F0 FC                 call    CLRDOSBF        ; clear DOS buffer
 963+ F94D 11 D0 FD                 ld      DE,DOSBFR       ; DE set to beginning of DOS buffer
 964+ F950 CD 46 FC                 call    CHKNMVAL        ; check and copy file name
 965+ F953 21 D0 FD                 ld      HL,DOSBFR       ; retrieve new name pointer
 966+ F956 DD E5                    push    IX              ; copy dest. address...
 967+ F958 D1                       pop     DE              ; ...into DE
 968+ F959 01 10 00                 ld      BC,$0010        ; 16 chars to copy
 969+ F95C ED B0                    ldir                    ; copy
 970+ F95E ED 5B EA 54              ld      DE,(TPBF2)      ; retrieve MSW of dir. sector
 971+ F962 ED 4B EC 54              ld      BC,(TPBF3)      ; retrieve LSW of dir. sector
 972+ F966 CD A7 FD                 call    CF_WR_SEC       ; write sector
 973+ F969 CD 74 FD                 call    CF_STANDBY      ; put CF in standby
 974+ F96C C9                       ret                     ; return to caller
 975+ F96D
 976+ F96D
 977+ F96D              ; *****************************************************************************
 978+ F96D              ; C H E C K    F I L E    E X I S T A N C E
 979+ F96D              ; check if a file with the given name exists into dir
 980+ F96D              ; Carry set if duplicate
 981+ F96D              ; *****************************************************************************
 982+ F96D CD DB FC     CHKFLEXT:   call    CLRIOBF         ; clear I/O
 983+ F970 CD 0E FC                 call    CHKDSKVAL       ; check DOS version & load disk details
 984+ F973 DA 74 F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
 985+ F976 CD B3 FB                 call    LDENTRIES       ; load entries into RAM register NTR_NBR
 986+ F979 CD 73 FC                 call    HL2DE           ; get start of directory into DE
 987+ F97C ED 53 D7 54              ld      (DIR_STRT),DE   ; store
 988+ F980 CD 73 FC                 call    HL2DE           ; get start of data area into DE
 989+ F983 ED 53 D9 54              ld      (DAT_STRT),DE   ; store
 990+ F987 C3 8D F9                 jp      LK4FILE1        ; check for name already present in dir and return to caller
 991+ F98A
 992+ F98A
 993+ F98A              ; *****************************************************************************
 994+ F98A              ; L O O K    F O R    A    F I L E
 995+ F98A              ; look for the given file into the dir
 996+ F98A              ; Carry is reset if not found, set otherwise
 997+ F98A              ; *****************************************************************************
 998+ F98A CD B3 FB     LK4FILE:    call    LDENTRIES       ; load entries into RAM register NTR_NBR
 999+ F98D CD DB FC     LK4FILE1:   call    CLRIOBF         ; clear IO buffer
1000+ F990 CD F0 FC                 call    CLRDOSBF        ; clear DOS buffer
1001+ F993 11 D0 FD                 ld      DE,DOSBFR       ; DE set to beginning of DOS buffer
1002+ F996 CD 46 FC                 call    CHKNMVAL        ; check and copy file name
1003+ F999 DA 68 F6                 jp      C,NAMERR        ; if Carry, file name error
1004+ F99C C3 C0 FA                 jp      FILE_EXIST      ; check if file exists and return to caller
1005+ F99F
1006+ F99F
1007+ F99F              ; *****************************************************************************
1008+ F99F              ; F I L E    L O A D
1009+ F99F              ; load a file from the disk into the memory
1010+ F99F              ; *****************************************************************************
1011+ F99F CD DB FC     LODFILE:    call    CLRIOBF         ; clear I/O
1012+ F9A2 CD 0E FC                 call    CHKDSKVAL       ; check DOS version & load disk details
1013+ F9A5 DA 74 F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
1014+ F9A8 CD 8A F9                 call    LK4FILE         ; look for given file
1015+ F9AB D2 6C F6                 jp      NC,FLNTFND      ; file not found - error
1016+ F9AE DD E5                    push    IX              ; copy pointer to file...
1017+ F9B0 E1                       pop     HL              ; ...into HL
1018+ F9B1 01 10 00                 ld      BC,$0010        ; skip file name (16 chars)...
1019+ F9B4 09                       add     HL,BC           ; ...by getting pointer to file details
1020+ F9B5 7E                       ld      A,(HL)          ; load file type
1021+ F9B6 FE 80                    cp      $80             ; 'BAS' type?
1022+ F9B8 28 0C                    jr      Z,LDFL4         ; yes, jump over
1023+ F9BA FE 81                    cp      $81             ; 'BIN' type?
1024+ F9BC C2 70 F6                 jp      NZ,LODERR       ; no, raise error
1025+ F9BF 3A EE 54                 ld      A,(TPBF4)       ; if BIN file, file must be loaded into its original position
1026+ F9C2 B7                       or      A               ; did the user set this?
1027+ F9C3 CA 70 F6                 jp      Z,LODERR        ; no, raise an error
1028+ F9C6 0E 04        LDFL4:      ld      C,$04           ; 4 steps forward and also 4 bytes to copy
1029+ F9C8 09                       add     HL,BC           ; point to starting sector
1030+ F9C9 11 E2 54                 ld      DE,MSW_SCT      ; point to store sector address of file
1031+ F9CC ED B0                    ldir                    ; copy MSW/LSW from entry into buffer
1032+ F9CE 11 DF 54                 ld      DE,BYT_SIZ      ; point to store size of file
1033+ F9D1 01 03 00                 ld      BC,$0003        ; 3 bytes to copy
1034+ F9D4 ED B0                    ldir                    ; copy size in bytes and sectors from entry into buffer
1035+ F9D6 11 86 55                 ld      DE,PROGND       ; load start of BASIC RAM
1036+ F9D9 3A EE 54                 ld      A,(TPBF4)       ; check where to save the data from
1037+ F9DC B7                       or      A               ; is it 0? (meaning from the current BASIC pointers)
1038+ F9DD 28 03                    jr      Z,LDFL1         ; yes, don't re-load the file from the address stored into the file
1039+ F9DF CD 73 FC                 call    HL2DE           ; no, load RAM address from disk
1040+ F9E2 ED 53 E6 54  LDFL1:      ld      (RAM_PTR),DE    ; store starting pointer
1041+ F9E6                          ; start loading from disk
1042+ F9E6 CD DB FC     LDFL2:      call    CLRIOBF         ; clear I/O buffer
1043+ F9E9 ED 5B E2 54              ld      DE,(MSW_SCT)    ; load MSW of sector
1044+ F9ED ED 4B E4 54              ld      BC,(LSW_SCT)    ; load LSW of sector
1045+ F9F1 CD 3E FD                 call    CF_SETSTR       ; set sector
1046+ F9F4 CD 80 FD                 call    CF_RD_SEC       ; read sector
1047+ F9F7 2A DF 54                 ld      HL,(BYT_SIZ)    ; load bytes left to be copied
1048+ F9FA 11 00 02                 ld      DE,$0200        ; are they < 512?
1049+ F9FD CD F9 40                 call    CMP16
1050+ FA00 30 04                    jr      NC,LDFL3        ; no, jump over
1051+ FA02 ED 5B DF 54              ld      DE,(BYT_SIZ)    ; yes, so load only remaining bytes
1052+ FA06 4B           LDFL3:      ld      C,E             ; move bytes to copy...
1053+ FA07 42                       ld      B,D             ; ...into BC
1054+ FA08 21 F0 FD                 ld      HL,IOBUFF       ; point to I/O buffer
1055+ FA0B ED 5B E6 54              ld      DE,(RAM_PTR)    ; point to RAM where to save
1056+ FA0F ED B0                    ldir                    ; copy data
1057+ FA11 21 E1 54                 ld      HL,SCT_SIZ      ; sector counter
1058+ FA14 35                       dec     (HL)            ; copied all the sectors?
1059+ FA15 CA 44 FA                 jp      Z,LDFLEX        ; yes, exit
1060+ FA18 2A E6 54                 ld      HL,(RAM_PTR)    ; pointer to RAM
1061+ FA1B 11 00 02                 ld      DE,$0200        ; block of 512 bytes copied
1062+ FA1E 19                       add     HL,DE           ; calculate next starting address
1063+ FA1F 22 E6 54                 ld      (RAM_PTR),HL    ; store next block
1064+ FA22 AF                       xor     A               ; reset Carry
1065+ FA23 2A DF 54                 ld      HL,(BYT_SIZ)    ; load left bytes
1066+ FA26 ED 52                    sbc     HL,DE           ; subtract copied bytes
1067+ FA28 22 DF 54                 ld      (BYT_SIZ),HL    ; store left bytes
1068+ FA2B ED 4B E4 54              ld      BC,(LSW_SCT)    ; load LSW of sector
1069+ FA2F 03                       inc     BC              ; next sector
1070+ FA30 78                       ld      A,B             ; BC=$0000?
1071+ FA31 B1                       or      C
1072+ FA32 20 09                    jr      NZ,LDFL5        ; no, jump over
1073+ FA34 ED 5B E2 54              ld      DE,(MSW_SCT)    ; load MSW of sector
1074+ FA38 13                       inc     DE              ; increment DE
1075+ FA39 ED 53 E2 54              ld      (MSW_SCT),DE    ; store new MSW of sector
1076+ FA3D ED 43 E4 54  LDFL5:      ld      (LSW_SCT),BC    ; store new LSW of sector
1077+ FA41 C3 E6 F9                 jp      LDFL2           ; repeat
1078+ FA44 CD 74 FD     LDFLEX:     call    CF_STANDBY      ; set CF into stand-by mode
1079+ FA47 AF                       xor     A               ; clear Carry flag
1080+ FA48 C9                       ret                     ; return to caller
1081+ FA49
1082+ FA49
1083+ FA49              ; *****************************************************************************
1084+ FA49              ; F I L E    E R A S E
1085+ FA49              ; erase a file from disk, freeing its block
1086+ FA49              ; *****************************************************************************
1087+ FA49 CD DB FC     FIL_ERASE:  call    CLRIOBF         ; clear I/O
1088+ FA4C CD 0E FC                 call    CHKDSKVAL       ; check DOS version & load disk details
1089+ FA4F DA 74 F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
1090+ FA52 CD 8A F9                 call    LK4FILE         ; look for given file
1091+ FA55 D2 6C F6                 jp      NC,FLNTFND      ; file not found - error
1092+ FA58 DD 5E 14                 ld      E,(IX+$14)      ; load MSW into DE
1093+ FA5B DD 56 15                 ld      D,(IX+$15)
1094+ FA5E DD 4E 16                 ld      C,(IX+$16)      ; load LSW into BC
1095+ FA61 DD 46 17                 ld      B,(IX+$17)
1096+ FA64 ED 53 E2 54              ld      (MSW_SCT),DE    ; store DE
1097+ FA68 ED 43 E4 54              ld      (LSW_SCT),BC    ; store BC
1098+ FA6C DD 7E 1A                 ld      A,(IX+$1A)      ; load size in sectors
1099+ FA6F 32 E1 54                 ld      (SCT_SIZ),A     ; store it
1100+ FA72 3E 7F                    ld      A,$7F           ; marker for file deleted
1101+ FA74 DD 77 00                 ld      (IX),A          ; set file as deleted (quick erase)
1102+ FA77 3A EE 54                 ld      A,(TPBF4)       ; check for quick or full delete
1103+ FA7A B7                       or      A               ; A=0 quick erase
1104+ FA7B 28 0A                    jr      Z,FIL_ERA5      ; jump if quick erase
1105+ FA7D AF                       xor     A               ; clear A
1106+ FA7E 06 20                    ld      B,$20           ; full erase - clean entry (32 cells)
1107+ FA80 DD 77 00     FIL_ERA6:   ld      (IX),A          ; reset cell
1108+ FA83 DD 23                    inc     IX              ; next cell
1109+ FA85 10 F9                    djnz    FIL_ERA6        ; repeat
1110+ FA87 ED 5B EA 54  FIL_ERA5:   ld      DE,(TPBF2)      ; retrieve MSW of current directory sector
1111+ FA8B ED 4B EC 54              ld      BC,(TPBF3)      ; retrieve LSW of current directory sector
1112+ FA8F CD A7 FD                 call    CF_WR_SEC       ; write sector
1113+ FA92 38 27                    jr      C,WRT_ERR       ; error?
1114+ FA94 3A EE 54                 ld      A,(TPBF4)       ; check for quick or full delete
1115+ FA97 B7                       or      A               ; if A=0 then quick erase
1116+ FA98 28 1C                    jr      Z,FIL_ERA3      ; yes, leave
1117+ FA9A CD DB FC                 call    CLRIOBF         ; no, full delete - clear I/O buffer
1118+ FA9D ED 5B E2 54              ld      DE,(MSW_SCT)    ; load MSW of 1st sector of file block
1119+ FAA1 ED 4B E4 54              ld      BC,(LSW_SCT)    ; load LSW of 1st sector of file block
1120+ FAA5 21 E1 54                 ld      HL,SCT_SIZ      ; pointer to size in sectors
1121+ FAA8 CD A7 FD     FIL_ERA1:   call    CF_WR_SEC       ; erase sector
1122+ FAAB 38 0E                    jr      C,WRT_ERR       ; error?
1123+ FAAD 03                       inc     BC              ; next sector
1124+ FAAE 78                       ld      A,B             ; is LSW rolled back to 0?
1125+ FAAF B1                       or      C
1126+ FAB0 20 01                    jr      NZ,FIL_ERA2     ; no, jump over
1127+ FAB2 13                       inc     DE              ; yes, increment MSW
1128+ FAB3 35           FIL_ERA2:   dec     (HL)            ; decrement sector counter
1129+ FAB4 20 F2                    jr      NZ,FIL_ERA1     ; repeat if other sectors
1130+ FAB6 CD 74 FD     FIL_ERA3:   call    CF_STANDBY      ; set CF into stand-by mode
1131+ FAB9 AF                       xor     A               ; clear Carry
1132+ FABA C9                       ret
1133+ FABB CD 74 FD     WRT_ERR:    call    CF_STANDBY      ; put CF into stand-by
1134+ FABE 37                       scf                     ; set error
1135+ FABF C9                       ret                     ; return to caller
1136+ FAC0
1137+ FAC0
1138+ FAC0              ; *****************************************************************************
1139+ FAC0              ; F I L E    C H E C K
1140+ FAC0              ; check if file name already exists in directory
1141+ FAC0              ; file name must be stored from DOSBFR   for 16 chars
1142+ FAC0              ; *****************************************************************************
1143+ FAC0 FD 2A DD 54  FILE_EXIST: ld      IY,(NTR_NBR)    ; load max entries
1144+ FAC4 CD 7A FB                 call    SETPTEN         ; point to 1st sector of dir
1145+ FAC7 CD 82 FB     CHKSTNM1:   call    PT2FSEN         ; point to 1st entry of a dir's sect
1146+ FACA CD 8D FB     CHKSTNM2:   call    CKCREN          ; check current entry
1147+ FACD 28 28                    jr      Z,CHKSTNM10     ; if empty or deleted, jump over
1148+ FACF 22 E8 54                 ld      (TPBF1),HL      ; store HL
1149+ FAD2 ED 53 EA 54              ld      (TPBF2),DE      ; store DE
1150+ FAD6 ED 43 EC 54              ld      (TPBF3),BC      ; store BC
1151+ FADA DD E5                    push    IX              ; copy IX...
1152+ FADC E1                       pop     HL              ; ...into HL
1153+ FADD 11 D0 FD                 ld      DE,DOSBFR       ; beginning of name file
1154+ FAE0 06 10                    ld      B,$10           ; 16 chars to check
1155+ FAE2 1A           CHKSTNM3:   ld      A,(DE)          ; load a char from name on disk
1156+ FAE3 ED A1                    cpi                     ; compare with name from user
1157+ FAE5 20 05                    jr      NZ,CHKSTNM6     ; chars are different, leave
1158+ FAE7 13                       inc     DE              ; inc DE (HL is incremented by "cpi")
1159+ FAE8 10 F8                    djnz    CHKSTNM3        ; repeat for 16 chars
1160+ FAEA 18 17                    jr      FLEXST          ; file exists in dir
1161+ FAEC 2A E8 54     CHKSTNM6:   ld      HL,(TPBF1)      ; retrieve HL
1162+ FAEF ED 5B EA 54              ld      DE,(TPBF2)      ; retrieve DE
1163+ FAF3 ED 4B EC 54              ld      BC,(TPBF3)      ; retrieve sector counter
1164+ FAF7 CD 95 FB     CHKSTNM10:  call    GTNXTEN         ; other entries in this sector?
1165+ FAFA 20 CE                    jr      NZ,CHKSTNM2     ; yes, continue check
1166+ FAFC CD A1 FB     CHKSTNM5:   call    CKLSTEN         ; go to next sector
1167+ FAFF 30 C6                    jr      NC,CHKSTNM1     ; more entries? repeat
1168+ FB01 AF           FLNTEXS:    xor     A               ; file not found, reset Carry
1169+ FB02 C9                       ret                     ; return
1170+ FB03 37           FLEXST:     scf                     ; file is present - set Carry flag for error
1171+ FB04 C9                       ret
1172+ FB05
1173+ FB05
1174+ FB05              ; *****************************************************************************
1175+ FB05              ; UNDELETE DELETED FILES
1176+ FB05              ; look for deleted files and undelete them
1177+ FB05              ; *****************************************************************************
1178+ FB05 CD DB FC     DSKUNDFL:   call    CLRIOBF         ; clear I/O
1179+ FB08 CD 0E FC                 call    CHKDSKVAL       ; check DOS version & load disk details
1180+ FB0B DA 74 F6                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
1181+ FB0E CD 52 FB                 call    FNDFRENTR       ; find a free entry
1182+ FB11 D8           DSKUNDFL1:  ret     C               ; return if entries are finished
1183+ FB12 DD 7E 00                 ld      A,(IX)          ; reload first char of entry
1184+ FB15 FE 7F                    cp      $7F             ; is it a deleted entry?
1185+ FB17 20 29                    jr      NZ,DSKUNDFL2    ; no, jump over
1186+ FB19 CD E5 FB                 call    RND8            ; get a random char
1187+ FB1C CD 03 FC                 call    CHATOZ          ; transform it into a letter
1188+ FB1F DD 77 00                 ld      (IX),A          ; store it as the first letter of filename
1189+ FB22 CD A7 FD                 call    CF_WR_SEC       ; write sector (address is into DEBC)
1190+ FB25 E5                       push    HL              ; store HL
1191+ FB26 C5                       push    BC              ; store BC
1192+ FB27 D5                       push    DE              ; store DE
1193+ FB28 DD E5                    push    IX              ; copy IX...
1194+ FB2A E1                       pop     HL              ; ...into HL
1195+ FB2B 06 10                    ld      B,$10           ; 16 chars
1196+ FB2D 7E           DSKUNDPR:   ld      A,(HL)          ; retrieve char from filename
1197+ FB2E CD DD 1A                 call    OUTC            ; print char
1198+ FB31 23                       inc     HL              ; next char
1199+ FB32 10 F9                    djnz    DSKUNDPR        ; repeat
1200+ FB34 3E 20                    ld      A,SPC           ; print a space
1201+ FB36 CD DD 1A                 call    OUTC
1202+ FB39 21 47 FB                 ld      HL,DSKUNDTXT    ; print undeleted message
1203+ FB3C CD B4 26                 call    PRS
1204+ FB3F D1                       pop     DE              ; retrieve DE
1205+ FB40 C1                       pop     BC              ; retrieve BC
1206+ FB41 E1                       pop     HL              ; retrieve HL
1207+ FB42 CD 66 FB     DSKUNDFL2:  call    FNDFRENTR4      ; goto next entry
1208+ FB45 18 CA                    jr      DSKUNDFL1       ; repeat
1209+ FB47 75 6E 64 65  DSKUNDTXT:  defb    "undeleted",CR,0
1209+ FB4B 6C 65 74 65
1209+ FB4F 64 0D 00
1210+ FB52
1211+ FB52
1212+ FB52              ; *****************************************************************************
1213+ FB52              ; FIND A FREE ENTRY
1214+ FB52              ; find a free entry in the directory to store a new file
1215+ FB52              ; *****************************************************************************
1216+ FB52 CD C2 FB     FNDFRENTR:  call    LDMSCT          ; read Master Sector
1217+ FB55 CD B3 FB                 call    LDENTRIES       ; load entries into RAM register NTR_NBR and DE
1218+ FB58 D5                       push    DE              ; copy number of entries...
1219+ FB59 FD E1                    pop     IY              ; ...into IY
1220+ FB5B CD 7A FB                 call    SETPTEN         ; point to first entry
1221+ FB5E CD 82 FB     FNDFRENTR1: call    PT2FSEN         ; point to 1st entry of sector
1222+ FB61 CD 8D FB     FNDFRENTR2: call    CKCREN          ; check current entry
1223+ FB64 28 0B                    jr      Z,FNDFRENTR3    ; found a free entry
1224+ FB66 CD 95 FB     FNDFRENTR4: call    GTNXTEN         ; other entries in this sector?
1225+ FB69 20 F6                    jr      NZ,FNDFRENTR2   ; yes, continue check
1226+ FB6B CD A1 FB                 call    CKLSTEN         ; go to next sector
1227+ FB6E 30 EE                    jr      NC,FNDFRENTR1   ; more entries? repeat
1228+ FB70 C9                       ret                     ; entries finished - leave
1229+ FB71 ED 43 DB 54  FNDFRENTR3: ld      (DIR_SCT),BC    ; store sector of dir
1230+ FB75 22 DD 54                 ld      (NTR_NBR),HL    ; store entry number
1231+ FB78 AF                       xor     A               ; reset Carry
1232+ FB79 C9                       ret
1233+ FB7A
1234+ FB7A
1235+ FB7A              ; *****************************************************************************
1236+ FB7A              ;   U T I L I T I E S
1237+ FB7A              ; *****************************************************************************
1238+ FB7A
1239+ FB7A              ; set up registers to point to first sector of directory
1240+ FB7A 01 01 00     SETPTEN:    ld      BC,$0001        ; BC=$0001 (starting sector of dir) (LSW)
1241+ FB7D 50                       ld      D,B             ; DE=$0000 (starting sector of dir) (MSW)
1242+ FB7E 58                       ld      E,B
1243+ FB7F 60                       ld      H,B             ; HL=$0000 (entry counter)
1244+ FB80 68                       ld      L,B
1245+ FB81 C9                       ret                     ; return to caller
1246+ FB82
1247+ FB82
1248+ FB82              ; load a sector and point to first entry
1249+ FB82 CD 3E FD     PT2FSEN:    call    CF_SETSTR       ; set sector to read (BC-DE)
1250+ FB85 CD 80 FD                 call    CF_RD_SEC       ; read sector
1251+ FB88 DD 21 F0 FD              ld      IX,IOBUFF       ; beginning of I/O buffer
1252+ FB8C C9                       ret
1253+ FB8D
1254+ FB8D
1255+ FB8D              ; check current entry
1256+ FB8D DD 7E 00     CKCREN:     ld      A,(IX)          ; load 1st char of entry name
1257+ FB90                          ;dec     IY              ; decrement number of entries
1258+ FB90 B7                       or      A               ; is it $00 (empty entry)?
1259+ FB91 C8                       ret     Z               ; yes, found an entry
1260+ FB92 FE 7F                    cp      $7F             ; is it $7F (deleted entry)?
1261+ FB94 C9                       ret
1262+ FB95
1263+ FB95              ; goto next entry
1264+ FB95 C5           GTNXTEN:    push    BC              ; store BC
1265+ FB96 01 20 00                 ld      BC,$0020        ; load BC with directory entry size (32 bytes)
1266+ FB99 DD 09                    add     IX,BC           ; next entry in current sector
1267+ FB9B C1                       pop     BC              ; retrieve sector pointer
1268+ FB9C 23                       inc     HL              ; increment entry counter
1269+ FB9D 7D                       ld      A,L
1270+ FB9E E6 0F                    and     %00001111       ; just done 16 entries?
1271+ FBA0 C9                       ret
1272+ FBA1
1273+ FBA1
1274+ FBA1              ; check if reached last entry
1275+ FBA1              ; Carry is set if entries finished
1276+ FBA1 03           CKLSTEN:    inc     BC              ; entries in this sector finished .. goto next sector
1277+ FBA2 78                       ld      A,B             ; check if...
1278+ FBA3 B1                       or      C               ; ...BC=$000
1279+ FBA4 20 01                    jr      NZ,CKLSTEN1     ; no, jump over
1280+ FBA6 13                       inc     DE              ; yes, increment DE (MSW)
1281+ FBA7 E5           CKLSTEN1:   push    HL              ; preserve current entry
1282+ FBA8 D5                       push    DE
1283+ FBA9 FD E5                    push    IY              ; copy max allowed files...
1284+ FBAB D1                       pop     DE              ; ...into HL
1285+ FBAC CD F9 40                 call    CMP16           ; check if reached max allowed entries
1286+ FBAF D1                       pop     DE
1287+ FBB0 E1                       pop     HL              ; (retrieve current entry)
1288+ FBB1 3F                       ccf
1289+ FBB2 C9                       ret                     ; return
1290+ FBB3
1291+ FBB3
1292+ FBB3              ; load entries intro RAM register
1293+ FBB3 21 F0 FD     LDENTRIES:  ld      HL,IOBUFF       ; start of I/O buffer
1294+ FBB6 01 19 00                 ld      BC,$0019        ; point to max. allowed entries
1295+ FBB9 09                       add     HL,BC           ; get address
1296+ FBBA CD 73 FC                 call    HL2DE           ; get entries into DE
1297+ FBBD ED 53 DD 54              ld      (NTR_NBR),DE    ; store
1298+ FBC1 C9                       ret                     ; return to caller
1299+ FBC2
1300+ FBC2
1301+ FBC2              ; load Master Sector (sector #0)
1302+ FBC2 01 00 00     LDMSCT:     ld      BC,$0000        ; LSW of sector
1303+ FBC5 50           LDMSCT1:    ld      D,B             ; MSW of sector
1304+ FBC6 58                       ld      E,B
1305+ FBC7 CD 3E FD                 call    CF_SETSTR       ; set sector
1306+ FBCA CD 80 FD                 call    CF_RD_SEC       ; read sector
1307+ FBCD C9                       ret
1308+ FBCE
1309+ FBCE
1310+ FBCE              ; generate random disk ID
1311+ FBCE C5           RND_ID:     push    BC
1312+ FBCF 06 02                    ld      B,$02           ; repeat 2 times
1313+ FBD1 CD E5 FB     RND_ID1:    call    RND8            ; get a random value
1314+ FBD4 CD 03 FC                 call    CHATOZ          ; transform it into a letter
1315+ FBD7 12                       ld      (DE),A          ; store it
1316+ FBD8 13                       inc     DE              ; inc pointer
1317+ FBD9 CD E5 FB                 call    RND8            ; get a random value
1318+ FBDC CD F8 FB                 call    CH0TO9          ; transform it into a number from 0 to 9
1319+ FBDF 12                       ld      (DE),A          ; store it
1320+ FBE0 13                       inc     DE              ; inc pointer
1321+ FBE1 10 EE                    djnz    RND_ID1         ; repeat
1322+ FBE3 C1                       pop     BC
1323+ FBE4 C9                       ret                     ; return to caller
1324+ FBE5
1325+ FBE5
1326+ FBE5              ; generate a pseudo-random number using TMR and R registers
1327+ FBE5 C5           RND8:       push    BC
1328+ FBE6 3A 20 55                 ld      A,(TMRCNT)      ; load LSW of sys-timer
1329+ FBE9 47                       ld      B,A             ; copy into B
1330+ FBEA ED 5F                    ld      A,R             ; load refresh register
1331+ FBEC A8                       xor     B               ; A xor B
1332+ FBED 47                       ld      B,A             ; copy into B
1333+ FBEE 0F                       rrca                    ; multiply by 32
1334+ FBEF 0F                       rrca
1335+ FBF0 0F                       rrca
1336+ FBF1 EE 1F                    xor     $1F
1337+ FBF3 80                       add     A,B
1338+ FBF4 DE FF                    sbc     A,255           ; carry
1339+ FBF6 C1                       pop     BC
1340+ FBF7 C9                       ret                     ; return to caller
1341+ FBF8
1342+ FBF8
1343+ FBF8              ; char ported into 0-9 interval
1344+ FBF8 E6 0F        CH0TO9:     and     %00001111       ; get only low nibble
1345+ FBFA FE 0A                    cp      $0A             ; is it < 10?
1346+ FBFC 38 02                    jr      C,CH0TO9E       ; yes, jump over
1347+ FBFE D6 0A                    sub     $0A             ; subract 10
1348+ FC00 C6 30        CH0TO9E:    add     $30             ; get a number from 0 to 9
1349+ FC02 C9                       ret
1350+ FC03
1351+ FC03
1352+ FC03              ; char ported into A-Z interval
1353+ FC03 E6 1F        CHATOZ:     and     %00011111       ; get only first 5 bits
1354+ FC05 FE 1A                    cp      $1A             ; is it < 26?
1355+ FC07 38 02                    jr      C,CHATOZE       ; yes, jump over
1356+ FC09 D6 1A                    sub     $1A             ; no, subtract 26
1357+ FC0B C6 41        CHATOZE:    add     $41             ; get a letter from 'A' to 'Z'
1358+ FC0D C9                       ret                     ; return to caller
1359+ FC0E
1360+ FC0E
1361+ FC0E              ; first check DOS validity then load disk details
1362+ FC0E CD FC FC     CHKDSKVAL:  call    CF_INIT         ; open CF card comm.
1363+ FC11 D8                       ret     C               ; if errors, leave
1364+ FC12 C5                       push    BC              ; store BC
1365+ FC13 D5                       push    DE              ; store DE
1366+ FC14 E5                       push    HL              ; store HL
1367+ FC15 01 00 00                 ld      BC,$0000        ; reset LSW of sector
1368+ FC18 50                       ld      D,B             ; reset MSW of sector
1369+ FC19 58                       ld      E,B
1370+ FC1A CD 3E FD                 call    CF_SETSTR       ; set sector #0
1371+ FC1D CD 80 FD                 call    CF_RD_SEC       ; read sector
1372+ FC20 21 F0 FD                 ld      HL,IOBUFF       ; address of default conf. buffer
1373+ FC23 11 0A 00                 ld      DE,$000A        ; point to disk DOS version
1374+ FC26 19                       add     HL,DE
1375+ FC27 11 8A F1                 ld      DE,DSKHDR+10    ; get starting address of I/O buffer
1376+ FC2A 06 04                    ld      B,$04           ; 4 chars
1377+ FC2C 1A           CHKDSKVAL1: ld      A,(DE)          ; load char from DOS version into memory
1378+ FC2D BE                       cp      (HL)            ; compare with disk DOS version
1379+ FC2E 20 11                    jr      NZ,CHKDSKVALE   ; no match - so error
1380+ FC30 13                       inc     DE              ; next source
1381+ FC31 23                       inc     HL              ; next comparison
1382+ FC32 10 F8                    djnz    CHKDSKVAL1      ; repeat
1383+ FC34 21 D0 FD                 ld      HL,DOSBFR       ; address of default conf. buffer
1384+ FC37 11 1D 00                 ld      DE,$001D        ; point to address of data area
1385+ FC3A 19                       add     HL,DE           ; set pointer to beginning of identifies
1386+ FC3B CD 73 FC                 call    HL2DE           ; first sector of data area into DE
1387+ FC3E AF                       xor     A               ; no error - clear Carry flag
1388+ FC3F 18 01                    jr      CHKDSKVAL2      ; jump over
1389+ FC41 37           CHKDSKVALE: scf                     ; error - set carry flag
1390+ FC42 E1           CHKDSKVAL2: pop     HL
1391+ FC43 D1                       pop     DE
1392+ FC44 C1                       pop     BC
1393+ FC45 C9                       ret                     ; return to caller
1394+ FC46
1395+ FC46
1396+ FC46              ; check name validity (only allowed chars) and copy it from string pool into a temp buff
1397+ FC46              ; Inputs: DE: pointer to dest. buffer
1398+ FC46              ; operation: copy (HL)->(DE) and pads to get a 16-chars name
1399+ FC46              ; destroys: A, BC, DE, HL
1400+ FC46 ED 4B 44 55  CHKNMVAL:   ld      BC,(DKLNPT)     ; load lenght of name
1401+ FC4A 79                       ld      A,C             ; lenght is max. 16 char, so we only check C
1402+ FC4B FE 11                    cp      $11             ; is it <=16?
1403+ FC4D 38 02                    jr      C,CHKNMVAL1     ; yes, so jump over
1404+ FC4F 0E 10                    ld      C,$10           ; no, get only 16 chars
1405+ FC51 41           CHKNMVAL1:  ld      B,C             ; copy lenght into B
1406+ FC52 0E 10                    ld      C,$10           ; char counter
1407+ FC54 2A 42 55                 ld      HL,(DKNMPT)     ; pointer to name
1408+ FC57 7E           CHKNMVAL2:  ld      A,(HL)          ; get a char from string name
1409+ FC58 CD C5 FC                 call    CHK_NAM         ; check if valid
1410+ FC5B D8                       ret     C               ; no, name error
1411+ FC5C 12                       ld      (DE),A          ; yes, store char
1412+ FC5D 13                       inc     DE              ; next I/O location
1413+ FC5E 23                       inc     HL              ; next name char
1414+ FC5F 0D                       dec     C               ; decrement number of chars copied
1415+ FC60 10 F5                    djnz    CHKNMVAL2       ; repeat until name ends
1416+ FC62 79                       ld      A,C             ; check if there are no empty chars in file
1417+ FC63 B7                       or      A
1418+ FC64 C8                       ret     Z               ; yes, job finished - return
1419+ FC65 3E 20                    ld      A,SPC           ; no, padding required
1420+ FC67 12           CHKNMVAL3:  ld      (DE),A          ; store char
1421+ FC68 13                       inc     DE              ; next location
1422+ FC69 0D                       dec     C               ; check if padding is over
1423+ FC6A 20 FB                    jr      NZ,CHKNMVAL3    ; no, continue
1424+ FC6C AF                       xor     A               ; clear Carry flag
1425+ FC6D C9                       ret                     ; return to caller
1426+ FC6E
1427+ FC6E
1428+ FC6E              ; store DE into (HL) and (HL+1)
1429+ FC6E 73           DE2HL:      ld      (HL),E          ; LSW of size
1430+ FC6F 23                       inc     HL
1431+ FC70 72                       ld      (HL),D          ; MSW of size
1432+ FC71 23                       inc     HL
1433+ FC72 C9                       ret                     ; return to caller
1434+ FC73
1435+ FC73
1436+ FC73              ; get DE from (HL) and (HL+1)
1437+ FC73 5E           HL2DE:      ld      E,(HL)          ; get LSW into E
1438+ FC74 23                       inc     HL              ; next location
1439+ FC75 56                       ld      D,(HL)          ; get MSW into D
1440+ FC76 23                       inc     HL              ; next location
1441+ FC77 C9                       ret                     ; return to caller
1442+ FC78
1443+ FC78
1444+ FC78              ; convert a 16/32-bit number into an ASCII string and print it
1445+ FC78              ; inputs: HL pointer to 32-bit number
1446+ FC78 CD 73 FC     PRN32ASCII: call    HL2DE           ; load MSW into DE  <-- entry for 32-bit
1447+ FC7B 4E           PRN16ASCII: ld      C,(HL)          ; load LSW into BC   <-- entry for 16-bit (set DE to $0000 before to call)
1448+ FC7C 23                       inc     HL
1449+ FC7D 46                       ld      B,(HL)
1450+ FC7E C5                       push    BC              ; copy BC...
1451+ FC7F DD E1                    pop     IX              ; ...into IX
1452+ FC81 FD 21 E8 54  PRN16ASCIX: ld      IY,TPBF1        ; number is into DEIX - now, load pointer to destination buffer
1453+ FC85 CD C2 41                 call    CLCN32          ; convert number in DEIX into ASCII number
1454+ FC88 21 E8 54                 ld      HL,TPBF1        ; address of ASCII number
1455+ FC8B 7E           PRNTSIZ:    ld      A,(HL)          ; get a char
1456+ FC8C B7                       or      A               ; is it $00 (end of string)?
1457+ FC8D C8                       ret     Z               ; yes, leave
1458+ FC8E CD DD 1A                 call    OUTC            ; no, print char
1459+ FC91 23                       inc     HL              ; next char
1460+ FC92 18 F7                    jr      PRNTSIZ         ; repeat
1461+ FC94
1462+ FC94
1463+ FC94              ; convert one or more bytes into memory in hex format
1464+ FC94              ; HL: pointer to number in memory - B: number of bytes to convert
1465+ FC94              ; destroys: A, D, HL
1466+ FC94 50           PRN_HEX:    ld      D,B             ; move bytes into D
1467+ FC95 7E           PRN_HEX1:   ld      A,(HL)          ; load value
1468+ FC96 CD B5 FC                 call    BYTEHEX         ; print hex number
1469+ FC99 23                       inc     HL              ; next location
1470+ FC9A 15                       dec     D               ; decrement bytes to convert
1471+ FC9B 20 F8                    jr      NZ,PRN_HEX1     ; repeat
1472+ FC9D C9                       ret                     ; return to caller
1473+ FC9E
1474+ FC9E
1475+ FC9E              ; convert one or more words into memory in hex format
1476+ FC9E              ; IX: pointer to number in memory - B: number of words to convert
1477+ FC9E              ; destroys: AF, IX
1478+ FC9E D5           PRN_WHEX:   push    DE              ; store DE
1479+ FC9F 50                       ld      D,B             ; load iterations into D
1480+ FCA0 DD 7E 01     PRN_WHEX1:  ld      A,(IX+1)        ; load MSW into A
1481+ FCA3 CD B5 FC                 call    BYTEHEX         ; print hex number
1482+ FCA6 DD 7E 00                 ld      A,(IX)          ; load LSW into A
1483+ FCA9 CD B5 FC                 call    BYTEHEX         ; print hex number
1484+ FCAC DD 23                    inc     IX              ; next word
1485+ FCAE DD 23                    inc     IX
1486+ FCB0 15                       dec     D               ; decrement words to convert
1487+ FCB1 20 ED                    jr      NZ,PRN_WHEX1    ; repeat
1488+ FCB3 D1                       pop     DE              ; retrieve DE
1489+ FCB4 C9                       ret                     ; return to caller
1490+ FCB5
1491+ FCB5
1492+ FCB5              ; print A in hex format
1493+ FCB5 C5           BYTEHEX:    push    BC              ; store BC
1494+ FCB6 D5                       push    DE              ; store DE
1495+ FCB7 CD 0E 40                 call    BYT2ASC         ; convert to HEX and get back into BC
1496+ FCBA 78                       ld      A,B             ; print left nibble
1497+ FCBB CD DD 1A                 call    OUTC
1498+ FCBE 79                       ld      A,C             ; print right nibble
1499+ FCBF CD DD 1A                 call    OUTC
1500+ FCC2 D1                       pop     DE              ; retrieve DE
1501+ FCC3 C1                       pop     BC              ; retrieve BC
1502+ FCC4 C9                       ret                     ; return to caller
1503+ FCC5
1504+ FCC5
1505+ FCC5              ; check for non-allowed chars in disk/file names - allowed chars: '0'-'9', 'A'-'Z', '-', SPACE
1506+ FCC5              ; input: A -> char to check
1507+ FCC5              ; return: C is set if ERROR, reset otherwise
1508+ FCC5 FE 20        CHK_NAM:    cp      SPC             ; is it a space?
1509+ FCC7 C8                       ret     Z               ; return if equal (C is reset)
1510+ FCC8 FE 2D                    cp      '-'             ; is it a minus?
1511+ FCCA C8                       ret     Z               ; return if equal
1512+ FCCB FE 30                    cp      '0'             ; char < '0' ?
1513+ FCCD D8                       ret     C               ; yes, disk name error
1514+ FCCE FE 3A                    cp      ':'             ; is char <= '9' ?
1515+ FCD0 38 07                    jr      C,CHK_C_CF      ; yes, leave
1516+ FCD2 E6 5F                    and     %01011111       ; for letters, only UPPER CASE
1517+ FCD4 FE 41                    cp      'A'             ; is char >= 'A' ?
1518+ FCD6 D8                       ret     C               ; no, error
1519+ FCD7 FE 5B                    cp      '['             ; is char <= 'Z' ? (if yes, C=1, then C=0; otherwise, C=0 then C=1)
1520+ FCD9 3F           CHK_C_CF:   ccf                     ; Carry complement (invert Carry)
1521+ FCDA C9           CHK_NAM_LV: ret                     ; return to caller
1522+ FCDB
1523+ FCDB
1524+ FCDB              ; clear I/O buffer
1525+ FCDB F5           CLRIOBF:    push    AF              ; store AF
1526+ FCDC C5                       push    BC              ; store BC
1527+ FCDD E5                       push    HL              ; store HL
1528+ FCDE 21 F0 FD                 ld 	    HL,IOBUFF       ; load address of last BASIC location
1529+ FCE1 01 02 00                 ld      BC,$0002        ; B=256 iterations ($00); C=repeat 2 times
1530+ FCE4 AF           CLRBUFF:    xor     A               ; reset A   ----- common part -----
1531+ FCE5 77           RSTIOBF:    ld      (HL),A          ; reset cell
1532+ FCE6 23                       inc     HL              ; next cell
1533+ FCE7 10 FC                    djnz    RSTIOBF         ; repeat for 256 times
1534+ FCE9 0D                       dec     C               ; decrement C
1535+ FCEA 20 F9                    jr      NZ,RSTIOBF      ; repeat if not zero
1536+ FCEC E1                       pop     HL              ; retrieve HL
1537+ FCED C1                       pop     BC              ; retrieve BC
1538+ FCEE F1                       pop     AF              ; retrieve AF
1539+ FCEF C9                       ret                     ; return to caller
1540+ FCF0
1541+ FCF0
1542+ FCF0              ; clear DOS buffer
1543+ FCF0 F5           CLRDOSBF:   push    AF              ; store AF
1544+ FCF1 C5                       push    BC              ; store BC
1545+ FCF2 E5                       push    HL              ; store HL
1546+ FCF3 21 D0 FD                 ld 	    HL,DOSBFR       ; load address of last BASIC location
1547+ FCF6 01 01 20                 ld      BC,$2001        ; B=32 iterations; C=repeat 1 time
1548+ FCF9 C3 E4 FC                 jp      CLRBUFF         ; continue to common part
# file closed: ../include/dos/dos-1.04.asm
  95  FCFC                  INCLUDE "../include/dos/bios-1.03.asm"
# file opened: ../include/dos/bios-1.03.asm
   1+ FCFC              ; ------------------------------------------------------------------------------
   2+ FCFC              ; LM80C 64K - BIOS ROUTINES - R1.03
   3+ FCFC              ; ------------------------------------------------------------------------------
   4+ FCFC              ; The following code is intended to be used with LM80C Z80-based computer
   5+ FCFC              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ FCFC              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ FCFC              ; kind of warranty: you can use them at your own risk.
   8+ FCFC              ; You are free to use them for any non-commercial use: you are only asked to
   9+ FCFC              ; maintain the copyright notices, include this advice and the note to the
  10+ FCFC              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ FCFC              ; redistribuite them.
  12+ FCFC              ; https://www.leonardomiliani.com
  13+ FCFC              ;
  14+ FCFC              ; Please support me by visiting the following links:
  15+ FCFC              ; Main project page: https://www.leonardomiliani.com
  16+ FCFC              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ FCFC              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ FCFC              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ FCFC              ; ------------------------------------------------------------------------------
  20+ FCFC              ;
  21+ FCFC              ; ------------------------------------------------------------------------------
  22+ FCFC              ; Code Revision:
  23+ FCFC              ; R1.0  - 20210307 - first release
  24+ FCFC              ; R1.01 - 20210310 - Code optimizing & better error handling
  25+ FCFC              ; R1.02 - 20210316 - disk speed improvements with INIR and OTIR
  26+ FCFC              ; R1.03 - 20210319 - code re-organization and new positioning into RAM
  27+ FCFC              ;
  28+ FCFC              ;------------------------------------------------------------------------------
  29+ FCFC
  30+ FCFC              ; equates for CF at port $50
  31+ FCFC              CF_DATA:        equ %01010000   ; ($50) Data register (R/W)
  32+ FCFC              CF_ERR:         equ %01010001   ; ($51) Error (R)
  33+ FCFC              CF_FTR:         equ %01010001   ; ($51) Features (W)
  34+ FCFC              CF_SECCNT:      equ %01010010   ; ($52) Sector count register (R/W)
  35+ FCFC              CF_LBA0:        equ %01010011   ; ($53) LBA register 0 (bits 0-7) (R/W)
  36+ FCFC              CF_LBA1:        equ %01010100   ; ($54) LBA register 1 (bits 8-15) (R/W)
  37+ FCFC              CF_LBA2:        equ %01010101   ; ($55) LBA register 2 (bits 16-23) (R/W)
  38+ FCFC              CF_LBA3:        equ %01010110   ; ($56) LBA register 3 (bits 24-27) (R/W) - bits 28-31 must be set to 111 in LBA mode
  39+ FCFC              CF_STAT:        equ %01010111   ; ($57) Status (R)
  40+ FCFC              CF_CMD:         equ %01010111   ; ($57) Command register (W)
  41+ FCFC
  42+ FCFC
  43+ FCFC              ;------------------------------------------------------------------------------
  44+ FCFC              ; R O U T I N E S
  45+ FCFC              ;------------------------------------------------------------------------------
  46+ FCFC
  47+ FCFC              BIOSSTART:  equ     $
  48+ FCFC              ; initilialize CF to work with, wakeing it up from standby and setting it to work in 8-bit mode
  49+ FCFC CD 12 FD     CF_INIT:    call    CF_NOP          ; execute a NOP to wake up the CF
  50+ FCFF CD 60 FD                 call    CR_DEV_RDY      ; wait for CF available and ready
  51+ FD02 D8                       ret     C               ; no card or I/O error, leave
  52+ FD03 3E 01                    ld      A,$01           ; 8-bit mode
  53+ FD05 D3 51                    out     (CF_FTR),A      ; set mode
  54+ FD07 CD 1B FD                 call    CF_BUSY         ; wait for CF being ready
  55+ FD0A 3E EF                    ld      A,$EF           ; command to set mode
  56+ FD0C D3 57                    out     (CF_CMD),A      ; execute command
  57+ FD0E CD 1B FD                 call    CF_BUSY         ; wait for CF being ready
  58+ FD11 C9                       ret                     ; return to caller
  59+ FD12
  60+ FD12
  61+ FD12              ; a NOP command, just used to wake up the CF card
  62+ FD12 3E 69        CF_NOP:     ld      A,$69           ; NOP command
  63+ FD14 D3 51                    out     (CF_FTR),A      ; send it
  64+ FD16 3E EF                    ld      A,$EF           ; set mode command
  65+ FD18 D3 57                    out     (CF_CMD),A      ; execute NOP
  66+ FD1A C9                       ret                     ; return to caller
  67+ FD1B
  68+ FD1B
  69+ FD1B              ; wait until BUSY bit is 0 (means CF has executed the requested job)
  70+ FD1B DB 57        CF_BUSY:    in      A,(CF_STAT)     ; read status register
  71+ FD1D 07                       rlca                    ; copy bit #7 into the Carry
  72+ FD1E DA 1B FD                 jp      C,CF_BUSY       ; loop while bit #7 is 1
  73+ FD21 C9                       ret                     ; bit #7 cleared - return to caller
  74+ FD22
  75+ FD22
  76+ FD22              ; check that CF is ready to get commands
  77+ FD22 DB 57        CF_CMDRDY:  in      A,(CF_STAT)     ; read status register
  78+ FD24 CB 47                    bit     0,A             ; any error?
  79+ FD26 20 07                    jr      NZ,RETERR       ; yes, return error
  80+ FD28 E6 C0                    and     %11000000       ; check only bits #6 & #7
  81+ FD2A EE 40                    xor     %01000000       ; bit #7 (BUSY) must be 0 and bit #6 (DRVRDY) must be 1
  82+ FD2C 20 F4                    jr      NZ,CF_CMDRDY    ; wait
  83+ FD2E C9                       ret                     ; return to caller
  84+ FD2F 37           RETERR:     scf                     ; set carry flag
  85+ FD30 C9                       ret                     ; return
  86+ FD31
  87+ FD31
  88+ FD31              ; wait until data is ready to be read
  89+ FD31 DB 57        CF_DAT_RDY: in      A,(CF_STAT)     ; read status register
  90+ FD33 CB 47                    bit     0,A             ; any error?
  91+ FD35 20 F8                    jr      NZ,RETERR       ; yes, return error
  92+ FD37 E6 88                    and     %10001000       ; check only bits #7 & #3
  93+ FD39 EE 08                    xor     %00001000       ; bit #7 (BUSY) must be 0 and bit #3 (DRQ) must be 1
  94+ FD3B 20 F4                    jr      NZ,CF_DAT_RDY   ; wait until data is ready
  95+ FD3D C9                       ret                     ; return to caller
  96+ FD3E
  97+ FD3E
  98+ FD3E              ; set sector to read from/write to - sector number is into DEBC (C=LSB, D=MSB)
  99+ FD3E CD 22 FD     CF_SETSTR:  call    CF_CMDRDY       ; Make sure drive is ready for command
 100+ FD41 3E 01                    ld      A,$01           ; 1 sector at a time
 101+ FD43 D3 52                    out     (CF_SECCNT),A   ; set number of sectors
 102+ FD45 CD 22 FD                 call    CF_CMDRDY       ; Make sure drive is ready for command
 103+ FD48 79                       ld      A,C             ; load LBA0 byte
 104+ FD49 D3 53                    out     (CF_LBA0),A     ; send it
 105+ FD4B CD 22 FD                 call    CF_CMDRDY       ; Make sure drive is ready for command
 106+ FD4E 78                       ld      A,B             ; load LBA1 byte
 107+ FD4F D3 54                    out     (CF_LBA1),A     ; send it
 108+ FD51 CD 22 FD                 call    CF_CMDRDY       ; Make sure drive is ready for command
 109+ FD54 7B                       ld      A,E             ; load LBA2 byte
 110+ FD55 D3 55                    out     (CF_LBA2),A     ; send it
 111+ FD57 CD 22 FD                 call    CF_CMDRDY       ; Make sure drive is ready for command
 112+ FD5A 3E E0                    ld      A,$E0           ; load LBA3 byte+master+LBA addressing
 113+ FD5C B2                       or      D               ; add LBA sector
 114+ FD5D D3 56                    out     (CF_LBA3),A     ; send it
 115+ FD5F C9                       ret                     ; return to caller
 116+ FD60
 117+ FD60
 118+ FD60              ; check if device is available & ready - try a bit of times, then exit with
 119+ FD60              ; error if no response, otherwise wait until device is ready
 120+ FD60              ; return Carry = 0 if device is available and ready, Carry = 1 if errors
 121+ FD60 C5           CR_DEV_RDY: push    BC              ; store HL
 122+ FD61 06 00                    ld      B,$00           ; 256 tries
 123+ FD63 0E 57                    ld      C,CF_STAT       ; address of status register
 124+ FD65 ED 78        CR_DV_RD_1: in      A,(C)           ; load status register (curiously, with no CF attached, in(CF_STAT) returns %01111000)
 125+ FD67 FE 40                    cp      %01000000       ; busy=0, rdy=1
 126+ FD69 28 07                    jr      Z,CR_DV_RD_E    ; got a response, so leave
 127+ FD6B FE 50                    cp      %01010000       ; busy=0, rdy=1, dsc=1
 128+ FD6D 28 03                    jr      Z,CR_DV_RD_E    ; got a response, so leave
 129+ FD6F 10 F4                    djnz    CR_DV_RD_1      ; repeat until timeout (Carry=1 while HL<DE)
 130+ FD71 37           CR_DV_ERR:  scf                     ; exit with Carry = 1 (device NOT ready)
 131+ FD72 C1           CR_DV_RD_E: pop     BC              ; retrieve HL
 132+ FD73 C9                       ret                     ; return to caller
 133+ FD74
 134+ FD74
 135+ FD74              ; put the CF into stand-by mode
 136+ FD74 3E E0        CF_STANDBY: ld 	    A,$E0   		; select CF as master, driver 0, LBA mode (bits #5-7=111)
 137+ FD76 D3 56                    out 	(CF_LBA3),A     ; send configuration
 138+ FD78 3E 92                    ld      A,$92           ; standby mode
 139+ FD7A D3 57                    out     (CF_CMD),A      ; send command
 140+ FD7C CD 1B FD                 call    CF_BUSY         ; wait for CF being ready
 141+ FD7F C9                       ret                     ; return to caller
 142+ FD80
 143+ FD80
 144+ FD80              ;***************************************************************************
 145+ FD80              ; CF_RD_SEC
 146+ FD80              ; Function: load a sector (512 bytes) into RAM buffer.
 147+ FD80              ;***************************************************************************
 148+ FD80 CD 22 FD     CF_RD_SEC:  call    CF_CMDRDY       ; Make sure drive is ready for command
 149+ FD83 D8                       ret     C               ; return if error
 150+ FD84 3E 20                    ld      A,$20           ; Prepare read command
 151+ FD86 D3 57                    out     (CF_CMD),A      ; Send read command
 152+ FD88 CD 31 FD                 call    CF_DAT_RDY      ; Wait until data is ready to be read
 153+ FD8B D8                       ret     C               ; return if error
 154+ FD8C DB 57                    in      A,(CF_STAT)     ; Read status
 155+ FD8E E6 01                    and     %00000001       ; mask off error bit
 156+ FD90 C2 80 FD                 jp      NZ,CF_RD_SEC    ; Try again if error
 157+ FD93              ; read CF buffer after it's been filled up by a previous command
 158+ FD93              ; and store data into the I/O buffer
 159+ FD93 C5           CF_RD_CMD:  push    BC              ; store BC
 160+ FD94 E5                       push    HL              ; store HL
 161+ FD95 CD 31 FD                 call    CF_DAT_RDY	    ; wait for data from CF to be ready
 162+ FD98 38 0A                    jr      C,CF_RD_EXIT    ; if error, leave
 163+ FD9A 01 50 00                 ld      BC,CF_DATA      ; set 256 bytes per loop (B=$00) and CF port (C=CF_DATA)
 164+ FD9D 21 F0 FD                 ld      HL,IOBUFF       ; get starting address of I/O buffer
 165+ FDA0 ED B2                    inir                    ; get 256 bytes
 166+ FDA2 ED B2                    inir                    ; get 256 bytes
 167+ FDA4 E1           CF_RD_EXIT: pop     HL              ; retrieve HL
 168+ FDA5 C1                       pop     BC              ; retrieve BC
 169+ FDA6 C9                       ret                     ; return to caller
 170+ FDA7
 171+ FDA7
 172+ FDA7              ;***************************************************************************
 173+ FDA7              ; CF_WR_SEC
 174+ FDA7              ; Function: write a sector to Compact Flash - sector address is into BCDE - source address is into HL
 175+ FDA7              ;***************************************************************************
 176+ FDA7 C5           CF_WR_SEC:  push    BC              ; store BC
 177+ FDA8 E5                       push    HL              ; store HL
 178+ FDA9 CD 3E FD                 call    CF_SETSTR       ; set sector
 179+ FDAC CD 22 FD                 call    CF_CMDRDY       ; Make sure drive is ready for command
 180+ FDAF 38 17                    jr      C,CF_WR_EXIT    ; return if error
 181+ FDB1 3E 30                    ld      A,$30           ; set write command
 182+ FDB3 D3 57                    out     (CF_CMD),A      ; send command
 183+ FDB5 CD 31 FD                 call    CF_DAT_RDY      ; Make sure drive is ready to get data
 184+ FDB8 38 0E                    jr      C,CF_WR_EXIT    ; return if error
 185+ FDBA 21 F0 FD                 ld 	    HL,IOBUFF       ; get starting address of I/O buffer
 186+ FDBD 01 50 00                 ld      BC,CF_DATA      ; set 256 bytes per loop (B=$00) and CF port (C=CF_DATA)
 187+ FDC0 ED B3                    otir                    ; output 256 bytes
 188+ FDC2 ED B3                    otir                    ; output 256 bytes
 189+ FDC4 CD 1B FD                 call    CF_BUSY         ; wait for CF to complete the writing
 190+ FDC7 AF                       xor     A               ; clear Carry
 191+ FDC8 E1           CF_WR_EXIT: pop     HL              ; retrieve HL
 192+ FDC9 C1                       pop     BC              ; retrieve BC
 193+ FDCA C9                       ret                     ; return to caller
 194+ FDCB
 195+ FDCB              BIOSEND:    equ     $               ; end of BIOS
# file closed: ../include/dos/bios-1.03.asm
  96  FDCB                  INCLUDE "../include/dos/buffers-1.00.asm"
# file opened: ../include/dos/buffers-1.00.asm
   1+ FDCB              ; ------------------------------------------------------------------------------
   2+ FDCB              ; LM80C 64K - BUFFERS - R1.00
   3+ FDCB              ; ------------------------------------------------------------------------------
   4+ FDCB              ; The following code is intended to be used with LM80C Z80-based computer
   5+ FDCB              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ FDCB              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ FDCB              ; kind of warranty: you can use them at your own risk.
   8+ FDCB              ; You are free to use them for any non-commercial use: you are only asked to
   9+ FDCB              ; maintain the copyright notices, include this advice and the note to the
  10+ FDCB              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ FDCB              ; redistribuite them.
  12+ FDCB              ; https://www.leonardomiliani.com
  13+ FDCB              ;
  14+ FDCB              ; Please support me by visiting the following links:
  15+ FDCB              ; Main project page: https://www.leonardomiliani.com
  16+ FDCB              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ FDCB              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ FDCB              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ FDCB              ; ------------------------------------------------------------------------------
  20+ FDCB              ;
  21+ FDCB              ; ------------------------------------------------------------------------------
  22+ FDCB              ; Code Revision:
  23+ FDCB              ; R1.00 - 20210319 - first release
  24+ FDCB              ;------------------------------------------------------------------------------
  25+ FDCB
  26+ FDCB
  27+ FDCB FF FF FF...              BLOCK   $FDD0-BIOSEND,$FF  ; filler
  28+ FDD0
  29+ FDD0                          org     $FDD0           ; location of DOS jump table
  30+ FDD0              SRTBFS:     equ     $
  31+ FDD0
  32+ FDD0                          ; buffers
  33+ FDD0 FF FF FF...  DOSBFR:     BLOCK   $20,$FF         ; 32 bytes buffer
  34+ FDF0 FF FF FF...  IOBUFF:     BLOCK   $200,$FF        ; 512 bytes buffer
  35+ FFF0
  36+ FFF0 FF                       defb    $FF             ; filler
  37+ FFF1 C3 A3 F3     JPDISK:     jp      DISK            ; jump to DISK statement
  38+ FFF4 C3 43 F3     JPERAS:     jp      ERASE           ; jump to ERASE statement
  39+ FFF7 C3 9B F1     JPLOAD:     jp      LOAD            ; jump to LOAD statement
  40+ FFFA C3 3E F2     JPSAVE:     jp      SAVE            ; jump to SAVE statement
  41+ FFFD C3 0C F3     JPFILS:     jp      FILES           ; jump to FILES statement
  42+ 0000
# file closed: ../include/dos/buffers-1.00.asm
  97  0000
  98  0000              ; END OF ASSEMBLY SOURCE
  99  0000              ;-------------------------------------------------------------------------------
 100  0000
# file closed: LM80C_64K-firmware-r1.15.asm

Value    Label
------ - -----------------------------------------------------------
0x018F   A_RTS_OFF
0x01AD   A_RTS_ON
0x2596   ABPASS
0xF38C   ABRTDS
0xF39A   ABRTXT
0x2FDE   ABS_
0x413A   absHL
0x1DB0 X ACCSUM
0x2595   ACPASS
0x4017   ADD30
0x4027   ADD301
0x2F77   ADDEXP
0x311D   ADDIG
0x0A35   ADDNEWLINE
0x2D13   ADDPHL
0x5542   ADRS1
0x5546   ADRS2
0xF69A   ALFLSTXT
0x2864   ALLFOL
0x20D1   ANTVLU
0x346E X ARET
0x24A0   ARLDSV
0x558A   ARREND
0x272F   ARRLP
0x2835   ASC
0x30C0   ASCTFP
0x202A   ASPCS
0x067F   ATHOME
0x3422   ATN
0x343F   ATN1
0x3449   ATNTAB
0x1DEB   ATOH
0x53F2   AUTOKE
0x16C0   AUTORP
0x0197   B_RTS_OFF
0x01B5 X B_RTS_ON
0x0829   BACKSPACE
0x204D   BADINP
0x175B   BAKSTK
0x2815   BAKTMP
0x539B   basicStarted
0x5473   BASTXT
0x3005   BCDEFP
0x058F   BEEPOFF
0x1393   BFREE
0x4069   BIN
0x406F X BIN2
0x40C6   BINERR
0x40A5   BINIT
0x409B   BINTFP
0xFDCB   BIOSEND
0xFCFC X BIOSSTART
0x4083   BITOUT
0x4087   BITOUT2
0x3D79   BITS6
0x3D83   BITS7
0x3D8E   BITS8
0x553F   BKGNDCLR
0x0008   BKSP
0x138A   BLNSPC
0x0028   BN
0x11A1   BNMSG
0x2D73   BNORM
0x1034 X BNPTR
0x2D76   BNRMLP
0x5549   BPS
0x1D5E   BRK
0x53E7   BRKFLG
0x5518   BRKLIN
0x1755   BRKMSG
0x137E   BRKRET
0x0010   BS
0x24D3   BSERR
0x10CB   BSMSG
0x101C X BSPTR
0x5476   BUFFER
0x0096   bufWrap
0x400E   BYT2ASC
0x54DF   BYT_SIZ
0xFCB5   BYTEHEX
0x2EAB   BYTSFT
0xFD1B   CF_BUSY
0x0057   CF_CMD
0xFD22   CF_CMDRDY
0xFD31   CF_DAT_RDY
0x0050   CF_DATA
0x0051 X CF_ERR
0x0051   CF_FTR
0xFCFC   CF_INIT
0x0053   CF_LBA0
0x0054   CF_LBA1
0x0055   CF_LBA2
0x0056   CF_LBA3
0xFD12   CF_NOP
0xFD93   CF_RD_CMD
0xFDA4   CF_RD_EXIT
0xFD80   CF_RD_SEC
0x0052   CF_SECCNT
0xFD3E   CF_SETSTR
0xFD74   CF_STANDBY
0x0057   CF_STAT
0xFDC8   CF_WR_EXIT
0xFDA7   CF_WR_SEC
0x2436   CFEVAL
0xF400   CFINIT
0xFBF8   CH0TO9
0xFC00   CH0TO9E
0x028B   CH3_TIMER
0x015D   CHABFREMPTY
0x075A   CHAR2VID
0x01FD   CHARINTOBFR
0x23E4   CHARTY
0x5574   CHASNDDTN
0xFC03   CHATOZ
0xFC0B   CHATOZE
0x5576   CHBSNDDTN
0x087F   CHCKYPOS
0x08EA   CHCKYPOS2
0x5578   CHCSNDDTN
0x0D71   CHECKALT
0x0D7F   CHECKCTRL
0x0D8D   CHECKKBD
0x37D4   CHECKPA
0x37D5   CHECKPY
0x030F   CHECKWARM
0x262D   CHEKFN
0xF32A   CHK1AR
0xFCD9   CHK_C_CF
0xFCC5   CHK_NAM
0xFCDA X CHK_NAM_LV
0x0E08   CHKALT
0x0E51   CHKAUTO
0x40B8   CHKBIN
0x35F5   CHKCLR0
0x35F1   CHKCLR1
0x029A   CHKCRSR
0x0DFF   CHKCTRL
0xF191   CHKDOS
0xFC0E   CHKDSKVAL
0xFC2C   CHKDSKVAL1
0xFC42   CHKDSKVAL2
0xFC41   CHKDSKVALE
0x3FC4   CHKEY1
0x3FC9   CHKEY2
0x3FCC   CHKEY3
0x3FD2   CHKEY4
0x3FD5   CHKEY5
0xF96D   CHKFLEXT
0xF4E0   CHKFLNM
0xF4EA   CHKFN1
0x0E89   CHKFNK
0x35FB   CHKG2M
0x0805   CHKHL
0x2CF2   CHKINK
0x0DEB   CHKLN
0x1DBD   CHKLTR
0xFC46   CHKNMVAL
0xFC51   CHKNMVAL1
0xFC57   CHKNMVAL2
0xFC67   CHKNMVAL3
0x3539   CHKSCAR
0x0CF6   CHKSNDCH
0x05BC   CHKSPCK
0x178F   CHKSTK
0xFAC7   CHKSTNM1
0xFAF7   CHKSTNM10
0xFACA   CHKSTNM2
0xFAE2   CHKSTNM3
0xFAFC X CHKSTNM5
0xFAEC   CHKSTNM6
0x53E4   CHKSUM
0x1AD2   CHKSYN
0x21B1   CHKTYP
0x08A6   CHKYPOS
0x3C3E   CHKZSER
0xF90B   CHNGNAM
0x2846   CHR
0x553D   CHR4VID
0x554A   CHRPNT
0x422F   CHRST68
0x4A2F   CHRST88
0x073C   CHRTBL
0x3A03   CIRCLE
0x3D2C   CKBPS
0x36E1   CKCOL
0xFB8D   CKCREN
0x0278   CKINCHAR
0xFBA1   CKLSTEN
0xFBA7   CKLSTEN1
0x34EC   CKMAGN
0x41C2   CLCN32
0x41D2   CLCN321
0x41D5   CLCN322
0x4220   CLCN323
0x41F7   CLCN325
0x4196   CLCN32T
0x41BE   CLCN32Z
0x1E10   CLEAR
0x0672   CLEARVIDBUF
0x1B1E   CLOTST
0x0ADB   CLR_RAM_REG
0xFCE4   CLRBUFF
0xFCF0   CLRDOSBF
0x1934   CLREG
0x35B0   CLREX2
0x359E   CLRG1
0x35A7   CLRG2
0x0614   CLRG2PTNTBL
0xFCDB   CLRIOBF
0x3597   CLRMC
0x3BF0   CLRPRM
0x0C94   CLRPSGREGS
0x190F   CLRPTR
0x05B7   CLRTABLE
0x3BD2   CLRTMBF
0x3594   CLRTXT
0x3BE1   CLRVDBF
0x3471   CLS
0x3F69   CLSQT
0x3F79   CLSQT1
0x40F9   CMP16
0x2CCB   CMP_A
0x304E   CMPFP
0x234A   CMPLG1
0x2348   CMPLOG
0x3034   CMPNUM
0x238C   CMPRES
0x2374   CMPSTR
0x0020   CN
0xF4BB   CNFREQ
0xF4DE   CNFRQN
0x1161   CNMSG
0x102C X CNPTR
0x293E   CNT1INS
0x0D31   CNTCHKSND
0x3566   CNTCKCL
0x3AC5   CNTCL1
0x3AE9   CNTCL2
0x3B0D   CNTCL3
0x3B33   CNTCL4
0x3B55   CNTCL5
0x3B79   CNTCL6
0x3B9D   CNTCL7
0x531A   CNTCP2RAM
0x39A6   CNTDRW
0x1FF2   CNTEND
0x0EE4   CNTFNK
0x3661   CNTGPT2
0x0E83   CNTKBCK
0x2309   CNTLGC
0x3F2F   CNTLTK
0x09E9   CNTNULL
0x0A67 X CNTNULL2
0x3852   CNTPLOT
0x3873   CNTPLT1
0x3CAB   CNTRX2
0x0120   CNTRXCHA
0x3C7C   CNTSER
0x3CB6   CNTSER2
0x3CC8   CNTSER3
0x3BCD   CNTVALY
0x1C5B   CNTWTSP
0x2975   CNTZIN
0x30CC   CNVNUM
0x129F   COLD
0x0304   COLDSTART
0x3549   COLOR
0x53E1   COMMAN
0x2DD3   COMPL
0x27AA   CONCAT
0x30FC   CONEXP
0x2D70   CONPOS
0x1D97   CONT
0x071D   CONT_POS_CURS
0x551E   CONTAD
0x0890   CONTCRSLFT
0x08FD   CONTCRSRGT
0x5581   CONTROLKEYS
0x229C   CONVAR
0x02F8   CORW
0x33A6   COS
0x1ACC   CPDEHL
0x1324   CPDSTB
0x3EC6   CPKEY
0x3EE5   CPKEY1
0x3ED6   CPKEY2
0x3EDD   CPKEY3
0x3EED   CPKYEND
0x1A11   CPYLIT
0x000D   CR
0xFD60   CR_DEV_RDY
0xFD71 X CR_DV_ERR
0xFD65   CR_DV_RD_1
0xFD72   CR_DV_RD_E
0x24F3   CRARLP
0x24D8   CREARY
0x1F1D   CRESTR
0x09BB   CRGRETURN
0x1972   CRNCLP
0x001F   CRSDN
0x001C   CRSLFT
0x553A   CRSR_STATE
0x001D   CRSRGT
0x001E   CRSUP
0x2666   CRTMST
0x2672   CRTST
0x2688   CRTSTE
0x1969   CRUNCH
0x000C   CS
0x12AC   CSTART
0x5524   CTC0IV
0x5527   CTC1IV
0x552A   CTC2IV
0x552D   CTC3IV
0x3E28   CTC_CFG
0x0010   CTC_CH0
0x0011   CTC_CH1
0x0012   CTC_CH2
0x0013   CTC_CH3
0x036A   CTCCONF
0x53E3   CTLOFG
0x3818   CTPOINT
0x0003   CTRLC
0x0007   CTRLG
0x000F   CTRLO
0x0011   CTRLQ
0x0012   CTRLR
0x0013   CTRLS
0x0015   CTRLU
0x2B9F   CTSNDC
0x5540   CUR_POS
0x550F   CUROPR
0x54D0   CURPOS
0x093B   CURSOR_OFF
0x0926   CURSOR_ON
0x0906   CURSORDOWN
0x086C   CURSORLEFT
0x08D1   CURSORRIGHT
0x08B8   CURSORUP
0x0038   D0
0x1232   D0MSG
0x1044 X D0PTR
0x003A   D1
0xF679   D1ERR
0x1242   D1MSG
0x1046 X D1PRT
0x003C   D2
0xF65C   D2ERR
0x124E   D2MSG
0x1048 X D2PRT
0x003E   D3
0x125C   D3MSG
0x104A X D3PRT
0x0040   D4
0x1261   D4MSG
0x104C X D4PTR
0x0042   D5
0x1266   D5MSG
0x104E X D5PTR
0x0044   D6
0x1270   D6MSG
0x1050 X D6PTR
0x0046   D7
0x1284   D7MSG
0x1052 X D7PRT
0x0048   D8
0x1290   D8MSG
0x1054 X D8PTR
0x54D9   DAT_STRT
0x1EC4   DATA
0x554B   DATABT
0x54D3   DATFLG
0x5513   DATLIN
0x17CC   DATSNR
0x5552   DC
0x3085   DCBCDE
0x0012   DD
0x17DB   DDERR
0x10D9   DDMSG
0x101E X DDPTR
0xFC6E   DE2HL
0x054D   DEC_D
0x3EB8   DECLN1
0x348D   DEEK
0x25AA   DEF
0x16C2 X DEFFNKS
0x3D13   DEFSER
0x24FB   DEFSIZ
0x1DD1   DEINT
0x007F   DEL
0x1A41   DELCHR
0x1DCB   DEPINT
0x3014   DETHL4
0x3016   DETHLB
0x31C6   DIGTXT
0x23B6   DIM
0x23AD   DIMRET
0x1B01   DINPOS
0x2EB0   DINT
0x34B8 X DIR_PAU
0x54DB   DIR_SCT
0x54D7   DIR_STRT
0x3E44   DIRMOD
0xF3A3   DISK
0x2A4D   DISNMI
0x2F0D   DIV
0x53A9   DIV1
0x2F01   DIV10
0x53AD   DIV2
0x53B1   DIV3
0x53B4   DIV4
0x4163   DIV_16_16
0x4154   DIV_16_8
0x4157   DIV_16_8LP
0x4178   DIV_32_16
0x417D   DIV_32_16LP
0x418E   DIV_32_16OF
0x4191   DIV_32_16SB
0x4144   DIV_8_8
0x4148   DIV_8_8LOOP
0x2F34   DIVLP
0x53A8   DIVSUP
0x5544   DKLNPT
0x5542   DKNMPT
0x3A87   DLSZ
0x194D   DOAGN
0x05D4   DOCOLDRESET
0x1FF7   DOCOM
0x1A21   DODEL
0x3206   DOEBIT
0x25D7   DOFN
0x3498   DOKE
0x5585   DOS_EN
0xF323   DOS_ERR
0xF57B X DOS_FT0
0xF57C   DOS_FT1
0xF62D   DOS_FT10
0xF596   DOS_FT2
0xF5BD X DOS_FT5
0xF631   DOS_FT7
0xF633   DOS_FT8
0xF620   DOS_FT9
0xF606   DOS_FTA
0xF56E   DOS_FTC
0xFDD0   DOSBFR
0x54D6   DOSER
0x13E2   DOSMSG
0x2025   DOSPC
0xF180   DOSSTART
0xF674   DOSVERSERR
0x2010   DOTAB
0x30F8   DPOINT
0x38CA   DRAW
0x3AA3   DRWCRL
0xF507   DSK_INIT
0xF639   DSK_RNM
0xF18F   DSKDIRADR
0xF3ED   DSKFRM
0xF660   DSKFULL
0xF180   DSKHDR
0xF683   DSKNMTX
0xF489   DSKRNM
0xF47C   DSKUND
0xFB05   DSKUNDFL
0xFB11   DSKUNDFL1
0xFB42   DSKUNDFL2
0xFB2D   DSKUNDPR
0xFB47   DSKUNDTXT
0x2676   DTSTR
0xF664   DUPLERR
0x4168   DV16_16_LP
0x2F0F   DVBCDE
0x5554   DX
0x39D6   DXGR
0x5556   DY
0x0014   DZ
0x17D5   DZERR
0x10EE   DZMSG
0x1020 X DZPTR
0x554E   E2
0x1A35   ECHDEL
0x031C   ECHO_CHAR
0x313F   EDIGIT
0x28DD   EMPTINS
0x0C90   EMPTSNDBFR
0x0AD2   EMPTVRM
0x0AC8   EMPTY_VRAM
0x014F   EMPTYCHABFR
0x0181   EMPTYCHBBFR
0x0603   EMPTYG2
0x0633   EMPTYMC
0x05DB   EMPTYVIDBUF
0x3DFD   ENCHB
0x533E   END_OF_FW
0x1A18   ENDBUF
0x310B   ENDCON
0x3A9F   ENDCRL
0x0DD3   ENDCTRLCK
0x255A   ENDDIM
0x39FF   ENDDRAW
0x2D04   ENDINK
0x2D0D X ENDINK2
0x1FDE   ENDINP
0x081B X ENDINSRT
0x54F2   ENDMEM
0x23D8   ENDNAM
0x0A42   ENDOFLN
0x1D6D   ENDPRG
0x256F   ENDTMR
0x5544   ENDTXT
0x04E7   ENDVDPSET
0x1798   ENFMEM
0x554C   ER
0x397A   ER2
0xF343   ERASE
0x056C   ERASECLRTBL
0xF37E   ERASED
0x1810   ERRIN
0x1D91   ERRINT
0x551C   ERRLIN
0x1744   ERRMSG
0x17EC   ERROR
0x1056 X ERRORS
0x100C   ERRTBL
0xF370   ERSTX
0x001B   ESC
0x21BE   EVAL
0x21C1   EVAL1
0x21CA   EVAL2
0x21CD   EVAL3
0x2283   EVLPAR
0x2396   EVNOT
0x1CFB   EXCUTE
0x04A5   EXG2MD
0x07B6   EXITCHAR2VID
0x0939   EXITCURSOR_ON
0x0923   EXITCURSORDOWN
0x0893   EXITCURSORLEFT
0x0903   EXITCURSORRGHT
0x08CF   EXITCURSORUP
0xF7CB X EXITFLS
0x17AC   EXITGM
0x37D0   EXITPA2
0x37CC   EXITPAI
0x411C   EXMUL16
0x3E0B   EXNRM
0x32A0   EXP
0x30EA   EXPLP
0x32E0   EXPTAB
0x3218   EXPTEN
0x212D   EXTIG
0x2156   FANDT
0x0008   FC
0x1DE6   FCERR
0x108F   FCMSG
0x1014 X FCPTR
0x213D   FDTLP
0xFAA8   FIL_ERA1
0xFAB3   FIL_ERA2
0xFAB6   FIL_ERA3
0xFA87   FIL_ERA5
0xFA80   FIL_ERA6
0xFA49   FIL_ERASE
0xFAC0   FILE_EXIST
0xF30C   FILES
0xF7D0   FILETP
0x2536   FINDEL
0x0DE9   FINDKEY
0x07C4   FLASHCURSOR
0xFB03   FLEXST
0x2FC4   FLGDIF
0x2FCB   FLGREL
0xFB01 X FLNTEXS
0xF66C   FLNTFND
0x00EC   FMVEREND
0x5590   FNARG
0x140A   FNCTAB
0x24A6   FNDARY
0x253B   FNDELP
0x18E2   FNDEND
0xFB52   FNDFRENTR
0xFB5E   FNDFRENTR1
0xFB61   FNDFRENTR2
0xFB71   FNDFRENTR3
0xFB66   FNDFRENTR4
0x2A2F   FNDNUM
0x1C0F   FNDTOK
0x241D   FNDVAR
0x199C   FNDWRD
0x53F3   FNKEYS
0x0F04   FNKEYSORD
0x22AD   FNOFST
0x558E   FNRGNM
0x242B   FNTHR
0x22DE   FNVAL
0x21F6   FOPRND
0x1C62   FOR
0x5515   FORFLG
0x1C92   FORFND
0x1C76   FORSLP
0x2D22   FPADD
0x2FFA   FPBCDE
0x5597   FPEXP
0x3061   FPINT
0x2E5D   FPMULT
0x5594   FPREG
0x2DBA   FPROND
0x1DC5   FPSINT
0x3011   FPTHL
0x2574   FRE
0x2590   FRENUM
0x553E   FRGNDCLR
0x229F   FRMEVL
0xF44F   FRMTXT
0x00D0 X FWVER
0x0420   G1MD
0x0460   G2MD
0x26F7   GARBGE
0x26FA   GARBLP
0xF206   GET4AR
0x1D1B   GETCHR
0x183F   GETCMD
0x4044   GETHEX
0x346F   GETINP
0x2A32   GETINT
0x282A   GETLEN
0x1A52   GETLIN
0x1DEC   GETLN
0x21AC   GETNUM
0x19B7   GETNXT
0x27F4   GETSTR
0x23BB   GETVAR
0x002A   GM
0x3C09   GMERR
0x11AC   GMMSG
0x1AA9   GMNCR
0x1036 X GMPRT
0x272E   GNXARY
0x22E6   GOFUNC
0x1E70   GOSUB
0x1E81   GOTO
0x36C4   GPCPCH1
0x36BA X GPCPCHR
0x3676   GPNT
0x36A0   GPNTCO1
0x3696 X GPNTCOL
0x3604   GPRINT
0x274E   GRBARY
0x26CF   GRBDON
0x2708   GRBLP
0x27F7   GSTRCU
0x27FB   GSTRDE
0x27FA   GSTRHL
0x2839 X GTFLNM
0x23C0   GTFNAM
0x1DEF   GTLNLP
0xFB95   GTNXTEN
0x3190   GTSIXD
0x20A9   GTVLUS
0x5544   GX
0x5546   GY
0x3237   HALF
0x33F0   HALFPI
0x3E4D   HELP
0x3FD8   HEX
0x3FF0   HEX1
0x3FF2   HEX2
0x3FFF   HEX3
0x4001   HEX4
0x405B   HEXIT
0x4037   HEXLP
0x403C   HEXLP1
0x402B   HEXTFP
0xFC73   HL2DE
0x072B   HL2XY
0x3E66   HLPERR
0x53EF   HLPLN
0x0019   HOME
0x0032   HP
0x1201   HPMSG
0x103E X HPPTR
0x0026 X HX
0x4064   HXERR
0x1196   HXMSG
0x1032 X HXPTR
0x0016   ID
0x10FF   IDMSG
0x1022 X IDPTR
0x261F   IDTEST
0x1F53   IF
0x1F6A   IF0
0x1F73   IF1
0x1F61   IFGO
0x1D02   IFJMP
0x0034   IM
0x17E7   IMERR
0x120B   IMMSG
0x1040 X IMPRT
0x300F   INCHL
0x1AFD   INCLEN
0x0294   INCTMR3
0x1775   INDFND
0x18AA   INEWLN
0x02AE   INIT_HW
0x02B1   INIT_HW2
0x166B   INITAB
0x1744   INITBE
0x0340   initCTC
0xF40D X INITDSK
0xF41B X INITFN
0x0C8A   initPSG
0x40E4   INITST
0x03D1   initVDP
0x2CC0   INKEY
0x2CDA   INKEY2
0x174B   INMSG
0x29EF   INP
0x20FB   INPBIN
0x1D6A   INPBRK
0x53DE   INPORT
0xF6CE   INPR1
0x53DD   INPSUB
0x205E   INPUT
0x3199   INRNG
0x07E7   INSERTKEY
0x001A   INSRT
0x2886   INSTR
0x308C   INT
0x191E   INTVAR
0x2FE2   INVSGN
0xFDF0   IOBUFF
0x20EC   ITMSEP
0xFFF1   JPDISK
0xFFF4   JPERAS
0xFFFD   JPFILS
0xFFF7   JPLOAD
0xFFFA   JPSAVE
0x3222   JSTZER
0x557A   KBDNPT
0x0F0C   KBMAP
0x0F8C   KBMAP_ALT
0x0FCC   KBMAP_CTRL
0x0F4C   KBMAP_SFT
0x557B   KBTMP
0x3E6B   KEY
0x0D51   KEYBOARD
0x3E88   KEYCH
0x53F1   KEYDEL
0x557F   KEYTMR
0x219C   KILFOR
0x1A4C   KILIN
0x557D   LASTKEYPRSD
0x54D1   LCRFLG
0x04DE   LDCLRTBEX2
0x0457   LDCLRTBMD1
0x05F4   LDCOLSTOEMPTY
0xF1D4   LDEND
0xFBB3   LDENTRIES
0xF1DB   LDERR
0xF9E2   LDFL1
0xF9E6   LDFL2
0xFA06   LDFL3
0xF9C6   LDFL4
0xFA3D   LDFL5
0xFA44   LDFLEX
0x0ED0   LDFNKEYCHR
0x17B9   LDG1
0x17CA   LDG1ND
0x3F1A   LDKEY
0xFBC2   LDMSCT
0xFBC5 X LDMSCT1
0x0AF8   LDREGVLS
0xF1F1   LDSVPT
0x2856   LEFT
0x2826   LEN
0x1EDB   LET
0x1F2E   LETNUM
0x1EF6   LETSTR
0x000A   LF
0x29E5   LFRGNM
0x53ED   LINEAT
0x314B   LINEIN
0x1893   LINFND
0x1B39   LIST
0x1BCC   LISTLP
0xF98A   LK4FILE
0xF98D   LK4FILE1
0x0B4A   LM80CLOGO
0x5540   LNS1
0x5544   LNS2
0xF19B   LOAD
0x0708   LOAD_CRSR_POS
0x0B02   LOADCHARSET
0x35B7   LOADCLR
0x3008   LOADFP
0x0597   LOADLOGOCHRS
0x0E0F   LOADMAP
0x096C   LOADNEXTCOL
0xF1BF   LOADST
0x2B05   LOCATE
0xF670   LODERR
0xF99F   LODFILE
0x2E1C   LOG
0x522F   LOGOFONT
0x2E0F   LOGTAB
0x175F   LOKFOR
0x5511   LOOPST
0x001C   LS
0x1136   LSMSG
0x1028 X LSPTR
0x1B65   LST01
0x1B68   LST01H
0x1BC3   LST02
0x1BAC   LST03
0x1BC0   LST05
0x1B83   LST06
0x1BF1   LST07
0x1BEE   LST08
0xF6B5   LST_FILES
0x1B94   LSTALL
0x5516   LSTBIN
0x553B   LSTCSRSTA
0xF702   LSTFILES1
0xF705   LSTFILES2
0xF72F   LSTFILES20
0xF737   LSTFILES21
0xF713   LSTFILES3
0xF771 X LSTFILES5
0xF766   LSTFILES6
0xF73A   LSTFILESPR
0x3EEF   LSTKEYS
0x1BFD   LSTLP2
0x1C00   LSTLP3
0x1B87   LSTNOT
0x54D4   LSTRAM
0x53D9   LSTRND
0x54E4   LSW_SCT
0x2106   LTSTND
0x0863   LVBKSP
0x05D2   LVCKSPLK
0x296B   LVINSTR
0x0EB7 X LVKBRDCHK
0x0EB3   LVKBRDCHK2
0x0131   LVRXCHA
0x1C47   LVSRLN
0x53E0   LWIDTH
0x2A35   MAKINT
0x31B5   MAKNUM
0x30D4   MANLP
0x19E9   MATCH
0x0482   MCMD
0x13FF   MEMMSG
0x2986   MID
0x285C   MID1
0x29EA   MIDNUM
0x2D62   MINCDE
0x228B   MINUS
0x35E4   MIXCLRS
0x5540   MIXCOL
0x2663   MKTMST
0x30AD   MLDBLP
0x30A5   MLDEBC
0x12E4   MLOOP
0x410C   MLP
0x4113   MLP1
0x2FA2   MLSP10
0x0CEC   MNGSNDS
0x12E1   MNOASK
0x3751   MNPAINT
0x0024   MO
0x2EB8   MOD
0x1186   MOMSG
0x40CB   MONOUT
0x1030 X MOPTR
0x2112   MORDT
0x1A5B   MORINP
0x18C9   MOVBUF
0x06CF   MOVCRS
0x19F1   MOVDIR
0x1784   MOVLP
0x06D5   MOVSHOWCRS
0x1781   MOVSTR
0x177E   MOVUP
0x1F81   MRPRNT
0x0376   MSGTXT1
0x03B4   MSGTXT2
0x12CE   MSIZE
0xF42F   MSPTOK
0xF437   MSTTXT
0x54E2   MSW_SCT
0x4129   MU32_1
0x4136   MU32_2
0x4104   MUL16
0x2E88   MUL8LP
0x412B   MUL_32L
0x411E   MUL_U32
0x2E54   MULLN2
0x2E5B   MULT
0x2E7F   MULT8
0x3116   MULTEN
0x55A6   MULVAL
0x0850   MVBKSP
0x0895   MVCRS2LFT
0x1F25   MVSTPT
0xF668   NAMERR
0x20A5   NEDMOR
0x324D   NEGAFT
0x413D   negHL
0x190E   NEW
0x06EA   NEWCRSRCOORD
0x0E63   NEWKEY
0x2034   NEXITM
0x2161   NEXT
0x2164   NEXT1
0x0000   NF
0x17D8   NFERR
0x1056   NFMSG
0x100C X NFPTR
0x0000   NLLCR
0x2A5E   NM1
0x2A43   NMI
0x2A6F   NMI2
0x2A7A   NMIDINT
0x2A73   NMIEINT
0x53E6   NMIFLG
0x2A7D   NMIINT
0x539F   NMIUSR
0x2A89   NMIVR1
0x0CBE   NOBEEP
0x0CDA   NOBPDAT
0x19E1   NOCHNG
0x3225   NOENED
0x3893   NOGD
0x2C23   NOISUP
0x0DD7   NOKEYPRSD
0x1D80   NOLIN
0x2E99   NOMADD
0x30BB   NOMLAD
0x2078   NOPMPT
0x2D8D   NORMAL
0x2C4D   NOS1
0x2C60   NOS2
0x2C79   NOS3
0x19D8   NOSPC
0x4057   NOSUB7
0x2D3C   NOSWAP
0x2ABB   NOSYSPR
0x2260   NOTAMP
0x0208   NOTFULL
0x023F   NOTRDWRAP
0x23F3   NOTSTR
0x0214   NOTWRAP
0x2A15   NOXOR
0x0036   NR
0x17EA   NRERR
0x1221   NRMSG
0x1042 X NRPRT
0x2403   NSCFOR
0x54DD   NTR_NBR
0x53E2   NULFLG
0x315E   NUMASC
0x554C   NUMCHR
0x24BA   NXTARY
0x19C7   NXTBYT
0x0B16   NXTCHAR
0x1A08   NXTCHR
0x077A   NXTCPCK
0x558C   NXTDAT
0x1EC3   NXTDTA
0x0816   NXTINST
0x209D   NXTITM
0x1C27   NXTLN
0x3732   NXTLOOP
0x551A   NXTOPR
0x1ECA   NXTSTL
0x1ECD   NXTSTT
0x0006   OD
0x1083   ODMSG
0x1012 X ODPTR
0x1750   OKMSG
0x000C   OM
0x17A7   OMERR
0x10AE   OMMSG
0x1018 X OMPTR
0x1F35   ON
0x1F44   ONGO
0x1F45   ONGOLP
0x1D03   ONJMP
0x21BA   OPNPAR
0x3F7B   OPNQT
0x3F91   OPNQT1
0xF467   OPRCMP
0x2235   OPRND
0x554C   ORGSP
0x001A   OS
0x1122   OSMSG
0x1026 X OSPTR
0x1A49   OTKLN
0x53A6   OTPORT
0x1ADD   OUTC
0x3216   OUTEXP
0x1AC3   OUTIT
0x1AC6   OUTNBS
0x40F3   OUTNCR
0x53A5   OUTSUB
0x1C19   OUTWRD
0x000A   OV
0x17E1   OVERR
0x10A5   OVMSG
0x1016 X OVPTR
0x2F95   OVTST1
0x2F9A   OVTST2
0x2F9B   OVTST3
0x313A   PADD
0x36F4   PAINT
0x373F   PAINT0
0x374E   PAINT1
0x374D   PAINT11
0x3781   PAINT2
0x3794   PAINT3
0x37B3   PAINT4
0x37C5   PAINT5
0x22FF   PAND
0x2324 X PAND1
0x554C   PARBT
0x25A5   PASSA
0x34AF   PAUSE
0x5599   PBUFF
0x2ACB   PEEK
0x1D65   PEND
0x2FF7   PHLTFP
0x0002 X PIO_CA
0x0003   PIO_CB
0x0000 X PIO_DA
0x0001   PIO_DB
0x2ADF   PKEPRMS
0x07C3   PLACEHOLDER
0x3837   PLOT
0x3A96   PLTCRL
0x2DC7   PLUCDE
0x2D95   PNORM
0x5548   PNT
0x0EB0   PNT2VD
0x380E   PNTEND
0x382C   PNTRTN
0xF78C   PNTSTATS
0x37E4   POINT
0x2AF5   POKE
0x26E9   POPAF
0x2813   POPHL
0x2EA9   POPHRT
0x1831   POPNOK
0x2302   POR
0x2329   POR1
0x25A2   POS
0x06C5   POS_CURSOR
0x0A68   POS_TB_CRS_32
0x0A98   POS_TB_CRS_40
0x1DC8 X POSINT
0x29FB   POUT
0x325B   POWER
0x326B   POWER1
0x3288   POWER2
0x323B   POWERS
0x1F85   PRINT
0x164D   PRITAB
0xFC7B   PRN16ASCII
0xFC81   PRN16ASCIX
0xFC78   PRN32ASCII
0xFC94 X PRN_HEX
0xFC95   PRN_HEX1
0xFC9E X PRN_WHEX
0xFCA0   PRN_WHEX1
0x1FE8   PRNTCRLF
0x0EF7   PRNTFNK
0x0EB8   PRNTFNKEY
0x3153   PRNTHL
0x1F88   PRNTLP
0x1FCB   PRNTNB
0x1832   PRNTOK
0x0A21   PRNTRETURN
0xFC8B   PRNTSIZ
0x1FCF   PRNTST
0x553C   PRNTVIDEO
0x26B3   PRNUMS
0x1A74   PROCES
0x5586   PROGND
0x55A9   PROGST
0x1951   PROMPT
0x26B4   PRS
0x26B7   PRS1
0x26BE   PRSLP
0x3F44   PRTCHR
0x3F93   PRTCKEY
0x3FA0   PRTEND
0x3F94   PRTK1
0x3F03 X PRTK2
0x3F2C   PRTK3
0x3F01   PRTK4
0x5548   PRTNUM
0x0041   PSG_DAT
0x0040   PSG_REG
0x2D1D   PSUB
0x5548   PT
0x554A   PT1
0x554C   PT2
0xFB82   PT2FSEN
0x3F61   PTCHR1
0x182D   PTLN
0x18D6   PTRLP
0x1AAF   PUTBUF
0x0EA3   PUTCHRBUF
0x0EEA   PUTCHRBUF1
0x07E3   PUTCRSCHR
0x1AB4   PUTCTL
0x1CD7   PUTFID
0x3897   PXLSET
0x2307   PXOR
0x2331   PXOR1
0x2679   QTSTLP
0x2673   QTSTR
0x33F4   QUARTR
0x554C   RADIUS
0x54E6   RAM_PTR
0x52EF   RAMRUN
0x027D   RAWPRINT
0x2098   READ
0x0689   READ_VIDEO_LOC
0x06BE   READ_VSTAT
0x5517   READFG
0x0D3C   READKBLN
0x3492 X RECWRD
0x203B   REDO
0x1EC6   REM
0xF2C9   RENFIL
0x2F47   RESDIV
0x3392   RESEED
0x40CE   RESET
0x3E78   RESFN
0x0365   RESTMR
0x1D40   RESTNL
0x1D2B   RESTOR
0x2D88   RESZER
0xF67B   RET_ERR
0x246A   RETADR
0xFD2F   RETERR
0x2FD0   RETINT
0x1EBE   RETLIN
0x19ED   RETNAD
0x246D   RETNUL
0x2297   RETNUM
0x2FC2   RETREL
0x1E9F   RETURN
0x0004   RG
0x106E   RGMSG
0x1010 X RGPTR
0x297C   RIGHT
0x285A   RIGHT1
0x53E8   RINPUT
0x21DA   RLTLP
0x3331   RND
0x336D   RND1
0x3389   RND2
0xFBE5   RND8
0xFBCE   RND_ID
0xFBD1   RND_ID1
0xF4AD   RNDKTX
0x339A   RNDTAB
0x3228   RNGTST
0x5304   ROM2RAM
0x2DA9   RONDB
0x2DA8   RONDUP
0x2D10   ROUND
0x2915   RP2INST
0x3BDA   RPCLTMB
0x368B   RPGPNT
0x0579   RPT100
0x051A   RPT101
0x051D   RPT102
0x0533   RPT103
0x053B   RPT104
0x3A5A   RPTCL1
0x076D   RPTCPCK
0x3A47   RPTCRL
0x3BE9   RPTCVBF
0x398A   RPTDRW
0x05FA   RPTEMPTYBUF
0x09AF   RPTEMPTYROW
0x065F   RPTFLL1
0x28EE   RPTINST
0x0D91   RPTKBDRD
0x35C0   RPTLDCL
0x09D9   RPTNLLSRC
0x0A5A   RPTNLLSRC2
0x34BD   RPTPS
0x3C4F   RPTRSSR
0x0CC4   RPTWLCMBP
0x2B7A   RPVOLCG
0x3134   RSCALE
0x0000 X RST00
0x0008 X RST08
0x0010 X RST10
0x0018 X RST18
0x06FF   RSTCHRCRS
0xFCE5   RSTIOBF
0x0C9B   RSTPSG
0x3C42   RSTSERS
0x299F   RSTSTR
0x0AE1   RSTVDPRAMREG
0x1E5C   RUN
0x1CDB   RUNCNT
0x191A   RUNFST
0x1E80   RUNLIN
0xF3E8   RWMSSC
0x0100   RX_CHA_AVAIL
0x0165   RX_CHB_AVAIL
0x022A   RXA
0x0255   RXA_EXIT
0x3CB2   RXEND
0x2960   RZINSTR
0x002E   SA
0x11D2   SAMSG
0x103A X SAPTR
0xF23E   SAVE
0xF29B   SAVE1
0xF2B0   SAVESCT
0x2D89   SAVEXP
0xF7DF   SAVFILE
0xF807   SAVFL1
0xF8A9   SAVFL10
0xF8DA X SAVFL11
0xF8FF   SAVFL12
0xF88D   SAVFL2
0xF7FF   SAVFL3
0xF8BB   SAVFL4
0xF81A   SAVFL6
0xF81E X SAVFL7
0xF865   SAVFL9
0xF906   SAVFLEXT
0x1CCE   SAVSTP
0x264E   SAVSTR
0x2478   SBSCPT
0x002C   SC
0x2DE7   SCALE
0x2DE9   SCALLP
0x30FF   SCALMI
0x3115   SCALPL
0x3E37   SCERR
0x3E33   SCERR1
0x11BD   SCMSG
0x2785   SCNEND
0x247E   SCPTLP
0x1038 X SCPTR
0x5537   SCR_CUR_NX
0x5538   SCR_CUR_NY
0x5535   SCR_CURS_X
0x5536   SCR_CURS_Y
0x5532   SCR_MODE
0x5533   SCR_NAM_TB
0x5539   SCR_ORG_CHR
0x5531   SCR_SIZE_H
0x5530   SCR_SIZE_W
0x34CE   SCREEN
0x095A   SCROLLNXTRW
0x0942   SCROLLUP
0x54E1   SCT_SIZ
0x34FA   SCVDP
0x19B5   SEARCH
0x53B6   SEED
0x0B18   SENDCHRPTRNS
0x0E70   SENDKEY
0x0CC1   SENDSND
0x0058   SER_BUFSIZE
0x0005   SER_EMPTYSIZE
0x0050   SER_FULLSIZE
0x5583   SERABITS
0x5584   SERBBITS
0x533E   SERBUF_START
0x539A   serBufUsed
0x3C0E   SERIAL
0x5582   SERIALS_EN
0x5396   serInPtr
0x3C78   SERLED
0x5398   serRdPtr
0x3C2F   SERVAR
0x3D56   SET_CTC
0x0AE6   SET_GFX_MODE
0x0AEE   SET_GFX_MODE2
0x3D45   SET_PT
0x0583   SETBEEP
0x35CB   SETBRCL
0x07A3   SETCRSRY
0x07A4   SETCSRCOORDS
0x1337   SETDSR
0x2A1F   SETIO
0x19FF   SETLIT
0x0657   SETNAMETABLE
0x0E41   SETNEWAUTO
0x133A   SETNOD
0x3D92   SETPAR
0x3D9D   SETPAR2
0xFB7A   SETPTEN
0x18D1   SETPTR
0x3FA2   SETREP
0x3D20   SETSER
0x0CE2   SETSNDREG
0x1308   SETTOP
0x136B   SETTP1
0x133B X SETTRAM
0x34E1 X SETVDP
0x0669   SETVDPADRS
0x189B   SFTPRG
0x2FC8   SGN
0x22EF   SGNEXP
0x5598   SGNRES
0x04F2   SHOW_LOGO
0x2DF6   SHRITE
0x2DF9   SHRLP
0x2DFD   SHRT1
0x13A1   SIGNON
0x301F   SIGNS
0x33AC   SIN
0x33DC   SIN1
0x33F8   SINTAB
0x01CB   SIO_A_DI
0x01E3   SIO_A_EI
0x0336   SIO_A_SETS
0x01D3   SIO_B_DI
0x01EB   SIO_B_EI
0x033C X SIO_B_SETS
0x0022   SIO_CA
0x0023   SIO_CB
0x0020   SIO_DA
0x0021   SIO_DB
0x019D   SIO_RTS_OFF
0x01BB   SIO_RTS_ON
0x01D9   SIO_RXDI
0x01F1   SIO_RXEN
0x554E   SIOBFR
0x317B   SIXDIG
0x2719   SMPVAR
0x3310   SMSER1
0x0002   SN
0x2BE8   SND1
0x1B10   SND2VID
0x0A02   SNDCHRTOBFR
0x064D   SNDCLRSET
0x0E91   SNDKEYTOBFR
0x05AD   SNDLOGPT
0x2C1D   SNDOVR
0x0CA8   SNDREGCFG
0x17D2   SNERR
0x1067   SNMSG
0x100E X SNPTR
0x0030   SO
0x3E3C   SOERR
0x11EB   SOMSG
0x103C X SOPTR
0x2B91   SOUND
0x554A X SPA
0x554B X SPB
0x0020   SPC
0x316C   SPCFST
0x202C   SPCLP
0x0136   SPEC_RXA_CNDT
0x0168   SPEC_RXB_CNDT
0x3252   SQR
0x1C35   SRCHLIN
0x18EE   SRCHLN
0x18F1   SRCHLP
0x1C3B   SRCLN
0x1C3C   SRCLN1
0x2B37   SREG
0x3DD2   SRLCNT
0x3C72   SRPT2
0xFDD0 X SRTBFS
0x2CEE   SRTINK
0x54F0   SRTMEM
0x5542   SRTTXT
0x2CAC   SSTAT
0x27E1   SSTSA
0x001E   ST
0x547B   STACK
0x2FEA   STAKFP
0x1D54   STALL
0x12A5   STARTB
0x064A   STARTEMPTY
0x557E   STATUSKEY
0x221E   STKTHS
0x560D   STLOOK
0x1146   STMSG
0x1D63   STOP
0x1E39   STORED
0x554D   STPBT
0x275C   STPOOL
0x102A X STPTR
0x263E   STR
0x2644   STR1
0x275F   STRADD
0x550D   STRBOT
0x3987   STRE2
0x20EF   STRENT
0x3DBA   STRPAR
0x53EB   STRSPC
0x1FD6   STTLIN
0x2D1F   SUBCDE
0x2D19   SUBPHL
0x3319   SUMLP
0x3301   SUMSER
0x3E12   SUP_BPS
0x31FA   SUPTLZ
0xF2C2   SVEND
0xF2F7   SVERR
0x23D7   SVNAM2
0x266C   SVSTAD
0x5550   SX
0x5552   SY
0x2A9D   SYS
0x12B3   SYSINIT
0x2AC9   SYSRET
0x340D   TAN
0x54CD   TEMPSTACK
0x0DC0   TESTALT
0x0DCD   TESTCTRL
0x26EB   TESTOS
0x26CD   TESTR
0x5550   TF
0xF6AB   TLFLSTX
0xF68F   TLSCTTX
0x0018   TM
0x17E4   TMERR
0x1113   TMMSG
0x8000   TMP_FW_LOC
0x5548   TMPADR
0x5540   TMPBFR1
0x5542   TMPBFR2
0x5544   TMPBFR3
0x5546   TMPBFR4
0x5542   TMPCLR
0x54D7   TMPDBF
0x554E   TMPHL
0x557C   TMPKEYBFR
0x5509   TMPSTR
0x1024 X TMPTR
0x255E   TMR
0x5520   TMRCNT
0x54FD   TMSTPL
0x54FB   TMSTPT
0x2852   TOPOOL
0x27EA   TOSTRA
0x554E   TP
0x54E8   TPBF1
0x54EA   TPBF2
0x54EC   TPBF3
0x54EE   TPBF4
0x54D7   TPHL
0x31D5   TRYAGN
0x27EB   TSALP
0x40EC X TSTBIT
0x1D46   TSTBRK
0x12F6   TSTMEM
0x21AF   TSTNUM
0x2694   TSTOPL
0x2336   TSTRED
0x1A02   TSTREM
0x2FB9   TSTSGN
0x1C49   TSTSPC
0x21B0   TSTSTR
0x1A52   TTYLIN
0x026C   TX_EMP
0x0259   TXA
0x0269   TXA_EXIT
0xF1E0   TXTLDG
0x03F6 X TXTMD
0xF2E6   TXTRNM
0xF2FC   TXTSVG
0x54D2   TYPE
0x0022   UF
0x17DE   UFERR
0x1170   UFMSG
0x102E X UFPTR
0x000E   UL
0x1E9A   ULERR
0x10BC   ULMSG
0x101A X ULPTR
0x2E0B   UNITY
0x1D41   UPDATA
0x53A2   USR
0x29B6   VAL
0x29D4   VAL1
0x29DE   VAL2
0x29E1   VAL3
0x3BC2   VALIDX
0x3BC7   VALIDY
0x5588   VAREND
0x0030   VDP_DAT
0x0031   VDP_SET
0x0B22   VDPMODESET
0x0B2A X VDPMODESET1
0x0B32 X VDPMODESET2
0x0B42 X VDPMODESETEX2
0x0B3A X VDPMODESETMC
0x5548   VIDEOBUFF
0x5570   VIDTMP1
0x5572   VIDTMP2
0x2B86   VOLCH
0x2B58   VOLUME
0x2AD2   VPEEK
0x2AFA   VPOKE
0x2C85   VREG
0x2CA1   VSTAT
0x2A01   WAIT
0x2A16   WAITLP
0x12A2   WARM
0x137B   WARMST
0x3485   WIDTH
0x0CD2   WLCBPDAT
0x0CB8   WLCMBEEP
0x144E   WORDS
0x15DF   WORDTB
0x069E   WRITE_VIDEO_LOC
0x06B3   WRITE_VREG
0x0994   WRITEBUF
0x539C   WRKSPC
0xFABB   WRT_ERR
0x2C70   WRTSND
0x0CE7   WRTSNDREG
0x1C4F   WTSPC
0x5540   X1
0x392D   X1GR
0x5548   X2
0x5548   XC
0x554E   XI
0x389F   XY2HL
0x5542   Y1
0x3957   Y1GR
0x554A   Y2
0x554A   YC
0x5550   YI
0x0083   ZDATA
0x00C3 X ZDINT
0x00C1 X ZDIV
0x00AF   ZELSE
0x0080   ZEND
0x00C9   ZEQUAL
0x2519   ZERARY
0x174F   ZERBYT
0x245C   ZEROLP
0x4075   ZEROSUP
0x00B9   ZFN
0x0081   ZFOR
0x008C   ZGOSUB
0x0088   ZGOTO
0x00C8   ZGTR
0x00E2   ZINSTR
0x00EA   ZLEFT
0x00CA   ZLTH
0x00BF   ZMINUS
0x00C2 X ZMOD
0x00B6   ZNEW
0x00BC   ZNOT
0x2005   ZONELP
0x00C7   ZOR
0x00BE   ZPLUS
0x00E1   ZPOINT
0x00B0   ZPRINT
0x008E   ZREM
0x00CB   ZSGN
0x00BA   ZSPC
0x00BD   ZSTEP
0x00B7   ZTAB
0x00BB   ZTHEN
0x00C0 X ZTIMES
0x00B8   ZTO
