# file opened: LM80C_64K-firmware-r1.14.asm
   1  0000              ; ------------------------------------------------------------------------------
   2  0000              ; LM80C 64K - FIRMWARE - R1.14
   3  0000              ; ------------------------------------------------------------------------------
   4  0000              ; The following code is intended to be used with LM80C Z80-based computer
   5  0000              ; designed by Leonardo Miliani. More info at
   6  0000              ; www DOT leonardomiliani DOT com
   7  0000              ; ------------------------------------------------------------------------------
   8  0000              ; Coding/Editing/Compiling:
   9  0000              ; Original init code for MC68B05 by Grant Searle
  10  0000              ; Original SIO/CTC/PIO init code by Mario Blunk
  11  0000              ; NASCOM BASIC originally modified by Gran Searle
  12  0000              ; Code modified and adapted for LM80C by Leonardo Miliani
  13  0000              ;
  14  0000              ; Edited with Visual Studio Code
  15  0000              ;
  16  0000              ; Compiled with SjASMPlus assembler 1.18.0
  17  0000              ; https://github.com/z00m128/sjasmplus
  18  0000              ; ------------------------------------------------------------------------------
  19  0000              ; Copyright notes:
  20  0000              ; Parts of the code (c) Grant Searle - free for non commercial use
  21  0000              ; Please include this advice and the note to the attribution of the original
  22  0000              ; version to Grant Searle if you intend to redistribuite it
  23  0000              ; http://searle.hostei.com/grant/index.html
  24  0000              ; eMail: home.micros01@btinternet.com
  25  0000              ;
  26  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  27  0000              ; Parts of the code (c) Mario Blunk
  28  0000              ; http://www.trainÂ­z.de
  29  0000              ;
  30  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  31  0000              ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  32  0000              ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  33  0000              ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  34  0000              ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  35  0000              ; the original ROM code (checksum A934H). PA
  36  0000              ;
  37  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  38  0000              ; The following code is intended to be used with LM80C Z80-based computer
  39  0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
  40  0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
  41  0000              ; kind of warranty: you can use them at your own risk.
  42  0000              ; You are free to use them for any non-commercial use: you are only asked to
  43  0000              ; maintain the copyright notices, include this advice and the note to the
  44  0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  45  0000              ; redistribuite them.
  46  0000              ; https://www.leonardomiliani.com
  47  0000              ;
  48  0000              ; Please support me by visiting the following links:
  49  0000              ; Main project page: https://www.leonardomiliani.com
  50  0000              ; Schematics and code: https://github.com/leomil72/LM80C
  51  0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  52  0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  53  0000              ; ------------------------------------------------------------------------------
  54  0000              ; set name for binary output file
  55  0000                  OUTPUT "LM80C-64K-firmware-r1.14.bin"
  56  0000
  57  0000              ; set computer model
  58  0000                  DEFINE LM80C64K
  59  0000
  60  0000              ; set firmware version
  61  0000                  DEFINE VERSION "1.14"
  62  0000
  63  0000              ; set DOS version
  64  0000                  DEFINE  DOS_VER "1.03"
  65  0000
  66  0000              ; define shorter VDP_DAT load instruction and additional delay for VDP access
  67  0000                  DEFINE LD_VDP_DAT dec     C
  68  0000                  DEFINE LM64K_NOP nop
  69  0000
  70  0000              ; ------------------------------------------------------------------------------
  71  0000              ; include the latest version of the bootloader: this sets up the address aliases,
  72  0000              ; configure the hardware, checks if warm or cold startup and loads the BASIC interpreter
  73  0000                  INCLUDE "../include/bootloader/bootloader-1.06.asm"
# file opened: ../include/bootloader/bootloader-1.06.asm
   1+ 0000              ; ------------------------------------------------------------------------------
   2+ 0000              ; LM80C - BOOTLOADER - 1.06
   3+ 0000              ; ------------------------------------------------------------------------------
   4+ 0000              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0000              ; kind of warranty: you can use them at your own risk.
   8+ 0000              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0000              ; maintain the copyright notices, include this advice and the note to the
  10+ 0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0000              ; redistribuite them.
  12+ 0000              ; https://www.leonardomiliani.com
  13+ 0000              ;
  14+ 0000              ; Please support me by visiting the following links:
  15+ 0000              ; Main project page: https://www.leonardomiliani.com
  16+ 0000              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0000              ; ------------------------------------------------------------------------------
  20+ 0000
  21+ 0000              ; ADDRESS DECODING (bits A6/A5/A4)
  22+ 0000              ; 0000xxxx : PIO
  23+ 0000              ; 0001xxxx : CTC
  24+ 0000              ; 0010xxxx : SIO
  25+ 0000              ; 0011xxxx : VDP
  26+ 0000              ; 0100xxxx : PSG
  27+ 0000              ; 0101xxxx : C.F.
  28+ 0000
  29+ 0000
  30+ 0000              ; ------------------------------------------------------------------------------
  31+ 0000              ;               EQUATES
  32+ 0000              ; ------------------------------------------------------------------------------
  33+ 0000              ; label defining for PIO (Parallel Input/Output)
  34+ 0000              PIO_DA          equ %00000000
  35+ 0000              PIO_DB          equ %00000001
  36+ 0000              PIO_CA          equ %00000010
  37+ 0000              PIO_CB          equ %00000011
  38+ 0000
  39+ 0000              ; label defining for CTC (Counter Timer Circuit)
  40+ 0000              CTC_CH0         equ %00010000
  41+ 0000              CTC_CH1         equ %00010001
  42+ 0000              CTC_CH2         equ %00010010
  43+ 0000              CTC_CH3         equ %00010011
  44+ 0000
  45+ 0000              ;label defining for SIO (Serial Input/Output)
  46+ 0000              SIO_CA          equ %00100010
  47+ 0000              SIO_CB          equ %00100011
  48+ 0000              SIO_DA          equ %00100000
  49+ 0000              SIO_DB          equ %00100001
  50+ 0000
  51+ 0000              ;label defining for VDP (Video Display Processor)
  52+ 0000              VDP_DAT         equ %00110000
  53+ 0000                  IFDEF LM80C64K
  54+ 0000              VDP_SET         equ %00110001
  55+ 0000                  ELSE
  56+ 0000 ~            VDP_SET         equ %00110010
  57+ 0000                  ENDIF
  58+ 0000
  59+ 0000              ; label defining for PSG (Programmable Sound Generator)
  60+ 0000              PSG_REG         equ %01000000
  61+ 0000              PSG_DAT         equ %01000001
  62+ 0000
  63+ 0000              ; Interrupt-driven serial I/O interface lead by the Z80 SIO to run modified
  64+ 0000              ; NASCOM Basic 4.7 - Full input buffering with incoming data hardware handshaking
  65+ 0000              ; Handshake shows full before the buffer is totally filled to allow run-on from the sender
  66+ 0000              SER_BUFSIZE     equ     $58
  67+ 0000              SER_FULLSIZE    equ     $50
  68+ 0000              SER_EMPTYSIZE   equ     $05
  69+ 0000
  70+ 0000
  71+ 0000              ;------------------------------------------------------------------------------
  72+ 0000              ;                                F I R M W A R E
  73+ 0000              ;------------------------------------------------------------------------------
  74+ 0000              ; BASE MEMORY - RESET LOCATION ($0000) -> the CPU jumps to $0000 after a reset
  75+ 0000                              org     $0000
  76+ 0000 F3           RST00:          di                      ; be sure that INTs are disabled
  77+ 0001                  IFDEF LM80C64K
  78+ 0001 C3 46 5F                     jp      ROM2RAM         ; jump to ROM/RAM switcher
  79+ 0004                  ELSE
  80+ 0004 ~                            jp      INIT_HW         ; jump to system initialization
  81+ 0004                  ENDIF
  82+ 0004
  83+ 0004              ;------------------------------------------------------------------------------
  84+ 0004              ; interrupt vector when SIO ch.B has a char available in its buffer
  85+ 0004                              ;$0004
  86+ 0004 65 01                        defw    RX_CHB_AVAIL
  87+ 0006
  88+ 0006              ;------------------------------------------------------------------------------
  89+ 0006              ; interrupt vector for SIO ch.B special conditions (i.e. buf overrun)
  90+ 0006                              ;$0006
  91+ 0006 68 01                        defw    SPEC_RXB_CNDT
  92+ 0008
  93+ 0008              ;------------------------------------------------------------------------------
  94+ 0008              ; send a character over serial ch. A
  95+ 0008                              ;$0008
  96+ 0008 C3 59 02     RST08:          jp      TXA
  97+ 000B FF                           BLOCK   1,$FF   ; filler
  98+ 000C
  99+ 000C              ;------------------------------------------------------------------------------
 100+ 000C              ; interrupt vector when SIO ch.A has a char available in its buffer
 101+ 000C                              ;$000C
 102+ 000C 00 01                        defw    RX_CHA_AVAIL
 103+ 000E
 104+ 000E              ;------------------------------------------------------------------------------
 105+ 000E              ; interrupt vector for SIO ch.A special conditions (i.e. buf overrun)
 106+ 000E                              ;$000E
 107+ 000E 36 01                        defw    SPEC_RXA_CNDT
 108+ 0010
 109+ 0010              ;------------------------------------------------------------------------------
 110+ 0010              ; receive a character over serial ch. A
 111+ 0010                              ;$0010
 112+ 0010 C3 2A 02     RST10:          jp      RXA
 113+ 0013 FF FF FF...                  BLOCK   5,$FF   ; filler
 114+ 0018              ;------------------------------------------------------------------------------
 115+ 0018              ; check buffer state
 116+ 0018
 117+ 0018                              ;$0018
 118+ 0018 C3 78 02     RST18:          jp      CKINCHAR
 119+ 001B FF FF FF...                  BLOCK   $25,$FF ; filler
 120+ 0040              ;------------------------------------------------------------------------------
 121+ 0040              ; interrupt vectors for CTC
 122+ 0040                              ;$0040               ; for CH0 Timer - used in BASIC by serial 1 for bps
 123+ 0040 5F 61                        defw    CTC0IV
 124+ 0042                              ;$0042               ; for CH1 Timer - used in BASIC by serial 2 for bps
 125+ 0042 62 61                        defw    CTC1IV
 126+ 0044                              ;$0044               ; for CH2 timer - unused
 127+ 0044 65 61                        defw    CTC2IV
 128+ 0046                              ;$0046               ; for CH3 Timer - used by FW for 100ths/s counter
 129+ 0046 68 61                        defw    CTC3IV
 130+ 0048 FF FF FF...                  BLOCK   $1E,$FF ; filler
 131+ 0066              ;------------------------------------------------------------------------------
 132+ 0066              ; interrupt routine for NMI
 133+ 0066                              ;$0066
 134+ 0066 C3 D6 5F                     jp      NMIUSR              ; jump to execute NMI service routine
 135+ 0069 FF FF FF...                  BLOCK   $27,$FF ; filler
 136+ 0090              ;------------------------------------------------------------------------------
 137+ 0090
 138+ 0090                              ;$0090
 139+ 0090                  IFDEF LM80C
 140+ 0090 ~                            defb    $4C,$4D,$38,$30,$43,$20,$43,$4F
 141+ 0090 ~                            defb    $4C,$4F,$52,$00,$00,$00,$00,$00
 142+ 0090                  ELSE
 143+ 0090 4C 4D 38 30                  defb    $4C,$4D,$38,$30,$43,$20,$36,$34
 143+ 0094 43 20 36 34
 144+ 0098 4B 20 43 4F                  defb    $4B,$20,$43,$4F,$4C,$4F,$52,$00
 144+ 009C 4C 4F 52 00
 145+ 00A0                  ENDIF
 146+ 00A0 43 4F 4D 50                  defb    $43,$4F,$4D,$50,$55,$54,$45,$52
 146+ 00A4 55 54 45 52
 147+ 00A8 20 28 32 30                  defb    $20,$28,$32,$30,$32,$31,$29,$00
 147+ 00AC 32 31 29 00
 148+ 00B0 44 65 73 69                  defb    $44,$65,$73,$69,$67,$6E,$65,$64
 148+ 00B4 67 6E 65 64
 149+ 00B8 20 62 79 00                  defb    $20,$62,$79,$00,$00,$00,$00,$00
 149+ 00BC 00 00 00 00
 150+ 00C0 4C 65 6F 6E                  defb    $4C,$65,$6F,$6E,$61,$72,$64,$6F
 150+ 00C4 61 72 64 6F
 151+ 00C8 20 4D 69 6C                  defb    $20,$4D,$69,$6C,$69,$61,$6E,$69
 151+ 00CC 69 61 6E 69
 152+ 00D0 46 57 20 31  FWVER:          defm    "FW ","1.14",$20,"2021-03-17",$20,"12:15:39",$00
 152+ 00D4 2E 31 34 20
 152+ 00D8 32 30 32 31
 152+ 00DC 2D 30 33 2D
 152+ 00E0 31 37 20 31
 152+ 00E4 32 3A 31 35
 152+ 00E8 3A 33 39 00
 153+ 00EC              FMVEREND:       equ     $
 154+ 00EC FF FF FF...                  BLOCK   $100-FMVEREND,$FF   ; filler
 155+ 0100              ;------------------------------------------------------------------------------
 156+ 0100
 157+ 0100              ;-------------------------------------------------------------------------------
 158+ 0100              ;               Z80 SIO CH. A MANAGEMENT
 159+ 0100              ;-------------------------------------------------------------------------------
 160+ 0100
 161+ 0100              ;-------------------------------------------------------------------------------
 162+ 0100              ; interrupt driven routine to get chars from Z80 SIO ch.A
 163+ 0100              ; this is the only serial channel that can print received chars onto the screen
 164+ 0100                              ;$0100
 165+ 0100 F5           RX_CHA_AVAIL:   push    AF              ; store A
 166+ 0101 E5                           push    HL              ; and HL
 167+ 0102 CD 8F 01                     call    A_RTS_OFF       ; disable RTS line
 168+ 0105 DB 20                        in      A,(SIO_DA)      ; read char from RX buffer into A
 169+ 0107 32 B7 61                     ld      (TMPKEYBFR),A   ; store it into the temp key buffer
 170+ 010A CD FD 01                     call    CHARINTOBFR     ; sub-routine to put the char into the input buffer
 171+ 010D D2 31 01                     jp      NC,LVRXCHA      ; if buffer is full, then leave without doing anything else
 172+ 0110 3A B7 61                     ld      A,(TMPKEYBFR)   ; retrieve char
 173+ 0113 32 78 61                     ld      (CHR4VID),A     ; write into buffer for video printing
 174+ 0116 FE 0D                        cp      CR              ; is it RETURN?
 175+ 0118 CA 20 01                     jp      Z,CNTRXCHA      ; yes, continue
 176+ 011B FE 20                        cp      $20             ; is it another control char (code < 32)?
 177+ 011D DA 31 01                     jp      C,LVRXCHA       ; yes, leave w/o printing it on video nor sending back to serial
 178+ 0120 F5           CNTRXCHA:       push    AF              ; store char
 179+ 0121 AF                           xor     A
 180+ 0122 32 B5 61                     ld      (KBDNPT),A      ; a char from serial is like a char printed by BASIC
 181+ 0125 3A 77 61                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 182+ 0128 FE 01                        cp      $01             ; is the print on video on?
 183+ 012A CC 57 07                     call    Z,CHAR2VID      ; yes, print on screen
 184+ 012D F1                           pop     AF              ; retrieve char
 185+ 012E CD 59 02                     call    TXA             ; send back to serial
 186+ 0131 E1           LVRXCHA:        pop     HL              ; retrieve HL
 187+ 0132 F1                           pop     AF              ; and A
 188+ 0133 FB                           ei                      ; re-enable interrupts
 189+ 0134 ED 4D                        reti                    ; and exit
 190+ 0136
 191+ 0136              ;-------------------------------------------------------------------------------
 192+ 0136              ; special SIO ch.A condition (i.e., buffer overrun)
 193+ 0136              ; if buffer overruns then show an error, empty the RX buffer and send
 194+ 0136              ; a break char
 195+ 0136 F5           SPEC_RXA_CNDT:  push    AF              ; store AF
 196+ 0137 CD 8F 01                     call    A_RTS_OFF       ; disable RTS
 197+ 013A CD CB 01                     call    SIO_A_DI        ; disable RX on ch. A
 198+ 013D 3A BD 61                     ld      A,(SERIALS_EN)  ; load serial status
 199+ 0140 CB 97                        res     2,A             ; disable RX on port 1
 200+ 0142 32 BD 61                     ld      (SERIALS_EN),A  ; store new serial status
 201+ 0145 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 202+ 0147 CB E7                        set     4,A             ; set 5th pin ON
 203+ 0149 D3 01                        out     (PIO_DB),A      ; send new setting
 204+ 014B 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 205+ 014D D3 22                        out     (SIO_CA),A      ; send command to SIO
 206+ 014F AF           EMPTYCHABFR:    xor     A
 207+ 0150 D3 22                        out     (SIO_CA),A      ; write to WR0, select RR0
 208+ 0152 DB 22                        in      A,(SIO_CA)      ; read RR0 register
 209+ 0154 E6 01                        and     $01             ; check if input buffer if empty
 210+ 0156 CA 5D 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then leave
 211+ 0159 DB 20                        in      A,(SIO_DA)      ; read chars
 212+ 015B 18 F2                        jr      EMPTYCHABFR     ; repeat
 213+ 015D F1           CHABFREMPTY:    pop     AF              ; retrieve AF
 214+ 015E 21 08 47                     ld      HL,SOERR        ; return point set to Serial Buffer Overrun routine
 215+ 0161 E3                           ex      (SP),HL         ; store onto stack
 216+ 0162 FB                           ei                      ; re-enable interrupts
 217+ 0163 ED 4D                        reti                    ; return from interrupt and execute code at SOERR
 218+ 0165
 219+ 0165              ;-------------------------------------------------------------------------------
 220+ 0165              ;               Z80 SIO CH. A MANAGEMENT
 221+ 0165              ;-------------------------------------------------------------------------------
 222+ 0165
 223+ 0165              ;-------------------------------------------------------------------------------
 224+ 0165              ; interrupt driven routine to get chars from Z80 SIO ch.B
 225+ 0165 FB           RX_CHB_AVAIL:   ei
 226+ 0166 ED 4D                        reti
 227+ 0168
 228+ 0168              ;-------------------------------------------------------------------------------
 229+ 0168              ; special SIO ch.A condition (i.e., buffer overrun)
 230+ 0168              ; if buffer overruns then show an error, empty the RX buffer and send
 231+ 0168              ; a break char
 232+ 0168 F5           SPEC_RXB_CNDT:  push    AF              ; store A
 233+ 0169 CD 97 01                     call    B_RTS_OFF       ; disable RTS
 234+ 016C CD D3 01                     call    SIO_B_DI        ; disable RX on ch.B
 235+ 016F 3A BD 61                     ld      A,(SERIALS_EN)  ; load serial status
 236+ 0172 CB 9F                        res     3,A             ; disable RX on port 2
 237+ 0174 32 BD 61                     ld      (SERIALS_EN),A  ; store new serial status
 238+ 0177 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 239+ 0179 CB EF                        set     5,A             ; set 5th pin ON
 240+ 017B D3 01                        out     (PIO_DB),A      ; send new setting
 241+ 017D 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 242+ 017F D3 23                        out     (SIO_CB),A      ; send command to SIO
 243+ 0181 AF           EMPTYCHBBFR:    xor     A
 244+ 0182 D3 23                        out     (SIO_CB),A      ; write to WR0, select RR0
 245+ 0184 DB 23                        in      A,(SIO_CB)      ; read RR0 register
 246+ 0186 E6 01                        and     $01             ; check if input buffer if empty
 247+ 0188 CA 5D 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then jump to run "exit" code
 248+ 018B DB 21                        in      A,(SIO_DB)      ; read chars
 249+ 018D 18 F2                        jr      EMPTYCHBBFR     ; repeat
 250+ 018F
 251+ 018F
 252+ 018F              ;-------------------------------------------------------------------------------
 253+ 018F              ;               Z80 SIO MANAGEMENT
 254+ 018F              ;-------------------------------------------------------------------------------
 255+ 018F              ; disable RTS:
 256+ 018F              ; by resetting RTS bit (set to 0), the RTS line is disabled (HIGH)
 257+ 018F C5           A_RTS_OFF:      push    BC              ; store BC
 258+ 0190 0E 22                        ld      C,SIO_CA        ; select channel A
 259+ 0192 3A BE 61                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 260+ 0195 18 06                        jr      SIO_RTS_OFF
 261+ 0197 C5           B_RTS_OFF:      push    BC              ; store BC
 262+ 0198 0E 23                        ld      C,SIO_CB        ; select channel B
 263+ 019A 3A BF 61                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 264+ 019D CB 3F        SIO_RTS_OFF:    srl     A               ; position data bits in bits #5&6
 265+ 019F E6 60                        and     %01100000       ; get only bits #5&6
 266+ 01A1 47                           ld      B,A             ; store data bits
 267+ 01A2 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 268+ 01A4 ED 79                        out     (C),A
 269+ 01A6 3E 88                        ld      A,%10001000     ; enable DTR (b7) and TX (b4), disable RTS (b1)
 270+ 01A8 B0                           or      B               ; set data bits
 271+ 01A9 ED 79                        out     (C),A           ; send setting
 272+ 01AB C1                           pop     BC              ; retrieve BC
 273+ 01AC C9                           ret                     ; exit
 274+ 01AD
 275+ 01AD              ;-------------------------------------------------------------------------------
 276+ 01AD              ; enable RTS
 277+ 01AD              ; by setting RTS bit (set to 1), the RTS line is enabled (LOW)
 278+ 01AD C5           A_RTS_ON:       push    BC              ; store BC
 279+ 01AE 0E 22                        ld      C,SIO_CA        ; select channel A
 280+ 01B0 3A BE 61                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 281+ 01B3 18 06                        jr      SIO_RTS_ON
 282+ 01B5 C5           B_RTS_ON:       push    BC              ; store BC
 283+ 01B6 0E 23                        ld      C,SIO_CB        ; select channel B
 284+ 01B8 3A BF 61                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 285+ 01BB CB 3F        SIO_RTS_ON:     srl     A               ; position data bits in bits #5&6
 286+ 01BD E6 60                        and     %01100000       ; get only bits #5&6
 287+ 01BF 47                           ld      B,A             ; store data bits
 288+ 01C0 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 289+ 01C2 ED 79                        out     (C),A
 290+ 01C4 3E 8A                        ld      A,%10001010     ; enable DTR (b7), TX (b4), and RTS (b1)
 291+ 01C6 B0                           or      B               ; set data bits
 292+ 01C7 ED 79                        out     (C),A           ; send setting
 293+ 01C9 C1                           pop     BC              ; retrieve BC
 294+ 01CA C9                           ret                     ; return
 295+ 01CB
 296+ 01CB              ;-------------------------------------------------------------------------------
 297+ 01CB              ; disable SIO RX channel
 298+ 01CB C5           SIO_A_DI:       push    BC              ; store BC
 299+ 01CC 0E 22                        ld      C,SIO_CA        ; SIO channel A
 300+ 01CE 3A BE 61                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 301+ 01D1 18 06                        jr      SIO_RXDI        ; jump to disable RX
 302+ 01D3 C5           SIO_B_DI:       push    BC              ; store BC
 303+ 01D4 0E 23                        ld      C,SIO_CB        ; SIO channel B
 304+ 01D6 3A BF 61                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 305+ 01D9 47           SIO_RXDI:       ld      B,A             ; store data bits
 306+ 01DA 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 307+ 01DC ED 79                        out     (C),A
 308+ 01DE 78                           ld      A,B             ; retrieve data bits; RX disabled; auto enable is OFF
 309+ 01DF ED 79                        out     (C),A
 310+ 01E1 C1                           pop     BC              ; retrieve BC
 311+ 01E2 C9                           ret                     ; return
 312+ 01E3
 313+ 01E3              ;-------------------------------------------------------------------------------
 314+ 01E3              ; enable SIO RX channel
 315+ 01E3 C5           SIO_A_EI:       push    BC              ; store BC
 316+ 01E4 0E 22                        ld      C,SIO_CA
 317+ 01E6 3A BE 61                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 318+ 01E9 18 06                        jr      SIO_RXEN
 319+ 01EB C5           SIO_B_EI:       push    BC              ; store BC
 320+ 01EC 0E 23                        ld      C,SIO_CB
 321+ 01EE 3A BF 61                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 322+ 01F1 47           SIO_RXEN:       ld      B,A             ; store data bits
 323+ 01F2 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 324+ 01F4 ED 79                        out     (C),A           ; select register
 325+ 01F6 78                           ld      A,B             ; retrieve data bits
 326+ 01F7 CB C7                        set     0,A             ; set RX enabled; auto enable is OFF
 327+ 01F9 ED 79                        out     (C),A           ; send settings to SIO
 328+ 01FB C1                           pop     BC              ; retrieve BC
 329+ 01FC C9                           ret
 330+ 01FD
 331+ 01FD              ;------------------------------------------------------------------------------
 332+ 01FD              ; put a char into the input buffer, char is into A
 333+ 01FD              ; this sub is called both from the ISR "RX_CHA_AVAIL" and when
 334+ 01FD              ; the RETURN key is pressed on the keyboard
 335+ 01FD F5           CHARINTOBFR:    push    AF              ; store it
 336+ 01FE 3A D1 5F                     ld      A,(serBufUsed)  ; load buffer size
 337+ 0201 FE 58                        cp      SER_BUFSIZE     ; if buffer is not full
 338+ 0203 DA 08 02                     jp      C,NOTFULL       ; then store the char
 339+ 0206 F1                           pop     AF              ; else drop it
 340+ 0207 C9                           ret                     ; and exit
 341+ 0208 2A CD 5F     NOTFULL:        ld      HL,(serInPtr)   ; buffer is not full, can store the char
 342+ 020B 23                           inc     HL              ; load pointer to find first free cell
 343+ 020C 7D                           ld      A,L             ; only check low byte because buffer<256
 344+ 020D FE CD                        cp      bufWrap         ; check if the pointer is at the last cell
 345+ 020F 20 03                        jr      NZ,NOTWRAP      ; if not then continue
 346+ 0211 21 75 5F                     ld      HL,SERBUF_START ; else load the address of the first cell
 347+ 0214 22 CD 5F     NOTWRAP:        ld      (serInPtr),HL   ; store the new pointer
 348+ 0217 F1                           pop     AF              ; then retrieve the char...
 349+ 0218 77                           ld      (HL),A          ; ...and store it in the appropriate cell
 350+ 0219 21 D1 5F                     ld      HL,serBufUsed   ; size of the input buffer
 351+ 021C 34                           inc     (HL)            ; increment it
 352+ 021D 3E 50                        ld      A,SER_FULLSIZE  ; input buffer capacity
 353+ 021F BE                           cp      (HL)            ; check if input buffer is full
 354+ 0220 D8                           ret     C               ; exit if buffer is not full
 355+ 0221 3A BD 61                     ld      A,(SERIALS_EN)  ; check if serial 1 is open
 356+ 0224 1F                           rra                     ; bit 0 into Carry: if Carry is 1 then serial 0 is open and...
 357+ 0225 DC 8F 01                     call    C,A_RTS_OFF     ; ...receiving further chars must be stopped
 358+ 0228 37                           scf                     ; set Carry flag, because  we must inform that the char has been added before to disable RTS
 359+ 0229 C9                           ret
 360+ 022A
 361+ 022A
 362+ 022A              ;-------------------------------------------------------------------------------
 363+ 022A              ; retrieve a char from the input buffer
 364+ 022A 3A D1 5F     RXA:            ld      A,(serBufUsed)  ; load the buffer size
 365+ 022D A7                           and     A               ; check if it's 0 (empty)
 366+ 022E CA 2A 02                     jp      Z,RXA           ; if it's empty, wait for a char
 367+ 0231 F3                           di                      ; disable interrupts
 368+ 0232 E5                           push    HL              ; store HL
 369+ 0233 2A CF 5F                     ld      HL,(serRdPtr)   ; load pointer to first available char
 370+ 0236 23                           inc     HL              ; increment it (go to the next char)
 371+ 0237 7D                           ld      A,L             ; check if the end of the buffer has been reached
 372+ 0238 FE CD                        cp      bufWrap         ; (only check low byte because buffer<256)
 373+ 023A 20 03                        jr      NZ,NOTRDWRAP    ; if not, jump straight
 374+ 023C 21 75 5F                     ld      HL,SERBUF_START ; else reload the starting address of the buffer
 375+ 023F 22 CF 5F     NOTRDWRAP:      ld      (serRdPtr),HL   ; store new pointer to the next char to read
 376+ 0242 3A D1 5F                     ld      A,(serBufUsed)  ; load buffer size
 377+ 0245 3D                           dec     A               ; decrement it
 378+ 0246 32 D1 5F                     ld      (serBufUsed),A  ; and store the new size
 379+ 0249 FE 05                        cp      SER_EMPTYSIZE   ; check if input buffer can be considered empty
 380+ 024B 30 08                        jr      NC,RXA_EXIT     ; if not empty yet, then exit
 381+ 024D 3A BD 61                     ld      A,(SERIALS_EN)  ; load serial state
 382+ 0250 EE 05                        xor     %00000101       ; check if serial 1 is open and RX enabled
 383+ 0252 CC AD 01                     call    Z,A_RTS_ON      ; yes, set RTS on
 384+ 0255 7E           RXA_EXIT:       ld      A,(HL)          ; recover the char and return it into A
 385+ 0256 E1                           pop     HL              ; retrieve HL
 386+ 0257 FB                           ei                      ; re-enable interrupts
 387+ 0258 C9                           ret                     ; return
 388+ 0259
 389+ 0259              ;------------------------------------------------------------------------------
 390+ 0259              ; sends a char over the serial - char is into A
 391+ 0259 F5           TXA:            push    AF              ; store AF
 392+ 025A C5                           push    BC              ; store BC
 393+ 025B 47                           ld      B,A             ; store char
 394+ 025C 3A BD 61                     ld      A,(SERIALS_EN)  ; load serial status
 395+ 025F EE 05                        xor     %00000101       ; check if serial 1 is open and RX is enabled
 396+ 0261 20 06                        jr      NZ,TXA_EXIT     ; no, jump over
 397+ 0263 78                           ld      A,B             ; retrieve char
 398+ 0264 D3 20                        out     (SIO_DA),A      ; send char to the SIO
 399+ 0266 CD 6C 02                     call    TX_EMP          ; wait for outgoing char to be sent
 400+ 0269 C1           TXA_EXIT:       pop     BC              ; retrieve BC
 401+ 026A F1                           pop     AF              ; retrieve AF
 402+ 026B C9                           ret                     ; return
 403+ 026C
 404+ 026C              ;------------------------------------------------------------------------------
 405+ 026C              ; wait until outgoing serial has been sent
 406+ 026C 97           TX_EMP:         sub     A               ; set A to 0
 407+ 026D 3C                           inc     A               ; set A to 1
 408+ 026E D3 22                        out     (SIO_CA),A      ; write to WR0, select RR1
 409+ 0270 DB 22                        in      A,(SIO_CA)      ; read RR1 register
 410+ 0272 CB 47                        bit     0,A             ; check if all chars have been sent
 411+ 0274 CA 6C 02                     jp      Z,TX_EMP        ; if not (bit 0 = 0) then retrieve
 412+ 0277 C9                           ret                     ; else exit
 413+ 0278
 414+ 0278
 415+ 0278              ;------------------------------------------------------------------------------
 416+ 0278              ; check if there is some chars into the buffer
 417+ 0278 3A D1 5F     CKINCHAR:       ld      A,(serBufUsed)  ; load buffer size
 418+ 027B A7                           and     A               ; compare to 0
 419+ 027C C9                           ret                     ; return
 420+ 027D
 421+ 027D              ;------------------------------------------------------------------------------
 422+ 027D              ; print a text from memory, and terminate when $00 is found
 423+ 027D 7E           RAWPRINT:       ld      A,(HL)          ; load character from memory cell pointed by HL
 424+ 027E B7                           or      A               ; is it $00 (end string)?
 425+ 027F C8                           ret     Z               ; Yes, then return
 426+ 0280 32 78 61                     ld      (CHR4VID),A     ; store char
 427+ 0283 F3                           di
 428+ 0284 CD 57 07                     call    CHAR2VID        ; and send it to screen
 429+ 0287 FB                           ei
 430+ 0288 23                           inc     HL              ; and select the next one
 431+ 0289 18 F2                        jr      RAWPRINT        ; repeat
 432+ 028B
 433+ 028B              ;-------------------------------------------------
 434+ 028B              ; Interrupt service routine (ISR) for CH3 timer
 435+ 028B              ; this is used to increment the 100ths of a second counter and for cursor flashing
 436+ 028B F5           CH3_TIMER:      push    AF              ; save regs. A,
 437+ 028C C5                           push    BC              ; BC,
 438+ 028D D5                           push    DE              ; DE,
 439+ 028E E5                           push    HL              ; HL
 440+ 028F 21 5B 61                     ld      HL,TMRCNT       ; load starting address of the timer
 441+ 0292 06 04                        ld      B,$04           ; 4 bytes to check
 442+ 0294 34           INCTMR3:        inc     (HL)            ; increment timer
 443+ 0295 20 03                        jr      NZ,CHKCRSR      ; if not zero then exit (finished increment)
 444+ 0297 23                           inc     HL              ; if yes, there was an overflow, so increment next byte
 445+ 0298 10 FA                        djnz    INCTMR3         ; repeat for 4 bytes
 446+ 029A CD C1 07     CHKCRSR:        call    FLASHCURSOR     ; call the flashing cursor routine
 447+ 029D CD E9 0C                     call    MNGSNDS         ; call the tone managemenet
 448+ 02A0 3A 5B 61                     ld      A,(TMRCNT)      ; check for keyboard management
 449+ 02A3 1F                           rra                     ; bit 0 = 1 ?
 450+ 02A4 D4 4E 0D                     call    NC,KEYBOARD     ; no, so read the keyboard inputs
 451+ 02A7 E1                           pop     HL              ; retrieve HL,
 452+ 02A8 D1                           pop     DE              ; DE,
 453+ 02A9 C1                           pop     BC              ; BC,
 454+ 02AA F1                           pop     AF              ; and A
 455+ 02AB FB                           ei                      ; re-enable interrupts
 456+ 02AC ED 4D                        reti                    ; exit from ISR
 457+ 02AE
 458+ 02AE              ;------------------------------------------------------------------------------
 459+ 02AE              ;               HARDWARE INITIALISATION
 460+ 02AE              ;------------------------------------------------------------------------------
 461+ 02AE              ; first run - setup HW & SW
 462+ 02AE              ; (on LN80C 64K runs from RAM)
 463+ 02AE 21 04 61     INIT_HW:        ld      HL,TEMPSTACK    ; load temp stack pointer
 464+ 02B1 F9           INIT_HW2:       ld      SP,HL           ; set stack to temp stack pointer
 465+ 02B2 21 75 5F                     ld      HL,SERBUF_START ; set beginning of input buffer
 466+ 02B5 22 CD 5F                     ld      (serInPtr),HL   ; for incoming chars to store into buffer
 467+ 02B8 22 CF 5F                     ld      (serRdPtr),HL   ; and for chars to be read from buffer
 468+ 02BB AF                           xor     A               ; reset A
 469+ 02BC 32 D1 5F                     ld      (serBufUsed),A  ; actual buffer size is 0
 470+ 02BF 32 BD 61                     ld      (SERIALS_EN),A  ; set serial ports status to OFF
 471+ 02C2                  IFDEF LM80C
 472+ 02C2 ~                            call    HELLOWRLD       ; little serial blink with LEDs
 473+ 02C2                  ENDIF
 474+ 02C2 CD 40 03                     call    initCTC         ; configure CTC, then...
 475+ 02C5 CD 87 0C                     call    initPSG         ; ...configure PSG
 476+ 02C8 CD F2 04                     call    SHOW_LOGO       ; show computer logo
 477+ 02CB 1E 01                        ld      E,$01           ; E chooses the video mode (graphics 1)
 478+ 02CD CD D1 03                     call    initVDP         ; set video display
 479+ 02D0 AF                           xor     A
 480+ 02D1 ED 47                        ld      I,A             ; set high byte of interrupt vectors to point to page 0
 481+ 02D3 ED 5E                        im      2               ; interrupt mode 2
 482+ 02D5 FB                           ei                      ; enable interrupts
 483+ 02D6                              ; print system messages
 484+ 02D6 AF                           xor     A               ; A=0 so...
 485+ 02D7 32 B5 61                     ld      (KBDNPT),A      ; ...inputs don't come from keyboard
 486+ 02DA 3C                           inc     A               ; A=1...
 487+ 02DB 32 77 61                     ld      (PRNTVIDEO),A   ; ...to activate the print-on-video
 488+ 02DE 21 76 03                     ld      HL,MSGTXT1      ; sign-on message
 489+ 02E1 CD 7D 02                     call    RAWPRINT        ; print message
 490+ 02E4 3A D2 5F                     ld      A,(basicStarted); check if BASIC is already started
 491+ 02E7 FE 59                        cp      'Y'             ; to see if this is a power-up
 492+ 02E9 20 19                        jr      NZ,COLDSTART    ; if not, then do a COLD start
 493+ 02EB 21 B4 03                     ld      HL,MSGTXT2      ; message to choose kind of start
 494+ 02EE CD 7D 02                     call    RAWPRINT        ; print message
 495+ 02F1 CD 23 09                     call    CURSOR_ON       ; enable cursor
 496+ 02F4 AF                           xor     A
 497+ 02F5 32 77 61                     ld      (PRNTVIDEO),A   ; disable print-on-video
 498+ 02F8 CD 2A 02     CORW:           call    RXA             ; look for a pressed key
 499+ 02FB E6 DF                        and     %11011111       ; only UPPERCASE char
 500+ 02FD FE 43                        cp      'C'             ; cold start?
 501+ 02FF 20 0E                        jr      NZ,CHECKWARM    ; no, let's check for warm start
 502+ 0301 CD 1C 03                     call    ECHO_CHAR       ; echoes the char
 503+ 0304 3E 59        COLDSTART:      ld      A,'Y'           ; yes, set the "BASIC started" flag
 504+ 0306 32 D2 5F                     ld      (basicStarted),A
 505+ 0309 CD 38 09                     call    CURSOR_OFF      ; disable cursor
 506+ 030C C3 79 1B                     jp      COLD            ; start BASIC COLD
 507+ 030F FE 57        CHECKWARM:      cp      'W'
 508+ 0311 20 E5                        jr      NZ,CORW         ; char not recognized, wait again
 509+ 0313 CD 1C 03                     call    ECHO_CHAR       ; echoes the char
 510+ 0316 CD 38 09                     call    CURSOR_OFF      ; disable cursor
 511+ 0319 C3 7C 1B                     jp      WARM            ; start BASIC WARM
 512+ 031C
 513+ 031C              ;-------------------------------------------------------------------------------
 514+ 031C              ; send back char received through ch. A
 515+ 031C 32 78 61     ECHO_CHAR:      ld      (CHR4VID),A     ; set char for video printing
 516+ 031F AF                           xor     A
 517+ 0320 32 B5 61                     ld      (KBDNPT),A      ; input is not from keyboard
 518+ 0323 F3                           di                      ; disable INTs
 519+ 0324 CD 57 07                     call    CHAR2VID        ; echoes back the pressed key,
 520+ 0327 3E 0D                        ld      A,CR            ; then set a CR
 521+ 0329 32 78 61                     ld      (CHR4VID),A     ; set char for video printing
 522+ 032C CD 57 07                     call    CHAR2VID        ; and send it to screen
 523+ 032F FB                           ei                      ; re-enable INTs
 524+ 0330 3E 01                        ld      A,$01
 525+ 0332 32 77 61                     ld      (PRNTVIDEO),A   ; re-enable video printing
 526+ 0335 C9                           ret                     ; return to caller
 527+ 0336
 528+ 0336                  IFDEF LM80C
 529+ 0336 ~            ;-------------------------------------------------------------------------------
 530+ 0336 ~            ; little serial blink with LEDs
 531+ 0336 ~            HELLOWRLD:      ld      C,$09           ; 8 LEDs to be turned off + 1 more step to turn off the last LED
 532+ 0336 ~                            ld      A,%11001111     ; set mode 3 (mode control)
 533+ 0336 ~                            out     (PIO_CB),A      ; for PIO port B
 534+ 0336 ~                            xor     A               ; set pins to OUTPUT
 535+ 0336 ~                            out     (PIO_CB),A      ; for port B
 536+ 0336 ~                            inc     A               ; LSB on
 537+ 0336 ~            LEDLIGHT:       out     (PIO_DB),A      ; turn LEDs on/off for a "Supercar" sequence
 538+ 0336 ~                            ld      E,$20           ; little delay
 539+ 0336 ~            DEC_E:          ld      B,$00           ; count to 256
 540+ 0336 ~            COUNTER:        djnz    COUNTER         ; decrement inner counter
 541+ 0336 ~                            dec     E               ; decrement outer counter
 542+ 0336 ~                            jr      NZ,DEC_E        ; finish delay
 543+ 0336 ~                            sla     A               ; shift reg.A to left 1 bit
 544+ 0336 ~                            dec     C               ; next LED
 545+ 0336 ~                            jr      NZ,LEDLIGHT     ; all LEDs done? no, repeat
 546+ 0336 ~                            ret                     ; return to caller
 547+ 0336                  ENDIF
 548+ 0336              ;-------------------------------------------------------------------------------
 549+ 0336              ; Z80 SIO default settings for serial channels
 550+ 0336 30           SIO_A_SETS:     defb    %00110000       ; write into WR0: error reset, select WR0
 551+ 0337 18                           defb    %00011000       ; write into WR0: channel reset
 552+ 0338 04                           defb    %00000100       ; write into WR0: select WR4
 553+ 0339 44                           defb    %01000100       ; write into WR4: presc. 16x, 1 stop bit, no parity
 554+ 033A 05                           defb    %00000101       ; write into WR0: select WR5
 555+ 033B E8                           defb    %11101000       ; write into WR5: DTR on, TX 8 bits, BREAK off, TX on, RTS off
 556+ 033C 01           SIO_B_SETS:     defb    %00000001       ; write into WR0: select WR1
 557+ 033D 04                           defb    %00000100       ; write into WR1: status affects interrupt vectors
 558+ 033E 02                           defb    %00000010       ; write into WR0: select WR2
 559+ 033F 00                           defb    %00000000       ; write into WR2: set interrupt vector, but bits D3/D2/D1 of this vector
 560+ 0340                                                      ; will be affected by the channel & condition that raised the interrupt
 561+ 0340                                                      ; (see datasheet): in our example, 0x0C for Ch.A receiving A char, 0x0E
 562+ 0340                                                      ; for special conditions
 563+ 0340              ;------------------------------------------------------------------------------
 564+ 0340              ;               Z80 CTC SETTING UP
 565+ 0340              ;------------------------------------------------------------------------------
 566+ 0340              initCTC:
 567+ 0340 21 6A 03                     ld      HL,CTCCONF      ; CTC configuration
 568+ 0343 11 5F 61                     ld      DE,CTC0IV       ; CTC interrupt vector table
 569+ 0346 01 0C 00                     ld      BC,$000C        ; 12 bytes
 570+ 0349 ED B0                        ldir                    ; copy data
 571+ 034B              ;CH0, CH1, & CH2 disabled
 572+ 034B 3E 03                        ld      A,%00000011     ; interrupt off, timer mode, prescaler=16, don't care ext. TRG edge,
 573+ 034D                                                      ; start timer on loading constant, no time constant follows, software reset, command word
 574+ 034D D3 10                        out     (CTC_CH0),A     ; set CH0
 575+ 034F D3 11                        out     (CTC_CH1),A     ; set CH1
 576+ 0351 D3 12                        out     (CTC_CH2),A     ; set CH2
 577+ 0353              ;init CH3
 578+ 0353              ;CH3 divides CPU CLK by 144*256 providing an interrupt signal at 100 Hz (1/100 sec).
 579+ 0353              ;f = CPU_CLK/(144*256) => 3,686,400 / ( 36,864 ) => 100Hz
 580+ 0353 3E A7                        ld      A,%10100111     ; interrupt on; timer mode; prescaler=256; don't care ext; automatic trigger;
 581+ 0355                                                      ; time constant follows; cont. operation; command word
 582+ 0355 D3 13                        out     (CTC_CH3),A     ; send to CH3
 583+ 0357 3E 90                        ld      A,$90           ; time constant - 90$ (144d)
 584+ 0359 D3 13                        out     (CTC_CH3),A     ; send to CH3
 585+ 035B 3E 40                        ld      A,%01000000     ; D7..D3 provide the first part of the int vector (in our case, $0100), followed by
 586+ 035D                                                      ; D2..D1, provided by the CTC (they point to the channel), D0=interrupt word
 587+ 035D                                                      ; so int vector is 01000xx00
 588+ 035D D3 10                        out     (CTC_CH0),A     ; send to CTC
 589+ 035F                              ; reset cells of 100ths of a second counter
 590+ 035F AF                           xor     A               ; reset A
 591+ 0360 21 5B 61                     ld      HL,TMRCNT       ; load TMR pointer
 592+ 0363 06 04                        ld      B,$04           ; 4 memory cells
 593+ 0365 77           RESTMR:         ld      (HL),A          ; reset n-cell of TMR
 594+ 0366 23                           inc     HL              ; next cell
 595+ 0367 10 FC                        djnz    RESTMR          ; repeat for 4 cells
 596+ 0369 C9                           ret
 597+ 036A
 598+ 036A
 599+ 036A              ;------------------------------------------------------------------------------
 600+ 036A              ; jump table for CHx interrupts
 601+ 036A FB ED 4D     CTCCONF:        defb    $FB,$ED,$4D     ; CTC0 interrupt vector (ei; reti)
 602+ 036D FB ED 4D                     defb    $FB,$ED,$4D     ; CTC1 interrupt vector (ei; reti)
 603+ 0370 FB ED 4D                     defb    $FB,$ED,$4D     ; CTC2 interrupt vector (ei; reti)
 604+ 0373 C3 8B 02                     jp      CH3_TIMER       ; CTC3 interrupt vector (jump to execute sys-tick timer)
 605+ 0376
 606+ 0376
 607+ 0376              ;------------------------------------------------------------------------------
 608+ 0376              ; welcome messages
 609+ 0376              MSGTXT1:
 610+ 0376                  IFDEF LM80C64K
 611+ 0376 20 20 20 20                  defm    "    LM80C 64K Color Computer",CR
 611+ 037A 4C 4D 38 30
 611+ 037E 43 20 36 34
 611+ 0382 4B 20 43 6F
 611+ 0386 6C 6F 72 20
 611+ 038A 43 6F 6D 70
 611+ 038E 75 74 65 72
 611+ 0392 0D
 612+ 0393                  ELSE
 613+ 0393 ~                            defm    "      LM80C Color Computer",CR
 614+ 0393                  ENDIF
 615+ 0393 20 62 79 20                  defm    " by Leonardo Miliani * FW R","1.14",CR,0
 615+ 0397 4C 65 6F 6E
 615+ 039B 61 72 64 6F
 615+ 039F 20 4D 69 6C
 615+ 03A3 69 61 6E 69
 615+ 03A7 20 2A 20 46
 615+ 03AB 57 20 52 31
 615+ 03AF 2E 31 34 0D
 615+ 03B3 00
 616+ 03B4 0D           MSGTXT2:        defb    CR
 617+ 03B5 20 20 20 3C                  defm    "   <C>old or <W>arm start? ",0
 617+ 03B9 43 3E 6F 6C
 617+ 03BD 64 20 6F 72
 617+ 03C1 20 3C 57 3E
 617+ 03C5 61 72 6D 20
 617+ 03C9 73 74 61 72
 617+ 03CD 74 3F 20 00
 618+ 03D1
# file closed: ../include/bootloader/bootloader-1.06.asm
  74  03D1
  75  03D1              ; incude the latest version of the VDP module
  76  03D1                  INCLUDE "../include/vdp/vdp-1.5.asm"
# file opened: ../include/vdp/vdp-1.5.asm
   1+ 03D1              ; ------------------------------------------------------------------------------
   2+ 03D1              ; LM80C - VDP ROUTINES - 1.5
   3+ 03D1              ; ------------------------------------------------------------------------------
   4+ 03D1              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 03D1              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 03D1              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 03D1              ; kind of warranty: you can use them at your own risk.
   8+ 03D1              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 03D1              ; maintain the copyright notices, include this advice and the note to the
  10+ 03D1              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 03D1              ; redistribuite them.
  12+ 03D1              ; https://www.leonardomiliani.com
  13+ 03D1              ;
  14+ 03D1              ; Please support me by visiting the following links:
  15+ 03D1              ; Main project page: https://www.leonardomiliani.com
  16+ 03D1              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 03D1              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 03D1              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 03D1              ; ------------------------------------------------------------------------------
  20+ 03D1              ;
  21+ 03D1              ;------------------------------------------------------------------------------
  22+ 03D1              ; VDP INITIALISATION
  23+ 03D1              ; initialize VDP for a specific graphics mode
  24+ 03D1              ; INPUT: E -> contains the graphics mode:
  25+ 03D1              ; 0=text; 1=graphics 1; 2=graphics 2; 3=multicolor; 4=extended graphics 2
  26+ 03D1 D5           initVDP:        push    DE              ; store E
  27+ 03D2 CD C5 0A                     call    EMPTY_VRAM      ; reset VRAM
  28+ 03D5 CD E3 0A                     call    SET_GFX_MODE    ; load register settings
  29+ 03D8 CD D8 0A                     call    CLR_RAM_REG     ; reset RAM registers
  30+ 03DB D1                           pop     DE              ; restore reg. E
  31+ 03DC AF                           xor     A               ; reset A
  32+ 03DD 47                           ld      B,A             ; reset B (will be used later)
  33+ 03DE 7B                           ld      A,E             ; move E into A
  34+ 03DF 32 6D 61                     ld      (SCR_MODE),A    ; store screen mode
  35+ 03E2 FE 01                        cp      $01             ; is it graphics 1 (A=1)?
  36+ 03E4 CA 20 04                     jp      Z,G1MD          ; yes, jump over
  37+ 03E7 FE 02                        cp      $02             ; is it graphics 2 (A=2)?
  38+ 03E9 CA 60 04                     jp      Z,G2MD          ; yes, jump over
  39+ 03EC FE 03                        cp      $03             ; is it multicolor (A=3)?
  40+ 03EE CA 82 04                     jp      Z,MCMD          ; yes, jump over
  41+ 03F1 FE 04                        cp      $04             ; is it extended graphics 2 (A=4)?
  42+ 03F3 CA A5 04                     jp      Z,EXG2MD        ; yes, jump over
  43+ 03F6                              ; otherwise, it must be $00 so we assume that it's text mode
  44+ 03F6
  45+ 03F6              ; LOAD VDP SETTINGS FOR SELECTED VIDEO MODE:
  46+ 03F6
  47+ 03F6                              ; TEXT MODE (G0)
  48+ 03F6                              ; load charset
  49+ 03F6 60           TXTMD:          ld      H,B
  50+ 03F7 68                           ld      L,B             ; HL=first pattern cell $0000
  51+ 03F8 CD FF 0A                     call    LOADCHARSET     ; load patterns into VRAM
  52+ 03FB                              ; set cursor & video overlay
  53+ 03FB AF                           xor     A               ; reset A
  54+ 03FC 32 70 61                     ld      (SCR_CURS_X),A  ; set cursor position at X=0
  55+ 03FF 32 71 61                     ld      (SCR_CURS_Y),A  ; and Y=0
  56+ 0402 3E 05                        ld      A,$05           ; light blue
  57+ 0404 32 7A 61                     ld      (BKGNDCLR),A    ; set background/border color
  58+ 0407 3E 28                        ld      A,$28
  59+ 0409 32 6B 61                     ld      (SCR_SIZE_W),A  ; screen width = 40 cols
  60+ 040C 3E 18                        ld      A,$18
  61+ 040E 32 6C 61                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  62+ 0411 3E 1E                        ld      A,$1E
  63+ 0413 32 18 60                     ld      (COMMAN),A      ; width for commas (4 columns)
  64+ 0416 11 00 08                     ld      DE,$0800
  65+ 0419 ED 53 6E 61                  ld      (SCR_NAM_TB),DE ; set name table address
  66+ 041D C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
  67+ 0420
  68+ 0420                              ; GRAPHICS 1 MODE (G1)
  69+ 0420                              ; load pattern table
  70+ 0420 68           G1MD:           ld      L,B
  71+ 0421 60                           ld      H,B             ; HL=first pattern cell $0000
  72+ 0422 CD FF 0A                     call    LOADCHARSET     ; load patterns into VRAM
  73+ 0425                              ; set cursor & video overlay
  74+ 0425 AF                           xor     A               ; position cursor
  75+ 0426 32 70 61                     ld      (SCR_CURS_X),A  ; at X=0
  76+ 0429 32 71 61                     ld      (SCR_CURS_Y),A  ; and Y=0
  77+ 042C 3E 20                        ld      A,$20
  78+ 042E 32 6B 61                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
  79+ 0431 3E 18                        ld      A,$18
  80+ 0433 32 6C 61                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  81+ 0436 3E 14                        ld      A,$14
  82+ 0438 32 18 60                     ld      (COMMAN),A      ; width for commas (3 columns)
  83+ 043B 11 00 18                     ld      DE,$1800
  84+ 043E ED 53 6E 61                  ld      (SCR_NAM_TB),DE ; set name table address
  85+ 0442                              ; load color table
  86+ 0442 21 00 20                     ld      HL,$2000        ; color table start: $2000
  87+ 0445 CD 66 06                     call    SETVDPADRS
  88+ 0448 3E 01                        ld      A,$01           ; foreground color...
  89+ 044A 32 79 61                     ld      (FRGNDCLR),A    ; ...set to black
  90+ 044D 3E 0F                        ld      A,$0F           ; background color...
  91+ 044F 32 7A 61                     ld      (BKGNDCLR),A    ; ...set to white
  92+ 0452 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
  93+ 0454 06 20                        ld      B,$20           ; 32 bytes of colors
  94+ 0456 0D                           dec     C              ; VDP data mode
  95+ 0457 ED 79        LDCLRTBMD1:     out     (C),A           ; after the first byte, the VDP autoincrements VRAM pointer
  96+ 0459 00                           nop
  97+ 045A 00                           nop
  98+ 045B 10 FA                        djnz    LDCLRTBMD1      ; repeat for 32 bytes
  99+ 045D C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 100+ 0460
 101+ 0460                              ; GRAPHICS 2 MODE (G2)
 102+ 0460 AF           G2MD:           xor     A               ; position cursor
 103+ 0461 32 70 61                     ld      (SCR_CURS_X),A  ; at X=0
 104+ 0464 32 71 61                     ld      (SCR_CURS_Y),A  ; and Y=0
 105+ 0467 32 6B 61                     ld      (SCR_SIZE_W),A  ; screen width = 256 pixels (0=256)
 106+ 046A 3C                           inc     A               ; black on...
 107+ 046B 32 79 61                     ld      (FRGNDCLR),A    ; ...foreground
 108+ 046E 3E 0F                        ld      A,$0F           ; white on...
 109+ 0470 32 7A 61                     ld      (BKGNDCLR),A    ; ...background
 110+ 0473 3E C0                        ld      A,$C0
 111+ 0475 32 6C 61                     ld      (SCR_SIZE_H),A  ; screen height = 192 pixels
 112+ 0478 11 00 18                     ld      DE,$1800
 113+ 047B ED 53 6E 61                  ld      (SCR_NAM_TB),DE ; set name table address
 114+ 047F C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 115+ 0482
 116+ 0482                              ; MULTICOLOR MODE (G3)
 117+ 0482 AF           MCMD:           xor     A               ; position cursor
 118+ 0483 32 70 61                     ld      (SCR_CURS_X),A  ; at X=0
 119+ 0486 32 71 61                     ld      (SCR_CURS_Y),A  ; and Y=0
 120+ 0489 3E 0F                        ld      A,$0F           ; white color for...
 121+ 048B 32 7A 61                     ld      (BKGNDCLR),A    ; ...background and...
 122+ 048E 32 79 61                     ld      (FRGNDCLR),A    ; ...foreground (even this is not used in MC)
 123+ 0491 3E 40                        ld      A,$40
 124+ 0493 32 6B 61                     ld      (SCR_SIZE_W),A  ; screen width = 64 blocks
 125+ 0496 3E 30                        ld      A,$30
 126+ 0498 32 6C 61                     ld      (SCR_SIZE_H),A  ; screen height = 48 blocks
 127+ 049B 11 00 08                     ld      DE,$0800
 128+ 049E ED 53 6E 61                  ld      (SCR_NAM_TB),DE ; set name table address
 129+ 04A2 C3 E7 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 130+ 04A5
 131+ 04A5                              ; EXTENDED GRAPHICS 2 (G4)
 132+ 04A5              EXG2MD:         ; load pattern table
 133+ 04A5 60                           ld      H,B
 134+ 04A6 68                           ld      L,B             ; HL=first pattern cell $0000
 135+ 04A7 CD FF 0A                     call    LOADCHARSET     ; load patterns into VRAM
 136+ 04AA                              ; set cursor & video overlay
 137+ 04AA AF                           xor     A               ; position cursor
 138+ 04AB 32 70 61                     ld      (SCR_CURS_X),A  ; at X=0
 139+ 04AE 32 71 61                     ld      (SCR_CURS_Y),A  ; and Y=0
 140+ 04B1 3E 20                        ld      A,$20
 141+ 04B3 32 6B 61                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
 142+ 04B6 3E 18                        ld      A,$18
 143+ 04B8 32 6C 61                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
 144+ 04BB 3E 14                        ld      A,$14
 145+ 04BD 32 18 60                     ld      (COMMAN),A      ; width for commas (3 columns)
 146+ 04C0 11 00 38                     ld      DE,$3800
 147+ 04C3 ED 53 6E 61                  ld      (SCR_NAM_TB),DE ; set name table address
 148+ 04C7                               ; load color table
 149+ 04C7 21 00 20                     ld      HL,$2000        ; color table start: $2000
 150+ 04CA CD 66 06                     call    SETVDPADRS
 151+ 04CD 3E 01                        ld      A,$01           ; foreground color is...
 152+ 04CF 32 79 61                     ld      (FRGNDCLR),A    ; ...set to black
 153+ 04D2 3E 0F                        ld      A,$0F           ; whitefor...
 154+ 04D4 32 7A 61                     ld      (BKGNDCLR),A    ; ...background
 155+ 04D7 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
 156+ 04D9 16 08                        ld      D,$08           ; 8 pages of
 157+ 04DB 06 00                        ld      B,$00           ; 256 bytes of colors (total of 2,048 cells)
 158+ 04DD 0D                           dec     C              ; VDP data mode
 159+ 04DE ED 79        LDCLRTBEX2:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
 160+ 04E0 00                           nop
 161+ 04E1 00                           nop
 162+ 04E2 10 FA                        djnz    LDCLRTBEX2      ; repeat for 256 bytes
 163+ 04E4 15                           dec     D               ; did we fill up all the cells?
 164+ 04E5 20 F7                        jr      NZ,LDCLRTBEX2   ; no, repeat
 165+ 04E7                              ; LAST VDP SETTINGS
 166+ 04E7 CD 38 09     ENDVDPSET:      call    CURSOR_OFF      ; disable cursor
 167+ 04EA CD D8 05                     call    EMPTYVIDBUF     ; empty video buffer
 168+ 04ED AF                           xor     A
 169+ 04EE 32 74 61                     ld      (SCR_ORG_CHR),A ; store byte used tochar used to empty the video buffer
 170+ 04F1 C9                           ret                     ; return to caller
 171+ 04F2
 172+ 04F2
 173+ 04F2              ; show initial logo
 174+ 04F2 CD C5 0A     SHOW_LOGO:      call    EMPTY_VRAM      ; reset VRAM
 175+ 04F5                              ; set VDP for G2 mode
 176+ 04F5 06 07                        ld      B,$07           ; set only the first 7 registers
 177+ 04F7 11 10 00                     ld      DE,$0010        ; load settings for G2 mode
 178+ 04FA CD EB 0A                     call    SET_GFX_MODE2   ; load register settings
 179+ 04FD 16 01                        ld      D,$01           ; backdrop color set to black
 180+ 04FF ED 51                        out     (C),D           ; send data to VDP
 181+ 0501 ED 79                        out     (C),A           ; indicate the register to send data to
 182+ 0503                              ; set name table
 183+ 0503 21 00 18                     ld      HL,$1800        ; name table address
 184+ 0506 CD 54 06                     call    SETNAMETABLE    ; set name table (load names into table)
 185+ 0509 CD 6C 05                     call    ERASECLRTBL     ; erase color table (set foreground & background to black)
 186+ 050C                              ; set colors for logo
 187+ 050C 21 00 28                     ld      HL,$2800        ; 2nd page of color table
 188+ 050F CD 66 06                     call    SETVDPADRS
 189+ 0512 06 05                        ld      B,$05           ; 5 bands
 190+ 0514 21 B7 05                     ld      HL,CLRTABLE
 191+ 0517 0D                           dec     C              ; set VDP_DAT
 192+ 0518 1E 08                        ld      E,$08           ; 8 pixels each pattern
 193+ 051A 16 40        RPT101:         ld      D,$40           ; 64 chars each band
 194+ 051C 7E                           ld      A,(HL)          ; load data
 195+ 051D ED 79        RPT102:         out     (C),A           ; send it to VRAM
 196+ 051F 00                           nop                     ; little delay
 197+ 0520 1D                           dec     E               ; decrement counter
 198+ 0521 20 FA                        jr      NZ,RPT102       ; repeat until zero
 199+ 0523 1E 08                        ld      E,$08           ; 8 pixels each pattern
 200+ 0525 15                           dec     D               ; decrement char band counter
 201+ 0526 20 F5                        jr      NZ,RPT102       ; repeat until zero
 202+ 0528 23                           inc     HL              ; next pattern
 203+ 0529 10 EF                        djnz    RPT101          ; repeat until covered every band
 204+ 052B                              ; set pattern table
 205+ 052B 21 00 08                     ld      HL,$0800        ; address of first cell of 2nd area of pattern table
 206+ 052E 11 47 0B                     ld      DE,LM80CLOGO    ; pointer to logo pattern
 207+ 0531 06 00                        ld      B,$00           ; 256 bytes, 8 rows
 208+ 0533 CD 97 05     RPT103:         call    LOADLOGOCHRS
 209+ 0536 13                           inc     DE              ; next logo pattern
 210+ 0537 10 FA                        djnz    RPT103
 211+ 0539 06 20                        ld      B,$20           ; repeat for another 2 rows
 212+ 053B CD 97 05     RPT104:         call    LOADLOGOCHRS
 213+ 053E 13                           inc     DE              ; next logo pattern
 214+ 053F 10 FA                        djnz    RPT104
 215+ 0541                              ; show logo/message, play a beep, check for SHIFT pressure (to disable DOS), and wait a while
 216+ 0541 06 02                        ld      B,$02           ; two times
 217+ 0543 AF                           xor     A               ; reset A
 218+ 0544 57                           ld      D,A             ; 256 times
 219+ 0545 5F                           ld      E,A             ; x 256 times
 220+ 0546 32 7B 61                     ld      (TMPBFR1),A     ; sound flag set to 0
 221+ 0549                  IFDEF LM80C64K
 222+ 0549 3C                           inc     A               ; by default, I/O DOS buffer is enabled on LM80C 64K, disabled on LM80C
 223+ 054A                  ENDIF
 224+ 054A 32 C0 61                     ld      (DOS_EN),A      ; DOS enabled
 225+ 054D 00           DEC_D:          nop                     ; does nothing...
 226+ 054E 00                           nop
 227+ 054F 00                           nop
 228+ 0550 00                           nop
 229+ 0551 00                           nop
 230+ 0552 00                           nop                     ; ...until here
 231+ 0553 1D                           dec     E               ; decrement E
 232+ 0554 20 F7                        jr      NZ,DEC_D        ; repeat until $00
 233+ 0556 7A                           ld      A,D
 234+ 0557 FE 40                        cp      $40             ; ...equal to 64
 235+ 0559 CC 83 05                     call    Z,SETBEEP       ; if yes, start sound
 236+ 055C 15                           dec     D
 237+ 055D 20 EE                        jr      NZ,DEC_D        ; repeat
 238+ 055F 3A 7B 61                     ld      A,(TMPBFR1)     ; sound state
 239+ 0562 FE 02                        cp      $02             ; check if sound is to be set off
 240+ 0564 C4 8F 05                     call    NZ,BEEPOFF      ; yes
 241+ 0567                  IFDEF LM80C64K
 242+ 0567 CD BC 05                     call    CHKSPCK         ; check if special key (CTRL) has been pressed on keyboard
 243+ 056A                                                      ; on LM80C 64K, you can disabled the I/O DOS buffer, on LM80C you can't
 244+ 056A                  ENDIF
 245+ 056A 10 E1                        djnz    DEC_D           ; repeat
 246+ 056C              ERASECLRTBL:    ; erase color table
 247+ 056C 3E 11                        ld      A,$11           ; foreground and background set to black
 248+ 056E 16 0A                        ld      D,$0A           ; 10 pages
 249+ 0570 06 00                        ld      B,$00           ; 256 color cells per page
 250+ 0572 21 00 28                     ld      HL,$2800        ; first cell of 2nd color table
 251+ 0575 CD 66 06                     call    SETVDPADRS      ; send address
 252+ 0578 0D                           dec     C              ; VDP address for passing data
 253+ 0579 ED 79        RPT100:         out     (C),A           ; send data
 254+ 057B 00                           nop
 255+ 057C 00                           nop                     ; little delay
 256+ 057D 10 FA                        djnz    RPT100          ; repeat for entire page
 257+ 057F 15                           dec     D
 258+ 0580 20 F7                        jr      NZ,RPT100       ; repeat for all the pages ($0A00 cells)
 259+ 0582 C9                           ret                     ; return to caller
 260+ 0583
 261+ 0583              ; play a beep
 262+ 0583 3A 7B 61     SETBEEP:        ld      A,(TMPBFR1)     ; check the already-beeped flag
 263+ 0586 B7                           or      A               ; is it 0?
 264+ 0587 C0                           ret     NZ              ; no, exit
 265+ 0588 3C                           inc     A               ; flag to 1
 266+ 0589 32 7B 61                     ld      (TMPBFR1),A     ; set sound
 267+ 058C C3 B5 0C                     jp      WLCMBEEP        ; play a beep & return
 268+ 058F
 269+ 058F              ; beep off
 270+ 058F 3E 02        BEEPOFF:        ld      A,$02           ; flag for sound off
 271+ 0591 32 7B 61                     ld      (TMPBFR1),A     ; set flag
 272+ 0594 C3 BB 0C                     jp      NOBEEP          ; stop beep and return
 273+ 0597
 274+ 0597
 275+ 0597              ; used to load the chars that will compose the logo of the splash screen
 276+ 0597 1A           LOADLOGOCHRS:   ld      A,(DE)          ; load a pattern char of the logo
 277+ 0598 87                           add     A,A
 278+ 0599 87                           add     A,A
 279+ 059A 87                           add     A,A             ; multiply times 8 to get the offset
 280+ 059B C5                           push    BC
 281+ 059C D5                           push    DE              ; store BC and DE
 282+ 059D E5                           push    HL              ; store VRAM address to write to
 283+ 059E 21 71 5E                     ld      HL,LOGOFONT     ; start of logo font data
 284+ 05A1 5F                           ld      E,A
 285+ 05A2 16 00                        ld      D,$00           ; put offset (A) into DE
 286+ 05A4 19                           add     HL,DE           ; get address of pattern data
 287+ 05A5 EB                           ex      DE,HL           ; move address into DE
 288+ 05A6 E1                           pop     HL              ; retrieve VRAM address
 289+ 05A7 06 08                        ld      B,$08           ; 8 bytes per pattern
 290+ 05A9 CD 66 06                     call    SETVDPADRS      ; set VDP address
 291+ 05AC 0D                           dec     C              ; VDP_DAT
 292+ 05AD 1A           SNDLOGPT:       ld      A,(DE)          ; load data from RAM
 293+ 05AE ED 79                        out     (C),A           ; and send to VRAM
 294+ 05B0 13                           inc     DE              ; next byte into RAM
 295+ 05B1 23                           inc     HL              ; next byte into VRAM (used in future iterations)
 296+ 05B2 10 F9                        djnz    SNDLOGPT        ; repeat 8 times
 297+ 05B4 D1                           pop     DE
 298+ 05B5 C1                           pop     BC              ; retrieve BC & DE
 299+ 05B6 C9                           ret                     ; return to caller
 300+ 05B7              CLRTABLE:       equ $
 301+ 05B7 18 1B 13 14                  defb    $18,$1B,$13,$14,$1D ; colors of background bands of the logo
 301+ 05BB 1D
 302+ 05BC
 303+ 05BC
 304+ 05BC              ; while showing the logo, check if special key (CTRL) is being pressed
 305+ 05BC              ; if yes, then disable DOS functions recovering RAM
 306+ 05BC F5           CHKSPCK:        push    AF
 307+ 05BD 3E FE                        ld      A,%11111110     ; select CTRL row
 308+ 05BF CD 39 0D                     call    READKBLN        ; read row
 309+ 05C2 CB 5F                        bit     3,A             ; test for RUN/STOP
 310+ 05C4 CA D1 05                     jp      Z,DOCOLDRESET   ; yes, do a cold reset
 311+ 05C7 CB 57                        bit     2,A             ; test if CTRL key is pressed
 312+ 05C9 20 04                        jr      NZ,LVCKSPLK     ; no, leave
 313+ 05CB AF                           xor     A               ; yes, so...
 314+ 05CC 32 C0 61                     ld      (DOS_EN),A      ; ...disable DOS
 315+ 05CF F1           LVCKSPLK:       pop     AF
 316+ 05D0 C9                           ret
 317+ 05D1 AF           DOCOLDRESET:    xor     A               ; reset A
 318+ 05D2 32 D2 5F                     ld      (basicStarted),A; reset BASIC warm start
 319+ 05D5 C3 00 00                     jp      $0000           ; restart
 320+ 05D8
 321+ 05D8
 322+ 05D8              ; empty video buffer
 323+ 05D8 3A 6D 61     EMPTYVIDBUF:    ld      A,(SCR_MODE)    ; check screen mode
 324+ 05DB FE 02                        cp      $02             ; is it G2 mode?
 325+ 05DD CA 00 06                     jp      Z,EMPTYG2       ; yes, jump over
 326+ 05E0 FE 03                        cp      $03             ; is it MC mode?
 327+ 05E2 CA 30 06                     jp      Z,EMPTYMC       ; yes, jump over
 328+ 05E5 3A 6C 61                     ld      A,(SCR_SIZE_H)  ; load height of screen
 329+ 05E8 47                           ld      B,A             ; move rows into B
 330+ 05E9 AF                           xor     A               ; filling char is $00
 331+ 05EA 2A 6E 61                     ld      HL,(SCR_NAM_TB) ; load the name table address
 332+ 05ED CD 66 06                     call    SETVDPADRS      ; send address to VDP
 333+ 05F0 0D                           dec     C              ; VDP address for passing data
 334+ 05F1 5F           LDCOLSTOEMPTY:  ld      E,A             ; store filling char into E
 335+ 05F2 3A 6B 61                     ld      A,(SCR_SIZE_W)  ; load # of cols to empty into A
 336+ 05F5 57                           ld      D,A             ; move A into D
 337+ 05F6 7B                           ld      A,E             ; recover filling char
 338+ 05F7 ED 79        RPTEMPTYBUF:    out     (C),A           ; write empty byte into VRAM
 339+ 05F9 00                           nop
 340+ 05FA 15                           dec     D               ; decr. D
 341+ 05FB 20 FA                        jr      NZ,RPTEMPTYBUF  ; repeat for the # of cols
 342+ 05FD 10 F2                        djnz    LDCOLSTOEMPTY   ; repeat for the # of rows
 343+ 05FF C9                           ret                     ; return to caller
 344+ 0600 2A 6E 61     EMPTYG2:        ld      HL,(SCR_NAM_TB) ; yes, additional setup for G2 - load G2 name table address (usually $1800)
 345+ 0603 CD 54 06                     call    SETNAMETABLE    ; set name table
 346+ 0606 21 00 00                     ld      HL,$0000        ; set pattern table
 347+ 0609 CD 66 06                     call    SETVDPADRS      ; send address to VDP
 348+ 060C AF                           xor     A               ; empty pattern
 349+ 060D 16 18                        ld      D,$18           ; 6144 ($1800) cell to clean, 24 pages ($18)
 350+ 060F 47                           ld      B,A             ; 256 bytes for page
 351+ 0610 0D                           dec     C              ; VDP data mode
 352+ 0611 ED 79        CLRG2PTNTBL:    out     (C),A           ; clear pattern
 353+ 0613 00                           nop                     ; little delay
 354+ 0614 00                           nop
 355+ 0615 10 FA                        djnz    CLRG2PTNTBL     ; repeat for 1 page
 356+ 0617 15                           dec     D               ; next page
 357+ 0618 20 F7                        jr      NZ,CLRG2PTNTBL  ; repeat
 358+ 061A 21 00 20                     ld      HL,$2000        ; load the color table address
 359+ 061D CD 66 06                     call    SETVDPADRS      ; send address to VDP
 360+ 0620 3A 79 61                     ld      A,(FRGNDCLR)    ; load foreground
 361+ 0623 87                           add     A,A
 362+ 0624 87                           add     A,A
 363+ 0625 87                           add     A,A
 364+ 0626 87                           add     A,A             ; move to high nibble
 365+ 0627 57                           ld      D,A             ; store into D
 366+ 0628 3A 7A 61                     ld      A,(BKGNDCLR)    ; load background color
 367+ 062B B2                           or      D               ; combine with background color
 368+ 062C 16 18                        ld      D,$18           ; 6144 ($1800) cells to fill, so 24 pages ($18)
 369+ 062E 18 17                        jr      STARTEMPTY
 370+ 0630 21 00 08     EMPTYMC:        ld      HL,$0800        ; MC name table
 371+ 0633 CD 54 06                     call    SETNAMETABLE    ; set name table
 372+ 0636 21 00 00                     ld      HL,$0000        ; color table address
 373+ 0639 CD 66 06                     call    SETVDPADRS      ; send address to VDP
 374+ 063C 3A 7A 61                     ld      A,(BKGNDCLR)    ; load background
 375+ 063F 57                           ld      D,A             ; store into D
 376+ 0640 87                           add     A,A
 377+ 0641 87                           add     A,A
 378+ 0642 87                           add     A,A
 379+ 0643 87                           add     A,A             ; move to high nibble
 380+ 0644 B2                           or      D               ; set background color for high and low nibble
 381+ 0645 16 08                        ld      D,$08           ; 2048 ($0800) cells to fill, so 8 pages ($08)
 382+ 0647 0D           STARTEMPTY:     dec     C              ; VDP address for passing data
 383+ 0648 06 00                        ld      B,$00           ; 256 bytes each page ($00=256)
 384+ 064A ED 79        SNDCLRSET:      out     (C),A           ; send color setting
 385+ 064C 00                           nop                     ; wait a while
 386+ 064D 00                           nop
 387+ 064E 10 FA                        djnz    SNDCLRSET       ; repeat for 1 page
 388+ 0650 15                           dec     D               ; have we filled all the pages?
 389+ 0651 20 F7                        jr      NZ,SNDCLRSET    ; no, repeat
 390+ 0653 C9                           ret                     ; return to caller
 391+ 0654
 392+ 0654              ; set name table for G2 mode (patterns from $00 to $FF for each of the 3 areas of the screen)
 393+ 0654 CD 66 06     SETNAMETABLE:   call    SETVDPADRS      ; send address to VDP
 394+ 0657 0D                           dec     C              ; VDP address for passing data
 395+ 0658 16 03                        ld      D,$03           ; 3 pages to fill into VRAM (768 cells)
 396+ 065A AF                           xor     A               ; starting char name #0 (chars go from 0 to 255)
 397+ 065B 47                           ld      B,A             ; reset B
 398+ 065C ED 79        RPTFLL1:        out     (C),A           ; send name to VRAM
 399+ 065E 00                           nop
 400+ 065F 3C                           inc     A               ; increment # of name
 401+ 0660 10 FA                        djnz    RPTFLL1         ; repeat for 256 cells (1 page)
 402+ 0662 15                           dec     D               ; did we fill all the pages?
 403+ 0663 20 F7                        jr      NZ,RPTFLL1      ; no, continue
 404+ 0665 C9                           ret                     ; return to caller
 405+ 0666
 406+ 0666              ; set an address into VRAM: address is in HL - HL is changed after it
 407+ 0666 0E 31        SETVDPADRS:     ld      C,VDP_SET       ; VDP address mode
 408+ 0668 CB F4                        set     6,H             ; set bit #6 of address, to write to VRAM
 409+ 066A ED 69                        out     (C),L           ; send low and...
 410+ 066C ED 61                        out     (C),H           ; ...high byte of the first cell
 411+ 066E C9                           ret                     ; return to caller
 412+ 066F
 413+ 066F              ; clear the video buffer and position the cursor at 0,0
 414+ 066F CD D8 05     CLEARVIDBUF:    call    EMPTYVIDBUF     ; clear video buffer
 415+ 0672 AF                           xor     A               ; reset A
 416+ 0673 32 70 61                     ld      (SCR_CURS_X),A  ; cursor X to 0
 417+ 0676 32 71 61                     ld      (SCR_CURS_Y),A  ; cursor Y to 0
 418+ 0679 C3 C2 06                     jp      POS_CURSOR      ; position cursor & return to caller
 419+ 067C
 420+ 067C              ; HOME: position the cursor at coords. 0,0
 421+ 067C AF           ATHOME:         xor     A               ; position cursor at 0,0 by storing...
 422+ 067D 32 73 61                     ld      (SCR_CUR_NY),A  ; ...new Y...
 423+ 0680 32 72 61                     ld      (SCR_CUR_NX),A  ; ...and new X
 424+ 0683 C3 CC 06                     jp      MOVCRS          ; move cursor to new location & return to caller
 425+ 0686
 426+ 0686              ; load the char or byte at the VRAM position set by HL
 427+ 0686              ; value is returned into A
 428+ 0686 C5           READ_VIDEO_LOC: push    BC              ; store BC
 429+ 0687 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 430+ 0689 44                           ld      B,H
 431+ 068A CB B8                        res     7,B
 432+ 068C CB B0                        res     6,B
 433+ 068E ED 69                        out     (C),L           ; low byte then...
 434+ 0690 ED 41                        out     (C),B           ; high byte
 435+ 0692 0D                           dec     C              ; VDP data mode
 436+ 0693 00                           nop               ; added to compensate shorter instruction
 437+ 0694 00                           nop                     ; wait...
 438+ 0695 00                           nop                     ; ...a while
 439+ 0696 00                           nop
 440+ 0697 ED 78                        in      A,(C)           ; read byte at current VRAM location
 441+ 0699 C1                           pop     BC              ; restore BC
 442+ 069A C9                           ret                     ; return to caller
 443+ 069B
 444+ 069B              ; write a byte at the VRAM position pointed by HL
 445+ 069B              ; value is in A
 446+ 069B C5           WRITE_VIDEO_LOC:push    BC              ; store BC
 447+ 069C 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 448+ 069E 44                           ld      B,H             ; copy H into B
 449+ 069F CB B8                        res     7,B
 450+ 06A1 CB F0                        set     6,B             ; write to VRAM
 451+ 06A3 ED 69                        out     (C),L           ; low byte then...
 452+ 06A5 ED 41                        out     (C),B           ; high byte of VRAM address
 453+ 06A7 0D                           dec     C              ; VDP data mode
 454+ 06A8 00                           nop               ; added to compensate shorter instruction
 455+ 06A9 00                           nop                     ; wait...
 456+ 06AA 00                           nop                     ; ...a while
 457+ 06AB 00                           nop
 458+ 06AC ED 79                        out     (C),A           ; write byte into VRAM
 459+ 06AE C1                           pop     BC              ; restore BC
 460+ 06AF C9                           ret                     ; return to caller
 461+ 06B0
 462+ 06B0              ; write a value into a specific VDP register
 463+ 06B0              ; value is in E, register is in A
 464+ 06B0 C5           WRITE_VREG:     push    BC              ; store BC
 465+ 06B1 C6 80                        add     A,$80           ; set VDP to write to registers
 466+ 06B3 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 467+ 06B5 ED 59                        out     (C),E           ; send data to VDP
 468+ 06B7 ED 79                        out     (C),A           ; select the destination register
 469+ 06B9 C1                           pop     BC              ; restore BC
 470+ 06BA C9                           ret                     ; return to caller
 471+ 06BB
 472+ 06BB              ; read VDP status register and return value into A
 473+ 06BB C5           READ_VSTAT:     push    BC              ; store BC
 474+ 06BC 0E 31                        ld      C,VDP_SET       ; VDP register access
 475+ 06BE ED 78                        in      A,(C)           ; read status register
 476+ 06C0 C1                           pop     BC              ; restore BC
 477+ 06C1 C9                           ret                     ; return to caller
 478+ 06C2
 479+ 06C2              ; position the cursor at the current coordinates, preserving underlying char
 480+ 06C2 CD 05 07     POS_CURSOR:     call    LOAD_CRSR_POS   ; load the VRAM address of cursor into HL
 481+ 06C5 CD 86 06                     call    READ_VIDEO_LOC  ; load the current char at the cursor position (return in A)
 482+ 06C8 32 74 61                     ld      (SCR_ORG_CHR),A ; store the current char
 483+ 06CB C9                           ret
 484+ 06CC
 485+ 06CC              ; move cursor to new X,Y coordinates
 486+ 06CC CD FC 06     MOVCRS:         call    RSTCHRCRS       ; restore the char in the current cursor position
 487+ 06CF CD E7 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 488+ 06D2 CD C2 06     MOVSHOWCRS:     call    POS_CURSOR      ; position cursor into new location
 489+ 06D5 3A 75 61                     ld      A,(CRSR_STATE)  ; load status of cursor
 490+ 06D8 A7                           and     A               ; is cursor off?
 491+ 06D9 C8                           ret     Z               ; yes, return
 492+ 06DA 3A 76 61                     ld      A,(LSTCSRSTA)   ; it's visible, so...
 493+ 06DD F6 20                        or      $20             ; ...set cursor on
 494+ 06DF 32 76 61                     ld      (LSTCSRSTA),A   ; store the last cursor state
 495+ 06E2 3E FF                        ld      A,$FF           ; BTW, set cursor visible after moved it
 496+ 06E4 C3 9B 06                     jp      WRITE_VIDEO_LOC ; write into video cell
 497+ 06E7
 498+ 06E7
 499+ 06E7              ; set new cursor's coordinates
 500+ 06E7 3A 72 61     NEWCRSRCOORD:   ld      A,(SCR_CUR_NX)  ; load new X
 501+ 06EA 32 70 61                     ld      (SCR_CURS_X),A  ; write new X
 502+ 06ED 3A 73 61                     ld      A,(SCR_CUR_NY)  ; load new Y
 503+ 06F0 32 71 61                     ld      (SCR_CURS_Y),A  ; write new Y
 504+ 06F3 3E FF                        ld      A,$FF           ; delete new values
 505+ 06F5 32 72 61                     ld      (SCR_CUR_NX),A  ; of X
 506+ 06F8 32 73 61                     ld      (SCR_CUR_NY),A  ; and Y
 507+ 06FB C9                           ret
 508+ 06FC
 509+ 06FC              ; recover char under the cursor and prints it onto the screen
 510+ 06FC CD 05 07     RSTCHRCRS:      call    LOAD_CRSR_POS   ; recover old cursor position
 511+ 06FF 3A 74 61                     ld      A,(SCR_ORG_CHR) ; recover old char
 512+ 0702 C3 9B 06                     jp      WRITE_VIDEO_LOC ; write char into VRAM & return
 513+ 0705
 514+ 0705              ; retrieve cursor position from either current coordinates or next place
 515+ 0705              ; return address position into HL
 516+ 0705 3A 71 61     LOAD_CRSR_POS:  ld      A,(SCR_CURS_Y)  ; load cursor Y
 517+ 0708 6F                           ld      L,A             ; move it into reg.L
 518+ 0709 AF                           xor     A               ; reset A
 519+ 070A 67                           ld      H,A             ; reset H
 520+ 070B 47                           ld      B,A             ; reset B
 521+ 070C 29                           add     HL,HL           ; create offset (each address is 2-bytes long so we need to double HL)
 522+ 070D 11 95 0A                     ld      DE,POS_TB_CRS_40; load position table address of cursor for 40 cols
 523+ 0710 3A 6B 61                     ld      A,(SCR_SIZE_W)  ; load screen width
 524+ 0713 FE 28                        cp      $28             ; is it 40 cols?
 525+ 0715 28 03                        jr      Z,CONT_POS_CURS ; yes, jump over
 526+ 0717 11 65 0A                     ld      DE,POS_TB_CRS_32; no, load position table address of cursor for 32 cols
 527+ 071A 19           CONT_POS_CURS:  add     HL,DE           ; the correct starting address of the required row is now into HL
 528+ 071B 5E                           ld      E,(HL)          ; load starting address of the required row into DE
 529+ 071C 23                           inc     HL
 530+ 071D 56                           ld      D,(HL)
 531+ 071E 2A 6E 61                     ld      HL,(SCR_NAM_TB) ; load starting address of name table
 532+ 0721 19                           add     HL,DE           ; starting address of the current row into name table
 533+ 0722 3A 70 61                     ld      A,(SCR_CURS_X)  ; load cursor X
 534+ 0725 4F                           ld      C,A             ; transfer A into C
 535+ 0726 09                           add     HL,BC           ; add X offset: now HL contains the address of the current cursor position
 536+ 0727 C9                           ret
 537+ 0728
 538+ 0728              ; find X,Y coordinates of a screen address pointed in VRAM by HL
 539+ 0728              ; return them into L,A for X,Y
 540+ 0728 D5           HL2XY:          push    DE              ; store DE
 541+ 0729 ED 5B 6E 61                  ld      DE,(SCR_NAM_TB) ; load starting address of name table into DE
 542+ 072D AF                           xor     A               ; clear Carry
 543+ 072E ED 52                        sbc     HL,DE           ; find position relative to screen (from 0,0)
 544+ 0730 D1                           pop     DE
 545+ 0731 3A 6B 61                     ld      A,(SCR_SIZE_W)  ; load screen width
 546+ 0734 4F                           ld      C,A             ; move it into C
 547+ 0735 CD 96 4D                     call    DIV_16_8        ; divide position by C: return Y into L and X into A
 548+ 0738 C9                           ret                     ; return to caller
 549+ 0739
 550+ 0739              ;-------------------------------------------------------------------------------
 551+ 0739              ; char table for jumps
 552+ 0739 19           CHRTBL:         defb    HOME
 553+ 073A 7C 06                        defw    ATHOME          ; move the cursor to 0,0
 554+ 073C
 555+ 073C 0C                           defb    CS
 556+ 073D 6F 06                        defw    CLEARVIDBUF     ; clear video buffer and position cursor at 0,0
 557+ 073F
 558+ 073F 0D                           defb    CR
 559+ 0740 B8 09                        defw    CRGRETURN       ; go to the beginning of the next line
 560+ 0742
 561+ 0742 08                           defb    BKSP
 562+ 0743 26 08                        defw    BACKSPACE       ; move cursor left 1 position
 563+ 0745
 564+ 0745 1C                           defb    CRSLFT
 565+ 0746 69 08                        defw    CURSORLEFT      ; move cursor left
 566+ 0748
 567+ 0748 1E                           defb    CRSUP
 568+ 0749 B5 08                        defw    CURSORUP        ; move cursor up
 569+ 074B
 570+ 074B 1D                           defb    CRSRGT
 571+ 074C CE 08                        defw    CURSORRIGHT     ; move cursor right
 572+ 074E
 573+ 074E 1F                           defb    CRSDN
 574+ 074F 03 09                        defw    CURSORDOWN      ; move cursor up
 575+ 0751
 576+ 0751 1A                           defb    INSRT
 577+ 0752 E4 07                        defw    INSERTKEY       ; insert a space
 578+ 0754
 579+ 0754 0A                           defb    LF
 580+ 0755 C0 07                        defw    PLACEHOLDER     ; CURRENTLY WE DON'T PRINT LINE FEED
 581+ 0757
 582+ 0757              ; send current char to video buffer
 583+ 0757 F5           CHAR2VID:       push    AF              ; store AF
 584+ 0758 C5                           push    BC              ; store BC
 585+ 0759 D5                           push    DE              ; store DE
 586+ 075A E5                           push    HL              ; store HL
 587+ 075B 3A 75 61                     ld      A,(CRSR_STATE)  ; store cursor state...
 588+ 075E F5                           push    AF              ; into stack
 589+ 075F CD 38 09                     call    CURSOR_OFF      ; cursor off
 590+ 0762 3A 78 61                     ld      A,(CHR4VID)     ; recover char
 591+ 0765 06 0A                        ld      B,$0A           ; 10 chars to check
 592+ 0767 21 39 07                     ld      HL,CHRTBL       ; address of key table
 593+ 076A BE           RPTCPCK:        cp      (HL)            ; compare with char
 594+ 076B 23                           inc     HL              ; beginning of sub-routine address
 595+ 076C 20 09                        jr      NZ,NXTCPCK      ; different, go to next char
 596+ 076E 5E                           ld      E,(HL)          ; load addres into DE
 597+ 076F 23                           inc     HL
 598+ 0770 56                           ld      D,(HL)
 599+ 0771 EB                           ex      DE,HL           ; move user routine's address into HL
 600+ 0772 11 B3 07                     ld      DE,EXITCHAR2VID ; set point of return after the user routine
 601+ 0775 D5                           push    DE              ; store into stack
 602+ 0776 E9                           jp      (HL)            ; call user routine - then, the CPU will return (jump) to EXITCHAR2VID
 603+ 0777 23           NXTCPCK:        inc     HL              ; jump over 2 cells...
 604+ 0778 23                           inc     HL              ; ...to the next char code
 605+ 0779 10 EF                        djnz    RPTCPCK         ; repeat
 606+ 077B                              ; it'a not a special char, just print it
 607+ 077B CD 05 07                     call    LOAD_CRSR_POS   ; recover position of cursor
 608+ 077E 3A 78 61                     ld      A,(CHR4VID)     ; recover char to print
 609+ 0781 CD 9B 06                     call    WRITE_VIDEO_LOC ; write A into VRAM at (HL)
 610+ 0784 3A 71 61                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 611+ 0787 5F                           ld      E,A             ; store cursor Y into E
 612+ 0788 3A 70 61                     ld      A,(SCR_CURS_X)  ; load cursor X
 613+ 078B 3C                           inc     A               ; move 1 step to right
 614+ 078C 21 6B 61                     ld      HL,SCR_SIZE_W   ; cell that keeps the width of screen
 615+ 078F BE                           cp      (HL)            ; have we reached the most right position?
 616+ 0790 20 0F                        jr      NZ,SETCSRCOORDS ; no, go over
 617+ 0792 1C                           inc     E               ; yes, increment cursor Y (go to next line)
 618+ 0793 7B                           ld      A,E             ; move cursor Y into A
 619+ 0794 21 6C 61                     ld      HL,SCR_SIZE_H   ; cell that keeps the height of screen
 620+ 0797 BE                           cp      (HL)            ; have we reached the bottom of the screen?
 621+ 0798 20 06                        jr      NZ,SETCRSRY     ; no, jump over
 622+ 079A D5                           push    DE
 623+ 079B CD 3F 09                     call    SCROLLUP        ; scroll screen up
 624+ 079E D1                           pop     DE
 625+ 079F 1D                           dec     E               ; decrement 1 row, to set cursor Y on the last line
 626+ 07A0 AF           SETCRSRY:       xor     A               ; then set cursor X to 0 (go to beginning of line)
 627+ 07A1 32 70 61     SETCSRCOORDS:   ld      (SCR_CURS_X),A  ; store current cursor X
 628+ 07A4 7B                           ld      A,E             ; recover Y
 629+ 07A5 32 71 61                     ld      (SCR_CURS_Y),A  ; store current cursor Y
 630+ 07A8 CD C2 06                     call    POS_CURSOR      ; position cursor into new location
 631+ 07AB 3A 5B 61                     ld      A,(TMRCNT)      ; load status of cursor flashing
 632+ 07AE E6 20                        and     $20             ; check cursor state
 633+ 07B0 32 76 61                     ld      (LSTCSRSTA),A   ; store the last cursor state
 634+ 07B3 AF           EXITCHAR2VID:   xor     A               ; reset char
 635+ 07B4 32 78 61                     ld      (CHR4VID),A     ; to be sent to screen
 636+ 07B7 F1                           pop     AF              ; recover cursor state
 637+ 07B8 A7                           and     A               ; was it off (A=0)?
 638+ 07B9 C4 23 09                     call    NZ,CURSOR_ON    ; no, set cursor on
 639+ 07BC E1                           pop     HL              ; restore HL
 640+ 07BD D1                           pop     DE              ; restore DE
 641+ 07BE C1                           pop     BC              ; restore BC
 642+ 07BF F1                           pop     AF              ; restore AF
 643+ 07C0 C9           PLACEHOLDER:    ret                     ; return to caller
 644+ 07C1
 645+ 07C1              ; flash the cursor at the current position
 646+ 07C1              ; (this sub-routine is called by CH3 timer ISR)
 647+ 07C1 3A 75 61     FLASHCURSOR:    ld      A,(CRSR_STATE)  ; now, check the cursor
 648+ 07C4 A7                           and     A               ; cursor off (A=0)?
 649+ 07C5 C8                           ret     Z               ; yes, return
 650+ 07C6 3A 5B 61                     ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
 651+ 07C9 E6 20                        and     $20             ; check if it's time to flash the cursor (check bit #6)
 652+ 07CB 21 76 61                     ld      HL,LSTCSRSTA    ; load address of cell that stores the last cursor state
 653+ 07CE BE                           cp      (HL)            ; compare current state with last state
 654+ 07CF C8                           ret     Z               ; same state, no change required - exit
 655+ 07D0 77                           ld      (HL),A          ; save new state
 656+ 07D1 F5                           push    AF              ; store A (keep state for later use)
 657+ 07D2 CD 05 07                     call    LOAD_CRSR_POS   ; load current cursor position into HL
 658+ 07D5 F1                           pop     AF              ; recover current state
 659+ 07D6 06 FF                        ld      B,$FF           ; cursor char
 660+ 07D8 FE 20                        cp      $20             ; is the cursor on video (A == $20)?
 661+ 07DA 28 04                        jr      Z,PUTCRSCHR     ; yes, jump over
 662+ 07DC 3A 74 61                     ld      A,(SCR_ORG_CHR) ; no, load the original char
 663+ 07DF 47                           ld      B,A             ; move char into B
 664+ 07E0 78           PUTCRSCHR:      ld      A,B             ; recover char from B
 665+ 07E1 C3 9B 06                     jp      WRITE_VIDEO_LOC ; print cursor/char at the current position & return
 666+ 07E4
 667+ 07E4
 668+ 07E4              ; insert an empty space at the current position of the cursor, moving the following text
 669+ 07E4              ; 1 cell straight
 670+ 07E4 CD FC 06     INSERTKEY:      call    RSTCHRCRS       ; restore char under the cursor
 671+ 07E7 CD 05 07                     call    LOAD_CRSR_POS   ; retrieve address of cursor cell
 672+ 07EA 22 7B 61                     ld      (CUR_POS),HL    ; store it
 673+ 07ED CD 3F 0A                     call    ENDOFLN         ; find address of first free cell after the end of the text from the current cursor position - address into HL -
 674+ 07F0                                                      ; DE is the address of the bottom right cell of the screen
 675+ 07F0 22 7F 61                     ld      (ENDTXT),HL     ; store it
 676+ 07F3 ED 4B 7B 61                  ld      BC,(CUR_POS)    ; load starting address
 677+ 07F7 AF                           xor     A
 678+ 07F8 ED 42                        sbc     HL,BC           ; how many positions to move?
 679+ 07FA CA D2 06                     jp      Z,MOVSHOWCRS    ; none - leave and re-place cursor
 680+ 07FD 44 4D                        ld      BC,HL           ; number of chars to scroll into BC
 681+ 07FF 2A 7F 61                     ld      HL,(ENDTXT)     ; load address of the end of text
 682+ 0802 2B           CHKHL:          dec     HL              ; decrement to find the address of the char to move
 683+ 0803 E5                           push    HL
 684+ 0804 CD 3B 4D                     call    CMP16           ; is it the last cell (bottom right) of screen?
 685+ 0807 E1                           pop     HL
 686+ 0808 D2 13 08                     jp      NC,NXTINST      ; yes, so jump over - nothing to do
 687+ 080B CD 86 06                     call    READ_VIDEO_LOC  ; no, so read current char
 688+ 080E 23                           inc     HL              ; next cell
 689+ 080F CD 9B 06                     call    WRITE_VIDEO_LOC ; write into new position
 690+ 0812 2B                           dec     HL              ; decrement to old position
 691+ 0813 0B           NXTINST:        dec     BC              ; decrement number of chars to move
 692+ 0814 79                           ld      A,C
 693+ 0815 B0                           or      B               ; finished?
 694+ 0816 20 EA                        jr      NZ,CHKHL        ; no, repeat
 695+ 0818 3E 20        ENDINSRT:       ld      A,SPC           ; load SPACE character
 696+ 081A 2A 7B 61                     ld      HL,(CUR_POS)    ; get cursor position
 697+ 081D 32 74 61                     ld      (SCR_ORG_CHR),A ; reset original char under the cursor
 698+ 0820 CD 9B 06                     call    WRITE_VIDEO_LOC ; empty current video location
 699+ 0823 C3 D2 06                     jp      MOVSHOWCRS      ; re-place cursor
 700+ 0826
 701+ 0826              ; delete the char at the left of the cursor
 702+ 0826 CD FC 06     BACKSPACE:      call    RSTCHRCRS       ; restore char
 703+ 0829 2A 6E 61                     ld      HL,(SCR_NAM_TB) ; address of origin of screen (location 0,0)
 704+ 082C 44 4D                        ld      BC,HL           ; store into BC
 705+ 082E CD 05 07                     call    LOAD_CRSR_POS   ; load address of current cursor pos.
 706+ 0831 54 5D                        ld      DE,HL           ; copy into DE
 707+ 0833 AF                           xor     A               ; reset Carry
 708+ 0834 ED 42                        sbc     HL,BC           ; check how many chars between
 709+ 0836 CA 60 08                     jp      Z,LVBKSP        ; none, so we are at the top left corner
 710+ 0839 ED 53 7B 61                  ld      (CUR_POS),DE    ; store current cursor position
 711+ 083D CD 3F 0A                     call    ENDOFLN         ; check end of text
 712+ 0840 ED 5B 7B 61                  ld      DE,(CUR_POS)    ; retrieve cursor position
 713+ 0844 AF                           xor     A               ; reset Carry
 714+ 0845 ED 52                        sbc     HL,DE           ; check if none follows
 715+ 0847 CA 60 08                     jp      Z,LVBKSP        ; no chars follow, so simply move the cursor
 716+ 084A 44 4D                        ld      BC,HL           ; save numbers of chars to move
 717+ 084C EB                           ex      DE,HL           ; copy starting position into HL
 718+ 084D CD 86 06     MVBKSP:         call    READ_VIDEO_LOC  ; read char
 719+ 0850 2B                           dec     HL              ; 1 position to left
 720+ 0851 CD 9B 06                     call    WRITE_VIDEO_LOC ; write char
 721+ 0854 23                           inc     HL              ; goto next char to copy (2 steps to right)
 722+ 0855 23                           inc     HL
 723+ 0856 0B                           dec     BC              ; decrement # of chars
 724+ 0857 79                           ld      A,C
 725+ 0858 B0                           or      B               ; 0 chars?
 726+ 0859 20 F2                        jr      NZ,MVBKSP       ; not finished, continue
 727+ 085B 2B                           dec     HL
 728+ 085C AF                           xor     A
 729+ 085D CD 9B 06                     call    WRITE_VIDEO_LOC ; reset last char
 730+ 0860 CD 92 08     LVBKSP:         call    MVCRS2LFT       ; move cursor to new position
 731+ 0863 CD E7 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 732+ 0866 C3 D2 06                     jp      MOVSHOWCRS      ; move cursor to the new location and set it ON
 733+ 0869
 734+ 0869
 735+ 0869              ; move cursor to left
 736+ 0869 F5           CURSORLEFT:     push    AF              ; store A
 737+ 086A 3A 70 61                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 738+ 086D A7                           and     A               ; is it at the most left of the screen (X=0)?
 739+ 086E 28 0C                        jr      Z,CHCKYPOS      ; yes, check Y position
 740+ 0870 3D                           dec     A               ; no, decrement X
 741+ 0871 32 72 61                     ld      (SCR_CUR_NX),A  ; store new X
 742+ 0874 3A 71 61                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 743+ 0877 32 73 61                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 744+ 087A 18 11                        jr      CONTCRSLFT      ; go on moving cursor
 745+ 087C 3A 71 61     CHCKYPOS:       ld      A,(SCR_CURS_Y)  ; load cursor Y
 746+ 087F A7                           and     A               ; is it at the most top of the screen (Y=0)?
 747+ 0880 28 0E                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 748+ 0882 3D                           dec     A               ; no, decrement Y
 749+ 0883 32 73 61                     ld      (SCR_CUR_NY),A  ; store new Y
 750+ 0886 3A 6B 61                     ld      A,(SCR_SIZE_W)  ; load current screen width
 751+ 0889 3D                           dec     A               ; cursor to the most right position (width-0)
 752+ 088A 32 72 61                     ld      (SCR_CUR_NX),A  ; set new cursor X
 753+ 088D CD CC 06     CONTCRSLFT:     call    MOVCRS          ; move cursor into new position
 754+ 0890 F1           EXITCURSORLEFT: pop     AF              ; restore A
 755+ 0891 C9                           ret                     ; return to caller
 756+ 0892
 757+ 0892              ; move cursor 1 position to the left
 758+ 0892 3A 70 61     MVCRS2LFT:      ld      A,(SCR_CURS_X)  ; load cursor X into A
 759+ 0895 A7                           and     A               ; is it at the most left of the screen (X=0)?
 760+ 0896 28 0B                        jr      Z,CHKYPOS       ; yes, check Y position
 761+ 0898 3D                           dec     A               ; no, decrement X
 762+ 0899 32 72 61                     ld      (SCR_CUR_NX),A  ; store new X
 763+ 089C 3A 71 61                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 764+ 089F 32 73 61                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 765+ 08A2 C9                           ret                     ; go on moving cursor
 766+ 08A3 3A 71 61     CHKYPOS:        ld      A,(SCR_CURS_Y)  ; load cursor Y
 767+ 08A6 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 768+ 08A7 28 E7                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 769+ 08A9 3D                           dec     A               ; no, decrement Y
 770+ 08AA 32 73 61                     ld      (SCR_CUR_NY),A  ; store new Y
 771+ 08AD 3A 6B 61                     ld      A,(SCR_SIZE_W)  ; load current screen width
 772+ 08B0 3D                           dec     A               ; cursor to the most right position (width-1)
 773+ 08B1 32 72 61                     ld      (SCR_CUR_NX),A  ; set new cursor X
 774+ 08B4 C9                           ret                     ; return to caller
 775+ 08B5
 776+ 08B5              ; move cursor up
 777+ 08B5 F5           CURSORUP:       push    AF              ; store A
 778+ 08B6 3A 71 61                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 779+ 08B9 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 780+ 08BA 28 10                        jr      Z,EXITCURSORUP  ; yes, exit doing nothing
 781+ 08BC 3D                           dec     A               ; no, decrement Y
 782+ 08BD 32 73 61                     ld      (SCR_CUR_NY),A  ; store new Y
 783+ 08C0 3A 70 61                     ld      A,(SCR_CURS_X)  ; load current cursor X
 784+ 08C3 32 72 61                     ld      (SCR_CUR_NX),A  ; set new cursor X
 785+ 08C6 CD FC 06                     call    RSTCHRCRS       ; restore char under the cursor and print it
 786+ 08C9 CD CC 06                     call    MOVCRS          ; move cursor into new position
 787+ 08CC F1           EXITCURSORUP:   pop     AF              ; restore A
 788+ 08CD C9                           ret                     ; return to caller
 789+ 08CE
 790+ 08CE
 791+ 08CE              ; move cursor to right
 792+ 08CE F5           CURSORRIGHT:    push    AF              ; store A
 793+ 08CF C5                           push    BC              ; store B
 794+ 08D0 3A 6B 61                     ld      A,(SCR_SIZE_W)  ; load current screen width (in text modes it's 32 or 40)
 795+ 08D3 3D                           dec     A               ; decrement it (most right can only be 31 or 39)
 796+ 08D4 47                           ld      B,A             ; move A into B
 797+ 08D5 3A 70 61                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 798+ 08D8 B8                           cp      B               ; is cursor at the most right position on the screen?
 799+ 08D9 30 0C                        jr      NC,CHCKYPOS2    ; yes, so jump to check Y position
 800+ 08DB 3C                           inc     A               ; no, so increment X
 801+ 08DC 32 72 61                     ld      (SCR_CUR_NX),A  ; store new X
 802+ 08DF 3A 71 61                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 803+ 08E2 32 73 61                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 804+ 08E5 18 13                        jr      CONTCRSRGT      ; go on moving cursor
 805+ 08E7 3A 6C 61     CHCKYPOS2:      ld      A,(SCR_SIZE_H)  ; load screen height
 806+ 08EA 3D                           dec     A               ; decrement it (last row can only be 23)
 807+ 08EB 47                           ld      B,A             ; move bottom into B
 808+ 08EC 3A 71 61                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 809+ 08EF B8                           cp      B               ; is the cursor at the bottom of the screen?
 810+ 08F0 30 0E                        jr      NC,EXITCURSORRGHT; yes, exit doing nothing
 811+ 08F2 3C                           inc     A               ; no, increment Y
 812+ 08F3 32 73 61                     ld      (SCR_CUR_NY),A  ; store new Y
 813+ 08F6 AF                           xor     A               ; move cursor to top left
 814+ 08F7 32 72 61                     ld      (SCR_CUR_NX),A  ; store new X
 815+ 08FA CD FC 06     CONTCRSRGT:     call    RSTCHRCRS       ; restore char under the cursor and print it
 816+ 08FD CD CC 06                     call    MOVCRS          ; move cursor into new position
 817+ 0900 C1           EXITCURSORRGHT: pop     BC              ; retrieve BC
 818+ 0901 F1                           pop     AF              ; restore A
 819+ 0902 C9                           ret                     ; return to caller
 820+ 0903
 821+ 0903
 822+ 0903              ; move cursor down
 823+ 0903 F5           CURSORDOWN:     push    AF              ; store A
 824+ 0904 C5                           push    BC              ; store B
 825+ 0905 3A 6C 61                     ld      A,(SCR_SIZE_H)  ; load current screen height (in text modes it's 24)
 826+ 0908 3D                           dec     A               ; decrement it (positions can only vary between 0 and 23)
 827+ 0909 47                           ld      B,A             ; move X into B
 828+ 090A 3A 71 61                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 829+ 090D B8                           cp      B               ; is current cursor position < 23?
 830+ 090E 30 10                        jr      NC,EXITCURSORDOWN; no, exit doing nothing
 831+ 0910 3C                           inc     A               ; yes, increment Y
 832+ 0911 32 73 61                     ld      (SCR_CUR_NY),A  ; store new Y
 833+ 0914 3A 70 61                     ld      A,(SCR_CURS_X)  ; load current cursor X
 834+ 0917 32 72 61                     ld      (SCR_CUR_NX),A  ; set new cursor X
 835+ 091A CD FC 06                     call    RSTCHRCRS       ; restore char under the cursor and print it
 836+ 091D CD CC 06                     call    MOVCRS          ; move cursor into new position
 837+ 0920 C1           EXITCURSORDOWN: pop     BC              ; retrieve BC
 838+ 0921 F1                           pop     AF              ; retrieve A
 839+ 0922 C9                           ret                     ; return to caller
 840+ 0923
 841+ 0923
 842+ 0923              ; set cursor on (visible on screen)
 843+ 0923 F5           CURSOR_ON:      push    AF              ; store AF
 844+ 0924 3A 75 61                     ld      A,(CRSR_STATE)  ; load cursor state
 845+ 0927 B7                           or      A               ; is it on?
 846+ 0928 20 0C                        jr      NZ,EXITCURSOR_ON; yes, so nothing to do
 847+ 092A 3A 6C 61                     ld      A,(SCR_SIZE_H)  ; check the video mode
 848+ 092D FE 30                        cp      $30             ; graphics 2 or 3 (if value>=48)?
 849+ 092F 30 05                        jr      NC,EXITCURSOR_ON; yes, so exit (no cursor in graphics 2 or 3)
 850+ 0931 3E 01                        ld      A,$01           ; cursor state ON
 851+ 0933 32 75 61                     ld      (CRSR_STATE),A  ; set state
 852+ 0936 F1           EXITCURSOR_ON:  pop     AF              ; restore AF
 853+ 0937 C9                           ret                     ; return to caller
 854+ 0938
 855+ 0938              ; set cursor off (invisible on screen)
 856+ 0938 F5           CURSOR_OFF:     push    AF              ; store AF
 857+ 0939 AF                           xor     A               ; cursor state OFF
 858+ 093A 32 75 61                     ld      (CRSR_STATE),A  ; set state
 859+ 093D F1                           pop     AF              ; restore AF
 860+ 093E C9                           ret
 861+ 093F
 862+ 093F              ; scroll the screen 1 row up
 863+ 093F AF           SCROLLUP:       xor     A               ; reset A
 864+ 0940 57                           ld      D,A             ; reset D
 865+ 0941 32 77 61                     ld      (PRNTVIDEO),A   ; no print on screen while scrolling
 866+ 0944 2A 6E 61                     ld      HL,(SCR_NAM_TB) ; start address of the name table
 867+ 0947 22 AB 61                     ld      (VIDTMP1),HL    ; store address of the destination row (1st row of the screen)
 868+ 094A 3A 6B 61                     ld      A,(SCR_SIZE_W)  ; load the screen width
 869+ 094D 5F                           ld      E,A             ; move width into E
 870+ 094E 19                           add     HL,DE           ; HL now contains the address of the source row (2nd row of the screen)
 871+ 094F 22 AD 61                     ld      (VIDTMP2),HL    ; store address of source row
 872+ 0952 3A 6C 61                     ld      A,(SCR_SIZE_H)  ; load the screen height
 873+ 0955 3D                           dec     A               ; decrement the # of rows: now, A contains the # of rows to be moved
 874+ 0956 47                           ld      B,A             ; move # of rows into B
 875+ 0957 3A 6B 61     SCROLLNXTRW:    ld      A,(SCR_SIZE_W)  ; (re)load the screen width
 876+ 095A 5F                           ld      E,A             ; move width into E
 877+ 095B 2A AD 61                     ld      HL,(VIDTMP2)    ; load source address
 878+ 095E 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 879+ 0960 ED 69                        out     (C),L           ; low byte of source
 880+ 0962 ED 61                        out     (C),H           ; high byte of source
 881+ 0964 21 83 61                     ld      HL,VIDEOBUFF    ; load address of the first cell of the video buffer
 882+ 0967 0D                           dec     C              ; VDP data mode
 883+ 0968 00                           nop               ; added to compensate shorter instruction
 884+ 0969 ED 78        LOADNEXTCOL:    in      A,(C)           ; load char
 885+ 096B 77                           ld      (HL),A          ; store char
 886+ 096C 23                           inc     HL              ; next cell of the buffer
 887+ 096D 1D                           dec     E               ; count the chars to be read
 888+ 096E 20 F9                        jr      NZ,LOADNEXTCOL  ; repeat until we read the entire row
 889+ 0970 3A 6B 61                     ld      A,(SCR_SIZE_W)  ; reload the screen width
 890+ 0973 5F                           ld      E,A             ; move # of rows into E
 891+ 0974 16 00                        ld      D,$00           ; reset D
 892+ 0976 2A AB 61                     ld      HL,(VIDTMP1)    ; load address of destination row
 893+ 0979 E5                           push    HL              ; store HL
 894+ 097A 2A AD 61                     ld      HL,(VIDTMP2)    ; current source will be..
 895+ 097D 22 AB 61                     ld      (VIDTMP1),HL    ; ..new destination
 896+ 0980 19                           add     HL,DE           ; address of new
 897+ 0981 22 AD 61                     ld      (VIDTMP2),HL    ; source row
 898+ 0984 E1                           pop     HL              ; restore address of current destination row
 899+ 0985 CB F4                        set     6,H             ; writing mode
 900+ 0987 0E 31                        ld      C,VDP_SET       ; VDP setting mode
 901+ 0989 ED 69                        out     (C),L           ; low byte
 902+ 098B ED 61                        out     (C),H           ; high byte of address
 903+ 098D 21 83 61                     ld      HL,VIDEOBUFF    ; video buffer address
 904+ 0990 0D                           dec     C              ; VDP data mode
 905+ 0991 7E           WRITEBUF:       ld      A,(HL)          ; load char
 906+ 0992 ED 79                        out     (C),A           ; send char
 907+ 0994 23                           inc     HL              ; increment buffer index
 908+ 0995 1D                           dec     E               ; next row
 909+ 0996 20 F9                        jr      NZ,WRITEBUF     ; repeat until 0
 910+ 0998 10 BD                        djnz    SCROLLNXTRW     ; repeat for the entire screen
 911+ 099A 3A 6B 61                     ld      A,(SCR_SIZE_W)  ; reload screen width
 912+ 099D 47                           ld      B,A             ; cells to empty into B
 913+ 099E AF                           xor     A               ; null char
 914+ 099F 0E 31                        ld      C,VDP_SET       ; VDP set mode
 915+ 09A1 2A AB 61                     ld      HL,(VIDTMP1)    ; load address of the last row
 916+ 09A4 CB F4                        set     6,H             ; writing mode
 917+ 09A6 ED 69                        out     (C),L           ; low byte then..
 918+ 09A8 ED 61                        out     (C),H           ; high byte of address
 919+ 09AA 0D                           dec     C              ; VDP data mode
 920+ 09AB 00                           nop               ; delay
 921+ 09AC ED 79        RPTEMPTYROW:    out     (C),A           ; empty cell
 922+ 09AE 00                           nop                     ; delay
 923+ 09AF 00                           nop
 924+ 09B0 10 FA                        djnz    RPTEMPTYROW     ; repeat until the last row has been cleaned
 925+ 09B2 3E 01                        ld      A,$01
 926+ 09B4 32 77 61                     ld      (PRNTVIDEO),A   ; set print-on-video on
 927+ 09B7 C9                           ret                     ; return to caller
 928+ 09B8
 929+ 09B8              ; carriage return: first, it looks for char $00 at the beginning of the line (look for the first null char),
 930+ 09B8              ; then it starts sendind every char it finds on the screen to the terminal buffer of the BASIC interpreter
 931+ 09B8              ; until another null char is found. Finally, move to the next line and position the cursor at the beginning
 932+ 09B8              ; of the row (equivalent to CR+LF), then gets back control to the screen editor to let it interpret the line
 933+ 09B8              CUR_POS         equ     TMPBFR1         ; cursor position
 934+ 09B8              SRTTXT          equ     TMPBFR2         ; start of text line
 935+ 09B8              ENDTXT          equ     TMPBFR3         ; end of text line
 936+ 09B8              CRGRETURN:      ; preliminary: disable cursor if on, and retrieve char under it
 937+ 09B8 3A 75 61                     ld      A,(CRSR_STATE)  ; recover cursor state
 938+ 09BB 32 81 61                     ld      (TMPBFR4),A     ; store status
 939+ 09BE A7                           and     A               ; is cursor on?
 940+ 09BF C4 38 09                     call    NZ,CURSOR_OFF   ; yes, so set cursor off
 941+ 09C2 CD FC 06                     call    RSTCHRCRS       ; restore char under it
 942+ 09C5                              ; first, check if cursor if off, so that we just interpret return as a new line command
 943+ 09C5 3A B5 61                     ld      A,(KBDNPT)      ; check if input from keyboad
 944+ 09C8 A7                           and     A               ; if 0, input is not from keyboard...
 945+ 09C9 CA 1E 0A                     jp      Z,PRNTRETURN    ; ...so just print a carriage return; otherwise, interpret the return
 946+ 09CC                              ; first part: look for the beginning of the text line on screen
 947+ 09CC CD 05 07                     call    LOAD_CRSR_POS   ; load cursor position into HL
 948+ 09CF 22 7B 61                     ld      (CUR_POS),HL    ; store it
 949+ 09D2 ED 5B 6E 61                  ld      DE,(SCR_NAM_TB) ; load VRAM address of top-left cell of screen ("home")
 950+ 09D6 E5           RPTNLLSRC:      push    HL
 951+ 09D7 CD 3B 4D                     call    CMP16           ; check if at "home"
 952+ 09DA E1                           pop     HL
 953+ 09DB CA E6 09                     jp      Z,CNTNULL       ; yes, exit because there is nothing before
 954+ 09DE 2B                           dec     HL              ; go 1 step back
 955+ 09DF CD 86 06                     call    READ_VIDEO_LOC  ; read char of current position
 956+ 09E2 A7                           and     A               ; is it $00 (null char)?
 957+ 09E3 20 F1                        jr      NZ,RPTNLLSRC    ; no, continue searching
 958+ 09E5 23                           inc     HL              ; move 1 step forward to go back to the last cell with something in
 959+ 09E6                              ; second part: look for the ending of the text on screen
 960+ 09E6 22 7D 61     CNTNULL:        ld      (SRTTXT),HL     ; store beginning of text
 961+ 09E9 CD 3F 0A                     call    ENDOFLN         ; find end of text line looking at the end of chars after the cursor position
 962+ 09EC 22 7F 61                     ld      (ENDTXT),HL     ; store ending of text line
 963+ 09EF ED 5B 7D 61                  ld      DE,(SRTTXT)     ; load beginning of text line
 964+ 09F3 A7                           and     A               ; clear Carry
 965+ 09F4 ED 52                        sbc     HL,DE           ; how many chars?
 966+ 09F6 28 26                        jr      Z,PRNTRETURN    ; no chars found (HL-DE=0), so just print return & leave
 967+ 09F8                              ;---    central part: send the text on the screen to the interpreter
 968+ 09F8 2A 7D 61                     ld      HL,(SRTTXT)     ; load beginning of text line
 969+ 09FB ED 5B 7F 61                  ld      DE,(ENDTXT)     ; load ending of text line
 970+ 09FF CD 86 06     SNDCHRTOBFR:    call    READ_VIDEO_LOC  ; read char
 971+ 0A02 E5                           push    HL
 972+ 0A03 CD FD 01                     call    CHARINTOBFR     ; send char to buffer
 973+ 0A06 E1                           pop     HL
 974+ 0A07 23                           inc     HL              ; go to next char
 975+ 0A08 E5                           push    HL              ; store HL
 976+ 0A09 CD 3B 4D                     call    CMP16           ; check if DE=HL (finish chars)
 977+ 0A0C E1                           pop     HL
 978+ 0A0D 20 F0                        jr      NZ,SNDCHRTOBFR  ; no, repeat
 979+ 0A0F 3E 0D                        ld      A,CR            ; yes, so now send carriage return
 980+ 0A11 CD FD 01                     call    CHARINTOBFR     ; send to buffer
 981+ 0A14 2A 7F 61                     ld      HL,(ENDTXT)     ; recover address of last char of input text
 982+ 0A17 CD 28 07                     call    HL2XY           ; retrieve X,Y from address
 983+ 0A1A 7D                           ld      A,L             ; move Y into A (we don't need X anymore)
 984+ 0A1B 32 71 61                     ld      (SCR_CURS_Y),A  ; store new Y
 985+ 0A1E                              ;---    final part: go at the beginning of a new line on the screen
 986+ 0A1E AF           PRNTRETURN:     xor     A               ; move to col 0
 987+ 0A1F 32 70 61                     ld      (SCR_CURS_X),A  ; store new X
 988+ 0A22 3A 71 61                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 989+ 0A25 3C                           inc     A               ; new row
 990+ 0A26 21 6C 61                     ld      HL,SCR_SIZE_H   ; load address of cell that keeps screen height
 991+ 0A29 BE                           cp      (HL)            ; is the cursor over the bottom of the screen?
 992+ 0A2A 38 06                        jr      C,ADDNEWLINE    ; no, jump over
 993+ 0A2C 3D                           dec     A               ; yes, so come back 1 row, then...
 994+ 0A2D F5                           push    AF              ; (store A)
 995+ 0A2E CD 3F 09                     call    SCROLLUP        ; ...scroll the screen before to...
 996+ 0A31 F1                           pop     AF              ; (retrieve A)
 997+ 0A32 32 71 61     ADDNEWLINE:     ld      (SCR_CURS_Y),A  ; ...store new Y
 998+ 0A35 3A 81 61                     ld      A,(TMPBFR4)     ; retrieve cursor state
 999+ 0A38 A7                           and     A               ; was it off (A=0)?
1000+ 0A39 C4 23 09                     call    NZ,CURSOR_ON    ; no, set cursor on
1001+ 0A3C C3 C2 06                     jp      POS_CURSOR      ; position cursor to new location & return to caller
1002+ 0A3F
1003+ 0A3F              ; find end of text line
1004+ 0A3F              ; destroys A, DE, and HL - store address of last char of text line into HL,
1005+ 0A3F              ; while DE contains the address of the bottom right cell of the screen
1006+ 0A3F 3A 6C 61     ENDOFLN:        ld      A,(SCR_SIZE_H)
1007+ 0A42 5F                           ld      E,A             ; load screen height into DE
1008+ 0A43 3A 6B 61                     ld      A,(SCR_SIZE_W)
1009+ 0A46 6F                           ld      L,A             ; load screen width into HL
1010+ 0A47 AF                           xor     A
1011+ 0A48 67                           ld      H,A
1012+ 0A49 57                           ld      D,A
1013+ 0A4A CD 46 4D                     call    MUL16           ; multiply HL times DE to get the screen size
1014+ 0A4D ED 5B 6E 61                  ld      DE,(SCR_NAM_TB) ; load screen name table start address into DE
1015+ 0A51 19                           add     HL,DE           ; get the address...
1016+ 0A52 2B                           dec     HL              ; ...of the "last" video cell
1017+ 0A53 EB                           ex      DE,HL           ; store address into DE
1018+ 0A54 2A 7B 61                     ld      HL,(CUR_POS)    ; retrieve original cursor position
1019+ 0A57 E5           RPTNLLSRC2:     push    HL
1020+ 0A58 CD 3B 4D                     call    CMP16           ; check if at last position on screen (bottom right corner)
1021+ 0A5B E1                           pop     HL
1022+ 0A5C C8                           ret     Z               ; if yes, exit because these is nothing after
1023+ 0A5D 23                           inc     HL              ; 1 more step forward
1024+ 0A5E CD 86 06                     call    READ_VIDEO_LOC  ; read char of current position
1025+ 0A61 A7                           and     A               ; is it $00 (null char)?
1026+ 0A62 20 F3                        jr      NZ,RPTNLLSRC2   ; no, continue searching
1027+ 0A64 C9           CNTNULL2:       ret                     ; yes: found end of text, return to caller
1028+ 0A65
1029+ 0A65
1030+ 0A65              ; ------------------------------------------------------------------------------
1031+ 0A65                              ; this table contains the values of the offsets to be added to
1032+ 0A65                              ; the starting address of the name table to find the correct
1033+ 0A65                              ; value of the first cell of the corresponding row
1034+ 0A65                              ; (by doing so, it's faster than doing a multipication)
1035+ 0A65                              ; table for graphics 1 text mode: 32 cols
1036+ 0A65 00 00 20 00  POS_TB_CRS_32:  defw    $0000,$0020,$0040,$0060,$0080,$00A0,$00C0,$00E0
1036+ 0A69 40 00 60 00
1036+ 0A6D 80 00 A0 00
1036+ 0A71 C0 00 E0 00
1037+ 0A75 00 01 20 01                  defw    $0100,$0120,$0140,$0160,$0180,$01A0,$01C0,$01E0
1037+ 0A79 40 01 60 01
1037+ 0A7D 80 01 A0 01
1037+ 0A81 C0 01 E0 01
1038+ 0A85 00 02 20 02                  defw    $0200,$0220,$0240,$0260,$0280,$02A0,$02C0,$02E0
1038+ 0A89 40 02 60 02
1038+ 0A8D 80 02 A0 02
1038+ 0A91 C0 02 E0 02
1039+ 0A95                              ; table for pure text mode: 40 cols
1040+ 0A95 00 00 28 00  POS_TB_CRS_40:  defw    $0000,$0028,$0050,$0078,$00A0,$00C8,$00F0,$0118
1040+ 0A99 50 00 78 00
1040+ 0A9D A0 00 C8 00
1040+ 0AA1 F0 00 18 01
1041+ 0AA5 40 01 68 01                  defw    $0140,$0168,$0190,$01B8,$01E0,$0208,$0230,$0258
1041+ 0AA9 90 01 B8 01
1041+ 0AAD E0 01 08 02
1041+ 0AB1 30 02 58 02
1042+ 0AB5 80 02 A8 02                  defw    $0280,$02A8,$02D0,$02F8,$0320,$0348,$0370,$0398
1042+ 0AB9 D0 02 F8 02
1042+ 0ABD 20 03 48 03
1042+ 0AC1 70 03 98 03
1043+ 0AC5
1044+ 0AC5              ; ------------------------------------------------------------------------------
1045+ 0AC5              ; reset VRAM
1046+ 0AC5 AF           EMPTY_VRAM:     xor     A               ; reg.A cleared: we fill up VRAM with $00
1047+ 0AC6 67                           ld      H,A
1048+ 0AC7 6F                           ld      L,A             ; reset HL
1049+ 0AC8 CD 66 06                     call    SETVDPADRS      ; set address of first VRAM cell to $0000
1050+ 0ACB 06 40                        ld      B,$40           ; $40 pages of RAM...
1051+ 0ACD 57                           ld      D,A             ; ...each one with $100 cells (tot. $4000 bytes)
1052+ 0ACE 0D                           dec     C              ; VDP data mode
1053+ 0ACF ED 79        EMPTVRM:        out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
1054+ 0AD1 14                           inc     D               ; next cell
1055+ 0AD2 00                           nop
1056+ 0AD3 20 FA                        jr      NZ,EMPTVRM      ; repeat until page is fully cleared
1057+ 0AD5 10 F8                        djnz    EMPTVRM         ; repeat for $40 pages
1058+ 0AD7 C9                           ret                     ; return to caller
1059+ 0AD8
1060+ 0AD8              ; clear video registers in SRAM
1061+ 0AD8 21 6B 61     CLR_RAM_REG:    ld      HL,SCR_SIZE_W   ; address of first register
1062+ 0ADB AF                           xor     A               ; $00 to clean the registers
1063+ 0ADC 06 44                        ld      B,CHASNDDTN-SCR_SIZE_W; how many bytes (registers) to clean (dinamically calculated)
1064+ 0ADE 77           RSTVDPRAMREG:   ld      (HL),A          ; reset register
1065+ 0ADF 23                           inc     HL              ; next register
1066+ 0AE0 10 FC                        djnz    RSTVDPRAMREG    ; repeat
1067+ 0AE2 C9                           ret                     ; return to caller
1068+ 0AE3
1069+ 0AE3              ; ------------------------------------------------------------------------------
1070+ 0AE3              ; set a specific graphics mode, passed into reg. E
1071+ 0AE3 06 08        SET_GFX_MODE:   ld      B,$08           ; 8 registers means 8 bytes..
1072+ 0AE5 CB 23                        sla     E               ; multiply E by 8..
1073+ 0AE7 CB 23                        sla     E               ; so that reg. E can point..
1074+ 0AE9 CB 23                        sla     E               ; to the correct settings
1075+ 0AEB 16 00        SET_GFX_MODE2:  ld      D,$00           ; reset D
1076+ 0AED 21 1F 0B                     ld      HL,VDPMODESET   ; pointer to register settings | <= here points the SHOW_LOGO sub-routine
1077+ 0AF0 19                           add     HL,DE           ; add offset to get the correct set of values for the required mode
1078+ 0AF1 3E 80                        ld      A,$80           ; start with REG0 ($80+register number)
1079+ 0AF3 0E 31                        ld      C,VDP_SET       ; VDP set
1080+ 0AF5 56           LDREGVLS:       ld      D,(HL)          ; load register's value
1081+ 0AF6 ED 51                        out     (C),D           ; send data to VDP
1082+ 0AF8 ED 79                        out     (C),A           ; indicate the register to send data to
1083+ 0AFA 3C                           inc     A               ; next register
1084+ 0AFB 23                           inc     HL              ; next value
1085+ 0AFC 10 F7                        djnz    LDREGVLS        ; repeat for 8 registers
1086+ 0AFE C9                           ret
1087+ 0AFF
1088+ 0AFF              ; ------------------------------------------------------------------------------
1089+ 0AFF              LOADCHARSET:    ; reg. A contains the video mode
1090+ 0AFF                              ; reg. HL contains address of pattern table into VRAM
1091+ 0AFF 06 00                        ld      B,$00           ; 0=256 chars to load (complete charset)
1092+ 0B01 CB F4                        set     $06,H           ; add $4000 to address to indicate that we want to write into VRAM
1093+ 0B03 0E 31                        ld      C,VDP_SET       ; load VDP address into C
1094+ 0B05 ED 69                        out     (C),L           ; send low byte of address
1095+ 0B07 ED 61                        out     (C),H           ; send high byte
1096+ 0B09 0D                           dec     C              ; VDP data mode
1097+ 0B0A 21 71 4E                     ld      HL,CHRST68      ; starting address of 6x8 charset into ROM
1098+ 0B0D A7                           and     A               ; is it text mode (A=0)?
1099+ 0B0E 28 03                        jr      Z,NXTCHAR       ; yes, so jump to load chars into VRAM
1100+ 0B10 21 71 56                     ld      HL,CHRST88      ; no, so we change and load the 8x8 charset
1101+ 0B13 16 08        NXTCHAR:        ld      D,$08           ; 8 bytes per pattern char
1102+ 0B15 7E           SENDCHRPTRNS:   ld      A,(HL)          ; load byte to send to VDP
1103+ 0B16 ED 79                        out     (C),A           ; write byte into VRAM
1104+ 0B18 23                           inc     HL              ; inc byte pointer
1105+ 0B19 15                           dec     D               ; 8 bytes sents (0 char)?
1106+ 0B1A 20 F9                        jr      NZ,SENDCHRPTRNS ; no, continue
1107+ 0B1C 10 F5                        djnz    NXTCHAR         ; yes, decrement chars counter and continue for all the chars
1108+ 0B1E C9                           ret                     ; return to caller
1109+ 0B1F
1110+ 0B1F              ;------------------------------------------------------------------------------
1111+ 0B1F              ; NAME TABLE:       buffer video - contains the chars to be shown on video
1112+ 0B1F              ; PATTERN TABLE:    charset - contains the chars/tiles to be loaded into the name table
1113+ 0B1F              ; COLOR TABLE:      color settings for chars/tiles
1114+ 0B1F
1115+ 0B1F                              ; VDP register settings for a text display
1116+ 0B1F 00           VDPMODESET:     defb    %00000000       ; reg.0: external video off
1117+ 0B20 D0                           defb    %11010000       ; reg.1: 16K VRAM, video on, int. off, text mode (40x24)
1118+ 0B21 02                           defb    $02             ; reg.2: name table set to $0800 ($02x$400)
1119+ 0B22 00                           defb    $00             ; reg.3: not used in text mode
1120+ 0B23 00                           defb    $00             ; reg.4: pattern table set to $0000
1121+ 0B24 00                           defb    $00             ; reg.5: not used in text mode
1122+ 0B25 00                           defb    $00             ; reg.6: not used in text mode
1123+ 0B26 F5                           defb    $f5             ; reg.7: white text on light blue background
1124+ 0B27
1125+ 0B27              VDPMODESET1:    ; VDP register settings for a graphics 1 mode
1126+ 0B27 00                           defb    %00000000       ; reg.0: ext. video off
1127+ 0B28 C0                           defb    %11000000       ; reg.1: 16K Vram; video on, int off, graphics mode 1, sprite size 8x8, sprite magn. 0
1128+ 0B29 06                           defb    $06             ; reg.2: name table address: $1800
1129+ 0B2A 80                           defb    $80             ; reg.3: color table address: $2000
1130+ 0B2B 00                           defb    $00             ; reg.4: pattern table address: $0000
1131+ 0B2C 36                           defb    $36             ; reg.5: sprite attr. table address: $1B00
1132+ 0B2D 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1133+ 0B2E 05                           defb    $05             ; reg.7: backdrop color (light blue)
1134+ 0B2F
1135+ 0B2F              VDPMODESET2:    ; VDP register settings for a graphics 2 mode
1136+ 0B2F 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1137+ 0B30 C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1138+ 0B31 06                           defb    $06             ; reg.2: name table addr.: $1800
1139+ 0B32 FF                           defb    $FF             ; reg.3: color table addr.: $2000
1140+ 0B33 03                           defb    $03             ; reg.4: pattern table addr.: $0000
1141+ 0B34 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1142+ 0B35 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1143+ 0B36 05                           defb    $05             ; reg.7: backdrop color: light blue
1144+ 0B37
1145+ 0B37              VDPMODESETMC:   ; VDP register settings for a multicolor mode
1146+ 0B37 00                           defb    %00000000       ; reg.0: ext. video dis.
1147+ 0B38 CB                           defb    %11001011       ; reg.1: 16K VRAM, video on, INT off, multicolor mode, sprite size 8x8, sprite magn. 0
1148+ 0B39 02                           defb    $02             ; reg.2: name table addr.: $0800
1149+ 0B3A 00                           defb    $00             ; reg.3: don't care
1150+ 0B3B 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1151+ 0B3C 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1152+ 0B3D 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1153+ 0B3E 0F                           defb    $0F             ; reg.7: backdrop color (white)
1154+ 0B3F
1155+ 0B3F              VDPMODESETEX2:  ; VDP register settings for an extended graphics 2 mode
1156+ 0B3F 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1157+ 0B40 C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1158+ 0B41 0E                           defb    $0E             ; reg.2: name table addr.: $3800
1159+ 0B42 9F                           defb    $9F             ; reg.3: color table addr.: $2000
1160+ 0B43 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1161+ 0B44 76                           defb    $76             ; reg.5: sprite attr. table addr.: $3B00
1162+ 0B45 03                           defb    $03             ; reg.6: sprite pattern table addr.: $1800
1163+ 0B46 05                           defb    $05             ; reg.7: backdrop color: light blue
1164+ 0B47
1165+ 0B47              LM80CLOGO:      ; patterns to compose the splash screen logo
1166+ 0B47                              ; 1st band
1167+ 0B47 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1167+ 0B4B 00 00 00 00
1167+ 0B4F 00 00 00 00
1167+ 0B53 00 00 00 00
1167+ 0B57 00 00 00 00
1167+ 0B5B 00 00 00 00
1167+ 0B5F 00 00 00 00
1167+ 0B63 00 00 00 00
1168+ 0B67 00 00 0F 0A                  defb    0,0,15,10,11,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1168+ 0B6B 0B 10 00 00
1168+ 0B6F 00 00 00 00
1168+ 0B73 00 00 00 00
1168+ 0B77 00 00 00 00
1168+ 0B7B 00 00 00 00
1168+ 0B7F 00 00 00 00
1168+ 0B83 00 00 00 00
1169+ 0B87                              ; 2nd band
1170+ 0B87 00 00 0D 17                  defb    0,0,13,23,0,12,0,0,0,1,0,0,0,20,0,0,6,5,6,21,22,7,6,21,22,7,6,1,1,7,0,0
1170+ 0B8B 00 0C 00 00
1170+ 0B8F 00 01 00 00
1170+ 0B93 00 14 00 00
1170+ 0B97 06 05 06 15
1170+ 0B9B 16 07 06 15
1170+ 0B9F 16 07 06 01
1170+ 0BA3 01 07 00 00
1171+ 0BA7 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,20,6,1,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1171+ 0BAB 00 0C 00 00
1171+ 0BAF 00 01 00 00
1171+ 0BB3 00 01 14 06
1171+ 0BB7 01 05 03 05
1171+ 0BBB 03 05 03 05
1171+ 0BBF 03 05 03 05
1171+ 0BC3 03 05 00 00
1172+ 0BC7                              ; 3rd band
1173+ 0BC7 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,1,1,1,5,9,20,19,8,3,5,19,5,3,5,0,0,0,0
1173+ 0BCB 00 0C 00 00
1173+ 0BCF 00 01 00 00
1173+ 0BD3 00 01 01 01
1173+ 0BD7 01 05 09 14
1173+ 0BDB 13 08 03 05
1173+ 0BDF 13 05 03 05
1173+ 0BE3 00 00 00 00
1174+ 0BE7 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,8,3,5,6,21,22,7,3,1,22,5,3,5,0,0,0,0
1174+ 0BEB 00 0C 00 00
1174+ 0BEF 00 01 00 00
1174+ 0BF3 00 01 00 08
1174+ 0BF7 03 05 06 15
1174+ 0BFB 16 07 03 01
1174+ 0BFF 16 05 03 05
1174+ 0C03 00 00 00 00
1175+ 0C07                              ; 4th band
1176+ 0C07 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,0,3,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1176+ 0C0B 00 0C 00 00
1176+ 0C0F 00 01 00 00
1176+ 0C13 00 01 00 00
1176+ 0C17 03 05 03 05
1176+ 0C1B 03 05 03 05
1176+ 0C1F 03 05 03 05
1176+ 0C23 03 05 00 00
1177+ 0C27 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,4,4,0,1,0,0,3,5,9,20,19,8,9,20,19,8,9,1,1,8,0,0
1177+ 0C2B 00 0C 00 00
1177+ 0C2F 00 01 04 04
1177+ 0C33 00 01 00 00
1177+ 0C37 03 05 09 14
1177+ 0C3B 13 08 09 14
1177+ 0C3F 13 08 09 01
1177+ 0C43 01 08 00 00
1178+ 0C47                              ; 5th band
1179+ 0C47 00 00 0E 12                  defb    0,0,14,18,18,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1179+ 0C4B 12 11 00 00
1179+ 0C4F 00 00 00 00
1179+ 0C53 00 00 00 00
1179+ 0C57 00 00 00 00
1179+ 0C5B 00 00 00 00
1179+ 0C5F 00 00 00 00
1179+ 0C63 00 00 00 00
1180+ 0C67 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1180+ 0C6B 00 00 00 00
1180+ 0C6F 00 00 00 00
1180+ 0C73 00 00 00 00
1180+ 0C77 00 00 00 00
1180+ 0C7B 00 00 00 00
1180+ 0C7F 00 00 00 00
1180+ 0C83 00 00 00 00
# file closed: ../include/vdp/vdp-1.5.asm
  77  0C87
  78  0C87              ; incude the latest version of the PSG module
  79  0C87                  INCLUDE "../include/psg/psg-1.1.asm"
# file opened: ../include/psg/psg-1.1.asm
   1+ 0C87              ; ------------------------------------------------------------------------------
   2+ 0C87              ; LM80C - PSG ROUTINES - 1.1
   3+ 0C87              ; ------------------------------------------------------------------------------
   4+ 0C87              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0C87              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0C87              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0C87              ; kind of warranty: you can use them at your own risk.
   8+ 0C87              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0C87              ; maintain the copyright notices, include this advice and the note to the
  10+ 0C87              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0C87              ; redistribuite them.
  12+ 0C87              ; https://www.leonardomiliani.com
  13+ 0C87              ;
  14+ 0C87              ; Please support me by visiting the following links:
  15+ 0C87              ; Main project page: https://www.leonardomiliani.com
  16+ 0C87              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0C87              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0C87              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0C87              ; ------------------------------------------------------------------------------
  20+ 0C87              ;
  21+ 0C87              ; ------------------------------------------------------------------------------
  22+ 0C87
  23+ 0C87              ;------------------------------------------------------------------------------
  24+ 0C87
  25+ 0C87              ; configure the PSG
  26+ 0C87 21 AF 61     initPSG:        ld      HL,CHASNDDTN    ; starting address of sound & keyboard RAM registers
  27+ 0C8A 06 0E                        ld      B,SERIALS_EN-CHASNDDTN; # of PSG sound & keyboard registers
  28+ 0C8C AF                           xor     A               ; reset A
  29+ 0C8D 77           EMPTSNDBFR:     ld      (HL),A          ; reset RAM register
  30+ 0C8E 23                           inc     HL              ; next register
  31+ 0C8F 10 FC                        djnz    EMPTSNDBFR      ; repeat
  32+ 0C91 06 10        CLRPSGREGS:     ld      B,$10           ; 16 registers to set
  33+ 0C93 21 A5 0C                     ld      HL,SNDREGCFG    ; starting address of register settings
  34+ 0C96 16 00                        ld      D,$00           ; first register
  35+ 0C98 7A           RSTPSG:         ld      A,D             ; register value
  36+ 0C99 CD DF 0C                     call    SETSNDREG       ; select register
  37+ 0C9C 7E                           ld      A,(HL)          ; load value
  38+ 0C9D CD E4 0C                     call    WRTSNDREG       ; write to register
  39+ 0CA0 14                           inc     D               ; next register
  40+ 0CA1 23                           inc     HL              ; next value
  41+ 0CA2 10 F4                        djnz    RSTPSG          ; repeat for each register
  42+ 0CA4 C9                           ret                     ; return to caller
  43+ 0CA5
  44+ 0CA5 00 00 00 00  SNDREGCFG:      defb $00,$00,$00,$00,$00,$00,$00,%10111111
  44+ 0CA9 00 00 00 BF
  45+ 0CAD 00 00 00 00                  defb $00,$00,$00,$00,$00,$00,$ff,$ff
  45+ 0CB1 00 00 FF FF
  46+ 0CB5                              ; reg. 7: set I/O ch.A to OUTPUT, I/O ch.B to INPUT; set noise to OFF; set audio to OFF
  47+ 0CB5
  48+ 0CB5
  49+ 0CB5              ; routine to play a welcome beep on channel C (tone 4010) and to shut it off
  50+ 0CB5 21 CF 0C     WLCMBEEP:       ld      HL,WLCBPDAT     ; data address
  51+ 0CB8 C3 BE 0C                     jp      SENDSND
  52+ 0CBB 21 D7 0C     NOBEEP:         ld      HL,NOBPDAT      ; data address
  53+ 0CBE C5           SENDSND:        push    BC
  54+ 0CBF 06 04                        ld      B,$04           ; 4 pairs
  55+ 0CC1 7E           RPTWLCMBP:      ld      A,(HL)          ; read register #
  56+ 0CC2 CD DF 0C                     call    SETSNDREG
  57+ 0CC5 23                           inc     HL              ; next cell
  58+ 0CC6 7E                           ld      A,(HL)          ; read value
  59+ 0CC7 CD E4 0C                     call    WRTSNDREG
  60+ 0CCA 23                           inc     HL
  61+ 0CCB 10 F4                        djnz    RPTWLCMBP       ; repeat
  62+ 0CCD C1                           pop     BC
  63+ 0CCE C9                           ret                     ; return to caller
  64+ 0CCF
  65+ 0CCF 07 BB 04 56  WLCBPDAT:       defb    $07,%10111011,$04,$56,$05,$00,$0A,$0F
  65+ 0CD3 05 00 0A 0F
  66+ 0CD7 04 00 05 00  NOBPDAT:        defb    $04,$00,$05,$00,$0A,$00,$07,%10111111
  66+ 0CDB 0A 00 07 BF
  67+ 0CDF
  68+ 0CDF
  69+ 0CDF              ; select register on PSG
  70+ 0CDF 0E 40        SETSNDREG:      ld      C,PSG_REG       ; PSG register port
  71+ 0CE1 ED 79                        out     (C),A           ; set register
  72+ 0CE3 C9                           ret                     ; return to caller
  73+ 0CE4
  74+ 0CE4              ; send data to PSG
  75+ 0CE4 0E 41        WRTSNDREG:      ld      C,PSG_DAT       ; PSG data port
  76+ 0CE6 ED 79                        out     (C),A           ; send data
  77+ 0CE8 C9                           ret                     ; return to caller
  78+ 0CE9
  79+ 0CE9              ; manage the sounds' duration: each time this subroutine is called, it
  80+ 0CE9              ; decrements the single sound durations (measured in ms) and eventually
  81+ 0CE9              ; shut off the audio channel whose counter has reached 0.
  82+ 0CE9              ; (this sub-routine is called by CH3 timer ISR)
  83+ 0CE9 DD E5        MNGSNDS:        push    IX              ; store IX
  84+ 0CEB DD 21 AF 61                  ld      IX,CHASNDDTN    ; starting address of tones duration
  85+ 0CEF 06 03                        ld      B,$03           ; 3 channels to check
  86+ 0CF1 26 01                        ld      H,$01           ; mixer channels: A=>bit 1, B=>bit 2, C=>bit 3
  87+ 0CF3 DD 5E 00     CHKSNDCH:       ld      E,(IX+0)        ; load LSB into E
  88+ 0CF6 DD 56 01                     ld      D,(IX+1)        ; load MSB into D
  89+ 0CF9 7B                           ld      A,E             ; load E into A
  90+ 0CFA B2                           or      D               ; check that DE=0
  91+ 0CFB 28 31                        jr      Z,CNTCHKSND     ; yes, jump over
  92+ 0CFD 1B                           dec     DE              ; no, so decrement DE
  93+ 0CFE 7B                           ld      A,E             ; reload E into A...
  94+ 0CFF DD 73 00                     ld      (IX+0),E        ; store new...
  95+ 0D02 DD 72 01                     ld      (IX+1),D        ; ...duration and...
  96+ 0D05 B2                           or      D               ; ...do another check to see if DE=0
  97+ 0D06 20 26                        jr      NZ,CNTCHKSND    ; no, so jump over
  98+ 0D08                                                      ; if yes, let's shut down the corresponding channel
  99+ 0D08                                                      ; to shut down a tone we disable it into the mixer
 100+ 0D08                                                      ; then set 0 into its tone registers
 101+ 0D08 16 07                        ld      D,$07           ; mixer register
 102+ 0D0A 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 103+ 0D0C ED 51                        out     (C),D           ; set mixer register
 104+ 0D0E ED 78                        in      A,(C)           ; load current value
 105+ 0D10 B4                           or      H               ; set off the channel into the mixer (remember that 1=OFF)
 106+ 0D11 ED 51                        out     (C),D           ; select mixer register
 107+ 0D13 0E 41                        ld      C,PSG_DAT       ; PSG data port
 108+ 0D15 ED 79                        out     (C),A           ; send new value for the mixer
 109+ 0D17 3E 03                        ld      A,$03           ; three channels
 110+ 0D19 90                           sub     B               ; find current channel (0->A, 1->B, 2->C)
 111+ 0D1A 87                           add     A,A             ; and find first register (A=>0, B=>2, C=>4)
 112+ 0D1B 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 113+ 0D1D ED 79                        out     (C),A           ; select first tone register of channel
 114+ 0D1F 2E 00                        ld      L,$00           ; value 0 into L
 115+ 0D21 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 116+ 0D23 ED 69                        out     (C),L           ; write 0 into register
 117+ 0D25 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 118+ 0D27 3C                           inc     A               ; next tone register
 119+ 0D28 ED 79                        out     (C),A           ; select second tone register of channel
 120+ 0D2A 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 121+ 0D2C ED 69                        out     (C),L           ; write 0 into register
 122+ 0D2E DD 23        CNTCHKSND:      inc     IX              ; set for...
 123+ 0D30 DD 23                        inc     IX              ; ...next channel...
 124+ 0D32 CB 24                        sla     H               ; shift left H 1 bit
 125+ 0D34 10 BD                        djnz    CHKSNDCH        ; repeat for 3 channels
 126+ 0D36 DD E1                        pop     IX              ; restore IX
 127+ 0D38 C9                           ret                     ; return to caller
 128+ 0D39
 129+ 0D39              ; read a specific row of the keyboard matrix, set by A
 130+ 0D39              ; return read into A
 131+ 0D39 C5           READKBLN:       push    BC              ; store BC
 132+ 0D3A 06 0F                        ld      B,$0F           ; reg #15
 133+ 0D3C 0E 40                        ld      C,PSG_REG       ; PSG register port
 134+ 0D3E ED 41                        out     (C),B           ; select reg #15
 135+ 0D40 0E 41                        ld      C,PSG_DAT       ; PSG data port
 136+ 0D42 ED 79                        out     (C),A           ; activate the row
 137+ 0D44 06 0E                        ld      B,$0E           ; register #14 (port B)
 138+ 0D46 0E 40                        ld      C,PSG_REG       ; PSG register port
 139+ 0D48 ED 41                        out     (C),B           ; select reg. 14 (port B)
 140+ 0D4A ED 78                        in      A,(C)           ; read register #14
 141+ 0D4C C1                           pop     BC              ; retrieve BC
 142+ 0D4D C9                           ret
 143+ 0D4E
 144+ 0D4E              ; read the keyboard matrix to look for a key pressure
 145+ 0D4E 0E 40        KEYBOARD:       ld      C,PSG_REG       ; PSG register port
 146+ 0D50 06 07                        ld      B,$07           ; set register #7...
 147+ 0D52 ED 41                        out     (C),B           ; ...to work with
 148+ 0D54 ED 78                        in      A,(C)           ; read register #7
 149+ 0D56 CB FF                        set     7,A             ; port A set to output
 150+ 0D58 CB B7                        res     6,A             ; port B set to input
 151+ 0D5A ED 41                        out     (C),B           ; set register #7
 152+ 0D5C 0E 41                        ld      C,PSG_DAT       ; PSG data port
 153+ 0D5E ED 79                        out     (C),A           ; set I/O ports w/o altering the rest of the mixer
 154+ 0D60                              ; check special keys (SHIFT/ALT/CTRL)
 155+ 0D60 3E FD                        ld      A,%11111101     ; select SHIFT row
 156+ 0D62 CD 39 0D                     call    READKBLN        ; read row
 157+ 0D65 CB 5F                        bit     3,A             ; test if SHIFT key is pressed (4th bit is reset)
 158+ 0D67 20 05                        jr      NZ,CHECKALT     ; no, so go on
 159+ 0D69 21 BC 61                     ld      HL,CONTROLKEYS  ; control key flags
 160+ 0D6C 36 01                        ld      (HL),%00000001  ; set SHIFT flag, reset CTRL & ALT flags (currently multiply control keys are NOT supported)
 161+ 0D6E 3E FE        CHECKALT:       ld      A,%11111110     ; select ALT row
 162+ 0D70 CD 39 0D                     call    READKBLN        ; read ALT row
 163+ 0D73 CB 6F                        bit     5,A             ; test if ALT key is pressed (5th bit is reset)
 164+ 0D75 20 05                        jr      NZ,CHECKCTRL    ; no, so go on
 165+ 0D77 21 BC 61                     ld      HL,CONTROLKEYS  ; control key flags
 166+ 0D7A 36 04                        ld      (HL),%00000100  ; set ALT flag, reset SHIFT & CTRL flag (currently multiply control keys are NOT supported)
 167+ 0D7C 3E FE        CHECKCTRL:      ld      A,%11111110     ; select CTRL row
 168+ 0D7E CD 39 0D                     call    READKBLN        ; read CTRL row
 169+ 0D81 CB 57                        bit     2,A             ; test if CTRL key is pressed (3rd bit is reset)
 170+ 0D83 20 05                        jr      NZ,CHECKKBD     ; no, so make a normal reading
 171+ 0D85 21 BC 61                     ld      HL,CONTROLKEYS  ; control key flags
 172+ 0D88 36 02                        ld      (HL),%00000010  ; set CTRL flag, reset SHIFT & ALT flags (currently multiply control keys are NOT supported)
 173+ 0D8A 06 08        CHECKKBD:       ld      B,$08           ; 8 lines
 174+ 0D8C 3E 7F                        ld      A,%01111111     ; start from the last line of the matrix
 175+ 0D8E 16 0F        RPTKBDRD:       ld      D,$0F           ; register #15 (port B)
 176+ 0D90 0E 40                        ld      C,PSG_REG       ; PSG register port
 177+ 0D92 ED 51                        out     (C),D           ; select reg. #15
 178+ 0D94 0E 41                        ld      C,PSG_DAT       ; PSG data port
 179+ 0D96 ED 79                        out     (C),A           ; activate 1 line (active line is grounded, i.e. with a LOW signal)
 180+ 0D98 5F                           ld      E,A             ; save current line into E
 181+ 0D99 16 0E                        ld      D,$0E           ; register #14 (port A)
 182+ 0D9B 0E 40                        ld      C,PSG_REG       ; PSG register port
 183+ 0D9D ED 51                        out     (C),D           ; select reg. 14 (port A)
 184+ 0D9F 00                           nop
 185+ 0DA0 ED 78                        in      A,(C)           ; read register #14
 186+ 0DA2 FE FF                        cp      $FF             ; is there any line set to 0?
 187+ 0DA4 28 2E                        jr      Z,NOKEYPRSD     ; no, go to the next row
 188+ 0DA6                              ; check control keys
 189+ 0DA6 32 B6 61                     ld      (KBTMP),A       ; yes, check if a control key was pressed. First, store current row
 190+ 0DA9 78                           ld      A,B             ; copy current row (B) into A
 191+ 0DAA FE 02                        cp      $02             ; is it the row of the SHIFT?
 192+ 0DAC 20 0F                        jr      NZ,TESTALT      ; no, continue checking the other control keys
 193+ 0DAE 3A B6 61                     ld      A,(KBTMP)       ; yes, retrieve current row data
 194+ 0DB1 CB 5F                        bit     3,A             ; check SHIFT bit line
 195+ 0DB3 20 31                        jr      NZ,FINDKEY      ; no SHIFT, continue checking
 196+ 0DB5 CB DF                        set     3,A             ; yes, it's the SHIFT. So remove SHIFT bit
 197+ 0DB7 FE FF                        cp      $FF             ; after deleting the SHIFT bit, is there any other bit selected?
 198+ 0DB9 20 2B                        jr      NZ,FINDKEY      ; yes, go to check which one
 199+ 0DBB 18 17                        jr      NOKEYPRSD       ; no, go to next row
 200+ 0DBD FE 01        TESTALT:        cp      $01             ; is it the line of ALT & CTRL?
 201+ 0DBF 3A B6 61                     ld      A,(KBTMP)       ; retrieve current row data
 202+ 0DC2 20 22                        jr      NZ,FINDKEY      ; no, continue
 203+ 0DC4 CB 6F                        bit     5,A             ; yes, check ALT bit line
 204+ 0DC6 20 02                        jr      NZ,TESTCTRL     ; no ALT, continue checking
 205+ 0DC8 CB EF                        set     5,A             ; yes, it's the ALT. So remove ALT bit
 206+ 0DCA CB 57        TESTCTRL:       bit     2,A             ; check CTRL bit line
 207+ 0DCC 20 02                        jr      NZ,ENDCTRLCK    ; no CTRL, continue checking
 208+ 0DCE CB D7                        set     2,A             ; delete CTRL bit flag
 209+ 0DD0 FE FF        ENDCTRLCK:      cp      $FF             ; after deleting the ALT & CTRL bits, is there any other bit selected?
 210+ 0DD2 20 12                        jr      NZ,FINDKEY      ; yes, go to check which one
 211+ 0DD4 7B           NOKEYPRSD:      ld      A,E             ; no key pressed, load current output port
 212+ 0DD5 0F                           rrca                    ; rotate right by 1
 213+ 0DD6 10 B6                        djnz    RPTKBDRD        ; repeat for 8 lines
 214+ 0DD8 AF                           xor     A               ; if exit from here, no key has been pressed...
 215+ 0DD9 32 B8 61                     ld      (LASTKEYPRSD),A ; ...so reset the last key cell...
 216+ 0DDC 32 BC 61                     ld      (CONTROLKEYS),A ; ...reset contro key flags...
 217+ 0DDF 32 B5 61                     ld      (KBDNPT),A      ; ...no input from keyboard...
 218+ 0DE2 32 B9 61                     ld      (STATUSKEY),A   ; ...no auto-repeat...
 219+ 0DE5 C9                           ret                     ; ...and leave
 220+ 0DE6 1E FF        FINDKEY:        ld      E,$FF           ; counter
 221+ 0DE8 1C           CHKLN:          inc     E               ; E goes from 0 to 7
 222+ 0DE9 CB 3F                        srl     A               ; is the first bit reset? (we're looking for a "0", meaning grounded line)
 223+ 0DEB 38 FB                        jr      C,CHKLN         ; no, check next bit
 224+ 0DED 3A BC 61                     ld      A,(CONTROLKEYS) ; load control key flags
 225+ 0DF0 21 09 0F                     ld      HL,KBMAP        ; normal keymap
 226+ 0DF3 FE 01                        cp      $01             ; SHIFT flag?
 227+ 0DF5 20 05                        jr      NZ,CHKCTRL      ; no, jump over
 228+ 0DF7 21 49 0F                     ld      HL,KBMAP_SFT    ; SHIFT keymap
 229+ 0DFA 18 10                        jr      LOADMAP         ; and load it
 230+ 0DFC FE 02        CHKCTRL:        cp      $02             ; CTRL flag?
 231+ 0DFE 20 05                        jr      NZ,CHKALT       ; no, jump over
 232+ 0E00 21 C9 0F                     ld      HL,KBMAP_CTRL   ; CTRL map
 233+ 0E03 18 07                        jr      LOADMAP         ; and load it
 234+ 0E05 FE 04        CHKALT:         cp      $04             ; ALT flag?
 235+ 0E07 20 03                        jr      NZ,LOADMAP      ; no, check over
 236+ 0E09 21 89 0F                     ld      HL,KBMAP_ALT    ; ALT map
 237+ 0E0C 05           LOADMAP:        dec     B               ; decrement row # (rows go from 0 to 7)
 238+ 0E0D 48                           ld      C,B             ; move B into C and...
 239+ 0E0E CB 21                        sla     C               ; ...multiply it...
 240+ 0E10 CB 21                        sla     C               ; ...by 8 to find...
 241+ 0E12 CB 21                        sla     C               ; ...the current row into the matrix
 242+ 0E14 06 00                        ld      B,$00           ; reset B
 243+ 0E16 09                           add     HL,BC           ; find the address of the current row
 244+ 0E17 50                           ld      D,B             ; reset D
 245+ 0E18 19                           add     HL,DE           ; find the current column - now (HL) stores the pressed key
 246+ 0E19 3A B8 61                     ld      A,(LASTKEYPRSD) ; load the last key pressed
 247+ 0E1C BE                           cp      (HL)            ; is it the same key?
 248+ 0E1D 20 41                        jr      NZ,NEWKEY       ; no, it's a new key
 249+ 0E1F 44 4D                        ld      BC,HL           ; store address of current keycode
 250+ 0E21 2A 5B 61                     ld      HL,(TMRCNT)     ; load current system timer
 251+ 0E24 ED 5B BA 61                  ld      DE,(KEYTMR)     ; load auto-repeat timer
 252+ 0E28 3A B9 61                     ld      A,(STATUSKEY)   ; yes, load current status of auto-repeat
 253+ 0E2B FE 01                        cp      $01             ; is it initial pressure?
 254+ 0E2D 20 1F                        jr      NZ,CHKAUTO      ; no, jump over
 255+ 0E2F AF                           xor     A               ; clear Carry
 256+ 0E30 ED 52                        sbc     HL,DE           ; startint time - actual time
 257+ 0E32 16 00                        ld      D,$00           ; 64 ths/s > 640 ms
 258+ 0E34 3A 28 60                     ld      A,(KEYDEL)
 259+ 0E37 5F                           ld      E,A
 260+ 0E38 CD 3B 4D                     call    CMP16           ; time elapsed is >= $40?
 261+ 0E3B DA B0 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 262+ 0E3E 3E 02        SETNEWAUTO:     ld      A,$02           ; yes set status to...
 263+ 0E40 32 B9 61                     ld      (STATUSKEY),A   ; ...auto-repeat
 264+ 0E43 2A 5B 61                     ld      HL,(TMRCNT)     ; load system timer
 265+ 0E46 22 BA 61                     ld      (KEYTMR),HL     ; store starting time
 266+ 0E49 60 69                        ld      HL,BC           ; retrieve address of current keycode
 267+ 0E4B C3 6D 0E                     jp      SENDKEY         ; send key
 268+ 0E4E AF           CHKAUTO:        xor     A               ; clear Carry
 269+ 0E4F ED 52                        sbc     HL,DE           ; computer interval between initial pressure of key and current time
 270+ 0E51 16 00                        ld      D,$00
 271+ 0E53 3A 29 60                     ld      A,(AUTOKE)
 272+ 0E56 5F                           ld      E,A             ; auto-repeat delay into DE
 273+ 0E57 CD 3B 4D                     call    CMP16           ; check if interval is greater than delay
 274+ 0E5A DA B0 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 275+ 0E5D C3 3E 0E                     jp      SETNEWAUTO      ; set new loop and send key
 276+ 0E60 AF           NEWKEY:         xor     A               ; set initial state...
 277+ 0E61 3C                           inc     A               ; ...for auto-repeat...
 278+ 0E62 32 B9 61                     ld      (STATUSKEY),A   ; ...1=pressure init
 279+ 0E65 ED 4B 5B 61                  ld      BC,(TMRCNT)     ; load current system timer
 280+ 0E69 ED 43 BA 61                  ld      (KEYTMR),BC     ; set starting time
 281+ 0E6D 7E           SENDKEY:        ld      A,(HL)          ; then, load key...
 282+ 0E6E 32 B8 61                     ld      (LASTKEYPRSD),A ; ...store it...
 283+ 0E71 32 B7 61                     ld      (TMPKEYBFR),A   ; ...insert it into the INKEY buffer...
 284+ 0E74 32 78 61                     ld      (CHR4VID),A     ; ...and store char for video
 285+ 0E77 FE 03                        cp      CTRLC           ; is it RUN/STOP?
 286+ 0E79 20 05                        jr      NZ,CNTKBCK      ; no, jump over
 287+ 0E7B CD FD 01                     call    CHARINTOBFR     ; yes, send directly to buffer and...
 288+ 0E7E 18 30                        jr      LVKBRDCHK2      ; ...leave
 289+ 0E80 01 00 08     CNTKBCK:        ld      BC,$0800        ; 8 FN keys (B), FN key number (C)
 290+ 0E83 21 01 0F                     ld      HL,FNKEYSORD    ; FN keys codes
 291+ 0E86 BE           CHKFNK:         cp      (HL)            ; is it an FN key?
 292+ 0E87 CA B5 0E                     jp      Z,PRNTFNKEY     ; yes, jump over
 293+ 0E8A 0C                           inc     C               ; next FN key
 294+ 0E8B 23                           inc     HL              ; next FN key code
 295+ 0E8C 10 F8                        djnz    CHKFNK          ; continue for 8 FN keys
 296+ 0E8E 3E 01        SNDKEYTOBFR:    ld      A,$01           ; normal key - set input flag
 297+ 0E90 32 B5 61                     ld      (KBDNPT),A      ; to keyboard
 298+ 0E93 3A 77 61                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 299+ 0E96 B7                           or      A               ; is the print-on-video disabled?
 300+ 0E97 CA A0 0E                     jp      Z,PUTCHRBUF     ; yes, so send char to input buffer
 301+ 0E9A 3A 75 61                     ld      A,(CRSR_STATE)  ; check cursor state
 302+ 0E9D B7                           or      A               ; is it 0 (cursor OFF)?
 303+ 0E9E 20 0D                        jr      NZ,PNT2VD       ; no, print on screen
 304+ 0EA0 AF           PUTCHRBUF:      xor     A
 305+ 0EA1 32 B5 61                     ld      (KBDNPT),A      ; if send to input buffer, set RETURN as from BASIC
 306+ 0EA4 3A B7 61                     ld      A,(TMPKEYBFR)   ; retrieve char
 307+ 0EA7 CD FD 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 308+ 0EAA C3 B0 0E                     jp      LVKBRDCHK2      ; ...and leave
 309+ 0EAD CD 57 07     PNT2VD:         call    CHAR2VID        ; send char to video
 310+ 0EB0 AF           LVKBRDCHK2:     xor     A
 311+ 0EB1 32 BC 61                     ld      (CONTROLKEYS),A ; reset control key flags
 312+ 0EB4 C9           LVKBRDCHK:      ret                     ; return to caller: the current key code is into TMPKEYBFR
 313+ 0EB5                              ; manage FN keys
 314+ 0EB5 57           PRNTFNKEY:      ld      D,A             ; copy A into D
 315+ 0EB6 2A 24 60                     ld      HL,(LINEAT)     ; Get current line number
 316+ 0EB9 23                           inc     HL              ; -1 means direct statement
 317+ 0EBA 7C                           ld      A,H
 318+ 0EBB B5                           or      L
 319+ 0EBC 7A                           ld      A,D             ; retrieve char
 320+ 0EBD 20 CF                        jr      NZ,SNDKEYTOBFR  ; indirect mode - just send FN key code to buffer
 321+ 0EBF 79                           ld      A,C             ; direct mode, so print text - first, get FN key number
 322+ 0EC0 87                           add     A,A
 323+ 0EC1 87                           add     A,A
 324+ 0EC2 87                           add     A,A
 325+ 0EC3 87                           add     A,A             ; FN key number * 16
 326+ 0EC4 4F                           ld      C,A             ; move it into C
 327+ 0EC5 06 00                        ld      B,$00           ; reset B, to get offset
 328+ 0EC7 21 2A 60                     ld      HL,FNKEYS       ; load address of FN keys texts
 329+ 0ECA 09                           add     HL,BC           ; get correct text address
 330+ 0ECB 06 10                        ld      B,$10           ; 16 chars
 331+ 0ECD 7E           LDFNKEYCHR:     ld      A,(HL)          ; load char
 332+ 0ECE A7                           and     A               ; null char?
 333+ 0ECF CA B0 0E                     jp      Z,LVKBRDCHK2    ; yes, so leave
 334+ 0ED2 57                           ld      D,A             ; pass char into D
 335+ 0ED3 3A 77 61                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 336+ 0ED6 B7                           or      A               ; is the print-on-video disabled?
 337+ 0ED7 CA E7 0E                     jp      Z,PUTCHRBUF1    ; yes, so send char to input buffer
 338+ 0EDA 3A 75 61                     ld      A,(CRSR_STATE)  ; check cursor state
 339+ 0EDD B7                           or      A               ; is it 0 (cursor OFF)?
 340+ 0EDE C4 F4 0E                     call    NZ,PRNTFNK      ; no, print on screen
 341+ 0EE1 23           CNTFNK:         inc     HL              ; next char
 342+ 0EE2 10 E9                        djnz    LDFNKEYCHR      ; repeat for max. 16 chars
 343+ 0EE4 C3 B0 0E                     jp      LVKBRDCHK2      ; leave
 344+ 0EE7 AF           PUTCHRBUF1:     xor     A               ; if send to input buffer,...
 345+ 0EE8 32 B5 61                     ld      (KBDNPT),A      ; ...set input as from BASIC
 346+ 0EEB 7A                           ld      A,D             ; retrieve char
 347+ 0EEC E5                           push    HL              ; store HL
 348+ 0EED CD FD 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 349+ 0EF0 E1                           pop     HL              ; retrieve HL
 350+ 0EF1 C3 E1 0E                     jp      CNTFNK          ; repeat
 351+ 0EF4 7A           PRNTFNK:        ld      A,D             ; recover char
 352+ 0EF5 32 78 61                     ld      (CHR4VID),A     ; store char for printing
 353+ 0EF8 3E 01                        ld      A,$01           ; normal key - set input flag
 354+ 0EFA 32 B5 61                     ld      (KBDNPT),A      ; to keyboard
 355+ 0EFD CD 57 07                     call    CHAR2VID        ; print on screen
 356+ 0F00 C9                           ret                     ; return to caller
 357+ 0F01
 358+ 0F01
 359+ 0F01              ;-----------------------------------------------------------------------
 360+ 0F01 01 02 04 05  FNKEYSORD:      defb 1,2,4,5,6,22,23,24                 ; order of FN Keys
 360+ 0F05 06 16 17 18
 361+ 0F09              ;-----------------------------------------------------------------------
 362+ 0F09              ; key codes
 363+ 0F09 31 19 0E 03  KBMAP:          defb '1',25,14,3,' ',16,'q','2'         ; 25=HOME  14=CTRL  3=RUN/STOP 16=C=
 363+ 0F0D 20 10 71 32
 364+ 0F11 33 77 61 14                  defb '3','w','a',20,'z','s','e','4'     ; 20=SHIFT
 364+ 0F15 7A 73 65 34
 365+ 0F19 35 72 64 78                  defb '5','r','d','x','c','f','t','6'
 365+ 0F1D 63 66 74 36
 366+ 0F21 37 79 67 76                  defb '7','y','g','v','b','h','u','8'
 366+ 0F25 62 68 75 38
 367+ 0F29 39 69 6A 6E                  defb '9','i','j','n','m','k','o','0'
 367+ 0F2D 6D 6B 6F 30
 368+ 0F31 1F 70 6C 2C                  defb 31,'p','l',',','.',':','-',30      ; 31=CURSOR DOWN  30=CURSOR UP
 368+ 0F35 2E 3A 2D 1E
 369+ 0F39 1C 2A 3B 2F                  defb 28,'*',';','/',27,'=','+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 369+ 0F3D 1B 3D 2B 1D
 370+ 0F41 08 0D FC 40                  defb 8,13,252,'@',1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 370+ 0F45 01 02 04 18
 371+ 0F49
 372+ 0F49              ; shifted codes - not all the keys have the shifted version
 373+ 0F49 21 0C 0E 03  KBMAP_SFT:      defb '!',12,14,3,' ',16,'Q',34          ; 12=CLEAR  14=CTRL  3=RUN/STOP 16=C=   34="
 373+ 0F4D 20 10 51 22
 374+ 0F51 23 57 41 14                  defb '#','W','A',20,'Z','S','E','$'     ; 20=SHIFT
 374+ 0F55 5A 53 45 24
 375+ 0F59 25 52 44 58                  defb '%','R','D','X','C','F','T','&'
 375+ 0F5D 43 46 54 26
 376+ 0F61 27 59 47 56                  defb 39,'Y','G','V','B','H','U','('     ; 39='
 376+ 0F65 42 48 55 28
 377+ 0F69 29 49 4A 4E                  defb ')','I','J','N','M','K','O',94     ; 94=^
 377+ 0F6D 4D 4B 4F 5E
 378+ 0F71 1F 50 4C 3C                  defb 31,'P','L','<','>','[','_',30      ; 31=CURSOR DOWN  30=CURSOR UP
 378+ 0F75 3E 5B 5F 1E
 379+ 0F79 1C 2A 5D 3F                  defb 28,'*',']','?',27,198,'+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 379+ 0F7D 1B C6 2B 1D
 380+ 0F81 1A 0D D3 40                  defb 26,13,211,'@',5,6,22,23            ; 26=INSERT, 211=â¬  5=F4  6=F5  22=F6  23=F7
 380+ 0F85 05 06 16 17
 381+ 0F89
 382+ 0F89              ; ALT (C=) codes - not all the keys have the alt-ed version
 383+ 0F89 31 0C 0E 03  KBMAP_ALT:      defb '1',12,14,3,' ',16,222,196         ; 12=CLEAR  14=CTRL  3=RUN/STOP  16=C=  34="
 383+ 0F8D 20 10 DE C4
 384+ 0F91 33 DD 85 14                  defb '3',221,133,20,131,130,165,'4'     ; 20=SHIFT
 384+ 0F95 83 82 A5 34
 385+ 0F99 35 A2 A6 84                  defb '5',162,166,132,157,163,168,'6'
 385+ 0F9D 9D A3 A8 36
 386+ 0FA1 37 AB A9 A1                  defb '7',171,169,161,158,172,213,'8'    ;
 386+ 0FA5 9E AC D5 38
 387+ 0FA9 39 D6 D8 9F                  defb '9',214,216,159,160,215,135,195    ;
 387+ 0FAD A0 D7 87 C3
 388+ 0FB1 1F 88 8A C1                  defb 31,136,138,193,192,123,144,30      ; 31=CURSOR DOWN  123={  30=CURSOR UP
 388+ 0FB5 C0 7B 90 1E
 389+ 0FB9 1C 8F 7D FE                  defb 28,143,125,254,27,209,148,29       ; 28=CURSOR LEFT  125=}  27=ESCAPE  29=CURSOR RIGHT
 389+ 0FBD 1B D1 94 1D
 390+ 0FC1 08 0D E0 89                  defb 8,13,224,137,5,6,22,23             ; 8=DEL(backspace)  13=RETURN  252=Â£  5=F4  6=F5  22=F6  23=F7
 390+ 0FC5 05 06 16 17
 391+ 0FC9
 392+ 0FC9              ; CTRL codes - not all the keys have the control-ed version
 393+ 0FC9 31 19 0E 03  KBMAP_CTRL:     defb '1',25,14,3,' ',16,154,'2'         ; 25=HOME  14=CTRL  3=RUN/STOP  16=C=
 393+ 0FCD 20 10 9A 32
 394+ 0FD1 33 9C 95 14                  defb '3',156,149,20,152,150,153,'4'     ; 20=SHIFT
 394+ 0FD5 98 96 99 34
 395+ 0FD9 35 9B B0 97                  defb '5',155,176,151,177,175,165,'6'
 395+ 0FDD B1 AF A5 36
 396+ 0FE1 37 A6 A8 B2                  defb '7',166,168,178,179,169,167,'8'
 396+ 0FE5 B3 A9 A7 38
 397+ 0FE9 39 B8 AA AC                  defb '9',184,170,172,171,181,164,'0'
 397+ 0FED AB B5 A4 30
 398+ 0FF1 1F A3 AD 2C                  defb 31,163,173,',','.',':',186,30      ; 31=CURSOR DOWN  30=CURSOR UP
 398+ 0FF5 2E 3A BA 1E
 399+ 0FF9 1C E1 3B 2F                  defb 28,225,';','/',27,212,185,29       ; 28=CURSOR LEFT  27=ESCAPE  212=Ï  29=CURSOR RIGHT
 399+ 0FFD 1B D4 B9 1D
 400+ 1001 08 0D BD A2                  defb 8,13,189,162,1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 400+ 1005 01 02 04 18
# file closed: ../include/psg/psg-1.1.asm
  80  1009
  81  1009              ; include the latest versions of the CF & DOS modules
  82  1009                  INCLUDE "../include/dos/bios-1.02.asm"
# file opened: ../include/dos/bios-1.02.asm
   1+ 1009              ; ------------------------------------------------------------------------------
   2+ 1009              ; LM80C 64K - BIOS ROUTINES - R1.02
   3+ 1009              ; ------------------------------------------------------------------------------
   4+ 1009              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 1009              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 1009              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 1009              ; kind of warranty: you can use them at your own risk.
   8+ 1009              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 1009              ; maintain the copyright notices, include this advice and the note to the
  10+ 1009              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 1009              ; redistribuite them.
  12+ 1009              ; https://www.leonardomiliani.com
  13+ 1009              ;
  14+ 1009              ; Please support me by visiting the following links:
  15+ 1009              ; Main project page: https://www.leonardomiliani.com
  16+ 1009              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 1009              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 1009              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 1009              ; ------------------------------------------------------------------------------
  20+ 1009              ;
  21+ 1009              ; ------------------------------------------------------------------------------
  22+ 1009              ; Code Revision:
  23+ 1009              ; R1.0  - 20210307 - first release
  24+ 1009              ; R1.01 - 20210310 - Code optimizing & better error handling
  25+ 1009              ; R1.02 - 2021xxxx - disk speed improvements with INIR and OTIR
  26+ 1009              ;
  27+ 1009              ;------------------------------------------------------------------------------
  28+ 1009
  29+ 1009              ; equates for CF at port $50
  30+ 1009              CF_DATA:        equ %01010000   ; ($50) Data register (R/W)
  31+ 1009              CF_ERR:         equ %01010001   ; ($51) Error (R)
  32+ 1009              CF_FTR:         equ %01010001   ; ($51) Features (W)
  33+ 1009              CF_SECCNT:      equ %01010010   ; ($52) Sector count register (R/W)
  34+ 1009              CF_LBA0:        equ %01010011   ; ($53) LBA register 0 (bits 0-7) (R/W)
  35+ 1009              CF_LBA1:        equ %01010100   ; ($54) LBA register 1 (bits 8-15) (R/W)
  36+ 1009              CF_LBA2:        equ %01010101   ; ($55) LBA register 2 (bits 16-23) (R/W)
  37+ 1009              CF_LBA3:        equ %01010110   ; ($56) LBA register 3 (bits 24-27) (R/W) - bits 28-31 must be set to 111 in LBA mode
  38+ 1009              CF_STAT:        equ %01010111   ; ($57) Status (R)
  39+ 1009              CF_CMD:         equ %01010111   ; ($57) Command register (W)
  40+ 1009
  41+ 1009
  42+ 1009              ;------------------------------------------------------------------------------
  43+ 1009              ; R O U T I N E S
  44+ 1009              ;------------------------------------------------------------------------------
  45+ 1009
  46+ 1009              ; initilialize CF to work with, wakeing it up from standby and setting it to work in 8-bit mode
  47+ 1009 CD 1F 10     CF_INIT:    call    CF_NOP          ; execute a NOP to wake up the CF
  48+ 100C CD 6D 10                 call    CR_DEV_RDY      ; wait for CF available and ready
  49+ 100F D8                       ret     C               ; no card or I/O error, leave
  50+ 1010 3E 01                    ld      A,$01           ; 8-bit mode
  51+ 1012 D3 51                    out     (CF_FTR),A      ; set mode
  52+ 1014 CD 28 10                 call    CF_BUSY         ; wait for CF being ready
  53+ 1017 3E EF                    ld      A,$EF           ; command to set mode
  54+ 1019 D3 57                    out     (CF_CMD),A      ; execute command
  55+ 101B CD 28 10                 call    CF_BUSY         ; wait for CF being ready
  56+ 101E C9                       ret                     ; return to caller
  57+ 101F
  58+ 101F
  59+ 101F              ; a NOP command, just used to wake up the CF card
  60+ 101F 3E 69        CF_NOP:     ld      A,$69           ; NOP command
  61+ 1021 D3 51                    out     (CF_FTR),A      ; send it
  62+ 1023 3E EF                    ld      A,$EF           ; set mode command
  63+ 1025 D3 57                    out     (CF_CMD),A      ; execute NOP
  64+ 1027 C9                       ret                     ; return to caller
  65+ 1028
  66+ 1028
  67+ 1028              ; wait until BUSY bit is 0 (means CF has executed the requested job)
  68+ 1028 DB 57        CF_BUSY:    in      A,(CF_STAT)     ; read status register
  69+ 102A 07                       rlca                    ; copy bit #7 into the Carry
  70+ 102B DA 28 10                 jp      C,CF_BUSY       ; loop while bit #7 is 1
  71+ 102E C9                       ret                     ; bit #7 cleared - return to caller
  72+ 102F
  73+ 102F
  74+ 102F              ; check that CF is ready to get commands
  75+ 102F DB 57        CF_CMDRDY:  in      A,(CF_STAT)     ; read status register
  76+ 1031 CB 47                    bit     0,A             ; any error?
  77+ 1033 20 07                    jr      NZ,RETERR       ; yes, return error
  78+ 1035 E6 C0                    and     %11000000       ; check only bits #6 & #7
  79+ 1037 EE 40                    xor     %01000000       ; bit #7 (BUSY) must be 0 and bit #6 (DRVRDY) must be 1
  80+ 1039 20 F4                    jr      NZ,CF_CMDRDY    ; wait
  81+ 103B C9                       ret                     ; return to caller
  82+ 103C 37           RETERR:     scf                     ; set carry flag
  83+ 103D C9                       ret                     ; return
  84+ 103E
  85+ 103E
  86+ 103E              ; wait until data is ready to be read
  87+ 103E DB 57        CF_DAT_RDY: in      A,(CF_STAT)     ; read status register
  88+ 1040 CB 47                    bit     0,A             ; any error?
  89+ 1042 20 F8                    jr      NZ,RETERR       ; yes, return error
  90+ 1044 E6 88                    and     %10001000       ; check only bits #7 & #3
  91+ 1046 EE 08                    xor     %00001000       ; bit #7 (BUSY) must be 0 and bit #3 (DRQ) must be 1
  92+ 1048 20 F4                    jr      NZ,CF_DAT_RDY   ; wait until data is ready
  93+ 104A C9                       ret                     ; return to caller
  94+ 104B
  95+ 104B
  96+ 104B              ; set sector to read from/write to - sector number is into DEBC (C=LSB, D=MSB)
  97+ 104B CD 2F 10     CF_SETSTR:  call    CF_CMDRDY       ; Make sure drive is ready for command
  98+ 104E 3E 01                    ld      A,$01           ; 1 sector at a time
  99+ 1050 D3 52                    out     (CF_SECCNT),A   ; set number of sectors
 100+ 1052 CD 2F 10                 call    CF_CMDRDY       ; Make sure drive is ready for command
 101+ 1055 79                       ld      A,C             ; load LBA0 byte
 102+ 1056 D3 53                    out     (CF_LBA0),A     ; send it
 103+ 1058 CD 2F 10                 call    CF_CMDRDY       ; Make sure drive is ready for command
 104+ 105B 78                       ld      A,B             ; load LBA1 byte
 105+ 105C D3 54                    out     (CF_LBA1),A     ; send it
 106+ 105E CD 2F 10                 call    CF_CMDRDY       ; Make sure drive is ready for command
 107+ 1061 7B                       ld      A,E             ; load LBA2 byte
 108+ 1062 D3 55                    out     (CF_LBA2),A     ; send it
 109+ 1064 CD 2F 10                 call    CF_CMDRDY       ; Make sure drive is ready for command
 110+ 1067 3E E0                    ld      A,$E0           ; load LBA3 byte+master+LBA addressing
 111+ 1069 B2                       or      D               ; add LBA sector
 112+ 106A D3 56                    out     (CF_LBA3),A     ; send it
 113+ 106C C9                       ret                     ; return to caller
 114+ 106D
 115+ 106D
 116+ 106D              ; check if device is available & ready - try a bit of times, then exit with
 117+ 106D              ; error if no response, otherwise wait until device is ready
 118+ 106D              ; return Carry = 0 if device is available and ready, Carry = 1 if errors
 119+ 106D C5           CR_DEV_RDY: push    BC              ; store HL
 120+ 106E 06 00                    ld      B,$00           ; 256 tries
 121+ 1070 0E 57                    ld      C,CF_STAT       ; address of status register
 122+ 1072 ED 78        CR_DV_RD_1: in      A,(C)           ; load status register (curiously, with no CF attached, in(CF_STAT) returns %01111000)
 123+ 1074 FE 40                    cp      %01000000       ; busy=0, rdy=1
 124+ 1076 28 07                    jr      Z,CR_DV_RD_E    ; got a response, so leave
 125+ 1078 FE 50                    cp      %01010000       ; busy=0, rdy=1, dsc=1
 126+ 107A 28 03                    jr      Z,CR_DV_RD_E    ; got a response, so leave
 127+ 107C 10 F4                    djnz    CR_DV_RD_1      ; repeat until timeout (Carry=1 while HL<DE)
 128+ 107E 37           CR_DV_ERR:  scf                     ; exit with Carry = 1 (device NOT ready)
 129+ 107F C1           CR_DV_RD_E: pop     BC              ; retrieve HL
 130+ 1080 C9                       ret                     ; return to caller
 131+ 1081
 132+ 1081
 133+ 1081              ; put the CF into stand-by mode
 134+ 1081 3E E0        CF_STANDBY: ld 	    A,$E0   		; select CF as master, driver 0, LBA mode (bits #5-7=111)
 135+ 1083 D3 56                    out 	(CF_LBA3),A     ; send configuration
 136+ 1085 3E 92                    ld      A,$92           ; standby mode
 137+ 1087 D3 57                    out     (CF_CMD),A      ; send command
 138+ 1089 CD 28 10                 call    CF_BUSY         ; wait for CF being ready
 139+ 108C C9                       ret                     ; return to caller
 140+ 108D
 141+ 108D
 142+ 108D              ;***************************************************************************
 143+ 108D              ; CF_RD_SEC
 144+ 108D              ; Function: load a sector (512 bytes) into RAM buffer.
 145+ 108D              ;***************************************************************************
 146+ 108D CD 2F 10     CF_RD_SEC:  call    CF_CMDRDY       ; Make sure drive is ready for command
 147+ 1090 D8                       ret     C               ; return if error
 148+ 1091 3E 20                    ld      A,$20           ; Prepare read command
 149+ 1093 D3 57                    out     (CF_CMD),A      ; Send read command
 150+ 1095 CD 3E 10                 call    CF_DAT_RDY      ; Wait until data is ready to be read
 151+ 1098 D8                       ret     C               ; return if error
 152+ 1099 DB 57                    in      A,(CF_STAT)     ; Read status
 153+ 109B E6 01                    and     %00000001       ; mask off error bit
 154+ 109D C2 8D 10                 jp      NZ,CF_RD_SEC    ; Try again if error
 155+ 10A0              ; read CF buffer after it's been filled up by a previous command
 156+ 10A0              ; and store data into the I/O buffer
 157+ 10A0 C5           CF_RD_CMD:  push    BC              ; store BC
 158+ 10A1 E5                       push    HL              ; store HL
 159+ 10A2 CD 3E 10                 call    CF_DAT_RDY	    ; wait for data from CF to be ready
 160+ 10A5 38 0A                    jr      C,CF_RD_EXIT    ; if error, leave
 161+ 10A7 01 50 00                 ld      BC,CF_DATA      ; set 256 bytes per loop (B=$00) and CF port (C=CF_DATA)
 162+ 10AA 2A 0F 61                 ld      HL,(IOBUFF)     ; get starting address of I/O buffer
 163+ 10AD ED B2                    inir                    ; get 256 bytes
 164+ 10AF ED B2                    inir                    ; get 256 bytes
 165+ 10B1 E1           CF_RD_EXIT: pop     HL              ; retrieve HL
 166+ 10B2 C1                       pop     BC              ; retrieve BC
 167+ 10B3 C9                       ret                     ; return to caller
 168+ 10B4
 169+ 10B4
 170+ 10B4              ;***************************************************************************
 171+ 10B4              ; CF_WR_SEC
 172+ 10B4              ; Function: write a sector to Compact Flash - sector address is into BCDE - source address is into HL
 173+ 10B4              ;***************************************************************************
 174+ 10B4 C5           CF_WR_SEC:  push    BC              ; store BC
 175+ 10B5 E5                       push    HL              ; store HL
 176+ 10B6 CD 4B 10                 call    CF_SETSTR       ; set sector
 177+ 10B9 CD 2F 10                 call    CF_CMDRDY       ; Make sure drive is ready for command
 178+ 10BC 38 17                    jr      C,CF_WR_EXIT    ; return if error
 179+ 10BE 3E 30                    ld      A,$30           ; set write command
 180+ 10C0 D3 57                    out     (CF_CMD),A      ; send command
 181+ 10C2 CD 3E 10                 call    CF_DAT_RDY      ; Make sure drive is ready to get data
 182+ 10C5 38 0E                    jr      C,CF_WR_EXIT    ; return if error
 183+ 10C7 2A 0F 61                 ld 	    HL,(IOBUFF)     ; get starting address of I/O buffer
 184+ 10CA 01 50 00                 ld      BC,CF_DATA      ; set 256 bytes per loop (B=$00) and CF port (C=CF_DATA)
 185+ 10CD ED B3                    otir                    ; output 256 bytes
 186+ 10CF ED B3                    otir                    ; output 256 bytes
 187+ 10D1 CD 28 10                 call    CF_BUSY         ; wait for CF to complete the writing
 188+ 10D4 AF                       xor     A               ; clear Carry
 189+ 10D5 E1           CF_WR_EXIT: pop     HL              ; retrieve HL
 190+ 10D6 C1                       pop     BC              ; retrieve BC
 191+ 10D7 C9                       ret                     ; return to caller
 192+ 10D8
# file closed: ../include/dos/bios-1.02.asm
  83  10D8                  INCLUDE "../include/dos/dos-1.03.asm"
# file opened: ../include/dos/dos-1.03.asm
   1+ 10D8              ; ------------------------------------------------------------------------------
   2+ 10D8              ; LM80C 64K - DOS ROUTINES - R1.03
   3+ 10D8              ; ------------------------------------------------------------------------------
   4+ 10D8              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 10D8              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 10D8              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 10D8              ; kind of warranty: you can use them at your own risk.
   8+ 10D8              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 10D8              ; maintain the copyright notices, include this advice and the note to the
  10+ 10D8              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 10D8              ; redistribuite them.
  12+ 10D8              ; https://www.leonardomiliani.com
  13+ 10D8              ;
  14+ 10D8              ; Please support me by visiting the following links:
  15+ 10D8              ; Main project page: https://www.leonardomiliani.com
  16+ 10D8              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 10D8              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 10D8              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 10D8              ; ------------------------------------------------------------------------------
  20+ 10D8              ;
  21+ 10D8              ; ------------------------------------------------------------------------------
  22+ 10D8              ; Code Revision:
  23+ 10D8              ; R1.0  - 20210306 - first release
  24+ 10D8              ; R1.01 - 20210309 - code cleaning & optimization - new behaviour for ERASE (full erase everything)
  25+ 10D8              ; R1.02 - 20210310 - code optimization - new UNDELETE feature for DISK statement
  26+ 10D8              ; R1.03 - 2021xxxx - code size enhancements
  27+ 10D8              ;
  28+ 10D8              ;------------------------------------------------------------------------------
  29+ 10D8
  30+ 10D8
  31+ 10D8 4C 4D 38 30  DFSCT0      defb    "LM80C DOS",$00,"1.03",$00     ; disk header
  31+ 10DC 43 20 44 4F
  31+ 10E0 53 00 31 2E
  31+ 10E4 30 33 00
  32+ 10E7 00 01        DSKDIRADR:  defb    $00,$01                         ; 1st sector of directory ($0001)
  33+ 10E9
  34+ 10E9              DIR_STRT:   equ     TMPDBF          ; (2) start of directory
  35+ 10E9              DAT_STRT:   equ     DIR_STRT+$02    ; (2) start of DATA area
  36+ 10E9              DIR_SCT:    equ     DAT_STRT+$02    ; (2) sector of first free entry in the directory
  37+ 10E9              NTR_NBR:    equ     DIR_SCT+$02     ; (2) number of free entry
  38+ 10E9              BYT_SIZ:    equ     NTR_NBR+$02     ; (2) file size in bytes
  39+ 10E9              SCT_SIZ:    equ     BYT_SIZ+$02     ; (1) file size in sectors
  40+ 10E9              MSW_SCT:    equ     SCT_SIZ+$01     ; (2) MSW sector of file
  41+ 10E9              LSW_SCT:    equ     MSW_SCT+$02     ; (2) LSW sector of file
  42+ 10E9              RAM_PTR:    equ     LSW_SCT+$02     ; (2) pointer to RAM
  43+ 10E9              TPBF1:      equ     RAM_PTR+$02     ; (2) temp. word
  44+ 10E9              TPBF2:      equ     TPBF1+$02       ; (2) temp. word
  45+ 10E9              TPBF3:      equ     TPBF2+$02       ; (2) temp. word
  46+ 10E9              TPBF4:      equ     TPBF3+$02       ; (2) temp. word
  47+ 10E9              SRTMEM:     equ     TPBF4+$02       ; (2) temp. word
  48+ 10E9              ENDMEM:     equ     SRTMEM+$02      ; (2) temp. word
  49+ 10E9
  50+ 10E9
  51+ 10E9              ; *****************************************************************************
  52+ 10E9              ; D I S K    I N I T
  53+ 10E9              ; Functions: format a disk creating a fresh new file system on disk or
  54+ 10E9              ;            rewrite only the Master Sector
  55+ 10E9              ; *****************************************************************************
  56+ 10E9 3A 29 61     DSK_INIT:   ld      A,(TPBF4)       ; load type of formatting
  57+ 10EC 32 7B 61                 ld      (TMPBFR1),A     ; save onto another location for later use
  58+ 10EF CD C5 18                 call    CLRIOBF         ; clear I/O buffer
  59+ 10F2 CD DA 18                 call    CLRDOSBF        ; clear DOS buffer
  60+ 10F5 3E E0                    ld 	    A,$E0   		; select CF as master, driver 0, LBA mode (bits #5-7=111)
  61+ 10F7 D3 56                    out 	(CF_LBA3),A     ; send configuration
  62+ 10F9 3E EC                    ld      A,$EC           ; select "drive ID" command
  63+ 10FB D3 57                    out     (CF_CMD),A      ; send command
  64+ 10FD CD 3E 10                 call	CF_DAT_RDY      ; wait until data is ready to be read
  65+ 1100 CD A0 10                 call	CF_RD_CMD       ; read data and store into I/O buffer
  66+ 1103 ED 5B 0D 61              ld      DE,(DOSBFR)     ; address of default conf. buffer
  67+ 1107 2A 0F 61                 ld 	    HL,(IOBUFF)     ; get starting address of I/O buffer
  68+ 110A 01 0E 00                 ld      BC,$000E        ; position of current disk size in sectors
  69+ 110D 09                       add     HL,BC           ; set into HL
  70+ 110E 0E 04                    ld      C,$04           ; 4 bytes to copy
  71+ 1110 ED B0                    ldir                    ; copy (DE is auto-incremented)
  72+ 1112 2A 0F 61                 ld 	    HL,(IOBUFF)     ; get starting address of I/O buffer
  73+ 1115 01 02 00                 ld      BC,$0002        ; 2 bytes to copy and also address of number of cylinders
  74+ 1118 09                       add     HL,BC           ; get position of data
  75+ 1119 ED B0                    ldir                    ; copy (DE is auto-incremented)
  76+ 111B 2A 0F 61                 ld 	    HL,(IOBUFF)     ; get starting address of I/O buffer
  77+ 111E 01 0C 00                 ld      BC,$000C        ; address of number of sectors per cylinder
  78+ 1121 09                       add     HL,BC           ; get position of data
  79+ 1122 0E 02                    ld      C,$02           ; 2 bytes to copy
  80+ 1124 ED B0                    ldir                    ; copy (DE is auto-incremented)
  81+ 1126 2A 0F 61                 ld 	    HL,(IOBUFF)     ; get starting address of I/O buffer
  82+ 1129 01 06 00                 ld      BC,$0006        ; address of number of heads
  83+ 112C 09                       add     HL,BC           ; get position of data
  84+ 112D 0E 02                    ld      C,$02           ; 2 bytes to copy
  85+ 112F ED B0                    ldir                    ; copy (DE is auto-incremented)
  86+ 1131                          ; now we calculate the # of files allowed (1 file = 1 block = 64K)
  87+ 1131 ED 53 29 61              ld      (TPBF4),DE      ; store current pointer to temp. default conf. buffer
  88+ 1135 2A 0D 61                 ld      HL,(DOSBFR)     ; load number of sectors
  89+ 1138 4E                       ld      C,(HL)          ; MSW into AC
  90+ 1139 23                       inc     HL
  91+ 113A 7E                       ld      A,(HL)
  92+ 113B 23                       inc     HL
  93+ 113C 5E                       ld      E,(HL)          ; LSW into DE
  94+ 113D 23                       inc     HL
  95+ 113E 56                       ld      D,(HL)
  96+ 113F D5                       push    DE              ; move DE into IX
  97+ 1140 DD E1                    pop     IX
  98+ 1142 11 80 00                 ld      DE,$0080        ; 128 sectors per block
  99+ 1145 CD BA 4D                 call    DIV_32_16       ; execute ACIX/DE; result is into ACIX, remainder into HL
 100+ 1148 47                       ld      B,A             ; now result is into BCIX
 101+ 1149 B1                       or      C               ; BC=$0000?
 102+ 114A 28 05                    jr      Z,DOS_FTC       ; yes, but.....
 103+ 114C 11 FF FF                 ld      DE,$FFFF        ; ... no more than $FFFF files, so set limit
 104+ 114F 18 0E                    jr      DOS_FT1         ; jump over
 105+ 1151 DD E5        DOS_FTC:    push    IX              ; move IX into DE
 106+ 1153 D1                       pop     DE              ; now result is into BCDE
 107+ 1154 7C                       ld      A,H             ; remainder = zero?
 108+ 1155 B5                       or      L
 109+ 1156 CA 5F 11                 jp      Z,DOS_FT1       ; yes, jump over
 110+ 1159 13                       inc     DE              ; no, increment DE
 111+ 115A 7A                       ld      A,D             ; check if DE is zero
 112+ 115B B3                       or      E
 113+ 115C 20 01                    jr      NZ,DOS_FT1      ; no, jump over
 114+ 115E 1B           DOS_FT0:    dec     DE              ; yes, so set files to limit of $FFFF
 115+ 115F 2A 29 61     DOS_FT1:    ld      HL,(TPBF4)      ; retrieve current pointer to temp. def. conf. buffer
 116+ 1162 CD 58 18                 call    DE2HL           ; store # of entries
 117+ 1165 D5                       push    DE              ; store entries
 118+ 1166 EB                       ex      DE,HL           ; copy current pointer into DE
 119+ 1167 21 E7 10                 ld      HL,DSKDIRADR    ; address of directory start
 120+ 116A 01 02 00                 ld      BC,$0002        ; 2 bytes to copy
 121+ 116D ED B0                    ldir                    ; copy into buffer
 122+ 116F                          ; now we calculate the starting sector of data area
 123+ 116F E1                       pop     HL              ; entries into HL
 124+ 1170 0E 10                    ld      C,$10           ; 16 entries per sector
 125+ 1172 CD 96 4D                 call    DIV_16_8        ; calculare how many sectors for dir (HL/C)
 126+ 1175 B7                       or      A               ; remainder = 0?
 127+ 1176 28 01                    jr      Z,DOS_FT2       ; yes, jump over
 128+ 1178 23                       inc     HL              ; increment sectors
 129+ 1179 E5           DOS_FT2:    push    HL              ; store size of directory
 130+ 117A FD E1                    pop     IY              ; into IY
 131+ 117C 23                       inc     HL              ; data area is 1 sector bigger than directory's size
 132+ 117D EB                       ex      DE,HL           ; restore pointer into HL, and move sectors into DE
 133+ 117E 73                       ld      (HL),E          ; store starting of
 134+ 117F 23                       inc     HL              ; data area
 135+ 1180 72                       ld      (HL),D          ; into buffer
 136+ 1181                          ; now clean again the I/O buffer and copy the configuration into I/O buffer
 137+ 1181 CD C5 18                 call    CLRIOBF         ; clear I/O buffer
 138+ 1184 21 D8 10                 ld      HL,DFSCT0       ; address of disk header string
 139+ 1187 ED 5B 0F 61              ld      DE,(IOBUFF)     ; address of I/O buffer
 140+ 118B 01 0F 00                 ld      BC,$000F        ; 15 chars
 141+ 118E ED B0                    ldir                    ; copy header into buffer
 142+ 1190 2A 0D 61                 ld      HL,(DOSBFR)     ; first part of configuration
 143+ 1193 01 10 00                 ld      BC,$0010        ; composed by 16 chars
 144+ 1196 ED B0                    ldir                    ; copy (DE is auto-incremented)
 145+ 1198 AF                       xor     A               ; A=$0
 146+ 1199 12                       ld      (DE),A          ; marker at $1F
 147+ 119A 13                       inc     DE
 148+ 119B CD 30 18                 call    CHKNMVAL        ; copy disk name into buffer
 149+ 119E DA 5D 12                 jp      C,D1ERR         ; disk name error
 150+ 11A1 CD B8 17     DOS_FT5:    call    RND_ID          ; generate a semi-random disk ID
 151+ 11A4 2A 0F 61                 ld      HL,(IOBUFF)     ; get starting address of I/O buffer
 152+ 11A7 54                       ld      D,H             ; copy into DE...
 153+ 11A8 5D                       ld      E,L             ; ...for later use
 154+ 11A9 01 FE 01                 ld      BC,$01FE        ; get address of last 2 bytes...
 155+ 11AC 09                       add     HL,BC           ; ...of the I/O buffer
 156+ 11AD 3E 38                    ld      A,'8'           ; write marker "80"
 157+ 11AF 77                       ld      (HL),A          ; ...
 158+ 11B0 23                       inc     HL              ; ...
 159+ 11B1 3E 30                    ld      A,'0'           ; ...
 160+ 11B3 77                       ld      (HL),A          ; ...into last 2 locations
 161+ 11B4 EB                       ex      DE,HL           ; copy beginning of I/O buffer from DE into HL
 162+ 11B5 AF                       xor     A               ; reset A - set sector # to $00000000
 163+ 11B6 47                       ld      B,A             ; LBA0=0
 164+ 11B7 4F                       ld      C,A             ; LBA1=0
 165+ 11B8 57                       ld      D,A             ; LBA2=0
 166+ 11B9 5F                       ld      E,A             ; LBA3=0
 167+ 11BA CD B4 10                 call    CF_WR_SEC       ; write sector to CF
 168+ 11BD DA 40 12                 jp      C,D2ERR
 169+ 11C0                          ; check if only re-writing of Master Sector was need
 170+ 11C0 3A 7B 61                 ld      A,(TMPBFR1)     ; retrieve type of formatting
 171+ 11C3 3D                       dec     A               ; A=1?
 172+ 11C4 C8                       ret     Z               ; yes, finished job
 173+ 11C5                          ; erase directory -----------------------------
 174+ 11C5                          ; create a progress bar
 175+ 11C5 3E 0D                    ld      A,CR            ; no, full format - go to new line
 176+ 11C7 CD A9 23                 call    OUTC
 177+ 11CA FD E5                    push    IY              ; copy directory's size...
 178+ 11CC E1                       pop     HL              ; ...into HL
 179+ 11CD 01 18 00                 ld      BC,$0018        ; 24 steps
 180+ 11D0 CD 96 4D                 call    DIV_16_8        ; calculate HL/24 (remainder is ignored, here)
 181+ 11D3 E5                       push    HL              ; store result...
 182+ 11D4 DD E1                    pop     IX              ; ...into IX...
 183+ 11D6 EB                       ex      DE,HL           ; ...and into DE
 184+ 11D7 3E 2D                    ld      A,'-'           ; print a progress bar
 185+ 11D9 CD 15 12                 call    DOS_FT7         ; print it
 186+ 11DC 3E 1C                    ld      A,CRSLFT        ; CURSOR left
 187+ 11DE CD 15 12                 call    DOS_FT7         ; come back to beginning of line
 188+ 11E1 FD E5                    push    IY              ; copy directory's size
 189+ 11E3 E1                       pop     HL              ; into HL
 190+ 11E4 01 01 00                 ld      BC,$0001        ; first sector of directory
 191+ 11E7 CD C5 18                 call    CLRIOBF         ; clear I/O buffer
 192+ 11EA D5           DOS_FTA:    push    DE              ; store counter
 193+ 11EB 11 00 00                 ld      DE,$0000        ; reset MSW of sector pointer
 194+ 11EE CD B4 10                 call    CF_WR_SEC       ; write sector to CF
 195+ 11F1 DA 11 12                 jp      C,DOS_FT10      ; error occured
 196+ 11F4 03                       inc     BC              ; next sector
 197+ 11F5 2B                       dec     HL              ; decrement HL
 198+ 11F6 D1                       pop     DE              ; retrieve counter
 199+ 11F7 1B                       dec     DE              ; decrement counter
 200+ 11F8 7B                       ld      A,E
 201+ 11F9 B2                       or      D               ; check if counter is zero
 202+ 11FA 20 08                    jr      NZ,DOS_FT9      ; no, jump over
 203+ 11FC 3E 2A                    ld      A,'*'           ; yes, print char
 204+ 11FE CD A9 23                 call    OUTC
 205+ 1201 DD E5                    push    IX              ; re-set counter
 206+ 1203 D1                       pop     DE
 207+ 1204 7C           DOS_FT9:    ld      A,H             ; check if...
 208+ 1205 B5                       or      L               ; ...HL = 0
 209+ 1206 20 E2                    jr      NZ,DOS_FTA      ; if not, repeat
 210+ 1208 3E 0D                    ld      A,CR            ; return
 211+ 120A CD A9 23                 call    OUTC            ; next line
 212+ 120D CD 81 10                 call    CF_STANDBY      ; set CF into stand-by mode
 213+ 1210 C9                       ret
 214+ 1211 D1           DOS_FT10:   pop     DE
 215+ 1212 C3 40 12                 jp      D2ERR           ; disk geometry error
 216+ 1215
 217+ 1215              ; print a char 24 times
 218+ 1215 06 18        DOS_FT7:    ld      B,$18           ; 24 times
 219+ 1217 CD A9 23     DOS_FT8:    call    OUTC            ; print char
 220+ 121A 10 FB                    djnz    DOS_FT8         ; repeat
 221+ 121C C9                       ret                     ; return to caller
 222+ 121D
 223+ 121D
 224+ 121D              ; *****************************************************************************
 225+ 121D              ; D I S K    R E N A M E
 226+ 121D              ;******************************************************************************
 227+ 121D CD C5 18     DSK_RNM:    call    CLRIOBF         ; clear I/O buffer
 228+ 1220 CD DA 18                 call    CLRDOSBF        ; clear DOS buff.
 229+ 1223 CD AC 17                 call    LDMSCT          ; load Master Sector
 230+ 1226 2A 0F 61                 ld      HL,(IOBUFF)     ; point to start of I/O buffer
 231+ 1229 01 20 00                 ld      BC,$0020        ; offset for disk name
 232+ 122C 09                       add     HL,BC           ; get pointer
 233+ 122D EB                       ex      DE,HL           ; copy pointer into DE
 234+ 122E CD 30 18                 call    CHKNMVAL        ; copy disk name into buffer
 235+ 1231 DA 5D 12                 jp      C,D1ERR         ; disk name error
 236+ 1234 11 00 00                 ld      DE,$0000        ; reset MSW sector
 237+ 1237 42                       ld      B,D             ; reset LSW sector
 238+ 1238 4A                       ld      C,D
 239+ 1239 CD B4 10                 call    CF_WR_SEC       ; write sector
 240+ 123C DA A4 16                 jp      C,WRT_ERR       ; error?
 241+ 123F C9                       ret                     ; no, return to caller
 242+ 1240
 243+ 1240
 244+ 1240              ; *****************************************************************************
 245+ 1240              ; DOS ERRORS
 246+ 1240              ; *****************************************************************************
 247+ 1240 3E 3C        D2ERR:      ld      A,D2            ; disk geometry error
 248+ 1242 18 1B                    jr      RET_ERR
 249+ 1244 3E 42        DSKFULL:    ld      A,D5            ; disk full error
 250+ 1246 18 17                    jr      RET_ERR
 251+ 1248 3E 44        DUPLERR:    ld      A,D6            ; duplicate file name
 252+ 124A 18 13                    jr      RET_ERR
 253+ 124C 3E 3A        NAMERR:     ld      A,D1            ; file name error
 254+ 124E 18 0F                    jr      RET_ERR
 255+ 1250 3E 48        FLNTFND:    ld      A,D8            ; file not found
 256+ 1252 18 0B                    jr      RET_ERR
 257+ 1254 3E 40        LODERR:     ld      A,D4            ; generic load error
 258+ 1256 18 07                    jr      RET_ERR
 259+ 1258 3E 46        DOSVERSERR: ld      A,D7            ; DOS version error
 260+ 125A C3 5F 12                 jp      RET_ERR
 261+ 125D 3E 3A        D1ERR:      ld      A,D1            ; name string error
 262+ 125F 32 11 61     RET_ERR:    ld      (DOSER),A       ; store DOS error
 263+ 1262 CD 81 10                 call    CF_STANDBY      ; set CF into stand-by
 264+ 1265 37                       scf                     ; set Carry for error
 265+ 1266 C9                       ret                     ; return to caller
 266+ 1267
 267+ 1267              ; *****************************************************************************
 268+ 1267              ; L I S T    F I L E S
 269+ 1267              ; Function: print details of disk and list files
 270+ 1267              ; Input: D: $00=only disk details; $01=file list, too
 271+ 1267              ; *****************************************************************************
 272+ 1267 44 69 73 6B  DSKNMTX:    defb    "Disk name: ",0
 272+ 126B 20 6E 61 6D
 272+ 126F 65 3A 20 00
 273+ 1273 0D 53 65 63  TLSCTTX:    defb    CR,"Sectors: ",0
 273+ 1277 74 6F 72 73
 273+ 127B 3A 20 00
 274+ 127E 0D 41 6C 6C  ALFLSTXT:   defb    CR,"Allowed files: ",0
 274+ 1282 6F 77 65 64
 274+ 1286 20 66 69 6C
 274+ 128A 65 73 3A 20
 274+ 128E 00
 275+ 128F 20 66 69 6C  TLFLSTX:    defb    " file(s)",CR,0
 275+ 1293 65 28 73 29
 275+ 1297 0D 00
 276+ 1299 CD F8 17     LST_FILES:  call    CHKDSKVAL       ; check DOS version & load disk details
 277+ 129C DA 58 12                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
 278+ 129F D5                       push    DE              ; store D
 279+ 12A0 CD AC 17                 call    LDMSCT          ; load Master Sector
 280+ 12A3 21 67 12                 ld      HL,DSKNMTX      ; pointer to "Disk name" message
 281+ 12A6 CD 80 2F                 call    PRS             ; print it
 282+ 12A9 2A 0F 61                 ld 	    HL,(IOBUFF)     ; get starting address of I/O buffer
 283+ 12AC 11 20 00                 ld      DE,$0020        ; position of disk name
 284+ 12AF 19                       add     HL,DE           ; get address
 285+ 12B0 06 10                    ld      B,$10           ; 16 chars
 286+ 12B2 7E           INPR1:      ld      A,(HL)          ; load char
 287+ 12B3 CD A9 23                 call    OUTC            ; print it
 288+ 12B6 23                       inc     HL
 289+ 12B7 10 F9                    djnz    INPR1           ; repeat
 290+ 12B9 3E 0D                    ld      A,CR
 291+ 12BB CD A9 23                 call    OUTC            ; carriage return
 292+ 12BE DD 21 00 00              ld      IX,$0000        ; reset file counter (for use in formatting)
 293+ 12C2 D1                       pop     DE              ; retrieve D
 294+ 12C3 7A                       ld      A,D
 295+ 12C4 B7                       or      A               ; is D=0?
 296+ 12C5 CA 71 13                 jp      Z,PNTSTATS      ; yes, jump over
 297+ 12C8                          ; print list of files
 298+ 12C8 2A 0F 61                 ld      HL,(IOBUFF)     ; start of I/O buffer
 299+ 12CB 11 0F 00                 ld      DE,$000F        ; point to details of disk
 300+ 12CE 19                       add     HL,DE           ; find address
 301+ 12CF ED 5B 0D 61              ld      DE,(DOSBFR)     ; store into DOS buffer
 302+ 12D3 01 20 00                 ld      BC,$0020        ; 32 bytes
 303+ 12D6 ED B0                    ldir                    ; copy
 304+ 12D8 CD 9D 17                 call    LDENTRIES       ; load entries
 305+ 12DB FD 2A 18 61              ld      IY,(NTR_NBR)    ; load max entries
 306+ 12DF D9                       exx
 307+ 12E0 01 00 00                 ld      BC,$0000        ; reset file counter
 308+ 12E3 D9                       exx
 309+ 12E4 CD 64 17                 call    SETPTEN         ; point to 1st sector of dir
 310+ 12E7 CD 6C 17     LSTFILES1:  call    PT2FSEN         ; point to 1st entry of a dir's sect
 311+ 12EA CD 77 17     LSTFILES2:  call    CKCREN          ; check current entry
 312+ 12ED 28 5C                    jr      Z,LSTFILES6     ; if empty or deleted, ignore it
 313+ 12EF C5                       push    BC              ; this is a valid entry - so, store BC (LSW of sect)
 314+ 12F0 FD E5                    push    IY              ; store IY (entries counter)
 315+ 12F2 E5                       push    HL              ; store HL (sect entry counter)
 316+ 12F3 D5                       push    DE              ; store DE (MSW of sector)
 317+ 12F4 DD E5                    push    IX              ; store IX (pointer to first byte of entry)
 318+ 12F6 06 10                    ld      B,$10           ; 16 chars to read and print
 319+ 12F8 DD 7E 00     LSTFILES3:  ld      A,(IX)          ; load char from name
 320+ 12FB CD A9 23                 call    OUTC            ; print char
 321+ 12FE DD 23                    inc     IX              ; next char
 322+ 1300 10 F6                    djnz    LSTFILES3       ; repeat
 323+ 1302 3E 20                    ld      A,SPC
 324+ 1304 CD A9 23                 call    OUTC            ; print space
 325+ 1307 DD 7E 00                 ld      A,(IX)          ; file type
 326+ 130A D6 80                    sub     $80             ; types start from $80
 327+ 130C B7                       or      A               ; BAS type ($00)?
 328+ 130D 20 05                    jr      NZ,LSTFILES20   ; no, jump over
 329+ 130F 21 B5 13                 ld      HL,FILETP       ; print "BAS"
 330+ 1312 18 0B                    jr      LSTFILESPR
 331+ 1314 3D           LSTFILES20: dec     A               ; BIN type ($01)?
 332+ 1315 20 05                    jr      NZ,LSTFILES21   ; no, jump over
 333+ 1317 21 BA 13                 ld      HL,FILETP+5     ; print "BIN"
 334+ 131A 18 03                    jr      LSTFILESPR
 335+ 131C 21 BF 13     LSTFILES21: ld      HL,FILETP+10    ; print "???"
 336+ 131F CD 80 2F     LSTFILESPR: call    PRS
 337+ 1322 01 08 00                 ld      BC,$0008
 338+ 1325 DD 09                    add     IX,BC           ; point to file size in bytes
 339+ 1327 DD 4E 00                 ld      C,(IX)          ; load size in BC, first LSW
 340+ 132A DD 23                    inc     IX
 341+ 132C DD 46 00                 ld      B,(IX)          ; then MSW
 342+ 132F C5                       push    BC              ; copy...
 343+ 1330 DD E1                    pop     IX              ; ...into IX
 344+ 1332 11 00 00                 ld      DE,$0000        ; reset DE
 345+ 1335 FD E5                    push    IY
 346+ 1337 CD 6B 18                 call    PRN16ASCIX      ; print size in bytes (DEIX)
 347+ 133A FD E1                    pop     IY
 348+ 133C 3E 0D                    ld      A,CR
 349+ 133E CD A9 23                 call    OUTC            ; print carriage return
 350+ 1341 D9                       exx                     ; set shadow registers
 351+ 1342 03                       inc     BC              ; increment file counter
 352+ 1343 D9                       exx                     ; restore main registers
 353+ 1344 DD E1                    pop     IX              ; retrieve IX
 354+ 1346 D1                       pop     DE              ; retrieve DE
 355+ 1347 E1                       pop     HL              ; retrieve HL
 356+ 1348 FD E1                    pop     IY              ; retrieve IY
 357+ 134A C1                       pop     BC              ; retrieve BC
 358+ 134B CD 12 26     LSTFILES6:  call    TSTBRK          ; Test for break key
 359+ 134E CD 15 25                 call    TSTSPC          ; test for space
 360+ 1351 CD 7F 17                 call    GTNXTEN         ; other entries in this sector?
 361+ 1354 20 94                    jr      NZ,LSTFILES2    ; yes, continue check
 362+ 1356 CD 8B 17     LSTFILES5:  call    CKLSTEN         ; go to next sector
 363+ 1359 D2 E7 12                 jp      NC,LSTFILES1    ; more entries? repeat
 364+ 135C D9                       exx                     ; set shadow registers
 365+ 135D C5                       push    BC              ; store file counter
 366+ 135E D9                       exx                     ; restore main registers
 367+ 135F DD E1                    pop     IX              ; retrieve file counter
 368+ 1361 DD E5                    push    IX              ; store it again
 369+ 1363 11 00 00                 ld      DE,$0000        ; reset DE
 370+ 1366 CD 6B 18                 call    PRN16ASCIX      ; print number of files from DEIX
 371+ 1369 21 8F 12                 ld      HL,TLFLSTX
 372+ 136C CD 80 2F                 call    PRS             ; print "file(s)"
 373+ 136F DD E1                    pop     IX
 374+ 1371 21 73 12     PNTSTATS:   ld      HL,TLSCTTX      ; Point to message "Tot. sectors"
 375+ 1374 CD 80 2F                 call    PRS             ; print message
 376+ 1377 2A 0D 61                 ld      HL,(DOSBFR)     ; reload address of I/O buffer and point to disk size
 377+ 137A DD E5                    push    IX
 378+ 137C CD 62 18                 call    PRN32ASCII      ; print size
 379+ 137F 3E 2F                    ld      A,'/'
 380+ 1381 CD A9 23                 call    OUTC            ; print a "/""
 381+ 1384 D1                       pop     DE              ; copy number of entries into DE
 382+ 1385 01 80 00                 ld      BC,$0080        ; 128 sectors per entry block
 383+ 1388 CD 60 4D                 call    MUL_U32         ; multiply BC times DE: returns DEHL
 384+ 138B ED 53 23 61              ld      (TPBF1),DE      ; store results
 385+ 138F 22 25 61                 ld      (TPBF2),HL
 386+ 1392 21 23 61                 ld      HL,TPBF1        ; print results
 387+ 1395 CD 62 18                 call    PRN32ASCII
 388+ 1398 21 7E 12                 ld      HL,ALFLSTXT     ; Point to message "Allowed files"
 389+ 139B CD 80 2F                 call    PRS             ; print message
 390+ 139E 2A 0D 61                 ld      HL,(DOSBFR)     ; reload address of I/O buffer
 391+ 13A1 01 0A 00                 ld      BC,$000A        ; address of allowed files
 392+ 13A4 09                       add     HL,BC           ; find pointer
 393+ 13A5 11 00 00                 ld      DE,$0000        ; MSW set to $0000
 394+ 13A8 CD 65 18                 call    PRN16ASCII      ; print max files
 395+ 13AB 3E 0D                    ld      A,CR
 396+ 13AD CD A9 23                 call    OUTC            ; print a carriage return
 397+ 13B0 CD 81 10     EXITFLS:    call    CF_STANDBY      ; put CF into standby
 398+ 13B3 AF                       xor     A               ; clear Carry flag
 399+ 13B4 C9                       ret                     ; return to caller
 400+ 13B5 42 41 53 20  FILETP:     defb    "BAS ",0        ; BASIC type
 400+ 13B9 00
 401+ 13BA 42 49 4E 20              defb    "BIN ",0        ; BINARY type
 401+ 13BE 00
 402+ 13BF 3F 3F 3F 20              defb    "??? ",0        ; unkown
 402+ 13C3 00
 403+ 13C4
 404+ 13C4
 405+ 13C4              ; *****************************************************************************
 406+ 13C4              ; S A V E    F I L E
 407+ 13C4              ; save current BASIC program onto a file
 408+ 13C4              ; *****************************************************************************
 409+ 13C4 CD 55 15     SAVFILE:    call    CHKFLEXT        ; file already exists?
 410+ 13C7 DA 48 12                 jp      C,DUPLERR       ; name is present - error
 411+ 13CA CD 3C 17                 call    FNDFRENTR       ; find a free entry in the directory
 412+ 13CD DA 44 12                 jp      C,DSKFULL       ; no entry, disk full error
 413+ 13D0 3A 29 61                 ld      A,(TPBF4)       ; check what to save
 414+ 13D3 FE 80                    cp      $80             ; BASIC program?
 415+ 13D5 C2 E4 13                 jp      NZ,SAVFL3       ; no, jump over
 416+ 13D8                          ; BASIC area to save starts at PROGND and ends at (PROGND)
 417+ 13D8 2A C1 61                 ld      HL,(PROGND)     ; load end of BASIC program <- WARNING: pay attention to (PROGND) and PROGND
 418+ 13DB 11 C1 61                 ld      DE,PROGND       ; start of RAM to be saved  <- WARNING: pay attention to (PROGND) and PROGND
 419+ 13DE ED 53 2B 61              ld      (SRTMEM),DE     ; copy DE
 420+ 13E2 18 08                    jr      SAVFL1
 421+ 13E4 2A 2D 61     SAVFL3:     ld      HL,(ENDMEM)     ; save a portion of memory: HL <= end of portion
 422+ 13E7 23                       inc     HL              ; we always need 1 more byte to store the portion of memory
 423+ 13E8 ED 5B 2B 61              ld      DE,(SRTMEM)     ; DE <= start of portion
 424+ 13EC                          ; compute how many sectors/blocks are needed to save file
 425+ 13EC AF           SAVFL1:     xor     A               ; reset Carry
 426+ 13ED ED 52                    sbc     HL,DE           ; get how many bytes to save
 427+ 13EF 22 1A 61                 ld      (BYT_SIZ),HL    ; store into memory
 428+ 13F2 11 00 02                 ld      DE,$0200        ; 512 bytes per sector
 429+ 13F5 7C                       ld      A,H             ; move lenght...
 430+ 13F6 4D                       ld      C,L             ; ...into AC
 431+ 13F7 CD A5 4D                 call    DIV_16_16       ; lenght/512 = nbr. of sectors: quotient in AC but A will be discarded
 432+ 13FA 7C                       ld      A,H             ; check if...
 433+ 13FB B5                       or      L               ; ...remainder (HL) is 0
 434+ 13FC 28 01                    jr      Z,SAVFL6        ; yes, jump over
 435+ 13FE 03                       inc     BC              ; no, so we need another sector
 436+ 13FF 79           SAVFL6:     ld      A,C
 437+ 1400 32 1C 61                 ld      (SCT_SIZ),A     ; store into memory
 438+ 1403              SAVFL7:     ; start saving on disk
 439+ 1403 11 00 00                 ld      DE,$0000        ; directory is always from sector 0000-0001
 440+ 1406 ED 4B 16 61              ld      BC,(DIR_SCT)    ; load sector of dir where to save file entry
 441+ 140A CD 4B 10                 call    CF_SETSTR       ; set sector to read
 442+ 140D CD 8D 10                 call    CF_RD_SEC       ; read sector
 443+ 1410 3A 18 61                 ld      A,(NTR_NBR)     ; load entry number (ignoring MSB)
 444+ 1413 E6 0F                    and     %00001111       ; be sure to get only low nibble
 445+ 1415 87                       add     A,A             ; multiply...
 446+ 1416 87                       add     A,A             ; ...times 16 by...
 447+ 1417 87                       add     A,A             ; ...adding...
 448+ 1418 87                       add     A,A             ; ...4 times
 449+ 1419 CB 27                    sla     A               ; left shift to multiply times 32 - Carry is set if results is > 255
 450+ 141B 5F                       ld      E,A             ; copy into C
 451+ 141C CB 12                    rl      D               ; if Carry, then increment D (D was 0, see above)
 452+ 141E                          ; set name
 453+ 141E 2A 0F 61                 ld 	    HL,(IOBUFF)     ; get starting address of I/O buffer
 454+ 1421 19                       add     HL,DE           ; add offset to get address of entry
 455+ 1422 ED 5B 0D 61              ld      DE,(DOSBFR)     ; pointer to file name
 456+ 1426 01 10 00                 ld      BC,$0010        ; 16 chars
 457+ 1429 EB                       ex      DE,HL           ; move source into HL and destination into DE
 458+ 142A ED B0                    ldir                    ; copy file name
 459+ 142C EB                       ex      DE,HL           ; move current buffer pointer into HL
 460+ 142D 3A 29 61                 ld      A,(TPBF4)       ; load the type of file
 461+ 1430 77                       ld      (HL),A          ; store it
 462+ 1431 23                       inc     HL
 463+ 1432 AF                       xor     A               ; file attributes - AT THE MOMENT, NO ATTRIBUTES
 464+ 1433 77                       ld      (HL),A
 465+ 1434 23                       inc     HL
 466+ 1435 ED 5B 18 61              ld      DE,(NTR_NBR)    ; reload entry number
 467+ 1439 CD 58 18                 call    DE2HL           ; store entry into buffer
 468+ 143C E5                       push    HL              ; store pointer
 469+ 143D 01 80 00                 ld      BC,$0080        ; 128 sectors per entry block
 470+ 1440 CD 60 4D                 call    MUL_U32         ; multiply BC times DE: returns DEHL
 471+ 1443 ED 4B 14 61              ld      BC,(DAT_STRT)   ; load start of data
 472+ 1447 09                       add     HL,BC           ; add sector of data area
 473+ 1448 30 01                    jr      NC,SAVFL9       ; overflow?
 474+ 144A 13                       inc     DE              ; yes, increment DE
 475+ 144B ED 53 1D 61  SAVFL9:     ld      (MSW_SCT),DE    ; store MSW of sector
 476+ 144F 22 1F 61                 ld      (LSW_SCT),HL    ; store LSW of sector
 477+ 1452 E1                       pop     HL              ; retrieve pointer
 478+ 1453 CD 58 18                 call    DE2HL           ; also copy MSW of sector into entry
 479+ 1456 ED 5B 1F 61              ld      DE,(LSW_SCT)    ; retrieve LSW
 480+ 145A CD 58 18                 call    DE2HL           ; also copy LSW of sector into entry
 481+ 145D ED 5B 1A 61              ld      DE,(BYT_SIZ)    ; retrieve file size in bytes
 482+ 1461 CD 58 18                 call    DE2HL           ; copy file size into buffer
 483+ 1464 3A 1C 61                 ld      A,(SCT_SIZ)     ; retrieve file size in sectors
 484+ 1467 77                       ld      (HL),A          ; copy into buffer
 485+ 1468 23                       inc     HL              ; next location
 486+ 1469 ED 5B 2B 61              ld      DE,(SRTMEM)     ; start of address of file in RAM
 487+ 146D CD 58 18                 call    DE2HL           ; copy into buffer
 488+ 1470 06 03                    ld      B,$03           ; remaining chars...
 489+ 1472 AF                       xor     A               ; ...set to $00
 490+ 1473 77           SAVFL2:     ld      (HL),A          ; reset byte
 491+ 1474 23                       inc     HL              ; next cell
 492+ 1475 10 FC                    djnz    SAVFL2          ; repeat
 493+ 1477                          ; save entry into directory
 494+ 1477 11 00 00                 ld      DE,$0000        ; block 0
 495+ 147A ED 4B 16 61              ld      BC,(DIR_SCT)    ; load sector of dir where to save file entry
 496+ 147E CD B4 10                 call    CF_WR_SEC       ; write new entry into directory
 497+ 1481 DA 40 12                 jp      C,D2ERR         ; error occured
 498+ 1484 CD C5 18                 call    CLRIOBF         ; clear I/O buffer
 499+ 1487                          ; start saving RAM
 500+ 1487 ED 5B 2B 61              ld      DE,(SRTMEM)     ; load start of RAM
 501+ 148B ED 53 21 61              ld      (RAM_PTR),DE    ; store
 502+ 148F CD C5 18     SAVFL10:    call    CLRIOBF         ; clear I/O buffer
 503+ 1492 2A 1A 61                 ld      HL,(BYT_SIZ)    ; load bytes left to be copied
 504+ 1495 11 00 02                 ld      DE,$0200        ; are they < 512?
 505+ 1498 CD 3B 4D                 call    CMP16
 506+ 149B 30 04                    jr      NC,SAVFL4       ; no, jump over
 507+ 149D ED 5B 1A 61              ld      DE,(BYT_SIZ)    ; yes, so load remaining bytes
 508+ 14A1 4B           SAVFL4:     ld      C,E             ; bytes to copy
 509+ 14A2 42                       ld      B,D             ; into BC
 510+ 14A3 2A 21 61                 ld      HL,(RAM_PTR)    ; load pointer to RAM to be saved
 511+ 14A6 ED 5B 0F 61              ld      DE,(IOBUFF)     ; load start of I/O buffer
 512+ 14AA ED B0                    ldir                    ; copy data
 513+ 14AC ED 5B 1D 61              ld      DE,(MSW_SCT)    ; load MSW of sector
 514+ 14B0 ED 4B 1F 61              ld      BC,(LSW_SCT)    ; load LSW of sector
 515+ 14B4 CD B4 10                 call    CF_WR_SEC       ; write sector
 516+ 14B7 DA A4 16                 jp      C,WRT_ERR       ; error?
 517+ 14BA 21 1C 61                 ld      HL,SCT_SIZ      ; sector counter
 518+ 14BD 35                       dec     (HL)            ; copied all the sectors?
 519+ 14BE CA ED 14                 jp      Z,SAVFLEXT      ; yes, exit
 520+ 14C1 2A 21 61     SAVFL11:    ld      HL,(RAM_PTR)    ; pointer to RAM
 521+ 14C4 11 00 02                 ld      DE,$0200        ; block of 512 bytes copied
 522+ 14C7 19                       add     HL,DE           ; calculate next starting address
 523+ 14C8 22 21 61                 ld      (RAM_PTR),HL    ; store next block
 524+ 14CB AF                       xor     A               ; reset Carry
 525+ 14CC 2A 1A 61                 ld      HL,(BYT_SIZ)    ; load left bytes
 526+ 14CF ED 52                    sbc     HL,DE           ; subtract copied bytes
 527+ 14D1 22 1A 61                 ld      (BYT_SIZ),HL    ; store left bytes
 528+ 14D4 ED 4B 1F 61              ld      BC,(LSW_SCT)    ; load LSW of sector
 529+ 14D8 03                       inc     BC              ; next sector
 530+ 14D9 78                       ld      A,B             ; BC=$0000?
 531+ 14DA B1                       or      C
 532+ 14DB 20 09                    jr      NZ,SAVFL12      ; no, jump over
 533+ 14DD ED 5B 1D 61              ld      DE,(MSW_SCT)    ; load MSW of sector
 534+ 14E1 13                       inc     DE              ; increment DE
 535+ 14E2 ED 53 1D 61              ld      (MSW_SCT),DE    ; store new MSW of sector
 536+ 14E6 ED 43 1F 61  SAVFL12:    ld      (LSW_SCT),BC    ; store new LSW of sector
 537+ 14EA C3 8F 14                 jp      SAVFL10         ; repeat
 538+ 14ED CD 81 10     SAVFLEXT:   call    CF_STANDBY      ; set CF into stand-by mode
 539+ 14F0 AF                       xor     A               ; clear Carry flag
 540+ 14F1 C9                       ret                     ; return to caller
 541+ 14F2
 542+ 14F2
 543+ 14F2              ; *****************************************************************************
 544+ 14F2              ; C H A N G E    F I L E N A M E
 545+ 14F2              ; change name to a file
 546+ 14F2              ; *****************************************************************************
 547+ 14F2 ED 5B 1A 61  CHNGNAM:    ld      DE,(BYT_SIZ)    ; load lenght
 548+ 14F6 ED 53 7F 61              ld      (DKLNPT),DE     ; store it
 549+ 14FA ED 5B 21 61              ld      DE,(RAM_PTR)    ; load address
 550+ 14FE ED 53 7D 61              ld      (DKNMPT),DE     ; store it
 551+ 1502 CD 55 15                 call    CHKFLEXT        ; destination file already exists?
 552+ 1505 DA 48 12                 jp      C,DUPLERR       ; file name already exists
 553+ 1508 CD C5 18                 call    CLRIOBF         ; clear I/O buffer
 554+ 150B ED 5B 81 61              ld      DE,(TMPBFR4)    ; load lenght
 555+ 150F ED 53 7F 61              ld      (DKLNPT),DE     ; store it
 556+ 1513 ED 5B 2B 61              ld      DE,(TPBF4+2)    ; load address
 557+ 1517 ED 53 7D 61              ld      (DKNMPT),DE     ; store it
 558+ 151B CD 72 15                 call    LK4FILE         ; look for file
 559+ 151E D2 50 12                 jp      NC,FLNTFND      ; file not found error
 560+ 1521 ED 5B 1A 61              ld      DE,(BYT_SIZ)    ; load lenght
 561+ 1525 ED 53 7F 61              ld      (DKLNPT),DE     ; store it
 562+ 1529 ED 5B 21 61              ld      DE,(RAM_PTR)    ; load address
 563+ 152D ED 53 7D 61              ld      (DKNMPT),DE     ; store it
 564+ 1531 CD DA 18                 call    CLRDOSBF        ; clear DOS buffer
 565+ 1534 ED 5B 0D 61              ld      DE,(DOSBFR)     ; DE set to beginning of DOS buffer
 566+ 1538 CD 30 18                 call    CHKNMVAL        ; check and copy file name
 567+ 153B 2A 0D 61                 ld      HL,(DOSBFR)     ; retrieve new name pointer
 568+ 153E DD E5                    push    IX              ; copy dest. address...
 569+ 1540 D1                       pop     DE              ; ...into DE
 570+ 1541 01 10 00                 ld      BC,$0010        ; 16 chars to copy
 571+ 1544 ED B0                    ldir                    ; copy
 572+ 1546 ED 5B 25 61              ld      DE,(TPBF2)      ; retrieve MSW of dir. sector
 573+ 154A ED 4B 27 61              ld      BC,(TPBF3)      ; retrieve LSW of dir. sector
 574+ 154E CD B4 10                 call    CF_WR_SEC       ; write sector
 575+ 1551 CD 81 10                 call    CF_STANDBY      ; put CF in standby
 576+ 1554 C9                       ret                     ; return to caller
 577+ 1555
 578+ 1555
 579+ 1555              ; *****************************************************************************
 580+ 1555              ; C H E C K    F I L E    E X I S T A N C E
 581+ 1555              ; check if a file with the given name exists into dir
 582+ 1555              ; Carry set if duplicate
 583+ 1555              ; *****************************************************************************
 584+ 1555 CD C5 18     CHKFLEXT:   call    CLRIOBF         ; clear I/O
 585+ 1558 CD F8 17                 call    CHKDSKVAL       ; check DOS version & load disk details
 586+ 155B DA 58 12                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
 587+ 155E CD 9D 17                 call    LDENTRIES       ; load entries into RAM register NTR_NBR
 588+ 1561 CD 5D 18                 call    HL2DE           ; get start of directory into DE
 589+ 1564 ED 53 12 61              ld      (DIR_STRT),DE   ; store
 590+ 1568 CD 5D 18                 call    HL2DE           ; get start of data area into DE
 591+ 156B ED 53 14 61              ld      (DAT_STRT),DE   ; store
 592+ 156F C3 75 15                 jp      LK4FILE1        ; check for name already present in dir and return to caller
 593+ 1572
 594+ 1572
 595+ 1572              ; *****************************************************************************
 596+ 1572              ; L O O K    F O R    A    F I L E
 597+ 1572              ; look for the given file into the dir
 598+ 1572              ; Carry is reset if not found, set otherwise
 599+ 1572              ; *****************************************************************************
 600+ 1572 CD 9D 17     LK4FILE:    call    LDENTRIES       ; load entries into RAM register NTR_NBR
 601+ 1575 CD C5 18     LK4FILE1:   call    CLRIOBF         ; clear IO buffer
 602+ 1578 CD DA 18                 call    CLRDOSBF        ; clear DOS buffer
 603+ 157B ED 5B 0D 61              ld      DE,(DOSBFR)     ; DE set to beginning of DOS buffer
 604+ 157F CD 30 18                 call    CHKNMVAL        ; check and copy file name
 605+ 1582 DA 4C 12                 jp      C,NAMERR        ; if Carry, file name error
 606+ 1585 C3 A9 16                 jp      FILE_EXIST      ; check if file exists and return to caller
 607+ 1588
 608+ 1588
 609+ 1588              ; *****************************************************************************
 610+ 1588              ; F I L E    L O A D
 611+ 1588              ; load a file from the disk into the memory
 612+ 1588              ; *****************************************************************************
 613+ 1588 CD C5 18     LODFILE:    call    CLRIOBF         ; clear I/O
 614+ 158B CD F8 17                 call    CHKDSKVAL       ; check DOS version & load disk details
 615+ 158E DA 58 12                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
 616+ 1591 CD 72 15                 call    LK4FILE         ; look for given file
 617+ 1594 D2 50 12                 jp      NC,FLNTFND      ; file not found - error
 618+ 1597 DD E5                    push    IX              ; copy pointer to file...
 619+ 1599 E1                       pop     HL              ; ...into HL
 620+ 159A 01 10 00                 ld      BC,$0010        ; skip file name (16 chars)...
 621+ 159D 09                       add     HL,BC           ; ...by getting pointer to file details
 622+ 159E 7E                       ld      A,(HL)          ; load file type
 623+ 159F FE 80                    cp      $80             ; 'BAS' type?
 624+ 15A1 28 0C                    jr      Z,LDFL4         ; yes, jump over
 625+ 15A3 FE 81                    cp      $81             ; 'BIN' type?
 626+ 15A5 C2 54 12                 jp      NZ,LODERR       ; no, raise error
 627+ 15A8 3A 29 61                 ld      A,(TPBF4)       ; if BIN file, file must be loaded into its original position
 628+ 15AB B7                       or      A               ; did the user set this?
 629+ 15AC CA 54 12                 jp      Z,LODERR        ; no, raise an error
 630+ 15AF 0E 04        LDFL4:      ld      C,$04           ; 4 steps forward and also 4 bytes to copy
 631+ 15B1 09                       add     HL,BC           ; point to starting sector
 632+ 15B2 11 1D 61                 ld      DE,MSW_SCT      ; point to store sector address of file
 633+ 15B5 ED B0                    ldir                    ; copy MSW/LSW from entry into buffer
 634+ 15B7 11 1A 61                 ld      DE,BYT_SIZ      ; point to store size of file
 635+ 15BA 01 03 00                 ld      BC,$0003        ; 3 bytes to copy
 636+ 15BD ED B0                    ldir                    ; copy size in bytes and sectors from entry into buffer
 637+ 15BF 11 C1 61                 ld      DE,PROGND       ; load start of BASIC RAM
 638+ 15C2 3A 29 61                 ld      A,(TPBF4)       ; check where to save the data from
 639+ 15C5 B7                       or      A               ; is it 0? (meaning from the current BASIC pointers)
 640+ 15C6 28 03                    jr      Z,LDFL1         ; yes, don't re-load the file from the address stored into the file
 641+ 15C8 CD 5D 18                 call    HL2DE           ; no, load RAM address from disk
 642+ 15CB ED 53 21 61  LDFL1:      ld      (RAM_PTR),DE    ; store starting pointer
 643+ 15CF                          ; start loading from disk
 644+ 15CF CD C5 18     LDFL2:      call    CLRIOBF         ; clear I/O buffer
 645+ 15D2 ED 5B 1D 61              ld      DE,(MSW_SCT)    ; load MSW of sector
 646+ 15D6 ED 4B 1F 61              ld      BC,(LSW_SCT)    ; load LSW of sector
 647+ 15DA CD 4B 10                 call    CF_SETSTR       ; set sector
 648+ 15DD CD 8D 10                 call    CF_RD_SEC       ; read sector
 649+ 15E0 2A 1A 61                 ld      HL,(BYT_SIZ)    ; load bytes left to be copied
 650+ 15E3 11 00 02                 ld      DE,$0200        ; are they < 512?
 651+ 15E6 CD 3B 4D                 call    CMP16
 652+ 15E9 30 04                    jr      NC,LDFL3        ; no, jump over
 653+ 15EB ED 5B 1A 61              ld      DE,(BYT_SIZ)    ; yes, so load only remaining bytes
 654+ 15EF 4B           LDFL3:      ld      C,E             ; move bytes to copy...
 655+ 15F0 42                       ld      B,D             ; ...into BC
 656+ 15F1 2A 0F 61                 ld      HL,(IOBUFF)     ; point to I/O buffer
 657+ 15F4 ED 5B 21 61              ld      DE,(RAM_PTR)    ; point to RAM where to save
 658+ 15F8 ED B0                    ldir                    ; copy data
 659+ 15FA 21 1C 61                 ld      HL,SCT_SIZ      ; sector counter
 660+ 15FD 35                       dec     (HL)            ; copied all the sectors?
 661+ 15FE CA 2D 16                 jp      Z,LDFLEX        ; yes, exit
 662+ 1601 2A 21 61                 ld      HL,(RAM_PTR)    ; pointer to RAM
 663+ 1604 11 00 02                 ld      DE,$0200        ; block of 512 bytes copied
 664+ 1607 19                       add     HL,DE           ; calculate next starting address
 665+ 1608 22 21 61                 ld      (RAM_PTR),HL    ; store next block
 666+ 160B AF                       xor     A               ; reset Carry
 667+ 160C 2A 1A 61                 ld      HL,(BYT_SIZ)    ; load left bytes
 668+ 160F ED 52                    sbc     HL,DE           ; subtract copied bytes
 669+ 1611 22 1A 61                 ld      (BYT_SIZ),HL    ; store left bytes
 670+ 1614 ED 4B 1F 61              ld      BC,(LSW_SCT)    ; load LSW of sector
 671+ 1618 03                       inc     BC              ; next sector
 672+ 1619 78                       ld      A,B             ; BC=$0000?
 673+ 161A B1                       or      C
 674+ 161B 20 09                    jr      NZ,LDFL5        ; no, jump over
 675+ 161D ED 5B 1D 61              ld      DE,(MSW_SCT)    ; load MSW of sector
 676+ 1621 13                       inc     DE              ; increment DE
 677+ 1622 ED 53 1D 61              ld      (MSW_SCT),DE    ; store new MSW of sector
 678+ 1626 ED 43 1F 61  LDFL5:      ld      (LSW_SCT),BC    ; store new LSW of sector
 679+ 162A C3 CF 15                 jp      LDFL2           ; repeat
 680+ 162D CD 81 10     LDFLEX:     call    CF_STANDBY      ; set CF into stand-by mode
 681+ 1630 AF                       xor     A               ; clear Carry flag
 682+ 1631 C9                       ret                     ; return to caller
 683+ 1632
 684+ 1632
 685+ 1632              ; *****************************************************************************
 686+ 1632              ; F I L E    E R A S E
 687+ 1632              ; erase a file from disk, freeing its block
 688+ 1632              ; *****************************************************************************
 689+ 1632 CD C5 18     FIL_ERASE:  call    CLRIOBF         ; clear I/O
 690+ 1635 CD F8 17                 call    CHKDSKVAL       ; check DOS version & load disk details
 691+ 1638 DA 58 12                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
 692+ 163B CD 72 15                 call    LK4FILE         ; look for given file
 693+ 163E D2 50 12                 jp      NC,FLNTFND      ; file not found - error
 694+ 1641 DD 5E 14                 ld      E,(IX+$14)      ; load MSW into DE
 695+ 1644 DD 56 15                 ld      D,(IX+$15)
 696+ 1647 DD 4E 16                 ld      C,(IX+$16)      ; load LSW into BC
 697+ 164A DD 46 17                 ld      B,(IX+$17)
 698+ 164D ED 53 1D 61              ld      (MSW_SCT),DE    ; store DE
 699+ 1651 ED 43 1F 61              ld      (LSW_SCT),BC    ; store BC
 700+ 1655 DD 7E 1A                 ld      A,(IX+$1A)      ; load size in sectors
 701+ 1658 32 1C 61                 ld      (SCT_SIZ),A     ; store it
 702+ 165B 3E 7F                    ld      A,$7F           ; marker for file deleted
 703+ 165D DD 77 00                 ld      (IX),A          ; set file as deleted (quick erase)
 704+ 1660 3A 29 61                 ld      A,(TPBF4)       ; check for quick or full delete
 705+ 1663 B7                       or      A               ; A=0 quick erase
 706+ 1664 28 0A                    jr      Z,FIL_ERA5      ; jump if quick erase
 707+ 1666 AF                       xor     A               ; clear A
 708+ 1667 06 20                    ld      B,$20           ; full erase - clean entry (32 cells)
 709+ 1669 DD 77 00     FIL_ERA6:   ld      (IX),A          ; reset cell
 710+ 166C DD 23                    inc     IX              ; next cell
 711+ 166E 10 F9                    djnz    FIL_ERA6        ; repeat
 712+ 1670 ED 5B 25 61  FIL_ERA5:   ld      DE,(TPBF2)      ; retrieve MSW of current directory sector
 713+ 1674 ED 4B 27 61              ld      BC,(TPBF3)      ; retrieve LSW of current directory sector
 714+ 1678 CD B4 10                 call    CF_WR_SEC       ; write sector
 715+ 167B 38 27                    jr      C,WRT_ERR       ; error?
 716+ 167D 3A 29 61                 ld      A,(TPBF4)       ; check for quick or full delete
 717+ 1680 B7                       or      A               ; if A=0 then quick erase
 718+ 1681 28 1C                    jr      Z,FIL_ERA3      ; yes, leave
 719+ 1683 CD C5 18                 call    CLRIOBF         ; no, full delete - clear I/O buffer
 720+ 1686 ED 5B 1D 61              ld      DE,(MSW_SCT)    ; load MSW of 1st sector of file block
 721+ 168A ED 4B 1F 61              ld      BC,(LSW_SCT)    ; load LSW of 1st sector of file block
 722+ 168E 21 1C 61                 ld      HL,SCT_SIZ      ; pointer to size in sectors
 723+ 1691 CD B4 10     FIL_ERA1:   call    CF_WR_SEC       ; erase sector
 724+ 1694 38 0E                    jr      C,WRT_ERR       ; error?
 725+ 1696 03                       inc     BC              ; next sector
 726+ 1697 78                       ld      A,B             ; is LSW rolled back to 0?
 727+ 1698 B1                       or      C
 728+ 1699 20 01                    jr      NZ,FIL_ERA2     ; no, jump over
 729+ 169B 13                       inc     DE              ; yes, increment MSW
 730+ 169C 35           FIL_ERA2:   dec     (HL)            ; decrement sector counter
 731+ 169D 20 F2                    jr      NZ,FIL_ERA1     ; repeat if other sectors
 732+ 169F CD 81 10     FIL_ERA3:   call    CF_STANDBY      ; set CF into stand-by mode
 733+ 16A2 AF                       xor     A               ; clear Carry
 734+ 16A3 C9                       ret
 735+ 16A4 CD 81 10     WRT_ERR:    call    CF_STANDBY      ; put CF into stand-by
 736+ 16A7 37                       scf                     ; set error
 737+ 16A8 C9                       ret                     ; return to caller
 738+ 16A9
 739+ 16A9
 740+ 16A9              ; *****************************************************************************
 741+ 16A9              ; F I L E    C H E C K
 742+ 16A9              ; check if file name already exists in directory
 743+ 16A9              ; file name must be stored from (DOSBFR) for 16 chars
 744+ 16A9              ; *****************************************************************************
 745+ 16A9 FD 2A 18 61  FILE_EXIST: ld      IY,(NTR_NBR)    ; load max entries
 746+ 16AD CD 64 17                 call    SETPTEN         ; point to 1st sector of dir
 747+ 16B0 CD 6C 17     CHKSTNM1:   call    PT2FSEN         ; point to 1st entry of a dir's sect
 748+ 16B3 CD 77 17     CHKSTNM2:   call    CKCREN          ; check current entry
 749+ 16B6 28 29                    jr      Z,CHKSTNM10     ; if empty or deleted, jump over
 750+ 16B8 22 23 61                 ld      (TPBF1),HL      ; store HL
 751+ 16BB ED 53 25 61              ld      (TPBF2),DE      ; store DE
 752+ 16BF ED 43 27 61              ld      (TPBF3),BC      ; store BC
 753+ 16C3 DD E5                    push    IX              ; copy IX...
 754+ 16C5 E1                       pop     HL              ; ...into HL
 755+ 16C6 ED 5B 0D 61              ld      DE,(DOSBFR)     ; beginning of name file
 756+ 16CA 06 10                    ld      B,$10           ; 16 chars to check
 757+ 16CC 1A           CHKSTNM3:   ld      A,(DE)          ; load a char from name on disk
 758+ 16CD ED A1                    cpi                     ; compare with name from user
 759+ 16CF 20 05                    jr      NZ,CHKSTNM6     ; chars are different, leave
 760+ 16D1 13                       inc     DE              ; inc DE (HL is incremented by "cpi")
 761+ 16D2 10 F8                    djnz    CHKSTNM3        ; repeat for 16 chars
 762+ 16D4 18 17                    jr      FLEXST          ; file exists in dir
 763+ 16D6 2A 23 61     CHKSTNM6:   ld      HL,(TPBF1)      ; retrieve HL
 764+ 16D9 ED 5B 25 61              ld      DE,(TPBF2)      ; retrieve DE
 765+ 16DD ED 4B 27 61              ld      BC,(TPBF3)      ; retrieve sector counter
 766+ 16E1 CD 7F 17     CHKSTNM10:  call    GTNXTEN         ; other entries in this sector?
 767+ 16E4 20 CD                    jr      NZ,CHKSTNM2     ; yes, continue check
 768+ 16E6 CD 8B 17     CHKSTNM5:   call    CKLSTEN         ; go to next sector
 769+ 16E9 30 C5                    jr      NC,CHKSTNM1     ; more entries? repeat
 770+ 16EB AF           FLNTEXS:    xor     A               ; file not found, reset Carry
 771+ 16EC C9                       ret                     ; return
 772+ 16ED 37           FLEXST:     scf                     ; file is present - set Carry flag for error
 773+ 16EE C9                       ret
 774+ 16EF
 775+ 16EF
 776+ 16EF              ; *****************************************************************************
 777+ 16EF              ; UNDELETE DELETED FILES
 778+ 16EF              ; look for deleted files and undelete them
 779+ 16EF              ; *****************************************************************************
 780+ 16EF CD C5 18     DSKUNDFL:   call    CLRIOBF         ; clear I/O
 781+ 16F2 CD F8 17                 call    CHKDSKVAL       ; check DOS version & load disk details
 782+ 16F5 DA 58 12                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
 783+ 16F8 CD 3C 17                 call    FNDFRENTR       ; find a free entry
 784+ 16FB D8           DSKUNDFL1:  ret     C               ; return if entries are finished
 785+ 16FC DD 7E 00                 ld      A,(IX)          ; reload first char of entry
 786+ 16FF FE 7F                    cp      $7F             ; is it a deleted entry?
 787+ 1701 20 29                    jr      NZ,DSKUNDFL2    ; no, jump over
 788+ 1703 CD CF 17                 call    RND8            ; get a random char
 789+ 1706 CD ED 17                 call    CHATOZ          ; transform it into a letter
 790+ 1709 DD 77 00                 ld      (IX),A          ; store it as the first letter of filename
 791+ 170C CD B4 10                 call    CF_WR_SEC       ; write sector (address is into DEBC)
 792+ 170F E5                       push    HL              ; store HL
 793+ 1710 C5                       push    BC              ; store BC
 794+ 1711 D5                       push    DE              ; store DE
 795+ 1712 DD E5                    push    IX              ; copy IX...
 796+ 1714 E1                       pop     HL              ; ...into HL
 797+ 1715 06 10                    ld      B,$10           ; 16 chars
 798+ 1717 7E           DSKUNDPR:   ld      A,(HL)          ; retrieve char from filename
 799+ 1718 CD A9 23                 call    OUTC            ; print char
 800+ 171B 23                       inc     HL              ; next char
 801+ 171C 10 F9                    djnz    DSKUNDPR        ; repeat
 802+ 171E 3E 20                    ld      A,SPC           ; print a space
 803+ 1720 CD A9 23                 call    OUTC
 804+ 1723 21 31 17                 ld      HL,DSKUNDTXT    ; print undeleted message
 805+ 1726 CD 80 2F                 call    PRS
 806+ 1729 D1                       pop     DE              ; retrieve DE
 807+ 172A C1                       pop     BC              ; retrieve BC
 808+ 172B E1                       pop     HL              ; retrieve HL
 809+ 172C CD 50 17     DSKUNDFL2:  call    FNDFRENTR4      ; goto next entry
 810+ 172F 18 CA                    jr      DSKUNDFL1       ; repeat
 811+ 1731 75 6E 64 65  DSKUNDTXT:  defb    "undeleted",CR,0
 811+ 1735 6C 65 74 65
 811+ 1739 64 0D 00
 812+ 173C
 813+ 173C
 814+ 173C              ; *****************************************************************************
 815+ 173C              ; FIND A FREE ENTRY
 816+ 173C              ; find a free entry in the directory to store a new file
 817+ 173C              ; *****************************************************************************
 818+ 173C CD AC 17     FNDFRENTR:  call    LDMSCT          ; read Master Sector
 819+ 173F CD 9D 17                 call    LDENTRIES       ; load entries into RAM register NTR_NBR and DE
 820+ 1742 D5                       push    DE              ; copy number of entries...
 821+ 1743 FD E1                    pop     IY              ; ...into IY
 822+ 1745 CD 64 17                 call    SETPTEN         ; point to first entry
 823+ 1748 CD 6C 17     FNDFRENTR1: call    PT2FSEN         ; point to 1st entry of sector
 824+ 174B CD 77 17     FNDFRENTR2: call    CKCREN          ; check current entry
 825+ 174E 28 0B                    jr      Z,FNDFRENTR3    ; found a free entry
 826+ 1750 CD 7F 17     FNDFRENTR4: call    GTNXTEN         ; other entries in this sector?
 827+ 1753 20 F6                    jr      NZ,FNDFRENTR2   ; yes, continue check
 828+ 1755 CD 8B 17                 call    CKLSTEN         ; go to next sector
 829+ 1758 30 EE                    jr      NC,FNDFRENTR1   ; more entries? repeat
 830+ 175A C9                       ret                     ; entries finished - leave
 831+ 175B ED 43 16 61  FNDFRENTR3: ld      (DIR_SCT),BC    ; store sector of dir
 832+ 175F 22 18 61                 ld      (NTR_NBR),HL    ; store entry number
 833+ 1762 AF                       xor     A               ; reset Carry
 834+ 1763 C9                       ret
 835+ 1764
 836+ 1764
 837+ 1764              ; *****************************************************************************
 838+ 1764              ;   U T I L I T I E S
 839+ 1764              ; *****************************************************************************
 840+ 1764
 841+ 1764              ; set up registers to point to first sector of directory
 842+ 1764 01 01 00     SETPTEN:    ld      BC,$0001        ; BC=$0001 (starting sector of dir) (LSW)
 843+ 1767 50                       ld      D,B             ; DE=$0000 (starting sector of dir) (MSW)
 844+ 1768 58                       ld      E,B
 845+ 1769 60                       ld      H,B             ; HL=$0000 (entry counter)
 846+ 176A 68                       ld      L,B
 847+ 176B C9                       ret                     ; return to caller
 848+ 176C
 849+ 176C
 850+ 176C              ; load a sector and point to first entry
 851+ 176C CD 4B 10     PT2FSEN:    call    CF_SETSTR       ; set sector to read (BC-DE)
 852+ 176F CD 8D 10                 call    CF_RD_SEC       ; read sector
 853+ 1772 DD 2A 0F 61              ld      IX,(IOBUFF)     ; beginning of I/O buffer
 854+ 1776 C9                       ret
 855+ 1777
 856+ 1777
 857+ 1777              ; check current entry
 858+ 1777 DD 7E 00     CKCREN:     ld      A,(IX)          ; load 1st char of entry name
 859+ 177A                          ;dec     IY              ; decrement number of entries
 860+ 177A B7                       or      A               ; is it $00 (empty entry)?
 861+ 177B C8                       ret     Z               ; yes, found an entry
 862+ 177C FE 7F                    cp      $7F             ; is it $7F (deleted entry)?
 863+ 177E C9                       ret
 864+ 177F
 865+ 177F              ; goto next entry
 866+ 177F C5           GTNXTEN:    push    BC              ; store BC
 867+ 1780 01 20 00                 ld      BC,$0020        ; load BC with directory entry size (32 bytes)
 868+ 1783 DD 09                    add     IX,BC           ; next entry in current sector
 869+ 1785 C1                       pop     BC              ; retrieve sector pointer
 870+ 1786 23                       inc     HL              ; increment entry counter
 871+ 1787 7D                       ld      A,L
 872+ 1788 E6 0F                    and     %00001111       ; just done 16 entries?
 873+ 178A C9                       ret
 874+ 178B
 875+ 178B
 876+ 178B              ; check if reached last entry
 877+ 178B              ; Carry is set if entries finished
 878+ 178B 03           CKLSTEN:    inc     BC              ; entries in this sector finished .. goto next sector
 879+ 178C 78                       ld      A,B             ; check if...
 880+ 178D B1                       or      C               ; ...BC=$000
 881+ 178E 20 01                    jr      NZ,CKLSTEN1     ; no, jump over
 882+ 1790 13                       inc     DE              ; yes, increment DE (MSW)
 883+ 1791 E5           CKLSTEN1:   push    HL              ; preserve current entry
 884+ 1792 D5                       push    DE
 885+ 1793 FD E5                    push    IY              ; copy max allowed files...
 886+ 1795 D1                       pop     DE              ; ...into HL
 887+ 1796 CD 3B 4D                 call    CMP16           ; check if reached max allowed entries
 888+ 1799 D1                       pop     DE
 889+ 179A E1                       pop     HL              ; (retrieve current entry)
 890+ 179B 3F                       ccf
 891+ 179C C9                       ret                     ; return
 892+ 179D
 893+ 179D
 894+ 179D              ; load entries intro RAM register
 895+ 179D 2A 0F 61     LDENTRIES:  ld      HL,(IOBUFF)     ; start of I/O buffer
 896+ 17A0 01 19 00                 ld      BC,$0019        ; point to max. allowed entries
 897+ 17A3 09                       add     HL,BC           ; get address
 898+ 17A4 CD 5D 18                 call    HL2DE           ; get entries into DE
 899+ 17A7 ED 53 18 61              ld      (NTR_NBR),DE    ; store
 900+ 17AB C9                       ret                     ; return to caller
 901+ 17AC
 902+ 17AC
 903+ 17AC              ; load Master Sector (sector #0)
 904+ 17AC 01 00 00     LDMSCT:     ld      BC,$0000        ; LSW of sector
 905+ 17AF 50           LDMSCT1:    ld      D,B             ; MSW of sector
 906+ 17B0 58                       ld      E,B
 907+ 17B1 CD 4B 10                 call    CF_SETSTR       ; set sector
 908+ 17B4 CD 8D 10                 call    CF_RD_SEC       ; read sector
 909+ 17B7 C9                       ret
 910+ 17B8
 911+ 17B8
 912+ 17B8              ; generate random disk ID
 913+ 17B8 C5           RND_ID:     push    BC
 914+ 17B9 06 02                    ld      B,$02           ; repeat 2 times
 915+ 17BB CD CF 17     RND_ID1:    call    RND8            ; get a random value
 916+ 17BE CD ED 17                 call    CHATOZ          ; transform it into a letter
 917+ 17C1 12                       ld      (DE),A          ; store it
 918+ 17C2 13                       inc     DE              ; inc pointer
 919+ 17C3 CD CF 17                 call    RND8            ; get a random value
 920+ 17C6 CD E2 17                 call    CH0TO9          ; transform it into a number from 0 to 9
 921+ 17C9 12                       ld      (DE),A          ; store it
 922+ 17CA 13                       inc     DE              ; inc pointer
 923+ 17CB 10 EE                    djnz    RND_ID1         ; repeat
 924+ 17CD C1                       pop     BC
 925+ 17CE C9                       ret                     ; return to caller
 926+ 17CF
 927+ 17CF
 928+ 17CF              ; generate a pseudo-random number using TMR and R registers
 929+ 17CF C5           RND8:       push    BC
 930+ 17D0 3A 5B 61                 ld      A,(TMRCNT)      ; load LSW of sys-timer
 931+ 17D3 47                       ld      B,A             ; copy into B
 932+ 17D4 ED 5F                    ld      A,R             ; load refresh register
 933+ 17D6 A8                       xor     B               ; A xor B
 934+ 17D7 47                       ld      B,A             ; copy into B
 935+ 17D8 0F                       rrca                    ; multiply by 32
 936+ 17D9 0F                       rrca
 937+ 17DA 0F                       rrca
 938+ 17DB EE 1F                    xor     $1F
 939+ 17DD 80                       add     A,B
 940+ 17DE DE FF                    sbc     A,255           ; carry
 941+ 17E0 C1                       pop     BC
 942+ 17E1 C9                       ret                     ; return to caller
 943+ 17E2
 944+ 17E2
 945+ 17E2              ; char ported into 0-9 interval
 946+ 17E2 E6 0F        CH0TO9:     and     %00001111       ; get only low nibble
 947+ 17E4 FE 0A                    cp      $0A             ; is it < 10?
 948+ 17E6 38 02                    jr      C,CH0TO9E       ; yes, jump over
 949+ 17E8 D6 0A                    sub     $0A             ; subract 10
 950+ 17EA C6 30        CH0TO9E:    add     $30             ; get a number from 0 to 9
 951+ 17EC C9                       ret
 952+ 17ED
 953+ 17ED
 954+ 17ED              ; char ported into A-Z interval
 955+ 17ED E6 1F        CHATOZ:     and     %00011111       ; get only first 5 bits
 956+ 17EF FE 1A                    cp      $1A             ; is it < 26?
 957+ 17F1 38 02                    jr      C,CHATOZE       ; yes, jump over
 958+ 17F3 D6 1A                    sub     $1A             ; no, subtract 26
 959+ 17F5 C6 41        CHATOZE:    add     $41             ; get a letter from 'A' to 'Z'
 960+ 17F7 C9                       ret                     ; return to caller
 961+ 17F8
 962+ 17F8
 963+ 17F8              ; first check DOS validity then load disk details
 964+ 17F8 CD 09 10     CHKDSKVAL:  call    CF_INIT         ; open CF card comm.
 965+ 17FB D8                       ret     C               ; if errors, leave
 966+ 17FC C5                       push    BC              ; store BC
 967+ 17FD D5                       push    DE              ; store DE
 968+ 17FE E5                       push    HL              ; store HL
 969+ 17FF 01 00 00                 ld      BC,$0000        ; reset LSW of sector
 970+ 1802 50                       ld      D,B             ; reset MSW of sector
 971+ 1803 58                       ld      E,B
 972+ 1804 CD 4B 10                 call    CF_SETSTR       ; set sector #0
 973+ 1807 CD 8D 10                 call    CF_RD_SEC       ; read sector
 974+ 180A 2A 0F 61                 ld      HL,(IOBUFF)     ; address of default conf. buffer
 975+ 180D 11 0A 00                 ld      DE,$000A        ; point to disk DOS version
 976+ 1810 19                       add     HL,DE
 977+ 1811 11 E2 10                 ld      DE,DFSCT0+10    ; get starting address of I/O buffer
 978+ 1814 06 04                    ld      B,$04           ; 4 chars
 979+ 1816 1A           CHKDSKVAL1: ld      A,(DE)          ; load char from DOS version into memory
 980+ 1817 BE                       cp      (HL)            ; compare with disk DOS version
 981+ 1818 20 11                    jr      NZ,CHKDSKVALE   ; no match - so error
 982+ 181A 13                       inc     DE              ; next source
 983+ 181B 23                       inc     HL              ; next comparison
 984+ 181C 10 F8                    djnz    CHKDSKVAL1      ; repeat
 985+ 181E 2A 0D 61                 ld      HL,(DOSBFR)     ; address of default conf. buffer
 986+ 1821 11 1D 00                 ld      DE,$001D        ; point to address of data area
 987+ 1824 19                       add     HL,DE           ; set pointer to beginning of identifies
 988+ 1825 CD 5D 18                 call    HL2DE           ; first sector of data area into DE
 989+ 1828 AF                       xor     A               ; no error - clear Carry flag
 990+ 1829 18 01                    jr      CHKDSKVAL2      ; jump over
 991+ 182B 37           CHKDSKVALE: scf                     ; error - set carry flag
 992+ 182C E1           CHKDSKVAL2: pop     HL
 993+ 182D D1                       pop     DE
 994+ 182E C1                       pop     BC
 995+ 182F C9                       ret                     ; return to caller
 996+ 1830
 997+ 1830
 998+ 1830              ; check name validity (only allowed chars) and copy it from string pool into a temp buff
 999+ 1830              ; Inputs: DE: pointer to dest. buffer
1000+ 1830              ; operation: copy (HL)->(DE) and pads to get a 16-chars name
1001+ 1830              ; destroys: A, BC, DE, HL
1002+ 1830 ED 4B 7F 61  CHKNMVAL:   ld      BC,(DKLNPT)     ; load lenght of name
1003+ 1834 79                       ld      A,C             ; lenght is max. 16 char, so we only check C
1004+ 1835 FE 11                    cp      $11             ; is it <=16?
1005+ 1837 38 02                    jr      C,CHKNMVAL1     ; yes, so jump over
1006+ 1839 0E 10                    ld      C,$10           ; no, get only 16 chars
1007+ 183B 41           CHKNMVAL1:  ld      B,C             ; copy lenght into B
1008+ 183C 0E 10                    ld      C,$10           ; char counter
1009+ 183E 2A 7D 61                 ld      HL,(DKNMPT)     ; pointer to name
1010+ 1841 7E           CHKNMVAL2:  ld      A,(HL)          ; get a char from string name
1011+ 1842 CD AF 18                 call    CHK_NAM         ; check if valid
1012+ 1845 D8                       ret     C               ; no, name error
1013+ 1846 12                       ld      (DE),A          ; yes, store char
1014+ 1847 13                       inc     DE              ; next I/O location
1015+ 1848 23                       inc     HL              ; next name char
1016+ 1849 0D                       dec     C               ; decrement number of chars copied
1017+ 184A 10 F5                    djnz    CHKNMVAL2       ; repeat until name ends
1018+ 184C 79                       ld      A,C             ; check if there are no empty chars in file
1019+ 184D B7                       or      A
1020+ 184E C8                       ret     Z               ; yes, job finished - return
1021+ 184F 3E 20                    ld      A,SPC           ; no, padding required
1022+ 1851 12           CHKNMVAL3:  ld      (DE),A          ; store char
1023+ 1852 13                       inc     DE              ; next location
1024+ 1853 0D                       dec     C               ; check if padding is over
1025+ 1854 20 FB                    jr      NZ,CHKNMVAL3    ; no, continue
1026+ 1856 AF                       xor     A               ; clear Carry flag
1027+ 1857 C9                       ret                     ; return to caller
1028+ 1858
1029+ 1858
1030+ 1858              ; store DE into (HL) and (HL+1)
1031+ 1858 73           DE2HL:      ld      (HL),E          ; LSW of size
1032+ 1859 23                       inc     HL
1033+ 185A 72                       ld      (HL),D          ; MSW of size
1034+ 185B 23                       inc     HL
1035+ 185C C9                       ret                     ; return to caller
1036+ 185D
1037+ 185D
1038+ 185D              ; get DE from (HL) and (HL+1)
1039+ 185D 5E           HL2DE:      ld      E,(HL)          ; get LSW into E
1040+ 185E 23                       inc     HL              ; next location
1041+ 185F 56                       ld      D,(HL)          ; get MSW into D
1042+ 1860 23                       inc     HL              ; next location
1043+ 1861 C9                       ret                     ; return to caller
1044+ 1862
1045+ 1862
1046+ 1862              ; convert a 16/32-bit number into an ASCII string and print it
1047+ 1862              ; inputs: HL pointer to 32-bit number
1048+ 1862 CD 5D 18     PRN32ASCII: call    HL2DE           ; load MSW into DE  <-- entry for 32-bit
1049+ 1865 4E           PRN16ASCII: ld      C,(HL)          ; load LSW into BC   <-- entry for 16-bit (set DE to $0000 before to call)
1050+ 1866 23                       inc     HL
1051+ 1867 46                       ld      B,(HL)
1052+ 1868 C5                       push    BC              ; copy BC...
1053+ 1869 DD E1                    pop     IX              ; ...into IX
1054+ 186B FD 21 23 61  PRN16ASCIX: ld      IY,TPBF1        ; number is into DEIX - now, load pointer to destination buffer
1055+ 186F CD 04 4E                 call    CLCN32          ; convert number in DEIX into ASCII number
1056+ 1872 21 23 61                 ld      HL,TPBF1        ; address of ASCII number
1057+ 1875 7E           PRNTSIZ:    ld      A,(HL)          ; get a char
1058+ 1876 B7                       or      A               ; is it $00 (end of string)?
1059+ 1877 C8                       ret     Z               ; yes, leave
1060+ 1878 CD A9 23                 call    OUTC            ; no, print char
1061+ 187B 23                       inc     HL              ; next char
1062+ 187C 18 F7                    jr      PRNTSIZ         ; repeat
1063+ 187E
1064+ 187E
1065+ 187E              ; convert one or more bytes into memory in hex format
1066+ 187E              ; HL: pointer to number in memory - B: number of bytes to convert
1067+ 187E              ; destroys: A, D, HL
1068+ 187E 50           PRN_HEX:    ld      D,B             ; move bytes into D
1069+ 187F 7E           PRN_HEX1:   ld      A,(HL)          ; load value
1070+ 1880 CD 9F 18                 call    BYTEHEX         ; print hex number
1071+ 1883 23                       inc     HL              ; next location
1072+ 1884 15                       dec     D               ; decrement bytes to convert
1073+ 1885 20 F8                    jr      NZ,PRN_HEX1     ; repeat
1074+ 1887 C9                       ret
1075+ 1888
1076+ 1888
1077+ 1888              ; convert one or more words into memory in hex format
1078+ 1888              ; IX: pointer to number in memory - B: number of words to convert
1079+ 1888              ; destroys: AF, IX
1080+ 1888 D5           PRN_WHEX:   push    DE
1081+ 1889 50                       ld      D,B
1082+ 188A DD 7E 01     PRN_WHEX1:  ld      A,(IX+1)        ; load MSW into A
1083+ 188D CD 9F 18                 call    BYTEHEX         ; print hex number
1084+ 1890 DD 7E 00                 ld      A,(IX)          ; load LSW into A
1085+ 1893 CD 9F 18                 call    BYTEHEX         ; print hex number
1086+ 1896 DD 23                    inc     IX
1087+ 1898 DD 23                    inc     IX              ; next word
1088+ 189A 15                       dec     D               ; decrement words to convert
1089+ 189B 20 ED                    jr      NZ,PRN_WHEX1    ; repeat
1090+ 189D D1                       pop     DE
1091+ 189E C9                       ret
1092+ 189F
1093+ 189F
1094+ 189F              ; print A in hex format
1095+ 189F C5           BYTEHEX:    push    BC
1096+ 18A0 D5                       push    DE
1097+ 18A1 CD 50 4C                 call    BYT2ASC         ; convert to HEX and get back into BC
1098+ 18A4 78                       ld      A,B
1099+ 18A5 CD A9 23                 call    OUTC            ; print left nibble
1100+ 18A8 79                       ld      A,C
1101+ 18A9 CD A9 23                 call    OUTC            ; print right nibble
1102+ 18AC D1                       pop     DE
1103+ 18AD C1                       pop     BC
1104+ 18AE C9                       ret                     ; return to caller
1105+ 18AF
1106+ 18AF
1107+ 18AF              ; check for non-allowed chars in disk/file names - allowed chars: '0'-'9', 'A'-'Z', '-', SPACE
1108+ 18AF              ; input: A -> char to check
1109+ 18AF              ; return: C is set if ERROR, reset otherwise
1110+ 18AF FE 20        CHK_NAM:    cp      SPC             ; is it a space?
1111+ 18B1 C8                       ret     Z               ; return if equal (C is reset)
1112+ 18B2 FE 2D                    cp      '-'             ; is it a minus?
1113+ 18B4 C8                       ret     Z               ; return if equal
1114+ 18B5 FE 30                    cp      '0'             ; char < '0' ?
1115+ 18B7 D8                       ret     C               ; yes, disk name error
1116+ 18B8 FE 3A                    cp      ':'             ; is char <= '9' ?
1117+ 18BA 38 07                    jr      C,CHK_C_CF      ; yes, leave
1118+ 18BC E6 5F                    and     %01011111       ; for letters, only UPPER CASE
1119+ 18BE FE 41                    cp      'A'             ; is char >= 'A' ?
1120+ 18C0 D8                       ret     C               ; no, error
1121+ 18C1 FE 5B                    cp      '['             ; is char <= 'Z' ? (if yes, C=1, then C=0; otherwise, C=0 then C=1)
1122+ 18C3 3F           CHK_C_CF:   ccf                     ; Carry complement (invert Carry)
1123+ 18C4 C9           CHK_NAM_LV: ret                     ; return to caller
1124+ 18C5
1125+ 18C5
1126+ 18C5              ; clear I/O buffer
1127+ 18C5 F5           CLRIOBF:    push    AF              ; store AF
1128+ 18C6 C5                       push    BC              ; store BC
1129+ 18C7 E5                       push    HL              ; store HL
1130+ 18C8 2A 0F 61                 ld 	    HL,(IOBUFF)     ; load address of last BASIC location
1131+ 18CB 01 02 00                 ld      BC,$0002        ; B=256 iterations ($00); C=repeat 2 times
1132+ 18CE AF           CLRBUFF:    xor     A               ; reset A   ----- common part -----
1133+ 18CF 77           RSTIOBF:    ld      (HL),A          ; reset cell
1134+ 18D0 23                       inc     HL              ; next cell
1135+ 18D1 10 FC                    djnz    RSTIOBF         ; repeat for 256 times
1136+ 18D3 0D                       dec     C               ; decrement C
1137+ 18D4 20 F9                    jr      NZ,RSTIOBF      ; repeat if not zero
1138+ 18D6 E1                       pop     HL              ; retrieve HL
1139+ 18D7 C1                       pop     BC              ; retrieve BC
1140+ 18D8 F1                       pop     AF              ; retrieve AF
1141+ 18D9 C9                       ret                     ; return to caller
1142+ 18DA
1143+ 18DA
1144+ 18DA              ; clear DOS buffer
1145+ 18DA F5           CLRDOSBF:   push    AF              ; store AF
1146+ 18DB C5                       push    BC              ; store BC
1147+ 18DC E5                       push    HL              ; store HL
1148+ 18DD 2A 0D 61                 ld 	    HL,(DOSBFR)     ; load address of last BASIC location
1149+ 18E0 01 01 20                 ld      BC,$2001        ; B=32 iterations; C=repeat 1 time
1150+ 18E3 C3 CE 18                 jp      CLRBUFF         ; continue to common part
# file closed: ../include/dos/dos-1.03.asm
  84  18E6
  85  18E6              ; include the latest version of the LM80C 64K BASIC interpreter
  86  18E6                  INCLUDE "../include/basic/basic-1.09.asm"
# file opened: ../include/basic/basic-1.09.asm
   1+ 18E6              ; ------------------------------------------------------------------------------
   2+ 18E6              ; LM80C BASIC (32K/64K) - R3.23
   3+ 18E6              ; ------------------------------------------------------------------------------
   4+ 18E6              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 18E6              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 18E6              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 18E6              ; kind of warranty: you can use them at your own risk.
   8+ 18E6              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 18E6              ; maintain the copyright notices, include this advice and the note to the
  10+ 18E6              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 18E6              ; redistribuite them.
  12+ 18E6              ; https://www.leonardomiliani.com
  13+ 18E6              ;
  14+ 18E6              ; Please support me by visiting the following links:
  15+ 18E6              ; Main project page: https://www.leonardomiliani.com
  16+ 18E6              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 18E6              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 18E6              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 18E6              ; ------------------------------------------------------------------------------
  20+ 18E6              ; LM80C BASIC 64K - originally based on the following NASCOM BASIC versions:
  21+ 18E6              ; 4.7  - original version by NASCOM/MICROSOFT
  22+ 18E6              ; 4.7b - modified version by Grant Searle (additional commands & functions)
  23+ 18E6
  24+ 18E6
  25+ 18E6              ;------------------------------------------------------------------------------
  26+ 18E6              ;  L M 8 0 C   B A S I C
  27+ 18E6              ;------------------------------------------------------------------------------
  28+ 18E6
  29+ 18E6              ; GENERAL EQUATES
  30+ 18E6
  31+ 18E6              NLLCR           equ     $00             ; null char (used as space/empty char in video prints)
  32+ 18E6              CTRLC           equ     $03             ; Control "C"
  33+ 18E6              CTRLG           equ     $07             ; Control "G"
  34+ 18E6              BKSP            equ     $08             ; Back space
  35+ 18E6              LF              equ     $0A             ; Line feed
  36+ 18E6              CS              equ     $0C             ; Clear screen
  37+ 18E6              CR              equ     $0D             ; Carriage return
  38+ 18E6              CTRLO           equ     $0F             ; Control "O"
  39+ 18E6              CTRLQ           equ     $11             ; Control "Q"
  40+ 18E6              CTRLR           equ     $12             ; Control "R"
  41+ 18E6              CTRLS           equ     $13             ; Control "S"
  42+ 18E6              CTRLU           equ     $15             ; Control "U"
  43+ 18E6              HOME            equ     $19             ; Home (cursor at 0,0)
  44+ 18E6              ESC             equ     $1B             ; Escape
  45+ 18E6              SPC             equ     $20             ; Space
  46+ 18E6              DEL             equ     $7F             ; Delete
  47+ 18E6              INSRT           equ     $1A             ; Insert Key
  48+ 18E6              ; cursor ASCII codes
  49+ 18E6              CRSLFT          equ     $1C             ; cursor left
  50+ 18E6              CRSRGT          equ     $1D             ; cursor right
  51+ 18E6              CRSUP           equ     $1E             ; cursor up
  52+ 18E6              CRSDN           equ     $1F             ; cursor down
  53+ 18E6
  54+ 18E6
  55+ 18E6              ;-------------------------------------------------------------------------
  56+ 18E6              ; BASIC ERROR MESSAGES
  57+ 18E6              ; the interpreter looks for a single-byte code in the following list,
  58+ 18E6              ; then loads the corresponding memory pointer in "ERRTBL" table to
  59+ 18E6              ; find where to retrieve the message text in "ERRORS"
  60+ 18E6
  61+ 18E6              ; BASIC ERROR CODE VALUES
  62+ 18E6              ; These values act as an offset to point to the error message into the error table
  63+ 18E6              ; must be incremented by 2 because they point to a word address jump
  64+ 18E6              NF      equ     $00     ; NEXT without FOR
  65+ 18E6              SN      equ     $02     ; Syntax error
  66+ 18E6              RG      equ     $04     ; RETURN without GOSUB
  67+ 18E6              OD      equ     $06     ; Out of DATA
  68+ 18E6              FC      equ     $08     ; Function call error
  69+ 18E6              OV      equ     $0A     ; Overflow
  70+ 18E6              OM      equ     $0C     ; Out of memory
  71+ 18E6              UL      equ     $0E     ; Undefined line number
  72+ 18E6              BS      equ     $10     ; Bad subscript
  73+ 18E6              DD      equ     $12     ; Re-Dimensioned array
  74+ 18E6              DZ      equ     $14     ; Division by zero (/0)
  75+ 18E6              ID      equ     $16     ; Illegal direct
  76+ 18E6              TM      equ     $18     ; Type mis-match
  77+ 18E6              OS      equ     $1A     ; Out of string space
  78+ 18E6              LS      equ     $1C     ; String too long
  79+ 18E6              ST      equ     $1E     ; String formula too complex
  80+ 18E6              CN      equ     $20     ; Can't continue
  81+ 18E6              UF      equ     $22     ; Undefined FN function
  82+ 18E6              MO      equ     $24     ; Missing operand
  83+ 18E6              HX      equ     $26     ; HEX error
  84+ 18E6              BN      equ     $28     ; BIN error
  85+ 18E6              GM      equ     $2A     ; No Graphics Mode
  86+ 18E6              SC      equ     $2C     ; Serial configuration
  87+ 18E6              SA      equ     $2E     ; Serial port already open
  88+ 18E6              SO      equ     $30     ; Serial buffer overrun
  89+ 18E6              HP      equ     $32     ; HELP call
  90+ 18E6              IM      equ     $34     ; Illegal indirect
  91+ 18E6              NR      equ     $36     ; Device not ready
  92+ 18E6              D0      equ     $38     ; DOS not enabled
  93+ 18E6              D1      equ     $3A     ; Disk/File name error
  94+ 18E6              D2      equ     $3C     ; Disk geometry error
  95+ 18E6              D3      equ     $3E     ; Save error
  96+ 18E6              D4      equ     $40     ; Load error
  97+ 18E6              D5      equ     $42     ; Disk full error
  98+ 18E6              D6      equ     $44     ; Duplicate file name error
  99+ 18E6              D7      equ     $46     ; DOS version error
 100+ 18E6              D8      equ     $48     ; File not found error
 101+ 18E6
 102+ 18E6
 103+ 18E6              ; BASIC ERROR POINTER TABLE
 104+ 18E6              ERRTBL: equ $
 105+ 18E6 30 19        NFPTR:  defw    NFMSG
 106+ 18E8 41 19        SNPTR:  defw    SNMSG
 107+ 18EA 48 19        RGPTR:  defw    RGMSG
 108+ 18EC 5D 19        ODPTR:  defw    ODMSG
 109+ 18EE 69 19        FCPTR:  defw    FCMSG
 110+ 18F0 7F 19        OVPTR:  defw    OVMSG
 111+ 18F2 88 19        OMPTR:  defw    OMMSG
 112+ 18F4 96 19        ULPTR:  defw    ULMSG
 113+ 18F6 A5 19        BSPTR:  defw    BSMSG
 114+ 18F8 B3 19        DDPTR:  defw    DDMSG
 115+ 18FA C8 19        DZPTR:  defw    DZMSG
 116+ 18FC D9 19        IDPTR:  defw    IDMSG
 117+ 18FE ED 19        TMPTR:  defw    TMMSG
 118+ 1900 FC 19        OSPTR:  defw    OSMSG
 119+ 1902 10 1A        LSPTR:  defw    LSMSG
 120+ 1904 20 1A        STPTR:  defw    STMSG
 121+ 1906 3B 1A        CNPTR:  defw    CNMSG
 122+ 1908 4A 1A        UFPTR:  defw    UFMSG
 123+ 190A 60 1A        MOPTR:  defw    MOMSG
 124+ 190C 70 1A        HXPTR:  defw    HXMSG
 125+ 190E 7B 1A        BNPTR:  defw    BNMSG
 126+ 1910 86 1A        GMPRT:  defw    GMMSG
 127+ 1912 97 1A        SCPTR:  defw    SCMSG
 128+ 1914 AC 1A        SAPTR:  defw    SAMSG
 129+ 1916 C5 1A        SOPTR:  defw    SOMSG
 130+ 1918 DB 1A        HPPTR:  defw    HPMSG
 131+ 191A E5 1A        IMPRT:  defw    IMMSG
 132+ 191C FB 1A        NRPRT:  defw    NRMSG
 133+ 191E 0C 1B        D0PTR:  defw    D0MSG
 134+ 1920 1C 1B        D1PRT:  defw    D1MSG
 135+ 1922 28 1B        D2PRT:  defw    D2MSG
 136+ 1924 36 1B        D3PRT:  defw    D3MSG
 137+ 1926 3B 1B        D4PTR:  defw    D4MSG
 138+ 1928 40 1B        D5PTR:  defw    D5MSG
 139+ 192A 4A 1B        D6PTR:  defw    D6MSG
 140+ 192C 5E 1B        D7PRT:  defw    D7MSG
 141+ 192E 6A 1B        D8PTR:  defw    D8MSG
 142+ 1930
 143+ 1930
 144+ 1930              ; BASIC ERROR MESSAGE LIST
 145+ 1930              ERRORS  equ $
 146+ 1930 4E 45 58 54  NFMSG:  defb    "NEXT Without FOR",0
 146+ 1934 20 57 69 74
 146+ 1938 68 6F 75 74
 146+ 193C 20 46 4F 52
 146+ 1940 00
 147+ 1941 53 79 6E 74  SNMSG:  defb    "Syntax",0
 147+ 1945 61 78 00
 148+ 1948 52 45 54 55  RGMSG:  defb    "RETURN without GOSUB",0
 148+ 194C 52 4E 20 77
 148+ 1950 69 74 68 6F
 148+ 1954 75 74 20 47
 148+ 1958 4F 53 55 42
 148+ 195C 00
 149+ 195D 4F 75 74 20  ODMSG:  defb    "Out of DATA",0
 149+ 1961 6F 66 20 44
 149+ 1965 41 54 41 00
 150+ 1969 49 6C 6C 65  FCMSG:  defb    "Illegal Function Call",0
 150+ 196D 67 61 6C 20
 150+ 1971 46 75 6E 63
 150+ 1975 74 69 6F 6E
 150+ 1979 20 43 61 6C
 150+ 197D 6C 00
 151+ 197F 4F 76 65 72  OVMSG:  defb    "Overflow",0
 151+ 1983 66 6C 6F 77
 151+ 1987 00
 152+ 1988 4F 75 74 20  OMMSG:  defb    "Out of Memory",0
 152+ 198C 6F 66 20 4D
 152+ 1990 65 6D 6F 72
 152+ 1994 79 00
 153+ 1996 55 6E 64 65  ULMSG:  defb    "Undefined Line",0
 153+ 199A 66 69 6E 65
 153+ 199E 64 20 4C 69
 153+ 19A2 6E 65 00
 154+ 19A5 42 61 64 20  BSMSG:  defb    "Bad Subscript",0
 154+ 19A9 53 75 62 73
 154+ 19AD 63 72 69 70
 154+ 19B1 74 00
 155+ 19B3 52 65 2D 44  DDMSG:  defb    "Re-Dimensioned Array",0
 155+ 19B7 69 6D 65 6E
 155+ 19BB 73 69 6F 6E
 155+ 19BF 65 64 20 41
 155+ 19C3 72 72 61 79
 155+ 19C7 00
 156+ 19C8 44 69 76 69  DZMSG:  defb    "Division by Zero",0
 156+ 19CC 73 69 6F 6E
 156+ 19D0 20 62 79 20
 156+ 19D4 5A 65 72 6F
 156+ 19D8 00
 157+ 19D9 49 6C 6C 65  IDMSG:  defb    "Illegal Direct Mode",0
 157+ 19DD 67 61 6C 20
 157+ 19E1 44 69 72 65
 157+ 19E5 63 74 20 4D
 157+ 19E9 6F 64 65 00
 158+ 19ED 54 79 70 65  TMMSG:  defb    "Type Mis-match",0
 158+ 19F1 20 4D 69 73
 158+ 19F5 2D 6D 61 74
 158+ 19F9 63 68 00
 159+ 19FC 4F 75 74 20  OSMSG:  defb    "Out of String Space",0
 159+ 1A00 6F 66 20 53
 159+ 1A04 74 72 69 6E
 159+ 1A08 67 20 53 70
 159+ 1A0C 61 63 65 00
 160+ 1A10 53 74 72 69  LSMSG:  defb    "String Too Long",0
 160+ 1A14 6E 67 20 54
 160+ 1A18 6F 6F 20 4C
 160+ 1A1C 6F 6E 67 00
 161+ 1A20 53 74 72 69  STMSG:  defb    "String Formula Too Complex",0
 161+ 1A24 6E 67 20 46
 161+ 1A28 6F 72 6D 75
 161+ 1A2C 6C 61 20 54
 161+ 1A30 6F 6F 20 43
 161+ 1A34 6F 6D 70 6C
 161+ 1A38 65 78 00
 162+ 1A3B 43 61 6E 27  CNMSG:  defb    "Can't Continue",0
 162+ 1A3F 74 20 43 6F
 162+ 1A43 6E 74 69 6E
 162+ 1A47 75 65 00
 163+ 1A4A 55 6E 64 65  UFMSG:  defb    "Undefined FN Function",0
 163+ 1A4E 66 69 6E 65
 163+ 1A52 64 20 46 4E
 163+ 1A56 20 46 75 6E
 163+ 1A5A 63 74 69 6F
 163+ 1A5E 6E 00
 164+ 1A60 4D 69 73 73  MOMSG:  defb    "Missing Operand",0
 164+ 1A64 69 6E 67 20
 164+ 1A68 4F 70 65 72
 164+ 1A6C 61 6E 64 00
 165+ 1A70 48 45 58 20  HXMSG:  defb    "HEX Format",0
 165+ 1A74 46 6F 72 6D
 165+ 1A78 61 74 00
 166+ 1A7B 42 49 4E 20  BNMSG:  defb    "BIN Format",0
 166+ 1A7F 46 6F 72 6D
 166+ 1A83 61 74 00
 167+ 1A86 4E 6F 20 47  GMMSG:  defb    "No Graphics Mode",0
 167+ 1A8A 72 61 70 68
 167+ 1A8E 69 63 73 20
 167+ 1A92 4D 6F 64 65
 167+ 1A96 00
 168+ 1A97 53 65 72 69  SCMSG:  defb    "Serial Configuration",0
 168+ 1A9B 61 6C 20 43
 168+ 1A9F 6F 6E 66 69
 168+ 1AA3 67 75 72 61
 168+ 1AA7 74 69 6F 6E
 168+ 1AAB 00
 169+ 1AAC 53 65 72 69  SAMSG:  defb    "Serial Port Already Open",0
 169+ 1AB0 61 6C 20 50
 169+ 1AB4 6F 72 74 20
 169+ 1AB8 41 6C 72 65
 169+ 1ABC 61 64 79 20
 169+ 1AC0 4F 70 65 6E
 169+ 1AC4 00
 170+ 1AC5 53 65 72 69  SOMSG:  defb    "Serial Buffer Overrun",0
 170+ 1AC9 61 6C 20 42
 170+ 1ACD 75 66 66 65
 170+ 1AD1 72 20 4F 76
 170+ 1AD5 65 72 72 75
 170+ 1AD9 6E 00
 171+ 1ADB 48 45 4C 50  HPMSG:  defb    "HELP Call",0
 171+ 1ADF 20 43 61 6C
 171+ 1AE3 6C 00
 172+ 1AE5 49 6C 6C 65  IMMSG:  defb    "Illegal Indirect Mode",0
 172+ 1AE9 67 61 6C 20
 172+ 1AED 49 6E 64 69
 172+ 1AF1 72 65 63 74
 172+ 1AF5 20 4D 6F 64
 172+ 1AF9 65 00
 173+ 1AFB 44 65 76 69  NRMSG:  defb    "Device Not Ready",0
 173+ 1AFF 63 65 20 4E
 173+ 1B03 6F 74 20 52
 173+ 1B07 65 61 64 79
 173+ 1B0B 00
 174+ 1B0C 44 4F 53 20  D0MSG:  defb    "DOS Not Enabled",0
 174+ 1B10 4E 6F 74 20
 174+ 1B14 45 6E 61 62
 174+ 1B18 6C 65 64 00
 175+ 1B1C 4E 61 6D 65  D1MSG:  defb    "Name String",0
 175+ 1B20 20 53 74 72
 175+ 1B24 69 6E 67 00
 176+ 1B28 44 69 73 6B  D2MSG:  defb    "Disk Geometry",0
 176+ 1B2C 20 47 65 6F
 176+ 1B30 6D 65 74 72
 176+ 1B34 79 00
 177+ 1B36 53 61 76 65  D3MSG:  defb    "Save",0
 177+ 1B3A 00
 178+ 1B3B 4C 6F 61 64  D4MSG:  defb    "Load",0
 178+ 1B3F 00
 179+ 1B40 44 69 73 6B  D5MSG:  defb    "Disk Full",0
 179+ 1B44 20 46 75 6C
 179+ 1B48 6C 00
 180+ 1B4A 44 75 70 6C  D6MSG:  defb    "Duplicate File Name",0
 180+ 1B4E 69 63 61 74
 180+ 1B52 65 20 46 69
 180+ 1B56 6C 65 20 4E
 180+ 1B5A 61 6D 65 00
 181+ 1B5E 44 4F 53 20  D7MSG:  defb    "DOS Version",0
 181+ 1B62 56 65 72 73
 181+ 1B66 69 6F 6E 00
 182+ 1B6A 46 69 6C 65  D8MSG:  defb    "File Not Found",0
 182+ 1B6E 20 4E 6F 74
 182+ 1B72 20 46 6F 75
 182+ 1B76 6E 64 00
 183+ 1B79
 184+ 1B79
 185+ 1B79              ;-----------------------------------------------------------------------------
 186+ 1B79              ; STARTING POINTS FOR BASIC BOOT
 187+ 1B79              ; COLD: reset every memory pointer, acting as a power-up boot
 188+ 1B79              ; WARM: preserve program in memory, keeping every current pointer
 189+ 1B79
 190+ 1B79 C3 7F 1B     COLD:   jp      STARTB          ; Jump for cold start
 191+ 1B7C C3 47 1C     WARM:   jp      WARMST          ; Jump for warm start
 192+ 1B7F
 193+ 1B7F C3 86 1B     STARTB: jp      CSTART          ; Jump to initialise
 194+ 1B82 9D 26                defw    DEINT           ; Get integer -32768 to 32767
 195+ 1B84 62 2E                defw    ABPASS          ; Return integer in AB
 196+ 1B86 21 D3 5F     CSTART: ld      HL,WRKSPC       ; Start of workspace RAM
 197+ 1B89 F9                   ld      SP,HL           ; Set up a temporary stack
 198+ 1B8A C3 26 4D             jp      INITST          ; Go to initialise
 199+ 1B8D
 200+ 1B8D 21 37 1F     SYSINIT:ld      HL,INITAB       ; Initialise workspace
 201+ 1B90 01 DC 00             ld      BC,INITBE-INITAB+3; Bytes to copy
 202+ 1B93 11 D3 5F             ld      DE,WRKSPC       ; Into workspace RAM
 203+ 1B96 ED B0                ldir                    ; Copy data
 204+ 1B98 EB                   ex      DE,HL           ; Copy DE into HL
 205+ 1B99 F9                   ld      SP,HL           ; Temporary stack
 206+ 1B9A CD 00 22             call    CLREG           ; Clear registers and stack
 207+ 1B9D CD B4 28             call    PRNTCRLF        ; Output CRLF
 208+ 1BA0 32 06 61             ld      (BUFFER+88+1),A ; Mark end of buffer
 209+ 1BA3 32 E4 61             ld      (PROGST),A      ; Initialise program area
 210+ 1BA6 18 13                jr      MNOASK          ; usually, don't ask for memory top (only when there are errors)
 211+ 1BA8 21 CB 1C     MSIZE:  ld      HL,MEMMSG       ; Point to message
 212+ 1BAB CD 80 2F             call    PRS             ; Output "Memory size"
 213+ 1BAE CD 1D 22             call    PROMPT          ; Get input with '?'
 214+ 1BB1 CD 23 09             call    CURSOR_ON       ; enable cursor
 215+ 1BB4 CD E7 25             call    GETCHR          ; Get next character
 216+ 1BB7 B7                   or      A               ; Set flags
 217+ 1BB8 C2 D0 1B             jp      NZ,TSTMEM       ; If number - Test if RAM there
 218+ 1BBB 21 48 62     MNOASK: ld      HL,STLOOK       ; Point to start of RAM
 219+ 1BBE 23           MLOOP:  inc     HL              ; Next byte
 220+ 1BBF 7C                   ld      A,H             ; Above address FFFF ?
 221+ 1BC0 B5                   or      L
 222+ 1BC1 CA E2 1B             jp      Z,SETTOP        ; Yes - 64K RAM
 223+ 1BC4 7E                   ld      A,(HL)          ; Get contents
 224+ 1BC5 47                   ld      B,A             ; Save it
 225+ 1BC6 2F                   cpl                     ; Flip all bits
 226+ 1BC7 77                   ld      (HL),A          ; Put it back
 227+ 1BC8 BE                   cp      (HL)            ; RAM there if same
 228+ 1BC9 70                   ld      (HL),B          ; Restore old contents
 229+ 1BCA CA BE 1B             jp      Z,MLOOP         ; If RAM - test next byte
 230+ 1BCD C3 E2 1B             jp      SETTOP          ; Top of RAM found
 231+ 1BD0
 232+ 1BD0 CD B7 26     TSTMEM: call    ATOH            ; Get high memory into DE
 233+ 1BD3 B7                   or      A               ; Set flags on last byte
 234+ 1BD4 C2 9E 20             jp      NZ,SNERR        ; ?SN Error if bad character
 235+ 1BD7 EB                   ex      DE,HL           ; Address into HL
 236+ 1BD8 2B                   dec     HL              ; Back one byte
 237+ 1BD9 3E D9                ld      A,%11011001     ; Test byte
 238+ 1BDB 46                   ld      B,(HL)          ; Get old contents
 239+ 1BDC 77                   ld      (HL),A          ; Load test byte
 240+ 1BDD BE                   cp      (HL)            ; RAM there if same
 241+ 1BDE 70                   ld      (HL),B          ; Restore old contents
 242+ 1BDF C2 A8 1B             jp      NZ,MSIZE        ; Ask again if no RAM
 243+ 1BE2
 244+ 1BE2 CD 38 09     SETTOP: call    CURSOR_OFF      ; disable cursor
 245+ 1BE5 2B                   dec     HL              ; Back one byte
 246+ 1BE6 11 47 62             ld      DE,STLOOK-1     ; See if enough RAM
 247+ 1BE9 CD 98 23             call    CPDEHL          ; Compare DE with HL
 248+ 1BEC DA A8 1B             jp      C,MSIZE         ; Ask again if not enough RAM
 249+ 1BEF 3A C0 61             ld      A,(DOS_EN)      ; read if the user enabled/disabled DOS while booting
 250+ 1BF2 1F                   rra                     ; is DOS disabled?
 251+ 1BF3 30 12                jr      NC,NODOS        ; yes, so jump over
 252+ 1BF5 11 00 FE             ld      DE,0-512        ; no, so reserve 512 bytes on top of RAM...
 253+ 1BF8 19                   add     HL,DE           ; ...for I/O buffer...
 254+ 1BF9 22 0F 61             ld      (IOBUFF),HL     ; ...and store address
 255+ 1BFC 11 E0 FF             ld      DE,0-32         ; then, reserve 32 bytes...
 256+ 1BFF 19                   add     HL,DE           ; ...for DOS buffer...
 257+ 1C00 22 0D 61             ld      (DOSBFR),HL     ; ...and store address
 258+ 1C03 11 FF FF             ld      DE,0-1          ; then, 1 more byte to go back to preserve...
 259+ 1C06 19                   add     HL,DE           ; ... the 1st byte of buffer
 260+ 1C07 11 9C FF     NODOS:  ld      DE,0-100        ; now, preserve 100 bytes for string space
 261+ 1C0A 22 0B 61             ld      (LSTRAM),HL     ; Save last available RAM
 262+ 1C0D 19                   add     HL,DE           ; Allocate string space
 263+ 1C0E 22 22 60             ld      (STRSPC),HL     ; Save string space
 264+ 1C11 CD DB 21             call    CLRPTR          ; Clear program area
 265+ 1C14 2A 22 60             ld      HL,(STRSPC)     ; Get end of memory
 266+ 1C17 11 EF FF             ld      DE,0-17         ; Offset for free bytes
 267+ 1C1A 19                   add     HL,DE           ; Adjust HL
 268+ 1C1B 11 E4 61             ld      DE,PROGST       ; Start of program text
 269+ 1C1E 7D                   ld      A,L             ; Get LSB
 270+ 1C1F 93                   sub     E               ; Adjust it
 271+ 1C20 6F                   ld      L,A             ; Re-save
 272+ 1C21 7C                   ld      A,H             ; Get MSB
 273+ 1C22 9A                   sbc     A,D             ; Adjust it
 274+ 1C23 67                   ld      H,A             ; Re-save
 275+ 1C24 E5                   push    HL              ; Save bytes free
 276+ 1C25 21 6D 1C             ld      HL,SIGNON       ; Sign-on message
 277+ 1C28 CD 80 2F             call    PRS             ; Output string
 278+ 1C2B 3A C0 61             ld      A,(DOS_EN)      ; check if DOS is enabled
 279+ 1C2E B7                   or      A
 280+ 1C2F 28 06                jr      Z,SETTP1        ; no DOS, jump over
 281+ 1C31 21 AE 1C             ld      HL,DOSMSG       ; DOS message
 282+ 1C34 CD 80 2F             call    PRS
 283+ 1C37 21 56 1C     SETTP1: ld      HL,BLNSPC       ; Empty space
 284+ 1C3A CD 80 2F             call    PRS             ; Output string
 285+ 1C3D E1                   pop     HL              ; Get bytes free back
 286+ 1C3E CD 1F 3A             call    PRNTHL          ; Output amount of free memory
 287+ 1C41 21 5F 1C             ld      HL,BFREE        ; " Bytes free" message
 288+ 1C44 CD 80 2F             call    PRS             ; Output string
 289+ 1C47
 290+ 1C47 31 B2 60     WARMST: ld      SP,STACK        ; Temporary stack
 291+ 1C4A CD 00 22     BRKRET: call    CLREG           ; Clear registers and stack
 292+ 1C4D CD 44 47             call    RESFN           ; reset FN keys and auto-repeat
 293+ 1C50 CD 23 09             call    CURSOR_ON       ; enable cursor
 294+ 1C53 C3 FE 20             jp      PRNTOK          ; Go to get command line
 295+ 1C56
 296+ 1C56 20 20 20 20  BLNSPC: defb    "        ",0    ; 8 empty cells to align the "XXXX Bytes free" message
 296+ 1C5A 20 20 20 20
 296+ 1C5E 00
 297+ 1C5F 20 42 79 74  BFREE:  defb    " Bytes free",CR,CR,0
 297+ 1C63 65 73 20 66
 297+ 1C67 72 65 65 0D
 297+ 1C6B 0D 00
 298+ 1C6D
 299+ 1C6D 4C 4D 38 30  SIGNON: defb    "LM80C BASIC 3.23 ",251,"2021 L.Miliani"
 299+ 1C71 43 20 42 41
 299+ 1C75 53 49 43 20
 299+ 1C79 33 2E 32 33
 299+ 1C7D 20 FB 32 30
 299+ 1C81 32 31 20 4C
 299+ 1C85 2E 4D 69 6C
 299+ 1C89 69 61 6E 69
 300+ 1C8D 20 5A 38 30          defb    " Z80 BASIC 4.7  ",251,"1978 Microsoft",CR,0
 300+ 1C91 20 42 41 53
 300+ 1C95 49 43 20 34
 300+ 1C99 2E 37 20 20
 300+ 1C9D FB 31 39 37
 300+ 1CA1 38 20 4D 69
 300+ 1CA5 63 72 6F 73
 300+ 1CA9 6F 66 74 0D
 300+ 1CAD 00
 301+ 1CAE 20 20 20 20  DOSMSG: defb    "     LM80C DOS ","1.03","  Loaded",CR,0
 301+ 1CB2 20 4C 4D 38
 301+ 1CB6 30 43 20 44
 301+ 1CBA 4F 53 20 31
 301+ 1CBE 2E 30 33 20
 301+ 1CC2 20 4C 6F 61
 301+ 1CC6 64 65 64 0D
 301+ 1CCA 00
 302+ 1CCB
 303+ 1CCB 4D 65 6D 6F  MEMMSG: defb    "Memory top",0
 303+ 1CCF 72 79 20 74
 303+ 1CD3 6F 70 00
 304+ 1CD6
 305+ 1CD6              ; The following list reports all the functions supported by the interpreter.
 306+ 1CD6              ; To add a custom function, the user must first insert the reserved word here,
 307+ 1CD6              ; then into the list of the reserved words below, and finally must increment the
 308+ 1CD6              ; ZSGN token value and all the following ones after ZSGN by 1 for every added
 309+ 1CD6              ; function.
 310+ 1CD6
 311+ 1CD6              ; FUNCTION ADDRESS TABLE (this is a sort of offset table)
 312+ 1CD6              ; this list must be coherent with the tokens' functions list. This means that every
 313+ 1CD6              ; entry here must have the corresponding entry in the tokens list.
 314+ 1CD6 94 38        FNCTAB: defw    SGN
 315+ 1CD8 2A 2E                defw    TMR         ; added by Leonardo Miliani
 316+ 1CDA 58 39                defw    INT
 317+ 1CDC AA 38                defw    ABS_        ; '_' necessary to avoid assembler warnings
 318+ 1CDE D9 5F                defw    USR
 319+ 1CE0 40 2E                defw    FRE
 320+ 1CE2 BB 32                defw    INP
 321+ 1CE4 6E 2E                defw    POS
 322+ 1CE6 1E 3B                defw    SQR
 323+ 1CE8 FD 3B                defw    RND
 324+ 1CEA E8 36                defw    LOG
 325+ 1CEC 6C 3B                defw    EXP
 326+ 1CEE 72 3C                defw    COS
 327+ 1CF0 78 3C                defw    SIN
 328+ 1CF2 D9 3C                defw    TAN
 329+ 1CF4 EE 3C                defw    ATN
 330+ 1CF6 97 33                defw    PEEK
 331+ 1CF8 59 3D                defw    DEEK
 332+ 1CFA 9E 33                defw    VPEEK       ; added by Leonardo Miliani
 333+ 1CFC 6D 35                defw    VSTAT       ; added by Leonardo Miliani
 334+ 1CFE 78 35                defw    SSTAT       ; added by Leonardo Miliani
 335+ 1D00 8C 35                defw    INKEY       ; added by Leonardo Miliani
 336+ 1D02 B0 40                defw    POINT       ; added by Leonardo Miliani
 337+ 1D04 52 31                defw    INSTR       ; added by Leonardo Miliani
 338+ 1D06 F2 30                defw    LEN
 339+ 1D08 0A 2F                defw    STR
 340+ 1D0A 82 32                defw    VAL
 341+ 1D0C 01 31                defw    ASC
 342+ 1D0E 12 31                defw    CHR
 343+ 1D10 1A 4C                defw    HEX         ; added by Grant Searle
 344+ 1D12 AB 4C                defw    BIN         ; added by Grant Searle
 345+ 1D14 22 31                defw    LEFT
 346+ 1D16 48 32                defw    RIGHT
 347+ 1D18 52 32                defw    MID
 348+ 1D1A
 349+ 1D1A              ; RESERVED WORD LIST
 350+ 1D1A              ; Here are all the reserved words used by the interpreter
 351+ 1D1A              ; To add custom functions/commands, the user must insert the keyword
 352+ 1D1A              ; in this list, following the schematic
 353+ 1D1A C5 4E 44     WORDS:  defb    'E'+$80,"ND"            ; from here the list contains the COMMANDS
 354+ 1D1D C6 4F 52             defb    'F'+$80,"OR"
 355+ 1D20 CE 45 58 54          defb    'N'+$80,"EXT"
 356+ 1D24 C4 41 54 41          defb    'D'+$80,"ATA"
 357+ 1D28 C9 4E 50 55          defb    'I'+$80,"NPUT"
 357+ 1D2C 54
 358+ 1D2D C4 49 4D             defb    'D'+$80,"IM"
 359+ 1D30 D2 45 41 44          defb    'R'+$80,"EAD"
 360+ 1D34 CC 45 54             defb    'L'+$80,"ET"
 361+ 1D37 C7 4F 54 4F          defb    'G'+$80,"OTO"
 362+ 1D3B D2 55 4E             defb    'R'+$80,"UN"
 363+ 1D3E C9 46                defb    'I'+$80,"F"
 364+ 1D40 D2 45 53 54          defb    'R'+$80,"ESTORE"
 364+ 1D44 4F 52 45
 365+ 1D47 C7 4F 53 55          defb    'G'+$80,"OSUB"
 365+ 1D4B 42
 366+ 1D4C D2 45 54 55          defb    'R'+$80,"ETURN"
 366+ 1D50 52 4E
 367+ 1D52 D2 45 4D             defb    'R'+$80,"EM"            ; original REM
 368+ 1D55 D3 54 4F 50          defb    'S'+$80,"TOP"
 369+ 1D59 CF 55 54             defb    'O'+$80,"UT"
 370+ 1D5C CF 4E                defb    'O'+$80,"N"
 371+ 1D5E C6 49 4C 45          defb    'F'+$80,"ILES"          ; added by Leonardo Miliani
 371+ 1D62 53
 372+ 1D63 C5 52 41 53          defb    'E'+$80,"RASE"          ; added by Leonardo Miliani
 372+ 1D67 45
 373+ 1D68 C4 49 53 4B          defb    'D'+$80,"ISK"           ; added by Leonardo Miliani
 374+ 1D6C D7 41 49 54          defb    'W'+$80,"AIT"
 375+ 1D70 C4 45 46             defb    'D'+$80,"EF"
 376+ 1D73 D0 4F 4B 45          defb    'P'+$80,"OKE"
 377+ 1D77 C4 4F 4B 45          defb    'D'+$80,"OKE"
 378+ 1D7B D6 50 4F 4B          defb    'V'+$80,"POKE"          ; added by Leonardo Miliani
 378+ 1D7F 45
 379+ 1D80 D3 52 45 47          defb    'S'+$80,"REG"           ; added by Leonardo Miliani
 380+ 1D84 D6 52 45 47          defb    'V'+$80,"REG"           ; added by Leonardo Miliani
 381+ 1D88 D3 43 52 45          defb    'S'+$80,"CREEN"         ; changed by Leonardo Miliani
 381+ 1D8C 45 4E
 382+ 1D8E CC 4F 43 41          defb    'L'+$80,"OCATE"         ; added by Leonardo Miliani
 382+ 1D92 54 45
 383+ 1D94 D3 4F 55 4E          defb    'S'+$80,"OUND"          ; added by Leonardo Miliani
 383+ 1D98 44
 384+ 1D99 D6 4F 4C 55          defb    'V'+$80,"OLUME"         ; added by Leonardo Miliani
 384+ 1D9D 4D 45
 385+ 1D9F D0 41 55 53          defb    'P'+$80,"AUSE"          ; added by Leonardo Miliani
 385+ 1DA3 45
 386+ 1DA4 C3 4F 4C 4F          defb    'C'+$80,"OLOR"          ; added by Leonardo Miliani
 386+ 1DA8 52
 387+ 1DA9 D0 4C 4F 54          defb    'P'+$80,"LOT"           ; added by Leonardo Miliani
 388+ 1DAD C4 52 41 57          defb    'D'+$80,"RAW"           ; added by Leonardo Miliani
 389+ 1DB1 C3 49 52 43          defb    'C'+$80,"IRCLE"         ; added by Leonardo Miliani
 389+ 1DB5 4C 45
 390+ 1DB7 D0 41 49 4E          defb    'P'+$80,"AINT"          ; added by Leonardo Miliani
 390+ 1DBB 54
 391+ 1DBC D3 45 52 49          defb    'S'+$80,"ERIAL"         ; added by Leonardo Miliani
 391+ 1DC0 41 4C
 392+ 1DC2 C8 45 4C 50          defb    'H'+$80,"ELP"           ; changed by Leonardo Miliani - was LINES
 393+ 1DC6 C3 4C 53             defb    'C'+$80,"LS"            ; restored command
 394+ 1DC9 CB 45 59             defb    'K'+$80,"EY"            ; added by Leonardo Miliani
 395+ 1DCC CE 4D 49             defb    'N'+$80,"MI"            ; added by Leonardo Miliani
 396+ 1DCF C7 50 52 49          defb    'G'+$80,"PRINT"         ; added by Leonardo Miliani
 396+ 1DD3 4E 54
 397+ 1DD5 D7 49 44 54          defb    'W'+$80,"IDTH"
 397+ 1DD9 48
 398+ 1DDA D3 59 53             defb    'S'+$80,"YS"            ; added by Leonardo Miliani
 399+ 1DDD D2 45 53 45          defb    'R'+$80,"ESET"          ; changed by Leonardo Miliani
 399+ 1DE1 54
 400+ 1DE2 C5 4C 53 45          defb    'E'+$80,"LSE"           ; added by Leonardo Miliani
 401+ 1DE6 D0 52 49 4E          defb    'P'+$80,"RINT"
 401+ 1DEA 54
 402+ 1DEB C3 4F 4E 54          defb    'C'+$80,"ONT"
 403+ 1DEF CC 49 53 54          defb    'L'+$80,"IST"
 404+ 1DF3 C3 4C 45 41          defb    'C'+$80,"LEAR"
 404+ 1DF7 52
 405+ 1DF8 CC 4F 41 44          defb    'L'+$80,"OAD"
 406+ 1DFC D3 41 56 45          defb    'S'+$80,"AVE"
 407+ 1E00 CE 45 57             defb    'N'+$80,"EW"
 408+ 1E03 D4 41 42 28          defb    'T'+$80,"AB("
 409+ 1E07 D4 4F                defb    'T'+$80,"O"
 410+ 1E09 C6 4E                defb    'F'+$80,"N"
 411+ 1E0B D3 50 43 28          defb    'S'+$80,"PC("
 412+ 1E0F D4 48 45 4E          defb    'T'+$80,"HEN"
 413+ 1E13 CE 4F 54             defb    'N'+$80,"OT"
 414+ 1E16 D3 54 45 50          defb    'S'+$80,"TEP"
 415+ 1E1A                      ; from here: operators
 416+ 1E1A AB                   defb    '+'+$80
 417+ 1E1B AD                   defb    '-'+$80
 418+ 1E1C AA                   defb    '*'+$80
 419+ 1E1D AF                   defb    '/'+$80
 420+ 1E1E A5                   defb    '%'+$80
 421+ 1E1F A3                   defb    '#'+$80
 422+ 1E20 DE                   defb    '^'+$80
 423+ 1E21 C1 4E 44             defb    'A'+$80,"ND"
 424+ 1E24 D8 4F 52             defb    'X'+$80,"OR"
 425+ 1E27 CF 52                defb    'O'+$80,"R"
 426+ 1E29 BE                   defb    '>'+$80
 427+ 1E2A BD                   defb    '='+$80
 428+ 1E2B BC                   defb    '<'+$80
 429+ 1E2C
 430+ 1E2C                      ; from here there are the tokens' FUNCTIONS list
 431+ 1E2C                      ; this list must be coherent with the functions list above
 432+ 1E2C D3 47 4E             defb    'S'+$80,"GN"
 433+ 1E2F D4 4D 52             defb    'T'+$80,"MR"            ; added by Leonardo Miliani
 434+ 1E32 C9 4E 54             defb    'I'+$80,"NT"
 435+ 1E35 C1 42 53             defb    'A'+$80,"BS"
 436+ 1E38 D5 53 52             defb    'U'+$80,"SR"
 437+ 1E3B C6 52 45             defb    'F'+$80,"RE"
 438+ 1E3E C9 4E 50             defb    'I'+$80,"NP"
 439+ 1E41 D0 4F 53             defb    'P'+$80,"OS"
 440+ 1E44 D3 51 52             defb    'S'+$80,"QR"
 441+ 1E47 D2 4E 44             defb    'R'+$80,"ND"
 442+ 1E4A CC 4F 47             defb    'L'+$80,"OG"
 443+ 1E4D C5 58 50             defb    'E'+$80,"XP"
 444+ 1E50 C3 4F 53             defb    'C'+$80,"OS"
 445+ 1E53 D3 49 4E             defb    'S'+$80,"IN"
 446+ 1E56 D4 41 4E             defb    'T'+$80,"AN"
 447+ 1E59 C1 54 4E             defb    'A'+$80,"TN"
 448+ 1E5C D0 45 45 4B          defb    'P'+$80,"EEK"
 449+ 1E60 C4 45 45 4B          defb    'D'+$80,"EEK"
 450+ 1E64 D6 50 45 45          defb    'V'+$80,"PEEK"          ; added by Leonardo Miliani
 450+ 1E68 4B
 451+ 1E69 D6 53 54 41          defb    'V'+$80,"STAT"          ; added by Leonardo Miliani
 451+ 1E6D 54
 452+ 1E6E D3 53 54 41          defb    'S'+$80,"STAT"          ; added by Leonardo Miliani
 452+ 1E72 54
 453+ 1E73 C9 4E 4B 45          defb    'I'+$80,"NKEY"          ; added by Leonardo Miliani
 453+ 1E77 59
 454+ 1E78 D0 4F 49 4E          defb    'P'+$80,"OINT"          ; added by Leonardo Miliani
 454+ 1E7C 54
 455+ 1E7D C9 4E 53 54          defb    'I'+$80,"NSTR"          ; added by Leonardo Miliani
 455+ 1E81 52
 456+ 1E82 CC 45 4E             defb    'L'+$80,"EN"
 457+ 1E85 D3 54 52 24          defb    'S'+$80,"TR$"
 458+ 1E89 D6 41 4C             defb    'V'+$80,"AL"
 459+ 1E8C C1 53 43             defb    'A'+$80,"SC"
 460+ 1E8F C3 48 52 24          defb    'C'+$80,"HR$"
 461+ 1E93 C8 45 58 24          defb    'H'+$80,"EX$"           ; added by Grant Searle
 462+ 1E97 C2 49 4E 24          defb    'B'+$80,"IN$"           ; added by Grant Searle
 463+ 1E9B CC 45 46 54          defb    'L'+$80,"EFT$"
 463+ 1E9F 24
 464+ 1EA0 D2 49 47 48          defb    'R'+$80,"IGHT$"
 464+ 1EA4 54 24
 465+ 1EA6 CD 49 44 24          defb    'M'+$80,"ID$"
 466+ 1EAA 80                   defb    $80                     ; End-of-list marker
 467+ 1EAB
 468+ 1EAB              ; KEYWORD ADDRESS TABLE
 469+ 1EAB              ; this list must be coherent with the commands'
 470+ 1EAB              ; tokens list above
 471+ 1EAB 31 26        WORDTB: defw    PEND
 472+ 1EAD 2E 25                defw    FOR
 473+ 1EAF 2D 2A                defw    NEXT
 474+ 1EB1 90 27                defw    DATA
 475+ 1EB3 2A 29                defw    INPUT
 476+ 1EB5 82 2C                defw    DIM
 477+ 1EB7 64 29                defw    READ
 478+ 1EB9 A7 27                defw    LET
 479+ 1EBB 4D 27                defw    GOTO
 480+ 1EBD 28 27                defw    RUN
 481+ 1EBF 1F 28                defw    IF
 482+ 1EC1 F7 25                defw    RESTOR
 483+ 1EC3 3C 27                defw    GOSUB
 484+ 1EC5 6B 27                defw    RETURN
 485+ 1EC7 92 27                defw    REM         ; original REM
 486+ 1EC9 2F 26                defw    STOP
 487+ 1ECB C7 32                defw    POUT
 488+ 1ECD 01 28                defw    ON
 489+ 1ECF 1F 4A                defw    FILES       ; changed by Leonardo Miliani - was NULL
 490+ 1ED1 56 4A                defw    ERASE       ; added by Leonardo Miliani
 491+ 1ED3 B6 4A                defw    DISK        ; added by Leonardo Miliani
 492+ 1ED5 CD 32                defw    WAIT
 493+ 1ED7 76 2E                defw    DEF
 494+ 1ED9 C1 33                defw    POKE
 495+ 1EDB 64 3D                defw    DOKE
 496+ 1EDD C6 33                defw    VPOKE       ; added by Leonardo Miliani
 497+ 1EDF 03 34                defw    SREG        ; added by Leonardo Miliani
 498+ 1EE1 51 35                defw    VREG        ; added by Leonardo Miliani
 499+ 1EE3 9A 3D                defw    SCREEN      ; new behaviour: now it sets up a graphics mode (Leonardo Miliani)
 500+ 1EE5 D1 33                defw    LOCATE      ; added by Leonardo Miliani
 501+ 1EE7 5D 34                defw    SOUND       ; added by Leonardo Miliani
 502+ 1EE9 24 34                defw    VOLUME      ; added by Leonardo Miliani
 503+ 1EEB 7B 3D                defw    PAUSE       ; added by Leonardo Miliani
 504+ 1EED 15 3E                defw    COLOR       ; added by Leonardo Miliani
 505+ 1EEF 03 41                defw    PLOT        ; added by Leonardo Miliani
 506+ 1EF1 96 41                defw    DRAW        ; added by Leonardo Miliani
 507+ 1EF3 CF 42                defw    CIRCLE      ; added by Leonardo Miliani
 508+ 1EF5 C0 3F                defw    PAINT       ; added by Leonardo Miliani
 509+ 1EF7 DA 44                defw    SERIAL      ; added by Leonardo Miliani
 510+ 1EF9 19 47                defw    HELP        ; changed by Leonardo Miliani - was LINES
 511+ 1EFB 3D 3D                defw    CLS
 512+ 1EFD 37 47                defw    KEY         ; added by Leonardo Miliani
 513+ 1EFF 0F 33                defw    NMI         ; added by Leonardo Miliani
 514+ 1F01 D0 3E                defw    GPRINT      ; added by Leonardo Miliani
 515+ 1F03 51 3D                defw    WIDTH
 516+ 1F05 69 33                defw    SYS         ; added by Leonardo Miliani
 517+ 1F07 10 4D                defw    RESET       ; new behaviour: now it resets the system
 518+ 1F09 94 27                defw    REM+2       ; ELSE: added by Leonardo Miliani
 519+ 1F0B 51 28                defw    PRINT
 520+ 1F0D 63 26                defw    CONT
 521+ 1F0F 05 24                defw    LIST
 522+ 1F11 DC 26                defw    CLEAR
 523+ 1F13 AE 48                defw    LOAD        ; re-implemented by Leonardo Miliani (was CLOAD)
 524+ 1F15 51 49                defw    SAVE        ; re-implemented by Leonardo Miliani (was CSAVE)
 525+ 1F17 DA 21                defw    NEW
 526+ 1F19
 527+ 1F19              ; RESERVED WORD TOKEN VALUES
 528+ 1F19              ; if you add a function or command you must increment by 1
 529+ 1F19              ; the values below. Pay attention that you must increment only the
 530+ 1F19              ; values AFTER the position where you entered the function/command word
 531+ 1F19              ; in the "Reserver word list" above. I.E.: VPOKE has been added between
 532+ 1F19              ; DOKE and SCREEN, and since REM is the reserved work listed below
 533+ 1F19              ; that is before the point where VPOKE has been entered, every entry
 534+ 1F19              ; after REM has been incremented.
 535+ 1F19              ; Another example: when TMR has been added, since it's a function, every
 536+ 1F19              ; entry after & included ZSGN must be checked (read below)
 537+ 1F19
 538+ 1F19              ZEND    equ     $80             ; END        <-- from here, there are the commands
 539+ 1F19              ZFOR    equ     $81             ; FOR
 540+ 1F19              ZDATA   equ     $83             ; DATA
 541+ 1F19              ZGOTO   equ     $88             ; GOTO
 542+ 1F19              ZGOSUB  equ     $8C             ; GOSUB
 543+ 1F19              ZREM    equ     $8E             ; REM
 544+ 1F19              ZELSE   equ     $AF             ; ELSE
 545+ 1F19              ZPRINT  equ     $B0             ; PRINT
 546+ 1F19              ZNEW    equ     $B6             ; NEW
 547+ 1F19
 548+ 1F19              ZTAB    equ     $B7             ; TAB
 549+ 1F19              ZTO     equ     $B8             ; TO
 550+ 1F19              ZFN     equ     $B9             ; FN
 551+ 1F19              ZSPC    equ     $BA             ; SPC
 552+ 1F19              ZTHEN   equ     $BB             ; THEN
 553+ 1F19              ZNOT    equ     $BC             ; NOT
 554+ 1F19              ZSTEP   equ     $BD             ; STEP
 555+ 1F19
 556+ 1F19              ZPLUS   equ     $BE             ; +         <-- from here, there are the math operators
 557+ 1F19              ZMINUS  equ     $BF             ; -
 558+ 1F19              ZTIMES  equ     $C0             ; *
 559+ 1F19              ZDIV    equ     $C1             ; /
 560+ 1F19              ZMOD    equ     $C2             ; %
 561+ 1F19              ZDINT   equ     $C3             ; #
 562+ 1F19              ZOR     equ     $C7             ; OR
 563+ 1F19              ZGTR    equ     $C8             ; >
 564+ 1F19              ZEQUAL  equ     $C9             ; M
 565+ 1F19              ZLTH    equ     $CA             ; <
 566+ 1F19
 567+ 1F19              ZSGN    equ     $CB             ; SGN       <-- from here, there are the functions
 568+ 1F19              ZPOINT  equ     $E1             ; ZPOINT    <-- if the user enters a custom function, between
 569+ 1F19                                              ;               SGN and POINT, he/she must increment this pointer by 1
 570+ 1F19              ZINSTR  equ     $E2             ; ZINSTR    <-- same here
 571+ 1F19              ZLEFT   equ     $EA             ; LEFT$     <-- if the user enters a custom function anywhere,
 572+ 1F19                                              ;               he/she must increment this pointer by 1
 573+ 1F19
 574+ 1F19              ; ARITHMETIC PRECEDENCE TABLE
 575+ 1F19              ; in the formulas below, <last> is a number stored into the stack that must be retrieved
 576+ 1F19              ; with POP BC, POP DE; FPREG is a f.p. number store into the RAM register FPREG
 577+ 1F19 79           PRITAB: defb    $79             ; Precedence value
 578+ 1F1A 06 3A                defw    PADD            ; FPREG = <last> + FPREG
 579+ 1F1C
 580+ 1F1C 79                   defb    $79             ; Precedence value
 581+ 1F1D E9 35                defw    PSUB            ; FPREG = <last> - FPREG
 582+ 1F1F
 583+ 1F1F 7C                   defb    $7C             ; Precedence value
 584+ 1F20 27 37                defw    MULT            ; PPREG = <last> * FPREG
 585+ 1F22
 586+ 1F22 7C                   defb    $7C             ; Precedence value
 587+ 1F23 D9 37                defw    DIV             ; FPREG = <last> / FPREG
 588+ 1F25
 589+ 1F25 7C                   defb    $7C             ; Precedence value
 590+ 1F26 84 37                defw    MOD             ; FPREG = INT(<last>)-(INT(FPREG)*INT(<last>/FPREG))
 591+ 1F28
 592+ 1F28 7C                   defb    $7C             ; precedence value
 593+ 1F29 7C 37                defw    DINT            ; FPREG = INT(<last> / FPREG )
 594+ 1F2B
 595+ 1F2B 7F                   defb    $7F             ; Precedence value
 596+ 1F2C 27 3B                defw    POWER           ; FPREG = <last> ^ FPREG
 597+ 1F2E
 598+ 1F2E 50                   defb    $50             ; Precedence value
 599+ 1F2F CB 2B                defw    PAND            ; FPREG = <last> AND FPREG
 600+ 1F31
 601+ 1F31 4A                   defb    $4A             ; Precedence value
 602+ 1F32 D3 2B                defw    PXOR            ; FPREG = <last> XOR FPREG
 603+ 1F34
 604+ 1F34 46                   defb    $46             ; Precedence value
 605+ 1F35 CE 2B                defw    POR             ; FPREG = <last> OR FPREG
 606+ 1F37
 607+ 1F37
 608+ 1F37              ; INITIALISATION TABLE -------------------------------------------------------
 609+ 1F37              ; these values are copied into RAM at startup
 610+ 1F37 C3 47 1C     INITAB: jp      WARMST          ; Warm start jump
 611+ 1F3A ED 45 00             defb    $ED,$45,$00     ; RETN + NOP for default NMI service routine
 612+ 1F3D C3 B2 26             jp      FCERR           ; "USR (X)" jump (Set to Error)
 613+ 1F40 D3 00                out     (0),A           ; "out p,n" skeleton
 614+ 1F42 C9                   ret
 615+ 1F43 D6 00                sub     $00             ; Division support routine
 616+ 1F45 6F                   ld      L,A
 617+ 1F46 7C                   ld      A,H
 618+ 1F47 DE 00                sbc     A,$00
 619+ 1F49 67                   ld      H,A
 620+ 1F4A 78                   ld      A,B
 621+ 1F4B DE 00                sbc     A,$00
 622+ 1F4D 47                   ld      B,A
 623+ 1F4E 3E 00                ld      A,$00
 624+ 1F50 C9                   ret
 625+ 1F51 00 00 00             defb    $00,$00,$00     ; Random number seed table used by RND
 626+ 1F54 35 4A CA 99          defb    $35,$4A,$CA,$99 ;-2.65145E+07
 627+ 1F58 39 1C 76 98          defb    $39,$1C,$76,$98 ; 1.61291E+07
 628+ 1F5C 22 95 B3 98          defb    $22,$95,$B3,$98 ;-1.17691E+07
 629+ 1F60 0A DD 47 98          defb    $0A,$DD,$47,$98 ; 1.30983E+07
 630+ 1F64 53 D1 99 99          defb    $53,$D1,$99,$99 ;-2-01612E+07
 631+ 1F68 0A 1A 9F 98          defb    $0A,$1A,$9F,$98 ;-1.04269E+07
 632+ 1F6C 65 BC CD 98          defb    $65,$BC,$CD,$98 ;-1.34831E+07
 633+ 1F70 D6 77 3E 98          defb    $D6,$77,$3E,$98 ; 1.24825E+07
 634+ 1F74 52 C7 4F 80          defb    $52,$C7,$4F,$80 ; Last random number
 635+ 1F78 DB 00                in      A,($00)         ; INP (x) skeleton
 636+ 1F7A C9                   ret
 637+ 1F7B FF                   defb    $FF             ; Terminal width (255 = no auto CRLF)
 638+ 1F7C 14                   defb    $14             ; Width for commas (at reset, 3 columns, for G1 mode)
 639+ 1F7D 00                   defb    $00             ; No nulls after input bytes
 640+ 1F7E 00                   defb    $00             ; Output enabled (^O off)
 641+ 1F7F 00 00                defw    $00             ; Array load/save check sum
 642+ 1F81 00                   defb    $00             ; Break not by NMI
 643+ 1F82 00                   defb    $00             ; Break flag
 644+ 1F83 C3 1E 23             jp      TTYLIN          ; Input reflection (set to TTY)
 645+ 1F86 48 62                defw    STLOOK          ; Temp string space
 646+ 1F88 FE FF                defw    -2              ; Current line number (cold)
 647+ 1F8A FF FF                defw    -1              ; Current line with errors (no errors)
 648+ 1F8C 40           AUTORP: defb    $40             ; delay for key auto-repeat start
 649+ 1F8D 08                   defb    $08             ; auto-repeat delay
 650+ 1F8E 4C 49 53 54  DEFFNKS:defm    "LIST",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 1
 650+ 1F92 0D 00 00 00
 650+ 1F96 00 00 00 00
 650+ 1F9A 00 00 00 00
 651+ 1F9E 52 55 4E 0D          defm    "RUN",13,0,0,0,0,0,0,0,0,0,0,0,0    ; KEY 2
 651+ 1FA2 00 00 00 00
 651+ 1FA6 00 00 00 00
 651+ 1FAA 00 00 00 00
 652+ 1FAE 53 43 52 45          defm    "SCREEN1",13,0,0,0,0,0,0,0,0        ; KEY 3
 652+ 1FB2 45 4E 31 0D
 652+ 1FB6 00 00 00 00
 652+ 1FBA 00 00 00 00
 653+ 1FBE 43 4F 4C 4F          defm    "COLOR1,15,5",13,0,0,0,0            ; KEY 4
 653+ 1FC2 52 31 2C 31
 653+ 1FC6 35 2C 35 0D
 653+ 1FCA 00 00 00 00
 654+ 1FCE 53 45 52 49          defm    "SERIAL1,38400",13,0,0              ; KEY 5
 654+ 1FD2 41 4C 31 2C
 654+ 1FD6 33 38 34 30
 654+ 1FDA 30 0D 00 00
 655+ 1FDE 53 43 52 45          defm    "SCREEN2",13,0,0,0,0,0,0,0,0        ; KEY 6
 655+ 1FE2 45 4E 32 0D
 655+ 1FE6 00 00 00 00
 655+ 1FEA 00 00 00 00
 656+ 1FEE 43 4F 4E 54          defm    "CONT",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 7
 656+ 1FF2 0D 00 00 00
 656+ 1FF6 00 00 00 00
 656+ 1FFA 00 00 00 00
 657+ 1FFE 48 45 4C 50          defm    "HELP",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 8 (HELP KEY)
 657+ 2002 0D 00 00 00
 657+ 2006 00 00 00 00
 657+ 200A 00 00 00 00
 658+ 200E E5 61                defw    PROGST+1        ; Start of program text
 659+ 2010              INITBE:
 660+ 2010
 661+ 2010              ; END OF INITIALISATION TABLE ---------------------------------------------------
 662+ 2010
 663+ 2010 20 45 72 72  ERRMSG: defb    " Error",0
 663+ 2014 6F 72 00
 664+ 2017 20 69 6E 20  INMSG:  defb    " in ",0
 664+ 201B 00
 665+ 201C              ZERBYT  equ     $-1             ; A zero byte
 666+ 201C 4F 6B 0D 00  OKMSG:  defb    "Ok",CR,0,0
 666+ 2020 00
 667+ 2021 42 72 65 61  BRKMSG: defb    "Break",0
 667+ 2025 6B 00
 668+ 2027
 669+ 2027 21 04 00     BAKSTK: ld      HL,$04          ; Look for "FOR" block with
 670+ 202A 39                   add     HL,SP           ; same index as specified
 671+ 202B 7E           LOKFOR: ld      A,(HL)          ; Get block ID
 672+ 202C 23                   inc     HL              ; Point to index address
 673+ 202D FE 81                cp      ZFOR            ; Is it a "FOR" token
 674+ 202F C0                   ret     NZ              ; No - exit
 675+ 2030 4E                   ld      C,(HL)          ; BC = Address of "FOR" index
 676+ 2031 23                   inc     HL
 677+ 2032 46                   ld      B,(HL)
 678+ 2033 23                   inc     HL              ; Point to sign of STEP
 679+ 2034 E5                   push    HL              ; Save pointer to sign
 680+ 2035 69                   ld      L,C             ; HL = address of "FOR" index
 681+ 2036 60                   ld      H,B
 682+ 2037 7A                   ld      A,D             ; See if an index was specified
 683+ 2038 B3                   or      E               ; DE = 0 if no index specified
 684+ 2039 EB                   ex      DE,HL           ; Specified index into HL
 685+ 203A CA 41 20             jp      Z,INDFND        ; Skip if no index given
 686+ 203D EB                   ex      DE,HL           ; Index back into DE
 687+ 203E CD 98 23             call    CPDEHL          ; Compare index with one given
 688+ 2041 01 0D 00     INDFND: ld      BC,16-3         ; Offset to next block
 689+ 2044 E1                   pop     HL              ; Restore pointer to sign
 690+ 2045 C8                   ret     Z               ; Return if block found
 691+ 2046 09                   add     HL,BC           ; Point to next block
 692+ 2047 C3 2B 20             jp      LOKFOR          ; Keep on looking
 693+ 204A
 694+ 204A CD 64 20     MOVUP:  call    ENFMEM          ; See if enough memory
 695+ 204D C5           MOVSTR: push    BC              ; Save end of source
 696+ 204E E3                   ex      (SP),HL         ; Swap source and dest" end
 697+ 204F C1                   pop     BC              ; Get end of destination
 698+ 2050 CD 98 23     MOVLP:  call    CPDEHL          ; See if list moved
 699+ 2053 7E                   ld      A,(HL)          ; Get byte
 700+ 2054 02                   ld      (BC),A          ; Move it
 701+ 2055 C8                   ret     Z               ; Exit if all done
 702+ 2056 0B                   dec     BC              ; Next byte to move to
 703+ 2057 2B                   dec     HL              ; Next byte to move
 704+ 2058 C3 50 20             jp      MOVLP           ; Loop until all bytes moved
 705+ 205B
 706+ 205B E5           CHKSTK: push    HL              ; Save code string address
 707+ 205C 2A C5 61             ld      HL,(ARREND)     ; Lowest free memory
 708+ 205F 06 00                ld      B,$00           ; BC = Number of levels to test
 709+ 2061 09                   add     HL,BC           ; 2 Bytes for each level
 710+ 2062 09                   add     HL,BC
 711+ 2063 3E                   defb    $3E             ; Skip "push HL"
 712+ 2064 E5           ENFMEM: push    HL              ; Save code string address
 713+ 2065 3E D0                ld      A,$D0           ; LOW -48 ; 48 Bytes minimum RAM
 714+ 2067 95                   sub     L
 715+ 2068 6F                   ld      L,A
 716+ 2069 3E FF                ld      A,$FF           ; HIGH (-48) ; 48 Bytes minimum RAM
 717+ 206B 9C                   sbc     A,H
 718+ 206C DA 73 20             jp      C,OMERR         ; Not enough - ?OM Error
 719+ 206F 67                   ld      H,A
 720+ 2070 39                   add     HL,SP           ; Test if stack is overflowed
 721+ 2071 E1                   pop     HL              ; Restore code string address
 722+ 2072 D8                   ret     C               ; Return if enough memory
 723+ 2073 1E 0C        OMERR:  ld      E,OM            ; ?OM Error
 724+ 2075 C3 B8 20             jp      ERROR
 725+ 2078
 726+ 2078
 727+ 2078              ; if in graphics mode, return to text (called by "NOLIN" and "ERROR")
 728+ 2078 F5           EXITGM: push    AF              ; store AF
 729+ 2079 3A 6D 61             ld      A,(SCR_MODE)    ; check screen mode
 730+ 207C FE 02                cp      $02             ; G2?
 731+ 207E CA 85 20             jp      Z,LDG1          ; yes, back to G1
 732+ 2081 FE 03                cp      $03             ; G3?
 733+ 2083 20 11                jr      NZ,LDG1ND       ; no, so return
 734+ 2085 E5           LDG1:   push    HL              ; store HL
 735+ 2086 D5                   push    DE              ; store DE
 736+ 2087 11 01 00             ld      DE,$0001        ; sprites set to defaults, G1 mode
 737+ 208A F3                   di                      ; disable INTs
 738+ 208B CD D1 03             call    initVDP         ; initialize VDP with mode pointed by E
 739+ 208E FB                   ei                      ; re-enable INTs
 740+ 208F 3E 01                ld      A,$01           ; activate the...
 741+ 2091 32 77 61             ld      (PRNTVIDEO),A   ; ...video buffer...
 742+ 2094 D1                   pop     DE              ; retrieve DE
 743+ 2095 E1                   pop     HL              ; retrieve HL
 744+ 2096 F1           LDG1ND: pop     AF              ; retrieve AF
 745+ 2097 C9                   ret                     ; return to caller
 746+ 2098
 747+ 2098
 748+ 2098 2A 4E 61     DATSNR: ld      HL,(DATLIN)     ; Get line of current DATA item
 749+ 209B 22 24 60             ld      (LINEAT),HL     ; Save as current line
 750+ 209E 1E 02        SNERR:  ld      E,SN            ; ?SN Error
 751+ 20A0 01                   defb    $01             ; Skip "ld E,DZ"
 752+ 20A1 1E 14        DZERR:  ld      E,DZ            ; ?/0 Error
 753+ 20A3 01                   defb    $01             ; Skip "ld E,NF"
 754+ 20A4 1E 00        NFERR:  ld      E,NF            ; ?NF Error
 755+ 20A6 01                   defb    $01             ; Skip "ld E,DD"
 756+ 20A7 1E 12        DDERR:  ld      E,DD            ; ?DD Error
 757+ 20A9 01                   defb    $01             ; Skip "ld E,UF"
 758+ 20AA 1E 22        UFERR:  ld      E,UF            ; ?UF Error
 759+ 20AC 01                   defb    $01             ; Skip "ld E,OV
 760+ 20AD 1E 0A        OVERR:  ld      E,OV            ; ?OV Error
 761+ 20AF 01                   defb    $01             ; Skip "ld E,TM"
 762+ 20B0 1E 18        TMERR:  ld      E,TM            ; ?TM Error
 763+ 20B2 01                   defb    $01             ; Skip next statement
 764+ 20B3 1E 34        IMERR:  ld      E,IM            ; ?Illegal indirect mode error
 765+ 20B5 01                   defb    $01             ; Skip next statement
 766+ 20B6 1E 36        NRERR:  ld      E,NR            ; ?Device not ready error
 767+ 20B8
 768+ 20B8 CD 00 22     ERROR:  call    CLREG           ; Clear registers and stack
 769+ 20BB CD 78 20             call    EXITGM          ; exit from graphic modes
 770+ 20BE 32 1A 60             ld      (CTLOFG),A      ; Enable output (A is 0)
 771+ 20C1 CD 23 09             call    CURSOR_ON       ; enable cursor
 772+ 20C4 CD A2 28             call    STTLIN          ; Start new line
 773+ 20C7 21 E6 18             ld      HL,ERRTBL       ; Point to error codes
 774+ 20CA 57                   ld      D,A             ; D = 0 (A is 0)
 775+ 20CB 3E 3F                ld      A,'?'
 776+ 20CD CD A9 23             call    OUTC            ; Output '?'
 777+ 20D0 19                   add     HL,DE           ; Offset to correct error code
 778+ 20D1 5E                   ld      E,(HL)          ; load pointer to error message
 779+ 20D2 23                   inc     HL              ; by loading LSB,
 780+ 20D3 56                   ld      D,(HL)          ; then MSB
 781+ 20D4 62 6B                ld      HL,DE           ; load pointer to HL
 782+ 20D6 CD 80 2F             call    PRS             ; Output error message
 783+ 20D9 21 10 20             ld      HL,ERRMSG       ; "Error" message
 784+ 20DC CD 80 2F     ERRIN:  call    PRS             ; Output message
 785+ 20DF 2A 24 60             ld      HL,(LINEAT)     ; Get line of error
 786+ 20E2 11 FE FF             ld      DE,-2           ; Cold start error if -2
 787+ 20E5 CD 98 23             call    CPDEHL          ; See if cold start error
 788+ 20E8 CA 86 1B             jp      Z,CSTART        ; Cold start error - Restart
 789+ 20EB 7C                   ld      A,H             ; Was it a direct error?
 790+ 20EC A5                   and     L               ; Line = -1 if direct error
 791+ 20ED 3C                   inc     A
 792+ 20EE CA F9 20             jp      Z,PTLN          ; Yes, jump over
 793+ 20F1 E5                   push    HL              ; indirect mode - store HL
 794+ 20F2 2A 24 60             ld      HL,(LINEAT)     ; copy current line number
 795+ 20F5 22 26 60             ld      (HLPLN),HL      ; save in HELP line register
 796+ 20F8 E1                   pop     HL              ; retrieve HL
 797+ 20F9 C4 17 3A     PTLN:   call    NZ,LINEIN       ; No - output line of error
 798+ 20FC
 799+ 20FC 3E                   defb    $3E             ; Skip "pop BC"
 800+ 20FD C1           POPNOK: pop     BC              ; Drop address in input buffer
 801+ 20FE
 802+ 20FE              ; run into direct mode: print OK and get command
 803+ 20FE AF           PRNTOK: xor     A               ; Output "Ok" and get command
 804+ 20FF 32 1A 60             ld      (CTLOFG),A      ; Enable output
 805+ 2102 CD A2 28             call    STTLIN          ; Start new line
 806+ 2105 21 1C 20             ld      HL,OKMSG        ; "Ok" message
 807+ 2108 CD 80 2F             call    PRS             ; Output "Ok"
 808+ 210B CD 23 09     GETCMD: call    CURSOR_ON       ; enable cursor
 809+ 210E 3A BD 61             ld      A,(SERIALS_EN)  ; load serial state
 810+ 2111 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
 811+ 2113 CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
 812+ 2116 21 FF FF             ld      HL,-1           ; Flag direct mode
 813+ 2119 22 24 60             ld      (LINEAT),HL     ; Save as current line
 814+ 211C CD 1E 23             call    GETLIN          ; Get an input line
 815+ 211F DA 0B 21             jp      C,GETCMD        ; Get line again if break
 816+ 2122 CD E7 25             call    GETCHR          ; Get first character
 817+ 2125 17                   rla                     ; 8th bit is copied into carry and original carry is copied into bit 0)
 818+ 2126 DA 9E 20             jp      C,SNERR         ; if char >=128 (8th bit set) then raise an error
 819+ 2129 1F                   rra                     ; recover original char and Carry
 820+ 212A 3C                   inc     A               ; Test if end of line
 821+ 212B 3D                   dec     A               ; Without affecting Carry
 822+ 212C CA 0B 21             jp      Z,GETCMD        ; Nothing entered - Get another
 823+ 212F F5                   push    AF              ; Save Carry status
 824+ 2130 3A BD 61             ld      A,(SERIALS_EN)  ; load serial state
 825+ 2133 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
 826+ 2135 CC 8F 01             call    Z,A_RTS_OFF      ; yes, set RTS on
 827+ 2138 CD 38 09             call    CURSOR_OFF      ; cursor disabled
 828+ 213B CD B7 26             call    ATOH            ; Get line number into DE
 829+ 213E D5                   push    DE              ; Save line number
 830+ 213F CD 35 22             call    CRUNCH          ; Tokenise rest of line
 831+ 2142 47                   ld      B,A             ; Length of tokenised line
 832+ 2143 D1                   pop     DE              ; Restore line number
 833+ 2144 F1                   pop     AF              ; Restore Carry
 834+ 2145 D2 C7 25             jp      NC,EXCUTE       ; No line number - Direct mode
 835+ 2148 D5                   push    DE              ; Save line number
 836+ 2149 C5                   push    BC              ; Save length of tokenised line
 837+ 214A AF                   xor     A
 838+ 214B 32 51 61             ld      (LSTBIN),A      ; Clear last byte input
 839+ 214E CD E7 25             call    GETCHR          ; Get next character
 840+ 2151 B7                   or      A               ; Set flags
 841+ 2152 F5                   push    AF              ; And save them
 842+ 2153 CD BA 21             call    SRCHLN          ; Search for line number in DE
 843+ 2156 DA 5F 21             jp      C,LINFND        ; Jump if line found
 844+ 2159 F1                   pop     AF              ; Get status
 845+ 215A F5                   push    AF              ; And re-save
 846+ 215B CA 66 27             jp      Z,ULERR         ; Nothing after number - Error
 847+ 215E B7                   or      A               ; Clear Carry
 848+ 215F C5           LINFND: push    BC              ; Save address of line in prog
 849+ 2160 D2 76 21             jp      NC,INEWLN       ; Line not found - Insert new
 850+ 2163 EB                   ex      DE,HL           ; Next line address in DE
 851+ 2164 2A C1 61             ld      HL,(PROGND)     ; End of program
 852+ 2167 1A           SFTPRG: ld      A,(DE)          ; Shift rest of program down
 853+ 2168 02                   ld      (BC),A
 854+ 2169 03                   inc     BC              ; Next destination
 855+ 216A 13                   inc     DE              ; Next source
 856+ 216B CD 98 23             call    CPDEHL          ; All done?
 857+ 216E C2 67 21             jp      NZ,SFTPRG       ; More to do
 858+ 2171 60                   ld      H,B             ; HL - New end of program
 859+ 2172 69                   ld      L,C
 860+ 2173 22 C1 61             ld      (PROGND),HL     ; Update end of program
 861+ 2176
 862+ 2176 D1           INEWLN: pop     DE              ; Get address of line,
 863+ 2177 F1                   pop     AF              ; Get status
 864+ 2178 CA 9D 21             jp      Z,SETPTR        ; No text - Set up pointers
 865+ 217B 2A C1 61             ld      HL,(PROGND)     ; Get end of program
 866+ 217E E3                   ex      (SP),HL         ; Get length of input line
 867+ 217F C1                   pop     BC              ; End of program to BC
 868+ 2180 09                   add     HL,BC           ; Find new end
 869+ 2181 E5                   push    HL              ; Save new end
 870+ 2182 CD 4A 20             call    MOVUP           ; Make space for line
 871+ 2185 E1                   pop     HL              ; Restore new end
 872+ 2186 22 C1 61             ld      (PROGND),HL     ; Update end of program pointer
 873+ 2189 EB                   ex      DE,HL           ; Get line to move up in HL
 874+ 218A 74                   ld      (HL),H          ; Save MSB
 875+ 218B D1                   pop     DE              ; Get new line number
 876+ 218C 23                   inc     HL              ; Skip pointer
 877+ 218D 23                   inc     HL
 878+ 218E 73                   ld      (HL),E          ; Save LSB of line number
 879+ 218F 23                   inc     HL
 880+ 2190 72                   ld      (HL),D          ; Save MSB of line number
 881+ 2191 23                   inc     HL              ; To first byte in line
 882+ 2192 11 AD 60             ld      DE,BUFFER       ; Copy buffer to program
 883+ 2195 1A           MOVBUF: ld      A,(DE)          ; Get source
 884+ 2196 77                   ld      (HL),A          ; Save destinations
 885+ 2197 23                   inc     HL              ; Next source
 886+ 2198 13                   inc     DE              ; Next destination
 887+ 2199 B7                   or      A               ; Done?
 888+ 219A C2 95 21             jp      NZ,MOVBUF       ; No - Repeat
 889+ 219D CD E6 21     SETPTR: call    RUNFST          ; Set line pointers
 890+ 21A0 23                   inc     HL              ; To LSB of pointer
 891+ 21A1 EB                   ex      DE,HL           ; Address to DE
 892+ 21A2 62           PTRLP:  ld      H,D             ; Address to HL
 893+ 21A3 6B                   ld      L,E
 894+ 21A4 7E                   ld      A,(HL)          ; Get LSB of pointer
 895+ 21A5 23                   inc     HL              ; To MSB of pointer
 896+ 21A6 B6                   or      (HL)            ; Compare with MSB pointer
 897+ 21A7 CA 0B 21             jp      Z,GETCMD        ; Get command line if end
 898+ 21AA 23                   inc     HL              ; To LSB of line number
 899+ 21AB 23                   inc     HL              ; Skip line number
 900+ 21AC 23                   inc     HL              ; Point to first byte in line
 901+ 21AD AF                   xor     A               ; Looking for 00 byte
 902+ 21AE BE           FNDEND: cp      (HL)            ; Found end of line?
 903+ 21AF 23                   inc     HL              ; Move to next byte
 904+ 21B0 C2 AE 21             jp      NZ,FNDEND       ; No - Keep looking
 905+ 21B3 EB                   ex      DE,HL           ; Next line address to HL
 906+ 21B4 73                   ld      (HL),E          ; Save LSB of pointer
 907+ 21B5 23                   inc     HL
 908+ 21B6 72                   ld      (HL),D          ; Save MSB of pointer
 909+ 21B7 C3 A2 21             jp      PTRLP           ; Do next line
 910+ 21BA
 911+ 21BA 2A AA 60     SRCHLN: ld      HL,(BASTXT)     ; Start of program text
 912+ 21BD 44           SRCHLP: ld      B,H             ; BC = Address to look at
 913+ 21BE 4D                   ld      C,L
 914+ 21BF 7E                   ld      A,(HL)          ; Get address of next line
 915+ 21C0 23                   inc     HL
 916+ 21C1 B6                   or      (HL)            ; End of program found?
 917+ 21C2 2B                   dec     HL
 918+ 21C3 C8                   ret     Z               ; Yes - Line not found
 919+ 21C4 23                   inc     HL
 920+ 21C5 23                   inc     HL
 921+ 21C6 7E                   ld      A,(HL)          ; Get LSB of line number
 922+ 21C7 23                   inc     HL
 923+ 21C8 66                   ld      H,(HL)          ; Get MSB of line number
 924+ 21C9 6F                   ld      L,A
 925+ 21CA CD 98 23             call    CPDEHL          ; Compare with line in DE
 926+ 21CD 60                   ld      H,B             ; HL = Start of this line
 927+ 21CE 69                   ld      L,C
 928+ 21CF 7E                   ld      A,(HL)          ; Get LSB of next line address
 929+ 21D0 23                   inc     HL
 930+ 21D1 66                   ld      H,(HL)          ; Get MSB of next line address
 931+ 21D2 6F                   ld      L,A             ; Next line to HL
 932+ 21D3 3F                   ccf
 933+ 21D4 C8                   ret     Z               ; Lines found - Exit
 934+ 21D5 3F                   ccf
 935+ 21D6 D0                   ret     NC              ; Line not found,at line after
 936+ 21D7 C3 BD 21             jp      SRCHLP          ; Keep looking
 937+ 21DA
 938+ 21DA C0           NEW:    ret     NZ              ; Return if any more on line
 939+ 21DB 2A AA 60     CLRPTR: ld      HL,(BASTXT)     ; Point to start of program
 940+ 21DE AF                   xor     A               ; Set program area to empty
 941+ 21DF 77                   ld      (HL),A          ; Save LSB = 00
 942+ 21E0 23                   inc     HL
 943+ 21E1 77                   ld      (HL),A          ; Save MSB = 00
 944+ 21E2 23                   inc     HL
 945+ 21E3 22 C1 61             ld      (PROGND),HL     ; Set program end
 946+ 21E6
 947+ 21E6 2A AA 60     RUNFST: ld      HL,(BASTXT)     ; Clear all variables
 948+ 21E9 2B                   dec     HL
 949+ 21EA
 950+ 21EA 22 53 61     INTVAR: ld      (BRKLIN),HL     ; Initialise RUN variables
 951+ 21ED 2A 0B 61             ld      HL,(LSTRAM)     ; Get end of RAM
 952+ 21F0 22 48 61             ld      (STRBOT),HL     ; Clear string space
 953+ 21F3 AF                   xor     A
 954+ 21F4 CD F7 25             call    RESTOR          ; Reset DATA pointers
 955+ 21F7 2A C1 61             ld      HL,(PROGND)     ; Get end of program
 956+ 21FA 22 C3 61             ld      (VAREND),HL     ; Clear variables
 957+ 21FD 22 C5 61             ld      (ARREND),HL     ; Clear arrays
 958+ 2200
 959+ 2200 C1           CLREG:  pop     BC              ; Save return address
 960+ 2201 2A 22 60             ld      HL,(STRSPC)     ; Get end of working RAM
 961+ 2204 F9                   ld      SP,HL           ; Set stack
 962+ 2205 21 38 61             ld      HL,TMSTPL       ; Temporary string pool
 963+ 2208 22 36 61             ld      (TMSTPT),HL     ; Reset temporary string ptr
 964+ 220B AF                   xor     A               ; A = 00
 965+ 220C 6F                   ld      L,A             ; HL = 0000
 966+ 220D 67                   ld      H,A
 967+ 220E 22 59 61             ld      (CONTAD),HL     ; No CONTinue
 968+ 2211 32 50 61             ld      (FORFLG),A      ; Clear FOR flag
 969+ 2214 22 C9 61             ld      (FNRGNM),HL     ; Clear FN argument
 970+ 2217 E5                   push    HL              ; HL = 0000
 971+ 2218 C5                   push    BC              ; Put back return
 972+ 2219 2A 53 61     DOAGN:  ld      HL,(BRKLIN)     ; Get address of code to RUN
 973+ 221C C9                   ret                     ; Return to execution driver
 974+ 221D
 975+ 221D 3E 3F        PROMPT: ld      A,'?'           ; '?'
 976+ 221F CD A9 23             call    OUTC            ; Output character
 977+ 2222 3E 00                ld      A,NLLCR         ; null char
 978+ 2224 CD A9 23             call    OUTC            ; Output character
 979+ 2227 CD 23 09             call    CURSOR_ON       ; enable cursor
 980+ 222A 3A BD 61             ld      A,(SERIALS_EN)  ; load serial state
 981+ 222D EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
 982+ 222F CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
 983+ 2232 C3 1F 60             jp      RINPUT          ; Get input line
 984+ 2235
 985+ 2235 AF           CRUNCH: xor     A               ; Tokenise line @ HL to BUFFER
 986+ 2236 32 0A 61             ld      (DATFLG),A      ; Reset literal flag
 987+ 2239 0E 05                ld      C,2+3           ; 2 byte number and 3 nulls
 988+ 223B 11 AD 60             ld      DE,BUFFER       ; Start of input buffer
 989+ 223E 7E           CRNCLP: ld      A,(HL)          ; Get byte
 990+ 223F FE 20                cp      SPC             ; Is it a space?
 991+ 2241 CA BD 22             jp      Z,MOVDIR        ; Yes - Copy direct
 992+ 2244 47                   ld      B,A             ; Save character
 993+ 2245 FE 22                cp      $22             ; '"'             ; Is it a quote?
 994+ 2247 CA DD 22             jp      Z,CPYLIT        ; Yes - Copy literal string
 995+ 224A B7                   or      A               ; Is it end of buffer?
 996+ 224B CA E4 22             jp      Z,ENDBUF        ; Yes - End buffer
 997+ 224E 3A 0A 61             ld      A,(DATFLG)      ; Get data type
 998+ 2251 B7                   or      A               ; Literal?
 999+ 2252 7E                   ld      A,(HL)          ; Get byte to copy
1000+ 2253 C2 BD 22             jp      NZ,MOVDIR       ; Literal - Copy direct
1001+ 2256 FE 3F                cp      '?'             ; Is it '?' short for PRINT
1002+ 2258 3E B0                ld      A,ZPRINT        ; "PRINT" token
1003+ 225A CA BD 22             jp      Z,MOVDIR        ; Yes - replace it
1004+ 225D 7E                   ld      A,(HL)          ; Get byte again
1005+ 225E FE 30                cp      '0'             ; Is it less than '0'
1006+ 2260 DA 68 22             jp      C,FNDWRD        ; Yes - Look for reserved words
1007+ 2263 FE 3C                cp      $3C  ;60; ";"+1       ; Is it "0123456789:;" ?
1008+ 2265 DA BD 22             jp      C,MOVDIR        ; Yes - copy it direct
1009+ 2268 D5           FNDWRD: push    DE              ; Look for reserved words
1010+ 2269 11 19 1D             ld      DE,WORDS-1      ; Point to table
1011+ 226C C5                   push    BC              ; Save count
1012+ 226D 01 B9 22             ld      BC,RETNAD       ; Where to return to
1013+ 2270 C5                   push    BC              ; Save return address
1014+ 2271 06 7F                ld      B,ZEND-1        ; First token value -1
1015+ 2273 7E                   ld      A,(HL)          ; Get byte
1016+ 2274 FE 61                cp      'a'             ; Less than 'a' ?
1017+ 2276 DA 81 22             jp      C,SEARCH        ; Yes - search for words
1018+ 2279 FE 7B                cp      'z'+1           ; Greater than 'z' ?
1019+ 227B D2 81 22             jp      NC,SEARCH       ; Yes - search for words
1020+ 227E E6 5F                and     %01011111       ; Force upper case
1021+ 2280 77                   ld      (HL),A          ; Replace byte
1022+ 2281 4E           SEARCH: ld      C,(HL)          ; Search for a word
1023+ 2282 EB                   ex      DE,HL
1024+ 2283 23           GETNXT: inc     HL              ; Get next reserved word
1025+ 2284 B6                   or      (HL)            ; Start of word?
1026+ 2285 F2 83 22             jp      P,GETNXT        ; No - move on
1027+ 2288 04                   inc     B               ; Increment token value
1028+ 2289 7E                   ld      A,(HL)          ; Get byte from table
1029+ 228A E6 7F                and     %01111111       ; Strip bit 7
1030+ 228C C8                   ret     Z               ; Return if end of list
1031+ 228D B9                   cp      C               ; Same character as in buffer?
1032+ 228E C2 83 22             jp      NZ,GETNXT       ; No - get next word
1033+ 2291 EB                   ex      DE,HL
1034+ 2292 E5                   push    HL              ; Save start of word
1035+ 2293
1036+ 2293 13           NXTBYT: inc     DE              ; Look through rest of word
1037+ 2294 1A                   ld      A,(DE)          ; Get byte from table
1038+ 2295 B7                   or      A               ; End of word ?
1039+ 2296 FA B5 22             jp      M,MATCH         ; Yes - Match found
1040+ 2299 4F                   ld      C,A             ; Save it
1041+ 229A 78                   ld      A,B             ; Get token value
1042+ 229B FE 88                cp      ZGOTO           ; Is it "GOTO" token ?
1043+ 229D C2 A4 22             jp      NZ,NOSPC        ; No - Don't allow spaces
1044+ 22A0 CD E7 25             call    GETCHR          ; Get next character
1045+ 22A3 2B                   dec     HL              ; Cancel increment from GETCHR
1046+ 22A4 23           NOSPC:  inc     HL              ; Next byte
1047+ 22A5 7E                   ld      A,(HL)          ; Get byte
1048+ 22A6 FE 61                cp      'a'             ; Less than 'a' ?
1049+ 22A8 DA AD 22             jp      C,NOCHNG        ; Yes - don't change
1050+ 22AB E6 5F                and     %01011111       ; Make upper case
1051+ 22AD B9           NOCHNG: cp      C               ; Same as in buffer ?
1052+ 22AE CA 93 22             jp      Z,NXTBYT        ; Yes - keep testing
1053+ 22B1 E1                   pop     HL              ; Get back start of word
1054+ 22B2 C3 81 22             jp      SEARCH          ; Look at next word
1055+ 22B5
1056+ 22B5 48           MATCH:  ld      C,B             ; Word found - Save token value
1057+ 22B6 F1                   pop     AF              ; Throw away return
1058+ 22B7 EB                   ex      DE,HL
1059+ 22B8 C9                   ret                     ; Return to "RETNAD"
1060+ 22B9 EB           RETNAD: ex      DE,HL           ; Get address in string
1061+ 22BA 79                   ld      A,C             ; Get token value
1062+ 22BB C1                   pop     BC              ; Restore buffer length
1063+ 22BC D1                   pop     DE              ; Get destination address
1064+ 22BD 23           MOVDIR: inc     HL              ; Next source in buffer
1065+ 22BE 12                   ld      (DE),A          ; Put byte in buffer
1066+ 22BF 13                   inc     DE              ; Move up buffer
1067+ 22C0 0C                   inc     C               ; Increment length of buffer
1068+ 22C1 D6 3A                sub     ':'             ; End of statement?
1069+ 22C3 CA CB 22             jp      Z,SETLIT        ; Jump if multi-statement line
1070+ 22C6 FE 49                cp      ZDATA-$3A       ; Is it DATA statement ?
1071+ 22C8 C2 CE 22             jp      NZ,TSTREM       ; No - see if REM
1072+ 22CB 32 0A 61     SETLIT: ld      (DATFLG),A      ; Set literal flag
1073+ 22CE D6 54        TSTREM: sub     ZREM-$3A        ; Is it REM?
1074+ 22D0 C2 3E 22             jp      NZ,CRNCLP       ; No - Leave flag
1075+ 22D3 47                   ld      B,A             ; Copy rest of buffer
1076+ 22D4 7E           NXTCHR: ld      A,(HL)          ; Get byte
1077+ 22D5 B7                   or      A               ; End of line ?
1078+ 22D6 CA E4 22             jp      Z,ENDBUF        ; Yes - Terminate buffer
1079+ 22D9 B8                   cp      B               ; End of statement ?
1080+ 22DA CA BD 22             jp      Z,MOVDIR        ; Yes - Get next one
1081+ 22DD 23           CPYLIT: inc     HL              ; Move up source string
1082+ 22DE 12                   ld      (DE),A          ; Save in destination
1083+ 22DF 0C                   inc     C               ; Increment length
1084+ 22E0 13                   inc     DE              ; Move up destination
1085+ 22E1 C3 D4 22             jp      NXTCHR          ; Repeat
1086+ 22E4
1087+ 22E4 21 AC 60     ENDBUF: ld      HL,BUFFER-1     ; Point to start of buffer
1088+ 22E7 12                   ld      (DE),A          ; Mark end of buffer (A = 00)
1089+ 22E8 13                   inc     DE
1090+ 22E9 12                   ld      (DE),A          ; A = 00
1091+ 22EA 13                   inc     DE
1092+ 22EB 12                   ld      (DE),A          ; A = 00
1093+ 22EC C9                   ret
1094+ 22ED
1095+ 22ED 3A 19 60     DODEL:  ld      A,(NULFLG)      ; Get null flag status
1096+ 22F0 B7                   or      A               ; Is it zero?
1097+ 22F1 3E 00                ld      A,$00           ; Zero A - Leave flags
1098+ 22F3 32 19 60             ld      (NULFLG),A      ; Zero null flag
1099+ 22F6 C2 01 23             jp      NZ,ECHDEL       ; Set - Echo it
1100+ 22F9 05                   dec     B               ; Decrement length
1101+ 22FA CA 1E 23             jp      Z,GETLIN        ; Get line again if empty
1102+ 22FD CD A9 23             call    OUTC            ; Output null character
1103+ 2300 3E                   defb    $3E             ; Skip "dec B"
1104+ 2301 05           ECHDEL: dec     B               ; Count bytes in buffer
1105+ 2302 2B                   dec     HL              ; Back space buffer
1106+ 2303 CA 15 23             jp      Z,OTKLN         ; No buffer - Try again
1107+ 2306 7E                   ld      A,(HL)          ; Get deleted byte
1108+ 2307 CD A9 23             call    OUTC            ; Echo it
1109+ 230A C3 27 23             jp      MORINP          ; Get more input
1110+ 230D
1111+ 230D 05           DELCHR: dec     B               ; Count bytes in buffer
1112+ 230E 2B                   dec     HL              ; Back space buffer
1113+ 230F CD A9 23             call    OUTC            ; Output character in A
1114+ 2312 C2 27 23             jp      NZ,MORINP       ; Not end - Get more
1115+ 2315 CD A9 23     OTKLN:  call    OUTC            ; Output character in A
1116+ 2318 CD B4 28     KILIN:  call    PRNTCRLF        ; Output CRLF
1117+ 231B C3 1E 23             jp      TTYLIN          ; Get line again
1118+ 231E
1119+ 231E              GETLIN:
1120+ 231E 21 AD 60     TTYLIN: ld      HL,BUFFER       ; Get a line by character
1121+ 2321 06 01                ld      B,$01           ; Set buffer as empty
1122+ 2323 AF                   xor     A
1123+ 2324 32 19 60             ld      (NULFLG),A      ; Clear null flag
1124+ 2327 CD EA 23     MORINP: call    CLOTST          ; Get character and test ^O
1125+ 232A 4F                   ld      C,A             ; Save character in C
1126+ 232B FE 7F                cp      DEL             ; Delete character?
1127+ 232D CA ED 22             jp      Z,DODEL         ; Yes - Process it
1128+ 2330 3A 19 60             ld      A,(NULFLG)      ; Get null flag
1129+ 2333 B7                   or      A               ; Test null flag status
1130+ 2334 CA 40 23             jp      Z,PROCES        ; Reset - Process character
1131+ 2337 3E 00                ld      A,$00           ; Set a null
1132+ 2339 CD A9 23             call    OUTC            ; Output null
1133+ 233C AF                   xor     A               ; Clear A
1134+ 233D 32 19 60             ld      (NULFLG),A      ; Reset null flag
1135+ 2340 79           PROCES: ld      A,C             ; Get character
1136+ 2341 FE 07                cp      CTRLG           ; Bell?
1137+ 2343 CA 80 23             jp      Z,PUTCTL        ; Yes - Save it
1138+ 2346 FE 03                cp      CTRLC           ; Is it control "C"?
1139+ 2348 CC 75 23             call    Z,GMNCR         ; Yes - exit from graphic mode & Output CRLF
1140+ 234B 37                   scf                     ; Flag break
1141+ 234C C8                   ret     Z               ; Return if control "C"
1142+ 234D FE 0D                cp      CR              ; Is it enter?
1143+ 234F CA AA 28             jp      Z,ENDINP        ; Yes - Terminate input
1144+ 2352 FE 15                cp      CTRLU           ; Is it control "U"?
1145+ 2354 CA 18 23             jp      Z,KILIN         ; Yes - Get another line
1146+ 2357 FE 08                cp      BKSP            ; Is it backspace?
1147+ 2359 CA 0D 23             jp      Z,DELCHR        ; Yes - Delete character
1148+ 235C FE 12                cp      CTRLR           ; Is it control "R"?
1149+ 235E C2 7B 23             jp      NZ,PUTBUF       ; No - Put in buffer
1150+ 2361 C5                   push    BC              ; Save buffer length
1151+ 2362 D5                   push    DE              ; Save DE
1152+ 2363 E5                   push    HL              ; Save buffer address
1153+ 2364 36 00                ld      (HL),$00        ; Mark end of buffer
1154+ 2366 CD 35 4D             call    OUTNCR          ; Output and do CRLF
1155+ 2369 21 AD 60             ld      HL,BUFFER       ; Point to buffer start
1156+ 236C CD 80 2F             call    PRS             ; Output buffer
1157+ 236F E1                   pop     HL              ; Restore buffer address
1158+ 2370 D1                   pop     DE              ; Restore DE
1159+ 2371 C1                   pop     BC              ; Restore buffer length
1160+ 2372 C3 27 23             jp      MORINP          ; Get another character
1161+ 2375 CD 78 20     GMNCR:  call    EXITGM          ; exit from graphic mode
1162+ 2378 C3 B4 28             jp      PRNTCRLF        ; output CRLF
1163+ 237B
1164+ 237B FE 20        PUTBUF: cp      SPC             ; Is it a control code?
1165+ 237D DA 27 23             jp      C,MORINP        ; Yes - Ignore
1166+ 2380 78           PUTCTL: ld      A,B             ; Get number of bytes in buffer
1167+ 2381 FE 59                cp      $58+$01         ; Test for line overflow
1168+ 2383 3E 08                ld      A,BKSP          ; Set a bell
1169+ 2385 D2 92 23             jp      NC,OUTNBS       ; Ring bell if buffer full
1170+ 2388 79                   ld      A,C             ; Get character
1171+ 2389 71                   ld      (HL),C          ; Save in buffer
1172+ 238A 32 51 61             ld      (LSTBIN),A      ; Save last input byte
1173+ 238D 23                   inc     HL              ; Move up buffer
1174+ 238E 04                   inc     B               ; Increment length
1175+ 238F C3 27 23     OUTIT:  jp      MORINP          ; Get another character
1176+ 2392
1177+ 2392 CD A9 23     OUTNBS: call    OUTC            ; Output bell and back over it
1178+ 2395 C3 8F 23             jp      OUTIT           ; get more chars
1179+ 2398
1180+ 2398 7C           CPDEHL: ld      A,H             ; Get H
1181+ 2399 92                   sub     D               ; Compare with D
1182+ 239A C0                   ret     NZ              ; Different - Exit
1183+ 239B 7D                   ld      A,L             ; Get L
1184+ 239C 93                   sub     E               ; Compare with E
1185+ 239D C9                   ret                     ; Return status
1186+ 239E
1187+ 239E 7E           CHKSYN: ld      A,(HL)          ; Check syntax of character
1188+ 239F E3                   ex      (SP),HL         ; Address of test byte
1189+ 23A0 BE                   cp      (HL)            ; Same as in code string?
1190+ 23A1 23                   inc     HL              ; Return address
1191+ 23A2 E3                   ex      (SP),HL         ; Put it back
1192+ 23A3 CA E7 25             jp      Z,GETCHR        ; Yes - Get next character
1193+ 23A6 C3 9E 20             jp      SNERR           ; Different - ?SN Error
1194+ 23A9
1195+ 23A9 F5           OUTC:   push    AF              ; Save character
1196+ 23AA 3A 1A 60             ld      A,(CTLOFG)      ; Get control "O" flag
1197+ 23AD B7                   or      A               ; Is it set?
1198+ 23AE C2 B5 2F             jp      NZ,POPAF        ; Yes - don't output
1199+ 23B1 F1                   pop     AF              ; Restore character
1200+ 23B2 C5                   push    BC              ; Save buffer length
1201+ 23B3 F5                   push    AF              ; Save character
1202+ 23B4 FE 20                cp      SPC             ; Is it a control code?
1203+ 23B6 DA CD 23             jp      C,DINPOS        ; Yes - Don't inc POS(X)
1204+ 23B9 3A 17 60             ld      A,(LWIDTH)      ; Get line width
1205+ 23BC 47                   ld      B,A             ; To B
1206+ 23BD 3A 07 61             ld      A,(CURPOS)      ; Get cursor position
1207+ 23C0 04                   inc     B               ; Width 255?
1208+ 23C1 CA C9 23             jp      Z,INCLEN        ; Yes - No width limit
1209+ 23C4 05                   dec     B               ; Restore width
1210+ 23C5 B8                   cp      B               ; At end of line?
1211+ 23C6 CC B4 28             call    Z,PRNTCRLF      ; Yes - output CRLF
1212+ 23C9 3C           INCLEN: inc     A               ; Move on one character
1213+ 23CA 32 07 61             ld      (CURPOS),A      ; Save new position
1214+ 23CD AF           DINPOS: xor     A
1215+ 23CE 32 B5 61             ld      (KBDNPT),A      ; set flag for no char from keyboard
1216+ 23D1 F1                   pop     AF              ; Restore character
1217+ 23D2 C1                   pop     BC              ; Restore buffer length
1218+ 23D3 F5                   push    AF
1219+ 23D4 CD DC 23             call    SND2VID         ; send char to video
1220+ 23D7 F1                   pop     AF
1221+ 23D8 CD 0D 4D             call    MONOUT          ; send char to serial if enabled
1222+ 23DB C9                   ret
1223+ 23DC
1224+ 23DC              ; print char to video if cursor is on
1225+ 23DC 32 78 61     SND2VID:ld      (CHR4VID),A     ; store A
1226+ 23DF 3A 77 61             ld      A,(PRNTVIDEO)   ; check print-on-video
1227+ 23E2 B7                   or      A               ; is it off?
1228+ 23E3 C8                   ret     Z               ; yes, so return
1229+ 23E4 F3                   di                      ; disable INTs
1230+ 23E5 CD 57 07             call    CHAR2VID        ; cursor is on, so print char on screen
1231+ 23E8 FB                   ei                      ; re-enable INTs
1232+ 23E9 C9                   ret                     ; return to caller
1233+ 23EA
1234+ 23EA CD 3B 3D     CLOTST: call    GETINP          ; Get input character
1235+ 23ED FE 0F                cp      CTRLO           ; Is it control "O"?
1236+ 23EF C0                   ret     NZ              ; No don't flip flag
1237+ 23F0 3A 1A 60             ld      A,(CTLOFG)      ; Get flag
1238+ 23F3 2F                   cpl                     ; Flip it
1239+ 23F4 32 1A 60             ld      (CTLOFG),A      ; Put it back
1240+ 23F7 A7                   and     A               ; is output enabled?
1241+ 23F8 CC 23 09             call    Z,CURSOR_ON     ; yes, so cursor on
1242+ 23FB 3A BD 61             ld      A,(SERIALS_EN)  ; load serial state
1243+ 23FE EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
1244+ 2400 CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
1245+ 2403 AF                   xor     A               ; Null character
1246+ 2404 C9                   ret
1247+ 2405
1248+ 2405              ; LIST: list the program stored into memory
1249+ 2405 C1           LIST:   pop     BC              ; rubbish - not needed (legacy from original call of LIST)
1250+ 2406 2B                   dec     HL              ; dec 'cos GETCHR INCs
1251+ 2407 CD E7 25             call    GETCHR          ; Get next character
1252+ 240A CA 60 24             jp      Z,LSTALL        ; list all if nothing follows
1253+ 240D FE BF                cp      ZMINUS          ; is it '-'?
1254+ 240F 20 20                jr      NZ,LST01        ; no, look for a line number
1255+ 2411 11 00 00             ld      DE,$0000        ; yes, set search from 0
1256+ 2414 CD 01 25             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1257+ 2417 ED 43 7B 61          ld      (TMPBFR1),BC    ; store address of starting line
1258+ 241B CD 9E 23             call    CHKSYN          ; skip '-'
1259+ 241E BF                   defb    ZMINUS
1260+ 241F CD B7 26             call    ATOH            ; now, look for another number (ASCII number to DE)
1261+ 2422 CD 07 25             call    SRCLN           ; find a line, getting the previous if it doesn't exist
1262+ 2425 ED 43 7D 61          ld      (TMPBFR2),BC    ; store address of ending line
1263+ 2429 ED 4B 7B 61          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1264+ 242D C5                   push    BC              ; store address of line for later use
1265+ 242E C3 98 24             jp      LISTLP          ; go listing
1266+ 2431 CD B7 26     LST01:  call    ATOH            ; get a line number (ASCII number to DE)
1267+ 2434 ED 53 81 61  LST01H: ld      (TMPBFR4),DE    ; store ending line address for later use - N.B.: this is a hook for HELP command
1268+ 2438 CD 01 25             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1269+ 243B ED 43 7B 61          ld      (TMPBFR1),BC    ; store address of starting line
1270+ 243F ED 43 7D 61          ld      (TMPBFR2),BC    ; same address for ending line (we'll change it later if needed)
1271+ 2443 2B                   dec     HL              ; dec 'cos GETCHR INCs
1272+ 2444 CD E7 25             call    GETCHR          ; Get next character
1273+ 2447 CA 53 24             jp      Z,LSTNOT        ; nothing follows, so ending & starting lines are the same
1274+ 244A FE BF                cp      ZMINUS          ; is it '-'?
1275+ 244C CA 78 24             jp      Z,LST03         ; yes, read ending line
1276+ 244F C5           LST06:  push    BC              ; store address for later use
1277+ 2450 C3 98 24             jp      LISTLP          ; jump to list
1278+ 2453 ED 5B 81 61  LSTNOT: ld      DE,(TMPBFR4)
1279+ 2457 CD 01 25             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1280+ 245A DA 4F 24             jp      C,LST06
1281+ 245D C3 FE 20             jp      PRNTOK
1282+ 2460 11 F9 FF     LSTALL: ld      DE,65529        ; set ending line to max. allowed line number
1283+ 2463 CD 01 25             call    SRCHLIN         ; get address of last line
1284+ 2466 ED 43 7D 61          ld      (TMPBFR2),BC    ; store it
1285+ 246A 11 00 00             ld      DE,$0000        ; set start to first line in memory
1286+ 246D CD 01 25             call    SRCHLIN         ; get address of first line
1287+ 2470 ED 43 7B 61          ld      (TMPBFR1),BC    ; store it
1288+ 2474 C5                   push    BC              ; store address of starting line for later use
1289+ 2475 C3 98 24             jp      LISTLP          ; start printing
1290+ 2478 CD 9E 23     LST03:  call    CHKSYN          ; skip '-'
1291+ 247B BF                   defb    ZMINUS
1292+ 247C CD B7 26             call    ATOH            ; look for another number (return into DE)
1293+ 247F 7A                   ld      A,D
1294+ 2480 B3                   or      E               ; is line=0?
1295+ 2481 20 09                jr      NZ,LST05        ; no, jump over
1296+ 2483 11 F9 FF             ld      DE,65529        ; yes set last valid line number
1297+ 2486 CD 01 25             call    SRCHLIN         ; get address of last line
1298+ 2489 C3 8F 24             jp      LST02
1299+ 248C CD 07 25     LST05:  call    SRCLN           ; find a line, getting the previous if it doesn't exist
1300+ 248F ED 43 7D 61  LST02:  ld      (TMPBFR2),BC    ; store address of ending line
1301+ 2493 ED 4B 7B 61          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1302+ 2497 C5                   push    BC              ; store it for later use
1303+ 2498 E1           LISTLP: pop     HL              ; Restore address of line
1304+ 2499 4E                   ld      C,(HL)          ; Get LSB of next line
1305+ 249A 23                   inc     HL
1306+ 249B 46                   ld      B,(HL)          ; Get MSB of next line
1307+ 249C 23                   inc     HL
1308+ 249D 78                   ld      A,B             ; BC = 0 (End of program)?
1309+ 249E B1                   or      C
1310+ 249F CA FE 20             jp      Z,PRNTOK        ; Yes - Go to command mode
1311+ 24A2 CD 12 26             call    TSTBRK          ; Test for break key
1312+ 24A5 CD 15 25             call    TSTSPC          ; test for space
1313+ 24A8 C5                   push    BC              ; Save address of next line
1314+ 24A9 3A 70 61             ld      A,(SCR_CURS_X)  ; load current X pos of cursor
1315+ 24AC A7                   and     A               ; is it at the beginning of a new line?
1316+ 24AD 20 0B                jr      NZ,LST08        ; No, jump over
1317+ 24AF 3E 0D                ld      A,CR            ; yes, so just send a CR
1318+ 24B1 CD 0D 4D             call    MONOUT          ; to serial if it's open
1319+ 24B4 AF                   xor     A               ; then, set cursor
1320+ 24B5 32 07 61             ld      (CURPOS),A      ; to position 0
1321+ 24B8 18 03                jr      LST07           ; and continue
1322+ 24BA CD B4 28     LST08:  call    PRNTCRLF        ; output CRLF
1323+ 24BD 5E           LST07:  ld      E,(HL)          ; Get LSB of line number
1324+ 24BE 23                   inc     HL
1325+ 24BF 56                   ld      D,(HL)          ; Get MSB of line number
1326+ 24C0 23                   inc     HL
1327+ 24C1 E5                   push    HL              ; Save address of line start
1328+ 24C2 EB                   ex      DE,HL           ; Line number to HL
1329+ 24C3 CD 1F 3A             call    PRNTHL          ; Output line number in decimal
1330+ 24C6 3E 20                ld      A,SPC           ; Space after line number
1331+ 24C8 E1                   pop     HL              ; Restore start of line address
1332+ 24C9 CD A9 23     LSTLP2: call    OUTC            ; Output character in A
1333+ 24CC 7E           LSTLP3: ld      A,(HL)          ; Get next byte in line
1334+ 24CD B7                   or      A               ; End of line?
1335+ 24CE 23                   inc     HL              ; To next byte in line
1336+ 24CF CA F3 24             jp      Z,NXTLN         ; Yes - check next line
1337+ 24D2 F2 C9 24             jp      P,LSTLP2        ; No token - output it
1338+ 24D5 D6 7F                sub     ZEND-1          ; Find and output word
1339+ 24D7 4F                   ld      C,A             ; Token offset+1 to C
1340+ 24D8 11 1A 1D             ld      DE,WORDS        ; Reserved word list
1341+ 24DB 1A           FNDTOK: ld      A,(DE)          ; Get character in list
1342+ 24DC 13                   inc     DE              ; Move on to next
1343+ 24DD B7                   or      A               ; Is it start of word?
1344+ 24DE F2 DB 24             jp      P,FNDTOK        ; No - Keep looking for word
1345+ 24E1 0D                   dec     C               ; Count words
1346+ 24E2 C2 DB 24             jp      NZ,FNDTOK       ; Not there - keep looking
1347+ 24E5 E6 7F        OUTWRD: and     %01111111       ; Strip bit 7
1348+ 24E7 CD A9 23             call    OUTC            ; Output character
1349+ 24EA 1A                   ld      A,(DE)          ; Get next character
1350+ 24EB 13                   inc     DE              ; Move on to next
1351+ 24EC B7                   or      A               ; Is it end of word?
1352+ 24ED F2 E5 24             jp      P,OUTWRD        ; No - output the rest
1353+ 24F0 C3 CC 24             jp      LSTLP3          ; Next byte in line
1354+ 24F3 D1           NXTLN:  pop     DE              ; recover address of current line
1355+ 24F4 2A 7D 61             ld      HL,(TMPBFR2)    ; address of last line to print
1356+ 24F7 CD 3B 4D             call    CMP16           ; check if current line is over last printable line
1357+ 24FA DA FE 20             jp      C,PRNTOK        ; finish - leave & print OK
1358+ 24FD D5                   push    DE              ; store address of current line
1359+ 24FE C3 98 24             jp      LISTLP          ; continue listing
1360+ 2501              ; look for the address of a program line
1361+ 2501 E5           SRCHLIN:push    HL              ; store HL (this is needed because HL store the pointer to the input buffer)
1362+ 2502 CD BA 21             call    SRCHLN          ; search for line number in DE
1363+ 2505 E1                   pop     HL              ; retrieve HL
1364+ 2506 C9                   ret                     ; return to caller
1365+ 2507              ; look for the address of a program line - if the line isn't found,
1366+ 2507              ; it look backward for the previous line
1367+ 2507 E5           SRCLN:  push    HL              ; store HL
1368+ 2508 CD BA 21     SRCLN1: call    SRCHLN          ; search for line in DE
1369+ 250B DA 13 25             jp      C,LVSRLN        ; found it, leave loop
1370+ 250E 1B                   dec     DE              ; not found, decrement number to look backward for an existing line
1371+ 250F 7B                   ld      A,E
1372+ 2510 B2                   or      D               ; is line number zero?
1373+ 2511 20 F5                jr      NZ,SRCLN1       ; no, continue
1374+ 2513 E1           LVSRLN: pop     HL              ; retrieve HL
1375+ 2514 C9                   ret                     ; return to caller
1376+ 2515
1377+ 2515              ; during LISTing, check if PAUSE is pressed, then pause listing and
1378+ 2515              ; wait for another pressing of PAUSE to continue or CTRL-C/BREAK to exit
1379+ 2515 3A B7 61     TSTSPC: ld      A,(TMPKEYBFR)   ; Get input character
1380+ 2518 FE 20                cp      SPC             ; Is it SPACE?
1381+ 251A C0                   ret     NZ              ; No, return
1382+ 251B CD 3B 3D     WTSPC:  call    GETINP          ; Yes, stop listing and wait for another space or BREAK
1383+ 251E FE 20                cp      SPC             ; is it SPACE?
1384+ 2520 20 05                jr      NZ,CNTWTSP      ; no, continue
1385+ 2522 AF                   xor     A
1386+ 2523 32 B7 61             ld      (TMPKEYBFR),A   ; reset key
1387+ 2526 C9                   ret                     ; return to caller
1388+ 2527 FE 03        CNTWTSP:cp      CTRLC           ; is it CTRL-C/BREAK?
1389+ 2529 20 F0                jr      NZ,WTSPC        ; no, loop
1390+ 252B C3 4A 1C             jp      BRKRET          ; exit and output "Ok"
1391+ 252E
1392+ 252E
1393+ 252E 3E 64        FOR:    ld      A,$64           ; Flag "FOR" assignment
1394+ 2530 32 50 61             ld      (FORFLG),A      ; Save "FOR" flag
1395+ 2533 CD A7 27             call    LET             ; Set up initial index
1396+ 2536 C1                   pop     BC              ; Drop RETurn address
1397+ 2537 E5                   push    HL              ; Save code string address
1398+ 2538 CD 90 27             call    DATA            ; Get next statement address
1399+ 253B 22 4C 61             ld      (LOOPST),HL     ; Save it for start of loop
1400+ 253E 21 02 00             ld      HL,$0002        ; Offset for "FOR" block
1401+ 2541 39                   add     HL,SP           ; Point to it
1402+ 2542 CD 2B 20     FORSLP: call    LOKFOR          ; Look for existing "FOR" block
1403+ 2545 D1                   pop     DE              ; Get code string address
1404+ 2546 C2 5E 25             jp      NZ,FORFND       ; No nesting found
1405+ 2549 09                   add     HL,BC           ; Move into "FOR" block
1406+ 254A D5                   push    DE              ; Save code string address
1407+ 254B 2B                   dec     HL
1408+ 254C 56                   ld      D,(HL)          ; Get MSB of loop statement
1409+ 254D 2B                   dec     HL
1410+ 254E 5E                   ld      E,(HL)          ; Get LSB of loop statement
1411+ 254F 23                   inc     HL
1412+ 2550 23                   inc     HL
1413+ 2551 E5                   push    HL              ; Save block address
1414+ 2552 2A 4C 61             ld      HL,(LOOPST)     ; Get address of loop statement
1415+ 2555 CD 98 23             call    CPDEHL          ; Compare the FOR loops
1416+ 2558 E1                   pop     HL              ; Restore block address
1417+ 2559 C2 42 25             jp      NZ,FORSLP       ; Different FORs - Find another
1418+ 255C D1                   pop     DE              ; Restore code string address
1419+ 255D F9                   ld      SP,HL           ; Remove all nested loops
1420+ 255E
1421+ 255E EB           FORFND: ex      DE,HL           ; Code string address to HL
1422+ 255F 0E 08                ld      C,$08
1423+ 2561 CD 5B 20             call    CHKSTK          ; Check for 8 levels of stack
1424+ 2564 E5                   push    HL              ; Save code string address
1425+ 2565 2A 4C 61             ld      HL,(LOOPST)     ; Get first statement of loop
1426+ 2568 E3                   ex      (SP),HL         ; Save and restore code string
1427+ 2569 E5                   push    HL              ; Re-save code string address
1428+ 256A 2A 24 60             ld      HL,(LINEAT)     ; Get current line number
1429+ 256D E3                   ex      (SP),HL         ; Save and restore code string
1430+ 256E CD 7B 2A             call    TSTNUM          ; Make sure it's a number
1431+ 2571 CD 9E 23             call    CHKSYN          ; Make sure "TO" is next
1432+ 2574 B8                   defb    ZTO             ; "TO" token
1433+ 2575 CD 78 2A             call    GETNUM          ; Get "TO" expression value
1434+ 2578 E5                   push    HL              ; Save code string address
1435+ 2579 CD D1 38             call    BCDEFP          ; Move "TO" value to BCDE
1436+ 257C E1                   pop     HL              ; Restore code string address
1437+ 257D C5                   push    BC              ; Save "TO" value in block
1438+ 257E D5                   push    DE
1439+ 257F 01 00 81             ld      BC,$8100        ; BCDE - 1 (default STEP)
1440+ 2582 51                   ld      D,C             ; C=0
1441+ 2583 5A                   ld      E,D             ; D=0
1442+ 2584 7E                   ld      A,(HL)          ; Get next byte in code string
1443+ 2585 FE BD                cp      ZSTEP           ; See if "STEP" is stated
1444+ 2587 3E 01                ld      A,$01           ; Sign of step = 1
1445+ 2589 C2 9A 25             jp      NZ,SAVSTP       ; No STEP given - Default to 1
1446+ 258C CD E7 25             call    GETCHR          ; Jump over "STEP" token
1447+ 258F CD 78 2A             call    GETNUM          ; Get step value
1448+ 2592 E5                   push    HL              ; Save code string address
1449+ 2593 CD D1 38             call    BCDEFP          ; Move STEP to BCDE
1450+ 2596 CD 85 38             call    TSTSGN          ; Test sign of FPREG
1451+ 2599 E1                   pop     HL              ; Restore code string address
1452+ 259A C5           SAVSTP: push    BC              ; Save the STEP value in block
1453+ 259B D5                   push    DE
1454+ 259C F5                   push    AF              ; Save sign of STEP
1455+ 259D 33                   inc     SP              ; Don't save flags
1456+ 259E E5                   push    HL              ; Save code string address
1457+ 259F 2A 53 61             ld      HL,(BRKLIN)     ; Get address of index variable
1458+ 25A2 E3                   ex      (SP),HL         ; Save and restore code string
1459+ 25A3 06 81        PUTFID: ld      B,ZFOR          ; "FOR" block marker
1460+ 25A5 C5                   push    BC              ; Save it
1461+ 25A6 33                   inc     SP              ; Don't save C
1462+ 25A7
1463+ 25A7 CD 12 26     RUNCNT: call    TSTBRK          ; Execution driver - Test break
1464+ 25AA 22 53 61             ld      (BRKLIN),HL     ; Save code address for break
1465+ 25AD 7E                   ld      A,(HL)          ; Get next byte in code string
1466+ 25AE FE 3A                cp      ':'             ; Multi statement line?
1467+ 25B0 CA C7 25             jp      Z,EXCUTE        ; Yes - Execute it
1468+ 25B3 B7                   or      A               ; End of line?
1469+ 25B4 C2 9E 20             jp      NZ,SNERR        ; No - Syntax error
1470+ 25B7 23                   inc     HL              ; Point to address of next line
1471+ 25B8 7E                   ld      A,(HL)          ; Get LSB of line pointer
1472+ 25B9 23                   inc     HL
1473+ 25BA B6                   or      (HL)            ; Is it zero (End of prog)?
1474+ 25BB CA 39 26             jp      Z,ENDPRG        ; Yes - Terminate execution
1475+ 25BE 23                   inc     HL              ; Point to line number
1476+ 25BF 5E                   ld      E,(HL)          ; Get LSB of line number
1477+ 25C0 23                   inc     HL
1478+ 25C1 56                   ld      D,(HL)          ; Get MSB of line number
1479+ 25C2 EB                   ex      DE,HL           ; Line number to HL
1480+ 25C3 22 24 60             ld      (LINEAT),HL     ; Save as current line number
1481+ 25C6 EB                   ex      DE,HL           ; Line number back to DE
1482+ 25C7 CD E7 25     EXCUTE: call    GETCHR          ; Get key word
1483+ 25CA 11 A7 25             ld      DE,RUNCNT       ; Where to RETurn to
1484+ 25CD D5                   push    DE              ; Save for RETurn
1485+ 25CE C8           IFJMP:  ret     Z               ; Go to RUNCNT if end of STMT
1486+ 25CF
1487+ 25CF D6 80        ONJMP:  sub     ZEND            ; Is it a token?
1488+ 25D1 DA A7 27             jp      C,LET           ; No - try to assign it
1489+ 25D4 FE 37                cp      ZNEW+1-ZEND     ; END to NEW ?
1490+ 25D6 D2 9E 20             jp      NC,SNERR        ; Not a key word - ?SN Error
1491+ 25D9 07                   rlca                    ; Double it
1492+ 25DA 4F                   ld      C,A             ; BC = Offset into table
1493+ 25DB 06 00                ld      B,0
1494+ 25DD EB                   ex      DE,HL           ; Save code string address
1495+ 25DE 21 AB 1E             ld      HL,WORDTB       ; Keyword address table
1496+ 25E1 09                   add     HL,BC           ; Point to routine address
1497+ 25E2 4E                   ld      C,(HL)          ; Get LSB of routine address
1498+ 25E3 23                   inc     HL
1499+ 25E4 46                   ld      B,(HL)          ; Get MSB of routine address
1500+ 25E5 C5                   push    BC              ; Save routine address
1501+ 25E6 EB                   ex      DE,HL           ; Restore code string address
1502+ 25E7
1503+ 25E7              ; get a char from input buffer: exit with NC if character found is
1504+ 25E7              ; not a number; exit with Z if nothing found; char is into A
1505+ 25E7 23           GETCHR: inc     HL              ; Point to next character
1506+ 25E8 7E                   ld      A,(HL)          ; Get next code string byte
1507+ 25E9 FE 3A                cp      ':'             ; Z if ':'
1508+ 25EB D0                   ret     NC              ; NC if > "9"
1509+ 25EC FE 20                cp      SPC
1510+ 25EE CA E7 25             jp      Z,GETCHR        ; Skip over spaces
1511+ 25F1 FE 30                cp      '0'
1512+ 25F3 3F                   ccf                     ; NC if < '0'
1513+ 25F4 3C                   inc     A               ; Test for zero - Leave carry
1514+ 25F5 3D                   dec     A               ; Z if Null
1515+ 25F6 C9                   ret
1516+ 25F7
1517+ 25F7 EB           RESTOR: ex      DE,HL           ; Save code string address
1518+ 25F8 2A AA 60             ld      HL,(BASTXT)     ; Point to start of program
1519+ 25FB CA 0C 26             jp      Z,RESTNL        ; Just RESTORE - reset pointer
1520+ 25FE EB                   ex      DE,HL           ; Restore code string address
1521+ 25FF CD B7 26             call    ATOH            ; Get line number to DE
1522+ 2602 E5                   push    HL              ; Save code string address
1523+ 2603 CD BA 21             call    SRCHLN          ; Search for line number in DE
1524+ 2606 60                   ld      H,B             ; HL = Address of line
1525+ 2607 69                   ld      L,C
1526+ 2608 D1                   pop     DE              ; Restore code string address
1527+ 2609 D2 66 27             jp      NC,ULERR        ; ?UL Error if not found
1528+ 260C 2B           RESTNL: dec     HL              ; Byte before DATA statement
1529+ 260D 22 C7 61     UPDATA: ld      (NXTDAT),HL     ; Update DATA pointer
1530+ 2610 EB                   ex      DE,HL           ; Restore code string address
1531+ 2611 C9                   ret
1532+ 2612
1533+ 2612
1534+ 2612              ; check if CTRL-C is into input buffer
1535+ 2612 DF           TSTBRK: rst     $18             ; Check input status
1536+ 2613 C8                   ret     Z               ; No key, go back
1537+ 2614 D7                   rst     $10             ; Get the key into A
1538+ 2615 FE 1B                cp      ESC             ; Escape key?
1539+ 2617 28 11                jr      Z,BRK           ; Yes, break
1540+ 2619 FE 03                cp      CTRLC           ; <Ctrl-C>
1541+ 261B 28 0D                jr      Z,BRK           ; Yes, break
1542+ 261D FE 13                cp      CTRLS           ; Stop scrolling?
1543+ 261F C0                   ret     NZ              ; Other key, ignore
1544+ 2620
1545+ 2620
1546+ 2620              ; wait for a key while listing
1547+ 2620 D7           STALL:  rst     $10             ; Wait for key
1548+ 2621 FE 11                cp      CTRLQ           ; Resume scrolling?
1549+ 2623 C8                   ret     Z               ; Release the chokehold
1550+ 2624 FE 03                cp      CTRLC           ; Second break?
1551+ 2626 28 07                jr      Z,STOP          ; Break during hold exits prog
1552+ 2628 18 F6                jr      STALL           ; Loop until <Ctrl-Q> or <brk>
1553+ 262A
1554+ 262A 3E FF        BRK:    ld      A,$FF           ; Set BRKFLG
1555+ 262C 32 1E 60             ld      (BRKFLG),A      ; Store it
1556+ 262F
1557+ 262F C0           STOP:   ret     NZ              ; Exit if anything else
1558+ 2630 F6                   defb    $F6             ; Flag "STOP"
1559+ 2631 C0           PEND:   ret     NZ              ; Exit if anything else
1560+ 2632 22 53 61             ld      (BRKLIN),HL     ; Save point of break
1561+ 2635 21                   defb    $21             ; Skip "OR 11111111B"
1562+ 2636 F6 FF        INPBRK: or      %11111111       ; Flag "Break" wanted
1563+ 2638 C1                   pop     BC              ; Return not needed and more
1564+ 2639 2A 24 60     ENDPRG: ld      HL,(LINEAT)     ; Get current line number
1565+ 263C F5                   push    AF              ; Save STOP / END status
1566+ 263D 7D                   ld      A,L             ; Is it direct break?
1567+ 263E A4                   and     H
1568+ 263F 3C                   inc     A               ; Line is -1 if direct break
1569+ 2640 CA 4C 26             jp      Z,NOLIN         ; Yes - No line number
1570+ 2643 22 57 61             ld      (ERRLIN),HL     ; Save line of break
1571+ 2646 2A 53 61             ld      HL,(BRKLIN)     ; Get point of break
1572+ 2649 22 59 61             ld      (CONTAD),HL     ; Save point to CONTinue
1573+ 264C AF           NOLIN:  xor     A
1574+ 264D 32 1A 60             ld      (CTLOFG),A      ; Enable output
1575+ 2650 CD A2 28             call    STTLIN          ; Start a new line
1576+ 2653 F1                   pop     AF              ; Restore STOP / END status
1577+ 2654 21 21 20             ld      HL,BRKMSG       ; "Break" message
1578+ 2657 C2 5D 26             jp      NZ,ERRINT       ; "in line" wanted?
1579+ 265A C3 FE 20             jp      PRNTOK          ; Go to command mode
1580+ 265D CD 78 20     ERRINT: call    EXITGM          ; exit from graphics mode
1581+ 2660 C3 DC 20             jp      ERRIN           ; print message
1582+ 2663
1583+ 2663
1584+ 2663              ; CONTinue after a break/error
1585+ 2663 21 FF FF     CONT:   ld      HL,-1           ; reset...
1586+ 2666 22 26 60             ld      (HLPLN),HL      ; ...HELP line register
1587+ 2669 2A 59 61             ld      HL,(CONTAD)     ; Get CONTinue address
1588+ 266C 7C                   ld      A,H             ; Is it zero?
1589+ 266D B5                   or      L
1590+ 266E 1E 20                ld      E,CN            ; ?CN Error
1591+ 2670 CA B8 20             jp      Z,ERROR         ; Yes - output "?CN Error"
1592+ 2673 EB                   ex      DE,HL           ; Save code string address
1593+ 2674 2A 57 61             ld      HL,(ERRLIN)     ; Get line of last break
1594+ 2677 22 24 60             ld      (LINEAT),HL     ; Set up current line number
1595+ 267A EB                   ex      DE,HL           ; Restore code string address
1596+ 267B C9                   ret                     ; CONTinue where left off
1597+ 267C
1598+ 267C E5           ACCSUM: push    HL              ; Save address in array
1599+ 267D 2A 1B 60             ld      HL,(CHKSUM)     ; Get check sum
1600+ 2680 06 00                ld      B,$00           ; BC - Value of byte
1601+ 2682 4F                   ld      C,A
1602+ 2683 09                   add     HL,BC           ; Add byte to check sum
1603+ 2684 22 1B 60             ld      (CHKSUM),HL     ; Re-save check sum
1604+ 2687 E1                   pop     HL              ; Restore address in array
1605+ 2688 C9                   ret
1606+ 2689
1607+ 2689 7E           CHKLTR: ld      A,(HL)          ; Get byte
1608+ 268A FE 41                cp      'A'             ; < 'a' ?
1609+ 268C D8                   ret     C               ; Carry set if not letter
1610+ 268D FE 5B                cp      'Z'+1           ; > 'z' ?
1611+ 268F 3F                   ccf
1612+ 2690 C9                   ret                     ; Carry set if not letter
1613+ 2691
1614+ 2691 CD E7 25     FPSINT: call    GETCHR          ; Get next character
1615+ 2694 CD 78 2A     POSINT: call    GETNUM          ; Get integer 0 to 32767
1616+ 2697 CD 85 38     DEPINT: call    TSTSGN          ; Test sign of FPREG
1617+ 269A FA B2 26             jp      M,FCERR         ; Negative - ?FC Error
1618+ 269D 3A D2 61     DEINT:  ld      A,(FPEXP)       ; Get integer value to DE
1619+ 26A0 FE 90                cp      $80+$10         ; Exponent in range (16 bits)?
1620+ 26A2 DA 2D 39             jp      C,FPINT         ; Yes - convert it
1621+ 26A5 01 80 90             ld      BC,$9080        ; BCDE = -32768
1622+ 26A8 11 00 00             ld      DE,$0000
1623+ 26AB E5                   push    HL              ; Save code string address
1624+ 26AC CD 00 39             call    CMPNUM          ; Compare FPREG with BCDE
1625+ 26AF E1                   pop     HL              ; Restore code string address
1626+ 26B0 51                   ld      D,C             ; MSB to D
1627+ 26B1 C8                   ret     Z               ; Return if in range
1628+ 26B2 1E 08        FCERR:  ld      E,FC            ; ?FC Error
1629+ 26B4 C3 B8 20             jp      ERROR           ; Output error-
1630+ 26B7
1631+ 26B7
1632+ 26B7              ; convert a number in ASCII chars into an integer and store it into DE
1633+ 26B7 2B           ATOH:   dec     HL              ; ASCII number to DE binary
1634+ 26B8 11 00 00     GETLN:  ld      DE,$0000        ; Get number to DE
1635+ 26BB CD E7 25     GTLNLP: call    GETCHR          ; Get next character
1636+ 26BE D0                   ret     NC              ; Exit if not a digit
1637+ 26BF E5                   push    HL              ; Save code string address
1638+ 26C0 F5                   push    AF              ; Save digit
1639+ 26C1 21 98 19             ld      HL,65529/10     ; Largest number 65529
1640+ 26C4 CD 98 23             call    CPDEHL          ; Number in range?
1641+ 26C7 DA 9E 20             jp      C,SNERR         ; No - ?SN Error
1642+ 26CA 62                   ld      H,D             ; HL = Number
1643+ 26CB 6B                   ld      L,E
1644+ 26CC 19                   add     HL,DE           ; Times 2
1645+ 26CD 29                   add     HL,HL           ; Times 4
1646+ 26CE 19                   add     HL,DE           ; Times 5
1647+ 26CF 29                   add     HL,HL           ; Times 10
1648+ 26D0 F1                   pop     AF              ; Restore digit
1649+ 26D1 D6 30                sub     '0'             ; Make it 0 to 9
1650+ 26D3 5F                   ld      E,A             ; DE = Value of digit
1651+ 26D4 16 00                ld      D,0
1652+ 26D6 19                   add     HL,DE           ; Add to number
1653+ 26D7 EB                   ex      DE,HL           ; Number to DE
1654+ 26D8 E1                   pop     HL              ; Restore code string address
1655+ 26D9 C3 BB 26             jp      GTLNLP          ; Go to next character
1656+ 26DC
1657+ 26DC CA EA 21     CLEAR:  jp      Z,INTVAR        ; Just "CLEAR" Keep parameters
1658+ 26DF CD 78 2A             call    GETNUM          ; Evaluate a number
1659+ 26E2 CD 9D 26             call    DEINT           ; Get integer -32768 to 32767 into DE
1660+ 26E5 2B                   dec     HL              ; Cancel increment
1661+ 26E6 CD E7 25             call    GETCHR          ; Get next character
1662+ 26E9 E5                   push    HL              ; Save code string address
1663+ 26EA 2A 0B 61             ld      HL,(LSTRAM)     ; Get end of RAM
1664+ 26ED CA 05 27             jp      Z,STORED        ; No value given - Use stored
1665+ 26F0 E1                   pop     HL              ; Restore code string address
1666+ 26F1 CD 9E 23             call    CHKSYN          ; Check for comma
1667+ 26F4 2C                   defb    ','
1668+ 26F5 D5                   push    DE              ; Save number
1669+ 26F6 CD 78 2A             call    GETNUM          ; Evaluate a number
1670+ 26F9 CD 9D 26             call    DEINT           ; Get integer -32768 to 32767 into DE
1671+ 26FC 2B                   dec     HL              ; Cancel increment
1672+ 26FD CD E7 25             call    GETCHR          ; Get next character
1673+ 2700 C2 9E 20             jp      NZ,SNERR        ; ?SN Error if more on line
1674+ 2703 E3                   ex      (SP),HL         ; Save code string address
1675+ 2704 EB                   ex      DE,HL           ; Number to DE
1676+ 2705 7D           STORED: ld      A,L             ; Get LSB of new RAM top
1677+ 2706 93                   sub     E               ; Subtract LSB of string space
1678+ 2707 5F                   ld      E,A             ; Save LSB
1679+ 2708 7C                   ld      A,H             ; Get MSB of new RAM top
1680+ 2709 9A                   sbc     A,D             ; Subtract MSB of string space
1681+ 270A 57                   ld      D,A             ; Save MSB
1682+ 270B DA 73 20             jp      C,OMERR         ; ?OM Error if not enough mem
1683+ 270E E5                   push    HL              ; Save RAM top
1684+ 270F 2A C1 61             ld      HL,(PROGND)     ; Get program end
1685+ 2712 01 28 00             ld      BC,$28          ; 40 Bytes minimum working RAM
1686+ 2715 09                   add     HL,BC           ; Get lowest address
1687+ 2716 CD 98 23             call    CPDEHL          ; Enough memory?
1688+ 2719 D2 73 20             jp      NC,OMERR        ; No - ?OM Error
1689+ 271C EB                   ex      DE,HL           ; RAM top to HL
1690+ 271D 22 22 60             ld      (STRSPC),HL     ; Set new string space
1691+ 2720 E1                   pop     HL              ; End of memory to use
1692+ 2721 22 0B 61             ld      (LSTRAM),HL     ; Set new top of RAM
1693+ 2724 E1                   pop     HL              ; Restore code string address
1694+ 2725 C3 EA 21             jp      INTVAR          ; Initialise variables
1695+ 2728
1696+ 2728 E5           RUN:    push    HL              ; store HL
1697+ 2729 21 FF FF             ld      HL,-1           ; reset...
1698+ 272C 22 26 60             ld      (HLPLN),HL      ; ...HELP line register
1699+ 272F E1                   pop     HL              ; retrieve HL
1700+ 2730 CA E6 21             jp      Z,RUNFST        ; RUN from start if just RUN
1701+ 2733 CD EA 21             call    INTVAR          ; Initialise variables
1702+ 2736 01 A7 25             ld      BC,RUNCNT       ; Execution driver loop
1703+ 2739 C3 4C 27             jp      RUNLIN          ; RUN from line number
1704+ 273C
1705+ 273C 0E 03        GOSUB:  ld      C,$03           ; 3 Levels of stack needed
1706+ 273E CD 5B 20             call    CHKSTK          ; Check for 3 levels of stack
1707+ 2741 C1                   pop     BC              ; Get return address
1708+ 2742 E5                   push    HL              ; Save code string for RETURN
1709+ 2743 E5                   push    HL              ; And for GOSUB routine
1710+ 2744 2A 24 60             ld      HL,(LINEAT)     ; Get current line
1711+ 2747 E3                   ex      (SP),HL         ; Into stack - Code string out
1712+ 2748 3E 8C                ld      A,ZGOSUB        ; "GOSUB" token
1713+ 274A F5                   push    AF              ; Save token
1714+ 274B 33                   inc     SP              ; Don't save flags
1715+ 274C
1716+ 274C C5           RUNLIN: push    BC              ; Save return address
1717+ 274D CD B7 26     GOTO:   call    ATOH            ; ASCII number to DE binary
1718+ 2750 CD 92 27             call    REM             ; Get end of line
1719+ 2753 E5                   push    HL              ; Save end of line
1720+ 2754 2A 24 60             ld      HL,(LINEAT)     ; Get current line
1721+ 2757 CD 98 23             call    CPDEHL          ; Line after current?
1722+ 275A E1                   pop     HL              ; Restore end of line
1723+ 275B 23                   inc     HL              ; Start of next line
1724+ 275C DC BD 21             call    C,SRCHLP        ; Line is after current line
1725+ 275F D4 BA 21             call    NC,SRCHLN       ; Line is before current line
1726+ 2762 60                   ld      H,B             ; Set up code string address
1727+ 2763 69                   ld      L,C
1728+ 2764 2B                   dec     HL              ; Incremented after
1729+ 2765 D8                   ret     C               ; Line found
1730+ 2766 1E 0E        ULERR:  ld      E,UL            ; ?UL Error
1731+ 2768 C3 B8 20             jp      ERROR           ; Output error message
1732+ 276B
1733+ 276B C0           RETURN: ret     NZ              ; Return if not just RETURN
1734+ 276C 16 FF                ld      D,-1            ; Flag "GOSUB" search
1735+ 276E CD 27 20             call    BAKSTK          ; Look "GOSUB" block
1736+ 2771 F9                   ld      SP,HL           ; Kill all FORs in subroutine
1737+ 2772 FE 8C                cp      ZGOSUB          ; Test for "GOSUB" token
1738+ 2774 1E 04                ld      E,RG            ; ?RG Error
1739+ 2776 C2 B8 20             jp      NZ,ERROR        ; Error if no "GOSUB" found
1740+ 2779 E1                   pop     HL              ; Get RETURN line number
1741+ 277A 22 24 60             ld      (LINEAT),HL     ; Save as current
1742+ 277D 23                   inc     HL              ; Was it from direct statement?
1743+ 277E 7C                   ld      A,H
1744+ 277F B5                   or      L               ; Return to line
1745+ 2780 C2 8A 27             jp      NZ,RETLIN       ; No - Return to line
1746+ 2783 3A 51 61             ld      A,(LSTBIN)      ; Any INPUT in subroutine?
1747+ 2786 B7                   or      A               ; If so buffer is corrupted
1748+ 2787 C2 FD 20             jp      NZ,POPNOK       ; Yes - Go to command mode
1749+ 278A 21 A7 25     RETLIN: ld      HL,RUNCNT       ; Execution driver loop
1750+ 278D E3                   ex      (SP),HL         ; Into stack - Code string out
1751+ 278E 3E                   defb    $3E             ; Skip "pop HL"
1752+ 278F E1           NXTDTA: pop     HL              ; Restore code string address
1753+ 2790
1754+ 2790 01 3A        DATA:   defb    $01,$3A         ; ':' End of statement (stands for LD BC,$0E3A - NOP)
1755+ 2792 0E 00        REM:    ld      C,$00           ; 00  End of statement
1756+ 2794 06 00                ld      B,$00
1757+ 2796 79           NXTSTL: ld      A,C             ; Statement and byte
1758+ 2797 48                   ld      C,B
1759+ 2798 47                   ld      B,A             ; Statement end byte
1760+ 2799 7E           NXTSTT: ld      A,(HL)          ; Get byte
1761+ 279A B7                   or      A               ; End of line?
1762+ 279B C8                   ret     Z               ; Yes - Exit
1763+ 279C B8                   cp      B               ; End of statement?
1764+ 279D C8                   ret     Z               ; Yes - Exit
1765+ 279E 23                   inc     HL              ; Next byte
1766+ 279F FE 22                cp      $22             ; '"'             ; Literal string?
1767+ 27A1 CA 96 27             jp      Z,NXTSTL        ; Yes - Look for another '"'
1768+ 27A4 C3 99 27             jp      NXTSTT          ; Keep looking
1769+ 27A7
1770+ 27A7 CD 87 2C     LET:    call    GETVAR          ; Get variable name
1771+ 27AA CD 9E 23             call    CHKSYN          ; Make sure "=" follows
1772+ 27AD C9                   defb    ZEQUAL          ; "=" token
1773+ 27AE D5                   push    DE              ; Save address of variable
1774+ 27AF 3A 09 61             ld      A,(TYPE)        ; Get data type
1775+ 27B2 F5                   push    AF              ; Save type
1776+ 27B3 CD 8A 2A             call    EVAL            ; Evaluate expression
1777+ 27B6 F1                   pop     AF              ; Restore type
1778+ 27B7 E3                   ex      (SP),HL         ; Save code - Get var addr
1779+ 27B8 22 53 61             ld      (BRKLIN),HL     ; Save address of variable
1780+ 27BB 1F                   rra                     ; Adjust type
1781+ 27BC CD 7D 2A             call    CHKTYP          ; Check types are the same
1782+ 27BF CA FA 27             jp      Z,LETNUM        ; Numeric - Move value
1783+ 27C2 E5           LETSTR: push    HL              ; Save address of string var
1784+ 27C3 2A CF 61             ld      HL,(FPREG)      ; Pointer to string entry
1785+ 27C6 E5                   push    HL              ; Save it on stack
1786+ 27C7 23                   inc     HL              ; Skip over length
1787+ 27C8 23                   inc     HL
1788+ 27C9 5E                   ld      E,(HL)          ; LSB of string address
1789+ 27CA 23                   inc     HL
1790+ 27CB 56                   ld      D,(HL)          ; MSB of string address
1791+ 27CC 2A AA 60             ld      HL,(BASTXT)     ; Point to start of program
1792+ 27CF CD 98 23             call    CPDEHL          ; Is string before program?
1793+ 27D2 D2 E9 27             jp      NC,CRESTR       ; Yes - Create string entry
1794+ 27D5 2A 22 60             ld      HL,(STRSPC)     ; Point to string space
1795+ 27D8 CD 98 23             call    CPDEHL          ; Is string literal in program?
1796+ 27DB D1                   pop     DE              ; Restore address of string
1797+ 27DC D2 F1 27             jp      NC,MVSTPT       ; Yes - Set up pointer
1798+ 27DF 21 44 61             ld      HL,TMPSTR       ; Temporary string pool
1799+ 27E2 CD 98 23             call    CPDEHL          ; Is string in temporary pool?
1800+ 27E5 D2 F1 27             jp      NC,MVSTPT       ; No - Set up pointer
1801+ 27E8 3E                   defb    $3E             ; Skip "pop DE"
1802+ 27E9 D1           CRESTR: pop     DE              ; Restore address of string
1803+ 27EA CD E1 30             call    BAKTMP          ; Back to last tmp-str entry
1804+ 27ED EB                   ex      DE,HL           ; Address of string entry
1805+ 27EE CD 1A 2F             call    SAVSTR          ; Save string in string area
1806+ 27F1 CD E1 30     MVSTPT: call    BAKTMP          ; Back to last tmp-str entry
1807+ 27F4 E1                   pop     HL              ; Get string pointer
1808+ 27F5 CD E0 38             call    DETHL4          ; Move string pointer to var
1809+ 27F8 E1                   pop     HL              ; Restore code string address
1810+ 27F9 C9                   ret
1811+ 27FA
1812+ 27FA E5           LETNUM: push    HL              ; Save address of variable
1813+ 27FB CD DD 38             call    FPTHL           ; Move value to variable
1814+ 27FE D1                   pop     DE              ; Restore address of variable
1815+ 27FF E1                   pop     HL              ; Restore code string address
1816+ 2800 C9                   ret
1817+ 2801
1818+ 2801 CD FE 32     ON:     call    GETINT          ; Get integer 0-255
1819+ 2804 7E                   ld      A,(HL)          ; Get "GOTO" or "GOSUB" token
1820+ 2805 47                   ld      B,A             ; Save in B
1821+ 2806 FE 8C                cp      ZGOSUB          ; "GOSUB" token?
1822+ 2808 CA 10 28             jp      Z,ONGO          ; Yes - Find line number
1823+ 280B CD 9E 23             call    CHKSYN          ; Make sure it's "GOTO"
1824+ 280E 88                   defb    ZGOTO           ; "GOTO" token
1825+ 280F 2B                   dec     HL              ; Cancel increment
1826+ 2810 4B           ONGO:   ld      C,E             ; Integer of branch value
1827+ 2811 0D           ONGOLP: dec     C               ; Count branches
1828+ 2812 78                   ld      A,B             ; Get "GOTO" or "GOSUB" token
1829+ 2813 CA CF 25             jp      Z,ONJMP         ; Go to that line if right one
1830+ 2816 CD B8 26             call    GETLN           ; Get line number to DE
1831+ 2819 FE 2C                cp      ','             ; Another line number?
1832+ 281B C0                   ret     NZ              ; No - Drop through
1833+ 281C C3 11 28             jp      ONGOLP          ; Yes - loop
1834+ 281F
1835+ 281F CD 8A 2A     IF:     call    EVAL            ; Evaluate expression
1836+ 2822 7E                   ld      A,(HL)          ; Get token
1837+ 2823 FE 88                cp      ZGOTO           ; "GOTO" token?
1838+ 2825 CA 2D 28             jp      Z,IFGO          ; Yes - Get line
1839+ 2828 CD 9E 23             call    CHKSYN          ; Make sure it's "THEN"
1840+ 282B BB                   defb    ZTHEN           ; "THEN" token
1841+ 282C 2B                   dec     HL              ; Cancel increment
1842+ 282D CD 7B 2A     IFGO:   call    TSTNUM          ; Make sure it's numeric
1843+ 2830 CD 85 38             call    TSTSGN          ; Test state of expression
1844+ 2833 CA 3F 28             jp      Z,IF1           ; False - Jump over
1845+ 2836 CD E7 25     IF0:    call    GETCHR          ; Get next character
1846+ 2839 DA 4D 27             jp      C,GOTO          ; Number - GOTO that line
1847+ 283C C3 CE 25             jp      IFJMP           ; Otherwise do statement
1848+ 283F 0E AF        IF1:    ld      C,ZELSE
1849+ 2841 CD 94 27             call    REM+2           ; check statement
1850+ 2844 B7                   or      A               ; end of line?
1851+ 2845 C8                   ret     Z               ; yes, leave
1852+ 2846 FE AF                cp      ZELSE
1853+ 2848 20 F5                jr      NZ,IF1          ; ELSE not found, continue check
1854+ 284A C3 36 28             jp      IF0             ; return to IF
1855+ 284D
1856+ 284D
1857+ 284D 2B           MRPRNT: dec     HL              ; dec 'cos GETCHR INCs
1858+ 284E CD E7 25             call    GETCHR          ; Get next character
1859+ 2851 CA B4 28     PRINT:  jp      Z,PRNTCRLF      ; CRLF if just PRINT
1860+ 2854 C8           PRNTLP: ret     Z               ; End of list - Exit
1861+ 2855 FE B7                cp      ZTAB            ; "TAB(" token?
1862+ 2857 CA DC 28             jp      Z,DOTAB         ; Yes - Do TAB routine
1863+ 285A FE BA                cp      ZSPC            ; "SPC(" token?
1864+ 285C CA DC 28             jp      Z,DOTAB         ; Yes - Do SPC routine
1865+ 285F E5                   push    HL              ; Save code string address
1866+ 2860 FE 2C                cp      ','             ; Comma?
1867+ 2862 CA C3 28             jp      Z,DOCOM         ; Yes - Move to next zone
1868+ 2865 FE 3B                cp      ';'             ; Semi-colon?
1869+ 2867 CA 00 29             jp      Z,NEXITM        ; Do semi-colon routine
1870+ 286A C1                   pop     BC              ; Code string address to BC
1871+ 286B CD 8A 2A             call    EVAL            ; Evaluate expression
1872+ 286E E5                   push    HL              ; Save code string address
1873+ 286F 3A 09 61             ld      A,(TYPE)        ; Get variable type
1874+ 2872 B7                   or      A               ; Is it a string variable?
1875+ 2873 C2 9B 28             jp      NZ,PRNTST       ; Yes - Output string contents
1876+ 2876 CD 2A 3A             call    NUMASC          ; Convert number to text
1877+ 2879 CD 3E 2F             call    CRTST           ; Create temporary string
1878+ 287C 36 00                ld      (HL),NLLCR      ; Followed by a NULL char (was SPC, space)
1879+ 287E 2A CF 61             ld      HL,(FPREG)      ; Get length of output
1880+ 2881 34                   inc     (HL)            ; Plus 1 for the space
1881+ 2882 2A CF 61             ld      HL,(FPREG)      ; < Not needed >
1882+ 2885 3A 17 60             ld      A,(LWIDTH)      ; Get width of line
1883+ 2888 47                   ld      B,A             ; To B
1884+ 2889 04                   inc     B               ; Width 255 (No limit)?
1885+ 288A CA 97 28             jp      Z,PRNTNB        ; Yes - Output number string
1886+ 288D 04                   inc     B               ; Adjust it
1887+ 288E 3A 07 61             ld      A,(CURPOS)      ; Get cursor position
1888+ 2891 86                   add     A,(HL)          ; Add length of string
1889+ 2892 3D                   dec     A               ; Adjust it
1890+ 2893 B8                   cp      B               ; Will output fit on this line?
1891+ 2894 D4 B4 28             call    NC,PRNTCRLF     ; No - CRLF first
1892+ 2897 CD 83 2F     PRNTNB: call    PRS1            ; Output string at (HL)
1893+ 289A AF                   xor     A               ; Skip call by setting 'z' flag
1894+ 289B C4 83 2F     PRNTST: call    NZ,PRS1         ; Output string at (HL)
1895+ 289E E1                   pop     HL              ; Restore code string address
1896+ 289F C3 4D 28             jp      MRPRNT          ; See if more to PRINT
1897+ 28A2
1898+ 28A2 3A 07 61     STTLIN: ld      A,(CURPOS)      ; Make sure on new line
1899+ 28A5 B7                   or      A               ; Already at start?
1900+ 28A6 C8                   ret     Z               ; Yes - Do nothing
1901+ 28A7 C3 B4 28             jp      PRNTCRLF        ; Start a new line
1902+ 28AA
1903+ 28AA AF           ENDINP: xor     A
1904+ 28AB 32 B5 61             ld      (KBDNPT),A      ; char is not from keyboard
1905+ 28AE 77                   ld      (HL),A          ; Mark end of buffer
1906+ 28AF 21 AC 60             ld      HL,BUFFER-1     ; Point to buffer
1907+ 28B2 18 0A                jr      CNTEND
1908+ 28B4 3E 0D        PRNTCRLF:ld     A,CR            ; Load a CR
1909+ 28B6 CD A9 23             call    OUTC            ; Output character
1910+ 28B9 3E 0A                ld      A,LF            ; Load a LF
1911+ 28BB CD A9 23             call    OUTC            ; Output character
1912+ 28BE AF           CNTEND: xor     A               ; Set to position 0
1913+ 28BF 32 07 61             ld      (CURPOS),A      ; Store it
1914+ 28C2 C9                   ret                     ; return to caller
1915+ 28C3
1916+ 28C3 3A 18 60     DOCOM:  ld      A,(COMMAN)      ; Get comma width
1917+ 28C6 47                   ld      B,A             ; Save in B
1918+ 28C7 3A 70 61             ld      A,(SCR_CURS_X)  ; Get current position
1919+ 28CA B8                   cp      B               ; Within the limit?
1920+ 28CB D4 B4 28             call    NC,PRNTCRLF     ; No - output CRLF
1921+ 28CE D2 00 29             jp      NC,NEXITM       ; Get next item
1922+ 28D1 D6 0A        ZONELP: sub     $0A             ; Next zone of 10 characters
1923+ 28D3 D2 D1 28             jp      NC,ZONELP       ; Repeat if more zones
1924+ 28D6 2F                   cpl                     ; Number of null chars to output
1925+ 28D7 0E 00                ld      C,NLLCR         ; null char
1926+ 28D9 C3 F6 28             jp      ASPCS           ; Output them
1927+ 28DC
1928+ 28DC F5           DOTAB:  push    AF              ; Save token
1929+ 28DD CD FB 32             call    FNDNUM          ; Evaluate expression
1930+ 28E0 CD 9E 23             call    CHKSYN          ; Make sure ")" follows
1931+ 28E3 29                   defb    ')'
1932+ 28E4 2B                   dec     HL              ; Back space on to ")"
1933+ 28E5 F1                   pop     AF              ; Restore token
1934+ 28E6 0E 00                ld      C,NLLCR         ; for SPC we use NULL char (was SPACE)
1935+ 28E8 D6 BA                sub     ZSPC            ; Was it "SPC(" ?
1936+ 28EA E5                   push    HL              ; Save code string address
1937+ 28EB CA F1 28             jp      Z,DOSPC         ; Yes - Do 'E' spaces
1938+ 28EE 3A 70 61             ld      A,(SCR_CURS_X)  ; Get current X position
1939+ 28F1 2F           DOSPC:  cpl                     ; Number of spaces to print to
1940+ 28F2 83                   add     A,E             ; Total number to print
1941+ 28F3 D2 00 29             jp      NC,NEXITM       ; TAB < Current POS(X)
1942+ 28F6 3C           ASPCS:  inc     A               ; Output A spaces
1943+ 28F7 47                   ld      B,A             ; Save number to print
1944+ 28F8 79           SPCLP:  ld      A,C             ; char to print
1945+ 28F9 CD A9 23             call    OUTC            ; Output character in A
1946+ 28FC 05                   dec     B               ; Count them
1947+ 28FD C2 F8 28             jp      NZ,SPCLP        ; Repeat if more
1948+ 2900 E1           NEXITM: pop     HL              ; Restore code string address
1949+ 2901 CD E7 25             call    GETCHR          ; Get next character
1950+ 2904 C3 54 28             jp      PRNTLP          ; More to print
1951+ 2907
1952+ 2907 3F 52 65 64  REDO:   defb    "?Redo from start",CR,0
1952+ 290B 6F 20 66 72
1952+ 290F 6F 6D 20 73
1952+ 2913 74 61 72 74
1952+ 2917 0D 00
1953+ 2919
1954+ 2919 3A 52 61     BADINP: ld      A,(READFG)      ; READ or INPUT?
1955+ 291C B7                   or      A
1956+ 291D C2 98 20             jp      NZ,DATSNR       ; READ - ?SN Error
1957+ 2920 C1                   pop     BC              ; Throw away code string addr
1958+ 2921 21 07 29             ld      HL,REDO         ; "Redo from start" message
1959+ 2924 CD 80 2F             call    PRS             ; Output string
1960+ 2927 C3 19 22             jp      DOAGN           ; Do last INPUT again
1961+ 292A
1962+ 292A CD EB 2E     INPUT:  call    IDTEST          ; Test for illegal direct
1963+ 292D 7E                   ld      A,(HL)          ; Get character after "INPUT"
1964+ 292E FE 22                cp      $22             ; '"' ; Is there a prompt string?
1965+ 2930 3E 00                ld      A,$00           ; Clear A and leave flags
1966+ 2932 32 1A 60             ld      (CTLOFG),A      ; Enable output
1967+ 2935 C2 44 29             jp      NZ,NOPMPT       ; No prompt - get input
1968+ 2938 CD 3F 2F             call    QTSTR           ; Get string terminated by '"'
1969+ 293B CD 9E 23             call    CHKSYN          ; Check for ';' after prompt
1970+ 293E 3B                   defb    ";"
1971+ 293F E5                   push    HL              ; Save code string address
1972+ 2940 CD 83 2F             call    PRS1            ; Output prompt string
1973+ 2943 3E                   defb    $3E             ; Skip "push HL"
1974+ 2944 E5           NOPMPT: push    HL              ; Save code string address
1975+ 2945 CD 1D 22             call    PROMPT          ; Get input with "? " prompt
1976+ 2948 C1                   pop     BC              ; Restore code string address
1977+ 2949 DA 36 26             jp      C,INPBRK        ; Break pressed - Exit
1978+ 294C 23                   inc     HL              ; Next byte
1979+ 294D 7E                   ld      A,(HL)          ; Get it
1980+ 294E B7                   or      A               ; End of line?
1981+ 294F 2B                   dec     HL              ; Back again
1982+ 2950 C5                   push    BC              ; Re-save code string address
1983+ 2951 3A BD 61             ld      A,(SERIALS_EN)  ; load serial state
1984+ 2954 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
1985+ 2956 CC 8F 01             call    Z,A_RTS_OFF      ; yes, set RTS on
1986+ 2959 CD 38 09             call    CURSOR_OFF      ; disable cursor
1987+ 295C CA 8F 27             jp      Z,NXTDTA        ; Yes - Find next DATA stmt
1988+ 295F 36 2C                ld      (HL),','        ; Store comma as separator
1989+ 2961 C3 69 29             jp      NXTITM          ; Get next item
1990+ 2964
1991+ 2964 E5           READ:   push    HL              ; Save code string address
1992+ 2965 2A C7 61             ld      HL,(NXTDAT)     ; Next DATA statement
1993+ 2968 F6                   defb    $F6             ; Flag "READ"
1994+ 2969 AF           NXTITM: xor     A               ; Flag "INPUT"
1995+ 296A 32 52 61             ld      (READFG),A      ; Save "READ"/"INPUT" flag
1996+ 296D E3                   ex      (SP),HL         ; Get code str' , Save pointer
1997+ 296E C3 75 29             jp      GTVLUS          ; Get values
1998+ 2971
1999+ 2971 CD 9E 23     NEDMOR: call    CHKSYN          ; Check for comma between items
2000+ 2974 2C                   defb    ','
2001+ 2975 CD 87 2C     GTVLUS: call    GETVAR          ; Get variable name
2002+ 2978 E3                   ex      (SP),HL         ; Save code str" , Get pointer
2003+ 2979 D5                   push    DE              ; Save variable address
2004+ 297A 7E                   ld      A,(HL)          ; Get next "INPUT"/"DATA" byte
2005+ 297B FE 2C                cp      ','             ; Comma?
2006+ 297D CA 9D 29             jp      Z,ANTVLU        ; Yes - Get another value
2007+ 2980 3A 52 61             ld      A,(READFG)      ; Is it READ?
2008+ 2983 B7                   or      A
2009+ 2984 C2 09 2A             jp      NZ,FDTLP        ; Yes - Find next DATA stmt
2010+ 2987 3E 3F                ld      A,'?'           ; More INPUT needed
2011+ 2989 CD A9 23             call    OUTC            ; Output character
2012+ 298C CD 1D 22             call    PROMPT          ; Get INPUT with prompt
2013+ 298F D1                   pop     DE              ; Variable address
2014+ 2990 C1                   pop     BC              ; Code string address
2015+ 2991 DA 36 26             jp      C,INPBRK        ; Break pressed
2016+ 2994 23                   inc     HL              ; Point to next DATA byte
2017+ 2995 7E                   ld      A,(HL)          ; Get byte
2018+ 2996 B7                   or      A               ; Is it zero (No input) ?
2019+ 2997 2B                   dec     HL              ; Back space INPUT pointer
2020+ 2998 C5                   push    BC              ; Save code string address
2021+ 2999 CA 8F 27             jp      Z,NXTDTA        ; Find end of buffer
2022+ 299C D5                   push    DE              ; Save variable address
2023+ 299D 3A 09 61     ANTVLU: ld      A,(TYPE)        ; Check data type
2024+ 29A0 B7                   or      A               ; Is it numeric?
2025+ 29A1 CA C7 29             jp      Z,INPBIN        ; Yes - Convert to binary
2026+ 29A4 CD E7 25             call    GETCHR          ; Get next character
2027+ 29A7 57                   ld      D,A             ; Save input character
2028+ 29A8 47                   ld      B,A             ; Again
2029+ 29A9 FE 22                cp      $22             ; '"'     ; Start of literal sting?
2030+ 29AB CA BB 29             jp      Z,STRENT        ; Yes - Create string entry
2031+ 29AE 3A 52 61             ld      A,(READFG)      ; "READ" or "INPUT" ?
2032+ 29B1 B7                   or      A
2033+ 29B2 57                   ld      D,A             ; Save 00 if "INPUT"
2034+ 29B3 CA B8 29             jp      Z,ITMSEP        ; "INPUT" - End with 00
2035+ 29B6 16 3A                ld      D,':'           ; "DATA" - End with 00 or ':'
2036+ 29B8 06 2C        ITMSEP: ld      B,','           ; Item separator
2037+ 29BA 2B                   dec     HL              ; Back space for DTSTR
2038+ 29BB CD 42 2F     STRENT: call    DTSTR           ; Get string terminated by D
2039+ 29BE EB                   ex      DE,HL           ; String address to DE
2040+ 29BF 21 D2 29             ld      HL,LTSTND       ; Where to go after LETSTR
2041+ 29C2 E3                   ex      (SP),HL         ; Save HL , get input pointer
2042+ 29C3 D5                   push    DE              ; Save address of string
2043+ 29C4 C3 C2 27             jp      LETSTR          ; Assign string to variable
2044+ 29C7
2045+ 29C7 CD E7 25     INPBIN: call    GETCHR          ; Get next character
2046+ 29CA CD 8C 39             call    ASCTFP          ; Convert ASCII to FP number
2047+ 29CD E3                   ex      (SP),HL         ; Save input ptr, Get var addr
2048+ 29CE CD DD 38             call    FPTHL           ; Move FPREG to variable
2049+ 29D1 E1                   pop     HL              ; Restore input pointer
2050+ 29D2 2B           LTSTND: dec     HL              ; dec 'cos GETCHR INCs
2051+ 29D3 CD E7 25             call    GETCHR          ; Get next character
2052+ 29D6 CA DE 29             jp      Z,MORDT         ; End of line - More needed?
2053+ 29D9 FE 2C                cp      ','             ; Another value?
2054+ 29DB C2 19 29             jp      NZ,BADINP       ; No - Bad input
2055+ 29DE E3           MORDT:  ex      (SP),HL         ; Get code string address
2056+ 29DF 2B                   dec     HL              ; dec 'cos GETCHR INCs
2057+ 29E0 CD E7 25             call    GETCHR          ; Get next character
2058+ 29E3 C2 71 29             jp      NZ,NEDMOR       ; More needed - Get it
2059+ 29E6 D1                   pop     DE              ; Restore DATA pointer
2060+ 29E7 3A 52 61             ld      A,(READFG)      ; "READ" or "INPUT" ?
2061+ 29EA B7                   or      A
2062+ 29EB EB                   ex      DE,HL           ; DATA pointer to HL
2063+ 29EC C2 0D 26             jp      NZ,UPDATA       ; Update DATA pointer if "READ"
2064+ 29EF D5                   push    DE              ; Save code string address
2065+ 29F0 B6                   or      (HL)            ; More input given?
2066+ 29F1 21 F9 29             ld      HL,EXTIG        ; "?Extra ignored" message
2067+ 29F4 C4 80 2F             call    NZ,PRS          ; Output string if extra given
2068+ 29F7 E1                   pop     HL              ; Restore code string address
2069+ 29F8 C9                   ret
2070+ 29F9
2071+ 29F9 3F 45 78 74  EXTIG:  defb    "?Extra ignored",CR,0
2071+ 29FD 72 61 20 69
2071+ 2A01 67 6E 6F 72
2071+ 2A05 65 64 0D 00
2072+ 2A09
2073+ 2A09 CD 90 27     FDTLP:  call    DATA            ; Get next statement
2074+ 2A0C B7                   or      A               ; End of line?
2075+ 2A0D C2 22 2A             jp      NZ,FANDT        ; No - See if DATA statement
2076+ 2A10 23                   inc     HL
2077+ 2A11 7E                   ld      A,(HL)          ; End of program?
2078+ 2A12 23                   inc     HL
2079+ 2A13 B6                   or      (HL)            ; 00 00 Ends program
2080+ 2A14 1E 06                ld      E,OD            ; ?OD Error
2081+ 2A16 CA B8 20             jp      Z,ERROR         ; Yes - Out of DATA
2082+ 2A19 23                   inc     HL
2083+ 2A1A 5E                   ld      E,(HL)          ; LSB of line number
2084+ 2A1B 23                   inc     HL
2085+ 2A1C 56                   ld      D,(HL)          ; MSB of line number
2086+ 2A1D EB                   ex      DE,HL
2087+ 2A1E 22 4E 61             ld      (DATLIN),HL     ; Set line of current DATA item
2088+ 2A21 EB                   ex      DE,HL
2089+ 2A22 CD E7 25     FANDT:  call    GETCHR          ; Get next character
2090+ 2A25 FE 83                cp      ZDATA           ; "DATA" token
2091+ 2A27 C2 09 2A             jp      NZ,FDTLP        ; No "DATA" - Keep looking
2092+ 2A2A C3 9D 29             jp      ANTVLU          ; Found - Convert input
2093+ 2A2D
2094+ 2A2D 11 00 00     NEXT:   ld      DE,$0000        ; In case no index given
2095+ 2A30 C4 87 2C     NEXT1:  call    NZ,GETVAR       ; Get index address
2096+ 2A33 22 53 61             ld      (BRKLIN),HL     ; Save code string address
2097+ 2A36 CD 27 20             call    BAKSTK          ; Look for "FOR" block
2098+ 2A39 C2 A4 20             jp      NZ,NFERR        ; No "FOR" - ?NF Error
2099+ 2A3C F9                   ld      SP,HL           ; Clear nested loops
2100+ 2A3D D5                   push    DE              ; Save index address
2101+ 2A3E 7E                   ld      A,(HL)          ; Get sign of STEP
2102+ 2A3F 23                   inc     HL
2103+ 2A40 F5                   push    AF              ; Save sign of STEP
2104+ 2A41 D5                   push    DE              ; Save index address
2105+ 2A42 CD C3 38             call    PHLTFP          ; Move index value to FPREG
2106+ 2A45 E3                   ex      (SP),HL         ; Save address of TO value
2107+ 2A46 E5                   push    HL              ; Save address of index
2108+ 2A47 CD DF 35             call    ADDPHL          ; Add STEP to index value
2109+ 2A4A E1                   pop     HL              ; Restore address of index
2110+ 2A4B CD DD 38             call    FPTHL           ; Move value to index variable
2111+ 2A4E E1                   pop     HL              ; Restore address of TO value
2112+ 2A4F CD D4 38             call    LOADFP          ; Move TO value to BCDE
2113+ 2A52 E5                   push    HL              ; Save address of line of FOR
2114+ 2A53 CD 00 39             call    CMPNUM          ; Compare index with TO value
2115+ 2A56 E1                   pop     HL              ; Restore address of line num
2116+ 2A57 C1                   pop     BC              ; Address of sign of STEP
2117+ 2A58 90                   sub     B               ; Compare with expected sign
2118+ 2A59 CD D4 38             call    LOADFP          ; BC = Loop stmt,DE = Line num
2119+ 2A5C CA 68 2A             jp      Z,KILFOR        ; Loop finished - Terminate it
2120+ 2A5F EB                   ex      DE,HL           ; Loop statement line number
2121+ 2A60 22 24 60             ld      (LINEAT),HL     ; Set loop line number
2122+ 2A63 69                   ld      L,C             ; Set code string to loop
2123+ 2A64 60                   ld      H,B
2124+ 2A65 C3 A3 25             jp      PUTFID          ; Put back "FOR" and continue
2125+ 2A68
2126+ 2A68 F9           KILFOR: ld      SP,HL           ; Remove "FOR" block
2127+ 2A69 2A 53 61             ld      HL,(BRKLIN)     ; Code string after "NEXT"
2128+ 2A6C 7E                   ld      A,(HL)          ; Get next byte in code string
2129+ 2A6D FE 2C                cp      ','             ; More NEXTs ?
2130+ 2A6F C2 A7 25             jp      NZ,RUNCNT       ; No - Do next statement
2131+ 2A72 CD E7 25             call    GETCHR          ; Position to index name
2132+ 2A75 CD 30 2A             call    NEXT1           ; Re-enter NEXT routine
2133+ 2A78              ; < will not RETurn to here , Exit to RUNCNT or Loop >
2134+ 2A78
2135+ 2A78 CD 8A 2A     GETNUM: call    EVAL            ; Get a numeric expression
2136+ 2A7B F6           TSTNUM: defb    $F6             ; Clear carry (numeric)
2137+ 2A7C 37           TSTSTR: scf                     ; Set carry (string)
2138+ 2A7D 3A 09 61     CHKTYP: ld      A,(TYPE)        ; Check types match
2139+ 2A80 8F                   adc     A,A             ; Expected + actual
2140+ 2A81 B7                   or      A               ; Clear carry , set parity
2141+ 2A82 E8                   ret     PE              ; Even parity - Types match
2142+ 2A83 C3 B0 20             jp      TMERR           ; Different types - Error
2143+ 2A86
2144+ 2A86 CD 9E 23     OPNPAR: call    CHKSYN          ; Make sure "(" follows
2145+ 2A89 28                   defb    '('
2146+ 2A8A 2B           EVAL:   dec     HL              ; Evaluate expression & save
2147+ 2A8B 16 00                ld      D,$00           ; Precedence value
2148+ 2A8D D5           EVAL1:  push    DE              ; Save precedence
2149+ 2A8E 0E 01                ld      C,$01
2150+ 2A90 CD 5B 20             call    CHKSTK          ; Check for 1 level of stack
2151+ 2A93 CD 01 2B             call    OPRND           ; Get next expression value
2152+ 2A96 22 55 61     EVAL2:  ld      (NXTOPR),HL     ; Save address of next operator
2153+ 2A99 2A 55 61     EVAL3:  ld      HL,(NXTOPR)     ; Restore address of next opr
2154+ 2A9C C1                   pop     BC              ; Precedence value and operator
2155+ 2A9D 78                   ld      A,B             ; Get precedence value
2156+ 2A9E FE 78                cp      $78             ; "AND", "OR", or "XOR" ?
2157+ 2AA0 D4 7B 2A             call    NC,TSTNUM       ; No - Make sure it's a number
2158+ 2AA3 7E                   ld      A,(HL)          ; Get next operator / function
2159+ 2AA4 16 00                ld      D,$00           ; Clear Last relation
2160+ 2AA6 D6 C8        RLTLP:  sub     ZGTR            ; ">" Token
2161+ 2AA8 DA C2 2A             jp      C,FOPRND        ; + - * / ^ AND OR XOR - Test it
2162+ 2AAB FE 03                cp      ZLTH+1-ZGTR     ; < = >
2163+ 2AAD D2 C2 2A             jp      NC,FOPRND       ; Function - Call it
2164+ 2AB0 FE 01                cp      ZEQUAL-ZGTR     ; "="
2165+ 2AB2 17                   rla                     ; <- Test for legal
2166+ 2AB3 AA                   xor     D               ; <- combinations of < = >
2167+ 2AB4 BA                   cp      D               ; <- by combining last token
2168+ 2AB5 57                   ld      D,A             ; <- with current one
2169+ 2AB6 DA 9E 20             jp      C,SNERR         ; Error if "<<' '==" or ">>"
2170+ 2AB9 22 4A 61             ld      (CUROPR),HL     ; Save address of current token
2171+ 2ABC CD E7 25             call    GETCHR          ; Get next character
2172+ 2ABF C3 A6 2A             jp      RLTLP           ; Treat the two as one
2173+ 2AC2
2174+ 2AC2 7A           FOPRND: ld      A,D             ; < = > found ?
2175+ 2AC3 B7                   or      A
2176+ 2AC4 C2 02 2C             jp      NZ,TSTRED       ; Yes - Test for reduction
2177+ 2AC7 7E                   ld      A,(HL)          ; Get operator token
2178+ 2AC8 22 4A 61             ld      (CUROPR),HL     ; Save operator address
2179+ 2ACB D6 BE                sub     ZPLUS           ; Operator or function?
2180+ 2ACD D8                   ret     C               ; Neither - Exit
2181+ 2ACE FE 0A                cp      ZOR+1-ZPLUS     ; Is it + - * / ^ AND XOR OR ?
2182+ 2AD0 D0                   ret     NC              ; No - Exit
2183+ 2AD1 5F                   ld      E,A             ; Coded operator
2184+ 2AD2 3A 09 61             ld      A,(TYPE)        ; Get data type
2185+ 2AD5 3D                   dec     A               ; FF = numeric , 00 = string
2186+ 2AD6 B3                   or      E               ; Combine with coded operator
2187+ 2AD7 7B                   ld      A,E             ; Get coded operator
2188+ 2AD8 CA 76 30             jp      Z,CONCAT        ; String concatenation
2189+ 2ADB 07                   rlca                    ; Times 2
2190+ 2ADC 83                   add     A,E             ; Times 3
2191+ 2ADD 5F                   ld      E,A             ; To DE (D is 0)
2192+ 2ADE 21 19 1F             ld      HL,PRITAB       ; Precedence table
2193+ 2AE1 19                   add     HL,DE           ; To the operator concerned
2194+ 2AE2 78                   ld      A,B             ; Last operator precedence
2195+ 2AE3 56                   ld      D,(HL)          ; Get evaluation precedence
2196+ 2AE4 BA                   cp      D               ; Compare with eval precedence
2197+ 2AE5 D0                   ret     NC              ; Exit if higher precedence
2198+ 2AE6 23                   inc     HL              ; Point to routine address
2199+ 2AE7 CD 7B 2A             call    TSTNUM          ; Make sure it's a number
2200+ 2AEA
2201+ 2AEA C5           STKTHS: push    BC              ; Save last precedence & token
2202+ 2AEB 01 99 2A             ld      BC,EVAL3        ; Where to go on prec' break
2203+ 2AEE C5                   push    BC              ; Save on stack for return
2204+ 2AEF 43                   ld      B,E             ; Save operator
2205+ 2AF0 4A                   ld      C,D             ; Save precedence
2206+ 2AF1 CD B6 38             call    STAKFP          ; Move value to stack
2207+ 2AF4 58                   ld      E,B             ; Restore operator
2208+ 2AF5 51                   ld      D,C             ; Restore precedence
2209+ 2AF6 4E                   ld      C,(HL)          ; Get LSB of routine address
2210+ 2AF7 23                   inc     HL
2211+ 2AF8 46                   ld      B,(HL)          ; Get MSB of routine address
2212+ 2AF9 23                   inc     HL
2213+ 2AFA C5                   push    BC              ; Save routine address
2214+ 2AFB 2A 4A 61             ld      HL,(CUROPR)     ; Address of current operator
2215+ 2AFE C3 8D 2A             jp      EVAL1           ; Loop until prec' break
2216+ 2B01
2217+ 2B01 AF           OPRND:  xor     A               ; Get operand routine
2218+ 2B02 32 09 61             ld      (TYPE),A        ; Set numeric expected
2219+ 2B05 CD E7 25             call    GETCHR          ; Get next character
2220+ 2B08 1E 24                ld      E,MO            ; ?MO Error
2221+ 2B0A CA B8 20             jp      Z,ERROR         ; No operand - Error
2222+ 2B0D DA 8C 39             jp      C,ASCTFP        ; Number - Get value
2223+ 2B10 CD 89 26             call    CHKLTR          ; See if a letter
2224+ 2B13 D2 68 2B             jp      NC,CONVAR       ; Letter - Find variable
2225+ 2B16 FE 26                cp      '&'             ; &H = HEX, &B = BINARY
2226+ 2B18 20 12                jr      NZ,NOTAMP
2227+ 2B1A CD E7 25             call    GETCHR          ; Get next character
2228+ 2B1D FE 48                cp      'H'             ; Hex number indicated? [function added]
2229+ 2B1F CA 6D 4C             jp      Z,HEXTFP        ; Convert Hex to FPREG
2230+ 2B22 FE 42                cp      'B'             ; Binary number indicated? [function added]
2231+ 2B24 CA DD 4C             jp      Z,BINTFP        ; Convert Bin to FPREG
2232+ 2B27 1E 02                ld      E,SN            ; If neither then a ?SN Error
2233+ 2B29 CA B8 20             jp      Z,ERROR         ;
2234+ 2B2C FE BE        NOTAMP: cp      ZPLUS           ; '+' Token ?
2235+ 2B2E CA 01 2B             jp      Z,OPRND         ; Yes - Look for operand
2236+ 2B31 FE 2E                cp      '.'             ; '.' ?
2237+ 2B33 CA 8C 39             jp      Z,ASCTFP        ; Yes - Create FP number
2238+ 2B36 FE BF                cp      ZMINUS          ; '-' Token ?
2239+ 2B38 CA 57 2B             jp      Z,MINUS         ; Yes - Do minus
2240+ 2B3B FE 22                cp      $22             ; '"'             ; Literal string ?
2241+ 2B3D CA 3F 2F             jp      Z,QTSTR         ; Get string terminated by '"'
2242+ 2B40 FE BC                cp      ZNOT            ; "NOT" Token ?
2243+ 2B42 CA 62 2C             jp      Z,EVNOT         ; Yes - Eval NOT expression
2244+ 2B45 FE B9                cp      ZFN             ; "FN" Token ?
2245+ 2B47 CA A3 2E             jp      Z,DOFN          ; Yes - Do FN routine
2246+ 2B4A D6 CB                sub     ZSGN            ; Is it a function?
2247+ 2B4C D2 79 2B             jp      NC,FNOFST       ; Yes - Evaluate function
2248+ 2B4F CD 86 2A     EVLPAR: call    OPNPAR          ; Evaluate expression in "()"
2249+ 2B52 CD 9E 23             call    CHKSYN          ; Make sure ")" follows
2250+ 2B55 29                   defb    ')'
2251+ 2B56 C9                   ret
2252+ 2B57
2253+ 2B57 16 7D        MINUS:  ld      D,$7D           ; '-' precedence
2254+ 2B59 CD 8D 2A             call    EVAL1           ; Evaluate until prec' break
2255+ 2B5C 2A 55 61             ld      HL,(NXTOPR)     ; Get next operator address
2256+ 2B5F E5                   push    HL              ; Save next operator address
2257+ 2B60 CD AE 38             call    INVSGN          ; Negate value
2258+ 2B63 CD 7B 2A     RETNUM: call    TSTNUM          ; Make sure it's a number
2259+ 2B66 E1                   pop     HL              ; Restore next operator address
2260+ 2B67 C9                   ret
2261+ 2B68
2262+ 2B68 CD 87 2C     CONVAR: call    GETVAR          ; Get variable address to DE
2263+ 2B6B E5           FRMEVL: push    HL              ; Save code string address
2264+ 2B6C EB                   ex      DE,HL           ; Variable address to HL
2265+ 2B6D 22 CF 61             ld      (FPREG),HL      ; Save address of variable
2266+ 2B70 3A 09 61             ld      A,(TYPE)        ; Get type
2267+ 2B73 B7                   or      A               ; Numeric?
2268+ 2B74 CC C3 38             call    Z,PHLTFP        ; Yes - Move contents to FPREG
2269+ 2B77 E1                   pop     HL              ; Restore code string address
2270+ 2B78 C9                   ret
2271+ 2B79
2272+ 2B79 06 00        FNOFST: ld      B,$00           ; Get address of function
2273+ 2B7B 07                   rlca                    ; Double function offset
2274+ 2B7C 4F                   ld      C,A             ; BC = Offset in function table
2275+ 2B7D C5                   push    BC              ; Save adjusted token value
2276+ 2B7E CD E7 25             call    GETCHR          ; Get next character
2277+ 2B81 79                   ld      A,C             ; Get adjusted token value
2278+ 2B82 FE 2C                cp      2*(ZPOINT-ZSGN) ; "POINT" token?
2279+ 2B84 CA B0 40             jp      Z,POINT         ; Yes, do "POINT"
2280+ 2B87 FE 2E                cp      2*(ZINSTR-ZSGN) ; "INSTR" token?
2281+ 2B89 CA 52 31             jp      Z,INSTR         ; Yes, do "INSTR"
2282+ 2B8C FE 3D                cp      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
2283+ 2B8E DA AA 2B             jp      C,FNVAL         ; No - Do function
2284+ 2B91 CD 86 2A             call    OPNPAR          ; Evaluate expression  (X,...
2285+ 2B94 CD 9E 23             call    CHKSYN          ; Make sure ',' follows
2286+ 2B97 2C                   defb    ','
2287+ 2B98 CD 7C 2A             call    TSTSTR          ; Make sure it's a string
2288+ 2B9B EB                   ex      DE,HL           ; Save code string address
2289+ 2B9C 2A CF 61             ld      HL,(FPREG)      ; Get address of string
2290+ 2B9F E3                   ex      (SP),HL         ; Save address of string
2291+ 2BA0 E5                   push    HL              ; Save adjusted token value
2292+ 2BA1 EB                   ex      DE,HL           ; Restore code string address
2293+ 2BA2 CD FE 32             call    GETINT          ; Get integer 0-255
2294+ 2BA5 EB                   ex      DE,HL           ; Save code string address
2295+ 2BA6 E3                   ex      (SP),HL         ; Save integer,HL = adj' token
2296+ 2BA7 C3 B2 2B             jp      GOFUNC          ; Jump to string function
2297+ 2BAA
2298+ 2BAA CD 4F 2B     FNVAL:  call    EVLPAR          ; Evaluate expression
2299+ 2BAD E3                   ex      (SP),HL         ; HL = Adjusted token value
2300+ 2BAE 11 63 2B             ld      DE,RETNUM       ; Return number from function
2301+ 2BB1 D5                   push    DE              ; Save on stack
2302+ 2BB2 01 D6 1C     GOFUNC: ld      BC,FNCTAB       ; Function routine addresses
2303+ 2BB5 09                   add     HL,BC           ; Point to right address
2304+ 2BB6 4E                   ld      C,(HL)          ; Get LSB of address
2305+ 2BB7 23                   inc     HL              ;
2306+ 2BB8 66                   ld      H,(HL)          ; Get MSB of address
2307+ 2BB9 69                   ld      L,C             ; Address to HL
2308+ 2BBA E9                   jp      (HL)            ; Jump to function
2309+ 2BBB
2310+ 2BBB 15           SGNEXP: dec     D               ; Dee to flag negative exponent
2311+ 2BBC FE BF                cp      ZMINUS          ; '-' token ?
2312+ 2BBE C8                   ret     Z               ; Yes - Return
2313+ 2BBF FE 2D                cp      '-'             ; '-' ASCII ?
2314+ 2BC1 C8                   ret     Z               ; Yes - Return
2315+ 2BC2 14                   inc     D               ; Inc to flag positive exponent
2316+ 2BC3 FE 2B                cp      '+'             ; '+' ASCII ?
2317+ 2BC5 C8                   ret     Z               ; Yes - Return
2318+ 2BC6 FE BE                cp      ZPLUS           ; '+' token ?
2319+ 2BC8 C8                   ret     Z               ; Yes - Return
2320+ 2BC9 2B                   dec     HL              ; dec 'cos GETCHR INCs
2321+ 2BCA C9                   ret                     ; Return "NZ"
2322+ 2BCB
2323+ 2BCB              ; execute OR, AND, and XOR operations
2324+ 2BCB AF           PAND:   xor     A               ; for AND, Z=1
2325+ 2BCC 18 07                jr      CNTLGC
2326+ 2BCE AF           POR:    xor     A               ; for OR, Z=0, S=1
2327+ 2BCF D6 01                sub     $01
2328+ 2BD1 18 02                jr      CNTLGC
2329+ 2BD3 AF           PXOR:   xor     A               ; for XOR, Z=0, S=0
2330+ 2BD4 3C                   inc     A
2331+ 2BD5 F5           CNTLGC: push    AF              ; store operand's flags
2332+ 2BD6 CD 7B 2A             call    TSTNUM          ; Make sure it's a number
2333+ 2BD9 CD 9D 26             call    DEINT           ; Get integer -32768 to 32767
2334+ 2BDC F1                   pop     AF              ; retrieve operand's flags
2335+ 2BDD EB                   ex      DE,HL           ; <- Get last
2336+ 2BDE C1                   pop     BC              ; <-  value
2337+ 2BDF E3                   ex      (SP),HL         ; <-  from
2338+ 2BE0 EB                   ex      DE,HL           ; <-  stack
2339+ 2BE1 CD C6 38             call    FPBCDE          ; Move last value to FPREG
2340+ 2BE4 F5                   push    AF              ; store operand's flags
2341+ 2BE5 CD 9D 26             call    DEINT           ; Get integer -32768 to 32767
2342+ 2BE8 F1                   pop     AF              ; retrieve operand's flags
2343+ 2BE9 C1                   pop     BC              ; Get value
2344+ 2BEA 79                   ld      A,C             ; Get LSB
2345+ 2BEB 21 61 2E             ld      HL,ACPASS       ; Address of save AC as current
2346+ 2BEE 20 05                jr      NZ,POR1         ; if X/OR, jump over
2347+ 2BF0 A3           PAND1:  and     E               ; "AND" LSBs
2348+ 2BF1 4F                   ld      C,A             ; Save LSB
2349+ 2BF2 78                   ld      A,B             ; Get MSB
2350+ 2BF3 A2                   and     D               ; "AND" MSBs
2351+ 2BF4 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2352+ 2BF5 F2 FD 2B     POR1:   jp      P,PXOR1         ; if S=0, jump to XOR
2353+ 2BF8 B3                   or      E               ; "OR" LSBs
2354+ 2BF9 4F                   ld      C,A             ; Save LSB
2355+ 2BFA 78                   ld      A,B             ; Get MSB
2356+ 2BFB B2                   or      D               ; "OR" MSBs
2357+ 2BFC E9                   jp      (HL)            ; Save AC as current (ACPASS)
2358+ 2BFD AB           PXOR1:  xor     E               ; "XOR" LSBs
2359+ 2BFE 4F                   ld      C,A             ; Save LSB
2360+ 2BFF 78                   ld      A,B             ; Get MSB
2361+ 2C00 AA                   xor     D               ; "XOR" MSBs
2362+ 2C01 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2363+ 2C02
2364+ 2C02 21 14 2C     TSTRED: ld      HL,CMPLOG       ; Logical compare routine
2365+ 2C05 3A 09 61             ld      A,(TYPE)        ; Get data type
2366+ 2C08 1F                   rra                     ; Carry set = string
2367+ 2C09 7A                   ld      A,D             ; Get last precedence value
2368+ 2C0A 17                   rla                     ; Times 2 plus carry
2369+ 2C0B 5F                   ld      E,A             ; To E
2370+ 2C0C 16 64                ld      D,$64           ; Relational precedence
2371+ 2C0E 78                   ld      A,B             ; Get current precedence
2372+ 2C0F BA                   cp      D               ; Compare with last
2373+ 2C10 D0                   ret     NC              ; Eval if last was rel' or log'
2374+ 2C11 C3 EA 2A             jp      STKTHS          ; Stack this one and get next
2375+ 2C14
2376+ 2C14 16 2C        CMPLOG: defw    CMPLG1          ; Compare two values / strings
2377+ 2C16 79           CMPLG1: ld      A,C             ; Get data type
2378+ 2C17 B7                   or      A
2379+ 2C18 1F                   rra
2380+ 2C19 C1                   pop     BC              ; Get last expression to BCDE
2381+ 2C1A D1                   pop     DE
2382+ 2C1B F5                   push    AF              ; Save status
2383+ 2C1C CD 7D 2A             call    CHKTYP          ; Check that types match
2384+ 2C1F 21 58 2C             ld      HL,CMPRES       ; Result to comparison
2385+ 2C22 E5                   push    HL              ; Save for RETurn
2386+ 2C23 CA 00 39             jp      Z,CMPNUM        ; Compare values if numeric
2387+ 2C26 AF                   xor     A               ; Compare two strings
2388+ 2C27 32 09 61             ld      (TYPE),A        ; Set type to numeric
2389+ 2C2A D5                   push    DE              ; Save string name
2390+ 2C2B CD C3 30             call    GSTRCU          ; Get current string
2391+ 2C2E 7E                   ld      A,(HL)          ; Get length of string
2392+ 2C2F 23                   inc     HL
2393+ 2C30 23                   inc     HL
2394+ 2C31 4E                   ld      C,(HL)          ; Get LSB of address
2395+ 2C32 23                   inc     HL
2396+ 2C33 46                   ld      B,(HL)          ; Get MSB of address
2397+ 2C34 D1                   pop     DE              ; Restore string name
2398+ 2C35 C5                   push    BC              ; Save address of string
2399+ 2C36 F5                   push    AF              ; Save length of string
2400+ 2C37 CD C7 30             call    GSTRDE          ; Get second string
2401+ 2C3A CD D4 38             call    LOADFP          ; Get address of second string
2402+ 2C3D F1                   pop     AF              ; Restore length of string 1
2403+ 2C3E 57                   ld      D,A             ; Length to D
2404+ 2C3F E1                   pop     HL              ; Restore address of string 1
2405+ 2C40 7B           CMPSTR: ld      A,E             ; Bytes of string 2 to do
2406+ 2C41 B2                   or      D               ; Bytes of string 1 to do
2407+ 2C42 C8                   ret     Z               ; Exit if all bytes compared
2408+ 2C43 7A                   ld      A,D             ; Get bytes of string 1 to do
2409+ 2C44 D6 01                sub     $01
2410+ 2C46 D8                   ret     C               ; Exit if end of string 1
2411+ 2C47 AF                   xor     A
2412+ 2C48 BB                   cp      E               ; Bytes of string 2 to do
2413+ 2C49 3C                   inc     A
2414+ 2C4A D0                   ret     NC              ; Exit if end of string 2
2415+ 2C4B 15                   dec     D               ; Count bytes in string 1
2416+ 2C4C 1D                   dec     E               ; Count bytes in string 2
2417+ 2C4D 0A                   ld      A,(BC)          ; Byte in string 2
2418+ 2C4E BE                   cp      (HL)            ; Compare to byte in string 1
2419+ 2C4F 23                   inc     HL              ; Move up string 1
2420+ 2C50 03                   inc     BC              ; Move up string 2
2421+ 2C51 CA 40 2C             jp      Z,CMPSTR        ; Same - Try next bytes
2422+ 2C54 3F                   ccf                     ; Flag difference (">" or "<")
2423+ 2C55 C3 90 38             jp      FLGDIF          ; "<" gives -1 , ">" gives +1
2424+ 2C58
2425+ 2C58 3C           CMPRES: inc     A               ; Increment current value
2426+ 2C59 8F                   adc     A,A             ; Double plus carry
2427+ 2C5A C1                   pop     BC              ; Get other value
2428+ 2C5B A0                   and     B               ; Combine them
2429+ 2C5C C6 FF                add     A,-1            ; Carry set if different
2430+ 2C5E 9F                   sbc     A,A             ; 00 - Equal , FF - Different
2431+ 2C5F C3 97 38             jp      FLGREL          ; Set current value & continue
2432+ 2C62
2433+ 2C62 16 5A        EVNOT:  ld      D,$5A           ; Precedence value for "NOT"
2434+ 2C64 CD 8D 2A             call    EVAL1           ; Eval until precedence break
2435+ 2C67 CD 7B 2A             call    TSTNUM          ; Make sure it's a number
2436+ 2C6A CD 9D 26             call    DEINT           ; Get integer -32768 - 32767
2437+ 2C6D 7B                   ld      A,E             ; Get LSB
2438+ 2C6E 2F                   cpl                     ; Invert LSB
2439+ 2C6F 4F                   ld      C,A             ; Save "NOT" of LSB
2440+ 2C70 7A                   ld      A,D             ; Get MSB
2441+ 2C71 2F                   cpl                     ; Invert MSB
2442+ 2C72 CD 61 2E             call    ACPASS          ; Save AC as current
2443+ 2C75 C1                   pop     BC              ; Clean up stack
2444+ 2C76 C3 99 2A             jp      EVAL3           ; Continue evaluation
2445+ 2C79
2446+ 2C79 2B           DIMRET: dec     HL              ; dec 'cos GETCHR INCs
2447+ 2C7A CD E7 25             call    GETCHR          ; Get next character
2448+ 2C7D C8                   ret     Z               ; End of DIM statement
2449+ 2C7E CD 9E 23             call    CHKSYN          ; Make sure ',' follows
2450+ 2C81 2C                   defb    ','
2451+ 2C82 01 79 2C     DIM:    ld      BC,DIMRET       ; Return to "DIMRET"
2452+ 2C85 C5                   push    BC              ; Save on stack
2453+ 2C86 F6                   defb    $F6             ; Flag "Create" variable
2454+ 2C87 AF           GETVAR: xor     A               ; Find variable address,to DE
2455+ 2C88 32 08 61             ld      (LCRFLG),A      ; Set locate / create flag
2456+ 2C8B 46                   ld      B,(HL)          ; Get First byte of name
2457+ 2C8C CD 89 26     GTFNAM: call    CHKLTR          ; See if a letter
2458+ 2C8F DA 9E 20             jp      C,SNERR         ; ?SN Error if not a letter
2459+ 2C92 AF                   xor     A
2460+ 2C93 4F                   ld      C,A             ; Clear second byte of name
2461+ 2C94 32 09 61             ld      (TYPE),A        ; Set type to numeric
2462+ 2C97 CD E7 25             call    GETCHR          ; Get next character
2463+ 2C9A DA A3 2C             jp      C,SVNAM2        ; Numeric - Save in name
2464+ 2C9D CD 89 26             call    CHKLTR          ; See if a letter
2465+ 2CA0 DA B0 2C             jp      C,CHARTY        ; Not a letter - Check type
2466+ 2CA3 4F           SVNAM2: ld      C,A             ; Save second byte of name
2467+ 2CA4 CD E7 25     ENDNAM: call    GETCHR          ; Get next character
2468+ 2CA7 DA A4 2C             jp      C,ENDNAM        ; Numeric - Get another
2469+ 2CAA CD 89 26             call    CHKLTR          ; See if a letter
2470+ 2CAD D2 A4 2C             jp      NC,ENDNAM       ; Letter - Get another
2471+ 2CB0 D6 24        CHARTY: sub     '$'             ; String variable?
2472+ 2CB2 C2 BF 2C             jp      NZ,NOTSTR       ; No - Numeric variable
2473+ 2CB5 3C                   inc     A               ; A = 1 (string type)
2474+ 2CB6 32 09 61             ld      (TYPE),A        ; Set type to string
2475+ 2CB9 0F                   rrca                    ; A = 80H , Flag for string
2476+ 2CBA 81                   add     A,C             ; 2nd byte of name has bit 7 on
2477+ 2CBB 4F                   ld      C,A             ; Resave second byte on name
2478+ 2CBC CD E7 25             call    GETCHR          ; Get next character
2479+ 2CBF 3A 50 61     NOTSTR: ld      A,(FORFLG)      ; Array name needed ?
2480+ 2CC2 3D                   dec     A
2481+ 2CC3 CA 6C 2D             jp      Z,ARLDSV        ; Yes - Get array name
2482+ 2CC6 F2 CF 2C             jp      P,NSCFOR        ; No array with "FOR" or "FN"
2483+ 2CC9 7E                   ld      A,(HL)          ; Get byte again
2484+ 2CCA D6 28                sub     '('             ; Subscripted variable?
2485+ 2CCC CA 44 2D             jp      Z,SBSCPT        ; Yes - Sort out subscript
2486+ 2CCF
2487+ 2CCF AF           NSCFOR: xor     A               ; Simple variable
2488+ 2CD0 32 50 61             ld      (FORFLG),A      ; Clear "FOR" flag
2489+ 2CD3 E5                   push    HL              ; Save code string address
2490+ 2CD4 50                   ld      D,B             ; DE = Variable name to find
2491+ 2CD5 59                   ld      E,C
2492+ 2CD6 2A C9 61             ld      HL,(FNRGNM)     ; FN argument name
2493+ 2CD9 CD 98 23             call    CPDEHL          ; Is it the FN argument?
2494+ 2CDC 11 CB 61             ld      DE,FNARG        ; Point to argument value
2495+ 2CDF CA 75 37             jp      Z,POPHRT        ; Yes - Return FN argument value
2496+ 2CE2 2A C3 61             ld      HL,(VAREND)     ; End of variables
2497+ 2CE5 EB                   ex      DE,HL           ; Address of end of search
2498+ 2CE6 2A C1 61             ld      HL,(PROGND)     ; Start of variables address
2499+ 2CE9 CD 98 23     FNDVAR: call    CPDEHL          ; End of variable list table?
2500+ 2CEC CA 02 2D             jp      Z,CFEVAL        ; Yes - Called from EVAL?
2501+ 2CEF 79                   ld      A,C             ; Get second byte of name
2502+ 2CF0 96                   sub     (HL)            ; Compare with name in list
2503+ 2CF1 23                   inc     HL              ; Move on to first byte
2504+ 2CF2 C2 F7 2C             jp      NZ,FNTHR        ; Different - Find another
2505+ 2CF5 78                   ld      A,B             ; Get first byte of name
2506+ 2CF6 96                   sub     (HL)            ; Compare with name in list
2507+ 2CF7 23           FNTHR:  inc     HL              ; Move on to LSB of value
2508+ 2CF8 CA 36 2D             jp      Z,RETADR        ; Found - Return address
2509+ 2CFB 23                   inc     HL              ; <- Skip
2510+ 2CFC 23                   inc     HL              ; <- over
2511+ 2CFD 23                   inc     HL              ; <- F.P.
2512+ 2CFE 23                   inc     HL              ; <- value
2513+ 2CFF C3 E9 2C             jp      FNDVAR          ; Keep looking
2514+ 2D02
2515+ 2D02 E1           CFEVAL: pop     HL              ; Restore code string address
2516+ 2D03 E3                   ex      (SP),HL         ; Get return address
2517+ 2D04 D5                   push    DE              ; Save address of variable
2518+ 2D05 11 6B 2B             ld      DE,FRMEVL       ; Return address in EVAL
2519+ 2D08 CD 98 23             call    CPDEHL          ; Called from EVAL ?
2520+ 2D0B D1                   pop     DE              ; Restore address of variable
2521+ 2D0C CA 39 2D             jp      Z,RETNUL        ; Yes - Return null variable
2522+ 2D0F E3                   ex      (SP),HL         ; Put back return
2523+ 2D10 E5                   push    HL              ; Save code string address
2524+ 2D11 C5                   push    BC              ; Save variable name
2525+ 2D12 01 06 00             ld      BC,$0006        ; 2 byte name plus 4 byte data
2526+ 2D15 2A C5 61             ld      HL,(ARREND)     ; End of arrays
2527+ 2D18 E5                   push    HL              ; Save end of arrays
2528+ 2D19 09                   add     HL,BC           ; Move up 6 bytes
2529+ 2D1A C1                   pop     BC              ; Source address in BC
2530+ 2D1B E5                   push    HL              ; Save new end address
2531+ 2D1C CD 4A 20             call    MOVUP           ; Move arrays up
2532+ 2D1F E1                   pop     HL              ; Restore new end address
2533+ 2D20 22 C5 61             ld      (ARREND),HL     ; Set new end address
2534+ 2D23 60                   ld      H,B             ; End of variables to HL
2535+ 2D24 69                   ld      L,C
2536+ 2D25 22 C3 61             ld      (VAREND),HL     ; Set new end address
2537+ 2D28
2538+ 2D28 2B           ZEROLP: dec     HL              ; Back through to zero variable
2539+ 2D29 36 00                ld      (HL),$00        ; Zero byte in variable
2540+ 2D2B CD 98 23             call    CPDEHL          ; Done them all?
2541+ 2D2E C2 28 2D             jp      NZ,ZEROLP       ; No - Keep on going
2542+ 2D31 D1                   pop     DE              ; Get variable name
2543+ 2D32 73                   ld      (HL),E          ; Store second character
2544+ 2D33 23                   inc     HL
2545+ 2D34 72                   ld      (HL),D          ; Store first character
2546+ 2D35 23                   inc     HL
2547+ 2D36 EB           RETADR: ex      DE,HL           ; Address of variable in DE
2548+ 2D37 E1                   pop     HL              ; Restore code string address
2549+ 2D38 C9                   ret
2550+ 2D39
2551+ 2D39 32 D2 61     RETNUL: ld      (FPEXP),A       ; Set result to zero
2552+ 2D3C 21 1B 20             ld      HL,ZERBYT       ; Also set a null string
2553+ 2D3F 22 CF 61             ld      (FPREG),HL      ; Save for EVAL
2554+ 2D42 E1                   pop     HL              ; Restore code string address
2555+ 2D43 C9                   ret
2556+ 2D44
2557+ 2D44 E5           SBSCPT: push    HL              ; Save code string address
2558+ 2D45 2A 08 61             ld      HL,(LCRFLG)     ; Locate/Create and Type
2559+ 2D48 E3                   ex      (SP),HL         ; Save and get code string
2560+ 2D49 57                   ld      D,A             ; Zero number of dimensions
2561+ 2D4A D5           SCPTLP: push    DE              ; Save number of dimensions
2562+ 2D4B C5                   push    BC              ; Save array name
2563+ 2D4C CD 91 26             call    FPSINT          ; Get subscript (0-32767)
2564+ 2D4F C1                   pop     BC              ; Restore array name
2565+ 2D50 F1                   pop     AF              ; Get number of dimensions
2566+ 2D51 EB                   ex      DE,HL
2567+ 2D52 E3                   ex      (SP),HL         ; Save subscript value
2568+ 2D53 E5                   push    HL              ; Save LCRFLG and TYPE
2569+ 2D54 EB                   ex      DE,HL
2570+ 2D55 3C                   inc     A               ; Count dimensions
2571+ 2D56 57                   ld      D,A             ; Save in D
2572+ 2D57 7E                   ld      A,(HL)          ; Get next byte in code string
2573+ 2D58 FE 2C                cp      ','             ; Comma (more to come)?
2574+ 2D5A CA 4A 2D             jp      Z,SCPTLP        ; Yes - More subscripts
2575+ 2D5D CD 9E 23             call    CHKSYN          ; Make sure ")" follows
2576+ 2D60 29                   defb    ')'
2577+ 2D61 22 55 61             ld      (NXTOPR),HL     ; Save code string address
2578+ 2D64 E1                   pop     HL              ; Get LCRFLG and TYPE
2579+ 2D65 22 08 61             ld      (LCRFLG),HL     ; Restore Locate/create & type
2580+ 2D68 1E 00                ld      E,$00           ; Flag not CSAVE* or CLOAD*
2581+ 2D6A D5                   push    DE              ; Save number of dimensions (D)
2582+ 2D6B 11                   defb    $11             ; Skip "push HL" and "push AF'
2583+ 2D6C
2584+ 2D6C E5           ARLDSV: push    HL              ; Save code string address
2585+ 2D6D F5                   push    AF              ; A = 00 , Flags set = Z,N
2586+ 2D6E 2A C3 61             ld      HL,(VAREND)     ; Start of arrays
2587+ 2D71 3E                   defb    $3E             ; Skip "add HL,DE"
2588+ 2D72 19           FNDARY: add     HL,DE           ; Move to next array start
2589+ 2D73 EB                   ex      DE,HL
2590+ 2D74 2A C5 61             ld      HL,(ARREND)     ; End of arrays
2591+ 2D77 EB                   ex      DE,HL           ; Current array pointer
2592+ 2D78 CD 98 23             call    CPDEHL          ; End of arrays found?
2593+ 2D7B CA A4 2D             jp      Z,CREARY        ; Yes - Create array
2594+ 2D7E 7E                   ld      A,(HL)          ; Get second byte of name
2595+ 2D7F B9                   cp      C               ; Compare with name given
2596+ 2D80 23                   inc     HL              ; Move on
2597+ 2D81 C2 86 2D             jp      NZ,NXTARY       ; Different - Find next array
2598+ 2D84 7E                   ld      A,(HL)          ; Get first byte of name
2599+ 2D85 B8                   cp      B               ; Compare with name given
2600+ 2D86 23           NXTARY: inc     HL              ; Move on
2601+ 2D87 5E                   ld      E,(HL)          ; Get LSB of next array address
2602+ 2D88 23                   inc     HL
2603+ 2D89 56                   ld      D,(HL)          ; Get MSB of next array address
2604+ 2D8A 23                   inc     HL
2605+ 2D8B C2 72 2D             jp      NZ,FNDARY       ; Not found - Keep looking
2606+ 2D8E 3A 08 61             ld      A,(LCRFLG)      ; Found Locate or Create it?
2607+ 2D91 B7                   or      A
2608+ 2D92 C2 A7 20             jp      NZ,DDERR        ; Create - ?DD Error
2609+ 2D95 F1                   pop     AF              ; Locate - Get number of dim'ns
2610+ 2D96 44                   ld      B,H             ; BC Points to array dim'ns
2611+ 2D97 4D                   ld      C,L
2612+ 2D98 CA 75 37             jp      Z,POPHRT        ; Jump if array load/save
2613+ 2D9B 96                   sub     (HL)            ; Same number of dimensions?
2614+ 2D9C CA 02 2E             jp      Z,FINDEL        ; Yes - Find element
2615+ 2D9F 1E 10        BSERR:  ld      E,BS            ; ?BS Error
2616+ 2DA1 C3 B8 20             jp      ERROR           ; Output error
2617+ 2DA4
2618+ 2DA4 11 04 00     CREARY: ld      DE,$0004        ; 4 Bytes per entry
2619+ 2DA7 F1                   pop     AF              ; Array to save or 0 dim'ns?
2620+ 2DA8 CA B2 26             jp      Z,FCERR         ; Yes - ?FC Error
2621+ 2DAB 71                   ld      (HL),C          ; Save second byte of name
2622+ 2DAC 23                   inc     HL
2623+ 2DAD 70                   ld      (HL),B          ; Save first byte of name
2624+ 2DAE 23                   inc     HL
2625+ 2DAF 4F                   ld      C,A             ; Number of dimensions to C
2626+ 2DB0 CD 5B 20             call    CHKSTK          ; Check if enough memory
2627+ 2DB3 23                   inc     HL              ; Point to number of dimensions
2628+ 2DB4 23                   inc     HL
2629+ 2DB5 22 4A 61             ld      (CUROPR),HL     ; Save address of pointer
2630+ 2DB8 71                   ld      (HL),C          ; Set number of dimensions
2631+ 2DB9 23                   inc     HL
2632+ 2DBA 3A 08 61             ld      A,(LCRFLG)      ; Locate of Create?
2633+ 2DBD 17                   rla                     ; Carry set = Create
2634+ 2DBE 79                   ld      A,C             ; Get number of dimensions
2635+ 2DBF 01 0B 00     CRARLP: ld      BC,10+1         ; Default dimension size 10
2636+ 2DC2 D2 C7 2D             jp      NC,DEFSIZ       ; Locate - Set default size
2637+ 2DC5 C1                   pop     BC              ; Get specified dimension size
2638+ 2DC6 03                   inc     BC              ; Include zero element
2639+ 2DC7 71           DEFSIZ: ld      (HL),C          ; Save LSB of dimension size
2640+ 2DC8 23                   inc     HL
2641+ 2DC9 70                   ld      (HL),B          ; Save MSB of dimension size
2642+ 2DCA 23                   inc     HL
2643+ 2DCB F5                   push    AF              ; Save num' of dim'ns an status
2644+ 2DCC E5                   push    HL              ; Save address of dim'n size
2645+ 2DCD CD 71 39             call    MLDEBC          ; Multiply DE by BC to find
2646+ 2DD0 EB                   ex      DE,HL           ; amount of mem needed (to DE)
2647+ 2DD1 E1                   pop     HL              ; Restore address of dimension
2648+ 2DD2 F1                   pop     AF              ; Restore number of dimensions
2649+ 2DD3 3D                   dec     A               ; Count them
2650+ 2DD4 C2 BF 2D             jp      NZ,CRARLP       ; Do next dimension if more
2651+ 2DD7 F5                   push    AF              ; Save locate/create flag
2652+ 2DD8 42                   ld      B,D             ; MSB of memory needed
2653+ 2DD9 4B                   ld      C,E             ; LSB of memory needed
2654+ 2DDA EB                   ex      DE,HL
2655+ 2DDB 19                   add     HL,DE           ; Add bytes to array start
2656+ 2DDC DA 73 20             jp      C,OMERR         ; Too big - Error
2657+ 2DDF CD 64 20             call    ENFMEM          ; See if enough memory
2658+ 2DE2 22 C5 61             ld      (ARREND),HL     ; Save new end of array
2659+ 2DE5
2660+ 2DE5 2B           ZERARY: dec     HL              ; Back through array data
2661+ 2DE6 36 00                ld      (HL),$00        ; Set array element to zero
2662+ 2DE8 CD 98 23             call    CPDEHL          ; All elements zeroed?
2663+ 2DEB C2 E5 2D             jp      NZ,ZERARY       ; No - Keep on going
2664+ 2DEE 03                   inc     BC              ; Number of bytes + 1
2665+ 2DEF 57                   ld      D,A             ; A=0
2666+ 2DF0 2A 4A 61             ld      HL,(CUROPR)     ; Get address of array
2667+ 2DF3 5E                   ld      E,(HL)          ; Number of dimensions
2668+ 2DF4 EB                   ex      DE,HL           ; To HL
2669+ 2DF5 29                   add     HL,HL           ; Two bytes per dimension size
2670+ 2DF6 09                   add     HL,BC           ; Add number of bytes
2671+ 2DF7 EB                   ex      DE,HL           ; Bytes needed to DE
2672+ 2DF8 2B                   dec     HL
2673+ 2DF9 2B                   dec     HL
2674+ 2DFA 73                   ld      (HL),E          ; Save LSB of bytes needed
2675+ 2DFB 23                   inc     HL
2676+ 2DFC 72                   ld      (HL),D          ; Save MSB of bytes needed
2677+ 2DFD 23                   inc     HL
2678+ 2DFE F1                   pop     AF              ; Locate / Create?
2679+ 2DFF DA 26 2E             jp      C,ENDDIM        ; A is 0 , End if create
2680+ 2E02 47           FINDEL: ld      B,A             ; Find array element
2681+ 2E03 4F                   ld      C,A
2682+ 2E04 7E                   ld      A,(HL)          ; Number of dimensions
2683+ 2E05 23                   inc     HL
2684+ 2E06 16                   defb    $16             ; Skip "pop HL"
2685+ 2E07 E1           FNDELP: pop     HL              ; Address of next dim' size
2686+ 2E08 5E                   ld      E,(HL)          ; Get LSB of dim'n size
2687+ 2E09 23                   inc     HL
2688+ 2E0A 56                   ld      D,(HL)          ; Get MSB of dim'n size
2689+ 2E0B 23                   inc     HL
2690+ 2E0C E3                   ex      (SP),HL         ; Save address - Get index
2691+ 2E0D F5                   push    AF              ; Save number of dim'ns
2692+ 2E0E CD 98 23             call    CPDEHL          ; Dimension too large?
2693+ 2E11 D2 9F 2D             jp      NC,BSERR        ; Yes - ?BS Error
2694+ 2E14 E5                   push    HL              ; Save index
2695+ 2E15 CD 71 39             call    MLDEBC          ; Multiply previous by size
2696+ 2E18 D1                   pop     DE              ; Index supplied to DE
2697+ 2E19 19                   add     HL,DE           ; Add index to pointer
2698+ 2E1A F1                   pop     AF              ; Number of dimensions
2699+ 2E1B 3D                   dec     A               ; Count them
2700+ 2E1C 44                   ld      B,H             ; MSB of pointer
2701+ 2E1D 4D                   ld      C,L             ; LSB of pointer
2702+ 2E1E C2 07 2E             jp      NZ,FNDELP       ; More - Keep going
2703+ 2E21 29                   add     HL,HL           ; 4 Bytes per element
2704+ 2E22 29                   add     HL,HL
2705+ 2E23 C1                   pop     BC              ; Start of array
2706+ 2E24 09                   add     HL,BC           ; Point to element
2707+ 2E25 EB                   ex      DE,HL           ; Address of element to DE
2708+ 2E26 2A 55 61     ENDDIM: ld      HL,(NXTOPR)     ; Got code string address
2709+ 2E29 C9                   ret
2710+ 2E2A
2711+ 2E2A
2712+ 2E2A              ; returns the value of the 32-bit system tick counter as
2713+ 2E2A              ; two 16-bit words
2714+ 2E2A CD 7B 2A     TMR:    call    TSTNUM          ; Make sure it's a number
2715+ 2E2D CD 9D 26             call    DEINT           ; Get integer (-32768 to 32767)
2716+ 2E30 2A 5B 61             ld      HL,(TMRCNT)     ; load the LSBytes of timer
2717+ 2E33 7B                   ld      A,E
2718+ 2E34 B2                   or      D               ; is it 0?
2719+ 2E35 CA 3B 2E             jp      Z,ENDTMR        ; yes, jump over
2720+ 2E38 2A 5D 61             ld      HL,(TMRCNT+2)   ; load the MSBytes of timer
2721+ 2E3B 45           ENDTMR: ld      B,L             ; move bytes...
2722+ 2E3C 7C                   ld      A,H             ; ...into AB
2723+ 2E3D C3 62 2E             jp      ABPASS          ; return word into AB
2724+ 2E40
2725+ 2E40
2726+ 2E40              ; returns the free space for BASIC or into the string pool
2727+ 2E40 2A C5 61     FRE:    ld      HL,(ARREND)     ; Start of free memory
2728+ 2E43 EB                   ex      DE,HL           ; To DE
2729+ 2E44 21 00 00             ld      HL,$0000        ; End of free memory
2730+ 2E47 39                   add     HL,SP           ; Current stack value
2731+ 2E48 3A 09 61             ld      A,(TYPE)        ; Dummy argument type
2732+ 2E4B B7                   or      A
2733+ 2E4C CA 5C 2E             jp      Z,FRENUM        ; Numeric - Free variable space
2734+ 2E4F CD C3 30             call    GSTRCU          ; Current string to pool
2735+ 2E52 CD C3 2F             call    GARBGE          ; Garbage collection
2736+ 2E55 2A 22 60             ld      HL,(STRSPC)     ; Bottom of string space in use
2737+ 2E58 EB                   ex      DE,HL           ; To DE
2738+ 2E59 2A 48 61             ld      HL,(STRBOT)     ; Bottom of string space
2739+ 2E5C 7D           FRENUM: ld      A,L             ; Get LSB of end
2740+ 2E5D 93                   sub     E               ; Subtract LSB of beginning
2741+ 2E5E 4F                   ld      C,A             ; Save difference if C
2742+ 2E5F 7C                   ld      A,H             ; Get MSB of end
2743+ 2E60 9A                   sbc     A,D             ; Subtract MSB of beginning
2744+ 2E61 41           ACPASS: ld      B,C             ; Return integer AC
2745+ 2E62 50           ABPASS: ld      D,B             ; Return integer AB
2746+ 2E63 1E 00                ld      E,$00
2747+ 2E65 21 09 61             ld      HL,TYPE         ; Point to type
2748+ 2E68 73                   ld      (HL),E          ; Set type to numeric
2749+ 2E69 06 90                ld      B,$80+$10       ; 16 bit integer
2750+ 2E6B C3 9C 38             jp      RETINT          ; Return the integer
2751+ 2E6E
2752+ 2E6E              ; returns the X position of the cursor during a print
2753+ 2E6E 3A 07 61     POS:    ld      A,(CURPOS)      ; Get cursor position
2754+ 2E71              ; return the value in A as a number
2755+ 2E71 47           PASSA:  ld      B,A             ; Put A into AB
2756+ 2E72 AF                   xor     A               ; Zero A
2757+ 2E73 C3 62 2E             jp      ABPASS          ; Return integer AB
2758+ 2E76
2759+ 2E76 CD F9 2E     DEF:    call    CHEKFN          ; Get "FN" and name
2760+ 2E79 CD EB 2E             call    IDTEST          ; Test for illegal direct
2761+ 2E7C 01 90 27             ld      BC,DATA         ; To get next statement
2762+ 2E7F C5                   push    BC              ; Save address for RETurn
2763+ 2E80 D5                   push    DE              ; Save address of function ptr
2764+ 2E81 CD 9E 23             call    CHKSYN          ; Make sure "(" follows
2765+ 2E84 28                   defb    '('
2766+ 2E85 CD 87 2C             call    GETVAR          ; Get argument variable name
2767+ 2E88 E5                   push    HL              ; Save code string address
2768+ 2E89 EB                   ex      DE,HL           ; Argument address to HL
2769+ 2E8A 2B                   dec     HL
2770+ 2E8B 56                   ld      D,(HL)          ; Get first byte of arg name
2771+ 2E8C 2B                   dec     HL
2772+ 2E8D 5E                   ld      E,(HL)          ; Get second byte of arg name
2773+ 2E8E E1                   pop     HL              ; Restore code string address
2774+ 2E8F CD 7B 2A             call    TSTNUM          ; Make sure numeric argument
2775+ 2E92 CD 9E 23             call    CHKSYN          ; Make sure ")" follows
2776+ 2E95 29                   defb    ')'
2777+ 2E96 CD 9E 23             call    CHKSYN          ; Make sure "=" follows
2778+ 2E99 C9                   defb    ZEQUAL          ; "=" token
2779+ 2E9A 44                   ld      B,H             ; Code string address to BC
2780+ 2E9B 4D                   ld      C,L
2781+ 2E9C E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2782+ 2E9D 71                   ld      (HL),C          ; Save LSB of FN code string
2783+ 2E9E 23                   inc     HL
2784+ 2E9F 70                   ld      (HL),B          ; Save MSB of FN code string
2785+ 2EA0 C3 38 2F             jp      SVSTAD          ; Save address and do function
2786+ 2EA3
2787+ 2EA3 CD F9 2E     DOFN:   call    CHEKFN          ; Make sure FN follows
2788+ 2EA6 D5                   push    DE              ; Save function pointer address
2789+ 2EA7 CD 4F 2B             call    EVLPAR          ; Evaluate expression in "()"
2790+ 2EAA CD 7B 2A             call    TSTNUM          ; Make sure numeric result
2791+ 2EAD E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2792+ 2EAE 5E                   ld      E,(HL)          ; Get LSB of FN code string
2793+ 2EAF 23                   inc     HL
2794+ 2EB0 56                   ld      D,(HL)          ; Get MSB of FN code string
2795+ 2EB1 23                   inc     HL
2796+ 2EB2 7A                   ld      A,D             ; And function DEFined?
2797+ 2EB3 B3                   or      E
2798+ 2EB4 CA AA 20             jp      Z,UFERR         ; No - ?UF Error
2799+ 2EB7 7E                   ld      A,(HL)          ; Get LSB of argument address
2800+ 2EB8 23                   inc     HL
2801+ 2EB9 66                   ld      H,(HL)          ; Get MSB of argument address
2802+ 2EBA 6F                   ld      L,A             ; HL = Arg variable address
2803+ 2EBB E5                   push    HL              ; Save it
2804+ 2EBC 2A C9 61             ld      HL,(FNRGNM)     ; Get old argument name
2805+ 2EBF E3                   ex      (SP),HL         ; Save old , Get new
2806+ 2EC0 22 C9 61             ld      (FNRGNM),HL     ; Set new argument name
2807+ 2EC3 2A CD 61             ld      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2808+ 2EC6 E5                   push    HL              ; Save it
2809+ 2EC7 2A CB 61             ld      HL,(FNARG)      ; Get MSB,EXP of old arg value
2810+ 2ECA E5                   push    HL              ; Save it
2811+ 2ECB 21 CB 61             ld      HL,FNARG        ; HL = Value of argument
2812+ 2ECE D5                   push    DE              ; Save FN code string address
2813+ 2ECF CD DD 38             call    FPTHL           ; Move FPREG to argument
2814+ 2ED2 E1                   pop     HL              ; Get FN code string address
2815+ 2ED3 CD 78 2A             call    GETNUM          ; Get value from function
2816+ 2ED6 2B                   dec     HL              ; dec 'cos GETCHR INCs
2817+ 2ED7 CD E7 25             call    GETCHR          ; Get next character
2818+ 2EDA C2 9E 20             jp      NZ,SNERR        ; Bad character in FN - Error
2819+ 2EDD E1                   pop     HL              ; Get MSB,EXP of old arg
2820+ 2EDE 22 CB 61             ld      (FNARG),HL      ; Restore it
2821+ 2EE1 E1                   pop     HL              ; Get LSB,NLSB of old arg
2822+ 2EE2 22 CD 61             ld      (FNARG+2),HL    ; Restore it
2823+ 2EE5 E1                   pop     HL              ; Get name of old arg
2824+ 2EE6 22 C9 61             ld      (FNRGNM),HL     ; Restore it
2825+ 2EE9 E1                   pop     HL              ; Restore code string address
2826+ 2EEA C9                   ret
2827+ 2EEB
2828+ 2EEB E5           IDTEST: push    HL              ; Save code string address
2829+ 2EEC 2A 24 60             ld      HL,(LINEAT)     ; Get current line number
2830+ 2EEF 23                   inc     HL              ; -1 means direct statement
2831+ 2EF0 7C                   ld      A,H
2832+ 2EF1 B5                   or      L
2833+ 2EF2 E1                   pop     HL              ; Restore code string address
2834+ 2EF3 C0                   ret     NZ              ; Return if in program
2835+ 2EF4 1E 16                ld      E,ID            ; ?ID Error
2836+ 2EF6 C3 B8 20             jp      ERROR
2837+ 2EF9
2838+ 2EF9 CD 9E 23     CHEKFN: call    CHKSYN          ; Make sure FN follows
2839+ 2EFC B9                   defb    ZFN             ; "FN" token
2840+ 2EFD 3E 80                ld      A,$80
2841+ 2EFF 32 50 61             ld      (FORFLG),A      ; Flag FN name to find
2842+ 2F02 B6                   or      (HL)            ; FN name has bit 7 set
2843+ 2F03 47                   ld      B,A             ; in first byte of name
2844+ 2F04 CD 8C 2C             call    GTFNAM          ; Get FN name
2845+ 2F07 C3 7B 2A             jp      TSTNUM          ; Make sure numeric function
2846+ 2F0A
2847+ 2F0A CD 7B 2A     STR:    call    TSTNUM          ; Make sure it's a number
2848+ 2F0D CD 2A 3A             call    NUMASC          ; Turn number into text
2849+ 2F10 CD 3E 2F     STR1:   call    CRTST           ; Create string entry for it
2850+ 2F13 CD C3 30             call    GSTRCU          ; Current string to pool
2851+ 2F16 01 1E 31             ld      BC,TOPOOL       ; Save in string pool
2852+ 2F19 C5                   push    BC              ; Save address on stack
2853+ 2F1A
2854+ 2F1A 7E           SAVSTR: ld      A,(HL)          ; Get string length
2855+ 2F1B 23                   inc     HL
2856+ 2F1C 23                   inc     HL
2857+ 2F1D E5                   push    HL              ; Save pointer to string
2858+ 2F1E CD 99 2F             call    TESTR           ; See if enough string space
2859+ 2F21 E1                   pop     HL              ; Restore pointer to string
2860+ 2F22 4E                   ld      C,(HL)          ; Get LSB of address
2861+ 2F23 23                   inc     HL
2862+ 2F24 46                   ld      B,(HL)          ; Get MSB of address
2863+ 2F25 CD 32 2F             call    CRTMST          ; Create string entry
2864+ 2F28 E5                   push    HL              ; Save pointer to MSB of addr
2865+ 2F29 6F                   ld      L,A             ; Length of string
2866+ 2F2A CD B6 30             call    TOSTRA          ; Move to string area
2867+ 2F2D D1                   pop     DE              ; Restore pointer to MSB
2868+ 2F2E C9                   ret
2869+ 2F2F
2870+ 2F2F CD 99 2F     MKTMST: call    TESTR           ; See if enough string space
2871+ 2F32 21 44 61     CRTMST: ld      HL,TMPSTR       ; Temporary string
2872+ 2F35 E5                   push    HL              ; Save it
2873+ 2F36 77                   ld      (HL),A          ; Save length of string
2874+ 2F37 23                   inc     HL
2875+ 2F38 23           SVSTAD: inc     HL
2876+ 2F39 73                   ld      (HL),E          ; Save LSB of address
2877+ 2F3A 23                   inc     HL
2878+ 2F3B 72                   ld      (HL),D          ; Save MSB of address
2879+ 2F3C E1                   pop     HL              ; Restore pointer
2880+ 2F3D C9                   ret
2881+ 2F3E
2882+ 2F3E 2B           CRTST:  dec     HL              ; dec - INCed after
2883+ 2F3F 06 22        QTSTR:  ld      B,$22           ; '"'           ; Terminating quote
2884+ 2F41 50                   ld      D,B             ; Quote to D
2885+ 2F42 E5           DTSTR:  push    HL              ; Save start
2886+ 2F43 0E FF                ld      C,-1            ; Set counter to -1
2887+ 2F45 23           QTSTLP: inc     HL              ; Move on
2888+ 2F46 7E                   ld      A,(HL)          ; Get byte
2889+ 2F47 0C                   inc     C               ; Count bytes
2890+ 2F48 B7                   or      A               ; End of line?
2891+ 2F49 CA 54 2F             jp      Z,CRTSTE        ; Yes - Create string entry
2892+ 2F4C BA                   cp      D               ; Terminator D found?
2893+ 2F4D CA 54 2F             jp      Z,CRTSTE        ; Yes - Create string entry
2894+ 2F50 B8                   cp      B               ; Terminator B found?
2895+ 2F51 C2 45 2F             jp      NZ,QTSTLP       ; No - Keep looking
2896+ 2F54 FE 22        CRTSTE: cp      $22             ; '"'             ; End with '"'?
2897+ 2F56 CC E7 25             call    Z,GETCHR        ; Yes - Get next character
2898+ 2F59 E3                   ex      (SP),HL         ; Starting quote
2899+ 2F5A 23                   inc     HL              ; First byte of string
2900+ 2F5B EB                   ex      DE,HL           ; To DE
2901+ 2F5C 79                   ld      A,C             ; Get length
2902+ 2F5D CD 32 2F             call    CRTMST          ; Create string entry
2903+ 2F60 11 44 61     TSTOPL: ld      DE,TMPSTR       ; Temporary string
2904+ 2F63 2A 36 61             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2905+ 2F66 22 CF 61             ld      (FPREG),HL      ; Save address of string ptr
2906+ 2F69 3E 01                ld      A,$01
2907+ 2F6B 32 09 61             ld      (TYPE),A        ; Set type to string
2908+ 2F6E CD E0 38             call    DETHL4          ; Move string to pool
2909+ 2F71 CD 98 23             call    CPDEHL          ; Out of string pool?
2910+ 2F74 22 36 61             ld      (TMSTPT),HL     ; Save new pointer
2911+ 2F77 E1                   pop     HL              ; Restore code string address
2912+ 2F78 7E                   ld      A,(HL)          ; Get next code byte
2913+ 2F79 C0                   ret     NZ              ; Return if pool OK
2914+ 2F7A 1E 1E                ld      E,ST            ; ?ST Error
2915+ 2F7C C3 B8 20             jp      ERROR           ; String pool overflow
2916+ 2F7F
2917+ 2F7F 23           PRNUMS: inc     HL              ; Skip leading space
2918+ 2F80 CD 3E 2F     PRS:    call    CRTST           ; Create string entry for it
2919+ 2F83 CD C3 30     PRS1:   call    GSTRCU          ; Current string to pool
2920+ 2F86 CD D4 38             call    LOADFP          ; Move string block to BCDE
2921+ 2F89 1C                   inc     E               ; Length + 1
2922+ 2F8A 1D           PRSLP:  dec     E               ; Count characters
2923+ 2F8B C8                   ret     Z               ; End of string
2924+ 2F8C 0A                   ld      A,(BC)          ; Get byte to output
2925+ 2F8D CD A9 23             call    OUTC            ; Output character in A
2926+ 2F90 FE 0D                cp      CR              ; Return?
2927+ 2F92 CC BE 28             call    Z,CNTEND        ; Yes - Position cursor to 0
2928+ 2F95 03                   inc     BC              ; Next byte in string
2929+ 2F96 C3 8A 2F             jp      PRSLP           ; More characters to output
2930+ 2F99
2931+ 2F99 B7           TESTR:  or      A               ; Test if enough room
2932+ 2F9A 0E                   defb    $0E             ; No garbage collection done
2933+ 2F9B F1           GRBDON: pop     AF              ; Garbage collection done
2934+ 2F9C F5                   push    AF              ; Save status
2935+ 2F9D 2A 22 60             ld      HL,(STRSPC)     ; Bottom of string space in use
2936+ 2FA0 EB                   ex      DE,HL           ; To DE
2937+ 2FA1 2A 48 61             ld      HL,(STRBOT)     ; Bottom of string area
2938+ 2FA4 2F                   cpl                     ; Negate length (Top down)
2939+ 2FA5 4F                   ld      C,A             ; -Length to BC
2940+ 2FA6 06 FF                ld      B,-1            ; BC = -ve length of string
2941+ 2FA8 09                   add     HL,BC           ; Add to bottom of space in use
2942+ 2FA9 23                   inc     HL              ; Plus one for 2's complement
2943+ 2FAA CD 98 23             call    CPDEHL          ; Below string RAM area?
2944+ 2FAD DA B7 2F             jp      C,TESTOS        ; Tidy up if not done else err
2945+ 2FB0 22 48 61             ld      (STRBOT),HL     ; Save new bottom of area
2946+ 2FB3 23                   inc     HL              ; Point to first byte of string
2947+ 2FB4 EB                   ex      DE,HL           ; Address to DE
2948+ 2FB5 F1           POPAF:  pop     AF              ; Throw away status push
2949+ 2FB6 C9                   ret
2950+ 2FB7
2951+ 2FB7 F1           TESTOS: pop     AF              ; Garbage collect been done?
2952+ 2FB8 1E 1A                ld      E,OS            ; ?OS Error
2953+ 2FBA CA B8 20             jp      Z,ERROR         ; Yes - Not enough string space
2954+ 2FBD BF                   cp      A               ; Flag garbage collect done
2955+ 2FBE F5                   push    AF              ; Save status
2956+ 2FBF 01 9B 2F             ld      BC,GRBDON       ; Garbage collection done
2957+ 2FC2 C5                   push    BC              ; Save for RETurn
2958+ 2FC3 2A 0B 61     GARBGE: ld      HL,(LSTRAM)     ; Get end of RAM pointer
2959+ 2FC6 22 48 61     GARBLP: ld      (STRBOT),HL     ; Reset string pointer
2960+ 2FC9 21 00 00             ld      HL,$0000
2961+ 2FCC E5                   push    HL              ; Flag no string found
2962+ 2FCD 2A 22 60             ld      HL,(STRSPC)     ; Get bottom of string space
2963+ 2FD0 E5                   push    HL              ; Save bottom of string space
2964+ 2FD1 21 38 61             ld      HL,TMSTPL       ; Temporary string pool
2965+ 2FD4 EB           GRBLP:  ex      DE,HL
2966+ 2FD5 2A 36 61             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2967+ 2FD8 EB                   ex      DE,HL
2968+ 2FD9 CD 98 23             call    CPDEHL          ; Temporary string pool done?
2969+ 2FDC 01 D4 2F             ld      BC,GRBLP        ; Loop until string pool done
2970+ 2FDF C2 28 30             jp      NZ,STPOOL       ; No - See if in string area
2971+ 2FE2 2A C1 61             ld      HL,(PROGND)     ; Start of simple variables
2972+ 2FE5 EB           SMPVAR: ex      DE,HL
2973+ 2FE6 2A C3 61             ld      HL,(VAREND)     ; End of simple variables
2974+ 2FE9 EB                   ex      DE,HL
2975+ 2FEA CD 98 23             call    CPDEHL          ; All simple strings done?
2976+ 2FED CA FB 2F             jp      Z,ARRLP         ; Yes - Do string arrays
2977+ 2FF0 7E                   ld      A,(HL)          ; Get type of variable
2978+ 2FF1 23                   inc     HL
2979+ 2FF2 23                   inc     HL
2980+ 2FF3 B7                   or      A               ; "S" flag set if string
2981+ 2FF4 CD 2B 30             call    STRADD          ; See if string in string area
2982+ 2FF7 C3 E5 2F             jp      SMPVAR          ; Loop until simple ones done
2983+ 2FFA
2984+ 2FFA C1           GNXARY: pop     BC              ; Scrap address of this array
2985+ 2FFB EB           ARRLP:  ex      DE,HL
2986+ 2FFC 2A C5 61             ld      HL,(ARREND)     ; End of string arrays
2987+ 2FFF EB                   ex      DE,HL
2988+ 3000 CD 98 23             call    CPDEHL          ; All string arrays done?
2989+ 3003 CA 51 30             jp      Z,SCNEND        ; Yes - Move string if found
2990+ 3006 CD D4 38             call    LOADFP          ; Get array name to BCDE
2991+ 3009 7B                   ld      A,E             ; Get type of array
2992+ 300A E5                   push    HL              ; Save address of num of dim'ns
2993+ 300B 09                   add     HL,BC           ; Start of next array
2994+ 300C B7                   or      A               ; Test type of array
2995+ 300D F2 FA 2F             jp      P,GNXARY        ; Numeric array - Ignore it
2996+ 3010 22 4A 61             ld      (CUROPR),HL     ; Save address of next array
2997+ 3013 E1                   pop     HL              ; Get address of num of dim'ns
2998+ 3014 4E                   ld      C,(HL)          ; BC = Number of dimensions
2999+ 3015 06 00                ld      B,$00
3000+ 3017 09                   add     HL,BC           ; Two bytes per dimension size
3001+ 3018 09                   add     HL,BC
3002+ 3019 23                   inc     HL              ; Plus one for number of dim'ns
3003+ 301A EB           GRBARY: ex      DE,HL
3004+ 301B 2A 4A 61             ld      HL,(CUROPR)     ; Get address of next array
3005+ 301E EB                   ex      DE,HL
3006+ 301F CD 98 23             call    CPDEHL          ; Is this array finished?
3007+ 3022 CA FB 2F             jp      Z,ARRLP         ; Yes - Get next one
3008+ 3025 01 1A 30             ld      BC,GRBARY       ; Loop until array all done
3009+ 3028 C5           STPOOL: push    BC              ; Save return address
3010+ 3029 F6 80                or      $80             ; Flag string type
3011+ 302B 7E           STRADD: ld      A,(HL)          ; Get string length
3012+ 302C 23                   inc     HL
3013+ 302D 23                   inc     HL
3014+ 302E 5E                   ld      E,(HL)          ; Get LSB of string address
3015+ 302F 23                   inc     HL
3016+ 3030 56                   ld      D,(HL)          ; Get MSB of string address
3017+ 3031 23                   inc     HL
3018+ 3032 F0                   ret     P               ; Not a string - Return
3019+ 3033 B7                   or      A               ; Set flags on string length
3020+ 3034 C8                   ret     Z               ; Null string - Return
3021+ 3035 44                   ld      B,H             ; Save variable pointer
3022+ 3036 4D                   ld      C,L
3023+ 3037 2A 48 61             ld      HL,(STRBOT)     ; Bottom of new area
3024+ 303A CD 98 23             call    CPDEHL          ; String been done?
3025+ 303D 60                   ld      H,B             ; Restore variable pointer
3026+ 303E 69                   ld      L,C
3027+ 303F D8                   ret     C               ; String done - Ignore
3028+ 3040 E1                   pop     HL              ; Return address
3029+ 3041 E3                   ex      (SP),HL         ; Lowest available string area
3030+ 3042 CD 98 23             call    CPDEHL          ; String within string area?
3031+ 3045 E3                   ex      (SP),HL         ; Lowest available string area
3032+ 3046 E5                   push    HL              ; Re-save return address
3033+ 3047 60                   ld      H,B             ; Restore variable pointer
3034+ 3048 69                   ld      L,C
3035+ 3049 D0                   ret     NC              ; Outside string area - Ignore
3036+ 304A C1                   pop     BC              ; Get return , Throw 2 away
3037+ 304B F1                   pop     AF              ;
3038+ 304C F1                   pop     AF              ;
3039+ 304D E5                   push    HL              ; Save variable pointer
3040+ 304E D5                   push    DE              ; Save address of current
3041+ 304F C5                   push    BC              ; Put back return address
3042+ 3050 C9                   ret                     ; Go to it
3043+ 3051
3044+ 3051 D1           SCNEND: pop     DE              ; Addresses of strings
3045+ 3052 E1                   pop     HL              ;
3046+ 3053 7D                   ld      A,L             ; HL = 0 if no more to do
3047+ 3054 B4                   or      H
3048+ 3055 C8                   ret     Z               ; No more to do - Return
3049+ 3056 2B                   dec     HL
3050+ 3057 46                   ld      B,(HL)          ; MSB of address of string
3051+ 3058 2B                   dec     HL
3052+ 3059 4E                   ld      C,(HL)          ; LSB of address of string
3053+ 305A E5                   push    HL              ; Save variable address
3054+ 305B 2B                   dec     HL
3055+ 305C 2B                   dec     HL
3056+ 305D 6E                   ld      L,(HL)          ; HL = Length of string
3057+ 305E 26 00                ld      H,$00
3058+ 3060 09                   add     HL,BC           ; Address of end of string+1
3059+ 3061 50                   ld      D,B             ; String address to DE
3060+ 3062 59                   ld      E,C
3061+ 3063 2B                   dec     HL              ; Last byte in string
3062+ 3064 44                   ld      B,H             ; Address to BC
3063+ 3065 4D                   ld      C,L
3064+ 3066 2A 48 61             ld      HL,(STRBOT)     ; Current bottom of string area
3065+ 3069 CD 4D 20             call    MOVSTR          ; Move string to new address
3066+ 306C E1                   pop     HL              ; Restore variable address
3067+ 306D 71                   ld      (HL),C          ; Save new LSB of address
3068+ 306E 23                   inc     HL
3069+ 306F 70                   ld      (HL),B          ; Save new MSB of address
3070+ 3070 69                   ld      L,C             ; Next string area+1 to HL
3071+ 3071 60                   ld      H,B
3072+ 3072 2B                   dec     HL              ; Next string area address
3073+ 3073 C3 C6 2F             jp      GARBLP          ; Look for more strings
3074+ 3076
3075+ 3076 C5           CONCAT: push    BC              ; Save prec' opr & code string
3076+ 3077 E5                   push    HL              ;
3077+ 3078 2A CF 61             ld      HL,(FPREG)      ; Get first string
3078+ 307B E3                   ex      (SP),HL         ; Save first string
3079+ 307C CD 01 2B             call    OPRND           ; Get second string
3080+ 307F E3                   ex      (SP),HL         ; Restore first string
3081+ 3080 CD 7C 2A             call    TSTSTR          ; Make sure it's a string
3082+ 3083 7E                   ld      A,(HL)          ; Get length of second string
3083+ 3084 E5                   push    HL              ; Save first string
3084+ 3085 2A CF 61             ld      HL,(FPREG)      ; Get second string
3085+ 3088 E5                   push    HL              ; Save second string
3086+ 3089 86                   add     A,(HL)          ; Add length of second string
3087+ 308A 1E 1C                ld      E,LS            ; ?LS Error
3088+ 308C DA B8 20             jp      C,ERROR         ; String too long - Error
3089+ 308F CD 2F 2F             call    MKTMST          ; Make temporary string
3090+ 3092 D1                   pop     DE              ; Get second string to DE
3091+ 3093 CD C7 30             call    GSTRDE          ; Move to string pool if needed
3092+ 3096 E3                   ex      (SP),HL         ; Get first string
3093+ 3097 CD C6 30             call    GSTRHL          ; Move to string pool if needed
3094+ 309A E5                   push    HL              ; Save first string
3095+ 309B 2A 46 61             ld      HL,(TMPSTR+2)   ; Temporary string address
3096+ 309E EB                   ex      DE,HL           ; To DE
3097+ 309F CD AD 30             call    SSTSA           ; First string to string area
3098+ 30A2 CD AD 30             call    SSTSA           ; Second string to string area
3099+ 30A5 21 96 2A             ld      HL,EVAL2        ; Return to evaluation loop
3100+ 30A8 E3                   ex      (SP),HL         ; Save return,get code string
3101+ 30A9 E5                   push    HL              ; Save code string address
3102+ 30AA C3 60 2F             jp      TSTOPL          ; To temporary string to pool
3103+ 30AD
3104+ 30AD E1           SSTSA:  pop     HL              ; Return address
3105+ 30AE E3                   ex      (SP),HL         ; Get string block,save return
3106+ 30AF 7E                   ld      A,(HL)          ; Get length of string
3107+ 30B0 23                   inc     HL
3108+ 30B1 23                   inc     HL
3109+ 30B2 4E                   ld      C,(HL)          ; Get LSB of string address
3110+ 30B3 23                   inc     HL
3111+ 30B4 46                   ld      B,(HL)          ; Get MSB of string address
3112+ 30B5 6F                   ld      L,A             ; Length to L
3113+ 30B6 2C           TOSTRA: inc     L               ; inc - DECed after
3114+ 30B7 2D           TSALP:  dec     L               ; Count bytes moved
3115+ 30B8 C8                   ret     Z               ; End of string - Return
3116+ 30B9 0A                   ld      A,(BC)          ; Get source
3117+ 30BA 12                   ld      (DE),A          ; Save destination
3118+ 30BB 03                   inc     BC              ; Next source
3119+ 30BC 13                   inc     DE              ; Next destination
3120+ 30BD C3 B7 30             jp      TSALP           ; Loop until string moved
3121+ 30C0
3122+ 30C0 CD 7C 2A     GETSTR: call    TSTSTR          ; Make sure it's a string
3123+ 30C3 2A CF 61     GSTRCU: ld      HL,(FPREG)      ; Get current string
3124+ 30C6 EB           GSTRHL: ex      DE,HL           ; Save DE
3125+ 30C7 CD E1 30     GSTRDE: call    BAKTMP          ; Was it last tmp-str?
3126+ 30CA EB                   ex      DE,HL           ; Restore DE
3127+ 30CB C0                   ret     NZ              ; No - Return
3128+ 30CC D5                   push    DE              ; Save string
3129+ 30CD 50                   ld      D,B             ; String block address to DE
3130+ 30CE 59                   ld      E,C
3131+ 30CF 1B                   dec     DE              ; Point to length
3132+ 30D0 4E                   ld      C,(HL)          ; Get string length
3133+ 30D1 2A 48 61             ld      HL,(STRBOT)     ; Current bottom of string area
3134+ 30D4 CD 98 23             call    CPDEHL          ; Last one in string area?
3135+ 30D7 C2 DF 30             jp      NZ,POPHL        ; No - Return
3136+ 30DA 47                   ld      B,A             ; Clear B (A=0)
3137+ 30DB 09                   add     HL,BC           ; Remove string from str' area
3138+ 30DC 22 48 61             ld      (STRBOT),HL     ; Save new bottom of str' area
3139+ 30DF E1           POPHL:  pop     HL              ; Restore string
3140+ 30E0 C9                   ret
3141+ 30E1
3142+ 30E1 2A 36 61     BAKTMP: ld      HL,(TMSTPT)     ; Get temporary string pool top
3143+ 30E4 2B                   dec     HL              ; Back
3144+ 30E5 46                   ld      B,(HL)          ; Get MSB of address
3145+ 30E6 2B                   dec     HL              ; Back
3146+ 30E7 4E                   ld      C,(HL)          ; Get LSB of address
3147+ 30E8 2B                   dec     HL              ; Back
3148+ 30E9 2B                   dec     HL              ; Back
3149+ 30EA CD 98 23             call    CPDEHL          ; String last in string pool?
3150+ 30ED C0                   ret     NZ              ; Yes - Leave it
3151+ 30EE 22 36 61             ld      (TMSTPT),HL     ; Save new string pool top
3152+ 30F1 C9                   ret
3153+ 30F2
3154+ 30F2 01 71 2E     LEN:    ld      BC,PASSA        ; To return integer A
3155+ 30F5 C5                   push    BC              ; Save address
3156+ 30F6 CD C0 30     GETLEN: call    GETSTR          ; Get string and its length
3157+ 30F9 AF                   xor     A
3158+ 30FA 57                   ld      D,A             ; Clear D
3159+ 30FB 32 09 61             ld      (TYPE),A        ; Set type to numeric
3160+ 30FE 7E                   ld      A,(HL)          ; Get length of string
3161+ 30FF B7                   or      A               ; Set status flags
3162+ 3100 C9                   ret
3163+ 3101
3164+ 3101 01 71 2E     ASC:    ld      BC,PASSA        ; To return integer A
3165+ 3104 C5                   push    BC              ; Save address
3166+ 3105 CD F6 30     GTFLNM: call    GETLEN          ; Get length of string
3167+ 3108 CA B2 26             jp      Z,FCERR         ; Null string - Error
3168+ 310B 23                   inc     HL
3169+ 310C 23                   inc     HL
3170+ 310D 5E                   ld      E,(HL)          ; Get LSB of address
3171+ 310E 23                   inc     HL
3172+ 310F 56                   ld      D,(HL)          ; Get MSB of address
3173+ 3110 1A                   ld      A,(DE)          ; Get first byte of string
3174+ 3111 C9                   ret
3175+ 3112
3176+ 3112 3E 01        CHR:    ld      A,$01           ; One character string
3177+ 3114 CD 2F 2F             call    MKTMST          ; Make a temporary string
3178+ 3117 CD 01 33             call    MAKINT          ; Make it integer A
3179+ 311A 2A 46 61             ld      HL,(TMPSTR+2)   ; Get address of string
3180+ 311D 73                   ld      (HL),E          ; Save character
3181+ 311E C1           TOPOOL: pop     BC              ; Clean up stack
3182+ 311F C3 60 2F             jp      TSTOPL          ; Temporary string to pool
3183+ 3122
3184+ 3122 CD B1 32     LEFT:   call    LFRGNM          ; Get number and ending ")"
3185+ 3125 AF                   xor     A               ; Start at first byte in string
3186+ 3126 E3           RIGHT1: ex      (SP),HL         ; Save code string,Get string
3187+ 3127 4F                   ld      C,A             ; Starting position in string
3188+ 3128 E5           MID1:   push    HL              ; Save string block address
3189+ 3129 7E                   ld      A,(HL)          ; Get length of string
3190+ 312A B8                   cp      B               ; Compare with number given
3191+ 312B DA 30 31             jp      C,ALLFOL        ; All following bytes required
3192+ 312E 78                   ld      A,B             ; Get new length
3193+ 312F 11                   defb    $11             ; Skip "ld C,0"
3194+ 3130 0E 00        ALLFOL: ld      C,$00           ; First byte of string
3195+ 3132 C5                   push    BC              ; Save position in string
3196+ 3133 CD 99 2F             call    TESTR           ; See if enough string space
3197+ 3136 C1                   pop     BC              ; Get position in string
3198+ 3137 E1                   pop     HL              ; Restore string block address
3199+ 3138 E5                   push    HL              ; And re-save it
3200+ 3139 23                   inc     HL
3201+ 313A 23                   inc     HL
3202+ 313B 46                   ld      B,(HL)          ; Get LSB of address
3203+ 313C 23                   inc     HL
3204+ 313D 66                   ld      H,(HL)          ; Get MSB of address
3205+ 313E 68                   ld      L,B             ; HL = address of string
3206+ 313F 06 00                ld      B,$00           ; BC = starting address
3207+ 3141 09                   add     HL,BC           ; Point to that byte
3208+ 3142 44                   ld      B,H             ; BC = source string
3209+ 3143 4D                   ld      C,L
3210+ 3144 CD 32 2F             call    CRTMST          ; Create a string entry
3211+ 3147 6F                   ld      L,A             ; Length of new string
3212+ 3148 CD B6 30             call    TOSTRA          ; Move string to string area
3213+ 314B D1                   pop     DE              ; Clear stack
3214+ 314C CD C7 30             call    GSTRDE          ; Move to string pool if needed
3215+ 314F C3 60 2F             jp      TSTOPL          ; Temporary string to pool
3216+ 3152
3217+ 3152
3218+ 3152              ; INSTR statement - look for a string inside another string
3219+ 3152              ; usage: INSTR(A$,B$) -> search for B$ into A$
3220+ 3152              ; return 0 if B$ is not found into A$, or LEN(A$)<LEN(B$)
3221+ 3152              ; return 1~255 to indicate the starting position of B$ into A$
3222+ 3152              ; ex.: INSTR("HELLO","LO") returns 4 - INSTR("HOME","PC") returns 0
3223+ 3152              LNS1    equ     TMPBFR1
3224+ 3152              ADRS1   equ     TMPBFR2
3225+ 3152              LNS2    equ     TMPBFR3
3226+ 3152              ADRS2   equ     TMPBFR4
3227+ 3152              PT      equ     VIDEOBUFF
3228+ 3152              PT1     equ     VIDEOBUFF+2
3229+ 3152              PT2     equ     VIDEOBUFF+4
3230+ 3152              TP      equ     VIDEOBUFF+6
3231+ 3152              TF      equ     VIDEOBUFF+8
3232+ 3152 CD 9E 23     INSTR:  call    CHKSYN          ; make sure "(" follows
3233+ 3155 28                   defb    '('
3234+ 3156 2B                   dec     HL              ; dec 'cause GETCHR increments
3235+ 3157 CD E7 25             call    GETCHR          ; check if something follows
3236+ 315A CA 9E 20             jp      Z,SNERR         ; if nothing else, raise a syntax error
3237+ 315D CD 8A 2A             call    EVAL            ; Evaluate expression
3238+ 3160 CD 7C 2A             call    TSTSTR          ; Make sure it's a string
3239+ 3163 22 83 61             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3240+ 3166 CD C3 30             call    GSTRCU          ; check that a string follows
3241+ 3169 CD D4 38             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3242+ 316C ED 53 7B 61          ld      (LNS1),DE       ; store values into
3243+ 3170 ED 43 7D 61          ld      (ADRS1),BC      ; temp buffers
3244+ 3174 2A 83 61             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3245+ 3177 CD 9E 23             call    CHKSYN          ; Make sure ',' follows
3246+ 317A 2C                   defb    ','
3247+ 317B 2B                   dec     HL              ; dec 'cause GETCHR increments
3248+ 317C CD E7 25             call    GETCHR          ; check if something follows
3249+ 317F CA 9E 20             jp      Z,SNERR         ; if nothing else, raise a syntax error
3250+ 3182 CD 8A 2A             call    EVAL            ; Evaluate expression
3251+ 3185 CD 7C 2A             call    TSTSTR          ; Make sure it's a string
3252+ 3188 22 83 61             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3253+ 318B CD C3 30             call    GSTRCU          ; check that a string follows
3254+ 318E CD D4 38             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3255+ 3191 ED 53 7F 61          ld      (LNS2),DE       ; store values into
3256+ 3195 ED 43 81 61          ld      (ADRS2),BC      ; temp buffers
3257+ 3199 2A 83 61             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3258+ 319C CD 9E 23             call    CHKSYN          ; make sure ")" follows
3259+ 319F 29                   defb    ')'
3260+ 31A0 E5                   push    HL              ; store current code string pointer (the point after the ")" ) ...
3261+ 31A1 FD E1                pop     IY              ; ...into IY
3262+ 31A3 AF                   xor     A               ; reset 10 RAM cells
3263+ 31A4 06 0A                ld      B,$0A           ; (INSTR registers)
3264+ 31A6 21 83 61             ld      HL,PT           ; first cell
3265+ 31A9 77           EMPTINS:ld      (HL),A          ; reset cell
3266+ 31AA 23                   inc     HL              ; next cell
3267+ 31AB 10 FC                djnz    EMPTINS         ; repeat
3268+ 31AD ED 5B 7F 61          ld      DE,(LNS2)       ; load len(S2) into DE
3269+ 31B1 2A 7B 61             ld      HL,(LNS1)       ; load len(S1) into HL
3270+ 31B4 CD 3B 4D             call    CMP16           ; check that len(S1)>=len(S2)
3271+ 31B7 DA 2C 32             jp      C,RZINSTR       ; if len(S2)>len(S1) then return 0
3272+ 31BA AF           RPTINST:xor     A               ; reset...
3273+ 31BB 32 89 61             ld      (TP),A          ; ...TP...
3274+ 31BE 32 8B 61             ld      (TF),A          ; ...and TF
3275+ 31C1 ED 4B 83 61          ld      BC,(PT)         ; pointer to S1
3276+ 31C5 2A 7D 61             ld      HL,(ADRS1)      ; first cell of S1
3277+ 31C8 09                   add     HL,BC           ; get current position into RAM
3278+ 31C9 7E                   ld      A,(HL)          ; load S1(PT)
3279+ 31CA 2A 81 61             ld      HL,(ADRS2)      ; pointer to first char of S2
3280+ 31CD BE                   cp      (HL)            ; is S1(PT)=S2(0)?
3281+ 31CE 20 3A                jr      NZ,CNT1INS      ; no, continue
3282+ 31D0 3A 83 61             ld      A,(PT)          ; load current PT
3283+ 31D3 32 89 61             ld      (TP),A          ; TP=PT
3284+ 31D6 32 85 61             ld      (PT1),A         ; P1=PT
3285+ 31D9 AF                   xor     A               ; set...
3286+ 31DA 32 87 61             ld      (PT2),A         ; ...PT2=0
3287+ 31DD 3C                   inc     A               ;
3288+ 31DE 32 8B 61             ld      (TF),A          ; set TF=1
3289+ 31E1 ED 4B 85 61  RP2INST:ld      BC,(PT1)        ; load pointer PT1
3290+ 31E5 2A 7D 61             ld      HL,(ADRS1)      ; load address of S1
3291+ 31E8 09                   add     HL,BC           ; find char of S1 pointed by PT1
3292+ 31E9 7E                   ld      A,(HL)          ; load S1(PT1)
3293+ 31EA ED 4B 87 61          ld      BC,(PT2)        ; load pointer PT2
3294+ 31EE 2A 81 61             ld      HL,(ADRS2)      ; load char of S2 pointed by PT2
3295+ 31F1 09                   add     HL,BC           ; find S2(PT2)
3296+ 31F2 BE                   cp      (HL)            ; is S1(PT1)=S2(PT2)?
3297+ 31F3 20 4C                jr      NZ,CNTZIN       ; no, exit inner loop
3298+ 31F5 21 85 61             ld      HL,PT1
3299+ 31F8 34                   inc     (HL)            ; increment PT1
3300+ 31F9 3A 87 61             ld      A,(PT2)
3301+ 31FC 3C                   inc     A               ; increment PT2
3302+ 31FD 32 87 61             ld      (PT2),A
3303+ 3200 CA 0A 32             jp      Z,CNT1INS       ; if PT2>255 then exit
3304+ 3203 21 7F 61             ld      HL,LNS2         ; len(S2)
3305+ 3206 BE                   cp      (HL)            ; PT2=len(S2)?
3306+ 3207 DA E1 31             jp      C,RP2INST       ; no (PT2<len(S2) - repeat
3307+ 320A 3A 8B 61     CNT1INS:ld      A,(TF)          ; check TF
3308+ 320D A7                   and     A               ; TF=0? (clears also Carry for next SBC)
3309+ 320E 20 1C                jr      NZ,RZINSTR      ; no, exit
3310+ 3210 2A 7B 61             ld      HL,(LNS1)       ; load len(S1)
3311+ 3213 ED 4B 7F 61          ld      BC,(LNS2)       ; load len(S2)
3312+ 3217 ED 42                sbc     HL,BC           ; HL=len(S1)-len(S2)
3313+ 3219 ED 5B 83 61          ld      DE,(PT)         ; load pointer
3314+ 321D 1C                   inc     E               ; PT=PT+1
3315+ 321E ED 53 83 61          ld      (PT),DE         ; store new value
3316+ 3222 EB                   ex      DE,HL           ; invert registers
3317+ 3223 CD 3B 4D             call    CMP16           ; check if PT>len(S1)-len(S2)
3318+ 3226 DA BA 31             jp      C,RPTINST       ; repeat if <
3319+ 3229 CA BA 31             jp      Z,RPTINST       ; repeat if =
3320+ 322C 3A 8B 61     RZINSTR:ld      A,(TF)          ; current value of TF
3321+ 322F A7                   and     A               ; is it 0?
3322+ 3230 CA 37 32             jp      Z,LVINSTR       ; yes, return 0
3323+ 3233 3A 89 61             ld      A,(TP)          ; return TP...
3324+ 3236 3C                   inc     A               ; ...incremented by 1
3325+ 3237 E1           LVINSTR:pop     HL              ; drop original return point
3326+ 3238 FD E5                push    IY              ; load current string address from IY into stack
3327+ 323A 11 63 2B             ld      DE,RETNUM       ; Address of Return number from function...
3328+ 323D D5                   push    DE              ; ...saved on stack
3329+ 323E C3 71 2E             jp      PASSA           ; return TP
3330+ 3241 AF           CNTZIN: xor     A               ; set...
3331+ 3242 32 8B 61             ld      (TF),A          ; TF=0
3332+ 3245 C3 0A 32             jp      CNT1INS         ; continue
3333+ 3248
3334+ 3248
3335+ 3248              ; returns the right portion of a string
3336+ 3248 CD B1 32     RIGHT:  call    LFRGNM          ; Get number and ending ")"
3337+ 324B D1                   pop     DE              ; Get string length
3338+ 324C D5                   push    DE              ; And re-save
3339+ 324D 1A                   ld      A,(DE)          ; Get length
3340+ 324E 90                   sub     B               ; Move back N bytes
3341+ 324F C3 26 31             jp      RIGHT1          ; Go and get sub-string
3342+ 3252
3343+ 3252              ; returns a piece of a string
3344+ 3252 EB           MID:    ex      DE,HL           ; Get code string address
3345+ 3253 7E                   ld      A,(HL)          ; Get next byte ',' or ")"
3346+ 3254 CD B6 32             call    MIDNUM          ; Get number supplied
3347+ 3257 04                   inc     B               ; Is it character zero?
3348+ 3258 05                   dec     B
3349+ 3259 CA B2 26             jp      Z,FCERR         ; Yes - Error
3350+ 325C C5                   push    BC              ; Save starting position
3351+ 325D 1E FF                ld      E,$FF           ; All of string
3352+ 325F FE 29                cp      ')'             ; Any length given?
3353+ 3261 CA 6B 32             jp      Z,RSTSTR        ; No - Rest of string
3354+ 3264 CD 9E 23             call    CHKSYN          ; Make sure ',' follows
3355+ 3267 2C                   defb    ','
3356+ 3268 CD FE 32             call    GETINT          ; Get integer 0-255
3357+ 326B CD 9E 23     RSTSTR: call    CHKSYN          ; Make sure ")" follows
3358+ 326E 29                   defb    ')'
3359+ 326F F1                   pop     AF              ; Restore starting position
3360+ 3270 E3                   ex      (SP),HL         ; Get string,save code string
3361+ 3271 01 28 31             ld      BC,MID1         ; Continuation of MID$ routine
3362+ 3274 C5                   push    BC              ; Save for return
3363+ 3275 3D                   dec     A               ; Starting position-1
3364+ 3276 BE                   cp      (HL)            ; Compare with length
3365+ 3277 06 00                ld      B,$00           ; Zero bytes length
3366+ 3279 D0                   ret     NC              ; Null string if start past end
3367+ 327A 4F                   ld      C,A             ; Save starting position-1
3368+ 327B 7E                   ld      A,(HL)          ; Get length of string
3369+ 327C 91                   sub     C               ; Subtract start
3370+ 327D BB                   cp      E               ; Enough string for it?
3371+ 327E 47                   ld      B,A             ; Save maximum length available
3372+ 327F D8                   ret     C               ; Truncate string if needed
3373+ 3280 43                   ld      B,E             ; Set specified length
3374+ 3281 C9                   ret                     ; Go and create string
3375+ 3282
3376+ 3282
3377+ 3282              ; return the value of a numeric string
3378+ 3282 CD F6 30     VAL:    call    GETLEN          ; Get length of string
3379+ 3285 CA 54 36             jp      Z,RESZER        ; Result zero
3380+ 3288 5F                   ld      E,A             ; Save length
3381+ 3289 23                   inc     HL
3382+ 328A 23                   inc     HL
3383+ 328B 7E                   ld      A,(HL)          ; Get LSB of address
3384+ 328C 23                   inc     HL
3385+ 328D 66                   ld      H,(HL)          ; Get MSB of address
3386+ 328E 6F                   ld      L,A             ; HL = String address
3387+ 328F E5                   push    HL              ; Save string address
3388+ 3290 19                   add     HL,DE
3389+ 3291 46                   ld      B,(HL)          ; Get end of string+1 byte
3390+ 3292 72                   ld      (HL),D          ; Zero it to terminate
3391+ 3293 E3                   ex      (SP),HL         ; Save string end,get start
3392+ 3294 C5                   push    BC              ; Save end+1 byte
3393+ 3295 7E                   ld      A,(HL)          ; Get starting byte
3394+ 3296 FE 24                cp      '$'             ; Hex number indicated? [function added]
3395+ 3298 C2 A0 32             jp      NZ,VAL1
3396+ 329B CD 6D 4C             call    HEXTFP          ; Convert Hex to FPREG
3397+ 329E 18 0D                jr      VAL3
3398+ 32A0 FE 25        VAL1:   cp      '%'             ; Binary number indicated? [function added]
3399+ 32A2 C2 AA 32             jp      NZ,VAL2
3400+ 32A5 CD DD 4C             call    BINTFP          ; Convert Bin to FPREG
3401+ 32A8 18 03                jr      VAL3
3402+ 32AA CD 8C 39     VAL2:   call    ASCTFP          ; Convert ASCII string to FP
3403+ 32AD C1           VAL3:   pop     BC              ; Restore end+1 byte
3404+ 32AE E1                   pop     HL              ; Restore end+1 address
3405+ 32AF 70                   ld      (HL),B          ; Put back original byte
3406+ 32B0 C9                   ret
3407+ 32B1
3408+ 32B1 EB           LFRGNM: ex      DE,HL           ; Code string address to HL
3409+ 32B2 CD 9E 23             call    CHKSYN          ; Make sure ")" follows
3410+ 32B5 29                   defb    ')'
3411+ 32B6 C1           MIDNUM: pop     BC              ; Get return address
3412+ 32B7 D1                   pop     DE              ; Get number supplied
3413+ 32B8 C5                   push    BC              ; Re-save return address
3414+ 32B9 43                   ld      B,E             ; Number to B
3415+ 32BA C9                   ret
3416+ 32BB
3417+ 32BB CD 01 33     INP:    call    MAKINT          ; Make it integer A
3418+ 32BE 32 15 60             ld      (INPORT),A      ; Set input port
3419+ 32C1 CD 14 60             call    INPSUB          ; Get input from port
3420+ 32C4 C3 71 2E             jp      PASSA           ; Return integer A
3421+ 32C7
3422+ 32C7 CD EB 32     POUT:   call    SETIO           ; Set up port number
3423+ 32CA C3 DC 5F             jp      OUTSUB          ; Output data and return
3424+ 32CD
3425+ 32CD CD EB 32     WAIT:   call    SETIO           ; Set up port number
3426+ 32D0 F5                   push    AF              ; Save AND mask
3427+ 32D1 1E 00                ld      E,$00           ; Assume zero if none given
3428+ 32D3 2B                   dec     HL              ; dec 'cos GETCHR INCs
3429+ 32D4 CD E7 25             call    GETCHR          ; Get next character
3430+ 32D7 CA E1 32             jp      Z,NOXOR         ; No XOR byte given
3431+ 32DA CD 9E 23             call    CHKSYN          ; Make sure ',' follows
3432+ 32DD 2C                   defb    ','
3433+ 32DE CD FE 32             call    GETINT          ; Get integer 0-255 to XOR with
3434+ 32E1 C1           NOXOR:  pop     BC              ; Restore AND mask
3435+ 32E2 CD 14 60     WAITLP: call    INPSUB          ; Get input
3436+ 32E5 AB                   xor     E               ; Flip selected bits
3437+ 32E6 A0                   and     B               ; Result non-zero?
3438+ 32E7 CA E2 32             jp      Z,WAITLP        ; No = keep waiting
3439+ 32EA C9                   ret
3440+ 32EB
3441+ 32EB CD FE 32     SETIO:  call    GETINT          ; Get integer 0-255
3442+ 32EE 32 15 60             ld      (INPORT),A      ; Set input port
3443+ 32F1 32 DD 5F             ld      (OTPORT),A      ; Set output port
3444+ 32F4 CD 9E 23             call    CHKSYN          ; Make sure ',' follows
3445+ 32F7 2C                   defb    ','
3446+ 32F8 C3 FE 32             jp      GETINT          ; Get integer 0-255 and return
3447+ 32FB
3448+ 32FB CD E7 25     FNDNUM: call    GETCHR          ; Get next character
3449+ 32FE CD 78 2A     GETINT: call    GETNUM          ; Get a number from 0 to 255
3450+ 3301 CD 97 26     MAKINT: call    DEPINT          ; Make sure value 0 - 255
3451+ 3304 7A                   ld      A,D             ; Get MSB of number
3452+ 3305 B7                   or      A               ; Zero?
3453+ 3306 C2 B2 26             jp      NZ,FCERR        ; No - Error
3454+ 3309 2B                   dec     HL              ; dec 'cos GETCHR INCs
3455+ 330A CD E7 25             call    GETCHR          ; Get next character
3456+ 330D 7B                   ld      A,E             ; Get number to A
3457+ 330E C9                   ret
3458+ 330F
3459+ 330F
3460+ 330F              ; activate a Non-Maskable Interrupt hooked to VDP interrupt signal
3461+ 330F              ; address must point to an ISR routine that terminates with EI/RETN instructions
3462+ 330F CD 78 2A     NMI:    call    GETNUM          ; Get memory address
3463+ 3312 CD 9D 26             call    DEINT           ; get integer -32768 to 32767
3464+ 3315 7B                   ld      A,E             ; check if address is 0
3465+ 3316 B2                   or      D
3466+ 3317 20 11                jr      NZ,NM1          ; no, so jump over
3467+ 3319 F3           DISNMI: di                      ; disable INTs
3468+ 331A CD 46 33             call    NMIDINT         ; disable VDP INT
3469+ 331D E5                   push    HL              ; store HL
3470+ 331E 21 ED 45             ld      HL,$45ED        ; these are the op-codes for "RETN"
3471+ 3321 22 D6 5F             ld      (NMIUSR),HL     ; store RETN
3472+ 3324 AF                   xor     A
3473+ 3325 32 D8 5F             ld      (NMIUSR+2),A    ; "NOP"
3474+ 3328 18 11                jr      NMI2            ; execute the last part of code
3475+ 332A E5           NM1:    push    HL              ; store current HL
3476+ 332B EB                   ex      DE,HL           ; move address argument into HL
3477+ 332C F3                   di                      ; disable INTs
3478+ 332D CD 46 33             call    NMIDINT         ; disable VDP INT, if enabled
3479+ 3330 3E C3                ld      A,$C3           ; "jp" instruction
3480+ 3332 32 D6 5F             ld      (NMIUSR),A      ; store it
3481+ 3335 22 D7 5F             ld      (NMIUSR+1),HL   ; store address
3482+ 3338 CD 3F 33             call    NMIEINT         ; re-enable VDP INT
3483+ 333B FB           NMI2:   ei                      ; re-enable INTS
3484+ 333C 00                   nop                     ; wait for INTs
3485+ 333D E1                   pop    HL               ; retrieve HL
3486+ 333E C9                   ret                     ; return to caller
3487+ 333F              ; enable VDP INT
3488+ 333F CD 55 33     NMIEINT:call    NMIVR1          ; load default VReg #1 setting
3489+ 3342 F6 20                or      %00100000       ; enable VDP INT
3490+ 3344 18 03                jr      NMIINT          ; rest of code is shared
3491+ 3346              ; disable VDP INT
3492+ 3346 CD 55 33     NMIDINT:call    NMIVR1          ; load default VReg #1 setting
3493+ 3349 D5           NMIINT: push    DE              ; store DE
3494+ 334A 5F                   ld      E,A             ; move value into E
3495+ 334B 3E 01                ld      A,$01           ; VREG #1
3496+ 334D F3                   di                      ; disable INTs
3497+ 334E CD B0 06             call    WRITE_VREG      ; disable VDP INT
3498+ 3351 FB                   ei                      ; re-enable INTs
3499+ 3352 00                   nop                     ; wait for INTs being enabled
3500+ 3353 D1                   pop     DE              ; retrieve DE
3501+ 3354 C9                   ret                     ; return to caller
3502+ 3355
3503+ 3355              ; load VREG #1 setting for current screen mode and return it into A
3504+ 3355 E5           NMIVR1: push    HL              ; store HL
3505+ 3356 D5                   push    DE              ; store DE
3506+ 3357 3A 6D 61             ld      A,(SCR_MODE)    ; check screen mode
3507+ 335A 87                   add     A,A             ; multiply A by 8...
3508+ 335B 87                   add     A,A             ; ...so that reg. A can points..
3509+ 335C 87                   add     A,A             ; to the correct settings
3510+ 335D 3C                   inc     A               ; need to change VREG 1
3511+ 335E 5F                   ld      E,A             ; copy A into E
3512+ 335F 16 00                ld      D,$00           ; reset D
3513+ 3361 21 1F 0B             ld      HL,VDPMODESET   ; pointer to register #1 setting...
3514+ 3364 19                   add     HL,DE           ; ...for current screen mode
3515+ 3365 7E                   ld      A,(HL)          ; load current setting
3516+ 3366 D1                   pop     DE              ; retrieve DE
3517+ 3367 E1                   pop     HL              ; retrieve HL
3518+ 3368 C9                   ret                     ; return to caller
3519+ 3369
3520+ 3369              ; execute a machine language routine, eventually passing a param into A
3521+ 3369 CD 78 2A     SYS:    call    GETNUM          ; Get memory address
3522+ 336C CD 9D 26             call    DEINT           ; Get integer -32768 to 32767
3523+ 336F ED 53 7D 61          ld      (TMPBFR2),DE    ; store user routine's address
3524+ 3373 AF                   xor     A               ; reset A
3525+ 3374 32 7B 61             ld      (TMPBFR1),A     ; store into temp buffer
3526+ 3377 2B                   dec     HL              ; dec 'cos GETCHR INCs
3527+ 3378 CD E7 25             call    GETCHR          ; check next character
3528+ 337B 28 0A                jr      Z,NOSYSPR       ; jump if nothing follows
3529+ 337D CD 9E 23             call    CHKSYN          ; Make sure ',' follows
3530+ 3380 2C                   defb    ','
3531+ 3381 CD FE 32             call    GETINT          ; get byte value (0~255) if something follows
3532+ 3384 32 7B 61             ld      (TMPBFR1),A     ; store into temp buffer
3533+ 3387 3A 7B 61     NOSYSPR:ld      A,(TMPBFR1)     ; recover A
3534+ 338A ED 5B 7D 61          ld      DE,(TMPBFR2)    ; recover user routine's address
3535+ 338E E5                   push    HL              ; save code string address
3536+ 338F EB                   ex      DE,HL           ; move user routine's address into HL
3537+ 3390 11 95 33             ld      DE,SYSRET       ; set point of return after the user routine
3538+ 3393 D5                   push    DE              ; store into stack
3539+ 3394 E9                   jp      (HL)            ; call user routine
3540+ 3395 E1           SYSRET: pop     HL              ; retrieve code string address
3541+ 3396 C9                   ret                     ; return to caller
3542+ 3397
3543+ 3397
3544+ 3397              ; read the contents of a RAM location
3545+ 3397 CD 9D 26     PEEK:   call    DEINT           ; Get memory address into DE
3546+ 339A 1A                   ld      A,(DE)          ; Read value of memory cell
3547+ 339B C3 71 2E             jp      PASSA           ; Return into A
3548+ 339E
3549+ 339E              ; read the contents of a VRAM location
3550+ 339E CD 9D 26     VPEEK:  call    DEINT           ; Get VRAM address into DE
3551+ 33A1 EB                   ex      DE,HL           ; Copy param into HL
3552+ 33A2 F3                   di                      ; Disable interrupts
3553+ 33A3 CD 86 06             call    READ_VIDEO_LOC  ; Read data from VRAM at address HL
3554+ 33A6 FB                   ei                      ; Re-enable interrupts
3555+ 33A7 EB                   ex      DE,HL           ; Restore HL
3556+ 33A8 C3 71 2E             jp      PASSA           ; Return value into A
3557+ 33AB
3558+ 33AB              ; recover params for POKE/VPOKE commands
3559+ 33AB              ; returns address into DE and byte to be written into A
3560+ 33AB CD 78 2A     PKEPRMS:call    GETNUM          ; Get memory address
3561+ 33AE CD 9D 26             call    DEINT           ; Get integer -32768 to 32767
3562+ 33B1 ED 53 7B 61          ld      (TMPBFR1),DE    ; Store DE into a temp. buffer
3563+ 33B5 CD 9E 23             call    CHKSYN          ; Make sure ',' follows
3564+ 33B8 2C                   defb    ','
3565+ 33B9 CD FE 32             call    GETINT          ; Get integer 0-255
3566+ 33BC ED 5B 7B 61          ld      DE,(TMPBFR1)    ; Restore memory address
3567+ 33C0 C9                   ret                     ; Return to caller
3568+ 33C1
3569+ 33C1              ; write a byte into a RAM location
3570+ 33C1 CD AB 33     POKE:   call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3571+ 33C4 12                   ld      (DE),A          ; Load it into memory
3572+ 33C5 C9                   ret
3573+ 33C6
3574+ 33C6              ; write a byte into a VRAM location
3575+ 33C6 CD AB 33     VPOKE:  call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3576+ 33C9 EB                   ex      DE,HL           ; Copy address into HL
3577+ 33CA F3                   di                      ; Disable interrupts
3578+ 33CB CD 9B 06             call    WRITE_VIDEO_LOC ; write data into VRAM at address HL
3579+ 33CE FB                   ei                      ; Re-enable interrupts
3580+ 33CF EB                   ex      DE,HL           ; Restore HL
3581+ 33D0 C9                   ret                     ; Return to caller
3582+ 33D1
3583+ 33D1              ; position the cursor at a specific X,Y location onto screen
3584+ 33D1 CD FE 32     LOCATE: call    GETINT          ; get the first param into A
3585+ 33D4 E5                   push    HL              ; store HL
3586+ 33D5 21 6B 61             ld      HL,SCR_SIZE_W   ; load address of screen width
3587+ 33D8 5E                   ld      E,(HL)          ; load screen width into E
3588+ 33D9 E1                   pop     HL              ; restore HL
3589+ 33DA BB                   cp      E               ; compare witdh with param
3590+ 33DB D2 B2 26             jp      NC,FCERR        ; value over the width of the screen, exit with Illegal F.C. error
3591+ 33DE 32 7B 61             ld      (TMPBFR1),A     ; Store X into a temp. buffer
3592+ 33E1 CD 9E 23             call    CHKSYN          ; Make sure ',' follows
3593+ 33E4 2C                   defb    ','
3594+ 33E5 CD FE 32             call    GETINT          ; Get the second param into A
3595+ 33E8 E5                   push    HL              ; store HL
3596+ 33E9 21 6C 61             ld      HL,SCR_SIZE_H   ; load address of screen width
3597+ 33EC 5E                   ld      E,(HL)          ; load screen width into A
3598+ 33ED E1                   pop     HL              ; restore HL
3599+ 33EE BB                   cp      E               ; compare witdh with param
3600+ 33EF D2 B2 26             jp      NC,FCERR        ; value over the height of the screen, exit with Illegal F.C. error
3601+ 33F2 32 73 61             ld      (SCR_CUR_NY),A  ; store new Y
3602+ 33F5 3A 7B 61             ld      A,(TMPBFR1)     ; recover the new X
3603+ 33F8 32 72 61             ld      (SCR_CUR_NX),A  ; store new X
3604+ 33FB E5                   push    HL              ; store HL
3605+ 33FC F3                   di                      ; disable INTs
3606+ 33FD CD CC 06             call    MOVCRS          ; move cursor to new location
3607+ 3400 FB                   ei                      ; re-enable INTs
3608+ 3401 E1                   pop     HL              ; restore HL
3609+ 3402 C9                   ret                     ; return to caller
3610+ 3403
3611+ 3403              ; write a byte into one of the PSG registers
3612+ 3403 CD FE 32     SREG:   call    GETINT          ; Get register number back into A
3613+ 3406 FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3614+ 3408 D2 B2 26             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3615+ 340B 32 7B 61             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3616+ 340E CD 9E 23             call    CHKSYN          ; Make sure ',' follows
3617+ 3411 2C                   defb    ','
3618+ 3412 CD FE 32             call    GETINT          ; get second value (0-255), returned into A
3619+ 3415 5F                   ld      E,A             ; store value into E
3620+ 3416 3A 7B 61             ld      A,(TMPBFR1)     ; recover VDP register and store into D
3621+ 3419 F3                   di                      ; disable INTs
3622+ 341A 0E 40                ld      C,PSG_REG       ; output port to access PSG registers
3623+ 341C ED 79                out     (C),A           ; send register # to PSG
3624+ 341E 0E 41                ld      C,PSG_DAT       ; output port to send data to PSG
3625+ 3420 ED 59                out     (C),E           ; send byte to write into selected register
3626+ 3422 FB                   ei                      ; re-enable INTs
3627+ 3423 C9                   ret                     ; return to caller
3628+ 3424
3629+ 3424              ; VOLUME ch,vol
3630+ 3424              ; set the volume for the audio channels
3631+ 3424              ; "ch" is 1~3 for corresponding channel, or 0 for all; "vol" is 0~15 (0=OFF, 15=MAX)
3632+ 3424 CD FE 32     VOLUME: call    GETINT          ; get integer 0-255 (recover channel)
3633+ 3427 FE 04                cp      $04             ; check if it's in the range 0~3
3634+ 3429 D2 B2 26             jp      NC,FCERR        ; if not, exit with Illegal function call error
3635+ 342C 32 7B 61             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3636+ 342F CD 9E 23             call    CHKSYN          ; Make sure ',' follows
3637+ 3432 2C                   defb    ','
3638+ 3433 CD FE 32             call    GETINT          ; get integer 0-255 (recover channel)
3639+ 3436 FE 10                cp      $10             ; check if it's in the range 0~15
3640+ 3438 D2 B2 26             jp      NC,FCERR        ; if not, exit with Illegal funcion call
3641+ 343B 57                   ld      D,A             ; store volume into D
3642+ 343C 3A 7B 61             ld      A,(TMPBFR1)     ; retrieve channel
3643+ 343F A7                   and     A               ; is it 0? (0=every channel)
3644+ 3440 20 10                jr      NZ,VOLCH        ; no, jump over
3645+ 3442 06 03                ld      B,$03           ; yes, set every channel
3646+ 3444 1E 08                ld      E,$08           ; register volume of first channel
3647+ 3446 0E 40        RPVOLCG:ld      C,PSG_REG       ; PSG register port
3648+ 3448 ED 59                out     (C),E           ; set register #
3649+ 344A 0E 41                ld      C,PSG_DAT       ; PSG data port
3650+ 344C ED 51                out     (C),D           ; send volume
3651+ 344E 1C                   inc     E               ; next register
3652+ 344F 10 F5                djnz    RPVOLCG         ; repeat for each channel
3653+ 3451 C9                   ret                     ; return to caller
3654+ 3452 0E 40        VOLCH:  ld      C,PSG_REG       ; PSG register port
3655+ 3454 C6 07                add     $07             ; add 7 to A so that we have the correct register (1->8, 2->9, 3->10)
3656+ 3456 ED 79                out     (C),A           ; set register
3657+ 3458 0E 41                ld      C,PSG_DAT       ; PSG data port
3658+ 345A ED 51                out     (C),D           ; send volume level
3659+ 345C C9                   ret                     ; return to caller
3660+ 345D
3661+ 345D              ; SOUND ch,tone,dur
3662+ 345D              ; play a tone or noise of "tone" frequency from selected channel "ch" for duration "dur"
3663+ 345D              ; "ch" is 1~6 (0=means sound OFF,1~3 for tone, 4~6 for noise) / "tone" is 1~4,095 (0=means no tone) /
3664+ 345D              ; "dur" is 1~16383 h.o.s.,0.001~163s (0=means non-stop tone)
3665+ 345D CD FE 32     SOUND:  call    GETINT          ; get integer 0-255 (recover channel)
3666+ 3460 A7                   and     A               ; is it zero?
3667+ 3461 20 08                jr      NZ,CTSNDC       ; no, continue with checking of params
3668+ 3463 E5                   push    HL              ; store HL
3669+ 3464 F3                   di                      ; disable INTs
3670+ 3465 CD 91 0C             call    CLRPSGREGS      ; yes, it's zero, so reset PSG registers to shut down every sound
3671+ 3468 FB                   ei                      ; re-enable INTs
3672+ 3469 E1                   pop     HL              ; retrieve HL
3673+ 346A C9                   ret                     ; return to caller
3674+ 346B 32 7B 61     CTSNDC: ld      (TMPBFR1),A     ; no, continue by storing A into a temp. buffer
3675+ 346E FE 04                cp      $04             ; is channel >3?
3676+ 3470 D2 EF 34             jp      NC,NOISUP       ; Yes - check to see if it's a noise channel
3677+ 3473 CD 9E 23             call    CHKSYN          ; No, continue checking by making sure ',' follows
3678+ 3476 2C                   defb    ','
3679+ 3477 CD 78 2A             call    GETNUM          ; Get tone frequency
3680+ 347A CD 9D 26             call    DEINT           ; Get integer -32768 to 32767
3681+ 347D ED 53 7D 61          ld      (TMPBFR2),DE    ; Store frequency
3682+ 3481 CD 9E 23             call    CHKSYN          ; Make sure ',' follows
3683+ 3484 2C                   defb    ','
3684+ 3485 CD 78 2A             call    GETNUM          ; Get duration
3685+ 3488 CD 9D 26             call    DEINT           ; Get integer -32768 to 32767
3686+ 348B ED 53 7F 61          ld      (TMPBFR3),DE    ; Store duration
3687+ 348F                                              ; CHECK CHANNEL
3688+ 348F 3A 7B 61             ld      A,(TMPBFR1)     ; recover channel
3689+ 3492 FE 01                cp      $01             ; is channel <1?
3690+ 3494 DA B2 26             jp      C,FCERR         ; Yes - Illegal function call error
3691+ 3497                                              ; CHECK FREQUENCY
3692+ 3497 ED 5B 7D 61          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3693+ 349B 7A                   ld      A,D             ; move D into A and check if it is in the range 0~4095...
3694+ 349C FE 10                cp      $10             ; ...so D must not be greater than $0F (15)
3695+ 349E D2 B2 26             jp      NC,FCERR        ; if not in the range, exit with an Illegal function call error
3696+ 34A1                                              ; CHECK DURATION
3697+ 34A1 ED 5B 7F 61          ld      DE,(TMPBFR3)    ; restore duration from temp buffer
3698+ 34A5 7A                   ld      A,D             ; check if it is in the range 0~16383...
3699+ 34A6 E6 C0                and     $C0             ; ...(15th & 14th bits must not be set)
3700+ 34A8 C2 B2 26             jp      NZ,FCERR        ; if not in the range, exit with an Illegal function call error
3701+ 34AB                                              ;
3702+ 34AB                                              ; SET TONE:
3703+ 34AB                                              ; let's start by setting up the channel
3704+ 34AB 3A 7B 61             ld      A,(TMPBFR1)     ; restore channel value
3705+ 34AE FE 03                cp      $03             ; is it 3?
3706+ 34B0 20 02                jr      NZ,SND1         ; no, jump over
3707+ 34B2 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3708+ 34B4 2F           SND1:   cpl                     ; complement of A - this is used later to set on the channel into the mixer
3709+ 34B5 CD 3C 35             call    WRTSND          ; enable line into mixer of channel stored in A
3710+ 34B8                                              ; SET FREQUENCY
3711+ 34B8                                              ; we simply get frequency and subtract from 4096. The result
3712+ 34B8                                              ; is put into register pair of the corresponding freq tone channel
3713+ 34B8 ED 5B 7D 61          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3714+ 34BC E5                   push    HL              ; store HL (it will be used by the subroutine)
3715+ 34BD 21 00 10             ld      HL,$1000        ; load 4096 into HL
3716+ 34C0 A7                   and     A               ; reset C flag
3717+ 34C1 ED 52                sbc     HL,DE           ; subtract freq from HL - now the frequency is inverted, so we will send the low as high and vice-versa
3718+ 34C3 3A 7B 61             ld      A,(TMPBFR1)     ; restore channel value
3719+ 34C6 3D                   dec     A               ; set A into the range 0~2
3720+ 34C7 87                   add     A,A             ; double A to find the register pair that correspond to the channel (A->0,1 / B->2,3, C->4,5)
3721+ 34C8 0E 40                ld      C,PSG_REG       ; PSG register port
3722+ 34CA ED 79                out     (C),A           ; select first register of the pair
3723+ 34CC 0E 41                ld      C,PSG_DAT       ; PSG data port
3724+ 34CE ED 69                out     (C),L           ; send high byte
3725+ 34D0 0E 40                ld      C,PSG_REG       ; PSG register support
3726+ 34D2 3C                   inc     A               ; second register of the pair
3727+ 34D3 ED 79                out     (C),A           ; select register
3728+ 34D5 0E 41                ld      C,PSG_DAT       ; PSG data port
3729+ 34D7 ED 61                out     (C),H           ; send low byte
3730+ 34D9 ED 5B 7F 61          ld      DE,(TMPBFR3)    ; recover duration
3731+ 34DD 3A 7B 61             ld      A,(TMPBFR1)     ; recover channel value
3732+ 34E0 3D                   dec     A               ; set channel into the range 0~2
3733+ 34E1 87                   add     A,A             ; double A to find the correct offset
3734+ 34E2 21 AF 61             ld      HL,CHASNDDTN    ; set duration into...
3735+ 34E5 85                   add     A,L             ; ...the proper...
3736+ 34E6 30 01                jr      NC,SNDOVR       ; (is there a rest? no, jump over
3737+ 34E8 24                   inc     H               ; yes, increment H)
3738+ 34E9 6F           SNDOVR: ld      L,A             ; ...register pair...
3739+ 34EA 73                   ld      (HL),E          ; ...and store the value
3740+ 34EB 23                   inc     HL
3741+ 34EC 72                   ld      (HL),D
3742+ 34ED E1                   pop     HL              ; retrieve HL
3743+ 34EE C9                   ret                     ; Return to caller
3744+ 34EF FE 07        NOISUP: cp      $07             ; is channel in range 4 to 6 (for a noise)?
3745+ 34F1 D2 B2 26             jp      NC,FCERR        ; no, so ILLEGAL FUNCTION CALL
3746+ 34F4 CD 9E 23             call    CHKSYN          ; yes, continue checking by making sure ',' follows
3747+ 34F7 2C                   defb    ','
3748+ 34F8 CD FE 32             call    GETINT          ; get integer 0-255 (frequency)
3749+ 34FB FE 20                cp      $20             ; make sure it's in range 0~31
3750+ 34FD D2 B2 26             jp      NC,FCERR        ; no, so Illegal function call
3751+ 3500 32 7D 61             ld      (TMPBFR2),A     ; store freq.
3752+ 3503 2B                   dec     HL              ; dec 'cos GETCHR INCs
3753+ 3504 CD E7 25             call    GETCHR          ; check that nothing follows
3754+ 3507 C2 9E 20             jp      NZ,SNERR        ; error if no empty line
3755+ 350A 3A 7D 61             ld      A,(TMPBFR2)     ; retrieve freq.
3756+ 350D 5F                   ld      E,A             ; store freq into E
3757+ 350E 3A 7B 61             ld      A,(TMPBFR1)     ; retrieve channel
3758+ 3511 D6 03                sub     $03             ; subtract 3 to get channel in range 1~3
3759+ 3513 FE 03                cp      $03             ; is it 3?
3760+ 3515 20 02                jr      NZ,NOS1         ; no, jump over
3761+ 3517 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3762+ 3519 87           NOS1:   add     A,A
3763+ 351A 87                   add     A,A
3764+ 351B 87                   add     A,A             ; let's move A 3 bits to left
3765+ 351C 47                   ld      B,A             ; store channel into B
3766+ 351D 7B                   ld      A,E             ; check if
3767+ 351E A7                   and     A               ; freq is 0 (means that noise reproduction must be halted)
3768+ 351F F3                   di                      ; disable INts
3769+ 3520 20 0A                jr      NZ,NOS2         ; no, so jump over
3770+ 3522 3E 07                ld      A,$07           ; mixer register
3771+ 3524 CD DF 0C             call    SETSNDREG       ; set mixer register
3772+ 3527 ED 78                in      A,(C)           ; load current mixer value
3773+ 3529 B0                   or      B               ; disable noise
3774+ 352A 18 19                jr      NOS3            ; continue over
3775+ 352C 78           NOS2:   ld      A,B             ; recover channel
3776+ 352D 2F                   cpl                     ; complement of A - this is used to set on the channel into the mixer
3777+ 352E CD 3C 35             call    WRTSND          ; enable line into mixer of channel stored in A
3778+ 3531 3E 06                ld      A,$06           ; write into noise register
3779+ 3533 CD DF 0C             call    SETSNDREG       ; set register into PSG
3780+ 3536 7B                   ld      A,E             ; load value for noise frequency
3781+ 3537 CD E4 0C             call    WRTSNDREG       ; write data into register $06
3782+ 353A FB                   ei                      ; re-enable INTs
3783+ 353B C9                   ret
3784+ 353C                      ; enable line into mixer of channel stored in A
3785+ 353C 47           WRTSND: ld      B,A             ; move channel into B
3786+ 353D 3E 07                ld      A,$07           ; mixer register
3787+ 353F CD DF 0C             call    SETSNDREG       ; set mixer register
3788+ 3542 ED 78                in      A,(C)           ; load current value
3789+ 3544 A0                   and     B               ; set on the channel into the mixer (remember that 0=ON)
3790+ 3545                                              ; example: if channel is A (1), complement of 1 is 254 (11111110). So, 255 (in case
3791+ 3545                                              ; the register is still unchanged after reset) is 11111111 and
3792+ 3545                                              ; 11111111 AND 11111110 is equal to 11111110
3793+ 3545                                              ; 11111001 AND 11111110 is equal to 11111000 (in case channels B & C are ON)
3794+ 3545 47           NOS3:   ld      B,A             ; store new mixer value into B
3795+ 3546 3E 07                ld      A,$07           ; mixer address
3796+ 3548 CD DF 0C             call    SETSNDREG       ; set register
3797+ 354B 78                   ld      A,B             ; retrieve new mixer value from B
3798+ 354C CD E4 0C             call    WRTSNDREG       ; send new value for the mixer
3799+ 354F FB                   ei                      ; re-enable INTs
3800+ 3550 C9                   ret                     ; return to caller
3801+ 3551
3802+ 3551              ; write a byte into one of the VDP registers
3803+ 3551 CD FE 32     VREG:   call    GETINT          ; Get register number back into A
3804+ 3554 FE 08                cp      $08             ; check if value is equal or greater than 8 (VDP registers are only 8, from 0 to 7)
3805+ 3556 D2 B2 26             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3806+ 3559 32 7B 61             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3807+ 355C CD 9E 23             call    CHKSYN          ; Make sure ',' follows
3808+ 355F 2C                   defb    ','
3809+ 3560 CD FE 32             call    GETINT          ; get value (0-255)
3810+ 3563 5F                   ld      E,A             ; store value into E
3811+ 3564 3A 7B 61             ld      A,(TMPBFR1)     ; recover VDP register and store into A
3812+ 3567 F3                   di                      ; disable INTs
3813+ 3568 CD B0 06             call    WRITE_VREG      ; write value into VDP register
3814+ 356B FB                   ei                      ; re-enable INTs
3815+ 356C C9                   ret                     ; return to caller
3816+ 356D
3817+ 356D              ; read the VDP status register and return it into A
3818+ 356D CD 9D 26     VSTAT:  call    DEINT           ; Get integer -32768 to 32767 (Note: we do NOT use it)
3819+ 3570 F3                   di                      ; disable INTs
3820+ 3571 CD BB 06             call    READ_VSTAT      ; read VDP register status
3821+ 3574 FB                   ei                      ; re-enable INTs
3822+ 3575 C3 71 2E             jp      PASSA           ; Return integer A
3823+ 3578
3824+ 3578              ; read from PSG register and return it into A
3825+ 3578 CD 9D 26     SSTAT:  call    DEINT           ; get integer -32768 to 32767
3826+ 357B 7B                   ld      A,E             ; consider LSB
3827+ 357C FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3828+ 357E D2 B2 26             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3829+ 3581 F3                   di                      ; disable INts
3830+ 3582 0E 40                ld      C,PSG_REG       ; output port to set PSG register
3831+ 3584 ED 79                out     (C),A           ; send register to read from
3832+ 3586 ED 78                in      A,(C)           ; read register's contents and store into A
3833+ 3588 FB                   ei                      ; re-enable INTs
3834+ 3589 C3 71 2E             jp      PASSA           ; return A
3835+ 358C
3836+ 358C              ; read the temp key buffer and return the value of the current key being pressed
3837+ 358C              ; can wait for the number of 100thds of second before to return
3838+ 358C CD EB 2E     INKEY:  call    IDTEST          ; Test for illegal direct
3839+ 358F CD 9D 26             call    DEINT           ; get number param (100thds of second to wait) into DE
3840+ 3592 C5                   push    BC              ; store BC
3841+ 3593 3A 5B 61             ld      A,(TMRCNT)      ; Load current value of system timer
3842+ 3596 47                   ld      B,A             ; move it into B
3843+ 3597 3A 5B 61     CMP_A:  ld      A,(TMRCNT)      ; make a little delay of 1/100 sec...
3844+ 359A B8                   cp      B               ; ...to let the sniffer collect...
3845+ 359B 20 FA                jr      NZ,CMP_A        ; ...at least 1 char before to continue
3846+ 359D 7A                   ld      A,D             ; check the param
3847+ 359E B3                   or      E               ; if DE<>0 then...
3848+ 359F 20 05                jr      NZ,INKEY2       ; ...jump over...
3849+ 35A1 3A B7 61             ld      A,(TMPKEYBFR)   ; ...else read the buffer and...
3850+ 35A4 18 2A                jr      ENDINK          ; ...return it
3851+ 35A6 7A           INKEY2: ld      A,D             ; check if param>1023
3852+ 35A7 FE 04                cp      $04             ; to do this we check if MSB>3
3853+ 35A9 D2 B2 26             jp      NC,FCERR        ; if MSB >=4 then error
3854+ 35AC E5                   push    HL              ; store HL
3855+ 35AD 21 09 00             ld      HL,$0009        ; check if value
3856+ 35B0 CD 3B 4D             call    CMP16           ; is < 10
3857+ 35B3 E1                   pop     HL              ; retrieve HL
3858+ 35B4 DA BA 35             jp      C,SRTINK        ; if value >= 10 then jump over
3859+ 35B7 11 0A 00             ld      DE,$000A        ; else, use 10 (no intervals shorter than 10/100s)
3860+ 35BA 3A 5B 61     SRTINK: ld      A,(TMRCNT)      ; Load the first byte of the system timer
3861+ 35BD 47                   ld      B,A             ; move it into B
3862+ 35BE 3A B7 61     CHKINK: ld      A,(TMPKEYBFR)   ; load char code from buffer
3863+ 35C1 A7                   and     A               ; is it 0?
3864+ 35C2 20 0C                jr      NZ,ENDINK       ; no, so we can return it
3865+ 35C4 3A 5B 61             ld      A,(TMRCNT)      ; load the first byte of the system timer
3866+ 35C7 B8                   cp      B               ; is it the same value?
3867+ 35C8 28 F4                jr      Z,CHKINK        ; yes, so read again
3868+ 35CA 47                   ld      B,A             ; store new value
3869+ 35CB 1B                   dec     DE              ; no, decrement timer
3870+ 35CC 7A                   ld      A,D             ; check if zero reached
3871+ 35CD B3                   or      E               ; by ORing D and E
3872+ 35CE 20 EE                jr      NZ,CHKINK       ; if not 0, repeat
3873+ 35D0 C1           ENDINK: pop     BC              ; restore BC
3874+ 35D1 F5                   push    AF              ; store A
3875+ 35D2 F3                   di                      ; disable INTs
3876+ 35D3 AF                   xor     A               ; clear the...
3877+ 35D4 32 B7 61             ld      (TMPKEYBFR),A   ; ...TMP KEY buffer for the next read
3878+ 35D7 FB                   ei                      ; re-enable INTs
3879+ 35D8 F1                   pop     AF              ; retrieve A
3880+ 35D9 C3 71 2E     ENDINK2:jp      PASSA           ; return A as ASCII value
3881+ 35DC
3882+ 35DC
3883+ 35DC 21 03 3B     ROUND:  ld      HL,HALF         ; Add 0.5 to FPREG
3884+ 35DF CD D4 38     ADDPHL: call    LOADFP          ; Load FP at (HL) to BCDE
3885+ 35E2 C3 EE 35             jp      FPADD           ; Add BCDE to FPREG
3886+ 35E5
3887+ 35E5
3888+ 35E5 CD D4 38     SUBPHL: call    LOADFP          ; FPREG = -FPREG + number at HL
3889+ 35E8 21                   defb    $21             ; Skip "pop BC" and "pop DE"
3890+ 35E9 C1           PSUB:   pop     BC              ; Get FP number from stack
3891+ 35EA D1                   pop     DE
3892+ 35EB CD AE 38     SUBCDE: call    INVSGN          ; Negate FPREG
3893+ 35EE 78           FPADD:  ld      A,B             ; Get FP exponent
3894+ 35EF B7                   or      A               ; Is number zero?
3895+ 35F0 C8                   ret     Z               ; Yes - Nothing to add
3896+ 35F1 3A D2 61             ld      A,(FPEXP)       ; Get FPREG exponent
3897+ 35F4 B7                   or      A               ; Is this number zero?
3898+ 35F5 CA C6 38             jp      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3899+ 35F8 90                   sub     B               ; BCDE number larger?
3900+ 35F9 D2 08 36             jp      NC,NOSWAP       ; No - Don't swap them
3901+ 35FC 2F                   cpl                     ; Two's complement
3902+ 35FD 3C                   inc     A               ;  FP exponent
3903+ 35FE EB                   ex      DE,HL
3904+ 35FF CD B6 38             call    STAKFP          ; Put FPREG on stack
3905+ 3602 EB                   ex      DE,HL
3906+ 3603 CD C6 38             call    FPBCDE          ; Move BCDE to FPREG
3907+ 3606 C1                   pop     BC              ; Restore number from stack
3908+ 3607 D1                   pop     DE
3909+ 3608 FE 19        NOSWAP: cp      24+1            ; Second number insignificant?
3910+ 360A D0                   ret     NC              ; Yes - First number is result
3911+ 360B F5                   push    AF              ; Save number of bits to scale
3912+ 360C CD EB 38             call    SIGNS           ; Set MSBs & sign of result
3913+ 360F 67                   ld      H,A             ; Save sign of result
3914+ 3610 F1                   pop     AF              ; Restore scaling factor
3915+ 3611 CD B3 36             call    SCALE           ; Scale BCDE to same exponent
3916+ 3614 B4                   or      H               ; Result to be positive?
3917+ 3615 21 CF 61             ld      HL,FPREG        ; Point to FPREG
3918+ 3618 F2 2E 36             jp      P,MINCDE        ; No - Subtract FPREG from CDE
3919+ 361B CD 93 36             call    PLUCDE          ; Add FPREG to CDE
3920+ 361E D2 74 36             jp      NC,RONDUP       ; No overflow - Round it up
3921+ 3621 23                   inc     HL              ; Point to exponent
3922+ 3622 34                   inc     (HL)            ; Increment it
3923+ 3623 CA AD 20             jp      Z,OVERR         ; Number overflowed - Error
3924+ 3626 2E 01                ld      L,$01           ; 1 bit to shift right
3925+ 3628 CD C9 36             call    SHRT1           ; Shift result right
3926+ 362B C3 74 36             jp      RONDUP          ; Round it up
3927+ 362E
3928+ 362E AF           MINCDE: xor     A               ; Clear A and carry
3929+ 362F 90                   sub     B               ; Negate exponent
3930+ 3630 47                   ld      B,A             ; Re-save exponent
3931+ 3631 7E                   ld      A,(HL)          ; Get LSB of FPREG
3932+ 3632 9B                   sbc     A, E            ; Subtract LSB of BCDE
3933+ 3633 5F                   ld      E,A             ; Save LSB of BCDE
3934+ 3634 23                   inc     HL
3935+ 3635 7E                   ld      A,(HL)          ; Get NMSB of FPREG
3936+ 3636 9A                   sbc     A,D             ; Subtract NMSB of BCDE
3937+ 3637 57                   ld      D,A             ; Save NMSB of BCDE
3938+ 3638 23                   inc     HL
3939+ 3639 7E                   ld      A,(HL)          ; Get MSB of FPREG
3940+ 363A 99                   sbc     A,C             ; Subtract MSB of BCDE
3941+ 363B 4F                   ld      C,A             ; Save MSB of BCDE
3942+ 363C DC 9F 36     CONPOS: call    C,COMPL         ; Overflow - Make it positive
3943+ 363F
3944+ 363F 68           BNORM:  ld      L,B             ; L = Exponent
3945+ 3640 63                   ld      H,E             ; H = LSB
3946+ 3641 AF                   xor     A
3947+ 3642 47           BNRMLP: ld      B,A             ; Save bit count
3948+ 3643 79                   ld      A,C             ; Get MSB
3949+ 3644 B7                   or      A               ; Is it zero?
3950+ 3645 C2 61 36             jp      NZ,PNORM        ; No - Do it bit at a time
3951+ 3648 4A                   ld      C,D             ; MSB = NMSB
3952+ 3649 54                   ld      D,H             ; NMSB= LSB
3953+ 364A 65                   ld      H,L             ; LSB = VLSB
3954+ 364B 6F                   ld      L,A             ; VLSB= 0
3955+ 364C 78                   ld      A,B             ; Get exponent
3956+ 364D D6 08                sub     $08             ; Count 8 bits
3957+ 364F FE E0                cp      -24-8           ; Was number zero?
3958+ 3651 C2 42 36             jp      NZ,BNRMLP       ; No - Keep normalising
3959+ 3654 AF           RESZER: xor     A               ; Result is zero
3960+ 3655 32 D2 61     SAVEXP: ld      (FPEXP),A       ; Save result as zero
3961+ 3658 C9                   ret
3962+ 3659
3963+ 3659 05           NORMAL: dec     B               ; Count bits
3964+ 365A 29                   add     HL,HL           ; Shift HL left
3965+ 365B 7A                   ld      A,D             ; Get NMSB
3966+ 365C 17                   rla                     ; Shift left with last bit
3967+ 365D 57                   ld      D,A             ; Save NMSB
3968+ 365E 79                   ld      A,C             ; Get MSB
3969+ 365F 8F                   adc     A,A             ; Shift left with last bit
3970+ 3660 4F                   ld      C,A             ; Save MSB
3971+ 3661 F2 59 36     PNORM:  jp      P,NORMAL        ; Not done - Keep going
3972+ 3664 78                   ld      A,B             ; Number of bits shifted
3973+ 3665 5C                   ld      E,H             ; Save HL in EB
3974+ 3666 45                   ld      B,L
3975+ 3667 B7                   or      A               ; Any shifting done?
3976+ 3668 CA 74 36             jp      Z,RONDUP        ; No - Round it up
3977+ 366B 21 D2 61             ld      HL,FPEXP        ; Point to exponent
3978+ 366E 86                   add     A,(HL)          ; Add shifted bits
3979+ 366F 77                   ld      (HL),A          ; Re-save exponent
3980+ 3670 D2 54 36             jp      NC,RESZER       ; Underflow - Result is zero
3981+ 3673 C8                   ret     Z               ; Result is zero
3982+ 3674 78           RONDUP: ld      A,B             ; Get VLSB of number
3983+ 3675 21 D2 61     RONDB:  ld      HL,FPEXP        ; Point to exponent
3984+ 3678 B7                   or      A               ; Any rounding?
3985+ 3679 FC 86 36             call    M,FPROND        ; Yes - Round number up
3986+ 367C 46                   ld      B,(HL)          ; B = Exponent
3987+ 367D 23                   inc     HL
3988+ 367E 7E                   ld      A,(HL)          ; Get sign of result
3989+ 367F E6 80                and     %10000000       ; Only bit 7 needed
3990+ 3681 A9                   xor     C               ; Set correct sign
3991+ 3682 4F                   ld      C,A             ; Save correct sign in number
3992+ 3683 C3 C6 38             jp      FPBCDE          ; Move BCDE to FPREG
3993+ 3686
3994+ 3686 1C           FPROND: inc     E               ; Round LSB
3995+ 3687 C0                   ret     NZ              ; Return if ok
3996+ 3688 14                   inc     D               ; Round NMSB
3997+ 3689 C0                   ret     NZ              ; Return if ok
3998+ 368A 0C                   inc     C               ; Round MSB
3999+ 368B C0                   ret     NZ              ; Return if ok
4000+ 368C 0E 80                ld      C,$80           ; Set normal value
4001+ 368E 34                   inc     (HL)            ; Increment exponent
4002+ 368F C0                   ret     NZ              ; Return if ok
4003+ 3690 C3 AD 20             jp      OVERR           ; Overflow error
4004+ 3693
4005+ 3693 7E           PLUCDE: ld      A,(HL)          ; Get LSB of FPREG
4006+ 3694 83                   add     A,E             ; Add LSB of BCDE
4007+ 3695 5F                   ld      E,A             ; Save LSB of BCDE
4008+ 3696 23                   inc     HL
4009+ 3697 7E                   ld      A,(HL)          ; Get NMSB of FPREG
4010+ 3698 8A                   adc     A,D             ; Add NMSB of BCDE
4011+ 3699 57                   ld      D,A             ; Save NMSB of BCDE
4012+ 369A 23                   inc     HL
4013+ 369B 7E                   ld      A,(HL)          ; Get MSB of FPREG
4014+ 369C 89                   adc     A,C             ; Add MSB of BCDE
4015+ 369D 4F                   ld      C,A             ; Save MSB of BCDE
4016+ 369E C9                   ret
4017+ 369F
4018+ 369F 21 D3 61     COMPL:  ld      HL,SGNRES       ; Sign of result
4019+ 36A2 7E                   ld      A,(HL)          ; Get sign of result
4020+ 36A3 2F                   cpl                     ; Negate it
4021+ 36A4 77                   ld      (HL),A          ; Put it back
4022+ 36A5 AF                   xor     A
4023+ 36A6 6F                   ld      L,A             ; Set L to zero
4024+ 36A7 90                   sub     B               ; Negate exponent,set carry
4025+ 36A8 47                   ld      B,A             ; Re-save exponent
4026+ 36A9 7D                   ld      A,L             ; Load zero
4027+ 36AA 9B                   sbc     A,E             ; Negate LSB
4028+ 36AB 5F                   ld      E,A             ; Re-save LSB
4029+ 36AC 7D                   ld      A,L             ; Load zero
4030+ 36AD 9A                   sbc     A,D             ; Negate NMSB
4031+ 36AE 57                   ld      D,A             ; Re-save NMSB
4032+ 36AF 7D                   ld      A,L             ; Load zero
4033+ 36B0 99                   sbc     A,C             ; Negate MSB
4034+ 36B1 4F                   ld      C,A             ; Re-save MSB
4035+ 36B2 C9                   ret
4036+ 36B3
4037+ 36B3 06 00        SCALE:  ld      B,$00           ; Clear underflow
4038+ 36B5 D6 08        SCALLP: sub     $08             ; 8 bits (a whole byte)?
4039+ 36B7 DA C2 36             jp      C,SHRITE        ; No - Shift right A bits
4040+ 36BA 43                   ld      B,E             ; <- Shift
4041+ 36BB 5A                   ld      E,D             ; <- right
4042+ 36BC 51                   ld      D,C             ; <- eight
4043+ 36BD 0E 00                ld      C,$00           ; <- bits
4044+ 36BF C3 B5 36             jp      SCALLP          ; More bits to shift
4045+ 36C2
4046+ 36C2 C6 09        SHRITE: add     A,8+1           ; Adjust count
4047+ 36C4 6F                   ld      L,A             ; Save bits to shift
4048+ 36C5 AF           SHRLP:  xor     A               ; Flag for all done
4049+ 36C6 2D                   dec     L               ; All shifting done?
4050+ 36C7 C8                   ret     Z               ; Yes - Return
4051+ 36C8 79                   ld      A,C             ; Get MSB
4052+ 36C9 1F           SHRT1:  rra                     ; Shift it right
4053+ 36CA 4F                   ld      C,A             ; Re-save
4054+ 36CB 7A                   ld      A,D             ; Get NMSB
4055+ 36CC 1F                   rra                     ; Shift right with last bit
4056+ 36CD 57                   ld      D,A             ; Re-save it
4057+ 36CE 7B                   ld      A,E             ; Get LSB
4058+ 36CF 1F                   rra                     ; Shift right with last bit
4059+ 36D0 5F                   ld      E,A             ; Re-save it
4060+ 36D1 78                   ld      A,B             ; Get underflow
4061+ 36D2 1F                   rra                     ; Shift right with last bit
4062+ 36D3 47                   ld      B,A             ; Re-save underflow
4063+ 36D4 C3 C5 36             jp      SHRLP           ; More bits to do
4064+ 36D7
4065+ 36D7 00 00 00 81  UNITY:  defb    $00,$00,$00,$81 ; 1.00000
4066+ 36DB
4067+ 36DB 03           LOGTAB: defb    $03             ; Table used by LOG
4068+ 36DC AA 56 19 80          defb    $AA,$56,$19,$80 ; 0.59898
4069+ 36E0 F1 22 76 80          defb    $F1,$22,$76,$80 ; 0.96147
4070+ 36E4 45 AA 38 82          defb    $45,$AA,$38,$82 ; 2.88539
4071+ 36E8
4072+ 36E8 CD 85 38     LOG:    call    TSTSGN          ; Test sign of value
4073+ 36EB B7                   or      A
4074+ 36EC EA B2 26             jp      PE,FCERR        ; ?FC Error if <= zero
4075+ 36EF 21 D2 61             ld      HL,FPEXP        ; Point to exponent
4076+ 36F2 7E                   ld      A,(HL)          ; Get exponent
4077+ 36F3 01 35 80             ld      BC,$8035        ; BCDE = SQR(1/2)
4078+ 36F6 11 F3 04             ld      DE,$04F3
4079+ 36F9 90                   sub     B               ; Scale value to be < 1
4080+ 36FA F5                   push    AF              ; Save scale factor
4081+ 36FB 70                   ld      (HL),B          ; Save new exponent
4082+ 36FC D5                   push    DE              ; Save SQR(1/2)
4083+ 36FD C5                   push    BC
4084+ 36FE CD EE 35             call    FPADD           ; Add SQR(1/2) to value
4085+ 3701 C1                   pop     BC              ; Restore SQR(1/2)
4086+ 3702 D1                   pop     DE
4087+ 3703 04                   inc     B               ; Make it SQR(2)
4088+ 3704 CD DB 37             call    DVBCDE          ; Divide by SQR(2)
4089+ 3707 21 D7 36             ld      HL,UNITY        ; Point to 1.
4090+ 370A CD E5 35             call    SUBPHL          ; Subtract FPREG from 1
4091+ 370D 21 DB 36             ld      HL,LOGTAB       ; Coefficient table
4092+ 3710 CD CD 3B             call    SUMSER          ; Evaluate sum of series
4093+ 3713 01 80 80             ld      BC,$8080        ; BCDE = -0.5
4094+ 3716 11 00 00             ld      DE,$0000
4095+ 3719 CD EE 35             call    FPADD           ; Subtract 0.5 from FPREG
4096+ 371C F1                   pop     AF              ; Restore scale factor
4097+ 371D CD 00 3A             call    RSCALE          ; Re-scale number
4098+ 3720 01 31 80     MULLN2: ld      BC,$8031        ; BCDE = Ln(2)
4099+ 3723 11 18 72             ld      DE,$7218
4100+ 3726 21                   defb    $21             ; Skip "pop BC" and "pop DE"
4101+ 3727
4102+ 3727 C1           MULT:   pop     BC              ; Get number from stack
4103+ 3728 D1                   pop     DE
4104+ 3729 CD 85 38     FPMULT: call    TSTSGN          ; Test sign of FPREG
4105+ 372C C8                   ret     Z               ; Return zero if zero
4106+ 372D 2E 00                ld      L,$00           ; Flag add exponents
4107+ 372F CD 43 38             call    ADDEXP          ; Add exponents
4108+ 3732 79                   ld      A,C             ; Get MSB of multiplier
4109+ 3733 32 E1 61             ld      (MULVAL),A      ; Save MSB of multiplier
4110+ 3736 EB                   ex      DE,HL
4111+ 3737 22 E2 61             ld      (MULVAL+1),HL   ; Save rest of multiplier
4112+ 373A 01 00 00             ld      BC,$0000        ; Partial product (BCDE) = zero
4113+ 373D 50                   ld      D,B
4114+ 373E 58                   ld      E,B
4115+ 373F 21 3F 36             ld      HL,BNORM        ; Address of normalise
4116+ 3742 E5                   push    HL              ; Save for return
4117+ 3743 21 4B 37             ld      HL,MULT8        ; Address of 8 bit multiply
4118+ 3746 E5                   push    HL              ; Save for NMSB,MSB
4119+ 3747 E5                   push    HL              ;
4120+ 3748 21 CF 61             ld      HL,FPREG        ; Point to number
4121+ 374B 7E           MULT8:  ld      A,(HL)          ; Get LSB of number
4122+ 374C 23                   inc     HL              ; Point to NMSB
4123+ 374D B7                   or      A               ; Test LSB
4124+ 374E CA 77 37             jp      Z,BYTSFT        ; Zero - shift to next byte
4125+ 3751 E5                   push    HL              ; Save address of number
4126+ 3752 2E 08                ld      L,$08           ; 8 bits to multiply by
4127+ 3754 1F           MUL8LP: rra                     ; Shift LSB right
4128+ 3755 67                   ld      H,A             ; Save LSB
4129+ 3756 79                   ld      A,C             ; Get MSB
4130+ 3757 D2 65 37             jp      NC,NOMADD       ; Bit was zero - Don't add
4131+ 375A E5                   push    HL              ; Save LSB and count
4132+ 375B 2A E2 61             ld      HL,(MULVAL+1)   ; Get LSB and NMSB
4133+ 375E 19                   add     HL,DE           ; Add NMSB and LSB
4134+ 375F EB                   ex      DE,HL           ; Leave sum in DE
4135+ 3760 E1                   pop     HL              ; Restore MSB and count
4136+ 3761 3A E1 61             ld      A,(MULVAL)      ; Get MSB of multiplier
4137+ 3764 89                   adc     A,C             ; Add MSB
4138+ 3765 1F           NOMADD: rra                     ; Shift MSB right
4139+ 3766 4F                   ld      C,A             ; Re-save MSB
4140+ 3767 7A                   ld      A,D             ; Get NMSB
4141+ 3768 1F                   rra                     ; Shift NMSB right
4142+ 3769 57                   ld      D,A             ; Re-save NMSB
4143+ 376A 7B                   ld      A,E             ; Get LSB
4144+ 376B 1F                   rra                     ; Shift LSB right
4145+ 376C 5F                   ld      E,A             ; Re-save LSB
4146+ 376D 78                   ld      A,B             ; Get VLSB
4147+ 376E 1F                   rra                     ; Shift VLSB right
4148+ 376F 47                   ld      B,A             ; Re-save VLSB
4149+ 3770 2D                   dec     L               ; Count bits multiplied
4150+ 3771 7C                   ld      A,H             ; Get LSB of multiplier
4151+ 3772 C2 54 37             jp      NZ,MUL8LP       ; More - Do it
4152+ 3775 E1           POPHRT: pop     HL              ; Restore address of number
4153+ 3776 C9                   ret
4154+ 3777
4155+ 3777 43           BYTSFT: ld      B,E             ; Shift partial product left
4156+ 3778 5A                   ld      E,D
4157+ 3779 51                   ld      D,C
4158+ 377A 4F                   ld      C,A
4159+ 377B C9                   ret
4160+ 377C
4161+ 377C
4162+ 377C              ; WORKING ââ
4163+ 377C C1           DINT:   pop     BC              ; Get number from stack
4164+ 377D D1                   pop     DE
4165+ 377E CD DB 37             call    DVBCDE          ; get BCDE/FPREG and store result into FPREG
4166+ 3781 C3 58 39             jp      INT             ; return INT(FPREG)
4167+ 3784
4168+ 3784
4169+ 3784              ; A MODULO B - return remainder of the integer division A/B where:
4170+ 3784              ; A is in stack; B is in FPREG
4171+ 3784              ; math is:
4172+ 3784              ; A=INT(A); B=INT(B); R=A-(B*INT(A/B))
4173+ 3784 CD 58 39     MOD:    call    INT             ; B=INT(B)
4174+ 3787 CD D1 38             call    BCDEFP          ; copy B (from FPREG) into BCDE
4175+ 378A ED 53 7F 61          ld      (TMPBFR3),DE    ; store B into...
4176+ 378E ED 43 81 61          ld      (TMPBFR4),BC    ; ...a temp buffer
4177+ 3792 C1                   pop     BC              ; recover A...
4178+ 3793 D1                   pop     DE              ; ...from stack
4179+ 3794 CD C6 38             call    FPBCDE          ; store A into FPREG
4180+ 3797 CD 58 39             call    INT             ; get integer part: A=INT(A)
4181+ 379A CD D1 38             call    BCDEFP          ; copy A (from FPREG) into BCDE
4182+ 379D ED 53 7B 61          ld      (TMPBFR1),DE    ; store A into...
4183+ 37A1 ED 43 7D 61          ld      (TMPBFR2),BC    ; ...a temp buffer
4184+ 37A5                                              ; begin calculation
4185+ 37A5 2A 7F 61             ld      HL,(TMPBFR3)    ; move B...
4186+ 37A8 22 CF 61             ld      (FPREG),HL      ; ...from...
4187+ 37AB 2A 81 61             ld      HL,(TMPBFR4)    ; ...temp buffer...
4188+ 37AE 22 D1 61             ld      (FPREG+2),HL    ; ...into FPREG
4189+ 37B1 CD DB 37             call    DVBCDE          ; compute A/B and store into FPREG
4190+ 37B4 CD 58 39             call    INT             ; get integer part of result: now FPREG = INT(A/B)
4191+ 37B7 ED 5B 7F 61          ld      DE,(TMPBFR3)    ; load B...
4192+ 37BB ED 4B 81 61          ld      BC,(TMPBFR4)    ; ...into BCDE
4193+ 37BF CD 29 37             call    FPMULT          ; get B*INT(A/B) and store into FPREG
4194+ 37C2 ED 5B 7B 61          ld      DE,(TMPBFR1)    ; retrieve A from...
4195+ 37C6 ED 4B 7D 61          ld      BC,(TMPBFR2)    ; ...temp buffer
4196+ 37CA C3 EB 35             jp      SUBCDE          ; return result of A-(B*INT(A/B))
4197+ 37CD
4198+ 37CD
4199+ 37CD CD B6 38     DIV10:  call    STAKFP          ; Save FPREG on stack
4200+ 37D0 01 20 84             ld      BC,$8420        ; BCDE = 10.
4201+ 37D3 11 00 00             ld      DE,$0000
4202+ 37D6 CD C6 38             call    FPBCDE          ; Move 10 to FPREG
4203+ 37D9
4204+ 37D9 C1           DIV:    pop     BC              ; Get number from stack
4205+ 37DA D1                   pop     DE
4206+ 37DB CD 85 38     DVBCDE: call    TSTSGN          ; Test sign of FPREG
4207+ 37DE CA A1 20             jp      Z,DZERR         ; Error if division by zero
4208+ 37E1 2E FF                ld      L,-1            ; Flag subtract exponents
4209+ 37E3 CD 43 38             call    ADDEXP          ; Subtract exponents
4210+ 37E6 34                   inc     (HL)            ; Add 2 to exponent to adjust
4211+ 37E7 34                   inc     (HL)
4212+ 37E8 2B                   dec     HL              ; Point to MSB
4213+ 37E9 7E                   ld      A,(HL)          ; Get MSB of dividend
4214+ 37EA 32 E8 5F             ld      (DIV3),A        ; Save for subtraction
4215+ 37ED 2B                   dec     HL
4216+ 37EE 7E                   ld      A,(HL)          ; Get NMSB of dividend
4217+ 37EF 32 E4 5F             ld      (DIV2),A        ; Save for subtraction
4218+ 37F2 2B                   dec     HL
4219+ 37F3 7E                   ld      A,(HL)          ; Get MSB of dividend
4220+ 37F4 32 E0 5F             ld      (DIV1),A        ; Save for subtraction
4221+ 37F7 41                   ld      B,C             ; Get MSB
4222+ 37F8 EB                   ex      DE,HL           ; NMSB,LSB to HL
4223+ 37F9 AF                   xor     A
4224+ 37FA 4F                   ld      C,A             ; Clear MSB of quotient
4225+ 37FB 57                   ld      D,A             ; Clear NMSB of quotient
4226+ 37FC 5F                   ld      E,A             ; Clear LSB of quotient
4227+ 37FD 32 EB 5F             ld      (DIV4),A        ; Clear overflow count
4228+ 3800 E5           DIVLP:  push    HL              ; Save divisor
4229+ 3801 C5                   push    BC
4230+ 3802 7D                   ld      A,L             ; Get LSB of number
4231+ 3803 CD DF 5F             call    DIVSUP          ; Subt' divisor from dividend
4232+ 3806 DE 00                sbc     A,$00           ; Count for overflows
4233+ 3808 3F                   ccf
4234+ 3809 D2 13 38             jp      NC,RESDIV       ; Restore divisor if borrow
4235+ 380C 32 EB 5F             ld      (DIV4),A        ; Re-save overflow count
4236+ 380F F1                   pop     AF              ; Scrap divisor
4237+ 3810 F1                   pop     AF
4238+ 3811 37                   scf                     ; Set carry to
4239+ 3812 D2                   defb    $D2             ; Skip "pop BC" and "pop HL"
4240+ 3813
4241+ 3813 C1           RESDIV: pop     BC              ; Restore divisor
4242+ 3814 E1                   pop     HL
4243+ 3815 79                   ld      A,C             ; Get MSB of quotient
4244+ 3816 3C                   inc     A
4245+ 3817 3D                   dec     A
4246+ 3818 1F                   rra                     ; Bit 0 to bit 7
4247+ 3819 FA 75 36             jp      M,RONDB         ; Done - Normalise result
4248+ 381C 17                   rla                     ; Restore carry
4249+ 381D 7B                   ld      A,E             ; Get LSB of quotient
4250+ 381E 17                   rla                     ; Double it
4251+ 381F 5F                   ld      E,A             ; Put it back
4252+ 3820 7A                   ld      A,D             ; Get NMSB of quotient
4253+ 3821 17                   rla                     ; Double it
4254+ 3822 57                   ld      D,A             ; Put it back
4255+ 3823 79                   ld      A,C             ; Get MSB of quotient
4256+ 3824 17                   rla                     ; Double it
4257+ 3825 4F                   ld      C,A             ; Put it back
4258+ 3826 29                   add     HL,HL           ; Double NMSB,LSB of divisor
4259+ 3827 78                   ld      A,B             ; Get MSB of divisor
4260+ 3828 17                   rla                     ; Double it
4261+ 3829 47                   ld      B,A             ; Put it back
4262+ 382A 3A EB 5F             ld      A,(DIV4)        ; Get VLSB of quotient
4263+ 382D 17                   rla                     ; Double it
4264+ 382E 32 EB 5F             ld      (DIV4),A        ; Put it back
4265+ 3831 79                   ld      A,C             ; Get MSB of quotient
4266+ 3832 B2                   or      D               ; Merge NMSB
4267+ 3833 B3                   or      E               ; Merge LSB
4268+ 3834 C2 00 38             jp      NZ,DIVLP        ; Not done - Keep dividing
4269+ 3837 E5                   push    HL              ; Save divisor
4270+ 3838 21 D2 61             ld      HL,FPEXP        ; Point to exponent
4271+ 383B 35                   dec     (HL)            ; Divide by 2
4272+ 383C E1                   pop     HL              ; Restore divisor
4273+ 383D C2 00 38             jp      NZ,DIVLP        ; Ok - Keep going
4274+ 3840 C3 AD 20             jp      OVERR           ; Overflow error
4275+ 3843
4276+ 3843
4277+ 3843 78           ADDEXP: ld      A,B             ; Get exponent of dividend
4278+ 3844 B7                   or      A               ; Test it
4279+ 3845 CA 67 38             jp      Z,OVTST3        ; Zero - Result zero
4280+ 3848 7D                   ld      A,L             ; Get add/subtract flag
4281+ 3849 21 D2 61             ld      HL,FPEXP        ; Point to exponent
4282+ 384C AE                   xor     (HL)            ; Add or subtract it
4283+ 384D 80                   add     A,B             ; Add the other exponent
4284+ 384E 47                   ld      B,A             ; Save new exponent
4285+ 384F 1F                   rra                     ; Test exponent for overflow
4286+ 3850 A8                   xor     B
4287+ 3851 78                   ld      A,B             ; Get exponent
4288+ 3852 F2 66 38             jp      P,OVTST2        ; Positive - Test for overflow
4289+ 3855 C6 80                add     A,$80           ; Add excess 128
4290+ 3857 77                   ld      (HL),A          ; Save new exponent
4291+ 3858 CA 75 37             jp      Z,POPHRT        ; Zero - Result zero
4292+ 385B CD EB 38             call    SIGNS           ; Set MSBs and sign of result
4293+ 385E 77                   ld      (HL),A          ; Save new exponent
4294+ 385F 2B                   dec     HL              ; Point to MSB
4295+ 3860 C9                   ret
4296+ 3861
4297+ 3861 CD 85 38     OVTST1: call    TSTSGN          ; Test sign of FPREG
4298+ 3864 2F                   cpl                     ; Invert sign
4299+ 3865 E1                   pop     HL              ; Clean up stack
4300+ 3866 B7           OVTST2: or      A               ; Test if new exponent zero
4301+ 3867 E1           OVTST3: pop     HL              ; Clear off return address
4302+ 3868 F2 54 36             jp      P,RESZER        ; Result zero
4303+ 386B C3 AD 20             jp      OVERR           ; Overflow error
4304+ 386E
4305+ 386E CD D1 38     MLSP10: call    BCDEFP          ; Move FPREG to BCDE
4306+ 3871 78                   ld      A,B             ; Get exponent
4307+ 3872 B7                   or      A               ; Is it zero?
4308+ 3873 C8                   ret     Z               ; Yes - Result is zero
4309+ 3874 C6 02                add     A,$02           ; Multiply by 4
4310+ 3876 DA AD 20             jp      C,OVERR         ; Overflow - ?OV Error
4311+ 3879 47                   ld      B,A             ; Re-save exponent
4312+ 387A CD EE 35             call    FPADD           ; Add BCDE to FPREG (Times 5)
4313+ 387D 21 D2 61             ld      HL,FPEXP        ; Point to exponent
4314+ 3880 34                   inc     (HL)            ; Double number (Times 10)
4315+ 3881 C0                   ret     NZ              ; Ok - Return
4316+ 3882 C3 AD 20             jp      OVERR           ; Overflow error
4317+ 3885
4318+ 3885 3A D2 61     TSTSGN: ld      A,(FPEXP)       ; Get sign of FPREG
4319+ 3888 B7                   or      A
4320+ 3889 C8                   ret     Z               ; RETurn if number is zero
4321+ 388A 3A D1 61             ld      A,(FPREG+2)     ; Get MSB of FPREG
4322+ 388D FE                   defb    0FEH            ; Test sign
4323+ 388E 2F           RETREL: cpl                     ; Invert sign
4324+ 388F 17                   rla                     ; Sign bit to carry
4325+ 3890 9F           FLGDIF: sbc     A,A             ; Carry to all bits of A
4326+ 3891 C0                   ret     NZ              ; Return -1 if negative
4327+ 3892 3C                   inc     A               ; Bump to +1
4328+ 3893 C9                   ret                     ; Positive - Return +1
4329+ 3894
4330+ 3894 CD 85 38     SGN:    call    TSTSGN          ; Test sign of FPREG
4331+ 3897 06 88        FLGREL: ld      B,$80+8         ; 8 bit integer in exponent
4332+ 3899 11 00 00             ld      DE,0            ; Zero NMSB and LSB
4333+ 389C 21 D2 61     RETINT: ld      HL,FPEXP        ; Point to exponent
4334+ 389F 4F                   ld      C,A             ; CDE = MSB,NMSB and LSB
4335+ 38A0 70                   ld      (HL),B          ; Save exponent
4336+ 38A1 06 00                ld      B,0             ; CDE = integer to normalise
4337+ 38A3 23                   inc     HL              ; Point to sign of result
4338+ 38A4 36 80                ld      (HL),$80        ; Set sign of result
4339+ 38A6 17                   rla                     ; Carry = sign of integer
4340+ 38A7 C3 3C 36             jp      CONPOS          ; Set sign of result
4341+ 38AA
4342+ 38AA CD 85 38     ABS_:   call    TSTSGN          ; Test sign of FPREG
4343+ 38AD F0                   ret     P               ; Return if positive
4344+ 38AE 21 D1 61     INVSGN: ld      HL,FPREG+2      ; Point to MSB
4345+ 38B1 7E                   ld      A,(HL)          ; Get sign of mantissa
4346+ 38B2 EE 80                xor     $80             ; Invert sign of mantissa
4347+ 38B4 77                   ld      (HL),A          ; Re-save sign of mantissa
4348+ 38B5 C9                   ret
4349+ 38B6
4350+ 38B6 EB           STAKFP: ex      DE,HL           ; Save code string address
4351+ 38B7 2A CF 61             ld      HL,(FPREG)      ; LSB,NLSB of FPREG
4352+ 38BA E3                   ex      (SP),HL         ; Stack them,get return
4353+ 38BB E5                   push    HL              ; Re-save return
4354+ 38BC 2A D1 61             ld      HL,(FPREG+2)    ; MSB and exponent of FPREG
4355+ 38BF E3                   ex      (SP),HL         ; Stack them,get return
4356+ 38C0 E5                   push    HL              ; Re-save return
4357+ 38C1 EB                   ex      DE,HL           ; Restore code string address
4358+ 38C2 C9                   ret
4359+ 38C3
4360+ 38C3              ; store F.P. number from BCDE into (FPREG)
4361+ 38C3 CD D4 38     PHLTFP: call    LOADFP          ; Number at HL to BCDE
4362+ 38C6 EB           FPBCDE: ex      DE,HL           ; Save code string address
4363+ 38C7 22 CF 61             ld      (FPREG),HL      ; Save LSB,NLSB of number
4364+ 38CA 60                   ld      H,B             ; Exponent of number
4365+ 38CB 69                   ld      L,C             ; MSB of number
4366+ 38CC 22 D1 61             ld      (FPREG+2),HL    ; Save MSB and exponent
4367+ 38CF EB                   ex      DE,HL           ; Restore code string address
4368+ 38D0 C9                   ret
4369+ 38D1
4370+ 38D1              ; load F.P. number from (FPREG) into BCDE
4371+ 38D1 21 CF 61     BCDEFP: ld      HL,FPREG        ; Point to FPREG
4372+ 38D4 5E           LOADFP: ld      E,(HL)          ; Get LSB of number
4373+ 38D5 23                   inc     HL
4374+ 38D6 56                   ld      D,(HL)          ; Get NMSB of number
4375+ 38D7 23                   inc     HL
4376+ 38D8 4E                   ld      C,(HL)          ; Get MSB of number
4377+ 38D9 23                   inc     HL
4378+ 38DA 46                   ld      B,(HL)          ; Get exponent of number
4379+ 38DB 23           INCHL:  inc     HL              ; Used for conditional "inc HL"
4380+ 38DC C9                   ret
4381+ 38DD
4382+ 38DD              ; move floating point from (FPREG) into (HL)
4383+ 38DD 11 CF 61     FPTHL:  ld      DE,FPREG        ; Point to FPREG
4384+ 38E0 06 04        DETHL4: ld      B,$04           ; 4 bytes to move
4385+ 38E2 1A           DETHLB: ld      A,(DE)          ; Get source
4386+ 38E3 77                   ld      (HL),A          ; Save destination
4387+ 38E4 13                   inc     DE              ; Next source
4388+ 38E5 23                   inc     HL              ; Next destination
4389+ 38E6 05                   dec     B               ; Count bytes
4390+ 38E7 C2 E2 38             jp      NZ,DETHLB       ; Loop if more
4391+ 38EA C9                   ret
4392+ 38EB
4393+ 38EB 21 D1 61     SIGNS:  ld      HL,FPREG+2      ; Point to MSB of FPREG
4394+ 38EE 7E                   ld      A,(HL)          ; Get MSB
4395+ 38EF 07                   rlca                    ; Old sign to carry
4396+ 38F0 37                   scf                     ; Set MSBit
4397+ 38F1 1F                   rra                     ; Set MSBit of MSB
4398+ 38F2 77                   ld      (HL),A          ; Save new MSB
4399+ 38F3 3F                   ccf                     ; Complement sign
4400+ 38F4 1F                   rra                     ; Old sign to carry
4401+ 38F5 23                   inc     HL
4402+ 38F6 23                   inc     HL
4403+ 38F7 77                   ld      (HL),A          ; Set sign of result
4404+ 38F8 79                   ld      A,C             ; Get MSB
4405+ 38F9 07                   rlca                    ; Old sign to carry
4406+ 38FA 37                   scf                     ; Set MSBit
4407+ 38FB 1F                   rra                     ; Set MSBit of MSB
4408+ 38FC 4F                   ld      C,A             ; Save MSB
4409+ 38FD 1F                   rra
4410+ 38FE AE                   xor     (HL)            ; New sign of result
4411+ 38FF C9                   ret
4412+ 3900
4413+ 3900 78           CMPNUM: ld      A,B             ; Get exponent of number
4414+ 3901 B7                   or      A
4415+ 3902 CA 85 38             jp      Z,TSTSGN        ; Zero - Test sign of FPREG
4416+ 3905 21 8E 38             ld      HL,RETREL       ; Return relation routine
4417+ 3908 E5                   push    HL              ; Save for return
4418+ 3909 CD 85 38             call    TSTSGN          ; Test sign of FPREG
4419+ 390C 79                   ld      A,C             ; Get MSB of number
4420+ 390D C8                   ret     Z               ; FPREG zero - Number's MSB
4421+ 390E 21 D1 61             ld      HL,FPREG+2      ; MSB of FPREG
4422+ 3911 AE                   xor     (HL)            ; Combine signs
4423+ 3912 79                   ld      A,C             ; Get MSB of number
4424+ 3913 F8                   ret     M               ; Exit if signs different
4425+ 3914 CD 1A 39             call    CMPFP           ; Compare FP numbers
4426+ 3917 1F                   rra                     ; Get carry to sign
4427+ 3918 A9                   xor     C               ; Combine with MSB of number
4428+ 3919 C9                   ret
4429+ 391A
4430+ 391A 23           CMPFP:  inc     HL              ; Point to exponent
4431+ 391B 78                   ld      A,B             ; Get exponent
4432+ 391C BE                   cp      (HL)            ; Compare exponents
4433+ 391D C0                   ret     NZ              ; Different
4434+ 391E 2B                   dec     HL              ; Point to MBS
4435+ 391F 79                   ld      A,C             ; Get MSB
4436+ 3920 BE                   cp      (HL)            ; Compare MSBs
4437+ 3921 C0                   ret     NZ              ; Different
4438+ 3922 2B                   dec     HL              ; Point to NMSB
4439+ 3923 7A                   ld      A,D             ; Get NMSB
4440+ 3924 BE                   cp      (HL)            ; Compare NMSBs
4441+ 3925 C0                   ret     NZ              ; Different
4442+ 3926 2B                   dec     HL              ; Point to LSB
4443+ 3927 7B                   ld      A,E             ; Get LSB
4444+ 3928 96                   sub     (HL)            ; Compare LSBs
4445+ 3929 C0                   ret     NZ              ; Different
4446+ 392A E1                   pop     HL              ; Drop RETurn
4447+ 392B E1                   pop     HL              ; Drop another RETurn
4448+ 392C C9                   ret
4449+ 392D
4450+ 392D 47           FPINT:  ld      B,A             ; <- Move
4451+ 392E 4F                   ld      C,A             ; <- exponent
4452+ 392F 57                   ld      D,A             ; <- to all
4453+ 3930 5F                   ld      E,A             ; <- bits
4454+ 3931 B7                   or      A               ; Test exponent
4455+ 3932 C8                   ret     Z               ; Zero - Return zero
4456+ 3933 E5                   push    HL              ; Save pointer to number
4457+ 3934 CD D1 38             call    BCDEFP          ; Move FPREG to BCDE
4458+ 3937 CD EB 38             call    SIGNS           ; Set MSBs & sign of result
4459+ 393A AE                   xor     (HL)            ; Combine with sign of FPREG
4460+ 393B 67                   ld      H,A             ; Save combined signs
4461+ 393C FC 51 39             call    M,DCBCDE        ; Negative - Decrement BCDE
4462+ 393F 3E 98                ld      A,$80+24        ; 24 bits
4463+ 3941 90                   sub     B               ; Bits to shift
4464+ 3942 CD B3 36             call    SCALE           ; Shift BCDE
4465+ 3945 7C                   ld      A,H             ; Get combined sign
4466+ 3946 17                   rla                     ; Sign to carry
4467+ 3947 DC 86 36             call    C,FPROND        ; Negative - Round number up
4468+ 394A 06 00                ld      B,$00           ; Zero exponent
4469+ 394C DC 9F 36             call    C,COMPL         ; If negative make positive
4470+ 394F E1                   pop     HL              ; Restore pointer to number
4471+ 3950 C9                   ret
4472+ 3951
4473+ 3951 1B           DCBCDE: dec     DE              ; Decrement BCDE
4474+ 3952 7A                   ld      A,D             ; Test LSBs
4475+ 3953 A3                   and     E
4476+ 3954 3C                   inc     A
4477+ 3955 C0                   ret     NZ              ; Exit if LSBs not FFFF
4478+ 3956 0B                   dec     BC              ; Decrement MSBs
4479+ 3957 C9                   ret
4480+ 3958
4481+ 3958 21 D2 61     INT:    ld      HL,FPEXP        ; Point to exponent
4482+ 395B 7E                   ld      A,(HL)          ; Get exponent
4483+ 395C FE 98                cp      $80+24          ; Integer accuracy only?
4484+ 395E 3A CF 61             ld      A,(FPREG)       ; Get LSB
4485+ 3961 D0                   ret     NC              ; Yes - Already integer
4486+ 3962 7E                   ld      A,(HL)          ; Get exponent
4487+ 3963 CD 2D 39             call    FPINT           ; F.P to integer
4488+ 3966 36 98                ld      (HL),$80+24     ; Save 24 bit integer
4489+ 3968 7B                   ld      A,E             ; Get LSB of number
4490+ 3969 F5                   push    AF              ; Save LSB
4491+ 396A 79                   ld      A,C             ; Get MSB of number
4492+ 396B 17                   rla                     ; Sign to carry
4493+ 396C CD 3C 36             call    CONPOS          ; Set sign of result
4494+ 396F F1                   pop     AF              ; Restore LSB of number
4495+ 3970 C9                   ret
4496+ 3971
4497+ 3971 21 00 00     MLDEBC: ld      HL,$0000        ; Clear partial product
4498+ 3974 78                   ld      A,B             ; Test multiplier
4499+ 3975 B1                   or      C
4500+ 3976 C8                   ret     Z               ; Return zero if zero
4501+ 3977 3E 10                ld      A,$10           ; 16 bits
4502+ 3979 29           MLDBLP: add     HL,HL           ; Shift P.P left
4503+ 397A DA 9F 2D             jp      C,BSERR         ; ?BS Error if overflow
4504+ 397D EB                   ex      DE,HL
4505+ 397E 29                   add     HL,HL           ; Shift multiplier left
4506+ 397F EB                   ex      DE,HL
4507+ 3980 D2 87 39             jp      NC,NOMLAD       ; Bit was zero - No add
4508+ 3983 09                   add     HL,BC           ; Add multiplicand
4509+ 3984 DA 9F 2D             jp      C,BSERR         ; ?BS Error if overflow
4510+ 3987 3D           NOMLAD: dec     A               ; Count bits
4511+ 3988 C2 79 39             jp      NZ,MLDBLP       ; More
4512+ 398B C9                   ret
4513+ 398C
4514+ 398C FE 2D        ASCTFP: cp      '-'             ; Negative?
4515+ 398E F5                   push    AF              ; Save it and flags
4516+ 398F CA 98 39             jp      Z,CNVNUM        ; Yes - Convert number
4517+ 3992 FE 2B                cp      '+'             ; Positive?
4518+ 3994 CA 98 39             jp      Z,CNVNUM        ; Yes - Convert number
4519+ 3997 2B                   dec     HL              ; dec 'cos GETCHR INCs
4520+ 3998 CD 54 36     CNVNUM: call    RESZER          ; Set result to zero
4521+ 399B 47                   ld      B,A             ; Digits after point counter
4522+ 399C 57                   ld      D,A             ; Sign of exponent
4523+ 399D 5F                   ld      E,A             ; Exponent of ten
4524+ 399E 2F                   cpl
4525+ 399F 4F                   ld      C,A             ; Before or after point flag
4526+ 39A0 CD E7 25     MANLP:  call    GETCHR          ; Get next character
4527+ 39A3 DA E9 39             jp      C,ADDIG         ; Digit - Add to number
4528+ 39A6 FE 2E                cp      '.'
4529+ 39A8 CA C4 39             jp      Z,DPOINT        ; '.' - Flag point
4530+ 39AB FE 45                cp      'E'
4531+ 39AD C2 C8 39             jp      NZ,CONEXP       ; Not 'E' - Scale number
4532+ 39B0 CD E7 25             call    GETCHR          ; Get next character
4533+ 39B3 CD BB 2B             call    SGNEXP          ; Get sign of exponent
4534+ 39B6 CD E7 25     EXPLP:  call    GETCHR          ; Get next character
4535+ 39B9 DA 0B 3A             jp      C,EDIGIT        ; Digit - Add to exponent
4536+ 39BC 14                   inc     D               ; Is sign negative?
4537+ 39BD C2 C8 39             jp      NZ,CONEXP       ; No - Scale number
4538+ 39C0 AF                   xor     A
4539+ 39C1 93                   sub     E               ; Negate exponent
4540+ 39C2 5F                   ld      E,A             ; And re-save it
4541+ 39C3 0C                   inc     C               ; Flag end of number
4542+ 39C4 0C           DPOINT: inc     C               ; Flag point passed
4543+ 39C5 CA A0 39             jp      Z,MANLP         ; Zero - Get another digit
4544+ 39C8 E5           CONEXP: push    HL              ; Save code string address
4545+ 39C9 7B                   ld      A,E             ; Get exponent
4546+ 39CA 90                   sub     B               ; Subtract digits after point
4547+ 39CB F4 E1 39     SCALMI: call    P,SCALPL        ; Positive - Multiply number
4548+ 39CE F2 D7 39             jp      P,ENDCON        ; Positive - All done
4549+ 39D1 F5                   push    AF              ; Save number of times to /10
4550+ 39D2 CD CD 37             call    DIV10           ; Divide by 10
4551+ 39D5 F1                   pop     AF              ; Restore count
4552+ 39D6 3C                   inc     A               ; Count divides
4553+ 39D7
4554+ 39D7 C2 CB 39     ENDCON: jp      NZ,SCALMI       ; More to do
4555+ 39DA D1                   pop     DE              ; Restore code string address
4556+ 39DB F1                   pop     AF              ; Restore sign of number
4557+ 39DC CC AE 38             call    Z,INVSGN        ; Negative - Negate number
4558+ 39DF EB                   ex      DE,HL           ; Code string address to HL
4559+ 39E0 C9                   ret
4560+ 39E1
4561+ 39E1 C8           SCALPL: ret     Z               ; Exit if no scaling needed
4562+ 39E2 F5           MULTEN: push    AF              ; Save count
4563+ 39E3 CD 6E 38             call    MLSP10          ; Multiply number by 10
4564+ 39E6 F1                   pop     AF              ; Restore count
4565+ 39E7 3D                   dec     A               ; Count multiplies
4566+ 39E8 C9                   ret
4567+ 39E9
4568+ 39E9 D5           ADDIG:  push    DE              ; Save sign of exponent
4569+ 39EA 57                   ld      D,A             ; Save digit
4570+ 39EB 78                   ld      A,B             ; Get digits after point
4571+ 39EC 89                   adc     A,C             ; Add one if after point
4572+ 39ED 47                   ld      B,A             ; Re-save counter
4573+ 39EE C5                   push    BC              ; Save point flags
4574+ 39EF E5                   push    HL              ; Save code string address
4575+ 39F0 D5                   push    DE              ; Save digit
4576+ 39F1 CD 6E 38             call    MLSP10          ; Multiply number by 10
4577+ 39F4 F1                   pop     AF              ; Restore digit
4578+ 39F5 D6 30                sub     '0'             ; Make it absolute
4579+ 39F7 CD 00 3A             call    RSCALE          ; Re-scale number
4580+ 39FA E1                   pop     HL              ; Restore code string address
4581+ 39FB C1                   pop     BC              ; Restore point flags
4582+ 39FC D1                   pop     DE              ; Restore sign of exponent
4583+ 39FD C3 A0 39             jp      MANLP           ; Get another digit
4584+ 3A00
4585+ 3A00 CD B6 38     RSCALE: call    STAKFP          ; Put number on stack
4586+ 3A03 CD 97 38             call    FLGREL          ; Digit to add to FPREG
4587+ 3A06 C1           PADD:   pop     BC              ; Restore number
4588+ 3A07 D1                   pop     DE
4589+ 3A08 C3 EE 35             jp      FPADD           ; Add BCDE to FPREG and return
4590+ 3A0B
4591+ 3A0B 7B           EDIGIT: ld      A,E             ; Get digit
4592+ 3A0C 07                   rlca                    ; Times 2
4593+ 3A0D 07                   rlca                    ; Times 4
4594+ 3A0E 83                   add     A,E             ; Times 5
4595+ 3A0F 07                   rlca                    ; Times 10
4596+ 3A10 86                   add     A,(HL)          ; Add next digit
4597+ 3A11 D6 30                sub     '0'             ; Make it absolute
4598+ 3A13 5F                   ld      E,A             ; Save new digit
4599+ 3A14 C3 B6 39             jp      EXPLP           ; Look for another digit
4600+ 3A17
4601+ 3A17 E5           LINEIN: push    HL              ; Save code string address
4602+ 3A18 21 17 20             ld      HL,INMSG        ; Output " in "
4603+ 3A1B CD 80 2F             call    PRS             ; Output string at HL
4604+ 3A1E E1                   pop     HL              ; Restore code string address
4605+ 3A1F EB           PRNTHL: ex      DE,HL           ; Code string address to DE
4606+ 3A20 AF                   xor     A
4607+ 3A21 06 98                ld      B,$80+24        ; 24 bits
4608+ 3A23 CD 9C 38             call    RETINT          ; Return the integer
4609+ 3A26 21 7F 2F             ld      HL,PRNUMS       ; Print number string
4610+ 3A29 E5                   push    HL              ; Save for return
4611+ 3A2A              ; conmvert FP number into ASCII chars
4612+ 3A2A 21 D4 61     NUMASC: ld      HL,PBUFF        ; Convert number to ASCII
4613+ 3A2D E5                   push    HL              ; Save for return
4614+ 3A2E CD 85 38             call    TSTSGN          ; Test sign of FPREG
4615+ 3A31 36 20                ld      (HL),SPC        ; Space at start
4616+ 3A33 F2 38 3A             jp      P,SPCFST        ; Positive - Space to start
4617+ 3A36 36 2D                ld      (HL),'-'        ; '-' sign at start
4618+ 3A38 23           SPCFST: inc     HL              ; First byte of number
4619+ 3A39 36 30                ld      (HL),'0'        ; '0' if zero
4620+ 3A3B CA EE 3A             jp      Z,JSTZER        ; Return '0' if zero
4621+ 3A3E E5                   push    HL              ; Save buffer address
4622+ 3A3F FC AE 38             call    M,INVSGN        ; Negate FPREG if negative
4623+ 3A42 AF                   xor     A               ; Zero A
4624+ 3A43 F5                   push    AF              ; Save it
4625+ 3A44 CD F4 3A             call    RNGTST          ; Test number is in range
4626+ 3A47 01 43 91     SIXDIG: ld      BC,$9143        ; BCDE - 99999.9
4627+ 3A4A 11 F8 4F             ld      DE,$4FF8
4628+ 3A4D CD 00 39             call    CMPNUM          ; Compare numbers
4629+ 3A50 B7                   or      A
4630+ 3A51 E2 65 3A             jp      PO,INRNG        ; > 99999.9 - Sort it out
4631+ 3A54 F1                   pop     AF              ; Restore count
4632+ 3A55 CD E2 39             call    MULTEN          ; Multiply by ten
4633+ 3A58 F5                   push    AF              ; Re-save count
4634+ 3A59 C3 47 3A             jp      SIXDIG          ; Test it again
4635+ 3A5C
4636+ 3A5C CD CD 37     GTSIXD: call    DIV10           ; Divide by 10
4637+ 3A5F F1                   pop     AF              ; Get count
4638+ 3A60 3C                   inc     A               ; Count divides
4639+ 3A61 F5                   push    AF              ; Re-save count
4640+ 3A62 CD F4 3A             call    RNGTST          ; Test number is in range
4641+ 3A65 CD DC 35     INRNG:  call    ROUND           ; Add 0.5 to FPREG
4642+ 3A68 3C                   inc     A
4643+ 3A69 CD 2D 39             call    FPINT           ; F.P to integer
4644+ 3A6C CD C6 38             call    FPBCDE          ; Move BCDE to FPREG
4645+ 3A6F 01 06 03             ld      BC,$0306        ; 1E+06 to 1E-03 range
4646+ 3A72 F1                   pop     AF              ; Restore count
4647+ 3A73 81                   add     A,C             ; 6 digits before point
4648+ 3A74 3C                   inc     A               ; Add one
4649+ 3A75 FA 81 3A             jp      M,MAKNUM        ; Do it in 'E' form if < 1E-02
4650+ 3A78 FE 08                cp      6+1+1           ; More than 999999 ?
4651+ 3A7A D2 81 3A             jp      NC,MAKNUM       ; Yes - Do it in 'E' form
4652+ 3A7D 3C                   inc     A               ; Adjust for exponent
4653+ 3A7E 47                   ld      B,A             ; Exponent of number
4654+ 3A7F 3E 02                ld      A,2             ; Make it zero after
4655+ 3A81
4656+ 3A81 3D           MAKNUM: dec     A               ; Adjust for digits to do
4657+ 3A82 3D                   dec     A
4658+ 3A83 E1                   pop     HL              ; Restore buffer address
4659+ 3A84 F5                   push    AF              ; Save count
4660+ 3A85 11 07 3B             ld      DE,POWERS       ; Powers of ten
4661+ 3A88 05                   dec     B               ; Count digits before point
4662+ 3A89 C2 92 3A             jp      NZ,DIGTXT       ; Not zero - Do number
4663+ 3A8C 36 2E                ld      (HL),'.'        ; Save point
4664+ 3A8E 23                   inc     HL              ; Move on
4665+ 3A8F 36 30                ld      (HL),'0'        ; Save zero
4666+ 3A91 23                   inc     HL              ; Move on
4667+ 3A92 05           DIGTXT: dec     B               ; Count digits before point
4668+ 3A93 36 2E                ld      (HL),'.'        ; Save point in case
4669+ 3A95 CC DB 38             call    Z,INCHL         ; Last digit - move on
4670+ 3A98 C5                   push    BC              ; Save digits before point
4671+ 3A99 E5                   push    HL              ; Save buffer address
4672+ 3A9A D5                   push    DE              ; Save powers of ten
4673+ 3A9B CD D1 38             call    BCDEFP          ; Move FPREG to BCDE
4674+ 3A9E E1                   pop     HL              ; Powers of ten table
4675+ 3A9F 06 2F                ld      B,'0'-1         ; ASCII '0' - 1
4676+ 3AA1 04           TRYAGN: inc     B               ; Count subtractions
4677+ 3AA2 7B                   ld      A,E             ; Get LSB
4678+ 3AA3 96                   sub     (HL)            ; Subtract LSB
4679+ 3AA4 5F                   ld      E,A             ; Save LSB
4680+ 3AA5 23                   inc     HL
4681+ 3AA6 7A                   ld      A,D             ; Get NMSB
4682+ 3AA7 9E                   sbc     A,(HL)          ; Subtract NMSB
4683+ 3AA8 57                   ld      D,A             ; Save NMSB
4684+ 3AA9 23                   inc     HL
4685+ 3AAA 79                   ld      A,C             ; Get MSB
4686+ 3AAB 9E                   sbc     A,(HL)          ; Subtract MSB
4687+ 3AAC 4F                   ld      C,A             ; Save MSB
4688+ 3AAD 2B                   dec     HL              ; Point back to start
4689+ 3AAE 2B                   dec     HL
4690+ 3AAF D2 A1 3A             jp      NC,TRYAGN       ; No overflow - Try again
4691+ 3AB2 CD 93 36             call    PLUCDE          ; Restore number
4692+ 3AB5 23                   inc     HL              ; Start of next number
4693+ 3AB6 CD C6 38             call    FPBCDE          ; Move BCDE to FPREG
4694+ 3AB9 EB                   ex      DE,HL           ; Save point in table
4695+ 3ABA E1                   pop     HL              ; Restore buffer address
4696+ 3ABB 70                   ld      (HL),B          ; Save digit in buffer
4697+ 3ABC 23                   inc     HL              ; And move on
4698+ 3ABD C1                   pop     BC              ; Restore digit count
4699+ 3ABE 0D                   dec     C               ; Count digits
4700+ 3ABF C2 92 3A             jp      NZ,DIGTXT       ; More - Do them
4701+ 3AC2 05                   dec     B               ; Any decimal part?
4702+ 3AC3 CA D2 3A             jp      Z,DOEBIT        ; No - Do 'E' bit
4703+ 3AC6 2B           SUPTLZ: dec     HL              ; Move back through buffer
4704+ 3AC7 7E                   ld      A,(HL)          ; Get character
4705+ 3AC8 FE 30                cp      '0'             ; '0' character?
4706+ 3ACA CA C6 3A             jp      Z,SUPTLZ        ; Yes - Look back for more
4707+ 3ACD FE 2E                cp      '.'             ; A decimal point?
4708+ 3ACF C4 DB 38             call    NZ,INCHL        ; Move back over digit
4709+ 3AD2
4710+ 3AD2 F1           DOEBIT: pop     AF              ; Get 'E' flag
4711+ 3AD3 CA F1 3A             jp      Z,NOENED        ; No 'E' needed - End buffer
4712+ 3AD6 36 45                ld      (HL),'E'        ; Put 'E' in buffer
4713+ 3AD8 23                   inc     HL              ; And move on
4714+ 3AD9 36 2B                ld      (HL),'+'        ; Put '+' in buffer
4715+ 3ADB F2 E2 3A             jp      P,OUTEXP        ; Positive - Output exponent
4716+ 3ADE 36 2D                ld      (HL),'-'        ; Put '-' in buffer
4717+ 3AE0 2F                   cpl                     ; Negate exponent
4718+ 3AE1 3C                   inc     A
4719+ 3AE2 06 2F        OUTEXP: ld      B,'0'-1         ; ASCII '0' - 1
4720+ 3AE4 04           EXPTEN: inc     B               ; Count subtractions
4721+ 3AE5 D6 0A                sub     $0A             ; Tens digit
4722+ 3AE7 D2 E4 3A             jp      NC,EXPTEN       ; More to do
4723+ 3AEA C6 3A                add     A,'0'+10        ; Restore and make ASCII
4724+ 3AEC 23                   inc     HL              ; Move on
4725+ 3AED 70                   ld      (HL),B          ; Save MSB of exponent
4726+ 3AEE 23           JSTZER: inc     HL              ;
4727+ 3AEF 77                   ld      (HL),A          ; Save LSB of exponent
4728+ 3AF0 23                   inc     HL
4729+ 3AF1 71           NOENED: ld      (HL),C          ; Mark end of buffer
4730+ 3AF2 E1                   pop     HL              ; Restore code string address
4731+ 3AF3 C9                   ret
4732+ 3AF4
4733+ 3AF4 01 74 94     RNGTST: ld      BC,$9474        ; BCDE = 999999.
4734+ 3AF7 11 F7 23             ld      DE,$23F7
4735+ 3AFA CD 00 39             call    CMPNUM          ; Compare numbers
4736+ 3AFD B7                   or      A
4737+ 3AFE E1                   pop     HL              ; Return address to HL
4738+ 3AFF E2 5C 3A             jp      PO,GTSIXD       ; Too big - Divide by ten
4739+ 3B02 E9                   jp      (HL)            ; Otherwise return to caller
4740+ 3B03
4741+ 3B03 00 00 00 80  HALF:   defb    $00,$00,$00,$80 ; 0.5
4742+ 3B07
4743+ 3B07 A0 86 01     POWERS: defb    $A0,$86,$01  ; 100000
4744+ 3B0A 10 27 00             defb    $10,$27,$00  ;  10000
4745+ 3B0D E8 03 00             defb    $E8,$03,$00  ;   1000
4746+ 3B10 64 00 00             defb    $64,$00,$00  ;    100
4747+ 3B13 0A 00 00             defb    $0A,$00,$00  ;     10
4748+ 3B16 01 00 00             defb    $01,$00,$00  ;      1
4749+ 3B19
4750+ 3B19 21 AE 38     NEGAFT: ld      HL,INVSGN       ; Negate result
4751+ 3B1C E3                   ex      (SP),HL         ; To be done after caller
4752+ 3B1D E9                   jp      (HL)            ; Return to caller
4753+ 3B1E
4754+ 3B1E CD B6 38     SQR:    call    STAKFP          ; Put value on stack
4755+ 3B21 21 03 3B             ld      HL,HALF         ; Set power to 1/2
4756+ 3B24 CD C3 38             call    PHLTFP          ; Move 1/2 to FPREG
4757+ 3B27
4758+ 3B27 C1           POWER:  pop     BC              ; Get base
4759+ 3B28 D1                   pop     DE
4760+ 3B29 CD 85 38             call    TSTSGN          ; Test sign of power
4761+ 3B2C 78                   ld      A,B             ; Get exponent of base
4762+ 3B2D CA 6C 3B             jp      Z,EXP           ; Make result 1 if zero
4763+ 3B30 F2 37 3B             jp      P,POWER1        ; Positive base - Ok
4764+ 3B33 B7                   or      A               ; Zero to negative power?
4765+ 3B34 CA A1 20             jp      Z,DZERR         ; Yes - ?/0 Error
4766+ 3B37 B7           POWER1: or      A               ; Base zero?
4767+ 3B38 CA 55 36             jp      Z,SAVEXP        ; Yes - Return zero
4768+ 3B3B D5                   push    DE              ; Save base
4769+ 3B3C C5                   push    BC
4770+ 3B3D 79                   ld      A,C             ; Get MSB of base
4771+ 3B3E F6 7F                or      %01111111       ; Get sign status
4772+ 3B40 CD D1 38             call    BCDEFP          ; Move power to BCDE
4773+ 3B43 F2 54 3B             jp      P,POWER2        ; Positive base - Ok
4774+ 3B46 D5                   push    DE              ; Save power
4775+ 3B47 C5                   push    BC
4776+ 3B48 CD 58 39             call    INT             ; Get integer of power
4777+ 3B4B C1                   pop     BC              ; Restore power
4778+ 3B4C D1                   pop     DE
4779+ 3B4D F5                   push    AF              ; MSB of base
4780+ 3B4E CD 00 39             call    CMPNUM          ; Power an integer?
4781+ 3B51 E1                   pop     HL              ; Restore MSB of base
4782+ 3B52 7C                   ld      A,H             ; but don't affect flags
4783+ 3B53 1F                   rra                     ; Exponent odd or even?
4784+ 3B54 E1           POWER2: pop     HL              ; Restore MSB and exponent
4785+ 3B55 22 D1 61             ld      (FPREG+2),HL    ; Save base in FPREG
4786+ 3B58 E1                   pop     HL              ; LSBs of base
4787+ 3B59 22 CF 61             ld      (FPREG),HL      ; Save in FPREG
4788+ 3B5C DC 19 3B             call    C,NEGAFT        ; Odd power - Negate result
4789+ 3B5F CC AE 38             call    Z,INVSGN        ; Negative base - Negate it
4790+ 3B62 D5                   push    DE              ; Save power
4791+ 3B63 C5                   push    BC
4792+ 3B64 CD E8 36             call    LOG             ; Get LOG of base
4793+ 3B67 C1                   pop     BC              ; Restore power
4794+ 3B68 D1                   pop     DE
4795+ 3B69 CD 29 37             call    FPMULT          ; Multiply LOG by power
4796+ 3B6C
4797+ 3B6C CD B6 38     EXP:    call    STAKFP          ; Put value on stack
4798+ 3B6F 01 38 81             ld      BC,$8138        ; BCDE = 1/Ln(2)
4799+ 3B72 11 3B AA             ld      DE,$AA3B
4800+ 3B75 CD 29 37             call    FPMULT          ; Multiply value by 1/LN(2)
4801+ 3B78 3A D2 61             ld      A,(FPEXP)       ; Get exponent
4802+ 3B7B FE 88                cp      $80+8           ; Is it in range?
4803+ 3B7D D2 61 38             jp      NC,OVTST1       ; No - Test for overflow
4804+ 3B80 CD 58 39             call    INT             ; Get INT of FPREG
4805+ 3B83 C6 80                add     A,$80           ; For excess 128
4806+ 3B85 C6 02                add     A,$02           ; Exponent > 126?
4807+ 3B87 DA 61 38             jp      C,OVTST1        ; Yes - Test for overflow
4808+ 3B8A F5                   push    AF              ; Save scaling factor
4809+ 3B8B 21 D7 36             ld      HL,UNITY        ; Point to 1.
4810+ 3B8E CD DF 35             call    ADDPHL          ; Add 1 to FPREG
4811+ 3B91 CD 20 37             call    MULLN2          ; Multiply by LN(2)
4812+ 3B94 F1                   pop     AF              ; Restore scaling factor
4813+ 3B95 C1                   pop     BC              ; Restore exponent
4814+ 3B96 D1                   pop     DE
4815+ 3B97 F5                   push    AF              ; Save scaling factor
4816+ 3B98 CD EB 35             call    SUBCDE          ; Subtract exponent from FPREG
4817+ 3B9B CD AE 38             call    INVSGN          ; Negate result
4818+ 3B9E 21 AC 3B             ld      HL,EXPTAB       ; Coefficient table
4819+ 3BA1 CD DC 3B             call    SMSER1          ; Sum the series
4820+ 3BA4 11 00 00             ld      DE,$0000        ; Zero LSBs
4821+ 3BA7 C1                   pop     BC              ; Scaling factor
4822+ 3BA8 4A                   ld      C,D             ; Zero MSB
4823+ 3BA9 C3 29 37             jp      FPMULT          ; Scale result to correct value
4824+ 3BAC
4825+ 3BAC 08           EXPTAB: defb    $08             ; Table used by EXP
4826+ 3BAD 40 2E 94 74          defb    $40,$2E,$94,$74 ; -1/7! (-1/5040)
4827+ 3BB1 70 4F 2E 77          defb    $70,$4F,$2E,$77 ;  1/6! ( 1/720)
4828+ 3BB5 6E 02 88 7A          defb    $6E,$02,$88,$7A ; -1/5! (-1/120)
4829+ 3BB9 E6 A0 2A 7C          defb    $E6,$A0,$2A,$7C ;  1/4! ( 1/24)
4830+ 3BBD 50 AA AA 7E          defb    $50,$AA,$AA,$7E ; -1/3! (-1/6)
4831+ 3BC1 FF FF 7F 7F          defb    $FF,$FF,$7F,$7F ;  1/2! ( 1/2)
4832+ 3BC5 00 00 80 81          defb    $00,$00,$80,$81 ; -1/1! (-1/1)
4833+ 3BC9 00 00 00 81          defb    $00,$00,$00,$81 ;  1/0! ( 1/1)
4834+ 3BCD
4835+ 3BCD CD B6 38     SUMSER: call    STAKFP          ; Put FPREG on stack
4836+ 3BD0 11 27 37             ld      DE,MULT         ; Multiply by "X"
4837+ 3BD3 D5                   push    DE              ; To be done after
4838+ 3BD4 E5                   push    HL              ; Save address of table
4839+ 3BD5 CD D1 38             call    BCDEFP          ; Move FPREG to BCDE
4840+ 3BD8 CD 29 37             call    FPMULT          ; Square the value
4841+ 3BDB E1                   pop     HL              ; Restore address of table
4842+ 3BDC CD B6 38     SMSER1: call    STAKFP          ; Put value on stack
4843+ 3BDF 7E                   ld      A,(HL)          ; Get number of coefficients
4844+ 3BE0 23                   inc     HL              ; Point to start of table
4845+ 3BE1 CD C3 38             call    PHLTFP          ; Move coefficient to FPREG
4846+ 3BE4 06                   defb    06H             ; Skip "pop AF"
4847+ 3BE5 F1           SUMLP:  pop     AF              ; Restore count
4848+ 3BE6 C1                   pop     BC              ; Restore number
4849+ 3BE7 D1                   pop     DE
4850+ 3BE8 3D                   dec     A               ; Cont coefficients
4851+ 3BE9 C8                   ret     Z               ; All done
4852+ 3BEA D5                   push    DE              ; Save number
4853+ 3BEB C5                   push    BC
4854+ 3BEC F5                   push    AF              ; Save count
4855+ 3BED E5                   push    HL              ; Save address in table
4856+ 3BEE CD 29 37             call    FPMULT          ; Multiply FPREG by BCDE
4857+ 3BF1 E1                   pop     HL              ; Restore address in table
4858+ 3BF2 CD D4 38             call    LOADFP          ; Number at HL to BCDE
4859+ 3BF5 E5                   push    HL              ; Save address in table
4860+ 3BF6 CD EE 35             call    FPADD           ; Add coefficient to FPREG
4861+ 3BF9 E1                   pop     HL              ; Restore address in table
4862+ 3BFA C3 E5 3B             jp      SUMLP           ; More coefficients
4863+ 3BFD
4864+ 3BFD
4865+ 3BFD              ; random number generator
4866+ 3BFD              ; a negative argument is used as a seed for the RNG
4867+ 3BFD              ; 0 is used to repeat the last random number
4868+ 3BFD              ; a positive argument generates a new random number
4869+ 3BFD CD 85 38     RND:    call    TSTSGN          ; Test sign of FPREG
4870+ 3C00 21 EF 5F             ld      HL,SEED+2       ; Random number seed
4871+ 3C03 FA 5E 3C             jp      M,RESEED        ; Negative - Re-seed
4872+ 3C06 21 10 60             ld      HL,LSTRND       ; Last random number
4873+ 3C09 CD C3 38             call    PHLTFP          ; Move last RND to FPREG
4874+ 3C0C 21 EF 5F             ld      HL,SEED+2       ; Random number seed
4875+ 3C0F C8                   ret     Z               ; Return if RND(0)
4876+ 3C10 86                   add     A,(HL)          ; Add (SEED+2)
4877+ 3C11 E6 07                and     %00000111       ; 0 to 7
4878+ 3C13 06 00                ld      B,$00
4879+ 3C15 77                   ld      (HL),A          ; Re-save seed
4880+ 3C16 23                   inc     HL              ; Move to coefficient table
4881+ 3C17 87                   add     A,A             ; 4 bytes
4882+ 3C18 87                   add     A,A             ; per entry
4883+ 3C19 4F                   ld      C,A             ; BC = Offset into table
4884+ 3C1A 09                   add     HL,BC           ; Point to coefficient
4885+ 3C1B CD D4 38             call    LOADFP          ; Coefficient to BCDE
4886+ 3C1E CD 29 37             call    FPMULT          ; Multiply FPREG by coefficient
4887+ 3C21 3A EE 5F             ld      A,(SEED+1)      ; Get (SEED+1)
4888+ 3C24 3C                   inc     A               ; Add 1
4889+ 3C25 E6 03                and     %00000011       ; 0 to 3
4890+ 3C27 06 00                ld      B,$00
4891+ 3C29 FE 01                cp      $01             ; Is it zero?
4892+ 3C2B 88                   adc     A,B             ; Yes - Make it 1
4893+ 3C2C 32 EE 5F             ld      (SEED+1),A      ; Re-save seed
4894+ 3C2F 21 62 3C             ld      HL,RNDTAB-4     ; Addition table
4895+ 3C32 87                   add     A,A             ; 4 bytes
4896+ 3C33 87                   add     A,A             ; per entry
4897+ 3C34 4F                   ld      C,A             ; BC = Offset into table
4898+ 3C35 09                   add     HL,BC           ; Point to value
4899+ 3C36 CD DF 35             call    ADDPHL          ; Add value to FPREG
4900+ 3C39 CD D1 38     RND1:   call    BCDEFP          ; Move FPREG to BCDE
4901+ 3C3C 7B                   ld      A,E             ; Get LSB
4902+ 3C3D 59                   ld      E,C             ; LSB = MSB
4903+ 3C3E EE 4F                xor     %01001111       ; Fiddle around
4904+ 3C40 4F                   ld      C,A             ; New MSB
4905+ 3C41 36 80                ld      (HL),$80        ; Set exponent
4906+ 3C43 2B                   dec     HL              ; Point to MSB
4907+ 3C44 46                   ld      B,(HL)          ; Get MSB
4908+ 3C45 36 80                ld      (HL),$80        ; Make value -0.5
4909+ 3C47 21 ED 5F             ld      HL,SEED         ; Random number seed
4910+ 3C4A 34                   inc     (HL)            ; Count seed
4911+ 3C4B 7E                   ld      A,(HL)          ; Get seed
4912+ 3C4C D6 AB                sub     $AB             ; Do it modulo 171
4913+ 3C4E C2 55 3C             jp      NZ,RND2         ; Non-zero - Ok
4914+ 3C51 77                   ld      (HL),A          ; Zero seed
4915+ 3C52 0C                   inc     C               ; Fillde about
4916+ 3C53 15                   dec     D               ; with the
4917+ 3C54 1C                   inc     E               ; number
4918+ 3C55 CD 3F 36     RND2:   call    BNORM           ; Normalise number
4919+ 3C58 21 10 60             ld      HL,LSTRND       ; Save random number
4920+ 3C5B C3 DD 38             jp      FPTHL           ; Move FPREG to last and return
4921+ 3C5E
4922+ 3C5E 77           RESEED: ld      (HL),A          ; Re-seed random numbers
4923+ 3C5F 2B                   dec     HL
4924+ 3C60 77                   ld      (HL),A
4925+ 3C61 2B                   dec     HL
4926+ 3C62 77                   ld      (HL),A
4927+ 3C63 C3 39 3C             jp      RND1            ; Return RND seed
4928+ 3C66
4929+ 3C66 68 B1 46 68  RNDTAB: defb    $68,$B1,$46,$68 ; Table used by RND
4930+ 3C6A 99 E9 92 69          defb    $99,$E9,$92,$69
4931+ 3C6E 10 D1 75 68          defb    $10,$D1,$75,$68
4932+ 3C72
4933+ 3C72              ; COS and SIN functions
4934+ 3C72 21 BC 3C     COS:    ld      HL,HALFPI       ; Point to PI/2
4935+ 3C75 CD DF 35             call    ADDPHL          ; Add it to PPREG
4936+ 3C78 CD B6 38     SIN:    call    STAKFP          ; Put angle on stack
4937+ 3C7B 01 49 83             ld      BC,$8349        ; BCDE = 2 PI
4938+ 3C7E 11 DB 0F             ld      DE,$0FDB
4939+ 3C81 CD C6 38             call    FPBCDE          ; Move 2 PI to FPREG
4940+ 3C84 C1                   pop     BC              ; Restore angle
4941+ 3C85 D1                   pop     DE
4942+ 3C86 CD DB 37             call    DVBCDE          ; Divide angle by 2 PI
4943+ 3C89 CD B6 38             call    STAKFP          ; Put it on stack
4944+ 3C8C CD 58 39             call    INT             ; Get INT of result
4945+ 3C8F C1                   pop     BC              ; Restore number
4946+ 3C90 D1                   pop     DE
4947+ 3C91 CD EB 35             call    SUBCDE          ; Make it 0 <= value < 1
4948+ 3C94 21 C0 3C             ld      HL,QUARTR       ; Point to 0.25
4949+ 3C97 CD E5 35             call    SUBPHL          ; Subtract value from 0.25
4950+ 3C9A CD 85 38             call    TSTSGN          ; Test sign of value
4951+ 3C9D 37                   scf                     ; Flag positive
4952+ 3C9E F2 A8 3C             jp      P,SIN1          ; Positive - Ok
4953+ 3CA1 CD DC 35             call    ROUND           ; Add 0.5 to value
4954+ 3CA4 CD 85 38             call    TSTSGN          ; Test sign of value
4955+ 3CA7 B7                   or      A               ; Flag negative
4956+ 3CA8 F5           SIN1:   push    AF              ; Save sign
4957+ 3CA9 F4 AE 38             call    P,INVSGN        ; Negate value if positive
4958+ 3CAC 21 C0 3C             ld      HL,QUARTR       ; Point to 0.25
4959+ 3CAF CD DF 35             call    ADDPHL          ; Add 0.25 to value
4960+ 3CB2 F1                   pop     AF              ; Restore sign
4961+ 3CB3 D4 AE 38             call    NC,INVSGN       ; Negative - Make positive
4962+ 3CB6 21 C4 3C             ld      HL,SINTAB       ; Coefficient table
4963+ 3CB9 C3 CD 3B             jp      SUMSER          ; Evaluate sum of series
4964+ 3CBC
4965+ 3CBC DB 0F 49 81  HALFPI: defb    $DB,$0F,$49,$81 ; 1.5708 (PI/2)
4966+ 3CC0
4967+ 3CC0 00 00 00 7F  QUARTR: defb    $00,$00,$00,$7F ; 0.25
4968+ 3CC4
4969+ 3CC4 05           SINTAB: defb    $05             ; Table used by SIN
4970+ 3CC5 BA D7 1E 86          defb    $BA,$D7,$1E,$86 ; 39.711
4971+ 3CC9 64 26 99 87          defb    $64,$26,$99,$87 ;-76.575
4972+ 3CCD 58 34 23 87          defb    $58,$34,$23,$87 ; 81.602
4973+ 3CD1 E0 5D A5 86          defb    $E0,$5D,$A5,$86 ;-41.342
4974+ 3CD5 DA 0F 49 83          defb    $DA,$0F,$49,$83 ;  6.2832
4975+ 3CD9
4976+ 3CD9 CD B6 38     TAN:    call    STAKFP          ; Put angle on stack
4977+ 3CDC CD 78 3C             call    SIN             ; Get SIN of angle
4978+ 3CDF C1                   pop     BC              ; Restore angle
4979+ 3CE0 E1                   pop     HL
4980+ 3CE1 CD B6 38             call    STAKFP          ; Save SIN of angle
4981+ 3CE4 EB                   ex      DE,HL           ; BCDE = Angle
4982+ 3CE5 CD C6 38             call    FPBCDE          ; Angle to FPREG
4983+ 3CE8 CD 72 3C             call    COS             ; Get COS of angle
4984+ 3CEB C3 D9 37             jp      DIV             ; TAN = SIN / COS
4985+ 3CEE
4986+ 3CEE CD 85 38     ATN:    call    TSTSGN          ; Test sign of value
4987+ 3CF1 FC 19 3B             call    M,NEGAFT        ; Negate result after if -ve
4988+ 3CF4 FC AE 38             call    M,INVSGN        ; Negate value if -ve
4989+ 3CF7 3A D2 61             ld      A,(FPEXP)       ; Get exponent
4990+ 3CFA FE 81                cp      81H             ; Number less than 1?
4991+ 3CFC DA 0B 3D             jp      C,ATN1          ; Yes - Get arc tangnt
4992+ 3CFF 01 00 81             ld      BC,$8100        ; BCDE = 1
4993+ 3D02 51                   ld      D,C
4994+ 3D03 59                   ld      E,C
4995+ 3D04 CD DB 37             call    DVBCDE          ; Get reciprocal of number
4996+ 3D07 21 E5 35             ld      HL,SUBPHL       ; Sub angle from PI/2
4997+ 3D0A E5                   push    HL              ; Save for angle > 1
4998+ 3D0B 21 15 3D     ATN1:   ld      HL,ATNTAB       ; Coefficient table
4999+ 3D0E CD CD 3B             call    SUMSER          ; Evaluate sum of series
5000+ 3D11 21 BC 3C             ld      HL,HALFPI       ; PI/2 - angle in case > 1
5001+ 3D14 C9                   ret                     ; Number > 1 - Sub from PI/2
5002+ 3D15
5003+ 3D15 09           ATNTAB: defb    $09             ; Table used by ATN
5004+ 3D16 4A D7 3B 78          defb    $4A,$D7,$3B,$78 ; 1/17
5005+ 3D1A 02 6E 84 7B          defb    $02,$6E,$84,$7B ;-1/15
5006+ 3D1E FE C1 2F 7C          defb    $FE,$C1,$2F,$7C ; 1/13
5007+ 3D22 74 31 9A 7D          defb    $74,$31,$9A,$7D ;-1/11
5008+ 3D26 84 3D 5A 7D          defb    $84,$3D,$5A,$7D ; 1/9
5009+ 3D2A C8 7F 91 7E          defb    $C8,$7F,$91,$7E ;-1/7
5010+ 3D2E E4 BB 4C 7E          defb    $E4,$BB,$4C,$7E ; 1/5
5011+ 3D32 6C AA AA 7F          defb    $6C,$AA,$AA,$7F ;-1/3
5012+ 3D36 00 00 00 81          defb    $00,$00,$00,$81 ; 1/1
5013+ 3D3A
5014+ 3D3A
5015+ 3D3A C9           ARET:   ret                     ; A RETurn instruction
5016+ 3D3B
5017+ 3D3B D7           GETINP: rst     $10             ; input a character
5018+ 3D3C C9                   ret
5019+ 3D3D
5020+ 3D3D E5           CLS:    push    HL
5021+ 3D3E D5                   push    DE
5022+ 3D3F 3A 6D 61             ld      A,(SCR_MODE)    ; check screen mode
5023+ 3D42 FE 02                cp      $02             ; G2 mode?
5024+ 3D44 CC D8 05             call    Z,EMPTYVIDBUF   ; yes, reset video buffer
5025+ 3D47 D1                   pop     DE
5026+ 3D48 E1                   pop     HL
5027+ 3D49 3E 0C                ld      A,CS            ; ASCII Clear screen
5028+ 3D4B CD DC 23             call    SND2VID         ; send to screen
5029+ 3D4E C3 0D 4D             jp      MONOUT          ; Output character
5030+ 3D51
5031+ 3D51 CD FE 32     WIDTH:  call    GETINT          ; Get integer 0-255
5032+ 3D54 7B                   ld      A,E             ; Width to A
5033+ 3D55 32 17 60             ld      (LWIDTH),A      ; Set width
5034+ 3D58 C9                   ret
5035+ 3D59
5036+ 3D59
5037+ 3D59              ; read a word (2 bytes) from a couple of RAM locations, in little-endian format
5038+ 3D59              ; i.e., the first location is the LSB, while the second one is the MSB
5039+ 3D59 CD 9D 26     DEEK:   call    DEINT           ; Get integer -32768 to 32767
5040+ 3D5C D5                   push    DE              ; Save number
5041+ 3D5D E1                   pop     HL              ; Number to HL
5042+ 3D5E 46           RECWRD: ld      B,(HL)          ; Get LSB of contents
5043+ 3D5F 23                   inc     HL
5044+ 3D60 7E                   ld      A,(HL)          ; Get MSB of contents
5045+ 3D61 C3 62 2E             jp      ABPASS          ; Return integer AB
5046+ 3D64
5047+ 3D64              ; write a word (2 bytes) into a couple of RAM locations, in little-endian format
5048+ 3D64              ; i.e., the LSB will go into the first location, while the MSB into the second one
5049+ 3D64 CD 78 2A     DOKE:   call    GETNUM          ; Get a number
5050+ 3D67 CD 9D 26             call    DEINT           ; Get integer -32768 to 32767
5051+ 3D6A D5                   push    DE              ; Save address
5052+ 3D6B CD 9E 23             call    CHKSYN          ; Make sure ',' follows
5053+ 3D6E 2C                   defb    ','
5054+ 3D6F CD 78 2A             call    GETNUM          ; Get a number
5055+ 3D72 CD 9D 26             call    DEINT           ; Get integer -32768 to 32767
5056+ 3D75 E3                   ex      (SP),HL         ; Save value,get address
5057+ 3D76 73                   ld      (HL),E          ; Save LSB of value
5058+ 3D77 23                   inc     HL
5059+ 3D78 72                   ld      (HL),D          ; Save MSB of value
5060+ 3D79 E1                   pop     HL              ; Restore code string address
5061+ 3D7A C9                   ret
5062+ 3D7B
5063+ 3D7B              ; stop the execution of code for a certain bit of time. The pause
5064+ 3D7B              ; is between $0000 and $FFFF 100ths of a second (0~655.5 secs)
5065+ 3D7B CD 78 2A     PAUSE:  call    GETNUM          ; Get a number
5066+ 3D7E CD 9D 26             call    DEINT           ; Get integer -32768 to 32767
5067+ 3D81 7A                   ld      A,D             ; load D into A
5068+ 3D82 B3                   or      E               ; are D & E equal to $00?
5069+ 3D83 C8                   ret     Z               ; if yes, then return
5070+ 3D84 C5           DIR_PAU:push    BC              ; store BC
5071+ 3D85 3A 5B 61             ld      A,(TMRCNT)      ; Load current value of system timer
5072+ 3D88 47                   ld      B,A             ; move it into B
5073+ 3D89 CD 12 26     RPTPS:  call    TSTBRK          ; Test for break key
5074+ 3D8C 3A 5B 61             ld      A,(TMRCNT)      ; Load current value of system timer
5075+ 3D8F B8                   cp      B               ; is it the same value?
5076+ 3D90 28 F7                jr      Z,RPTPS         ; yes, so read again
5077+ 3D92 47                   ld      B,A             ; no, so store the new value
5078+ 3D93 1B                   dec     DE              ; decrement interval
5079+ 3D94 7A                   ld      A,D             ; load D into A
5080+ 3D95 B3                   or      E               ; check if DE is equal to 0 (if D & e are $00 then result is 0)
5081+ 3D96 20 F1                jr      NZ,RPTPS        ; no, repeat
5082+ 3D98 C1                   pop     BC              ; yes, recover BC and continue
5083+ 3D99 C9                   ret
5084+ 3D9A
5085+ 3D9A              ; change the screen mode and set some graphic features. Usage: SCREEN X[,Y][,Z]
5086+ 3D9A              ; where X is graphic mode:
5087+ 3D9A              ; 0=text mode (40x24), 1=graphic mode 1 (32x24 chars); 2=graphic mode 2 (256x192 pixels);
5088+ 3D9A              ; 3=multicolor mode (64x48 pixels); 4=extended graphic mode 2 (32x24 chars mixed between G1 and G2)
5089+ 3D9A              ; Y is: 0=8x8 sprites, 1=16x16 sprites
5090+ 3D9A              ; Z is: 0=no sprite magnification; 1=sprite magnification x2 (8x8=>16x16, and 16x16=32x32)
5091+ 3D9A              ; (the latters are accepted only in graphic modes G1, G2, G3, and G4)
5092+ 3D9A AF           SCREEN: xor     A
5093+ 3D9B 32 7D 61             ld      (TMPBFR2),A     ; sprite size & magnif. byte set to 0
5094+ 3D9E CD FE 32             call    GETINT          ; Get integer 0-255
5095+ 3DA1 FE 05                cp      $05             ; is it a valid mode (0~4)?
5096+ 3DA3 D2 B2 26             jp      NC,FCERR        ; No - Illegal function call Error
5097+ 3DA6 32 7B 61             ld      (TMPBFR1),A     ; store graphic mode
5098+ 3DA9 A7                   and     A               ; is it 0 (text mode)?
5099+ 3DAA CA C6 3D             jp      Z,SCVDP         ; yes, ignore other arguments and set mode immediately
5100+ 3DAD CD 05 3E     SETVDP: call    CHKSCAR         ; no, check if sprite size follows
5101+ 3DB0 DA B8 3D             jp      C,CKMAGN        ; no (set to 0 or missing), so jump over
5102+ 3DB3 3E 02                ld      A,$02           ; no, so set sprite size
5103+ 3DB5 32 7D 61             ld      (TMPBFR2),A     ; ...to 16x16
5104+ 3DB8 CD 05 3E     CKMAGN: call    CHKSCAR         ; check if sprite magnification follows
5105+ 3DBB DA C6 3D             jp      C,SCVDP         ; no (set to 0 or missing), so jump over
5106+ 3DBE 3A 7D 61             ld      A,(TMPBFR2)     ; yes, so retrieve sprite attributes...
5107+ 3DC1 F6 01                or      $01             ; ...set sprite magnification to 2x...
5108+ 3DC3 32 7D 61             ld      (TMPBFR2),A     ; ...and save flags again
5109+ 3DC6 F3           SCVDP:  di                      ; disable INTs
5110+ 3DC7 D5                   push    DE              ; store DE
5111+ 3DC8 E5                   push    HL              ; store HL
5112+ 3DC9 3A 7B 61             ld      A,(TMPBFR1)     ; recover graphic mode
5113+ 3DCC 5F                   ld      E,A             ; and store it into E
5114+ 3DCD 3A 7D 61             ld      A,(TMPBFR2)     ; recover sprite flags
5115+ 3DD0 57                   ld      D,A             ; and store them into D
5116+ 3DD1 D5                   push    DE              ; store D & E
5117+ 3DD2 CD D1 03             call    initVDP         ; initialize VDP with mode pointed by E
5118+ 3DD5 D1                   pop     DE              ; retrieve D & E
5119+ 3DD6 7B                   ld      A,E             ; move graphic mode into A
5120+ 3DD7 87                   add     A,A
5121+ 3DD8 87                   add     A,A
5122+ 3DD9 87                   add     A,A             ; multiply A times 8 to get offset of graphic mode
5123+ 3DDA 5F                   ld      E,A             ; and pass it into E
5124+ 3DDB D5                   push    DE              ; store sprite flags in E
5125+ 3DDC 16 00                ld      D,$00           ; reset D
5126+ 3DDE 21 20 0B             ld      HL,VDPMODESET+1 ; load address of VDP settings for reg#1
5127+ 3DE1 19                   add     HL,DE           ; load correct reg#1 setting
5128+ 3DE2 D1                   pop     DE              ; retrieve sprite flags from E
5129+ 3DE3 7E                   ld      A,(HL)          ; load reg#1 setting
5130+ 3DE4 E6 FC                and     %11111100       ; reset size & magn. bits
5131+ 3DE6 B2                   or      D               ; set size & magn. bits
5132+ 3DE7 5F                   ld      E,A             ; value into E
5133+ 3DE8 3E 01                ld      A,$01           ; reg #1
5134+ 3DEA CD B0 06             call    WRITE_VREG      ; send setting to reg #1
5135+ 3DED 2A 24 60             ld      HL,(LINEAT)     ; Get current line number
5136+ 3DF0 23                   inc     HL              ; -1 means direct statement
5137+ 3DF1 7C                   ld      A,H
5138+ 3DF2 B5                   or      L
5139+ 3DF3 CC 23 09             call    Z,CURSOR_ON     ; enable cursor if not in program mode
5140+ 3DF6 FB                   ei                      ; re-enable interrupts
5141+ 3DF7 E1                   pop     HL              ; restore HL
5142+ 3DF8 D1                   pop     DE              ; restore DE
5143+ 3DF9 3A 6C 61             ld      A,(SCR_SIZE_H)  ; check the screen mode by looking at the screen height
5144+ 3DFC FE 30                cp      $30             ; is it 48 chars or 192 pixels (MC and G2 modes)?
5145+ 3DFE D0                   ret     NC              ; yes, so exit (in graphics 2 and multicolor no print-on-video)
5146+ 3DFF 3E 01                ld      A,$01           ; no (we are in Text, G1 or ExG2), so activate the...
5147+ 3E01 32 77 61             ld      (PRNTVIDEO),A   ; ...video buffer...
5148+ 3E04 C9                   ret                     ; ...and return to caller
5149+ 3E05
5150+ 3E05              ; check an additional argument for SCREEN - There are 2 ways of working:
5151+ 3E05              ; to check if something follows: Carry is 1 is no argument follows, 0 otherwise
5152+ 3E05              ; to check the value of the following argument: 0 is argument is 1, 1 is argument is <> 1
5153+ 3E05 2B           CHKSCAR:dec     HL              ; dec 'cos GETCHR INCs
5154+ 3E06 CD E7 25             call    GETCHR          ; Get next character
5155+ 3E09 37                   scf                     ; set carry flag
5156+ 3E0A C8                   ret     Z               ; return if nothing follows with Carry=1
5157+ 3E0B CD 9E 23             call    CHKSYN          ; Make sure ',' follows
5158+ 3E0E 2C                   defb    ','
5159+ 3E0F CD FE 32             call    GETINT          ; get value
5160+ 3E12 1F                   rra                     ; Carry=bit #0
5161+ 3E13 3F                   ccf                     ; invert Carry, so Carry=0 if arg. is 1, and Carry=1 otherwise (arg<>1)
5162+ 3E14 C9                   ret                     ; return
5163+ 3E15
5164+ 3E15
5165+ 3E15              ; change the colors of the screen - Syntax is COLOR a,b,c where:
5166+ 3E15              ; a=foreground color / b=background color / c=border color
5167+ 3E15              ; a,b,c must be in a range between 1 and 15 (0 is transparent and it's not supported)
5168+ 3E15              ; the number of arguments is based on the current screen mode
5169+ 3E15 CD FE 32     COLOR:  call    GETINT          ; get first value
5170+ 3E18 CD BD 3E             call    CHKCLR1         ; check if it's in range 1~15
5171+ 3E1B 32 7B 61             ld      (TMPBFR1),A     ; store it
5172+ 3E1E 3A 6D 61             ld      A,(SCR_MODE)    ; check screen mode
5173+ 3E21 FE 03                cp      $03             ; is it multicolor mode?
5174+ 3E23 20 0D                jr      NZ,CNTCKCL      ; no, continue
5175+ 3E25 3E 0F                ld      A,$0F           ; white for...
5176+ 3E27 32 79 61             ld      (FRGNDCLR),A    ; ...foreground (even it's not used in MC)
5177+ 3E2A 3A 7B 61             ld      A,(TMPBFR1)     ; yes, so we stop here because in MC mode we just support border color
5178+ 3E2D 32 7F 61             ld      (TMPBFR3),A     ; move color into temp buffer 3
5179+ 3E30 18 31                jr      CLRMC           ; jump to set color
5180+ 3E32 CD 9E 23     CNTCKCL:call    CHKSYN          ; Make sure ',' follows
5181+ 3E35 2C                   defb    ','
5182+ 3E36 CD FE 32             call    GETINT          ; get second value
5183+ 3E39 CD BD 3E             call    CHKCLR1         ; check if it's in range 1~15
5184+ 3E3C 32 7D 61             ld      (TMPBFR2),A     ; store it
5185+ 3E3F 3A 6D 61             ld      A,(SCR_MODE)    ; check screen mode
5186+ 3E42 A7                   and     A               ; is it text mode?
5187+ 3E43 28 1B                jr      Z,CLRTXT        ; yes, stop here because in text mode, background and border colors coincide
5188+ 3E45 CD 9E 23             call    CHKSYN          ; Make sure ',' follows
5189+ 3E48 2C                   defb    ','
5190+ 3E49 CD FE 32             call    GETINT          ; get third value
5191+ 3E4C CD BD 3E             call    CHKCLR1         ; check if it's in range 1~15
5192+ 3E4F 32 7F 61             ld      (TMPBFR3),A     ; store it
5193+ 3E52 D5                   push    DE              ; store DE
5194+ 3E53 3A 6D 61             ld      A,(SCR_MODE)    ; check screen mode
5195+ 3E56 FE 01                cp      $01             ; is it G1 mode?
5196+ 3E58 28 10                jr      Z,CLRG1         ; yes, jump over
5197+ 3E5A FE 02                cp      $02             ; is it G2 mode?
5198+ 3E5C 28 15                jr      Z,CLRG2         ; yes, jump over
5199+ 3E5E 18 1C                jr      CLREX2          ; last case can only be ExG2
5200+ 3E60 CD B0 3E     CLRTXT: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5201+ 3E63 32 7F 61     CLRMC:  ld      (TMPBFR3),A     ; store color settings (for MC mode, we only set border color)
5202+ 3E66 D5                   push    DE              ; store DE
5203+ 3E67 F3                   di                      ; disable INTs
5204+ 3E68 18 2D                jr      SETBRCL         ; set colors and exit
5205+ 3E6A CD B0 3E     CLRG1:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5206+ 3E6D 16 01                ld      D,$01           ; repeat 1 time
5207+ 3E6F 06 20                ld      B,$20           ; 32 bytes of colors
5208+ 3E71 18 10                jr      LOADCLR         ; load colors
5209+ 3E73 CD B0 3E     CLRG2:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5210+ 3E76 16 18                ld      D,$18           ; 18 pages of...
5211+ 3E78 06 00                ld      B,$00           ; ...256 bytes each
5212+ 3E7A 18 07                jr      LOADCLR         ; load colors
5213+ 3E7C CD B0 3E     CLREX2: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5214+ 3E7F 16 08                ld      D,$08           ; 8 pages of...
5215+ 3E81 06 00                ld      B,$00           ; ...256 bytes each
5216+ 3E83 E5           LOADCLR:push    HL              ; store HL
5217+ 3E84 21 00 20             ld      HL,$2000        ; color table start: $2000
5218+ 3E87 F3                   di                      ; disable INTs
5219+ 3E88 CD 66 06             call    SETVDPADRS
5220+ 3E8B 0D                   dec     C              ; VDP data mode
5221+ 3E8C ED 79        RPTLDCL:out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
5222+ 3E8E 00                   nop
5223+ 3E8F 00                   nop
5224+ 3E90 10 FA                djnz    RPTLDCL         ; repeat for 256 bytes (1 page)
5225+ 3E92 15                   dec     D               ; did we fill up all the pages?
5226+ 3E93 20 F7                jr      NZ,RPTLDCL      ; no, repeat
5227+ 3E95 FB                   ei
5228+ 3E96 E1                   pop     HL              ; retrieve HL
5229+ 3E97 3A 7B 61     SETBRCL:ld      A,(TMPBFR1)     ; retrieve foreground color
5230+ 3E9A 32 79 61             ld      (FRGNDCLR),A    ; store it
5231+ 3E9D 3A 7D 61             ld      A,(TMPBFR2)     ; retrieve background color
5232+ 3EA0 32 7A 61             ld      (BKGNDCLR),A    ; store it
5233+ 3EA3 3A 7F 61             ld      A,(TMPBFR3)     ; recover border color
5234+ 3EA6 5F                   ld      E,A             ; move it into E
5235+ 3EA7 3E 07                ld      A,$07           ; set VDP register 7
5236+ 3EA9 F3                   di
5237+ 3EAA CD B0 06             call    WRITE_VREG      ; send value to VDP: set border color
5238+ 3EAD FB                   ei                      ; re-enable INTs
5239+ 3EAE D1                   pop     DE              ; retrieve DE
5240+ 3EAF C9                   ret                     ; return to caller
5241+ 3EB0
5242+ 3EB0
5243+ 3EB0              ; mix 2 color nibbles in 1 byte
5244+ 3EB0 3A 7D 61     MIXCLRS:ld      A,(TMPBFR2)     ; retrieve background color
5245+ 3EB3 47                   ld      B,A             ; move it into B
5246+ 3EB4 3A 7B 61             ld      A,(TMPBFR1)     ; retrieve foreground color
5247+ 3EB7 87                   add     A,A             ; move foreground color into the high nibble of A
5248+ 3EB8 87                   add     A,A
5249+ 3EB9 87                   add     A,A
5250+ 3EBA 87                   add     A,A
5251+ 3EBB B0                   or      B               ; put background color into the low nibble of A
5252+ 3EBC C9                   ret                     ; return to caller
5253+ 3EBD
5254+ 3EBD
5255+ 3EBD              ; check if the color is not 0 and into the range 1~15
5256+ 3EBD A7           CHKCLR1:and     A               ; is it 0?
5257+ 3EBE CA 9E 20             jp      Z,SNERR         ; yes, raise a SN error
5258+ 3EC1 FE 10        CHKCLR0:cp      $10             ; is it in range 0~15?
5259+ 3EC3 D2 9E 20             jp      NC,SNERR        ; no, raise a SN error
5260+ 3EC6 C9                   ret                     ; param is OK, can return
5261+ 3EC7
5262+ 3EC7
5263+ 3EC7              ; check if in graphics 2 mode
5264+ 3EC7 3A 6D 61     CHKG2M: ld      A,(SCR_MODE)    ; check screen mode
5265+ 3ECA FE 02                cp      $02             ; actually, we can paint only in G2
5266+ 3ECC C2 D5 44             jp      NZ,GMERR        ; no G2, print a No Graphics Mode Error
5267+ 3ECF C9                   ret                     ; return to caller
5268+ 3ED0
5269+ 3ED0
5270+ 3ED0              ; print a text in screen 2
5271+ 3ED0              ; GPRINT text,x,y[,fc[,bc]]
5272+ 3ED0              ; where "text" is an expression that can be converted into a sequence of ASCII chars,
5273+ 3ED0              ; x & y are the coordinates (0<=x<=31, 0<=y<=23), fc & bc are foreground and background
5274+ 3ED0              ; colors (1~15), resp.
5275+ 3ED0              ; (portions of code are from nippur72)
5276+ 3ED0              GX      equ     TMPBFR3
5277+ 3ED0              GY      equ     TMPBFR4
5278+ 3ED0              TMPCLR  equ     TMPBFR2
5279+ 3ED0              MIXCOL  equ     TMPBFR1
5280+ 3ED0              TMPADR  equ     VIDEOBUFF
5281+ 3ED0              CHRPNT  equ     VIDEOBUFF+$02
5282+ 3ED0              NUMCHR  equ     VIDEOBUFF+$04
5283+ 3ED0              TMPHL   equ     VIDEOBUFF+$06
5284+ 3ED0 CD C7 3E     GPRINT: call    CHKG2M          ; check if in graphic mode 2
5285+ 3ED3 2B                   dec     HL              ; dec 'cos GETCHR INCs
5286+ 3ED4 CD E7 25             call    GETCHR          ; check if something follows
5287+ 3ED7 CA 9E 20             jp      Z,SNERR         ; if nothing else, raise a syntax error
5288+ 3EDA 22 83 61             ld      (TMPADR),HL     ; save current code string pointer
5289+ 3EDD CD 8A 2A             call    EVAL            ; Evaluate expression
5290+ 3EE0 CD 7C 2A             call    TSTSTR          ; Make sure it's a string
5291+ 3EE3 22 89 61             ld      (TMPHL),HL      ; store code string pointer
5292+ 3EE6 CD C3 30             call    GSTRCU          ; Current string to pool
5293+ 3EE9 CD D4 38             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
5294+ 3EEC ED 43 85 61          ld      (CHRPNT),BC     ; store string pointer
5295+ 3EF0 ED 53 87 61          ld      (NUMCHR),DE     ; store string lenght
5296+ 3EF4 2A 89 61             ld      HL,(TMPHL)      ; restore code string pointer
5297+ 3EF7 CD 9E 23             call    CHKSYN          ; Make sure ',' follows
5298+ 3EFA 2C                   defb    ','
5299+ 3EFB CD FE 32             call    GETINT          ; get X coord.
5300+ 3EFE FE 20                cp      $20             ; is it in rage 0~31?
5301+ 3F00 D2 B2 26             jp      NC,FCERR        ; Illegal function call error
5302+ 3F03 32 7F 61             ld      (GX),A          ; store into temp. buffer
5303+ 3F06 CD 9E 23             call    CHKSYN          ; Make sure ',' follows
5304+ 3F09 2C                   defb    ','
5305+ 3F0A CD FE 32             call    GETINT          ; get Y coord.
5306+ 3F0D FE 18                cp      $18             ; is it in range 0~23?
5307+ 3F0F D2 B2 26             jp      NC,FCERR        ; Illegal function call error
5308+ 3F12 32 81 61             ld      (GY),A          ; store into temp. buffer
5309+ 3F15 11 7D 61             ld      DE,TMPCLR
5310+ 3F18 3A 7A 61             ld      A,(BKGNDCLR)    ; load background color
5311+ 3F1B 12                   ld      (DE),A          ; store into temp buff
5312+ 3F1C 3A 79 61             ld      A,(FRGNDCLR)    ; load foreground color
5313+ 3F1F 1B                   dec     DE
5314+ 3F20 1B                   dec     DE
5315+ 3F21 12                   ld      (DE),A          ; store into temp buff
5316+ 3F22 CD AD 3F             call    CKCOL           ; check color
5317+ 3F25 CA 2D 3F             jp      Z,CNTGPT2       ; if anything follows, jump over
5318+ 3F28 13                   inc     DE
5319+ 3F29 13                   inc     DE
5320+ 3F2A CD AD 3F             call    CKCOL           ; check background color
5321+ 3F2D CD B0 3E     CNTGPT2:call    MIXCLRS         ; mix foreground & background colors
5322+ 3F30 32 7B 61             ld      (MIXCOL),A      ; store mixed colors
5323+ 3F33 E5                   push    HL              ; store code string address
5324+ 3F34 ED 4B 85 61          ld      BC,(CHRPNT)     ; retrieve string pointer
5325+ 3F38 ED 5B 87 61          ld      DE,(NUMCHR)     ; retrieve string lenght
5326+ 3F3C 1C                   inc     E               ; Length + 1
5327+ 3F3D CD 42 3F             call    GPNT            ; print on G2
5328+ 3F40 E1                   pop     HL              ; recover HL
5329+ 3F41 C9                   ret                     ; return to caller
5330+ 3F42 D5           GPNT:   push    DE              ; store string lenght (E)
5331+ 3F43                      ; calculate VRAM address of first char
5332+ 3F43 3A 7F 61             LD      A,(GX)          ; load X
5333+ 3F46 6F                   ld      L,A             ;
5334+ 3F47 26 00                ld      H,0             ; HL = X
5335+ 3F49 29                   add     HL,HL           ;
5336+ 3F4A 29                   add     HL,HL           ;
5337+ 3F4B 29                   add     HL,HL           ; X=X*8
5338+ 3F4C 3A 81 61             ld      A,(GY)          ; load Y
5339+ 3F4F 57                   ld      D,A             ; move it into D
5340+ 3F50 1E 00                ld      E,0             ; DE =Y*256
5341+ 3F52 19                   add     HL,DE           ; address = X*8 + Y*256
5342+ 3F53 22 83 61             ld      (TMPADR),HL     ; store VRAM address of first VRAM cell
5343+ 3F56 D1                   pop     DE              ; retrieve # of chars to be printed yet (E)
5344+ 3F57 1D           RPGPNT: dec     E               ; Count characters
5345+ 3F58 C8                   ret     Z               ; End of string - return
5346+ 3F59 D5                   push    DE              ; store chars counter
5347+ 3F5A                      ; calculate dest address in color vram
5348+ 3F5A 2A 83 61             ld      HL,(TMPADR)     ; recover VRAM address
5349+ 3F5D 11 00 20             ld      DE,$2000        ; color map address
5350+ 3F60 19                   add     HL,DE           ; HL = $2000 + XY address
5351+ 3F61 F3                   di                      ; disable INTs
5352+ 3F62                      ; send color settings
5353+ 3F62 CD 66 06     GPNTCOL:call    SETVDPADRS      ; set VRAM address for color cell
5354+ 3F65 3A 7B 61             ld      A,(MIXCOL)      ; load color settings
5355+ 3F68 06 08                ld      B,$08           ; repeat for 8 rows
5356+ 3F6A 0E 30                ld      C,VDP_DAT       ; VDP data mode
5357+ 3F6C ED 79        GPNTCO1:out     (C),A           ; send data (VRAM pointer auto-increments)
5358+ 3F6E 00                   nop                     ; wait...
5359+ 3F6F 00                   nop                     ; ...a...
5360+ 3F70 00                   nop                     ; ...while
5361+ 3F71 10 F9                djnz    GPNTCO1         ; repeat for 8 cells
5362+ 3F73                      ; calculate source address
5363+ 3F73 2A 85 61             ld      HL,(CHRPNT)     ; load char pointer
5364+ 3F76 7E                   ld      A,(HL)          ; get char
5365+ 3F77 23                   inc     HL              ; increment char pointer
5366+ 3F78 22 85 61             ld      (CHRPNT),HL     ; store char pointer
5367+ 3F7B 6F                   ld      L,A             ;
5368+ 3F7C 26 00                ld      H,$00           ; char into HL
5369+ 3F7E 29                   add     HL,HL           ;
5370+ 3F7F 29                   add     HL,HL           ;
5371+ 3F80 29                   add     HL,HL           ; get offset of char into ROM (charcode * 8)
5372+ 3F81 11 71 56             ld      DE,CHRST88      ; DE = start of 8x8 fonts in ROM
5373+ 3F84 19                   add     HL,DE           ; HL = start of characters in ROM
5374+ 3F85 EB                   ex      DE,HL           ; store address into DE
5375+ 3F86 2A 83 61     GPCPCHR:ld      HL,(TMPADR)     ; load VRAM address
5376+ 3F89 CD 66 06             call    SETVDPADRS      ; send it to VDP
5377+ 3F8C EB                   ex      DE,HL           ; restore address into HL
5378+ 3F8D 06 08                ld      B,$08           ; repeat for 8 rows
5379+ 3F8F 0D                   dec     C              ; VDP data mode
5380+ 3F90 ED A3        GPCPCH1:outi                    ; load a byte from ROM and send to VRAM
5381+ 3F92 00                   nop                     ; wait...
5382+ 3F93 00                   nop                     ; ...a...
5383+ 3F94 00                   nop                     ; ...while
5384+ 3F95 20 F9                jr      NZ,GPCPCH1      ; repeat for 8 chars
5385+ 3F97 FB                   ei                      ; re-enable INTs
5386+ 3F98 11 08 00             ld      DE,$0008        ; 8 bytes to go to the next video cell
5387+ 3F9B 2A 83 61             ld      HL,(TMPADR)     ; load VRAM address
5388+ 3F9E 19                   add     HL,DE           ; get address of next VRAM cell
5389+ 3F9F 22 83 61             ld      (TMPADR),HL     ; store new VRAM address
5390+ 3FA2 11 00 18             ld      DE,$1800        ; forbidden address
5391+ 3FA5 CD 3B 4D             call    CMP16           ; check if the printing has gone out of the screen
5392+ 3FA8 D1                   pop     DE              ; retrieve number of chars to be printed
5393+ 3FA9 D0                   ret     NC              ; if HL>=$1800 then leave
5394+ 3FAA C3 57 3F             jp      RPGPNT          ; otherwise, check if more chars to output
5395+ 3FAD
5396+ 3FAD              ; used by GPRINT to get a color argument (if present)
5397+ 3FAD 2B           CKCOL:  dec     HL              ; dec 'cos GETCHR INCs
5398+ 3FAE CD E7 25             call    GETCHR          ; Get next character
5399+ 3FB1 C8                   ret     Z               ; return if nothing follows
5400+ 3FB2 CD 9E 23             call    CHKSYN          ; Make sure ',' follows
5401+ 3FB5 2C                   defb    ','
5402+ 3FB6 D5                   push    DE              ; store DE
5403+ 3FB7 CD FE 32             call    GETINT          ; get value
5404+ 3FBA CD BD 3E             call    CHKCLR1         ; check if color is in range 1~15
5405+ 3FBD D1                   pop     DE              ; retrieve DE
5406+ 3FBE 12                   ld      (DE),A          ; store color into temp buffer
5407+ 3FBF C9                   ret                     ; return to caller
5408+ 3FC0
5409+ 3FC0
5410+ 3FC0              ; paint X,Y[,C]: in graphics mode, fills an area starting
5411+ 3FC0              ; at point X,Y, using default color or, if used, with
5412+ 3FC0              ; color set by C
5413+ 3FC0              ; TMPBFR1       X
5414+ 3FC0              ; TMPBFR2       Y
5415+ 3FC0              ; TMPBFR3       COLOR
5416+ 3FC0              PNT     equ     VIDEOBUFF
5417+ 3FC0              SPA     equ     VIDEOBUFF+$02
5418+ 3FC0              SPB     equ     VIDEOBUFF+$03
5419+ 3FC0              ORGSP   equ     VIDEOBUFF+$04
5420+ 3FC0 CD C7 3E     PAINT:  call    CHKG2M          ; check if in graphic mode 2
5421+ 3FC3 CD FE 32             call    GETINT          ; get X
5422+ 3FC6 32 7B 61             ld      (TMPBFR1),A     ; store X
5423+ 3FC9 CD 9E 23             call    CHKSYN          ; Make sure ',' follows
5424+ 3FCC 2C                   defb    ','
5425+ 3FCD CD FE 32             call    GETINT          ; get Y coords,
5426+ 3FD0 FE C0                cp      $C0             ; check if Y is in range 0~191
5427+ 3FD2 D2 B2 26             jp      NC,FCERR        ; no, raise an FC error
5428+ 3FD5 32 7D 61             ld      (TMPBFR2),A     ; store Y
5429+ 3FD8 CD BC 44             call    CLRPRM          ; check if color has been passed
5430+ 3FDB 3A 7F 61             ld      A,(TMPBFR3)     ; load color
5431+ 3FDE A7                   and     A               ; check if 0
5432+ 3FDF CA B2 26             jp      Z,FCERR         ; yes, raise an error
5433+ 3FE2 E5                   push    HL              ; store HL
5434+ 3FE3 C5                   push    BC              ; store BC
5435+ 3FE4 D5                   push    DE              ; store DE
5436+ 3FE5                      ; start algorithm
5437+ 3FE5 CD F8 40             call    PNTRTN          ; check if pixel is already set
5438+ 3FE8 C2 9C 40             jp      NZ,EXITPA2      ; if yes, then leave PAINT
5439+ 3FEB ED 73 87 61          ld      (ORGSP),SP      ; no, store current Stack Pointer
5440+ 3FEF 21 01 00             ld      HL,$0001        ; HL=1
5441+ 3FF2 22 83 61             ld      (PNT),HL        ; set PNT
5442+ 3FF5 3A 7B 61             ld      A,(TMPBFR1)     ; load starting X...
5443+ 3FF8 47                   ld      B,A             ; ...into B
5444+ 3FF9 3A 7D 61             ld      A,(TMPBFR2)     ; load starting Y...
5445+ 3FFC 4F                   ld      C,A             ; ...into C
5446+ 3FFD C5                   push    BC              ; store starting X,Y into stack
5447+ 3FFE                      ; main loop
5448+ 3FFE 2A 83 61     NXTLOOP:ld      HL,(PNT)        ; retrieve PNT
5449+ 4001 7C                   ld      A,H             ; check if PNT=0
5450+ 4002 B5                   or      L
5451+ 4003 CA 98 40             jp      Z,EXITPAI       ; yes, no more points to process - exit
5452+ 4006 2B                   dec     HL              ; no, so decrement PNT...
5453+ 4007 22 83 61             ld      (PNT),HL        ; ...and store it
5454+ 400A C1                   pop     BC              ; retrieve pixel coordinates X,Y into BC
5455+ 400B CD A0 40     PAINT0: call    CHECKPA         ; check if pixel is set/reset
5456+ 400E 20 09                jr      NZ,PAINT11      ; pixel is set, so jump over
5457+ 4010 78                   ld      A,B             ; pixel is reset, check if X1=0
5458+ 4011 A7                   and     A               ; (reached the limit of the screen)
5459+ 4012 CA 1A 40             jp      Z,PAINT1        ; yes, jump over
5460+ 4015 05                   dec     B               ; no, decrement X1...
5461+ 4016 C3 0B 40             jp      PAINT0          ; ...and repeat
5462+ 4019 04           PAINT11:inc     B               ; if found a pixel on, the re-increment X1
5463+ 401A AF           PAINT1: xor     A               ; reset A
5464+ 401B 57                   ld      D,A             ; set SA=0
5465+ 401C 5F                   ld      E,A             ; set SB=0
5466+ 401D CD A0 40     MNPAINT:call    CHECKPA         ; check if pixel is set/reset
5467+ 4020 20 DC                jr      NZ,NXTLOOP      ; it's set, so goto next loop
5468+ 4022 78                   ld      A,B             ; copy X1
5469+ 4023 32 7B 61             ld      (TMPBFR1),A     ; into buffer
5470+ 4026 79                   ld      A,C             ; copy Y
5471+ 4027 32 7D 61             ld      (TMPBFR2),A     ; into buffer
5472+ 402A CD 1E 41             call    CNTPLOT         ; plot pixel X1,Y
5473+ 402D 7A                   ld      A,D             ; load SA into A
5474+ 402E A7                   and     A               ; SA=0?
5475+ 402F 20 1C                jr      NZ,PAINT2       ; no, jump over
5476+ 4031 79                   ld      A,C             ; load Y
5477+ 4032 FE 01                cp      $01             ; Y>0?
5478+ 4034 DA 4D 40             jp      C,PAINT2        ; no, jump over
5479+ 4037 3D                   dec     A               ; yes, Y=Y-1
5480+ 4038 CD A1 40             call    CHECKPY         ; check pixel X1,Y-1
5481+ 403B 20 10                jr      NZ,PAINT2       ; it's set, so jump over
5482+ 403D 0D                   dec     C               ; Y=Y-1
5483+ 403E C5                   push    BC              ; insert pixel(X1,Y-1) into stack
5484+ 403F 0C                   inc     C               ; retrieve original Y
5485+ 4040 2A 83 61             ld      HL,(PNT)        ; load PNT
5486+ 4043 23                   inc     HL              ; increment PNT
5487+ 4044 22 83 61             ld      (PNT),HL        ; store new PNT
5488+ 4047 3E 01                ld      A,$01           ; set SA=1 and...
5489+ 4049 57                   ld      D,A             ; ...store SA into memory
5490+ 404A C3 60 40             jp      PAINT3          ; jump over
5491+ 404D 7A           PAINT2: ld      A,D             ; load SA into A
5492+ 404E 1F                   rra                     ; check if SA=1
5493+ 404F 30 0F                jr      NC,PAINT3       ; no, jump over
5494+ 4051 79                   ld      A,C             ; load Y
5495+ 4052 FE 01                cp      $01             ; Y>0?
5496+ 4054 DA 60 40             jp      C,PAINT3        ; no, jump over
5497+ 4057 3D                   dec     A               ; Y=Y-1
5498+ 4058 CD A1 40             call    CHECKPY         ; check pixel X1,Y-1
5499+ 405B CA 60 40             jp      Z,PAINT3        ; if pixel is off, jump over
5500+ 405E AF                   xor     A               ; pixel is on, so...
5501+ 405F 57                   ld      D,A             ; ...set SA=0
5502+ 4060 7B           PAINT3: ld      A,E             ; check if...
5503+ 4061 A7                   and     A               ; SB=0
5504+ 4062 20 1B                jr      NZ,PAINT4       ; no, jump over
5505+ 4064 79                   ld      A,C             ; load Y
5506+ 4065 FE BF                cp      $BF             ; Y<191?
5507+ 4067 30 16                jr      NC,PAINT4       ; no, jump over
5508+ 4069 3C                   inc     A               ; Y=Y+1
5509+ 406A CD A1 40             call    CHECKPY         ; check pixel X1,Y+1
5510+ 406D 20 10                jr      NZ,PAINT4       ; pixel is on, so jump over
5511+ 406F 0C                   inc     C               ; Y=Y+1
5512+ 4070 C5                   push    BC              ; insert pixel(X1,Y+1) into stack
5513+ 4071 0D                   dec     C               ; retrieve original Y
5514+ 4072 2A 83 61             ld      HL,(PNT)        ; PNT
5515+ 4075 23                   inc     HL              ; PNT=PNT+1
5516+ 4076 22 83 61             ld      (PNT),HL        ; store PNT
5517+ 4079 3E 01                ld      A,$01           ; SB=1
5518+ 407B 5F                   ld      E,A             ; set SB
5519+ 407C C3 91 40             jp      PAINT5          ; jump over
5520+ 407F 7B           PAINT4: ld      A,E             ; load SB
5521+ 4080 1F                   rra                     ; check if SB=1
5522+ 4081 30 0E                jr      NC,PAINT5       ; no, jump over
5523+ 4083 79                   ld      A,C             ; load Y
5524+ 4084 FE BF                cp      $BF             ; Y<191?
5525+ 4086 30 09                jr      NC,PAINT5       ; no, jump over
5526+ 4088 3C                   inc     A               ; Y=Y+1
5527+ 4089 CD A1 40             call    CHECKPY         ; check pixel X1,Y+1
5528+ 408C CA 91 40             jp      Z,PAINT5        ; if pixel is off, jump over
5529+ 408F AF                   xor     A               ; pixel is on, so...
5530+ 4090 5F                   ld      E,A             ; ...set SB=0
5531+ 4091 04           PAINT5: inc     B               ; X1=X1+1
5532+ 4092 CA FE 3F             jp      Z,NXTLOOP       ; if X1>255 (X1=0) then goto next loop
5533+ 4095 C3 1D 40             jp      MNPAINT         ; otherwise, repeat for next X
5534+ 4098 ED 7B 87 61  EXITPAI:ld      SP,(ORGSP)      ; retrieve original SP pointer
5535+ 409C D1           EXITPA2:pop     DE              ; retrieve DE
5536+ 409D C1                   pop     BC              ; retrieve BC
5537+ 409E E1                   pop     HL              ; retrieve HL
5538+ 409F C9                   ret                     ; return to caller
5539+ 40A0 79           CHECKPA:ld      A,C             ; copy Y into A
5540+ 40A1 32 7D 61     CHECKPY:ld      (TMPBFR2),A     ; store Y
5541+ 40A4 78                   ld      A,B             ; copy X1 into A
5542+ 40A5 32 7B 61             ld      (TMPBFR1),A     ; store X1
5543+ 40A8 C5                   push    BC              ; save X1,Y
5544+ 40A9 D5                   push    DE
5545+ 40AA CD F8 40             call    PNTRTN          ; check if pixel is set/reset
5546+ 40AD D1                   pop     DE
5547+ 40AE C1                   pop     BC              ; retrieve X1,Y
5548+ 40AF C9                   ret                     ; return to caller
5549+ 40B0
5550+ 40B0
5551+ 40B0              ; POINT(x,y): return if a pixel is set (returns color) or if it's reset (0)
5552+ 40B0 CD C7 3E     POINT:  call    CHKG2M          ; check if in graphic mode 2
5553+ 40B3 CD 9E 23             call    CHKSYN          ; make sure "(" follows
5554+ 40B6 28                   defb    '('
5555+ 40B7 CD FE 32             call    GETINT          ; get X coords.
5556+ 40BA 32 7B 61             ld      (TMPBFR1),A     ; store it into a temp buffer
5557+ 40BD CD 9E 23             call    CHKSYN          ; Make sure ',' follows
5558+ 40C0 2C                   defb    ','
5559+ 40C1 CD FE 32             call    GETINT          ; get Y coords,
5560+ 40C4 FE C0                cp      $C0             ; check if Y is in range 0~191
5561+ 40C6 D2 B2 26             jp      NC,FCERR        ; no, raise an FC error
5562+ 40C9 32 7D 61             ld      (TMPBFR2),A     ; store into a temp buffer
5563+ 40CC CD 9E 23             call    CHKSYN          ; make sure ")" follows
5564+ 40CF 29                   defb    ')'
5565+ 40D0 E5                   push    HL              ; store current string address - the point after the ")" - ...
5566+ 40D1 FD E1                pop     IY              ; ...into IY
5567+ 40D3 CD F8 40             call    PNTRTN          ; check if pixel is set or reset
5568+ 40D6 20 0C                jr      NZ,CTPOINT      ; it's ON, jump over
5569+ 40D8 AF                   xor     A               ; no, it's OFF. make sure to reset A...
5570+ 40D9 47                   ld      B,A             ; ...and B
5571+ 40DA E1           PNTEND: pop     HL              ; drop original return point
5572+ 40DB FD E5                push    IY              ; load current string address from IY into stack
5573+ 40DD 11 63 2B             ld      DE,RETNUM       ; Address of Return number from function...
5574+ 40E0 D5                   push    DE              ; ...saved on stack
5575+ 40E1 C3 62 2E             jp      ABPASS          ; return AB
5576+ 40E4 CB EC        CTPOINT:set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5577+ 40E6 F3                   di
5578+ 40E7 CD 86 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5579+ 40EA FB                   ei
5580+ 40EB CB 3F                srl     A               ; shift A...
5581+ 40ED CB 3F                srl     A               ; ...4 times...
5582+ 40EF CB 3F                srl     A               ; ...to move foreground color...
5583+ 40F1 CB 3F                srl     A               ; ...into lowest nibble
5584+ 40F3 47                   ld      B,A             ; color into B
5585+ 40F4 AF                   xor     A               ; reset MSB
5586+ 40F5 C3 DA 40             jp      PNTEND          ; return AB
5587+ 40F8 CD 6B 41     PNTRTN: call    XY2HL           ; find HL address of pixel at X,Y
5588+ 40FB 57                   ld      D,A             ; store pixel index
5589+ 40FC F3                   di                      ; disable INTs
5590+ 40FD CD 86 06             call    READ_VIDEO_LOC  ; read contents of VRAM cell addressed by HL
5591+ 4100 FB                   ei                      ; re-enable INTs
5592+ 4101 A2                   and     D               ; is the pixel ON or OFF? (will be checked later)
5593+ 4102 C9                   ret                     ; return to caller
5594+ 4103
5595+ 4103
5596+ 4103              ; PLOT X,Y[,color]
5597+ 4103              ; plot a pixel in graphic mode 2
5598+ 4103 CD C7 3E     PLOT:   call    CHKG2M          ; check if in G2 mode
5599+ 4106 CD FE 32             call    GETINT          ; get X coords.
5600+ 4109 32 7B 61             ld      (TMPBFR1),A     ; store it into a temp buffer
5601+ 410C CD 9E 23             call    CHKSYN          ; Make sure ',' follows
5602+ 410F 2C                   defb    ','
5603+ 4110 CD FE 32             call    GETINT          ; get Y coords,
5604+ 4113 FE C0                cp      $C0             ; check if Y is in range 0~191
5605+ 4115 D2 B2 26             jp      NC,FCERR        ; no, raise an FC error
5606+ 4118 32 7D 61             ld      (TMPBFR2),A     ; store into a temp buffer
5607+ 411B CD BC 44             call    CLRPRM          ; check if param "color" has been passed
5608+ 411E E5           CNTPLOT:push    HL              ; store HL
5609+ 411F C5                   push    BC              ; store BC
5610+ 4120 D5                   push    DE              ; store DE
5611+ 4121 CD 6B 41             call    XY2HL           ; find VRAM address of byte containing pixel at X,Y & return into HL
5612+ 4124 D2 5F 41             jp      NC,NOGD         ; if carry is reset, there was an error -> so leave
5613+ 4127 57                   ld      D,A             ; move pixel value into D
5614+ 4128 3A 7F 61             ld      A,(TMPBFR3)     ; retrieve color
5615+ 412B A7                   and     A               ; is it 0? (background, or reset pixel)
5616+ 412C 20 11                jr      NZ,CNTPLT1      ; no, continue
5617+ 412E F3                   di                      ; yes - so, disable INTs
5618+ 412F CD 86 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5619+ 4132 FB                   ei                      ; re-enable INTs
5620+ 4133 5F                   ld      E,A             ; store value of cell
5621+ 4134 7A                   ld      A,D             ; retrieve pixel
5622+ 4135 2F                   cpl                     ; revert bits
5623+ 4136 A3                   and     E               ; set video pixel to off
5624+ 4137 F3                   di                      ; disable INTs
5625+ 4138 CD 9B 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5626+ 413B FB                   ei                      ; re-enable INTs
5627+ 413C C3 5F 41             jp      NOGD            ; leave
5628+ 413F 87           CNTPLT1:add     A,A             ; now we move low nibble
5629+ 4140 87                   add     A,A             ; in the high nibble
5630+ 4141 87                   add     A,A             ; by adding A to itself
5631+ 4142 87                   add     A,A             ; 4 times (this is a shift left 4)
5632+ 4143 5F                   ld      E,A             ; move it into E
5633+ 4144 F3                   di                      ; disable INTs
5634+ 4145 CD 86 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5635+ 4148 FB                   ei
5636+ 4149 B2                   or      D               ; merge new pixel preserving original pattern
5637+ 414A F3                   di
5638+ 414B CD 9B 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5639+ 414E FB                   ei
5640+ 414F CB EC                set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5641+ 4151 F3                   di
5642+ 4152 CD 86 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5643+ 4155 FB                   ei
5644+ 4156 E6 0F                and     %00001111       ; reset high nibble (the foreground color)
5645+ 4158 B3                   or      E               ; set new foreground color
5646+ 4159 F3                   di
5647+ 415A CD 9B 06             call    WRITE_VIDEO_LOC ; write new color settings
5648+ 415D FB                   ei                      ; re-enable INTs
5649+ 415E 00                   nop                     ; wait for INTs to be enabled again
5650+ 415F D1           NOGD:   pop     DE              ; retrieve DE
5651+ 4160 C1                   pop     BC              ; retrieve BC
5652+ 4161 E1                   pop     HL              ; retrieve HL
5653+ 4162 C9                   ret                     ; return to caller
5654+ 4163 80 40 20 10  PXLSET: defb    $80,$40,$20,$10,$08,$04,$02,$01 ; pixel to be set ON
5654+ 4167 08 04 02 01
5655+ 416B                      ; where R(X/8)=> 0=80h, 1=40h, 2=20h, 3=10h, 4=08h, 5=04h, 6=02h, 7=$01
5656+ 416B
5657+ 416B
5658+ 416B              ; compute the VRAM address of the byte containing the pixel
5659+ 416B              ; being pointed by X,Y (TMPBFR1,TMPBFR2)
5660+ 416B              ; byte address is returned into HL
5661+ 416B              ; pixel is returned into A
5662+ 416B              XY2HL:  ; formula is: ADDRESS=(INT(X/8))*8 + (INT(Y/8))*256 + R(Y/8)
5663+ 416B                      ; where R(Y/8) is the remainder of (Y/8)
5664+ 416B                      ; the pixel to be set is given by R(X/8), and data is taken from the array
5665+ 416B 3A 7D 61             ld      A,(TMPBFR2)     ; retrieve Y
5666+ 416E FE C0                cp      $C0             ; Y>=192?
5667+ 4170 D0                   ret     NC              ; yes, so leave
5668+ 4171 1E 08                ld      E,$08           ; load E with divisor
5669+ 4173 57                   ld      D,A             ; and store into D (dividend)
5670+ 4174 CD 86 4D             call    DIV_8_8         ; get Y/8, D is quotient=INT(Y/8), and A is remainder
5671+ 4177 4F                   ld      C,A             ; store remainder into C
5672+ 4178 42                   ld      B,D             ; B=(INT(Y/8))*256 (we simply copy quotient into B)
5673+ 4179 60 69                ld      HL,BC           ; copy BC into HL: now HL has the VRAM address of the byte being set
5674+ 417B 3A 7B 61             ld      A,(TMPBFR1)     ; retrieve X
5675+ 417E 57                   ld      D,A             ; and move it into D (dividend)
5676+ 417F CD 86 4D             call    DIV_8_8         ; get X/8, D is quotient=INT(X/8), and A is remainder
5677+ 4182 4F                   ld      C,A             ; store remainder into C
5678+ 4183 7A                   ld      A,D             ; move quotient into A
5679+ 4184 87                   add     A,A             ; multiply quotient by 8
5680+ 4185 87                   add     A,A
5681+ 4186 87                   add     A,A
5682+ 4187 5F                   ld      E,A             ; store result into E
5683+ 4188 16 00                ld      D,$00           ; reset D
5684+ 418A 19                   add     HL,DE           ; add DE to HL, getting the final VRAM address
5685+ 418B EB                   ex      DE,HL           ; move VRAM address into DE
5686+ 418C 21 63 41             ld      HL,PXLSET       ; starting address of table for pixel to draw
5687+ 418F 06 00                ld      B,$00           ; reset B
5688+ 4191 09                   add     HL,BC           ; add C (remainder of X/8) to get address of pixel to turn on
5689+ 4192 7E                   ld      A,(HL)          ; load pixel data
5690+ 4193 EB                   ex      DE,HL           ; retrieve VRAM pattern address into HL
5691+ 4194 37                   scf                     ; set Carry for normal exit
5692+ 4195 C9                   ret                     ; return to caller
5693+ 4196
5694+ 4196
5695+ 4196              ; DRAW X1,Y1,X2,Y2[,color]
5696+ 4196              ; Draw a line using Bresenham's line algorithm from X1,Y1 to X2,Y2
5697+ 4196              ; X1,Y1 can be either less than or greater than X2,Y2 (meaning that)
5698+ 4196              ; the drawing will be ever done from X1,Y2 to X2,Y2, regardless of
5699+ 4196              ; the values. If color is not specified, the foreground color set
5700+ 4196              ; with COLOR will be used
5701+ 4196              X1      equ     TMPBFR1
5702+ 4196              Y1      equ     TMPBFR2
5703+ 4196              X2      equ     VIDEOBUFF
5704+ 4196              Y2      equ     VIDEOBUFF+$02
5705+ 4196              ER      equ     VIDEOBUFF+$04
5706+ 4196              E2      equ     VIDEOBUFF+$06
5707+ 4196              SX      equ     VIDEOBUFF+$08
5708+ 4196              SY      equ     VIDEOBUFF+$0A
5709+ 4196              DX      equ     VIDEOBUFF+$0C
5710+ 4196              DY      equ     VIDEOBUFF+$0E
5711+ 4196 CD C7 3E     DRAW:   call    CHKG2M          ; check if in G2 mode
5712+ 4199 CD 9E 44             call    CLRTMBF         ; clear TMPBFRx
5713+ 419C CD AD 44             call    CLRVDBF         ; clear VIDEOBUFF
5714+ 419F CD FE 32             call    GETINT          ; get X1 coords.
5715+ 41A2 32 7B 61             ld      (X1),A          ; store it into a temp buffer
5716+ 41A5 CD 9E 23             call    CHKSYN          ; Make sure ',' follows
5717+ 41A8 2C                   defb    ','
5718+ 41A9 CD FE 32             call    GETINT          ; get Y1 coords.
5719+ 41AC FE C0                cp      $C0             ; check if Y1 is in range 0~191
5720+ 41AE D2 B2 26             jp      NC,FCERR        ; no, raise an FC error
5721+ 41B1 32 7D 61             ld      (Y1),A          ; store into a temp buffer
5722+ 41B4 CD 9E 23             call    CHKSYN          ; Make sure ',' follows
5723+ 41B7 2C                   defb    ','
5724+ 41B8 CD FE 32             call    GETINT          ; get X2 coords.
5725+ 41BB 32 83 61             ld      (X2),A          ; store it into a temp buffer
5726+ 41BE CD 9E 23             call    CHKSYN          ; Make sure ',' follows
5727+ 41C1 2C                   defb    ','
5728+ 41C2 CD FE 32             call    GETINT          ; get Y2 coords
5729+ 41C5 FE C0                cp      $C0             ; check if Y2 is in range 0~191
5730+ 41C7 D2 B2 26             jp      NC,FCERR        ; no, raise an FC error
5731+ 41CA 32 85 61             ld      (Y2),A          ; store it into a temp buffer
5732+ 41CD CD BC 44             call    CLRPRM          ; check for arg. "color" and store it into TMPBFR3
5733+ 41D0 E5                   push    HL              ; store register we'll use
5734+ 41D1 D5                   push    DE
5735+ 41D2 C5                   push    BC
5736+ 41D3 ED 5B 7B 61          ld      DE,(X1)         ; load X1 and
5737+ 41D7 2A 83 61             ld      HL,(X2)         ; X2
5738+ 41DA B7                   or      A               ; clear CARRY
5739+ 41DB ED 52                sbc     HL,DE           ; DX=X2-X1
5740+ 41DD CD 7C 4D             call    absHL           ; DX=ABS(DX)
5741+ 41E0 22 8F 61             ld      (DX),HL         ; store DX
5742+ 41E3 01 FF FF             ld      BC,$FFFF        ; SX=-1
5743+ 41E6 2A 7B 61             ld      HL,(X1)
5744+ 41E9 ED 5B 83 61          ld      DE,(X2)
5745+ 41ED CD 3B 4D             call    CMP16           ; X1<X2?
5746+ 41F0 CA F9 41             jp      Z,X1GR          ; no, X1=X2
5747+ 41F3 F2 F9 41             jp      P,X1GR          ; no, X1>X2
5748+ 41F6 01 01 00             ld      BC,$0001        ; yes, so set SX=1
5749+ 41F9 ED 43 8B 61  X1GR:   ld      (SX),BC         ; store SX
5750+ 41FD ED 5B 7D 61          ld      DE,(Y1)
5751+ 4201 2A 85 61             ld      HL,(Y2)
5752+ 4204 B7                   or      A               ; clear Carry
5753+ 4205 ED 52                sbc     HL,DE           ; DY=Y2-Y1
5754+ 4207 CD 7C 4D             call    absHL           ; DY=ABS(DY)
5755+ 420A 22 91 61             ld      (DY),HL         ; store DY
5756+ 420D 01 FF FF             ld      BC,$FFFF        ; SY=-1
5757+ 4210 2A 7D 61             ld      HL,(Y1)
5758+ 4213 ED 5B 85 61          ld      DE,(Y2)
5759+ 4217 CD 3B 4D             call    CMP16           ; is Y1<Y2?
5760+ 421A CA 23 42             jp      Z,Y1GR          ; no, Y1=Y2
5761+ 421D F2 23 42             jp      P,Y1GR          ; no, Y1>Y2 - jump over
5762+ 4220 01 01 00             ld      BC,$0001        ; yes, so set SY=1
5763+ 4223 ED 43 8D 61  Y1GR:   ld      (SY),BC         ; store SY
5764+ 4227 2A 91 61             ld      HL,(DY)         ; ER=DY
5765+ 422A CD 7F 4D             call    negHL           ; ER=-DY
5766+ 422D 22 87 61             ld      (ER),HL         ; store ER
5767+ 4230 2A 8F 61             ld      HL,(DX)
5768+ 4233 ED 5B 91 61          ld      DE,(DY)
5769+ 4237 CD 3B 4D             call    CMP16           ; DX>DY?
5770+ 423A CA 46 42             jp      Z,ER2           ; no, DX=DY
5771+ 423D FA 46 42             jp      M,ER2           ; no, DX<DY
5772+ 4240 2A 8F 61             ld      HL,(DX)         ; reload DX
5773+ 4243 22 87 61             ld      (ER),HL         ; yes: DX>DY, so ER=DX
5774+ 4246 2A 87 61     ER2:    ld      HL,(ER)         ; load ER
5775+ 4249 CB 2C                sra     H               ; right shift (and preserve sign)...
5776+ 424B CB 1D                rr      L               ; ...of HL, so ER=INT(ER/2)
5777+ 424D CB 7C                bit     7,H             ; is the number negative?
5778+ 424F CA 53 42             jp      Z,STRE2         ; no, jump over
5779+ 4252 23                   inc     HL              ; yes, add 1 'cos INT of a negative number needs to be incremented
5780+ 4253 22 87 61     STRE2:  ld      (ER),HL         ; store ER
5781+ 4256 CD 1E 41     RPTDRW: call    CNTPLOT         ; plot first pixel
5782+ 4259 2A 7B 61             ld      HL,(X1)
5783+ 425C ED 5B 83 61          ld      DE,(X2)
5784+ 4260 CD 3B 4D             call    CMP16           ; X1=X2?
5785+ 4263 20 0D                jr      NZ,CNTDRW       ; no, continue drawing
5786+ 4265 2A 7D 61             ld      HL,(Y1)         ; yes, so check
5787+ 4268 ED 5B 85 61          ld      DE,(Y2)         ; also Y
5788+ 426C CD 3B 4D             call    CMP16           ; Y1=Y2?
5789+ 426F CA CB 42             jp      Z,ENDDRAW       ; yes, finished drawing: exit
5790+ 4272 ED 5B 87 61  CNTDRW: ld      DE,(ER)
5791+ 4276 ED 53 89 61          ld      (E2),DE         ; E2=ER
5792+ 427A 2A 8F 61             ld      HL,(DX)
5793+ 427D CD 7F 4D             call    negHL           ; DX=-DX
5794+ 4280 EB                   ex      DE,HL           ; invert DE and HL => HL=E2, DE=-DX
5795+ 4281 CD 3B 4D             call    CMP16           ; E2>-DX?
5796+ 4284 CA A2 42             jp      Z,DXGR          ; no, E2=-DX: jump
5797+ 4287 FA A2 42             jp      M,DXGR          ; no, E2<-DX: jump
5798+ 428A 2A 87 61             ld      HL,(ER)         ; yes
5799+ 428D ED 5B 91 61          ld      DE,(DY)
5800+ 4291 B7                   or      A               ; clear CARRY
5801+ 4292 ED 52                sbc     HL,DE           ; ER=ER-DY
5802+ 4294 22 87 61             ld      (ER),HL
5803+ 4297 2A 7B 61             ld      HL,(X1)
5804+ 429A ED 5B 8B 61          ld      DE,(SX)
5805+ 429E 19                   add     HL,DE           ; X1=X1+SX (increment X1)
5806+ 429F 22 7B 61             ld      (X1),HL
5807+ 42A2 2A 89 61     DXGR:   ld      HL,(E2)
5808+ 42A5 ED 5B 91 61          ld      DE,(DY)
5809+ 42A9 CD 3B 4D             call    CMP16           ; E2<DY?
5810+ 42AC CA 56 42             jp      Z,RPTDRW        ; no, E2=DY: jump
5811+ 42AF F2 56 42             jp      P,RPTDRW        ; no, E2>DY: jump
5812+ 42B2 2A 87 61             ld      HL,(ER)         ; yes
5813+ 42B5 ED 5B 8F 61          ld      DE,(DX)
5814+ 42B9 19                   add     HL,DE           ; ER=ER+DX
5815+ 42BA 22 87 61             ld      (ER),HL
5816+ 42BD 2A 7D 61             ld      HL,(Y1)
5817+ 42C0 ED 5B 8D 61          ld      DE,(SY)
5818+ 42C4 19                   add     HL,DE           ; Y1=Y1+SY (increment Y1)
5819+ 42C5 22 7D 61             ld      (Y1),HL
5820+ 42C8 C3 56 42             jp      RPTDRW          ; repeat
5821+ 42CB C1           ENDDRAW:pop     BC              ; retrieve BC
5822+ 42CC D1                   pop     DE              ; retrieve DE
5823+ 42CD E1                   pop     HL              ; retrieve HL
5824+ 42CE C9                   ret                     ; return to caller
5825+ 42CF
5826+ 42CF
5827+ 42CF              ; CIRCLE X,Y,R[,C]
5828+ 42CF              ; Draw a circle using Bresenham's circle algorithm with center in X,Y
5829+ 42CF              ; and radius R, with optional color C. If color is not specified, the
5830+ 42CF              ; foreground color set with COLOR will be used
5831+ 42CF              XC      equ     VIDEOBUFF
5832+ 42CF              YC      equ     VIDEOBUFF+$02
5833+ 42CF              RADIUS  equ     VIDEOBUFF+$04
5834+ 42CF              XI      equ     VIDEOBUFF+$06
5835+ 42CF              YI      equ     VIDEOBUFF+$08
5836+ 42CF              DC      equ     VIDEOBUFF+$0A
5837+ 42CF CD C7 3E     CIRCLE: call    CHKG2M          ; check if in G2 mode
5838+ 42D2 CD AD 44             call    CLRVDBF         ; clear VIDEOBUFF
5839+ 42D5 CD FE 32             call    GETINT          ; get X coords.
5840+ 42D8 32 83 61             ld      (XC),A          ; store it into a temp buffer
5841+ 42DB CD 9E 23             call    CHKSYN          ; Make sure ',' follows
5842+ 42DE 2C                   defb    ','
5843+ 42DF CD FE 32             call    GETINT          ; get Y coords,
5844+ 42E2 32 85 61             ld      (YC),A          ; store it into a temp buffer
5845+ 42E5 CD 9E 23             call    CHKSYN          ; Make sure ',' follows
5846+ 42E8 2C                   defb    ','
5847+ 42E9 CD FE 32             call    GETINT          ; get radius
5848+ 42EC 32 87 61             ld      (RADIUS),A      ; store it into a temp buffer
5849+ 42EF CD BC 44             call    CLRPRM          ; check if param "color" has been passed
5850+ 42F2 C5                   push    BC              ; store BC
5851+ 42F3 D5                   push    DE              ; store DE
5852+ 42F4 E5                   push    HL              ; store HL
5853+ 42F5 AF                   xor     A               ; clear A,
5854+ 42F6 47                   ld      B,A             ; B,
5855+ 42F7 4F                   ld      C,A             ; C,
5856+ 42F8 57                   ld      D,A             ; D,
5857+ 42F9 67                   ld      H,A             ; and H
5858+ 42FA ED 43 89 61          ld      (XI),BC         ; clear XI
5859+ 42FE 3A 87 61             ld      A,(RADIUS)      ; load RADIUS into A
5860+ 4301 6F                   ld      L,A             ; HL now contains R
5861+ 4302 22 8B 61             ld      (YI),HL         ; YI=RADIUS
5862+ 4305 29                   add     HL,HL           ; R*2
5863+ 4306 EB                   ex      DE,HL           ; put HL into DE
5864+ 4307 21 03 00             ld      HL,$0003        ; HL = 3
5865+ 430A AF                   xor     A               ; clear Carry
5866+ 430B ED 52                sbc     HL,DE           ; D=3-(2*R) => HL
5867+ 430D 22 8D 61             ld      (DC),HL         ; store D
5868+ 4310 CD 6F 43             call    DRWCRL          ; draw initial point
5869+ 4313 ED 5B 89 61  RPTCRL: ld      DE,(XI)         ; load XI
5870+ 4317 2A 8B 61             ld      HL,(YI)         ; load YI
5871+ 431A CD 3B 4D             call    CMP16           ; is YI<DI?
5872+ 431D CA 26 43             jp      Z,RPTCL1        ; no, YI=XI
5873+ 4320 F2 26 43             jp      P,RPTCL1        ; no, YI>XI
5874+ 4323 C3 6B 43             jp      ENDCRL          ; yes, so we've finished
5875+ 4326 21 89 61     RPTCL1: ld      HL,XI
5876+ 4329 34                   inc     (HL)            ; XI=XI+1
5877+ 432A 2A 8D 61             ld      HL,(DC)         ; load D
5878+ 432D 7C                   ld      A,H
5879+ 432E B5                   or      L               ; is D=0? Yes, jump over
5880+ 432F CA 53 43             jp      Z,DLSZ
5881+ 4332 CB 7C                bit     7,H             ; is D<0?
5882+ 4334 20 1D                jr      NZ,DLSZ         ; yes, jump over
5883+ 4336 ED 5B 8B 61          ld      DE,(YI)         ; D>0
5884+ 433A 1B                   dec     DE              ; so, YI=YI-1
5885+ 433B ED 53 8B 61          ld      (YI),DE         ; store YI
5886+ 433F AF                   xor     A               ; clear Carry
5887+ 4340 2A 89 61             ld      HL,(XI)
5888+ 4343 ED 52                sbc     HL,DE           ; HL=XI-YI
5889+ 4345 29                   add     HL,HL
5890+ 4346 29                   add     HL,HL           ; HL=HL*4
5891+ 4347 11 0A 00             ld      DE,10
5892+ 434A 19                   add     HL,DE           ; HL=HL+10
5893+ 434B ED 5B 8D 61          ld      DE,(DC)         ; load D
5894+ 434F EB                   ex      DE,HL           ; invert DE and HL, so that HL=4*(XI-YI)+10 and DE=D
5895+ 4350 19                   add     HL,DE           ; D=D+4*(XI-YI)+10
5896+ 4351 18 0F                jr      PLTCRL          ; plot next pixel
5897+ 4353 2A 89 61     DLSZ:   ld      HL,(XI)         ; load XI
5898+ 4356 29                   add     HL,HL
5899+ 4357 29                   add     HL,HL           ; XI=XI*4
5900+ 4358 11 06 00             ld      DE,$0006
5901+ 435B 19                   add     HL,DE
5902+ 435C ED 5B 8D 61          ld      DE,(DC)
5903+ 4360 EB                   ex      DE,HL           ; HL=D and DE=4*XI+6
5904+ 4361 19                   add     HL,DE           ; D=D+4*XI+6
5905+ 4362 22 8D 61     PLTCRL: ld      (DC),HL         ; store new D
5906+ 4365 CD 6F 43             call    DRWCRL          ; plot pixel
5907+ 4368 C3 13 43             jp      RPTCRL          ; repeat
5908+ 436B E1           ENDCRL: pop     HL
5909+ 436C D1                   pop     DE
5910+ 436D C1                   pop     BC
5911+ 436E C9                   ret                     ; return to caller
5912+ 436F 2A 83 61     DRWCRL: ld      HL,(XC)
5913+ 4372 ED 5B 89 61          ld      DE,(XI)
5914+ 4376 19                   add     HL,DE           ; X=XC+XI
5915+ 4377 22 7B 61             ld      (X1),HL         ; store X
5916+ 437A CD 8E 44             call    VALIDX          ; check if X is valid (0~255)
5917+ 437D DA 91 43             jp      C,CNTCL1        ; if Carry is set, X is not valid
5918+ 4380 2A 85 61             ld      HL,(YC)
5919+ 4383 ED 5B 8B 61          ld      DE,(YI)
5920+ 4387 19                   add     HL,DE           ; Y=YC+YI
5921+ 4388 22 7D 61             ld      (Y1),HL         ; store Y
5922+ 438B CD 93 44             call    VALIDY          ; check if Y is valid (0~191)
5923+ 438E D4 1E 41             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5924+ 4391 AF           CNTCL1: xor     A               ; clear Carry
5925+ 4392 2A 83 61             ld      HL,(XC)
5926+ 4395 ED 5B 89 61          ld      DE,(XI)
5927+ 4399 ED 52                sbc     HL,DE           ; X=XC-XI
5928+ 439B 22 7B 61             ld      (X1),HL         ; store X
5929+ 439E CD 8E 44             call    VALIDX          ; check if X is valid (0~255)
5930+ 43A1 DA B5 43             jp      C,CNTCL2        ; if Carry is set, X is not valid
5931+ 43A4 2A 85 61             ld      HL,(YC)
5932+ 43A7 ED 5B 8B 61          ld      DE,(YI)
5933+ 43AB 19                   add     HL,DE           ; Y=YC+YI
5934+ 43AC 22 7D 61             ld      (Y1),HL         ; store Y
5935+ 43AF CD 93 44             call    VALIDY          ; check if Y is valid (0~191)
5936+ 43B2 D4 1E 41             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5937+ 43B5 2A 83 61     CNTCL2: ld      HL,(XC)
5938+ 43B8 ED 5B 89 61          ld      DE,(XI)
5939+ 43BC 19                   add     HL,DE           ; X=XC+XI
5940+ 43BD 22 7B 61             ld      (X1),HL         ; store X
5941+ 43C0 CD 8E 44             call    VALIDX          ; check if X is valid (0~255)
5942+ 43C3 DA D9 43             jp      C,CNTCL3        ; if Carry is set, X is not valid
5943+ 43C6 AF                   xor     A               ; clear Carry
5944+ 43C7 2A 85 61             ld      HL,(YC)
5945+ 43CA ED 5B 8B 61          ld      DE,(YI)
5946+ 43CE ED 52                sbc     HL,DE           ; Y=YC-YI
5947+ 43D0 22 7D 61             ld      (Y1),HL         ; store Y
5948+ 43D3 CD 93 44             call    VALIDY          ; check if Y is valid (0~191)
5949+ 43D6 D4 1E 41             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5950+ 43D9 AF           CNTCL3: xor     A               ; clear Carry
5951+ 43DA 2A 83 61             ld      HL,(XC)
5952+ 43DD ED 5B 89 61          ld      DE,(XI)
5953+ 43E1 ED 52                sbc     HL,DE           ; X=XC-XI
5954+ 43E3 22 7B 61             ld      (X1),HL         ; store X
5955+ 43E6 CD 8E 44             call    VALIDX          ; check if X is valid (0~255)
5956+ 43E9 DA FF 43             jp      C,CNTCL4        ; if Carry is set, X is not valid
5957+ 43EC AF                   xor     A               ; clear Carry
5958+ 43ED 2A 85 61             ld      HL,(YC)
5959+ 43F0 ED 5B 8B 61          ld      DE,(YI)
5960+ 43F4 ED 52                sbc     HL,DE           ; Y=YC-YI
5961+ 43F6 22 7D 61             ld      (Y1),HL         ; store Y
5962+ 43F9 CD 93 44             call    VALIDY          ; check if Y is valid (0~191)
5963+ 43FC D4 1E 41             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5964+ 43FF 2A 83 61     CNTCL4: ld      HL,(XC)
5965+ 4402 ED 5B 8B 61          ld      DE,(YI)
5966+ 4406 19                   add     HL,DE           ; X=XC+YI
5967+ 4407 22 7B 61             ld      (X1),HL         ; store X
5968+ 440A CD 8E 44             call    VALIDX          ; check if X is valid (0~255)
5969+ 440D DA 21 44             jp      C,CNTCL5        ; if Carry is set, X is not valid
5970+ 4410 2A 85 61             ld      HL,(YC)
5971+ 4413 ED 5B 89 61          ld      DE,(XI)
5972+ 4417 19                   add     HL,DE           ; Y=YC+XI
5973+ 4418 22 7D 61             ld      (Y1),HL         ; store Y
5974+ 441B CD 93 44             call    VALIDY          ; check if Y is valid (0~191)
5975+ 441E D4 1E 41             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5976+ 4421 AF           CNTCL5: xor     A               ; clear Carry
5977+ 4422 2A 83 61             ld      HL,(XC)
5978+ 4425 ED 5B 8B 61          ld      DE,(YI)
5979+ 4429 ED 52                sbc     HL,DE           ; X=XC-YI
5980+ 442B 22 7B 61             ld      (X1),HL         ; store X
5981+ 442E CD 8E 44             call    VALIDX          ; check if X is valid (0~255)
5982+ 4431 DA 45 44             jp      C,CNTCL6        ; if Carry is set, X is not valid
5983+ 4434 2A 85 61             ld      HL,(YC)
5984+ 4437 ED 5B 89 61          ld      DE,(XI)
5985+ 443B 19                   add     HL,DE           ; Y=YC+XI
5986+ 443C 22 7D 61             ld      (Y1),HL         ; store Y
5987+ 443F CD 93 44             call    VALIDY          ; check if Y is valid (0~191)
5988+ 4442 D4 1E 41             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5989+ 4445 2A 83 61     CNTCL6: ld      HL,(XC)
5990+ 4448 ED 5B 8B 61          ld      DE,(YI)
5991+ 444C 19                   add     HL,DE           ; X=XC+YI
5992+ 444D 22 7B 61             ld      (X1),HL         ; store X
5993+ 4450 CD 8E 44             call    VALIDX          ; check if X is valid (0~255)
5994+ 4453 DA 69 44             jp      C,CNTCL7        ; if Carry is set, X is not valid
5995+ 4456 AF                   xor     A               ; clear Carry
5996+ 4457 2A 85 61             ld      HL,(YC)
5997+ 445A ED 5B 89 61          ld      DE,(XI)
5998+ 445E ED 52                sbc     HL,DE           ; Y=YC-XI
5999+ 4460 22 7D 61             ld      (Y1),HL         ; store Y
6000+ 4463 CD 93 44             call    VALIDY          ; check if Y is valid (0~191)
6001+ 4466 D4 1E 41             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
6002+ 4469 AF           CNTCL7: xor     A               ; clear Carry
6003+ 446A 2A 83 61             ld      HL,(XC)
6004+ 446D ED 5B 8B 61          ld      DE,(YI)
6005+ 4471 ED 52                sbc     HL,DE           ; X=XC-YI
6006+ 4473 22 7B 61             ld      (X1),HL         ; store X
6007+ 4476 CD 8E 44             call    VALIDX          ; check if X is valid (0~255)
6008+ 4479 D8                   ret     C               ; if Carry is set, X is not valid
6009+ 447A AF                   xor     A               ; clear Carry
6010+ 447B 2A 85 61             ld      HL,(YC)
6011+ 447E ED 5B 89 61          ld      DE,(XI)
6012+ 4482 ED 52                sbc     HL,DE           ; Y=YC-XI
6013+ 4484 22 7D 61             ld      (Y1),HL         ; store Y
6014+ 4487 CD 93 44             call    VALIDY          ; check if Y is valid (0~191)
6015+ 448A D4 1E 41             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
6016+ 448D C9                   ret                     ; return to caller
6017+ 448E
6018+ 448E              ; check if X,Y coordinates are valid: 0<=X<=255 and 0<=Y<=191
6019+ 448E              ; input: HL (value to check), can be negative
6020+ 448E              ; output: CARRY flag: reset => VALID  //  set => NOT VALID
6021+ 448E              ; destroys: A
6022+ 448E AF           VALIDX: xor     A               ; reset A
6023+ 448F B4                   or      H               ; check if H is 0 (this means that X is in range 0~255 and not negative)
6024+ 4490 C8                   ret     Z               ; yes, we can return (C is clear)
6025+ 4491 37                   scf                     ; set Carry flag to raise error
6026+ 4492 C9                   ret                     ; return to caller
6027+ 4493
6028+ 4493 AF           VALIDY: xor     A               ; reset A
6029+ 4494 B4                   or      H               ; check if H is 0 (this means that Y is in range 0~255 and not negative)
6030+ 4495 28 02                jr      Z,CNTVALY       ; yes, continue checking
6031+ 4497 37                   scf                     ; no, raise error by setting Carry flag
6032+ 4498 C9                   ret                     ; return to caller
6033+ 4499 7D           CNTVALY:ld      A,L
6034+ 449A FE C0                cp      $C0             ; is Y<192? Carry is set if Y<192
6035+ 449C 3F                   ccf                     ; invert Carry, so Carry=0 means OK, Carry=1 means ERROR
6036+ 449D C9                   ret                     ; return to caller
6037+ 449E
6038+ 449E
6039+ 449E
6040+ 449E              ; cleat TMPBFR1-4 buffers before using them
6041+ 449E AF           CLRTMBF:xor     A               ; reset A
6042+ 449F E5                   push    HL              ; store HL
6043+ 44A0 C5                   push    BC              ; store BC
6044+ 44A1 21 7B 61             ld      HL,TMPBFR1      ; address of 1st location
6045+ 44A4 06 08                ld      B,$08           ; 8 locations
6046+ 44A6 77           RPCLTMB:ld      (HL),A          ; clear byte
6047+ 44A7 23                   inc     HL              ; next location
6048+ 44A8 10 FC                djnz    RPCLTMB         ; repeat
6049+ 44AA C1                   pop     BC              ; retrieve BC
6050+ 44AB E1                   pop     HL              ; retrieve HL
6051+ 44AC C9                   ret                     ; return to caller
6052+ 44AD
6053+ 44AD
6054+ 44AD              ; clear VIDEOBUFF before using it as temp buffer
6055+ 44AD AF           CLRVDBF:xor     A               ; clear A
6056+ 44AE C5                   push    BC              ; store BC
6057+ 44AF E5                   push    HL              ; store HL
6058+ 44B0 06 28                ld      B,$28           ; 40 cells
6059+ 44B2 21 83 61             ld      HL,VIDEOBUFF    ; address of 1st cell
6060+ 44B5 77           RPTCVBF:ld      (HL),A          ; clear cell
6061+ 44B6 23                   inc     HL              ; next cell
6062+ 44B7 10 FC                djnz    RPTCVBF         ; repeat
6063+ 44B9 E1                   pop     HL              ; retrieve HL
6064+ 44BA C1                   pop     BC              ; retrieve BC
6065+ 44BB C9                   ret                     ; return to caller
6066+ 44BC
6067+ 44BC
6068+ 44BC              ; check if a color is passed as argument with PLOT, DRAW, and CIRCLE
6069+ 44BC              ; commands. If not present, the default foreground color will be used
6070+ 44BC 3A 79 61     CLRPRM: ld      A,(FRGNDCLR)    ; load foreground color
6071+ 44BF 32 7F 61             ld      (TMPBFR3),A     ; store into temp buffer
6072+ 44C2 2B                   dec     HL              ; dec 'cos GETCHR INCs
6073+ 44C3 CD E7 25             call    GETCHR          ; Get next character
6074+ 44C6 C8                   ret     Z               ; return foreground color if nothing follows
6075+ 44C7 CD 9E 23             call    CHKSYN          ; Make sure ',' follows
6076+ 44CA 2C                   defb    ','
6077+ 44CB CD FE 32             call    GETINT          ; get value
6078+ 44CE CD C1 3E             call    CHKCLR0         ; check if color is in range 0~15
6079+ 44D1 32 7F 61             ld      (TMPBFR3),A     ; store color into temp buffer
6080+ 44D4 C9                   ret                     ; return to caller
6081+ 44D5
6082+ 44D5
6083+ 44D5              ; no graphics mode error: raised when a graphics command is invoked
6084+ 44D5              ; out of graphic 2 mode.
6085+ 44D5 1E 2A        GMERR:  ld      E,GM            ; load Graphics Mode Error flag
6086+ 44D7 C3 B8 20             jp      ERROR           ; print error
6087+ 44DA
6088+ 44DA
6089+ 44DA              ; set a serial port: params are PORT,BPS,DATA,PARITY,STOP
6090+ 44DA              ; PORT=1/2; BPS=1,200~57,600 (see below), DATA=5/6/7/8
6091+ 44DA              ; PARITY: 0=no parity; 1=ODD parity; 2=EVEN parity;
6092+ 44DA              ; STOP=0/1/2/3: 0=0 bit; 1=1 bit; 2=1.5 bits; 3=2 bits
6093+ 44DA              ; PORT 1 acts as a char device; PORT 2 acts as a block device
6094+ 44DA              ; DATA,PARITY, and STOP are optional: if nothing follows BPS,
6095+ 44DA              ; they are assumed to be 8,0,1 resp.
6096+ 44DA              PRTNUM  equ     VIDEOBUFF
6097+ 44DA              BPS     equ     PRTNUM+$01
6098+ 44DA              DATABT  equ     BPS+$02
6099+ 44DA              PARBT   equ     DATABT+$01
6100+ 44DA              STPBT   equ     PARBT+$01
6101+ 44DA              SIOBFR  equ     STPBT+$01
6102+ 44DA CD FE 32     SERIAL: call    GETINT          ; get port #
6103+ 44DD A7                   and     A               ; is it zero?
6104+ 44DE CA B2 26             jp      Z,FCERR         ; yes, error
6105+ 44E1 FE 03                cp      $03             ; is it 1 or 2?
6106+ 44E3 D2 03 47             jp      NC,SCERR        ; no, error
6107+ 44E6 32 83 61             ld      (PRTNUM),A      ; store port number into a temp buffer
6108+ 44E9 CD 9E 23             call    CHKSYN          ; Make sure ',' follows
6109+ 44EC 2C                   defb    ','
6110+ 44ED 2B                   dec     HL
6111+ 44EE CD E7 25             call    GETCHR          ; check what's following
6112+ 44F1 CA 9E 20             jp      Z,SNERR         ; error if nothing follows
6113+ 44F4 30 05                jr      NC,SERVAR       ; it's not a number, try a variable
6114+ 44F6 CD B7 26             call    ATOH            ; get bps (returned into DE)
6115+ 44F9 18 0F                jr      CHKZSER         ; jump over
6116+ 44FB CD 78 2A     SERVAR: call    GETNUM          ; get number
6117+ 44FE CD 85 38             call    TSTSGN          ; check value
6118+ 4501 FA B2 26             jp      M,FCERR         ; negative - illegal function call
6119+ 4504 3A D2 61             ld      A,(FPEXP)       ; Get integer value to DE
6120+ 4507 CD 2D 39             call    FPINT           ; get integer number into BCDE - drop BC 'cause isn't necessary
6121+ 450A 7A           CHKZSER:ld      A,D             ; bps is into DE - move MSB into A
6122+ 450B B3                   or      E               ; check if bps=0
6123+ 450C 20 3A                jr      NZ,CNTSER       ; no, continue checking
6124+ 450E                      ; if baud rate is 0, then close the serial comm.
6125+ 450E 3A 83 61     RSTSERS:ld      A,(PRTNUM)      ; yes, so reset the channel. First, load port number
6126+ 4511 3D                   dec     A               ; subtract 1, so that serial channel is 0=>A and 1=>B
6127+ 4512 C6 22                add     SIO_CA          ; find correct channel
6128+ 4514 4F                   ld      C,A             ; store serial channel
6129+ 4515 F3                   di                      ; disable INTs
6130+ 4516 AF                   xor     A               ; reset A
6131+ 4517 16 01                ld      D,$01           ; start from WR1
6132+ 4519 06 05                ld      B,$05           ; 5 registers
6133+ 451B ED 51        RPTRSSR:out     (C),D           ; select register
6134+ 451D ED 79                out     (C),A           ; reset register
6135+ 451F 14                   inc     D               ; next register
6136+ 4520 10 F9                djnz    RPTRSSR         ; repeat
6137+ 4522 3E 30                ld      A,%00110000     ; write into WR0: error reset, select WR0
6138+ 4524 ED 79                out     (C),A           ; send command to serial channel
6139+ 4526 3E 18                ld      A,%00011000     ; write into WR0: channel reset
6140+ 4528 ED 79                out     (C),A           ; send command to serial channel
6141+ 452A FB                   ei                      ; re-enable INTs
6142+ 452B E5                   push    HL              ; store HL
6143+ 452C 21 BD 61             ld      HL,SERIALS_EN   ; serials enabled status byte
6144+ 452F DB 01                in      A,(PIO_DB)      ; read status LEDs
6145+ 4531 CB 41                bit     0,C             ; check serial port
6146+ 4533 20 09                jr      NZ,SRPT2        ; if bit is set, jump to port 2
6147+ 4535 CB B7                res     6,A             ; it's port 1
6148+ 4537 CB A7                res     4,A             ; remove possible error LED
6149+ 4539 CB 86                res     0,(HL)          ; disable port 1
6150+ 453B C3 44 45             jp      SERLED          ; jump over
6151+ 453E CB BF        SRPT2:  res     7,A             ; it's port 2
6152+ 4540 CB AF                res     5,A             ; remove possible error LED
6153+ 4542 CB 8E                res     1,(HL)          ; disable port 2
6154+ 4544 D3 01        SERLED: out     (PIO_DB),A      ; send new configuration
6155+ 4546 E1                   pop     HL              ; retrieve HL
6156+ 4547 C9                   ret                     ; return to caller
6157+ 4548                      ; check if bps=1, meaning reactivate RX on serial
6158+ 4548 7A           CNTSER: ld      A,D
6159+ 4549 B2                   or      D               ; check if bps<>1 by first checking D=0
6160+ 454A 20 36                jr      NZ,CNTSER2      ; if not, jump over
6161+ 454C 7B                   ld      A,E             ; then by checking that
6162+ 454D FE 01                cp      $01             ; E=1
6163+ 454F 20 31                jr      NZ,CNTSER2      ; if not, jump over
6164+ 4551 3A 83 61             ld      A,(PRTNUM)      ; load port number
6165+ 4554 57                   ld      D,A             ; store port on D
6166+ 4555 3A BD 61             ld      A,(SERIALS_EN)  ; load address of serial status cell
6167+ 4558 A2                   and     D               ; check status
6168+ 4559 CA 03 47             jp      Z,SCERR         ; port not open, raise error
6169+ 455C F3                   di                      ; disable INTs
6170+ 455D 7A                   ld      A,D             ; move port # into A
6171+ 455E 5F                   ld      E,A             ; and also into E
6172+ 455F 87                   add     A
6173+ 4560 87                   add     A               ; move A to left times 2
6174+ 4561 57                   ld      D,A             ; move value into D
6175+ 4562 3A BD 61             ld      A,(SERIALS_EN)  ; load serial status byte
6176+ 4565 B2                   or      D               ; re-enable RX
6177+ 4566 32 BD 61             ld      (SERIALS_EN),A  ; store new serial status
6178+ 4569 7B                   ld      A,E             ; recover port #
6179+ 456A 3D                   dec     A               ; check port
6180+ 456B 20 0A                jr      NZ,CNTRX2       ; port is #2
6181+ 456D CD E3 01             call    SIO_A_EI        ; re-enable RX on port 1
6182+ 4570 DB 01                in      A,(PIO_DB)      ; load status LEDs
6183+ 4572 CB A7                res     4,A             ; remove error LED
6184+ 4574 C3 7E 45             jp      RXEND           ; terminate setting
6185+ 4577 CD EB 01     CNTRX2: call    SIO_B_EI        ; re-enable RX on port 2
6186+ 457A DB 01                in      A,(PIO_DB)      ; load status LEDs
6187+ 457C CB AF                res     5,A             ; remove error LED
6188+ 457E D3 01        RXEND:  out     (PIO_DB),A      ; set new status for LEDs
6189+ 4580 FB                   ei                      ; re-enable INTs
6190+ 4581 C9                   ret                     ; return to caller
6191+ 4582                      ; set serial port comm.
6192+ 4582 D5           CNTSER2:push    DE              ; store BPS
6193+ 4583 3A 83 61             ld      A,(PRTNUM)      ; load port number
6194+ 4586 57                   ld      D,A             ; move port # into D
6195+ 4587 3A BD 61             ld      A,(SERIALS_EN)  ; check if serial port is already open
6196+ 458A A2                   and     D               ; by ANDing A with D
6197+ 458B D1                   pop     DE              ; retrieve BPS
6198+ 458C CA 94 45             jp      Z,CNTSER3       ; not open, continue
6199+ 458F 1E 2E                ld      E,SA            ; already open, so raise a "Serial Port Already Error"
6200+ 4591 C3 B8 20             jp      ERROR           ; and leave
6201+ 4594 E5           CNTSER3:push    HL              ; store HL
6202+ 4595 21 00 E1             ld      HL,$E100        ; check bps. start with HL=57,600
6203+ 4598 CD 3B 4D             call    CMP16           ; is bps<=57,600?
6204+ 459B E1                   pop     HL              ; but first, recover HL
6205+ 459C DA 03 47             jp      C,SCERR         ; no (bps>57,600) then error
6206+ 459F ED 53 84 61          ld      (BPS),DE        ; store bps
6207+ 45A3 2B                   dec     HL              ; dec 'cos GETCHR INCs
6208+ 45A4 CD E7 25             call    GETCHR          ; Get next character
6209+ 45A7 CA DF 45             jp      Z,DEFSER        ; defaults if nothing follows
6210+ 45AA CD 9E 23             call    CHKSYN          ; Make sure ',' follows
6211+ 45AD 2C                   defb    ','
6212+ 45AE CD FE 32             call    GETINT          ; get data bits
6213+ 45B1 FE 05                cp      $05             ; is it <5?
6214+ 45B3 DA 03 47             jp      C,SCERR         ; yes, error
6215+ 45B6 FE 09                cp      $09             ; is it >=9?
6216+ 45B8 D2 B2 26             jp      NC,FCERR        ; yes, error
6217+ 45BB 32 86 61             ld      (DATABT),A      ; store data bits
6218+ 45BE CD 9E 23             call    CHKSYN          ; Make sure ',' follows
6219+ 45C1 2C                   defb    ','
6220+ 45C2 CD FE 32             call    GETINT          ; get parity bits
6221+ 45C5 BF FE 03             cp      A,$03           ; check if parity is in range 0~2
6222+ 45C8 D2 03 47             jp      NC,SCERR        ; no, error
6223+ 45CB 32 87 61             ld      (PARBT),A       ; store parity
6224+ 45CE CD 9E 23             call    CHKSYN          ; Make sure ',' follows
6225+ 45D1 2C                   defb    ','
6226+ 45D2 CD FE 32             call    GETINT          ; get stop bits
6227+ 45D5 FE 03                cp      $03             ; is it >=3?
6228+ 45D7 D2 03 47             jp      NC,SCERR        ; yes, error
6229+ 45DA 32 88 61             ld      (STPBT),A       ; store stop bits
6230+ 45DD 18 0D                jr      SETSER          ; jump to set serial
6231+ 45DF 3E 08        DEFSER: ld      A,$08           ; 8 bits for data
6232+ 45E1 32 86 61             ld      (DATABT),A
6233+ 45E4 AF                   xor     A               ; no parity bit
6234+ 45E5 32 87 61             ld      (PARBT),A
6235+ 45E8 3C                   inc     A               ; 1 bit for stop
6236+ 45E9 32 88 61             ld      (STPBT),A
6237+ 45EC                      ; check if bps are legal
6238+ 45EC E5           SETSER: push    HL              ; store HL
6239+ 45ED D5                   push    DE              ; store DE
6240+ 45EE DD E5                push    IX              ; store IX
6241+ 45F0 DD 21 DE 46          ld      IX,SUP_BPS      ; allowed BPSs
6242+ 45F4 06 0B                ld      B,$0B           ; 11 items
6243+ 45F6 0E 00                ld      C,$00           ; reset pointer
6244+ 45F8 2A 84 61     CKBPS:  ld      HL,(BPS)        ; load BPS
6245+ 45FB DD 5E 00             ld      E,(IX+0)        ; load LSB of item
6246+ 45FE DD 56 01             ld      D,(IX+1)        ; load MSB of item
6247+ 4601 CD 3B 4D             call    CMP16           ; is it equal?
6248+ 4604 CA 11 46             jp      Z,SET_PT        ; yes, found a correspondance
6249+ 4607 DD 23                inc     IX
6250+ 4609 DD 23                inc     IX              ; no, go to next entry
6251+ 460B 0C                   inc     C               ; increment pointer
6252+ 460C 10 EA                djnz    CKBPS           ; repeat for 10 entries
6253+ 460E C3 FF 46             jp      SCERR1          ; if nothing found, raise an error
6254+ 4611              SET_PT: ;init CTC CH0: CH0 provides RX/TX clock to SIO port A
6255+ 4611                      ; TO0 output frequency=INPUT CLK/time constant. Time constant is set to get 16 times
6256+ 4611                      ; the requested baud rate. I.e., if bps is 19,200 then time constast is set to 6 because
6257+ 4611                      ; 1,843,200/6 = 307,200 Hz (that is 19,200 x 16)
6258+ 4611 F3                   di                      ; disable INTs
6259+ 4612 06 00                ld      B,$00           ; reset B
6260+ 4614 21 F4 46             ld      HL,CTC_CFG      ; address of first CTC divider
6261+ 4617 09                   add     HL,BC           ; adjust for correct CTC divider
6262+ 4618 0E 10                ld      C,CTC_CH0       ; CTC channel 0
6263+ 461A 3A 83 61             ld      A,(PRTNUM)      ; load port number
6264+ 461D 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6265+ 461E DA 22 46             jp      C,SET_CTC       ; port 1 => ch. 0, so continue
6266+ 4621 0C                   inc     C               ; port 2 => ch. 1, increment address port into C
6267+ 4622 3E 47        SET_CTC:ld      A,%01000111     ; interrupt off, counter mode, prsc=16 (doesn't matter), ext. start,
6268+ 4624                                              ; start upon loading time constant, time constant follows, sw reset, command word
6269+ 4624 ED 79                out     (C),A           ; configure CTC channel
6270+ 4626 7E                   ld      A,(HL)          ; load CTC divider
6271+ 4627 ED 79                out     (C),A           ; send divider
6272+ 4629                      ; configure SIO
6273+ 4629 21 36 03             ld      HL,SIO_A_SETS   ; load default settings for SIO
6274+ 462C 11 89 61             ld      DE,SIOBFR       ; into a temp buffer
6275+ 462F 01 0A 00             ld      BC,$000A        ; 10 items to copy
6276+ 4632 ED B0                ldir                    ; copy SIO settings into TEMP buffer
6277+ 4634 3A 8E 61             ld      A,(SIOBFR+5)    ; load WR5 setting
6278+ 4637 47                   ld      B,A             ; move it into B
6279+ 4638 3A 86 61             ld      A,(DATABT)      ; load DATA bits
6280+ 463B FE 05                cp      $05             ; is it 5 bits?
6281+ 463D 20 06                jr      NZ,BITS6        ; no, jump over
6282+ 463F CB B0                res     6,B
6283+ 4641 CB A8                res     5,B             ; set D6 & D5 to 0
6284+ 4643 18 19                jr      SETPAR          ; jump to set parity
6285+ 4645 FE 06        BITS6:  cp      $06             ; is it 6 bits?
6286+ 4647 20 06                jr      NZ,BITS7        ; no, jump over
6287+ 4649 CB F0                set     6,B
6288+ 464B CB A8                res     5,B             ; set D6 & D5 to 1,0
6289+ 464D 18 0F                jr      SETPAR          ; jump to set parity
6290+ 464F FE 07        BITS7:  cp      $07             ; is it 7 bits?
6291+ 4651 20 07                jr      NZ,BITS8        ; no, jump over
6292+ 4653 CB B0                res     6,B
6293+ 4655 CB E8                set     5,B             ; set D6 & D5 to 0,1
6294+ 4657 C3 5E 46             jp      SETPAR          ; jump to set parity
6295+ 465A CB F0        BITS8:  set     6,B
6296+ 465C CB E8                set     5,B             ; set D6 & D5 to 1,1
6297+ 465E 21 BE 61     SETPAR: ld      HL,SERABITS     ; load address for storing data bits
6298+ 4661 3A 83 61             ld      A,(PRTNUM)      ; check serial port number
6299+ 4664 3D                   dec     A               ; is it port #1?
6300+ 4665 CA 69 46             jp      Z,SETPAR2       ; yes, jump over
6301+ 4668 23                   inc     HL              ; port #2, use SERBBITS instead
6302+ 4669 78           SETPAR2:ld      A,B             ; retrieve DATA bits
6303+ 466A 32 8E 61             ld      (SIOBFR+5),A    ; save DATA bits
6304+ 466D E6 60                and     %01100000       ; filter only D5&D6 bits
6305+ 466F 87                   add     A,A             ; shift left times 1
6306+ 4670 77                   ld      (HL),A          ; store for SIO_EI & SIO_DI functions
6307+ 4671 3A 88 61             ld      A,(STPBT)       ; load STOP bits
6308+ 4674 87                   add     A,A
6309+ 4675 87                   add     A,A             ; 2 left shifts
6310+ 4676 47                   ld      B,A             ; move forming byte into B
6311+ 4677 3A 87 61             ld      A,(PARBT)       ; load PARITY setting
6312+ 467A A7                   and     A               ; is it 0?
6313+ 467B CA 86 46             jp      Z,STRPAR        ; yes, jump over
6314+ 467E CB C0                set     0,B             ; set PARITY on
6315+ 4680 3D                   dec     A               ; is parity ODD?
6316+ 4681 CA 86 46             jp      Z,STRPAR        ; yes, so jump over
6317+ 4684 CB C8                set     1,B             ; no, it's EVEN so set the corresponding bit
6318+ 4686 3A 8C 61     STRPAR: ld      A,(SIOBFR+3)    ; load WR4 setting
6319+ 4689 E6 F0                and     %11110000       ; reset STOP & PARITY bits
6320+ 468B B0                   or      B               ; set new STOP & PARITY bits
6321+ 468C 32 8C 61             ld      (SIOBFR+3),A    ; store new value
6322+ 468F                      ;set up TX and RX:
6323+ 468F                      ; the followings are settings for channel A
6324+ 468F 21 89 61             ld      HL,SIOBFR       ; settings for SIO ch. A
6325+ 4692 06 06                ld      B,$06           ; 6 bytes to send
6326+ 4694 0E 22                ld      C,SIO_CA        ; I/O address of SIO ch.A
6327+ 4696 3A 83 61             ld      A,(PRTNUM)      ; load port number
6328+ 4699 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6329+ 469A DA 9E 46             jp      C,SRLCNT        ; port 1, continue
6330+ 469D 0C                   inc     C               ; port 2, increment address port into C
6331+ 469E ED B3        SRLCNT: otir                    ; send bytes to SIO
6332+ 46A0                      ; the following are settings for channel B (don't need to load HL since settings are contigous)
6333+ 46A0 06 04                ld      B,$04           ; other 4 bytes to send
6334+ 46A2 51                   ld      D,C             ; store port address into D
6335+ 46A3 0E 23                ld      C,SIO_CB        ; I/O address of SIO ch.B
6336+ 46A5 ED B3                otir                    ; send bytes to SIO
6337+ 46A7                      ; the following are settings for selected channel
6338+ 46A7 3E 01                ld      A,$01           ; write into WR0: select WR1
6339+ 46A9 4A                   ld      C,D             ; retrieve port address
6340+ 46AA ED 79                out     (C),A
6341+ 46AC 3E 18                ld      A,%00011000     ; interrupts on every RX char; parity is no special condition;
6342+ 46AE                                              ; buffer overrun is special condition
6343+ 46AE ED 79                out     (C),A
6344+ 46B0 21 BD 61             ld      HL,SERIALS_EN
6345+ 46B3 3A 83 61             ld      A,(PRTNUM)      ; retrieve serial channel
6346+ 46B6 3D                   dec     A               ; channel A?
6347+ 46B7 20 10                jr      NZ,ENCHB        ; no, jump over
6348+ 46B9 CD E3 01             call    SIO_A_EI        ; enable RX on SIO channel A
6349+ 46BC CB C6                set     0,(HL)          ; set serial port 1 status ON
6350+ 46BE CB D6                set     2,(HL)          ; set serial port 1 RX ON
6351+ 46C0                      ; back to normal running
6352+ 46C0 FB                   ei                      ; re-enable INTs
6353+ 46C1 DB 01                in      A,(PIO_DB)      ; load status LEDs
6354+ 46C3 CB F7                set     6,A             ; set status LED on
6355+ 46C5 CB A7                res     4,A             ; set error LED off
6356+ 46C7 18 0E                jr      EXNRM           ; leave
6357+ 46C9 CD EB 01     ENCHB:  call    SIO_B_EI        ; enable RX on SIO channel B
6358+ 46CC CB CE                set     1,(HL)          ; set serial port 2 status ON
6359+ 46CE CB DE                set     3,(HL)          ; set serial port 2 RX ON
6360+ 46D0                      ; back to normal running
6361+ 46D0 FB                   ei                      ; re-enable INTs
6362+ 46D1 DB 01                in      A,(PIO_DB)      ; load status LEDs
6363+ 46D3 CB FF                set     7,A             ; set status LED on
6364+ 46D5 CB AF                res     5,A             ; set error LED off
6365+ 46D7 D3 01        EXNRM:  out     (PIO_DB),A      ; send new configuration
6366+ 46D9 DD E1                pop     IX              ; retrieve IX
6367+ 46DB D1                   pop     DE              ; retrieve DE
6368+ 46DC E1                   pop     HL              ; retrieve HL
6369+ 46DD C9                   ret                     ; return to caller
6370+ 46DE
6371+ 46DE              ; allowed bps (Bauds per second)
6372+ 46DE 00 E1 00 96  SUP_BPS:defw    57600,38400,28800,19200,14400,9600,4800,3600,2400,1200,600
6372+ 46E2 80 70 00 4B
6372+ 46E6 40 38 80 25
6372+ 46EA C0 12 10 0E
6372+ 46EE 60 09 B0 04
6372+ 46F2 58 02
6373+ 46F4              ; corresponding CTC divider
6374+ 46F4 02 03 04 06  CTC_CFG:defb    2,3,4,6,8,12,24,32,48,96,192
6374+ 46F8 08 0C 18 20
6374+ 46FC 30 60 C0
6375+ 46FF
6376+ 46FF
6377+ 46FF              ; serial configuration error
6378+ 46FF DD E1        SCERR1: pop     IX              ; retrieve IX
6379+ 4701 D1                   pop     DE              ; retrieve DE
6380+ 4702 E1                   pop     HL              ; retrieve HL
6381+ 4703 1E 2C        SCERR:  ld      E,SC            ; Serial Configuration Error
6382+ 4705 C3 B8 20             jp      ERROR           ; print error
6383+ 4708
6384+ 4708
6385+ 4708              ; serial buffer overrun
6386+ 4708 CD B4 28     SOERR:  call    PRNTCRLF
6387+ 470B 1E 30                ld      E,SO            ; Serial Buffer Overrun
6388+ 470D C3 B8 20             jp      ERROR
6389+ 4710
6390+ 4710
6391+ 4710              ; check for direct mode:
6392+ 4710              ; Z is set if in direct mode, reset otherwise
6393+ 4710 E5           DIRMOD: push    HL              ; Save code string address
6394+ 4711 2A 24 60             ld      HL,(LINEAT)     ; Get current line number
6395+ 4714 23                   inc     HL              ; -1 means direct statement
6396+ 4715 7C                   ld      A,H
6397+ 4716 B5                   or      L
6398+ 4717 E1                   pop     HL              ; Restore code string address
6399+ 4718 C9                   ret
6400+ 4719
6401+ 4719
6402+ 4719              ; HELP lists the line program where an error occured
6403+ 4719 CD 10 47     HELP:   call    DIRMOD          ; check if in direct mode
6404+ 471C C2 32 47             jp      NZ,HLPERR       ; raise error if in indirect mode
6405+ 471F E5                   push    HL              ; store HL
6406+ 4720 2A 26 60             ld      HL,(HLPLN)      ; load HELP line
6407+ 4723 23                   inc     HL              ; increment HL
6408+ 4724 7C                   ld      A,H
6409+ 4725 B5                   or      L               ; check if there is a line into the HELP reg.
6410+ 4726 E1                   pop     HL
6411+ 4727 CA 32 47             jp      Z,HLPERR        ; no line found, raise error
6412+ 472A ED 5B 26 60          ld      DE,(HLPLN)      ; recover line
6413+ 472E C1                   pop     BC              ; remove BC from stack since it's not needed anymore for LIST
6414+ 472F C3 34 24             jp      LST01H          ; jump to list line
6415+ 4732 1E 32        HLPERR: ld      E,HP            ; HELP call error
6416+ 4734 C3 B8 20             jp      ERROR           ; raise error
6417+ 4737
6418+ 4737
6419+ 4737              ; KEY command to list/modify function keys and auto-repeat
6420+ 4737 2B           KEY:    dec     HL              ; dec 'cos GETCHR INCs
6421+ 4738 CD E7 25             call    GETCHR          ; Get next character
6422+ 473B CA BB 47             jp      Z,LSTKEYS       ; jump if nothing follows
6423+ 473E                      ; change FN keys
6424+ 473E CD FE 32             call    GETINT          ; get a number
6425+ 4741 A7                   and     A               ; is it 0?
6426+ 4742 20 10                jr      NZ,KEYCH        ; no, jump over
6427+ 4744 E5           RESFN:  push    HL              ; yes - reset FN keys to defaults
6428+ 4745 D5                   push    DE              ; store HL & DE
6429+ 4746 21 8C 1F             ld      HL,AUTORP       ; pointer to default auto-repeat delays and FN keys texts
6430+ 4749 11 28 60             ld      DE,KEYDEL       ; pointer to destination
6431+ 474C 01 82 00             ld      BC,$0082        ; 130 chars to be copied (2xauto-delay, 128xFN keys)
6432+ 474F ED B0                ldir                    ; restore default texts
6433+ 4751 D1                   pop     DE              ; retrieve DE
6434+ 4752 E1                   pop     HL              ; retrieve HL
6435+ 4753 C9                   ret                     ; return to caller
6436+ 4754 FE 09        KEYCH:  cp      $09             ; is it >= 9?
6437+ 4756 D2 6E 48             jp      NC,SETREP       ; yes - jump over
6438+ 4759 3D                   dec     A               ; FN key in range 0~7
6439+ 475A 87                   add     A,A             ; multiply A...
6440+ 475B 87                   add     A,A             ; ... times 4...
6441+ 475C 87                   add     A,A             ; ... to get the correct...
6442+ 475D 87                   add     A,A             ; ... offset fo FN key text
6443+ 475E 32 7B 61             ld      (TMPBFR1),A     ; store FN key offset...
6444+ 4761 AF                   xor     A               ; ...in a...
6445+ 4762 32 7C 61             ld      (TMPBFR1+1),A   ; ...16-bit register
6446+ 4765 CD 9E 23             call    CHKSYN          ; Make sure ',' follows
6447+ 4768 2C                   defb    ','
6448+ 4769 44 4D                ld      BC,HL           ; copy address into BC
6449+ 476B CD 8A 2A             call    EVAL            ; Evaluate expression (in E there is the length)
6450+ 476E E5                   push    HL              ; store string pointer
6451+ 476F 3A 09 61             ld      A,(TYPE)        ; Get variable type
6452+ 4772 B7                   or      A               ; Is it a string variable?
6453+ 4773 CA 9E 20             jp      Z,SNERR         ; no - syntax error
6454+ 4776 CD C3 30             call    GSTRCU          ; Current string to pool
6455+ 4779 CD D4 38             call    LOADFP          ; Move string block data to (BC=pointer, DE=length)
6456+ 477C 7B                   ld      A,E             ; copy length into A
6457+ 477D FE 11                cp      $11             ; is length > 16?
6458+ 477F DA 84 47             jp      C,DECLN1        ; no, jump over
6459+ 4782 1E 10                ld      E,$10           ; yes, so set length to 16
6460+ 4784 3E 10        DECLN1: ld      A,$10           ; calculate how many...
6461+ 4786 93                   sub     E               ; ...null chars needed to fill up...
6462+ 4787 57                   ld      D,A             ; ...the FN key text
6463+ 4788 C5                   push    BC              ; store address of string
6464+ 4789 ED 4B 7B 61          ld      BC,(TMPBFR1)    ; load FN key offset
6465+ 478D 21 2A 60             ld      HL,FNKEYS       ; load address of FN keys texts
6466+ 4790 09                   add     HL,BC           ; get corrected address
6467+ 4791 C1                   pop     BC              ; retrieve address of string chars
6468+ 4792 0A           CPKEY:  ld      A,(BC)          ; load char from string
6469+ 4793 FE 0D                cp      CR              ; return?
6470+ 4795 CA A2 47             jp      Z,CPKEY2        ; yes, store char
6471+ 4798 FE 7B                cp      $7B             ; if char > "z" ?
6472+ 479A D2 9E 20             jp      NC,SNERR        ; yes - syntax error
6473+ 479D FE 20                cp      $20             ; is char < space?
6474+ 479F DA 9E 20             jp      C,SNERR         ; yes - syntax error
6475+ 47A2 FE 61        CPKEY2: cp      $61             ; is it >= 'a'?
6476+ 47A4 DA A9 47             jp      C,CPKEY3        ; no, continue
6477+ 47A7 E6 5F                and     %01011111       ; set letters to uppercase
6478+ 47A9 77           CPKEY3: ld      (HL),A          ; store char
6479+ 47AA 23                   inc     HL              ; next string char
6480+ 47AB 03                   inc     BC              ; next free cell
6481+ 47AC 1D                   dec     E               ; decrement E
6482+ 47AD 20 E3                jr      NZ,CPKEY        ; repeat until 0
6483+ 47AF AF                   xor     A               ; null char
6484+ 47B0 14                   inc     D               ; +1 to decrement below
6485+ 47B1 15           CPKEY1: dec     D               ; how many null chars to insert?
6486+ 47B2 CA B9 47             jp      Z,CPKYEND       ; no more nulls, so exit
6487+ 47B5 77                   ld      (HL),A          ; store it
6488+ 47B6 23                   inc     HL              ; next cell
6489+ 47B7 18 F8                jr      CPKEY1          ; repeat
6490+ 47B9 E1           CPKYEND:pop     HL              ; retrieve pointer to string
6491+ 47BA C9                   ret                     ; return to caller
6492+ 47BB                                              ; list FN keys
6493+ 47BB E5           LSTKEYS:push    HL              ; Save code string address
6494+ 47BC 2A 24 60             ld      HL,(LINEAT)     ; Get current line number
6495+ 47BF 23                   inc     HL              ; -1 means direct statement
6496+ 47C0 7C                   ld      A,H
6497+ 47C1 B5                   or      L
6498+ 47C2 E1                   pop     HL              ; Restore code string address
6499+ 47C3 C2 9E 20             jp      NZ,SNERR        ; raise error if in indirect mode
6500+ 47C6 E5                   push    HL              ; store HL
6501+ 47C7 D5                   push    DE              ; store DE
6502+ 47C8 21 2A 60             ld      HL,FNKEYS       ; load starting address of FN keys text
6503+ 47CB 0E 01                ld      C,$01           ; 8 function keys
6504+ 47CD 06 10        PRTK4:  ld      B,$10           ; 16 chars each
6505+ 47CF 11 90 48     PRTK2:  ld      DE,CHKEY1       ; message "KEY "
6506+ 47D2 CD 5F 48             call    PRTCKEY         ; print it
6507+ 47D5 79                   ld      A,C             ; load FN key
6508+ 47D6 C6 30                add     $30             ; get number in ASCI code
6509+ 47D8 CD A9 23             call    OUTC            ; print it
6510+ 47DB 11 95 48             ld      DE,CHKEY2       ; message ": ""
6511+ 47DE CD 5F 48             call    PRTCKEY         ; print it
6512+ 47E1 3E 01                ld      A,$01           ; " opened
6513+ 47E3 32 7B 61             ld      (TMPBFR1),A
6514+ 47E6 7E           LDKEY:  ld      A,(HL)          ; retrieve char
6515+ 47E7 A7                   and     A               ; is it zero?
6516+ 47E8 CA FB 47             jp      Z,CNTLTK        ; yes, go next char
6517+ 47EB CD 47 48             call    OPNQT           ; check if quotes are opened
6518+ 47EE FE 22                cp      $22             ; check if char is "?
6519+ 47F0 CA 10 48             jp      Z,PRTCHR        ; yes, print "chr$("
6520+ 47F3 FE 0D                cp      CR              ; is it a CR?
6521+ 47F5 CA 10 48             jp      Z,PRTCHR        ; yes, print "chr$("
6522+ 47F8 CD A9 23     PRTK3:  call    OUTC            ; no, just print it
6523+ 47FB 23           CNTLTK: inc     HL              ; next char
6524+ 47FC 10 E8                djnz    LDKEY           ; continue until finished
6525+ 47FE CD 35 48             call    CLSQT           ; check if quotes are still open
6526+ 4801 3E 0D                ld      A,CR            ; go next line
6527+ 4803 CD A9 23             call    OUTC            ; print it
6528+ 4806 0C                   inc     C               ; next FN key
6529+ 4807 79                   ld      A,C             ; check if...
6530+ 4808 FE 09                cp      $09             ; finished keys?
6531+ 480A DA CD 47             jp      C,PRTK4         ; no, repeat 1 more time
6532+ 480D D1                   pop     DE              ; retrieve DE
6533+ 480E E1                   pop     HL              ; retrieve HL
6534+ 480F C9                   ret                     ; return to caller
6535+ 4810 E5           PRTCHR: push    HL              ; store HL
6536+ 4811 CD 35 48             call    CLSQT           ; check if quotes are closed
6537+ 4814 3E 2B                ld      A,'+'           ; '+' char
6538+ 4816 CD A9 23             call    OUTC            ; print it
6539+ 4819 11 98 48             ld      DE,CHKEY3       ; address of "CHR$("
6540+ 481C CD 5F 48             call    PRTCKEY         ; print it
6541+ 481F E1                   pop     HL              ; recover HL
6542+ 4820 23                   inc     HL              ; next char
6543+ 4821 05                   dec     B               ; increment char counter
6544+ 4822 11 9E 48             ld      DE,CHKEY4       ; load address of RETURN
6545+ 4825 7E                   ld      A,(HL)          ; load char
6546+ 4826 FE 0D                cp      CR              ; is it a RETURN?
6547+ 4828 20 03                jr      NZ,PTCHR1       ; no, jump over
6548+ 482A 11 A1 48             ld      DE,CHKEY5       ; yes, load address of "
6549+ 482D CD 5F 48     PTCHR1: call    PRTCKEY         ; print it
6550+ 4830 3E 29                ld      A,')'           ; char )
6551+ 4832 C3 F8 47             jp      PRTK3           ; continue
6552+ 4835 F5           CLSQT:  push    AF              ; store A
6553+ 4836 3A 7B 61             ld      A,(TMPBFR1)     ; quote status
6554+ 4839 A7                   and     A               ; are they closed?
6555+ 483A 28 09                jr      Z,CLSQT1        ; if yes, return
6556+ 483C 3E 22                ld      A,$22           ; no, so close them
6557+ 483E CD A9 23             call    OUTC            ; print "
6558+ 4841 AF                   xor     A               ; set quotes
6559+ 4842 32 7B 61             ld      (TMPBFR1),A     ; as closed
6560+ 4845 F1           CLSQT1: pop     AF              ; retrieve A
6561+ 4846 C9                   ret                     ; return to caller
6562+ 4847 F5           OPNQT:  push    AF              ; store A
6563+ 4848 3A 7B 61             ld      A,(TMPBFR1)     ; quote status
6564+ 484B A7                   and     A               ; are they open?
6565+ 484C 20 0F                jr      NZ,OPNQT1       ; if yes, return
6566+ 484E 3E 2B                ld      A,'+'           ; no, so add '+
6567+ 4850 CD A9 23             call    OUTC            ; print it
6568+ 4853 3E 22                ld      A,$22           ; and then open quotes
6569+ 4855 CD A9 23             call    OUTC            ; print them
6570+ 4858 3E 01                ld      A,$01           ; set quotes
6571+ 485A 32 7B 61             ld      (TMPBFR1),A     ; as opened
6572+ 485D F1           OPNQT1: pop     AF              ; retrieve A
6573+ 485E C9                   ret                     ; return to caller
6574+ 485F F5           PRTCKEY:push    AF              ; store original char
6575+ 4860 1A           PRTK1:  ld      A,(DE)          ; load char
6576+ 4861 A7                   and     A               ; is it 0?
6577+ 4862 CA 6C 48             jp      Z,PRTEND        ; yes, finished printing
6578+ 4865 CD A9 23             call    OUTC            ; no, print char
6579+ 4868 13                   inc     DE              ; next char
6580+ 4869 C3 60 48             jp      PRTK1           ; repeat
6581+ 486C F1           PRTEND: pop     AF              ; retrieve AF
6582+ 486D C9                   ret                     ; return to caller
6583+ 486E FE 09        SETREP: cp      $09             ; is it special key 9? (stands for auto-repeat)
6584+ 4870 C2 9E 20             jp      NZ,SNERR        ; no, raise an error
6585+ 4873 CD 9E 23             call    CHKSYN          ; Check for comma
6586+ 4876 2C                   defb    ','
6587+ 4877 CD FE 32             call    GETINT          ; get a number
6588+ 487A 32 7B 61             ld      (TMPBFR1),A     ; store it
6589+ 487D CD 9E 23             call    CHKSYN          ; Check for comma
6590+ 4880 2C                   defb    ','
6591+ 4881 CD FE 32             call    GETINT          ; get another number
6592+ 4884 E5                   push    HL              ; store HL
6593+ 4885 21 29 60             ld      HL,AUTOKE       ; address of second cell for key auto-repeat
6594+ 4888 77                   ld      (HL),A          ; store auto-repeat delay
6595+ 4889 2B                   dec     HL              ; previous cell
6596+ 488A 3A 7B 61             ld      A,(TMPBFR1)     ; retrieve value
6597+ 488D 77                   ld      (HL),A          ; store delay for auto-repeat
6598+ 488E E1                   pop     HL              ; retrieve HL
6599+ 488F C9                   ret
6600+ 4890 4B 45 59 20  CHKEY1: defb    "KEY ",0
6600+ 4894 00
6601+ 4895 3A 22 00     CHKEY2: defb    ":",34,0
6602+ 4898 63 68 72 24  CHKEY3: defb    "chr$(",0
6602+ 489C 28 00
6603+ 489E 31 33 00     CHKEY4: defb    "13",0
6604+ 48A1 33 34 00     CHKEY5: defb    "34",0
6605+ 48A4
6606+ 48A4
6607+ 48A4              ; check if DOS is enabled
6608+ 48A4 3A C0 61     CHKDOS: ld      A,(DOS_EN)      ; load DOS state
6609+ 48A7 A7                   and     A               ; check if 0 (NOT enabled)
6610+ 48A8 C0                   ret     NZ              ; return if enabled
6611+ 48A9 1E 38                ld      E,D0            ; DOS not enabled error
6612+ 48AB C3 B8 20             jp      ERROR           ; raise error
6613+ 48AE
6614+ 48AE
6615+ 48AE              ; LOAD "filename"[,1]  <- load a BASIC program from disk
6616+ 48AE              ; LOAD x,y,w,z         <- load a sector from disc, LBA address equals to ((((z*256)+w)*256)+y)*256)+x
6617+ 48AE CD A4 48     LOAD:   call    CHKDOS          ; check if DOS is enabled
6618+ 48B1 CD 04 49             call    LDSVPT          ; check if in direct mode and what's following
6619+ 48B4 CA D2 48             jp      Z,LOADST        ; number - load a single sector
6620+ 48B7 CD 10 47             call    DIRMOD          ; a file can be loaded ONLY in direct mode
6621+ 48BA C2 B3 20             jp      NZ,IMERR        ; raise error if in indirect mode
6622+ 48BD CD FD 4B             call    CHKFN1          ; string - evaluate file name
6623+ 48C0 CD 3D 4A             call    CHK1AR          ; check for ",1" argument
6624+ 48C3 22 7B 61             ld      (TMPBFR1),HL    ; store HL
6625+ 48C6 21 F3 48             ld      HL,TXTLDG       ; loading message
6626+ 48C9 CD 80 2F             call    PRS             ; print
6627+ 48CC CD 88 15             call    LODFILE         ; load file into memory
6628+ 48CF C3 E7 48             jp      LDEND           ; retrieve registers and leave
6629+ 48D2 2A 7B 61     LOADST: ld      HL,(TMPBFR1)    ; retrieve HL
6630+ 48D5 CD 19 49             call    GET4AR          ; get 4 arguments
6631+ 48D8 22 7B 61             ld      (TMPBFR1),HL    ; store HL
6632+ 48DB CD 4B 10             call    CF_SETSTR       ; set sector
6633+ 48DE CD 8D 10             call    CF_RD_SEC       ; read sector
6634+ 48E1 38 0B                jr      C,LDERR
6635+ 48E3 CD 81 10             call    CF_STANDBY      ; put CF in standby mode
6636+ 48E6 AF                   xor     A               ; clear Carry
6637+ 48E7 2A 7B 61     LDEND:  ld      HL,(TMPBFR1)    ; retrieve HL
6638+ 48EA DA 36 4A             jp      C,DOS_ERR       ; jump if DOS error
6639+ 48ED C9                   ret                     ; return to caller
6640+ 48EE 1E 40        LDERR:  ld      E,D4            ; load error
6641+ 48F0 C3 B8 20             jp      ERROR
6642+ 48F3 4C 6F 61 64  TXTLDG: defb    "Loading file... ",0
6642+ 48F7 69 6E 67 20
6642+ 48FB 66 69 6C 65
6642+ 48FF 2E 2E 2E 20
6642+ 4903 00
6643+ 4904
6644+ 4904
6645+ 4904              ; common code for LOAD/SAVE to check the type of operation required
6646+ 4904              ; (load/save a file or a single sector)
6647+ 4904              ; returns Z if argument is a number, NZ if it's a string
6648+ 4904 CD A4 48     LDSVPT: call    CHKDOS          ; check if DOS is enabled
6649+ 4907 2B                   dec     HL              ; dec 'cos GETCHR INCs
6650+ 4908 CD E7 25             call    GETCHR          ; check if something follows
6651+ 490B CA 9E 20             jp      Z,SNERR         ; if anything else, raise a syntax error
6652+ 490E 22 7B 61             ld      (TMPBFR1),HL    ; save current code string pointer
6653+ 4911 CD 8A 2A             call    EVAL            ; Evaluate expression
6654+ 4914 3A 09 61             ld      A,(TYPE)        ; Get variable type
6655+ 4917 B7                   or      A               ; Is it a string variable?
6656+ 4918 C9                   ret                     ; return to caller
6657+ 4919
6658+ 4919
6659+ 4919              ; shared code between LOAD and SAVE
6660+ 4919              ; get 4 arguments after the command LOAD or SAVE
6661+ 4919              ; and load them into appropriate registers
6662+ 4919 2A 7B 61     GET4AR: ld      HL,(TMPBFR1)    ; retrieve string code pointer
6663+ 491C CD FE 32             call    GETINT          ; get 1st pointer
6664+ 491F 32 12 61             ld      (TMPDBF),A      ; store it into a temp buffer
6665+ 4922 CD 9E 23             call    CHKSYN          ; Make sure ',' follows
6666+ 4925 2C                   defb    ','
6667+ 4926 CD FE 32             call    GETINT          ; get 2nd pointer
6668+ 4929 32 13 61             ld      (TMPDBF+1),A    ; store it into a temp buffer
6669+ 492C CD 9E 23             call    CHKSYN          ; Make sure ',' follows
6670+ 492F 2C                   defb    ','
6671+ 4930 CD FE 32             call    GETINT          ; get 3rd pointer
6672+ 4933 32 14 61             ld      (TMPDBF+2),A    ; store it into a temp buffer
6673+ 4936 CD 9E 23             call    CHKSYN          ; Make sure ',' follows
6674+ 4939 2C                   defb    ','
6675+ 493A CD FE 32             call    GETINT          ; get 4th pointer
6676+ 493D 57                   ld      D,A             ; store it
6677+ 493E 3A 12 61             ld      A,(TMPDBF)      ; retrieve 1st pointer
6678+ 4941 4F                   ld      C,A
6679+ 4942 3A 13 61             ld      A,(TMPDBF+1)    ; retrieve 2nd pointer
6680+ 4945 47                   ld      B,A
6681+ 4946 3A 14 61             ld      A,(TMPDBF+2)    ; retrieve 3rd pointer
6682+ 4949 5F                   ld      E,A
6683+ 494A CD 09 10             call    CF_INIT         ; init CF card
6684+ 494D DA B6 20             jp      C,NRERR         ; error if device not available/ready
6685+ 4950 C9                   ret                     ; return to caller
6686+ 4951
6687+ 4951
6688+ 4951              ; save a file onto the disk
6689+ 4951              ; syntax: save "filename" to save a BASIC program
6690+ 4951              ; save x,y,z to save IO buffer into x-y-z sector
6691+ 4951              ; save "filename",start,end to save a portion of memory
6692+ 4951 CD A4 48     SAVE:   call    CHKDOS          ; check if DOS is enabled
6693+ 4954 2B                   dec     HL              ; dec 'cos GETCHR INCs
6694+ 4955 CD E7 25             call    GETCHR          ; check if something follows
6695+ 4958 CA 9E 20             jp      Z,SNERR         ; if nothing else, raise a syntax error
6696+ 495B 22 7B 61             ld      (TMPBFR1),HL    ; save current code string pointer
6697+ 495E CD 8A 2A             call    EVAL            ; Evaluate expression
6698+ 4961 3A 09 61             ld      A,(TYPE)        ; Get variable type
6699+ 4964 B7                   or      A               ; Is it a string variable?
6700+ 4965 CA C3 49             jp      Z,SAVESCT       ; no - save a single sector
6701+ 4968 CD FD 4B             call    CHKFN1          ; yes, load string name
6702+ 496B ED 53 81 61          ld      (TMPBFR4),DE    ; store lenght into another buffer
6703+ 496F ED 43 2B 61          ld      (TPBF4+2),BC    ; store address into another buffer
6704+ 4973 3E 80                ld      A,$80           ; set BAS as file type
6705+ 4975 32 29 61             ld      (TPBF4),A
6706+ 4978 2B                   dec     HL              ; dec 'cos GETCHR INCs
6707+ 4979 CD E7 25             call    GETCHR          ; check if something follows
6708+ 497C 28 30                jr      Z,SAVE1         ; no, jump over
6709+ 497E CD 9E 23             call    CHKSYN          ; yes - Make sure ',' follows
6710+ 4981 2C                   defb    ','
6711+ 4982 22 12 61             ld      (TMPDBF),HL     ; store code string pointer
6712+ 4985 CD 8A 2A             call    EVAL            ; check expression
6713+ 4988 2A 12 61             ld      HL,(TMPDBF)     ; point back to the beginning of epression
6714+ 498B 3A 09 61             ld      A,(TYPE)        ; check result type
6715+ 498E B7                   or      A               ; is it another string?
6716+ 498F 20 4B                jr      NZ,RENFIL       ; yes, jump to rename file
6717+ 4991 CD 78 2A             call    GETNUM          ; no, this is the memory address for a BIN file
6718+ 4994 CD 9D 26             call    DEINT           ; Get integer -32768 to 32767
6719+ 4997 ED 53 2B 61          ld      (SRTMEM),DE     ; Store DE into a temp. buffer
6720+ 499B CD 9E 23             call    CHKSYN          ; Make sure ',' follows
6721+ 499E 2C                   defb    ','
6722+ 499F CD 78 2A             call    GETNUM          ; Get memory address
6723+ 49A2 CD 9D 26             call    DEINT           ; Get integer -32768 to 32767
6724+ 49A5 ED 53 2D 61          ld      (ENDMEM),DE     ; Store DE into a temp. buffer
6725+ 49A9 3E 81                ld      A,$81           ; set BIN for file type
6726+ 49AB 32 29 61             ld      (TPBF4),A
6727+ 49AE CD 10 47     SAVE1:  call    DIRMOD          ; can be executed ONLY in direct mode
6728+ 49B1 C2 B3 20             jp      NZ,IMERR        ; raise error if in indirect mode
6729+ 49B4 22 7B 61             ld      (TMPBFR1),HL    ; store code string pointer
6730+ 49B7 21 0F 4A             ld      HL,TXTSVG       ; loading message
6731+ 49BA CD 80 2F             call    PRS             ; print
6732+ 49BD CD C4 13             call    SAVFILE         ; load file into memory
6733+ 49C0 C3 D5 49             jp      SVEND           ; retrieve registers and leave
6734+ 49C3                      ;save a single sector
6735+ 49C3 2A 12 61     SAVESCT:ld      HL,(TMPDBF)     ; retrieve string code pointer
6736+ 49C6 CD 19 49             call    GET4AR          ; get 4 arguments
6737+ 49C9 22 7B 61             ld      (TMPBFR1),HL    ; store code string pointer
6738+ 49CC CD B4 10             call    CF_WR_SEC       ; read sector
6739+ 49CF 38 39                jr      C,SVERR
6740+ 49D1 CD 81 10             call    CF_STANDBY      ; put CF in standby mode
6741+ 49D4 AF                   xor     A               ; clear Carry
6742+ 49D5 2A 7B 61     SVEND:  ld      HL,(TMPBFR1)    ; retrieve code string pointer
6743+ 49D8 DA 36 4A             jp      C,DOS_ERR       ; jump if DOS error
6744+ 49DB C9                   ret                     ; return to caller
6745+ 49DC CD C3 30     RENFIL: call    GSTRCU          ; check that a string follows
6746+ 49DF CD D4 38             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
6747+ 49E2 ED 53 1A 61          ld      (BYT_SIZ),DE    ; store values into
6748+ 49E6 ED 43 21 61          ld      (RAM_PTR),BC    ; temp buffers
6749+ 49EA E5                   push    HL              ; store code string pointer
6750+ 49EB 21 F9 49             ld      HL,TXTRNM       ; point to "renaming file"
6751+ 49EE CD 80 2F             call    PRS             ; print string
6752+ 49F1 CD F2 14             call    CHNGNAM         ; rename file
6753+ 49F4 E1                   pop     HL              ; retrieve code string pointer
6754+ 49F5 DA 36 4A             jp      C,DOS_ERR       ; any error?
6755+ 49F8 C9                   ret                     ; return to caller
6756+ 49F9 52 65 6E 61  TXTRNM: defb    "Renaming file...",0
6756+ 49FD 6D 69 6E 67
6756+ 4A01 20 66 69 6C
6756+ 4A05 65 2E 2E 2E
6756+ 4A09 00
6757+ 4A0A 1E 3E        SVERR:  ld      E,D3            ; save error
6758+ 4A0C C3 B8 20             jp      ERROR
6759+ 4A0F 53 61 76 69  TXTSVG: defb    "Saving file... ",0
6759+ 4A13 6E 67 20 66
6759+ 4A17 69 6C 65 2E
6759+ 4A1B 2E 2E 20 00
6760+ 4A1F
6761+ 4A1F
6762+ 4A1F              ; FILES
6763+ 4A1F              ; list files on disk
6764+ 4A1F CD A4 48     FILES:  call    CHKDOS          ; check if DOS is enabled
6765+ 4A22 CD C5 18             call    CLRIOBF         ; clear I/O buffer
6766+ 4A25 CD 09 10             call    CF_INIT         ; init CF card
6767+ 4A28 DA 36 4A             jp      C,DOS_ERR       ; error if device not available/ready
6768+ 4A2B E5                   push    HL              ; store code string pointer
6769+ 4A2C 16 01                ld      D,$01           ; print disk details and file list
6770+ 4A2E CD 99 12             call    LST_FILES       ; list files
6771+ 4A31 E1                   pop     HL              ; retrieve code string pointer
6772+ 4A32 DA 36 4A             jp      C,DOS_ERR       ; any error?
6773+ 4A35 C9                   ret                     ; return to caller
6774+ 4A36
6775+ 4A36
6776+ 4A36              ; raise a DOS error
6777+ 4A36 3A 11 61     DOS_ERR:ld      A,(DOSER)       ; load error code
6778+ 4A39 5F                   ld      E,A             ; copy into E
6779+ 4A3A C3 B8 20             jp      ERROR           ; goto error routine
6780+ 4A3D
6781+ 4A3D
6782+ 4A3D              ; check for ",1" argument
6783+ 4A3D              ; check if 1 is passed as argument after LOAD and ERASE
6784+ 4A3D AF           CHK1AR: xor     A               ; reset A
6785+ 4A3E 32 29 61             ld      (TPBF4),A       ; default setting
6786+ 4A41                                              ; (load=store file in RAM using current BASIC pointers
6787+ 4A41                                              ; (erase=quick delete)
6788+ 4A41 2B                   dec     HL              ; dec 'cause GETCHR increments
6789+ 4A42 CD E7 25             call    GETCHR          ; check if something follows
6790+ 4A45 C8                   ret     Z               ; if nothing follows, return
6791+ 4A46 CD 9E 23             call    CHKSYN          ; Make sure ',' follows
6792+ 4A49 2C                   defb    ','
6793+ 4A4A CD FE 32             call    GETINT          ; get a value
6794+ 4A4D 3D                   dec     A               ; decrement it
6795+ 4A4E C2 9E 20             jp      NZ,SNERR        ; not '1' - raise an error
6796+ 4A51 3C                   inc     A               ; A=1
6797+ 4A52 32 29 61             ld      (TPBF4),A       ; load=store file in RAM using address in file
6798+ 4A55                                              ; erase=full delete
6799+ 4A55 C9                   ret                     ; return to caller
6800+ 4A56
6801+ 4A56
6802+ 4A56              ; ERASE "filename"
6803+ 4A56              ; erase a file from disk
6804+ 4A56 CD A4 48     ERASE:  call    CHKDOS          ; check if DOS is enabled
6805+ 4A59 CD F3 4B             call    CHKFLNM         ; check for a disk name
6806+ 4A5C CD 3D 4A             call    CHK1AR          ; check for ",1" argument
6807+ 4A5F E5                   push    HL              ; store code string pointer
6808+ 4A60 21 83 4A             ld      HL,ERSTX        ; Point to message
6809+ 4A63 CD 80 2F             call    PRS             ; print message for init confirmation
6810+ 4A66 E1                   pop     HL              ; retrieve HL
6811+ 4A67 CD CE 4B             call    CNFREQ          ; ask for confirmation
6812+ 4A6A 38 33                jr      C,ABRTDS        ; if Carry set then abort
6813+ 4A6C CD 09 10             call    CF_INIT         ; init CF card
6814+ 4A6F DA 36 4A             jp      C,DOS_ERR       ; error if device not available/ready
6815+ 4A72 E5                   push    HL              ; store code string pointer
6816+ 4A73 CD 32 16             call    FIL_ERASE       ; deleted file
6817+ 4A76 E1                   pop     HL              ; retrieve code string pointer
6818+ 4A77 DA 36 4A             jp      C,DOS_ERR       ; leave if error
6819+ 4A7A E5                   push    HL              ; store HL
6820+ 4A7B 21 91 4A             ld      HL,ERASED       ; point to message of file deleted
6821+ 4A7E CD 80 2F             call    PRS             ; print it
6822+ 4A81 E1                   pop     HL              ; retrieve HL
6823+ 4A82 C9                   ret                     ; return to caller
6824+ 4A83 44 65 6C 65  ERSTX:  defb    "Delete file? ",0
6824+ 4A87 74 65 20 66
6824+ 4A8B 69 6C 65 3F
6824+ 4A8F 20 00
6825+ 4A91 46 69 6C 65  ERASED: defb    "File deleted",CR,0
6825+ 4A95 20 64 65 6C
6825+ 4A99 65 74 65 64
6825+ 4A9D 0D 00
6826+ 4A9F
6827+ 4A9F
6828+ 4A9F              ; disk operation aborted
6829+ 4A9F 3E 01        ABRTDS: ld      A,$01           ; re-enable...
6830+ 4AA1 32 77 61             ld      (PRNTVIDEO),A   ; ...print-on-video
6831+ 4AA4 E5                   push    HL              ; store code string pointer
6832+ 4AA5 21 AD 4A             ld      HL,ABRTXT       ; Point to message
6833+ 4AA8 CD 80 2F             call    PRS             ; print message for leaving init procedure
6834+ 4AAB E1                   pop     HL              ; retrieve code string pointer
6835+ 4AAC C9                   ret                     ; return to caller
6836+ 4AAD 0D 41 62 6F  ABRTXT: defb    CR,"Aborted",0
6836+ 4AB1 72 74 65 64
6836+ 4AB5 00
6837+ 4AB6
6838+ 4AB6
6839+ 4AB6               ; DISK command -------
6840+ 4AB6              ; execute several operations on a disk:
6841+ 4AB6              ; "F": format/rewrite Master Sector
6842+ 4AB6              ; "R": rename disk
6843+ 4AB6              ; syntax: DISK "arg1"[,arg2][,1]
6844+ 4AB6              TPHL:   equ     TMPDBF          ; temp. buffer for code string pointer
6845+ 4AB6 CD 10 47     DISK:   call    DIRMOD          ; can be executed ONLY in direct mode
6846+ 4AB9 C2 B3 20             jp      NZ,IMERR        ; raise error if in indirect mode
6847+ 4ABC CD A4 48             call    CHKDOS          ; check if DOS is enabled
6848+ 4ABF                      ; check first argument
6849+ 4ABF 2B                   dec     HL              ; dec 'cause GETCHR increments
6850+ 4AC0 CD E7 25             call    GETCHR          ; check if something follows
6851+ 4AC3 CA 9E 20             jp      Z,SNERR         ; if nothing else, raise a syntax error
6852+ 4AC6 CD 8A 2A             call    EVAL            ; Evaluate expression
6853+ 4AC9 CD 7C 2A             call    TSTSTR          ; Make sure it's a string
6854+ 4ACC 22 12 61             ld      (TPHL),HL       ; store code string pointer into a temp buffer
6855+ 4ACF CD C3 30             call    GSTRCU          ; check that a string follows
6856+ 4AD2 CD D4 38             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
6857+ 4AD5 7B                   ld      A,E
6858+ 4AD6 3D                   dec     A               ; lenght must be = 1
6859+ 4AD7 2A 12 61             ld      HL,(TPHL)       ; retrieve code string pointer
6860+ 4ADA C2 9E 20             jp      NZ,SNERR
6861+ 4ADD AF                   xor     A
6862+ 4ADE 32 29 61             ld      (TPBF4),A       ; set default to full format
6863+ 4AE1 0A                   ld      A,(BC)          ; load command
6864+ 4AE2 E6 5F                and     %01011111       ; Force upper case
6865+ 4AE4 FE 46                cp      'F'             ; format command?
6866+ 4AE6 CA 00 4B             jp      Z,DSKFRM        ; yes
6867+ 4AE9 FE 57                cp      'W'             ; rewrite master sector?
6868+ 4AEB CA FB 4A             jp      Z,RWMSSC        ; yes
6869+ 4AEE FE 52                cp      'R'             ; rename command?
6870+ 4AF0 CA 9C 4B             jp      Z,DSKRNM        ; yes
6871+ 4AF3 FE 55                cp      'U'             ; undelete command?
6872+ 4AF5 CA 8F 4B             jp      Z,DSKUND        ; yes
6873+ 4AF8 C3 9E 20             jp      SNERR           ; nothing more - raise a syntax error
6874+ 4AFB
6875+ 4AFB
6876+ 4AFB              ; Format disk or rewrite Master sector
6877+ 4AFB              ; syntax: DISK "F","disk name"[,1]
6878+ 4AFB              ; "disk name" is the name -> max 16 chars, allowed chars: "A" to "Z", "0" to "9","-", SPACE
6879+ 4AFB              ; ",1": just rewrite Master sector without overwriting current directory
6880+ 4AFB              ; Format: set up a fresh new file system, re-writing the Master sector and
6881+ 4AFB              ; initializing the directory
6882+ 4AFB              ; Master Sector rewriting: re-initialize the Master Sector, writing a new disk name and
6883+ 4AFB              ; re-calculating disk geometry
6884+ 4AFB              DKNMPT: equ     TMPBFR2         ; store the pointer to the disk name string
6885+ 4AFB              DKLNPT: equ     TMPBFR3         ; store the pointer to the lenght of disk name string
6886+ 4AFB 3E 01        RWMSSC  ld      A,$01           ; set rewriting of master sector
6887+ 4AFD 32 29 61             ld      (TPBF4),A
6888+ 4B00 CD 9E 23     DSKFRM: call    CHKSYN          ; Make sure ',' follows
6889+ 4B03 2C                   defb    ','
6890+ 4B04 CD F3 4B             call    CHKFLNM         ; check for file name
6891+ 4B07 11 4A 4B             ld      DE,MSTTXT       ; format message
6892+ 4B0A 3A 29 61             ld      A,(TPBF4)       ; check for type of operation
6893+ 4B0D B7                   or      A               ; A=0 (full format)?
6894+ 4B0E 20 03                jr      NZ,CFINIT       ; no, jump over
6895+ 4B10 11 62 4B             ld      DE,FRMTXT       ; rewrite Master Sector
6896+ 4B13 E5           CFINIT: push    HL              ; store code string pointer
6897+ 4B14 62                   ld      H,D             ; Point to message
6898+ 4B15 6B                   ld      L,E
6899+ 4B16 CD 80 2F             call    PRS             ; print message for confirmation
6900+ 4B19 E1                   pop     HL              ; retrieve HL
6901+ 4B1A CD CE 4B             call    CNFREQ          ; ask for confirmation
6902+ 4B1D DA 9F 4A             jp      C,ABRTDS        ; if Carry set then abort
6903+ 4B20 CD 09 10     INITDSK:call    CF_INIT         ; init CF card
6904+ 4B23 DA 36 4A             jp      C,DOS_ERR       ; error if device not available/ready
6905+ 4B26 E5                   push    HL              ; store code string pointer
6906+ 4B27 CD E9 10             call    DSK_INIT        ; init disk
6907+ 4B2A E1                   pop     HL              ; retrieve code string pointer
6908+ 4B2B DA 36 4A             jp      C,DOS_ERR       ; if Carry set, raise error
6909+ 4B2E E5           INITFN: push    HL              ; store code string pointer
6910+ 4B2F 3A 7B 61             ld      A,(TMPBFR1)
6911+ 4B32 B7                   or      A               ; full formatting?
6912+ 4B33 20 0D                jr      NZ,MSPTOK       ; no
6913+ 4B35 21 7A 4B             ld      HL,OPRCMP       ; yes, Point to message
6914+ 4B38 CD 80 2F             call    PRS             ; print message for init confirmation
6915+ 4B3B 16 00                ld      D,$00           ; print only disk details, no file list
6916+ 4B3D CD 99 12             call    LST_FILES       ; print details of disk and list files
6917+ 4B40 E1                   pop     HL              ; retrieve code string pointer
6918+ 4B41 C9                   ret                     ; return to caller
6919+ 4B42 21 7A 4B     MSPTOK: ld      HL,OPRCMP       ; format OK message
6920+ 4B45 CD 80 2F             call    PRS             ; print message for init confirmation
6921+ 4B48 E1                   pop     HL              ; retrieve code string pointer
6922+ 4B49 C9                   ret                     ; return to caller
6923+ 4B4A 52 65 77 72  MSTTXT: defb    "Rewrite Master Sector? ",0
6923+ 4B4E 69 74 65 20
6923+ 4B52 4D 61 73 74
6923+ 4B56 65 72 20 53
6923+ 4B5A 65 63 74 6F
6923+ 4B5E 72 3F 20 00
6924+ 4B62 57 41 52 4E  FRMTXT: defb    "WARNING!! Format disk? ",0
6924+ 4B66 49 4E 47 21
6924+ 4B6A 21 20 46 6F
6924+ 4B6E 72 6D 61 74
6924+ 4B72 20 64 69 73
6924+ 4B76 6B 3F 20 00
6925+ 4B7A 4F 70 65 72  OPRCMP: defb    "Operation completed",CR,0
6925+ 4B7E 61 74 69 6F
6925+ 4B82 6E 20 63 6F
6925+ 4B86 6D 70 6C 65
6925+ 4B8A 74 65 64 0D
6925+ 4B8E 00
6926+ 4B8F
6927+ 4B8F
6928+ 4B8F              ; undelete files
6929+ 4B8F              ; look for files marked as "deleted" and undelete them
6930+ 4B8F 2B           DSKUND: dec     HL              ; dec 'cause GETCHR increments
6931+ 4B90 CD E7 25             call    GETCHR          ; check if something follows
6932+ 4B93 C2 9E 20             jp      NZ,SNERR        ; if something else, raise a syntax error
6933+ 4B96 E5                   push    HL              ; store code string pointer
6934+ 4B97 CD EF 16             call    DSKUNDFL        ; undelete files
6935+ 4B9A E1                   pop     HL              ; retrieve code string pointer
6936+ 4B9B C9                   ret                     ; return to caller
6937+ 4B9C
6938+ 4B9C
6939+ 4B9C              ; disk rename
6940+ 4B9C              ; change the name of the disk w/o altering anything else
6941+ 4B9C CD 9E 23     DSKRNM: call    CHKSYN          ; Make sure ',' follows
6942+ 4B9F 2C                   defb    ','
6943+ 4BA0 CD F3 4B             call    CHKFLNM         ; check for file name
6944+ 4BA3 E5                   push    HL              ; store code string pointer
6945+ 4BA4 21 C0 4B             ld      HL,RNDKTX       ; Point to message
6946+ 4BA7 CD 80 2F             call    PRS             ; print message for confirmation
6947+ 4BAA E1                   pop     HL              ; retrieve HL
6948+ 4BAB CD CE 4B             call    CNFREQ          ; ask for confirmation
6949+ 4BAE DA 9F 4A             jp      C,ABRTDS        ; if Carry set then abort
6950+ 4BB1 CD 09 10             call    CF_INIT         ; init CF card
6951+ 4BB4 DA 36 4A             jp      C,DOS_ERR       ; error if device not available/ready
6952+ 4BB7 E5                   push    HL              ; store code string pointer
6953+ 4BB8 CD 1D 12             call    DSK_RNM         ; init disk
6954+ 4BBB E1                   pop     HL              ; retrieve code string pointer
6955+ 4BBC DA 36 4A             jp      C,DOS_ERR       ; DOS error
6956+ 4BBF C9                   ret
6957+ 4BC0 52 65 6E 61  RNDKTX: defb    "Rename disk? ",0
6957+ 4BC4 6D 65 20 64
6957+ 4BC8 69 73 6B 3F
6957+ 4BCC 20 00
6958+ 4BCE
6959+ 4BCE
6960+ 4BCE              ; confirmation required by the user ('y' or 'Y' DO confirm, otherwise DON'T)
6961+ 4BCE CD 23 09     CNFREQ: call    CURSOR_ON       ; enable cursor
6962+ 4BD1 AF                   xor     A
6963+ 4BD2 32 77 61             ld      (PRNTVIDEO),A   ; disable print-on-video
6964+ 4BD5 CD 2A 02             call    RXA             ; look for a pressed key
6965+ 4BD8 FE 03                cp      CTRLC           ; is it RUN STOP?
6966+ 4BDA 28 15                jr      Z,CNFRQN        ; yes, abort operation
6967+ 4BDC E6 DF                and     %11011111       ; only UPPERCASE char
6968+ 4BDE FE 59                cp      'Y'             ; 'Y'?
6969+ 4BE0 20 0F                jr      NZ,CNFRQN       ; no, abort operation
6970+ 4BE2 08                   ex      AF,AF'
6971+ 4BE3 3E 01                ld      A,$01           ; re-enable...
6972+ 4BE5 32 77 61             ld      (PRNTVIDEO),A   ; ...print-on-video
6973+ 4BE8 08                   ex      AF,AF'
6974+ 4BE9 CD 1C 03             call    ECHO_CHAR       ; yes, echoes the char
6975+ 4BEC CD 38 09             call    CURSOR_OFF      ; disable cursor
6976+ 4BEF AF                   xor     A               ; reset Carry flag
6977+ 4BF0 C9                   ret                     ; return to caller
6978+ 4BF1 37           CNFRQN: scf                     ; set Carry flag
6979+ 4BF2 C9                   ret                     ; return to caller
6980+ 4BF3
6981+ 4BF3
6982+ 4BF3              ; check that a disk/file name follows
6983+ 4BF3 2B           CHKFLNM:dec     HL              ; dec 'cause GETCHR increments
6984+ 4BF4 CD E7 25             call    GETCHR          ; check if something follows
6985+ 4BF7 CA 9E 20             jp      Z,SNERR         ; if nothing else, raise a syntax error
6986+ 4BFA CD 8A 2A             call    EVAL            ; Evaluate expression
6987+ 4BFD CD 7C 2A     CHKFN1: call    TSTSTR          ; Make sure it's a string
6988+ 4C00 22 14 61             ld      (TMPDBF+2),HL   ; store code string pointer into a temp buffer
6989+ 4C03 CD C3 30             call    GSTRCU          ; get current string into pool
6990+ 4C06 CD D4 38             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
6991+ 4C09 7B                   ld      A,E             ; check if lenght = 0
6992+ 4C0A A7                   and     A               ; null string?
6993+ 4C0B CA 9E 20             jp      Z,SNERR         ; yes, syntax error
6994+ 4C0E ED 53 7F 61          ld      (DKLNPT),DE     ; no, store lenght
6995+ 4C12 ED 43 7D 61          ld      (DKNMPT),BC     ; store address of temp string
6996+ 4C16 2A 14 61             ld      HL,(TMPDBF+2)   ; retrieve code string pointer
6997+ 4C19 C9                   ret                     ; return to caller
6998+ 4C1A
6999+ 4C1A
7000+ 4C1A              ; HEX$(nn) Convert 16 bit number to Hexadecimal string
7001+ 4C1A CD 7B 2A     HEX: 	call	TSTNUM          ; Verify it's a number
7002+ 4C1D CD 9D 26             call	DEINT           ; Get integer -32768 to 32767
7003+ 4C20 C5                   push	BC              ; Save contents of BC
7004+ 4C21 21 D4 61             ld      HL,PBUFF        ; load address of PBUFF into HL
7005+ 4C24 7A                   ld      A,D             ; Get MSB into A
7006+ 4C25 B7                   or      A               ; OR with LSB to see if param=0
7007+ 4C26 28 0C                jr      Z,HEX2          ; Skip output if both high digits are zero
7008+ 4C28 CD 50 4C             call    BYT2ASC         ; Convert D to ASCII
7009+ 4C2B 78                   ld      A,B             ; cechk if B
7010+ 4C2C FE 30                cp      '0'             ; is 0
7011+ 4C2E 28 02                jr      Z,HEX1          ; Don't store high digit if zero
7012+ 4C30 70                   ld      (HL),B          ; Store it to PBUFF
7013+ 4C31 23                   inc     HL              ; Next location
7014+ 4C32 71           HEX1:   ld      (HL),C          ; Store C to PBUFF+1
7015+ 4C33 23                   inc     HL              ; Next location
7016+ 4C34 7B           HEX2:   ld      A,E             ; Get lower byte
7017+ 4C35 CD 50 4C             call    BYT2ASC         ; Convert E to ASCII
7018+ 4C38 7A                   ld      A,D
7019+ 4C39 B7                   or      A
7020+ 4C3A 20 05                jr      NZ,HEX3         ; If upper byte was not zero then always print lower byte
7021+ 4C3C 78                   ld      A,B
7022+ 4C3D FE 30                cp      '0'             ; If high digit of lower byte is zero then don't print
7023+ 4C3F 28 02                jr      Z,HEX4
7024+ 4C41 70           HEX3:   ld      (HL),B          ; to PBUFF+2
7025+ 4C42 23                   inc     HL              ; Next location
7026+ 4C43 71           HEX4:   ld      (HL),C          ; to PBUFF+3
7027+ 4C44 23                   inc     HL              ; PBUFF+4 to zero
7028+ 4C45 AF                   xor     A               ; Terminating character
7029+ 4C46 77                   ld      (HL),A          ; Store zero to terminate
7030+ 4C47 23                   inc     HL              ; Make sure PBUFF is terminated
7031+ 4C48 77                   ld      (HL),A          ; Store the double zero there
7032+ 4C49 C1                   pop     BC              ; Get BC back
7033+ 4C4A 21 D4 61             ld      HL,PBUFF        ; Reset to start of PBUFF
7034+ 4C4D C3 10 2F             jp      STR1            ; Convert the PBUFF to a string and return it
7035+ 4C50 47           BYT2ASC:ld      B,A             ; Save original value
7036+ 4C51 E6 0F                and     $0F             ; Strip off upper nybble
7037+ 4C53 FE 0A                cp      $0A             ; 0-9?
7038+ 4C55 38 02                jr      C,ADD30         ; If A-F, add 7 more
7039+ 4C57 C6 07                add     A,$07           ; Bring value up to ASCII A-F
7040+ 4C59 C6 30        ADD30:  add     A,$30           ; And make ASCII
7041+ 4C5B 4F                   ld      C,A             ; Save converted char to C
7042+ 4C5C 78                   ld      A,B             ; Retrieve original value
7043+ 4C5D 0F                   rrca                    ; and Rotate it right
7044+ 4C5E 0F                   rrca
7045+ 4C5F 0F                   rrca
7046+ 4C60 0F                   rrca
7047+ 4C61 E6 0F                and     $0F             ; Mask off upper nybble
7048+ 4C63 FE 0A                cp      $0A             ; 0-9? < A hex?
7049+ 4C65 38 02                jr      C,ADD301        ; Skip Add 7
7050+ 4C67 C6 07                add     A,$07           ; Bring it up to ASCII A-F
7051+ 4C69 C6 30        ADD301: add     A,$30           ; And make it full ASCII
7052+ 4C6B 47                   ld      B,A             ; Store high order byte
7053+ 4C6C C9                   ret
7054+ 4C6D
7055+ 4C6D              ; Convert "&Hnnnn" to FPREG
7056+ 4C6D              ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
7057+ 4C6D              ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
7058+ 4C6D EB           HEXTFP: ex      DE,HL           ; Move code string pointer to DE
7059+ 4C6E 21 00 00             ld      HL,$0000        ; Zero out the value
7060+ 4C71 CD 86 4C             call    GETHEX          ; Check the number for valid hex
7061+ 4C74 DA A6 4C             jp      C,HXERR         ; First value wasn't hex, HX error
7062+ 4C77 18 05                jr      HEXLP1          ; Convert first character
7063+ 4C79 CD 86 4C     HEXLP:  call    GETHEX          ; Get second and addtional characters
7064+ 4C7C 38 1F                jr      C,HEXIT         ; Exit if not a hex character
7065+ 4C7E 29           HEXLP1: add     HL,HL           ; Rotate 4 bits to the left
7066+ 4C7F 29                   add     HL,HL
7067+ 4C80 29                   add     HL,HL
7068+ 4C81 29                   add     HL,HL
7069+ 4C82 B5                   or      L               ; Add in D0-D3 into L
7070+ 4C83 6F                   ld      L,A             ; Save new value
7071+ 4C84 18 F3                jr      HEXLP           ; And continue until all hex characters are in
7072+ 4C86
7073+ 4C86 13           GETHEX: inc     DE              ; Next location
7074+ 4C87 1A                   ld      A,(DE)          ; Load character at pointer
7075+ 4C88 FE 20                cp      SPC
7076+ 4C8A CA 86 4C             jp      Z,GETHEX        ; Skip spaces
7077+ 4C8D D6 30                sub     $30             ; Get absolute value
7078+ 4C8F D8                   ret     C               ; < "0", error
7079+ 4C90 FE 0A                cp      $0A
7080+ 4C92 38 05                jr      C,NOSUB7        ; Is already in the range 0-9
7081+ 4C94 D6 07                sub     $07             ; Reduce to A-F
7082+ 4C96 FE 0A                cp      $0A             ; Value should be $0A-$0F at this point
7083+ 4C98 D8                   ret     C               ; CY set if was :            ; < = > ? @
7084+ 4C99 FE 10        NOSUB7: cp      $10             ; > Greater than "F"?
7085+ 4C9B 3F                   ccf
7086+ 4C9C C9                   ret                     ; CY set if it wasn't valid hex
7087+ 4C9D
7088+ 4C9D EB           HEXIT:  ex      DE,HL           ; Value into DE, Code string into HL
7089+ 4C9E 7A                   ld      A,D             ; Load DE into AC
7090+ 4C9F 4B                   ld      C,E             ; For prep to
7091+ 4CA0 E5                   push    HL
7092+ 4CA1 CD 61 2E             call    ACPASS          ; ACPASS to set AC as integer into FPREG
7093+ 4CA4 E1                   pop     HL
7094+ 4CA5 C9                   ret
7095+ 4CA6
7096+ 4CA6 DD 5C        HXERR:  ld      E,HX            ; ?HEX Error
7097+ 4CA8 C3 B8 20             jp      ERROR
7098+ 4CAB
7099+ 4CAB              ; BIN$(NN) Convert integer to a 1-16 char binary string
7100+ 4CAB CD 7B 2A     BIN:    call    TSTNUM          ; Verify it's a number
7101+ 4CAE CD 9D 26             call    DEINT           ; Get integer -32768 to 32767
7102+ 4CB1 C5           BIN2:   push    BC              ; Save contents of BC
7103+ 4CB2 21 D4 61             ld      HL,PBUFF
7104+ 4CB5 06 11                ld      B,$11           ; One higher than max char count (16+1)
7105+ 4CB7              ZEROSUP:                        ; Suppress leading zeros
7106+ 4CB7 05                   dec     B               ; Max 16 chars
7107+ 4CB8 78                   ld      A,B
7108+ 4CB9 FE 01                cp      $01
7109+ 4CBB 28 08                jr      Z,BITOUT        ; Always output at least one character
7110+ 4CBD CB 13                rl      E
7111+ 4CBF CB 12                rl      D
7112+ 4CC1 30 F4                jr      NC,ZEROSUP
7113+ 4CC3 18 04                jr      BITOUT2
7114+ 4CC5 CB 13        BITOUT: rl      E
7115+ 4CC7 CB 12                rl      D               ; Top bit now in carry
7116+ 4CC9 3E 30        BITOUT2:ld      A,'0'           ; Char for '0'
7117+ 4CCB CE 00                adc     A,$00           ; If carry set then '0' --> '1'
7118+ 4CCD 77                   ld      (HL),A
7119+ 4CCE 23                   inc     HL
7120+ 4CCF 05                   dec     B
7121+ 4CD0 20 F3                jr      NZ,BITOUT
7122+ 4CD2 AF                   xor     A               ; Terminating character
7123+ 4CD3 77                   ld      (HL),A          ; Store zero to terminate
7124+ 4CD4 23                   inc     HL              ; Make sure PBUFF is terminated
7125+ 4CD5 77                   ld      (HL),A          ; Store the double zero there
7126+ 4CD6 C1                   pop     BC
7127+ 4CD7 21 D4 61             ld      HL,PBUFF
7128+ 4CDA C3 10 2F             jp      STR1
7129+ 4CDD
7130+ 4CDD              ; Convert "&Bnnnn" to FPREG
7131+ 4CDD              ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
7132+ 4CDD EB           BINTFP: ex      DE,HL           ; Move code string pointer to DE
7133+ 4CDE 21 00 00             ld      HL,$0000        ; Zero out the value
7134+ 4CE1 CD FA 4C             call    CHKBIN          ; Check the number for valid bin
7135+ 4CE4 DA 08 4D             jp      C,BINERR        ; First value wasn't bin, HX error
7136+ 4CE7 D6 30        BINIT:  sub     '0'
7137+ 4CE9 29                   add     HL,HL           ; Rotate HL left
7138+ 4CEA B5                   or      L
7139+ 4CEB 6F                   ld      L,A
7140+ 4CEC CD FA 4C             call    CHKBIN          ; Get second and addtional characters
7141+ 4CEF 30 F6                jr      NC,BINIT        ; Process if a bin character
7142+ 4CF1 EB                   ex      DE,HL           ; Value into DE, Code string into HL
7143+ 4CF2 7A                   ld      A,D             ; Load DE into AC
7144+ 4CF3 4B                   ld      C,E             ; For prep to
7145+ 4CF4 E5                   push    HL
7146+ 4CF5 CD 61 2E             call    ACPASS          ; ACPASS to set AC as integer into FPREG
7147+ 4CF8 E1                   pop     HL
7148+ 4CF9 C9                   ret
7149+ 4CFA
7150+ 4CFA              ; Char is in A, NC if char is 0 or 1
7151+ 4CFA 13           CHKBIN: inc     DE
7152+ 4CFB 1A                   ld      A,(DE)
7153+ 4CFC FE 20                cp      SPC
7154+ 4CFE CA FA 4C             jp      Z,CHKBIN        ; Skip spaces
7155+ 4D01 FE 30                cp      '0'             ; Set C if < '0'
7156+ 4D03 D8                   ret     C
7157+ 4D04 FE 32                cp      '2'
7158+ 4D06 3F                   ccf                     ; Set C if > '1'
7159+ 4D07 C9                   ret
7160+ 4D08
7161+ 4D08 1E 28        BINERR: ld      E,BN            ; ?BIN Error
7162+ 4D0A C3 B8 20             jp      ERROR
7163+ 4D0D
7164+ 4D0D
7165+ 4D0D C3 08 00     MONOUT: jp      $0008           ; output a char
7166+ 4D10
7167+ 4D10
7168+ 4D10 CD 19 33     RESET:  call    DISNMI          ; disable NMI vector
7169+ 4D13 3A BD 61             ld      A,(SERIALS_EN)  ; load status of serial lines
7170+ 4D16 E6 11                and     $11             ; are serial ports open?
7171+ 4D18 C4 0E 45             call    NZ,RSTSERS      ; yes, reset serials
7172+ 4D1B 3A C0 61             ld      A,(DOS_EN)      ; is DOS enabled
7173+ 4D1E A7                   and     A               ; if enabled, A<>0
7174+ 4D1F C4 81 10             call    NZ,CF_STANDBY   ; put CF into standby mode
7175+ 4D22 F3                   di                      ; disable INTs
7176+ 4D23                  IFDEF LM80C64K
7177+ 4D23 C3 46 5F             jp      ROM2RAM         ; Restart
7178+ 4D26                  ELSE
7179+ 4D26 ~                    jp      $0000           ; Restart
7180+ 4D26                  ENDIF
7181+ 4D26
7182+ 4D26
7183+ 4D26 3E 00        INITST: ld      A,$00           ; Clear break flag
7184+ 4D28 32 1E 60             ld      (BRKFLG),A
7185+ 4D2B C3 8D 1B             jp      SYSINIT
7186+ 4D2E
7187+ 4D2E
7188+ 4D2E F5           TSTBIT: push    AF              ; Save bit mask
7189+ 4D2F A0                   and     B               ; Get common bits
7190+ 4D30 C1                   pop     BC              ; Restore bit mask
7191+ 4D31 B8                   cp      B               ; Same bit set?
7192+ 4D32 3E 00                ld      A,$00           ; Return 0 in A
7193+ 4D34 C9                   ret
7194+ 4D35
7195+ 4D35 CD A9 23     OUTNCR: call    OUTC            ; Output character in A
7196+ 4D38 C3 B4 28             jp      PRNTCRLF        ; Output CRLF
7197+ 4D3B
# file closed: ../include/basic/basic-1.09.asm
  87  4D3B
  88  4D3B              ; include utils
  89  4D3B                  INCLUDE "../include/utils/utils-r1.2.asm"
# file opened: ../include/utils/utils-r1.2.asm
   1+ 4D3B              ; ------------------------------------------------------------------------------
   2+ 4D3B              ; LM80C - UTILITY ROUTINES - R1.2
   3+ 4D3B              ; ------------------------------------------------------------------------------
   4+ 4D3B              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4D3B              ; designed by Leonardo Miliani. More info at
   6+ 4D3B              ; www DOT leonardomiliani DOT com
   7+ 4D3B              ;
   8+ 4D3B              ; *ALS are routines from "Z80 Assembly Language Subroutines" by Lance
   9+ 4D3B              ; A. Leventhal and Winthrop Saville - Ed. Osborne/McGraw-Hill (1983)
  10+ 4D3B              ;
  11+ 4D3B              ; * WKT are routines from WikiTI:
  12+ 4D3B              ; http://wikiti.brandonw.net/index.php?title=WikiTI_Home
  13+ 4D3B              ;
  14+ 4D3B              ; * LAC are routines from Learn@Cemetch
  15+ 4D3B              ; https://learn.cemetech.net/index.php/Main_Page
  16+ 4D3B              ;
  17+ 4D3B              ; ------------------------------------------------------------------------------
  18+ 4D3B              ; Code Revision:
  19+ 4D3B              ; R1.0 - 20200110 - First release: 16-bit comparision/multiplication/negation
  20+ 4D3B              ; R1.1 - 20200413 - Second release: added ABS(HL)
  21+ 4D3B              ; R1.2 - 20200131 - Added 32/16 bit multiplication/division and converter to
  22+ 4D3B              ;                   transform a 32-bit value into ASCII representation
  23+ 4D3B              ;
  24+ 4D3B              ; ------------------------------------------------------------------------------
  25+ 4D3B
  26+ 4D3B              ; compare two 16-bit registers, HL (minuend) and DE (subtrahend)
  27+ 4D3B              ; values can be both signed or unsigned words
  28+ 4D3B              ; inputs: HL, DE
  29+ 4D3B              ; destroys: A,F,HL
  30+ 4D3B              ;
  31+ 4D3B              ; returns: Z=1 if HL = DE
  32+ 4D3B              ; for UNSIGNED: C=1 if HL<DE  //  C=0 if HL>DE
  33+ 4D3B              ; for SIGNED:   S=1 (M) if HL<DE  //  S=0 (P) if HL>DE
  34+ 4D3B              ; if HL=DE: Z,P,NC  - Z=1, S=0; C=0
  35+ 4D3B              ; if HL>DE: NZ,P,NC - Z=0, S=0; C=0
  36+ 4D3B              ; if HL<DE: NZ,M,C  - Z=0, S=1; C=1
  37+ 4D3B              ; Source: ALS
  38+ 4D3B
  39+ 4D3B B7           CMP16:  or      A           ; clear CARRY
  40+ 4D3C ED 52                sbc     HL,DE       ; subtract DE from HL
  41+ 4D3E E0                   ret     PO          ; return if no overflow
  42+ 4D3F 7C                   ld      A,H         ; overflow - invert SIGN flag
  43+ 4D40 1F                   rra                 ; save CARRY flag in bit 7
  44+ 4D41 EE 40                xor     %01000000   ; complement bit 6 (SIGN bit)
  45+ 4D43 37                   scf                 ; ensure a Non-Zero result
  46+ 4D44 8F                   adc     A,A         ; restore CARRY, complemented SIGN
  47+ 4D45                                          ; ZERO flag = 0 for sure
  48+ 4D45 C9                   ret                 ; return
  49+ 4D46
  50+ 4D46              ; ----------------------------------------------------------------------
  51+ 4D46
  52+ 4D46              ; multiply 2 signed/unsigned 16-bit words and return a 16-bit
  53+ 4D46              ; signed/unsigned product
  54+ 4D46              ; inputs: HL (multiplicand); DE (multiplier)
  55+ 4D46              ; destroys: A,F
  56+ 4D46              ; returns: HL (product)
  57+ 4D46              ; Source: ALS
  58+ 4D46
  59+ 4D46              ; initialize partial product, bit count
  60+ 4D46 C5           MUL16:  push    BC
  61+ 4D47 4D                   ld      C,L         ; BC = multiplier
  62+ 4D48 44                   ld      B,H
  63+ 4D49 21 00 00             ld      HL,0        ; product = 0
  64+ 4D4C 3E 0F                ld      A,$0F       ; count = bit lenght - 1 (16-1)
  65+ 4D4E                      ; shift-and-add algorithm
  66+ 4D4E                      ; if MSB of multiplier is 1, add multiplicand to partial product
  67+ 4D4E                      ; shift partial product, multiplier left 1 bit
  68+ 4D4E CB 23        MLP:    sla     E           ; shift multiplier left 1 bit
  69+ 4D50 CB 12                rl      D
  70+ 4D52 30 01                jr      NC,MLP1     ; jump if MSB of multiplier = 0
  71+ 4D54 09                   add     HL,BC       ; add multiplicand to partial product
  72+ 4D55 29           MLP1:   add     HL,HL       ; shift partial product left
  73+ 4D56 3D                   dec     A
  74+ 4D57 20 F5                jr      NZ,MLP      ; continue until count = 0
  75+ 4D59                      ; add multiplicand one last time if MSB of multiplier is 1
  76+ 4D59 B2                   or      D           ; sign flag = MSB of multiplier
  77+ 4D5A F2 5E 4D             jp      P,EXMUL16   ; exit if MSB of multiplier is 0
  78+ 4D5D 09                   add     HL,BC       ; add multiplicand to product
  79+ 4D5E C1           EXMUL16:pop     BC
  80+ 4D5F C9                   ret
  81+ 4D60
  82+ 4D60
  83+ 4D60              ; ----------------------------------------------------------------------
  84+ 4D60
  85+ 4D60              ; multiply 2 unsigned 16-bit words and return a 32-bit unsigned product
  86+ 4D60              ; inputs: BC (multiplicand); DE (multiplier)
  87+ 4D60              ; destroys: A,F
  88+ 4D60              ; operation: BC * DE
  89+ 4D60              ; returns: DEHL (product)
  90+ 4D60              ; Source: WKT
  91+ 4D60
  92+ 4D60 21 00 00     MUL_U32:ld      HL,$0000        ; reset HL
  93+ 4D63 CB 23                sla     E		; optimised 1st iteration
  94+ 4D65 CB 12                rl      D
  95+ 4D67 30 02                jr      NC,MU32_1       ; if no Carry then jump over
  96+ 4D69 60                   ld      H,B
  97+ 4D6A 69                   ld      L,C
  98+ 4D6B 3E 0F        MU32_1: ld      A,$0F
  99+ 4D6D 29           MUL_32L:add     HL,HL           ; main loop
 100+ 4D6E CB 13                rl      E
 101+ 4D70 CB 12                rl      D
 102+ 4D72 30 04                jr      NC,MU32_2
 103+ 4D74 09                   add     HL,BC
 104+ 4D75 30 01                jr      NC,MU32_2
 105+ 4D77 13                   inc     DE
 106+ 4D78 3D           MU32_2: dec     A
 107+ 4D79 20 F2                jr      NZ,MUL_32L
 108+ 4D7B C9                   ret
 109+ 4D7C
 110+ 4D7C              ; ----------------------------------------------------------------------
 111+ 4D7C              ; absolute value of HL (same applies to other 16-bit register pairs)
 112+ 4D7C              ; also, invert value of HL (or any other 16-bit register, just adjust the code)
 113+ 4D7C              ;
 114+ 4D7C              ; inputs: HL
 115+ 4D7C              ; destroys: A
 116+ 4D7C              ; operation: ABS(HL)
 117+ 4D7C              ; returns: HL with no sign or negated
 118+ 4D7C              ; Source: WKT
 119+ 4D7C
 120+ 4D7C CB 7C        absHL:  bit     7,H
 121+ 4D7E C8                   ret     Z
 122+ 4D7F AF           negHL:  xor     A
 123+ 4D80 95                   sub     L
 124+ 4D81 6F                   ld      L,A
 125+ 4D82 9F                   sbc     A,A
 126+ 4D83 94                   sub     H
 127+ 4D84 67                   ld      H,A
 128+ 4D85 C9                   ret
 129+ 4D86
 130+ 4D86              ; ------------------------------------------------------------------------------
 131+ 4D86
 132+ 4D86              ; 8/8 division
 133+ 4D86              ; INPUT: D (dividend), E (divisor)
 134+ 4D86              ; OPERATION: D/E
 135+ 4D86              ; OUTPUT: D (quotient), A (remainder)
 136+ 4D86 AF           DIV_8_8:    xor     A
 137+ 4D87 C5                       push    BC
 138+ 4D88 06 08                    ld      B,08h
 139+ 4D8A CB 22        DIV_8_8LOOP:sla     D
 140+ 4D8C 17                       rla
 141+ 4D8D BB                       cp      E
 142+ 4D8E 38 02                    jr      C,$+4
 143+ 4D90 93                       sub     E
 144+ 4D91 14                       inc     D
 145+ 4D92 10 F6                    djnz    DIV_8_8LOOP
 146+ 4D94 C1                       pop     BC
 147+ 4D95 C9                       ret
 148+ 4D96
 149+ 4D96              ; ----------------------------------------------------------------------
 150+ 4D96              ; divide a 16-bit number by an 8-bit number
 151+ 4D96              ; (16/8 division)
 152+ 4D96              ;
 153+ 4D96              ; inputs: HL (Dividend), C (divisor)
 154+ 4D96              ; destroys: A, B
 155+ 4D96              ; OPERATION: HL/C
 156+ 4D96              ; returns: HL (quotient), A (remainder)
 157+ 4D96              ; source: WKT
 158+ 4D96
 159+ 4D96 AF           DIV_16_8:   xor     A
 160+ 4D97 06 10                    ld      B,16
 161+ 4D99 29           DIV_16_8LP: add     HL,HL
 162+ 4D9A 17                       rla
 163+ 4D9B 38 03                    jr      C,$+5
 164+ 4D9D B9                       cp      C
 165+ 4D9E 38 02                    jr      C,$+4
 166+ 4DA0 91                       sub     C
 167+ 4DA1 2C                       inc     L
 168+ 4DA2 10 F5                    djnz    DIV_16_8LP
 169+ 4DA4 C9                       ret
 170+ 4DA5
 171+ 4DA5              ; ----------------------------------------------------------------------
 172+ 4DA5              ; divide a 16-bit number by a 16-bit number
 173+ 4DA5              ; (16/16 division)
 174+ 4DA5              ;
 175+ 4DA5              ; inputs: AC (Dividend), DE (divisor)
 176+ 4DA5              ; destroys: HL,A,C
 177+ 4DA5              ; OPERATION: AC/DE
 178+ 4DA5              ; returns: AC (quotient), HL (remainder)
 179+ 4DA5              ; source: WKT
 180+ 4DA5 21 00 00     DIV_16_16:  ld      HL, 0
 181+ 4DA8 06 10                    ld      B, 16
 182+ 4DAA CB 21        DV16_16_LP: sla     C
 183+ 4DAC CB C1                    set     0,C         ; this simulates the SLL undocumented instruction
 184+ 4DAE 17                       rla
 185+ 4DAF ED 6A                    adc     HL,HL
 186+ 4DB1 ED 52                    sbc     HL,DE
 187+ 4DB3 30 02                    jr      NC, $+4
 188+ 4DB5 19                       add     HL,DE
 189+ 4DB6 0D                       dec     C
 190+ 4DB7 10 F1                    djnz    DV16_16_LP
 191+ 4DB9 C9                       ret
 192+ 4DBA
 193+ 4DBA
 194+ 4DBA              ; ----------------------------------------------------------------------
 195+ 4DBA              ; divide a 32-bit number by a 16 bit-number
 196+ 4DBA              ; (32/16 division)
 197+ 4DBA              ;
 198+ 4DBA              ; inputs: ACIX (Dividend), DE (divisor)
 199+ 4DBA              ; destroys: HL,IX,BC
 200+ 4DBA              ; OPERATION: ACIX/DE
 201+ 4DBA              ; returns: ACIX (quotient), HL (remainder)
 202+ 4DBA              ; source: WKT
 203+ 4DBA
 204+ 4DBA 21 00 00     DIV_32_16:  ld      HL,0
 205+ 4DBD 06 20                    ld      B,32
 206+ 4DBF DD 29        DIV_32_16LP:add     IX,IX
 207+ 4DC1 CB 11                    rl      C
 208+ 4DC3 17                       rla
 209+ 4DC4 ED 6A                    adc     HL,HL
 210+ 4DC6 38 08                    jr      C,DIV_32_16OF
 211+ 4DC8 ED 52                    sbc     HL,DE
 212+ 4DCA 30 07                    jr      NC,DIV_32_16SB
 213+ 4DCC 19                       add     HL,DE
 214+ 4DCD 10 F0                    djnz    DIV_32_16LP
 215+ 4DCF C9                       ret
 216+ 4DD0 B7           DIV_32_16OF:or      A                   ; overflow
 217+ 4DD1 ED 52                    sbc     HL,DE
 218+ 4DD3 DD 23        DIV_32_16SB:inc     IX                  ; set bit
 219+ 4DD5 10 E8                    djnz    DIV_32_16LP
 220+ 4DD7 C9                       ret
 221+ 4DD8
 222+ 4DD8
 223+ 4DD8              ; ----------------------------------------------------------------------
 224+ 4DD8              ; convert a 32-bit number in ASCII string (terminated by '0')
 225+ 4DD8              ;
 226+ 4DD8              ; inputs: DEIX (Value), IY (dest. address in memory)
 227+ 4DD8              ; destroys: AF, BC, DE, HL, IX
 228+ 4DD8              ; outputs: IY (last char in dest. string)
 229+ 4DD8              ; source: MSX Forum
 230+ 4DD8
 231+ 4DD8 01 00 00 00  CLCN32T:    defw    1,0,10,0,100,0,1000,0,10000,0
 231+ 4DDC 0A 00 00 00
 231+ 4DE0 64 00 00 00
 231+ 4DE4 E8 03 00 00
 231+ 4DE8 10 27 00 00
 232+ 4DEC A0 86 01 00              defw    $86A0,$1,$4240,$F,$9680,$98,$E100,$5F5,$CA00,$3B9A
 232+ 4DF0 40 42 0F 00
 232+ 4DF4 80 96 98 00
 232+ 4DF8 00 E1 F5 05
 232+ 4DFC 00 CA 9A 3B
 233+ 4E00 00 00 00 00  CLCN32Z:    defs    4
 234+ 4E04
 235+ 4E04 DD 22 00 4E  CLCN32:     ld      (CLCN32Z),IX
 236+ 4E08 ED 53 02 4E              ld      (CLCN32Z+$02),DE
 237+ 4E0C DD 21 FC 4D              ld      IX,CLCN32T+$24
 238+ 4E10 06 09                    ld      B,$09
 239+ 4E12 0E 00                    ld      C,$00
 240+ 4E14 3E 30        CLCN321:    ld      A,"0"
 241+ 4E16 B7                       or      A
 242+ 4E17 DD 5E 00     CLCN322:    ld      E,(IX+$00)
 243+ 4E1A DD 56 01                 ld      D,(IX+$01)
 244+ 4E1D 2A 00 4E                 ld      HL,(CLCN32Z)
 245+ 4E20 ED 52                    sbc     HL,DE
 246+ 4E22 22 00 4E                 ld      (CLCN32Z),HL
 247+ 4E25 DD 5E 02                 ld      E,(IX+$02)
 248+ 4E28 DD 56 03                 ld      D,(IX+$03)
 249+ 4E2B 2A 02 4E                 ld      HL,(CLCN32Z+$02)
 250+ 4E2E ED 52                    sbc     HL,DE
 251+ 4E30 22 02 4E                 ld      (CLCN32Z+$02),HL
 252+ 4E33 38 04                    jr      C,CLCN325
 253+ 4E35 0C                       inc     C
 254+ 4E36 3C                       inc     A
 255+ 4E37 18 DE                    jr      CLCN322
 256+ 4E39 DD 5E 00     CLCN325:    ld      E,(IX+$00)
 257+ 4E3C DD 56 01                 ld      D,(IX+$01)
 258+ 4E3F 2A 00 4E                 ld      HL,(CLCN32Z)
 259+ 4E42 19                       add     HL,DE
 260+ 4E43 22 00 4E                 ld      (CLCN32Z),HL
 261+ 4E46 DD 5E 02                 ld      E,(IX+$02)
 262+ 4E49 DD 56 03                 ld      D,(IX+$03)
 263+ 4E4C 2A 02 4E                 ld      HL,(CLCN32Z+$02)
 264+ 4E4F ED 5A                    adc     HL,DE
 265+ 4E51 22 02 4E                 ld      (CLCN32Z+$02),HL
 266+ 4E54 11 FC FF                 ld      DE,-4
 267+ 4E57 DD 19                    add     IX,DE
 268+ 4E59 0C                       inc     C
 269+ 4E5A 0D                       dec     C
 270+ 4E5B 28 05                    jr      Z,CLCN323
 271+ 4E5D FD 77 00                 ld      (IY+$00),A
 272+ 4E60 FD 23                    inc     IY
 273+ 4E62 10 B0        CLCN323:    djnz    CLCN321
 274+ 4E64 3A 00 4E                 ld      A,(CLCN32Z)
 275+ 4E67 C6 30                    add     "0"
 276+ 4E69 FD 77 00                 ld      (IY+$00),A
 277+ 4E6C FD 36 01 00              ld      (IY+$01),0
 278+ 4E70 C9                       ret
# file closed: ../include/utils/utils-r1.2.asm
  90  4E71
  91  4E71              ; include the latest version of the font sets
  92  4E71                  INCLUDE "../include/vdp/6x8fonts-r16.asm"
# file opened: ../include/vdp/6x8fonts-r16.asm
   1+ 4E71              ; ------------------------------------------------------------------------------
   2+ 4E71              ; LM80C - 6x8 CHARSET - R1.6
   3+ 4E71              ; ------------------------------------------------------------------------------
   4+ 4E71              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4E71              ; designed by Leonardo Miliani. More info at
   6+ 4E71              ; www DOT leonardomiliani DOT com
   7+ 4E71              ; ------------------------------------------------------------------------------
   8+ 4E71              ; Code Revision:
   9+ 4E71              ; R1.0 - 20190511 - First revision: ASCII chars (from 0 to 127)
  10+ 4E71              ; R1.1 - 20190521 - Expanded to 255 chars
  11+ 4E71              ; R1.2 - 20191209 - Start adding graphic chars to be coherent with 8x8 fonts
  12+ 4E71              ; R1.3 - 20191226 - Added extended char codes (128-255)
  13+ 4E71              ; R1.4 - 20200228 - adopted more usual hexadecimal & binary prefixes
  14+ 4E71              ; R1.5 - 20200524 - New style for char #252
  15+ 4E71              ; R1.6 - 20200704 - Redefined chars 105, 106, and 252
  16+ 4E71              ; ------------------------------------------------------------------------------
  17+ 4E71              ;
  18+ 4E71              ;-------------------------------------------------------------------------------
  19+ 4E71              ;
  20+ 4E71              ;               6 x 8    C  H  A  R  S  E  T
  21+ 4E71              ;
  22+ 4E71              ;-------------------------------------------------------------------------------
  23+ 4E71              ;
  24+ 4E71              ;       6X8 CHARS, DESIGNED FOR TEXT BUT USABLE IN GRAPHICS 1 MODE TOO
  25+ 4E71              ;       UPDATE: NOW GRAPHICS 1 MODE HAS ITS OWN CHAR SET
  26+ 4E71
  27+ 4E71              CHRST68 equ $
  28+ 4E71 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  28+ 4E75 00 00 00 00
  29+ 4E79 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  29+ 4E7D 00 00 00 00
  30+ 4E81 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  30+ 4E85 00 00 00 00
  31+ 4E89 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  31+ 4E8D 00 00 00 00
  32+ 4E91 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  32+ 4E95 00 00 00 00
  33+ 4E99 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  33+ 4E9D 00 00 00 00
  34+ 4EA1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  34+ 4EA5 00 00 00 00
  35+ 4EA9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  35+ 4EAD 00 00 00 00
  36+ 4EB1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
  36+ 4EB5 00 00 00 00
  37+ 4EB9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  37+ 4EBD 00 00 00 00
  38+ 4EC1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  38+ 4EC5 00 00 00 00
  39+ 4EC9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11
  39+ 4ECD 00 00 00 00
  40+ 4ED1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  40+ 4ED5 00 00 00 00
  41+ 4ED9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
  41+ 4EDD 00 00 00 00
  42+ 4EE1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
  42+ 4EE5 00 00 00 00
  43+ 4EE9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  43+ 4EED 00 00 00 00
  44+ 4EF1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  44+ 4EF5 00 00 00 00
  45+ 4EF9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  45+ 4EFD 00 00 00 00
  46+ 4F01 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  46+ 4F05 00 00 00 00
  47+ 4F09 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  47+ 4F0D 00 00 00 00
  48+ 4F11 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
  48+ 4F15 00 00 00 00
  49+ 4F19 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  49+ 4F1D 00 00 00 00
  50+ 4F21 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
  50+ 4F25 00 00 00 00
  51+ 4F29 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
  51+ 4F2D 00 00 00 00
  52+ 4F31 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
  52+ 4F35 00 00 00 00
  53+ 4F39 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
  53+ 4F3D 00 00 00 00
  54+ 4F41 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
  54+ 4F45 00 00 00 00
  55+ 4F49 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
  55+ 4F4D 00 00 00 00
  56+ 4F51 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
  56+ 4F55 00 00 00 00
  57+ 4F59 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
  57+ 4F5D 00 00 00 00
  58+ 4F61 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
  58+ 4F65 00 00 00 00
  59+ 4F69 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
  59+ 4F6D 00 00 00 00
  60+ 4F71 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32: space
  60+ 4F75 00 00 00 00
  61+ 4F79 20 20 20 20          defb $20,$20,$20,$20,$20,$00,$20,$00 ; char 33: !
  61+ 4F7D 20 00 20 00
  62+ 4F81 50 50 00 00          defb $50,$50,$00,$00,$00,$00,$00,$00 ; char 34: "
  62+ 4F85 00 00 00 00
  63+ 4F89 50 50 F8 50          defb $50,$50,$f8,$50,$f8,$50,$50,$00 ; char 35: #
  63+ 4F8D F8 50 50 00
  64+ 4F91 20 78 A0 70          defb $20,$78,$a0,$70,$28,$f0,$20,$00 ; char 36: $
  64+ 4F95 28 F0 20 00
  65+ 4F99 C0 C8 10 20          defb $c0,$c8,$10,$20,$40,$98,$18,$00 ; char 37: %
  65+ 4F9D 40 98 18 00
  66+ 4FA1 60 90 A0 40          defb $60,$90,$a0,$40,$a8,$90,$68,$00 ; char 38: &
  66+ 4FA5 A8 90 68 00
  67+ 4FA9 60 20 40 00          defb $60,$20,$40,$00,$00,$00,$00,$00 ; char 39: '
  67+ 4FAD 00 00 00 00
  68+ 4FB1 10 20 40 40          defb $10,$20,$40,$40,$40,$20,$10,$00 ; char 40: (
  68+ 4FB5 40 20 10 00
  69+ 4FB9 40 20 10 10          defb $40,$20,$10,$10,$10,$20,$40,$00 ; char 41: )
  69+ 4FBD 10 20 40 00
  70+ 4FC1 00 20 A8 70          defb $00,$20,$a8,$70,$a8,$20,$00,$00 ; char 42: *
  70+ 4FC5 A8 20 00 00
  71+ 4FC9 00 20 20 F8          defb $00,$20,$20,$f8,$20,$20,$00,$00 ; char 43: +
  71+ 4FCD 20 20 00 00
  72+ 4FD1 00 00 00 00          defb $00,$00,$00,$00,$60,$20,$40,$00 ; char 44: ,
  72+ 4FD5 60 20 40 00
  73+ 4FD9 00 00 00 F8          defb $00,$00,$00,$f8,$00,$00,$00,$00 ; char 45: -
  73+ 4FDD 00 00 00 00
  74+ 4FE1 00 00 00 00          defb $00,$00,$00,$00,$00,$60,$60,$00 ; char 46: .
  74+ 4FE5 00 60 60 00
  75+ 4FE9 00 08 10 20          defb $00,$08,$10,$20,$40,$80,$00,$00 ; char 47: /
  75+ 4FED 40 80 00 00
  76+ 4FF1 70 88 98 A8          defb $70,$88,$98,$a8,$c8,$88,$70,$00 ; char 48: 0
  76+ 4FF5 C8 88 70 00
  77+ 4FF9 20 60 20 20          defb $20,$60,$20,$20,$20,$20,$70,$00 ; char 49: 1
  77+ 4FFD 20 20 70 00
  78+ 5001 70 88 08 10          defb $70,$88,$08,$10,$20,$40,$f8,$00 ; char 50: 2
  78+ 5005 20 40 F8 00
  79+ 5009 F8 10 20 10          defb $f8,$10,$20,$10,$08,$88,$70,$00 ; char 51: 3
  79+ 500D 08 88 70 00
  80+ 5011 10 30 50 90          defb $10,$30,$50,$90,$f8,$10,$10,$00 ; char 52: 4
  80+ 5015 F8 10 10 00
  81+ 5019 F8 80 F0 08          defb $f8,$80,$f0,$08,$08,$88,$70,$00 ; char 53: 5
  81+ 501D 08 88 70 00
  82+ 5021 30 40 80 F0          defb $30,$40,$80,$f0,$88,$88,$70,$00 ; char 54: 6
  82+ 5025 88 88 70 00
  83+ 5029 F8 08 10 20          defb $f8,$08,$10,$20,$40,$40,$40,$00 ; char 55: 7
  83+ 502D 40 40 40 00
  84+ 5031 70 88 88 70          defb $70,$88,$88,$70,$88,$88,$70,$00 ; char 56: 8
  84+ 5035 88 88 70 00
  85+ 5039 70 88 88 78          defb $70,$88,$88,$78,$08,$10,$60,$00 ; char 57: 9
  85+ 503D 08 10 60 00
  86+ 5041 00 30 30 00          defb $00,$30,$30,$00,$30,$30,$00,$00 ; char 58: :
  86+ 5045 30 30 00 00
  87+ 5049 00 30 30 00          defb $00,$30,$30,$00,$30,$10,$20,$00 ; char 59: ;
  87+ 504D 30 10 20 00
  88+ 5051 10 20 40 80          defb $10,$20,$40,$80,$40,$20,$10,$00 ; char 60: <
  88+ 5055 40 20 10 00
  89+ 5059 00 00 F8 00          defb $00,$00,$f8,$00,$f8,$00,$00,$00 ; char 61: =
  89+ 505D F8 00 00 00
  90+ 5061 40 20 10 08          defb $40,$20,$10,$08,$10,$20,$40,$00 ; char 62: >
  90+ 5065 10 20 40 00
  91+ 5069 70 88 08 10          defb $70,$88,$08,$10,$20,$00,$20,$00 ; char 63: ?
  91+ 506D 20 00 20 00
  92+ 5071 70 88 08 68          defb $70,$88,$08,$68,$a8,$a8,$70,$00 ; char 64: @
  92+ 5075 A8 A8 70 00
  93+ 5079 70 88 88 88          defb $70,$88,$88,$88,$f8,$88,$88,$00 ; char 65: A
  93+ 507D F8 88 88 00
  94+ 5081 F0 88 88 F0          defb $f0,$88,$88,$f0,$88,$88,$f0,$00 ; char 66: B
  94+ 5085 88 88 F0 00
  95+ 5089 70 88 80 80          defb $70,$88,$80,$80,$80,$88,$70,$00 ; char 67: C
  95+ 508D 80 88 70 00
  96+ 5091 E0 90 88 88          defb $e0,$90,$88,$88,$88,$90,$e0,$00 ; char 68: D
  96+ 5095 88 90 E0 00
  97+ 5099 F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$f8,$00 ; char 69: E
  97+ 509D 80 80 F8 00
  98+ 50A1 F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$80,$00 ; char 70: F
  98+ 50A5 80 80 80 00
  99+ 50A9 70 88 80 B8          defb $70,$88,$80,$b8,$88,$88,$78,$00 ; char 71: G
  99+ 50AD 88 88 78 00
 100+ 50B1 88 88 88 F8          defb $88,$88,$88,$f8,$88,$88,$88,$00 ; char 72: H
 100+ 50B5 88 88 88 00
 101+ 50B9 70 20 20 20          defb $70,$20,$20,$20,$20,$20,$70,$00 ; char 73: I
 101+ 50BD 20 20 70 00
 102+ 50C1 38 10 10 10          defb $38,$10,$10,$10,$10,$90,$60,$00 ; char 74: J
 102+ 50C5 10 90 60 00
 103+ 50C9 88 90 A0 C0          defb $88,$90,$a0,$c0,$a0,$90,$88,$00 ; char 75: K
 103+ 50CD A0 90 88 00
 104+ 50D1 80 80 80 80          defb $80,$80,$80,$80,$80,$80,$f8,$00 ; char 76: L
 104+ 50D5 80 80 F8 00
 105+ 50D9 88 D8 A8 A8          defb $88,$d8,$a8,$a8,$88,$88,$88,$00 ; char 77: M
 105+ 50DD 88 88 88 00
 106+ 50E1 88 C8 A8 98          defb $88,$c8,$a8,$98,$88,$88,$88,$00 ; char 78: N
 106+ 50E5 88 88 88 00
 107+ 50E9 70 88 88 88          defb $70,$88,$88,$88,$88,$88,$70,$00 ; char 79: O
 107+ 50ED 88 88 70 00
 108+ 50F1 F0 88 88 F0          defb $f0,$88,$88,$f0,$80,$80,$80,$00 ; char 80: P
 108+ 50F5 80 80 80 00
 109+ 50F9 70 88 88 88          defb $70,$88,$88,$88,$a8,$90,$68,$00 ; char 81: Q
 109+ 50FD A8 90 68 00
 110+ 5101 F0 88 88 F0          defb $f0,$88,$88,$f0,$a0,$90,$88,$00 ; char 82: R
 110+ 5105 A0 90 88 00
 111+ 5109 78 80 80 70          defb $78,$80,$80,$70,$08,$08,$f0,$00 ; char 83: S
 111+ 510D 08 08 F0 00
 112+ 5111 F8 20 20 20          defb $f8,$20,$20,$20,$20,$20,$20,$00 ; char 84: T
 112+ 5115 20 20 20 00
 113+ 5119 88 88 88 88          defb $88,$88,$88,$88,$88,$88,$70,$00 ; char 85: U
 113+ 511D 88 88 70 00
 114+ 5121 88 88 88 88          defb $88,$88,$88,$88,$88,$50,$20,$00 ; char 86: V
 114+ 5125 88 50 20 00
 115+ 5129 88 88 88 88          defb $88,$88,$88,$88,$a8,$a8,$50,$00 ; char 87: W
 115+ 512D A8 A8 50 00
 116+ 5131 88 88 50 20          defb $88,$88,$50,$20,$50,$88,$88,$00 ; char 88: X
 116+ 5135 50 88 88 00
 117+ 5139 88 88 88 50          defb $88,$88,$88,$50,$20,$20,$20,$00 ; char 89: Y
 117+ 513D 20 20 20 00
 118+ 5141 F8 08 10 20          defb $f8,$08,$10,$20,$40,$80,$f8,$00 ; char 90: Z
 118+ 5145 40 80 F8 00
 119+ 5149 70 40 40 40          defb $70,$40,$40,$40,$40,$40,$70,$00 ; char 91: [
 119+ 514D 40 40 70 00
 120+ 5151 00 80 40 20          defb $00,$80,$40,$20,$10,$08,$00,$00 ; char 92: \
 120+ 5155 10 08 00 00
 121+ 5159 70 10 10 10          defb $70,$10,$10,$10,$10,$10,$70,$00 ; char 93: ]
 121+ 515D 10 10 70 00
 122+ 5161 20 50 88 00          defb $20,$50,$88,$00,$00,$00,$00,$00 ; char 94: ^
 122+ 5165 00 00 00 00
 123+ 5169 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$FC ; char 95: _ (underscore)
 123+ 516D 00 00 00 FC
 124+ 5171 40 20 10 00          defb $40,$20,$10,$00,$00,$00,$00,$00 ; char 96: `
 124+ 5175 00 00 00 00
 125+ 5179 00 00 70 08          defb $00,$00,$70,$08,$78,$88,$78,$00 ; char 97: a
 125+ 517D 78 88 78 00
 126+ 5181 80 80 80 B0          defb $80,$80,$80,$b0,$c8,$88,$f0,$00 ; char 98: b
 126+ 5185 C8 88 F0 00
 127+ 5189 00 00 70 80          defb $00,$00,$70,$80,$80,$88,$70,$00 ; char 99: c
 127+ 518D 80 88 70 00
 128+ 5191 08 08 08 68          defb $08,$08,$08,$68,$98,$88,$78,$00 ; char 100: d
 128+ 5195 98 88 78 00
 129+ 5199 00 00 70 88          defb $00,$00,$70,$88,$f8,$80,$70,$00 ; char 101: e
 129+ 519D F8 80 70 00
 130+ 51A1 30 48 40 E0          defb $30,$48,$40,$e0,$40,$40,$40,$00 ; char 102: f
 130+ 51A5 40 40 40 00
 131+ 51A9 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$70,$00 ; char 103: g
 131+ 51AD 78 08 70 00
 132+ 51B1 80 80 B0 C8          defb $80,$80,$b0,$c8,$88,$88,$88,$00 ; char 104: h
 132+ 51B5 88 88 88 00
 133+ 51B9 20 00 20 20          defb $20,$00,$20,$20,$20,$20,$20,$00 ; char 105: i
 133+ 51BD 20 20 20 00
 134+ 51C1 08 00 18 08          defb $08,$00,$18,$08,$08,$88,$70,$00 ; char 106: j
 134+ 51C5 08 88 70 00
 135+ 51C9 80 80 90 A0          defb $80,$80,$90,$a0,$c0,$a0,$90,$00 ; char 107: k
 135+ 51CD C0 A0 90 00
 136+ 51D1 60 20 20 20          defb $60,$20,$20,$20,$20,$20,$70,$00 ; char 108: l
 136+ 51D5 20 20 70 00
 137+ 51D9 00 00 D0 A8          defb $00,$00,$d0,$a8,$a8,$88,$88,$00 ; char 109: m
 137+ 51DD A8 88 88 00
 138+ 51E1 00 00 B0 C8          defb $00,$00,$b0,$c8,$88,$88,$88,$00 ; char 110: n
 138+ 51E5 88 88 88 00
 139+ 51E9 00 00 70 88          defb $00,$00,$70,$88,$88,$88,$70,$00 ; char 111: o
 139+ 51ED 88 88 70 00
 140+ 51F1 00 00 F0 88          defb $00,$00,$f0,$88,$f0,$80,$80,$00 ; char 112: p
 140+ 51F5 F0 80 80 00
 141+ 51F9 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$08,$00 ; char 113: q
 141+ 51FD 78 08 08 00
 142+ 5201 00 00 B0 C8          defb $00,$00,$b0,$c8,$80,$80,$80,$00 ; char 114: r
 142+ 5205 80 80 80 00
 143+ 5209 00 00 70 80          defb $00,$00,$70,$80,$70,$08,$f0,$00 ; char 115: s
 143+ 520D 70 08 F0 00
 144+ 5211 40 40 E0 40          defb $40,$40,$e0,$40,$40,$48,$30,$00 ; char 116: t
 144+ 5215 40 48 30 00
 145+ 5219 00 00 88 88          defb $00,$00,$88,$88,$88,$98,$68,$00 ; char 117: u
 145+ 521D 88 98 68 00
 146+ 5221 00 00 88 88          defb $00,$00,$88,$88,$88,$50,$20,$00 ; char 118: v
 146+ 5225 88 50 20 00
 147+ 5229 00 00 88 88          defb $00,$00,$88,$88,$a8,$a8,$50,$00 ; char 119: w
 147+ 522D A8 A8 50 00
 148+ 5231 00 00 88 50          defb $00,$00,$88,$50,$20,$50,$88,$00 ; char 120: x
 148+ 5235 20 50 88 00
 149+ 5239 00 00 88 98          defb $00,$00,$88,$98,$68,$08,$70,$00 ; char 121: y
 149+ 523D 68 08 70 00
 150+ 5241 00 00 F8 10          defb $00,$00,$f8,$10,$20,$40,$f8,$00 ; char 122: z
 150+ 5245 20 40 F8 00
 151+ 5249 10 20 20 40          defb $10,$20,$20,$40,$20,$20,$10,$00 ; char 123: {
 151+ 524D 20 20 10 00
 152+ 5251 20 20 20 20          defb $20,$20,$20,$20,$20,$20,$20,$00 ; char 124: |
 152+ 5255 20 20 20 00
 153+ 5259 20 10 10 08          defb $20,$10,$10,$08,$10,$10,$20,$00 ; char 125: }
 153+ 525D 10 10 20 00
 154+ 5261 00 28 50 00          defb $00,$28,$50,$00,$00,$00,$00,$00 ; char 126: ~
 154+ 5265 00 00 00 00
 155+ 5269 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 127: (delete) - here end the standard ASCII (0-127)
 155+ 526D 00 00 00 00
 156+ 5271 78 84 CC 84          defb %01111000,%10000100,%11001100,%10000100,%10110100,%10000100,%01111000,%00000000 ; char 128 (open face)
 156+ 5275 B4 84 78 00
 157+ 5279 78 FC B4 FC          defb %01111000,%11111100,%10110100,%11111100,%10110100,%11001100,%01111000,%00000000 ; char 129 (full face)
 157+ 527D B4 CC 78 00
 158+ 5281 48 FC FC FC          defb %01001000,%11111100,%11111100,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 130 (hearts)
 158+ 5285 FC 78 30 00
 159+ 5289 00 20 70 F8          defb %00000000,%00100000,%01110000,%11111000,%11111000,%01110000,%00100000,%00000000 ; char 131 (diamonds)
 159+ 528D F8 70 20 00
 160+ 5291 70 20 A8 F8          defb %01110000,%00100000,%10101000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 132 (clubs)
 160+ 5295 A8 20 70 00
 161+ 5299 20 70 F8 F8          defb %00100000,%01110000,%11111000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 133 (spades)
 161+ 529D A8 20 70 00
 162+ 52A1 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 134
 162+ 52A5 FC 30 30 30
 163+ 52A9 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 135
 163+ 52AD 3C 30 30 30
 164+ 52B1 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 136
 164+ 52B5 F0 30 30 30
 165+ 52B9 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00000000,%00000000,%00000000 ; char 137
 165+ 52BD F0 00 00 00
 166+ 52C1 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00000000,%00000000,%00000000 ; char 138
 166+ 52C5 3C 00 00 00
 167+ 52C9 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 139
 167+ 52CD FC 00 00 00
 168+ 52D1 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 140
 168+ 52D5 3C 30 30 30
 169+ 52D9 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 141
 169+ 52DD FC 30 30 30
 170+ 52E1 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 142
 170+ 52E5 F0 30 30 30
 171+ 52E9 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 143
 171+ 52ED FC 00 00 00
 172+ 52F1 30 30 30 30          defb %00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000 ; char 144
 172+ 52F5 30 30 30 30
 173+ 52F9 0C 1C 18 38          defb %00001100,%00011100,%00011000,%00111000,%01110000,%01100000,%11100000,%11000000 ; char 145
 173+ 52FD 70 60 E0 C0
 174+ 5301 C0 E0 60 70          defb %11000000,%11100000,%01100000,%01110000,%00111000,%00011000,%00011100,%00001100 ; char 146
 174+ 5305 38 18 1C 0C
 175+ 5309 CC CC 78 30          defb %11001100,%11001100,%01111000,%00110000,%00110000,%01111000,%11001100,%11001100 ; char 147
 175+ 530D 30 78 CC CC
 176+ 5311 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 148
 176+ 5315 20 20 20 20
 177+ 5319 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 149
 177+ 531D 20 20 20 20
 178+ 5321 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 150
 178+ 5325 20 20 20 20
 179+ 5329 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 151
 179+ 532D 00 00 00 00
 180+ 5331 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00000000,%00000000,%00000000,%00000000 ; char 152
 180+ 5335 00 00 00 00
 181+ 5339 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 153
 181+ 533D 00 00 00 00
 182+ 5341 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 154
 182+ 5345 20 20 20 20
 183+ 5349 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 155
 183+ 534D 20 20 20 20
 184+ 5351 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 156
 184+ 5355 20 20 20 20
 185+ 5359 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 157
 185+ 535D 00 00 00 00
 186+ 5361 20 20 20 20          defb %00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000 ; char 158
 186+ 5365 20 20 20 20
 187+ 5369 04 08 08 10          defb %00000100,%00001000,%00001000,%00010000,%00100000,%01000000,%01000000,%10000000 ; char 159
 187+ 536D 20 40 40 80
 188+ 5371 80 40 40 20          defb %10000000,%01000000,%01000000,%00100000,%00010000,%00001000,%00001000,%00000100 ; char 160
 188+ 5375 10 08 08 04
 189+ 5379 84 48 48 30          defb %10000100,%01001000,%01001000,%00110000,%00110000,%01001000,%01001000,%10000100 ; char 161
 189+ 537D 30 48 48 84
 190+ 5381 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 162
 190+ 5385 00 00 FC FC
 191+ 5389 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111100,%11111100,%11111100,%11111100 ; char 163
 191+ 538D FC FC FC FC
 192+ 5391 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 164
 192+ 5395 FC FC FC FC
 193+ 5399 FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 193+ 539D 00 00 00 00
 194+ 53A1 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 166
 194+ 53A5 00 00 00 00
 195+ 53A9 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 167
 195+ 53AD FC FC 00 00
 196+ 53B1 80 80 80 80          defb %10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000 ; char 168
 196+ 53B5 80 80 80 80
 197+ 53B9 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000 ; char 169
 197+ 53BD E0 E0 E0 E0
 198+ 53C1 F8 F8 F8 F8          defb %11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000 ; char 170
 198+ 53C5 F8 F8 F8 F8
 199+ 53C9 04 04 04 04          defb %00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100 ; char 171
 199+ 53CD 04 04 04 04
 200+ 53D1 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100 ; char 172
 200+ 53D5 1C 1C 1C 1C
 201+ 53D9 7C 7C 7C 7C          defb %01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100 ; char 173
 201+ 53DD 7C 7C 7C 7C
 202+ 53E1 FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 174
 202+ 53E5 84 84 84 FC
 203+ 53E9 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%11100000,%11100000,%11100000 ; char 175
 203+ 53ED E0 E0 E0 E0
 204+ 53F1 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00011100,%00011100,%00011100 ; char 176
 204+ 53F5 1C 1C 1C 1C
 205+ 53F9 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 177
 205+ 53FD 00 00 00 00
 206+ 5401 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 178
 206+ 5405 00 00 00 00
 207+ 5409 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00011100,%00011100,%00011100,%00011100 ; char 179
 207+ 540D 1C 1C 1C 1C
 208+ 5411 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%11100000,%11100000,%11100000,%11100000 ; char 180
 208+ 5415 E0 E0 E0 E0
 209+ 5419 78 78 78 78          defb %01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000 ; char 181
 209+ 541D 78 78 78 78
 210+ 5421 CC CC CC CC          defb %11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100 ; char 182
 210+ 5425 CC CC CC CC
 211+ 5429 FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 183
 211+ 542D 00 00 FC FC
 212+ 5431 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 184
 212+ 5435 FC FC 00 00
 213+ 5439 30 30 CC CC          defb %00110000,%00110000,%11001100,%11001100,%00110000,%00110000,%11001100,%11001100 ; char 185
 213+ 543D 30 30 CC CC
 214+ 5441 54 A8 54 A8          defb %01010100,%10101000,%01010100,%10101000,%01010100,%10101000,%01010100,%10101000 ; char 186
 214+ 5445 54 A8 54 A8
 215+ 5449 64 30 98 CC          defb %01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100 ; char 187
 215+ 544D 64 30 98 CC
 216+ 5451 CC 64 30 98          defb %11001100,%01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000 ; char 188
 216+ 5455 CC 64 30 98
 217+ 5459 30 98 CC 64          defb %00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100,%01100100 ; char 189
 217+ 545D 30 98 CC 64
 218+ 5461 64 CC 98 30          defb %01100100,%11001100,%10011000,%00110000,%01100100,%11001100,%10011000,%00110000 ; char 190
 218+ 5465 64 CC 98 30
 219+ 5469 20 20 F8 20          defb %00100000,%00100000,%11111000,%00100000,%00100000,%00000000,%11111000,%00000000 ; char 191 (Â±)
 219+ 546D 20 00 F8 00
 220+ 5471 C0 30 08 30          defb %11000000,%00110000,%00001000,%00110000,%11000000,%00000000,%11111000,%00000000 ; char 192 (â¥)
 220+ 5475 C0 00 F8 00
 221+ 5479 18 60 80 60          defb %00011000,%01100000,%10000000,%01100000,%00011000,%00000000,%11111000,%00000000 ; char 193 (â¤)
 221+ 547D 18 00 F8 00
 222+ 5481 3C 20 20 20          defb %00111100,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 222+ 5485 A0 60 20 00
 223+ 5489 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 223+ 548D 00 00 00 00
 224+ 5491 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 224+ 5495 70 00 00 00
 225+ 5499 00 00 54 A8          defb %00000000,%00000000,%01010100,%10101000,%00000000,%11111100,%00000000,%00000000 ; char 197
 225+ 549D 00 FC 00 00
 226+ 54A1 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 226+ 54A5 54 A8 00 00
 227+ 54A9 00 80 C0 E0          defb %00000000,%10000000,%11000000,%11100000,%11100000,%11000000,%10000000,%00000000 ; char 199
 227+ 54AD E0 C0 80 00
 228+ 54B1 FC 78 30 00          defb %11111100,%01111000,%00110000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 200
 228+ 54B5 00 00 00 00
 229+ 54B9 00 04 0C 1C          defb %00000000,%00000100,%00001100,%00011100,%00011100,%00001100,%00000100,%00000000 ; char 201
 229+ 54BD 1C 0C 04 00
 230+ 54C1 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00110000,%01111000,%11111100 ; char 202
 230+ 54C5 00 30 78 FC
 231+ 54C9 20 70 F8 20          defb %00100000,%01110000,%11111000,%00100000,%00100000,%00100000,%00100000,%00000000 ; char 203 (up arrow)
 231+ 54CD 20 20 20 00
 232+ 54D1 3C 1C 1C 24          defb %00111100,%00011100,%00011100,%00100100,%01000000,%10000000,%00000000,%00000000 ; char 204 (up right arrow)
 232+ 54D5 40 80 00 00
 233+ 54D9 00 10 18 FC          defb %00000000,%00010000,%00011000,%11111100,%00011000,%00010000,%00000000,%00000000 ; char 205 (right arrow)
 233+ 54DD 18 10 00 00
 234+ 54E1 00 00 80 40          defb %00000000,%00000000,%10000000,%01000000,%00100100,%00011100,%00011100,%00111100 ; char 206 (down right arrow)
 234+ 54E5 24 1C 1C 3C
 235+ 54E9 00 20 20 20          defb %00000000,%00100000,%00100000,%00100000,%00100000,%11111000,%01110000,%00100000 ; char 207 (down arrow)
 235+ 54ED 20 F8 70 20
 236+ 54F1 00 00 04 08          defb %00000000,%00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000 ; char 208 (down left arrow)
 236+ 54F5 90 E0 E0 F0
 237+ 54F9 00 20 60 FC          defb %00000000,%00100000,%01100000,%11111100,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 237+ 54FD 60 20 00 00
 238+ 5501 F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 238+ 5505 08 04 00 00
 239+ 5509 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 239+ 550D F0 44 38 00
 240+ 5511 00 04 78 A8          defb %00000000,%00000100,%01111000,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 240+ 5515 28 28 28 00
 241+ 5519 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00100000,%00100000,%00100000 ; char 213
 241+ 551D 1C 20 20 20
 242+ 5521 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%00010000,%00010000,%00010000 ; char 214
 242+ 5525 E0 10 10 10
 243+ 5529 10 10 10 E0          defb %00010000,%00010000,%00010000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 215
 243+ 552D 00 00 00 00
 244+ 5531 20 20 20 1C          defb %00100000,%00100000,%00100000,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 216
 244+ 5535 00 00 00 00
 245+ 5539 00 00 00 1C          defb %00000000,%00000000,%00000000,%00011100,%00111100,%00110000,%00110000,%00110000 ; char 217
 245+ 553D 3C 30 30 30
 246+ 5541 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00110000,%00110000,%00110000 ; char 218
 246+ 5545 F0 30 30 30
 247+ 5549 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 247+ 554D E0 00 00 00
 248+ 5551 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00011100,%00000000,%00000000,%00000000 ; char 220
 248+ 5555 1C 00 00 00
 249+ 5559 00 30 48 48          defb %00000000,%00110000,%01001000,%01001000,%01001000,%00110000,%00000000,%00000000 ; char 221
 249+ 555D 48 30 00 00
 250+ 5561 00 30 78 78          defb %00000000,%00110000,%01111000,%01111000,%01111000,%00110000,%00000000,%00000000 ; char 222
 250+ 5565 78 30 00 00
 251+ 5569 00 30 78 FC          defb %00000000,%00110000,%01111000,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 223
 251+ 556D FC 78 30 00
 252+ 5571 FC F8 F0 E0          defb %11111100,%11111000,%11110000,%11100000,%11100000,%11000000,%10000000,%10000000 ; char 224
 252+ 5575 E0 C0 80 80
 253+ 5579 FC 7C 3C 1C          defb %11111100,%01111100,%00111100,%00011100,%00011100,%00001100,%00000100,%00000100 ; char 225
 253+ 557D 1C 0C 04 04
 254+ 5581 04 04 0C 1C          defb %00000100,%00000100,%00001100,%00011100,%00011100,%00111100,%01111100,%11111100 ; char 226
 254+ 5585 1C 3C 7C FC
 255+ 5589 80 80 C0 E0          defb %10000000,%10000000,%11000000,%11100000,%11100000,%11110000,%11111000,%11111100 ; char 227
 255+ 558D E0 F0 F8 FC
 256+ 5591 00 04 0C D8          defb %00000000,%00000100,%00001100,%11011000,%11110000,%11100000,%11000000,%00000000 ; char 228 (checkmark)
 256+ 5595 F0 E0 C0 00
 257+ 5599 00 CC 78 30          defb %00000000,%11001100,%01111000,%00110000,%01111000,%11001100,%00000000,%00000000 ; char 229 (x)
 257+ 559D 78 CC 00 00
 258+ 55A1 70 88 88 88          defb %01110000,%10001000,%10001000,%10001000,%01110000,%00100000,%01110000,%00100000 ; char 230 (female)
 258+ 55A5 70 20 70 20
 259+ 55A9 00 1C 0C 74          defb %00000000,%00011100,%00001100,%01110100,%10010000,%10010000,%01100000,%00000000 ; char 231 (male)
 259+ 55AD 90 90 60 00
 260+ 55B1 F8 84 84 84          defb %11111000,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 232 (new doc)
 260+ 55B5 84 84 84 FC
 261+ 55B9 00 F0 FC 84          defb %00000000,%11110000,%11111100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 233 (folder)
 261+ 55BD 84 84 84 FC
 262+ 55C1 30 78 FC 48          defb %00110000,%01111000,%11111100,%01001000,%01001000,%01001000,%01001000,%01111000 ; char 234 (trash bin)
 262+ 55C5 48 48 48 78
 263+ 55C9 FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%11111100,%10110100,%10110100,%11111100 ; char 235 (floppy disk)
 263+ 55CD FC B4 B4 FC
 264+ 55D1 00 00 D4 D8          defb %00000000,%00000000,%11010100,%11011000,%11010100,%11010100,%00000000,%00000000 ; char 236 (OK)
 264+ 55D5 D4 D4 00 00
 265+ 55D9 30 78 FC 78          defb %00110000,%01111000,%11111100,%01111000,%01111000,%01001000,%01001000,%01001000 ; char 237 (home)
 265+ 55DD 78 48 48 48
 266+ 55E1 78 84 A4 A4          defb %01111000,%10000100,%10100100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 238 (clock)
 266+ 55E5 B4 84 78 00
 267+ 55E9 00 00 08 F4          defb %00000000,%00000000,%00001000,%11110100,%10101000,%10000000,%00000000,%00000000 ; char 239 (key)
 267+ 55ED A8 80 00 00
 268+ 55F1 20 30 78 B0          defb %00100000,%00110000,%01111000,%10110000,%10100000,%10001000,%01110000,%00000000 ; char 240 (undo)
 268+ 55F5 A0 88 70 00
 269+ 55F9 00 FC CC B4          defb %00000000,%11111100,%11001100,%10110100,%10000100,%10000100,%11111100,%00000000 ; char 241 (letter)
 269+ 55FD 84 84 FC 00
 270+ 5601 60 90 90 F0          defb %01100000,%10010000,%10010000,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 242 (lock)
 270+ 5605 F0 F0 F0 00
 271+ 5609 08 14 14 F0          defb %00001000,%00010100,%00010100,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 243 (unlock)
 271+ 560D F0 F0 F0 00
 272+ 5611 FC FC 84 B4          defb %11111100,%11111100,%10000100,%10110100,%10010100,%10010100,%10000100,%11111100 ; char 244 (calendar)
 272+ 5615 94 94 84 FC
 273+ 5619 00 04 38 58          defb %00000000,%00000100,%00111000,%01011000,%01101000,%01110000,%10000000,%00000000 ; char 245 (diameter)
 273+ 561D 68 70 80 00
 274+ 5621 78 84 84 84          defb %01111000,%10000100,%10000100,%10000100,%01101100,%00011000,%00001000,%00000000 ; char 246 (baloon)
 274+ 5625 6C 18 08 00
 275+ 5629 30 28 28 28          defb %00110000,%00101000,%00101000,%00101000,%00100000,%01100000,%11100000,%01000000 ; char 247 (note)
 275+ 562D 20 60 E0 40
 276+ 5631 20 68 E4 E4          defb %00100000,%01101000,%11100100,%11100100,%11100100,%01101000,%00100000,%00000000 ; char 248 (audio on)
 276+ 5635 E4 68 20 00
 277+ 5639 20 60 E0 E0          defb %00100000,%01100000,%11100000,%11100000,%11100000,%01100000,%00100000,%00000000 ; char 249 (audio off)
 277+ 563D E0 60 20 00
 278+ 5641 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11110000,%10010000 ; char 250 (pointer)
 278+ 5645 F8 FC F0 90
 279+ 5649 78 84 B4 A4          defb %01111000,%10000100,%10110100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 251 (Â©)
 279+ 564D B4 84 78 00
 280+ 5651 30 48 40 E0          defb %00110000,%01001000,%01000000,%11100000,%01000000,%01001000,%10110000,%00000000 ; char 252 (Â£)
 280+ 5655 40 48 B0 00
 281+ 5659 78 84 F0 48          defb %01111000,%10000100,%11110000,%01001000,%01001000,%00111100,%10000100,%01111000 ; char 253 (Â§)
 281+ 565D 48 3C 84 78
 282+ 5661 00 00 20 00          defb %00000000,%00000000,%00100000,%00000000,%11111000,%00000000,%00100000,%00000000 ; char 254 (Ã·)
 282+ 5665 F8 00 20 00
 283+ 5669 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 255 (cursor)
 283+ 566D FC FC FC FC
 284+ 5671                      ; here ends the ASCII table
 285+ 5671
# file closed: ../include/vdp/6x8fonts-r16.asm
  93  5671                  INCLUDE "../include/vdp/8x8fonts-r18.asm"
# file opened: ../include/vdp/8x8fonts-r18.asm
   1+ 5671              ; ------------------------------------------------------------------------------
   2+ 5671              ; LM80C - 8x8 CHARSET - R1.8
   3+ 5671              ; ------------------------------------------------------------------------------
   4+ 5671              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 5671              ; designed by Leonardo Miliani. More info at
   6+ 5671              ; www DOT leonardomiliani DOT com
   7+ 5671              ; ------------------------------------------------------------------------------
   8+ 5671              ; Code Revision:
   9+ 5671              ; R1.0 - 20190615 - First revision: ASCII chars (from 0 to 255) - actually, they are 6x8 pixels
  10+ 5671              ; R1.1 - 20190616 - Converted to 8x8 pixels
  11+ 5671              ; R1.2 - 20191013 - Added new graphic chars and reorganized previous ones
  12+ 5671              ; R1.3 - 20191015 - More graphic chars
  13+ 5671              ; R1.4 - 20191202 - Fixed char 11/12, added new special chars
  14+ 5671              ; R1.5 - 20191210 - Changed several graphic chars
  15+ 5671              ; R1.6 - 20200125 - Removed double chars, changed with new ones
  16+ 5671              ; R1.7 - 20200228 - adopted more usual hexadecimal & binary prefixes
  17+ 5671              ; R1.8 - 20200524 - New style for char #252
  18+ 5671              ; ------------------------------------------------------------------------------
  19+ 5671              ;
  20+ 5671              ;-------------------------------------------------------------------------------
  21+ 5671              ;
  22+ 5671              ;               8 x 8    C  H  A  R  S  E  T
  23+ 5671              ;
  24+ 5671              ;-------------------------------------------------------------------------------
  25+ 5671              ;
  26+ 5671              ;       8X8 CHARS, DESIGNED FOR GRAPHICS 1 MODE
  27+ 5671
  28+ 5671              CHRST88 equ $
  29+ 5671 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  29+ 5675 00 00 00 00
  30+ 5679 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  30+ 567D 00 00 00 00
  31+ 5681 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  31+ 5685 00 00 00 00
  32+ 5689 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  32+ 568D 00 00 00 00
  33+ 5691 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  33+ 5695 00 00 00 00
  34+ 5699 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  34+ 569D 00 00 00 00
  35+ 56A1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  35+ 56A5 00 00 00 00
  36+ 56A9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  36+ 56AD 00 00 00 00
  37+ 56B1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 DEL key (backspace)
  37+ 56B5 00 00 00 00
  38+ 56B9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  38+ 56BD 00 00 00 00
  39+ 56C1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  39+ 56C5 00 00 00 00
  40+ 56C9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 (unused)
  40+ 56CD 00 00 00 00
  41+ 56D1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  41+ 56D5 00 00 00 00
  42+ 56D9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 RETURN key (carriage return)
  42+ 56DD 00 00 00 00
  43+ 56E1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL key
  43+ 56E5 00 00 00 00
  44+ 56E9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  44+ 56ED 00 00 00 00
  45+ 56F1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  45+ 56F5 00 00 00 00
  46+ 56F9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  46+ 56FD 00 00 00 00
  47+ 5701 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  47+ 5705 00 00 00 00
  48+ 5709 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  48+ 570D 00 00 00 00
  49+ 5711 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT key
  49+ 5715 00 00 00 00
  50+ 5719 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  50+ 571D 00 00 00 00
  51+ 5721 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6 key
  51+ 5725 00 00 00 00
  52+ 5729 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7 key
  52+ 572D 00 00 00 00
  53+ 5731 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP key
  53+ 5735 00 00 00 00
  54+ 5739 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 HOME key
  54+ 573D 00 00 00 00
  55+ 5741 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26 INSERT key
  55+ 5745 00 00 00 00
  56+ 5749 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 ESCAPE key
  56+ 574D 00 00 00 00
  57+ 5751 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 CRSR LEFT key (cursor left)
  57+ 5755 00 00 00 00
  58+ 5759 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 CRSR RIGHT key (cursor right)
  58+ 575D 00 00 00 00
  59+ 5761 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 CRSR UP key (cursor up)
  59+ 5765 00 00 00 00
  60+ 5769 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 CRSR DOWN key (cursor down)
  60+ 576D 00 00 00 00
  61+ 5771 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32 SPACE key
  61+ 5775 00 00 00 00
  62+ 5779 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00000000,%00010000,%00000000 ; char 33 - !
  62+ 577D 10 00 10 00
  63+ 5781 28 28 28 00          defb %00101000,%00101000,%00101000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 34 - "
  63+ 5785 00 00 00 00
  64+ 5789 28 28 FE 28          defb %00101000,%00101000,%11111110,%00101000,%11111110,%00101000,%00101000,%00000000 ; char 35 - #
  64+ 578D FE 28 28 00
  65+ 5791 10 3C 50 38          defb %00010000,%00111100,%01010000,%00111000,%00010100,%01111000,%00010000,%00000000 ; char 36 - $
  65+ 5795 14 78 10 00
  66+ 5799 00 62 64 08          defb %00000000,%01100010,%01100100,%00001000,%00010000,%00100110,%01000110,%00000000 ; char 37 - %
  66+ 579D 10 26 46 00
  67+ 57A1 00 30 48 30          defb %00000000,%00110000,%01001000,%00110000,%01001010,%01000100,%00111010,%00000000 ; char 38 - &
  67+ 57A5 4A 44 3A 00
  68+ 57A9 08 10 20 00          defb %00001000,%00010000,%00100000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 39 - '
  68+ 57AD 00 00 00 00
  69+ 57B1 08 10 20 20          defb %00001000,%00010000,%00100000,%00100000,%00100000,%00010000,%00001000,%00000000 ; char 40 - (
  69+ 57B5 20 10 08 00
  70+ 57B9 20 10 08 08          defb %00100000,%00010000,%00001000,%00001000,%00001000,%00010000,%00100000,%00000000 ; char 41 - )
  70+ 57BD 08 10 20 00
  71+ 57C1 00 10 54 38          defb %00000000,%00010000,%01010100,%00111000,%00111000,%01010100,%00010000,%00000000 ; char 42 - *
  71+ 57C5 38 54 10 00
  72+ 57C9 00 10 10 7C          defb %00000000,%00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%00000000 ; char 43 - +
  72+ 57CD 10 10 00 00
  73+ 57D1 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00001000,%00010000 ; char 44 - ,
  73+ 57D5 00 18 08 10
  74+ 57D9 00 00 00 7C          defb %00000000,%00000000,%00000000,%01111100,%00000000,%00000000,%00000000,%00000000 ; char 45 - -
  74+ 57DD 00 00 00 00
  75+ 57E1 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00011000,%00000000 ; char 46 - .
  75+ 57E5 00 18 18 00
  76+ 57E9 00 02 04 08          defb %00000000,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%00000000 ; char 47 - /
  76+ 57ED 10 20 40 00
  77+ 57F1 38 44 4C 54          defb %00111000,%01000100,%01001100,%01010100,%01100100,%01000100,%00111000,%00000000 ; char 48 - 0
  77+ 57F5 64 44 38 00
  78+ 57F9 10 30 50 10          defb %00010000,%00110000,%01010000,%00010000,%00010000,%00010000,%01111100,%00000000 ; char 49 - 1
  78+ 57FD 10 10 7C 00
  79+ 5801 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 50 - 2
  79+ 5805 10 20 7C 00
  80+ 5809 7C 08 10 08          defb %01111100,%00001000,%00010000,%00001000,%00000100,%01000100,%00111000,%00000000 ; char 51 - 3
  80+ 580D 04 44 38 00
  81+ 5811 08 18 28 48          defb %00001000,%00011000,%00101000,%01001000,%01111100,%00001000,%00001000,%00000000 ; char 52 - 4
  81+ 5815 7C 08 08 00
  82+ 5819 7C 40 78 04          defb %01111100,%01000000,%01111000,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 53 - 5
  82+ 581D 04 44 38 00
  83+ 5821 38 44 40 78          defb %00111000,%01000100,%01000000,%01111000,%01000100,%01000100,%00111000,%00000000 ; char 54 - 6
  83+ 5825 44 44 38 00
  84+ 5829 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%00100000,%00100000,%00000000 ; char 55 - 7
  84+ 582D 20 20 20 00
  85+ 5831 38 44 44 38          defb %00111000,%01000100,%01000100,%00111000,%01000100,%01000100,%00111000,%00000000 ; char 56 - 8
  85+ 5835 44 44 38 00
  86+ 5839 38 44 44 3C          defb %00111000,%01000100,%01000100,%00111100,%00000100,%01000100,%00111000,%00000000 ; char 57 - 9
  86+ 583D 04 44 38 00
  87+ 5841 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00011000,%00000000,%00000000 ; char 58 - :
  87+ 5845 18 18 00 00
  88+ 5849 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00001000,%00010000,%00000000 ; char 59 - ;
  88+ 584D 18 08 10 00
  89+ 5851 04 08 10 20          defb %00000100,%00001000,%00010000,%00100000,%00010000,%00001000,%00000100,%00000000 ; char 60 - <
  89+ 5855 10 08 04 00
  90+ 5859 00 00 7E 00          defb %00000000,%00000000,%01111110,%00000000,%01111110,%00000000,%00000000,%00000000 ; char 61 - =
  90+ 585D 7E 00 00 00
  91+ 5861 20 10 08 04          defb %00100000,%00010000,%00001000,%00000100,%00001000,%00010000,%00100000,%00000000 ; char 62 - >
  91+ 5865 08 10 20 00
  92+ 5869 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00000000,%00010000,%00000000 ; char 63 - ?
  92+ 586D 10 00 10 00
  93+ 5871 78 84 BC AC          defb %01111000,%10000100,%10111100,%10101100,%10111000,%10000000,%10000100,%01111000 ; char 64 - @
  93+ 5875 B8 80 84 78
  94+ 5879 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%00000000 ; char 65 - A
  94+ 587D 7C 44 44 00
  95+ 5881 78 44 44 78          defb %01111000,%01000100,%01000100,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 66 - B
  95+ 5885 44 44 78 00
  96+ 5889 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 67 - C
  96+ 588D 40 44 38 00
  97+ 5891 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01000100,%01000100,%01111000,%00000000 ; char 68 - D
  97+ 5895 44 44 78 00
  98+ 5899 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01111100,%00000000 ; char 69 - E
  98+ 589D 40 40 7C 00
  99+ 58A1 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01000000,%00000000 ; char 70 - F
  99+ 58A5 40 40 40 00
 100+ 58A9 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01011100,%01000100,%00111000,%00000000 ; char 71 - G
 100+ 58AD 5C 44 38 00
 101+ 58B1 44 44 44 7C          defb %01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%01000100,%00000000 ; char 72 - H
 101+ 58B5 44 44 44 00
 102+ 58B9 38 10 10 10          defb %00111000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 73 - I
 102+ 58BD 10 10 38 00
 103+ 58C1 3C 04 04 04          defb %00111100,%00000100,%00000100,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 74 - J
 103+ 58C5 04 44 38 00
 104+ 58C9 44 44 48 70          defb %01000100,%01000100,%01001000,%01110000,%01001000,%01000100,%01000100,%00000000 ; char 75 - K
 104+ 58CD 48 44 44 00
 105+ 58D1 40 40 40 40          defb %01000000,%01000000,%01000000,%01000000,%01000000,%01000000,%01111100,%00000000 ; char 76 - L
 105+ 58D5 40 40 7C 00
 106+ 58D9 42 66 5A 42          defb %01000010,%01100110,%01011010,%01000010,%01000010,%01000010,%01000010,%00000000 ; char 77 - M
 106+ 58DD 42 42 42 00
 107+ 58E1 44 64 54 4C          defb %01000100,%01100100,%01010100,%01001100,%01000100,%01000100,%01000100,%00000000 ; char 78 - N
 107+ 58E5 44 44 44 00
 108+ 58E9 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 79 - O
 108+ 58ED 44 44 38 00
 109+ 58F1 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01000000,%01000000,%00000000 ; char 80 - P
 109+ 58F5 78 40 40 00
 110+ 58F9 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01010100,%01001000,%00110100,%00000000 ; char 81 - Q
 110+ 58FD 54 48 34 00
 111+ 5901 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01001000,%01000100,%00000000 ; char 82 - R
 111+ 5905 78 48 44 00
 112+ 5909 3C 40 40 38          defb %00111100,%01000000,%01000000,%00111000,%00000100,%00000100,%01111000,%00000000 ; char 83 - S
 112+ 590D 04 04 78 00
 113+ 5911 7C 10 10 10          defb %01111100,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 84 - T
 113+ 5915 10 10 10 00
 114+ 5919 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 85 - U
 114+ 591D 44 44 38 00
 115+ 5921 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 86 - V
 115+ 5925 44 28 10 00
 116+ 5929 42 42 42 42          defb %01000010,%01000010,%01000010,%01000010,%01011010,%01011010,%00100100,%00000000 ; char 87 - W
 116+ 592D 5A 5A 24 00
 117+ 5931 44 44 28 10          defb %01000100,%01000100,%00101000,%00010000,%00101000,%01000100,%01000100,%00000000 ; char 88 - X
 117+ 5935 28 44 44 00
 118+ 5939 44 44 44 28          defb %01000100,%01000100,%01000100,%00101000,%00010000,%00010000,%00010000,%00000000 ; char 89 - Y
 118+ 593D 10 10 10 00
 119+ 5941 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%01000000,%01111100,%00000000 ; char 90 - Z
 119+ 5945 20 40 7C 00
 120+ 5949 38 20 20 20          defb %00111000,%00100000,%00100000,%00100000,%00100000,%00100000,%00111000,%00000000 ; char 91 - [
 120+ 594D 20 20 38 00
 121+ 5951 00 40 20 10          defb %00000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000000 ; char 92 - \
 121+ 5955 08 04 02 00
 122+ 5959 38 08 08 08          defb %00111000,%00001000,%00001000,%00001000,%00001000,%00001000,%00111000,%00000000 ; char 93 - ]
 122+ 595D 08 08 38 00
 123+ 5961 10 28 44 00          defb %00010000,%00101000,%01000100,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 94 - ^
 123+ 5965 00 00 00 00
 124+ 5969 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%01111110,%00000000 ; char 95 _ (underscore)
 124+ 596D 00 00 7E 00
 125+ 5971 20 10 08 00          defb %00100000,%00010000,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 96 - `
 125+ 5975 00 00 00 00
 126+ 5979 00 00 38 04          defb %00000000,%00000000,%00111000,%00000100,%00111100,%01000100,%00111100,%00000000 ; char 97 - a
 126+ 597D 3C 44 3C 00
 127+ 5981 40 40 40 78          defb %01000000,%01000000,%01000000,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 98 - b
 127+ 5985 44 44 78 00
 128+ 5989 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 99 - c
 128+ 598D 40 44 38 00
 129+ 5991 04 04 04 3C          defb %00000100,%00000100,%00000100,%00111100,%01000100,%01000100,%00111100,%00000000 ; char 100 - d
 129+ 5995 44 44 3C 00
 130+ 5999 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01111100,%01000000,%00111000,%00000000 ; char 101 - e
 130+ 599D 7C 40 38 00
 131+ 59A1 18 24 20 70          defb %00011000,%00100100,%00100000,%01110000,%00100000,%00100000,%00100000,%00000000 ; char 102 - f
 131+ 59A5 20 20 20 00
 132+ 59A9 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00111000 ; char 103 - g
 132+ 59AD 44 3C 04 38
 133+ 59B1 40 40 58 64          defb %01000000,%01000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 104 - h
 133+ 59B5 44 44 44 00
 134+ 59B9 00 10 00 10          defb %00000000,%00010000,%00000000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 105 - i
 134+ 59BD 10 10 10 00
 135+ 59C1 08 00 18 08          defb %00001000,%00000000,%00011000,%00001000,%00001000,%00001000,%01001000,%00110000 ; char 106 - j
 135+ 59C5 08 08 48 30
 136+ 59C9 40 40 48 50          defb %01000000,%01000000,%01001000,%01010000,%01100000,%01010000,%01001000,%00000000 ; char 107 - k
 136+ 59CD 60 50 48 00
 137+ 59D1 30 10 10 10          defb %00110000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 108 - l
 137+ 59D5 10 10 38 00
 138+ 59D9 00 00 54 6A          defb %00000000,%00000000,%01010100,%01101010,%01001010,%01000010,%01000010,%00000000 ; char 109 - m
 138+ 59DD 4A 42 42 00
 139+ 59E1 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 110 - n
 139+ 59E5 44 44 44 00
 140+ 59E9 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 111: o
 140+ 59ED 44 44 38 00
 141+ 59F1 00 00 78 44          defb %00000000,%00000000,%01111000,%01000100,%01000100,%01111000,%01000000,%01000000 ; char 112: p
 141+ 59F5 44 78 40 40
 142+ 59F9 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00000100 ; char 113: q
 142+ 59FD 44 3C 04 04
 143+ 5A01 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000000,%01000000,%01000000,%00000000 ; char 114: r
 143+ 5A05 40 40 40 00
 144+ 5A09 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%00111000,%00000100,%01111000,%00000000 ; char 115: s
 144+ 5A0D 38 04 78 00
 145+ 5A11 20 20 70 20          defb %00100000,%00100000,%01110000,%00100000,%00100000,%00100100,%00011000,%00000000 ; char 116: t
 145+ 5A15 20 24 18 00
 146+ 5A19 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%01001100,%00110100,%00000000 ; char 117: u
 146+ 5A1D 44 4C 34 00
 147+ 5A21 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 118: v
 147+ 5A25 44 28 10 00
 148+ 5A29 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01010100,%01010100,%00101000,%00000000 ; char 119: w
 148+ 5A2D 54 54 28 00
 149+ 5A31 00 00 44 28          defb %00000000,%00000000,%01000100,%00101000,%00010000,%00101000,%01000100,%00000000 ; char 120: x
 149+ 5A35 10 28 44 00
 150+ 5A39 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01001100,%00110100,%00000100,%00111000 ; char 121: y
 150+ 5A3D 4C 34 04 38
 151+ 5A41 00 00 7C 08          defb %00000000,%00000000,%01111100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 122: z
 151+ 5A45 10 20 7C 00
 152+ 5A49 18 20 20 40          defb %00011000,%00100000,%00100000,%01000000,%00100000,%00100000,%00011000,%00000000 ; char 123: {
 152+ 5A4D 20 20 18 00
 153+ 5A51 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 124: |
 153+ 5A55 10 10 10 00
 154+ 5A59 30 08 08 04          defb %00110000,%00001000,%00001000,%00000100,%00001000,%00001000,%00110000,%00000000 ; char 125: }
 154+ 5A5D 08 08 30 00
 155+ 5A61 20 54 08 00          defb %00100000,%01010100,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 126: ~
 155+ 5A65 00 00 00 00
 156+ 5A69 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 127 (delete) - end the standard ASCII (0-127)
 156+ 5A6D 00 00 00 00
 157+ 5A71 3C 42 A5 81          defb %00111100,%01000010,%10100101,%10000001,%10100101,%10011001,%01000010,%00111100 ; char 128 (open face)
 157+ 5A75 A5 99 42 3C
 158+ 5A79 3C 7E DB FF          defb %00111100,%01111110,%11011011,%11111111,%11011011,%11100111,%01111110,%00111100 ; char 129 (full face)
 158+ 5A7D DB E7 7E 3C
 159+ 5A81 6C FE FE FE          defb %01101100,%11111110,%11111110,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 130 (hearts)
 159+ 5A85 7C 38 10 00
 160+ 5A89 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 131 (diamonds)
 160+ 5A8D 7C 38 10 00
 161+ 5A91 10 38 54 FE          defb %00010000,%00111000,%01010100,%11111110,%01010100,%00010000,%01111100,%00000000 ; char 132 (clus)
 161+ 5A95 54 10 7C 00
 162+ 5A99 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%11010110,%00010000,%01111100,%00000000 ; char 133 (spades)
 162+ 5A9D D6 10 7C 00
 163+ 5AA1 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 134
 163+ 5AA5 FF 18 18 18
 164+ 5AA9 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 135
 164+ 5AAD 1F 18 18 18
 165+ 5AB1 00 00 00 F8          defb %00000000,%00000000,%00000000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 136
 165+ 5AB5 F8 18 18 18
 166+ 5AB9 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00000000,%00000000,%00000000 ; char 137
 166+ 5ABD F8 00 00 00
 167+ 5AC1 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00000000,%00000000,%00000000 ; char 138
 167+ 5AC5 1F 00 00 00
 168+ 5AC9 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 139
 168+ 5ACD FF 00 00 00
 169+ 5AD1 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 140
 169+ 5AD5 1F 18 18 18
 170+ 5AD9 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 141
 170+ 5ADD FF 18 18 18
 171+ 5AE1 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 142
 171+ 5AE5 F8 18 18 18
 172+ 5AE9 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 143
 172+ 5AED FF 00 00 00
 173+ 5AF1 18 18 18 18          defb %00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000 ; char 144
 173+ 5AF5 18 18 18 18
 174+ 5AF9 03 07 0E 1C          defb %00000011,%00000111,%00001110,%00011100,%00111000,%01110000,%11100000,%11000000 ; char 145
 174+ 5AFD 38 70 E0 C0
 175+ 5B01 C0 E0 70 38          defb %11000000,%11100000,%01110000,%00111000,%00011100,%00001110,%00000111,%00000011 ; char 146
 175+ 5B05 1C 0E 07 03
 176+ 5B09 C3 E7 7E 3C          defb %11000011,%11100111,%01111110,%00111100,%00111100,%01111110,%11100111,%11000011 ; char 147
 176+ 5B0D 3C 7E E7 C3
 177+ 5B11 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 148
 177+ 5B15 10 10 10 10
 178+ 5B19 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 149
 178+ 5B1D 10 10 10 10
 179+ 5B21 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 150
 179+ 5B25 10 10 10 10
 180+ 5B29 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 151
 180+ 5B2D 00 00 00 00
 181+ 5B31 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00000000,%00000000,%00000000,%00000000 ; char 152
 181+ 5B35 00 00 00 00
 182+ 5B39 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 153
 182+ 5B3D 00 00 00 00
 183+ 5B41 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 154
 183+ 5B45 10 10 10 10
 184+ 5B49 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 155
 184+ 5B4D 10 10 10 10
 185+ 5B51 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 156
 185+ 5B55 10 10 10 10
 186+ 5B59 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 157
 186+ 5B5D 00 00 00 00
 187+ 5B61 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000 ; char 158
 187+ 5B65 10 10 10 10
 188+ 5B69 01 02 04 08          defb %00000001,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%10000000 ; char 159
 188+ 5B6D 10 20 40 80
 189+ 5B71 80 40 20 10          defb %10000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000001 ; char 160
 189+ 5B75 08 04 02 01
 190+ 5B79 81 42 24 18          defb %10000001,%01000010,%00100100,%00011000,%00011000,%00100100,%01000010,%10000001 ; char 161
 190+ 5B7D 18 24 42 81
 191+ 5B81 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 162
 191+ 5B85 00 00 FF FF
 192+ 5B89 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; char 163
 192+ 5B8D FF FF FF FF
 193+ 5B91 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 164
 193+ 5B95 FF FF FF FF
 194+ 5B99 FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 194+ 5B9D 00 00 00 00
 195+ 5BA1 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 166
 195+ 5BA5 00 00 00 00
 196+ 5BA9 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 167
 196+ 5BAD FF FF 00 00
 197+ 5BB1 C0 C0 C0 C0          defb %11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000 ; char 168
 197+ 5BB5 C0 C0 C0 C0
 198+ 5BB9 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; char 169
 198+ 5BBD F0 F0 F0 F0
 199+ 5BC1 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 170
 199+ 5BC5 FC FC FC FC
 200+ 5BC9 03 03 03 03          defb %00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011 ; char 171
 200+ 5BCD 03 03 03 03
 201+ 5BD1 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; char 172
 201+ 5BD5 0F 0F 0F 0F
 202+ 5BD9 3F 3F 3F 3F          defb %00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111 ; char 173
 202+ 5BDD 3F 3F 3F 3F
 203+ 5BE1 FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 174
 203+ 5BE5 81 81 81 FF
 204+ 5BE9 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; char 175
 204+ 5BED F0 F0 F0 F0
 205+ 5BF1 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; char 176
 205+ 5BF5 0F 0F 0F 0F
 206+ 5BF9 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; char 177
 206+ 5BFD 00 00 00 00
 207+ 5C01 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 178
 207+ 5C05 00 00 00 00
 208+ 5C09 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00001111,%00001111,%00001111,%00001111 ; char 179
 208+ 5C0D 0F 0F 0F 0F
 209+ 5C11 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%11110000,%11110000,%11110000,%11110000 ; char 180
 209+ 5C15 F0 F0 F0 F0
 210+ 5C19 3C 3C 3C 3C          defb %00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100 ; char 181
 210+ 5C1D 3C 3C 3C 3C
 211+ 5C21 C3 C3 C3 C3          defb %11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011 ; char 182
 211+ 5C25 C3 C3 C3 C3
 212+ 5C29 FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 183
 212+ 5C2D 00 00 FF FF
 213+ 5C31 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 184
 213+ 5C35 FF FF 00 00
 214+ 5C39 33 33 CC CC          defb %00110011,%00110011,%11001100,%11001100,%00110011,%00110011,%11001100,%11001100 ; char 185
 214+ 5C3D 33 33 CC CC
 215+ 5C41 55 AA 55 AA          defb %01010101,%10101010,%01010101,%10101010,%01010101,%10101010,%01010101,%10101010 ; char 186
 215+ 5C45 55 AA 55 AA
 216+ 5C49 66 33 99 CC          defb %01100110,%00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100 ; char 187
 216+ 5C4D 66 33 99 CC
 217+ 5C51 CC 99 33 66          defb %11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011,%01100110 ; char 188
 217+ 5C55 CC 99 33 66
 218+ 5C59 33 99 CC 66          defb %00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100,%01100110 ; char 189
 218+ 5C5D 33 99 CC 66
 219+ 5C61 66 CC 99 33          defb %01100110,%11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011 ; char 190
 219+ 5C65 66 CC 99 33
 220+ 5C69 10 10 7C 10          defb %00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%01111100,%00000000 ; char 191 (Â±)
 220+ 5C6D 10 00 7C 00
 221+ 5C71 60 18 06 18          defb %01100000,%00011000,%00000110,%00011000,%01100000,%00000000,%01111110,%00000000 ; char 192 (â¥)
 221+ 5C75 60 00 7E 00
 222+ 5C79 06 18 60 18          defb %00000110,%00011000,%01100000,%00011000,%00000110,%00000000,%01111110,%00000000 ; char 193 (â¤)
 222+ 5C7D 06 00 7E 00
 223+ 5C81 3E 20 20 20          defb %00111110,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 223+ 5C85 A0 60 20 00
 224+ 5C89 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 224+ 5C8D 00 00 00 00
 225+ 5C91 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 225+ 5C95 70 00 00 00
 226+ 5C99 00 00 2A 54          defb %00000000,%00000000,%00101010,%01010100,%00000000,%01111110,%00000000,%00000000 ; char 197
 226+ 5C9D 00 7E 00 00
 227+ 5CA1 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 227+ 5CA5 54 A8 00 00
 228+ 5CA9 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11100000,%11000000,%10000000,%00000000 ; char 199
 228+ 5CAD E0 C0 80 00
 229+ 5CB1 FE 7C 38 10          defb %11111110,%01111100,%00111000,%00010000,%00000000,%00000000,%00000000,%00000000 ; char 200
 229+ 5CB5 00 00 00 00
 230+ 5CB9 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00000111,%00000011,%00000001,%00000000 ; char 201
 230+ 5CBD 07 03 01 00
 231+ 5CC1 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00010000,%00111000,%01111100,%11111110 ; char 202
 231+ 5CC5 10 38 7C FE
 232+ 5CC9 10 38 7C 10          defb %00010000,%00111000,%01111100,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 203 (up arrow)
 232+ 5CCD 10 10 10 00
 233+ 5CD1 1E 0E 0E 12          defb %00011110,%00001110,%00001110,%00010010,%00100000,%01000000,%00000000,%00000000 ; char 204 (up right arrow)
 233+ 5CD5 20 40 00 00
 234+ 5CD9 00 08 0C FE          defb %00000000,%00001000,%00001100,%11111110,%00001100,%00001000,%00000000,%00000000 ; char 205 (right arrow)
 234+ 5CDD 0C 08 00 00
 235+ 5CE1 00 40 20 12          defb %00000000,%01000000,%00100000,%00010010,%00001110,%00001110,%00011110,%00000000 ; char 206 (down right arrow)
 235+ 5CE5 0E 0E 1E 00
 236+ 5CE9 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%01111100,%00111000,%00010000,%00000000 ; char 207 (down arrow)
 236+ 5CED 7C 38 10 00
 237+ 5CF1 00 04 08 90          defb %00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000,%00000000 ; char 208 (down left arrow)
 237+ 5CF5 E0 E0 F0 00
 238+ 5CF9 00 20 60 FE          defb %00000000,%00100000,%01100000,%11111110,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 238+ 5CFD 60 20 00 00
 239+ 5D01 F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 239+ 5D05 08 04 00 00
 240+ 5D09 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 240+ 5D0D F0 44 38 00
 241+ 5D11 00 02 7C A8          defb %00000000,%00000010,%01111100,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 241+ 5D15 28 28 28 00
 242+ 5D19 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001000,%00010000,%00010000,%00010000 ; char 213
 242+ 5D1D 08 10 10 10
 243+ 5D21 00 00 00 C0          defb %00000000,%00000000,%00000000,%11000000,%00100000,%00010000,%00010000,%00010000 ; char 214
 243+ 5D25 20 10 10 10
 244+ 5D29 10 10 20 C0          defb %00010000,%00010000,%00100000,%11000000,%00000000,%00000000,%00000000,%00000000 ; char 215
 244+ 5D2D 00 00 00 00
 245+ 5D31 10 10 08 07          defb %00010000,%00010000,%00001000,%00000111,%00000000,%00000000,%00000000,%00000000 ; char 216
 245+ 5D35 00 00 00 00
 246+ 5D39 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001111,%00011100,%00011000,%00011000 ; char 217
 246+ 5D3D 0F 1C 18 18
 247+ 5D41 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00111000,%00011000,%00011000 ; char 218
 247+ 5D45 F0 38 18 18
 248+ 5D49 18 18 38 F0          defb %00011000,%00011000,%00111000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 248+ 5D4D E0 00 00 00
 249+ 5D51 18 18 1C 0F          defb %00011000,%00011000,%00011100,%00001111,%00000111,%00000000,%00000000,%00000000 ; char 220
 249+ 5D55 07 00 00 00
 250+ 5D59 00 3C 42 42          defb %00000000,%00111100,%01000010,%01000010,%01000010,%01000010,%00111100,%00000000 ; char 221
 250+ 5D5D 42 42 3C 00
 251+ 5D61 00 3C 7E 7E          defb %00000000,%00111100,%01111110,%01111110,%01111110,%01111110,%00111100,%00000000 ; char 222
 251+ 5D65 7E 7E 3C 00
 252+ 5D69 00 18 3C 7E          defb %00000000,%00011000,%00111100,%01111110,%01111110,%00111100,%00011000,%00000000 ; char 223
 252+ 5D6D 7E 3C 18 00
 253+ 5D71 FF FE FC F8          defb %11111111,%11111110,%11111100,%11111000,%11110000,%11100000,%11000000,%10000000 ; char 224
 253+ 5D75 F0 E0 C0 80
 254+ 5D79 FF 7F 3F 1F          defb %11111111,%01111111,%00111111,%00011111,%00001111,%00000111,%00000011,%00000001 ; char 225
 254+ 5D7D 0F 07 03 01
 255+ 5D81 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00011111,%00111111,%01111111,%11111111 ; char 226
 255+ 5D85 1F 3F 7F FF
 256+ 5D89 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11111110,%11111111 ; char 227
 256+ 5D8D F8 FC FE FF
 257+ 5D91 00 02 06 6C          defb %00000000,%00000010,%00000110,%01101100,%01111000,%01110000,%01100000,%00000000 ; char 228 (checkmark)
 257+ 5D95 78 70 60 00
 258+ 5D99 00 66 3C 18          defb %00000000,%01100110,%00111100,%00011000,%00111100,%01100110,%00000000,%00000000 ; char 229 (x)
 258+ 5D9D 3C 66 00 00
 259+ 5DA1 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%00111000,%00010000,%00111000,%00010000 ; char 230 (female)
 259+ 5DA5 38 10 38 10
 260+ 5DA9 07 03 3D 44          defb %00000111,%00000011,%00111101,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 231 (male)
 260+ 5DAD 44 44 38 00
 261+ 5DB1 78 44 42 42          defb %01111000,%01000100,%01000010,%01000010,%01000010,%01000010,%01000010,%01111110 ; char 232 (new doc)
 261+ 5DB5 42 42 42 7E
 262+ 5DB9 00 F8 FF 81          defb %00000000,%11111000,%11111111,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 233 (folder)
 262+ 5DBD 81 81 81 FF
 263+ 5DC1 10 7C FE 54          defb %00010000,%01111100,%11111110,%01010100,%01010100,%01010100,%01010100,%01111100 ; char 234 (trash bin)
 263+ 5DC5 54 54 54 7C
 264+ 5DC9 FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10111101,%10101101,%10101101,%11111111 ; char 235 (floppy disk)
 264+ 5DCD BD AD AD FF
 265+ 5DD1 00 EA AA AC          defb %00000000,%11101010,%10101010,%10101100,%10101100,%10101010,%11101010,%00000000 ; char 236 (OK)
 265+ 5DD5 AC AA EA 00
 266+ 5DD9 18 7E FF 7E          defb %00011000,%01111110,%11111111,%01111110,%01111110,%01100110,%01100110,%01100110 ; char 237 (home)
 266+ 5DDD 7E 66 66 66
 267+ 5DE1 3C 42 91 91          defb %00111100,%01000010,%10010001,%10010001,%10011101,%10000001,%01000010,%00111100 ; char 238 (clock)
 267+ 5DE5 9D 81 42 3C
 268+ 5DE9 00 02 05 FD          defb %00000000,%00000010,%00000101,%11111101,%10100101,%10100010,%00000000,%00000000 ; char 239 (key)
 268+ 5DED A5 A2 00 00
 269+ 5DF1 08 0C 3E 4C          defb %00001000,%00001100,%00111110,%01001100,%01001000,%01000010,%01000010,%00111100 ; char 240 (undo)
 269+ 5DF5 48 42 42 3C
 270+ 5DF9 00 FF C3 A5          defb %00000000,%11111111,%11000011,%10100101,%10011001,%10000001,%11111111,%00000000 ; char 241 (letter)
 270+ 5DFD 99 81 FF 00
 271+ 5E01 38 44 44 7C          defb %00111000,%01000100,%01000100,%01111100,%01111100,%01111100,%01111100,%00000000 ; char 242 (lock)
 271+ 5E05 7C 7C 7C 00
 272+ 5E09 06 09 09 F8          defb %00000110,%00001001,%00001001,%11111000,%11111000,%11111000,%11111000,%00000000 ; char 243 (unlock)
 272+ 5E0D F8 F8 F8 00
 273+ 5E11 FF FF 81 AD          defb %11111111,%11111111,%10000001,%10101101,%10100101,%10100101,%10000001,%11111111 ; char 244 (calendar)
 273+ 5E15 A5 A5 81 FF
 274+ 5E19 01 1A 24 4A          defb %00000001,%00011010,%00100100,%01001010,%01010010,%00100100,%01011000,%10000000 ; char 245 (diameter)
 274+ 5E1D 52 24 58 80
 275+ 5E21 7E 81 81 81          defb %01111110,%10000001,%10000001,%10000001,%10000001,%01110110,%00001100,%00000100 ; char 246 (baloon)
 275+ 5E25 81 76 0C 04
 276+ 5E29 0C 0A 0A 0A          defb %00001100,%00001010,%00001010,%00001010,%00001000,%00011000,%00111000,%00010000 ; char 247 (note)
 276+ 5E2D 08 18 38 10
 277+ 5E31 12 31 F5 F5          defb %00010010,%00110001,%11110101,%11110101,%11110101,%11110101,%00110001,%00010010 ; char 248 (audio on)
 277+ 5E35 F5 F5 31 12
 278+ 5E39 10 30 F0 F0          defb %00010000,%00110000,%11110000,%11110000,%11110000,%11110000,%00110000,%00010000 ; char 249 (audio off)
 278+ 5E3D F0 F0 30 10
 279+ 5E41 40 60 70 78          defb %01000000,%01100000,%01110000,%01111000,%01111100,%01111110,%01111000,%01001000 ; char 250 (pointer)
 279+ 5E45 7C 7E 78 48
 280+ 5E49 3C 42 99 A1          defb %00111100,%01000010,%10011001,%10100001,%10100001,%10011001,%01000010,%00111100 ; char 251 (Â©)
 280+ 5E4D A1 99 42 3C
 281+ 5E51 18 24 20 78          defb %00011000,%00100100,%00100000,%01111000,%00100000,%00100010,%01011100,%00000000 ; char 252 (Â£)
 281+ 5E55 20 22 5C 00
 282+ 5E59 3C 42 78 24          defb %00111100,%01000010,%01111000,%00100100,%00100100,%00011110,%01000010,%00111100 ; char 253 (Â§)
 282+ 5E5D 24 1E 42 3C
 283+ 5E61 00 00 10 00          defb %00000000,%00000000,%00010000,%00000000,%01111100,%00000000,%00010000,%00000000 ; char 254 (Ã·)
 283+ 5E65 7C 00 10 00
 284+ 5E69 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 255 (cursor)
 284+ 5E6D FF FF FF FF
 285+ 5E71
# file closed: ../include/vdp/8x8fonts-r18.asm
  94  5E71                  INCLUDE "../include/vdp/logo-fonts.asm"
# file opened: ../include/vdp/logo-fonts.asm
   1+ 5E71              ; ------------------------------------------------------------------------------
   2+ 5E71              ; LM80C - LOGO CHARSET - R1.1
   3+ 5E71              ; ------------------------------------------------------------------------------
   4+ 5E71              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 5E71              ; designed by Leonardo Miliani. More info at
   6+ 5E71              ; www DOT leonardomiliani DOT com
   7+ 5E71              ; ------------------------------------------------------------------------------
   8+ 5E71              ; Code Revision:
   9+ 5E71              ; R1.0 - 20200124 - First revision: logo chars
  10+ 5E71              ; R1.1 - 20200229 - Adopted usual hexadecimal & binary prefixes
  11+ 5E71              ; ------------------------------------------------------------------------------
  12+ 5E71
  13+ 5E71              LOGOFONT:   equ $
  14+ 5E71 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; 0
  14+ 5E75 00 00 00 00
  15+ 5E79 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; 1
  15+ 5E7D FF FF FF FF
  16+ 5E81 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; 2
  16+ 5E85 00 00 00 00
  17+ 5E89 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; 3
  17+ 5E8D 0F 0F 0F 0F
  18+ 5E91 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; 4
  18+ 5E95 FF FF FF FF
  19+ 5E99 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; 5
  19+ 5E9D F0 F0 F0 F0
  20+ 5EA1 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; 6
  20+ 5EA5 0F 0F 0F 0F
  21+ 5EA9 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; 7
  21+ 5EAD F0 F0 F0 F0
  22+ 5EB1 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; 8
  22+ 5EB5 00 00 00 00
  23+ 5EB9 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; 9
  23+ 5EBD 00 00 00 00
  24+ 5EC1 00 00 00 FC              defb %00000000,%00000000,%00000000,%11111100,%11111111,%00000111,%00000011,%00000000 ; 10
  24+ 5EC5 FF 07 03 00
  25+ 5EC9 00 00 00 3F              defb %00000000,%00000000,%00000000,%00111111,%11111111,%11100000,%11000000,%00000000 ; 11
  25+ 5ECD FF E0 C0 00
  26+ 5ED1 18 18 1F 19              defb %00011000,%00011000,%00011111,%00011001,%00011001,%00011111,%00011000,%00011000 ; 12
  26+ 5ED5 19 1F 18 18
  27+ 5ED9 18 18 F8 98              defb %00011000,%00011000,%11111000,%10011000,%10011000,%11111000,%00011000,%00011000 ; 13
  27+ 5EDD 98 F8 18 18
  28+ 5EE1 18 18 1C 1F              defb %00011000,%00011000,%00011100,%00011111,%00001111,%00000000,%00000000,%00000000 ; 14
  28+ 5EE5 0F 00 00 00
  29+ 5EE9 00 00 00 0F              defb %00000000,%00000000,%00000000,%00001111,%00011111,%00011100,%00011000,%00011000 ; 15
  29+ 5EED 1F 1C 18 18
  30+ 5EF1 00 00 00 F0              defb %00000000,%00000000,%00000000,%11110000,%11111000,%00111000,%00011000,%00011000 ; 16
  30+ 5EF5 F8 38 18 18
  31+ 5EF9 18 18 38 F8              defb %00011000,%00011000,%00111000,%11111000,%11110000,%00000000,%00000000,%00000000 ; 17
  31+ 5EFD F0 00 00 00
  32+ 5F01 00 00 00 FF              defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; 18
  32+ 5F05 FF 00 00 00
  33+ 5F09 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%11111111,%11111111,%11111111,%11111111 ; 19
  33+ 5F0D FF FF FF FF
  34+ 5F11 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11111111,%11111111,%11111111,%11111111 ; 20
  34+ 5F15 FF FF FF FF
  35+ 5F19 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11110000,%11110000,%11110000,%11110000 ; 21
  35+ 5F1D F0 F0 F0 F0
  36+ 5F21 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00001111,%00001111,%00001111,%00001111 ; 22
  36+ 5F25 0F 0F 0F 0F
  37+ 5F29 00 30 78 78              defb %00000000,%00110000,%01111000,%01111000,%00110000,%00000000,%00000000,%00000000 ; 23
  37+ 5F2D 30 00 00 00
  38+ 5F31
# file closed: ../include/vdp/logo-fonts.asm
  95  5F31
  96  5F31              ; include ROM/RAM switcher
  97  5F31                  INCLUDE "../include/switcher/switcher-r11.asm"
# file opened: ../include/switcher/switcher-r11.asm
   1+ 5F31              ; ------------------------------------------------------------------------------
   2+ 5F31              ; LM80C - ROM/RAM SWITCHER - R1.1
   3+ 5F31              ; ------------------------------------------------------------------------------
   4+ 5F31              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 5F31              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 5F31              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 5F31              ; kind of warranty: you can use them at your own risk.
   8+ 5F31              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 5F31              ; maintain the copyright notices, include this advice and the note to the
  10+ 5F31              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 5F31              ; redistribuite them.
  12+ 5F31              ; https://www.leonardomiliani.com
  13+ 5F31              ;
  14+ 5F31              ; Please support me by visiting the following links:
  15+ 5F31              ; Main project page: https://www.leonardomiliani.com
  16+ 5F31              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 5F31              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 5F31              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 5F31              ; ------------------------------------------------------------------------------
  20+ 5F31              ; Code Revision:
  21+ 5F31              ; R1.0   - 20200718 - First version
  22+ 5F31              ; R1.1   - 20200827 - PIO settings now are part of the file
  23+ 5F31              ;-------------------------------------------------------------------------------
  24+ 5F31
  25+ 5F31              TMP_FW_LOC:     equ     $8000           ; address from where to make a temporary copy of the FW
  26+ 5F31              ;-------------------------------------------------------------------------------
  27+ 5F31              ; THIS CODE WILL BE EXECUTED FROM RAM
  28+ 5F31 3E FC        RAMRUN:         ld      A,%11111100     ; set ROM off and RAM on..
  29+ 5F33 D3 01                        out     (PIO_DB),A      ; ...by setting bit #0 to 0 (and leave VRAM bank #0)
  30+ 5F35 01 75 5F                     ld      BC,END_OF_FW    ; let's copy back FW into low RAM - bytes to copy
  31+ 5F38 21 00 80                     ld      HL,TMP_FW_LOC   ; source address
  32+ 5F3B 11 00 00                     ld      DE,$0000        ; dest. address
  33+ 5F3E ED B0                        ldir                    ; copy!
  34+ 5F40 AF                           xor     A
  35+ 5F41 D3 01                        out     (PIO_DB),A      ; all LEDs off - finished copying
  36+ 5F43 C3 AE 02                     jp      INIT_HW         ; return control to old init (now into RAM)
  37+ 5F46
  38+ 5F46              ;-------------------------------------------------------------------------------
  39+ 5F46              ; copy the whole contents of ROM into RAM then disable the first memory
  40+ 5F46 3A D2 5F     ROM2RAM:        ld      A,(basicStarted); check if BASIC is already started
  41+ 5F49 FE 59                        cp      'Y'             ; to see if this is a power-up
  42+ 5F4B 20 0F                        jr      NZ,CNTCP2RAM    ; no, continue copy to RAM
  43+ 5F4D                              ; WARNING: Do **NOT** change the following "out()" sequence, ABSOLUTELY!
  44+ 5F4D 3E CF                        ld      A,%11001111     ; set mode 3 ("control mode")
  45+ 5F4F D3 03                        out     (PIO_CB),A      ; for PIO port B
  46+ 5F51 AF                           xor     A               ; set LEDs off, RAM on, VRAM on bank #0
  47+ 5F52 D3 01                        out     (PIO_DB),A      ; send settings to PIO register
  48+ 5F54 D3 03                        out     (PIO_CB),A      ; set pins following register's status
  49+ 5F56 21 04 61                     ld      HL,TEMPSTACK    ; temporary stack
  50+ 5F59 C3 B1 02                     jp      INIT_HW2        ; jump to re-init HW
  51+ 5F5C
  52+ 5F5C                              ; WARNING: Do **NOT** change the following "out()" sequence, ABSOLUTELY!
  53+ 5F5C 3E CF        CNTCP2RAM:      ld      A,%11001111     ; set mode 3 (mode control)
  54+ 5F5E D3 03                        out     (PIO_CB),A      ; for PIO port B
  55+ 5F60 3E FD                        ld      A,%11111101     ; set pin #0 as HIGH to enable ROM
  56+ 5F62 D3 01                        out     (PIO_DB),A      ; store the value into the internal register
  57+ 5F64 AF                           xor     A               ; set pins to OUTPUT
  58+ 5F65 D3 03                        out     (PIO_CB),A      ; for port B, activating the RAM
  59+ 5F67 01 75 5F                     ld      BC,END_OF_FW    ; copy FW from ROM to high RAM
  60+ 5F6A 21 00 00                     ld      HL,$0000        ; source address
  61+ 5F6D 11 00 80                     ld      DE,TMP_FW_LOC   ; dest. address
  62+ 5F70 ED B0                        ldir                    ; copy!
  63+ 5F72 C3 31 DF                     jp      RAMRUN+TMP_FW_LOC; jump to execute code into RAM
  64+ 5F75
  65+ 5F75              ;-------------------------------------------------------------------------------
  66+ 5F75              END_OF_FW:      equ     $   ; this is the last cell of the firmware
# file closed: ../include/switcher/switcher-r11.asm
  98  5F75
  99  5F75              ; include workspace equates
 100  5F75                  INCLUDE "../include/workspace/workspace-r1.1.asm"
# file opened: ../include/workspace/workspace-r1.1.asm
   1+ 5F75              ; ------------------------------------------------------------------------------
   2+ 5F75              ; LM80C 64K - WORKSPACE EQUATES - R1.1
   3+ 5F75              ; ------------------------------------------------------------------------------
   4+ 5F75              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 5F75              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 5F75              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 5F75              ; kind of warranty: you can use them at your own risk.
   8+ 5F75              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 5F75              ; maintain the copyright notices, include this advice and the note to the
  10+ 5F75              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 5F75              ; redistribuite them.
  12+ 5F75              ; https://www.leonardomiliani.com
  13+ 5F75              ;
  14+ 5F75              ; Please support me by visiting the following links:
  15+ 5F75              ; Main project page: https://www.leonardomiliani.com
  16+ 5F75              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 5F75              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 5F75              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 5F75              ; ------------------------------------------------------------------------------
  20+ 5F75
  21+ 5F75              ; set starting of RAM based on computer model
  22+ 5F75                  IFDEF LM80C64K
  23+ 5F75              SERBUF_START    equ     END_OF_FW       ; RAM starts here
  24+ 5F75                  ELSE
  25+ 5F75 ~            SERBUF_START    equ     $8000           ; RAM starts here
  26+ 5F75                  ENDIF
  27+ 5F75
  28+ 5F75              ;-------------------------------------------------------------------------------
  29+ 5F75              serInPtr        equ     SERBUF_START + SER_BUFSIZE
  30+ 5F75              serRdPtr        equ     serInPtr+2
  31+ 5F75              serBufUsed      equ     serRdPtr+2
  32+ 5F75              basicStarted    equ     serBufUsed+1
  33+ 5F75              bufWrap         equ     (SERBUF_START + SER_BUFSIZE) & $FF
  34+ 5F75              TEMPSTACK       equ     CURPOS - 3      ; top of BASIC line input buffer so is "free ram" when BASIC resets
  35+ 5F75
  36+ 5F75              ; BASIC WORK SPACE LOCATIONS
  37+ 5F75              ; THE INTERPRETER ALLOCATES THE FOLLOWING RAM CELLS
  38+ 5F75              ; TO STORE IMPORTANT VALUES USED FOR SOME SPECIFIC FUNCTIONS:
  39+ 5F75              ; THEY CAN BE VECTOR (ADDRESSES) FUNCTIONS, SYSTEM DATAS (I.E. VARIABLES)
  40+ 5F75              ; AND SO ON. THE FIRST CELLS ARE FILLED WITH VALUES STORED INTO ROM AT $(INITAB) ADDRESS
  41+ 5F75              WRKSPC          equ     basicStarted+$01; (3) BASIC Work space
  42+ 5F75              NMIUSR          equ     WRKSPC+$03      ; (3) NMI exit point routine
  43+ 5F75              USR             equ     NMIUSR+$03      ; (3) "USR (x)" jump  <-- in (USR+$01)/(USR+$02) the user can store the address of a specific machine language routine
  44+ 5F75              OUTSUB          equ     USR+$03         ; (1) "out p,n"
  45+ 5F75              OTPORT          equ     OUTSUB+$01      ; (2) Port (p)
  46+ 5F75              DIVSUP          equ     OTPORT+$02      ; (1) Division support routine
  47+ 5F75              DIV1            equ     DIVSUP+$01      ; (4) <- Values
  48+ 5F75              DIV2            equ     DIV1+$04        ; (4) <-   to
  49+ 5F75              DIV3            equ     DIV2+$04        ; (3) <-   be
  50+ 5F75              DIV4            equ     DIV3+$03        ; (2) <-inserted
  51+ 5F75              SEED            equ     DIV4+$02        ; (35) Random number seed  <-- starting address of a seed table
  52+ 5F75              LSTRND          equ     SEED+$23        ; (4) Last random number
  53+ 5F75              INPSUB          equ     LSTRND+$04      ; (1) INP A,(x) Routine
  54+ 5F75              INPORT          equ     INPSUB+$01      ; (2) PORT (x)
  55+ 5F75              LWIDTH          equ     INPORT+$02      ; (1) Terminal width
  56+ 5F75              COMMAN          equ     LWIDTH+$01      ; (1) Width for commas
  57+ 5F75              NULFLG          equ     COMMAN+$01      ; (1) Null after input byte flag
  58+ 5F75              CTLOFG          equ     NULFLG+$01      ; (1) Control "O" flag
  59+ 5F75              CHKSUM          equ     CTLOFG+$01      ; (2) Array load/save check sum
  60+ 5F75              NMIFLG          equ     CHKSUM+$02      ; (1) Flag for NMI break routine
  61+ 5F75              BRKFLG          equ     NMIFLG+$01      ; (1) Break flag
  62+ 5F75              RINPUT          equ     BRKFLG+$01      ; (3) Input reflection
  63+ 5F75              STRSPC          equ     RINPUT+$03      ; (2) Pointer to bottom (start) of string space - default is 100 bytes below the top of memory
  64+ 5F75              LINEAT          equ     STRSPC+$02      ; (2) Current line number. -1 means "direct mode", while -2 means cold start.
  65+ 5F75              HLPLN           equ     LINEAT+$02      ; (2) Current line with errors
  66+ 5F75              KEYDEL          equ     HLPLN+$02       ; (1) delay before key auto-repeat starts
  67+ 5F75              AUTOKE          equ     KEYDEL+$01      ; (1) delay for key auto-repeat
  68+ 5F75              FNKEYS          equ     AUTOKE+$01      ; (128) default text of FN keys
  69+ 5F75              BASTXT          equ     FNKEYS+$80      ; (3) Pointer to start of BASIC program in memory
  70+ 5F75              ; - - - - - - - - - - - - - - - - - - -   the above are locations pre-filled by the firmware at startup
  71+ 5F75              BUFFER          equ     BASTXT+$03      ; (5) Input buffer
  72+ 5F75              STACK           equ     BUFFER+$05      ; (85) Initial stack
  73+ 5F75              CURPOS          equ     STACK+$55       ; (1) Character position on line
  74+ 5F75              LCRFLG          equ     CURPOS+$01      ; (1) Locate/Create flag for DIM statement
  75+ 5F75              TYPE            equ     LCRFLG+$01      ; (1) Data type flag: 0=numeric, non-zero=string
  76+ 5F75              DATFLG          equ     TYPE+$01        ; (1) Literal statement flag
  77+ 5F75              LSTRAM          equ     DATFLG+$01      ; (2) Last available RAM location for BASIC
  78+ 5F75              DOSBFR          equ     LSTRAM+$02      ; (2) Start of temporary buffer used by DOS for load/save files (32 bytes below the I/O buffer)
  79+ 5F75              IOBUFF          equ     DOSBFR+$02      ; (2) Start of I/O buffer used by DOS to store/retrieve disk sectors
  80+ 5F75              DOSER           equ     IOBUFF+$02      ; (1) Error from DOS
  81+ 5F75              TMPDBF          equ     DOSER+$01       ; (36) Secondary buffer for DOS
  82+ 5F75              TMSTPT          equ     TMPDBF+$24      ; (2) Temporary string pointer
  83+ 5F75              TMSTPL          equ     TMSTPT+$02      ; (12) Temporary string pool
  84+ 5F75              TMPSTR          equ     TMSTPL+$0C      ; (4) Temporary string
  85+ 5F75              STRBOT          equ     TMPSTR+$04      ; (2) Bottom of string space
  86+ 5F75              CUROPR          equ     STRBOT+$02      ; (2) Current operator in EVAL
  87+ 5F75              LOOPST          equ     CUROPR+$02      ; (2) First statement of loop
  88+ 5F75              DATLIN          equ     LOOPST+$02      ; (2) Line of current DATA item
  89+ 5F75              FORFLG          equ     DATLIN+$02      ; (1) "FOR" loop flag
  90+ 5F75              LSTBIN          equ     FORFLG+$01      ; (1) Last byte entered
  91+ 5F75              READFG          equ     LSTBIN+$01      ; (1) Read/Input flag
  92+ 5F75              BRKLIN          equ     READFG+$01      ; (2) Line of break
  93+ 5F75              NXTOPR          equ     BRKLIN+$02      ; (2) Next operator in EVAL
  94+ 5F75              ERRLIN          equ     NXTOPR+$02      ; (2) Line of error
  95+ 5F75              CONTAD          equ     ERRLIN+$02      ; (2) Where to CONTinue
  96+ 5F75              TMRCNT          equ     CONTAD+$02      ; (4) TMR counter for 1/100 seconds
  97+ 5F75              CTC0IV          equ     TMRCNT+$04      ; (3) CTC0 interrupt vector
  98+ 5F75              CTC1IV          equ     CTC0IV+$03      ; (3) CTC1 interrupt vector
  99+ 5F75              CTC2IV          equ     CTC1IV+$03      ; (3) CTC2 interrupt vector
 100+ 5F75              CTC3IV          equ     CTC2IV+$03      ; (3) CTC3 interrupt vector
 101+ 5F75              ; - - - - - - - - - - - - - - - - - - -   VIDEO REGISTERS - FROM HERE...
 102+ 5F75              SCR_SIZE_W      equ     CTC3IV+$03      ; (1) screen width (it can be either 40 chars or 32 chars/bytes)
 103+ 5F75              SCR_SIZE_H      equ     SCR_SIZE_W+$01  ; (1) screen height (it can be 24/48/192: 24 for text, 48 for MC, 192 for graphics)
 104+ 5F75              SCR_MODE        equ     SCR_SIZE_H+$01  ; (1) screen mode (0=text, 1=G1, 2=G2, 3=MC, 4=ExG2)
 105+ 5F75              SCR_NAM_TB      equ     SCR_MODE+$01    ; (2) video name table address
 106+ 5F75              SCR_CURS_X      equ     SCR_NAM_TB+$02  ; (1) cursor X
 107+ 5F75              SCR_CURS_Y      equ     SCR_CURS_X+$01  ; (1) cursor Y
 108+ 5F75              SCR_CUR_NX      equ     SCR_CURS_Y+$01  ; (1) new cursor X position
 109+ 5F75              SCR_CUR_NY      equ     SCR_CUR_NX+$01  ; (1) new cursor Y position
 110+ 5F75              SCR_ORG_CHR     equ     SCR_CUR_NY+$01  ; (1) original char positioned under the cursor
 111+ 5F75              CRSR_STATE      equ     SCR_ORG_CHR+$01 ; (1) state of cursor (1=on, 0=off)
 112+ 5F75              LSTCSRSTA       equ     CRSR_STATE+$01  ; (1) last cursor state
 113+ 5F75              PRNTVIDEO       equ     LSTCSRSTA+$01   ; (1) print on video buffer (1=on / 0=off) set to off on graphic only modes
 114+ 5F75              CHR4VID         equ     PRNTVIDEO+$01   ; (1) char for video buffer
 115+ 5F75              FRGNDCLR        equ     CHR4VID+$01     ; (1) foreground color as set by SCREEN or COLOR commands
 116+ 5F75              BKGNDCLR        equ     FRGNDCLR+$01    ; (1) background color as set by SCREEN or COLOR commands
 117+ 5F75              TMPBFR1         equ     BKGNDCLR+$01    ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 118+ 5F75              TMPBFR2         equ     TMPBFR1+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 119+ 5F75              TMPBFR3         equ     TMPBFR2+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 120+ 5F75              TMPBFR4         equ     TMPBFR3+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 121+ 5F75              VIDEOBUFF       equ     TMPBFR4+$02     ; (40) buffer used for video scrolling and other purposes
 122+ 5F75              VIDTMP1         equ     VIDEOBUFF+$28   ; (2) temporary video word
 123+ 5F75              VIDTMP2         equ     VIDTMP1+$02     ; (2) temporary video word
 124+ 5F75              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO VPD OUT OF THIS RANGE,
 125+ 5F75                                                      ; OTHERWISE YOU WILL HAVE TO CHECK THE POINTER IN "CLR_RAM_REG" FUNCTION
 126+ 5F75              ; - - - - - - - - - - - - - - - - - - -   SOUND & KEYBOARD REGISTERS - FROM HERE...
 127+ 5F75              CHASNDDTN       equ     VIDTMP2+$02     ; (2) sound Ch.A duration (in 1/100s)
 128+ 5F75              CHBSNDDTN       equ     CHASNDDTN+$02   ; (2) sound Ch.B duration (in 1/100s)
 129+ 5F75              CHCSNDDTN       equ     CHBSNDDTN+$02   ; (2) sound Ch.C duration (in 1/100s)
 130+ 5F75              KBDNPT          equ     CHCSNDDTN+$02   ; (1) temp cell used to flag if input comes from keyboard
 131+ 5F75              KBTMP           equ     KBDNPT+$01      ; (1) temp cell used by keyboard scanner
 132+ 5F75              TMPKEYBFR       equ     KBTMP+$01       ; (1) temp buffer for last key pressed
 133+ 5F75              LASTKEYPRSD     equ     TMPKEYBFR+$01   ; (1) last key code pressed
 134+ 5F75              STATUSKEY       equ     LASTKEYPRSD+$01 ; (1) status key, used for auto-repeat
 135+ 5F75              KEYTMR          equ     STATUSKEY+$01   ; (2) timer used for auto-repeat key
 136+ 5F75              CONTROLKEYS     equ     KEYTMR+$02      ; (1) flags for control keys (bit#0=SHIFT; bit#1=CTRL; bit#2=C=)
 137+ 5F75              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO PSG OUT OF THIS RANGE,
 138+ 5F75                                                      ; OTHERWISE YOU WILL HAVE TO CHANGE THE POINTER IN "initPSG" FUNCTION
 139+ 5F75              SERIALS_EN      equ     CONTROLKEYS+$01 ; (1) serial ports status: bit 0 for Port1 (A), bit 1 for Port2 (B): 0=OFF, 1=ON
 140+ 5F75              SERABITS        equ     SERIALS_EN+$01  ; (1) serial port A data bits
 141+ 5F75              SERBBITS        equ     SERABITS+$01    ; (1) serial port B data bits
 142+ 5F75              DOS_EN          equ     SERBBITS+$01    ; (1) DOS enable/disable (1/0)
 143+ 5F75              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 144+ 5F75                                                      ; from here there are the RAM locations that
 145+ 5F75                                                      ; are saved during SAVE
 146+ 5F75              PROGND          equ     DOS_EN+$01      ; (2) End of program
 147+ 5F75              VAREND          equ     PROGND+$02      ; (2) End of variables
 148+ 5F75              ARREND          equ     VAREND+$02      ; (2) End of arrays
 149+ 5F75              NXTDAT          equ     ARREND+$02      ; (2) Next data item
 150+ 5F75              FNRGNM          equ     NXTDAT+$02      ; (2) Name of FN argument
 151+ 5F75              FNARG           equ     FNRGNM+$02      ; (4) FN argument value
 152+ 5F75              FPREG           equ     FNARG+$04       ; (3) Floating point register
 153+ 5F75              FPEXP           equ     FPREG+$03       ; (1) Floating point exponent
 154+ 5F75              SGNRES          equ     FPEXP+$01       ; (1) Sign of result
 155+ 5F75              PBUFF           equ     SGNRES+$01      ; (13) Number print buffer
 156+ 5F75              MULVAL          equ     PBUFF+$0D       ; (3) Multiplier
 157+ 5F75              PROGST          equ     MULVAL+$03      ; (100) Start of program text area
 158+ 5F75              STLOOK          equ     PROGST+$64      ; Start of memory test
 159+ 5F75
# file closed: ../include/workspace/workspace-r1.1.asm
 101  5F75
 102  5F75              ; END OF ASSEMBLY SOURCE
 103  5F75              ;-------------------------------------------------------------------------------
 104  5F75
# file closed: LM80C_64K-firmware-r1.14.asm

Value    Label
------ - -----------------------------------------------------------
0x61B3   CHCSNDDTN
0x61B1   CHBSNDDTN
0x601D   NMIFLG
0x5F5C   CNTCP2RAM
0x5F75   END_OF_FW
0x5F31   RAMRUN
0x8000   TMP_FW_LOC
0x4E62   CLCN323
0x4E39   CLCN325
0x4E17   CLCN322
0x4E14   CLCN321
0x4E00   CLCN32Z
0x4DD8   CLCN32T
0x4DD3   DIV_32_16SB
0x4DD0   DIV_32_16OF
0x4DBF   DIV_32_16LP
0x4DAA   DV16_16_LP
0x4D99   DIV_16_8LP
0x4D8A   DIV_8_8LOOP
0x4D78   MU32_2
0x4D6D   MUL_32L
0x4D5E   EXMUL16
0x4D55   MLP1
0x4D4E   MLP
0x4D2E X TSTBIT
0x4CE7   BINIT
0x4CFA   CHKBIN
0x4CC9   BITOUT2
0x4CC5   BITOUT
0x4CB7   ZEROSUP
0x4CB1 X BIN2
0x4C99   NOSUB7
0x4C9D   HEXIT
0x4C79   HEXLP
0x4C7E   HEXLP1
0x4CA6   HXERR
0x4C86   GETHEX
0x4C69   ADD301
0x4C59   ADD30
0x4C43   HEX4
0x4C41   HEX3
0x4C32   HEX1
0x4C34   HEX2
0x4BF1   CNFRQN
0x4BC0   RNDKTX
0x4B7A   OPRCMP
0x4B42   MSPTOK
0x4B2E X INITFN
0x4B20 X INITDSK
0x4B62   FRMTXT
0x4B13   CFINIT
0x4B4A   MSTTXT
0x4B8F   DSKUND
0x4B9C   DSKRNM
0x4AFB   RWMSSC
0x4B00   DSKFRM
0x6112   TPHL
0x4AAD   ABRTXT
0x4A91   ERASED
0x4A9F   ABRTDS
0x4BCE   CNFREQ
0x4A83   ERSTX
0x4BF3   CHKFLNM
0x49F9   TXTRNM
0x4A0A   SVERR
0x49D5   SVEND
0x4A0F   TXTSVG
0x49DC   RENFIL
0x49AE   SAVE1
0x49C3   SAVESCT
0x4A36   DOS_ERR
0x48EE   LDERR
0x4919   GET4AR
0x48E7   LDEND
0x48F3   TXTLDG
0x4A3D   CHK1AR
0x4BFD   CHKFN1
0x48D2   LOADST
0x4904   LDSVPT
0x48A4   CHKDOS
0x486C   PRTEND
0x4860   PRTK1
0x485D   OPNQT1
0x4845   CLSQT1
0x48A1   CHKEY5
0x482D   PTCHR1
0x489E   CHKEY4
0x4835   CLSQT
0x47F8   PRTK3
0x4810   PRTCHR
0x4847   OPNQT
0x47FB   CNTLTK
0x47E6   LDKEY
0x4895   CHKEY2
0x485F   PRTCKEY
0x4890   CHKEY1
0x47CF X PRTK2
0x47CD   PRTK4
0x47B9   CPKYEND
0x47B1   CPKEY1
0x47A9   CPKEY3
0x47A2   CPKEY2
0x4792   CPKEY
0x4784   DECLN1
0x486E   SETREP
0x4754   KEYCH
0x47BB   LSTKEYS
0x4732   HLPERR
0x4710   DIRMOD
0x46D7   EXNRM
0x46C9   ENCHB
0x469E   SRLCNT
0x4686   STRPAR
0x4669   SETPAR2
0x465A   BITS8
0x464F   BITS7
0x465E   SETPAR
0x4645   BITS6
0x4622   SET_CTC
0x46F4   CTC_CFG
0x46FF   SCERR1
0x4611   SET_PT
0x45F8   CKBPS
0x46DE   SUP_BPS
0x45EC   SETSER
0x45DF   DEFSER
0x4594   CNTSER3
0x4577   CNTRX2
0x4582   CNTSER2
0x4544   SERLED
0x453E   SRPT2
0x451B   RPTRSSR
0x450E   RSTSERS
0x4548   CNTSER
0x450A   CHKZSER
0x44FB   SERVAR
0x4703   SCERR
0x6189   SIOBFR
0x6188   STPBT
0x6187   PARBT
0x6186   DATABT
0x6184   BPS
0x6183   PRTNUM
0x44B5   RPTCVBF
0x44A6   RPCLTMB
0x4499   CNTVALY
0x4469   CNTCL7
0x4445   CNTCL6
0x4421   CNTCL5
0x43FF   CNTCL4
0x43D9   CNTCL3
0x43B5   CNTCL2
0x4493   VALIDY
0x4391   CNTCL1
0x448E   VALIDX
0x4362   PLTCRL
0x4353   DLSZ
0x436B   ENDCRL
0x4326   RPTCL1
0x4313   RPTCRL
0x436F   DRWCRL
0x618D   DC
0x618B   YI
0x6189   XI
0x6185   YC
0x6183   XC
0x42A2   DXGR
0x42CB   ENDDRAW
0x4272   CNTDRW
0x4256   RPTDRW
0x4253   STRE2
0x4246   ER2
0x4D7F   negHL
0x4223   Y1GR
0x41F9   X1GR
0x4D7C   absHL
0x44AD   CLRVDBF
0x449E   CLRTMBF
0x618F   DX
0x618D   SY
0x618B   SX
0x6189   E2
0x6187   ER
0x6185   Y2
0x6183   X2
0x617D   Y1
0x617B   X1
0x4D86   DIV_8_8
0x4163   PXLSET
0x413F   CNTPLT1
0x415F   NOGD
0x416B   XY2HL
0x40DA   PNTEND
0x40E4   CTPOINT
0x4091   PAINT5
0x4060   PAINT3
0x40A1   CHECKPY
0x404D   PAINT2
0x411E   CNTPLOT
0x401D   MNPAINT
0x401A   PAINT1
0x4019   PAINT11
0x40A0   CHECKPA
0x400B   PAINT0
0x4098   EXITPAI
0x3FFE   NXTLOOP
0x409C   EXITPA2
0x40F8   PNTRTN
0x44BC   CLRPRM
0x6187   ORGSP
0x6186 X SPB
0x6185 X SPA
0x6183   PNT
0x3F90   GPCPCH1
0x3F86 X GPCPCHR
0x3F6C   GPNTCO1
0x3F62 X GPNTCOL
0x3F57   RPGPNT
0x3F42   GPNT
0x3F2D   CNTGPT2
0x3FAD   CKCOL
0x6189   TMPHL
0x6187   NUMCHR
0x6185   CHRPNT
0x6183   TMPADR
0x617B   MIXCOL
0x617D   TMPCLR
0x6181   GY
0x617F   GX
0x44D5   GMERR
0x3EC7   CHKG2M
0x3EC1   CHKCLR0
0x3E8C   RPTLDCL
0x3E83   LOADCLR
0x3E97   SETBRCL
0x3EB0   MIXCLRS
0x3E7C   CLREX2
0x3E73   CLRG2
0x3E6A   CLRG1
0x3E60   CLRTXT
0x3E63   CLRMC
0x3EBD   CHKCLR1
0x3DB8   CKMAGN
0x3E05   CHKSCAR
0x3DAD X SETVDP
0x3DC6   SCVDP
0x3D89   RPTPS
0x3D84 X DIR_PAU
0x3D5E X RECWRD
0x3D3A X ARET
0x3D15   ATNTAB
0x3D0B   ATN1
0x3CC4   SINTAB
0x3CA8   SIN1
0x3CC0   QUARTR
0x3CBC   HALFPI
0x3C55   RND2
0x3C39   RND1
0x3C66   RNDTAB
0x6010   LSTRND
0x3C5E   RESEED
0x5FED   SEED
0x3BE5   SUMLP
0x3BDC   SMSER1
0x3BAC   EXPTAB
0x3B54   POWER2
0x3B37   POWER1
0x3B19   NEGAFT
0x3AE4   EXPTEN
0x3AF1   NOENED
0x3AC6   SUPTLZ
0x3AD2   DOEBIT
0x3AA1   TRYAGN
0x3A92   DIGTXT
0x3B07   POWERS
0x3A81   MAKNUM
0x3A5C   GTSIXD
0x3A65   INRNG
0x3A47   SIXDIG
0x3AF4   RNGTST
0x3AEE   JSTZER
0x3A38   SPCFST
0x61D4   PBUFF
0x39E2   MULTEN
0x39D7   ENDCON
0x39E1   SCALPL
0x39CB   SCALMI
0x3A0B   EDIGIT
0x39B6   EXPLP
0x39C8   CONEXP
0x39C4   DPOINT
0x39E9   ADDIG
0x39A0   MANLP
0x3998   CNVNUM
0x3979   MLDBLP
0x3951   DCBCDE
0x391A   CMPFP
0x38E2   DETHLB
0x38DB   INCHL
0x388E   RETREL
0x386E   MLSP10
0x3861   OVTST1
0x3866   OVTST2
0x3867   OVTST3
0x3813   RESDIV
0x5FDF   DIVSUP
0x3800   DIVLP
0x5FEB   DIV4
0x5FE0   DIV1
0x5FE4   DIV2
0x5FE8   DIV3
0x37CD   DIV10
0x3765   NOMADD
0x3754   MUL8LP
0x3777   BYTSFT
0x374B   MULT8
0x61E1   MULVAL
0x3843   ADDEXP
0x3729   FPMULT
0x3720   MULLN2
0x3A00   RSCALE
0x3BCD   SUMSER
0x37DB   DVBCDE
0x36DB   LOGTAB
0x36D7   UNITY
0x36C5   SHRLP
0x36C2   SHRITE
0x36B5   SCALLP
0x61D3   SGNRES
0x3686   FPROND
0x3675   RONDB
0x3659   NORMAL
0x3655   SAVEXP
0x3661   PNORM
0x363C   CONPOS
0x36C9   SHRT1
0x3674   RONDUP
0x3693   PLUCDE
0x362E   MINCDE
0x36B3   SCALE
0x38EB   SIGNS
0x3608   NOSWAP
0x35EB   SUBCDE
0x35E5   SUBPHL
0x35EE   FPADD
0x3B03   HALF
0x35DC   ROUND
0x35D9 X ENDINK2
0x35BE   CHKINK
0x35BA   SRTINK
0x35D0   ENDINK
0x35A6   INKEY2
0x3597   CMP_A
0x3545   NOS3
0x352C   NOS2
0x3519   NOS1
0x34E9   SNDOVR
0x353C   WRTSND
0x34B4   SND1
0x3446   RPVOLCG
0x3452   VOLCH
0x33AB   PKEPRMS
0x3395   SYSRET
0x3387   NOSYSPR
0x3349   NMIINT
0x3355   NMIVR1
0x333F   NMIEINT
0x333B   NMI2
0x3346   NMIDINT
0x3319   DISNMI
0x332A   NM1
0x5FDD   OTPORT
0x32E2   WAITLP
0x32E1   NOXOR
0x5FDC   OUTSUB
0x32EB   SETIO
0x6014   INPSUB
0x6015   INPORT
0x32AA   VAL2
0x32AD   VAL3
0x3654   RESZER
0x326B   RSTSTR
0x32B6   MIDNUM
0x3237   LVINSTR
0x3241   CNTZIN
0x31E1   RP2INST
0x320A   CNT1INS
0x31BA   RPTINST
0x322C   RZINSTR
0x6191   DY
0x31A9   EMPTINS
0x618B   TF
0x6189   TP
0x6187   PT2
0x6183   PT
0x6181   ADRS2
0x617F   LNS2
0x617D   ADRS1
0x617B   LNS1
0x3130   ALLFOL
0x3128   MID1
0x4D08   BINERR
0x3126   RIGHT1
0x32B1   LFRGNM
0x3301   MAKINT
0x3105 X GTFLNM
0x30F6   GETLEN
0x30DF   POPHL
0x30C0   GETSTR
0x30B7   TSALP
0x30AD   SSTSA
0x30C6   GSTRHL
0x301A   GRBARY
0x3051   SCNEND
0x2FFA   GNXARY
0x302B   STRADD
0x2FFB   ARRLP
0x2FE5   SMPVAR
0x3028   STPOOL
0x2FD4   GRBLP
0x2FC6   GARBLP
0x2FB7   TESTOS
0x2F9B   GRBDON
0x2F8A   PRSLP
0x2F7F   PRNUMS
0x2F60   TSTOPL
0x2F54   CRTSTE
0x2F45   QTSTLP
0x2F2F   MKTMST
0x30B6   TOSTRA
0x2F32   CRTMST
0x2F99   TESTR
0x311E   TOPOOL
0x2F10   STR1
0x2F38   SVSTAD
0x2EF9   CHEKFN
0x2E71   PASSA
0x389C   RETINT
0x2FC3   GARBGE
0x2E5C   FRENUM
0x2E3B   ENDTMR
0x2E07   FNDELP
0x2E26   ENDDIM
0x2DE5   ZERARY
0x3971   MLDEBC
0x2DC7   DEFSIZ
0x2DBF   CRARLP
0x2D9F   BSERR
0x2E02   FINDEL
0x2D86   NXTARY
0x2DA4   CREARY
0x2D72   FNDARY
0x2D4A   SCPTLP
0x2D28   ZEROLP
0x2D39   RETNUL
0x2D36   RETADR
0x2CF7   FNTHR
0x2D02   CFEVAL
0x2CE9   FNDVAR
0x3775   POPHRT
0x61CB   FNARG
0x2D44   SBSCPT
0x2CCF   NSCFOR
0x2D6C   ARLDSV
0x2CBF   NOTSTR
0x2CA4   ENDNAM
0x2CB0   CHARTY
0x2CA3   SVNAM2
0x2C8C   GTFNAM
0x6108   LCRFLG
0x2C79   DIMRET
0x3897   FLGREL
0x3890   FLGDIF
0x2C40   CMPSTR
0x30C7   GSTRDE
0x30C3   GSTRCU
0x2C58   CMPRES
0x2C16   CMPLG1
0x2C14   CMPLOG
0x2BFD   PXOR1
0x2BF0 X PAND1
0x2BF5   POR1
0x2E61   ACPASS
0x38C6   FPBCDE
0x2BD5   CNTLGC
0x2BBB   SGNEXP
0x2BB2   GOFUNC
0x2BAA   FNVAL
0x2B6B   FRMEVL
0x2B63   RETNUM
0x38AE   INVSGN
0x2B4F   EVLPAR
0x2B79   FNOFST
0x2EA3   DOFN
0x2C62   EVNOT
0x2B57   MINUS
0x4CDD   BINTFP
0x4C6D   HEXTFP
0x2B2C   NOTAMP
0x2B68   CONVAR
0x38B6   STAKFP
0x2AEA   STKTHS
0x3076   CONCAT
0x2C02   TSTRED
0x614A   CUROPR
0x2AC2   FOPRND
0x2AA6   RLTLP
0x2A99   EVAL3
0x6155   NXTOPR
0x2A96   EVAL2
0x2B01   OPRND
0x2A8D   EVAL1
0x2A86   OPNPAR
0x2A7C   TSTSTR
0x2A68   KILFOR
0x38D4   LOADFP
0x35DF   ADDPHL
0x38C3   PHLTFP
0x2A30   NEXT1
0x2A22   FANDT
0x29F9   EXTIG
0x29DE   MORDT
0x398C   ASCTFP
0x29D2   LTSTND
0x2F42   DTSTR
0x29B8   ITMSEP
0x29BB   STRENT
0x29C7   INPBIN
0x2A09   FDTLP
0x299D   ANTVLU
0x2971   NEDMOR
0x2975   GTVLUS
0x2969   NXTITM
0x2944   NOPMPT
0x2EEB   IDTEST
0x6152   READFG
0x2919   BADINP
0x2907   REDO
0x28F8   SPCLP
0x28F1   DOSPC
0x32FB   FNDNUM
0x28D1   ZONELP
0x28BE   CNTEND
0x2F83   PRS1
0x2F3E   CRTST
0x3A2A   NUMASC
0x289B   PRNTST
0x2900   NEXITM
0x28C3   DOCOM
0x28DC   DOTAB
0x2854   PRNTLP
0x284D   MRPRNT
0x2836   IF0
0x283F   IF1
0x282D   IFGO
0x2811   ONGOLP
0x2810   ONGO
0x32FE   GETINT
0x38DD   FPTHL
0x38E0   DETHL4
0x2F1A   SAVSTR
0x30E1   BAKTMP
0x6144   TMPSTR
0x27F1   MVSTPT
0x27E9   CRESTR
0x61CF   FPREG
0x27C2   LETSTR
0x27FA   LETNUM
0x2A7D   CHKTYP
0x2A8A   EVAL
0x6109   TYPE
0x2C87   GETVAR
0x2799   NXTSTT
0x2796   NXTSTL
0x278F   NXTDTA
0x278A   RETLIN
0x274C   RUNLIN
0x2705   STORED
0x26BB   GTLNLP
0x26B8   GETLN
0x3900   CMPNUM
0x392D   FPINT
0x61D2   FPEXP
0x2697   DEPINT
0x2694 X POSINT
0x34EF   NOISUP
0x2691   FPSINT
0x2689   CHKLTR
0x601B   CHKSUM
0x267C X ACCSUM
0x265D   ERRINT
0x6157   ERRLIN
0x264C   NOLIN
0x2636   INPBRK
0x601E   BRKFLG
0x2620   STALL
0x262A   BRK
0x61C7   NXTDAT
0x260D   UPDATA
0x260C   RESTNL
0x25CF   ONJMP
0x25CE   IFJMP
0x2639   ENDPRG
0x25A7   RUNCNT
0x25A3   PUTFID
0x3885   TSTSGN
0x259A   SAVSTP
0x38D1   BCDEFP
0x2A78   GETNUM
0x2A7B   TSTNUM
0x255E   FORFND
0x2542   FORSLP
0x614C   LOOPST
0x2527   CNTWTSP
0x251B   WTSPC
0x2513   LVSRLN
0x2508   SRCLN1
0x24E5   OUTWRD
0x24F3   NXTLN
0x24CC   LSTLP3
0x24C9   LSTLP2
0x24BD   LST07
0x24BA   LST08
0x407F   PAINT4
0x248F   LST02
0x248C   LST05
0x244F   LST06
0x2478   LST03
0x2453   LSTNOT
0x2434   LST01H
0x2498   LISTLP
0x2507   SRCLN
0x2501   SRCHLIN
0x2431   LST01
0x2460   LSTALL
0x3D3B   GETINP
0x4D0D   MONOUT
0x23DC   SND2VID
0x23C9   INCLEN
0x6107   CURPOS
0x6017   LWIDTH
0x23CD   DINPOS
0x2FB5   POPAF
0x239E   CHKSYN
0x238F   OUTIT
0x2392   OUTNBS
0x4D35   OUTNCR
0x237B   PUTBUF
0x28AA   ENDINP
0x2375   GMNCR
0x2380   PUTCTL
0x2340   PROCES
0x23EA   CLOTST
0x2318   KILIN
0x230D   DELCHR
0x2327   MORINP
0x2315   OTKLN
0x2301   ECHDEL
0x6019   NULFLG
0x22ED   DODEL
0x22D4   NXTCHR
0x22CE   TSTREM
0x22CB   SETLIT
0x22AD   NOCHNG
0x22A4   NOSPC
0x22B5   MATCH
0x2293   NXTBYT
0x2283   GETNXT
0x2281   SEARCH
0x22B9   RETNAD
0x2268   FNDWRD
0x22E4   ENDBUF
0x22DD   CPYLIT
0x22BD   MOVDIR
0x223E   CRNCLP
0x610A   DATFLG
0x601F   RINPUT
0x2219   DOAGN
0x61C9   FNRGNM
0x6150   FORFLG
0x6159   CONTAD
0x6136   TMSTPT
0x6138   TMSTPL
0x61C3   VAREND
0x6148   STRBOT
0x6153   BRKLIN
0x21EA   INTVAR
0x21BD   SRCHLP
0x60AA   BASTXT
0x21AE   FNDEND
0x21A2   PTRLP
0x21E6   RUNFST
0x2195   MOVBUF
0x219D   SETPTR
0x2167   SFTPRG
0x2176   INEWLN
0x2766   ULERR
0x215F   LINFND
0x21BA   SRCHLN
0x6151   LSTBIN
0x25C7   EXCUTE
0x2235   CRUNCH
0x231E   GETLIN
0x210B   GETCMD
0x20FD   POPNOK
0x3A17   LINEIN
0x6026   HLPLN
0x20F9   PTLN
0x20DC   ERRIN
0x28A2   STTLIN
0x601A   CTLOFG
0x20B6   NRERR
0x20B3   IMERR
0x20B0   TMERR
0x20AD   OVERR
0x20AA   UFERR
0x20A7   DDERR
0x20A4   NFERR
0x20A1   DZERR
0x614E   DATLIN
0x2098   DATSNR
0x2096   LDG1ND
0x2085   LDG1
0x2078   EXITGM
0x20B8   ERROR
0x2073   OMERR
0x61C5   ARREND
0x205B   CHKSTK
0x2050   MOVLP
0x204D   MOVSTR
0x2064   ENFMEM
0x204A   MOVUP
0x2041   INDFND
0x202B   LOKFOR
0x2027   BAKSTK
0x2021   BRKMSG
0x201C   OKMSG
0x201B   ZERBYT
0x2017   INMSG
0x2010   ERRMSG
0x1F8E X DEFFNKS
0x1F8C   AUTORP
0x231E   TTYLIN
0x26B2   FCERR
0x2BCE   POR
0x2BD3   PXOR
0x2BCB   PAND
0x363F   BNORM
0x3B27   POWER
0x377C   DINT
0x3784   MOD
0x37D9   DIV
0x3727   MULT
0x35E9   PSUB
0x3A06   PADD
0x1F19   PRITAB
0x00EA   ZLEFT
0x00E2   ZINSTR
0x00E1   ZPOINT
0x00CB   ZSGN
0x00CA   ZLTH
0x00C9   ZEQUAL
0x00C8   ZGTR
0x00C7   ZOR
0x00C3 X ZDINT
0x00C2 X ZMOD
0x00C1 X ZDIV
0x00C0 X ZTIMES
0x00BF   ZMINUS
0x00BE   ZPLUS
0x00BD   ZSTEP
0x00BC   ZNOT
0x00BB   ZTHEN
0x00BA   ZSPC
0x00B9   ZFN
0x00B8   ZTO
0x00B7   ZTAB
0x00B6   ZNEW
0x00B0   ZPRINT
0x00AF   ZELSE
0x008E   ZREM
0x008C   ZGOSUB
0x0088   ZGOTO
0x0083   ZDATA
0x0081   ZFOR
0x0080   ZEND
0x21DA   NEW
0x4951   SAVE
0x48AE   LOAD
0x26DC   CLEAR
0x2405   LIST
0x2663   CONT
0x2851   PRINT
0x4D10   RESET
0x3369   SYS
0x3D51   WIDTH
0x3ED0   GPRINT
0x330F   NMI
0x4737   KEY
0x3D3D   CLS
0x4719   HELP
0x44DA   SERIAL
0x3FC0   PAINT
0x42CF   CIRCLE
0x4103   PLOT
0x3E15   COLOR
0x3D7B   PAUSE
0x3424   VOLUME
0x345D   SOUND
0x33D1   LOCATE
0x3551   VREG
0x3403   SREG
0x33C6   VPOKE
0x3D64   DOKE
0x33C1   POKE
0x2E76   DEF
0x32CD   WAIT
0x4AB6   DISK
0x4A56   ERASE
0x4A1F   FILES
0x2801   ON
0x32C7   POUT
0x262F   STOP
0x2792   REM
0x276B   RETURN
0x273C   GOSUB
0x25F7   RESTOR
0x281F   IF
0x2728   RUN
0x274D   GOTO
0x27A7   LET
0x2964   READ
0x2C82   DIM
0x292A   INPUT
0x2790   DATA
0x2A2D   NEXT
0x252E   FOR
0x2631   PEND
0x1EAB   WORDTB
0x1D1A   WORDS
0x3252   MID
0x3248   RIGHT
0x3122   LEFT
0x4CAB   BIN
0x4C1A   HEX
0x3112   CHR
0x3101   ASC
0x3282   VAL
0x2F0A   STR
0x457E   RXEND
0x30F2   LEN
0x3152   INSTR
0x40B0   POINT
0x358C   INKEY
0x3578   SSTAT
0x356D   VSTAT
0x339E   VPEEK
0x3D59   DEEK
0x3397   PEEK
0x3CEE   ATN
0x3CD9   TAN
0x3D9A   SCREEN
0x3C78   SIN
0x3C72   COS
0x3B6C   EXP
0x36E8   LOG
0x3BFD   RND
0x3B1E   SQR
0x2E6E   POS
0x32BB   INP
0x2E40   FRE
0x6185   PT1
0x5FD9   USR
0x38AA   ABS_
0x3958   INT
0x2E2A   TMR
0x3894   SGN
0x1CD6   FNCTAB
0x20FE   PRNTOK
0x4744   RESFN
0x1C4A   BRKRET
0x60B2   STACK
0x1C5F   BFREE
0x3A1F   PRNTHL
0x1C56   BLNSPC
0x1CAE   DOSMSG
0x1C37   SETTP1
0x21DB   CLRPTR
0x6022   STRSPC
0x610B   LSTRAM
0x1C07   NODOS
0x2398   CPDEHL
0x209E   SNERR
0x26B7   ATOH
0x1BE2   SETTOP
0x1BBE   MLOOP
0x6248   STLOOK
0x1BD0   TSTMEM
0x25E7   GETCHR
0x221D   PROMPT
0x1CCB   MEMMSG
0x1BA8   MSIZE
0x1BBB   MNOASK
0x346B   CTSNDC
0x61E4   PROGST
0x28B4   PRNTCRLF
0x2200   CLREG
0x24DB   FNDTOK
0x2010   INITBE
0x1F37   INITAB
0x1B8D   SYSINIT
0x5FD3   WRKSPC
0x2E62   ABPASS
0x2897   PRNTNB
0x269D   DEINT
0x1B86   CSTART
0x1C47   WARMST
0x1B7F   STARTB
0x1930 X ERRORS
0x1B6A   D8MSG
0x192E X D8PTR
0x1B5E   D7MSG
0x192C X D7PRT
0x1B4A   D6MSG
0x192A X D6PTR
0x1B40   D5MSG
0x1928 X D5PTR
0x1B3B   D4MSG
0x1926 X D4PTR
0x1B36   D3MSG
0x3987   NOMLAD
0x1924 X D3PRT
0x1B28   D2MSG
0x1922 X D2PRT
0x1B1C   D1MSG
0x1920 X D1PRT
0x1B0C   D0MSG
0x191E X D0PTR
0x1AFB   NRMSG
0x191C X NRPRT
0x1AE5   IMMSG
0x191A X IMPRT
0x1ADB   HPMSG
0x1918 X HPPTR
0x1AC5   SOMSG
0x1AAC   SAMSG
0x1914 X SAPTR
0x1A97   SCMSG
0x1912 X SCPTR
0x1910 X GMPRT
0x1A7B   BNMSG
0x190E X BNPTR
0x1A70   HXMSG
0x190C X HXPTR
0x1A60   MOMSG
0x190A X MOPTR
0x1908 X UFPTR
0x1A3B   CNMSG
0x1906 X CNPTR
0x1A20   STMSG
0x1904 X STPTR
0x1916 X SOPTR
0x1A10   LSMSG
0x1902 X LSPTR
0x19FC   OSMSG
0x4D6B   MU32_1
0x1900 X OSPTR
0x19ED   TMMSG
0x18FE X TMPTR
0x19D9   IDMSG
0x18FC X IDPTR
0x19C8   DZMSG
0x18FA X DZPTR
0x19B3   DDMSG
0x18F8 X DDPTR
0x19A5   BSMSG
0x18F6 X BSPTR
0x1996   ULMSG
0x4898   CHKEY3
0x18F4 X ULPTR
0x1988   OMMSG
0x18F2 X OMPTR
0x197F   OVMSG
0x18F0 X OVPTR
0x1969   FCMSG
0x18EE X FCPTR
0x195D   ODMSG
0x18EC X ODPTR
0x1948   RGMSG
0x18EA X RGPTR
0x1941   SNMSG
0x18E8 X SNPTR
0x1930   NFMSG
0x18E6 X NFPTR
0x18E6   ERRTBL
0x003E   D3
0x0038   D0
0x0036   NR
0x0034   IM
0x0032   HP
0x0030   SO
0x002E   SA
0x002C   SC
0x002A   GM
0x0028   BN
0x0026 X HX
0x0024   MO
0x0022   UF
0x0020   CN
0x001E   ST
0x28F6   ASPCS
0x001C   LS
0x001A   OS
0x0018   TM
0x0016   ID
0x0014   DZ
0x0012   DD
0x0010   BS
0x000E   UL
0x000C   OM
0x000A   OV
0x0008   FC
0x0006   OD
0x0004   RG
0x0002   SN
0x0000   NF
0x007F   DEL
0x001B   ESC
0x0015   CTRLU
0x0013   CTRLS
0x0012   CTRLR
0x0011   CTRLQ
0x000F   CTRLO
0x0007   CTRLG
0x18CF   RSTIOBF
0x18CE   CLRBUFF
0x18C4 X CHK_NAM_LV
0x18C3   CHK_C_CF
0x1A4A   UFMSG
0x4C50   BYT2ASC
0x188A   PRN_WHEX1
0x1888 X PRN_WHEX
0x189F   BYTEHEX
0x187F   PRN_HEX1
0x187E X PRN_HEX
0x1875   PRNTSIZ
0x4E04   CLCN32
0x1851   CHKNMVAL3
0x18AF   CHK_NAM
0x1841   CHKNMVAL2
0x60AD   BUFFER
0x183B   CHKNMVAL1
0x182C   CHKDSKVAL2
0x182B   CHKDSKVALE
0x1816   CHKDSKVAL1
0x17F5   CHATOZE
0x17EA   CH0TO9E
0x17E2   CH0TO9
0x17BB   RND_ID1
0x17AF X LDMSCT1
0x1791   CKLSTEN1
0x175B   FNDFRENTR3
0x174B   FNDFRENTR2
0x1748   FNDFRENTR1
0x1750   FNDFRENTR4
0x1731   DSKUNDTXT
0x1717   DSKUNDPR
0x17ED   CHATOZ
0x17CF   RND8
0x172C   DSKUNDFL2
0x16FB   DSKUNDFL1
0x32A0   VAL1
0x16EF   DSKUNDFL
0x16EB X FLNTEXS
0x16E6 X CHKSTNM5
0x16ED   FLEXST
0x16D6   CHKSTNM6
0x16CC   CHKSTNM3
0x16E1   CHKSTNM10
0x16B3   CHKSTNM2
0x16B0   CHKSTNM1
0x169C   FIL_ERA2
0x1691   FIL_ERA1
0x169F   FIL_ERA3
0x1669   FIL_ERA6
0x1670   FIL_ERA5
0x1632   FIL_ERASE
0x1626   LDFL5
0x162D   LDFLEX
0x15EF   LDFL3
0x15CF   LDFL2
0x15CB   LDFL1
0x15AF   LDFL4
0x1588   LODFILE
0x16A9   FILE_EXIST
0x1575   LK4FILE1
0x185D   HL2DE
0x1572   LK4FILE
0x617D   DKNMPT
0x617F   DKLNPT
0x4196   DRAW
0x14F2   CHNGNAM
0x14E6   SAVFL12
0x14C1 X SAVFL11
0x14ED   SAVFLEXT
0x14A1   SAVFL4
0x148F   SAVFL10
0x1473   SAVFL2
0x144B   SAVFL9
0x1403 X SAVFL7
0x13FF   SAVFL6
0x4DA5   DIV_16_16
0x13EC   SAVFL1
0x61C1   PROGND
0x13E4   SAVFL3
0x173C   FNDFRENTR
0x1555   CHKFLEXT
0x13C4   SAVFILE
0x13B0 X EXITFLS
0x1865   PRN16ASCII
0x4D60   MUL_U32
0x1862   PRN32ASCII
0x178B   CKLSTEN
0x1356 X LSTFILES5
0x177F   GTNXTEN
0x2515   TSTSPC
0x2612   TSTBRK
0x186B   PRN16ASCIX
0x131C   LSTFILES21
0x131F   LSTFILESPR
0x13B5   FILETP
0x1314   LSTFILES20
0x12F8   LSTFILES3
0x1777   CKCREN
0x12EA   LSTFILES2
0x176C   PT2FSEN
0x12E7   LSTFILES1
0x1764   SETPTEN
0x179D   LDENTRIES
0x1371   PNTSTATS
0x12B2   INPR1
0x2F80   PRS
0x17F8   CHKDSKVAL
0x1299   LST_FILES
0x128F   TLFLSTX
0x127E   ALFLSTXT
0x1273   TLSCTTX
0x1267   DSKNMTX
0x6111   DOSER
0x0046   D7
0x1258   DOSVERSERR
0x0040   D4
0x1254   LODERR
0x0048   D8
0x1250   FLNTFND
0x003A   D1
0x124C   NAMERR
0x0044   D6
0x1248   DUPLERR
0x0042   D5
0x1244   DSKFULL
0x125F   RET_ERR
0x003C   D2
0x16A4   WRT_ERR
0x17AC   LDMSCT
0x121D   DSK_RNM
0x1217   DOS_FT8
0x1204   DOS_FT9
0x1211   DOS_FT10
0x11EA   DOS_FTA
0x1215   DOS_FT7
0x23A9   OUTC
0x1240   D2ERR
0x17B8   RND_ID
0x11A1 X DOS_FT5
0x125D   D1ERR
0x1830   CHKNMVAL
0x1179   DOS_FT2
0x1858   DE2HL
0x115E X DOS_FT0
0x115F   DOS_FT1
0x1151   DOS_FTC
0x4DBA   DIV_32_16
0x610D   DOSBFR
0x18DA   CLRDOSBF
0x18C5   CLRIOBF
0x10E9   DSK_INIT
0x612D   ENDMEM
0x612B   SRTMEM
0x6129   TPBF4
0x6187   RADIUS
0x6127   TPBF3
0x6125   TPBF2
0x6123   TPBF1
0x6121   RAM_PTR
0x611F   LSW_SCT
0x611D   MSW_SCT
0x611C   SCT_SIZ
0x611A   BYT_SIZ
0x6118   NTR_NBR
0x6116   DIR_SCT
0x6112   DIR_STRT
0x6112   TMPDBF
0x10E7   DSKDIRADR
0x10D8   DFSCT0
0x10D5   CF_WR_EXIT
0x10B4   CF_WR_SEC
0x3AE2   OUTEXP
0x610F   IOBUFF
0x10B1   CF_RD_EXIT
0x10A0   CF_RD_CMD
0x108D   CF_RD_SEC
0x1081   CF_STANDBY
0x107E X CR_DV_ERR
0x107F   CR_DV_RD_E
0x6114   DAT_STRT
0x1072   CR_DV_RD_1
0x134B   LSTFILES6
0x104B   CF_SETSTR
0x103E   CF_DAT_RDY
0x103C   RETERR
0x102F   CF_CMDRDY
0x106D   CR_DEV_RDY
0x101F   CF_NOP
0x1009   CF_INIT
0x0057   CF_CMD
0x0057   CF_STAT
0x0056   CF_LBA3
0x0055   CF_LBA2
0x0054   CF_LBA1
0x0053   CF_LBA0
0x0052   CF_SECCNT
0x0051   CF_FTR
0x0051 X CF_ERR
0x0050   CF_DATA
0x0EE1   CNTFNK
0x0EF4   PRNTFNK
0x0EE7   PUTCHRBUF1
0x0ECD   LDFNKEYCHR
0x602A   FNKEYS
0x6024   LINEAT
0x1C6D   SIGNON
0x0EB4 X LVKBRDCHK
0x0EAD   PNT2VD
0x0EA0   PUTCHRBUF
0x0E8E   SNDKEYTOBFR
0x0EB5   PRNTFNKEY
0x0E86   CHKFNK
0x0F01   FNKEYSORD
0x0E80   CNTKBCK
0x0003   CTRLC
0x6029   AUTOKE
0x3642   BNRMLP
0x0E6D   SENDKEY
0x0E3E   SETNEWAUTO
0x0EB0   LVKBRDCHK2
0x6028   KEYDEL
0x0E4E   CHKAUTO
0x61BA   KEYTMR
0x0E60   NEWKEY
0x0F89   KBMAP_ALT
0x0FC9   KBMAP_CTRL
0x0E05   CHKALT
0x0E0C   LOADMAP
0x0F49   KBMAP_SFT
0x0DFC   CHKCTRL
0x0F09   KBMAP
0x0DE8   CHKLN
0x61B9   STATUSKEY
0x61B8   LASTKEYPRSD
0x0DD0   ENDCTRLCK
0x0DCA   TESTCTRL
0x0DE6   FINDKEY
0x0DBD   TESTALT
0x61B6   KBTMP
0x0DD4   NOKEYPRSD
0x0D8E   RPTKBDRD
0x0D8A   CHECKKBD
0x0D7C   CHECKCTRL
0x61BC   CONTROLKEYS
0x0D6E   CHECKALT
0x0D2E   CNTCHKSND
0x0CF3   CHKSNDCH
0x0CC1   RPTWLCMBP
0x0CD7   NOBPDAT
0x0CBE   SENDSND
0x0CCF   WLCBPDAT
0x0CE4   WRTSNDREG
0x0CDF   SETSNDREG
0x0CA5   SNDREGCFG
0x0C91   CLRPSGREGS
0x0C8D   EMPTSNDBFR
0x0B3F X VDPMODESETEX2
0x0B37 X VDPMODESETMC
0x0B2F X VDPMODESET2
0x2F3F   QTSTR
0x0B27 X VDPMODESET1
0x0B15   SENDCHRPTRNS
0x5671   CHRST88
0x0B13   NXTCHAR
0x4E71   CHRST68
0x0AF5   LDREGVLS
0x0B1F   VDPMODESET
0x0ADE   RSTVDPRAMREG
0x61AF   CHASNDDTN
0x0ACF   EMPTVRM
0x0A64 X CNTNULL2
0x0A57   RPTNLLSRC2
0x4D46   MUL16
0x0A32   ADDNEWLINE
0x09FF   SNDCHRTOBFR
0x09E6   CNTNULL
0x09D6   RPTNLLSRC
0x0A1E   PRNTRETURN
0x6181   TMPBFR4
0x617F   TMPBFR3
0x617D   SRTTXT
0x617D   TMPBFR2
0x09AC   RPTEMPTYROW
0x0991   WRITEBUF
0x0969   LOADNEXTCOL
0x6183   VIDEOBUFF
0x0957   SCROLLNXTRW
0x61AD   VIDTMP2
0x61AB   VIDTMP1
0x0936   EXITCURSOR_ON
0x0920   EXITCURSORDOWN
0x0900   EXITCURSORRGHT
0x08FA   CONTCRSRGT
0x08E7   CHCKYPOS2
0x08CC   EXITCURSORUP
0x08A3   CHKYPOS
0x0890   EXITCURSORLEFT
0x088D   CONTCRSLFT
0x087C   CHCKYPOS
0x0892   MVCRS2LFT
0x084D   MVBKSP
0x0860   LVBKSP
0x0020   SPC
0x0818 X ENDINSRT
0x0813   NXTINST
0x4D3B   CMP16
0x0802   CHKHL
0x617F   ENDTXT
0x0A3F   ENDOFLN
0x617B   CUR_POS
0x07E0   PUTCRSCHR
0x093F   SCROLLUP
0x07A0   SETCRSRY
0x1028   CF_BUSY
0x07A1   SETCSRCOORDS
0x07B3   EXITCHAR2VID
0x0777   NXTCPCK
0x076A   RPTCPCK
0x07C0   PLACEHOLDER
0x000A   LF
0x07E4   INSERTKEY
0x001A   INSRT
0x0903   CURSORDOWN
0x001F   CRSDN
0x08CE   CURSORRIGHT
0x001D   CRSRGT
0x08B5   CURSORUP
0x001E   CRSUP
0x0869   CURSORLEFT
0x001C   CRSLFT
0x0826   BACKSPACE
0x3E32   CNTCKCL
0x0008   BKSP
0x09B8   CRGRETURN
0x000C   CS
0x0019   HOME
0x0739   CHRTBL
0x4D96   DIV_16_8
0x0728   HL2XY
0x0A65   POS_TB_CRS_32
0x071A   CONT_POS_CURS
0x0A95   POS_TB_CRS_40
0x6176   LSTCSRSTA
0x6175   CRSR_STATE
0x06D2   MOVSHOWCRS
0x06E7   NEWCRSRCOORD
0x06FC   RSTCHRCRS
0x0705   LOAD_CRSR_POS
0x06BB   READ_VSTAT
0x06B0   WRITE_VREG
0x069B   WRITE_VIDEO_LOC
0x0686   READ_VIDEO_LOC
0x06CC   MOVCRS
0x6172   SCR_CUR_NX
0x0000   NLLCR
0x6173   SCR_CUR_NY
0x067C   ATHOME
0x06C2   POS_CURSOR
0x066F   CLEARVIDBUF
0x065C   RPTFLL1
0x064A   SNDCLRSET
0x0647   STARTEMPTY
0x0611   CLRG2PTNTBL
0x05F7   RPTEMPTYBUF
0x05F1   LDCOLSTOEMPTY
0x0630   EMPTYMC
0x0600   EMPTYG2
0x05CF   LVCKSPLK
0x05D1   DOCOLDRESET
0x0D39   READKBLN
0x05AD   SNDLOGPT
0x369F   COMPL
0x5E71   LOGOFONT
0x0CBB   NOBEEP
0x0CB5   WLCMBEEP
0x0579   RPT100
0x05BC   CHKSPCK
0x058F   BEEPOFF
0x0583   SETBEEP
0x054D   DEC_D
0x61C0   DOS_EN
0x617B   TMPBFR1
0x053B   RPT104
0x0597   LOADLOGOCHRS
0x0533   RPT103
0x0B47   LM80CLOGO
0x051D   RPT102
0x0C98   RSTPSG
0x051A   RPT101
0x05B7   CLRTABLE
0x056C   ERASECLRTBL
0x0654   SETNAMETABLE
0x0AEB   SET_GFX_MODE2
0x6174   SCR_ORG_CHR
0x05D8   EMPTYVIDBUF
0x0457   LDCLRTBMD1
0x6179   FRGNDCLR
0x0666   SETVDPADRS
0x04E7   ENDVDPSET
0x616E   SCR_NAM_TB
0x6018   COMMAN
0x616C   SCR_SIZE_H
0x616B   SCR_SIZE_W
0x617A   BKGNDCLR
0x6171   SCR_CURS_Y
0x04DE   LDCLRTBEX2
0x6170   SCR_CURS_X
0x0AFF   LOADCHARSET
0x03F6 X TXTMD
0x04A5   EXG2MD
0x0482   MCMD
0x0460   G2MD
0x0420   G1MD
0x616D   SCR_MODE
0x0AD8   CLR_RAM_REG
0x0AE3   SET_GFX_MODE
0x0AC5   EMPTY_VRAM
0x0365   RESTMR
0x036A   CTCCONF
0x033C X SIO_B_SETS
0x0336   SIO_A_SETS
0x1B7C   WARM
0x1B79   COLD
0x0938   CURSOR_OFF
0x031C   ECHO_CHAR
0x030F   CHECKWARM
0x02F8   CORW
0x0923   CURSOR_ON
0x03B4   MSGTXT2
0x0304   COLDSTART
0x5FD2   basicStarted
0x0376   MSGTXT1
0x4D26   INITST
0x03D1   initVDP
0x04F2   SHOW_LOGO
0x0C87   initPSG
0x0340   initCTC
0x02B1   INIT_HW2
0x6104   TEMPSTACK
0x02AE   INIT_HW
0x0D4E   KEYBOARD
0x0CE9   MNGSNDS
0x07C1   FLASHCURSOR
0x029A   CHKCRSR
0x0294   INCTMR3
0x615B   TMRCNT
0x028B   CH3_TIMER
0x027D   RAWPRINT
0x026C   TX_EMP
0x0269   TXA_EXIT
0x0255   RXA_EXIT
0x023F   NOTRDWRAP
0x5FCF   serRdPtr
0x5F75   SERBUF_START
0x0214   NOTWRAP
0x00CD   bufWrap
0x5FCD   serInPtr
0x0208   NOTFULL
0x5FD1   serBufUsed
0x01EB   SIO_B_EI
0x01F1   SIO_RXEN
0x01E3   SIO_A_EI
0x01D9   SIO_RXDI
0x01B5 X B_RTS_ON
0x01BB   SIO_RTS_ON
0x01AD   A_RTS_ON
0x61BF   SERBBITS
0x019D   SIO_RTS_OFF
0x61BE   SERABITS
0x0181   EMPTYCHBBFR
0x01D3   SIO_B_DI
0x0197   B_RTS_OFF
0x4708   SOERR
0x015D   CHABFREMPTY
0x014F   EMPTYCHABFR
0x61BD   SERIALS_EN
0x01CB   SIO_A_DI
0x1A86   GMMSG
0x0757   CHAR2VID
0x6177   PRNTVIDEO
0x61B5   KBDNPT
0x0120   CNTRXCHA
0x000D   CR
0x6178   CHR4VID
0x0131   LVRXCHA
0x01FD   CHARINTOBFR
0x61B7   TMPKEYBFR
0x018F   A_RTS_OFF
0x00EC   FMVEREND
0x00D0 X FWVER
0x5FD6   NMIUSR
0x6168   CTC3IV
0x6165   CTC2IV
0x6162   CTC1IV
0x615F   CTC0IV
0x0278   CKINCHAR
0x0018 X RST18
0x022A   RXA
0x0010 X RST10
0x0136   SPEC_RXA_CNDT
0x0100   RX_CHA_AVAIL
0x0259   TXA
0x0008 X RST08
0x0168   SPEC_RXB_CNDT
0x0165   RX_CHB_AVAIL
0x5F46   ROM2RAM
0x0000 X RST00
0x0005   SER_EMPTYSIZE
0x0050   SER_FULLSIZE
0x0058   SER_BUFSIZE
0x0041   PSG_DAT
0x0040   PSG_REG
0x0031   VDP_SET
0x0030   VDP_DAT
0x0021   SIO_DB
0x0020   SIO_DA
0x0023   SIO_CB
0x0022   SIO_CA
0x0013   CTC_CH3
0x0012   CTC_CH2
0x0011   CTC_CH1
0x0010   CTC_CH0
0x0003   PIO_CB
0x0002 X PIO_CA
0x0001   PIO_DB
0x0000 X PIO_DA
